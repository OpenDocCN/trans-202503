- en: '**6**'
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '**6**'
- en: STORING COLLECTIONS IN DICTIONARIES AND ARRAYS
  id: totrans-1
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将集合存储在字典和数组中
- en: '![Image](Image00001.jpg)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Image00001.jpg)'
- en: In previous chapters, you learned that you can store a single piece of information
    in a variable or constant. But what if you want to store a collection of things,
    like the names of all the places you’ve visited or all the books that you’ve read?
    In this chapter, we’ll introduce you to arrays and dictionaries. They’re both
    used to store collections of values. Using arrays and dictionaries, you can work
    with a lot of data at once and make your programs more powerful!
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的章节中，你学到可以将单个信息存储在变量或常量中。但如果你想存储一个集合，比如你去过的所有地方的名称或你读过的所有书籍呢？在这一章中，我们将向你介绍数组和字典。它们都用于存储值的集合。使用数组和字典，你可以一次性处理大量数据，使你的程序更加强大！
- en: '**KEEPING THINGS IN ORDER WITH ARRAYS**'
  id: totrans-4
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**通过数组保持顺序**'
- en: An *array* is a list of items of the same data type stored in order, kind of
    like a numbered grocery list. Items in an array are stored by their *index* ,
    a number based on where the item is positioned in the array.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: '*数组* 是按顺序存储的同一数据类型项的列表，有点像编号的购物清单。数组中的项是通过它们的 *索引* 来存储的，索引是基于该项在数组中的位置的数字。'
- en: When you write a grocery list, you usually start with the number 1, but in computer
    programming, an index starts at 0, not 1\. So the first item in an array is always
    at index 0, the second item is at index 1, the third item is at index 2, and so
    on.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 当你写购物清单时，通常会从数字1开始，但在计算机编程中，索引是从0开始的，而不是1。因此，数组中的第一个项总是在索引0处，第二个项在索引1处，第三个项在索引2处，以此类推。
- en: 'Let’s create an array. If you already know what you’re going to put into your
    array, you can create it and *initialize* it with those values. To initialize
    something in Swift is to give it some initial value so you can use it in your
    program. Let’s say that you want to store a list of all of the national parks
    that you’ve visited. Enter the following into your playground:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 我们来创建一个数组。如果你已经知道要放入数组的内容，你可以直接创建它并用这些值进行*初始化*。在 Swift 中，初始化意味着赋予某个对象初始值，这样你就可以在程序中使用它。假设你想存储你去过的所有国家公园的列表。在你的
    Playground 中输入以下内容：
- en: '![](Image00114.jpg)'
  id: totrans-8
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00114.jpg)'
- en: This code creates an array variable called nationalParks and initializes it
    with the names of three national parks. Because we initialized this array to hold
    strings, you’ll only be able to put strings in it.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码创建了一个名为 `nationalParks` 的数组变量，并将其初始化为包含三个国家公园名称的数组。因为我们将这个数组初始化为存储字符串，所以你只能在其中存储字符串。
- en: '[Figure 6-1](text00016.html#ch06fig1) shows how you can imagine your array.
    It’s like a row of boxes containing the three names of national parks at indices
    0, 1, and 2\. Remember that the indices of an array always start at 0!'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: '[图6-1](text00016.html#ch06fig1) 展示了你可以如何想象你的数组。它就像一排盒子，分别存放位于索引 0、1 和 2 处的三个国家公园的名称。记住，数组的索引总是从0开始！'
- en: '![Image](Image00115.jpg)'
  id: totrans-11
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Image00115.jpg)'
- en: '*Figure 6-1: The nationalParks array*'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: '*图6-1：nationalParks 数组*'
- en: '**USING MUTABLE AND IMMUTABLE ARRAYS**'
  id: totrans-13
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**使用可变和不可变数组**'
- en: Our nationalParks array is a variable because we created it with the var keyword
    ➊ . An array stored in a variable is called a *mutable* array. This means that
    you can change it by adding items, removing items, or swapping items in and out.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的 `nationalParks` 数组是一个变量，因为我们用 `var` 关键字创建了它 ➊。存储在变量中的数组被称为 *可变* 数组。这意味着你可以通过添加、移除或替换其中的元素来修改它。
- en: You can also create an *immutable* array. An immutable array is created with
    the keyword let instead of var . Similar to a constant, once an immutable array
    is created, nothing in it can be changed.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以创建一个 *不可变* 数组。不可变数组是使用 `let` 关键字而不是 `var` 创建的。类似于常量，一旦不可变数组被创建，它其中的任何内容都不能被修改。
- en: So when should you use a mutable array or an immutable array? It’s best to use
    let if you know your collection will never change, like if you’re storing the
    colors of the rainbow. You should use var if you need to change your collection,
    like if you’re storing an array of your favorite T-shirts, which might change
    depending on what’s in style!
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，什么时候应该使用可变数组或不可变数组呢？如果你知道集合永远不会改变，像是存储彩虹的颜色，那么最好使用 `let`。如果你需要修改集合，比如存储你最喜欢的
    T 恤的数组（这可能会根据流行趋势发生变化），那就应该使用 `var`！
- en: '![Image](Image00116.jpg)'
  id: totrans-17
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Image00116.jpg)'
- en: '**USING TYPE INFERENCE**'
  id: totrans-18
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**使用类型推断**'
- en: 'When we created our nationalParks array, we specified that we were creating
    an array of string values by adding a colon (: ) and [String] ➋ . This step is
    optional when you create an array and initialize it with one or more values because
    Swift will use type inference to determine the kind of data you want the array
    to hold. That means that you could just as easily have created the array by doing
    this:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: '当我们创建我们的 nationalParks 数组时，我们通过添加冒号 (: ) 和 [String] ➋ 来指定我们正在创建一个字符串值的数组。这个步骤在你创建数组并用一个或多个值初始化它时是可选的，因为
    Swift 会使用类型推断来确定你想要数组包含的数据类型。这意味着你完全可以通过以下方式创建数组：'
- en: '![](Image00117.jpg)'
  id: totrans-20
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00117.jpg)'
- en: Using type inference, Swift knows we initialized this array to hold strings,
    and it can hold only strings.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 通过类型推断，Swift 知道我们初始化了这个数组来存储字符串，并且它只能存储字符串。
- en: The list of parks that we created the array with is an example of an array *literal*
    . A literal is a value that is exactly what you see. It is not a variable or constant
    but rather just the value without a name. "Grand Canyon" is an example of a string
    literal, and 7 is an example of an integer literal. An array literal is a list
    of items contained between two square brackets and separated by commas, like ["Acadia",
    "Zion", "Grand Canyon"] ➊ .
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 我们用来创建数组的公园列表是一个数组 *字面量* 的例子。字面量是一个值，它正是你所看到的。它不是一个变量或常量，而只是没有名称的值。 "Grand Canyon"
    是一个字符串字面量的例子，而 7 是一个整数字面量的例子。数组字面量是一个包含在两个方括号之间、由逗号分隔的项目列表，例如 ["Acadia", "Zion",
    "Grand Canyon"] ➊。
- en: '**ACCESSING ITEMS IN AN ARRAY**'
  id: totrans-23
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**访问数组中的项目**'
- en: 'Let’s say you want to access an item in your array and use it in your program.
    Your friend asks you to tell them all about your travels, so you want to use the
    names of the national parks that you stored in the array. To access an item in
    your array, write the array name followed by the item’s index inside square brackets:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你想要访问数组中的一个项目，并在程序中使用它。你的朋友要求你告诉他们所有关于你旅行的事情，所以你想使用你存储在数组中的国家公园名称。要访问数组中的一个项目，写下数组名称，后跟方括号内的项目索引：
- en: '![](Image00118.jpg)'
  id: totrans-25
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00118.jpg)'
- en: In this example, we are accessing the names of the national parks and then printing
    them to the screen using print . To get the first item in nationalParks , you
    use nationalParks[0] ➊ . To access the second item in nationalParks , you use
    nationalParks[1] .
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们访问了国家公园的名称，然后使用 print 将它们打印到屏幕上。要获取 nationalParks 中的第一个项目，你可以使用 nationalParks[0]
    ➊。要访问 nationalParks 中的第二个项目，你可以使用 nationalParks[1]。
- en: '**WATCHING THE RANGE**'
  id: totrans-27
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**观察范围**'
- en: One important point about arrays is that if you try to access an item at an
    index that’s higher than the last index in the array, you’ll get an error. In
    [Figure 6-2](text00016.html#ch06fig2) , you can see that nationalParks[3] (which
    would be the fourth item in the array) gives you an error because there are only
    three national parks in the array, indexed from 0 to 2.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 关于数组的一个重要点是，如果你尝试访问一个高于数组中最后一个索引的项目，你将得到一个错误。在 [图 6-2](text00016.html#ch06fig2)
    中，你可以看到 nationalParks[3]（这将是数组中的第四个项目）会给你一个错误，因为数组中只有三个国家公园，它们的索引从 0 到 2。
- en: As you can see, you get an error message that says Index out of range . If you
    try to access an item that doesn’t exist in your array, your app will crash!
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，你收到了一条错误信息，提示 "Index out of range"。如果你尝试访问一个不存在于数组中的项目，你的应用程序将崩溃！
- en: '![Image](Image00119.jpg)'
  id: totrans-30
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00119.jpg)'
- en: '*Figure 6-2: Trying to access an index in the array where nothing exists causes
    an error.*'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 6-2：尝试访问数组中不存在的索引会导致错误。*'
- en: '**ADDING ITEMS TO AN ARRAY**'
  id: totrans-32
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**向数组添加项目**'
- en: One way to change an array is to add new items to it. There are a few different
    ways to do this, so let’s take a look at each.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 改变数组的一种方式是向数组中添加新项目。有几种不同的方法可以做到这一点，让我们看一下每种方法。
- en: 'First, you can use an array’s append(_:) method. *Append* means to add something.
    Using append(_:) , you can add one new item to the end of your array. Say you
    go on another trip and visit the Badlands, and you want to add it to your list
    of national parks. To do that, add this code into your playground:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，你可以使用数组的 append(_:) 方法。*Append* 意味着添加某个东西。使用 append(_:) 方法，你可以将一个新项添加到数组的末尾。假设你进行了一次新的旅行，参观了坏lands国家公园，并且想将它添加到你的国家公园列表中。为此，你可以在你的
    playground 中添加以下代码：
- en: '![](Image00120.jpg)'
  id: totrans-35
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00120.jpg)'
- en: To use the append(_:) method, first write the name of your array followed by
    a period and then append . Then, put the item you want to add to your array inside
    the parentheses. In this case, you put "Badlands" inside the parentheses.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用 append(_:) 方法，首先写下你的数组名称，后跟一个句点，然后是 append。接着，将你想添加到数组中的项目放入括号内。在这个例子中，你将
    "Badlands" 放入括号中。
- en: 'If you want to add something at a specific place in your array, use the array’s
    insert(_:at:) method instead. This method takes two arguments: the item that you
    want to insert and the index of where it should go in the array. (We’ll discuss
    arguments in more detail in [Chapter 7](text00017.html#ch07) .)'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想在数组中的特定位置添加元素，请改用数组的insert(_:at:)方法。此方法接受两个参数：你想插入的元素和它在数组中应该插入的位置（我们将在[第7章](text00017.html#ch07)中详细讨论参数）。
- en: 'Let’s say you totally forgot that you went to the Petrified Forest right after
    you visited the Grand Canyon, and you want to update your nationalParks array
    so it displays the parks in the order in which you visited them. To update your
    array, you could use the insert(_:at:) method to put the Petrified Forest in the
    right position:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你完全忘记了在游览大峡谷后，你去了“化石森林”，你想更新你的nationalParks数组，使其按你访问的顺序显示这些公园。要更新数组，你可以使用insert(_:at:)方法将“化石森林”放到正确的位置：
- en: '![](Image00121.jpg)'
  id: totrans-39
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00121.jpg)'
- en: When you insert a new item at index 3, everything that was in the array at index
    3 or higher gets scooted over to make room for the new item. That means the item
    that was at index 3 is now at index 4, the item that was at index 4 is now at
    index 5, and so on. After you add the Petrified Forest, nationalParks is now ["Acadia",
    "Zion", "Grand Canyon", "Petrified Forest", "Badlands"] .
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 当你在索引3的位置插入新元素时，所有原本位于索引3或更高位置的元素都会向后移动，为新元素腾出空间。这意味着，原本位于索引3的元素现在会位于索引4，原本位于索引4的元素现在会位于索引5，依此类推。在你添加了“化石森林”后，nationalParks数组现在是["Acadia",
    "Zion", "Grand Canyon", "Petrified Forest", "Badlands"]。
- en: '**COMBINING ARRAYS**'
  id: totrans-41
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**合并数组**'
- en: 'Not only can you add new items to an array, but you can also add two arrays
    together using the + and += operators. Let’s say that you have the ingredients
    for a fruit smoothie in two arrays:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 你不仅可以向数组中添加新元素，还可以使用+和+=运算符将两个数组合并在一起。假设你有两个数组，分别存放了水果奶昔的配料：
- en: '![](Image00122.jpg)'
  id: totrans-43
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00122.jpg)'
- en: Now you can make a delicious smoothie by adding the fruits and liquids arrays.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你可以通过添加水果和液体数组来制作美味的奶昔。
- en: '![](Image00123.jpg)'
  id: totrans-45
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00123.jpg)'
- en: The order of the ingredients in smoothie is the same as the order in fruits
    and liquids . If you created smoothie with liquids + fruits , then the liquids
    would come first.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 奶昔中配料的顺序与水果和液体的顺序相同。如果你是用液体 + 水果来制作奶昔，那么液体应该先放。
- en: 'You use the += operator to add an array to the end of your array. Add some
    whipped cream as follows for extra yumminess:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用+=运算符将一个数组添加到另一个数组的末尾。如下所示，加入一些奶油以增加美味：
- en: '![](Image00124.jpg)'
  id: totrans-48
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00124.jpg)'
- en: Note that ["whipped cream"] is an array even though it has a single item in
    it. When you’re using += to append something to an array, you have to make sure
    you’re only trying to add another array. If you were to just write the string
    "whipped cream" without the square brackets around it, you would get an error.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，["whipped cream"]是一个数组，尽管它只有一个元素。当你使用+=运算符将元素追加到数组时，必须确保你只尝试添加另一个数组。如果你只是写上字符串"whipped
    cream"，而没有用方括号括起来，你会得到一个错误。
- en: '![Image](Image00125.jpg)'
  id: totrans-50
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00125.jpg)'
- en: '**REMOVING ITEMS FROM AN ARRAY**'
  id: totrans-51
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**从数组中移除元素**'
- en: 'There are several methods for removing items from an array. Let’s start by
    looking at the array’s removeLast() method. As you might have guessed from its
    name, removeLast() removes the last item from your array. Let’s try it out with
    a shoppingList array:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 从数组中移除元素有几种方法。首先让我们来看一下数组的removeLast()方法。顾名思义，removeLast()会移除数组中的最后一个元素。我们可以用shoppingList数组来试试这个方法：
- en: '![](Image00126.jpg)'
  id: totrans-53
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00126.jpg)'
- en: Neat! Note that the removeLast() method returns the removed item, so you can
    store it in a new constant or variable if you want.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 很棒！请注意，removeLast()方法会返回被移除的元素，因此如果你想，你可以将它存储到一个新的常量或变量中。
- en: 'You can also remove an item from a specific index by using the remove(at:)
    method. Let’s say that your mom doesn’t want you buying any candy and takes that
    off the list:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以通过使用remove(at:)方法从特定的索引中移除元素。假设你的妈妈不让你买糖果，并将其从购物清单中删除：
- en: '![Image](Image00127.jpg)![](Image00128.jpg)'
  id: totrans-56
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00127.jpg)![](Image00128.jpg)'
- en: Just like when we added an item to the middle of our array and all the items
    scooted over to make room, if you remove an item from the middle of an array,
    the rest of the items will scoot back to fill in that empty space. The "apples"
    item that was at index 3 is now at index 2, where "candy" was.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 就像我们在数组中间添加元素时，所有元素都会向后移动腾出空间一样，如果你从数组中间移除元素，其余的元素也会向前移动填补空缺。原本在索引3位置的"apples"元素，现在会移动到索引2的位置，那里曾经是"candy"。
- en: 'You can also remove all items from an array with removeAll() . Try entering
    this into your playground:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以使用 removeAll() 来移除数组中的所有项。尝试将这个输入到你的 playground 中：
- en: '![](Image00129.jpg)'
  id: totrans-59
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00129.jpg)'
- en: 'Note that trying to remove an item at an index that doesn’t exist will give
    you an error:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，尝试移除一个不存在的索引项会导致错误：
- en: '![](Image00130.jpg)'
  id: totrans-61
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00130.jpg)'
- en: Our array doesn’t have this many items (in fact, now it’s empty!), so this throws
    an error. We’ll also get an error if we use removeLast() on our empty array, because
    there’s nothing in it—there’s no last index at all! However, removeAll() is always
    safe to use, even on an empty array.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的数组没有这么多项（实际上，现在它是空的！），所以这会引发错误。如果我们在空数组上使用 removeLast()，也会出现错误，因为数组中没有任何内容——根本没有最后一个索引！然而，使用
    removeAll() 永远是安全的，即使在空数组上。
- en: '**REPLACING ITEMS IN AN ARRAY**'
  id: totrans-63
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**替换数组中的项**'
- en: 'To replace an item in an array, you set the index of the array to the new value,
    as shown here:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 要替换数组中的某个项，你需要将数组的索引设置为新值，如下所示：
- en: '![](Image00131.jpg)'
  id: totrans-65
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00131.jpg)'
- en: At ➊ , we replaced the item at index 2 (the third item) with "Unicorn" because
    magical animals count as favorite animals, too! At ➋ , we replaced the item at
    index 0 (the first item) with "Bearded dragon" . No, that’s not a real dragon—it’s
    just a lizard!
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 在 ➊ 处，我们将索引为 2（第三项）的项替换为 "独角兽"，因为魔法动物也是喜欢的动物！在 ➋ 处，我们将索引为 0（第一项）的项替换为 "胡须龙"。不，那不是一条真正的龙——它只是一个蜥蜴！
- en: Like any time you’re working with array index numbers, you have to be sure an
    item exists in the array at that index before you change its value, or you will
    get an Index out of range error.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 就像在操作数组索引时一样，你必须确保在改变数组某个索引位置的值之前，该位置已经有项，否则会出现“索引超出范围”的错误。
- en: '[Figure 6-3](text00016.html#ch06fig3) shows the error that occurs if you try
    to add "Standard poodle" using favoriteAnimals[3] = "Standard poodle" . To add
    an item to the end of an array, you should use the append(_:) method or += , as
    we covered in “[Adding Items to an Array](text00016.html#ch06lev2sec5) ” on [page
    70](text00016.html#page_70) .'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 6-3](text00016.html#ch06fig3) 显示了如果你尝试使用 favoriteAnimals[3] = "标准贵宾犬" 来添加
    "标准贵宾犬"，会发生的错误。要将项添加到数组的末尾，你应该使用 append(_:) 方法或 += ，正如我们在 “[向数组添加项](text00016.html#ch06lev2sec5)”
    中讨论的那样，见 [第 70 页](text00016.html#page_70) 。'
- en: '![Image](Image00132.jpg)'
  id: totrans-69
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00132.jpg)'
- en: '*Figure 6-3: Don’t try to replace a value at an index beyond the existing array.*'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 6-3：不要尝试替换超出现有数组范围的索引位置的值。*'
- en: Now you know how to change arrays however you might need to. You can add items,
    take items away, or replace items. Next, we’ll look at how to use the properties
    of arrays to find out even more information about them.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经知道如何根据需要修改数组。你可以添加项、移除项或替换项。接下来，我们将看看如何使用数组的属性来了解更多关于数组的信息。
- en: '![Image](Image00133.jpg)'
  id: totrans-72
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00133.jpg)'
- en: '**USING ARRAY PROPERTIES**'
  id: totrans-73
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**使用数组属性**'
- en: In addition to methods like append(_:) and removeLast() , arrays also have *properties*
    . An array’s properties are variables or constants that contain some information
    about the array. Two really helpful properties that you might use are the Boolean
    property isEmpty and the integer property count .
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 除了像 append(_:) 和 removeLast() 这样的方法，数组还有 *属性* 。数组的属性是包含有关数组的一些信息的变量或常量。有两个非常有用的属性，你可能会用到：布尔属性
    isEmpty 和整数属性 count 。
- en: The isEmpty property is true or false depending on whether the array is empty,
    and the count property will tell you how many items are in that array.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: isEmpty 属性是一个布尔值，表示数组是否为空，而 count 属性则告诉你数组中有多少项。
- en: 'Check out how these two properties are used in the following if-else statement:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 看看这两个属性在以下 if-else 语句中的使用方式：
- en: '![Image](Image00134.jpg)'
  id: totrans-77
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00134.jpg)'
- en: 'This if-else statement checks whether the array mySiblings is empty ➊ . If
    it is, then "I don''t have any siblings." is printed. But if there is something
    in the array, then the number of siblings that we have is printed: "I have 3 siblings."
    ➋ .'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 这个 if-else 语句检查数组 mySiblings 是否为空 ➊ 。如果为空，则打印 "我没有兄弟姐妹。" 如果数组中有内容，则打印我们有多少个兄弟姐妹："我有
    3 个兄弟姐妹。" ➋ 。
- en: '**LOOPING OVER AN ARRAY**'
  id: totrans-79
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**遍历数组**'
- en: 'Sometimes when you’re working with arrays you might want to do something to
    every item in the array. You can use a for-in loop to do that! The following code
    will print every topping in a pizzaToppings array on a separate line:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 有时在处理数组时，你可能想对数组中的每一项做一些操作。你可以使用 for-in 循环来实现！以下代码将在每一行打印 pizzaToppings 数组中的每个配料：
- en: '![Image](Image00135.jpg)'
  id: totrans-81
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00135.jpg)'
- en: To write a for-in loop for the pizzaToppings array, we used the keyword for
    , followed by the constant topping , then the keyword in , and finally the name
    of our array, pizzaToppings . Then we put the statements that we want to run for
    each topping inside the braces of the for-in loop. The constant topping ➊ temporarily
    represents each pizza topping in the array as we loop through it. We could have
    chosen any name for this constant, but it’s a good idea to pick something that
    makes sense. You can see the output of this for-in loop in [Figure 6-4](text00016.html#ch06fig4)
    .
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 要为 pizzaToppings 数组编写一个 for-in 循环，我们使用了关键字 for，后跟常量 topping，再加上关键字 in，最后是数组的名称
    pizzaToppings。然后我们把要在每个 topping 上执行的语句放在 for-in 循环的大括号中。常量 topping ➊ 临时代表数组中每个比萨配料，当我们遍历它时。我们可以为这个常量选择任何名称，但最好选一个有意义的名字。你可以在
    [图6-4](text00016.html#ch06fig4) 中看到这个 for-in 循环的输出。
- en: '![Image](Image00136.jpg)'
  id: totrans-83
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00136.jpg)'
- en: '*Figure 6-4: Output of the example for-in loop*'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: '*图6-4：for-in 循环示例的输出*'
- en: '![Image](Image00137.jpg)'
  id: totrans-85
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00137.jpg)'
- en: 'Using for-in loops is great for printing every value in an array. If you’re
    working with numbers, you can even use them to perform math operations on each
    item, which makes for some speedy calculations! The following code takes an array
    of numbers and calculates the square for each (the square of a number is that
    number multiplied by itself):'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 for-in 循环非常适合打印数组中的每个值。如果你正在处理数字，甚至可以利用它对每个项执行数学运算，这使得计算速度更快！下面的代码接收一个数字数组，并计算每个数字的平方（一个数字的平方是该数字与自身相乘）：
- en: '![Image](Image00138.jpg)'
  id: totrans-87
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00138.jpg)'
- en: '[Figure 6-5](text00016.html#ch06fig5) shows the results.'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: '[图6-5](text00016.html#ch06fig5) 显示了结果。'
- en: '![Image](Image00139.jpg)'
  id: totrans-89
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00139.jpg)'
- en: '*Figure 6-5: Printing the squares for each number in the myNumbers array*'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: '*图6-5：打印 myNumbers 数组中每个数字的平方*'
- en: '**DICTIONARIES ARE KEY!**'
  id: totrans-91
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**字典是关键！**'
- en: A *dictionary* is also a collection of values, but instead of an ordered index,
    each value has its own *key* . Because there’s no index, the values are not stored
    in any particular order. To access values in a dictionary, you look them up by
    their key.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: '*字典* 也是一个值的集合，但不同于有序的索引，每个值都有自己的 *键* 。由于没有索引，值并没有按照特定的顺序存储。要访问字典中的值，你需要通过键来查找它们。'
- en: A key must be unique. You can’t have the same key more than once in the same
    dictionary. If there were two identical keys and you asked the computer to give
    you the value for one of them, the computer wouldn’t know which one to choose!
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 一个键必须是唯一的。在同一个字典中，不能有相同的键。如果有两个相同的键，并且你要求计算机返回其中一个的值，计算机就不知道该选择哪个！
- en: Let’s take a look at how to make a dictionary and write keys that will help
    you find all the information you need.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看如何创建一个字典，并编写键来帮助你找到所需的所有信息。
- en: '![Image](Image00140.jpg)'
  id: totrans-95
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00140.jpg)'
- en: '**INITIALIZING A DICTIONARY**'
  id: totrans-96
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**初始化字典**'
- en: 'To create and initialize a dictionary, first write var and the name of your
    dictionary. Then write the keys and corresponding values inside a pair of square
    brackets, similar to an array. Let’s create a dictionary to store the names of
    a few US states. The key for each state will be its two-letter abbreviation:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建并初始化一个字典，首先写下 var 和字典的名称。然后在一对方括号内写下键和值，类似于数组。让我们创建一个字典来存储几个美国州的名称。每个州的键将是其两字母的缩写：
- en: '![](Image00141.jpg)'
  id: totrans-98
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00141.jpg)'
- en: As you can see, there’s a colon between each key and its value, and the key/value
    pairs are separated by commas.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，键和值之间有一个冒号，键/值对之间用逗号分隔。
- en: Dictionaries are different from arrays in that they are *unordered* . Because
    of that, it’s likely that the order of the states that you see in your results
    pane ➋ is different from the order in which you entered your states ➊ . It might
    even be different than the order that’s printed in this book!
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 字典与数组不同，因为它们是 *无序的* 。因此，你看到的结果面板中的州的顺序 ➋ 可能与输入这些州时的顺序 ➊ 不同。甚至可能与本书中打印的顺序不同！
- en: As with arrays, you can use var to make a mutable dictionary or use let to make
    an immutable dictionary.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 与数组一样，你可以使用 var 来创建一个可变字典，或者使用 let 来创建一个不可变字典。
- en: 'In Swift, all of the keys of a dictionary must be the same type, and all of
    the values of a dictionary must also be the same type, but the key type doesn’t
    have to match the value type. For example, if you wanted to store a collection
    of fractions, you could use doubles for the keys and strings for the values:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Swift 中，字典的所有键必须是相同类型的，字典的所有值也必须是相同类型的，但键的类型不一定与值的类型匹配。例如，如果你想存储一组分数，你可以将双精度数值用作键，将字符串用作值：
- en: '![](Image00142.jpg)'
  id: totrans-103
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00142.jpg)'
- en: In this dictionary, all of the keys must be doubles, and all of the values must
    be strings. Again, you’ll see that the order of the numbers in the results pane
    can be quite different from the order in which you wrote the fractions in your
    dictionary. This is fine because you don’t need to know the order to access anything.
    You can find any item that you need by its key. Let’s see how!
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个字典中，所有的键必须是双精度类型，所有的值必须是字符串类型。同样，你会发现结果面板中数字的顺序与在字典中编写分数的顺序可能非常不同。这是正常的，因为你不需要知道顺序来访问任何内容。你可以通过键找到你需要的任何项目。让我们看看如何做！
- en: '**ACCESSING VALUES IN A DICTIONARY**'
  id: totrans-105
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**访问字典中的值**'
- en: 'Looking up a value in a dictionary is similar to how you access a value in
    an array except that you use a key inside the square brackets instead of an index,
    like this: usStates["TX"] .'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 在字典中查找一个值类似于你在数组中访问值的方式，只是你在方括号内使用的是键，而不是索引，像这样：usStates["TX"]。
- en: There is a big difference, however, in how Swift returns the values from a dictionary.
    When you access a value at an index of an array, you are simply given the value.
    When you access a value with a key in a dictionary, you are given an optional.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，Swift 从字典中返回值的方式存在很大差异。当你访问数组中某个索引的值时，你会直接得到该值。而当你在字典中使用键访问值时，你得到的是一个可选值。
- en: In [Chapter 5](text00015.html#ch05) , you learned that optionals might contain
    a value or might be nil . The reason Swift returns optionals when you’re looking
    up items in a dictionary is that the key you used might not exist in the dictionary,
    in which case there’s no value to access. Trying to access a value that doesn’t
    exist would give you a big fat error! To avoid that problem, Swift returns optionals.
    That means you need to unwrap any value you get out of a dictionary before you
    can do anything with it.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第 5 章](text00015.html#ch05)中，你学过可选值可能包含一个值，也可能是 nil。Swift 在你查找字典中的项目时返回可选值，是因为你使用的键可能在字典中不存在，这种情况下就没有值可访问。尝试访问一个不存在的值会导致一个很大的错误！为了避免这个问题，Swift
    返回了可选值。这意味着你需要解包从字典中获取的任何值，才能对其进行操作。
- en: 'To unwrap an optional, first you check whether it exists using an if-let statement,
    just like we did in [Chapter 5](text00015.html#ch05) . The following code shows
    you how to get a value out of a dictionary:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 要解包一个可选值，首先你需要使用 if-let 语句检查它是否存在，就像我们在[第 5 章](text00015.html#ch05)中做的那样。以下代码展示了如何从字典中获取一个值：
- en: '![Image](Image00143.jpg)'
  id: totrans-110
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00143.jpg)'
- en: To retrieve "Texas" from the dictionary, we use if let to set a constant loneStarState
    to usStates["TX"] ➊ . Because we have this state in our dictionary, the line I
    have Texas in my dictionary. is printed. Next we try to access a state that is
    not in our dictionary by using the key usStates["FL"] ➋ . Thankfully, because
    we used an if-let statement, the program won’t crash when the computer can’t find
    this state. Instead, I don't have that state in my dictionary. is printed.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 要从字典中检索“Texas”，我们使用 if let 来将常量 loneStarState 设置为 usStates["TX"] ➊。因为我们在字典中有这个州，所以输出了“我在字典中有
    Texas。”接下来，我们尝试通过使用键 usStates["FL"] ➋ 来访问字典中没有的州。幸运的是，因为我们使用了 if-let 语句，当计算机找不到该州时，程序不会崩溃。相反，输出了“我在字典中没有那个州。”
- en: '**ADDING ITEMS TO A DICTIONARY**'
  id: totrans-112
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**向字典中添加项目**'
- en: 'To add an item to a dictionary, first write the name of your dictionary and
    assign the new item to the key you want it to have in the dictionary. Let’s add
    "Minnesota" to our usStates dictionary:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 要向字典中添加项目，首先写下字典的名称，并将新项目分配给你希望它在字典中拥有的键。让我们向 usStates 字典中添加“明尼苏达州”：
- en: '![](Image00144.jpg)'
  id: totrans-114
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00144.jpg)'
- en: 'Now when you look at usStates , you’ll see that it’s updated to ["MN": "Minnesota",
    "WA": "Washington", "MA": "Massachusetts", "TX": "Texas"] . Remember, because
    you don’t have to rely on indices, your new dictionary item might appear anywhere
    in the dictionary.'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: '现在，当你查看 usStates 时，你会看到它已更新为 ["MN": "Minnesota", "WA": "Washington", "MA":
    "Massachusetts", "TX": "Texas"]。记住，因为你不必依赖索引，新的字典项可能出现在字典中的任何位置。'
- en: '**REMOVING ITEMS FROM A DICTIONARY**'
  id: totrans-116
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**从字典中移除项目**'
- en: Removing an item from a dictionary is quite simple; you do so by setting the
    value to nil . Because the values in dictionaries are returned as optionals, you
    don’t have to worry about nil causing any problems in your dictionary.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 从字典中移除项非常简单；你只需将值设置为nil。由于字典中的值是作为可选项返回的，所以你无需担心nil会在字典中引发任何问题。
- en: '![](Image00145.jpg)'
  id: totrans-118
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00145.jpg)'
- en: 'You can see that after you remove the value at the key "MA" , usStates is updated
    to ["MN": "Minnesota", "WA": "Washington", "TX": "Texas"] . Remember that nil
    is special and means that there’s no value at all. That’s why you don’t see "MA":
    nil in our dictionary.'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: '你可以看到，在移除键"MA"的值后，usStates被更新为["MN": "Minnesota", "WA": "Washington", "TX":
    "Texas"]。记住，nil是特殊的，表示没有值。这就是为什么你在字典中看不到"MA": nil。'
- en: '**REPLACING ITEMS IN A DICTIONARY**'
  id: totrans-120
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**替换字典中的项**'
- en: 'Replacing an item in a dictionary is also easy. It works the same was as replacing
    an item in an array. You just set the item that you want to replace to something
    else. Say you create a dictionary of fruit colors:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 替换字典中的项也很简单。它的工作原理和替换数组中的项一样。你只需要将你想替换的项设置为其他值。比如，你创建一个水果颜色的字典：
- en: '![](Image00146.jpg)'
  id: totrans-122
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00146.jpg)'
- en: At first we had the value "apple" for "red" , but then we decided that "raspberry"
    is a better fruit to use since sometimes apples are green or yellow. To replace
    "apple" with "raspberry" , we set colorFruits["red"] to its new value ➊ .
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 一开始我们为"red"设置了值"apple"，但后来我们决定使用"raspberry"更合适，因为有时苹果是绿色或黄色的。为了将"apple"替换为"raspberry"，我们将colorFruits["red"]的值设置为新的值➊。
- en: You may remember that this is the same way we entered a new value into a dictionary.
    If the key already exists in the dictionary, then the value for that key is replaced.
    If the key doesn’t already exist, then the new key/value pair will be added to
    the dictionary.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能还记得，这和我们将新值输入字典的方式一样。如果键已经存在于字典中，那么该键的值将被替换。如果该键不存在，新的键/值对将被添加到字典中。
- en: '![Image](Image00147.jpg)'
  id: totrans-125
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00147.jpg)'
- en: '**USING DICTIONARY PROPERTIES**'
  id: totrans-126
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**使用字典属性**'
- en: 'Like an array, a dictionary also has an isEmpty property and a count property.
    For example, the following code shows how you can use the isEmpty property to
    check if a dictionary is empty, and if it isn’t empty, the count property checks
    how many items you have. Imagine you have a basket of fruit for sale. You can
    use these properties to help you keep track of everything:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 像数组一样，字典也有isEmpty属性和count属性。例如，以下代码展示了如何使用isEmpty属性检查字典是否为空，如果字典不为空，count属性则可以检查字典中有多少项。想象你有一个待售的水果篮子。你可以使用这些属性帮助你追踪所有内容：
- en: '![Image](Image00148.jpg)'
  id: totrans-128
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00148.jpg)'
- en: 'A dictionary also has two special properties: keys , which contains all of
    the dictionary’s keys, and values , which contains all of its values. We’ll use
    these two properties when we loop through the dictionary.'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 字典还有两个特殊的属性：keys，包含字典的所有键；values，包含字典的所有值。在遍历字典时，我们将使用这两个属性。
- en: Let’s write some code that loops through our fruit baskets and prints the price
    of each fruit.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们写一些代码，遍历我们的水果篮子，并打印每个水果的价格。
- en: '**LOOPING OVER A DICTIONARY**'
  id: totrans-131
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**遍历字典**'
- en: 'You can loop through a dictionary using a for-in loop. Because each item has
    a key and a value, you can do this in two different ways. This is how to loop
    through a dictionary using its keys:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用for-in循环遍历字典。因为每个项都有一个键和值，所以你可以用两种不同的方式来做这件事。这是通过字典的键来遍历字典的方法：
- en: '![Image](Image00149.jpg)'
  id: totrans-133
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00149.jpg)'
- en: Here we use the dictionary’s keys property ➊ to loop through fruitBasket and
    print its contents. We start by writing the keyword for , followed by a constant
    name fruit for the dictionary key, the keyword in , the dictionary name, a period,
    and keys .
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们使用字典的keys属性➊来遍历fruitBasket并打印其内容。我们首先写上关键字for，然后是一个常量名fruit作为字典键，接着是关键字in，字典名称，一个句点，再加上keys。
- en: Inside the braces of our for-in loop, we have access to both the key, which
    we call fruit ➋ , and the value at that key when we force-unwrap its contents
    with fruitBasket[fruit]! ➌ . That value will be the fruit’s price.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的for-in循环的花括号内，我们可以访问到键，我们称之为fruit ➋ ，以及当我们强制解包其内容时的值fruitBasket[fruit]!
    ➌。该值将是水果的价格。
- en: In this case, it’s safe to force-unwrap the value using an exclamation point
    because we know that the fruit key we’re using is definitely inside the dictionary.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，使用感叹号强制解包值是安全的，因为我们知道我们使用的fruit键一定在字典中。
- en: Any code we put inside the for-in loop will run once for every key in our dictionary.
    So you should see the print statement display three times.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在 for-in 循环中放置的任何代码都会针对字典中的每个键执行一次。所以你应该看到打印语句显示三次。
- en: 'We can also loop through the dictionary using its values property:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以使用字典的 `values` 属性来遍历字典：
- en: '![Image](Image00150.jpg)'
  id: totrans-139
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00150.jpg)'
- en: We use the same style of for-in loop, but now we use a constant to refer to
    each value, which we call price , in the values property. When looping through
    values, we don’t have access to the keys from inside the loop.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用相同样式的 for-in 循环，但现在我们使用常量来引用 `values` 属性中的每个值，这个常量我们称之为 `price`。在遍历值时，我们无法从循环内访问键。
- en: Another difference to note is that price is not an optional because it’s accessed
    directly as a value in the fruitBasket dictionary. That means we don’t have to
    unwrap it. You should still see the print statement printed three times. [Figure
    6-6](text00016.html#ch06fig6) shows the output of both loops.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个需要注意的区别是，`price` 不是可选类型，因为它作为字典 `fruitBasket` 中的值被直接访问。这意味着我们不需要解包它。你仍然应该看到打印语句打印三次。[图
    6-6](text00016.html#ch06fig6) 展示了两个循环的输出。
- en: '![Image](Image00151.jpg)'
  id: totrans-142
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00151.jpg)'
- en: '*Figure 6-6: Looping through the keys and values of a dictionary with a for-in
    loop*'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 6-6：使用 for-in 循环遍历字典的键和值*'
- en: The order of your results might be slightly different from ours. That’s because
    the items in a dictionary aren’t in a numbered order like they are in an array!
    And because the order is not guaranteed, you might see a different order printed
    if you run the same code again.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 你的结果顺序可能与我们的稍有不同。这是因为字典中的项目不像数组那样按编号顺序排列！并且由于顺序无法保证，如果你重新运行相同的代码，可能会看到不同的顺序。
- en: '**WHAT YOU LEARNED**'
  id: totrans-145
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**你学到的知识**'
- en: In this chapter, you learned how to store collections of items in an array and
    in a dictionary. To store items in an ordered list, you would use an array and
    look up each item by its index. If you wanted to store items by key instead, you
    would use a dictionary.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你学会了如何将项目集合存储在数组和字典中。如果你要存储有序列表中的项目，你应该使用数组，并通过索引查找每个项目。如果你希望通过键来存储项目，则应该使用字典。
- en: Knowing about arrays and dictionaries and how to use them is a powerful building
    block for almost any programming language. Next we will learn about functions,
    another very powerful tool. Functions are blocks of code that you create and name
    to perform a specific job. After you have written a function, you can use its
    name to call it from almost anywhere in your program.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 了解数组和字典以及如何使用它们是几乎任何编程语言的强大构建块。接下来我们将学习函数，另一个非常强大的工具。函数是你创建并命名的代码块，用于执行特定的工作。在你编写了一个函数之后，可以通过它的名称在程序的几乎任何地方调用它。
- en: STORING COLLECTIONS IN DICTIONARIES AND ARRAYS
  id: totrans-148
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将集合存储在字典和数组中
- en: '![Image](Image00001.jpg)'
  id: totrans-149
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00001.jpg)'
- en: In previous chapters, you learned that you can store a single piece of information
    in a variable or constant. But what if you want to store a collection of things,
    like the names of all the places you’ve visited or all the books that you’ve read?
    In this chapter, we’ll introduce you to arrays and dictionaries. They’re both
    used to store collections of values. Using arrays and dictionaries, you can work
    with a lot of data at once and make your programs more powerful!
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的章节中，你学习了如何将单个信息存储在变量或常量中。但如果你想存储一组信息，比如你访问过的所有地方的名称，或者你读过的所有书籍的名字呢？在本章中，我们将向你介绍数组和字典。它们都用于存储值的集合。通过使用数组和字典，你可以一次性处理大量数据，从而让你的程序变得更强大！
- en: '**KEEPING THINGS IN ORDER WITH ARRAYS**'
  id: totrans-151
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**使用数组保持顺序**'
- en: An *array* is a list of items of the same data type stored in order, kind of
    like a numbered grocery list. Items in an array are stored by their *index* ,
    a number based on where the item is positioned in the array.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 一个 *数组* 是按顺序存储的相同数据类型的项目列表，类似于有编号的购物清单。数组中的项目是通过其 *索引* 存储的，索引是基于项目在数组中的位置的数字。
- en: When you write a grocery list, you usually start with the number 1, but in computer
    programming, an index starts at 0, not 1\. So the first item in an array is always
    at index 0, the second item is at index 1, the third item is at index 2, and so
    on.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 当你写购物清单时，你通常从数字 1 开始，但在计算机编程中，索引是从 0 开始的，而不是从 1 开始。所以数组中的第一个项目总是在索引 0，第二个项目在索引
    1，第三个项目在索引 2，以此类推。
- en: 'Let’s create an array. If you already know what you’re going to put into your
    array, you can create it and *initialize* it with those values. To initialize
    something in Swift is to give it some initial value so you can use it in your
    program. Let’s say that you want to store a list of all of the national parks
    that you’ve visited. Enter the following into your playground:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一个数组。如果你已经知道你将要放入数组的内容，你可以创建它并用这些值*初始化*它。在 Swift 中初始化某个东西是指给它一个初始值，以便你可以在程序中使用它。假设你想存储你访问过的所有国家公园的列表。请输入以下内容到你的
    playground 中：
- en: '![](Image00114.jpg)'
  id: totrans-155
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00114.jpg)'
- en: This code creates an array variable called nationalParks and initializes it
    with the names of three national parks. Because we initialized this array to hold
    strings, you’ll only be able to put strings in it.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码创建了一个名为 nationalParks 的数组变量，并使用三个国家公园的名称对其进行了初始化。因为我们初始化这个数组来存储字符串，所以它只能存储字符串。
- en: '[Figure 6-1](text00016.html#ch06fig1) shows how you can imagine your array.
    It’s like a row of boxes containing the three names of national parks at indices
    0, 1, and 2\. Remember that the indices of an array always start at 0!'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 6-1](text00016.html#ch06fig1) 展示了你可以如何想象你的数组。它就像一排盒子，包含了位于索引 0、1 和 2 的三个国家公园名称。记住，数组的索引总是从
    0 开始！'
- en: '![Image](Image00115.jpg)'
  id: totrans-158
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Image00115.jpg)'
- en: '*Figure 6-1: The nationalParks array*'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 6-1：nationalParks 数组*'
- en: '**USING MUTABLE AND IMMUTABLE ARRAYS**'
  id: totrans-160
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**使用可变和不可变数组**'
- en: Our nationalParks array is a variable because we created it with the var keyword
    ➊ . An array stored in a variable is called a *mutable* array. This means that
    you can change it by adding items, removing items, or swapping items in and out.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的 nationalParks 数组是一个变量，因为我们是用 var 关键字 ➊ 创建它的。存储在变量中的数组叫做*可变*数组。这意味着你可以通过添加项、删除项或交换项来更改它。
- en: You can also create an *immutable* array. An immutable array is created with
    the keyword let instead of var . Similar to a constant, once an immutable array
    is created, nothing in it can be changed.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以创建一个*不可变*数组。不可变数组是使用关键词 let 而不是 var 创建的。类似常量，一旦不可变数组被创建，里面的内容就不能再改变。
- en: So when should you use a mutable array or an immutable array? It’s best to use
    let if you know your collection will never change, like if you’re storing the
    colors of the rainbow. You should use var if you need to change your collection,
    like if you’re storing an array of your favorite T-shirts, which might change
    depending on what’s in style!
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，什么时候应该使用可变数组或不可变数组呢？如果你知道你的集合永远不会改变，比如存储彩虹的颜色，最好使用 let。如果你需要改变集合，例如存储你最喜欢的
    T 恤的数组，这些 T 恤可能会根据流行趋势发生变化，那么你应该使用 var！
- en: '![Image](Image00116.jpg)'
  id: totrans-164
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Image00116.jpg)'
- en: '**USING TYPE INFERENCE**'
  id: totrans-165
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**使用类型推断**'
- en: 'When we created our nationalParks array, we specified that we were creating
    an array of string values by adding a colon (: ) and [String] ➋ . This step is
    optional when you create an array and initialize it with one or more values because
    Swift will use type inference to determine the kind of data you want the array
    to hold. That means that you could just as easily have created the array by doing
    this:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们创建我们的 nationalParks 数组时，我们通过添加冒号（:）和 [String] ➋ 来指定我们正在创建一个字符串值的数组。此步骤在你创建一个数组并用一个或多个值初始化它时是可选的，因为
    Swift 会使用类型推断来确定你希望数组存储的数据类型。这意味着你也可以通过这样创建数组：
- en: '![](Image00117.jpg)'
  id: totrans-167
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00117.jpg)'
- en: Using type inference, Swift knows we initialized this array to hold strings,
    and it can hold only strings.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 使用类型推断，Swift 知道我们初始化了这个数组来存储字符串，并且它只能存储字符串。
- en: The list of parks that we created the array with is an example of an array *literal*
    . A literal is a value that is exactly what you see. It is not a variable or constant
    but rather just the value without a name. "Grand Canyon" is an example of a string
    literal, and 7 is an example of an integer literal. An array literal is a list
    of items contained between two square brackets and separated by commas, like ["Acadia",
    "Zion", "Grand Canyon"] ➊ .
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建数组时使用的公园列表是数组*字面量*的一个例子。字面量是你所看到的确切值。它不是一个变量或常量，而仅仅是一个没有名字的值。“大峡谷”是一个字符串字面量的例子，7
    是一个整数字面量的例子。数组字面量是一个包含在两个方括号之间并用逗号分隔的项列表，比如 ["Acadia", "Zion", "Grand Canyon"]
    ➊。
- en: '**ACCESSING ITEMS IN AN ARRAY**'
  id: totrans-170
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**访问数组中的项**'
- en: 'Let’s say you want to access an item in your array and use it in your program.
    Your friend asks you to tell them all about your travels, so you want to use the
    names of the national parks that you stored in the array. To access an item in
    your array, write the array name followed by the item’s index inside square brackets:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你想在程序中访问数组中的某个项目并使用它。你的朋友请求你告诉他们你所有的旅行经历，所以你想使用存储在数组中的国家公园的名称。要访问数组中的某项，写下数组名称，后跟方括号内的项的索引：
- en: '![](Image00118.jpg)'
  id: totrans-172
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00118.jpg)'
- en: In this example, we are accessing the names of the national parks and then printing
    them to the screen using print . To get the first item in nationalParks , you
    use nationalParks[0] ➊ . To access the second item in nationalParks , you use
    nationalParks[1] .
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们访问了国家公园的名称，并使用 print 将它们打印到屏幕上。要获取 nationalParks 中的第一个项目，你使用 nationalParks[0]
    ➊。要访问 nationalParks 中的第二个项目，你使用 nationalParks[1]。
- en: '**WATCHING THE RANGE**'
  id: totrans-174
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**监视范围**'
- en: One important point about arrays is that if you try to access an item at an
    index that’s higher than the last index in the array, you’ll get an error. In
    [Figure 6-2](text00016.html#ch06fig2) , you can see that nationalParks[3] (which
    would be the fourth item in the array) gives you an error because there are only
    three national parks in the array, indexed from 0 to 2.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 关于数组有一个重要的点，如果你尝试访问一个比数组中最后一个索引更大的索引，你将得到一个错误。在[图 6-2](text00016.html#ch06fig2)中，你可以看到
    nationalParks[3]（这将是数组中的第四项）会报错，因为数组中只有三个国家公园，索引从0到2。
- en: As you can see, you get an error message that says Index out of range . If you
    try to access an item that doesn’t exist in your array, your app will crash!
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，你会收到一条错误信息，提示 Index out of range。如果你尝试访问数组中不存在的项，你的应用将崩溃！
- en: '![Image](Image00119.jpg)'
  id: totrans-177
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00119.jpg)'
- en: '*Figure 6-2: Trying to access an index in the array where nothing exists causes
    an error.*'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 6-2：尝试访问数组中不存在的索引会导致错误。*'
- en: '**ADDING ITEMS TO AN ARRAY**'
  id: totrans-179
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**向数组添加项**'
- en: One way to change an array is to add new items to it. There are a few different
    ways to do this, so let’s take a look at each.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 更改数组的一种方法是向其中添加新项。对此有几种不同的方法，让我们逐一查看。
- en: 'First, you can use an array’s append(_:) method. *Append* means to add something.
    Using append(_:) , you can add one new item to the end of your array. Say you
    go on another trip and visit the Badlands, and you want to add it to your list
    of national parks. To do that, add this code into your playground:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，你可以使用数组的 append(_:) 方法。*Append* 意味着添加某物。使用 append(_:)，你可以将一个新项添加到数组的末尾。假设你又去了一个旅行，参观了坏lands，想要将它添加到你的国家公园列表中。为此，请将以下代码添加到你的
    playground：
- en: '![](Image00120.jpg)'
  id: totrans-182
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00120.jpg)'
- en: To use the append(_:) method, first write the name of your array followed by
    a period and then append . Then, put the item you want to add to your array inside
    the parentheses. In this case, you put "Badlands" inside the parentheses.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用 append(_:) 方法，首先写下数组的名称，后跟一个句点，然后写 append。接着，将你要添加到数组的项放在括号内。在这个例子中，你将 "Badlands"
    放在括号内。
- en: 'If you want to add something at a specific place in your array, use the array’s
    insert(_:at:) method instead. This method takes two arguments: the item that you
    want to insert and the index of where it should go in the array. (We’ll discuss
    arguments in more detail in [Chapter 7](text00017.html#ch07) .)'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想在数组中的特定位置添加某项，请改用数组的 insert(_:at:) 方法。此方法接受两个参数：你要插入的项以及它在数组中应该放置的索引。（我们将在[第7章](text00017.html#ch07)中更详细地讨论参数。）
- en: 'Let’s say you totally forgot that you went to the Petrified Forest right after
    you visited the Grand Canyon, and you want to update your nationalParks array
    so it displays the parks in the order in which you visited them. To update your
    array, you could use the insert(_:at:) method to put the Petrified Forest in the
    right position:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你完全忘记了在参观大峡谷后去了化石森林，你想更新你的 nationalParks 数组，使其显示你访问过的国家公园的顺序。为了更新你的数组，你可以使用
    insert(_:at:) 方法将化石森林放到正确的位置：
- en: '![](Image00121.jpg)'
  id: totrans-186
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00121.jpg)'
- en: When you insert a new item at index 3, everything that was in the array at index
    3 or higher gets scooted over to make room for the new item. That means the item
    that was at index 3 is now at index 4, the item that was at index 4 is now at
    index 5, and so on. After you add the Petrified Forest, nationalParks is now ["Acadia",
    "Zion", "Grand Canyon", "Petrified Forest", "Badlands"] .
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 当你在索引3的位置插入新项目时，数组中从索引3开始的所有项目都会向后移动，为新项目腾出空间。这意味着原本在索引3的项目现在会在索引4，原本在索引4的项目会在索引5，以此类推。加入“化石森林”之后，nationalParks数组变成了["Acadia",
    "Zion", "Grand Canyon", "Petrified Forest", "Badlands"]。
- en: '**COMBINING ARRAYS**'
  id: totrans-188
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**合并数组**'
- en: 'Not only can you add new items to an array, but you can also add two arrays
    together using the + and += operators. Let’s say that you have the ingredients
    for a fruit smoothie in two arrays:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 不仅可以将新项目添加到数组中，还可以使用+和+=运算符将两个数组合并。假设你有两个数组，分别包含水果奶昔的配料：
- en: '![](Image00122.jpg)'
  id: totrans-190
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00122.jpg)'
- en: Now you can make a delicious smoothie by adding the fruits and liquids arrays.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你可以通过将水果和液体数组合并，做出美味的奶昔。
- en: '![](Image00123.jpg)'
  id: totrans-192
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00123.jpg)'
- en: The order of the ingredients in smoothie is the same as the order in fruits
    and liquids . If you created smoothie with liquids + fruits , then the liquids
    would come first.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 奶昔中的配料顺序与水果和液体的顺序相同。如果你先加入液体再加入水果，那么液体会排在前面。
- en: 'You use the += operator to add an array to the end of your array. Add some
    whipped cream as follows for extra yumminess:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 你使用+=运算符将一个数组添加到数组的末尾。如下所示，加入一些鲜奶油，以增加美味：
- en: '![](Image00124.jpg)'
  id: totrans-195
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00124.jpg)'
- en: Note that ["whipped cream"] is an array even though it has a single item in
    it. When you’re using += to append something to an array, you have to make sure
    you’re only trying to add another array. If you were to just write the string
    "whipped cream" without the square brackets around it, you would get an error.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，["whipped cream"]是一个数组，尽管它只有一个项目。当你使用+=运算符将某个内容添加到数组时，必须确保你添加的是另一个数组。如果你只是写上字符串"whipped
    cream"，没有方括号包围，就会报错。
- en: '![Image](Image00125.jpg)'
  id: totrans-197
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00125.jpg)'
- en: '**REMOVING ITEMS FROM AN ARRAY**'
  id: totrans-198
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**从数组中移除项目**'
- en: 'There are several methods for removing items from an array. Let’s start by
    looking at the array’s removeLast() method. As you might have guessed from its
    name, removeLast() removes the last item from your array. Let’s try it out with
    a shoppingList array:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 有几种方法可以从数组中移除项目。我们先来看一下数组的removeLast()方法。顾名思义，removeLast()方法会移除数组中的最后一个项目。我们用一个shoppingList数组来尝试一下：
- en: '![](Image00126.jpg)'
  id: totrans-200
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00126.jpg)'
- en: Neat! Note that the removeLast() method returns the removed item, so you can
    store it in a new constant or variable if you want.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 很棒！请注意，removeLast()方法会返回被移除的项目，所以如果你愿意，可以将其存储在一个新的常量或变量中。
- en: 'You can also remove an item from a specific index by using the remove(at:)
    method. Let’s say that your mom doesn’t want you buying any candy and takes that
    off the list:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以通过使用remove(at:)方法从特定索引移除一个项目。假设你妈妈不希望你买糖果，并把它从列表中移除：
- en: '![Image](Image00127.jpg)![](Image00128.jpg)'
  id: totrans-203
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00127.jpg)![](Image00128.jpg)'
- en: Just like when we added an item to the middle of our array and all the items
    scooted over to make room, if you remove an item from the middle of an array,
    the rest of the items will scoot back to fill in that empty space. The "apples"
    item that was at index 3 is now at index 2, where "candy" was.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 就像我们在数组中间添加项目时，所有项目会向后移动腾出空间一样，如果你从数组中间移除一个项目，剩余的项目会向前移动，填补空缺。"apples"原本在索引3的位置，现在位于索引2，原本在该位置的"candy"被移除。
- en: 'You can also remove all items from an array with removeAll() . Try entering
    this into your playground:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以使用removeAll()方法移除数组中的所有项目。试着在你的 playground 中输入这个：
- en: '![](Image00129.jpg)'
  id: totrans-206
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00129.jpg)'
- en: 'Note that trying to remove an item at an index that doesn’t exist will give
    you an error:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，尝试移除一个不存在的索引位置的项目会抛出一个错误：
- en: '![](Image00130.jpg)'
  id: totrans-208
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00130.jpg)'
- en: Our array doesn’t have this many items (in fact, now it’s empty!), so this throws
    an error. We’ll also get an error if we use removeLast() on our empty array, because
    there’s nothing in it—there’s no last index at all! However, removeAll() is always
    safe to use, even on an empty array.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的数组没有这么多项（实际上，现在它是空的！），所以这会抛出一个错误。如果我们在空数组上使用removeLast()，也会出错，因为数组里没有任何内容——根本没有最后一个索引！然而，removeAll()总是可以安全使用，即使是在空数组上。
- en: '**REPLACING ITEMS IN AN ARRAY**'
  id: totrans-210
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**替换数组中的项目**'
- en: 'To replace an item in an array, you set the index of the array to the new value,
    as shown here:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 要替换数组中的一个项目，你需要将数组的索引设置为新的值，如下所示：
- en: '![](Image00131.jpg)'
  id: totrans-212
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00131.jpg)'
- en: At ➊ , we replaced the item at index 2 (the third item) with "Unicorn" because
    magical animals count as favorite animals, too! At ➋ , we replaced the item at
    index 0 (the first item) with "Bearded dragon" . No, that’s not a real dragon—it’s
    just a lizard!
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 在➊处，我们用“独角兽”替换了索引2（第三项）的项目，因为神奇的动物也算是喜欢的动物！在➋处，我们用“胡须龙”替换了索引0（第一项）的项目。不是的，那不是一条真正的龙——它只是一只蜥蜴！
- en: Like any time you’re working with array index numbers, you have to be sure an
    item exists in the array at that index before you change its value, or you will
    get an Index out of range error.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 就像每次你处理数组索引时一样，你必须确保在更改某个索引的值之前，该索引在数组中存在，否则会出现“索引超出范围”错误。
- en: '[Figure 6-3](text00016.html#ch06fig3) shows the error that occurs if you try
    to add "Standard poodle" using favoriteAnimals[3] = "Standard poodle" . To add
    an item to the end of an array, you should use the append(_:) method or += , as
    we covered in “[Adding Items to an Array](text00016.html#ch06lev2sec5) ” on [page
    70](text00016.html#page_70) .'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: '[图6-3](text00016.html#ch06fig3)显示了当你尝试通过favoriteAnimals[3] = "Standard poodle"添加“标准贵宾犬”时会发生的错误。要将项目添加到数组的末尾，你应该使用append(_:)方法或+=，正如我们在“[向数组添加项](text00016.html#ch06lev2sec5)”中第70页所讲解的那样。'
- en: '![Image](Image00132.jpg)'
  id: totrans-216
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00132.jpg)'
- en: '*Figure 6-3: Don’t try to replace a value at an index beyond the existing array.*'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: '*图6-3：不要尝试替换数组中超出范围的索引的值。*'
- en: Now you know how to change arrays however you might need to. You can add items,
    take items away, or replace items. Next, we’ll look at how to use the properties
    of arrays to find out even more information about them.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经知道如何根据需要更改数组了。你可以添加项目、删除项目或替换项目。接下来，我们将学习如何使用数组的属性获取更多关于数组的信息。
- en: '![Image](Image00133.jpg)'
  id: totrans-219
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00133.jpg)'
- en: '**USING ARRAY PROPERTIES**'
  id: totrans-220
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**使用数组属性**'
- en: In addition to methods like append(_:) and removeLast() , arrays also have *properties*
    . An array’s properties are variables or constants that contain some information
    about the array. Two really helpful properties that you might use are the Boolean
    property isEmpty and the integer property count .
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 除了像append(_:)和removeLast()这样的函数，数组还有*属性*。数组的属性是包含有关数组的一些信息的变量或常量。你可能会用到的两个非常有用的属性是布尔属性isEmpty和整数属性count。
- en: The isEmpty property is true or false depending on whether the array is empty,
    and the count property will tell you how many items are in that array.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: isEmpty属性的值是true或false，取决于数组是否为空，而count属性会告诉你数组中有多少项。
- en: 'Check out how these two properties are used in the following if-else statement:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 查看以下if-else语句中这两个属性是如何使用的：
- en: '![Image](Image00134.jpg)'
  id: totrans-224
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00134.jpg)'
- en: 'This if-else statement checks whether the array mySiblings is empty ➊ . If
    it is, then "I don''t have any siblings." is printed. But if there is something
    in the array, then the number of siblings that we have is printed: "I have 3 siblings."
    ➋ .'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 这个if-else语句检查数组mySiblings是否为空 ➊。如果为空，则打印出“我没有兄弟姐妹。”如果数组中有内容，则打印出我们有多少兄弟姐妹：“我有3个兄弟姐妹。”
    ➋。
- en: '**LOOPING OVER AN ARRAY**'
  id: totrans-226
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**遍历数组**'
- en: 'Sometimes when you’re working with arrays you might want to do something to
    every item in the array. You can use a for-in loop to do that! The following code
    will print every topping in a pizzaToppings array on a separate line:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 有时在处理数组时，你可能希望对数组中的每一项执行相同的操作。你可以使用for-in循环来实现！以下代码将逐行打印出pizzaToppings数组中的每个配料：
- en: '![Image](Image00135.jpg)'
  id: totrans-228
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00135.jpg)'
- en: To write a for-in loop for the pizzaToppings array, we used the keyword for
    , followed by the constant topping , then the keyword in , and finally the name
    of our array, pizzaToppings . Then we put the statements that we want to run for
    each topping inside the braces of the for-in loop. The constant topping ➊ temporarily
    represents each pizza topping in the array as we loop through it. We could have
    chosen any name for this constant, but it’s a good idea to pick something that
    makes sense. You can see the output of this for-in loop in [Figure 6-4](text00016.html#ch06fig4)
    .
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 要为pizzaToppings数组编写for-in循环，我们使用关键字for，接着是常量topping，然后是关键字in，最后是数组的名称pizzaToppings。接下来，我们将希望为每个配料执行的语句放在for-in循环的大括号内。常量topping
    ➊ 在我们遍历数组时暂时表示数组中的每个披萨配料。我们本可以为这个常量选择任何名字，但选择一个有意义的名称是个好主意。你可以在[图6-4](text00016.html#ch06fig4)中查看这个for-in循环的输出。
- en: '![Image](Image00136.jpg)'
  id: totrans-230
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00136.jpg)'
- en: '*Figure 6-4: Output of the example for-in loop*'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: '*图6-4：示例for-in循环的输出*'
- en: '![Image](Image00137.jpg)'
  id: totrans-232
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00137.jpg)'
- en: 'Using for-in loops is great for printing every value in an array. If you’re
    working with numbers, you can even use them to perform math operations on each
    item, which makes for some speedy calculations! The following code takes an array
    of numbers and calculates the square for each (the square of a number is that
    number multiplied by itself):'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `for-in` 循环非常适合打印数组中的每个值。如果你正在处理数字，甚至可以使用它们对每个项目执行数学运算，这样可以快速进行计算！以下代码接受一个数字数组，并计算每个数字的平方（一个数字的平方是该数字与其自身相乘）：
- en: '![Image](Image00138.jpg)'
  id: totrans-234
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00138.jpg)'
- en: '[Figure 6-5](text00016.html#ch06fig5) shows the results.'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 6-5](text00016.html#ch06fig5)显示了结果。'
- en: '![Image](Image00139.jpg)'
  id: totrans-236
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00139.jpg)'
- en: '*Figure 6-5: Printing the squares for each number in the myNumbers array*'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 6-5：打印 myNumbers 数组中每个数字的平方*'
- en: '**DICTIONARIES ARE KEY!**'
  id: totrans-238
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**字典非常重要！**'
- en: A *dictionary* is also a collection of values, but instead of an ordered index,
    each value has its own *key* . Because there’s no index, the values are not stored
    in any particular order. To access values in a dictionary, you look them up by
    their key.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 一个*字典*也是一个值的集合，但与数组不同，每个值都有自己的*键*。由于没有索引，值并不会按特定顺序存储。要访问字典中的值，你需要通过键来查找它们。
- en: A key must be unique. You can’t have the same key more than once in the same
    dictionary. If there were two identical keys and you asked the computer to give
    you the value for one of them, the computer wouldn’t know which one to choose!
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 键必须是唯一的。你不能在同一个字典中有两个相同的键。如果有两个相同的键，而你要求计算机给你其中一个的值，计算机将不知道选择哪个！
- en: Let’s take a look at how to make a dictionary and write keys that will help
    you find all the information you need.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看一下如何创建一个字典，并写出帮助你找到所需信息的键。
- en: '![Image](Image00140.jpg)'
  id: totrans-242
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00140.jpg)'
- en: '**INITIALIZING A DICTIONARY**'
  id: totrans-243
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**初始化字典**'
- en: 'To create and initialize a dictionary, first write var and the name of your
    dictionary. Then write the keys and corresponding values inside a pair of square
    brackets, similar to an array. Let’s create a dictionary to store the names of
    a few US states. The key for each state will be its two-letter abbreviation:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建和初始化一个字典，首先写上`var`和字典的名称。然后在一对方括号中写上键和对应的值，类似于数组。让我们创建一个字典来存储一些美国州的名字。每个州的键将是它的两字母缩写：
- en: '![](Image00141.jpg)'
  id: totrans-245
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00141.jpg)'
- en: As you can see, there’s a colon between each key and its value, and the key/value
    pairs are separated by commas.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，每个键和值之间有一个冒号，键值对之间用逗号分隔。
- en: Dictionaries are different from arrays in that they are *unordered* . Because
    of that, it’s likely that the order of the states that you see in your results
    pane ➋ is different from the order in which you entered your states ➊ . It might
    even be different than the order that’s printed in this book!
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 字典与数组的不同之处在于它们是*无序的*。因此，你在结果面板中看到的州的顺序➋可能与输入州的顺序➊不同。甚至可能与本书中打印的顺序不同！
- en: As with arrays, you can use var to make a mutable dictionary or use let to make
    an immutable dictionary.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 与数组一样，你可以使用`var`来创建一个可变字典，或使用`let`来创建一个不可变字典。
- en: 'In Swift, all of the keys of a dictionary must be the same type, and all of
    the values of a dictionary must also be the same type, but the key type doesn’t
    have to match the value type. For example, if you wanted to store a collection
    of fractions, you could use doubles for the keys and strings for the values:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Swift 中，字典的所有键必须是相同的类型，字典的所有值也必须是相同的类型，但键的类型不需要与值的类型匹配。例如，如果你想存储一组分数，你可以使用双精度浮点数作为键，字符串作为值：
- en: '![](Image00142.jpg)'
  id: totrans-250
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00142.jpg)'
- en: In this dictionary, all of the keys must be doubles, and all of the values must
    be strings. Again, you’ll see that the order of the numbers in the results pane
    can be quite different from the order in which you wrote the fractions in your
    dictionary. This is fine because you don’t need to know the order to access anything.
    You can find any item that you need by its key. Let’s see how!
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个字典中，所有键必须是双精度浮点数，所有值必须是字符串。同样，你会看到结果面板中的数字顺序可能与在字典中写入分数的顺序完全不同。这没关系，因为你不需要知道顺序就能访问任何内容。你可以通过键找到任何你需要的项。让我们来看看！
- en: '**ACCESSING VALUES IN A DICTIONARY**'
  id: totrans-252
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**访问字典中的值**'
- en: 'Looking up a value in a dictionary is similar to how you access a value in
    an array except that you use a key inside the square brackets instead of an index,
    like this: usStates["TX"] .'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 在字典中查找一个值类似于你在数组中访问一个值的方式，只不过你使用的是键而不是索引，像这样：usStates["TX"]。
- en: There is a big difference, however, in how Swift returns the values from a dictionary.
    When you access a value at an index of an array, you are simply given the value.
    When you access a value with a key in a dictionary, you are given an optional.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，Swift在返回字典中的值时有一个很大的区别。当你访问数组中的一个索引值时，你只是得到了值。而当你使用字典中的键访问值时，你得到的是一个可选值。
- en: In [Chapter 5](text00015.html#ch05) , you learned that optionals might contain
    a value or might be nil . The reason Swift returns optionals when you’re looking
    up items in a dictionary is that the key you used might not exist in the dictionary,
    in which case there’s no value to access. Trying to access a value that doesn’t
    exist would give you a big fat error! To avoid that problem, Swift returns optionals.
    That means you need to unwrap any value you get out of a dictionary before you
    can do anything with it.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第5章](text00015.html#ch05)中，你学到可选值可能包含一个值，也可能为nil。当你在字典中查找项目时，Swift返回可选值的原因是你使用的键可能在字典中不存在，在这种情况下就没有值可访问。试图访问一个不存在的值会导致一个大错误！为避免这个问题，Swift返回可选值。这意味着你在对字典取值后，需要解包任何得到的值，才能对其进行操作。
- en: 'To unwrap an optional, first you check whether it exists using an if-let statement,
    just like we did in [Chapter 5](text00015.html#ch05) . The following code shows
    you how to get a value out of a dictionary:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 要解包一个可选值，首先你需要使用if-let语句检查它是否存在，就像我们在[第5章](text00015.html#ch05)中做的那样。下面的代码展示了如何从字典中获取一个值：
- en: '![Image](Image00143.jpg)'
  id: totrans-257
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00143.jpg)'
- en: To retrieve "Texas" from the dictionary, we use if let to set a constant loneStarState
    to usStates["TX"] ➊ . Because we have this state in our dictionary, the line I
    have Texas in my dictionary. is printed. Next we try to access a state that is
    not in our dictionary by using the key usStates["FL"] ➋ . Thankfully, because
    we used an if-let statement, the program won’t crash when the computer can’t find
    this state. Instead, I don't have that state in my dictionary. is printed.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 要从字典中取出"Texas"，我们使用if let语句将常量loneStarState设置为usStates["TX"] ➊。因为我们在字典中有这个州，所以打印出"I
    have Texas in my dictionary"。接下来，我们尝试通过使用键usStates["FL"] ➋来访问一个不在字典中的州。幸运的是，由于我们使用了if-let语句，当计算机找不到该州时，程序不会崩溃。相反，打印出"I
    don't have that state in my dictionary"。
- en: '**ADDING ITEMS TO A DICTIONARY**'
  id: totrans-259
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**向字典中添加项目**'
- en: 'To add an item to a dictionary, first write the name of your dictionary and
    assign the new item to the key you want it to have in the dictionary. Let’s add
    "Minnesota" to our usStates dictionary:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 要向字典中添加一个项目，首先写出字典的名称，并将新的项目赋给你希望它在字典中对应的键。让我们把"Minnesota"添加到我们的usStates字典中：
- en: '![](Image00144.jpg)'
  id: totrans-261
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00144.jpg)'
- en: 'Now when you look at usStates , you’ll see that it’s updated to ["MN": "Minnesota",
    "WA": "Washington", "MA": "Massachusetts", "TX": "Texas"] . Remember, because
    you don’t have to rely on indices, your new dictionary item might appear anywhere
    in the dictionary.'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: '现在，当你查看usStates时，你会看到它已经更新为["MN": "Minnesota", "WA": "Washington", "MA": "Massachusetts",
    "TX": "Texas"]。记住，由于你不需要依赖索引，新的字典项目可能会出现在字典的任何位置。'
- en: '**REMOVING ITEMS FROM A DICTIONARY**'
  id: totrans-263
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**从字典中移除项目**'
- en: Removing an item from a dictionary is quite simple; you do so by setting the
    value to nil . Because the values in dictionaries are returned as optionals, you
    don’t have to worry about nil causing any problems in your dictionary.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 从字典中移除一个项目非常简单；你只需将该值设置为nil。因为字典中的值是以可选值的形式返回的，所以你不必担心nil会导致字典中的任何问题。
- en: '![](Image00145.jpg)'
  id: totrans-265
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00145.jpg)'
- en: 'You can see that after you remove the value at the key "MA" , usStates is updated
    to ["MN": "Minnesota", "WA": "Washington", "TX": "Texas"] . Remember that nil
    is special and means that there’s no value at all. That’s why you don’t see "MA":
    nil in our dictionary.'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: '你可以看到，在你移除键"MA"对应的值后，usStates已经更新为["MN": "Minnesota", "WA": "Washington", "TX":
    "Texas"]。记住，nil是特别的，表示没有值。这就是为什么你在字典中看不到"MA": nil。'
- en: '**REPLACING ITEMS IN A DICTIONARY**'
  id: totrans-267
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**替换字典中的项目**'
- en: 'Replacing an item in a dictionary is also easy. It works the same was as replacing
    an item in an array. You just set the item that you want to replace to something
    else. Say you create a dictionary of fruit colors:'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 替换字典中的项目也很简单。它与替换数组中的项目的方式相同。你只需要将要替换的项目设置为其他内容。比如你创建了一个表示水果颜色的字典：
- en: '![](Image00146.jpg)'
  id: totrans-269
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00146.jpg)'
- en: At first we had the value "apple" for "red" , but then we decided that "raspberry"
    is a better fruit to use since sometimes apples are green or yellow. To replace
    "apple" with "raspberry" , we set colorFruits["red"] to its new value ➊ .
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 最初我们为"red"设置了"apple"的值，但后来我们决定使用"raspberry"作为更好的水果，因为有时苹果是绿色或黄色的。为了将"apple"替换为"raspberry"，我们将colorFruits["red"]设置为它的新值
    ➊。
- en: You may remember that this is the same way we entered a new value into a dictionary.
    If the key already exists in the dictionary, then the value for that key is replaced.
    If the key doesn’t already exist, then the new key/value pair will be added to
    the dictionary.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能记得这与我们向字典中添加新值的方式相同。如果字典中已经存在该键，那么该键的值将被替换。如果该键不存在，则新键/值对将添加到字典中。
- en: '![Image](Image00147.jpg)'
  id: totrans-272
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00147.jpg)'
- en: '**USING DICTIONARY PROPERTIES**'
  id: totrans-273
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**使用字典属性**'
- en: 'Like an array, a dictionary also has an isEmpty property and a count property.
    For example, the following code shows how you can use the isEmpty property to
    check if a dictionary is empty, and if it isn’t empty, the count property checks
    how many items you have. Imagine you have a basket of fruit for sale. You can
    use these properties to help you keep track of everything:'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 像数组一样，字典也有isEmpty属性和count属性。例如，以下代码展示了如何使用isEmpty属性来检查字典是否为空，如果字典不为空，则使用count属性检查字典中的项目数。想象一下你有一个待售的水果篮。你可以利用这些属性帮助你追踪一切：
- en: '![Image](Image00148.jpg)'
  id: totrans-275
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00148.jpg)'
- en: 'A dictionary also has two special properties: keys , which contains all of
    the dictionary’s keys, and values , which contains all of its values. We’ll use
    these two properties when we loop through the dictionary.'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 字典还有两个特殊属性：keys，它包含字典的所有键，以及values，它包含字典的所有值。我们将在遍历字典时使用这两个属性。
- en: Let’s write some code that loops through our fruit baskets and prints the price
    of each fruit.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们写一些代码来遍历我们的水果篮，并打印每种水果的价格。
- en: '**LOOPING OVER A DICTIONARY**'
  id: totrans-278
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**遍历字典**'
- en: 'You can loop through a dictionary using a for-in loop. Because each item has
    a key and a value, you can do this in two different ways. This is how to loop
    through a dictionary using its keys:'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用for-in循环来遍历字典。由于每个项目都有一个键和值，因此你可以以两种不同的方式进行遍历。这是使用字典的键来遍历字典的方法：
- en: '![Image](Image00149.jpg)'
  id: totrans-280
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00149.jpg)'
- en: Here we use the dictionary’s keys property ➊ to loop through fruitBasket and
    print its contents. We start by writing the keyword for , followed by a constant
    name fruit for the dictionary key, the keyword in , the dictionary name, a period,
    and keys .
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们使用字典的keys属性 ➊ 来遍历fruitBasket并打印其内容。我们首先写下关键字for，后面跟着字典键的常量名fruit，接着是关键字in，字典名称，一个句点，然后是keys。
- en: Inside the braces of our for-in loop, we have access to both the key, which
    we call fruit ➋ , and the value at that key when we force-unwrap its contents
    with fruitBasket[fruit]! ➌ . That value will be the fruit’s price.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 在for-in循环的大括号内部，我们可以访问到键（我们称之为fruit ➋）以及通过强制解包它的内容fruitBasket[fruit]! ➌ 获得的值。该值将是水果的价格。
- en: In this case, it’s safe to force-unwrap the value using an exclamation point
    because we know that the fruit key we’re using is definitely inside the dictionary.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，强制解包该值是安全的，因为我们知道正在使用的水果键一定在字典中。
- en: Any code we put inside the for-in loop will run once for every key in our dictionary.
    So you should see the print statement display three times.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 我们放入for-in循环中的任何代码都会针对字典中的每个键执行一次。所以你应该看到打印语句显示三次。
- en: 'We can also loop through the dictionary using its values property:'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以使用字典的values属性来遍历字典：
- en: '![Image](Image00150.jpg)'
  id: totrans-286
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00150.jpg)'
- en: We use the same style of for-in loop, but now we use a constant to refer to
    each value, which we call price , in the values property. When looping through
    values, we don’t have access to the keys from inside the loop.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用相同的for-in循环样式，但现在我们使用常量来引用values属性中的每个值，我们将其称为price。在遍历values时，我们无法从循环内部访问键。
- en: Another difference to note is that price is not an optional because it’s accessed
    directly as a value in the fruitBasket dictionary. That means we don’t have to
    unwrap it. You should still see the print statement printed three times. [Figure
    6-6](text00016.html#ch06fig6) shows the output of both loops.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个需要注意的区别是，price不是一个可选项，因为它是直接作为fruitBasket字典中的值访问的。这意味着我们不需要解包它。你仍然应该看到打印语句打印三次。[图6-6](text00016.html#ch06fig6)显示了两个循环的输出。
- en: '![Image](Image00151.jpg)'
  id: totrans-289
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00151.jpg)'
- en: '*Figure 6-6: Looping through the keys and values of a dictionary with a for-in
    loop*'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: '*图6-6：使用 for-in 循环遍历字典的键和值*'
- en: The order of your results might be slightly different from ours. That’s because
    the items in a dictionary aren’t in a numbered order like they are in an array!
    And because the order is not guaranteed, you might see a different order printed
    if you run the same code again.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 你的结果顺序可能会与我们的略有不同。这是因为字典中的项不像数组中的项那样按编号顺序排列！并且由于顺序没有保证，因此如果你再次运行相同的代码，可能会看到不同的顺序。
- en: '**WHAT YOU LEARNED**'
  id: totrans-292
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**你学到了什么**'
- en: In this chapter, you learned how to store collections of items in an array and
    in a dictionary. To store items in an ordered list, you would use an array and
    look up each item by its index. If you wanted to store items by key instead, you
    would use a dictionary.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一章中，你学到了如何在数组和字典中存储项的集合。要在有序列表中存储项，你应使用数组，并通过其索引查找每一项。如果你想根据键存储项，你则应使用字典。
- en: Knowing about arrays and dictionaries and how to use them is a powerful building
    block for almost any programming language. Next we will learn about functions,
    another very powerful tool. Functions are blocks of code that you create and name
    to perform a specific job. After you have written a function, you can use its
    name to call it from almost anywhere in your program.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 了解数组和字典以及如何使用它们，是几乎所有编程语言中的一个强大基础。接下来，我们将学习函数，这是另一个非常强大的工具。函数是你创建并命名的代码块，用来执行特定的任务。写完函数后，你可以通过它的名字从程序中的几乎任何地方调用它。
- en: '![Image](Image00001.jpg)'
  id: totrans-295
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00001.jpg)'
- en: In previous chapters, you learned that you can store a single piece of information
    in a variable or constant. But what if you want to store a collection of things,
    like the names of all the places you’ve visited or all the books that you’ve read?
    In this chapter, we’ll introduce you to arrays and dictionaries. They’re both
    used to store collections of values. Using arrays and dictionaries, you can work
    with a lot of data at once and make your programs more powerful!
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的章节中，你学到了如何在变量或常量中存储单一的信息。但如果你想存储一组事物，比如你访问过的所有地方的名称或你读过的所有书的名称呢？在这一章中，我们将向你介绍数组和字典。它们都用于存储值的集合。通过使用数组和字典，你可以一次处理大量数据，并让你的程序更强大！
- en: '**KEEPING THINGS IN ORDER WITH ARRAYS**'
  id: totrans-297
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**使用数组保持事务的顺序**'
- en: An *array* is a list of items of the same data type stored in order, kind of
    like a numbered grocery list. Items in an array are stored by their *index* ,
    a number based on where the item is positioned in the array.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: '*数组* 是一个按顺序存储相同数据类型的项的列表，就像是一个编号的购物清单。数组中的项是通过其 *索引* 来存储的，索引是一个基于项在数组中位置的数字。'
- en: When you write a grocery list, you usually start with the number 1, but in computer
    programming, an index starts at 0, not 1\. So the first item in an array is always
    at index 0, the second item is at index 1, the third item is at index 2, and so
    on.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 当你写购物清单时，通常从数字1开始，但在计算机编程中，索引是从0开始的，而不是1。所以数组中的第一个项目总是位于索引0，第二个项目位于索引1，第三个项目位于索引2，依此类推。
- en: 'Let’s create an array. If you already know what you’re going to put into your
    array, you can create it and *initialize* it with those values. To initialize
    something in Swift is to give it some initial value so you can use it in your
    program. Let’s say that you want to store a list of all of the national parks
    that you’ve visited. Enter the following into your playground:'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一个数组。如果你已经知道你要放入数组的内容，你可以创建它并用这些值进行 *初始化*。在 Swift 中初始化某个东西是指给它一个初始值，以便你在程序中使用它。假设你想存储一个你访问过的所有国家公园的列表。在你的
    playground 中输入以下内容：
- en: '![](Image00114.jpg)'
  id: totrans-301
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00114.jpg)'
- en: This code creates an array variable called nationalParks and initializes it
    with the names of three national parks. Because we initialized this array to hold
    strings, you’ll only be able to put strings in it.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码创建了一个名为 nationalParks 的数组变量，并用三个国家公园的名称对其进行了初始化。因为我们初始化了这个数组来存储字符串，所以你只能往其中放入字符串。
- en: '[Figure 6-1](text00016.html#ch06fig1) shows how you can imagine your array.
    It’s like a row of boxes containing the three names of national parks at indices
    0, 1, and 2\. Remember that the indices of an array always start at 0!'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: '[图6-1](text00016.html#ch06fig1) 显示了如何想象你的数组。它就像是一排盒子，包含了三个国家公园的名称，分别位于索引0、1和2。记住，数组的索引总是从0开始！'
- en: '![Image](Image00115.jpg)'
  id: totrans-304
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00115.jpg)'
- en: '*Figure 6-1: The nationalParks array*'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: '*图6-1：nationalParks 数组*'
- en: '**USING MUTABLE AND IMMUTABLE ARRAYS**'
  id: totrans-306
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**使用可变和不可变的数组**'
- en: Our nationalParks array is a variable because we created it with the var keyword
    ➊ . An array stored in a variable is called a *mutable* array. This means that
    you can change it by adding items, removing items, or swapping items in and out.
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的 `nationalParks` 数组是一个变量，因为我们使用 `var` 关键字创建了它 ➊。存储在变量中的数组被称为*可变*数组。这意味着你可以通过添加项目、删除项目或替换项目来修改它。
- en: You can also create an *immutable* array. An immutable array is created with
    the keyword let instead of var . Similar to a constant, once an immutable array
    is created, nothing in it can be changed.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以创建一个*不可变*数组。一个不可变数组是使用关键字 `let` 创建的，而不是 `var`。类似于常量，一旦创建了不可变数组，数组中的任何内容都不能更改。
- en: So when should you use a mutable array or an immutable array? It’s best to use
    let if you know your collection will never change, like if you’re storing the
    colors of the rainbow. You should use var if you need to change your collection,
    like if you’re storing an array of your favorite T-shirts, which might change
    depending on what’s in style!
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，什么时候应该使用可变数组或不可变数组呢？如果你知道你的集合永远不会改变，例如存储彩虹的颜色，最好使用 `let`。如果你需要更改集合，例如存储你的最爱
    T 恤的数组（这些可能会根据时尚变化），则应该使用 `var`！
- en: '![Image](Image00116.jpg)'
  id: totrans-310
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00116.jpg)'
- en: '**USING TYPE INFERENCE**'
  id: totrans-311
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**使用类型推断**'
- en: 'When we created our nationalParks array, we specified that we were creating
    an array of string values by adding a colon (: ) and [String] ➋ . This step is
    optional when you create an array and initialize it with one or more values because
    Swift will use type inference to determine the kind of data you want the array
    to hold. That means that you could just as easily have created the array by doing
    this:'
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们创建 `nationalParks` 数组时，我们通过添加冒号（:）和 `[String]` ➋ 来指定我们正在创建一个字符串值的数组。当你创建一个数组并用一个或多个值初始化它时，这一步是可选的，因为
    Swift 会使用类型推断来确定数组要存储的数据类型。这意味着你也可以像这样轻松创建数组：
- en: '![](Image00117.jpg)'
  id: totrans-313
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00117.jpg)'
- en: Using type inference, Swift knows we initialized this array to hold strings,
    and it can hold only strings.
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 通过类型推断，Swift 知道我们初始化了这个数组来存储字符串，而且它只能存储字符串。
- en: The list of parks that we created the array with is an example of an array *literal*
    . A literal is a value that is exactly what you see. It is not a variable or constant
    but rather just the value without a name. "Grand Canyon" is an example of a string
    literal, and 7 is an example of an integer literal. An array literal is a list
    of items contained between two square brackets and separated by commas, like ["Acadia",
    "Zion", "Grand Canyon"] ➊ .
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建数组时使用的公园列表是一个数组*字面量*的例子。字面量是一个值，正是你所看到的内容。它不是一个变量或常量，而是没有名称的值。"Grand Canyon"
    是字符串字面量的例子，而 7 是整数字面量的例子。数组字面量是包含在两个方括号之间并用逗号分隔的项目列表，例如 ["Acadia", "Zion", "Grand
    Canyon"] ➊。
- en: '**ACCESSING ITEMS IN AN ARRAY**'
  id: totrans-316
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**访问数组中的项**'
- en: 'Let’s say you want to access an item in your array and use it in your program.
    Your friend asks you to tell them all about your travels, so you want to use the
    names of the national parks that you stored in the array. To access an item in
    your array, write the array name followed by the item’s index inside square brackets:'
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你想在程序中访问一个数组项并使用它。你的朋友要求你告诉他们所有的旅行经历，所以你想使用存储在数组中的国家公园名称。要访问数组中的某个项目，只需编写数组名称，后跟项目的索引，索引位于方括号中：
- en: '![](Image00118.jpg)'
  id: totrans-318
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00118.jpg)'
- en: In this example, we are accessing the names of the national parks and then printing
    them to the screen using print . To get the first item in nationalParks , you
    use nationalParks[0] ➊ . To access the second item in nationalParks , you use
    nationalParks[1] .
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们正在访问国家公园的名称，并通过使用 `print` 将它们打印到屏幕上。要获取 `nationalParks` 中的第一个项目，您可以使用
    `nationalParks[0]` ➊。要访问 `nationalParks` 中的第二个项目，您可以使用 `nationalParks[1]`。
- en: '**WATCHING THE RANGE**'
  id: totrans-320
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**观察范围**'
- en: One important point about arrays is that if you try to access an item at an
    index that’s higher than the last index in the array, you’ll get an error. In
    [Figure 6-2](text00016.html#ch06fig2) , you can see that nationalParks[3] (which
    would be the fourth item in the array) gives you an error because there are only
    three national parks in the array, indexed from 0 to 2.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 关于数组的一个重要点是，如果你尝试访问一个比数组最后一个索引更高的索引，你会得到一个错误。在[图 6-2](text00016.html#ch06fig2)中，你可以看到
    `nationalParks[3]`（即数组中的第四项）会报错，因为数组中只有三个国家公园，索引从 0 到 2。
- en: As you can see, you get an error message that says Index out of range . If you
    try to access an item that doesn’t exist in your array, your app will crash!
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，出现了一个错误信息：“Index out of range”。如果你尝试访问数组中不存在的元素，应用程序将崩溃！
- en: '![Image](Image00119.jpg)'
  id: totrans-323
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00119.jpg)'
- en: '*Figure 6-2: Trying to access an index in the array where nothing exists causes
    an error.*'
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 6-2：尝试访问数组中不存在的索引会导致错误。*'
- en: '**ADDING ITEMS TO AN ARRAY**'
  id: totrans-325
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**向数组添加元素**'
- en: One way to change an array is to add new items to it. There are a few different
    ways to do this, so let’s take a look at each.
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 改变数组的一种方法是向其中添加新元素。有几种不同的方法可以做到这一点，接下来我们来看看每种方法。
- en: 'First, you can use an array’s append(_:) method. *Append* means to add something.
    Using append(_:) , you can add one new item to the end of your array. Say you
    go on another trip and visit the Badlands, and you want to add it to your list
    of national parks. To do that, add this code into your playground:'
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，你可以使用数组的 append(_:) 方法。*Append* 意味着添加某个元素。通过 append(_:) 方法，你可以将一个新项添加到数组的末尾。假设你去了另一个地方，参观了坏lands（Badlands），并希望将其添加到你的国家公园列表中。为此，将以下代码添加到你的
    playground 中：
- en: '![](Image00120.jpg)'
  id: totrans-328
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00120.jpg)'
- en: To use the append(_:) method, first write the name of your array followed by
    a period and then append . Then, put the item you want to add to your array inside
    the parentheses. In this case, you put "Badlands" inside the parentheses.
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 append(_:) 方法时，首先写下数组的名称，后跟一个句点，然后是 append。接着，将你想要添加到数组中的项放入括号中。在这种情况下，你将“Badlands”放入了括号中。
- en: 'If you want to add something at a specific place in your array, use the array’s
    insert(_:at:) method instead. This method takes two arguments: the item that you
    want to insert and the index of where it should go in the array. (We’ll discuss
    arguments in more detail in [Chapter 7](text00017.html#ch07) .)'
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想在数组的特定位置添加元素，可以使用数组的 insert(_:at:) 方法。这个方法接受两个参数：要插入的元素和它应该放置的索引位置。（我们将在[第
    7 章](text00017.html#ch07) 中详细讨论参数。）
- en: 'Let’s say you totally forgot that you went to the Petrified Forest right after
    you visited the Grand Canyon, and you want to update your nationalParks array
    so it displays the parks in the order in which you visited them. To update your
    array, you could use the insert(_:at:) method to put the Petrified Forest in the
    right position:'
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你完全忘记了自己在参观大峡谷后立刻去过 Petrified Forest（化石森林），现在你想更新你的 nationalParks 数组，以便按照你参观的顺序显示公园。为了更新数组，你可以使用
    insert(_:at:) 方法，将 Petrified Forest 插入到正确的位置：
- en: '![](Image00121.jpg)'
  id: totrans-332
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00121.jpg)'
- en: When you insert a new item at index 3, everything that was in the array at index
    3 or higher gets scooted over to make room for the new item. That means the item
    that was at index 3 is now at index 4, the item that was at index 4 is now at
    index 5, and so on. After you add the Petrified Forest, nationalParks is now ["Acadia",
    "Zion", "Grand Canyon", "Petrified Forest", "Badlands"] .
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 当你在索引 3 处插入新项时，所有位于索引 3 或更高位置的元素都会被移动，以腾出空间给新项。这意味着原本在索引 3 处的元素现在位于索引 4，原本在索引
    4 处的元素现在位于索引 5，以此类推。在你添加了“Petrified Forest”后，nationalParks 数组变为 ["Acadia", "Zion",
    "Grand Canyon", "Petrified Forest", "Badlands"]。
- en: '**COMBINING ARRAYS**'
  id: totrans-334
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**合并数组**'
- en: 'Not only can you add new items to an array, but you can also add two arrays
    together using the + and += operators. Let’s say that you have the ingredients
    for a fruit smoothie in two arrays:'
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 不仅可以向数组添加新项，还可以使用 + 和 += 运算符将两个数组连接起来。假设你有两个数组，分别存储水果冰沙的原料：
- en: '![](Image00122.jpg)'
  id: totrans-336
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00122.jpg)'
- en: Now you can make a delicious smoothie by adding the fruits and liquids arrays.
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你可以通过将水果和液体数组结合起来，制作美味的冰沙。
- en: '![](Image00123.jpg)'
  id: totrans-338
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00123.jpg)'
- en: The order of the ingredients in smoothie is the same as the order in fruits
    and liquids . If you created smoothie with liquids + fruits , then the liquids
    would come first.
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 冰沙中的原料顺序与 fruits 和 liquids 中的顺序相同。如果你用 liquids + fruits 来制作冰沙，那么液体会排在前面。
- en: 'You use the += operator to add an array to the end of your array. Add some
    whipped cream as follows for extra yumminess:'
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用 += 运算符将一个数组添加到另一个数组的末尾。为了让冰沙更加美味，可以像下面这样加入一些搅打奶油：
- en: '![](Image00124.jpg)'
  id: totrans-341
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00124.jpg)'
- en: Note that ["whipped cream"] is an array even though it has a single item in
    it. When you’re using += to append something to an array, you have to make sure
    you’re only trying to add another array. If you were to just write the string
    "whipped cream" without the square brackets around it, you would get an error.
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，["whipped cream"] 虽然只有一个元素，但它仍然是一个数组。当你使用 += 来追加元素到数组时，必须确保你只是在尝试添加另一个数组。如果你只是写下字符串
    "whipped cream" 而没有加上方括号，你将会得到一个错误。
- en: '![Image](Image00125.jpg)'
  id: totrans-343
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00125.jpg)'
- en: '**REMOVING ITEMS FROM AN ARRAY**'
  id: totrans-344
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**从数组中移除项**'
- en: 'There are several methods for removing items from an array. Let’s start by
    looking at the array’s removeLast() method. As you might have guessed from its
    name, removeLast() removes the last item from your array. Let’s try it out with
    a shoppingList array:'
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 有几种方法可以从数组中移除项。让我们从查看数组的 removeLast() 方法开始。如你所猜测的那样，removeLast() 会移除数组中的最后一项。让我们用一个购物清单数组来试试：
- en: '![](Image00126.jpg)'
  id: totrans-346
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00126.jpg)'
- en: Neat! Note that the removeLast() method returns the removed item, so you can
    store it in a new constant or variable if you want.
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 很棒！请注意，removeLast() 方法会返回被移除的项，所以如果你需要，你可以将其存储在一个新的常量或变量中。
- en: 'You can also remove an item from a specific index by using the remove(at:)
    method. Let’s say that your mom doesn’t want you buying any candy and takes that
    off the list:'
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以通过使用 remove(at:) 方法从特定索引移除一项。假设你的妈妈不希望你买糖果并将其从列表中移除：
- en: '![Image](Image00127.jpg)![](Image00128.jpg)'
  id: totrans-349
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00127.jpg)![](Image00128.jpg)'
- en: Just like when we added an item to the middle of our array and all the items
    scooted over to make room, if you remove an item from the middle of an array,
    the rest of the items will scoot back to fill in that empty space. The "apples"
    item that was at index 3 is now at index 2, where "candy" was.
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 就像我们在数组中间添加项时，所有其他项会往旁边移以腾出空间一样，如果你从数组中间移除一项，剩下的项会向后移，填补这个空位。原本位于索引 3 处的“苹果”项，现在位于索引
    2 处，原本那里是“糖果”。
- en: 'You can also remove all items from an array with removeAll() . Try entering
    this into your playground:'
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以通过 removeAll() 移除数组中的所有项。试着在你的游乐场中输入这个：
- en: '![](Image00129.jpg)'
  id: totrans-352
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00129.jpg)'
- en: 'Note that trying to remove an item at an index that doesn’t exist will give
    you an error:'
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，尝试从一个不存在的索引移除项将会导致错误：
- en: '![](Image00130.jpg)'
  id: totrans-354
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00130.jpg)'
- en: Our array doesn’t have this many items (in fact, now it’s empty!), so this throws
    an error. We’ll also get an error if we use removeLast() on our empty array, because
    there’s nothing in it—there’s no last index at all! However, removeAll() is always
    safe to use, even on an empty array.
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的数组没有这么多项（实际上，现在它是空的！），因此会抛出一个错误。如果我们对空数组使用 removeLast()，也会出错，因为它里面什么也没有——根本没有最后一个索引！但是，removeAll()
    在任何情况下都是安全的，甚至对于空数组也是如此。
- en: '**REPLACING ITEMS IN AN ARRAY**'
  id: totrans-356
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**替换数组中的项**'
- en: 'To replace an item in an array, you set the index of the array to the new value,
    as shown here:'
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 要替换数组中的一项，你需要将该索引的数组值设置为新值，如下所示：
- en: '![](Image00131.jpg)'
  id: totrans-358
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00131.jpg)'
- en: At ➊ , we replaced the item at index 2 (the third item) with "Unicorn" because
    magical animals count as favorite animals, too! At ➋ , we replaced the item at
    index 0 (the first item) with "Bearded dragon" . No, that’s not a real dragon—it’s
    just a lizard!
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 在 ➊ 处，我们将索引为 2（第三项）的项替换为“独角兽”，因为神奇的动物也算是最喜欢的动物！在 ➋ 处，我们将索引为 0（第一项）的项替换为“有鬚龙”。不，那可不是一条真正的龙——它只是一种蜥蜴！
- en: Like any time you’re working with array index numbers, you have to be sure an
    item exists in the array at that index before you change its value, or you will
    get an Index out of range error.
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 就像每次处理数组索引时，你必须确保数组中在该索引位置存在一个项，否则你会遇到索引超出范围的错误。
- en: '[Figure 6-3](text00016.html#ch06fig3) shows the error that occurs if you try
    to add "Standard poodle" using favoriteAnimals[3] = "Standard poodle" . To add
    an item to the end of an array, you should use the append(_:) method or += , as
    we covered in “[Adding Items to an Array](text00016.html#ch06lev2sec5) ” on [page
    70](text00016.html#page_70) .'
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 6-3](text00016.html#ch06fig3) 显示了当你尝试使用 favoriteAnimals[3] = "Standard poodle"
    来添加“标准贵宾犬”时发生的错误。要将项添加到数组的末尾，你应该使用 append(_:) 方法或 +=，正如我们在 “[向数组添加项](text00016.html#ch06lev2sec5)”
    中第 [70 页](text00016.html#page_70) 所讲的那样。'
- en: '![Image](Image00132.jpg)'
  id: totrans-362
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00132.jpg)'
- en: '*Figure 6-3: Don’t try to replace a value at an index beyond the existing array.*'
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 6-3：不要尝试替换超出现有数组范围的索引值。*'
- en: Now you know how to change arrays however you might need to. You can add items,
    take items away, or replace items. Next, we’ll look at how to use the properties
    of arrays to find out even more information about them.
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你知道如何根据需要更改数组了。你可以添加项、移除项或替换项。接下来，我们将看看如何利用数组的属性来获取更多关于它们的信息。
- en: '![Image](Image00133.jpg)'
  id: totrans-365
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00133.jpg)'
- en: '**USING ARRAY PROPERTIES**'
  id: totrans-366
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**使用数组属性**'
- en: In addition to methods like append(_:) and removeLast() , arrays also have *properties*
    . An array’s properties are variables or constants that contain some information
    about the array. Two really helpful properties that you might use are the Boolean
    property isEmpty and the integer property count .
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: 除了像append(_)和removeLast()这样的函数外，数组还有*属性*。数组的属性是包含关于数组某些信息的变量或常量。你可能会用到的两个非常有用的属性是布尔值属性isEmpty和整数属性count。
- en: The isEmpty property is true or false depending on whether the array is empty,
    and the count property will tell you how many items are in that array.
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: isEmpty属性根据数组是否为空来返回true或false，而count属性则告诉你数组中有多少项。
- en: 'Check out how these two properties are used in the following if-else statement:'
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: 查看这两个属性在以下if-else语句中的使用方式：
- en: '![Image](Image00134.jpg)'
  id: totrans-370
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00134.jpg)'
- en: 'This if-else statement checks whether the array mySiblings is empty ➊ . If
    it is, then "I don''t have any siblings." is printed. But if there is something
    in the array, then the number of siblings that we have is printed: "I have 3 siblings."
    ➋ .'
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: 这个if-else语句检查数组mySiblings是否为空 ➊。如果为空，则打印"我没有兄弟姐妹。"如果数组中有值，则打印我们有多少个兄弟姐妹："我有3个兄弟姐妹。"
    ➋。
- en: '**LOOPING OVER AN ARRAY**'
  id: totrans-372
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**遍历数组**'
- en: 'Sometimes when you’re working with arrays you might want to do something to
    every item in the array. You can use a for-in loop to do that! The following code
    will print every topping in a pizzaToppings array on a separate line:'
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: 有时在处理数组时，你可能希望对数组中的每个项目执行相同的操作。你可以使用for-in循环来完成这个任务！以下代码会将pizzaToppings数组中的每个配料逐行打印出来：
- en: '![Image](Image00135.jpg)'
  id: totrans-374
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00135.jpg)'
- en: To write a for-in loop for the pizzaToppings array, we used the keyword for
    , followed by the constant topping , then the keyword in , and finally the name
    of our array, pizzaToppings . Then we put the statements that we want to run for
    each topping inside the braces of the for-in loop. The constant topping ➊ temporarily
    represents each pizza topping in the array as we loop through it. We could have
    chosen any name for this constant, but it’s a good idea to pick something that
    makes sense. You can see the output of this for-in loop in [Figure 6-4](text00016.html#ch06fig4)
    .
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: 要编写pizzaToppings数组的for-in循环，我们使用了关键字for，后跟常量topping，再是关键字in，最后是我们的数组名称pizzaToppings。然后我们把想要在每个配料上执行的语句放在for-in循环的大括号内。常量topping
    ➊临时代表我们遍历数组时的每个披萨配料。我们本可以为这个常量选择任何名字，但最好选择一个有意义的名字。你可以在[图6-4](text00016.html#ch06fig4)中看到这个for-in循环的输出。
- en: '![Image](Image00136.jpg)'
  id: totrans-376
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00136.jpg)'
- en: '*Figure 6-4: Output of the example for-in loop*'
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: '*图6-4：示例for-in循环的输出*'
- en: '![Image](Image00137.jpg)'
  id: totrans-378
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00137.jpg)'
- en: 'Using for-in loops is great for printing every value in an array. If you’re
    working with numbers, you can even use them to perform math operations on each
    item, which makes for some speedy calculations! The following code takes an array
    of numbers and calculates the square for each (the square of a number is that
    number multiplied by itself):'
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: 使用for-in循环非常适合打印数组中的每个值。如果你在处理数字，甚至可以用它们对每个项目进行数学运算，这样可以进行快速计算！以下代码将一个数字数组作为输入，并计算每个数字的平方（一个数字的平方是该数字乘以它本身）：
- en: '![Image](Image00138.jpg)'
  id: totrans-380
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00138.jpg)'
- en: '[Figure 6-5](text00016.html#ch06fig5) shows the results.'
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: '[图6-5](text00016.html#ch06fig5)展示了结果。'
- en: '![Image](Image00139.jpg)'
  id: totrans-382
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00139.jpg)'
- en: '*Figure 6-5: Printing the squares for each number in the myNumbers array*'
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: '*图6-5：打印myNumbers数组中每个数字的平方*'
- en: '**DICTIONARIES ARE KEY!**'
  id: totrans-384
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**字典是关键！**'
- en: A *dictionary* is also a collection of values, but instead of an ordered index,
    each value has its own *key* . Because there’s no index, the values are not stored
    in any particular order. To access values in a dictionary, you look them up by
    their key.
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: '*字典*也是一个值的集合，但不同于有序索引，每个值都有自己的*键*。因为没有索引，值的存储顺序是无特定顺序的。要访问字典中的值，你需要通过键来查找它们。'
- en: A key must be unique. You can’t have the same key more than once in the same
    dictionary. If there were two identical keys and you asked the computer to give
    you the value for one of them, the computer wouldn’t know which one to choose!
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: 键必须是唯一的。你不能在同一个字典中使用相同的键两次。如果有两个相同的键，而你要求计算机返回其中一个键的值，计算机就无法知道选择哪个！
- en: Let’s take a look at how to make a dictionary and write keys that will help
    you find all the information you need.
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如何创建一个字典，并编写键来帮助你找到所有需要的信息。
- en: '![Image](Image00140.jpg)'
  id: totrans-388
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00140.jpg)'
- en: '**INITIALIZING A DICTIONARY**'
  id: totrans-389
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**初始化字典**'
- en: 'To create and initialize a dictionary, first write var and the name of your
    dictionary. Then write the keys and corresponding values inside a pair of square
    brackets, similar to an array. Let’s create a dictionary to store the names of
    a few US states. The key for each state will be its two-letter abbreviation:'
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建并初始化一个字典，首先写var和字典的名称。然后将键和相应的值写在一对方括号中，类似于数组。让我们创建一个字典来存储一些美国州的名称。每个州的键将是其两位字母的缩写：
- en: '![](Image00141.jpg)'
  id: totrans-391
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00141.jpg)'
- en: As you can see, there’s a colon between each key and its value, and the key/value
    pairs are separated by commas.
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，每个键与其值之间都有一个冒号，键值对之间用逗号分隔。
- en: Dictionaries are different from arrays in that they are *unordered* . Because
    of that, it’s likely that the order of the states that you see in your results
    pane ➋ is different from the order in which you entered your states ➊ . It might
    even be different than the order that’s printed in this book!
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: 字典与数组不同，字典是*无序的*。因此，你在结果面板中看到的状态顺序➋可能与输入的状态顺序➊不同，甚至可能与本书中打印的顺序不同！
- en: As with arrays, you can use var to make a mutable dictionary or use let to make
    an immutable dictionary.
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: 与数组一样，你可以使用var来创建一个可变字典，或者使用let来创建一个不可变字典。
- en: 'In Swift, all of the keys of a dictionary must be the same type, and all of
    the values of a dictionary must also be the same type, but the key type doesn’t
    have to match the value type. For example, if you wanted to store a collection
    of fractions, you could use doubles for the keys and strings for the values:'
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: 在Swift中，字典的所有键必须是相同类型的，字典的所有值也必须是相同类型的，但键的类型不需要与值的类型相同。例如，如果你想存储一组分数，你可以使用双精度类型作为键，字符串作为值：
- en: '![](Image00142.jpg)'
  id: totrans-396
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00142.jpg)'
- en: In this dictionary, all of the keys must be doubles, and all of the values must
    be strings. Again, you’ll see that the order of the numbers in the results pane
    can be quite different from the order in which you wrote the fractions in your
    dictionary. This is fine because you don’t need to know the order to access anything.
    You can find any item that you need by its key. Let’s see how!
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个字典中，所有的键必须是双精度类型（doubles），所有的值必须是字符串类型（strings）。再次提醒，你会发现结果面板中数字的顺序可能与字典中你输入的分数顺序完全不同。这是可以接受的，因为你不需要知道顺序就可以访问任何内容。你可以通过键来找到你需要的任何项目。让我们来看一下如何操作！
- en: '**ACCESSING VALUES IN A DICTIONARY**'
  id: totrans-398
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**在字典中访问值**'
- en: 'Looking up a value in a dictionary is similar to how you access a value in
    an array except that you use a key inside the square brackets instead of an index,
    like this: usStates["TX"] .'
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
  zh: 在字典中查找一个值类似于在数组中访问一个值，不同之处在于你在方括号内使用的是键而不是索引，像这样：usStates["TX"]。
- en: There is a big difference, however, in how Swift returns the values from a dictionary.
    When you access a value at an index of an array, you are simply given the value.
    When you access a value with a key in a dictionary, you are given an optional.
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，Swift在从字典中返回值时有一个很大的不同。当你访问数组中的一个索引时，你只会得到值。当你使用字典中的键访问一个值时，你会得到一个可选值。
- en: In [Chapter 5](text00015.html#ch05) , you learned that optionals might contain
    a value or might be nil . The reason Swift returns optionals when you’re looking
    up items in a dictionary is that the key you used might not exist in the dictionary,
    in which case there’s no value to access. Trying to access a value that doesn’t
    exist would give you a big fat error! To avoid that problem, Swift returns optionals.
    That means you need to unwrap any value you get out of a dictionary before you
    can do anything with it.
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第5章](text00015.html#ch05)中，你已经学过可选类型（optionals）可能包含一个值，也可能是nil。当你在字典中查找项目时，Swift返回可选类型的原因是你使用的键可能在字典中不存在，这种情况下是没有值可访问的。尝试访问不存在的值会导致一个严重错误！为了避免这个问题，Swift返回的是可选类型。这意味着你需要在使用字典中的任何值之前解包它。
- en: 'To unwrap an optional, first you check whether it exists using an if-let statement,
    just like we did in [Chapter 5](text00015.html#ch05) . The following code shows
    you how to get a value out of a dictionary:'
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
  zh: 要解包一个可选值，首先你需要使用if-let语句检查它是否存在，就像我们在[第5章](text00015.html#ch05)中做的那样。以下代码演示了如何从字典中获取一个值：
- en: '![Image](Image00143.jpg)'
  id: totrans-403
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00143.jpg)'
- en: To retrieve "Texas" from the dictionary, we use if let to set a constant loneStarState
    to usStates["TX"] ➊ . Because we have this state in our dictionary, the line I
    have Texas in my dictionary. is printed. Next we try to access a state that is
    not in our dictionary by using the key usStates["FL"] ➋ . Thankfully, because
    we used an if-let statement, the program won’t crash when the computer can’t find
    this state. Instead, I don't have that state in my dictionary. is printed.
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
  zh: 为了从字典中获取“Texas”，我们使用if let将常量loneStarState设置为usStates["TX"]➊。因为我们在字典中有这个州，打印了"I
    have Texas in my dictionary."。接下来，我们尝试通过使用键usStates["FL"]➋来访问字典中没有的州。幸运的是，由于我们使用了if-let语句，当计算机找不到这个州时，程序不会崩溃。相反，打印了"I
    don't have that state in my dictionary."。
- en: '**ADDING ITEMS TO A DICTIONARY**'
  id: totrans-405
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**向字典添加项目**'
- en: 'To add an item to a dictionary, first write the name of your dictionary and
    assign the new item to the key you want it to have in the dictionary. Let’s add
    "Minnesota" to our usStates dictionary:'
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
  zh: 要向字典中添加项目，首先写下字典的名称，并将新项目分配给你希望它在字典中拥有的键。让我们将“Minnesota”添加到我们的usStates字典中：
- en: '![](Image00144.jpg)'
  id: totrans-407
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00144.jpg)'
- en: 'Now when you look at usStates , you’ll see that it’s updated to ["MN": "Minnesota",
    "WA": "Washington", "MA": "Massachusetts", "TX": "Texas"] . Remember, because
    you don’t have to rely on indices, your new dictionary item might appear anywhere
    in the dictionary.'
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
  zh: '现在，当你查看usStates时，你会看到它已更新为["MN": "Minnesota", "WA": "Washington", "MA": "Massachusetts",
    "TX": "Texas"]。记住，由于你不需要依赖索引，新的字典项可能出现在字典的任何位置。'
- en: '**REMOVING ITEMS FROM A DICTIONARY**'
  id: totrans-409
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**从字典中删除项目**'
- en: Removing an item from a dictionary is quite simple; you do so by setting the
    value to nil . Because the values in dictionaries are returned as optionals, you
    don’t have to worry about nil causing any problems in your dictionary.
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
  zh: 从字典中删除项目相当简单；你只需将值设置为nil。因为字典中的值是以可选类型返回的，所以你不需要担心nil会在字典中引发任何问题。
- en: '![](Image00145.jpg)'
  id: totrans-411
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00145.jpg)'
- en: 'You can see that after you remove the value at the key "MA" , usStates is updated
    to ["MN": "Minnesota", "WA": "Washington", "TX": "Texas"] . Remember that nil
    is special and means that there’s no value at all. That’s why you don’t see "MA":
    nil in our dictionary.'
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
  zh: '你可以看到，在你删除键“MA”对应的值后，usStates已更新为["MN": "Minnesota", "WA": "Washington", "TX":
    "Texas"]。记住，nil是特殊的，表示没有任何值。这就是为什么你在字典中没有看到"MA": nil。'
- en: '**REPLACING ITEMS IN A DICTIONARY**'
  id: totrans-413
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**替换字典中的项目**'
- en: 'Replacing an item in a dictionary is also easy. It works the same was as replacing
    an item in an array. You just set the item that you want to replace to something
    else. Say you create a dictionary of fruit colors:'
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
  zh: 替换字典中的项目也很简单。它的工作方式与替换数组中的项目相同。你只需要将要替换的项目设置为其他内容。假设你创建了一个水果颜色的字典：
- en: '![](Image00146.jpg)'
  id: totrans-415
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00146.jpg)'
- en: At first we had the value "apple" for "red" , but then we decided that "raspberry"
    is a better fruit to use since sometimes apples are green or yellow. To replace
    "apple" with "raspberry" , we set colorFruits["red"] to its new value ➊ .
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
  zh: 最初我们为“red”设置了值“apple”，但后来我们决定使用“raspberry”作为更好的水果，因为有时苹果是绿色或黄色的。为了将“apple”替换为“raspberry”，我们将colorFruits["red"]设置为它的新值➊。
- en: You may remember that this is the same way we entered a new value into a dictionary.
    If the key already exists in the dictionary, then the value for that key is replaced.
    If the key doesn’t already exist, then the new key/value pair will be added to
    the dictionary.
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能记得，这是我们将新值输入字典的相同方式。如果键已经存在于字典中，那么该键的值会被替换。如果键不存在，那么新的键/值对将会被添加到字典中。
- en: '![Image](Image00147.jpg)'
  id: totrans-418
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00147.jpg)'
- en: '**USING DICTIONARY PROPERTIES**'
  id: totrans-419
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**使用字典属性**'
- en: 'Like an array, a dictionary also has an isEmpty property and a count property.
    For example, the following code shows how you can use the isEmpty property to
    check if a dictionary is empty, and if it isn’t empty, the count property checks
    how many items you have. Imagine you have a basket of fruit for sale. You can
    use these properties to help you keep track of everything:'
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
  zh: 像数组一样，字典也有isEmpty属性和count属性。例如，以下代码展示了如何使用isEmpty属性来检查字典是否为空，如果不为空，则使用count属性检查你有多少个项。假设你有一个出售水果的篮子。你可以使用这些属性来帮助你跟踪一切：
- en: '![Image](Image00148.jpg)'
  id: totrans-421
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00148.jpg)'
- en: 'A dictionary also has two special properties: keys , which contains all of
    the dictionary’s keys, and values , which contains all of its values. We’ll use
    these two properties when we loop through the dictionary.'
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
  zh: 字典还有两个特殊属性：keys，它包含字典的所有键，和values，它包含字典的所有值。在我们遍历字典时，会使用这两个属性。
- en: Let’s write some code that loops through our fruit baskets and prints the price
    of each fruit.
  id: totrans-423
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们写一些代码，循环遍历我们的水果篮，并打印每种水果的价格。
- en: '**LOOPING OVER A DICTIONARY**'
  id: totrans-424
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**循环遍历字典**'
- en: 'You can loop through a dictionary using a for-in loop. Because each item has
    a key and a value, you can do this in two different ways. This is how to loop
    through a dictionary using its keys:'
  id: totrans-425
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用 for-in 循环遍历字典。由于每个项都有一个键和值，因此你可以通过两种不同的方式进行遍历。这是使用字典的键来循环遍历的方式：
- en: '![Image](Image00149.jpg)'
  id: totrans-426
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00149.jpg)'
- en: Here we use the dictionary’s keys property ➊ to loop through fruitBasket and
    print its contents. We start by writing the keyword for , followed by a constant
    name fruit for the dictionary key, the keyword in , the dictionary name, a period,
    and keys .
  id: totrans-427
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们使用字典的 keys 属性 ➊ 来循环遍历 fruitBasket 并打印其内容。我们从写下关键字 for 开始，后跟字典键的常量名称 fruit，关键字
    in，字典名称，一个句点，和 keys。
- en: Inside the braces of our for-in loop, we have access to both the key, which
    we call fruit ➋ , and the value at that key when we force-unwrap its contents
    with fruitBasket[fruit]! ➌ . That value will be the fruit’s price.
  id: totrans-428
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的 for-in 循环的花括号内，我们可以访问键（我们称之为 fruit ➋），以及通过 fruitBasket[fruit]! ➌ 强制解包其内容时该键的值。该值将是水果的价格。
- en: In this case, it’s safe to force-unwrap the value using an exclamation point
    because we know that the fruit key we’re using is definitely inside the dictionary.
  id: totrans-429
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，使用感叹号强制解包值是安全的，因为我们知道我们使用的 fruit 键一定在字典中。
- en: Any code we put inside the for-in loop will run once for every key in our dictionary.
    So you should see the print statement display three times.
  id: totrans-430
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在 for-in 循环中放入的任何代码都会针对字典中的每个键运行一次。所以你应该看到打印语句显示三次。
- en: 'We can also loop through the dictionary using its values property:'
  id: totrans-431
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以通过字典的 values 属性来循环遍历：
- en: '![Image](Image00150.jpg)'
  id: totrans-432
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00150.jpg)'
- en: We use the same style of for-in loop, but now we use a constant to refer to
    each value, which we call price , in the values property. When looping through
    values, we don’t have access to the keys from inside the loop.
  id: totrans-433
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用相同样式的 for-in 循环，但现在我们使用常量来引用每个值，我们称之为 price，位于 values 属性中。在循环值时，我们无法从循环内部访问键。
- en: Another difference to note is that price is not an optional because it’s accessed
    directly as a value in the fruitBasket dictionary. That means we don’t have to
    unwrap it. You should still see the print statement printed three times. [Figure
    6-6](text00016.html#ch06fig6) shows the output of both loops.
  id: totrans-434
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个需要注意的区别是，价格不是一个可选项，因为它直接作为值存储在 fruitBasket 字典中。这意味着我们不需要解包它。你应该仍然能看到打印语句被打印三次。[图
    6-6](text00016.html#ch06fig6) 显示了两个循环的输出。
- en: '![Image](Image00151.jpg)'
  id: totrans-435
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00151.jpg)'
- en: '*Figure 6-6: Looping through the keys and values of a dictionary with a for-in
    loop*'
  id: totrans-436
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 6-6：使用 for-in 循环遍历字典的键和值*'
- en: The order of your results might be slightly different from ours. That’s because
    the items in a dictionary aren’t in a numbered order like they are in an array!
    And because the order is not guaranteed, you might see a different order printed
    if you run the same code again.
  id: totrans-437
  prefs: []
  type: TYPE_NORMAL
  zh: 你的结果顺序可能与我们的略有不同。这是因为字典中的项目不像数组那样按编号顺序排列！并且由于顺序不保证，如果你再次运行相同的代码，可能会看到不同的顺序。
- en: '**WHAT YOU LEARNED**'
  id: totrans-438
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**你学到的内容**'
- en: In this chapter, you learned how to store collections of items in an array and
    in a dictionary. To store items in an ordered list, you would use an array and
    look up each item by its index. If you wanted to store items by key instead, you
    would use a dictionary.
  id: totrans-439
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你学习了如何将项目存储在数组和字典中。要将项目存储在有序列表中，你可以使用数组，并通过索引查找每个项目。如果你想按键存储项目，则可以使用字典。
- en: Knowing about arrays and dictionaries and how to use them is a powerful building
    block for almost any programming language. Next we will learn about functions,
    another very powerful tool. Functions are blocks of code that you create and name
    to perform a specific job. After you have written a function, you can use its
    name to call it from almost anywhere in your program.
  id: totrans-440
  prefs: []
  type: TYPE_NORMAL
  zh: 了解数组和字典以及如何使用它们是几乎所有编程语言中的强大构建块。接下来我们将学习函数，另一个非常强大的工具。函数是你创建并命名的代码块，用来执行特定的任务。在你编写了一个函数后，你可以通过它的名称在程序中的几乎任何地方调用它。
- en: In previous chapters, you learned that you can store a single piece of information
    in a variable or constant. But what if you want to store a collection of things,
    like the names of all the places you’ve visited or all the books that you’ve read?
    In this chapter, we’ll introduce you to arrays and dictionaries. They’re both
    used to store collections of values. Using arrays and dictionaries, you can work
    with a lot of data at once and make your programs more powerful!
  id: totrans-441
  prefs: []
  type: TYPE_NORMAL
  zh: 在之前的章节中，你学习了如何在变量或常量中存储单个信息。但是如果你想存储一个集合的内容，比如你访问过的所有地方的名称或你读过的所有书籍呢？在本章中，我们将介绍数组和字典。它们都是用来存储值的集合。通过使用数组和字典，你可以一次性处理大量数据，让你的程序更强大！
- en: '**KEEPING THINGS IN ORDER WITH ARRAYS**'
  id: totrans-442
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**使用数组保持顺序**'
- en: An *array* is a list of items of the same data type stored in order, kind of
    like a numbered grocery list. Items in an array are stored by their *index* ,
    a number based on where the item is positioned in the array.
  id: totrans-443
  prefs: []
  type: TYPE_NORMAL
  zh: '*数组*是按顺序存储的相同数据类型的项列表，有点像编号的购物清单。数组中的项目是通过它们的*索引*存储的，索引是根据项目在数组中的位置计算的数字。'
- en: When you write a grocery list, you usually start with the number 1, but in computer
    programming, an index starts at 0, not 1\. So the first item in an array is always
    at index 0, the second item is at index 1, the third item is at index 2, and so
    on.
  id: totrans-444
  prefs: []
  type: TYPE_NORMAL
  zh: 当你写购物清单时，通常从数字 1 开始，但在计算机编程中，索引是从 0 开始的，而不是从 1 开始。所以数组中的第一个项目始终位于索引 0，第二个项目位于索引
    1，第三个项目位于索引 2，以此类推。
- en: 'Let’s create an array. If you already know what you’re going to put into your
    array, you can create it and *initialize* it with those values. To initialize
    something in Swift is to give it some initial value so you can use it in your
    program. Let’s say that you want to store a list of all of the national parks
    that you’ve visited. Enter the following into your playground:'
  id: totrans-445
  prefs: []
  type: TYPE_NORMAL
  zh: 我们来创建一个数组。如果你已经知道要放入数组中的内容，可以直接创建数组并用这些值进行*初始化*。在 Swift 中，初始化某个对象就是为它赋予一个初始值，这样你才能在程序中使用它。假设你想存储你访问过的所有国家公园的列表。请在你的
    Playground 中输入以下内容：
- en: '![](Image00114.jpg)'
  id: totrans-446
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00114.jpg)'
- en: This code creates an array variable called nationalParks and initializes it
    with the names of three national parks. Because we initialized this array to hold
    strings, you’ll only be able to put strings in it.
  id: totrans-447
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码创建了一个名为 nationalParks 的数组变量，并用三个国家公园的名称进行了初始化。因为我们初始化这个数组来存储字符串，所以你只能将字符串放入其中。
- en: '[Figure 6-1](text00016.html#ch06fig1) shows how you can imagine your array.
    It’s like a row of boxes containing the three names of national parks at indices
    0, 1, and 2\. Remember that the indices of an array always start at 0!'
  id: totrans-448
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 6-1](text00016.html#ch06fig1)展示了你可以如何想象你的数组。它就像一排盒子，里面存放着位于索引 0、1 和 2 处的三个国家公园名称。记住，数组的索引总是从
    0 开始！'
- en: '![Image](Image00115.jpg)'
  id: totrans-449
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00115.jpg)'
- en: '*Figure 6-1: The nationalParks array*'
  id: totrans-450
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 6-1：nationalParks 数组*'
- en: '**USING MUTABLE AND IMMUTABLE ARRAYS**'
  id: totrans-451
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**使用可变和不可变数组**'
- en: Our nationalParks array is a variable because we created it with the var keyword
    ➊ . An array stored in a variable is called a *mutable* array. This means that
    you can change it by adding items, removing items, or swapping items in and out.
  id: totrans-452
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的 nationalParks 数组是一个变量，因为我们使用了 var 关键字创建它 ➊。存储在变量中的数组被称为*可变*数组。这意味着你可以通过添加、删除或替换元素来修改它。
- en: You can also create an *immutable* array. An immutable array is created with
    the keyword let instead of var . Similar to a constant, once an immutable array
    is created, nothing in it can be changed.
  id: totrans-453
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以创建一个*不可变*数组。不可变数组是使用 let 关键字创建的，而不是 var。类似于常量，一旦创建了不可变数组，数组中的任何内容都无法更改。
- en: So when should you use a mutable array or an immutable array? It’s best to use
    let if you know your collection will never change, like if you’re storing the
    colors of the rainbow. You should use var if you need to change your collection,
    like if you’re storing an array of your favorite T-shirts, which might change
    depending on what’s in style!
  id: totrans-454
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，什么时候应该使用可变数组或不可变数组呢？如果你知道你的集合永远不会改变，比如你存储的是彩虹的颜色，那么最好使用 let。如果你需要更改集合中的内容，比如你存储的是你最喜欢的
    T 恤的数组，它可能会随着流行趋势的变化而改变，那么你应该使用 var。
- en: '![Image](Image00116.jpg)'
  id: totrans-455
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00116.jpg)'
- en: '**USING TYPE INFERENCE**'
  id: totrans-456
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**使用类型推断**'
- en: 'When we created our nationalParks array, we specified that we were creating
    an array of string values by adding a colon (: ) and [String] ➋ . This step is
    optional when you create an array and initialize it with one or more values because
    Swift will use type inference to determine the kind of data you want the array
    to hold. That means that you could just as easily have created the array by doing
    this:'
  id: totrans-457
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们创建 `nationalParks` 数组时，我们通过添加冒号(:)和[String] ➋ 指定了我们正在创建一个字符串类型的数组。在创建并初始化数组时，这一步是可选的，因为
    Swift 会使用类型推断来确定数组要存储的数据类型。这意味着你完全可以通过以下方式创建数组：
- en: '![](Image00117.jpg)'
  id: totrans-458
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00117.jpg)'
- en: Using type inference, Swift knows we initialized this array to hold strings,
    and it can hold only strings.
  id: totrans-459
  prefs: []
  type: TYPE_NORMAL
  zh: 通过类型推断，Swift 知道我们初始化这个数组时，它将保存字符串，并且它只能保存字符串。
- en: The list of parks that we created the array with is an example of an array *literal*
    . A literal is a value that is exactly what you see. It is not a variable or constant
    but rather just the value without a name. "Grand Canyon" is an example of a string
    literal, and 7 is an example of an integer literal. An array literal is a list
    of items contained between two square brackets and separated by commas, like ["Acadia",
    "Zion", "Grand Canyon"] ➊ .
  id: totrans-460
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建数组时使用的公园列表是数组*字面量*的一个例子。字面量是一个值，完全就是你所看到的。它不是变量或常量，而只是一个没有名称的值。"Grand Canyon"
    就是一个字符串字面量，7 是一个整数字面量。数组字面量是包含在两个方括号之间，并由逗号分隔的项目列表，比如 ["Acadia", "Zion", "Grand
    Canyon"] ➊。
- en: '**ACCESSING ITEMS IN AN ARRAY**'
  id: totrans-461
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**访问数组中的项目**'
- en: 'Let’s say you want to access an item in your array and use it in your program.
    Your friend asks you to tell them all about your travels, so you want to use the
    names of the national parks that you stored in the array. To access an item in
    your array, write the array name followed by the item’s index inside square brackets:'
  id: totrans-462
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你想要访问数组中的一个项目并在程序中使用它。你的朋友问你有关旅行的所有事情，所以你想使用你在数组中存储的国家公园名称。要访问数组中的一个项目，可以写数组名称，后跟项目的索引，索引放在方括号内：
- en: '![](Image00118.jpg)'
  id: totrans-463
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00118.jpg)'
- en: In this example, we are accessing the names of the national parks and then printing
    them to the screen using print . To get the first item in nationalParks , you
    use nationalParks[0] ➊ . To access the second item in nationalParks , you use
    nationalParks[1] .
  id: totrans-464
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们正在访问国家公园的名称，然后使用 `print` 打印到屏幕上。要获取 `nationalParks` 中的第一个项目，你可以使用 `nationalParks[0]`
    ➊。要访问 `nationalParks` 中的第二个项目，你可以使用 `nationalParks[1]`。
- en: '**WATCHING THE RANGE**'
  id: totrans-465
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**监视范围**'
- en: One important point about arrays is that if you try to access an item at an
    index that’s higher than the last index in the array, you’ll get an error. In
    [Figure 6-2](text00016.html#ch06fig2) , you can see that nationalParks[3] (which
    would be the fourth item in the array) gives you an error because there are only
    three national parks in the array, indexed from 0 to 2.
  id: totrans-466
  prefs: []
  type: TYPE_NORMAL
  zh: 关于数组有一个重要的注意点：如果你尝试访问数组中一个超出最后索引的项目，你会得到一个错误。在[图 6-2](text00016.html#ch06fig2)中，你可以看到
    `nationalParks[3]`（即数组中的第四个项目）会给你一个错误，因为数组中只有三个国家公园，索引范围是从 0 到 2。
- en: As you can see, you get an error message that says Index out of range . If you
    try to access an item that doesn’t exist in your array, your app will crash!
  id: totrans-467
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，你会收到一个错误消息，显示 "Index out of range"。如果你尝试访问数组中不存在的项目，应用程序就会崩溃！
- en: '![Image](Image00119.jpg)'
  id: totrans-468
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Image00119.jpg)'
- en: '*Figure 6-2: Trying to access an index in the array where nothing exists causes
    an error.*'
  id: totrans-469
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 6-2：尝试访问数组中不存在的索引会导致错误。*'
- en: '**ADDING ITEMS TO AN ARRAY**'
  id: totrans-470
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**向数组添加项目**'
- en: One way to change an array is to add new items to it. There are a few different
    ways to do this, so let’s take a look at each.
  id: totrans-471
  prefs: []
  type: TYPE_NORMAL
  zh: 改变数组的一种方式是向其中添加新项。实现这一点有几种不同的方法，我们来逐一看看。
- en: 'First, you can use an array’s append(_:) method. *Append* means to add something.
    Using append(_:) , you can add one new item to the end of your array. Say you
    go on another trip and visit the Badlands, and you want to add it to your list
    of national parks. To do that, add this code into your playground:'
  id: totrans-472
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，你可以使用数组的 `append(_:)` 方法。*Append* 意味着添加。使用 `append(_:)`，你可以将一个新项目添加到数组的末尾。假设你又去了一次旅行，参观了
    Badlands，并且想要将其添加到国家公园列表中。为此，你可以将以下代码添加到你的 Playground 中：
- en: '![](Image00120.jpg)'
  id: totrans-473
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00120.jpg)'
- en: To use the append(_:) method, first write the name of your array followed by
    a period and then append . Then, put the item you want to add to your array inside
    the parentheses. In this case, you put "Badlands" inside the parentheses.
  id: totrans-474
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `append(_:)` 方法时，首先写出数组名称，后面加一个句点，再加上 `append`。然后，将你想添加到数组中的项目放在括号内。在这个例子中，你将
    "Badlands" 放在括号内。
- en: 'If you want to add something at a specific place in your array, use the array’s
    insert(_:at:) method instead. This method takes two arguments: the item that you
    want to insert and the index of where it should go in the array. (We’ll discuss
    arguments in more detail in [Chapter 7](text00017.html#ch07) .)'
  id: totrans-475
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想在数组的特定位置添加元素，可以使用数组的 insert(_:at:) 方法。这个方法有两个参数：你想插入的项目和该项目在数组中的索引位置。（我们将在[第
    7 章](text00017.html#ch07)详细讨论参数。）
- en: 'Let’s say you totally forgot that you went to the Petrified Forest right after
    you visited the Grand Canyon, and you want to update your nationalParks array
    so it displays the parks in the order in which you visited them. To update your
    array, you could use the insert(_:at:) method to put the Petrified Forest in the
    right position:'
  id: totrans-476
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你完全忘记了自己在参观大峡谷之后去了化石森林，现在你想更新 nationalParks 数组，使它按你访问的顺序显示公园。要更新数组，你可以使用 insert(_:at:)
    方法将化石森林插入到正确的位置：
- en: '![](Image00121.jpg)'
  id: totrans-477
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00121.jpg)'
- en: When you insert a new item at index 3, everything that was in the array at index
    3 or higher gets scooted over to make room for the new item. That means the item
    that was at index 3 is now at index 4, the item that was at index 4 is now at
    index 5, and so on. After you add the Petrified Forest, nationalParks is now ["Acadia",
    "Zion", "Grand Canyon", "Petrified Forest", "Badlands"] .
  id: totrans-478
  prefs: []
  type: TYPE_NORMAL
  zh: 当你在索引 3 处插入新项目时，所有在索引 3 或更高位置的项目都会向后移动，为新项目腾出空间。这意味着原本在索引 3 的项目现在会被移到索引 4，索引
    4 的项目会被移到索引 5，依此类推。添加化石森林后，nationalParks 数组变成了 ["Acadia", "Zion", "Grand Canyon",
    "Petrified Forest", "Badlands"]。
- en: '**COMBINING ARRAYS**'
  id: totrans-479
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**合并数组**'
- en: 'Not only can you add new items to an array, but you can also add two arrays
    together using the + and += operators. Let’s say that you have the ingredients
    for a fruit smoothie in two arrays:'
  id: totrans-480
  prefs: []
  type: TYPE_NORMAL
  zh: 你不仅可以向数组中添加新项目，还可以使用 + 和 += 运算符将两个数组合并。假设你有两个数组，分别包含制作水果冰沙的原料：
- en: '![](Image00122.jpg)'
  id: totrans-481
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00122.jpg)'
- en: Now you can make a delicious smoothie by adding the fruits and liquids arrays.
  id: totrans-482
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你可以通过将水果和液体数组合并，制作出一杯美味的冰沙。
- en: '![](Image00123.jpg)'
  id: totrans-483
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00123.jpg)'
- en: The order of the ingredients in smoothie is the same as the order in fruits
    and liquids . If you created smoothie with liquids + fruits , then the liquids
    would come first.
  id: totrans-484
  prefs: []
  type: TYPE_NORMAL
  zh: 冰沙中的原料顺序与水果和液体中的顺序相同。如果你用液体 + 水果的顺序创建冰沙，那么液体会排在前面。
- en: 'You use the += operator to add an array to the end of your array. Add some
    whipped cream as follows for extra yumminess:'
  id: totrans-485
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用 += 运算符将一个数组添加到另一个数组的末尾。下面就是添加一些鲜奶油来提升美味感的方式：
- en: '![](Image00124.jpg)'
  id: totrans-486
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00124.jpg)'
- en: Note that ["whipped cream"] is an array even though it has a single item in
    it. When you’re using += to append something to an array, you have to make sure
    you’re only trying to add another array. If you were to just write the string
    "whipped cream" without the square brackets around it, you would get an error.
  id: totrans-487
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，["whipped cream"] 是一个数组，尽管它只有一个项目。当你使用 += 向数组添加元素时，必须确保你只是在添加另一个数组。如果你直接写字符串
    "whipped cream" 而没有方括号，就会报错。
- en: '![Image](Image00125.jpg)'
  id: totrans-488
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00125.jpg)'
- en: '**REMOVING ITEMS FROM AN ARRAY**'
  id: totrans-489
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**从数组中移除项目**'
- en: 'There are several methods for removing items from an array. Let’s start by
    looking at the array’s removeLast() method. As you might have guessed from its
    name, removeLast() removes the last item from your array. Let’s try it out with
    a shoppingList array:'
  id: totrans-490
  prefs: []
  type: TYPE_NORMAL
  zh: 有几种方法可以从数组中移除项目。让我们从数组的 removeLast() 方法开始。顾名思义，removeLast() 会移除数组中的最后一个项目。我们可以用一个购物清单数组来试一试：
- en: '![](Image00126.jpg)'
  id: totrans-491
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00126.jpg)'
- en: Neat! Note that the removeLast() method returns the removed item, so you can
    store it in a new constant or variable if you want.
  id: totrans-492
  prefs: []
  type: TYPE_NORMAL
  zh: 真棒！请注意，removeLast() 方法会返回被移除的项目，因此，如果你愿意，可以将它存储在一个新的常量或变量中。
- en: 'You can also remove an item from a specific index by using the remove(at:)
    method. Let’s say that your mom doesn’t want you buying any candy and takes that
    off the list:'
  id: totrans-493
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以使用 remove(at:) 方法从特定的索引位置移除一个项目。假设你妈妈不希望你买糖果，并将它从列表中删除：
- en: '![Image](Image00127.jpg)![](Image00128.jpg)'
  id: totrans-494
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00127.jpg)![](Image00128.jpg)'
- en: Just like when we added an item to the middle of our array and all the items
    scooted over to make room, if you remove an item from the middle of an array,
    the rest of the items will scoot back to fill in that empty space. The "apples"
    item that was at index 3 is now at index 2, where "candy" was.
  id: totrans-495
  prefs: []
  type: TYPE_NORMAL
  zh: 就像我们在数组中间添加一个项目时，所有项目都向后移动一样，如果你从数组中间移除一个项目，剩下的项目会向前移动填补那个空位。原本在索引 3 的 "apples"
    项目现在会出现在索引 2 的位置，原本在索引 2 的 "candy" 项目会移到索引 3。
- en: 'You can also remove all items from an array with removeAll() . Try entering
    this into your playground:'
  id: totrans-496
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以使用 removeAll() 从数组中移除所有项。尝试将以下代码输入到你的 playground 中：
- en: '![](Image00129.jpg)'
  id: totrans-497
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00129.jpg)'
- en: 'Note that trying to remove an item at an index that doesn’t exist will give
    you an error:'
  id: totrans-498
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，尝试删除一个不存在索引的项会导致错误：
- en: '![](Image00130.jpg)'
  id: totrans-499
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00130.jpg)'
- en: Our array doesn’t have this many items (in fact, now it’s empty!), so this throws
    an error. We’ll also get an error if we use removeLast() on our empty array, because
    there’s nothing in it—there’s no last index at all! However, removeAll() is always
    safe to use, even on an empty array.
  id: totrans-500
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的数组没有这么多项（事实上，现在它是空的！），所以会抛出一个错误。如果我们在空数组上使用 removeLast()，也会报错，因为数组中没有任何元素——根本没有最后一个索引！然而，removeAll()
    始终是安全的，即使在空数组上使用。
- en: '**REPLACING ITEMS IN AN ARRAY**'
  id: totrans-501
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**替换数组中的项**'
- en: 'To replace an item in an array, you set the index of the array to the new value,
    as shown here:'
  id: totrans-502
  prefs: []
  type: TYPE_NORMAL
  zh: 要替换数组中的一项，你只需将该数组的索引设置为新值，如下所示：
- en: '![](Image00131.jpg)'
  id: totrans-503
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00131.jpg)'
- en: At ➊ , we replaced the item at index 2 (the third item) with "Unicorn" because
    magical animals count as favorite animals, too! At ➋ , we replaced the item at
    index 0 (the first item) with "Bearded dragon" . No, that’s not a real dragon—it’s
    just a lizard!
  id: totrans-504
  prefs: []
  type: TYPE_NORMAL
  zh: 在 ➊ 处，我们将索引为 2（第三项）的项替换为 "独角兽"，因为魔法动物也算是最喜欢的动物！在 ➋ 处，我们将索引为 0（第一项）的项替换为 "胡须龙"。不，这不是一条真正的龙——它只是一只蜥蜴！
- en: Like any time you’re working with array index numbers, you have to be sure an
    item exists in the array at that index before you change its value, or you will
    get an Index out of range error.
  id: totrans-505
  prefs: []
  type: TYPE_NORMAL
  zh: 就像你在处理数组索引时一样，你必须确保数组在该索引位置有项存在，然后再改变它的值，否则会出现索引超出范围的错误。
- en: '[Figure 6-3](text00016.html#ch06fig3) shows the error that occurs if you try
    to add "Standard poodle" using favoriteAnimals[3] = "Standard poodle" . To add
    an item to the end of an array, you should use the append(_:) method or += , as
    we covered in “[Adding Items to an Array](text00016.html#ch06lev2sec5) ” on [page
    70](text00016.html#page_70) .'
  id: totrans-506
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 6-3](text00016.html#ch06fig3) 显示了如果你尝试使用 favoriteAnimals[3] = "Standard
    poodle" 添加 "标准贵宾犬" 时发生的错误。要将项添加到数组末尾，应该使用 append(_:) 方法或 += ，正如我们在 “[向数组添加项](text00016.html#ch06lev2sec5)”
    中在 [第70页](text00016.html#page_70) 所讲解的。'
- en: '![Image](Image00132.jpg)'
  id: totrans-507
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00132.jpg)'
- en: '*Figure 6-3: Don’t try to replace a value at an index beyond the existing array.*'
  id: totrans-508
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 6-3：不要尝试替换超出现有数组范围的索引值。*'
- en: Now you know how to change arrays however you might need to. You can add items,
    take items away, or replace items. Next, we’ll look at how to use the properties
    of arrays to find out even more information about them.
  id: totrans-509
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你知道如何根据需要更改数组了。你可以添加项、删除项或替换项。接下来，我们将探讨如何使用数组的属性来获取更多有关它们的信息。
- en: '![Image](Image00133.jpg)'
  id: totrans-510
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00133.jpg)'
- en: '**USING ARRAY PROPERTIES**'
  id: totrans-511
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**使用数组属性**'
- en: In addition to methods like append(_:) and removeLast() , arrays also have *properties*
    . An array’s properties are variables or constants that contain some information
    about the array. Two really helpful properties that you might use are the Boolean
    property isEmpty and the integer property count .
  id: totrans-512
  prefs: []
  type: TYPE_NORMAL
  zh: 除了像 append(_:) 和 removeLast() 这样的函数，数组还有*属性*。数组的属性是包含数组某些信息的变量或常量。有两个非常有用的属性，你可能会用到，它们是布尔值类型的
    isEmpty 属性和整数类型的 count 属性。
- en: The isEmpty property is true or false depending on whether the array is empty,
    and the count property will tell you how many items are in that array.
  id: totrans-513
  prefs: []
  type: TYPE_NORMAL
  zh: isEmpty 属性是布尔值，取决于数组是否为空，而 count 属性则告诉你数组中有多少项。
- en: 'Check out how these two properties are used in the following if-else statement:'
  id: totrans-514
  prefs: []
  type: TYPE_NORMAL
  zh: 查看以下 if-else 语句中这两个属性是如何被使用的：
- en: '![Image](Image00134.jpg)'
  id: totrans-515
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00134.jpg)'
- en: 'This if-else statement checks whether the array mySiblings is empty ➊ . If
    it is, then "I don''t have any siblings." is printed. But if there is something
    in the array, then the number of siblings that we have is printed: "I have 3 siblings."
    ➋ .'
  id: totrans-516
  prefs: []
  type: TYPE_NORMAL
  zh: 这个 if-else 语句检查数组 mySiblings 是否为空 ➊。如果为空，则打印 "我没有兄弟姐妹"。如果数组中有内容，则打印我们有几个兄弟姐妹："我有
    3 个兄弟姐妹" ➋。
- en: '**LOOPING OVER AN ARRAY**'
  id: totrans-517
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**遍历数组**'
- en: 'Sometimes when you’re working with arrays you might want to do something to
    every item in the array. You can use a for-in loop to do that! The following code
    will print every topping in a pizzaToppings array on a separate line:'
  id: totrans-518
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，当你在使用数组时，可能想对数组中的每一项做一些操作。你可以使用 for-in 循环来实现这一点！以下代码将会把 pizzaToppings 数组中的每个配料打印在单独的一行上：
- en: '![Image](Image00135.jpg)'
  id: totrans-519
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00135.jpg)'
- en: To write a for-in loop for the pizzaToppings array, we used the keyword for
    , followed by the constant topping , then the keyword in , and finally the name
    of our array, pizzaToppings . Then we put the statements that we want to run for
    each topping inside the braces of the for-in loop. The constant topping ➊ temporarily
    represents each pizza topping in the array as we loop through it. We could have
    chosen any name for this constant, but it’s a good idea to pick something that
    makes sense. You can see the output of this for-in loop in [Figure 6-4](text00016.html#ch06fig4)
    .
  id: totrans-520
  prefs: []
  type: TYPE_NORMAL
  zh: 为了编写 pizzaToppings 数组的 for-in 循环，我们使用了关键字 for，接着是常量 topping，再是关键字 in，最后是数组的名称
    pizzaToppings。然后我们将希望在每个 topping 上执行的语句放入 for-in 循环的大括号中。常量 topping ➊ 临时代表我们在循环中遍历的每个披萨配料。我们可以为这个常量选择任何名字，但最好选一个有意义的名字。你可以在
    [图 6-4](text00016.html#ch06fig4) 中看到这个 for-in 循环的输出。
- en: '![Image](Image00136.jpg)'
  id: totrans-521
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00136.jpg)'
- en: '*Figure 6-4: Output of the example for-in loop*'
  id: totrans-522
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 6-4：示例 for-in 循环的输出*'
- en: '![Image](Image00137.jpg)'
  id: totrans-523
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00137.jpg)'
- en: 'Using for-in loops is great for printing every value in an array. If you’re
    working with numbers, you can even use them to perform math operations on each
    item, which makes for some speedy calculations! The following code takes an array
    of numbers and calculates the square for each (the square of a number is that
    number multiplied by itself):'
  id: totrans-524
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 for-in 循环打印数组中的每个值非常好。如果你正在处理数字，你甚至可以使用它们对每个项执行数学运算，这样可以加速计算！以下代码接受一个数字数组，并计算每个数字的平方（一个数字的平方是该数字与自身相乘）：
- en: '![Image](Image00138.jpg)'
  id: totrans-525
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00138.jpg)'
- en: '[Figure 6-5](text00016.html#ch06fig5) shows the results.'
  id: totrans-526
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 6-5](text00016.html#ch06fig5) 显示了结果。'
- en: '![Image](Image00139.jpg)'
  id: totrans-527
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00139.jpg)'
- en: '*Figure 6-5: Printing the squares for each number in the myNumbers array*'
  id: totrans-528
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 6-5：打印 myNumbers 数组中每个数字的平方*'
- en: '**DICTIONARIES ARE KEY!**'
  id: totrans-529
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**字典很重要！**'
- en: A *dictionary* is also a collection of values, but instead of an ordered index,
    each value has its own *key* . Because there’s no index, the values are not stored
    in any particular order. To access values in a dictionary, you look them up by
    their key.
  id: totrans-530
  prefs: []
  type: TYPE_NORMAL
  zh: '*字典* 也是一个值的集合，但不同于有序索引，每个值都有自己的 *键* 。由于没有索引，值不会按特定顺序存储。要访问字典中的值，你需要通过其键来查找。'
- en: A key must be unique. You can’t have the same key more than once in the same
    dictionary. If there were two identical keys and you asked the computer to give
    you the value for one of them, the computer wouldn’t know which one to choose!
  id: totrans-531
  prefs: []
  type: TYPE_NORMAL
  zh: 键必须是唯一的。你不能在同一个字典中使用相同的键。如果有两个相同的键并且你请求计算机返回其中一个的值，计算机将不知道选择哪个！
- en: Let’s take a look at how to make a dictionary and write keys that will help
    you find all the information you need.
  id: totrans-532
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看如何创建字典并写入键，以帮助你找到所需的所有信息。
- en: '![Image](Image00140.jpg)'
  id: totrans-533
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00140.jpg)'
- en: '**INITIALIZING A DICTIONARY**'
  id: totrans-534
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**初始化字典**'
- en: 'To create and initialize a dictionary, first write var and the name of your
    dictionary. Then write the keys and corresponding values inside a pair of square
    brackets, similar to an array. Let’s create a dictionary to store the names of
    a few US states. The key for each state will be its two-letter abbreviation:'
  id: totrans-535
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建并初始化字典，首先写 var 和字典的名称。然后像数组一样，将键和值放在一对方括号中。让我们创建一个字典来存储一些美国州的名称。每个州的键将是其两个字母的缩写：
- en: '![](Image00141.jpg)'
  id: totrans-536
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00141.jpg)'
- en: As you can see, there’s a colon between each key and its value, and the key/value
    pairs are separated by commas.
  id: totrans-537
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，键和值之间有一个冒号，键值对之间用逗号分隔。
- en: Dictionaries are different from arrays in that they are *unordered* . Because
    of that, it’s likely that the order of the states that you see in your results
    pane ➋ is different from the order in which you entered your states ➊ . It might
    even be different than the order that’s printed in this book!
  id: totrans-538
  prefs: []
  type: TYPE_NORMAL
  zh: 字典与数组的不同之处在于它们是 *无序* 的。因此，结果面板 ➋ 中看到的状态顺序很可能与输入状态 ➊ 时的顺序不同，甚至可能与本书中打印的顺序不同！
- en: As with arrays, you can use var to make a mutable dictionary or use let to make
    an immutable dictionary.
  id: totrans-539
  prefs: []
  type: TYPE_NORMAL
  zh: 和数组一样，你可以使用 var 来创建可变字典，或者使用 let 来创建不可变字典。
- en: 'In Swift, all of the keys of a dictionary must be the same type, and all of
    the values of a dictionary must also be the same type, but the key type doesn’t
    have to match the value type. For example, if you wanted to store a collection
    of fractions, you could use doubles for the keys and strings for the values:'
  id: totrans-540
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Swift 中，字典的所有键必须是相同的类型，所有值也必须是相同的类型，但键的类型不必与值的类型匹配。例如，如果你想存储一组分数，你可以使用 `Double`
    作为键，`String` 作为值：
- en: '![](Image00142.jpg)'
  id: totrans-541
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00142.jpg)'
- en: In this dictionary, all of the keys must be doubles, and all of the values must
    be strings. Again, you’ll see that the order of the numbers in the results pane
    can be quite different from the order in which you wrote the fractions in your
    dictionary. This is fine because you don’t need to know the order to access anything.
    You can find any item that you need by its key. Let’s see how!
  id: totrans-542
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个字典中，所有的键必须是 `Double` 类型，而所有的值必须是 `String` 类型。同样，你会发现结果窗格中的数字顺序可能与字典中写入分数时的顺序大不相同。这没问题，因为你不需要知道顺序就可以访问任何项。你可以通过键找到任何你需要的项。让我们看看怎么做！
- en: '**ACCESSING VALUES IN A DICTIONARY**'
  id: totrans-543
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**访问字典中的值**'
- en: 'Looking up a value in a dictionary is similar to how you access a value in
    an array except that you use a key inside the square brackets instead of an index,
    like this: usStates["TX"] .'
  id: totrans-544
  prefs: []
  type: TYPE_NORMAL
  zh: 在字典中查找值类似于在数组中访问值，只不过你在方括号内使用的是键，而不是索引，就像这样：`usStates["TX"]`。
- en: There is a big difference, however, in how Swift returns the values from a dictionary.
    When you access a value at an index of an array, you are simply given the value.
    When you access a value with a key in a dictionary, you are given an optional.
  id: totrans-545
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，Swift 在从字典返回值时有很大的不同。当你访问数组中的某个索引时，你会直接得到该值。当你通过字典中的键访问一个值时，你会得到一个可选值。
- en: In [Chapter 5](text00015.html#ch05) , you learned that optionals might contain
    a value or might be nil . The reason Swift returns optionals when you’re looking
    up items in a dictionary is that the key you used might not exist in the dictionary,
    in which case there’s no value to access. Trying to access a value that doesn’t
    exist would give you a big fat error! To avoid that problem, Swift returns optionals.
    That means you need to unwrap any value you get out of a dictionary before you
    can do anything with it.
  id: totrans-546
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第5章](text00015.html#ch05)中，你学到了可选值可能包含一个值，也可能是 `nil`。Swift 在你查找字典中的项时返回可选值，是因为你使用的键可能不存在于字典中，在这种情况下就没有值可供访问。试图访问一个不存在的值会导致一个大错误！为了避免这个问题，Swift
    返回可选值。这意味着你需要解包从字典中获得的任何值，然后才能对它进行处理。
- en: 'To unwrap an optional, first you check whether it exists using an if-let statement,
    just like we did in [Chapter 5](text00015.html#ch05) . The following code shows
    you how to get a value out of a dictionary:'
  id: totrans-547
  prefs: []
  type: TYPE_NORMAL
  zh: 要解包一个可选值，首先通过 `if-let` 语句检查它是否存在，就像我们在[第5章](text00015.html#ch05)中做的那样。以下代码展示了如何从字典中获取值：
- en: '![Image](Image00143.jpg)'
  id: totrans-548
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00143.jpg)'
- en: To retrieve "Texas" from the dictionary, we use if let to set a constant loneStarState
    to usStates["TX"] ➊ . Because we have this state in our dictionary, the line I
    have Texas in my dictionary. is printed. Next we try to access a state that is
    not in our dictionary by using the key usStates["FL"] ➋ . Thankfully, because
    we used an if-let statement, the program won’t crash when the computer can’t find
    this state. Instead, I don't have that state in my dictionary. is printed.
  id: totrans-549
  prefs: []
  type: TYPE_NORMAL
  zh: 要从字典中获取 "Texas"，我们使用 `if let` 将常量 `loneStarState` 设置为 `usStates["TX"]` ➊。因为我们在字典中有这个州，所以下面会打印出
    "I have Texas in my dictionary."。接着，我们尝试通过键 `usStates["FL"]` ➋ 访问一个字典中没有的州。幸运的是，因为我们使用了
    `if-let` 语句，当计算机找不到这个州时，程序不会崩溃，而是会打印出 "I don't have that state in my dictionary."。
- en: '**ADDING ITEMS TO A DICTIONARY**'
  id: totrans-550
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**向字典添加项**'
- en: 'To add an item to a dictionary, first write the name of your dictionary and
    assign the new item to the key you want it to have in the dictionary. Let’s add
    "Minnesota" to our usStates dictionary:'
  id: totrans-551
  prefs: []
  type: TYPE_NORMAL
  zh: 要向字典添加一个项，首先写出字典的名称，并将新项赋值给你希望它在字典中拥有的键。让我们向 `usStates` 字典中添加 "Minnesota"：
- en: '![](Image00144.jpg)'
  id: totrans-552
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00144.jpg)'
- en: 'Now when you look at usStates , you’ll see that it’s updated to ["MN": "Minnesota",
    "WA": "Washington", "MA": "Massachusetts", "TX": "Texas"] . Remember, because
    you don’t have to rely on indices, your new dictionary item might appear anywhere
    in the dictionary.'
  id: totrans-553
  prefs: []
  type: TYPE_NORMAL
  zh: '现在，当你查看 `usStates` 时，你会看到它已更新为 ["MN": "Minnesota", "WA": "Washington", "MA":
    "Massachusetts", "TX": "Texas"]。记住，因为你不需要依赖索引，所以新添加的字典项可能出现在字典中的任何位置。'
- en: '**REMOVING ITEMS FROM A DICTIONARY**'
  id: totrans-554
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**从字典中删除项**'
- en: Removing an item from a dictionary is quite simple; you do so by setting the
    value to nil . Because the values in dictionaries are returned as optionals, you
    don’t have to worry about nil causing any problems in your dictionary.
  id: totrans-555
  prefs: []
  type: TYPE_NORMAL
  zh: 从字典中删除一个项是相当简单的；你只需要将该项的值设置为nil。因为字典中的值是作为可选值返回的，所以你不需要担心nil会在字典中引起任何问题。
- en: '![](Image00145.jpg)'
  id: totrans-556
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00145.jpg)'
- en: 'You can see that after you remove the value at the key "MA" , usStates is updated
    to ["MN": "Minnesota", "WA": "Washington", "TX": "Texas"] . Remember that nil
    is special and means that there’s no value at all. That’s why you don’t see "MA":
    nil in our dictionary.'
  id: totrans-557
  prefs: []
  type: TYPE_NORMAL
  zh: '你可以看到，在你删除了键“MA”对应的值之后，usStates被更新为["MN": "Minnesota", "WA": "Washington",
    "TX": "Texas"]。记住，nil是特殊的，意味着没有值。因此，你不会在字典中看到"MA": nil。'
- en: '**REPLACING ITEMS IN A DICTIONARY**'
  id: totrans-558
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**替换字典中的项**'
- en: 'Replacing an item in a dictionary is also easy. It works the same was as replacing
    an item in an array. You just set the item that you want to replace to something
    else. Say you create a dictionary of fruit colors:'
  id: totrans-559
  prefs: []
  type: TYPE_NORMAL
  zh: 替换字典中的项也很简单。它的工作方式与替换数组中的项相同。你只需将你想替换的项设置为其他值。假设你创建了一个水果颜色的字典：
- en: '![](Image00146.jpg)'
  id: totrans-560
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00146.jpg)'
- en: At first we had the value "apple" for "red" , but then we decided that "raspberry"
    is a better fruit to use since sometimes apples are green or yellow. To replace
    "apple" with "raspberry" , we set colorFruits["red"] to its new value ➊ .
  id: totrans-561
  prefs: []
  type: TYPE_NORMAL
  zh: 一开始，我们将"apple"作为"red"的值，但后来我们决定使用"raspberry"（覆盆子）作为更合适的水果，因为有时苹果是绿色或黄色的。要将"apple"替换为"raspberry"，我们将colorFruits["red"]设置为它的新值
    ➊。
- en: You may remember that this is the same way we entered a new value into a dictionary.
    If the key already exists in the dictionary, then the value for that key is replaced.
    If the key doesn’t already exist, then the new key/value pair will be added to
    the dictionary.
  id: totrans-562
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能还记得，这和我们向字典中添加新值的方式是一样的。如果键已经存在于字典中，那么该键对应的值将被替换。如果键不存在，则新的键/值对将被添加到字典中。
- en: '![Image](Image00147.jpg)'
  id: totrans-563
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00147.jpg)'
- en: '**USING DICTIONARY PROPERTIES**'
  id: totrans-564
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**使用字典属性**'
- en: 'Like an array, a dictionary also has an isEmpty property and a count property.
    For example, the following code shows how you can use the isEmpty property to
    check if a dictionary is empty, and if it isn’t empty, the count property checks
    how many items you have. Imagine you have a basket of fruit for sale. You can
    use these properties to help you keep track of everything:'
  id: totrans-565
  prefs: []
  type: TYPE_NORMAL
  zh: 像数组一样，字典也有isEmpty属性和count属性。例如，以下代码展示了如何使用isEmpty属性检查字典是否为空，如果不为空，count属性则可以检查字典中有多少项。假设你有一个待售的水果篮子，你可以使用这些属性来帮助你跟踪所有物品：
- en: '![Image](Image00148.jpg)'
  id: totrans-566
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00148.jpg)'
- en: 'A dictionary also has two special properties: keys , which contains all of
    the dictionary’s keys, and values , which contains all of its values. We’ll use
    these two properties when we loop through the dictionary.'
  id: totrans-567
  prefs: []
  type: TYPE_NORMAL
  zh: 字典还有两个特殊的属性：keys，包含字典的所有键，和values，包含所有的值。我们将在遍历字典时使用这两个属性。
- en: Let’s write some code that loops through our fruit baskets and prints the price
    of each fruit.
  id: totrans-568
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们编写一些代码，通过遍历我们的水果篮子并打印每种水果的价格。
- en: '**LOOPING OVER A DICTIONARY**'
  id: totrans-569
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**遍历字典**'
- en: 'You can loop through a dictionary using a for-in loop. Because each item has
    a key and a value, you can do this in two different ways. This is how to loop
    through a dictionary using its keys:'
  id: totrans-570
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用for-in循环遍历字典。由于每个项都有一个键和值，你可以用两种不同的方式来实现这一点。这是使用字典的键遍历字典的方法：
- en: '![Image](Image00149.jpg)'
  id: totrans-571
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00149.jpg)'
- en: Here we use the dictionary’s keys property ➊ to loop through fruitBasket and
    print its contents. We start by writing the keyword for , followed by a constant
    name fruit for the dictionary key, the keyword in , the dictionary name, a period,
    and keys .
  id: totrans-572
  prefs: []
  type: TYPE_NORMAL
  zh: 这里我们使用字典的keys属性 ➊ 来遍历fruitBasket并打印其内容。我们从编写关键字for开始，后跟常量名fruit作为字典的键，关键字in，字典名，点符号，然后是keys。
- en: Inside the braces of our for-in loop, we have access to both the key, which
    we call fruit ➋ , and the value at that key when we force-unwrap its contents
    with fruitBasket[fruit]! ➌ . That value will be the fruit’s price.
  id: totrans-573
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的for-in循环的花括号内，我们可以访问到键（我们称之为fruit ➋）以及通过强制解包fruitBasket[fruit]! ➌ 获取到的该键对应的值。这个值将是水果的价格。
- en: In this case, it’s safe to force-unwrap the value using an exclamation point
    because we know that the fruit key we’re using is definitely inside the dictionary.
  id: totrans-574
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，使用感叹号强制解包值是安全的，因为我们知道我们使用的水果键肯定在字典中。
- en: Any code we put inside the for-in loop will run once for every key in our dictionary.
    So you should see the print statement display three times.
  id: totrans-575
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在 for-in 循环中放入的任何代码都会针对字典中的每个键执行一次。所以你应该看到打印语句执行三次。
- en: 'We can also loop through the dictionary using its values property:'
  id: totrans-576
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以使用字典的 values 属性来遍历字典：
- en: '![Image](Image00150.jpg)'
  id: totrans-577
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Image00150.jpg)'
- en: We use the same style of for-in loop, but now we use a constant to refer to
    each value, which we call price , in the values property. When looping through
    values, we don’t have access to the keys from inside the loop.
  id: totrans-578
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用相同类型的 for-in 循环，但现在我们使用常量来引用每个值，我们称之为 price，出现在 values 属性中。在循环值时，我们无法从循环内部访问键。
- en: Another difference to note is that price is not an optional because it’s accessed
    directly as a value in the fruitBasket dictionary. That means we don’t have to
    unwrap it. You should still see the print statement printed three times. [Figure
    6-6](text00016.html#ch06fig6) shows the output of both loops.
  id: totrans-579
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个需要注意的区别是，price 不是可选的，因为它直接作为 fruitBasket 字典中的值来访问。这意味着我们不需要解包它。你仍然应该看到打印语句执行三次。[图6-6](text00016.html#ch06fig6)
    显示了两种循环的输出。
- en: '![Image](Image00151.jpg)'
  id: totrans-580
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Image00151.jpg)'
- en: '*Figure 6-6: Looping through the keys and values of a dictionary with a for-in
    loop*'
  id: totrans-581
  prefs: []
  type: TYPE_NORMAL
  zh: '*图6-6：使用 for-in 循环遍历字典的键和值*'
- en: The order of your results might be slightly different from ours. That’s because
    the items in a dictionary aren’t in a numbered order like they are in an array!
    And because the order is not guaranteed, you might see a different order printed
    if you run the same code again.
  id: totrans-582
  prefs: []
  type: TYPE_NORMAL
  zh: 你的结果顺序可能会与我们的略有不同。这是因为字典中的项目不像数组中的项目那样按数字顺序排列！由于顺序无法保证，如果你再次运行相同的代码，可能会看到不同的顺序。
- en: '**WHAT YOU LEARNED**'
  id: totrans-583
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**你学到了什么**'
- en: In this chapter, you learned how to store collections of items in an array and
    in a dictionary. To store items in an ordered list, you would use an array and
    look up each item by its index. If you wanted to store items by key instead, you
    would use a dictionary.
  id: totrans-584
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你学会了如何在数组和字典中存储项目集合。要将项目存储在有序列表中，你可以使用数组，并通过其索引查找每个项目。如果你想根据键来存储项目，则应使用字典。
- en: Knowing about arrays and dictionaries and how to use them is a powerful building
    block for almost any programming language. Next we will learn about functions,
    another very powerful tool. Functions are blocks of code that you create and name
    to perform a specific job. After you have written a function, you can use its
    name to call it from almost anywhere in your program.
  id: totrans-585
  prefs: []
  type: TYPE_NORMAL
  zh: 了解数组和字典以及如何使用它们，是几乎任何编程语言中强大的构建块。接下来我们将学习函数，这是另一个非常强大的工具。函数是你创建并命名的代码块，用于执行特定的任务。编写完函数后，你可以在程序中的几乎任何地方通过函数名来调用它。
- en: '**KEEPING THINGS IN ORDER WITH ARRAYS**'
  id: totrans-586
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**使用数组保持顺序**'
- en: An *array* is a list of items of the same data type stored in order, kind of
    like a numbered grocery list. Items in an array are stored by their *index* ,
    a number based on where the item is positioned in the array.
  id: totrans-587
  prefs: []
  type: TYPE_NORMAL
  zh: '*数组* 是一种将相同数据类型的项目按顺序存储的列表，有点像编号的购物清单。数组中的项目通过它们的 *索引* 来存储，索引是基于项目在数组中位置的数字。'
- en: When you write a grocery list, you usually start with the number 1, but in computer
    programming, an index starts at 0, not 1\. So the first item in an array is always
    at index 0, the second item is at index 1, the third item is at index 2, and so
    on.
  id: totrans-588
  prefs: []
  type: TYPE_NORMAL
  zh: 当你写购物清单时，通常会从数字1开始，但在计算机编程中，索引是从0开始的，而不是1。所以数组中的第一个项目总是在索引0处，第二个项目在索引1处，第三个项目在索引2处，以此类推。
- en: 'Let’s create an array. If you already know what you’re going to put into your
    array, you can create it and *initialize* it with those values. To initialize
    something in Swift is to give it some initial value so you can use it in your
    program. Let’s say that you want to store a list of all of the national parks
    that you’ve visited. Enter the following into your playground:'
  id: totrans-589
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一个数组。如果你已经知道要放入数组的内容，可以创建并用这些值初始化它。在 Swift 中初始化某样东西是指给它一个初始值，这样你就可以在程序中使用它。假设你想存储你访问过的所有国家公园的列表。将以下内容输入到你的
    Playground 中：
- en: '![](Image00114.jpg)'
  id: totrans-590
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00114.jpg)'
- en: This code creates an array variable called nationalParks and initializes it
    with the names of three national parks. Because we initialized this array to hold
    strings, you’ll only be able to put strings in it.
  id: totrans-591
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码创建了一个名为 nationalParks 的数组变量，并用三个国家公园的名称初始化它。因为我们将这个数组初始化为存储字符串类型，所以你只能在其中放入字符串。
- en: '[Figure 6-1](text00016.html#ch06fig1) shows how you can imagine your array.
    It’s like a row of boxes containing the three names of national parks at indices
    0, 1, and 2\. Remember that the indices of an array always start at 0!'
  id: totrans-592
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 6-1](text00016.html#ch06fig1)展示了你如何想象你的数组。它就像一排盒子，包含了位于索引 0、1 和 2 的三个国家公园的名字。记住，数组的索引总是从
    0 开始！'
- en: '![Image](Image00115.jpg)'
  id: totrans-593
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00115.jpg)'
- en: '*Figure 6-1: The nationalParks array*'
  id: totrans-594
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 6-1：nationalParks 数组*'
- en: '**USING MUTABLE AND IMMUTABLE ARRAYS**'
  id: totrans-595
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**使用可变和不可变数组**'
- en: Our nationalParks array is a variable because we created it with the var keyword
    ➊ . An array stored in a variable is called a *mutable* array. This means that
    you can change it by adding items, removing items, or swapping items in and out.
  id: totrans-596
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的 nationalParks 数组是一个变量，因为我们是用 var 关键字创建它的 ➊。存储在变量中的数组被称为*可变*数组。这意味着你可以通过添加项目、移除项目或交换项目来改变它。
- en: You can also create an *immutable* array. An immutable array is created with
    the keyword let instead of var . Similar to a constant, once an immutable array
    is created, nothing in it can be changed.
  id: totrans-597
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以创建一个*不可变*数组。不可变数组是通过使用关键字 let 而不是 var 来创建的。与常量类似，一旦不可变数组创建完成，它里面的内容就不能被改变。
- en: So when should you use a mutable array or an immutable array? It’s best to use
    let if you know your collection will never change, like if you’re storing the
    colors of the rainbow. You should use var if you need to change your collection,
    like if you’re storing an array of your favorite T-shirts, which might change
    depending on what’s in style!
  id: totrans-598
  prefs: []
  type: TYPE_NORMAL
  zh: 那么什么时候应该使用可变数组或不可变数组呢？如果你知道你的集合永远不会改变，比如你存储的是彩虹的颜色，最好使用 let。如果你需要改变你的集合，比如存储你最喜欢的
    T 恤的数组，这些 T 恤可能会根据时尚变化，应该使用 var！
- en: '![Image](Image00116.jpg)'
  id: totrans-599
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00116.jpg)'
- en: '**USING TYPE INFERENCE**'
  id: totrans-600
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**使用类型推断**'
- en: 'When we created our nationalParks array, we specified that we were creating
    an array of string values by adding a colon (: ) and [String] ➋ . This step is
    optional when you create an array and initialize it with one or more values because
    Swift will use type inference to determine the kind of data you want the array
    to hold. That means that you could just as easily have created the array by doing
    this:'
  id: totrans-601
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们创建 nationalParks 数组时，我们通过添加冒号（:）和 [String] ➋ 来指定我们正在创建一个字符串值的数组。当你创建一个数组并用一个或多个值初始化它时，这一步是可选的，因为
    Swift 会使用类型推断来确定你想让数组存储的数据类型。这意味着你也可以像这样创建数组：
- en: '![](Image00117.jpg)'
  id: totrans-602
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00117.jpg)'
- en: Using type inference, Swift knows we initialized this array to hold strings,
    and it can hold only strings.
  id: totrans-603
  prefs: []
  type: TYPE_NORMAL
  zh: 使用类型推断，Swift 知道我们初始化了这个数组来存储字符串，而且它只能存储字符串。
- en: The list of parks that we created the array with is an example of an array *literal*
    . A literal is a value that is exactly what you see. It is not a variable or constant
    but rather just the value without a name. "Grand Canyon" is an example of a string
    literal, and 7 is an example of an integer literal. An array literal is a list
    of items contained between two square brackets and separated by commas, like ["Acadia",
    "Zion", "Grand Canyon"] ➊ .
  id: totrans-604
  prefs: []
  type: TYPE_NORMAL
  zh: 我们用来创建数组的国家公园列表是一个数组*字面量*的例子。字面量是一个值，正是你看到的内容。它不是变量或常量，而只是没有名称的值。“Grand Canyon”是一个字符串字面量，7
    是一个整数字面量。数组字面量是包含在方括号中的一系列项目，项目之间用逗号分隔，例如 ["Acadia", "Zion", "Grand Canyon"] ➊。
- en: '**ACCESSING ITEMS IN AN ARRAY**'
  id: totrans-605
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**访问数组中的项目**'
- en: 'Let’s say you want to access an item in your array and use it in your program.
    Your friend asks you to tell them all about your travels, so you want to use the
    names of the national parks that you stored in the array. To access an item in
    your array, write the array name followed by the item’s index inside square brackets:'
  id: totrans-606
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你想访问数组中的一个项目并在程序中使用它。你的朋友让你告诉他们你所有的旅行经历，所以你想用你存储在数组中的国家公园名字。要访问数组中的一个项目，写下数组名，后面跟上项目的索引，索引用方括号括起来：
- en: '![](Image00118.jpg)'
  id: totrans-607
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00118.jpg)'
- en: In this example, we are accessing the names of the national parks and then printing
    them to the screen using print . To get the first item in nationalParks , you
    use nationalParks[0] ➊ . To access the second item in nationalParks , you use
    nationalParks[1] .
  id: totrans-608
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们正在访问国家公园的名字，然后通过 print 将它们打印到屏幕上。要获取 nationalParks 中的第一个项目，你可以使用 nationalParks[0]
    ➊。要访问 nationalParks 中的第二个项目，你可以使用 nationalParks[1]。
- en: '**WATCHING THE RANGE**'
  id: totrans-609
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**观察范围**'
- en: One important point about arrays is that if you try to access an item at an
    index that’s higher than the last index in the array, you’ll get an error. In
    [Figure 6-2](text00016.html#ch06fig2) , you can see that nationalParks[3] (which
    would be the fourth item in the array) gives you an error because there are only
    three national parks in the array, indexed from 0 to 2.
  id: totrans-610
  prefs: []
  type: TYPE_NORMAL
  zh: 关于数组的一个重要点是，如果你尝试访问一个高于数组最后一个索引的项，你将会得到一个错误。在[图 6-2](text00016.html#ch06fig2)中，你可以看到
    nationalParks[3]（这将是数组中的第四项）会给你一个错误，因为数组中只有三个国家公园，索引从 0 到 2。
- en: As you can see, you get an error message that says Index out of range . If you
    try to access an item that doesn’t exist in your array, your app will crash!
  id: totrans-611
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，你会收到一条错误信息，提示“索引超出范围”。如果你尝试访问数组中不存在的项，应用程序会崩溃！
- en: '![Image](Image00119.jpg)'
  id: totrans-612
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00119.jpg)'
- en: '*Figure 6-2: Trying to access an index in the array where nothing exists causes
    an error.*'
  id: totrans-613
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 6-2：尝试访问数组中不存在的索引会导致错误。*'
- en: '**ADDING ITEMS TO AN ARRAY**'
  id: totrans-614
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**向数组添加项**'
- en: One way to change an array is to add new items to it. There are a few different
    ways to do this, so let’s take a look at each.
  id: totrans-615
  prefs: []
  type: TYPE_NORMAL
  zh: 改变数组的一种方式就是向它添加新项。这里有几种不同的方式，接下来我们将逐一介绍。
- en: 'First, you can use an array’s append(_:) method. *Append* means to add something.
    Using append(_:) , you can add one new item to the end of your array. Say you
    go on another trip and visit the Badlands, and you want to add it to your list
    of national parks. To do that, add this code into your playground:'
  id: totrans-616
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，你可以使用数组的 append(_:) 方法。*Append* 的意思是添加某个东西。使用 append(_:) 方法，你可以将一个新项添加到数组的末尾。假设你去了一趟新旅行，参观了
    Badlands，并且你想把它添加到你的国家公园列表中。为此，将以下代码添加到你的 playground 中：
- en: '![](Image00120.jpg)'
  id: totrans-617
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00120.jpg)'
- en: To use the append(_:) method, first write the name of your array followed by
    a period and then append . Then, put the item you want to add to your array inside
    the parentheses. In this case, you put "Badlands" inside the parentheses.
  id: totrans-618
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 append(_:) 方法时，首先写下数组的名称，后面跟一个点，然后是 append。接着，将你想要添加到数组的项放到括号内。在本例中，你将 "Badlands"
    放入括号内。
- en: 'If you want to add something at a specific place in your array, use the array’s
    insert(_:at:) method instead. This method takes two arguments: the item that you
    want to insert and the index of where it should go in the array. (We’ll discuss
    arguments in more detail in [Chapter 7](text00017.html#ch07) .)'
  id: totrans-619
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想在数组中的特定位置添加某个元素，可以使用数组的 insert(_:at:) 方法。这个方法接受两个参数：你要插入的项和它在数组中应该插入的位置。（我们将在[第
    7 章](text00017.html#ch07)中详细讨论参数。）
- en: 'Let’s say you totally forgot that you went to the Petrified Forest right after
    you visited the Grand Canyon, and you want to update your nationalParks array
    so it displays the parks in the order in which you visited them. To update your
    array, you could use the insert(_:at:) method to put the Petrified Forest in the
    right position:'
  id: totrans-620
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你完全忘记了在参观大峡谷之后，你去了化石森林，并且你想更新你的 nationalParks 数组，使它显示你访问这些公园的顺序。为了更新你的数组，你可以使用
    insert(_:at:) 方法将化石森林放到正确的位置：
- en: '![](Image00121.jpg)'
  id: totrans-621
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00121.jpg)'
- en: When you insert a new item at index 3, everything that was in the array at index
    3 or higher gets scooted over to make room for the new item. That means the item
    that was at index 3 is now at index 4, the item that was at index 4 is now at
    index 5, and so on. After you add the Petrified Forest, nationalParks is now ["Acadia",
    "Zion", "Grand Canyon", "Petrified Forest", "Badlands"] .
  id: totrans-622
  prefs: []
  type: TYPE_NORMAL
  zh: 当你在索引 3 插入新项时，数组中从索引 3 或更高位置的所有项都会被推到一个位置，以腾出空间给新项。这意味着原本在索引 3 的项现在在索引 4，原本在索引
    4 的项现在在索引 5，依此类推。加入化石森林后，nationalParks 现在是 ["Acadia", "Zion", "Grand Canyon",
    "Petrified Forest", "Badlands"]。
- en: '**COMBINING ARRAYS**'
  id: totrans-623
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**合并数组**'
- en: 'Not only can you add new items to an array, but you can also add two arrays
    together using the + and += operators. Let’s say that you have the ingredients
    for a fruit smoothie in two arrays:'
  id: totrans-624
  prefs: []
  type: TYPE_NORMAL
  zh: 你不仅可以向数组中添加新项，还可以使用 + 和 += 运算符将两个数组相加。假设你有两个数组，分别包含制作水果冰沙的食材：
- en: '![](Image00122.jpg)'
  id: totrans-625
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00122.jpg)'
- en: Now you can make a delicious smoothie by adding the fruits and liquids arrays.
  id: totrans-626
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你可以通过将水果和液体数组相加来制作美味的冰沙。
- en: '![](Image00123.jpg)'
  id: totrans-627
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00123.jpg)'
- en: The order of the ingredients in smoothie is the same as the order in fruits
    and liquids . If you created smoothie with liquids + fruits , then the liquids
    would come first.
  id: totrans-628
  prefs: []
  type: TYPE_NORMAL
  zh: 冰沙中的食材顺序与水果和液体的顺序相同。如果你是将液体 + 水果制作冰沙，那么液体会排在前面。
- en: 'You use the += operator to add an array to the end of your array. Add some
    whipped cream as follows for extra yumminess:'
  id: totrans-629
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用 += 操作符将一个数组添加到你的数组末尾。为了增加更多美味，可以按如下方式添加一些鲜奶油：
- en: '![](Image00124.jpg)'
  id: totrans-630
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00124.jpg)'
- en: Note that ["whipped cream"] is an array even though it has a single item in
    it. When you’re using += to append something to an array, you have to make sure
    you’re only trying to add another array. If you were to just write the string
    "whipped cream" without the square brackets around it, you would get an error.
  id: totrans-631
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，["whipped cream"] 虽然只有一个项，但它依然是一个数组。当你使用 += 来向数组添加元素时，必须确保你只添加另一个数组。如果你仅仅写下字符串
    "whipped cream" 而不加方括号，就会报错。
- en: '![Image](Image00125.jpg)'
  id: totrans-632
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Image00125.jpg)'
- en: '**REMOVING ITEMS FROM AN ARRAY**'
  id: totrans-633
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**从数组中移除项**'
- en: 'There are several methods for removing items from an array. Let’s start by
    looking at the array’s removeLast() method. As you might have guessed from its
    name, removeLast() removes the last item from your array. Let’s try it out with
    a shoppingList array:'
  id: totrans-634
  prefs: []
  type: TYPE_NORMAL
  zh: 有几种方法可以从数组中移除项。我们先从查看数组的 removeLast() 方法开始。正如你从其名称可以猜到的，removeLast() 会移除数组中的最后一个项。让我们用一个
    shoppingList 数组来试试：
- en: '![](Image00126.jpg)'
  id: totrans-635
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00126.jpg)'
- en: Neat! Note that the removeLast() method returns the removed item, so you can
    store it in a new constant or variable if you want.
  id: totrans-636
  prefs: []
  type: TYPE_NORMAL
  zh: 很棒！请注意，removeLast() 方法会返回被移除的项，因此如果需要，你可以将其存储在新的常量或变量中。
- en: 'You can also remove an item from a specific index by using the remove(at:)
    method. Let’s say that your mom doesn’t want you buying any candy and takes that
    off the list:'
  id: totrans-637
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以通过使用 remove(at:) 方法从特定索引处移除项。假设你妈妈不想让你买糖果，并将其从购物清单中移除：
- en: '![Image](Image00127.jpg)![](Image00128.jpg)'
  id: totrans-638
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Image00127.jpg)![](Image00128.jpg)'
- en: Just like when we added an item to the middle of our array and all the items
    scooted over to make room, if you remove an item from the middle of an array,
    the rest of the items will scoot back to fill in that empty space. The "apples"
    item that was at index 3 is now at index 2, where "candy" was.
  id: totrans-639
  prefs: []
  type: TYPE_NORMAL
  zh: 就像我们在数组中间添加项时，所有项都会挪动位置以腾出空间一样，如果你从数组中间移除一个项，其余项也会挪回以填补空位。原本在索引 3 位置的“apples”项，现在移到了原来“candy”所在的索引
    2 位置。
- en: 'You can also remove all items from an array with removeAll() . Try entering
    this into your playground:'
  id: totrans-640
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以使用 removeAll() 方法从数组中移除所有项。试着在你的 playground 中输入以下内容：
- en: '![](Image00129.jpg)'
  id: totrans-641
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00129.jpg)'
- en: 'Note that trying to remove an item at an index that doesn’t exist will give
    you an error:'
  id: totrans-642
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，尝试从不存在的索引处移除项会引发错误：
- en: '![](Image00130.jpg)'
  id: totrans-643
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00130.jpg)'
- en: Our array doesn’t have this many items (in fact, now it’s empty!), so this throws
    an error. We’ll also get an error if we use removeLast() on our empty array, because
    there’s nothing in it—there’s no last index at all! However, removeAll() is always
    safe to use, even on an empty array.
  id: totrans-644
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的数组并没有这么多项（事实上，现在它是空的！），所以这会抛出一个错误。如果我们在空数组上使用 removeLast()，也会报错，因为它里面什么都没有——根本没有最后一个索引！然而，removeAll()
    是安全的，即使在空数组上也能正常使用。
- en: '**REPLACING ITEMS IN AN ARRAY**'
  id: totrans-645
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**替换数组中的项**'
- en: 'To replace an item in an array, you set the index of the array to the new value,
    as shown here:'
  id: totrans-646
  prefs: []
  type: TYPE_NORMAL
  zh: 要替换数组中的项，你需要将数组的索引设置为新值，如下所示：
- en: '![](Image00131.jpg)'
  id: totrans-647
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00131.jpg)'
- en: At ➊ , we replaced the item at index 2 (the third item) with "Unicorn" because
    magical animals count as favorite animals, too! At ➋ , we replaced the item at
    index 0 (the first item) with "Bearded dragon" . No, that’s not a real dragon—it’s
    just a lizard!
  id: totrans-648
  prefs: []
  type: TYPE_NORMAL
  zh: 在 ➊ 位置，我们将索引 2（第三项）处的项替换为 "Unicorn"，因为魔法动物也算是最喜欢的动物！在 ➋ 位置，我们将索引 0（第一项）处的项替换为
    "Bearded dragon"。不，这不是一只真正的龙——它只是一个蜥蜴！
- en: Like any time you’re working with array index numbers, you have to be sure an
    item exists in the array at that index before you change its value, or you will
    get an Index out of range error.
  id: totrans-649
  prefs: []
  type: TYPE_NORMAL
  zh: 就像你在处理数组索引时一样，必须确保该索引位置的项存在于数组中，否则你会遇到“索引超出范围”的错误。
- en: '[Figure 6-3](text00016.html#ch06fig3) shows the error that occurs if you try
    to add "Standard poodle" using favoriteAnimals[3] = "Standard poodle" . To add
    an item to the end of an array, you should use the append(_:) method or += , as
    we covered in “[Adding Items to an Array](text00016.html#ch06lev2sec5) ” on [page
    70](text00016.html#page_70) .'
  id: totrans-650
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 6-3](text00016.html#ch06fig3) 展示了如果你试图通过 favoriteAnimals[3] = "Standard
    poodle" 来添加 "Standard poodle"，会发生的错误。要将项添加到数组末尾，你应该使用 append(_:) 方法或 +=，正如我们在
    “[向数组添加项](text00016.html#ch06lev2sec5)” 中所讲解的，在 [第 70 页](text00016.html#page_70)
    中。'
- en: '![Image](Image00132.jpg)'
  id: totrans-651
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Image00132.jpg)'
- en: '*Figure 6-3: Don’t try to replace a value at an index beyond the existing array.*'
  id: totrans-652
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 6-3：不要尝试在超出现有数组范围的索引位置替换值。*'
- en: Now you know how to change arrays however you might need to. You can add items,
    take items away, or replace items. Next, we’ll look at how to use the properties
    of arrays to find out even more information about them.
  id: totrans-653
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你知道如何根据需要修改数组了。你可以添加项目、删除项目或替换项目。接下来，我们将看看如何使用数组的属性获取更多关于它们的信息。
- en: '![Image](Image00133.jpg)'
  id: totrans-654
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00133.jpg)'
- en: '**USING ARRAY PROPERTIES**'
  id: totrans-655
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**使用数组属性**'
- en: In addition to methods like append(_:) and removeLast() , arrays also have *properties*
    . An array’s properties are variables or constants that contain some information
    about the array. Two really helpful properties that you might use are the Boolean
    property isEmpty and the integer property count .
  id: totrans-656
  prefs: []
  type: TYPE_NORMAL
  zh: 除了像 append(_:) 和 removeLast() 这样的函数，数组还拥有 *属性*。数组的属性是包含有关数组信息的变量或常量。你可能会用到的两个非常有用的属性是布尔类型的
    isEmpty 属性和整数类型的 count 属性。
- en: The isEmpty property is true or false depending on whether the array is empty,
    and the count property will tell you how many items are in that array.
  id: totrans-657
  prefs: []
  type: TYPE_NORMAL
  zh: isEmpty 属性根据数组是否为空返回 true 或 false，而 count 属性会告诉你数组中有多少个元素。
- en: 'Check out how these two properties are used in the following if-else statement:'
  id: totrans-658
  prefs: []
  type: TYPE_NORMAL
  zh: 查看以下 if-else 语句中如何使用这两个属性：
- en: '![Image](Image00134.jpg)'
  id: totrans-659
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00134.jpg)'
- en: 'This if-else statement checks whether the array mySiblings is empty ➊ . If
    it is, then "I don''t have any siblings." is printed. But if there is something
    in the array, then the number of siblings that we have is printed: "I have 3 siblings."
    ➋ .'
  id: totrans-660
  prefs: []
  type: TYPE_NORMAL
  zh: 这个 if-else 语句检查数组 mySiblings 是否为空 ➊。如果为空，程序会打印 "我没有兄弟姐妹"。如果数组中有元素，程序会打印我们有多少个兄弟姐妹："我有
    3 个兄弟姐妹。" ➋。
- en: '**LOOPING OVER AN ARRAY**'
  id: totrans-661
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**遍历数组**'
- en: 'Sometimes when you’re working with arrays you might want to do something to
    every item in the array. You can use a for-in loop to do that! The following code
    will print every topping in a pizzaToppings array on a separate line:'
  id: totrans-662
  prefs: []
  type: TYPE_NORMAL
  zh: 有时候，在处理数组时，你可能希望对数组中的每个元素做一些事情。你可以使用 for-in 循环来做到这一点！以下代码会将 pizzaToppings 数组中的每个配料打印在单独的一行：
- en: '![Image](Image00135.jpg)'
  id: totrans-663
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00135.jpg)'
- en: To write a for-in loop for the pizzaToppings array, we used the keyword for
    , followed by the constant topping , then the keyword in , and finally the name
    of our array, pizzaToppings . Then we put the statements that we want to run for
    each topping inside the braces of the for-in loop. The constant topping ➊ temporarily
    represents each pizza topping in the array as we loop through it. We could have
    chosen any name for this constant, but it’s a good idea to pick something that
    makes sense. You can see the output of this for-in loop in [Figure 6-4](text00016.html#ch06fig4)
    .
  id: totrans-664
  prefs: []
  type: TYPE_NORMAL
  zh: 为了编写一个针对 pizzaToppings 数组的 for-in 循环，我们使用了关键字 for，后面跟着常量 topping，然后是关键字 in，最后是数组的名称
    pizzaToppings。然后，我们把希望在每个 topping 上执行的语句放入 for-in 循环的大括号中。常量 topping ➊ 临时代表数组中每一个披萨配料，我们遍历数组时它依次代表每个配料。我们本可以为这个常量选择任何名字，但最好选一个有意义的名字。你可以在[图
    6-4](text00016.html#ch06fig4) 中看到这个 for-in 循环的输出。
- en: '![Image](Image00136.jpg)'
  id: totrans-665
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00136.jpg)'
- en: '*Figure 6-4: Output of the example for-in loop*'
  id: totrans-666
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 6-4：示例 for-in 循环的输出*'
- en: '![Image](Image00137.jpg)'
  id: totrans-667
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00137.jpg)'
- en: 'Using for-in loops is great for printing every value in an array. If you’re
    working with numbers, you can even use them to perform math operations on each
    item, which makes for some speedy calculations! The following code takes an array
    of numbers and calculates the square for each (the square of a number is that
    number multiplied by itself):'
  id: totrans-668
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 for-in 循环非常适合打印数组中的每个值。如果你处理的是数字，甚至可以用它们对每个项目执行数学运算，这样就能快速计算！以下代码接收一个数字数组并计算每个数字的平方（一个数字的平方就是这个数字与其本身相乘）：
- en: '![Image](Image00138.jpg)'
  id: totrans-669
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00138.jpg)'
- en: '[Figure 6-5](text00016.html#ch06fig5) shows the results.'
  id: totrans-670
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 6-5](text00016.html#ch06fig5) 展示了结果。'
- en: '![Image](Image00139.jpg)'
  id: totrans-671
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00139.jpg)'
- en: '*Figure 6-5: Printing the squares for each number in the myNumbers array*'
  id: totrans-672
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 6-5：打印 myNumbers 数组中每个数字的平方*'
- en: '**DICTIONARIES ARE KEY!**'
  id: totrans-673
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**字典是关键！**'
- en: A *dictionary* is also a collection of values, but instead of an ordered index,
    each value has its own *key* . Because there’s no index, the values are not stored
    in any particular order. To access values in a dictionary, you look them up by
    their key.
  id: totrans-674
  prefs: []
  type: TYPE_NORMAL
  zh: '*字典* 也是一类值的集合，但与数组不同的是，字典中的每个值都有自己的 *键*。因为没有索引，字典中的值没有特定顺序。要访问字典中的值，你需要通过键来查找它们。'
- en: A key must be unique. You can’t have the same key more than once in the same
    dictionary. If there were two identical keys and you asked the computer to give
    you the value for one of them, the computer wouldn’t know which one to choose!
  id: totrans-675
  prefs: []
  type: TYPE_NORMAL
  zh: 键必须是唯一的。你不能在同一个字典中使用相同的键两次。如果有两个相同的键，而你要求计算机给你其中一个键的值，计算机就不知道选择哪个！
- en: Let’s take a look at how to make a dictionary and write keys that will help
    you find all the information you need.
  id: totrans-676
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看如何创建一个字典，并写下能够帮助你找到所有所需信息的键。
- en: '![Image](Image00140.jpg)'
  id: totrans-677
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00140.jpg)'
- en: '**INITIALIZING A DICTIONARY**'
  id: totrans-678
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**初始化字典**'
- en: 'To create and initialize a dictionary, first write var and the name of your
    dictionary. Then write the keys and corresponding values inside a pair of square
    brackets, similar to an array. Let’s create a dictionary to store the names of
    a few US states. The key for each state will be its two-letter abbreviation:'
  id: totrans-679
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建和初始化一个字典，首先写下`var`和字典的名称。然后，在一对方括号中写下键和值，类似于数组。我们来创建一个字典来存储一些美国州的名称。每个州的键将是其两位字母的缩写：
- en: '![](Image00141.jpg)'
  id: totrans-680
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00141.jpg)'
- en: As you can see, there’s a colon between each key and its value, and the key/value
    pairs are separated by commas.
  id: totrans-681
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，键和值之间有一个冒号，键/值对之间用逗号分隔。
- en: Dictionaries are different from arrays in that they are *unordered* . Because
    of that, it’s likely that the order of the states that you see in your results
    pane ➋ is different from the order in which you entered your states ➊ . It might
    even be different than the order that’s printed in this book!
  id: totrans-682
  prefs: []
  type: TYPE_NORMAL
  zh: 字典与数组的不同之处在于它们是*无序的*。因此，你在结果窗格中看到的州的顺序➋可能与输入州的顺序➊不同，甚至可能与本书中打印的顺序不同！
- en: As with arrays, you can use var to make a mutable dictionary or use let to make
    an immutable dictionary.
  id: totrans-683
  prefs: []
  type: TYPE_NORMAL
  zh: 与数组一样，你可以使用`var`来创建一个可变字典，或者使用`let`来创建一个不可变字典。
- en: 'In Swift, all of the keys of a dictionary must be the same type, and all of
    the values of a dictionary must also be the same type, but the key type doesn’t
    have to match the value type. For example, if you wanted to store a collection
    of fractions, you could use doubles for the keys and strings for the values:'
  id: totrans-684
  prefs: []
  type: TYPE_NORMAL
  zh: 在Swift中，字典的所有键必须是相同类型，字典的所有值也必须是相同类型，但键的类型不需要与值的类型匹配。例如，如果你想存储一个分数的集合，你可以将键定义为浮动数值，将值定义为字符串：
- en: '![](Image00142.jpg)'
  id: totrans-685
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00142.jpg)'
- en: In this dictionary, all of the keys must be doubles, and all of the values must
    be strings. Again, you’ll see that the order of the numbers in the results pane
    can be quite different from the order in which you wrote the fractions in your
    dictionary. This is fine because you don’t need to know the order to access anything.
    You can find any item that you need by its key. Let’s see how!
  id: totrans-686
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个字典中，所有的键必须是浮动数值，所有的值必须是字符串。再一次，你会看到结果窗格中数字的顺序可能与字典中分数的书写顺序完全不同。这是正常的，因为你不需要知道顺序就能访问任何内容。你可以通过键找到你需要的任何项目。我们来看看怎么做！
- en: '**ACCESSING VALUES IN A DICTIONARY**'
  id: totrans-687
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**访问字典中的值**'
- en: 'Looking up a value in a dictionary is similar to how you access a value in
    an array except that you use a key inside the square brackets instead of an index,
    like this: usStates["TX"] .'
  id: totrans-688
  prefs: []
  type: TYPE_NORMAL
  zh: 在字典中查找值类似于你如何通过数组访问值，只不过你使用键而不是索引，在方括号内这样写：usStates["TX"]。
- en: There is a big difference, however, in how Swift returns the values from a dictionary.
    When you access a value at an index of an array, you are simply given the value.
    When you access a value with a key in a dictionary, you are given an optional.
  id: totrans-689
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，Swift从字典返回值的方式有一个很大的不同。当你通过数组的索引访问一个值时，你只会得到该值。当你通过字典的键访问一个值时，你得到的是一个可选值。
- en: In [Chapter 5](text00015.html#ch05) , you learned that optionals might contain
    a value or might be nil . The reason Swift returns optionals when you’re looking
    up items in a dictionary is that the key you used might not exist in the dictionary,
    in which case there’s no value to access. Trying to access a value that doesn’t
    exist would give you a big fat error! To avoid that problem, Swift returns optionals.
    That means you need to unwrap any value you get out of a dictionary before you
    can do anything with it.
  id: totrans-690
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第5章](text00015.html#ch05)中，你学到了可选值可能包含一个值，也可能是nil。Swift在查找字典中的项目时返回可选值的原因是你使用的键可能不存在于字典中，在这种情况下没有值可访问。尝试访问一个不存在的值会给你带来一个大大的错误！为了避免这个问题，Swift返回可选值。这意味着你需要解包从字典中获取的任何值，才能对其进行操作。
- en: 'To unwrap an optional, first you check whether it exists using an if-let statement,
    just like we did in [Chapter 5](text00015.html#ch05) . The following code shows
    you how to get a value out of a dictionary:'
  id: totrans-691
  prefs: []
  type: TYPE_NORMAL
  zh: 要解包一个可选值，首先使用 if-let 语句检查它是否存在，就像我们在[第 5 章](text00015.html#ch05)中所做的那样。以下代码展示了如何从字典中获取一个值：
- en: '![Image](Image00143.jpg)'
  id: totrans-692
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00143.jpg)'
- en: To retrieve "Texas" from the dictionary, we use if let to set a constant loneStarState
    to usStates["TX"] ➊ . Because we have this state in our dictionary, the line I
    have Texas in my dictionary. is printed. Next we try to access a state that is
    not in our dictionary by using the key usStates["FL"] ➋ . Thankfully, because
    we used an if-let statement, the program won’t crash when the computer can’t find
    this state. Instead, I don't have that state in my dictionary. is printed.
  id: totrans-693
  prefs: []
  type: TYPE_NORMAL
  zh: 要从字典中检索 "Texas"，我们使用 if let 将常量 loneStarState 设置为 usStates["TX"] ➊。因为我们在字典中有这个州，所以会打印出
    I have Texas in my dictionary. 接下来，我们尝试通过使用键 usStates["FL"] ➋ 访问一个不在字典中的州。幸运的是，由于我们使用了
    if-let 语句，当计算机找不到这个州时，程序不会崩溃。相反，会打印出 I don't have that state in my dictionary.
- en: '**ADDING ITEMS TO A DICTIONARY**'
  id: totrans-694
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**向字典中添加项**'
- en: 'To add an item to a dictionary, first write the name of your dictionary and
    assign the new item to the key you want it to have in the dictionary. Let’s add
    "Minnesota" to our usStates dictionary:'
  id: totrans-695
  prefs: []
  type: TYPE_NORMAL
  zh: 要向字典中添加一个项，首先写下字典的名称，并将新项分配给你希望它在字典中拥有的键。让我们将 "Minnesota" 添加到我们的 usStates 字典中：
- en: '![](Image00144.jpg)'
  id: totrans-696
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00144.jpg)'
- en: 'Now when you look at usStates , you’ll see that it’s updated to ["MN": "Minnesota",
    "WA": "Washington", "MA": "Massachusetts", "TX": "Texas"] . Remember, because
    you don’t have to rely on indices, your new dictionary item might appear anywhere
    in the dictionary.'
  id: totrans-697
  prefs: []
  type: TYPE_NORMAL
  zh: '现在当你查看 usStates 时，你会看到它已更新为 ["MN": "Minnesota", "WA": "Washington", "MA": "Massachusetts",
    "TX": "Texas"]。记住，由于你不必依赖索引，你的新字典项可能出现在字典的任何位置。'
- en: '**REMOVING ITEMS FROM A DICTIONARY**'
  id: totrans-698
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**从字典中删除项**'
- en: Removing an item from a dictionary is quite simple; you do so by setting the
    value to nil . Because the values in dictionaries are returned as optionals, you
    don’t have to worry about nil causing any problems in your dictionary.
  id: totrans-699
  prefs: []
  type: TYPE_NORMAL
  zh: 从字典中删除项非常简单；你只需将值设置为 nil。因为字典中的值是作为可选项返回的，所以你不必担心 nil 会在字典中引起任何问题。
- en: '![](Image00145.jpg)'
  id: totrans-700
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00145.jpg)'
- en: 'You can see that after you remove the value at the key "MA" , usStates is updated
    to ["MN": "Minnesota", "WA": "Washington", "TX": "Texas"] . Remember that nil
    is special and means that there’s no value at all. That’s why you don’t see "MA":
    nil in our dictionary.'
  id: totrans-701
  prefs: []
  type: TYPE_NORMAL
  zh: '你可以看到，在删除键 "MA" 的值后，usStates 已更新为 ["MN": "Minnesota", "WA": "Washington", "TX":
    "Texas"]。记住，nil 是特殊的，意味着完全没有值。这就是为什么在我们的字典中看不到 "MA": nil 的原因。'
- en: '**REPLACING ITEMS IN A DICTIONARY**'
  id: totrans-702
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**替换字典中的项**'
- en: 'Replacing an item in a dictionary is also easy. It works the same was as replacing
    an item in an array. You just set the item that you want to replace to something
    else. Say you create a dictionary of fruit colors:'
  id: totrans-703
  prefs: []
  type: TYPE_NORMAL
  zh: 替换字典中的项也很简单。它的工作方式与替换数组中的项相同。你只需将你要替换的项设置为其他内容。比如你创建了一个水果颜色的字典：
- en: '![](Image00146.jpg)'
  id: totrans-704
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00146.jpg)'
- en: At first we had the value "apple" for "red" , but then we decided that "raspberry"
    is a better fruit to use since sometimes apples are green or yellow. To replace
    "apple" with "raspberry" , we set colorFruits["red"] to its new value ➊ .
  id: totrans-705
  prefs: []
  type: TYPE_NORMAL
  zh: 起初我们将 "apple" 作为 "red" 的值，但后来我们决定 "raspberry" 是一个更好的水果选择，因为有时苹果是绿色或黄色的。为了将 "apple"
    替换为 "raspberry"，我们将 colorFruits["red"] 设置为它的新值 ➊。
- en: You may remember that this is the same way we entered a new value into a dictionary.
    If the key already exists in the dictionary, then the value for that key is replaced.
    If the key doesn’t already exist, then the new key/value pair will be added to
    the dictionary.
  id: totrans-706
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能还记得，这和我们将新值输入字典时的方式相同。如果键已经存在于字典中，那么该键的值会被替换。如果键不存在，则新的键/值对会被添加到字典中。
- en: '![Image](Image00147.jpg)'
  id: totrans-707
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00147.jpg)'
- en: '**USING DICTIONARY PROPERTIES**'
  id: totrans-708
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**使用字典属性**'
- en: 'Like an array, a dictionary also has an isEmpty property and a count property.
    For example, the following code shows how you can use the isEmpty property to
    check if a dictionary is empty, and if it isn’t empty, the count property checks
    how many items you have. Imagine you have a basket of fruit for sale. You can
    use these properties to help you keep track of everything:'
  id: totrans-709
  prefs: []
  type: TYPE_NORMAL
  zh: 像数组一样，字典也有 isEmpty 属性和 count 属性。例如，以下代码展示了如何使用 isEmpty 属性检查字典是否为空，如果不为空，则使用
    count 属性检查你有多少个项。假设你有一个出售的水果篮子。你可以使用这些属性来帮助你跟踪所有的物品：
- en: '![Image](Image00148.jpg)'
  id: totrans-710
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00148.jpg)'
- en: 'A dictionary also has two special properties: keys , which contains all of
    the dictionary’s keys, and values , which contains all of its values. We’ll use
    these two properties when we loop through the dictionary.'
  id: totrans-711
  prefs: []
  type: TYPE_NORMAL
  zh: 字典还有两个特殊的属性：keys，其中包含字典的所有键，以及 values，其中包含字典的所有值。我们将在循环遍历字典时使用这两个属性。
- en: Let’s write some code that loops through our fruit baskets and prints the price
    of each fruit.
  id: totrans-712
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们编写一些代码，通过水果篮子循环并打印每个水果的价格。
- en: '**LOOPING OVER A DICTIONARY**'
  id: totrans-713
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**循环遍历字典**'
- en: 'You can loop through a dictionary using a for-in loop. Because each item has
    a key and a value, you can do this in two different ways. This is how to loop
    through a dictionary using its keys:'
  id: totrans-714
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用 for-in 循环遍历字典。因为每个项目都有一个键和值，所以你可以用两种不同的方式来做。下面是通过字典的键来循环的方式：
- en: '![Image](Image00149.jpg)'
  id: totrans-715
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00149.jpg)'
- en: Here we use the dictionary’s keys property ➊ to loop through fruitBasket and
    print its contents. We start by writing the keyword for , followed by a constant
    name fruit for the dictionary key, the keyword in , the dictionary name, a period,
    and keys .
  id: totrans-716
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们使用字典的 keys 属性 ➊ 来循环遍历 fruitBasket 并打印其内容。我们从写关键字 for 开始，接着是字典键的常量名称 fruit，关键字
    in，字典名称，句点和 keys。
- en: Inside the braces of our for-in loop, we have access to both the key, which
    we call fruit ➋ , and the value at that key when we force-unwrap its contents
    with fruitBasket[fruit]! ➌ . That value will be the fruit’s price.
  id: totrans-717
  prefs: []
  type: TYPE_NORMAL
  zh: 在 for-in 循环的花括号内，我们可以访问键（我们称之为 fruit ➋）和该键对应的值，当我们通过 fruitBasket[fruit]! ➌ 强制解包其内容时。该值将是水果的价格。
- en: In this case, it’s safe to force-unwrap the value using an exclamation point
    because we know that the fruit key we’re using is definitely inside the dictionary.
  id: totrans-718
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，使用感叹号强制解包值是安全的，因为我们知道我们使用的水果键肯定在字典中。
- en: Any code we put inside the for-in loop will run once for every key in our dictionary.
    So you should see the print statement display three times.
  id: totrans-719
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在 for-in 循环中放入的任何代码都会对字典中的每个键执行一次。所以你应该能看到打印语句显示三次。
- en: 'We can also loop through the dictionary using its values property:'
  id: totrans-720
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以通过字典的 values 属性来循环遍历：
- en: '![Image](Image00150.jpg)'
  id: totrans-721
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00150.jpg)'
- en: We use the same style of for-in loop, but now we use a constant to refer to
    each value, which we call price , in the values property. When looping through
    values, we don’t have access to the keys from inside the loop.
  id: totrans-722
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用相同的 for-in 循环风格，但现在我们使用一个常量来引用每个值，我们称之为 price，位于 values 属性中。在循环遍历值时，我们无法从循环内部访问键。
- en: Another difference to note is that price is not an optional because it’s accessed
    directly as a value in the fruitBasket dictionary. That means we don’t have to
    unwrap it. You should still see the print statement printed three times. [Figure
    6-6](text00016.html#ch06fig6) shows the output of both loops.
  id: totrans-723
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个需要注意的区别是，价格不是可选的，因为它是直接作为 fruitBasket 字典中的值访问的。这意味着我们不需要解包它。你仍然应该看到打印语句打印三次。[图6-6](text00016.html#ch06fig6)
    显示了两个循环的输出。
- en: '![Image](Image00151.jpg)'
  id: totrans-724
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00151.jpg)'
- en: '*Figure 6-6: Looping through the keys and values of a dictionary with a for-in
    loop*'
  id: totrans-725
  prefs: []
  type: TYPE_NORMAL
  zh: '*图6-6：使用 for-in 循环遍历字典的键和值*'
- en: The order of your results might be slightly different from ours. That’s because
    the items in a dictionary aren’t in a numbered order like they are in an array!
    And because the order is not guaranteed, you might see a different order printed
    if you run the same code again.
  id: totrans-726
  prefs: []
  type: TYPE_NORMAL
  zh: 你的结果顺序可能与我们的略有不同。这是因为字典中的项目不像数组中的项目那样按编号顺序排列！而且因为顺序不保证，你可能会在再次运行相同的代码时看到不同的顺序。
- en: '**WHAT YOU LEARNED**'
  id: totrans-727
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**你学到了什么**'
- en: In this chapter, you learned how to store collections of items in an array and
    in a dictionary. To store items in an ordered list, you would use an array and
    look up each item by its index. If you wanted to store items by key instead, you
    would use a dictionary.
  id: totrans-728
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你学会了如何将项目存储在数组和字典中。要将项目存储在有序列表中，你可以使用数组，并通过索引查找每个项目。如果你想按键存储项目，则可以使用字典。
- en: Knowing about arrays and dictionaries and how to use them is a powerful building
    block for almost any programming language. Next we will learn about functions,
    another very powerful tool. Functions are blocks of code that you create and name
    to perform a specific job. After you have written a function, you can use its
    name to call it from almost anywhere in your program.
  id: totrans-729
  prefs: []
  type: TYPE_NORMAL
  zh: 了解数组和字典以及如何使用它们，是几乎任何编程语言的一个强大构建模块。接下来我们将学习函数，这是另一个非常强大的工具。函数是你创建并命名的一段代码，用来执行特定的任务。写完函数后，你可以通过它的名字在程序的几乎任何地方调用它。
- en: An *array* is a list of items of the same data type stored in order, kind of
    like a numbered grocery list. Items in an array are stored by their *index* ,
    a number based on where the item is positioned in the array.
  id: totrans-730
  prefs: []
  type: TYPE_NORMAL
  zh: '*数组*是存储相同数据类型项目的列表，按照顺序排列，有点像一个编号的购物清单。数组中的项目按*索引*存储，索引是基于项目在数组中的位置的数字。'
- en: When you write a grocery list, you usually start with the number 1, but in computer
    programming, an index starts at 0, not 1\. So the first item in an array is always
    at index 0, the second item is at index 1, the third item is at index 2, and so
    on.
  id: totrans-731
  prefs: []
  type: TYPE_NORMAL
  zh: 当你写购物清单时，你通常会从数字1开始，但在计算机编程中，索引是从0开始的，而不是1。所以数组中的第一个项目总是位于索引0，第二个项目位于索引1，第三个项目位于索引2，以此类推。
- en: 'Let’s create an array. If you already know what you’re going to put into your
    array, you can create it and *initialize* it with those values. To initialize
    something in Swift is to give it some initial value so you can use it in your
    program. Let’s say that you want to store a list of all of the national parks
    that you’ve visited. Enter the following into your playground:'
  id: totrans-732
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一个数组。如果你已经知道你要放入数组的内容，可以创建它并用这些值进行*初始化*。在Swift中，初始化就是赋予某个值一个初始值，以便你可以在程序中使用它。假设你想存储你访问过的所有国家公园的列表。请在你的Playground中输入以下内容：
- en: '![](Image00114.jpg)'
  id: totrans-733
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00114.jpg)'
- en: This code creates an array variable called nationalParks and initializes it
    with the names of three national parks. Because we initialized this array to hold
    strings, you’ll only be able to put strings in it.
  id: totrans-734
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码创建了一个名为nationalParks的数组变量，并用三个国家公园的名字对其进行了初始化。因为我们初始化这个数组来存储字符串，所以你只能向其中添加字符串。
- en: '[Figure 6-1](text00016.html#ch06fig1) shows how you can imagine your array.
    It’s like a row of boxes containing the three names of national parks at indices
    0, 1, and 2\. Remember that the indices of an array always start at 0!'
  id: totrans-735
  prefs: []
  type: TYPE_NORMAL
  zh: '[图6-1](text00016.html#ch06fig1)展示了你如何理解数组。它就像一排盒子，包含了国家公园的三个名字，分别位于索引0、1和2的位置。记住，数组的索引总是从0开始！'
- en: '![Image](Image00115.jpg)'
  id: totrans-736
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00115.jpg)'
- en: '*Figure 6-1: The nationalParks array*'
  id: totrans-737
  prefs: []
  type: TYPE_NORMAL
  zh: '*图6-1：nationalParks数组*'
- en: '**USING MUTABLE AND IMMUTABLE ARRAYS**'
  id: totrans-738
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**使用可变和不可变数组**'
- en: Our nationalParks array is a variable because we created it with the var keyword
    ➊ . An array stored in a variable is called a *mutable* array. This means that
    you can change it by adding items, removing items, or swapping items in and out.
  id: totrans-739
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的nationalParks数组是一个变量，因为我们使用`var`关键字创建了它➊。存储在变量中的数组被称为*可变*数组。这意味着你可以通过添加、删除或交换项目来改变它。
- en: You can also create an *immutable* array. An immutable array is created with
    the keyword let instead of var . Similar to a constant, once an immutable array
    is created, nothing in it can be changed.
  id: totrans-740
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以创建一个*不可变*数组。不可变数组是使用`let`关键字而不是`var`创建的。类似于常量，一旦不可变数组创建后，它其中的内容就不能再更改。
- en: So when should you use a mutable array or an immutable array? It’s best to use
    let if you know your collection will never change, like if you’re storing the
    colors of the rainbow. You should use var if you need to change your collection,
    like if you’re storing an array of your favorite T-shirts, which might change
    depending on what’s in style!
  id: totrans-741
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，什么时候应该使用可变数组或不可变数组呢？如果你知道你的集合永远不会改变，比如如果你存储的是彩虹的颜色，最好使用`let`。如果你需要改变集合，比如存储的是你最喜欢的T恤的数组，可能会根据时尚变化，应该使用`var`！
- en: '![Image](Image00116.jpg)'
  id: totrans-742
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00116.jpg)'
- en: '**USING TYPE INFERENCE**'
  id: totrans-743
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**使用类型推断**'
- en: 'When we created our nationalParks array, we specified that we were creating
    an array of string values by adding a colon (: ) and [String] ➋ . This step is
    optional when you create an array and initialize it with one or more values because
    Swift will use type inference to determine the kind of data you want the array
    to hold. That means that you could just as easily have created the array by doing
    this:'
  id: totrans-744
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们创建 `nationalParks` 数组时，我们通过添加冒号（:）和 [String] ➋ 来指定我们正在创建一个包含字符串值的数组。此步骤在创建数组并用一个或多个值初始化时是可选的，因为
    Swift 会使用类型推断来确定你希望数组保存的数据类型。这意味着你完全可以通过以下方式创建数组：
- en: '![](Image00117.jpg)'
  id: totrans-745
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00117.jpg)'
- en: Using type inference, Swift knows we initialized this array to hold strings,
    and it can hold only strings.
  id: totrans-746
  prefs: []
  type: TYPE_NORMAL
  zh: 通过类型推断，Swift 知道我们初始化了一个只包含字符串的数组，它只能保存字符串。
- en: The list of parks that we created the array with is an example of an array *literal*
    . A literal is a value that is exactly what you see. It is not a variable or constant
    but rather just the value without a name. "Grand Canyon" is an example of a string
    literal, and 7 is an example of an integer literal. An array literal is a list
    of items contained between two square brackets and separated by commas, like ["Acadia",
    "Zion", "Grand Canyon"] ➊ .
  id: totrans-747
  prefs: []
  type: TYPE_NORMAL
  zh: 我们用来创建数组的公园列表就是一个数组*字面量*的例子。字面量是指你所看到的就是值本身。它不是一个变量或常量，而仅仅是没有名字的值。“Grand Canyon”是一个字符串字面量，7
    是一个整数字面量。数组字面量是一个项目列表，这些项目被两个方括号括起来，并用逗号分隔，例如 `["Acadia", "Zion", "Grand Canyon"]`
    ➊。
- en: '**ACCESSING ITEMS IN AN ARRAY**'
  id: totrans-748
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**访问数组中的项目**'
- en: 'Let’s say you want to access an item in your array and use it in your program.
    Your friend asks you to tell them all about your travels, so you want to use the
    names of the national parks that you stored in the array. To access an item in
    your array, write the array name followed by the item’s index inside square brackets:'
  id: totrans-749
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你想访问数组中的一个项目并在程序中使用它。你的朋友让你告诉他们你所有的旅行经历，所以你想使用你存储在数组中的国家公园名称。要访问数组中的项目，只需写出数组名称，后跟方括号中的项目索引：
- en: '![](Image00118.jpg)'
  id: totrans-750
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00118.jpg)'
- en: In this example, we are accessing the names of the national parks and then printing
    them to the screen using print . To get the first item in nationalParks , you
    use nationalParks[0] ➊ . To access the second item in nationalParks , you use
    nationalParks[1] .
  id: totrans-751
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们访问国家公园的名称，然后使用 `print` 将它们打印到屏幕上。要获取 `nationalParks` 中的第一个项目，你可以使用
    `nationalParks[0]` ➊。要访问 `nationalParks` 中的第二个项目，你可以使用 `nationalParks[1]`。
- en: '**WATCHING THE RANGE**'
  id: totrans-752
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**监控范围**'
- en: One important point about arrays is that if you try to access an item at an
    index that’s higher than the last index in the array, you’ll get an error. In
    [Figure 6-2](text00016.html#ch06fig2) , you can see that nationalParks[3] (which
    would be the fourth item in the array) gives you an error because there are only
    three national parks in the array, indexed from 0 to 2.
  id: totrans-753
  prefs: []
  type: TYPE_NORMAL
  zh: 关于数组的一个重要事项是，如果你尝试访问一个超过数组最后一个索引的项目，你会得到一个错误。在[图 6-2](text00016.html#ch06fig2)中，你可以看到
    `nationalParks[3]`（这应该是数组中的第四个项目）会给你一个错误，因为数组中只有三个国家公园，索引从 0 到 2。
- en: As you can see, you get an error message that says Index out of range . If you
    try to access an item that doesn’t exist in your array, your app will crash!
  id: totrans-754
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，你会得到一个错误消息，提示“索引超出范围”。如果你尝试访问数组中不存在的项目，你的应用程序会崩溃！
- en: '![Image](Image00119.jpg)'
  id: totrans-755
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00119.jpg)'
- en: '*Figure 6-2: Trying to access an index in the array where nothing exists causes
    an error.*'
  id: totrans-756
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 6-2：尝试访问数组中不存在的索引会导致错误。*'
- en: '**ADDING ITEMS TO AN ARRAY**'
  id: totrans-757
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**向数组添加项目**'
- en: One way to change an array is to add new items to it. There are a few different
    ways to do this, so let’s take a look at each.
  id: totrans-758
  prefs: []
  type: TYPE_NORMAL
  zh: 更改数组的一种方法是向其中添加新项目。有几种不同的方法可以做到这一点，让我们来看看每种方法。
- en: 'First, you can use an array’s append(_:) method. *Append* means to add something.
    Using append(_:) , you can add one new item to the end of your array. Say you
    go on another trip and visit the Badlands, and you want to add it to your list
    of national parks. To do that, add this code into your playground:'
  id: totrans-759
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，你可以使用数组的 `append(_:)` 方法。*Append* 意味着添加某些东西。使用 `append(_:)`，你可以将一个新项目添加到数组的末尾。假设你去旅行并参观了《坏地国家公园》，你想将它添加到你的国家公园列表中。为此，你可以在
    Playground 中添加以下代码：
- en: '![](Image00120.jpg)'
  id: totrans-760
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00120.jpg)'
- en: To use the append(_:) method, first write the name of your array followed by
    a period and then append . Then, put the item you want to add to your array inside
    the parentheses. In this case, you put "Badlands" inside the parentheses.
  id: totrans-761
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用 `append(_:)` 方法，首先写出你的数组名称，后跟一个句点，然后是 `append`。接着，将你要添加到数组中的项目放入括号内。在这种情况下，你将“Badlands”放入括号内。
- en: 'If you want to add something at a specific place in your array, use the array’s
    insert(_:at:) method instead. This method takes two arguments: the item that you
    want to insert and the index of where it should go in the array. (We’ll discuss
    arguments in more detail in [Chapter 7](text00017.html#ch07) .)'
  id: totrans-762
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想在数组的特定位置添加元素，使用数组的insert(_:at:)方法。这方法需要两个参数：你想插入的元素和它应该插入数组中的索引位置。（我们将在[第7章](text00017.html#ch07)中详细讨论参数。）
- en: 'Let’s say you totally forgot that you went to the Petrified Forest right after
    you visited the Grand Canyon, and you want to update your nationalParks array
    so it displays the parks in the order in which you visited them. To update your
    array, you could use the insert(_:at:) method to put the Petrified Forest in the
    right position:'
  id: totrans-763
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你完全忘记了自己在参观完大峡谷后去过化石森林，而你想更新你的nationalParks数组，使其按照你访问的顺序显示公园。要更新数组，你可以使用insert(_:at:)方法，将化石森林放到正确的位置：
- en: '![](Image00121.jpg)'
  id: totrans-764
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00121.jpg)'
- en: When you insert a new item at index 3, everything that was in the array at index
    3 or higher gets scooted over to make room for the new item. That means the item
    that was at index 3 is now at index 4, the item that was at index 4 is now at
    index 5, and so on. After you add the Petrified Forest, nationalParks is now ["Acadia",
    "Zion", "Grand Canyon", "Petrified Forest", "Badlands"] .
  id: totrans-765
  prefs: []
  type: TYPE_NORMAL
  zh: 当你在索引3处插入一个新元素时，原本在索引3或更高位置的所有元素都会向后移动，为新元素腾出空间。这意味着原本在索引3处的元素将移到索引4，原本在索引4处的元素将移到索引5，以此类推。在你添加了化石森林后，nationalParks数组现在是["Acadia",
    "Zion", "Grand Canyon", "Petrified Forest", "Badlands"]。
- en: '**COMBINING ARRAYS**'
  id: totrans-766
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**合并数组**'
- en: 'Not only can you add new items to an array, but you can also add two arrays
    together using the + and += operators. Let’s say that you have the ingredients
    for a fruit smoothie in two arrays:'
  id: totrans-767
  prefs: []
  type: TYPE_NORMAL
  zh: 你不仅可以向数组中添加新元素，还可以使用+和+=运算符将两个数组连接在一起。假设你有两个数组，分别包含制作水果果昔的原料：
- en: '![](Image00122.jpg)'
  id: totrans-768
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00122.jpg)'
- en: Now you can make a delicious smoothie by adding the fruits and liquids arrays.
  id: totrans-769
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你可以通过将水果和液体数组添加在一起，制作一杯美味的果昔。
- en: '![](Image00123.jpg)'
  id: totrans-770
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00123.jpg)'
- en: The order of the ingredients in smoothie is the same as the order in fruits
    and liquids . If you created smoothie with liquids + fruits , then the liquids
    would come first.
  id: totrans-771
  prefs: []
  type: TYPE_NORMAL
  zh: 果昔中原料的顺序与水果和液体数组中的顺序相同。如果你是用液体+水果的顺序来创建果昔，那么液体会先出现。
- en: 'You use the += operator to add an array to the end of your array. Add some
    whipped cream as follows for extra yumminess:'
  id: totrans-772
  prefs: []
  type: TYPE_NORMAL
  zh: 你使用+=运算符将一个数组添加到另一个数组的末尾。为了增加额外的美味，可以按如下方式添加一些鲜奶油：
- en: '![](Image00124.jpg)'
  id: totrans-773
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00124.jpg)'
- en: Note that ["whipped cream"] is an array even though it has a single item in
    it. When you’re using += to append something to an array, you have to make sure
    you’re only trying to add another array. If you were to just write the string
    "whipped cream" without the square brackets around it, you would get an error.
  id: totrans-774
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，即使["whipped cream"]数组中只有一个元素，它仍然是一个数组。当你使用+=将某些内容追加到数组时，必须确保你只是在添加另一个数组。如果你只是写出字符串"whipped
    cream"而没有加上方括号，就会出现错误。
- en: '![Image](Image00125.jpg)'
  id: totrans-775
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00125.jpg)'
- en: '**REMOVING ITEMS FROM AN ARRAY**'
  id: totrans-776
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**从数组中移除元素**'
- en: 'There are several methods for removing items from an array. Let’s start by
    looking at the array’s removeLast() method. As you might have guessed from its
    name, removeLast() removes the last item from your array. Let’s try it out with
    a shoppingList array:'
  id: totrans-777
  prefs: []
  type: TYPE_NORMAL
  zh: 有几种方法可以从数组中移除元素。让我们首先看看数组的removeLast()方法。顾名思义，removeLast()方法移除数组中的最后一个元素。让我们用一个shoppingList数组来试一下：
- en: '![](Image00126.jpg)'
  id: totrans-778
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00126.jpg)'
- en: Neat! Note that the removeLast() method returns the removed item, so you can
    store it in a new constant or variable if you want.
  id: totrans-779
  prefs: []
  type: TYPE_NORMAL
  zh: 真棒！注意，removeLast()方法返回已移除的元素，因此，如果需要，你可以将它存储在一个新的常量或变量中。
- en: 'You can also remove an item from a specific index by using the remove(at:)
    method. Let’s say that your mom doesn’t want you buying any candy and takes that
    off the list:'
  id: totrans-780
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以使用remove(at:)方法从特定索引移除元素。假设你妈妈不希望你买糖果，并从列表中将其移除：
- en: '![Image](Image00127.jpg)![](Image00128.jpg)'
  id: totrans-781
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00127.jpg)![](Image00128.jpg)'
- en: Just like when we added an item to the middle of our array and all the items
    scooted over to make room, if you remove an item from the middle of an array,
    the rest of the items will scoot back to fill in that empty space. The "apples"
    item that was at index 3 is now at index 2, where "candy" was.
  id: totrans-782
  prefs: []
  type: TYPE_NORMAL
  zh: 就像我们向数组中间添加元素时，所有元素都会移动以腾出空间一样，如果你从数组的中间移除一个元素，其余的元素将会移动回来填补这个空位。原本在索引3处的"apples"元素现在位于索引2的位置，原本在索引2处的"candy"元素被移除了。
- en: 'You can also remove all items from an array with removeAll() . Try entering
    this into your playground:'
  id: totrans-783
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以使用 removeAll() 从数组中移除所有项。尝试在你的 playground 中输入以下内容：
- en: '![](Image00129.jpg)'
  id: totrans-784
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00129.jpg)'
- en: 'Note that trying to remove an item at an index that doesn’t exist will give
    you an error:'
  id: totrans-785
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，尝试删除一个不存在索引位置的项会抛出错误：
- en: '![](Image00130.jpg)'
  id: totrans-786
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00130.jpg)'
- en: Our array doesn’t have this many items (in fact, now it’s empty!), so this throws
    an error. We’ll also get an error if we use removeLast() on our empty array, because
    there’s nothing in it—there’s no last index at all! However, removeAll() is always
    safe to use, even on an empty array.
  id: totrans-787
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的数组没有这么多项（实际上，现在它是空的！），因此会抛出错误。如果我们在空数组上使用 removeLast()，也会出现错误，因为数组里什么也没有——根本没有最后一个索引！然而，removeAll()
    总是可以安全使用，即使在空数组上也是如此。
- en: '**REPLACING ITEMS IN AN ARRAY**'
  id: totrans-788
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**替换数组中的项**'
- en: 'To replace an item in an array, you set the index of the array to the new value,
    as shown here:'
  id: totrans-789
  prefs: []
  type: TYPE_NORMAL
  zh: 要替换数组中的项，你可以将数组的索引设置为新值，如下所示：
- en: '![](Image00131.jpg)'
  id: totrans-790
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00131.jpg)'
- en: At ➊ , we replaced the item at index 2 (the third item) with "Unicorn" because
    magical animals count as favorite animals, too! At ➋ , we replaced the item at
    index 0 (the first item) with "Bearded dragon" . No, that’s not a real dragon—it’s
    just a lizard!
  id: totrans-791
  prefs: []
  type: TYPE_NORMAL
  zh: 在 ➊ 处，我们将索引 2（第三项）位置的项替换为 "Unicorn"，因为魔法动物也算作最喜欢的动物！在 ➋ 处，我们将索引 0（第一项）位置的项替换为
    "Bearded dragon"。不，那不是一条真正的龙——它只是一个蜥蜴！
- en: Like any time you’re working with array index numbers, you have to be sure an
    item exists in the array at that index before you change its value, or you will
    get an Index out of range error.
  id: totrans-792
  prefs: []
  type: TYPE_NORMAL
  zh: 就像任何时候你在处理数组索引时，你必须确保在修改值之前该索引位置上有一个项，否则会出现“索引超出范围”的错误。
- en: '[Figure 6-3](text00016.html#ch06fig3) shows the error that occurs if you try
    to add "Standard poodle" using favoriteAnimals[3] = "Standard poodle" . To add
    an item to the end of an array, you should use the append(_:) method or += , as
    we covered in “[Adding Items to an Array](text00016.html#ch06lev2sec5) ” on [page
    70](text00016.html#page_70) .'
  id: totrans-793
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 6-3](text00016.html#ch06fig3) 显示了如果你尝试使用 favoriteAnimals[3] = "Standard
    poodle" 添加 "标准贵宾犬" 时出现的错误。要向数组的末尾添加项，你应该使用 append(_:) 方法或 +=，就像我们在 “[向数组添加项](text00016.html#ch06lev2sec5)”
    一节中讲的那样，参见 [第 70 页](text00016.html#page_70)。'
- en: '![Image](Image00132.jpg)'
  id: totrans-794
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Image00132.jpg)'
- en: '*Figure 6-3: Don’t try to replace a value at an index beyond the existing array.*'
  id: totrans-795
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 6-3：不要尝试替换超出现有数组范围的索引位置的值。*'
- en: Now you know how to change arrays however you might need to. You can add items,
    take items away, or replace items. Next, we’ll look at how to use the properties
    of arrays to find out even more information about them.
  id: totrans-796
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经知道如何根据需要修改数组。你可以添加项、移除项或替换项。接下来，我们将看看如何使用数组的属性来获取更多关于它们的信息。
- en: '![Image](Image00133.jpg)'
  id: totrans-797
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Image00133.jpg)'
- en: '**USING ARRAY PROPERTIES**'
  id: totrans-798
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**使用数组属性**'
- en: In addition to methods like append(_:) and removeLast() , arrays also have *properties*
    . An array’s properties are variables or constants that contain some information
    about the array. Two really helpful properties that you might use are the Boolean
    property isEmpty and the integer property count .
  id: totrans-799
  prefs: []
  type: TYPE_NORMAL
  zh: 除了像 append(_:) 和 removeLast() 这样的操作方法，数组还有 *属性*。数组的属性是包含数组信息的变量或常量。你可能会使用的两个非常有用的属性是布尔类型的
    isEmpty 和整数类型的 count。
- en: The isEmpty property is true or false depending on whether the array is empty,
    and the count property will tell you how many items are in that array.
  id: totrans-800
  prefs: []
  type: TYPE_NORMAL
  zh: isEmpty 属性会根据数组是否为空返回 true 或 false，而 count 属性会告诉你数组中有多少项。
- en: 'Check out how these two properties are used in the following if-else statement:'
  id: totrans-801
  prefs: []
  type: TYPE_NORMAL
  zh: 查看这两个属性如何在以下的 if-else 语句中使用：
- en: '![Image](Image00134.jpg)'
  id: totrans-802
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Image00134.jpg)'
- en: 'This if-else statement checks whether the array mySiblings is empty ➊ . If
    it is, then "I don''t have any siblings." is printed. But if there is something
    in the array, then the number of siblings that we have is printed: "I have 3 siblings."
    ➋ .'
  id: totrans-803
  prefs: []
  type: TYPE_NORMAL
  zh: 这个 if-else 语句检查数组 mySiblings 是否为空 ➊。如果为空，则输出 "我没有兄弟姐妹"。但如果数组中有内容，则输出我们有几个兄弟姐妹："我有
    3 个兄弟姐妹" ➋。
- en: '**LOOPING OVER AN ARRAY**'
  id: totrans-804
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**遍历数组**'
- en: 'Sometimes when you’re working with arrays you might want to do something to
    every item in the array. You can use a for-in loop to do that! The following code
    will print every topping in a pizzaToppings array on a separate line:'
  id: totrans-805
  prefs: []
  type: TYPE_NORMAL
  zh: 有时在处理数组时，你可能希望对数组中的每个项执行某个操作。你可以使用 for-in 循环来做到这一点！以下代码会在每一行打印 pizzaToppings
    数组中的每个配料：
- en: '![Image](Image00135.jpg)'
  id: totrans-806
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Image00135.jpg)'
- en: To write a for-in loop for the pizzaToppings array, we used the keyword for
    , followed by the constant topping , then the keyword in , and finally the name
    of our array, pizzaToppings . Then we put the statements that we want to run for
    each topping inside the braces of the for-in loop. The constant topping ➊ temporarily
    represents each pizza topping in the array as we loop through it. We could have
    chosen any name for this constant, but it’s a good idea to pick something that
    makes sense. You can see the output of this for-in loop in [Figure 6-4](text00016.html#ch06fig4)
    .
  id: totrans-807
  prefs: []
  type: TYPE_NORMAL
  zh: 为pizzaToppings数组编写for-in循环时，我们使用了关键字for，后跟常量topping，再加上关键字in，最后是我们数组的名称pizzaToppings。然后，我们将每个配料要执行的语句放入for-in循环的大括号内。常量topping
    ➊在循环过程中暂时代表数组中的每个披萨配料。我们本可以选择任何名称作为这个常量，但最好选择一个有意义的名称。你可以在[图6-4](text00016.html#ch06fig4)中看到这个for-in循环的输出。
- en: '![Image](Image00136.jpg)'
  id: totrans-808
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Image00136.jpg)'
- en: '*Figure 6-4: Output of the example for-in loop*'
  id: totrans-809
  prefs: []
  type: TYPE_NORMAL
  zh: '*图6-4：示例for-in循环的输出*'
- en: '![Image](Image00137.jpg)'
  id: totrans-810
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Image00137.jpg)'
- en: 'Using for-in loops is great for printing every value in an array. If you’re
    working with numbers, you can even use them to perform math operations on each
    item, which makes for some speedy calculations! The following code takes an array
    of numbers and calculates the square for each (the square of a number is that
    number multiplied by itself):'
  id: totrans-811
  prefs: []
  type: TYPE_NORMAL
  zh: 使用for-in循环非常适合打印数组中的每个值。如果你正在处理数字，你甚至可以用它们对每个项执行数学运算，这样可以快速进行计算！以下代码取一个数字数组，并计算每个数字的平方（一个数字的平方是该数字与自身相乘）：
- en: '![Image](Image00138.jpg)'
  id: totrans-812
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Image00138.jpg)'
- en: '[Figure 6-5](text00016.html#ch06fig5) shows the results.'
  id: totrans-813
  prefs: []
  type: TYPE_NORMAL
  zh: '[图6-5](text00016.html#ch06fig5)显示了结果。'
- en: '![Image](Image00139.jpg)'
  id: totrans-814
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Image00139.jpg)'
- en: '*Figure 6-5: Printing the squares for each number in the myNumbers array*'
  id: totrans-815
  prefs: []
  type: TYPE_NORMAL
  zh: '*图6-5：打印myNumbers数组中每个数字的平方*'
- en: '**DICTIONARIES ARE KEY!**'
  id: totrans-816
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**字典至关重要！**'
- en: A *dictionary* is also a collection of values, but instead of an ordered index,
    each value has its own *key* . Because there’s no index, the values are not stored
    in any particular order. To access values in a dictionary, you look them up by
    their key.
  id: totrans-817
  prefs: []
  type: TYPE_NORMAL
  zh: 一个*字典*也是一个值的集合，但与有序索引的数组不同，每个值都有自己的*键*。由于没有索引，值不会按特定顺序存储。要访问字典中的值，你需要通过键来查找它们。
- en: A key must be unique. You can’t have the same key more than once in the same
    dictionary. If there were two identical keys and you asked the computer to give
    you the value for one of them, the computer wouldn’t know which one to choose!
  id: totrans-818
  prefs: []
  type: TYPE_NORMAL
  zh: 每个键必须是唯一的。在同一个字典中不能有相同的键。如果有两个相同的键，并且你请求计算机给你其中一个的值，计算机就无法知道应该选择哪个键！
- en: Let’s take a look at how to make a dictionary and write keys that will help
    you find all the information you need.
  id: totrans-819
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如何创建一个字典并写入键，以帮助你找到所需的所有信息。
- en: '![Image](Image00140.jpg)'
  id: totrans-820
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Image00140.jpg)'
- en: '**INITIALIZING A DICTIONARY**'
  id: totrans-821
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**初始化字典**'
- en: 'To create and initialize a dictionary, first write var and the name of your
    dictionary. Then write the keys and corresponding values inside a pair of square
    brackets, similar to an array. Let’s create a dictionary to store the names of
    a few US states. The key for each state will be its two-letter abbreviation:'
  id: totrans-822
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建并初始化字典，首先写`var`和字典的名称。然后将键和值对写在一对方括号内，类似于数组。让我们创建一个字典来存储一些美国州的名称。每个州的键将是它的两个字母缩写：
- en: '![](Image00141.jpg)'
  id: totrans-823
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00141.jpg)'
- en: As you can see, there’s a colon between each key and its value, and the key/value
    pairs are separated by commas.
  id: totrans-824
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，每个键和它的值之间有一个冒号，键/值对之间用逗号分隔。
- en: Dictionaries are different from arrays in that they are *unordered* . Because
    of that, it’s likely that the order of the states that you see in your results
    pane ➋ is different from the order in which you entered your states ➊ . It might
    even be different than the order that’s printed in this book!
  id: totrans-825
  prefs: []
  type: TYPE_NORMAL
  zh: 字典与数组的不同之处在于它们是*无序*的。因此，你在结果窗格中看到的状态顺序➋可能与输入状态的顺序➊不同，甚至可能与本书中打印的顺序不同！
- en: As with arrays, you can use var to make a mutable dictionary or use let to make
    an immutable dictionary.
  id: totrans-826
  prefs: []
  type: TYPE_NORMAL
  zh: 和数组一样，你可以使用`var`来创建一个可变字典，或者使用`let`来创建一个不可变字典。
- en: 'In Swift, all of the keys of a dictionary must be the same type, and all of
    the values of a dictionary must also be the same type, but the key type doesn’t
    have to match the value type. For example, if you wanted to store a collection
    of fractions, you could use doubles for the keys and strings for the values:'
  id: totrans-827
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Swift 中，字典的所有键必须是相同类型的，字典的所有值也必须是相同类型的，但键的类型不必与值的类型相匹配。例如，如果你想存储一组分数，你可以使用双精度浮点数作为键，字符串作为值：
- en: '![](Image00142.jpg)'
  id: totrans-828
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00142.jpg)'
- en: In this dictionary, all of the keys must be doubles, and all of the values must
    be strings. Again, you’ll see that the order of the numbers in the results pane
    can be quite different from the order in which you wrote the fractions in your
    dictionary. This is fine because you don’t need to know the order to access anything.
    You can find any item that you need by its key. Let’s see how!
  id: totrans-829
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个字典中，所有的键必须是双精度浮点数，所有的值必须是字符串。同样，你会发现结果面板中数字的顺序可能与字典中你写的分数顺序大不相同。这是可以的，因为你不需要知道顺序就能访问任何内容。你可以通过键找到任何你需要的项。让我们看看怎么做！
- en: '**ACCESSING VALUES IN A DICTIONARY**'
  id: totrans-830
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**访问字典中的值**'
- en: 'Looking up a value in a dictionary is similar to how you access a value in
    an array except that you use a key inside the square brackets instead of an index,
    like this: usStates["TX"] .'
  id: totrans-831
  prefs: []
  type: TYPE_NORMAL
  zh: 在字典中查找一个值类似于在数组中访问一个值，不同之处在于你使用的是方括号中的键，而不是索引，像这样：usStates["TX"]。
- en: There is a big difference, however, in how Swift returns the values from a dictionary.
    When you access a value at an index of an array, you are simply given the value.
    When you access a value with a key in a dictionary, you are given an optional.
  id: totrans-832
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，Swift 在返回字典中的值时有一个很大的不同。当你在数组中访问一个索引的值时，你会直接得到这个值。而当你使用字典中的键访问值时，你会得到一个可选值。
- en: In [Chapter 5](text00015.html#ch05) , you learned that optionals might contain
    a value or might be nil . The reason Swift returns optionals when you’re looking
    up items in a dictionary is that the key you used might not exist in the dictionary,
    in which case there’s no value to access. Trying to access a value that doesn’t
    exist would give you a big fat error! To avoid that problem, Swift returns optionals.
    That means you need to unwrap any value you get out of a dictionary before you
    can do anything with it.
  id: totrans-833
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第 5 章](text00015.html#ch05)中，你学到过可选值可能包含一个值，也可能是 nil。Swift 返回可选值的原因是，当你在字典中查找项时，使用的键可能在字典中不存在，在这种情况下没有值可以访问。试图访问一个不存在的值会导致一个大错误！为避免这个问题，Swift
    返回可选值。这意味着你需要解包从字典中获取的任何值，才能对其进行处理。
- en: 'To unwrap an optional, first you check whether it exists using an if-let statement,
    just like we did in [Chapter 5](text00015.html#ch05) . The following code shows
    you how to get a value out of a dictionary:'
  id: totrans-834
  prefs: []
  type: TYPE_NORMAL
  zh: 要解包一个可选值，首先你需要使用 if-let 语句检查它是否存在，就像我们在[第 5 章](text00015.html#ch05)中做的那样。以下代码展示了如何从字典中获取一个值：
- en: '![Image](Image00143.jpg)'
  id: totrans-835
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00143.jpg)'
- en: To retrieve "Texas" from the dictionary, we use if let to set a constant loneStarState
    to usStates["TX"] ➊ . Because we have this state in our dictionary, the line I
    have Texas in my dictionary. is printed. Next we try to access a state that is
    not in our dictionary by using the key usStates["FL"] ➋ . Thankfully, because
    we used an if-let statement, the program won’t crash when the computer can’t find
    this state. Instead, I don't have that state in my dictionary. is printed.
  id: totrans-836
  prefs: []
  type: TYPE_NORMAL
  zh: 要从字典中检索 "Texas"，我们使用 if let 将常量 loneStarState 设置为 usStates["TX"] ➊。因为我们在字典中有这个州，所以会打印出
    "I have Texas in my dictionary."。接下来我们尝试访问一个不在字典中的州，使用键 usStates["FL"] ➋。幸运的是，由于我们使用了
    if-let 语句，当计算机无法找到该州时，程序不会崩溃。相反，会打印出 "I don't have that state in my dictionary."。
- en: '**ADDING ITEMS TO A DICTIONARY**'
  id: totrans-837
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**向字典中添加项**'
- en: 'To add an item to a dictionary, first write the name of your dictionary and
    assign the new item to the key you want it to have in the dictionary. Let’s add
    "Minnesota" to our usStates dictionary:'
  id: totrans-838
  prefs: []
  type: TYPE_NORMAL
  zh: 要向字典中添加一个项，首先写下字典的名称，并将新项分配给你希望它在字典中拥有的键。我们来向 usStates 字典中添加 "Minnesota"：
- en: '![](Image00144.jpg)'
  id: totrans-839
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00144.jpg)'
- en: 'Now when you look at usStates , you’ll see that it’s updated to ["MN": "Minnesota",
    "WA": "Washington", "MA": "Massachusetts", "TX": "Texas"] . Remember, because
    you don’t have to rely on indices, your new dictionary item might appear anywhere
    in the dictionary.'
  id: totrans-840
  prefs: []
  type: TYPE_NORMAL
  zh: '现在当你查看 usStates 时，你会看到它已经更新为 ["MN": "Minnesota", "WA": "Washington", "MA":
    "Massachusetts", "TX": "Texas"]。记住，由于你不必依赖索引，你的新字典项可能出现在字典的任何位置。'
- en: '**REMOVING ITEMS FROM A DICTIONARY**'
  id: totrans-841
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**从字典中移除项**'
- en: Removing an item from a dictionary is quite simple; you do so by setting the
    value to nil . Because the values in dictionaries are returned as optionals, you
    don’t have to worry about nil causing any problems in your dictionary.
  id: totrans-842
  prefs: []
  type: TYPE_NORMAL
  zh: 从字典中移除一个项是非常简单的；你只需将该值设置为 nil。因为字典中的值是作为可选值返回的，所以你不必担心 nil 会在字典中引发任何问题。
- en: '![](Image00145.jpg)'
  id: totrans-843
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00145.jpg)'
- en: 'You can see that after you remove the value at the key "MA" , usStates is updated
    to ["MN": "Minnesota", "WA": "Washington", "TX": "Texas"] . Remember that nil
    is special and means that there’s no value at all. That’s why you don’t see "MA":
    nil in our dictionary.'
  id: totrans-844
  prefs: []
  type: TYPE_NORMAL
  zh: '你可以看到，在移除 "MA" 键对应的值之后，usStates 被更新为 ["MN": "Minnesota", "WA": "Washington",
    "TX": "Texas"]。记住，nil 是特殊的，它意味着根本没有值。这就是为什么在我们的字典中你没有看到 "MA": nil。'
- en: '**REPLACING ITEMS IN A DICTIONARY**'
  id: totrans-845
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**替换字典中的项**'
- en: 'Replacing an item in a dictionary is also easy. It works the same was as replacing
    an item in an array. You just set the item that you want to replace to something
    else. Say you create a dictionary of fruit colors:'
  id: totrans-846
  prefs: []
  type: TYPE_NORMAL
  zh: 替换字典中的项也很简单。它的工作方式和替换数组中的项一样。你只需将要替换的项设置为其他值。例如，你创建了一个水果颜色的字典：
- en: '![](Image00146.jpg)'
  id: totrans-847
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00146.jpg)'
- en: At first we had the value "apple" for "red" , but then we decided that "raspberry"
    is a better fruit to use since sometimes apples are green or yellow. To replace
    "apple" with "raspberry" , we set colorFruits["red"] to its new value ➊ .
  id: totrans-848
  prefs: []
  type: TYPE_NORMAL
  zh: 一开始我们为 "red" 设置了值 "apple"，但后来我们决定使用 "raspberry" 作为更好的水果，因为有时候苹果是绿色或黄色的。为了将 "apple"
    替换为 "raspberry"，我们将 colorFruits["red"] 设置为它的新值 ➊。
- en: You may remember that this is the same way we entered a new value into a dictionary.
    If the key already exists in the dictionary, then the value for that key is replaced.
    If the key doesn’t already exist, then the new key/value pair will be added to
    the dictionary.
  id: totrans-849
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能还记得，这就是我们将新值插入字典的方法。如果键已经存在于字典中，那么该键的值将被替换。如果键不存在，新的键/值对将被添加到字典中。
- en: '![Image](Image00147.jpg)'
  id: totrans-850
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00147.jpg)'
- en: '**USING DICTIONARY PROPERTIES**'
  id: totrans-851
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**使用字典属性**'
- en: 'Like an array, a dictionary also has an isEmpty property and a count property.
    For example, the following code shows how you can use the isEmpty property to
    check if a dictionary is empty, and if it isn’t empty, the count property checks
    how many items you have. Imagine you have a basket of fruit for sale. You can
    use these properties to help you keep track of everything:'
  id: totrans-852
  prefs: []
  type: TYPE_NORMAL
  zh: 像数组一样，字典也有 isEmpty 属性和 count 属性。例如，以下代码展示了如何使用 isEmpty 属性来检查字典是否为空，如果字典不为空，count
    属性则可以检查你有多少个项目。想象一下，你有一个出售水果的篮子。你可以使用这些属性来帮助你跟踪所有的水果：
- en: '![Image](Image00148.jpg)'
  id: totrans-853
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00148.jpg)'
- en: 'A dictionary also has two special properties: keys , which contains all of
    the dictionary’s keys, and values , which contains all of its values. We’ll use
    these two properties when we loop through the dictionary.'
  id: totrans-854
  prefs: []
  type: TYPE_NORMAL
  zh: 字典还有两个特殊的属性：keys，包含字典中所有的键；以及 values，包含字典中所有的值。在遍历字典时，我们将使用这两个属性。
- en: Let’s write some code that loops through our fruit baskets and prints the price
    of each fruit.
  id: totrans-855
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们写一些代码，遍历我们的水果篮子并打印每种水果的价格。
- en: '**LOOPING OVER A DICTIONARY**'
  id: totrans-856
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**遍历字典**'
- en: 'You can loop through a dictionary using a for-in loop. Because each item has
    a key and a value, you can do this in two different ways. This is how to loop
    through a dictionary using its keys:'
  id: totrans-857
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用 for-in 循环遍历字典。因为每一项都有一个键和值，所以你可以通过两种不同的方式来实现。以下是如何通过字典的键来遍历字典：
- en: '![Image](Image00149.jpg)'
  id: totrans-858
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00149.jpg)'
- en: Here we use the dictionary’s keys property ➊ to loop through fruitBasket and
    print its contents. We start by writing the keyword for , followed by a constant
    name fruit for the dictionary key, the keyword in , the dictionary name, a period,
    and keys .
  id: totrans-859
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们使用字典的 keys 属性 ➊ 来遍历 fruitBasket 并打印其内容。我们首先写出关键字 for，后跟字典键的常量名 fruit，接着是关键字
    in，字典名称，句点，最后是 keys。
- en: Inside the braces of our for-in loop, we have access to both the key, which
    we call fruit ➋ , and the value at that key when we force-unwrap its contents
    with fruitBasket[fruit]! ➌ . That value will be the fruit’s price.
  id: totrans-860
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的 for-in 循环的花括号内部，我们可以访问到键（我们称之为 fruit ➋）以及该键对应的值，当我们通过 `fruitBasket[fruit]!`
    强制解包时 ➌。这个值将是水果的价格。
- en: In this case, it’s safe to force-unwrap the value using an exclamation point
    because we know that the fruit key we’re using is definitely inside the dictionary.
  id: totrans-861
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，使用感叹号强制解包该值是安全的，因为我们知道正在使用的水果键肯定在字典中。
- en: Any code we put inside the for-in loop will run once for every key in our dictionary.
    So you should see the print statement display three times.
  id: totrans-862
  prefs: []
  type: TYPE_NORMAL
  zh: 我们放入for-in循环中的任何代码都会在字典的每个键上运行一次。所以你应该会看到打印语句显示三次。
- en: 'We can also loop through the dictionary using its values property:'
  id: totrans-863
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以通过字典的values属性来循环：
- en: '![Image](Image00150.jpg)'
  id: totrans-864
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00150.jpg)'
- en: We use the same style of for-in loop, but now we use a constant to refer to
    each value, which we call price , in the values property. When looping through
    values, we don’t have access to the keys from inside the loop.
  id: totrans-865
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用相同风格的for-in循环，但现在我们使用一个常量来引用values属性中的每个值，我们称其为price。在循环遍历值时，我们无法从循环内访问键。
- en: Another difference to note is that price is not an optional because it’s accessed
    directly as a value in the fruitBasket dictionary. That means we don’t have to
    unwrap it. You should still see the print statement printed three times. [Figure
    6-6](text00016.html#ch06fig6) shows the output of both loops.
  id: totrans-866
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个需要注意的区别是，price不是可选类型，因为它是直接作为fruitBasket字典中的值访问的。这意味着我们不需要解包它。你仍然应该看到打印语句显示三次。[图6-6](text00016.html#ch06fig6)展示了两种循环的输出。
- en: '![Image](Image00151.jpg)'
  id: totrans-867
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00151.jpg)'
- en: '*Figure 6-6: Looping through the keys and values of a dictionary with a for-in
    loop*'
  id: totrans-868
  prefs: []
  type: TYPE_NORMAL
  zh: '*图6-6：通过for-in循环遍历字典的键和值*'
- en: The order of your results might be slightly different from ours. That’s because
    the items in a dictionary aren’t in a numbered order like they are in an array!
    And because the order is not guaranteed, you might see a different order printed
    if you run the same code again.
  id: totrans-869
  prefs: []
  type: TYPE_NORMAL
  zh: 你的结果顺序可能与我们的稍有不同。这是因为字典中的项目不像数组那样按编号顺序排列！而且由于顺序无法保证，如果你再次运行相同的代码，可能会看到不同的打印顺序。
- en: '**WHAT YOU LEARNED**'
  id: totrans-870
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**你学到了什么**'
- en: In this chapter, you learned how to store collections of items in an array and
    in a dictionary. To store items in an ordered list, you would use an array and
    look up each item by its index. If you wanted to store items by key instead, you
    would use a dictionary.
  id: totrans-871
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你学习了如何将项目存储在数组和字典中。为了将项目存储在一个有序列表中，你可以使用数组，并通过索引查找每个项目。如果你想按键存储项目，则应使用字典。
- en: Knowing about arrays and dictionaries and how to use them is a powerful building
    block for almost any programming language. Next we will learn about functions,
    another very powerful tool. Functions are blocks of code that you create and name
    to perform a specific job. After you have written a function, you can use its
    name to call it from almost anywhere in your program.
  id: totrans-872
  prefs: []
  type: TYPE_NORMAL
  zh: 了解数组和字典以及如何使用它们是几乎所有编程语言中强大的构建块。接下来，我们将学习函数，另一个非常强大的工具。函数是你创建并命名的代码块，用来执行特定的任务。在你编写了一个函数后，可以通过其名称从程序中的几乎任何地方调用它。
- en: When you write a grocery list, you usually start with the number 1, but in computer
    programming, an index starts at 0, not 1\. So the first item in an array is always
    at index 0, the second item is at index 1, the third item is at index 2, and so
    on.
  id: totrans-873
  prefs: []
  type: TYPE_NORMAL
  zh: 当你写购物清单时，通常会从数字1开始，但在计算机编程中，索引从0开始，而不是1。所以数组中的第一个项目总是在索引0处，第二个项目在索引1处，第三个项目在索引2处，依此类推。
- en: 'Let’s create an array. If you already know what you’re going to put into your
    array, you can create it and *initialize* it with those values. To initialize
    something in Swift is to give it some initial value so you can use it in your
    program. Let’s say that you want to store a list of all of the national parks
    that you’ve visited. Enter the following into your playground:'
  id: totrans-874
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一个数组。如果你已经知道要放入数组的内容，你可以创建它并用这些值进行*初始化*。在Swift中初始化某个内容是指给它一个初始值，以便你可以在程序中使用它。假设你想存储你访问过的所有国家公园的列表，在你的playground中输入以下内容：
- en: '![](Image00114.jpg)'
  id: totrans-875
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00114.jpg)'
- en: This code creates an array variable called nationalParks and initializes it
    with the names of three national parks. Because we initialized this array to hold
    strings, you’ll only be able to put strings in it.
  id: totrans-876
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码创建了一个名为nationalParks的数组变量，并用三个国家公园的名称对其进行初始化。因为我们初始化了这个数组来保存字符串，所以你只能在其中放入字符串。
- en: '[Figure 6-1](text00016.html#ch06fig1) shows how you can imagine your array.
    It’s like a row of boxes containing the three names of national parks at indices
    0, 1, and 2\. Remember that the indices of an array always start at 0!'
  id: totrans-877
  prefs: []
  type: TYPE_NORMAL
  zh: '[图6-1](text00016.html#ch06fig1)展示了你如何想象你的数组。它就像一排盒子，包含了位于索引0、1和2的三个国家公园的名称。记住，数组的索引总是从0开始！'
- en: '![Image](Image00115.jpg)'
  id: totrans-878
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00115.jpg)'
- en: '*Figure 6-1: The nationalParks array*'
  id: totrans-879
  prefs: []
  type: TYPE_NORMAL
  zh: '*图6-1：nationalParks数组*'
- en: '**USING MUTABLE AND IMMUTABLE ARRAYS**'
  id: totrans-880
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**使用可变和不可变数组**'
- en: Our nationalParks array is a variable because we created it with the var keyword
    ➊ . An array stored in a variable is called a *mutable* array. This means that
    you can change it by adding items, removing items, or swapping items in and out.
  id: totrans-881
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的 nationalParks 数组是一个变量，因为我们使用 `var` 关键字创建了它 ➊。存储在变量中的数组被称为 *可变* 数组。这意味着你可以通过添加、删除或交换元素来更改它。
- en: You can also create an *immutable* array. An immutable array is created with
    the keyword let instead of var . Similar to a constant, once an immutable array
    is created, nothing in it can be changed.
  id: totrans-882
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以创建一个 *不可变* 数组。不可变数组是使用 `let` 关键字创建的，而不是 `var`。与常量类似，一旦不可变数组被创建，它的内容就无法更改。
- en: So when should you use a mutable array or an immutable array? It’s best to use
    let if you know your collection will never change, like if you’re storing the
    colors of the rainbow. You should use var if you need to change your collection,
    like if you’re storing an array of your favorite T-shirts, which might change
    depending on what’s in style!
  id: totrans-883
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，什么时候应该使用可变数组或不可变数组呢？如果你知道你的集合永远不会改变，例如存储彩虹的颜色，最好使用 `let`。如果你需要改变集合，例如存储你最喜欢的
    T 恤的数组，可能会随着时尚变化而变化，那么应该使用 `var`！
- en: '![Image](Image00116.jpg)'
  id: totrans-884
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00116.jpg)'
- en: '**USING TYPE INFERENCE**'
  id: totrans-885
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**使用类型推断**'
- en: 'When we created our nationalParks array, we specified that we were creating
    an array of string values by adding a colon (: ) and [String] ➋ . This step is
    optional when you create an array and initialize it with one or more values because
    Swift will use type inference to determine the kind of data you want the array
    to hold. That means that you could just as easily have created the array by doing
    this:'
  id: totrans-886
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们创建 nationalParks 数组时，我们指定了创建一个字符串类型的数组，通过添加冒号（:）和 [String] ➋。当你创建数组并用一个或多个值初始化它时，这一步是可选的，因为
    Swift 会使用类型推断来确定你想让数组包含的数据类型。这意味着你也可以通过以下方式创建该数组：
- en: '![](Image00117.jpg)'
  id: totrans-887
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00117.jpg)'
- en: Using type inference, Swift knows we initialized this array to hold strings,
    and it can hold only strings.
  id: totrans-888
  prefs: []
  type: TYPE_NORMAL
  zh: 使用类型推断，Swift 知道我们初始化了这个数组来保存字符串，并且它只能包含字符串。
- en: The list of parks that we created the array with is an example of an array *literal*
    . A literal is a value that is exactly what you see. It is not a variable or constant
    but rather just the value without a name. "Grand Canyon" is an example of a string
    literal, and 7 is an example of an integer literal. An array literal is a list
    of items contained between two square brackets and separated by commas, like ["Acadia",
    "Zion", "Grand Canyon"] ➊ .
  id: totrans-889
  prefs: []
  type: TYPE_NORMAL
  zh: 我们用来创建数组的公园列表是数组 *字面量* 的一个例子。字面量是一个值，它正是你看到的内容。它不是变量或常量，而是没有名称的值。"Grand Canyon"
    是一个字符串字面量，7 是一个整数字面量。数组字面量是由两个方括号括起来并用逗号分隔的项列表，例如 ["Acadia", "Zion", "Grand Canyon"]
    ➊。
- en: '**ACCESSING ITEMS IN AN ARRAY**'
  id: totrans-890
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**访问数组中的元素**'
- en: 'Let’s say you want to access an item in your array and use it in your program.
    Your friend asks you to tell them all about your travels, so you want to use the
    names of the national parks that you stored in the array. To access an item in
    your array, write the array name followed by the item’s index inside square brackets:'
  id: totrans-891
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你想访问数组中的一个元素并在程序中使用它。你的朋友要求你告诉他们关于你旅行的所有信息，因此你想使用存储在数组中的国家公园的名字。要访问数组中的一个元素，你需要写出数组名称，然后在方括号中写出该元素的索引：
- en: '![](Image00118.jpg)'
  id: totrans-892
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00118.jpg)'
- en: In this example, we are accessing the names of the national parks and then printing
    them to the screen using print . To get the first item in nationalParks , you
    use nationalParks[0] ➊ . To access the second item in nationalParks , you use
    nationalParks[1] .
  id: totrans-893
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们正在访问国家公园的名字，然后使用 `print` 将它们打印到屏幕上。要获取 nationalParks 中的第一个元素，你使用 nationalParks[0]
    ➊。要访问 nationalParks 中的第二个元素，你使用 nationalParks[1]。
- en: '**WATCHING THE RANGE**'
  id: totrans-894
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**观察范围**'
- en: One important point about arrays is that if you try to access an item at an
    index that’s higher than the last index in the array, you’ll get an error. In
    [Figure 6-2](text00016.html#ch06fig2) , you can see that nationalParks[3] (which
    would be the fourth item in the array) gives you an error because there are only
    three national parks in the array, indexed from 0 to 2.
  id: totrans-895
  prefs: []
  type: TYPE_NORMAL
  zh: 关于数组的一个重要点是，如果你尝试访问一个索引大于数组中最后一个索引的元素，你将得到一个错误。在 [图 6-2](text00016.html#ch06fig2)
    中，你可以看到 nationalParks[3]（这将是数组中的第四个元素）会给出错误，因为数组中只有三个国家公园，索引从 0 到 2。
- en: As you can see, you get an error message that says Index out of range . If you
    try to access an item that doesn’t exist in your array, your app will crash!
  id: totrans-896
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，你会收到一个错误信息，提示 "Index out of range"。如果你试图访问一个数组中不存在的元素，程序会崩溃！
- en: '![Image](Image00119.jpg)'
  id: totrans-897
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00119.jpg)'
- en: '*Figure 6-2: Trying to access an index in the array where nothing exists causes
    an error.*'
  id: totrans-898
  prefs: []
  type: TYPE_NORMAL
  zh: '*图6-2：尝试访问数组中不存在的索引会导致错误。*'
- en: '**ADDING ITEMS TO AN ARRAY**'
  id: totrans-899
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**向数组添加元素**'
- en: One way to change an array is to add new items to it. There are a few different
    ways to do this, so let’s take a look at each.
  id: totrans-900
  prefs: []
  type: TYPE_NORMAL
  zh: 改变数组的一种方法是向其中添加新元素。这里有几种不同的方法，接下来我们逐一来看。
- en: 'First, you can use an array’s append(_:) method. *Append* means to add something.
    Using append(_:) , you can add one new item to the end of your array. Say you
    go on another trip and visit the Badlands, and you want to add it to your list
    of national parks. To do that, add this code into your playground:'
  id: totrans-901
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，你可以使用数组的 append(_:) 方法。*Append* 意味着添加。使用 append(_:) 方法，你可以将一个新元素添加到数组的末尾。假设你又去旅行了，参观了
    Badlands，你想把它添加到国家公园的列表中。为此，你可以在 Playground 中添加以下代码：
- en: '![](Image00120.jpg)'
  id: totrans-902
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00120.jpg)'
- en: To use the append(_:) method, first write the name of your array followed by
    a period and then append . Then, put the item you want to add to your array inside
    the parentheses. In this case, you put "Badlands" inside the parentheses.
  id: totrans-903
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用 append(_:) 方法，首先写下数组的名称，后面加一个句点，然后是 append。接着，将你要添加到数组中的元素放到括号内。在这个例子中，你将
    "Badlands" 放到括号内。
- en: 'If you want to add something at a specific place in your array, use the array’s
    insert(_:at:) method instead. This method takes two arguments: the item that you
    want to insert and the index of where it should go in the array. (We’ll discuss
    arguments in more detail in [Chapter 7](text00017.html#ch07) .)'
  id: totrans-904
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想在数组的特定位置添加元素，可以改用数组的 insert(_:at:) 方法。这个方法有两个参数：你想要插入的元素和它在数组中的位置索引。（我们将在[第7章](text00017.html#ch07)中更详细地讨论参数。）
- en: 'Let’s say you totally forgot that you went to the Petrified Forest right after
    you visited the Grand Canyon, and you want to update your nationalParks array
    so it displays the parks in the order in which you visited them. To update your
    array, you could use the insert(_:at:) method to put the Petrified Forest in the
    right position:'
  id: totrans-905
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你完全忘记了在参观 Grand Canyon 后，你还去了 Petrified Forest，现在你想更新 nationalParks 数组，使其显示你参观这些公园的顺序。为了更新你的数组，你可以使用
    insert(_:at:) 方法将 Petrified Forest 放到正确的位置：
- en: '![](Image00121.jpg)'
  id: totrans-906
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00121.jpg)'
- en: When you insert a new item at index 3, everything that was in the array at index
    3 or higher gets scooted over to make room for the new item. That means the item
    that was at index 3 is now at index 4, the item that was at index 4 is now at
    index 5, and so on. After you add the Petrified Forest, nationalParks is now ["Acadia",
    "Zion", "Grand Canyon", "Petrified Forest", "Badlands"] .
  id: totrans-907
  prefs: []
  type: TYPE_NORMAL
  zh: 当你在索引 3 处插入一个新元素时，数组中索引为 3 或更大的所有元素都会被移动，以腾出位置给新元素。这意味着原本位于索引 3 的元素现在会移到索引 4，位于索引
    4 的元素会移到索引 5，以此类推。添加了 Petrified Forest 后，nationalParks 变为 ["Acadia", "Zion", "Grand
    Canyon", "Petrified Forest", "Badlands"]。
- en: '**COMBINING ARRAYS**'
  id: totrans-908
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**合并数组**'
- en: 'Not only can you add new items to an array, but you can also add two arrays
    together using the + and += operators. Let’s say that you have the ingredients
    for a fruit smoothie in two arrays:'
  id: totrans-909
  prefs: []
  type: TYPE_NORMAL
  zh: 不仅可以向数组中添加新元素，还可以使用 + 和 += 操作符将两个数组合并。假设你有两个数组，分别包含制作果昔所需的水果和液体成分：
- en: '![](Image00122.jpg)'
  id: totrans-910
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00122.jpg)'
- en: Now you can make a delicious smoothie by adding the fruits and liquids arrays.
  id: totrans-911
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你可以通过添加水果和液体数组来制作美味的果昔。
- en: '![](Image00123.jpg)'
  id: totrans-912
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00123.jpg)'
- en: The order of the ingredients in smoothie is the same as the order in fruits
    and liquids . If you created smoothie with liquids + fruits , then the liquids
    would come first.
  id: totrans-913
  prefs: []
  type: TYPE_NORMAL
  zh: 果昔中的食材顺序与水果和液体的顺序相同。如果你是用液体 + 水果来制作果昔，那么液体会排在前面。
- en: 'You use the += operator to add an array to the end of your array. Add some
    whipped cream as follows for extra yumminess:'
  id: totrans-914
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用 += 操作符将一个数组添加到另一个数组的末尾。为了增加更多的美味，可以按以下方式添加一些打发奶油：
- en: '![](Image00124.jpg)'
  id: totrans-915
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00124.jpg)'
- en: Note that ["whipped cream"] is an array even though it has a single item in
    it. When you’re using += to append something to an array, you have to make sure
    you’re only trying to add another array. If you were to just write the string
    "whipped cream" without the square brackets around it, you would get an error.
  id: totrans-916
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，["whipped cream"] 是一个数组，尽管它只有一个元素。当你使用 += 操作符向数组添加元素时，必须确保你只是尝试添加另一个数组。如果你直接写字符串
    "whipped cream" 而没有用方括号包裹它，程序会报错。
- en: '![Image](Image00125.jpg)'
  id: totrans-917
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00125.jpg)'
- en: '**REMOVING ITEMS FROM AN ARRAY**'
  id: totrans-918
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**从数组中移除项**'
- en: 'There are several methods for removing items from an array. Let’s start by
    looking at the array’s removeLast() method. As you might have guessed from its
    name, removeLast() removes the last item from your array. Let’s try it out with
    a shoppingList array:'
  id: totrans-919
  prefs: []
  type: TYPE_NORMAL
  zh: 有几种方法可以从数组中移除项。我们先来看一下数组的removeLast()方法。正如你从名称中可能猜到的，removeLast()方法会移除数组中的最后一个项。我们来试试用一个shoppingList数组：
- en: '![](Image00126.jpg)'
  id: totrans-920
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00126.jpg)'
- en: Neat! Note that the removeLast() method returns the removed item, so you can
    store it in a new constant or variable if you want.
  id: totrans-921
  prefs: []
  type: TYPE_NORMAL
  zh: 很棒！请注意，removeLast()方法会返回被移除的项，因此如果你想的话，你可以将其存储在一个新的常量或变量中。
- en: 'You can also remove an item from a specific index by using the remove(at:)
    method. Let’s say that your mom doesn’t want you buying any candy and takes that
    off the list:'
  id: totrans-922
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以通过使用remove(at:)方法从特定的索引移除项。假设你的妈妈不希望你买糖果，并将其从清单上移除：
- en: '![Image](Image00127.jpg)![](Image00128.jpg)'
  id: totrans-923
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00127.jpg)![](Image00128.jpg)'
- en: Just like when we added an item to the middle of our array and all the items
    scooted over to make room, if you remove an item from the middle of an array,
    the rest of the items will scoot back to fill in that empty space. The "apples"
    item that was at index 3 is now at index 2, where "candy" was.
  id: totrans-924
  prefs: []
  type: TYPE_NORMAL
  zh: 就像我们在数组中间添加项并且所有项向后移动以腾出空间一样，如果你从数组中间移除一项，其他项会向前移动，填补那个空缺。原本在索引3的“苹果”项现在位于索引2的位置，那里原来是“糖果”。
- en: 'You can also remove all items from an array with removeAll() . Try entering
    this into your playground:'
  id: totrans-925
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以通过removeAll()方法移除数组中的所有项。试着在你的playground中输入这个：
- en: '![](Image00129.jpg)'
  id: totrans-926
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00129.jpg)'
- en: 'Note that trying to remove an item at an index that doesn’t exist will give
    you an error:'
  id: totrans-927
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，尝试移除一个不存在的索引处的项会导致错误：
- en: '![](Image00130.jpg)'
  id: totrans-928
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00130.jpg)'
- en: Our array doesn’t have this many items (in fact, now it’s empty!), so this throws
    an error. We’ll also get an error if we use removeLast() on our empty array, because
    there’s nothing in it—there’s no last index at all! However, removeAll() is always
    safe to use, even on an empty array.
  id: totrans-929
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的数组没有这么多项（事实上，现在它是空的！），所以这会抛出一个错误。如果我们在空数组上使用removeLast()，也会出错，因为数组里什么也没有——根本没有最后一个索引！不过，removeAll()始终是安全的，即使在空数组上使用也没有问题。
- en: '**REPLACING ITEMS IN AN ARRAY**'
  id: totrans-930
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**替换数组中的项**'
- en: 'To replace an item in an array, you set the index of the array to the new value,
    as shown here:'
  id: totrans-931
  prefs: []
  type: TYPE_NORMAL
  zh: 要替换数组中的项，你可以将数组的索引设置为新值，如下所示：
- en: '![](Image00131.jpg)'
  id: totrans-932
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00131.jpg)'
- en: At ➊ , we replaced the item at index 2 (the third item) with "Unicorn" because
    magical animals count as favorite animals, too! At ➋ , we replaced the item at
    index 0 (the first item) with "Bearded dragon" . No, that’s not a real dragon—it’s
    just a lizard!
  id: totrans-933
  prefs: []
  type: TYPE_NORMAL
  zh: 在➊处，我们将索引2（第三项）的项替换为“独角兽”，因为魔法动物也算是最喜欢的动物！在➋处，我们将索引0（第一项）的项替换为“胡须龙”。不，那不是一只真正的龙——它只是一个蜥蜴！
- en: Like any time you’re working with array index numbers, you have to be sure an
    item exists in the array at that index before you change its value, or you will
    get an Index out of range error.
  id: totrans-934
  prefs: []
  type: TYPE_NORMAL
  zh: 就像你在处理数组索引时一样，在更改项的值之前，必须确保该索引处有项存在，否则会出现“索引超出范围”错误。
- en: '[Figure 6-3](text00016.html#ch06fig3) shows the error that occurs if you try
    to add "Standard poodle" using favoriteAnimals[3] = "Standard poodle" . To add
    an item to the end of an array, you should use the append(_:) method or += , as
    we covered in “[Adding Items to an Array](text00016.html#ch06lev2sec5) ” on [page
    70](text00016.html#page_70) .'
  id: totrans-935
  prefs: []
  type: TYPE_NORMAL
  zh: '[图6-3](text00016.html#ch06fig3)展示了如果你尝试通过favoriteAnimals[3] = "标准贵宾犬"来添加“标准贵宾犬”时会发生的错误。要将一项添加到数组的末尾，你应该使用append(_:)方法或+=，我们在“[向数组添加项](text00016.html#ch06lev2sec5)”的[第70页](text00016.html#page_70)中已经讲解过了。'
- en: '![Image](Image00132.jpg)'
  id: totrans-936
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00132.jpg)'
- en: '*Figure 6-3: Don’t try to replace a value at an index beyond the existing array.*'
  id: totrans-937
  prefs: []
  type: TYPE_NORMAL
  zh: '*图6-3：不要尝试替换超出现有数组索引的值。*'
- en: Now you know how to change arrays however you might need to. You can add items,
    take items away, or replace items. Next, we’ll look at how to use the properties
    of arrays to find out even more information about them.
  id: totrans-938
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你知道如何根据需要更改数组了。你可以添加项、移除项或替换项。接下来，我们将看看如何使用数组的属性来了解更多关于它们的信息。
- en: '![Image](Image00133.jpg)'
  id: totrans-939
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00133.jpg)'
- en: '**USING ARRAY PROPERTIES**'
  id: totrans-940
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**使用数组属性**'
- en: In addition to methods like append(_:) and removeLast() , arrays also have *properties*
    . An array’s properties are variables or constants that contain some information
    about the array. Two really helpful properties that you might use are the Boolean
    property isEmpty and the integer property count .
  id: totrans-941
  prefs: []
  type: TYPE_NORMAL
  zh: 除了像 `append(_:)` 和 `removeLast()` 这样的方法，数组还有 *属性*。数组的属性是包含数组相关信息的变量或常量。你可能会用到的两个非常有用的属性是布尔值属性
    `isEmpty` 和整数属性 `count`。
- en: The isEmpty property is true or false depending on whether the array is empty,
    and the count property will tell you how many items are in that array.
  id: totrans-942
  prefs: []
  type: TYPE_NORMAL
  zh: '`isEmpty` 属性根据数组是否为空来返回 `true` 或 `false`，而 `count` 属性则会告诉你数组中有多少个元素。'
- en: 'Check out how these two properties are used in the following if-else statement:'
  id: totrans-943
  prefs: []
  type: TYPE_NORMAL
  zh: 查看下面这个 if-else 语句中如何使用这两个属性：
- en: '![Image](Image00134.jpg)'
  id: totrans-944
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00134.jpg)'
- en: 'This if-else statement checks whether the array mySiblings is empty ➊ . If
    it is, then "I don''t have any siblings." is printed. But if there is something
    in the array, then the number of siblings that we have is printed: "I have 3 siblings."
    ➋ .'
  id: totrans-945
  prefs: []
  type: TYPE_NORMAL
  zh: 这个 if-else 语句检查数组 `mySiblings` 是否为空 ➊。如果为空，那么打印 "我没有兄弟姐妹。"。但如果数组中有内容，那么将打印我们有多少个兄弟姐妹："我有
    3 个兄弟姐妹。" ➋。
- en: '**LOOPING OVER AN ARRAY**'
  id: totrans-946
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**循环遍历数组**'
- en: 'Sometimes when you’re working with arrays you might want to do something to
    every item in the array. You can use a for-in loop to do that! The following code
    will print every topping in a pizzaToppings array on a separate line:'
  id: totrans-947
  prefs: []
  type: TYPE_NORMAL
  zh: 有时在处理数组时，你可能想对数组中的每个项执行某些操作。你可以使用 for-in 循环来做到这一点！以下代码将把 `pizzaToppings` 数组中的每个配料打印到单独的一行：
- en: '![Image](Image00135.jpg)'
  id: totrans-948
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00135.jpg)'
- en: To write a for-in loop for the pizzaToppings array, we used the keyword for
    , followed by the constant topping , then the keyword in , and finally the name
    of our array, pizzaToppings . Then we put the statements that we want to run for
    each topping inside the braces of the for-in loop. The constant topping ➊ temporarily
    represents each pizza topping in the array as we loop through it. We could have
    chosen any name for this constant, but it’s a good idea to pick something that
    makes sense. You can see the output of this for-in loop in [Figure 6-4](text00016.html#ch06fig4)
    .
  id: totrans-949
  prefs: []
  type: TYPE_NORMAL
  zh: 为了编写一个针对 `pizzaToppings` 数组的 for-in 循环，我们使用了关键字 `for`，接着是常量 `topping`，然后是关键字
    `in`，最后是我们数组的名称 `pizzaToppings`。接着我们将希望在每个 topping 上运行的语句放入 for-in 循环的大括号内。常量
    `topping` ➊ 临时代表我们循环遍历的数组中的每一个披萨配料。我们本可以为这个常量选择任何名称，但选择一个有意义的名字是个好主意。你可以在 [图 6-4](text00016.html#ch06fig4)
    中看到这个 for-in 循环的输出。
- en: '![Image](Image00136.jpg)'
  id: totrans-950
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00136.jpg)'
- en: '*Figure 6-4: Output of the example for-in loop*'
  id: totrans-951
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 6-4：示例 for-in 循环的输出*'
- en: '![Image](Image00137.jpg)'
  id: totrans-952
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00137.jpg)'
- en: 'Using for-in loops is great for printing every value in an array. If you’re
    working with numbers, you can even use them to perform math operations on each
    item, which makes for some speedy calculations! The following code takes an array
    of numbers and calculates the square for each (the square of a number is that
    number multiplied by itself):'
  id: totrans-953
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 for-in 循环非常适合打印数组中的每个值。如果你正在处理数字，你甚至可以用它们对每个项执行数学运算，这样就能进行快速计算！以下代码接受一个数字数组并计算每个数字的平方（一个数字的平方是该数字与自身相乘）：
- en: '![Image](Image00138.jpg)'
  id: totrans-954
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00138.jpg)'
- en: '[Figure 6-5](text00016.html#ch06fig5) shows the results.'
  id: totrans-955
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 6-5](text00016.html#ch06fig5) 显示了结果。'
- en: '![Image](Image00139.jpg)'
  id: totrans-956
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00139.jpg)'
- en: '*Figure 6-5: Printing the squares for each number in the myNumbers array*'
  id: totrans-957
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 6-5：打印 `myNumbers` 数组中每个数字的平方*'
- en: '**DICTIONARIES ARE KEY!**'
  id: totrans-958
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**字典很重要！**'
- en: A *dictionary* is also a collection of values, but instead of an ordered index,
    each value has its own *key* . Because there’s no index, the values are not stored
    in any particular order. To access values in a dictionary, you look them up by
    their key.
  id: totrans-959
  prefs: []
  type: TYPE_NORMAL
  zh: '*字典* 也是一个值的集合，但与有序索引不同，每个值都有自己的 *键*。因为没有索引，值没有特定的存储顺序。要访问字典中的值，你需要通过它们的键来查找。'
- en: A key must be unique. You can’t have the same key more than once in the same
    dictionary. If there were two identical keys and you asked the computer to give
    you the value for one of them, the computer wouldn’t know which one to choose!
  id: totrans-960
  prefs: []
  type: TYPE_NORMAL
  zh: 键必须是唯一的。在同一个字典中，不能有相同的键。如果存在两个相同的键，而你要求计算机返回其中一个的值，那么计算机会不知道该选择哪个！
- en: Let’s take a look at how to make a dictionary and write keys that will help
    you find all the information you need.
  id: totrans-961
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看如何创建一个字典，并编写帮助你找到所需所有信息的键。
- en: '![Image](Image00140.jpg)'
  id: totrans-962
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00140.jpg)'
- en: '**INITIALIZING A DICTIONARY**'
  id: totrans-963
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**初始化字典**'
- en: 'To create and initialize a dictionary, first write var and the name of your
    dictionary. Then write the keys and corresponding values inside a pair of square
    brackets, similar to an array. Let’s create a dictionary to store the names of
    a few US states. The key for each state will be its two-letter abbreviation:'
  id: totrans-964
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建并初始化字典，首先写上 var 和字典的名称。然后在一对方括号内写上键和值对，类似于数组。我们来创建一个字典，用来存储一些美国州的名称。每个州的键将是它的两字母缩写：
- en: '![](Image00141.jpg)'
  id: totrans-965
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00141.jpg)'
- en: As you can see, there’s a colon between each key and its value, and the key/value
    pairs are separated by commas.
  id: totrans-966
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，键和值之间有一个冒号，键值对之间用逗号分隔。
- en: Dictionaries are different from arrays in that they are *unordered* . Because
    of that, it’s likely that the order of the states that you see in your results
    pane ➋ is different from the order in which you entered your states ➊ . It might
    even be different than the order that’s printed in this book!
  id: totrans-967
  prefs: []
  type: TYPE_NORMAL
  zh: 字典与数组不同，因为它们是*无序的*。因此，你在结果窗格中看到的状态顺序➋很可能与输入状态的顺序➊不同。甚至可能与本书中打印的顺序不同！
- en: As with arrays, you can use var to make a mutable dictionary or use let to make
    an immutable dictionary.
  id: totrans-968
  prefs: []
  type: TYPE_NORMAL
  zh: 与数组类似，你可以使用 var 来创建可变字典，或者使用 let 来创建不可变字典。
- en: 'In Swift, all of the keys of a dictionary must be the same type, and all of
    the values of a dictionary must also be the same type, but the key type doesn’t
    have to match the value type. For example, if you wanted to store a collection
    of fractions, you could use doubles for the keys and strings for the values:'
  id: totrans-969
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Swift 中，字典的所有键必须是相同类型的，字典的所有值也必须是相同类型的，但键类型不必与值类型匹配。例如，如果你想存储一组分数，你可以使用双精度浮点数作为键，字符串作为值：
- en: '![](Image00142.jpg)'
  id: totrans-970
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00142.jpg)'
- en: In this dictionary, all of the keys must be doubles, and all of the values must
    be strings. Again, you’ll see that the order of the numbers in the results pane
    can be quite different from the order in which you wrote the fractions in your
    dictionary. This is fine because you don’t need to know the order to access anything.
    You can find any item that you need by its key. Let’s see how!
  id: totrans-971
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个字典中，所有的键必须是双精度浮点数，所有的值必须是字符串。再说一次，你会发现结果窗格中的数字顺序可能与在字典中写入分数的顺序完全不同。这是可以接受的，因为你不需要知道顺序就能访问任何内容。你可以通过键找到你需要的任何项。我们来看看如何操作！
- en: '**ACCESSING VALUES IN A DICTIONARY**'
  id: totrans-972
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**访问字典中的值**'
- en: 'Looking up a value in a dictionary is similar to how you access a value in
    an array except that you use a key inside the square brackets instead of an index,
    like this: usStates["TX"] .'
  id: totrans-973
  prefs: []
  type: TYPE_NORMAL
  zh: 在字典中查找一个值类似于访问数组中的值，只不过你需要在方括号中使用键，而不是索引，像这样：usStates["TX"]。
- en: There is a big difference, however, in how Swift returns the values from a dictionary.
    When you access a value at an index of an array, you are simply given the value.
    When you access a value with a key in a dictionary, you are given an optional.
  id: totrans-974
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在 Swift 中返回字典值的方式有很大不同。当你访问数组中的一个索引时，你只是得到那个值。而当你用一个键访问字典中的值时，你得到的是一个可选值。
- en: In [Chapter 5](text00015.html#ch05) , you learned that optionals might contain
    a value or might be nil . The reason Swift returns optionals when you’re looking
    up items in a dictionary is that the key you used might not exist in the dictionary,
    in which case there’s no value to access. Trying to access a value that doesn’t
    exist would give you a big fat error! To avoid that problem, Swift returns optionals.
    That means you need to unwrap any value you get out of a dictionary before you
    can do anything with it.
  id: totrans-975
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第5章](text00015.html#ch05)中，你学到了可选值可能包含一个值，或者可能是 nil。Swift 在查找字典项时返回可选值的原因是你使用的键可能不存在于字典中，这种情况下没有值可访问。尝试访问一个不存在的值会导致一个严重的错误！为了避免这个问题，Swift
    返回可选值。这意味着你在对字典中的任何值进行操作之前需要解包它。
- en: 'To unwrap an optional, first you check whether it exists using an if-let statement,
    just like we did in [Chapter 5](text00015.html#ch05) . The following code shows
    you how to get a value out of a dictionary:'
  id: totrans-976
  prefs: []
  type: TYPE_NORMAL
  zh: 要解包一个可选值，首先你需要使用 if-let 语句检查它是否存在，就像我们在[第5章](text00015.html#ch05)中做的那样。以下代码展示了如何从字典中获取一个值：
- en: '![Image](Image00143.jpg)'
  id: totrans-977
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00143.jpg)'
- en: To retrieve "Texas" from the dictionary, we use if let to set a constant loneStarState
    to usStates["TX"] ➊ . Because we have this state in our dictionary, the line I
    have Texas in my dictionary. is printed. Next we try to access a state that is
    not in our dictionary by using the key usStates["FL"] ➋ . Thankfully, because
    we used an if-let statement, the program won’t crash when the computer can’t find
    this state. Instead, I don't have that state in my dictionary. is printed.
  id: totrans-978
  prefs: []
  type: TYPE_NORMAL
  zh: 要从字典中检索"Texas"，我们使用if let将常量loneStarState设置为usStates["TX"] ➊。因为我们在字典中有这个州，所以会打印出“我在我的字典中有Texas。”接下来，我们尝试通过使用键usStates["FL"]
    ➋访问一个不在字典中的州。幸运的是，因为我们使用了if-let语句，当计算机找不到这个州时，程序不会崩溃。相反，会打印出“我在字典中没有这个州。”
- en: '**ADDING ITEMS TO A DICTIONARY**'
  id: totrans-979
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**向字典添加项**'
- en: 'To add an item to a dictionary, first write the name of your dictionary and
    assign the new item to the key you want it to have in the dictionary. Let’s add
    "Minnesota" to our usStates dictionary:'
  id: totrans-980
  prefs: []
  type: TYPE_NORMAL
  zh: 要向字典添加一项，首先写下字典的名称，并将新项分配给你希望它在字典中具有的键。让我们将"Minneapolis"添加到我们的usStates字典中：
- en: '![](Image00144.jpg)'
  id: totrans-981
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00144.jpg)'
- en: 'Now when you look at usStates , you’ll see that it’s updated to ["MN": "Minnesota",
    "WA": "Washington", "MA": "Massachusetts", "TX": "Texas"] . Remember, because
    you don’t have to rely on indices, your new dictionary item might appear anywhere
    in the dictionary.'
  id: totrans-982
  prefs: []
  type: TYPE_NORMAL
  zh: '现在当你查看usStates时，你会看到它已更新为["MN": "Minnesota", "WA": "Washington", "MA": "Massachusetts",
    "TX": "Texas"]。记住，因为你不需要依赖索引，你的新字典项可能出现在字典中的任何位置。'
- en: '**REMOVING ITEMS FROM A DICTIONARY**'
  id: totrans-983
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**从字典中移除项**'
- en: Removing an item from a dictionary is quite simple; you do so by setting the
    value to nil . Because the values in dictionaries are returned as optionals, you
    don’t have to worry about nil causing any problems in your dictionary.
  id: totrans-984
  prefs: []
  type: TYPE_NORMAL
  zh: 从字典中移除一项非常简单；你只需要将值设置为nil。由于字典中的值以可选值返回，因此你不必担心nil会在字典中引发任何问题。
- en: '![](Image00145.jpg)'
  id: totrans-985
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00145.jpg)'
- en: 'You can see that after you remove the value at the key "MA" , usStates is updated
    to ["MN": "Minnesota", "WA": "Washington", "TX": "Texas"] . Remember that nil
    is special and means that there’s no value at all. That’s why you don’t see "MA":
    nil in our dictionary.'
  id: totrans-986
  prefs: []
  type: TYPE_NORMAL
  zh: '你可以看到，在你移除键"MA"的值后，usStates更新为["MN": "Minnesota", "WA": "Washington", "TX":
    "Texas"]。记住，nil是特别的，表示根本没有值。这就是为什么你在我们的字典中看不到"MA": nil。'
- en: '**REPLACING ITEMS IN A DICTIONARY**'
  id: totrans-987
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**替换字典中的项**'
- en: 'Replacing an item in a dictionary is also easy. It works the same was as replacing
    an item in an array. You just set the item that you want to replace to something
    else. Say you create a dictionary of fruit colors:'
  id: totrans-988
  prefs: []
  type: TYPE_NORMAL
  zh: 替换字典中的项也很简单。它的工作方式与替换数组中的项相同。你只需将要替换的项设置为其他值。假设你创建了一个水果颜色的字典：
- en: '![](Image00146.jpg)'
  id: totrans-989
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00146.jpg)'
- en: At first we had the value "apple" for "red" , but then we decided that "raspberry"
    is a better fruit to use since sometimes apples are green or yellow. To replace
    "apple" with "raspberry" , we set colorFruits["red"] to its new value ➊ .
  id: totrans-990
  prefs: []
  type: TYPE_NORMAL
  zh: 起初我们为"red"赋值为"apple"，但后来我们决定"raspberry"是更好的水果，因为有时苹果是绿色或黄色的。要用"raspberry"替换"apple"，我们将colorFruits["red"]设置为它的新值
    ➊。
- en: You may remember that this is the same way we entered a new value into a dictionary.
    If the key already exists in the dictionary, then the value for that key is replaced.
    If the key doesn’t already exist, then the new key/value pair will be added to
    the dictionary.
  id: totrans-991
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能记得，这与我们将新值输入字典的方式相同。如果该键已经存在于字典中，那么该键的值将被替换。如果该键不存在，那么新的键/值对将被添加到字典中。
- en: '![Image](Image00147.jpg)'
  id: totrans-992
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00147.jpg)'
- en: '**USING DICTIONARY PROPERTIES**'
  id: totrans-993
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**使用字典属性**'
- en: 'Like an array, a dictionary also has an isEmpty property and a count property.
    For example, the following code shows how you can use the isEmpty property to
    check if a dictionary is empty, and if it isn’t empty, the count property checks
    how many items you have. Imagine you have a basket of fruit for sale. You can
    use these properties to help you keep track of everything:'
  id: totrans-994
  prefs: []
  type: TYPE_NORMAL
  zh: 和数组一样，字典也有isEmpty属性和count属性。例如，以下代码展示了你如何使用isEmpty属性检查字典是否为空，如果不为空，count属性则检查你有多少项。假设你有一个水果篮出售，你可以使用这些属性帮助你跟踪所有物品：
- en: '![Image](Image00148.jpg)'
  id: totrans-995
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00148.jpg)'
- en: 'A dictionary also has two special properties: keys , which contains all of
    the dictionary’s keys, and values , which contains all of its values. We’ll use
    these two properties when we loop through the dictionary.'
  id: totrans-996
  prefs: []
  type: TYPE_NORMAL
  zh: 字典还有两个特殊的属性：keys，它包含字典的所有键，和values，它包含所有的值。我们将在遍历字典时使用这两个属性。
- en: Let’s write some code that loops through our fruit baskets and prints the price
    of each fruit.
  id: totrans-997
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们写一些代码，遍历我们的水果篮并打印每种水果的价格。
- en: '**LOOPING OVER A DICTIONARY**'
  id: totrans-998
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**遍历字典**'
- en: 'You can loop through a dictionary using a for-in loop. Because each item has
    a key and a value, you can do this in two different ways. This is how to loop
    through a dictionary using its keys:'
  id: totrans-999
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用for-in循环遍历字典。因为每个项目都有一个键和一个值，所以你可以用两种不同的方式来实现。下面是通过字典的键来遍历字典的方法：
- en: '![Image](Image00149.jpg)'
  id: totrans-1000
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00149.jpg)'
- en: Here we use the dictionary’s keys property ➊ to loop through fruitBasket and
    print its contents. We start by writing the keyword for , followed by a constant
    name fruit for the dictionary key, the keyword in , the dictionary name, a period,
    and keys .
  id: totrans-1001
  prefs: []
  type: TYPE_NORMAL
  zh: 这里我们使用字典的keys属性➊来遍历fruitBasket并打印它的内容。我们首先写出关键字for，然后是字典键的常量名fruit，接着是关键字in，字典名称，句点和keys。
- en: Inside the braces of our for-in loop, we have access to both the key, which
    we call fruit ➋ , and the value at that key when we force-unwrap its contents
    with fruitBasket[fruit]! ➌ . That value will be the fruit’s price.
  id: totrans-1002
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们for-in循环的大括号内，我们可以访问键（我们称之为fruit➋）和该键的值，当我们通过fruitBasket[fruit]!强制解包其内容时➌。这个值将是水果的价格。
- en: In this case, it’s safe to force-unwrap the value using an exclamation point
    because we know that the fruit key we’re using is definitely inside the dictionary.
  id: totrans-1003
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，使用感叹号强制解包值是安全的，因为我们知道我们使用的fruit键肯定在字典中。
- en: Any code we put inside the for-in loop will run once for every key in our dictionary.
    So you should see the print statement display three times.
  id: totrans-1004
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在for-in循环中放入的任何代码都会为字典中的每个键执行一次。所以你应该看到打印语句显示三次。
- en: 'We can also loop through the dictionary using its values property:'
  id: totrans-1005
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以使用字典的values属性来遍历字典：
- en: '![Image](Image00150.jpg)'
  id: totrans-1006
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00150.jpg)'
- en: We use the same style of for-in loop, but now we use a constant to refer to
    each value, which we call price , in the values property. When looping through
    values, we don’t have access to the keys from inside the loop.
  id: totrans-1007
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用相同类型的for-in循环，但现在我们使用常量来引用每个值，我们称之为price，在values属性中。当遍历值时，我们无法从循环内部访问键。
- en: Another difference to note is that price is not an optional because it’s accessed
    directly as a value in the fruitBasket dictionary. That means we don’t have to
    unwrap it. You should still see the print statement printed three times. [Figure
    6-6](text00016.html#ch06fig6) shows the output of both loops.
  id: totrans-1008
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个需要注意的区别是，price不是一个可选值，因为它是直接作为fruitBasket字典中的值来访问的。这意味着我们不需要解包它。你仍然应该看到打印语句打印三次。[图6-6](text00016.html#ch06fig6)展示了两个循环的输出。
- en: '![Image](Image00151.jpg)'
  id: totrans-1009
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00151.jpg)'
- en: '*Figure 6-6: Looping through the keys and values of a dictionary with a for-in
    loop*'
  id: totrans-1010
  prefs: []
  type: TYPE_NORMAL
  zh: '*图6-6：使用for-in循环遍历字典的键和值*'
- en: The order of your results might be slightly different from ours. That’s because
    the items in a dictionary aren’t in a numbered order like they are in an array!
    And because the order is not guaranteed, you might see a different order printed
    if you run the same code again.
  id: totrans-1011
  prefs: []
  type: TYPE_NORMAL
  zh: 你的结果顺序可能与我们的稍有不同。这是因为字典中的项目不像数组那样按编号顺序排列！而且由于顺序不能保证，如果你再次运行相同的代码，你可能会看到不同的顺序。
- en: '**WHAT YOU LEARNED**'
  id: totrans-1012
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**你学到了什么**'
- en: In this chapter, you learned how to store collections of items in an array and
    in a dictionary. To store items in an ordered list, you would use an array and
    look up each item by its index. If you wanted to store items by key instead, you
    would use a dictionary.
  id: totrans-1013
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一章中，你学习了如何将项目存储在数组和字典中。要将项目存储在有序列表中，你可以使用数组并通过索引查找每个项目。如果你想按键存储项目，则应使用字典。
- en: Knowing about arrays and dictionaries and how to use them is a powerful building
    block for almost any programming language. Next we will learn about functions,
    another very powerful tool. Functions are blocks of code that you create and name
    to perform a specific job. After you have written a function, you can use its
    name to call it from almost anywhere in your program.
  id: totrans-1014
  prefs: []
  type: TYPE_NORMAL
  zh: 了解数组和字典以及如何使用它们是几乎任何编程语言中的一个强大构建块。接下来我们将学习函数，另一个非常强大的工具。函数是你创建并命名的代码块，用于执行特定的任务。在你编写了一个函数后，你可以通过它的名称在程序中的几乎任何地方调用它。
- en: 'Let’s create an array. If you already know what you’re going to put into your
    array, you can create it and *initialize* it with those values. To initialize
    something in Swift is to give it some initial value so you can use it in your
    program. Let’s say that you want to store a list of all of the national parks
    that you’ve visited. Enter the following into your playground:'
  id: totrans-1015
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一个数组。如果你已经知道要放入数组的内容，你可以创建它并用这些值进行*初始化*。在 Swift 中，初始化是指给某个对象赋予初始值，以便你在程序中使用它。假设你想要存储你访问过的所有国家公园的列表。请输入以下内容到你的
    playground：
- en: '![](Image00114.jpg)'
  id: totrans-1016
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00114.jpg)'
- en: This code creates an array variable called nationalParks and initializes it
    with the names of three national parks. Because we initialized this array to hold
    strings, you’ll only be able to put strings in it.
  id: totrans-1017
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码创建了一个名为 nationalParks 的数组变量，并用三个国家公园的名称初始化它。因为我们初始化这个数组来存储字符串，所以你只能在其中放入字符串。
- en: '[Figure 6-1](text00016.html#ch06fig1) shows how you can imagine your array.
    It’s like a row of boxes containing the three names of national parks at indices
    0, 1, and 2\. Remember that the indices of an array always start at 0!'
  id: totrans-1018
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 6-1](text00016.html#ch06fig1)展示了你可以如何想象你的数组。它就像一排包含国家公园名称的盒子，分别位于索引 0、1
    和 2。记住，数组的索引总是从 0 开始！'
- en: '![Image](Image00115.jpg)'
  id: totrans-1019
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00115.jpg)'
- en: '*Figure 6-1: The nationalParks array*'
  id: totrans-1020
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 6-1：nationalParks 数组*'
- en: '**USING MUTABLE AND IMMUTABLE ARRAYS**'
  id: totrans-1021
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**使用可变数组和不可变数组**'
- en: Our nationalParks array is a variable because we created it with the var keyword
    ➊ . An array stored in a variable is called a *mutable* array. This means that
    you can change it by adding items, removing items, or swapping items in and out.
  id: totrans-1022
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的 nationalParks 数组是一个变量，因为我们使用 var 关键字创建了它 ➊。存储在变量中的数组称为*可变*数组。这意味着你可以通过添加、删除或交换其中的项来更改它。
- en: You can also create an *immutable* array. An immutable array is created with
    the keyword let instead of var . Similar to a constant, once an immutable array
    is created, nothing in it can be changed.
  id: totrans-1023
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以创建一个*不可变*数组。不可变数组是使用关键字 let 创建的，而不是 var。与常量类似，一旦创建了不可变数组，它里面的内容就无法更改。
- en: So when should you use a mutable array or an immutable array? It’s best to use
    let if you know your collection will never change, like if you’re storing the
    colors of the rainbow. You should use var if you need to change your collection,
    like if you’re storing an array of your favorite T-shirts, which might change
    depending on what’s in style!
  id: totrans-1024
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，什么时候应该使用可变数组或不可变数组呢？如果你知道你的集合永远不会改变，例如你正在存储彩虹的颜色，最好使用let。如果你需要更改集合，比如你存储的是你最喜欢的T恤的数组，可能会随着流行趋势的变化而改变，那就应该使用var！
- en: '![Image](Image00116.jpg)'
  id: totrans-1025
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00116.jpg)'
- en: '**USING TYPE INFERENCE**'
  id: totrans-1026
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**使用类型推断**'
- en: 'When we created our nationalParks array, we specified that we were creating
    an array of string values by adding a colon (: ) and [String] ➋ . This step is
    optional when you create an array and initialize it with one or more values because
    Swift will use type inference to determine the kind of data you want the array
    to hold. That means that you could just as easily have created the array by doing
    this:'
  id: totrans-1027
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们创建 nationalParks 数组时，我们通过添加冒号（:）和 [String] ➋ 指定了创建一个字符串类型的数组。当你创建一个数组并用一个或多个值初始化它时，这一步是可选的，因为
    Swift 会使用类型推断来确定你希望数组存储的数据类型。这意味着你也可以通过如下方式创建数组：
- en: '![](Image00117.jpg)'
  id: totrans-1028
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00117.jpg)'
- en: Using type inference, Swift knows we initialized this array to hold strings,
    and it can hold only strings.
  id: totrans-1029
  prefs: []
  type: TYPE_NORMAL
  zh: 使用类型推断，Swift 知道我们初始化了这个数组来存储字符串，并且它只能存储字符串。
- en: The list of parks that we created the array with is an example of an array *literal*
    . A literal is a value that is exactly what you see. It is not a variable or constant
    but rather just the value without a name. "Grand Canyon" is an example of a string
    literal, and 7 is an example of an integer literal. An array literal is a list
    of items contained between two square brackets and separated by commas, like ["Acadia",
    "Zion", "Grand Canyon"] ➊ .
  id: totrans-1030
  prefs: []
  type: TYPE_NORMAL
  zh: 我们用来创建数组的国家公园列表是一个数组*字面量*的例子。字面量是一个值，它就是你所看到的内容。它不是变量或常量，而是没有名称的值。"Grand Canyon"
    是一个字符串字面量，7 是一个整数字面量。数组字面量是包含在两个方括号之间并用逗号分隔的项的列表，例如 ["Acadia", "Zion", "Grand
    Canyon"] ➊。
- en: '**ACCESSING ITEMS IN AN ARRAY**'
  id: totrans-1031
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**访问数组中的项**'
- en: 'Let’s say you want to access an item in your array and use it in your program.
    Your friend asks you to tell them all about your travels, so you want to use the
    names of the national parks that you stored in the array. To access an item in
    your array, write the array name followed by the item’s index inside square brackets:'
  id: totrans-1032
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你想要访问数组中的一个项目并在程序中使用它。你的朋友让你讲述你所有的旅行经历，因此你想使用你存储在数组中的国家公园名称。要访问数组中的一个项目，写出数组名称，后跟该项目的索引，索引放在方括号中：
- en: '![](Image00118.jpg)'
  id: totrans-1033
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00118.jpg)'
- en: In this example, we are accessing the names of the national parks and then printing
    them to the screen using print . To get the first item in nationalParks , you
    use nationalParks[0] ➊ . To access the second item in nationalParks , you use
    nationalParks[1] .
  id: totrans-1034
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们访问国家公园的名称，然后使用`print`将它们打印到屏幕上。要获取`nationalParks`中的第一个项目，可以使用`nationalParks[0]`
    ➊。要访问`nationalParks`中的第二个项目，可以使用`nationalParks[1]`。
- en: '**WATCHING THE RANGE**'
  id: totrans-1035
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**观看范围**'
- en: One important point about arrays is that if you try to access an item at an
    index that’s higher than the last index in the array, you’ll get an error. In
    [Figure 6-2](text00016.html#ch06fig2) , you can see that nationalParks[3] (which
    would be the fourth item in the array) gives you an error because there are only
    three national parks in the array, indexed from 0 to 2.
  id: totrans-1036
  prefs: []
  type: TYPE_NORMAL
  zh: 关于数组的一个重要事项是，如果你尝试访问一个比数组最后一个索引更高的索引，你将得到一个错误。在[图6-2](text00016.html#ch06fig2)中，你可以看到`nationalParks[3]`（即数组中的第四个项目）会导致错误，因为数组中只有三个国家公园，索引从0到2。
- en: As you can see, you get an error message that says Index out of range . If you
    try to access an item that doesn’t exist in your array, your app will crash!
  id: totrans-1037
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，你会收到一条错误消息，提示"索引超出范围"。如果你尝试访问一个在数组中不存在的项目，你的应用程序将崩溃！
- en: '![Image](Image00119.jpg)'
  id: totrans-1038
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00119.jpg)'
- en: '*Figure 6-2: Trying to access an index in the array where nothing exists causes
    an error.*'
  id: totrans-1039
  prefs: []
  type: TYPE_NORMAL
  zh: '*图6-2：尝试访问数组中不存在的索引会导致错误。*'
- en: '**ADDING ITEMS TO AN ARRAY**'
  id: totrans-1040
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**向数组添加项目**'
- en: One way to change an array is to add new items to it. There are a few different
    ways to do this, so let’s take a look at each.
  id: totrans-1041
  prefs: []
  type: TYPE_NORMAL
  zh: 更改数组的一种方法是向其中添加新项目。有几种不同的方法可以做到这一点，所以让我们看看每种方法。
- en: 'First, you can use an array’s append(_:) method. *Append* means to add something.
    Using append(_:) , you can add one new item to the end of your array. Say you
    go on another trip and visit the Badlands, and you want to add it to your list
    of national parks. To do that, add this code into your playground:'
  id: totrans-1042
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，你可以使用数组的`append(_:)`方法。*Append*意味着添加某物。使用`append(_:)`方法，你可以将一个新项目添加到数组的末尾。假设你又去了一趟旅行，参观了坏地（Badlands），并想将其添加到你的国家公园列表中。为此，将以下代码添加到你的
    Playground 中：
- en: '![](Image00120.jpg)'
  id: totrans-1043
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00120.jpg)'
- en: To use the append(_:) method, first write the name of your array followed by
    a period and then append . Then, put the item you want to add to your array inside
    the parentheses. In this case, you put "Badlands" inside the parentheses.
  id: totrans-1044
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`append(_:)`方法时，首先写出数组的名称，后面加上一个句点，然后是`append`。接着，将你想要添加到数组中的项目放在括号内。在这种情况下，你把"Badlands"放在了括号里。
- en: 'If you want to add something at a specific place in your array, use the array’s
    insert(_:at:) method instead. This method takes two arguments: the item that you
    want to insert and the index of where it should go in the array. (We’ll discuss
    arguments in more detail in [Chapter 7](text00017.html#ch07) .)'
  id: totrans-1045
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想在数组的特定位置添加某个元素，请改用数组的`insert(_:at:)`方法。此方法有两个参数：你要插入的项目和它应该放入数组中的索引。（我们将在[第7章](text00017.html#ch07)中更详细地讨论参数。）
- en: 'Let’s say you totally forgot that you went to the Petrified Forest right after
    you visited the Grand Canyon, and you want to update your nationalParks array
    so it displays the parks in the order in which you visited them. To update your
    array, you could use the insert(_:at:) method to put the Petrified Forest in the
    right position:'
  id: totrans-1046
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你完全忘记了自己在参观大峡谷后立即去了石化森林，你想更新`nationalParks`数组，以便按访问顺序显示这些公园。要更新数组，你可以使用`insert(_:at:)`方法将石化森林放到正确的位置：
- en: '![](Image00121.jpg)'
  id: totrans-1047
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00121.jpg)'
- en: When you insert a new item at index 3, everything that was in the array at index
    3 or higher gets scooted over to make room for the new item. That means the item
    that was at index 3 is now at index 4, the item that was at index 4 is now at
    index 5, and so on. After you add the Petrified Forest, nationalParks is now ["Acadia",
    "Zion", "Grand Canyon", "Petrified Forest", "Badlands"] .
  id: totrans-1048
  prefs: []
  type: TYPE_NORMAL
  zh: 当你在索引3处插入一个新项时，索引3或更高位置的所有项都会向后移动，为新项腾出空间。这意味着原本在索引3的项现在在索引4，原本在索引4的项现在在索引5，以此类推。在你添加了“化石森林”之后，`nationalParks`现在是["Acadia",
    "Zion", "Grand Canyon", "Petrified Forest", "Badlands"]。
- en: '**COMBINING ARRAYS**'
  id: totrans-1049
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**合并数组**'
- en: 'Not only can you add new items to an array, but you can also add two arrays
    together using the + and += operators. Let’s say that you have the ingredients
    for a fruit smoothie in two arrays:'
  id: totrans-1050
  prefs: []
  type: TYPE_NORMAL
  zh: 不仅可以向数组中添加新项，还可以使用`+`和`+=`运算符将两个数组合并。假设你有两个数组，分别存放果昔的水果和配料：
- en: '![](Image00122.jpg)'
  id: totrans-1051
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00122.jpg)'
- en: Now you can make a delicious smoothie by adding the fruits and liquids arrays.
  id: totrans-1052
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你可以通过将水果和液体数组结合来制作美味的果昔了。
- en: '![](Image00123.jpg)'
  id: totrans-1053
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00123.jpg)'
- en: The order of the ingredients in smoothie is the same as the order in fruits
    and liquids . If you created smoothie with liquids + fruits , then the liquids
    would come first.
  id: totrans-1054
  prefs: []
  type: TYPE_NORMAL
  zh: 在果昔中，配料的顺序与水果和液体的顺序相同。如果你先加入液体，再加入水果，那么液体会排在前面。
- en: 'You use the += operator to add an array to the end of your array. Add some
    whipped cream as follows for extra yumminess:'
  id: totrans-1055
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`+=`运算符可以将一个数组添加到另一个数组的末尾。如下所示，加入一些鲜奶油，增加额外的美味：
- en: '![](Image00124.jpg)'
  id: totrans-1056
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00124.jpg)'
- en: Note that ["whipped cream"] is an array even though it has a single item in
    it. When you’re using += to append something to an array, you have to make sure
    you’re only trying to add another array. If you were to just write the string
    "whipped cream" without the square brackets around it, you would get an error.
  id: totrans-1057
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，`["whipped cream"]`是一个数组，即使它只有一个项。当你使用`+=`将某物添加到数组时，必须确保你正在添加的是另一个数组。如果你只是写下字符串"whipped
    cream"而没有将其放在方括号内，系统会报错。
- en: '![Image](Image00125.jpg)'
  id: totrans-1058
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00125.jpg)'
- en: '**REMOVING ITEMS FROM AN ARRAY**'
  id: totrans-1059
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**从数组中移除项**'
- en: 'There are several methods for removing items from an array. Let’s start by
    looking at the array’s removeLast() method. As you might have guessed from its
    name, removeLast() removes the last item from your array. Let’s try it out with
    a shoppingList array:'
  id: totrans-1060
  prefs: []
  type: TYPE_NORMAL
  zh: 有多种方法可以从数组中移除项。让我们先看看数组的`removeLast()`方法。顾名思义，`removeLast()`方法会移除数组中的最后一项。我们可以用一个购物清单数组来试试：
- en: '![](Image00126.jpg)'
  id: totrans-1061
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00126.jpg)'
- en: Neat! Note that the removeLast() method returns the removed item, so you can
    store it in a new constant or variable if you want.
  id: totrans-1062
  prefs: []
  type: TYPE_NORMAL
  zh: 很棒！请注意，`removeLast()`方法会返回被移除的项，因此如果你需要，可以将其存储在一个新的常量或变量中。
- en: 'You can also remove an item from a specific index by using the remove(at:)
    method. Let’s say that your mom doesn’t want you buying any candy and takes that
    off the list:'
  id: totrans-1063
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以通过使用`remove(at:)`方法从特定的索引移除一个项。假设你的妈妈不想你买糖果，并将其从列表中移除：
- en: '![Image](Image00127.jpg)![](Image00128.jpg)'
  id: totrans-1064
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00127.jpg)![](Image00128.jpg)'
- en: Just like when we added an item to the middle of our array and all the items
    scooted over to make room, if you remove an item from the middle of an array,
    the rest of the items will scoot back to fill in that empty space. The "apples"
    item that was at index 3 is now at index 2, where "candy" was.
  id: totrans-1065
  prefs: []
  type: TYPE_NORMAL
  zh: 就像我们在数组中间添加项时，所有项都会向后移动为新项腾出空间一样，如果你从数组中间移除项，其余项也会向前移动填补空缺。原本在索引3的“apples”项现在会出现在索引2的位置——那里原来是“candy”。
- en: 'You can also remove all items from an array with removeAll() . Try entering
    this into your playground:'
  id: totrans-1066
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以使用`removeAll()`方法移除数组中的所有项。尝试在你的 playground 中输入以下内容：
- en: '![](Image00129.jpg)'
  id: totrans-1067
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00129.jpg)'
- en: 'Note that trying to remove an item at an index that doesn’t exist will give
    you an error:'
  id: totrans-1068
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，如果尝试从一个不存在的索引移除项，将会抛出错误：
- en: '![](Image00130.jpg)'
  id: totrans-1069
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00130.jpg)'
- en: Our array doesn’t have this many items (in fact, now it’s empty!), so this throws
    an error. We’ll also get an error if we use removeLast() on our empty array, because
    there’s nothing in it—there’s no last index at all! However, removeAll() is always
    safe to use, even on an empty array.
  id: totrans-1070
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的数组没有这么多项（事实上，它现在是空的！），所以会抛出一个错误。如果我们在空数组上使用`removeLast()`，也会报错，因为它是空的——根本没有最后一个索引！然而，`removeAll()`在任何时候都可以安全使用，即使在空数组上也是如此。
- en: '**REPLACING ITEMS IN AN ARRAY**'
  id: totrans-1071
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**替换数组中的项**'
- en: 'To replace an item in an array, you set the index of the array to the new value,
    as shown here:'
  id: totrans-1072
  prefs: []
  type: TYPE_NORMAL
  zh: 要替换数组中的项，只需将该索引位置的值设置为新的值，如下所示：
- en: '![](Image00131.jpg)'
  id: totrans-1073
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00131.jpg)'
- en: At ➊ , we replaced the item at index 2 (the third item) with "Unicorn" because
    magical animals count as favorite animals, too! At ➋ , we replaced the item at
    index 0 (the first item) with "Bearded dragon" . No, that’s not a real dragon—it’s
    just a lizard!
  id: totrans-1074
  prefs: []
  type: TYPE_NORMAL
  zh: 在 ➊ 处，我们将索引 2（第三项）的项替换为“独角兽”，因为魔法动物也算是最喜欢的动物！在 ➋ 处，我们将索引 0（第一项）的项替换为“胡须龙”。不，那不是一条真正的龙——它只是一只蜥蜴！
- en: Like any time you’re working with array index numbers, you have to be sure an
    item exists in the array at that index before you change its value, or you will
    get an Index out of range error.
  id: totrans-1075
  prefs: []
  type: TYPE_NORMAL
  zh: 就像在处理数组索引时，你必须确保数组中该索引处有项存在，才可以更改其值，否则你会遇到“索引超出范围”的错误。
- en: '[Figure 6-3](text00016.html#ch06fig3) shows the error that occurs if you try
    to add "Standard poodle" using favoriteAnimals[3] = "Standard poodle" . To add
    an item to the end of an array, you should use the append(_:) method or += , as
    we covered in “[Adding Items to an Array](text00016.html#ch06lev2sec5) ” on [page
    70](text00016.html#page_70) .'
  id: totrans-1076
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 6-3](text00016.html#ch06fig3) 显示了如果你尝试使用 favoriteAnimals[3] = "Standard
    poodle" 添加“标准贵宾犬”时会发生的错误。要向数组的末尾添加项，应该使用 append(_:) 方法或 += ，就像我们在 “[向数组添加项](text00016.html#ch06lev2sec5)”
    一节中第 [70 页](text00016.html#page_70) 讨论的那样。'
- en: '![Image](Image00132.jpg)'
  id: totrans-1077
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00132.jpg)'
- en: '*Figure 6-3: Don’t try to replace a value at an index beyond the existing array.*'
  id: totrans-1078
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 6-3：不要尝试替换超出现有数组范围的索引的值。*'
- en: Now you know how to change arrays however you might need to. You can add items,
    take items away, or replace items. Next, we’ll look at how to use the properties
    of arrays to find out even more information about them.
  id: totrans-1079
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你知道如何根据需要修改数组。你可以添加项、删除项或替换项。接下来，我们将看看如何使用数组的属性来获取更多关于它们的信息。
- en: '![Image](Image00133.jpg)'
  id: totrans-1080
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00133.jpg)'
- en: '**USING ARRAY PROPERTIES**'
  id: totrans-1081
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**使用数组属性**'
- en: In addition to methods like append(_:) and removeLast() , arrays also have *properties*
    . An array’s properties are variables or constants that contain some information
    about the array. Two really helpful properties that you might use are the Boolean
    property isEmpty and the integer property count .
  id: totrans-1082
  prefs: []
  type: TYPE_NORMAL
  zh: 除了像 append(_:) 和 removeLast() 这样的方法，数组还具有 *属性*。数组的属性是包含数组相关信息的变量或常量。有两个非常有用的属性，你可能会用到，它们分别是布尔属性
    isEmpty 和整数属性 count。
- en: The isEmpty property is true or false depending on whether the array is empty,
    and the count property will tell you how many items are in that array.
  id: totrans-1083
  prefs: []
  type: TYPE_NORMAL
  zh: isEmpty 属性的值为 true 或 false，取决于数组是否为空，而 count 属性则告诉你数组中有多少项。
- en: 'Check out how these two properties are used in the following if-else statement:'
  id: totrans-1084
  prefs: []
  type: TYPE_NORMAL
  zh: 看看这两个属性是如何在以下的 if-else 语句中使用的：
- en: '![Image](Image00134.jpg)'
  id: totrans-1085
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00134.jpg)'
- en: 'This if-else statement checks whether the array mySiblings is empty ➊ . If
    it is, then "I don''t have any siblings." is printed. But if there is something
    in the array, then the number of siblings that we have is printed: "I have 3 siblings."
    ➋ .'
  id: totrans-1086
  prefs: []
  type: TYPE_NORMAL
  zh: 这个 if-else 语句检查数组 mySiblings 是否为空 ➊。如果为空，就会打印出“我没有兄弟姐妹。”如果数组中有项，则会打印出我们有多少个兄弟姐妹：“我有
    3 个兄弟姐妹。” ➋。
- en: '**LOOPING OVER AN ARRAY**'
  id: totrans-1087
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**循环遍历数组**'
- en: 'Sometimes when you’re working with arrays you might want to do something to
    every item in the array. You can use a for-in loop to do that! The following code
    will print every topping in a pizzaToppings array on a separate line:'
  id: totrans-1088
  prefs: []
  type: TYPE_NORMAL
  zh: 有时在处理数组时，你可能想对数组中的每一项做一些操作。你可以使用 for-in 循环来做到这一点！以下代码将把 pizzaToppings 数组中的每一个配料打印到单独的一行：
- en: '![Image](Image00135.jpg)'
  id: totrans-1089
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00135.jpg)'
- en: To write a for-in loop for the pizzaToppings array, we used the keyword for
    , followed by the constant topping , then the keyword in , and finally the name
    of our array, pizzaToppings . Then we put the statements that we want to run for
    each topping inside the braces of the for-in loop. The constant topping ➊ temporarily
    represents each pizza topping in the array as we loop through it. We could have
    chosen any name for this constant, but it’s a good idea to pick something that
    makes sense. You can see the output of this for-in loop in [Figure 6-4](text00016.html#ch06fig4)
    .
  id: totrans-1090
  prefs: []
  type: TYPE_NORMAL
  zh: 要为 pizzaToppings 数组编写一个 for-in 循环，我们使用了关键字 for，后跟常量 topping，再接关键字 in，最后是数组名称
    pizzaToppings。然后，我们将要对每个配料执行的语句放在 for-in 循环的大括号中。常量 topping ➊ 临时代表数组中每个配料，随着我们循环遍历它。我们可以为这个常量选择任何名字，但最好选择一个有意义的名称。你可以在
    [图 6-4](text00016.html#ch06fig4) 中看到这个 for-in 循环的输出。
- en: '![Image](Image00136.jpg)'
  id: totrans-1091
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00136.jpg)'
- en: '*Figure 6-4: Output of the example for-in loop*'
  id: totrans-1092
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 6-4：示例 for-in 循环的输出*'
- en: '![Image](Image00137.jpg)'
  id: totrans-1093
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00137.jpg)'
- en: 'Using for-in loops is great for printing every value in an array. If you’re
    working with numbers, you can even use them to perform math operations on each
    item, which makes for some speedy calculations! The following code takes an array
    of numbers and calculates the square for each (the square of a number is that
    number multiplied by itself):'
  id: totrans-1094
  prefs: []
  type: TYPE_NORMAL
  zh: 使用for-in循环非常适合打印数组中的每个值。如果你处理的是数字，甚至可以用它们对每个项目执行数学运算，这样可以进行快速的计算！以下代码取一个数字数组，并计算每个数字的平方（一个数字的平方是该数字乘以它自己）：
- en: '![Image](Image00138.jpg)'
  id: totrans-1095
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00138.jpg)'
- en: '[Figure 6-5](text00016.html#ch06fig5) shows the results.'
  id: totrans-1096
  prefs: []
  type: TYPE_NORMAL
  zh: '[图6-5](text00016.html#ch06fig5)显示了结果。'
- en: '![Image](Image00139.jpg)'
  id: totrans-1097
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00139.jpg)'
- en: '*Figure 6-5: Printing the squares for each number in the myNumbers array*'
  id: totrans-1098
  prefs: []
  type: TYPE_NORMAL
  zh: '*图6-5：打印myNumbers数组中每个数字的平方*'
- en: '**DICTIONARIES ARE KEY!**'
  id: totrans-1099
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**字典至关重要！**'
- en: A *dictionary* is also a collection of values, but instead of an ordered index,
    each value has its own *key* . Because there’s no index, the values are not stored
    in any particular order. To access values in a dictionary, you look them up by
    their key.
  id: totrans-1100
  prefs: []
  type: TYPE_NORMAL
  zh: '*字典*也是一个值的集合，但不同于有序索引，每个值都有它自己的*键*。由于没有索引，值不会按照任何特定顺序存储。要访问字典中的值，你需要通过键来查找它们。'
- en: A key must be unique. You can’t have the same key more than once in the same
    dictionary. If there were two identical keys and you asked the computer to give
    you the value for one of them, the computer wouldn’t know which one to choose!
  id: totrans-1101
  prefs: []
  type: TYPE_NORMAL
  zh: 键必须是唯一的。你不能在同一个字典中有相同的键。如果有两个相同的键，而你要求计算机给你其中一个的值，计算机就不知道该选择哪一个！
- en: Let’s take a look at how to make a dictionary and write keys that will help
    you find all the information you need.
  id: totrans-1102
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如何创建一个字典，并编写有助于查找所有信息的键。
- en: '![Image](Image00140.jpg)'
  id: totrans-1103
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00140.jpg)'
- en: '**INITIALIZING A DICTIONARY**'
  id: totrans-1104
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**初始化字典**'
- en: 'To create and initialize a dictionary, first write var and the name of your
    dictionary. Then write the keys and corresponding values inside a pair of square
    brackets, similar to an array. Let’s create a dictionary to store the names of
    a few US states. The key for each state will be its two-letter abbreviation:'
  id: totrans-1105
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建并初始化字典，首先写上`var`和字典的名称。然后将键和值放在一对方括号内，类似于数组。让我们创建一个字典，用来存储一些美国州的名称。每个州的键将是它的两位字母缩写：
- en: '![](Image00141.jpg)'
  id: totrans-1106
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00141.jpg)'
- en: As you can see, there’s a colon between each key and its value, and the key/value
    pairs are separated by commas.
  id: totrans-1107
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，键和值之间有一个冒号，键/值对之间用逗号分隔。
- en: Dictionaries are different from arrays in that they are *unordered* . Because
    of that, it’s likely that the order of the states that you see in your results
    pane ➋ is different from the order in which you entered your states ➊ . It might
    even be different than the order that’s printed in this book!
  id: totrans-1108
  prefs: []
  type: TYPE_NORMAL
  zh: 字典与数组的不同之处在于它们是*无序的*。因此，你在结果面板 ➋ 中看到的状态顺序可能与你输入状态的顺序 ➊ 不同。它甚至可能与本书中打印的顺序不同！
- en: As with arrays, you can use var to make a mutable dictionary or use let to make
    an immutable dictionary.
  id: totrans-1109
  prefs: []
  type: TYPE_NORMAL
  zh: 与数组一样，你可以使用`var`来创建可变字典，或使用`let`来创建不可变字典。
- en: 'In Swift, all of the keys of a dictionary must be the same type, and all of
    the values of a dictionary must also be the same type, but the key type doesn’t
    have to match the value type. For example, if you wanted to store a collection
    of fractions, you could use doubles for the keys and strings for the values:'
  id: totrans-1110
  prefs: []
  type: TYPE_NORMAL
  zh: 在Swift中，字典的所有键必须是相同类型的，字典的所有值也必须是相同类型的，但键的类型不必与值的类型匹配。例如，如果你想存储一个分数集合，你可以使用浮动类型（doubles）作为键，字符串类型作为值：
- en: '![](Image00142.jpg)'
  id: totrans-1111
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00142.jpg)'
- en: In this dictionary, all of the keys must be doubles, and all of the values must
    be strings. Again, you’ll see that the order of the numbers in the results pane
    can be quite different from the order in which you wrote the fractions in your
    dictionary. This is fine because you don’t need to know the order to access anything.
    You can find any item that you need by its key. Let’s see how!
  id: totrans-1112
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个字典中，所有的键必须是浮动类型（doubles），而所有的值必须是字符串类型。你会发现，结果面板中的数字顺序与在字典中写入分数的顺序可能大不相同。这是正常的，因为你不需要知道顺序就能访问任何内容。你可以通过键来查找所需的任何项目。让我们看看如何做！
- en: '**ACCESSING VALUES IN A DICTIONARY**'
  id: totrans-1113
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**访问字典中的值**'
- en: 'Looking up a value in a dictionary is similar to how you access a value in
    an array except that you use a key inside the square brackets instead of an index,
    like this: usStates["TX"] .'
  id: totrans-1114
  prefs: []
  type: TYPE_NORMAL
  zh: 在字典中查找一个值类似于在数组中访问一个值，只不过你是在方括号内使用一个键，而不是一个索引，例如：usStates["TX"]。
- en: There is a big difference, however, in how Swift returns the values from a dictionary.
    When you access a value at an index of an array, you are simply given the value.
    When you access a value with a key in a dictionary, you are given an optional.
  id: totrans-1115
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，Swift从字典中返回值时存在一个很大的区别。当你通过数组的索引访问一个值时，你直接得到该值。当你通过字典中的键访问一个值时，你得到的是一个可选值。
- en: In [Chapter 5](text00015.html#ch05) , you learned that optionals might contain
    a value or might be nil . The reason Swift returns optionals when you’re looking
    up items in a dictionary is that the key you used might not exist in the dictionary,
    in which case there’s no value to access. Trying to access a value that doesn’t
    exist would give you a big fat error! To avoid that problem, Swift returns optionals.
    That means you need to unwrap any value you get out of a dictionary before you
    can do anything with it.
  id: totrans-1116
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第5章](text00015.html#ch05)中，你学到可选值可能包含一个值，也可能是nil。Swift在你查找字典中的项目时返回可选值的原因是你使用的键可能在字典中不存在，在这种情况下没有值可供访问。尝试访问一个不存在的值会导致一个错误！为了避免这个问题，Swift返回可选值。这意味着在你使用字典中的任何值之前，你需要解包它。
- en: 'To unwrap an optional, first you check whether it exists using an if-let statement,
    just like we did in [Chapter 5](text00015.html#ch05) . The following code shows
    you how to get a value out of a dictionary:'
  id: totrans-1117
  prefs: []
  type: TYPE_NORMAL
  zh: 要解包一个可选值，首先你需要使用if-let语句检查它是否存在，就像我们在[第5章](text00015.html#ch05)中做的那样。以下代码展示了如何从字典中获取一个值：
- en: '![Image](Image00143.jpg)'
  id: totrans-1118
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00143.jpg)'
- en: To retrieve "Texas" from the dictionary, we use if let to set a constant loneStarState
    to usStates["TX"] ➊ . Because we have this state in our dictionary, the line I
    have Texas in my dictionary. is printed. Next we try to access a state that is
    not in our dictionary by using the key usStates["FL"] ➋ . Thankfully, because
    we used an if-let statement, the program won’t crash when the computer can’t find
    this state. Instead, I don't have that state in my dictionary. is printed.
  id: totrans-1119
  prefs: []
  type: TYPE_NORMAL
  zh: 要从字典中获取“Texas”，我们使用if let将常量loneStarState设置为usStates["TX"] ➊。因为我们的字典中有这个州，所以下面会打印出“I
    have Texas in my dictionary.”接下来，我们尝试通过使用键usStates["FL"] ➋访问一个不在字典中的州。幸运的是，由于我们使用了if-let语句，当计算机找不到这个州时，程序不会崩溃。相反，打印出“I
    don't have that state in my dictionary.”
- en: '**ADDING ITEMS TO A DICTIONARY**'
  id: totrans-1120
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**向字典中添加项目**'
- en: 'To add an item to a dictionary, first write the name of your dictionary and
    assign the new item to the key you want it to have in the dictionary. Let’s add
    "Minnesota" to our usStates dictionary:'
  id: totrans-1121
  prefs: []
  type: TYPE_NORMAL
  zh: 要向字典中添加一个项目，首先写下字典的名称，然后将新项目分配给你想要它所在的键。我们来将“Minnesota”添加到我们的usStates字典中：
- en: '![](Image00144.jpg)'
  id: totrans-1122
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00144.jpg)'
- en: 'Now when you look at usStates , you’ll see that it’s updated to ["MN": "Minnesota",
    "WA": "Washington", "MA": "Massachusetts", "TX": "Texas"] . Remember, because
    you don’t have to rely on indices, your new dictionary item might appear anywhere
    in the dictionary.'
  id: totrans-1123
  prefs: []
  type: TYPE_NORMAL
  zh: '现在，当你查看usStates时，你会看到它已更新为["MN": "Minnesota", "WA": "Washington", "MA": "Massachusetts",
    "TX": "Texas"]。记住，因为你不需要依赖索引，所以你新的字典项目可能出现在字典中的任何位置。'
- en: '**REMOVING ITEMS FROM A DICTIONARY**'
  id: totrans-1124
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**从字典中移除项目**'
- en: Removing an item from a dictionary is quite simple; you do so by setting the
    value to nil . Because the values in dictionaries are returned as optionals, you
    don’t have to worry about nil causing any problems in your dictionary.
  id: totrans-1125
  prefs: []
  type: TYPE_NORMAL
  zh: 从字典中移除一个项目非常简单；你只需要将值设置为nil。因为字典中的值是作为可选值返回的，所以你不必担心nil会导致字典出现任何问题。
- en: '![](Image00145.jpg)'
  id: totrans-1126
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00145.jpg)'
- en: 'You can see that after you remove the value at the key "MA" , usStates is updated
    to ["MN": "Minnesota", "WA": "Washington", "TX": "Texas"] . Remember that nil
    is special and means that there’s no value at all. That’s why you don’t see "MA":
    nil in our dictionary.'
  id: totrans-1127
  prefs: []
  type: TYPE_NORMAL
  zh: '你可以看到，在移除键为"MA"的值之后，usStates更新为["MN": "Minnesota", "WA": "Washington", "TX":
    "Texas"]。记住，nil是特殊的，意味着完全没有值。这就是为什么你在字典中看不到"MA": nil。'
- en: '**REPLACING ITEMS IN A DICTIONARY**'
  id: totrans-1128
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**替换字典中的项目**'
- en: 'Replacing an item in a dictionary is also easy. It works the same was as replacing
    an item in an array. You just set the item that you want to replace to something
    else. Say you create a dictionary of fruit colors:'
  id: totrans-1129
  prefs: []
  type: TYPE_NORMAL
  zh: 替换字典中的项目也很简单。它的操作方式与替换数组中的项目相同。你只需将要替换的项目设置为其他值。假设你创建了一个水果颜色的字典：
- en: '![](Image00146.jpg)'
  id: totrans-1130
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00146.jpg)'
- en: At first we had the value "apple" for "red" , but then we decided that "raspberry"
    is a better fruit to use since sometimes apples are green or yellow. To replace
    "apple" with "raspberry" , we set colorFruits["red"] to its new value ➊ .
  id: totrans-1131
  prefs: []
  type: TYPE_NORMAL
  zh: 一开始我们给“red”赋值为“apple”，但是后来我们决定“raspberry”是更合适的水果，因为有时候苹果是绿色或黄色的。为了将“apple”替换为“raspberry”，我们将`colorFruits["red"]`设置为它的新值
    ➊。
- en: You may remember that this is the same way we entered a new value into a dictionary.
    If the key already exists in the dictionary, then the value for that key is replaced.
    If the key doesn’t already exist, then the new key/value pair will be added to
    the dictionary.
  id: totrans-1132
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能还记得，我们向字典中添加新值的方式就是这样。如果字典中已经存在该键，则会替换该键对应的值。如果该键不存在，则会将新的键/值对添加到字典中。
- en: '![Image](Image00147.jpg)'
  id: totrans-1133
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Image00147.jpg)'
- en: '**USING DICTIONARY PROPERTIES**'
  id: totrans-1134
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**使用字典属性**'
- en: 'Like an array, a dictionary also has an isEmpty property and a count property.
    For example, the following code shows how you can use the isEmpty property to
    check if a dictionary is empty, and if it isn’t empty, the count property checks
    how many items you have. Imagine you have a basket of fruit for sale. You can
    use these properties to help you keep track of everything:'
  id: totrans-1135
  prefs: []
  type: TYPE_NORMAL
  zh: 类似于数组，字典也有一个`isEmpty`属性和一个`count`属性。例如，以下代码展示了如何使用`isEmpty`属性来检查字典是否为空，如果不为空，`count`属性则检查字典中有多少项。想象一下，你有一个待售的水果篮。你可以使用这些属性来帮助你跟踪一切：
- en: '![Image](Image00148.jpg)'
  id: totrans-1136
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Image00148.jpg)'
- en: 'A dictionary also has two special properties: keys , which contains all of
    the dictionary’s keys, and values , which contains all of its values. We’ll use
    these two properties when we loop through the dictionary.'
  id: totrans-1137
  prefs: []
  type: TYPE_NORMAL
  zh: 字典还有两个特殊属性：`keys`，它包含字典的所有键，以及`values`，它包含所有的值。我们将在循环遍历字典时使用这两个属性。
- en: Let’s write some code that loops through our fruit baskets and prints the price
    of each fruit.
  id: totrans-1138
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们写一些代码，遍历我们的水果篮并打印每个水果的价格。
- en: '**LOOPING OVER A DICTIONARY**'
  id: totrans-1139
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**循环遍历字典**'
- en: 'You can loop through a dictionary using a for-in loop. Because each item has
    a key and a value, you can do this in two different ways. This is how to loop
    through a dictionary using its keys:'
  id: totrans-1140
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用`for-in`循环遍历字典。因为每个项都有一个键和值，你可以用两种不同的方式来实现。以下是通过字典的键来循环遍历字典的方法：
- en: '![Image](Image00149.jpg)'
  id: totrans-1141
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Image00149.jpg)'
- en: Here we use the dictionary’s keys property ➊ to loop through fruitBasket and
    print its contents. We start by writing the keyword for , followed by a constant
    name fruit for the dictionary key, the keyword in , the dictionary name, a period,
    and keys .
  id: totrans-1142
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们使用字典的`keys`属性 ➊ 来循环遍历`fruitBasket`并打印它的内容。我们首先写出关键字`for`，接着是一个常量名`fruit`表示字典的键，再加上关键字`in`，字典名，点号和`keys`。
- en: Inside the braces of our for-in loop, we have access to both the key, which
    we call fruit ➋ , and the value at that key when we force-unwrap its contents
    with fruitBasket[fruit]! ➌ . That value will be the fruit’s price.
  id: totrans-1143
  prefs: []
  type: TYPE_NORMAL
  zh: 在`for-in`循环的花括号内部，我们可以访问键（我们称之为`fruit` ➋）以及通过`fruitBasket[fruit]!`强制解包其内容后的值
    ➌。该值将是水果的价格。
- en: In this case, it’s safe to force-unwrap the value using an exclamation point
    because we know that the fruit key we’re using is definitely inside the dictionary.
  id: totrans-1144
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，使用感叹号强制解包值是安全的，因为我们知道我们正在使用的水果键一定存在于字典中。
- en: Any code we put inside the for-in loop will run once for every key in our dictionary.
    So you should see the print statement display three times.
  id: totrans-1145
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在`for-in`循环中放置的任何代码都会针对字典中的每一个键执行一次。因此，你应该看到打印语句显示三次。
- en: 'We can also loop through the dictionary using its values property:'
  id: totrans-1146
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以使用字典的`values`属性来循环遍历字典：
- en: '![Image](Image00150.jpg)'
  id: totrans-1147
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Image00150.jpg)'
- en: We use the same style of for-in loop, but now we use a constant to refer to
    each value, which we call price , in the values property. When looping through
    values, we don’t have access to the keys from inside the loop.
  id: totrans-1148
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用相同风格的`for-in`循环，但这次我们使用一个常量来引用每个值，称其为`price`，并且它位于`values`属性中。在循环遍历`values`时，我们无法从循环内部访问键。
- en: Another difference to note is that price is not an optional because it’s accessed
    directly as a value in the fruitBasket dictionary. That means we don’t have to
    unwrap it. You should still see the print statement printed three times. [Figure
    6-6](text00016.html#ch06fig6) shows the output of both loops.
  id: totrans-1149
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个需要注意的区别是，`price`不是可选类型，因为它是直接作为`fruitBasket`字典中的值来访问的。这意味着我们不需要解包它。你仍然应该看到打印语句打印三次。[图
    6-6](text00016.html#ch06fig6)展示了两个循环的输出。
- en: '![Image](Image00151.jpg)'
  id: totrans-1150
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Image00151.jpg)'
- en: '*Figure 6-6: Looping through the keys and values of a dictionary with a for-in
    loop*'
  id: totrans-1151
  prefs: []
  type: TYPE_NORMAL
  zh: '*图6-6：使用for-in循环遍历字典的键和值*'
- en: The order of your results might be slightly different from ours. That’s because
    the items in a dictionary aren’t in a numbered order like they are in an array!
    And because the order is not guaranteed, you might see a different order printed
    if you run the same code again.
  id: totrans-1152
  prefs: []
  type: TYPE_NORMAL
  zh: 你的结果顺序可能与我们的略有不同。这是因为字典中的项目不像数组中的项目那样按编号排序！由于顺序无法保证，如果你重新运行相同的代码，你可能会看到不同的打印顺序。
- en: '**WHAT YOU LEARNED**'
  id: totrans-1153
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**你学到了什么**'
- en: In this chapter, you learned how to store collections of items in an array and
    in a dictionary. To store items in an ordered list, you would use an array and
    look up each item by its index. If you wanted to store items by key instead, you
    would use a dictionary.
  id: totrans-1154
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你学会了如何将项目存储在数组和字典中。要将项目存储在有序列表中，你应该使用数组，并通过索引查找每个项目。如果你想根据键存储项目，你应该使用字典。
- en: Knowing about arrays and dictionaries and how to use them is a powerful building
    block for almost any programming language. Next we will learn about functions,
    another very powerful tool. Functions are blocks of code that you create and name
    to perform a specific job. After you have written a function, you can use its
    name to call it from almost anywhere in your program.
  id: totrans-1155
  prefs: []
  type: TYPE_NORMAL
  zh: 了解数组和字典及其使用方式是几乎任何编程语言的一个强大构建块。接下来，我们将学习函数，这是另一个非常强大的工具。函数是你创建并命名的代码块，用来执行特定的任务。在你编写完函数后，你可以通过它的名字在程序中的几乎任何地方调用它。
- en: '![](Image00114.jpg)'
  id: totrans-1156
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00114.jpg)'
- en: This code creates an array variable called nationalParks and initializes it
    with the names of three national parks. Because we initialized this array to hold
    strings, you’ll only be able to put strings in it.
  id: totrans-1157
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码创建了一个名为nationalParks的数组变量，并用三个国家公园的名称初始化它。因为我们初始化这个数组来保存字符串，所以它只能包含字符串。
- en: '[Figure 6-1](text00016.html#ch06fig1) shows how you can imagine your array.
    It’s like a row of boxes containing the three names of national parks at indices
    0, 1, and 2\. Remember that the indices of an array always start at 0!'
  id: totrans-1158
  prefs: []
  type: TYPE_NORMAL
  zh: '[图6-1](text00016.html#ch06fig1)展示了你如何想象你的数组。它就像一排盒子，包含了位于索引0、1和2的三个国家公园的名称。记住，数组的索引总是从0开始！'
- en: '![Image](Image00115.jpg)'
  id: totrans-1159
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00115.jpg)'
- en: '*Figure 6-1: The nationalParks array*'
  id: totrans-1160
  prefs: []
  type: TYPE_NORMAL
  zh: '*图6-1：nationalParks数组*'
- en: '**USING MUTABLE AND IMMUTABLE ARRAYS**'
  id: totrans-1161
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**使用可变和不可变数组**'
- en: Our nationalParks array is a variable because we created it with the var keyword
    ➊ . An array stored in a variable is called a *mutable* array. This means that
    you can change it by adding items, removing items, or swapping items in and out.
  id: totrans-1162
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的nationalParks数组是一个变量，因为我们使用`var`关键字创建了它 ➊ 。存储在变量中的数组被称为*可变*数组。这意味着你可以通过添加、删除或交换其中的项目来改变它。
- en: You can also create an *immutable* array. An immutable array is created with
    the keyword let instead of var . Similar to a constant, once an immutable array
    is created, nothing in it can be changed.
  id: totrans-1163
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以创建一个*不可变*数组。不可变数组是使用`let`关键字创建的，而不是`var`。与常量类似，一旦不可变数组被创建，它其中的内容就不能再被修改。
- en: So when should you use a mutable array or an immutable array? It’s best to use
    let if you know your collection will never change, like if you’re storing the
    colors of the rainbow. You should use var if you need to change your collection,
    like if you’re storing an array of your favorite T-shirts, which might change
    depending on what’s in style!
  id: totrans-1164
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，何时使用可变数组或不可变数组呢？如果你知道你的集合永远不会改变，最好使用`let`，比如你要存储彩虹的颜色。若你需要改变集合，例如存储你最喜欢的T恤衫的数组，这些T恤可能会随着流行趋势而改变，那么你应该使用`var`。
- en: '![Image](Image00116.jpg)'
  id: totrans-1165
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00116.jpg)'
- en: '**USING TYPE INFERENCE**'
  id: totrans-1166
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**使用类型推断**'
- en: 'When we created our nationalParks array, we specified that we were creating
    an array of string values by adding a colon (: ) and [String] ➋ . This step is
    optional when you create an array and initialize it with one or more values because
    Swift will use type inference to determine the kind of data you want the array
    to hold. That means that you could just as easily have created the array by doing
    this:'
  id: totrans-1167
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们创建nationalParks数组时，我们通过添加冒号（:）和[String] ➋ 来指定我们创建的是一个字符串值的数组。这个步骤在创建数组并用一个或多个值初始化它时是可选的，因为Swift会使用类型推断来确定你希望数组包含的数据类型。这意味着你也可以通过以下方式创建数组：
- en: '![](Image00117.jpg)'
  id: totrans-1168
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00117.jpg)'
- en: Using type inference, Swift knows we initialized this array to hold strings,
    and it can hold only strings.
  id: totrans-1169
  prefs: []
  type: TYPE_NORMAL
  zh: 通过类型推断，Swift知道我们初始化这个数组来保存字符串，并且它只能包含字符串。
- en: The list of parks that we created the array with is an example of an array *literal*
    . A literal is a value that is exactly what you see. It is not a variable or constant
    but rather just the value without a name. "Grand Canyon" is an example of a string
    literal, and 7 is an example of an integer literal. An array literal is a list
    of items contained between two square brackets and separated by commas, like ["Acadia",
    "Zion", "Grand Canyon"] ➊ .
  id: totrans-1170
  prefs: []
  type: TYPE_NORMAL
  zh: 我们用来创建数组的公园列表是数组*字面量*的一个例子。字面量是一个值，它就是你所看到的内容。它不是变量或常量，而只是没有名称的值。“Grand Canyon”是字符串字面量的例子，而7是整数字面量的例子。数组字面量是一个包含在方括号内并用逗号分隔的元素列表，如["Acadia",
    "Zion", "Grand Canyon"] ➊。
- en: '**ACCESSING ITEMS IN AN ARRAY**'
  id: totrans-1171
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**访问数组中的元素**'
- en: 'Let’s say you want to access an item in your array and use it in your program.
    Your friend asks you to tell them all about your travels, so you want to use the
    names of the national parks that you stored in the array. To access an item in
    your array, write the array name followed by the item’s index inside square brackets:'
  id: totrans-1172
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你想在程序中访问数组中的一个元素并使用它。你的朋友要求你告诉他们所有关于你旅行的事情，所以你想使用你存储在数组中的国家公园名称。要访问数组中的一个元素，写出数组名称，后跟方括号中的索引：
- en: '![](Image00118.jpg)'
  id: totrans-1173
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00118.jpg)'
- en: In this example, we are accessing the names of the national parks and then printing
    them to the screen using print . To get the first item in nationalParks , you
    use nationalParks[0] ➊ . To access the second item in nationalParks , you use
    nationalParks[1] .
  id: totrans-1174
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们正在访问国家公园的名称，然后使用 print 将它们打印到屏幕上。要获取 nationalParks 中的第一个元素，你使用 nationalParks[0]
    ➊ 。要访问 nationalParks 中的第二个元素，你使用 nationalParks[1]。
- en: '**WATCHING THE RANGE**'
  id: totrans-1175
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**观察范围**'
- en: One important point about arrays is that if you try to access an item at an
    index that’s higher than the last index in the array, you’ll get an error. In
    [Figure 6-2](text00016.html#ch06fig2) , you can see that nationalParks[3] (which
    would be the fourth item in the array) gives you an error because there are only
    three national parks in the array, indexed from 0 to 2.
  id: totrans-1176
  prefs: []
  type: TYPE_NORMAL
  zh: 关于数组的一个重要点是，如果你尝试访问一个超出数组最后一个索引的元素，你会得到一个错误。在[图6-2](text00016.html#ch06fig2)
    中，你可以看到 nationalParks[3]（它应该是数组中的第四个元素）会给你一个错误，因为数组中只有三个国家公园，索引从0到2。
- en: As you can see, you get an error message that says Index out of range . If you
    try to access an item that doesn’t exist in your array, your app will crash!
  id: totrans-1177
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，你会得到一条错误信息，提示索引超出范围。如果你尝试访问一个在数组中不存在的元素，应用程序将崩溃！
- en: '![Image](Image00119.jpg)'
  id: totrans-1178
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00119.jpg)'
- en: '*Figure 6-2: Trying to access an index in the array where nothing exists causes
    an error.*'
  id: totrans-1179
  prefs: []
  type: TYPE_NORMAL
  zh: '*图6-2：尝试访问数组中不存在元素的索引会导致错误。*'
- en: '**ADDING ITEMS TO AN ARRAY**'
  id: totrans-1180
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**向数组添加元素**'
- en: One way to change an array is to add new items to it. There are a few different
    ways to do this, so let’s take a look at each.
  id: totrans-1181
  prefs: []
  type: TYPE_NORMAL
  zh: 改变数组的一种方法是向其中添加新元素。有几种不同的方法来做到这一点，所以我们来看一下每种方法。
- en: 'First, you can use an array’s append(_:) method. *Append* means to add something.
    Using append(_:) , you can add one new item to the end of your array. Say you
    go on another trip and visit the Badlands, and you want to add it to your list
    of national parks. To do that, add this code into your playground:'
  id: totrans-1182
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，你可以使用数组的 append(_:) 方法。*追加*意味着添加某些内容。使用 append(_:) 方法，你可以将一个新元素添加到数组的末尾。假设你去了一次新旅行，参观了
    Badlands，并且你想把它添加到你的国家公园列表中。为此，把以下代码添加到你的 Playground 中：
- en: '![](Image00120.jpg)'
  id: totrans-1183
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00120.jpg)'
- en: To use the append(_:) method, first write the name of your array followed by
    a period and then append . Then, put the item you want to add to your array inside
    the parentheses. In this case, you put "Badlands" inside the parentheses.
  id: totrans-1184
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用 append(_:) 方法，首先写出数组的名称，后跟一个句点，再写 append 。然后，把你想添加到数组中的元素放入括号内。在这个例子中，你把“Badlands”放入了括号内。
- en: 'If you want to add something at a specific place in your array, use the array’s
    insert(_:at:) method instead. This method takes two arguments: the item that you
    want to insert and the index of where it should go in the array. (We’ll discuss
    arguments in more detail in [Chapter 7](text00017.html#ch07) .)'
  id: totrans-1185
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想在数组中的特定位置添加元素，使用数组的 insert(_:at:) 方法。这个方法有两个参数：你想要插入的元素和它应该放入数组中的位置索引。（我们将在[第7章](text00017.html#ch07)
    中详细讨论参数。）
- en: 'Let’s say you totally forgot that you went to the Petrified Forest right after
    you visited the Grand Canyon, and you want to update your nationalParks array
    so it displays the parks in the order in which you visited them. To update your
    array, you could use the insert(_:at:) method to put the Petrified Forest in the
    right position:'
  id: totrans-1186
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你完全忘记了在参观大峡谷之后去了化石森林，并且你想更新你的 `nationalParks` 数组，使它按你访问的顺序显示各个公园。为了更新你的数组，你可以使用
    `insert(_:at:)` 方法将化石森林放入正确的位置：
- en: '![](Image00121.jpg)'
  id: totrans-1187
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00121.jpg)'
- en: When you insert a new item at index 3, everything that was in the array at index
    3 or higher gets scooted over to make room for the new item. That means the item
    that was at index 3 is now at index 4, the item that was at index 4 is now at
    index 5, and so on. After you add the Petrified Forest, nationalParks is now ["Acadia",
    "Zion", "Grand Canyon", "Petrified Forest", "Badlands"] .
  id: totrans-1188
  prefs: []
  type: TYPE_NORMAL
  zh: 当你在索引 3 处插入一个新项目时，数组中索引 3 或更高位置的所有项目都会被推移，以腾出空间给新项目。这意味着原来在索引 3 的项目现在位于索引 4，原来在索引
    4 的项目现在位于索引 5，依此类推。添加化石森林之后，`nationalParks` 变为 ["Acadia", "Zion", "Grand Canyon",
    "Petrified Forest", "Badlands"]。
- en: '**COMBINING ARRAYS**'
  id: totrans-1189
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**合并数组**'
- en: 'Not only can you add new items to an array, but you can also add two arrays
    together using the + and += operators. Let’s say that you have the ingredients
    for a fruit smoothie in two arrays:'
  id: totrans-1190
  prefs: []
  type: TYPE_NORMAL
  zh: 不仅可以向数组中添加新项目，还可以使用 `+` 和 `+=` 运算符将两个数组合并。假设你有两数组，分别包含做水果冰沙的原料：
- en: '![](Image00122.jpg)'
  id: totrans-1191
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00122.jpg)'
- en: Now you can make a delicious smoothie by adding the fruits and liquids arrays.
  id: totrans-1192
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你可以通过将水果和液体数组合并，做出一杯美味的冰沙。
- en: '![](Image00123.jpg)'
  id: totrans-1193
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00123.jpg)'
- en: The order of the ingredients in smoothie is the same as the order in fruits
    and liquids . If you created smoothie with liquids + fruits , then the liquids
    would come first.
  id: totrans-1194
  prefs: []
  type: TYPE_NORMAL
  zh: 冰沙的原料顺序与 `fruits` 和 `liquids` 中的顺序相同。如果你用 `liquids + fruits` 创建了冰沙，那么液体会排在前面。
- en: 'You use the += operator to add an array to the end of your array. Add some
    whipped cream as follows for extra yumminess:'
  id: totrans-1195
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用 `+=` 运算符将一个数组添加到另一个数组的末尾。为了增加一些美味的味道，可以按如下方式加入一些鲜奶油：
- en: '![](Image00124.jpg)'
  id: totrans-1196
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00124.jpg)'
- en: Note that ["whipped cream"] is an array even though it has a single item in
    it. When you’re using += to append something to an array, you have to make sure
    you’re only trying to add another array. If you were to just write the string
    "whipped cream" without the square brackets around it, you would get an error.
  id: totrans-1197
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，["whipped cream"] 是一个数组，即使它只包含一个项目。当你使用 `+=` 将东西附加到数组时，你必须确保你只是在尝试添加另一个数组。如果你只是写字符串
    "whipped cream" 而没有将其放在方括号内，程序会报错。
- en: '![Image](Image00125.jpg)'
  id: totrans-1198
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00125.jpg)'
- en: '**REMOVING ITEMS FROM AN ARRAY**'
  id: totrans-1199
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**从数组中移除项目**'
- en: 'There are several methods for removing items from an array. Let’s start by
    looking at the array’s removeLast() method. As you might have guessed from its
    name, removeLast() removes the last item from your array. Let’s try it out with
    a shoppingList array:'
  id: totrans-1200
  prefs: []
  type: TYPE_NORMAL
  zh: 有几种方法可以从数组中移除项目。让我们首先看看数组的 `removeLast()` 方法。正如你从它的名字中可能猜到的，`removeLast()` 会移除数组中的最后一个项目。让我们用一个
    `shoppingList` 数组来试试：
- en: '![](Image00126.jpg)'
  id: totrans-1201
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00126.jpg)'
- en: Neat! Note that the removeLast() method returns the removed item, so you can
    store it in a new constant or variable if you want.
  id: totrans-1202
  prefs: []
  type: TYPE_NORMAL
  zh: 很棒！注意，`removeLast()` 方法会返回被移除的项目，因此，如果你需要，你可以将其存储到一个新的常量或变量中。
- en: 'You can also remove an item from a specific index by using the remove(at:)
    method. Let’s say that your mom doesn’t want you buying any candy and takes that
    off the list:'
  id: totrans-1203
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以使用 `remove(at:)` 方法从特定索引移除一个项目。假设你妈妈不希望你买任何糖果，并把它从清单上拿掉：
- en: '![Image](Image00127.jpg)![](Image00128.jpg)'
  id: totrans-1204
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00127.jpg)![](Image00128.jpg)'
- en: Just like when we added an item to the middle of our array and all the items
    scooted over to make room, if you remove an item from the middle of an array,
    the rest of the items will scoot back to fill in that empty space. The "apples"
    item that was at index 3 is now at index 2, where "candy" was.
  id: totrans-1205
  prefs: []
  type: TYPE_NORMAL
  zh: 就像我们在数组中间添加项目时，所有的项目都被推移腾出空间一样，如果你从数组中间移除一个项目，剩下的项目也会向前移动，填补空缺。原来在索引 3 处的 "apples"
    项目现在位于索引 2，原来在索引 2 处的 "candy" 项目被移除。
- en: 'You can also remove all items from an array with removeAll() . Try entering
    this into your playground:'
  id: totrans-1206
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以使用 `removeAll()` 移除数组中的所有项目。试试在你的 playground 中输入这个代码：
- en: '![](Image00129.jpg)'
  id: totrans-1207
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00129.jpg)'
- en: 'Note that trying to remove an item at an index that doesn’t exist will give
    you an error:'
  id: totrans-1208
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，试图移除一个不存在的索引会导致错误：
- en: '![](Image00130.jpg)'
  id: totrans-1209
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00130.jpg)'
- en: Our array doesn’t have this many items (in fact, now it’s empty!), so this throws
    an error. We’ll also get an error if we use removeLast() on our empty array, because
    there’s nothing in it—there’s no last index at all! However, removeAll() is always
    safe to use, even on an empty array.
  id: totrans-1210
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的数组没有这么多元素（实际上现在它是空的！），所以这会抛出一个错误。如果我们在空数组上使用 removeLast()，也会出现错误，因为数组中没有任何内容——根本没有最后一个索引！但是，removeAll()
    即使在空数组上使用也总是安全的。
- en: '**REPLACING ITEMS IN AN ARRAY**'
  id: totrans-1211
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**替换数组中的元素**'
- en: 'To replace an item in an array, you set the index of the array to the new value,
    as shown here:'
  id: totrans-1212
  prefs: []
  type: TYPE_NORMAL
  zh: 要替换数组中的元素，你需要将数组的索引设置为新值，如下所示：
- en: '![](Image00131.jpg)'
  id: totrans-1213
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00131.jpg)'
- en: At ➊ , we replaced the item at index 2 (the third item) with "Unicorn" because
    magical animals count as favorite animals, too! At ➋ , we replaced the item at
    index 0 (the first item) with "Bearded dragon" . No, that’s not a real dragon—it’s
    just a lizard!
  id: totrans-1214
  prefs: []
  type: TYPE_NORMAL
  zh: 在 ➊ 处，我们将索引为 2（第三个元素）的项替换为 "独角兽"，因为魔法动物也算作是最喜欢的动物！在 ➋ 处，我们将索引为 0（第一个元素）的项替换为
    "胡须蜥蜴"。不，那不是一只真正的龙——它只是一个蜥蜴！
- en: Like any time you’re working with array index numbers, you have to be sure an
    item exists in the array at that index before you change its value, or you will
    get an Index out of range error.
  id: totrans-1215
  prefs: []
  type: TYPE_NORMAL
  zh: 就像在处理数组索引时一样，你必须确保数组中该索引处确实有元素，否则会抛出一个 "索引超出范围" 错误。
- en: '[Figure 6-3](text00016.html#ch06fig3) shows the error that occurs if you try
    to add "Standard poodle" using favoriteAnimals[3] = "Standard poodle" . To add
    an item to the end of an array, you should use the append(_:) method or += , as
    we covered in “[Adding Items to an Array](text00016.html#ch06lev2sec5) ” on [page
    70](text00016.html#page_70) .'
  id: totrans-1216
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 6-3](text00016.html#ch06fig3) 显示了如果你尝试通过 favoriteAnimals[3] = "标准贵宾犬" 来添加
    "标准贵宾犬" 时发生的错误。要将项添加到数组的末尾，你应该使用 append(_:) 方法或 += ，就像我们在 “[向数组添加元素](text00016.html#ch06lev2sec5)”
    中讲到的那样，见 [第 70 页](text00016.html#page_70) 。'
- en: '![Image](Image00132.jpg)'
  id: totrans-1217
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00132.jpg)'
- en: '*Figure 6-3: Don’t try to replace a value at an index beyond the existing array.*'
  id: totrans-1218
  prefs: []
  type: TYPE_NORMAL
  zh: '*图6-3：不要尝试替换超出现有数组索引的值。*'
- en: Now you know how to change arrays however you might need to. You can add items,
    take items away, or replace items. Next, we’ll look at how to use the properties
    of arrays to find out even more information about them.
  id: totrans-1219
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你知道如何根据需要更改数组。你可以添加元素、删除元素或替换元素。接下来，我们将看看如何使用数组的属性来获取更多关于数组的信息。
- en: '![Image](Image00133.jpg)'
  id: totrans-1220
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00133.jpg)'
- en: '**USING ARRAY PROPERTIES**'
  id: totrans-1221
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**使用数组属性**'
- en: In addition to methods like append(_:) and removeLast() , arrays also have *properties*
    . An array’s properties are variables or constants that contain some information
    about the array. Two really helpful properties that you might use are the Boolean
    property isEmpty and the integer property count .
  id: totrans-1222
  prefs: []
  type: TYPE_NORMAL
  zh: 除了像 append(_:) 和 removeLast() 这样的函数方法外，数组还有 *属性* 。数组的属性是包含关于数组的一些信息的变量或常量。有两个非常有用的属性你可能会用到，分别是布尔属性
    isEmpty 和整数属性 count 。
- en: The isEmpty property is true or false depending on whether the array is empty,
    and the count property will tell you how many items are in that array.
  id: totrans-1223
  prefs: []
  type: TYPE_NORMAL
  zh: isEmpty 属性根据数组是否为空返回 true 或 false，而 count 属性则会告诉你数组中有多少个元素。
- en: 'Check out how these two properties are used in the following if-else statement:'
  id: totrans-1224
  prefs: []
  type: TYPE_NORMAL
  zh: 请查看这两个属性如何在以下 if-else 语句中使用：
- en: '![Image](Image00134.jpg)'
  id: totrans-1225
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00134.jpg)'
- en: 'This if-else statement checks whether the array mySiblings is empty ➊ . If
    it is, then "I don''t have any siblings." is printed. But if there is something
    in the array, then the number of siblings that we have is printed: "I have 3 siblings."
    ➋ .'
  id: totrans-1226
  prefs: []
  type: TYPE_NORMAL
  zh: 这个 if-else 语句检查数组 mySiblings 是否为空 ➊ 。如果为空，则打印 "我没有兄弟姐妹"。如果数组中有内容，则打印我们拥有的兄弟姐妹数量："我有
    3 个兄弟姐妹" ➋ 。
- en: '**LOOPING OVER AN ARRAY**'
  id: totrans-1227
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**遍历数组**'
- en: 'Sometimes when you’re working with arrays you might want to do something to
    every item in the array. You can use a for-in loop to do that! The following code
    will print every topping in a pizzaToppings array on a separate line:'
  id: totrans-1228
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，当你处理数组时，可能会想对数组中的每个元素做一些操作。你可以使用 for-in 循环来实现！以下代码会将 pizzaToppings 数组中的每个配料打印在单独的一行上：
- en: '![Image](Image00135.jpg)'
  id: totrans-1229
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00135.jpg)'
- en: To write a for-in loop for the pizzaToppings array, we used the keyword for
    , followed by the constant topping , then the keyword in , and finally the name
    of our array, pizzaToppings . Then we put the statements that we want to run for
    each topping inside the braces of the for-in loop. The constant topping ➊ temporarily
    represents each pizza topping in the array as we loop through it. We could have
    chosen any name for this constant, but it’s a good idea to pick something that
    makes sense. You can see the output of this for-in loop in [Figure 6-4](text00016.html#ch06fig4)
    .
  id: totrans-1230
  prefs: []
  type: TYPE_NORMAL
  zh: 为了为pizzaToppings数组编写一个for-in循环，我们使用了关键字for，后跟常量topping，再后是关键字in，最后是数组名称pizzaToppings。然后我们把想要在每个配料上运行的语句放在for-in循环的大括号中。常量topping
    ➊临时表示数组中的每个比萨配料，随着循环的进行。我们本可以为这个常量选择任何名称，但最好选择一个有意义的名称。你可以在[图6-4](text00016.html#ch06fig4)中看到这个for-in循环的输出。
- en: '![Image](Image00136.jpg)'
  id: totrans-1231
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Image00136.jpg)'
- en: '*Figure 6-4: Output of the example for-in loop*'
  id: totrans-1232
  prefs: []
  type: TYPE_NORMAL
  zh: '*图6-4：示例for-in循环的输出*'
- en: '![Image](Image00137.jpg)'
  id: totrans-1233
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Image00137.jpg)'
- en: 'Using for-in loops is great for printing every value in an array. If you’re
    working with numbers, you can even use them to perform math operations on each
    item, which makes for some speedy calculations! The following code takes an array
    of numbers and calculates the square for each (the square of a number is that
    number multiplied by itself):'
  id: totrans-1234
  prefs: []
  type: TYPE_NORMAL
  zh: 使用for-in循环非常适合打印数组中的每一个值。如果你在处理数字，你甚至可以用它们对每个项执行数学运算，这样就能进行快速计算！以下代码接收一个数字数组，并计算每个数字的平方（一个数字的平方是该数字与它自身相乘）：
- en: '![Image](Image00138.jpg)'
  id: totrans-1235
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Image00138.jpg)'
- en: '[Figure 6-5](text00016.html#ch06fig5) shows the results.'
  id: totrans-1236
  prefs: []
  type: TYPE_NORMAL
  zh: '[图6-5](text00016.html#ch06fig5)显示了结果。'
- en: '![Image](Image00139.jpg)'
  id: totrans-1237
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Image00139.jpg)'
- en: '*Figure 6-5: Printing the squares for each number in the myNumbers array*'
  id: totrans-1238
  prefs: []
  type: TYPE_NORMAL
  zh: '*图6-5：打印myNumbers数组中每个数字的平方*'
- en: '**DICTIONARIES ARE KEY!**'
  id: totrans-1239
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**字典是关键！**'
- en: A *dictionary* is also a collection of values, but instead of an ordered index,
    each value has its own *key* . Because there’s no index, the values are not stored
    in any particular order. To access values in a dictionary, you look them up by
    their key.
  id: totrans-1240
  prefs: []
  type: TYPE_NORMAL
  zh: '*字典*也是一个值的集合，但与有序索引不同，每个值都有其自己的*键*。因为没有索引，值的存储顺序并不固定。要访问字典中的值，你需要通过其键来查找。'
- en: A key must be unique. You can’t have the same key more than once in the same
    dictionary. If there were two identical keys and you asked the computer to give
    you the value for one of them, the computer wouldn’t know which one to choose!
  id: totrans-1241
  prefs: []
  type: TYPE_NORMAL
  zh: 键必须是唯一的。你不能在同一个字典中有相同的键。如果有两个相同的键，并且你要求计算机返回其中一个的值，计算机将不知道选择哪个！
- en: Let’s take a look at how to make a dictionary and write keys that will help
    you find all the information you need.
  id: totrans-1242
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如何创建字典并编写键，帮助你找到所有需要的信息。
- en: '![Image](Image00140.jpg)'
  id: totrans-1243
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Image00140.jpg)'
- en: '**INITIALIZING A DICTIONARY**'
  id: totrans-1244
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**初始化字典**'
- en: 'To create and initialize a dictionary, first write var and the name of your
    dictionary. Then write the keys and corresponding values inside a pair of square
    brackets, similar to an array. Let’s create a dictionary to store the names of
    a few US states. The key for each state will be its two-letter abbreviation:'
  id: totrans-1245
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建并初始化一个字典，首先写下var和字典的名称。然后在一对方括号内写出键及其对应的值，类似于数组。让我们创建一个字典来存储一些美国州的名称。每个州的键将是它的两字母缩写：
- en: '![](Image00141.jpg)'
  id: totrans-1246
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00141.jpg)'
- en: As you can see, there’s a colon between each key and its value, and the key/value
    pairs are separated by commas.
  id: totrans-1247
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，每个键和其值之间有一个冒号，键/值对之间由逗号分隔。
- en: Dictionaries are different from arrays in that they are *unordered* . Because
    of that, it’s likely that the order of the states that you see in your results
    pane ➋ is different from the order in which you entered your states ➊ . It might
    even be different than the order that’s printed in this book!
  id: totrans-1248
  prefs: []
  type: TYPE_NORMAL
  zh: 字典不同于数组，因为它们是*无序的*。因此，你在结果面板中看到的州的顺序➋可能与输入时的顺序➊不同。它甚至可能与书中打印的顺序不同！
- en: As with arrays, you can use var to make a mutable dictionary or use let to make
    an immutable dictionary.
  id: totrans-1249
  prefs: []
  type: TYPE_NORMAL
  zh: 和数组一样，你可以使用var来创建一个可变字典，或者使用let来创建一个不可变字典。
- en: 'In Swift, all of the keys of a dictionary must be the same type, and all of
    the values of a dictionary must also be the same type, but the key type doesn’t
    have to match the value type. For example, if you wanted to store a collection
    of fractions, you could use doubles for the keys and strings for the values:'
  id: totrans-1250
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Swift 中，字典的所有键必须是相同类型，字典的所有值也必须是相同类型，但键的类型不必与值的类型匹配。例如，如果你想存储一组分数，你可以使用双精度浮点数（doubles）作为键，使用字符串（strings）作为值：
- en: '![](Image00142.jpg)'
  id: totrans-1251
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00142.jpg)'
- en: In this dictionary, all of the keys must be doubles, and all of the values must
    be strings. Again, you’ll see that the order of the numbers in the results pane
    can be quite different from the order in which you wrote the fractions in your
    dictionary. This is fine because you don’t need to know the order to access anything.
    You can find any item that you need by its key. Let’s see how!
  id: totrans-1252
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个字典中，所有的键必须是双精度浮点数（doubles），所有的值必须是字符串（strings）。再说一次，你会发现结果窗格中数字的顺序可能与在字典中书写分数的顺序大不相同。这没关系，因为你不需要知道顺序就能访问任何内容。你可以通过键找到你需要的任何项目。我们来看看怎么做！
- en: '**ACCESSING VALUES IN A DICTIONARY**'
  id: totrans-1253
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**访问字典中的值**'
- en: 'Looking up a value in a dictionary is similar to how you access a value in
    an array except that you use a key inside the square brackets instead of an index,
    like this: usStates["TX"] .'
  id: totrans-1254
  prefs: []
  type: TYPE_NORMAL
  zh: 在字典中查找值与在数组中查找值类似，只不过你使用的是方括号内的键，而不是索引，比如这样：usStates["TX"]。
- en: There is a big difference, however, in how Swift returns the values from a dictionary.
    When you access a value at an index of an array, you are simply given the value.
    When you access a value with a key in a dictionary, you are given an optional.
  id: totrans-1255
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，Swift 返回字典中的值有一个很大的区别。当你访问数组中某个索引的值时，你只是简单地获得该值。而当你使用字典中的键访问值时，你会得到一个可选值（optional）。
- en: In [Chapter 5](text00015.html#ch05) , you learned that optionals might contain
    a value or might be nil . The reason Swift returns optionals when you’re looking
    up items in a dictionary is that the key you used might not exist in the dictionary,
    in which case there’s no value to access. Trying to access a value that doesn’t
    exist would give you a big fat error! To avoid that problem, Swift returns optionals.
    That means you need to unwrap any value you get out of a dictionary before you
    can do anything with it.
  id: totrans-1256
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第五章](text00015.html#ch05)中，你学到可选值可能包含一个值，也可能是 nil。Swift 返回可选值的原因是，当你在字典中查找项目时，所使用的键可能不存在于字典中，在这种情况下就没有值可以访问。尝试访问一个不存在的值会导致一个大错误！为了避免这个问题，Swift
    返回可选值。这意味着你需要解包从字典中获取的任何值，才能对其进行操作。
- en: 'To unwrap an optional, first you check whether it exists using an if-let statement,
    just like we did in [Chapter 5](text00015.html#ch05) . The following code shows
    you how to get a value out of a dictionary:'
  id: totrans-1257
  prefs: []
  type: TYPE_NORMAL
  zh: 要解包一个可选值，首先你需要使用 if-let 语句检查它是否存在，就像我们在[第五章](text00015.html#ch05)中做的那样。以下代码展示了如何从字典中获取值：
- en: '![Image](Image00143.jpg)'
  id: totrans-1258
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00143.jpg)'
- en: To retrieve "Texas" from the dictionary, we use if let to set a constant loneStarState
    to usStates["TX"] ➊ . Because we have this state in our dictionary, the line I
    have Texas in my dictionary. is printed. Next we try to access a state that is
    not in our dictionary by using the key usStates["FL"] ➋ . Thankfully, because
    we used an if-let statement, the program won’t crash when the computer can’t find
    this state. Instead, I don't have that state in my dictionary. is printed.
  id: totrans-1259
  prefs: []
  type: TYPE_NORMAL
  zh: 要从字典中检索 "Texas"，我们使用 if let 将常量 loneStarState 设置为 usStates["TX"] ➊。因为我们在字典中有这个州，所以下面会打印出
    "I have Texas in my dictionary."。接下来我们尝试通过键 usStates["FL"] ➋ 访问一个字典中不存在的州。幸运的是，因为我们使用了
    if-let 语句，当计算机找不到这个州时，程序不会崩溃。相反，打印出 "I don't have that state in my dictionary."。
- en: '**ADDING ITEMS TO A DICTIONARY**'
  id: totrans-1260
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**向字典添加项目**'
- en: 'To add an item to a dictionary, first write the name of your dictionary and
    assign the new item to the key you want it to have in the dictionary. Let’s add
    "Minnesota" to our usStates dictionary:'
  id: totrans-1261
  prefs: []
  type: TYPE_NORMAL
  zh: 要向字典中添加一个项目，首先写出字典的名称，并将新项目分配给你希望它在字典中对应的键。让我们把 "Minnesota" 添加到我们的 usStates
    字典中：
- en: '![](Image00144.jpg)'
  id: totrans-1262
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00144.jpg)'
- en: 'Now when you look at usStates , you’ll see that it’s updated to ["MN": "Minnesota",
    "WA": "Washington", "MA": "Massachusetts", "TX": "Texas"] . Remember, because
    you don’t have to rely on indices, your new dictionary item might appear anywhere
    in the dictionary.'
  id: totrans-1263
  prefs: []
  type: TYPE_NORMAL
  zh: '现在，当你查看 usStates 时，你会看到它已更新为 ["MN": "Minnesota", "WA": "Washington", "MA":
    "Massachusetts", "TX": "Texas"]。记住，因为你不需要依赖索引，所以你的新字典项可能会出现在字典中的任何位置。'
- en: '**REMOVING ITEMS FROM A DICTIONARY**'
  id: totrans-1264
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**从字典中删除项目**'
- en: Removing an item from a dictionary is quite simple; you do so by setting the
    value to nil . Because the values in dictionaries are returned as optionals, you
    don’t have to worry about nil causing any problems in your dictionary.
  id: totrans-1265
  prefs: []
  type: TYPE_NORMAL
  zh: 从字典中移除项是非常简单的；你可以通过将值设置为 nil 来做到这一点。因为字典中的值是可选的，所以你不必担心 nil 会在字典中引发任何问题。
- en: '![](Image00145.jpg)'
  id: totrans-1266
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00145.jpg)'
- en: 'You can see that after you remove the value at the key "MA" , usStates is updated
    to ["MN": "Minnesota", "WA": "Washington", "TX": "Texas"] . Remember that nil
    is special and means that there’s no value at all. That’s why you don’t see "MA":
    nil in our dictionary.'
  id: totrans-1267
  prefs: []
  type: TYPE_NORMAL
  zh: '你可以看到，当你移除键 "MA" 处的值后，usStates 被更新为 ["MN": "Minnesota", "WA": "Washington",
    "TX": "Texas"]。记住，nil 是特殊的，表示没有值。因此，你不会在字典中看到 "MA": nil。'
- en: '**REPLACING ITEMS IN A DICTIONARY**'
  id: totrans-1268
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**替换字典中的项**'
- en: 'Replacing an item in a dictionary is also easy. It works the same was as replacing
    an item in an array. You just set the item that you want to replace to something
    else. Say you create a dictionary of fruit colors:'
  id: totrans-1269
  prefs: []
  type: TYPE_NORMAL
  zh: 替换字典中的项也很简单。它的工作方式和替换数组中的项一样。你只需将你想要替换的项设置为其他内容。例如，你可以创建一个水果颜色的字典：
- en: '![](Image00146.jpg)'
  id: totrans-1270
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00146.jpg)'
- en: At first we had the value "apple" for "red" , but then we decided that "raspberry"
    is a better fruit to use since sometimes apples are green or yellow. To replace
    "apple" with "raspberry" , we set colorFruits["red"] to its new value ➊ .
  id: totrans-1271
  prefs: []
  type: TYPE_NORMAL
  zh: 一开始我们为 "red" 设置了值 "apple"，但后来我们决定 "raspberry" 是一个更好的水果，因为有时苹果是绿色或黄色的。要将 "apple"
    替换为 "raspberry"，我们将 colorFruits["red"] 设置为它的新值 ➊。
- en: You may remember that this is the same way we entered a new value into a dictionary.
    If the key already exists in the dictionary, then the value for that key is replaced.
    If the key doesn’t already exist, then the new key/value pair will be added to
    the dictionary.
  id: totrans-1272
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能记得这是我们向字典中输入新值的方式。如果键已经存在于字典中，则该键对应的值将被替换。如果该键不存在，那么新的键/值对将被添加到字典中。
- en: '![Image](Image00147.jpg)'
  id: totrans-1273
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00147.jpg)'
- en: '**USING DICTIONARY PROPERTIES**'
  id: totrans-1274
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**使用字典属性**'
- en: 'Like an array, a dictionary also has an isEmpty property and a count property.
    For example, the following code shows how you can use the isEmpty property to
    check if a dictionary is empty, and if it isn’t empty, the count property checks
    how many items you have. Imagine you have a basket of fruit for sale. You can
    use these properties to help you keep track of everything:'
  id: totrans-1275
  prefs: []
  type: TYPE_NORMAL
  zh: 像数组一样，字典也有一个 isEmpty 属性和一个 count 属性。例如，以下代码演示了如何使用 isEmpty 属性来检查字典是否为空，如果不为空，count
    属性可以检查字典中有多少项。假设你有一个待售的水果篮。你可以使用这些属性来帮助你跟踪所有内容：
- en: '![Image](Image00148.jpg)'
  id: totrans-1276
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00148.jpg)'
- en: 'A dictionary also has two special properties: keys , which contains all of
    the dictionary’s keys, and values , which contains all of its values. We’ll use
    these two properties when we loop through the dictionary.'
  id: totrans-1277
  prefs: []
  type: TYPE_NORMAL
  zh: 字典还有两个特殊属性：keys，它包含字典中的所有键；values，它包含字典中的所有值。我们将在遍历字典时使用这两个属性。
- en: Let’s write some code that loops through our fruit baskets and prints the price
    of each fruit.
  id: totrans-1278
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们编写一些代码，遍历我们的水果篮并打印每个水果的价格。
- en: '**LOOPING OVER A DICTIONARY**'
  id: totrans-1279
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**遍历字典**'
- en: 'You can loop through a dictionary using a for-in loop. Because each item has
    a key and a value, you can do this in two different ways. This is how to loop
    through a dictionary using its keys:'
  id: totrans-1280
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用 for-in 循环遍历字典。因为每个项都有一个键和值，所以你可以通过两种不同的方式来进行遍历。这是通过字典的键来循环的方式：
- en: '![Image](Image00149.jpg)'
  id: totrans-1281
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00149.jpg)'
- en: Here we use the dictionary’s keys property ➊ to loop through fruitBasket and
    print its contents. We start by writing the keyword for , followed by a constant
    name fruit for the dictionary key, the keyword in , the dictionary name, a period,
    and keys .
  id: totrans-1282
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们使用字典的 keys 属性 ➊ 来遍历 fruitBasket 并打印其内容。我们首先写出关键字 for，接着是一个常量名 fruit 来代表字典的键，接着是关键字
    in，字典名，一个句点和 keys。
- en: Inside the braces of our for-in loop, we have access to both the key, which
    we call fruit ➋ , and the value at that key when we force-unwrap its contents
    with fruitBasket[fruit]! ➌ . That value will be the fruit’s price.
  id: totrans-1283
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的 for-in 循环的花括号内，我们可以访问到键（我们称之为 fruit ➋）以及当我们强制解包它的内容时通过 fruitBasket[fruit]!
    ➌ 获取到的该键对应的值。该值将是水果的价格。
- en: In this case, it’s safe to force-unwrap the value using an exclamation point
    because we know that the fruit key we’re using is definitely inside the dictionary.
  id: totrans-1284
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，强制解包值时使用感叹号是安全的，因为我们知道所使用的 fruit 键肯定在字典中。
- en: Any code we put inside the for-in loop will run once for every key in our dictionary.
    So you should see the print statement display three times.
  id: totrans-1285
  prefs: []
  type: TYPE_NORMAL
  zh: 我们放入for-in循环中的任何代码都会对字典中的每个键运行一次。所以你应该看到打印语句显示三次。
- en: 'We can also loop through the dictionary using its values property:'
  id: totrans-1286
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以使用字典的values属性来遍历字典：
- en: '![Image](Image00150.jpg)'
  id: totrans-1287
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00150.jpg)'
- en: We use the same style of for-in loop, but now we use a constant to refer to
    each value, which we call price , in the values property. When looping through
    values, we don’t have access to the keys from inside the loop.
  id: totrans-1288
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用相同类型的for-in循环，但现在我们使用常量来引用每个值，这个值我们称为price，在values属性中。当遍历值时，我们无法在循环内部访问键。
- en: Another difference to note is that price is not an optional because it’s accessed
    directly as a value in the fruitBasket dictionary. That means we don’t have to
    unwrap it. You should still see the print statement printed three times. [Figure
    6-6](text00016.html#ch06fig6) shows the output of both loops.
  id: totrans-1289
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个需要注意的区别是，价格不是一个可选值，因为它是直接作为水果篮字典中的值来访问的。这意味着我们不需要解包它。你仍然应该看到打印语句打印三次。[图 6-6](text00016.html#ch06fig6)显示了两个循环的输出。
- en: '![Image](Image00151.jpg)'
  id: totrans-1290
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00151.jpg)'
- en: '*Figure 6-6: Looping through the keys and values of a dictionary with a for-in
    loop*'
  id: totrans-1291
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 6-6：使用for-in循环遍历字典的键和值*'
- en: The order of your results might be slightly different from ours. That’s because
    the items in a dictionary aren’t in a numbered order like they are in an array!
    And because the order is not guaranteed, you might see a different order printed
    if you run the same code again.
  id: totrans-1292
  prefs: []
  type: TYPE_NORMAL
  zh: 你的结果顺序可能会与我们的略有不同。这是因为字典中的项目不像数组那样按编号顺序排列！由于顺序不固定，如果你重新运行相同的代码，你可能会看到不同的输出顺序。
- en: '**WHAT YOU LEARNED**'
  id: totrans-1293
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**你学到的内容**'
- en: In this chapter, you learned how to store collections of items in an array and
    in a dictionary. To store items in an ordered list, you would use an array and
    look up each item by its index. If you wanted to store items by key instead, you
    would use a dictionary.
  id: totrans-1294
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一章中，你学习了如何将项目存储在数组和字典中。要在有序列表中存储项目，你会使用数组，并通过索引查找每个项目。如果你想通过键存储项目，而不是通过索引，你会使用字典。
- en: Knowing about arrays and dictionaries and how to use them is a powerful building
    block for almost any programming language. Next we will learn about functions,
    another very powerful tool. Functions are blocks of code that you create and name
    to perform a specific job. After you have written a function, you can use its
    name to call it from almost anywhere in your program.
  id: totrans-1295
  prefs: []
  type: TYPE_NORMAL
  zh: 了解数组和字典以及如何使用它们是几乎任何编程语言的强大构建模块。接下来我们将学习函数，这是另一个非常强大的工具。函数是你创建并命名的一段代码，用于执行特定任务。编写完函数后，你可以通过它的名称在程序中的几乎任何地方调用它。
- en: This code creates an array variable called nationalParks and initializes it
    with the names of three national parks. Because we initialized this array to hold
    strings, you’ll only be able to put strings in it.
  id: totrans-1296
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码创建了一个名为nationalParks的数组变量，并用三个国家公园的名称初始化它。因为我们将这个数组初始化为存储字符串，所以你只能在其中放入字符串。
- en: '[Figure 6-1](text00016.html#ch06fig1) shows how you can imagine your array.
    It’s like a row of boxes containing the three names of national parks at indices
    0, 1, and 2\. Remember that the indices of an array always start at 0!'
  id: totrans-1297
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 6-1](text00016.html#ch06fig1)展示了你可以如何想象你的数组。它就像一排包含三个国家公园名称的盒子，分别位于索引0、1和2。记住，数组的索引总是从0开始！'
- en: '![Image](Image00115.jpg)'
  id: totrans-1298
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00115.jpg)'
- en: '*Figure 6-1: The nationalParks array*'
  id: totrans-1299
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 6-1：nationalParks数组*'
- en: '**USING MUTABLE AND IMMUTABLE ARRAYS**'
  id: totrans-1300
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**使用可变和不可变数组**'
- en: Our nationalParks array is a variable because we created it with the var keyword
    ➊ . An array stored in a variable is called a *mutable* array. This means that
    you can change it by adding items, removing items, or swapping items in and out.
  id: totrans-1301
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的nationalParks数组是一个变量，因为我们使用var关键字创建了它 ➊ 。存储在变量中的数组被称为*可变*数组。这意味着你可以通过添加、删除或交换数组中的项目来更改它。
- en: You can also create an *immutable* array. An immutable array is created with
    the keyword let instead of var . Similar to a constant, once an immutable array
    is created, nothing in it can be changed.
  id: totrans-1302
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以创建一个*不可变*数组。不可变数组是使用let关键字而不是var创建的。类似于常量，一旦不可变数组创建后，它的内容就不能更改。
- en: So when should you use a mutable array or an immutable array? It’s best to use
    let if you know your collection will never change, like if you’re storing the
    colors of the rainbow. You should use var if you need to change your collection,
    like if you’re storing an array of your favorite T-shirts, which might change
    depending on what’s in style!
  id: totrans-1303
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，什么时候应该使用可变数组或不可变数组呢？如果你知道你的集合永远不会改变，比如你存储的是彩虹的颜色，最好使用 let。如果你需要更改你的集合，比如你存储的是你最喜欢的
    T 恤的数组，这可能会根据流行趋势变化，那你应该使用 var。
- en: '![Image](Image00116.jpg)'
  id: totrans-1304
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00116.jpg)'
- en: '**USING TYPE INFERENCE**'
  id: totrans-1305
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**使用类型推断**'
- en: 'When we created our nationalParks array, we specified that we were creating
    an array of string values by adding a colon (: ) and [String] ➋ . This step is
    optional when you create an array and initialize it with one or more values because
    Swift will use type inference to determine the kind of data you want the array
    to hold. That means that you could just as easily have created the array by doing
    this:'
  id: totrans-1306
  prefs: []
  type: TYPE_NORMAL
  zh: '当我们创建 nationalParks 数组时，我们通过添加冒号 (: ) 和 [String] ➋ 来指定我们正在创建一个包含字符串值的数组。当你用一个或多个值初始化数组时，这一步是可选的，因为
    Swift 会使用类型推断来确定你希望数组存储的数据类型。这意味着你也可以像这样轻松地创建数组：'
- en: '![](Image00117.jpg)'
  id: totrans-1307
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00117.jpg)'
- en: Using type inference, Swift knows we initialized this array to hold strings,
    and it can hold only strings.
  id: totrans-1308
  prefs: []
  type: TYPE_NORMAL
  zh: 使用类型推断，Swift 知道我们初始化这个数组以存储字符串，并且它只能存储字符串。
- en: The list of parks that we created the array with is an example of an array *literal*
    . A literal is a value that is exactly what you see. It is not a variable or constant
    but rather just the value without a name. "Grand Canyon" is an example of a string
    literal, and 7 is an example of an integer literal. An array literal is a list
    of items contained between two square brackets and separated by commas, like ["Acadia",
    "Zion", "Grand Canyon"] ➊ .
  id: totrans-1309
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建的包含公园列表的数组是一个数组*字面量*的示例。字面量是一个值，它就是你看到的内容。它不是一个变量或常量，而仅仅是一个没有名称的值。"Grand
    Canyon" 是一个字符串字面量的例子，而 7 是一个整数字面量的例子。数组字面量是由两个方括号括起来、用逗号分隔的一组元素，比如 ["Acadia",
    "Zion", "Grand Canyon"] ➊。
- en: '**ACCESSING ITEMS IN AN ARRAY**'
  id: totrans-1310
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**访问数组中的元素**'
- en: 'Let’s say you want to access an item in your array and use it in your program.
    Your friend asks you to tell them all about your travels, so you want to use the
    names of the national parks that you stored in the array. To access an item in
    your array, write the array name followed by the item’s index inside square brackets:'
  id: totrans-1311
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你想访问数组中的一个元素并在程序中使用它。你的朋友请你讲述你的旅行经历，所以你想使用你存储在数组中的国家公园名称。要访问数组中的一个元素，只需在方括号内写出数组名称和元素的索引：
- en: '![](Image00118.jpg)'
  id: totrans-1312
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00118.jpg)'
- en: In this example, we are accessing the names of the national parks and then printing
    them to the screen using print . To get the first item in nationalParks , you
    use nationalParks[0] ➊ . To access the second item in nationalParks , you use
    nationalParks[1] .
  id: totrans-1313
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们正在访问 nationalParks 中的国家公园名称，并通过 print 将它们打印到屏幕上。要获取 nationalParks 中的第一个元素，你使用
    nationalParks[0] ➊。要访问 nationalParks 中的第二个元素，你使用 nationalParks[1]。
- en: '**WATCHING THE RANGE**'
  id: totrans-1314
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**监控范围**'
- en: One important point about arrays is that if you try to access an item at an
    index that’s higher than the last index in the array, you’ll get an error. In
    [Figure 6-2](text00016.html#ch06fig2) , you can see that nationalParks[3] (which
    would be the fourth item in the array) gives you an error because there are only
    three national parks in the array, indexed from 0 to 2.
  id: totrans-1315
  prefs: []
  type: TYPE_NORMAL
  zh: 关于数组的一个重要点是，如果你尝试访问数组中索引高于最后一个索引的元素，你会遇到错误。在[图 6-2](text00016.html#ch06fig2)中，你可以看到
    nationalParks[3]（即数组中的第四个元素）会出现错误，因为数组中只有三个国家公园，索引范围是从 0 到 2。
- en: As you can see, you get an error message that says Index out of range . If you
    try to access an item that doesn’t exist in your array, your app will crash!
  id: totrans-1316
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，错误消息显示为索引超出范围。如果你尝试访问数组中不存在的元素，应用程序将崩溃！
- en: '![Image](Image00119.jpg)'
  id: totrans-1317
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00119.jpg)'
- en: '*Figure 6-2: Trying to access an index in the array where nothing exists causes
    an error.*'
  id: totrans-1318
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 6-2：尝试访问数组中不存在的索引会导致错误。*'
- en: '**ADDING ITEMS TO AN ARRAY**'
  id: totrans-1319
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**向数组添加元素**'
- en: One way to change an array is to add new items to it. There are a few different
    ways to do this, so let’s take a look at each.
  id: totrans-1320
  prefs: []
  type: TYPE_NORMAL
  zh: 更改数组的一种方式是向其中添加新元素。这里有几种不同的方法来实现这一点，让我们逐一看看。
- en: 'First, you can use an array’s append(_:) method. *Append* means to add something.
    Using append(_:) , you can add one new item to the end of your array. Say you
    go on another trip and visit the Badlands, and you want to add it to your list
    of national parks. To do that, add this code into your playground:'
  id: totrans-1321
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，你可以使用数组的append(_:)方法。*Append*表示添加某个元素。使用append(_:)方法，你可以将一个新元素添加到数组的末尾。假设你又去了一趟旅行，参观了坏lands，并且你想把它添加到你的国家公园列表中。为此，在你的游乐场代码中添加以下代码：
- en: '![](Image00120.jpg)'
  id: totrans-1322
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00120.jpg)'
- en: To use the append(_:) method, first write the name of your array followed by
    a period and then append . Then, put the item you want to add to your array inside
    the parentheses. In this case, you put "Badlands" inside the parentheses.
  id: totrans-1323
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用append(_:)方法，首先写下数组的名称，后跟一个句点，然后使用append。接着，将你想添加到数组的元素放在括号内。在这个例子中，你把"Badlands"放进了括号。
- en: 'If you want to add something at a specific place in your array, use the array’s
    insert(_:at:) method instead. This method takes two arguments: the item that you
    want to insert and the index of where it should go in the array. (We’ll discuss
    arguments in more detail in [Chapter 7](text00017.html#ch07) .)'
  id: totrans-1324
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想在数组的特定位置添加某个元素，使用数组的insert(_:at:)方法。这方法需要两个参数：你想插入的元素和它应该放置在数组中的位置索引。（我们将在[第7章](text00017.html#ch07)中更详细地讨论参数。）
- en: 'Let’s say you totally forgot that you went to the Petrified Forest right after
    you visited the Grand Canyon, and you want to update your nationalParks array
    so it displays the parks in the order in which you visited them. To update your
    array, you could use the insert(_:at:) method to put the Petrified Forest in the
    right position:'
  id: totrans-1325
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你完全忘记了在参观完大峡谷后，你去了化石森林，并且你想更新你的nationalParks数组，使其按你参观的顺序显示各个公园。要更新你的数组，可以使用insert(_:at:)方法，将化石森林放在正确的位置：
- en: '![](Image00121.jpg)'
  id: totrans-1326
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00121.jpg)'
- en: When you insert a new item at index 3, everything that was in the array at index
    3 or higher gets scooted over to make room for the new item. That means the item
    that was at index 3 is now at index 4, the item that was at index 4 is now at
    index 5, and so on. After you add the Petrified Forest, nationalParks is now ["Acadia",
    "Zion", "Grand Canyon", "Petrified Forest", "Badlands"] .
  id: totrans-1327
  prefs: []
  type: TYPE_NORMAL
  zh: 当你在索引3的位置插入一个新元素时，数组中从索引3开始及其之后的所有元素都会向后移动，以腾出位置给新元素。这意味着原来在索引3的元素现在会移到索引4，原本在索引4的元素现在移到索引5，以此类推。添加化石森林后，nationalParks数组现在是["Acadia",
    "Zion", "Grand Canyon", "Petrified Forest", "Badlands"]。
- en: '**COMBINING ARRAYS**'
  id: totrans-1328
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**合并数组**'
- en: 'Not only can you add new items to an array, but you can also add two arrays
    together using the + and += operators. Let’s say that you have the ingredients
    for a fruit smoothie in two arrays:'
  id: totrans-1329
  prefs: []
  type: TYPE_NORMAL
  zh: 你不仅可以向数组添加新元素，还可以使用+和+=操作符将两个数组合并在一起。假设你有两个数组，分别存储水果冰沙的原料：
- en: '![](Image00122.jpg)'
  id: totrans-1330
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00122.jpg)'
- en: Now you can make a delicious smoothie by adding the fruits and liquids arrays.
  id: totrans-1331
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你可以通过将水果和液体数组组合起来，制作美味的冰沙。
- en: '![](Image00123.jpg)'
  id: totrans-1332
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00123.jpg)'
- en: The order of the ingredients in smoothie is the same as the order in fruits
    and liquids . If you created smoothie with liquids + fruits , then the liquids
    would come first.
  id: totrans-1333
  prefs: []
  type: TYPE_NORMAL
  zh: 冰沙原料的顺序与水果和液体的顺序相同。如果你用液体+水果的顺序来制作冰沙，那么液体会排在前面。
- en: 'You use the += operator to add an array to the end of your array. Add some
    whipped cream as follows for extra yumminess:'
  id: totrans-1334
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用+=操作符将一个数组添加到另一个数组的末尾。以下是将一些鲜奶油加入数组中的方法，以增加额外的美味感：
- en: '![](Image00124.jpg)'
  id: totrans-1335
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00124.jpg)'
- en: Note that ["whipped cream"] is an array even though it has a single item in
    it. When you’re using += to append something to an array, you have to make sure
    you’re only trying to add another array. If you were to just write the string
    "whipped cream" without the square brackets around it, you would get an error.
  id: totrans-1336
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，["whipped cream"]是一个数组，即使它只有一个元素。当你使用+=将某个元素添加到数组时，必须确保你只是试图添加另一个数组。如果你只是写了字符串"whipped
    cream"而没有方括号，程序会报错。
- en: '![Image](Image00125.jpg)'
  id: totrans-1337
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00125.jpg)'
- en: '**REMOVING ITEMS FROM AN ARRAY**'
  id: totrans-1338
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**从数组中删除元素**'
- en: 'There are several methods for removing items from an array. Let’s start by
    looking at the array’s removeLast() method. As you might have guessed from its
    name, removeLast() removes the last item from your array. Let’s try it out with
    a shoppingList array:'
  id: totrans-1339
  prefs: []
  type: TYPE_NORMAL
  zh: 有几种方法可以从数组中删除元素。让我们首先来看一下数组的removeLast()方法。正如你从方法名中猜到的那样，removeLast()会删除数组中的最后一个元素。我们可以用一个购物清单数组来试一试。
- en: '![](Image00126.jpg)'
  id: totrans-1340
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00126.jpg)'
- en: Neat! Note that the removeLast() method returns the removed item, so you can
    store it in a new constant or variable if you want.
  id: totrans-1341
  prefs: []
  type: TYPE_NORMAL
  zh: 很棒！请注意，removeLast() 方法会返回被删除的项目，所以如果你需要的话，可以将它存储在一个新的常量或变量中。
- en: 'You can also remove an item from a specific index by using the remove(at:)
    method. Let’s say that your mom doesn’t want you buying any candy and takes that
    off the list:'
  id: totrans-1342
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以通过使用 remove(at:) 方法从特定索引位置删除一个项目。假设你的妈妈不希望你买任何糖果，并把它从清单上删除：
- en: '![Image](Image00127.jpg)![](Image00128.jpg)'
  id: totrans-1343
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00127.jpg)![](Image00128.jpg)'
- en: Just like when we added an item to the middle of our array and all the items
    scooted over to make room, if you remove an item from the middle of an array,
    the rest of the items will scoot back to fill in that empty space. The "apples"
    item that was at index 3 is now at index 2, where "candy" was.
  id: totrans-1344
  prefs: []
  type: TYPE_NORMAL
  zh: 就像我们在数组中间添加一个项目时，所有项目会向一边移动以腾出空间一样，如果你从数组中间删除一个项目，其余的项目会回移，填补那个空位。原本位于索引 3 的“苹果”项目现在位于索引
    2，即“糖果”所在的位置。
- en: 'You can also remove all items from an array with removeAll() . Try entering
    this into your playground:'
  id: totrans-1345
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以使用 removeAll() 方法从数组中删除所有项目。试着在你的 Playground 中输入以下内容：
- en: '![](Image00129.jpg)'
  id: totrans-1346
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00129.jpg)'
- en: 'Note that trying to remove an item at an index that doesn’t exist will give
    you an error:'
  id: totrans-1347
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，尝试删除一个不存在的索引位置的项目会导致错误：
- en: '![](Image00130.jpg)'
  id: totrans-1348
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00130.jpg)'
- en: Our array doesn’t have this many items (in fact, now it’s empty!), so this throws
    an error. We’ll also get an error if we use removeLast() on our empty array, because
    there’s nothing in it—there’s no last index at all! However, removeAll() is always
    safe to use, even on an empty array.
  id: totrans-1349
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的数组没有这么多项目（实际上，现在它是空的！），所以这会导致错误。如果我们对空数组使用 removeLast()，也会出错，因为它什么都没有——根本没有最后一个索引！然而，removeAll()
    方法始终是安全的，即使是对空数组也可以使用。
- en: '**REPLACING ITEMS IN AN ARRAY**'
  id: totrans-1350
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**替换数组中的项目**'
- en: 'To replace an item in an array, you set the index of the array to the new value,
    as shown here:'
  id: totrans-1351
  prefs: []
  type: TYPE_NORMAL
  zh: 要替换数组中的项目，你需要将数组的索引设置为新值，如下所示：
- en: '![](Image00131.jpg)'
  id: totrans-1352
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00131.jpg)'
- en: At ➊ , we replaced the item at index 2 (the third item) with "Unicorn" because
    magical animals count as favorite animals, too! At ➋ , we replaced the item at
    index 0 (the first item) with "Bearded dragon" . No, that’s not a real dragon—it’s
    just a lizard!
  id: totrans-1353
  prefs: []
  type: TYPE_NORMAL
  zh: 在 ➊ 处，我们将索引为 2（第三个项目）的位置替换为“独角兽”，因为魔法动物也算作是最喜欢的动物！在 ➋ 处，我们将索引为 0（第一个项目）的位置替换为“胡须龙”。不，这不是一只真正的龙——它只是一个蜥蜴！
- en: Like any time you’re working with array index numbers, you have to be sure an
    item exists in the array at that index before you change its value, or you will
    get an Index out of range error.
  id: totrans-1354
  prefs: []
  type: TYPE_NORMAL
  zh: 就像在处理数组索引时一样，你必须确保数组在该索引位置有项目存在，才能修改它的值，否则你会遇到“索引超出范围”错误。
- en: '[Figure 6-3](text00016.html#ch06fig3) shows the error that occurs if you try
    to add "Standard poodle" using favoriteAnimals[3] = "Standard poodle" . To add
    an item to the end of an array, you should use the append(_:) method or += , as
    we covered in “[Adding Items to an Array](text00016.html#ch06lev2sec5) ” on [page
    70](text00016.html#page_70) .'
  id: totrans-1355
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 6-3](text00016.html#ch06fig3) 显示了如果你尝试使用 favoriteAnimals[3] = "Standard
    poodle" 添加“标准贵宾犬”时会发生的错误。要向数组的末尾添加项目，你应该使用 append(_:) 方法或 += 运算符，正如我们在 “[向数组中添加项目](text00016.html#ch06lev2sec5)”
    一节中 [第 70 页](text00016.html#page_70) 讨论的那样。'
- en: '![Image](Image00132.jpg)'
  id: totrans-1356
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00132.jpg)'
- en: '*Figure 6-3: Don’t try to replace a value at an index beyond the existing array.*'
  id: totrans-1357
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 6-3：不要尝试替换超出现有数组范围的索引位置的值。*'
- en: Now you know how to change arrays however you might need to. You can add items,
    take items away, or replace items. Next, we’ll look at how to use the properties
    of arrays to find out even more information about them.
  id: totrans-1358
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你知道如何根据需要更改数组了。你可以添加项目、删除项目或替换项目。接下来，我们将看看如何使用数组的属性来获取更多关于它们的信息。
- en: '![Image](Image00133.jpg)'
  id: totrans-1359
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00133.jpg)'
- en: '**USING ARRAY PROPERTIES**'
  id: totrans-1360
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**使用数组属性**'
- en: In addition to methods like append(_:) and removeLast() , arrays also have *properties*
    . An array’s properties are variables or constants that contain some information
    about the array. Two really helpful properties that you might use are the Boolean
    property isEmpty and the integer property count .
  id: totrans-1361
  prefs: []
  type: TYPE_NORMAL
  zh: 除了像 append(_:) 和 removeLast() 这样的函数方法，数组还有 *属性*。数组的属性是包含数组相关信息的变量或常量。有两个非常有用的属性，你可能会用到，它们分别是布尔值属性
    isEmpty 和整数属性 count。
- en: The isEmpty property is true or false depending on whether the array is empty,
    and the count property will tell you how many items are in that array.
  id: totrans-1362
  prefs: []
  type: TYPE_NORMAL
  zh: isEmpty 属性根据数组是否为空返回 true 或 false，count 属性将告诉你数组中有多少个项目。
- en: 'Check out how these two properties are used in the following if-else statement:'
  id: totrans-1363
  prefs: []
  type: TYPE_NORMAL
  zh: 请查看以下 if-else 语句中如何使用这两个属性：
- en: '![Image](Image00134.jpg)'
  id: totrans-1364
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00134.jpg)'
- en: 'This if-else statement checks whether the array mySiblings is empty ➊ . If
    it is, then "I don''t have any siblings." is printed. But if there is something
    in the array, then the number of siblings that we have is printed: "I have 3 siblings."
    ➋ .'
  id: totrans-1365
  prefs: []
  type: TYPE_NORMAL
  zh: 这个 if-else 语句检查数组 mySiblings 是否为空 ➊。如果为空，则打印“我没有任何兄弟姐妹。”如果数组中有内容，则打印我们拥有的兄弟姐妹数量：“我有
    3 个兄弟姐妹。” ➋。
- en: '**LOOPING OVER AN ARRAY**'
  id: totrans-1366
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**遍历数组**'
- en: 'Sometimes when you’re working with arrays you might want to do something to
    every item in the array. You can use a for-in loop to do that! The following code
    will print every topping in a pizzaToppings array on a separate line:'
  id: totrans-1367
  prefs: []
  type: TYPE_NORMAL
  zh: 有时候，当你处理数组时，可能希望对数组中的每个项执行某些操作。你可以使用 for-in 循环来实现！以下代码将逐行打印 pizzaToppings 数组中的每个配料：
- en: '![Image](Image00135.jpg)'
  id: totrans-1368
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00135.jpg)'
- en: To write a for-in loop for the pizzaToppings array, we used the keyword for
    , followed by the constant topping , then the keyword in , and finally the name
    of our array, pizzaToppings . Then we put the statements that we want to run for
    each topping inside the braces of the for-in loop. The constant topping ➊ temporarily
    represents each pizza topping in the array as we loop through it. We could have
    chosen any name for this constant, but it’s a good idea to pick something that
    makes sense. You can see the output of this for-in loop in [Figure 6-4](text00016.html#ch06fig4)
    .
  id: totrans-1369
  prefs: []
  type: TYPE_NORMAL
  zh: 为了编写 pizzaToppings 数组的 for-in 循环，我们使用了关键字 for，后跟常量 topping，再加上关键字 in，最后是我们数组的名称
    pizzaToppings。然后我们将要对每个配料执行的语句放入 for-in 循环的花括号内。常量 topping ➊ 在我们遍历数组时，暂时代表每个披萨配料。我们本可以为这个常量选择任何名称，但最好选择一个有意义的名称。你可以在
    [图 6-4](text00016.html#ch06fig4) 中看到这个 for-in 循环的输出。
- en: '![Image](Image00136.jpg)'
  id: totrans-1370
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00136.jpg)'
- en: '*Figure 6-4: Output of the example for-in loop*'
  id: totrans-1371
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 6-4：示例 for-in 循环的输出*'
- en: '![Image](Image00137.jpg)'
  id: totrans-1372
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00137.jpg)'
- en: 'Using for-in loops is great for printing every value in an array. If you’re
    working with numbers, you can even use them to perform math operations on each
    item, which makes for some speedy calculations! The following code takes an array
    of numbers and calculates the square for each (the square of a number is that
    number multiplied by itself):'
  id: totrans-1373
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 for-in 循环非常适合打印数组中的每个值。如果你在处理数字，你甚至可以利用它们对每个项执行数学运算，这样可以进行快速计算！以下代码获取一个数字数组并计算每个数字的平方（数字的平方是该数字与其自身相乘）：
- en: '![Image](Image00138.jpg)'
  id: totrans-1374
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00138.jpg)'
- en: '[Figure 6-5](text00016.html#ch06fig5) shows the results.'
  id: totrans-1375
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 6-5](text00016.html#ch06fig5) 显示了结果。'
- en: '![Image](Image00139.jpg)'
  id: totrans-1376
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00139.jpg)'
- en: '*Figure 6-5: Printing the squares for each number in the myNumbers array*'
  id: totrans-1377
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 6-5：打印 myNumbers 数组中每个数字的平方*'
- en: '**DICTIONARIES ARE KEY!**'
  id: totrans-1378
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**字典很重要！**'
- en: A *dictionary* is also a collection of values, but instead of an ordered index,
    each value has its own *key* . Because there’s no index, the values are not stored
    in any particular order. To access values in a dictionary, you look them up by
    their key.
  id: totrans-1379
  prefs: []
  type: TYPE_NORMAL
  zh: '*字典* 也是一个值的集合，但与有序索引不同，每个值都有自己的 *键*。由于没有索引，值的存储顺序是无序的。要访问字典中的值，可以通过键来查找它们。'
- en: A key must be unique. You can’t have the same key more than once in the same
    dictionary. If there were two identical keys and you asked the computer to give
    you the value for one of them, the computer wouldn’t know which one to choose!
  id: totrans-1380
  prefs: []
  type: TYPE_NORMAL
  zh: 键必须是唯一的。你不能在同一个字典中重复使用相同的键。如果有两个相同的键，且你要求计算机返回其中一个的值，计算机将无法确定选择哪一个！
- en: Let’s take a look at how to make a dictionary and write keys that will help
    you find all the information you need.
  id: totrans-1381
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看如何创建一个字典，并写下有助于你找到所需信息的键。
- en: '![Image](Image00140.jpg)'
  id: totrans-1382
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00140.jpg)'
- en: '**INITIALIZING A DICTIONARY**'
  id: totrans-1383
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**初始化字典**'
- en: 'To create and initialize a dictionary, first write var and the name of your
    dictionary. Then write the keys and corresponding values inside a pair of square
    brackets, similar to an array. Let’s create a dictionary to store the names of
    a few US states. The key for each state will be its two-letter abbreviation:'
  id: totrans-1384
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建和初始化字典，首先写上 var 和字典的名称。然后在一对方括号内写下键和值，类似于数组。让我们创建一个字典来存储一些美国州的名称。每个州的键将是其两字母的缩写：
- en: '![](Image00141.jpg)'
  id: totrans-1385
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00141.jpg)'
- en: As you can see, there’s a colon between each key and its value, and the key/value
    pairs are separated by commas.
  id: totrans-1386
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，每个键和值之间有一个冒号，键/值对之间由逗号分隔。
- en: Dictionaries are different from arrays in that they are *unordered* . Because
    of that, it’s likely that the order of the states that you see in your results
    pane ➋ is different from the order in which you entered your states ➊ . It might
    even be different than the order that’s printed in this book!
  id: totrans-1387
  prefs: []
  type: TYPE_NORMAL
  zh: 字典与数组不同，字典是*无序*的。因此，你在结果窗格中看到的州的顺序 ➋ 可能与你输入的州的顺序 ➊ 不同，甚至可能与本书中打印的顺序不同！
- en: As with arrays, you can use var to make a mutable dictionary or use let to make
    an immutable dictionary.
  id: totrans-1388
  prefs: []
  type: TYPE_NORMAL
  zh: 与数组一样，你可以使用 var 来创建一个可变字典，或者使用 let 来创建一个不可变字典。
- en: 'In Swift, all of the keys of a dictionary must be the same type, and all of
    the values of a dictionary must also be the same type, but the key type doesn’t
    have to match the value type. For example, if you wanted to store a collection
    of fractions, you could use doubles for the keys and strings for the values:'
  id: totrans-1389
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Swift 中，字典的所有键必须是相同类型，字典的所有值也必须是相同类型，但键的类型不必与值的类型匹配。例如，如果你想存储一个分数集合，你可以使用双精度浮点数作为键，使用字符串作为值：
- en: '![](Image00142.jpg)'
  id: totrans-1390
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00142.jpg)'
- en: In this dictionary, all of the keys must be doubles, and all of the values must
    be strings. Again, you’ll see that the order of the numbers in the results pane
    can be quite different from the order in which you wrote the fractions in your
    dictionary. This is fine because you don’t need to know the order to access anything.
    You can find any item that you need by its key. Let’s see how!
  id: totrans-1391
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个字典中，所有的键必须是双精度浮点数，所有的值必须是字符串。同样，你会看到，结果窗格中的数字顺序可能与字典中分数的顺序有所不同。这是可以接受的，因为你不需要知道顺序来访问任何内容。你可以通过键来查找你需要的任何项。让我们看看怎么做！
- en: '**ACCESSING VALUES IN A DICTIONARY**'
  id: totrans-1392
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**访问字典中的值**'
- en: 'Looking up a value in a dictionary is similar to how you access a value in
    an array except that you use a key inside the square brackets instead of an index,
    like this: usStates["TX"] .'
  id: totrans-1393
  prefs: []
  type: TYPE_NORMAL
  zh: 查找字典中的值类似于访问数组中的值，不同之处在于你在方括号内使用的是键而不是索引，比如这样：usStates["TX"]。
- en: There is a big difference, however, in how Swift returns the values from a dictionary.
    When you access a value at an index of an array, you are simply given the value.
    When you access a value with a key in a dictionary, you are given an optional.
  id: totrans-1394
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，Swift 返回字典中值的方式有很大不同。当你访问数组中某个索引的值时，你只是直接获得该值。当你使用键访问字典中的值时，你得到的是一个可选值。
- en: In [Chapter 5](text00015.html#ch05) , you learned that optionals might contain
    a value or might be nil . The reason Swift returns optionals when you’re looking
    up items in a dictionary is that the key you used might not exist in the dictionary,
    in which case there’s no value to access. Trying to access a value that doesn’t
    exist would give you a big fat error! To avoid that problem, Swift returns optionals.
    That means you need to unwrap any value you get out of a dictionary before you
    can do anything with it.
  id: totrans-1395
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第5章](text00015.html#ch05)中，你学习了可选值可能包含一个值，也可能为 nil。当你在字典中查找项时，Swift 返回可选值的原因是，你使用的键可能在字典中不存在，在这种情况下，就没有值可供访问。尝试访问一个不存在的值会导致一个严重的错误！为避免这个问题，Swift
    返回可选值。这意味着在对字典中获取的任何值进行操作之前，你需要解包它。
- en: 'To unwrap an optional, first you check whether it exists using an if-let statement,
    just like we did in [Chapter 5](text00015.html#ch05) . The following code shows
    you how to get a value out of a dictionary:'
  id: totrans-1396
  prefs: []
  type: TYPE_NORMAL
  zh: 要解包一个可选值，首先你需要使用 if-let 语句检查它是否存在，就像我们在[第5章](text00015.html#ch05)中做的那样。以下代码展示了如何从字典中获取一个值：
- en: '![Image](Image00143.jpg)'
  id: totrans-1397
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Image00143.jpg)'
- en: To retrieve "Texas" from the dictionary, we use if let to set a constant loneStarState
    to usStates["TX"] ➊ . Because we have this state in our dictionary, the line I
    have Texas in my dictionary. is printed. Next we try to access a state that is
    not in our dictionary by using the key usStates["FL"] ➋ . Thankfully, because
    we used an if-let statement, the program won’t crash when the computer can’t find
    this state. Instead, I don't have that state in my dictionary. is printed.
  id: totrans-1398
  prefs: []
  type: TYPE_NORMAL
  zh: 要从字典中检索 "Texas"，我们使用 if let 语句将常量 loneStarState 设置为 usStates["TX"] ➊。因为字典中有这个州，所以打印出
    "我在我的字典中有 Texas"。接下来，我们尝试通过使用键 usStates["FL"] ➋ 访问一个不存在于字典中的州。幸运的是，因为我们使用了 if-let
    语句，当计算机找不到该州时，程序不会崩溃，而是打印出 "我在我的字典中没有这个州"。
- en: '**ADDING ITEMS TO A DICTIONARY**'
  id: totrans-1399
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**向字典添加项**'
- en: 'To add an item to a dictionary, first write the name of your dictionary and
    assign the new item to the key you want it to have in the dictionary. Let’s add
    "Minnesota" to our usStates dictionary:'
  id: totrans-1400
  prefs: []
  type: TYPE_NORMAL
  zh: 要向字典中添加项，首先写出字典的名称，并将新项赋给你希望其拥有的键。让我们将 "Minnesota" 添加到我们的 usStates 字典中：
- en: '![](Image00144.jpg)'
  id: totrans-1401
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00144.jpg)'
- en: 'Now when you look at usStates , you’ll see that it’s updated to ["MN": "Minnesota",
    "WA": "Washington", "MA": "Massachusetts", "TX": "Texas"] . Remember, because
    you don’t have to rely on indices, your new dictionary item might appear anywhere
    in the dictionary.'
  id: totrans-1402
  prefs: []
  type: TYPE_NORMAL
  zh: '现在，当你查看 usStates 时，你会看到它已经更新为 ["MN": "Minnesota", "WA": "Washington", "MA":
    "Massachusetts", "TX": "Texas"]。记住，因为你不需要依赖索引，所以新的字典项可能出现在字典的任何位置。'
- en: '**REMOVING ITEMS FROM A DICTIONARY**'
  id: totrans-1403
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**从字典中删除项**'
- en: Removing an item from a dictionary is quite simple; you do so by setting the
    value to nil . Because the values in dictionaries are returned as optionals, you
    don’t have to worry about nil causing any problems in your dictionary.
  id: totrans-1404
  prefs: []
  type: TYPE_NORMAL
  zh: 从字典中删除项非常简单；你只需要将值设置为 nil。因为字典中的值是以可选项的形式返回的，所以你无需担心 nil 会在字典中引起问题。
- en: '![](Image00145.jpg)'
  id: totrans-1405
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00145.jpg)'
- en: 'You can see that after you remove the value at the key "MA" , usStates is updated
    to ["MN": "Minnesota", "WA": "Washington", "TX": "Texas"] . Remember that nil
    is special and means that there’s no value at all. That’s why you don’t see "MA":
    nil in our dictionary.'
  id: totrans-1406
  prefs: []
  type: TYPE_NORMAL
  zh: '你可以看到，在你删除 "MA" 键的值之后，usStates 已更新为 ["MN": "Minnesota", "WA": "Washington",
    "TX": "Texas"]。记住，nil 是特殊的，表示没有任何值。这就是为什么你在我们的字典中看不到 "MA": nil。'
- en: '**REPLACING ITEMS IN A DICTIONARY**'
  id: totrans-1407
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**替换字典中的项**'
- en: 'Replacing an item in a dictionary is also easy. It works the same was as replacing
    an item in an array. You just set the item that you want to replace to something
    else. Say you create a dictionary of fruit colors:'
  id: totrans-1408
  prefs: []
  type: TYPE_NORMAL
  zh: 替换字典中的项也很简单。它的工作方式与替换数组中的项相同。你只需要将要替换的项设置为其他值。假设你创建了一个水果颜色的字典：
- en: '![](Image00146.jpg)'
  id: totrans-1409
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00146.jpg)'
- en: At first we had the value "apple" for "red" , but then we decided that "raspberry"
    is a better fruit to use since sometimes apples are green or yellow. To replace
    "apple" with "raspberry" , we set colorFruits["red"] to its new value ➊ .
  id: totrans-1410
  prefs: []
  type: TYPE_NORMAL
  zh: 最初我们为 "red" 设置了值 "apple"，但后来我们决定使用 "raspberry" 作为更好的水果，因为有时候苹果是绿色或黄色的。为了将 "apple"
    替换为 "raspberry"，我们将 colorFruits["red"] 设置为它的新值 ➊。
- en: You may remember that this is the same way we entered a new value into a dictionary.
    If the key already exists in the dictionary, then the value for that key is replaced.
    If the key doesn’t already exist, then the new key/value pair will be added to
    the dictionary.
  id: totrans-1411
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能还记得，这与我们向字典中添加新值的方式相同。如果键已经存在于字典中，那么该键的值将被替换。如果该键不存在，则新的键值对将被添加到字典中。
- en: '![Image](Image00147.jpg)'
  id: totrans-1412
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00147.jpg)'
- en: '**USING DICTIONARY PROPERTIES**'
  id: totrans-1413
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**使用字典属性**'
- en: 'Like an array, a dictionary also has an isEmpty property and a count property.
    For example, the following code shows how you can use the isEmpty property to
    check if a dictionary is empty, and if it isn’t empty, the count property checks
    how many items you have. Imagine you have a basket of fruit for sale. You can
    use these properties to help you keep track of everything:'
  id: totrans-1414
  prefs: []
  type: TYPE_NORMAL
  zh: 就像数组一样，字典也有 isEmpty 属性和 count 属性。例如，以下代码展示了如何使用 isEmpty 属性来检查字典是否为空，如果不为空，则使用
    count 属性来检查字典中有多少项。假设你有一个待售的水果篮子。你可以使用这些属性帮助你跟踪所有内容：
- en: '![Image](Image00148.jpg)'
  id: totrans-1415
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00148.jpg)'
- en: 'A dictionary also has two special properties: keys , which contains all of
    the dictionary’s keys, and values , which contains all of its values. We’ll use
    these two properties when we loop through the dictionary.'
  id: totrans-1416
  prefs: []
  type: TYPE_NORMAL
  zh: 字典还有两个特殊的属性：keys，包含字典的所有键，和 values，包含字典的所有值。我们在遍历字典时会使用这两个属性。
- en: Let’s write some code that loops through our fruit baskets and prints the price
    of each fruit.
  id: totrans-1417
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们写一些代码，遍历我们的水果篮子并打印每种水果的价格。
- en: '**LOOPING OVER A DICTIONARY**'
  id: totrans-1418
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**遍历字典**'
- en: 'You can loop through a dictionary using a for-in loop. Because each item has
    a key and a value, you can do this in two different ways. This is how to loop
    through a dictionary using its keys:'
  id: totrans-1419
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用 for-in 循环来遍历字典。由于每个项都有一个键和值，你可以通过两种不同的方式来做到这一点。以下是通过键遍历字典的方法：
- en: '![Image](Image00149.jpg)'
  id: totrans-1420
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00149.jpg)'
- en: Here we use the dictionary’s keys property ➊ to loop through fruitBasket and
    print its contents. We start by writing the keyword for , followed by a constant
    name fruit for the dictionary key, the keyword in , the dictionary name, a period,
    and keys .
  id: totrans-1421
  prefs: []
  type: TYPE_NORMAL
  zh: 这里我们使用字典的 keys 属性 ➊ 来遍历 fruitBasket 并打印其内容。我们首先写出关键字 for，接着是常量名称 fruit，代表字典的键，再是关键字
    in，字典名称，一个句点，以及 keys。
- en: Inside the braces of our for-in loop, we have access to both the key, which
    we call fruit ➋ , and the value at that key when we force-unwrap its contents
    with fruitBasket[fruit]! ➌ . That value will be the fruit’s price.
  id: totrans-1422
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的 for-in 循环的大括号内部，我们可以访问到键（我们称之为 fruit ➋）和该键的值，当我们强制解包 fruitBasket[fruit]
    的内容时 ➌。该值就是水果的价格。
- en: In this case, it’s safe to force-unwrap the value using an exclamation point
    because we know that the fruit key we’re using is definitely inside the dictionary.
  id: totrans-1423
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，使用感叹号强制解包这个值是安全的，因为我们知道正在使用的水果键肯定在字典中。
- en: Any code we put inside the for-in loop will run once for every key in our dictionary.
    So you should see the print statement display three times.
  id: totrans-1424
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在 for-in 循环中放入的任何代码都会针对字典中的每个键执行一次。所以你应该看到打印语句显示三次。
- en: 'We can also loop through the dictionary using its values property:'
  id: totrans-1425
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以通过字典的 values 属性来循环：
- en: '![Image](Image00150.jpg)'
  id: totrans-1426
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Image00150.jpg)'
- en: We use the same style of for-in loop, but now we use a constant to refer to
    each value, which we call price , in the values property. When looping through
    values, we don’t have access to the keys from inside the loop.
  id: totrans-1427
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用相同的 for-in 循环方式，但现在我们使用常量来引用每个值，我们称之为 price ，它来自 values 属性。在循环遍历值时，我们无法从循环内部访问到键。
- en: Another difference to note is that price is not an optional because it’s accessed
    directly as a value in the fruitBasket dictionary. That means we don’t have to
    unwrap it. You should still see the print statement printed three times. [Figure
    6-6](text00016.html#ch06fig6) shows the output of both loops.
  id: totrans-1428
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个需要注意的区别是 price 不是可选项，因为它是直接作为值访问的，来自 fruitBasket 字典。这意味着我们不需要解包它。你应该仍然能看到打印语句打印三次。[图6-6](text00016.html#ch06fig6)
    展示了两种循环的输出。
- en: '![Image](Image00151.jpg)'
  id: totrans-1429
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Image00151.jpg)'
- en: '*Figure 6-6: Looping through the keys and values of a dictionary with a for-in
    loop*'
  id: totrans-1430
  prefs: []
  type: TYPE_NORMAL
  zh: '*图6-6：使用 for-in 循环遍历字典的键和值*'
- en: The order of your results might be slightly different from ours. That’s because
    the items in a dictionary aren’t in a numbered order like they are in an array!
    And because the order is not guaranteed, you might see a different order printed
    if you run the same code again.
  id: totrans-1431
  prefs: []
  type: TYPE_NORMAL
  zh: 你的结果顺序可能与我们的稍有不同。这是因为字典中的项目不像数组那样按数字顺序排列！由于顺序没有保证，如果你再次运行相同的代码，你可能会看到不同的输出顺序。
- en: '**WHAT YOU LEARNED**'
  id: totrans-1432
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**你学到了什么**'
- en: In this chapter, you learned how to store collections of items in an array and
    in a dictionary. To store items in an ordered list, you would use an array and
    look up each item by its index. If you wanted to store items by key instead, you
    would use a dictionary.
  id: totrans-1433
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你学习了如何将项目集合存储在数组和字典中。要将项目存储在有序列表中，你可以使用数组并通过索引查找每个项目。如果你想按键来存储项目，则应使用字典。
- en: Knowing about arrays and dictionaries and how to use them is a powerful building
    block for almost any programming language. Next we will learn about functions,
    another very powerful tool. Functions are blocks of code that you create and name
    to perform a specific job. After you have written a function, you can use its
    name to call it from almost anywhere in your program.
  id: totrans-1434
  prefs: []
  type: TYPE_NORMAL
  zh: 了解数组和字典以及如何使用它们是几乎所有编程语言中的一个强大基础。接下来，我们将学习函数，这是另一种非常强大的工具。函数是你创建并命名的一块代码，用来执行特定的任务。写好一个函数后，你可以在程序中的几乎任何地方使用它的名字来调用它。
- en: '[Figure 6-1](text00016.html#ch06fig1) shows how you can imagine your array.
    It’s like a row of boxes containing the three names of national parks at indices
    0, 1, and 2\. Remember that the indices of an array always start at 0!'
  id: totrans-1435
  prefs: []
  type: TYPE_NORMAL
  zh: '[图6-1](text00016.html#ch06fig1) 展示了你如何想象你的数组。它就像一排盒子，索引 0、1 和 2 里分别包含三个国家公园的名字。记住，数组的索引总是从
    0 开始！'
- en: '![Image](Image00115.jpg)'
  id: totrans-1436
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Image00115.jpg)'
- en: '*Figure 6-1: The nationalParks array*'
  id: totrans-1437
  prefs: []
  type: TYPE_NORMAL
  zh: '*图6-1：nationalParks 数组*'
- en: '**USING MUTABLE AND IMMUTABLE ARRAYS**'
  id: totrans-1438
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**使用可变和不可变数组**'
- en: Our nationalParks array is a variable because we created it with the var keyword
    ➊ . An array stored in a variable is called a *mutable* array. This means that
    you can change it by adding items, removing items, or swapping items in and out.
  id: totrans-1439
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的 nationalParks 数组是一个变量，因为我们使用 var 关键词创建了它 ➊。存储在变量中的数组称为*可变*数组。这意味着你可以通过添加、删除或交换数组中的项目来修改它。
- en: You can also create an *immutable* array. An immutable array is created with
    the keyword let instead of var . Similar to a constant, once an immutable array
    is created, nothing in it can be changed.
  id: totrans-1440
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以创建一个*不可变*数组。一个不可变数组是通过关键词 let 而不是 var 创建的。与常量类似，一旦不可变数组被创建，它其中的内容就不能被改变。
- en: So when should you use a mutable array or an immutable array? It’s best to use
    let if you know your collection will never change, like if you’re storing the
    colors of the rainbow. You should use var if you need to change your collection,
    like if you’re storing an array of your favorite T-shirts, which might change
    depending on what’s in style!
  id: totrans-1441
  prefs: []
  type: TYPE_NORMAL
  zh: 那么什么时候应该使用可变数组或不可变数组呢？如果你知道你的集合永远不会改变，例如存储彩虹的颜色，最好使用 let。如果你需要修改你的集合，例如存储你最喜欢的
    T 恤衫的数组，这可能会根据流行的款式变化，那么应该使用 var。
- en: '![Image](Image00116.jpg)'
  id: totrans-1442
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00116.jpg)'
- en: '**USING TYPE INFERENCE**'
  id: totrans-1443
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**使用类型推断**'
- en: 'When we created our nationalParks array, we specified that we were creating
    an array of string values by adding a colon (: ) and [String] ➋ . This step is
    optional when you create an array and initialize it with one or more values because
    Swift will use type inference to determine the kind of data you want the array
    to hold. That means that you could just as easily have created the array by doing
    this:'
  id: totrans-1444
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们创建 nationalParks 数组时，我们通过添加冒号（:）和 [String] ➋ 来指定我们正在创建一个字符串值的数组。这个步骤在创建数组并用一个或多个值初始化时是可选的，因为
    Swift 会使用类型推断来确定你希望数组存储的数据类型。这意味着你完全可以通过下面的方式创建数组：
- en: '![](Image00117.jpg)'
  id: totrans-1445
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00117.jpg)'
- en: Using type inference, Swift knows we initialized this array to hold strings,
    and it can hold only strings.
  id: totrans-1446
  prefs: []
  type: TYPE_NORMAL
  zh: 使用类型推断，Swift 知道我们初始化了这个数组来存储字符串，并且它只能存储字符串。
- en: The list of parks that we created the array with is an example of an array *literal*
    . A literal is a value that is exactly what you see. It is not a variable or constant
    but rather just the value without a name. "Grand Canyon" is an example of a string
    literal, and 7 is an example of an integer literal. An array literal is a list
    of items contained between two square brackets and separated by commas, like ["Acadia",
    "Zion", "Grand Canyon"] ➊ .
  id: totrans-1447
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建数组时使用的公园列表是一个数组*字面量*的例子。字面量是一个值，它就是你看到的那样。它不是一个变量或常量，而是一个没有名字的值。"Grand Canyon"
    是字符串字面量的例子，7 是整数字面量的例子。数组字面量是包含在两个方括号之间的项目列表，项目之间用逗号分隔，如 ["Acadia", "Zion", "Grand
    Canyon"] ➊。
- en: '**ACCESSING ITEMS IN AN ARRAY**'
  id: totrans-1448
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**访问数组中的项目**'
- en: 'Let’s say you want to access an item in your array and use it in your program.
    Your friend asks you to tell them all about your travels, so you want to use the
    names of the national parks that you stored in the array. To access an item in
    your array, write the array name followed by the item’s index inside square brackets:'
  id: totrans-1449
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你想访问数组中的一个项目并在程序中使用它。你的朋友请你告诉他们你所有的旅行经历，所以你想使用你在数组中存储的国家公园的名称。要访问数组中的一个项目，写出数组名称，后面跟着该项目的索引，索引位于方括号中：
- en: '![](Image00118.jpg)'
  id: totrans-1450
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00118.jpg)'
- en: In this example, we are accessing the names of the national parks and then printing
    them to the screen using print . To get the first item in nationalParks , you
    use nationalParks[0] ➊ . To access the second item in nationalParks , you use
    nationalParks[1] .
  id: totrans-1451
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们访问了国家公园的名称，并使用 print 将它们打印到屏幕上。要获取 nationalParks 中的第一个项目，你可以使用 nationalParks[0]
    ➊。要访问 nationalParks 中的第二个项目，你可以使用 nationalParks[1]。
- en: '**WATCHING THE RANGE**'
  id: totrans-1452
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**观察范围**'
- en: One important point about arrays is that if you try to access an item at an
    index that’s higher than the last index in the array, you’ll get an error. In
    [Figure 6-2](text00016.html#ch06fig2) , you can see that nationalParks[3] (which
    would be the fourth item in the array) gives you an error because there are only
    three national parks in the array, indexed from 0 to 2.
  id: totrans-1453
  prefs: []
  type: TYPE_NORMAL
  zh: 关于数组的一个重要点是，如果你尝试访问一个索引大于数组中最后一个索引的项目，你会得到一个错误。在[图 6-2](text00016.html#ch06fig2)
    中，你可以看到 nationalParks[3]（这将是数组中的第四个项目）会给出错误，因为数组中只有三个国家公园，索引从 0 到 2。
- en: As you can see, you get an error message that says Index out of range . If you
    try to access an item that doesn’t exist in your array, your app will crash!
  id: totrans-1454
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，你会收到一个错误信息，说"Index out of range"。如果你尝试访问数组中不存在的项，应用程序将崩溃！
- en: '![Image](Image00119.jpg)'
  id: totrans-1455
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00119.jpg)'
- en: '*Figure 6-2: Trying to access an index in the array where nothing exists causes
    an error.*'
  id: totrans-1456
  prefs: []
  type: TYPE_NORMAL
  zh: '*图6-2：尝试访问数组中不存在的索引会导致错误。*'
- en: '**ADDING ITEMS TO AN ARRAY**'
  id: totrans-1457
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**向数组添加项**'
- en: One way to change an array is to add new items to it. There are a few different
    ways to do this, so let’s take a look at each.
  id: totrans-1458
  prefs: []
  type: TYPE_NORMAL
  zh: 改变数组的一种方法是向其添加新项。有几种不同的方法来做到这一点，让我们逐一看看。
- en: 'First, you can use an array’s append(_:) method. *Append* means to add something.
    Using append(_:) , you can add one new item to the end of your array. Say you
    go on another trip and visit the Badlands, and you want to add it to your list
    of national parks. To do that, add this code into your playground:'
  id: totrans-1459
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，你可以使用数组的append(_:)方法。*Append*意味着添加某物。使用append(_:)方法，你可以将一项新内容添加到数组的末尾。假设你又去了旅行，参观了Badlands，你想将它添加到你的国家公园列表中。为此，可以在你的游乐场中添加如下代码：
- en: '![](Image00120.jpg)'
  id: totrans-1460
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00120.jpg)'
- en: To use the append(_:) method, first write the name of your array followed by
    a period and then append . Then, put the item you want to add to your array inside
    the parentheses. In this case, you put "Badlands" inside the parentheses.
  id: totrans-1461
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用append(_:)方法，首先写下数组的名称，后面跟一个句点，然后是append。接着，将你想要添加到数组中的项放入括号内。在此案例中，你将"Badlands"放入了括号中。
- en: 'If you want to add something at a specific place in your array, use the array’s
    insert(_:at:) method instead. This method takes two arguments: the item that you
    want to insert and the index of where it should go in the array. (We’ll discuss
    arguments in more detail in [Chapter 7](text00017.html#ch07) .)'
  id: totrans-1462
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想在数组中的特定位置添加某项，使用数组的insert(_:at:)方法。这个方法接受两个参数：你想插入的项和它应该放置的位置索引。（我们将在[第7章](text00017.html#ch07)中详细讨论参数。）
- en: 'Let’s say you totally forgot that you went to the Petrified Forest right after
    you visited the Grand Canyon, and you want to update your nationalParks array
    so it displays the parks in the order in which you visited them. To update your
    array, you could use the insert(_:at:) method to put the Petrified Forest in the
    right position:'
  id: totrans-1463
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你完全忘记了自己在参观大峡谷后去了化石森林，现在你想更新你的nationalParks数组，以按你参观的顺序显示这些公园。要更新数组，你可以使用insert(_:at:)方法，将化石森林插入到正确的位置：
- en: '![](Image00121.jpg)'
  id: totrans-1464
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00121.jpg)'
- en: When you insert a new item at index 3, everything that was in the array at index
    3 or higher gets scooted over to make room for the new item. That means the item
    that was at index 3 is now at index 4, the item that was at index 4 is now at
    index 5, and so on. After you add the Petrified Forest, nationalParks is now ["Acadia",
    "Zion", "Grand Canyon", "Petrified Forest", "Badlands"] .
  id: totrans-1465
  prefs: []
  type: TYPE_NORMAL
  zh: 当你在索引3处插入一个新项时，数组中索引为3或更高的所有项都会被推移，以为新项腾出空间。这意味着原本在索引3处的项现在位于索引4处，原本在索引4处的项现在位于索引5处，以此类推。在你添加化石森林之后，nationalParks数组现在是["Acadia",
    "Zion", "Grand Canyon", "Petrified Forest", "Badlands"]。
- en: '**COMBINING ARRAYS**'
  id: totrans-1466
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**合并数组**'
- en: 'Not only can you add new items to an array, but you can also add two arrays
    together using the + and += operators. Let’s say that you have the ingredients
    for a fruit smoothie in two arrays:'
  id: totrans-1467
  prefs: []
  type: TYPE_NORMAL
  zh: 你不仅可以向数组中添加新项，还可以使用+和+=运算符将两个数组合并在一起。假设你有两个数组，分别包含制作水果冰沙的食材：
- en: '![](Image00122.jpg)'
  id: totrans-1468
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00122.jpg)'
- en: Now you can make a delicious smoothie by adding the fruits and liquids arrays.
  id: totrans-1469
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你可以通过将水果和液体数组合并来制作美味的冰沙。
- en: '![](Image00123.jpg)'
  id: totrans-1470
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00123.jpg)'
- en: The order of the ingredients in smoothie is the same as the order in fruits
    and liquids . If you created smoothie with liquids + fruits , then the liquids
    would come first.
  id: totrans-1471
  prefs: []
  type: TYPE_NORMAL
  zh: 冰沙中的食材顺序与水果和液体中的顺序相同。如果你用液体+水果创建冰沙，那么液体会排在前面。
- en: 'You use the += operator to add an array to the end of your array. Add some
    whipped cream as follows for extra yumminess:'
  id: totrans-1472
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用+=运算符将一个数组添加到另一个数组的末尾。为了让味道更美味，添加一些鲜奶油如下：
- en: '![](Image00124.jpg)'
  id: totrans-1473
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00124.jpg)'
- en: Note that ["whipped cream"] is an array even though it has a single item in
    it. When you’re using += to append something to an array, you have to make sure
    you’re only trying to add another array. If you were to just write the string
    "whipped cream" without the square brackets around it, you would get an error.
  id: totrans-1474
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，["whipped cream"]是一个数组，尽管它只包含一个项。当你使用+=将某物添加到数组时，你必须确保只尝试添加另一个数组。如果你仅仅写下字符串"whipped
    cream"，没有方括号，程序会报错。
- en: '![Image](Image00125.jpg)'
  id: totrans-1475
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00125.jpg)'
- en: '**REMOVING ITEMS FROM AN ARRAY**'
  id: totrans-1476
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**从数组中移除项**'
- en: 'There are several methods for removing items from an array. Let’s start by
    looking at the array’s removeLast() method. As you might have guessed from its
    name, removeLast() removes the last item from your array. Let’s try it out with
    a shoppingList array:'
  id: totrans-1477
  prefs: []
  type: TYPE_NORMAL
  zh: 有几种方法可以从数组中移除项。让我们先来看看数组的removeLast()方法。正如你从它的名字猜到的那样，removeLast()会移除数组中的最后一项。让我们用一个shoppingList数组试一下：
- en: '![](Image00126.jpg)'
  id: totrans-1478
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00126.jpg)'
- en: Neat! Note that the removeLast() method returns the removed item, so you can
    store it in a new constant or variable if you want.
  id: totrans-1479
  prefs: []
  type: TYPE_NORMAL
  zh: 很棒！请注意，removeLast()方法会返回被移除的项，所以如果你愿意，你可以将它存储在一个新的常量或变量中。
- en: 'You can also remove an item from a specific index by using the remove(at:)
    method. Let’s say that your mom doesn’t want you buying any candy and takes that
    off the list:'
  id: totrans-1480
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以通过使用remove(at:)方法来从指定的索引移除项。假设你妈妈不想让你买任何糖果，于是把它从清单上删除：
- en: '![Image](Image00127.jpg)![](Image00128.jpg)'
  id: totrans-1481
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00127.jpg)![](Image00128.jpg)'
- en: Just like when we added an item to the middle of our array and all the items
    scooted over to make room, if you remove an item from the middle of an array,
    the rest of the items will scoot back to fill in that empty space. The "apples"
    item that was at index 3 is now at index 2, where "candy" was.
  id: totrans-1482
  prefs: []
  type: TYPE_NORMAL
  zh: 就像我们在数组中间添加项时，所有其他项会向一边移动腾出空间一样，如果你从数组中间移除项，剩下的项会向回移来填补空位。原本在索引3位置的"苹果"项现在在索引2的位置，原本"糖果"的位置。
- en: 'You can also remove all items from an array with removeAll() . Try entering
    this into your playground:'
  id: totrans-1483
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以通过removeAll()方法移除数组中的所有项。试着在你的游乐场中输入以下内容：
- en: '![](Image00129.jpg)'
  id: totrans-1484
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00129.jpg)'
- en: 'Note that trying to remove an item at an index that doesn’t exist will give
    you an error:'
  id: totrans-1485
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，尝试删除一个不存在的索引位置的项会导致错误：
- en: '![](Image00130.jpg)'
  id: totrans-1486
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00130.jpg)'
- en: Our array doesn’t have this many items (in fact, now it’s empty!), so this throws
    an error. We’ll also get an error if we use removeLast() on our empty array, because
    there’s nothing in it—there’s no last index at all! However, removeAll() is always
    safe to use, even on an empty array.
  id: totrans-1487
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的数组并没有这么多项（实际上现在它是空的！），所以这会抛出一个错误。如果我们在空数组上使用removeLast()，也会出现错误，因为它里面没有任何东西——根本没有最后一个索引！不过，removeAll()方法始终是安全的，即使是在空数组上也可以使用。
- en: '**REPLACING ITEMS IN AN ARRAY**'
  id: totrans-1488
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**替换数组中的项**'
- en: 'To replace an item in an array, you set the index of the array to the new value,
    as shown here:'
  id: totrans-1489
  prefs: []
  type: TYPE_NORMAL
  zh: 要替换数组中的项，你可以将数组的索引位置设置为新值，如下所示：
- en: '![](Image00131.jpg)'
  id: totrans-1490
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00131.jpg)'
- en: At ➊ , we replaced the item at index 2 (the third item) with "Unicorn" because
    magical animals count as favorite animals, too! At ➋ , we replaced the item at
    index 0 (the first item) with "Bearded dragon" . No, that’s not a real dragon—it’s
    just a lizard!
  id: totrans-1491
  prefs: []
  type: TYPE_NORMAL
  zh: 在➊位置，我们用"独角兽"替换了索引2（第三项）的位置，因为魔法动物也是最爱的动物！在➋位置，我们用"须龙"替换了索引0（第一项）的位置。不，这可不是一条真正的龙——它只是一只蜥蜴！
- en: Like any time you’re working with array index numbers, you have to be sure an
    item exists in the array at that index before you change its value, or you will
    get an Index out of range error.
  id: totrans-1492
  prefs: []
  type: TYPE_NORMAL
  zh: 就像任何时候你在处理数组索引时一样，在你更改值之前，一定要确保该索引位置的项在数组中存在，否则你会遇到"索引越界"的错误。
- en: '[Figure 6-3](text00016.html#ch06fig3) shows the error that occurs if you try
    to add "Standard poodle" using favoriteAnimals[3] = "Standard poodle" . To add
    an item to the end of an array, you should use the append(_:) method or += , as
    we covered in “[Adding Items to an Array](text00016.html#ch06lev2sec5) ” on [page
    70](text00016.html#page_70) .'
  id: totrans-1493
  prefs: []
  type: TYPE_NORMAL
  zh: '[图6-3](text00016.html#ch06fig3)显示了当你尝试使用favoriteAnimals[3] = "Standard poodle"
    添加"标准贵宾犬"时发生的错误。要将项添加到数组的末尾，你应该使用append(_:)方法或+=，正如我们在 “[添加项到数组](text00016.html#ch06lev2sec5)”一节中第[70页](text00016.html#page_70)所讲解的那样。'
- en: '![Image](Image00132.jpg)'
  id: totrans-1494
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00132.jpg)'
- en: '*Figure 6-3: Don’t try to replace a value at an index beyond the existing array.*'
  id: totrans-1495
  prefs: []
  type: TYPE_NORMAL
  zh: '*图6-3：不要尝试替换超出现有数组范围的索引位置的值。*'
- en: Now you know how to change arrays however you might need to. You can add items,
    take items away, or replace items. Next, we’ll look at how to use the properties
    of arrays to find out even more information about them.
  id: totrans-1496
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你知道如何根据需要更改数组了。你可以添加项，移除项或替换项。接下来，我们将看看如何使用数组的属性来了解更多关于数组的信息。
- en: '![Image](Image00133.jpg)'
  id: totrans-1497
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00133.jpg)'
- en: '**USING ARRAY PROPERTIES**'
  id: totrans-1498
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**使用数组属性**'
- en: In addition to methods like append(_:) and removeLast() , arrays also have *properties*
    . An array’s properties are variables or constants that contain some information
    about the array. Two really helpful properties that you might use are the Boolean
    property isEmpty and the integer property count .
  id: totrans-1499
  prefs: []
  type: TYPE_NORMAL
  zh: 除了像 append(_:) 和 removeLast() 这样的操作方法，数组还有 *属性*。数组的属性是包含有关数组信息的变量或常量。有两个非常有用的属性你可能会用到，一个是布尔型属性
    isEmpty，另一个是整数型属性 count。
- en: The isEmpty property is true or false depending on whether the array is empty,
    and the count property will tell you how many items are in that array.
  id: totrans-1500
  prefs: []
  type: TYPE_NORMAL
  zh: isEmpty 属性根据数组是否为空返回 true 或 false，count 属性则会告诉你数组中有多少个元素。
- en: 'Check out how these two properties are used in the following if-else statement:'
  id: totrans-1501
  prefs: []
  type: TYPE_NORMAL
  zh: 看看下面的 if-else 语句中如何使用这两个属性：
- en: '![Image](Image00134.jpg)'
  id: totrans-1502
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Image00134.jpg)'
- en: 'This if-else statement checks whether the array mySiblings is empty ➊ . If
    it is, then "I don''t have any siblings." is printed. But if there is something
    in the array, then the number of siblings that we have is printed: "I have 3 siblings."
    ➋ .'
  id: totrans-1503
  prefs: []
  type: TYPE_NORMAL
  zh: 这个 if-else 语句检查数组 mySiblings 是否为空 ➊。如果为空，则打印“我没有兄弟姐妹”。如果数组中有内容，则打印我们有几个兄弟姐妹：“我有
    3 个兄弟姐妹。” ➋。
- en: '**LOOPING OVER AN ARRAY**'
  id: totrans-1504
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**遍历数组**'
- en: 'Sometimes when you’re working with arrays you might want to do something to
    every item in the array. You can use a for-in loop to do that! The following code
    will print every topping in a pizzaToppings array on a separate line:'
  id: totrans-1505
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，当你处理数组时，可能会想对数组中的每一项执行某些操作。你可以使用 for-in 循环来实现！以下代码将在单独的行上打印出 pizzaToppings
    数组中的每一项：
- en: '![Image](Image00135.jpg)'
  id: totrans-1506
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Image00135.jpg)'
- en: To write a for-in loop for the pizzaToppings array, we used the keyword for
    , followed by the constant topping , then the keyword in , and finally the name
    of our array, pizzaToppings . Then we put the statements that we want to run for
    each topping inside the braces of the for-in loop. The constant topping ➊ temporarily
    represents each pizza topping in the array as we loop through it. We could have
    chosen any name for this constant, but it’s a good idea to pick something that
    makes sense. You can see the output of this for-in loop in [Figure 6-4](text00016.html#ch06fig4)
    .
  id: totrans-1507
  prefs: []
  type: TYPE_NORMAL
  zh: 为了写一个用于 pizzaToppings 数组的 for-in 循环，我们使用了关键字 for，后跟常量 topping，然后是关键字 in，最后是我们数组的名称
    pizzaToppings。然后我们将希望对每个 topping 执行的语句放在 for-in 循环的大括号内。常量 topping ➊ 在我们循环时临时代表数组中的每一个
    pizza topping。我们本可以为这个常量选择任何名字，但最好选一个有意义的名字。你可以在 [图6-4](text00016.html#ch06fig4)
    中看到这个 for-in 循环的输出。
- en: '![Image](Image00136.jpg)'
  id: totrans-1508
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Image00136.jpg)'
- en: '*Figure 6-4: Output of the example for-in loop*'
  id: totrans-1509
  prefs: []
  type: TYPE_NORMAL
  zh: '*图6-4：示例中 for-in 循环的输出*'
- en: '![Image](Image00137.jpg)'
  id: totrans-1510
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Image00137.jpg)'
- en: 'Using for-in loops is great for printing every value in an array. If you’re
    working with numbers, you can even use them to perform math operations on each
    item, which makes for some speedy calculations! The following code takes an array
    of numbers and calculates the square for each (the square of a number is that
    number multiplied by itself):'
  id: totrans-1511
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 for-in 循环非常适合打印数组中的每个值。如果你处理的是数字，你甚至可以用它们对每个项执行数学运算，这样就能进行快速的计算！以下代码接收一个数字数组，并计算每个数字的平方（数字的平方是该数字与其自身相乘）：
- en: '![Image](Image00138.jpg)'
  id: totrans-1512
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Image00138.jpg)'
- en: '[Figure 6-5](text00016.html#ch06fig5) shows the results.'
  id: totrans-1513
  prefs: []
  type: TYPE_NORMAL
  zh: '[图6-5](text00016.html#ch06fig5)显示了结果。'
- en: '![Image](Image00139.jpg)'
  id: totrans-1514
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Image00139.jpg)'
- en: '*Figure 6-5: Printing the squares for each number in the myNumbers array*'
  id: totrans-1515
  prefs: []
  type: TYPE_NORMAL
  zh: '*图6-5：打印 myNumbers 数组中每个数字的平方*'
- en: '**DICTIONARIES ARE KEY!**'
  id: totrans-1516
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**字典是关键！**'
- en: A *dictionary* is also a collection of values, but instead of an ordered index,
    each value has its own *key* . Because there’s no index, the values are not stored
    in any particular order. To access values in a dictionary, you look them up by
    their key.
  id: totrans-1517
  prefs: []
  type: TYPE_NORMAL
  zh: '*字典* 也是一种值的集合，但与有序索引的数组不同，每个值都有自己的 *键*。由于没有索引，值不会以任何特定的顺序存储。要访问字典中的值，你需要通过其键来查找。'
- en: A key must be unique. You can’t have the same key more than once in the same
    dictionary. If there were two identical keys and you asked the computer to give
    you the value for one of them, the computer wouldn’t know which one to choose!
  id: totrans-1518
  prefs: []
  type: TYPE_NORMAL
  zh: 键必须是唯一的。在同一个字典中，不能有相同的键。如果存在两个相同的键，你请求计算机给你其中一个键的值时，计算机将无法知道选择哪个！
- en: Let’s take a look at how to make a dictionary and write keys that will help
    you find all the information you need.
  id: totrans-1519
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如何创建一个字典并编写键，以帮助你找到所需的所有信息。
- en: '![Image](Image00140.jpg)'
  id: totrans-1520
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Image00140.jpg)'
- en: '**INITIALIZING A DICTIONARY**'
  id: totrans-1521
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**初始化字典**'
- en: 'To create and initialize a dictionary, first write var and the name of your
    dictionary. Then write the keys and corresponding values inside a pair of square
    brackets, similar to an array. Let’s create a dictionary to store the names of
    a few US states. The key for each state will be its two-letter abbreviation:'
  id: totrans-1522
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建并初始化字典，首先写上 `var` 和字典的名称。然后在一对方括号中写上键和值对，就像数组一样。让我们创建一个字典来存储一些美国州的名称。每个州的键将是其两字母的缩写：
- en: '![](Image00141.jpg)'
  id: totrans-1523
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00141.jpg)'
- en: As you can see, there’s a colon between each key and its value, and the key/value
    pairs are separated by commas.
  id: totrans-1524
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，每个键和值之间有一个冒号，键值对之间用逗号分隔。
- en: Dictionaries are different from arrays in that they are *unordered* . Because
    of that, it’s likely that the order of the states that you see in your results
    pane ➋ is different from the order in which you entered your states ➊ . It might
    even be different than the order that’s printed in this book!
  id: totrans-1525
  prefs: []
  type: TYPE_NORMAL
  zh: 字典与数组的不同之处在于它们是*无序的*。因此，你在结果面板➋中看到的状态顺序可能与输入状态的顺序➊不同，甚至可能与书中打印的顺序不同！
- en: As with arrays, you can use var to make a mutable dictionary or use let to make
    an immutable dictionary.
  id: totrans-1526
  prefs: []
  type: TYPE_NORMAL
  zh: 与数组一样，你可以使用 `var` 来创建一个可变字典，或使用 `let` 来创建一个不可变字典。
- en: 'In Swift, all of the keys of a dictionary must be the same type, and all of
    the values of a dictionary must also be the same type, but the key type doesn’t
    have to match the value type. For example, if you wanted to store a collection
    of fractions, you could use doubles for the keys and strings for the values:'
  id: totrans-1527
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Swift 中，字典的所有键必须是相同类型，字典的所有值也必须是相同类型，但键的类型不必与值的类型匹配。例如，如果你想存储一组分数，你可以将键使用
    `double` 类型，值使用 `string` 类型：
- en: '![](Image00142.jpg)'
  id: totrans-1528
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00142.jpg)'
- en: In this dictionary, all of the keys must be doubles, and all of the values must
    be strings. Again, you’ll see that the order of the numbers in the results pane
    can be quite different from the order in which you wrote the fractions in your
    dictionary. This is fine because you don’t need to know the order to access anything.
    You can find any item that you need by its key. Let’s see how!
  id: totrans-1529
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个字典中，所有的键必须是 `double` 类型，所有的值必须是 `string` 类型。同样，你会发现结果面板中的数字顺序可能与在字典中编写分数时的顺序大不相同。这没问题，因为你不需要知道顺序就能访问任何项。你可以通过键来查找需要的任何项。让我们来看一下如何操作！
- en: '**ACCESSING VALUES IN A DICTIONARY**'
  id: totrans-1530
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**访问字典中的值**'
- en: 'Looking up a value in a dictionary is similar to how you access a value in
    an array except that you use a key inside the square brackets instead of an index,
    like this: usStates["TX"] .'
  id: totrans-1531
  prefs: []
  type: TYPE_NORMAL
  zh: 在字典中查找值类似于在数组中访问值，只不过你使用的是方括号中的键，而不是索引，像这样：usStates["TX"]。
- en: There is a big difference, however, in how Swift returns the values from a dictionary.
    When you access a value at an index of an array, you are simply given the value.
    When you access a value with a key in a dictionary, you are given an optional.
  id: totrans-1532
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，Swift 返回字典值的方式有一个很大的区别。当你访问数组中的某个索引时，你会直接获得该值。当你使用键访问字典中的值时，你将获得一个可选值。
- en: In [Chapter 5](text00015.html#ch05) , you learned that optionals might contain
    a value or might be nil . The reason Swift returns optionals when you’re looking
    up items in a dictionary is that the key you used might not exist in the dictionary,
    in which case there’s no value to access. Trying to access a value that doesn’t
    exist would give you a big fat error! To avoid that problem, Swift returns optionals.
    That means you need to unwrap any value you get out of a dictionary before you
    can do anything with it.
  id: totrans-1533
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第 5 章](text00015.html#ch05)中，你学到了可选值可能包含值，也可能是 nil。Swift 在查找字典中的项时返回可选值的原因是，你使用的键可能在字典中不存在，在这种情况下就没有值可供访问。试图访问一个不存在的值会导致严重错误！为了避免这个问题，Swift
    返回可选值。这意味着你需要在使用从字典中取出的值之前进行解包。
- en: 'To unwrap an optional, first you check whether it exists using an if-let statement,
    just like we did in [Chapter 5](text00015.html#ch05) . The following code shows
    you how to get a value out of a dictionary:'
  id: totrans-1534
  prefs: []
  type: TYPE_NORMAL
  zh: 要解包一个可选值，首先你需要通过 `if-let` 语句检查它是否存在，就像我们在[第 5 章](text00015.html#ch05)中所做的那样。下面的代码展示了如何从字典中获取一个值：
- en: '![Image](Image00143.jpg)'
  id: totrans-1535
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00143.jpg)'
- en: To retrieve "Texas" from the dictionary, we use if let to set a constant loneStarState
    to usStates["TX"] ➊ . Because we have this state in our dictionary, the line I
    have Texas in my dictionary. is printed. Next we try to access a state that is
    not in our dictionary by using the key usStates["FL"] ➋ . Thankfully, because
    we used an if-let statement, the program won’t crash when the computer can’t find
    this state. Instead, I don't have that state in my dictionary. is printed.
  id: totrans-1536
  prefs: []
  type: TYPE_NORMAL
  zh: 要从字典中检索 "Texas"，我们使用 `if let` 语句将常量 `loneStarState` 设置为 `usStates["TX"]` ➊ 。因为字典中有这个州，所以输出
    "I have Texas in my dictionary."。接下来，我们尝试通过使用键 `usStates["FL"]` ➋ 来访问一个字典中没有的州。幸运的是，由于我们使用了
    `if-let` 语句，当计算机无法找到这个州时，程序不会崩溃。相反，输出 "I don't have that state in my dictionary."。
- en: '**ADDING ITEMS TO A DICTIONARY**'
  id: totrans-1537
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**向字典中添加项目**'
- en: 'To add an item to a dictionary, first write the name of your dictionary and
    assign the new item to the key you want it to have in the dictionary. Let’s add
    "Minnesota" to our usStates dictionary:'
  id: totrans-1538
  prefs: []
  type: TYPE_NORMAL
  zh: 要向字典中添加一个项，首先写下字典的名称，并将新项赋值给你希望它在字典中拥有的键。让我们将 "Minnesota" 添加到我们的 `usStates`
    字典中：
- en: '![](Image00144.jpg)'
  id: totrans-1539
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00144.jpg)'
- en: 'Now when you look at usStates , you’ll see that it’s updated to ["MN": "Minnesota",
    "WA": "Washington", "MA": "Massachusetts", "TX": "Texas"] . Remember, because
    you don’t have to rely on indices, your new dictionary item might appear anywhere
    in the dictionary.'
  id: totrans-1540
  prefs: []
  type: TYPE_NORMAL
  zh: '当你查看 `usStates` 时，你会看到它已更新为 ["MN": "Minnesota", "WA": "Washington", "MA": "Massachusetts",
    "TX": "Texas"] 。记住，因为你不需要依赖索引，所以新的字典项可能出现在字典中的任何位置。'
- en: '**REMOVING ITEMS FROM A DICTIONARY**'
  id: totrans-1541
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**从字典中删除项目**'
- en: Removing an item from a dictionary is quite simple; you do so by setting the
    value to nil . Because the values in dictionaries are returned as optionals, you
    don’t have to worry about nil causing any problems in your dictionary.
  id: totrans-1542
  prefs: []
  type: TYPE_NORMAL
  zh: 从字典中删除项非常简单；你只需将值设置为 nil 。由于字典中的值是作为可选项返回的，因此你不需要担心 nil 会在字典中引发问题。
- en: '![](Image00145.jpg)'
  id: totrans-1543
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00145.jpg)'
- en: 'You can see that after you remove the value at the key "MA" , usStates is updated
    to ["MN": "Minnesota", "WA": "Washington", "TX": "Texas"] . Remember that nil
    is special and means that there’s no value at all. That’s why you don’t see "MA":
    nil in our dictionary.'
  id: totrans-1544
  prefs: []
  type: TYPE_NORMAL
  zh: '你可以看到，在移除键 "MA" 对应的值后，`usStates` 被更新为 ["MN": "Minnesota", "WA": "Washington",
    "TX": "Texas"] 。记住，nil 是特殊的，意味着没有任何值。这就是为什么在我们的字典中你看不到 "MA": nil。'
- en: '**REPLACING ITEMS IN A DICTIONARY**'
  id: totrans-1545
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**在字典中替换项目**'
- en: 'Replacing an item in a dictionary is also easy. It works the same was as replacing
    an item in an array. You just set the item that you want to replace to something
    else. Say you create a dictionary of fruit colors:'
  id: totrans-1546
  prefs: []
  type: TYPE_NORMAL
  zh: 在字典中替换项目也很容易。它的工作原理与替换数组中的项目相同。你只需将要替换的项设置为其他值。例如，假设你创建了一个水果颜色的字典：
- en: '![](Image00146.jpg)'
  id: totrans-1547
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00146.jpg)'
- en: At first we had the value "apple" for "red" , but then we decided that "raspberry"
    is a better fruit to use since sometimes apples are green or yellow. To replace
    "apple" with "raspberry" , we set colorFruits["red"] to its new value ➊ .
  id: totrans-1548
  prefs: []
  type: TYPE_NORMAL
  zh: 一开始我们为 "red" 设置了值 "apple" ，但后来我们决定使用 "raspberry" 更好，因为有时候苹果是绿色或黄色的。要将 "apple"
    替换为 "raspberry" ，我们将 `colorFruits["red"]` 设置为它的新值 ➊ 。
- en: You may remember that this is the same way we entered a new value into a dictionary.
    If the key already exists in the dictionary, then the value for that key is replaced.
    If the key doesn’t already exist, then the new key/value pair will be added to
    the dictionary.
  id: totrans-1549
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能还记得这与我们向字典中输入新值的方式相同。如果键已经存在于字典中，那么该键的值会被替换。如果键不存在，那么新的键/值对将被添加到字典中。
- en: '![Image](Image00147.jpg)'
  id: totrans-1550
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00147.jpg)'
- en: '**USING DICTIONARY PROPERTIES**'
  id: totrans-1551
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**使用字典属性**'
- en: 'Like an array, a dictionary also has an isEmpty property and a count property.
    For example, the following code shows how you can use the isEmpty property to
    check if a dictionary is empty, and if it isn’t empty, the count property checks
    how many items you have. Imagine you have a basket of fruit for sale. You can
    use these properties to help you keep track of everything:'
  id: totrans-1552
  prefs: []
  type: TYPE_NORMAL
  zh: 和数组一样，字典也有 `isEmpty` 属性和 `count` 属性。例如，以下代码展示了如何使用 `isEmpty` 属性检查字典是否为空，如果字典不为空，则使用
    `count` 属性检查你有多少项。假设你有一个水果篮子在出售。你可以使用这些属性帮助你跟踪所有物品：
- en: '![Image](Image00148.jpg)'
  id: totrans-1553
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00148.jpg)'
- en: 'A dictionary also has two special properties: keys , which contains all of
    the dictionary’s keys, and values , which contains all of its values. We’ll use
    these two properties when we loop through the dictionary.'
  id: totrans-1554
  prefs: []
  type: TYPE_NORMAL
  zh: 字典还有两个特殊的属性：`keys` ，它包含字典的所有键，和 `values` ，它包含字典的所有值。我们将在遍历字典时使用这两个属性。
- en: Let’s write some code that loops through our fruit baskets and prints the price
    of each fruit.
  id: totrans-1555
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们编写一些代码，循环遍历我们的水果篮子并打印每种水果的价格。
- en: '**LOOPING OVER A DICTIONARY**'
  id: totrans-1556
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**遍历字典**'
- en: 'You can loop through a dictionary using a for-in loop. Because each item has
    a key and a value, you can do this in two different ways. This is how to loop
    through a dictionary using its keys:'
  id: totrans-1557
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用 for-in 循环遍历字典。因为每个项目都有一个键和一个值，所以可以用两种不同的方式来做这件事。这是如何使用其键遍历字典的方法：
- en: '![Image](Image00149.jpg)'
  id: totrans-1558
  prefs: []
  type: TYPE_IMG
  zh: '![图像](Image00149.jpg)'
- en: Here we use the dictionary’s keys property ➊ to loop through fruitBasket and
    print its contents. We start by writing the keyword for , followed by a constant
    name fruit for the dictionary key, the keyword in , the dictionary name, a period,
    and keys .
  id: totrans-1559
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们使用字典的 keys 属性 ➊ 遍历 fruitBasket 并打印其内容。我们首先编写关键字 for ，然后是一个常量名 fruit ，用于字典键，关键字
    in ，字典名称，一个句点和 keys 。
- en: Inside the braces of our for-in loop, we have access to both the key, which
    we call fruit ➋ , and the value at that key when we force-unwrap its contents
    with fruitBasket[fruit]! ➌ . That value will be the fruit’s price.
  id: totrans-1560
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的 for-in 循环的大括号中，我们既可以访问键，我们称之为 fruit ➋ ，也可以在使用 fruitBasket[fruit]! ➌ 强制解包其内容时访问该键的值。该值将是水果的价格。
- en: In this case, it’s safe to force-unwrap the value using an exclamation point
    because we know that the fruit key we’re using is definitely inside the dictionary.
  id: totrans-1561
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们可以安全地使用感叹号来强制解包值，因为我们知道我们使用的水果键肯定在字典中。
- en: Any code we put inside the for-in loop will run once for every key in our dictionary.
    So you should see the print statement display three times.
  id: totrans-1562
  prefs: []
  type: TYPE_NORMAL
  zh: 我们放入 for-in 循环中的任何代码将对我们字典中的每个键运行一次。因此，您应该看到打印语句显示三次。
- en: 'We can also loop through the dictionary using its values property:'
  id: totrans-1563
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以使用其值属性遍历字典：
- en: '![Image](Image00150.jpg)'
  id: totrans-1564
  prefs: []
  type: TYPE_IMG
  zh: '![图像](Image00150.jpg)'
- en: We use the same style of for-in loop, but now we use a constant to refer to
    each value, which we call price , in the values property. When looping through
    values, we don’t have access to the keys from inside the loop.
  id: totrans-1565
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用相同的 for-in 循环样式，但现在我们使用一个常量来引用每个值，我们称之为 price ，在 values 属性中。在循环值时，我们无法从内部访问键。
- en: Another difference to note is that price is not an optional because it’s accessed
    directly as a value in the fruitBasket dictionary. That means we don’t have to
    unwrap it. You should still see the print statement printed three times. [Figure
    6-6](text00016.html#ch06fig6) shows the output of both loops.
  id: totrans-1566
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个要注意的区别是价格不是可选的，因为它直接作为 fruitBasket 字典中的值访问。这意味着我们不必解包它。您仍然应该看到打印语句打印三次。[图
    6-6](text00016.html#ch06fig6) 显示了两个循环的输出。
- en: '![Image](Image00151.jpg)'
  id: totrans-1567
  prefs: []
  type: TYPE_IMG
  zh: '![图像](Image00151.jpg)'
- en: '*Figure 6-6: Looping through the keys and values of a dictionary with a for-in
    loop*'
  id: totrans-1568
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 6-6：使用 for-in 循环遍历字典的键和值*'
- en: The order of your results might be slightly different from ours. That’s because
    the items in a dictionary aren’t in a numbered order like they are in an array!
    And because the order is not guaranteed, you might see a different order printed
    if you run the same code again.
  id: totrans-1569
  prefs: []
  type: TYPE_NORMAL
  zh: 您的结果顺序可能与我们的略有不同。这是因为字典中的项目不像数组中那样按编号顺序排列！并且因为顺序不是保证的，如果您再次运行相同的代码，可能会看到不同的顺序打印。
- en: '**WHAT YOU LEARNED**'
  id: totrans-1570
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**你学到了什么**'
- en: In this chapter, you learned how to store collections of items in an array and
    in a dictionary. To store items in an ordered list, you would use an array and
    look up each item by its index. If you wanted to store items by key instead, you
    would use a dictionary.
  id: totrans-1571
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，您学习了如何在数组和字典中存储项目集合。要在有序列表中存储项目，您将使用数组，并通过其索引查找每个项目。如果您想按键存储项目，那么将使用字典。
- en: Knowing about arrays and dictionaries and how to use them is a powerful building
    block for almost any programming language. Next we will learn about functions,
    another very powerful tool. Functions are blocks of code that you create and name
    to perform a specific job. After you have written a function, you can use its
    name to call it from almost anywhere in your program.
  id: totrans-1572
  prefs: []
  type: TYPE_NORMAL
  zh: 了解数组和字典以及如何使用它们是几乎任何编程语言的强大基础模块。接下来，我们将学习另一个非常强大的工具——函数。函数是您创建并命名以执行特定任务的代码块。编写函数后，您可以使用其名称从程序中的几乎任何地方调用它。
- en: '![Image](Image00115.jpg)'
  id: totrans-1573
  prefs: []
  type: TYPE_IMG
  zh: '![图像](Image00115.jpg)'
- en: '*Figure 6-1: The nationalParks array*'
  id: totrans-1574
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 6-1：nationalParks 数组*'
- en: '**USING MUTABLE AND IMMUTABLE ARRAYS**'
  id: totrans-1575
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**使用可变和不可变数组**'
- en: Our nationalParks array is a variable because we created it with the var keyword
    ➊ . An array stored in a variable is called a *mutable* array. This means that
    you can change it by adding items, removing items, or swapping items in and out.
  id: totrans-1576
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的nationalParks数组是一个变量，因为我们使用var关键字创建了它 ➊。存储在变量中的数组被称为*可变*数组。这意味着你可以通过添加、删除或交换项来更改它。
- en: You can also create an *immutable* array. An immutable array is created with
    the keyword let instead of var . Similar to a constant, once an immutable array
    is created, nothing in it can be changed.
  id: totrans-1577
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以创建一个*不可变*数组。不可变数组是使用let关键字而不是var创建的。与常量类似，一旦创建了不可变数组，它其中的内容就不能再更改。
- en: So when should you use a mutable array or an immutable array? It’s best to use
    let if you know your collection will never change, like if you’re storing the
    colors of the rainbow. You should use var if you need to change your collection,
    like if you’re storing an array of your favorite T-shirts, which might change
    depending on what’s in style!
  id: totrans-1578
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，什么时候应该使用可变数组或不可变数组呢？如果你知道你的集合永远不会改变，例如你正在存储彩虹的颜色，最好使用let。如果你需要更改你的集合，比如存储你最喜欢的T恤的数组，这可能会根据流行趋势而变化，那么你应该使用var。
- en: '![Image](Image00116.jpg)'
  id: totrans-1579
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00116.jpg)'
- en: '**USING TYPE INFERENCE**'
  id: totrans-1580
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**使用类型推断**'
- en: 'When we created our nationalParks array, we specified that we were creating
    an array of string values by adding a colon (: ) and [String] ➋ . This step is
    optional when you create an array and initialize it with one or more values because
    Swift will use type inference to determine the kind of data you want the array
    to hold. That means that you could just as easily have created the array by doing
    this:'
  id: totrans-1581
  prefs: []
  type: TYPE_NORMAL
  zh: '当我们创建nationalParks数组时，我们指定了我们正在创建一个包含字符串值的数组，通过添加冒号(: )和[String] ➋。当你创建数组并用一个或多个值初始化它时，这一步是可选的，因为Swift会使用类型推断来确定你想让数组存储的数据类型。这意味着你也可以像这样创建数组：'
- en: '![](Image00117.jpg)'
  id: totrans-1582
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00117.jpg)'
- en: Using type inference, Swift knows we initialized this array to hold strings,
    and it can hold only strings.
  id: totrans-1583
  prefs: []
  type: TYPE_NORMAL
  zh: 使用类型推断，Swift知道我们初始化了一个数组来存储字符串，而且它只能存储字符串。
- en: The list of parks that we created the array with is an example of an array *literal*
    . A literal is a value that is exactly what you see. It is not a variable or constant
    but rather just the value without a name. "Grand Canyon" is an example of a string
    literal, and 7 is an example of an integer literal. An array literal is a list
    of items contained between two square brackets and separated by commas, like ["Acadia",
    "Zion", "Grand Canyon"] ➊ .
  id: totrans-1584
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建的包含公园的数组是一个*字面量*数组的示例。字面量是一个值，它正是你所看到的内容。它不是变量或常量，而仅仅是没有名字的值。“Grand Canyon”是字符串字面量的一个例子，7是整数字面量的一个例子。数组字面量是一个项的列表，项被包含在两个方括号之间并用逗号分隔，像这样：["Acadia",
    "Zion", "Grand Canyon"] ➊。
- en: '**ACCESSING ITEMS IN AN ARRAY**'
  id: totrans-1585
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**访问数组中的项**'
- en: 'Let’s say you want to access an item in your array and use it in your program.
    Your friend asks you to tell them all about your travels, so you want to use the
    names of the national parks that you stored in the array. To access an item in
    your array, write the array name followed by the item’s index inside square brackets:'
  id: totrans-1586
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你想访问数组中的一项并在你的程序中使用它。你的朋友问你能不能讲讲你的旅行经历，于是你想用你存储在数组中的国家公园的名字。要访问数组中的一项，写出数组的名称，后跟该项的索引，索引放在方括号内：
- en: '![](Image00118.jpg)'
  id: totrans-1587
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00118.jpg)'
- en: In this example, we are accessing the names of the national parks and then printing
    them to the screen using print . To get the first item in nationalParks , you
    use nationalParks[0] ➊ . To access the second item in nationalParks , you use
    nationalParks[1] .
  id: totrans-1588
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们访问了国家公园的名字，然后使用print将它们打印到屏幕上。要获取nationalParks中的第一个项，可以使用nationalParks[0]
    ➊。要访问nationalParks中的第二个项，可以使用nationalParks[1]。
- en: '**WATCHING THE RANGE**'
  id: totrans-1589
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**观察范围**'
- en: One important point about arrays is that if you try to access an item at an
    index that’s higher than the last index in the array, you’ll get an error. In
    [Figure 6-2](text00016.html#ch06fig2) , you can see that nationalParks[3] (which
    would be the fourth item in the array) gives you an error because there are only
    three national parks in the array, indexed from 0 to 2.
  id: totrans-1590
  prefs: []
  type: TYPE_NORMAL
  zh: 关于数组有一个重要的点是，如果你尝试访问一个索引超出数组最后一个索引的项，你将会遇到错误。在[图6-2](text00016.html#ch06fig2)中，你可以看到nationalParks[3]（这应该是数组中的第四个项）会导致错误，因为数组中只有三个国家公园，索引从0到2。
- en: As you can see, you get an error message that says Index out of range . If you
    try to access an item that doesn’t exist in your array, your app will crash!
  id: totrans-1591
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，你会收到一条错误信息，显示“索引超出范围”。如果你尝试访问数组中不存在的项，应用程序会崩溃！
- en: '![Image](Image00119.jpg)'
  id: totrans-1592
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00119.jpg)'
- en: '*Figure 6-2: Trying to access an index in the array where nothing exists causes
    an error.*'
  id: totrans-1593
  prefs: []
  type: TYPE_NORMAL
  zh: '*图6-2：尝试访问数组中不存在的索引会导致错误。*'
- en: '**ADDING ITEMS TO AN ARRAY**'
  id: totrans-1594
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**向数组添加项**'
- en: One way to change an array is to add new items to it. There are a few different
    ways to do this, so let’s take a look at each.
  id: totrans-1595
  prefs: []
  type: TYPE_NORMAL
  zh: 更改数组的一种方法是向其中添加新项。有几种不同的方法可以做到这一点，接下来让我们看看每种方法。
- en: 'First, you can use an array’s append(_:) method. *Append* means to add something.
    Using append(_:) , you can add one new item to the end of your array. Say you
    go on another trip and visit the Badlands, and you want to add it to your list
    of national parks. To do that, add this code into your playground:'
  id: totrans-1596
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，你可以使用数组的append(_:)方法。*Append*意思是添加某物。使用append(_:)方法，你可以将一个新项添加到数组的末尾。假设你去了一次新的旅行，访问了Badlands，并且想要将它添加到你的国家公园列表中。为了做到这一点，向你的游乐场代码中添加以下内容：
- en: '![](Image00120.jpg)'
  id: totrans-1597
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00120.jpg)'
- en: To use the append(_:) method, first write the name of your array followed by
    a period and then append . Then, put the item you want to add to your array inside
    the parentheses. In this case, you put "Badlands" inside the parentheses.
  id: totrans-1598
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用append(_:)方法，首先写下数组的名称，然后加上一个句点，再加上append。接着，将你想添加到数组的项放入括号内。在这种情况下，你将“Badlands”放入括号内。
- en: 'If you want to add something at a specific place in your array, use the array’s
    insert(_:at:) method instead. This method takes two arguments: the item that you
    want to insert and the index of where it should go in the array. (We’ll discuss
    arguments in more detail in [Chapter 7](text00017.html#ch07) .)'
  id: totrans-1599
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想在数组的特定位置添加项，使用数组的insert(_:at:)方法。这个方法接受两个参数：你想插入的项和它在数组中应该放置的位置索引。（我们将在[第7章](text00017.html#ch07)中更详细地讨论参数。）
- en: 'Let’s say you totally forgot that you went to the Petrified Forest right after
    you visited the Grand Canyon, and you want to update your nationalParks array
    so it displays the parks in the order in which you visited them. To update your
    array, you could use the insert(_:at:) method to put the Petrified Forest in the
    right position:'
  id: totrans-1600
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你完全忘记了你在访问Grand Canyon之后去过Petrified Forest，而你想更新nationalParks数组，以便它按你访问公园的顺序显示。要更新数组，你可以使用insert(_:at:)方法将Petrified
    Forest放到正确的位置：
- en: '![](Image00121.jpg)'
  id: totrans-1601
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00121.jpg)'
- en: When you insert a new item at index 3, everything that was in the array at index
    3 or higher gets scooted over to make room for the new item. That means the item
    that was at index 3 is now at index 4, the item that was at index 4 is now at
    index 5, and so on. After you add the Petrified Forest, nationalParks is now ["Acadia",
    "Zion", "Grand Canyon", "Petrified Forest", "Badlands"] .
  id: totrans-1602
  prefs: []
  type: TYPE_NORMAL
  zh: 当你在索引3处插入新项时，数组中索引3及更高位置的所有项都会向后移动，为新项腾出空间。这意味着，原本在索引3处的项现在位于索引4处，原本在索引4处的项现在位于索引5处，以此类推。在你添加了“Petrified
    Forest”之后，nationalParks数组变为["Acadia", "Zion", "Grand Canyon", "Petrified Forest",
    "Badlands"]。
- en: '**COMBINING ARRAYS**'
  id: totrans-1603
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**合并数组**'
- en: 'Not only can you add new items to an array, but you can also add two arrays
    together using the + and += operators. Let’s say that you have the ingredients
    for a fruit smoothie in two arrays:'
  id: totrans-1604
  prefs: []
  type: TYPE_NORMAL
  zh: 你不仅可以向数组添加新项，还可以使用+和+=运算符将两个数组合并在一起。假设你有两个数组，分别是制作水果冰沙的原料：
- en: '![](Image00122.jpg)'
  id: totrans-1605
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00122.jpg)'
- en: Now you can make a delicious smoothie by adding the fruits and liquids arrays.
  id: totrans-1606
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你可以通过添加水果和液体数组来制作美味的冰沙。
- en: '![](Image00123.jpg)'
  id: totrans-1607
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00123.jpg)'
- en: The order of the ingredients in smoothie is the same as the order in fruits
    and liquids . If you created smoothie with liquids + fruits , then the liquids
    would come first.
  id: totrans-1608
  prefs: []
  type: TYPE_NORMAL
  zh: 冰沙中原料的顺序与水果和液体中的顺序相同。如果你用liquids + fruits创建冰沙，那么液体会先放进去。
- en: 'You use the += operator to add an array to the end of your array. Add some
    whipped cream as follows for extra yumminess:'
  id: totrans-1609
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用+=运算符将一个数组添加到另一个数组的末尾。为了增加额外的美味，按如下方式添加一些奶油：
- en: '![](Image00124.jpg)'
  id: totrans-1610
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00124.jpg)'
- en: Note that ["whipped cream"] is an array even though it has a single item in
    it. When you’re using += to append something to an array, you have to make sure
    you’re only trying to add another array. If you were to just write the string
    "whipped cream" without the square brackets around it, you would get an error.
  id: totrans-1611
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，["whipped cream"]是一个数组，尽管它只有一个元素。当你使用+=运算符将某物添加到数组时，必须确保你只在添加另一个数组。如果你只是写下字符串“whipped
    cream”而没有方括号，程序会报错。
- en: '![Image](Image00125.jpg)'
  id: totrans-1612
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00125.jpg)'
- en: '**REMOVING ITEMS FROM AN ARRAY**'
  id: totrans-1613
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**从数组中移除项目**'
- en: 'There are several methods for removing items from an array. Let’s start by
    looking at the array’s removeLast() method. As you might have guessed from its
    name, removeLast() removes the last item from your array. Let’s try it out with
    a shoppingList array:'
  id: totrans-1614
  prefs: []
  type: TYPE_NORMAL
  zh: 删除数组中项目的方法有几种。首先我们来看数组的removeLast()方法。正如你从它的名字中可能猜到的那样，removeLast()会删除数组中的最后一个项目。我们可以在shoppingList数组上试一下：
- en: '![](Image00126.jpg)'
  id: totrans-1615
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00126.jpg)'
- en: Neat! Note that the removeLast() method returns the removed item, so you can
    store it in a new constant or variable if you want.
  id: totrans-1616
  prefs: []
  type: TYPE_NORMAL
  zh: 很棒！注意，removeLast()方法会返回被移除的项目，因此如果你愿意，可以将其存储在一个新的常量或变量中。
- en: 'You can also remove an item from a specific index by using the remove(at:)
    method. Let’s say that your mom doesn’t want you buying any candy and takes that
    off the list:'
  id: totrans-1617
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以使用remove(at:)方法从指定的索引中删除一个项目。假设你的妈妈不希望你买糖果，并把它从列表中拿掉：
- en: '![Image](Image00127.jpg)![](Image00128.jpg)'
  id: totrans-1618
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00127.jpg)![](Image00128.jpg)'
- en: Just like when we added an item to the middle of our array and all the items
    scooted over to make room, if you remove an item from the middle of an array,
    the rest of the items will scoot back to fill in that empty space. The "apples"
    item that was at index 3 is now at index 2, where "candy" was.
  id: totrans-1619
  prefs: []
  type: TYPE_NORMAL
  zh: 就像我们在数组中间添加一个项目时，所有其他项目都会向后挪动以腾出空间一样，如果你从数组的中间删除一个项目，其他的项目也会向前挪动以填补那个空位。原来位于索引3的“苹果”项目现在位于索引2的位置，这里原本是“糖果”。
- en: 'You can also remove all items from an array with removeAll() . Try entering
    this into your playground:'
  id: totrans-1620
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以使用removeAll()方法删除数组中的所有项目。在你的 playground 中试试看：
- en: '![](Image00129.jpg)'
  id: totrans-1621
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00129.jpg)'
- en: 'Note that trying to remove an item at an index that doesn’t exist will give
    you an error:'
  id: totrans-1622
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，尝试删除一个不存在的索引位置的项目会导致错误：
- en: '![](Image00130.jpg)'
  id: totrans-1623
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00130.jpg)'
- en: Our array doesn’t have this many items (in fact, now it’s empty!), so this throws
    an error. We’ll also get an error if we use removeLast() on our empty array, because
    there’s nothing in it—there’s no last index at all! However, removeAll() is always
    safe to use, even on an empty array.
  id: totrans-1624
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的数组并没有这么多项目（事实上，现在它是空的！），因此这会抛出一个错误。如果我们对空数组使用removeLast()，也会报错，因为数组里没有任何元素——根本没有最后一个索引！不过，removeAll()方法总是安全的，即使在空数组上也可以使用。
- en: '**REPLACING ITEMS IN AN ARRAY**'
  id: totrans-1625
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**替换数组中的项目**'
- en: 'To replace an item in an array, you set the index of the array to the new value,
    as shown here:'
  id: totrans-1626
  prefs: []
  type: TYPE_NORMAL
  zh: 要替换数组中的一个项目，你只需将数组的索引设置为新值，如下所示：
- en: '![](Image00131.jpg)'
  id: totrans-1627
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00131.jpg)'
- en: At ➊ , we replaced the item at index 2 (the third item) with "Unicorn" because
    magical animals count as favorite animals, too! At ➋ , we replaced the item at
    index 0 (the first item) with "Bearded dragon" . No, that’s not a real dragon—it’s
    just a lizard!
  id: totrans-1628
  prefs: []
  type: TYPE_NORMAL
  zh: 在 ➊ 位置，我们将索引2（第三个项目）处的元素替换为“独角兽”，因为魔法动物也算是最喜欢的动物！在 ➋ 位置，我们将索引0（第一个项目）处的元素替换为“鬃蜥”。不，这不是一只真正的龙——它只是一种蜥蜴！
- en: Like any time you’re working with array index numbers, you have to be sure an
    item exists in the array at that index before you change its value, or you will
    get an Index out of range error.
  id: totrans-1629
  prefs: []
  type: TYPE_NORMAL
  zh: 就像你在处理数组索引时一样，你必须确保在修改某个索引的值之前，数组中该位置已经有一个项目，否则你会遇到“索引超出范围”的错误。
- en: '[Figure 6-3](text00016.html#ch06fig3) shows the error that occurs if you try
    to add "Standard poodle" using favoriteAnimals[3] = "Standard poodle" . To add
    an item to the end of an array, you should use the append(_:) method or += , as
    we covered in “[Adding Items to an Array](text00016.html#ch06lev2sec5) ” on [page
    70](text00016.html#page_70) .'
  id: totrans-1630
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 6-3](text00016.html#ch06fig3)展示了如果你尝试通过favoriteAnimals[3] = "标准贵宾犬"来添加“标准贵宾犬”，会发生的错误。要将项目添加到数组的末尾，你应该使用append(_:)方法或+=，正如我们在“[添加项目到数组](text00016.html#ch06lev2sec5)”一节中讲到的，参见[第70页](text00016.html#page_70)。'
- en: '![Image](Image00132.jpg)'
  id: totrans-1631
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00132.jpg)'
- en: '*Figure 6-3: Don’t try to replace a value at an index beyond the existing array.*'
  id: totrans-1632
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 6-3：不要尝试替换一个超出现有数组范围的索引位置的值。*'
- en: Now you know how to change arrays however you might need to. You can add items,
    take items away, or replace items. Next, we’ll look at how to use the properties
    of arrays to find out even more information about them.
  id: totrans-1633
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你知道如何根据需要更改数组了。你可以添加项目、删除项目或替换项目。接下来，我们将看看如何使用数组的属性来了解更多关于数组的信息。
- en: '![Image](Image00133.jpg)'
  id: totrans-1634
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00133.jpg)'
- en: '**USING ARRAY PROPERTIES**'
  id: totrans-1635
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**使用数组属性**'
- en: In addition to methods like append(_:) and removeLast() , arrays also have *properties*
    . An array’s properties are variables or constants that contain some information
    about the array. Two really helpful properties that you might use are the Boolean
    property isEmpty and the integer property count .
  id: totrans-1636
  prefs: []
  type: TYPE_NORMAL
  zh: 除了像append(_:)和removeLast()这样的函数，数组还有*属性*。数组的属性是包含有关数组信息的变量或常量。有两个非常有用的属性是布尔值属性isEmpty和整数属性count。
- en: The isEmpty property is true or false depending on whether the array is empty,
    and the count property will tell you how many items are in that array.
  id: totrans-1637
  prefs: []
  type: TYPE_NORMAL
  zh: isEmpty属性根据数组是否为空返回true或false，而count属性将告诉你数组中有多少项。
- en: 'Check out how these two properties are used in the following if-else statement:'
  id: totrans-1638
  prefs: []
  type: TYPE_NORMAL
  zh: 看看以下if-else语句中如何使用这两个属性：
- en: '![Image](Image00134.jpg)'
  id: totrans-1639
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00134.jpg)'
- en: 'This if-else statement checks whether the array mySiblings is empty ➊ . If
    it is, then "I don''t have any siblings." is printed. But if there is something
    in the array, then the number of siblings that we have is printed: "I have 3 siblings."
    ➋ .'
  id: totrans-1640
  prefs: []
  type: TYPE_NORMAL
  zh: 这个if-else语句检查数组mySiblings是否为空 ➊。如果为空，则打印“我没有兄弟姐妹。”如果数组中有内容，则打印我们拥有的兄弟姐妹数量：“我有3个兄弟姐妹。”
    ➋。
- en: '**LOOPING OVER AN ARRAY**'
  id: totrans-1641
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**遍历数组**'
- en: 'Sometimes when you’re working with arrays you might want to do something to
    every item in the array. You can use a for-in loop to do that! The following code
    will print every topping in a pizzaToppings array on a separate line:'
  id: totrans-1642
  prefs: []
  type: TYPE_NORMAL
  zh: 有时候，当你在处理数组时，可能希望对数组中的每个项目做一些操作。你可以使用for-in循环来做到这一点！下面的代码将在pizzaToppings数组中为每个配料打印一行：
- en: '![Image](Image00135.jpg)'
  id: totrans-1643
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00135.jpg)'
- en: To write a for-in loop for the pizzaToppings array, we used the keyword for
    , followed by the constant topping , then the keyword in , and finally the name
    of our array, pizzaToppings . Then we put the statements that we want to run for
    each topping inside the braces of the for-in loop. The constant topping ➊ temporarily
    represents each pizza topping in the array as we loop through it. We could have
    chosen any name for this constant, but it’s a good idea to pick something that
    makes sense. You can see the output of this for-in loop in [Figure 6-4](text00016.html#ch06fig4)
    .
  id: totrans-1644
  prefs: []
  type: TYPE_NORMAL
  zh: 为了写一个适用于pizzaToppings数组的for-in循环，我们使用了关键字for，接着是常量topping，再是关键字in，最后是数组的名称pizzaToppings。然后，我们将想要为每个topping执行的语句放在for-in循环的大括号内。常量topping
    ➊临时表示数组中每个披萨配料，随着循环的进行，我们可以为这个常量选择任何名字，但选择一个有意义的名字是个好主意。你可以在[图6-4](text00016.html#ch06fig4)中看到这个for-in循环的输出。
- en: '![Image](Image00136.jpg)'
  id: totrans-1645
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00136.jpg)'
- en: '*Figure 6-4: Output of the example for-in loop*'
  id: totrans-1646
  prefs: []
  type: TYPE_NORMAL
  zh: '*图6-4：示例for-in循环的输出*'
- en: '![Image](Image00137.jpg)'
  id: totrans-1647
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00137.jpg)'
- en: 'Using for-in loops is great for printing every value in an array. If you’re
    working with numbers, you can even use them to perform math operations on each
    item, which makes for some speedy calculations! The following code takes an array
    of numbers and calculates the square for each (the square of a number is that
    number multiplied by itself):'
  id: totrans-1648
  prefs: []
  type: TYPE_NORMAL
  zh: 使用for-in循环打印数组中的每个值非常好。如果你处理的是数字，你甚至可以用它们对每个项目进行数学运算，这样就能快速进行计算！以下代码接收一个数字数组，并计算每个数字的平方（数字的平方是该数字乘以它自身）：
- en: '![Image](Image00138.jpg)'
  id: totrans-1649
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00138.jpg)'
- en: '[Figure 6-5](text00016.html#ch06fig5) shows the results.'
  id: totrans-1650
  prefs: []
  type: TYPE_NORMAL
  zh: '[图6-5](text00016.html#ch06fig5)展示了结果。'
- en: '![Image](Image00139.jpg)'
  id: totrans-1651
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00139.jpg)'
- en: '*Figure 6-5: Printing the squares for each number in the myNumbers array*'
  id: totrans-1652
  prefs: []
  type: TYPE_NORMAL
  zh: '*图6-5：打印myNumbers数组中每个数字的平方*'
- en: '**DICTIONARIES ARE KEY!**'
  id: totrans-1653
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**字典很重要！**'
- en: A *dictionary* is also a collection of values, but instead of an ordered index,
    each value has its own *key* . Because there’s no index, the values are not stored
    in any particular order. To access values in a dictionary, you look them up by
    their key.
  id: totrans-1654
  prefs: []
  type: TYPE_NORMAL
  zh: '*字典*也是一组值，但与有序索引不同，每个值都有自己的*键*。由于没有索引，这些值没有特定的存储顺序。要访问字典中的值，你需要通过它们的键来查找。'
- en: A key must be unique. You can’t have the same key more than once in the same
    dictionary. If there were two identical keys and you asked the computer to give
    you the value for one of them, the computer wouldn’t know which one to choose!
  id: totrans-1655
  prefs: []
  type: TYPE_NORMAL
  zh: 键必须是唯一的。你不能在同一个字典中使用相同的键。如果有两个相同的键，且你要求计算机给你其中一个键的值，计算机将不知道选择哪一个！
- en: Let’s take a look at how to make a dictionary and write keys that will help
    you find all the information you need.
  id: totrans-1656
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看如何创建一个字典并编写键值，帮助你找到所有需要的信息。
- en: '![Image](Image00140.jpg)'
  id: totrans-1657
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00140.jpg)'
- en: '**INITIALIZING A DICTIONARY**'
  id: totrans-1658
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**初始化字典**'
- en: 'To create and initialize a dictionary, first write var and the name of your
    dictionary. Then write the keys and corresponding values inside a pair of square
    brackets, similar to an array. Let’s create a dictionary to store the names of
    a few US states. The key for each state will be its two-letter abbreviation:'
  id: totrans-1659
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建和初始化一个字典，首先写上var和字典的名称。然后将键和值放在一对方括号内，类似于数组。让我们创建一个字典来存储一些美国州的名称。每个州的键将是它的两字母缩写：
- en: '![](Image00141.jpg)'
  id: totrans-1660
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00141.jpg)'
- en: As you can see, there’s a colon between each key and its value, and the key/value
    pairs are separated by commas.
  id: totrans-1661
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，每个键和值之间有一个冒号，键/值对之间用逗号分隔。
- en: Dictionaries are different from arrays in that they are *unordered* . Because
    of that, it’s likely that the order of the states that you see in your results
    pane ➋ is different from the order in which you entered your states ➊ . It might
    even be different than the order that’s printed in this book!
  id: totrans-1662
  prefs: []
  type: TYPE_NORMAL
  zh: 字典与数组不同，它们是*无序的*。因此，你在结果面板中看到的州的顺序➋可能与你输入州的顺序➊不同。它甚至可能与本书中打印的顺序不同！
- en: As with arrays, you can use var to make a mutable dictionary or use let to make
    an immutable dictionary.
  id: totrans-1663
  prefs: []
  type: TYPE_NORMAL
  zh: 和数组一样，你可以使用var来创建一个可变字典，或者使用let来创建一个不可变字典。
- en: 'In Swift, all of the keys of a dictionary must be the same type, and all of
    the values of a dictionary must also be the same type, but the key type doesn’t
    have to match the value type. For example, if you wanted to store a collection
    of fractions, you could use doubles for the keys and strings for the values:'
  id: totrans-1664
  prefs: []
  type: TYPE_NORMAL
  zh: 在Swift中，字典的所有键必须是相同的类型，所有的值也必须是相同的类型，但键的类型不一定与值的类型相匹配。例如，如果你想存储一组分数，你可以使用双精度浮点数作为键，字符串作为值：
- en: '![](Image00142.jpg)'
  id: totrans-1665
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00142.jpg)'
- en: In this dictionary, all of the keys must be doubles, and all of the values must
    be strings. Again, you’ll see that the order of the numbers in the results pane
    can be quite different from the order in which you wrote the fractions in your
    dictionary. This is fine because you don’t need to know the order to access anything.
    You can find any item that you need by its key. Let’s see how!
  id: totrans-1666
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个字典中，所有的键必须是双精度浮点数，所有的值必须是字符串。你会发现结果面板中数字的顺序可能与字典中分数的顺序不同。这是正常的，因为你不需要知道顺序就能访问任何项。你可以通过键找到任何你需要的项。我们来看看怎么做！
- en: '**ACCESSING VALUES IN A DICTIONARY**'
  id: totrans-1667
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**在字典中访问值**'
- en: 'Looking up a value in a dictionary is similar to how you access a value in
    an array except that you use a key inside the square brackets instead of an index,
    like this: usStates["TX"] .'
  id: totrans-1668
  prefs: []
  type: TYPE_NORMAL
  zh: 在字典中查找一个值类似于在数组中访问一个值，只不过你在方括号内使用的是键，而不是索引，像这样：usStates["TX"]。
- en: There is a big difference, however, in how Swift returns the values from a dictionary.
    When you access a value at an index of an array, you are simply given the value.
    When you access a value with a key in a dictionary, you are given an optional.
  id: totrans-1669
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，Swift从字典中返回值的方式有一个很大的区别。当你在数组的索引处访问一个值时，你只会得到值。而当你用键访问字典中的值时，你会得到一个可选项。
- en: In [Chapter 5](text00015.html#ch05) , you learned that optionals might contain
    a value or might be nil . The reason Swift returns optionals when you’re looking
    up items in a dictionary is that the key you used might not exist in the dictionary,
    in which case there’s no value to access. Trying to access a value that doesn’t
    exist would give you a big fat error! To avoid that problem, Swift returns optionals.
    That means you need to unwrap any value you get out of a dictionary before you
    can do anything with it.
  id: totrans-1670
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第5章](text00015.html#ch05)中，你学到过可选项可能包含一个值，也可能是nil。当你在字典中查找项时，Swift返回可选项的原因是你使用的键可能在字典中不存在，在这种情况下没有值可访问。尝试访问一个不存在的值会导致一个大错误！为了避免这个问题，Swift返回可选项。这意味着在你能对字典中的任何值进行操作之前，必须先解包它。
- en: 'To unwrap an optional, first you check whether it exists using an if-let statement,
    just like we did in [Chapter 5](text00015.html#ch05) . The following code shows
    you how to get a value out of a dictionary:'
  id: totrans-1671
  prefs: []
  type: TYPE_NORMAL
  zh: 要解包一个可选项，首先你需要使用if-let语句检查它是否存在，就像我们在[第5章](text00015.html#ch05)中做的那样。以下代码展示了如何从字典中获取一个值：
- en: '![Image](Image00143.jpg)'
  id: totrans-1672
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00143.jpg)'
- en: To retrieve "Texas" from the dictionary, we use if let to set a constant loneStarState
    to usStates["TX"] ➊ . Because we have this state in our dictionary, the line I
    have Texas in my dictionary. is printed. Next we try to access a state that is
    not in our dictionary by using the key usStates["FL"] ➋ . Thankfully, because
    we used an if-let statement, the program won’t crash when the computer can’t find
    this state. Instead, I don't have that state in my dictionary. is printed.
  id: totrans-1673
  prefs: []
  type: TYPE_NORMAL
  zh: 要从字典中获取"Texas"，我们使用if let将常量loneStarState设置为usStates["TX"] ➊。因为我们在字典中有这个州，所以会打印出"I
    have Texas in my dictionary."。接下来，我们尝试通过使用键usStates["FL"] ➋来访问一个不在字典中的州。幸运的是，由于我们使用了if-let语句，当计算机找不到该州时，程序不会崩溃。相反，会打印出"I
    don't have that state in my dictionary."。
- en: '**ADDING ITEMS TO A DICTIONARY**'
  id: totrans-1674
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**向字典添加项**'
- en: 'To add an item to a dictionary, first write the name of your dictionary and
    assign the new item to the key you want it to have in the dictionary. Let’s add
    "Minnesota" to our usStates dictionary:'
  id: totrans-1675
  prefs: []
  type: TYPE_NORMAL
  zh: 要向字典添加项，首先写出字典的名称，并将新项分配给你想要在字典中使用的键。让我们向usStates字典中添加"Minnesota"：
- en: '![](Image00144.jpg)'
  id: totrans-1676
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00144.jpg)'
- en: 'Now when you look at usStates , you’ll see that it’s updated to ["MN": "Minnesota",
    "WA": "Washington", "MA": "Massachusetts", "TX": "Texas"] . Remember, because
    you don’t have to rely on indices, your new dictionary item might appear anywhere
    in the dictionary.'
  id: totrans-1677
  prefs: []
  type: TYPE_NORMAL
  zh: '现在，当你查看usStates时，你会看到它已更新为["MN": "Minnesota", "WA": "Washington", "MA": "Massachusetts",
    "TX": "Texas"]。记住，由于你不需要依赖索引，新的字典项可能会出现在字典中的任何位置。'
- en: '**REMOVING ITEMS FROM A DICTIONARY**'
  id: totrans-1678
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**从字典中移除项**'
- en: Removing an item from a dictionary is quite simple; you do so by setting the
    value to nil . Because the values in dictionaries are returned as optionals, you
    don’t have to worry about nil causing any problems in your dictionary.
  id: totrans-1679
  prefs: []
  type: TYPE_NORMAL
  zh: 从字典中移除项非常简单；你只需将值设为nil。由于字典中的值作为可选项返回，因此你无需担心nil会在字典中引起任何问题。
- en: '![](Image00145.jpg)'
  id: totrans-1680
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00145.jpg)'
- en: 'You can see that after you remove the value at the key "MA" , usStates is updated
    to ["MN": "Minnesota", "WA": "Washington", "TX": "Texas"] . Remember that nil
    is special and means that there’s no value at all. That’s why you don’t see "MA":
    nil in our dictionary.'
  id: totrans-1681
  prefs: []
  type: TYPE_NORMAL
  zh: '你可以看到，在移除键"MA"对应的值之后，usStates被更新为["MN": "Minnesota", "WA": "Washington", "TX":
    "Texas"]。记住，nil是特殊的，意味着没有值。这就是为什么你在我们的字典中看不到"MA": nil。'
- en: '**REPLACING ITEMS IN A DICTIONARY**'
  id: totrans-1682
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**替换字典中的项**'
- en: 'Replacing an item in a dictionary is also easy. It works the same was as replacing
    an item in an array. You just set the item that you want to replace to something
    else. Say you create a dictionary of fruit colors:'
  id: totrans-1683
  prefs: []
  type: TYPE_NORMAL
  zh: 替换字典中的项也很容易。它的工作方式与替换数组中的项相同。你只需将想要替换的项设置为其他内容。假设你创建了一个水果颜色的字典：
- en: '![](Image00146.jpg)'
  id: totrans-1684
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00146.jpg)'
- en: At first we had the value "apple" for "red" , but then we decided that "raspberry"
    is a better fruit to use since sometimes apples are green or yellow. To replace
    "apple" with "raspberry" , we set colorFruits["red"] to its new value ➊ .
  id: totrans-1685
  prefs: []
  type: TYPE_NORMAL
  zh: 最初我们为"red"设置了"apple"这个值，但后来我们决定使用"raspberry"作为更好的水果，因为有时候苹果是绿色或黄色的。为了用"raspberry"替换"apple"，我们将colorFruits["red"]设置为新的值
    ➊。
- en: You may remember that this is the same way we entered a new value into a dictionary.
    If the key already exists in the dictionary, then the value for that key is replaced.
    If the key doesn’t already exist, then the new key/value pair will be added to
    the dictionary.
  id: totrans-1686
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能记得，这与我们将新值输入字典的方式相同。如果键已经存在于字典中，那么该键的值将被替换。如果键不存在，那么新的键值对将被添加到字典中。
- en: '![Image](Image00147.jpg)'
  id: totrans-1687
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00147.jpg)'
- en: '**USING DICTIONARY PROPERTIES**'
  id: totrans-1688
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**使用字典属性**'
- en: 'Like an array, a dictionary also has an isEmpty property and a count property.
    For example, the following code shows how you can use the isEmpty property to
    check if a dictionary is empty, and if it isn’t empty, the count property checks
    how many items you have. Imagine you have a basket of fruit for sale. You can
    use these properties to help you keep track of everything:'
  id: totrans-1689
  prefs: []
  type: TYPE_NORMAL
  zh: 和数组一样，字典也有isEmpty属性和count属性。例如，以下代码展示了如何使用isEmpty属性来检查字典是否为空，如果不为空，count属性会检查字典中有多少项。想象一下，你有一个水果篮子待售。你可以使用这些属性来帮助你跟踪一切：
- en: '![Image](Image00148.jpg)'
  id: totrans-1690
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00148.jpg)'
- en: 'A dictionary also has two special properties: keys , which contains all of
    the dictionary’s keys, and values , which contains all of its values. We’ll use
    these two properties when we loop through the dictionary.'
  id: totrans-1691
  prefs: []
  type: TYPE_NORMAL
  zh: 字典还有两个特殊属性：keys，包含字典的所有键，以及values，包含字典的所有值。我们在遍历字典时会使用这两个属性。
- en: Let’s write some code that loops through our fruit baskets and prints the price
    of each fruit.
  id: totrans-1692
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们编写一些代码，遍历我们的水果篮并打印每种水果的价格。
- en: '**LOOPING OVER A DICTIONARY**'
  id: totrans-1693
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**遍历字典**'
- en: 'You can loop through a dictionary using a for-in loop. Because each item has
    a key and a value, you can do this in two different ways. This is how to loop
    through a dictionary using its keys:'
  id: totrans-1694
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用 `for-in` 循环遍历字典。由于每个项目都有一个键和值，因此可以通过两种不同的方式来完成此操作。这是使用字典的键遍历字典的方式：
- en: '![Image](Image00149.jpg)'
  id: totrans-1695
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Image00149.jpg)'
- en: Here we use the dictionary’s keys property ➊ to loop through fruitBasket and
    print its contents. We start by writing the keyword for , followed by a constant
    name fruit for the dictionary key, the keyword in , the dictionary name, a period,
    and keys .
  id: totrans-1696
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们使用字典的 `keys` 属性 ➊ 来遍历 `fruitBasket` 并打印其内容。我们首先写下关键字 `for`，然后是字典键的常量名称
    `fruit`，接着是关键字 `in`，字典的名称，接着是一个句点和 `keys`。
- en: Inside the braces of our for-in loop, we have access to both the key, which
    we call fruit ➋ , and the value at that key when we force-unwrap its contents
    with fruitBasket[fruit]! ➌ . That value will be the fruit’s price.
  id: totrans-1697
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `for-in` 循环的大括号内，我们可以访问键（我们称之为 `fruit` ➋），并且在通过 `fruitBasket[fruit]!` 强制解包其内容后，访问该键对应的值
    ➌。该值将是水果的价格。
- en: In this case, it’s safe to force-unwrap the value using an exclamation point
    because we know that the fruit key we’re using is definitely inside the dictionary.
  id: totrans-1698
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，使用感叹号强制解包该值是安全的，因为我们知道我们使用的 `fruit` 键肯定存在于字典中。
- en: Any code we put inside the for-in loop will run once for every key in our dictionary.
    So you should see the print statement display three times.
  id: totrans-1699
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在 `for-in` 循环内编写的任何代码都会针对字典中的每个键运行一次。所以你应该看到 `print` 语句显示三次。
- en: 'We can also loop through the dictionary using its values property:'
  id: totrans-1700
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以通过字典的值属性来遍历字典：
- en: '![Image](Image00150.jpg)'
  id: totrans-1701
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Image00150.jpg)'
- en: We use the same style of for-in loop, but now we use a constant to refer to
    each value, which we call price , in the values property. When looping through
    values, we don’t have access to the keys from inside the loop.
  id: totrans-1702
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用相同的 `for-in` 循环方式，但现在我们使用一个常量来引用 `values` 属性中的每个值，我们将其称为 `price`。在遍历值时，我们无法从循环内访问键。
- en: Another difference to note is that price is not an optional because it’s accessed
    directly as a value in the fruitBasket dictionary. That means we don’t have to
    unwrap it. You should still see the print statement printed three times. [Figure
    6-6](text00016.html#ch06fig6) shows the output of both loops.
  id: totrans-1703
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个需要注意的区别是，`price` 不是一个可选值，因为它是直接作为 `fruitBasket` 字典中的值进行访问的。这意味着我们不需要解包它。你仍然应该看到
    `print` 语句打印三次。[图 6-6](text00016.html#ch06fig6) 显示了两个循环的输出结果。
- en: '![Image](Image00151.jpg)'
  id: totrans-1704
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Image00151.jpg)'
- en: '*Figure 6-6: Looping through the keys and values of a dictionary with a for-in
    loop*'
  id: totrans-1705
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 6-6: 使用 `for-in` 循环遍历字典的键和值*'
- en: The order of your results might be slightly different from ours. That’s because
    the items in a dictionary aren’t in a numbered order like they are in an array!
    And because the order is not guaranteed, you might see a different order printed
    if you run the same code again.
  id: totrans-1706
  prefs: []
  type: TYPE_NORMAL
  zh: 你的结果顺序可能与我们的略有不同。这是因为字典中的项不像数组那样有序！由于顺序无法保证，因此如果再次运行相同的代码，可能会看到不同的顺序。
- en: '**WHAT YOU LEARNED**'
  id: totrans-1707
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**你学到的内容**'
- en: In this chapter, you learned how to store collections of items in an array and
    in a dictionary. To store items in an ordered list, you would use an array and
    look up each item by its index. If you wanted to store items by key instead, you
    would use a dictionary.
  id: totrans-1708
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你学习了如何将项集合存储在数组和字典中。为了将项存储在有序列表中，你将使用数组并通过索引查找每个项。如果你希望通过键来存储项，则应该使用字典。
- en: Knowing about arrays and dictionaries and how to use them is a powerful building
    block for almost any programming language. Next we will learn about functions,
    another very powerful tool. Functions are blocks of code that you create and name
    to perform a specific job. After you have written a function, you can use its
    name to call it from almost anywhere in your program.
  id: totrans-1709
  prefs: []
  type: TYPE_NORMAL
  zh: 了解数组和字典及其使用方法是几乎所有编程语言中的一个强大基础。接下来，我们将学习函数，另一个非常强大的工具。函数是你创建并命名的代码块，用于执行特定的任务。写完函数后，你可以通过它的名称从程序中的几乎任何地方调用它。
- en: '*Figure 6-1: The nationalParks array*'
  id: totrans-1710
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 6-1: nationalParks 数组*'
- en: '**USING MUTABLE AND IMMUTABLE ARRAYS**'
  id: totrans-1711
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**使用可变和不可变数组**'
- en: Our nationalParks array is a variable because we created it with the var keyword
    ➊ . An array stored in a variable is called a *mutable* array. This means that
    you can change it by adding items, removing items, or swapping items in and out.
  id: totrans-1712
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的nationalParks数组是一个变量，因为我们使用var关键字创建了它 ➊。存储在变量中的数组被称为*可变*数组。这意味着你可以通过添加、删除或交换项目来更改它。
- en: You can also create an *immutable* array. An immutable array is created with
    the keyword let instead of var . Similar to a constant, once an immutable array
    is created, nothing in it can be changed.
  id: totrans-1713
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以创建一个*不可变*数组。不可变数组是通过关键字let而非var来创建的。与常量类似，一旦创建了不可变数组，其中的任何内容都不能更改。
- en: So when should you use a mutable array or an immutable array? It’s best to use
    let if you know your collection will never change, like if you’re storing the
    colors of the rainbow. You should use var if you need to change your collection,
    like if you’re storing an array of your favorite T-shirts, which might change
    depending on what’s in style!
  id: totrans-1714
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，何时使用可变数组或不可变数组呢？如果你知道你的集合永远不会改变，最好使用let，比如如果你要存储彩虹的颜色。你应该使用var，如果你需要更改集合，比如存储你最喜欢的T恤的数组，这些可能会随着流行趋势的变化而改变！
- en: '![Image](Image00116.jpg)'
  id: totrans-1715
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00116.jpg)'
- en: '**USING TYPE INFERENCE**'
  id: totrans-1716
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**使用类型推断**'
- en: 'When we created our nationalParks array, we specified that we were creating
    an array of string values by adding a colon (: ) and [String] ➋ . This step is
    optional when you create an array and initialize it with one or more values because
    Swift will use type inference to determine the kind of data you want the array
    to hold. That means that you could just as easily have created the array by doing
    this:'
  id: totrans-1717
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们创建nationalParks数组时，我们通过添加冒号(:)和[String] ➋来指定我们正在创建一个字符串值的数组。这个步骤在你创建数组并初始化为一个或多个值时是可选的，因为Swift会使用类型推断来确定你希望数组保存的数据类型。这意味着，你完全可以通过以下方式创建数组：
- en: '![](Image00117.jpg)'
  id: totrans-1718
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00117.jpg)'
- en: Using type inference, Swift knows we initialized this array to hold strings,
    and it can hold only strings.
  id: totrans-1719
  prefs: []
  type: TYPE_NORMAL
  zh: 使用类型推断，Swift知道我们初始化了一个只能保存字符串的数组。
- en: The list of parks that we created the array with is an example of an array *literal*
    . A literal is a value that is exactly what you see. It is not a variable or constant
    but rather just the value without a name. "Grand Canyon" is an example of a string
    literal, and 7 is an example of an integer literal. An array literal is a list
    of items contained between two square brackets and separated by commas, like ["Acadia",
    "Zion", "Grand Canyon"] ➊ .
  id: totrans-1720
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建数组时使用的公园列表是一个*字面量*数组的示例。字面量是一个值，它正是你所看到的。它不是变量或常量，而只是一个没有名称的值。“Grand Canyon”是字符串字面量的例子，而7是整数字面量的例子。数组字面量是包含在两个方括号之间，并用逗号分隔的项目列表，比如["Acadia",
    "Zion", "Grand Canyon"] ➊。
- en: '**ACCESSING ITEMS IN AN ARRAY**'
  id: totrans-1721
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**访问数组中的项目**'
- en: 'Let’s say you want to access an item in your array and use it in your program.
    Your friend asks you to tell them all about your travels, so you want to use the
    names of the national parks that you stored in the array. To access an item in
    your array, write the array name followed by the item’s index inside square brackets:'
  id: totrans-1722
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你想访问数组中的某个项目，并在程序中使用它。你的朋友要求你告诉他们你所有的旅行经历，所以你想使用你存储在数组中的国家公园名称。要访问数组中的项目，写出数组名称，后面跟上方括号内的项目索引：
- en: '![](Image00118.jpg)'
  id: totrans-1723
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00118.jpg)'
- en: In this example, we are accessing the names of the national parks and then printing
    them to the screen using print . To get the first item in nationalParks , you
    use nationalParks[0] ➊ . To access the second item in nationalParks , you use
    nationalParks[1] .
  id: totrans-1724
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们正在访问国家公园的名称，然后使用print将它们打印到屏幕上。要获取nationalParks中的第一个项目，你使用nationalParks[0]
    ➊。要访问nationalParks中的第二个项目，你使用nationalParks[1]。
- en: '**WATCHING THE RANGE**'
  id: totrans-1725
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**查看范围**'
- en: One important point about arrays is that if you try to access an item at an
    index that’s higher than the last index in the array, you’ll get an error. In
    [Figure 6-2](text00016.html#ch06fig2) , you can see that nationalParks[3] (which
    would be the fourth item in the array) gives you an error because there are only
    three national parks in the array, indexed from 0 to 2.
  id: totrans-1726
  prefs: []
  type: TYPE_NORMAL
  zh: 关于数组的一个重要点是，如果你尝试访问比数组最后一个索引还高的索引，将会出现错误。在[图6-2](text00016.html#ch06fig2)中，你可以看到nationalParks[3]（即数组中的第四个项目）会给出错误，因为数组中只有三个国家公园，索引从0到2。
- en: As you can see, you get an error message that says Index out of range . If you
    try to access an item that doesn’t exist in your array, your app will crash!
  id: totrans-1727
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，你会收到一个错误信息，显示“索引超出范围”。如果你尝试访问数组中不存在的项，应用程序将崩溃！
- en: '![Image](Image00119.jpg)'
  id: totrans-1728
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00119.jpg)'
- en: '*Figure 6-2: Trying to access an index in the array where nothing exists causes
    an error.*'
  id: totrans-1729
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 6-2：尝试访问数组中不存在的索引会导致错误。*'
- en: '**ADDING ITEMS TO AN ARRAY**'
  id: totrans-1730
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**向数组添加项**'
- en: One way to change an array is to add new items to it. There are a few different
    ways to do this, so let’s take a look at each.
  id: totrans-1731
  prefs: []
  type: TYPE_NORMAL
  zh: 更改数组的一种方法是向其中添加新项。有几种不同的方法可以做到这一点，让我们来看看每种方法。
- en: 'First, you can use an array’s append(_:) method. *Append* means to add something.
    Using append(_:) , you can add one new item to the end of your array. Say you
    go on another trip and visit the Badlands, and you want to add it to your list
    of national parks. To do that, add this code into your playground:'
  id: totrans-1732
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，你可以使用数组的`append(_:)`方法。*Append*意味着添加某物。使用`append(_:)`，你可以将一个新项添加到数组的末尾。假设你又去旅行，参观了“Badlands”，并想将它添加到你的国家公园列表中。为此，可以将以下代码添加到你的playground中：
- en: '![](Image00120.jpg)'
  id: totrans-1733
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00120.jpg)'
- en: To use the append(_:) method, first write the name of your array followed by
    a period and then append . Then, put the item you want to add to your array inside
    the parentheses. In this case, you put "Badlands" inside the parentheses.
  id: totrans-1734
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用`append(_:)`方法，首先写下你的数组名称，然后加一个点，接着是`append`。然后，将你想要添加到数组中的项放在圆括号内。在这种情况下，你将“Badlands”放入圆括号内。
- en: 'If you want to add something at a specific place in your array, use the array’s
    insert(_:at:) method instead. This method takes two arguments: the item that you
    want to insert and the index of where it should go in the array. (We’ll discuss
    arguments in more detail in [Chapter 7](text00017.html#ch07) .)'
  id: totrans-1735
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想在数组的特定位置添加某物，使用数组的`insert(_:at:)`方法。这个方法接受两个参数：你想插入的项以及它在数组中应该插入的位置索引。（我们将在[第7章](text00017.html#ch07)中更详细地讨论参数。）
- en: 'Let’s say you totally forgot that you went to the Petrified Forest right after
    you visited the Grand Canyon, and you want to update your nationalParks array
    so it displays the parks in the order in which you visited them. To update your
    array, you could use the insert(_:at:) method to put the Petrified Forest in the
    right position:'
  id: totrans-1736
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你完全忘记了你在参观“大峡谷”之后就去了“Petrified Forest”，并且你想更新你的`nationalParks`数组，使其显示你参观公园的顺序。为了更新你的数组，你可以使用`insert(_:at:)`方法将“Petrified
    Forest”放在正确的位置：
- en: '![](Image00121.jpg)'
  id: totrans-1737
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00121.jpg)'
- en: When you insert a new item at index 3, everything that was in the array at index
    3 or higher gets scooted over to make room for the new item. That means the item
    that was at index 3 is now at index 4, the item that was at index 4 is now at
    index 5, and so on. After you add the Petrified Forest, nationalParks is now ["Acadia",
    "Zion", "Grand Canyon", "Petrified Forest", "Badlands"] .
  id: totrans-1738
  prefs: []
  type: TYPE_NORMAL
  zh: 当你在索引3处插入一个新项时，数组中索引3及以上的所有项都会向后移动，为新项腾出空间。这意味着原本在索引3的项现在位于索引4，原本在索引4的项现在位于索引5，依此类推。在你添加“Petrified
    Forest”后，`nationalParks`数组现在是["Acadia", "Zion", "Grand Canyon", "Petrified Forest",
    "Badlands"]。
- en: '**COMBINING ARRAYS**'
  id: totrans-1739
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**合并数组**'
- en: 'Not only can you add new items to an array, but you can also add two arrays
    together using the + and += operators. Let’s say that you have the ingredients
    for a fruit smoothie in two arrays:'
  id: totrans-1740
  prefs: []
  type: TYPE_NORMAL
  zh: 你不仅可以向数组添加新项，还可以使用`+`和`+=`操作符将两个数组合并起来。假设你有两个数组，分别包含做果昔所需的水果和液体：
- en: '![](Image00122.jpg)'
  id: totrans-1741
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00122.jpg)'
- en: Now you can make a delicious smoothie by adding the fruits and liquids arrays.
  id: totrans-1742
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你可以通过添加水果和液体数组来制作美味的果昔。
- en: '![](Image00123.jpg)'
  id: totrans-1743
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00123.jpg)'
- en: The order of the ingredients in smoothie is the same as the order in fruits
    and liquids . If you created smoothie with liquids + fruits , then the liquids
    would come first.
  id: totrans-1744
  prefs: []
  type: TYPE_NORMAL
  zh: 果昔中配料的顺序与`fruits`和`liquids`中的顺序相同。如果你将`liquids + fruits`来创建果昔，那么液体将排在前面。
- en: 'You use the += operator to add an array to the end of your array. Add some
    whipped cream as follows for extra yumminess:'
  id: totrans-1745
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用`+=`操作符将一个数组添加到你的数组的末尾。为了增加一些美味感，可以按如下方式添加一些鲜奶油：
- en: '![](Image00124.jpg)'
  id: totrans-1746
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00124.jpg)'
- en: Note that ["whipped cream"] is an array even though it has a single item in
    it. When you’re using += to append something to an array, you have to make sure
    you’re only trying to add another array. If you were to just write the string
    "whipped cream" without the square brackets around it, you would get an error.
  id: totrans-1747
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，尽管`["whipped cream"]`只有一个项，它仍然是一个数组。当你使用`+=`将某物附加到数组时，你必须确保你只尝试添加另一个数组。如果你只是写了字符串“whipped
    cream”，而没有方括号，程序将报错。
- en: '![Image](Image00125.jpg)'
  id: totrans-1748
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00125.jpg)'
- en: '**REMOVING ITEMS FROM AN ARRAY**'
  id: totrans-1749
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**从数组中删除项目**'
- en: 'There are several methods for removing items from an array. Let’s start by
    looking at the array’s removeLast() method. As you might have guessed from its
    name, removeLast() removes the last item from your array. Let’s try it out with
    a shoppingList array:'
  id: totrans-1750
  prefs: []
  type: TYPE_NORMAL
  zh: 删除数组项有几种方法。我们先来看看数组的 removeLast() 方法。正如你从它的名称中可能猜到的那样，removeLast() 会移除数组中的最后一个项。我们用一个
    shoppingList（购物清单）数组来试试：
- en: '![](Image00126.jpg)'
  id: totrans-1751
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00126.jpg)'
- en: Neat! Note that the removeLast() method returns the removed item, so you can
    store it in a new constant or variable if you want.
  id: totrans-1752
  prefs: []
  type: TYPE_NORMAL
  zh: 真棒！请注意，removeLast() 方法会返回被删除的项，因此如果你想，你可以将其存储在一个新的常量或变量中。
- en: 'You can also remove an item from a specific index by using the remove(at:)
    method. Let’s say that your mom doesn’t want you buying any candy and takes that
    off the list:'
  id: totrans-1753
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以通过使用 remove(at:) 方法从特定索引删除一个项。假设你的妈妈不希望你买糖果，并将其从清单中删除：
- en: '![Image](Image00127.jpg)![](Image00128.jpg)'
  id: totrans-1754
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00127.jpg)![](Image00128.jpg)'
- en: Just like when we added an item to the middle of our array and all the items
    scooted over to make room, if you remove an item from the middle of an array,
    the rest of the items will scoot back to fill in that empty space. The "apples"
    item that was at index 3 is now at index 2, where "candy" was.
  id: totrans-1755
  prefs: []
  type: TYPE_NORMAL
  zh: 就像我们在数组中间添加项目时，所有其他项目都挪动以腾出空间一样，如果你从数组的中间删除一个项目，其余项目会向回挪动，填补空缺。索引 3 处的“apples”（苹果）项目现在会出现在索引
    2 处，原本在那里的“candy”（糖果）已被移除。
- en: 'You can also remove all items from an array with removeAll() . Try entering
    this into your playground:'
  id: totrans-1756
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以使用 removeAll() 删除数组中的所有项。试试在你的 Playground 中输入这个：
- en: '![](Image00129.jpg)'
  id: totrans-1757
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00129.jpg)'
- en: 'Note that trying to remove an item at an index that doesn’t exist will give
    you an error:'
  id: totrans-1758
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，尝试删除一个不存在索引处的项会导致错误：
- en: '![](Image00130.jpg)'
  id: totrans-1759
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00130.jpg)'
- en: Our array doesn’t have this many items (in fact, now it’s empty!), so this throws
    an error. We’ll also get an error if we use removeLast() on our empty array, because
    there’s nothing in it—there’s no last index at all! However, removeAll() is always
    safe to use, even on an empty array.
  id: totrans-1760
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的数组没有这么多项目（事实上，现在它是空的！），所以会抛出错误。如果我们在空数组上使用 removeLast()，也会出现错误，因为它里面什么都没有——根本没有最后一个索引！然而，使用
    removeAll() 始终是安全的，即使在空数组上也是如此。
- en: '**REPLACING ITEMS IN AN ARRAY**'
  id: totrans-1761
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**替换数组中的项**'
- en: 'To replace an item in an array, you set the index of the array to the new value,
    as shown here:'
  id: totrans-1762
  prefs: []
  type: TYPE_NORMAL
  zh: 要替换数组中的一项，你只需将该索引设置为新值，如下所示：
- en: '![](Image00131.jpg)'
  id: totrans-1763
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00131.jpg)'
- en: At ➊ , we replaced the item at index 2 (the third item) with "Unicorn" because
    magical animals count as favorite animals, too! At ➋ , we replaced the item at
    index 0 (the first item) with "Bearded dragon" . No, that’s not a real dragon—it’s
    just a lizard!
  id: totrans-1764
  prefs: []
  type: TYPE_NORMAL
  zh: 在 ➊ ，我们将索引 2（第三个项目）处的项替换为“Unicorn”（独角兽），因为魔法动物也算作是喜欢的动物！在 ➋ ，我们将索引 0（第一个项目）处的项替换为“Bearded
    dragon”（须龙）。不，这不是一条真正的龙——它只是一个蜥蜴！
- en: Like any time you’re working with array index numbers, you have to be sure an
    item exists in the array at that index before you change its value, or you will
    get an Index out of range error.
  id: totrans-1765
  prefs: []
  type: TYPE_NORMAL
  zh: 就像每次操作数组索引时，你必须确保在该索引处的数组中存在项，否则你会得到一个超出范围的错误。
- en: '[Figure 6-3](text00016.html#ch06fig3) shows the error that occurs if you try
    to add "Standard poodle" using favoriteAnimals[3] = "Standard poodle" . To add
    an item to the end of an array, you should use the append(_:) method or += , as
    we covered in “[Adding Items to an Array](text00016.html#ch06lev2sec5) ” on [page
    70](text00016.html#page_70) .'
  id: totrans-1766
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 6-3](text00016.html#ch06fig3) 显示了如果你尝试通过 favoriteAnimals[3] = "Standard
    poodle" 来添加“Standard poodle”（标准贵宾犬），会发生的错误。要将一个项添加到数组的末尾，你应该使用 append(_:) 方法或
    += ，就像我们在 “[向数组中添加项目](text00016.html#ch06lev2sec5)” 章节中在 [第 70 页](text00016.html#page_70)
    讨论的那样。'
- en: '![Image](Image00132.jpg)'
  id: totrans-1767
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00132.jpg)'
- en: '*Figure 6-3: Don’t try to replace a value at an index beyond the existing array.*'
  id: totrans-1768
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 6-3：不要尝试替换一个超出现有数组范围的索引处的值。*'
- en: Now you know how to change arrays however you might need to. You can add items,
    take items away, or replace items. Next, we’ll look at how to use the properties
    of arrays to find out even more information about them.
  id: totrans-1769
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你知道如何根据需要更改数组了。你可以添加项、移除项或替换项。接下来，我们将了解如何使用数组的属性，获取更多关于数组的信息。
- en: '![Image](Image00133.jpg)'
  id: totrans-1770
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00133.jpg)'
- en: '**USING ARRAY PROPERTIES**'
  id: totrans-1771
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**使用数组属性**'
- en: In addition to methods like append(_:) and removeLast() , arrays also have *properties*
    . An array’s properties are variables or constants that contain some information
    about the array. Two really helpful properties that you might use are the Boolean
    property isEmpty and the integer property count .
  id: totrans-1772
  prefs: []
  type: TYPE_NORMAL
  zh: 除了像append(_:)和removeLast()这样的函数，数组还有*属性*。数组的属性是包含有关数组的一些信息的变量或常量。你可能会用到的两个非常有用的属性是布尔属性isEmpty和整数属性count。
- en: The isEmpty property is true or false depending on whether the array is empty,
    and the count property will tell you how many items are in that array.
  id: totrans-1773
  prefs: []
  type: TYPE_NORMAL
  zh: isEmpty属性根据数组是否为空来返回true或false，count属性则告诉你数组中有多少项。
- en: 'Check out how these two properties are used in the following if-else statement:'
  id: totrans-1774
  prefs: []
  type: TYPE_NORMAL
  zh: 看看以下if-else语句中如何使用这两个属性：
- en: '![Image](Image00134.jpg)'
  id: totrans-1775
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Image00134.jpg)'
- en: 'This if-else statement checks whether the array mySiblings is empty ➊ . If
    it is, then "I don''t have any siblings." is printed. But if there is something
    in the array, then the number of siblings that we have is printed: "I have 3 siblings."
    ➋ .'
  id: totrans-1776
  prefs: []
  type: TYPE_NORMAL
  zh: 这个if-else语句检查数组mySiblings是否为空 ➊。如果为空，则打印出“我没有兄弟姐妹。”但如果数组中有内容，则打印出我们有几个兄弟姐妹：“我有3个兄弟姐妹。”
    ➋。
- en: '**LOOPING OVER AN ARRAY**'
  id: totrans-1777
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**遍历数组**'
- en: 'Sometimes when you’re working with arrays you might want to do something to
    every item in the array. You can use a for-in loop to do that! The following code
    will print every topping in a pizzaToppings array on a separate line:'
  id: totrans-1778
  prefs: []
  type: TYPE_NORMAL
  zh: 有时候在处理数组时，你可能想对数组中的每个项目执行某些操作。你可以使用for-in循环来实现！以下代码会将pizzaToppings数组中的每个配料打印在单独的一行：
- en: '![Image](Image00135.jpg)'
  id: totrans-1779
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Image00135.jpg)'
- en: To write a for-in loop for the pizzaToppings array, we used the keyword for
    , followed by the constant topping , then the keyword in , and finally the name
    of our array, pizzaToppings . Then we put the statements that we want to run for
    each topping inside the braces of the for-in loop. The constant topping ➊ temporarily
    represents each pizza topping in the array as we loop through it. We could have
    chosen any name for this constant, but it’s a good idea to pick something that
    makes sense. You can see the output of this for-in loop in [Figure 6-4](text00016.html#ch06fig4)
    .
  id: totrans-1780
  prefs: []
  type: TYPE_NORMAL
  zh: 为pizzaToppings数组编写for-in循环时，我们使用了关键字for，后跟常量topping，再加上关键字in，最后是我们数组的名称pizzaToppings。然后，我们将想要为每个配料执行的语句放入for-in循环的大括号中。常量topping
    ➊在我们遍历数组时暂时代表每个配料。我们本可以为这个常量选择任何名字，但选择一个有意义的名称是个好主意。你可以在[图6-4](text00016.html#ch06fig4)中看到这个for-in循环的输出。
- en: '![Image](Image00136.jpg)'
  id: totrans-1781
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Image00136.jpg)'
- en: '*Figure 6-4: Output of the example for-in loop*'
  id: totrans-1782
  prefs: []
  type: TYPE_NORMAL
  zh: '*图6-4：示例for-in循环的输出*'
- en: '![Image](Image00137.jpg)'
  id: totrans-1783
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Image00137.jpg)'
- en: 'Using for-in loops is great for printing every value in an array. If you’re
    working with numbers, you can even use them to perform math operations on each
    item, which makes for some speedy calculations! The following code takes an array
    of numbers and calculates the square for each (the square of a number is that
    number multiplied by itself):'
  id: totrans-1784
  prefs: []
  type: TYPE_NORMAL
  zh: 使用for-in循环非常适合打印数组中的每个值。如果你在处理数字，甚至可以使用它们对每个项目执行数学运算，这样就能进行快速计算！以下代码获取一个数字数组，并计算每个数字的平方（数字的平方是该数字与自身相乘）：
- en: '![Image](Image00138.jpg)'
  id: totrans-1785
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Image00138.jpg)'
- en: '[Figure 6-5](text00016.html#ch06fig5) shows the results.'
  id: totrans-1786
  prefs: []
  type: TYPE_NORMAL
  zh: '[图6-5](text00016.html#ch06fig5)显示了结果。'
- en: '![Image](Image00139.jpg)'
  id: totrans-1787
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Image00139.jpg)'
- en: '*Figure 6-5: Printing the squares for each number in the myNumbers array*'
  id: totrans-1788
  prefs: []
  type: TYPE_NORMAL
  zh: '*图6-5：打印myNumbers数组中每个数字的平方*'
- en: '**DICTIONARIES ARE KEY!**'
  id: totrans-1789
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**字典是关键！**'
- en: A *dictionary* is also a collection of values, but instead of an ordered index,
    each value has its own *key* . Because there’s no index, the values are not stored
    in any particular order. To access values in a dictionary, you look them up by
    their key.
  id: totrans-1790
  prefs: []
  type: TYPE_NORMAL
  zh: '*字典*也是一个值的集合，但与有序索引不同，每个值都有自己的*键*。因为没有索引，值不会按特定顺序存储。要访问字典中的值，你需要通过键查找它们。'
- en: A key must be unique. You can’t have the same key more than once in the same
    dictionary. If there were two identical keys and you asked the computer to give
    you the value for one of them, the computer wouldn’t know which one to choose!
  id: totrans-1791
  prefs: []
  type: TYPE_NORMAL
  zh: 键必须是唯一的。你不能在同一个字典中使用相同的键。如果有两个相同的键，并且你要求计算机返回其中一个的值，计算机就无法知道选择哪个！
- en: Let’s take a look at how to make a dictionary and write keys that will help
    you find all the information you need.
  id: totrans-1792
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看如何创建一个字典，并编写键来帮助你查找所需的所有信息。
- en: '![Image](Image00140.jpg)'
  id: totrans-1793
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Image00140.jpg)'
- en: '**INITIALIZING A DICTIONARY**'
  id: totrans-1794
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**初始化字典**'
- en: 'To create and initialize a dictionary, first write var and the name of your
    dictionary. Then write the keys and corresponding values inside a pair of square
    brackets, similar to an array. Let’s create a dictionary to store the names of
    a few US states. The key for each state will be its two-letter abbreviation:'
  id: totrans-1795
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建并初始化一个字典，首先写`var`和字典的名称。然后在一对方括号内写入键和值，类似于数组。让我们创建一个字典来存储一些美国州的名称。每个州的键将是它的两位字母缩写：
- en: '![](Image00141.jpg)'
  id: totrans-1796
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00141.jpg)'
- en: As you can see, there’s a colon between each key and its value, and the key/value
    pairs are separated by commas.
  id: totrans-1797
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，每个键和值之间有一个冒号，键值对之间用逗号分隔。
- en: Dictionaries are different from arrays in that they are *unordered* . Because
    of that, it’s likely that the order of the states that you see in your results
    pane ➋ is different from the order in which you entered your states ➊ . It might
    even be different than the order that’s printed in this book!
  id: totrans-1798
  prefs: []
  type: TYPE_NORMAL
  zh: 字典与数组的不同之处在于它们是*无序的*。因此，你在结果面板 ➋ 中看到的状态顺序可能与输入状态的顺序 ➊ 不同，甚至可能与书中打印的顺序不同！
- en: As with arrays, you can use var to make a mutable dictionary or use let to make
    an immutable dictionary.
  id: totrans-1799
  prefs: []
  type: TYPE_NORMAL
  zh: 和数组一样，你可以使用`var`来创建一个可变字典，或者使用`let`来创建一个不可变字典。
- en: 'In Swift, all of the keys of a dictionary must be the same type, and all of
    the values of a dictionary must also be the same type, but the key type doesn’t
    have to match the value type. For example, if you wanted to store a collection
    of fractions, you could use doubles for the keys and strings for the values:'
  id: totrans-1800
  prefs: []
  type: TYPE_NORMAL
  zh: 在Swift中，字典的所有键必须是相同类型，所有值也必须是相同类型，但键的类型不必与值的类型匹配。例如，如果你想存储一个分数集合，你可以使用双精度类型作为键，字符串作为值：
- en: '![](Image00142.jpg)'
  id: totrans-1801
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00142.jpg)'
- en: In this dictionary, all of the keys must be doubles, and all of the values must
    be strings. Again, you’ll see that the order of the numbers in the results pane
    can be quite different from the order in which you wrote the fractions in your
    dictionary. This is fine because you don’t need to know the order to access anything.
    You can find any item that you need by its key. Let’s see how!
  id: totrans-1802
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个字典中，所有的键必须是双精度类型（doubles），所有的值必须是字符串类型（strings）。同样，你会看到在结果面板中，数字的顺序可能与在字典中写入分数的顺序大不相同。这是没问题的，因为你不需要知道顺序就能访问任何内容。你可以通过键找到任何需要的项目。我们来看一下如何操作！
- en: '**ACCESSING VALUES IN A DICTIONARY**'
  id: totrans-1803
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**访问字典中的值**'
- en: 'Looking up a value in a dictionary is similar to how you access a value in
    an array except that you use a key inside the square brackets instead of an index,
    like this: usStates["TX"] .'
  id: totrans-1804
  prefs: []
  type: TYPE_NORMAL
  zh: 在字典中查找值的方式类似于在数组中访问值，只是你在方括号内使用键而不是索引，例如：usStates["TX"]。
- en: There is a big difference, however, in how Swift returns the values from a dictionary.
    When you access a value at an index of an array, you are simply given the value.
    When you access a value with a key in a dictionary, you are given an optional.
  id: totrans-1805
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在Swift中，字典返回值的方式与数组不同。当你访问数组中的一个索引时，你只会得到该值。当你用键访问字典中的值时，你会得到一个可选项。
- en: In [Chapter 5](text00015.html#ch05) , you learned that optionals might contain
    a value or might be nil . The reason Swift returns optionals when you’re looking
    up items in a dictionary is that the key you used might not exist in the dictionary,
    in which case there’s no value to access. Trying to access a value that doesn’t
    exist would give you a big fat error! To avoid that problem, Swift returns optionals.
    That means you need to unwrap any value you get out of a dictionary before you
    can do anything with it.
  id: totrans-1806
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第5章](text00015.html#ch05)中，你学到可选项可能包含一个值，也可能是nil。Swift返回可选项的原因是你在查找字典中的项目时，使用的键可能在字典中不存在，在这种情况下无法访问值。尝试访问一个不存在的值会给你一个错误！为了避免这个问题，Swift返回可选项。这意味着在对字典中的值进行任何操作之前，你需要先解包它。
- en: 'To unwrap an optional, first you check whether it exists using an if-let statement,
    just like we did in [Chapter 5](text00015.html#ch05) . The following code shows
    you how to get a value out of a dictionary:'
  id: totrans-1807
  prefs: []
  type: TYPE_NORMAL
  zh: 要解包一个可选项，首先你使用if-let语句检查它是否存在，就像我们在[第5章](text00015.html#ch05)中做的那样。下面的代码演示了如何从字典中获取一个值：
- en: '![Image](Image00143.jpg)'
  id: totrans-1808
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00143.jpg)'
- en: To retrieve "Texas" from the dictionary, we use if let to set a constant loneStarState
    to usStates["TX"] ➊ . Because we have this state in our dictionary, the line I
    have Texas in my dictionary. is printed. Next we try to access a state that is
    not in our dictionary by using the key usStates["FL"] ➋ . Thankfully, because
    we used an if-let statement, the program won’t crash when the computer can’t find
    this state. Instead, I don't have that state in my dictionary. is printed.
  id: totrans-1809
  prefs: []
  type: TYPE_NORMAL
  zh: 要从字典中检索“Texas”，我们使用if let将常量loneStarState设置为usStates["TX"] ➊。因为我们在字典中有这个州，所以打印出“我在字典里有Texas”。接下来，我们尝试通过使用键usStates["FL"]
    ➋来访问一个不在字典中的州。幸运的是，由于我们使用了if-let语句，当计算机找不到这个州时，程序不会崩溃。相反，打印出“我字典里没有这个州”。
- en: '**ADDING ITEMS TO A DICTIONARY**'
  id: totrans-1810
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**向字典添加项**'
- en: 'To add an item to a dictionary, first write the name of your dictionary and
    assign the new item to the key you want it to have in the dictionary. Let’s add
    "Minnesota" to our usStates dictionary:'
  id: totrans-1811
  prefs: []
  type: TYPE_NORMAL
  zh: 要向字典添加一项，首先写出字典的名称，并将新项分配给你希望其在字典中拥有的键。让我们将“Minnesota”添加到我们的usStates字典中：
- en: '![](Image00144.jpg)'
  id: totrans-1812
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00144.jpg)'
- en: 'Now when you look at usStates , you’ll see that it’s updated to ["MN": "Minnesota",
    "WA": "Washington", "MA": "Massachusetts", "TX": "Texas"] . Remember, because
    you don’t have to rely on indices, your new dictionary item might appear anywhere
    in the dictionary.'
  id: totrans-1813
  prefs: []
  type: TYPE_NORMAL
  zh: '现在，当你查看usStates时，你会看到它更新为["MN": "Minnesota", "WA": "Washington", "MA": "Massachusetts",
    "TX": "Texas"]。记住，因为你不必依赖索引，新的字典项可能出现在字典中的任何位置。'
- en: '**REMOVING ITEMS FROM A DICTIONARY**'
  id: totrans-1814
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**从字典中移除项**'
- en: Removing an item from a dictionary is quite simple; you do so by setting the
    value to nil . Because the values in dictionaries are returned as optionals, you
    don’t have to worry about nil causing any problems in your dictionary.
  id: totrans-1815
  prefs: []
  type: TYPE_NORMAL
  zh: 从字典中移除项非常简单；你只需将值设置为nil。因为字典中的值是可选的，你不必担心nil会在字典中造成任何问题。
- en: '![](Image00145.jpg)'
  id: totrans-1816
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00145.jpg)'
- en: 'You can see that after you remove the value at the key "MA" , usStates is updated
    to ["MN": "Minnesota", "WA": "Washington", "TX": "Texas"] . Remember that nil
    is special and means that there’s no value at all. That’s why you don’t see "MA":
    nil in our dictionary.'
  id: totrans-1817
  prefs: []
  type: TYPE_NORMAL
  zh: '你可以看到，在你移除键“MA”的值后，usStates更新为["MN": "Minnesota", "WA": "Washington", "TX":
    "Texas"]。记住，nil是特殊的，表示没有值。这就是为什么你在字典中看不到"MA": nil。'
- en: '**REPLACING ITEMS IN A DICTIONARY**'
  id: totrans-1818
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**替换字典中的项**'
- en: 'Replacing an item in a dictionary is also easy. It works the same was as replacing
    an item in an array. You just set the item that you want to replace to something
    else. Say you create a dictionary of fruit colors:'
  id: totrans-1819
  prefs: []
  type: TYPE_NORMAL
  zh: 替换字典中的一项也很简单。它与替换数组中的项一样。你只需将你想要替换的项设置为其他值。比如，你创建了一个水果颜色的字典：
- en: '![](Image00146.jpg)'
  id: totrans-1820
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00146.jpg)'
- en: At first we had the value "apple" for "red" , but then we decided that "raspberry"
    is a better fruit to use since sometimes apples are green or yellow. To replace
    "apple" with "raspberry" , we set colorFruits["red"] to its new value ➊ .
  id: totrans-1821
  prefs: []
  type: TYPE_NORMAL
  zh: 起初我们为“red”设置了“apple”的值，但后来我们决定“raspberry”是一个更好的水果，因为有时候苹果是绿色或黄色的。为了将“apple”替换为“raspberry”，我们将colorFruits["red"]设置为新的值➊。
- en: You may remember that this is the same way we entered a new value into a dictionary.
    If the key already exists in the dictionary, then the value for that key is replaced.
    If the key doesn’t already exist, then the new key/value pair will be added to
    the dictionary.
  id: totrans-1822
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能还记得，这与我们向字典中输入新值的方式相同。如果键已经存在于字典中，则该键的值会被替换。如果键不存在，则新的键/值对将被添加到字典中。
- en: '![Image](Image00147.jpg)'
  id: totrans-1823
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00147.jpg)'
- en: '**USING DICTIONARY PROPERTIES**'
  id: totrans-1824
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**使用字典属性**'
- en: 'Like an array, a dictionary also has an isEmpty property and a count property.
    For example, the following code shows how you can use the isEmpty property to
    check if a dictionary is empty, and if it isn’t empty, the count property checks
    how many items you have. Imagine you have a basket of fruit for sale. You can
    use these properties to help you keep track of everything:'
  id: totrans-1825
  prefs: []
  type: TYPE_NORMAL
  zh: 与数组一样，字典也有isEmpty属性和count属性。例如，以下代码展示了如何使用isEmpty属性检查字典是否为空，如果不为空，则使用count属性检查字典中有多少项。假设你有一个待售的水果篮，你可以使用这些属性帮助你跟踪所有内容：
- en: '![Image](Image00148.jpg)'
  id: totrans-1826
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00148.jpg)'
- en: 'A dictionary also has two special properties: keys , which contains all of
    the dictionary’s keys, and values , which contains all of its values. We’ll use
    these two properties when we loop through the dictionary.'
  id: totrans-1827
  prefs: []
  type: TYPE_NORMAL
  zh: 字典还有两个特殊属性：keys，它包含字典的所有键；values，它包含字典的所有值。我们将在遍历字典时使用这两个属性。
- en: Let’s write some code that loops through our fruit baskets and prints the price
    of each fruit.
  id: totrans-1828
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们写一些代码，遍历我们的水果篮，并打印每个水果的价格。
- en: '**LOOPING OVER A DICTIONARY**'
  id: totrans-1829
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**遍历字典**'
- en: 'You can loop through a dictionary using a for-in loop. Because each item has
    a key and a value, you can do this in two different ways. This is how to loop
    through a dictionary using its keys:'
  id: totrans-1830
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用for-in循环来遍历字典。因为每个项目都有一个键和值，所以你可以用两种不同的方式进行。以下是如何通过键来遍历字典：
- en: '![Image](Image00149.jpg)'
  id: totrans-1831
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00149.jpg)'
- en: Here we use the dictionary’s keys property ➊ to loop through fruitBasket and
    print its contents. We start by writing the keyword for , followed by a constant
    name fruit for the dictionary key, the keyword in , the dictionary name, a period,
    and keys .
  id: totrans-1832
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们使用字典的keys属性 ➊ 来遍历fruitBasket并打印其内容。我们从编写关键字for开始，接着是字典键的常量名称fruit，关键字in，字典名称，句点，最后是keys。
- en: Inside the braces of our for-in loop, we have access to both the key, which
    we call fruit ➋ , and the value at that key when we force-unwrap its contents
    with fruitBasket[fruit]! ➌ . That value will be the fruit’s price.
  id: totrans-1833
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的for-in循环的花括号内部，我们可以访问到键（我们称之为fruit ➋），以及当我们使用fruitBasket[fruit]! ➌ 强制解包其内容时，该键对应的值。这个值将是水果的价格。
- en: In this case, it’s safe to force-unwrap the value using an exclamation point
    because we know that the fruit key we’re using is definitely inside the dictionary.
  id: totrans-1834
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，使用感叹号强制解包值是安全的，因为我们知道我们使用的fruit键一定在字典中。
- en: Any code we put inside the for-in loop will run once for every key in our dictionary.
    So you should see the print statement display three times.
  id: totrans-1835
  prefs: []
  type: TYPE_NORMAL
  zh: 我们放入for-in循环中的任何代码都会对字典中的每个键执行一次。所以你应该看到打印语句显示三次。
- en: 'We can also loop through the dictionary using its values property:'
  id: totrans-1836
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以通过字典的值属性来遍历字典：
- en: '![Image](Image00150.jpg)'
  id: totrans-1837
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00150.jpg)'
- en: We use the same style of for-in loop, but now we use a constant to refer to
    each value, which we call price , in the values property. When looping through
    values, we don’t have access to the keys from inside the loop.
  id: totrans-1838
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用相同风格的for-in循环，但现在我们使用常量来引用values属性中的每个值，我们称之为price。当遍历值时，我们无法从循环内部访问到键。
- en: Another difference to note is that price is not an optional because it’s accessed
    directly as a value in the fruitBasket dictionary. That means we don’t have to
    unwrap it. You should still see the print statement printed three times. [Figure
    6-6](text00016.html#ch06fig6) shows the output of both loops.
  id: totrans-1839
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个需要注意的区别是，price不是可选的，因为它直接作为值从fruitBasket字典中访问。这意味着我们不需要解包它。你仍然应该看到打印语句打印三次。[图6-6](text00016.html#ch06fig6)展示了两个循环的输出。
- en: '![Image](Image00151.jpg)'
  id: totrans-1840
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00151.jpg)'
- en: '*Figure 6-6: Looping through the keys and values of a dictionary with a for-in
    loop*'
  id: totrans-1841
  prefs: []
  type: TYPE_NORMAL
  zh: '*图6-6：使用for-in循环遍历字典的键和值*'
- en: The order of your results might be slightly different from ours. That’s because
    the items in a dictionary aren’t in a numbered order like they are in an array!
    And because the order is not guaranteed, you might see a different order printed
    if you run the same code again.
  id: totrans-1842
  prefs: []
  type: TYPE_NORMAL
  zh: 你的结果顺序可能与我们的略有不同。这是因为字典中的项目不像数组那样是按编号顺序排列的！而且因为顺序没有保证，如果你再次运行相同的代码，可能会看到不同的顺序。
- en: '**WHAT YOU LEARNED**'
  id: totrans-1843
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**你学到了什么**'
- en: In this chapter, you learned how to store collections of items in an array and
    in a dictionary. To store items in an ordered list, you would use an array and
    look up each item by its index. If you wanted to store items by key instead, you
    would use a dictionary.
  id: totrans-1844
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你学习了如何在数组和字典中存储项目。要将项目存储在有序列表中，你会使用数组，并通过索引查找每个项目。如果你想按键存储项目，则会使用字典。
- en: Knowing about arrays and dictionaries and how to use them is a powerful building
    block for almost any programming language. Next we will learn about functions,
    another very powerful tool. Functions are blocks of code that you create and name
    to perform a specific job. After you have written a function, you can use its
    name to call it from almost anywhere in your program.
  id: totrans-1845
  prefs: []
  type: TYPE_NORMAL
  zh: 了解数组和字典及其使用方法是几乎任何编程语言的强大构建块。接下来，我们将学习函数，另一种非常强大的工具。函数是你创建并命名的代码块，用来执行特定的任务。编写完函数后，你可以通过它的名字从程序中的几乎任何地方调用它。
- en: '**USING MUTABLE AND IMMUTABLE ARRAYS**'
  id: totrans-1846
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**使用可变和不可变数组**'
- en: Our nationalParks array is a variable because we created it with the var keyword
    ➊ . An array stored in a variable is called a *mutable* array. This means that
    you can change it by adding items, removing items, or swapping items in and out.
  id: totrans-1847
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的 nationalParks 数组是一个变量，因为我们使用 var 关键字创建了它 ➊。存储在变量中的数组称为 *可变* 数组。这意味着你可以通过添加、移除或交换其中的项目来修改它。
- en: You can also create an *immutable* array. An immutable array is created with
    the keyword let instead of var . Similar to a constant, once an immutable array
    is created, nothing in it can be changed.
  id: totrans-1848
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以创建一个 *不可变* 数组。不可变数组是使用 let 关键字创建的，而不是 var。类似于常量，一旦创建了不可变数组，数组中的内容就不能再更改。
- en: So when should you use a mutable array or an immutable array? It’s best to use
    let if you know your collection will never change, like if you’re storing the
    colors of the rainbow. You should use var if you need to change your collection,
    like if you’re storing an array of your favorite T-shirts, which might change
    depending on what’s in style!
  id: totrans-1849
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，什么时候应该使用可变数组或不可变数组呢？如果你知道你的集合永远不会改变，例如存储彩虹的颜色时，最好使用 let。如果你需要更改集合，例如存储你最喜欢的
    T 恤的数组（这个数组可能会根据流行趋势发生变化），则应该使用 var。
- en: '![Image](Image00116.jpg)'
  id: totrans-1850
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00116.jpg)'
- en: '**USING TYPE INFERENCE**'
  id: totrans-1851
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**使用类型推断**'
- en: 'When we created our nationalParks array, we specified that we were creating
    an array of string values by adding a colon (: ) and [String] ➋ . This step is
    optional when you create an array and initialize it with one or more values because
    Swift will use type inference to determine the kind of data you want the array
    to hold. That means that you could just as easily have created the array by doing
    this:'
  id: totrans-1852
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们创建 nationalParks 数组时，我们通过添加冒号（:）和 [String] ➋ 指定了我们创建的是一个字符串类型的数组。此步骤在创建数组并用一个或多个值初始化时是可选的，因为
    Swift 会使用类型推断来确定你希望数组存储的数据类型。这意味着，你完全可以这样创建数组：
- en: '![](Image00117.jpg)'
  id: totrans-1853
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00117.jpg)'
- en: Using type inference, Swift knows we initialized this array to hold strings,
    and it can hold only strings.
  id: totrans-1854
  prefs: []
  type: TYPE_NORMAL
  zh: 使用类型推断，Swift 知道我们初始化这个数组时是用来存储字符串的，因此它只能存储字符串。
- en: The list of parks that we created the array with is an example of an array *literal*
    . A literal is a value that is exactly what you see. It is not a variable or constant
    but rather just the value without a name. "Grand Canyon" is an example of a string
    literal, and 7 is an example of an integer literal. An array literal is a list
    of items contained between two square brackets and separated by commas, like ["Acadia",
    "Zion", "Grand Canyon"] ➊ .
  id: totrans-1855
  prefs: []
  type: TYPE_NORMAL
  zh: 我们用来创建数组的国家公园列表是一个数组 *字面量* 的例子。字面量是一个值，它就是你看到的那样。它不是变量或常量，而只是一个没有名字的值。 "Grand
    Canyon" 是一个字符串字面量，7 是一个整数字面量。数组字面量是包含在两个方括号之间并用逗号分隔的项目列表，例如 ["Acadia", "Zion",
    "Grand Canyon"] ➊。
- en: '**ACCESSING ITEMS IN AN ARRAY**'
  id: totrans-1856
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**访问数组中的项目**'
- en: 'Let’s say you want to access an item in your array and use it in your program.
    Your friend asks you to tell them all about your travels, so you want to use the
    names of the national parks that you stored in the array. To access an item in
    your array, write the array name followed by the item’s index inside square brackets:'
  id: totrans-1857
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你想要访问数组中的某个项目并在程序中使用它。你的朋友请你告诉他们关于你旅行的所有事情，所以你想使用你存储在数组中的国家公园名称。要访问数组中的某个项目，只需写下数组名称，后面跟着项目的索引，索引要放在方括号内：
- en: '![](Image00118.jpg)'
  id: totrans-1858
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00118.jpg)'
- en: In this example, we are accessing the names of the national parks and then printing
    them to the screen using print . To get the first item in nationalParks , you
    use nationalParks[0] ➊ . To access the second item in nationalParks , you use
    nationalParks[1] .
  id: totrans-1859
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们正在访问国家公园的名称，然后使用 print 将它们打印到屏幕上。要获取 nationalParks 中的第一个项目，可以使用 nationalParks[0]
    ➊。要访问 nationalParks 中的第二个项目，可以使用 nationalParks[1]。
- en: '**WATCHING THE RANGE**'
  id: totrans-1860
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**观察范围**'
- en: One important point about arrays is that if you try to access an item at an
    index that’s higher than the last index in the array, you’ll get an error. In
    [Figure 6-2](text00016.html#ch06fig2) , you can see that nationalParks[3] (which
    would be the fourth item in the array) gives you an error because there are only
    three national parks in the array, indexed from 0 to 2.
  id: totrans-1861
  prefs: []
  type: TYPE_NORMAL
  zh: 关于数组的一个重要点是，如果你尝试访问一个比数组最后一个索引更大的索引位置，你会得到一个错误。在[图 6-2](text00016.html#ch06fig2)中，你可以看到
    nationalParks[3]（这应该是数组中的第四项）会产生错误，因为数组中只有三个国家公园，索引范围是从 0 到 2。
- en: As you can see, you get an error message that says Index out of range . If you
    try to access an item that doesn’t exist in your array, your app will crash!
  id: totrans-1862
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，系统会提示你一个错误信息：“索引超出范围”。如果你尝试访问数组中不存在的项，你的应用程序将崩溃！
- en: '![Image](Image00119.jpg)'
  id: totrans-1863
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00119.jpg)'
- en: '*Figure 6-2: Trying to access an index in the array where nothing exists causes
    an error.*'
  id: totrans-1864
  prefs: []
  type: TYPE_NORMAL
  zh: '*图6-2：尝试访问数组中不存在的索引会导致错误。*'
- en: '**ADDING ITEMS TO AN ARRAY**'
  id: totrans-1865
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**向数组添加项**'
- en: One way to change an array is to add new items to it. There are a few different
    ways to do this, so let’s take a look at each.
  id: totrans-1866
  prefs: []
  type: TYPE_NORMAL
  zh: 改变一个数组的方式之一是向其添加新项。有几种不同的方法可以做到这一点，让我们逐一看看。
- en: 'First, you can use an array’s append(_:) method. *Append* means to add something.
    Using append(_:) , you can add one new item to the end of your array. Say you
    go on another trip and visit the Badlands, and you want to add it to your list
    of national parks. To do that, add this code into your playground:'
  id: totrans-1867
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，你可以使用数组的 `append(_:)` 方法。*Append* 意思是添加某物。通过使用 `append(_:)`，你可以向数组的末尾添加一项新的元素。假设你又去了一趟旅行，参观了“Badlands”，并且你想将它添加到你的国家公园列表中。为此，你可以在你的
    playground 中添加如下代码：
- en: '![](Image00120.jpg)'
  id: totrans-1868
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00120.jpg)'
- en: To use the append(_:) method, first write the name of your array followed by
    a period and then append . Then, put the item you want to add to your array inside
    the parentheses. In this case, you put "Badlands" inside the parentheses.
  id: totrans-1869
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用 `append(_:)` 方法，首先写下你的数组名称，后面跟一个句点，再写 `append`。然后，将你想要添加到数组中的项放入括号内。在这个例子中，你将“Badlands”放入了括号内。
- en: 'If you want to add something at a specific place in your array, use the array’s
    insert(_:at:) method instead. This method takes two arguments: the item that you
    want to insert and the index of where it should go in the array. (We’ll discuss
    arguments in more detail in [Chapter 7](text00017.html#ch07) .)'
  id: totrans-1870
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想在数组中的特定位置添加一个元素，可以使用数组的 `insert(_:at:)` 方法。此方法有两个参数：你想插入的项以及它应该放置在数组中的索引位置。（我们将在[第7章](text00017.html#ch07)中更详细地讨论参数。）
- en: 'Let’s say you totally forgot that you went to the Petrified Forest right after
    you visited the Grand Canyon, and you want to update your nationalParks array
    so it displays the parks in the order in which you visited them. To update your
    array, you could use the insert(_:at:) method to put the Petrified Forest in the
    right position:'
  id: totrans-1871
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你完全忘记了自己在参观大峡谷后去过“Petrified Forest”，并且你想更新你的 `nationalParks` 数组，使它按你访问的顺序显示公园。要更新数组，你可以使用
    `insert(_:at:)` 方法，将“Petrified Forest”放到正确的位置：
- en: '![](Image00121.jpg)'
  id: totrans-1872
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00121.jpg)'
- en: When you insert a new item at index 3, everything that was in the array at index
    3 or higher gets scooted over to make room for the new item. That means the item
    that was at index 3 is now at index 4, the item that was at index 4 is now at
    index 5, and so on. After you add the Petrified Forest, nationalParks is now ["Acadia",
    "Zion", "Grand Canyon", "Petrified Forest", "Badlands"] .
  id: totrans-1873
  prefs: []
  type: TYPE_NORMAL
  zh: 当你在索引 3 处插入新项时，数组中从索引 3 或更高的所有元素都会被推后以为新项腾出空间。这意味着原本在索引 3 的项现在会移到索引 4，原本在索引
    4 的项会移到索引 5，以此类推。添加了“Petrified Forest”后，`nationalParks` 变成了 `["Acadia", "Zion",
    "Grand Canyon", "Petrified Forest", "Badlands"]`。
- en: '**COMBINING ARRAYS**'
  id: totrans-1874
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**合并数组**'
- en: 'Not only can you add new items to an array, but you can also add two arrays
    together using the + and += operators. Let’s say that you have the ingredients
    for a fruit smoothie in two arrays:'
  id: totrans-1875
  prefs: []
  type: TYPE_NORMAL
  zh: 你不仅可以向数组添加新项，还可以使用 `+` 和 `+=` 运算符将两个数组合并。假设你有两个数组，分别包含水果冰沙的原料：
- en: '![](Image00122.jpg)'
  id: totrans-1876
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00122.jpg)'
- en: Now you can make a delicious smoothie by adding the fruits and liquids arrays.
  id: totrans-1877
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你可以通过添加 `fruits` 和 `liquids` 数组来制作一款美味的冰沙。
- en: '![](Image00123.jpg)'
  id: totrans-1878
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00123.jpg)'
- en: The order of the ingredients in smoothie is the same as the order in fruits
    and liquids . If you created smoothie with liquids + fruits , then the liquids
    would come first.
  id: totrans-1879
  prefs: []
  type: TYPE_NORMAL
  zh: 冰沙中原料的顺序与 `fruits` 和 `liquids` 中的顺序相同。如果你使用 `liquids + fruits` 创建冰沙，那么液体将排在前面。
- en: 'You use the += operator to add an array to the end of your array. Add some
    whipped cream as follows for extra yumminess:'
  id: totrans-1880
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用 `+=` 运算符将一个数组添加到另一个数组的末尾。为了增加额外的美味感，可以按如下方式添加一些鲜奶油：
- en: '![](Image00124.jpg)'
  id: totrans-1881
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00124.jpg)'
- en: Note that ["whipped cream"] is an array even though it has a single item in
    it. When you’re using += to append something to an array, you have to make sure
    you’re only trying to add another array. If you were to just write the string
    "whipped cream" without the square brackets around it, you would get an error.
  id: totrans-1882
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，`["whipped cream"]` 是一个数组，尽管它只有一个项。当你使用 `+=` 来向数组添加元素时，必须确保你添加的是另一个数组。如果你只是写了字符串
    "whipped cream" 而没有用方括号括起来，就会报错。
- en: '![Image](Image00125.jpg)'
  id: totrans-1883
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00125.jpg)'
- en: '**REMOVING ITEMS FROM AN ARRAY**'
  id: totrans-1884
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**从数组中移除项目**'
- en: 'There are several methods for removing items from an array. Let’s start by
    looking at the array’s removeLast() method. As you might have guessed from its
    name, removeLast() removes the last item from your array. Let’s try it out with
    a shoppingList array:'
  id: totrans-1885
  prefs: []
  type: TYPE_NORMAL
  zh: 有几种方法可以从数组中移除项目。让我们首先看看数组的removeLast()方法。正如你从它的名字可以猜到的那样，removeLast()会移除数组中的最后一个项目。让我们在一个shoppingList数组中试试这个方法：
- en: '![](Image00126.jpg)'
  id: totrans-1886
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00126.jpg)'
- en: Neat! Note that the removeLast() method returns the removed item, so you can
    store it in a new constant or variable if you want.
  id: totrans-1887
  prefs: []
  type: TYPE_NORMAL
  zh: 很棒！请注意，removeLast()方法会返回被移除的项目，所以如果你需要，可以将它存储在一个新的常量或变量中。
- en: 'You can also remove an item from a specific index by using the remove(at:)
    method. Let’s say that your mom doesn’t want you buying any candy and takes that
    off the list:'
  id: totrans-1888
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以使用remove(at:)方法从特定索引移除一个项目。假设你的妈妈不希望你买糖果，并把它从列表上拿掉：
- en: '![Image](Image00127.jpg)![](Image00128.jpg)'
  id: totrans-1889
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00127.jpg)![](Image00128.jpg)'
- en: Just like when we added an item to the middle of our array and all the items
    scooted over to make room, if you remove an item from the middle of an array,
    the rest of the items will scoot back to fill in that empty space. The "apples"
    item that was at index 3 is now at index 2, where "candy" was.
  id: totrans-1890
  prefs: []
  type: TYPE_NORMAL
  zh: 就像我们在数组中间添加项目时，所有项目会向一侧移动以腾出空间一样，如果你从数组中间移除一个项目，其余的项目会向前移动以填补那个空位。原来在索引3的“苹果”项目现在位于索引2的位置，原本“糖果”在这里。
- en: 'You can also remove all items from an array with removeAll() . Try entering
    this into your playground:'
  id: totrans-1891
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以使用removeAll()方法移除数组中的所有项。试试在你的 Playground 中输入这个：
- en: '![](Image00129.jpg)'
  id: totrans-1892
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00129.jpg)'
- en: 'Note that trying to remove an item at an index that doesn’t exist will give
    you an error:'
  id: totrans-1893
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，尝试移除一个不存在的索引位置的项目会给你一个错误：
- en: '![](Image00130.jpg)'
  id: totrans-1894
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00130.jpg)'
- en: Our array doesn’t have this many items (in fact, now it’s empty!), so this throws
    an error. We’ll also get an error if we use removeLast() on our empty array, because
    there’s nothing in it—there’s no last index at all! However, removeAll() is always
    safe to use, even on an empty array.
  id: totrans-1895
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的数组并没有这么多项目（实际上，现在它是空的！），所以这会抛出一个错误。如果我们在空数组上使用removeLast()，也会出错，因为数组中没有任何内容——根本没有最后一个索引！然而，removeAll()总是安全的，即使是在空数组上使用也没问题。
- en: '**REPLACING ITEMS IN AN ARRAY**'
  id: totrans-1896
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**替换数组中的项目**'
- en: 'To replace an item in an array, you set the index of the array to the new value,
    as shown here:'
  id: totrans-1897
  prefs: []
  type: TYPE_NORMAL
  zh: 要替换数组中的一个项目，你需要将数组的索引设置为新的值，如下所示：
- en: '![](Image00131.jpg)'
  id: totrans-1898
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00131.jpg)'
- en: At ➊ , we replaced the item at index 2 (the third item) with "Unicorn" because
    magical animals count as favorite animals, too! At ➋ , we replaced the item at
    index 0 (the first item) with "Bearded dragon" . No, that’s not a real dragon—it’s
    just a lizard!
  id: totrans-1899
  prefs: []
  type: TYPE_NORMAL
  zh: 在➊，我们用“独角兽”替换了索引2（第三个项目）的位置，因为魔法动物也算作最喜欢的动物！在➋，我们用“胡须龙”替换了索引0（第一个项目）的位置。不是的，那不是一条真正的龙——它只是一个蜥蜴！
- en: Like any time you’re working with array index numbers, you have to be sure an
    item exists in the array at that index before you change its value, or you will
    get an Index out of range error.
  id: totrans-1900
  prefs: []
  type: TYPE_NORMAL
  zh: 就像每次处理数组索引时一样，你必须确保该索引位置的项目在数组中存在，才能更改它的值，否则你会遇到索引超出范围的错误。
- en: '[Figure 6-3](text00016.html#ch06fig3) shows the error that occurs if you try
    to add "Standard poodle" using favoriteAnimals[3] = "Standard poodle" . To add
    an item to the end of an array, you should use the append(_:) method or += , as
    we covered in “[Adding Items to an Array](text00016.html#ch06lev2sec5) ” on [page
    70](text00016.html#page_70) .'
  id: totrans-1901
  prefs: []
  type: TYPE_NORMAL
  zh: '[图6-3](text00016.html#ch06fig3)展示了如果你尝试用favoriteAnimals[3] = "Standard poodle"添加“标准贵宾犬”时会发生的错误。要向数组的末尾添加项目，你应该使用append(_:)方法或+=，我们在
    “[向数组添加项目](text00016.html#ch06lev2sec5)”中已经讲过，参见[第70页](text00016.html#page_70)。'
- en: '![Image](Image00132.jpg)'
  id: totrans-1902
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00132.jpg)'
- en: '*Figure 6-3: Don’t try to replace a value at an index beyond the existing array.*'
  id: totrans-1903
  prefs: []
  type: TYPE_NORMAL
  zh: '*图6-3：不要尝试替换超出现有数组范围的索引位置的值。*'
- en: Now you know how to change arrays however you might need to. You can add items,
    take items away, or replace items. Next, we’ll look at how to use the properties
    of arrays to find out even more information about them.
  id: totrans-1904
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你知道如何根据需要更改数组了。你可以添加项目、移除项目或替换项目。接下来，我们将看看如何使用数组的属性来获取更多关于数组的信息。
- en: '![Image](Image00133.jpg)'
  id: totrans-1905
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00133.jpg)'
- en: '**USING ARRAY PROPERTIES**'
  id: totrans-1906
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**使用数组属性**'
- en: In addition to methods like append(_:) and removeLast() , arrays also have *properties*
    . An array’s properties are variables or constants that contain some information
    about the array. Two really helpful properties that you might use are the Boolean
    property isEmpty and the integer property count .
  id: totrans-1907
  prefs: []
  type: TYPE_NORMAL
  zh: 除了 append(_:) 和 removeLast() 这类方法，数组还有 *属性*。数组的属性是包含关于数组的某些信息的变量或常量。你可能会使用的两个非常有用的属性是布尔类型的
    isEmpty 属性和整数类型的 count 属性。
- en: The isEmpty property is true or false depending on whether the array is empty,
    and the count property will tell you how many items are in that array.
  id: totrans-1908
  prefs: []
  type: TYPE_NORMAL
  zh: isEmpty 属性根据数组是否为空返回 true 或 false，count 属性则会告诉你数组中有多少个项目。
- en: 'Check out how these two properties are used in the following if-else statement:'
  id: totrans-1909
  prefs: []
  type: TYPE_NORMAL
  zh: 查看以下 if-else 语句中如何使用这两个属性：
- en: '![Image](Image00134.jpg)'
  id: totrans-1910
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00134.jpg)'
- en: 'This if-else statement checks whether the array mySiblings is empty ➊ . If
    it is, then "I don''t have any siblings." is printed. But if there is something
    in the array, then the number of siblings that we have is printed: "I have 3 siblings."
    ➋ .'
  id: totrans-1911
  prefs: []
  type: TYPE_NORMAL
  zh: 这个 if-else 语句检查数组 mySiblings 是否为空 ➊。如果为空，则打印 "我没有兄弟姐妹"。如果数组中有内容，则打印我们有多少兄弟姐妹："我有
    3 个兄弟姐妹。" ➋。
- en: '**LOOPING OVER AN ARRAY**'
  id: totrans-1912
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**遍历数组**'
- en: 'Sometimes when you’re working with arrays you might want to do something to
    every item in the array. You can use a for-in loop to do that! The following code
    will print every topping in a pizzaToppings array on a separate line:'
  id: totrans-1913
  prefs: []
  type: TYPE_NORMAL
  zh: 有时候，当你处理数组时，可能想对数组中的每个项目做一些事情。你可以使用 for-in 循环来实现！以下代码将在单独的行上打印 pizzaToppings
    数组中的每个配料：
- en: '![Image](Image00135.jpg)'
  id: totrans-1914
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00135.jpg)'
- en: To write a for-in loop for the pizzaToppings array, we used the keyword for
    , followed by the constant topping , then the keyword in , and finally the name
    of our array, pizzaToppings . Then we put the statements that we want to run for
    each topping inside the braces of the for-in loop. The constant topping ➊ temporarily
    represents each pizza topping in the array as we loop through it. We could have
    chosen any name for this constant, but it’s a good idea to pick something that
    makes sense. You can see the output of this for-in loop in [Figure 6-4](text00016.html#ch06fig4)
    .
  id: totrans-1915
  prefs: []
  type: TYPE_NORMAL
  zh: 为了为 pizzaToppings 数组编写一个 for-in 循环，我们使用了关键字 for，接着是常量 topping，然后是关键字 in，最后是我们数组的名称
    pizzaToppings。然后我们将想要为每个配料执行的语句放入 for-in 循环的大括号内。常量 topping ➊ 在我们循环遍历时临时代表数组中的每个披萨配料。我们可以为这个常量选择任何名字，但选择一个有意义的名字是个好主意。你可以在
    [图 6-4](text00016.html#ch06fig4) 中看到这个 for-in 循环的输出。
- en: '![Image](Image00136.jpg)'
  id: totrans-1916
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00136.jpg)'
- en: '*Figure 6-4: Output of the example for-in loop*'
  id: totrans-1917
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 6-4：示例 for-in 循环的输出*'
- en: '![Image](Image00137.jpg)'
  id: totrans-1918
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00137.jpg)'
- en: 'Using for-in loops is great for printing every value in an array. If you’re
    working with numbers, you can even use them to perform math operations on each
    item, which makes for some speedy calculations! The following code takes an array
    of numbers and calculates the square for each (the square of a number is that
    number multiplied by itself):'
  id: totrans-1919
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 for-in 循环非常适合打印数组中的每个值。如果你正在处理数字，甚至可以使用它们对每个项目执行数学运算，这样就能快速进行计算！以下代码取一个数字数组并计算每个数字的平方（一个数字的平方是该数字与它自己相乘）：
- en: '![Image](Image00138.jpg)'
  id: totrans-1920
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00138.jpg)'
- en: '[Figure 6-5](text00016.html#ch06fig5) shows the results.'
  id: totrans-1921
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 6-5](text00016.html#ch06fig5) 显示了结果。'
- en: '![Image](Image00139.jpg)'
  id: totrans-1922
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00139.jpg)'
- en: '*Figure 6-5: Printing the squares for each number in the myNumbers array*'
  id: totrans-1923
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 6-5：打印 myNumbers 数组中每个数字的平方*'
- en: '**DICTIONARIES ARE KEY!**'
  id: totrans-1924
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**字典是关键！**'
- en: A *dictionary* is also a collection of values, but instead of an ordered index,
    each value has its own *key* . Because there’s no index, the values are not stored
    in any particular order. To access values in a dictionary, you look them up by
    their key.
  id: totrans-1925
  prefs: []
  type: TYPE_NORMAL
  zh: '*字典* 也是一种值的集合，但与有序索引不同，每个值都有自己的 *键*。因为没有索引，所以这些值没有特定的存储顺序。要访问字典中的值，你需要通过其键来查找。'
- en: A key must be unique. You can’t have the same key more than once in the same
    dictionary. If there were two identical keys and you asked the computer to give
    you the value for one of them, the computer wouldn’t know which one to choose!
  id: totrans-1926
  prefs: []
  type: TYPE_NORMAL
  zh: 键必须是唯一的。你不能在同一个字典中使用相同的键两次。如果有两个相同的键，并且你要求计算机返回其中一个的值，计算机就无法知道选择哪个！
- en: Let’s take a look at how to make a dictionary and write keys that will help
    you find all the information you need.
  id: totrans-1927
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看如何创建一个字典，并写出有助于你查找所需信息的键。
- en: '![Image](Image00140.jpg)'
  id: totrans-1928
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00140.jpg)'
- en: '**INITIALIZING A DICTIONARY**'
  id: totrans-1929
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**初始化字典**'
- en: 'To create and initialize a dictionary, first write var and the name of your
    dictionary. Then write the keys and corresponding values inside a pair of square
    brackets, similar to an array. Let’s create a dictionary to store the names of
    a few US states. The key for each state will be its two-letter abbreviation:'
  id: totrans-1930
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建并初始化一个字典，首先写 var 和字典的名称。然后像数组一样在一对方括号内写入键和值对。我们来创建一个字典，用来存储一些美国州的名称。每个州的键将是其两字母缩写：
- en: '![](Image00141.jpg)'
  id: totrans-1931
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00141.jpg)'
- en: As you can see, there’s a colon between each key and its value, and the key/value
    pairs are separated by commas.
  id: totrans-1932
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，每个键和值之间有一个冒号，键值对之间用逗号分隔。
- en: Dictionaries are different from arrays in that they are *unordered* . Because
    of that, it’s likely that the order of the states that you see in your results
    pane ➋ is different from the order in which you entered your states ➊ . It might
    even be different than the order that’s printed in this book!
  id: totrans-1933
  prefs: []
  type: TYPE_NORMAL
  zh: 字典与数组不同，因为它们是*无序的*。因此，你在结果面板中看到的州的顺序➋很可能与输入州的顺序➊不同。它甚至可能与本书中打印的顺序不同！
- en: As with arrays, you can use var to make a mutable dictionary or use let to make
    an immutable dictionary.
  id: totrans-1934
  prefs: []
  type: TYPE_NORMAL
  zh: 与数组一样，你可以使用 var 来创建可变字典，或者使用 let 来创建不可变字典。
- en: 'In Swift, all of the keys of a dictionary must be the same type, and all of
    the values of a dictionary must also be the same type, but the key type doesn’t
    have to match the value type. For example, if you wanted to store a collection
    of fractions, you could use doubles for the keys and strings for the values:'
  id: totrans-1935
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Swift 中，字典的所有键必须是相同类型，所有值也必须是相同类型，但键的类型不必与值的类型相匹配。例如，如果你想存储一个分数集合，你可以使用 double
    类型作为键，使用字符串类型作为值：
- en: '![](Image00142.jpg)'
  id: totrans-1936
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00142.jpg)'
- en: In this dictionary, all of the keys must be doubles, and all of the values must
    be strings. Again, you’ll see that the order of the numbers in the results pane
    can be quite different from the order in which you wrote the fractions in your
    dictionary. This is fine because you don’t need to know the order to access anything.
    You can find any item that you need by its key. Let’s see how!
  id: totrans-1937
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个字典中，所有的键必须是 double 类型，所有的值必须是字符串类型。同样，你会发现结果面板中数字的顺序可能与字典中分数的顺序完全不同。这没关系，因为你不需要知道顺序来访问任何内容。你可以通过键找到任何你需要的项。让我们来看看怎么做！
- en: '**ACCESSING VALUES IN A DICTIONARY**'
  id: totrans-1938
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**访问字典中的值**'
- en: 'Looking up a value in a dictionary is similar to how you access a value in
    an array except that you use a key inside the square brackets instead of an index,
    like this: usStates["TX"] .'
  id: totrans-1939
  prefs: []
  type: TYPE_NORMAL
  zh: 在字典中查找值类似于在数组中访问值，只是你在方括号内使用键而不是索引，像这样：usStates["TX"]。
- en: There is a big difference, however, in how Swift returns the values from a dictionary.
    When you access a value at an index of an array, you are simply given the value.
    When you access a value with a key in a dictionary, you are given an optional.
  id: totrans-1940
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，Swift 在从字典返回值时存在很大差异。当你通过索引访问数组中的值时，你只会得到该值。而当你通过键访问字典中的值时，你会得到一个可选值。
- en: In [Chapter 5](text00015.html#ch05) , you learned that optionals might contain
    a value or might be nil . The reason Swift returns optionals when you’re looking
    up items in a dictionary is that the key you used might not exist in the dictionary,
    in which case there’s no value to access. Trying to access a value that doesn’t
    exist would give you a big fat error! To avoid that problem, Swift returns optionals.
    That means you need to unwrap any value you get out of a dictionary before you
    can do anything with it.
  id: totrans-1941
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第5章](text00015.html#ch05)中，你学过可选值可能包含一个值，也可能是nil。Swift 返回可选值的原因是，当你在字典中查找项目时，你使用的键可能在字典中不存在，这时就没有值可以访问。尝试访问不存在的值会给你带来一个大错误！为了避免这个问题，Swift
    返回可选值。这意味着，在你做任何操作之前，你需要解包从字典中获得的值。
- en: 'To unwrap an optional, first you check whether it exists using an if-let statement,
    just like we did in [Chapter 5](text00015.html#ch05) . The following code shows
    you how to get a value out of a dictionary:'
  id: totrans-1942
  prefs: []
  type: TYPE_NORMAL
  zh: 要解包一个可选值，首先你需要使用 if-let 语句检查它是否存在，就像我们在[第5章](text00015.html#ch05)中所做的那样。以下代码展示了如何从字典中获取一个值：
- en: '![Image](Image00143.jpg)'
  id: totrans-1943
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00143.jpg)'
- en: To retrieve "Texas" from the dictionary, we use if let to set a constant loneStarState
    to usStates["TX"] ➊ . Because we have this state in our dictionary, the line I
    have Texas in my dictionary. is printed. Next we try to access a state that is
    not in our dictionary by using the key usStates["FL"] ➋ . Thankfully, because
    we used an if-let statement, the program won’t crash when the computer can’t find
    this state. Instead, I don't have that state in my dictionary. is printed.
  id: totrans-1944
  prefs: []
  type: TYPE_NORMAL
  zh: 为了从字典中获取“Texas”，我们使用if let将常量loneStarState设置为usStates["TX"] ➊。因为我们的字典中有这个州，所以会打印出“我在字典中有Texas”。接下来，我们尝试使用usStates["FL"]
    ➋访问一个不在字典中的州。幸运的是，因为我们使用了if-let语句，当计算机找不到该州时，程序不会崩溃，而是会打印出“我在字典中没有这个州”。
- en: '**ADDING ITEMS TO A DICTIONARY**'
  id: totrans-1945
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**向字典中添加项**'
- en: 'To add an item to a dictionary, first write the name of your dictionary and
    assign the new item to the key you want it to have in the dictionary. Let’s add
    "Minnesota" to our usStates dictionary:'
  id: totrans-1946
  prefs: []
  type: TYPE_NORMAL
  zh: 要向字典中添加一个项，首先写出字典的名称，并将新项赋值给你希望它在字典中拥有的键。让我们把“明尼苏达”添加到我们的usStates字典中：
- en: '![](Image00144.jpg)'
  id: totrans-1947
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00144.jpg)'
- en: 'Now when you look at usStates , you’ll see that it’s updated to ["MN": "Minnesota",
    "WA": "Washington", "MA": "Massachusetts", "TX": "Texas"] . Remember, because
    you don’t have to rely on indices, your new dictionary item might appear anywhere
    in the dictionary.'
  id: totrans-1948
  prefs: []
  type: TYPE_NORMAL
  zh: '现在，当你查看usStates时，你会看到它已经更新为["MN": "Minnesota", "WA": "Washington", "MA": "Massachusetts",
    "TX": "Texas"]。记住，由于你不必依赖索引，所以你的新字典项可能出现在字典中的任何位置。'
- en: '**REMOVING ITEMS FROM A DICTIONARY**'
  id: totrans-1949
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**从字典中删除项**'
- en: Removing an item from a dictionary is quite simple; you do so by setting the
    value to nil . Because the values in dictionaries are returned as optionals, you
    don’t have to worry about nil causing any problems in your dictionary.
  id: totrans-1950
  prefs: []
  type: TYPE_NORMAL
  zh: 从字典中删除项非常简单；你只需要将该值设置为nil。由于字典中的值是作为可选项返回的，你不必担心nil会导致字典出现问题。
- en: '![](Image00145.jpg)'
  id: totrans-1951
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00145.jpg)'
- en: 'You can see that after you remove the value at the key "MA" , usStates is updated
    to ["MN": "Minnesota", "WA": "Washington", "TX": "Texas"] . Remember that nil
    is special and means that there’s no value at all. That’s why you don’t see "MA":
    nil in our dictionary.'
  id: totrans-1952
  prefs: []
  type: TYPE_NORMAL
  zh: '你可以看到，在删除了键“MA”对应的值之后，usStates更新为["MN": "Minnesota", "WA": "Washington", "TX":
    "Texas"]。记住，nil是特殊的，表示没有值。因此，你在字典中不会看到"MA": nil。'
- en: '**REPLACING ITEMS IN A DICTIONARY**'
  id: totrans-1953
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**替换字典中的项**'
- en: 'Replacing an item in a dictionary is also easy. It works the same was as replacing
    an item in an array. You just set the item that you want to replace to something
    else. Say you create a dictionary of fruit colors:'
  id: totrans-1954
  prefs: []
  type: TYPE_NORMAL
  zh: 替换字典中的项也很简单。它的工作方式与替换数组中的项相同。你只需要将想要替换的项设置为其他值。假设你创建了一个水果颜色的字典：
- en: '![](Image00146.jpg)'
  id: totrans-1955
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00146.jpg)'
- en: At first we had the value "apple" for "red" , but then we decided that "raspberry"
    is a better fruit to use since sometimes apples are green or yellow. To replace
    "apple" with "raspberry" , we set colorFruits["red"] to its new value ➊ .
  id: totrans-1956
  prefs: []
  type: TYPE_NORMAL
  zh: 起初我们将“苹果”作为“红色”的值，但后来我们决定“覆盆子”更适合，因为有时候苹果是绿色或黄色的。为了将“苹果”替换为“覆盆子”，我们将colorFruits["red"]设置为新的值
    ➊。
- en: You may remember that this is the same way we entered a new value into a dictionary.
    If the key already exists in the dictionary, then the value for that key is replaced.
    If the key doesn’t already exist, then the new key/value pair will be added to
    the dictionary.
  id: totrans-1957
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能还记得，这与我们将新值添加到字典中的方式相同。如果键已经存在于字典中，那么该键对应的值将被替换。如果键不存在，那么新的键/值对将被添加到字典中。
- en: '![Image](Image00147.jpg)'
  id: totrans-1958
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00147.jpg)'
- en: '**USING DICTIONARY PROPERTIES**'
  id: totrans-1959
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**使用字典属性**'
- en: 'Like an array, a dictionary also has an isEmpty property and a count property.
    For example, the following code shows how you can use the isEmpty property to
    check if a dictionary is empty, and if it isn’t empty, the count property checks
    how many items you have. Imagine you have a basket of fruit for sale. You can
    use these properties to help you keep track of everything:'
  id: totrans-1960
  prefs: []
  type: TYPE_NORMAL
  zh: 像数组一样，字典也有isEmpty属性和count属性。例如，以下代码展示了如何使用isEmpty属性来检查字典是否为空，如果不为空，count属性则用来检查字典中有多少项。假设你有一个水果销售篮，你可以使用这些属性帮助你跟踪所有的水果：
- en: '![Image](Image00148.jpg)'
  id: totrans-1961
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00148.jpg)'
- en: 'A dictionary also has two special properties: keys , which contains all of
    the dictionary’s keys, and values , which contains all of its values. We’ll use
    these two properties when we loop through the dictionary.'
  id: totrans-1962
  prefs: []
  type: TYPE_NORMAL
  zh: 字典也有两个特殊属性：keys，包含字典的所有键，以及values，包含字典的所有值。当我们遍历字典时，会使用这两个属性。
- en: Let’s write some code that loops through our fruit baskets and prints the price
    of each fruit.
  id: totrans-1963
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们写一些代码，通过循环遍历我们的水果篮子并打印每种水果的价格。
- en: '**LOOPING OVER A DICTIONARY**'
  id: totrans-1964
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**遍历字典**'
- en: 'You can loop through a dictionary using a for-in loop. Because each item has
    a key and a value, you can do this in two different ways. This is how to loop
    through a dictionary using its keys:'
  id: totrans-1965
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用for-in循环遍历字典。由于每个项目都有一个键和值，你可以用两种不同的方式来实现。以下是如何通过键遍历字典：
- en: '![Image](Image00149.jpg)'
  id: totrans-1966
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00149.jpg)'
- en: Here we use the dictionary’s keys property ➊ to loop through fruitBasket and
    print its contents. We start by writing the keyword for , followed by a constant
    name fruit for the dictionary key, the keyword in , the dictionary name, a period,
    and keys .
  id: totrans-1967
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们使用字典的keys属性 ➊ 来遍历fruitBasket并打印其内容。我们首先写下关键字for，后跟字典键的常量名称fruit，关键字in，字典名称，句点和keys。
- en: Inside the braces of our for-in loop, we have access to both the key, which
    we call fruit ➋ , and the value at that key when we force-unwrap its contents
    with fruitBasket[fruit]! ➌ . That value will be the fruit’s price.
  id: totrans-1968
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的for-in循环的花括号内，我们可以访问键（我们称之为fruit ➋）和该键的值，当我们强制解包它的内容时，可以通过fruitBasket[fruit]!
    ➌获取。该值将是水果的价格。
- en: In this case, it’s safe to force-unwrap the value using an exclamation point
    because we know that the fruit key we’re using is definitely inside the dictionary.
  id: totrans-1969
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，使用感叹号强制解包值是安全的，因为我们知道我们使用的fruit键肯定在字典中。
- en: Any code we put inside the for-in loop will run once for every key in our dictionary.
    So you should see the print statement display three times.
  id: totrans-1970
  prefs: []
  type: TYPE_NORMAL
  zh: 我们放在for-in循环中的任何代码都会对字典中的每个键执行一次。所以你应该看到打印语句显示三次。
- en: 'We can also loop through the dictionary using its values property:'
  id: totrans-1971
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以通过字典的values属性进行循环遍历：
- en: '![Image](Image00150.jpg)'
  id: totrans-1972
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00150.jpg)'
- en: We use the same style of for-in loop, but now we use a constant to refer to
    each value, which we call price , in the values property. When looping through
    values, we don’t have access to the keys from inside the loop.
  id: totrans-1973
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用相同类型的for-in循环，但现在我们使用常量来引用values属性中的每个值，我们称之为price。当遍历值时，我们无法在循环内访问键。
- en: Another difference to note is that price is not an optional because it’s accessed
    directly as a value in the fruitBasket dictionary. That means we don’t have to
    unwrap it. You should still see the print statement printed three times. [Figure
    6-6](text00016.html#ch06fig6) shows the output of both loops.
  id: totrans-1974
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个需要注意的区别是price不是一个可选值，因为它是直接作为fruitBasket字典中的值来访问的。这意味着我们不需要解包它。你仍然应该看到打印语句打印三次。[图
    6-6](text00016.html#ch06fig6)展示了两个循环的输出。
- en: '![Image](Image00151.jpg)'
  id: totrans-1975
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00151.jpg)'
- en: '*Figure 6-6: Looping through the keys and values of a dictionary with a for-in
    loop*'
  id: totrans-1976
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 6-6：使用for-in循环遍历字典的键和值*'
- en: The order of your results might be slightly different from ours. That’s because
    the items in a dictionary aren’t in a numbered order like they are in an array!
    And because the order is not guaranteed, you might see a different order printed
    if you run the same code again.
  id: totrans-1977
  prefs: []
  type: TYPE_NORMAL
  zh: 你的结果顺序可能与我们的稍有不同。那是因为字典中的项目不像数组中的项目那样按编号顺序排列！由于顺序不保证，如果你重新运行相同的代码，你可能会看到不同的顺序。
- en: '**WHAT YOU LEARNED**'
  id: totrans-1978
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**你学到的内容**'
- en: In this chapter, you learned how to store collections of items in an array and
    in a dictionary. To store items in an ordered list, you would use an array and
    look up each item by its index. If you wanted to store items by key instead, you
    would use a dictionary.
  id: totrans-1979
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一章中，你学会了如何将项目集合存储在数组和字典中。要存储有序的列表，你可以使用数组，并通过索引查找每个项目。如果你想按键存储项目，则应使用字典。
- en: Knowing about arrays and dictionaries and how to use them is a powerful building
    block for almost any programming language. Next we will learn about functions,
    another very powerful tool. Functions are blocks of code that you create and name
    to perform a specific job. After you have written a function, you can use its
    name to call it from almost anywhere in your program.
  id: totrans-1980
  prefs: []
  type: TYPE_NORMAL
  zh: 了解数组和字典以及如何使用它们是几乎任何编程语言的强大构建块。接下来我们将学习函数，另一个非常强大的工具。函数是你创建并命名的代码块，用于执行特定的任务。在编写函数之后，你可以在程序的几乎任何地方调用它。
- en: Our nationalParks array is a variable because we created it with the var keyword
    ➊ . An array stored in a variable is called a *mutable* array. This means that
    you can change it by adding items, removing items, or swapping items in and out.
  id: totrans-1981
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的 nationalParks 数组是一个变量，因为我们是用 var 关键词创建的 ➊。存储在变量中的数组被称为*可变*数组。这意味着你可以通过添加项目、删除项目或交换项目来更改它。
- en: You can also create an *immutable* array. An immutable array is created with
    the keyword let instead of var . Similar to a constant, once an immutable array
    is created, nothing in it can be changed.
  id: totrans-1982
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以创建一个*不可变*数组。不可变数组是通过关键词let而不是var来创建的。类似于常量，一旦不可变数组被创建，里面的内容就无法更改。
- en: So when should you use a mutable array or an immutable array? It’s best to use
    let if you know your collection will never change, like if you’re storing the
    colors of the rainbow. You should use var if you need to change your collection,
    like if you’re storing an array of your favorite T-shirts, which might change
    depending on what’s in style!
  id: totrans-1983
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，什么时候应该使用可变数组或不可变数组呢？如果你知道你的集合永远不会改变，比如你存储的是彩虹的颜色，最好使用let。如果你需要改变集合，比如存储的是你最喜欢的T恤的数组，而这些T恤可能会根据流行趋势发生变化，那么应该使用var。
- en: '![Image](Image00116.jpg)'
  id: totrans-1984
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00116.jpg)'
- en: '**USING TYPE INFERENCE**'
  id: totrans-1985
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**使用类型推断**'
- en: 'When we created our nationalParks array, we specified that we were creating
    an array of string values by adding a colon (: ) and [String] ➋ . This step is
    optional when you create an array and initialize it with one or more values because
    Swift will use type inference to determine the kind of data you want the array
    to hold. That means that you could just as easily have created the array by doing
    this:'
  id: totrans-1986
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们创建 nationalParks 数组时，我们通过添加冒号(:)和[String] ➋来指定我们正在创建一个字符串值的数组。当你创建一个数组并用一个或多个值初始化它时，这一步是可选的，因为
    Swift 会使用类型推断来确定你希望数组保存的数据类型。这意味着你完全可以像这样创建数组：
- en: '![](Image00117.jpg)'
  id: totrans-1987
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00117.jpg)'
- en: Using type inference, Swift knows we initialized this array to hold strings,
    and it can hold only strings.
  id: totrans-1988
  prefs: []
  type: TYPE_NORMAL
  zh: 使用类型推断，Swift 知道我们初始化这个数组以保存字符串，而且它只能保存字符串。
- en: The list of parks that we created the array with is an example of an array *literal*
    . A literal is a value that is exactly what you see. It is not a variable or constant
    but rather just the value without a name. "Grand Canyon" is an example of a string
    literal, and 7 is an example of an integer literal. An array literal is a list
    of items contained between two square brackets and separated by commas, like ["Acadia",
    "Zion", "Grand Canyon"] ➊ .
  id: totrans-1989
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建数组时使用的公园列表是数组*字面量*的一个例子。字面量是你所看到的值，准确无误。它不是变量或常量，而只是没有名称的值。"Grand Canyon"
    是一个字符串字面量，而 7 是一个整数字面量。数组字面量是包含在两个方括号之间，并用逗号分隔的项列表，如 ["Acadia", "Zion", "Grand
    Canyon"] ➊。
- en: '**ACCESSING ITEMS IN AN ARRAY**'
  id: totrans-1990
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**访问数组中的项**'
- en: 'Let’s say you want to access an item in your array and use it in your program.
    Your friend asks you to tell them all about your travels, so you want to use the
    names of the national parks that you stored in the array. To access an item in
    your array, write the array name followed by the item’s index inside square brackets:'
  id: totrans-1991
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你想访问数组中的一项，并在程序中使用它。你的朋友问你关于旅行的所有事情，所以你想使用你在数组中存储的国家公园的名称。要访问数组中的一项，写出数组名称，后面跟上方括号内的索引：
- en: '![](Image00118.jpg)'
  id: totrans-1992
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00118.jpg)'
- en: In this example, we are accessing the names of the national parks and then printing
    them to the screen using print . To get the first item in nationalParks , you
    use nationalParks[0] ➊ . To access the second item in nationalParks , you use
    nationalParks[1] .
  id: totrans-1993
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们正在访问国家公园的名称，然后通过print将它们打印到屏幕上。要获取 nationalParks 中的第一项，使用 nationalParks[0]
    ➊。要访问 nationalParks 中的第二项，使用 nationalParks[1]。
- en: '**WATCHING THE RANGE**'
  id: totrans-1994
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**观察范围**'
- en: One important point about arrays is that if you try to access an item at an
    index that’s higher than the last index in the array, you’ll get an error. In
    [Figure 6-2](text00016.html#ch06fig2) , you can see that nationalParks[3] (which
    would be the fourth item in the array) gives you an error because there are only
    three national parks in the array, indexed from 0 to 2.
  id: totrans-1995
  prefs: []
  type: TYPE_NORMAL
  zh: 关于数组，有一个重要的点是，如果你尝试访问一个索引大于数组最后一个索引的项，你会得到一个错误。在[图6-2](text00016.html#ch06fig2)中，你可以看到
    nationalParks[3]（它应该是数组中的第四个元素）会给出一个错误，因为数组中只有三个国家公园，索引从0到2。
- en: As you can see, you get an error message that says Index out of range . If you
    try to access an item that doesn’t exist in your array, your app will crash!
  id: totrans-1996
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，你会收到一条错误信息，提示“索引超出范围”。如果你尝试访问数组中不存在的项，应用程序将崩溃！
- en: '![Image](Image00119.jpg)'
  id: totrans-1997
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00119.jpg)'
- en: '*Figure 6-2: Trying to access an index in the array where nothing exists causes
    an error.*'
  id: totrans-1998
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 6-2：尝试访问数组中不存在的索引会导致错误。*'
- en: '**ADDING ITEMS TO AN ARRAY**'
  id: totrans-1999
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**向数组添加项**'
- en: One way to change an array is to add new items to it. There are a few different
    ways to do this, so let’s take a look at each.
  id: totrans-2000
  prefs: []
  type: TYPE_NORMAL
  zh: 修改数组的一种方法是向其中添加新项。有几种不同的方式可以做到这一点，让我们逐一了解。
- en: 'First, you can use an array’s append(_:) method. *Append* means to add something.
    Using append(_:) , you can add one new item to the end of your array. Say you
    go on another trip and visit the Badlands, and you want to add it to your list
    of national parks. To do that, add this code into your playground:'
  id: totrans-2001
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，你可以使用数组的 append(_:) 方法。*附加*意味着添加某个内容。使用 append(_:) 方法，你可以将一个新项添加到数组的末尾。假设你又去了一次旅行，参观了坏lands，你想把它添加到你的国家公园列表中。为此，请将以下代码添加到你的
    playground 中：
- en: '![](Image00120.jpg)'
  id: totrans-2002
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00120.jpg)'
- en: To use the append(_:) method, first write the name of your array followed by
    a period and then append . Then, put the item you want to add to your array inside
    the parentheses. In this case, you put "Badlands" inside the parentheses.
  id: totrans-2003
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用 append(_:) 方法，首先写下数组的名称，后跟一个句点，然后添加 append。接着，将你想添加到数组中的项放在括号内。在这个例子中，你将
    "Badlands" 放在了括号内。
- en: 'If you want to add something at a specific place in your array, use the array’s
    insert(_:at:) method instead. This method takes two arguments: the item that you
    want to insert and the index of where it should go in the array. (We’ll discuss
    arguments in more detail in [Chapter 7](text00017.html#ch07) .)'
  id: totrans-2004
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想在数组中的特定位置添加内容，请改用数组的 insert(_:at:) 方法。该方法需要两个参数：你要插入的项和它应该插入数组中的位置索引。（我们将在[第7章](text00017.html#ch07)中详细讨论参数。）
- en: 'Let’s say you totally forgot that you went to the Petrified Forest right after
    you visited the Grand Canyon, and you want to update your nationalParks array
    so it displays the parks in the order in which you visited them. To update your
    array, you could use the insert(_:at:) method to put the Petrified Forest in the
    right position:'
  id: totrans-2005
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你完全忘记了在参观大峡谷后你去了化石森林，现在你想更新你的 nationalParks 数组，以便按照你访问的顺序显示这些公园。要更新数组，你可以使用
    insert(_:at:) 方法，将化石森林放到正确的位置：
- en: '![](Image00121.jpg)'
  id: totrans-2006
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00121.jpg)'
- en: When you insert a new item at index 3, everything that was in the array at index
    3 or higher gets scooted over to make room for the new item. That means the item
    that was at index 3 is now at index 4, the item that was at index 4 is now at
    index 5, and so on. After you add the Petrified Forest, nationalParks is now ["Acadia",
    "Zion", "Grand Canyon", "Petrified Forest", "Badlands"] .
  id: totrans-2007
  prefs: []
  type: TYPE_NORMAL
  zh: 当你在索引 3 处插入新项时，数组中索引 3 或更高位置的所有项都会被移到一边，为新项腾出空间。这意味着原来在索引 3 处的项现在会移到索引 4，原来在索引
    4 处的项会移到索引 5，以此类推。在你添加化石森林之后，nationalParks 数组现在是 ["Acadia", "Zion", "Grand Canyon",
    "Petrified Forest", "Badlands"]。
- en: '**COMBINING ARRAYS**'
  id: totrans-2008
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**合并数组**'
- en: 'Not only can you add new items to an array, but you can also add two arrays
    together using the + and += operators. Let’s say that you have the ingredients
    for a fruit smoothie in two arrays:'
  id: totrans-2009
  prefs: []
  type: TYPE_NORMAL
  zh: 你不仅可以向数组添加新项，还可以使用 + 和 += 运算符将两个数组连接起来。假设你有两个数组，其中包含制作水果冰沙的所有配料：
- en: '![](Image00122.jpg)'
  id: totrans-2010
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00122.jpg)'
- en: Now you can make a delicious smoothie by adding the fruits and liquids arrays.
  id: totrans-2011
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你可以通过将水果和液体数组添加到一起制作美味的冰沙。
- en: '![](Image00123.jpg)'
  id: totrans-2012
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00123.jpg)'
- en: The order of the ingredients in smoothie is the same as the order in fruits
    and liquids . If you created smoothie with liquids + fruits , then the liquids
    would come first.
  id: totrans-2013
  prefs: []
  type: TYPE_NORMAL
  zh: 冰沙中成分的顺序与水果和液体的顺序相同。如果你是用液体 + 水果创建的冰沙，那么液体会排在前面。
- en: 'You use the += operator to add an array to the end of your array. Add some
    whipped cream as follows for extra yumminess:'
  id: totrans-2014
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用 += 运算符将一个数组添加到你的数组末尾。为了增加一点美味，可以添加一些鲜奶油：
- en: '![](Image00124.jpg)'
  id: totrans-2015
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00124.jpg)'
- en: Note that ["whipped cream"] is an array even though it has a single item in
    it. When you’re using += to append something to an array, you have to make sure
    you’re only trying to add another array. If you were to just write the string
    "whipped cream" without the square brackets around it, you would get an error.
  id: totrans-2016
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，["whipped cream"] 是一个数组，即使它只有一个项。当你使用 += 将内容附加到数组时，你必须确保只添加另一个数组。如果你只写了字符串
    "whipped cream" 而没有方括号，你会收到一个错误。
- en: '![Image](Image00125.jpg)'
  id: totrans-2017
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00125.jpg)'
- en: '**REMOVING ITEMS FROM AN ARRAY**'
  id: totrans-2018
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**从数组中删除项**'
- en: 'There are several methods for removing items from an array. Let’s start by
    looking at the array’s removeLast() method. As you might have guessed from its
    name, removeLast() removes the last item from your array. Let’s try it out with
    a shoppingList array:'
  id: totrans-2019
  prefs: []
  type: TYPE_NORMAL
  zh: 删除数组中项的方法有好几种。让我们先看看数组的removeLast()方法。正如你从它的名字中可能猜到的，removeLast()会删除数组中的最后一项。让我们尝试一下使用一个shoppingList数组：
- en: '![](Image00126.jpg)'
  id: totrans-2020
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00126.jpg)'
- en: Neat! Note that the removeLast() method returns the removed item, so you can
    store it in a new constant or variable if you want.
  id: totrans-2021
  prefs: []
  type: TYPE_NORMAL
  zh: 很棒！请注意，removeLast()方法会返回被删除的项，因此如果你想，可以将其存储在一个新的常量或变量中。
- en: 'You can also remove an item from a specific index by using the remove(at:)
    method. Let’s say that your mom doesn’t want you buying any candy and takes that
    off the list:'
  id: totrans-2022
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以使用remove(at:)方法从特定索引删除项。假设你的妈妈不希望你买糖果，并将其从列表中移除：
- en: '![Image](Image00127.jpg)![](Image00128.jpg)'
  id: totrans-2023
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00127.jpg)![](Image00128.jpg)'
- en: Just like when we added an item to the middle of our array and all the items
    scooted over to make room, if you remove an item from the middle of an array,
    the rest of the items will scoot back to fill in that empty space. The "apples"
    item that was at index 3 is now at index 2, where "candy" was.
  id: totrans-2024
  prefs: []
  type: TYPE_NORMAL
  zh: 就像我们在数组中间添加项时，所有项会移动以腾出空间一样，如果你从数组中间删除项，剩下的项会移动以填补这个空位。原本在索引3处的“苹果”项现在位于索引2的位置，那里原来是“糖果”。
- en: 'You can also remove all items from an array with removeAll() . Try entering
    this into your playground:'
  id: totrans-2025
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以使用removeAll()删除数组中的所有项。试着在你的 playground 中输入这个：
- en: '![](Image00129.jpg)'
  id: totrans-2026
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00129.jpg)'
- en: 'Note that trying to remove an item at an index that doesn’t exist will give
    you an error:'
  id: totrans-2027
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，尝试删除一个不存在的索引处的项会导致错误：
- en: '![](Image00130.jpg)'
  id: totrans-2028
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00130.jpg)'
- en: Our array doesn’t have this many items (in fact, now it’s empty!), so this throws
    an error. We’ll also get an error if we use removeLast() on our empty array, because
    there’s nothing in it—there’s no last index at all! However, removeAll() is always
    safe to use, even on an empty array.
  id: totrans-2029
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的数组没有这么多项（事实上，现在它是空的！），所以这会抛出一个错误。如果我们在空数组上使用removeLast()，也会出错，因为数组里没有任何内容——根本没有最后一个索引！不过，使用removeAll()始终是安全的，即使是空数组。
- en: '**REPLACING ITEMS IN AN ARRAY**'
  id: totrans-2030
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**替换数组中的项**'
- en: 'To replace an item in an array, you set the index of the array to the new value,
    as shown here:'
  id: totrans-2031
  prefs: []
  type: TYPE_NORMAL
  zh: 要替换数组中的一项，你需要将该索引的位置设置为新值，如下所示：
- en: '![](Image00131.jpg)'
  id: totrans-2032
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00131.jpg)'
- en: At ➊ , we replaced the item at index 2 (the third item) with "Unicorn" because
    magical animals count as favorite animals, too! At ➋ , we replaced the item at
    index 0 (the first item) with "Bearded dragon" . No, that’s not a real dragon—it’s
    just a lizard!
  id: totrans-2033
  prefs: []
  type: TYPE_NORMAL
  zh: 在➊，我们将索引为2（第三项）的项替换为“独角兽”，因为魔法动物也算是最喜欢的动物！在➋，我们将索引为0（第一项）的项替换为“胡须龙”。不，这不是一只真正的龙——它只是一只蜥蜴！
- en: Like any time you’re working with array index numbers, you have to be sure an
    item exists in the array at that index before you change its value, or you will
    get an Index out of range error.
  id: totrans-2034
  prefs: []
  type: TYPE_NORMAL
  zh: 就像每次你处理数组索引时一样，在更改值之前，你必须确保该索引处的项在数组中存在，否则你会遇到“索引超出范围”的错误。
- en: '[Figure 6-3](text00016.html#ch06fig3) shows the error that occurs if you try
    to add "Standard poodle" using favoriteAnimals[3] = "Standard poodle" . To add
    an item to the end of an array, you should use the append(_:) method or += , as
    we covered in “[Adding Items to an Array](text00016.html#ch06lev2sec5) ” on [page
    70](text00016.html#page_70) .'
  id: totrans-2035
  prefs: []
  type: TYPE_NORMAL
  zh: '[图6-3](text00016.html#ch06fig3)展示了如果你尝试使用favoriteAnimals[3] = "标准贵宾犬"来添加“标准贵宾犬”，会发生什么错误。要将项添加到数组的末尾，你应该使用append(_:)方法或+=，正如我们在“[向数组添加项](text00016.html#ch06lev2sec5)”中所讲的，在[第70页](text00016.html#page_70)。'
- en: '![Image](Image00132.jpg)'
  id: totrans-2036
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00132.jpg)'
- en: '*Figure 6-3: Don’t try to replace a value at an index beyond the existing array.*'
  id: totrans-2037
  prefs: []
  type: TYPE_NORMAL
  zh: '*图6-3：不要尝试替换超出现有数组范围的索引处的值。*'
- en: Now you know how to change arrays however you might need to. You can add items,
    take items away, or replace items. Next, we’ll look at how to use the properties
    of arrays to find out even more information about them.
  id: totrans-2038
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你知道如何根据需要更改数组了。你可以添加项、删除项，或替换项。接下来，我们将看看如何使用数组的属性来获取更多关于它们的信息。
- en: '![Image](Image00133.jpg)'
  id: totrans-2039
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00133.jpg)'
- en: '**USING ARRAY PROPERTIES**'
  id: totrans-2040
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**使用数组属性**'
- en: In addition to methods like append(_:) and removeLast() , arrays also have *properties*
    . An array’s properties are variables or constants that contain some information
    about the array. Two really helpful properties that you might use are the Boolean
    property isEmpty and the integer property count .
  id: totrans-2041
  prefs: []
  type: TYPE_NORMAL
  zh: 除了像 append(_:) 和 removeLast() 这样的操作方法外，数组还有 *属性* 。数组的属性是包含一些数组信息的变量或常量。有两个非常有用的属性你可能会使用：布尔型的
    isEmpty 属性和整数型的 count 属性。
- en: The isEmpty property is true or false depending on whether the array is empty,
    and the count property will tell you how many items are in that array.
  id: totrans-2042
  prefs: []
  type: TYPE_NORMAL
  zh: isEmpty 属性根据数组是否为空返回 true 或 false，count 属性则会告诉你数组中有多少项。
- en: 'Check out how these two properties are used in the following if-else statement:'
  id: totrans-2043
  prefs: []
  type: TYPE_NORMAL
  zh: 看看这两个属性在下面的 if-else 语句中的使用方式：
- en: '![Image](Image00134.jpg)'
  id: totrans-2044
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00134.jpg)'
- en: 'This if-else statement checks whether the array mySiblings is empty ➊ . If
    it is, then "I don''t have any siblings." is printed. But if there is something
    in the array, then the number of siblings that we have is printed: "I have 3 siblings."
    ➋ .'
  id: totrans-2045
  prefs: []
  type: TYPE_NORMAL
  zh: 这个 if-else 语句检查 mySiblings 数组是否为空 ➊。如果为空，则打印出 “我没有兄弟姐妹。” 如果数组中有元素，则打印出兄弟姐妹的数量：“我有
    3 个兄弟姐妹。” ➋。
- en: '**LOOPING OVER AN ARRAY**'
  id: totrans-2046
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**遍历数组**'
- en: 'Sometimes when you’re working with arrays you might want to do something to
    every item in the array. You can use a for-in loop to do that! The following code
    will print every topping in a pizzaToppings array on a separate line:'
  id: totrans-2047
  prefs: []
  type: TYPE_NORMAL
  zh: 有时候，当你在处理数组时，可能希望对数组中的每一项做些操作。你可以使用 for-in 循环来实现！以下代码将会在单独的一行上打印出 pizzaToppings
    数组中的每一个配料：
- en: '![Image](Image00135.jpg)'
  id: totrans-2048
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00135.jpg)'
- en: To write a for-in loop for the pizzaToppings array, we used the keyword for
    , followed by the constant topping , then the keyword in , and finally the name
    of our array, pizzaToppings . Then we put the statements that we want to run for
    each topping inside the braces of the for-in loop. The constant topping ➊ temporarily
    represents each pizza topping in the array as we loop through it. We could have
    chosen any name for this constant, but it’s a good idea to pick something that
    makes sense. You can see the output of this for-in loop in [Figure 6-4](text00016.html#ch06fig4)
    .
  id: totrans-2049
  prefs: []
  type: TYPE_NORMAL
  zh: 为了编写 pizzaToppings 数组的 for-in 循环，我们使用了关键字 for，后跟常量 topping，然后是关键字 in，最后是数组名称
    pizzaToppings。接着我们将要对每个配料执行的语句放在 for-in 循环的括号内。常量 topping ➊ 临时表示我们在循环过程中访问的每一个配料。我们可以为这个常量选择任何名字，但最好选一个有意义的名字。你可以在
    [图 6-4](text00016.html#ch06fig4) 中看到这个 for-in 循环的输出。
- en: '![Image](Image00136.jpg)'
  id: totrans-2050
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00136.jpg)'
- en: '*Figure 6-4: Output of the example for-in loop*'
  id: totrans-2051
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 6-4：示例 for-in 循环的输出*'
- en: '![Image](Image00137.jpg)'
  id: totrans-2052
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00137.jpg)'
- en: 'Using for-in loops is great for printing every value in an array. If you’re
    working with numbers, you can even use them to perform math operations on each
    item, which makes for some speedy calculations! The following code takes an array
    of numbers and calculates the square for each (the square of a number is that
    number multiplied by itself):'
  id: totrans-2053
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 for-in 循环非常适合打印数组中的每一个值。如果你处理的是数字，你甚至可以用它们对每个项执行数学运算，这样能快速进行计算！以下代码会接受一个数字数组，并计算每个数字的平方（数字的平方是数字与自身相乘）：
- en: '![Image](Image00138.jpg)'
  id: totrans-2054
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00138.jpg)'
- en: '[Figure 6-5](text00016.html#ch06fig5) shows the results.'
  id: totrans-2055
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 6-5](text00016.html#ch06fig5) 显示了结果。'
- en: '![Image](Image00139.jpg)'
  id: totrans-2056
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00139.jpg)'
- en: '*Figure 6-5: Printing the squares for each number in the myNumbers array*'
  id: totrans-2057
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 6-5：打印 myNumbers 数组中每个数字的平方*'
- en: '**DICTIONARIES ARE KEY!**'
  id: totrans-2058
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**字典是关键！**'
- en: A *dictionary* is also a collection of values, but instead of an ordered index,
    each value has its own *key* . Because there’s no index, the values are not stored
    in any particular order. To access values in a dictionary, you look them up by
    their key.
  id: totrans-2059
  prefs: []
  type: TYPE_NORMAL
  zh: '*字典* 也是一个值的集合，但与有序索引不同，每个值都有自己的 *键* 。由于没有索引，值并没有按照任何特定的顺序存储。要访问字典中的值，你需要通过它们的键来查找。'
- en: A key must be unique. You can’t have the same key more than once in the same
    dictionary. If there were two identical keys and you asked the computer to give
    you the value for one of them, the computer wouldn’t know which one to choose!
  id: totrans-2060
  prefs: []
  type: TYPE_NORMAL
  zh: 键必须是唯一的。在同一个字典中不能有重复的键。如果有两个相同的键，且你要求计算机给出其中一个的值，计算机就无法知道应该选择哪个！
- en: Let’s take a look at how to make a dictionary and write keys that will help
    you find all the information you need.
  id: totrans-2061
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看如何创建字典并编写键，以帮助你找到所需的所有信息。
- en: '![Image](Image00140.jpg)'
  id: totrans-2062
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00140.jpg)'
- en: '**INITIALIZING A DICTIONARY**'
  id: totrans-2063
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**初始化字典**'
- en: 'To create and initialize a dictionary, first write var and the name of your
    dictionary. Then write the keys and corresponding values inside a pair of square
    brackets, similar to an array. Let’s create a dictionary to store the names of
    a few US states. The key for each state will be its two-letter abbreviation:'
  id: totrans-2064
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建并初始化一个字典，首先写上 var 和字典的名称。然后在一对方括号内写上键及其对应的值，类似于数组。我们来创建一个字典，用来存储几个美国州的名称。每个州的键将是它的两字母缩写：
- en: '![](Image00141.jpg)'
  id: totrans-2065
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00141.jpg)'
- en: As you can see, there’s a colon between each key and its value, and the key/value
    pairs are separated by commas.
  id: totrans-2066
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，每个键和值之间有一个冒号，键/值对之间用逗号分隔。
- en: Dictionaries are different from arrays in that they are *unordered* . Because
    of that, it’s likely that the order of the states that you see in your results
    pane ➋ is different from the order in which you entered your states ➊ . It might
    even be different than the order that’s printed in this book!
  id: totrans-2067
  prefs: []
  type: TYPE_NORMAL
  zh: 字典与数组的不同之处在于它们是*无序的*。因此，结果面板中显示的状态顺序 ➋ 可能与您输入状态的顺序 ➊ 不同。甚至可能与本书中打印的顺序不同！
- en: As with arrays, you can use var to make a mutable dictionary or use let to make
    an immutable dictionary.
  id: totrans-2068
  prefs: []
  type: TYPE_NORMAL
  zh: 和数组一样，你可以使用 var 来创建一个可变字典，或者使用 let 来创建一个不可变字典。
- en: 'In Swift, all of the keys of a dictionary must be the same type, and all of
    the values of a dictionary must also be the same type, but the key type doesn’t
    have to match the value type. For example, if you wanted to store a collection
    of fractions, you could use doubles for the keys and strings for the values:'
  id: totrans-2069
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Swift 中，字典的所有键必须是相同的类型，字典的所有值也必须是相同的类型，但键的类型不必与值的类型相同。例如，如果你想存储一组分数，你可以使用
    double 类型作为键，使用 string 类型作为值：
- en: '![](Image00142.jpg)'
  id: totrans-2070
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00142.jpg)'
- en: In this dictionary, all of the keys must be doubles, and all of the values must
    be strings. Again, you’ll see that the order of the numbers in the results pane
    can be quite different from the order in which you wrote the fractions in your
    dictionary. This is fine because you don’t need to know the order to access anything.
    You can find any item that you need by its key. Let’s see how!
  id: totrans-2071
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个字典中，所有的键都必须是 double 类型，所有的值都必须是 string 类型。同样，你会看到，结果面板中数字的顺序可能与字典中书写分数的顺序差别很大。这没关系，因为你不需要知道顺序就能访问任何项。你可以通过键找到任何需要的项。让我们来看一下！
- en: '**ACCESSING VALUES IN A DICTIONARY**'
  id: totrans-2072
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**访问字典中的值**'
- en: 'Looking up a value in a dictionary is similar to how you access a value in
    an array except that you use a key inside the square brackets instead of an index,
    like this: usStates["TX"] .'
  id: totrans-2073
  prefs: []
  type: TYPE_NORMAL
  zh: 在字典中查找值的方法类似于在数组中访问值，不同的是，你使用键而不是索引，像这样：usStates["TX"]。
- en: There is a big difference, however, in how Swift returns the values from a dictionary.
    When you access a value at an index of an array, you are simply given the value.
    When you access a value with a key in a dictionary, you are given an optional.
  id: totrans-2074
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，Swift 在从字典返回值时有一个很大的不同。当你在数组中访问一个索引处的值时，你只是直接得到值。而在字典中通过键访问值时，你得到的是一个可选值。
- en: In [Chapter 5](text00015.html#ch05) , you learned that optionals might contain
    a value or might be nil . The reason Swift returns optionals when you’re looking
    up items in a dictionary is that the key you used might not exist in the dictionary,
    in which case there’s no value to access. Trying to access a value that doesn’t
    exist would give you a big fat error! To avoid that problem, Swift returns optionals.
    That means you need to unwrap any value you get out of a dictionary before you
    can do anything with it.
  id: totrans-2075
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第5章](text00015.html#ch05)中，你已经学习过可选值可能包含一个值，也可能是 nil。Swift 返回可选值的原因是，当你在字典中查找项时，你使用的键可能在字典中不存在，在这种情况下就没有值可供访问。试图访问一个不存在的值会导致一个大错误！为了避免这个问题，Swift
    返回可选值。这意味着，在你对从字典中获取的任何值进行操作之前，必须先解包它。
- en: 'To unwrap an optional, first you check whether it exists using an if-let statement,
    just like we did in [Chapter 5](text00015.html#ch05) . The following code shows
    you how to get a value out of a dictionary:'
  id: totrans-2076
  prefs: []
  type: TYPE_NORMAL
  zh: 要解包一个可选值，首先通过 if-let 语句检查它是否存在，就像我们在[第5章](text00015.html#ch05)中所做的那样。下面的代码展示了如何从字典中获取值：
- en: '![Image](Image00143.jpg)'
  id: totrans-2077
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00143.jpg)'
- en: To retrieve "Texas" from the dictionary, we use if let to set a constant loneStarState
    to usStates["TX"] ➊ . Because we have this state in our dictionary, the line I
    have Texas in my dictionary. is printed. Next we try to access a state that is
    not in our dictionary by using the key usStates["FL"] ➋ . Thankfully, because
    we used an if-let statement, the program won’t crash when the computer can’t find
    this state. Instead, I don't have that state in my dictionary. is printed.
  id: totrans-2078
  prefs: []
  type: TYPE_NORMAL
  zh: 要从字典中检索 "Texas"，我们使用 if let 将常量 loneStarState 设置为 usStates["TX"] ➊。因为我们在字典中有这个州，所以打印出了
    "I have Texas in my dictionary."。接下来，我们尝试通过使用键 usStates["FL"] ➋ 来访问一个不在字典中的州。幸运的是，由于我们使用了
    if-let 语句，当计算机找不到这个州时，程序不会崩溃。相反，打印出 "I don't have that state in my dictionary."。
- en: '**ADDING ITEMS TO A DICTIONARY**'
  id: totrans-2079
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**向字典中添加项目**'
- en: 'To add an item to a dictionary, first write the name of your dictionary and
    assign the new item to the key you want it to have in the dictionary. Let’s add
    "Minnesota" to our usStates dictionary:'
  id: totrans-2080
  prefs: []
  type: TYPE_NORMAL
  zh: 要向字典添加一个项目，首先写出字典的名称，并将新项目分配给你希望它在字典中拥有的键。让我们将 "Minnesota" 添加到我们的 usStates 字典中：
- en: '![](Image00144.jpg)'
  id: totrans-2081
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00144.jpg)'
- en: 'Now when you look at usStates , you’ll see that it’s updated to ["MN": "Minnesota",
    "WA": "Washington", "MA": "Massachusetts", "TX": "Texas"] . Remember, because
    you don’t have to rely on indices, your new dictionary item might appear anywhere
    in the dictionary.'
  id: totrans-2082
  prefs: []
  type: TYPE_NORMAL
  zh: '现在，当你查看 usStates 时，你会看到它更新为 ["MN": "Minnesota", "WA": "Washington", "MA": "Massachusetts",
    "TX": "Texas"]。记住，因为你不需要依赖索引，所以新的字典项可能出现在字典中的任何位置。'
- en: '**REMOVING ITEMS FROM A DICTIONARY**'
  id: totrans-2083
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**从字典中移除项目**'
- en: Removing an item from a dictionary is quite simple; you do so by setting the
    value to nil . Because the values in dictionaries are returned as optionals, you
    don’t have to worry about nil causing any problems in your dictionary.
  id: totrans-2084
  prefs: []
  type: TYPE_NORMAL
  zh: 从字典中移除一个项目非常简单；你只需要将值设置为 nil。由于字典中的值是作为可选类型返回的，所以你不必担心 nil 会导致字典出现任何问题。
- en: '![](Image00145.jpg)'
  id: totrans-2085
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00145.jpg)'
- en: 'You can see that after you remove the value at the key "MA" , usStates is updated
    to ["MN": "Minnesota", "WA": "Washington", "TX": "Texas"] . Remember that nil
    is special and means that there’s no value at all. That’s why you don’t see "MA":
    nil in our dictionary.'
  id: totrans-2086
  prefs: []
  type: TYPE_NORMAL
  zh: '你可以看到，在你移除键 "MA" 处的值后，usStates 更新为 ["MN": "Minnesota", "WA": "Washington",
    "TX": "Texas"]。记住，nil 是特殊的，意味着没有任何值。因此，你在字典中看不到 "MA": nil。'
- en: '**REPLACING ITEMS IN A DICTIONARY**'
  id: totrans-2087
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**替换字典中的项目**'
- en: 'Replacing an item in a dictionary is also easy. It works the same was as replacing
    an item in an array. You just set the item that you want to replace to something
    else. Say you create a dictionary of fruit colors:'
  id: totrans-2088
  prefs: []
  type: TYPE_NORMAL
  zh: 在字典中替换项目也很简单。它和在数组中替换项目的方式一样。你只需将要替换的项目设置为另一个值。例如，假设你创建了一个关于水果颜色的字典：
- en: '![](Image00146.jpg)'
  id: totrans-2089
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00146.jpg)'
- en: At first we had the value "apple" for "red" , but then we decided that "raspberry"
    is a better fruit to use since sometimes apples are green or yellow. To replace
    "apple" with "raspberry" , we set colorFruits["red"] to its new value ➊ .
  id: totrans-2090
  prefs: []
  type: TYPE_NORMAL
  zh: 最开始我们给 "red" 配置了 "apple" 的值，但后来我们决定 "raspberry" 是更合适的水果，因为有时苹果是绿色或黄色的。为了将 "apple"
    替换为 "raspberry"，我们将 colorFruits["red"] 设置为新的值 ➊。
- en: You may remember that this is the same way we entered a new value into a dictionary.
    If the key already exists in the dictionary, then the value for that key is replaced.
    If the key doesn’t already exist, then the new key/value pair will be added to
    the dictionary.
  id: totrans-2091
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能还记得，这和我们向字典中插入新值的方式是一样的。如果键已经存在于字典中，那么该键的值会被替换。如果该键不存在，则新的键值对会被添加到字典中。
- en: '![Image](Image00147.jpg)'
  id: totrans-2092
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00147.jpg)'
- en: '**USING DICTIONARY PROPERTIES**'
  id: totrans-2093
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**使用字典属性**'
- en: 'Like an array, a dictionary also has an isEmpty property and a count property.
    For example, the following code shows how you can use the isEmpty property to
    check if a dictionary is empty, and if it isn’t empty, the count property checks
    how many items you have. Imagine you have a basket of fruit for sale. You can
    use these properties to help you keep track of everything:'
  id: totrans-2094
  prefs: []
  type: TYPE_NORMAL
  zh: 像数组一样，字典也有 isEmpty 属性和 count 属性。例如，下面的代码展示了如何使用 isEmpty 属性来检查字典是否为空，如果字典不为空，count
    属性则可以检查你有多少个项目。假设你有一个待售的水果篮，你可以利用这些属性帮助你跟踪所有内容：
- en: '![Image](Image00148.jpg)'
  id: totrans-2095
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00148.jpg)'
- en: 'A dictionary also has two special properties: keys , which contains all of
    the dictionary’s keys, and values , which contains all of its values. We’ll use
    these two properties when we loop through the dictionary.'
  id: totrans-2096
  prefs: []
  type: TYPE_NORMAL
  zh: 字典还有两个特殊的属性：keys，它包含字典中的所有键；以及 values，它包含所有的值。我们将在遍历字典时使用这两个属性。
- en: Let’s write some code that loops through our fruit baskets and prints the price
    of each fruit.
  id: totrans-2097
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们写一些代码，遍历我们的果篮并打印每个水果的价格。
- en: '**LOOPING OVER A DICTIONARY**'
  id: totrans-2098
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**遍历字典**'
- en: 'You can loop through a dictionary using a for-in loop. Because each item has
    a key and a value, you can do this in two different ways. This is how to loop
    through a dictionary using its keys:'
  id: totrans-2099
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用for-in循环遍历字典。因为每个项目都有一个键和值，你可以通过两种不同的方式进行遍历。这是使用字典的键来遍历字典的方法：
- en: '![Image](Image00149.jpg)'
  id: totrans-2100
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Image00149.jpg)'
- en: Here we use the dictionary’s keys property ➊ to loop through fruitBasket and
    print its contents. We start by writing the keyword for , followed by a constant
    name fruit for the dictionary key, the keyword in , the dictionary name, a period,
    and keys .
  id: totrans-2101
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们使用字典的keys属性➊遍历fruitBasket并打印其内容。我们首先写下关键词for，然后是一个常量名称fruit，表示字典的键，接着是关键词in，字典名，一个句点，最后是keys。
- en: Inside the braces of our for-in loop, we have access to both the key, which
    we call fruit ➋ , and the value at that key when we force-unwrap its contents
    with fruitBasket[fruit]! ➌ . That value will be the fruit’s price.
  id: totrans-2102
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的for-in循环的大括号内，我们可以访问键（我们称之为fruit）➋，以及通过fruitBasket[fruit]!强制解包该键对应的值➌。该值将是水果的价格。
- en: In this case, it’s safe to force-unwrap the value using an exclamation point
    because we know that the fruit key we’re using is definitely inside the dictionary.
  id: totrans-2103
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，使用感叹号强制解包值是安全的，因为我们知道我们使用的fruit键肯定在字典中。
- en: Any code we put inside the for-in loop will run once for every key in our dictionary.
    So you should see the print statement display three times.
  id: totrans-2104
  prefs: []
  type: TYPE_NORMAL
  zh: 我们放入for-in循环中的任何代码都会针对字典中的每个键执行一次。所以你应该看到print语句显示三次。
- en: 'We can also loop through the dictionary using its values property:'
  id: totrans-2105
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以使用字典的values属性来遍历字典：
- en: '![Image](Image00150.jpg)'
  id: totrans-2106
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Image00150.jpg)'
- en: We use the same style of for-in loop, but now we use a constant to refer to
    each value, which we call price , in the values property. When looping through
    values, we don’t have access to the keys from inside the loop.
  id: totrans-2107
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用相同风格的for-in循环，但现在我们用一个常量来引用values属性中的每个值，我们称之为price。当遍历值时，我们无法从循环内访问键。
- en: Another difference to note is that price is not an optional because it’s accessed
    directly as a value in the fruitBasket dictionary. That means we don’t have to
    unwrap it. You should still see the print statement printed three times. [Figure
    6-6](text00016.html#ch06fig6) shows the output of both loops.
  id: totrans-2108
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个需要注意的区别是，price不是可选类型，因为它直接作为fruitBasket字典中的值访问。这意味着我们不需要解包它。你应该仍然能看到print语句打印三次。[图6-6](text00016.html#ch06fig6)显示了两个循环的输出。
- en: '![Image](Image00151.jpg)'
  id: totrans-2109
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Image00151.jpg)'
- en: '*Figure 6-6: Looping through the keys and values of a dictionary with a for-in
    loop*'
  id: totrans-2110
  prefs: []
  type: TYPE_NORMAL
  zh: '*图6-6：使用for-in循环遍历字典的键和值*'
- en: The order of your results might be slightly different from ours. That’s because
    the items in a dictionary aren’t in a numbered order like they are in an array!
    And because the order is not guaranteed, you might see a different order printed
    if you run the same code again.
  id: totrans-2111
  prefs: []
  type: TYPE_NORMAL
  zh: 你的结果顺序可能与我们的略有不同。这是因为字典中的项目不像数组那样按编号顺序排列！由于顺序无法保证，如果你再次运行相同的代码，可能会看到不同的顺序。
- en: '**WHAT YOU LEARNED**'
  id: totrans-2112
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**你学到了什么**'
- en: In this chapter, you learned how to store collections of items in an array and
    in a dictionary. To store items in an ordered list, you would use an array and
    look up each item by its index. If you wanted to store items by key instead, you
    would use a dictionary.
  id: totrans-2113
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一章中，你学习了如何将项目集合存储在数组和字典中。要将项目存储在有序列表中，你会使用数组，并通过索引查找每个项目。如果你想按键存储项目，你则会使用字典。
- en: Knowing about arrays and dictionaries and how to use them is a powerful building
    block for almost any programming language. Next we will learn about functions,
    another very powerful tool. Functions are blocks of code that you create and name
    to perform a specific job. After you have written a function, you can use its
    name to call it from almost anywhere in your program.
  id: totrans-2114
  prefs: []
  type: TYPE_NORMAL
  zh: 了解数组和字典以及如何使用它们，是几乎任何编程语言的强大基础。接下来我们将学习函数，另一个非常强大的工具。函数是你创建并命名的代码块，用来执行特定的任务。编写了函数后，你可以通过它的名字从程序中的几乎任何地方调用它。
- en: You can also create an *immutable* array. An immutable array is created with
    the keyword let instead of var . Similar to a constant, once an immutable array
    is created, nothing in it can be changed.
  id: totrans-2115
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以创建一个*不可变*数组。不可变数组是使用let关键字而不是var创建的。类似于常量，一旦创建了不可变数组，数组中的内容就无法更改。
- en: So when should you use a mutable array or an immutable array? It’s best to use
    let if you know your collection will never change, like if you’re storing the
    colors of the rainbow. You should use var if you need to change your collection,
    like if you’re storing an array of your favorite T-shirts, which might change
    depending on what’s in style!
  id: totrans-2116
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，什么时候应该使用可变数组或不可变数组呢？如果你知道你的集合永远不会改变，比如你存储的是彩虹的颜色，最好使用 let。你应该使用 var 如果你需要更改集合，比如你存储的是一组你最喜欢的
    T 恤，这些可能会根据流行的款式而改变！
- en: '![Image](Image00116.jpg)'
  id: totrans-2117
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00116.jpg)'
- en: '**USING TYPE INFERENCE**'
  id: totrans-2118
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**使用类型推断**'
- en: 'When we created our nationalParks array, we specified that we were creating
    an array of string values by adding a colon (: ) and [String] ➋ . This step is
    optional when you create an array and initialize it with one or more values because
    Swift will use type inference to determine the kind of data you want the array
    to hold. That means that you could just as easily have created the array by doing
    this:'
  id: totrans-2119
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们创建 nationalParks 数组时，我们通过添加冒号（:）和 [String] ➋ 指定了我们创建的是一个字符串值数组。这个步骤在你创建并用一个或多个值初始化数组时是可选的，因为
    Swift 会使用类型推断来确定你希望数组保存的数据类型。这意味着你也可以像这样创建数组：
- en: '![](Image00117.jpg)'
  id: totrans-2120
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00117.jpg)'
- en: Using type inference, Swift knows we initialized this array to hold strings,
    and it can hold only strings.
  id: totrans-2121
  prefs: []
  type: TYPE_NORMAL
  zh: 使用类型推断，Swift 知道我们初始化了一个用于保存字符串的数组，并且它只能保存字符串。
- en: The list of parks that we created the array with is an example of an array *literal*
    . A literal is a value that is exactly what you see. It is not a variable or constant
    but rather just the value without a name. "Grand Canyon" is an example of a string
    literal, and 7 is an example of an integer literal. An array literal is a list
    of items contained between two square brackets and separated by commas, like ["Acadia",
    "Zion", "Grand Canyon"] ➊ .
  id: totrans-2122
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建数组时使用的公园列表是数组*字面量*的一个例子。字面量是一个完全由你看到的值组成的值。它不是变量或常量，而只是没有名称的值。“大峡谷”是字符串字面量的一个例子，7
    是整数字面量的一个例子。数组字面量是一个项的列表，项之间用逗号分隔，且被方括号括起来，像这样 ["Acadia", "Zion", "Grand Canyon"]
    ➊。
- en: '**ACCESSING ITEMS IN AN ARRAY**'
  id: totrans-2123
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**访问数组中的元素**'
- en: 'Let’s say you want to access an item in your array and use it in your program.
    Your friend asks you to tell them all about your travels, so you want to use the
    names of the national parks that you stored in the array. To access an item in
    your array, write the array name followed by the item’s index inside square brackets:'
  id: totrans-2124
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你想要访问数组中的一个项目并在程序中使用它。你的朋友要求你讲述你的旅行经历，因此你想使用你存储在数组中的国家公园名称。要访问数组中的一个项目，写出数组名后跟着项的索引，索引放在方括号内：
- en: '![](Image00118.jpg)'
  id: totrans-2125
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00118.jpg)'
- en: In this example, we are accessing the names of the national parks and then printing
    them to the screen using print . To get the first item in nationalParks , you
    use nationalParks[0] ➊ . To access the second item in nationalParks , you use
    nationalParks[1] .
  id: totrans-2126
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们访问国家公园的名称，然后使用 print 将它们打印到屏幕上。要获取 nationalParks 中的第一个项目，使用 nationalParks[0]
    ➊ 。要访问 nationalParks 中的第二个项目，使用 nationalParks[1]。
- en: '**WATCHING THE RANGE**'
  id: totrans-2127
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**观察范围**'
- en: One important point about arrays is that if you try to access an item at an
    index that’s higher than the last index in the array, you’ll get an error. In
    [Figure 6-2](text00016.html#ch06fig2) , you can see that nationalParks[3] (which
    would be the fourth item in the array) gives you an error because there are only
    three national parks in the array, indexed from 0 to 2.
  id: totrans-2128
  prefs: []
  type: TYPE_NORMAL
  zh: 关于数组有一个重要的点，如果你尝试访问一个超出数组最后一个索引的项，你将得到一个错误。在[图6-2](text00016.html#ch06fig2)中，你可以看到
    nationalParks[3]（即数组中的第四项）会给你一个错误，因为数组中只有三个国家公园，索引从 0 到 2。
- en: As you can see, you get an error message that says Index out of range . If you
    try to access an item that doesn’t exist in your array, your app will crash!
  id: totrans-2129
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，你会收到一条错误消息，提示“索引超出范围”。如果你尝试访问数组中不存在的项目，应用程序会崩溃！
- en: '![Image](Image00119.jpg)'
  id: totrans-2130
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00119.jpg)'
- en: '*Figure 6-2: Trying to access an index in the array where nothing exists causes
    an error.*'
  id: totrans-2131
  prefs: []
  type: TYPE_NORMAL
  zh: '*图6-2：尝试访问数组中不存在的索引会导致错误。*'
- en: '**ADDING ITEMS TO AN ARRAY**'
  id: totrans-2132
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**向数组添加元素**'
- en: One way to change an array is to add new items to it. There are a few different
    ways to do this, so let’s take a look at each.
  id: totrans-2133
  prefs: []
  type: TYPE_NORMAL
  zh: 更改数组的一种方法是向其中添加新元素。这里有几种不同的方法来实现这一点，我们来逐一看看。
- en: 'First, you can use an array’s append(_:) method. *Append* means to add something.
    Using append(_:) , you can add one new item to the end of your array. Say you
    go on another trip and visit the Badlands, and you want to add it to your list
    of national parks. To do that, add this code into your playground:'
  id: totrans-2134
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，你可以使用数组的append(_:)方法。*Append*意思是添加某个东西。使用append(_:)方法，你可以将一个新项目添加到数组的末尾。假设你又去了一次旅行，参观了坏lands，你想将它添加到你的国家公园列表中。为了做到这一点，将以下代码添加到你的游乐场中：
- en: '![](Image00120.jpg)'
  id: totrans-2135
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00120.jpg)'
- en: To use the append(_:) method, first write the name of your array followed by
    a period and then append . Then, put the item you want to add to your array inside
    the parentheses. In this case, you put "Badlands" inside the parentheses.
  id: totrans-2136
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用append(_:)方法，首先写下数组的名称，后面加一个句点，然后写上append。接着，在括号内放入你想要添加到数组中的项目。在这种情况下，你将"Badlands"放入了括号内。
- en: 'If you want to add something at a specific place in your array, use the array’s
    insert(_:at:) method instead. This method takes two arguments: the item that you
    want to insert and the index of where it should go in the array. (We’ll discuss
    arguments in more detail in [Chapter 7](text00017.html#ch07) .)'
  id: totrans-2137
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想在数组的特定位置添加某个项目，请使用数组的insert(_:at:)方法。此方法需要两个参数：你想要插入的项目和它在数组中应放置的位置的索引。（我们将在[第7章](text00017.html#ch07)中详细讨论参数。）
- en: 'Let’s say you totally forgot that you went to the Petrified Forest right after
    you visited the Grand Canyon, and you want to update your nationalParks array
    so it displays the parks in the order in which you visited them. To update your
    array, you could use the insert(_:at:) method to put the Petrified Forest in the
    right position:'
  id: totrans-2138
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你完全忘记了在参观大峡谷后你去过石化森林，并且你想更新你的nationalParks数组，使它显示你参观的公园的顺序。为了更新你的数组，你可以使用insert(_:at:)方法将石化森林放在正确的位置：
- en: '![](Image00121.jpg)'
  id: totrans-2139
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00121.jpg)'
- en: When you insert a new item at index 3, everything that was in the array at index
    3 or higher gets scooted over to make room for the new item. That means the item
    that was at index 3 is now at index 4, the item that was at index 4 is now at
    index 5, and so on. After you add the Petrified Forest, nationalParks is now ["Acadia",
    "Zion", "Grand Canyon", "Petrified Forest", "Badlands"] .
  id: totrans-2140
  prefs: []
  type: TYPE_NORMAL
  zh: 当你在索引3处插入一个新项目时，数组中索引3或更高位置的所有项目都会向后移动，为新项目腾出空间。这意味着索引3处的项目现在会在索引4处，索引4处的项目会在索引5处，以此类推。添加了石化森林后，nationalParks数组现在是["Acadia",
    "Zion", "Grand Canyon", "Petrified Forest", "Badlands"]。
- en: '**COMBINING ARRAYS**'
  id: totrans-2141
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**合并数组**'
- en: 'Not only can you add new items to an array, but you can also add two arrays
    together using the + and += operators. Let’s say that you have the ingredients
    for a fruit smoothie in two arrays:'
  id: totrans-2142
  prefs: []
  type: TYPE_NORMAL
  zh: 你不仅可以向数组中添加新项目，还可以使用+和+=操作符将两个数组合并。假设你有两个数组，分别包含制作水果冰沙的原料：
- en: '![](Image00122.jpg)'
  id: totrans-2143
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00122.jpg)'
- en: Now you can make a delicious smoothie by adding the fruits and liquids arrays.
  id: totrans-2144
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你可以通过添加水果和液体数组来制作美味的冰沙。
- en: '![](Image00123.jpg)'
  id: totrans-2145
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00123.jpg)'
- en: The order of the ingredients in smoothie is the same as the order in fruits
    and liquids . If you created smoothie with liquids + fruits , then the liquids
    would come first.
  id: totrans-2146
  prefs: []
  type: TYPE_NORMAL
  zh: 冰沙中的原料顺序与水果和液体的顺序相同。如果你使用液体+水果创建冰沙，那么液体会排在前面。
- en: 'You use the += operator to add an array to the end of your array. Add some
    whipped cream as follows for extra yumminess:'
  id: totrans-2147
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用+=操作符将一个数组添加到你的数组末尾。为了增加一些奶油，让冰沙更加美味，可以这样做：
- en: '![](Image00124.jpg)'
  id: totrans-2148
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00124.jpg)'
- en: Note that ["whipped cream"] is an array even though it has a single item in
    it. When you’re using += to append something to an array, you have to make sure
    you’re only trying to add another array. If you were to just write the string
    "whipped cream" without the square brackets around it, you would get an error.
  id: totrans-2149
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，["whipped cream"]是一个数组，即使它只包含一个项目。当你使用+=来附加某个项目到数组时，必须确保你仅仅是想添加另一个数组。如果你只是写下字符串"whipped
    cream"，而没有加上方括号，你将会得到一个错误。
- en: '![Image](Image00125.jpg)'
  id: totrans-2150
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00125.jpg)'
- en: '**REMOVING ITEMS FROM AN ARRAY**'
  id: totrans-2151
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**从数组中移除项目**'
- en: 'There are several methods for removing items from an array. Let’s start by
    looking at the array’s removeLast() method. As you might have guessed from its
    name, removeLast() removes the last item from your array. Let’s try it out with
    a shoppingList array:'
  id: totrans-2152
  prefs: []
  type: TYPE_NORMAL
  zh: 有几种方法可以从数组中移除项目。让我们从查看数组的removeLast()方法开始。正如你从其名字猜到的那样，removeLast()方法会移除数组中的最后一个项目。让我们通过一个购物清单数组来尝试一下：
- en: '![](Image00126.jpg)'
  id: totrans-2153
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00126.jpg)'
- en: Neat! Note that the removeLast() method returns the removed item, so you can
    store it in a new constant or variable if you want.
  id: totrans-2154
  prefs: []
  type: TYPE_NORMAL
  zh: 很棒！请注意，removeLast() 方法会返回被移除的元素，因此如果你需要，可以将其存储到一个新的常量或变量中。
- en: 'You can also remove an item from a specific index by using the remove(at:)
    method. Let’s say that your mom doesn’t want you buying any candy and takes that
    off the list:'
  id: totrans-2155
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以使用 remove(at:) 方法从特定索引移除一个元素。假设你妈妈不让你买糖果并把它从购物清单上移除：
- en: '![Image](Image00127.jpg)![](Image00128.jpg)'
  id: totrans-2156
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00127.jpg)![](Image00128.jpg)'
- en: Just like when we added an item to the middle of our array and all the items
    scooted over to make room, if you remove an item from the middle of an array,
    the rest of the items will scoot back to fill in that empty space. The "apples"
    item that was at index 3 is now at index 2, where "candy" was.
  id: totrans-2157
  prefs: []
  type: TYPE_NORMAL
  zh: 就像当我们将一个元素添加到数组中间时，所有元素会向后挪动腾出空间一样，如果你从数组中间移除一个元素，剩余的元素会向前挪动填补那个空位。原本位于索引 3
    位置的 "apples" 元素现在位于索引 2 位置，即原先 "candy" 的位置。
- en: 'You can also remove all items from an array with removeAll() . Try entering
    this into your playground:'
  id: totrans-2158
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以使用 removeAll() 方法从数组中移除所有元素。尝试在你的 playground 中输入这个：
- en: '![](Image00129.jpg)'
  id: totrans-2159
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00129.jpg)'
- en: 'Note that trying to remove an item at an index that doesn’t exist will give
    you an error:'
  id: totrans-2160
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，尝试移除一个不存在索引处的元素会导致错误：
- en: '![](Image00130.jpg)'
  id: totrans-2161
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00130.jpg)'
- en: Our array doesn’t have this many items (in fact, now it’s empty!), so this throws
    an error. We’ll also get an error if we use removeLast() on our empty array, because
    there’s nothing in it—there’s no last index at all! However, removeAll() is always
    safe to use, even on an empty array.
  id: totrans-2162
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的数组没有这么多元素（事实上，它现在是空的！），所以这会抛出一个错误。如果我们在空数组上使用 removeLast()，也会出错，因为里面没有任何元素——根本没有最后一个索引！然而，removeAll()
    始终是安全的，即使是在空数组上也能使用。
- en: '**REPLACING ITEMS IN AN ARRAY**'
  id: totrans-2163
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**替换数组中的元素**'
- en: 'To replace an item in an array, you set the index of the array to the new value,
    as shown here:'
  id: totrans-2164
  prefs: []
  type: TYPE_NORMAL
  zh: 要替换数组中的一个元素，你可以将数组的索引设置为新值，如下所示：
- en: '![](Image00131.jpg)'
  id: totrans-2165
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00131.jpg)'
- en: At ➊ , we replaced the item at index 2 (the third item) with "Unicorn" because
    magical animals count as favorite animals, too! At ➋ , we replaced the item at
    index 0 (the first item) with "Bearded dragon" . No, that’s not a real dragon—it’s
    just a lizard!
  id: totrans-2166
  prefs: []
  type: TYPE_NORMAL
  zh: 在 ➊ 处，我们将索引 2（第三个元素）处的元素替换为 "独角兽"，因为神奇动物也算作最喜欢的动物！在 ➋ 处，我们将索引 0（第一个元素）处的元素替换为
    "胡须龙"。不，那不是一条真正的龙——它只是一只蜥蜴！
- en: Like any time you’re working with array index numbers, you have to be sure an
    item exists in the array at that index before you change its value, or you will
    get an Index out of range error.
  id: totrans-2167
  prefs: []
  type: TYPE_NORMAL
  zh: 就像在处理数组索引时一样，你必须确保在修改值之前该索引处的元素确实存在，否则会出现“索引超出范围”错误。
- en: '[Figure 6-3](text00016.html#ch06fig3) shows the error that occurs if you try
    to add "Standard poodle" using favoriteAnimals[3] = "Standard poodle" . To add
    an item to the end of an array, you should use the append(_:) method or += , as
    we covered in “[Adding Items to an Array](text00016.html#ch06lev2sec5) ” on [page
    70](text00016.html#page_70) .'
  id: totrans-2168
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 6-3](text00016.html#ch06fig3) 显示了如果你尝试使用 favoriteAnimals[3] = "Standard
    poodle" 来添加 "标准贵宾犬" 时出现的错误。要将一个元素添加到数组的末尾，应该使用 append(_:) 方法或 +=，就像我们在 “[向数组添加元素](text00016.html#ch06lev2sec5)”
    中讨论的那样，详见 [第 70 页](text00016.html#page_70)。'
- en: '![Image](Image00132.jpg)'
  id: totrans-2169
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00132.jpg)'
- en: '*Figure 6-3: Don’t try to replace a value at an index beyond the existing array.*'
  id: totrans-2170
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 6-3：不要尝试替换超过现有数组索引的值。*'
- en: Now you know how to change arrays however you might need to. You can add items,
    take items away, or replace items. Next, we’ll look at how to use the properties
    of arrays to find out even more information about them.
  id: totrans-2171
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你知道如何根据需要修改数组了。你可以添加元素、移除元素或替换元素。接下来，我们将了解如何使用数组的属性来获取更多关于数组的信息。
- en: '![Image](Image00133.jpg)'
  id: totrans-2172
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00133.jpg)'
- en: '**USING ARRAY PROPERTIES**'
  id: totrans-2173
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**使用数组属性**'
- en: In addition to methods like append(_:) and removeLast() , arrays also have *properties*
    . An array’s properties are variables or constants that contain some information
    about the array. Two really helpful properties that you might use are the Boolean
    property isEmpty and the integer property count .
  id: totrans-2174
  prefs: []
  type: TYPE_NORMAL
  zh: 除了像 append(_:) 和 removeLast() 这样的函数，数组还有 *属性*。数组的属性是包含数组信息的变量或常量。你可能会用到的两个非常有用的属性是布尔属性
    isEmpty 和整数属性 count。
- en: The isEmpty property is true or false depending on whether the array is empty,
    and the count property will tell you how many items are in that array.
  id: totrans-2175
  prefs: []
  type: TYPE_NORMAL
  zh: isEmpty 属性根据数组是否为空返回 true 或 false，而 count 属性会告诉你数组中有多少个元素。
- en: 'Check out how these two properties are used in the following if-else statement:'
  id: totrans-2176
  prefs: []
  type: TYPE_NORMAL
  zh: 查看以下if-else语句中如何使用这两个属性：
- en: '![Image](Image00134.jpg)'
  id: totrans-2177
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00134.jpg)'
- en: 'This if-else statement checks whether the array mySiblings is empty ➊ . If
    it is, then "I don''t have any siblings." is printed. But if there is something
    in the array, then the number of siblings that we have is printed: "I have 3 siblings."
    ➋ .'
  id: totrans-2178
  prefs: []
  type: TYPE_NORMAL
  zh: 这个if-else语句检查数组mySiblings是否为空 ➊。如果是，它会打印出“我没有兄弟姐妹。”但如果数组中有内容，它将打印出我们有多少兄弟姐妹：“我有3个兄弟姐妹。”
    ➋。
- en: '**LOOPING OVER AN ARRAY**'
  id: totrans-2179
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**遍历数组**'
- en: 'Sometimes when you’re working with arrays you might want to do something to
    every item in the array. You can use a for-in loop to do that! The following code
    will print every topping in a pizzaToppings array on a separate line:'
  id: totrans-2180
  prefs: []
  type: TYPE_NORMAL
  zh: 有时在处理数组时，你可能想对数组中的每一项做一些事情。你可以使用for-in循环来实现！以下代码将打印pizzaToppings数组中的每个配料，每个配料占一行：
- en: '![Image](Image00135.jpg)'
  id: totrans-2181
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00135.jpg)'
- en: To write a for-in loop for the pizzaToppings array, we used the keyword for
    , followed by the constant topping , then the keyword in , and finally the name
    of our array, pizzaToppings . Then we put the statements that we want to run for
    each topping inside the braces of the for-in loop. The constant topping ➊ temporarily
    represents each pizza topping in the array as we loop through it. We could have
    chosen any name for this constant, but it’s a good idea to pick something that
    makes sense. You can see the output of this for-in loop in [Figure 6-4](text00016.html#ch06fig4)
    .
  id: totrans-2182
  prefs: []
  type: TYPE_NORMAL
  zh: 要为pizzaToppings数组编写for-in循环，我们使用关键字for，后跟常量topping，然后是关键字in，最后是我们数组的名称pizzaToppings。接着，我们把要对每个配料执行的语句放在for-in循环的大括号内。常量topping
    ➊ 在我们遍历数组时暂时代表数组中的每个披萨配料。我们本可以为这个常量选择任何名字，但选择一个有意义的名字是个好主意。你可以在[图6-4](text00016.html#ch06fig4)中看到这个for-in循环的输出。
- en: '![Image](Image00136.jpg)'
  id: totrans-2183
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00136.jpg)'
- en: '*Figure 6-4: Output of the example for-in loop*'
  id: totrans-2184
  prefs: []
  type: TYPE_NORMAL
  zh: '*图6-4：示例for-in循环的输出*'
- en: '![Image](Image00137.jpg)'
  id: totrans-2185
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00137.jpg)'
- en: 'Using for-in loops is great for printing every value in an array. If you’re
    working with numbers, you can even use them to perform math operations on each
    item, which makes for some speedy calculations! The following code takes an array
    of numbers and calculates the square for each (the square of a number is that
    number multiplied by itself):'
  id: totrans-2186
  prefs: []
  type: TYPE_NORMAL
  zh: 使用for-in循环遍历数组非常适合打印数组中的每个值。如果你正在处理数字，你甚至可以使用它们对每个项进行数学运算，从而实现快速计算！以下代码将一个数字数组的每个数字平方（数字的平方是这个数字与它自身相乘）：
- en: '![Image](Image00138.jpg)'
  id: totrans-2187
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00138.jpg)'
- en: '[Figure 6-5](text00016.html#ch06fig5) shows the results.'
  id: totrans-2188
  prefs: []
  type: TYPE_NORMAL
  zh: '[图6-5](text00016.html#ch06fig5)显示了结果。'
- en: '![Image](Image00139.jpg)'
  id: totrans-2189
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00139.jpg)'
- en: '*Figure 6-5: Printing the squares for each number in the myNumbers array*'
  id: totrans-2190
  prefs: []
  type: TYPE_NORMAL
  zh: '*图6-5：打印myNumbers数组中每个数字的平方*'
- en: '**DICTIONARIES ARE KEY!**'
  id: totrans-2191
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**字典至关重要！**'
- en: A *dictionary* is also a collection of values, but instead of an ordered index,
    each value has its own *key* . Because there’s no index, the values are not stored
    in any particular order. To access values in a dictionary, you look them up by
    their key.
  id: totrans-2192
  prefs: []
  type: TYPE_NORMAL
  zh: '*字典*也是一个值的集合，但与数组不同的是，每个值都有一个自己的*键*。由于没有索引，值不会以特定顺序存储。要访问字典中的值，你需要通过它的键来查找。'
- en: A key must be unique. You can’t have the same key more than once in the same
    dictionary. If there were two identical keys and you asked the computer to give
    you the value for one of them, the computer wouldn’t know which one to choose!
  id: totrans-2193
  prefs: []
  type: TYPE_NORMAL
  zh: 键必须是唯一的。在同一个字典中不能有相同的键。如果存在两个相同的键，并且你让计算机返回其中一个的值，计算机将不知道该选择哪一个！
- en: Let’s take a look at how to make a dictionary and write keys that will help
    you find all the information you need.
  id: totrans-2194
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如何创建一个字典并写入键，帮助你找到所有需要的信息。
- en: '![Image](Image00140.jpg)'
  id: totrans-2195
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00140.jpg)'
- en: '**INITIALIZING A DICTIONARY**'
  id: totrans-2196
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**初始化字典**'
- en: 'To create and initialize a dictionary, first write var and the name of your
    dictionary. Then write the keys and corresponding values inside a pair of square
    brackets, similar to an array. Let’s create a dictionary to store the names of
    a few US states. The key for each state will be its two-letter abbreviation:'
  id: totrans-2197
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建并初始化一个字典，首先写上var和字典的名称。然后在一对方括号内写入键和值，类似于数组的写法。我们创建一个字典来存储一些美国州的名称。每个州的键将是其两个字母的缩写：
- en: '![](Image00141.jpg)'
  id: totrans-2198
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00141.jpg)'
- en: As you can see, there’s a colon between each key and its value, and the key/value
    pairs are separated by commas.
  id: totrans-2199
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，每个键和值之间都有一个冒号，键/值对由逗号分隔。
- en: Dictionaries are different from arrays in that they are *unordered* . Because
    of that, it’s likely that the order of the states that you see in your results
    pane ➋ is different from the order in which you entered your states ➊ . It might
    even be different than the order that’s printed in this book!
  id: totrans-2200
  prefs: []
  type: TYPE_NORMAL
  zh: 字典与数组不同，因为字典是 *无序的*。因此，你在结果面板 ➋ 中看到的州的顺序可能与输入州时的顺序 ➊ 不同，甚至可能与书中打印出的顺序不同！
- en: As with arrays, you can use var to make a mutable dictionary or use let to make
    an immutable dictionary.
  id: totrans-2201
  prefs: []
  type: TYPE_NORMAL
  zh: 与数组类似，你可以使用 var 来创建一个可变字典，或使用 let 来创建一个不可变字典。
- en: 'In Swift, all of the keys of a dictionary must be the same type, and all of
    the values of a dictionary must also be the same type, but the key type doesn’t
    have to match the value type. For example, if you wanted to store a collection
    of fractions, you could use doubles for the keys and strings for the values:'
  id: totrans-2202
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Swift 中，字典的所有键必须是相同的类型，字典的所有值也必须是相同的类型，但键的类型不必与值的类型匹配。例如，如果你想存储一个分数集合，你可以使用双精度数作为键，字符串作为值：
- en: '![](Image00142.jpg)'
  id: totrans-2203
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00142.jpg)'
- en: In this dictionary, all of the keys must be doubles, and all of the values must
    be strings. Again, you’ll see that the order of the numbers in the results pane
    can be quite different from the order in which you wrote the fractions in your
    dictionary. This is fine because you don’t need to know the order to access anything.
    You can find any item that you need by its key. Let’s see how!
  id: totrans-2204
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个字典中，所有的键必须是双精度数，所有的值必须是字符串。同样，你会看到在结果面板中的数字顺序与在字典中书写分数时的顺序可能会有很大不同。这是正常的，因为你不需要知道顺序就能访问任何项。你可以通过键来找到任何你需要的项目。让我们来看看怎么做！
- en: '**ACCESSING VALUES IN A DICTIONARY**'
  id: totrans-2205
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**访问字典中的值**'
- en: 'Looking up a value in a dictionary is similar to how you access a value in
    an array except that you use a key inside the square brackets instead of an index,
    like this: usStates["TX"] .'
  id: totrans-2206
  prefs: []
  type: TYPE_NORMAL
  zh: 在字典中查找一个值与在数组中访问一个值类似，只不过你需要在方括号中使用键，而不是索引，像这样：usStates["TX"]。
- en: There is a big difference, however, in how Swift returns the values from a dictionary.
    When you access a value at an index of an array, you are simply given the value.
    When you access a value with a key in a dictionary, you are given an optional.
  id: totrans-2207
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，Swift 返回字典值的方式有一个很大的不同。当你通过数组的索引访问值时，你直接得到该值。而当你通过字典的键访问值时，你得到的是一个可选值。
- en: In [Chapter 5](text00015.html#ch05) , you learned that optionals might contain
    a value or might be nil . The reason Swift returns optionals when you’re looking
    up items in a dictionary is that the key you used might not exist in the dictionary,
    in which case there’s no value to access. Trying to access a value that doesn’t
    exist would give you a big fat error! To avoid that problem, Swift returns optionals.
    That means you need to unwrap any value you get out of a dictionary before you
    can do anything with it.
  id: totrans-2208
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第 5 章](text00015.html#ch05) 中，你学习了可选值可能包含一个值，也可能是 nil。Swift 返回可选值的原因是，当你在字典中查找项目时，所使用的键可能不存在于字典中，这种情况下没有值可以访问。试图访问一个不存在的值会导致一个大错误！为了避免这个问题，Swift
    返回可选值。这意味着，在你使用字典中的值之前，必须解包它。
- en: 'To unwrap an optional, first you check whether it exists using an if-let statement,
    just like we did in [Chapter 5](text00015.html#ch05) . The following code shows
    you how to get a value out of a dictionary:'
  id: totrans-2209
  prefs: []
  type: TYPE_NORMAL
  zh: 要解包一个可选值，首先你需要通过 if-let 语句检查它是否存在，就像我们在[第 5 章](text00015.html#ch05) 中所做的那样。以下代码展示了如何从字典中获取一个值：
- en: '![Image](Image00143.jpg)'
  id: totrans-2210
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Image00143.jpg)'
- en: To retrieve "Texas" from the dictionary, we use if let to set a constant loneStarState
    to usStates["TX"] ➊ . Because we have this state in our dictionary, the line I
    have Texas in my dictionary. is printed. Next we try to access a state that is
    not in our dictionary by using the key usStates["FL"] ➋ . Thankfully, because
    we used an if-let statement, the program won’t crash when the computer can’t find
    this state. Instead, I don't have that state in my dictionary. is printed.
  id: totrans-2211
  prefs: []
  type: TYPE_NORMAL
  zh: 要从字典中获取"Texas"（德克萨斯州），我们使用 if let 语句将常量 loneStarState 设置为 usStates["TX"] ➊。因为字典中包含这个州，所以会打印出“我在我的字典中有德克萨斯州”。接下来，我们尝试通过使用
    usStates["FL"] ➋ 来访问一个不在字典中的州。幸运的是，因为我们使用了 if-let 语句，当计算机找不到这个州时，程序不会崩溃。相反，会打印出“我在我的字典中没有那个州”。
- en: '**ADDING ITEMS TO A DICTIONARY**'
  id: totrans-2212
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**向字典中添加项目**'
- en: 'To add an item to a dictionary, first write the name of your dictionary and
    assign the new item to the key you want it to have in the dictionary. Let’s add
    "Minnesota" to our usStates dictionary:'
  id: totrans-2213
  prefs: []
  type: TYPE_NORMAL
  zh: 要向字典中添加一项，首先写出字典的名称，并将新项赋值给你想要的键。让我们把“明尼苏达”添加到我们的usStates字典中：
- en: '![](Image00144.jpg)'
  id: totrans-2214
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00144.jpg)'
- en: 'Now when you look at usStates , you’ll see that it’s updated to ["MN": "Minnesota",
    "WA": "Washington", "MA": "Massachusetts", "TX": "Texas"] . Remember, because
    you don’t have to rely on indices, your new dictionary item might appear anywhere
    in the dictionary.'
  id: totrans-2215
  prefs: []
  type: TYPE_NORMAL
  zh: '现在当你查看usStates时，你会看到它已更新为["MN": "Minnesota", "WA": "Washington", "MA": "Massachusetts",
    "TX": "Texas"]。记住，因为你不必依赖于索引，所以你的新字典项可能出现在字典的任何位置。'
- en: '**REMOVING ITEMS FROM A DICTIONARY**'
  id: totrans-2216
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**从字典中删除项**'
- en: Removing an item from a dictionary is quite simple; you do so by setting the
    value to nil . Because the values in dictionaries are returned as optionals, you
    don’t have to worry about nil causing any problems in your dictionary.
  id: totrans-2217
  prefs: []
  type: TYPE_NORMAL
  zh: 从字典中删除项非常简单；你只需要将该值设置为nil。由于字典中的值是以可选项的形式返回的，你不需要担心nil会在字典中引发任何问题。
- en: '![](Image00145.jpg)'
  id: totrans-2218
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00145.jpg)'
- en: 'You can see that after you remove the value at the key "MA" , usStates is updated
    to ["MN": "Minnesota", "WA": "Washington", "TX": "Texas"] . Remember that nil
    is special and means that there’s no value at all. That’s why you don’t see "MA":
    nil in our dictionary.'
  id: totrans-2219
  prefs: []
  type: TYPE_NORMAL
  zh: '你可以看到，在移除键“MA”的值后，usStates更新为["MN": "Minnesota", "WA": "Washington", "TX":
    "Texas"]。记住，nil是特殊的，表示没有值。因此你在字典中不会看到"MA": nil。'
- en: '**REPLACING ITEMS IN A DICTIONARY**'
  id: totrans-2220
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**在字典中替换项**'
- en: 'Replacing an item in a dictionary is also easy. It works the same was as replacing
    an item in an array. You just set the item that you want to replace to something
    else. Say you create a dictionary of fruit colors:'
  id: totrans-2221
  prefs: []
  type: TYPE_NORMAL
  zh: 在字典中替换项也很简单。它的操作方式与替换数组中的项一样。你只需要将要替换的项设置为其他值。假设你创建了一个水果颜色的字典：
- en: '![](Image00146.jpg)'
  id: totrans-2222
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00146.jpg)'
- en: At first we had the value "apple" for "red" , but then we decided that "raspberry"
    is a better fruit to use since sometimes apples are green or yellow. To replace
    "apple" with "raspberry" , we set colorFruits["red"] to its new value ➊ .
  id: totrans-2223
  prefs: []
  type: TYPE_NORMAL
  zh: 最初我们为“red”设置了“apple”的值，但后来我们决定“raspberry”是一个更好的水果，因为有时苹果是绿色或黄色的。为了用“raspberry”替换“apple”，我们将colorFruits["red"]的值设置为新值➊。
- en: You may remember that this is the same way we entered a new value into a dictionary.
    If the key already exists in the dictionary, then the value for that key is replaced.
    If the key doesn’t already exist, then the new key/value pair will be added to
    the dictionary.
  id: totrans-2224
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能记得，这与我们将新值添加到字典中的方式是一样的。如果字典中已经存在该键，那么该键的值会被替换。如果该键不存在，那么新的键值对将被添加到字典中。
- en: '![Image](Image00147.jpg)'
  id: totrans-2225
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00147.jpg)'
- en: '**USING DICTIONARY PROPERTIES**'
  id: totrans-2226
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**使用字典属性**'
- en: 'Like an array, a dictionary also has an isEmpty property and a count property.
    For example, the following code shows how you can use the isEmpty property to
    check if a dictionary is empty, and if it isn’t empty, the count property checks
    how many items you have. Imagine you have a basket of fruit for sale. You can
    use these properties to help you keep track of everything:'
  id: totrans-2227
  prefs: []
  type: TYPE_NORMAL
  zh: 和数组一样，字典也有一个isEmpty属性和一个count属性。例如，以下代码展示了如何使用isEmpty属性检查字典是否为空，如果不为空，count属性则检查你有多少个项。想象你有一个水果篮子在售卖，你可以使用这些属性来帮助你追踪所有的东西：
- en: '![Image](Image00148.jpg)'
  id: totrans-2228
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00148.jpg)'
- en: 'A dictionary also has two special properties: keys , which contains all of
    the dictionary’s keys, and values , which contains all of its values. We’ll use
    these two properties when we loop through the dictionary.'
  id: totrans-2229
  prefs: []
  type: TYPE_NORMAL
  zh: 字典还具有两个特殊的属性：keys，包含字典的所有键，和values，包含字典的所有值。当我们遍历字典时，将会使用这两个属性。
- en: Let’s write some code that loops through our fruit baskets and prints the price
    of each fruit.
  id: totrans-2230
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们写一些代码，遍历我们的水果篮子并打印每个水果的价格。
- en: '**LOOPING OVER A DICTIONARY**'
  id: totrans-2231
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**遍历字典**'
- en: 'You can loop through a dictionary using a for-in loop. Because each item has
    a key and a value, you can do this in two different ways. This is how to loop
    through a dictionary using its keys:'
  id: totrans-2232
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用for-in循环遍历字典。由于每个项都有一个键和值，因此你可以通过两种不同的方式进行遍历。这是通过键遍历字典的方法：
- en: '![Image](Image00149.jpg)'
  id: totrans-2233
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00149.jpg)'
- en: Here we use the dictionary’s keys property ➊ to loop through fruitBasket and
    print its contents. We start by writing the keyword for , followed by a constant
    name fruit for the dictionary key, the keyword in , the dictionary name, a period,
    and keys .
  id: totrans-2234
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们使用字典的键属性 ➊ 来遍历 `fruitBasket` 并打印其内容。我们首先写出 `for` 关键字，接着是字典键的常量名称 `fruit`，然后是
    `in` 关键字，再是字典的名称，接着是一个句点，最后是 `keys`。
- en: Inside the braces of our for-in loop, we have access to both the key, which
    we call fruit ➋ , and the value at that key when we force-unwrap its contents
    with fruitBasket[fruit]! ➌ . That value will be the fruit’s price.
  id: totrans-2235
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们 `for-in` 循环的花括号内，我们可以访问字典中的键，称其为 `fruit` ➋，以及通过 `fruitBasket[fruit]!` 强制解包其内容后的值
    ➌。该值就是水果的价格。
- en: In this case, it’s safe to force-unwrap the value using an exclamation point
    because we know that the fruit key we’re using is definitely inside the dictionary.
  id: totrans-2236
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，使用感叹号强制解包值是安全的，因为我们知道我们使用的 `fruit` 键肯定存在于字典中。
- en: Any code we put inside the for-in loop will run once for every key in our dictionary.
    So you should see the print statement display three times.
  id: totrans-2237
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在 `for-in` 循环中放入的任何代码都会对字典中的每个键执行一次。所以你应该看到打印语句显示三次。
- en: 'We can also loop through the dictionary using its values property:'
  id: totrans-2238
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以通过字典的 `values` 属性进行遍历：
- en: '![Image](Image00150.jpg)'
  id: totrans-2239
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00150.jpg)'
- en: We use the same style of for-in loop, but now we use a constant to refer to
    each value, which we call price , in the values property. When looping through
    values, we don’t have access to the keys from inside the loop.
  id: totrans-2240
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用相同样式的 `for-in` 循环，但现在我们用常量来引用 `values` 属性中的每个值，称其为 `price`。在遍历值时，我们无法从循环内部访问键。
- en: Another difference to note is that price is not an optional because it’s accessed
    directly as a value in the fruitBasket dictionary. That means we don’t have to
    unwrap it. You should still see the print statement printed three times. [Figure
    6-6](text00016.html#ch06fig6) shows the output of both loops.
  id: totrans-2241
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个需要注意的区别是，`price` 不是一个可选值，因为它是直接作为 `fruitBasket` 字典中的值进行访问的。这意味着我们不需要解包它。你仍然应该看到打印语句显示三次。[图
    6-6](text00016.html#ch06fig6) 显示了两个循环的输出。
- en: '![Image](Image00151.jpg)'
  id: totrans-2242
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00151.jpg)'
- en: '*Figure 6-6: Looping through the keys and values of a dictionary with a for-in
    loop*'
  id: totrans-2243
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 6-6：使用 `for-in` 循环遍历字典的键和值*'
- en: The order of your results might be slightly different from ours. That’s because
    the items in a dictionary aren’t in a numbered order like they are in an array!
    And because the order is not guaranteed, you might see a different order printed
    if you run the same code again.
  id: totrans-2244
  prefs: []
  type: TYPE_NORMAL
  zh: 你的结果顺序可能会和我们的略有不同。这是因为字典中的项目不像数组中的项目那样按编号顺序排列！而且由于顺序不保证，若重新运行相同代码，你可能会看到不同的顺序。
- en: '**WHAT YOU LEARNED**'
  id: totrans-2245
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**你学到的内容**'
- en: In this chapter, you learned how to store collections of items in an array and
    in a dictionary. To store items in an ordered list, you would use an array and
    look up each item by its index. If you wanted to store items by key instead, you
    would use a dictionary.
  id: totrans-2246
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你学习了如何将项目存储在数组和字典中。为了将项目存储在有序列表中，你会使用数组并通过索引查找每个项目。如果你想通过键来存储项目，你应该使用字典。
- en: Knowing about arrays and dictionaries and how to use them is a powerful building
    block for almost any programming language. Next we will learn about functions,
    another very powerful tool. Functions are blocks of code that you create and name
    to perform a specific job. After you have written a function, you can use its
    name to call it from almost anywhere in your program.
  id: totrans-2247
  prefs: []
  type: TYPE_NORMAL
  zh: 了解数组和字典以及如何使用它们是几乎所有编程语言的一个强大构建块。接下来，我们将学习函数，这是另一个非常强大的工具。函数是你创建并命名的代码块，用于执行特定的任务。编写完函数后，你可以使用它的名称从程序中的几乎任何位置调用它。
- en: So when should you use a mutable array or an immutable array? It’s best to use
    let if you know your collection will never change, like if you’re storing the
    colors of the rainbow. You should use var if you need to change your collection,
    like if you’re storing an array of your favorite T-shirts, which might change
    depending on what’s in style!
  id: totrans-2248
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，什么时候应该使用可变数组或不可变数组呢？如果你知道你的集合永远不会改变，最好使用 `let`，例如如果你存储的是彩虹的颜色。如果你需要更改集合，比如存储你最喜欢的
    T 恤阵列（可能会根据流行趋势变化），你应该使用 `var`。
- en: '![Image](Image00116.jpg)'
  id: totrans-2249
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00116.jpg)'
- en: '**USING TYPE INFERENCE**'
  id: totrans-2250
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**使用类型推断**'
- en: 'When we created our nationalParks array, we specified that we were creating
    an array of string values by adding a colon (: ) and [String] ➋ . This step is
    optional when you create an array and initialize it with one or more values because
    Swift will use type inference to determine the kind of data you want the array
    to hold. That means that you could just as easily have created the array by doing
    this:'
  id: totrans-2251
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们创建 nationalParks 数组时，我们通过添加冒号（:）和 [String] ➋ 来指定我们正在创建一个字符串值的数组。当你创建一个数组并用一个或多个值初始化时，这一步是可选的，因为
    Swift 会使用类型推断来确定你希望数组存储的数据类型。这意味着你本可以像这样创建数组：
- en: '![](Image00117.jpg)'
  id: totrans-2252
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00117.jpg)'
- en: Using type inference, Swift knows we initialized this array to hold strings,
    and it can hold only strings.
  id: totrans-2253
  prefs: []
  type: TYPE_NORMAL
  zh: 使用类型推断，Swift 知道我们初始化了一个数组来存储字符串，而且它只能存储字符串。
- en: The list of parks that we created the array with is an example of an array *literal*
    . A literal is a value that is exactly what you see. It is not a variable or constant
    but rather just the value without a name. "Grand Canyon" is an example of a string
    literal, and 7 is an example of an integer literal. An array literal is a list
    of items contained between two square brackets and separated by commas, like ["Acadia",
    "Zion", "Grand Canyon"] ➊ .
  id: totrans-2254
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建数组时使用的公园列表是数组*字面量*的一个例子。字面量是一个值，正是你所看到的内容。它不是一个变量或常量，而仅仅是没有名称的值。"Grand Canyon"
    是一个字符串字面量，7 是一个整数字面量。数组字面量是一个包含在两个方括号之间，并且用逗号分隔的项目列表，如 ["Acadia", "Zion", "Grand
    Canyon"] ➊。
- en: '**ACCESSING ITEMS IN AN ARRAY**'
  id: totrans-2255
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**访问数组中的项目**'
- en: 'Let’s say you want to access an item in your array and use it in your program.
    Your friend asks you to tell them all about your travels, so you want to use the
    names of the national parks that you stored in the array. To access an item in
    your array, write the array name followed by the item’s index inside square brackets:'
  id: totrans-2256
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你想要在程序中访问数组中的一个项目并使用它。你的朋友要求你告诉他们你所有的旅行经历，所以你想使用你存储在数组中的国家公园名称。要访问数组中的一个项目，写下数组名称，后跟项目的索引，索引放在方括号内：
- en: '![](Image00118.jpg)'
  id: totrans-2257
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00118.jpg)'
- en: In this example, we are accessing the names of the national parks and then printing
    them to the screen using print . To get the first item in nationalParks , you
    use nationalParks[0] ➊ . To access the second item in nationalParks , you use
    nationalParks[1] .
  id: totrans-2258
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们正在访问国家公园的名称，然后通过使用 print 将其打印到屏幕上。要获取 nationalParks 中的第一个项目，你可以使用 nationalParks[0]
    ➊。要访问 nationalParks 中的第二个项目，你可以使用 nationalParks[1]。
- en: '**WATCHING THE RANGE**'
  id: totrans-2259
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**观察范围**'
- en: One important point about arrays is that if you try to access an item at an
    index that’s higher than the last index in the array, you’ll get an error. In
    [Figure 6-2](text00016.html#ch06fig2) , you can see that nationalParks[3] (which
    would be the fourth item in the array) gives you an error because there are only
    three national parks in the array, indexed from 0 to 2.
  id: totrans-2260
  prefs: []
  type: TYPE_NORMAL
  zh: 关于数组的一个重要点是，如果你尝试访问一个索引，它比数组中的最后一个索引还要大，那么你会得到一个错误。在[图 6-2](text00016.html#ch06fig2)中，你可以看到
    nationalParks[3]（这将是数组中的第四个项目）会引发错误，因为数组中只有三个国家公园，索引从 0 到 2。
- en: As you can see, you get an error message that says Index out of range . If you
    try to access an item that doesn’t exist in your array, your app will crash!
  id: totrans-2261
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，你会收到一条错误消息，提示 Index out of range。如果你尝试访问数组中不存在的项目，应用程序将崩溃！
- en: '![Image](Image00119.jpg)'
  id: totrans-2262
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00119.jpg)'
- en: '*Figure 6-2: Trying to access an index in the array where nothing exists causes
    an error.*'
  id: totrans-2263
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 6-2：尝试访问数组中不存在的索引会导致错误。*'
- en: '**ADDING ITEMS TO AN ARRAY**'
  id: totrans-2264
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**向数组添加项目**'
- en: One way to change an array is to add new items to it. There are a few different
    ways to do this, so let’s take a look at each.
  id: totrans-2265
  prefs: []
  type: TYPE_NORMAL
  zh: 修改数组的一种方法是向其中添加新项目。有几种不同的方式可以实现这一点，我们来看一下每一种。
- en: 'First, you can use an array’s append(_:) method. *Append* means to add something.
    Using append(_:) , you can add one new item to the end of your array. Say you
    go on another trip and visit the Badlands, and you want to add it to your list
    of national parks. To do that, add this code into your playground:'
  id: totrans-2266
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，你可以使用数组的 append(_:) 方法。*Append* 的意思是添加某物。使用 append(_:) ，你可以将一个新项目添加到数组的末尾。假设你进行了一次新的旅行，访问了
    Badlands，并且你想把它添加到国家公园列表中。为此，可以将以下代码添加到你的 Playground 中：
- en: '![](Image00120.jpg)'
  id: totrans-2267
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00120.jpg)'
- en: To use the append(_:) method, first write the name of your array followed by
    a period and then append . Then, put the item you want to add to your array inside
    the parentheses. In this case, you put "Badlands" inside the parentheses.
  id: totrans-2268
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用 append(_:) 方法，首先写下数组的名称，后跟一个句点，然后添加 . 接着，将你想要添加到数组中的项目放在括号内。在这个例子中，你把 "Badlands"
    放入了括号中。
- en: 'If you want to add something at a specific place in your array, use the array’s
    insert(_:at:) method instead. This method takes two arguments: the item that you
    want to insert and the index of where it should go in the array. (We’ll discuss
    arguments in more detail in [Chapter 7](text00017.html#ch07) .)'
  id: totrans-2269
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想在数组的特定位置添加一个项，可以改用数组的insert(_:at:)方法。这个方法接受两个参数：你要插入的项和它应该插入的位置（索引）。(我们将在[第7章](text00017.html#ch07)中详细讨论参数。)
- en: 'Let’s say you totally forgot that you went to the Petrified Forest right after
    you visited the Grand Canyon, and you want to update your nationalParks array
    so it displays the parks in the order in which you visited them. To update your
    array, you could use the insert(_:at:) method to put the Petrified Forest in the
    right position:'
  id: totrans-2270
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你完全忘记了在参观大峡谷后去过Petrified Forest，你想更新你的nationalParks数组，使其按你参观的顺序显示这些公园。要更新你的数组，你可以使用insert(_:at:)方法将Petrified
    Forest插入正确的位置：
- en: '![](Image00121.jpg)'
  id: totrans-2271
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00121.jpg)'
- en: When you insert a new item at index 3, everything that was in the array at index
    3 or higher gets scooted over to make room for the new item. That means the item
    that was at index 3 is now at index 4, the item that was at index 4 is now at
    index 5, and so on. After you add the Petrified Forest, nationalParks is now ["Acadia",
    "Zion", "Grand Canyon", "Petrified Forest", "Badlands"] .
  id: totrans-2272
  prefs: []
  type: TYPE_NORMAL
  zh: 当你在索引3处插入一个新项时，数组中索引3或更高位置的所有项都会被推到新项旁边，以腾出空间。这意味着原本在索引3的项现在位于索引4，原本在索引4的项现在位于索引5，以此类推。添加“Petrified
    Forest”后，nationalParks数组现在变成了["Acadia", "Zion", "Grand Canyon", "Petrified Forest",
    "Badlands"]。
- en: '**COMBINING ARRAYS**'
  id: totrans-2273
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**合并数组**'
- en: 'Not only can you add new items to an array, but you can also add two arrays
    together using the + and += operators. Let’s say that you have the ingredients
    for a fruit smoothie in two arrays:'
  id: totrans-2274
  prefs: []
  type: TYPE_NORMAL
  zh: 不仅可以向数组添加新项，还可以使用+和+=运算符将两个数组合并。假设你有两个数组，其中包含制作水果冰沙的食材：
- en: '![](Image00122.jpg)'
  id: totrans-2275
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00122.jpg)'
- en: Now you can make a delicious smoothie by adding the fruits and liquids arrays.
  id: totrans-2276
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你可以通过将水果和液体数组相加来制作美味的冰沙。
- en: '![](Image00123.jpg)'
  id: totrans-2277
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00123.jpg)'
- en: The order of the ingredients in smoothie is the same as the order in fruits
    and liquids . If you created smoothie with liquids + fruits , then the liquids
    would come first.
  id: totrans-2278
  prefs: []
  type: TYPE_NORMAL
  zh: 冰沙中食材的顺序与水果和液体数组的顺序相同。如果你使用液体+水果的顺序创建冰沙，那么液体会先加入。
- en: 'You use the += operator to add an array to the end of your array. Add some
    whipped cream as follows for extra yumminess:'
  id: totrans-2279
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用+=运算符将一个数组添加到数组的末尾。如下所示，加入一些鲜奶油，让冰沙更加美味：
- en: '![](Image00124.jpg)'
  id: totrans-2280
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00124.jpg)'
- en: Note that ["whipped cream"] is an array even though it has a single item in
    it. When you’re using += to append something to an array, you have to make sure
    you’re only trying to add another array. If you were to just write the string
    "whipped cream" without the square brackets around it, you would get an error.
  id: totrans-2281
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，["whipped cream"]是一个数组，尽管它只有一个项。当你使用+=操作符向数组附加内容时，必须确保你仅仅是尝试添加另一个数组。如果你只是写上字符串"whipped
    cream"而没有将其放在方括号内，你会得到一个错误。
- en: '![Image](Image00125.jpg)'
  id: totrans-2282
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00125.jpg)'
- en: '**REMOVING ITEMS FROM AN ARRAY**'
  id: totrans-2283
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**从数组中移除项**'
- en: 'There are several methods for removing items from an array. Let’s start by
    looking at the array’s removeLast() method. As you might have guessed from its
    name, removeLast() removes the last item from your array. Let’s try it out with
    a shoppingList array:'
  id: totrans-2284
  prefs: []
  type: TYPE_NORMAL
  zh: 有几种方法可以从数组中移除项。让我们从数组的removeLast()方法开始。正如你从它的名称中猜到的那样，removeLast()会移除数组中的最后一个项。让我们用一个shoppingList数组试试：
- en: '![](Image00126.jpg)'
  id: totrans-2285
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00126.jpg)'
- en: Neat! Note that the removeLast() method returns the removed item, so you can
    store it in a new constant or variable if you want.
  id: totrans-2286
  prefs: []
  type: TYPE_NORMAL
  zh: 很棒！请注意，removeLast()方法返回被移除的项，因此如果你想的话，可以将其存储到一个新的常量或变量中。
- en: 'You can also remove an item from a specific index by using the remove(at:)
    method. Let’s say that your mom doesn’t want you buying any candy and takes that
    off the list:'
  id: totrans-2287
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以通过使用remove(at:)方法从特定的索引移除一个项目。假设你妈妈不希望你买糖果并把它从清单中拿掉：
- en: '![Image](Image00127.jpg)![](Image00128.jpg)'
  id: totrans-2288
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00127.jpg)![](Image00128.jpg)'
- en: Just like when we added an item to the middle of our array and all the items
    scooted over to make room, if you remove an item from the middle of an array,
    the rest of the items will scoot back to fill in that empty space. The "apples"
    item that was at index 3 is now at index 2, where "candy" was.
  id: totrans-2289
  prefs: []
  type: TYPE_NORMAL
  zh: 就像我们向数组中间添加项时，所有项都会被推移以腾出空间一样，如果你从数组的中间移除一个项，剩下的项会向回移动以填补空缺。原本位于索引3的"apples"项现在移到索引2的位置，那里曾经是"candy"。
- en: 'You can also remove all items from an array with removeAll() . Try entering
    this into your playground:'
  id: totrans-2290
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以使用 removeAll() 删除数组中的所有元素。尝试在你的 playground 中输入这个：
- en: '![](Image00129.jpg)'
  id: totrans-2291
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00129.jpg)'
- en: 'Note that trying to remove an item at an index that doesn’t exist will give
    you an error:'
  id: totrans-2292
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，尝试删除一个不存在的索引位置的元素会导致错误：
- en: '![](Image00130.jpg)'
  id: totrans-2293
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00130.jpg)'
- en: Our array doesn’t have this many items (in fact, now it’s empty!), so this throws
    an error. We’ll also get an error if we use removeLast() on our empty array, because
    there’s nothing in it—there’s no last index at all! However, removeAll() is always
    safe to use, even on an empty array.
  id: totrans-2294
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的数组没有这么多的元素（事实上，现在它是空的！），所以这会抛出一个错误。如果我们在空数组上使用 removeLast() 也会得到错误，因为它里面没有任何元素——根本没有最后一个索引！不过，removeAll()
    无论在空数组上使用都总是安全的。
- en: '**REPLACING ITEMS IN AN ARRAY**'
  id: totrans-2295
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**替换数组中的元素**'
- en: 'To replace an item in an array, you set the index of the array to the new value,
    as shown here:'
  id: totrans-2296
  prefs: []
  type: TYPE_NORMAL
  zh: 要替换数组中的一个元素，你需要将数组的索引设置为新的值，如下所示：
- en: '![](Image00131.jpg)'
  id: totrans-2297
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00131.jpg)'
- en: At ➊ , we replaced the item at index 2 (the third item) with "Unicorn" because
    magical animals count as favorite animals, too! At ➋ , we replaced the item at
    index 0 (the first item) with "Bearded dragon" . No, that’s not a real dragon—it’s
    just a lizard!
  id: totrans-2298
  prefs: []
  type: TYPE_NORMAL
  zh: 在 ➊ 处，我们将索引 2（第三个元素）的位置替换为 "独角兽"，因为魔法动物也算作是最喜欢的动物！在 ➋ 处，我们将索引 0（第一个元素）的位置替换为
    "鬃蜥"。不，这不是一种真正的龙——它只是一个蜥蜴！
- en: Like any time you’re working with array index numbers, you have to be sure an
    item exists in the array at that index before you change its value, or you will
    get an Index out of range error.
  id: totrans-2299
  prefs: []
  type: TYPE_NORMAL
  zh: 像处理数组索引时一样，在你修改值之前，必须确保该索引位置的元素存在，否则你将会遇到“索引超出范围”的错误。
- en: '[Figure 6-3](text00016.html#ch06fig3) shows the error that occurs if you try
    to add "Standard poodle" using favoriteAnimals[3] = "Standard poodle" . To add
    an item to the end of an array, you should use the append(_:) method or += , as
    we covered in “[Adding Items to an Array](text00016.html#ch06lev2sec5) ” on [page
    70](text00016.html#page_70) .'
  id: totrans-2300
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 6-3](text00016.html#ch06fig3) 显示了如果你尝试使用 favoriteAnimals[3] = "标准贵宾犬" 添加
    "标准贵宾犬" 时发生的错误。要将元素添加到数组的末尾，你应该使用 append(_:) 方法或 +=，正如我们在 “[向数组添加元素](text00016.html#ch06lev2sec5)”
    中第 [70 页](text00016.html#page_70) 提到的那样。'
- en: '![Image](Image00132.jpg)'
  id: totrans-2301
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00132.jpg)'
- en: '*Figure 6-3: Don’t try to replace a value at an index beyond the existing array.*'
  id: totrans-2302
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 6-3：不要尝试替换一个超出现有数组范围的索引位置的值。*'
- en: Now you know how to change arrays however you might need to. You can add items,
    take items away, or replace items. Next, we’ll look at how to use the properties
    of arrays to find out even more information about them.
  id: totrans-2303
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经知道了如何根据需要更改数组。你可以添加元素、删除元素或替换元素。接下来，我们将看看如何使用数组的属性来获取更多关于它们的信息。
- en: '![Image](Image00133.jpg)'
  id: totrans-2304
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00133.jpg)'
- en: '**USING ARRAY PROPERTIES**'
  id: totrans-2305
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**使用数组属性**'
- en: In addition to methods like append(_:) and removeLast() , arrays also have *properties*
    . An array’s properties are variables or constants that contain some information
    about the array. Two really helpful properties that you might use are the Boolean
    property isEmpty and the integer property count .
  id: totrans-2306
  prefs: []
  type: TYPE_NORMAL
  zh: 除了像 append(_:) 和 removeLast() 这样的方法外，数组还具有*属性*。数组的属性是包含一些关于数组信息的变量或常量。你可能会使用的两个非常有用的属性是布尔值属性
    isEmpty 和整数属性 count。
- en: The isEmpty property is true or false depending on whether the array is empty,
    and the count property will tell you how many items are in that array.
  id: totrans-2307
  prefs: []
  type: TYPE_NORMAL
  zh: isEmpty 属性根据数组是否为空返回 true 或 false，count 属性则会告诉你数组中有多少个元素。
- en: 'Check out how these two properties are used in the following if-else statement:'
  id: totrans-2308
  prefs: []
  type: TYPE_NORMAL
  zh: 查看以下 if-else 语句是如何使用这两个属性的：
- en: '![Image](Image00134.jpg)'
  id: totrans-2309
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00134.jpg)'
- en: 'This if-else statement checks whether the array mySiblings is empty ➊ . If
    it is, then "I don''t have any siblings." is printed. But if there is something
    in the array, then the number of siblings that we have is printed: "I have 3 siblings."
    ➋ .'
  id: totrans-2310
  prefs: []
  type: TYPE_NORMAL
  zh: 这个 if-else 语句检查数组 mySiblings 是否为空 ➊。如果为空，那么就会打印 "我没有兄弟姐妹"。但如果数组里有元素，那么就会打印我们有多少个兄弟姐妹："我有
    3 个兄弟姐妹" ➋。
- en: '**LOOPING OVER AN ARRAY**'
  id: totrans-2311
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**遍历数组**'
- en: 'Sometimes when you’re working with arrays you might want to do something to
    every item in the array. You can use a for-in loop to do that! The following code
    will print every topping in a pizzaToppings array on a separate line:'
  id: totrans-2312
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，当你在处理数组时，可能会想对数组中的每个元素做一些操作。你可以使用 for-in 循环来实现！以下代码会将 pizzaToppings 数组中的每个配料打印到单独的行上：
- en: '![Image](Image00135.jpg)'
  id: totrans-2313
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00135.jpg)'
- en: To write a for-in loop for the pizzaToppings array, we used the keyword for
    , followed by the constant topping , then the keyword in , and finally the name
    of our array, pizzaToppings . Then we put the statements that we want to run for
    each topping inside the braces of the for-in loop. The constant topping ➊ temporarily
    represents each pizza topping in the array as we loop through it. We could have
    chosen any name for this constant, but it’s a good idea to pick something that
    makes sense. You can see the output of this for-in loop in [Figure 6-4](text00016.html#ch06fig4)
    .
  id: totrans-2314
  prefs: []
  type: TYPE_NORMAL
  zh: 为了编写一个针对`pizzaToppings`数组的for-in循环，我们使用了关键字for，接着是常量`topping`，然后是关键字in，最后是我们数组的名称`pizzaToppings`。然后我们把想要在每个配料上执行的语句放在for-in循环的大括号内。常量`topping`
    ➊临时代表数组中的每个比萨配料，当我们遍历数组时。我们本可以为这个常量选择任何名称，但选择一个有意义的名称是个好主意。你可以在[图6-4](text00016.html#ch06fig4)中看到这个for-in循环的输出。
- en: '![Image](Image00136.jpg)'
  id: totrans-2315
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00136.jpg)'
- en: '*Figure 6-4: Output of the example for-in loop*'
  id: totrans-2316
  prefs: []
  type: TYPE_NORMAL
  zh: '*图6-4：示例for-in循环的输出*'
- en: '![Image](Image00137.jpg)'
  id: totrans-2317
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00137.jpg)'
- en: 'Using for-in loops is great for printing every value in an array. If you’re
    working with numbers, you can even use them to perform math operations on each
    item, which makes for some speedy calculations! The following code takes an array
    of numbers and calculates the square for each (the square of a number is that
    number multiplied by itself):'
  id: totrans-2318
  prefs: []
  type: TYPE_NORMAL
  zh: 使用for-in循环非常适合打印数组中的每个值。如果你正在处理数字，甚至可以使用它们对每个项目执行数学运算，这样可以快速进行计算！以下代码接收一个数字数组，并计算每个数字的平方（一个数字的平方就是它自己乘以自己）：
- en: '![Image](Image00138.jpg)'
  id: totrans-2319
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00138.jpg)'
- en: '[Figure 6-5](text00016.html#ch06fig5) shows the results.'
  id: totrans-2320
  prefs: []
  type: TYPE_NORMAL
  zh: '[图6-5](text00016.html#ch06fig5)显示了结果。'
- en: '![Image](Image00139.jpg)'
  id: totrans-2321
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00139.jpg)'
- en: '*Figure 6-5: Printing the squares for each number in the myNumbers array*'
  id: totrans-2322
  prefs: []
  type: TYPE_NORMAL
  zh: '*图6-5：打印`myNumbers`数组中每个数字的平方*'
- en: '**DICTIONARIES ARE KEY!**'
  id: totrans-2323
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**字典非常重要！**'
- en: A *dictionary* is also a collection of values, but instead of an ordered index,
    each value has its own *key* . Because there’s no index, the values are not stored
    in any particular order. To access values in a dictionary, you look them up by
    their key.
  id: totrans-2324
  prefs: []
  type: TYPE_NORMAL
  zh: '*字典*也是一个值的集合，但不同于有序索引，每个值都有自己的*键*。由于没有索引，值的存储顺序是随机的。要访问字典中的值，你需要通过键来查找。'
- en: A key must be unique. You can’t have the same key more than once in the same
    dictionary. If there were two identical keys and you asked the computer to give
    you the value for one of them, the computer wouldn’t know which one to choose!
  id: totrans-2325
  prefs: []
  type: TYPE_NORMAL
  zh: 键必须是唯一的。在同一个字典中不能有重复的键。如果有两个相同的键，而你要求计算机给出其中一个的值，计算机将不知道该选择哪个！
- en: Let’s take a look at how to make a dictionary and write keys that will help
    you find all the information you need.
  id: totrans-2326
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看一下如何创建一个字典，并写下帮助你找到所有需要信息的键。
- en: '![Image](Image00140.jpg)'
  id: totrans-2327
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00140.jpg)'
- en: '**INITIALIZING A DICTIONARY**'
  id: totrans-2328
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**初始化字典**'
- en: 'To create and initialize a dictionary, first write var and the name of your
    dictionary. Then write the keys and corresponding values inside a pair of square
    brackets, similar to an array. Let’s create a dictionary to store the names of
    a few US states. The key for each state will be its two-letter abbreviation:'
  id: totrans-2329
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建并初始化一个字典，首先写下var和字典的名称。然后像数组一样，在一对方括号内写下键和值。我们来创建一个字典，存储一些美国州的名称。每个州的键将是它的两字母缩写：
- en: '![](Image00141.jpg)'
  id: totrans-2330
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00141.jpg)'
- en: As you can see, there’s a colon between each key and its value, and the key/value
    pairs are separated by commas.
  id: totrans-2331
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，每个键和值之间都有一个冒号，键/值对之间用逗号分隔。
- en: Dictionaries are different from arrays in that they are *unordered* . Because
    of that, it’s likely that the order of the states that you see in your results
    pane ➋ is different from the order in which you entered your states ➊ . It might
    even be different than the order that’s printed in this book!
  id: totrans-2332
  prefs: []
  type: TYPE_NORMAL
  zh: 字典与数组不同，它们是*无序的*。因此，你在结果面板中看到的状态顺序 ➋可能与输入状态的顺序 ➊不同，甚至可能与书中打印的顺序不同！
- en: As with arrays, you can use var to make a mutable dictionary or use let to make
    an immutable dictionary.
  id: totrans-2333
  prefs: []
  type: TYPE_NORMAL
  zh: 和数组一样，你可以使用var来创建一个可变字典，或者使用let来创建一个不可变字典。
- en: 'In Swift, all of the keys of a dictionary must be the same type, and all of
    the values of a dictionary must also be the same type, but the key type doesn’t
    have to match the value type. For example, if you wanted to store a collection
    of fractions, you could use doubles for the keys and strings for the values:'
  id: totrans-2334
  prefs: []
  type: TYPE_NORMAL
  zh: 在Swift中，字典的所有键必须是相同类型的，字典的所有值也必须是相同类型的，但键的类型不必与值的类型相匹配。例如，如果你想存储一组分数，你可以使用双精度浮点数作为键，使用字符串作为值：
- en: '![](Image00142.jpg)'
  id: totrans-2335
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00142.jpg)'
- en: In this dictionary, all of the keys must be doubles, and all of the values must
    be strings. Again, you’ll see that the order of the numbers in the results pane
    can be quite different from the order in which you wrote the fractions in your
    dictionary. This is fine because you don’t need to know the order to access anything.
    You can find any item that you need by its key. Let’s see how!
  id: totrans-2336
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个字典中，所有的键必须是双精度浮点数，所有的值必须是字符串。再次强调，你会看到结果窗格中的数字顺序与在字典中编写分数时的顺序可能完全不同。这没关系，因为你不需要知道顺序就能访问任何东西。你可以通过键找到任何你需要的项。让我们看看！
- en: '**ACCESSING VALUES IN A DICTIONARY**'
  id: totrans-2337
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**访问字典中的值**'
- en: 'Looking up a value in a dictionary is similar to how you access a value in
    an array except that you use a key inside the square brackets instead of an index,
    like this: usStates["TX"] .'
  id: totrans-2338
  prefs: []
  type: TYPE_NORMAL
  zh: 查找字典中的值类似于你在数组中访问值的方式，不同之处在于，你使用键而不是索引来访问，像这样：usStates["TX"]。
- en: There is a big difference, however, in how Swift returns the values from a dictionary.
    When you access a value at an index of an array, you are simply given the value.
    When you access a value with a key in a dictionary, you are given an optional.
  id: totrans-2339
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在Swift从字典返回值的方式上有一个很大的不同。当你通过数组的索引访问一个值时，你只是得到了该值。当你通过字典的键访问一个值时，你得到的是一个可选值。
- en: In [Chapter 5](text00015.html#ch05) , you learned that optionals might contain
    a value or might be nil . The reason Swift returns optionals when you’re looking
    up items in a dictionary is that the key you used might not exist in the dictionary,
    in which case there’s no value to access. Trying to access a value that doesn’t
    exist would give you a big fat error! To avoid that problem, Swift returns optionals.
    That means you need to unwrap any value you get out of a dictionary before you
    can do anything with it.
  id: totrans-2340
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第5章](text00015.html#ch05)中，你学到可选值可能包含一个值，也可能是nil。Swift在你查找字典中的项目时返回可选值的原因是，你使用的键可能在字典中不存在，在这种情况下没有值可供访问。尝试访问一个不存在的值会导致一个严重的错误！为了避免这个问题，Swift返回可选值。这意味着你需要解包从字典中获取的任何值，才能对它进行操作。
- en: 'To unwrap an optional, first you check whether it exists using an if-let statement,
    just like we did in [Chapter 5](text00015.html#ch05) . The following code shows
    you how to get a value out of a dictionary:'
  id: totrans-2341
  prefs: []
  type: TYPE_NORMAL
  zh: 要解包一个可选值，首先检查它是否存在，使用`if-let`语句，就像我们在[第5章](text00015.html#ch05)中做的那样。以下代码展示了如何从字典中获取一个值：
- en: '![Image](Image00143.jpg)'
  id: totrans-2342
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00143.jpg)'
- en: To retrieve "Texas" from the dictionary, we use if let to set a constant loneStarState
    to usStates["TX"] ➊ . Because we have this state in our dictionary, the line I
    have Texas in my dictionary. is printed. Next we try to access a state that is
    not in our dictionary by using the key usStates["FL"] ➋ . Thankfully, because
    we used an if-let statement, the program won’t crash when the computer can’t find
    this state. Instead, I don't have that state in my dictionary. is printed.
  id: totrans-2343
  prefs: []
  type: TYPE_NORMAL
  zh: 要从字典中检索“Texas”，我们使用`if let`语句将常量loneStarState设置为usStates["TX"] ➊。因为字典中有这个州，所以会打印出“I
    have Texas in my dictionary.”。接下来，我们尝试通过使用键usStates["FL"] ➋来访问一个不在字典中的州。幸运的是，由于我们使用了`if-let`语句，当计算机找不到这个州时，程序不会崩溃。相反，打印出“I
    don't have that state in my dictionary.”。
- en: '**ADDING ITEMS TO A DICTIONARY**'
  id: totrans-2344
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**向字典添加项目**'
- en: 'To add an item to a dictionary, first write the name of your dictionary and
    assign the new item to the key you want it to have in the dictionary. Let’s add
    "Minnesota" to our usStates dictionary:'
  id: totrans-2345
  prefs: []
  type: TYPE_NORMAL
  zh: 要向字典添加项，首先写下字典的名称，并将新项分配给你希望它在字典中拥有的键。让我们把“Minnesota”添加到我们的usStates字典中：
- en: '![](Image00144.jpg)'
  id: totrans-2346
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00144.jpg)'
- en: 'Now when you look at usStates , you’ll see that it’s updated to ["MN": "Minnesota",
    "WA": "Washington", "MA": "Massachusetts", "TX": "Texas"] . Remember, because
    you don’t have to rely on indices, your new dictionary item might appear anywhere
    in the dictionary.'
  id: totrans-2347
  prefs: []
  type: TYPE_NORMAL
  zh: '现在，当你查看usStates时，你会看到它已更新为["MN": "Minnesota", "WA": "Washington", "MA": "Massachusetts",
    "TX": "Texas"]。记住，由于你不必依赖索引，所以新的字典项可能出现在字典的任何位置。'
- en: '**REMOVING ITEMS FROM A DICTIONARY**'
  id: totrans-2348
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**从字典中删除项目**'
- en: Removing an item from a dictionary is quite simple; you do so by setting the
    value to nil . Because the values in dictionaries are returned as optionals, you
    don’t have to worry about nil causing any problems in your dictionary.
  id: totrans-2349
  prefs: []
  type: TYPE_NORMAL
  zh: 从字典中删除项非常简单；你可以通过将值设置为 `nil` 来删除。由于字典中的值作为可选值返回，因此你不必担心 `nil` 会导致字典出现任何问题。
- en: '![](Image00145.jpg)'
  id: totrans-2350
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00145.jpg)'
- en: 'You can see that after you remove the value at the key "MA" , usStates is updated
    to ["MN": "Minnesota", "WA": "Washington", "TX": "Texas"] . Remember that nil
    is special and means that there’s no value at all. That’s why you don’t see "MA":
    nil in our dictionary.'
  id: totrans-2351
  prefs: []
  type: TYPE_NORMAL
  zh: '你可以看到，在删除 "MA" 键对应的值后，`usStates` 更新为 ["MN": "Minnesota", "WA": "Washington",
    "TX": "Texas"]。记住，`nil` 是特殊的，意味着没有值。因此你不会在字典中看到 "MA": nil。'
- en: '**REPLACING ITEMS IN A DICTIONARY**'
  id: totrans-2352
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**替换字典中的项**'
- en: 'Replacing an item in a dictionary is also easy. It works the same was as replacing
    an item in an array. You just set the item that you want to replace to something
    else. Say you create a dictionary of fruit colors:'
  id: totrans-2353
  prefs: []
  type: TYPE_NORMAL
  zh: 替换字典中的项也很简单。它与替换数组中的项相同。你只需将要替换的项设置为其他值。假设你创建了一个水果颜色的字典：
- en: '![](Image00146.jpg)'
  id: totrans-2354
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00146.jpg)'
- en: At first we had the value "apple" for "red" , but then we decided that "raspberry"
    is a better fruit to use since sometimes apples are green or yellow. To replace
    "apple" with "raspberry" , we set colorFruits["red"] to its new value ➊ .
  id: totrans-2355
  prefs: []
  type: TYPE_NORMAL
  zh: 起初，我们为 "red" 键设定了值 "apple"，但后来我们决定 "raspberry" 是一个更好的水果，因为有时苹果是绿色或黄色的。为了将 "apple"
    替换为 "raspberry"，我们将 `colorFruits["red"]` 设置为它的新值 ➊。
- en: You may remember that this is the same way we entered a new value into a dictionary.
    If the key already exists in the dictionary, then the value for that key is replaced.
    If the key doesn’t already exist, then the new key/value pair will be added to
    the dictionary.
  id: totrans-2356
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能记得，这是我们将新值添加到字典的相同方式。如果键已经存在于字典中，那么该键的值将被替换。如果键不存在，那么新的键/值对将被添加到字典中。
- en: '![Image](Image00147.jpg)'
  id: totrans-2357
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00147.jpg)'
- en: '**USING DICTIONARY PROPERTIES**'
  id: totrans-2358
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**使用字典属性**'
- en: 'Like an array, a dictionary also has an isEmpty property and a count property.
    For example, the following code shows how you can use the isEmpty property to
    check if a dictionary is empty, and if it isn’t empty, the count property checks
    how many items you have. Imagine you have a basket of fruit for sale. You can
    use these properties to help you keep track of everything:'
  id: totrans-2359
  prefs: []
  type: TYPE_NORMAL
  zh: 与数组一样，字典也具有 `isEmpty` 属性和 `count` 属性。例如，以下代码演示了如何使用 `isEmpty` 属性检查字典是否为空，如果不为空，`count`
    属性则检查字典中有多少项。想象一下，你有一个水果篮子在出售。你可以使用这些属性来帮助你追踪所有内容：
- en: '![Image](Image00148.jpg)'
  id: totrans-2360
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00148.jpg)'
- en: 'A dictionary also has two special properties: keys , which contains all of
    the dictionary’s keys, and values , which contains all of its values. We’ll use
    these two properties when we loop through the dictionary.'
  id: totrans-2361
  prefs: []
  type: TYPE_NORMAL
  zh: 字典还有两个特殊的属性：`keys`，它包含字典的所有键，以及 `values`，它包含字典的所有值。当我们遍历字典时，会使用这两个属性。
- en: Let’s write some code that loops through our fruit baskets and prints the price
    of each fruit.
  id: totrans-2362
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们编写一些代码，遍历我们的水果篮并打印每种水果的价格。
- en: '**LOOPING OVER A DICTIONARY**'
  id: totrans-2363
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**遍历字典**'
- en: 'You can loop through a dictionary using a for-in loop. Because each item has
    a key and a value, you can do this in two different ways. This is how to loop
    through a dictionary using its keys:'
  id: totrans-2364
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用 `for-in` 循环遍历字典。由于每一项都有一个键和值，因此你可以通过两种不同的方式来实现这一点。这是通过键遍历字典的方法：
- en: '![Image](Image00149.jpg)'
  id: totrans-2365
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00149.jpg)'
- en: Here we use the dictionary’s keys property ➊ to loop through fruitBasket and
    print its contents. We start by writing the keyword for , followed by a constant
    name fruit for the dictionary key, the keyword in , the dictionary name, a period,
    and keys .
  id: totrans-2366
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们使用字典的 `keys` 属性 ➊ 来遍历 `fruitBasket` 并打印其内容。我们从写 `for` 关键字开始，后面跟着字典键的常量名称
    `fruit`，然后是 `in` 关键字，字典名称，接着是一个句点，最后是 `keys`。
- en: Inside the braces of our for-in loop, we have access to both the key, which
    we call fruit ➋ , and the value at that key when we force-unwrap its contents
    with fruitBasket[fruit]! ➌ . That value will be the fruit’s price.
  id: totrans-2367
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `for-in` 循环的花括号内，我们可以访问键，我们称之为 `fruit` ➋，以及通过强制解包其内容 `fruitBasket[fruit]!`
    ➌ 后获得的值。该值将是水果的价格。
- en: In this case, it’s safe to force-unwrap the value using an exclamation point
    because we know that the fruit key we’re using is definitely inside the dictionary.
  id: totrans-2368
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，使用感叹号强制解包值是安全的，因为我们知道我们使用的水果键一定在字典中。
- en: Any code we put inside the for-in loop will run once for every key in our dictionary.
    So you should see the print statement display three times.
  id: totrans-2369
  prefs: []
  type: TYPE_NORMAL
  zh: 我们放入 for-in 循环中的任何代码都会针对字典中的每个键执行一次。所以你应该看到打印语句显示三次。
- en: 'We can also loop through the dictionary using its values property:'
  id: totrans-2370
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以通过字典的 values 属性遍历字典：
- en: '![Image](Image00150.jpg)'
  id: totrans-2371
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00150.jpg)'
- en: We use the same style of for-in loop, but now we use a constant to refer to
    each value, which we call price , in the values property. When looping through
    values, we don’t have access to the keys from inside the loop.
  id: totrans-2372
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用相同风格的 for-in 循环，但现在我们使用常量来引用 values 属性中的每个值，我们称之为 price。在遍历 values 时，我们无法从循环内部访问键。
- en: Another difference to note is that price is not an optional because it’s accessed
    directly as a value in the fruitBasket dictionary. That means we don’t have to
    unwrap it. You should still see the print statement printed three times. [Figure
    6-6](text00016.html#ch06fig6) shows the output of both loops.
  id: totrans-2373
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个需要注意的区别是，价格不是可选项，因为它直接作为值访问 `fruitBasket` 字典中的内容。这意味着我们不需要解包它。你应该仍然看到打印语句打印三次。[图
    6-6](text00016.html#ch06fig6) 显示了两个循环的输出。
- en: '![Image](Image00151.jpg)'
  id: totrans-2374
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00151.jpg)'
- en: '*Figure 6-6: Looping through the keys and values of a dictionary with a for-in
    loop*'
  id: totrans-2375
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 6-6：使用 for-in 循环遍历字典的键和值*'
- en: The order of your results might be slightly different from ours. That’s because
    the items in a dictionary aren’t in a numbered order like they are in an array!
    And because the order is not guaranteed, you might see a different order printed
    if you run the same code again.
  id: totrans-2376
  prefs: []
  type: TYPE_NORMAL
  zh: 你的结果顺序可能与我们的稍有不同。因为字典中的项目不像数组那样按编号排序！由于顺序无法保证，如果你再次运行相同的代码，可能会看到不同的顺序被打印出来。
- en: '**WHAT YOU LEARNED**'
  id: totrans-2377
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**你学到了什么**'
- en: In this chapter, you learned how to store collections of items in an array and
    in a dictionary. To store items in an ordered list, you would use an array and
    look up each item by its index. If you wanted to store items by key instead, you
    would use a dictionary.
  id: totrans-2378
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你学习了如何将项目存储在数组和字典中。为了将项目存储在有序列表中，你应该使用数组，并通过索引查找每个项目。如果你想通过键存储项目，则应该使用字典。
- en: Knowing about arrays and dictionaries and how to use them is a powerful building
    block for almost any programming language. Next we will learn about functions,
    another very powerful tool. Functions are blocks of code that you create and name
    to perform a specific job. After you have written a function, you can use its
    name to call it from almost anywhere in your program.
  id: totrans-2379
  prefs: []
  type: TYPE_NORMAL
  zh: 了解数组和字典以及如何使用它们是几乎所有编程语言中的一个强大构建块。接下来我们将学习函数，这是另一个非常强大的工具。函数是你创建并命名的一块代码，用于执行特定的任务。编写完函数后，你可以通过它的名称在程序的几乎任何地方调用它。
- en: '![Image](Image00116.jpg)'
  id: totrans-2380
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00116.jpg)'
- en: '**USING TYPE INFERENCE**'
  id: totrans-2381
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**使用类型推断**'
- en: 'When we created our nationalParks array, we specified that we were creating
    an array of string values by adding a colon (: ) and [String] ➋ . This step is
    optional when you create an array and initialize it with one or more values because
    Swift will use type inference to determine the kind of data you want the array
    to hold. That means that you could just as easily have created the array by doing
    this:'
  id: totrans-2382
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们创建 nationalParks 数组时，我们通过添加冒号（:）和 [String] ➋ 来指定我们正在创建一个字符串值的数组。在创建数组并用一个或多个值初始化它时，这一步是可选的，因为
    Swift 会使用类型推断来确定你希望数组存储的数据类型。这意味着你也可以通过以下方式轻松创建数组：
- en: '![](Image00117.jpg)'
  id: totrans-2383
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00117.jpg)'
- en: Using type inference, Swift knows we initialized this array to hold strings,
    and it can hold only strings.
  id: totrans-2384
  prefs: []
  type: TYPE_NORMAL
  zh: 使用类型推断，Swift 知道我们初始化了这个数组来存储字符串，并且它只能存储字符串。
- en: The list of parks that we created the array with is an example of an array *literal*
    . A literal is a value that is exactly what you see. It is not a variable or constant
    but rather just the value without a name. "Grand Canyon" is an example of a string
    literal, and 7 is an example of an integer literal. An array literal is a list
    of items contained between two square brackets and separated by commas, like ["Acadia",
    "Zion", "Grand Canyon"] ➊ .
  id: totrans-2385
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建数组时使用的公园列表是数组*字面量*的一个例子。字面量是一个值，它与显示的内容完全一致。它不是变量或常量，而只是没有名称的值。“Grand Canyon”是一个字符串字面量的例子，而7是一个整数字面量的例子。数组字面量是包含在两个方括号之间并由逗号分隔的一组项目，例如
    ["Acadia", "Zion", "Grand Canyon"] ➊。
- en: '**ACCESSING ITEMS IN AN ARRAY**'
  id: totrans-2386
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**访问数组中的项目**'
- en: 'Let’s say you want to access an item in your array and use it in your program.
    Your friend asks you to tell them all about your travels, so you want to use the
    names of the national parks that you stored in the array. To access an item in
    your array, write the array name followed by the item’s index inside square brackets:'
  id: totrans-2387
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你想在你的程序中访问数组中的某个项并使用它。你的朋友让你告诉他们关于你旅行的所有事情，于是你想用你在数组中存储的国家公园的名字。要访问数组中的某个项，写上数组名称，后面跟着项的索引，索引放在方括号内：
- en: '![](Image00118.jpg)'
  id: totrans-2388
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00118.jpg)'
- en: In this example, we are accessing the names of the national parks and then printing
    them to the screen using print . To get the first item in nationalParks , you
    use nationalParks[0] ➊ . To access the second item in nationalParks , you use
    nationalParks[1] .
  id: totrans-2389
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们正在访问国家公园的名字，并使用 print 将它们打印到屏幕上。要获取 nationalParks 中的第一项，你使用 nationalParks[0]
    ➊ 。要访问 nationalParks 中的第二项，你使用 nationalParks[1] 。
- en: '**WATCHING THE RANGE**'
  id: totrans-2390
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**观看范围**'
- en: One important point about arrays is that if you try to access an item at an
    index that’s higher than the last index in the array, you’ll get an error. In
    [Figure 6-2](text00016.html#ch06fig2) , you can see that nationalParks[3] (which
    would be the fourth item in the array) gives you an error because there are only
    three national parks in the array, indexed from 0 to 2.
  id: totrans-2391
  prefs: []
  type: TYPE_NORMAL
  zh: 关于数组的一个重要点是，如果你尝试访问数组中某个索引大于数组最后一个索引的项，你将会遇到错误。在[图 6-2](text00016.html#ch06fig2)中，你可以看到
    nationalParks[3]（即数组中的第四项）会导致错误，因为数组中只有三个国家公园，索引从 0 到 2。
- en: As you can see, you get an error message that says Index out of range . If you
    try to access an item that doesn’t exist in your array, your app will crash!
  id: totrans-2392
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，你会收到一个错误信息，提示索引超出范围。如果你尝试访问数组中不存在的项，应用程序会崩溃！
- en: '![Image](Image00119.jpg)'
  id: totrans-2393
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00119.jpg)'
- en: '*Figure 6-2: Trying to access an index in the array where nothing exists causes
    an error.*'
  id: totrans-2394
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 6-2：尝试访问数组中不存在的索引会导致错误。*'
- en: '**ADDING ITEMS TO AN ARRAY**'
  id: totrans-2395
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**向数组添加项目**'
- en: One way to change an array is to add new items to it. There are a few different
    ways to do this, so let’s take a look at each.
  id: totrans-2396
  prefs: []
  type: TYPE_NORMAL
  zh: 更改数组的一种方法是向其添加新项。有几种不同的方法可以做到这一点，让我们逐一了解。
- en: 'First, you can use an array’s append(_:) method. *Append* means to add something.
    Using append(_:) , you can add one new item to the end of your array. Say you
    go on another trip and visit the Badlands, and you want to add it to your list
    of national parks. To do that, add this code into your playground:'
  id: totrans-2397
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，你可以使用数组的 append(_:) 方法。*Append* 的意思是添加某物。使用 append(_:) ，你可以将一个新项添加到数组的末尾。假设你又去了另一个旅行，参观了恶地（Badlands），并想把它添加到你的国家公园名单中。为此，将以下代码添加到你的
    playground 中：
- en: '![](Image00120.jpg)'
  id: totrans-2398
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00120.jpg)'
- en: To use the append(_:) method, first write the name of your array followed by
    a period and then append . Then, put the item you want to add to your array inside
    the parentheses. In this case, you put "Badlands" inside the parentheses.
  id: totrans-2399
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用 append(_:) 方法，首先写上你的数组名，后面跟一个句点，再接 append 。然后，把你想添加到数组中的项放在括号内。在这个例子中，你把
    "Badlands" 放在括号内。
- en: 'If you want to add something at a specific place in your array, use the array’s
    insert(_:at:) method instead. This method takes two arguments: the item that you
    want to insert and the index of where it should go in the array. (We’ll discuss
    arguments in more detail in [Chapter 7](text00017.html#ch07) .)'
  id: totrans-2400
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想在数组的特定位置添加内容，可以改用数组的 insert(_:at:) 方法。这个方法需要两个参数：你想插入的项和它应该放在数组中的位置的索引。（我们将在[第7章](text00017.html#ch07)中详细讨论参数。）
- en: 'Let’s say you totally forgot that you went to the Petrified Forest right after
    you visited the Grand Canyon, and you want to update your nationalParks array
    so it displays the parks in the order in which you visited them. To update your
    array, you could use the insert(_:at:) method to put the Petrified Forest in the
    right position:'
  id: totrans-2401
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你完全忘记了在参观大峡谷后去了化石森林，而你想更新你的 nationalParks 数组，以便按你访问的顺序显示这些公园。为了更新数组，你可以使用
    insert(_:at:) 方法，将化石森林放在正确的位置：
- en: '![](Image00121.jpg)'
  id: totrans-2402
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00121.jpg)'
- en: When you insert a new item at index 3, everything that was in the array at index
    3 or higher gets scooted over to make room for the new item. That means the item
    that was at index 3 is now at index 4, the item that was at index 4 is now at
    index 5, and so on. After you add the Petrified Forest, nationalParks is now ["Acadia",
    "Zion", "Grand Canyon", "Petrified Forest", "Badlands"] .
  id: totrans-2403
  prefs: []
  type: TYPE_NORMAL
  zh: 当你在索引3处插入新元素时，索引3及其之后的所有元素都会向右移动，为新元素腾出位置。这意味着原本位于索引3处的元素现在会移到索引4处，原本位于索引4处的元素会移到索引5处，以此类推。添加Petrified
    Forest后，nationalParks数组变为["Acadia", "Zion", "Grand Canyon", "Petrified Forest",
    "Badlands"]。
- en: '**COMBINING ARRAYS**'
  id: totrans-2404
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**合并数组**'
- en: 'Not only can you add new items to an array, but you can also add two arrays
    together using the + and += operators. Let’s say that you have the ingredients
    for a fruit smoothie in two arrays:'
  id: totrans-2405
  prefs: []
  type: TYPE_NORMAL
  zh: 不仅可以向数组中添加新元素，你还可以使用+和+=运算符将两个数组连接在一起。假设你有两个数组，分别包含制作水果冰沙的水果和液体：
- en: '![](Image00122.jpg)'
  id: totrans-2406
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00122.jpg)'
- en: Now you can make a delicious smoothie by adding the fruits and liquids arrays.
  id: totrans-2407
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你可以通过将fruits和liquids数组相加，制作一杯美味的冰沙。
- en: '![](Image00123.jpg)'
  id: totrans-2408
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00123.jpg)'
- en: The order of the ingredients in smoothie is the same as the order in fruits
    and liquids . If you created smoothie with liquids + fruits , then the liquids
    would come first.
  id: totrans-2409
  prefs: []
  type: TYPE_NORMAL
  zh: 冰沙中食材的顺序与fruits和liquids数组中的顺序相同。如果你使用liquids + fruits的方式创建冰沙，那么液体会排在前面。
- en: 'You use the += operator to add an array to the end of your array. Add some
    whipped cream as follows for extra yumminess:'
  id: totrans-2410
  prefs: []
  type: TYPE_NORMAL
  zh: 你使用+=运算符将一个数组添加到数组的末尾。为了让冰沙更美味，接下来可以添加一些鲜奶油：
- en: '![](Image00124.jpg)'
  id: totrans-2411
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00124.jpg)'
- en: Note that ["whipped cream"] is an array even though it has a single item in
    it. When you’re using += to append something to an array, you have to make sure
    you’re only trying to add another array. If you were to just write the string
    "whipped cream" without the square brackets around it, you would get an error.
  id: totrans-2412
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，["whipped cream"]即使只有一个元素，也仍然是一个数组。当你使用+=将元素追加到数组时，必须确保你只是在尝试添加另一个数组。如果你直接写"whipped
    cream"而没有将其放在方括号中，系统会报错。
- en: '![Image](Image00125.jpg)'
  id: totrans-2413
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00125.jpg)'
- en: '**REMOVING ITEMS FROM AN ARRAY**'
  id: totrans-2414
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**从数组中移除元素**'
- en: 'There are several methods for removing items from an array. Let’s start by
    looking at the array’s removeLast() method. As you might have guessed from its
    name, removeLast() removes the last item from your array. Let’s try it out with
    a shoppingList array:'
  id: totrans-2415
  prefs: []
  type: TYPE_NORMAL
  zh: 有几种方法可以从数组中移除元素。让我们从数组的removeLast()方法开始。正如你从名称上猜到的，removeLast()方法会移除数组中的最后一个元素。我们用一个shoppingList数组来试试：
- en: '![](Image00126.jpg)'
  id: totrans-2416
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00126.jpg)'
- en: Neat! Note that the removeLast() method returns the removed item, so you can
    store it in a new constant or variable if you want.
  id: totrans-2417
  prefs: []
  type: TYPE_NORMAL
  zh: 很棒！请注意，removeLast()方法会返回被移除的元素，因此你可以将其存储到一个新的常量或变量中， 如果你需要的话。
- en: 'You can also remove an item from a specific index by using the remove(at:)
    method. Let’s say that your mom doesn’t want you buying any candy and takes that
    off the list:'
  id: totrans-2418
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以通过使用remove(at:)方法来移除特定索引位置的元素。假设你妈妈不希望你买糖果，把它从清单上去掉：
- en: '![Image](Image00127.jpg)![](Image00128.jpg)'
  id: totrans-2419
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00127.jpg)![](Image00128.jpg)'
- en: Just like when we added an item to the middle of our array and all the items
    scooted over to make room, if you remove an item from the middle of an array,
    the rest of the items will scoot back to fill in that empty space. The "apples"
    item that was at index 3 is now at index 2, where "candy" was.
  id: totrans-2420
  prefs: []
  type: TYPE_NORMAL
  zh: 就像我们在数组中间添加元素时，所有元素都会向右移动腾出空间一样，如果你从数组的中间移除元素，其余的元素也会向左移动填补空缺。原本位于索引3处的"apples"现在位于索引2处，原本位于索引2处的"candy"则移到了索引3。
- en: 'You can also remove all items from an array with removeAll() . Try entering
    this into your playground:'
  id: totrans-2421
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以使用removeAll()方法移除数组中的所有元素。在你的playground中尝试输入这个：
- en: '![](Image00129.jpg)'
  id: totrans-2422
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00129.jpg)'
- en: 'Note that trying to remove an item at an index that doesn’t exist will give
    you an error:'
  id: totrans-2423
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，如果尝试移除一个不存在的索引位置的元素，会发生错误：
- en: '![](Image00130.jpg)'
  id: totrans-2424
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00130.jpg)'
- en: Our array doesn’t have this many items (in fact, now it’s empty!), so this throws
    an error. We’ll also get an error if we use removeLast() on our empty array, because
    there’s nothing in it—there’s no last index at all! However, removeAll() is always
    safe to use, even on an empty array.
  id: totrans-2425
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的数组并没有这么多元素（事实上，现在它已经是空的了！），因此会抛出错误。如果我们在空数组上使用removeLast()方法，也会报错，因为数组中没有任何元素——根本没有最后一个索引！然而，removeAll()方法在任何情况下都是安全的，即使是在空数组上使用。
- en: '**REPLACING ITEMS IN AN ARRAY**'
  id: totrans-2426
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**替换数组中的元素**'
- en: 'To replace an item in an array, you set the index of the array to the new value,
    as shown here:'
  id: totrans-2427
  prefs: []
  type: TYPE_NORMAL
  zh: 要替换数组中的元素，你可以将数组的某个索引设置为新的值，如下所示：
- en: '![](Image00131.jpg)'
  id: totrans-2428
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00131.jpg)'
- en: At ➊ , we replaced the item at index 2 (the third item) with "Unicorn" because
    magical animals count as favorite animals, too! At ➋ , we replaced the item at
    index 0 (the first item) with "Bearded dragon" . No, that’s not a real dragon—it’s
    just a lizard!
  id: totrans-2429
  prefs: []
  type: TYPE_NORMAL
  zh: 在 ➊ 处，我们将索引为 2（第三个项目）的位置的元素替换为 "独角兽"，因为魔法动物也算作最爱的动物！在 ➋ 处，我们将索引为 0（第一个项目）的位置的元素替换为
    "有鬃蜥"。不，这不是一只真正的龙——它只是一只蜥蜴！
- en: Like any time you’re working with array index numbers, you have to be sure an
    item exists in the array at that index before you change its value, or you will
    get an Index out of range error.
  id: totrans-2430
  prefs: []
  type: TYPE_NORMAL
  zh: 就像在处理数组索引时一样，你必须确保在改变数组中某个索引的值之前，该索引位置有一个元素，否则会出现“索引超出范围”的错误。
- en: '[Figure 6-3](text00016.html#ch06fig3) shows the error that occurs if you try
    to add "Standard poodle" using favoriteAnimals[3] = "Standard poodle" . To add
    an item to the end of an array, you should use the append(_:) method or += , as
    we covered in “[Adding Items to an Array](text00016.html#ch06lev2sec5) ” on [page
    70](text00016.html#page_70) .'
  id: totrans-2431
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 6-3](text00016.html#ch06fig3)显示了如果你尝试使用 favoriteAnimals[3] = "标准贵宾犬" 来添加
    "标准贵宾犬"，会发生的错误。要将一个项目添加到数组的末尾，你应该使用 append(_:) 方法或 +=，我们在 “[向数组添加项目](text00016.html#ch06lev2sec5)”
    中已经介绍过这个方法，见[第 70 页](text00016.html#page_70)。'
- en: '![Image](Image00132.jpg)'
  id: totrans-2432
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00132.jpg)'
- en: '*Figure 6-3: Don’t try to replace a value at an index beyond the existing array.*'
  id: totrans-2433
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 6-3：不要尝试替换超出现有数组范围的索引值。*'
- en: Now you know how to change arrays however you might need to. You can add items,
    take items away, or replace items. Next, we’ll look at how to use the properties
    of arrays to find out even more information about them.
  id: totrans-2434
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你知道如何根据需要更改数组了。你可以添加项目、删除项目或替换项目。接下来，我们将看看如何使用数组的属性来获取更多关于数组的信息。
- en: '![Image](Image00133.jpg)'
  id: totrans-2435
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00133.jpg)'
- en: '**USING ARRAY PROPERTIES**'
  id: totrans-2436
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**使用数组属性**'
- en: In addition to methods like append(_:) and removeLast() , arrays also have *properties*
    . An array’s properties are variables or constants that contain some information
    about the array. Two really helpful properties that you might use are the Boolean
    property isEmpty and the integer property count .
  id: totrans-2437
  prefs: []
  type: TYPE_NORMAL
  zh: 除了像 append(_:) 和 removeLast() 这样的函数外，数组还有 *属性*。数组的属性是包含数组相关信息的变量或常量。两个你可能会用到的非常有用的属性是布尔型的
    isEmpty 属性和整数型的 count 属性。
- en: The isEmpty property is true or false depending on whether the array is empty,
    and the count property will tell you how many items are in that array.
  id: totrans-2438
  prefs: []
  type: TYPE_NORMAL
  zh: isEmpty 属性的值为 true 或 false，取决于数组是否为空，而 count 属性会告诉你数组中有多少个元素。
- en: 'Check out how these two properties are used in the following if-else statement:'
  id: totrans-2439
  prefs: []
  type: TYPE_NORMAL
  zh: 查看以下 if-else 语句中这两个属性是如何使用的：
- en: '![Image](Image00134.jpg)'
  id: totrans-2440
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00134.jpg)'
- en: 'This if-else statement checks whether the array mySiblings is empty ➊ . If
    it is, then "I don''t have any siblings." is printed. But if there is something
    in the array, then the number of siblings that we have is printed: "I have 3 siblings."
    ➋ .'
  id: totrans-2441
  prefs: []
  type: TYPE_NORMAL
  zh: 这个 if-else 语句检查数组 mySiblings 是否为空 ➊。如果数组为空，则打印 "我没有兄弟姐妹"。但如果数组中有元素，则打印出我们有多少兄弟姐妹："我有
    3 个兄弟姐妹。" ➋。
- en: '**LOOPING OVER AN ARRAY**'
  id: totrans-2442
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**循环遍历数组**'
- en: 'Sometimes when you’re working with arrays you might want to do something to
    every item in the array. You can use a for-in loop to do that! The following code
    will print every topping in a pizzaToppings array on a separate line:'
  id: totrans-2443
  prefs: []
  type: TYPE_NORMAL
  zh: 有时在处理数组时，你可能想对数组中的每个项目执行相同的操作。你可以使用 for-in 循环来实现！以下代码会将 pizzaToppings 数组中的每个配料打印到单独的一行：
- en: '![Image](Image00135.jpg)'
  id: totrans-2444
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00135.jpg)'
- en: To write a for-in loop for the pizzaToppings array, we used the keyword for
    , followed by the constant topping , then the keyword in , and finally the name
    of our array, pizzaToppings . Then we put the statements that we want to run for
    each topping inside the braces of the for-in loop. The constant topping ➊ temporarily
    represents each pizza topping in the array as we loop through it. We could have
    chosen any name for this constant, but it’s a good idea to pick something that
    makes sense. You can see the output of this for-in loop in [Figure 6-4](text00016.html#ch06fig4)
    .
  id: totrans-2445
  prefs: []
  type: TYPE_NORMAL
  zh: 为了为 pizzaToppings 数组写一个 for-in 循环，我们使用了关键字 for，接着是常量 topping，然后是关键字 in，最后是数组名称
    pizzaToppings。然后我们将希望在每个 topping 上执行的语句放入 for-in 循环的大括号中。常量 topping ➊ 临时代表我们在遍历数组时每一个披萨配料。我们可以为这个常量选择任何名字，但选择一个有意义的名字是个好主意。你可以在[图
    6-4](text00016.html#ch06fig4)中看到这个 for-in 循环的输出。
- en: '![Image](Image00136.jpg)'
  id: totrans-2446
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00136.jpg)'
- en: '*Figure 6-4: Output of the example for-in loop*'
  id: totrans-2447
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 6-4：示例 for-in 循环的输出*'
- en: '![Image](Image00137.jpg)'
  id: totrans-2448
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00137.jpg)'
- en: 'Using for-in loops is great for printing every value in an array. If you’re
    working with numbers, you can even use them to perform math operations on each
    item, which makes for some speedy calculations! The following code takes an array
    of numbers and calculates the square for each (the square of a number is that
    number multiplied by itself):'
  id: totrans-2449
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`for-in`循环非常适合打印数组中的每个值。如果你正在处理数字，甚至可以使用它们对每个项执行数学运算，这样可以加快计算速度！以下代码取一个数字数组，并计算每个数字的平方（数字的平方是该数字与自身相乘）：
- en: '![Image](Image00138.jpg)'
  id: totrans-2450
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00138.jpg)'
- en: '[Figure 6-5](text00016.html#ch06fig5) shows the results.'
  id: totrans-2451
  prefs: []
  type: TYPE_NORMAL
  zh: '[图6-5](text00016.html#ch06fig5)显示了结果。'
- en: '![Image](Image00139.jpg)'
  id: totrans-2452
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00139.jpg)'
- en: '*Figure 6-5: Printing the squares for each number in the myNumbers array*'
  id: totrans-2453
  prefs: []
  type: TYPE_NORMAL
  zh: '*图6-5：打印myNumbers数组中每个数字的平方*'
- en: '**DICTIONARIES ARE KEY!**'
  id: totrans-2454
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**字典是关键！**'
- en: A *dictionary* is also a collection of values, but instead of an ordered index,
    each value has its own *key* . Because there’s no index, the values are not stored
    in any particular order. To access values in a dictionary, you look them up by
    their key.
  id: totrans-2455
  prefs: []
  type: TYPE_NORMAL
  zh: '*字典*也是一个值的集合，但不同于有序索引的是，每个值都有自己的*键*。由于没有索引，值不会按照任何特定顺序存储。要访问字典中的值，你需要通过它们的键来查找。'
- en: A key must be unique. You can’t have the same key more than once in the same
    dictionary. If there were two identical keys and you asked the computer to give
    you the value for one of them, the computer wouldn’t know which one to choose!
  id: totrans-2456
  prefs: []
  type: TYPE_NORMAL
  zh: 每个键必须是唯一的。在同一个字典中不能有相同的键。如果有两个相同的键，你请求计算机返回其中一个的值时，计算机就无法确定应该选择哪一个！
- en: Let’s take a look at how to make a dictionary and write keys that will help
    you find all the information you need.
  id: totrans-2457
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看一下如何创建字典并写入键，以帮助你找到所需的所有信息。
- en: '![Image](Image00140.jpg)'
  id: totrans-2458
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00140.jpg)'
- en: '**INITIALIZING A DICTIONARY**'
  id: totrans-2459
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**初始化字典**'
- en: 'To create and initialize a dictionary, first write var and the name of your
    dictionary. Then write the keys and corresponding values inside a pair of square
    brackets, similar to an array. Let’s create a dictionary to store the names of
    a few US states. The key for each state will be its two-letter abbreviation:'
  id: totrans-2460
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建并初始化一个字典，首先写出`var`和字典的名称。然后在一对方括号内写出键和值，类似于数组。我们来创建一个字典，用来存储一些美国州的名称。每个州的键将是它的两字母缩写：
- en: '![](Image00141.jpg)'
  id: totrans-2461
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00141.jpg)'
- en: As you can see, there’s a colon between each key and its value, and the key/value
    pairs are separated by commas.
  id: totrans-2462
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，每个键与其值之间有一个冒号，键值对之间用逗号分隔。
- en: Dictionaries are different from arrays in that they are *unordered* . Because
    of that, it’s likely that the order of the states that you see in your results
    pane ➋ is different from the order in which you entered your states ➊ . It might
    even be different than the order that’s printed in this book!
  id: totrans-2463
  prefs: []
  type: TYPE_NORMAL
  zh: 字典与数组的不同之处在于它们是*无序的*。因此，你在结果面板中看到的州的顺序➋可能与输入这些州的顺序➊不同。甚至可能与本书中打印出的顺序不同！
- en: As with arrays, you can use var to make a mutable dictionary or use let to make
    an immutable dictionary.
  id: totrans-2464
  prefs: []
  type: TYPE_NORMAL
  zh: 和数组一样，你可以使用`var`来创建可变字典，或者使用`let`来创建不可变字典。
- en: 'In Swift, all of the keys of a dictionary must be the same type, and all of
    the values of a dictionary must also be the same type, but the key type doesn’t
    have to match the value type. For example, if you wanted to store a collection
    of fractions, you could use doubles for the keys and strings for the values:'
  id: totrans-2465
  prefs: []
  type: TYPE_NORMAL
  zh: 在Swift中，字典的所有键必须是相同类型，字典的所有值也必须是相同类型，但键的类型不需要与值的类型相匹配。例如，如果你想存储一组分数，可以使用双精度数作为键，字符串作为值：
- en: '![](Image00142.jpg)'
  id: totrans-2466
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00142.jpg)'
- en: In this dictionary, all of the keys must be doubles, and all of the values must
    be strings. Again, you’ll see that the order of the numbers in the results pane
    can be quite different from the order in which you wrote the fractions in your
    dictionary. This is fine because you don’t need to know the order to access anything.
    You can find any item that you need by its key. Let’s see how!
  id: totrans-2467
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个字典中，所有的键必须是双精度数，所有的值必须是字符串。同样，你会发现结果面板中的数字顺序可能与在字典中写入分数的顺序相差很大。这没关系，因为你不需要知道顺序就可以访问任何内容。你可以通过键找到你需要的任何项目。我们来看看怎么做！
- en: '**ACCESSING VALUES IN A DICTIONARY**'
  id: totrans-2468
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**访问字典中的值**'
- en: 'Looking up a value in a dictionary is similar to how you access a value in
    an array except that you use a key inside the square brackets instead of an index,
    like this: usStates["TX"] .'
  id: totrans-2469
  prefs: []
  type: TYPE_NORMAL
  zh: 在字典中查找一个值类似于你如何在数组中访问值，只是你需要在方括号内使用键，而不是索引，像这样：usStates["TX"]。
- en: There is a big difference, however, in how Swift returns the values from a dictionary.
    When you access a value at an index of an array, you are simply given the value.
    When you access a value with a key in a dictionary, you are given an optional.
  id: totrans-2470
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，Swift返回字典中值的方式有很大的不同。当你在数组的索引位置访问一个值时，你只是直接获得这个值。当你使用键在字典中访问一个值时，你获得的是一个可选项。
- en: In [Chapter 5](text00015.html#ch05) , you learned that optionals might contain
    a value or might be nil . The reason Swift returns optionals when you’re looking
    up items in a dictionary is that the key you used might not exist in the dictionary,
    in which case there’s no value to access. Trying to access a value that doesn’t
    exist would give you a big fat error! To avoid that problem, Swift returns optionals.
    That means you need to unwrap any value you get out of a dictionary before you
    can do anything with it.
  id: totrans-2471
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第5章](text00015.html#ch05)中，你学到可选项可能包含一个值，也可能是nil。Swift返回可选项的原因是，在你查找字典中的项时，使用的键可能在字典中不存在，这种情况下没有值可以访问。尝试访问一个不存在的值会导致一个严重的错误！为了避免这个问题，Swift返回可选项。这意味着你需要解包从字典中取出的任何值，才能对其进行操作。
- en: 'To unwrap an optional, first you check whether it exists using an if-let statement,
    just like we did in [Chapter 5](text00015.html#ch05) . The following code shows
    you how to get a value out of a dictionary:'
  id: totrans-2472
  prefs: []
  type: TYPE_NORMAL
  zh: 要解包一个可选项，首先使用if-let语句检查它是否存在，就像我们在[第5章](text00015.html#ch05)中做的那样。下面的代码展示了如何从字典中获取一个值：
- en: '![Image](Image00143.jpg)'
  id: totrans-2473
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00143.jpg)'
- en: To retrieve "Texas" from the dictionary, we use if let to set a constant loneStarState
    to usStates["TX"] ➊ . Because we have this state in our dictionary, the line I
    have Texas in my dictionary. is printed. Next we try to access a state that is
    not in our dictionary by using the key usStates["FL"] ➋ . Thankfully, because
    we used an if-let statement, the program won’t crash when the computer can’t find
    this state. Instead, I don't have that state in my dictionary. is printed.
  id: totrans-2474
  prefs: []
  type: TYPE_NORMAL
  zh: 要从字典中检索“Texas”，我们使用if let将常量loneStarState设置为usStates["TX"] ➊。因为我们在字典中有这个州，所以会打印出“I
    have Texas in my dictionary.”。接下来，我们尝试通过键usStates["FL"] ➋访问一个不在字典中的州。幸运的是，由于我们使用了if-let语句，当计算机找不到这个州时，程序不会崩溃。相反，它会打印出“I
    don't have that state in my dictionary.”。
- en: '**ADDING ITEMS TO A DICTIONARY**'
  id: totrans-2475
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**向字典添加项**'
- en: 'To add an item to a dictionary, first write the name of your dictionary and
    assign the new item to the key you want it to have in the dictionary. Let’s add
    "Minnesota" to our usStates dictionary:'
  id: totrans-2476
  prefs: []
  type: TYPE_NORMAL
  zh: 要向字典中添加一个项，首先写下字典的名称，然后将新项分配给你想要它拥有的键。让我们将“Minnesota”添加到我们的usStates字典中：
- en: '![](Image00144.jpg)'
  id: totrans-2477
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00144.jpg)'
- en: 'Now when you look at usStates , you’ll see that it’s updated to ["MN": "Minnesota",
    "WA": "Washington", "MA": "Massachusetts", "TX": "Texas"] . Remember, because
    you don’t have to rely on indices, your new dictionary item might appear anywhere
    in the dictionary.'
  id: totrans-2478
  prefs: []
  type: TYPE_NORMAL
  zh: '现在，当你查看usStates时，你会看到它已经更新为["MN": "Minnesota", "WA": "Washington", "MA": "Massachusetts",
    "TX": "Texas"]。记住，因为你不需要依赖索引，所以你的新字典项可能出现在字典中的任何位置。'
- en: '**REMOVING ITEMS FROM A DICTIONARY**'
  id: totrans-2479
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**从字典中移除项**'
- en: Removing an item from a dictionary is quite simple; you do so by setting the
    value to nil . Because the values in dictionaries are returned as optionals, you
    don’t have to worry about nil causing any problems in your dictionary.
  id: totrans-2480
  prefs: []
  type: TYPE_NORMAL
  zh: 从字典中移除一个项非常简单；你只需要将其值设置为nil。因为字典中的值是作为可选项返回的，所以你不必担心nil会在字典中引发任何问题。
- en: '![](Image00145.jpg)'
  id: totrans-2481
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00145.jpg)'
- en: 'You can see that after you remove the value at the key "MA" , usStates is updated
    to ["MN": "Minnesota", "WA": "Washington", "TX": "Texas"] . Remember that nil
    is special and means that there’s no value at all. That’s why you don’t see "MA":
    nil in our dictionary.'
  id: totrans-2482
  prefs: []
  type: TYPE_NORMAL
  zh: '你可以看到，在你移除键"MA"的值之后，usStates被更新为["MN": "Minnesota", "WA": "Washington", "TX":
    "Texas"]。记住，nil是特殊的，意味着根本没有值。这就是为什么你在我们的字典中看不到"MA": nil的原因。'
- en: '**REPLACING ITEMS IN A DICTIONARY**'
  id: totrans-2483
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**替换字典中的项**'
- en: 'Replacing an item in a dictionary is also easy. It works the same was as replacing
    an item in an array. You just set the item that you want to replace to something
    else. Say you create a dictionary of fruit colors:'
  id: totrans-2484
  prefs: []
  type: TYPE_NORMAL
  zh: 替换字典中的项也很简单。它的工作方式与替换数组中的项相同。你只需要将你想替换的项设置为其他内容。例如，你可以创建一个水果颜色的字典：
- en: '![](Image00146.jpg)'
  id: totrans-2485
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00146.jpg)'
- en: At first we had the value "apple" for "red" , but then we decided that "raspberry"
    is a better fruit to use since sometimes apples are green or yellow. To replace
    "apple" with "raspberry" , we set colorFruits["red"] to its new value ➊ .
  id: totrans-2486
  prefs: []
  type: TYPE_NORMAL
  zh: 最初我们为“red”设置了值“apple”，但后来我们决定使用“raspberry”作为更合适的水果，因为有时候苹果是绿色或黄色的。为了将“apple”替换为“raspberry”，我们将colorFruits["red"]的值设置为新值
    ➊。
- en: You may remember that this is the same way we entered a new value into a dictionary.
    If the key already exists in the dictionary, then the value for that key is replaced.
    If the key doesn’t already exist, then the new key/value pair will be added to
    the dictionary.
  id: totrans-2487
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能记得，这和我们将新值添加到字典中的方式是一样的。如果键已经存在于字典中，那么该键的值将被替换。如果键不存在，新的键/值对将被添加到字典中。
- en: '![Image](Image00147.jpg)'
  id: totrans-2488
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00147.jpg)'
- en: '**USING DICTIONARY PROPERTIES**'
  id: totrans-2489
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**使用字典属性**'
- en: 'Like an array, a dictionary also has an isEmpty property and a count property.
    For example, the following code shows how you can use the isEmpty property to
    check if a dictionary is empty, and if it isn’t empty, the count property checks
    how many items you have. Imagine you have a basket of fruit for sale. You can
    use these properties to help you keep track of everything:'
  id: totrans-2490
  prefs: []
  type: TYPE_NORMAL
  zh: 类似于数组，字典也有isEmpty属性和count属性。例如，以下代码展示了如何使用isEmpty属性检查字典是否为空，如果不为空，count属性则用来检查字典中有多少项。假设你有一个待售的水果篮子，你可以利用这些属性来帮助你追踪所有的水果：
- en: '![Image](Image00148.jpg)'
  id: totrans-2491
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00148.jpg)'
- en: 'A dictionary also has two special properties: keys , which contains all of
    the dictionary’s keys, and values , which contains all of its values. We’ll use
    these two properties when we loop through the dictionary.'
  id: totrans-2492
  prefs: []
  type: TYPE_NORMAL
  zh: 字典还有两个特殊属性：keys，包含字典中的所有键，和values，包含字典中的所有值。我们将在遍历字典时使用这两个属性。
- en: Let’s write some code that loops through our fruit baskets and prints the price
    of each fruit.
  id: totrans-2493
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们写一些代码，遍历我们的水果篮子并打印每个水果的价格。
- en: '**LOOPING OVER A DICTIONARY**'
  id: totrans-2494
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**遍历字典**'
- en: 'You can loop through a dictionary using a for-in loop. Because each item has
    a key and a value, you can do this in two different ways. This is how to loop
    through a dictionary using its keys:'
  id: totrans-2495
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用for-in循环遍历字典。由于每个项都有一个键和值，你可以通过两种不同的方式来遍历字典。以下是使用键遍历字典的方法：
- en: '![Image](Image00149.jpg)'
  id: totrans-2496
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00149.jpg)'
- en: Here we use the dictionary’s keys property ➊ to loop through fruitBasket and
    print its contents. We start by writing the keyword for , followed by a constant
    name fruit for the dictionary key, the keyword in , the dictionary name, a period,
    and keys .
  id: totrans-2497
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们使用字典的keys属性 ➊ 遍历fruitBasket并打印其内容。我们首先写关键字for，然后是常量名fruit作为字典键，关键字in，字典名，句点，最后是keys。
- en: Inside the braces of our for-in loop, we have access to both the key, which
    we call fruit ➋ , and the value at that key when we force-unwrap its contents
    with fruitBasket[fruit]! ➌ . That value will be the fruit’s price.
  id: totrans-2498
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的for-in循环的花括号内，我们可以访问键值，称之为fruit ➋，以及通过强制解包其内容fruitBasket[fruit]! ➌ 获得的该键对应的值。这个值将是水果的价格。
- en: In this case, it’s safe to force-unwrap the value using an exclamation point
    because we know that the fruit key we’re using is definitely inside the dictionary.
  id: totrans-2499
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，使用感叹号强制解包值是安全的，因为我们知道使用的fruit键一定在字典内。
- en: Any code we put inside the for-in loop will run once for every key in our dictionary.
    So you should see the print statement display three times.
  id: totrans-2500
  prefs: []
  type: TYPE_NORMAL
  zh: 我们放入for-in循环中的任何代码将会为字典中的每个键执行一次。因此，你应该会看到打印语句显示三次。
- en: 'We can also loop through the dictionary using its values property:'
  id: totrans-2501
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以通过字典的values属性来遍历字典：
- en: '![Image](Image00150.jpg)'
  id: totrans-2502
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00150.jpg)'
- en: We use the same style of for-in loop, but now we use a constant to refer to
    each value, which we call price , in the values property. When looping through
    values, we don’t have access to the keys from inside the loop.
  id: totrans-2503
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用相同风格的for-in循环，但这次我们使用一个常量来引用值，称之为price，来自values属性。遍历值时，我们无法从循环内部访问键。
- en: Another difference to note is that price is not an optional because it’s accessed
    directly as a value in the fruitBasket dictionary. That means we don’t have to
    unwrap it. You should still see the print statement printed three times. [Figure
    6-6](text00016.html#ch06fig6) shows the output of both loops.
  id: totrans-2504
  prefs: []
  type: TYPE_NORMAL
  zh: 需要注意的另一个区别是，价格（price）不是可选项，因为它是直接作为值从fruitBasket字典中访问的。这意味着我们不需要解包它。你应该仍然会看到打印语句打印了三次。[图6-6](text00016.html#ch06fig6)显示了两个循环的输出。
- en: '![Image](Image00151.jpg)'
  id: totrans-2505
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00151.jpg)'
- en: '*Figure 6-6: Looping through the keys and values of a dictionary with a for-in
    loop*'
  id: totrans-2506
  prefs: []
  type: TYPE_NORMAL
  zh: '*图6-6：使用for-in循环遍历字典的键和值*'
- en: The order of your results might be slightly different from ours. That’s because
    the items in a dictionary aren’t in a numbered order like they are in an array!
    And because the order is not guaranteed, you might see a different order printed
    if you run the same code again.
  id: totrans-2507
  prefs: []
  type: TYPE_NORMAL
  zh: 你的结果顺序可能与我们的稍有不同。这是因为字典中的项不像数组中的项那样按编号顺序排列！而且由于顺序无法保证，如果你再次运行相同的代码，你可能会看到不同的输出顺序。
- en: '**WHAT YOU LEARNED**'
  id: totrans-2508
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**你学到了什么**'
- en: In this chapter, you learned how to store collections of items in an array and
    in a dictionary. To store items in an ordered list, you would use an array and
    look up each item by its index. If you wanted to store items by key instead, you
    would use a dictionary.
  id: totrans-2509
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你学习了如何将项存储在数组和字典中。要在有序列表中存储项，你可以使用数组，并通过索引查找每个项。如果你想按键存储项，你则可以使用字典。
- en: Knowing about arrays and dictionaries and how to use them is a powerful building
    block for almost any programming language. Next we will learn about functions,
    another very powerful tool. Functions are blocks of code that you create and name
    to perform a specific job. After you have written a function, you can use its
    name to call it from almost anywhere in your program.
  id: totrans-2510
  prefs: []
  type: TYPE_NORMAL
  zh: 了解数组和字典以及如何使用它们，是几乎所有编程语言的一个强大构建块。接下来，我们将学习函数，这是另一个非常强大的工具。函数是你创建并命名的代码块，用来执行特定的任务。在你编写了一个函数之后，你可以在程序的几乎任何地方通过调用它的名字来使用它。
- en: '**USING TYPE INFERENCE**'
  id: totrans-2511
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**使用类型推断**'
- en: 'When we created our nationalParks array, we specified that we were creating
    an array of string values by adding a colon (: ) and [String] ➋ . This step is
    optional when you create an array and initialize it with one or more values because
    Swift will use type inference to determine the kind of data you want the array
    to hold. That means that you could just as easily have created the array by doing
    this:'
  id: totrans-2512
  prefs: []
  type: TYPE_NORMAL
  zh: '当我们创建nationalParks数组时，我们通过添加冒号(: )和[String] ➋指定了我们正在创建一个字符串值的数组。此步骤在创建数组并用一个或多个值初始化时是可选的，因为Swift会使用类型推断来确定你希望数组保存的数据类型。这意味着，你也可以通过以下方式轻松创建该数组：'
- en: '![](Image00117.jpg)'
  id: totrans-2513
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00117.jpg)'
- en: Using type inference, Swift knows we initialized this array to hold strings,
    and it can hold only strings.
  id: totrans-2514
  prefs: []
  type: TYPE_NORMAL
  zh: 使用类型推断，Swift知道我们初始化这个数组来存储字符串，并且它只能存储字符串。
- en: The list of parks that we created the array with is an example of an array *literal*
    . A literal is a value that is exactly what you see. It is not a variable or constant
    but rather just the value without a name. "Grand Canyon" is an example of a string
    literal, and 7 is an example of an integer literal. An array literal is a list
    of items contained between two square brackets and separated by commas, like ["Acadia",
    "Zion", "Grand Canyon"] ➊ .
  id: totrans-2515
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建数组时使用的公园列表是一个*字面量*数组的例子。字面量是一个值，它就是你所看到的那个值。它不是一个变量或常量，而是一个没有名称的值。“Grand
    Canyon”是一个字符串字面量的例子，7是一个整数字面量的例子。数组字面量是包含在两个方括号之间，并用逗号分隔的项的列表，如["Acadia", "Zion",
    "Grand Canyon"] ➊。
- en: '**ACCESSING ITEMS IN AN ARRAY**'
  id: totrans-2516
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**访问数组中的项**'
- en: 'Let’s say you want to access an item in your array and use it in your program.
    Your friend asks you to tell them all about your travels, so you want to use the
    names of the national parks that you stored in the array. To access an item in
    your array, write the array name followed by the item’s index inside square brackets:'
  id: totrans-2517
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你想访问数组中的一个项并在程序中使用它。你的朋友让你告诉他们所有关于你旅行的事情，所以你想使用你存储在数组中的国家公园的名称。要访问数组中的一个项，只需写出数组名，后跟项的索引，索引放在方括号内：
- en: '![](Image00118.jpg)'
  id: totrans-2518
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00118.jpg)'
- en: In this example, we are accessing the names of the national parks and then printing
    them to the screen using print . To get the first item in nationalParks , you
    use nationalParks[0] ➊ . To access the second item in nationalParks , you use
    nationalParks[1] .
  id: totrans-2519
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们访问了国家公园的名称，然后使用print将它们打印到屏幕上。要获取nationalParks中的第一个项目，你可以使用nationalParks[0]
    ➊。要访问nationalParks中的第二个项目，你可以使用nationalParks[1]。
- en: '**WATCHING THE RANGE**'
  id: totrans-2520
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**观察范围**'
- en: One important point about arrays is that if you try to access an item at an
    index that’s higher than the last index in the array, you’ll get an error. In
    [Figure 6-2](text00016.html#ch06fig2) , you can see that nationalParks[3] (which
    would be the fourth item in the array) gives you an error because there are only
    three national parks in the array, indexed from 0 to 2.
  id: totrans-2521
  prefs: []
  type: TYPE_NORMAL
  zh: 关于数组的一个重要点是，如果你尝试访问一个高于数组最后一个索引的项目，就会出现错误。在[图6-2](text00016.html#ch06fig2)中，你可以看到nationalParks[3]（即数组中的第四项）会导致错误，因为数组中只有三个国家公园，索引从0到2。
- en: As you can see, you get an error message that says Index out of range . If you
    try to access an item that doesn’t exist in your array, your app will crash!
  id: totrans-2522
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，出现了一个错误信息，提示“索引超出范围”。如果你尝试访问一个在数组中不存在的项目，应用程序会崩溃！
- en: '![Image](Image00119.jpg)'
  id: totrans-2523
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00119.jpg)'
- en: '*Figure 6-2: Trying to access an index in the array where nothing exists causes
    an error.*'
  id: totrans-2524
  prefs: []
  type: TYPE_NORMAL
  zh: '*图6-2：尝试访问数组中不存在的索引会导致错误。*'
- en: '**ADDING ITEMS TO AN ARRAY**'
  id: totrans-2525
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**向数组中添加项目**'
- en: One way to change an array is to add new items to it. There are a few different
    ways to do this, so let’s take a look at each.
  id: totrans-2526
  prefs: []
  type: TYPE_NORMAL
  zh: 更改数组的其中一种方式是向其中添加新项。这里有几种不同的方法，接下来我们将逐一查看。
- en: 'First, you can use an array’s append(_:) method. *Append* means to add something.
    Using append(_:) , you can add one new item to the end of your array. Say you
    go on another trip and visit the Badlands, and you want to add it to your list
    of national parks. To do that, add this code into your playground:'
  id: totrans-2527
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，你可以使用数组的append(_:)方法。*Append*意思是添加某物。使用append(_:)，你可以将一个新项添加到数组的末尾。假设你去另一个地方旅行，参观了Badlands，并希望将其添加到你的国家公园列表中。为此，将以下代码添加到你的playground中：
- en: '![](Image00120.jpg)'
  id: totrans-2528
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00120.jpg)'
- en: To use the append(_:) method, first write the name of your array followed by
    a period and then append . Then, put the item you want to add to your array inside
    the parentheses. In this case, you put "Badlands" inside the parentheses.
  id: totrans-2529
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用append(_:)方法，首先写出数组的名称，后面跟一个句点，再接着写append。然后，把你想要添加到数组中的项目放在括号内。在这种情况下，你将"Badlands"放入括号中。
- en: 'If you want to add something at a specific place in your array, use the array’s
    insert(_:at:) method instead. This method takes two arguments: the item that you
    want to insert and the index of where it should go in the array. (We’ll discuss
    arguments in more detail in [Chapter 7](text00017.html#ch07) .)'
  id: totrans-2530
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想在数组的特定位置添加某个项目，请使用数组的insert(_:at:)方法。此方法需要两个参数：你要插入的项目和它在数组中应该放置的位置（索引）。我们将在[第7章](text00017.html#ch07)中更详细地讨论参数。
- en: 'Let’s say you totally forgot that you went to the Petrified Forest right after
    you visited the Grand Canyon, and you want to update your nationalParks array
    so it displays the parks in the order in which you visited them. To update your
    array, you could use the insert(_:at:) method to put the Petrified Forest in the
    right position:'
  id: totrans-2531
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你完全忘记了在参观大峡谷后去了石化森林，并且你想更新nationalParks数组，使其按你访问的顺序显示各个公园。要更新数组，你可以使用insert(_:at:)方法将石化森林放在正确的位置：
- en: '![](Image00121.jpg)'
  id: totrans-2532
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00121.jpg)'
- en: When you insert a new item at index 3, everything that was in the array at index
    3 or higher gets scooted over to make room for the new item. That means the item
    that was at index 3 is now at index 4, the item that was at index 4 is now at
    index 5, and so on. After you add the Petrified Forest, nationalParks is now ["Acadia",
    "Zion", "Grand Canyon", "Petrified Forest", "Badlands"] .
  id: totrans-2533
  prefs: []
  type: TYPE_NORMAL
  zh: 当你在索引3处插入一个新项目时，数组中索引3或更高位置的所有项目都会向后移动，以腾出空间给新项目。这意味着原本在索引3的位置的项目现在会在索引4，原本在索引4的项目会在索引5，以此类推。添加了石化森林之后，nationalParks数组现在是["Acadia",
    "Zion", "Grand Canyon", "Petrified Forest", "Badlands"]。
- en: '**COMBINING ARRAYS**'
  id: totrans-2534
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**合并数组**'
- en: 'Not only can you add new items to an array, but you can also add two arrays
    together using the + and += operators. Let’s say that you have the ingredients
    for a fruit smoothie in two arrays:'
  id: totrans-2535
  prefs: []
  type: TYPE_NORMAL
  zh: 你不仅可以向数组中添加新项，还可以使用+和+=操作符将两个数组合并。假设你有两个数组，分别包含制作水果smoothie的食材：
- en: '![](Image00122.jpg)'
  id: totrans-2536
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00122.jpg)'
- en: Now you can make a delicious smoothie by adding the fruits and liquids arrays.
  id: totrans-2537
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你可以通过将水果和液体数组添加在一起，制作出美味的smoothie。
- en: '![](Image00123.jpg)'
  id: totrans-2538
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00123.jpg)'
- en: The order of the ingredients in smoothie is the same as the order in fruits
    and liquids . If you created smoothie with liquids + fruits , then the liquids
    would come first.
  id: totrans-2539
  prefs: []
  type: TYPE_NORMAL
  zh: Smoothie中的食材顺序与水果和液体的顺序相同。如果你用液体+水果制作了smoothie，那么液体会先放进去。
- en: 'You use the += operator to add an array to the end of your array. Add some
    whipped cream as follows for extra yumminess:'
  id: totrans-2540
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用+=运算符将一个数组添加到数组的末尾。为了增加更多美味的口感，像这样添加一些鲜奶油：
- en: '![](Image00124.jpg)'
  id: totrans-2541
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00124.jpg)'
- en: Note that ["whipped cream"] is an array even though it has a single item in
    it. When you’re using += to append something to an array, you have to make sure
    you’re only trying to add another array. If you were to just write the string
    "whipped cream" without the square brackets around it, you would get an error.
  id: totrans-2542
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，["whipped cream"]是一个数组，尽管它只有一个项目。当你使用+=向数组中添加项目时，必须确保你添加的也是一个数组。如果你只是写下字符串“whipped
    cream”而没有加上方括号，你会得到一个错误。
- en: '![Image](Image00125.jpg)'
  id: totrans-2543
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00125.jpg)'
- en: '**REMOVING ITEMS FROM AN ARRAY**'
  id: totrans-2544
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**从数组中删除项目**'
- en: 'There are several methods for removing items from an array. Let’s start by
    looking at the array’s removeLast() method. As you might have guessed from its
    name, removeLast() removes the last item from your array. Let’s try it out with
    a shoppingList array:'
  id: totrans-2545
  prefs: []
  type: TYPE_NORMAL
  zh: 有几种方法可以从数组中删除项目。让我们首先看一下数组的removeLast()方法。正如你从方法名中可能猜到的，removeLast()会删除数组中的最后一个项目。我们用一个shoppingList数组来试试：
- en: '![](Image00126.jpg)'
  id: totrans-2546
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00126.jpg)'
- en: Neat! Note that the removeLast() method returns the removed item, so you can
    store it in a new constant or variable if you want.
  id: totrans-2547
  prefs: []
  type: TYPE_NORMAL
  zh: 真棒！注意，removeLast()方法返回已删除的项目，所以如果你愿意，可以将其存储在一个新的常量或变量中。
- en: 'You can also remove an item from a specific index by using the remove(at:)
    method. Let’s say that your mom doesn’t want you buying any candy and takes that
    off the list:'
  id: totrans-2548
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以通过使用remove(at:)方法从特定的索引删除一个项目。假设你的妈妈不想让你买糖果，并且把它从清单上移除：
- en: '![Image](Image00127.jpg)![](Image00128.jpg)'
  id: totrans-2549
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00127.jpg)![](Image00128.jpg)'
- en: Just like when we added an item to the middle of our array and all the items
    scooted over to make room, if you remove an item from the middle of an array,
    the rest of the items will scoot back to fill in that empty space. The "apples"
    item that was at index 3 is now at index 2, where "candy" was.
  id: totrans-2550
  prefs: []
  type: TYPE_NORMAL
  zh: 就像我们在数组中间添加项目时，所有项目会向一边移动以腾出空间一样，如果你从数组中间删除项目，其余的项目也会向回移动，填补这个空缺。原本位于索引3处的“苹果”项目现在位于索引2处，取代了“糖果”的位置。
- en: 'You can also remove all items from an array with removeAll() . Try entering
    this into your playground:'
  id: totrans-2551
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以使用removeAll()删除数组中的所有项目。在你的playground中输入以下内容试试：
- en: '![](Image00129.jpg)'
  id: totrans-2552
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00129.jpg)'
- en: 'Note that trying to remove an item at an index that doesn’t exist will give
    you an error:'
  id: totrans-2553
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，试图删除一个不存在索引处的项目会导致错误：
- en: '![](Image00130.jpg)'
  id: totrans-2554
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00130.jpg)'
- en: Our array doesn’t have this many items (in fact, now it’s empty!), so this throws
    an error. We’ll also get an error if we use removeLast() on our empty array, because
    there’s nothing in it—there’s no last index at all! However, removeAll() is always
    safe to use, even on an empty array.
  id: totrans-2555
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的数组中没有这么多项（事实上，现在它是空的！），所以这会抛出一个错误。如果我们在空数组上使用removeLast()，也会出错，因为数组中没有任何内容——根本没有最后一个索引！不过，removeAll()在任何情况下都可以安全使用，即使是空数组。
- en: '**REPLACING ITEMS IN AN ARRAY**'
  id: totrans-2556
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**替换数组中的项目**'
- en: 'To replace an item in an array, you set the index of the array to the new value,
    as shown here:'
  id: totrans-2557
  prefs: []
  type: TYPE_NORMAL
  zh: 要替换数组中的项目，你可以将数组的索引设置为新值，如下所示：
- en: '![](Image00131.jpg)'
  id: totrans-2558
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00131.jpg)'
- en: At ➊ , we replaced the item at index 2 (the third item) with "Unicorn" because
    magical animals count as favorite animals, too! At ➋ , we replaced the item at
    index 0 (the first item) with "Bearded dragon" . No, that’s not a real dragon—it’s
    just a lizard!
  id: totrans-2559
  prefs: []
  type: TYPE_NORMAL
  zh: 在➊，我们将索引为2（第三个项目）的位置的项目替换为“独角兽”，因为神奇动物也算是最喜欢的动物！在➋，我们将索引为0（第一个项目）的位置的项目替换为“胡须龙”。不，这不是一条真正的龙——它只是一个蜥蜴！
- en: Like any time you’re working with array index numbers, you have to be sure an
    item exists in the array at that index before you change its value, or you will
    get an Index out of range error.
  id: totrans-2560
  prefs: []
  type: TYPE_NORMAL
  zh: 就像处理数组索引时一样，在更改值之前，必须确保数组中该索引位置确实存在项目，否则会出现索引越界错误。
- en: '[Figure 6-3](text00016.html#ch06fig3) shows the error that occurs if you try
    to add "Standard poodle" using favoriteAnimals[3] = "Standard poodle" . To add
    an item to the end of an array, you should use the append(_:) method or += , as
    we covered in “[Adding Items to an Array](text00016.html#ch06lev2sec5) ” on [page
    70](text00016.html#page_70) .'
  id: totrans-2561
  prefs: []
  type: TYPE_NORMAL
  zh: '[图6-3](text00016.html#ch06fig3)显示了如果你试图使用favoriteAnimals[3] = "Standard poodle"来添加“标准贵宾犬”时发生的错误。要将项目添加到数组的末尾，应该使用append(_:)方法或+=，正如我们在“[向数组添加项目](text00016.html#ch06lev2sec5)”中所讲解的，在[第70页](text00016.html#page_70)。'
- en: '![Image](Image00132.jpg)'
  id: totrans-2562
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00132.jpg)'
- en: '*Figure 6-3: Don’t try to replace a value at an index beyond the existing array.*'
  id: totrans-2563
  prefs: []
  type: TYPE_NORMAL
  zh: '*图6-3：不要试图替换超出现有数组范围的索引处的值。*'
- en: Now you know how to change arrays however you might need to. You can add items,
    take items away, or replace items. Next, we’ll look at how to use the properties
    of arrays to find out even more information about them.
  id: totrans-2564
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经知道如何根据需要更改数组了。你可以添加元素、删除元素或替换元素。接下来，我们将看看如何使用数组的属性来获取更多有关数组的信息。
- en: '![Image](Image00133.jpg)'
  id: totrans-2565
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Image00133.jpg)'
- en: '**USING ARRAY PROPERTIES**'
  id: totrans-2566
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**使用数组属性**'
- en: In addition to methods like append(_:) and removeLast() , arrays also have *properties*
    . An array’s properties are variables or constants that contain some information
    about the array. Two really helpful properties that you might use are the Boolean
    property isEmpty and the integer property count .
  id: totrans-2567
  prefs: []
  type: TYPE_NORMAL
  zh: 除了像 append(_:) 和 removeLast() 这样的操作方法，数组还有*属性*。数组的属性是包含关于数组的一些信息的变量或常量。有两个非常有用的属性你可能会用到，它们分别是布尔类型属性
    isEmpty 和整数类型属性 count。
- en: The isEmpty property is true or false depending on whether the array is empty,
    and the count property will tell you how many items are in that array.
  id: totrans-2568
  prefs: []
  type: TYPE_NORMAL
  zh: isEmpty 属性的值为 true 或 false，取决于数组是否为空，而 count 属性将告诉你数组中有多少个元素。
- en: 'Check out how these two properties are used in the following if-else statement:'
  id: totrans-2569
  prefs: []
  type: TYPE_NORMAL
  zh: 看看以下 if-else 语句是如何使用这两个属性的：
- en: '![Image](Image00134.jpg)'
  id: totrans-2570
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Image00134.jpg)'
- en: 'This if-else statement checks whether the array mySiblings is empty ➊ . If
    it is, then "I don''t have any siblings." is printed. But if there is something
    in the array, then the number of siblings that we have is printed: "I have 3 siblings."
    ➋ .'
  id: totrans-2571
  prefs: []
  type: TYPE_NORMAL
  zh: 这个 if-else 语句检查数组 mySiblings 是否为空 ➊。如果为空，则输出 "我没有兄弟姐妹"。但如果数组中有元素，则输出我们有多少兄弟姐妹："我有
    3 个兄弟姐妹" ➋。
- en: '**LOOPING OVER AN ARRAY**'
  id: totrans-2572
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**遍历数组**'
- en: 'Sometimes when you’re working with arrays you might want to do something to
    every item in the array. You can use a for-in loop to do that! The following code
    will print every topping in a pizzaToppings array on a separate line:'
  id: totrans-2573
  prefs: []
  type: TYPE_NORMAL
  zh: 有时在处理数组时，你可能想对数组中的每个元素做一些处理。你可以使用 for-in 循环来实现！以下代码将在 pizzaToppings 数组中打印每个配料，每个配料占一行：
- en: '![Image](Image00135.jpg)'
  id: totrans-2574
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Image00135.jpg)'
- en: To write a for-in loop for the pizzaToppings array, we used the keyword for
    , followed by the constant topping , then the keyword in , and finally the name
    of our array, pizzaToppings . Then we put the statements that we want to run for
    each topping inside the braces of the for-in loop. The constant topping ➊ temporarily
    represents each pizza topping in the array as we loop through it. We could have
    chosen any name for this constant, but it’s a good idea to pick something that
    makes sense. You can see the output of this for-in loop in [Figure 6-4](text00016.html#ch06fig4)
    .
  id: totrans-2575
  prefs: []
  type: TYPE_NORMAL
  zh: 要编写一个针对 pizzaToppings 数组的 for-in 循环，我们使用关键字 for，后跟常量 topping，再接着关键字 in，最后是我们的数组名称
    pizzaToppings。然后我们将每个 topping 的处理语句放入 for-in 循环的花括号内。常量 topping ➊ 在我们遍历数组时临时代表数组中的每个披萨配料。我们可以为这个常量选择任何名称，但最好选择一个有意义的名称。你可以在[图
    6-4](text00016.html#ch06fig4)中看到这个 for-in 循环的输出。
- en: '![Image](Image00136.jpg)'
  id: totrans-2576
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Image00136.jpg)'
- en: '*Figure 6-4: Output of the example for-in loop*'
  id: totrans-2577
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 6-4：示例 for-in 循环的输出*'
- en: '![Image](Image00137.jpg)'
  id: totrans-2578
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Image00137.jpg)'
- en: 'Using for-in loops is great for printing every value in an array. If you’re
    working with numbers, you can even use them to perform math operations on each
    item, which makes for some speedy calculations! The following code takes an array
    of numbers and calculates the square for each (the square of a number is that
    number multiplied by itself):'
  id: totrans-2579
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 for-in 循环非常适合打印数组中的每个值。如果你在处理数字，你甚至可以利用它们对每个元素进行数学运算，从而加快计算速度！以下代码接收一个数字数组并计算每个数字的平方（一个数字的平方是该数字与自身相乘）：
- en: '![Image](Image00138.jpg)'
  id: totrans-2580
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Image00138.jpg)'
- en: '[Figure 6-5](text00016.html#ch06fig5) shows the results.'
  id: totrans-2581
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 6-5](text00016.html#ch06fig5)展示了结果。'
- en: '![Image](Image00139.jpg)'
  id: totrans-2582
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Image00139.jpg)'
- en: '*Figure 6-5: Printing the squares for each number in the myNumbers array*'
  id: totrans-2583
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 6-5：打印 myNumbers 数组中每个数字的平方*'
- en: '**DICTIONARIES ARE KEY!**'
  id: totrans-2584
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**字典非常重要！**'
- en: A *dictionary* is also a collection of values, but instead of an ordered index,
    each value has its own *key* . Because there’s no index, the values are not stored
    in any particular order. To access values in a dictionary, you look them up by
    their key.
  id: totrans-2585
  prefs: []
  type: TYPE_NORMAL
  zh: '*字典*也是一种值的集合，但与数组不同的是，字典中的每个值都有自己的*键*。由于没有索引，字典中的值没有特定顺序。要访问字典中的值，你需要通过键来查找它们。'
- en: A key must be unique. You can’t have the same key more than once in the same
    dictionary. If there were two identical keys and you asked the computer to give
    you the value for one of them, the computer wouldn’t know which one to choose!
  id: totrans-2586
  prefs: []
  type: TYPE_NORMAL
  zh: 键必须是唯一的。你不能在同一个字典中使用相同的键。如果有两个相同的键，并且你要求计算机给你其中一个键对应的值，计算机就不知道该选择哪一个！
- en: Let’s take a look at how to make a dictionary and write keys that will help
    you find all the information you need.
  id: totrans-2587
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看一下如何创建一个字典并编写键，帮助你找到所有需要的信息。
- en: '![Image](Image00140.jpg)'
  id: totrans-2588
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00140.jpg)'
- en: '**INITIALIZING A DICTIONARY**'
  id: totrans-2589
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**初始化字典**'
- en: 'To create and initialize a dictionary, first write var and the name of your
    dictionary. Then write the keys and corresponding values inside a pair of square
    brackets, similar to an array. Let’s create a dictionary to store the names of
    a few US states. The key for each state will be its two-letter abbreviation:'
  id: totrans-2590
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建并初始化一个字典，首先写上 var 和字典的名称。然后在一对方括号内写入键和值，类似于数组。我们来创建一个字典来存储一些美国州的名称。每个州的键将是其两字母缩写：
- en: '![](Image00141.jpg)'
  id: totrans-2591
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00141.jpg)'
- en: As you can see, there’s a colon between each key and its value, and the key/value
    pairs are separated by commas.
  id: totrans-2592
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，每个键和值之间有一个冒号，键/值对通过逗号分隔。
- en: Dictionaries are different from arrays in that they are *unordered* . Because
    of that, it’s likely that the order of the states that you see in your results
    pane ➋ is different from the order in which you entered your states ➊ . It might
    even be different than the order that’s printed in this book!
  id: totrans-2593
  prefs: []
  type: TYPE_NORMAL
  zh: 字典与数组不同，字典是*无序的*。因此，你在结果面板中看到的州的顺序➋可能与输入州的顺序➊不同，甚至可能与本书中打印的顺序不同！
- en: As with arrays, you can use var to make a mutable dictionary or use let to make
    an immutable dictionary.
  id: totrans-2594
  prefs: []
  type: TYPE_NORMAL
  zh: 和数组一样，你可以使用 var 来创建一个可变字典，或者使用 let 来创建一个不可变字典。
- en: 'In Swift, all of the keys of a dictionary must be the same type, and all of
    the values of a dictionary must also be the same type, but the key type doesn’t
    have to match the value type. For example, if you wanted to store a collection
    of fractions, you could use doubles for the keys and strings for the values:'
  id: totrans-2595
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Swift 中，字典的所有键必须是相同类型，而字典的所有值也必须是相同类型，但键的类型不必与值的类型相匹配。例如，如果你想存储一组分数，可以使用双精度浮点数作为键，使用字符串作为值：
- en: '![](Image00142.jpg)'
  id: totrans-2596
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00142.jpg)'
- en: In this dictionary, all of the keys must be doubles, and all of the values must
    be strings. Again, you’ll see that the order of the numbers in the results pane
    can be quite different from the order in which you wrote the fractions in your
    dictionary. This is fine because you don’t need to know the order to access anything.
    You can find any item that you need by its key. Let’s see how!
  id: totrans-2597
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个字典中，所有的键必须是双精度浮点数，而所有的值必须是字符串。同样，你会发现结果面板中数字的顺序可能与在字典中写入分数的顺序完全不同。没关系，因为你不需要知道顺序来访问任何内容。你可以通过键来查找所需的任何项。我们来看一下！
- en: '**ACCESSING VALUES IN A DICTIONARY**'
  id: totrans-2598
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**访问字典中的值**'
- en: 'Looking up a value in a dictionary is similar to how you access a value in
    an array except that you use a key inside the square brackets instead of an index,
    like this: usStates["TX"] .'
  id: totrans-2599
  prefs: []
  type: TYPE_NORMAL
  zh: 查找字典中的值类似于在数组中访问值的方式，只不过你需要在方括号内使用一个键而不是索引，像这样：usStates["TX"]。
- en: There is a big difference, however, in how Swift returns the values from a dictionary.
    When you access a value at an index of an array, you are simply given the value.
    When you access a value with a key in a dictionary, you are given an optional.
  id: totrans-2600
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，Swift 在从字典中返回值的方式上存在很大差异。当你访问数组中的某个索引的值时，你仅仅是得到一个值。而当你通过字典中的键访问值时，你得到的是一个可选值。
- en: In [Chapter 5](text00015.html#ch05) , you learned that optionals might contain
    a value or might be nil . The reason Swift returns optionals when you’re looking
    up items in a dictionary is that the key you used might not exist in the dictionary,
    in which case there’s no value to access. Trying to access a value that doesn’t
    exist would give you a big fat error! To avoid that problem, Swift returns optionals.
    That means you need to unwrap any value you get out of a dictionary before you
    can do anything with it.
  id: totrans-2601
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第 5 章](text00015.html#ch05)中，你了解到可选值可能包含一个值，也可能为 nil。当你在字典中查找项时，Swift 返回可选值的原因是，你使用的键可能在字典中不存在，这种情况下就没有值可以访问。尝试访问不存在的值会导致一个大错误！为了避免这个问题，Swift
    返回可选值。这意味着你需要解包从字典中获取的任何值，才能对其进行操作。
- en: 'To unwrap an optional, first you check whether it exists using an if-let statement,
    just like we did in [Chapter 5](text00015.html#ch05) . The following code shows
    you how to get a value out of a dictionary:'
  id: totrans-2602
  prefs: []
  type: TYPE_NORMAL
  zh: 要展开一个可选值，首先使用 if-let 语句检查它是否存在，就像我们在[第 5 章](text00015.html#ch05)中做的那样。下面的代码展示了如何从字典中获取一个值：
- en: '![Image](Image00143.jpg)'
  id: totrans-2603
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00143.jpg)'
- en: To retrieve "Texas" from the dictionary, we use if let to set a constant loneStarState
    to usStates["TX"] ➊ . Because we have this state in our dictionary, the line I
    have Texas in my dictionary. is printed. Next we try to access a state that is
    not in our dictionary by using the key usStates["FL"] ➋ . Thankfully, because
    we used an if-let statement, the program won’t crash when the computer can’t find
    this state. Instead, I don't have that state in my dictionary. is printed.
  id: totrans-2604
  prefs: []
  type: TYPE_NORMAL
  zh: 要从字典中检索 "Texas"，我们使用 if let 将常量 loneStarState 设置为 usStates["TX"] ➊。由于我们在字典中有这个州，输出将显示
    "I have Texas in my dictionary."。接下来，我们尝试通过使用键 usStates["FL"] ➋ 访问一个不在字典中的州。幸运的是，因为我们使用了
    if-let 语句，当计算机找不到这个州时，程序不会崩溃，而是输出 "I don't have that state in my dictionary."。
- en: '**ADDING ITEMS TO A DICTIONARY**'
  id: totrans-2605
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**向字典中添加项**'
- en: 'To add an item to a dictionary, first write the name of your dictionary and
    assign the new item to the key you want it to have in the dictionary. Let’s add
    "Minnesota" to our usStates dictionary:'
  id: totrans-2606
  prefs: []
  type: TYPE_NORMAL
  zh: 要向字典中添加项，首先写出字典的名称，并将新项赋给你希望它在字典中拥有的键。让我们将 "Minnesota" 添加到我们的 usStates 字典中：
- en: '![](Image00144.jpg)'
  id: totrans-2607
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00144.jpg)'
- en: 'Now when you look at usStates , you’ll see that it’s updated to ["MN": "Minnesota",
    "WA": "Washington", "MA": "Massachusetts", "TX": "Texas"] . Remember, because
    you don’t have to rely on indices, your new dictionary item might appear anywhere
    in the dictionary.'
  id: totrans-2608
  prefs: []
  type: TYPE_NORMAL
  zh: '现在，当你查看 usStates 时，你会看到它已更新为 ["MN": "Minnesota", "WA": "Washington", "MA":
    "Massachusetts", "TX": "Texas"]。记住，由于你不需要依赖索引，所以新的字典项可能出现在字典中的任何位置。'
- en: '**REMOVING ITEMS FROM A DICTIONARY**'
  id: totrans-2609
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**从字典中移除项**'
- en: Removing an item from a dictionary is quite simple; you do so by setting the
    value to nil . Because the values in dictionaries are returned as optionals, you
    don’t have to worry about nil causing any problems in your dictionary.
  id: totrans-2610
  prefs: []
  type: TYPE_NORMAL
  zh: 从字典中移除项非常简单；你只需将该项的值设置为 nil。由于字典中的值是作为可选项返回的，所以你不必担心 nil 会在字典中引起任何问题。
- en: '![](Image00145.jpg)'
  id: totrans-2611
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00145.jpg)'
- en: 'You can see that after you remove the value at the key "MA" , usStates is updated
    to ["MN": "Minnesota", "WA": "Washington", "TX": "Texas"] . Remember that nil
    is special and means that there’s no value at all. That’s why you don’t see "MA":
    nil in our dictionary.'
  id: totrans-2612
  prefs: []
  type: TYPE_NORMAL
  zh: '你可以看到，在移除 "MA" 键的值之后，usStates 已更新为 ["MN": "Minnesota", "WA": "Washington",
    "TX": "Texas"]。记住，nil 是特殊的，意味着没有值。因此，你不会在字典中看到 "MA": nil。'
- en: '**REPLACING ITEMS IN A DICTIONARY**'
  id: totrans-2613
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**替换字典中的项**'
- en: 'Replacing an item in a dictionary is also easy. It works the same was as replacing
    an item in an array. You just set the item that you want to replace to something
    else. Say you create a dictionary of fruit colors:'
  id: totrans-2614
  prefs: []
  type: TYPE_NORMAL
  zh: 替换字典中的项也很简单。它的工作方式与替换数组中的项相同。你只需将要替换的项设置为其他值。假设你创建了一个水果颜色字典：
- en: '![](Image00146.jpg)'
  id: totrans-2615
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00146.jpg)'
- en: At first we had the value "apple" for "red" , but then we decided that "raspberry"
    is a better fruit to use since sometimes apples are green or yellow. To replace
    "apple" with "raspberry" , we set colorFruits["red"] to its new value ➊ .
  id: totrans-2616
  prefs: []
  type: TYPE_NORMAL
  zh: 一开始我们给 "red" 配置了值 "apple"，但后来我们决定 "raspberry" 更适合作为水果，因为有时候苹果是绿色或黄色的。为了将 "apple"
    替换为 "raspberry"，我们将 colorFruits["red"] 设置为它的新值 ➊。
- en: You may remember that this is the same way we entered a new value into a dictionary.
    If the key already exists in the dictionary, then the value for that key is replaced.
    If the key doesn’t already exist, then the new key/value pair will be added to
    the dictionary.
  id: totrans-2617
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能还记得，这正是我们将新值插入字典的方式。如果字典中已经存在该键，那么该键的值会被替换。如果该键不存在，则新的键/值对将被添加到字典中。
- en: '![Image](Image00147.jpg)'
  id: totrans-2618
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00147.jpg)'
- en: '**USING DICTIONARY PROPERTIES**'
  id: totrans-2619
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**使用字典属性**'
- en: 'Like an array, a dictionary also has an isEmpty property and a count property.
    For example, the following code shows how you can use the isEmpty property to
    check if a dictionary is empty, and if it isn’t empty, the count property checks
    how many items you have. Imagine you have a basket of fruit for sale. You can
    use these properties to help you keep track of everything:'
  id: totrans-2620
  prefs: []
  type: TYPE_NORMAL
  zh: 像数组一样，字典也有 isEmpty 属性和 count 属性。例如，以下代码展示了如何使用 isEmpty 属性检查字典是否为空，如果不为空，则使用
    count 属性检查字典中有多少项。假设你有一个待售的水果篮子。你可以使用这些属性帮助你跟踪所有的水果：
- en: '![Image](Image00148.jpg)'
  id: totrans-2621
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00148.jpg)'
- en: 'A dictionary also has two special properties: keys , which contains all of
    the dictionary’s keys, and values , which contains all of its values. We’ll use
    these two properties when we loop through the dictionary.'
  id: totrans-2622
  prefs: []
  type: TYPE_NORMAL
  zh: 字典还有两个特殊的属性：keys，它包含字典的所有键；以及values，它包含字典的所有值。我们将在遍历字典时使用这两个属性。
- en: Let’s write some code that loops through our fruit baskets and prints the price
    of each fruit.
  id: totrans-2623
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们编写一些代码，遍历我们的水果篮并打印每个水果的价格。
- en: '**LOOPING OVER A DICTIONARY**'
  id: totrans-2624
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**遍历字典**'
- en: 'You can loop through a dictionary using a for-in loop. Because each item has
    a key and a value, you can do this in two different ways. This is how to loop
    through a dictionary using its keys:'
  id: totrans-2625
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用for-in循环遍历字典。因为每个项目都有一个键和值，你可以通过两种不同的方式来做到这一点。这是通过键遍历字典的方法：
- en: '![Image](Image00149.jpg)'
  id: totrans-2626
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00149.jpg)'
- en: Here we use the dictionary’s keys property ➊ to loop through fruitBasket and
    print its contents. We start by writing the keyword for , followed by a constant
    name fruit for the dictionary key, the keyword in , the dictionary name, a period,
    and keys .
  id: totrans-2627
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们使用字典的keys属性➊来遍历fruitBasket并打印其内容。我们首先写下for关键字，然后是一个常量名fruit，用于字典的键，接着是in关键字，字典名称，一个句点，再加上keys。
- en: Inside the braces of our for-in loop, we have access to both the key, which
    we call fruit ➋ , and the value at that key when we force-unwrap its contents
    with fruitBasket[fruit]! ➌ . That value will be the fruit’s price.
  id: totrans-2628
  prefs: []
  type: TYPE_NORMAL
  zh: 在for-in循环的大括号内部，我们可以访问键fruit ➋ 和该键的值，当我们强制解包其内容时，使用fruitBasket[fruit]! ➌。该值将是水果的价格。
- en: In this case, it’s safe to force-unwrap the value using an exclamation point
    because we know that the fruit key we’re using is definitely inside the dictionary.
  id: totrans-2629
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，使用感叹号强制解包值是安全的，因为我们知道正在使用的fruit键肯定存在于字典中。
- en: Any code we put inside the for-in loop will run once for every key in our dictionary.
    So you should see the print statement display three times.
  id: totrans-2630
  prefs: []
  type: TYPE_NORMAL
  zh: 我们放入for-in循环中的任何代码都会为字典中的每个键执行一次。所以你应该看到打印语句被打印三次。
- en: 'We can also loop through the dictionary using its values property:'
  id: totrans-2631
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以使用字典的values属性进行循环：
- en: '![Image](Image00150.jpg)'
  id: totrans-2632
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00150.jpg)'
- en: We use the same style of for-in loop, but now we use a constant to refer to
    each value, which we call price , in the values property. When looping through
    values, we don’t have access to the keys from inside the loop.
  id: totrans-2633
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用相同的for-in循环样式，但现在我们使用常量来引用values属性中的每个值，我们称之为price。在循环遍历值时，我们无法从循环内部访问键。
- en: Another difference to note is that price is not an optional because it’s accessed
    directly as a value in the fruitBasket dictionary. That means we don’t have to
    unwrap it. You should still see the print statement printed three times. [Figure
    6-6](text00016.html#ch06fig6) shows the output of both loops.
  id: totrans-2634
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个需要注意的区别是，price不是一个可选值，因为它是直接作为fruitBasket字典中的值进行访问的。这意味着我们不需要解包它。你仍然会看到打印语句被打印三次。[图6-6](text00016.html#ch06fig6)显示了两个循环的输出。
- en: '![Image](Image00151.jpg)'
  id: totrans-2635
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00151.jpg)'
- en: '*Figure 6-6: Looping through the keys and values of a dictionary with a for-in
    loop*'
  id: totrans-2636
  prefs: []
  type: TYPE_NORMAL
  zh: '*图6-6：使用for-in循环遍历字典的键和值*'
- en: The order of your results might be slightly different from ours. That’s because
    the items in a dictionary aren’t in a numbered order like they are in an array!
    And because the order is not guaranteed, you might see a different order printed
    if you run the same code again.
  id: totrans-2637
  prefs: []
  type: TYPE_NORMAL
  zh: 你得到的结果顺序可能与我们的略有不同。因为字典中的项目不像数组那样按编号顺序排列！而且由于顺序不可保证，如果你再次运行相同的代码，可能会看到不同的顺序打印出来。
- en: '**WHAT YOU LEARNED**'
  id: totrans-2638
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**你学到的知识**'
- en: In this chapter, you learned how to store collections of items in an array and
    in a dictionary. To store items in an ordered list, you would use an array and
    look up each item by its index. If you wanted to store items by key instead, you
    would use a dictionary.
  id: totrans-2639
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你学习了如何在数组和字典中存储项目集合。要在有序列表中存储项目，你会使用数组，并通过索引查找每个项目。如果你想通过键来存储项目，你则会使用字典。
- en: Knowing about arrays and dictionaries and how to use them is a powerful building
    block for almost any programming language. Next we will learn about functions,
    another very powerful tool. Functions are blocks of code that you create and name
    to perform a specific job. After you have written a function, you can use its
    name to call it from almost anywhere in your program.
  id: totrans-2640
  prefs: []
  type: TYPE_NORMAL
  zh: 了解数组和字典及其使用方法是几乎所有编程语言中非常强大的构建模块。接下来我们将学习函数，另一种非常强大的工具。函数是你创建并命名的代码块，用来执行特定的任务。在你编写了一个函数之后，你可以通过它的名字在程序的几乎任何地方调用它。
- en: 'When we created our nationalParks array, we specified that we were creating
    an array of string values by adding a colon (: ) and [String] ➋ . This step is
    optional when you create an array and initialize it with one or more values because
    Swift will use type inference to determine the kind of data you want the array
    to hold. That means that you could just as easily have created the array by doing
    this:'
  id: totrans-2641
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们创建nationalParks数组时，我们通过添加冒号（:）和[String] ➋来指定我们正在创建一个字符串值的数组。当你创建并初始化一个或多个值的数组时，这一步是可选的，因为Swift会使用类型推断来确定你希望数组存储的数据类型。这意味着你也可以通过以下方式创建数组：
- en: '![](Image00117.jpg)'
  id: totrans-2642
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00117.jpg)'
- en: Using type inference, Swift knows we initialized this array to hold strings,
    and it can hold only strings.
  id: totrans-2643
  prefs: []
  type: TYPE_NORMAL
  zh: 通过类型推断，Swift知道我们初始化了这个数组以存储字符串，它只能存储字符串。
- en: The list of parks that we created the array with is an example of an array *literal*
    . A literal is a value that is exactly what you see. It is not a variable or constant
    but rather just the value without a name. "Grand Canyon" is an example of a string
    literal, and 7 is an example of an integer literal. An array literal is a list
    of items contained between two square brackets and separated by commas, like ["Acadia",
    "Zion", "Grand Canyon"] ➊ .
  id: totrans-2644
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建的包含公园列表的数组是一个数组*字面量*的例子。字面量是一个值，它就是你看到的那个值。它不是一个变量或常量，而只是没有名称的值。"Grand Canyon"是一个字符串字面量的例子，7是一个整数字面量的例子。数组字面量是一个由两对方括号包含并由逗号分隔的项目列表，比如["Acadia",
    "Zion", "Grand Canyon"] ➊。
- en: '**ACCESSING ITEMS IN AN ARRAY**'
  id: totrans-2645
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**访问数组中的项目**'
- en: 'Let’s say you want to access an item in your array and use it in your program.
    Your friend asks you to tell them all about your travels, so you want to use the
    names of the national parks that you stored in the array. To access an item in
    your array, write the array name followed by the item’s index inside square brackets:'
  id: totrans-2646
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你想要访问数组中的一个项目并在程序中使用它。你的朋友要求你告诉他们关于你旅行的所有事情，所以你想使用你存储在数组中的国家公园的名称。要访问数组中的一个项目，写下数组名称，后跟方括号中的项目索引：
- en: '![](Image00118.jpg)'
  id: totrans-2647
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00118.jpg)'
- en: In this example, we are accessing the names of the national parks and then printing
    them to the screen using print . To get the first item in nationalParks , you
    use nationalParks[0] ➊ . To access the second item in nationalParks , you use
    nationalParks[1] .
  id: totrans-2648
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们正在访问国家公园的名称，然后通过print将它们打印到屏幕上。要获取nationalParks中的第一个项目，你使用nationalParks[0]
    ➊。要访问nationalParks中的第二个项目，你使用nationalParks[1]。
- en: '**WATCHING THE RANGE**'
  id: totrans-2649
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**观察范围**'
- en: One important point about arrays is that if you try to access an item at an
    index that’s higher than the last index in the array, you’ll get an error. In
    [Figure 6-2](text00016.html#ch06fig2) , you can see that nationalParks[3] (which
    would be the fourth item in the array) gives you an error because there are only
    three national parks in the array, indexed from 0 to 2.
  id: totrans-2650
  prefs: []
  type: TYPE_NORMAL
  zh: 关于数组有一个重要的点是，如果你尝试访问一个高于数组中最后一个索引的项目，你将得到一个错误。在[图 6-2](text00016.html#ch06fig2)中，你可以看到nationalParks[3]（这将是数组中的第四个项目）给你一个错误，因为数组中只有三个国家公园，索引从0到2。
- en: As you can see, you get an error message that says Index out of range . If you
    try to access an item that doesn’t exist in your array, your app will crash!
  id: totrans-2651
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，你会收到一个错误信息，提示“索引超出范围”。如果你尝试访问数组中不存在的项目，你的应用程序将崩溃！
- en: '![Image](Image00119.jpg)'
  id: totrans-2652
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00119.jpg)'
- en: '*Figure 6-2: Trying to access an index in the array where nothing exists causes
    an error.*'
  id: totrans-2653
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 6-2：尝试访问数组中不存在的索引会导致错误。*'
- en: '**ADDING ITEMS TO AN ARRAY**'
  id: totrans-2654
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**向数组添加项目**'
- en: One way to change an array is to add new items to it. There are a few different
    ways to do this, so let’s take a look at each.
  id: totrans-2655
  prefs: []
  type: TYPE_NORMAL
  zh: 更改数组的一种方法是向其中添加新项目。有几种不同的方式可以做到这一点，让我们来看看每种方法。
- en: 'First, you can use an array’s append(_:) method. *Append* means to add something.
    Using append(_:) , you can add one new item to the end of your array. Say you
    go on another trip and visit the Badlands, and you want to add it to your list
    of national parks. To do that, add this code into your playground:'
  id: totrans-2656
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，你可以使用数组的append(_:)方法。*Append*表示添加某个项目。使用append(_:)，你可以将一个新项目添加到数组的末尾。假设你去了一次新的旅行，参观了荒原国家公园，并且你想将它添加到你的国家公园列表中。为了做到这一点，可以将以下代码添加到你的Playground中：
- en: '![](Image00120.jpg)'
  id: totrans-2657
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00120.jpg)'
- en: To use the append(_:) method, first write the name of your array followed by
    a period and then append . Then, put the item you want to add to your array inside
    the parentheses. In this case, you put "Badlands" inside the parentheses.
  id: totrans-2658
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用append(_:)方法，首先写出数组的名称，后面跟一个句点，再加上append。然后，将你想要添加到数组中的项目放在括号内。在这个例子中，你把"Badlands"放在括号内。
- en: 'If you want to add something at a specific place in your array, use the array’s
    insert(_:at:) method instead. This method takes two arguments: the item that you
    want to insert and the index of where it should go in the array. (We’ll discuss
    arguments in more detail in [Chapter 7](text00017.html#ch07) .)'
  id: totrans-2659
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想在数组的特定位置添加项目，可以使用数组的insert(_:at:)方法。这个方法需要两个参数：你要插入的项目和它在数组中应该插入的位置索引。（我们将在[第7章](text00017.html#ch07)中更详细地讨论参数。）
- en: 'Let’s say you totally forgot that you went to the Petrified Forest right after
    you visited the Grand Canyon, and you want to update your nationalParks array
    so it displays the parks in the order in which you visited them. To update your
    array, you could use the insert(_:at:) method to put the Petrified Forest in the
    right position:'
  id: totrans-2660
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你完全忘记了你是在参观完Grand Canyon之后才去的Petrified Forest，而你想更新你的nationalParks数组，让它显示你访问的公园的顺序。为了更新数组，你可以使用insert(_:at:)方法，将Petrified
    Forest插入正确的位置：
- en: '![](Image00121.jpg)'
  id: totrans-2661
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00121.jpg)'
- en: When you insert a new item at index 3, everything that was in the array at index
    3 or higher gets scooted over to make room for the new item. That means the item
    that was at index 3 is now at index 4, the item that was at index 4 is now at
    index 5, and so on. After you add the Petrified Forest, nationalParks is now ["Acadia",
    "Zion", "Grand Canyon", "Petrified Forest", "Badlands"] .
  id: totrans-2662
  prefs: []
  type: TYPE_NORMAL
  zh: 当你在索引3的位置插入新项目时，数组中索引3及其之后的所有项目都会向后移动，为新项目腾出位置。这意味着原来在索引3的项目现在会变成索引4的项目，在索引4的项目会变成索引5的项目，以此类推。在你添加了Petrified
    Forest之后，nationalParks现在是["Acadia", "Zion", "Grand Canyon", "Petrified Forest",
    "Badlands"]。
- en: '**COMBINING ARRAYS**'
  id: totrans-2663
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**合并数组**'
- en: 'Not only can you add new items to an array, but you can also add two arrays
    together using the + and += operators. Let’s say that you have the ingredients
    for a fruit smoothie in two arrays:'
  id: totrans-2664
  prefs: []
  type: TYPE_NORMAL
  zh: 不仅可以向数组中添加新项目，还可以使用+和+=运算符将两个数组连接在一起。假设你有两个数组，分别存储了果昔的水果和液体成分：
- en: '![](Image00122.jpg)'
  id: totrans-2665
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00122.jpg)'
- en: Now you can make a delicious smoothie by adding the fruits and liquids arrays.
  id: totrans-2666
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你可以通过将水果和液体数组相加来制作美味的果昔。
- en: '![](Image00123.jpg)'
  id: totrans-2667
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00123.jpg)'
- en: The order of the ingredients in smoothie is the same as the order in fruits
    and liquids . If you created smoothie with liquids + fruits , then the liquids
    would come first.
  id: totrans-2668
  prefs: []
  type: TYPE_NORMAL
  zh: 果昔中成分的顺序与水果和液体数组中的顺序相同。如果你使用液体 + 水果的顺序创建果昔，那么液体将排在前面。
- en: 'You use the += operator to add an array to the end of your array. Add some
    whipped cream as follows for extra yumminess:'
  id: totrans-2669
  prefs: []
  type: TYPE_NORMAL
  zh: 你使用+=运算符将一个数组添加到你数组的末尾。你可以像下面这样添加一些鲜奶油，使它更美味：
- en: '![](Image00124.jpg)'
  id: totrans-2670
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00124.jpg)'
- en: Note that ["whipped cream"] is an array even though it has a single item in
    it. When you’re using += to append something to an array, you have to make sure
    you’re only trying to add another array. If you were to just write the string
    "whipped cream" without the square brackets around it, you would get an error.
  id: totrans-2671
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，虽然["whipped cream"]数组中只有一个项目，但它仍然是一个数组。当你使用+=将内容添加到数组时，必须确保你只是在尝试添加另一个数组。如果你只是写字符串"whipped
    cream"而没有加上方括号，就会出现错误。
- en: '![Image](Image00125.jpg)'
  id: totrans-2672
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00125.jpg)'
- en: '**REMOVING ITEMS FROM AN ARRAY**'
  id: totrans-2673
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**从数组中移除项目**'
- en: 'There are several methods for removing items from an array. Let’s start by
    looking at the array’s removeLast() method. As you might have guessed from its
    name, removeLast() removes the last item from your array. Let’s try it out with
    a shoppingList array:'
  id: totrans-2674
  prefs: []
  type: TYPE_NORMAL
  zh: 有几种方法可以从数组中移除项目。我们从数组的removeLast()方法开始。正如你从方法名中可以猜到的，removeLast()会移除数组中的最后一个项目。我们可以通过一个shoppingList数组来尝试一下：
- en: '![](Image00126.jpg)'
  id: totrans-2675
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00126.jpg)'
- en: Neat! Note that the removeLast() method returns the removed item, so you can
    store it in a new constant or variable if you want.
  id: totrans-2676
  prefs: []
  type: TYPE_NORMAL
  zh: 很棒！请注意，removeLast()方法会返回被移除的项，因此如果需要，你可以将其存储在一个新的常量或变量中。
- en: 'You can also remove an item from a specific index by using the remove(at:)
    method. Let’s say that your mom doesn’t want you buying any candy and takes that
    off the list:'
  id: totrans-2677
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以通过使用remove(at:)方法从特定索引移除一项。假设你的妈妈不希望你买糖果，并把它从列表中移除：
- en: '![Image](Image00127.jpg)![](Image00128.jpg)'
  id: totrans-2678
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00127.jpg)![](Image00128.jpg)'
- en: Just like when we added an item to the middle of our array and all the items
    scooted over to make room, if you remove an item from the middle of an array,
    the rest of the items will scoot back to fill in that empty space. The "apples"
    item that was at index 3 is now at index 2, where "candy" was.
  id: totrans-2679
  prefs: []
  type: TYPE_NORMAL
  zh: 就像我们将一项添加到数组中间时，所有项都会挤到一起以腾出空间一样，如果你从数组中间移除一项，其余项也会挤到一起填补那个空缺。曾经在索引3处的“苹果”项现在位于索引2，原来的“糖果”项所在的位置。
- en: 'You can also remove all items from an array with removeAll() . Try entering
    this into your playground:'
  id: totrans-2680
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以使用removeAll()方法移除数组中的所有项。试着在你的游乐场中输入这个：
- en: '![](Image00129.jpg)'
  id: totrans-2681
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00129.jpg)'
- en: 'Note that trying to remove an item at an index that doesn’t exist will give
    you an error:'
  id: totrans-2682
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，尝试移除一个不存在的索引位置的项会引发错误：
- en: '![](Image00130.jpg)'
  id: totrans-2683
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00130.jpg)'
- en: Our array doesn’t have this many items (in fact, now it’s empty!), so this throws
    an error. We’ll also get an error if we use removeLast() on our empty array, because
    there’s nothing in it—there’s no last index at all! However, removeAll() is always
    safe to use, even on an empty array.
  id: totrans-2684
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的数组没有这么多项（事实上，现在它是空的！），所以这会抛出一个错误。如果我们在空数组上使用removeLast()，也会出错，因为数组中没有任何项——根本没有最后一个索引！但是，removeAll()方法在任何情况下都是安全的，即使在空数组上也能使用。
- en: '**REPLACING ITEMS IN AN ARRAY**'
  id: totrans-2685
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**替换数组中的项**'
- en: 'To replace an item in an array, you set the index of the array to the new value,
    as shown here:'
  id: totrans-2686
  prefs: []
  type: TYPE_NORMAL
  zh: 要替换数组中的项，你需要将数组索引设置为新值，如下所示：
- en: '![](Image00131.jpg)'
  id: totrans-2687
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00131.jpg)'
- en: At ➊ , we replaced the item at index 2 (the third item) with "Unicorn" because
    magical animals count as favorite animals, too! At ➋ , we replaced the item at
    index 0 (the first item) with "Bearded dragon" . No, that’s not a real dragon—it’s
    just a lizard!
  id: totrans-2688
  prefs: []
  type: TYPE_NORMAL
  zh: 在➊处，我们将索引2（第三项）的项替换为“独角兽”，因为魔法动物也算是最爱的动物！在➋处，我们将索引0（第一项）的项替换为“胡须龙”。不，那不是一只真正的龙——它只是一个蜥蜴！
- en: Like any time you’re working with array index numbers, you have to be sure an
    item exists in the array at that index before you change its value, or you will
    get an Index out of range error.
  id: totrans-2689
  prefs: []
  type: TYPE_NORMAL
  zh: 就像在处理数组索引时一样，你必须确保该索引处的项存在，才能更改其值，否则会得到一个“索引超出范围”的错误。
- en: '[Figure 6-3](text00016.html#ch06fig3) shows the error that occurs if you try
    to add "Standard poodle" using favoriteAnimals[3] = "Standard poodle" . To add
    an item to the end of an array, you should use the append(_:) method or += , as
    we covered in “[Adding Items to an Array](text00016.html#ch06lev2sec5) ” on [page
    70](text00016.html#page_70) .'
  id: totrans-2690
  prefs: []
  type: TYPE_NORMAL
  zh: '[图6-3](text00016.html#ch06fig3)显示了当你尝试使用favoriteAnimals[3] = "标准贵宾犬"来添加“标准贵宾犬”时出现的错误。要将项添加到数组的末尾，你应该使用append(_:)方法或+=运算符，正如我们在[第70页](text00016.html#page_70)的“[向数组添加项](text00016.html#ch06lev2sec5)”中所讨论的。'
- en: '![Image](Image00132.jpg)'
  id: totrans-2691
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00132.jpg)'
- en: '*Figure 6-3: Don’t try to replace a value at an index beyond the existing array.*'
  id: totrans-2692
  prefs: []
  type: TYPE_NORMAL
  zh: '*图6-3：不要尝试替换超出现有数组索引范围的值。*'
- en: Now you know how to change arrays however you might need to. You can add items,
    take items away, or replace items. Next, we’ll look at how to use the properties
    of arrays to find out even more information about them.
  id: totrans-2693
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你知道如何根据需要更改数组了。你可以添加项，移除项或替换项。接下来，我们将看看如何使用数组的属性获取更多关于它们的信息。
- en: '![Image](Image00133.jpg)'
  id: totrans-2694
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00133.jpg)'
- en: '**USING ARRAY PROPERTIES**'
  id: totrans-2695
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**使用数组属性**'
- en: In addition to methods like append(_:) and removeLast() , arrays also have *properties*
    . An array’s properties are variables or constants that contain some information
    about the array. Two really helpful properties that you might use are the Boolean
    property isEmpty and the integer property count .
  id: totrans-2696
  prefs: []
  type: TYPE_NORMAL
  zh: 除了像append(_:)和removeLast()这样的函数方法，数组还有*属性*。数组的属性是包含一些关于数组信息的变量或常量。你可能会用到的两个非常有用的属性是布尔类型的isEmpty属性和整数类型的count属性。
- en: The isEmpty property is true or false depending on whether the array is empty,
    and the count property will tell you how many items are in that array.
  id: totrans-2697
  prefs: []
  type: TYPE_NORMAL
  zh: isEmpty属性根据数组是否为空返回true或false，而count属性则告诉你数组中有多少项。
- en: 'Check out how these two properties are used in the following if-else statement:'
  id: totrans-2698
  prefs: []
  type: TYPE_NORMAL
  zh: 看看在下面的 `if-else` 语句中如何使用这两个属性：
- en: '![Image](Image00134.jpg)'
  id: totrans-2699
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00134.jpg)'
- en: 'This if-else statement checks whether the array mySiblings is empty ➊ . If
    it is, then "I don''t have any siblings." is printed. But if there is something
    in the array, then the number of siblings that we have is printed: "I have 3 siblings."
    ➋ .'
  id: totrans-2700
  prefs: []
  type: TYPE_NORMAL
  zh: 这个 `if-else` 语句检查数组 `mySiblings` 是否为空 ➊ 。如果为空，则打印“我没有兄弟姐妹。” 如果数组中有内容，则打印我们有多少个兄弟姐妹：“我有
    3 个兄弟姐妹。” ➋ 。
- en: '**LOOPING OVER AN ARRAY**'
  id: totrans-2701
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**遍历数组**'
- en: 'Sometimes when you’re working with arrays you might want to do something to
    every item in the array. You can use a for-in loop to do that! The following code
    will print every topping in a pizzaToppings array on a separate line:'
  id: totrans-2702
  prefs: []
  type: TYPE_NORMAL
  zh: 有时在使用数组时，你可能想对数组中的每一项执行某个操作。你可以使用 `for-in` 循环来实现！下面的代码会在每一行打印出 `pizzaToppings`
    数组中的每一个配料：
- en: '![Image](Image00135.jpg)'
  id: totrans-2703
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00135.jpg)'
- en: To write a for-in loop for the pizzaToppings array, we used the keyword for
    , followed by the constant topping , then the keyword in , and finally the name
    of our array, pizzaToppings . Then we put the statements that we want to run for
    each topping inside the braces of the for-in loop. The constant topping ➊ temporarily
    represents each pizza topping in the array as we loop through it. We could have
    chosen any name for this constant, but it’s a good idea to pick something that
    makes sense. You can see the output of this for-in loop in [Figure 6-4](text00016.html#ch06fig4)
    .
  id: totrans-2704
  prefs: []
  type: TYPE_NORMAL
  zh: 为了编写一个针对 `pizzaToppings` 数组的 `for-in` 循环，我们使用了 `for` 关键字，后面跟着常量 `topping` ，然后是
    `in` 关键字，最后是我们的数组名 `pizzaToppings` 。然后，我们将希望在每个配料上执行的语句放在 `for-in` 循环的花括号中。常量
    `topping` ➊ 在我们遍历数组时临时代表每个披萨配料。我们本可以为这个常量选择任何名字，但选择一个有意义的名称是个好主意。你可以在 [图 6-4](text00016.html#ch06fig4)
    中看到这个 `for-in` 循环的输出。
- en: '![Image](Image00136.jpg)'
  id: totrans-2705
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00136.jpg)'
- en: '*Figure 6-4: Output of the example for-in loop*'
  id: totrans-2706
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 6-4：示例 `for-in` 循环的输出*'
- en: '![Image](Image00137.jpg)'
  id: totrans-2707
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00137.jpg)'
- en: 'Using for-in loops is great for printing every value in an array. If you’re
    working with numbers, you can even use them to perform math operations on each
    item, which makes for some speedy calculations! The following code takes an array
    of numbers and calculates the square for each (the square of a number is that
    number multiplied by itself):'
  id: totrans-2708
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `for-in` 循环非常适合打印数组中的每个值。如果你处理的是数字，甚至可以利用它们对每一项进行数学运算，这样可以快速进行计算！下面的代码获取一个数字数组，并计算每个数字的平方（数字的平方是该数字与它自身相乘）：
- en: '![Image](Image00138.jpg)'
  id: totrans-2709
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00138.jpg)'
- en: '[Figure 6-5](text00016.html#ch06fig5) shows the results.'
  id: totrans-2710
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 6-5](text00016.html#ch06fig5) 显示了结果。'
- en: '![Image](Image00139.jpg)'
  id: totrans-2711
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00139.jpg)'
- en: '*Figure 6-5: Printing the squares for each number in the myNumbers array*'
  id: totrans-2712
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 6-5：打印 `myNumbers` 数组中每个数字的平方*'
- en: '**DICTIONARIES ARE KEY!**'
  id: totrans-2713
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**字典是关键！**'
- en: A *dictionary* is also a collection of values, but instead of an ordered index,
    each value has its own *key* . Because there’s no index, the values are not stored
    in any particular order. To access values in a dictionary, you look them up by
    their key.
  id: totrans-2714
  prefs: []
  type: TYPE_NORMAL
  zh: '*字典* 也是一个值的集合，但与数组不同的是，每个值都有自己的 *键* 。因为没有索引，所以值并不按任何特定顺序存储。要访问字典中的值，你需要通过它们的键来查找。'
- en: A key must be unique. You can’t have the same key more than once in the same
    dictionary. If there were two identical keys and you asked the computer to give
    you the value for one of them, the computer wouldn’t know which one to choose!
  id: totrans-2715
  prefs: []
  type: TYPE_NORMAL
  zh: 键必须是唯一的。你不能在同一个字典中有两个相同的键。如果有两个相同的键，而你要求计算机返回其中一个的值，计算机就无法知道选择哪个！
- en: Let’s take a look at how to make a dictionary and write keys that will help
    you find all the information you need.
  id: totrans-2716
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看一下如何创建一个字典，并编写键，以帮助你找到所需的所有信息。
- en: '![Image](Image00140.jpg)'
  id: totrans-2717
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00140.jpg)'
- en: '**INITIALIZING A DICTIONARY**'
  id: totrans-2718
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**初始化字典**'
- en: 'To create and initialize a dictionary, first write var and the name of your
    dictionary. Then write the keys and corresponding values inside a pair of square
    brackets, similar to an array. Let’s create a dictionary to store the names of
    a few US states. The key for each state will be its two-letter abbreviation:'
  id: totrans-2719
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建并初始化一个字典，首先写上 `var` 和字典的名称。然后在一对方括号内写上键和值，类似于数组的写法。让我们创建一个字典来存储一些美国州的名称。每个州的键将是其两字母的缩写：
- en: '![](Image00141.jpg)'
  id: totrans-2720
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00141.jpg)'
- en: As you can see, there’s a colon between each key and its value, and the key/value
    pairs are separated by commas.
  id: totrans-2721
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，每个键和它的值之间有一个冒号，键值对之间用逗号分隔。
- en: Dictionaries are different from arrays in that they are *unordered* . Because
    of that, it’s likely that the order of the states that you see in your results
    pane ➋ is different from the order in which you entered your states ➊ . It might
    even be different than the order that’s printed in this book!
  id: totrans-2722
  prefs: []
  type: TYPE_NORMAL
  zh: 字典与数组的不同之处在于它们是*无序的*。因此，你在结果面板中看到的州的顺序➋很可能与你输入州时的顺序➊不同，甚至可能与本书中打印的顺序不同！
- en: As with arrays, you can use var to make a mutable dictionary or use let to make
    an immutable dictionary.
  id: totrans-2723
  prefs: []
  type: TYPE_NORMAL
  zh: 与数组一样，你可以使用var来创建一个可变字典，或者使用let来创建一个不可变字典。
- en: 'In Swift, all of the keys of a dictionary must be the same type, and all of
    the values of a dictionary must also be the same type, but the key type doesn’t
    have to match the value type. For example, if you wanted to store a collection
    of fractions, you could use doubles for the keys and strings for the values:'
  id: totrans-2724
  prefs: []
  type: TYPE_NORMAL
  zh: 在Swift中，字典的所有键必须是相同的类型，字典的所有值也必须是相同的类型，但键的类型不必与值的类型匹配。例如，如果你想存储一个分数的集合，可以使用双精度数作为键，使用字符串作为值：
- en: '![](Image00142.jpg)'
  id: totrans-2725
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00142.jpg)'
- en: In this dictionary, all of the keys must be doubles, and all of the values must
    be strings. Again, you’ll see that the order of the numbers in the results pane
    can be quite different from the order in which you wrote the fractions in your
    dictionary. This is fine because you don’t need to know the order to access anything.
    You can find any item that you need by its key. Let’s see how!
  id: totrans-2726
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个字典中，所有的键必须是双精度数，所有的值必须是字符串。同样，你会发现结果面板中数字的顺序可能与你在字典中写入分数的顺序大不相同。这没关系，因为你不需要知道顺序就能访问任何项。你可以通过键找到你需要的任何项。让我们看看怎么做！
- en: '**ACCESSING VALUES IN A DICTIONARY**'
  id: totrans-2727
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**访问字典中的值**'
- en: 'Looking up a value in a dictionary is similar to how you access a value in
    an array except that you use a key inside the square brackets instead of an index,
    like this: usStates["TX"] .'
  id: totrans-2728
  prefs: []
  type: TYPE_NORMAL
  zh: 在字典中查找一个值类似于在数组中访问一个值，只是你在方括号中使用的是键，而不是索引，像这样：usStates["TX"]。
- en: There is a big difference, however, in how Swift returns the values from a dictionary.
    When you access a value at an index of an array, you are simply given the value.
    When you access a value with a key in a dictionary, you are given an optional.
  id: totrans-2729
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，Swift从字典中返回值的方式有很大的不同。当你通过数组的索引访问值时，你直接得到值。而当你通过字典中的键访问值时，你得到的是一个可选项。
- en: In [Chapter 5](text00015.html#ch05) , you learned that optionals might contain
    a value or might be nil . The reason Swift returns optionals when you’re looking
    up items in a dictionary is that the key you used might not exist in the dictionary,
    in which case there’s no value to access. Trying to access a value that doesn’t
    exist would give you a big fat error! To avoid that problem, Swift returns optionals.
    That means you need to unwrap any value you get out of a dictionary before you
    can do anything with it.
  id: totrans-2730
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第5章](text00015.html#ch05)中，你学习了可选项可能包含一个值，也可能是nil。Swift在你查找字典中的项时返回可选项的原因是，你使用的键可能在字典中不存在，在这种情况下就没有值可供访问。尝试访问一个不存在的值会导致一个巨大的错误！为避免这个问题，Swift返回可选项。这意味着你需要在使用字典中的值之前解包它。
- en: 'To unwrap an optional, first you check whether it exists using an if-let statement,
    just like we did in [Chapter 5](text00015.html#ch05) . The following code shows
    you how to get a value out of a dictionary:'
  id: totrans-2731
  prefs: []
  type: TYPE_NORMAL
  zh: 要解包一个可选项，首先使用if-let语句检查它是否存在，就像我们在[第5章](text00015.html#ch05)中做的那样。以下代码演示了如何从字典中获取一个值：
- en: '![Image](Image00143.jpg)'
  id: totrans-2732
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00143.jpg)'
- en: To retrieve "Texas" from the dictionary, we use if let to set a constant loneStarState
    to usStates["TX"] ➊ . Because we have this state in our dictionary, the line I
    have Texas in my dictionary. is printed. Next we try to access a state that is
    not in our dictionary by using the key usStates["FL"] ➋ . Thankfully, because
    we used an if-let statement, the program won’t crash when the computer can’t find
    this state. Instead, I don't have that state in my dictionary. is printed.
  id: totrans-2733
  prefs: []
  type: TYPE_NORMAL
  zh: 要从字典中检索“Texas”，我们使用if let将常量loneStarState设置为usStates["TX"] ➊。因为我们在字典中有这个州，所以打印出“I
    have Texas in my dictionary.”接下来，我们尝试通过键usStates["FL"] ➋访问一个不在字典中的州。幸运的是，因为我们使用了if-let语句，当计算机找不到这个州时，程序不会崩溃。相反，打印出“I
    don't have that state in my dictionary.”。
- en: '**ADDING ITEMS TO A DICTIONARY**'
  id: totrans-2734
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**向字典添加项**'
- en: 'To add an item to a dictionary, first write the name of your dictionary and
    assign the new item to the key you want it to have in the dictionary. Let’s add
    "Minnesota" to our usStates dictionary:'
  id: totrans-2735
  prefs: []
  type: TYPE_NORMAL
  zh: 要向字典中添加一个项目，首先写出字典的名称，并将新项分配给你想要它在字典中拥有的键。我们来向我们的 usStates 字典中添加 "Minnesota"：
- en: '![](Image00144.jpg)'
  id: totrans-2736
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00144.jpg)'
- en: 'Now when you look at usStates , you’ll see that it’s updated to ["MN": "Minnesota",
    "WA": "Washington", "MA": "Massachusetts", "TX": "Texas"] . Remember, because
    you don’t have to rely on indices, your new dictionary item might appear anywhere
    in the dictionary.'
  id: totrans-2737
  prefs: []
  type: TYPE_NORMAL
  zh: '现在当你查看 usStates 时，你会看到它已更新为 ["MN": "Minnesota", "WA": "Washington", "MA": "Massachusetts",
    "TX": "Texas"]。记住，因为你不需要依赖索引，所以新添加的字典项可能出现在字典中的任何位置。'
- en: '**REMOVING ITEMS FROM A DICTIONARY**'
  id: totrans-2738
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**从字典中移除项目**'
- en: Removing an item from a dictionary is quite simple; you do so by setting the
    value to nil . Because the values in dictionaries are returned as optionals, you
    don’t have to worry about nil causing any problems in your dictionary.
  id: totrans-2739
  prefs: []
  type: TYPE_NORMAL
  zh: 从字典中移除一个项目非常简单；你只需要将其值设置为 nil 。因为字典中的值是以可选项的形式返回的，所以你不必担心 nil 会在字典中造成任何问题。
- en: '![](Image00145.jpg)'
  id: totrans-2740
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00145.jpg)'
- en: 'You can see that after you remove the value at the key "MA" , usStates is updated
    to ["MN": "Minnesota", "WA": "Washington", "TX": "Texas"] . Remember that nil
    is special and means that there’s no value at all. That’s why you don’t see "MA":
    nil in our dictionary.'
  id: totrans-2741
  prefs: []
  type: TYPE_NORMAL
  zh: '你可以看到，在移除 "MA" 键的值后，usStates 更新为 ["MN": "Minnesota", "WA": "Washington", "TX":
    "Texas"]。记住，nil 是特殊的，意味着根本没有值。因此，你不会在我们的字典中看到 "MA": nil。'
- en: '**REPLACING ITEMS IN A DICTIONARY**'
  id: totrans-2742
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**替换字典中的项目**'
- en: 'Replacing an item in a dictionary is also easy. It works the same was as replacing
    an item in an array. You just set the item that you want to replace to something
    else. Say you create a dictionary of fruit colors:'
  id: totrans-2743
  prefs: []
  type: TYPE_NORMAL
  zh: 替换字典中的项目也很简单。它的工作方式与替换数组中的项目相同。你只需将要替换的项目设置为其他值。假设你创建了一个水果颜色的字典：
- en: '![](Image00146.jpg)'
  id: totrans-2744
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00146.jpg)'
- en: At first we had the value "apple" for "red" , but then we decided that "raspberry"
    is a better fruit to use since sometimes apples are green or yellow. To replace
    "apple" with "raspberry" , we set colorFruits["red"] to its new value ➊ .
  id: totrans-2745
  prefs: []
  type: TYPE_NORMAL
  zh: 起初我们为 "red" 赋值 "apple"，但后来我们决定用 "raspberry" 替代，因为有时候苹果是绿色或黄色的。要将 "apple" 替换为
    "raspberry"，我们将 colorFruits["red"] 设置为其新值 ➊。
- en: You may remember that this is the same way we entered a new value into a dictionary.
    If the key already exists in the dictionary, then the value for that key is replaced.
    If the key doesn’t already exist, then the new key/value pair will be added to
    the dictionary.
  id: totrans-2746
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能还记得，这与我们向字典中输入新值的方式相同。如果键已经存在于字典中，那么该键的值将被替换。如果键不存在，新的键值对将被添加到字典中。
- en: '![Image](Image00147.jpg)'
  id: totrans-2747
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00147.jpg)'
- en: '**USING DICTIONARY PROPERTIES**'
  id: totrans-2748
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**使用字典属性**'
- en: 'Like an array, a dictionary also has an isEmpty property and a count property.
    For example, the following code shows how you can use the isEmpty property to
    check if a dictionary is empty, and if it isn’t empty, the count property checks
    how many items you have. Imagine you have a basket of fruit for sale. You can
    use these properties to help you keep track of everything:'
  id: totrans-2749
  prefs: []
  type: TYPE_NORMAL
  zh: 像数组一样，字典也有一个 isEmpty 属性和一个 count 属性。例如，下面的代码展示了如何使用 isEmpty 属性来检查字典是否为空，如果不为空，则使用
    count 属性检查字典中有多少项。假设你有一个待售的水果篮子，你可以使用这些属性来帮助你跟踪所有物品：
- en: '![Image](Image00148.jpg)'
  id: totrans-2750
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00148.jpg)'
- en: 'A dictionary also has two special properties: keys , which contains all of
    the dictionary’s keys, and values , which contains all of its values. We’ll use
    these two properties when we loop through the dictionary.'
  id: totrans-2751
  prefs: []
  type: TYPE_NORMAL
  zh: 字典还有两个特殊的属性：keys，包含字典的所有键；values，包含字典的所有值。当我们遍历字典时，将使用这两个属性。
- en: Let’s write some code that loops through our fruit baskets and prints the price
    of each fruit.
  id: totrans-2752
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们写一些代码，遍历我们的水果篮子，并打印每种水果的价格。
- en: '**LOOPING OVER A DICTIONARY**'
  id: totrans-2753
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**遍历字典**'
- en: 'You can loop through a dictionary using a for-in loop. Because each item has
    a key and a value, you can do this in two different ways. This is how to loop
    through a dictionary using its keys:'
  id: totrans-2754
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用 for-in 循环来遍历字典。因为每个项目都有一个键和值，所以你可以用两种不同的方式来做到这一点。这是使用字典的键来遍历字典的方法：
- en: '![Image](Image00149.jpg)'
  id: totrans-2755
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00149.jpg)'
- en: Here we use the dictionary’s keys property ➊ to loop through fruitBasket and
    print its contents. We start by writing the keyword for , followed by a constant
    name fruit for the dictionary key, the keyword in , the dictionary name, a period,
    and keys .
  id: totrans-2756
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们使用字典的keys属性 ➊ 来循环遍历fruitBasket并打印其内容。我们首先写出关键字for，接着是字典键的常量名称fruit，关键字in，字典名称，句点和keys。
- en: Inside the braces of our for-in loop, we have access to both the key, which
    we call fruit ➋ , and the value at that key when we force-unwrap its contents
    with fruitBasket[fruit]! ➌ . That value will be the fruit’s price.
  id: totrans-2757
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的for-in循环的大括号内，我们可以访问到键（我们称之为fruit ➋）以及通过强制解包其内容得到的值fruitBasket[fruit]! ➌。这个值就是水果的价格。
- en: In this case, it’s safe to force-unwrap the value using an exclamation point
    because we know that the fruit key we’re using is definitely inside the dictionary.
  id: totrans-2758
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，使用感叹号强制解包值是安全的，因为我们知道正在使用的fruit键肯定在字典中。
- en: Any code we put inside the for-in loop will run once for every key in our dictionary.
    So you should see the print statement display three times.
  id: totrans-2759
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在for-in循环中放入的任何代码都会针对字典中的每一个键执行一次。所以你应该能看到打印语句打印三次。
- en: 'We can also loop through the dictionary using its values property:'
  id: totrans-2760
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以通过字典的values属性来循环遍历：
- en: '![Image](Image00150.jpg)'
  id: totrans-2761
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Image00150.jpg)'
- en: We use the same style of for-in loop, but now we use a constant to refer to
    each value, which we call price , in the values property. When looping through
    values, we don’t have access to the keys from inside the loop.
  id: totrans-2762
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用相同的for-in循环样式，但现在我们使用一个常量来引用values属性中的每个值，我们称之为price。在遍历值时，我们无法从循环内访问键。
- en: Another difference to note is that price is not an optional because it’s accessed
    directly as a value in the fruitBasket dictionary. That means we don’t have to
    unwrap it. You should still see the print statement printed three times. [Figure
    6-6](text00016.html#ch06fig6) shows the output of both loops.
  id: totrans-2763
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个需要注意的区别是，价格不是可选项，因为它直接作为值存储在fruitBasket字典中。这意味着我们不需要解包它。你仍然应该能看到打印语句打印三次。[图6-6](text00016.html#ch06fig6)显示了两个循环的输出。
- en: '![Image](Image00151.jpg)'
  id: totrans-2764
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Image00151.jpg)'
- en: '*Figure 6-6: Looping through the keys and values of a dictionary with a for-in
    loop*'
  id: totrans-2765
  prefs: []
  type: TYPE_NORMAL
  zh: '*图6-6：使用for-in循环遍历字典的键和值*'
- en: The order of your results might be slightly different from ours. That’s because
    the items in a dictionary aren’t in a numbered order like they are in an array!
    And because the order is not guaranteed, you might see a different order printed
    if you run the same code again.
  id: totrans-2766
  prefs: []
  type: TYPE_NORMAL
  zh: 你的结果顺序可能与我们的稍有不同。这是因为字典中的项不像数组那样按编号顺序排列！由于顺序无法保证，如果你再次运行相同的代码，可能会看到不同的顺序。
- en: '**WHAT YOU LEARNED**'
  id: totrans-2767
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**你学到的内容**'
- en: In this chapter, you learned how to store collections of items in an array and
    in a dictionary. To store items in an ordered list, you would use an array and
    look up each item by its index. If you wanted to store items by key instead, you
    would use a dictionary.
  id: totrans-2768
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你学习了如何在数组和字典中存储项目。要在有序列表中存储项目，你会使用数组并通过索引查找每个项目。如果你想根据键来存储项目，你会使用字典。
- en: Knowing about arrays and dictionaries and how to use them is a powerful building
    block for almost any programming language. Next we will learn about functions,
    another very powerful tool. Functions are blocks of code that you create and name
    to perform a specific job. After you have written a function, you can use its
    name to call it from almost anywhere in your program.
  id: totrans-2769
  prefs: []
  type: TYPE_NORMAL
  zh: 了解数组和字典以及如何使用它们，是几乎所有编程语言中非常强大的构建块。接下来，我们将学习函数，这是另一个非常强大的工具。函数是你创建并命名的代码块，用来执行特定的任务。写完一个函数后，你可以在程序中的几乎任何地方调用它。
- en: '![](Image00117.jpg)'
  id: totrans-2770
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00117.jpg)'
- en: Using type inference, Swift knows we initialized this array to hold strings,
    and it can hold only strings.
  id: totrans-2771
  prefs: []
  type: TYPE_NORMAL
  zh: 通过类型推断，Swift知道我们初始化了这个数组来存储字符串，并且它只能存储字符串。
- en: The list of parks that we created the array with is an example of an array *literal*
    . A literal is a value that is exactly what you see. It is not a variable or constant
    but rather just the value without a name. "Grand Canyon" is an example of a string
    literal, and 7 is an example of an integer literal. An array literal is a list
    of items contained between two square brackets and separated by commas, like ["Acadia",
    "Zion", "Grand Canyon"] ➊ .
  id: totrans-2772
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建数组时使用的公园列表就是一个数组 *字面量* 的例子。字面量是指完全符合你所看到的值。它不是变量或常量，而是没有名称的值。 "Grand Canyon"
    是字符串字面量的一个例子，而 7 是整数字面量的一个例子。数组字面量是由两个方括号包围，元素之间用逗号分隔的元素列表，如 ["Acadia", "Zion",
    "Grand Canyon"] ➊。
- en: '**ACCESSING ITEMS IN AN ARRAY**'
  id: totrans-2773
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**访问数组中的元素**'
- en: 'Let’s say you want to access an item in your array and use it in your program.
    Your friend asks you to tell them all about your travels, so you want to use the
    names of the national parks that you stored in the array. To access an item in
    your array, write the array name followed by the item’s index inside square brackets:'
  id: totrans-2774
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你想在程序中访问数组中的某个元素并使用它。你的朋友问你有关你旅行的所有事情，所以你想使用你存储在数组中的国家公园名称。要访问数组中的一个元素，写下数组的名称，后面跟上该元素的索引，索引需要放在方括号中：
- en: '![](Image00118.jpg)'
  id: totrans-2775
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00118.jpg)'
- en: In this example, we are accessing the names of the national parks and then printing
    them to the screen using print . To get the first item in nationalParks , you
    use nationalParks[0] ➊ . To access the second item in nationalParks , you use
    nationalParks[1] .
  id: totrans-2776
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们访问国家公园的名称，然后使用 print 打印到屏幕上。要获取 nationalParks 中的第一个元素，你可以使用 nationalParks[0]
    ➊。要访问 nationalParks 中的第二个元素，你可以使用 nationalParks[1]。
- en: '**WATCHING THE RANGE**'
  id: totrans-2777
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**观察范围**'
- en: One important point about arrays is that if you try to access an item at an
    index that’s higher than the last index in the array, you’ll get an error. In
    [Figure 6-2](text00016.html#ch06fig2) , you can see that nationalParks[3] (which
    would be the fourth item in the array) gives you an error because there are only
    three national parks in the array, indexed from 0 to 2.
  id: totrans-2778
  prefs: []
  type: TYPE_NORMAL
  zh: 关于数组，有一点很重要：如果你尝试访问数组中某个索引大于最后一个索引的元素，你会得到一个错误。在 [图 6-2](text00016.html#ch06fig2)
    中，你可以看到 nationalParks[3]（这将是数组中的第四个元素）会给你一个错误，因为数组中只有三个国家公园，索引范围是从 0 到 2。
- en: As you can see, you get an error message that says Index out of range . If you
    try to access an item that doesn’t exist in your array, your app will crash!
  id: totrans-2779
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，你会收到一条错误信息，显示 “Index out of range”（索引超出范围）。如果你尝试访问一个数组中不存在的元素，你的应用程序将崩溃！
- en: '![Image](Image00119.jpg)'
  id: totrans-2780
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00119.jpg)'
- en: '*Figure 6-2: Trying to access an index in the array where nothing exists causes
    an error.*'
  id: totrans-2781
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 6-2：尝试访问数组中不存在元素的索引会导致错误。*'
- en: '**ADDING ITEMS TO AN ARRAY**'
  id: totrans-2782
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**向数组添加元素**'
- en: One way to change an array is to add new items to it. There are a few different
    ways to do this, so let’s take a look at each.
  id: totrans-2783
  prefs: []
  type: TYPE_NORMAL
  zh: 更改数组的一种方式是向其中添加新元素。有几种不同的方法来实现这一点，让我们来看看每种方法。
- en: 'First, you can use an array’s append(_:) method. *Append* means to add something.
    Using append(_:) , you can add one new item to the end of your array. Say you
    go on another trip and visit the Badlands, and you want to add it to your list
    of national parks. To do that, add this code into your playground:'
  id: totrans-2784
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，你可以使用数组的 append(_:) 方法。*Append* 的意思是添加某个东西。使用 append(_:)，你可以向数组的末尾添加一个新元素。假设你又去了一次旅行，参观了恶地，你想把它添加到你的国家公园列表中。要做到这一点，可以将以下代码添加到你的
    Playground 中：
- en: '![](Image00120.jpg)'
  id: totrans-2785
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00120.jpg)'
- en: To use the append(_:) method, first write the name of your array followed by
    a period and then append . Then, put the item you want to add to your array inside
    the parentheses. In this case, you put "Badlands" inside the parentheses.
  id: totrans-2786
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用 append(_:) 方法，首先写下你的数组名称，后面跟一个句点，然后是 append。接着，将你想要添加到数组中的元素放在括号内。在这个例子中，你将
    "Badlands" 放入括号中。
- en: 'If you want to add something at a specific place in your array, use the array’s
    insert(_:at:) method instead. This method takes two arguments: the item that you
    want to insert and the index of where it should go in the array. (We’ll discuss
    arguments in more detail in [Chapter 7](text00017.html#ch07) .)'
  id: totrans-2787
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想在数组的特定位置添加某个元素，可以使用数组的 insert(_:at:) 方法。这个方法接受两个参数：你想要插入的元素和它在数组中应该放置的位置的索引。（我们将在
    [第 7 章](text00017.html#ch07) 中更详细地讨论参数。）
- en: 'Let’s say you totally forgot that you went to the Petrified Forest right after
    you visited the Grand Canyon, and you want to update your nationalParks array
    so it displays the parks in the order in which you visited them. To update your
    array, you could use the insert(_:at:) method to put the Petrified Forest in the
    right position:'
  id: totrans-2788
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你完全忘记了你在参观大峡谷之后去了化石森林，并且你想更新你的 nationalParks 数组，以按照你访问的顺序显示这些公园。为了更新数组，你可以使用
    insert(_:at:) 方法将化石森林放到正确的位置：
- en: '![](Image00121.jpg)'
  id: totrans-2789
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00121.jpg)'
- en: When you insert a new item at index 3, everything that was in the array at index
    3 or higher gets scooted over to make room for the new item. That means the item
    that was at index 3 is now at index 4, the item that was at index 4 is now at
    index 5, and so on. After you add the Petrified Forest, nationalParks is now ["Acadia",
    "Zion", "Grand Canyon", "Petrified Forest", "Badlands"] .
  id: totrans-2790
  prefs: []
  type: TYPE_NORMAL
  zh: 当你在索引3的位置插入一个新项时，原本在索引3或更高位置的所有项都会向后移动，以腾出空间给新项。这意味着原本在索引3的项现在移到索引4，原本在索引4的项移到索引5，以此类推。添加化石森林后，nationalParks
    数组现在是 ["Acadia", "Zion", "Grand Canyon", "Petrified Forest", "Badlands"]。
- en: '**COMBINING ARRAYS**'
  id: totrans-2791
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**合并数组**'
- en: 'Not only can you add new items to an array, but you can also add two arrays
    together using the + and += operators. Let’s say that you have the ingredients
    for a fruit smoothie in two arrays:'
  id: totrans-2792
  prefs: []
  type: TYPE_NORMAL
  zh: 不仅可以向数组中添加新项，还可以使用 + 和 += 操作符将两个数组合并。假设你有两个数组，分别包含制作水果奶昔的配料：
- en: '![](Image00122.jpg)'
  id: totrans-2793
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00122.jpg)'
- en: Now you can make a delicious smoothie by adding the fruits and liquids arrays.
  id: totrans-2794
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你可以通过将水果和液体数组添加在一起，制作一杯美味的奶昔。
- en: '![](Image00123.jpg)'
  id: totrans-2795
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00123.jpg)'
- en: The order of the ingredients in smoothie is the same as the order in fruits
    and liquids . If you created smoothie with liquids + fruits , then the liquids
    would come first.
  id: totrans-2796
  prefs: []
  type: TYPE_NORMAL
  zh: 奶昔中的配料顺序与水果和液体的顺序相同。如果你用液体 + 水果来制作奶昔，那么液体应该先加进去。
- en: 'You use the += operator to add an array to the end of your array. Add some
    whipped cream as follows for extra yumminess:'
  id: totrans-2797
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用 += 操作符将一个数组添加到另一个数组的末尾。为了增加一些美味的奶油，可以按如下方式添加一些搅打奶油：
- en: '![](Image00124.jpg)'
  id: totrans-2798
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00124.jpg)'
- en: Note that ["whipped cream"] is an array even though it has a single item in
    it. When you’re using += to append something to an array, you have to make sure
    you’re only trying to add another array. If you were to just write the string
    "whipped cream" without the square brackets around it, you would get an error.
  id: totrans-2799
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，["whipped cream"]是一个数组，尽管它里面只有一个元素。当你使用 += 向数组添加内容时，必须确保你只是在尝试添加另一个数组。如果你只是写了字符串"whipped
    cream"，而没有加上方括号，程序会报错。
- en: '![Image](Image00125.jpg)'
  id: totrans-2800
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00125.jpg)'
- en: '**REMOVING ITEMS FROM AN ARRAY**'
  id: totrans-2801
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**从数组中删除项**'
- en: 'There are several methods for removing items from an array. Let’s start by
    looking at the array’s removeLast() method. As you might have guessed from its
    name, removeLast() removes the last item from your array. Let’s try it out with
    a shoppingList array:'
  id: totrans-2802
  prefs: []
  type: TYPE_NORMAL
  zh: 删除数组中项有多种方法。首先我们来看一下数组的 removeLast() 方法。顾名思义，removeLast() 会删除数组中的最后一项。让我们用一个
    shoppingList 数组试一下：
- en: '![](Image00126.jpg)'
  id: totrans-2803
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00126.jpg)'
- en: Neat! Note that the removeLast() method returns the removed item, so you can
    store it in a new constant or variable if you want.
  id: totrans-2804
  prefs: []
  type: TYPE_NORMAL
  zh: 太棒了！注意，removeLast() 方法会返回删除的项，因此，如果需要，你可以将它存储到一个新的常量或变量中。
- en: 'You can also remove an item from a specific index by using the remove(at:)
    method. Let’s say that your mom doesn’t want you buying any candy and takes that
    off the list:'
  id: totrans-2805
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以使用 remove(at:) 方法从特定的索引删除一项。假设你妈妈不希望你买糖果，并把它从购物清单中删除：
- en: '![Image](Image00127.jpg)![](Image00128.jpg)'
  id: totrans-2806
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00127.jpg)![](Image00128.jpg)'
- en: Just like when we added an item to the middle of our array and all the items
    scooted over to make room, if you remove an item from the middle of an array,
    the rest of the items will scoot back to fill in that empty space. The "apples"
    item that was at index 3 is now at index 2, where "candy" was.
  id: totrans-2807
  prefs: []
  type: TYPE_NORMAL
  zh: 就像我们在数组中间添加一个项并且所有项会向后挪动腾出空间一样，如果你从数组中间删除一个项，剩余的项会自动挪回去填补那个空位。原本在索引3的位置的"apples"项现在位于索引2的位置，那里原本是"candy"。
- en: 'You can also remove all items from an array with removeAll() . Try entering
    this into your playground:'
  id: totrans-2808
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以使用 removeAll() 方法从数组中删除所有项。试着在你的 Playground 中输入这个：
- en: '![](Image00129.jpg)'
  id: totrans-2809
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00129.jpg)'
- en: 'Note that trying to remove an item at an index that doesn’t exist will give
    you an error:'
  id: totrans-2810
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，尝试删除一个不存在的索引位置的项会导致错误：
- en: '![](Image00130.jpg)'
  id: totrans-2811
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00130.jpg)'
- en: Our array doesn’t have this many items (in fact, now it’s empty!), so this throws
    an error. We’ll also get an error if we use removeLast() on our empty array, because
    there’s nothing in it—there’s no last index at all! However, removeAll() is always
    safe to use, even on an empty array.
  id: totrans-2812
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的数组没有这么多项（实际上，现在它是空的！），所以这会抛出一个错误。如果我们在空数组上使用 removeLast()，也会发生错误，因为数组中没有任何内容——根本没有最后一个索引！然而，removeAll()
    是始终安全的，即使在空数组上也能使用。
- en: '**REPLACING ITEMS IN AN ARRAY**'
  id: totrans-2813
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**替换数组中的项**'
- en: 'To replace an item in an array, you set the index of the array to the new value,
    as shown here:'
  id: totrans-2814
  prefs: []
  type: TYPE_NORMAL
  zh: 要替换数组中的项，你可以将数组的索引设置为新值，如下所示：
- en: '![](Image00131.jpg)'
  id: totrans-2815
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00131.jpg)'
- en: At ➊ , we replaced the item at index 2 (the third item) with "Unicorn" because
    magical animals count as favorite animals, too! At ➋ , we replaced the item at
    index 0 (the first item) with "Bearded dragon" . No, that’s not a real dragon—it’s
    just a lizard!
  id: totrans-2816
  prefs: []
  type: TYPE_NORMAL
  zh: 在 ➊ ，我们将索引为 2（第三个项）的项替换为 "Unicorn"（独角兽），因为魔法动物也算作最喜欢的动物！在 ➋ ，我们将索引为 0（第一个项）的项替换为
    "Bearded dragon"（胡须龙）。不，那不是一条真正的龙——它只是一个蜥蜴！
- en: Like any time you’re working with array index numbers, you have to be sure an
    item exists in the array at that index before you change its value, or you will
    get an Index out of range error.
  id: totrans-2817
  prefs: []
  type: TYPE_NORMAL
  zh: 就像每次操作数组索引时一样，你必须确保在更改数组某个索引的值之前，该索引处确实有项，否则你会遇到索引越界错误。
- en: '[Figure 6-3](text00016.html#ch06fig3) shows the error that occurs if you try
    to add "Standard poodle" using favoriteAnimals[3] = "Standard poodle" . To add
    an item to the end of an array, you should use the append(_:) method or += , as
    we covered in “[Adding Items to an Array](text00016.html#ch06lev2sec5) ” on [page
    70](text00016.html#page_70) .'
  id: totrans-2818
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 6-3](text00016.html#ch06fig3) 显示了如果你尝试使用 favoriteAnimals[3] = "Standard
    poodle" 来添加 "Standard poodle" 时发生的错误。要将项添加到数组的末尾，应该使用 append(_:) 方法或 += ，如我们在
    “[向数组添加项](text00016.html#ch06lev2sec5)” 第 70 页中所讨论的那样。'
- en: '![Image](Image00132.jpg)'
  id: totrans-2819
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00132.jpg)'
- en: '*Figure 6-3: Don’t try to replace a value at an index beyond the existing array.*'
  id: totrans-2820
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 6-3：不要尝试替换超出现有数组索引的值。*'
- en: Now you know how to change arrays however you might need to. You can add items,
    take items away, or replace items. Next, we’ll look at how to use the properties
    of arrays to find out even more information about them.
  id: totrans-2821
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你知道如何根据需要更改数组了。你可以添加项、删除项或替换项。接下来，我们将了解如何使用数组的属性来获取更多有关它们的信息。
- en: '![Image](Image00133.jpg)'
  id: totrans-2822
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00133.jpg)'
- en: '**USING ARRAY PROPERTIES**'
  id: totrans-2823
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**使用数组属性**'
- en: In addition to methods like append(_:) and removeLast() , arrays also have *properties*
    . An array’s properties are variables or constants that contain some information
    about the array. Two really helpful properties that you might use are the Boolean
    property isEmpty and the integer property count .
  id: totrans-2824
  prefs: []
  type: TYPE_NORMAL
  zh: 除了像 append(_:) 和 removeLast() 这样的 方法，数组还有 *属性*。数组的属性是包含有关数组信息的变量或常量。你可能会用到的两个非常有用的属性是布尔属性
    isEmpty 和整数属性 count。
- en: The isEmpty property is true or false depending on whether the array is empty,
    and the count property will tell you how many items are in that array.
  id: totrans-2825
  prefs: []
  type: TYPE_NORMAL
  zh: isEmpty 属性的值为 true 或 false，取决于数组是否为空，而 count 属性则会告诉你数组中有多少个项。
- en: 'Check out how these two properties are used in the following if-else statement:'
  id: totrans-2826
  prefs: []
  type: TYPE_NORMAL
  zh: 查看下面的 if-else 语句中如何使用这两个属性：
- en: '![Image](Image00134.jpg)'
  id: totrans-2827
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00134.jpg)'
- en: 'This if-else statement checks whether the array mySiblings is empty ➊ . If
    it is, then "I don''t have any siblings." is printed. But if there is something
    in the array, then the number of siblings that we have is printed: "I have 3 siblings."
    ➋ .'
  id: totrans-2828
  prefs: []
  type: TYPE_NORMAL
  zh: 这个 if-else 语句检查数组 mySiblings 是否为空 ➊ 。如果是，它会打印 "我没有兄弟姐妹"。如果数组中有内容，则会打印我们有几个兄弟姐妹："我有
    3 个兄弟姐妹。" ➋ 。
- en: '**LOOPING OVER AN ARRAY**'
  id: totrans-2829
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**遍历数组**'
- en: 'Sometimes when you’re working with arrays you might want to do something to
    every item in the array. You can use a for-in loop to do that! The following code
    will print every topping in a pizzaToppings array on a separate line:'
  id: totrans-2830
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，当你操作数组时，可能希望对数组中的每一项执行某些操作。你可以使用 for-in 循环来实现！以下代码将会逐行打印 pizzaToppings 数组中的每个配料：
- en: '![Image](Image00135.jpg)'
  id: totrans-2831
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00135.jpg)'
- en: To write a for-in loop for the pizzaToppings array, we used the keyword for
    , followed by the constant topping , then the keyword in , and finally the name
    of our array, pizzaToppings . Then we put the statements that we want to run for
    each topping inside the braces of the for-in loop. The constant topping ➊ temporarily
    represents each pizza topping in the array as we loop through it. We could have
    chosen any name for this constant, but it’s a good idea to pick something that
    makes sense. You can see the output of this for-in loop in [Figure 6-4](text00016.html#ch06fig4)
    .
  id: totrans-2832
  prefs: []
  type: TYPE_NORMAL
  zh: 要为 `pizzaToppings` 数组编写一个 for-in 循环，我们使用关键字 for ，后跟常量 topping ，然后是关键字 in ，最后是我们的数组名称
    pizzaToppings 。然后，我们将希望对每个 topping 执行的语句放入 for-in 循环的大括号中。常量 topping ➊ 临时代表我们在循环中访问的数组中的每个比萨配料。我们可以为这个常量选择任何名称，但选择一个有意义的名称是个好主意。你可以在[图
    6-4](text00016.html#ch06fig4)中看到这个 for-in 循环的输出。
- en: '![Image](Image00136.jpg)'
  id: totrans-2833
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00136.jpg)'
- en: '*Figure 6-4: Output of the example for-in loop*'
  id: totrans-2834
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 6-4：示例 for-in 循环的输出*'
- en: '![Image](Image00137.jpg)'
  id: totrans-2835
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00137.jpg)'
- en: 'Using for-in loops is great for printing every value in an array. If you’re
    working with numbers, you can even use them to perform math operations on each
    item, which makes for some speedy calculations! The following code takes an array
    of numbers and calculates the square for each (the square of a number is that
    number multiplied by itself):'
  id: totrans-2836
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 for-in 循环非常适合打印数组中的每个值。如果你正在处理数字，还可以使用它们对每个项目执行数学运算，这样就能进行快速的计算！以下代码获取一个数字数组，并计算每个数字的平方（一个数字的平方是该数字与自身相乘）：
- en: '![Image](Image00138.jpg)'
  id: totrans-2837
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00138.jpg)'
- en: '[Figure 6-5](text00016.html#ch06fig5) shows the results.'
  id: totrans-2838
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 6-5](text00016.html#ch06fig5)显示了结果。'
- en: '![Image](Image00139.jpg)'
  id: totrans-2839
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00139.jpg)'
- en: '*Figure 6-5: Printing the squares for each number in the myNumbers array*'
  id: totrans-2840
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 6-5：打印 myNumbers 数组中每个数字的平方*'
- en: '**DICTIONARIES ARE KEY!**'
  id: totrans-2841
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**字典至关重要！**'
- en: A *dictionary* is also a collection of values, but instead of an ordered index,
    each value has its own *key* . Because there’s no index, the values are not stored
    in any particular order. To access values in a dictionary, you look them up by
    their key.
  id: totrans-2842
  prefs: []
  type: TYPE_NORMAL
  zh: '*字典*也是一种值的集合，但与有序索引不同，每个值都有自己的*键*。由于没有索引，值不会按特定顺序存储。要访问字典中的值，你需要通过它们的键来查找。'
- en: A key must be unique. You can’t have the same key more than once in the same
    dictionary. If there were two identical keys and you asked the computer to give
    you the value for one of them, the computer wouldn’t know which one to choose!
  id: totrans-2843
  prefs: []
  type: TYPE_NORMAL
  zh: 键必须是唯一的。在同一个字典中不能有相同的键。如果有两个相同的键，并且你要求计算机给出其中一个的值，计算机将不知道该选择哪一个！
- en: Let’s take a look at how to make a dictionary and write keys that will help
    you find all the information you need.
  id: totrans-2844
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如何创建字典并编写键，以帮助你找到所有所需的信息。
- en: '![Image](Image00140.jpg)'
  id: totrans-2845
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00140.jpg)'
- en: '**INITIALIZING A DICTIONARY**'
  id: totrans-2846
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**初始化字典**'
- en: 'To create and initialize a dictionary, first write var and the name of your
    dictionary. Then write the keys and corresponding values inside a pair of square
    brackets, similar to an array. Let’s create a dictionary to store the names of
    a few US states. The key for each state will be its two-letter abbreviation:'
  id: totrans-2847
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建和初始化字典，首先写 var 和字典的名称。然后在一对方括号内写入键及其对应的值，类似于数组。我们来创建一个字典来存储一些美国州的名称。每个州的键将是它的两位字母缩写：
- en: '![](Image00141.jpg)'
  id: totrans-2848
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00141.jpg)'
- en: As you can see, there’s a colon between each key and its value, and the key/value
    pairs are separated by commas.
  id: totrans-2849
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，每个键和值之间有一个冒号，键值对之间用逗号分隔。
- en: Dictionaries are different from arrays in that they are *unordered* . Because
    of that, it’s likely that the order of the states that you see in your results
    pane ➋ is different from the order in which you entered your states ➊ . It might
    even be different than the order that’s printed in this book!
  id: totrans-2850
  prefs: []
  type: TYPE_NORMAL
  zh: 字典与数组不同，因为它们是*无序的*。因此，你在结果窗格中看到的州的顺序 ➋ 可能与输入州的顺序 ➊ 不同。它甚至可能与本书中打印的顺序不同！
- en: As with arrays, you can use var to make a mutable dictionary or use let to make
    an immutable dictionary.
  id: totrans-2851
  prefs: []
  type: TYPE_NORMAL
  zh: 与数组一样，你可以使用 var 来创建可变字典，或使用 let 来创建不可变字典。
- en: 'In Swift, all of the keys of a dictionary must be the same type, and all of
    the values of a dictionary must also be the same type, but the key type doesn’t
    have to match the value type. For example, if you wanted to store a collection
    of fractions, you could use doubles for the keys and strings for the values:'
  id: totrans-2852
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Swift 中，字典的所有键必须是相同类型的，字典的所有值也必须是相同类型的，但键的类型不必与值的类型匹配。例如，如果你想存储一个分数集合，你可以使用双精度浮点数作为键，字符串作为值：
- en: '![](Image00142.jpg)'
  id: totrans-2853
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00142.jpg)'
- en: In this dictionary, all of the keys must be doubles, and all of the values must
    be strings. Again, you’ll see that the order of the numbers in the results pane
    can be quite different from the order in which you wrote the fractions in your
    dictionary. This is fine because you don’t need to know the order to access anything.
    You can find any item that you need by its key. Let’s see how!
  id: totrans-2854
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个字典中，所有的键必须是双精度浮点数（doubles），所有的值必须是字符串（strings）。再一次，你会看到结果窗格中的数字顺序可能与字典中分数的书写顺序完全不同。这是可以接受的，因为你不需要知道顺序就能访问任何内容。你可以通过键来找到你需要的任何项。我们来看一下如何操作！
- en: '**ACCESSING VALUES IN A DICTIONARY**'
  id: totrans-2855
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**访问字典中的值**'
- en: 'Looking up a value in a dictionary is similar to how you access a value in
    an array except that you use a key inside the square brackets instead of an index,
    like this: usStates["TX"] .'
  id: totrans-2856
  prefs: []
  type: TYPE_NORMAL
  zh: 在字典中查找一个值的方式类似于你在数组中访问一个值，只不过你在方括号内使用的是键而不是索引，比如：usStates["TX"]。
- en: There is a big difference, however, in how Swift returns the values from a dictionary.
    When you access a value at an index of an array, you are simply given the value.
    When you access a value with a key in a dictionary, you are given an optional.
  id: totrans-2857
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，Swift 在从字典返回值的方式上有一个显著的区别。当你通过数组的索引访问一个值时，你只是得到了这个值。而当你通过字典中的键访问一个值时，你得到的是一个可选值（optional）。
- en: In [Chapter 5](text00015.html#ch05) , you learned that optionals might contain
    a value or might be nil . The reason Swift returns optionals when you’re looking
    up items in a dictionary is that the key you used might not exist in the dictionary,
    in which case there’s no value to access. Trying to access a value that doesn’t
    exist would give you a big fat error! To avoid that problem, Swift returns optionals.
    That means you need to unwrap any value you get out of a dictionary before you
    can do anything with it.
  id: totrans-2858
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第5章](text00015.html#ch05)中，你学习了可选值可能包含一个值，也可能是 nil。Swift 返回可选值的原因是，在你查找字典中的项时，使用的键可能在字典中不存在，在这种情况下就没有值可以访问。尝试访问一个不存在的值会导致一个大错误！为了避免这个问题，Swift
    返回了可选值。这意味着在你使用字典中的任何值之前，你需要先解包它。
- en: 'To unwrap an optional, first you check whether it exists using an if-let statement,
    just like we did in [Chapter 5](text00015.html#ch05) . The following code shows
    you how to get a value out of a dictionary:'
  id: totrans-2859
  prefs: []
  type: TYPE_NORMAL
  zh: 要解包一个可选值，首先你要使用 if-let 语句检查它是否存在，就像我们在[第5章](text00015.html#ch05)中做的那样。以下代码展示了如何从字典中获取一个值：
- en: '![Image](Image00143.jpg)'
  id: totrans-2860
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00143.jpg)'
- en: To retrieve "Texas" from the dictionary, we use if let to set a constant loneStarState
    to usStates["TX"] ➊ . Because we have this state in our dictionary, the line I
    have Texas in my dictionary. is printed. Next we try to access a state that is
    not in our dictionary by using the key usStates["FL"] ➋ . Thankfully, because
    we used an if-let statement, the program won’t crash when the computer can’t find
    this state. Instead, I don't have that state in my dictionary. is printed.
  id: totrans-2861
  prefs: []
  type: TYPE_NORMAL
  zh: 为了从字典中检索 "Texas"，我们使用 if-let 语句将常量 loneStarState 设置为 usStates["TX"] ➊。因为我们在字典中有这个州，所以会打印出
    "我在字典中有德克萨斯州"。接着我们尝试通过使用键 usStates["FL"] ➋ 访问一个不在字典中的州。幸运的是，由于我们使用了 if-let 语句，当计算机找不到这个州时，程序不会崩溃。相反，会打印出
    "我在字典中没有这个州"。
- en: '**ADDING ITEMS TO A DICTIONARY**'
  id: totrans-2862
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**向字典添加项**'
- en: 'To add an item to a dictionary, first write the name of your dictionary and
    assign the new item to the key you want it to have in the dictionary. Let’s add
    "Minnesota" to our usStates dictionary:'
  id: totrans-2863
  prefs: []
  type: TYPE_NORMAL
  zh: 要向字典中添加一个项，首先写出字典的名称，并将新项分配给你希望它在字典中拥有的键。我们来向我们的 usStates 字典中添加 "Minnesota"：
- en: '![](Image00144.jpg)'
  id: totrans-2864
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00144.jpg)'
- en: 'Now when you look at usStates , you’ll see that it’s updated to ["MN": "Minnesota",
    "WA": "Washington", "MA": "Massachusetts", "TX": "Texas"] . Remember, because
    you don’t have to rely on indices, your new dictionary item might appear anywhere
    in the dictionary.'
  id: totrans-2865
  prefs: []
  type: TYPE_NORMAL
  zh: '现在，当你查看 usStates 时，你会看到它已更新为 ["MN": "Minnesota", "WA": "Washington", "MA":
    "Massachusetts", "TX": "Texas"]。记住，因为你不需要依赖索引，你的新字典项可能出现在字典中的任何位置。'
- en: '**REMOVING ITEMS FROM A DICTIONARY**'
  id: totrans-2866
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**从字典移除项**'
- en: Removing an item from a dictionary is quite simple; you do so by setting the
    value to nil . Because the values in dictionaries are returned as optionals, you
    don’t have to worry about nil causing any problems in your dictionary.
  id: totrans-2867
  prefs: []
  type: TYPE_NORMAL
  zh: 从字典中移除一项非常简单；你只需将该值设置为`nil`。由于字典中的值是作为可选值返回的，因此你不必担心`nil`会在字典中引起任何问题。
- en: '![](Image00145.jpg)'
  id: totrans-2868
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00145.jpg)'
- en: 'You can see that after you remove the value at the key "MA" , usStates is updated
    to ["MN": "Minnesota", "WA": "Washington", "TX": "Texas"] . Remember that nil
    is special and means that there’s no value at all. That’s why you don’t see "MA":
    nil in our dictionary.'
  id: totrans-2869
  prefs: []
  type: TYPE_NORMAL
  zh: '你可以看到，在移除"MA"键的值后，`usStates`被更新为["MN": "Minnesota", "WA": "Washington", "TX":
    "Texas"]。记住，`nil`是特殊的，表示根本没有值。因此，你不会在字典中看到"MA": nil。'
- en: '**REPLACING ITEMS IN A DICTIONARY**'
  id: totrans-2870
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**替换字典中的项**'
- en: 'Replacing an item in a dictionary is also easy. It works the same was as replacing
    an item in an array. You just set the item that you want to replace to something
    else. Say you create a dictionary of fruit colors:'
  id: totrans-2871
  prefs: []
  type: TYPE_NORMAL
  zh: 替换字典中的项也很简单。它的操作方式与替换数组中的项相同。你只需将你要替换的项设置为其他值。比如你创建了一个水果颜色的字典：
- en: '![](Image00146.jpg)'
  id: totrans-2872
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00146.jpg)'
- en: At first we had the value "apple" for "red" , but then we decided that "raspberry"
    is a better fruit to use since sometimes apples are green or yellow. To replace
    "apple" with "raspberry" , we set colorFruits["red"] to its new value ➊ .
  id: totrans-2873
  prefs: []
  type: TYPE_NORMAL
  zh: 起初我们为"red"设置了"apple"的值，但后来我们决定"raspberry"是更好的水果，因为有时候苹果是绿色或黄色的。为了将"apple"替换为"raspberry"，我们将`colorFruits["red"]`设置为新的值
    ➊。
- en: You may remember that this is the same way we entered a new value into a dictionary.
    If the key already exists in the dictionary, then the value for that key is replaced.
    If the key doesn’t already exist, then the new key/value pair will be added to
    the dictionary.
  id: totrans-2874
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能记得，这和我们将新值添加到字典中的方式是一样的。如果字典中已经有这个键，则该键的值会被替换。如果字典中没有这个键，则新的键值对将被添加到字典中。
- en: '![Image](Image00147.jpg)'
  id: totrans-2875
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00147.jpg)'
- en: '**USING DICTIONARY PROPERTIES**'
  id: totrans-2876
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**使用字典属性**'
- en: 'Like an array, a dictionary also has an isEmpty property and a count property.
    For example, the following code shows how you can use the isEmpty property to
    check if a dictionary is empty, and if it isn’t empty, the count property checks
    how many items you have. Imagine you have a basket of fruit for sale. You can
    use these properties to help you keep track of everything:'
  id: totrans-2877
  prefs: []
  type: TYPE_NORMAL
  zh: 类似于数组，字典也有`isEmpty`属性和`count`属性。例如，下面的代码展示了如何使用`isEmpty`属性检查字典是否为空，如果不为空，`count`属性则会显示字典中有多少项。假设你有一个水果销售篮子。你可以使用这些属性来帮助你跟踪所有内容：
- en: '![Image](Image00148.jpg)'
  id: totrans-2878
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00148.jpg)'
- en: 'A dictionary also has two special properties: keys , which contains all of
    the dictionary’s keys, and values , which contains all of its values. We’ll use
    these two properties when we loop through the dictionary.'
  id: totrans-2879
  prefs: []
  type: TYPE_NORMAL
  zh: 一个字典还有两个特殊属性：`keys`，它包含字典的所有键；以及`values`，它包含字典的所有值。我们将在遍历字典时使用这两个属性。
- en: Let’s write some code that loops through our fruit baskets and prints the price
    of each fruit.
  id: totrans-2880
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们编写一些代码，遍历我们的果篮并打印每个水果的价格。
- en: '**LOOPING OVER A DICTIONARY**'
  id: totrans-2881
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**遍历字典**'
- en: 'You can loop through a dictionary using a for-in loop. Because each item has
    a key and a value, you can do this in two different ways. This is how to loop
    through a dictionary using its keys:'
  id: totrans-2882
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用`for-in`循环遍历字典。由于每个项都有一个键和值，因此你可以通过两种不同的方式来遍历字典。这是使用字典的键遍历字典的方式：
- en: '![Image](Image00149.jpg)'
  id: totrans-2883
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00149.jpg)'
- en: Here we use the dictionary’s keys property ➊ to loop through fruitBasket and
    print its contents. We start by writing the keyword for , followed by a constant
    name fruit for the dictionary key, the keyword in , the dictionary name, a period,
    and keys .
  id: totrans-2884
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们使用字典的键属性 ➊ 来遍历果篮并打印其内容。我们首先写下关键字`for`，后跟字典键的常量名`fruit`，关键字`in`，字典名，句点，以及`keys`。
- en: Inside the braces of our for-in loop, we have access to both the key, which
    we call fruit ➋ , and the value at that key when we force-unwrap its contents
    with fruitBasket[fruit]! ➌ . That value will be the fruit’s price.
  id: totrans-2885
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的`for-in`循环的花括号内，我们可以访问键，我们称之为`fruit` ➋ ，并且可以通过`fruitBasket[fruit]!`强制解包其内容
    ➌ 。该值就是水果的价格。
- en: In this case, it’s safe to force-unwrap the value using an exclamation point
    because we know that the fruit key we’re using is definitely inside the dictionary.
  id: totrans-2886
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，使用感叹号强制解包值是安全的，因为我们知道我们使用的`fruit`键肯定在字典中。
- en: Any code we put inside the for-in loop will run once for every key in our dictionary.
    So you should see the print statement display three times.
  id: totrans-2887
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在 `for-in` 循环中放入的任何代码都会在字典的每个键上执行一次。所以你应该看到 `print` 语句被打印三次。
- en: 'We can also loop through the dictionary using its values property:'
  id: totrans-2888
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以使用字典的 `values` 属性进行循环：
- en: '![Image](Image00150.jpg)'
  id: totrans-2889
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Image00150.jpg)'
- en: We use the same style of for-in loop, but now we use a constant to refer to
    each value, which we call price , in the values property. When looping through
    values, we don’t have access to the keys from inside the loop.
  id: totrans-2890
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用相同的 `for-in` 循环风格，但现在我们使用常量来引用 `values` 属性中的每个值，我们称之为 `price`。在循环遍历值时，我们无法从循环内访问键。
- en: Another difference to note is that price is not an optional because it’s accessed
    directly as a value in the fruitBasket dictionary. That means we don’t have to
    unwrap it. You should still see the print statement printed three times. [Figure
    6-6](text00016.html#ch06fig6) shows the output of both loops.
  id: totrans-2891
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个需要注意的区别是，`price` 不是可选的，因为它是直接作为 `fruitBasket` 字典中的一个值来访问的。这意味着我们不需要解包它。你仍然应该看到
    `print` 语句打印三次。[图 6-6](text00016.html#ch06fig6) 显示了两个循环的输出。
- en: '![Image](Image00151.jpg)'
  id: totrans-2892
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Image00151.jpg)'
- en: '*Figure 6-6: Looping through the keys and values of a dictionary with a for-in
    loop*'
  id: totrans-2893
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 6-6：使用 `for-in` 循环遍历字典的键和值*'
- en: The order of your results might be slightly different from ours. That’s because
    the items in a dictionary aren’t in a numbered order like they are in an array!
    And because the order is not guaranteed, you might see a different order printed
    if you run the same code again.
  id: totrans-2894
  prefs: []
  type: TYPE_NORMAL
  zh: 你的结果顺序可能与我们的略有不同。这是因为字典中的项目不像数组中的那样按编号顺序排列！由于顺序没有保证，如果你再次运行相同的代码，可能会看到不同的顺序。
- en: '**WHAT YOU LEARNED**'
  id: totrans-2895
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**你学到的内容**'
- en: In this chapter, you learned how to store collections of items in an array and
    in a dictionary. To store items in an ordered list, you would use an array and
    look up each item by its index. If you wanted to store items by key instead, you
    would use a dictionary.
  id: totrans-2896
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你学会了如何将一组项目存储在数组和字典中。要将项目存储在有序列表中，你会使用数组，并通过索引查找每个项目。如果你想根据键存储项目，则应使用字典。
- en: Knowing about arrays and dictionaries and how to use them is a powerful building
    block for almost any programming language. Next we will learn about functions,
    another very powerful tool. Functions are blocks of code that you create and name
    to perform a specific job. After you have written a function, you can use its
    name to call it from almost anywhere in your program.
  id: totrans-2897
  prefs: []
  type: TYPE_NORMAL
  zh: 了解数组和字典以及如何使用它们，是几乎所有编程语言中强大的构建块。接下来，我们将学习函数，这是另一个非常强大的工具。函数是你创建并命名的代码块，用来执行特定的任务。在你编写了一个函数之后，你可以通过它的名称在程序的几乎任何地方调用它。
- en: Using type inference, Swift knows we initialized this array to hold strings,
    and it can hold only strings.
  id: totrans-2898
  prefs: []
  type: TYPE_NORMAL
  zh: 通过类型推断，Swift 知道我们初始化了这个数组来保存字符串，并且它只能保存字符串。
- en: The list of parks that we created the array with is an example of an array *literal*
    . A literal is a value that is exactly what you see. It is not a variable or constant
    but rather just the value without a name. "Grand Canyon" is an example of a string
    literal, and 7 is an example of an integer literal. An array literal is a list
    of items contained between two square brackets and separated by commas, like ["Acadia",
    "Zion", "Grand Canyon"] ➊ .
  id: totrans-2899
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建数组的公园列表是数组*字面量*的一个例子。字面量是一个值，它正是你所看到的内容。它不是变量或常量，而仅仅是一个没有名称的值。“大峡谷”是字符串字面量的例子，而
    7 是整数字面量的例子。数组字面量是包含在两个方括号之间并用逗号分隔的项目列表，如 ["Acadia", "Zion", "Grand Canyon"] ➊。
- en: '**ACCESSING ITEMS IN AN ARRAY**'
  id: totrans-2900
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**访问数组中的项目**'
- en: 'Let’s say you want to access an item in your array and use it in your program.
    Your friend asks you to tell them all about your travels, so you want to use the
    names of the national parks that you stored in the array. To access an item in
    your array, write the array name followed by the item’s index inside square brackets:'
  id: totrans-2901
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你想访问数组中的一个项目并在程序中使用它。你的朋友要求你告诉他们所有的旅行经历，因此你想使用存储在数组中的国家公园名称。要访问数组中的一个项目，写出数组名称，后跟该项目的索引，放在方括号中：
- en: '![](Image00118.jpg)'
  id: totrans-2902
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00118.jpg)'
- en: In this example, we are accessing the names of the national parks and then printing
    them to the screen using print . To get the first item in nationalParks , you
    use nationalParks[0] ➊ . To access the second item in nationalParks , you use
    nationalParks[1] .
  id: totrans-2903
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们访问了国家公园的名称，并通过 `print` 函数将它们打印到屏幕上。要获取 `nationalParks` 中的第一个项目，可以使用
    `nationalParks[0]` ➊ 。要访问 `nationalParks` 中的第二个项目，可以使用 `nationalParks[1]`。
- en: '**WATCHING THE RANGE**'
  id: totrans-2904
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**监控范围**'
- en: One important point about arrays is that if you try to access an item at an
    index that’s higher than the last index in the array, you’ll get an error. In
    [Figure 6-2](text00016.html#ch06fig2) , you can see that nationalParks[3] (which
    would be the fourth item in the array) gives you an error because there are only
    three national parks in the array, indexed from 0 to 2.
  id: totrans-2905
  prefs: []
  type: TYPE_NORMAL
  zh: 关于数组的一个重要事项是，如果你尝试访问一个超出数组最后一个索引的项，你会收到一个错误。在[图 6-2](text00016.html#ch06fig2)中，你可以看到
    nationalParks[3]（这将是数组中的第四项）会给你一个错误，因为数组中只有三个国家公园，索引从 0 到 2。
- en: As you can see, you get an error message that says Index out of range . If you
    try to access an item that doesn’t exist in your array, your app will crash!
  id: totrans-2906
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，你会收到一个错误信息，提示“索引超出范围”。如果你尝试访问数组中不存在的项，应用程序将崩溃！
- en: '![Image](Image00119.jpg)'
  id: totrans-2907
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00119.jpg)'
- en: '*Figure 6-2: Trying to access an index in the array where nothing exists causes
    an error.*'
  id: totrans-2908
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 6-2：尝试访问数组中不存在的索引会导致错误。*'
- en: '**ADDING ITEMS TO AN ARRAY**'
  id: totrans-2909
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**向数组添加项**'
- en: One way to change an array is to add new items to it. There are a few different
    ways to do this, so let’s take a look at each.
  id: totrans-2910
  prefs: []
  type: TYPE_NORMAL
  zh: 更改数组的一种方法是向其中添加新项。有几种不同的方法可以做到这一点，下面我们来看看每一种方法。
- en: 'First, you can use an array’s append(_:) method. *Append* means to add something.
    Using append(_:) , you can add one new item to the end of your array. Say you
    go on another trip and visit the Badlands, and you want to add it to your list
    of national parks. To do that, add this code into your playground:'
  id: totrans-2911
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，你可以使用数组的 append(_:) 方法。*Append* 意味着添加某个东西。使用 append(_:) 方法，你可以将一项新项添加到数组的末尾。假设你再次旅行，访问了
    Badlands，并且你想将它添加到你的国家公园列表中。为此，将以下代码添加到你的 playground 中：
- en: '![](Image00120.jpg)'
  id: totrans-2912
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00120.jpg)'
- en: To use the append(_:) method, first write the name of your array followed by
    a period and then append . Then, put the item you want to add to your array inside
    the parentheses. In this case, you put "Badlands" inside the parentheses.
  id: totrans-2913
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 append(_:) 方法时，首先写下数组的名称，后跟一个句点，然后写 append。接着，将你想添加到数组中的项放在括号内。在这个例子中，你把“Badlands”放在括号里。
- en: 'If you want to add something at a specific place in your array, use the array’s
    insert(_:at:) method instead. This method takes two arguments: the item that you
    want to insert and the index of where it should go in the array. (We’ll discuss
    arguments in more detail in [Chapter 7](text00017.html#ch07) .)'
  id: totrans-2914
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想在数组的特定位置添加内容，可以改用数组的 insert(_:at:) 方法。此方法接受两个参数：你想插入的项和它应该放在数组中的索引位置。（我们将在[第
    7 章](text00017.html#ch07)中详细讨论参数。）
- en: 'Let’s say you totally forgot that you went to the Petrified Forest right after
    you visited the Grand Canyon, and you want to update your nationalParks array
    so it displays the parks in the order in which you visited them. To update your
    array, you could use the insert(_:at:) method to put the Petrified Forest in the
    right position:'
  id: totrans-2915
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你完全忘记了在访问大峡谷后去了化石森林，并且你想更新 nationalParks 数组，使其显示你访问国家公园的顺序。为此，你可以使用 insert(_:at:)
    方法将化石森林放入正确的位置：
- en: '![](Image00121.jpg)'
  id: totrans-2916
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00121.jpg)'
- en: When you insert a new item at index 3, everything that was in the array at index
    3 or higher gets scooted over to make room for the new item. That means the item
    that was at index 3 is now at index 4, the item that was at index 4 is now at
    index 5, and so on. After you add the Petrified Forest, nationalParks is now ["Acadia",
    "Zion", "Grand Canyon", "Petrified Forest", "Badlands"] .
  id: totrans-2917
  prefs: []
  type: TYPE_NORMAL
  zh: 当你在索引 3 处插入新项时，数组中索引 3 或更高的所有项都会被向后移动，以便为新项腾出空间。这意味着原本在索引 3 处的项现在会移到索引 4，原本在索引
    4 处的项会移到索引 5，依此类推。添加“化石森林”之后，nationalParks 现在是 ["Acadia", "Zion", "Grand Canyon",
    "Petrified Forest", "Badlands"]。
- en: '**COMBINING ARRAYS**'
  id: totrans-2918
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**合并数组**'
- en: 'Not only can you add new items to an array, but you can also add two arrays
    together using the + and += operators. Let’s say that you have the ingredients
    for a fruit smoothie in two arrays:'
  id: totrans-2919
  prefs: []
  type: TYPE_NORMAL
  zh: 你不仅可以向数组中添加新项，还可以使用 + 和 += 运算符将两个数组合并。假设你有两个数组，分别是水果冰沙的配料：
- en: '![](Image00122.jpg)'
  id: totrans-2920
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00122.jpg)'
- en: Now you can make a delicious smoothie by adding the fruits and liquids arrays.
  id: totrans-2921
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你可以通过添加水果和液体数组来制作美味的冰沙。
- en: '![](Image00123.jpg)'
  id: totrans-2922
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00123.jpg)'
- en: The order of the ingredients in smoothie is the same as the order in fruits
    and liquids . If you created smoothie with liquids + fruits , then the liquids
    would come first.
  id: totrans-2923
  prefs: []
  type: TYPE_NORMAL
  zh: 冰沙配料的顺序与水果和液体数组中的顺序相同。如果你将冰沙与液体 + 水果合并，则液体会先出现。
- en: 'You use the += operator to add an array to the end of your array. Add some
    whipped cream as follows for extra yumminess:'
  id: totrans-2924
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `+=` 运算符可以将一个数组添加到你的数组末尾。为了增加额外的美味，可以按如下方式添加一些打发奶油：
- en: '![](Image00124.jpg)'
  id: totrans-2925
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00124.jpg)'
- en: Note that ["whipped cream"] is an array even though it has a single item in
    it. When you’re using += to append something to an array, you have to make sure
    you’re only trying to add another array. If you were to just write the string
    "whipped cream" without the square brackets around it, you would get an error.
  id: totrans-2926
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，["whipped cream"] 是一个数组，尽管它只有一个项目。当你使用 `+=` 向数组追加内容时，必须确保你只添加另一个数组。如果你直接写
    "whipped cream"（没有方括号），就会出现错误。
- en: '![Image](Image00125.jpg)'
  id: totrans-2927
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00125.jpg)'
- en: '**REMOVING ITEMS FROM AN ARRAY**'
  id: totrans-2928
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**从数组中移除项目**'
- en: 'There are several methods for removing items from an array. Let’s start by
    looking at the array’s removeLast() method. As you might have guessed from its
    name, removeLast() removes the last item from your array. Let’s try it out with
    a shoppingList array:'
  id: totrans-2929
  prefs: []
  type: TYPE_NORMAL
  zh: 有几种方法可以从数组中删除项目。我们先来看一下数组的 `removeLast()` 方法。正如你从名称中可能猜到的那样，`removeLast()` 会删除数组中的最后一个项目。让我们通过一个
    `shoppingList` 数组来试试：
- en: '![](Image00126.jpg)'
  id: totrans-2930
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00126.jpg)'
- en: Neat! Note that the removeLast() method returns the removed item, so you can
    store it in a new constant or variable if you want.
  id: totrans-2931
  prefs: []
  type: TYPE_NORMAL
  zh: 很棒！请注意，`removeLast()` 方法会返回被移除的项目，因此如果你想的话，可以将它存储在一个新的常量或变量中。
- en: 'You can also remove an item from a specific index by using the remove(at:)
    method. Let’s say that your mom doesn’t want you buying any candy and takes that
    off the list:'
  id: totrans-2932
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以通过使用 `remove(at:)` 方法从特定索引移除项目。假设你的妈妈不希望你买任何糖果，并将其从清单中移除：
- en: '![Image](Image00127.jpg)![](Image00128.jpg)'
  id: totrans-2933
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00127.jpg)![](Image00128.jpg)'
- en: Just like when we added an item to the middle of our array and all the items
    scooted over to make room, if you remove an item from the middle of an array,
    the rest of the items will scoot back to fill in that empty space. The "apples"
    item that was at index 3 is now at index 2, where "candy" was.
  id: totrans-2934
  prefs: []
  type: TYPE_NORMAL
  zh: 就像我们在数组中间添加项目时，所有项目会滑动以腾出空间一样，如果你从数组中间移除一个项目，剩下的项目也会滑动回去，填补那个空位。原来位于索引 3 的 "apples"
    项目现在位于索引 2 的位置，即 "candy" 曾经的位置。
- en: 'You can also remove all items from an array with removeAll() . Try entering
    this into your playground:'
  id: totrans-2935
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以通过 `removeAll()` 从数组中移除所有项目。尝试将以下内容输入到你的 Playground 中：
- en: '![](Image00129.jpg)'
  id: totrans-2936
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00129.jpg)'
- en: 'Note that trying to remove an item at an index that doesn’t exist will give
    you an error:'
  id: totrans-2937
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，尝试删除一个不存在的索引位置的项目会给你带来错误：
- en: '![](Image00130.jpg)'
  id: totrans-2938
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00130.jpg)'
- en: Our array doesn’t have this many items (in fact, now it’s empty!), so this throws
    an error. We’ll also get an error if we use removeLast() on our empty array, because
    there’s nothing in it—there’s no last index at all! However, removeAll() is always
    safe to use, even on an empty array.
  id: totrans-2939
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的数组没有这么多的项目（实际上，现在它是空的！），所以这会抛出一个错误。如果我们在空数组上使用 `removeLast()`，也会报错，因为它里面没有任何元素——根本就没有最后一个索引！然而，`removeAll()`
    即使在空数组上使用也总是安全的。
- en: '**REPLACING ITEMS IN AN ARRAY**'
  id: totrans-2940
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**替换数组中的项目**'
- en: 'To replace an item in an array, you set the index of the array to the new value,
    as shown here:'
  id: totrans-2941
  prefs: []
  type: TYPE_NORMAL
  zh: 要替换数组中的一个项目，你只需将数组的索引设置为新值，如下所示：
- en: '![](Image00131.jpg)'
  id: totrans-2942
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00131.jpg)'
- en: At ➊ , we replaced the item at index 2 (the third item) with "Unicorn" because
    magical animals count as favorite animals, too! At ➋ , we replaced the item at
    index 0 (the first item) with "Bearded dragon" . No, that’s not a real dragon—it’s
    just a lizard!
  id: totrans-2943
  prefs: []
  type: TYPE_NORMAL
  zh: 在 ➊ 处，我们将索引 2（第三个项目）的位置替换为 "Unicorn"（独角兽），因为魔法动物也算是最喜欢的动物！在 ➋ 处，我们将索引 0（第一个项目）的位置替换为
    "Bearded dragon"（须龙）。不，那不是一条真正的龙——它只是一只蜥蜴！
- en: Like any time you’re working with array index numbers, you have to be sure an
    item exists in the array at that index before you change its value, or you will
    get an Index out of range error.
  id: totrans-2944
  prefs: []
  type: TYPE_NORMAL
  zh: 和你处理数组索引时的任何情况一样，你必须确保在更改某个值之前，数组中该索引位置有项目，否则会出现索引超出范围的错误。
- en: '[Figure 6-3](text00016.html#ch06fig3) shows the error that occurs if you try
    to add "Standard poodle" using favoriteAnimals[3] = "Standard poodle" . To add
    an item to the end of an array, you should use the append(_:) method or += , as
    we covered in “[Adding Items to an Array](text00016.html#ch06lev2sec5) ” on [page
    70](text00016.html#page_70) .'
  id: totrans-2945
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 6-3](text00016.html#ch06fig3) 显示了如果你尝试使用 `favoriteAnimals[3] = "Standard
    poodle"` 来添加 "Standard poodle" 时发生的错误。要将项目添加到数组的末尾，你应该使用 `append(_:)` 方法或 `+=`，正如我们在
    “[向数组添加项目](text00016.html#ch06lev2sec5)” 一节中提到的，在 [第 70 页](text00016.html#page_70)。'
- en: '![Image](Image00132.jpg)'
  id: totrans-2946
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00132.jpg)'
- en: '*Figure 6-3: Don’t try to replace a value at an index beyond the existing array.*'
  id: totrans-2947
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 6-3：不要尝试替换超出现有数组索引的值。*'
- en: Now you know how to change arrays however you might need to. You can add items,
    take items away, or replace items. Next, we’ll look at how to use the properties
    of arrays to find out even more information about them.
  id: totrans-2948
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经知道如何根据需要更改数组了。你可以添加项目、移除项目或替换项目。接下来，我们将看看如何使用数组的属性来获得更多关于它们的信息。
- en: '![Image](Image00133.jpg)'
  id: totrans-2949
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00133.jpg)'
- en: '**USING ARRAY PROPERTIES**'
  id: totrans-2950
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**使用数组属性**'
- en: In addition to methods like append(_:) and removeLast() , arrays also have *properties*
    . An array’s properties are variables or constants that contain some information
    about the array. Two really helpful properties that you might use are the Boolean
    property isEmpty and the integer property count .
  id: totrans-2951
  prefs: []
  type: TYPE_NORMAL
  zh: 除了像 append(_:) 和 removeLast() 这样的函数，数组还有 *属性*。数组的属性是包含关于数组一些信息的变量或常量。你可能会用到的两个非常有用的属性是布尔类型的
    isEmpty 属性和整数类型的 count 属性。
- en: The isEmpty property is true or false depending on whether the array is empty,
    and the count property will tell you how many items are in that array.
  id: totrans-2952
  prefs: []
  type: TYPE_NORMAL
  zh: isEmpty 属性是布尔值，表示数组是否为空，而 count 属性则会告诉你数组中有多少项。
- en: 'Check out how these two properties are used in the following if-else statement:'
  id: totrans-2953
  prefs: []
  type: TYPE_NORMAL
  zh: 看看在下面的 if-else 语句中如何使用这两个属性：
- en: '![Image](Image00134.jpg)'
  id: totrans-2954
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00134.jpg)'
- en: 'This if-else statement checks whether the array mySiblings is empty ➊ . If
    it is, then "I don''t have any siblings." is printed. But if there is something
    in the array, then the number of siblings that we have is printed: "I have 3 siblings."
    ➋ .'
  id: totrans-2955
  prefs: []
  type: TYPE_NORMAL
  zh: 这个 if-else 语句检查数组 mySiblings 是否为空 ➊。如果为空，则打印 "我没有兄弟姐妹"。但如果数组中有内容，则打印我们有多少个兄弟姐妹：“我有
    3 个兄弟姐妹。” ➋。
- en: '**LOOPING OVER AN ARRAY**'
  id: totrans-2956
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**遍历数组**'
- en: 'Sometimes when you’re working with arrays you might want to do something to
    every item in the array. You can use a for-in loop to do that! The following code
    will print every topping in a pizzaToppings array on a separate line:'
  id: totrans-2957
  prefs: []
  type: TYPE_NORMAL
  zh: 有时在处理数组时，你可能想对数组中的每一项做点什么。你可以使用 for-in 循环来完成！以下代码将会把 pizzaToppings 数组中的每个配料打印到不同的行上：
- en: '![Image](Image00135.jpg)'
  id: totrans-2958
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00135.jpg)'
- en: To write a for-in loop for the pizzaToppings array, we used the keyword for
    , followed by the constant topping , then the keyword in , and finally the name
    of our array, pizzaToppings . Then we put the statements that we want to run for
    each topping inside the braces of the for-in loop. The constant topping ➊ temporarily
    represents each pizza topping in the array as we loop through it. We could have
    chosen any name for this constant, but it’s a good idea to pick something that
    makes sense. You can see the output of this for-in loop in [Figure 6-4](text00016.html#ch06fig4)
    .
  id: totrans-2959
  prefs: []
  type: TYPE_NORMAL
  zh: 要为 pizzaToppings 数组写一个 for-in 循环，我们使用了关键字 for，接着是常量 topping，然后是关键字 in，最后是我们的数组名称
    pizzaToppings。然后我们将希望在每个 topping 上运行的语句放在 for-in 循环的大括号内。常量 topping ➊ 在我们遍历数组时暂时代表数组中的每个披萨配料。我们本可以为这个常量选择任何名称，但最好选择一个有意义的名字。你可以在
    [图 6-4](text00016.html#ch06fig4) 中看到这个 for-in 循环的输出。
- en: '![Image](Image00136.jpg)'
  id: totrans-2960
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00136.jpg)'
- en: '*Figure 6-4: Output of the example for-in loop*'
  id: totrans-2961
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 6-4：示例 for-in 循环的输出*'
- en: '![Image](Image00137.jpg)'
  id: totrans-2962
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00137.jpg)'
- en: 'Using for-in loops is great for printing every value in an array. If you’re
    working with numbers, you can even use them to perform math operations on each
    item, which makes for some speedy calculations! The following code takes an array
    of numbers and calculates the square for each (the square of a number is that
    number multiplied by itself):'
  id: totrans-2963
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 for-in 循环非常适合打印数组中的每个值。如果你在处理数字，你甚至可以用它们对每个项执行数学运算，这样可以进行快速的计算！以下代码取一个数字数组，并计算每个数字的平方（数字的平方是该数字与自身相乘）：
- en: '![Image](Image00138.jpg)'
  id: totrans-2964
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00138.jpg)'
- en: '[Figure 6-5](text00016.html#ch06fig5) shows the results.'
  id: totrans-2965
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 6-5](text00016.html#ch06fig5) 显示了结果。'
- en: '![Image](Image00139.jpg)'
  id: totrans-2966
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00139.jpg)'
- en: '*Figure 6-5: Printing the squares for each number in the myNumbers array*'
  id: totrans-2967
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 6-5：打印 myNumbers 数组中每个数字的平方*'
- en: '**DICTIONARIES ARE KEY!**'
  id: totrans-2968
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**字典是关键！**'
- en: A *dictionary* is also a collection of values, but instead of an ordered index,
    each value has its own *key* . Because there’s no index, the values are not stored
    in any particular order. To access values in a dictionary, you look them up by
    their key.
  id: totrans-2969
  prefs: []
  type: TYPE_NORMAL
  zh: '*字典*也是一种值的集合，但与有序索引不同，每个值都有自己的 *键*。因为没有索引，所以值并不按任何特定顺序存储。要访问字典中的值，你通过它们的键来查找。'
- en: A key must be unique. You can’t have the same key more than once in the same
    dictionary. If there were two identical keys and you asked the computer to give
    you the value for one of them, the computer wouldn’t know which one to choose!
  id: totrans-2970
  prefs: []
  type: TYPE_NORMAL
  zh: 一个键必须是唯一的。你不能在同一个字典中有多个相同的键。如果有两个相同的键，而你要求计算机给你其中一个的值，计算机将无法知道选择哪个！
- en: Let’s take a look at how to make a dictionary and write keys that will help
    you find all the information you need.
  id: totrans-2971
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看如何创建字典并编写键，以便帮助你找到所需的所有信息。
- en: '![Image](Image00140.jpg)'
  id: totrans-2972
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00140.jpg)'
- en: '**INITIALIZING A DICTIONARY**'
  id: totrans-2973
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**初始化字典**'
- en: 'To create and initialize a dictionary, first write var and the name of your
    dictionary. Then write the keys and corresponding values inside a pair of square
    brackets, similar to an array. Let’s create a dictionary to store the names of
    a few US states. The key for each state will be its two-letter abbreviation:'
  id: totrans-2974
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建和初始化一个字典，首先写上 `var` 和字典的名称。然后在一对方括号内写入键和值对，类似于数组。我们来创建一个字典来存储一些美国州的名字。每个州的键将是它的两个字母缩写：
- en: '![](Image00141.jpg)'
  id: totrans-2975
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00141.jpg)'
- en: As you can see, there’s a colon between each key and its value, and the key/value
    pairs are separated by commas.
  id: totrans-2976
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，每个键和值之间有一个冒号，键值对之间用逗号分隔。
- en: Dictionaries are different from arrays in that they are *unordered* . Because
    of that, it’s likely that the order of the states that you see in your results
    pane ➋ is different from the order in which you entered your states ➊ . It might
    even be different than the order that’s printed in this book!
  id: totrans-2977
  prefs: []
  type: TYPE_NORMAL
  zh: 字典与数组不同，因为它们是 *无序的*。因此，在结果面板 ➋ 中显示的州的顺序很可能与输入州的顺序 ➊ 不同。甚至可能与本书中打印的顺序不同！
- en: As with arrays, you can use var to make a mutable dictionary or use let to make
    an immutable dictionary.
  id: totrans-2978
  prefs: []
  type: TYPE_NORMAL
  zh: 和数组一样，你可以使用 `var` 来创建一个可变字典，或者使用 `let` 来创建一个不可变字典。
- en: 'In Swift, all of the keys of a dictionary must be the same type, and all of
    the values of a dictionary must also be the same type, but the key type doesn’t
    have to match the value type. For example, if you wanted to store a collection
    of fractions, you could use doubles for the keys and strings for the values:'
  id: totrans-2979
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Swift 中，字典的所有键必须是相同类型的，字典的所有值也必须是相同类型的，但键的类型不必与值的类型匹配。例如，如果你想存储一个分数集合，你可以使用双精度浮点数作为键，字符串作为值：
- en: '![](Image00142.jpg)'
  id: totrans-2980
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00142.jpg)'
- en: In this dictionary, all of the keys must be doubles, and all of the values must
    be strings. Again, you’ll see that the order of the numbers in the results pane
    can be quite different from the order in which you wrote the fractions in your
    dictionary. This is fine because you don’t need to know the order to access anything.
    You can find any item that you need by its key. Let’s see how!
  id: totrans-2981
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个字典中，所有的键必须是双精度浮点数，所有的值必须是字符串。同样，你会发现结果面板中的数字顺序可能与在字典中写入分数的顺序完全不同。这是正常的，因为你不需要知道顺序就能访问任何内容。你可以通过键找到你需要的任何项目。我们来看看如何做到这一点！
- en: '**ACCESSING VALUES IN A DICTIONARY**'
  id: totrans-2982
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**访问字典中的值**'
- en: 'Looking up a value in a dictionary is similar to how you access a value in
    an array except that you use a key inside the square brackets instead of an index,
    like this: usStates["TX"] .'
  id: totrans-2983
  prefs: []
  type: TYPE_NORMAL
  zh: 在字典中查找值类似于你在数组中访问值的方式，只不过你使用键而不是索引，像这样：usStates["TX"]。
- en: There is a big difference, however, in how Swift returns the values from a dictionary.
    When you access a value at an index of an array, you are simply given the value.
    When you access a value with a key in a dictionary, you are given an optional.
  id: totrans-2984
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，Swift 从字典中返回值的方式有很大不同。当你访问数组中的某个索引的值时，你只是直接获得该值。当你通过字典中的键访问值时，你会得到一个可选值（optional）。
- en: In [Chapter 5](text00015.html#ch05) , you learned that optionals might contain
    a value or might be nil . The reason Swift returns optionals when you’re looking
    up items in a dictionary is that the key you used might not exist in the dictionary,
    in which case there’s no value to access. Trying to access a value that doesn’t
    exist would give you a big fat error! To avoid that problem, Swift returns optionals.
    That means you need to unwrap any value you get out of a dictionary before you
    can do anything with it.
  id: totrans-2985
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [第5章](text00015.html#ch05) 中，你学习了可选值可能包含一个值，或者可能为 nil。Swift 返回可选值的原因是你查找的键可能在字典中不存在，在这种情况下，没有值可以访问。尝试访问不存在的值会导致一个大的错误！为了避免这个问题，Swift
    返回可选值。这意味着你需要解包从字典中获取的任何值，才能对它做任何操作。
- en: 'To unwrap an optional, first you check whether it exists using an if-let statement,
    just like we did in [Chapter 5](text00015.html#ch05) . The following code shows
    you how to get a value out of a dictionary:'
  id: totrans-2986
  prefs: []
  type: TYPE_NORMAL
  zh: 要解包一个可选值，首先你通过if-let语句检查它是否存在，就像我们在[第5章](text00015.html#ch05)中做的那样。以下代码展示了如何从字典中获取一个值：
- en: '![Image](Image00143.jpg)'
  id: totrans-2987
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00143.jpg)'
- en: To retrieve "Texas" from the dictionary, we use if let to set a constant loneStarState
    to usStates["TX"] ➊ . Because we have this state in our dictionary, the line I
    have Texas in my dictionary. is printed. Next we try to access a state that is
    not in our dictionary by using the key usStates["FL"] ➋ . Thankfully, because
    we used an if-let statement, the program won’t crash when the computer can’t find
    this state. Instead, I don't have that state in my dictionary. is printed.
  id: totrans-2988
  prefs: []
  type: TYPE_NORMAL
  zh: 要从字典中检索"Texas"，我们使用if let将常量loneStarState设置为usStates["TX"] ➊。因为我们在字典中有这个州，所以会打印出"I
    have Texas in my dictionary"。接下来，我们尝试访问一个字典中没有的州，使用键usStates["FL"] ➋。幸运的是，因为我们使用了if-let语句，当计算机找不到这个州时，程序不会崩溃。相反，会打印出"I
    don't have that state in my dictionary"。
- en: '**ADDING ITEMS TO A DICTIONARY**'
  id: totrans-2989
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**向字典中添加项目**'
- en: 'To add an item to a dictionary, first write the name of your dictionary and
    assign the new item to the key you want it to have in the dictionary. Let’s add
    "Minnesota" to our usStates dictionary:'
  id: totrans-2990
  prefs: []
  type: TYPE_NORMAL
  zh: 要向字典中添加项目，首先写下字典的名称，并将新项目赋值给你希望它拥有的键。让我们将"Minnesota"添加到我们的usStates字典中：
- en: '![](Image00144.jpg)'
  id: totrans-2991
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00144.jpg)'
- en: 'Now when you look at usStates , you’ll see that it’s updated to ["MN": "Minnesota",
    "WA": "Washington", "MA": "Massachusetts", "TX": "Texas"] . Remember, because
    you don’t have to rely on indices, your new dictionary item might appear anywhere
    in the dictionary.'
  id: totrans-2992
  prefs: []
  type: TYPE_NORMAL
  zh: '现在，当你查看usStates时，你会看到它更新为["MN": "Minnesota", "WA": "Washington", "MA": "Massachusetts",
    "TX": "Texas"]。记住，因为你不需要依赖索引，所以新的字典项可能出现在字典的任何位置。'
- en: '**REMOVING ITEMS FROM A DICTIONARY**'
  id: totrans-2993
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**从字典中移除项目**'
- en: Removing an item from a dictionary is quite simple; you do so by setting the
    value to nil . Because the values in dictionaries are returned as optionals, you
    don’t have to worry about nil causing any problems in your dictionary.
  id: totrans-2994
  prefs: []
  type: TYPE_NORMAL
  zh: 从字典中移除一个项目非常简单；你只需将该值设置为nil。因为字典中的值作为可选值返回，所以你不必担心nil会在字典中引发任何问题。
- en: '![](Image00145.jpg)'
  id: totrans-2995
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00145.jpg)'
- en: 'You can see that after you remove the value at the key "MA" , usStates is updated
    to ["MN": "Minnesota", "WA": "Washington", "TX": "Texas"] . Remember that nil
    is special and means that there’s no value at all. That’s why you don’t see "MA":
    nil in our dictionary.'
  id: totrans-2996
  prefs: []
  type: TYPE_NORMAL
  zh: '你可以看到，当你移除键为"MA"的值后，usStates更新为["MN": "Minnesota", "WA": "Washington", "TX":
    "Texas"]。记住，nil是特殊的，表示完全没有值。这就是为什么你在字典中看不到"MA": nil的原因。'
- en: '**REPLACING ITEMS IN A DICTIONARY**'
  id: totrans-2997
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**替换字典中的项目**'
- en: 'Replacing an item in a dictionary is also easy. It works the same was as replacing
    an item in an array. You just set the item that you want to replace to something
    else. Say you create a dictionary of fruit colors:'
  id: totrans-2998
  prefs: []
  type: TYPE_NORMAL
  zh: 替换字典中的项目也很简单。它的工作方式与替换数组中的项目相同。你只需将你想替换的项目设为其他值。例如，你创建一个包含水果颜色的字典：
- en: '![](Image00146.jpg)'
  id: totrans-2999
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00146.jpg)'
- en: At first we had the value "apple" for "red" , but then we decided that "raspberry"
    is a better fruit to use since sometimes apples are green or yellow. To replace
    "apple" with "raspberry" , we set colorFruits["red"] to its new value ➊ .
  id: totrans-3000
  prefs: []
  type: TYPE_NORMAL
  zh: 起初，我们为"red"键设置了值"apple"，但后来我们决定使用"raspberry"作为更好的水果，因为有时候苹果是绿色或黄色的。要将"apple"替换为"raspberry"，我们将colorFruits["red"]设置为它的新值
    ➊。
- en: You may remember that this is the same way we entered a new value into a dictionary.
    If the key already exists in the dictionary, then the value for that key is replaced.
    If the key doesn’t already exist, then the new key/value pair will be added to
    the dictionary.
  id: totrans-3001
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能还记得，这是我们向字典中输入新值的相同方式。如果键已经存在于字典中，那么该键的值将被替换。如果键不存在，那么新的键/值对将被添加到字典中。
- en: '![Image](Image00147.jpg)'
  id: totrans-3002
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00147.jpg)'
- en: '**USING DICTIONARY PROPERTIES**'
  id: totrans-3003
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**使用字典属性**'
- en: 'Like an array, a dictionary also has an isEmpty property and a count property.
    For example, the following code shows how you can use the isEmpty property to
    check if a dictionary is empty, and if it isn’t empty, the count property checks
    how many items you have. Imagine you have a basket of fruit for sale. You can
    use these properties to help you keep track of everything:'
  id: totrans-3004
  prefs: []
  type: TYPE_NORMAL
  zh: 和数组一样，字典也有isEmpty属性和count属性。例如，下面的代码展示了如何使用isEmpty属性检查字典是否为空，如果不为空，count属性会显示字典中有多少项。假设你有一篮待售的水果。你可以利用这些属性来帮助你跟踪所有内容：
- en: '![Image](Image00148.jpg)'
  id: totrans-3005
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00148.jpg)'
- en: 'A dictionary also has two special properties: keys , which contains all of
    the dictionary’s keys, and values , which contains all of its values. We’ll use
    these two properties when we loop through the dictionary.'
  id: totrans-3006
  prefs: []
  type: TYPE_NORMAL
  zh: 字典还有两个特殊属性：keys，包含字典的所有键，以及 values，包含字典的所有值。我们将在循环遍历字典时使用这两个属性。
- en: Let’s write some code that loops through our fruit baskets and prints the price
    of each fruit.
  id: totrans-3007
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们写一些代码，循环遍历我们的水果篮并打印每种水果的价格。
- en: '**LOOPING OVER A DICTIONARY**'
  id: totrans-3008
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**遍历字典**'
- en: 'You can loop through a dictionary using a for-in loop. Because each item has
    a key and a value, you can do this in two different ways. This is how to loop
    through a dictionary using its keys:'
  id: totrans-3009
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用 for-in 循环遍历字典。因为每个项都有一个键和值，所以你可以通过两种不同的方式进行循环。以下是使用字典的键来遍历字典的方式：
- en: '![Image](Image00149.jpg)'
  id: totrans-3010
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00149.jpg)'
- en: Here we use the dictionary’s keys property ➊ to loop through fruitBasket and
    print its contents. We start by writing the keyword for , followed by a constant
    name fruit for the dictionary key, the keyword in , the dictionary name, a period,
    and keys .
  id: totrans-3011
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们使用字典的 keys 属性 ➊ 来循环遍历 fruitBasket 并打印其内容。我们从写关键字 `for` 开始，后面跟着常量名 fruit（表示字典的键），关键字
    `in`，字典名，点号，最后是 keys。
- en: Inside the braces of our for-in loop, we have access to both the key, which
    we call fruit ➋ , and the value at that key when we force-unwrap its contents
    with fruitBasket[fruit]! ➌ . That value will be the fruit’s price.
  id: totrans-3012
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的 for-in 循环的大括号内，我们可以访问键（我们称之为 fruit ➋）和该键对应的值，当我们使用 `fruitBasket[fruit]!`
    强制解包其内容时 ➌。这个值将是水果的价格。
- en: In this case, it’s safe to force-unwrap the value using an exclamation point
    because we know that the fruit key we’re using is definitely inside the dictionary.
  id: totrans-3013
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，使用感叹号强制解包值是安全的，因为我们知道我们使用的果实键肯定在字典中。
- en: Any code we put inside the for-in loop will run once for every key in our dictionary.
    So you should see the print statement display three times.
  id: totrans-3014
  prefs: []
  type: TYPE_NORMAL
  zh: 我们放入 for-in 循环中的任何代码都会对字典中的每个键运行一次。因此，你应该看到打印语句显示三次。
- en: 'We can also loop through the dictionary using its values property:'
  id: totrans-3015
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以使用字典的 values 属性来循环遍历字典：
- en: '![Image](Image00150.jpg)'
  id: totrans-3016
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00150.jpg)'
- en: We use the same style of for-in loop, but now we use a constant to refer to
    each value, which we call price , in the values property. When looping through
    values, we don’t have access to the keys from inside the loop.
  id: totrans-3017
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用相同类型的 for-in 循环，但现在我们使用常量来引用每个值，我们称之为 price，在 values 属性中。当遍历 values 时，我们无法从循环内部访问键。
- en: Another difference to note is that price is not an optional because it’s accessed
    directly as a value in the fruitBasket dictionary. That means we don’t have to
    unwrap it. You should still see the print statement printed three times. [Figure
    6-6](text00016.html#ch06fig6) shows the output of both loops.
  id: totrans-3018
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个需要注意的区别是，price 不是一个可选项，因为它是直接作为值在 fruitBasket 字典中访问的。这意味着我们不需要解包它。你仍然应该看到打印语句显示三次。[图
    6-6](text00016.html#ch06fig6) 显示了两种循环的输出。
- en: '![Image](Image00151.jpg)'
  id: totrans-3019
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00151.jpg)'
- en: '*Figure 6-6: Looping through the keys and values of a dictionary with a for-in
    loop*'
  id: totrans-3020
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 6-6：使用 for-in 循环遍历字典的键和值*'
- en: The order of your results might be slightly different from ours. That’s because
    the items in a dictionary aren’t in a numbered order like they are in an array!
    And because the order is not guaranteed, you might see a different order printed
    if you run the same code again.
  id: totrans-3021
  prefs: []
  type: TYPE_NORMAL
  zh: 你的结果顺序可能会与我们的略有不同。这是因为字典中的项不像数组那样按编号顺序排列！而且由于顺序不可保证，如果你再次运行相同的代码，你可能会看到不同的顺序。
- en: '**WHAT YOU LEARNED**'
  id: totrans-3022
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**你学到了什么**'
- en: In this chapter, you learned how to store collections of items in an array and
    in a dictionary. To store items in an ordered list, you would use an array and
    look up each item by its index. If you wanted to store items by key instead, you
    would use a dictionary.
  id: totrans-3023
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你学习了如何将项集合存储在数组和字典中。要将项存储在有序列表中，你会使用数组，并通过索引查找每个项。如果你想通过键来存储项，你则会使用字典。
- en: Knowing about arrays and dictionaries and how to use them is a powerful building
    block for almost any programming language. Next we will learn about functions,
    another very powerful tool. Functions are blocks of code that you create and name
    to perform a specific job. After you have written a function, you can use its
    name to call it from almost anywhere in your program.
  id: totrans-3024
  prefs: []
  type: TYPE_NORMAL
  zh: 了解数组和字典以及如何使用它们是几乎任何编程语言中的强大构建块。接下来我们将学习函数，另一个非常强大的工具。函数是你创建并命名的代码块，用于执行特定任务。在你编写了一个函数之后，你可以在程序中的几乎任何地方通过其名称来调用它。
- en: The list of parks that we created the array with is an example of an array *literal*
    . A literal is a value that is exactly what you see. It is not a variable or constant
    but rather just the value without a name. "Grand Canyon" is an example of a string
    literal, and 7 is an example of an integer literal. An array literal is a list
    of items contained between two square brackets and separated by commas, like ["Acadia",
    "Zion", "Grand Canyon"] ➊ .
  id: totrans-3025
  prefs: []
  type: TYPE_NORMAL
  zh: 我们用来创建数组的公园列表是一个数组 *字面量* 的例子。字面量是一个值，完全就是你看到的内容。它不是一个变量或常量，而只是一个没有名称的值。"Grand
    Canyon" 是一个字符串字面量的例子，而 7 是一个整数字面量的例子。数组字面量是包含在两个方括号之间并用逗号分隔的项目列表，例如 ["Acadia",
    "Zion", "Grand Canyon"] ➊。
- en: '**ACCESSING ITEMS IN AN ARRAY**'
  id: totrans-3026
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**访问数组中的项目**'
- en: 'Let’s say you want to access an item in your array and use it in your program.
    Your friend asks you to tell them all about your travels, so you want to use the
    names of the national parks that you stored in the array. To access an item in
    your array, write the array name followed by the item’s index inside square brackets:'
  id: totrans-3027
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你想访问数组中的某个项目并在程序中使用它。你的朋友要求你告诉他们你所有的旅行经历，所以你想使用你存储在数组中的国家公园的名称。要访问数组中的某个项目，写出数组名称，后面加上项目的索引并放入方括号中：
- en: '![](Image00118.jpg)'
  id: totrans-3028
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00118.jpg)'
- en: In this example, we are accessing the names of the national parks and then printing
    them to the screen using print . To get the first item in nationalParks , you
    use nationalParks[0] ➊ . To access the second item in nationalParks , you use
    nationalParks[1] .
  id: totrans-3029
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们正在访问国家公园的名称，然后使用 print 将它们打印到屏幕上。要获取 nationalParks 中的第一个项目，你使用 nationalParks[0]
    ➊。要访问 nationalParks 中的第二个项目，你使用 nationalParks[1]。
- en: '**WATCHING THE RANGE**'
  id: totrans-3030
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**查看范围**'
- en: One important point about arrays is that if you try to access an item at an
    index that’s higher than the last index in the array, you’ll get an error. In
    [Figure 6-2](text00016.html#ch06fig2) , you can see that nationalParks[3] (which
    would be the fourth item in the array) gives you an error because there are only
    three national parks in the array, indexed from 0 to 2.
  id: totrans-3031
  prefs: []
  type: TYPE_NORMAL
  zh: 关于数组的一个重要点是，如果你试图访问一个比数组最后一个索引更高的索引，你会得到一个错误。在 [图6-2](text00016.html#ch06fig2)
    中，你可以看到 nationalParks[3]（这将是数组中的第四个项目）会给你一个错误，因为数组中只有三个国家公园，索引从 0 到 2。
- en: As you can see, you get an error message that says Index out of range . If you
    try to access an item that doesn’t exist in your array, your app will crash!
  id: totrans-3032
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，你会收到一个错误消息，提示 "Index out of range"。如果你试图访问数组中不存在的项目，应用程序会崩溃！
- en: '![Image](Image00119.jpg)'
  id: totrans-3033
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00119.jpg)'
- en: '*Figure 6-2: Trying to access an index in the array where nothing exists causes
    an error.*'
  id: totrans-3034
  prefs: []
  type: TYPE_NORMAL
  zh: '*图6-2：尝试访问数组中不存在的索引会导致错误。*'
- en: '**ADDING ITEMS TO AN ARRAY**'
  id: totrans-3035
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**向数组添加项目**'
- en: One way to change an array is to add new items to it. There are a few different
    ways to do this, so let’s take a look at each.
  id: totrans-3036
  prefs: []
  type: TYPE_NORMAL
  zh: 更改数组的一种方法是向数组中添加新项目。有几种不同的方法来做到这一点，我们来看看每种方法。
- en: 'First, you can use an array’s append(_:) method. *Append* means to add something.
    Using append(_:) , you can add one new item to the end of your array. Say you
    go on another trip and visit the Badlands, and you want to add it to your list
    of national parks. To do that, add this code into your playground:'
  id: totrans-3037
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，你可以使用数组的 append(_:) 方法。*Append* 的意思是添加某物。使用 append(_:) 方法，你可以将一个新项目添加到数组的末尾。假设你去了一次新的旅行，访问了
    Badlands，你想把它添加到你的国家公园列表中。为此，可以将以下代码添加到你的 playground 中：
- en: '![](Image00120.jpg)'
  id: totrans-3038
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00120.jpg)'
- en: To use the append(_:) method, first write the name of your array followed by
    a period and then append . Then, put the item you want to add to your array inside
    the parentheses. In this case, you put "Badlands" inside the parentheses.
  id: totrans-3039
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用 append(_:) 方法，首先写出数组的名称，后面加一个点，再加上 append。然后，将你想添加到数组中的项目放入括号内。在这个例子中，你将
    "Badlands" 放入了括号内。
- en: 'If you want to add something at a specific place in your array, use the array’s
    insert(_:at:) method instead. This method takes two arguments: the item that you
    want to insert and the index of where it should go in the array. (We’ll discuss
    arguments in more detail in [Chapter 7](text00017.html#ch07) .)'
  id: totrans-3040
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想在数组的特定位置添加某项内容，可以使用数组的 `insert(_:at:)` 方法。这个方法有两个参数：你想插入的项和它应该放在数组中的索引位置。（我们将在[第
    7 章](text00017.html#ch07)中详细讨论参数。）
- en: 'Let’s say you totally forgot that you went to the Petrified Forest right after
    you visited the Grand Canyon, and you want to update your nationalParks array
    so it displays the parks in the order in which you visited them. To update your
    array, you could use the insert(_:at:) method to put the Petrified Forest in the
    right position:'
  id: totrans-3041
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你完全忘记了在参观大峡谷之后去了化石森林，你想要更新你的 nationalParks 数组，让它按照你访问的顺序显示公园。要更新你的数组，你可以使用
    `insert(_:at:)` 方法将化石森林放在正确的位置：
- en: '![](Image00121.jpg)'
  id: totrans-3042
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00121.jpg)'
- en: When you insert a new item at index 3, everything that was in the array at index
    3 or higher gets scooted over to make room for the new item. That means the item
    that was at index 3 is now at index 4, the item that was at index 4 is now at
    index 5, and so on. After you add the Petrified Forest, nationalParks is now ["Acadia",
    "Zion", "Grand Canyon", "Petrified Forest", "Badlands"] .
  id: totrans-3043
  prefs: []
  type: TYPE_NORMAL
  zh: 当你在索引 3 插入一个新项时，数组中索引为 3 或更高的所有项都会向后移动，为新项腾出空间。这意味着原本在索引 3 的项现在会在索引 4，原本在索引
    4 的项会在索引 5，依此类推。添加了化石森林之后，nationalParks 数组现在是 ["Acadia", "Zion", "Grand Canyon",
    "Petrified Forest", "Badlands"]。
- en: '**COMBINING ARRAYS**'
  id: totrans-3044
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**合并数组**'
- en: 'Not only can you add new items to an array, but you can also add two arrays
    together using the + and += operators. Let’s say that you have the ingredients
    for a fruit smoothie in two arrays:'
  id: totrans-3045
  prefs: []
  type: TYPE_NORMAL
  zh: 你不仅可以向数组中添加新项目，还可以使用 `+` 和 `+=` 操作符将两个数组合并。假设你有两个数组，分别存放水果奶昔的食材：
- en: '![](Image00122.jpg)'
  id: totrans-3046
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00122.jpg)'
- en: Now you can make a delicious smoothie by adding the fruits and liquids arrays.
  id: totrans-3047
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你可以通过将水果和液体数组添加在一起，制作出美味的奶昔。
- en: '![](Image00123.jpg)'
  id: totrans-3048
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00123.jpg)'
- en: The order of the ingredients in smoothie is the same as the order in fruits
    and liquids . If you created smoothie with liquids + fruits , then the liquids
    would come first.
  id: totrans-3049
  prefs: []
  type: TYPE_NORMAL
  zh: 奶昔中食材的顺序与水果和液体的顺序相同。如果你是用液体 + 水果做的奶昔，那么液体应该先放。
- en: 'You use the += operator to add an array to the end of your array. Add some
    whipped cream as follows for extra yumminess:'
  id: totrans-3050
  prefs: []
  type: TYPE_NORMAL
  zh: 你使用 `+=` 操作符将一个数组添加到你数组的末尾。为了增加更多美味的口感，你可以按如下方式添加一些奶油：
- en: '![](Image00124.jpg)'
  id: totrans-3051
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00124.jpg)'
- en: Note that ["whipped cream"] is an array even though it has a single item in
    it. When you’re using += to append something to an array, you have to make sure
    you’re only trying to add another array. If you were to just write the string
    "whipped cream" without the square brackets around it, you would get an error.
  id: totrans-3052
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，["whipped cream"] 是一个数组，即使它只有一个项目。当你使用 `+=` 操作符向数组添加内容时，必须确保你只在尝试添加另一个数组。如果你只写了字符串
    "whipped cream" 而没有加上方括号，那么你将会遇到错误。
- en: '![Image](Image00125.jpg)'
  id: totrans-3053
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Image00125.jpg)'
- en: '**REMOVING ITEMS FROM AN ARRAY**'
  id: totrans-3054
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**从数组中移除项**'
- en: 'There are several methods for removing items from an array. Let’s start by
    looking at the array’s removeLast() method. As you might have guessed from its
    name, removeLast() removes the last item from your array. Let’s try it out with
    a shoppingList array:'
  id: totrans-3055
  prefs: []
  type: TYPE_NORMAL
  zh: 有几种方法可以从数组中移除项。我们首先来看一下数组的 `removeLast()` 方法。正如你从名字中可能猜到的那样，`removeLast()` 会移除数组中的最后一项。我们来通过一个
    shoppingList 数组试试看：
- en: '![](Image00126.jpg)'
  id: totrans-3056
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00126.jpg)'
- en: Neat! Note that the removeLast() method returns the removed item, so you can
    store it in a new constant or variable if you want.
  id: totrans-3057
  prefs: []
  type: TYPE_NORMAL
  zh: 很棒！注意，`removeLast()` 方法返回被移除的项，因此你可以将它存储在一个新的常量或变量中，如果你需要的话。
- en: 'You can also remove an item from a specific index by using the remove(at:)
    method. Let’s say that your mom doesn’t want you buying any candy and takes that
    off the list:'
  id: totrans-3058
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以使用 `remove(at:)` 方法从指定的索引处移除一项。假设你妈妈不希望你买糖果，把糖果从清单上拿掉：
- en: '![Image](Image00127.jpg)![](Image00128.jpg)'
  id: totrans-3059
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Image00127.jpg)![](Image00128.jpg)'
- en: Just like when we added an item to the middle of our array and all the items
    scooted over to make room, if you remove an item from the middle of an array,
    the rest of the items will scoot back to fill in that empty space. The "apples"
    item that was at index 3 is now at index 2, where "candy" was.
  id: totrans-3060
  prefs: []
  type: TYPE_NORMAL
  zh: 就像我们把一项添加到数组中间时，所有其他项都会向后移动为新项腾出空间一样，如果你从数组的中间移除一项，其余项也会向前移动以填补那个空位。原本在索引 3
    的 "apples" 项现在会在索引 2 的位置，原来 "candy" 项所在的位置。
- en: 'You can also remove all items from an array with removeAll() . Try entering
    this into your playground:'
  id: totrans-3061
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以使用 removeAll() 从数组中移除所有项。尝试在你的 playground 中输入以下内容：
- en: '![](Image00129.jpg)'
  id: totrans-3062
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00129.jpg)'
- en: 'Note that trying to remove an item at an index that doesn’t exist will give
    you an error:'
  id: totrans-3063
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，尝试移除一个不存在索引的项会导致错误：
- en: '![](Image00130.jpg)'
  id: totrans-3064
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00130.jpg)'
- en: Our array doesn’t have this many items (in fact, now it’s empty!), so this throws
    an error. We’ll also get an error if we use removeLast() on our empty array, because
    there’s nothing in it—there’s no last index at all! However, removeAll() is always
    safe to use, even on an empty array.
  id: totrans-3065
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的数组没有这么多项（事实上，现在它是空的！），所以这会抛出一个错误。如果我们在空数组上使用 removeLast()，也会出现错误，因为数组中没有任何元素——根本没有最后一个索引！但是，removeAll()
    始终是安全的，即使在空数组上使用也没有问题。
- en: '**REPLACING ITEMS IN AN ARRAY**'
  id: totrans-3066
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**替换数组中的元素**'
- en: 'To replace an item in an array, you set the index of the array to the new value,
    as shown here:'
  id: totrans-3067
  prefs: []
  type: TYPE_NORMAL
  zh: 要替换数组中的元素，你可以将数组某个索引处的值设置为新的值，如下所示：
- en: '![](Image00131.jpg)'
  id: totrans-3068
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00131.jpg)'
- en: At ➊ , we replaced the item at index 2 (the third item) with "Unicorn" because
    magical animals count as favorite animals, too! At ➋ , we replaced the item at
    index 0 (the first item) with "Bearded dragon" . No, that’s not a real dragon—it’s
    just a lizard!
  id: totrans-3069
  prefs: []
  type: TYPE_NORMAL
  zh: 在 ➊，我们将索引 2（第三项）处的元素替换为 "独角兽"，因为魔法动物也算作最喜欢的动物！在 ➋，我们将索引 0（第一项）处的元素替换为 "胡须龙"。不，这不是一条真正的龙——它只是个蜥蜴！
- en: Like any time you’re working with array index numbers, you have to be sure an
    item exists in the array at that index before you change its value, or you will
    get an Index out of range error.
  id: totrans-3070
  prefs: []
  type: TYPE_NORMAL
  zh: 就像每次处理数组索引时一样，你必须确保数组中在该索引位置有一个元素，才能改变它的值，否则会报索引越界错误。
- en: '[Figure 6-3](text00016.html#ch06fig3) shows the error that occurs if you try
    to add "Standard poodle" using favoriteAnimals[3] = "Standard poodle" . To add
    an item to the end of an array, you should use the append(_:) method or += , as
    we covered in “[Adding Items to an Array](text00016.html#ch06lev2sec5) ” on [page
    70](text00016.html#page_70) .'
  id: totrans-3071
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 6-3](text00016.html#ch06fig3) 显示了如果你尝试使用 favoriteAnimals[3] = "Standard
    poodle" 添加 "标准贵宾犬" 时会发生的错误。要将一个项添加到数组的末尾，应该使用 append(_:) 方法或 +=，正如我们在 “[向数组添加项](text00016.html#ch06lev2sec5)”
    中的 [第 70 页](text00016.html#page_70) 所讲的。'
- en: '![Image](Image00132.jpg)'
  id: totrans-3072
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00132.jpg)'
- en: '*Figure 6-3: Don’t try to replace a value at an index beyond the existing array.*'
  id: totrans-3073
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 6-3：不要尝试替换超出现有数组索引范围的值。*'
- en: Now you know how to change arrays however you might need to. You can add items,
    take items away, or replace items. Next, we’ll look at how to use the properties
    of arrays to find out even more information about them.
  id: totrans-3074
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你知道如何根据需要更改数组了。你可以添加项，移除项，或者替换项。接下来，我们将看看如何使用数组的属性来获取更多有关它们的信息。
- en: '![Image](Image00133.jpg)'
  id: totrans-3075
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00133.jpg)'
- en: '**USING ARRAY PROPERTIES**'
  id: totrans-3076
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**使用数组属性**'
- en: In addition to methods like append(_:) and removeLast() , arrays also have *properties*
    . An array’s properties are variables or constants that contain some information
    about the array. Two really helpful properties that you might use are the Boolean
    property isEmpty and the integer property count .
  id: totrans-3077
  prefs: []
  type: TYPE_NORMAL
  zh: 除了像 append(_:) 和 removeLast() 这样的方法，数组还有*属性*。数组的属性是包含关于数组的一些信息的变量或常量。你可能会用到的两个非常有用的属性是布尔型属性
    isEmpty 和整数型属性 count。
- en: The isEmpty property is true or false depending on whether the array is empty,
    and the count property will tell you how many items are in that array.
  id: totrans-3078
  prefs: []
  type: TYPE_NORMAL
  zh: isEmpty 属性表示数组是否为空，返回 true 或 false，count 属性则告诉你数组中有多少项。
- en: 'Check out how these two properties are used in the following if-else statement:'
  id: totrans-3079
  prefs: []
  type: TYPE_NORMAL
  zh: 看看以下 if-else 语句中是如何使用这两个属性的：
- en: '![Image](Image00134.jpg)'
  id: totrans-3080
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00134.jpg)'
- en: 'This if-else statement checks whether the array mySiblings is empty ➊ . If
    it is, then "I don''t have any siblings." is printed. But if there is something
    in the array, then the number of siblings that we have is printed: "I have 3 siblings."
    ➋ .'
  id: totrans-3081
  prefs: []
  type: TYPE_NORMAL
  zh: 这个 if-else 语句检查数组 mySiblings 是否为空 ➊。如果为空，打印 "我没有兄弟姐妹。" 如果数组中有内容，则打印我们有多少个兄弟姐妹："我有
    3 个兄弟姐妹。" ➋。
- en: '**LOOPING OVER AN ARRAY**'
  id: totrans-3082
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**遍历数组**'
- en: 'Sometimes when you’re working with arrays you might want to do something to
    every item in the array. You can use a for-in loop to do that! The following code
    will print every topping in a pizzaToppings array on a separate line:'
  id: totrans-3083
  prefs: []
  type: TYPE_NORMAL
  zh: 有时在处理数组时，你可能想对数组中的每个元素做某些操作。你可以使用 for-in 循环来实现！下面的代码会将 pizzaToppings 数组中的每个配料打印到单独的一行：
- en: '![Image](Image00135.jpg)'
  id: totrans-3084
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00135.jpg)'
- en: To write a for-in loop for the pizzaToppings array, we used the keyword for
    , followed by the constant topping , then the keyword in , and finally the name
    of our array, pizzaToppings . Then we put the statements that we want to run for
    each topping inside the braces of the for-in loop. The constant topping ➊ temporarily
    represents each pizza topping in the array as we loop through it. We could have
    chosen any name for this constant, but it’s a good idea to pick something that
    makes sense. You can see the output of this for-in loop in [Figure 6-4](text00016.html#ch06fig4)
    .
  id: totrans-3085
  prefs: []
  type: TYPE_NORMAL
  zh: 为了编写一个针对 pizzaToppings 数组的 for-in 循环，我们使用了关键字 for，接着是常量 topping，然后是关键字 in，最后是数组的名称
    pizzaToppings。接着，我们把要在每个 topping 上执行的语句放入 for-in 循环的大括号内。常量 topping ➊ 在我们遍历数组时临时代表数组中的每个比萨配料。我们本可以为这个常量选择任何名字，但最好选择一个有意义的名称。你可以在
    [图 6-4](text00016.html#ch06fig4) 中看到这个 for-in 循环的输出。
- en: '![Image](Image00136.jpg)'
  id: totrans-3086
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00136.jpg)'
- en: '*Figure 6-4: Output of the example for-in loop*'
  id: totrans-3087
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 6-4：示例 for-in 循环的输出*'
- en: '![Image](Image00137.jpg)'
  id: totrans-3088
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00137.jpg)'
- en: 'Using for-in loops is great for printing every value in an array. If you’re
    working with numbers, you can even use them to perform math operations on each
    item, which makes for some speedy calculations! The following code takes an array
    of numbers and calculates the square for each (the square of a number is that
    number multiplied by itself):'
  id: totrans-3089
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 for-in 循环非常适合打印数组中的每个值。如果你处理的是数字，还可以使用它们对每个项进行数学运算，从而进行快速计算！以下代码接受一个数字数组，并计算每个数字的平方（一个数字的平方是它自己乘以自己）：
- en: '![Image](Image00138.jpg)'
  id: totrans-3090
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00138.jpg)'
- en: '[Figure 6-5](text00016.html#ch06fig5) shows the results.'
  id: totrans-3091
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 6-5](text00016.html#ch06fig5) 显示了结果。'
- en: '![Image](Image00139.jpg)'
  id: totrans-3092
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00139.jpg)'
- en: '*Figure 6-5: Printing the squares for each number in the myNumbers array*'
  id: totrans-3093
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 6-5：打印 myNumbers 数组中每个数字的平方*'
- en: '**DICTIONARIES ARE KEY!**'
  id: totrans-3094
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**字典至关重要！**'
- en: A *dictionary* is also a collection of values, but instead of an ordered index,
    each value has its own *key* . Because there’s no index, the values are not stored
    in any particular order. To access values in a dictionary, you look them up by
    their key.
  id: totrans-3095
  prefs: []
  type: TYPE_NORMAL
  zh: '*字典*也是一个值的集合，但不同于有序索引，每个值都有自己独立的*键*。由于没有索引，值不会以任何特定的顺序存储。要访问字典中的值，你需要通过键来查找它们。'
- en: A key must be unique. You can’t have the same key more than once in the same
    dictionary. If there were two identical keys and you asked the computer to give
    you the value for one of them, the computer wouldn’t know which one to choose!
  id: totrans-3096
  prefs: []
  type: TYPE_NORMAL
  zh: 每个键必须是唯一的。同一个字典中不能有重复的键。如果有两个相同的键，当你请求计算机给出其中一个的值时，计算机将不知道该选择哪一个！
- en: Let’s take a look at how to make a dictionary and write keys that will help
    you find all the information you need.
  id: totrans-3097
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看如何创建字典并写入键，这将帮助你找到所有需要的信息。
- en: '![Image](Image00140.jpg)'
  id: totrans-3098
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00140.jpg)'
- en: '**INITIALIZING A DICTIONARY**'
  id: totrans-3099
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**初始化字典**'
- en: 'To create and initialize a dictionary, first write var and the name of your
    dictionary. Then write the keys and corresponding values inside a pair of square
    brackets, similar to an array. Let’s create a dictionary to store the names of
    a few US states. The key for each state will be its two-letter abbreviation:'
  id: totrans-3100
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建并初始化字典，首先写 var 和字典的名称。然后在一对方括号中写入键及其对应的值，类似于数组的写法。让我们创建一个字典来存储一些美国州的名称。每个州的键将是它的两字母缩写：
- en: '![](Image00141.jpg)'
  id: totrans-3101
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00141.jpg)'
- en: As you can see, there’s a colon between each key and its value, and the key/value
    pairs are separated by commas.
  id: totrans-3102
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，每个键和它的值之间有一个冒号，键/值对之间用逗号分隔。
- en: Dictionaries are different from arrays in that they are *unordered* . Because
    of that, it’s likely that the order of the states that you see in your results
    pane ➋ is different from the order in which you entered your states ➊ . It might
    even be different than the order that’s printed in this book!
  id: totrans-3103
  prefs: []
  type: TYPE_NORMAL
  zh: 字典与数组不同，字典是*无序的*。因此，你在结果窗格 ➋ 中看到的状态顺序很可能与你输入状态 ➊ 时的顺序不同，甚至可能与本书中打印出的顺序不同！
- en: As with arrays, you can use var to make a mutable dictionary or use let to make
    an immutable dictionary.
  id: totrans-3104
  prefs: []
  type: TYPE_NORMAL
  zh: 与数组一样，你可以使用 var 来创建一个可变字典，或者使用 let 来创建一个不可变字典。
- en: 'In Swift, all of the keys of a dictionary must be the same type, and all of
    the values of a dictionary must also be the same type, but the key type doesn’t
    have to match the value type. For example, if you wanted to store a collection
    of fractions, you could use doubles for the keys and strings for the values:'
  id: totrans-3105
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Swift 中，字典的所有键必须是相同类型的，字典的所有值也必须是相同类型的，但键类型不必与值类型相匹配。例如，如果你想存储一组分数，你可以使用双精度浮点数作为键，字符串作为值：
- en: '![](Image00142.jpg)'
  id: totrans-3106
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00142.jpg)'
- en: In this dictionary, all of the keys must be doubles, and all of the values must
    be strings. Again, you’ll see that the order of the numbers in the results pane
    can be quite different from the order in which you wrote the fractions in your
    dictionary. This is fine because you don’t need to know the order to access anything.
    You can find any item that you need by its key. Let’s see how!
  id: totrans-3107
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个字典中，所有的键必须是双精度浮点数，所有的值必须是字符串。同样，你会发现结果面板中的数字顺序可能与在字典中书写分数时的顺序完全不同。这没关系，因为你不需要知道顺序来访问任何内容。你可以通过键来找到你需要的任何项目。让我们来看看如何做！
- en: '**ACCESSING VALUES IN A DICTIONARY**'
  id: totrans-3108
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**访问字典中的值**'
- en: 'Looking up a value in a dictionary is similar to how you access a value in
    an array except that you use a key inside the square brackets instead of an index,
    like this: usStates["TX"] .'
  id: totrans-3109
  prefs: []
  type: TYPE_NORMAL
  zh: 在字典中查找一个值类似于在数组中访问一个值，只不过你在方括号中使用的是一个键而不是索引，例如：usStates["TX"]。
- en: There is a big difference, however, in how Swift returns the values from a dictionary.
    When you access a value at an index of an array, you are simply given the value.
    When you access a value with a key in a dictionary, you are given an optional.
  id: totrans-3110
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，Swift 从字典中返回值的方式与数组不同。当你在数组的索引位置访问一个值时，你只是得到了该值。而当你用键在字典中访问一个值时，你会得到一个可选项。
- en: In [Chapter 5](text00015.html#ch05) , you learned that optionals might contain
    a value or might be nil . The reason Swift returns optionals when you’re looking
    up items in a dictionary is that the key you used might not exist in the dictionary,
    in which case there’s no value to access. Trying to access a value that doesn’t
    exist would give you a big fat error! To avoid that problem, Swift returns optionals.
    That means you need to unwrap any value you get out of a dictionary before you
    can do anything with it.
  id: totrans-3111
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第 5 章](text00015.html#ch05)中，你学习了可选项可能包含值或可能是 nil。当你在字典中查找项目时，Swift 返回可选项的原因是你使用的键可能在字典中不存在，在这种情况下，就没有值可供访问。尝试访问一个不存在的值会给你一个巨大的错误！为避免这个问题，Swift
    返回可选项。这意味着你需要解包从字典中取出的任何值，才能对其进行操作。
- en: 'To unwrap an optional, first you check whether it exists using an if-let statement,
    just like we did in [Chapter 5](text00015.html#ch05) . The following code shows
    you how to get a value out of a dictionary:'
  id: totrans-3112
  prefs: []
  type: TYPE_NORMAL
  zh: 要解包一个可选项，首先你需要使用 if-let 语句检查它是否存在，就像我们在[第 5 章](text00015.html#ch05)中做的那样。以下代码演示了如何从字典中获取一个值：
- en: '![Image](Image00143.jpg)'
  id: totrans-3113
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Image00143.jpg)'
- en: To retrieve "Texas" from the dictionary, we use if let to set a constant loneStarState
    to usStates["TX"] ➊ . Because we have this state in our dictionary, the line I
    have Texas in my dictionary. is printed. Next we try to access a state that is
    not in our dictionary by using the key usStates["FL"] ➋ . Thankfully, because
    we used an if-let statement, the program won’t crash when the computer can’t find
    this state. Instead, I don't have that state in my dictionary. is printed.
  id: totrans-3114
  prefs: []
  type: TYPE_NORMAL
  zh: 要从字典中检索 "Texas"，我们使用 if let 语句将常量 loneStarState 设置为 usStates["TX"] ➊。由于我们在字典中有这个州，输出将打印
    "I have Texas in my dictionary"。接下来，我们尝试访问一个字典中不存在的州，通过键 usStates["FL"] ➋。幸运的是，由于我们使用了
    if-let 语句，当计算机找不到这个州时，程序不会崩溃。相反，输出将打印 "I don't have that state in my dictionary"。
- en: '**ADDING ITEMS TO A DICTIONARY**'
  id: totrans-3115
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**向字典中添加项目**'
- en: 'To add an item to a dictionary, first write the name of your dictionary and
    assign the new item to the key you want it to have in the dictionary. Let’s add
    "Minnesota" to our usStates dictionary:'
  id: totrans-3116
  prefs: []
  type: TYPE_NORMAL
  zh: 要向字典中添加一个项目，首先写下字典的名称，并将新项目分配给你希望它在字典中拥有的键。我们来向 usStates 字典中添加 "Minnesota"：
- en: '![](Image00144.jpg)'
  id: totrans-3117
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00144.jpg)'
- en: 'Now when you look at usStates , you’ll see that it’s updated to ["MN": "Minnesota",
    "WA": "Washington", "MA": "Massachusetts", "TX": "Texas"] . Remember, because
    you don’t have to rely on indices, your new dictionary item might appear anywhere
    in the dictionary.'
  id: totrans-3118
  prefs: []
  type: TYPE_NORMAL
  zh: '现在，当你查看 usStates 时，你会看到它已更新为 ["MN": "Minnesota", "WA": "Washington", "MA":
    "Massachusetts", "TX": "Texas"]。记住，由于你不需要依赖索引，新的字典项目可能出现在字典的任何位置。'
- en: '**REMOVING ITEMS FROM A DICTIONARY**'
  id: totrans-3119
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**从字典中删除项目**'
- en: Removing an item from a dictionary is quite simple; you do so by setting the
    value to nil . Because the values in dictionaries are returned as optionals, you
    don’t have to worry about nil causing any problems in your dictionary.
  id: totrans-3120
  prefs: []
  type: TYPE_NORMAL
  zh: 从字典中移除项非常简单；你只需要将值设置为 nil。因为字典中的值是以可选类型返回的，所以你无需担心 nil 会在字典中引发任何问题。
- en: '![](Image00145.jpg)'
  id: totrans-3121
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00145.jpg)'
- en: 'You can see that after you remove the value at the key "MA" , usStates is updated
    to ["MN": "Minnesota", "WA": "Washington", "TX": "Texas"] . Remember that nil
    is special and means that there’s no value at all. That’s why you don’t see "MA":
    nil in our dictionary.'
  id: totrans-3122
  prefs: []
  type: TYPE_NORMAL
  zh: '你可以看到，在移除“MA”键对应的值后，usStates 被更新为 ["MN": "Minnesota", "WA": "Washington", "TX":
    "Texas"]。记住，nil 是特殊的，意味着没有任何值。因此你在字典中看不到 "MA": nil。'
- en: '**REPLACING ITEMS IN A DICTIONARY**'
  id: totrans-3123
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**替换字典中的项**'
- en: 'Replacing an item in a dictionary is also easy. It works the same was as replacing
    an item in an array. You just set the item that you want to replace to something
    else. Say you create a dictionary of fruit colors:'
  id: totrans-3124
  prefs: []
  type: TYPE_NORMAL
  zh: 替换字典中的项也很简单。它的操作方式与替换数组中的项相同。你只需将要替换的项设置为其他值。假设你创建了一个水果颜色的字典：
- en: '![](Image00146.jpg)'
  id: totrans-3125
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00146.jpg)'
- en: At first we had the value "apple" for "red" , but then we decided that "raspberry"
    is a better fruit to use since sometimes apples are green or yellow. To replace
    "apple" with "raspberry" , we set colorFruits["red"] to its new value ➊ .
  id: totrans-3126
  prefs: []
  type: TYPE_NORMAL
  zh: 一开始我们为“红色”分配了“苹果”这个值，但后来我们决定“树莓”是更好的选择，因为有时候苹果是绿色或黄色的。为了将“苹果”替换为“树莓”，我们将 colorFruits["red"]
    设置为它的新值 ➊。
- en: You may remember that this is the same way we entered a new value into a dictionary.
    If the key already exists in the dictionary, then the value for that key is replaced.
    If the key doesn’t already exist, then the new key/value pair will be added to
    the dictionary.
  id: totrans-3127
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能还记得，这是我们向字典中输入新值的相同方式。如果键已经存在于字典中，那么该键的值会被替换；如果键不存在，则新的键/值对将被添加到字典中。
- en: '![Image](Image00147.jpg)'
  id: totrans-3128
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00147.jpg)'
- en: '**USING DICTIONARY PROPERTIES**'
  id: totrans-3129
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**使用字典属性**'
- en: 'Like an array, a dictionary also has an isEmpty property and a count property.
    For example, the following code shows how you can use the isEmpty property to
    check if a dictionary is empty, and if it isn’t empty, the count property checks
    how many items you have. Imagine you have a basket of fruit for sale. You can
    use these properties to help you keep track of everything:'
  id: totrans-3130
  prefs: []
  type: TYPE_NORMAL
  zh: 和数组一样，字典也有 isEmpty 属性和 count 属性。例如，以下代码展示了如何使用 isEmpty 属性来检查字典是否为空，如果不为空，count
    属性则检查你有多少项。假设你有一个待售的水果篮，你可以使用这些属性帮助你跟踪所有内容：
- en: '![Image](Image00148.jpg)'
  id: totrans-3131
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00148.jpg)'
- en: 'A dictionary also has two special properties: keys , which contains all of
    the dictionary’s keys, and values , which contains all of its values. We’ll use
    these two properties when we loop through the dictionary.'
  id: totrans-3132
  prefs: []
  type: TYPE_NORMAL
  zh: 字典还有两个特殊属性：keys，它包含字典中的所有键；values，它包含字典中的所有值。我们将在遍历字典时使用这两个属性。
- en: Let’s write some code that loops through our fruit baskets and prints the price
    of each fruit.
  id: totrans-3133
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们写一些代码，遍历我们的水果篮，并打印每个水果的价格。
- en: '**LOOPING OVER A DICTIONARY**'
  id: totrans-3134
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**遍历字典**'
- en: 'You can loop through a dictionary using a for-in loop. Because each item has
    a key and a value, you can do this in two different ways. This is how to loop
    through a dictionary using its keys:'
  id: totrans-3135
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用 for-in 循环来遍历字典。因为每个项都有一个键和值，你可以通过两种不同的方式来进行遍历。这是通过键遍历字典的方法：
- en: '![Image](Image00149.jpg)'
  id: totrans-3136
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00149.jpg)'
- en: Here we use the dictionary’s keys property ➊ to loop through fruitBasket and
    print its contents. We start by writing the keyword for , followed by a constant
    name fruit for the dictionary key, the keyword in , the dictionary name, a period,
    and keys .
  id: totrans-3137
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们使用字典的 keys 属性 ➊ 来遍历 fruitBasket 并打印其内容。我们首先写关键字 for，然后是字典键的常量名 fruit，接着是关键字
    in，字典名，一个句点，最后是 keys。
- en: Inside the braces of our for-in loop, we have access to both the key, which
    we call fruit ➋ , and the value at that key when we force-unwrap its contents
    with fruitBasket[fruit]! ➌ . That value will be the fruit’s price.
  id: totrans-3138
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的 for-in 循环的大括号内，我们可以访问到键（我们称之为 fruit ➋）以及通过强制解包 `fruitBasket[fruit]!` ➌
    获取到的该键对应的值。这个值就是水果的价格。
- en: In this case, it’s safe to force-unwrap the value using an exclamation point
    because we know that the fruit key we’re using is definitely inside the dictionary.
  id: totrans-3139
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，使用感叹号强制解包值是安全的，因为我们知道我们使用的水果键肯定在字典中存在。
- en: Any code we put inside the for-in loop will run once for every key in our dictionary.
    So you should see the print statement display three times.
  id: totrans-3140
  prefs: []
  type: TYPE_NORMAL
  zh: 我们放入 `for-in` 循环中的任何代码会针对字典中的每个键运行一次。因此，你应该看到 `print` 语句显示三次。
- en: 'We can also loop through the dictionary using its values property:'
  id: totrans-3141
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以通过字典的 `values` 属性进行循环：
- en: '![Image](Image00150.jpg)'
  id: totrans-3142
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00150.jpg)'
- en: We use the same style of for-in loop, but now we use a constant to refer to
    each value, which we call price , in the values property. When looping through
    values, we don’t have access to the keys from inside the loop.
  id: totrans-3143
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用相同类型的 `for-in` 循环，但现在我们使用常量来引用 `values` 属性中的每个值，我们称之为 `price`。当循环遍历 `values`
    时，我们无法从循环内部访问键。
- en: Another difference to note is that price is not an optional because it’s accessed
    directly as a value in the fruitBasket dictionary. That means we don’t have to
    unwrap it. You should still see the print statement printed three times. [Figure
    6-6](text00016.html#ch06fig6) shows the output of both loops.
  id: totrans-3144
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个需要注意的区别是 `price` 不是可选的，因为它是直接作为值访问 `fruitBasket` 字典中的。那意味着我们不需要解包它。你仍然应该看到
    `print` 语句打印三次。[图 6-6](text00016.html#ch06fig6) 显示了两个循环的输出。
- en: '![Image](Image00151.jpg)'
  id: totrans-3145
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00151.jpg)'
- en: '*Figure 6-6: Looping through the keys and values of a dictionary with a for-in
    loop*'
  id: totrans-3146
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 6-6: 使用 `for-in` 循环遍历字典的键和值*'
- en: The order of your results might be slightly different from ours. That’s because
    the items in a dictionary aren’t in a numbered order like they are in an array!
    And because the order is not guaranteed, you might see a different order printed
    if you run the same code again.
  id: totrans-3147
  prefs: []
  type: TYPE_NORMAL
  zh: 你的结果顺序可能与你的不同。这是因为字典中的项目不像数组中的项目那样按编号顺序排列！而且，由于顺序无法保证，如果你重新运行相同的代码，可能会看到不同的顺序。
- en: '**WHAT YOU LEARNED**'
  id: totrans-3148
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**你学到的内容**'
- en: In this chapter, you learned how to store collections of items in an array and
    in a dictionary. To store items in an ordered list, you would use an array and
    look up each item by its index. If you wanted to store items by key instead, you
    would use a dictionary.
  id: totrans-3149
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你学习了如何将多个项目存储在数组和字典中。为了将项目存储在有序列表中，你可以使用数组，并通过索引查找每个项目。如果你想按键存储项目，则应使用字典。
- en: Knowing about arrays and dictionaries and how to use them is a powerful building
    block for almost any programming language. Next we will learn about functions,
    another very powerful tool. Functions are blocks of code that you create and name
    to perform a specific job. After you have written a function, you can use its
    name to call it from almost anywhere in your program.
  id: totrans-3150
  prefs: []
  type: TYPE_NORMAL
  zh: 了解数组和字典以及如何使用它们是几乎任何编程语言的强大构建块。接下来我们将学习函数，这是另一个非常强大的工具。函数是你创建并命名的一段代码，用于执行特定任务。在你写好函数之后，你可以使用它的名称在程序的几乎任何地方调用它。
- en: '**ACCESSING ITEMS IN AN ARRAY**'
  id: totrans-3151
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**访问数组中的项目**'
- en: 'Let’s say you want to access an item in your array and use it in your program.
    Your friend asks you to tell them all about your travels, so you want to use the
    names of the national parks that you stored in the array. To access an item in
    your array, write the array name followed by the item’s index inside square brackets:'
  id: totrans-3152
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你想要访问数组中的一个项目并在程序中使用它。你的朋友请你告诉他们你所有的旅行经历，因此你想使用你存储在数组中的国家公园名称。要访问数组中的一个项目，写出数组名称，后跟方括号内的项目索引：
- en: '![](Image00118.jpg)'
  id: totrans-3153
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00118.jpg)'
- en: In this example, we are accessing the names of the national parks and then printing
    them to the screen using print . To get the first item in nationalParks , you
    use nationalParks[0] ➊ . To access the second item in nationalParks , you use
    nationalParks[1] .
  id: totrans-3154
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们正在访问国家公园的名称，并通过使用 `print` 将它们打印到屏幕上。要获取 `nationalParks` 中的第一个项目，你可以使用
    `nationalParks[0]` ➊ 。要访问 `nationalParks` 中的第二个项目，你可以使用 `nationalParks[1]`。
- en: '**WATCHING THE RANGE**'
  id: totrans-3155
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**观察范围**'
- en: One important point about arrays is that if you try to access an item at an
    index that’s higher than the last index in the array, you’ll get an error. In
    [Figure 6-2](text00016.html#ch06fig2) , you can see that nationalParks[3] (which
    would be the fourth item in the array) gives you an error because there are only
    three national parks in the array, indexed from 0 to 2.
  id: totrans-3156
  prefs: []
  type: TYPE_NORMAL
  zh: 关于数组有一个重要的点是，如果你尝试访问一个索引高于数组中最后一个索引的项目，你会收到一个错误。在[图 6-2](text00016.html#ch06fig2)中，你可以看到
    `nationalParks[3]`（这将是数组中的第四个项目）给出错误，因为数组中只有三个国家公园，索引从 0 到 2。
- en: As you can see, you get an error message that says Index out of range . If you
    try to access an item that doesn’t exist in your array, your app will crash!
  id: totrans-3157
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，你会收到一条错误信息，显示“索引超出范围”。如果你尝试访问数组中不存在的项目，应用程序将崩溃！
- en: '![Image](Image00119.jpg)'
  id: totrans-3158
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00119.jpg)'
- en: '*Figure 6-2: Trying to access an index in the array where nothing exists causes
    an error.*'
  id: totrans-3159
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 6-2：尝试访问数组中不存在的索引会导致错误。*'
- en: '**ADDING ITEMS TO AN ARRAY**'
  id: totrans-3160
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**向数组中添加项**'
- en: One way to change an array is to add new items to it. There are a few different
    ways to do this, so let’s take a look at each.
  id: totrans-3161
  prefs: []
  type: TYPE_NORMAL
  zh: 修改数组的一种方法是向其中添加新项。方法有几种，我们可以逐一了解。
- en: 'First, you can use an array’s append(_:) method. *Append* means to add something.
    Using append(_:) , you can add one new item to the end of your array. Say you
    go on another trip and visit the Badlands, and you want to add it to your list
    of national parks. To do that, add this code into your playground:'
  id: totrans-3162
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，你可以使用数组的 append(_:) 方法。*Append* 意味着添加某个元素。使用 append(_:) 方法，你可以将一个新项添加到数组的末尾。假设你又去了一次旅行，参观了坏lands国家公园，并且想把它加入到你的国家公园列表中。为了实现这一点，可以将以下代码添加到你的
    playground 中：
- en: '![](Image00120.jpg)'
  id: totrans-3163
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00120.jpg)'
- en: To use the append(_:) method, first write the name of your array followed by
    a period and then append . Then, put the item you want to add to your array inside
    the parentheses. In this case, you put "Badlands" inside the parentheses.
  id: totrans-3164
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用 append(_:) 方法，首先写出你的数组名，后面跟上一个句点，然后是 append。接着，将你想要添加到数组的项放在括号内。在这个例子中，你将
    "Badlands" 放入括号中。
- en: 'If you want to add something at a specific place in your array, use the array’s
    insert(_:at:) method instead. This method takes two arguments: the item that you
    want to insert and the index of where it should go in the array. (We’ll discuss
    arguments in more detail in [Chapter 7](text00017.html#ch07) .)'
  id: totrans-3165
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想在数组中的特定位置添加元素，可以改用数组的 insert(_:at:) 方法。此方法需要两个参数：你想插入的项和它应该插入到数组中的索引位置。（我们将在[第7章](text00017.html#ch07)
    中更详细地讨论参数。）
- en: 'Let’s say you totally forgot that you went to the Petrified Forest right after
    you visited the Grand Canyon, and you want to update your nationalParks array
    so it displays the parks in the order in which you visited them. To update your
    array, you could use the insert(_:at:) method to put the Petrified Forest in the
    right position:'
  id: totrans-3166
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你完全忘记了自己是在参观大峡谷后才去的 Petrified Forest，并且你想更新你的 nationalParks 数组，以显示你参观的公园的顺序。为了更新数组，你可以使用
    insert(_:at:) 方法，将 Petrified Forest 放到正确的位置：
- en: '![](Image00121.jpg)'
  id: totrans-3167
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00121.jpg)'
- en: When you insert a new item at index 3, everything that was in the array at index
    3 or higher gets scooted over to make room for the new item. That means the item
    that was at index 3 is now at index 4, the item that was at index 4 is now at
    index 5, and so on. After you add the Petrified Forest, nationalParks is now ["Acadia",
    "Zion", "Grand Canyon", "Petrified Forest", "Badlands"] .
  id: totrans-3168
  prefs: []
  type: TYPE_NORMAL
  zh: 当你在索引 3 处插入一个新项时，数组中从索引 3 或更高位置的所有元素都会被向后移动，为新项腾出空间。这意味着原本在索引 3 处的项现在会被移动到索引
    4，原本在索引 4 处的项会被移动到索引 5，以此类推。在你添加了 Petrified Forest 后，nationalParks 现在变成了 ["Acadia",
    "Zion", "Grand Canyon", "Petrified Forest", "Badlands"]。
- en: '**COMBINING ARRAYS**'
  id: totrans-3169
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**合并数组**'
- en: 'Not only can you add new items to an array, but you can also add two arrays
    together using the + and += operators. Let’s say that you have the ingredients
    for a fruit smoothie in two arrays:'
  id: totrans-3170
  prefs: []
  type: TYPE_NORMAL
  zh: 你不仅可以向数组中添加新项，还可以使用 + 和 += 操作符将两个数组合并。假设你有两个数组，分别包含制作水果果昔所需的配料：
- en: '![](Image00122.jpg)'
  id: totrans-3171
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00122.jpg)'
- en: Now you can make a delicious smoothie by adding the fruits and liquids arrays.
  id: totrans-3172
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你可以通过将水果和液体数组合并，制作出美味的果昔了。
- en: '![](Image00123.jpg)'
  id: totrans-3173
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00123.jpg)'
- en: The order of the ingredients in smoothie is the same as the order in fruits
    and liquids . If you created smoothie with liquids + fruits , then the liquids
    would come first.
  id: totrans-3174
  prefs: []
  type: TYPE_NORMAL
  zh: 果昔中的配料顺序与水果和液体的顺序相同。如果你创建的果昔是液体+水果的顺序，那么液体会排在前面。
- en: 'You use the += operator to add an array to the end of your array. Add some
    whipped cream as follows for extra yumminess:'
  id: totrans-3175
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用 += 操作符将一个数组添加到另一个数组的末尾。为了让果昔更加美味，可以按如下方式添加一些奶油：
- en: '![](Image00124.jpg)'
  id: totrans-3176
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00124.jpg)'
- en: Note that ["whipped cream"] is an array even though it has a single item in
    it. When you’re using += to append something to an array, you have to make sure
    you’re only trying to add another array. If you were to just write the string
    "whipped cream" without the square brackets around it, you would get an error.
  id: totrans-3177
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，["whipped cream"] 是一个数组，即使它只有一个元素。当你使用 += 来向数组添加内容时，必须确保你只是在尝试添加另一个数组。如果你只写字符串
    "whipped cream" 而不加上方括号，就会出现错误。
- en: '![Image](Image00125.jpg)'
  id: totrans-3178
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00125.jpg)'
- en: '**REMOVING ITEMS FROM AN ARRAY**'
  id: totrans-3179
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**从数组中移除项**'
- en: 'There are several methods for removing items from an array. Let’s start by
    looking at the array’s removeLast() method. As you might have guessed from its
    name, removeLast() removes the last item from your array. Let’s try it out with
    a shoppingList array:'
  id: totrans-3180
  prefs: []
  type: TYPE_NORMAL
  zh: 有几种方法可以从数组中删除项。让我们从数组的removeLast()方法开始。正如你从它的名字中猜到的，removeLast()会删除数组中的最后一项。让我们用一个shoppingList数组来试试：
- en: '![](Image00126.jpg)'
  id: totrans-3181
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00126.jpg)'
- en: Neat! Note that the removeLast() method returns the removed item, so you can
    store it in a new constant or variable if you want.
  id: totrans-3182
  prefs: []
  type: TYPE_NORMAL
  zh: 很棒！请注意，removeLast()方法会返回被删除的项，因此如果你需要，可以将其存储在新的常量或变量中。
- en: 'You can also remove an item from a specific index by using the remove(at:)
    method. Let’s say that your mom doesn’t want you buying any candy and takes that
    off the list:'
  id: totrans-3183
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以使用remove(at:)方法从特定索引删除一个项。假设你妈妈不想让你买糖果，并把它从列表中删除：
- en: '![Image](Image00127.jpg)![](Image00128.jpg)'
  id: totrans-3184
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00127.jpg)![](Image00128.jpg)'
- en: Just like when we added an item to the middle of our array and all the items
    scooted over to make room, if you remove an item from the middle of an array,
    the rest of the items will scoot back to fill in that empty space. The "apples"
    item that was at index 3 is now at index 2, where "candy" was.
  id: totrans-3185
  prefs: []
  type: TYPE_NORMAL
  zh: 就像我们在数组中间添加项时，所有的项都会移动以腾出空间一样，如果你从数组的中间删除项，剩余的项会向前移动填补空白。原本位于索引3的“apples”项现在位于索引2的位置，原本在此处的是“candy”。
- en: 'You can also remove all items from an array with removeAll() . Try entering
    this into your playground:'
  id: totrans-3186
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以使用removeAll()方法从数组中移除所有项。试试在你的Playground中输入这个：
- en: '![](Image00129.jpg)'
  id: totrans-3187
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00129.jpg)'
- en: 'Note that trying to remove an item at an index that doesn’t exist will give
    you an error:'
  id: totrans-3188
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，尝试删除一个不存在的索引位置的项会导致错误：
- en: '![](Image00130.jpg)'
  id: totrans-3189
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00130.jpg)'
- en: Our array doesn’t have this many items (in fact, now it’s empty!), so this throws
    an error. We’ll also get an error if we use removeLast() on our empty array, because
    there’s nothing in it—there’s no last index at all! However, removeAll() is always
    safe to use, even on an empty array.
  id: totrans-3190
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的数组没有这么多项（实际上现在它是空的！），因此会抛出错误。如果我们在空数组上使用removeLast()，也会出现错误，因为数组里没有任何东西——根本没有最后一个索引！然而，removeAll()方法在空数组上使用时始终是安全的。
- en: '**REPLACING ITEMS IN AN ARRAY**'
  id: totrans-3191
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**替换数组中的项**'
- en: 'To replace an item in an array, you set the index of the array to the new value,
    as shown here:'
  id: totrans-3192
  prefs: []
  type: TYPE_NORMAL
  zh: 要替换数组中的项，你可以将数组的索引设置为新值，如下所示：
- en: '![](Image00131.jpg)'
  id: totrans-3193
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00131.jpg)'
- en: At ➊ , we replaced the item at index 2 (the third item) with "Unicorn" because
    magical animals count as favorite animals, too! At ➋ , we replaced the item at
    index 0 (the first item) with "Bearded dragon" . No, that’s not a real dragon—it’s
    just a lizard!
  id: totrans-3194
  prefs: []
  type: TYPE_NORMAL
  zh: 在➊，我们将索引2（第三项）的位置的项替换为"Unicorn"，因为魔法动物也是最喜欢的动物！在➋，我们将索引0（第一项）的位置的项替换为"Bearded
    dragon"。不，这不是一条真正的龙——它只是一只蜥蜴！
- en: Like any time you’re working with array index numbers, you have to be sure an
    item exists in the array at that index before you change its value, or you will
    get an Index out of range error.
  id: totrans-3195
  prefs: []
  type: TYPE_NORMAL
  zh: 就像你在处理数组索引时一样，你必须确保该索引位置的项存在，否则会出现索引超出范围的错误。
- en: '[Figure 6-3](text00016.html#ch06fig3) shows the error that occurs if you try
    to add "Standard poodle" using favoriteAnimals[3] = "Standard poodle" . To add
    an item to the end of an array, you should use the append(_:) method or += , as
    we covered in “[Adding Items to an Array](text00016.html#ch06lev2sec5) ” on [page
    70](text00016.html#page_70) .'
  id: totrans-3196
  prefs: []
  type: TYPE_NORMAL
  zh: '[图6-3](text00016.html#ch06fig3)展示了如果你尝试通过favoriteAnimals[3] = "Standard poodle"添加"Standard
    poodle"时会发生的错误。要将项添加到数组末尾，应该使用append(_:)方法或+=，正如我们在《[向数组添加项](text00016.html#ch06lev2sec5)》中第[70页](text00016.html#page_70)讲到的那样。'
- en: '![Image](Image00132.jpg)'
  id: totrans-3197
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00132.jpg)'
- en: '*Figure 6-3: Don’t try to replace a value at an index beyond the existing array.*'
  id: totrans-3198
  prefs: []
  type: TYPE_NORMAL
  zh: '*图6-3：不要尝试替换一个超出现有数组索引的值。*'
- en: Now you know how to change arrays however you might need to. You can add items,
    take items away, or replace items. Next, we’ll look at how to use the properties
    of arrays to find out even more information about them.
  id: totrans-3199
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经知道如何根据需要更改数组了。你可以添加项、删除项或替换项。接下来，我们将看看如何使用数组的属性来获取更多关于数组的信息。
- en: '![Image](Image00133.jpg)'
  id: totrans-3200
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00133.jpg)'
- en: '**USING ARRAY PROPERTIES**'
  id: totrans-3201
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**使用数组属性**'
- en: In addition to methods like append(_:) and removeLast() , arrays also have *properties*
    . An array’s properties are variables or constants that contain some information
    about the array. Two really helpful properties that you might use are the Boolean
    property isEmpty and the integer property count .
  id: totrans-3202
  prefs: []
  type: TYPE_NORMAL
  zh: 除了像 append(_:) 和 removeLast() 这样的方法外，数组还有*属性*。数组的属性是包含一些关于数组信息的变量或常量。你可能会使用的两个非常有用的属性是布尔值属性
    isEmpty 和整数属性 count。
- en: The isEmpty property is true or false depending on whether the array is empty,
    and the count property will tell you how many items are in that array.
  id: totrans-3203
  prefs: []
  type: TYPE_NORMAL
  zh: isEmpty 属性是布尔值，取决于数组是否为空，而 count 属性会告诉你数组中有多少项。
- en: 'Check out how these two properties are used in the following if-else statement:'
  id: totrans-3204
  prefs: []
  type: TYPE_NORMAL
  zh: 查看以下 if-else 语句中如何使用这两个属性：
- en: '![Image](Image00134.jpg)'
  id: totrans-3205
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00134.jpg)'
- en: 'This if-else statement checks whether the array mySiblings is empty ➊ . If
    it is, then "I don''t have any siblings." is printed. But if there is something
    in the array, then the number of siblings that we have is printed: "I have 3 siblings."
    ➋ .'
  id: totrans-3206
  prefs: []
  type: TYPE_NORMAL
  zh: 这个 if-else 语句检查数组 mySiblings 是否为空 ➊。如果是，它会打印 "我没有兄弟姐妹。"。如果数组中有内容，则会打印我们有多少兄弟姐妹：“我有
    3 个兄弟姐妹。” ➋。
- en: '**LOOPING OVER AN ARRAY**'
  id: totrans-3207
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**循环遍历数组**'
- en: 'Sometimes when you’re working with arrays you might want to do something to
    every item in the array. You can use a for-in loop to do that! The following code
    will print every topping in a pizzaToppings array on a separate line:'
  id: totrans-3208
  prefs: []
  type: TYPE_NORMAL
  zh: 有时在处理数组时，你可能想对数组中的每个项目做些事情。你可以使用 for-in 循环来实现！以下代码将在单独的行上打印出 pizzaToppings 数组中的每个配料：
- en: '![Image](Image00135.jpg)'
  id: totrans-3209
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00135.jpg)'
- en: To write a for-in loop for the pizzaToppings array, we used the keyword for
    , followed by the constant topping , then the keyword in , and finally the name
    of our array, pizzaToppings . Then we put the statements that we want to run for
    each topping inside the braces of the for-in loop. The constant topping ➊ temporarily
    represents each pizza topping in the array as we loop through it. We could have
    chosen any name for this constant, but it’s a good idea to pick something that
    makes sense. You can see the output of this for-in loop in [Figure 6-4](text00016.html#ch06fig4)
    .
  id: totrans-3210
  prefs: []
  type: TYPE_NORMAL
  zh: 为了编写 pizzaToppings 数组的 for-in 循环，我们使用了关键字 for，后面跟着常量 topping，然后是关键字 in，最后是我们的数组名
    pizzaToppings。然后，我们将想要对每个配料执行的语句放在 for-in 循环的大括号内。常量 topping ➊ 临时表示我们循环中的每个披萨配料。我们可以为这个常量选择任何名字，但最好选一个有意义的名字。你可以在
    [图 6-4](text00016.html#ch06fig4) 中看到这个 for-in 循环的输出。
- en: '![Image](Image00136.jpg)'
  id: totrans-3211
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00136.jpg)'
- en: '*Figure 6-4: Output of the example for-in loop*'
  id: totrans-3212
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 6-4：示例 for-in 循环的输出*'
- en: '![Image](Image00137.jpg)'
  id: totrans-3213
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00137.jpg)'
- en: 'Using for-in loops is great for printing every value in an array. If you’re
    working with numbers, you can even use them to perform math operations on each
    item, which makes for some speedy calculations! The following code takes an array
    of numbers and calculates the square for each (the square of a number is that
    number multiplied by itself):'
  id: totrans-3214
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 for-in 循环非常适合打印数组中的每个值。如果你正在处理数字，你甚至可以使用它们对每个项目执行数学运算，这样就可以进行快速计算！以下代码接收一个数字数组并计算每个数字的平方（数字的平方是该数字与其本身相乘）：
- en: '![Image](Image00138.jpg)'
  id: totrans-3215
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00138.jpg)'
- en: '[Figure 6-5](text00016.html#ch06fig5) shows the results.'
  id: totrans-3216
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 6-5](text00016.html#ch06fig5) 显示了结果。'
- en: '![Image](Image00139.jpg)'
  id: totrans-3217
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00139.jpg)'
- en: '*Figure 6-5: Printing the squares for each number in the myNumbers array*'
  id: totrans-3218
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 6-5：打印 myNumbers 数组中每个数字的平方*'
- en: '**DICTIONARIES ARE KEY!**'
  id: totrans-3219
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**字典非常重要！**'
- en: A *dictionary* is also a collection of values, but instead of an ordered index,
    each value has its own *key* . Because there’s no index, the values are not stored
    in any particular order. To access values in a dictionary, you look them up by
    their key.
  id: totrans-3220
  prefs: []
  type: TYPE_NORMAL
  zh: '*字典*也是一种值的集合，但与有序索引不同，每个值都有自己的*键*。因为没有索引，值不会按任何特定顺序存储。要访问字典中的值，你需要通过键来查找它们。'
- en: A key must be unique. You can’t have the same key more than once in the same
    dictionary. If there were two identical keys and you asked the computer to give
    you the value for one of them, the computer wouldn’t know which one to choose!
  id: totrans-3221
  prefs: []
  type: TYPE_NORMAL
  zh: 键必须是唯一的。在同一个字典中不能有相同的键。如果有两个相同的键，你要求计算机返回其中一个的值时，计算机就不知道该选择哪个！
- en: Let’s take a look at how to make a dictionary and write keys that will help
    you find all the information you need.
  id: totrans-3222
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如何创建一个字典并编写键，以帮助你找到所有需要的信息。
- en: '![Image](Image00140.jpg)'
  id: totrans-3223
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00140.jpg)'
- en: '**INITIALIZING A DICTIONARY**'
  id: totrans-3224
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**初始化字典**'
- en: 'To create and initialize a dictionary, first write var and the name of your
    dictionary. Then write the keys and corresponding values inside a pair of square
    brackets, similar to an array. Let’s create a dictionary to store the names of
    a few US states. The key for each state will be its two-letter abbreviation:'
  id: totrans-3225
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建和初始化一个字典，首先写 `var` 和字典的名称。然后，在一对方括号内写入键和值，类似于数组的格式。我们来创建一个字典，存储一些美国州的名字。每个州的键将是它的两字母缩写：
- en: '![](Image00141.jpg)'
  id: totrans-3226
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00141.jpg)'
- en: As you can see, there’s a colon between each key and its value, and the key/value
    pairs are separated by commas.
  id: totrans-3227
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，每个键和值之间有一个冒号，键/值对之间用逗号分隔。
- en: Dictionaries are different from arrays in that they are *unordered* . Because
    of that, it’s likely that the order of the states that you see in your results
    pane ➋ is different from the order in which you entered your states ➊ . It might
    even be different than the order that’s printed in this book!
  id: totrans-3228
  prefs: []
  type: TYPE_NORMAL
  zh: 字典与数组不同，因为它们是*无序的*。因此，你在结果面板中看到的州的顺序➋很可能与你输入州的顺序➊不同，甚至可能与书中打印的顺序不同！
- en: As with arrays, you can use var to make a mutable dictionary or use let to make
    an immutable dictionary.
  id: totrans-3229
  prefs: []
  type: TYPE_NORMAL
  zh: 与数组一样，你可以使用 `var` 来创建一个可变字典，或者使用 `let` 来创建一个不可变字典。
- en: 'In Swift, all of the keys of a dictionary must be the same type, and all of
    the values of a dictionary must also be the same type, but the key type doesn’t
    have to match the value type. For example, if you wanted to store a collection
    of fractions, you could use doubles for the keys and strings for the values:'
  id: totrans-3230
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Swift 中，字典的所有键必须是相同的类型，字典的所有值也必须是相同的类型，但键的类型不必与值的类型匹配。例如，如果你想存储一组分数，你可以使用双精度浮点数作为键，字符串作为值：
- en: '![](Image00142.jpg)'
  id: totrans-3231
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00142.jpg)'
- en: In this dictionary, all of the keys must be doubles, and all of the values must
    be strings. Again, you’ll see that the order of the numbers in the results pane
    can be quite different from the order in which you wrote the fractions in your
    dictionary. This is fine because you don’t need to know the order to access anything.
    You can find any item that you need by its key. Let’s see how!
  id: totrans-3232
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个字典中，所有的键必须是双精度浮点数，所有的值必须是字符串。同样，你会发现结果面板中的数字顺序可能与你在字典中写入分数的顺序大不相同。这是可以的，因为你不需要知道顺序来访问任何内容。你可以通过键来查找你需要的任何项。让我们看看如何操作！
- en: '**ACCESSING VALUES IN A DICTIONARY**'
  id: totrans-3233
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**访问字典中的值**'
- en: 'Looking up a value in a dictionary is similar to how you access a value in
    an array except that you use a key inside the square brackets instead of an index,
    like this: usStates["TX"] .'
  id: totrans-3234
  prefs: []
  type: TYPE_NORMAL
  zh: 在字典中查找一个值与访问数组中的值类似，只是你在方括号内使用的是键而不是索引，像这样：usStates["TX"]。
- en: There is a big difference, however, in how Swift returns the values from a dictionary.
    When you access a value at an index of an array, you are simply given the value.
    When you access a value with a key in a dictionary, you are given an optional.
  id: totrans-3235
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，Swift 返回字典值的方式有一个很大的区别。当你通过数组的索引访问值时，你只是直接获得值。当你通过字典的键访问值时，你得到的是一个可选值。
- en: In [Chapter 5](text00015.html#ch05) , you learned that optionals might contain
    a value or might be nil . The reason Swift returns optionals when you’re looking
    up items in a dictionary is that the key you used might not exist in the dictionary,
    in which case there’s no value to access. Trying to access a value that doesn’t
    exist would give you a big fat error! To avoid that problem, Swift returns optionals.
    That means you need to unwrap any value you get out of a dictionary before you
    can do anything with it.
  id: totrans-3236
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第5章](text00015.html#ch05)中，你学习了可选值可能包含一个值，也可能为nil。当你在字典中查找项时，Swift 返回可选值的原因是你使用的键可能不存在于字典中，在这种情况下没有值可访问。尝试访问一个不存在的值会导致一个严重的错误！为了避免这个问题，Swift
    返回可选值。这意味着你需要解包从字典中获得的任何值，才能对其进行操作。
- en: 'To unwrap an optional, first you check whether it exists using an if-let statement,
    just like we did in [Chapter 5](text00015.html#ch05) . The following code shows
    you how to get a value out of a dictionary:'
  id: totrans-3237
  prefs: []
  type: TYPE_NORMAL
  zh: 要解包一个可选值，首先你要检查它是否存在，使用 `if-let` 语句，就像我们在[第5章](text00015.html#ch05)中做的那样。以下代码展示了如何从字典中获取一个值：
- en: '![Image](Image00143.jpg)'
  id: totrans-3238
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00143.jpg)'
- en: To retrieve "Texas" from the dictionary, we use if let to set a constant loneStarState
    to usStates["TX"] ➊ . Because we have this state in our dictionary, the line I
    have Texas in my dictionary. is printed. Next we try to access a state that is
    not in our dictionary by using the key usStates["FL"] ➋ . Thankfully, because
    we used an if-let statement, the program won’t crash when the computer can’t find
    this state. Instead, I don't have that state in my dictionary. is printed.
  id: totrans-3239
  prefs: []
  type: TYPE_NORMAL
  zh: 要从字典中检索"Texas"，我们使用`if let`将常量loneStarState设置为usStates["TX"] ➊ 。由于字典中包含这个州，打印出“I
    have Texas in my dictionary.” 接下来，我们尝试通过使用键usStates["FL"] ➋ 访问一个不在字典中的州。幸运的是，因为我们使用了`if-let`语句，当计算机找不到这个州时，程序不会崩溃。相反，打印出“I
    don't have that state in my dictionary.”。
- en: '**ADDING ITEMS TO A DICTIONARY**'
  id: totrans-3240
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**向字典中添加项目**'
- en: 'To add an item to a dictionary, first write the name of your dictionary and
    assign the new item to the key you want it to have in the dictionary. Let’s add
    "Minnesota" to our usStates dictionary:'
  id: totrans-3241
  prefs: []
  type: TYPE_NORMAL
  zh: 要向字典中添加一个项，首先写出字典的名称，并将新项赋给你希望它在字典中拥有的键。让我们把"Minnesota"添加到我们的usStates字典中：
- en: '![](Image00144.jpg)'
  id: totrans-3242
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00144.jpg)'
- en: 'Now when you look at usStates , you’ll see that it’s updated to ["MN": "Minnesota",
    "WA": "Washington", "MA": "Massachusetts", "TX": "Texas"] . Remember, because
    you don’t have to rely on indices, your new dictionary item might appear anywhere
    in the dictionary.'
  id: totrans-3243
  prefs: []
  type: TYPE_NORMAL
  zh: '现在当你查看usStates时，你会发现它已更新为["MN": "Minnesota", "WA": "Washington", "MA": "Massachusetts",
    "TX": "Texas"]。记住，因为你不需要依赖索引，所以新添加的字典项可能出现在字典中的任何位置。'
- en: '**REMOVING ITEMS FROM A DICTIONARY**'
  id: totrans-3244
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**从字典中删除项目**'
- en: Removing an item from a dictionary is quite simple; you do so by setting the
    value to nil . Because the values in dictionaries are returned as optionals, you
    don’t have to worry about nil causing any problems in your dictionary.
  id: totrans-3245
  prefs: []
  type: TYPE_NORMAL
  zh: 从字典中删除一个项非常简单；你只需要将其值设为nil。因为字典中的值是可选类型，所以你不必担心nil会导致字典出现问题。
- en: '![](Image00145.jpg)'
  id: totrans-3246
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00145.jpg)'
- en: 'You can see that after you remove the value at the key "MA" , usStates is updated
    to ["MN": "Minnesota", "WA": "Washington", "TX": "Texas"] . Remember that nil
    is special and means that there’s no value at all. That’s why you don’t see "MA":
    nil in our dictionary.'
  id: totrans-3247
  prefs: []
  type: TYPE_NORMAL
  zh: '你可以看到，在删除键"MA"的值后，usStates已更新为["MN": "Minnesota", "WA": "Washington", "TX":
    "Texas"]。记住，nil是特殊的，意味着没有值。这就是为什么你在字典中看不到"MA": nil的原因。'
- en: '**REPLACING ITEMS IN A DICTIONARY**'
  id: totrans-3248
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**替换字典中的项**'
- en: 'Replacing an item in a dictionary is also easy. It works the same was as replacing
    an item in an array. You just set the item that you want to replace to something
    else. Say you create a dictionary of fruit colors:'
  id: totrans-3249
  prefs: []
  type: TYPE_NORMAL
  zh: 替换字典中的项也很简单。它与替换数组中的项一样。你只需要将你想替换的项设为其他值。例如，你创建一个水果颜色的字典：
- en: '![](Image00146.jpg)'
  id: totrans-3250
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00146.jpg)'
- en: At first we had the value "apple" for "red" , but then we decided that "raspberry"
    is a better fruit to use since sometimes apples are green or yellow. To replace
    "apple" with "raspberry" , we set colorFruits["red"] to its new value ➊ .
  id: totrans-3251
  prefs: []
  type: TYPE_NORMAL
  zh: 起初我们为"red"赋值"apple"，但后来我们决定使用"raspberry"，因为有时候苹果是绿色或黄色的。为了将"apple"替换为"raspberry"，我们将colorFruits["red"]的值设为新的值
    ➊ 。
- en: You may remember that this is the same way we entered a new value into a dictionary.
    If the key already exists in the dictionary, then the value for that key is replaced.
    If the key doesn’t already exist, then the new key/value pair will be added to
    the dictionary.
  id: totrans-3252
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能记得，这是我们将新值输入字典的相同方式。如果键已经存在于字典中，那么该键的值会被替换。如果该键在字典中不存在，那么新的键值对将被添加到字典中。
- en: '![Image](Image00147.jpg)'
  id: totrans-3253
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00147.jpg)'
- en: '**USING DICTIONARY PROPERTIES**'
  id: totrans-3254
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**使用字典属性**'
- en: 'Like an array, a dictionary also has an isEmpty property and a count property.
    For example, the following code shows how you can use the isEmpty property to
    check if a dictionary is empty, and if it isn’t empty, the count property checks
    how many items you have. Imagine you have a basket of fruit for sale. You can
    use these properties to help you keep track of everything:'
  id: totrans-3255
  prefs: []
  type: TYPE_NORMAL
  zh: 像数组一样，字典也有`isEmpty`属性和`count`属性。例如，以下代码展示了如何使用`isEmpty`属性来检查字典是否为空，如果不为空，`count`属性可以检查字典中有多少项。假设你有一篮子待售的水果。你可以利用这些属性来帮助你跟踪所有的水果：
- en: '![Image](Image00148.jpg)'
  id: totrans-3256
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00148.jpg)'
- en: 'A dictionary also has two special properties: keys , which contains all of
    the dictionary’s keys, and values , which contains all of its values. We’ll use
    these two properties when we loop through the dictionary.'
  id: totrans-3257
  prefs: []
  type: TYPE_NORMAL
  zh: 字典还有两个特殊的属性：`keys`，它包含字典的所有键，以及`values`，它包含字典的所有值。我们在遍历字典时会使用这两个属性。
- en: Let’s write some code that loops through our fruit baskets and prints the price
    of each fruit.
  id: totrans-3258
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们写一些代码，遍历我们的水果篮并打印每个水果的价格。
- en: '**LOOPING OVER A DICTIONARY**'
  id: totrans-3259
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**遍历字典**'
- en: 'You can loop through a dictionary using a for-in loop. Because each item has
    a key and a value, you can do this in two different ways. This is how to loop
    through a dictionary using its keys:'
  id: totrans-3260
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用for-in循环遍历字典。由于每个条目都有一个键和值，你可以通过两种不同的方式来实现。这是使用键遍历字典的方法：
- en: '![Image](Image00149.jpg)'
  id: totrans-3261
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00149.jpg)'
- en: Here we use the dictionary’s keys property ➊ to loop through fruitBasket and
    print its contents. We start by writing the keyword for , followed by a constant
    name fruit for the dictionary key, the keyword in , the dictionary name, a period,
    and keys .
  id: totrans-3262
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们使用字典的keys属性 ➊ 来遍历fruitBasket并打印其内容。我们首先写出for关键字，后跟字典键的常量名fruit，再写in关键字，字典名，句点，以及keys。
- en: Inside the braces of our for-in loop, we have access to both the key, which
    we call fruit ➋ , and the value at that key when we force-unwrap its contents
    with fruitBasket[fruit]! ➌ . That value will be the fruit’s price.
  id: totrans-3263
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的for-in循环的大括号内，我们可以访问到键（我们称之为fruit ➋ ）和该键的值，当我们通过fruitBasket[fruit]! 强制解包其内容时
    ➌ 。这个值就是水果的价格。
- en: In this case, it’s safe to force-unwrap the value using an exclamation point
    because we know that the fruit key we’re using is definitely inside the dictionary.
  id: totrans-3264
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，使用感叹号强制解包值是安全的，因为我们知道我们使用的fruit键肯定在字典内。
- en: Any code we put inside the for-in loop will run once for every key in our dictionary.
    So you should see the print statement display three times.
  id: totrans-3265
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在for-in循环内放置的任何代码都会针对字典中的每个键运行一次。因此你应该看到打印语句显示三次。
- en: 'We can also loop through the dictionary using its values property:'
  id: totrans-3266
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以通过字典的values属性来进行遍历：
- en: '![Image](Image00150.jpg)'
  id: totrans-3267
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00150.jpg)'
- en: We use the same style of for-in loop, but now we use a constant to refer to
    each value, which we call price , in the values property. When looping through
    values, we don’t have access to the keys from inside the loop.
  id: totrans-3268
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用相同类型的for-in循环，但现在我们使用常量来引用values属性中的每个值，称之为price。在遍历values时，我们无法从循环内部访问到键。
- en: Another difference to note is that price is not an optional because it’s accessed
    directly as a value in the fruitBasket dictionary. That means we don’t have to
    unwrap it. You should still see the print statement printed three times. [Figure
    6-6](text00016.html#ch06fig6) shows the output of both loops.
  id: totrans-3269
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个需要注意的区别是，价格不是可选的，因为它直接作为值访问自fruitBasket字典。这意味着我们不需要解包它。你仍然应该看到打印语句打印三次。[图6-6](text00016.html#ch06fig6)展示了两个循环的输出。
- en: '![Image](Image00151.jpg)'
  id: totrans-3270
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00151.jpg)'
- en: '*Figure 6-6: Looping through the keys and values of a dictionary with a for-in
    loop*'
  id: totrans-3271
  prefs: []
  type: TYPE_NORMAL
  zh: '*图6-6：使用for-in循环遍历字典的键和值*'
- en: The order of your results might be slightly different from ours. That’s because
    the items in a dictionary aren’t in a numbered order like they are in an array!
    And because the order is not guaranteed, you might see a different order printed
    if you run the same code again.
  id: totrans-3272
  prefs: []
  type: TYPE_NORMAL
  zh: 你的结果顺序可能会与我们的稍有不同。那是因为字典中的项目不像数组那样按顺序编号！由于顺序不保证，如果你重新运行相同的代码，可能会看到不同的顺序输出。
- en: '**WHAT YOU LEARNED**'
  id: totrans-3273
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**你学到了什么**'
- en: In this chapter, you learned how to store collections of items in an array and
    in a dictionary. To store items in an ordered list, you would use an array and
    look up each item by its index. If you wanted to store items by key instead, you
    would use a dictionary.
  id: totrans-3274
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你学习了如何将项目存储在数组和字典中。要将项目存储在有序列表中，你将使用数组并通过索引查找每个项目。如果你想通过键来存储项目，你将使用字典。
- en: Knowing about arrays and dictionaries and how to use them is a powerful building
    block for almost any programming language. Next we will learn about functions,
    another very powerful tool. Functions are blocks of code that you create and name
    to perform a specific job. After you have written a function, you can use its
    name to call it from almost anywhere in your program.
  id: totrans-3275
  prefs: []
  type: TYPE_NORMAL
  zh: 了解数组和字典以及如何使用它们，是几乎任何编程语言中一个强大的构建块。接下来我们将学习函数，另一个非常强大的工具。函数是你创建并命名的代码块，用来执行特定的任务。编写了一个函数之后，你可以通过它的名称从程序中的几乎任何地方调用它。
- en: 'Let’s say you want to access an item in your array and use it in your program.
    Your friend asks you to tell them all about your travels, so you want to use the
    names of the national parks that you stored in the array. To access an item in
    your array, write the array name followed by the item’s index inside square brackets:'
  id: totrans-3276
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你想要访问数组中的某个元素，并在你的程序中使用它。你的朋友要求你告诉他们所有旅行的经历，所以你想使用你存储在数组中的国家公园名称。要访问数组中的某个元素，写下数组的名称，然后在方括号中写出该元素的索引：
- en: '![](Image00118.jpg)'
  id: totrans-3277
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00118.jpg)'
- en: In this example, we are accessing the names of the national parks and then printing
    them to the screen using print . To get the first item in nationalParks , you
    use nationalParks[0] ➊ . To access the second item in nationalParks , you use
    nationalParks[1] .
  id: totrans-3278
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们访问国家公园的名称，然后使用 print 将它们打印到屏幕上。要获取 nationalParks 中的第一个元素，你使用 nationalParks[0]
    ➊。要访问 nationalParks 中的第二个元素，你使用 nationalParks[1]。
- en: '**WATCHING THE RANGE**'
  id: totrans-3279
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**观察范围**'
- en: One important point about arrays is that if you try to access an item at an
    index that’s higher than the last index in the array, you’ll get an error. In
    [Figure 6-2](text00016.html#ch06fig2) , you can see that nationalParks[3] (which
    would be the fourth item in the array) gives you an error because there are only
    three national parks in the array, indexed from 0 to 2.
  id: totrans-3280
  prefs: []
  type: TYPE_NORMAL
  zh: 关于数组的一个重要事项是，如果你尝试访问一个索引超出数组最后一个索引的位置，你会得到一个错误。在[图6-2](text00016.html#ch06fig2)中，你可以看到
    nationalParks[3]（这将是数组中的第四个元素）会出错，因为数组中只有三个国家公园，索引从0到2。
- en: As you can see, you get an error message that says Index out of range . If you
    try to access an item that doesn’t exist in your array, your app will crash!
  id: totrans-3281
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，你会得到一个错误信息，显示“索引超出范围”。如果你尝试访问数组中不存在的元素，你的应用程序将崩溃！
- en: '![Image](Image00119.jpg)'
  id: totrans-3282
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00119.jpg)'
- en: '*Figure 6-2: Trying to access an index in the array where nothing exists causes
    an error.*'
  id: totrans-3283
  prefs: []
  type: TYPE_NORMAL
  zh: '*图6-2：尝试访问数组中不存在的索引会导致错误。*'
- en: '**ADDING ITEMS TO AN ARRAY**'
  id: totrans-3284
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**向数组添加元素**'
- en: One way to change an array is to add new items to it. There are a few different
    ways to do this, so let’s take a look at each.
  id: totrans-3285
  prefs: []
  type: TYPE_NORMAL
  zh: 更改数组的一种方式是向其中添加新元素。有几种不同的方式来实现这一点，所以我们来看看每种方法。
- en: 'First, you can use an array’s append(_:) method. *Append* means to add something.
    Using append(_:) , you can add one new item to the end of your array. Say you
    go on another trip and visit the Badlands, and you want to add it to your list
    of national parks. To do that, add this code into your playground:'
  id: totrans-3286
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，你可以使用数组的 append(_:) 方法。*Append* 意思是添加某个元素。使用 append(_:) ，你可以将一个新项目添加到数组的末尾。假设你又去旅行，访问了坏lands（Badlands），并且想将其添加到你的国家公园列表中。为此，将以下代码添加到你的
    Playground 中：
- en: '![](Image00120.jpg)'
  id: totrans-3287
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00120.jpg)'
- en: To use the append(_:) method, first write the name of your array followed by
    a period and then append . Then, put the item you want to add to your array inside
    the parentheses. In this case, you put "Badlands" inside the parentheses.
  id: totrans-3288
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用 append(_:) 方法，首先写下数组的名称，后跟一个句点，然后再写 append。接着，将你想要添加到数组中的项目放在括号内。在这种情况下，你将
    "Badlands" 放入括号中。
- en: 'If you want to add something at a specific place in your array, use the array’s
    insert(_:at:) method instead. This method takes two arguments: the item that you
    want to insert and the index of where it should go in the array. (We’ll discuss
    arguments in more detail in [Chapter 7](text00017.html#ch07) .)'
  id: totrans-3289
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想在数组的特定位置添加某个元素，可以使用数组的 insert(_:at:) 方法。这个方法需要两个参数：你想插入的元素和它应该在数组中出现的位置的索引。（我们将在[第7章](text00017.html#ch07)中详细讨论参数。）
- en: 'Let’s say you totally forgot that you went to the Petrified Forest right after
    you visited the Grand Canyon, and you want to update your nationalParks array
    so it displays the parks in the order in which you visited them. To update your
    array, you could use the insert(_:at:) method to put the Petrified Forest in the
    right position:'
  id: totrans-3290
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你完全忘记了在访问大峡谷之后，你去了化石林，你想更新你的 nationalParks 数组，以便按你访问的顺序显示这些公园。为了更新你的数组，你可以使用
    insert(_:at:) 方法将化石林放在正确的位置：
- en: '![](Image00121.jpg)'
  id: totrans-3291
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00121.jpg)'
- en: When you insert a new item at index 3, everything that was in the array at index
    3 or higher gets scooted over to make room for the new item. That means the item
    that was at index 3 is now at index 4, the item that was at index 4 is now at
    index 5, and so on. After you add the Petrified Forest, nationalParks is now ["Acadia",
    "Zion", "Grand Canyon", "Petrified Forest", "Badlands"] .
  id: totrans-3292
  prefs: []
  type: TYPE_NORMAL
  zh: 当你在索引3的位置插入新项时，数组中索引为3或更高的所有项都会向后移动，为新项腾出空间。这意味着原本在索引3的项现在移到索引4，原本在索引4的项现在移到索引5，依此类推。在你添加了Petrified
    Forest后，nationalParks现在是["Acadia", "Zion", "Grand Canyon", "Petrified Forest",
    "Badlands"]。
- en: '**COMBINING ARRAYS**'
  id: totrans-3293
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**合并数组**'
- en: 'Not only can you add new items to an array, but you can also add two arrays
    together using the + and += operators. Let’s say that you have the ingredients
    for a fruit smoothie in two arrays:'
  id: totrans-3294
  prefs: []
  type: TYPE_NORMAL
  zh: 你不仅可以向数组中添加新项，还可以使用+和+=操作符将两个数组合并。假设你有两个数组分别包含制作水果平滑饮品的成分：
- en: '![](Image00122.jpg)'
  id: totrans-3295
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00122.jpg)'
- en: Now you can make a delicious smoothie by adding the fruits and liquids arrays.
  id: totrans-3296
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你可以通过将水果和液体数组合并来制作一杯美味的平滑饮品。
- en: '![](Image00123.jpg)'
  id: totrans-3297
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00123.jpg)'
- en: The order of the ingredients in smoothie is the same as the order in fruits
    and liquids . If you created smoothie with liquids + fruits , then the liquids
    would come first.
  id: totrans-3298
  prefs: []
  type: TYPE_NORMAL
  zh: 平滑饮品中成分的顺序与水果和液体的顺序相同。如果你是通过液体+水果的方式制作平滑饮品的，那么液体会排在前面。
- en: 'You use the += operator to add an array to the end of your array. Add some
    whipped cream as follows for extra yumminess:'
  id: totrans-3299
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用+=操作符将一个数组添加到另一个数组的末尾。为了增加一些美味的鲜奶油，可以如下操作：
- en: '![](Image00124.jpg)'
  id: totrans-3300
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00124.jpg)'
- en: Note that ["whipped cream"] is an array even though it has a single item in
    it. When you’re using += to append something to an array, you have to make sure
    you’re only trying to add another array. If you were to just write the string
    "whipped cream" without the square brackets around it, you would get an error.
  id: totrans-3301
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，["whipped cream"]虽然只有一个项，但它仍然是一个数组。当你使用+=来追加某项到数组时，必须确保你只是在尝试添加另一个数组。如果你只是写下字符串"whipped
    cream"而不加方括号，就会出现错误。
- en: '![Image](Image00125.jpg)'
  id: totrans-3302
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00125.jpg)'
- en: '**REMOVING ITEMS FROM AN ARRAY**'
  id: totrans-3303
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**从数组中移除项**'
- en: 'There are several methods for removing items from an array. Let’s start by
    looking at the array’s removeLast() method. As you might have guessed from its
    name, removeLast() removes the last item from your array. Let’s try it out with
    a shoppingList array:'
  id: totrans-3304
  prefs: []
  type: TYPE_NORMAL
  zh: 有多种方法可以从数组中移除项。让我们先看看数组的removeLast()方法。正如你从名字中可能猜到的，removeLast()会移除数组中的最后一项。让我们用一个shoppingList数组来试试看：
- en: '![](Image00126.jpg)'
  id: totrans-3305
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00126.jpg)'
- en: Neat! Note that the removeLast() method returns the removed item, so you can
    store it in a new constant or variable if you want.
  id: totrans-3306
  prefs: []
  type: TYPE_NORMAL
  zh: 真棒！注意，removeLast()方法会返回被移除的项，所以如果你愿意，可以将其存储在一个新的常量或变量中。
- en: 'You can also remove an item from a specific index by using the remove(at:)
    method. Let’s say that your mom doesn’t want you buying any candy and takes that
    off the list:'
  id: totrans-3307
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以使用remove(at:)方法从特定索引移除某项。假设你的妈妈不希望你买糖果，并从清单中把它拿掉：
- en: '![Image](Image00127.jpg)![](Image00128.jpg)'
  id: totrans-3308
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00127.jpg)![](Image00128.jpg)'
- en: Just like when we added an item to the middle of our array and all the items
    scooted over to make room, if you remove an item from the middle of an array,
    the rest of the items will scoot back to fill in that empty space. The "apples"
    item that was at index 3 is now at index 2, where "candy" was.
  id: totrans-3309
  prefs: []
  type: TYPE_NORMAL
  zh: 就像我们在数组中间添加项时，所有项都会向后移动腾出空间一样，如果你从数组中间移除项，剩下的项会向前填补空缺。原本在索引3位置的"apples"项现在会出现在索引2位置，那里曾经是"candy"。
- en: 'You can also remove all items from an array with removeAll() . Try entering
    this into your playground:'
  id: totrans-3310
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以使用removeAll()从数组中移除所有项。试试在你的游乐场中输入这个：
- en: '![](Image00129.jpg)'
  id: totrans-3311
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00129.jpg)'
- en: 'Note that trying to remove an item at an index that doesn’t exist will give
    you an error:'
  id: totrans-3312
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，尝试移除一个不存在索引处的项会导致错误：
- en: '![](Image00130.jpg)'
  id: totrans-3313
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00130.jpg)'
- en: Our array doesn’t have this many items (in fact, now it’s empty!), so this throws
    an error. We’ll also get an error if we use removeLast() on our empty array, because
    there’s nothing in it—there’s no last index at all! However, removeAll() is always
    safe to use, even on an empty array.
  id: totrans-3314
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的数组没有这么多项（事实上，现在它是空的！），所以这会抛出一个错误。如果我们在空数组上使用removeLast()，也会出错，因为数组中没有任何内容——根本没有最后一个索引！不过，removeAll()总是可以安全使用，即使是在空数组上。
- en: '**REPLACING ITEMS IN AN ARRAY**'
  id: totrans-3315
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**替换数组中的项**'
- en: 'To replace an item in an array, you set the index of the array to the new value,
    as shown here:'
  id: totrans-3316
  prefs: []
  type: TYPE_NORMAL
  zh: 要替换数组中的一项，你只需将数组中该索引位置的值设置为新值，如下所示：
- en: '![](Image00131.jpg)'
  id: totrans-3317
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00131.jpg)'
- en: At ➊ , we replaced the item at index 2 (the third item) with "Unicorn" because
    magical animals count as favorite animals, too! At ➋ , we replaced the item at
    index 0 (the first item) with "Bearded dragon" . No, that’s not a real dragon—it’s
    just a lizard!
  id: totrans-3318
  prefs: []
  type: TYPE_NORMAL
  zh: 在 ➊ 处，我们将索引 2 （第三项）的位置的项替换为“独角兽”，因为魔法动物也算是最喜欢的动物！在 ➋ 处，我们将索引 0 （第一项）的位置的项替换为“胡须蜥蜴”。不，那不是一条真正的龙——它只是一只蜥蜴！
- en: Like any time you’re working with array index numbers, you have to be sure an
    item exists in the array at that index before you change its value, or you will
    get an Index out of range error.
  id: totrans-3319
  prefs: []
  type: TYPE_NORMAL
  zh: 就像你在处理数组索引号时一样，在改变数组中特定索引的值之前，必须确保该位置上有项，否则你会遇到索引越界错误。
- en: '[Figure 6-3](text00016.html#ch06fig3) shows the error that occurs if you try
    to add "Standard poodle" using favoriteAnimals[3] = "Standard poodle" . To add
    an item to the end of an array, you should use the append(_:) method or += , as
    we covered in “[Adding Items to an Array](text00016.html#ch06lev2sec5) ” on [page
    70](text00016.html#page_70) .'
  id: totrans-3320
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 6-3](text00016.html#ch06fig3) 显示了如果你尝试通过 `favoriteAnimals[3] = "Standard
    poodle"` 添加“标准贵宾犬”时发生的错误。要将项添加到数组的末尾，应该使用 append(_:) 方法或 += ，正如我们在 “[向数组添加项](text00016.html#ch06lev2sec5)”
    的 [第 70 页](text00016.html#page_70) 中所讲解的那样。'
- en: '![Image](Image00132.jpg)'
  id: totrans-3321
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00132.jpg)'
- en: '*Figure 6-3: Don’t try to replace a value at an index beyond the existing array.*'
  id: totrans-3322
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 6-3：不要尝试在现有数组的索引之外替换值。*'
- en: Now you know how to change arrays however you might need to. You can add items,
    take items away, or replace items. Next, we’ll look at how to use the properties
    of arrays to find out even more information about them.
  id: totrans-3323
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你知道如何根据需要修改数组了。你可以添加项、删除项或替换项。接下来，我们将探讨如何使用数组的属性来获取更多关于数组的信息。
- en: '![Image](Image00133.jpg)'
  id: totrans-3324
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00133.jpg)'
- en: '**USING ARRAY PROPERTIES**'
  id: totrans-3325
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**使用数组属性**'
- en: In addition to methods like append(_:) and removeLast() , arrays also have *properties*
    . An array’s properties are variables or constants that contain some information
    about the array. Two really helpful properties that you might use are the Boolean
    property isEmpty and the integer property count .
  id: totrans-3326
  prefs: []
  type: TYPE_NORMAL
  zh: 除了像 append(_:) 和 removeLast() 这样的函数，数组还有 *属性*。数组的属性是包含数组信息的变量或常量。有两个非常有用的属性你可能会使用，它们分别是布尔属性
    isEmpty 和整数属性 count。
- en: The isEmpty property is true or false depending on whether the array is empty,
    and the count property will tell you how many items are in that array.
  id: totrans-3327
  prefs: []
  type: TYPE_NORMAL
  zh: isEmpty 属性的值为 true 或 false，取决于数组是否为空，而 count 属性将告诉你数组中有多少项。
- en: 'Check out how these two properties are used in the following if-else statement:'
  id: totrans-3328
  prefs: []
  type: TYPE_NORMAL
  zh: 查看以下 if-else 语句中这两个属性是如何使用的：
- en: '![Image](Image00134.jpg)'
  id: totrans-3329
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00134.jpg)'
- en: 'This if-else statement checks whether the array mySiblings is empty ➊ . If
    it is, then "I don''t have any siblings." is printed. But if there is something
    in the array, then the number of siblings that we have is printed: "I have 3 siblings."
    ➋ .'
  id: totrans-3330
  prefs: []
  type: TYPE_NORMAL
  zh: 这个 if-else 语句检查数组 mySiblings 是否为空 ➊ 。如果为空，则打印“我没有兄弟姐妹。”如果数组中有内容，则打印我们拥有的兄弟姐妹数量：“我有
    3 个兄弟姐妹。” ➋ 。
- en: '**LOOPING OVER AN ARRAY**'
  id: totrans-3331
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**遍历数组**'
- en: 'Sometimes when you’re working with arrays you might want to do something to
    every item in the array. You can use a for-in loop to do that! The following code
    will print every topping in a pizzaToppings array on a separate line:'
  id: totrans-3332
  prefs: []
  type: TYPE_NORMAL
  zh: 有时在处理数组时，你可能想对数组中的每一项做一些操作。你可以使用 for-in 循环来做到这一点！以下代码将会逐行打印 pizzaToppings 数组中的每一个配料：
- en: '![Image](Image00135.jpg)'
  id: totrans-3333
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00135.jpg)'
- en: To write a for-in loop for the pizzaToppings array, we used the keyword for
    , followed by the constant topping , then the keyword in , and finally the name
    of our array, pizzaToppings . Then we put the statements that we want to run for
    each topping inside the braces of the for-in loop. The constant topping ➊ temporarily
    represents each pizza topping in the array as we loop through it. We could have
    chosen any name for this constant, but it’s a good idea to pick something that
    makes sense. You can see the output of this for-in loop in [Figure 6-4](text00016.html#ch06fig4)
    .
  id: totrans-3334
  prefs: []
  type: TYPE_NORMAL
  zh: 要为 pizzaToppings 数组写一个 for-in 循环，我们使用了关键字 for，后面是常量 topping，然后是关键字 in，最后是我们的数组名称
    pizzaToppings。接着，我们将每个配料要执行的语句放在 for-in 循环的大括号内。常量 topping ➊ 在我们遍历数组时，临时代表数组中的每个比萨配料。我们可以为这个常量选择任何名称，但最好选择一个有意义的名字。你可以在
    [图 6-4](text00016.html#ch06fig4) 中看到这个 for-in 循环的输出。
- en: '![Image](Image00136.jpg)'
  id: totrans-3335
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00136.jpg)'
- en: '*Figure 6-4: Output of the example for-in loop*'
  id: totrans-3336
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 6-4：示例 for-in 循环的输出*'
- en: '![Image](Image00137.jpg)'
  id: totrans-3337
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00137.jpg)'
- en: 'Using for-in loops is great for printing every value in an array. If you’re
    working with numbers, you can even use them to perform math operations on each
    item, which makes for some speedy calculations! The following code takes an array
    of numbers and calculates the square for each (the square of a number is that
    number multiplied by itself):'
  id: totrans-3338
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `for-in` 循环非常适合打印数组中的每个值。如果你在处理数字，你甚至可以利用它们对每个项目进行数学运算，从而进行快速计算！下面的代码接收一个数字数组并计算每个数字的平方（一个数字的平方就是该数字与自身相乘）：
- en: '![Image](Image00138.jpg)'
  id: totrans-3339
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00138.jpg)'
- en: '[Figure 6-5](text00016.html#ch06fig5) shows the results.'
  id: totrans-3340
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 6-5](text00016.html#ch06fig5) 展示了结果。'
- en: '![Image](Image00139.jpg)'
  id: totrans-3341
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00139.jpg)'
- en: '*Figure 6-5: Printing the squares for each number in the myNumbers array*'
  id: totrans-3342
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 6-5：打印 myNumbers 数组中每个数字的平方*'
- en: '**DICTIONARIES ARE KEY!**'
  id: totrans-3343
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**字典是关键！**'
- en: A *dictionary* is also a collection of values, but instead of an ordered index,
    each value has its own *key* . Because there’s no index, the values are not stored
    in any particular order. To access values in a dictionary, you look them up by
    their key.
  id: totrans-3344
  prefs: []
  type: TYPE_NORMAL
  zh: '*字典* 也是一个值的集合，但不同于有序索引，每个值都有自己的*键*。由于没有索引，值没有按任何特定顺序存储。要访问字典中的值，你需要通过键来查找它们。'
- en: A key must be unique. You can’t have the same key more than once in the same
    dictionary. If there were two identical keys and you asked the computer to give
    you the value for one of them, the computer wouldn’t know which one to choose!
  id: totrans-3345
  prefs: []
  type: TYPE_NORMAL
  zh: 键必须是唯一的。你不能在同一个字典中有两个相同的键。如果有两个相同的键，而你要求计算机返回其中一个的值，计算机将不知道选择哪个！
- en: Let’s take a look at how to make a dictionary and write keys that will help
    you find all the information you need.
  id: totrans-3346
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看一下如何创建一个字典并编写键，以帮助你找到所有需要的信息。
- en: '![Image](Image00140.jpg)'
  id: totrans-3347
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00140.jpg)'
- en: '**INITIALIZING A DICTIONARY**'
  id: totrans-3348
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**初始化字典**'
- en: 'To create and initialize a dictionary, first write var and the name of your
    dictionary. Then write the keys and corresponding values inside a pair of square
    brackets, similar to an array. Let’s create a dictionary to store the names of
    a few US states. The key for each state will be its two-letter abbreviation:'
  id: totrans-3349
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建并初始化一个字典，首先写上 `var` 和字典的名称。然后在一对方括号内写入键和值的对应关系，类似于数组。让我们创建一个字典来存储一些美国州的名称。每个州的键将是它的两个字母的缩写：
- en: '![](Image00141.jpg)'
  id: totrans-3350
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00141.jpg)'
- en: As you can see, there’s a colon between each key and its value, and the key/value
    pairs are separated by commas.
  id: totrans-3351
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，每个键和值之间都有一个冒号，键/值对通过逗号分隔。
- en: Dictionaries are different from arrays in that they are *unordered* . Because
    of that, it’s likely that the order of the states that you see in your results
    pane ➋ is different from the order in which you entered your states ➊ . It might
    even be different than the order that’s printed in this book!
  id: totrans-3352
  prefs: []
  type: TYPE_NORMAL
  zh: 字典与数组不同，因为它们是*无序*的。因此，你在结果面板中看到的州的顺序➋可能与你输入州的顺序➊不同。甚至可能与本书中打印的顺序不同！
- en: As with arrays, you can use var to make a mutable dictionary or use let to make
    an immutable dictionary.
  id: totrans-3353
  prefs: []
  type: TYPE_NORMAL
  zh: 和数组一样，你可以使用 `var` 来创建一个可变字典，或者使用 `let` 来创建一个不可变字典。
- en: 'In Swift, all of the keys of a dictionary must be the same type, and all of
    the values of a dictionary must also be the same type, but the key type doesn’t
    have to match the value type. For example, if you wanted to store a collection
    of fractions, you could use doubles for the keys and strings for the values:'
  id: totrans-3354
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Swift 中，字典的所有键必须是相同类型，字典的所有值也必须是相同类型，但键的类型不必与值的类型匹配。例如，如果你想存储一个分数的集合，你可以使用双精度数（doubles）作为键，字符串（strings）作为值：
- en: '![](Image00142.jpg)'
  id: totrans-3355
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00142.jpg)'
- en: In this dictionary, all of the keys must be doubles, and all of the values must
    be strings. Again, you’ll see that the order of the numbers in the results pane
    can be quite different from the order in which you wrote the fractions in your
    dictionary. This is fine because you don’t need to know the order to access anything.
    You can find any item that you need by its key. Let’s see how!
  id: totrans-3356
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个字典中，所有的键必须是双精度数（doubles），所有的值必须是字符串（strings）。同样，你会发现结果面板中数字的顺序可能与在字典中写入分数的顺序大不相同。这没关系，因为你不需要知道顺序就能访问任何内容。你可以通过键来查找你需要的任何项目。我们来看看怎么做！
- en: '**ACCESSING VALUES IN A DICTIONARY**'
  id: totrans-3357
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**访问字典中的值**'
- en: 'Looking up a value in a dictionary is similar to how you access a value in
    an array except that you use a key inside the square brackets instead of an index,
    like this: usStates["TX"] .'
  id: totrans-3358
  prefs: []
  type: TYPE_NORMAL
  zh: 在字典中查找一个值类似于你如何访问数组中的值，不同之处在于，你使用的是方括号中的键，而不是索引，像这样：usStates["TX"]。
- en: There is a big difference, however, in how Swift returns the values from a dictionary.
    When you access a value at an index of an array, you are simply given the value.
    When you access a value with a key in a dictionary, you are given an optional.
  id: totrans-3359
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，Swift 从字典中返回值的方式有一个很大的区别。当你访问数组中的索引值时，你只是简单地获得该值。而当你通过字典中的键访问值时，你得到的是一个可选值。
- en: In [Chapter 5](text00015.html#ch05) , you learned that optionals might contain
    a value or might be nil . The reason Swift returns optionals when you’re looking
    up items in a dictionary is that the key you used might not exist in the dictionary,
    in which case there’s no value to access. Trying to access a value that doesn’t
    exist would give you a big fat error! To avoid that problem, Swift returns optionals.
    That means you need to unwrap any value you get out of a dictionary before you
    can do anything with it.
  id: totrans-3360
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第5章](text00015.html#ch05)中，你学习了可选值可能包含一个值，也可能是 nil。Swift 在查找字典中的项时返回可选值的原因是，你使用的键可能在字典中不存在，在这种情况下，没有值可供访问。尝试访问一个不存在的值会给你带来一个大错误！为避免这个问题，Swift
    返回可选值。这意味着，在你可以对字典中的任何值进行操作之前，需要先解包它。
- en: 'To unwrap an optional, first you check whether it exists using an if-let statement,
    just like we did in [Chapter 5](text00015.html#ch05) . The following code shows
    you how to get a value out of a dictionary:'
  id: totrans-3361
  prefs: []
  type: TYPE_NORMAL
  zh: 要解包一个可选值，首先使用 if-let 语句检查它是否存在，就像我们在[第5章](text00015.html#ch05)中做的那样。以下代码演示了如何从字典中获取值：
- en: '![Image](Image00143.jpg)'
  id: totrans-3362
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00143.jpg)'
- en: To retrieve "Texas" from the dictionary, we use if let to set a constant loneStarState
    to usStates["TX"] ➊ . Because we have this state in our dictionary, the line I
    have Texas in my dictionary. is printed. Next we try to access a state that is
    not in our dictionary by using the key usStates["FL"] ➋ . Thankfully, because
    we used an if-let statement, the program won’t crash when the computer can’t find
    this state. Instead, I don't have that state in my dictionary. is printed.
  id: totrans-3363
  prefs: []
  type: TYPE_NORMAL
  zh: 要从字典中检索“Texas”，我们使用 if let 将常量 loneStarState 设置为 usStates["TX"] ➊。因为我们在字典中有这个州，所以会打印出
    I have Texas in my dictionary.。接下来，我们尝试使用键 usStates["FL"] ➋ 访问一个不存在于字典中的州。幸运的是，由于我们使用了
    if-let 语句，当计算机无法找到该州时，程序不会崩溃。相反，会打印出 I don't have that state in my dictionary.。
- en: '**ADDING ITEMS TO A DICTIONARY**'
  id: totrans-3364
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**向字典中添加项**'
- en: 'To add an item to a dictionary, first write the name of your dictionary and
    assign the new item to the key you want it to have in the dictionary. Let’s add
    "Minnesota" to our usStates dictionary:'
  id: totrans-3365
  prefs: []
  type: TYPE_NORMAL
  zh: 要向字典中添加项，首先写出字典的名称，并将新项分配给你希望它在字典中具有的键。让我们向我们的 usStates 字典添加 "Minnesota"：
- en: '![](Image00144.jpg)'
  id: totrans-3366
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00144.jpg)'
- en: 'Now when you look at usStates , you’ll see that it’s updated to ["MN": "Minnesota",
    "WA": "Washington", "MA": "Massachusetts", "TX": "Texas"] . Remember, because
    you don’t have to rely on indices, your new dictionary item might appear anywhere
    in the dictionary.'
  id: totrans-3367
  prefs: []
  type: TYPE_NORMAL
  zh: '现在，当你查看 usStates 时，你会看到它已更新为 ["MN": "Minnesota", "WA": "Washington", "MA":
    "Massachusetts", "TX": "Texas"]。记住，因为你不需要依赖索引，你的新字典项可能会出现在字典中的任何位置。'
- en: '**REMOVING ITEMS FROM A DICTIONARY**'
  id: totrans-3368
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**从字典中删除项**'
- en: Removing an item from a dictionary is quite simple; you do so by setting the
    value to nil . Because the values in dictionaries are returned as optionals, you
    don’t have to worry about nil causing any problems in your dictionary.
  id: totrans-3369
  prefs: []
  type: TYPE_NORMAL
  zh: 从字典中删除项非常简单；你只需将该值设置为 nil。由于字典中的值以可选值的形式返回，因此你不需要担心 nil 会在字典中引起任何问题。
- en: '![](Image00145.jpg)'
  id: totrans-3370
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00145.jpg)'
- en: 'You can see that after you remove the value at the key "MA" , usStates is updated
    to ["MN": "Minnesota", "WA": "Washington", "TX": "Texas"] . Remember that nil
    is special and means that there’s no value at all. That’s why you don’t see "MA":
    nil in our dictionary.'
  id: totrans-3371
  prefs: []
  type: TYPE_NORMAL
  zh: '你可以看到，在删除了键为 "MA" 的值后，usStates 已更新为 ["MN": "Minnesota", "WA": "Washington",
    "TX": "Texas"]。记住，nil 是特殊的，意味着根本没有值。这就是为什么你在字典中看不到 "MA": nil 的原因。'
- en: '**REPLACING ITEMS IN A DICTIONARY**'
  id: totrans-3372
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**在字典中替换项**'
- en: 'Replacing an item in a dictionary is also easy. It works the same was as replacing
    an item in an array. You just set the item that you want to replace to something
    else. Say you create a dictionary of fruit colors:'
  id: totrans-3373
  prefs: []
  type: TYPE_NORMAL
  zh: 在字典中替换项也很简单。它与替换数组中的项方式相同。你只需将要替换的项设置为其他值。假设你创建了一个水果颜色的字典：
- en: '![](Image00146.jpg)'
  id: totrans-3374
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00146.jpg)'
- en: At first we had the value "apple" for "red" , but then we decided that "raspberry"
    is a better fruit to use since sometimes apples are green or yellow. To replace
    "apple" with "raspberry" , we set colorFruits["red"] to its new value ➊ .
  id: totrans-3375
  prefs: []
  type: TYPE_NORMAL
  zh: 最开始我们将值 "apple" 分配给 "red"，但后来我们决定使用 "raspberry" 作为更合适的水果，因为有时苹果是绿色或黄色的。为了将 "apple"
    替换为 "raspberry"，我们将 colorFruits["red"] 设置为它的新值 ➊。
- en: You may remember that this is the same way we entered a new value into a dictionary.
    If the key already exists in the dictionary, then the value for that key is replaced.
    If the key doesn’t already exist, then the new key/value pair will be added to
    the dictionary.
  id: totrans-3376
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能还记得这和我们向字典中添加新值的方式一样。如果键已经存在于字典中，那么该键的值会被替换。如果键不存在，则新的键值对将被添加到字典中。
- en: '![Image](Image00147.jpg)'
  id: totrans-3377
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00147.jpg)'
- en: '**USING DICTIONARY PROPERTIES**'
  id: totrans-3378
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**使用字典属性**'
- en: 'Like an array, a dictionary also has an isEmpty property and a count property.
    For example, the following code shows how you can use the isEmpty property to
    check if a dictionary is empty, and if it isn’t empty, the count property checks
    how many items you have. Imagine you have a basket of fruit for sale. You can
    use these properties to help you keep track of everything:'
  id: totrans-3379
  prefs: []
  type: TYPE_NORMAL
  zh: 像数组一样，字典也有一个 isEmpty 属性和一个 count 属性。例如，以下代码展示了如何使用 isEmpty 属性来检查字典是否为空，如果不为空，count
    属性会检查字典中的项数。假设你有一个水果篮子待售，你可以使用这些属性来帮助你跟踪所有内容：
- en: '![Image](Image00148.jpg)'
  id: totrans-3380
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00148.jpg)'
- en: 'A dictionary also has two special properties: keys , which contains all of
    the dictionary’s keys, and values , which contains all of its values. We’ll use
    these two properties when we loop through the dictionary.'
  id: totrans-3381
  prefs: []
  type: TYPE_NORMAL
  zh: 字典还有两个特殊属性：keys，包含字典的所有键；values，包含字典的所有值。在遍历字典时，我们将使用这两个属性。
- en: Let’s write some code that loops through our fruit baskets and prints the price
    of each fruit.
  id: totrans-3382
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们写些代码来遍历我们的水果篮子并打印每个水果的价格。
- en: '**LOOPING OVER A DICTIONARY**'
  id: totrans-3383
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**遍历字典**'
- en: 'You can loop through a dictionary using a for-in loop. Because each item has
    a key and a value, you can do this in two different ways. This is how to loop
    through a dictionary using its keys:'
  id: totrans-3384
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用 for-in 循环遍历字典。因为每一项都有一个键和值，所以你可以用两种不同的方式来遍历字典。下面是通过字典的键遍历字典的方法：
- en: '![Image](Image00149.jpg)'
  id: totrans-3385
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00149.jpg)'
- en: Here we use the dictionary’s keys property ➊ to loop through fruitBasket and
    print its contents. We start by writing the keyword for , followed by a constant
    name fruit for the dictionary key, the keyword in , the dictionary name, a period,
    and keys .
  id: totrans-3386
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们使用字典的 keys 属性 ➊ 来遍历 fruitBasket 并打印其内容。我们先写关键词 for，后面跟着常量名称 fruit，表示字典的键，再加上关键词
    in，字典名称，句点，和 keys。
- en: Inside the braces of our for-in loop, we have access to both the key, which
    we call fruit ➋ , and the value at that key when we force-unwrap its contents
    with fruitBasket[fruit]! ➌ . That value will be the fruit’s price.
  id: totrans-3387
  prefs: []
  type: TYPE_NORMAL
  zh: 在 for-in 循环的大括号内，我们可以访问键，称之为 fruit ➋，以及通过强制解包 fruitBasket[fruit]! ➌ 访问该键对应的值。该值将是水果的价格。
- en: In this case, it’s safe to force-unwrap the value using an exclamation point
    because we know that the fruit key we’re using is definitely inside the dictionary.
  id: totrans-3388
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，使用感叹号强制解包值是安全的，因为我们知道我们使用的水果键肯定在字典中。
- en: Any code we put inside the for-in loop will run once for every key in our dictionary.
    So you should see the print statement display three times.
  id: totrans-3389
  prefs: []
  type: TYPE_NORMAL
  zh: 我们放在 for-in 循环内的任何代码都会在字典的每个键上执行一次。所以你应该看到打印语句显示三次。
- en: 'We can also loop through the dictionary using its values property:'
  id: totrans-3390
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以通过字典的 values 属性来遍历字典：
- en: '![Image](Image00150.jpg)'
  id: totrans-3391
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00150.jpg)'
- en: We use the same style of for-in loop, but now we use a constant to refer to
    each value, which we call price , in the values property. When looping through
    values, we don’t have access to the keys from inside the loop.
  id: totrans-3392
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用相同的 for-in 循环风格，但现在我们用一个常量来引用每个值，我们称之为 price，位于 values 属性中。在遍历 values 时，我们无法从循环内访问键。
- en: Another difference to note is that price is not an optional because it’s accessed
    directly as a value in the fruitBasket dictionary. That means we don’t have to
    unwrap it. You should still see the print statement printed three times. [Figure
    6-6](text00016.html#ch06fig6) shows the output of both loops.
  id: totrans-3393
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个需要注意的区别是，price 不是可选的，因为它是直接作为水果篮子字典中的值访问的。这意味着我们不需要解包它。你应该仍然能看到打印语句打印三次。[图
    6-6](text00016.html#ch06fig6)展示了两个循环的输出。
- en: '![Image](Image00151.jpg)'
  id: totrans-3394
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00151.jpg)'
- en: '*Figure 6-6: Looping through the keys and values of a dictionary with a for-in
    loop*'
  id: totrans-3395
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 6-6：使用 for-in 循环遍历字典的键和值*'
- en: The order of your results might be slightly different from ours. That’s because
    the items in a dictionary aren’t in a numbered order like they are in an array!
    And because the order is not guaranteed, you might see a different order printed
    if you run the same code again.
  id: totrans-3396
  prefs: []
  type: TYPE_NORMAL
  zh: 你的结果顺序可能与我们的略有不同。这是因为字典中的项目不像数组那样按编号顺序排列！由于顺序无法保证，因此如果你再次运行相同的代码，你可能会看到不同的顺序输出。
- en: '**WHAT YOU LEARNED**'
  id: totrans-3397
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**你学到了什么**'
- en: In this chapter, you learned how to store collections of items in an array and
    in a dictionary. To store items in an ordered list, you would use an array and
    look up each item by its index. If you wanted to store items by key instead, you
    would use a dictionary.
  id: totrans-3398
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你学习了如何将项目集合存储在数组和字典中。要将项目存储在有序列表中，你可以使用数组，并通过索引查找每个项目。如果你想通过键存储项目，你可以使用字典。
- en: Knowing about arrays and dictionaries and how to use them is a powerful building
    block for almost any programming language. Next we will learn about functions,
    another very powerful tool. Functions are blocks of code that you create and name
    to perform a specific job. After you have written a function, you can use its
    name to call it from almost anywhere in your program.
  id: totrans-3399
  prefs: []
  type: TYPE_NORMAL
  zh: 了解数组和字典以及如何使用它们，是几乎所有编程语言中强大的构建模块。接下来，我们将学习函数，这是另一个非常强大的工具。函数是你创建并命名的一段代码，用来执行特定的任务。编写完函数后，你可以通过它的名字在程序中的几乎任何地方调用它。
- en: '![](Image00118.jpg)'
  id: totrans-3400
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00118.jpg)'
- en: In this example, we are accessing the names of the national parks and then printing
    them to the screen using print . To get the first item in nationalParks , you
    use nationalParks[0] ➊ . To access the second item in nationalParks , you use
    nationalParks[1] .
  id: totrans-3401
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们访问了国家公园的名称，然后使用 print 将它们打印到屏幕上。要获取 nationalParks 中的第一个项目，你使用 nationalParks[0]
    ➊。要访问 nationalParks 中的第二个项目，你使用 nationalParks[1]。
- en: '**WATCHING THE RANGE**'
  id: totrans-3402
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**观察范围**'
- en: One important point about arrays is that if you try to access an item at an
    index that’s higher than the last index in the array, you’ll get an error. In
    [Figure 6-2](text00016.html#ch06fig2) , you can see that nationalParks[3] (which
    would be the fourth item in the array) gives you an error because there are only
    three national parks in the array, indexed from 0 to 2.
  id: totrans-3403
  prefs: []
  type: TYPE_NORMAL
  zh: 关于数组有一个重要的要点，如果你尝试访问一个超出数组最后一个索引的项目，你将会遇到错误。在[图 6-2](text00016.html#ch06fig2)中，你可以看到
    nationalParks[3]（它本应是数组中的第四个项目）会导致错误，因为数组中只有三个国家公园，索引从 0 到 2。
- en: As you can see, you get an error message that says Index out of range . If you
    try to access an item that doesn’t exist in your array, your app will crash!
  id: totrans-3404
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，你会得到一个错误信息，提示 "Index out of range"。如果你尝试访问数组中不存在的项目，应用程序会崩溃！
- en: '![Image](Image00119.jpg)'
  id: totrans-3405
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00119.jpg)'
- en: '*Figure 6-2: Trying to access an index in the array where nothing exists causes
    an error.*'
  id: totrans-3406
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 6-2：尝试访问数组中不存在的索引会导致错误。*'
- en: '**ADDING ITEMS TO AN ARRAY**'
  id: totrans-3407
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**向数组添加项目**'
- en: One way to change an array is to add new items to it. There are a few different
    ways to do this, so let’s take a look at each.
  id: totrans-3408
  prefs: []
  type: TYPE_NORMAL
  zh: 改变数组的一种方法是向其中添加新项目。有几种不同的方法来实现这一点，我们来逐一看看。
- en: 'First, you can use an array’s append(_:) method. *Append* means to add something.
    Using append(_:) , you can add one new item to the end of your array. Say you
    go on another trip and visit the Badlands, and you want to add it to your list
    of national parks. To do that, add this code into your playground:'
  id: totrans-3409
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，你可以使用数组的 append(_:) 方法。*Append* 的意思是添加某物。通过 append(_:)，你可以将一个新项目添加到数组的末尾。假设你又去了一次旅行，参观了恶地，并且想将它添加到你的国家公园列表中。为此，你可以将以下代码添加到你的
    playground 中：
- en: '![](Image00120.jpg)'
  id: totrans-3410
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00120.jpg)'
- en: To use the append(_:) method, first write the name of your array followed by
    a period and then append . Then, put the item you want to add to your array inside
    the parentheses. In this case, you put "Badlands" inside the parentheses.
  id: totrans-3411
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 append(_:) 方法时，首先写下数组的名字，后面跟一个点，再加上 append。然后，将你想要添加到数组中的项目放入括号内。在这个例子中，你将
    "Badlands" 放入括号中。
- en: 'If you want to add something at a specific place in your array, use the array’s
    insert(_:at:) method instead. This method takes two arguments: the item that you
    want to insert and the index of where it should go in the array. (We’ll discuss
    arguments in more detail in [Chapter 7](text00017.html#ch07) .)'
  id: totrans-3412
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想在数组中的特定位置添加某个项目，可以使用数组的 insert(_:at:) 方法。此方法有两个参数：你想要插入的项目和它应该放在数组中的位置（索引）。(我们将在[第
    7 章](text00017.html#ch07)中更详细地讨论参数。)
- en: 'Let’s say you totally forgot that you went to the Petrified Forest right after
    you visited the Grand Canyon, and you want to update your nationalParks array
    so it displays the parks in the order in which you visited them. To update your
    array, you could use the insert(_:at:) method to put the Petrified Forest in the
    right position:'
  id: totrans-3413
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你完全忘记了在参观完大峡谷后，你去了化石森林，你想更新你的 nationalParks 数组，使它按照你参观的顺序显示公园。为了更新数组，你可以使用insert(_:at:)方法把化石森林插入到正确的位置：
- en: '![](Image00121.jpg)'
  id: totrans-3414
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00121.jpg)'
- en: When you insert a new item at index 3, everything that was in the array at index
    3 or higher gets scooted over to make room for the new item. That means the item
    that was at index 3 is now at index 4, the item that was at index 4 is now at
    index 5, and so on. After you add the Petrified Forest, nationalParks is now ["Acadia",
    "Zion", "Grand Canyon", "Petrified Forest", "Badlands"] .
  id: totrans-3415
  prefs: []
  type: TYPE_NORMAL
  zh: 当你在索引3插入新项时，数组中索引为3及以上的项都会向后挪动，以为新项腾出空间。也就是说，原本在索引3的项现在位于索引4，原本在索引4的项则移到了索引5，以此类推。添加化石森林后，nationalParks
    数组变成了 ["Acadia", "Zion", "Grand Canyon", "Petrified Forest", "Badlands"]。
- en: '**COMBINING ARRAYS**'
  id: totrans-3416
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**合并数组**'
- en: 'Not only can you add new items to an array, but you can also add two arrays
    together using the + and += operators. Let’s say that you have the ingredients
    for a fruit smoothie in two arrays:'
  id: totrans-3417
  prefs: []
  type: TYPE_NORMAL
  zh: 不仅可以向数组添加新项，你还可以使用 + 和 += 操作符将两个数组合并。假设你有两个数组分别存放了果汁冰沙的配料：
- en: '![](Image00122.jpg)'
  id: totrans-3418
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00122.jpg)'
- en: Now you can make a delicious smoothie by adding the fruits and liquids arrays.
  id: totrans-3419
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你可以通过添加水果和液体数组来制作美味的果汁冰沙了。
- en: '![](Image00123.jpg)'
  id: totrans-3420
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00123.jpg)'
- en: The order of the ingredients in smoothie is the same as the order in fruits
    and liquids . If you created smoothie with liquids + fruits , then the liquids
    would come first.
  id: totrans-3421
  prefs: []
  type: TYPE_NORMAL
  zh: 果汁冰沙中的配料顺序与水果和液体的顺序相同。如果你是用液体 + 水果的顺序创建的果汁冰沙，那么液体会排在前面。
- en: 'You use the += operator to add an array to the end of your array. Add some
    whipped cream as follows for extra yumminess:'
  id: totrans-3422
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用 += 操作符将一个数组添加到另一个数组的末尾。为了增加一些美味的奶油，可以按如下方式添加：
- en: '![](Image00124.jpg)'
  id: totrans-3423
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00124.jpg)'
- en: Note that ["whipped cream"] is an array even though it has a single item in
    it. When you’re using += to append something to an array, you have to make sure
    you’re only trying to add another array. If you were to just write the string
    "whipped cream" without the square brackets around it, you would get an error.
  id: totrans-3424
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，["whipped cream"]是一个数组，尽管它只有一个项。当你使用 += 操作符将某个项添加到数组时，必须确保你仅仅是在添加一个数组。如果你只写了字符串"whipped
    cream"而没有加上方括号，系统会报错。
- en: '![Image](Image00125.jpg)'
  id: totrans-3425
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00125.jpg)'
- en: '**REMOVING ITEMS FROM AN ARRAY**'
  id: totrans-3426
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**从数组中删除项**'
- en: 'There are several methods for removing items from an array. Let’s start by
    looking at the array’s removeLast() method. As you might have guessed from its
    name, removeLast() removes the last item from your array. Let’s try it out with
    a shoppingList array:'
  id: totrans-3427
  prefs: []
  type: TYPE_NORMAL
  zh: 有几种方法可以从数组中删除项。让我们先来看一下数组的removeLast()方法。正如你从它的名字猜到的那样，removeLast()会删除数组中的最后一项。我们可以通过一个购物清单数组来试试：
- en: '![](Image00126.jpg)'
  id: totrans-3428
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00126.jpg)'
- en: Neat! Note that the removeLast() method returns the removed item, so you can
    store it in a new constant or variable if you want.
  id: totrans-3429
  prefs: []
  type: TYPE_NORMAL
  zh: 很棒！请注意，removeLast()方法会返回被删除的项，因此如果需要，你可以将其存储在一个新的常量或变量中。
- en: 'You can also remove an item from a specific index by using the remove(at:)
    method. Let’s say that your mom doesn’t want you buying any candy and takes that
    off the list:'
  id: totrans-3430
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以使用remove(at:)方法从特定索引删除一项。假设你的妈妈不想让你买糖果，并从清单中删除了这项：
- en: '![Image](Image00127.jpg)![](Image00128.jpg)'
  id: totrans-3431
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00127.jpg)![](Image00128.jpg)'
- en: Just like when we added an item to the middle of our array and all the items
    scooted over to make room, if you remove an item from the middle of an array,
    the rest of the items will scoot back to fill in that empty space. The "apples"
    item that was at index 3 is now at index 2, where "candy" was.
  id: totrans-3432
  prefs: []
  type: TYPE_NORMAL
  zh: 就像我们在数组中间添加项时，所有其他项会向后挪动腾出空间一样，如果你从数组中间删除项，其他项会向前挪动以填补空缺。原本位于索引3的“苹果”现在移到了索引2的位置，原本位于索引2的“糖果”则被移除。
- en: 'You can also remove all items from an array with removeAll() . Try entering
    this into your playground:'
  id: totrans-3433
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以使用removeAll()方法从数组中删除所有项。试着在你的 playground 中输入这个代码：
- en: '![](Image00129.jpg)'
  id: totrans-3434
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00129.jpg)'
- en: 'Note that trying to remove an item at an index that doesn’t exist will give
    you an error:'
  id: totrans-3435
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，尝试删除一个不存在的索引项会导致错误：
- en: '![](Image00130.jpg)'
  id: totrans-3436
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00130.jpg)'
- en: Our array doesn’t have this many items (in fact, now it’s empty!), so this throws
    an error. We’ll also get an error if we use removeLast() on our empty array, because
    there’s nothing in it—there’s no last index at all! However, removeAll() is always
    safe to use, even on an empty array.
  id: totrans-3437
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的数组没有这么多项（事实上，现在它是空的！），所以这会抛出一个错误。如果我们在空数组上使用 removeLast()，也会出错，因为它里面没有任何内容——根本没有最后一个索引！然而，使用
    removeAll() 是始终安全的，即使在空数组上也可以。
- en: '**REPLACING ITEMS IN AN ARRAY**'
  id: totrans-3438
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**替换数组中的项目**'
- en: 'To replace an item in an array, you set the index of the array to the new value,
    as shown here:'
  id: totrans-3439
  prefs: []
  type: TYPE_NORMAL
  zh: 要替换数组中的项，你可以将数组索引设置为新值，如下所示：
- en: '![](Image00131.jpg)'
  id: totrans-3440
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00131.jpg)'
- en: At ➊ , we replaced the item at index 2 (the third item) with "Unicorn" because
    magical animals count as favorite animals, too! At ➋ , we replaced the item at
    index 0 (the first item) with "Bearded dragon" . No, that’s not a real dragon—it’s
    just a lizard!
  id: totrans-3441
  prefs: []
  type: TYPE_NORMAL
  zh: 在 ➊ 处，我们将索引为 2（第三个项目）的项替换为 "独角兽"，因为魔法动物也算作最喜欢的动物！在 ➋ 处，我们将索引为 0（第一个项目）的项替换为
    "胡须龙"。不，这不是一条真正的龙——它只是只蜥蜴！
- en: Like any time you’re working with array index numbers, you have to be sure an
    item exists in the array at that index before you change its value, or you will
    get an Index out of range error.
  id: totrans-3442
  prefs: []
  type: TYPE_NORMAL
  zh: 就像每次你使用数组索引号时一样，你必须确保在更改其值之前该索引处的项目确实存在，否则你会遇到“索引超出范围”的错误。
- en: '[Figure 6-3](text00016.html#ch06fig3) shows the error that occurs if you try
    to add "Standard poodle" using favoriteAnimals[3] = "Standard poodle" . To add
    an item to the end of an array, you should use the append(_:) method or += , as
    we covered in “[Adding Items to an Array](text00016.html#ch06lev2sec5) ” on [page
    70](text00016.html#page_70) .'
  id: totrans-3443
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 6-3](text00016.html#ch06fig3) 显示了如果尝试通过 favoriteAnimals[3] = "Standard poodle"
    来添加 "标准贵宾犬" 时发生的错误。要将项目添加到数组的末尾，应该使用 append(_:) 方法或 +=，正如我们在 “[向数组添加项目](text00016.html#ch06lev2sec5)”
    中在 [第 70 页](text00016.html#page_70) 所讲解的那样。'
- en: '![Image](Image00132.jpg)'
  id: totrans-3444
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Image00132.jpg)'
- en: '*Figure 6-3: Don’t try to replace a value at an index beyond the existing array.*'
  id: totrans-3445
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 6-3：不要尝试替换超出现有数组索引的值。*'
- en: Now you know how to change arrays however you might need to. You can add items,
    take items away, or replace items. Next, we’ll look at how to use the properties
    of arrays to find out even more information about them.
  id: totrans-3446
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你知道如何根据需要更改数组了。你可以添加项目、移除项目或替换项目。接下来，我们将看看如何使用数组的属性来获取更多关于它们的信息。
- en: '![Image](Image00133.jpg)'
  id: totrans-3447
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Image00133.jpg)'
- en: '**USING ARRAY PROPERTIES**'
  id: totrans-3448
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**使用数组属性**'
- en: In addition to methods like append(_:) and removeLast() , arrays also have *properties*
    . An array’s properties are variables or constants that contain some information
    about the array. Two really helpful properties that you might use are the Boolean
    property isEmpty and the integer property count .
  id: totrans-3449
  prefs: []
  type: TYPE_NORMAL
  zh: 除了像 append(_:) 和 removeLast() 这样的操作方法，数组还有 *属性*。数组的属性是包含数组相关信息的变量或常量。有两个非常有用的属性你可能会用到，它们分别是布尔型属性
    isEmpty 和整型属性 count。
- en: The isEmpty property is true or false depending on whether the array is empty,
    and the count property will tell you how many items are in that array.
  id: totrans-3450
  prefs: []
  type: TYPE_NORMAL
  zh: isEmpty 属性根据数组是否为空返回 true 或 false，而 count 属性会告诉你数组中有多少个项目。
- en: 'Check out how these two properties are used in the following if-else statement:'
  id: totrans-3451
  prefs: []
  type: TYPE_NORMAL
  zh: 查看以下 if-else 语句中这两个属性是如何使用的：
- en: '![Image](Image00134.jpg)'
  id: totrans-3452
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Image00134.jpg)'
- en: 'This if-else statement checks whether the array mySiblings is empty ➊ . If
    it is, then "I don''t have any siblings." is printed. But if there is something
    in the array, then the number of siblings that we have is printed: "I have 3 siblings."
    ➋ .'
  id: totrans-3453
  prefs: []
  type: TYPE_NORMAL
  zh: 这个 if-else 语句检查数组 mySiblings 是否为空 ➊ 。如果为空，则打印 "我没有兄弟姐妹。"。但如果数组中有内容，则打印我们有多少兄弟姐妹：“我有
    3 个兄弟姐妹。” ➋ 。
- en: '**LOOPING OVER AN ARRAY**'
  id: totrans-3454
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**遍历数组**'
- en: 'Sometimes when you’re working with arrays you might want to do something to
    every item in the array. You can use a for-in loop to do that! The following code
    will print every topping in a pizzaToppings array on a separate line:'
  id: totrans-3455
  prefs: []
  type: TYPE_NORMAL
  zh: 有时在处理数组时，你可能希望对数组中的每个项执行某个操作。你可以使用 for-in 循环来做到这一点！以下代码将逐行打印 pizzaToppings 数组中的每个配料：
- en: '![Image](Image00135.jpg)'
  id: totrans-3456
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Image00135.jpg)'
- en: To write a for-in loop for the pizzaToppings array, we used the keyword for
    , followed by the constant topping , then the keyword in , and finally the name
    of our array, pizzaToppings . Then we put the statements that we want to run for
    each topping inside the braces of the for-in loop. The constant topping ➊ temporarily
    represents each pizza topping in the array as we loop through it. We could have
    chosen any name for this constant, but it’s a good idea to pick something that
    makes sense. You can see the output of this for-in loop in [Figure 6-4](text00016.html#ch06fig4)
    .
  id: totrans-3457
  prefs: []
  type: TYPE_NORMAL
  zh: 要为 pizzaToppings 数组写一个 for-in 循环，我们使用关键字 for，后跟常量 topping，然后是关键字 in，最后是数组的名称
    pizzaToppings。接着我们把希望在每个 topping 上执行的语句放入 for-in 循环的大括号中。常量 topping ➊ 在我们遍历数组时暂时代表每个比萨配料。我们可以为这个常量选择任何名称，但最好选择一个有意义的名称。你可以在[图
    6-4](text00016.html#ch06fig4) 中看到这个 for-in 循环的输出。
- en: '![Image](Image00136.jpg)'
  id: totrans-3458
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00136.jpg)'
- en: '*Figure 6-4: Output of the example for-in loop*'
  id: totrans-3459
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 6-4：示例 for-in 循环的输出*'
- en: '![Image](Image00137.jpg)'
  id: totrans-3460
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00137.jpg)'
- en: 'Using for-in loops is great for printing every value in an array. If you’re
    working with numbers, you can even use them to perform math operations on each
    item, which makes for some speedy calculations! The following code takes an array
    of numbers and calculates the square for each (the square of a number is that
    number multiplied by itself):'
  id: totrans-3461
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 for-in 循环非常适合打印数组中的每个值。如果你在处理数字，还可以利用它们对每个项目进行数学运算，这使得计算速度更快！以下代码接受一个数字数组，并计算每个数字的平方（数字的平方是该数字乘以自身）：
- en: '![Image](Image00138.jpg)'
  id: totrans-3462
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00138.jpg)'
- en: '[Figure 6-5](text00016.html#ch06fig5) shows the results.'
  id: totrans-3463
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 6-5](text00016.html#ch06fig5) 显示了结果。'
- en: '![Image](Image00139.jpg)'
  id: totrans-3464
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00139.jpg)'
- en: '*Figure 6-5: Printing the squares for each number in the myNumbers array*'
  id: totrans-3465
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 6-5：打印 myNumbers 数组中每个数字的平方*'
- en: '**DICTIONARIES ARE KEY!**'
  id: totrans-3466
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**字典至关重要！**'
- en: A *dictionary* is also a collection of values, but instead of an ordered index,
    each value has its own *key* . Because there’s no index, the values are not stored
    in any particular order. To access values in a dictionary, you look them up by
    their key.
  id: totrans-3467
  prefs: []
  type: TYPE_NORMAL
  zh: '*字典* 也是一个值的集合，但不同于有序索引，每个值都有其独立的*键*。由于没有索引，值不会按特定顺序存储。要访问字典中的值，你需要通过键来查找它们。'
- en: A key must be unique. You can’t have the same key more than once in the same
    dictionary. If there were two identical keys and you asked the computer to give
    you the value for one of them, the computer wouldn’t know which one to choose!
  id: totrans-3468
  prefs: []
  type: TYPE_NORMAL
  zh: 键必须是唯一的。你不能在同一个字典中使用相同的键。如果有两个相同的键，当你要求计算机提供其中一个的值时，计算机将不知道选择哪个！
- en: Let’s take a look at how to make a dictionary and write keys that will help
    you find all the information you need.
  id: totrans-3469
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看如何创建字典并写出能够帮助你查找所需信息的键。
- en: '![Image](Image00140.jpg)'
  id: totrans-3470
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00140.jpg)'
- en: '**INITIALIZING A DICTIONARY**'
  id: totrans-3471
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**初始化字典**'
- en: 'To create and initialize a dictionary, first write var and the name of your
    dictionary. Then write the keys and corresponding values inside a pair of square
    brackets, similar to an array. Let’s create a dictionary to store the names of
    a few US states. The key for each state will be its two-letter abbreviation:'
  id: totrans-3472
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建和初始化字典，首先写上 var 和字典的名称。然后将键和值写在一对方括号内，类似于数组。让我们创建一个字典来存储一些美国州的名称。每个州的键将是其两字母的缩写：
- en: '![](Image00141.jpg)'
  id: totrans-3473
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00141.jpg)'
- en: As you can see, there’s a colon between each key and its value, and the key/value
    pairs are separated by commas.
  id: totrans-3474
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，键和值之间有一个冒号，键/值对由逗号分隔。
- en: Dictionaries are different from arrays in that they are *unordered* . Because
    of that, it’s likely that the order of the states that you see in your results
    pane ➋ is different from the order in which you entered your states ➊ . It might
    even be different than the order that’s printed in this book!
  id: totrans-3475
  prefs: []
  type: TYPE_NORMAL
  zh: 字典与数组的不同之处在于它们是*无序的*。因此，你看到的结果窗格中州的顺序➋可能与输入州的顺序➊不同。它甚至可能与本书中打印的顺序不同！
- en: As with arrays, you can use var to make a mutable dictionary or use let to make
    an immutable dictionary.
  id: totrans-3476
  prefs: []
  type: TYPE_NORMAL
  zh: 和数组一样，你可以使用 var 来创建可变字典，或者使用 let 来创建不可变字典。
- en: 'In Swift, all of the keys of a dictionary must be the same type, and all of
    the values of a dictionary must also be the same type, but the key type doesn’t
    have to match the value type. For example, if you wanted to store a collection
    of fractions, you could use doubles for the keys and strings for the values:'
  id: totrans-3477
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Swift 中，字典的所有键必须是相同类型的，字典的所有值也必须是相同类型的，但键的类型不必与值的类型匹配。例如，如果你想存储一组分数，你可以使用双精度浮点数作为键，使用字符串作为值：
- en: '![](Image00142.jpg)'
  id: totrans-3478
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00142.jpg)'
- en: In this dictionary, all of the keys must be doubles, and all of the values must
    be strings. Again, you’ll see that the order of the numbers in the results pane
    can be quite different from the order in which you wrote the fractions in your
    dictionary. This is fine because you don’t need to know the order to access anything.
    You can find any item that you need by its key. Let’s see how!
  id: totrans-3479
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个字典中，所有的键必须是双精度浮点数，所有的值必须是字符串。同样，你会看到结果面板中数字的顺序可能和你在字典中写分数的顺序完全不同。这是正常的，因为你不需要依赖顺序来访问任何内容。你可以通过键找到你需要的任何项。我们来看看怎么做！
- en: '**ACCESSING VALUES IN A DICTIONARY**'
  id: totrans-3480
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**访问字典中的值**'
- en: 'Looking up a value in a dictionary is similar to how you access a value in
    an array except that you use a key inside the square brackets instead of an index,
    like this: usStates["TX"] .'
  id: totrans-3481
  prefs: []
  type: TYPE_NORMAL
  zh: 在字典中查找一个值类似于在数组中访问值，只不过你使用的是方括号中的键，而不是索引，像这样：usStates["TX"]。
- en: There is a big difference, however, in how Swift returns the values from a dictionary.
    When you access a value at an index of an array, you are simply given the value.
    When you access a value with a key in a dictionary, you are given an optional.
  id: totrans-3482
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，Swift 在从字典返回值的方式上有一个很大的不同。当你通过数组的索引访问一个值时，你只会得到该值。而当你通过字典的键访问一个值时，你得到的是一个可选值。
- en: In [Chapter 5](text00015.html#ch05) , you learned that optionals might contain
    a value or might be nil . The reason Swift returns optionals when you’re looking
    up items in a dictionary is that the key you used might not exist in the dictionary,
    in which case there’s no value to access. Trying to access a value that doesn’t
    exist would give you a big fat error! To avoid that problem, Swift returns optionals.
    That means you need to unwrap any value you get out of a dictionary before you
    can do anything with it.
  id: totrans-3483
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第5章](text00015.html#ch05)中，你学到了可选值可能包含一个值，也可能为 nil。Swift 返回可选值的原因是，当你在字典中查找项时，使用的键可能不存在于字典中，这样就没有值可以访问。如果你尝试访问一个不存在的值，程序就会报错！为了避免这个问题，Swift
    返回的是可选值。这意味着你需要解包从字典中获取的任何值，然后才能使用它。
- en: 'To unwrap an optional, first you check whether it exists using an if-let statement,
    just like we did in [Chapter 5](text00015.html#ch05) . The following code shows
    you how to get a value out of a dictionary:'
  id: totrans-3484
  prefs: []
  type: TYPE_NORMAL
  zh: 要解包一个可选值，首先你需要使用 if-let 语句检查它是否存在，就像我们在[第5章](text00015.html#ch05)中做的那样。下面的代码展示了如何从字典中获取一个值：
- en: '![Image](Image00143.jpg)'
  id: totrans-3485
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00143.jpg)'
- en: To retrieve "Texas" from the dictionary, we use if let to set a constant loneStarState
    to usStates["TX"] ➊ . Because we have this state in our dictionary, the line I
    have Texas in my dictionary. is printed. Next we try to access a state that is
    not in our dictionary by using the key usStates["FL"] ➋ . Thankfully, because
    we used an if-let statement, the program won’t crash when the computer can’t find
    this state. Instead, I don't have that state in my dictionary. is printed.
  id: totrans-3486
  prefs: []
  type: TYPE_NORMAL
  zh: 要从字典中检索 "Texas"，我们使用 if let 将常量 loneStarState 设置为 usStates["TX"] ➊。因为我们在字典中有这个州，所以打印出
    "我在字典中有 Texas"。接下来，我们尝试通过使用键 usStates["FL"] ➋ 访问一个不在字典中的州。幸运的是，因为我们使用了 if-let
    语句，当计算机找不到这个州时，程序不会崩溃。相反，打印出 "我在字典中没有这个州"。
- en: '**ADDING ITEMS TO A DICTIONARY**'
  id: totrans-3487
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**向字典中添加项**'
- en: 'To add an item to a dictionary, first write the name of your dictionary and
    assign the new item to the key you want it to have in the dictionary. Let’s add
    "Minnesota" to our usStates dictionary:'
  id: totrans-3488
  prefs: []
  type: TYPE_NORMAL
  zh: 要向字典中添加一个项，首先写出字典的名称，并将新项赋值给你希望它在字典中拥有的键。让我们将 "Minnesota" 添加到我们的 usStates 字典中：
- en: '![](Image00144.jpg)'
  id: totrans-3489
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00144.jpg)'
- en: 'Now when you look at usStates , you’ll see that it’s updated to ["MN": "Minnesota",
    "WA": "Washington", "MA": "Massachusetts", "TX": "Texas"] . Remember, because
    you don’t have to rely on indices, your new dictionary item might appear anywhere
    in the dictionary.'
  id: totrans-3490
  prefs: []
  type: TYPE_NORMAL
  zh: '现在，当你查看 usStates 时，你会看到它已更新为 ["MN": "Minnesota", "WA": "Washington", "MA":
    "Massachusetts", "TX": "Texas"]。记住，因为你不需要依赖索引，你的新字典项可能出现在字典的任何位置。'
- en: '**REMOVING ITEMS FROM A DICTIONARY**'
  id: totrans-3491
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**从字典中删除项**'
- en: Removing an item from a dictionary is quite simple; you do so by setting the
    value to nil . Because the values in dictionaries are returned as optionals, you
    don’t have to worry about nil causing any problems in your dictionary.
  id: totrans-3492
  prefs: []
  type: TYPE_NORMAL
  zh: 从字典中移除项目非常简单；你只需将值设置为 `nil`。由于字典中的值是作为可选类型返回的，所以你不需要担心 `nil` 会在字典中引发任何问题。
- en: '![](Image00145.jpg)'
  id: totrans-3493
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00145.jpg)'
- en: 'You can see that after you remove the value at the key "MA" , usStates is updated
    to ["MN": "Minnesota", "WA": "Washington", "TX": "Texas"] . Remember that nil
    is special and means that there’s no value at all. That’s why you don’t see "MA":
    nil in our dictionary.'
  id: totrans-3494
  prefs: []
  type: TYPE_NORMAL
  zh: '你可以看到，在移除键 "MA" 对应的值后，`usStates` 被更新为 ["MN": "Minnesota", "WA": "Washington",
    "TX": "Texas"]。记住，`nil` 是特殊的，表示没有值。这就是为什么在我们的字典中看不到 "MA": nil。'
- en: '**REPLACING ITEMS IN A DICTIONARY**'
  id: totrans-3495
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**替换字典中的项目**'
- en: 'Replacing an item in a dictionary is also easy. It works the same was as replacing
    an item in an array. You just set the item that you want to replace to something
    else. Say you create a dictionary of fruit colors:'
  id: totrans-3496
  prefs: []
  type: TYPE_NORMAL
  zh: 替换字典中的项目也很简单。它与替换数组中的项目方式相同。你只需将要替换的项目设置为其他内容。比如你创建了一个水果颜色的字典：
- en: '![](Image00146.jpg)'
  id: totrans-3497
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00146.jpg)'
- en: At first we had the value "apple" for "red" , but then we decided that "raspberry"
    is a better fruit to use since sometimes apples are green or yellow. To replace
    "apple" with "raspberry" , we set colorFruits["red"] to its new value ➊ .
  id: totrans-3498
  prefs: []
  type: TYPE_NORMAL
  zh: 最初，我们为 "red" 设置了 "apple" 的值，但后来我们决定 "raspberry" 更适合作为水果，因为有时苹果是绿色或黄色的。要将 "apple"
    替换为 "raspberry"，我们将 `colorFruits["red"]` 设置为新的值 ➊。
- en: You may remember that this is the same way we entered a new value into a dictionary.
    If the key already exists in the dictionary, then the value for that key is replaced.
    If the key doesn’t already exist, then the new key/value pair will be added to
    the dictionary.
  id: totrans-3499
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能记得，这与我们向字典中添加新值的方式相同。如果该键已经存在于字典中，则该键的值将被替换。如果该键不存在，则新的键/值对将被添加到字典中。
- en: '![Image](Image00147.jpg)'
  id: totrans-3500
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00147.jpg)'
- en: '**USING DICTIONARY PROPERTIES**'
  id: totrans-3501
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**使用字典属性**'
- en: 'Like an array, a dictionary also has an isEmpty property and a count property.
    For example, the following code shows how you can use the isEmpty property to
    check if a dictionary is empty, and if it isn’t empty, the count property checks
    how many items you have. Imagine you have a basket of fruit for sale. You can
    use these properties to help you keep track of everything:'
  id: totrans-3502
  prefs: []
  type: TYPE_NORMAL
  zh: 和数组一样，字典也有 `isEmpty` 属性和 `count` 属性。例如，以下代码演示了如何使用 `isEmpty` 属性检查字典是否为空，如果不为空，则使用
    `count` 属性检查字典中有多少项。假设你有一个待售的水果篮子，你可以使用这些属性帮助你跟踪所有内容：
- en: '![Image](Image00148.jpg)'
  id: totrans-3503
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00148.jpg)'
- en: 'A dictionary also has two special properties: keys , which contains all of
    the dictionary’s keys, and values , which contains all of its values. We’ll use
    these two properties when we loop through the dictionary.'
  id: totrans-3504
  prefs: []
  type: TYPE_NORMAL
  zh: 字典还有两个特殊属性：`keys`，它包含字典中的所有键，以及 `values`，它包含字典中的所有值。在遍历字典时，我们将使用这两个属性。
- en: Let’s write some code that loops through our fruit baskets and prints the price
    of each fruit.
  id: totrans-3505
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们编写一些代码，遍历我们的水果篮子并打印每个水果的价格。
- en: '**LOOPING OVER A DICTIONARY**'
  id: totrans-3506
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**遍历字典**'
- en: 'You can loop through a dictionary using a for-in loop. Because each item has
    a key and a value, you can do this in two different ways. This is how to loop
    through a dictionary using its keys:'
  id: totrans-3507
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用 `for-in` 循环遍历字典。因为每个项都有一个键和值，所以你可以通过两种不同的方式来实现。以下是通过键遍历字典的方式：
- en: '![Image](Image00149.jpg)'
  id: totrans-3508
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00149.jpg)'
- en: Here we use the dictionary’s keys property ➊ to loop through fruitBasket and
    print its contents. We start by writing the keyword for , followed by a constant
    name fruit for the dictionary key, the keyword in , the dictionary name, a period,
    and keys .
  id: totrans-3509
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们使用字典的 `keys` 属性 ➊ 来遍历 `fruitBasket` 并打印其内容。我们首先写下关键字 `for`，然后是字典键的常量名称
    `fruit`，接着是关键字 `in`，字典名称，句点和 `keys`。
- en: Inside the braces of our for-in loop, we have access to both the key, which
    we call fruit ➋ , and the value at that key when we force-unwrap its contents
    with fruitBasket[fruit]! ➌ . That value will be the fruit’s price.
  id: totrans-3510
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `for-in` 循环的大括号内，我们可以访问到键，我们称之为 `fruit` ➋，以及通过强制解包其内容 `fruitBasket[fruit]!`
    ➌ 获得的键对应的值。该值将是水果的价格。
- en: In this case, it’s safe to force-unwrap the value using an exclamation point
    because we know that the fruit key we’re using is definitely inside the dictionary.
  id: totrans-3511
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，使用感叹号强制解包值是安全的，因为我们知道我们使用的水果键肯定存在于字典中。
- en: Any code we put inside the for-in loop will run once for every key in our dictionary.
    So you should see the print statement display three times.
  id: totrans-3512
  prefs: []
  type: TYPE_NORMAL
  zh: 我们放在 for-in 循环中的任何代码都会在字典中的每个键上运行一次。所以你应该看到 print 语句打印三次。
- en: 'We can also loop through the dictionary using its values property:'
  id: totrans-3513
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以通过字典的 values 属性来循环：
- en: '![Image](Image00150.jpg)'
  id: totrans-3514
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Image00150.jpg)'
- en: We use the same style of for-in loop, but now we use a constant to refer to
    each value, which we call price , in the values property. When looping through
    values, we don’t have access to the keys from inside the loop.
  id: totrans-3515
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用相同的 for-in 循环样式，但现在我们使用一个常量来引用每个值，我们称其为价格（price），它位于 values 属性中。当循环遍历 values
    时，我们无法从循环内部访问键。
- en: Another difference to note is that price is not an optional because it’s accessed
    directly as a value in the fruitBasket dictionary. That means we don’t have to
    unwrap it. You should still see the print statement printed three times. [Figure
    6-6](text00016.html#ch06fig6) shows the output of both loops.
  id: totrans-3516
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个需要注意的区别是，价格（price）不是可选的，因为它直接作为值访问于 fruitBasket 字典中。这意味着我们不需要解包它。你仍然应该看到
    print 语句打印三次。[图 6-6](text00016.html#ch06fig6) 显示了两个循环的输出。
- en: '![Image](Image00151.jpg)'
  id: totrans-3517
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Image00151.jpg)'
- en: '*Figure 6-6: Looping through the keys and values of a dictionary with a for-in
    loop*'
  id: totrans-3518
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 6-6：使用 for-in 循环遍历字典的键和值*'
- en: The order of your results might be slightly different from ours. That’s because
    the items in a dictionary aren’t in a numbered order like they are in an array!
    And because the order is not guaranteed, you might see a different order printed
    if you run the same code again.
  id: totrans-3519
  prefs: []
  type: TYPE_NORMAL
  zh: 你得到的结果顺序可能与我们稍有不同。这是因为字典中的项不像数组中的项那样按数字顺序排列！而且由于顺序没有保证，如果你再次运行相同的代码，你可能会看到不同的顺序。
- en: '**WHAT YOU LEARNED**'
  id: totrans-3520
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**你学到了什么**'
- en: In this chapter, you learned how to store collections of items in an array and
    in a dictionary. To store items in an ordered list, you would use an array and
    look up each item by its index. If you wanted to store items by key instead, you
    would use a dictionary.
  id: totrans-3521
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一章中，你学习了如何将一组项存储在数组和字典中。要将项存储在有序列表中，你会使用数组，并通过索引查找每一项。如果你想通过键来存储项，你会使用字典。
- en: Knowing about arrays and dictionaries and how to use them is a powerful building
    block for almost any programming language. Next we will learn about functions,
    another very powerful tool. Functions are blocks of code that you create and name
    to perform a specific job. After you have written a function, you can use its
    name to call it from almost anywhere in your program.
  id: totrans-3522
  prefs: []
  type: TYPE_NORMAL
  zh: 了解数组和字典及其使用方法是几乎任何编程语言中的一个强大基础。接下来我们将学习函数，另一个非常强大的工具。函数是你创建并命名的一块代码，用来执行特定的工作。写完一个函数后，你可以通过其名称在程序的几乎任何地方调用它。
- en: In this example, we are accessing the names of the national parks and then printing
    them to the screen using print . To get the first item in nationalParks , you
    use nationalParks[0] ➊ . To access the second item in nationalParks , you use
    nationalParks[1] .
  id: totrans-3523
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们访问的是国家公园的名称，并通过 print 将其打印到屏幕上。要获取 nationalParks 中的第一个项目，你可以使用 nationalParks[0]
    ➊。要访问 nationalParks 中的第二个项目，你可以使用 nationalParks[1]。
- en: '**WATCHING THE RANGE**'
  id: totrans-3524
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**观察范围**'
- en: One important point about arrays is that if you try to access an item at an
    index that’s higher than the last index in the array, you’ll get an error. In
    [Figure 6-2](text00016.html#ch06fig2) , you can see that nationalParks[3] (which
    would be the fourth item in the array) gives you an error because there are only
    three national parks in the array, indexed from 0 to 2.
  id: totrans-3525
  prefs: []
  type: TYPE_NORMAL
  zh: 关于数组的一个重要点是，如果你尝试访问数组中一个比最后一个索引还要大的索引，你会得到一个错误。在[图 6-2](text00016.html#ch06fig2)中，你可以看到
    nationalParks[3]（即数组中的第四项）会给你一个错误，因为数组中只有三个国家公园，索引从 0 到 2。
- en: As you can see, you get an error message that says Index out of range . If you
    try to access an item that doesn’t exist in your array, your app will crash!
  id: totrans-3526
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，出现了一个错误信息，显示为“索引超出范围”。如果你尝试访问数组中不存在的项目，应用程序会崩溃！
- en: '![Image](Image00119.jpg)'
  id: totrans-3527
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Image00119.jpg)'
- en: '*Figure 6-2: Trying to access an index in the array where nothing exists causes
    an error.*'
  id: totrans-3528
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 6-2：尝试访问数组中不存在的索引会导致错误。*'
- en: '**ADDING ITEMS TO AN ARRAY**'
  id: totrans-3529
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**向数组添加元素**'
- en: One way to change an array is to add new items to it. There are a few different
    ways to do this, so let’s take a look at each.
  id: totrans-3530
  prefs: []
  type: TYPE_NORMAL
  zh: 改变数组的一种方法是向其中添加新项。我们有几种不同的方法来做到这一点，接下来我们将逐一查看。
- en: 'First, you can use an array’s append(_:) method. *Append* means to add something.
    Using append(_:) , you can add one new item to the end of your array. Say you
    go on another trip and visit the Badlands, and you want to add it to your list
    of national parks. To do that, add this code into your playground:'
  id: totrans-3531
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，你可以使用数组的append(_:)方法。*Append*意思是添加某个元素。使用append(_:)，你可以将一个新项添加到数组的末尾。假设你又去了一趟旅行，参观了坏lands，并且想把它添加到你的国家公园列表中。你可以在你的playground中添加如下代码：
- en: '![](Image00120.jpg)'
  id: totrans-3532
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00120.jpg)'
- en: To use the append(_:) method, first write the name of your array followed by
    a period and then append . Then, put the item you want to add to your array inside
    the parentheses. In this case, you put "Badlands" inside the parentheses.
  id: totrans-3533
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用append(_:)方法，首先写出数组的名称，后面跟一个句点，再写append。然后，把你想要添加到数组中的元素放在括号内。在这个例子中，你把"Badlands"放在了括号里。
- en: 'If you want to add something at a specific place in your array, use the array’s
    insert(_:at:) method instead. This method takes two arguments: the item that you
    want to insert and the index of where it should go in the array. (We’ll discuss
    arguments in more detail in [Chapter 7](text00017.html#ch07) .)'
  id: totrans-3534
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想在数组的特定位置添加某个元素，请改用数组的insert(_:at:)方法。这个方法需要两个参数：你想要插入的元素以及它在数组中应插入的位置（我们将在[第7章](text00017.html#ch07)详细讨论参数）。
- en: 'Let’s say you totally forgot that you went to the Petrified Forest right after
    you visited the Grand Canyon, and you want to update your nationalParks array
    so it displays the parks in the order in which you visited them. To update your
    array, you could use the insert(_:at:) method to put the Petrified Forest in the
    right position:'
  id: totrans-3535
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你完全忘记了自己在游览大峡谷后去了石化森林，并且想要更新你的nationalParks数组，以便按照你访问的顺序显示公园。要更新数组，你可以使用insert(_:at:)方法将石化森林插入正确的位置：
- en: '![](Image00121.jpg)'
  id: totrans-3536
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00121.jpg)'
- en: When you insert a new item at index 3, everything that was in the array at index
    3 or higher gets scooted over to make room for the new item. That means the item
    that was at index 3 is now at index 4, the item that was at index 4 is now at
    index 5, and so on. After you add the Petrified Forest, nationalParks is now ["Acadia",
    "Zion", "Grand Canyon", "Petrified Forest", "Badlands"] .
  id: totrans-3537
  prefs: []
  type: TYPE_NORMAL
  zh: 当你在索引3的位置插入一个新项时，数组中从索引3及其更高位置的所有元素都会向后移动，为新项腾出空间。这意味着原来在索引3的位置的项现在会在索引4的位置，索引4的位置的项会在索引5的位置，以此类推。添加石化森林后，nationalParks数组现在是["Acadia",
    "Zion", "Grand Canyon", "Petrified Forest", "Badlands"]。
- en: '**COMBINING ARRAYS**'
  id: totrans-3538
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**合并数组**'
- en: 'Not only can you add new items to an array, but you can also add two arrays
    together using the + and += operators. Let’s say that you have the ingredients
    for a fruit smoothie in two arrays:'
  id: totrans-3539
  prefs: []
  type: TYPE_NORMAL
  zh: 你不仅可以向数组中添加新元素，还可以使用+和+=操作符将两个数组合并。假设你有两个数组，分别包含制作水果smoothie的食材：
- en: '![](Image00122.jpg)'
  id: totrans-3540
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00122.jpg)'
- en: Now you can make a delicious smoothie by adding the fruits and liquids arrays.
  id: totrans-3541
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你可以通过将水果和液体数组合并来制作一杯美味的smoothie。
- en: '![](Image00123.jpg)'
  id: totrans-3542
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00123.jpg)'
- en: The order of the ingredients in smoothie is the same as the order in fruits
    and liquids . If you created smoothie with liquids + fruits , then the liquids
    would come first.
  id: totrans-3543
  prefs: []
  type: TYPE_NORMAL
  zh: smoothie中的食材顺序与水果和液体的顺序相同。如果你是先加入液体然后加入水果来制作smoothie，那么液体会先加入。
- en: 'You use the += operator to add an array to the end of your array. Add some
    whipped cream as follows for extra yumminess:'
  id: totrans-3544
  prefs: []
  type: TYPE_NORMAL
  zh: 你使用+=操作符将一个数组添加到另一个数组的末尾。可以按如下方式添加一些whipped cream来增加美味感：
- en: '![](Image00124.jpg)'
  id: totrans-3545
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00124.jpg)'
- en: Note that ["whipped cream"] is an array even though it has a single item in
    it. When you’re using += to append something to an array, you have to make sure
    you’re only trying to add another array. If you were to just write the string
    "whipped cream" without the square brackets around it, you would get an error.
  id: totrans-3546
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，虽然["whipped cream"]数组中只有一个元素，但它仍然是一个数组。当你使用+=操作符将某个元素添加到数组时，必须确保你添加的是另一个数组。如果你直接写出字符串"whipped
    cream"，而没有加上方括号，那么会报错。
- en: '![Image](Image00125.jpg)'
  id: totrans-3547
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00125.jpg)'
- en: '**REMOVING ITEMS FROM AN ARRAY**'
  id: totrans-3548
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**从数组中移除项**'
- en: 'There are several methods for removing items from an array. Let’s start by
    looking at the array’s removeLast() method. As you might have guessed from its
    name, removeLast() removes the last item from your array. Let’s try it out with
    a shoppingList array:'
  id: totrans-3549
  prefs: []
  type: TYPE_NORMAL
  zh: 有几种方法可以从数组中移除元素。我们先来看数组的removeLast()方法。正如它的名字所示，removeLast()会移除数组中的最后一个元素。让我们通过一个shoppingList数组来试一下：
- en: '![](Image00126.jpg)'
  id: totrans-3550
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00126.jpg)'
- en: Neat! Note that the removeLast() method returns the removed item, so you can
    store it in a new constant or variable if you want.
  id: totrans-3551
  prefs: []
  type: TYPE_NORMAL
  zh: 很棒！请注意，removeLast()方法会返回被移除的项，因此如果你想，你可以将其存储在一个新的常量或变量中。
- en: 'You can also remove an item from a specific index by using the remove(at:)
    method. Let’s say that your mom doesn’t want you buying any candy and takes that
    off the list:'
  id: totrans-3552
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以通过使用remove(at:)方法从特定索引处移除一个项。假设你妈妈不想让你买糖果，并从列表中将其删除：
- en: '![Image](Image00127.jpg)![](Image00128.jpg)'
  id: totrans-3553
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00127.jpg)![](Image00128.jpg)'
- en: Just like when we added an item to the middle of our array and all the items
    scooted over to make room, if you remove an item from the middle of an array,
    the rest of the items will scoot back to fill in that empty space. The "apples"
    item that was at index 3 is now at index 2, where "candy" was.
  id: totrans-3554
  prefs: []
  type: TYPE_NORMAL
  zh: 就像我们在数组中间添加一项时，所有项都会滑动过去腾出空间一样，如果你从数组的中间移除一项，其余的项会向前滑动，填补那个空缺的地方。原来在索引3处的"苹果"现在在索引2处，原本的"糖果"在这里。
- en: 'You can also remove all items from an array with removeAll() . Try entering
    this into your playground:'
  id: totrans-3555
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以使用removeAll()方法移除数组中的所有项。尝试在你的游乐场中输入这个：
- en: '![](Image00129.jpg)'
  id: totrans-3556
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00129.jpg)'
- en: 'Note that trying to remove an item at an index that doesn’t exist will give
    you an error:'
  id: totrans-3557
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，尝试移除一个不存在索引处的项会导致错误：
- en: '![](Image00130.jpg)'
  id: totrans-3558
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00130.jpg)'
- en: Our array doesn’t have this many items (in fact, now it’s empty!), so this throws
    an error. We’ll also get an error if we use removeLast() on our empty array, because
    there’s nothing in it—there’s no last index at all! However, removeAll() is always
    safe to use, even on an empty array.
  id: totrans-3559
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的数组并没有这么多项（事实上，现在它是空的！），所以这会引发一个错误。如果我们在空数组上使用removeLast()，也会出错，因为里面什么也没有——根本没有最后一个索引！但是，removeAll()方法即使在空数组上使用也是安全的。
- en: '**REPLACING ITEMS IN AN ARRAY**'
  id: totrans-3560
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**在数组中替换项**'
- en: 'To replace an item in an array, you set the index of the array to the new value,
    as shown here:'
  id: totrans-3561
  prefs: []
  type: TYPE_NORMAL
  zh: 要在数组中替换一项，你只需要将数组的索引设置为新值，如下所示：
- en: '![](Image00131.jpg)'
  id: totrans-3562
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00131.jpg)'
- en: At ➊ , we replaced the item at index 2 (the third item) with "Unicorn" because
    magical animals count as favorite animals, too! At ➋ , we replaced the item at
    index 0 (the first item) with "Bearded dragon" . No, that’s not a real dragon—it’s
    just a lizard!
  id: totrans-3563
  prefs: []
  type: TYPE_NORMAL
  zh: 在➊，我们用“独角兽”替换了索引为2的项（第三项），因为魔法动物也算是最喜欢的动物！在➋，我们用“鬃蜥”替换了索引为0的项（第一项）。不，那不是一只真正的龙——它只是一只蜥蜴！
- en: Like any time you’re working with array index numbers, you have to be sure an
    item exists in the array at that index before you change its value, or you will
    get an Index out of range error.
  id: totrans-3564
  prefs: []
  type: TYPE_NORMAL
  zh: 就像在处理数组索引时一样，你必须确保该索引位置的项存在，否则你会遇到“索引超出范围”的错误。
- en: '[Figure 6-3](text00016.html#ch06fig3) shows the error that occurs if you try
    to add "Standard poodle" using favoriteAnimals[3] = "Standard poodle" . To add
    an item to the end of an array, you should use the append(_:) method or += , as
    we covered in “[Adding Items to an Array](text00016.html#ch06lev2sec5) ” on [page
    70](text00016.html#page_70) .'
  id: totrans-3565
  prefs: []
  type: TYPE_NORMAL
  zh: '[图6-3](text00016.html#ch06fig3)展示了如果你尝试通过favoriteAnimals[3] = "Standard poodle"来添加"标准贵宾犬"时会发生的错误。要向数组的末尾添加项，应该使用append(_:)方法或+=，正如我们在[《向数组添加项》](text00016.html#ch06lev2sec5)一节中介绍的那样，见[第70页](text00016.html#page_70)。'
- en: '![Image](Image00132.jpg)'
  id: totrans-3566
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00132.jpg)'
- en: '*Figure 6-3: Don’t try to replace a value at an index beyond the existing array.*'
  id: totrans-3567
  prefs: []
  type: TYPE_NORMAL
  zh: '*图6-3：不要尝试在超出现有数组范围的索引处替换值。*'
- en: Now you know how to change arrays however you might need to. You can add items,
    take items away, or replace items. Next, we’ll look at how to use the properties
    of arrays to find out even more information about them.
  id: totrans-3568
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你知道了如何根据需要更改数组。你可以添加项、删除项或替换项。接下来，我们将学习如何利用数组的属性获取更多关于数组的信息。
- en: '![Image](Image00133.jpg)'
  id: totrans-3569
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00133.jpg)'
- en: '**USING ARRAY PROPERTIES**'
  id: totrans-3570
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**使用数组属性**'
- en: In addition to methods like append(_:) and removeLast() , arrays also have *properties*
    . An array’s properties are variables or constants that contain some information
    about the array. Two really helpful properties that you might use are the Boolean
    property isEmpty and the integer property count .
  id: totrans-3571
  prefs: []
  type: TYPE_NORMAL
  zh: 除了像append(_:)和removeLast()这样的常用方法外，数组还有*属性*。数组的属性是包含数组信息的变量或常量。你可能会用到的两个非常有用的属性是布尔值属性isEmpty和整数属性count。
- en: The isEmpty property is true or false depending on whether the array is empty,
    and the count property will tell you how many items are in that array.
  id: totrans-3572
  prefs: []
  type: TYPE_NORMAL
  zh: isEmpty属性的值为true或false，取决于数组是否为空，而count属性会告诉你数组中有多少项。
- en: 'Check out how these two properties are used in the following if-else statement:'
  id: totrans-3573
  prefs: []
  type: TYPE_NORMAL
  zh: 看看下面的 if-else 语句中是如何使用这两个属性的：
- en: '![Image](Image00134.jpg)'
  id: totrans-3574
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00134.jpg)'
- en: 'This if-else statement checks whether the array mySiblings is empty ➊ . If
    it is, then "I don''t have any siblings." is printed. But if there is something
    in the array, then the number of siblings that we have is printed: "I have 3 siblings."
    ➋ .'
  id: totrans-3575
  prefs: []
  type: TYPE_NORMAL
  zh: 这个 if-else 语句检查数组 mySiblings 是否为空 ➊。如果为空，则打印 "我没有兄弟姐妹。"。如果数组中有内容，则打印我们有多少兄弟姐妹："我有
    3 个兄弟姐妹。" ➋。
- en: '**LOOPING OVER AN ARRAY**'
  id: totrans-3576
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**遍历数组**'
- en: 'Sometimes when you’re working with arrays you might want to do something to
    every item in the array. You can use a for-in loop to do that! The following code
    will print every topping in a pizzaToppings array on a separate line:'
  id: totrans-3577
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，在处理数组时，你可能想对数组中的每个项执行某些操作。你可以使用 for-in 循环来做到这一点！以下代码将把 pizzaToppings 数组中的每个配料分别打印到新的一行：
- en: '![Image](Image00135.jpg)'
  id: totrans-3578
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00135.jpg)'
- en: To write a for-in loop for the pizzaToppings array, we used the keyword for
    , followed by the constant topping , then the keyword in , and finally the name
    of our array, pizzaToppings . Then we put the statements that we want to run for
    each topping inside the braces of the for-in loop. The constant topping ➊ temporarily
    represents each pizza topping in the array as we loop through it. We could have
    chosen any name for this constant, but it’s a good idea to pick something that
    makes sense. You can see the output of this for-in loop in [Figure 6-4](text00016.html#ch06fig4)
    .
  id: totrans-3579
  prefs: []
  type: TYPE_NORMAL
  zh: 为了编写 pizzaToppings 数组的 for-in 循环，我们使用了关键字 for，然后是常量 topping，再是关键字 in，最后是我们的数组名称
    pizzaToppings。然后，我们把想对每个配料执行的语句放在 for-in 循环的大括号内。常量 topping ➊ 临时代表数组中的每个配料，随着循环进行。我们本可以为这个常量选择任何名称，但选择一个有意义的名字会更好。你可以在
    [图 6-4](text00016.html#ch06fig4) 中看到这个 for-in 循环的输出。
- en: '![Image](Image00136.jpg)'
  id: totrans-3580
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00136.jpg)'
- en: '*Figure 6-4: Output of the example for-in loop*'
  id: totrans-3581
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 6-4：for-in 循环示例的输出*'
- en: '![Image](Image00137.jpg)'
  id: totrans-3582
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00137.jpg)'
- en: 'Using for-in loops is great for printing every value in an array. If you’re
    working with numbers, you can even use them to perform math operations on each
    item, which makes for some speedy calculations! The following code takes an array
    of numbers and calculates the square for each (the square of a number is that
    number multiplied by itself):'
  id: totrans-3583
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 for-in 循环非常适合打印数组中的每个值。如果你处理的是数字，你甚至可以用它们对每个项执行数学运算，从而进行快速计算！以下代码获取一个数字数组，并计算每个数字的平方（一个数字的平方就是该数字与自身相乘）：
- en: '![Image](Image00138.jpg)'
  id: totrans-3584
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00138.jpg)'
- en: '[Figure 6-5](text00016.html#ch06fig5) shows the results.'
  id: totrans-3585
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 6-5](text00016.html#ch06fig5)展示了结果。'
- en: '![Image](Image00139.jpg)'
  id: totrans-3586
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00139.jpg)'
- en: '*Figure 6-5: Printing the squares for each number in the myNumbers array*'
  id: totrans-3587
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 6-5：打印 myNumbers 数组中每个数字的平方*'
- en: '**DICTIONARIES ARE KEY!**'
  id: totrans-3588
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**字典是关键！**'
- en: A *dictionary* is also a collection of values, but instead of an ordered index,
    each value has its own *key* . Because there’s no index, the values are not stored
    in any particular order. To access values in a dictionary, you look them up by
    their key.
  id: totrans-3589
  prefs: []
  type: TYPE_NORMAL
  zh: '*字典*也是一个值的集合，但与有序索引不同，每个值都有其自己的*键*。由于没有索引，值不会按任何特定顺序存储。要访问字典中的值，你需要通过它们的键来查找。'
- en: A key must be unique. You can’t have the same key more than once in the same
    dictionary. If there were two identical keys and you asked the computer to give
    you the value for one of them, the computer wouldn’t know which one to choose!
  id: totrans-3590
  prefs: []
  type: TYPE_NORMAL
  zh: 键必须是唯一的。你不能在同一个字典中使用相同的键两次。如果有两个相同的键，并且你要求计算机给出其中一个键的值，计算机将无法决定选择哪一个！
- en: Let’s take a look at how to make a dictionary and write keys that will help
    you find all the information you need.
  id: totrans-3591
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看一下如何创建一个字典，并编写能够帮助你找到所需所有信息的键。
- en: '![Image](Image00140.jpg)'
  id: totrans-3592
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00140.jpg)'
- en: '**INITIALIZING A DICTIONARY**'
  id: totrans-3593
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**初始化字典**'
- en: 'To create and initialize a dictionary, first write var and the name of your
    dictionary. Then write the keys and corresponding values inside a pair of square
    brackets, similar to an array. Let’s create a dictionary to store the names of
    a few US states. The key for each state will be its two-letter abbreviation:'
  id: totrans-3594
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建并初始化一个字典，首先写上 var 和字典的名称。然后将键和相应的值写在一对方括号内，类似于数组。我们来创建一个字典，存储几个美国州的名字。每个州的键将是它的两位字母缩写：
- en: '![](Image00141.jpg)'
  id: totrans-3595
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00141.jpg)'
- en: As you can see, there’s a colon between each key and its value, and the key/value
    pairs are separated by commas.
  id: totrans-3596
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，每个键和值之间有一个冒号，键值对之间用逗号分隔。
- en: Dictionaries are different from arrays in that they are *unordered* . Because
    of that, it’s likely that the order of the states that you see in your results
    pane ➋ is different from the order in which you entered your states ➊ . It might
    even be different than the order that’s printed in this book!
  id: totrans-3597
  prefs: []
  type: TYPE_NORMAL
  zh: 字典与数组的不同之处在于它们是*无序*的。因此，你看到的结果面板中的州的顺序 ➋ 可能与输入州的顺序 ➊ 不同。它甚至可能与本书中打印的顺序不同！
- en: As with arrays, you can use var to make a mutable dictionary or use let to make
    an immutable dictionary.
  id: totrans-3598
  prefs: []
  type: TYPE_NORMAL
  zh: 和数组一样，你可以使用var来创建一个可变字典，或者使用let来创建一个不可变字典。
- en: 'In Swift, all of the keys of a dictionary must be the same type, and all of
    the values of a dictionary must also be the same type, but the key type doesn’t
    have to match the value type. For example, if you wanted to store a collection
    of fractions, you could use doubles for the keys and strings for the values:'
  id: totrans-3599
  prefs: []
  type: TYPE_NORMAL
  zh: 在Swift中，字典的所有键必须是相同的类型，字典的所有值也必须是相同的类型，但键的类型不必与值的类型匹配。例如，如果你想存储一组分数，你可以使用双精度浮点数作为键，使用字符串作为值：
- en: '![](Image00142.jpg)'
  id: totrans-3600
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00142.jpg)'
- en: In this dictionary, all of the keys must be doubles, and all of the values must
    be strings. Again, you’ll see that the order of the numbers in the results pane
    can be quite different from the order in which you wrote the fractions in your
    dictionary. This is fine because you don’t need to know the order to access anything.
    You can find any item that you need by its key. Let’s see how!
  id: totrans-3601
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个字典中，所有的键必须是双精度浮点数，所有的值必须是字符串。同样，你会发现结果面板中数字的顺序可能与在字典中书写分数的顺序完全不同。这是没问题的，因为你不需要知道顺序就能访问任何内容。你可以通过键来找到任何需要的项。我们来看看怎么做！
- en: '**ACCESSING VALUES IN A DICTIONARY**'
  id: totrans-3602
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**访问字典中的值**'
- en: 'Looking up a value in a dictionary is similar to how you access a value in
    an array except that you use a key inside the square brackets instead of an index,
    like this: usStates["TX"] .'
  id: totrans-3603
  prefs: []
  type: TYPE_NORMAL
  zh: 查找字典中的值类似于你在数组中访问值的方式，只不过在方括号内使用的是键而不是索引，像这样：usStates["TX"]。
- en: There is a big difference, however, in how Swift returns the values from a dictionary.
    When you access a value at an index of an array, you are simply given the value.
    When you access a value with a key in a dictionary, you are given an optional.
  id: totrans-3604
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在Swift从字典中返回值时有一个很大的区别。当你访问数组中的某个索引的值时，你会直接得到该值。当你使用字典中的键访问值时，你得到的是一个可选值。
- en: In [Chapter 5](text00015.html#ch05) , you learned that optionals might contain
    a value or might be nil . The reason Swift returns optionals when you’re looking
    up items in a dictionary is that the key you used might not exist in the dictionary,
    in which case there’s no value to access. Trying to access a value that doesn’t
    exist would give you a big fat error! To avoid that problem, Swift returns optionals.
    That means you need to unwrap any value you get out of a dictionary before you
    can do anything with it.
  id: totrans-3605
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第5章](text00015.html#ch05)中，你学到可选值可能包含一个值，也可能是nil。Swift在查找字典中的项时返回可选值的原因是，所使用的键可能不存在于字典中，在这种情况下就没有值可以访问。尝试访问一个不存在的值会导致一个大的错误！为了避免这个问题，Swift返回可选值。这意味着你需要解包从字典中获取的任何值，才能对它进行操作。
- en: 'To unwrap an optional, first you check whether it exists using an if-let statement,
    just like we did in [Chapter 5](text00015.html#ch05) . The following code shows
    you how to get a value out of a dictionary:'
  id: totrans-3606
  prefs: []
  type: TYPE_NORMAL
  zh: 要解包一个可选值，首先需要使用if-let语句检查它是否存在，就像我们在[第5章](text00015.html#ch05)中做的那样。以下代码展示了如何从字典中获取一个值：
- en: '![Image](Image00143.jpg)'
  id: totrans-3607
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00143.jpg)'
- en: To retrieve "Texas" from the dictionary, we use if let to set a constant loneStarState
    to usStates["TX"] ➊ . Because we have this state in our dictionary, the line I
    have Texas in my dictionary. is printed. Next we try to access a state that is
    not in our dictionary by using the key usStates["FL"] ➋ . Thankfully, because
    we used an if-let statement, the program won’t crash when the computer can’t find
    this state. Instead, I don't have that state in my dictionary. is printed.
  id: totrans-3608
  prefs: []
  type: TYPE_NORMAL
  zh: 要从字典中获取“德克萨斯州”，我们使用if let将常量loneStarState设置为usStates["TX"] ➊。因为我们在字典中有这个州，所以会打印出“I
    have Texas in my dictionary”。接下来，我们尝试使用键usStates["FL"] ➋访问一个不在字典中的州。幸运的是，由于我们使用了if-let语句，当计算机找不到该州时，程序不会崩溃。相反，会打印出“I
    don't have that state in my dictionary”。
- en: '**ADDING ITEMS TO A DICTIONARY**'
  id: totrans-3609
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**向字典中添加项**'
- en: 'To add an item to a dictionary, first write the name of your dictionary and
    assign the new item to the key you want it to have in the dictionary. Let’s add
    "Minnesota" to our usStates dictionary:'
  id: totrans-3610
  prefs: []
  type: TYPE_NORMAL
  zh: 要向字典中添加项，首先写出字典的名称，并将新项赋给你希望它在字典中拥有的键。我们来将 "Minnesota" 添加到 usStates 字典中：
- en: '![](Image00144.jpg)'
  id: totrans-3611
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00144.jpg)'
- en: 'Now when you look at usStates , you’ll see that it’s updated to ["MN": "Minnesota",
    "WA": "Washington", "MA": "Massachusetts", "TX": "Texas"] . Remember, because
    you don’t have to rely on indices, your new dictionary item might appear anywhere
    in the dictionary.'
  id: totrans-3612
  prefs: []
  type: TYPE_NORMAL
  zh: '现在，当你查看 usStates 时，你会看到它已经更新为 ["MN": "Minnesota", "WA": "Washington", "MA":
    "Massachusetts", "TX": "Texas"]。记住，由于你不必依赖索引，新的字典项可能会出现在字典的任何位置。'
- en: '**REMOVING ITEMS FROM A DICTIONARY**'
  id: totrans-3613
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**从字典中移除项**'
- en: Removing an item from a dictionary is quite simple; you do so by setting the
    value to nil . Because the values in dictionaries are returned as optionals, you
    don’t have to worry about nil causing any problems in your dictionary.
  id: totrans-3614
  prefs: []
  type: TYPE_NORMAL
  zh: 从字典中移除项是相当简单的；你只需要将值设置为 nil。因为字典中的值是可选类型，所以你不必担心 nil 会导致字典出现问题。
- en: '![](Image00145.jpg)'
  id: totrans-3615
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00145.jpg)'
- en: 'You can see that after you remove the value at the key "MA" , usStates is updated
    to ["MN": "Minnesota", "WA": "Washington", "TX": "Texas"] . Remember that nil
    is special and means that there’s no value at all. That’s why you don’t see "MA":
    nil in our dictionary.'
  id: totrans-3616
  prefs: []
  type: TYPE_NORMAL
  zh: '你可以看到，在移除键 "MA" 的值后，usStates 更新为 ["MN": "Minnesota", "WA": "Washington", "TX":
    "Texas"]。记住，nil 是特殊的，表示没有任何值。因此，在我们的字典中你不会看到 "MA": nil。'
- en: '**REPLACING ITEMS IN A DICTIONARY**'
  id: totrans-3617
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**替换字典中的项**'
- en: 'Replacing an item in a dictionary is also easy. It works the same was as replacing
    an item in an array. You just set the item that you want to replace to something
    else. Say you create a dictionary of fruit colors:'
  id: totrans-3618
  prefs: []
  type: TYPE_NORMAL
  zh: 替换字典中的项也很简单。它的工作原理与替换数组中的项相同。你只需将要替换的项设置为其他值。假设你创建了一个水果颜色的字典：
- en: '![](Image00146.jpg)'
  id: totrans-3619
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00146.jpg)'
- en: At first we had the value "apple" for "red" , but then we decided that "raspberry"
    is a better fruit to use since sometimes apples are green or yellow. To replace
    "apple" with "raspberry" , we set colorFruits["red"] to its new value ➊ .
  id: totrans-3620
  prefs: []
  type: TYPE_NORMAL
  zh: 最初我们将 "red" 的值设为 "apple"，但后来我们决定 "raspberry" 是一个更好的水果，因为有时候苹果是绿色或黄色的。为了将 "apple"
    替换为 "raspberry"，我们将 colorFruits["red"] 设置为新的值 ➊。
- en: You may remember that this is the same way we entered a new value into a dictionary.
    If the key already exists in the dictionary, then the value for that key is replaced.
    If the key doesn’t already exist, then the new key/value pair will be added to
    the dictionary.
  id: totrans-3621
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能记得，这与我们向字典中输入新值的方式相同。如果键已经存在于字典中，那么该键的值将被替换。如果键尚不存在，那么新的键/值对将被添加到字典中。
- en: '![Image](Image00147.jpg)'
  id: totrans-3622
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00147.jpg)'
- en: '**USING DICTIONARY PROPERTIES**'
  id: totrans-3623
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**使用字典属性**'
- en: 'Like an array, a dictionary also has an isEmpty property and a count property.
    For example, the following code shows how you can use the isEmpty property to
    check if a dictionary is empty, and if it isn’t empty, the count property checks
    how many items you have. Imagine you have a basket of fruit for sale. You can
    use these properties to help you keep track of everything:'
  id: totrans-3624
  prefs: []
  type: TYPE_NORMAL
  zh: 与数组类似，字典也有 isEmpty 属性和 count 属性。例如，以下代码展示了如何使用 isEmpty 属性检查字典是否为空，如果字典不为空，count
    属性将检查字典中有多少项。假设你有一个待售的水果篮。你可以使用这些属性帮助你跟踪所有内容：
- en: '![Image](Image00148.jpg)'
  id: totrans-3625
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00148.jpg)'
- en: 'A dictionary also has two special properties: keys , which contains all of
    the dictionary’s keys, and values , which contains all of its values. We’ll use
    these two properties when we loop through the dictionary.'
  id: totrans-3626
  prefs: []
  type: TYPE_NORMAL
  zh: 字典还有两个特殊的属性：keys，包含字典的所有键；以及 values，包含字典的所有值。在遍历字典时，我们会使用这两个属性。
- en: Let’s write some code that loops through our fruit baskets and prints the price
    of each fruit.
  id: totrans-3627
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们编写一些代码，遍历我们的水果篮并打印每种水果的价格。
- en: '**LOOPING OVER A DICTIONARY**'
  id: totrans-3628
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**遍历字典**'
- en: 'You can loop through a dictionary using a for-in loop. Because each item has
    a key and a value, you can do this in two different ways. This is how to loop
    through a dictionary using its keys:'
  id: totrans-3629
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用 for-in 循环遍历字典。因为每个项都有一个键和值，所以你可以有两种不同的方式来遍历字典。下面是如何通过键来遍历字典：
- en: '![Image](Image00149.jpg)'
  id: totrans-3630
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00149.jpg)'
- en: Here we use the dictionary’s keys property ➊ to loop through fruitBasket and
    print its contents. We start by writing the keyword for , followed by a constant
    name fruit for the dictionary key, the keyword in , the dictionary name, a period,
    and keys .
  id: totrans-3631
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们使用字典的keys属性 ➊ 来遍历fruitBasket并打印其内容。我们从写关键字for开始，后跟一个常量名称fruit（作为字典键），关键字in，字典名称，句点和keys。
- en: Inside the braces of our for-in loop, we have access to both the key, which
    we call fruit ➋ , and the value at that key when we force-unwrap its contents
    with fruitBasket[fruit]! ➌ . That value will be the fruit’s price.
  id: totrans-3632
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的for-in循环的大括号内，我们可以访问到键，我们称之为fruit ➋，以及在强制解包其内容后通过fruitBasket[fruit]! ➌ 获取的该键对应的值。该值将是水果的价格。
- en: In this case, it’s safe to force-unwrap the value using an exclamation point
    because we know that the fruit key we’re using is definitely inside the dictionary.
  id: totrans-3633
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，使用感叹号强制解包值是安全的，因为我们知道我们使用的fruit键一定在字典中。
- en: Any code we put inside the for-in loop will run once for every key in our dictionary.
    So you should see the print statement display three times.
  id: totrans-3634
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在for-in循环内部放入的任何代码都会针对字典中的每个键运行一次。因此，你应该看到打印语句显示三次。
- en: 'We can also loop through the dictionary using its values property:'
  id: totrans-3635
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以使用字典的values属性进行循环遍历：
- en: '![Image](Image00150.jpg)'
  id: totrans-3636
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Image00150.jpg)'
- en: We use the same style of for-in loop, but now we use a constant to refer to
    each value, which we call price , in the values property. When looping through
    values, we don’t have access to the keys from inside the loop.
  id: totrans-3637
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用相同类型的for-in循环，但现在我们使用一个常量来引用values属性中的每个值，我们称之为price。在循环遍历值时，我们无法从循环内部访问键。
- en: Another difference to note is that price is not an optional because it’s accessed
    directly as a value in the fruitBasket dictionary. That means we don’t have to
    unwrap it. You should still see the print statement printed three times. [Figure
    6-6](text00016.html#ch06fig6) shows the output of both loops.
  id: totrans-3638
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个需要注意的区别是，price不是一个可选值，因为它直接作为fruitBasket字典中的一个值进行访问。这意味着我们不需要对其进行解包。你仍然会看到打印语句被打印三次。[图6-6](text00016.html#ch06fig6)展示了两个循环的输出结果。
- en: '![Image](Image00151.jpg)'
  id: totrans-3639
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Image00151.jpg)'
- en: '*Figure 6-6: Looping through the keys and values of a dictionary with a for-in
    loop*'
  id: totrans-3640
  prefs: []
  type: TYPE_NORMAL
  zh: '*图6-6：使用for-in循环遍历字典的键和值*'
- en: The order of your results might be slightly different from ours. That’s because
    the items in a dictionary aren’t in a numbered order like they are in an array!
    And because the order is not guaranteed, you might see a different order printed
    if you run the same code again.
  id: totrans-3641
  prefs: []
  type: TYPE_NORMAL
  zh: 你的结果顺序可能与我们的略有不同。这是因为字典中的项不像数组那样按编号顺序排列！并且由于顺序无法保证，如果你再次运行相同的代码，你可能会看到不同的顺序打印出来。
- en: '**WHAT YOU LEARNED**'
  id: totrans-3642
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**你学到的内容**'
- en: In this chapter, you learned how to store collections of items in an array and
    in a dictionary. To store items in an ordered list, you would use an array and
    look up each item by its index. If you wanted to store items by key instead, you
    would use a dictionary.
  id: totrans-3643
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你学习了如何在数组和字典中存储项。为了存储有序列表中的项，你将使用数组，并通过索引查找每一项。如果你想通过键存储项，你将使用字典。
- en: Knowing about arrays and dictionaries and how to use them is a powerful building
    block for almost any programming language. Next we will learn about functions,
    another very powerful tool. Functions are blocks of code that you create and name
    to perform a specific job. After you have written a function, you can use its
    name to call it from almost anywhere in your program.
  id: totrans-3644
  prefs: []
  type: TYPE_NORMAL
  zh: 了解数组和字典及其用法是几乎所有编程语言中强大的构建块。接下来，我们将学习函数，这是另一个非常强大的工具。函数是你创建并命名的一块代码，用于执行特定任务。编写函数后，你可以在程序中的几乎任何地方通过调用函数名来使用它。
- en: '**WATCHING THE RANGE**'
  id: totrans-3645
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**观察范围**'
- en: One important point about arrays is that if you try to access an item at an
    index that’s higher than the last index in the array, you’ll get an error. In
    [Figure 6-2](text00016.html#ch06fig2) , you can see that nationalParks[3] (which
    would be the fourth item in the array) gives you an error because there are only
    three national parks in the array, indexed from 0 to 2.
  id: totrans-3646
  prefs: []
  type: TYPE_NORMAL
  zh: 关于数组的一个重要点是，如果你尝试访问一个索引大于数组最后一个索引的项，你会得到一个错误。在[图6-2](text00016.html#ch06fig2)中，你可以看到nationalParks[3]（这将是数组中的第四项）会给出一个错误，因为数组中只有三个国家公园，索引从0到2。
- en: As you can see, you get an error message that says Index out of range . If you
    try to access an item that doesn’t exist in your array, your app will crash!
  id: totrans-3647
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，你会收到一个错误信息，提示“索引超出范围”。如果你尝试访问一个不存在的数组项，应用程序将崩溃！
- en: '![Image](Image00119.jpg)'
  id: totrans-3648
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00119.jpg)'
- en: '*Figure 6-2: Trying to access an index in the array where nothing exists causes
    an error.*'
  id: totrans-3649
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 6-2：尝试访问数组中不存在的索引会导致错误。*'
- en: '**ADDING ITEMS TO AN ARRAY**'
  id: totrans-3650
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**向数组添加项**'
- en: One way to change an array is to add new items to it. There are a few different
    ways to do this, so let’s take a look at each.
  id: totrans-3651
  prefs: []
  type: TYPE_NORMAL
  zh: 改变数组的一种方式是向其中添加新项。这个过程有几种不同的方法，让我们来看看每一种。
- en: 'First, you can use an array’s append(_:) method. *Append* means to add something.
    Using append(_:) , you can add one new item to the end of your array. Say you
    go on another trip and visit the Badlands, and you want to add it to your list
    of national parks. To do that, add this code into your playground:'
  id: totrans-3652
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，你可以使用数组的 append(_:) 方法。*Append* 意味着添加某个东西。使用 append(_:)，你可以将一个新项添加到数组的末尾。假设你又去旅行，参观了
    Badlands，并且想将它加入到你的国家公园列表中。为此，将以下代码添加到你的 playground 中：
- en: '![](Image00120.jpg)'
  id: totrans-3653
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00120.jpg)'
- en: To use the append(_:) method, first write the name of your array followed by
    a period and then append . Then, put the item you want to add to your array inside
    the parentheses. In this case, you put "Badlands" inside the parentheses.
  id: totrans-3654
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用 append(_:) 方法，首先写出数组的名称，后跟一个句点，然后是 append。然后，将你要添加到数组中的项放入括号内。在这个例子中，你将
    "Badlands" 放入括号中。
- en: 'If you want to add something at a specific place in your array, use the array’s
    insert(_:at:) method instead. This method takes two arguments: the item that you
    want to insert and the index of where it should go in the array. (We’ll discuss
    arguments in more detail in [Chapter 7](text00017.html#ch07) .)'
  id: totrans-3655
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想在数组中的特定位置添加某个东西，可以改用数组的 insert(_:at:) 方法。此方法接受两个参数：你想要插入的项和它在数组中应放置的位置索引。（我们将在[第
    7 章](text00017.html#ch07) 中更详细地讨论参数。）
- en: 'Let’s say you totally forgot that you went to the Petrified Forest right after
    you visited the Grand Canyon, and you want to update your nationalParks array
    so it displays the parks in the order in which you visited them. To update your
    array, you could use the insert(_:at:) method to put the Petrified Forest in the
    right position:'
  id: totrans-3656
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你完全忘记了自己是在参观了大峡谷之后去的 Petrified Forest，并且你想更新你的 nationalParks 数组，以按你参观的顺序显示公园。为了更新数组，你可以使用
    insert(_:at:) 方法，将 Petrified Forest 放到正确的位置：
- en: '![](Image00121.jpg)'
  id: totrans-3657
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00121.jpg)'
- en: When you insert a new item at index 3, everything that was in the array at index
    3 or higher gets scooted over to make room for the new item. That means the item
    that was at index 3 is now at index 4, the item that was at index 4 is now at
    index 5, and so on. After you add the Petrified Forest, nationalParks is now ["Acadia",
    "Zion", "Grand Canyon", "Petrified Forest", "Badlands"] .
  id: totrans-3658
  prefs: []
  type: TYPE_NORMAL
  zh: 当你在索引 3 处插入一个新项时，数组中索引 3 或更高的所有项都会被移动，以腾出空间给新项。这意味着原本在索引 3 处的项现在位于索引 4，原本在索引
    4 处的项现在位于索引 5，依此类推。在你添加了 Petrified Forest 后，nationalParks 现在是 ["Acadia", "Zion",
    "Grand Canyon", "Petrified Forest", "Badlands"]。
- en: '**COMBINING ARRAYS**'
  id: totrans-3659
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**合并数组**'
- en: 'Not only can you add new items to an array, but you can also add two arrays
    together using the + and += operators. Let’s say that you have the ingredients
    for a fruit smoothie in two arrays:'
  id: totrans-3660
  prefs: []
  type: TYPE_NORMAL
  zh: 你不仅可以向数组中添加新项，还可以使用 + 和 += 运算符将两个数组连接起来。假设你有两个数组，分别存储制作水果冰沙的原料：
- en: '![](Image00122.jpg)'
  id: totrans-3661
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00122.jpg)'
- en: Now you can make a delicious smoothie by adding the fruits and liquids arrays.
  id: totrans-3662
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你可以通过添加 fruits 和 liquids 数组制作美味的冰沙。
- en: '![](Image00123.jpg)'
  id: totrans-3663
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00123.jpg)'
- en: The order of the ingredients in smoothie is the same as the order in fruits
    and liquids . If you created smoothie with liquids + fruits , then the liquids
    would come first.
  id: totrans-3664
  prefs: []
  type: TYPE_NORMAL
  zh: 冰沙中原料的顺序与 fruits 和 liquids 数组中的顺序相同。如果你是用 liquids + fruits 创建冰沙，那么 liquids 会排在前面。
- en: 'You use the += operator to add an array to the end of your array. Add some
    whipped cream as follows for extra yumminess:'
  id: totrans-3665
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用 += 运算符将一个数组添加到另一个数组的末尾。为增加更多美味，可以按照以下方式添加一些鲜奶油：
- en: '![](Image00124.jpg)'
  id: totrans-3666
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00124.jpg)'
- en: Note that ["whipped cream"] is an array even though it has a single item in
    it. When you’re using += to append something to an array, you have to make sure
    you’re only trying to add another array. If you were to just write the string
    "whipped cream" without the square brackets around it, you would get an error.
  id: totrans-3667
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，["whipped cream"] 是一个数组，尽管它只有一个项。当你使用 += 向数组添加内容时，你必须确保你只是在添加另一个数组。如果你仅仅写了字符串
    "whipped cream" 而没有加上方括号，你会得到一个错误。
- en: '![Image](Image00125.jpg)'
  id: totrans-3668
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00125.jpg)'
- en: '**REMOVING ITEMS FROM AN ARRAY**'
  id: totrans-3669
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**从数组中移除项**'
- en: 'There are several methods for removing items from an array. Let’s start by
    looking at the array’s removeLast() method. As you might have guessed from its
    name, removeLast() removes the last item from your array. Let’s try it out with
    a shoppingList array:'
  id: totrans-3670
  prefs: []
  type: TYPE_NORMAL
  zh: 删除数组中的项有几种方法。让我们先来看看数组的 removeLast() 方法。正如你从它的名字中可能猜到的，removeLast() 会删除数组中的最后一项。让我们尝试在购物清单数组中使用它：
- en: '![](Image00126.jpg)'
  id: totrans-3671
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00126.jpg)'
- en: Neat! Note that the removeLast() method returns the removed item, so you can
    store it in a new constant or variable if you want.
  id: totrans-3672
  prefs: []
  type: TYPE_NORMAL
  zh: 很棒！请注意，removeLast() 方法返回被删除的项，因此如果你想，你可以将其存储在一个新的常量或变量中。
- en: 'You can also remove an item from a specific index by using the remove(at:)
    method. Let’s say that your mom doesn’t want you buying any candy and takes that
    off the list:'
  id: totrans-3673
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以通过使用 remove(at:) 方法从特定索引位置删除项。假设你的妈妈不希望你买任何糖果，并将其从列表中移除：
- en: '![Image](Image00127.jpg)![](Image00128.jpg)'
  id: totrans-3674
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00127.jpg)![](Image00128.jpg)'
- en: Just like when we added an item to the middle of our array and all the items
    scooted over to make room, if you remove an item from the middle of an array,
    the rest of the items will scoot back to fill in that empty space. The "apples"
    item that was at index 3 is now at index 2, where "candy" was.
  id: totrans-3675
  prefs: []
  type: TYPE_NORMAL
  zh: 就像我们将项添加到数组中间时，所有其他项都向一边移动腾出空间一样，如果你从数组中间删除一项，其他项也会向回移动，填补那个空缺的位置。原本位于索引 3 的
    "苹果" 现在位于索引 2，原本位于该位置的 "糖果" 被移除。
- en: 'You can also remove all items from an array with removeAll() . Try entering
    this into your playground:'
  id: totrans-3676
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以使用 removeAll() 删除数组中的所有项。尝试在你的 Playground 中输入这个：
- en: '![](Image00129.jpg)'
  id: totrans-3677
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00129.jpg)'
- en: 'Note that trying to remove an item at an index that doesn’t exist will give
    you an error:'
  id: totrans-3678
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，尝试删除一个不存在的索引位置的项会导致错误：
- en: '![](Image00130.jpg)'
  id: totrans-3679
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00130.jpg)'
- en: Our array doesn’t have this many items (in fact, now it’s empty!), so this throws
    an error. We’ll also get an error if we use removeLast() on our empty array, because
    there’s nothing in it—there’s no last index at all! However, removeAll() is always
    safe to use, even on an empty array.
  id: totrans-3680
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的数组没有这么多项（实际上，现在它是空的！），因此会抛出一个错误。如果我们在空数组上使用 removeLast()，也会出错，因为数组中没有任何内容——根本没有最后一个索引！不过，removeAll()
    在空数组上也始终是安全的。
- en: '**REPLACING ITEMS IN AN ARRAY**'
  id: totrans-3681
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**替换数组中的项**'
- en: 'To replace an item in an array, you set the index of the array to the new value,
    as shown here:'
  id: totrans-3682
  prefs: []
  type: TYPE_NORMAL
  zh: 要替换数组中的项，你只需要将数组的某个索引位置赋值为新的值，如下所示：
- en: '![](Image00131.jpg)'
  id: totrans-3683
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00131.jpg)'
- en: At ➊ , we replaced the item at index 2 (the third item) with "Unicorn" because
    magical animals count as favorite animals, too! At ➋ , we replaced the item at
    index 0 (the first item) with "Bearded dragon" . No, that’s not a real dragon—it’s
    just a lizard!
  id: totrans-3684
  prefs: []
  type: TYPE_NORMAL
  zh: 在 ➊ 处，我们将索引 2 （第三项）上的项替换成了 "独角兽"，因为魔法动物也算作最爱的动物！在 ➋ 处，我们将索引 0 （第一项）上的项替换成了 "胡须龙"。不，这不是一条真正的龙——它只是一个蜥蜴！
- en: Like any time you’re working with array index numbers, you have to be sure an
    item exists in the array at that index before you change its value, or you will
    get an Index out of range error.
  id: totrans-3685
  prefs: []
  type: TYPE_NORMAL
  zh: 就像任何处理数组索引时一样，你必须确保该索引位置的项在数组中存在，否则你会得到一个 "索引超出范围" 的错误。
- en: '[Figure 6-3](text00016.html#ch06fig3) shows the error that occurs if you try
    to add "Standard poodle" using favoriteAnimals[3] = "Standard poodle" . To add
    an item to the end of an array, you should use the append(_:) method or += , as
    we covered in “[Adding Items to an Array](text00016.html#ch06lev2sec5) ” on [page
    70](text00016.html#page_70) .'
  id: totrans-3686
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 6-3](text00016.html#ch06fig3) 显示了如果你尝试使用 favoriteAnimals[3] = "标准贵宾犬" 添加项时发生的错误。要将项添加到数组的末尾，应该使用
    append(_:) 方法或 += ，正如我们在 “[向数组添加项](text00016.html#ch06lev2sec5)” 中所讲解的，在 [第 70
    页](text00016.html#page_70)。'
- en: '![Image](Image00132.jpg)'
  id: totrans-3687
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00132.jpg)'
- en: '*Figure 6-3: Don’t try to replace a value at an index beyond the existing array.*'
  id: totrans-3688
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 6-3：不要尝试在超出现有数组范围的索引位置替换值。*'
- en: Now you know how to change arrays however you might need to. You can add items,
    take items away, or replace items. Next, we’ll look at how to use the properties
    of arrays to find out even more information about them.
  id: totrans-3689
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经知道如何根据需要修改数组。你可以添加项，删除项，或替换项。接下来，我们将看看如何使用数组的属性来获取更多关于它们的信息。
- en: '![Image](Image00133.jpg)'
  id: totrans-3690
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00133.jpg)'
- en: '**USING ARRAY PROPERTIES**'
  id: totrans-3691
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**使用数组属性**'
- en: In addition to methods like append(_:) and removeLast() , arrays also have *properties*
    . An array’s properties are variables or constants that contain some information
    about the array. Two really helpful properties that you might use are the Boolean
    property isEmpty and the integer property count .
  id: totrans-3692
  prefs: []
  type: TYPE_NORMAL
  zh: 除了像 append(_:) 和 removeLast() 这样的函数，数组还有*属性*。数组的属性是包含有关数组信息的变量或常量。你可能会用到的两个非常有用的属性是布尔类型的
    isEmpty 属性和整数类型的 count 属性。
- en: The isEmpty property is true or false depending on whether the array is empty,
    and the count property will tell you how many items are in that array.
  id: totrans-3693
  prefs: []
  type: TYPE_NORMAL
  zh: isEmpty 属性根据数组是否为空返回 true 或 false，count 属性则会告诉你数组中有多少项。
- en: 'Check out how these two properties are used in the following if-else statement:'
  id: totrans-3694
  prefs: []
  type: TYPE_NORMAL
  zh: 看一下这些属性在以下 if-else 语句中的使用方式：
- en: '![Image](Image00134.jpg)'
  id: totrans-3695
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00134.jpg)'
- en: 'This if-else statement checks whether the array mySiblings is empty ➊ . If
    it is, then "I don''t have any siblings." is printed. But if there is something
    in the array, then the number of siblings that we have is printed: "I have 3 siblings."
    ➋ .'
  id: totrans-3696
  prefs: []
  type: TYPE_NORMAL
  zh: 这个 if-else 语句检查 mySiblings 数组是否为空 ➊。如果是空的，则打印 “我没有兄弟姐妹。” 如果数组里有东西，则打印我们有多少个兄弟姐妹：“我有
    3 个兄弟姐妹。” ➋。
- en: '**LOOPING OVER AN ARRAY**'
  id: totrans-3697
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**遍历数组**'
- en: 'Sometimes when you’re working with arrays you might want to do something to
    every item in the array. You can use a for-in loop to do that! The following code
    will print every topping in a pizzaToppings array on a separate line:'
  id: totrans-3698
  prefs: []
  type: TYPE_NORMAL
  zh: 有时在处理数组时，你可能想对数组中的每个项执行某些操作。你可以使用 for-in 循环来做到这一点！以下代码将在单独的行上打印 pizzaToppings
    数组中的每个配料：
- en: '![Image](Image00135.jpg)'
  id: totrans-3699
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00135.jpg)'
- en: To write a for-in loop for the pizzaToppings array, we used the keyword for
    , followed by the constant topping , then the keyword in , and finally the name
    of our array, pizzaToppings . Then we put the statements that we want to run for
    each topping inside the braces of the for-in loop. The constant topping ➊ temporarily
    represents each pizza topping in the array as we loop through it. We could have
    chosen any name for this constant, but it’s a good idea to pick something that
    makes sense. You can see the output of this for-in loop in [Figure 6-4](text00016.html#ch06fig4)
    .
  id: totrans-3700
  prefs: []
  type: TYPE_NORMAL
  zh: 要为 pizzaToppings 数组编写 for-in 循环，我们使用了关键字 for，后面跟着常量 topping，然后是关键字 in，最后是我们数组的名称
    pizzaToppings。接着我们将每次遍历数组时要执行的语句放在 for-in 循环的大括号中。常量 topping ➊ 在我们遍历数组时临时代表每个披萨配料。我们本可以为这个常量选择任何名称，但选择一个有意义的名称是个好主意。你可以在
    [图6-4](text00016.html#ch06fig4) 中看到这个 for-in 循环的输出。
- en: '![Image](Image00136.jpg)'
  id: totrans-3701
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00136.jpg)'
- en: '*Figure 6-4: Output of the example for-in loop*'
  id: totrans-3702
  prefs: []
  type: TYPE_NORMAL
  zh: '*图6-4：示例 for-in 循环的输出*'
- en: '![Image](Image00137.jpg)'
  id: totrans-3703
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00137.jpg)'
- en: 'Using for-in loops is great for printing every value in an array. If you’re
    working with numbers, you can even use them to perform math operations on each
    item, which makes for some speedy calculations! The following code takes an array
    of numbers and calculates the square for each (the square of a number is that
    number multiplied by itself):'
  id: totrans-3704
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 for-in 循环非常适合打印数组中的每个值。如果你处理的是数字，你甚至可以利用它们对每一项进行数学运算，从而加快计算速度！以下代码获取一个数字数组，并计算每个数字的平方（一个数字的平方是它自己与自己的乘积）：
- en: '![Image](Image00138.jpg)'
  id: totrans-3705
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00138.jpg)'
- en: '[Figure 6-5](text00016.html#ch06fig5) shows the results.'
  id: totrans-3706
  prefs: []
  type: TYPE_NORMAL
  zh: '[图6-5](text00016.html#ch06fig5)展示了结果。'
- en: '![Image](Image00139.jpg)'
  id: totrans-3707
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00139.jpg)'
- en: '*Figure 6-5: Printing the squares for each number in the myNumbers array*'
  id: totrans-3708
  prefs: []
  type: TYPE_NORMAL
  zh: '*图6-5：打印 myNumbers 数组中每个数字的平方*'
- en: '**DICTIONARIES ARE KEY!**'
  id: totrans-3709
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**字典是关键！**'
- en: A *dictionary* is also a collection of values, but instead of an ordered index,
    each value has its own *key* . Because there’s no index, the values are not stored
    in any particular order. To access values in a dictionary, you look them up by
    their key.
  id: totrans-3710
  prefs: []
  type: TYPE_NORMAL
  zh: '*字典*也是一组值的集合，但与有序索引的数组不同，每个值都有自己的*键*。由于没有索引，值的存储没有特定的顺序。要访问字典中的值，必须通过其键进行查找。'
- en: A key must be unique. You can’t have the same key more than once in the same
    dictionary. If there were two identical keys and you asked the computer to give
    you the value for one of them, the computer wouldn’t know which one to choose!
  id: totrans-3711
  prefs: []
  type: TYPE_NORMAL
  zh: 键必须是唯一的。同一个字典中不能有重复的键。如果有两个相同的键，且你请求计算机给出其中一个键的值，计算机将不知道选择哪个！
- en: Let’s take a look at how to make a dictionary and write keys that will help
    you find all the information you need.
  id: totrans-3712
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看一下如何创建字典，并编写有助于你找到所有需要信息的键。
- en: '![Image](Image00140.jpg)'
  id: totrans-3713
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00140.jpg)'
- en: '**INITIALIZING A DICTIONARY**'
  id: totrans-3714
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**初始化字典**'
- en: 'To create and initialize a dictionary, first write var and the name of your
    dictionary. Then write the keys and corresponding values inside a pair of square
    brackets, similar to an array. Let’s create a dictionary to store the names of
    a few US states. The key for each state will be its two-letter abbreviation:'
  id: totrans-3715
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建并初始化一个字典，首先写上 `var` 和字典的名称。然后将键和值以一对方括号的形式写在一起，类似于数组。让我们创建一个字典来存储一些美国州的名称。每个州的键将是它的两字母缩写：
- en: '![](Image00141.jpg)'
  id: totrans-3716
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00141.jpg)'
- en: As you can see, there’s a colon between each key and its value, and the key/value
    pairs are separated by commas.
  id: totrans-3717
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，每个键和值之间有一个冒号，键/值对之间用逗号分隔。
- en: Dictionaries are different from arrays in that they are *unordered* . Because
    of that, it’s likely that the order of the states that you see in your results
    pane ➋ is different from the order in which you entered your states ➊ . It might
    even be different than the order that’s printed in this book!
  id: totrans-3718
  prefs: []
  type: TYPE_NORMAL
  zh: 字典与数组的不同之处在于它们是 *无序的*。因此，你在结果面板中看到的州的顺序 ➋ 可能与输入州的顺序 ➊ 完全不同。甚至可能与本书中打印的顺序不同！
- en: As with arrays, you can use var to make a mutable dictionary or use let to make
    an immutable dictionary.
  id: totrans-3719
  prefs: []
  type: TYPE_NORMAL
  zh: 与数组类似，你可以使用 `var` 来创建一个可变字典，或者使用 `let` 来创建一个不可变字典。
- en: 'In Swift, all of the keys of a dictionary must be the same type, and all of
    the values of a dictionary must also be the same type, but the key type doesn’t
    have to match the value type. For example, if you wanted to store a collection
    of fractions, you could use doubles for the keys and strings for the values:'
  id: totrans-3720
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Swift 中，字典的所有键必须是相同类型，字典的所有值也必须是相同类型，但键的类型不必与值的类型匹配。例如，如果你想存储一个分数集合，你可以使用
    `double` 类型作为键，使用字符串类型作为值：
- en: '![](Image00142.jpg)'
  id: totrans-3721
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00142.jpg)'
- en: In this dictionary, all of the keys must be doubles, and all of the values must
    be strings. Again, you’ll see that the order of the numbers in the results pane
    can be quite different from the order in which you wrote the fractions in your
    dictionary. This is fine because you don’t need to know the order to access anything.
    You can find any item that you need by its key. Let’s see how!
  id: totrans-3722
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个字典中，所有的键必须是 `double` 类型，所有的值必须是字符串类型。同样，你会发现，结果面板中数字的顺序可能与字典中分数的输入顺序完全不同。这是正常的，因为你不需要知道顺序就能访问任何内容。你可以通过键来查找任何你需要的项。我们来看看如何操作！
- en: '**ACCESSING VALUES IN A DICTIONARY**'
  id: totrans-3723
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**访问字典中的值**'
- en: 'Looking up a value in a dictionary is similar to how you access a value in
    an array except that you use a key inside the square brackets instead of an index,
    like this: usStates["TX"] .'
  id: totrans-3724
  prefs: []
  type: TYPE_NORMAL
  zh: 在字典中查找一个值的方式与在数组中访问一个值类似，只是你需要使用方括号中的键，而不是索引，像这样：`usStates["TX"]`。
- en: There is a big difference, however, in how Swift returns the values from a dictionary.
    When you access a value at an index of an array, you are simply given the value.
    When you access a value with a key in a dictionary, you are given an optional.
  id: totrans-3725
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，Swift 返回字典值的方式有一个很大的不同。当你在数组的索引位置访问值时，你会直接得到该值。当你使用键在字典中访问值时，你会得到一个可选值。
- en: In [Chapter 5](text00015.html#ch05) , you learned that optionals might contain
    a value or might be nil . The reason Swift returns optionals when you’re looking
    up items in a dictionary is that the key you used might not exist in the dictionary,
    in which case there’s no value to access. Trying to access a value that doesn’t
    exist would give you a big fat error! To avoid that problem, Swift returns optionals.
    That means you need to unwrap any value you get out of a dictionary before you
    can do anything with it.
  id: totrans-3726
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第五章](text00015.html#ch05)中，你学到过可选类型可能包含一个值，也可能是 `nil`。Swift 在你查找字典中的项时返回可选类型的原因是，你使用的键可能在字典中不存在，在这种情况下就没有值可以访问。如果尝试访问一个不存在的值，会得到一个错误！为了避免这个问题，Swift
    返回可选类型。这意味着你需要在对字典中获取的值进行操作之前，先解包该值。
- en: 'To unwrap an optional, first you check whether it exists using an if-let statement,
    just like we did in [Chapter 5](text00015.html#ch05) . The following code shows
    you how to get a value out of a dictionary:'
  id: totrans-3727
  prefs: []
  type: TYPE_NORMAL
  zh: 要解包一个可选类型，首先使用 `if-let` 语句检查它是否存在，就像我们在[第五章](text00015.html#ch05)中所做的那样。下面的代码展示了如何从字典中获取一个值：
- en: '![Image](Image00143.jpg)'
  id: totrans-3728
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00143.jpg)'
- en: To retrieve "Texas" from the dictionary, we use if let to set a constant loneStarState
    to usStates["TX"] ➊ . Because we have this state in our dictionary, the line I
    have Texas in my dictionary. is printed. Next we try to access a state that is
    not in our dictionary by using the key usStates["FL"] ➋ . Thankfully, because
    we used an if-let statement, the program won’t crash when the computer can’t find
    this state. Instead, I don't have that state in my dictionary. is printed.
  id: totrans-3729
  prefs: []
  type: TYPE_NORMAL
  zh: 要从字典中获取 "Texas"，我们使用 if let 将常量 loneStarState 设置为 usStates["TX"] ➊。因为字典中有这个州，所以打印了“我有
    Texas 在我的字典中”。接下来，我们尝试使用键 usStates["FL"] ➋ 访问一个字典中没有的州。幸运的是，由于我们使用了 if-let 语句，当计算机找不到这个州时，程序不会崩溃。相反，打印了“我的字典中没有这个州”。
- en: '**ADDING ITEMS TO A DICTIONARY**'
  id: totrans-3730
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**向字典添加项**'
- en: 'To add an item to a dictionary, first write the name of your dictionary and
    assign the new item to the key you want it to have in the dictionary. Let’s add
    "Minnesota" to our usStates dictionary:'
  id: totrans-3731
  prefs: []
  type: TYPE_NORMAL
  zh: 要向字典中添加项，首先写下字典的名称，并将新项分配给你希望它在字典中对应的键。让我们将 "Minnesota" 添加到我们的 usStates 字典中：
- en: '![](Image00144.jpg)'
  id: totrans-3732
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00144.jpg)'
- en: 'Now when you look at usStates , you’ll see that it’s updated to ["MN": "Minnesota",
    "WA": "Washington", "MA": "Massachusetts", "TX": "Texas"] . Remember, because
    you don’t have to rely on indices, your new dictionary item might appear anywhere
    in the dictionary.'
  id: totrans-3733
  prefs: []
  type: TYPE_NORMAL
  zh: '现在，当你查看 usStates 时，你会看到它已更新为 ["MN": "Minnesota", "WA": "Washington", "MA":
    "Massachusetts", "TX": "Texas"]。记住，由于你不需要依赖索引，你的新字典项可能出现在字典中的任何位置。'
- en: '**REMOVING ITEMS FROM A DICTIONARY**'
  id: totrans-3734
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**从字典中移除项**'
- en: Removing an item from a dictionary is quite simple; you do so by setting the
    value to nil . Because the values in dictionaries are returned as optionals, you
    don’t have to worry about nil causing any problems in your dictionary.
  id: totrans-3735
  prefs: []
  type: TYPE_NORMAL
  zh: 从字典中移除项非常简单；你只需将值设置为 nil。因为字典中的值是以可选值的形式返回的，所以你不需要担心 nil 会在字典中造成任何问题。
- en: '![](Image00145.jpg)'
  id: totrans-3736
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00145.jpg)'
- en: 'You can see that after you remove the value at the key "MA" , usStates is updated
    to ["MN": "Minnesota", "WA": "Washington", "TX": "Texas"] . Remember that nil
    is special and means that there’s no value at all. That’s why you don’t see "MA":
    nil in our dictionary.'
  id: totrans-3737
  prefs: []
  type: TYPE_NORMAL
  zh: '你可以看到，在移除键“MA”的值后，usStates 被更新为 ["MN": "Minnesota", "WA": "Washington", "TX":
    "Texas"]。请记住，nil 是特殊的，表示没有值。因此，你在字典中不会看到 "MA": nil。'
- en: '**REPLACING ITEMS IN A DICTIONARY**'
  id: totrans-3738
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**替换字典中的项**'
- en: 'Replacing an item in a dictionary is also easy. It works the same was as replacing
    an item in an array. You just set the item that you want to replace to something
    else. Say you create a dictionary of fruit colors:'
  id: totrans-3739
  prefs: []
  type: TYPE_NORMAL
  zh: 替换字典中的项也很简单。它与替换数组中的项相同。你只需将要替换的项设置为其他值。假设你创建了一个水果颜色的字典：
- en: '![](Image00146.jpg)'
  id: totrans-3740
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00146.jpg)'
- en: At first we had the value "apple" for "red" , but then we decided that "raspberry"
    is a better fruit to use since sometimes apples are green or yellow. To replace
    "apple" with "raspberry" , we set colorFruits["red"] to its new value ➊ .
  id: totrans-3741
  prefs: []
  type: TYPE_NORMAL
  zh: 一开始，我们为 "red" 设置了值 "apple"，但后来我们决定 "raspberry" 是一个更好的水果，因为有时候苹果是绿色或黄色的。为了将 "apple"
    替换为 "raspberry"，我们将 colorFruits["red"] 设置为它的新值 ➊。
- en: You may remember that this is the same way we entered a new value into a dictionary.
    If the key already exists in the dictionary, then the value for that key is replaced.
    If the key doesn’t already exist, then the new key/value pair will be added to
    the dictionary.
  id: totrans-3742
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能还记得，这和我们向字典中输入新值的方法一样。如果键已经存在于字典中，那么该键的值将被替换。如果键不存在，则新的键值对会被添加到字典中。
- en: '![Image](Image00147.jpg)'
  id: totrans-3743
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00147.jpg)'
- en: '**USING DICTIONARY PROPERTIES**'
  id: totrans-3744
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**使用字典属性**'
- en: 'Like an array, a dictionary also has an isEmpty property and a count property.
    For example, the following code shows how you can use the isEmpty property to
    check if a dictionary is empty, and if it isn’t empty, the count property checks
    how many items you have. Imagine you have a basket of fruit for sale. You can
    use these properties to help you keep track of everything:'
  id: totrans-3745
  prefs: []
  type: TYPE_NORMAL
  zh: 类似于数组，字典也有 isEmpty 属性和 count 属性。例如，以下代码展示了如何使用 isEmpty 属性来检查字典是否为空，如果字典不为空，则使用
    count 属性检查字典中有多少项。想象一下，你有一个水果篮子在出售。你可以使用这些属性来帮助你跟踪所有物品：
- en: '![Image](Image00148.jpg)'
  id: totrans-3746
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00148.jpg)'
- en: 'A dictionary also has two special properties: keys , which contains all of
    the dictionary’s keys, and values , which contains all of its values. We’ll use
    these two properties when we loop through the dictionary.'
  id: totrans-3747
  prefs: []
  type: TYPE_NORMAL
  zh: 字典还有两个特殊的属性：keys，包含字典中的所有键，和 values，包含所有值。当我们遍历字典时，会使用这两个属性。
- en: Let’s write some code that loops through our fruit baskets and prints the price
    of each fruit.
  id: totrans-3748
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们写一些代码，循环遍历我们的果篮并打印每种水果的价格。
- en: '**LOOPING OVER A DICTIONARY**'
  id: totrans-3749
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**遍历字典**'
- en: 'You can loop through a dictionary using a for-in loop. Because each item has
    a key and a value, you can do this in two different ways. This is how to loop
    through a dictionary using its keys:'
  id: totrans-3750
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用for-in循环遍历字典。因为每个项目都有一个键和值，所以你可以用两种不同的方式来做。以下是使用键遍历字典的方法：
- en: '![Image](Image00149.jpg)'
  id: totrans-3751
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Image00149.jpg)'
- en: Here we use the dictionary’s keys property ➊ to loop through fruitBasket and
    print its contents. We start by writing the keyword for , followed by a constant
    name fruit for the dictionary key, the keyword in , the dictionary name, a period,
    and keys .
  id: totrans-3752
  prefs: []
  type: TYPE_NORMAL
  zh: 这里我们使用字典的keys属性 ➊ 来遍历fruitBasket并打印其内容。我们从写关键字for开始，后跟字典键的常量名称fruit，关键字in，字典名称，一个句点，以及keys。
- en: Inside the braces of our for-in loop, we have access to both the key, which
    we call fruit ➋ , and the value at that key when we force-unwrap its contents
    with fruitBasket[fruit]! ➌ . That value will be the fruit’s price.
  id: totrans-3753
  prefs: []
  type: TYPE_NORMAL
  zh: 在for-in循环的大括号内，我们可以访问到键，我们称其为fruit ➋ ，以及该键的值，当我们使用fruitBasket[fruit]!强制解包它的内容时
    ➌。那个值将是水果的价格。
- en: In this case, it’s safe to force-unwrap the value using an exclamation point
    because we know that the fruit key we’re using is definitely inside the dictionary.
  id: totrans-3754
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，使用感叹号强制解包值是安全的，因为我们知道我们使用的水果键一定在字典中。
- en: Any code we put inside the for-in loop will run once for every key in our dictionary.
    So you should see the print statement display three times.
  id: totrans-3755
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在for-in循环中写的任何代码都会为字典中的每个键执行一次。所以你应该会看到打印语句显示三次。
- en: 'We can also loop through the dictionary using its values property:'
  id: totrans-3756
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以使用字典的values属性来循环遍历字典：
- en: '![Image](Image00150.jpg)'
  id: totrans-3757
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Image00150.jpg)'
- en: We use the same style of for-in loop, but now we use a constant to refer to
    each value, which we call price , in the values property. When looping through
    values, we don’t have access to the keys from inside the loop.
  id: totrans-3758
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用相同的for-in循环方式，但现在我们用一个常量来表示values属性中的每个值，我们称其为price。在遍历值时，我们无法在循环内访问到键。
- en: Another difference to note is that price is not an optional because it’s accessed
    directly as a value in the fruitBasket dictionary. That means we don’t have to
    unwrap it. You should still see the print statement printed three times. [Figure
    6-6](text00016.html#ch06fig6) shows the output of both loops.
  id: totrans-3759
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个需要注意的区别是，价格不是一个可选项，因为它直接作为一个值被访问在fruitBasket字典中。这意味着我们不需要解包它。你应该仍然会看到打印语句被打印三次。[图
    6-6](text00016.html#ch06fig6)显示了两个循环的输出。
- en: '![Image](Image00151.jpg)'
  id: totrans-3760
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Image00151.jpg)'
- en: '*Figure 6-6: Looping through the keys and values of a dictionary with a for-in
    loop*'
  id: totrans-3761
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 6-6：使用for-in循环遍历字典的键和值*'
- en: The order of your results might be slightly different from ours. That’s because
    the items in a dictionary aren’t in a numbered order like they are in an array!
    And because the order is not guaranteed, you might see a different order printed
    if you run the same code again.
  id: totrans-3762
  prefs: []
  type: TYPE_NORMAL
  zh: 你的结果顺序可能与我们的略有不同。这是因为字典中的项目不像数组那样按编号顺序排列！而且由于顺序不可保证，如果你再次运行相同的代码，你可能会看到不同的打印顺序。
- en: '**WHAT YOU LEARNED**'
  id: totrans-3763
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**你学到了什么**'
- en: In this chapter, you learned how to store collections of items in an array and
    in a dictionary. To store items in an ordered list, you would use an array and
    look up each item by its index. If you wanted to store items by key instead, you
    would use a dictionary.
  id: totrans-3764
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一章中，你学习了如何将项目存储在数组和字典中。要将项目存储在有序列表中，你应该使用数组并通过索引查找每个项目。如果你想按键存储项目，你应该使用字典。
- en: Knowing about arrays and dictionaries and how to use them is a powerful building
    block for almost any programming language. Next we will learn about functions,
    another very powerful tool. Functions are blocks of code that you create and name
    to perform a specific job. After you have written a function, you can use its
    name to call it from almost anywhere in your program.
  id: totrans-3765
  prefs: []
  type: TYPE_NORMAL
  zh: 了解数组和字典以及如何使用它们是几乎任何编程语言的强大构建块。接下来我们将学习函数，另一个非常强大的工具。函数是你创建并命名的代码块，用来执行特定的任务。写完一个函数后，你可以通过它的名字从程序中的几乎任何地方调用它。
- en: One important point about arrays is that if you try to access an item at an
    index that’s higher than the last index in the array, you’ll get an error. In
    [Figure 6-2](text00016.html#ch06fig2) , you can see that nationalParks[3] (which
    would be the fourth item in the array) gives you an error because there are only
    three national parks in the array, indexed from 0 to 2.
  id: totrans-3766
  prefs: []
  type: TYPE_NORMAL
  zh: 关于数组的一个重要点是，如果你尝试访问数组中一个大于最后一个索引的项目，将会出现错误。在[图6-2](text00016.html#ch06fig2)中，你可以看到，nationalParks[3]（即数组中的第四个项目）会导致错误，因为数组中只有三个国家公园，索引从0到2。
- en: As you can see, you get an error message that says Index out of range . If you
    try to access an item that doesn’t exist in your array, your app will crash!
  id: totrans-3767
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，系统会提示“索引超出范围”的错误消息。如果你尝试访问数组中不存在的项目，应用程序将崩溃！
- en: '![Image](Image00119.jpg)'
  id: totrans-3768
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00119.jpg)'
- en: '*Figure 6-2: Trying to access an index in the array where nothing exists causes
    an error.*'
  id: totrans-3769
  prefs: []
  type: TYPE_NORMAL
  zh: '*图6-2：尝试访问数组中不存在的索引会导致错误。*'
- en: '**ADDING ITEMS TO AN ARRAY**'
  id: totrans-3770
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**向数组添加项目**'
- en: One way to change an array is to add new items to it. There are a few different
    ways to do this, so let’s take a look at each.
  id: totrans-3771
  prefs: []
  type: TYPE_NORMAL
  zh: 改变数组的一种方法是向其中添加新项目。有几种不同的方式可以做到这一点，让我们逐一了解。
- en: 'First, you can use an array’s append(_:) method. *Append* means to add something.
    Using append(_:) , you can add one new item to the end of your array. Say you
    go on another trip and visit the Badlands, and you want to add it to your list
    of national parks. To do that, add this code into your playground:'
  id: totrans-3772
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，你可以使用数组的 append(_:) 方法。*Append* 意味着添加某个项目。通过 append(_:) 方法，你可以将一个新项目添加到数组的末尾。假设你又去了一趟旅行，参观了“恶地”，你想将它添加到国家公园的列表中。要做到这一点，可以将以下代码添加到你的
    playground 中：
- en: '![](Image00120.jpg)'
  id: totrans-3773
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00120.jpg)'
- en: To use the append(_:) method, first write the name of your array followed by
    a period and then append . Then, put the item you want to add to your array inside
    the parentheses. In this case, you put "Badlands" inside the parentheses.
  id: totrans-3774
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用 append(_:) 方法，首先写出数组的名称，然后加上一个句点，再加上 append。接着，将你想要添加到数组中的项目放在括号内。在这个例子中，你将“恶地”放在括号内。
- en: 'If you want to add something at a specific place in your array, use the array’s
    insert(_:at:) method instead. This method takes two arguments: the item that you
    want to insert and the index of where it should go in the array. (We’ll discuss
    arguments in more detail in [Chapter 7](text00017.html#ch07) .)'
  id: totrans-3775
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想在数组的特定位置添加某个项目，可以使用数组的 insert(_:at:) 方法。该方法接受两个参数：你想插入的项目以及它应该在数组中出现的索引位置。（我们将在[第7章](text00017.html#ch07)中详细讨论参数。）
- en: 'Let’s say you totally forgot that you went to the Petrified Forest right after
    you visited the Grand Canyon, and you want to update your nationalParks array
    so it displays the parks in the order in which you visited them. To update your
    array, you could use the insert(_:at:) method to put the Petrified Forest in the
    right position:'
  id: totrans-3776
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你完全忘记了在参观大峡谷后去过“化石森林”，你希望更新你的 nationalParks 数组，以便它按你访问的顺序显示各大公园。要更新数组，可以使用
    insert(_:at:) 方法将“化石森林”插入到正确的位置：
- en: '![](Image00121.jpg)'
  id: totrans-3777
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00121.jpg)'
- en: When you insert a new item at index 3, everything that was in the array at index
    3 or higher gets scooted over to make room for the new item. That means the item
    that was at index 3 is now at index 4, the item that was at index 4 is now at
    index 5, and so on. After you add the Petrified Forest, nationalParks is now ["Acadia",
    "Zion", "Grand Canyon", "Petrified Forest", "Badlands"] .
  id: totrans-3778
  prefs: []
  type: TYPE_NORMAL
  zh: 当你在索引3处插入一个新项目时，数组中索引3或更高的所有项目都会向后移动，为新项目腾出空间。这意味着原本位于索引3的项目现在位于索引4，原本位于索引4的项目现在位于索引5，依此类推。添加“化石森林”后，nationalParks
    数组现在变为["Acadia", "Zion", "Grand Canyon", "Petrified Forest", "Badlands"]。
- en: '**COMBINING ARRAYS**'
  id: totrans-3779
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**合并数组**'
- en: 'Not only can you add new items to an array, but you can also add two arrays
    together using the + and += operators. Let’s say that you have the ingredients
    for a fruit smoothie in two arrays:'
  id: totrans-3780
  prefs: []
  type: TYPE_NORMAL
  zh: 不仅可以向数组中添加新项目，还可以使用 + 和 += 运算符将两个数组相加。假设你有两个数组，分别包含水果奶昔的配料：
- en: '![](Image00122.jpg)'
  id: totrans-3781
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00122.jpg)'
- en: Now you can make a delicious smoothie by adding the fruits and liquids arrays.
  id: totrans-3782
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你可以通过将水果和液体数组合并来制作一杯美味的奶昔。
- en: '![](Image00123.jpg)'
  id: totrans-3783
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00123.jpg)'
- en: The order of the ingredients in smoothie is the same as the order in fruits
    and liquids . If you created smoothie with liquids + fruits , then the liquids
    would come first.
  id: totrans-3784
  prefs: []
  type: TYPE_NORMAL
  zh: 奶昔中配料的顺序与水果和液体的顺序相同。如果你用液体 + 水果的顺序创建奶昔，那么液体将排在前面。
- en: 'You use the += operator to add an array to the end of your array. Add some
    whipped cream as follows for extra yumminess:'
  id: totrans-3785
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用+=运算符将一个数组添加到另一个数组的末尾。为了增加一些美味，可以按如下方式添加一些奶油：
- en: '![](Image00124.jpg)'
  id: totrans-3786
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00124.jpg)'
- en: Note that ["whipped cream"] is an array even though it has a single item in
    it. When you’re using += to append something to an array, you have to make sure
    you’re only trying to add another array. If you were to just write the string
    "whipped cream" without the square brackets around it, you would get an error.
  id: totrans-3787
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，["whipped cream"]是一个数组，尽管它只有一个元素。当你使用+=将内容追加到数组时，必须确保你只尝试添加另一个数组。如果你只是写了字符串“whipped
    cream”而没有加上方括号，就会出现错误。
- en: '![Image](Image00125.jpg)'
  id: totrans-3788
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00125.jpg)'
- en: '**REMOVING ITEMS FROM AN ARRAY**'
  id: totrans-3789
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**从数组中删除项**'
- en: 'There are several methods for removing items from an array. Let’s start by
    looking at the array’s removeLast() method. As you might have guessed from its
    name, removeLast() removes the last item from your array. Let’s try it out with
    a shoppingList array:'
  id: totrans-3790
  prefs: []
  type: TYPE_NORMAL
  zh: 删除数组项有几种方法。首先让我们看一下数组的removeLast()方法。正如你从名字中猜到的那样，removeLast()会删除数组中的最后一项。让我们用一个shoppingList数组来尝试一下：
- en: '![](Image00126.jpg)'
  id: totrans-3791
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00126.jpg)'
- en: Neat! Note that the removeLast() method returns the removed item, so you can
    store it in a new constant or variable if you want.
  id: totrans-3792
  prefs: []
  type: TYPE_NORMAL
  zh: 真棒！请注意，removeLast()方法会返回被移除的项，因此如果你想，可以将它存储在一个新的常量或变量中。
- en: 'You can also remove an item from a specific index by using the remove(at:)
    method. Let’s say that your mom doesn’t want you buying any candy and takes that
    off the list:'
  id: totrans-3793
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以使用remove(at:)方法从特定的索引删除项。假设你的妈妈不想让你买糖果并把它从清单上删除：
- en: '![Image](Image00127.jpg)![](Image00128.jpg)'
  id: totrans-3794
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00127.jpg)![](Image00128.jpg)'
- en: Just like when we added an item to the middle of our array and all the items
    scooted over to make room, if you remove an item from the middle of an array,
    the rest of the items will scoot back to fill in that empty space. The "apples"
    item that was at index 3 is now at index 2, where "candy" was.
  id: totrans-3795
  prefs: []
  type: TYPE_NORMAL
  zh: 就像我们在数组中间添加项时，所有项都会移位以腾出空间一样，如果你从数组中间删除项，剩余的项会向后移动填补空缺。原本在索引3的“苹果”项现在位于索引2的位置，那里原本是“糖果”。
- en: 'You can also remove all items from an array with removeAll() . Try entering
    this into your playground:'
  id: totrans-3796
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以使用removeAll()删除数组中的所有项。试着在你的playground中输入这个：
- en: '![](Image00129.jpg)'
  id: totrans-3797
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00129.jpg)'
- en: 'Note that trying to remove an item at an index that doesn’t exist will give
    you an error:'
  id: totrans-3798
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，尝试删除一个不存在的索引处的项会给你一个错误：
- en: '![](Image00130.jpg)'
  id: totrans-3799
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00130.jpg)'
- en: Our array doesn’t have this many items (in fact, now it’s empty!), so this throws
    an error. We’ll also get an error if we use removeLast() on our empty array, because
    there’s nothing in it—there’s no last index at all! However, removeAll() is always
    safe to use, even on an empty array.
  id: totrans-3800
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的数组中没有这么多项（实际上，现在它是空的！），所以这会抛出错误。如果我们在空数组上使用removeLast()，也会出现错误，因为数组里没有任何内容——根本没有最后一个索引！但是，removeAll()即使在空数组上使用也是安全的。
- en: '**REPLACING ITEMS IN AN ARRAY**'
  id: totrans-3801
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**替换数组中的项**'
- en: 'To replace an item in an array, you set the index of the array to the new value,
    as shown here:'
  id: totrans-3802
  prefs: []
  type: TYPE_NORMAL
  zh: 要替换数组中的一项，你需要将数组的某个索引设置为新值，如下所示：
- en: '![](Image00131.jpg)'
  id: totrans-3803
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00131.jpg)'
- en: At ➊ , we replaced the item at index 2 (the third item) with "Unicorn" because
    magical animals count as favorite animals, too! At ➋ , we replaced the item at
    index 0 (the first item) with "Bearded dragon" . No, that’s not a real dragon—it’s
    just a lizard!
  id: totrans-3804
  prefs: []
  type: TYPE_NORMAL
  zh: 在➊，我们将索引为2（第三项）的项替换为“独角兽”，因为魔法动物也算作最喜欢的动物！在➋，我们将索引为0（第一项）的项替换为“鬃龙”。不，这不是一条真的龙——它只是一个蜥蜴！
- en: Like any time you’re working with array index numbers, you have to be sure an
    item exists in the array at that index before you change its value, or you will
    get an Index out of range error.
  id: totrans-3805
  prefs: []
  type: TYPE_NORMAL
  zh: 和你在处理数组索引时一样，你必须确保在修改某个索引的值之前，数组中确实存在该项，否则你会遇到“索引超出范围”错误。
- en: '[Figure 6-3](text00016.html#ch06fig3) shows the error that occurs if you try
    to add "Standard poodle" using favoriteAnimals[3] = "Standard poodle" . To add
    an item to the end of an array, you should use the append(_:) method or += , as
    we covered in “[Adding Items to an Array](text00016.html#ch06lev2sec5) ” on [page
    70](text00016.html#page_70) .'
  id: totrans-3806
  prefs: []
  type: TYPE_NORMAL
  zh: '[图6-3](text00016.html#ch06fig3)展示了如果你尝试使用favoriteAnimals[3] = "标准贵宾犬"添加“标准贵宾犬”时会发生的错误。要将项添加到数组末尾，你应该使用append(_:)方法或+=，正如我们在
    “[向数组添加项](text00016.html#ch06lev2sec5)”中讲到的，[第70页](text00016.html#page_70)。'
- en: '![Image](Image00132.jpg)'
  id: totrans-3807
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00132.jpg)'
- en: '*Figure 6-3: Don’t try to replace a value at an index beyond the existing array.*'
  id: totrans-3808
  prefs: []
  type: TYPE_NORMAL
  zh: '*图6-3：不要尝试替换超出现有数组范围的索引处的值。*'
- en: Now you know how to change arrays however you might need to. You can add items,
    take items away, or replace items. Next, we’ll look at how to use the properties
    of arrays to find out even more information about them.
  id: totrans-3809
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你知道如何根据需要修改数组了。你可以添加元素、删除元素或替换元素。接下来，我们将看看如何使用数组的属性来获取更多有关它们的信息。
- en: '![Image](Image00133.jpg)'
  id: totrans-3810
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00133.jpg)'
- en: '**USING ARRAY PROPERTIES**'
  id: totrans-3811
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**使用数组属性**'
- en: In addition to methods like append(_:) and removeLast() , arrays also have *properties*
    . An array’s properties are variables or constants that contain some information
    about the array. Two really helpful properties that you might use are the Boolean
    property isEmpty and the integer property count .
  id: totrans-3812
  prefs: []
  type: TYPE_NORMAL
  zh: 除了像 append(_:) 和 removeLast() 这样的函数，数组还有*属性*。数组的属性是包含有关数组信息的变量或常量。有两个非常有用的属性，你可能会使用它们：布尔值属性
    isEmpty 和整数属性 count。
- en: The isEmpty property is true or false depending on whether the array is empty,
    and the count property will tell you how many items are in that array.
  id: totrans-3813
  prefs: []
  type: TYPE_NORMAL
  zh: isEmpty 属性根据数组是否为空返回 true 或 false，count 属性则告诉你数组中有多少个元素。
- en: 'Check out how these two properties are used in the following if-else statement:'
  id: totrans-3814
  prefs: []
  type: TYPE_NORMAL
  zh: 查看以下 if-else 语句中如何使用这两个属性：
- en: '![Image](Image00134.jpg)'
  id: totrans-3815
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00134.jpg)'
- en: 'This if-else statement checks whether the array mySiblings is empty ➊ . If
    it is, then "I don''t have any siblings." is printed. But if there is something
    in the array, then the number of siblings that we have is printed: "I have 3 siblings."
    ➋ .'
  id: totrans-3816
  prefs: []
  type: TYPE_NORMAL
  zh: 这个 if-else 语句检查数组 mySiblings 是否为空 ➊。如果为空，则打印 "我没有兄弟姐妹"。如果数组中有元素，则打印我们有几个兄弟姐妹：“我有
    3 个兄弟姐妹。” ➋。
- en: '**LOOPING OVER AN ARRAY**'
  id: totrans-3817
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**遍历数组**'
- en: 'Sometimes when you’re working with arrays you might want to do something to
    every item in the array. You can use a for-in loop to do that! The following code
    will print every topping in a pizzaToppings array on a separate line:'
  id: totrans-3818
  prefs: []
  type: TYPE_NORMAL
  zh: 有时在处理数组时，你可能希望对数组中的每个元素执行某个操作。你可以使用 for-in 循环来做到这一点！下面的代码将在单独的行中打印出 pizzaToppings
    数组中的每个配料：
- en: '![Image](Image00135.jpg)'
  id: totrans-3819
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00135.jpg)'
- en: To write a for-in loop for the pizzaToppings array, we used the keyword for
    , followed by the constant topping , then the keyword in , and finally the name
    of our array, pizzaToppings . Then we put the statements that we want to run for
    each topping inside the braces of the for-in loop. The constant topping ➊ temporarily
    represents each pizza topping in the array as we loop through it. We could have
    chosen any name for this constant, but it’s a good idea to pick something that
    makes sense. You can see the output of this for-in loop in [Figure 6-4](text00016.html#ch06fig4)
    .
  id: totrans-3820
  prefs: []
  type: TYPE_NORMAL
  zh: 要为 pizzaToppings 数组编写 for-in 循环，我们使用关键字 for，后跟常量 topping，再是关键字 in，最后是数组名称 pizzaToppings。然后，我们把希望对每个
    topping 执行的语句放在 for-in 循环的花括号内。常量 topping ➊ 在我们遍历数组时，临时代表数组中的每一个披萨配料。我们本可以为这个常量选择任何名字，但最好选一个有意义的名字。你可以在[图
    6-4](text00016.html#ch06fig4)中查看这个 for-in 循环的输出。
- en: '![Image](Image00136.jpg)'
  id: totrans-3821
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00136.jpg)'
- en: '*Figure 6-4: Output of the example for-in loop*'
  id: totrans-3822
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 6-4：示例 for-in 循环的输出*'
- en: '![Image](Image00137.jpg)'
  id: totrans-3823
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00137.jpg)'
- en: 'Using for-in loops is great for printing every value in an array. If you’re
    working with numbers, you can even use them to perform math operations on each
    item, which makes for some speedy calculations! The following code takes an array
    of numbers and calculates the square for each (the square of a number is that
    number multiplied by itself):'
  id: totrans-3824
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 for-in 循环对于打印数组中的每个值非常有效。如果你处理的是数字，你甚至可以用它们对每个元素进行数学运算，这样可以快速计算！下面的代码获取一个数字数组，并计算每个数字的平方（一个数字的平方是它本身乘以自己）：
- en: '![Image](Image00138.jpg)'
  id: totrans-3825
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00138.jpg)'
- en: '[Figure 6-5](text00016.html#ch06fig5) shows the results.'
  id: totrans-3826
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 6-5](text00016.html#ch06fig5)显示了结果。'
- en: '![Image](Image00139.jpg)'
  id: totrans-3827
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00139.jpg)'
- en: '*Figure 6-5: Printing the squares for each number in the myNumbers array*'
  id: totrans-3828
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 6-5：打印 myNumbers 数组中每个数字的平方*'
- en: '**DICTIONARIES ARE KEY!**'
  id: totrans-3829
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**字典是关键！**'
- en: A *dictionary* is also a collection of values, but instead of an ordered index,
    each value has its own *key* . Because there’s no index, the values are not stored
    in any particular order. To access values in a dictionary, you look them up by
    their key.
  id: totrans-3830
  prefs: []
  type: TYPE_NORMAL
  zh: '*字典*也是一种值的集合，但与有序索引不同，每个值都有自己的*键*。由于没有索引，值并不按特定顺序存储。要访问字典中的值，你需要通过键来查找它们。'
- en: A key must be unique. You can’t have the same key more than once in the same
    dictionary. If there were two identical keys and you asked the computer to give
    you the value for one of them, the computer wouldn’t know which one to choose!
  id: totrans-3831
  prefs: []
  type: TYPE_NORMAL
  zh: 键必须是唯一的。您不能在同一个字典中重复使用相同的键。如果有两个相同的键，而您要求计算机给出其中一个键的值，计算机就无法知道该选择哪个！
- en: Let’s take a look at how to make a dictionary and write keys that will help
    you find all the information you need.
  id: totrans-3832
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看如何创建一个字典并写入键，以帮助您找到所需的所有信息。
- en: '![Image](Image00140.jpg)'
  id: totrans-3833
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00140.jpg)'
- en: '**INITIALIZING A DICTIONARY**'
  id: totrans-3834
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**初始化字典**'
- en: 'To create and initialize a dictionary, first write var and the name of your
    dictionary. Then write the keys and corresponding values inside a pair of square
    brackets, similar to an array. Let’s create a dictionary to store the names of
    a few US states. The key for each state will be its two-letter abbreviation:'
  id: totrans-3835
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建并初始化一个字典，首先写上 var 和字典的名称。然后在一对方括号中写下键和值，类似于数组。我们来创建一个字典来存储一些美国州的名称。每个州的键将是它的两位字母缩写：
- en: '![](Image00141.jpg)'
  id: totrans-3836
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00141.jpg)'
- en: As you can see, there’s a colon between each key and its value, and the key/value
    pairs are separated by commas.
  id: totrans-3837
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，每个键和值之间都有一个冒号，键/值对之间用逗号分隔。
- en: Dictionaries are different from arrays in that they are *unordered* . Because
    of that, it’s likely that the order of the states that you see in your results
    pane ➋ is different from the order in which you entered your states ➊ . It might
    even be different than the order that’s printed in this book!
  id: totrans-3838
  prefs: []
  type: TYPE_NORMAL
  zh: 字典与数组的不同之处在于它们是*无序的*。因此，您在结果窗格 ➋ 中看到的状态顺序可能与您输入状态的顺序 ➊ 不同。它甚至可能与本书中打印的顺序不同！
- en: As with arrays, you can use var to make a mutable dictionary or use let to make
    an immutable dictionary.
  id: totrans-3839
  prefs: []
  type: TYPE_NORMAL
  zh: 与数组一样，您可以使用 var 来创建可变字典，或者使用 let 来创建不可变字典。
- en: 'In Swift, all of the keys of a dictionary must be the same type, and all of
    the values of a dictionary must also be the same type, but the key type doesn’t
    have to match the value type. For example, if you wanted to store a collection
    of fractions, you could use doubles for the keys and strings for the values:'
  id: totrans-3840
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Swift 中，字典的所有键必须是相同类型，字典的所有值也必须是相同类型，但键类型不必与值类型相匹配。例如，如果您想存储一个分数集合，可以使用双精度浮点数作为键，字符串作为值：
- en: '![](Image00142.jpg)'
  id: totrans-3841
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00142.jpg)'
- en: In this dictionary, all of the keys must be doubles, and all of the values must
    be strings. Again, you’ll see that the order of the numbers in the results pane
    can be quite different from the order in which you wrote the fractions in your
    dictionary. This is fine because you don’t need to know the order to access anything.
    You can find any item that you need by its key. Let’s see how!
  id: totrans-3842
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个字典中，所有的键必须是双精度浮点数，所有的值必须是字符串。再次提醒，您会发现结果窗格中的数字顺序可能与您在字典中写入分数的顺序相差很大。这没关系，因为您不需要知道顺序就能访问任何内容。您可以通过键找到任何需要的项。让我们来看看！
- en: '**ACCESSING VALUES IN A DICTIONARY**'
  id: totrans-3843
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**访问字典中的值**'
- en: 'Looking up a value in a dictionary is similar to how you access a value in
    an array except that you use a key inside the square brackets instead of an index,
    like this: usStates["TX"] .'
  id: totrans-3844
  prefs: []
  type: TYPE_NORMAL
  zh: 在字典中查找一个值的方式与访问数组中的值类似，只不过您需要在方括号内使用一个键，而不是索引，例如：usStates["TX"]。
- en: There is a big difference, however, in how Swift returns the values from a dictionary.
    When you access a value at an index of an array, you are simply given the value.
    When you access a value with a key in a dictionary, you are given an optional.
  id: totrans-3845
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，Swift 在从字典中返回值的方式上有很大的不同。当您访问数组中某个索引的值时，您只是简单地得到该值。当您使用键访问字典中的值时，您得到的是一个可选值。
- en: In [Chapter 5](text00015.html#ch05) , you learned that optionals might contain
    a value or might be nil . The reason Swift returns optionals when you’re looking
    up items in a dictionary is that the key you used might not exist in the dictionary,
    in which case there’s no value to access. Trying to access a value that doesn’t
    exist would give you a big fat error! To avoid that problem, Swift returns optionals.
    That means you need to unwrap any value you get out of a dictionary before you
    can do anything with it.
  id: totrans-3846
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第 5 章](text00015.html#ch05)中，您学到过可选值可能包含一个值，也可能是 nil。Swift 在查找字典中的项时返回可选值的原因是，您使用的键可能在字典中不存在，这种情况下就没有值可访问。试图访问一个不存在的值会给您带来一个大错误！为了避免这个问题，Swift
    返回可选值。这意味着您在处理字典中的任何值之前，必须先解包它。
- en: 'To unwrap an optional, first you check whether it exists using an if-let statement,
    just like we did in [Chapter 5](text00015.html#ch05) . The following code shows
    you how to get a value out of a dictionary:'
  id: totrans-3847
  prefs: []
  type: TYPE_NORMAL
  zh: 要展开一个可选值，首先你需要通过 if-let 语句检查它是否存在，就像我们在[第5章](text00015.html#ch05)中做的那样。以下代码展示了如何从字典中获取一个值：
- en: '![Image](Image00143.jpg)'
  id: totrans-3848
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00143.jpg)'
- en: To retrieve "Texas" from the dictionary, we use if let to set a constant loneStarState
    to usStates["TX"] ➊ . Because we have this state in our dictionary, the line I
    have Texas in my dictionary. is printed. Next we try to access a state that is
    not in our dictionary by using the key usStates["FL"] ➋ . Thankfully, because
    we used an if-let statement, the program won’t crash when the computer can’t find
    this state. Instead, I don't have that state in my dictionary. is printed.
  id: totrans-3849
  prefs: []
  type: TYPE_NORMAL
  zh: 为了从字典中检索 "Texas"，我们使用 if let 将常量 loneStarState 设置为 usStates["TX"] ➊。因为我们在字典中有这个州，所以打印出
    "I have Texas in my dictionary."。接下来，我们尝试通过使用键 usStates["FL"] ➋ 来访问一个不在字典中的州。幸运的是，由于我们使用了
    if-let 语句，当计算机找不到该州时，程序不会崩溃。相反，打印出 "I don't have that state in my dictionary."。
- en: '**ADDING ITEMS TO A DICTIONARY**'
  id: totrans-3850
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**向字典中添加项**'
- en: 'To add an item to a dictionary, first write the name of your dictionary and
    assign the new item to the key you want it to have in the dictionary. Let’s add
    "Minnesota" to our usStates dictionary:'
  id: totrans-3851
  prefs: []
  type: TYPE_NORMAL
  zh: 向字典中添加项时，首先写下字典的名称，并将新项分配给你希望它在字典中拥有的键。让我们将 "Minnesota" 添加到我们的 usStates 字典中：
- en: '![](Image00144.jpg)'
  id: totrans-3852
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00144.jpg)'
- en: 'Now when you look at usStates , you’ll see that it’s updated to ["MN": "Minnesota",
    "WA": "Washington", "MA": "Massachusetts", "TX": "Texas"] . Remember, because
    you don’t have to rely on indices, your new dictionary item might appear anywhere
    in the dictionary.'
  id: totrans-3853
  prefs: []
  type: TYPE_NORMAL
  zh: '现在，当你查看 usStates 时，你会看到它被更新为 ["MN": "Minnesota", "WA": "Washington", "MA":
    "Massachusetts", "TX": "Texas"]。记住，因为你不需要依赖索引，所以你的新字典项可能出现在字典中的任何位置。'
- en: '**REMOVING ITEMS FROM A DICTIONARY**'
  id: totrans-3854
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**从字典中移除项**'
- en: Removing an item from a dictionary is quite simple; you do so by setting the
    value to nil . Because the values in dictionaries are returned as optionals, you
    don’t have to worry about nil causing any problems in your dictionary.
  id: totrans-3855
  prefs: []
  type: TYPE_NORMAL
  zh: 从字典中移除项非常简单；你只需将值设置为 nil。因为字典中的值是以可选值的形式返回的，所以你不必担心 nil 会在字典中引起问题。
- en: '![](Image00145.jpg)'
  id: totrans-3856
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00145.jpg)'
- en: 'You can see that after you remove the value at the key "MA" , usStates is updated
    to ["MN": "Minnesota", "WA": "Washington", "TX": "Texas"] . Remember that nil
    is special and means that there’s no value at all. That’s why you don’t see "MA":
    nil in our dictionary.'
  id: totrans-3857
  prefs: []
  type: TYPE_NORMAL
  zh: '你可以看到，在移除键 "MA" 的值后，usStates 被更新为 ["MN": "Minnesota", "WA": "Washington", "TX":
    "Texas"]。记住，nil 是特别的，意味着根本没有值。这就是为什么你在字典中看不到 "MA": nil。'
- en: '**REPLACING ITEMS IN A DICTIONARY**'
  id: totrans-3858
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**替换字典中的项**'
- en: 'Replacing an item in a dictionary is also easy. It works the same was as replacing
    an item in an array. You just set the item that you want to replace to something
    else. Say you create a dictionary of fruit colors:'
  id: totrans-3859
  prefs: []
  type: TYPE_NORMAL
  zh: 替换字典中的项也很容易。它的工作方式与替换数组中的项相同。你只需要将你想要替换的项设置为其他内容。假设你创建了一个水果颜色的字典：
- en: '![](Image00146.jpg)'
  id: totrans-3860
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00146.jpg)'
- en: At first we had the value "apple" for "red" , but then we decided that "raspberry"
    is a better fruit to use since sometimes apples are green or yellow. To replace
    "apple" with "raspberry" , we set colorFruits["red"] to its new value ➊ .
  id: totrans-3861
  prefs: []
  type: TYPE_NORMAL
  zh: 一开始，我们将值 "apple" 用于 "red" ，但是后来我们决定 "raspberry" 更适合作为水果，因为有时候苹果是绿色或黄色的。为了将 "apple"
    替换为 "raspberry" ，我们将 colorFruits["red"] 设置为它的新值 ➊。
- en: You may remember that this is the same way we entered a new value into a dictionary.
    If the key already exists in the dictionary, then the value for that key is replaced.
    If the key doesn’t already exist, then the new key/value pair will be added to
    the dictionary.
  id: totrans-3862
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能还记得，这是我们将新值输入字典的相同方式。如果字典中已经存在该键，那么该键的值将被替换。如果该键不存在，则新的键值对将被添加到字典中。
- en: '![Image](Image00147.jpg)'
  id: totrans-3863
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00147.jpg)'
- en: '**USING DICTIONARY PROPERTIES**'
  id: totrans-3864
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**使用字典属性**'
- en: 'Like an array, a dictionary also has an isEmpty property and a count property.
    For example, the following code shows how you can use the isEmpty property to
    check if a dictionary is empty, and if it isn’t empty, the count property checks
    how many items you have. Imagine you have a basket of fruit for sale. You can
    use these properties to help you keep track of everything:'
  id: totrans-3865
  prefs: []
  type: TYPE_NORMAL
  zh: 类似于数组，字典也有 isEmpty 属性和 count 属性。例如，以下代码展示了如何使用 isEmpty 属性检查字典是否为空，如果不为空，则使用
    count 属性检查字典中有多少项。假设你有一个待售的水果篮子。你可以使用这些属性来帮助你跟踪所有的水果：
- en: '![Image](Image00148.jpg)'
  id: totrans-3866
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00148.jpg)'
- en: 'A dictionary also has two special properties: keys , which contains all of
    the dictionary’s keys, and values , which contains all of its values. We’ll use
    these two properties when we loop through the dictionary.'
  id: totrans-3867
  prefs: []
  type: TYPE_NORMAL
  zh: 字典还有两个特殊的属性：keys，它包含字典的所有键，以及 values，它包含字典的所有值。我们在遍历字典时将使用这两个属性。
- en: Let’s write some code that loops through our fruit baskets and prints the price
    of each fruit.
  id: totrans-3868
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们编写一些代码，遍历我们的水果篮并打印每个水果的价格。
- en: '**LOOPING OVER A DICTIONARY**'
  id: totrans-3869
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**遍历字典**'
- en: 'You can loop through a dictionary using a for-in loop. Because each item has
    a key and a value, you can do this in two different ways. This is how to loop
    through a dictionary using its keys:'
  id: totrans-3870
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用 for-in 循环遍历字典。因为每个项目都有键和值，所以你可以通过两种不同的方式来实现。以下是使用字典的键遍历字典的方法：
- en: '![Image](Image00149.jpg)'
  id: totrans-3871
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00149.jpg)'
- en: Here we use the dictionary’s keys property ➊ to loop through fruitBasket and
    print its contents. We start by writing the keyword for , followed by a constant
    name fruit for the dictionary key, the keyword in , the dictionary name, a period,
    and keys .
  id: totrans-3872
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们使用字典的 keys 属性 ➊ 遍历 fruitBasket 并打印其内容。我们首先写出关键字 for，接着是常量名 fruit 作为字典键，再写关键字
    in，字典名称，句点和 keys。
- en: Inside the braces of our for-in loop, we have access to both the key, which
    we call fruit ➋ , and the value at that key when we force-unwrap its contents
    with fruitBasket[fruit]! ➌ . That value will be the fruit’s price.
  id: totrans-3873
  prefs: []
  type: TYPE_NORMAL
  zh: 在 for-in 循环的大括号内，我们可以访问键（我们称之为 fruit ➋）以及通过强制解包其内容来获取该键的值：fruitBasket[fruit]!
    ➌。该值就是水果的价格。
- en: In this case, it’s safe to force-unwrap the value using an exclamation point
    because we know that the fruit key we’re using is definitely inside the dictionary.
  id: totrans-3874
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，使用感叹号强制解包值是安全的，因为我们知道所使用的水果键肯定存在于字典中。
- en: Any code we put inside the for-in loop will run once for every key in our dictionary.
    So you should see the print statement display three times.
  id: totrans-3875
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在 for-in 循环中写的任何代码都会在字典的每个键上执行一次。所以你应该会看到打印语句显示三次。
- en: 'We can also loop through the dictionary using its values property:'
  id: totrans-3876
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以通过字典的值属性来遍历字典：
- en: '![Image](Image00150.jpg)'
  id: totrans-3877
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00150.jpg)'
- en: We use the same style of for-in loop, but now we use a constant to refer to
    each value, which we call price , in the values property. When looping through
    values, we don’t have access to the keys from inside the loop.
  id: totrans-3878
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用相同的 for-in 循环样式，但现在我们使用常量来引用 values 属性中的每个值，称之为 price。在遍历值时，我们无法从循环内部访问键。
- en: Another difference to note is that price is not an optional because it’s accessed
    directly as a value in the fruitBasket dictionary. That means we don’t have to
    unwrap it. You should still see the print statement printed three times. [Figure
    6-6](text00016.html#ch06fig6) shows the output of both loops.
  id: totrans-3879
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个需要注意的区别是，price 不是可选的，因为它是直接作为字典中水果篮的值来访问的。这意味着我们不需要解包它。你仍然应该会看到打印语句显示三次。[图
    6-6](text00016.html#ch06fig6) 显示了两个循环的输出。
- en: '![Image](Image00151.jpg)'
  id: totrans-3880
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00151.jpg)'
- en: '*Figure 6-6: Looping through the keys and values of a dictionary with a for-in
    loop*'
  id: totrans-3881
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 6-6：使用 for-in 循环遍历字典的键和值*'
- en: The order of your results might be slightly different from ours. That’s because
    the items in a dictionary aren’t in a numbered order like they are in an array!
    And because the order is not guaranteed, you might see a different order printed
    if you run the same code again.
  id: totrans-3882
  prefs: []
  type: TYPE_NORMAL
  zh: 你的结果顺序可能会与我们的有所不同。这是因为字典中的项目不像数组那样按数字顺序排列！由于顺序不保证，如果你再次运行相同的代码，你可能会看到不同的输出顺序。
- en: '**WHAT YOU LEARNED**'
  id: totrans-3883
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**你学到的内容**'
- en: In this chapter, you learned how to store collections of items in an array and
    in a dictionary. To store items in an ordered list, you would use an array and
    look up each item by its index. If you wanted to store items by key instead, you
    would use a dictionary.
  id: totrans-3884
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你学习了如何将项目存储在数组和字典中。要将项目存储在有序列表中，你会使用数组并通过索引查找每个项目。如果你想根据键存储项目，则需要使用字典。
- en: Knowing about arrays and dictionaries and how to use them is a powerful building
    block for almost any programming language. Next we will learn about functions,
    another very powerful tool. Functions are blocks of code that you create and name
    to perform a specific job. After you have written a function, you can use its
    name to call it from almost anywhere in your program.
  id: totrans-3885
  prefs: []
  type: TYPE_NORMAL
  zh: 了解数组和字典以及如何使用它们是几乎所有编程语言中一个强大的基础。接下来，我们将学习函数，这是另一个非常强大的工具。函数是你创建并命名的代码块，用来执行特定的任务。在你编写了一个函数之后，你可以通过函数名在程序的几乎任何地方调用它。
- en: As you can see, you get an error message that says Index out of range . If you
    try to access an item that doesn’t exist in your array, your app will crash!
  id: totrans-3886
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，你会收到一个错误信息，提示“索引超出范围”。如果你尝试访问数组中不存在的项目，应用程序将崩溃！
- en: '![Image](Image00119.jpg)'
  id: totrans-3887
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00119.jpg)'
- en: '*Figure 6-2: Trying to access an index in the array where nothing exists causes
    an error.*'
  id: totrans-3888
  prefs: []
  type: TYPE_NORMAL
  zh: '*图6-2：尝试访问数组中不存在的索引会导致错误。*'
- en: '**ADDING ITEMS TO AN ARRAY**'
  id: totrans-3889
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**向数组添加项目**'
- en: One way to change an array is to add new items to it. There are a few different
    ways to do this, so let’s take a look at each.
  id: totrans-3890
  prefs: []
  type: TYPE_NORMAL
  zh: 改变数组的一种方式是向其中添加新项目。这里有几种不同的方法，我们来逐一看看。
- en: 'First, you can use an array’s append(_:) method. *Append* means to add something.
    Using append(_:) , you can add one new item to the end of your array. Say you
    go on another trip and visit the Badlands, and you want to add it to your list
    of national parks. To do that, add this code into your playground:'
  id: totrans-3891
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，你可以使用数组的append(_:)方法。*Append*的意思是添加某物。使用append(_:)方法，你可以向数组的末尾添加一个新项目。假设你又去了一次旅行，访问了Badlands，你想将它添加到你的国家公园列表中。为此，将以下代码添加到你的playground中：
- en: '![](Image00120.jpg)'
  id: totrans-3892
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00120.jpg)'
- en: To use the append(_:) method, first write the name of your array followed by
    a period and then append . Then, put the item you want to add to your array inside
    the parentheses. In this case, you put "Badlands" inside the parentheses.
  id: totrans-3893
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用append(_:)方法，首先写下数组的名称，后跟一个句点，然后再写append。接着，将你想要添加到数组中的项目放入括号内。在这个例子中，你将"Badlands"放入括号内。
- en: 'If you want to add something at a specific place in your array, use the array’s
    insert(_:at:) method instead. This method takes two arguments: the item that you
    want to insert and the index of where it should go in the array. (We’ll discuss
    arguments in more detail in [Chapter 7](text00017.html#ch07) .)'
  id: totrans-3894
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想在数组中的特定位置添加某个项目，请使用数组的insert(_:at:)方法。这个方法接受两个参数：你想插入的项目和它应该放在数组中的位置索引。（我们将在[第7章](text00017.html#ch07)中更详细地讨论参数。）
- en: 'Let’s say you totally forgot that you went to the Petrified Forest right after
    you visited the Grand Canyon, and you want to update your nationalParks array
    so it displays the parks in the order in which you visited them. To update your
    array, you could use the insert(_:at:) method to put the Petrified Forest in the
    right position:'
  id: totrans-3895
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你完全忘记了在游览大峡谷之后去过化石森林，你想要更新你的nationalParks数组，使其按照你参观的顺序显示这些公园。为了更新数组，你可以使用insert(_:at:)方法，将化石森林放到正确的位置：
- en: '![](Image00121.jpg)'
  id: totrans-3896
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00121.jpg)'
- en: When you insert a new item at index 3, everything that was in the array at index
    3 or higher gets scooted over to make room for the new item. That means the item
    that was at index 3 is now at index 4, the item that was at index 4 is now at
    index 5, and so on. After you add the Petrified Forest, nationalParks is now ["Acadia",
    "Zion", "Grand Canyon", "Petrified Forest", "Badlands"] .
  id: totrans-3897
  prefs: []
  type: TYPE_NORMAL
  zh: 当你在索引3的位置插入新项目时，索引3及其之后的所有项目都会向后移动，为新项目腾出位置。这意味着，原来在索引3的项目现在会被移动到索引4，原来在索引4的项目会被移动到索引5，以此类推。在你添加了化石森林之后，nationalParks数组现在是["Acadia",
    "Zion", "Grand Canyon", "Petrified Forest", "Badlands"]。
- en: '**COMBINING ARRAYS**'
  id: totrans-3898
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**合并数组**'
- en: 'Not only can you add new items to an array, but you can also add two arrays
    together using the + and += operators. Let’s say that you have the ingredients
    for a fruit smoothie in two arrays:'
  id: totrans-3899
  prefs: []
  type: TYPE_NORMAL
  zh: 你不仅可以向数组添加新项目，还可以使用+和+=运算符将两个数组合并在一起。假设你有两个数组，分别存储了制作水果冰沙所需的食材：
- en: '![](Image00122.jpg)'
  id: totrans-3900
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00122.jpg)'
- en: Now you can make a delicious smoothie by adding the fruits and liquids arrays.
  id: totrans-3901
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你可以通过将水果和液体数组合并，制作美味的冰沙。
- en: '![](Image00123.jpg)'
  id: totrans-3902
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00123.jpg)'
- en: The order of the ingredients in smoothie is the same as the order in fruits
    and liquids . If you created smoothie with liquids + fruits , then the liquids
    would come first.
  id: totrans-3903
  prefs: []
  type: TYPE_NORMAL
  zh: 冰沙中食材的顺序与水果和液体的顺序相同。如果你用液体+水果制作冰沙，那么液体会先放进去。
- en: 'You use the += operator to add an array to the end of your array. Add some
    whipped cream as follows for extra yumminess:'
  id: totrans-3904
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用 += 操作符将一个数组添加到另一个数组的末尾。如下所示，加入一些奶油，增加美味：
- en: '![](Image00124.jpg)'
  id: totrans-3905
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00124.jpg)'
- en: Note that ["whipped cream"] is an array even though it has a single item in
    it. When you’re using += to append something to an array, you have to make sure
    you’re only trying to add another array. If you were to just write the string
    "whipped cream" without the square brackets around it, you would get an error.
  id: totrans-3906
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，["whipped cream"] 是一个数组，即使它只有一个元素。当你使用 += 操作符将内容添加到数组时，必须确保你只是在添加另一个数组。如果你仅仅写下字符串
    "whipped cream" 而没有使用方括号包裹它，你会得到一个错误。
- en: '![Image](Image00125.jpg)'
  id: totrans-3907
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00125.jpg)'
- en: '**REMOVING ITEMS FROM AN ARRAY**'
  id: totrans-3908
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**从数组中移除元素**'
- en: 'There are several methods for removing items from an array. Let’s start by
    looking at the array’s removeLast() method. As you might have guessed from its
    name, removeLast() removes the last item from your array. Let’s try it out with
    a shoppingList array:'
  id: totrans-3909
  prefs: []
  type: TYPE_NORMAL
  zh: 有几种方法可以从数组中移除元素。让我们首先来看数组的 removeLast() 方法。正如你从它的名字中猜到的那样，removeLast() 会移除数组中的最后一个元素。让我们在
    shoppingList 数组上尝试一下：
- en: '![](Image00126.jpg)'
  id: totrans-3910
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00126.jpg)'
- en: Neat! Note that the removeLast() method returns the removed item, so you can
    store it in a new constant or variable if you want.
  id: totrans-3911
  prefs: []
  type: TYPE_NORMAL
  zh: 很棒！请注意，removeLast() 方法会返回被移除的元素，因此如果你愿意，你可以将其存储在一个新的常量或变量中。
- en: 'You can also remove an item from a specific index by using the remove(at:)
    method. Let’s say that your mom doesn’t want you buying any candy and takes that
    off the list:'
  id: totrans-3912
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以使用 remove(at:) 方法从特定的索引中移除元素。假设你的妈妈不希望你买糖果，并把它从清单上去掉：
- en: '![Image](Image00127.jpg)![](Image00128.jpg)'
  id: totrans-3913
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00127.jpg)![](Image00128.jpg)'
- en: Just like when we added an item to the middle of our array and all the items
    scooted over to make room, if you remove an item from the middle of an array,
    the rest of the items will scoot back to fill in that empty space. The "apples"
    item that was at index 3 is now at index 2, where "candy" was.
  id: totrans-3914
  prefs: []
  type: TYPE_NORMAL
  zh: 就像我们将一个元素添加到数组中间时，所有元素都会移动来腾出空间一样，如果你从数组中间移除一个元素，剩下的元素将会移动回来填补那个空缺。原本在索引 3 位置的
    "apples" 现在位于索引 2 位置，原本 "candy" 在那里。
- en: 'You can also remove all items from an array with removeAll() . Try entering
    this into your playground:'
  id: totrans-3915
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以使用 removeAll() 方法从数组中移除所有元素。试着在你的 Playground 中输入以下内容：
- en: '![](Image00129.jpg)'
  id: totrans-3916
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00129.jpg)'
- en: 'Note that trying to remove an item at an index that doesn’t exist will give
    you an error:'
  id: totrans-3917
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，尝试从一个不存在的索引位置移除元素会导致错误：
- en: '![](Image00130.jpg)'
  id: totrans-3918
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00130.jpg)'
- en: Our array doesn’t have this many items (in fact, now it’s empty!), so this throws
    an error. We’ll also get an error if we use removeLast() on our empty array, because
    there’s nothing in it—there’s no last index at all! However, removeAll() is always
    safe to use, even on an empty array.
  id: totrans-3919
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的数组没有这么多元素（实际上，现在它已经是空的了！），所以这会抛出一个错误。如果我们在空数组上使用 removeLast()，也会出错，因为数组中什么都没有——根本没有最后一个索引！然而，removeAll()
    在任何情况下都可以安全使用，即使在空数组上也是如此。
- en: '**REPLACING ITEMS IN AN ARRAY**'
  id: totrans-3920
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**替换数组中的元素**'
- en: 'To replace an item in an array, you set the index of the array to the new value,
    as shown here:'
  id: totrans-3921
  prefs: []
  type: TYPE_NORMAL
  zh: 要替换数组中的元素，你可以将数组中某个索引位置的值设置为新的值，如下所示：
- en: '![](Image00131.jpg)'
  id: totrans-3922
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00131.jpg)'
- en: At ➊ , we replaced the item at index 2 (the third item) with "Unicorn" because
    magical animals count as favorite animals, too! At ➋ , we replaced the item at
    index 0 (the first item) with "Bearded dragon" . No, that’s not a real dragon—it’s
    just a lizard!
  id: totrans-3923
  prefs: []
  type: TYPE_NORMAL
  zh: 在 ➊ 处，我们将索引 2 位置（第三个元素）的值替换成了 "Unicorn"，因为魔法动物也是最喜欢的动物！在 ➋ 处，我们将索引 0 位置（第一个元素）的值替换成了
    "Bearded dragon"。不，这不是一条真正的龙——它只是一个蜥蜴！
- en: Like any time you’re working with array index numbers, you have to be sure an
    item exists in the array at that index before you change its value, or you will
    get an Index out of range error.
  id: totrans-3924
  prefs: []
  type: TYPE_NORMAL
  zh: 就像你在处理数组索引时一样，你必须确保在改变某个索引处的值之前，该索引在数组中确实存在，否则你会遇到“索引超出范围”的错误。
- en: '[Figure 6-3](text00016.html#ch06fig3) shows the error that occurs if you try
    to add "Standard poodle" using favoriteAnimals[3] = "Standard poodle" . To add
    an item to the end of an array, you should use the append(_:) method or += , as
    we covered in “[Adding Items to an Array](text00016.html#ch06lev2sec5) ” on [page
    70](text00016.html#page_70) .'
  id: totrans-3925
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 6-3](text00016.html#ch06fig3) 显示了当你尝试通过 favoriteAnimals[3] = "Standard poodle"
    来添加 "Standard poodle" 时发生的错误。要将元素添加到数组末尾，你应该使用 append(_:) 方法或 +=，正如我们在 “[向数组添加元素](text00016.html#ch06lev2sec5)”
    中第 70 页所讲解的那样。'
- en: '![Image](Image00132.jpg)'
  id: totrans-3926
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00132.jpg)'
- en: '*Figure 6-3: Don’t try to replace a value at an index beyond the existing array.*'
  id: totrans-3927
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 6-3：不要尝试替换一个超出现有数组范围的索引位置的值。*'
- en: Now you know how to change arrays however you might need to. You can add items,
    take items away, or replace items. Next, we’ll look at how to use the properties
    of arrays to find out even more information about them.
  id: totrans-3928
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你知道如何根据需要更改数组了。你可以添加项目、删除项目或替换项目。接下来，我们将看看如何使用数组的属性来获取更多关于数组的信息。
- en: '![Image](Image00133.jpg)'
  id: totrans-3929
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00133.jpg)'
- en: '**USING ARRAY PROPERTIES**'
  id: totrans-3930
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**使用数组属性**'
- en: In addition to methods like append(_:) and removeLast() , arrays also have *properties*
    . An array’s properties are variables or constants that contain some information
    about the array. Two really helpful properties that you might use are the Boolean
    property isEmpty and the integer property count .
  id: totrans-3931
  prefs: []
  type: TYPE_NORMAL
  zh: 除了像 append(_:) 和 removeLast() 这样的操作方法，数组还有*属性*。数组的属性是包含有关数组的一些信息的变量或常量。你可能会用到的两个非常有用的属性是布尔类型的
    isEmpty 属性和整数类型的 count 属性。
- en: The isEmpty property is true or false depending on whether the array is empty,
    and the count property will tell you how many items are in that array.
  id: totrans-3932
  prefs: []
  type: TYPE_NORMAL
  zh: isEmpty 属性的值为 true 或 false，取决于数组是否为空，而 count 属性则会告诉你数组中有多少个元素。
- en: 'Check out how these two properties are used in the following if-else statement:'
  id: totrans-3933
  prefs: []
  type: TYPE_NORMAL
  zh: 查看下面这个 if-else 语句中如何使用这两个属性：
- en: '![Image](Image00134.jpg)'
  id: totrans-3934
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00134.jpg)'
- en: 'This if-else statement checks whether the array mySiblings is empty ➊ . If
    it is, then "I don''t have any siblings." is printed. But if there is something
    in the array, then the number of siblings that we have is printed: "I have 3 siblings."
    ➋ .'
  id: totrans-3935
  prefs: []
  type: TYPE_NORMAL
  zh: 这个 if-else 语句检查 mySiblings 数组是否为空 ➊。如果是空的，则打印出 "我没有兄弟姐妹。"。如果数组中有内容，则打印出兄弟姐妹的数量："我有
    3 个兄弟姐妹。" ➋。
- en: '**LOOPING OVER AN ARRAY**'
  id: totrans-3936
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**遍历数组**'
- en: 'Sometimes when you’re working with arrays you might want to do something to
    every item in the array. You can use a for-in loop to do that! The following code
    will print every topping in a pizzaToppings array on a separate line:'
  id: totrans-3937
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，当你处理数组时，可能希望对数组中的每个项目执行相同的操作。你可以使用 for-in 循环来实现！以下代码将会在新的一行上打印出 pizzaToppings
    数组中的每个配料：
- en: '![Image](Image00135.jpg)'
  id: totrans-3938
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00135.jpg)'
- en: To write a for-in loop for the pizzaToppings array, we used the keyword for
    , followed by the constant topping , then the keyword in , and finally the name
    of our array, pizzaToppings . Then we put the statements that we want to run for
    each topping inside the braces of the for-in loop. The constant topping ➊ temporarily
    represents each pizza topping in the array as we loop through it. We could have
    chosen any name for this constant, but it’s a good idea to pick something that
    makes sense. You can see the output of this for-in loop in [Figure 6-4](text00016.html#ch06fig4)
    .
  id: totrans-3939
  prefs: []
  type: TYPE_NORMAL
  zh: 要编写 pizzaToppings 数组的 for-in 循环，我们使用了关键字 for，后跟常量 topping，然后是关键字 in，最后是数组的名称
    pizzaToppings。接着，我们将要对每个 topping 执行的语句放入 for-in 循环的大括号内。常量 topping ➊ 在我们遍历数组时暂时代表数组中的每个披萨配料。我们本可以为这个常量选择任何名字，但最好选择一个有意义的名字。你可以在[图6-4](text00016.html#ch06fig4)中看到这个
    for-in 循环的输出。
- en: '![Image](Image00136.jpg)'
  id: totrans-3940
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00136.jpg)'
- en: '*Figure 6-4: Output of the example for-in loop*'
  id: totrans-3941
  prefs: []
  type: TYPE_NORMAL
  zh: '*图6-4：示例 for-in 循环的输出*'
- en: '![Image](Image00137.jpg)'
  id: totrans-3942
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00137.jpg)'
- en: 'Using for-in loops is great for printing every value in an array. If you’re
    working with numbers, you can even use them to perform math operations on each
    item, which makes for some speedy calculations! The following code takes an array
    of numbers and calculates the square for each (the square of a number is that
    number multiplied by itself):'
  id: totrans-3943
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 for-in 循环非常适合打印数组中的每个值。如果你正在处理数字，你甚至可以利用它们对每个项目进行数学运算，这样可以进行快速的计算！以下代码接收一个数字数组，并计算每个数字的平方（一个数字的平方是该数字乘以它自身）：
- en: '![Image](Image00138.jpg)'
  id: totrans-3944
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00138.jpg)'
- en: '[Figure 6-5](text00016.html#ch06fig5) shows the results.'
  id: totrans-3945
  prefs: []
  type: TYPE_NORMAL
  zh: '[图6-5](text00016.html#ch06fig5)展示了结果。'
- en: '![Image](Image00139.jpg)'
  id: totrans-3946
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00139.jpg)'
- en: '*Figure 6-5: Printing the squares for each number in the myNumbers array*'
  id: totrans-3947
  prefs: []
  type: TYPE_NORMAL
  zh: '*图6-5：打印 myNumbers 数组中每个数字的平方*'
- en: '**DICTIONARIES ARE KEY!**'
  id: totrans-3948
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**字典是关键！**'
- en: A *dictionary* is also a collection of values, but instead of an ordered index,
    each value has its own *key* . Because there’s no index, the values are not stored
    in any particular order. To access values in a dictionary, you look them up by
    their key.
  id: totrans-3949
  prefs: []
  type: TYPE_NORMAL
  zh: '*字典*也是一个值的集合，但与数组不同的是，字典中的每个值都有自己的*键*。因为没有索引，值不会按任何特定顺序存储。要访问字典中的值，你需要通过它们的键来查找。'
- en: A key must be unique. You can’t have the same key more than once in the same
    dictionary. If there were two identical keys and you asked the computer to give
    you the value for one of them, the computer wouldn’t know which one to choose!
  id: totrans-3950
  prefs: []
  type: TYPE_NORMAL
  zh: 键必须是唯一的。你不能在同一个字典中有相同的键。如果有两个相同的键，而你要求计算机返回其中一个的值，计算机将不知道选择哪个！
- en: Let’s take a look at how to make a dictionary and write keys that will help
    you find all the information you need.
  id: totrans-3951
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如何创建一个字典，并写下键，以帮助你找到所有需要的信息。
- en: '![Image](Image00140.jpg)'
  id: totrans-3952
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00140.jpg)'
- en: '**INITIALIZING A DICTIONARY**'
  id: totrans-3953
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**初始化字典**'
- en: 'To create and initialize a dictionary, first write var and the name of your
    dictionary. Then write the keys and corresponding values inside a pair of square
    brackets, similar to an array. Let’s create a dictionary to store the names of
    a few US states. The key for each state will be its two-letter abbreviation:'
  id: totrans-3954
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建并初始化一个字典，首先写 `var` 和字典的名称。然后在一对方括号内写入键和对应的值，类似于数组。让我们创建一个字典来存储一些美国州的名称。每个州的键将是其两字母的缩写：
- en: '![](Image00141.jpg)'
  id: totrans-3955
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00141.jpg)'
- en: As you can see, there’s a colon between each key and its value, and the key/value
    pairs are separated by commas.
  id: totrans-3956
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，每个键和值之间有一个冒号，并且键/值对之间用逗号分隔。
- en: Dictionaries are different from arrays in that they are *unordered* . Because
    of that, it’s likely that the order of the states that you see in your results
    pane ➋ is different from the order in which you entered your states ➊ . It might
    even be different than the order that’s printed in this book!
  id: totrans-3957
  prefs: []
  type: TYPE_NORMAL
  zh: 字典不同于数组，它是*无序的*。因此，你在结果窗格中看到的州的顺序➋可能与你输入的顺序➊不同。它甚至可能与书中打印的顺序不同！
- en: As with arrays, you can use var to make a mutable dictionary or use let to make
    an immutable dictionary.
  id: totrans-3958
  prefs: []
  type: TYPE_NORMAL
  zh: 和数组一样，你可以使用 `var` 来创建一个可变字典，或者使用 `let` 来创建一个不可变字典。
- en: 'In Swift, all of the keys of a dictionary must be the same type, and all of
    the values of a dictionary must also be the same type, but the key type doesn’t
    have to match the value type. For example, if you wanted to store a collection
    of fractions, you could use doubles for the keys and strings for the values:'
  id: totrans-3959
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Swift 中，字典的所有键必须是相同类型的，字典的所有值也必须是相同类型的，但键的类型不必与值的类型相匹配。例如，如果你想存储一组分数，你可以将键设置为
    `double` 类型，值设置为 `string` 类型：
- en: '![](Image00142.jpg)'
  id: totrans-3960
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00142.jpg)'
- en: In this dictionary, all of the keys must be doubles, and all of the values must
    be strings. Again, you’ll see that the order of the numbers in the results pane
    can be quite different from the order in which you wrote the fractions in your
    dictionary. This is fine because you don’t need to know the order to access anything.
    You can find any item that you need by its key. Let’s see how!
  id: totrans-3961
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个字典中，所有的键必须是 `double` 类型，所有的值必须是 `string` 类型。同样，你会发现结果窗格中的数字顺序与在字典中写入分数时的顺序可能完全不同。这是可以接受的，因为你不需要知道顺序就能访问任何内容。你可以通过键找到任何需要的项。我们来看看怎么做！
- en: '**ACCESSING VALUES IN A DICTIONARY**'
  id: totrans-3962
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**访问字典中的值**'
- en: 'Looking up a value in a dictionary is similar to how you access a value in
    an array except that you use a key inside the square brackets instead of an index,
    like this: usStates["TX"] .'
  id: totrans-3963
  prefs: []
  type: TYPE_NORMAL
  zh: 在字典中查找一个值类似于在数组中访问值的方式，不同之处在于你在方括号中使用的是键而不是索引，例如：usStates["TX"]。
- en: There is a big difference, however, in how Swift returns the values from a dictionary.
    When you access a value at an index of an array, you are simply given the value.
    When you access a value with a key in a dictionary, you are given an optional.
  id: totrans-3964
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，Swift 从字典中返回值的方式有一个很大的不同。当你在数组的索引位置访问值时，你直接得到值。而在字典中使用键访问值时，你得到的是一个可选值。
- en: In [Chapter 5](text00015.html#ch05) , you learned that optionals might contain
    a value or might be nil . The reason Swift returns optionals when you’re looking
    up items in a dictionary is that the key you used might not exist in the dictionary,
    in which case there’s no value to access. Trying to access a value that doesn’t
    exist would give you a big fat error! To avoid that problem, Swift returns optionals.
    That means you need to unwrap any value you get out of a dictionary before you
    can do anything with it.
  id: totrans-3965
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第5章](text00015.html#ch05)中，你学习了可选值可能包含一个值，也可能是 `nil`。Swift 返回可选值的原因是，当你在字典中查找项时，使用的键可能在字典中不存在，这种情况下就没有值可供访问。尝试访问一个不存在的值会给你一个大的错误！为了避免这个问题，Swift
    返回了可选值。这意味着，在你使用字典中的值之前，你需要解包它。
- en: 'To unwrap an optional, first you check whether it exists using an if-let statement,
    just like we did in [Chapter 5](text00015.html#ch05) . The following code shows
    you how to get a value out of a dictionary:'
  id: totrans-3966
  prefs: []
  type: TYPE_NORMAL
  zh: 要解包一个可选值，首先你需要使用if-let语句检查它是否存在，就像我们在[第5章](text00015.html#ch05)中做的那样。以下代码展示了如何从字典中获取一个值：
- en: '![Image](Image00143.jpg)'
  id: totrans-3967
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Image00143.jpg)'
- en: To retrieve "Texas" from the dictionary, we use if let to set a constant loneStarState
    to usStates["TX"] ➊ . Because we have this state in our dictionary, the line I
    have Texas in my dictionary. is printed. Next we try to access a state that is
    not in our dictionary by using the key usStates["FL"] ➋ . Thankfully, because
    we used an if-let statement, the program won’t crash when the computer can’t find
    this state. Instead, I don't have that state in my dictionary. is printed.
  id: totrans-3968
  prefs: []
  type: TYPE_NORMAL
  zh: 为了从字典中获取“Texas”，我们使用if let语句将常量loneStarState设置为usStates["TX"] ➊。由于我们在字典中有这个州，打印出“我在字典中找到了Texas”。接下来，我们尝试使用键usStates["FL"]
    ➋来访问一个不在字典中的州。幸运的是，因为我们使用了if-let语句，当计算机找不到这个州时，程序不会崩溃。相反，打印出“我在字典中没有这个州”。
- en: '**ADDING ITEMS TO A DICTIONARY**'
  id: totrans-3969
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**向字典添加项目**'
- en: 'To add an item to a dictionary, first write the name of your dictionary and
    assign the new item to the key you want it to have in the dictionary. Let’s add
    "Minnesota" to our usStates dictionary:'
  id: totrans-3970
  prefs: []
  type: TYPE_NORMAL
  zh: 要向字典中添加项，首先写出字典的名称，然后将新项分配给你希望它在字典中拥有的键。让我们将“Minnesota”添加到我们的usStates字典中：
- en: '![](Image00144.jpg)'
  id: totrans-3971
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00144.jpg)'
- en: 'Now when you look at usStates , you’ll see that it’s updated to ["MN": "Minnesota",
    "WA": "Washington", "MA": "Massachusetts", "TX": "Texas"] . Remember, because
    you don’t have to rely on indices, your new dictionary item might appear anywhere
    in the dictionary.'
  id: totrans-3972
  prefs: []
  type: TYPE_NORMAL
  zh: '现在，当你查看usStates时，你会发现它已经更新为["MN": "Minnesota", "WA": "Washington", "MA": "Massachusetts",
    "TX": "Texas"]。记住，因为你不必依赖于索引，所以你的新字典项可能出现在字典的任何位置。'
- en: '**REMOVING ITEMS FROM A DICTIONARY**'
  id: totrans-3973
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**从字典中删除项**'
- en: Removing an item from a dictionary is quite simple; you do so by setting the
    value to nil . Because the values in dictionaries are returned as optionals, you
    don’t have to worry about nil causing any problems in your dictionary.
  id: totrans-3974
  prefs: []
  type: TYPE_NORMAL
  zh: 从字典中删除项很简单；你只需要将该值设置为nil。由于字典中的值作为可选值返回，所以你不必担心nil会在字典中引起任何问题。
- en: '![](Image00145.jpg)'
  id: totrans-3975
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00145.jpg)'
- en: 'You can see that after you remove the value at the key "MA" , usStates is updated
    to ["MN": "Minnesota", "WA": "Washington", "TX": "Texas"] . Remember that nil
    is special and means that there’s no value at all. That’s why you don’t see "MA":
    nil in our dictionary.'
  id: totrans-3976
  prefs: []
  type: TYPE_NORMAL
  zh: '你可以看到，在删除键"MA"对应的值后，usStates被更新为["MN": "Minnesota", "WA": "Washington", "TX":
    "Texas"]。记住，nil是特殊的，意味着没有任何值。这就是为什么你在字典中看不到"MA": nil。'
- en: '**REPLACING ITEMS IN A DICTIONARY**'
  id: totrans-3977
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**替换字典中的项**'
- en: 'Replacing an item in a dictionary is also easy. It works the same was as replacing
    an item in an array. You just set the item that you want to replace to something
    else. Say you create a dictionary of fruit colors:'
  id: totrans-3978
  prefs: []
  type: TYPE_NORMAL
  zh: 替换字典中的项也很简单。它的操作方式与替换数组中的项一样。你只需将要替换的项设置为其他内容。假设你创建了一个包含水果颜色的字典：
- en: '![](Image00146.jpg)'
  id: totrans-3979
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00146.jpg)'
- en: At first we had the value "apple" for "red" , but then we decided that "raspberry"
    is a better fruit to use since sometimes apples are green or yellow. To replace
    "apple" with "raspberry" , we set colorFruits["red"] to its new value ➊ .
  id: totrans-3980
  prefs: []
  type: TYPE_NORMAL
  zh: 起初，我们给“red”分配了“apple”作为值，但后来我们决定用“raspberry”替换“apple”，因为有时苹果是绿色或黄色的。为了将“apple”替换为“raspberry”，我们将colorFruits["red"]设置为它的新值
    ➊。
- en: You may remember that this is the same way we entered a new value into a dictionary.
    If the key already exists in the dictionary, then the value for that key is replaced.
    If the key doesn’t already exist, then the new key/value pair will be added to
    the dictionary.
  id: totrans-3981
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能还记得，这与我们之前向字典中输入新值的方式相同。如果该键已经存在于字典中，那么该键的值将被替换。如果该键不存在，则新键/值对将被添加到字典中。
- en: '![Image](Image00147.jpg)'
  id: totrans-3982
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Image00147.jpg)'
- en: '**USING DICTIONARY PROPERTIES**'
  id: totrans-3983
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**使用字典属性**'
- en: 'Like an array, a dictionary also has an isEmpty property and a count property.
    For example, the following code shows how you can use the isEmpty property to
    check if a dictionary is empty, and if it isn’t empty, the count property checks
    how many items you have. Imagine you have a basket of fruit for sale. You can
    use these properties to help you keep track of everything:'
  id: totrans-3984
  prefs: []
  type: TYPE_NORMAL
  zh: 与数组一样，字典也有isEmpty属性和count属性。例如，以下代码展示了如何使用isEmpty属性来检查字典是否为空，如果字典不为空，count属性可以检查字典中有多少项。假设你有一个水果篮子待售，你可以使用这些属性来帮助你追踪所有内容：
- en: '![Image](Image00148.jpg)'
  id: totrans-3985
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00148.jpg)'
- en: 'A dictionary also has two special properties: keys , which contains all of
    the dictionary’s keys, and values , which contains all of its values. We’ll use
    these two properties when we loop through the dictionary.'
  id: totrans-3986
  prefs: []
  type: TYPE_NORMAL
  zh: 字典还有两个特殊的属性：keys ，它包含字典的所有键，和 values ，它包含字典的所有值。我们将在循环遍历字典时使用这两个属性。
- en: Let’s write some code that loops through our fruit baskets and prints the price
    of each fruit.
  id: totrans-3987
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们编写一些代码，循环遍历我们的水果篮并打印每个水果的价格。
- en: '**LOOPING OVER A DICTIONARY**'
  id: totrans-3988
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**循环遍历字典**'
- en: 'You can loop through a dictionary using a for-in loop. Because each item has
    a key and a value, you can do this in two different ways. This is how to loop
    through a dictionary using its keys:'
  id: totrans-3989
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用 for-in 循环遍历字典。由于每个项目都有一个键和值，你可以通过两种不同的方式来遍历字典。这是通过字典的键来循环遍历的方法：
- en: '![Image](Image00149.jpg)'
  id: totrans-3990
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00149.jpg)'
- en: Here we use the dictionary’s keys property ➊ to loop through fruitBasket and
    print its contents. We start by writing the keyword for , followed by a constant
    name fruit for the dictionary key, the keyword in , the dictionary name, a period,
    and keys .
  id: totrans-3991
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们使用字典的 keys 属性 ➊ 来循环遍历 fruitBasket 并打印其内容。我们从编写关键字 for 开始，接着是一个常量名称 fruit
    代表字典键，关键字 in ，字典名称，一个点符号，和 keys 属性。
- en: Inside the braces of our for-in loop, we have access to both the key, which
    we call fruit ➋ , and the value at that key when we force-unwrap its contents
    with fruitBasket[fruit]! ➌ . That value will be the fruit’s price.
  id: totrans-3992
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们 for-in 循环的大括号内，我们可以访问键，我们称之为 fruit ➋ ，以及该键对应的值，当我们通过 fruitBasket[fruit]!
    强制解包它的内容时 ➌ 。该值将是水果的价格。
- en: In this case, it’s safe to force-unwrap the value using an exclamation point
    because we know that the fruit key we’re using is definitely inside the dictionary.
  id: totrans-3993
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，使用感叹号强制解包值是安全的，因为我们知道我们使用的 fruit 键肯定存在于字典中。
- en: Any code we put inside the for-in loop will run once for every key in our dictionary.
    So you should see the print statement display three times.
  id: totrans-3994
  prefs: []
  type: TYPE_NORMAL
  zh: 我们放在 for-in 循环中的任何代码都会针对字典中的每个键执行一次。所以你应该看到打印语句显示三次。
- en: 'We can also loop through the dictionary using its values property:'
  id: totrans-3995
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以通过字典的 values 属性来循环遍历字典：
- en: '![Image](Image00150.jpg)'
  id: totrans-3996
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00150.jpg)'
- en: We use the same style of for-in loop, but now we use a constant to refer to
    each value, which we call price , in the values property. When looping through
    values, we don’t have access to the keys from inside the loop.
  id: totrans-3997
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用相同风格的 for-in 循环，但现在我们使用常量来引用每个值，我们称之为 price ，它在 values 属性中。当循环遍历值时，我们无法从循环内部访问键。
- en: Another difference to note is that price is not an optional because it’s accessed
    directly as a value in the fruitBasket dictionary. That means we don’t have to
    unwrap it. You should still see the print statement printed three times. [Figure
    6-6](text00016.html#ch06fig6) shows the output of both loops.
  id: totrans-3998
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个需要注意的区别是 price 不是可选类型，因为它直接作为值在 fruitBasket 字典中访问。这意味着我们不需要解包它。你仍然应该看到打印语句显示三次。[图
    6-6](text00016.html#ch06fig6) 显示了两个循环的输出。
- en: '![Image](Image00151.jpg)'
  id: totrans-3999
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00151.jpg)'
- en: '*Figure 6-6: Looping through the keys and values of a dictionary with a for-in
    loop*'
  id: totrans-4000
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 6-6：使用 for-in 循环遍历字典的键和值*'
- en: The order of your results might be slightly different from ours. That’s because
    the items in a dictionary aren’t in a numbered order like they are in an array!
    And because the order is not guaranteed, you might see a different order printed
    if you run the same code again.
  id: totrans-4001
  prefs: []
  type: TYPE_NORMAL
  zh: 你的结果顺序可能与我们的稍有不同。这是因为字典中的项目不像数组那样按编号顺序排列！而且由于顺序无法保证，如果你重新运行相同的代码，可能会看到不同的打印顺序。
- en: '**WHAT YOU LEARNED**'
  id: totrans-4002
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**你学到了什么**'
- en: In this chapter, you learned how to store collections of items in an array and
    in a dictionary. To store items in an ordered list, you would use an array and
    look up each item by its index. If you wanted to store items by key instead, you
    would use a dictionary.
  id: totrans-4003
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你学习了如何在数组和字典中存储项目集合。要将项目存储在有序列表中，你会使用数组并通过索引查找每个项目。如果你想通过键来存储项目，则会使用字典。
- en: Knowing about arrays and dictionaries and how to use them is a powerful building
    block for almost any programming language. Next we will learn about functions,
    another very powerful tool. Functions are blocks of code that you create and name
    to perform a specific job. After you have written a function, you can use its
    name to call it from almost anywhere in your program.
  id: totrans-4004
  prefs: []
  type: TYPE_NORMAL
  zh: 了解数组和字典以及如何使用它们是几乎所有编程语言中的一个强大构建块。接下来我们将学习函数，这是另一个非常强大的工具。函数是你创建并命名的代码块，用于执行特定的任务。写完函数后，你可以通过其名称从程序的几乎任何地方调用它。
- en: '![Image](Image00119.jpg)'
  id: totrans-4005
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00119.jpg)'
- en: '*Figure 6-2: Trying to access an index in the array where nothing exists causes
    an error.*'
  id: totrans-4006
  prefs: []
  type: TYPE_NORMAL
  zh: '*图6-2：尝试访问数组中不存在的索引会导致错误。*'
- en: '**ADDING ITEMS TO AN ARRAY**'
  id: totrans-4007
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**向数组添加项目**'
- en: One way to change an array is to add new items to it. There are a few different
    ways to do this, so let’s take a look at each.
  id: totrans-4008
  prefs: []
  type: TYPE_NORMAL
  zh: 更改数组的一种方式是向其中添加新项目。有几种不同的方法可以做到这一点，让我们来看一下每种方法。
- en: 'First, you can use an array’s append(_:) method. *Append* means to add something.
    Using append(_:) , you can add one new item to the end of your array. Say you
    go on another trip and visit the Badlands, and you want to add it to your list
    of national parks. To do that, add this code into your playground:'
  id: totrans-4009
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，你可以使用数组的append(_:)方法。*Append*表示添加某个项。使用append(_:)方法，你可以将一个新项添加到数组的末尾。假设你去了一次新旅行，参观了Badlands，并希望将它添加到你的国家公园列表中。为此，将以下代码添加到你的playground中：
- en: '![](Image00120.jpg)'
  id: totrans-4010
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00120.jpg)'
- en: To use the append(_:) method, first write the name of your array followed by
    a period and then append . Then, put the item you want to add to your array inside
    the parentheses. In this case, you put "Badlands" inside the parentheses.
  id: totrans-4011
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用append(_:)方法，首先写出你的数组名称，后面跟一个句点，再加上append。然后，将你想要添加到数组中的项放在括号内。在这种情况下，你将“Badlands”放在括号内。
- en: 'If you want to add something at a specific place in your array, use the array’s
    insert(_:at:) method instead. This method takes two arguments: the item that you
    want to insert and the index of where it should go in the array. (We’ll discuss
    arguments in more detail in [Chapter 7](text00017.html#ch07) .)'
  id: totrans-4012
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想在数组中的特定位置添加某个项，请改用数组的insert(_:at:)方法。此方法有两个参数：你想要插入的项和它应放置在数组中的索引位置。（我们将在[第7章](text00017.html#ch07)中详细讨论参数。）
- en: 'Let’s say you totally forgot that you went to the Petrified Forest right after
    you visited the Grand Canyon, and you want to update your nationalParks array
    so it displays the parks in the order in which you visited them. To update your
    array, you could use the insert(_:at:) method to put the Petrified Forest in the
    right position:'
  id: totrans-4013
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你完全忘记了在参观大峡谷之后你还去了化石森林，并且你想更新你的nationalParks数组，以便按你访问的顺序显示这些公园。为了更新数组，你可以使用insert(_:at:)方法将化石森林放在正确的位置：
- en: '![](Image00121.jpg)'
  id: totrans-4014
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00121.jpg)'
- en: When you insert a new item at index 3, everything that was in the array at index
    3 or higher gets scooted over to make room for the new item. That means the item
    that was at index 3 is now at index 4, the item that was at index 4 is now at
    index 5, and so on. After you add the Petrified Forest, nationalParks is now ["Acadia",
    "Zion", "Grand Canyon", "Petrified Forest", "Badlands"] .
  id: totrans-4015
  prefs: []
  type: TYPE_NORMAL
  zh: 当你在索引3插入新项时，数组中索引3或更高位置的所有项都会向后移动，以腾出空间给新项。这意味着，原本在索引3的项现在位于索引4，原本在索引4的项现在位于索引5，依此类推。添加了化石森林之后，nationalParks数组现在变为["Acadia",
    "Zion", "Grand Canyon", "Petrified Forest", "Badlands"]。
- en: '**COMBINING ARRAYS**'
  id: totrans-4016
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**合并数组**'
- en: 'Not only can you add new items to an array, but you can also add two arrays
    together using the + and += operators. Let’s say that you have the ingredients
    for a fruit smoothie in two arrays:'
  id: totrans-4017
  prefs: []
  type: TYPE_NORMAL
  zh: 你不仅可以向数组中添加新项目，还可以使用+和+=运算符将两个数组合并。假设你有两个数组，分别包含水果冰沙的原料：
- en: '![](Image00122.jpg)'
  id: totrans-4018
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00122.jpg)'
- en: Now you can make a delicious smoothie by adding the fruits and liquids arrays.
  id: totrans-4019
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你可以通过将水果和液体数组添加到一起，制作一款美味的冰沙。
- en: '![](Image00123.jpg)'
  id: totrans-4020
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00123.jpg)'
- en: The order of the ingredients in smoothie is the same as the order in fruits
    and liquids . If you created smoothie with liquids + fruits , then the liquids
    would come first.
  id: totrans-4021
  prefs: []
  type: TYPE_NORMAL
  zh: 冰沙中的原料顺序与水果和液体数组中的顺序相同。如果你用液体+水果创建冰沙，那么液体会排在前面。
- en: 'You use the += operator to add an array to the end of your array. Add some
    whipped cream as follows for extra yumminess:'
  id: totrans-4022
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用+=运算符将一个数组添加到另一个数组的末尾。你可以像这样添加一些搅打奶油，以增加美味：
- en: '![](Image00124.jpg)'
  id: totrans-4023
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00124.jpg)'
- en: Note that ["whipped cream"] is an array even though it has a single item in
    it. When you’re using += to append something to an array, you have to make sure
    you’re only trying to add another array. If you were to just write the string
    "whipped cream" without the square brackets around it, you would get an error.
  id: totrans-4024
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，["whipped cream"]是一个数组，尽管它只有一个项目。当你使用+=将某物添加到数组时，你必须确保你只是在尝试添加另一个数组。如果你只是写字符串"whipped
    cream"而没有方括号，它会报错。
- en: '![Image](Image00125.jpg)'
  id: totrans-4025
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00125.jpg)'
- en: '**REMOVING ITEMS FROM AN ARRAY**'
  id: totrans-4026
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**从数组中移除项目**'
- en: 'There are several methods for removing items from an array. Let’s start by
    looking at the array’s removeLast() method. As you might have guessed from its
    name, removeLast() removes the last item from your array. Let’s try it out with
    a shoppingList array:'
  id: totrans-4027
  prefs: []
  type: TYPE_NORMAL
  zh: 有几种方法可以从数组中移除项目。让我们从查看数组的removeLast()方法开始。正如你从它的名字中可能猜到的，removeLast()会移除数组中的最后一个项目。让我们用shoppingList数组来试一下：
- en: '![](Image00126.jpg)'
  id: totrans-4028
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00126.jpg)'
- en: Neat! Note that the removeLast() method returns the removed item, so you can
    store it in a new constant or variable if you want.
  id: totrans-4029
  prefs: []
  type: TYPE_NORMAL
  zh: 很棒！请注意，removeLast()方法返回被移除的项目，因此如果你愿意，可以将其存储在一个新的常量或变量中。
- en: 'You can also remove an item from a specific index by using the remove(at:)
    method. Let’s say that your mom doesn’t want you buying any candy and takes that
    off the list:'
  id: totrans-4030
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以通过使用remove(at:)方法从特定索引移除一个项目。假设你的妈妈不想让你买糖果，并把它从清单上拿掉：
- en: '![Image](Image00127.jpg)![](Image00128.jpg)'
  id: totrans-4031
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00127.jpg)![](Image00128.jpg)'
- en: Just like when we added an item to the middle of our array and all the items
    scooted over to make room, if you remove an item from the middle of an array,
    the rest of the items will scoot back to fill in that empty space. The "apples"
    item that was at index 3 is now at index 2, where "candy" was.
  id: totrans-4032
  prefs: []
  type: TYPE_NORMAL
  zh: 就像我们将项目添加到数组中间时，所有项目会挤过来腾出空间一样，如果你从数组的中间移除一个项目，其余的项目会挤回去填补那个空位。原来在索引3处的“苹果”现在位于索引2的位置，即原本“糖果”所在的位置。
- en: 'You can also remove all items from an array with removeAll() . Try entering
    this into your playground:'
  id: totrans-4033
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以使用removeAll()移除数组中的所有项目。尝试在你的游乐场输入这个：
- en: '![](Image00129.jpg)'
  id: totrans-4034
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00129.jpg)'
- en: 'Note that trying to remove an item at an index that doesn’t exist will give
    you an error:'
  id: totrans-4035
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，尝试移除一个不存在的索引位置的项目会导致错误：
- en: '![](Image00130.jpg)'
  id: totrans-4036
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00130.jpg)'
- en: Our array doesn’t have this many items (in fact, now it’s empty!), so this throws
    an error. We’ll also get an error if we use removeLast() on our empty array, because
    there’s nothing in it—there’s no last index at all! However, removeAll() is always
    safe to use, even on an empty array.
  id: totrans-4037
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的数组没有这么多项目（事实上，现在它已经空了！），所以会抛出一个错误。如果我们对空数组使用removeLast()，也会报错，因为里面什么都没有——根本没有最后一个索引！但是，removeAll()即使在空数组上使用也是安全的。
- en: '**REPLACING ITEMS IN AN ARRAY**'
  id: totrans-4038
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**替换数组中的项目**'
- en: 'To replace an item in an array, you set the index of the array to the new value,
    as shown here:'
  id: totrans-4039
  prefs: []
  type: TYPE_NORMAL
  zh: 要替换数组中的一个项目，你可以将数组的索引设置为新值，如下所示：
- en: '![](Image00131.jpg)'
  id: totrans-4040
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00131.jpg)'
- en: At ➊ , we replaced the item at index 2 (the third item) with "Unicorn" because
    magical animals count as favorite animals, too! At ➋ , we replaced the item at
    index 0 (the first item) with "Bearded dragon" . No, that’s not a real dragon—it’s
    just a lizard!
  id: totrans-4041
  prefs: []
  type: TYPE_NORMAL
  zh: 在 ➊ 处，我们将索引为2（第三个项目）的位置替换为“独角兽”，因为魔法动物也算作是最喜欢的动物！在 ➋ 处，我们将索引为0（第一个项目）的位置替换为“胡须龙”。不，这不是一只真正的龙——它只是一只蜥蜴！
- en: Like any time you’re working with array index numbers, you have to be sure an
    item exists in the array at that index before you change its value, or you will
    get an Index out of range error.
  id: totrans-4042
  prefs: []
  type: TYPE_NORMAL
  zh: 就像你在处理数组索引时一样，在更改某个项目的值之前，你必须确保该索引位置的项目确实存在，否则你会得到“索引超出范围”的错误。
- en: '[Figure 6-3](text00016.html#ch06fig3) shows the error that occurs if you try
    to add "Standard poodle" using favoriteAnimals[3] = "Standard poodle" . To add
    an item to the end of an array, you should use the append(_:) method or += , as
    we covered in “[Adding Items to an Array](text00016.html#ch06lev2sec5) ” on [page
    70](text00016.html#page_70) .'
  id: totrans-4043
  prefs: []
  type: TYPE_NORMAL
  zh: '[图6-3](text00016.html#ch06fig3)显示了如果你尝试使用favoriteAnimals[3] = "标准贵宾犬"添加“标准贵宾犬”时发生的错误。要将一个项目添加到数组的末尾，你应该使用append(_:)方法或+=，正如我们在“[向数组添加项目](text00016.html#ch06lev2sec5)”中讲解的那样，在[第70页](text00016.html#page_70)。'
- en: '![Image](Image00132.jpg)'
  id: totrans-4044
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00132.jpg)'
- en: '*Figure 6-3: Don’t try to replace a value at an index beyond the existing array.*'
  id: totrans-4045
  prefs: []
  type: TYPE_NORMAL
  zh: '*图6-3：不要尝试替换超出现有数组索引的值。*'
- en: Now you know how to change arrays however you might need to. You can add items,
    take items away, or replace items. Next, we’ll look at how to use the properties
    of arrays to find out even more information about them.
  id: totrans-4046
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你知道如何根据需要更改数组了。你可以添加、删除或替换项。接下来，我们将看看如何使用数组的属性来获取更多有关它们的信息。
- en: '![Image](Image00133.jpg)'
  id: totrans-4047
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Image00133.jpg)'
- en: '**USING ARRAY PROPERTIES**'
  id: totrans-4048
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**使用数组属性**'
- en: In addition to methods like append(_:) and removeLast() , arrays also have *properties*
    . An array’s properties are variables or constants that contain some information
    about the array. Two really helpful properties that you might use are the Boolean
    property isEmpty and the integer property count .
  id: totrans-4049
  prefs: []
  type: TYPE_NORMAL
  zh: 除了像 append(_:) 和 removeLast() 这样的操作方法，数组还有*属性*。数组的属性是包含有关数组的一些信息的变量或常量。你可能会用到的两个非常有用的属性是布尔值属性
    isEmpty 和整数属性 count。
- en: The isEmpty property is true or false depending on whether the array is empty,
    and the count property will tell you how many items are in that array.
  id: totrans-4050
  prefs: []
  type: TYPE_NORMAL
  zh: isEmpty 属性的值是 `true` 或 `false`，取决于数组是否为空，而 count 属性则告诉你数组中有多少项。
- en: 'Check out how these two properties are used in the following if-else statement:'
  id: totrans-4051
  prefs: []
  type: TYPE_NORMAL
  zh: 看一下以下 if-else 语句中这两个属性是如何使用的：
- en: '![Image](Image00134.jpg)'
  id: totrans-4052
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Image00134.jpg)'
- en: 'This if-else statement checks whether the array mySiblings is empty ➊ . If
    it is, then "I don''t have any siblings." is printed. But if there is something
    in the array, then the number of siblings that we have is printed: "I have 3 siblings."
    ➋ .'
  id: totrans-4053
  prefs: []
  type: TYPE_NORMAL
  zh: 这个 if-else 语句检查数组 mySiblings 是否为空 ➊。如果为空，则打印 "我没有兄弟姐妹。"。如果数组中有内容，则打印我们有几个兄弟姐妹："我有
    3 个兄弟姐妹。" ➋。
- en: '**LOOPING OVER AN ARRAY**'
  id: totrans-4054
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**遍历数组**'
- en: 'Sometimes when you’re working with arrays you might want to do something to
    every item in the array. You can use a for-in loop to do that! The following code
    will print every topping in a pizzaToppings array on a separate line:'
  id: totrans-4055
  prefs: []
  type: TYPE_NORMAL
  zh: 有时在处理数组时，你可能希望对数组中的每个项执行某些操作。你可以使用 `for-in` 循环来实现！以下代码会逐行打印 pizzaToppings 数组中的每个配料：
- en: '![Image](Image00135.jpg)'
  id: totrans-4056
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Image00135.jpg)'
- en: To write a for-in loop for the pizzaToppings array, we used the keyword for
    , followed by the constant topping , then the keyword in , and finally the name
    of our array, pizzaToppings . Then we put the statements that we want to run for
    each topping inside the braces of the for-in loop. The constant topping ➊ temporarily
    represents each pizza topping in the array as we loop through it. We could have
    chosen any name for this constant, but it’s a good idea to pick something that
    makes sense. You can see the output of this for-in loop in [Figure 6-4](text00016.html#ch06fig4)
    .
  id: totrans-4057
  prefs: []
  type: TYPE_NORMAL
  zh: 为了编写针对 pizzaToppings 数组的 `for-in` 循环，我们使用了关键字 `for`，后跟常量 topping，然后是关键字 `in`，最后是数组名称
    pizzaToppings。接着我们将要为每个配料执行的语句放入 `for-in` 循环的花括号内。常量 topping ➊ 在我们遍历数组时，临时代表数组中的每个配料。我们可以为这个常量选择任何名称，但最好选一个有意义的名字。你可以在
    [图 6-4](text00016.html#ch06fig4) 中看到这个 `for-in` 循环的输出。
- en: '![Image](Image00136.jpg)'
  id: totrans-4058
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Image00136.jpg)'
- en: '*Figure 6-4: Output of the example for-in loop*'
  id: totrans-4059
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 6-4：示例 `for-in` 循环的输出*'
- en: '![Image](Image00137.jpg)'
  id: totrans-4060
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Image00137.jpg)'
- en: 'Using for-in loops is great for printing every value in an array. If you’re
    working with numbers, you can even use them to perform math operations on each
    item, which makes for some speedy calculations! The following code takes an array
    of numbers and calculates the square for each (the square of a number is that
    number multiplied by itself):'
  id: totrans-4061
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `for-in` 循环非常适合打印数组中的每个值。如果你在处理数字，还可以用它们对每个项进行数学运算，这样可以快速进行计算！以下代码会取一个数字数组，并计算每个数字的平方（数字的平方是该数字与其自身相乘）：
- en: '![Image](Image00138.jpg)'
  id: totrans-4062
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Image00138.jpg)'
- en: '[Figure 6-5](text00016.html#ch06fig5) shows the results.'
  id: totrans-4063
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 6-5](text00016.html#ch06fig5) 显示了结果。'
- en: '![Image](Image00139.jpg)'
  id: totrans-4064
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Image00139.jpg)'
- en: '*Figure 6-5: Printing the squares for each number in the myNumbers array*'
  id: totrans-4065
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 6-5：打印 myNumbers 数组中每个数字的平方*'
- en: '**DICTIONARIES ARE KEY!**'
  id: totrans-4066
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**字典是关键！**'
- en: A *dictionary* is also a collection of values, but instead of an ordered index,
    each value has its own *key* . Because there’s no index, the values are not stored
    in any particular order. To access values in a dictionary, you look them up by
    their key.
  id: totrans-4067
  prefs: []
  type: TYPE_NORMAL
  zh: '*字典* 也是一种值的集合，但不同于有序的索引，每个值都有自己的*键*。由于没有索引，值不会按照特定顺序存储。要访问字典中的值，你需要通过它们的键进行查找。'
- en: A key must be unique. You can’t have the same key more than once in the same
    dictionary. If there were two identical keys and you asked the computer to give
    you the value for one of them, the computer wouldn’t know which one to choose!
  id: totrans-4068
  prefs: []
  type: TYPE_NORMAL
  zh: 键必须是唯一的。你不能在同一个字典中有相同的键。如果有两个相同的键，并且你要求计算机返回其中一个的值，计算机就不知道该选择哪一个！
- en: Let’s take a look at how to make a dictionary and write keys that will help
    you find all the information you need.
  id: totrans-4069
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看如何创建一个字典，并编写键以帮助你找到所需的所有信息。
- en: '![Image](Image00140.jpg)'
  id: totrans-4070
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00140.jpg)'
- en: '**INITIALIZING A DICTIONARY**'
  id: totrans-4071
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**初始化字典**'
- en: 'To create and initialize a dictionary, first write var and the name of your
    dictionary. Then write the keys and corresponding values inside a pair of square
    brackets, similar to an array. Let’s create a dictionary to store the names of
    a few US states. The key for each state will be its two-letter abbreviation:'
  id: totrans-4072
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建和初始化字典，首先写上`var`和字典的名称。然后像数组一样，使用一对方括号来写入键及其对应的值。让我们创建一个字典来存储一些美国州的名称。每个州的键将是其两字母的缩写：
- en: '![](Image00141.jpg)'
  id: totrans-4073
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00141.jpg)'
- en: As you can see, there’s a colon between each key and its value, and the key/value
    pairs are separated by commas.
  id: totrans-4074
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，每个键和值之间有一个冒号，键/值对之间用逗号分隔。
- en: Dictionaries are different from arrays in that they are *unordered* . Because
    of that, it’s likely that the order of the states that you see in your results
    pane ➋ is different from the order in which you entered your states ➊ . It might
    even be different than the order that’s printed in this book!
  id: totrans-4075
  prefs: []
  type: TYPE_NORMAL
  zh: 字典与数组不同，它们是*无序的*。因此，结果窗格➋中显示的州的顺序可能与输入时的顺序➊不同，甚至可能与本书中显示的顺序不同！
- en: As with arrays, you can use var to make a mutable dictionary or use let to make
    an immutable dictionary.
  id: totrans-4076
  prefs: []
  type: TYPE_NORMAL
  zh: 与数组一样，你可以使用`var`来创建一个可变字典，或者使用`let`来创建一个不可变字典。
- en: 'In Swift, all of the keys of a dictionary must be the same type, and all of
    the values of a dictionary must also be the same type, but the key type doesn’t
    have to match the value type. For example, if you wanted to store a collection
    of fractions, you could use doubles for the keys and strings for the values:'
  id: totrans-4077
  prefs: []
  type: TYPE_NORMAL
  zh: 在Swift中，字典的所有键必须是相同类型，字典的所有值也必须是相同类型，但键的类型不必与值的类型相匹配。例如，如果你想存储一个分数集合，你可以使用`double`类型作为键，`string`类型作为值：
- en: '![](Image00142.jpg)'
  id: totrans-4078
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00142.jpg)'
- en: In this dictionary, all of the keys must be doubles, and all of the values must
    be strings. Again, you’ll see that the order of the numbers in the results pane
    can be quite different from the order in which you wrote the fractions in your
    dictionary. This is fine because you don’t need to know the order to access anything.
    You can find any item that you need by its key. Let’s see how!
  id: totrans-4079
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个字典中，所有的键必须是`double`类型，所有的值必须是`string`类型。同样，你会看到，结果窗格中的数字顺序可能与字典中分数的输入顺序大不相同。这是可以的，因为你不需要知道顺序来访问任何内容。你可以通过键找到你需要的任何项。让我们看看如何做！
- en: '**ACCESSING VALUES IN A DICTIONARY**'
  id: totrans-4080
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**访问字典中的值**'
- en: 'Looking up a value in a dictionary is similar to how you access a value in
    an array except that you use a key inside the square brackets instead of an index,
    like this: usStates["TX"] .'
  id: totrans-4081
  prefs: []
  type: TYPE_NORMAL
  zh: 在字典中查找一个值类似于你如何访问数组中的一个值，只不过你使用的是键而不是索引，像这样：usStates["TX"]。
- en: There is a big difference, however, in how Swift returns the values from a dictionary.
    When you access a value at an index of an array, you are simply given the value.
    When you access a value with a key in a dictionary, you are given an optional.
  id: totrans-4082
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，Swift从字典中返回值的方式有很大的不同。当你访问数组中的某个索引的值时，你会直接得到该值。而当你用键访问字典中的值时，你得到的是一个可选项。
- en: In [Chapter 5](text00015.html#ch05) , you learned that optionals might contain
    a value or might be nil . The reason Swift returns optionals when you’re looking
    up items in a dictionary is that the key you used might not exist in the dictionary,
    in which case there’s no value to access. Trying to access a value that doesn’t
    exist would give you a big fat error! To avoid that problem, Swift returns optionals.
    That means you need to unwrap any value you get out of a dictionary before you
    can do anything with it.
  id: totrans-4083
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第五章](text00015.html#ch05)中，你学习了可选项可能包含一个值，也可能是nil。Swift在你查找字典中的项时返回可选项，是因为你使用的键可能在字典中不存在，在这种情况下没有值可以访问。尝试访问一个不存在的值会导致一个大错误！为了避免这个问题，Swift返回可选项。这意味着你需要解包从字典中获取的任何值，然后才能对其进行操作。
- en: 'To unwrap an optional, first you check whether it exists using an if-let statement,
    just like we did in [Chapter 5](text00015.html#ch05) . The following code shows
    you how to get a value out of a dictionary:'
  id: totrans-4084
  prefs: []
  type: TYPE_NORMAL
  zh: 要解包可选值，首先你需要检查它是否存在，使用 if-let 语句，就像我们在[第5章](text00015.html#ch05)中做的那样。以下代码展示了如何从字典中获取值：
- en: '![Image](Image00143.jpg)'
  id: totrans-4085
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00143.jpg)'
- en: To retrieve "Texas" from the dictionary, we use if let to set a constant loneStarState
    to usStates["TX"] ➊ . Because we have this state in our dictionary, the line I
    have Texas in my dictionary. is printed. Next we try to access a state that is
    not in our dictionary by using the key usStates["FL"] ➋ . Thankfully, because
    we used an if-let statement, the program won’t crash when the computer can’t find
    this state. Instead, I don't have that state in my dictionary. is printed.
  id: totrans-4086
  prefs: []
  type: TYPE_NORMAL
  zh: 要从字典中检索“Texas”，我们使用 if let 语句将常量 loneStarState 设置为 usStates["TX"] ➊。因为我们在字典中有这个州，所以会打印出
    “I have Texas in my dictionary.” 接下来，我们尝试通过使用键 usStates["FL"] ➋ 访问一个不在字典中的州。幸运的是，由于我们使用了
    if-let 语句，当计算机找不到该州时，程序不会崩溃。相反，会打印出 “I don't have that state in my dictionary.”
- en: '**ADDING ITEMS TO A DICTIONARY**'
  id: totrans-4087
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**向字典中添加项目**'
- en: 'To add an item to a dictionary, first write the name of your dictionary and
    assign the new item to the key you want it to have in the dictionary. Let’s add
    "Minnesota" to our usStates dictionary:'
  id: totrans-4088
  prefs: []
  type: TYPE_NORMAL
  zh: 要向字典添加项目，首先写出字典的名称，并将新项目分配给你希望其在字典中拥有的键。让我们将“Minnesota”添加到我们的 usStates 字典中：
- en: '![](Image00144.jpg)'
  id: totrans-4089
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00144.jpg)'
- en: 'Now when you look at usStates , you’ll see that it’s updated to ["MN": "Minnesota",
    "WA": "Washington", "MA": "Massachusetts", "TX": "Texas"] . Remember, because
    you don’t have to rely on indices, your new dictionary item might appear anywhere
    in the dictionary.'
  id: totrans-4090
  prefs: []
  type: TYPE_NORMAL
  zh: '现在，当你查看 usStates 时，你会看到它已更新为["MN": "Minnesota", "WA": "Washington", "MA": "Massachusetts",
    "TX": "Texas"]。记住，由于你不必依赖索引，你的新字典项目可能出现在字典中的任何位置。'
- en: '**REMOVING ITEMS FROM A DICTIONARY**'
  id: totrans-4091
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**从字典中删除项目**'
- en: Removing an item from a dictionary is quite simple; you do so by setting the
    value to nil . Because the values in dictionaries are returned as optionals, you
    don’t have to worry about nil causing any problems in your dictionary.
  id: totrans-4092
  prefs: []
  type: TYPE_NORMAL
  zh: 从字典中删除项目非常简单；你只需将值设置为 nil。因为字典中的值作为可选值返回，所以你不必担心 nil 会在字典中造成任何问题。
- en: '![](Image00145.jpg)'
  id: totrans-4093
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00145.jpg)'
- en: 'You can see that after you remove the value at the key "MA" , usStates is updated
    to ["MN": "Minnesota", "WA": "Washington", "TX": "Texas"] . Remember that nil
    is special and means that there’s no value at all. That’s why you don’t see "MA":
    nil in our dictionary.'
  id: totrans-4094
  prefs: []
  type: TYPE_NORMAL
  zh: '你可以看到，在删除键“MA”处的值后，usStates 已更新为["MN": "Minnesota", "WA": "Washington", "TX":
    "Texas"]。记住，nil 是特殊的，意味着没有值。因此，你在字典中不会看到 "MA": nil。'
- en: '**REPLACING ITEMS IN A DICTIONARY**'
  id: totrans-4095
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**在字典中替换项目**'
- en: 'Replacing an item in a dictionary is also easy. It works the same was as replacing
    an item in an array. You just set the item that you want to replace to something
    else. Say you create a dictionary of fruit colors:'
  id: totrans-4096
  prefs: []
  type: TYPE_NORMAL
  zh: 替换字典中的项目也很简单。它的工作方式与替换数组中的项目相同。你只需将要替换的项目设置为其他值。假设你创建了一个水果颜色的字典：
- en: '![](Image00146.jpg)'
  id: totrans-4097
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00146.jpg)'
- en: At first we had the value "apple" for "red" , but then we decided that "raspberry"
    is a better fruit to use since sometimes apples are green or yellow. To replace
    "apple" with "raspberry" , we set colorFruits["red"] to its new value ➊ .
  id: totrans-4098
  prefs: []
  type: TYPE_NORMAL
  zh: 起初我们为“red”设置了值“apple”，但后来我们决定“raspberry”是一个更好的水果，因为有时苹果是绿色或黄色的。要将“apple”替换为“raspberry”，我们将
    colorFruits["red"] 设置为它的新值 ➊。
- en: You may remember that this is the same way we entered a new value into a dictionary.
    If the key already exists in the dictionary, then the value for that key is replaced.
    If the key doesn’t already exist, then the new key/value pair will be added to
    the dictionary.
  id: totrans-4099
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能记得，这与我们向字典中输入新值的方式相同。如果该键已经存在于字典中，那么该键的值将被替换。如果该键尚不存在，那么新的键/值对将被添加到字典中。
- en: '![Image](Image00147.jpg)'
  id: totrans-4100
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00147.jpg)'
- en: '**USING DICTIONARY PROPERTIES**'
  id: totrans-4101
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**使用字典属性**'
- en: 'Like an array, a dictionary also has an isEmpty property and a count property.
    For example, the following code shows how you can use the isEmpty property to
    check if a dictionary is empty, and if it isn’t empty, the count property checks
    how many items you have. Imagine you have a basket of fruit for sale. You can
    use these properties to help you keep track of everything:'
  id: totrans-4102
  prefs: []
  type: TYPE_NORMAL
  zh: 和数组一样，字典也具有 isEmpty 属性和 count 属性。例如，以下代码展示了如何使用 isEmpty 属性来检查字典是否为空，如果不为空，count
    属性则检查字典中有多少项。假设你有一个待售的水果篮。你可以使用这些属性来帮助你跟踪一切：
- en: '![Image](Image00148.jpg)'
  id: totrans-4103
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00148.jpg)'
- en: 'A dictionary also has two special properties: keys , which contains all of
    the dictionary’s keys, and values , which contains all of its values. We’ll use
    these two properties when we loop through the dictionary.'
  id: totrans-4104
  prefs: []
  type: TYPE_NORMAL
  zh: 字典还有两个特殊属性：keys，它包含字典的所有键；values，它包含字典的所有值。在遍历字典时，我们将使用这两个属性。
- en: Let’s write some code that loops through our fruit baskets and prints the price
    of each fruit.
  id: totrans-4105
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们编写一些代码，遍历我们的果篮并打印每种水果的价格。
- en: '**LOOPING OVER A DICTIONARY**'
  id: totrans-4106
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**遍历字典**'
- en: 'You can loop through a dictionary using a for-in loop. Because each item has
    a key and a value, you can do this in two different ways. This is how to loop
    through a dictionary using its keys:'
  id: totrans-4107
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用 for-in 循环遍历字典。由于每个项目都有键和值，你可以用两种不同的方式进行遍历。这是使用字典的键遍历字典的方法：
- en: '![Image](Image00149.jpg)'
  id: totrans-4108
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00149.jpg)'
- en: Here we use the dictionary’s keys property ➊ to loop through fruitBasket and
    print its contents. We start by writing the keyword for , followed by a constant
    name fruit for the dictionary key, the keyword in , the dictionary name, a period,
    and keys .
  id: totrans-4109
  prefs: []
  type: TYPE_NORMAL
  zh: 这里我们使用字典的 keys 属性 ➊ 来遍历 fruitBasket 并打印其内容。我们从编写关键字 for 开始，后跟字典键的常量名 fruit，关键字
    in，字典名，一个句点，最后是 keys。
- en: Inside the braces of our for-in loop, we have access to both the key, which
    we call fruit ➋ , and the value at that key when we force-unwrap its contents
    with fruitBasket[fruit]! ➌ . That value will be the fruit’s price.
  id: totrans-4110
  prefs: []
  type: TYPE_NORMAL
  zh: 在 for-in 循环的大括号内，我们可以访问键（我们称其为 fruit ➋）以及通过 fruitBasket[fruit]! ➌ 强制解包其内容时，该键的值。该值将是水果的价格。
- en: In this case, it’s safe to force-unwrap the value using an exclamation point
    because we know that the fruit key we’re using is definitely inside the dictionary.
  id: totrans-4111
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，使用感叹号强制解包值是安全的，因为我们知道我们使用的 fruit 键一定在字典中。
- en: Any code we put inside the for-in loop will run once for every key in our dictionary.
    So you should see the print statement display three times.
  id: totrans-4112
  prefs: []
  type: TYPE_NORMAL
  zh: 我们放入 for-in 循环中的任何代码都会为字典中的每个键执行一次。因此，你应该看到 print 语句打印三次。
- en: 'We can also loop through the dictionary using its values property:'
  id: totrans-4113
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以使用字典的 values 属性遍历字典：
- en: '![Image](Image00150.jpg)'
  id: totrans-4114
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00150.jpg)'
- en: We use the same style of for-in loop, but now we use a constant to refer to
    each value, which we call price , in the values property. When looping through
    values, we don’t have access to the keys from inside the loop.
  id: totrans-4115
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用相同的 for-in 循环样式，但现在我们使用一个常量来引用每个值，我们称其为 price，位于 values 属性中。在循环遍历 values
    时，我们无法在循环内部访问键。
- en: Another difference to note is that price is not an optional because it’s accessed
    directly as a value in the fruitBasket dictionary. That means we don’t have to
    unwrap it. You should still see the print statement printed three times. [Figure
    6-6](text00016.html#ch06fig6) shows the output of both loops.
  id: totrans-4116
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个需要注意的区别是，price 不是可选的，因为它是直接作为值在 fruitBasket 字典中访问的。这意味着我们不需要解包它。你仍然应该看到 print
    语句打印三次。[图 6-6](text00016.html#ch06fig6) 显示了两种循环的输出。
- en: '![Image](Image00151.jpg)'
  id: totrans-4117
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00151.jpg)'
- en: '*Figure 6-6: Looping through the keys and values of a dictionary with a for-in
    loop*'
  id: totrans-4118
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 6-6：使用 for-in 循环遍历字典的键和值*'
- en: The order of your results might be slightly different from ours. That’s because
    the items in a dictionary aren’t in a numbered order like they are in an array!
    And because the order is not guaranteed, you might see a different order printed
    if you run the same code again.
  id: totrans-4119
  prefs: []
  type: TYPE_NORMAL
  zh: 你的结果顺序可能与我们的略有不同。那是因为字典中的项目不像数组中的项目那样按编号顺序排列！由于顺序不可保证，如果你再次运行相同的代码，可能会看到不同的打印顺序。
- en: '**WHAT YOU LEARNED**'
  id: totrans-4120
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**你学到了什么**'
- en: In this chapter, you learned how to store collections of items in an array and
    in a dictionary. To store items in an ordered list, you would use an array and
    look up each item by its index. If you wanted to store items by key instead, you
    would use a dictionary.
  id: totrans-4121
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你学习了如何在数组和字典中存储项目集合。要在有序列表中存储项目，你会使用数组，并通过索引查找每个项目。如果你想通过键来存储项目，你会使用字典。
- en: Knowing about arrays and dictionaries and how to use them is a powerful building
    block for almost any programming language. Next we will learn about functions,
    another very powerful tool. Functions are blocks of code that you create and name
    to perform a specific job. After you have written a function, you can use its
    name to call it from almost anywhere in your program.
  id: totrans-4122
  prefs: []
  type: TYPE_NORMAL
  zh: 了解数组和字典及其使用方法是几乎所有编程语言中非常强大的构建模块。接下来，我们将学习函数，另一个非常强大的工具。函数是你创建并命名的代码块，用来执行特定的任务。编写完函数后，你可以使用它的名称在程序的几乎任何地方调用它。
- en: '*Figure 6-2: Trying to access an index in the array where nothing exists causes
    an error.*'
  id: totrans-4123
  prefs: []
  type: TYPE_NORMAL
  zh: '*图6-2：尝试访问数组中不存在的索引会导致错误。*'
- en: '**ADDING ITEMS TO AN ARRAY**'
  id: totrans-4124
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**向数组添加项**'
- en: One way to change an array is to add new items to it. There are a few different
    ways to do this, so let’s take a look at each.
  id: totrans-4125
  prefs: []
  type: TYPE_NORMAL
  zh: 更改数组的一种方法是向其中添加新项。有几种不同的方法可以实现这一点，让我们来看一下每种方法。
- en: 'First, you can use an array’s append(_:) method. *Append* means to add something.
    Using append(_:) , you can add one new item to the end of your array. Say you
    go on another trip and visit the Badlands, and you want to add it to your list
    of national parks. To do that, add this code into your playground:'
  id: totrans-4126
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，你可以使用数组的 `append(_:)` 方法。*Append* 的意思是添加某个元素。使用 `append(_:)`，你可以向数组的末尾添加一个新元素。假设你去了另一个地方，参观了恶地（Badlands），并且你想将其添加到你的国家公园列表中。你可以在
    playground 中加入以下代码：
- en: '![](Image00120.jpg)'
  id: totrans-4127
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00120.jpg)'
- en: To use the append(_:) method, first write the name of your array followed by
    a period and then append . Then, put the item you want to add to your array inside
    the parentheses. In this case, you put "Badlands" inside the parentheses.
  id: totrans-4128
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `append(_:)` 方法时，首先写下数组的名称，后跟一个句点，再接 `append`。然后，把你想添加到数组中的元素放在圆括号内。在这个例子中，你把
    "Badlands" 放在了圆括号内。
- en: 'If you want to add something at a specific place in your array, use the array’s
    insert(_:at:) method instead. This method takes two arguments: the item that you
    want to insert and the index of where it should go in the array. (We’ll discuss
    arguments in more detail in [Chapter 7](text00017.html#ch07) .)'
  id: totrans-4129
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想在数组的特定位置插入某个元素，可以使用数组的 `insert(_:at:)` 方法。该方法接受两个参数：你要插入的项和它在数组中应该插入的位置索引。（我们将在[第7章](text00017.html#ch07)中更详细地讨论参数。）
- en: 'Let’s say you totally forgot that you went to the Petrified Forest right after
    you visited the Grand Canyon, and you want to update your nationalParks array
    so it displays the parks in the order in which you visited them. To update your
    array, you could use the insert(_:at:) method to put the Petrified Forest in the
    right position:'
  id: totrans-4130
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你完全忘记了自己在参观大峡谷后去过化石森林，并且你想更新你的 `nationalParks` 数组，以便按照你访问这些公园的顺序显示它们。要更新数组，你可以使用
    `insert(_:at:)` 方法将化石森林放到正确的位置：
- en: '![](Image00121.jpg)'
  id: totrans-4131
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00121.jpg)'
- en: When you insert a new item at index 3, everything that was in the array at index
    3 or higher gets scooted over to make room for the new item. That means the item
    that was at index 3 is now at index 4, the item that was at index 4 is now at
    index 5, and so on. After you add the Petrified Forest, nationalParks is now ["Acadia",
    "Zion", "Grand Canyon", "Petrified Forest", "Badlands"] .
  id: totrans-4132
  prefs: []
  type: TYPE_NORMAL
  zh: 当你在索引 3 处插入一个新元素时，数组中从索引 3 或更大的位置的所有元素都会被推移，腾出位置给新元素。也就是说，原本在索引 3 处的元素现在位于索引
    4，原本在索引 4 处的元素现在位于索引 5，依此类推。添加化石森林后，`nationalParks` 数组现在是 `["Acadia", "Zion",
    "Grand Canyon", "Petrified Forest", "Badlands"]`。
- en: '**COMBINING ARRAYS**'
  id: totrans-4133
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**合并数组**'
- en: 'Not only can you add new items to an array, but you can also add two arrays
    together using the + and += operators. Let’s say that you have the ingredients
    for a fruit smoothie in two arrays:'
  id: totrans-4134
  prefs: []
  type: TYPE_NORMAL
  zh: 你不仅可以向数组中添加新项，还可以使用 `+` 和 `+=` 操作符将两个数组合并在一起。假设你有两个数组，分别包含制作水果果昔的配料：
- en: '![](Image00122.jpg)'
  id: totrans-4135
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00122.jpg)'
- en: Now you can make a delicious smoothie by adding the fruits and liquids arrays.
  id: totrans-4136
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你可以通过添加水果和液体数组来制作一杯美味的果昔。
- en: '![](Image00123.jpg)'
  id: totrans-4137
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00123.jpg)'
- en: The order of the ingredients in smoothie is the same as the order in fruits
    and liquids . If you created smoothie with liquids + fruits , then the liquids
    would come first.
  id: totrans-4138
  prefs: []
  type: TYPE_NORMAL
  zh: 果昔的配料顺序与水果和液体的顺序相同。如果你先放液体再放水果，那么液体就会排在前面。
- en: 'You use the += operator to add an array to the end of your array. Add some
    whipped cream as follows for extra yumminess:'
  id: totrans-4139
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用 `+=` 操作符将一个数组添加到另一个数组的末尾。为了增加一些额外的美味，可以按照如下方式加入一些奶油：
- en: '![](Image00124.jpg)'
  id: totrans-4140
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00124.jpg)'
- en: Note that ["whipped cream"] is an array even though it has a single item in
    it. When you’re using += to append something to an array, you have to make sure
    you’re only trying to add another array. If you were to just write the string
    "whipped cream" without the square brackets around it, you would get an error.
  id: totrans-4141
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，["whipped cream"] 是一个数组，尽管它只包含一个元素。当你使用 += 将元素附加到数组时，必须确保你只添加另一个数组。如果你只是写了字符串
    "whipped cream" 而没有用方括号括起来，你会得到一个错误。
- en: '![Image](Image00125.jpg)'
  id: totrans-4142
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00125.jpg)'
- en: '**REMOVING ITEMS FROM AN ARRAY**'
  id: totrans-4143
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**从数组中移除元素**'
- en: 'There are several methods for removing items from an array. Let’s start by
    looking at the array’s removeLast() method. As you might have guessed from its
    name, removeLast() removes the last item from your array. Let’s try it out with
    a shoppingList array:'
  id: totrans-4144
  prefs: []
  type: TYPE_NORMAL
  zh: 有多种方法可以从数组中移除元素。让我们从查看数组的 removeLast() 方法开始。正如你从其名称中可能猜到的那样，removeLast() 会移除数组中的最后一个元素。我们用一个
    shoppingList 数组来试试看：
- en: '![](Image00126.jpg)'
  id: totrans-4145
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00126.jpg)'
- en: Neat! Note that the removeLast() method returns the removed item, so you can
    store it in a new constant or variable if you want.
  id: totrans-4146
  prefs: []
  type: TYPE_NORMAL
  zh: 很棒！注意，removeLast() 方法会返回被移除的元素，因此如果你想，你可以将它存储到一个新的常量或变量中。
- en: 'You can also remove an item from a specific index by using the remove(at:)
    method. Let’s say that your mom doesn’t want you buying any candy and takes that
    off the list:'
  id: totrans-4147
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以通过使用 remove(at:) 方法从特定索引移除一个元素。假设你妈妈不希望你买糖果，于是把它从购物清单上删掉：
- en: '![Image](Image00127.jpg)![](Image00128.jpg)'
  id: totrans-4148
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00127.jpg)![](Image00128.jpg)'
- en: Just like when we added an item to the middle of our array and all the items
    scooted over to make room, if you remove an item from the middle of an array,
    the rest of the items will scoot back to fill in that empty space. The "apples"
    item that was at index 3 is now at index 2, where "candy" was.
  id: totrans-4149
  prefs: []
  type: TYPE_NORMAL
  zh: 就像我们向数组中间添加元素时，所有其他元素都向后移动腾出空间一样，如果你从数组的中间移除一个元素，剩余的元素会向前移动，填补空白。原来在索引 3 位置的“apples”现在在索引
    2 位置，原来是“candy”所在的位置。
- en: 'You can also remove all items from an array with removeAll() . Try entering
    this into your playground:'
  id: totrans-4150
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以使用 removeAll() 来移除数组中的所有元素。尝试在你的 playground 中输入以下内容：
- en: '![](Image00129.jpg)'
  id: totrans-4151
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00129.jpg)'
- en: 'Note that trying to remove an item at an index that doesn’t exist will give
    you an error:'
  id: totrans-4152
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，尝试移除一个不存在的索引位置的元素会导致错误：
- en: '![](Image00130.jpg)'
  id: totrans-4153
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00130.jpg)'
- en: Our array doesn’t have this many items (in fact, now it’s empty!), so this throws
    an error. We’ll also get an error if we use removeLast() on our empty array, because
    there’s nothing in it—there’s no last index at all! However, removeAll() is always
    safe to use, even on an empty array.
  id: totrans-4154
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的数组没有这么多项（实际上，现在它是空的！），所以会抛出一个错误。如果我们在空数组上使用removeLast()，也会得到错误，因为数组中没有任何元素——根本没有最后一个索引！然而，removeAll()
    方法总是可以安全使用，即使是在空数组上。
- en: '**REPLACING ITEMS IN AN ARRAY**'
  id: totrans-4155
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**替换数组中的元素**'
- en: 'To replace an item in an array, you set the index of the array to the new value,
    as shown here:'
  id: totrans-4156
  prefs: []
  type: TYPE_NORMAL
  zh: 要替换数组中的元素，你只需将数组的索引设置为新的值，如下所示：
- en: '![](Image00131.jpg)'
  id: totrans-4157
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00131.jpg)'
- en: At ➊ , we replaced the item at index 2 (the third item) with "Unicorn" because
    magical animals count as favorite animals, too! At ➋ , we replaced the item at
    index 0 (the first item) with "Bearded dragon" . No, that’s not a real dragon—it’s
    just a lizard!
  id: totrans-4158
  prefs: []
  type: TYPE_NORMAL
  zh: 在 ➊ 处，我们将索引 2（第三个元素）的位置替换为“Unicorn”，因为魔法动物也是最喜欢的动物！在 ➋ 处，我们将索引 0（第一个元素）的位置替换为“Bearded
    dragon”。不，这不是一条真正的龙——它只是一个蜥蜴！
- en: Like any time you’re working with array index numbers, you have to be sure an
    item exists in the array at that index before you change its value, or you will
    get an Index out of range error.
  id: totrans-4159
  prefs: []
  type: TYPE_NORMAL
  zh: 就像每次处理数组索引时一样，在更改某个元素的值之前，必须确保该索引处的元素存在，否则你会遇到“索引超出范围”的错误。
- en: '[Figure 6-3](text00016.html#ch06fig3) shows the error that occurs if you try
    to add "Standard poodle" using favoriteAnimals[3] = "Standard poodle" . To add
    an item to the end of an array, you should use the append(_:) method or += , as
    we covered in “[Adding Items to an Array](text00016.html#ch06lev2sec5) ” on [page
    70](text00016.html#page_70) .'
  id: totrans-4160
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 6-3](text00016.html#ch06fig3) 显示了如果你尝试使用 favoriteAnimals[3] = "Standard
    poodle" 添加“标准贵宾犬”时发生的错误。要将一个元素添加到数组的末尾，你应该使用 append(_:) 方法或 +=，正如我们在 “[向数组添加元素](text00016.html#ch06lev2sec5)”
    中讲解的那样，见 [第 70 页](text00016.html#page_70)。'
- en: '![Image](Image00132.jpg)'
  id: totrans-4161
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00132.jpg)'
- en: '*Figure 6-3: Don’t try to replace a value at an index beyond the existing array.*'
  id: totrans-4162
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 6-3：不要尝试在超出现有数组的索引范围内替换值。*'
- en: Now you know how to change arrays however you might need to. You can add items,
    take items away, or replace items. Next, we’ll look at how to use the properties
    of arrays to find out even more information about them.
  id: totrans-4163
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你知道如何根据需要更改数组了。你可以添加项目、删除项目或替换项目。接下来，我们将查看如何使用数组的属性来获取更多有关它们的信息。
- en: '![Image](Image00133.jpg)'
  id: totrans-4164
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Image00133.jpg)'
- en: '**USING ARRAY PROPERTIES**'
  id: totrans-4165
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**使用数组属性**'
- en: In addition to methods like append(_:) and removeLast() , arrays also have *properties*
    . An array’s properties are variables or constants that contain some information
    about the array. Two really helpful properties that you might use are the Boolean
    property isEmpty and the integer property count .
  id: totrans-4166
  prefs: []
  type: TYPE_NORMAL
  zh: 除了像 append(_:) 和 removeLast() 这样的函数，数组还有 *属性* 。数组的属性是包含有关数组的一些信息的变量或常量。你可能会用到的两个非常有用的属性是布尔属性
    isEmpty 和整数属性 count。
- en: The isEmpty property is true or false depending on whether the array is empty,
    and the count property will tell you how many items are in that array.
  id: totrans-4167
  prefs: []
  type: TYPE_NORMAL
  zh: isEmpty 属性根据数组是否为空返回 true 或 false，而 count 属性将告诉你数组中有多少项。
- en: 'Check out how these two properties are used in the following if-else statement:'
  id: totrans-4168
  prefs: []
  type: TYPE_NORMAL
  zh: 看一下以下 if-else 语句中这两个属性是如何使用的：
- en: '![Image](Image00134.jpg)'
  id: totrans-4169
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Image00134.jpg)'
- en: 'This if-else statement checks whether the array mySiblings is empty ➊ . If
    it is, then "I don''t have any siblings." is printed. But if there is something
    in the array, then the number of siblings that we have is printed: "I have 3 siblings."
    ➋ .'
  id: totrans-4170
  prefs: []
  type: TYPE_NORMAL
  zh: 这个 if-else 语句检查数组 mySiblings 是否为空 ➊ 。如果为空，则打印“我没有兄弟姐妹。”如果数组中有内容，则打印我们有多少个兄弟姐妹：“我有
    3 个兄弟姐妹。” ➋ 。
- en: '**LOOPING OVER AN ARRAY**'
  id: totrans-4171
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**循环遍历数组**'
- en: 'Sometimes when you’re working with arrays you might want to do something to
    every item in the array. You can use a for-in loop to do that! The following code
    will print every topping in a pizzaToppings array on a separate line:'
  id: totrans-4172
  prefs: []
  type: TYPE_NORMAL
  zh: 有时在处理数组时，你可能想对数组中的每个项执行某些操作。你可以使用 for-in 循环来做到这一点！以下代码将在单独的行上打印出 pizzaToppings
    数组中的每个配料：
- en: '![Image](Image00135.jpg)'
  id: totrans-4173
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Image00135.jpg)'
- en: To write a for-in loop for the pizzaToppings array, we used the keyword for
    , followed by the constant topping , then the keyword in , and finally the name
    of our array, pizzaToppings . Then we put the statements that we want to run for
    each topping inside the braces of the for-in loop. The constant topping ➊ temporarily
    represents each pizza topping in the array as we loop through it. We could have
    chosen any name for this constant, but it’s a good idea to pick something that
    makes sense. You can see the output of this for-in loop in [Figure 6-4](text00016.html#ch06fig4)
    .
  id: totrans-4174
  prefs: []
  type: TYPE_NORMAL
  zh: 要为 pizzaToppings 数组编写 for-in 循环，我们使用关键字 for ，接着是常量 topping ，然后是关键字 in ，最后是我们的数组名称
    pizzaToppings 。然后，我们将每个 topping 的处理语句放在 for-in 循环的花括号中。常量 topping ➊ 在我们遍历数组时临时表示数组中的每个披萨配料。我们本可以选择任何名称来作为这个常量，但最好选择一个有意义的名字。你可以在[图
    6-4](text00016.html#ch06fig4)中看到这个 for-in 循环的输出。
- en: '![Image](Image00136.jpg)'
  id: totrans-4175
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Image00136.jpg)'
- en: '*Figure 6-4: Output of the example for-in loop*'
  id: totrans-4176
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 6-4：示例 for-in 循环的输出*'
- en: '![Image](Image00137.jpg)'
  id: totrans-4177
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Image00137.jpg)'
- en: 'Using for-in loops is great for printing every value in an array. If you’re
    working with numbers, you can even use them to perform math operations on each
    item, which makes for some speedy calculations! The following code takes an array
    of numbers and calculates the square for each (the square of a number is that
    number multiplied by itself):'
  id: totrans-4178
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 for-in 循环非常适合打印数组中的每个值。如果你正在处理数字，你甚至可以用它们对每个项目执行数学运算，这样就能进行快速的计算！以下代码获取一个数字数组，并计算每个数字的平方（数字的平方是该数字与自身相乘）：
- en: '![Image](Image00138.jpg)'
  id: totrans-4179
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Image00138.jpg)'
- en: '[Figure 6-5](text00016.html#ch06fig5) shows the results.'
  id: totrans-4180
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 6-5](text00016.html#ch06fig5) 显示了结果。'
- en: '![Image](Image00139.jpg)'
  id: totrans-4181
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Image00139.jpg)'
- en: '*Figure 6-5: Printing the squares for each number in the myNumbers array*'
  id: totrans-4182
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 6-5：打印 myNumbers 数组中每个数字的平方*'
- en: '**DICTIONARIES ARE KEY!**'
  id: totrans-4183
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**字典是关键！**'
- en: A *dictionary* is also a collection of values, but instead of an ordered index,
    each value has its own *key* . Because there’s no index, the values are not stored
    in any particular order. To access values in a dictionary, you look them up by
    their key.
  id: totrans-4184
  prefs: []
  type: TYPE_NORMAL
  zh: '*字典* 也是一种值的集合，但与有序索引不同，每个值都有自己的 *键* 。因为没有索引，所以值的存储顺序不固定。要访问字典中的值，你需要通过其键来查找。'
- en: A key must be unique. You can’t have the same key more than once in the same
    dictionary. If there were two identical keys and you asked the computer to give
    you the value for one of them, the computer wouldn’t know which one to choose!
  id: totrans-4185
  prefs: []
  type: TYPE_NORMAL
  zh: 键必须是唯一的。你不能在同一个字典中重复使用相同的键。如果有两个相同的键，并且你请求计算机返回其中一个键的值，计算机就无法知道该选择哪一个！
- en: Let’s take a look at how to make a dictionary and write keys that will help
    you find all the information you need.
  id: totrans-4186
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如何创建字典，并编写键来帮助你找到所需的所有信息。
- en: '![Image](Image00140.jpg)'
  id: totrans-4187
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00140.jpg)'
- en: '**INITIALIZING A DICTIONARY**'
  id: totrans-4188
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**初始化字典**'
- en: 'To create and initialize a dictionary, first write var and the name of your
    dictionary. Then write the keys and corresponding values inside a pair of square
    brackets, similar to an array. Let’s create a dictionary to store the names of
    a few US states. The key for each state will be its two-letter abbreviation:'
  id: totrans-4189
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建并初始化一个字典，首先写上`var`和字典的名称。然后将键和值对写在一对方括号中，类似于数组。让我们创建一个字典来存储一些美国州的名称。每个州的键将是它的两位字母缩写：
- en: '![](Image00141.jpg)'
  id: totrans-4190
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00141.jpg)'
- en: As you can see, there’s a colon between each key and its value, and the key/value
    pairs are separated by commas.
  id: totrans-4191
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，每个键和值之间有一个冒号，键值对之间用逗号分隔。
- en: Dictionaries are different from arrays in that they are *unordered* . Because
    of that, it’s likely that the order of the states that you see in your results
    pane ➋ is different from the order in which you entered your states ➊ . It might
    even be different than the order that’s printed in this book!
  id: totrans-4192
  prefs: []
  type: TYPE_NORMAL
  zh: 字典与数组的不同之处在于，它们是*无序的*。因此，你在结果面板 ➋ 中看到的状态顺序可能与输入状态 ➊ 的顺序不同，甚至可能与书中打印的顺序不同！
- en: As with arrays, you can use var to make a mutable dictionary or use let to make
    an immutable dictionary.
  id: totrans-4193
  prefs: []
  type: TYPE_NORMAL
  zh: 与数组一样，你可以使用`var`来创建一个可变字典，或者使用`let`来创建一个不可变字典。
- en: 'In Swift, all of the keys of a dictionary must be the same type, and all of
    the values of a dictionary must also be the same type, but the key type doesn’t
    have to match the value type. For example, if you wanted to store a collection
    of fractions, you could use doubles for the keys and strings for the values:'
  id: totrans-4194
  prefs: []
  type: TYPE_NORMAL
  zh: 在Swift中，字典的所有键必须是相同的类型，字典的所有值也必须是相同的类型，但键的类型不必与值的类型匹配。例如，如果你想存储一个分数集合，你可以使用双精度浮点数作为键，字符串作为值：
- en: '![](Image00142.jpg)'
  id: totrans-4195
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00142.jpg)'
- en: In this dictionary, all of the keys must be doubles, and all of the values must
    be strings. Again, you’ll see that the order of the numbers in the results pane
    can be quite different from the order in which you wrote the fractions in your
    dictionary. This is fine because you don’t need to know the order to access anything.
    You can find any item that you need by its key. Let’s see how!
  id: totrans-4196
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个字典中，所有的键必须是双精度浮点数类型，所有的值必须是字符串类型。同样，你会发现结果面板中的数字顺序可能与你在字典中写入分数的顺序有很大不同。这没关系，因为你不需要知道顺序就能访问任何内容。你可以通过键找到你需要的任何项。让我们来看看如何做到这一点！
- en: '**ACCESSING VALUES IN A DICTIONARY**'
  id: totrans-4197
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**访问字典中的值**'
- en: 'Looking up a value in a dictionary is similar to how you access a value in
    an array except that you use a key inside the square brackets instead of an index,
    like this: usStates["TX"] .'
  id: totrans-4198
  prefs: []
  type: TYPE_NORMAL
  zh: 在字典中查找值的方式与访问数组中的值类似，只是你使用的是方括号中的键而不是索引，例如：usStates["TX"]。
- en: There is a big difference, however, in how Swift returns the values from a dictionary.
    When you access a value at an index of an array, you are simply given the value.
    When you access a value with a key in a dictionary, you are given an optional.
  id: totrans-4199
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，Swift返回字典值的方式有很大不同。当你访问数组中的某个索引的值时，你会直接获得该值。而当你用字典中的键访问某个值时，你会得到一个可选类型的值。
- en: In [Chapter 5](text00015.html#ch05) , you learned that optionals might contain
    a value or might be nil . The reason Swift returns optionals when you’re looking
    up items in a dictionary is that the key you used might not exist in the dictionary,
    in which case there’s no value to access. Trying to access a value that doesn’t
    exist would give you a big fat error! To avoid that problem, Swift returns optionals.
    That means you need to unwrap any value you get out of a dictionary before you
    can do anything with it.
  id: totrans-4200
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第5章](text00015.html#ch05)中，你学到了可选值可能包含一个值，也可能是nil。Swift在查找字典中的项目时返回可选值的原因是，你使用的键可能在字典中不存在，在这种情况下，就没有值可以访问。试图访问一个不存在的值会导致一个大的错误！为了避免这个问题，Swift返回可选值。这意味着你在对字典中的值做任何操作之前，需要解包（unwrap）它。
- en: 'To unwrap an optional, first you check whether it exists using an if-let statement,
    just like we did in [Chapter 5](text00015.html#ch05) . The following code shows
    you how to get a value out of a dictionary:'
  id: totrans-4201
  prefs: []
  type: TYPE_NORMAL
  zh: 要解包一个可选值，首先你使用 if-let 语句检查它是否存在，就像我们在[第5章](text00015.html#ch05)中所做的那样。以下代码展示了如何从字典中获取一个值：
- en: '![Image](Image00143.jpg)'
  id: totrans-4202
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Image00143.jpg)'
- en: To retrieve "Texas" from the dictionary, we use if let to set a constant loneStarState
    to usStates["TX"] ➊ . Because we have this state in our dictionary, the line I
    have Texas in my dictionary. is printed. Next we try to access a state that is
    not in our dictionary by using the key usStates["FL"] ➋ . Thankfully, because
    we used an if-let statement, the program won’t crash when the computer can’t find
    this state. Instead, I don't have that state in my dictionary. is printed.
  id: totrans-4203
  prefs: []
  type: TYPE_NORMAL
  zh: 要从字典中检索 "Texas"，我们使用 if let 将常量 loneStarState 设置为 usStates["TX"] ➊。因为我们在字典中有这个州，所以会打印出
    "I have Texas in my dictionary." 接着，我们尝试通过键 usStates["FL"] ➋ 访问一个不在字典中的州。幸运的是，由于我们使用了
    if-let 语句，当计算机无法找到这个州时，程序不会崩溃，而是会打印出 "I don't have that state in my dictionary."。
- en: '**ADDING ITEMS TO A DICTIONARY**'
  id: totrans-4204
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**向字典中添加项**'
- en: 'To add an item to a dictionary, first write the name of your dictionary and
    assign the new item to the key you want it to have in the dictionary. Let’s add
    "Minnesota" to our usStates dictionary:'
  id: totrans-4205
  prefs: []
  type: TYPE_NORMAL
  zh: 要向字典添加项，首先写出字典的名称，并将新项分配给你希望它拥有的键。我们来向 usStates 字典添加 "Minnesota"：
- en: '![](Image00144.jpg)'
  id: totrans-4206
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00144.jpg)'
- en: 'Now when you look at usStates , you’ll see that it’s updated to ["MN": "Minnesota",
    "WA": "Washington", "MA": "Massachusetts", "TX": "Texas"] . Remember, because
    you don’t have to rely on indices, your new dictionary item might appear anywhere
    in the dictionary.'
  id: totrans-4207
  prefs: []
  type: TYPE_NORMAL
  zh: '现在，当你查看 usStates 时，你会看到它已经更新为 ["MN": "Minnesota", "WA": "Washington", "MA":
    "Massachusetts", "TX": "Texas"]。记住，由于你不需要依赖索引，所以新的字典项可能出现在字典中的任何位置。'
- en: '**REMOVING ITEMS FROM A DICTIONARY**'
  id: totrans-4208
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**从字典中移除项**'
- en: Removing an item from a dictionary is quite simple; you do so by setting the
    value to nil . Because the values in dictionaries are returned as optionals, you
    don’t have to worry about nil causing any problems in your dictionary.
  id: totrans-4209
  prefs: []
  type: TYPE_NORMAL
  zh: 从字典中移除项非常简单；你只需要将值设置为 nil。由于字典中的值是作为可选值返回的，因此你不必担心 nil 会在字典中引起任何问题。
- en: '![](Image00145.jpg)'
  id: totrans-4210
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00145.jpg)'
- en: 'You can see that after you remove the value at the key "MA" , usStates is updated
    to ["MN": "Minnesota", "WA": "Washington", "TX": "Texas"] . Remember that nil
    is special and means that there’s no value at all. That’s why you don’t see "MA":
    nil in our dictionary.'
  id: totrans-4211
  prefs: []
  type: TYPE_NORMAL
  zh: '你可以看到，在移除键 "MA" 对应的值后，usStates 被更新为 ["MN": "Minnesota", "WA": "Washington",
    "TX": "Texas"]。记住，nil 是特殊的，表示没有任何值。这就是为什么你在字典中看不到 "MA": nil。'
- en: '**REPLACING ITEMS IN A DICTIONARY**'
  id: totrans-4212
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**替换字典中的项**'
- en: 'Replacing an item in a dictionary is also easy. It works the same was as replacing
    an item in an array. You just set the item that you want to replace to something
    else. Say you create a dictionary of fruit colors:'
  id: totrans-4213
  prefs: []
  type: TYPE_NORMAL
  zh: 替换字典中的项也很简单。它与替换数组中的项的方式一样。你只需将要替换的项设置为其他内容。假设你创建了一个关于水果颜色的字典：
- en: '![](Image00146.jpg)'
  id: totrans-4214
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00146.jpg)'
- en: At first we had the value "apple" for "red" , but then we decided that "raspberry"
    is a better fruit to use since sometimes apples are green or yellow. To replace
    "apple" with "raspberry" , we set colorFruits["red"] to its new value ➊ .
  id: totrans-4215
  prefs: []
  type: TYPE_NORMAL
  zh: 起初我们为 "red" 设置了值 "apple"，但后来我们决定 "raspberry" 更适合，因为有时苹果是绿色或黄色的。为了用 "raspberry"
    替换 "apple"，我们将 colorFruits["red"] 设置为它的新值 ➊。
- en: You may remember that this is the same way we entered a new value into a dictionary.
    If the key already exists in the dictionary, then the value for that key is replaced.
    If the key doesn’t already exist, then the new key/value pair will be added to
    the dictionary.
  id: totrans-4216
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能还记得，这正是我们将新值输入字典的方式。如果键已经存在于字典中，那么该键的值会被替换。如果键不存在，则新的键值对将被添加到字典中。
- en: '![Image](Image00147.jpg)'
  id: totrans-4217
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Image00147.jpg)'
- en: '**USING DICTIONARY PROPERTIES**'
  id: totrans-4218
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**使用字典属性**'
- en: 'Like an array, a dictionary also has an isEmpty property and a count property.
    For example, the following code shows how you can use the isEmpty property to
    check if a dictionary is empty, and if it isn’t empty, the count property checks
    how many items you have. Imagine you have a basket of fruit for sale. You can
    use these properties to help you keep track of everything:'
  id: totrans-4219
  prefs: []
  type: TYPE_NORMAL
  zh: 和数组一样，字典也有一个 isEmpty 属性和一个 count 属性。例如，以下代码展示了如何使用 isEmpty 属性来检查字典是否为空，如果不为空，则使用
    count 属性检查字典中有多少项。假设你有一个待售的水果篮子，你可以使用这些属性帮助你记录所有物品：
- en: '![Image](Image00148.jpg)'
  id: totrans-4220
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Image00148.jpg)'
- en: 'A dictionary also has two special properties: keys , which contains all of
    the dictionary’s keys, and values , which contains all of its values. We’ll use
    these two properties when we loop through the dictionary.'
  id: totrans-4221
  prefs: []
  type: TYPE_NORMAL
  zh: 字典还有两个特殊的属性：`keys`，它包含字典的所有键，以及`values`，它包含所有的值。当我们遍历字典时，我们会使用这两个属性。
- en: Let’s write some code that loops through our fruit baskets and prints the price
    of each fruit.
  id: totrans-4222
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们写一些代码，遍历我们的水果篮并打印每个水果的价格。
- en: '**LOOPING OVER A DICTIONARY**'
  id: totrans-4223
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**遍历字典**'
- en: 'You can loop through a dictionary using a for-in loop. Because each item has
    a key and a value, you can do this in two different ways. This is how to loop
    through a dictionary using its keys:'
  id: totrans-4224
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用 `for-in` 循环遍历字典。由于每个项目都有一个键和值，你可以用两种不同的方式来做这件事。这是通过字典的键来遍历字典的方法：
- en: '![Image](Image00149.jpg)'
  id: totrans-4225
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Image00149.jpg)'
- en: Here we use the dictionary’s keys property ➊ to loop through fruitBasket and
    print its contents. We start by writing the keyword for , followed by a constant
    name fruit for the dictionary key, the keyword in , the dictionary name, a period,
    and keys .
  id: totrans-4226
  prefs: []
  type: TYPE_NORMAL
  zh: 这里我们使用字典的`keys`属性 ➊ 来遍历 `fruitBasket` 并打印其内容。我们首先写出`for`关键字，接着写出常量名 `fruit`
    作为字典键，然后是`in`关键字，字典名，接着一个句点和 `keys`。
- en: Inside the braces of our for-in loop, we have access to both the key, which
    we call fruit ➋ , and the value at that key when we force-unwrap its contents
    with fruitBasket[fruit]! ➌ . That value will be the fruit’s price.
  id: totrans-4227
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `for-in` 循环的大括号内，我们可以访问到键（我们称之为 `fruit` ➋），并通过 `fruitBasket[fruit]!` 强制解包它的内容，获取该键对应的值
    ➌。该值将是水果的价格。
- en: In this case, it’s safe to force-unwrap the value using an exclamation point
    because we know that the fruit key we’re using is definitely inside the dictionary.
  id: totrans-4228
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，使用感叹号强制解包值是安全的，因为我们知道我们正在使用的 `fruit` 键肯定存在于字典中。
- en: Any code we put inside the for-in loop will run once for every key in our dictionary.
    So you should see the print statement display three times.
  id: totrans-4229
  prefs: []
  type: TYPE_NORMAL
  zh: 我们放在 `for-in` 循环内部的任何代码都会针对字典中的每个键执行一次。因此，你应该会看到打印语句显示三次。
- en: 'We can also loop through the dictionary using its values property:'
  id: totrans-4230
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以使用字典的 `values` 属性来遍历字典：
- en: '![Image](Image00150.jpg)'
  id: totrans-4231
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Image00150.jpg)'
- en: We use the same style of for-in loop, but now we use a constant to refer to
    each value, which we call price , in the values property. When looping through
    values, we don’t have access to the keys from inside the loop.
  id: totrans-4232
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用相同的 `for-in` 循环样式，但现在我们使用一个常量来引用 `values` 属性中的每个值，我们称之为 `price`。在遍历值时，我们无法从循环内部访问键。
- en: Another difference to note is that price is not an optional because it’s accessed
    directly as a value in the fruitBasket dictionary. That means we don’t have to
    unwrap it. You should still see the print statement printed three times. [Figure
    6-6](text00016.html#ch06fig6) shows the output of both loops.
  id: totrans-4233
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个需要注意的区别是，`price` 不是一个可选值，因为它是通过直接访问水果篮字典中的值来获取的。这意味着我们不需要解包它。你仍然会看到打印语句打印三次。[图
    6-6](text00016.html#ch06fig6) 显示了两个循环的输出。
- en: '![Image](Image00151.jpg)'
  id: totrans-4234
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Image00151.jpg)'
- en: '*Figure 6-6: Looping through the keys and values of a dictionary with a for-in
    loop*'
  id: totrans-4235
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 6-6：使用 `for-in` 循环遍历字典的键和值*'
- en: The order of your results might be slightly different from ours. That’s because
    the items in a dictionary aren’t in a numbered order like they are in an array!
    And because the order is not guaranteed, you might see a different order printed
    if you run the same code again.
  id: totrans-4236
  prefs: []
  type: TYPE_NORMAL
  zh: 你的结果顺序可能与我们的略有不同。这是因为字典中的项目不像数组中的项目那样按数字顺序排列！并且由于顺序不保证，如果你再次运行相同的代码，你可能会看到不同的顺序。
- en: '**WHAT YOU LEARNED**'
  id: totrans-4237
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**你学到了什么**'
- en: In this chapter, you learned how to store collections of items in an array and
    in a dictionary. To store items in an ordered list, you would use an array and
    look up each item by its index. If you wanted to store items by key instead, you
    would use a dictionary.
  id: totrans-4238
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你学习了如何将项目集合存储在数组和字典中。为了将项目存储在有序列表中，你将使用数组并通过索引查找每个项目。如果你想根据键存储项目，你则需要使用字典。
- en: Knowing about arrays and dictionaries and how to use them is a powerful building
    block for almost any programming language. Next we will learn about functions,
    another very powerful tool. Functions are blocks of code that you create and name
    to perform a specific job. After you have written a function, you can use its
    name to call it from almost anywhere in your program.
  id: totrans-4239
  prefs: []
  type: TYPE_NORMAL
  zh: 了解数组和字典，以及如何使用它们，是几乎所有编程语言中一个非常强大的基础。接下来，我们将学习函数，这是另一种非常强大的工具。函数是你创建并命名的代码块，用于执行特定的任务。编写完函数后，你可以通过函数的名字在程序中的几乎任何地方调用它。
- en: '**ADDING ITEMS TO AN ARRAY**'
  id: totrans-4240
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**向数组添加项**'
- en: One way to change an array is to add new items to it. There are a few different
    ways to do this, so let’s take a look at each.
  id: totrans-4241
  prefs: []
  type: TYPE_NORMAL
  zh: 更改数组的一种方式是向其中添加新项。这里有几种不同的方法，我们来看一下每种方法。
- en: 'First, you can use an array’s append(_:) method. *Append* means to add something.
    Using append(_:) , you can add one new item to the end of your array. Say you
    go on another trip and visit the Badlands, and you want to add it to your list
    of national parks. To do that, add this code into your playground:'
  id: totrans-4242
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，你可以使用数组的append(_:)方法。*Append*意味着添加某些内容。使用append(_:)方法，你可以将一个新项目添加到数组的末尾。假设你去了一趟新的旅行，参观了恶地国家公园，并且你想将其添加到你的国家公园列表中。为此，您可以将以下代码添加到你的
    playground 中：
- en: '![](Image00120.jpg)'
  id: totrans-4243
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00120.jpg)'
- en: To use the append(_:) method, first write the name of your array followed by
    a period and then append . Then, put the item you want to add to your array inside
    the parentheses. In this case, you put "Badlands" inside the parentheses.
  id: totrans-4244
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用append(_:)方法，首先写下你的数组名称，后面加一个句点，然后是append。接着，将你想要添加到数组中的项目放到括号里。在这种情况下，你将"Badlands"放到括号中。
- en: 'If you want to add something at a specific place in your array, use the array’s
    insert(_:at:) method instead. This method takes two arguments: the item that you
    want to insert and the index of where it should go in the array. (We’ll discuss
    arguments in more detail in [Chapter 7](text00017.html#ch07) .)'
  id: totrans-4245
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想在数组的特定位置添加某些内容，请改用数组的insert(_:at:)方法。这个方法接受两个参数：你要插入的项目和它应该放置在数组中的索引位置。（我们将在[第7章](text00017.html#ch07)中更详细地讨论参数。）
- en: 'Let’s say you totally forgot that you went to the Petrified Forest right after
    you visited the Grand Canyon, and you want to update your nationalParks array
    so it displays the parks in the order in which you visited them. To update your
    array, you could use the insert(_:at:) method to put the Petrified Forest in the
    right position:'
  id: totrans-4246
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你完全忘记了你在参观大峡谷后去了化石林，并且你想更新你的nationalParks数组，以便按你访问的顺序显示公园。为了更新数组，你可以使用insert(_:at:)方法，将化石林放到正确的位置：
- en: '![](Image00121.jpg)'
  id: totrans-4247
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00121.jpg)'
- en: When you insert a new item at index 3, everything that was in the array at index
    3 or higher gets scooted over to make room for the new item. That means the item
    that was at index 3 is now at index 4, the item that was at index 4 is now at
    index 5, and so on. After you add the Petrified Forest, nationalParks is now ["Acadia",
    "Zion", "Grand Canyon", "Petrified Forest", "Badlands"] .
  id: totrans-4248
  prefs: []
  type: TYPE_NORMAL
  zh: 当你在索引3处插入一个新项目时，数组中索引为3或更高的所有项目都会向后移动，以为新项目腾出空间。这意味着原本在索引3处的项目现在位于索引4，原本在索引4处的项目现在位于索引5，依此类推。添加化石林后，nationalParks数组现在是["Acadia",
    "Zion", "Grand Canyon", "Petrified Forest", "Badlands"]。
- en: '**COMBINING ARRAYS**'
  id: totrans-4249
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**合并数组**'
- en: 'Not only can you add new items to an array, but you can also add two arrays
    together using the + and += operators. Let’s say that you have the ingredients
    for a fruit smoothie in two arrays:'
  id: totrans-4250
  prefs: []
  type: TYPE_NORMAL
  zh: 你不仅可以向数组中添加新项，还可以使用+和+=运算符将两个数组合并。假设你有两个数组，分别包含水果冰沙的原料：
- en: '![](Image00122.jpg)'
  id: totrans-4251
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00122.jpg)'
- en: Now you can make a delicious smoothie by adding the fruits and liquids arrays.
  id: totrans-4252
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你可以通过将水果和液体数组合并，制作一杯美味的冰沙。
- en: '![](Image00123.jpg)'
  id: totrans-4253
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00123.jpg)'
- en: The order of the ingredients in smoothie is the same as the order in fruits
    and liquids . If you created smoothie with liquids + fruits , then the liquids
    would come first.
  id: totrans-4254
  prefs: []
  type: TYPE_NORMAL
  zh: 冰沙中原料的顺序与水果和液体的顺序相同。如果你用液体+水果的顺序来制作冰沙，那么液体会排在前面。
- en: 'You use the += operator to add an array to the end of your array. Add some
    whipped cream as follows for extra yumminess:'
  id: totrans-4255
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用+=运算符将一个数组添加到另一个数组的末尾。为了增加更多美味，可以添加一些奶油，如下所示：
- en: '![](Image00124.jpg)'
  id: totrans-4256
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00124.jpg)'
- en: Note that ["whipped cream"] is an array even though it has a single item in
    it. When you’re using += to append something to an array, you have to make sure
    you’re only trying to add another array. If you were to just write the string
    "whipped cream" without the square brackets around it, you would get an error.
  id: totrans-4257
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，["鲜奶油"]是一个数组，尽管它只有一个项。当你使用+=向数组添加内容时，必须确保你只是在尝试添加另一个数组。如果你只写字符串"鲜奶油"而没有方括号，程序会报错。
- en: '![Image](Image00125.jpg)'
  id: totrans-4258
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00125.jpg)'
- en: '**REMOVING ITEMS FROM AN ARRAY**'
  id: totrans-4259
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**从数组中删除项**'
- en: 'There are several methods for removing items from an array. Let’s start by
    looking at the array’s removeLast() method. As you might have guessed from its
    name, removeLast() removes the last item from your array. Let’s try it out with
    a shoppingList array:'
  id: totrans-4260
  prefs: []
  type: TYPE_NORMAL
  zh: 删除数组中的项有几种方法。我们首先来看一下数组的removeLast()方法。正如你从名字中可能猜到的，removeLast()会删除数组中的最后一项。让我们用一个shoppingList数组来试试看：
- en: '![](Image00126.jpg)'
  id: totrans-4261
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00126.jpg)'
- en: Neat! Note that the removeLast() method returns the removed item, so you can
    store it in a new constant or variable if you want.
  id: totrans-4262
  prefs: []
  type: TYPE_NORMAL
  zh: 很棒！请注意，removeLast()方法返回被删除的项，因此如果需要，你可以将其存储在一个新的常量或变量中。
- en: 'You can also remove an item from a specific index by using the remove(at:)
    method. Let’s say that your mom doesn’t want you buying any candy and takes that
    off the list:'
  id: totrans-4263
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以通过使用remove(at:)方法从特定的索引位置删除一项。假设你妈妈不让你买糖果，并将它从清单上删除：
- en: '![Image](Image00127.jpg)![](Image00128.jpg)'
  id: totrans-4264
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00127.jpg)![](Image00128.jpg)'
- en: Just like when we added an item to the middle of our array and all the items
    scooted over to make room, if you remove an item from the middle of an array,
    the rest of the items will scoot back to fill in that empty space. The "apples"
    item that was at index 3 is now at index 2, where "candy" was.
  id: totrans-4265
  prefs: []
  type: TYPE_NORMAL
  zh: 就像我们在数组中间添加一个项时，所有其他项都会挪动以腾出空间一样，如果你从数组中间删除一个项，剩余的项会向前挪动以填补那个空位。原本在索引3位置的"苹果"项现在位于索引2位置，原来的"糖果"项已经被移除。
- en: 'You can also remove all items from an array with removeAll() . Try entering
    this into your playground:'
  id: totrans-4266
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以使用removeAll()方法删除数组中的所有项。试着在你的 playground 中输入这个代码：
- en: '![](Image00129.jpg)'
  id: totrans-4267
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00129.jpg)'
- en: 'Note that trying to remove an item at an index that doesn’t exist will give
    you an error:'
  id: totrans-4268
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，尝试删除一个不存在的索引位置的项会导致错误：
- en: '![](Image00130.jpg)'
  id: totrans-4269
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00130.jpg)'
- en: Our array doesn’t have this many items (in fact, now it’s empty!), so this throws
    an error. We’ll also get an error if we use removeLast() on our empty array, because
    there’s nothing in it—there’s no last index at all! However, removeAll() is always
    safe to use, even on an empty array.
  id: totrans-4270
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的数组中没有这么多项（实际上，现在它已经空了！），因此会抛出错误。如果我们在空数组上使用removeLast()，也会报错，因为数组中没有任何项——根本没有最后一个索引！然而，removeAll()方法在空数组上使用时始终是安全的。
- en: '**REPLACING ITEMS IN AN ARRAY**'
  id: totrans-4271
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**替换数组中的项**'
- en: 'To replace an item in an array, you set the index of the array to the new value,
    as shown here:'
  id: totrans-4272
  prefs: []
  type: TYPE_NORMAL
  zh: 要替换数组中的某一项，你可以将数组的索引设置为新的值，如下所示：
- en: '![](Image00131.jpg)'
  id: totrans-4273
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00131.jpg)'
- en: At ➊ , we replaced the item at index 2 (the third item) with "Unicorn" because
    magical animals count as favorite animals, too! At ➋ , we replaced the item at
    index 0 (the first item) with "Bearded dragon" . No, that’s not a real dragon—it’s
    just a lizard!
  id: totrans-4274
  prefs: []
  type: TYPE_NORMAL
  zh: 在➊处，我们将索引2（第三个项）的项替换为"独角兽"，因为神奇的动物也算是最喜欢的动物！在➋处，我们将索引0（第一个项）的项替换为"胡须龙"。不，那不是一条真正的龙——它只是一只蜥蜴！
- en: Like any time you’re working with array index numbers, you have to be sure an
    item exists in the array at that index before you change its value, or you will
    get an Index out of range error.
  id: totrans-4275
  prefs: []
  type: TYPE_NORMAL
  zh: 就像你在操作数组索引时一样，必须确保该索引位置的项确实存在于数组中，否则会出现索引越界的错误。
- en: '[Figure 6-3](text00016.html#ch06fig3) shows the error that occurs if you try
    to add "Standard poodle" using favoriteAnimals[3] = "Standard poodle" . To add
    an item to the end of an array, you should use the append(_:) method or += , as
    we covered in “[Adding Items to an Array](text00016.html#ch06lev2sec5) ” on [page
    70](text00016.html#page_70) .'
  id: totrans-4276
  prefs: []
  type: TYPE_NORMAL
  zh: '[图6-3](text00016.html#ch06fig3)展示了如果你尝试通过favoriteAnimals[3] = "标准贵宾犬"来添加"标准贵宾犬"时会出现的错误。要向数组的末尾添加项，你应该使用append(_:)方法或+=，我们在"[向数组添加项](text00016.html#ch06lev2sec5)"（[第70页](text00016.html#page_70)）中讲解过这个方法。'
- en: '![Image](Image00132.jpg)'
  id: totrans-4277
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00132.jpg)'
- en: '*Figure 6-3: Don’t try to replace a value at an index beyond the existing array.*'
  id: totrans-4278
  prefs: []
  type: TYPE_NORMAL
  zh: '*图6-3：不要尝试在超出现有数组范围的索引位置替换值。*'
- en: Now you know how to change arrays however you might need to. You can add items,
    take items away, or replace items. Next, we’ll look at how to use the properties
    of arrays to find out even more information about them.
  id: totrans-4279
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经知道了如何根据需要修改数组。你可以添加元素、删除元素或替换元素。接下来，我们将看看如何使用数组的属性来获取更多关于数组的信息。
- en: '![Image](Image00133.jpg)'
  id: totrans-4280
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00133.jpg)'
- en: '**USING ARRAY PROPERTIES**'
  id: totrans-4281
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**使用数组属性**'
- en: In addition to methods like append(_:) and removeLast() , arrays also have *properties*
    . An array’s properties are variables or constants that contain some information
    about the array. Two really helpful properties that you might use are the Boolean
    property isEmpty and the integer property count .
  id: totrans-4282
  prefs: []
  type: TYPE_NORMAL
  zh: 除了像append(_:)和removeLast()这样的函数，数组还有*属性*。数组的属性是包含关于数组的一些信息的变量或常量。你可能会用到的两个非常有用的属性是布尔属性isEmpty和整数属性count。
- en: The isEmpty property is true or false depending on whether the array is empty,
    and the count property will tell you how many items are in that array.
  id: totrans-4283
  prefs: []
  type: TYPE_NORMAL
  zh: isEmpty属性的值取决于数组是否为空，返回true或false，而count属性会告诉你该数组中有多少个元素。
- en: 'Check out how these two properties are used in the following if-else statement:'
  id: totrans-4284
  prefs: []
  type: TYPE_NORMAL
  zh: 看看这两个属性是如何在以下的if-else语句中使用的：
- en: '![Image](Image00134.jpg)'
  id: totrans-4285
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00134.jpg)'
- en: 'This if-else statement checks whether the array mySiblings is empty ➊ . If
    it is, then "I don''t have any siblings." is printed. But if there is something
    in the array, then the number of siblings that we have is printed: "I have 3 siblings."
    ➋ .'
  id: totrans-4286
  prefs: []
  type: TYPE_NORMAL
  zh: 这个if-else语句检查数组mySiblings是否为空 ➊。如果为空，则打印“我没有兄弟姐妹。”。但如果数组中有元素，则打印我们有多少个兄弟姐妹：“我有3个兄弟姐妹。”
    ➋。
- en: '**LOOPING OVER AN ARRAY**'
  id: totrans-4287
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**遍历数组**'
- en: 'Sometimes when you’re working with arrays you might want to do something to
    every item in the array. You can use a for-in loop to do that! The following code
    will print every topping in a pizzaToppings array on a separate line:'
  id: totrans-4288
  prefs: []
  type: TYPE_NORMAL
  zh: 有时在处理数组时，你可能想对数组中的每个元素做一些操作。你可以使用for-in循环来完成！以下代码会在单独的一行上打印pizzaToppings数组中的每个配料：
- en: '![Image](Image00135.jpg)'
  id: totrans-4289
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00135.jpg)'
- en: To write a for-in loop for the pizzaToppings array, we used the keyword for
    , followed by the constant topping , then the keyword in , and finally the name
    of our array, pizzaToppings . Then we put the statements that we want to run for
    each topping inside the braces of the for-in loop. The constant topping ➊ temporarily
    represents each pizza topping in the array as we loop through it. We could have
    chosen any name for this constant, but it’s a good idea to pick something that
    makes sense. You can see the output of this for-in loop in [Figure 6-4](text00016.html#ch06fig4)
    .
  id: totrans-4290
  prefs: []
  type: TYPE_NORMAL
  zh: 要为pizzaToppings数组编写for-in循环，我们使用了关键字for，接着是常量topping，然后是关键字in，最后是我们的数组名pizzaToppings。然后我们将希望在每个topping上运行的语句放在for-in循环的括号内。常量topping
    ➊ 在我们循环遍历数组时，临时代表数组中的每个披萨配料。我们本可以为这个常量选择任何名字，但最好选择一个有意义的名称。你可以在[图6-4](text00016.html#ch06fig4)中看到这个for-in循环的输出。
- en: '![Image](Image00136.jpg)'
  id: totrans-4291
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00136.jpg)'
- en: '*Figure 6-4: Output of the example for-in loop*'
  id: totrans-4292
  prefs: []
  type: TYPE_NORMAL
  zh: '*图6-4：示例for-in循环的输出*'
- en: '![Image](Image00137.jpg)'
  id: totrans-4293
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00137.jpg)'
- en: 'Using for-in loops is great for printing every value in an array. If you’re
    working with numbers, you can even use them to perform math operations on each
    item, which makes for some speedy calculations! The following code takes an array
    of numbers and calculates the square for each (the square of a number is that
    number multiplied by itself):'
  id: totrans-4294
  prefs: []
  type: TYPE_NORMAL
  zh: 使用for-in循环非常适合打印数组中的每个值。如果你在处理数字，甚至可以用它们对每个元素执行数学运算，从而加速计算！以下代码接收一个数字数组，并计算每个数字的平方（数字的平方是该数字与其本身相乘）：
- en: '![Image](Image00138.jpg)'
  id: totrans-4295
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00138.jpg)'
- en: '[Figure 6-5](text00016.html#ch06fig5) shows the results.'
  id: totrans-4296
  prefs: []
  type: TYPE_NORMAL
  zh: '[图6-5](text00016.html#ch06fig5)展示了结果。'
- en: '![Image](Image00139.jpg)'
  id: totrans-4297
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00139.jpg)'
- en: '*Figure 6-5: Printing the squares for each number in the myNumbers array*'
  id: totrans-4298
  prefs: []
  type: TYPE_NORMAL
  zh: '*图6-5：打印myNumbers数组中每个数字的平方*'
- en: '**DICTIONARIES ARE KEY!**'
  id: totrans-4299
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**字典很重要！**'
- en: A *dictionary* is also a collection of values, but instead of an ordered index,
    each value has its own *key* . Because there’s no index, the values are not stored
    in any particular order. To access values in a dictionary, you look them up by
    their key.
  id: totrans-4300
  prefs: []
  type: TYPE_NORMAL
  zh: '*字典*也是一个值的集合，但不同于有序索引，每个值都有自己的*键*。由于没有索引，值并不会按照特定顺序存储。要访问字典中的值，你需要通过它们的键来查找。'
- en: A key must be unique. You can’t have the same key more than once in the same
    dictionary. If there were two identical keys and you asked the computer to give
    you the value for one of them, the computer wouldn’t know which one to choose!
  id: totrans-4301
  prefs: []
  type: TYPE_NORMAL
  zh: 键必须是唯一的。你不能在同一个字典中多次使用相同的键。如果有两个相同的键，你要求计算机为你提供其中一个的值时，计算机就不知道该选择哪个！
- en: Let’s take a look at how to make a dictionary and write keys that will help
    you find all the information you need.
  id: totrans-4302
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看一下如何创建一个字典，并编写键来帮助你找到所需的所有信息。
- en: '![Image](Image00140.jpg)'
  id: totrans-4303
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00140.jpg)'
- en: '**INITIALIZING A DICTIONARY**'
  id: totrans-4304
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**初始化字典**'
- en: 'To create and initialize a dictionary, first write var and the name of your
    dictionary. Then write the keys and corresponding values inside a pair of square
    brackets, similar to an array. Let’s create a dictionary to store the names of
    a few US states. The key for each state will be its two-letter abbreviation:'
  id: totrans-4305
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建并初始化字典，首先写上`var`和字典的名称。然后像数组一样，在一对方括号中写上键及其对应的值。让我们创建一个字典来存储一些美国州的名字。每个州的键将是它的两位字母缩写：
- en: '![](Image00141.jpg)'
  id: totrans-4306
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00141.jpg)'
- en: As you can see, there’s a colon between each key and its value, and the key/value
    pairs are separated by commas.
  id: totrans-4307
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，每个键和值之间都有一个冒号，键/值对之间由逗号分隔。
- en: Dictionaries are different from arrays in that they are *unordered* . Because
    of that, it’s likely that the order of the states that you see in your results
    pane ➋ is different from the order in which you entered your states ➊ . It might
    even be different than the order that’s printed in this book!
  id: totrans-4308
  prefs: []
  type: TYPE_NORMAL
  zh: 字典与数组不同，因为字典是*无序的*。因此，你在结果窗格 ➋ 中看到的状态顺序可能与输入状态 ➊ 的顺序不同。甚至可能与本书中打印的顺序不同！
- en: As with arrays, you can use var to make a mutable dictionary or use let to make
    an immutable dictionary.
  id: totrans-4309
  prefs: []
  type: TYPE_NORMAL
  zh: 与数组一样，你可以使用`var`来创建一个可变字典，或者使用`let`来创建一个不可变字典。
- en: 'In Swift, all of the keys of a dictionary must be the same type, and all of
    the values of a dictionary must also be the same type, but the key type doesn’t
    have to match the value type. For example, if you wanted to store a collection
    of fractions, you could use doubles for the keys and strings for the values:'
  id: totrans-4310
  prefs: []
  type: TYPE_NORMAL
  zh: 在Swift中，字典的所有键必须是相同类型，所有值也必须是相同类型，但键的类型不需要与值的类型匹配。例如，如果你想存储一组分数，你可以使用双精度数（doubles）作为键，使用字符串作为值：
- en: '![](Image00142.jpg)'
  id: totrans-4311
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00142.jpg)'
- en: In this dictionary, all of the keys must be doubles, and all of the values must
    be strings. Again, you’ll see that the order of the numbers in the results pane
    can be quite different from the order in which you wrote the fractions in your
    dictionary. This is fine because you don’t need to know the order to access anything.
    You can find any item that you need by its key. Let’s see how!
  id: totrans-4312
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个字典中，所有的键必须是双精度数（doubles），所有的值必须是字符串。再次提醒，你会看到结果窗格中的数字顺序可能与在字典中编写分数的顺序完全不同。这是可以接受的，因为你不需要知道顺序就能访问任何内容。你可以通过键来找到任何需要的项。让我们来看一下如何操作！
- en: '**ACCESSING VALUES IN A DICTIONARY**'
  id: totrans-4313
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**访问字典中的值**'
- en: 'Looking up a value in a dictionary is similar to how you access a value in
    an array except that you use a key inside the square brackets instead of an index,
    like this: usStates["TX"] .'
  id: totrans-4314
  prefs: []
  type: TYPE_NORMAL
  zh: 在字典中查找值的方式类似于在数组中访问值，不同之处在于你使用的是键，而不是索引，就像这样：`usStates["TX"]`。
- en: There is a big difference, however, in how Swift returns the values from a dictionary.
    When you access a value at an index of an array, you are simply given the value.
    When you access a value with a key in a dictionary, you are given an optional.
  id: totrans-4315
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，Swift从字典中返回值的方式有一个很大的不同。当你访问数组中某个索引的值时，你直接得到值。当你用键访问字典中的值时，你得到的是一个可选项。
- en: In [Chapter 5](text00015.html#ch05) , you learned that optionals might contain
    a value or might be nil . The reason Swift returns optionals when you’re looking
    up items in a dictionary is that the key you used might not exist in the dictionary,
    in which case there’s no value to access. Trying to access a value that doesn’t
    exist would give you a big fat error! To avoid that problem, Swift returns optionals.
    That means you need to unwrap any value you get out of a dictionary before you
    can do anything with it.
  id: totrans-4316
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第5章](text00015.html#ch05)中，你学到过可选项可能包含一个值，也可能为nil。Swift在查找字典中的项时返回可选项，是因为你使用的键可能在字典中不存在，在这种情况下无法访问到值。尝试访问一个不存在的值会给你一个大大的错误！为避免这个问题，Swift返回可选项。这意味着你需要解包字典中获得的任何值，才能对其进行操作。
- en: 'To unwrap an optional, first you check whether it exists using an if-let statement,
    just like we did in [Chapter 5](text00015.html#ch05) . The following code shows
    you how to get a value out of a dictionary:'
  id: totrans-4317
  prefs: []
  type: TYPE_NORMAL
  zh: 要解包一个可选值，首先你需要使用 `if-let` 语句检查它是否存在，就像我们在 [第5章](text00015.html#ch05) 中所做的那样。以下代码演示了如何从字典中获取值：
- en: '![Image](Image00143.jpg)'
  id: totrans-4318
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00143.jpg)'
- en: To retrieve "Texas" from the dictionary, we use if let to set a constant loneStarState
    to usStates["TX"] ➊ . Because we have this state in our dictionary, the line I
    have Texas in my dictionary. is printed. Next we try to access a state that is
    not in our dictionary by using the key usStates["FL"] ➋ . Thankfully, because
    we used an if-let statement, the program won’t crash when the computer can’t find
    this state. Instead, I don't have that state in my dictionary. is printed.
  id: totrans-4319
  prefs: []
  type: TYPE_NORMAL
  zh: 要从字典中检索 "Texas"，我们使用 `if let` 来将常量 `loneStarState` 设置为 `usStates["TX"]` ➊。因为字典中有这个州，所以会打印出
    "I have Texas in my dictionary."。接下来，我们尝试通过使用键 `usStates["FL"]` ➋ 来访问一个字典中没有的州。幸运的是，由于我们使用了
    `if-let` 语句，当计算机找不到该州时，程序不会崩溃。相反，会打印出 "I don't have that state in my dictionary."。
- en: '**ADDING ITEMS TO A DICTIONARY**'
  id: totrans-4320
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**向字典中添加项**'
- en: 'To add an item to a dictionary, first write the name of your dictionary and
    assign the new item to the key you want it to have in the dictionary. Let’s add
    "Minnesota" to our usStates dictionary:'
  id: totrans-4321
  prefs: []
  type: TYPE_NORMAL
  zh: 要向字典中添加项，首先写下字典的名称，并将新项分配给你希望它在字典中拥有的键。让我们将 "Minnesota" 添加到我们的 `usStates` 字典中：
- en: '![](Image00144.jpg)'
  id: totrans-4322
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00144.jpg)'
- en: 'Now when you look at usStates , you’ll see that it’s updated to ["MN": "Minnesota",
    "WA": "Washington", "MA": "Massachusetts", "TX": "Texas"] . Remember, because
    you don’t have to rely on indices, your new dictionary item might appear anywhere
    in the dictionary.'
  id: totrans-4323
  prefs: []
  type: TYPE_NORMAL
  zh: '现在，当你查看 `usStates` 时，你会看到它已经更新为 ["MN": "Minnesota", "WA": "Washington", "MA":
    "Massachusetts", "TX": "Texas"]。记住，由于你不需要依赖索引，你的新字典项可能会出现在字典中的任何位置。'
- en: '**REMOVING ITEMS FROM A DICTIONARY**'
  id: totrans-4324
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**从字典中移除项**'
- en: Removing an item from a dictionary is quite simple; you do so by setting the
    value to nil . Because the values in dictionaries are returned as optionals, you
    don’t have to worry about nil causing any problems in your dictionary.
  id: totrans-4325
  prefs: []
  type: TYPE_NORMAL
  zh: 从字典中移除项非常简单；你只需将值设置为 `nil`。由于字典中的值是作为可选项返回的，因此你不需要担心 `nil` 会在字典中引发任何问题。
- en: '![](Image00145.jpg)'
  id: totrans-4326
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00145.jpg)'
- en: 'You can see that after you remove the value at the key "MA" , usStates is updated
    to ["MN": "Minnesota", "WA": "Washington", "TX": "Texas"] . Remember that nil
    is special and means that there’s no value at all. That’s why you don’t see "MA":
    nil in our dictionary.'
  id: totrans-4327
  prefs: []
  type: TYPE_NORMAL
  zh: '你可以看到，在你删除键 "MA" 的值之后，`usStates` 被更新为 ["MN": "Minnesota", "WA": "Washington",
    "TX": "Texas"]。记住，`nil` 是特殊的，表示根本没有值。这就是为什么你在我们的字典中看不到 "MA": nil。'
- en: '**REPLACING ITEMS IN A DICTIONARY**'
  id: totrans-4328
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**替换字典中的项**'
- en: 'Replacing an item in a dictionary is also easy. It works the same was as replacing
    an item in an array. You just set the item that you want to replace to something
    else. Say you create a dictionary of fruit colors:'
  id: totrans-4329
  prefs: []
  type: TYPE_NORMAL
  zh: 替换字典中的项也很简单。它的工作方式与替换数组中的项相同。你只需要将要替换的项设置为其他值。假设你创建了一个水果颜色的字典：
- en: '![](Image00146.jpg)'
  id: totrans-4330
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00146.jpg)'
- en: At first we had the value "apple" for "red" , but then we decided that "raspberry"
    is a better fruit to use since sometimes apples are green or yellow. To replace
    "apple" with "raspberry" , we set colorFruits["red"] to its new value ➊ .
  id: totrans-4331
  prefs: []
  type: TYPE_NORMAL
  zh: 起初我们为 "red" 设定了 "apple" 的值，但后来我们决定 "raspberry" 是更合适的水果，因为有时苹果是绿色或黄色的。为了将 "apple"
    替换为 "raspberry"，我们将 `colorFruits["red"]` 设置为其新值 ➊。
- en: You may remember that this is the same way we entered a new value into a dictionary.
    If the key already exists in the dictionary, then the value for that key is replaced.
    If the key doesn’t already exist, then the new key/value pair will be added to
    the dictionary.
  id: totrans-4332
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能还记得，这与我们向字典中输入新值的方法是一样的。如果键已经存在于字典中，那么该键的值会被替换。如果该键尚不存在，则新的键/值对会被添加到字典中。
- en: '![Image](Image00147.jpg)'
  id: totrans-4333
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00147.jpg)'
- en: '**USING DICTIONARY PROPERTIES**'
  id: totrans-4334
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**使用字典属性**'
- en: 'Like an array, a dictionary also has an isEmpty property and a count property.
    For example, the following code shows how you can use the isEmpty property to
    check if a dictionary is empty, and if it isn’t empty, the count property checks
    how many items you have. Imagine you have a basket of fruit for sale. You can
    use these properties to help you keep track of everything:'
  id: totrans-4335
  prefs: []
  type: TYPE_NORMAL
  zh: 像数组一样，字典也有 `isEmpty` 属性和 `count` 属性。例如，以下代码展示了你如何使用 `isEmpty` 属性检查字典是否为空，如果字典不为空，则
    `count` 属性可以检查字典中有多少项。假设你有一个待售的水果篮，你可以使用这些属性帮助你跟踪所有内容：
- en: '![Image](Image00148.jpg)'
  id: totrans-4336
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00148.jpg)'
- en: 'A dictionary also has two special properties: keys , which contains all of
    the dictionary’s keys, and values , which contains all of its values. We’ll use
    these two properties when we loop through the dictionary.'
  id: totrans-4337
  prefs: []
  type: TYPE_NORMAL
  zh: 字典还有两个特殊的属性：keys，包含字典的所有键，和 values，包含字典的所有值。我们将在遍历字典时使用这两个属性。
- en: Let’s write some code that loops through our fruit baskets and prints the price
    of each fruit.
  id: totrans-4338
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们写一些代码，遍历我们的水果篮并打印每个水果的价格。
- en: '**LOOPING OVER A DICTIONARY**'
  id: totrans-4339
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**遍历字典**'
- en: 'You can loop through a dictionary using a for-in loop. Because each item has
    a key and a value, you can do this in two different ways. This is how to loop
    through a dictionary using its keys:'
  id: totrans-4340
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用 for-in 循环来遍历字典。由于每个项都有一个键和值，你可以通过两种不同的方式进行循环。这是使用键遍历字典的方法：
- en: '![Image](Image00149.jpg)'
  id: totrans-4341
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00149.jpg)'
- en: Here we use the dictionary’s keys property ➊ to loop through fruitBasket and
    print its contents. We start by writing the keyword for , followed by a constant
    name fruit for the dictionary key, the keyword in , the dictionary name, a period,
    and keys .
  id: totrans-4342
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们使用字典的 keys 属性 ➊ 来遍历 fruitBasket 并打印它的内容。我们首先写关键字 for，接着是常量名称 fruit 作为字典键，然后是关键字
    in、字典名称、一个句点和 keys。
- en: Inside the braces of our for-in loop, we have access to both the key, which
    we call fruit ➋ , and the value at that key when we force-unwrap its contents
    with fruitBasket[fruit]! ➌ . That value will be the fruit’s price.
  id: totrans-4343
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的 for-in 循环的大括号内部，我们可以访问键（我们称之为 fruit ➋）以及当我们强制解包其内容时，字典中该键的值（fruitBasket[fruit]!
    ➌）。该值就是水果的价格。
- en: In this case, it’s safe to force-unwrap the value using an exclamation point
    because we know that the fruit key we’re using is definitely inside the dictionary.
  id: totrans-4344
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，强制解包值时使用感叹号是安全的，因为我们知道我们使用的 fruit 键一定在字典中。
- en: Any code we put inside the for-in loop will run once for every key in our dictionary.
    So you should see the print statement display three times.
  id: totrans-4345
  prefs: []
  type: TYPE_NORMAL
  zh: 我们放在 for-in 循环内部的代码会针对字典中的每个键运行一次。所以你应该看到打印语句显示三次。
- en: 'We can also loop through the dictionary using its values property:'
  id: totrans-4346
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以使用字典的 values 属性来循环遍历字典：
- en: '![Image](Image00150.jpg)'
  id: totrans-4347
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00150.jpg)'
- en: We use the same style of for-in loop, but now we use a constant to refer to
    each value, which we call price , in the values property. When looping through
    values, we don’t have access to the keys from inside the loop.
  id: totrans-4348
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用相同的 for-in 循环风格，但这次我们使用一个常量来引用 values 属性中的每个值，称之为 price。在循环遍历值时，我们无法从循环内部访问键。
- en: Another difference to note is that price is not an optional because it’s accessed
    directly as a value in the fruitBasket dictionary. That means we don’t have to
    unwrap it. You should still see the print statement printed three times. [Figure
    6-6](text00016.html#ch06fig6) shows the output of both loops.
  id: totrans-4349
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个需要注意的区别是，价格不是一个可选值，因为它是作为水果篮字典中的一个值直接访问的。这意味着我们不需要解包它。你仍然应该看到打印语句被打印三次。[图
    6-6](text00016.html#ch06fig6)显示了两个循环的输出结果。
- en: '![Image](Image00151.jpg)'
  id: totrans-4350
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00151.jpg)'
- en: '*Figure 6-6: Looping through the keys and values of a dictionary with a for-in
    loop*'
  id: totrans-4351
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 6-6：使用 for-in 循环遍历字典的键和值*'
- en: The order of your results might be slightly different from ours. That’s because
    the items in a dictionary aren’t in a numbered order like they are in an array!
    And because the order is not guaranteed, you might see a different order printed
    if you run the same code again.
  id: totrans-4352
  prefs: []
  type: TYPE_NORMAL
  zh: 你的结果顺序可能与我们的稍有不同。这是因为字典中的项不像数组那样按顺序编号！由于顺序无法保证，如果你再次运行相同的代码，可能会看到不同的顺序。
- en: '**WHAT YOU LEARNED**'
  id: totrans-4353
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**你学到了什么**'
- en: In this chapter, you learned how to store collections of items in an array and
    in a dictionary. To store items in an ordered list, you would use an array and
    look up each item by its index. If you wanted to store items by key instead, you
    would use a dictionary.
  id: totrans-4354
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你学习了如何将项目存储在数组和字典中。要将项目存储在有序列表中，你应该使用数组，并通过索引查找每个项目。如果你想按键存储项目，则应该使用字典。
- en: Knowing about arrays and dictionaries and how to use them is a powerful building
    block for almost any programming language. Next we will learn about functions,
    another very powerful tool. Functions are blocks of code that you create and name
    to perform a specific job. After you have written a function, you can use its
    name to call it from almost anywhere in your program.
  id: totrans-4355
  prefs: []
  type: TYPE_NORMAL
  zh: 了解数组和字典以及如何使用它们是几乎所有编程语言的强大构建块。接下来我们将学习函数，另一个非常强大的工具。函数是你创建并命名的代码块，用来执行特定的任务。编写完函数后，你可以通过它的名称从程序的几乎任何地方调用它。
- en: One way to change an array is to add new items to it. There are a few different
    ways to do this, so let’s take a look at each.
  id: totrans-4356
  prefs: []
  type: TYPE_NORMAL
  zh: 修改数组的一种方式是向其中添加新项。添加新项有几种不同的方法，我们来逐一看看。
- en: 'First, you can use an array’s append(_:) method. *Append* means to add something.
    Using append(_:) , you can add one new item to the end of your array. Say you
    go on another trip and visit the Badlands, and you want to add it to your list
    of national parks. To do that, add this code into your playground:'
  id: totrans-4357
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，你可以使用数组的 append(_:) 方法。*Append* 意味着添加某物。通过 append(_:)，你可以向数组的末尾添加一个新项。假设你又去了一次旅行，参观了
    Badlands，并且想将它添加到你的国家公园列表中。为此，可以将以下代码添加到你的 Playground 中：
- en: '![](Image00120.jpg)'
  id: totrans-4358
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00120.jpg)'
- en: To use the append(_:) method, first write the name of your array followed by
    a period and then append . Then, put the item you want to add to your array inside
    the parentheses. In this case, you put "Badlands" inside the parentheses.
  id: totrans-4359
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用 append(_:) 方法，首先写下数组的名称，后面跟一个句点，然后是 append。接着，在括号内放入你想要添加到数组中的项。在这种情况下，你把“Badlands”放入括号内。
- en: 'If you want to add something at a specific place in your array, use the array’s
    insert(_:at:) method instead. This method takes two arguments: the item that you
    want to insert and the index of where it should go in the array. (We’ll discuss
    arguments in more detail in [Chapter 7](text00017.html#ch07) .)'
  id: totrans-4360
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想在数组中的特定位置添加某项，可以使用数组的 insert(_:at:) 方法。此方法需要两个参数：你要插入的项以及它在数组中应插入的位置索引。（我们将在[第
    7 章](text00017.html#ch07)中更详细地讨论参数。）
- en: 'Let’s say you totally forgot that you went to the Petrified Forest right after
    you visited the Grand Canyon, and you want to update your nationalParks array
    so it displays the parks in the order in which you visited them. To update your
    array, you could use the insert(_:at:) method to put the Petrified Forest in the
    right position:'
  id: totrans-4361
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你完全忘记了在参观大峡谷之后去了石化森林，并且你想更新你的 nationalParks 数组，以便按你访问的顺序显示这些公园。为了更新数组，你可以使用
    insert(_:at:) 方法将石化森林放入正确的位置：
- en: '![](Image00121.jpg)'
  id: totrans-4362
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00121.jpg)'
- en: When you insert a new item at index 3, everything that was in the array at index
    3 or higher gets scooted over to make room for the new item. That means the item
    that was at index 3 is now at index 4, the item that was at index 4 is now at
    index 5, and so on. After you add the Petrified Forest, nationalParks is now ["Acadia",
    "Zion", "Grand Canyon", "Petrified Forest", "Badlands"] .
  id: totrans-4363
  prefs: []
  type: TYPE_NORMAL
  zh: 当你在索引 3 处插入一个新项时，数组中索引 3 或更高位置的所有项都会向后移动，为新项腾出空间。这意味着原本在索引 3 处的项现在在索引 4 处，原本在索引
    4 处的项现在在索引 5 处，以此类推。加入“石化森林”后，nationalParks 现在是 ["Acadia", "Zion", "Grand Canyon",
    "Petrified Forest", "Badlands"]。
- en: '**COMBINING ARRAYS**'
  id: totrans-4364
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**合并数组**'
- en: 'Not only can you add new items to an array, but you can also add two arrays
    together using the + and += operators. Let’s say that you have the ingredients
    for a fruit smoothie in two arrays:'
  id: totrans-4365
  prefs: []
  type: TYPE_NORMAL
  zh: 你不仅可以向数组中添加新项，还可以使用 + 和 += 运算符将两个数组合并。假设你有两个数组，分别存储制作果昔所需的水果和液体配料：
- en: '![](Image00122.jpg)'
  id: totrans-4366
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00122.jpg)'
- en: Now you can make a delicious smoothie by adding the fruits and liquids arrays.
  id: totrans-4367
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你可以通过合并水果和液体数组来制作美味的果昔了。
- en: '![](Image00123.jpg)'
  id: totrans-4368
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00123.jpg)'
- en: The order of the ingredients in smoothie is the same as the order in fruits
    and liquids . If you created smoothie with liquids + fruits , then the liquids
    would come first.
  id: totrans-4369
  prefs: []
  type: TYPE_NORMAL
  zh: 果昔中的配料顺序与水果和液体的顺序相同。如果你是用液体 + 水果来制作果昔，那么液体会排在前面。
- en: 'You use the += operator to add an array to the end of your array. Add some
    whipped cream as follows for extra yumminess:'
  id: totrans-4370
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用 += 运算符将一个数组添加到另一个数组的末尾。为了增加美味度，可以如下添加一些鲜奶油：
- en: '![](Image00124.jpg)'
  id: totrans-4371
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00124.jpg)'
- en: Note that ["whipped cream"] is an array even though it has a single item in
    it. When you’re using += to append something to an array, you have to make sure
    you’re only trying to add another array. If you were to just write the string
    "whipped cream" without the square brackets around it, you would get an error.
  id: totrans-4372
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，["whipped cream"] 是一个数组，即使它只有一个项目。当你使用 += 将内容附加到数组时，必须确保你仅尝试添加另一个数组。如果你只是写下字符串
    "whipped cream" 而没有加上方括号，系统会报错。
- en: '![Image](Image00125.jpg)'
  id: totrans-4373
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00125.jpg)'
- en: '**REMOVING ITEMS FROM AN ARRAY**'
  id: totrans-4374
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**从数组中删除项目**'
- en: 'There are several methods for removing items from an array. Let’s start by
    looking at the array’s removeLast() method. As you might have guessed from its
    name, removeLast() removes the last item from your array. Let’s try it out with
    a shoppingList array:'
  id: totrans-4375
  prefs: []
  type: TYPE_NORMAL
  zh: 有几种方法可以从数组中删除项目。让我们先看一下数组的 removeLast() 方法。正如你从它的名字中可以猜到的，removeLast() 会删除数组中的最后一个项目。让我们用一个购物清单数组来试试：
- en: '![](Image00126.jpg)'
  id: totrans-4376
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00126.jpg)'
- en: Neat! Note that the removeLast() method returns the removed item, so you can
    store it in a new constant or variable if you want.
  id: totrans-4377
  prefs: []
  type: TYPE_NORMAL
  zh: 真不错！请注意，removeLast() 方法返回被删除的项目，因此如果你想，可以将其存储在新的常量或变量中。
- en: 'You can also remove an item from a specific index by using the remove(at:)
    method. Let’s say that your mom doesn’t want you buying any candy and takes that
    off the list:'
  id: totrans-4378
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以通过使用 remove(at:) 方法从特定索引删除项目。假设你的妈妈不想让你买糖果，把它从列表中删除：
- en: '![Image](Image00127.jpg)![](Image00128.jpg)'
  id: totrans-4379
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00127.jpg)![](Image00128.jpg)'
- en: Just like when we added an item to the middle of our array and all the items
    scooted over to make room, if you remove an item from the middle of an array,
    the rest of the items will scoot back to fill in that empty space. The "apples"
    item that was at index 3 is now at index 2, where "candy" was.
  id: totrans-4380
  prefs: []
  type: TYPE_NORMAL
  zh: 就像我们在数组中间添加一个项目时，所有项目都会移过来腾出空间一样，如果你从数组中间删除一个项目，剩下的项目会移回去填补那个空白位置。原本在索引 3 的“苹果”项目现在位于索引
    2，原本是“糖果”的位置。
- en: 'You can also remove all items from an array with removeAll() . Try entering
    this into your playground:'
  id: totrans-4381
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以使用 removeAll() 从数组中删除所有项目。尝试在你的游乐场中输入这个：
- en: '![](Image00129.jpg)'
  id: totrans-4382
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00129.jpg)'
- en: 'Note that trying to remove an item at an index that doesn’t exist will give
    you an error:'
  id: totrans-4383
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，尝试删除一个不存在的索引处的项目会报错：
- en: '![](Image00130.jpg)'
  id: totrans-4384
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00130.jpg)'
- en: Our array doesn’t have this many items (in fact, now it’s empty!), so this throws
    an error. We’ll also get an error if we use removeLast() on our empty array, because
    there’s nothing in it—there’s no last index at all! However, removeAll() is always
    safe to use, even on an empty array.
  id: totrans-4385
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的数组没有这么多项目（实际上现在它是空的！），所以这会抛出一个错误。如果我们在空数组上使用 removeLast()，也会报错，因为它里面什么都没有——根本没有最后一个索引！然而，removeAll()
    即使在空数组上使用也总是安全的。
- en: '**REPLACING ITEMS IN AN ARRAY**'
  id: totrans-4386
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**替换数组中的项目**'
- en: 'To replace an item in an array, you set the index of the array to the new value,
    as shown here:'
  id: totrans-4387
  prefs: []
  type: TYPE_NORMAL
  zh: 要替换数组中的项目，你需要将数组的索引设置为新值，如下所示：
- en: '![](Image00131.jpg)'
  id: totrans-4388
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00131.jpg)'
- en: At ➊ , we replaced the item at index 2 (the third item) with "Unicorn" because
    magical animals count as favorite animals, too! At ➋ , we replaced the item at
    index 0 (the first item) with "Bearded dragon" . No, that’s not a real dragon—it’s
    just a lizard!
  id: totrans-4389
  prefs: []
  type: TYPE_NORMAL
  zh: 在➊ 处，我们将索引 2（第三个项目）处的项目替换为“独角兽”，因为魔法动物也算是最喜欢的动物！在➋ 处，我们将索引 0（第一个项目）处的项目替换为“胡须龙”。不，这可不是一条真正的龙——它只是一个蜥蜴！
- en: Like any time you’re working with array index numbers, you have to be sure an
    item exists in the array at that index before you change its value, or you will
    get an Index out of range error.
  id: totrans-4390
  prefs: []
  type: TYPE_NORMAL
  zh: 就像每次操作数组索引时一样，你必须确保该索引位置存在项目，才能修改其值，否则你会遇到“索引超出范围”的错误。
- en: '[Figure 6-3](text00016.html#ch06fig3) shows the error that occurs if you try
    to add "Standard poodle" using favoriteAnimals[3] = "Standard poodle" . To add
    an item to the end of an array, you should use the append(_:) method or += , as
    we covered in “[Adding Items to an Array](text00016.html#ch06lev2sec5) ” on [page
    70](text00016.html#page_70) .'
  id: totrans-4391
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 6-3](text00016.html#ch06fig3) 显示了如果你尝试通过 favoriteAnimals[3] = "Standard
    poodle" 添加“标准贵宾犬”时会发生的错误。要将项目添加到数组的末尾，你应该使用 append(_: ) 方法或 +=，正如我们在 “[向数组添加项目](text00016.html#ch06lev2sec5)”
    中所讨论的，[第 70 页](text00016.html#page_70)。'
- en: '![Image](Image00132.jpg)'
  id: totrans-4392
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00132.jpg)'
- en: '*Figure 6-3: Don’t try to replace a value at an index beyond the existing array.*'
  id: totrans-4393
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 6-3：不要尝试替换超出现有数组索引的值。*'
- en: Now you know how to change arrays however you might need to. You can add items,
    take items away, or replace items. Next, we’ll look at how to use the properties
    of arrays to find out even more information about them.
  id: totrans-4394
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经知道如何根据需要更改数组了。你可以添加元素、删除元素或替换元素。接下来，我们将看看如何使用数组的属性来获取更多有关它们的信息。
- en: '![Image](Image00133.jpg)'
  id: totrans-4395
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00133.jpg)'
- en: '**USING ARRAY PROPERTIES**'
  id: totrans-4396
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**使用数组属性**'
- en: In addition to methods like append(_:) and removeLast() , arrays also have *properties*
    . An array’s properties are variables or constants that contain some information
    about the array. Two really helpful properties that you might use are the Boolean
    property isEmpty and the integer property count .
  id: totrans-4397
  prefs: []
  type: TYPE_NORMAL
  zh: 除了像append(_:)和removeLast()这样的函数，数组还有*属性*。数组的属性是包含数组某些信息的变量或常量。你可能会用到的两个非常有用的属性是布尔值属性isEmpty和整数属性count。
- en: The isEmpty property is true or false depending on whether the array is empty,
    and the count property will tell you how many items are in that array.
  id: totrans-4398
  prefs: []
  type: TYPE_NORMAL
  zh: isEmpty属性的值为true或false，取决于数组是否为空，而count属性会告诉你数组中有多少个元素。
- en: 'Check out how these two properties are used in the following if-else statement:'
  id: totrans-4399
  prefs: []
  type: TYPE_NORMAL
  zh: 查看以下if-else语句中如何使用这两个属性：
- en: '![Image](Image00134.jpg)'
  id: totrans-4400
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00134.jpg)'
- en: 'This if-else statement checks whether the array mySiblings is empty ➊ . If
    it is, then "I don''t have any siblings." is printed. But if there is something
    in the array, then the number of siblings that we have is printed: "I have 3 siblings."
    ➋ .'
  id: totrans-4401
  prefs: []
  type: TYPE_NORMAL
  zh: 这个if-else语句检查数组mySiblings是否为空 ➊。如果为空，则打印“我没有兄弟姐妹”。但如果数组中有元素，则打印我们有多少兄弟姐妹：“我有3个兄弟姐妹。”
    ➋。
- en: '**LOOPING OVER AN ARRAY**'
  id: totrans-4402
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**循环遍历数组**'
- en: 'Sometimes when you’re working with arrays you might want to do something to
    every item in the array. You can use a for-in loop to do that! The following code
    will print every topping in a pizzaToppings array on a separate line:'
  id: totrans-4403
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，当你在处理数组时，可能想对数组中的每个元素做些操作。你可以使用for-in循环来实现！下面的代码将在pizzaToppings数组中打印每个配料，且每个配料在单独的一行中：
- en: '![Image](Image00135.jpg)'
  id: totrans-4404
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00135.jpg)'
- en: To write a for-in loop for the pizzaToppings array, we used the keyword for
    , followed by the constant topping , then the keyword in , and finally the name
    of our array, pizzaToppings . Then we put the statements that we want to run for
    each topping inside the braces of the for-in loop. The constant topping ➊ temporarily
    represents each pizza topping in the array as we loop through it. We could have
    chosen any name for this constant, but it’s a good idea to pick something that
    makes sense. You can see the output of this for-in loop in [Figure 6-4](text00016.html#ch06fig4)
    .
  id: totrans-4405
  prefs: []
  type: TYPE_NORMAL
  zh: 为了为pizzaToppings数组写一个for-in循环，我们使用了关键字for，接着是常量topping，然后是关键字in，最后是我们数组的名称pizzaToppings。然后，我们将要对每个配料执行的语句放在for-in循环的大括号中。常量topping
    ➊在我们遍历数组时暂时代表每个配料。我们可以为这个常量选择任何名字，但最好选择一个有意义的名字。你可以在[图6-4](text00016.html#ch06fig4)中看到这个for-in循环的输出。
- en: '![Image](Image00136.jpg)'
  id: totrans-4406
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00136.jpg)'
- en: '*Figure 6-4: Output of the example for-in loop*'
  id: totrans-4407
  prefs: []
  type: TYPE_NORMAL
  zh: '*图6-4：示例for-in循环的输出*'
- en: '![Image](Image00137.jpg)'
  id: totrans-4408
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00137.jpg)'
- en: 'Using for-in loops is great for printing every value in an array. If you’re
    working with numbers, you can even use them to perform math operations on each
    item, which makes for some speedy calculations! The following code takes an array
    of numbers and calculates the square for each (the square of a number is that
    number multiplied by itself):'
  id: totrans-4409
  prefs: []
  type: TYPE_NORMAL
  zh: 使用for-in循环非常适合打印数组中的每个值。如果你在处理数字，你甚至可以用它们对每个元素进行数学运算，这样就能进行快速的计算！下面的代码取一个数字数组，并计算每个数的平方（一个数的平方是该数与自身相乘）：
- en: '![Image](Image00138.jpg)'
  id: totrans-4410
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00138.jpg)'
- en: '[Figure 6-5](text00016.html#ch06fig5) shows the results.'
  id: totrans-4411
  prefs: []
  type: TYPE_NORMAL
  zh: '[图6-5](text00016.html#ch06fig5)显示了结果。'
- en: '![Image](Image00139.jpg)'
  id: totrans-4412
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00139.jpg)'
- en: '*Figure 6-5: Printing the squares for each number in the myNumbers array*'
  id: totrans-4413
  prefs: []
  type: TYPE_NORMAL
  zh: '*图6-5：打印myNumbers数组中每个数字的平方*'
- en: '**DICTIONARIES ARE KEY!**'
  id: totrans-4414
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**字典至关重要！**'
- en: A *dictionary* is also a collection of values, but instead of an ordered index,
    each value has its own *key* . Because there’s no index, the values are not stored
    in any particular order. To access values in a dictionary, you look them up by
    their key.
  id: totrans-4415
  prefs: []
  type: TYPE_NORMAL
  zh: '*字典*也是一种值的集合，但不同于有序索引，每个值都有自己的*键*。由于没有索引，值没有特定的存储顺序。要访问字典中的值，你需要通过键查找它们。'
- en: A key must be unique. You can’t have the same key more than once in the same
    dictionary. If there were two identical keys and you asked the computer to give
    you the value for one of them, the computer wouldn’t know which one to choose!
  id: totrans-4416
  prefs: []
  type: TYPE_NORMAL
  zh: 键必须是唯一的。你不能在同一个字典中使用相同的键多次。如果有两个相同的键，你要求计算机给你其中一个键的值时，计算机就无法知道选择哪一个！
- en: Let’s take a look at how to make a dictionary and write keys that will help
    you find all the information you need.
  id: totrans-4417
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看如何创建一个字典，并写出能够帮助你找到所有所需信息的键。
- en: '![Image](Image00140.jpg)'
  id: totrans-4418
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00140.jpg)'
- en: '**INITIALIZING A DICTIONARY**'
  id: totrans-4419
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**初始化字典**'
- en: 'To create and initialize a dictionary, first write var and the name of your
    dictionary. Then write the keys and corresponding values inside a pair of square
    brackets, similar to an array. Let’s create a dictionary to store the names of
    a few US states. The key for each state will be its two-letter abbreviation:'
  id: totrans-4420
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建和初始化一个字典，首先写var和字典的名称。然后将键和值放入一对方括号中，类似于数组。我们来创建一个字典，用于存储一些美国州的名称。每个州的键将是其两位字母缩写：
- en: '![](Image00141.jpg)'
  id: totrans-4421
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00141.jpg)'
- en: As you can see, there’s a colon between each key and its value, and the key/value
    pairs are separated by commas.
  id: totrans-4422
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，每个键和值之间有一个冒号，并且键/值对由逗号分隔。
- en: Dictionaries are different from arrays in that they are *unordered* . Because
    of that, it’s likely that the order of the states that you see in your results
    pane ➋ is different from the order in which you entered your states ➊ . It might
    even be different than the order that’s printed in this book!
  id: totrans-4423
  prefs: []
  type: TYPE_NORMAL
  zh: 字典与数组不同，它们是*无序的*。因此，你在结果面板➋中看到的状态顺序可能与输入状态的顺序➊不同。甚至可能与书中打印的顺序不同！
- en: As with arrays, you can use var to make a mutable dictionary or use let to make
    an immutable dictionary.
  id: totrans-4424
  prefs: []
  type: TYPE_NORMAL
  zh: 与数组一样，你可以使用var来创建一个可变字典，或者使用let来创建一个不可变字典。
- en: 'In Swift, all of the keys of a dictionary must be the same type, and all of
    the values of a dictionary must also be the same type, but the key type doesn’t
    have to match the value type. For example, if you wanted to store a collection
    of fractions, you could use doubles for the keys and strings for the values:'
  id: totrans-4425
  prefs: []
  type: TYPE_NORMAL
  zh: 在Swift中，字典的所有键必须是相同的类型，字典的所有值也必须是相同的类型，但键的类型不需要与值的类型匹配。例如，如果你想存储一个分数集合，可以使用double类型作为键，string类型作为值：
- en: '![](Image00142.jpg)'
  id: totrans-4426
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00142.jpg)'
- en: In this dictionary, all of the keys must be doubles, and all of the values must
    be strings. Again, you’ll see that the order of the numbers in the results pane
    can be quite different from the order in which you wrote the fractions in your
    dictionary. This is fine because you don’t need to know the order to access anything.
    You can find any item that you need by its key. Let’s see how!
  id: totrans-4427
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个字典中，所有的键必须是double类型，所有的值必须是string类型。同样，你会发现结果面板中的数字顺序可能与在字典中写分数的顺序大不相同。这没关系，因为你不需要知道顺序就能访问任何项。你可以通过键找到你需要的任何项。让我们看看如何操作！
- en: '**ACCESSING VALUES IN A DICTIONARY**'
  id: totrans-4428
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**访问字典中的值**'
- en: 'Looking up a value in a dictionary is similar to how you access a value in
    an array except that you use a key inside the square brackets instead of an index,
    like this: usStates["TX"] .'
  id: totrans-4429
  prefs: []
  type: TYPE_NORMAL
  zh: 在字典中查找一个值类似于在数组中访问一个值，只是你在方括号中使用的是键而不是索引，像这样：usStates["TX"]。
- en: There is a big difference, however, in how Swift returns the values from a dictionary.
    When you access a value at an index of an array, you are simply given the value.
    When you access a value with a key in a dictionary, you are given an optional.
  id: totrans-4430
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，Swift在返回字典中的值时有很大的不同。当你在数组中访问一个值时，你只会得到该值。当你在字典中使用键访问一个值时，你会得到一个可选值。
- en: In [Chapter 5](text00015.html#ch05) , you learned that optionals might contain
    a value or might be nil . The reason Swift returns optionals when you’re looking
    up items in a dictionary is that the key you used might not exist in the dictionary,
    in which case there’s no value to access. Trying to access a value that doesn’t
    exist would give you a big fat error! To avoid that problem, Swift returns optionals.
    That means you need to unwrap any value you get out of a dictionary before you
    can do anything with it.
  id: totrans-4431
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第5章](text00015.html#ch05)中，你学到可选值可能包含一个值，也可能是nil。Swift返回可选值的原因是，在你查找字典中的项时，你使用的键可能在字典中不存在，在这种情况下就没有值可访问。试图访问一个不存在的值会给你一个很大的错误！为了避免这个问题，Swift返回可选值。这意味着你需要解包从字典中得到的任何值，才能对其进行操作。
- en: 'To unwrap an optional, first you check whether it exists using an if-let statement,
    just like we did in [Chapter 5](text00015.html#ch05) . The following code shows
    you how to get a value out of a dictionary:'
  id: totrans-4432
  prefs: []
  type: TYPE_NORMAL
  zh: 要解包一个可选项，首先你需要使用if-let语句检查它是否存在，就像我们在[第5章](text00015.html#ch05)中做的那样。以下代码演示了如何从字典中获取一个值：
- en: '![Image](Image00143.jpg)'
  id: totrans-4433
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00143.jpg)'
- en: To retrieve "Texas" from the dictionary, we use if let to set a constant loneStarState
    to usStates["TX"] ➊ . Because we have this state in our dictionary, the line I
    have Texas in my dictionary. is printed. Next we try to access a state that is
    not in our dictionary by using the key usStates["FL"] ➋ . Thankfully, because
    we used an if-let statement, the program won’t crash when the computer can’t find
    this state. Instead, I don't have that state in my dictionary. is printed.
  id: totrans-4434
  prefs: []
  type: TYPE_NORMAL
  zh: 要从字典中检索“Texas”，我们使用if let将常量loneStarState设置为usStates["TX"] ➊。因为在我们的字典中有这个州，所以打印了“I
    have Texas in my dictionary”这一行。接下来，我们尝试通过使用键usStates["FL"] ➋来访问一个不在字典中的州。幸运的是，由于我们使用了if-let语句，当计算机找不到这个州时，程序不会崩溃。相反，打印了“I
    don't have that state in my dictionary”。
- en: '**ADDING ITEMS TO A DICTIONARY**'
  id: totrans-4435
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**向字典中添加项**'
- en: 'To add an item to a dictionary, first write the name of your dictionary and
    assign the new item to the key you want it to have in the dictionary. Let’s add
    "Minnesota" to our usStates dictionary:'
  id: totrans-4436
  prefs: []
  type: TYPE_NORMAL
  zh: 要向字典中添加一个项，首先写出字典的名称，并将新项赋给你希望它在字典中拥有的键。让我们向我们的usStates字典中添加“Minnesota”：
- en: '![](Image00144.jpg)'
  id: totrans-4437
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00144.jpg)'
- en: 'Now when you look at usStates , you’ll see that it’s updated to ["MN": "Minnesota",
    "WA": "Washington", "MA": "Massachusetts", "TX": "Texas"] . Remember, because
    you don’t have to rely on indices, your new dictionary item might appear anywhere
    in the dictionary.'
  id: totrans-4438
  prefs: []
  type: TYPE_NORMAL
  zh: '现在，当你查看usStates时，你会看到它已经更新为["MN": "Minnesota", "WA": "Washington", "MA": "Massachusetts",
    "TX": "Texas"]。记住，因为你不需要依赖索引，所以新的字典项可能会出现在字典中的任何位置。'
- en: '**REMOVING ITEMS FROM A DICTIONARY**'
  id: totrans-4439
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**从字典中删除项**'
- en: Removing an item from a dictionary is quite simple; you do so by setting the
    value to nil . Because the values in dictionaries are returned as optionals, you
    don’t have to worry about nil causing any problems in your dictionary.
  id: totrans-4440
  prefs: []
  type: TYPE_NORMAL
  zh: 从字典中删除项是非常简单的；你只需要将该项的值设置为nil。因为字典中的值是作为可选项返回的，所以你不必担心nil会在字典中引起任何问题。
- en: '![](Image00145.jpg)'
  id: totrans-4441
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00145.jpg)'
- en: 'You can see that after you remove the value at the key "MA" , usStates is updated
    to ["MN": "Minnesota", "WA": "Washington", "TX": "Texas"] . Remember that nil
    is special and means that there’s no value at all. That’s why you don’t see "MA":
    nil in our dictionary.'
  id: totrans-4442
  prefs: []
  type: TYPE_NORMAL
  zh: '你可以看到，在删除键“MA”对应的值后，usStates更新为["MN": "Minnesota", "WA": "Washington", "TX":
    "Texas"]。记住，nil是特殊的，表示没有值。这就是为什么你在字典中看不到"MA": nil的原因。'
- en: '**REPLACING ITEMS IN A DICTIONARY**'
  id: totrans-4443
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**替换字典中的项**'
- en: 'Replacing an item in a dictionary is also easy. It works the same was as replacing
    an item in an array. You just set the item that you want to replace to something
    else. Say you create a dictionary of fruit colors:'
  id: totrans-4444
  prefs: []
  type: TYPE_NORMAL
  zh: 替换字典中的项也很简单。它的工作方式与替换数组中的项相同。你只需要将你想替换的项设置为其他值。假设你创建了一个水果颜色的字典：
- en: '![](Image00146.jpg)'
  id: totrans-4445
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00146.jpg)'
- en: At first we had the value "apple" for "red" , but then we decided that "raspberry"
    is a better fruit to use since sometimes apples are green or yellow. To replace
    "apple" with "raspberry" , we set colorFruits["red"] to its new value ➊ .
  id: totrans-4446
  prefs: []
  type: TYPE_NORMAL
  zh: 一开始，我们给“red”分配了“apple”的值，但后来我们决定使用“raspberry”作为更合适的水果，因为有时候苹果是绿色或黄色的。要将“apple”替换为“raspberry”，我们将colorFruits["red"]设置为它的新值
    ➊。
- en: You may remember that this is the same way we entered a new value into a dictionary.
    If the key already exists in the dictionary, then the value for that key is replaced.
    If the key doesn’t already exist, then the new key/value pair will be added to
    the dictionary.
  id: totrans-4447
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能还记得，这与我们向字典中添加新值的方式相同。如果键已经存在于字典中，那么该键的值会被替换。如果键不存在，则新的键/值对将被添加到字典中。
- en: '![Image](Image00147.jpg)'
  id: totrans-4448
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00147.jpg)'
- en: '**USING DICTIONARY PROPERTIES**'
  id: totrans-4449
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**使用字典属性**'
- en: 'Like an array, a dictionary also has an isEmpty property and a count property.
    For example, the following code shows how you can use the isEmpty property to
    check if a dictionary is empty, and if it isn’t empty, the count property checks
    how many items you have. Imagine you have a basket of fruit for sale. You can
    use these properties to help you keep track of everything:'
  id: totrans-4450
  prefs: []
  type: TYPE_NORMAL
  zh: 像数组一样，字典也有isEmpty属性和count属性。例如，以下代码展示了你如何使用isEmpty属性检查字典是否为空，如果不为空，count属性则检查字典中有多少项。假设你有一个待售的水果篮子。你可以使用这些属性帮助你跟踪所有物品：
- en: '![Image](Image00148.jpg)'
  id: totrans-4451
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00148.jpg)'
- en: 'A dictionary also has two special properties: keys , which contains all of
    the dictionary’s keys, and values , which contains all of its values. We’ll use
    these two properties when we loop through the dictionary.'
  id: totrans-4452
  prefs: []
  type: TYPE_NORMAL
  zh: 字典还具有两个特殊属性：`keys`，它包含字典的所有键，和`values`，它包含字典的所有值。在遍历字典时，我们将使用这两个属性。
- en: Let’s write some code that loops through our fruit baskets and prints the price
    of each fruit.
  id: totrans-4453
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们编写一些代码，遍历我们的水果篮并打印每个水果的价格。
- en: '**LOOPING OVER A DICTIONARY**'
  id: totrans-4454
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**遍历字典**'
- en: 'You can loop through a dictionary using a for-in loop. Because each item has
    a key and a value, you can do this in two different ways. This is how to loop
    through a dictionary using its keys:'
  id: totrans-4455
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用for-in循环遍历字典。因为每个项都有一个键和值，所以你可以通过两种不同的方式来进行。以下是如何使用字典的键来遍历字典：
- en: '![Image](Image00149.jpg)'
  id: totrans-4456
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00149.jpg)'
- en: Here we use the dictionary’s keys property ➊ to loop through fruitBasket and
    print its contents. We start by writing the keyword for , followed by a constant
    name fruit for the dictionary key, the keyword in , the dictionary name, a period,
    and keys .
  id: totrans-4457
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们使用字典的keys属性➊来遍历fruitBasket并打印其内容。我们从编写关键字`for`开始，接着是一个常量名fruit作为字典的键，再加上关键字`in`，然后是字典的名称，接着是一个句点和`keys`。
- en: Inside the braces of our for-in loop, we have access to both the key, which
    we call fruit ➋ , and the value at that key when we force-unwrap its contents
    with fruitBasket[fruit]! ➌ . That value will be the fruit’s price.
  id: totrans-4458
  prefs: []
  type: TYPE_NORMAL
  zh: 在for-in循环的大括号内，我们可以访问到键，也就是我们称之为`fruit`➋，以及该键对应的值，当我们强制解包其内容时使用`fruitBasket[fruit]!`
    ➌。该值将是水果的价格。
- en: In this case, it’s safe to force-unwrap the value using an exclamation point
    because we know that the fruit key we’re using is definitely inside the dictionary.
  id: totrans-4459
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，使用感叹号强制解包该值是安全的，因为我们知道我们使用的`fruit`键肯定在字典中。
- en: Any code we put inside the for-in loop will run once for every key in our dictionary.
    So you should see the print statement display three times.
  id: totrans-4460
  prefs: []
  type: TYPE_NORMAL
  zh: 我们放入for-in循环中的任何代码都会对字典中的每个键执行一次。所以你应该看到打印语句被打印三次。
- en: 'We can also loop through the dictionary using its values property:'
  id: totrans-4461
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以通过字典的`values`属性遍历字典：
- en: '![Image](Image00150.jpg)'
  id: totrans-4462
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00150.jpg)'
- en: We use the same style of for-in loop, but now we use a constant to refer to
    each value, which we call price , in the values property. When looping through
    values, we don’t have access to the keys from inside the loop.
  id: totrans-4463
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用相同的for-in循环样式，但现在我们使用一个常量来引用每个值，我们将其称为`price`，它位于values属性中。在遍历值时，我们无法从循环内部访问键。
- en: Another difference to note is that price is not an optional because it’s accessed
    directly as a value in the fruitBasket dictionary. That means we don’t have to
    unwrap it. You should still see the print statement printed three times. [Figure
    6-6](text00016.html#ch06fig6) shows the output of both loops.
  id: totrans-4464
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个需要注意的区别是，`price`不是可选的，因为它是直接作为值从fruitBasket字典中访问的。这意味着我们不需要解包它。你仍然应该看到打印语句被打印三次。[图6-6](text00016.html#ch06fig6)显示了两个循环的输出。
- en: '![Image](Image00151.jpg)'
  id: totrans-4465
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00151.jpg)'
- en: '*Figure 6-6: Looping through the keys and values of a dictionary with a for-in
    loop*'
  id: totrans-4466
  prefs: []
  type: TYPE_NORMAL
  zh: '*图6-6：使用for-in循环遍历字典的键和值*'
- en: The order of your results might be slightly different from ours. That’s because
    the items in a dictionary aren’t in a numbered order like they are in an array!
    And because the order is not guaranteed, you might see a different order printed
    if you run the same code again.
  id: totrans-4467
  prefs: []
  type: TYPE_NORMAL
  zh: 你的结果顺序可能会与我们的略有不同。这是因为字典中的项不像数组那样是按编号顺序排列的！由于顺序并不保证，因此如果你再次运行相同的代码，可能会看到不同的顺序打印出来。
- en: '**WHAT YOU LEARNED**'
  id: totrans-4468
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**你学到了什么**'
- en: In this chapter, you learned how to store collections of items in an array and
    in a dictionary. To store items in an ordered list, you would use an array and
    look up each item by its index. If you wanted to store items by key instead, you
    would use a dictionary.
  id: totrans-4469
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你学习了如何将项存储在数组和字典中。要将项存储在有序列表中，你可以使用数组，并通过索引查找每个项。如果你想按键存储项，则应使用字典。
- en: Knowing about arrays and dictionaries and how to use them is a powerful building
    block for almost any programming language. Next we will learn about functions,
    another very powerful tool. Functions are blocks of code that you create and name
    to perform a specific job. After you have written a function, you can use its
    name to call it from almost anywhere in your program.
  id: totrans-4470
  prefs: []
  type: TYPE_NORMAL
  zh: 了解数组和字典以及如何使用它们，是几乎所有编程语言中的一个强大基础构件。接下来，我们将学习函数，另一个非常强大的工具。函数是你创建并命名的代码块，用于执行特定任务。在你编写完函数之后，可以通过它的名称从程序中的几乎任何地方调用它。
- en: 'First, you can use an array’s append(_:) method. *Append* means to add something.
    Using append(_:) , you can add one new item to the end of your array. Say you
    go on another trip and visit the Badlands, and you want to add it to your list
    of national parks. To do that, add this code into your playground:'
  id: totrans-4471
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，你可以使用数组的 append(_:) 方法。*Append* 意味着添加某物。使用 append(_:) 方法，你可以将一个新项目添加到数组的末尾。假设你又去了一次旅行，参观了
    Badlands，并且想要将它加入到你的国家公园列表中。为此，你可以将以下代码添加到你的 playground 中：
- en: '![](Image00120.jpg)'
  id: totrans-4472
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00120.jpg)'
- en: To use the append(_:) method, first write the name of your array followed by
    a period and then append . Then, put the item you want to add to your array inside
    the parentheses. In this case, you put "Badlands" inside the parentheses.
  id: totrans-4473
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用 append(_:) 方法，首先写出你的数组名称，后跟一个句点，然后是 append。接着，将你想要添加到数组中的项目放在圆括号内。在这个例子中，你将
    "Badlands" 放在了圆括号内。
- en: 'If you want to add something at a specific place in your array, use the array’s
    insert(_:at:) method instead. This method takes two arguments: the item that you
    want to insert and the index of where it should go in the array. (We’ll discuss
    arguments in more detail in [Chapter 7](text00017.html#ch07) .)'
  id: totrans-4474
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想要将某物添加到数组中的特定位置，可以改用数组的 insert(_:at:) 方法。这个方法有两个参数：你想要插入的项目和它应该在数组中的位置索引。（我们将在[第7章](text00017.html#ch07)
    中更详细地讨论参数。）
- en: 'Let’s say you totally forgot that you went to the Petrified Forest right after
    you visited the Grand Canyon, and you want to update your nationalParks array
    so it displays the parks in the order in which you visited them. To update your
    array, you could use the insert(_:at:) method to put the Petrified Forest in the
    right position:'
  id: totrans-4475
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你完全忘记了你在参观大峡谷之后去了化石森林，现在你想要更新你的 nationalParks 数组，使其按你访问的顺序显示各大公园。要更新你的数组，你可以使用
    insert(_:at:) 方法，将化石森林插入到正确的位置：
- en: '![](Image00121.jpg)'
  id: totrans-4476
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00121.jpg)'
- en: When you insert a new item at index 3, everything that was in the array at index
    3 or higher gets scooted over to make room for the new item. That means the item
    that was at index 3 is now at index 4, the item that was at index 4 is now at
    index 5, and so on. After you add the Petrified Forest, nationalParks is now ["Acadia",
    "Zion", "Grand Canyon", "Petrified Forest", "Badlands"] .
  id: totrans-4477
  prefs: []
  type: TYPE_NORMAL
  zh: 当你在索引 3 处插入新项目时，数组中索引 3 或更高位置的所有项目都会被移到新位置，以腾出空间给新项目。这意味着原本位于索引 3 的项目现在位于索引
    4，原本位于索引 4 的项目现在位于索引 5，以此类推。在你添加化石森林后，nationalParks 数组现在是 ["Acadia", "Zion", "Grand
    Canyon", "Petrified Forest", "Badlands"]。
- en: '**COMBINING ARRAYS**'
  id: totrans-4478
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**合并数组**'
- en: 'Not only can you add new items to an array, but you can also add two arrays
    together using the + and += operators. Let’s say that you have the ingredients
    for a fruit smoothie in two arrays:'
  id: totrans-4479
  prefs: []
  type: TYPE_NORMAL
  zh: 你不仅可以向数组中添加新项目，还可以使用 + 和 += 操作符将两个数组合并。假设你有两个数组，其中包含制作水果果昔的配料：
- en: '![](Image00122.jpg)'
  id: totrans-4480
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00122.jpg)'
- en: Now you can make a delicious smoothie by adding the fruits and liquids arrays.
  id: totrans-4481
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你可以通过添加水果和液体数组来制作美味的果昔。
- en: '![](Image00123.jpg)'
  id: totrans-4482
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00123.jpg)'
- en: The order of the ingredients in smoothie is the same as the order in fruits
    and liquids . If you created smoothie with liquids + fruits , then the liquids
    would come first.
  id: totrans-4483
  prefs: []
  type: TYPE_NORMAL
  zh: 果昔中配料的顺序与水果和液体的顺序相同。如果你是用液体 + 水果来制作果昔，那么液体会排在前面。
- en: 'You use the += operator to add an array to the end of your array. Add some
    whipped cream as follows for extra yumminess:'
  id: totrans-4484
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用 += 操作符将一个数组添加到另一个数组的末尾。为了增加一些美味，可以按以下方式添加一些鲜奶油：
- en: '![](Image00124.jpg)'
  id: totrans-4485
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00124.jpg)'
- en: Note that ["whipped cream"] is an array even though it has a single item in
    it. When you’re using += to append something to an array, you have to make sure
    you’re only trying to add another array. If you were to just write the string
    "whipped cream" without the square brackets around it, you would get an error.
  id: totrans-4486
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，["whipped cream"] 是一个数组，即使它只有一个项目。当你使用 += 向数组追加内容时，必须确保你只是在尝试添加另一个数组。如果你只是写字符串
    "whipped cream" 而没有将其放在方括号内，你会得到一个错误。
- en: '![Image](Image00125.jpg)'
  id: totrans-4487
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00125.jpg)'
- en: '**REMOVING ITEMS FROM AN ARRAY**'
  id: totrans-4488
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**从数组中移除项目**'
- en: 'There are several methods for removing items from an array. Let’s start by
    looking at the array’s removeLast() method. As you might have guessed from its
    name, removeLast() removes the last item from your array. Let’s try it out with
    a shoppingList array:'
  id: totrans-4489
  prefs: []
  type: TYPE_NORMAL
  zh: 有几种方法可以从数组中删除项。我们从数组的 removeLast() 方法开始看看。正如你从它的名字可以猜到的那样，removeLast() 会移除数组中的最后一项。让我们用
    shoppingList 数组试一下：
- en: '![](Image00126.jpg)'
  id: totrans-4490
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00126.jpg)'
- en: Neat! Note that the removeLast() method returns the removed item, so you can
    store it in a new constant or variable if you want.
  id: totrans-4491
  prefs: []
  type: TYPE_NORMAL
  zh: 很酷！请注意，removeLast() 方法会返回被移除的项，因此如果你想，你可以将它存储在一个新的常量或变量中。
- en: 'You can also remove an item from a specific index by using the remove(at:)
    method. Let’s say that your mom doesn’t want you buying any candy and takes that
    off the list:'
  id: totrans-4492
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以使用 remove(at:) 方法从特定索引移除项。假设你的妈妈不希望你买糖果，并把它从列表中拿掉：
- en: '![Image](Image00127.jpg)![](Image00128.jpg)'
  id: totrans-4493
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00127.jpg)![](Image00128.jpg)'
- en: Just like when we added an item to the middle of our array and all the items
    scooted over to make room, if you remove an item from the middle of an array,
    the rest of the items will scoot back to fill in that empty space. The "apples"
    item that was at index 3 is now at index 2, where "candy" was.
  id: totrans-4494
  prefs: []
  type: TYPE_NORMAL
  zh: 就像我们在数组中间添加项时，所有的项会移过去腾出空间一样，如果你从数组中间删除项，其余的项会移回来填补这个空位。曾经在索引 3 处的“苹果”项现在位于索引
    2 处，即“糖果”所在的位置。
- en: 'You can also remove all items from an array with removeAll() . Try entering
    this into your playground:'
  id: totrans-4495
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以使用 removeAll() 方法从数组中移除所有项。尝试将此输入到你的游乐场中：
- en: '![](Image00129.jpg)'
  id: totrans-4496
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00129.jpg)'
- en: 'Note that trying to remove an item at an index that doesn’t exist will give
    you an error:'
  id: totrans-4497
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，尝试删除一个不存在的索引处的项会导致错误：
- en: '![](Image00130.jpg)'
  id: totrans-4498
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00130.jpg)'
- en: Our array doesn’t have this many items (in fact, now it’s empty!), so this throws
    an error. We’ll also get an error if we use removeLast() on our empty array, because
    there’s nothing in it—there’s no last index at all! However, removeAll() is always
    safe to use, even on an empty array.
  id: totrans-4499
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的数组没有这么多项（事实上，现在它是空的！），所以会抛出错误。如果我们对空数组使用 removeLast()，也会报错，因为数组里什么都没有——根本没有最后一个索引！然而，removeAll()
    即使在空数组上使用也总是安全的。
- en: '**REPLACING ITEMS IN AN ARRAY**'
  id: totrans-4500
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**替换数组中的项**'
- en: 'To replace an item in an array, you set the index of the array to the new value,
    as shown here:'
  id: totrans-4501
  prefs: []
  type: TYPE_NORMAL
  zh: 要替换数组中的项，你需要将数组的索引设置为新值，如下所示：
- en: '![](Image00131.jpg)'
  id: totrans-4502
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00131.jpg)'
- en: At ➊ , we replaced the item at index 2 (the third item) with "Unicorn" because
    magical animals count as favorite animals, too! At ➋ , we replaced the item at
    index 0 (the first item) with "Bearded dragon" . No, that’s not a real dragon—it’s
    just a lizard!
  id: totrans-4503
  prefs: []
  type: TYPE_NORMAL
  zh: 在 ➊ 处，我们将索引为 2（第三个项目）的项替换为“独角兽”，因为魔法动物也算是最喜欢的动物！在 ➋ 处，我们将索引为 0（第一个项目）的项替换为“胡须龙”。不，这不是一条真正的龙——它只是一个蜥蜴！
- en: Like any time you’re working with array index numbers, you have to be sure an
    item exists in the array at that index before you change its value, or you will
    get an Index out of range error.
  id: totrans-4504
  prefs: []
  type: TYPE_NORMAL
  zh: 就像任何时候你在处理数组索引时，你必须确保该索引位置的项在数组中存在，否则你会遇到“索引超出范围”错误。
- en: '[Figure 6-3](text00016.html#ch06fig3) shows the error that occurs if you try
    to add "Standard poodle" using favoriteAnimals[3] = "Standard poodle" . To add
    an item to the end of an array, you should use the append(_:) method or += , as
    we covered in “[Adding Items to an Array](text00016.html#ch06lev2sec5) ” on [page
    70](text00016.html#page_70) .'
  id: totrans-4505
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 6-3](text00016.html#ch06fig3) 显示了如果你尝试使用 favoriteAnimals[3] = "标准贵宾犬" 来添加“标准贵宾犬”时发生的错误。要将项添加到数组的末尾，你应该使用
    append(_:) 方法或 +=，正如我们在 “[向数组添加项](text00016.html#ch06lev2sec5)” 第 [70 页](text00016.html#page_70)
    中讨论的那样。'
- en: '![Image](Image00132.jpg)'
  id: totrans-4506
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00132.jpg)'
- en: '*Figure 6-3: Don’t try to replace a value at an index beyond the existing array.*'
  id: totrans-4507
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 6-3：不要尝试替换超出现有数组范围的索引处的值。*'
- en: Now you know how to change arrays however you might need to. You can add items,
    take items away, or replace items. Next, we’ll look at how to use the properties
    of arrays to find out even more information about them.
  id: totrans-4508
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你知道了如何根据需要更改数组。你可以添加项、删除项或替换项。接下来，我们将学习如何利用数组的属性来获取更多关于它们的信息。
- en: '![Image](Image00133.jpg)'
  id: totrans-4509
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00133.jpg)'
- en: '**USING ARRAY PROPERTIES**'
  id: totrans-4510
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**使用数组属性**'
- en: In addition to methods like append(_:) and removeLast() , arrays also have *properties*
    . An array’s properties are variables or constants that contain some information
    about the array. Two really helpful properties that you might use are the Boolean
    property isEmpty and the integer property count .
  id: totrans-4511
  prefs: []
  type: TYPE_NORMAL
  zh: 除了像 append(_:) 和 removeLast() 这样的函数，数组还有 *属性*。数组的属性是包含一些关于数组信息的变量或常量。有两个非常有用的属性，你可能会使用，分别是布尔类型的
    isEmpty 属性和整数类型的 count 属性。
- en: The isEmpty property is true or false depending on whether the array is empty,
    and the count property will tell you how many items are in that array.
  id: totrans-4512
  prefs: []
  type: TYPE_NORMAL
  zh: isEmpty 属性根据数组是否为空返回 true 或 false，而 count 属性则会告诉你数组中有多少个项。
- en: 'Check out how these two properties are used in the following if-else statement:'
  id: totrans-4513
  prefs: []
  type: TYPE_NORMAL
  zh: 看一下以下 if-else 语句是如何使用这两个属性的：
- en: '![Image](Image00134.jpg)'
  id: totrans-4514
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00134.jpg)'
- en: 'This if-else statement checks whether the array mySiblings is empty ➊ . If
    it is, then "I don''t have any siblings." is printed. But if there is something
    in the array, then the number of siblings that we have is printed: "I have 3 siblings."
    ➋ .'
  id: totrans-4515
  prefs: []
  type: TYPE_NORMAL
  zh: 这个 if-else 语句检查数组 mySiblings 是否为空 ➊。如果为空，则打印出 "我没有兄弟姐妹。" 如果数组中有内容，则会打印出我们有多少兄弟姐妹：“我有
    3 个兄弟姐妹。” ➋。
- en: '**LOOPING OVER AN ARRAY**'
  id: totrans-4516
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**循环遍历数组**'
- en: 'Sometimes when you’re working with arrays you might want to do something to
    every item in the array. You can use a for-in loop to do that! The following code
    will print every topping in a pizzaToppings array on a separate line:'
  id: totrans-4517
  prefs: []
  type: TYPE_NORMAL
  zh: 有时在处理数组时，你可能想对数组中的每个项做点什么。你可以使用 for-in 循环来实现！以下代码将会在单独的一行中打印出 pizzaToppings
    数组中的每个配料：
- en: '![Image](Image00135.jpg)'
  id: totrans-4518
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00135.jpg)'
- en: To write a for-in loop for the pizzaToppings array, we used the keyword for
    , followed by the constant topping , then the keyword in , and finally the name
    of our array, pizzaToppings . Then we put the statements that we want to run for
    each topping inside the braces of the for-in loop. The constant topping ➊ temporarily
    represents each pizza topping in the array as we loop through it. We could have
    chosen any name for this constant, but it’s a good idea to pick something that
    makes sense. You can see the output of this for-in loop in [Figure 6-4](text00016.html#ch06fig4)
    .
  id: totrans-4519
  prefs: []
  type: TYPE_NORMAL
  zh: 要为 pizzaToppings 数组写一个 for-in 循环，我们使用了关键字 for，接着是常量 topping，然后是关键字 in，最后是我们数组的名称
    pizzaToppings。然后我们将每个配料需要执行的语句放在 for-in 循环的大括号内。常量 topping ➊ 在我们遍历数组时临时代表数组中的每个配料。我们本可以选择任何名字作为这个常量，但最好选一个有意义的名字。你可以在[图
    6-4](text00016.html#ch06fig4) 中看到这个 for-in 循环的输出。
- en: '![Image](Image00136.jpg)'
  id: totrans-4520
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00136.jpg)'
- en: '*Figure 6-4: Output of the example for-in loop*'
  id: totrans-4521
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 6-4：示例 for-in 循环的输出*'
- en: '![Image](Image00137.jpg)'
  id: totrans-4522
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00137.jpg)'
- en: 'Using for-in loops is great for printing every value in an array. If you’re
    working with numbers, you can even use them to perform math operations on each
    item, which makes for some speedy calculations! The following code takes an array
    of numbers and calculates the square for each (the square of a number is that
    number multiplied by itself):'
  id: totrans-4523
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 for-in 循环非常适合打印数组中的每个值。如果你在处理数字，甚至可以使用它们对每个项目执行数学运算，这样就能进行快速的计算！以下代码获取一个数字数组，并计算每个数字的平方（一个数字的平方就是这个数字与自身相乘）：
- en: '![Image](Image00138.jpg)'
  id: totrans-4524
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00138.jpg)'
- en: '[Figure 6-5](text00016.html#ch06fig5) shows the results.'
  id: totrans-4525
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 6-5](text00016.html#ch06fig5) 显示了结果。'
- en: '![Image](Image00139.jpg)'
  id: totrans-4526
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00139.jpg)'
- en: '*Figure 6-5: Printing the squares for each number in the myNumbers array*'
  id: totrans-4527
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 6-5：打印 myNumbers 数组中每个数字的平方*'
- en: '**DICTIONARIES ARE KEY!**'
  id: totrans-4528
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**字典是关键！**'
- en: A *dictionary* is also a collection of values, but instead of an ordered index,
    each value has its own *key* . Because there’s no index, the values are not stored
    in any particular order. To access values in a dictionary, you look them up by
    their key.
  id: totrans-4529
  prefs: []
  type: TYPE_NORMAL
  zh: '*字典*也是一种值的集合，但与有序索引不同，每个值都有自己的 *键*。因为没有索引，所以值没有特定的存储顺序。要访问字典中的值，你需要通过它们的键来查找。'
- en: A key must be unique. You can’t have the same key more than once in the same
    dictionary. If there were two identical keys and you asked the computer to give
    you the value for one of them, the computer wouldn’t know which one to choose!
  id: totrans-4530
  prefs: []
  type: TYPE_NORMAL
  zh: 键必须是唯一的。你不能在同一个字典中有重复的键。如果有两个相同的键，而你要求计算机给出其中一个的值，计算机就不知道该选择哪一个！
- en: Let’s take a look at how to make a dictionary and write keys that will help
    you find all the information you need.
  id: totrans-4531
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如何创建一个字典，并写出帮助你找到所需信息的键。
- en: '![Image](Image00140.jpg)'
  id: totrans-4532
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00140.jpg)'
- en: '**INITIALIZING A DICTIONARY**'
  id: totrans-4533
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**初始化字典**'
- en: 'To create and initialize a dictionary, first write var and the name of your
    dictionary. Then write the keys and corresponding values inside a pair of square
    brackets, similar to an array. Let’s create a dictionary to store the names of
    a few US states. The key for each state will be its two-letter abbreviation:'
  id: totrans-4534
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建并初始化一个字典，首先写 `var` 和字典的名称。然后将键及其对应的值放在一对方括号内，类似于数组。我们来创建一个字典，存储一些美国州的名称。每个州的键将是它的两个字母缩写：
- en: '![](Image00141.jpg)'
  id: totrans-4535
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00141.jpg)'
- en: As you can see, there’s a colon between each key and its value, and the key/value
    pairs are separated by commas.
  id: totrans-4536
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，每个键和值之间有一个冒号，键值对之间用逗号分隔。
- en: Dictionaries are different from arrays in that they are *unordered* . Because
    of that, it’s likely that the order of the states that you see in your results
    pane ➋ is different from the order in which you entered your states ➊ . It might
    even be different than the order that’s printed in this book!
  id: totrans-4537
  prefs: []
  type: TYPE_NORMAL
  zh: 字典与数组的不同之处在于它们是*无序的*。因此，在结果面板中看到的州的顺序➋可能与输入州的顺序➊不同，甚至可能与本书中打印的顺序不同！
- en: As with arrays, you can use var to make a mutable dictionary or use let to make
    an immutable dictionary.
  id: totrans-4538
  prefs: []
  type: TYPE_NORMAL
  zh: 与数组一样，你可以使用 `var` 来创建一个可变字典，或者使用 `let` 来创建一个不可变字典。
- en: 'In Swift, all of the keys of a dictionary must be the same type, and all of
    the values of a dictionary must also be the same type, but the key type doesn’t
    have to match the value type. For example, if you wanted to store a collection
    of fractions, you could use doubles for the keys and strings for the values:'
  id: totrans-4539
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Swift 中，字典的所有键必须是相同的类型，字典的所有值也必须是相同的类型，但键的类型不必与值的类型匹配。例如，如果你想存储一个分数集合，你可以使用
    `Double` 类型作为键，`String` 类型作为值：
- en: '![](Image00142.jpg)'
  id: totrans-4540
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00142.jpg)'
- en: In this dictionary, all of the keys must be doubles, and all of the values must
    be strings. Again, you’ll see that the order of the numbers in the results pane
    can be quite different from the order in which you wrote the fractions in your
    dictionary. This is fine because you don’t need to know the order to access anything.
    You can find any item that you need by its key. Let’s see how!
  id: totrans-4541
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个字典中，所有的键必须是 `Double` 类型，所有的值必须是 `String` 类型。同样，你会发现结果面板中数字的顺序可能与在字典中写入分数的顺序非常不同。这是正常的，因为你不需要知道顺序就能访问任何项。你可以通过键找到你需要的任何项。我们来看看怎么做！
- en: '**ACCESSING VALUES IN A DICTIONARY**'
  id: totrans-4542
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**访问字典中的值**'
- en: 'Looking up a value in a dictionary is similar to how you access a value in
    an array except that you use a key inside the square brackets instead of an index,
    like this: usStates["TX"] .'
  id: totrans-4543
  prefs: []
  type: TYPE_NORMAL
  zh: 在字典中查找一个值与在数组中访问一个值类似，唯一不同的是，你在方括号内使用键而不是索引，例如：`usStates["TX"]`。
- en: There is a big difference, however, in how Swift returns the values from a dictionary.
    When you access a value at an index of an array, you are simply given the value.
    When you access a value with a key in a dictionary, you are given an optional.
  id: totrans-4544
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，Swift 从字典返回值的方式有很大不同。当你访问数组的某个索引处的值时，你只是简单地得到该值。当你通过键访问字典中的值时，你得到的是一个可选值。
- en: In [Chapter 5](text00015.html#ch05) , you learned that optionals might contain
    a value or might be nil . The reason Swift returns optionals when you’re looking
    up items in a dictionary is that the key you used might not exist in the dictionary,
    in which case there’s no value to access. Trying to access a value that doesn’t
    exist would give you a big fat error! To avoid that problem, Swift returns optionals.
    That means you need to unwrap any value you get out of a dictionary before you
    can do anything with it.
  id: totrans-4545
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第 5 章](text00015.html#ch05)中，你学到过可选值可能包含一个值，也可能是 `nil`。Swift 在查找字典中的项时返回可选值的原因是，你使用的键可能在字典中不存在，在这种情况下没有值可供访问。尝试访问一个不存在的值会导致一个严重的错误！为了避免这个问题，Swift
    返回可选值。这意味着你需要解包从字典中获取的任何值，才能对其进行操作。
- en: 'To unwrap an optional, first you check whether it exists using an if-let statement,
    just like we did in [Chapter 5](text00015.html#ch05) . The following code shows
    you how to get a value out of a dictionary:'
  id: totrans-4546
  prefs: []
  type: TYPE_NORMAL
  zh: 要解包一个可选值，首先使用 `if-let` 语句检查它是否存在，就像我们在[第 5 章](text00015.html#ch05)中做的那样。以下代码展示了如何从字典中获取一个值：
- en: '![Image](Image00143.jpg)'
  id: totrans-4547
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00143.jpg)'
- en: To retrieve "Texas" from the dictionary, we use if let to set a constant loneStarState
    to usStates["TX"] ➊ . Because we have this state in our dictionary, the line I
    have Texas in my dictionary. is printed. Next we try to access a state that is
    not in our dictionary by using the key usStates["FL"] ➋ . Thankfully, because
    we used an if-let statement, the program won’t crash when the computer can’t find
    this state. Instead, I don't have that state in my dictionary. is printed.
  id: totrans-4548
  prefs: []
  type: TYPE_NORMAL
  zh: 要从字典中检索“Texas”，我们使用if let将常量loneStarState设置为usStates["TX"] ➊。因为我们在字典中有这个州，所以打印出“I
    have Texas in my dictionary.”接下来，我们尝试通过使用键usStates["FL"] ➋来访问一个不在字典中的州。幸运的是，因为我们使用了if-let语句，当计算机找不到该州时，程序不会崩溃。相反，打印出“I
    don't have that state in my dictionary.”。
- en: '**ADDING ITEMS TO A DICTIONARY**'
  id: totrans-4549
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**向字典中添加项**'
- en: 'To add an item to a dictionary, first write the name of your dictionary and
    assign the new item to the key you want it to have in the dictionary. Let’s add
    "Minnesota" to our usStates dictionary:'
  id: totrans-4550
  prefs: []
  type: TYPE_NORMAL
  zh: 向字典中添加项时，首先写出字典的名称，并将新项赋给你想要在字典中使用的键。让我们把“Minnesota”添加到我们的usStates字典中：
- en: '![](Image00144.jpg)'
  id: totrans-4551
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00144.jpg)'
- en: 'Now when you look at usStates , you’ll see that it’s updated to ["MN": "Minnesota",
    "WA": "Washington", "MA": "Massachusetts", "TX": "Texas"] . Remember, because
    you don’t have to rely on indices, your new dictionary item might appear anywhere
    in the dictionary.'
  id: totrans-4552
  prefs: []
  type: TYPE_NORMAL
  zh: '现在当你查看usStates时，你会看到它已经更新为["MN": "Minnesota", "WA": "Washington", "MA": "Massachusetts",
    "TX": "Texas"]。记住，因为你不需要依赖索引，新的字典项可能会出现在字典的任何位置。'
- en: '**REMOVING ITEMS FROM A DICTIONARY**'
  id: totrans-4553
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**从字典中删除项**'
- en: Removing an item from a dictionary is quite simple; you do so by setting the
    value to nil . Because the values in dictionaries are returned as optionals, you
    don’t have to worry about nil causing any problems in your dictionary.
  id: totrans-4554
  prefs: []
  type: TYPE_NORMAL
  zh: 从字典中删除项非常简单；你只需将值设置为nil。因为字典中的值是作为可选值返回的，所以你不必担心nil会在字典中引发任何问题。
- en: '![](Image00145.jpg)'
  id: totrans-4555
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00145.jpg)'
- en: 'You can see that after you remove the value at the key "MA" , usStates is updated
    to ["MN": "Minnesota", "WA": "Washington", "TX": "Texas"] . Remember that nil
    is special and means that there’s no value at all. That’s why you don’t see "MA":
    nil in our dictionary.'
  id: totrans-4556
  prefs: []
  type: TYPE_NORMAL
  zh: '你可以看到，在你删除键“MA”对应的值之后，usStates更新为["MN": "Minnesota", "WA": "Washington", "TX":
    "Texas"]。记住，nil是特殊的，意味着没有任何值。这就是为什么你在字典中看不到"MA": nil的原因。'
- en: '**REPLACING ITEMS IN A DICTIONARY**'
  id: totrans-4557
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**替换字典中的项**'
- en: 'Replacing an item in a dictionary is also easy. It works the same was as replacing
    an item in an array. You just set the item that you want to replace to something
    else. Say you create a dictionary of fruit colors:'
  id: totrans-4558
  prefs: []
  type: TYPE_NORMAL
  zh: 替换字典中的项也很简单。它的工作方式和替换数组中的项一样。你只需将想要替换的项设置为其他值。假设你创建了一个水果颜色的字典：
- en: '![](Image00146.jpg)'
  id: totrans-4559
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00146.jpg)'
- en: At first we had the value "apple" for "red" , but then we decided that "raspberry"
    is a better fruit to use since sometimes apples are green or yellow. To replace
    "apple" with "raspberry" , we set colorFruits["red"] to its new value ➊ .
  id: totrans-4560
  prefs: []
  type: TYPE_NORMAL
  zh: 起初，我们为“red”赋了值“apple”，但后来我们决定使用“raspberry”作为更合适的水果，因为有时候苹果是绿色或黄色的。为了用“raspberry”替换“apple”，我们将colorFruits["red"]设置为其新值➊。
- en: You may remember that this is the same way we entered a new value into a dictionary.
    If the key already exists in the dictionary, then the value for that key is replaced.
    If the key doesn’t already exist, then the new key/value pair will be added to
    the dictionary.
  id: totrans-4561
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能还记得，这和我们向字典中插入新值的方式相同。如果键已经存在于字典中，那么该键的值将被替换。如果键不存在，则新键/值对将被添加到字典中。
- en: '![Image](Image00147.jpg)'
  id: totrans-4562
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00147.jpg)'
- en: '**USING DICTIONARY PROPERTIES**'
  id: totrans-4563
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**使用字典属性**'
- en: 'Like an array, a dictionary also has an isEmpty property and a count property.
    For example, the following code shows how you can use the isEmpty property to
    check if a dictionary is empty, and if it isn’t empty, the count property checks
    how many items you have. Imagine you have a basket of fruit for sale. You can
    use these properties to help you keep track of everything:'
  id: totrans-4564
  prefs: []
  type: TYPE_NORMAL
  zh: 像数组一样，字典也有isEmpty属性和count属性。例如，以下代码展示了如何使用isEmpty属性检查字典是否为空，如果不为空，count属性会检查字典中有多少项。假设你有一个待售的水果篮。你可以使用这些属性来帮助你跟踪所有物品：
- en: '![Image](Image00148.jpg)'
  id: totrans-4565
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00148.jpg)'
- en: 'A dictionary also has two special properties: keys , which contains all of
    the dictionary’s keys, and values , which contains all of its values. We’ll use
    these two properties when we loop through the dictionary.'
  id: totrans-4566
  prefs: []
  type: TYPE_NORMAL
  zh: 字典还有两个特殊属性：keys，包含字典中的所有键，以及values，包含所有的值。当我们遍历字典时，会使用这两个属性。
- en: Let’s write some code that loops through our fruit baskets and prints the price
    of each fruit.
  id: totrans-4567
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们写一些代码，遍历我们的水果篮并打印每个水果的价格。
- en: '**LOOPING OVER A DICTIONARY**'
  id: totrans-4568
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**遍历字典**'
- en: 'You can loop through a dictionary using a for-in loop. Because each item has
    a key and a value, you can do this in two different ways. This is how to loop
    through a dictionary using its keys:'
  id: totrans-4569
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用 `for-in` 循环遍历字典。由于每个项目都有一个键和值，因此你可以通过两种不同的方式来进行遍历。以下是通过键遍历字典的方法：
- en: '![Image](Image00149.jpg)'
  id: totrans-4570
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00149.jpg)'
- en: Here we use the dictionary’s keys property ➊ to loop through fruitBasket and
    print its contents. We start by writing the keyword for , followed by a constant
    name fruit for the dictionary key, the keyword in , the dictionary name, a period,
    and keys .
  id: totrans-4571
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们使用字典的键属性 ➊ 来遍历 fruitBasket 并打印其内容。我们首先写下关键字 `for`，然后是字典键的常量名称 `fruit`，接着是关键字
    `in`，字典名称，一个句点，最后是 `keys`。
- en: Inside the braces of our for-in loop, we have access to both the key, which
    we call fruit ➋ , and the value at that key when we force-unwrap its contents
    with fruitBasket[fruit]! ➌ . That value will be the fruit’s price.
  id: totrans-4572
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `for-in` 循环的大括号内部，我们可以访问键（我们称之为 `fruit` ➋）以及当我们强制解包其内容时通过 `fruitBasket[fruit]!`
    ➌ 访问到的值。这个值将是水果的价格。
- en: In this case, it’s safe to force-unwrap the value using an exclamation point
    because we know that the fruit key we’re using is definitely inside the dictionary.
  id: totrans-4573
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，使用感叹号强制解包值是安全的，因为我们知道我们使用的 `fruit` 键肯定存在于字典中。
- en: Any code we put inside the for-in loop will run once for every key in our dictionary.
    So you should see the print statement display three times.
  id: totrans-4574
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在 `for-in` 循环中写的任何代码都会在字典中的每个键上执行一次。所以你应该会看到打印语句显示三次。
- en: 'We can also loop through the dictionary using its values property:'
  id: totrans-4575
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以使用字典的 `values` 属性来进行遍历：
- en: '![Image](Image00150.jpg)'
  id: totrans-4576
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00150.jpg)'
- en: We use the same style of for-in loop, but now we use a constant to refer to
    each value, which we call price , in the values property. When looping through
    values, we don’t have access to the keys from inside the loop.
  id: totrans-4577
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用相同样式的 `for-in` 循环，但现在我们使用常量来引用每个值，我们称之为 `price`，这个值来自 `values` 属性。在遍历值时，我们无法从循环内部访问键。
- en: Another difference to note is that price is not an optional because it’s accessed
    directly as a value in the fruitBasket dictionary. That means we don’t have to
    unwrap it. You should still see the print statement printed three times. [Figure
    6-6](text00016.html#ch06fig6) shows the output of both loops.
  id: totrans-4578
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个需要注意的区别是，`price` 不是可选的，因为它是直接作为 `fruitBasket` 字典中的值访问的。这意味着我们不需要解包它。你应该仍然会看到打印语句显示三次。[图
    6-6](text00016.html#ch06fig6) 显示了两个循环的输出。
- en: '![Image](Image00151.jpg)'
  id: totrans-4579
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00151.jpg)'
- en: '*Figure 6-6: Looping through the keys and values of a dictionary with a for-in
    loop*'
  id: totrans-4580
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 6-6：使用 `for-in` 循环遍历字典的键和值*'
- en: The order of your results might be slightly different from ours. That’s because
    the items in a dictionary aren’t in a numbered order like they are in an array!
    And because the order is not guaranteed, you might see a different order printed
    if you run the same code again.
  id: totrans-4581
  prefs: []
  type: TYPE_NORMAL
  zh: 你的结果顺序可能会与我们的稍有不同。那是因为字典中的项目不像数组中的项目那样按编号排序！由于顺序无法保证，因此如果你再次运行相同的代码，你可能会看到不同的顺序打印出来。
- en: '**WHAT YOU LEARNED**'
  id: totrans-4582
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**你学到了什么**'
- en: In this chapter, you learned how to store collections of items in an array and
    in a dictionary. To store items in an ordered list, you would use an array and
    look up each item by its index. If you wanted to store items by key instead, you
    would use a dictionary.
  id: totrans-4583
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一章中，你学习了如何将一系列项目存储在数组和字典中。要将项目存储在有序列表中，你将使用数组，并通过索引查找每个项目。如果你想按键来存储项目，则应该使用字典。
- en: Knowing about arrays and dictionaries and how to use them is a powerful building
    block for almost any programming language. Next we will learn about functions,
    another very powerful tool. Functions are blocks of code that you create and name
    to perform a specific job. After you have written a function, you can use its
    name to call it from almost anywhere in your program.
  id: totrans-4584
  prefs: []
  type: TYPE_NORMAL
  zh: 了解数组和字典及其使用方法是几乎所有编程语言的强大构建块。接下来，我们将学习函数，这是另一个非常强大的工具。函数是你创建并命名的代码块，用于执行特定的任务。写完函数后，你可以使用它的名称从程序中的几乎任何地方调用它。
- en: '![](Image00120.jpg)'
  id: totrans-4585
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00120.jpg)'
- en: To use the append(_:) method, first write the name of your array followed by
    a period and then append . Then, put the item you want to add to your array inside
    the parentheses. In this case, you put "Badlands" inside the parentheses.
  id: totrans-4586
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用 append(_:) 方法，首先写出数组的名字，后面跟一个句点，再加上 append。然后，把你想要添加的项放在括号内。在这种情况下，你将 "Badlands"
    放入括号内。
- en: 'If you want to add something at a specific place in your array, use the array’s
    insert(_:at:) method instead. This method takes two arguments: the item that you
    want to insert and the index of where it should go in the array. (We’ll discuss
    arguments in more detail in [Chapter 7](text00017.html#ch07) .)'
  id: totrans-4587
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想在数组中的特定位置添加某个项，使用数组的 insert(_:at:) 方法。这个方法有两个参数：你想插入的项和它应该插入的位置索引。（我们将在[第七章](text00017.html#ch07)
    中更详细地讨论参数。）
- en: 'Let’s say you totally forgot that you went to the Petrified Forest right after
    you visited the Grand Canyon, and you want to update your nationalParks array
    so it displays the parks in the order in which you visited them. To update your
    array, you could use the insert(_:at:) method to put the Petrified Forest in the
    right position:'
  id: totrans-4588
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你完全忘记了你在参观大峡谷后去了石化森林，并且你想更新你的 nationalParks 数组，以便它按你参观的顺序显示公园。要更新数组，你可以使用
    insert(_:at:) 方法将石化森林放在正确的位置：
- en: '![](Image00121.jpg)'
  id: totrans-4589
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00121.jpg)'
- en: When you insert a new item at index 3, everything that was in the array at index
    3 or higher gets scooted over to make room for the new item. That means the item
    that was at index 3 is now at index 4, the item that was at index 4 is now at
    index 5, and so on. After you add the Petrified Forest, nationalParks is now ["Acadia",
    "Zion", "Grand Canyon", "Petrified Forest", "Badlands"] .
  id: totrans-4590
  prefs: []
  type: TYPE_NORMAL
  zh: 当你在索引 3 处插入新项时，数组中索引为 3 或更高的所有项都会被推到后面，为新项腾出空间。这意味着原来在索引 3 的项现在会变成索引 4，原来在索引
    4 的项现在会变成索引 5，以此类推。在添加石化森林后，nationalParks 数组现在变为 ["Acadia", "Zion", "Grand Canyon",
    "Petrified Forest", "Badlands"]。
- en: '**COMBINING ARRAYS**'
  id: totrans-4591
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**合并数组**'
- en: 'Not only can you add new items to an array, but you can also add two arrays
    together using the + and += operators. Let’s say that you have the ingredients
    for a fruit smoothie in two arrays:'
  id: totrans-4592
  prefs: []
  type: TYPE_NORMAL
  zh: 你不仅可以向数组添加新项，还可以使用 + 和 += 运算符将两个数组合并。假设你有两组水果冰沙的配料数组：
- en: '![](Image00122.jpg)'
  id: totrans-4593
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00122.jpg)'
- en: Now you can make a delicious smoothie by adding the fruits and liquids arrays.
  id: totrans-4594
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你可以通过添加水果和液体数组来制作美味的冰沙。
- en: '![](Image00123.jpg)'
  id: totrans-4595
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00123.jpg)'
- en: The order of the ingredients in smoothie is the same as the order in fruits
    and liquids . If you created smoothie with liquids + fruits , then the liquids
    would come first.
  id: totrans-4596
  prefs: []
  type: TYPE_NORMAL
  zh: 冰沙中配料的顺序与水果和液体的顺序相同。如果你制作的是液体 + 水果的冰沙，那么液体应该先放。
- en: 'You use the += operator to add an array to the end of your array. Add some
    whipped cream as follows for extra yumminess:'
  id: totrans-4597
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用 += 运算符将一个数组添加到另一个数组的末尾。为了增加额外的美味，可以按如下方式加入一些鲜奶油：
- en: '![](Image00124.jpg)'
  id: totrans-4598
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00124.jpg)'
- en: Note that ["whipped cream"] is an array even though it has a single item in
    it. When you’re using += to append something to an array, you have to make sure
    you’re only trying to add another array. If you were to just write the string
    "whipped cream" without the square brackets around it, you would get an error.
  id: totrans-4599
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，["whipped cream"] 是一个数组，即使它只有一个项。当你使用 += 向数组添加内容时，必须确保你添加的是另一个数组。如果你只是写
    "whipped cream"（没有方括号），就会发生错误。
- en: '![Image](Image00125.jpg)'
  id: totrans-4600
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00125.jpg)'
- en: '**REMOVING ITEMS FROM AN ARRAY**'
  id: totrans-4601
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**从数组中移除项**'
- en: 'There are several methods for removing items from an array. Let’s start by
    looking at the array’s removeLast() method. As you might have guessed from its
    name, removeLast() removes the last item from your array. Let’s try it out with
    a shoppingList array:'
  id: totrans-4602
  prefs: []
  type: TYPE_NORMAL
  zh: 有几种方法可以从数组中移除项。让我们先来看一下数组的 removeLast() 方法。你可能从它的名字猜到，removeLast() 会移除数组中的最后一项。让我们用一个
    shoppingList 数组来试试看：
- en: '![](Image00126.jpg)'
  id: totrans-4603
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00126.jpg)'
- en: Neat! Note that the removeLast() method returns the removed item, so you can
    store it in a new constant or variable if you want.
  id: totrans-4604
  prefs: []
  type: TYPE_NORMAL
  zh: 很棒！请注意，removeLast() 方法会返回被移除的项，因此如果你想，可以将它存储在一个新的常量或变量中。
- en: 'You can also remove an item from a specific index by using the remove(at:)
    method. Let’s say that your mom doesn’t want you buying any candy and takes that
    off the list:'
  id: totrans-4605
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以通过使用 remove(at:) 方法从特定索引移除某项。假设你的妈妈不想你买糖果，于是她把糖果从清单上移除：
- en: '![Image](Image00127.jpg)![](Image00128.jpg)'
  id: totrans-4606
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00127.jpg)![](Image00128.jpg)'
- en: Just like when we added an item to the middle of our array and all the items
    scooted over to make room, if you remove an item from the middle of an array,
    the rest of the items will scoot back to fill in that empty space. The "apples"
    item that was at index 3 is now at index 2, where "candy" was.
  id: totrans-4607
  prefs: []
  type: TYPE_NORMAL
  zh: 就像我们在数组中间添加一个元素时，所有的元素会向后移动腾出空间一样，如果你从数组中间删除一个元素，剩下的元素会向前移动填补那个空位。原本在索引3处的"apples"现在被移到了索引2的位置，那里原本是"candy"。
- en: 'You can also remove all items from an array with removeAll() . Try entering
    this into your playground:'
  id: totrans-4608
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以使用removeAll()来删除数组中的所有项。试着在你的playground中输入这个代码：
- en: '![](Image00129.jpg)'
  id: totrans-4609
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00129.jpg)'
- en: 'Note that trying to remove an item at an index that doesn’t exist will give
    you an error:'
  id: totrans-4610
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，尝试删除一个不存在的索引位置的元素会导致错误：
- en: '![](Image00130.jpg)'
  id: totrans-4611
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00130.jpg)'
- en: Our array doesn’t have this many items (in fact, now it’s empty!), so this throws
    an error. We’ll also get an error if we use removeLast() on our empty array, because
    there’s nothing in it—there’s no last index at all! However, removeAll() is always
    safe to use, even on an empty array.
  id: totrans-4612
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的数组没有这么多元素（实际上现在它是空的！），所以这会抛出一个错误。如果我们在空数组上使用removeLast()，也会出错，因为数组中没有元素——根本没有最后一个索引！然而，removeAll()方法在任何时候使用都是安全的，即使是空数组。
- en: '**REPLACING ITEMS IN AN ARRAY**'
  id: totrans-4613
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**替换数组中的元素**'
- en: 'To replace an item in an array, you set the index of the array to the new value,
    as shown here:'
  id: totrans-4614
  prefs: []
  type: TYPE_NORMAL
  zh: 要替换数组中的项，你需要将数组的索引设置为新的值，如下所示：
- en: '![](Image00131.jpg)'
  id: totrans-4615
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00131.jpg)'
- en: At ➊ , we replaced the item at index 2 (the third item) with "Unicorn" because
    magical animals count as favorite animals, too! At ➋ , we replaced the item at
    index 0 (the first item) with "Bearded dragon" . No, that’s not a real dragon—it’s
    just a lizard!
  id: totrans-4616
  prefs: []
  type: TYPE_NORMAL
  zh: 在➊处，我们将索引2（第三个元素）处的项替换为"Unicorn"，因为魔法动物也算是最喜欢的动物！在➋处，我们将索引0（第一个元素）处的项替换为"Bearded
    dragon"。不，那不是真的龙——它只是一个蜥蜴！
- en: Like any time you’re working with array index numbers, you have to be sure an
    item exists in the array at that index before you change its value, or you will
    get an Index out of range error.
  id: totrans-4617
  prefs: []
  type: TYPE_NORMAL
  zh: 就像每次操作数组索引时一样，你必须确保在修改值之前该索引位置的元素确实存在，否则你会得到一个索引超出范围的错误。
- en: '[Figure 6-3](text00016.html#ch06fig3) shows the error that occurs if you try
    to add "Standard poodle" using favoriteAnimals[3] = "Standard poodle" . To add
    an item to the end of an array, you should use the append(_:) method or += , as
    we covered in “[Adding Items to an Array](text00016.html#ch06lev2sec5) ” on [page
    70](text00016.html#page_70) .'
  id: totrans-4618
  prefs: []
  type: TYPE_NORMAL
  zh: '[图6-3](text00016.html#ch06fig3)展示了如果你尝试通过favoriteAnimals[3] = "Standard poodle"来添加"Standard
    poodle"时出现的错误。要将一个元素添加到数组末尾，应该使用append(_:)方法或+=，正如我们在"[向数组添加元素](text00016.html#ch06lev2sec5)"一节中讲到的，见[第70页](text00016.html#page_70)。'
- en: '![Image](Image00132.jpg)'
  id: totrans-4619
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00132.jpg)'
- en: '*Figure 6-3: Don’t try to replace a value at an index beyond the existing array.*'
  id: totrans-4620
  prefs: []
  type: TYPE_NORMAL
  zh: '*图6-3：不要试图替换数组中超出范围的索引的值。*'
- en: Now you know how to change arrays however you might need to. You can add items,
    take items away, or replace items. Next, we’ll look at how to use the properties
    of arrays to find out even more information about them.
  id: totrans-4621
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你知道了如何根据需要修改数组。你可以添加元素、删除元素或替换元素。接下来，我们将看看如何使用数组的属性来获取更多关于它们的信息。
- en: '![Image](Image00133.jpg)'
  id: totrans-4622
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00133.jpg)'
- en: '**USING ARRAY PROPERTIES**'
  id: totrans-4623
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**使用数组属性**'
- en: In addition to methods like append(_:) and removeLast() , arrays also have *properties*
    . An array’s properties are variables or constants that contain some information
    about the array. Two really helpful properties that you might use are the Boolean
    property isEmpty and the integer property count .
  id: totrans-4624
  prefs: []
  type: TYPE_NORMAL
  zh: 除了像append(_:)和removeLast()这样的函数，数组还有*属性*。数组的属性是包含数组相关信息的变量或常量。你可能会用到的两个非常有用的属性是布尔类型的isEmpty属性和整数类型的count属性。
- en: The isEmpty property is true or false depending on whether the array is empty,
    and the count property will tell you how many items are in that array.
  id: totrans-4625
  prefs: []
  type: TYPE_NORMAL
  zh: isEmpty属性的值取决于数组是否为空，count属性则告诉你数组中有多少个元素。
- en: 'Check out how these two properties are used in the following if-else statement:'
  id: totrans-4626
  prefs: []
  type: TYPE_NORMAL
  zh: 看看这两个属性在以下的if-else语句中是如何使用的：
- en: '![Image](Image00134.jpg)'
  id: totrans-4627
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00134.jpg)'
- en: 'This if-else statement checks whether the array mySiblings is empty ➊ . If
    it is, then "I don''t have any siblings." is printed. But if there is something
    in the array, then the number of siblings that we have is printed: "I have 3 siblings."
    ➋ .'
  id: totrans-4628
  prefs: []
  type: TYPE_NORMAL
  zh: 这个if-else语句检查数组mySiblings是否为空➊。如果为空，就打印"我没有兄弟姐妹"。但如果数组中有元素，则会打印出我们有多少个兄弟姐妹："我有3个兄弟姐妹。"➋。
- en: '**LOOPING OVER AN ARRAY**'
  id: totrans-4629
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**遍历数组**'
- en: 'Sometimes when you’re working with arrays you might want to do something to
    every item in the array. You can use a for-in loop to do that! The following code
    will print every topping in a pizzaToppings array on a separate line:'
  id: totrans-4630
  prefs: []
  type: TYPE_NORMAL
  zh: 有时在处理数组时，你可能想对数组中的每个项目做一些操作。你可以使用for-in循环来做到这一点！以下代码会将pizzaToppings数组中的每个配料打印到单独的一行：
- en: '![Image](Image00135.jpg)'
  id: totrans-4631
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00135.jpg)'
- en: To write a for-in loop for the pizzaToppings array, we used the keyword for
    , followed by the constant topping , then the keyword in , and finally the name
    of our array, pizzaToppings . Then we put the statements that we want to run for
    each topping inside the braces of the for-in loop. The constant topping ➊ temporarily
    represents each pizza topping in the array as we loop through it. We could have
    chosen any name for this constant, but it’s a good idea to pick something that
    makes sense. You can see the output of this for-in loop in [Figure 6-4](text00016.html#ch06fig4)
    .
  id: totrans-4632
  prefs: []
  type: TYPE_NORMAL
  zh: 要为pizzaToppings数组编写一个for-in循环，我们使用了关键字for，后面跟着常量topping，然后是关键字in，最后是我们的数组名称pizzaToppings。接着，我们将希望为每个topping运行的语句放入for-in循环的大括号中。常量topping
    ➊在我们循环遍历数组时临时代表数组中的每个披萨配料。我们本可以为这个常量选择任何名称，但选择一个有意义的名称是一个好主意。你可以在[图6-4](text00016.html#ch06fig4)中看到这个for-in循环的输出。
- en: '![Image](Image00136.jpg)'
  id: totrans-4633
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00136.jpg)'
- en: '*Figure 6-4: Output of the example for-in loop*'
  id: totrans-4634
  prefs: []
  type: TYPE_NORMAL
  zh: '*图6-4：示例for-in循环的输出*'
- en: '![Image](Image00137.jpg)'
  id: totrans-4635
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00137.jpg)'
- en: 'Using for-in loops is great for printing every value in an array. If you’re
    working with numbers, you can even use them to perform math operations on each
    item, which makes for some speedy calculations! The following code takes an array
    of numbers and calculates the square for each (the square of a number is that
    number multiplied by itself):'
  id: totrans-4636
  prefs: []
  type: TYPE_NORMAL
  zh: 使用for-in循环非常适合打印数组中的每个值。如果你在处理数字，甚至可以用它们对每个项目进行数学运算，这使得计算速度非常快！以下代码会计算一个数字数组中每个数字的平方（一个数字的平方是该数字与自身相乘）：
- en: '![Image](Image00138.jpg)'
  id: totrans-4637
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00138.jpg)'
- en: '[Figure 6-5](text00016.html#ch06fig5) shows the results.'
  id: totrans-4638
  prefs: []
  type: TYPE_NORMAL
  zh: '[图6-5](text00016.html#ch06fig5)显示了结果。'
- en: '![Image](Image00139.jpg)'
  id: totrans-4639
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00139.jpg)'
- en: '*Figure 6-5: Printing the squares for each number in the myNumbers array*'
  id: totrans-4640
  prefs: []
  type: TYPE_NORMAL
  zh: '*图6-5：打印myNumbers数组中每个数字的平方*'
- en: '**DICTIONARIES ARE KEY!**'
  id: totrans-4641
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**字典是关键！**'
- en: A *dictionary* is also a collection of values, but instead of an ordered index,
    each value has its own *key* . Because there’s no index, the values are not stored
    in any particular order. To access values in a dictionary, you look them up by
    their key.
  id: totrans-4642
  prefs: []
  type: TYPE_NORMAL
  zh: '*字典*也是一个值的集合，但与有序索引的数组不同，每个值都有自己的*键*。由于没有索引，值不会以任何特定顺序存储。要访问字典中的值，你需要通过它们的键进行查找。'
- en: A key must be unique. You can’t have the same key more than once in the same
    dictionary. If there were two identical keys and you asked the computer to give
    you the value for one of them, the computer wouldn’t know which one to choose!
  id: totrans-4643
  prefs: []
  type: TYPE_NORMAL
  zh: 键必须是唯一的。在同一个字典中，不能有相同的键。如果有两个相同的键，而你要求计算机返回其中一个的值，计算机将不知道选择哪一个！
- en: Let’s take a look at how to make a dictionary and write keys that will help
    you find all the information you need.
  id: totrans-4644
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如何创建一个字典并写入键，这些键将帮助你找到你所需要的所有信息。
- en: '![Image](Image00140.jpg)'
  id: totrans-4645
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00140.jpg)'
- en: '**INITIALIZING A DICTIONARY**'
  id: totrans-4646
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**初始化字典**'
- en: 'To create and initialize a dictionary, first write var and the name of your
    dictionary. Then write the keys and corresponding values inside a pair of square
    brackets, similar to an array. Let’s create a dictionary to store the names of
    a few US states. The key for each state will be its two-letter abbreviation:'
  id: totrans-4647
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建并初始化一个字典，首先写下var和字典的名称。然后在一对方括号中写入键及其对应的值，类似于数组。让我们创建一个字典来存储一些美国州的名称。每个州的键将是它的两位字母缩写：
- en: '![](Image00141.jpg)'
  id: totrans-4648
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00141.jpg)'
- en: As you can see, there’s a colon between each key and its value, and the key/value
    pairs are separated by commas.
  id: totrans-4649
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，每个键和值之间有一个冒号，键/值对之间用逗号分隔。
- en: Dictionaries are different from arrays in that they are *unordered* . Because
    of that, it’s likely that the order of the states that you see in your results
    pane ➋ is different from the order in which you entered your states ➊ . It might
    even be different than the order that’s printed in this book!
  id: totrans-4650
  prefs: []
  type: TYPE_NORMAL
  zh: 字典与数组的不同之处在于它们是*无序的*。因此，你在结果窗格中看到的状态顺序 ➋ 可能与你输入状态的顺序 ➊ 不同。它甚至可能与本书中打印的顺序不同！
- en: As with arrays, you can use var to make a mutable dictionary or use let to make
    an immutable dictionary.
  id: totrans-4651
  prefs: []
  type: TYPE_NORMAL
  zh: 与数组一样，你可以使用var来创建一个可变字典，或使用let来创建一个不可变字典。
- en: 'In Swift, all of the keys of a dictionary must be the same type, and all of
    the values of a dictionary must also be the same type, but the key type doesn’t
    have to match the value type. For example, if you wanted to store a collection
    of fractions, you could use doubles for the keys and strings for the values:'
  id: totrans-4652
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Swift 中，字典的所有键必须是相同类型的，字典的所有值也必须是相同类型的，但键的类型不一定需要与值的类型相匹配。例如，如果你想存储一组分数，你可以使用浮动类型作为键，字符串作为值：
- en: '![](Image00142.jpg)'
  id: totrans-4653
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00142.jpg)'
- en: In this dictionary, all of the keys must be doubles, and all of the values must
    be strings. Again, you’ll see that the order of the numbers in the results pane
    can be quite different from the order in which you wrote the fractions in your
    dictionary. This is fine because you don’t need to know the order to access anything.
    You can find any item that you need by its key. Let’s see how!
  id: totrans-4654
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个字典中，所有的键必须是浮动类型（doubles），所有的值必须是字符串类型（strings）。再次强调，你会发现结果面板中的数字顺序可能与字典中你编写分数时的顺序不同。这是可以接受的，因为你不需要知道顺序就可以访问任何内容。你可以通过键来找到你需要的任何项目。让我们看看怎么做！
- en: '**ACCESSING VALUES IN A DICTIONARY**'
  id: totrans-4655
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**访问字典中的值**'
- en: 'Looking up a value in a dictionary is similar to how you access a value in
    an array except that you use a key inside the square brackets instead of an index,
    like this: usStates["TX"] .'
  id: totrans-4656
  prefs: []
  type: TYPE_NORMAL
  zh: 在字典中查找一个值类似于你在数组中访问一个值的方式，不同之处在于你在方括号中使用的是键，而不是索引，就像这样：usStates["TX"]。
- en: There is a big difference, however, in how Swift returns the values from a dictionary.
    When you access a value at an index of an array, you are simply given the value.
    When you access a value with a key in a dictionary, you are given an optional.
  id: totrans-4657
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，Swift 从字典返回值的方式有很大的不同。当你在数组中通过索引访问一个值时，你只是简单地得到了那个值。当你在字典中通过键访问一个值时，你得到的是一个可选值。
- en: In [Chapter 5](text00015.html#ch05) , you learned that optionals might contain
    a value or might be nil . The reason Swift returns optionals when you’re looking
    up items in a dictionary is that the key you used might not exist in the dictionary,
    in which case there’s no value to access. Trying to access a value that doesn’t
    exist would give you a big fat error! To avoid that problem, Swift returns optionals.
    That means you need to unwrap any value you get out of a dictionary before you
    can do anything with it.
  id: totrans-4658
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第 5 章](text00015.html#ch05)中，你学到过可选值可能包含一个值，也可能是 nil。Swift 在你查找字典中的项时返回可选值的原因是你使用的键可能在字典中不存在，在这种情况下就没有值可以访问。尝试访问一个不存在的值会导致一个大错误！为了避免这个问题，Swift
    返回了可选值。这意味着，在你对字典中的任何值进行操作之前，你需要先解包它。
- en: 'To unwrap an optional, first you check whether it exists using an if-let statement,
    just like we did in [Chapter 5](text00015.html#ch05) . The following code shows
    you how to get a value out of a dictionary:'
  id: totrans-4659
  prefs: []
  type: TYPE_NORMAL
  zh: 要解包一个可选值，首先你需要使用 if-let 语句检查它是否存在，就像我们在[第 5 章](text00015.html#ch05)中做的那样。下面的代码展示了如何从字典中获取一个值：
- en: '![Image](Image00143.jpg)'
  id: totrans-4660
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00143.jpg)'
- en: To retrieve "Texas" from the dictionary, we use if let to set a constant loneStarState
    to usStates["TX"] ➊ . Because we have this state in our dictionary, the line I
    have Texas in my dictionary. is printed. Next we try to access a state that is
    not in our dictionary by using the key usStates["FL"] ➋ . Thankfully, because
    we used an if-let statement, the program won’t crash when the computer can’t find
    this state. Instead, I don't have that state in my dictionary. is printed.
  id: totrans-4661
  prefs: []
  type: TYPE_NORMAL
  zh: 要从字典中检索 "Texas"，我们使用 if-let 语句将常量 loneStarState 设置为 usStates["TX"] ➊。因为我们在字典中有这个州，所以下面的语句
    "I have Texas in my dictionary." 会被打印出来。接下来，我们尝试使用键 usStates["FL"] ➋ 访问一个不在字典中的州。幸运的是，因为我们使用了
    if-let 语句，当计算机找不到这个州时，程序不会崩溃。相反，"I don't have that state in my dictionary." 会被打印出来。
- en: '**ADDING ITEMS TO A DICTIONARY**'
  id: totrans-4662
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**向字典添加项目**'
- en: 'To add an item to a dictionary, first write the name of your dictionary and
    assign the new item to the key you want it to have in the dictionary. Let’s add
    "Minnesota" to our usStates dictionary:'
  id: totrans-4663
  prefs: []
  type: TYPE_NORMAL
  zh: 要向字典中添加项目，首先写出字典的名称，并将新项目分配给你想要它的键。让我们向 usStates 字典中添加 "Minnesota"：
- en: '![](Image00144.jpg)'
  id: totrans-4664
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00144.jpg)'
- en: 'Now when you look at usStates , you’ll see that it’s updated to ["MN": "Minnesota",
    "WA": "Washington", "MA": "Massachusetts", "TX": "Texas"] . Remember, because
    you don’t have to rely on indices, your new dictionary item might appear anywhere
    in the dictionary.'
  id: totrans-4665
  prefs: []
  type: TYPE_NORMAL
  zh: '现在，当你查看 usStates 时，你会发现它已更新为 ["MN": "Minnesota", "WA": "Washington", "MA":
    "Massachusetts", "TX": "Texas"]。记住，因为你不需要依赖索引，你的新字典项可能出现在字典的任何位置。'
- en: '**REMOVING ITEMS FROM A DICTIONARY**'
  id: totrans-4666
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**从字典中移除项目**'
- en: Removing an item from a dictionary is quite simple; you do so by setting the
    value to nil . Because the values in dictionaries are returned as optionals, you
    don’t have to worry about nil causing any problems in your dictionary.
  id: totrans-4667
  prefs: []
  type: TYPE_NORMAL
  zh: 从字典中移除一项也相当简单；你只需将该项的值设置为 nil。因为字典中的值以可选类型返回，所以你不必担心 nil 会在字典中引起任何问题。
- en: '![](Image00145.jpg)'
  id: totrans-4668
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00145.jpg)'
- en: 'You can see that after you remove the value at the key "MA" , usStates is updated
    to ["MN": "Minnesota", "WA": "Washington", "TX": "Texas"] . Remember that nil
    is special and means that there’s no value at all. That’s why you don’t see "MA":
    nil in our dictionary.'
  id: totrans-4669
  prefs: []
  type: TYPE_NORMAL
  zh: '你可以看到，在移除键 "MA" 的值后，usStates 被更新为 ["MN": "Minnesota", "WA": "Washington", "TX":
    "Texas"]。记住，nil 是特殊的，表示根本没有值。这就是为什么你不会在我们的字典中看到 "MA": nil。'
- en: '**REPLACING ITEMS IN A DICTIONARY**'
  id: totrans-4670
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**替换字典中的项**'
- en: 'Replacing an item in a dictionary is also easy. It works the same was as replacing
    an item in an array. You just set the item that you want to replace to something
    else. Say you create a dictionary of fruit colors:'
  id: totrans-4671
  prefs: []
  type: TYPE_NORMAL
  zh: 替换字典中的项也很简单。它与替换数组中的项的方式相同。你只需将要替换的项设置为其他值。比如你创建了一个水果颜色的字典：
- en: '![](Image00146.jpg)'
  id: totrans-4672
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00146.jpg)'
- en: At first we had the value "apple" for "red" , but then we decided that "raspberry"
    is a better fruit to use since sometimes apples are green or yellow. To replace
    "apple" with "raspberry" , we set colorFruits["red"] to its new value ➊ .
  id: totrans-4673
  prefs: []
  type: TYPE_NORMAL
  zh: 最初我们为 "red" 设置了值 "apple"，但后来我们决定用 "raspberry" 替换它，因为有时苹果是绿色或黄色的。要用 "raspberry"
    替换 "apple"，我们将 colorFruits["red"] 设置为它的新值 ➊。
- en: You may remember that this is the same way we entered a new value into a dictionary.
    If the key already exists in the dictionary, then the value for that key is replaced.
    If the key doesn’t already exist, then the new key/value pair will be added to
    the dictionary.
  id: totrans-4674
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能还记得，这与我们向字典中添加新值的方式相同。如果键已经存在于字典中，那么该键的值将被替换。如果该键不存在，则新的键/值对将被添加到字典中。
- en: '![Image](Image00147.jpg)'
  id: totrans-4675
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Image00147.jpg)'
- en: '**USING DICTIONARY PROPERTIES**'
  id: totrans-4676
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**使用字典属性**'
- en: 'Like an array, a dictionary also has an isEmpty property and a count property.
    For example, the following code shows how you can use the isEmpty property to
    check if a dictionary is empty, and if it isn’t empty, the count property checks
    how many items you have. Imagine you have a basket of fruit for sale. You can
    use these properties to help you keep track of everything:'
  id: totrans-4677
  prefs: []
  type: TYPE_NORMAL
  zh: 像数组一样，字典也有一个 isEmpty 属性和一个 count 属性。例如，以下代码展示了如何使用 isEmpty 属性检查字典是否为空，如果不为空，count
    属性会检查字典中有多少项。假设你有一个待售的水果篮，你可以使用这些属性来帮助你跟踪所有的水果：
- en: '![Image](Image00148.jpg)'
  id: totrans-4678
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Image00148.jpg)'
- en: 'A dictionary also has two special properties: keys , which contains all of
    the dictionary’s keys, and values , which contains all of its values. We’ll use
    these two properties when we loop through the dictionary.'
  id: totrans-4679
  prefs: []
  type: TYPE_NORMAL
  zh: 字典还有两个特殊的属性：keys，包含字典的所有键；以及 values，包含字典的所有值。我们将在遍历字典时使用这两个属性。
- en: Let’s write some code that loops through our fruit baskets and prints the price
    of each fruit.
  id: totrans-4680
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们编写一些代码，遍历我们的水果篮，并打印每种水果的价格。
- en: '**LOOPING OVER A DICTIONARY**'
  id: totrans-4681
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**遍历字典**'
- en: 'You can loop through a dictionary using a for-in loop. Because each item has
    a key and a value, you can do this in two different ways. This is how to loop
    through a dictionary using its keys:'
  id: totrans-4682
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用 for-in 循环遍历字典。因为每个项目都有一个键和值，所以你可以用两种不同的方式来实现。下面是通过键遍历字典的方法：
- en: '![Image](Image00149.jpg)'
  id: totrans-4683
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Image00149.jpg)'
- en: Here we use the dictionary’s keys property ➊ to loop through fruitBasket and
    print its contents. We start by writing the keyword for , followed by a constant
    name fruit for the dictionary key, the keyword in , the dictionary name, a period,
    and keys .
  id: totrans-4684
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们使用字典的键属性 ➊ 来遍历 fruitBasket 并打印其内容。我们首先写出关键字 for，后跟常量名 fruit 作为字典的键，接着是关键字
    in，字典名，一个句点，最后是 keys。
- en: Inside the braces of our for-in loop, we have access to both the key, which
    we call fruit ➋ , and the value at that key when we force-unwrap its contents
    with fruitBasket[fruit]! ➌ . That value will be the fruit’s price.
  id: totrans-4685
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的 for-in 循环的大括号内，我们可以访问到键，即我们称之为 fruit ➋，以及通过强制解包 fruitBasket[fruit]! ➌ 获取的该键对应的值。该值将是水果的价格。
- en: In this case, it’s safe to force-unwrap the value using an exclamation point
    because we know that the fruit key we’re using is definitely inside the dictionary.
  id: totrans-4686
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，可以安全地强制解包值，因为我们知道我们使用的水果键肯定存在于字典中。
- en: Any code we put inside the for-in loop will run once for every key in our dictionary.
    So you should see the print statement display three times.
  id: totrans-4687
  prefs: []
  type: TYPE_NORMAL
  zh: 我们放入 for-in 循环中的任何代码都会针对字典中的每个键执行一次。所以你应该看到 print 语句被打印三次。
- en: 'We can also loop through the dictionary using its values property:'
  id: totrans-4688
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以通过字典的 values 属性来循环：
- en: '![Image](Image00150.jpg)'
  id: totrans-4689
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00150.jpg)'
- en: We use the same style of for-in loop, but now we use a constant to refer to
    each value, which we call price , in the values property. When looping through
    values, we don’t have access to the keys from inside the loop.
  id: totrans-4690
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用相同的 for-in 循环样式，但现在我们使用一个常量来引用值属性中的每个值，我们称之为 price。在循环遍历值时，我们无法从循环内部访问键。
- en: Another difference to note is that price is not an optional because it’s accessed
    directly as a value in the fruitBasket dictionary. That means we don’t have to
    unwrap it. You should still see the print statement printed three times. [Figure
    6-6](text00016.html#ch06fig6) shows the output of both loops.
  id: totrans-4691
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个需要注意的区别是，price 不是可选项，因为它是直接作为 fruitBasket 字典中的值来访问的。这意味着我们不需要解包它。你仍然应该看到
    print 语句打印三次。[图 6-6](text00016.html#ch06fig6) 显示了两个循环的输出。
- en: '![Image](Image00151.jpg)'
  id: totrans-4692
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00151.jpg)'
- en: '*Figure 6-6: Looping through the keys and values of a dictionary with a for-in
    loop*'
  id: totrans-4693
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 6-6：使用 for-in 循环遍历字典的键和值*'
- en: The order of your results might be slightly different from ours. That’s because
    the items in a dictionary aren’t in a numbered order like they are in an array!
    And because the order is not guaranteed, you might see a different order printed
    if you run the same code again.
  id: totrans-4694
  prefs: []
  type: TYPE_NORMAL
  zh: 你的结果顺序可能会与我们的略有不同。这是因为字典中的项不像数组那样是按编号顺序排列的！由于顺序无法保证，如果你重新运行相同的代码，可能会看到不同的顺序打印出来。
- en: '**WHAT YOU LEARNED**'
  id: totrans-4695
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**你学到的知识**'
- en: In this chapter, you learned how to store collections of items in an array and
    in a dictionary. To store items in an ordered list, you would use an array and
    look up each item by its index. If you wanted to store items by key instead, you
    would use a dictionary.
  id: totrans-4696
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你学习了如何将项存储在数组和字典中。要将项存储在有序列表中，你会使用数组并通过索引查找每个项。如果你想通过键来存储项，你则会使用字典。
- en: Knowing about arrays and dictionaries and how to use them is a powerful building
    block for almost any programming language. Next we will learn about functions,
    another very powerful tool. Functions are blocks of code that you create and name
    to perform a specific job. After you have written a function, you can use its
    name to call it from almost anywhere in your program.
  id: totrans-4697
  prefs: []
  type: TYPE_NORMAL
  zh: 了解数组和字典以及如何使用它们是几乎所有编程语言的强大构建模块。接下来，我们将学习函数，另一个非常强大的工具。函数是你创建并命名的代码块，用于执行特定任务。写完函数后，你可以使用其名称从程序中的几乎任何地方调用它。
- en: To use the append(_:) method, first write the name of your array followed by
    a period and then append . Then, put the item you want to add to your array inside
    the parentheses. In this case, you put "Badlands" inside the parentheses.
  id: totrans-4698
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用 append(_:) 方法，首先写出数组的名称，然后跟上一个句点，再写上 append。然后，将你想添加到数组中的项放在括号内。在这种情况下，你将
    "Badlands" 放入括号中。
- en: 'If you want to add something at a specific place in your array, use the array’s
    insert(_:at:) method instead. This method takes two arguments: the item that you
    want to insert and the index of where it should go in the array. (We’ll discuss
    arguments in more detail in [Chapter 7](text00017.html#ch07) .)'
  id: totrans-4699
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想在数组中的特定位置添加元素，可以改用数组的 insert(_:at:) 方法。这个方法接受两个参数：你想插入的项和它应该放在数组中的索引。（我们将在[第7章](text00017.html#ch07)中更详细地讨论参数。）
- en: 'Let’s say you totally forgot that you went to the Petrified Forest right after
    you visited the Grand Canyon, and you want to update your nationalParks array
    so it displays the parks in the order in which you visited them. To update your
    array, you could use the insert(_:at:) method to put the Petrified Forest in the
    right position:'
  id: totrans-4700
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你完全忘记了在参观大峡谷后去了石化森林，并且你想更新你的 nationalParks 数组，使其按你参观的顺序显示这些公园。要更新数组，你可以使用
    insert(_:at:) 方法将石化森林放置在正确的位置：
- en: '![](Image00121.jpg)'
  id: totrans-4701
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00121.jpg)'
- en: When you insert a new item at index 3, everything that was in the array at index
    3 or higher gets scooted over to make room for the new item. That means the item
    that was at index 3 is now at index 4, the item that was at index 4 is now at
    index 5, and so on. After you add the Petrified Forest, nationalParks is now ["Acadia",
    "Zion", "Grand Canyon", "Petrified Forest", "Badlands"] .
  id: totrans-4702
  prefs: []
  type: TYPE_NORMAL
  zh: 当你在索引3插入一个新项目时，所有原本在索引3或更高位置的项目都会向后移，以腾出位置给新项目。这意味着原本位于索引3的项目现在位于索引4，原本位于索引4的项目现在位于索引5，以此类推。添加“Petrified
    Forest”后，nationalParks数组现在是["Acadia", "Zion", "Grand Canyon", "Petrified Forest",
    "Badlands"]。
- en: '**COMBINING ARRAYS**'
  id: totrans-4703
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**合并数组**'
- en: 'Not only can you add new items to an array, but you can also add two arrays
    together using the + and += operators. Let’s say that you have the ingredients
    for a fruit smoothie in two arrays:'
  id: totrans-4704
  prefs: []
  type: TYPE_NORMAL
  zh: 你不仅可以向数组添加新项目，还可以使用+和+=运算符将两个数组合并。假设你有两个数组，分别包含制作水果冰沙的配料：
- en: '![](Image00122.jpg)'
  id: totrans-4705
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00122.jpg)'
- en: Now you can make a delicious smoothie by adding the fruits and liquids arrays.
  id: totrans-4706
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你可以通过添加水果和液体数组来制作美味的冰沙。
- en: '![](Image00123.jpg)'
  id: totrans-4707
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00123.jpg)'
- en: The order of the ingredients in smoothie is the same as the order in fruits
    and liquids . If you created smoothie with liquids + fruits , then the liquids
    would come first.
  id: totrans-4708
  prefs: []
  type: TYPE_NORMAL
  zh: 冰沙中的配料顺序与水果和液体数组的顺序相同。如果你是将液体+水果创建冰沙，那么液体会排在前面。
- en: 'You use the += operator to add an array to the end of your array. Add some
    whipped cream as follows for extra yumminess:'
  id: totrans-4709
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用+=运算符将一个数组添加到另一个数组的末尾。为了增加额外的美味，可以按照以下方法添加一些鲜奶油：
- en: '![](Image00124.jpg)'
  id: totrans-4710
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00124.jpg)'
- en: Note that ["whipped cream"] is an array even though it has a single item in
    it. When you’re using += to append something to an array, you have to make sure
    you’re only trying to add another array. If you were to just write the string
    "whipped cream" without the square brackets around it, you would get an error.
  id: totrans-4711
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，["whipped cream"]虽然只有一个项目，但它仍然是一个数组。当你使用+=将某些东西添加到数组时，必须确保你只是在添加另一个数组。如果你仅仅写上字符串“whipped
    cream”而不加方括号，系统会报错。
- en: '![Image](Image00125.jpg)'
  id: totrans-4712
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00125.jpg)'
- en: '**REMOVING ITEMS FROM AN ARRAY**'
  id: totrans-4713
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**从数组中移除项目**'
- en: 'There are several methods for removing items from an array. Let’s start by
    looking at the array’s removeLast() method. As you might have guessed from its
    name, removeLast() removes the last item from your array. Let’s try it out with
    a shoppingList array:'
  id: totrans-4714
  prefs: []
  type: TYPE_NORMAL
  zh: 有几种方法可以从数组中移除项目。让我们从查看数组的removeLast()方法开始。顾名思义，removeLast()会移除数组中的最后一个项目。我们来尝试一下使用shoppingList数组：
- en: '![](Image00126.jpg)'
  id: totrans-4715
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00126.jpg)'
- en: Neat! Note that the removeLast() method returns the removed item, so you can
    store it in a new constant or variable if you want.
  id: totrans-4716
  prefs: []
  type: TYPE_NORMAL
  zh: 很棒！请注意，removeLast()方法返回被移除的项目，所以如果你需要，可以将它存储在一个新的常量或变量中。
- en: 'You can also remove an item from a specific index by using the remove(at:)
    method. Let’s say that your mom doesn’t want you buying any candy and takes that
    off the list:'
  id: totrans-4717
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以通过使用remove(at:)方法从特定索引移除一个项目。假设你的妈妈不想让你买糖果，并将其从清单中去掉：
- en: '![Image](Image00127.jpg)![](Image00128.jpg)'
  id: totrans-4718
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00127.jpg)![](Image00128.jpg)'
- en: Just like when we added an item to the middle of our array and all the items
    scooted over to make room, if you remove an item from the middle of an array,
    the rest of the items will scoot back to fill in that empty space. The "apples"
    item that was at index 3 is now at index 2, where "candy" was.
  id: totrans-4719
  prefs: []
  type: TYPE_NORMAL
  zh: 就像我们在数组中间添加项目时，所有的项目会移到一边腾出空间一样，如果你从数组中间移除一个项目，其余的项目也会向后移，以填补这个空位。原本位于索引3的“apples”现在位于索引2的位置，原来“candy”所在的位置。
- en: 'You can also remove all items from an array with removeAll() . Try entering
    this into your playground:'
  id: totrans-4720
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以使用removeAll()方法从数组中移除所有项目。试试在你的playground中输入这个：
- en: '![](Image00129.jpg)'
  id: totrans-4721
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00129.jpg)'
- en: 'Note that trying to remove an item at an index that doesn’t exist will give
    you an error:'
  id: totrans-4722
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，尝试从一个不存在的索引移除项目会导致错误：
- en: '![](Image00130.jpg)'
  id: totrans-4723
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00130.jpg)'
- en: Our array doesn’t have this many items (in fact, now it’s empty!), so this throws
    an error. We’ll also get an error if we use removeLast() on our empty array, because
    there’s nothing in it—there’s no last index at all! However, removeAll() is always
    safe to use, even on an empty array.
  id: totrans-4724
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的数组没有这么多项目（事实上，现在它已经是空的了！），所以这会抛出一个错误。如果我们在空数组上使用removeLast()，也会报错，因为数组里没有任何内容——根本没有最后一个索引！但是，removeAll()方法在任何情况下都是安全的，即使是空数组。
- en: '**REPLACING ITEMS IN AN ARRAY**'
  id: totrans-4725
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**替换数组中的项目**'
- en: 'To replace an item in an array, you set the index of the array to the new value,
    as shown here:'
  id: totrans-4726
  prefs: []
  type: TYPE_NORMAL
  zh: 要替换数组中的项目，你可以将数组的索引设置为新值，如下所示：
- en: '![](Image00131.jpg)'
  id: totrans-4727
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00131.jpg)'
- en: At ➊ , we replaced the item at index 2 (the third item) with "Unicorn" because
    magical animals count as favorite animals, too! At ➋ , we replaced the item at
    index 0 (the first item) with "Bearded dragon" . No, that’s not a real dragon—it’s
    just a lizard!
  id: totrans-4728
  prefs: []
  type: TYPE_NORMAL
  zh: 在 ➊ 处，我们将索引为 2（第三项）的位置的项目替换为“独角兽”，因为魔法动物也算是喜欢的动物！在 ➋ 处，我们将索引为 0（第一项）的位置的项目替换为“须龙”。不，那不是一条真正的龙——它只是一个蜥蜴！
- en: Like any time you’re working with array index numbers, you have to be sure an
    item exists in the array at that index before you change its value, or you will
    get an Index out of range error.
  id: totrans-4729
  prefs: []
  type: TYPE_NORMAL
  zh: 就像每次处理数组索引号一样，你必须确保数组中在该索引处存在项目，否则你会遇到“索引超出范围”错误。
- en: '[Figure 6-3](text00016.html#ch06fig3) shows the error that occurs if you try
    to add "Standard poodle" using favoriteAnimals[3] = "Standard poodle" . To add
    an item to the end of an array, you should use the append(_:) method or += , as
    we covered in “[Adding Items to an Array](text00016.html#ch06lev2sec5) ” on [page
    70](text00016.html#page_70) .'
  id: totrans-4730
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 6-3](text00016.html#ch06fig3) 显示了如果你尝试使用 favoriteAnimals[3] = "标准贵宾犬" 来添加“标准贵宾犬”时会发生的错误。要将项目添加到数组的末尾，应该使用
    append(_:) 方法或 +=，正如我们在 “[向数组添加项目](text00016.html#ch06lev2sec5)” 中讲解的那样，在[第 70
    页](text00016.html#page_70)。'
- en: '![Image](Image00132.jpg)'
  id: totrans-4731
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00132.jpg)'
- en: '*Figure 6-3: Don’t try to replace a value at an index beyond the existing array.*'
  id: totrans-4732
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 6-3：不要尝试替换超出现有数组索引的值。*'
- en: Now you know how to change arrays however you might need to. You can add items,
    take items away, or replace items. Next, we’ll look at how to use the properties
    of arrays to find out even more information about them.
  id: totrans-4733
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你知道如何根据需要修改数组了。你可以添加项目、删除项目或替换项目。接下来，我们将了解如何使用数组的属性来获取更多关于它们的信息。
- en: '![Image](Image00133.jpg)'
  id: totrans-4734
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00133.jpg)'
- en: '**USING ARRAY PROPERTIES**'
  id: totrans-4735
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**使用数组属性**'
- en: In addition to methods like append(_:) and removeLast() , arrays also have *properties*
    . An array’s properties are variables or constants that contain some information
    about the array. Two really helpful properties that you might use are the Boolean
    property isEmpty and the integer property count .
  id: totrans-4736
  prefs: []
  type: TYPE_NORMAL
  zh: 除了像 append(_:) 和 removeLast() 这样的操作方法外，数组还有*属性*。数组的属性是包含有关数组信息的变量或常量。你可能会用到的两个非常有用的属性是布尔类型属性
    isEmpty 和整数类型属性 count。
- en: The isEmpty property is true or false depending on whether the array is empty,
    and the count property will tell you how many items are in that array.
  id: totrans-4737
  prefs: []
  type: TYPE_NORMAL
  zh: isEmpty 属性根据数组是否为空返回 true 或 false，而 count 属性则会告诉你数组中有多少项。
- en: 'Check out how these two properties are used in the following if-else statement:'
  id: totrans-4738
  prefs: []
  type: TYPE_NORMAL
  zh: 查看以下 if-else 语句中如何使用这两个属性：
- en: '![Image](Image00134.jpg)'
  id: totrans-4739
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00134.jpg)'
- en: 'This if-else statement checks whether the array mySiblings is empty ➊ . If
    it is, then "I don''t have any siblings." is printed. But if there is something
    in the array, then the number of siblings that we have is printed: "I have 3 siblings."
    ➋ .'
  id: totrans-4740
  prefs: []
  type: TYPE_NORMAL
  zh: 该 if-else 语句检查数组 mySiblings 是否为空 ➊。如果为空，则打印 "我没有兄弟姐妹"。但如果数组中有内容，则打印兄弟姐妹的数量：“我有
    3 个兄弟姐妹。” ➋。
- en: '**LOOPING OVER AN ARRAY**'
  id: totrans-4741
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**循环遍历数组**'
- en: 'Sometimes when you’re working with arrays you might want to do something to
    every item in the array. You can use a for-in loop to do that! The following code
    will print every topping in a pizzaToppings array on a separate line:'
  id: totrans-4742
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，当你处理数组时，可能希望对数组中的每一项执行某些操作。你可以使用 for-in 循环来实现！以下代码将在每一行打印 pizzaToppings 数组中的每个配料：
- en: '![Image](Image00135.jpg)'
  id: totrans-4743
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00135.jpg)'
- en: To write a for-in loop for the pizzaToppings array, we used the keyword for
    , followed by the constant topping , then the keyword in , and finally the name
    of our array, pizzaToppings . Then we put the statements that we want to run for
    each topping inside the braces of the for-in loop. The constant topping ➊ temporarily
    represents each pizza topping in the array as we loop through it. We could have
    chosen any name for this constant, but it’s a good idea to pick something that
    makes sense. You can see the output of this for-in loop in [Figure 6-4](text00016.html#ch06fig4)
    .
  id: totrans-4744
  prefs: []
  type: TYPE_NORMAL
  zh: 为了编写针对 pizzaToppings 数组的 for-in 循环，我们使用了关键字 for，后跟常量 topping，接着是关键字 in，最后是数组的名称
    pizzaToppings。然后，我们将希望针对每个 topping 执行的语句放在 for-in 循环的大括号内。在循环过程中，常量 topping ➊
    临时表示数组中的每个比萨配料。我们本可以为这个常量选择任何名称，但最好选择一个有意义的名称。你可以在[图 6-4](text00016.html#ch06fig4)中查看此
    for-in 循环的输出。
- en: '![Image](Image00136.jpg)'
  id: totrans-4745
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00136.jpg)'
- en: '*Figure 6-4: Output of the example for-in loop*'
  id: totrans-4746
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 6-4：示例中的 for-in 循环输出*'
- en: '![Image](Image00137.jpg)'
  id: totrans-4747
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00137.jpg)'
- en: 'Using for-in loops is great for printing every value in an array. If you’re
    working with numbers, you can even use them to perform math operations on each
    item, which makes for some speedy calculations! The following code takes an array
    of numbers and calculates the square for each (the square of a number is that
    number multiplied by itself):'
  id: totrans-4748
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 for-in 循环非常适合打印数组中的每个值。如果你处理的是数字，你甚至可以利用它们对每个元素执行数学运算，这使得计算非常快速！以下代码会对一个数字数组中的每个数字进行平方运算（数字的平方是该数字与自身相乘）：
- en: '![Image](Image00138.jpg)'
  id: totrans-4749
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Image00138.jpg)'
- en: '[Figure 6-5](text00016.html#ch06fig5) shows the results.'
  id: totrans-4750
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 6-5](text00016.html#ch06fig5) 显示了结果。'
- en: '![Image](Image00139.jpg)'
  id: totrans-4751
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Image00139.jpg)'
- en: '*Figure 6-5: Printing the squares for each number in the myNumbers array*'
  id: totrans-4752
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 6-5：打印 myNumbers 数组中每个数字的平方*'
- en: '**DICTIONARIES ARE KEY!**'
  id: totrans-4753
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**字典至关重要！**'
- en: A *dictionary* is also a collection of values, but instead of an ordered index,
    each value has its own *key* . Because there’s no index, the values are not stored
    in any particular order. To access values in a dictionary, you look them up by
    their key.
  id: totrans-4754
  prefs: []
  type: TYPE_NORMAL
  zh: 一个*字典*也是一个值的集合，但不同于有序的索引，每个值都有自己的*键*。由于没有索引，值没有按照任何特定的顺序存储。要访问字典中的值，你需要通过键来查找它们。
- en: A key must be unique. You can’t have the same key more than once in the same
    dictionary. If there were two identical keys and you asked the computer to give
    you the value for one of them, the computer wouldn’t know which one to choose!
  id: totrans-4755
  prefs: []
  type: TYPE_NORMAL
  zh: 键必须是唯一的。你不能在同一个字典中有重复的键。如果有两个相同的键，而你要求计算机返回其中一个的值，计算机就无法知道选择哪一个！
- en: Let’s take a look at how to make a dictionary and write keys that will help
    you find all the information you need.
  id: totrans-4756
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如何创建一个字典并编写键值对，帮助你查找所需的所有信息。
- en: '![Image](Image00140.jpg)'
  id: totrans-4757
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Image00140.jpg)'
- en: '**INITIALIZING A DICTIONARY**'
  id: totrans-4758
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**初始化字典**'
- en: 'To create and initialize a dictionary, first write var and the name of your
    dictionary. Then write the keys and corresponding values inside a pair of square
    brackets, similar to an array. Let’s create a dictionary to store the names of
    a few US states. The key for each state will be its two-letter abbreviation:'
  id: totrans-4759
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建和初始化一个字典，首先写下 var 和字典的名称。然后在一对方括号中写下键和值，类似于数组的写法。让我们创建一个字典来存储一些美国州的名称。每个州的键将是它的两位字母缩写：
- en: '![](Image00141.jpg)'
  id: totrans-4760
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00141.jpg)'
- en: As you can see, there’s a colon between each key and its value, and the key/value
    pairs are separated by commas.
  id: totrans-4761
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，每个键和值之间都有一个冒号，键值对之间用逗号分隔。
- en: Dictionaries are different from arrays in that they are *unordered* . Because
    of that, it’s likely that the order of the states that you see in your results
    pane ➋ is different from the order in which you entered your states ➊ . It might
    even be different than the order that’s printed in this book!
  id: totrans-4762
  prefs: []
  type: TYPE_NORMAL
  zh: 字典与数组的不同之处在于它们是*无序*的。因此，你在结果窗格中看到的状态顺序➋可能与输入状态的顺序➊不同。甚至可能与书中打印的顺序不同！
- en: As with arrays, you can use var to make a mutable dictionary or use let to make
    an immutable dictionary.
  id: totrans-4763
  prefs: []
  type: TYPE_NORMAL
  zh: 与数组一样，你可以使用 var 来创建一个可变字典，或者使用 let 来创建一个不可变字典。
- en: 'In Swift, all of the keys of a dictionary must be the same type, and all of
    the values of a dictionary must also be the same type, but the key type doesn’t
    have to match the value type. For example, if you wanted to store a collection
    of fractions, you could use doubles for the keys and strings for the values:'
  id: totrans-4764
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Swift 中，字典的所有键必须是相同类型的，而字典的所有值也必须是相同类型的，但键的类型不必与值的类型匹配。例如，如果你想存储一个分数集合，可以使用双精度浮点数作为键，使用字符串作为值：
- en: '![](Image00142.jpg)'
  id: totrans-4765
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00142.jpg)'
- en: In this dictionary, all of the keys must be doubles, and all of the values must
    be strings. Again, you’ll see that the order of the numbers in the results pane
    can be quite different from the order in which you wrote the fractions in your
    dictionary. This is fine because you don’t need to know the order to access anything.
    You can find any item that you need by its key. Let’s see how!
  id: totrans-4766
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个字典中，所有的键必须是双精度浮点数，所有的值必须是字符串。再次提醒你，结果窗格中的数字顺序可能与字典中写入的分数顺序有所不同。这个没有问题，因为你不需要知道顺序来访问任何内容。你可以通过键来查找任何需要的项目。让我们看看如何操作！
- en: '**ACCESSING VALUES IN A DICTIONARY**'
  id: totrans-4767
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**访问字典中的值**'
- en: 'Looking up a value in a dictionary is similar to how you access a value in
    an array except that you use a key inside the square brackets instead of an index,
    like this: usStates["TX"] .'
  id: totrans-4768
  prefs: []
  type: TYPE_NORMAL
  zh: 查找字典中的值类似于你在数组中访问值的方式，区别在于你在方括号内使用键，而不是索引，像这样：usStates["TX"]。
- en: There is a big difference, however, in how Swift returns the values from a dictionary.
    When you access a value at an index of an array, you are simply given the value.
    When you access a value with a key in a dictionary, you are given an optional.
  id: totrans-4769
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，有一个很大的区别，那就是 Swift 返回字典值的方式。当你在数组中访问某个索引的值时，你直接得到值。当你使用字典的键访问值时，你得到的是一个可选项。
- en: In [Chapter 5](text00015.html#ch05) , you learned that optionals might contain
    a value or might be nil . The reason Swift returns optionals when you’re looking
    up items in a dictionary is that the key you used might not exist in the dictionary,
    in which case there’s no value to access. Trying to access a value that doesn’t
    exist would give you a big fat error! To avoid that problem, Swift returns optionals.
    That means you need to unwrap any value you get out of a dictionary before you
    can do anything with it.
  id: totrans-4770
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第5章](text00015.html#ch05)中，你学到过可选项可能包含一个值，也可能是 nil 。Swift 返回可选项是因为你使用的键可能不存在于字典中，在这种情况下没有值可访问。尝试访问不存在的值会导致严重错误！为了避免这个问题，Swift
    返回了可选项。这意味着在对从字典中获得的任何值进行操作之前，你需要先解包它。
- en: 'To unwrap an optional, first you check whether it exists using an if-let statement,
    just like we did in [Chapter 5](text00015.html#ch05) . The following code shows
    you how to get a value out of a dictionary:'
  id: totrans-4771
  prefs: []
  type: TYPE_NORMAL
  zh: 要解包一个可选项，首先使用 if-let 语句检查它是否存在，就像我们在[第5章](text00015.html#ch05)中做的那样。以下代码展示了如何从字典中获取值：
- en: '![Image](Image00143.jpg)'
  id: totrans-4772
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00143.jpg)'
- en: To retrieve "Texas" from the dictionary, we use if let to set a constant loneStarState
    to usStates["TX"] ➊ . Because we have this state in our dictionary, the line I
    have Texas in my dictionary. is printed. Next we try to access a state that is
    not in our dictionary by using the key usStates["FL"] ➋ . Thankfully, because
    we used an if-let statement, the program won’t crash when the computer can’t find
    this state. Instead, I don't have that state in my dictionary. is printed.
  id: totrans-4773
  prefs: []
  type: TYPE_NORMAL
  zh: 要从字典中检索“Texas”，我们使用 if let 来将常量 loneStarState 设置为 usStates["TX"] ➊ 。由于我们在字典中有这个州，输出了
    I have Texas in my dictionary.。接下来，我们尝试通过使用键 usStates["FL"] ➋ 来访问一个不在字典中的州。幸运的是，因为我们使用了
    if-let 语句，当计算机无法找到该州时，程序不会崩溃。相反，输出了 I don't have that state in my dictionary.。
- en: '**ADDING ITEMS TO A DICTIONARY**'
  id: totrans-4774
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**向字典添加项目**'
- en: 'To add an item to a dictionary, first write the name of your dictionary and
    assign the new item to the key you want it to have in the dictionary. Let’s add
    "Minnesota" to our usStates dictionary:'
  id: totrans-4775
  prefs: []
  type: TYPE_NORMAL
  zh: 要向字典中添加一个项目，首先写出字典的名称，并将新项目分配给你想要它在字典中具有的键。我们来将 "Minnesota" 添加到我们的 usStates
    字典中：
- en: '![](Image00144.jpg)'
  id: totrans-4776
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00144.jpg)'
- en: 'Now when you look at usStates , you’ll see that it’s updated to ["MN": "Minnesota",
    "WA": "Washington", "MA": "Massachusetts", "TX": "Texas"] . Remember, because
    you don’t have to rely on indices, your new dictionary item might appear anywhere
    in the dictionary.'
  id: totrans-4777
  prefs: []
  type: TYPE_NORMAL
  zh: '现在，当你查看 usStates 时，你会看到它已经更新为 ["MN": "Minnesota", "WA": "Washington", "MA":
    "Massachusetts", "TX": "Texas"]。记住，因为你不需要依赖索引，所以你的新字典项目可能会出现在字典中的任何位置。'
- en: '**REMOVING ITEMS FROM A DICTIONARY**'
  id: totrans-4778
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**从字典移除项目**'
- en: Removing an item from a dictionary is quite simple; you do so by setting the
    value to nil . Because the values in dictionaries are returned as optionals, you
    don’t have to worry about nil causing any problems in your dictionary.
  id: totrans-4779
  prefs: []
  type: TYPE_NORMAL
  zh: 从字典中移除一个项目非常简单；你只需将值设置为 nil 。因为字典中的值是以可选项的形式返回的，所以你不必担心 nil 会在字典中引起任何问题。
- en: '![](Image00145.jpg)'
  id: totrans-4780
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00145.jpg)'
- en: 'You can see that after you remove the value at the key "MA" , usStates is updated
    to ["MN": "Minnesota", "WA": "Washington", "TX": "Texas"] . Remember that nil
    is special and means that there’s no value at all. That’s why you don’t see "MA":
    nil in our dictionary.'
  id: totrans-4781
  prefs: []
  type: TYPE_NORMAL
  zh: '你可以看到，当你移除键 "MA" 对应的值后，usStates 更新为 ["MN": "Minnesota", "WA": "Washington",
    "TX": "Texas"]。记住，nil 是特殊的，表示没有任何值。因此，你在字典中看不到 "MA": nil。'
- en: '**REPLACING ITEMS IN A DICTIONARY**'
  id: totrans-4782
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**替换字典中的项目**'
- en: 'Replacing an item in a dictionary is also easy. It works the same was as replacing
    an item in an array. You just set the item that you want to replace to something
    else. Say you create a dictionary of fruit colors:'
  id: totrans-4783
  prefs: []
  type: TYPE_NORMAL
  zh: 替换字典中的项目也很简单。它的工作方式与替换数组中的项目相同。你只需要将你想替换的项目设置为其他内容。假设你创建了一个水果颜色的字典：
- en: '![](Image00146.jpg)'
  id: totrans-4784
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00146.jpg)'
- en: At first we had the value "apple" for "red" , but then we decided that "raspberry"
    is a better fruit to use since sometimes apples are green or yellow. To replace
    "apple" with "raspberry" , we set colorFruits["red"] to its new value ➊ .
  id: totrans-4785
  prefs: []
  type: TYPE_NORMAL
  zh: 起初，我们为 "red" 设置了 "apple" 的值，但后来我们决定使用 "raspberry" 更合适，因为有时候苹果是绿色或黄色的。为了将 "apple"
    替换为 "raspberry"，我们将 `colorFruits["red"]` 设置为它的新值 ➊。
- en: You may remember that this is the same way we entered a new value into a dictionary.
    If the key already exists in the dictionary, then the value for that key is replaced.
    If the key doesn’t already exist, then the new key/value pair will be added to
    the dictionary.
  id: totrans-4786
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能记得，这与我们向字典中添加新值的方式相同。如果字典中已经存在该键，则该键的值将被替换。如果键不存在，那么新的键/值对将被添加到字典中。
- en: '![Image](Image00147.jpg)'
  id: totrans-4787
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00147.jpg)'
- en: '**USING DICTIONARY PROPERTIES**'
  id: totrans-4788
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**使用字典属性**'
- en: 'Like an array, a dictionary also has an isEmpty property and a count property.
    For example, the following code shows how you can use the isEmpty property to
    check if a dictionary is empty, and if it isn’t empty, the count property checks
    how many items you have. Imagine you have a basket of fruit for sale. You can
    use these properties to help you keep track of everything:'
  id: totrans-4789
  prefs: []
  type: TYPE_NORMAL
  zh: 像数组一样，字典也有 `isEmpty` 属性和 `count` 属性。例如，以下代码演示了如何使用 `isEmpty` 属性来检查字典是否为空，如果不为空，则使用
    `count` 属性检查字典中的项目数量。假设你有一个水果篮待售。你可以使用这些属性来帮助你跟踪所有内容：
- en: '![Image](Image00148.jpg)'
  id: totrans-4790
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00148.jpg)'
- en: 'A dictionary also has two special properties: keys , which contains all of
    the dictionary’s keys, and values , which contains all of its values. We’ll use
    these two properties when we loop through the dictionary.'
  id: totrans-4791
  prefs: []
  type: TYPE_NORMAL
  zh: 字典还有两个特殊属性：`keys`，它包含字典的所有键，和 `values`，它包含所有值。当我们遍历字典时，会用到这两个属性。
- en: Let’s write some code that loops through our fruit baskets and prints the price
    of each fruit.
  id: totrans-4792
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们编写一些代码，遍历我们的水果篮并打印每种水果的价格。
- en: '**LOOPING OVER A DICTIONARY**'
  id: totrans-4793
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**遍历字典**'
- en: 'You can loop through a dictionary using a for-in loop. Because each item has
    a key and a value, you can do this in two different ways. This is how to loop
    through a dictionary using its keys:'
  id: totrans-4794
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用 `for-in` 循环遍历字典。因为每个项目都有一个键和值，你可以通过两种不同的方式进行遍历。这是使用键遍历字典的方法：
- en: '![Image](Image00149.jpg)'
  id: totrans-4795
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00149.jpg)'
- en: Here we use the dictionary’s keys property ➊ to loop through fruitBasket and
    print its contents. We start by writing the keyword for , followed by a constant
    name fruit for the dictionary key, the keyword in , the dictionary name, a period,
    and keys .
  id: totrans-4796
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们使用字典的 `keys` 属性 ➊ 来遍历 `fruitBasket` 并打印它的内容。我们首先写下关键字 `for`，后跟字典键的常量名
    `fruit`，然后是关键字 `in`，字典名，一个句点，最后是 `keys`。
- en: Inside the braces of our for-in loop, we have access to both the key, which
    we call fruit ➋ , and the value at that key when we force-unwrap its contents
    with fruitBasket[fruit]! ➌ . That value will be the fruit’s price.
  id: totrans-4797
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `for-in` 循环的大括号内，我们可以访问键（我们称之为 fruit ➋）以及通过 `fruitBasket[fruit]!` 强制解包该键的值
    ➌。该值将是水果的价格。
- en: In this case, it’s safe to force-unwrap the value using an exclamation point
    because we know that the fruit key we’re using is definitely inside the dictionary.
  id: totrans-4798
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，使用感叹号强制解包值是安全的，因为我们知道我们使用的水果键肯定存在于字典中。
- en: Any code we put inside the for-in loop will run once for every key in our dictionary.
    So you should see the print statement display three times.
  id: totrans-4799
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在 `for-in` 循环中编写的任何代码都会对字典中的每个键执行一次。因此，你应该看到打印语句会执行三次。
- en: 'We can also loop through the dictionary using its values property:'
  id: totrans-4800
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以使用字典的 `values` 属性来遍历字典：
- en: '![Image](Image00150.jpg)'
  id: totrans-4801
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00150.jpg)'
- en: We use the same style of for-in loop, but now we use a constant to refer to
    each value, which we call price , in the values property. When looping through
    values, we don’t have access to the keys from inside the loop.
  id: totrans-4802
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用相同风格的 `for-in` 循环，但现在我们使用常量来引用 `values` 属性中的每个值，我们称其为 `price`。在遍历 `values`
    时，我们无法从循环内部访问键。
- en: Another difference to note is that price is not an optional because it’s accessed
    directly as a value in the fruitBasket dictionary. That means we don’t have to
    unwrap it. You should still see the print statement printed three times. [Figure
    6-6](text00016.html#ch06fig6) shows the output of both loops.
  id: totrans-4803
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个需要注意的区别是，价格不是一个可选值，因为它是直接作为字典 `fruitBasket` 中的值进行访问的。这意味着我们不需要解包它。你仍然应该看到打印语句会执行三次。[图
    6-6](text00016.html#ch06fig6)显示了两个循环的输出。
- en: '![Image](Image00151.jpg)'
  id: totrans-4804
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00151.jpg)'
- en: '*Figure 6-6: Looping through the keys and values of a dictionary with a for-in
    loop*'
  id: totrans-4805
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 6-6：使用 for-in 循环遍历字典的键和值*'
- en: The order of your results might be slightly different from ours. That’s because
    the items in a dictionary aren’t in a numbered order like they are in an array!
    And because the order is not guaranteed, you might see a different order printed
    if you run the same code again.
  id: totrans-4806
  prefs: []
  type: TYPE_NORMAL
  zh: 你的结果顺序可能会与我们的略有不同。那是因为字典中的项不像数组中的项那样按编号顺序排列！由于顺序没有保证，如果你再次运行相同的代码，你可能会看到不同的输出顺序。
- en: '**WHAT YOU LEARNED**'
  id: totrans-4807
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**你学到了什么**'
- en: In this chapter, you learned how to store collections of items in an array and
    in a dictionary. To store items in an ordered list, you would use an array and
    look up each item by its index. If you wanted to store items by key instead, you
    would use a dictionary.
  id: totrans-4808
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你学会了如何将项目存储在数组和字典中。为了按顺序存储项目，你会使用数组，并通过索引查找每个项目。如果你想通过键来存储项目，你则会使用字典。
- en: Knowing about arrays and dictionaries and how to use them is a powerful building
    block for almost any programming language. Next we will learn about functions,
    another very powerful tool. Functions are blocks of code that you create and name
    to perform a specific job. After you have written a function, you can use its
    name to call it from almost anywhere in your program.
  id: totrans-4809
  prefs: []
  type: TYPE_NORMAL
  zh: 了解数组和字典以及如何使用它们是几乎任何编程语言中的一个强大构建块。接下来，我们将学习函数，这是另一个非常强大的工具。函数是你创建并命名的一段代码，用来执行特定的任务。写好一个函数后，你可以在程序中的几乎任何地方使用它的名称来调用它。
- en: 'If you want to add something at a specific place in your array, use the array’s
    insert(_:at:) method instead. This method takes two arguments: the item that you
    want to insert and the index of where it should go in the array. (We’ll discuss
    arguments in more detail in [Chapter 7](text00017.html#ch07) .)'
  id: totrans-4810
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想在数组中的特定位置添加某个项，请改用数组的 insert(_:at:) 方法。这个方法需要两个参数：你要插入的项目和该项目应该插入的位置索引。（我们将在[第
    7 章](text00017.html#ch07) 中详细讨论参数。）
- en: 'Let’s say you totally forgot that you went to the Petrified Forest right after
    you visited the Grand Canyon, and you want to update your nationalParks array
    so it displays the parks in the order in which you visited them. To update your
    array, you could use the insert(_:at:) method to put the Petrified Forest in the
    right position:'
  id: totrans-4811
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你完全忘记了自己在游览大峡谷后去了石化森林，而你想更新你的 nationalParks 数组，以便按你访问它们的顺序显示这些公园。为了更新你的数组，你可以使用
    insert(_:at:) 方法将石化森林放到正确的位置：
- en: '![](Image00121.jpg)'
  id: totrans-4812
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00121.jpg)'
- en: When you insert a new item at index 3, everything that was in the array at index
    3 or higher gets scooted over to make room for the new item. That means the item
    that was at index 3 is now at index 4, the item that was at index 4 is now at
    index 5, and so on. After you add the Petrified Forest, nationalParks is now ["Acadia",
    "Zion", "Grand Canyon", "Petrified Forest", "Badlands"] .
  id: totrans-4813
  prefs: []
  type: TYPE_NORMAL
  zh: 当你在索引 3 处插入一个新项目时，所有原本位于索引 3 或更高位置的项目都会被向后移动以为新项目腾出空间。这意味着原本在索引 3 的项目现在位于索引
    4，原本在索引 4 的项目现在位于索引 5，以此类推。添加了石化森林之后，nationalParks 现在是 ["Acadia", "Zion", "Grand
    Canyon", "Petrified Forest", "Badlands"]。
- en: '**COMBINING ARRAYS**'
  id: totrans-4814
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**合并数组**'
- en: 'Not only can you add new items to an array, but you can also add two arrays
    together using the + and += operators. Let’s say that you have the ingredients
    for a fruit smoothie in two arrays:'
  id: totrans-4815
  prefs: []
  type: TYPE_NORMAL
  zh: 不仅可以向数组中添加新项目，你还可以使用 + 和 += 操作符将两个数组合并。假设你有两数组中的水果奶昔食材：
- en: '![](Image00122.jpg)'
  id: totrans-4816
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00122.jpg)'
- en: Now you can make a delicious smoothie by adding the fruits and liquids arrays.
  id: totrans-4817
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你可以通过将水果和液体数组相加来制作一杯美味的水果奶昔。
- en: '![](Image00123.jpg)'
  id: totrans-4818
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00123.jpg)'
- en: The order of the ingredients in smoothie is the same as the order in fruits
    and liquids . If you created smoothie with liquids + fruits , then the liquids
    would come first.
  id: totrans-4819
  prefs: []
  type: TYPE_NORMAL
  zh: 水果奶昔中的食材顺序与水果和液体数组的顺序相同。如果你是用液体 + 水果的顺序创建的奶昔，那么液体会排在前面。
- en: 'You use the += operator to add an array to the end of your array. Add some
    whipped cream as follows for extra yumminess:'
  id: totrans-4820
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用 += 操作符将一个数组添加到另一个数组的末尾。为了额外的美味，可以如下添加一些鲜奶油：
- en: '![](Image00124.jpg)'
  id: totrans-4821
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00124.jpg)'
- en: Note that ["whipped cream"] is an array even though it has a single item in
    it. When you’re using += to append something to an array, you have to make sure
    you’re only trying to add another array. If you were to just write the string
    "whipped cream" without the square brackets around it, you would get an error.
  id: totrans-4822
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，["鲜奶油"]是一个数组，尽管它只有一个项目。当你使用+=向数组添加项目时，必须确保你只是添加另一个数组。如果你只是写“鲜奶油”这个字符串，而没有加上方括号，就会出现错误。
- en: '![Image](Image00125.jpg)'
  id: totrans-4823
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00125.jpg)'
- en: '**REMOVING ITEMS FROM AN ARRAY**'
  id: totrans-4824
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**从数组中移除项目**'
- en: 'There are several methods for removing items from an array. Let’s start by
    looking at the array’s removeLast() method. As you might have guessed from its
    name, removeLast() removes the last item from your array. Let’s try it out with
    a shoppingList array:'
  id: totrans-4825
  prefs: []
  type: TYPE_NORMAL
  zh: 有几种方法可以从数组中移除项目。我们从查看数组的removeLast()方法开始。正如你从方法名中猜到的那样，removeLast()会移除数组中的最后一个项目。让我们用一个shoppingList数组来试试看：
- en: '![](Image00126.jpg)'
  id: totrans-4826
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00126.jpg)'
- en: Neat! Note that the removeLast() method returns the removed item, so you can
    store it in a new constant or variable if you want.
  id: totrans-4827
  prefs: []
  type: TYPE_NORMAL
  zh: 很棒！请注意，removeLast()方法会返回被移除的项目，因此你可以将其存储在一个新的常量或变量中，如果你想的话。
- en: 'You can also remove an item from a specific index by using the remove(at:)
    method. Let’s say that your mom doesn’t want you buying any candy and takes that
    off the list:'
  id: totrans-4828
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以通过使用remove(at:)方法从特定索引移除项目。假设你的妈妈不希望你买糖果并把它从列表中拿掉：
- en: '![Image](Image00127.jpg)![](Image00128.jpg)'
  id: totrans-4829
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00127.jpg)![](Image00128.jpg)'
- en: Just like when we added an item to the middle of our array and all the items
    scooted over to make room, if you remove an item from the middle of an array,
    the rest of the items will scoot back to fill in that empty space. The "apples"
    item that was at index 3 is now at index 2, where "candy" was.
  id: totrans-4830
  prefs: []
  type: TYPE_NORMAL
  zh: 就像当我们将一个项目添加到数组中间，所有项目都向前移动腾出空间一样，如果你从数组中间移除一个项目，剩余的项目将会向后移动以填补空缺。原来位于索引3的“苹果”现在位于索引2的位置，那里原来是“糖果”。
- en: 'You can also remove all items from an array with removeAll() . Try entering
    this into your playground:'
  id: totrans-4831
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以使用removeAll()方法从数组中移除所有项目。试着在你的游乐场输入这个：
- en: '![](Image00129.jpg)'
  id: totrans-4832
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00129.jpg)'
- en: 'Note that trying to remove an item at an index that doesn’t exist will give
    you an error:'
  id: totrans-4833
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，尝试从一个不存在的索引移除项目会导致错误：
- en: '![](Image00130.jpg)'
  id: totrans-4834
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00130.jpg)'
- en: Our array doesn’t have this many items (in fact, now it’s empty!), so this throws
    an error. We’ll also get an error if we use removeLast() on our empty array, because
    there’s nothing in it—there’s no last index at all! However, removeAll() is always
    safe to use, even on an empty array.
  id: totrans-4835
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的数组没有这么多项目（事实上，现在它是空的！），所以会抛出一个错误。如果我们在空数组上使用removeLast()，也会出错，因为它什么都没有——根本没有最后一个索引！然而，removeAll()是始终安全使用的，即使在空数组上也是如此。
- en: '**REPLACING ITEMS IN AN ARRAY**'
  id: totrans-4836
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**替换数组中的项目**'
- en: 'To replace an item in an array, you set the index of the array to the new value,
    as shown here:'
  id: totrans-4837
  prefs: []
  type: TYPE_NORMAL
  zh: 要替换数组中的一个项目，你只需将数组索引设置为新值，如下所示：
- en: '![](Image00131.jpg)'
  id: totrans-4838
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00131.jpg)'
- en: At ➊ , we replaced the item at index 2 (the third item) with "Unicorn" because
    magical animals count as favorite animals, too! At ➋ , we replaced the item at
    index 0 (the first item) with "Bearded dragon" . No, that’s not a real dragon—it’s
    just a lizard!
  id: totrans-4839
  prefs: []
  type: TYPE_NORMAL
  zh: 在➊处，我们将索引2（第三个项目）的位置替换为“独角兽”，因为魔法动物也算是最喜欢的动物！在➋处，我们将索引0（第一个项目）的位置替换为“胡须龙”。不，这可不是一条真的龙——它只是一只蜥蜴！
- en: Like any time you’re working with array index numbers, you have to be sure an
    item exists in the array at that index before you change its value, or you will
    get an Index out of range error.
  id: totrans-4840
  prefs: []
  type: TYPE_NORMAL
  zh: 就像任何时候你使用数组索引时一样，你必须确保在改变其值之前，该索引处的项目已经存在，否则会发生“索引超出范围”的错误。
- en: '[Figure 6-3](text00016.html#ch06fig3) shows the error that occurs if you try
    to add "Standard poodle" using favoriteAnimals[3] = "Standard poodle" . To add
    an item to the end of an array, you should use the append(_:) method or += , as
    we covered in “[Adding Items to an Array](text00016.html#ch06lev2sec5) ” on [page
    70](text00016.html#page_70) .'
  id: totrans-4841
  prefs: []
  type: TYPE_NORMAL
  zh: '[图6-3](text00016.html#ch06fig3)显示了如果你尝试通过favoriteAnimals[3] = "标准贵宾犬"添加“标准贵宾犬”时会发生的错误。要将一个项目添加到数组的末尾，你应该使用append(_:)方法或+=，正如我们在“[向数组中添加项目](text00016.html#ch06lev2sec5)”中第70页（[page
    70](text00016.html#page_70)）所介绍的那样。'
- en: '![Image](Image00132.jpg)'
  id: totrans-4842
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00132.jpg)'
- en: '*Figure 6-3: Don’t try to replace a value at an index beyond the existing array.*'
  id: totrans-4843
  prefs: []
  type: TYPE_NORMAL
  zh: '*图6-3：不要尝试在超出现有数组范围的索引处替换值。*'
- en: Now you know how to change arrays however you might need to. You can add items,
    take items away, or replace items. Next, we’ll look at how to use the properties
    of arrays to find out even more information about them.
  id: totrans-4844
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你知道如何根据需要更改数组了。你可以添加、删除或替换数组中的项。接下来，我们将看看如何使用数组的属性来获取更多关于数组的信息。
- en: '![Image](Image00133.jpg)'
  id: totrans-4845
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00133.jpg)'
- en: '**USING ARRAY PROPERTIES**'
  id: totrans-4846
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**使用数组属性**'
- en: In addition to methods like append(_:) and removeLast() , arrays also have *properties*
    . An array’s properties are variables or constants that contain some information
    about the array. Two really helpful properties that you might use are the Boolean
    property isEmpty and the integer property count .
  id: totrans-4847
  prefs: []
  type: TYPE_NORMAL
  zh: 除了像append(_:)和removeLast()这样的函数，数组还有*属性*。数组的属性是包含关于数组的某些信息的变量或常量。你可能会用到的两个非常有用的属性是布尔属性isEmpty和整数属性count。
- en: The isEmpty property is true or false depending on whether the array is empty,
    and the count property will tell you how many items are in that array.
  id: totrans-4848
  prefs: []
  type: TYPE_NORMAL
  zh: isEmpty属性的值是true或false，取决于数组是否为空，而count属性则会告诉你数组中有多少项。
- en: 'Check out how these two properties are used in the following if-else statement:'
  id: totrans-4849
  prefs: []
  type: TYPE_NORMAL
  zh: 看看这两个属性是如何在以下if-else语句中使用的：
- en: '![Image](Image00134.jpg)'
  id: totrans-4850
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00134.jpg)'
- en: 'This if-else statement checks whether the array mySiblings is empty ➊ . If
    it is, then "I don''t have any siblings." is printed. But if there is something
    in the array, then the number of siblings that we have is printed: "I have 3 siblings."
    ➋ .'
  id: totrans-4851
  prefs: []
  type: TYPE_NORMAL
  zh: 这个if-else语句检查数组mySiblings是否为空➊。如果为空，则打印“我没有兄弟姐妹。”如果数组中有元素，则打印我们有几个兄弟姐妹：“我有3个兄弟姐妹。”➋。
- en: '**LOOPING OVER AN ARRAY**'
  id: totrans-4852
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**遍历数组**'
- en: 'Sometimes when you’re working with arrays you might want to do something to
    every item in the array. You can use a for-in loop to do that! The following code
    will print every topping in a pizzaToppings array on a separate line:'
  id: totrans-4853
  prefs: []
  type: TYPE_NORMAL
  zh: 有时在处理数组时，你可能希望对数组中的每一项做某些操作。你可以使用for-in循环来实现！以下代码会将pizzaToppings数组中的每个配料打印在单独的行上：
- en: '![Image](Image00135.jpg)'
  id: totrans-4854
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00135.jpg)'
- en: To write a for-in loop for the pizzaToppings array, we used the keyword for
    , followed by the constant topping , then the keyword in , and finally the name
    of our array, pizzaToppings . Then we put the statements that we want to run for
    each topping inside the braces of the for-in loop. The constant topping ➊ temporarily
    represents each pizza topping in the array as we loop through it. We could have
    chosen any name for this constant, but it’s a good idea to pick something that
    makes sense. You can see the output of this for-in loop in [Figure 6-4](text00016.html#ch06fig4)
    .
  id: totrans-4855
  prefs: []
  type: TYPE_NORMAL
  zh: 为pizzaToppings数组编写for-in循环时，我们使用了关键字for，后面跟着常量topping，再是关键字in，最后是数组名称pizzaToppings。然后，我们将希望对每个配料执行的语句放入for-in循环的大括号中。常量topping➊在我们循环数组时暂时代表数组中的每个披萨配料。我们可以为这个常量选择任何名称，但最好选择一个有意义的名称。你可以在[图6-4](text00016.html#ch06fig4)中看到这个for-in循环的输出。
- en: '![Image](Image00136.jpg)'
  id: totrans-4856
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00136.jpg)'
- en: '*Figure 6-4: Output of the example for-in loop*'
  id: totrans-4857
  prefs: []
  type: TYPE_NORMAL
  zh: '*图6-4：示例for-in循环的输出*'
- en: '![Image](Image00137.jpg)'
  id: totrans-4858
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00137.jpg)'
- en: 'Using for-in loops is great for printing every value in an array. If you’re
    working with numbers, you can even use them to perform math operations on each
    item, which makes for some speedy calculations! The following code takes an array
    of numbers and calculates the square for each (the square of a number is that
    number multiplied by itself):'
  id: totrans-4859
  prefs: []
  type: TYPE_NORMAL
  zh: 使用for-in循环非常适合打印数组中的每个值。如果你处理的是数字，甚至可以用它们对每个项目执行数学运算，这样可以加快计算速度！以下代码获取一个数字数组并计算每个数字的平方（一个数字的平方是该数字与其自身相乘）：
- en: '![Image](Image00138.jpg)'
  id: totrans-4860
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00138.jpg)'
- en: '[Figure 6-5](text00016.html#ch06fig5) shows the results.'
  id: totrans-4861
  prefs: []
  type: TYPE_NORMAL
  zh: '[图6-5](text00016.html#ch06fig5)显示了结果。'
- en: '![Image](Image00139.jpg)'
  id: totrans-4862
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00139.jpg)'
- en: '*Figure 6-5: Printing the squares for each number in the myNumbers array*'
  id: totrans-4863
  prefs: []
  type: TYPE_NORMAL
  zh: '*图6-5：打印myNumbers数组中每个数字的平方*'
- en: '**DICTIONARIES ARE KEY!**'
  id: totrans-4864
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**字典至关重要！**'
- en: A *dictionary* is also a collection of values, but instead of an ordered index,
    each value has its own *key* . Because there’s no index, the values are not stored
    in any particular order. To access values in a dictionary, you look them up by
    their key.
  id: totrans-4865
  prefs: []
  type: TYPE_NORMAL
  zh: '*字典*也是一组值的集合，但与有序索引不同，每个值都有自己的*键*。因为没有索引，值不会以特定顺序存储。要访问字典中的值，你需要通过它们的键来查找。'
- en: A key must be unique. You can’t have the same key more than once in the same
    dictionary. If there were two identical keys and you asked the computer to give
    you the value for one of them, the computer wouldn’t know which one to choose!
  id: totrans-4866
  prefs: []
  type: TYPE_NORMAL
  zh: 键必须是唯一的。你不能在同一个字典中有两个相同的键。如果有两个相同的键，当你要求计算机返回其中一个键的值时，计算机将不知道选择哪个！
- en: Let’s take a look at how to make a dictionary and write keys that will help
    you find all the information you need.
  id: totrans-4867
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如何创建一个字典并写出键，以帮助你找到所需的所有信息。
- en: '![Image](Image00140.jpg)'
  id: totrans-4868
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00140.jpg)'
- en: '**INITIALIZING A DICTIONARY**'
  id: totrans-4869
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**初始化字典**'
- en: 'To create and initialize a dictionary, first write var and the name of your
    dictionary. Then write the keys and corresponding values inside a pair of square
    brackets, similar to an array. Let’s create a dictionary to store the names of
    a few US states. The key for each state will be its two-letter abbreviation:'
  id: totrans-4870
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建并初始化一个字典，首先写上 var 和字典的名称。然后将键和值放在一对方括号内，类似于数组的写法。让我们创建一个字典来存储一些美国州的名称。每个州的键将是它的两位字母缩写：
- en: '![](Image00141.jpg)'
  id: totrans-4871
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00141.jpg)'
- en: As you can see, there’s a colon between each key and its value, and the key/value
    pairs are separated by commas.
  id: totrans-4872
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，每个键和值之间有一个冒号，键/值对之间由逗号分隔。
- en: Dictionaries are different from arrays in that they are *unordered* . Because
    of that, it’s likely that the order of the states that you see in your results
    pane ➋ is different from the order in which you entered your states ➊ . It might
    even be different than the order that’s printed in this book!
  id: totrans-4873
  prefs: []
  type: TYPE_NORMAL
  zh: 字典不同于数组，因为它们是*无序的*。因此，你看到的结果面板中州的顺序 ➋ 可能与输入这些州的顺序 ➊ 不同。甚至可能与书中打印的顺序也不同！
- en: As with arrays, you can use var to make a mutable dictionary or use let to make
    an immutable dictionary.
  id: totrans-4874
  prefs: []
  type: TYPE_NORMAL
  zh: 与数组一样，你可以使用 var 来创建一个可变字典，或者使用 let 来创建一个不可变字典。
- en: 'In Swift, all of the keys of a dictionary must be the same type, and all of
    the values of a dictionary must also be the same type, but the key type doesn’t
    have to match the value type. For example, if you wanted to store a collection
    of fractions, you could use doubles for the keys and strings for the values:'
  id: totrans-4875
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Swift 中，字典的所有键必须是相同类型的，字典的所有值也必须是相同类型的，但键的类型不需要与值的类型相匹配。例如，如果你想存储一组分数，你可以使用双精度浮点数（doubles）作为键，使用字符串（strings）作为值：
- en: '![](Image00142.jpg)'
  id: totrans-4876
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00142.jpg)'
- en: In this dictionary, all of the keys must be doubles, and all of the values must
    be strings. Again, you’ll see that the order of the numbers in the results pane
    can be quite different from the order in which you wrote the fractions in your
    dictionary. This is fine because you don’t need to know the order to access anything.
    You can find any item that you need by its key. Let’s see how!
  id: totrans-4877
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个字典中，所有的键必须是双精度浮点数（doubles），所有的值必须是字符串（strings）。再一次，你会看到，结果面板中数字的顺序可能与在字典中写入分数的顺序完全不同。这是没问题的，因为你不需要知道顺序就能访问任何内容。你可以通过键找到任何你需要的项。我们来看一下怎么做！
- en: '**ACCESSING VALUES IN A DICTIONARY**'
  id: totrans-4878
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**访问字典中的值**'
- en: 'Looking up a value in a dictionary is similar to how you access a value in
    an array except that you use a key inside the square brackets instead of an index,
    like this: usStates["TX"] .'
  id: totrans-4879
  prefs: []
  type: TYPE_NORMAL
  zh: 在字典中查找值的方式类似于你在数组中访问值的方式，只不过你是在方括号内使用键，而不是索引，像这样：usStates["TX"]。
- en: There is a big difference, however, in how Swift returns the values from a dictionary.
    When you access a value at an index of an array, you are simply given the value.
    When you access a value with a key in a dictionary, you are given an optional.
  id: totrans-4880
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，Swift 在从字典中返回值时有很大的不同。当你访问数组中的某个索引值时，你只是简单地得到那个值。而当你使用字典中的键来访问值时，你得到的是一个可选值（optional）。
- en: In [Chapter 5](text00015.html#ch05) , you learned that optionals might contain
    a value or might be nil . The reason Swift returns optionals when you’re looking
    up items in a dictionary is that the key you used might not exist in the dictionary,
    in which case there’s no value to access. Trying to access a value that doesn’t
    exist would give you a big fat error! To avoid that problem, Swift returns optionals.
    That means you need to unwrap any value you get out of a dictionary before you
    can do anything with it.
  id: totrans-4881
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第5章](text00015.html#ch05)中，你学习了可选值可能包含一个值，或者可能是 nil。Swift 返回可选值的原因是你查找的键可能在字典中不存在，这种情况下就没有值可以访问。尝试访问不存在的值会导致一个大的错误！为了避免这个问题，Swift
    返回可选值。这意味着你需要解包（unwrap）从字典中获取的任何值，才能对其进行操作。
- en: 'To unwrap an optional, first you check whether it exists using an if-let statement,
    just like we did in [Chapter 5](text00015.html#ch05) . The following code shows
    you how to get a value out of a dictionary:'
  id: totrans-4882
  prefs: []
  type: TYPE_NORMAL
  zh: 要展开一个可选项，首先使用 if-let 语句检查它是否存在，就像我们在 [第5章](text00015.html#ch05) 中做的那样。以下代码向你展示了如何从字典中获取一个值：
- en: '![Image](Image00143.jpg)'
  id: totrans-4883
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00143.jpg)'
- en: To retrieve "Texas" from the dictionary, we use if let to set a constant loneStarState
    to usStates["TX"] ➊ . Because we have this state in our dictionary, the line I
    have Texas in my dictionary. is printed. Next we try to access a state that is
    not in our dictionary by using the key usStates["FL"] ➋ . Thankfully, because
    we used an if-let statement, the program won’t crash when the computer can’t find
    this state. Instead, I don't have that state in my dictionary. is printed.
  id: totrans-4884
  prefs: []
  type: TYPE_NORMAL
  zh: 要从字典中检索 "Texas"，我们使用 if let 将常量 loneStarState 设置为 usStates["TX"] ➊。因为我们在字典中有这个州，所以打印出
    I have Texas in my dictionary.。接下来，我们尝试通过使用键 usStates["FL"] ➋ 来访问一个不在字典中的州。幸运的是，因为我们使用了
    if-let 语句，当计算机找不到这个州时，程序不会崩溃。相反，打印出 I don't have that state in my dictionary.
- en: '**ADDING ITEMS TO A DICTIONARY**'
  id: totrans-4885
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**向字典添加项目**'
- en: 'To add an item to a dictionary, first write the name of your dictionary and
    assign the new item to the key you want it to have in the dictionary. Let’s add
    "Minnesota" to our usStates dictionary:'
  id: totrans-4886
  prefs: []
  type: TYPE_NORMAL
  zh: 要向字典中添加一个项目，首先写下字典的名称，并将新的项目赋值给你希望它在字典中对应的键。让我们将 "Minnesota" 添加到我们的 usStates
    字典中：
- en: '![](Image00144.jpg)'
  id: totrans-4887
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00144.jpg)'
- en: 'Now when you look at usStates , you’ll see that it’s updated to ["MN": "Minnesota",
    "WA": "Washington", "MA": "Massachusetts", "TX": "Texas"] . Remember, because
    you don’t have to rely on indices, your new dictionary item might appear anywhere
    in the dictionary.'
  id: totrans-4888
  prefs: []
  type: TYPE_NORMAL
  zh: '现在，当你查看 usStates 时，你会看到它已更新为 ["MN": "Minnesota", "WA": "Washington", "MA":
    "Massachusetts", "TX": "Texas"]。记住，因为你不需要依赖索引，所以新的字典项可能出现在字典中的任何位置。'
- en: '**REMOVING ITEMS FROM A DICTIONARY**'
  id: totrans-4889
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**从字典中删除项目**'
- en: Removing an item from a dictionary is quite simple; you do so by setting the
    value to nil . Because the values in dictionaries are returned as optionals, you
    don’t have to worry about nil causing any problems in your dictionary.
  id: totrans-4890
  prefs: []
  type: TYPE_NORMAL
  zh: 从字典中删除项目非常简单；你只需将该值设置为 nil。因为字典中的值是作为可选项返回的，所以你不必担心 nil 会在字典中引发任何问题。
- en: '![](Image00145.jpg)'
  id: totrans-4891
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00145.jpg)'
- en: 'You can see that after you remove the value at the key "MA" , usStates is updated
    to ["MN": "Minnesota", "WA": "Washington", "TX": "Texas"] . Remember that nil
    is special and means that there’s no value at all. That’s why you don’t see "MA":
    nil in our dictionary.'
  id: totrans-4892
  prefs: []
  type: TYPE_NORMAL
  zh: '你可以看到，在删除键 "MA" 对应的值后，usStates 更新为 ["MN": "Minnesota", "WA": "Washington",
    "TX": "Texas"]。记住，nil 是特殊的，表示没有任何值。这就是为什么在我们的字典中你没有看到 "MA": nil 的原因。'
- en: '**REPLACING ITEMS IN A DICTIONARY**'
  id: totrans-4893
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**替换字典中的项目**'
- en: 'Replacing an item in a dictionary is also easy. It works the same was as replacing
    an item in an array. You just set the item that you want to replace to something
    else. Say you create a dictionary of fruit colors:'
  id: totrans-4894
  prefs: []
  type: TYPE_NORMAL
  zh: 替换字典中的项目也很简单。它的工作方式与替换数组中的项目一样。你只需将你想替换的项目设置为其他值。假设你创建了一个水果颜色的字典：
- en: '![](Image00146.jpg)'
  id: totrans-4895
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00146.jpg)'
- en: At first we had the value "apple" for "red" , but then we decided that "raspberry"
    is a better fruit to use since sometimes apples are green or yellow. To replace
    "apple" with "raspberry" , we set colorFruits["red"] to its new value ➊ .
  id: totrans-4896
  prefs: []
  type: TYPE_NORMAL
  zh: 一开始我们为 "red" 设置了值 "apple"，但后来我们决定 "raspberry" 更适合作为水果，因为有时苹果是绿色或黄色的。为了将 "apple"
    替换为 "raspberry"，我们将 colorFruits["red"] 设置为它的新值 ➊。
- en: You may remember that this is the same way we entered a new value into a dictionary.
    If the key already exists in the dictionary, then the value for that key is replaced.
    If the key doesn’t already exist, then the new key/value pair will be added to
    the dictionary.
  id: totrans-4897
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能记得，这就是我们将新值添加到字典中的方式。如果键已经存在于字典中，则会替换该键对应的值。如果该键尚不存在，则新的键/值对将被添加到字典中。
- en: '![Image](Image00147.jpg)'
  id: totrans-4898
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00147.jpg)'
- en: '**USING DICTIONARY PROPERTIES**'
  id: totrans-4899
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**使用字典属性**'
- en: 'Like an array, a dictionary also has an isEmpty property and a count property.
    For example, the following code shows how you can use the isEmpty property to
    check if a dictionary is empty, and if it isn’t empty, the count property checks
    how many items you have. Imagine you have a basket of fruit for sale. You can
    use these properties to help you keep track of everything:'
  id: totrans-4900
  prefs: []
  type: TYPE_NORMAL
  zh: 和数组一样，字典也有 isEmpty 属性和 count 属性。例如，以下代码展示了如何使用 isEmpty 属性检查字典是否为空，如果不为空，则使用
    count 属性检查字典中有多少项。想象你有一个待售的水果篮。你可以使用这些属性帮助你跟踪所有内容：
- en: '![Image](Image00148.jpg)'
  id: totrans-4901
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Image00148.jpg)'
- en: 'A dictionary also has two special properties: keys , which contains all of
    the dictionary’s keys, and values , which contains all of its values. We’ll use
    these two properties when we loop through the dictionary.'
  id: totrans-4902
  prefs: []
  type: TYPE_NORMAL
  zh: 字典还有两个特殊的属性：keys，包含字典中所有的键，和 values，包含字典中所有的值。我们在遍历字典时会使用这两个属性。
- en: Let’s write some code that loops through our fruit baskets and prints the price
    of each fruit.
  id: totrans-4903
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们编写一些代码，遍历我们的水果篮并打印每个水果的价格。
- en: '**LOOPING OVER A DICTIONARY**'
  id: totrans-4904
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**遍历字典**'
- en: 'You can loop through a dictionary using a for-in loop. Because each item has
    a key and a value, you can do this in two different ways. This is how to loop
    through a dictionary using its keys:'
  id: totrans-4905
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用 `for-in` 循环遍历字典。因为每个项都有一个键和一个值，您可以通过两种不同的方式来实现这一点。以下是通过键遍历字典的方法：
- en: '![Image](Image00149.jpg)'
  id: totrans-4906
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Image00149.jpg)'
- en: Here we use the dictionary’s keys property ➊ to loop through fruitBasket and
    print its contents. We start by writing the keyword for , followed by a constant
    name fruit for the dictionary key, the keyword in , the dictionary name, a period,
    and keys .
  id: totrans-4907
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们使用字典的 `keys` 属性 ➊ 来遍历 `fruitBasket` 并打印其内容。我们首先写下关键字 `for`，然后是常量名称 `fruit`，它表示字典的键，再写上关键字
    `in`，字典的名称，一个句点和 `keys`。
- en: Inside the braces of our for-in loop, we have access to both the key, which
    we call fruit ➋ , and the value at that key when we force-unwrap its contents
    with fruitBasket[fruit]! ➌ . That value will be the fruit’s price.
  id: totrans-4908
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `for-in` 循环的花括号内，我们可以访问键，我们称之为 `fruit` ➋，以及通过 `fruitBasket[fruit]!` 强制解包内容时该键对应的值
    ➌。这个值将是水果的价格。
- en: In this case, it’s safe to force-unwrap the value using an exclamation point
    because we know that the fruit key we’re using is definitely inside the dictionary.
  id: totrans-4909
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，使用感叹号强制解包值是安全的，因为我们知道我们使用的水果键一定在字典中。
- en: Any code we put inside the for-in loop will run once for every key in our dictionary.
    So you should see the print statement display three times.
  id: totrans-4910
  prefs: []
  type: TYPE_NORMAL
  zh: 我们放入 `for-in` 循环中的任何代码都会对字典中的每个键执行一次。因此，您应该看到打印语句显示三次。
- en: 'We can also loop through the dictionary using its values property:'
  id: totrans-4911
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以使用字典的 `values` 属性来遍历：
- en: '![Image](Image00150.jpg)'
  id: totrans-4912
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Image00150.jpg)'
- en: We use the same style of for-in loop, but now we use a constant to refer to
    each value, which we call price , in the values property. When looping through
    values, we don’t have access to the keys from inside the loop.
  id: totrans-4913
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用相同风格的 `for-in` 循环，但现在我们使用一个常量来引用 `values` 属性中的每个值，称之为 `price`。当遍历 `values`
    时，我们无法从循环内部访问键。
- en: Another difference to note is that price is not an optional because it’s accessed
    directly as a value in the fruitBasket dictionary. That means we don’t have to
    unwrap it. You should still see the print statement printed three times. [Figure
    6-6](text00016.html#ch06fig6) shows the output of both loops.
  id: totrans-4914
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个需要注意的区别是 `price` 不是可选类型，因为它是直接作为字典 `fruitBasket` 中的值来访问的。这意味着我们不需要解包它。您应该仍然看到打印语句被打印三次。[图
    6-6](text00016.html#ch06fig6) 显示了两种循环的输出。
- en: '![Image](Image00151.jpg)'
  id: totrans-4915
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Image00151.jpg)'
- en: '*Figure 6-6: Looping through the keys and values of a dictionary with a for-in
    loop*'
  id: totrans-4916
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 6-6：使用 `for-in` 循环遍历字典的键和值*'
- en: The order of your results might be slightly different from ours. That’s because
    the items in a dictionary aren’t in a numbered order like they are in an array!
    And because the order is not guaranteed, you might see a different order printed
    if you run the same code again.
  id: totrans-4917
  prefs: []
  type: TYPE_NORMAL
  zh: 你的结果顺序可能与我们的略有不同。这是因为字典中的项不像数组中的项那样按编号顺序排列！并且因为顺序无法保证，如果你再次运行相同的代码，打印的顺序可能会有所不同。
- en: '**WHAT YOU LEARNED**'
  id: totrans-4918
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**你学到了什么**'
- en: In this chapter, you learned how to store collections of items in an array and
    in a dictionary. To store items in an ordered list, you would use an array and
    look up each item by its index. If you wanted to store items by key instead, you
    would use a dictionary.
  id: totrans-4919
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，您学习了如何将项目存储在数组和字典中。要将项目存储在有序列表中，您应该使用数组，并通过索引查找每个项目。如果您想通过键存储项目，您应该使用字典。
- en: Knowing about arrays and dictionaries and how to use them is a powerful building
    block for almost any programming language. Next we will learn about functions,
    another very powerful tool. Functions are blocks of code that you create and name
    to perform a specific job. After you have written a function, you can use its
    name to call it from almost anywhere in your program.
  id: totrans-4920
  prefs: []
  type: TYPE_NORMAL
  zh: 了解数组和字典以及如何使用它们，是几乎所有编程语言中强大的构建模块。接下来我们将学习函数，另一种非常强大的工具。函数是你创建并命名的代码块，用于执行特定的任务。编写完函数后，你可以通过它的名称在程序中的几乎任何地方调用它。
- en: 'Let’s say you totally forgot that you went to the Petrified Forest right after
    you visited the Grand Canyon, and you want to update your nationalParks array
    so it displays the parks in the order in which you visited them. To update your
    array, you could use the insert(_:at:) method to put the Petrified Forest in the
    right position:'
  id: totrans-4921
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你完全忘记了在参观完大峡谷之后去过化石林，你想更新你的 nationalParks 数组，以便按你参观的顺序显示这些国家公园。要更新你的数组，你可以使用
    insert(_:at:) 方法将化石林插入到正确的位置：
- en: '![](Image00121.jpg)'
  id: totrans-4922
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00121.jpg)'
- en: When you insert a new item at index 3, everything that was in the array at index
    3 or higher gets scooted over to make room for the new item. That means the item
    that was at index 3 is now at index 4, the item that was at index 4 is now at
    index 5, and so on. After you add the Petrified Forest, nationalParks is now ["Acadia",
    "Zion", "Grand Canyon", "Petrified Forest", "Badlands"] .
  id: totrans-4923
  prefs: []
  type: TYPE_NORMAL
  zh: 当你在索引 3 处插入一个新元素时，数组中索引 3 或更高位置的所有元素都会向后移动，为新元素腾出空间。这意味着，原本在索引 3 处的元素现在位于索引
    4，原本在索引 4 处的元素现在位于索引 5，以此类推。添加化石林之后，nationalParks 数组现在是 ["Acadia", "Zion", "Grand
    Canyon", "Petrified Forest", "Badlands"]。
- en: '**COMBINING ARRAYS**'
  id: totrans-4924
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**合并数组**'
- en: 'Not only can you add new items to an array, but you can also add two arrays
    together using the + and += operators. Let’s say that you have the ingredients
    for a fruit smoothie in two arrays:'
  id: totrans-4925
  prefs: []
  type: TYPE_NORMAL
  zh: 你不仅可以向数组中添加新元素，还可以使用 + 和 += 运算符将两个数组合并在一起。假设你有两个数组，分别包含制作水果冰沙所需的食材：
- en: '![](Image00122.jpg)'
  id: totrans-4926
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00122.jpg)'
- en: Now you can make a delicious smoothie by adding the fruits and liquids arrays.
  id: totrans-4927
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你可以通过将水果和液体数组加入其中，制作出一杯美味的冰沙。
- en: '![](Image00123.jpg)'
  id: totrans-4928
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00123.jpg)'
- en: The order of the ingredients in smoothie is the same as the order in fruits
    and liquids . If you created smoothie with liquids + fruits , then the liquids
    would come first.
  id: totrans-4929
  prefs: []
  type: TYPE_NORMAL
  zh: 冰沙中的食材顺序与水果和液体中的顺序相同。如果你使用液体 + 水果 来制作冰沙，那么液体会排在前面。
- en: 'You use the += operator to add an array to the end of your array. Add some
    whipped cream as follows for extra yumminess:'
  id: totrans-4930
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用 += 运算符将一个数组添加到另一个数组的末尾。为增加一些美味的配料，像这样添加一些打发奶油：
- en: '![](Image00124.jpg)'
  id: totrans-4931
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00124.jpg)'
- en: Note that ["whipped cream"] is an array even though it has a single item in
    it. When you’re using += to append something to an array, you have to make sure
    you’re only trying to add another array. If you were to just write the string
    "whipped cream" without the square brackets around it, you would get an error.
  id: totrans-4932
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，尽管 ["whipped cream"] 只有一个元素，它仍然是一个数组。当你使用 += 将某个元素附加到数组时，必须确保你正在添加的是另一个数组。如果你只是写了字符串
    "whipped cream"，而没有加上方括号，那么就会出现错误。
- en: '![Image](Image00125.jpg)'
  id: totrans-4933
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00125.jpg)'
- en: '**REMOVING ITEMS FROM AN ARRAY**'
  id: totrans-4934
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**从数组中删除元素**'
- en: 'There are several methods for removing items from an array. Let’s start by
    looking at the array’s removeLast() method. As you might have guessed from its
    name, removeLast() removes the last item from your array. Let’s try it out with
    a shoppingList array:'
  id: totrans-4935
  prefs: []
  type: TYPE_NORMAL
  zh: 有几种方法可以从数组中删除元素。我们先来看一下数组的 removeLast() 方法。正如你从方法名中猜到的那样，removeLast() 会删除数组中的最后一个元素。让我们用一个购物清单数组来试试看：
- en: '![](Image00126.jpg)'
  id: totrans-4936
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00126.jpg)'
- en: Neat! Note that the removeLast() method returns the removed item, so you can
    store it in a new constant or variable if you want.
  id: totrans-4937
  prefs: []
  type: TYPE_NORMAL
  zh: 很棒！注意，removeLast() 方法会返回被删除的元素，因此，如果你想的话，可以将其存储在一个新的常量或变量中。
- en: 'You can also remove an item from a specific index by using the remove(at:)
    method. Let’s say that your mom doesn’t want you buying any candy and takes that
    off the list:'
  id: totrans-4938
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以使用 remove(at:) 方法从指定的索引删除一个元素。假设你妈妈不希望你买糖果，并将其从购物清单中移除：
- en: '![Image](Image00127.jpg)![](Image00128.jpg)'
  id: totrans-4939
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00127.jpg)![](Image00128.jpg)'
- en: Just like when we added an item to the middle of our array and all the items
    scooted over to make room, if you remove an item from the middle of an array,
    the rest of the items will scoot back to fill in that empty space. The "apples"
    item that was at index 3 is now at index 2, where "candy" was.
  id: totrans-4940
  prefs: []
  type: TYPE_NORMAL
  zh: 就像我们在数组中间添加一个项时，所有项会移动以腾出空间一样，如果你从数组的中间删除一个项，剩下的项会移动回来填补这个空位。原本在索引3处的“苹果”项，现在在索引2处，原来“糖果”所在的位置。
- en: 'You can also remove all items from an array with removeAll() . Try entering
    this into your playground:'
  id: totrans-4941
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以使用removeAll()方法移除数组中的所有项。尝试在你的游乐场中输入以下内容：
- en: '![](Image00129.jpg)'
  id: totrans-4942
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00129.jpg)'
- en: 'Note that trying to remove an item at an index that doesn’t exist will give
    you an error:'
  id: totrans-4943
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，尝试删除一个不存在索引位置的项会引发错误：
- en: '![](Image00130.jpg)'
  id: totrans-4944
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00130.jpg)'
- en: Our array doesn’t have this many items (in fact, now it’s empty!), so this throws
    an error. We’ll also get an error if we use removeLast() on our empty array, because
    there’s nothing in it—there’s no last index at all! However, removeAll() is always
    safe to use, even on an empty array.
  id: totrans-4945
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的数组没有这么多项（实际上，现在它是空的！），因此会抛出一个错误。如果我们在空数组上使用removeLast()，也会报错，因为数组里没有任何元素——根本没有最后一个索引！然而，removeAll()始终是安全的，即使在空数组上使用也不会出错。
- en: '**REPLACING ITEMS IN AN ARRAY**'
  id: totrans-4946
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**替换数组中的项**'
- en: 'To replace an item in an array, you set the index of the array to the new value,
    as shown here:'
  id: totrans-4947
  prefs: []
  type: TYPE_NORMAL
  zh: 要替换数组中的项，你只需将该数组索引的值设置为新值，如下所示：
- en: '![](Image00131.jpg)'
  id: totrans-4948
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00131.jpg)'
- en: At ➊ , we replaced the item at index 2 (the third item) with "Unicorn" because
    magical animals count as favorite animals, too! At ➋ , we replaced the item at
    index 0 (the first item) with "Bearded dragon" . No, that’s not a real dragon—it’s
    just a lizard!
  id: totrans-4949
  prefs: []
  type: TYPE_NORMAL
  zh: 在➊处，我们将索引2（第三个项）处的元素替换为“独角兽”，因为魔法动物也算作最爱的动物！在➋处，我们将索引0（第一个项）处的元素替换为“胡须龙”。不，这不是一条真正的龙——它只是只蜥蜴！
- en: Like any time you’re working with array index numbers, you have to be sure an
    item exists in the array at that index before you change its value, or you will
    get an Index out of range error.
  id: totrans-4950
  prefs: []
  type: TYPE_NORMAL
  zh: 就像任何时候你操作数组索引时一样，在修改数组项的值之前，必须确保该索引位置有元素，否则你将会遇到“索引超出范围”错误。
- en: '[Figure 6-3](text00016.html#ch06fig3) shows the error that occurs if you try
    to add "Standard poodle" using favoriteAnimals[3] = "Standard poodle" . To add
    an item to the end of an array, you should use the append(_:) method or += , as
    we covered in “[Adding Items to an Array](text00016.html#ch06lev2sec5) ” on [page
    70](text00016.html#page_70) .'
  id: totrans-4951
  prefs: []
  type: TYPE_NORMAL
  zh: '[图6-3](text00016.html#ch06fig3)展示了如果你尝试通过favoriteAnimals[3] = "Standard poodle"添加"标准贵宾犬"时会发生的错误。要将项添加到数组的末尾，应该使用append(_:)方法或+=，正如我们在“[向数组中添加项](text00016.html#ch06lev2sec5)”一节中在[第70页](text00016.html#page_70)所讲解的。'
- en: '![Image](Image00132.jpg)'
  id: totrans-4952
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00132.jpg)'
- en: '*Figure 6-3: Don’t try to replace a value at an index beyond the existing array.*'
  id: totrans-4953
  prefs: []
  type: TYPE_NORMAL
  zh: '*图6-3：不要尝试替换超出现有数组索引的值。*'
- en: Now you know how to change arrays however you might need to. You can add items,
    take items away, or replace items. Next, we’ll look at how to use the properties
    of arrays to find out even more information about them.
  id: totrans-4954
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经知道如何根据需要更改数组。你可以添加项、删除项或替换项。接下来，我们将了解如何使用数组的属性来获取更多关于数组的信息。
- en: '![Image](Image00133.jpg)'
  id: totrans-4955
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00133.jpg)'
- en: '**USING ARRAY PROPERTIES**'
  id: totrans-4956
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**使用数组属性**'
- en: In addition to methods like append(_:) and removeLast() , arrays also have *properties*
    . An array’s properties are variables or constants that contain some information
    about the array. Two really helpful properties that you might use are the Boolean
    property isEmpty and the integer property count .
  id: totrans-4957
  prefs: []
  type: TYPE_NORMAL
  zh: 除了像append(_:)和removeLast()这样的操作方法，数组还有*属性*。数组的属性是包含一些关于数组信息的变量或常量。你可能会用到的两个非常有用的属性是布尔类型的isEmpty属性和整型的count属性。
- en: The isEmpty property is true or false depending on whether the array is empty,
    and the count property will tell you how many items are in that array.
  id: totrans-4958
  prefs: []
  type: TYPE_NORMAL
  zh: isEmpty属性根据数组是否为空返回true或false，而count属性则告诉你数组中有多少个元素。
- en: 'Check out how these two properties are used in the following if-else statement:'
  id: totrans-4959
  prefs: []
  type: TYPE_NORMAL
  zh: 查看下面的if-else语句中这两个属性是如何被使用的：
- en: '![Image](Image00134.jpg)'
  id: totrans-4960
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00134.jpg)'
- en: 'This if-else statement checks whether the array mySiblings is empty ➊ . If
    it is, then "I don''t have any siblings." is printed. But if there is something
    in the array, then the number of siblings that we have is printed: "I have 3 siblings."
    ➋ .'
  id: totrans-4961
  prefs: []
  type: TYPE_NORMAL
  zh: 这个if-else语句检查数组mySiblings是否为空➊。如果为空，则输出“我没有兄弟姐妹。”但如果数组中有内容，则输出我们有多少兄弟姐妹：“我有3个兄弟姐妹。”➋。
- en: '**LOOPING OVER AN ARRAY**'
  id: totrans-4962
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**遍历数组**'
- en: 'Sometimes when you’re working with arrays you might want to do something to
    every item in the array. You can use a for-in loop to do that! The following code
    will print every topping in a pizzaToppings array on a separate line:'
  id: totrans-4963
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，当你在使用数组时，可能希望对数组中的每一项做些事情。你可以使用for-in循环来做到这一点！以下代码将在每行打印pizzaToppings数组中的每个配料：
- en: '![Image](Image00135.jpg)'
  id: totrans-4964
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Image00135.jpg)'
- en: To write a for-in loop for the pizzaToppings array, we used the keyword for
    , followed by the constant topping , then the keyword in , and finally the name
    of our array, pizzaToppings . Then we put the statements that we want to run for
    each topping inside the braces of the for-in loop. The constant topping ➊ temporarily
    represents each pizza topping in the array as we loop through it. We could have
    chosen any name for this constant, but it’s a good idea to pick something that
    makes sense. You can see the output of this for-in loop in [Figure 6-4](text00016.html#ch06fig4)
    .
  id: totrans-4965
  prefs: []
  type: TYPE_NORMAL
  zh: 要为pizzaToppings数组编写for-in循环，我们使用关键字for，后跟常量topping，再加上关键字in，最后是数组名称pizzaToppings。然后，我们将希望对每个配料执行的语句放入for-in循环的大括号内。常量topping
    ➊ 在我们循环时暂时代表数组中的每个披萨配料。我们本可以为这个常量选择任何名字，但选择一个有意义的名字是个好主意。你可以在[图6-4](text00016.html#ch06fig4)中看到这个for-in循环的输出。
- en: '![Image](Image00136.jpg)'
  id: totrans-4966
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Image00136.jpg)'
- en: '*Figure 6-4: Output of the example for-in loop*'
  id: totrans-4967
  prefs: []
  type: TYPE_NORMAL
  zh: '*图6-4：示例for-in循环的输出*'
- en: '![Image](Image00137.jpg)'
  id: totrans-4968
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Image00137.jpg)'
- en: 'Using for-in loops is great for printing every value in an array. If you’re
    working with numbers, you can even use them to perform math operations on each
    item, which makes for some speedy calculations! The following code takes an array
    of numbers and calculates the square for each (the square of a number is that
    number multiplied by itself):'
  id: totrans-4969
  prefs: []
  type: TYPE_NORMAL
  zh: 使用for-in循环是打印数组中每个值的好方法。如果你正在处理数字，甚至可以使用它们对每个项目执行数学运算，这样可以进行快速计算！以下代码接受一个数字数组，并计算每个数字的平方（一个数字的平方是该数字与其自身相乘）：
- en: '![Image](Image00138.jpg)'
  id: totrans-4970
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Image00138.jpg)'
- en: '[Figure 6-5](text00016.html#ch06fig5) shows the results.'
  id: totrans-4971
  prefs: []
  type: TYPE_NORMAL
  zh: '[图6-5](text00016.html#ch06fig5)显示了结果。'
- en: '![Image](Image00139.jpg)'
  id: totrans-4972
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Image00139.jpg)'
- en: '*Figure 6-5: Printing the squares for each number in the myNumbers array*'
  id: totrans-4973
  prefs: []
  type: TYPE_NORMAL
  zh: '*图6-5：打印myNumbers数组中每个数字的平方*'
- en: '**DICTIONARIES ARE KEY!**'
  id: totrans-4974
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**字典是关键！**'
- en: A *dictionary* is also a collection of values, but instead of an ordered index,
    each value has its own *key* . Because there’s no index, the values are not stored
    in any particular order. To access values in a dictionary, you look them up by
    their key.
  id: totrans-4975
  prefs: []
  type: TYPE_NORMAL
  zh: '*字典*也是一个值的集合，但不同于有序的索引，每个值都有自己的*键*。由于没有索引，值不会按照任何特定的顺序存储。要访问字典中的值，你需要通过键来查找它们。'
- en: A key must be unique. You can’t have the same key more than once in the same
    dictionary. If there were two identical keys and you asked the computer to give
    you the value for one of them, the computer wouldn’t know which one to choose!
  id: totrans-4976
  prefs: []
  type: TYPE_NORMAL
  zh: 键必须是唯一的。你不能在同一个字典中使用相同的键两次。如果有两个相同的键，而你要求计算机返回其中一个值，计算机将无法决定选择哪一个！
- en: Let’s take a look at how to make a dictionary and write keys that will help
    you find all the information you need.
  id: totrans-4977
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如何创建一个字典，并编写键来帮助你找到所有需要的信息。
- en: '![Image](Image00140.jpg)'
  id: totrans-4978
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Image00140.jpg)'
- en: '**INITIALIZING A DICTIONARY**'
  id: totrans-4979
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**初始化字典**'
- en: 'To create and initialize a dictionary, first write var and the name of your
    dictionary. Then write the keys and corresponding values inside a pair of square
    brackets, similar to an array. Let’s create a dictionary to store the names of
    a few US states. The key for each state will be its two-letter abbreviation:'
  id: totrans-4980
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建并初始化字典，首先写var和字典的名称。然后，在一对方括号内写键和值，类似于数组。让我们创建一个字典来存储一些美国州的名称。每个州的键将是其两个字母的缩写：
- en: '![](Image00141.jpg)'
  id: totrans-4981
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00141.jpg)'
- en: As you can see, there’s a colon between each key and its value, and the key/value
    pairs are separated by commas.
  id: totrans-4982
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，每个键和值之间有一个冒号，键/值对之间用逗号分隔。
- en: Dictionaries are different from arrays in that they are *unordered* . Because
    of that, it’s likely that the order of the states that you see in your results
    pane ➋ is different from the order in which you entered your states ➊ . It might
    even be different than the order that’s printed in this book!
  id: totrans-4983
  prefs: []
  type: TYPE_NORMAL
  zh: 字典与数组的不同之处在于它们是*无序的*。因此，你在结果面板 ➋ 中看到的状态顺序可能与输入状态 ➊ 时的顺序不同。甚至可能与本书中打印的顺序不同！
- en: As with arrays, you can use var to make a mutable dictionary or use let to make
    an immutable dictionary.
  id: totrans-4984
  prefs: []
  type: TYPE_NORMAL
  zh: 与数组一样，你可以使用var来创建可变字典，或者使用let来创建不可变字典。
- en: 'In Swift, all of the keys of a dictionary must be the same type, and all of
    the values of a dictionary must also be the same type, but the key type doesn’t
    have to match the value type. For example, if you wanted to store a collection
    of fractions, you could use doubles for the keys and strings for the values:'
  id: totrans-4985
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Swift 中，字典的所有键必须是相同类型，字典的所有值也必须是相同类型，但键的类型不必与值的类型匹配。例如，如果你想存储一组分数，你可以使用双精度浮点数作为键，字符串作为值：
- en: '![](Image00142.jpg)'
  id: totrans-4986
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00142.jpg)'
- en: In this dictionary, all of the keys must be doubles, and all of the values must
    be strings. Again, you’ll see that the order of the numbers in the results pane
    can be quite different from the order in which you wrote the fractions in your
    dictionary. This is fine because you don’t need to know the order to access anything.
    You can find any item that you need by its key. Let’s see how!
  id: totrans-4987
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个字典中，所有的键必须是双精度浮点数，所有的值必须是字符串。同样，你会发现结果面板中的数字顺序可能与写入字典时分数的顺序完全不同。这是没问题的，因为你不需要知道顺序就能访问任何内容。你可以通过键找到任何你需要的项目。让我们看看怎么做！
- en: '**ACCESSING VALUES IN A DICTIONARY**'
  id: totrans-4988
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**访问字典中的值**'
- en: 'Looking up a value in a dictionary is similar to how you access a value in
    an array except that you use a key inside the square brackets instead of an index,
    like this: usStates["TX"] .'
  id: totrans-4989
  prefs: []
  type: TYPE_NORMAL
  zh: 在字典中查找一个值类似于在数组中访问一个值，只不过你使用的是方括号内的键而不是索引，像这样：usStates["TX"]。
- en: There is a big difference, however, in how Swift returns the values from a dictionary.
    When you access a value at an index of an array, you are simply given the value.
    When you access a value with a key in a dictionary, you are given an optional.
  id: totrans-4990
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，Swift 在返回字典中的值时有很大不同。当你在数组的索引处访问一个值时，你只是简单地获取这个值。当你通过字典中的键访问一个值时，你会得到一个可选值。
- en: In [Chapter 5](text00015.html#ch05) , you learned that optionals might contain
    a value or might be nil . The reason Swift returns optionals when you’re looking
    up items in a dictionary is that the key you used might not exist in the dictionary,
    in which case there’s no value to access. Trying to access a value that doesn’t
    exist would give you a big fat error! To avoid that problem, Swift returns optionals.
    That means you need to unwrap any value you get out of a dictionary before you
    can do anything with it.
  id: totrans-4991
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第 5 章](text00015.html#ch05) 中，你学过可选值可能包含一个值，也可能是 nil。Swift 在你查找字典中的项目时返回可选值的原因是，你使用的键可能在字典中不存在，在这种情况下没有值可供访问。试图访问一个不存在的值会给你一个很大的错误！为避免这个问题，Swift
    返回可选值。这意味着你需要在对字典取出的任何值进行操作之前先解包它。
- en: 'To unwrap an optional, first you check whether it exists using an if-let statement,
    just like we did in [Chapter 5](text00015.html#ch05) . The following code shows
    you how to get a value out of a dictionary:'
  id: totrans-4992
  prefs: []
  type: TYPE_NORMAL
  zh: 要解包一个可选值，首先你需要通过 if-let 语句检查它是否存在，就像我们在[第 5 章](text00015.html#ch05) 中做的那样。以下代码展示了如何从字典中取出一个值：
- en: '![Image](Image00143.jpg)'
  id: totrans-4993
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00143.jpg)'
- en: To retrieve "Texas" from the dictionary, we use if let to set a constant loneStarState
    to usStates["TX"] ➊ . Because we have this state in our dictionary, the line I
    have Texas in my dictionary. is printed. Next we try to access a state that is
    not in our dictionary by using the key usStates["FL"] ➋ . Thankfully, because
    we used an if-let statement, the program won’t crash when the computer can’t find
    this state. Instead, I don't have that state in my dictionary. is printed.
  id: totrans-4994
  prefs: []
  type: TYPE_NORMAL
  zh: 要从字典中检索“Texas”，我们使用 if let 来将常量 loneStarState 设置为 usStates["TX"] ➊ 。因为我们在字典中有这个州，所以会打印出
    "I have Texas in my dictionary." 接下来，我们尝试使用键 usStates["FL"] ➋ 访问一个不在字典中的州。幸运的是，因为我们使用了
    if-let 语句，当计算机找不到这个州时，程序不会崩溃。相反，"I don't have that state in my dictionary." 会被打印出来。
- en: '**ADDING ITEMS TO A DICTIONARY**'
  id: totrans-4995
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**向字典添加项目**'
- en: 'To add an item to a dictionary, first write the name of your dictionary and
    assign the new item to the key you want it to have in the dictionary. Let’s add
    "Minnesota" to our usStates dictionary:'
  id: totrans-4996
  prefs: []
  type: TYPE_NORMAL
  zh: 要向字典添加项目，首先写下字典的名称，并将新项目分配给你希望它在字典中对应的键。让我们向我们的 usStates 字典中添加 "Minnesota"：
- en: '![](Image00144.jpg)'
  id: totrans-4997
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00144.jpg)'
- en: 'Now when you look at usStates , you’ll see that it’s updated to ["MN": "Minnesota",
    "WA": "Washington", "MA": "Massachusetts", "TX": "Texas"] . Remember, because
    you don’t have to rely on indices, your new dictionary item might appear anywhere
    in the dictionary.'
  id: totrans-4998
  prefs: []
  type: TYPE_NORMAL
  zh: '现在，当你查看 usStates 时，你会看到它已经更新为 ["MN": "Minnesota", "WA": "Washington", "MA":
    "Massachusetts", "TX": "Texas"]。记住，因为你不需要依赖索引，你的新字典项可能出现在字典中的任何位置。'
- en: '**REMOVING ITEMS FROM A DICTIONARY**'
  id: totrans-4999
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**从字典中移除项目**'
- en: Removing an item from a dictionary is quite simple; you do so by setting the
    value to nil . Because the values in dictionaries are returned as optionals, you
    don’t have to worry about nil causing any problems in your dictionary.
  id: totrans-5000
  prefs: []
  type: TYPE_NORMAL
  zh: 从字典中移除项目非常简单；你只需将值设置为nil。由于字典中的值是以可选项的形式返回的，因此你不需要担心nil会在字典中引发问题。
- en: '![](Image00145.jpg)'
  id: totrans-5001
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00145.jpg)'
- en: 'You can see that after you remove the value at the key "MA" , usStates is updated
    to ["MN": "Minnesota", "WA": "Washington", "TX": "Texas"] . Remember that nil
    is special and means that there’s no value at all. That’s why you don’t see "MA":
    nil in our dictionary.'
  id: totrans-5002
  prefs: []
  type: TYPE_NORMAL
  zh: '你可以看到，在你移除键"MA"的值后，usStates被更新为["MN": "Minnesota", "WA": "Washington", "TX":
    "Texas"]。记住，nil是特殊的，意味着没有值。这就是为什么你不会在字典中看到"MA": nil。'
- en: '**REPLACING ITEMS IN A DICTIONARY**'
  id: totrans-5003
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**替换字典中的项目**'
- en: 'Replacing an item in a dictionary is also easy. It works the same was as replacing
    an item in an array. You just set the item that you want to replace to something
    else. Say you create a dictionary of fruit colors:'
  id: totrans-5004
  prefs: []
  type: TYPE_NORMAL
  zh: 替换字典中的项目也很简单。它的工作方式与替换数组中的项目相同。你只需将想替换的项目设置为其他值。例如，你创建一个包含水果颜色的字典：
- en: '![](Image00146.jpg)'
  id: totrans-5005
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00146.jpg)'
- en: At first we had the value "apple" for "red" , but then we decided that "raspberry"
    is a better fruit to use since sometimes apples are green or yellow. To replace
    "apple" with "raspberry" , we set colorFruits["red"] to its new value ➊ .
  id: totrans-5006
  prefs: []
  type: TYPE_NORMAL
  zh: 一开始我们为"red"提供了"apple"这个值，但后来我们决定"raspberry"更适合作为水果，因为有时苹果是绿色或黄色的。为了将"apple"替换为"raspberry"，我们将colorFruits["red"]的值设置为新的值
    ➊。
- en: You may remember that this is the same way we entered a new value into a dictionary.
    If the key already exists in the dictionary, then the value for that key is replaced.
    If the key doesn’t already exist, then the new key/value pair will be added to
    the dictionary.
  id: totrans-5007
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能记得，这和我们向字典中插入新值的方式相同。如果键已经存在于字典中，那么该键的值会被替换。如果键不存在，那么新的键/值对将被添加到字典中。
- en: '![Image](Image00147.jpg)'
  id: totrans-5008
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00147.jpg)'
- en: '**USING DICTIONARY PROPERTIES**'
  id: totrans-5009
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**使用字典属性**'
- en: 'Like an array, a dictionary also has an isEmpty property and a count property.
    For example, the following code shows how you can use the isEmpty property to
    check if a dictionary is empty, and if it isn’t empty, the count property checks
    how many items you have. Imagine you have a basket of fruit for sale. You can
    use these properties to help you keep track of everything:'
  id: totrans-5010
  prefs: []
  type: TYPE_NORMAL
  zh: 和数组一样，字典也有isEmpty属性和count属性。例如，以下代码展示了如何使用isEmpty属性检查字典是否为空，如果不为空，则count属性会检查字典中有多少项。想象你有一个出售的水果篮。你可以使用这些属性来帮助你跟踪一切：
- en: '![Image](Image00148.jpg)'
  id: totrans-5011
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00148.jpg)'
- en: 'A dictionary also has two special properties: keys , which contains all of
    the dictionary’s keys, and values , which contains all of its values. We’ll use
    these two properties when we loop through the dictionary.'
  id: totrans-5012
  prefs: []
  type: TYPE_NORMAL
  zh: 字典还有两个特殊的属性：keys，它包含字典的所有键；以及values，它包含字典的所有值。我们将在遍历字典时使用这两个属性。
- en: Let’s write some code that loops through our fruit baskets and prints the price
    of each fruit.
  id: totrans-5013
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们写一些代码，遍历我们的水果篮，并打印每种水果的价格。
- en: '**LOOPING OVER A DICTIONARY**'
  id: totrans-5014
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**遍历字典**'
- en: 'You can loop through a dictionary using a for-in loop. Because each item has
    a key and a value, you can do this in two different ways. This is how to loop
    through a dictionary using its keys:'
  id: totrans-5015
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用for-in循环遍历字典。因为每个项目都有一个键和一个值，你可以通过两种不同的方式进行遍历。这是使用字典的键来遍历字典的方法：
- en: '![Image](Image00149.jpg)'
  id: totrans-5016
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00149.jpg)'
- en: Here we use the dictionary’s keys property ➊ to loop through fruitBasket and
    print its contents. We start by writing the keyword for , followed by a constant
    name fruit for the dictionary key, the keyword in , the dictionary name, a period,
    and keys .
  id: totrans-5017
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们使用字典的keys属性 ➊ 来遍历fruitBasket并打印其内容。我们首先写出关键字for，接着是字典键的常量名称fruit，关键字in，字典名称，一个句点，和keys。
- en: Inside the braces of our for-in loop, we have access to both the key, which
    we call fruit ➋ , and the value at that key when we force-unwrap its contents
    with fruitBasket[fruit]! ➌ . That value will be the fruit’s price.
  id: totrans-5018
  prefs: []
  type: TYPE_NORMAL
  zh: 在for-in循环的大括号内，我们可以访问键fruit ➋，以及通过强制解包其内容fruitBasket[fruit]! ➌ 获取该键的值。这个值将是水果的价格。
- en: In this case, it’s safe to force-unwrap the value using an exclamation point
    because we know that the fruit key we’re using is definitely inside the dictionary.
  id: totrans-5019
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，使用感叹号强制解包值是安全的，因为我们知道我们使用的水果键一定存在于字典中。
- en: Any code we put inside the for-in loop will run once for every key in our dictionary.
    So you should see the print statement display three times.
  id: totrans-5020
  prefs: []
  type: TYPE_NORMAL
  zh: 我们放在 `for-in` 循环中的任何代码都会针对字典中的每个键执行一次。所以你应该看到打印语句显示三次。
- en: 'We can also loop through the dictionary using its values property:'
  id: totrans-5021
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以通过字典的 `values` 属性进行循环：
- en: '![Image](Image00150.jpg)'
  id: totrans-5022
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00150.jpg)'
- en: We use the same style of for-in loop, but now we use a constant to refer to
    each value, which we call price , in the values property. When looping through
    values, we don’t have access to the keys from inside the loop.
  id: totrans-5023
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用相同的 `for-in` 循环方式，但现在使用常量来引用 `values` 属性中的每个值，这个常量我们称之为 `price`。在循环 `values`
    时，我们无法访问循环中的键。
- en: Another difference to note is that price is not an optional because it’s accessed
    directly as a value in the fruitBasket dictionary. That means we don’t have to
    unwrap it. You should still see the print statement printed three times. [Figure
    6-6](text00016.html#ch06fig6) shows the output of both loops.
  id: totrans-5024
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个需要注意的区别是，价格不是可选的，因为它是直接作为值在 `fruitBasket` 字典中访问的。这意味着我们不需要解包它。你仍然应该看到打印语句打印三次。[图6-6](text00016.html#ch06fig6)显示了两个循环的输出。
- en: '![Image](Image00151.jpg)'
  id: totrans-5025
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00151.jpg)'
- en: '*Figure 6-6: Looping through the keys and values of a dictionary with a for-in
    loop*'
  id: totrans-5026
  prefs: []
  type: TYPE_NORMAL
  zh: '*图6-6：使用 `for-in` 循环遍历字典的键和值*'
- en: The order of your results might be slightly different from ours. That’s because
    the items in a dictionary aren’t in a numbered order like they are in an array!
    And because the order is not guaranteed, you might see a different order printed
    if you run the same code again.
  id: totrans-5027
  prefs: []
  type: TYPE_NORMAL
  zh: 你的结果顺序可能与我们的略有不同。那是因为字典中的项目不像数组中的项目那样有编号顺序！而且因为顺序无法保证，所以如果你再次运行相同的代码，你可能会看到不同的顺序被打印出来。
- en: '**WHAT YOU LEARNED**'
  id: totrans-5028
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**你学到了什么**'
- en: In this chapter, you learned how to store collections of items in an array and
    in a dictionary. To store items in an ordered list, you would use an array and
    look up each item by its index. If you wanted to store items by key instead, you
    would use a dictionary.
  id: totrans-5029
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你学习了如何在数组和字典中存储项目集合。要将项目存储在有序列表中，你应该使用数组，并通过索引查找每个项目。如果你想按键来存储项目，则应使用字典。
- en: Knowing about arrays and dictionaries and how to use them is a powerful building
    block for almost any programming language. Next we will learn about functions,
    another very powerful tool. Functions are blocks of code that you create and name
    to perform a specific job. After you have written a function, you can use its
    name to call it from almost anywhere in your program.
  id: totrans-5030
  prefs: []
  type: TYPE_NORMAL
  zh: 了解数组和字典及其使用方法是几乎所有编程语言中一个强大的构建模块。接下来我们将学习函数，这是另一个非常强大的工具。函数是你创建并命名的代码块，用来执行特定的工作。编写完函数后，你可以通过它的名称在程序中的几乎任何地方调用它。
- en: '![](Image00121.jpg)'
  id: totrans-5031
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00121.jpg)'
- en: When you insert a new item at index 3, everything that was in the array at index
    3 or higher gets scooted over to make room for the new item. That means the item
    that was at index 3 is now at index 4, the item that was at index 4 is now at
    index 5, and so on. After you add the Petrified Forest, nationalParks is now ["Acadia",
    "Zion", "Grand Canyon", "Petrified Forest", "Badlands"] .
  id: totrans-5032
  prefs: []
  type: TYPE_NORMAL
  zh: 当你在索引 3 处插入一个新项目时，数组中索引为 3 或更高的所有项目都会被挪动，腾出空间来放置新项目。这意味着原来位于索引 3 的项目现在位于索引 4，原来位于索引
    4 的项目现在位于索引 5，依此类推。添加了“Petrified Forest”后，`nationalParks` 数组现在变为 ["Acadia", "Zion",
    "Grand Canyon", "Petrified Forest", "Badlands"]。
- en: '**COMBINING ARRAYS**'
  id: totrans-5033
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**合并数组**'
- en: 'Not only can you add new items to an array, but you can also add two arrays
    together using the + and += operators. Let’s say that you have the ingredients
    for a fruit smoothie in two arrays:'
  id: totrans-5034
  prefs: []
  type: TYPE_NORMAL
  zh: 你不仅可以向数组添加新项目，还可以使用 `+` 和 `+=` 运算符将两个数组合并。假设你有两个数组，分别包含制作水果冰沙的配料：
- en: '![](Image00122.jpg)'
  id: totrans-5035
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00122.jpg)'
- en: Now you can make a delicious smoothie by adding the fruits and liquids arrays.
  id: totrans-5036
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你可以通过添加水果和液体数组来制作美味的冰沙。
- en: '![](Image00123.jpg)'
  id: totrans-5037
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00123.jpg)'
- en: The order of the ingredients in smoothie is the same as the order in fruits
    and liquids . If you created smoothie with liquids + fruits , then the liquids
    would come first.
  id: totrans-5038
  prefs: []
  type: TYPE_NORMAL
  zh: 冰沙中的配料顺序与水果和液体中的顺序相同。如果你先将液体加到水果后面制作冰沙，那么液体会排在前面。
- en: 'You use the += operator to add an array to the end of your array. Add some
    whipped cream as follows for extra yumminess:'
  id: totrans-5039
  prefs: []
  type: TYPE_NORMAL
  zh: 你使用 `+=` 运算符将一个数组添加到另一个数组的末尾。为了增加一些美味感，可以按如下方式添加一些鲜奶油：
- en: '![](Image00124.jpg)'
  id: totrans-5040
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00124.jpg)'
- en: Note that ["whipped cream"] is an array even though it has a single item in
    it. When you’re using += to append something to an array, you have to make sure
    you’re only trying to add another array. If you were to just write the string
    "whipped cream" without the square brackets around it, you would get an error.
  id: totrans-5041
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，["whipped cream"] 是一个数组，即使它只包含一个元素。当你使用 += 向数组追加元素时，必须确保你只是试图添加另一个数组。如果你只写字符串
    "whipped cream" 而没有加上方括号，就会报错。
- en: '![Image](Image00125.jpg)'
  id: totrans-5042
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00125.jpg)'
- en: '**REMOVING ITEMS FROM AN ARRAY**'
  id: totrans-5043
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**从数组中移除元素**'
- en: 'There are several methods for removing items from an array. Let’s start by
    looking at the array’s removeLast() method. As you might have guessed from its
    name, removeLast() removes the last item from your array. Let’s try it out with
    a shoppingList array:'
  id: totrans-5044
  prefs: []
  type: TYPE_NORMAL
  zh: 有几种方法可以从数组中移除元素。我们先来看一下数组的 removeLast() 方法。顾名思义，removeLast() 会移除数组中的最后一个元素。我们来用一个
    shoppingList 数组试试：
- en: '![](Image00126.jpg)'
  id: totrans-5045
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00126.jpg)'
- en: Neat! Note that the removeLast() method returns the removed item, so you can
    store it in a new constant or variable if you want.
  id: totrans-5046
  prefs: []
  type: TYPE_NORMAL
  zh: 很棒！请注意，removeLast() 方法返回被移除的元素，因此如果你想，你可以将其存储在一个新的常量或变量中。
- en: 'You can also remove an item from a specific index by using the remove(at:)
    method. Let’s say that your mom doesn’t want you buying any candy and takes that
    off the list:'
  id: totrans-5047
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以使用 remove(at:) 方法从特定索引移除元素。假设你妈妈不想让你买糖果，把它从列表上拿掉：
- en: '![Image](Image00127.jpg)![](Image00128.jpg)'
  id: totrans-5048
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00127.jpg)![](Image00128.jpg)'
- en: Just like when we added an item to the middle of our array and all the items
    scooted over to make room, if you remove an item from the middle of an array,
    the rest of the items will scoot back to fill in that empty space. The "apples"
    item that was at index 3 is now at index 2, where "candy" was.
  id: totrans-5049
  prefs: []
  type: TYPE_NORMAL
  zh: 就像我们在数组中间添加元素时，所有其他元素都会挪动以腾出空间一样，如果你从数组中间移除一个元素，其余的元素会挪回去填补空缺。原本在索引 3 的 "apples"
    现在在索引 2，原来 "candy" 所在的位置。
- en: 'You can also remove all items from an array with removeAll() . Try entering
    this into your playground:'
  id: totrans-5050
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以使用 removeAll() 移除数组中的所有元素。试着将这个输入到你的 Playground 中：
- en: '![](Image00129.jpg)'
  id: totrans-5051
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00129.jpg)'
- en: 'Note that trying to remove an item at an index that doesn’t exist will give
    you an error:'
  id: totrans-5052
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，尝试移除一个不存在的索引处的元素会导致错误：
- en: '![](Image00130.jpg)'
  id: totrans-5053
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00130.jpg)'
- en: Our array doesn’t have this many items (in fact, now it’s empty!), so this throws
    an error. We’ll also get an error if we use removeLast() on our empty array, because
    there’s nothing in it—there’s no last index at all! However, removeAll() is always
    safe to use, even on an empty array.
  id: totrans-5054
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的数组没有这么多元素（实际上，现在它是空的！），所以会抛出一个错误。如果我们在空数组上使用 removeLast()，也会报错，因为它什么也没有——根本没有最后一个索引！不过，removeAll()
    即使在空数组上使用也是安全的。
- en: '**REPLACING ITEMS IN AN ARRAY**'
  id: totrans-5055
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**替换数组中的元素**'
- en: 'To replace an item in an array, you set the index of the array to the new value,
    as shown here:'
  id: totrans-5056
  prefs: []
  type: TYPE_NORMAL
  zh: 要替换数组中的元素，可以将数组的索引设置为新值，如下所示：
- en: '![](Image00131.jpg)'
  id: totrans-5057
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00131.jpg)'
- en: At ➊ , we replaced the item at index 2 (the third item) with "Unicorn" because
    magical animals count as favorite animals, too! At ➋ , we replaced the item at
    index 0 (the first item) with "Bearded dragon" . No, that’s not a real dragon—it’s
    just a lizard!
  id: totrans-5058
  prefs: []
  type: TYPE_NORMAL
  zh: 在 ➊，我们用 "Unicorn" 替换了索引 2（第三个元素）的位置，因为魔法动物也算作最爱的动物！在 ➋，我们用 "Bearded dragon"
    替换了索引 0（第一个元素）的位置。不，这不是一条真正的龙——它只是一只蜥蜴！
- en: Like any time you’re working with array index numbers, you have to be sure an
    item exists in the array at that index before you change its value, or you will
    get an Index out of range error.
  id: totrans-5059
  prefs: []
  type: TYPE_NORMAL
  zh: 就像任何时候你处理数组索引时一样，必须确保数组中在该索引处存在元素，然后才能更改其值，否则会出现索引超出范围的错误。
- en: '[Figure 6-3](text00016.html#ch06fig3) shows the error that occurs if you try
    to add "Standard poodle" using favoriteAnimals[3] = "Standard poodle" . To add
    an item to the end of an array, you should use the append(_:) method or += , as
    we covered in “[Adding Items to an Array](text00016.html#ch06lev2sec5) ” on [page
    70](text00016.html#page_70) .'
  id: totrans-5060
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 6-3](text00016.html#ch06fig3) 展示了如果你试图通过 favoriteAnimals[3] = "Standard
    poodle" 来添加 "Standard poodle" 时发生的错误。要向数组的末尾添加元素，你应该使用 append(_:) 方法或 +=，我们在 “[向数组添加元素](text00016.html#ch06lev2sec5)”
    中已经讲解过了，见 [第 70 页](text00016.html#page_70)。'
- en: '![Image](Image00132.jpg)'
  id: totrans-5061
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00132.jpg)'
- en: '*Figure 6-3: Don’t try to replace a value at an index beyond the existing array.*'
  id: totrans-5062
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 6-3：不要尝试替换超出现有数组索引范围的值。*'
- en: Now you know how to change arrays however you might need to. You can add items,
    take items away, or replace items. Next, we’ll look at how to use the properties
    of arrays to find out even more information about them.
  id: totrans-5063
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你知道如何根据需要修改数组了。你可以添加、删除或替换数组中的项。接下来，我们将学习如何使用数组的属性来获取更多关于数组的信息。
- en: '![Image](Image00133.jpg)'
  id: totrans-5064
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Image00133.jpg)'
- en: '**USING ARRAY PROPERTIES**'
  id: totrans-5065
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**使用数组属性**'
- en: In addition to methods like append(_:) and removeLast() , arrays also have *properties*
    . An array’s properties are variables or constants that contain some information
    about the array. Two really helpful properties that you might use are the Boolean
    property isEmpty and the integer property count .
  id: totrans-5066
  prefs: []
  type: TYPE_NORMAL
  zh: 除了像append(_:)和removeLast()这样的函数，数组还拥有*属性*。数组的属性是包含数组相关信息的变量或常量。有两个非常有用的属性，你可能会用到，它们分别是布尔类型的isEmpty属性和整型的count属性。
- en: The isEmpty property is true or false depending on whether the array is empty,
    and the count property will tell you how many items are in that array.
  id: totrans-5067
  prefs: []
  type: TYPE_NORMAL
  zh: isEmpty属性的值为真或假，取决于数组是否为空，而count属性则告诉你数组中有多少项。
- en: 'Check out how these two properties are used in the following if-else statement:'
  id: totrans-5068
  prefs: []
  type: TYPE_NORMAL
  zh: 看一下以下if-else语句中这两个属性的使用方法：
- en: '![Image](Image00134.jpg)'
  id: totrans-5069
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Image00134.jpg)'
- en: 'This if-else statement checks whether the array mySiblings is empty ➊ . If
    it is, then "I don''t have any siblings." is printed. But if there is something
    in the array, then the number of siblings that we have is printed: "I have 3 siblings."
    ➋ .'
  id: totrans-5070
  prefs: []
  type: TYPE_NORMAL
  zh: 这个if-else语句检查数组mySiblings是否为空 ➊。如果为空，就会打印“我没有兄弟姐妹。”如果数组中有内容，则打印我们有几个兄弟姐妹：“我有3个兄弟姐妹。”
    ➋。
- en: '**LOOPING OVER AN ARRAY**'
  id: totrans-5071
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**遍历数组**'
- en: 'Sometimes when you’re working with arrays you might want to do something to
    every item in the array. You can use a for-in loop to do that! The following code
    will print every topping in a pizzaToppings array on a separate line:'
  id: totrans-5072
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，当你在处理数组时，可能需要对数组中的每一项做一些操作。你可以使用for-in循环来做到这一点！以下代码会把pizzaToppings数组中的每个配料分别打印到一行：
- en: '![Image](Image00135.jpg)'
  id: totrans-5073
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Image00135.jpg)'
- en: To write a for-in loop for the pizzaToppings array, we used the keyword for
    , followed by the constant topping , then the keyword in , and finally the name
    of our array, pizzaToppings . Then we put the statements that we want to run for
    each topping inside the braces of the for-in loop. The constant topping ➊ temporarily
    represents each pizza topping in the array as we loop through it. We could have
    chosen any name for this constant, but it’s a good idea to pick something that
    makes sense. You can see the output of this for-in loop in [Figure 6-4](text00016.html#ch06fig4)
    .
  id: totrans-5074
  prefs: []
  type: TYPE_NORMAL
  zh: 为了编写pizzaToppings数组的for-in循环，我们使用了关键字for，后跟常量topping，然后是关键字in，最后是我们的数组名称pizzaToppings。然后，我们将希望对每个配料执行的语句放入for-in循环的大括号内。常量topping
    ➊在我们循环遍历数组时，暂时代表数组中的每个披萨配料。我们本可以选择任何名字来作为这个常量，但最好选一个有意义的名称。你可以在[图6-4](text00016.html#ch06fig4)中看到这个for-in循环的输出。
- en: '![Image](Image00136.jpg)'
  id: totrans-5075
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Image00136.jpg)'
- en: '*Figure 6-4: Output of the example for-in loop*'
  id: totrans-5076
  prefs: []
  type: TYPE_NORMAL
  zh: '*图6-4：示例for-in循环的输出*'
- en: '![Image](Image00137.jpg)'
  id: totrans-5077
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Image00137.jpg)'
- en: 'Using for-in loops is great for printing every value in an array. If you’re
    working with numbers, you can even use them to perform math operations on each
    item, which makes for some speedy calculations! The following code takes an array
    of numbers and calculates the square for each (the square of a number is that
    number multiplied by itself):'
  id: totrans-5078
  prefs: []
  type: TYPE_NORMAL
  zh: 使用for-in循环非常适合打印数组中的每个值。如果你在处理数字，你甚至可以用它们对每一项进行数学运算，这样就能进行快速的计算！以下代码接收一个数字数组并计算每个数字的平方（数字的平方是数字与它自己相乘）：
- en: '![Image](Image00138.jpg)'
  id: totrans-5079
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Image00138.jpg)'
- en: '[Figure 6-5](text00016.html#ch06fig5) shows the results.'
  id: totrans-5080
  prefs: []
  type: TYPE_NORMAL
  zh: '[图6-5](text00016.html#ch06fig5)显示了结果。'
- en: '![Image](Image00139.jpg)'
  id: totrans-5081
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Image00139.jpg)'
- en: '*Figure 6-5: Printing the squares for each number in the myNumbers array*'
  id: totrans-5082
  prefs: []
  type: TYPE_NORMAL
  zh: '*图6-5：打印myNumbers数组中每个数字的平方*'
- en: '**DICTIONARIES ARE KEY!**'
  id: totrans-5083
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**字典是关键！**'
- en: A *dictionary* is also a collection of values, but instead of an ordered index,
    each value has its own *key* . Because there’s no index, the values are not stored
    in any particular order. To access values in a dictionary, you look them up by
    their key.
  id: totrans-5084
  prefs: []
  type: TYPE_NORMAL
  zh: '*字典*也是一种值的集合，但与有序索引不同，每个值都有自己的*键*。由于没有索引，值并没有按照特定顺序存储。要访问字典中的值，你需要通过键来查找它们。'
- en: A key must be unique. You can’t have the same key more than once in the same
    dictionary. If there were two identical keys and you asked the computer to give
    you the value for one of them, the computer wouldn’t know which one to choose!
  id: totrans-5085
  prefs: []
  type: TYPE_NORMAL
  zh: 键必须是唯一的。您不能在同一个字典中有重复的键。如果存在两个相同的键，而您要求计算机给出其中一个的值，计算机将不知道选择哪个！
- en: Let’s take a look at how to make a dictionary and write keys that will help
    you find all the information you need.
  id: totrans-5086
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如何创建一个字典，并编写键，帮助您找到所有需要的信息。
- en: '![Image](Image00140.jpg)'
  id: totrans-5087
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00140.jpg)'
- en: '**INITIALIZING A DICTIONARY**'
  id: totrans-5088
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**初始化字典**'
- en: 'To create and initialize a dictionary, first write var and the name of your
    dictionary. Then write the keys and corresponding values inside a pair of square
    brackets, similar to an array. Let’s create a dictionary to store the names of
    a few US states. The key for each state will be its two-letter abbreviation:'
  id: totrans-5089
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建并初始化一个字典，首先写 `var` 和字典的名称。然后，将键和值放入一对方括号中，类似于数组。让我们创建一个字典来存储几个美国州的名称。每个州的键将是它的两字母缩写：
- en: '![](Image00141.jpg)'
  id: totrans-5090
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00141.jpg)'
- en: As you can see, there’s a colon between each key and its value, and the key/value
    pairs are separated by commas.
  id: totrans-5091
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，每个键和值之间有一个冒号，键/值对之间用逗号分隔。
- en: Dictionaries are different from arrays in that they are *unordered* . Because
    of that, it’s likely that the order of the states that you see in your results
    pane ➋ is different from the order in which you entered your states ➊ . It might
    even be different than the order that’s printed in this book!
  id: totrans-5092
  prefs: []
  type: TYPE_NORMAL
  zh: 字典与数组的不同之处在于它们是 *无序的*。因此，您在结果面板 ➋ 中看到的州的顺序可能与您输入州的顺序 ➊ 不同。它甚至可能与本书中打印的顺序不同！
- en: As with arrays, you can use var to make a mutable dictionary or use let to make
    an immutable dictionary.
  id: totrans-5093
  prefs: []
  type: TYPE_NORMAL
  zh: 与数组一样，您可以使用 `var` 来创建一个可变字典，或者使用 `let` 来创建一个不可变字典。
- en: 'In Swift, all of the keys of a dictionary must be the same type, and all of
    the values of a dictionary must also be the same type, but the key type doesn’t
    have to match the value type. For example, if you wanted to store a collection
    of fractions, you could use doubles for the keys and strings for the values:'
  id: totrans-5094
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Swift 中，字典的所有键必须是相同的类型，字典的所有值也必须是相同的类型，但键的类型不必与值的类型匹配。例如，如果您想存储一个分数集合，您可以使用双精度浮点数作为键，使用字符串作为值：
- en: '![](Image00142.jpg)'
  id: totrans-5095
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00142.jpg)'
- en: In this dictionary, all of the keys must be doubles, and all of the values must
    be strings. Again, you’ll see that the order of the numbers in the results pane
    can be quite different from the order in which you wrote the fractions in your
    dictionary. This is fine because you don’t need to know the order to access anything.
    You can find any item that you need by its key. Let’s see how!
  id: totrans-5096
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个字典中，所有的键必须是双精度浮点数，所有的值必须是字符串。同样，您会看到结果面板中的数字顺序可能与您在字典中写入分数的顺序相差甚远。这没问题，因为您不需要知道顺序来访问任何内容。您可以通过键找到任何所需的项。让我们看看怎么做！
- en: '**ACCESSING VALUES IN A DICTIONARY**'
  id: totrans-5097
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**访问字典中的值**'
- en: 'Looking up a value in a dictionary is similar to how you access a value in
    an array except that you use a key inside the square brackets instead of an index,
    like this: usStates["TX"] .'
  id: totrans-5098
  prefs: []
  type: TYPE_NORMAL
  zh: 在字典中查找一个值的方式类似于在数组中查找值，不同的是，您使用键而不是索引，在方括号内，例如：usStates["TX"]。
- en: There is a big difference, however, in how Swift returns the values from a dictionary.
    When you access a value at an index of an array, you are simply given the value.
    When you access a value with a key in a dictionary, you are given an optional.
  id: totrans-5099
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，Swift 返回字典值的方式存在一个很大的区别。当您访问数组中的某个索引时，您只会获得该值。而当您使用字典中的键访问一个值时，您会得到一个可选项。
- en: In [Chapter 5](text00015.html#ch05) , you learned that optionals might contain
    a value or might be nil . The reason Swift returns optionals when you’re looking
    up items in a dictionary is that the key you used might not exist in the dictionary,
    in which case there’s no value to access. Trying to access a value that doesn’t
    exist would give you a big fat error! To avoid that problem, Swift returns optionals.
    That means you need to unwrap any value you get out of a dictionary before you
    can do anything with it.
  id: totrans-5100
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第5章](text00015.html#ch05)中，您学到了可选项可能包含一个值，也可能是 nil。Swift 在您查找字典中的项时返回可选项，是因为您使用的键可能不存在于字典中，在这种情况下无法访问值。尝试访问不存在的值将导致一个错误！为避免这个问题，Swift
    返回可选项。这意味着您需要解包从字典中获取的任何值，才能对其进行操作。
- en: 'To unwrap an optional, first you check whether it exists using an if-let statement,
    just like we did in [Chapter 5](text00015.html#ch05) . The following code shows
    you how to get a value out of a dictionary:'
  id: totrans-5101
  prefs: []
  type: TYPE_NORMAL
  zh: 要解包一个可选值，首先你需要通过 `if-let` 语句检查它是否存在，就像我们在[第5章](text00015.html#ch05)中做的那样。以下代码展示了如何从字典中获取一个值：
- en: '![Image](Image00143.jpg)'
  id: totrans-5102
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Image00143.jpg)'
- en: To retrieve "Texas" from the dictionary, we use if let to set a constant loneStarState
    to usStates["TX"] ➊ . Because we have this state in our dictionary, the line I
    have Texas in my dictionary. is printed. Next we try to access a state that is
    not in our dictionary by using the key usStates["FL"] ➋ . Thankfully, because
    we used an if-let statement, the program won’t crash when the computer can’t find
    this state. Instead, I don't have that state in my dictionary. is printed.
  id: totrans-5103
  prefs: []
  type: TYPE_NORMAL
  zh: 要从字典中检索 "Texas"，我们使用 `if let` 将常量 loneStarState 设置为 usStates["TX"] ➊。因为我们在字典中有这个州，所以打印出
    "I have Texas in my dictionary."。接下来，我们尝试通过使用键 usStates["FL"] ➋ 访问一个不在字典中的州。幸运的是，因为我们使用了
    `if-let` 语句，当计算机找不到这个州时，程序不会崩溃。相反，打印出 "I don't have that state in my dictionary."。
- en: '**ADDING ITEMS TO A DICTIONARY**'
  id: totrans-5104
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**向字典添加项目**'
- en: 'To add an item to a dictionary, first write the name of your dictionary and
    assign the new item to the key you want it to have in the dictionary. Let’s add
    "Minnesota" to our usStates dictionary:'
  id: totrans-5105
  prefs: []
  type: TYPE_NORMAL
  zh: 要向字典添加一个项目，首先写出字典的名称，然后将新项目赋值给你希望它拥有的键。让我们将 "Minnesota" 添加到我们的 usStates 字典中：
- en: '![](Image00144.jpg)'
  id: totrans-5106
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00144.jpg)'
- en: 'Now when you look at usStates , you’ll see that it’s updated to ["MN": "Minnesota",
    "WA": "Washington", "MA": "Massachusetts", "TX": "Texas"] . Remember, because
    you don’t have to rely on indices, your new dictionary item might appear anywhere
    in the dictionary.'
  id: totrans-5107
  prefs: []
  type: TYPE_NORMAL
  zh: '现在，当你查看 usStates 时，你会看到它已经更新为 ["MN": "Minnesota", "WA": "Washington", "MA":
    "Massachusetts", "TX": "Texas"]。记住，由于你不需要依赖索引，新的字典项目可能出现在字典的任何位置。'
- en: '**REMOVING ITEMS FROM A DICTIONARY**'
  id: totrans-5108
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**从字典中移除项目**'
- en: Removing an item from a dictionary is quite simple; you do so by setting the
    value to nil . Because the values in dictionaries are returned as optionals, you
    don’t have to worry about nil causing any problems in your dictionary.
  id: totrans-5109
  prefs: []
  type: TYPE_NORMAL
  zh: 从字典中移除一个项目非常简单；你可以通过将值设置为 nil 来实现。因为字典中的值是作为可选值返回的，所以你不必担心 nil 会在字典中造成任何问题。
- en: '![](Image00145.jpg)'
  id: totrans-5110
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00145.jpg)'
- en: 'You can see that after you remove the value at the key "MA" , usStates is updated
    to ["MN": "Minnesota", "WA": "Washington", "TX": "Texas"] . Remember that nil
    is special and means that there’s no value at all. That’s why you don’t see "MA":
    nil in our dictionary.'
  id: totrans-5111
  prefs: []
  type: TYPE_NORMAL
  zh: '你可以看到，在你移除键 "MA" 对应的值后，usStates 被更新为 ["MN": "Minnesota", "WA": "Washington",
    "TX": "Texas"]。记住，nil 是特殊的，它表示没有任何值。这就是为什么你在字典中看不到 "MA": nil 的原因。'
- en: '**REPLACING ITEMS IN A DICTIONARY**'
  id: totrans-5112
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**替换字典中的项目**'
- en: 'Replacing an item in a dictionary is also easy. It works the same was as replacing
    an item in an array. You just set the item that you want to replace to something
    else. Say you create a dictionary of fruit colors:'
  id: totrans-5113
  prefs: []
  type: TYPE_NORMAL
  zh: 替换字典中的项目也很简单。它的工作方式与替换数组中的项目相同。你只需要将你想替换的项目设置为其他值。假设你创建了一个关于水果颜色的字典：
- en: '![](Image00146.jpg)'
  id: totrans-5114
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00146.jpg)'
- en: At first we had the value "apple" for "red" , but then we decided that "raspberry"
    is a better fruit to use since sometimes apples are green or yellow. To replace
    "apple" with "raspberry" , we set colorFruits["red"] to its new value ➊ .
  id: totrans-5115
  prefs: []
  type: TYPE_NORMAL
  zh: 最初我们为 "red" 设置了 "apple" 作为值，但后来我们决定 "raspberry" 更适合作为水果，因为有时候苹果是绿色或黄色的。为了将 "apple"
    替换为 "raspberry"，我们将 colorFruits["red"] 设置为新的值 ➊。
- en: You may remember that this is the same way we entered a new value into a dictionary.
    If the key already exists in the dictionary, then the value for that key is replaced.
    If the key doesn’t already exist, then the new key/value pair will be added to
    the dictionary.
  id: totrans-5116
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能还记得，这与我们向字典中添加新值的方式相同。如果键已经存在于字典中，则该键对应的值将被替换。如果键不存在，则新的键/值对将被添加到字典中。
- en: '![Image](Image00147.jpg)'
  id: totrans-5117
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Image00147.jpg)'
- en: '**USING DICTIONARY PROPERTIES**'
  id: totrans-5118
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**使用字典属性**'
- en: 'Like an array, a dictionary also has an isEmpty property and a count property.
    For example, the following code shows how you can use the isEmpty property to
    check if a dictionary is empty, and if it isn’t empty, the count property checks
    how many items you have. Imagine you have a basket of fruit for sale. You can
    use these properties to help you keep track of everything:'
  id: totrans-5119
  prefs: []
  type: TYPE_NORMAL
  zh: 与数组一样，字典也有 isEmpty 属性和 count 属性。例如，以下代码展示了如何使用 isEmpty 属性来检查字典是否为空，如果不为空，则使用
    count 属性来检查字典中有多少个项目。假设你有一篮水果要出售。你可以使用这些属性来帮助你追踪所有物品：
- en: '![Image](Image00148.jpg)'
  id: totrans-5120
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00148.jpg)'
- en: 'A dictionary also has two special properties: keys , which contains all of
    the dictionary’s keys, and values , which contains all of its values. We’ll use
    these two properties when we loop through the dictionary.'
  id: totrans-5121
  prefs: []
  type: TYPE_NORMAL
  zh: 字典还有两个特殊的属性：`keys`，它包含字典中的所有键，以及`values`，它包含字典中的所有值。我们将在循环遍历字典时使用这两个属性。
- en: Let’s write some code that loops through our fruit baskets and prints the price
    of each fruit.
  id: totrans-5122
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们编写一些代码，循环遍历我们的水果篮，并打印每种水果的价格。
- en: '**LOOPING OVER A DICTIONARY**'
  id: totrans-5123
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**遍历字典**'
- en: 'You can loop through a dictionary using a for-in loop. Because each item has
    a key and a value, you can do this in two different ways. This is how to loop
    through a dictionary using its keys:'
  id: totrans-5124
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用`for-in`循环遍历字典。因为每个项目都有一个键和值，所以你可以有两种不同的方式来做这件事。这是使用字典的键来进行循环的方式：
- en: '![Image](Image00149.jpg)'
  id: totrans-5125
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00149.jpg)'
- en: Here we use the dictionary’s keys property ➊ to loop through fruitBasket and
    print its contents. We start by writing the keyword for , followed by a constant
    name fruit for the dictionary key, the keyword in , the dictionary name, a period,
    and keys .
  id: totrans-5126
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们使用字典的`keys`属性 ➊ 来循环遍历`fruitBasket`并打印其内容。我们首先编写关键字`for`，接着是常量名称`fruit`表示字典的键，关键字`in`，字典名称，句点和`keys`。
- en: Inside the braces of our for-in loop, we have access to both the key, which
    we call fruit ➋ , and the value at that key when we force-unwrap its contents
    with fruitBasket[fruit]! ➌ . That value will be the fruit’s price.
  id: totrans-5127
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的`for-in`循环的花括号内，我们可以访问到键，我们称之为`fruit` ➋，以及当我们强制解包`fruitBasket[fruit]!` ➌时，该键的值。这个值将是水果的价格。
- en: In this case, it’s safe to force-unwrap the value using an exclamation point
    because we know that the fruit key we’re using is definitely inside the dictionary.
  id: totrans-5128
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，使用感叹号强制解包值是安全的，因为我们知道我们使用的`fruit`键肯定在字典中。
- en: Any code we put inside the for-in loop will run once for every key in our dictionary.
    So you should see the print statement display three times.
  id: totrans-5129
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在`for-in`循环中放入的任何代码都会对字典中的每个键执行一次。因此，你应该看到打印语句显示三次。
- en: 'We can also loop through the dictionary using its values property:'
  id: totrans-5130
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以使用字典的`values`属性进行循环：
- en: '![Image](Image00150.jpg)'
  id: totrans-5131
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00150.jpg)'
- en: We use the same style of for-in loop, but now we use a constant to refer to
    each value, which we call price , in the values property. When looping through
    values, we don’t have access to the keys from inside the loop.
  id: totrans-5132
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用相同风格的`for-in`循环，但这次我们使用常量来引用`values`属性中的每个值，我们称之为`price`。在遍历值时，我们无法从循环内部访问到键。
- en: Another difference to note is that price is not an optional because it’s accessed
    directly as a value in the fruitBasket dictionary. That means we don’t have to
    unwrap it. You should still see the print statement printed three times. [Figure
    6-6](text00016.html#ch06fig6) shows the output of both loops.
  id: totrans-5133
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个需要注意的区别是，`price`不是可选类型，因为它直接作为`fruitBasket`字典中的值访问。这意味着我们不需要解包它。你仍然应该看到打印语句被打印三次。[图6-6](text00016.html#ch06fig6)展示了两个循环的输出。
- en: '![Image](Image00151.jpg)'
  id: totrans-5134
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00151.jpg)'
- en: '*Figure 6-6: Looping through the keys and values of a dictionary with a for-in
    loop*'
  id: totrans-5135
  prefs: []
  type: TYPE_NORMAL
  zh: '*图6-6：使用`for-in`循环遍历字典的键和值*'
- en: The order of your results might be slightly different from ours. That’s because
    the items in a dictionary aren’t in a numbered order like they are in an array!
    And because the order is not guaranteed, you might see a different order printed
    if you run the same code again.
  id: totrans-5136
  prefs: []
  type: TYPE_NORMAL
  zh: 你的结果顺序可能与我们的稍有不同。这是因为字典中的项目不像数组中的元素那样是按编号顺序排列的！由于顺序不能保证，如果你重新运行相同的代码，可能会看到不同的输出顺序。
- en: '**WHAT YOU LEARNED**'
  id: totrans-5137
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**你学到了什么**'
- en: In this chapter, you learned how to store collections of items in an array and
    in a dictionary. To store items in an ordered list, you would use an array and
    look up each item by its index. If you wanted to store items by key instead, you
    would use a dictionary.
  id: totrans-5138
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你学习了如何将项目存储在数组和字典中。为了将项目存储在有序的列表中，你会使用数组，并通过索引查找每个项目。如果你想通过键存储项目，则会使用字典。
- en: Knowing about arrays and dictionaries and how to use them is a powerful building
    block for almost any programming language. Next we will learn about functions,
    another very powerful tool. Functions are blocks of code that you create and name
    to perform a specific job. After you have written a function, you can use its
    name to call it from almost anywhere in your program.
  id: totrans-5139
  prefs: []
  type: TYPE_NORMAL
  zh: 了解数组和字典的使用方法是几乎所有编程语言中的一个强大构建模块。接下来我们将学习函数，这也是一个非常强大的工具。函数是你创建并命名的一段代码，用于执行特定的任务。编写完函数后，你可以通过它的名称从程序的任何地方调用它。
- en: When you insert a new item at index 3, everything that was in the array at index
    3 or higher gets scooted over to make room for the new item. That means the item
    that was at index 3 is now at index 4, the item that was at index 4 is now at
    index 5, and so on. After you add the Petrified Forest, nationalParks is now ["Acadia",
    "Zion", "Grand Canyon", "Petrified Forest", "Badlands"] .
  id: totrans-5140
  prefs: []
  type: TYPE_NORMAL
  zh: 当你在索引 3 处插入一个新项时，原本在索引 3 或更高位置的所有项都会向后移动，为新项腾出空间。这意味着原本在索引 3 的项现在位于索引 4，原本在索引
    4 的项现在位于索引 5，以此类推。在你添加了“Petrified Forest”之后，nationalParks 现在是 ["Acadia", "Zion",
    "Grand Canyon", "Petrified Forest", "Badlands"]。
- en: '**COMBINING ARRAYS**'
  id: totrans-5141
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**合并数组**'
- en: 'Not only can you add new items to an array, but you can also add two arrays
    together using the + and += operators. Let’s say that you have the ingredients
    for a fruit smoothie in two arrays:'
  id: totrans-5142
  prefs: []
  type: TYPE_NORMAL
  zh: 你不仅可以向数组中添加新项，还可以使用 + 和 += 操作符将两个数组连接起来。假设你有两组冰沙的配料，分别存储在两个数组中：
- en: '![](Image00122.jpg)'
  id: totrans-5143
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00122.jpg)'
- en: Now you can make a delicious smoothie by adding the fruits and liquids arrays.
  id: totrans-5144
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你可以通过将水果和液体数组结合起来，制作美味的冰沙。
- en: '![](Image00123.jpg)'
  id: totrans-5145
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00123.jpg)'
- en: The order of the ingredients in smoothie is the same as the order in fruits
    and liquids . If you created smoothie with liquids + fruits , then the liquids
    would come first.
  id: totrans-5146
  prefs: []
  type: TYPE_NORMAL
  zh: 冰沙中的配料顺序与水果和液体数组中的顺序相同。如果你用 liquids + fruits 创建冰沙，那么液体会先出现。
- en: 'You use the += operator to add an array to the end of your array. Add some
    whipped cream as follows for extra yumminess:'
  id: totrans-5147
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用 += 操作符将一个数组添加到另一个数组的末尾。为了增加额外的美味，加入一些奶油：
- en: '![](Image00124.jpg)'
  id: totrans-5148
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00124.jpg)'
- en: Note that ["whipped cream"] is an array even though it has a single item in
    it. When you’re using += to append something to an array, you have to make sure
    you’re only trying to add another array. If you were to just write the string
    "whipped cream" without the square brackets around it, you would get an error.
  id: totrans-5149
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，尽管 ["whipped cream"] 只是一个包含单个元素的数组，它依然是一个数组。当你使用 += 操作符向数组添加内容时，必须确保你只是在添加另一个数组。如果你直接写出字符串
    "whipped cream" 而不加上方括号，系统会报错。
- en: '![Image](Image00125.jpg)'
  id: totrans-5150
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00125.jpg)'
- en: '**REMOVING ITEMS FROM AN ARRAY**'
  id: totrans-5151
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**从数组中移除项**'
- en: 'There are several methods for removing items from an array. Let’s start by
    looking at the array’s removeLast() method. As you might have guessed from its
    name, removeLast() removes the last item from your array. Let’s try it out with
    a shoppingList array:'
  id: totrans-5152
  prefs: []
  type: TYPE_NORMAL
  zh: 有多种方法可以从数组中移除项。让我们首先看看数组的 removeLast() 方法。正如你从名称中猜到的，removeLast() 会移除数组中的最后一项。我们来用一个
    shoppingList 数组试一下：
- en: '![](Image00126.jpg)'
  id: totrans-5153
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00126.jpg)'
- en: Neat! Note that the removeLast() method returns the removed item, so you can
    store it in a new constant or variable if you want.
  id: totrans-5154
  prefs: []
  type: TYPE_NORMAL
  zh: 真棒！注意，removeLast() 方法会返回被移除的项，因此如果需要，你可以将其存储在一个新的常量或变量中。
- en: 'You can also remove an item from a specific index by using the remove(at:)
    method. Let’s say that your mom doesn’t want you buying any candy and takes that
    off the list:'
  id: totrans-5155
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以使用 remove(at:) 方法从特定的索引移除一项。假设你妈妈不想让你买糖果，于是将它从购物清单中移除：
- en: '![Image](Image00127.jpg)![](Image00128.jpg)'
  id: totrans-5156
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00127.jpg)![](Image00128.jpg)'
- en: Just like when we added an item to the middle of our array and all the items
    scooted over to make room, if you remove an item from the middle of an array,
    the rest of the items will scoot back to fill in that empty space. The "apples"
    item that was at index 3 is now at index 2, where "candy" was.
  id: totrans-5157
  prefs: []
  type: TYPE_NORMAL
  zh: 就像我们在数组中间添加一个项时，所有的项都会向后移动一样，如果你从数组中间移除一项，其余的项会向前移动，填补空缺。原本在索引 3 的“apples”项现在位于索引
    2，那里原本是“candy”。
- en: 'You can also remove all items from an array with removeAll() . Try entering
    this into your playground:'
  id: totrans-5158
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以使用 removeAll() 移除数组中的所有项。试试在你的 playground 中输入这个：
- en: '![](Image00129.jpg)'
  id: totrans-5159
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00129.jpg)'
- en: 'Note that trying to remove an item at an index that doesn’t exist will give
    you an error:'
  id: totrans-5160
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，尝试移除一个不存在的索引项会导致错误：
- en: '![](Image00130.jpg)'
  id: totrans-5161
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00130.jpg)'
- en: Our array doesn’t have this many items (in fact, now it’s empty!), so this throws
    an error. We’ll also get an error if we use removeLast() on our empty array, because
    there’s nothing in it—there’s no last index at all! However, removeAll() is always
    safe to use, even on an empty array.
  id: totrans-5162
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的数组没有这么多项（事实上，现在它是空的！），所以这会抛出一个错误。如果我们对空数组使用 removeLast()，也会报错，因为它里面什么也没有——根本没有最后一个索引！不过，removeAll()
    始终是安全的，即使是对空数组使用。
- en: '**REPLACING ITEMS IN AN ARRAY**'
  id: totrans-5163
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**替换数组中的项**'
- en: 'To replace an item in an array, you set the index of the array to the new value,
    as shown here:'
  id: totrans-5164
  prefs: []
  type: TYPE_NORMAL
  zh: 要替换数组中的项，你只需将数组的索引设置为新值，如下所示：
- en: '![](Image00131.jpg)'
  id: totrans-5165
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00131.jpg)'
- en: At ➊ , we replaced the item at index 2 (the third item) with "Unicorn" because
    magical animals count as favorite animals, too! At ➋ , we replaced the item at
    index 0 (the first item) with "Bearded dragon" . No, that’s not a real dragon—it’s
    just a lizard!
  id: totrans-5166
  prefs: []
  type: TYPE_NORMAL
  zh: 在 ➊ 处，我们用 "Unicorn" 替换了索引 2（第三项）处的元素，因为神奇动物也算是最爱的动物！在 ➋ 处，我们用 "Bearded dragon"
    替换了索引 0（第一项）处的元素。不，这不是一条真正的龙，它只是一个蜥蜴！
- en: Like any time you’re working with array index numbers, you have to be sure an
    item exists in the array at that index before you change its value, or you will
    get an Index out of range error.
  id: totrans-5167
  prefs: []
  type: TYPE_NORMAL
  zh: 像处理数组索引号时一样，在你改变数组某个索引的值之前，必须确保该索引处的项是存在的，否则你会遇到 “索引超出范围” 错误。
- en: '[Figure 6-3](text00016.html#ch06fig3) shows the error that occurs if you try
    to add "Standard poodle" using favoriteAnimals[3] = "Standard poodle" . To add
    an item to the end of an array, you should use the append(_:) method or += , as
    we covered in “[Adding Items to an Array](text00016.html#ch06lev2sec5) ” on [page
    70](text00016.html#page_70) .'
  id: totrans-5168
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 6-3](text00016.html#ch06fig3) 显示了如果你尝试使用 favoriteAnimals[3] = "Standard
    poodle" 添加 "Standard poodle" 时发生的错误。要向数组的末尾添加项，你应该使用 append(_:) 方法或 +=，正如我们在 “[向数组添加项](text00016.html#ch06lev2sec5)”中所讨论的，见
    [第 70 页](text00016.html#page_70)。'
- en: '![Image](Image00132.jpg)'
  id: totrans-5169
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00132.jpg)'
- en: '*Figure 6-3: Don’t try to replace a value at an index beyond the existing array.*'
  id: totrans-5170
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 6-3：不要尝试替换超出现有数组范围的索引值。*'
- en: Now you know how to change arrays however you might need to. You can add items,
    take items away, or replace items. Next, we’ll look at how to use the properties
    of arrays to find out even more information about them.
  id: totrans-5171
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你知道如何根据需要修改数组了。你可以添加项、删除项或替换项。接下来，我们将探讨如何使用数组的属性来获取更多关于数组的信息。
- en: '![Image](Image00133.jpg)'
  id: totrans-5172
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00133.jpg)'
- en: '**USING ARRAY PROPERTIES**'
  id: totrans-5173
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**使用数组属性**'
- en: In addition to methods like append(_:) and removeLast() , arrays also have *properties*
    . An array’s properties are variables or constants that contain some information
    about the array. Two really helpful properties that you might use are the Boolean
    property isEmpty and the integer property count .
  id: totrans-5174
  prefs: []
  type: TYPE_NORMAL
  zh: 除了像 append(_:) 和 removeLast() 这样的函数外，数组还有 *属性*。数组的属性是包含一些关于数组信息的变量或常量。你可能会用到的两个非常有用的属性是布尔类型的
    isEmpty 属性和整数类型的 count 属性。
- en: The isEmpty property is true or false depending on whether the array is empty,
    and the count property will tell you how many items are in that array.
  id: totrans-5175
  prefs: []
  type: TYPE_NORMAL
  zh: isEmpty 属性为 true 或 false，取决于数组是否为空，count 属性将告诉你数组中有多少项。
- en: 'Check out how these two properties are used in the following if-else statement:'
  id: totrans-5176
  prefs: []
  type: TYPE_NORMAL
  zh: 看看以下 if-else 语句中这两个属性是如何使用的：
- en: '![Image](Image00134.jpg)'
  id: totrans-5177
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00134.jpg)'
- en: 'This if-else statement checks whether the array mySiblings is empty ➊ . If
    it is, then "I don''t have any siblings." is printed. But if there is something
    in the array, then the number of siblings that we have is printed: "I have 3 siblings."
    ➋ .'
  id: totrans-5178
  prefs: []
  type: TYPE_NORMAL
  zh: 这个 if-else 语句检查数组 mySiblings 是否为空 ➊。如果为空，则会打印 "我没有兄弟姐妹。" 如果数组中有内容，则会打印我们有多少兄弟姐妹："我有
    3 个兄弟姐妹。" ➋。
- en: '**LOOPING OVER AN ARRAY**'
  id: totrans-5179
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**遍历数组**'
- en: 'Sometimes when you’re working with arrays you might want to do something to
    every item in the array. You can use a for-in loop to do that! The following code
    will print every topping in a pizzaToppings array on a separate line:'
  id: totrans-5180
  prefs: []
  type: TYPE_NORMAL
  zh: 有时在处理数组时，你可能想对数组中的每一项做一些操作。你可以使用 for-in 循环来实现这一点！下面的代码会在每一行上打印 pizzaToppings
    数组中的每个配料：
- en: '![Image](Image00135.jpg)'
  id: totrans-5181
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00135.jpg)'
- en: To write a for-in loop for the pizzaToppings array, we used the keyword for
    , followed by the constant topping , then the keyword in , and finally the name
    of our array, pizzaToppings . Then we put the statements that we want to run for
    each topping inside the braces of the for-in loop. The constant topping ➊ temporarily
    represents each pizza topping in the array as we loop through it. We could have
    chosen any name for this constant, but it’s a good idea to pick something that
    makes sense. You can see the output of this for-in loop in [Figure 6-4](text00016.html#ch06fig4)
    .
  id: totrans-5182
  prefs: []
  type: TYPE_NORMAL
  zh: 为了为 `pizzaToppings` 数组写一个 for-in 循环，我们使用了关键字 for，接着是常量 `topping`，然后是关键字 in，最后是我们数组的名称
    `pizzaToppings`。然后我们将想要对每个 topping 执行的语句放在 for-in 循环的花括号内。常量 `topping` ➊ 在我们遍历数组时，暂时表示数组中的每个披萨配料。我们本可以为这个常量选择任何名称，但选择一个有意义的名称是一个好主意。你可以在[图
    6-4](text00016.html#ch06fig4)中看到这个 for-in 循环的输出。
- en: '![Image](Image00136.jpg)'
  id: totrans-5183
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00136.jpg)'
- en: '*Figure 6-4: Output of the example for-in loop*'
  id: totrans-5184
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 6-4：示例 for-in 循环的输出*'
- en: '![Image](Image00137.jpg)'
  id: totrans-5185
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00137.jpg)'
- en: 'Using for-in loops is great for printing every value in an array. If you’re
    working with numbers, you can even use them to perform math operations on each
    item, which makes for some speedy calculations! The following code takes an array
    of numbers and calculates the square for each (the square of a number is that
    number multiplied by itself):'
  id: totrans-5186
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 for-in 循环非常适合打印数组中的每个值。如果你在处理数字，甚至可以用它们对每个项目执行数学运算，这样可以快速进行计算！以下代码获取一个数字数组，并计算每个数字的平方（一个数字的平方是该数字与其本身相乘）：
- en: '![Image](Image00138.jpg)'
  id: totrans-5187
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00138.jpg)'
- en: '[Figure 6-5](text00016.html#ch06fig5) shows the results.'
  id: totrans-5188
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 6-5](text00016.html#ch06fig5) 显示了结果。'
- en: '![Image](Image00139.jpg)'
  id: totrans-5189
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00139.jpg)'
- en: '*Figure 6-5: Printing the squares for each number in the myNumbers array*'
  id: totrans-5190
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 6-5：打印 myNumbers 数组中每个数字的平方*'
- en: '**DICTIONARIES ARE KEY!**'
  id: totrans-5191
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**字典非常重要！**'
- en: A *dictionary* is also a collection of values, but instead of an ordered index,
    each value has its own *key* . Because there’s no index, the values are not stored
    in any particular order. To access values in a dictionary, you look them up by
    their key.
  id: totrans-5192
  prefs: []
  type: TYPE_NORMAL
  zh: 一个 *字典* 也是一个值的集合，但不同于数组，它没有顺序索引，而是每个值都有自己的 *键*。由于没有索引，值的存储没有特定顺序。要访问字典中的值，你需要通过键来查找它们。
- en: A key must be unique. You can’t have the same key more than once in the same
    dictionary. If there were two identical keys and you asked the computer to give
    you the value for one of them, the computer wouldn’t know which one to choose!
  id: totrans-5193
  prefs: []
  type: TYPE_NORMAL
  zh: 一个键必须是唯一的。在同一个字典中不能有相同的键。如果有两个相同的键，当你要求计算机返回其中一个的值时，计算机就无法知道该选择哪个！
- en: Let’s take a look at how to make a dictionary and write keys that will help
    you find all the information you need.
  id: totrans-5194
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看一下如何创建一个字典，并编写键值对，帮助你找到所需的所有信息。
- en: '![Image](Image00140.jpg)'
  id: totrans-5195
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00140.jpg)'
- en: '**INITIALIZING A DICTIONARY**'
  id: totrans-5196
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**初始化字典**'
- en: 'To create and initialize a dictionary, first write var and the name of your
    dictionary. Then write the keys and corresponding values inside a pair of square
    brackets, similar to an array. Let’s create a dictionary to store the names of
    a few US states. The key for each state will be its two-letter abbreviation:'
  id: totrans-5197
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建并初始化一个字典，首先写 `var` 和字典的名称。然后在一对方括号内写入键和值，类似于数组的格式。让我们创建一个字典来存储几个美国州的名称。每个州的键将是它的两位字母缩写：
- en: '![](Image00141.jpg)'
  id: totrans-5198
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00141.jpg)'
- en: As you can see, there’s a colon between each key and its value, and the key/value
    pairs are separated by commas.
  id: totrans-5199
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，每个键和值之间有一个冒号，键/值对之间用逗号分隔。
- en: Dictionaries are different from arrays in that they are *unordered* . Because
    of that, it’s likely that the order of the states that you see in your results
    pane ➋ is different from the order in which you entered your states ➊ . It might
    even be different than the order that’s printed in this book!
  id: totrans-5200
  prefs: []
  type: TYPE_NORMAL
  zh: 字典与数组的不同之处在于，字典是 *无序的*。因此，你在结果面板中看到的州的顺序 ➋ 可能与输入的顺序 ➊ 不同，甚至可能与本书中打印的顺序不同！
- en: As with arrays, you can use var to make a mutable dictionary or use let to make
    an immutable dictionary.
  id: totrans-5201
  prefs: []
  type: TYPE_NORMAL
  zh: 与数组一样，你可以使用 `var` 来创建一个可变字典，或使用 `let` 来创建一个不可变字典。
- en: 'In Swift, all of the keys of a dictionary must be the same type, and all of
    the values of a dictionary must also be the same type, but the key type doesn’t
    have to match the value type. For example, if you wanted to store a collection
    of fractions, you could use doubles for the keys and strings for the values:'
  id: totrans-5202
  prefs: []
  type: TYPE_NORMAL
  zh: 在Swift中，字典的所有键必须是相同类型的，字典的所有值也必须是相同类型的，但键类型不必与值类型匹配。例如，如果你想存储一组分数，可以使用双精度浮点数作为键，字符串作为值：
- en: '![](Image00142.jpg)'
  id: totrans-5203
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00142.jpg)'
- en: In this dictionary, all of the keys must be doubles, and all of the values must
    be strings. Again, you’ll see that the order of the numbers in the results pane
    can be quite different from the order in which you wrote the fractions in your
    dictionary. This is fine because you don’t need to know the order to access anything.
    You can find any item that you need by its key. Let’s see how!
  id: totrans-5204
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个字典中，所有的键必须是双精度浮点数，所有的值必须是字符串。同样，你会看到，结果面板中数字的顺序可能与您在字典中写分数的顺序非常不同。这没关系，因为你不需要知道顺序来访问任何内容。你可以通过键找到任何你需要的项。我们来看看如何做到这一点！
- en: '**ACCESSING VALUES IN A DICTIONARY**'
  id: totrans-5205
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**访问字典中的值**'
- en: 'Looking up a value in a dictionary is similar to how you access a value in
    an array except that you use a key inside the square brackets instead of an index,
    like this: usStates["TX"] .'
  id: totrans-5206
  prefs: []
  type: TYPE_NORMAL
  zh: 在字典中查找一个值类似于在数组中访问一个值，除了你使用的是方括号内的键，而不是索引，像这样：usStates["TX"]。
- en: There is a big difference, however, in how Swift returns the values from a dictionary.
    When you access a value at an index of an array, you are simply given the value.
    When you access a value with a key in a dictionary, you are given an optional.
  id: totrans-5207
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，Swift返回字典中的值有一个很大的不同。当你访问数组中的一个索引值时，你只会得到值。而当你用键访问字典中的值时，你会得到一个可选值。
- en: In [Chapter 5](text00015.html#ch05) , you learned that optionals might contain
    a value or might be nil . The reason Swift returns optionals when you’re looking
    up items in a dictionary is that the key you used might not exist in the dictionary,
    in which case there’s no value to access. Trying to access a value that doesn’t
    exist would give you a big fat error! To avoid that problem, Swift returns optionals.
    That means you need to unwrap any value you get out of a dictionary before you
    can do anything with it.
  id: totrans-5208
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第5章](text00015.html#ch05)中，你学到过可选值可能包含一个值，也可能是nil。Swift在你查找字典中的项时返回可选值的原因是，你使用的键可能在字典中不存在，在这种情况下，就没有值可以访问。尝试访问一个不存在的值会给你一个大的错误！为了避免这个问题，Swift返回可选值。这意味着在你可以对字典中的值进行任何操作之前，你需要解包它。
- en: 'To unwrap an optional, first you check whether it exists using an if-let statement,
    just like we did in [Chapter 5](text00015.html#ch05) . The following code shows
    you how to get a value out of a dictionary:'
  id: totrans-5209
  prefs: []
  type: TYPE_NORMAL
  zh: 要解包一个可选值，首先检查它是否存在，使用if-let语句，就像我们在[第5章](text00015.html#ch05)中做的那样。以下代码展示了如何从字典中获取一个值：
- en: '![Image](Image00143.jpg)'
  id: totrans-5210
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00143.jpg)'
- en: To retrieve "Texas" from the dictionary, we use if let to set a constant loneStarState
    to usStates["TX"] ➊ . Because we have this state in our dictionary, the line I
    have Texas in my dictionary. is printed. Next we try to access a state that is
    not in our dictionary by using the key usStates["FL"] ➋ . Thankfully, because
    we used an if-let statement, the program won’t crash when the computer can’t find
    this state. Instead, I don't have that state in my dictionary. is printed.
  id: totrans-5211
  prefs: []
  type: TYPE_NORMAL
  zh: 要从字典中获取“Texas”，我们使用if let将常量loneStarState设置为usStates["TX"] ➊。因为我们的字典中有这个州，所以会打印出“I
    have Texas in my dictionary.”。接下来，我们尝试通过使用键usStates["FL"] ➋访问一个不在字典中的州。幸运的是，因为我们使用了if-let语句，当计算机找不到这个州时，程序不会崩溃。相反，会打印出“I
    don't have that state in my dictionary.”。
- en: '**ADDING ITEMS TO A DICTIONARY**'
  id: totrans-5212
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**向字典添加项**'
- en: 'To add an item to a dictionary, first write the name of your dictionary and
    assign the new item to the key you want it to have in the dictionary. Let’s add
    "Minnesota" to our usStates dictionary:'
  id: totrans-5213
  prefs: []
  type: TYPE_NORMAL
  zh: 要向字典添加项目，首先写出字典的名称，并将新项分配给你希望它在字典中拥有的键。我们来向我们的usStates字典中添加“Minnesota”：
- en: '![](Image00144.jpg)'
  id: totrans-5214
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00144.jpg)'
- en: 'Now when you look at usStates , you’ll see that it’s updated to ["MN": "Minnesota",
    "WA": "Washington", "MA": "Massachusetts", "TX": "Texas"] . Remember, because
    you don’t have to rely on indices, your new dictionary item might appear anywhere
    in the dictionary.'
  id: totrans-5215
  prefs: []
  type: TYPE_NORMAL
  zh: '现在，当你查看usStates时，你会看到它已更新为["MN": "Minnesota", "WA": "Washington", "MA": "Massachusetts",
    "TX": "Texas"]。记住，因为你不需要依赖索引，所以你的新字典项可能会出现在字典的任何位置。'
- en: '**REMOVING ITEMS FROM A DICTIONARY**'
  id: totrans-5216
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**从字典中移除项**'
- en: Removing an item from a dictionary is quite simple; you do so by setting the
    value to nil . Because the values in dictionaries are returned as optionals, you
    don’t have to worry about nil causing any problems in your dictionary.
  id: totrans-5217
  prefs: []
  type: TYPE_NORMAL
  zh: 从字典中移除项相当简单；你只需将值设置为`nil`。因为字典中的值作为可选项返回，所以你不必担心`nil`会导致字典出现问题。
- en: '![](Image00145.jpg)'
  id: totrans-5218
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00145.jpg)'
- en: 'You can see that after you remove the value at the key "MA" , usStates is updated
    to ["MN": "Minnesota", "WA": "Washington", "TX": "Texas"] . Remember that nil
    is special and means that there’s no value at all. That’s why you don’t see "MA":
    nil in our dictionary.'
  id: totrans-5219
  prefs: []
  type: TYPE_NORMAL
  zh: '你可以看到，在你移除键"MA"对应的值之后，`usStates`被更新为["MN": "Minnesota", "WA": "Washington",
    "TX": "Texas"]。记住，`nil`是特殊的，表示没有值。这就是为什么你在字典中看不到"MA": `nil`的原因。'
- en: '**REPLACING ITEMS IN A DICTIONARY**'
  id: totrans-5220
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**替换字典中的项**'
- en: 'Replacing an item in a dictionary is also easy. It works the same was as replacing
    an item in an array. You just set the item that you want to replace to something
    else. Say you create a dictionary of fruit colors:'
  id: totrans-5221
  prefs: []
  type: TYPE_NORMAL
  zh: 替换字典中的项也很简单。它的工作方式和替换数组中的项一样。你只需要将想要替换的项设置为其他值。比如你创建一个水果颜色的字典：
- en: '![](Image00146.jpg)'
  id: totrans-5222
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00146.jpg)'
- en: At first we had the value "apple" for "red" , but then we decided that "raspberry"
    is a better fruit to use since sometimes apples are green or yellow. To replace
    "apple" with "raspberry" , we set colorFruits["red"] to its new value ➊ .
  id: totrans-5223
  prefs: []
  type: TYPE_NORMAL
  zh: 一开始我们将"red"的值设为"apple"，但后来我们决定"raspberry"是一个更合适的水果，因为有时苹果是绿色或黄色的。为了将"apple"替换为"raspberry"，我们将`colorFruits["red"]`设置为其新值
    ➊。
- en: You may remember that this is the same way we entered a new value into a dictionary.
    If the key already exists in the dictionary, then the value for that key is replaced.
    If the key doesn’t already exist, then the new key/value pair will be added to
    the dictionary.
  id: totrans-5224
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能还记得，这和我们向字典中添加新值的方式是一样的。如果键已经存在于字典中，那么该键的值将被替换。如果键不存在，那么新的键值对将被添加到字典中。
- en: '![Image](Image00147.jpg)'
  id: totrans-5225
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Image00147.jpg)'
- en: '**USING DICTIONARY PROPERTIES**'
  id: totrans-5226
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**使用字典属性**'
- en: 'Like an array, a dictionary also has an isEmpty property and a count property.
    For example, the following code shows how you can use the isEmpty property to
    check if a dictionary is empty, and if it isn’t empty, the count property checks
    how many items you have. Imagine you have a basket of fruit for sale. You can
    use these properties to help you keep track of everything:'
  id: totrans-5227
  prefs: []
  type: TYPE_NORMAL
  zh: 和数组一样，字典也有一个`isEmpty`属性和一个`count`属性。例如，下面的代码展示了如何使用`isEmpty`属性来检查字典是否为空，如果不为空，`count`属性则会告诉你字典中有多少项。想象你有一个水果篮在出售。你可以使用这些属性帮助你跟踪所有物品：
- en: '![Image](Image00148.jpg)'
  id: totrans-5228
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Image00148.jpg)'
- en: 'A dictionary also has two special properties: keys , which contains all of
    the dictionary’s keys, and values , which contains all of its values. We’ll use
    these two properties when we loop through the dictionary.'
  id: totrans-5229
  prefs: []
  type: TYPE_NORMAL
  zh: 字典还有两个特殊属性：`keys`，它包含字典的所有键，以及`values`，它包含字典的所有值。当我们遍历字典时，我们会使用这两个属性。
- en: Let’s write some code that loops through our fruit baskets and prints the price
    of each fruit.
  id: totrans-5230
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们编写一些代码，遍历我们的水果篮并打印每个水果的价格。
- en: '**LOOPING OVER A DICTIONARY**'
  id: totrans-5231
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**遍历字典**'
- en: 'You can loop through a dictionary using a for-in loop. Because each item has
    a key and a value, you can do this in two different ways. This is how to loop
    through a dictionary using its keys:'
  id: totrans-5232
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用`for-in`循环遍历字典。由于每个项都有一个键和值，因此你可以用两种不同的方式来遍历字典。以下是使用字典的键来遍历字典的方法：
- en: '![Image](Image00149.jpg)'
  id: totrans-5233
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Image00149.jpg)'
- en: Here we use the dictionary’s keys property ➊ to loop through fruitBasket and
    print its contents. We start by writing the keyword for , followed by a constant
    name fruit for the dictionary key, the keyword in , the dictionary name, a period,
    and keys .
  id: totrans-5234
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们使用字典的`keys`属性 ➊ 来遍历`fruitBasket`并打印其内容。我们从编写关键字`for`开始，后面跟上一个常量名称`fruit`作为字典键，关键字`in`，字典名称，句点，最后是`keys`。
- en: Inside the braces of our for-in loop, we have access to both the key, which
    we call fruit ➋ , and the value at that key when we force-unwrap its contents
    with fruitBasket[fruit]! ➌ . That value will be the fruit’s price.
  id: totrans-5235
  prefs: []
  type: TYPE_NORMAL
  zh: 在`for-in`循环的花括号内，我们可以访问键（我们称之为`fruit` ➋）以及该键的值，当我们通过`fruitBasket[fruit]!`强制解包其内容时
    ➌。该值将是水果的价格。
- en: In this case, it’s safe to force-unwrap the value using an exclamation point
    because we know that the fruit key we’re using is definitely inside the dictionary.
  id: totrans-5236
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，可以安全地使用感叹号强制解包值，因为我们知道我们使用的水果键一定在字典中。
- en: Any code we put inside the for-in loop will run once for every key in our dictionary.
    So you should see the print statement display three times.
  id: totrans-5237
  prefs: []
  type: TYPE_NORMAL
  zh: 我们放在 for-in 循环中的任何代码都会针对字典中的每个键执行一次。所以你应该看到打印语句显示三次。
- en: 'We can also loop through the dictionary using its values property:'
  id: totrans-5238
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以通过字典的值属性来遍历字典：
- en: '![Image](Image00150.jpg)'
  id: totrans-5239
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00150.jpg)'
- en: We use the same style of for-in loop, but now we use a constant to refer to
    each value, which we call price , in the values property. When looping through
    values, we don’t have access to the keys from inside the loop.
  id: totrans-5240
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用相同的 for-in 循环方式，但现在我们使用常量来引用每个值，我们将其称为 `price`，该常量来自字典的值属性。在遍历值时，我们无法从循环内部访问键。
- en: Another difference to note is that price is not an optional because it’s accessed
    directly as a value in the fruitBasket dictionary. That means we don’t have to
    unwrap it. You should still see the print statement printed three times. [Figure
    6-6](text00016.html#ch06fig6) shows the output of both loops.
  id: totrans-5241
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个需要注意的区别是，价格不是一个可选项，因为它是直接作为果篮字典中的值来访问的。这意味着我们不需要解包它。你仍然会看到打印语句被打印三次。[图6-6](text00016.html#ch06fig6)显示了两个循环的输出。
- en: '![Image](Image00151.jpg)'
  id: totrans-5242
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00151.jpg)'
- en: '*Figure 6-6: Looping through the keys and values of a dictionary with a for-in
    loop*'
  id: totrans-5243
  prefs: []
  type: TYPE_NORMAL
  zh: '*图6-6：使用for-in循环遍历字典的键和值*'
- en: The order of your results might be slightly different from ours. That’s because
    the items in a dictionary aren’t in a numbered order like they are in an array!
    And because the order is not guaranteed, you might see a different order printed
    if you run the same code again.
  id: totrans-5244
  prefs: []
  type: TYPE_NORMAL
  zh: 你的结果顺序可能与我们的略有不同。这是因为字典中的项目不像数组中的项目那样按编号顺序排列！由于顺序无法保证，如果你再次运行相同的代码，可能会看到不同的顺序。
- en: '**WHAT YOU LEARNED**'
  id: totrans-5245
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**你学到了什么**'
- en: In this chapter, you learned how to store collections of items in an array and
    in a dictionary. To store items in an ordered list, you would use an array and
    look up each item by its index. If you wanted to store items by key instead, you
    would use a dictionary.
  id: totrans-5246
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你学习了如何将项目集合存储在数组和字典中。要将项目存储在有序列表中，你会使用数组，并通过索引查找每个项目。如果你想按键来存储项目，则可以使用字典。
- en: Knowing about arrays and dictionaries and how to use them is a powerful building
    block for almost any programming language. Next we will learn about functions,
    another very powerful tool. Functions are blocks of code that you create and name
    to perform a specific job. After you have written a function, you can use its
    name to call it from almost anywhere in your program.
  id: totrans-5247
  prefs: []
  type: TYPE_NORMAL
  zh: 了解数组和字典以及如何使用它们是几乎所有编程语言的强大构建块。接下来，我们将学习函数，另一个非常强大的工具。函数是你创建并命名的代码块，用于执行特定任务。写完函数后，你可以在程序中的几乎任何地方通过其名称调用它。
- en: '**COMBINING ARRAYS**'
  id: totrans-5248
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**合并数组**'
- en: 'Not only can you add new items to an array, but you can also add two arrays
    together using the + and += operators. Let’s say that you have the ingredients
    for a fruit smoothie in two arrays:'
  id: totrans-5249
  prefs: []
  type: TYPE_NORMAL
  zh: 你不仅可以向数组添加新项，还可以使用 `+` 和 `+=` 操作符将两个数组合并。假设你有两个数组，分别包含制作水果果昔的配料：
- en: '![](Image00122.jpg)'
  id: totrans-5250
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00122.jpg)'
- en: Now you can make a delicious smoothie by adding the fruits and liquids arrays.
  id: totrans-5251
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你可以通过添加水果和液体数组来制作美味的果昔。
- en: '![](Image00123.jpg)'
  id: totrans-5252
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00123.jpg)'
- en: The order of the ingredients in smoothie is the same as the order in fruits
    and liquids . If you created smoothie with liquids + fruits , then the liquids
    would come first.
  id: totrans-5253
  prefs: []
  type: TYPE_NORMAL
  zh: 果昔中配料的顺序与水果和液体的顺序相同。如果你是先加入液体再加入水果来制作果昔，那么液体会先加入。
- en: 'You use the += operator to add an array to the end of your array. Add some
    whipped cream as follows for extra yumminess:'
  id: totrans-5254
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用 `+=` 操作符将一个数组添加到你数组的末尾。为了增加一些美味，按如下方式添加一些奶油：
- en: '![](Image00124.jpg)'
  id: totrans-5255
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00124.jpg)'
- en: Note that ["whipped cream"] is an array even though it has a single item in
    it. When you’re using += to append something to an array, you have to make sure
    you’re only trying to add another array. If you were to just write the string
    "whipped cream" without the square brackets around it, you would get an error.
  id: totrans-5256
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，["whipped cream"] 是一个数组，尽管它只有一个元素。当你使用 `+=` 向数组追加内容时，你必须确保只是在添加另一个数组。如果你只是写字符串
    "whipped cream" 而没有方括号，系统会报错。
- en: '![Image](Image00125.jpg)'
  id: totrans-5257
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00125.jpg)'
- en: '**REMOVING ITEMS FROM AN ARRAY**'
  id: totrans-5258
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**从数组中移除项目**'
- en: 'There are several methods for removing items from an array. Let’s start by
    looking at the array’s removeLast() method. As you might have guessed from its
    name, removeLast() removes the last item from your array. Let’s try it out with
    a shoppingList array:'
  id: totrans-5259
  prefs: []
  type: TYPE_NORMAL
  zh: 有几种方法可以从数组中移除项。让我们先来看一下数组的 removeLast() 方法。正如你从它的名字中猜到的那样，removeLast() 会删除数组中的最后一个项。我们来试试它在一个
    shoppingList 数组上的效果：
- en: '![](Image00126.jpg)'
  id: totrans-5260
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00126.jpg)'
- en: Neat! Note that the removeLast() method returns the removed item, so you can
    store it in a new constant or variable if you want.
  id: totrans-5261
  prefs: []
  type: TYPE_NORMAL
  zh: 很棒！请注意，removeLast() 方法会返回被移除的项，因此你可以将其存储在一个新的常量或变量中，如果你想的话。
- en: 'You can also remove an item from a specific index by using the remove(at:)
    method. Let’s say that your mom doesn’t want you buying any candy and takes that
    off the list:'
  id: totrans-5262
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以通过使用 remove(at:) 方法从特定索引处删除项。假设你妈妈不希望你买糖果，于是将其从列表中移除：
- en: '![Image](Image00127.jpg)![](Image00128.jpg)'
  id: totrans-5263
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00127.jpg)![](Image00128.jpg)'
- en: Just like when we added an item to the middle of our array and all the items
    scooted over to make room, if you remove an item from the middle of an array,
    the rest of the items will scoot back to fill in that empty space. The "apples"
    item that was at index 3 is now at index 2, where "candy" was.
  id: totrans-5264
  prefs: []
  type: TYPE_NORMAL
  zh: 就像我们在数组中间添加了一个项，并且所有项都挪动了位置以腾出空间一样，如果你从数组中间移除一个项，其他项将会回填以填补这个空缺。原来在索引为 3 的“苹果”项现在变成了索引为
    2 的位置，原来“糖果”在那个位置。
- en: 'You can also remove all items from an array with removeAll() . Try entering
    this into your playground:'
  id: totrans-5265
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以使用 removeAll() 删除数组中的所有项。试着在你的 playground 中输入这个：
- en: '![](Image00129.jpg)'
  id: totrans-5266
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00129.jpg)'
- en: 'Note that trying to remove an item at an index that doesn’t exist will give
    you an error:'
  id: totrans-5267
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，试图删除一个不存在的索引位置的项会导致错误：
- en: '![](Image00130.jpg)'
  id: totrans-5268
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00130.jpg)'
- en: Our array doesn’t have this many items (in fact, now it’s empty!), so this throws
    an error. We’ll also get an error if we use removeLast() on our empty array, because
    there’s nothing in it—there’s no last index at all! However, removeAll() is always
    safe to use, even on an empty array.
  id: totrans-5269
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的数组没有这么多项（事实上，现在它是空的！），所以这会抛出一个错误。如果我们在空数组上使用 removeLast()，也会出现错误，因为里面没有任何元素——根本没有最后一个索引！然而，removeAll()
    方法总是安全的，即使是在空数组上使用。
- en: '**REPLACING ITEMS IN AN ARRAY**'
  id: totrans-5270
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**在数组中替换项**'
- en: 'To replace an item in an array, you set the index of the array to the new value,
    as shown here:'
  id: totrans-5271
  prefs: []
  type: TYPE_NORMAL
  zh: 要替换数组中的一项，你只需将数组的索引位置设置为新值，如下所示：
- en: '![](Image00131.jpg)'
  id: totrans-5272
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00131.jpg)'
- en: At ➊ , we replaced the item at index 2 (the third item) with "Unicorn" because
    magical animals count as favorite animals, too! At ➋ , we replaced the item at
    index 0 (the first item) with "Bearded dragon" . No, that’s not a real dragon—it’s
    just a lizard!
  id: totrans-5273
  prefs: []
  type: TYPE_NORMAL
  zh: 在 ➊ 处，我们将索引为 2（第三个项）的位置的元素替换为“独角兽”，因为神奇的动物也算是最喜欢的动物！在 ➋ 处，我们将索引为 0（第一个项）的位置的元素替换为“有鬃蜥蜴”。不，这不是一条真正的龙——它只是一只蜥蜴！
- en: Like any time you’re working with array index numbers, you have to be sure an
    item exists in the array at that index before you change its value, or you will
    get an Index out of range error.
  id: totrans-5274
  prefs: []
  type: TYPE_NORMAL
  zh: 就像你在处理数组索引时一样，在更改值之前，你必须确保该索引位置的项在数组中存在，否则会出现“索引超出范围”的错误。
- en: '[Figure 6-3](text00016.html#ch06fig3) shows the error that occurs if you try
    to add "Standard poodle" using favoriteAnimals[3] = "Standard poodle" . To add
    an item to the end of an array, you should use the append(_:) method or += , as
    we covered in “[Adding Items to an Array](text00016.html#ch06lev2sec5) ” on [page
    70](text00016.html#page_70) .'
  id: totrans-5275
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 6-3](text00016.html#ch06fig3) 显示了如果你尝试通过 favoriteAnimals[3] = "标准贵宾犬" 添加一个项时发生的错误。要将项添加到数组的末尾，应该使用
    append(_:) 方法或 += ，正如我们在“[向数组中添加项](text00016.html#ch06lev2sec5)”中第 [70 页](text00016.html#page_70)
    所介绍的那样。'
- en: '![Image](Image00132.jpg)'
  id: totrans-5276
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00132.jpg)'
- en: '*Figure 6-3: Don’t try to replace a value at an index beyond the existing array.*'
  id: totrans-5277
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 6-3：不要试图在超出现有数组索引的地方替换一个值。*'
- en: Now you know how to change arrays however you might need to. You can add items,
    take items away, or replace items. Next, we’ll look at how to use the properties
    of arrays to find out even more information about them.
  id: totrans-5278
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你知道了如何根据需要修改数组。你可以添加项、移除项或替换项。接下来，我们将看看如何使用数组的属性来获取更多关于它们的信息。
- en: '![Image](Image00133.jpg)'
  id: totrans-5279
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00133.jpg)'
- en: '**USING ARRAY PROPERTIES**'
  id: totrans-5280
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**使用数组属性**'
- en: In addition to methods like append(_:) and removeLast() , arrays also have *properties*
    . An array’s properties are variables or constants that contain some information
    about the array. Two really helpful properties that you might use are the Boolean
    property isEmpty and the integer property count .
  id: totrans-5281
  prefs: []
  type: TYPE_NORMAL
  zh: 除了像 `append(_:)` 和 `removeLast()` 这样的函数，数组还有 *属性*。数组的属性是包含有关数组信息的变量或常量。你可能会使用的两个非常有用的属性是布尔类型的
    `isEmpty` 和整数类型的 `count`。
- en: The isEmpty property is true or false depending on whether the array is empty,
    and the count property will tell you how many items are in that array.
  id: totrans-5282
  prefs: []
  type: TYPE_NORMAL
  zh: '`isEmpty` 属性的值为真或假，取决于数组是否为空，而 `count` 属性会告诉你数组中有多少项。'
- en: 'Check out how these two properties are used in the following if-else statement:'
  id: totrans-5283
  prefs: []
  type: TYPE_NORMAL
  zh: 查看以下 if-else 语句中如何使用这两个属性：
- en: '![Image](Image00134.jpg)'
  id: totrans-5284
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00134.jpg)'
- en: 'This if-else statement checks whether the array mySiblings is empty ➊ . If
    it is, then "I don''t have any siblings." is printed. But if there is something
    in the array, then the number of siblings that we have is printed: "I have 3 siblings."
    ➋ .'
  id: totrans-5285
  prefs: []
  type: TYPE_NORMAL
  zh: 这个 if-else 语句检查数组 `mySiblings` 是否为空 ➊。如果为空，则打印 "我没有兄弟姐妹"。但如果数组中有内容，则打印我们有多少个兄弟姐妹：“我有
    3 个兄弟姐妹。” ➋。
- en: '**LOOPING OVER AN ARRAY**'
  id: totrans-5286
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**循环遍历数组**'
- en: 'Sometimes when you’re working with arrays you might want to do something to
    every item in the array. You can use a for-in loop to do that! The following code
    will print every topping in a pizzaToppings array on a separate line:'
  id: totrans-5287
  prefs: []
  type: TYPE_NORMAL
  zh: 有时候，当你处理数组时，可能想对数组中的每个项做一些操作。你可以使用 for-in 循环来做到这一点！以下代码将在每一行打印出 `pizzaToppings`
    数组中的每个配料：
- en: '![Image](Image00135.jpg)'
  id: totrans-5288
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00135.jpg)'
- en: To write a for-in loop for the pizzaToppings array, we used the keyword for
    , followed by the constant topping , then the keyword in , and finally the name
    of our array, pizzaToppings . Then we put the statements that we want to run for
    each topping inside the braces of the for-in loop. The constant topping ➊ temporarily
    represents each pizza topping in the array as we loop through it. We could have
    chosen any name for this constant, but it’s a good idea to pick something that
    makes sense. You can see the output of this for-in loop in [Figure 6-4](text00016.html#ch06fig4)
    .
  id: totrans-5289
  prefs: []
  type: TYPE_NORMAL
  zh: 要为 `pizzaToppings` 数组编写一个 for-in 循环，我们使用了关键字 `for`，后跟常量 `topping`，然后是关键字 `in`，最后是数组的名称
    `pizzaToppings`。接着，我们将要在每个 `topping` 上运行的语句放在 for-in 循环的大括号中。常量 `topping` ➊ 在我们遍历数组时临时代表数组中的每个披萨配料。我们可以为这个常量选择任何名称，但最好选择一个有意义的名称。你可以在[图
    6-4](text00016.html#ch06fig4)中看到这个 for-in 循环的输出。
- en: '![Image](Image00136.jpg)'
  id: totrans-5290
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00136.jpg)'
- en: '*Figure 6-4: Output of the example for-in loop*'
  id: totrans-5291
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 6-4：示例 for-in 循环的输出*'
- en: '![Image](Image00137.jpg)'
  id: totrans-5292
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00137.jpg)'
- en: 'Using for-in loops is great for printing every value in an array. If you’re
    working with numbers, you can even use them to perform math operations on each
    item, which makes for some speedy calculations! The following code takes an array
    of numbers and calculates the square for each (the square of a number is that
    number multiplied by itself):'
  id: totrans-5293
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 for-in 循环非常适合打印数组中的每个值。如果你正在处理数字，甚至可以使用它们对每个项执行数学运算，这样就能快速进行计算！以下代码取一个数字数组，并计算每个数字的平方（数字的平方是该数字与自身相乘）：
- en: '![Image](Image00138.jpg)'
  id: totrans-5294
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00138.jpg)'
- en: '[Figure 6-5](text00016.html#ch06fig5) shows the results.'
  id: totrans-5295
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 6-5](text00016.html#ch06fig5) 显示了结果。'
- en: '![Image](Image00139.jpg)'
  id: totrans-5296
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00139.jpg)'
- en: '*Figure 6-5: Printing the squares for each number in the myNumbers array*'
  id: totrans-5297
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 6-5：打印 `myNumbers` 数组中每个数字的平方*'
- en: '**DICTIONARIES ARE KEY!**'
  id: totrans-5298
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**字典是关键！**'
- en: A *dictionary* is also a collection of values, but instead of an ordered index,
    each value has its own *key* . Because there’s no index, the values are not stored
    in any particular order. To access values in a dictionary, you look them up by
    their key.
  id: totrans-5299
  prefs: []
  type: TYPE_NORMAL
  zh: '*字典*也是一种值的集合，但不同于有序索引，每个值都有自己的 *键*。由于没有索引，值的存储顺序是无序的。要访问字典中的值，可以通过键来查找。'
- en: A key must be unique. You can’t have the same key more than once in the same
    dictionary. If there were two identical keys and you asked the computer to give
    you the value for one of them, the computer wouldn’t know which one to choose!
  id: totrans-5300
  prefs: []
  type: TYPE_NORMAL
  zh: 键必须是唯一的。你不能在同一个字典中有重复的键。如果有两个相同的键，并且你要求计算机给你其中一个的值，计算机就不知道该选择哪个！
- en: Let’s take a look at how to make a dictionary and write keys that will help
    you find all the information you need.
  id: totrans-5301
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看如何创建字典，并编写键，以帮助你找到所有需要的信息。
- en: '![Image](Image00140.jpg)'
  id: totrans-5302
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00140.jpg)'
- en: '**INITIALIZING A DICTIONARY**'
  id: totrans-5303
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**初始化字典**'
- en: 'To create and initialize a dictionary, first write var and the name of your
    dictionary. Then write the keys and corresponding values inside a pair of square
    brackets, similar to an array. Let’s create a dictionary to store the names of
    a few US states. The key for each state will be its two-letter abbreviation:'
  id: totrans-5304
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建和初始化一个字典，首先写上 var 和字典的名称。然后在一对方括号中写入键及其对应的值，类似于数组的写法。让我们创建一个字典来存储一些美国州的名称。每个州的键将是它的两字母缩写：
- en: '![](Image00141.jpg)'
  id: totrans-5305
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00141.jpg)'
- en: As you can see, there’s a colon between each key and its value, and the key/value
    pairs are separated by commas.
  id: totrans-5306
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，每个键和值之间都有一个冒号，键/值对之间用逗号分隔。
- en: Dictionaries are different from arrays in that they are *unordered* . Because
    of that, it’s likely that the order of the states that you see in your results
    pane ➋ is different from the order in which you entered your states ➊ . It might
    even be different than the order that’s printed in this book!
  id: totrans-5307
  prefs: []
  type: TYPE_NORMAL
  zh: 字典与数组不同，它们是*无序的*。因此，你在结果窗格中看到的州的顺序➋可能与你输入州的顺序➊不同，甚至可能与本书中打印的顺序不同！
- en: As with arrays, you can use var to make a mutable dictionary or use let to make
    an immutable dictionary.
  id: totrans-5308
  prefs: []
  type: TYPE_NORMAL
  zh: 与数组一样，你可以使用 var 来创建一个可变字典，或者使用 let 来创建一个不可变字典。
- en: 'In Swift, all of the keys of a dictionary must be the same type, and all of
    the values of a dictionary must also be the same type, but the key type doesn’t
    have to match the value type. For example, if you wanted to store a collection
    of fractions, you could use doubles for the keys and strings for the values:'
  id: totrans-5309
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Swift 中，字典的所有键必须是相同类型，所有值也必须是相同类型，但键的类型不必与值的类型匹配。例如，如果你想存储一个分数集合，你可以使用双精度浮点数作为键，字符串作为值：
- en: '![](Image00142.jpg)'
  id: totrans-5310
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00142.jpg)'
- en: In this dictionary, all of the keys must be doubles, and all of the values must
    be strings. Again, you’ll see that the order of the numbers in the results pane
    can be quite different from the order in which you wrote the fractions in your
    dictionary. This is fine because you don’t need to know the order to access anything.
    You can find any item that you need by its key. Let’s see how!
  id: totrans-5311
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个字典中，所有的键必须是双精度浮点数，所有的值必须是字符串。再次强调，你会看到结果窗格中的数字顺序可能与字典中写入的分数顺序完全不同。这是可以接受的，因为你不需要知道顺序就能访问任何内容。你可以通过键找到任何需要的项。让我们看看怎么做！
- en: '**ACCESSING VALUES IN A DICTIONARY**'
  id: totrans-5312
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**访问字典中的值**'
- en: 'Looking up a value in a dictionary is similar to how you access a value in
    an array except that you use a key inside the square brackets instead of an index,
    like this: usStates["TX"] .'
  id: totrans-5313
  prefs: []
  type: TYPE_NORMAL
  zh: 在字典中查找值类似于在数组中访问值，只不过你在方括号内使用的是键，而不是索引，如：usStates["TX"]。
- en: There is a big difference, however, in how Swift returns the values from a dictionary.
    When you access a value at an index of an array, you are simply given the value.
    When you access a value with a key in a dictionary, you are given an optional.
  id: totrans-5314
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，Swift 在从字典中返回值的方式上有很大的不同。当你访问数组中某个索引的值时，你只是简单地得到该值。而当你使用字典中的键访问值时，你会得到一个可选值。
- en: In [Chapter 5](text00015.html#ch05) , you learned that optionals might contain
    a value or might be nil . The reason Swift returns optionals when you’re looking
    up items in a dictionary is that the key you used might not exist in the dictionary,
    in which case there’s no value to access. Trying to access a value that doesn’t
    exist would give you a big fat error! To avoid that problem, Swift returns optionals.
    That means you need to unwrap any value you get out of a dictionary before you
    can do anything with it.
  id: totrans-5315
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第 5 章](text00015.html#ch05)中，你学过可选值可能包含一个值，也可能是 nil。Swift 返回可选值的原因是在字典中查找项时，你使用的键可能在字典中不存在，这种情况下就没有值可供访问。尝试访问不存在的值会导致一个错误！为了避免这个问题，Swift
    返回可选值。这意味着你需要在使用从字典中获取的任何值之前先解包它。
- en: 'To unwrap an optional, first you check whether it exists using an if-let statement,
    just like we did in [Chapter 5](text00015.html#ch05) . The following code shows
    you how to get a value out of a dictionary:'
  id: totrans-5316
  prefs: []
  type: TYPE_NORMAL
  zh: 要解包一个可选值，首先你需要使用 if-let 语句检查它是否存在，就像我们在[第 5 章](text00015.html#ch05)中做的那样。以下代码展示了如何从字典中获取一个值：
- en: '![Image](Image00143.jpg)'
  id: totrans-5317
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00143.jpg)'
- en: To retrieve "Texas" from the dictionary, we use if let to set a constant loneStarState
    to usStates["TX"] ➊ . Because we have this state in our dictionary, the line I
    have Texas in my dictionary. is printed. Next we try to access a state that is
    not in our dictionary by using the key usStates["FL"] ➋ . Thankfully, because
    we used an if-let statement, the program won’t crash when the computer can’t find
    this state. Instead, I don't have that state in my dictionary. is printed.
  id: totrans-5318
  prefs: []
  type: TYPE_NORMAL
  zh: 要从字典中检索“Texas”，我们使用`if let`将常量loneStarState设置为usStates["TX"] ➊ 。由于字典中包含此州，输出将为“我在我的字典中有Texas。”接下来，我们尝试通过键usStates["FL"]
    ➋ 访问一个字典中没有的州。幸运的是，因为我们使用了`if-let`语句，当计算机无法找到此州时，程序不会崩溃。相反，输出将为“我在我的字典中没有这个州。”
- en: '**ADDING ITEMS TO A DICTIONARY**'
  id: totrans-5319
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**向字典添加项**'
- en: 'To add an item to a dictionary, first write the name of your dictionary and
    assign the new item to the key you want it to have in the dictionary. Let’s add
    "Minnesota" to our usStates dictionary:'
  id: totrans-5320
  prefs: []
  type: TYPE_NORMAL
  zh: 要向字典中添加一项，首先写出字典的名称，并将新项分配给字典中你想要它的键。让我们将"Minneosta"添加到我们的usStates字典中：
- en: '![](Image00144.jpg)'
  id: totrans-5321
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00144.jpg)'
- en: 'Now when you look at usStates , you’ll see that it’s updated to ["MN": "Minnesota",
    "WA": "Washington", "MA": "Massachusetts", "TX": "Texas"] . Remember, because
    you don’t have to rely on indices, your new dictionary item might appear anywhere
    in the dictionary.'
  id: totrans-5322
  prefs: []
  type: TYPE_NORMAL
  zh: '现在，当你查看usStates时，你会看到它已更新为["MN": "Minnesota", "WA": "Washington", "MA": "Massachusetts",
    "TX": "Texas"] 。记住，因为你不需要依赖索引，所以你的新字典项可能出现在字典的任何位置。'
- en: '**REMOVING ITEMS FROM A DICTIONARY**'
  id: totrans-5323
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**从字典中移除项**'
- en: Removing an item from a dictionary is quite simple; you do so by setting the
    value to nil . Because the values in dictionaries are returned as optionals, you
    don’t have to worry about nil causing any problems in your dictionary.
  id: totrans-5324
  prefs: []
  type: TYPE_NORMAL
  zh: 从字典中移除项目非常简单；你只需要将值设置为nil。因为字典中的值是以可选项的形式返回的，所以你不必担心nil会在字典中引发任何问题。
- en: '![](Image00145.jpg)'
  id: totrans-5325
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00145.jpg)'
- en: 'You can see that after you remove the value at the key "MA" , usStates is updated
    to ["MN": "Minnesota", "WA": "Washington", "TX": "Texas"] . Remember that nil
    is special and means that there’s no value at all. That’s why you don’t see "MA":
    nil in our dictionary.'
  id: totrans-5326
  prefs: []
  type: TYPE_NORMAL
  zh: '你可以看到，在移除键"MA"的值之后，usStates被更新为["MN": "Minnesota", "WA": "Washington", "TX":
    "Texas"] 。记住，nil是特殊的，表示完全没有值。这就是为什么你在字典中看不到"MA": nil。'
- en: '**REPLACING ITEMS IN A DICTIONARY**'
  id: totrans-5327
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**替换字典中的项**'
- en: 'Replacing an item in a dictionary is also easy. It works the same was as replacing
    an item in an array. You just set the item that you want to replace to something
    else. Say you create a dictionary of fruit colors:'
  id: totrans-5328
  prefs: []
  type: TYPE_NORMAL
  zh: 替换字典中的项也很简单。它与替换数组中的项一样。你只需将要替换的项设置为其他内容。假设你创建了一个水果颜色的字典：
- en: '![](Image00146.jpg)'
  id: totrans-5329
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00146.jpg)'
- en: At first we had the value "apple" for "red" , but then we decided that "raspberry"
    is a better fruit to use since sometimes apples are green or yellow. To replace
    "apple" with "raspberry" , we set colorFruits["red"] to its new value ➊ .
  id: totrans-5330
  prefs: []
  type: TYPE_NORMAL
  zh: 一开始，我们将"red"的值设置为"apple"，但后来我们决定“raspberry”是更好的水果，因为有时苹果是绿色或黄色的。为了将"apple"替换为"raspberry"，我们将colorFruits["red"]设置为新的值
    ➊ 。
- en: You may remember that this is the same way we entered a new value into a dictionary.
    If the key already exists in the dictionary, then the value for that key is replaced.
    If the key doesn’t already exist, then the new key/value pair will be added to
    the dictionary.
  id: totrans-5331
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能还记得，这是我们向字典中输入新值的方式。如果键已经存在于字典中，那么该键的值将被替换。如果该键不存在，则新的键/值对将被添加到字典中。
- en: '![Image](Image00147.jpg)'
  id: totrans-5332
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00147.jpg)'
- en: '**USING DICTIONARY PROPERTIES**'
  id: totrans-5333
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**使用字典属性**'
- en: 'Like an array, a dictionary also has an isEmpty property and a count property.
    For example, the following code shows how you can use the isEmpty property to
    check if a dictionary is empty, and if it isn’t empty, the count property checks
    how many items you have. Imagine you have a basket of fruit for sale. You can
    use these properties to help you keep track of everything:'
  id: totrans-5334
  prefs: []
  type: TYPE_NORMAL
  zh: 像数组一样，字典也有一个`isEmpty`属性和一个`count`属性。例如，以下代码演示了如何使用`isEmpty`属性检查字典是否为空，如果不为空，`count`属性则检查字典中有多少项。假设你有一个售卖水果的篮子。你可以使用这些属性来帮助你跟踪一切：
- en: '![Image](Image00148.jpg)'
  id: totrans-5335
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00148.jpg)'
- en: 'A dictionary also has two special properties: keys , which contains all of
    the dictionary’s keys, and values , which contains all of its values. We’ll use
    these two properties when we loop through the dictionary.'
  id: totrans-5336
  prefs: []
  type: TYPE_NORMAL
  zh: 字典还有两个特殊的属性：`keys`，它包含字典中的所有键；和`values`，它包含字典中的所有值。当我们遍历字典时，会使用这两个属性。
- en: Let’s write some code that loops through our fruit baskets and prints the price
    of each fruit.
  id: totrans-5337
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们写一些代码，通过循环遍历我们的水果篮子并打印每种水果的价格。
- en: '**LOOPING OVER A DICTIONARY**'
  id: totrans-5338
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**遍历字典**'
- en: 'You can loop through a dictionary using a for-in loop. Because each item has
    a key and a value, you can do this in two different ways. This is how to loop
    through a dictionary using its keys:'
  id: totrans-5339
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用 for-in 循环遍历字典。由于每个项目都有一个键和值，你可以通过两种不同的方式来遍历字典。这是使用键来遍历字典的方法：
- en: '![Image](Image00149.jpg)'
  id: totrans-5340
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00149.jpg)'
- en: Here we use the dictionary’s keys property ➊ to loop through fruitBasket and
    print its contents. We start by writing the keyword for , followed by a constant
    name fruit for the dictionary key, the keyword in , the dictionary name, a period,
    and keys .
  id: totrans-5341
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们使用字典的 keys 属性 ➊ 来遍历 fruitBasket 并打印它的内容。我们首先写下关键字 for，后面跟着常量名 fruit，表示字典中的键，再加上关键字
    in，字典名称，句点，然后是 keys。
- en: Inside the braces of our for-in loop, we have access to both the key, which
    we call fruit ➋ , and the value at that key when we force-unwrap its contents
    with fruitBasket[fruit]! ➌ . That value will be the fruit’s price.
  id: totrans-5342
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们 for-in 循环的大括号内，我们可以访问到键（我们称之为 fruit ➋）以及通过强制解包其内容（使用 fruitBasket[fruit]!
    ➌）时对应的值。这个值将是水果的价格。
- en: In this case, it’s safe to force-unwrap the value using an exclamation point
    because we know that the fruit key we’re using is definitely inside the dictionary.
  id: totrans-5343
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，使用感叹号强制解包该值是安全的，因为我们知道正在使用的水果键肯定在字典中。
- en: Any code we put inside the for-in loop will run once for every key in our dictionary.
    So you should see the print statement display three times.
  id: totrans-5344
  prefs: []
  type: TYPE_NORMAL
  zh: 我们放入 for-in 循环中的任何代码都会对字典中的每个键执行一次。因此，你应该看到打印语句被执行三次。
- en: 'We can also loop through the dictionary using its values property:'
  id: totrans-5345
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以使用字典的 values 属性来遍历：
- en: '![Image](Image00150.jpg)'
  id: totrans-5346
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00150.jpg)'
- en: We use the same style of for-in loop, but now we use a constant to refer to
    each value, which we call price , in the values property. When looping through
    values, we don’t have access to the keys from inside the loop.
  id: totrans-5347
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用相同的 for-in 循环样式，但现在我们使用常量来引用每个值，我们称之为 price，来自 values 属性。当遍历值时，我们无法从循环内部访问键。
- en: Another difference to note is that price is not an optional because it’s accessed
    directly as a value in the fruitBasket dictionary. That means we don’t have to
    unwrap it. You should still see the print statement printed three times. [Figure
    6-6](text00016.html#ch06fig6) shows the output of both loops.
  id: totrans-5348
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个需要注意的区别是，price 不是可选值，因为它是直接作为水果篮子字典中的一个值访问的。这意味着我们不需要解包它。你仍然应该看到打印语句被执行了三次。[图
    6-6](text00016.html#ch06fig6) 显示了两个循环的输出。
- en: '![Image](Image00151.jpg)'
  id: totrans-5349
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00151.jpg)'
- en: '*Figure 6-6: Looping through the keys and values of a dictionary with a for-in
    loop*'
  id: totrans-5350
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 6-6：通过 for-in 循环遍历字典的键和值*'
- en: The order of your results might be slightly different from ours. That’s because
    the items in a dictionary aren’t in a numbered order like they are in an array!
    And because the order is not guaranteed, you might see a different order printed
    if you run the same code again.
  id: totrans-5351
  prefs: []
  type: TYPE_NORMAL
  zh: 你的结果顺序可能与我们的稍有不同。这是因为字典中的项目不像数组中的项目那样按顺序排列！而且由于顺序无法保证，如果你再次运行相同的代码，可能会看到不同的顺序。
- en: '**WHAT YOU LEARNED**'
  id: totrans-5352
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**你学到了什么**'
- en: In this chapter, you learned how to store collections of items in an array and
    in a dictionary. To store items in an ordered list, you would use an array and
    look up each item by its index. If you wanted to store items by key instead, you
    would use a dictionary.
  id: totrans-5353
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你学习了如何将项目存储在数组和字典中。要将项目存储在有序列表中，你应使用数组，并通过其索引查找每个项目。如果你想按键存储项目，则应使用字典。
- en: Knowing about arrays and dictionaries and how to use them is a powerful building
    block for almost any programming language. Next we will learn about functions,
    another very powerful tool. Functions are blocks of code that you create and name
    to perform a specific job. After you have written a function, you can use its
    name to call it from almost anywhere in your program.
  id: totrans-5354
  prefs: []
  type: TYPE_NORMAL
  zh: 了解数组和字典以及如何使用它们，是几乎任何编程语言中的一个强大的构建模块。接下来，我们将学习函数，另一个非常强大的工具。函数是你创建并命名的代码块，用于执行特定的任务。在你编写了一个函数后，可以通过其名称在程序中的几乎任何地方调用它。
- en: 'Not only can you add new items to an array, but you can also add two arrays
    together using the + and += operators. Let’s say that you have the ingredients
    for a fruit smoothie in two arrays:'
  id: totrans-5355
  prefs: []
  type: TYPE_NORMAL
  zh: 你不仅可以向数组中添加新项，还可以使用 + 和 += 运算符将两个数组连接在一起。假设你有两个数组，分别包含做水果冰沙所需的原料：
- en: '![](Image00122.jpg)'
  id: totrans-5356
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00122.jpg)'
- en: Now you can make a delicious smoothie by adding the fruits and liquids arrays.
  id: totrans-5357
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你可以通过将水果和液体数组相加来制作美味的冰沙。
- en: '![](Image00123.jpg)'
  id: totrans-5358
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00123.jpg)'
- en: The order of the ingredients in smoothie is the same as the order in fruits
    and liquids . If you created smoothie with liquids + fruits , then the liquids
    would come first.
  id: totrans-5359
  prefs: []
  type: TYPE_NORMAL
  zh: 在smoothie（冰沙）中，成分的顺序与水果和液体中的顺序相同。如果你先加液体再加水果，那么液体会排在前面。
- en: 'You use the += operator to add an array to the end of your array. Add some
    whipped cream as follows for extra yumminess:'
  id: totrans-5360
  prefs: []
  type: TYPE_NORMAL
  zh: 使用+=操作符将一个数组添加到你的数组的末尾。为了增加美味感，可以按如下方式添加一些鲜奶油：
- en: '![](Image00124.jpg)'
  id: totrans-5361
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00124.jpg)'
- en: Note that ["whipped cream"] is an array even though it has a single item in
    it. When you’re using += to append something to an array, you have to make sure
    you’re only trying to add another array. If you were to just write the string
    "whipped cream" without the square brackets around it, you would get an error.
  id: totrans-5362
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，["whipped cream"]虽然只有一个元素，但它仍然是一个数组。当你使用+=操作符将元素添加到数组时，必须确保你只是尝试添加另一个数组。如果你写的是“whipped
    cream”而没有使用方括号，程序会报错。
- en: '![Image](Image00125.jpg)'
  id: totrans-5363
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00125.jpg)'
- en: '**REMOVING ITEMS FROM AN ARRAY**'
  id: totrans-5364
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**从数组中移除项目**'
- en: 'There are several methods for removing items from an array. Let’s start by
    looking at the array’s removeLast() method. As you might have guessed from its
    name, removeLast() removes the last item from your array. Let’s try it out with
    a shoppingList array:'
  id: totrans-5365
  prefs: []
  type: TYPE_NORMAL
  zh: 有几种方法可以从数组中移除项目。让我们从查看数组的removeLast()方法开始。如您所料，removeLast()会移除数组中的最后一个项目。我们来用一个shoppingList数组试试看：
- en: '![](Image00126.jpg)'
  id: totrans-5366
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00126.jpg)'
- en: Neat! Note that the removeLast() method returns the removed item, so you can
    store it in a new constant or variable if you want.
  id: totrans-5367
  prefs: []
  type: TYPE_NORMAL
  zh: 很棒！注意，removeLast()方法会返回被移除的项目，因此如果需要，您可以将其存储在新的常量或变量中。
- en: 'You can also remove an item from a specific index by using the remove(at:)
    method. Let’s say that your mom doesn’t want you buying any candy and takes that
    off the list:'
  id: totrans-5368
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以使用remove(at:)方法从特定索引处移除项目。假设你妈妈不想让你买糖果，并且从购物清单上把它移除：
- en: '![Image](Image00127.jpg)![](Image00128.jpg)'
  id: totrans-5369
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00127.jpg)![](Image00128.jpg)'
- en: Just like when we added an item to the middle of our array and all the items
    scooted over to make room, if you remove an item from the middle of an array,
    the rest of the items will scoot back to fill in that empty space. The "apples"
    item that was at index 3 is now at index 2, where "candy" was.
  id: totrans-5370
  prefs: []
  type: TYPE_NORMAL
  zh: 就像我们在数组中间添加项目时，其他项目会移到空余的位置一样，如果你从数组中间移除一个项目，剩下的项目也会向后移动，填补那个空缺的位置。原本位于索引3的“苹果”项目，现在移动到索引2的位置，原来“糖果”所在的位置。
- en: 'You can also remove all items from an array with removeAll() . Try entering
    this into your playground:'
  id: totrans-5371
  prefs: []
  type: TYPE_NORMAL
  zh: 您也可以使用removeAll()从数组中移除所有项目。尝试将此输入到您的游乐场（Playground）中：
- en: '![](Image00129.jpg)'
  id: totrans-5372
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00129.jpg)'
- en: 'Note that trying to remove an item at an index that doesn’t exist will give
    you an error:'
  id: totrans-5373
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，如果尝试移除一个不存在的索引位置上的项目，程序会报错：
- en: '![](Image00130.jpg)'
  id: totrans-5374
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00130.jpg)'
- en: Our array doesn’t have this many items (in fact, now it’s empty!), so this throws
    an error. We’ll also get an error if we use removeLast() on our empty array, because
    there’s nothing in it—there’s no last index at all! However, removeAll() is always
    safe to use, even on an empty array.
  id: totrans-5375
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的数组没有这么多项目（事实上，现在它是空的！），所以这会抛出一个错误。如果我们对空数组使用removeLast()，也会报错，因为它里面没有任何元素——根本没有最后一个索引！不过，removeAll()方法即使在空数组上使用也是安全的。
- en: '**REPLACING ITEMS IN AN ARRAY**'
  id: totrans-5376
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**替换数组中的项目**'
- en: 'To replace an item in an array, you set the index of the array to the new value,
    as shown here:'
  id: totrans-5377
  prefs: []
  type: TYPE_NORMAL
  zh: 要替换数组中的项目，您需要将数组的索引设置为新值，如下所示：
- en: '![](Image00131.jpg)'
  id: totrans-5378
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00131.jpg)'
- en: At ➊ , we replaced the item at index 2 (the third item) with "Unicorn" because
    magical animals count as favorite animals, too! At ➋ , we replaced the item at
    index 0 (the first item) with "Bearded dragon" . No, that’s not a real dragon—it’s
    just a lizard!
  id: totrans-5379
  prefs: []
  type: TYPE_NORMAL
  zh: 在 ➊ 处，我们将索引为2（第三个项目）的元素替换为“独角兽”，因为魔法动物也算是最喜欢的动物！在 ➋ 处，我们将索引为0（第一个项目）的元素替换为“胡须蜥蜴”。不，这不是一条真正的龙——它只是一只蜥蜴！
- en: Like any time you’re working with array index numbers, you have to be sure an
    item exists in the array at that index before you change its value, or you will
    get an Index out of range error.
  id: totrans-5380
  prefs: []
  type: TYPE_NORMAL
  zh: 就像处理数组索引时一样，在更改某个值之前，您必须确保该索引位置上有项目，否则会出现“索引超出范围”错误。
- en: '[Figure 6-3](text00016.html#ch06fig3) shows the error that occurs if you try
    to add "Standard poodle" using favoriteAnimals[3] = "Standard poodle" . To add
    an item to the end of an array, you should use the append(_:) method or += , as
    we covered in “[Adding Items to an Array](text00016.html#ch06lev2sec5) ” on [page
    70](text00016.html#page_70) .'
  id: totrans-5381
  prefs: []
  type: TYPE_NORMAL
  zh: '[图6-3](text00016.html#ch06fig3)显示了如果你尝试使用favoriteAnimals[3] = "Standard poodle"添加“标准贵宾犬”时发生的错误。要将项添加到数组的末尾，你应该使用append(_:)方法或+=，正如我们在“[向数组添加项](text00016.html#ch06lev2sec5)”中讲解的那样，见[第70页](text00016.html#page_70)。'
- en: '![Image](Image00132.jpg)'
  id: totrans-5382
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00132.jpg)'
- en: '*Figure 6-3: Don’t try to replace a value at an index beyond the existing array.*'
  id: totrans-5383
  prefs: []
  type: TYPE_NORMAL
  zh: '*图6-3：不要尝试替换超出现有数组范围的索引处的值。*'
- en: Now you know how to change arrays however you might need to. You can add items,
    take items away, or replace items. Next, we’ll look at how to use the properties
    of arrays to find out even more information about them.
  id: totrans-5384
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你知道如何根据需要更改数组了。你可以添加项目，移除项目或替换项目。接下来，我们将了解如何使用数组的属性来进一步了解它们。
- en: '![Image](Image00133.jpg)'
  id: totrans-5385
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00133.jpg)'
- en: '**USING ARRAY PROPERTIES**'
  id: totrans-5386
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**使用数组属性**'
- en: In addition to methods like append(_:) and removeLast() , arrays also have *properties*
    . An array’s properties are variables or constants that contain some information
    about the array. Two really helpful properties that you might use are the Boolean
    property isEmpty and the integer property count .
  id: totrans-5387
  prefs: []
  type: TYPE_NORMAL
  zh: 除了像append(_:)和removeLast()这样的常用方法，数组还具有*属性*。数组的属性是包含关于数组某些信息的变量或常量。你可能会用到的两个非常有用的属性是布尔值属性isEmpty和整数属性count。
- en: The isEmpty property is true or false depending on whether the array is empty,
    and the count property will tell you how many items are in that array.
  id: totrans-5388
  prefs: []
  type: TYPE_NORMAL
  zh: isEmpty属性根据数组是否为空来返回true或false，而count属性会告诉你数组中有多少项。
- en: 'Check out how these two properties are used in the following if-else statement:'
  id: totrans-5389
  prefs: []
  type: TYPE_NORMAL
  zh: 看看下面的if-else语句中如何使用这两个属性：
- en: '![Image](Image00134.jpg)'
  id: totrans-5390
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00134.jpg)'
- en: 'This if-else statement checks whether the array mySiblings is empty ➊ . If
    it is, then "I don''t have any siblings." is printed. But if there is something
    in the array, then the number of siblings that we have is printed: "I have 3 siblings."
    ➋ .'
  id: totrans-5391
  prefs: []
  type: TYPE_NORMAL
  zh: 这个if-else语句检查数组mySiblings是否为空 ➊。如果为空，就会打印出“我没有兄弟姐妹。”如果数组中有内容，则会打印出我们拥有的兄弟姐妹的数量：“我有3个兄弟姐妹。”
    ➋。
- en: '**LOOPING OVER AN ARRAY**'
  id: totrans-5392
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**遍历数组**'
- en: 'Sometimes when you’re working with arrays you might want to do something to
    every item in the array. You can use a for-in loop to do that! The following code
    will print every topping in a pizzaToppings array on a separate line:'
  id: totrans-5393
  prefs: []
  type: TYPE_NORMAL
  zh: 有时候，当你在处理数组时，你可能想对数组中的每个项目做点什么。你可以使用for-in循环来实现这一点！以下代码会在每一行打印出pizzaToppings数组中的每个配料：
- en: '![Image](Image00135.jpg)'
  id: totrans-5394
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00135.jpg)'
- en: To write a for-in loop for the pizzaToppings array, we used the keyword for
    , followed by the constant topping , then the keyword in , and finally the name
    of our array, pizzaToppings . Then we put the statements that we want to run for
    each topping inside the braces of the for-in loop. The constant topping ➊ temporarily
    represents each pizza topping in the array as we loop through it. We could have
    chosen any name for this constant, but it’s a good idea to pick something that
    makes sense. You can see the output of this for-in loop in [Figure 6-4](text00016.html#ch06fig4)
    .
  id: totrans-5395
  prefs: []
  type: TYPE_NORMAL
  zh: 要为pizzaToppings数组编写for-in循环，我们使用了关键字for，后面跟着常量topping，然后是关键字in，最后是我们的数组名称pizzaToppings。然后，我们将希望在每个配料上执行的语句放入for-in循环的大括号内。常量topping
    ➊在我们遍历数组时临时代表数组中的每个披萨配料。我们本可以为这个常量选择任何名称，但最好选择一个有意义的名称。你可以在[图6-4](text00016.html#ch06fig4)中看到这个for-in循环的输出。
- en: '![Image](Image00136.jpg)'
  id: totrans-5396
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00136.jpg)'
- en: '*Figure 6-4: Output of the example for-in loop*'
  id: totrans-5397
  prefs: []
  type: TYPE_NORMAL
  zh: '*图6-4：示例for-in循环的输出*'
- en: '![Image](Image00137.jpg)'
  id: totrans-5398
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00137.jpg)'
- en: 'Using for-in loops is great for printing every value in an array. If you’re
    working with numbers, you can even use them to perform math operations on each
    item, which makes for some speedy calculations! The following code takes an array
    of numbers and calculates the square for each (the square of a number is that
    number multiplied by itself):'
  id: totrans-5399
  prefs: []
  type: TYPE_NORMAL
  zh: 使用for-in循环遍历数组非常适合打印数组中的每个值。如果你正在处理数字，你甚至可以用它们对每个项目执行数学运算，这样可以快速进行计算！以下代码会对数字数组中的每个元素计算平方（一个数的平方是这个数与它自身相乘）：
- en: '![Image](Image00138.jpg)'
  id: totrans-5400
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00138.jpg)'
- en: '[Figure 6-5](text00016.html#ch06fig5) shows the results.'
  id: totrans-5401
  prefs: []
  type: TYPE_NORMAL
  zh: '[图6-5](text00016.html#ch06fig5)显示了结果。'
- en: '![Image](Image00139.jpg)'
  id: totrans-5402
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00139.jpg)'
- en: '*Figure 6-5: Printing the squares for each number in the myNumbers array*'
  id: totrans-5403
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 6-5：打印 myNumbers 数组中每个数字的平方*'
- en: '**DICTIONARIES ARE KEY!**'
  id: totrans-5404
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**字典是关键！**'
- en: A *dictionary* is also a collection of values, but instead of an ordered index,
    each value has its own *key* . Because there’s no index, the values are not stored
    in any particular order. To access values in a dictionary, you look them up by
    their key.
  id: totrans-5405
  prefs: []
  type: TYPE_NORMAL
  zh: '*字典*也是一个值的集合，但与有序的索引不同，每个值都有自己的*键*。由于没有索引，值不会以任何特定的顺序存储。要访问字典中的值，你需要通过它们的键来查找。'
- en: A key must be unique. You can’t have the same key more than once in the same
    dictionary. If there were two identical keys and you asked the computer to give
    you the value for one of them, the computer wouldn’t know which one to choose!
  id: totrans-5406
  prefs: []
  type: TYPE_NORMAL
  zh: 一个键必须是唯一的。你不能在同一个字典中有相同的键。如果有两个相同的键，而你要求计算机返回其中一个的值，计算机就不知道该选择哪一个！
- en: Let’s take a look at how to make a dictionary and write keys that will help
    you find all the information you need.
  id: totrans-5407
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如何创建一个字典，并编写键来帮助你找到所有需要的信息。
- en: '![Image](Image00140.jpg)'
  id: totrans-5408
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00140.jpg)'
- en: '**INITIALIZING A DICTIONARY**'
  id: totrans-5409
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**初始化字典**'
- en: 'To create and initialize a dictionary, first write var and the name of your
    dictionary. Then write the keys and corresponding values inside a pair of square
    brackets, similar to an array. Let’s create a dictionary to store the names of
    a few US states. The key for each state will be its two-letter abbreviation:'
  id: totrans-5410
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建并初始化一个字典，首先写上 var 和字典的名称。然后像数组一样，在一对方括号内写入键和值。让我们创建一个字典来存储一些美国州的名称。每个州的键将是它的两个字母缩写：
- en: '![](Image00141.jpg)'
  id: totrans-5411
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00141.jpg)'
- en: As you can see, there’s a colon between each key and its value, and the key/value
    pairs are separated by commas.
  id: totrans-5412
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，每个键和它的值之间都有一个冒号，键值对之间用逗号分隔。
- en: Dictionaries are different from arrays in that they are *unordered* . Because
    of that, it’s likely that the order of the states that you see in your results
    pane ➋ is different from the order in which you entered your states ➊ . It might
    even be different than the order that’s printed in this book!
  id: totrans-5413
  prefs: []
  type: TYPE_NORMAL
  zh: 字典与数组的不同之处在于，它们是*无序的*。因此，你看到的结果面板中州的顺序➋可能与输入州的顺序➊不同。甚至可能与书中打印的顺序不同！
- en: As with arrays, you can use var to make a mutable dictionary or use let to make
    an immutable dictionary.
  id: totrans-5414
  prefs: []
  type: TYPE_NORMAL
  zh: 与数组类似，你可以使用 var 来创建一个可变字典，或者使用 let 来创建一个不可变字典。
- en: 'In Swift, all of the keys of a dictionary must be the same type, and all of
    the values of a dictionary must also be the same type, but the key type doesn’t
    have to match the value type. For example, if you wanted to store a collection
    of fractions, you could use doubles for the keys and strings for the values:'
  id: totrans-5415
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Swift 中，字典的所有键必须是相同类型的，字典的所有值也必须是相同类型的，但键的类型不必与值的类型相匹配。例如，如果你想存储一个分数的集合，你可以使用浮动类型作为键，字符串作为值：
- en: '![](Image00142.jpg)'
  id: totrans-5416
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00142.jpg)'
- en: In this dictionary, all of the keys must be doubles, and all of the values must
    be strings. Again, you’ll see that the order of the numbers in the results pane
    can be quite different from the order in which you wrote the fractions in your
    dictionary. This is fine because you don’t need to know the order to access anything.
    You can find any item that you need by its key. Let’s see how!
  id: totrans-5417
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个字典中，所有的键必须是浮动类型（doubles），所有的值必须是字符串（strings）。再说一次，你会看到结果面板中的数字顺序与在字典中写入分数的顺序可能会完全不同。这是可以接受的，因为你不需要知道顺序就能访问任何内容。你可以通过键来查找所需的任何项目。让我们来看看如何操作！
- en: '**ACCESSING VALUES IN A DICTIONARY**'
  id: totrans-5418
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**访问字典中的值**'
- en: 'Looking up a value in a dictionary is similar to how you access a value in
    an array except that you use a key inside the square brackets instead of an index,
    like this: usStates["TX"] .'
  id: totrans-5419
  prefs: []
  type: TYPE_NORMAL
  zh: 查找字典中的值类似于你在数组中访问值的方式，只是你需要在方括号内使用一个键而不是索引，像这样：usStates["TX"]。
- en: There is a big difference, however, in how Swift returns the values from a dictionary.
    When you access a value at an index of an array, you are simply given the value.
    When you access a value with a key in a dictionary, you are given an optional.
  id: totrans-5420
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，Swift 在从字典中返回值的方式上有很大的不同。当你访问数组中的一个索引值时，你直接得到那个值。当你使用字典的键来访问值时，你会得到一个可选值（optional）。
- en: In [Chapter 5](text00015.html#ch05) , you learned that optionals might contain
    a value or might be nil . The reason Swift returns optionals when you’re looking
    up items in a dictionary is that the key you used might not exist in the dictionary,
    in which case there’s no value to access. Trying to access a value that doesn’t
    exist would give you a big fat error! To avoid that problem, Swift returns optionals.
    That means you need to unwrap any value you get out of a dictionary before you
    can do anything with it.
  id: totrans-5421
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第 5 章](text00015.html#ch05)中，你学到过可选值可能包含一个值，也可能是 nil。Swift 在查找字典中的项时返回可选值的原因是，你使用的键可能在字典中不存在，这种情况下就没有值可以访问。试图访问一个不存在的值会导致一个大错误！为了避免这个问题，Swift
    返回可选值。这意味着你在使用字典获取到的任何值之前，都需要解包它。
- en: 'To unwrap an optional, first you check whether it exists using an if-let statement,
    just like we did in [Chapter 5](text00015.html#ch05) . The following code shows
    you how to get a value out of a dictionary:'
  id: totrans-5422
  prefs: []
  type: TYPE_NORMAL
  zh: 要解包一个可选值，首先你需要检查它是否存在，可以使用 if-let 语句，就像我们在[第 5 章](text00015.html#ch05)中做的那样。以下代码展示了如何从字典中获取一个值：
- en: '![Image](Image00143.jpg)'
  id: totrans-5423
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00143.jpg)'
- en: To retrieve "Texas" from the dictionary, we use if let to set a constant loneStarState
    to usStates["TX"] ➊ . Because we have this state in our dictionary, the line I
    have Texas in my dictionary. is printed. Next we try to access a state that is
    not in our dictionary by using the key usStates["FL"] ➋ . Thankfully, because
    we used an if-let statement, the program won’t crash when the computer can’t find
    this state. Instead, I don't have that state in my dictionary. is printed.
  id: totrans-5424
  prefs: []
  type: TYPE_NORMAL
  zh: 要从字典中检索 "Texas"，我们使用 if let 将常量 loneStarState 设置为 usStates["TX"] ➊。因为我们字典中有这个州，所以会打印出
    "I have Texas in my dictionary." 接下来，我们尝试通过键 usStates["FL"] ➋ 来访问一个不在字典中的州。幸运的是，因为我们使用了
    if-let 语句，当计算机找不到这个州时，程序不会崩溃。相反，打印出 "I don't have that state in my dictionary."。
- en: '**ADDING ITEMS TO A DICTIONARY**'
  id: totrans-5425
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**向字典添加项**'
- en: 'To add an item to a dictionary, first write the name of your dictionary and
    assign the new item to the key you want it to have in the dictionary. Let’s add
    "Minnesota" to our usStates dictionary:'
  id: totrans-5426
  prefs: []
  type: TYPE_NORMAL
  zh: 要向字典中添加一个项，首先写下字典的名称，并将新项赋值给你希望它在字典中具有的键。我们来往我们的 usStates 字典中添加 "Minnesota"：
- en: '![](Image00144.jpg)'
  id: totrans-5427
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00144.jpg)'
- en: 'Now when you look at usStates , you’ll see that it’s updated to ["MN": "Minnesota",
    "WA": "Washington", "MA": "Massachusetts", "TX": "Texas"] . Remember, because
    you don’t have to rely on indices, your new dictionary item might appear anywhere
    in the dictionary.'
  id: totrans-5428
  prefs: []
  type: TYPE_NORMAL
  zh: '现在当你查看 usStates 时，你会看到它更新为 ["MN": "Minnesota", "WA": "Washington", "MA": "Massachusetts",
    "TX": "Texas"]。记住，因为你不需要依赖索引，所以你的新字典项可能出现在字典中的任何位置。'
- en: '**REMOVING ITEMS FROM A DICTIONARY**'
  id: totrans-5429
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**从字典中移除项**'
- en: Removing an item from a dictionary is quite simple; you do so by setting the
    value to nil . Because the values in dictionaries are returned as optionals, you
    don’t have to worry about nil causing any problems in your dictionary.
  id: totrans-5430
  prefs: []
  type: TYPE_NORMAL
  zh: 从字典中移除项非常简单；你只需要将值设置为 nil。由于字典中的值是以可选项的形式返回的，因此你不必担心 nil 会在字典中引起任何问题。
- en: '![](Image00145.jpg)'
  id: totrans-5431
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00145.jpg)'
- en: 'You can see that after you remove the value at the key "MA" , usStates is updated
    to ["MN": "Minnesota", "WA": "Washington", "TX": "Texas"] . Remember that nil
    is special and means that there’s no value at all. That’s why you don’t see "MA":
    nil in our dictionary.'
  id: totrans-5432
  prefs: []
  type: TYPE_NORMAL
  zh: '你可以看到，在移除键 "MA" 的值后，usStates 更新为 ["MN": "Minnesota", "WA": "Washington", "TX":
    "Texas"]。记住，nil 是特殊的，表示没有任何值。这就是为什么我们在字典中看不到 "MA": nil。'
- en: '**REPLACING ITEMS IN A DICTIONARY**'
  id: totrans-5433
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**在字典中替换项**'
- en: 'Replacing an item in a dictionary is also easy. It works the same was as replacing
    an item in an array. You just set the item that you want to replace to something
    else. Say you create a dictionary of fruit colors:'
  id: totrans-5434
  prefs: []
  type: TYPE_NORMAL
  zh: 替换字典中的项也很简单。它的工作方式和替换数组中的项一样。你只需要将你想替换的项设置为其他值。假设你创建了一个水果颜色的字典：
- en: '![](Image00146.jpg)'
  id: totrans-5435
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00146.jpg)'
- en: At first we had the value "apple" for "red" , but then we decided that "raspberry"
    is a better fruit to use since sometimes apples are green or yellow. To replace
    "apple" with "raspberry" , we set colorFruits["red"] to its new value ➊ .
  id: totrans-5436
  prefs: []
  type: TYPE_NORMAL
  zh: 一开始我们为 "red" 设置了值 "apple"，但是后来我们决定 "raspberry" 更适合作为水果，因为有时候苹果是绿色或黄色的。要将 "apple"
    替换为 "raspberry"，我们将 colorFruits["red"] 设置为它的新值 ➊。
- en: You may remember that this is the same way we entered a new value into a dictionary.
    If the key already exists in the dictionary, then the value for that key is replaced.
    If the key doesn’t already exist, then the new key/value pair will be added to
    the dictionary.
  id: totrans-5437
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能记得这就是我们向字典中添加新值的方式。如果键已经存在于字典中，那么该键的值将被替换。如果该键不存在，那么新的键/值对将被添加到字典中。
- en: '![Image](Image00147.jpg)'
  id: totrans-5438
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00147.jpg)'
- en: '**USING DICTIONARY PROPERTIES**'
  id: totrans-5439
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**使用字典属性**'
- en: 'Like an array, a dictionary also has an isEmpty property and a count property.
    For example, the following code shows how you can use the isEmpty property to
    check if a dictionary is empty, and if it isn’t empty, the count property checks
    how many items you have. Imagine you have a basket of fruit for sale. You can
    use these properties to help you keep track of everything:'
  id: totrans-5440
  prefs: []
  type: TYPE_NORMAL
  zh: 像数组一样，字典也有一个 isEmpty 属性和一个 count 属性。例如，下面的代码展示了如何使用 isEmpty 属性检查字典是否为空，如果不为空，count
    属性则可以检查你有多少项。假设你有一个水果篮子在出售。你可以使用这些属性帮助你跟踪所有的内容：
- en: '![Image](Image00148.jpg)'
  id: totrans-5441
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00148.jpg)'
- en: 'A dictionary also has two special properties: keys , which contains all of
    the dictionary’s keys, and values , which contains all of its values. We’ll use
    these two properties when we loop through the dictionary.'
  id: totrans-5442
  prefs: []
  type: TYPE_NORMAL
  zh: 字典还有两个特殊的属性：keys，它包含字典的所有键，以及 values，它包含字典的所有值。我们将在遍历字典时使用这两个属性。
- en: Let’s write some code that loops through our fruit baskets and prints the price
    of each fruit.
  id: totrans-5443
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们写一些代码，遍历我们的水果篮子并打印每个水果的价格。
- en: '**LOOPING OVER A DICTIONARY**'
  id: totrans-5444
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**遍历字典**'
- en: 'You can loop through a dictionary using a for-in loop. Because each item has
    a key and a value, you can do this in two different ways. This is how to loop
    through a dictionary using its keys:'
  id: totrans-5445
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用 for-in 循环遍历字典。由于每个项都有一个键和值，你可以通过两种不同的方式来遍历字典。以下是使用键遍历字典的方式：
- en: '![Image](Image00149.jpg)'
  id: totrans-5446
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00149.jpg)'
- en: Here we use the dictionary’s keys property ➊ to loop through fruitBasket and
    print its contents. We start by writing the keyword for , followed by a constant
    name fruit for the dictionary key, the keyword in , the dictionary name, a period,
    and keys .
  id: totrans-5447
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们使用字典的 keys 属性 ➊ 来遍历 fruitBasket 并打印其内容。我们从写关键字 for 开始，后跟字典键的常量名 fruit，再加上关键字
    in，字典名，句点和 keys。
- en: Inside the braces of our for-in loop, we have access to both the key, which
    we call fruit ➋ , and the value at that key when we force-unwrap its contents
    with fruitBasket[fruit]! ➌ . That value will be the fruit’s price.
  id: totrans-5448
  prefs: []
  type: TYPE_NORMAL
  zh: 在 for-in 循环的大括号内，我们可以访问键（我们称之为 fruit ➋），以及通过 fruitBasket[fruit]! ➌ 强制解包该键的值。这个值将是水果的价格。
- en: In this case, it’s safe to force-unwrap the value using an exclamation point
    because we know that the fruit key we’re using is definitely inside the dictionary.
  id: totrans-5449
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，使用感叹号强制解包值是安全的，因为我们知道我们使用的水果键一定在字典中。
- en: Any code we put inside the for-in loop will run once for every key in our dictionary.
    So you should see the print statement display three times.
  id: totrans-5450
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在 for-in 循环中放入的任何代码都会为字典中的每个键执行一次。因此，你应该看到打印语句显示三次。
- en: 'We can also loop through the dictionary using its values property:'
  id: totrans-5451
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以通过字典的值属性来遍历字典：
- en: '![Image](Image00150.jpg)'
  id: totrans-5452
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00150.jpg)'
- en: We use the same style of for-in loop, but now we use a constant to refer to
    each value, which we call price , in the values property. When looping through
    values, we don’t have access to the keys from inside the loop.
  id: totrans-5453
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用相同样式的 for-in 循环，但现在我们使用常量来引用 values 属性中的每个值，我们称之为 price。在遍历值时，我们无法在循环内部访问键。
- en: Another difference to note is that price is not an optional because it’s accessed
    directly as a value in the fruitBasket dictionary. That means we don’t have to
    unwrap it. You should still see the print statement printed three times. [Figure
    6-6](text00016.html#ch06fig6) shows the output of both loops.
  id: totrans-5454
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个需要注意的区别是，price 不是一个可选项，因为它是直接作为水果篮子字典中的值来访问的。这意味着我们不需要解包它。你仍然应该看到打印语句打印了三次。[图
    6-6](text00016.html#ch06fig6)展示了两次循环的输出。
- en: '![Image](Image00151.jpg)'
  id: totrans-5455
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00151.jpg)'
- en: '*Figure 6-6: Looping through the keys and values of a dictionary with a for-in
    loop*'
  id: totrans-5456
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 6-6：使用 for-in 循环遍历字典的键和值*'
- en: The order of your results might be slightly different from ours. That’s because
    the items in a dictionary aren’t in a numbered order like they are in an array!
    And because the order is not guaranteed, you might see a different order printed
    if you run the same code again.
  id: totrans-5457
  prefs: []
  type: TYPE_NORMAL
  zh: 你的结果顺序可能会与我们的有所不同。因为字典中的项不像数组中的项那样是按编号顺序排列的！而且由于顺序不可保证，如果你再次运行相同的代码，可能会看到不同的顺序。
- en: '**WHAT YOU LEARNED**'
  id: totrans-5458
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**你学到了什么**'
- en: In this chapter, you learned how to store collections of items in an array and
    in a dictionary. To store items in an ordered list, you would use an array and
    look up each item by its index. If you wanted to store items by key instead, you
    would use a dictionary.
  id: totrans-5459
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你学会了如何将项存储在数组和字典中。要在有序列表中存储项，你可以使用数组，并通过索引查找每个项。如果你想按键存储项，则应使用字典。
- en: Knowing about arrays and dictionaries and how to use them is a powerful building
    block for almost any programming language. Next we will learn about functions,
    another very powerful tool. Functions are blocks of code that you create and name
    to perform a specific job. After you have written a function, you can use its
    name to call it from almost anywhere in your program.
  id: totrans-5460
  prefs: []
  type: TYPE_NORMAL
  zh: 了解数组和字典及其使用方法是几乎所有编程语言中强大的构建模块。接下来，我们将学习函数，另一个非常强大的工具。函数是你创建并命名的代码块，用于执行特定任务。编写完函数后，你可以通过它的名称在程序中的几乎任何地方调用它。
- en: '![](Image00122.jpg)'
  id: totrans-5461
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00122.jpg)'
- en: Now you can make a delicious smoothie by adding the fruits and liquids arrays.
  id: totrans-5462
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你可以通过将fruits和liquids数组相加来制作一杯美味的奶昔。
- en: '![](Image00123.jpg)'
  id: totrans-5463
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00123.jpg)'
- en: The order of the ingredients in smoothie is the same as the order in fruits
    and liquids . If you created smoothie with liquids + fruits , then the liquids
    would come first.
  id: totrans-5464
  prefs: []
  type: TYPE_NORMAL
  zh: 奶昔中的配料顺序与fruits和liquids中的顺序相同。如果你是通过liquids + fruits来创建奶昔，那么液体会排在前面。
- en: 'You use the += operator to add an array to the end of your array. Add some
    whipped cream as follows for extra yumminess:'
  id: totrans-5465
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用+=操作符将一个数组添加到你的数组末尾。为了让它更美味，可以添加一些鲜奶油：
- en: '![](Image00124.jpg)'
  id: totrans-5466
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00124.jpg)'
- en: Note that ["whipped cream"] is an array even though it has a single item in
    it. When you’re using += to append something to an array, you have to make sure
    you’re only trying to add another array. If you were to just write the string
    "whipped cream" without the square brackets around it, you would get an error.
  id: totrans-5467
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，["whipped cream"]是一个数组，尽管它只有一项。当你使用+=将某个项添加到数组时，必须确保你只在添加另一个数组。如果你只是写了字符串“whipped
    cream”，没有用方括号括起来，就会出现错误。
- en: '![Image](Image00125.jpg)'
  id: totrans-5468
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00125.jpg)'
- en: '**REMOVING ITEMS FROM AN ARRAY**'
  id: totrans-5469
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**从数组中删除项**'
- en: 'There are several methods for removing items from an array. Let’s start by
    looking at the array’s removeLast() method. As you might have guessed from its
    name, removeLast() removes the last item from your array. Let’s try it out with
    a shoppingList array:'
  id: totrans-5470
  prefs: []
  type: TYPE_NORMAL
  zh: 删除数组项有几种方法。让我们先看一下数组的removeLast()方法。正如你从它的名字中可能猜到的那样，removeLast()会删除数组中的最后一项。让我们用一个shoppingList数组来试一下：
- en: '![](Image00126.jpg)'
  id: totrans-5471
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00126.jpg)'
- en: Neat! Note that the removeLast() method returns the removed item, so you can
    store it in a new constant or variable if you want.
  id: totrans-5472
  prefs: []
  type: TYPE_NORMAL
  zh: 很棒！请注意，removeLast()方法会返回已删除的项，因此如果需要，你可以将其存储在新的常量或变量中。
- en: 'You can also remove an item from a specific index by using the remove(at:)
    method. Let’s say that your mom doesn’t want you buying any candy and takes that
    off the list:'
  id: totrans-5473
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以通过使用remove(at:)方法从特定索引删除一项。假设你妈妈不希望你买糖果，并将其从列表中移除：
- en: '![Image](Image00127.jpg)![](Image00128.jpg)'
  id: totrans-5474
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00127.jpg)![](Image00128.jpg)'
- en: Just like when we added an item to the middle of our array and all the items
    scooted over to make room, if you remove an item from the middle of an array,
    the rest of the items will scoot back to fill in that empty space. The "apples"
    item that was at index 3 is now at index 2, where "candy" was.
  id: totrans-5475
  prefs: []
  type: TYPE_NORMAL
  zh: 就像我们把一项添加到数组的中间，所有项都会往一边挪动以腾出空间一样，如果你从数组的中间删除一项，其余的项会重新挪动以填补那个空位。原来在索引3处的“apples”现在位于索引2处，那里原本是“candy”。
- en: 'You can also remove all items from an array with removeAll() . Try entering
    this into your playground:'
  id: totrans-5476
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以使用removeAll()方法删除数组中的所有项。试着将以下代码输入到你的 playground 中：
- en: '![](Image00129.jpg)'
  id: totrans-5477
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00129.jpg)'
- en: 'Note that trying to remove an item at an index that doesn’t exist will give
    you an error:'
  id: totrans-5478
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，尝试删除一个不存在索引的项会报错：
- en: '![](Image00130.jpg)'
  id: totrans-5479
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00130.jpg)'
- en: Our array doesn’t have this many items (in fact, now it’s empty!), so this throws
    an error. We’ll also get an error if we use removeLast() on our empty array, because
    there’s nothing in it—there’s no last index at all! However, removeAll() is always
    safe to use, even on an empty array.
  id: totrans-5480
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的数组没有这么多项目（事实上，现在它是空的！），所以会抛出一个错误。如果我们在空数组上使用 removeLast() ，也会抛出错误，因为它什么都没有——根本没有最后一个索引！然而，使用
    removeAll() 即使在空数组上也是安全的。
- en: '**REPLACING ITEMS IN AN ARRAY**'
  id: totrans-5481
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**替换数组中的元素**'
- en: 'To replace an item in an array, you set the index of the array to the new value,
    as shown here:'
  id: totrans-5482
  prefs: []
  type: TYPE_NORMAL
  zh: 要替换数组中的项目，你需要将数组的索引设置为新值，如下所示：
- en: '![](Image00131.jpg)'
  id: totrans-5483
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00131.jpg)'
- en: At ➊ , we replaced the item at index 2 (the third item) with "Unicorn" because
    magical animals count as favorite animals, too! At ➋ , we replaced the item at
    index 0 (the first item) with "Bearded dragon" . No, that’s not a real dragon—it’s
    just a lizard!
  id: totrans-5484
  prefs: []
  type: TYPE_NORMAL
  zh: 在 ➊ ，我们将索引为 2（第三个元素）的位置的元素替换为“独角兽”，因为魔法动物也算是最喜欢的动物！在 ➋ ，我们将索引为 0（第一个元素）的位置的元素替换为“胡须龙”。不，这不是一条真正的龙——它只是一个蜥蜴！
- en: Like any time you’re working with array index numbers, you have to be sure an
    item exists in the array at that index before you change its value, or you will
    get an Index out of range error.
  id: totrans-5485
  prefs: []
  type: TYPE_NORMAL
  zh: 就像处理数组索引时一样，在修改某个索引处的值之前，你必须确保该索引位置的元素确实存在，否则会出现“索引超出范围”的错误。
- en: '[Figure 6-3](text00016.html#ch06fig3) shows the error that occurs if you try
    to add "Standard poodle" using favoriteAnimals[3] = "Standard poodle" . To add
    an item to the end of an array, you should use the append(_:) method or += , as
    we covered in “[Adding Items to an Array](text00016.html#ch06lev2sec5) ” on [page
    70](text00016.html#page_70) .'
  id: totrans-5486
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 6-3](text00016.html#ch06fig3) 展示了如果你尝试通过 favoriteAnimals[3] = "Standard
    poodle" 来添加“标准贵宾犬”时会出现的错误。要将元素添加到数组的末尾，你应该使用 append(_:) 方法或 += ，正如我们在 “[向数组添加元素](text00016.html#ch06lev2sec5)”
    中讲到的，见 [第 70 页](text00016.html#page_70) 。'
- en: '![Image](Image00132.jpg)'
  id: totrans-5487
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00132.jpg)'
- en: '*Figure 6-3: Don’t try to replace a value at an index beyond the existing array.*'
  id: totrans-5488
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 6-3：不要尝试替换超出现有数组范围的索引处的值。*'
- en: Now you know how to change arrays however you might need to. You can add items,
    take items away, or replace items. Next, we’ll look at how to use the properties
    of arrays to find out even more information about them.
  id: totrans-5489
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经知道如何根据需要修改数组。你可以添加元素、删除元素或替换元素。接下来，我们将看看如何使用数组的属性来获取更多有关它们的信息。
- en: '![Image](Image00133.jpg)'
  id: totrans-5490
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00133.jpg)'
- en: '**USING ARRAY PROPERTIES**'
  id: totrans-5491
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**使用数组属性**'
- en: In addition to methods like append(_:) and removeLast() , arrays also have *properties*
    . An array’s properties are variables or constants that contain some information
    about the array. Two really helpful properties that you might use are the Boolean
    property isEmpty and the integer property count .
  id: totrans-5492
  prefs: []
  type: TYPE_NORMAL
  zh: 除了像 append(_:) 和 removeLast() 这样的函数，数组还有*属性*。数组的属性是包含数组信息的变量或常量。你可能会用到的两个非常有用的属性是布尔类型的属性
    isEmpty 和整数类型的属性 count。
- en: The isEmpty property is true or false depending on whether the array is empty,
    and the count property will tell you how many items are in that array.
  id: totrans-5493
  prefs: []
  type: TYPE_NORMAL
  zh: isEmpty 属性根据数组是否为空返回 true 或 false，而 count 属性会告诉你数组中有多少个元素。
- en: 'Check out how these two properties are used in the following if-else statement:'
  id: totrans-5494
  prefs: []
  type: TYPE_NORMAL
  zh: 请查看以下 if-else 语句中如何使用这两个属性：
- en: '![Image](Image00134.jpg)'
  id: totrans-5495
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00134.jpg)'
- en: 'This if-else statement checks whether the array mySiblings is empty ➊ . If
    it is, then "I don''t have any siblings." is printed. But if there is something
    in the array, then the number of siblings that we have is printed: "I have 3 siblings."
    ➋ .'
  id: totrans-5496
  prefs: []
  type: TYPE_NORMAL
  zh: 这个 if-else 语句检查数组 mySiblings 是否为空 ➊ 。如果为空，则打印“我没有兄弟姐妹。”；如果数组中有元素，则打印我们有多少个兄弟姐妹：“我有
    3 个兄弟姐妹。” ➋ 。
- en: '**LOOPING OVER AN ARRAY**'
  id: totrans-5497
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**遍历数组**'
- en: 'Sometimes when you’re working with arrays you might want to do something to
    every item in the array. You can use a for-in loop to do that! The following code
    will print every topping in a pizzaToppings array on a separate line:'
  id: totrans-5498
  prefs: []
  type: TYPE_NORMAL
  zh: 有时候在处理数组时，你可能想对数组中的每个元素执行某个操作。你可以使用 for-in 循环来实现！以下代码将逐行打印 pizzaToppings 数组中的每个配料：
- en: '![Image](Image00135.jpg)'
  id: totrans-5499
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00135.jpg)'
- en: To write a for-in loop for the pizzaToppings array, we used the keyword for
    , followed by the constant topping , then the keyword in , and finally the name
    of our array, pizzaToppings . Then we put the statements that we want to run for
    each topping inside the braces of the for-in loop. The constant topping ➊ temporarily
    represents each pizza topping in the array as we loop through it. We could have
    chosen any name for this constant, but it’s a good idea to pick something that
    makes sense. You can see the output of this for-in loop in [Figure 6-4](text00016.html#ch06fig4)
    .
  id: totrans-5500
  prefs: []
  type: TYPE_NORMAL
  zh: 要为pizzaToppings数组写一个for-in循环，我们使用了关键字for，接着是常量topping，之后是关键字in，最后是我们数组的名字pizzaToppings。然后我们将希望在每个topping上执行的语句放在for-in循环的花括号内。常量topping
    ➊在我们遍历数组时暂时表示数组中的每个比萨配料。我们本可以为这个常量选择任何名字，但选择一个有意义的名字是个好主意。你可以在[图6-4](text00016.html#ch06fig4)中看到这个for-in循环的输出。
- en: '![Image](Image00136.jpg)'
  id: totrans-5501
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00136.jpg)'
- en: '*Figure 6-4: Output of the example for-in loop*'
  id: totrans-5502
  prefs: []
  type: TYPE_NORMAL
  zh: '*图6-4：for-in循环示例的输出*'
- en: '![Image](Image00137.jpg)'
  id: totrans-5503
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00137.jpg)'
- en: 'Using for-in loops is great for printing every value in an array. If you’re
    working with numbers, you can even use them to perform math operations on each
    item, which makes for some speedy calculations! The following code takes an array
    of numbers and calculates the square for each (the square of a number is that
    number multiplied by itself):'
  id: totrans-5504
  prefs: []
  type: TYPE_NORMAL
  zh: 使用for-in循环非常适合打印数组中的每个值。如果你处理的是数字，你甚至可以用它们对每个项目执行数学运算，这样可以进行快速的计算！以下代码接收一个数字数组，并计算每个数字的平方（一个数字的平方是该数字与它自身相乘的结果）：
- en: '![Image](Image00138.jpg)'
  id: totrans-5505
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00138.jpg)'
- en: '[Figure 6-5](text00016.html#ch06fig5) shows the results.'
  id: totrans-5506
  prefs: []
  type: TYPE_NORMAL
  zh: '[图6-5](text00016.html#ch06fig5)展示了结果。'
- en: '![Image](Image00139.jpg)'
  id: totrans-5507
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00139.jpg)'
- en: '*Figure 6-5: Printing the squares for each number in the myNumbers array*'
  id: totrans-5508
  prefs: []
  type: TYPE_NORMAL
  zh: '*图6-5：打印myNumbers数组中每个数字的平方*'
- en: '**DICTIONARIES ARE KEY!**'
  id: totrans-5509
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**字典至关重要！**'
- en: A *dictionary* is also a collection of values, but instead of an ordered index,
    each value has its own *key* . Because there’s no index, the values are not stored
    in any particular order. To access values in a dictionary, you look them up by
    their key.
  id: totrans-5510
  prefs: []
  type: TYPE_NORMAL
  zh: '*字典*也是一组值，但不同于有序索引，字典中的每个值都有它自己的*键*。因为没有索引，值并没有按照特定的顺序存储。要访问字典中的值，你需要通过它们的键来查找。'
- en: A key must be unique. You can’t have the same key more than once in the same
    dictionary. If there were two identical keys and you asked the computer to give
    you the value for one of them, the computer wouldn’t know which one to choose!
  id: totrans-5511
  prefs: []
  type: TYPE_NORMAL
  zh: 键必须是唯一的。在同一个字典中，你不能有两个相同的键。如果有两个相同的键，而你请求计算机返回其中一个的值，计算机将无法确定选择哪个！
- en: Let’s take a look at how to make a dictionary and write keys that will help
    you find all the information you need.
  id: totrans-5512
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如何创建一个字典，并编写帮助你找到所需所有信息的键。
- en: '![Image](Image00140.jpg)'
  id: totrans-5513
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00140.jpg)'
- en: '**INITIALIZING A DICTIONARY**'
  id: totrans-5514
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**初始化字典**'
- en: 'To create and initialize a dictionary, first write var and the name of your
    dictionary. Then write the keys and corresponding values inside a pair of square
    brackets, similar to an array. Let’s create a dictionary to store the names of
    a few US states. The key for each state will be its two-letter abbreviation:'
  id: totrans-5515
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建并初始化一个字典，首先写var和字典的名称。然后在一对方括号内写出键和相应的值，类似于数组。让我们创建一个字典来存储几个美国州的名字。每个州的键将是它的两个字母的缩写：
- en: '![](Image00141.jpg)'
  id: totrans-5516
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00141.jpg)'
- en: As you can see, there’s a colon between each key and its value, and the key/value
    pairs are separated by commas.
  id: totrans-5517
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，每个键和它的值之间有一个冒号，并且键/值对之间用逗号分隔。
- en: Dictionaries are different from arrays in that they are *unordered* . Because
    of that, it’s likely that the order of the states that you see in your results
    pane ➋ is different from the order in which you entered your states ➊ . It might
    even be different than the order that’s printed in this book!
  id: totrans-5518
  prefs: []
  type: TYPE_NORMAL
  zh: 字典与数组不同，字典是*无序*的。因为这一点，你看到的结果窗格中状态的顺序➋可能与输入状态的顺序➊不同。甚至可能与书中打印的顺序不同！
- en: As with arrays, you can use var to make a mutable dictionary or use let to make
    an immutable dictionary.
  id: totrans-5519
  prefs: []
  type: TYPE_NORMAL
  zh: 与数组一样，你可以使用var来创建一个可变字典，或者使用let来创建一个不可变字典。
- en: 'In Swift, all of the keys of a dictionary must be the same type, and all of
    the values of a dictionary must also be the same type, but the key type doesn’t
    have to match the value type. For example, if you wanted to store a collection
    of fractions, you could use doubles for the keys and strings for the values:'
  id: totrans-5520
  prefs: []
  type: TYPE_NORMAL
  zh: 在Swift中，字典的所有键必须是相同类型的，字典的所有值也必须是相同类型的，但键的类型不必与值的类型匹配。例如，如果你想存储一个分数的集合，你可以使用`double`作为键，`string`作为值：
- en: '![](Image00142.jpg)'
  id: totrans-5521
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00142.jpg)'
- en: In this dictionary, all of the keys must be doubles, and all of the values must
    be strings. Again, you’ll see that the order of the numbers in the results pane
    can be quite different from the order in which you wrote the fractions in your
    dictionary. This is fine because you don’t need to know the order to access anything.
    You can find any item that you need by its key. Let’s see how!
  id: totrans-5522
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个字典中，所有的键必须是`double`类型，所有的值必须是字符串类型。同样，你会发现结果面板中的数字顺序可能与在字典中书写分数时的顺序完全不同。这没关系，因为你不需要知道顺序就能访问任何项。你可以通过键找到任何需要的项目。让我们看看如何做到这一点！
- en: '**ACCESSING VALUES IN A DICTIONARY**'
  id: totrans-5523
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**访问字典中的值**'
- en: 'Looking up a value in a dictionary is similar to how you access a value in
    an array except that you use a key inside the square brackets instead of an index,
    like this: usStates["TX"] .'
  id: totrans-5524
  prefs: []
  type: TYPE_NORMAL
  zh: 在字典中查找一个值类似于你在数组中访问一个值，只是你使用的是方括号中的键，而不是索引，像这样：`usStates["TX"]`。
- en: There is a big difference, however, in how Swift returns the values from a dictionary.
    When you access a value at an index of an array, you are simply given the value.
    When you access a value with a key in a dictionary, you are given an optional.
  id: totrans-5525
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，Swift返回字典值的方式与数组有很大不同。当你在数组中访问一个值时，你只是简单地得到该值。而当你在字典中通过键访问一个值时，你得到的是一个可选值。
- en: In [Chapter 5](text00015.html#ch05) , you learned that optionals might contain
    a value or might be nil . The reason Swift returns optionals when you’re looking
    up items in a dictionary is that the key you used might not exist in the dictionary,
    in which case there’s no value to access. Trying to access a value that doesn’t
    exist would give you a big fat error! To avoid that problem, Swift returns optionals.
    That means you need to unwrap any value you get out of a dictionary before you
    can do anything with it.
  id: totrans-5526
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第5章](text00015.html#ch05)中，你学到过可选值可能包含一个值，也可能是nil。Swift在查找字典中的项目时返回可选值的原因是，你使用的键可能在字典中不存在，在这种情况下是无法访问到值的。尝试访问一个不存在的值会导致一个大错误！为了避免这个问题，Swift返回可选值。这意味着你需要解包从字典中得到的任何值，才能对其进行操作。
- en: 'To unwrap an optional, first you check whether it exists using an if-let statement,
    just like we did in [Chapter 5](text00015.html#ch05) . The following code shows
    you how to get a value out of a dictionary:'
  id: totrans-5527
  prefs: []
  type: TYPE_NORMAL
  zh: 要解包一个可选值，首先使用`if-let`语句检查它是否存在，就像我们在[第5章](text00015.html#ch05)中做的那样。下面的代码展示了如何从字典中获取一个值：
- en: '![Image](Image00143.jpg)'
  id: totrans-5528
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00143.jpg)'
- en: To retrieve "Texas" from the dictionary, we use if let to set a constant loneStarState
    to usStates["TX"] ➊ . Because we have this state in our dictionary, the line I
    have Texas in my dictionary. is printed. Next we try to access a state that is
    not in our dictionary by using the key usStates["FL"] ➋ . Thankfully, because
    we used an if-let statement, the program won’t crash when the computer can’t find
    this state. Instead, I don't have that state in my dictionary. is printed.
  id: totrans-5529
  prefs: []
  type: TYPE_NORMAL
  zh: 要从字典中检索"Texas"，我们使用`if let`将常量loneStarState设置为`usStates["TX"]` ➊。因为我们的字典中有这个州，所以会打印出"我在字典中有Texas"。接下来，我们尝试使用键`usStates["FL"]`
    ➋访问一个不在字典中的州。幸运的是，使用了`if-let`语句后，当计算机找不到这个州时，程序不会崩溃。相反，会打印出"我在字典中没有这个州"。
- en: '**ADDING ITEMS TO A DICTIONARY**'
  id: totrans-5530
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**向字典中添加项目**'
- en: 'To add an item to a dictionary, first write the name of your dictionary and
    assign the new item to the key you want it to have in the dictionary. Let’s add
    "Minnesota" to our usStates dictionary:'
  id: totrans-5531
  prefs: []
  type: TYPE_NORMAL
  zh: 要向字典中添加一个项目，首先写下字典的名称，并将新项目赋值给你希望它在字典中具有的键。让我们向`usStates`字典中添加"Minnesota"：
- en: '![](Image00144.jpg)'
  id: totrans-5532
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00144.jpg)'
- en: 'Now when you look at usStates , you’ll see that it’s updated to ["MN": "Minnesota",
    "WA": "Washington", "MA": "Massachusetts", "TX": "Texas"] . Remember, because
    you don’t have to rely on indices, your new dictionary item might appear anywhere
    in the dictionary.'
  id: totrans-5533
  prefs: []
  type: TYPE_NORMAL
  zh: '现在，当你查看`usStates`时，你会看到它已经更新为["MN": "Minnesota", "WA": "Washington", "MA":
    "Massachusetts", "TX": "Texas"]。记住，因为你不需要依赖索引，你的新字典项可能出现在字典的任何位置。'
- en: '**REMOVING ITEMS FROM A DICTIONARY**'
  id: totrans-5534
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**从字典中移除项目**'
- en: Removing an item from a dictionary is quite simple; you do so by setting the
    value to nil . Because the values in dictionaries are returned as optionals, you
    don’t have to worry about nil causing any problems in your dictionary.
  id: totrans-5535
  prefs: []
  type: TYPE_NORMAL
  zh: 从字典中移除项非常简单；你只需将值设置为nil即可。因为字典中的值是以可选值返回的，所以你不必担心nil会在字典中引发任何问题。
- en: '![](Image00145.jpg)'
  id: totrans-5536
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00145.jpg)'
- en: 'You can see that after you remove the value at the key "MA" , usStates is updated
    to ["MN": "Minnesota", "WA": "Washington", "TX": "Texas"] . Remember that nil
    is special and means that there’s no value at all. That’s why you don’t see "MA":
    nil in our dictionary.'
  id: totrans-5537
  prefs: []
  type: TYPE_NORMAL
  zh: '你可以看到，在你移除键"MA"对应的值后，usStates会更新为["MN": "Minnesota", "WA": "Washington", "TX":
    "Texas"]。记住，nil是特殊的，意味着根本没有值。因此，你在字典中看不到"MA": nil。'
- en: '**REPLACING ITEMS IN A DICTIONARY**'
  id: totrans-5538
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**替换字典中的项**'
- en: 'Replacing an item in a dictionary is also easy. It works the same was as replacing
    an item in an array. You just set the item that you want to replace to something
    else. Say you create a dictionary of fruit colors:'
  id: totrans-5539
  prefs: []
  type: TYPE_NORMAL
  zh: 替换字典中的项也很简单。它的工作方式与替换数组中的项相同。你只需将你想要替换的项设置为其他值。例如，你创建了一个水果颜色的字典：
- en: '![](Image00146.jpg)'
  id: totrans-5540
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00146.jpg)'
- en: At first we had the value "apple" for "red" , but then we decided that "raspberry"
    is a better fruit to use since sometimes apples are green or yellow. To replace
    "apple" with "raspberry" , we set colorFruits["red"] to its new value ➊ .
  id: totrans-5541
  prefs: []
  type: TYPE_NORMAL
  zh: 一开始我们为“red”设置了值“apple”，但是后来我们决定用“raspberry”这个水果，因为有时苹果是绿色或黄色的。为了将“apple”替换成“raspberry”，我们将colorFruits["red"]设置为它的新值
    ➊。
- en: You may remember that this is the same way we entered a new value into a dictionary.
    If the key already exists in the dictionary, then the value for that key is replaced.
    If the key doesn’t already exist, then the new key/value pair will be added to
    the dictionary.
  id: totrans-5542
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能记得，这就是我们将新值添加到字典中的方式。如果键已经存在于字典中，那么该键的值会被替换。如果键不存在，则新的键/值对会被添加到字典中。
- en: '![Image](Image00147.jpg)'
  id: totrans-5543
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00147.jpg)'
- en: '**USING DICTIONARY PROPERTIES**'
  id: totrans-5544
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**使用字典属性**'
- en: 'Like an array, a dictionary also has an isEmpty property and a count property.
    For example, the following code shows how you can use the isEmpty property to
    check if a dictionary is empty, and if it isn’t empty, the count property checks
    how many items you have. Imagine you have a basket of fruit for sale. You can
    use these properties to help you keep track of everything:'
  id: totrans-5545
  prefs: []
  type: TYPE_NORMAL
  zh: 和数组一样，字典也有isEmpty属性和count属性。例如，以下代码展示了如何使用isEmpty属性检查字典是否为空，如果字典不为空，count属性会检查你有多少项。想象一下，你有一个水果篮子待售。你可以使用这些属性帮助你跟踪所有内容：
- en: '![Image](Image00148.jpg)'
  id: totrans-5546
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00148.jpg)'
- en: 'A dictionary also has two special properties: keys , which contains all of
    the dictionary’s keys, and values , which contains all of its values. We’ll use
    these two properties when we loop through the dictionary.'
  id: totrans-5547
  prefs: []
  type: TYPE_NORMAL
  zh: 字典还有两个特殊的属性：keys，包含字典的所有键，以及values，包含字典的所有值。当我们遍历字典时，我们将使用这两个属性。
- en: Let’s write some code that loops through our fruit baskets and prints the price
    of each fruit.
  id: totrans-5548
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们写一些代码，遍历我们的水果篮子并打印每个水果的价格。
- en: '**LOOPING OVER A DICTIONARY**'
  id: totrans-5549
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**遍历字典**'
- en: 'You can loop through a dictionary using a for-in loop. Because each item has
    a key and a value, you can do this in two different ways. This is how to loop
    through a dictionary using its keys:'
  id: totrans-5550
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用for-in循环遍历字典。由于每个项都有一个键和值，你可以用两种不同的方式来实现。这是如何通过字典的键来遍历字典的方式：
- en: '![Image](Image00149.jpg)'
  id: totrans-5551
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00149.jpg)'
- en: Here we use the dictionary’s keys property ➊ to loop through fruitBasket and
    print its contents. We start by writing the keyword for , followed by a constant
    name fruit for the dictionary key, the keyword in , the dictionary name, a period,
    and keys .
  id: totrans-5552
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们使用字典的keys属性 ➊ 来遍历fruitBasket并打印其内容。我们从编写关键字for开始，后面跟着一个常量名fruit作为字典的键，再加上关键字in，字典名，一个句点和keys。
- en: Inside the braces of our for-in loop, we have access to both the key, which
    we call fruit ➋ , and the value at that key when we force-unwrap its contents
    with fruitBasket[fruit]! ➌ . That value will be the fruit’s price.
  id: totrans-5553
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的for-in循环的大括号内，我们可以访问到键，称其为fruit ➋，以及当我们强制解包其内容时，通过fruitBasket[fruit]! ➌
    获取到的该键对应的值。这个值将是水果的价格。
- en: In this case, it’s safe to force-unwrap the value using an exclamation point
    because we know that the fruit key we’re using is definitely inside the dictionary.
  id: totrans-5554
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，使用感叹号强制解包值是安全的，因为我们知道我们使用的水果键肯定在字典中。
- en: Any code we put inside the for-in loop will run once for every key in our dictionary.
    So you should see the print statement display three times.
  id: totrans-5555
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在 for-in 循环中放入的任何代码都会为字典中的每个键执行一次。所以你应该会看到打印语句显示三次。
- en: 'We can also loop through the dictionary using its values property:'
  id: totrans-5556
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以通过字典的 values 属性进行遍历：
- en: '![Image](Image00150.jpg)'
  id: totrans-5557
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00150.jpg)'
- en: We use the same style of for-in loop, but now we use a constant to refer to
    each value, which we call price , in the values property. When looping through
    values, we don’t have access to the keys from inside the loop.
  id: totrans-5558
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用相同的 for-in 循环样式，但现在我们使用一个常量来引用每个值，我们称之为 price，位于 values 属性中。在循环遍历 values
    时，我们无法访问到循环内部的键。
- en: Another difference to note is that price is not an optional because it’s accessed
    directly as a value in the fruitBasket dictionary. That means we don’t have to
    unwrap it. You should still see the print statement printed three times. [Figure
    6-6](text00016.html#ch06fig6) shows the output of both loops.
  id: totrans-5559
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个需要注意的区别是，price 不是可选项，因为它是直接作为值从 fruitBasket 字典中访问的。这意味着我们不需要解包它。你仍然应该看到打印语句打印三次。[图
    6-6](text00016.html#ch06fig6) 显示了两种循环的输出。
- en: '![Image](Image00151.jpg)'
  id: totrans-5560
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00151.jpg)'
- en: '*Figure 6-6: Looping through the keys and values of a dictionary with a for-in
    loop*'
  id: totrans-5561
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 6-6：使用 for-in 循环遍历字典的键和值*'
- en: The order of your results might be slightly different from ours. That’s because
    the items in a dictionary aren’t in a numbered order like they are in an array!
    And because the order is not guaranteed, you might see a different order printed
    if you run the same code again.
  id: totrans-5562
  prefs: []
  type: TYPE_NORMAL
  zh: 你的结果顺序可能与我们的略有不同。这是因为字典中的项目不像数组中的项目那样是按编号顺序排列的！由于顺序不能保证，如果你再次运行相同的代码，可能会看到不同的顺序。
- en: '**WHAT YOU LEARNED**'
  id: totrans-5563
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**你学到了什么**'
- en: In this chapter, you learned how to store collections of items in an array and
    in a dictionary. To store items in an ordered list, you would use an array and
    look up each item by its index. If you wanted to store items by key instead, you
    would use a dictionary.
  id: totrans-5564
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你学会了如何将项目存储在数组和字典中。要将项目存储在有序列表中，你可以使用数组，并通过索引查找每个项目。如果你想按键存储项目，则需要使用字典。
- en: Knowing about arrays and dictionaries and how to use them is a powerful building
    block for almost any programming language. Next we will learn about functions,
    another very powerful tool. Functions are blocks of code that you create and name
    to perform a specific job. After you have written a function, you can use its
    name to call it from almost anywhere in your program.
  id: totrans-5565
  prefs: []
  type: TYPE_NORMAL
  zh: 了解数组和字典以及如何使用它们，是几乎所有编程语言中强大的构建块。接下来，我们将学习函数，这是另一个非常强大的工具。函数是你创建并命名的代码块，用来执行特定的任务。在你编写了一个函数之后，你可以通过其名称在程序中的几乎任何地方调用它。
- en: Now you can make a delicious smoothie by adding the fruits and liquids arrays.
  id: totrans-5566
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你可以通过添加 fruits 和 liquids 数组制作美味的 smoothie。
- en: '![](Image00123.jpg)'
  id: totrans-5567
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00123.jpg)'
- en: The order of the ingredients in smoothie is the same as the order in fruits
    and liquids . If you created smoothie with liquids + fruits , then the liquids
    would come first.
  id: totrans-5568
  prefs: []
  type: TYPE_NORMAL
  zh: smoothie 中的配料顺序与 fruits 和 liquids 中的顺序相同。如果你使用 liquids + fruits 来创建 smoothie，那么液体会先放。
- en: 'You use the += operator to add an array to the end of your array. Add some
    whipped cream as follows for extra yumminess:'
  id: totrans-5569
  prefs: []
  type: TYPE_NORMAL
  zh: 你使用 += 运算符将一个数组添加到数组的末尾。可以如下添加一些鲜奶油，以增加美味：
- en: '![](Image00124.jpg)'
  id: totrans-5570
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00124.jpg)'
- en: Note that ["whipped cream"] is an array even though it has a single item in
    it. When you’re using += to append something to an array, you have to make sure
    you’re only trying to add another array. If you were to just write the string
    "whipped cream" without the square brackets around it, you would get an error.
  id: totrans-5571
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，["whipped cream"] 是一个数组，即使它只有一个项目。当你使用 += 将内容添加到数组时，你必须确保你只是在尝试添加另一个数组。如果你只是写了字符串
    "whipped cream" 而没有加上方括号，就会报错。
- en: '![Image](Image00125.jpg)'
  id: totrans-5572
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00125.jpg)'
- en: '**REMOVING ITEMS FROM AN ARRAY**'
  id: totrans-5573
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**从数组中移除项目**'
- en: 'There are several methods for removing items from an array. Let’s start by
    looking at the array’s removeLast() method. As you might have guessed from its
    name, removeLast() removes the last item from your array. Let’s try it out with
    a shoppingList array:'
  id: totrans-5574
  prefs: []
  type: TYPE_NORMAL
  zh: 有几种方法可以从数组中移除项目。我们首先来看看数组的 removeLast() 方法。正如你从其名字中可能猜到的，removeLast() 会移除数组中的最后一个项目。让我们尝试在
    shoppingList 数组上使用它：
- en: '![](Image00126.jpg)'
  id: totrans-5575
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00126.jpg)'
- en: Neat! Note that the removeLast() method returns the removed item, so you can
    store it in a new constant or variable if you want.
  id: totrans-5576
  prefs: []
  type: TYPE_NORMAL
  zh: 很棒！请注意，removeLast() 方法返回已移除的项目，因此如果你想，可以将其存储在一个新的常量或变量中。
- en: 'You can also remove an item from a specific index by using the remove(at:)
    method. Let’s say that your mom doesn’t want you buying any candy and takes that
    off the list:'
  id: totrans-5577
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以通过使用 `remove(at:)` 方法从指定的索引位置删除元素。假设你的妈妈不希望你买任何糖果，并将其从列表中删除：
- en: '![Image](Image00127.jpg)![](Image00128.jpg)'
  id: totrans-5578
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00127.jpg)![](Image00128.jpg)'
- en: Just like when we added an item to the middle of our array and all the items
    scooted over to make room, if you remove an item from the middle of an array,
    the rest of the items will scoot back to fill in that empty space. The "apples"
    item that was at index 3 is now at index 2, where "candy" was.
  id: totrans-5579
  prefs: []
  type: TYPE_NORMAL
  zh: 就像我们在数组中间添加元素时，所有的元素会自动向后移动以腾出空间一样，如果你从数组的中间删除元素，其余的元素会向前移动，填补那个空位。原本位于索引 3
    的“苹果”现在位于索引 2，原来的“糖果”位置。
- en: 'You can also remove all items from an array with removeAll() . Try entering
    this into your playground:'
  id: totrans-5580
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以使用 `removeAll()` 删除数组中的所有元素。试试在你的 Playground 中输入这个：
- en: '![](Image00129.jpg)'
  id: totrans-5581
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00129.jpg)'
- en: 'Note that trying to remove an item at an index that doesn’t exist will give
    you an error:'
  id: totrans-5582
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，尝试删除一个不存在的索引处的元素会导致错误：
- en: '![](Image00130.jpg)'
  id: totrans-5583
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00130.jpg)'
- en: Our array doesn’t have this many items (in fact, now it’s empty!), so this throws
    an error. We’ll also get an error if we use removeLast() on our empty array, because
    there’s nothing in it—there’s no last index at all! However, removeAll() is always
    safe to use, even on an empty array.
  id: totrans-5584
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的数组没有这么多元素（事实上，现在它是空的！），所以这会抛出一个错误。如果我们在空数组上使用 `removeLast()`，也会得到一个错误，因为数组中没有元素——根本没有最后一个索引！但是，`removeAll()`
    是完全安全的，即使是在空数组上也能使用。
- en: '**REPLACING ITEMS IN AN ARRAY**'
  id: totrans-5585
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**替换数组中的元素**'
- en: 'To replace an item in an array, you set the index of the array to the new value,
    as shown here:'
  id: totrans-5586
  prefs: []
  type: TYPE_NORMAL
  zh: 要在数组中替换元素，你需要将数组的索引设置为新的值，如下所示：
- en: '![](Image00131.jpg)'
  id: totrans-5587
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00131.jpg)'
- en: At ➊ , we replaced the item at index 2 (the third item) with "Unicorn" because
    magical animals count as favorite animals, too! At ➋ , we replaced the item at
    index 0 (the first item) with "Bearded dragon" . No, that’s not a real dragon—it’s
    just a lizard!
  id: totrans-5588
  prefs: []
  type: TYPE_NORMAL
  zh: 在 ➊ 处，我们将索引 2（第三个元素）的位置的元素替换为“独角兽”，因为神奇动物也是最喜欢的动物！在 ➋ 处，我们将索引 0（第一个元素）的位置的元素替换为“胡须龙”。不，那不是一条真正的龙——它只是一种蜥蜴！
- en: Like any time you’re working with array index numbers, you have to be sure an
    item exists in the array at that index before you change its value, or you will
    get an Index out of range error.
  id: totrans-5589
  prefs: []
  type: TYPE_NORMAL
  zh: 就像你在处理数组索引时一样，在修改某个索引的值之前，必须确保该索引处的元素存在，否则你会遇到“索引超出范围”的错误。
- en: '[Figure 6-3](text00016.html#ch06fig3) shows the error that occurs if you try
    to add "Standard poodle" using favoriteAnimals[3] = "Standard poodle" . To add
    an item to the end of an array, you should use the append(_:) method or += , as
    we covered in “[Adding Items to an Array](text00016.html#ch06lev2sec5) ” on [page
    70](text00016.html#page_70) .'
  id: totrans-5590
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 6-3](text00016.html#ch06fig3) 展示了如果你尝试通过 `favoriteAnimals[3] = "Standard
    poodle"` 来添加“标准贵宾犬”，会发生的错误。要将元素添加到数组的末尾，你应该使用 `append(_:)` 方法或 `+=`，正如我们在 “[向数组中添加元素](text00016.html#ch06lev2sec5)”
    中第 [70 页](text00016.html#page_70) 所讲的。'
- en: '![Image](Image00132.jpg)'
  id: totrans-5591
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00132.jpg)'
- en: '*Figure 6-3: Don’t try to replace a value at an index beyond the existing array.*'
  id: totrans-5592
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 6-3：不要尝试在超出现有数组范围的索引位置替换值。*'
- en: Now you know how to change arrays however you might need to. You can add items,
    take items away, or replace items. Next, we’ll look at how to use the properties
    of arrays to find out even more information about them.
  id: totrans-5593
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你知道如何根据需要修改数组了。你可以添加元素、删除元素或替换元素。接下来，我们将看看如何使用数组的属性来进一步了解数组的信息。
- en: '![Image](Image00133.jpg)'
  id: totrans-5594
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00133.jpg)'
- en: '**USING ARRAY PROPERTIES**'
  id: totrans-5595
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**使用数组属性**'
- en: In addition to methods like append(_:) and removeLast() , arrays also have *properties*
    . An array’s properties are variables or constants that contain some information
    about the array. Two really helpful properties that you might use are the Boolean
    property isEmpty and the integer property count .
  id: totrans-5596
  prefs: []
  type: TYPE_NORMAL
  zh: 除了像 `append(_:)` 和 `removeLast()` 这样的操作方法，数组还有 *属性*。数组的属性是包含数组信息的变量或常量。你可能会用到的两个非常有用的属性是布尔属性
    `isEmpty` 和整数属性 `count`。
- en: The isEmpty property is true or false depending on whether the array is empty,
    and the count property will tell you how many items are in that array.
  id: totrans-5597
  prefs: []
  type: TYPE_NORMAL
  zh: '`isEmpty` 属性根据数组是否为空返回 `true` 或 `false`，而 `count` 属性则告诉你数组中有多少个元素。'
- en: 'Check out how these two properties are used in the following if-else statement:'
  id: totrans-5598
  prefs: []
  type: TYPE_NORMAL
  zh: 查看以下 if-else 语句中如何使用这两个属性：
- en: '![Image](Image00134.jpg)'
  id: totrans-5599
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00134.jpg)'
- en: 'This if-else statement checks whether the array mySiblings is empty ➊ . If
    it is, then "I don''t have any siblings." is printed. But if there is something
    in the array, then the number of siblings that we have is printed: "I have 3 siblings."
    ➋ .'
  id: totrans-5600
  prefs: []
  type: TYPE_NORMAL
  zh: 这个 if-else 语句检查 mySiblings 数组是否为空 ➊ 。如果为空，则打印 "我没有兄弟姐妹。" 但是，如果数组中有内容，则会打印我们有多少个兄弟姐妹：“我有
    3 个兄弟姐妹。” ➋ 。
- en: '**LOOPING OVER AN ARRAY**'
  id: totrans-5601
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**循环遍历数组**'
- en: 'Sometimes when you’re working with arrays you might want to do something to
    every item in the array. You can use a for-in loop to do that! The following code
    will print every topping in a pizzaToppings array on a separate line:'
  id: totrans-5602
  prefs: []
  type: TYPE_NORMAL
  zh: 有时候，当你在处理数组时，你可能想对数组中的每个项做些事情。你可以使用 for-in 循环来实现！以下代码将在每一行打印 pizzaToppings 数组中的每个配料：
- en: '![Image](Image00135.jpg)'
  id: totrans-5603
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Image00135.jpg)'
- en: To write a for-in loop for the pizzaToppings array, we used the keyword for
    , followed by the constant topping , then the keyword in , and finally the name
    of our array, pizzaToppings . Then we put the statements that we want to run for
    each topping inside the braces of the for-in loop. The constant topping ➊ temporarily
    represents each pizza topping in the array as we loop through it. We could have
    chosen any name for this constant, but it’s a good idea to pick something that
    makes sense. You can see the output of this for-in loop in [Figure 6-4](text00016.html#ch06fig4)
    .
  id: totrans-5604
  prefs: []
  type: TYPE_NORMAL
  zh: 要为 pizzaToppings 数组编写一个 for-in 循环，我们使用了关键字 for ，后跟常量 topping ，然后是关键字 in ，最后是数组的名称
    pizzaToppings 。然后，我们将要为每个配料执行的语句放在 for-in 循环的花括号内。常量 topping ➊ 临时表示我们在循环过程中每个
    pizzaTopping 。我们本可以为这个常量选择任何名称，但选择一个有意义的名字是个好主意。你可以在 [图 6-4](text00016.html#ch06fig4)
    中看到这个 for-in 循环的输出。
- en: '![Image](Image00136.jpg)'
  id: totrans-5605
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Image00136.jpg)'
- en: '*Figure 6-4: Output of the example for-in loop*'
  id: totrans-5606
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 6-4：示例 for-in 循环的输出*'
- en: '![Image](Image00137.jpg)'
  id: totrans-5607
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Image00137.jpg)'
- en: 'Using for-in loops is great for printing every value in an array. If you’re
    working with numbers, you can even use them to perform math operations on each
    item, which makes for some speedy calculations! The following code takes an array
    of numbers and calculates the square for each (the square of a number is that
    number multiplied by itself):'
  id: totrans-5608
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 for-in 循环非常适合打印数组中的每个值。如果你在处理数字，还可以使用它们对每个项目进行数学运算，这使得计算速度更快！以下代码获取一个数字数组，并计算每个数字的平方（一个数字的平方是该数字乘以它本身）：
- en: '![Image](Image00138.jpg)'
  id: totrans-5609
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Image00138.jpg)'
- en: '[Figure 6-5](text00016.html#ch06fig5) shows the results.'
  id: totrans-5610
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 6-5](text00016.html#ch06fig5) 显示了结果。'
- en: '![Image](Image00139.jpg)'
  id: totrans-5611
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Image00139.jpg)'
- en: '*Figure 6-5: Printing the squares for each number in the myNumbers array*'
  id: totrans-5612
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 6-5：打印 myNumbers 数组中每个数字的平方*'
- en: '**DICTIONARIES ARE KEY!**'
  id: totrans-5613
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**字典是关键！**'
- en: A *dictionary* is also a collection of values, but instead of an ordered index,
    each value has its own *key* . Because there’s no index, the values are not stored
    in any particular order. To access values in a dictionary, you look them up by
    their key.
  id: totrans-5614
  prefs: []
  type: TYPE_NORMAL
  zh: '*字典* 也是一个值的集合，但不同于有序的索引，每个值都有自己的 *键* 。由于没有索引，值并不是以特定顺序存储的。要访问字典中的值，你需要通过其键查找。'
- en: A key must be unique. You can’t have the same key more than once in the same
    dictionary. If there were two identical keys and you asked the computer to give
    you the value for one of them, the computer wouldn’t know which one to choose!
  id: totrans-5615
  prefs: []
  type: TYPE_NORMAL
  zh: 键必须是唯一的。你不能在同一个字典中使用相同的键多次。如果有两个相同的键，并且你要求计算机给你其中一个的值，计算机将不知道选择哪个！
- en: Let’s take a look at how to make a dictionary and write keys that will help
    you find all the information you need.
  id: totrans-5616
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如何创建一个字典，并编写帮助你找到所需所有信息的键。
- en: '![Image](Image00140.jpg)'
  id: totrans-5617
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Image00140.jpg)'
- en: '**INITIALIZING A DICTIONARY**'
  id: totrans-5618
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**初始化字典**'
- en: 'To create and initialize a dictionary, first write var and the name of your
    dictionary. Then write the keys and corresponding values inside a pair of square
    brackets, similar to an array. Let’s create a dictionary to store the names of
    a few US states. The key for each state will be its two-letter abbreviation:'
  id: totrans-5619
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建并初始化一个字典，首先写 var 和字典的名称。然后将键及其对应的值写在一对方括号中，类似于数组。让我们创建一个字典，用来存储一些美国州的名称。每个州的键将是其两个字母的缩写：
- en: '![](Image00141.jpg)'
  id: totrans-5620
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00141.jpg)'
- en: As you can see, there’s a colon between each key and its value, and the key/value
    pairs are separated by commas.
  id: totrans-5621
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，每个键和值之间有一个冒号，并且键/值对之间用逗号分隔。
- en: Dictionaries are different from arrays in that they are *unordered* . Because
    of that, it’s likely that the order of the states that you see in your results
    pane ➋ is different from the order in which you entered your states ➊ . It might
    even be different than the order that’s printed in this book!
  id: totrans-5622
  prefs: []
  type: TYPE_NORMAL
  zh: 字典与数组的不同之处在于它们是*无序的*。因此，你在结果面板中看到的州的顺序 ➋ 可能与你输入的州的顺序 ➊ 不同。甚至可能与本书中打印的顺序不同！
- en: As with arrays, you can use var to make a mutable dictionary or use let to make
    an immutable dictionary.
  id: totrans-5623
  prefs: []
  type: TYPE_NORMAL
  zh: 和数组一样，你可以使用 var 来创建一个可变字典，或者使用 let 来创建一个不可变字典。
- en: 'In Swift, all of the keys of a dictionary must be the same type, and all of
    the values of a dictionary must also be the same type, but the key type doesn’t
    have to match the value type. For example, if you wanted to store a collection
    of fractions, you could use doubles for the keys and strings for the values:'
  id: totrans-5624
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Swift 中，字典的所有键必须是相同类型的，字典的所有值也必须是相同类型的，但键的类型不必与值的类型相同。例如，如果你想存储一个分数集合，你可以使用双精度浮点数作为键，字符串作为值：
- en: '![](Image00142.jpg)'
  id: totrans-5625
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00142.jpg)'
- en: In this dictionary, all of the keys must be doubles, and all of the values must
    be strings. Again, you’ll see that the order of the numbers in the results pane
    can be quite different from the order in which you wrote the fractions in your
    dictionary. This is fine because you don’t need to know the order to access anything.
    You can find any item that you need by its key. Let’s see how!
  id: totrans-5626
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个字典中，所有的键必须是双精度浮点数，所有的值必须是字符串。同样，你会发现结果面板中数字的顺序可能与在字典中写入分数的顺序大不相同。这没关系，因为你不需要知道顺序就可以访问任何内容。你可以通过键来查找你需要的任何项。让我们来看看！
- en: '**ACCESSING VALUES IN A DICTIONARY**'
  id: totrans-5627
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**访问字典中的值**'
- en: 'Looking up a value in a dictionary is similar to how you access a value in
    an array except that you use a key inside the square brackets instead of an index,
    like this: usStates["TX"] .'
  id: totrans-5628
  prefs: []
  type: TYPE_NORMAL
  zh: 在字典中查找一个值类似于如何在数组中访问一个值，只不过你需要在方括号内使用键，而不是索引，像这样：usStates["TX"]。
- en: There is a big difference, however, in how Swift returns the values from a dictionary.
    When you access a value at an index of an array, you are simply given the value.
    When you access a value with a key in a dictionary, you are given an optional.
  id: totrans-5629
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在 Swift 中，从字典中返回值有一个很大的区别。当你访问数组中的某个索引时，你只是得到该值。当你通过字典中的键访问某个值时，你得到的是一个可选项。
- en: In [Chapter 5](text00015.html#ch05) , you learned that optionals might contain
    a value or might be nil . The reason Swift returns optionals when you’re looking
    up items in a dictionary is that the key you used might not exist in the dictionary,
    in which case there’s no value to access. Trying to access a value that doesn’t
    exist would give you a big fat error! To avoid that problem, Swift returns optionals.
    That means you need to unwrap any value you get out of a dictionary before you
    can do anything with it.
  id: totrans-5630
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第5章](text00015.html#ch05)中，你学到了可选项可能包含一个值，也可能是 nil。Swift 在查找字典中的项时返回可选项的原因是你使用的键可能在字典中不存在，在这种情况下就没有值可以访问。试图访问一个不存在的值会导致一个大错误！为避免这个问题，Swift
    返回可选项。这意味着你需要解包从字典中取出的任何值，才能对其进行操作。
- en: 'To unwrap an optional, first you check whether it exists using an if-let statement,
    just like we did in [Chapter 5](text00015.html#ch05) . The following code shows
    you how to get a value out of a dictionary:'
  id: totrans-5631
  prefs: []
  type: TYPE_NORMAL
  zh: 要解包一个可选项，首先使用 if-let 语句检查它是否存在，就像我们在[第5章](text00015.html#ch05)中所做的那样。以下代码展示了如何从字典中获取一个值：
- en: '![Image](Image00143.jpg)'
  id: totrans-5632
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Image00143.jpg)'
- en: To retrieve "Texas" from the dictionary, we use if let to set a constant loneStarState
    to usStates["TX"] ➊ . Because we have this state in our dictionary, the line I
    have Texas in my dictionary. is printed. Next we try to access a state that is
    not in our dictionary by using the key usStates["FL"] ➋ . Thankfully, because
    we used an if-let statement, the program won’t crash when the computer can’t find
    this state. Instead, I don't have that state in my dictionary. is printed.
  id: totrans-5633
  prefs: []
  type: TYPE_NORMAL
  zh: 为了从字典中检索“德克萨斯州”，我们使用 if let 将常量 loneStarState 设置为 usStates["TX"] ➊。因为我们在字典中有这个州，所以会打印出“I
    have Texas in my dictionary.”。接下来，我们尝试通过使用键 usStates["FL"] ➋ 来访问一个不在字典中的州。幸运的是，由于我们使用了
    if-let 语句，当计算机找不到该州时，程序不会崩溃。相反，会打印出“I don't have that state in my dictionary.”。
- en: '**ADDING ITEMS TO A DICTIONARY**'
  id: totrans-5634
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**向字典添加项**'
- en: 'To add an item to a dictionary, first write the name of your dictionary and
    assign the new item to the key you want it to have in the dictionary. Let’s add
    "Minnesota" to our usStates dictionary:'
  id: totrans-5635
  prefs: []
  type: TYPE_NORMAL
  zh: 要向字典添加一项，首先写出字典的名称，并将新项赋给你希望它在字典中对应的键。我们来将“Minnesota”添加到我们的usStates字典中：
- en: '![](Image00144.jpg)'
  id: totrans-5636
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00144.jpg)'
- en: 'Now when you look at usStates , you’ll see that it’s updated to ["MN": "Minnesota",
    "WA": "Washington", "MA": "Massachusetts", "TX": "Texas"] . Remember, because
    you don’t have to rely on indices, your new dictionary item might appear anywhere
    in the dictionary.'
  id: totrans-5637
  prefs: []
  type: TYPE_NORMAL
  zh: '现在，当你查看usStates时，你会发现它已经更新为["MN": "Minnesota", "WA": "Washington", "MA": "Massachusetts",
    "TX": "Texas"]。记住，因为你不需要依赖索引，所以新的字典项可能出现在字典的任何位置。'
- en: '**REMOVING ITEMS FROM A DICTIONARY**'
  id: totrans-5638
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**从字典中删除项**'
- en: Removing an item from a dictionary is quite simple; you do so by setting the
    value to nil . Because the values in dictionaries are returned as optionals, you
    don’t have to worry about nil causing any problems in your dictionary.
  id: totrans-5639
  prefs: []
  type: TYPE_NORMAL
  zh: 从字典中删除一个项非常简单；你只需要将该值设置为nil。由于字典中的值是可选的，你无需担心nil会在字典中造成任何问题。
- en: '![](Image00145.jpg)'
  id: totrans-5640
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00145.jpg)'
- en: 'You can see that after you remove the value at the key "MA" , usStates is updated
    to ["MN": "Minnesota", "WA": "Washington", "TX": "Texas"] . Remember that nil
    is special and means that there’s no value at all. That’s why you don’t see "MA":
    nil in our dictionary.'
  id: totrans-5641
  prefs: []
  type: TYPE_NORMAL
  zh: '你可以看到，当你删除“MA”对应的值后，usStates被更新为["MN": "Minnesota", "WA": "Washington", "TX":
    "Texas"]。记住，nil是特殊的，表示没有任何值。因此，在我们的字典中不会看到"MA": nil。'
- en: '**REPLACING ITEMS IN A DICTIONARY**'
  id: totrans-5642
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**替换字典中的项**'
- en: 'Replacing an item in a dictionary is also easy. It works the same was as replacing
    an item in an array. You just set the item that you want to replace to something
    else. Say you create a dictionary of fruit colors:'
  id: totrans-5643
  prefs: []
  type: TYPE_NORMAL
  zh: 替换字典中的一项也很简单。它和替换数组中的项一样，只需将你想替换的项设置为其他值。假设你创建了一个水果颜色的字典：
- en: '![](Image00146.jpg)'
  id: totrans-5644
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00146.jpg)'
- en: At first we had the value "apple" for "red" , but then we decided that "raspberry"
    is a better fruit to use since sometimes apples are green or yellow. To replace
    "apple" with "raspberry" , we set colorFruits["red"] to its new value ➊ .
  id: totrans-5645
  prefs: []
  type: TYPE_NORMAL
  zh: 最初，我们将“red”对应的值设为“apple”，但后来我们决定使用“raspberry”更合适，因为有时候苹果是绿色或黄色的。为了将“apple”替换为“raspberry”，我们将colorFruits["red"]设置为其新值➊。
- en: You may remember that this is the same way we entered a new value into a dictionary.
    If the key already exists in the dictionary, then the value for that key is replaced.
    If the key doesn’t already exist, then the new key/value pair will be added to
    the dictionary.
  id: totrans-5646
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能记得，这正是我们将新值添加到字典中的方式。如果键已经存在于字典中，那么该键对应的值会被替换。如果键还不存在，那么新的键/值对将被添加到字典中。
- en: '![Image](Image00147.jpg)'
  id: totrans-5647
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Image00147.jpg)'
- en: '**USING DICTIONARY PROPERTIES**'
  id: totrans-5648
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**使用字典属性**'
- en: 'Like an array, a dictionary also has an isEmpty property and a count property.
    For example, the following code shows how you can use the isEmpty property to
    check if a dictionary is empty, and if it isn’t empty, the count property checks
    how many items you have. Imagine you have a basket of fruit for sale. You can
    use these properties to help you keep track of everything:'
  id: totrans-5649
  prefs: []
  type: TYPE_NORMAL
  zh: 像数组一样，字典也有isEmpty属性和count属性。例如，以下代码展示了如何使用isEmpty属性检查字典是否为空，如果不为空，则count属性检查字典中有多少项。假设你有一个水果篮在售。你可以使用这些属性来帮助你追踪所有内容：
- en: '![Image](Image00148.jpg)'
  id: totrans-5650
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Image00148.jpg)'
- en: 'A dictionary also has two special properties: keys , which contains all of
    the dictionary’s keys, and values , which contains all of its values. We’ll use
    these two properties when we loop through the dictionary.'
  id: totrans-5651
  prefs: []
  type: TYPE_NORMAL
  zh: 字典还有两个特殊属性：keys，包含字典的所有键，以及values，包含字典的所有值。我们将在遍历字典时使用这两个属性。
- en: Let’s write some code that loops through our fruit baskets and prints the price
    of each fruit.
  id: totrans-5652
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们写些代码，遍历我们的水果篮并打印每个水果的价格。
- en: '**LOOPING OVER A DICTIONARY**'
  id: totrans-5653
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**遍历字典**'
- en: 'You can loop through a dictionary using a for-in loop. Because each item has
    a key and a value, you can do this in two different ways. This is how to loop
    through a dictionary using its keys:'
  id: totrans-5654
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用for-in循环遍历字典。因为每个项都有一个键和值，所以你可以用两种不同的方式来做。下面是通过字典的键来遍历字典的方式：
- en: '![Image](Image00149.jpg)'
  id: totrans-5655
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Image00149.jpg)'
- en: Here we use the dictionary’s keys property ➊ to loop through fruitBasket and
    print its contents. We start by writing the keyword for , followed by a constant
    name fruit for the dictionary key, the keyword in , the dictionary name, a period,
    and keys .
  id: totrans-5656
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们使用字典的 keys 属性 ➊ 来遍历 fruitBasket，并打印其内容。我们从写关键字 for 开始，接着是字典键的常量名 fruit，关键字
    in，字典名称，一个句点，和 keys。
- en: Inside the braces of our for-in loop, we have access to both the key, which
    we call fruit ➋ , and the value at that key when we force-unwrap its contents
    with fruitBasket[fruit]! ➌ . That value will be the fruit’s price.
  id: totrans-5657
  prefs: []
  type: TYPE_NORMAL
  zh: 在 for-in 循环的大括号内，我们可以访问键（我们称之为 fruit ➋），以及通过强制解包其内容（fruitBasket[fruit]! ➌）得到的该键的值。这个值将是水果的价格。
- en: In this case, it’s safe to force-unwrap the value using an exclamation point
    because we know that the fruit key we’re using is definitely inside the dictionary.
  id: totrans-5658
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，使用感叹号强制解包值是安全的，因为我们知道我们使用的 fruit 键肯定在字典中。
- en: Any code we put inside the for-in loop will run once for every key in our dictionary.
    So you should see the print statement display three times.
  id: totrans-5659
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在 for-in 循环中放入的任何代码都会针对字典中的每个键执行一次。所以你应该看到打印语句会显示三次。
- en: 'We can also loop through the dictionary using its values property:'
  id: totrans-5660
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以通过字典的 values 属性来遍历字典：
- en: '![Image](Image00150.jpg)'
  id: totrans-5661
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00150.jpg)'
- en: We use the same style of for-in loop, but now we use a constant to refer to
    each value, which we call price , in the values property. When looping through
    values, we don’t have access to the keys from inside the loop.
  id: totrans-5662
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用相同的 for-in 循环样式，但现在我们使用常量来引用每个值，我们称其为 price，位于 values 属性中。在循环遍历 values 时，我们无法访问循环内部的键。
- en: Another difference to note is that price is not an optional because it’s accessed
    directly as a value in the fruitBasket dictionary. That means we don’t have to
    unwrap it. You should still see the print statement printed three times. [Figure
    6-6](text00016.html#ch06fig6) shows the output of both loops.
  id: totrans-5663
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个需要注意的区别是，price 不是可选的，因为它直接作为值访问在 fruitBasket 字典中。这意味着我们不需要解包它。你仍然应该看到打印语句会显示三次。[图
    6-6](text00016.html#ch06fig6) 显示了两个循环的输出。
- en: '![Image](Image00151.jpg)'
  id: totrans-5664
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00151.jpg)'
- en: '*Figure 6-6: Looping through the keys and values of a dictionary with a for-in
    loop*'
  id: totrans-5665
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 6-6：使用 for-in 循环遍历字典的键和值*'
- en: The order of your results might be slightly different from ours. That’s because
    the items in a dictionary aren’t in a numbered order like they are in an array!
    And because the order is not guaranteed, you might see a different order printed
    if you run the same code again.
  id: totrans-5666
  prefs: []
  type: TYPE_NORMAL
  zh: 你的结果顺序可能与我们的略有不同。这是因为字典中的项目不像数组那样按编号排序！并且由于顺序无法保证，如果你再次运行相同的代码，可能会看到不同的顺序。
- en: '**WHAT YOU LEARNED**'
  id: totrans-5667
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**你学到了什么**'
- en: In this chapter, you learned how to store collections of items in an array and
    in a dictionary. To store items in an ordered list, you would use an array and
    look up each item by its index. If you wanted to store items by key instead, you
    would use a dictionary.
  id: totrans-5668
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你学习了如何将项目集合存储在数组和字典中。要将项目存储在有序列表中，你需要使用数组，并通过索引查找每个项目。如果你想通过键存储项目，则应使用字典。
- en: Knowing about arrays and dictionaries and how to use them is a powerful building
    block for almost any programming language. Next we will learn about functions,
    another very powerful tool. Functions are blocks of code that you create and name
    to perform a specific job. After you have written a function, you can use its
    name to call it from almost anywhere in your program.
  id: totrans-5669
  prefs: []
  type: TYPE_NORMAL
  zh: 了解数组和字典以及如何使用它们，是几乎所有编程语言中的一个强大构建块。接下来我们将学习函数，这是另一个非常强大的工具。函数是你创建并命名的一段代码，用来执行特定的任务。写好函数后，你可以在程序中的几乎任何地方通过函数名调用它。
- en: '![](Image00123.jpg)'
  id: totrans-5670
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00123.jpg)'
- en: The order of the ingredients in smoothie is the same as the order in fruits
    and liquids . If you created smoothie with liquids + fruits , then the liquids
    would come first.
  id: totrans-5671
  prefs: []
  type: TYPE_NORMAL
  zh: 奶昔中配料的顺序与水果和液体中的顺序相同。如果你先将液体与水果混合制成奶昔，那么液体会先放入。
- en: 'You use the += operator to add an array to the end of your array. Add some
    whipped cream as follows for extra yumminess:'
  id: totrans-5672
  prefs: []
  type: TYPE_NORMAL
  zh: 你使用 += 操作符将一个数组添加到另一个数组的末尾。为了让味道更加美味，可以按如下方式加入一些奶油：
- en: '![](Image00124.jpg)'
  id: totrans-5673
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00124.jpg)'
- en: Note that ["whipped cream"] is an array even though it has a single item in
    it. When you’re using += to append something to an array, you have to make sure
    you’re only trying to add another array. If you were to just write the string
    "whipped cream" without the square brackets around it, you would get an error.
  id: totrans-5674
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，["鲜奶油"] 是一个数组，尽管它只有一个项。当你使用 += 来向数组添加内容时，必须确保你只是在添加另一个数组。如果你只是写“鲜奶油”这个字符串而没有加上方括号，你会遇到错误。
- en: '![Image](Image00125.jpg)'
  id: totrans-5675
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Image00125.jpg)'
- en: '**REMOVING ITEMS FROM AN ARRAY**'
  id: totrans-5676
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**从数组中移除项**'
- en: 'There are several methods for removing items from an array. Let’s start by
    looking at the array’s removeLast() method. As you might have guessed from its
    name, removeLast() removes the last item from your array. Let’s try it out with
    a shoppingList array:'
  id: totrans-5677
  prefs: []
  type: TYPE_NORMAL
  zh: 有几种方法可以从数组中移除项。让我们先来看一下数组的 removeLast() 方法。正如你从它的名字可以猜到的，removeLast() 会移除数组中的最后一项。让我们通过一个
    shoppingList 数组来试试：
- en: '![](Image00126.jpg)'
  id: totrans-5678
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00126.jpg)'
- en: Neat! Note that the removeLast() method returns the removed item, so you can
    store it in a new constant or variable if you want.
  id: totrans-5679
  prefs: []
  type: TYPE_NORMAL
  zh: 很棒！请注意，removeLast() 方法会返回被移除的项，因此如果需要，你可以将它存储在一个新的常量或变量中。
- en: 'You can also remove an item from a specific index by using the remove(at:)
    method. Let’s say that your mom doesn’t want you buying any candy and takes that
    off the list:'
  id: totrans-5680
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以使用 remove(at:) 方法从指定的索引移除一项。假设你的妈妈不想让你买糖果，于是将其从清单中移除：
- en: '![Image](Image00127.jpg)![](Image00128.jpg)'
  id: totrans-5681
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Image00127.jpg)![](Image00128.jpg)'
- en: Just like when we added an item to the middle of our array and all the items
    scooted over to make room, if you remove an item from the middle of an array,
    the rest of the items will scoot back to fill in that empty space. The "apples"
    item that was at index 3 is now at index 2, where "candy" was.
  id: totrans-5682
  prefs: []
  type: TYPE_NORMAL
  zh: 就像我们将项添加到数组中间并让所有项向右移动腾出空间一样，如果你从数组中间移除一个项，其他项将会向左移动填补空缺。原本在索引3的“苹果”项现在出现在索引2的位置，即“糖果”所在的位置。
- en: 'You can also remove all items from an array with removeAll() . Try entering
    this into your playground:'
  id: totrans-5683
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以使用 removeAll() 方法移除数组中的所有项。试试将这个输入到你的 Playground 中：
- en: '![](Image00129.jpg)'
  id: totrans-5684
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00129.jpg)'
- en: 'Note that trying to remove an item at an index that doesn’t exist will give
    you an error:'
  id: totrans-5685
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，尝试移除一个不存在的索引处的项会导致错误：
- en: '![](Image00130.jpg)'
  id: totrans-5686
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00130.jpg)'
- en: Our array doesn’t have this many items (in fact, now it’s empty!), so this throws
    an error. We’ll also get an error if we use removeLast() on our empty array, because
    there’s nothing in it—there’s no last index at all! However, removeAll() is always
    safe to use, even on an empty array.
  id: totrans-5687
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的数组没有这么多项（事实上，现在它已经空了！），所以这会抛出错误。如果我们在空数组上使用 removeLast()，也会抛出错误，因为数组里什么都没有——根本没有最后一个索引！但是，removeAll()
    即使在空数组上使用也是安全的。
- en: '**REPLACING ITEMS IN AN ARRAY**'
  id: totrans-5688
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**替换数组中的项**'
- en: 'To replace an item in an array, you set the index of the array to the new value,
    as shown here:'
  id: totrans-5689
  prefs: []
  type: TYPE_NORMAL
  zh: 要替换数组中的项，你只需将数组的索引设置为新的值，如下所示：
- en: '![](Image00131.jpg)'
  id: totrans-5690
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00131.jpg)'
- en: At ➊ , we replaced the item at index 2 (the third item) with "Unicorn" because
    magical animals count as favorite animals, too! At ➋ , we replaced the item at
    index 0 (the first item) with "Bearded dragon" . No, that’s not a real dragon—it’s
    just a lizard!
  id: totrans-5691
  prefs: []
  type: TYPE_NORMAL
  zh: 在➊，我们将索引为2（第三个元素）的项替换为“独角兽”，因为魔法动物也算是最喜欢的动物！在➋，我们将索引为0（第一个元素）的项替换为“胡须龙”。不，那不是一条真正的龙——它只是一只蜥蜴！
- en: Like any time you’re working with array index numbers, you have to be sure an
    item exists in the array at that index before you change its value, or you will
    get an Index out of range error.
  id: totrans-5692
  prefs: []
  type: TYPE_NORMAL
  zh: 就像你在处理数组索引时一样，必须确保该索引位置存在项，才能修改它的值，否则你会遇到“索引超出范围”的错误。
- en: '[Figure 6-3](text00016.html#ch06fig3) shows the error that occurs if you try
    to add "Standard poodle" using favoriteAnimals[3] = "Standard poodle" . To add
    an item to the end of an array, you should use the append(_:) method or += , as
    we covered in “[Adding Items to an Array](text00016.html#ch06lev2sec5) ” on [page
    70](text00016.html#page_70) .'
  id: totrans-5693
  prefs: []
  type: TYPE_NORMAL
  zh: '[图6-3](text00016.html#ch06fig3)展示了如果你尝试通过 favoriteAnimals[3] = "标准贵宾犬" 来添加“标准贵宾犬”，会发生的错误。要将一项添加到数组的末尾，你应该使用
    append(_:) 方法或 += ，我们在“[向数组中添加项](text00016.html#ch06lev2sec5)”中介绍了此方法，在[第70页](text00016.html#page_70)有详细说明。'
- en: '![Image](Image00132.jpg)'
  id: totrans-5694
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Image00132.jpg)'
- en: '*Figure 6-3: Don’t try to replace a value at an index beyond the existing array.*'
  id: totrans-5695
  prefs: []
  type: TYPE_NORMAL
  zh: '*图6-3：不要尝试替换一个索引超出现有数组范围的值。*'
- en: Now you know how to change arrays however you might need to. You can add items,
    take items away, or replace items. Next, we’ll look at how to use the properties
    of arrays to find out even more information about them.
  id: totrans-5696
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你知道了如何根据需要更改数组。你可以添加项目、移除项目或替换项目。接下来，我们将探讨如何使用数组的属性来获取更多关于它们的信息。
- en: '![Image](Image00133.jpg)'
  id: totrans-5697
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00133.jpg)'
- en: '**USING ARRAY PROPERTIES**'
  id: totrans-5698
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**使用数组属性**'
- en: In addition to methods like append(_:) and removeLast() , arrays also have *properties*
    . An array’s properties are variables or constants that contain some information
    about the array. Two really helpful properties that you might use are the Boolean
    property isEmpty and the integer property count .
  id: totrans-5699
  prefs: []
  type: TYPE_NORMAL
  zh: 除了像 append(_:) 和 removeLast() 这样的方法，数组还有*属性*。数组的属性是包含关于数组信息的变量或常量。你可能会使用的两个非常有用的属性是布尔类型属性
    isEmpty 和整数类型属性 count。
- en: The isEmpty property is true or false depending on whether the array is empty,
    and the count property will tell you how many items are in that array.
  id: totrans-5700
  prefs: []
  type: TYPE_NORMAL
  zh: isEmpty 属性的值为 true 或 false，取决于数组是否为空，而 count 属性会告诉你数组中有多少项。
- en: 'Check out how these two properties are used in the following if-else statement:'
  id: totrans-5701
  prefs: []
  type: TYPE_NORMAL
  zh: 请查看下面的 if-else 语句中如何使用这两个属性：
- en: '![Image](Image00134.jpg)'
  id: totrans-5702
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00134.jpg)'
- en: 'This if-else statement checks whether the array mySiblings is empty ➊ . If
    it is, then "I don''t have any siblings." is printed. But if there is something
    in the array, then the number of siblings that we have is printed: "I have 3 siblings."
    ➋ .'
  id: totrans-5703
  prefs: []
  type: TYPE_NORMAL
  zh: 这个 if-else 语句检查数组 mySiblings 是否为空 ➊。如果为空，则打印 "我没有兄弟姐妹。"。如果数组中有内容，则打印我们拥有的兄弟姐妹数量："我有
    3 个兄弟姐妹。" ➋。
- en: '**LOOPING OVER AN ARRAY**'
  id: totrans-5704
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**遍历数组**'
- en: 'Sometimes when you’re working with arrays you might want to do something to
    every item in the array. You can use a for-in loop to do that! The following code
    will print every topping in a pizzaToppings array on a separate line:'
  id: totrans-5705
  prefs: []
  type: TYPE_NORMAL
  zh: 有时在处理数组时，你可能想对数组中的每个项目做一些操作。你可以使用 for-in 循环来完成！下面的代码将逐行打印 pizzaToppings 数组中的每个配料：
- en: '![Image](Image00135.jpg)'
  id: totrans-5706
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00135.jpg)'
- en: To write a for-in loop for the pizzaToppings array, we used the keyword for
    , followed by the constant topping , then the keyword in , and finally the name
    of our array, pizzaToppings . Then we put the statements that we want to run for
    each topping inside the braces of the for-in loop. The constant topping ➊ temporarily
    represents each pizza topping in the array as we loop through it. We could have
    chosen any name for this constant, but it’s a good idea to pick something that
    makes sense. You can see the output of this for-in loop in [Figure 6-4](text00016.html#ch06fig4)
    .
  id: totrans-5707
  prefs: []
  type: TYPE_NORMAL
  zh: 为 pizzaToppings 数组编写一个 for-in 循环时，我们使用了关键字 for，接着是常量 topping，然后是关键字 in，最后是我们数组的名称
    pizzaToppings。接着我们将想要在每个配料上执行的语句放入 for-in 循环的花括号内。常量 topping ➊ 在我们遍历数组时临时表示数组中的每个比萨配料。我们本可以选择任何名字来命名这个常量，但最好选择一个有意义的名字。你可以在[图
    6-4](text00016.html#ch06fig4)中看到这个 for-in 循环的输出。
- en: '![Image](Image00136.jpg)'
  id: totrans-5708
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00136.jpg)'
- en: '*Figure 6-4: Output of the example for-in loop*'
  id: totrans-5709
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 6-4：示例 for-in 循环的输出*'
- en: '![Image](Image00137.jpg)'
  id: totrans-5710
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00137.jpg)'
- en: 'Using for-in loops is great for printing every value in an array. If you’re
    working with numbers, you can even use them to perform math operations on each
    item, which makes for some speedy calculations! The following code takes an array
    of numbers and calculates the square for each (the square of a number is that
    number multiplied by itself):'
  id: totrans-5711
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 for-in 循环非常适合打印数组中的每个值。如果你在处理数字，你甚至可以用它们对每个项目执行数学运算，这样就能快速计算！以下代码接收一个数字数组，并计算每个数字的平方（数字的平方是该数字与自身相乘）：
- en: '![Image](Image00138.jpg)'
  id: totrans-5712
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00138.jpg)'
- en: '[Figure 6-5](text00016.html#ch06fig5) shows the results.'
  id: totrans-5713
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 6-5](text00016.html#ch06fig5) 显示了结果。'
- en: '![Image](Image00139.jpg)'
  id: totrans-5714
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00139.jpg)'
- en: '*Figure 6-5: Printing the squares for each number in the myNumbers array*'
  id: totrans-5715
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 6-5：打印 myNumbers 数组中每个数字的平方*'
- en: '**DICTIONARIES ARE KEY!**'
  id: totrans-5716
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**字典是关键！**'
- en: A *dictionary* is also a collection of values, but instead of an ordered index,
    each value has its own *key* . Because there’s no index, the values are not stored
    in any particular order. To access values in a dictionary, you look them up by
    their key.
  id: totrans-5717
  prefs: []
  type: TYPE_NORMAL
  zh: '*字典*也是一个值的集合，不过与有序索引不同，每个值都有自己的*键*。由于没有索引，值并不会以任何特定的顺序存储。要访问字典中的值，你需要通过其键来查找。'
- en: A key must be unique. You can’t have the same key more than once in the same
    dictionary. If there were two identical keys and you asked the computer to give
    you the value for one of them, the computer wouldn’t know which one to choose!
  id: totrans-5718
  prefs: []
  type: TYPE_NORMAL
  zh: 键必须是唯一的。你不能在同一个字典中多次使用相同的键。如果有两个相同的键，并且你请求计算机给出其中一个的值，计算机将无法确定选择哪一个！
- en: Let’s take a look at how to make a dictionary and write keys that will help
    you find all the information you need.
  id: totrans-5719
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看如何创建一个字典，并编写有助于你找到所有所需信息的键。
- en: '![Image](Image00140.jpg)'
  id: totrans-5720
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00140.jpg)'
- en: '**INITIALIZING A DICTIONARY**'
  id: totrans-5721
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**初始化字典**'
- en: 'To create and initialize a dictionary, first write var and the name of your
    dictionary. Then write the keys and corresponding values inside a pair of square
    brackets, similar to an array. Let’s create a dictionary to store the names of
    a few US states. The key for each state will be its two-letter abbreviation:'
  id: totrans-5722
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建和初始化一个字典，首先写上 `var` 和字典的名称。然后在一对方括号内写上键和对应的值，类似于数组。让我们创建一个字典，用来存储一些美国州的名称。每个州的键将是它的两位字母缩写：
- en: '![](Image00141.jpg)'
  id: totrans-5723
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00141.jpg)'
- en: As you can see, there’s a colon between each key and its value, and the key/value
    pairs are separated by commas.
  id: totrans-5724
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，每个键和值之间都有一个冒号，并且键值对之间用逗号分隔。
- en: Dictionaries are different from arrays in that they are *unordered* . Because
    of that, it’s likely that the order of the states that you see in your results
    pane ➋ is different from the order in which you entered your states ➊ . It might
    even be different than the order that’s printed in this book!
  id: totrans-5725
  prefs: []
  type: TYPE_NORMAL
  zh: 字典不同于数组，因为它们是 *无序* 的。因此，你在结果面板中看到的州的顺序 ➋ 可能与你输入州时的顺序 ➊ 不同，甚至可能与本书中打印的顺序不同！
- en: As with arrays, you can use var to make a mutable dictionary or use let to make
    an immutable dictionary.
  id: totrans-5726
  prefs: []
  type: TYPE_NORMAL
  zh: 和数组一样，你可以使用 `var` 来创建一个可变字典，或者使用 `let` 来创建一个不可变字典。
- en: 'In Swift, all of the keys of a dictionary must be the same type, and all of
    the values of a dictionary must also be the same type, but the key type doesn’t
    have to match the value type. For example, if you wanted to store a collection
    of fractions, you could use doubles for the keys and strings for the values:'
  id: totrans-5727
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Swift 中，字典的所有键必须是相同类型，字典的所有值也必须是相同类型，但键的类型不必与值的类型相匹配。例如，如果你想存储一个分数集合，你可以使用双精度浮点数作为键，字符串作为值：
- en: '![](Image00142.jpg)'
  id: totrans-5728
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00142.jpg)'
- en: In this dictionary, all of the keys must be doubles, and all of the values must
    be strings. Again, you’ll see that the order of the numbers in the results pane
    can be quite different from the order in which you wrote the fractions in your
    dictionary. This is fine because you don’t need to know the order to access anything.
    You can find any item that you need by its key. Let’s see how!
  id: totrans-5729
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个字典中，所有的键必须是双精度浮点数（doubles），所有的值必须是字符串（strings）。再次提醒，你会发现结果面板中的数字顺序可能和你在字典中书写分数的顺序有很大的不同。这没关系，因为你不需要知道顺序就能访问任何内容。你可以通过键来找到你需要的任何项。让我们来看一下！
- en: '**ACCESSING VALUES IN A DICTIONARY**'
  id: totrans-5730
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**访问字典中的值**'
- en: 'Looking up a value in a dictionary is similar to how you access a value in
    an array except that you use a key inside the square brackets instead of an index,
    like this: usStates["TX"] .'
  id: totrans-5731
  prefs: []
  type: TYPE_NORMAL
  zh: 在字典中查找一个值的方式与在数组中访问值类似，只不过你需要在方括号内使用键，而不是索引，像这样：usStates["TX"]。
- en: There is a big difference, however, in how Swift returns the values from a dictionary.
    When you access a value at an index of an array, you are simply given the value.
    When you access a value with a key in a dictionary, you are given an optional.
  id: totrans-5732
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在 Swift 中，字典返回值的方式有很大的不同。当你在数组的索引中访问值时，你会直接得到值。当你使用键在字典中访问值时，你会得到一个可选值（optional）。
- en: In [Chapter 5](text00015.html#ch05) , you learned that optionals might contain
    a value or might be nil . The reason Swift returns optionals when you’re looking
    up items in a dictionary is that the key you used might not exist in the dictionary,
    in which case there’s no value to access. Trying to access a value that doesn’t
    exist would give you a big fat error! To avoid that problem, Swift returns optionals.
    That means you need to unwrap any value you get out of a dictionary before you
    can do anything with it.
  id: totrans-5733
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第 5 章](text00015.html#ch05)中，你学到了可选值可能包含一个值，也可能是 nil。Swift 在你查找字典中的项时返回可选值的原因是你使用的键可能在字典中不存在，在这种情况下，没有值可以访问。尝试访问一个不存在的值会给你一个很大的错误！为了避免这个问题，Swift
    返回可选值。这意味着你需要解包从字典中获取的任何值，才能对其进行操作。
- en: 'To unwrap an optional, first you check whether it exists using an if-let statement,
    just like we did in [Chapter 5](text00015.html#ch05) . The following code shows
    you how to get a value out of a dictionary:'
  id: totrans-5734
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解包一个可选项，首先你要使用if-let语句检查它是否存在，就像我们在[第5章](text00015.html#ch05)中做的那样。以下代码展示了如何从字典中获取一个值：
- en: '![Image](Image00143.jpg)'
  id: totrans-5735
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00143.jpg)'
- en: To retrieve "Texas" from the dictionary, we use if let to set a constant loneStarState
    to usStates["TX"] ➊ . Because we have this state in our dictionary, the line I
    have Texas in my dictionary. is printed. Next we try to access a state that is
    not in our dictionary by using the key usStates["FL"] ➋ . Thankfully, because
    we used an if-let statement, the program won’t crash when the computer can’t find
    this state. Instead, I don't have that state in my dictionary. is printed.
  id: totrans-5736
  prefs: []
  type: TYPE_NORMAL
  zh: 为了从字典中获取"Texas"，我们使用if let语句将常量loneStarState设置为usStates["TX"]➊。因为我们在字典中有这个州，所以会打印出“I
    have Texas in my dictionary”。接下来，我们尝试访问一个不在字典中的州，使用键usStates["FL"]➋。幸运的是，由于我们使用了if-let语句，当计算机无法找到这个州时，程序不会崩溃。相反，打印出“I
    don’t have that state in my dictionary”。
- en: '**ADDING ITEMS TO A DICTIONARY**'
  id: totrans-5737
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**向字典中添加项目**'
- en: 'To add an item to a dictionary, first write the name of your dictionary and
    assign the new item to the key you want it to have in the dictionary. Let’s add
    "Minnesota" to our usStates dictionary:'
  id: totrans-5738
  prefs: []
  type: TYPE_NORMAL
  zh: 向字典中添加项目时，首先写下字典的名称，然后将新项目分配给你希望它拥有的键。让我们将"Minnesota"添加到我们的usStates字典中：
- en: '![](Image00144.jpg)'
  id: totrans-5739
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00144.jpg)'
- en: 'Now when you look at usStates , you’ll see that it’s updated to ["MN": "Minnesota",
    "WA": "Washington", "MA": "Massachusetts", "TX": "Texas"] . Remember, because
    you don’t have to rely on indices, your new dictionary item might appear anywhere
    in the dictionary.'
  id: totrans-5740
  prefs: []
  type: TYPE_NORMAL
  zh: '现在，当你查看usStates时，你会看到它已经更新为["MN": "Minnesota", "WA": "Washington", "MA": "Massachusetts",
    "TX": "Texas"]。记住，由于你不需要依赖索引，所以你的新字典项目可能出现在字典的任何位置。'
- en: '**REMOVING ITEMS FROM A DICTIONARY**'
  id: totrans-5741
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**从字典中移除项目**'
- en: Removing an item from a dictionary is quite simple; you do so by setting the
    value to nil . Because the values in dictionaries are returned as optionals, you
    don’t have to worry about nil causing any problems in your dictionary.
  id: totrans-5742
  prefs: []
  type: TYPE_NORMAL
  zh: 从字典中移除项目非常简单；你可以通过将值设置为nil来实现。因为字典中的值是以可选项的形式返回的，所以你不必担心nil会在字典中引起任何问题。
- en: '![](Image00145.jpg)'
  id: totrans-5743
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00145.jpg)'
- en: 'You can see that after you remove the value at the key "MA" , usStates is updated
    to ["MN": "Minnesota", "WA": "Washington", "TX": "Texas"] . Remember that nil
    is special and means that there’s no value at all. That’s why you don’t see "MA":
    nil in our dictionary.'
  id: totrans-5744
  prefs: []
  type: TYPE_NORMAL
  zh: '你可以看到，在移除"MA"键的值后，usStates已经更新为["MN": "Minnesota", "WA": "Washington", "TX":
    "Texas"]。记住，nil是特殊的，表示没有任何值。这就是为什么在字典中看不到"MA": nil的原因。'
- en: '**REPLACING ITEMS IN A DICTIONARY**'
  id: totrans-5745
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**替换字典中的项目**'
- en: 'Replacing an item in a dictionary is also easy. It works the same was as replacing
    an item in an array. You just set the item that you want to replace to something
    else. Say you create a dictionary of fruit colors:'
  id: totrans-5746
  prefs: []
  type: TYPE_NORMAL
  zh: 替换字典中的项目也很简单。它的工作方式与替换数组中的项目相同。你只需将要替换的项目设置为其他值。例如，你创建了一个水果颜色的字典：
- en: '![](Image00146.jpg)'
  id: totrans-5747
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00146.jpg)'
- en: At first we had the value "apple" for "red" , but then we decided that "raspberry"
    is a better fruit to use since sometimes apples are green or yellow. To replace
    "apple" with "raspberry" , we set colorFruits["red"] to its new value ➊ .
  id: totrans-5748
  prefs: []
  type: TYPE_NORMAL
  zh: 最开始，我们将"red"的值设为"apple"，但后来我们决定使用"raspberry"作为更好的水果，因为有时候苹果是绿色或黄色的。为了将"apple"替换为"raspberry"，我们将colorFruits["red"]设置为它的新值➊。
- en: You may remember that this is the same way we entered a new value into a dictionary.
    If the key already exists in the dictionary, then the value for that key is replaced.
    If the key doesn’t already exist, then the new key/value pair will be added to
    the dictionary.
  id: totrans-5749
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能还记得，这是我们将新值添加到字典中的方式。如果键已经存在于字典中，那么该键的值会被替换。如果键不存在，新的键值对将被添加到字典中。
- en: '![Image](Image00147.jpg)'
  id: totrans-5750
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00147.jpg)'
- en: '**USING DICTIONARY PROPERTIES**'
  id: totrans-5751
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**使用字典属性**'
- en: 'Like an array, a dictionary also has an isEmpty property and a count property.
    For example, the following code shows how you can use the isEmpty property to
    check if a dictionary is empty, and if it isn’t empty, the count property checks
    how many items you have. Imagine you have a basket of fruit for sale. You can
    use these properties to help you keep track of everything:'
  id: totrans-5752
  prefs: []
  type: TYPE_NORMAL
  zh: 像数组一样，字典也有isEmpty属性和count属性。例如，以下代码展示了如何使用isEmpty属性来检查字典是否为空，如果字典不为空，count属性会检查你有多少个项目。想象一下，你有一个水果篮子在出售。你可以使用这些属性来帮助你追踪所有的东西：
- en: '![Image](Image00148.jpg)'
  id: totrans-5753
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00148.jpg)'
- en: 'A dictionary also has two special properties: keys , which contains all of
    the dictionary’s keys, and values , which contains all of its values. We’ll use
    these two properties when we loop through the dictionary.'
  id: totrans-5754
  prefs: []
  type: TYPE_NORMAL
  zh: 字典还有两个特殊属性：keys，它包含字典的所有键；values，它包含字典的所有值。我们将在遍历字典时使用这两个属性。
- en: Let’s write some code that loops through our fruit baskets and prints the price
    of each fruit.
  id: totrans-5755
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们写一些代码，循环遍历我们的水果篮并打印每种水果的价格。
- en: '**LOOPING OVER A DICTIONARY**'
  id: totrans-5756
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**循环遍历字典**'
- en: 'You can loop through a dictionary using a for-in loop. Because each item has
    a key and a value, you can do this in two different ways. This is how to loop
    through a dictionary using its keys:'
  id: totrans-5757
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用for-in循环遍历字典。因为每个项目都有一个键和值，你可以通过两种不同的方式来做。这是如何使用字典的键来遍历字典：
- en: '![Image](Image00149.jpg)'
  id: totrans-5758
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00149.jpg)'
- en: Here we use the dictionary’s keys property ➊ to loop through fruitBasket and
    print its contents. We start by writing the keyword for , followed by a constant
    name fruit for the dictionary key, the keyword in , the dictionary name, a period,
    and keys .
  id: totrans-5759
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们使用字典的keys属性➊来循环遍历fruitBasket并打印其内容。我们从写关键字for开始，后面跟着常量名fruit作为字典的键，关键字in，字典名，一个句点，和keys。
- en: Inside the braces of our for-in loop, we have access to both the key, which
    we call fruit ➋ , and the value at that key when we force-unwrap its contents
    with fruitBasket[fruit]! ➌ . That value will be the fruit’s price.
  id: totrans-5760
  prefs: []
  type: TYPE_NORMAL
  zh: 在for-in循环的大括号内，我们可以访问键，我们称之为fruit➋，以及通过fruitBasket[fruit]! ➌强制解包其内容后得到的该键的值。这个值将是水果的价格。
- en: In this case, it’s safe to force-unwrap the value using an exclamation point
    because we know that the fruit key we’re using is definitely inside the dictionary.
  id: totrans-5761
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，使用感叹号强制解包值是安全的，因为我们知道我们使用的fruit键肯定在字典中。
- en: Any code we put inside the for-in loop will run once for every key in our dictionary.
    So you should see the print statement display three times.
  id: totrans-5762
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在for-in循环中写的任何代码都会在字典的每个键上运行一次。所以你应该看到打印语句显示三次。
- en: 'We can also loop through the dictionary using its values property:'
  id: totrans-5763
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以使用字典的values属性来遍历字典：
- en: '![Image](Image00150.jpg)'
  id: totrans-5764
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00150.jpg)'
- en: We use the same style of for-in loop, but now we use a constant to refer to
    each value, which we call price , in the values property. When looping through
    values, we don’t have access to the keys from inside the loop.
  id: totrans-5765
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用相同的for-in循环方式，但现在我们使用常量来引用每个值，我们称之为price，在values属性中。当循环遍历values时，我们无法从循环内部访问键。
- en: Another difference to note is that price is not an optional because it’s accessed
    directly as a value in the fruitBasket dictionary. That means we don’t have to
    unwrap it. You should still see the print statement printed three times. [Figure
    6-6](text00016.html#ch06fig6) shows the output of both loops.
  id: totrans-5766
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个需要注意的区别是价格不是可选的，因为它作为一个值直接访问了fruitBasket字典。这意味着我们不需要解包它。你应该仍然看到打印语句打印三次。[图6-6](text00016.html#ch06fig6)展示了两个循环的输出。
- en: '![Image](Image00151.jpg)'
  id: totrans-5767
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00151.jpg)'
- en: '*Figure 6-6: Looping through the keys and values of a dictionary with a for-in
    loop*'
  id: totrans-5768
  prefs: []
  type: TYPE_NORMAL
  zh: '*图6-6：使用for-in循环遍历字典的键和值*'
- en: The order of your results might be slightly different from ours. That’s because
    the items in a dictionary aren’t in a numbered order like they are in an array!
    And because the order is not guaranteed, you might see a different order printed
    if you run the same code again.
  id: totrans-5769
  prefs: []
  type: TYPE_NORMAL
  zh: 你的结果顺序可能与我们的稍有不同。这是因为字典中的项目不像数组那样按编号顺序排列！而且因为顺序无法保证，如果你再次运行相同的代码，你可能会看到不同的顺序。
- en: '**WHAT YOU LEARNED**'
  id: totrans-5770
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**你学到了什么**'
- en: In this chapter, you learned how to store collections of items in an array and
    in a dictionary. To store items in an ordered list, you would use an array and
    look up each item by its index. If you wanted to store items by key instead, you
    would use a dictionary.
  id: totrans-5771
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一章中，你学会了如何在数组和字典中存储项目。要将项目存储在有序列表中，你会使用数组，并通过索引查找每个项目。如果你想通过键来存储项目，那么你会使用字典。
- en: Knowing about arrays and dictionaries and how to use them is a powerful building
    block for almost any programming language. Next we will learn about functions,
    another very powerful tool. Functions are blocks of code that you create and name
    to perform a specific job. After you have written a function, you can use its
    name to call it from almost anywhere in your program.
  id: totrans-5772
  prefs: []
  type: TYPE_NORMAL
  zh: 了解数组和字典，以及如何使用它们，是几乎所有编程语言中非常强大的构建模块。接下来，我们将学习函数，另一个非常强大的工具。函数是你创建并命名的代码块，用来执行特定的任务。在你编写了一个函数之后，你可以通过它的名字从程序中的几乎任何地方调用它。
- en: The order of the ingredients in smoothie is the same as the order in fruits
    and liquids . If you created smoothie with liquids + fruits , then the liquids
    would come first.
  id: totrans-5773
  prefs: []
  type: TYPE_NORMAL
  zh: 果汁的配料顺序与水果和液体的顺序相同。如果你是先放液体再放水果制作果汁，那么液体会排在前面。
- en: 'You use the += operator to add an array to the end of your array. Add some
    whipped cream as follows for extra yumminess:'
  id: totrans-5774
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用 += 运算符将一个数组添加到另一个数组的末尾。为了增加一点美味，可以像下面这样添加一些奶油：
- en: '![](Image00124.jpg)'
  id: totrans-5775
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00124.jpg)'
- en: Note that ["whipped cream"] is an array even though it has a single item in
    it. When you’re using += to append something to an array, you have to make sure
    you’re only trying to add another array. If you were to just write the string
    "whipped cream" without the square brackets around it, you would get an error.
  id: totrans-5776
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，["whipped cream"] 是一个数组，尽管它里面只有一个项目。当你使用 += 将某个元素附加到数组时，必须确保你只是在尝试添加另一个数组。如果你直接写
    "whipped cream" 字符串而没有用方括号括起来，那么你会得到一个错误。
- en: '![Image](Image00125.jpg)'
  id: totrans-5777
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Image00125.jpg)'
- en: '**REMOVING ITEMS FROM AN ARRAY**'
  id: totrans-5778
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**从数组中移除项目**'
- en: 'There are several methods for removing items from an array. Let’s start by
    looking at the array’s removeLast() method. As you might have guessed from its
    name, removeLast() removes the last item from your array. Let’s try it out with
    a shoppingList array:'
  id: totrans-5779
  prefs: []
  type: TYPE_NORMAL
  zh: 移除数组中的项目有多种方法。让我们从查看数组的 removeLast() 方法开始。如你所料，removeLast() 会移除数组中的最后一个项目。让我们通过一个
    shoppingList 数组来试试看：
- en: '![](Image00126.jpg)'
  id: totrans-5780
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00126.jpg)'
- en: Neat! Note that the removeLast() method returns the removed item, so you can
    store it in a new constant or variable if you want.
  id: totrans-5781
  prefs: []
  type: TYPE_NORMAL
  zh: 很棒！请注意，removeLast() 方法会返回被移除的项目，因此如果你需要的话，可以将其存储在一个新的常量或变量中。
- en: 'You can also remove an item from a specific index by using the remove(at:)
    method. Let’s say that your mom doesn’t want you buying any candy and takes that
    off the list:'
  id: totrans-5782
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以使用 remove(at:) 方法从特定索引位置移除项目。假设你的妈妈不希望你买糖果，于是把它从列表中移除：
- en: '![Image](Image00127.jpg)![](Image00128.jpg)'
  id: totrans-5783
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Image00127.jpg)![](Image00128.jpg)'
- en: Just like when we added an item to the middle of our array and all the items
    scooted over to make room, if you remove an item from the middle of an array,
    the rest of the items will scoot back to fill in that empty space. The "apples"
    item that was at index 3 is now at index 2, where "candy" was.
  id: totrans-5784
  prefs: []
  type: TYPE_NORMAL
  zh: 就像我们在数组中间添加项目时，所有其他项目会挪动以腾出空间一样，如果你从数组的中间移除项目，其他项目会挪回去填补那个空位。原来在索引 3 位置的 "apples"
    项目现在在索引 2 位置，取代了 "candy"。
- en: 'You can also remove all items from an array with removeAll() . Try entering
    this into your playground:'
  id: totrans-5785
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以使用 removeAll() 方法移除数组中的所有项目。试着在你的 playground 中输入这个：
- en: '![](Image00129.jpg)'
  id: totrans-5786
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00129.jpg)'
- en: 'Note that trying to remove an item at an index that doesn’t exist will give
    you an error:'
  id: totrans-5787
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，尝试从一个不存在的索引位置移除项目会导致错误：
- en: '![](Image00130.jpg)'
  id: totrans-5788
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00130.jpg)'
- en: Our array doesn’t have this many items (in fact, now it’s empty!), so this throws
    an error. We’ll also get an error if we use removeLast() on our empty array, because
    there’s nothing in it—there’s no last index at all! However, removeAll() is always
    safe to use, even on an empty array.
  id: totrans-5789
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的数组没有这么多项目（实际上现在它是空的！），所以这会引发错误。如果我们在空数组上使用 removeLast() 方法，也会出错，因为数组里什么都没有——根本没有最后一个索引！不过，removeAll()
    方法即使在空数组上使用也总是安全的。
- en: '**REPLACING ITEMS IN AN ARRAY**'
  id: totrans-5790
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**替换数组中的项目**'
- en: 'To replace an item in an array, you set the index of the array to the new value,
    as shown here:'
  id: totrans-5791
  prefs: []
  type: TYPE_NORMAL
  zh: 要替换数组中的项目，你只需将数组的索引设置为新的值，如下所示：
- en: '![](Image00131.jpg)'
  id: totrans-5792
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00131.jpg)'
- en: At ➊ , we replaced the item at index 2 (the third item) with "Unicorn" because
    magical animals count as favorite animals, too! At ➋ , we replaced the item at
    index 0 (the first item) with "Bearded dragon" . No, that’s not a real dragon—it’s
    just a lizard!
  id: totrans-5793
  prefs: []
  type: TYPE_NORMAL
  zh: 在 ➊ ，我们用 "Unicorn" 替换了索引为 2（即第三个项目）的元素，因为神奇的动物也算是最喜欢的动物！在 ➋ ，我们用 "Bearded dragon"
    替换了索引为 0（即第一个项目）的元素。不是的，那不是一条真正的龙——它只是一只鬃蜥！
- en: Like any time you’re working with array index numbers, you have to be sure an
    item exists in the array at that index before you change its value, or you will
    get an Index out of range error.
  id: totrans-5794
  prefs: []
  type: TYPE_NORMAL
  zh: 就像你在处理数组索引时一样，你必须确保数组中在该索引处有项目存在，才能更改其值，否则会出现“索引超出范围”的错误。
- en: '[Figure 6-3](text00016.html#ch06fig3) shows the error that occurs if you try
    to add "Standard poodle" using favoriteAnimals[3] = "Standard poodle" . To add
    an item to the end of an array, you should use the append(_:) method or += , as
    we covered in “[Adding Items to an Array](text00016.html#ch06lev2sec5) ” on [page
    70](text00016.html#page_70) .'
  id: totrans-5795
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 6-3](text00016.html#ch06fig3)显示了如果你尝试通过 favoriteAnimals[3] = "标准贵宾犬" 来添加"标准贵宾犬"时发生的错误。要向数组末尾添加项目，应该使用
    append(_:) 方法或 +=，正如我们在“[向数组添加项目](text00016.html#ch06lev2sec5)”中讨论的那样，参见[第 70
    页](text00016.html#page_70)。'
- en: '![Image](Image00132.jpg)'
  id: totrans-5796
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00132.jpg)'
- en: '*Figure 6-3: Don’t try to replace a value at an index beyond the existing array.*'
  id: totrans-5797
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 6-3：不要尝试替换超出现有数组范围的索引值。*'
- en: Now you know how to change arrays however you might need to. You can add items,
    take items away, or replace items. Next, we’ll look at how to use the properties
    of arrays to find out even more information about them.
  id: totrans-5798
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你知道如何根据需要更改数组了。你可以添加项目、删除项目或替换项目。接下来，我们将探讨如何使用数组的属性来获取更多关于数组的信息。
- en: '![Image](Image00133.jpg)'
  id: totrans-5799
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00133.jpg)'
- en: '**USING ARRAY PROPERTIES**'
  id: totrans-5800
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**使用数组属性**'
- en: In addition to methods like append(_:) and removeLast() , arrays also have *properties*
    . An array’s properties are variables or constants that contain some information
    about the array. Two really helpful properties that you might use are the Boolean
    property isEmpty and the integer property count .
  id: totrans-5801
  prefs: []
  type: TYPE_NORMAL
  zh: 除了像 append(_:) 和 removeLast() 这样的方式外，数组还有*属性*。数组的属性是包含关于数组某些信息的变量或常量。你可能会用到的两个非常有用的属性是布尔属性
    isEmpty 和整数属性 count。
- en: The isEmpty property is true or false depending on whether the array is empty,
    and the count property will tell you how many items are in that array.
  id: totrans-5802
  prefs: []
  type: TYPE_NORMAL
  zh: isEmpty 属性是 true 或 false，取决于数组是否为空，而 count 属性会告诉你数组中有多少个项目。
- en: 'Check out how these two properties are used in the following if-else statement:'
  id: totrans-5803
  prefs: []
  type: TYPE_NORMAL
  zh: 查看以下 if-else 语句中如何使用这两个属性：
- en: '![Image](Image00134.jpg)'
  id: totrans-5804
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00134.jpg)'
- en: 'This if-else statement checks whether the array mySiblings is empty ➊ . If
    it is, then "I don''t have any siblings." is printed. But if there is something
    in the array, then the number of siblings that we have is printed: "I have 3 siblings."
    ➋ .'
  id: totrans-5805
  prefs: []
  type: TYPE_NORMAL
  zh: 这个 if-else 语句检查数组 mySiblings 是否为空 ➊。如果为空，则打印 "我没有兄弟姐妹"。如果数组中有内容，则打印我们有多少个兄弟姐妹："我有
    3 个兄弟姐妹" ➋。
- en: '**LOOPING OVER AN ARRAY**'
  id: totrans-5806
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**遍历数组**'
- en: 'Sometimes when you’re working with arrays you might want to do something to
    every item in the array. You can use a for-in loop to do that! The following code
    will print every topping in a pizzaToppings array on a separate line:'
  id: totrans-5807
  prefs: []
  type: TYPE_NORMAL
  zh: 有时在处理数组时，你可能希望对数组中的每个项目做一些操作。你可以使用 for-in 循环来实现！以下代码将会逐行打印出 pizzaToppings 数组中的每个配料：
- en: '![Image](Image00135.jpg)'
  id: totrans-5808
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00135.jpg)'
- en: To write a for-in loop for the pizzaToppings array, we used the keyword for
    , followed by the constant topping , then the keyword in , and finally the name
    of our array, pizzaToppings . Then we put the statements that we want to run for
    each topping inside the braces of the for-in loop. The constant topping ➊ temporarily
    represents each pizza topping in the array as we loop through it. We could have
    chosen any name for this constant, but it’s a good idea to pick something that
    makes sense. You can see the output of this for-in loop in [Figure 6-4](text00016.html#ch06fig4)
    .
  id: totrans-5809
  prefs: []
  type: TYPE_NORMAL
  zh: 要为 pizzaToppings 数组编写 for-in 循环，我们使用了关键字 for，后跟常量 topping，然后是关键字 in，最后是数组的名称
    pizzaToppings。然后我们将想要对每个 topping 执行的语句放在 for-in 循环的花括号中。常量 topping ➊ 在我们循环遍历数组时暂时代表数组中的每个披萨配料。我们本可以为这个常量选择任何名字，但选择一个有意义的名字是个好主意。你可以在[图
    6-4](text00016.html#ch06fig4)中看到这个 for-in 循环的输出。
- en: '![Image](Image00136.jpg)'
  id: totrans-5810
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00136.jpg)'
- en: '*Figure 6-4: Output of the example for-in loop*'
  id: totrans-5811
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 6-4：示例 for-in 循环的输出*'
- en: '![Image](Image00137.jpg)'
  id: totrans-5812
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00137.jpg)'
- en: 'Using for-in loops is great for printing every value in an array. If you’re
    working with numbers, you can even use them to perform math operations on each
    item, which makes for some speedy calculations! The following code takes an array
    of numbers and calculates the square for each (the square of a number is that
    number multiplied by itself):'
  id: totrans-5813
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 for-in 循环非常适合打印数组中的每个值。如果你正在处理数字，甚至可以使用它们对每个项目进行数学运算，从而进行快速计算！以下代码接收一个数字数组，并计算每个数字的平方（数字的平方是该数字与其自身相乘）：
- en: '![Image](Image00138.jpg)'
  id: totrans-5814
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00138.jpg)'
- en: '[Figure 6-5](text00016.html#ch06fig5) shows the results.'
  id: totrans-5815
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 6-5](text00016.html#ch06fig5) 显示了结果。'
- en: '![Image](Image00139.jpg)'
  id: totrans-5816
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00139.jpg)'
- en: '*Figure 6-5: Printing the squares for each number in the myNumbers array*'
  id: totrans-5817
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 6-5：打印 myNumbers 数组中每个数字的平方*'
- en: '**DICTIONARIES ARE KEY!**'
  id: totrans-5818
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**字典是关键！**'
- en: A *dictionary* is also a collection of values, but instead of an ordered index,
    each value has its own *key* . Because there’s no index, the values are not stored
    in any particular order. To access values in a dictionary, you look them up by
    their key.
  id: totrans-5819
  prefs: []
  type: TYPE_NORMAL
  zh: '*字典*也是一个值的集合，不同的是，它没有顺序索引，每个值都有自己的*键*。因为没有索引，所以值并不按任何特定顺序存储。要访问字典中的值，你需要通过键来查找。'
- en: A key must be unique. You can’t have the same key more than once in the same
    dictionary. If there were two identical keys and you asked the computer to give
    you the value for one of them, the computer wouldn’t know which one to choose!
  id: totrans-5820
  prefs: []
  type: TYPE_NORMAL
  zh: 一个键必须是唯一的。在同一个字典中不能有重复的键。如果有两个相同的键，而你要求计算机返回其中一个的值，计算机就不知道该选择哪一个！
- en: Let’s take a look at how to make a dictionary and write keys that will help
    you find all the information you need.
  id: totrans-5821
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看一下如何创建一个字典并编写键，以帮助你找到所有需要的信息。
- en: '![Image](Image00140.jpg)'
  id: totrans-5822
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00140.jpg)'
- en: '**INITIALIZING A DICTIONARY**'
  id: totrans-5823
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**初始化字典**'
- en: 'To create and initialize a dictionary, first write var and the name of your
    dictionary. Then write the keys and corresponding values inside a pair of square
    brackets, similar to an array. Let’s create a dictionary to store the names of
    a few US states. The key for each state will be its two-letter abbreviation:'
  id: totrans-5824
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建并初始化一个字典，首先写出 var 和字典的名称。然后在一对方括号中写入键和值，类似于数组。让我们创建一个字典来存储一些美国州的名称。每个州的键将是其两字母缩写：
- en: '![](Image00141.jpg)'
  id: totrans-5825
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00141.jpg)'
- en: As you can see, there’s a colon between each key and its value, and the key/value
    pairs are separated by commas.
  id: totrans-5826
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，键和值之间有一个冒号，键/值对通过逗号分隔。
- en: Dictionaries are different from arrays in that they are *unordered* . Because
    of that, it’s likely that the order of the states that you see in your results
    pane ➋ is different from the order in which you entered your states ➊ . It might
    even be different than the order that’s printed in this book!
  id: totrans-5827
  prefs: []
  type: TYPE_NORMAL
  zh: 字典与数组不同，因为它们是*无序的*。因此，你在结果窗格中看到的州的顺序 ➋ 可能与输入州的顺序 ➊ 不同。它甚至可能与书中打印的顺序不同！
- en: As with arrays, you can use var to make a mutable dictionary or use let to make
    an immutable dictionary.
  id: totrans-5828
  prefs: []
  type: TYPE_NORMAL
  zh: 与数组一样，你可以使用 var 来创建一个可变字典，或者使用 let 来创建一个不可变字典。
- en: 'In Swift, all of the keys of a dictionary must be the same type, and all of
    the values of a dictionary must also be the same type, but the key type doesn’t
    have to match the value type. For example, if you wanted to store a collection
    of fractions, you could use doubles for the keys and strings for the values:'
  id: totrans-5829
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Swift 中，字典的所有键必须是相同的类型，字典的所有值也必须是相同的类型，但键的类型不必与值的类型匹配。例如，如果你想存储一组分数，可以使用双精度浮点数作为键，字符串作为值：
- en: '![](Image00142.jpg)'
  id: totrans-5830
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00142.jpg)'
- en: In this dictionary, all of the keys must be doubles, and all of the values must
    be strings. Again, you’ll see that the order of the numbers in the results pane
    can be quite different from the order in which you wrote the fractions in your
    dictionary. This is fine because you don’t need to know the order to access anything.
    You can find any item that you need by its key. Let’s see how!
  id: totrans-5831
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个字典中，所有的键必须是双精度浮点数，所有的值必须是字符串。同样，你会发现，结果窗格中数字的顺序可能与在字典中编写分数的顺序有很大不同。这是可以的，因为你不需要知道顺序就能访问任何内容。你可以通过键找到你需要的任何项目。我们来看看如何做！
- en: '**ACCESSING VALUES IN A DICTIONARY**'
  id: totrans-5832
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**访问字典中的值**'
- en: 'Looking up a value in a dictionary is similar to how you access a value in
    an array except that you use a key inside the square brackets instead of an index,
    like this: usStates["TX"] .'
  id: totrans-5833
  prefs: []
  type: TYPE_NORMAL
  zh: 在字典中查找一个值类似于你在数组中访问一个值，不同之处在于你使用的是方括号中的键，而不是索引，例如：usStates["TX"]。
- en: There is a big difference, however, in how Swift returns the values from a dictionary.
    When you access a value at an index of an array, you are simply given the value.
    When you access a value with a key in a dictionary, you are given an optional.
  id: totrans-5834
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，Swift在从字典返回值时有一个很大的区别。当你访问数组中某个索引的值时，你只是获得该值。当你使用键访问字典中的值时，你得到的是一个可选值。
- en: In [Chapter 5](text00015.html#ch05) , you learned that optionals might contain
    a value or might be nil . The reason Swift returns optionals when you’re looking
    up items in a dictionary is that the key you used might not exist in the dictionary,
    in which case there’s no value to access. Trying to access a value that doesn’t
    exist would give you a big fat error! To avoid that problem, Swift returns optionals.
    That means you need to unwrap any value you get out of a dictionary before you
    can do anything with it.
  id: totrans-5835
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第五章](text00015.html#ch05)中，你学习了可选值可能包含一个值，也可能是nil。当你在字典中查找项目时，Swift返回可选值的原因是你使用的键可能在字典中不存在，在这种情况下，就没有值可以访问。试图访问一个不存在的值会导致一个大错误！为了避免这个问题，Swift返回可选值。这意味着你需要解包从字典中得到的任何值，然后才能对其进行处理。
- en: 'To unwrap an optional, first you check whether it exists using an if-let statement,
    just like we did in [Chapter 5](text00015.html#ch05) . The following code shows
    you how to get a value out of a dictionary:'
  id: totrans-5836
  prefs: []
  type: TYPE_NORMAL
  zh: 要解包一个可选值，首先使用if-let语句检查它是否存在，就像我们在[第五章](text00015.html#ch05)中所做的那样。以下代码展示了如何从字典中获取一个值：
- en: '![Image](Image00143.jpg)'
  id: totrans-5837
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Image00143.jpg)'
- en: To retrieve "Texas" from the dictionary, we use if let to set a constant loneStarState
    to usStates["TX"] ➊ . Because we have this state in our dictionary, the line I
    have Texas in my dictionary. is printed. Next we try to access a state that is
    not in our dictionary by using the key usStates["FL"] ➋ . Thankfully, because
    we used an if-let statement, the program won’t crash when the computer can’t find
    this state. Instead, I don't have that state in my dictionary. is printed.
  id: totrans-5838
  prefs: []
  type: TYPE_NORMAL
  zh: 为了从字典中检索"Texas"，我们使用if let将常量loneStarState设置为usStates["TX"] ➊。因为我们字典中有这个州，"I
    have Texas in my dictionary." 这一行会被打印出来。接下来，我们尝试通过使用键usStates["FL"] ➋访问一个不在字典中的州。幸运的是，因为我们使用了if-let语句，当计算机无法找到这个州时，程序不会崩溃。相反，"I
    don't have that state in my dictionary." 会被打印出来。
- en: '**ADDING ITEMS TO A DICTIONARY**'
  id: totrans-5839
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**向字典添加项目**'
- en: 'To add an item to a dictionary, first write the name of your dictionary and
    assign the new item to the key you want it to have in the dictionary. Let’s add
    "Minnesota" to our usStates dictionary:'
  id: totrans-5840
  prefs: []
  type: TYPE_NORMAL
  zh: 要向字典添加一个项目，首先写出字典的名称，并将新项目分配给你希望在字典中拥有的键。让我们把"明尼苏达"添加到我们的usStates字典中：
- en: '![](Image00144.jpg)'
  id: totrans-5841
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00144.jpg)'
- en: 'Now when you look at usStates , you’ll see that it’s updated to ["MN": "Minnesota",
    "WA": "Washington", "MA": "Massachusetts", "TX": "Texas"] . Remember, because
    you don’t have to rely on indices, your new dictionary item might appear anywhere
    in the dictionary.'
  id: totrans-5842
  prefs: []
  type: TYPE_NORMAL
  zh: '现在，当你查看usStates时，你会看到它已更新为["MN": "Minnesota", "WA": "Washington", "MA": "Massachusetts",
    "TX": "Texas"]。记住，因为你不需要依赖索引，新的字典项目可能会出现在字典中的任何位置。'
- en: '**REMOVING ITEMS FROM A DICTIONARY**'
  id: totrans-5843
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**从字典中删除项目**'
- en: Removing an item from a dictionary is quite simple; you do so by setting the
    value to nil . Because the values in dictionaries are returned as optionals, you
    don’t have to worry about nil causing any problems in your dictionary.
  id: totrans-5844
  prefs: []
  type: TYPE_NORMAL
  zh: 从字典中删除一个项目非常简单；你只需将值设置为nil。因为字典中的值作为可选值返回，所以你不需要担心nil会在字典中引起任何问题。
- en: '![](Image00145.jpg)'
  id: totrans-5845
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00145.jpg)'
- en: 'You can see that after you remove the value at the key "MA" , usStates is updated
    to ["MN": "Minnesota", "WA": "Washington", "TX": "Texas"] . Remember that nil
    is special and means that there’s no value at all. That’s why you don’t see "MA":
    nil in our dictionary.'
  id: totrans-5846
  prefs: []
  type: TYPE_NORMAL
  zh: '你可以看到，在删除键"MA"的值之后，usStates被更新为["MN": "Minnesota", "WA": "Washington", "TX":
    "Texas"]。记住，nil是特殊的，表示根本没有值。这就是为什么在我们的字典中你看不到"MA": nil。'
- en: '**REPLACING ITEMS IN A DICTIONARY**'
  id: totrans-5847
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**替换字典中的项目**'
- en: 'Replacing an item in a dictionary is also easy. It works the same was as replacing
    an item in an array. You just set the item that you want to replace to something
    else. Say you create a dictionary of fruit colors:'
  id: totrans-5848
  prefs: []
  type: TYPE_NORMAL
  zh: 替换字典中的项目也很简单。它的工作方式和替换数组中的项目一样。你只需将你想要替换的项目设置为其他内容。比如你创建一个水果颜色的字典：
- en: '![](Image00146.jpg)'
  id: totrans-5849
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00146.jpg)'
- en: At first we had the value "apple" for "red" , but then we decided that "raspberry"
    is a better fruit to use since sometimes apples are green or yellow. To replace
    "apple" with "raspberry" , we set colorFruits["red"] to its new value ➊ .
  id: totrans-5850
  prefs: []
  type: TYPE_NORMAL
  zh: 起初，我们为 "red" 设置了值 "apple"，但后来我们决定 "raspberry" 是更好的水果，因为有时候苹果是绿色或黄色的。为了用 "raspberry"
    替换 "apple"，我们将 colorFruits["red"] 设置为新的值 ➊。
- en: You may remember that this is the same way we entered a new value into a dictionary.
    If the key already exists in the dictionary, then the value for that key is replaced.
    If the key doesn’t already exist, then the new key/value pair will be added to
    the dictionary.
  id: totrans-5851
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能还记得，这就是我们向字典中输入新值的方式。如果键已经存在于字典中，则该键的值会被替换。如果键不存在，则新的键/值对将被添加到字典中。
- en: '![Image](Image00147.jpg)'
  id: totrans-5852
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00147.jpg)'
- en: '**USING DICTIONARY PROPERTIES**'
  id: totrans-5853
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**使用字典属性**'
- en: 'Like an array, a dictionary also has an isEmpty property and a count property.
    For example, the following code shows how you can use the isEmpty property to
    check if a dictionary is empty, and if it isn’t empty, the count property checks
    how many items you have. Imagine you have a basket of fruit for sale. You can
    use these properties to help you keep track of everything:'
  id: totrans-5854
  prefs: []
  type: TYPE_NORMAL
  zh: 像数组一样，字典也有 isEmpty 属性和 count 属性。例如，以下代码展示了如何使用 isEmpty 属性检查字典是否为空，如果不为空，则 count
    属性检查字典中有多少项。假设你有一个待售的水果篮。你可以使用这些属性来帮助你跟踪一切：
- en: '![Image](Image00148.jpg)'
  id: totrans-5855
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00148.jpg)'
- en: 'A dictionary also has two special properties: keys , which contains all of
    the dictionary’s keys, and values , which contains all of its values. We’ll use
    these two properties when we loop through the dictionary.'
  id: totrans-5856
  prefs: []
  type: TYPE_NORMAL
  zh: 字典还有两个特殊属性：keys，它包含字典的所有键；values，它包含字典的所有值。我们将在遍历字典时使用这两个属性。
- en: Let’s write some code that loops through our fruit baskets and prints the price
    of each fruit.
  id: totrans-5857
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们写一些代码，循环遍历我们的水果篮，并打印每个水果的价格。
- en: '**LOOPING OVER A DICTIONARY**'
  id: totrans-5858
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**遍历字典**'
- en: 'You can loop through a dictionary using a for-in loop. Because each item has
    a key and a value, you can do this in two different ways. This is how to loop
    through a dictionary using its keys:'
  id: totrans-5859
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用 for-in 循环来遍历字典。因为每个项都有一个键和值，所以你可以通过两种方式来完成。以下是使用字典的键来遍历字典的方法：
- en: '![Image](Image00149.jpg)'
  id: totrans-5860
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00149.jpg)'
- en: Here we use the dictionary’s keys property ➊ to loop through fruitBasket and
    print its contents. We start by writing the keyword for , followed by a constant
    name fruit for the dictionary key, the keyword in , the dictionary name, a period,
    and keys .
  id: totrans-5861
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们使用字典的 keys 属性 ➊ 来循环遍历 fruitBasket 并打印其内容。我们首先写下关键字 for，然后是字典键的常量名称 fruit，接着是关键字
    in，字典名称，句点，然后是 keys。
- en: Inside the braces of our for-in loop, we have access to both the key, which
    we call fruit ➋ , and the value at that key when we force-unwrap its contents
    with fruitBasket[fruit]! ➌ . That value will be the fruit’s price.
  id: totrans-5862
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们 for-in 循环的花括号内部，我们可以访问键（我们称之为 fruit ➋）以及通过 fruitBasket[fruit]! ➌ 强制解包其内容时的该键对应的值。该值就是水果的价格。
- en: In this case, it’s safe to force-unwrap the value using an exclamation point
    because we know that the fruit key we’re using is definitely inside the dictionary.
  id: totrans-5863
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，由于我们知道正在使用的果实键一定在字典中，因此使用感叹号强制解包值是安全的。
- en: Any code we put inside the for-in loop will run once for every key in our dictionary.
    So you should see the print statement display three times.
  id: totrans-5864
  prefs: []
  type: TYPE_NORMAL
  zh: 我们放入 for-in 循环中的任何代码都会针对字典中的每个键执行一次。所以你应该看到打印语句打印了三次。
- en: 'We can also loop through the dictionary using its values property:'
  id: totrans-5865
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以使用字典的 values 属性来循环遍历字典：
- en: '![Image](Image00150.jpg)'
  id: totrans-5866
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00150.jpg)'
- en: We use the same style of for-in loop, but now we use a constant to refer to
    each value, which we call price , in the values property. When looping through
    values, we don’t have access to the keys from inside the loop.
  id: totrans-5867
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用相同的 for-in 循环风格，但现在我们使用常量来引用 values 属性中的每个值，我们称之为 price。在循环值时，我们无法从循环内部访问键。
- en: Another difference to note is that price is not an optional because it’s accessed
    directly as a value in the fruitBasket dictionary. That means we don’t have to
    unwrap it. You should still see the print statement printed three times. [Figure
    6-6](text00016.html#ch06fig6) shows the output of both loops.
  id: totrans-5868
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个需要注意的区别是，price 不是一个可选值，因为它是直接作为值从 fruitBasket 字典中访问的。这意味着我们不需要解包它。你仍然应该看到打印语句打印了三次。[图
    6-6](text00016.html#ch06fig6) 显示了两个循环的输出。
- en: '![Image](Image00151.jpg)'
  id: totrans-5869
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00151.jpg)'
- en: '*Figure 6-6: Looping through the keys and values of a dictionary with a for-in
    loop*'
  id: totrans-5870
  prefs: []
  type: TYPE_NORMAL
  zh: '*图6-6：使用for-in循环遍历字典的键和值*'
- en: The order of your results might be slightly different from ours. That’s because
    the items in a dictionary aren’t in a numbered order like they are in an array!
    And because the order is not guaranteed, you might see a different order printed
    if you run the same code again.
  id: totrans-5871
  prefs: []
  type: TYPE_NORMAL
  zh: 你的结果顺序可能会与我们的有所不同。这是因为字典中的项目不像数组那样按数字顺序排列！而且由于顺序无法保证，如果你再次运行相同的代码，你可能会看到不同的顺序。
- en: '**WHAT YOU LEARNED**'
  id: totrans-5872
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**你学到的**'
- en: In this chapter, you learned how to store collections of items in an array and
    in a dictionary. To store items in an ordered list, you would use an array and
    look up each item by its index. If you wanted to store items by key instead, you
    would use a dictionary.
  id: totrans-5873
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你学会了如何在数组和字典中存储项目。要将项目存储在有序列表中，你应该使用数组，并通过索引查找每个项目。如果你想按键存储项目，那么你应该使用字典。
- en: Knowing about arrays and dictionaries and how to use them is a powerful building
    block for almost any programming language. Next we will learn about functions,
    another very powerful tool. Functions are blocks of code that you create and name
    to perform a specific job. After you have written a function, you can use its
    name to call it from almost anywhere in your program.
  id: totrans-5874
  prefs: []
  type: TYPE_NORMAL
  zh: 了解数组和字典以及如何使用它们是几乎任何编程语言的强大构建块。接下来我们将学习函数，另一个非常强大的工具。函数是你创建并命名的代码块，用来执行特定的任务。编写完函数后，你可以使用它的名字在程序中的几乎任何地方调用它。
- en: 'You use the += operator to add an array to the end of your array. Add some
    whipped cream as follows for extra yumminess:'
  id: totrans-5875
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用+=运算符将一个数组添加到数组的末尾。按如下方式添加一些鲜奶油，让它更美味：
- en: '![](Image00124.jpg)'
  id: totrans-5876
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00124.jpg)'
- en: Note that ["whipped cream"] is an array even though it has a single item in
    it. When you’re using += to append something to an array, you have to make sure
    you’re only trying to add another array. If you were to just write the string
    "whipped cream" without the square brackets around it, you would get an error.
  id: totrans-5877
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，["whipped cream"]是一个数组，尽管它只包含一个项目。当你使用+=将内容添加到数组时，必须确保你只是在添加另一个数组。如果你只是写了字符串"whipped
    cream"而没有加上方括号，就会出现错误。
- en: '![Image](Image00125.jpg)'
  id: totrans-5878
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00125.jpg)'
- en: '**REMOVING ITEMS FROM AN ARRAY**'
  id: totrans-5879
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**从数组中删除项目**'
- en: 'There are several methods for removing items from an array. Let’s start by
    looking at the array’s removeLast() method. As you might have guessed from its
    name, removeLast() removes the last item from your array. Let’s try it out with
    a shoppingList array:'
  id: totrans-5880
  prefs: []
  type: TYPE_NORMAL
  zh: 有多种方法可以从数组中删除项目。我们首先来看数组的removeLast()方法。正如你从名字中可能已经猜到的，removeLast()会删除数组中的最后一个项目。我们来尝试一下这个shoppingList数组：
- en: '![](Image00126.jpg)'
  id: totrans-5881
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00126.jpg)'
- en: Neat! Note that the removeLast() method returns the removed item, so you can
    store it in a new constant or variable if you want.
  id: totrans-5882
  prefs: []
  type: TYPE_NORMAL
  zh: 很棒！请注意，removeLast()方法会返回被删除的项目，因此如果你想，你可以将其存储在一个新的常量或变量中。
- en: 'You can also remove an item from a specific index by using the remove(at:)
    method. Let’s say that your mom doesn’t want you buying any candy and takes that
    off the list:'
  id: totrans-5883
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以使用remove(at:)方法从特定的索引处删除一个项目。假设你的妈妈不想让你买糖果，并把它从清单上删除：
- en: '![Image](Image00127.jpg)![](Image00128.jpg)'
  id: totrans-5884
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00127.jpg)![](Image00128.jpg)'
- en: Just like when we added an item to the middle of our array and all the items
    scooted over to make room, if you remove an item from the middle of an array,
    the rest of the items will scoot back to fill in that empty space. The "apples"
    item that was at index 3 is now at index 2, where "candy" was.
  id: totrans-5885
  prefs: []
  type: TYPE_NORMAL
  zh: 就像我们向数组中间添加项目时，所有的项目都会挪动以腾出空间一样，如果你从数组的中间删除一个项目，剩余的项目会自动挪回，填补那个空位。原本在索引3处的"apples"项目现在位于索引2处，那里原本是"candy"。
- en: 'You can also remove all items from an array with removeAll() . Try entering
    this into your playground:'
  id: totrans-5886
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以使用removeAll()删除数组中的所有项目。试试在你的游乐场中输入这个：
- en: '![](Image00129.jpg)'
  id: totrans-5887
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00129.jpg)'
- en: 'Note that trying to remove an item at an index that doesn’t exist will give
    you an error:'
  id: totrans-5888
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，尝试删除一个不存在的索引处的项目会引发错误：
- en: '![](Image00130.jpg)'
  id: totrans-5889
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00130.jpg)'
- en: Our array doesn’t have this many items (in fact, now it’s empty!), so this throws
    an error. We’ll also get an error if we use removeLast() on our empty array, because
    there’s nothing in it—there’s no last index at all! However, removeAll() is always
    safe to use, even on an empty array.
  id: totrans-5890
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的数组并没有这么多项目（事实上，现在它是空的！），所以这会抛出一个错误。如果我们在空数组上使用removeLast()，也会出现错误，因为它里面没有任何内容——根本没有最后一个索引！然而，removeAll()方法总是安全的，即使在空数组上使用也是如此。
- en: '**REPLACING ITEMS IN AN ARRAY**'
  id: totrans-5891
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**替换数组中的项目**'
- en: 'To replace an item in an array, you set the index of the array to the new value,
    as shown here:'
  id: totrans-5892
  prefs: []
  type: TYPE_NORMAL
  zh: 要替换数组中的一个项，你需要将数组索引设置为新的值，如下所示：
- en: '![](Image00131.jpg)'
  id: totrans-5893
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00131.jpg)'
- en: At ➊ , we replaced the item at index 2 (the third item) with "Unicorn" because
    magical animals count as favorite animals, too! At ➋ , we replaced the item at
    index 0 (the first item) with "Bearded dragon" . No, that’s not a real dragon—it’s
    just a lizard!
  id: totrans-5894
  prefs: []
  type: TYPE_NORMAL
  zh: 在 ➊ 处，我们将索引为2（第三个项目）的项替换为"独角兽"，因为魔法动物也算作最喜欢的动物！在 ➋ 处，我们将索引为0（第一个项目）的项替换为"胡须龙"。不，那不是一条真正的龙——它只是一个蜥蜴！
- en: Like any time you’re working with array index numbers, you have to be sure an
    item exists in the array at that index before you change its value, or you will
    get an Index out of range error.
  id: totrans-5895
  prefs: []
  type: TYPE_NORMAL
  zh: 就像你在处理数组索引时一样，必须确保在更改数组值之前，指定索引处确实存在一个项，否则你将遇到“索引超出范围”错误。
- en: '[Figure 6-3](text00016.html#ch06fig3) shows the error that occurs if you try
    to add "Standard poodle" using favoriteAnimals[3] = "Standard poodle" . To add
    an item to the end of an array, you should use the append(_:) method or += , as
    we covered in “[Adding Items to an Array](text00016.html#ch06lev2sec5) ” on [page
    70](text00016.html#page_70) .'
  id: totrans-5896
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 6-3](text00016.html#ch06fig3)展示了如果你尝试通过favoriteAnimals[3] = "Standard poodle"来添加"标准贵宾犬"时发生的错误。要向数组的末尾添加项目，应该使用append(_:)方法或+=，正如我们在“[向数组添加项目](text00016.html#ch06lev2sec5)”中在[第70页](text00016.html#page_70)讨论过的那样。'
- en: '![Image](Image00132.jpg)'
  id: totrans-5897
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Image00132.jpg)'
- en: '*Figure 6-3: Don’t try to replace a value at an index beyond the existing array.*'
  id: totrans-5898
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 6-3：不要尝试替换超出现有数组索引的值。*'
- en: Now you know how to change arrays however you might need to. You can add items,
    take items away, or replace items. Next, we’ll look at how to use the properties
    of arrays to find out even more information about them.
  id: totrans-5899
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经知道如何根据需要更改数组了。你可以添加项目、删除项目或替换项目。接下来，我们将了解如何使用数组的属性来获取更多关于数组的信息。
- en: '![Image](Image00133.jpg)'
  id: totrans-5900
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Image00133.jpg)'
- en: '**USING ARRAY PROPERTIES**'
  id: totrans-5901
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**使用数组属性**'
- en: In addition to methods like append(_:) and removeLast() , arrays also have *properties*
    . An array’s properties are variables or constants that contain some information
    about the array. Two really helpful properties that you might use are the Boolean
    property isEmpty and the integer property count .
  id: totrans-5902
  prefs: []
  type: TYPE_NORMAL
  zh: 除了像append(_:)和removeLast()这样的操作方法，数组还有*属性*。数组的属性是包含数组某些信息的变量或常量。两个非常有用的属性是布尔属性isEmpty和整数属性count。
- en: The isEmpty property is true or false depending on whether the array is empty,
    and the count property will tell you how many items are in that array.
  id: totrans-5903
  prefs: []
  type: TYPE_NORMAL
  zh: isEmpty属性的值为true或false，具体取决于数组是否为空，而count属性会告诉你数组中有多少项。
- en: 'Check out how these two properties are used in the following if-else statement:'
  id: totrans-5904
  prefs: []
  type: TYPE_NORMAL
  zh: 看一下在以下if-else语句中如何使用这两个属性：
- en: '![Image](Image00134.jpg)'
  id: totrans-5905
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Image00134.jpg)'
- en: 'This if-else statement checks whether the array mySiblings is empty ➊ . If
    it is, then "I don''t have any siblings." is printed. But if there is something
    in the array, then the number of siblings that we have is printed: "I have 3 siblings."
    ➋ .'
  id: totrans-5906
  prefs: []
  type: TYPE_NORMAL
  zh: 这个if-else语句检查数组mySiblings是否为空 ➊。如果为空，那么会打印出“我没有兄弟姐妹”。如果数组中有内容，则会打印出我们有几个兄弟姐妹：“我有3个兄弟姐妹。”
    ➋。
- en: '**LOOPING OVER AN ARRAY**'
  id: totrans-5907
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**遍历数组**'
- en: 'Sometimes when you’re working with arrays you might want to do something to
    every item in the array. You can use a for-in loop to do that! The following code
    will print every topping in a pizzaToppings array on a separate line:'
  id: totrans-5908
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，在处理数组时，你可能想对数组中的每个项执行相同的操作。你可以使用for-in循环来实现！以下代码将每个披萨配料打印到单独的一行：
- en: '![Image](Image00135.jpg)'
  id: totrans-5909
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Image00135.jpg)'
- en: To write a for-in loop for the pizzaToppings array, we used the keyword for
    , followed by the constant topping , then the keyword in , and finally the name
    of our array, pizzaToppings . Then we put the statements that we want to run for
    each topping inside the braces of the for-in loop. The constant topping ➊ temporarily
    represents each pizza topping in the array as we loop through it. We could have
    chosen any name for this constant, but it’s a good idea to pick something that
    makes sense. You can see the output of this for-in loop in [Figure 6-4](text00016.html#ch06fig4)
    .
  id: totrans-5910
  prefs: []
  type: TYPE_NORMAL
  zh: 要为pizzaToppings数组编写for-in循环，我们使用了关键字for，后面跟着常量topping，然后是关键字in，最后是数组的名称pizzaToppings。然后，我们将希望对每个配料执行的语句放在for-in循环的花括号内。常量topping
    ➊ 在我们遍历数组时暂时代表数组中的每个披萨配料。我们本可以选择任何名称，但选择一个有意义的名称是个好主意。你可以在[图 6-4](text00016.html#ch06fig4)中看到这个for-in循环的输出。
- en: '![Image](Image00136.jpg)'
  id: totrans-5911
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Image00136.jpg)'
- en: '*Figure 6-4: Output of the example for-in loop*'
  id: totrans-5912
  prefs: []
  type: TYPE_NORMAL
  zh: '*图6-4：示例for-in循环的输出*'
- en: '![Image](Image00137.jpg)'
  id: totrans-5913
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00137.jpg)'
- en: 'Using for-in loops is great for printing every value in an array. If you’re
    working with numbers, you can even use them to perform math operations on each
    item, which makes for some speedy calculations! The following code takes an array
    of numbers and calculates the square for each (the square of a number is that
    number multiplied by itself):'
  id: totrans-5914
  prefs: []
  type: TYPE_NORMAL
  zh: 使用for-in循环非常适合打印数组中的每个值。如果你在处理数字，甚至可以用它们对每个项目执行数学运算，从而加速计算！以下代码获取一个数字数组并计算每个数字的平方（数字的平方是该数字与其自身相乘）：
- en: '![Image](Image00138.jpg)'
  id: totrans-5915
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00138.jpg)'
- en: '[Figure 6-5](text00016.html#ch06fig5) shows the results.'
  id: totrans-5916
  prefs: []
  type: TYPE_NORMAL
  zh: '[图6-5](text00016.html#ch06fig5)展示了结果。'
- en: '![Image](Image00139.jpg)'
  id: totrans-5917
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00139.jpg)'
- en: '*Figure 6-5: Printing the squares for each number in the myNumbers array*'
  id: totrans-5918
  prefs: []
  type: TYPE_NORMAL
  zh: '*图6-5：打印myNumbers数组中每个数字的平方*'
- en: '**DICTIONARIES ARE KEY!**'
  id: totrans-5919
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**字典至关重要！**'
- en: A *dictionary* is also a collection of values, but instead of an ordered index,
    each value has its own *key* . Because there’s no index, the values are not stored
    in any particular order. To access values in a dictionary, you look them up by
    their key.
  id: totrans-5920
  prefs: []
  type: TYPE_NORMAL
  zh: 一个*字典*也是一个值的集合，但与有序索引不同，每个值都有它自己的*键*。由于没有索引，值不会按特定顺序存储。要访问字典中的值，你需要通过它们的键来查找。
- en: A key must be unique. You can’t have the same key more than once in the same
    dictionary. If there were two identical keys and you asked the computer to give
    you the value for one of them, the computer wouldn’t know which one to choose!
  id: totrans-5921
  prefs: []
  type: TYPE_NORMAL
  zh: 键必须是唯一的。在同一个字典中不能有重复的键。如果有两个相同的键，并且你要求计算机给你其中一个的值，计算机就无法知道选择哪个！
- en: Let’s take a look at how to make a dictionary and write keys that will help
    you find all the information you need.
  id: totrans-5922
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看如何创建一个字典并写下有助于你找到所需信息的键。
- en: '![Image](Image00140.jpg)'
  id: totrans-5923
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00140.jpg)'
- en: '**INITIALIZING A DICTIONARY**'
  id: totrans-5924
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**初始化字典**'
- en: 'To create and initialize a dictionary, first write var and the name of your
    dictionary. Then write the keys and corresponding values inside a pair of square
    brackets, similar to an array. Let’s create a dictionary to store the names of
    a few US states. The key for each state will be its two-letter abbreviation:'
  id: totrans-5925
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建和初始化一个字典，首先写上var和字典的名称。然后在一对方括号内写上键和对应的值，类似于数组。让我们创建一个字典来存储一些美国州的名称。每个州的键将是它的两字母缩写：
- en: '![](Image00141.jpg)'
  id: totrans-5926
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00141.jpg)'
- en: As you can see, there’s a colon between each key and its value, and the key/value
    pairs are separated by commas.
  id: totrans-5927
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，键和值之间有一个冒号，键值对由逗号分隔。
- en: Dictionaries are different from arrays in that they are *unordered* . Because
    of that, it’s likely that the order of the states that you see in your results
    pane ➋ is different from the order in which you entered your states ➊ . It might
    even be different than the order that’s printed in this book!
  id: totrans-5928
  prefs: []
  type: TYPE_NORMAL
  zh: 字典与数组不同，因为它们是*无序*的。因此，你看到的结果窗格中的州的顺序➋很可能与输入字典时州的顺序➊不同。它甚至可能与本书中打印的顺序不同！
- en: As with arrays, you can use var to make a mutable dictionary or use let to make
    an immutable dictionary.
  id: totrans-5929
  prefs: []
  type: TYPE_NORMAL
  zh: 与数组一样，你可以使用var来创建一个可变字典，或者使用let来创建一个不可变字典。
- en: 'In Swift, all of the keys of a dictionary must be the same type, and all of
    the values of a dictionary must also be the same type, but the key type doesn’t
    have to match the value type. For example, if you wanted to store a collection
    of fractions, you could use doubles for the keys and strings for the values:'
  id: totrans-5930
  prefs: []
  type: TYPE_NORMAL
  zh: 在Swift中，字典的所有键必须是相同类型的，字典的所有值也必须是相同类型的，但键类型不一定需要与值类型匹配。例如，如果你想存储一组分数，你可以将键设置为双精度浮点数，而值设置为字符串：
- en: '![](Image00142.jpg)'
  id: totrans-5931
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00142.jpg)'
- en: In this dictionary, all of the keys must be doubles, and all of the values must
    be strings. Again, you’ll see that the order of the numbers in the results pane
    can be quite different from the order in which you wrote the fractions in your
    dictionary. This is fine because you don’t need to know the order to access anything.
    You can find any item that you need by its key. Let’s see how!
  id: totrans-5932
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个字典中，所有的键必须是双精度浮点数，所有的值必须是字符串。同样，你会发现结果窗格中数字的顺序可能与字典中分数的顺序完全不同。这是没问题的，因为你不需要知道顺序就能访问任何项。你可以通过键找到任何需要的项目。让我们看看怎么做！
- en: '**ACCESSING VALUES IN A DICTIONARY**'
  id: totrans-5933
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**访问字典中的值**'
- en: 'Looking up a value in a dictionary is similar to how you access a value in
    an array except that you use a key inside the square brackets instead of an index,
    like this: usStates["TX"] .'
  id: totrans-5934
  prefs: []
  type: TYPE_NORMAL
  zh: 在字典中查找一个值与在数组中访问值类似，只不过你是用方括号中的键来访问，而不是用索引，像这样：usStates["TX"] 。
- en: There is a big difference, however, in how Swift returns the values from a dictionary.
    When you access a value at an index of an array, you are simply given the value.
    When you access a value with a key in a dictionary, you are given an optional.
  id: totrans-5935
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，Swift 返回字典值的方式与从数组中访问值有很大不同。当你通过数组的索引访问值时，你会直接得到值。当你通过字典的键访问值时，你得到的是一个可选项。
- en: In [Chapter 5](text00015.html#ch05) , you learned that optionals might contain
    a value or might be nil . The reason Swift returns optionals when you’re looking
    up items in a dictionary is that the key you used might not exist in the dictionary,
    in which case there’s no value to access. Trying to access a value that doesn’t
    exist would give you a big fat error! To avoid that problem, Swift returns optionals.
    That means you need to unwrap any value you get out of a dictionary before you
    can do anything with it.
  id: totrans-5936
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第5章](text00015.html#ch05)中，你已经学习了可选项可能包含一个值，也可能是 nil 。Swift 在查找字典中的项时返回可选项的原因是，你使用的键可能在字典中不存在，在这种情况下，就没有值可供访问。尝试访问不存在的值会导致一个大错误！为避免这个问题，Swift
    返回可选项。这意味着，在对字典中的值进行任何操作之前，你需要解包你从字典中获取的值。
- en: 'To unwrap an optional, first you check whether it exists using an if-let statement,
    just like we did in [Chapter 5](text00015.html#ch05) . The following code shows
    you how to get a value out of a dictionary:'
  id: totrans-5937
  prefs: []
  type: TYPE_NORMAL
  zh: 要解包一个可选项，首先你需要使用 if-let 语句检查它是否存在，就像我们在[第5章](text00015.html#ch05)中所做的那样。以下代码展示了如何从字典中获取一个值：
- en: '![Image](Image00143.jpg)'
  id: totrans-5938
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00143.jpg)'
- en: To retrieve "Texas" from the dictionary, we use if let to set a constant loneStarState
    to usStates["TX"] ➊ . Because we have this state in our dictionary, the line I
    have Texas in my dictionary. is printed. Next we try to access a state that is
    not in our dictionary by using the key usStates["FL"] ➋ . Thankfully, because
    we used an if-let statement, the program won’t crash when the computer can’t find
    this state. Instead, I don't have that state in my dictionary. is printed.
  id: totrans-5939
  prefs: []
  type: TYPE_NORMAL
  zh: 要从字典中获取 "德克萨斯"，我们使用 if let 来将常量 loneStarState 设置为 usStates["TX"] ➊ 。因为我们在字典中有这个州，所以会打印出
    "我在字典中有德克萨斯"。接下来，我们尝试通过使用键 usStates["FL"] ➋ 来访问一个字典中没有的州。幸运的是，由于我们使用了 if-let 语句，当计算机找不到该州时，程序不会崩溃。而是会打印出
    "我字典中没有这个州"。
- en: '**ADDING ITEMS TO A DICTIONARY**'
  id: totrans-5940
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**向字典中添加项**'
- en: 'To add an item to a dictionary, first write the name of your dictionary and
    assign the new item to the key you want it to have in the dictionary. Let’s add
    "Minnesota" to our usStates dictionary:'
  id: totrans-5941
  prefs: []
  type: TYPE_NORMAL
  zh: 要向字典中添加一项，首先写出字典的名称，并将新项赋值给你希望它在字典中拥有的键。让我们向我们的 usStates 字典中添加 "明尼苏达"：
- en: '![](Image00144.jpg)'
  id: totrans-5942
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00144.jpg)'
- en: 'Now when you look at usStates , you’ll see that it’s updated to ["MN": "Minnesota",
    "WA": "Washington", "MA": "Massachusetts", "TX": "Texas"] . Remember, because
    you don’t have to rely on indices, your new dictionary item might appear anywhere
    in the dictionary.'
  id: totrans-5943
  prefs: []
  type: TYPE_NORMAL
  zh: '现在，当你查看 usStates 时，你会看到它已更新为 ["MN": "明尼苏达", "WA": "华盛顿", "MA": "马萨诸塞", "TX":
    "德克萨斯"] 。记住，由于你不需要依赖索引，新的字典项可能会出现在字典的任何位置。'
- en: '**REMOVING ITEMS FROM A DICTIONARY**'
  id: totrans-5944
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**从字典中移除项**'
- en: Removing an item from a dictionary is quite simple; you do so by setting the
    value to nil . Because the values in dictionaries are returned as optionals, you
    don’t have to worry about nil causing any problems in your dictionary.
  id: totrans-5945
  prefs: []
  type: TYPE_NORMAL
  zh: 从字典中移除项非常简单；你只需将该值设置为 nil 。因为字典中的值是以可选项的形式返回的，所以你无需担心 nil 会在字典中引起任何问题。
- en: '![](Image00145.jpg)'
  id: totrans-5946
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00145.jpg)'
- en: 'You can see that after you remove the value at the key "MA" , usStates is updated
    to ["MN": "Minnesota", "WA": "Washington", "TX": "Texas"] . Remember that nil
    is special and means that there’s no value at all. That’s why you don’t see "MA":
    nil in our dictionary.'
  id: totrans-5947
  prefs: []
  type: TYPE_NORMAL
  zh: '你可以看到，当你移除键 "MA" 的值后，usStates 更新为 ["MN": "明尼苏达", "WA": "华盛顿", "TX": "德克萨斯"]
    。记住，nil 是特殊的，它意味着完全没有值。这就是为什么你在字典中看不到 "MA": nil 的原因。'
- en: '**REPLACING ITEMS IN A DICTIONARY**'
  id: totrans-5948
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**替换字典中的项**'
- en: 'Replacing an item in a dictionary is also easy. It works the same was as replacing
    an item in an array. You just set the item that you want to replace to something
    else. Say you create a dictionary of fruit colors:'
  id: totrans-5949
  prefs: []
  type: TYPE_NORMAL
  zh: 替换字典中的项也很简单。它与替换数组中的项相同。你只需将你想替换的项设置为其他内容。假设你创建了一个水果颜色的字典：
- en: '![](Image00146.jpg)'
  id: totrans-5950
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00146.jpg)'
- en: At first we had the value "apple" for "red" , but then we decided that "raspberry"
    is a better fruit to use since sometimes apples are green or yellow. To replace
    "apple" with "raspberry" , we set colorFruits["red"] to its new value ➊ .
  id: totrans-5951
  prefs: []
  type: TYPE_NORMAL
  zh: 最初我们为“red”设置了“apple”的值，但后来我们决定“raspberry”是一个更好的水果选择，因为有时苹果是绿色或黄色的。为了用“raspberry”替换“apple”，我们将colorFruits["red"]设置为其新值➊。
- en: You may remember that this is the same way we entered a new value into a dictionary.
    If the key already exists in the dictionary, then the value for that key is replaced.
    If the key doesn’t already exist, then the new key/value pair will be added to
    the dictionary.
  id: totrans-5952
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能记得，这是我们将新值输入字典的相同方式。如果键已经存在于字典中，那么该键的值会被替换。如果键不存在，那么新的键/值对将被添加到字典中。
- en: '![Image](Image00147.jpg)'
  id: totrans-5953
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00147.jpg)'
- en: '**USING DICTIONARY PROPERTIES**'
  id: totrans-5954
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**使用字典属性**'
- en: 'Like an array, a dictionary also has an isEmpty property and a count property.
    For example, the following code shows how you can use the isEmpty property to
    check if a dictionary is empty, and if it isn’t empty, the count property checks
    how many items you have. Imagine you have a basket of fruit for sale. You can
    use these properties to help you keep track of everything:'
  id: totrans-5955
  prefs: []
  type: TYPE_NORMAL
  zh: 像数组一样，字典也有isEmpty属性和count属性。例如，以下代码展示了如何使用isEmpty属性检查字典是否为空，如果不为空，count属性将检查你有多少项。假设你有一个待售的水果篮子，你可以使用这些属性来帮助你跟踪所有内容：
- en: '![Image](Image00148.jpg)'
  id: totrans-5956
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00148.jpg)'
- en: 'A dictionary also has two special properties: keys , which contains all of
    the dictionary’s keys, and values , which contains all of its values. We’ll use
    these two properties when we loop through the dictionary.'
  id: totrans-5957
  prefs: []
  type: TYPE_NORMAL
  zh: 字典还有两个特殊属性：keys，它包含字典的所有键，以及values，它包含字典的所有值。我们将在循环字典时使用这两个属性。
- en: Let’s write some code that loops through our fruit baskets and prints the price
    of each fruit.
  id: totrans-5958
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们写一些代码，循环遍历我们的水果篮子并打印每个水果的价格。
- en: '**LOOPING OVER A DICTIONARY**'
  id: totrans-5959
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**循环遍历字典**'
- en: 'You can loop through a dictionary using a for-in loop. Because each item has
    a key and a value, you can do this in two different ways. This is how to loop
    through a dictionary using its keys:'
  id: totrans-5960
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用for-in循环遍历字典。因为每个项都有一个键和值，所以你可以通过两种不同的方式来实现。以下是如何使用字典的键来循环遍历字典：
- en: '![Image](Image00149.jpg)'
  id: totrans-5961
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00149.jpg)'
- en: Here we use the dictionary’s keys property ➊ to loop through fruitBasket and
    print its contents. We start by writing the keyword for , followed by a constant
    name fruit for the dictionary key, the keyword in , the dictionary name, a period,
    and keys .
  id: totrans-5962
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们使用字典的keys属性➊来循环遍历fruitBasket并打印其内容。我们从写关键字for开始，后面跟一个常量名称fruit，表示字典的键，再写关键字in，字典名称，句点，以及keys。
- en: Inside the braces of our for-in loop, we have access to both the key, which
    we call fruit ➋ , and the value at that key when we force-unwrap its contents
    with fruitBasket[fruit]! ➌ . That value will be the fruit’s price.
  id: totrans-5963
  prefs: []
  type: TYPE_NORMAL
  zh: 在for-in循环的大括号内，我们可以访问键（我们称之为fruit➋）以及当我们强制解包其内容时，通过fruitBasket[fruit]!➌获取的该键的值。这个值将是水果的价格。
- en: In this case, it’s safe to force-unwrap the value using an exclamation point
    because we know that the fruit key we’re using is definitely inside the dictionary.
  id: totrans-5964
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，使用感叹号强制解包值是安全的，因为我们知道我们使用的fruit键肯定在字典中。
- en: Any code we put inside the for-in loop will run once for every key in our dictionary.
    So you should see the print statement display three times.
  id: totrans-5965
  prefs: []
  type: TYPE_NORMAL
  zh: 我们放入for-in循环中的任何代码都会对字典中的每个键执行一次。所以你应该会看到打印语句显示三次。
- en: 'We can also loop through the dictionary using its values property:'
  id: totrans-5966
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以使用字典的values属性来循环遍历：
- en: '![Image](Image00150.jpg)'
  id: totrans-5967
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00150.jpg)'
- en: We use the same style of for-in loop, but now we use a constant to refer to
    each value, which we call price , in the values property. When looping through
    values, we don’t have access to the keys from inside the loop.
  id: totrans-5968
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用相同的for-in循环风格，但现在我们使用常量来引用values属性中的每个值，我们称其为price。当循环遍历values时，我们无法在循环内部访问键。
- en: Another difference to note is that price is not an optional because it’s accessed
    directly as a value in the fruitBasket dictionary. That means we don’t have to
    unwrap it. You should still see the print statement printed three times. [Figure
    6-6](text00016.html#ch06fig6) shows the output of both loops.
  id: totrans-5969
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个需要注意的区别是，price不是一个可选值，因为它是直接作为值访问fruitBasket字典中的内容。这意味着我们不需要解包它。你仍然应该看到打印语句显示三次。[图6-6](text00016.html#ch06fig6)展示了两个循环的输出。
- en: '![Image](Image00151.jpg)'
  id: totrans-5970
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00151.jpg)'
- en: '*Figure 6-6: Looping through the keys and values of a dictionary with a for-in
    loop*'
  id: totrans-5971
  prefs: []
  type: TYPE_NORMAL
  zh: '*图6-6：使用for-in循环遍历字典的键和值*'
- en: The order of your results might be slightly different from ours. That’s because
    the items in a dictionary aren’t in a numbered order like they are in an array!
    And because the order is not guaranteed, you might see a different order printed
    if you run the same code again.
  id: totrans-5972
  prefs: []
  type: TYPE_NORMAL
  zh: 你的结果顺序可能会与我们的略有不同。这是因为字典中的项不像数组那样是按编号顺序排列的！而且由于顺序无法保证，如果你再次运行相同的代码，可能会看到不同的打印顺序。
- en: '**WHAT YOU LEARNED**'
  id: totrans-5973
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**你学到的内容**'
- en: In this chapter, you learned how to store collections of items in an array and
    in a dictionary. To store items in an ordered list, you would use an array and
    look up each item by its index. If you wanted to store items by key instead, you
    would use a dictionary.
  id: totrans-5974
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你学会了如何在数组和字典中存储项。要存储有序的列表，你会使用数组，并通过索引查找每个项。如果你想通过键来存储项，你会使用字典。
- en: Knowing about arrays and dictionaries and how to use them is a powerful building
    block for almost any programming language. Next we will learn about functions,
    another very powerful tool. Functions are blocks of code that you create and name
    to perform a specific job. After you have written a function, you can use its
    name to call it from almost anywhere in your program.
  id: totrans-5975
  prefs: []
  type: TYPE_NORMAL
  zh: 了解数组和字典以及如何使用它们，是几乎所有编程语言的强大构建块。接下来我们将学习函数，另一个非常强大的工具。函数是你创建并命名的代码块，用来执行特定任务。写完一个函数后，你可以通过它的名称在程序中的几乎任何地方调用它。
- en: '![](Image00124.jpg)'
  id: totrans-5976
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00124.jpg)'
- en: Note that ["whipped cream"] is an array even though it has a single item in
    it. When you’re using += to append something to an array, you have to make sure
    you’re only trying to add another array. If you were to just write the string
    "whipped cream" without the square brackets around it, you would get an error.
  id: totrans-5977
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，["whipped cream"]是一个数组，尽管它只包含一个项。当你使用+=向数组中添加内容时，必须确保你只是尝试添加另一个数组。如果你只是写了字符串"whipped
    cream"而没有加上方括号，你会得到一个错误。
- en: '![Image](Image00125.jpg)'
  id: totrans-5978
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00125.jpg)'
- en: '**REMOVING ITEMS FROM AN ARRAY**'
  id: totrans-5979
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**从数组中移除项**'
- en: 'There are several methods for removing items from an array. Let’s start by
    looking at the array’s removeLast() method. As you might have guessed from its
    name, removeLast() removes the last item from your array. Let’s try it out with
    a shoppingList array:'
  id: totrans-5980
  prefs: []
  type: TYPE_NORMAL
  zh: 有几种方法可以从数组中移除项。我们从查看数组的removeLast()方法开始。正如你从其名称中可能猜到的，removeLast()会移除数组中的最后一项。我们可以尝试在一个shoppingList数组上操作：
- en: '![](Image00126.jpg)'
  id: totrans-5981
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00126.jpg)'
- en: Neat! Note that the removeLast() method returns the removed item, so you can
    store it in a new constant or variable if you want.
  id: totrans-5982
  prefs: []
  type: TYPE_NORMAL
  zh: 很棒！注意，removeLast()方法会返回被移除的项，因此如果需要，你可以将它存储在一个新的常量或变量中。
- en: 'You can also remove an item from a specific index by using the remove(at:)
    method. Let’s say that your mom doesn’t want you buying any candy and takes that
    off the list:'
  id: totrans-5983
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以通过使用remove(at:)方法从特定索引移除一项。假设你的妈妈不希望你买糖果，并且把它从清单上移除：
- en: '![Image](Image00127.jpg)![](Image00128.jpg)'
  id: totrans-5984
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00127.jpg)![](Image00128.jpg)'
- en: Just like when we added an item to the middle of our array and all the items
    scooted over to make room, if you remove an item from the middle of an array,
    the rest of the items will scoot back to fill in that empty space. The "apples"
    item that was at index 3 is now at index 2, where "candy" was.
  id: totrans-5985
  prefs: []
  type: TYPE_NORMAL
  zh: 就像我们在数组中间添加项时，所有项都会向旁边移动以腾出空间一样，如果你从数组中间移除一个项，其它项会向回挪动以填补空缺。原本在索引3处的"apples"项现在会出现在索引2的位置，原本"candy"项所在的位置。
- en: 'You can also remove all items from an array with removeAll() . Try entering
    this into your playground:'
  id: totrans-5986
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以使用removeAll()方法移除数组中的所有项。试着将这个输入到你的playground中：
- en: '![](Image00129.jpg)'
  id: totrans-5987
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00129.jpg)'
- en: 'Note that trying to remove an item at an index that doesn’t exist will give
    you an error:'
  id: totrans-5988
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，尝试从一个不存在的索引移除项将会给你一个错误：
- en: '![](Image00130.jpg)'
  id: totrans-5989
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00130.jpg)'
- en: Our array doesn’t have this many items (in fact, now it’s empty!), so this throws
    an error. We’ll also get an error if we use removeLast() on our empty array, because
    there’s nothing in it—there’s no last index at all! However, removeAll() is always
    safe to use, even on an empty array.
  id: totrans-5990
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的数组并没有这么多项（事实上，现在它是空的！），因此这会抛出一个错误。如果我们在空数组上使用removeLast()，也会得到一个错误，因为数组中什么都没有——根本没有最后一个索引！然而，removeAll()在任何情况下都是安全的，即使是在空数组上使用。
- en: '**REPLACING ITEMS IN AN ARRAY**'
  id: totrans-5991
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**替换数组中的项**'
- en: 'To replace an item in an array, you set the index of the array to the new value,
    as shown here:'
  id: totrans-5992
  prefs: []
  type: TYPE_NORMAL
  zh: 要替换数组中的项，你可以将数组的索引设置为新值，如下所示：
- en: '![](Image00131.jpg)'
  id: totrans-5993
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00131.jpg)'
- en: At ➊ , we replaced the item at index 2 (the third item) with "Unicorn" because
    magical animals count as favorite animals, too! At ➋ , we replaced the item at
    index 0 (the first item) with "Bearded dragon" . No, that’s not a real dragon—it’s
    just a lizard!
  id: totrans-5994
  prefs: []
  type: TYPE_NORMAL
  zh: 在 ➊ 处，我们用"Unicorn"替换了索引为 2（第三个项）的位置，因为魔法动物也算是最喜欢的动物！在 ➋ 处，我们用"Bearded dragon"替换了索引为
    0（第一个项）的位置。不是的，那可不是真正的龙——它只是一个蜥蜴！
- en: Like any time you’re working with array index numbers, you have to be sure an
    item exists in the array at that index before you change its value, or you will
    get an Index out of range error.
  id: totrans-5995
  prefs: []
  type: TYPE_NORMAL
  zh: 就像在处理数组索引时一样，你必须确保在更改某个索引处的值之前，该索引处确实存在某个项，否则你将会遇到“索引超出范围”错误。
- en: '[Figure 6-3](text00016.html#ch06fig3) shows the error that occurs if you try
    to add "Standard poodle" using favoriteAnimals[3] = "Standard poodle" . To add
    an item to the end of an array, you should use the append(_:) method or += , as
    we covered in “[Adding Items to an Array](text00016.html#ch06lev2sec5) ” on [page
    70](text00016.html#page_70) .'
  id: totrans-5996
  prefs: []
  type: TYPE_NORMAL
  zh: '[图6-3](text00016.html#ch06fig3)显示了如果你尝试使用 favoriteAnimals[3] = "Standard poodle"
    来添加"Standard poodle"时发生的错误。要将项添加到数组的末尾，你应该使用 append(_:) 方法或 += ，正如我们在“[向数组添加项](text00016.html#ch06lev2sec5)”一节中介绍的那样，[第70页](text00016.html#page_70)。'
- en: '![Image](Image00132.jpg)'
  id: totrans-5997
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00132.jpg)'
- en: '*Figure 6-3: Don’t try to replace a value at an index beyond the existing array.*'
  id: totrans-5998
  prefs: []
  type: TYPE_NORMAL
  zh: '*图6-3：不要尝试替换超出现有数组范围的索引值。*'
- en: Now you know how to change arrays however you might need to. You can add items,
    take items away, or replace items. Next, we’ll look at how to use the properties
    of arrays to find out even more information about them.
  id: totrans-5999
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你知道如何根据需要更改数组了。你可以添加项、删除项或替换项。接下来，我们将看看如何使用数组的属性来获取更多关于数组的信息。
- en: '![Image](Image00133.jpg)'
  id: totrans-6000
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00133.jpg)'
- en: '**USING ARRAY PROPERTIES**'
  id: totrans-6001
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**使用数组属性**'
- en: In addition to methods like append(_:) and removeLast() , arrays also have *properties*
    . An array’s properties are variables or constants that contain some information
    about the array. Two really helpful properties that you might use are the Boolean
    property isEmpty and the integer property count .
  id: totrans-6002
  prefs: []
  type: TYPE_NORMAL
  zh: 除了像 append(_:) 和 removeLast() 这样的函数，数组还有 *属性* 。数组的属性是包含数组相关信息的变量或常量。你可能会用到的两个非常有用的属性是布尔值属性
    isEmpty 和整数属性 count 。
- en: The isEmpty property is true or false depending on whether the array is empty,
    and the count property will tell you how many items are in that array.
  id: totrans-6003
  prefs: []
  type: TYPE_NORMAL
  zh: isEmpty 属性的值为 true 或 false，取决于数组是否为空，而 count 属性会告诉你数组中有多少项。
- en: 'Check out how these two properties are used in the following if-else statement:'
  id: totrans-6004
  prefs: []
  type: TYPE_NORMAL
  zh: 查看以下 if-else 语句中如何使用这两个属性：
- en: '![Image](Image00134.jpg)'
  id: totrans-6005
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00134.jpg)'
- en: 'This if-else statement checks whether the array mySiblings is empty ➊ . If
    it is, then "I don''t have any siblings." is printed. But if there is something
    in the array, then the number of siblings that we have is printed: "I have 3 siblings."
    ➋ .'
  id: totrans-6006
  prefs: []
  type: TYPE_NORMAL
  zh: 这个 if-else 语句检查数组 mySiblings 是否为空 ➊ 。如果为空，则打印出 "我没有兄弟姐妹"。如果数组中有内容，则打印出我们拥有的兄弟姐妹数量：“我有
    3 个兄弟姐妹。” ➋ 。
- en: '**LOOPING OVER AN ARRAY**'
  id: totrans-6007
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**循环遍历数组**'
- en: 'Sometimes when you’re working with arrays you might want to do something to
    every item in the array. You can use a for-in loop to do that! The following code
    will print every topping in a pizzaToppings array on a separate line:'
  id: totrans-6008
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，当你处理数组时，可能想对数组中的每个项执行某些操作。你可以使用 for-in 循环来做到这一点！以下代码将在单独的一行上打印出 pizzaToppings
    数组中的每个配料：
- en: '![Image](Image00135.jpg)'
  id: totrans-6009
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00135.jpg)'
- en: To write a for-in loop for the pizzaToppings array, we used the keyword for
    , followed by the constant topping , then the keyword in , and finally the name
    of our array, pizzaToppings . Then we put the statements that we want to run for
    each topping inside the braces of the for-in loop. The constant topping ➊ temporarily
    represents each pizza topping in the array as we loop through it. We could have
    chosen any name for this constant, but it’s a good idea to pick something that
    makes sense. You can see the output of this for-in loop in [Figure 6-4](text00016.html#ch06fig4)
    .
  id: totrans-6010
  prefs: []
  type: TYPE_NORMAL
  zh: 要为 pizzaToppings 数组编写 for-in 循环，我们使用了关键字 for，后面是常量 topping，然后是关键字 in，最后是我们的数组名称
    pizzaToppings 。然后，我们将希望对每个配料执行的语句放在 for-in 循环的大括号内。常量 topping ➊ 在我们遍历数组时暂时代表每个配料。我们可以为这个常量选择任何名字，但最好选择一个有意义的名字。你可以在[图6-4](text00016.html#ch06fig4)中看到这个
    for-in 循环的输出。
- en: '![Image](Image00136.jpg)'
  id: totrans-6011
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00136.jpg)'
- en: '*Figure 6-4: Output of the example for-in loop*'
  id: totrans-6012
  prefs: []
  type: TYPE_NORMAL
  zh: '*图6-4：示例 for-in 循环的输出*'
- en: '![Image](Image00137.jpg)'
  id: totrans-6013
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00137.jpg)'
- en: 'Using for-in loops is great for printing every value in an array. If you’re
    working with numbers, you can even use them to perform math operations on each
    item, which makes for some speedy calculations! The following code takes an array
    of numbers and calculates the square for each (the square of a number is that
    number multiplied by itself):'
  id: totrans-6014
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 for-in 循环非常适合打印数组中的每个值。如果你处理的是数字，甚至可以用它们对每个项目执行数学运算，这使得计算速度非常快！以下代码取一个数字数组并计算每个数字的平方（一个数字的平方是该数字与其本身相乘）：
- en: '![Image](Image00138.jpg)'
  id: totrans-6015
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00138.jpg)'
- en: '[Figure 6-5](text00016.html#ch06fig5) shows the results.'
  id: totrans-6016
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 6-5](text00016.html#ch06fig5)展示了结果。'
- en: '![Image](Image00139.jpg)'
  id: totrans-6017
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00139.jpg)'
- en: '*Figure 6-5: Printing the squares for each number in the myNumbers array*'
  id: totrans-6018
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 6-5：打印 myNumbers 数组中每个数字的平方*'
- en: '**DICTIONARIES ARE KEY!**'
  id: totrans-6019
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**字典是关键！**'
- en: A *dictionary* is also a collection of values, but instead of an ordered index,
    each value has its own *key* . Because there’s no index, the values are not stored
    in any particular order. To access values in a dictionary, you look them up by
    their key.
  id: totrans-6020
  prefs: []
  type: TYPE_NORMAL
  zh: '*字典* 也是一个值的集合，但与数组不同的是，每个值都有自己的*键*。由于没有索引，值不会按任何特定顺序存储。要访问字典中的值，你需要通过其键来查找它们。'
- en: A key must be unique. You can’t have the same key more than once in the same
    dictionary. If there were two identical keys and you asked the computer to give
    you the value for one of them, the computer wouldn’t know which one to choose!
  id: totrans-6021
  prefs: []
  type: TYPE_NORMAL
  zh: 键必须是唯一的。同一个字典中不能有相同的键。如果有两个相同的键，并且你要求计算机返回其中一个的值，计算机就无法知道该选择哪个！
- en: Let’s take a look at how to make a dictionary and write keys that will help
    you find all the information you need.
  id: totrans-6022
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看如何创建一个字典，并编写键来帮助你找到所有需要的信息。
- en: '![Image](Image00140.jpg)'
  id: totrans-6023
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00140.jpg)'
- en: '**INITIALIZING A DICTIONARY**'
  id: totrans-6024
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**初始化字典**'
- en: 'To create and initialize a dictionary, first write var and the name of your
    dictionary. Then write the keys and corresponding values inside a pair of square
    brackets, similar to an array. Let’s create a dictionary to store the names of
    a few US states. The key for each state will be its two-letter abbreviation:'
  id: totrans-6025
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建并初始化一个字典，首先写下 var 和字典的名称。然后，将键和值对写在一对方括号内，类似于数组。我们来创建一个字典来存储一些美国州的名称。每个州的键将是它的两字母缩写：
- en: '![](Image00141.jpg)'
  id: totrans-6026
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00141.jpg)'
- en: As you can see, there’s a colon between each key and its value, and the key/value
    pairs are separated by commas.
  id: totrans-6027
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，每个键和值之间有一个冒号，键/值对之间用逗号分隔。
- en: Dictionaries are different from arrays in that they are *unordered* . Because
    of that, it’s likely that the order of the states that you see in your results
    pane ➋ is different from the order in which you entered your states ➊ . It might
    even be different than the order that’s printed in this book!
  id: totrans-6028
  prefs: []
  type: TYPE_NORMAL
  zh: 字典与数组不同，它们是*无序的*。因此，你在结果面板➋中看到的状态顺序可能与输入状态➊的顺序不同。甚至可能与书中所列的顺序不同！
- en: As with arrays, you can use var to make a mutable dictionary or use let to make
    an immutable dictionary.
  id: totrans-6029
  prefs: []
  type: TYPE_NORMAL
  zh: 和数组一样，你可以使用 var 来创建一个可变字典，或者使用 let 来创建一个不可变字典。
- en: 'In Swift, all of the keys of a dictionary must be the same type, and all of
    the values of a dictionary must also be the same type, but the key type doesn’t
    have to match the value type. For example, if you wanted to store a collection
    of fractions, you could use doubles for the keys and strings for the values:'
  id: totrans-6030
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Swift 中，字典的所有键必须是相同的类型，而字典的所有值也必须是相同的类型，但键的类型不必与值的类型匹配。例如，如果你想存储一组分数，你可以将键设置为双精度数，值设置为字符串：
- en: '![](Image00142.jpg)'
  id: totrans-6031
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00142.jpg)'
- en: In this dictionary, all of the keys must be doubles, and all of the values must
    be strings. Again, you’ll see that the order of the numbers in the results pane
    can be quite different from the order in which you wrote the fractions in your
    dictionary. This is fine because you don’t need to know the order to access anything.
    You can find any item that you need by its key. Let’s see how!
  id: totrans-6032
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个字典中，所有的键必须是双精度数，所有的值必须是字符串。同样，你会看到结果面板中的数字顺序可能与字典中分数的顺序大不相同。这没关系，因为你不需要知道顺序就能访问任何内容。你可以通过键找到你需要的任何项目。我们来看看如何实现！
- en: '**ACCESSING VALUES IN A DICTIONARY**'
  id: totrans-6033
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**访问字典中的值**'
- en: 'Looking up a value in a dictionary is similar to how you access a value in
    an array except that you use a key inside the square brackets instead of an index,
    like this: usStates["TX"] .'
  id: totrans-6034
  prefs: []
  type: TYPE_NORMAL
  zh: 查找字典中的值类似于访问数组中的值，只不过你在方括号内使用的是键而不是索引，例如：usStates["TX"]。
- en: There is a big difference, however, in how Swift returns the values from a dictionary.
    When you access a value at an index of an array, you are simply given the value.
    When you access a value with a key in a dictionary, you are given an optional.
  id: totrans-6035
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，Swift返回字典值的方式与数组有所不同。当你在数组的索引位置访问值时，你只是简单地得到该值。而当你在字典中使用键访问值时，你得到的是一个可选值。
- en: In [Chapter 5](text00015.html#ch05) , you learned that optionals might contain
    a value or might be nil . The reason Swift returns optionals when you’re looking
    up items in a dictionary is that the key you used might not exist in the dictionary,
    in which case there’s no value to access. Trying to access a value that doesn’t
    exist would give you a big fat error! To avoid that problem, Swift returns optionals.
    That means you need to unwrap any value you get out of a dictionary before you
    can do anything with it.
  id: totrans-6036
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第5章](text00015.html#ch05)中，你已经学习过可选值可能包含一个值，也可能是nil。Swift之所以在查找字典中的项时返回可选值，是因为你使用的键可能在字典中不存在，在这种情况下就没有值可供访问。如果你尝试访问一个不存在的值，就会遇到严重的错误！为了避免这个问题，Swift返回了可选值。这意味着你需要在对字典中的任何值进行操作之前，先解包它。
- en: 'To unwrap an optional, first you check whether it exists using an if-let statement,
    just like we did in [Chapter 5](text00015.html#ch05) . The following code shows
    you how to get a value out of a dictionary:'
  id: totrans-6037
  prefs: []
  type: TYPE_NORMAL
  zh: 要解包一个可选值，首先你需要使用if-let语句检查它是否存在，就像我们在[第5章](text00015.html#ch05)中所做的那样。以下代码演示了如何从字典中获取一个值：
- en: '![Image](Image00143.jpg)'
  id: totrans-6038
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00143.jpg)'
- en: To retrieve "Texas" from the dictionary, we use if let to set a constant loneStarState
    to usStates["TX"] ➊ . Because we have this state in our dictionary, the line I
    have Texas in my dictionary. is printed. Next we try to access a state that is
    not in our dictionary by using the key usStates["FL"] ➋ . Thankfully, because
    we used an if-let statement, the program won’t crash when the computer can’t find
    this state. Instead, I don't have that state in my dictionary. is printed.
  id: totrans-6039
  prefs: []
  type: TYPE_NORMAL
  zh: 要从字典中获取"Texas"，我们使用if let将常量loneStarState设置为usStates["TX"] ➊。由于我们在字典中有这个州，输出将是“我在字典中有Texas”。接下来，我们尝试访问一个字典中没有的州，使用键usStates["FL"]
    ➋。幸运的是，因为我们使用了if-let语句，当计算机无法找到该州时，程序不会崩溃。相反，会输出“我字典中没有那个州”。
- en: '**ADDING ITEMS TO A DICTIONARY**'
  id: totrans-6040
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**向字典中添加项**'
- en: 'To add an item to a dictionary, first write the name of your dictionary and
    assign the new item to the key you want it to have in the dictionary. Let’s add
    "Minnesota" to our usStates dictionary:'
  id: totrans-6041
  prefs: []
  type: TYPE_NORMAL
  zh: 要向字典中添加一个项，首先写下字典的名称，并将新项赋给你希望它在字典中具有的键。让我们将"Minnesota"添加到我们的usStates字典中：
- en: '![](Image00144.jpg)'
  id: totrans-6042
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00144.jpg)'
- en: 'Now when you look at usStates , you’ll see that it’s updated to ["MN": "Minnesota",
    "WA": "Washington", "MA": "Massachusetts", "TX": "Texas"] . Remember, because
    you don’t have to rely on indices, your new dictionary item might appear anywhere
    in the dictionary.'
  id: totrans-6043
  prefs: []
  type: TYPE_NORMAL
  zh: '现在，当你查看usStates时，你会看到它已更新为["MN": "Minnesota", "WA": "Washington", "MA": "Massachusetts",
    "TX": "Texas"]。记住，由于你不需要依赖索引，新的字典项可能会出现在字典中的任何位置。'
- en: '**REMOVING ITEMS FROM A DICTIONARY**'
  id: totrans-6044
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**从字典中移除项**'
- en: Removing an item from a dictionary is quite simple; you do so by setting the
    value to nil . Because the values in dictionaries are returned as optionals, you
    don’t have to worry about nil causing any problems in your dictionary.
  id: totrans-6045
  prefs: []
  type: TYPE_NORMAL
  zh: 从字典中移除项是非常简单的；你只需要将值设置为nil。由于字典中的值是以可选值返回的，所以你不必担心nil会在字典中引发任何问题。
- en: '![](Image00145.jpg)'
  id: totrans-6046
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00145.jpg)'
- en: 'You can see that after you remove the value at the key "MA" , usStates is updated
    to ["MN": "Minnesota", "WA": "Washington", "TX": "Texas"] . Remember that nil
    is special and means that there’s no value at all. That’s why you don’t see "MA":
    nil in our dictionary.'
  id: totrans-6047
  prefs: []
  type: TYPE_NORMAL
  zh: '你可以看到，在移除键"MA"对应的值之后，usStates被更新为["MN": "Minnesota", "WA": "Washington", "TX":
    "Texas"]。记住，nil是特殊的，表示根本没有值。因此，你在字典中不会看到"MA": nil。'
- en: '**REPLACING ITEMS IN A DICTIONARY**'
  id: totrans-6048
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**替换字典中的项**'
- en: 'Replacing an item in a dictionary is also easy. It works the same was as replacing
    an item in an array. You just set the item that you want to replace to something
    else. Say you create a dictionary of fruit colors:'
  id: totrans-6049
  prefs: []
  type: TYPE_NORMAL
  zh: 替换字典中的项也很简单。它的工作方式与替换数组中的项相同。你只需将要替换的项设置为其他值。例如，假设你创建了一个包含水果颜色的字典：
- en: '![](Image00146.jpg)'
  id: totrans-6050
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00146.jpg)'
- en: At first we had the value "apple" for "red" , but then we decided that "raspberry"
    is a better fruit to use since sometimes apples are green or yellow. To replace
    "apple" with "raspberry" , we set colorFruits["red"] to its new value ➊ .
  id: totrans-6051
  prefs: []
  type: TYPE_NORMAL
  zh: 最开始，我们将"red"的值设为"apple"，但后来我们决定"raspberry"更适合，因为有时候苹果是绿色或黄色的。为了将"apple"替换为"raspberry"，我们将colorFruits["red"]设置为它的新值
    ➊。
- en: You may remember that this is the same way we entered a new value into a dictionary.
    If the key already exists in the dictionary, then the value for that key is replaced.
    If the key doesn’t already exist, then the new key/value pair will be added to
    the dictionary.
  id: totrans-6052
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能记得，这与我们向字典中添加新值的方式是一样的。如果键已经存在于字典中，则该键的值会被替换。如果键不存在，则新的键/值对将被添加到字典中。
- en: '![Image](Image00147.jpg)'
  id: totrans-6053
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00147.jpg)'
- en: '**USING DICTIONARY PROPERTIES**'
  id: totrans-6054
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**使用字典属性**'
- en: 'Like an array, a dictionary also has an isEmpty property and a count property.
    For example, the following code shows how you can use the isEmpty property to
    check if a dictionary is empty, and if it isn’t empty, the count property checks
    how many items you have. Imagine you have a basket of fruit for sale. You can
    use these properties to help you keep track of everything:'
  id: totrans-6055
  prefs: []
  type: TYPE_NORMAL
  zh: 像数组一样，字典也有isEmpty属性和count属性。例如，下面的代码展示了如何使用isEmpty属性检查字典是否为空，如果不为空，count属性将检查字典中有多少项。假设你有一个待售的水果篮子。你可以使用这些属性帮助你跟踪所有内容：
- en: '![Image](Image00148.jpg)'
  id: totrans-6056
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00148.jpg)'
- en: 'A dictionary also has two special properties: keys , which contains all of
    the dictionary’s keys, and values , which contains all of its values. We’ll use
    these two properties when we loop through the dictionary.'
  id: totrans-6057
  prefs: []
  type: TYPE_NORMAL
  zh: 字典还有两个特殊属性：keys，它包含字典的所有键，以及values，它包含字典的所有值。当我们遍历字典时，我们将使用这两个属性。
- en: Let’s write some code that loops through our fruit baskets and prints the price
    of each fruit.
  id: totrans-6058
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们写一些代码，遍历我们的水果篮子并打印每个水果的价格。
- en: '**LOOPING OVER A DICTIONARY**'
  id: totrans-6059
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**遍历字典**'
- en: 'You can loop through a dictionary using a for-in loop. Because each item has
    a key and a value, you can do this in two different ways. This is how to loop
    through a dictionary using its keys:'
  id: totrans-6060
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用for-in循环遍历字典。因为每个项目都有一个键和值，所以你可以用两种不同的方式来做这件事。以下是如何使用键遍历字典：
- en: '![Image](Image00149.jpg)'
  id: totrans-6061
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00149.jpg)'
- en: Here we use the dictionary’s keys property ➊ to loop through fruitBasket and
    print its contents. We start by writing the keyword for , followed by a constant
    name fruit for the dictionary key, the keyword in , the dictionary name, a period,
    and keys .
  id: totrans-6062
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们使用字典的keys属性 ➊ 遍历fruitBasket并打印其内容。我们从写关键字for开始，后面跟一个常量名fruit作为字典的键，关键字in，字典名，一个句点，再加上keys。
- en: Inside the braces of our for-in loop, we have access to both the key, which
    we call fruit ➋ , and the value at that key when we force-unwrap its contents
    with fruitBasket[fruit]! ➌ . That value will be the fruit’s price.
  id: totrans-6063
  prefs: []
  type: TYPE_NORMAL
  zh: 在for-in循环的花括号内部，我们可以访问键，我们称其为fruit ➋，以及通过强制解包fruitBasket[fruit]! ➌获取该键对应的值。这个值将是水果的价格。
- en: In this case, it’s safe to force-unwrap the value using an exclamation point
    because we know that the fruit key we’re using is definitely inside the dictionary.
  id: totrans-6064
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，使用感叹号强制解包值是安全的，因为我们知道我们使用的水果键肯定在字典中。
- en: Any code we put inside the for-in loop will run once for every key in our dictionary.
    So you should see the print statement display three times.
  id: totrans-6065
  prefs: []
  type: TYPE_NORMAL
  zh: 我们放入for-in循环中的任何代码将为字典中的每个键执行一次。因此，你应该会看到打印语句显示三次。
- en: 'We can also loop through the dictionary using its values property:'
  id: totrans-6066
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以使用字典的values属性遍历字典：
- en: '![Image](Image00150.jpg)'
  id: totrans-6067
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00150.jpg)'
- en: We use the same style of for-in loop, but now we use a constant to refer to
    each value, which we call price , in the values property. When looping through
    values, we don’t have access to the keys from inside the loop.
  id: totrans-6068
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用相同的for-in循环风格，但现在我们使用一个常量来引用values属性中的每个值，我们称之为price。在遍历值时，我们无法从循环内部访问键。
- en: Another difference to note is that price is not an optional because it’s accessed
    directly as a value in the fruitBasket dictionary. That means we don’t have to
    unwrap it. You should still see the print statement printed three times. [Figure
    6-6](text00016.html#ch06fig6) shows the output of both loops.
  id: totrans-6069
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个需要注意的区别是，price不是可选的，因为它是作为fruitBasket字典中的值直接访问的。这意味着我们不需要解包它。你仍然应该看到打印语句打印三次。[图6-6](text00016.html#ch06fig6)显示了两个循环的输出。
- en: '![Image](Image00151.jpg)'
  id: totrans-6070
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00151.jpg)'
- en: '*Figure 6-6: Looping through the keys and values of a dictionary with a for-in
    loop*'
  id: totrans-6071
  prefs: []
  type: TYPE_NORMAL
  zh: '*图6-6：通过for-in循环遍历字典的键和值*'
- en: The order of your results might be slightly different from ours. That’s because
    the items in a dictionary aren’t in a numbered order like they are in an array!
    And because the order is not guaranteed, you might see a different order printed
    if you run the same code again.
  id: totrans-6072
  prefs: []
  type: TYPE_NORMAL
  zh: 你的结果顺序可能与我们的略有不同。这是因为字典中的元素不像数组中的元素那样按数字顺序排列！而且由于顺序没有保证，如果你再次运行相同的代码，你可能会看到不同的顺序。
- en: '**WHAT YOU LEARNED**'
  id: totrans-6073
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**你学到了什么**'
- en: In this chapter, you learned how to store collections of items in an array and
    in a dictionary. To store items in an ordered list, you would use an array and
    look up each item by its index. If you wanted to store items by key instead, you
    would use a dictionary.
  id: totrans-6074
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一章中，你学会了如何将元素存储在数组和字典中。要将项目存储在有序列表中，你应该使用数组，并通过索引查找每个元素。如果你想通过键来存储元素，则应使用字典。
- en: Knowing about arrays and dictionaries and how to use them is a powerful building
    block for almost any programming language. Next we will learn about functions,
    another very powerful tool. Functions are blocks of code that you create and name
    to perform a specific job. After you have written a function, you can use its
    name to call it from almost anywhere in your program.
  id: totrans-6075
  prefs: []
  type: TYPE_NORMAL
  zh: 了解数组和字典以及如何使用它们，是几乎所有编程语言中的强大构建块。接下来，我们将学习函数，这是另一个非常强大的工具。函数是你创建并命名的一段代码，用来执行特定的任务。编写函数后，你可以通过其名称在程序中的几乎任何地方调用它。
- en: Note that ["whipped cream"] is an array even though it has a single item in
    it. When you’re using += to append something to an array, you have to make sure
    you’re only trying to add another array. If you were to just write the string
    "whipped cream" without the square brackets around it, you would get an error.
  id: totrans-6076
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，["whipped cream"]是一个数组，尽管它只有一个元素。当你使用+=操作符向数组添加内容时，必须确保你只是在添加另一个数组。如果你直接写字符串"whipped
    cream"而没有方括号，你会遇到错误。
- en: '![Image](Image00125.jpg)'
  id: totrans-6077
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00125.jpg)'
- en: '**REMOVING ITEMS FROM AN ARRAY**'
  id: totrans-6078
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**从数组中移除元素**'
- en: 'There are several methods for removing items from an array. Let’s start by
    looking at the array’s removeLast() method. As you might have guessed from its
    name, removeLast() removes the last item from your array. Let’s try it out with
    a shoppingList array:'
  id: totrans-6079
  prefs: []
  type: TYPE_NORMAL
  zh: 有几种方法可以从数组中移除元素。让我们首先看看数组的removeLast()方法。正如你从它的名字猜到的那样，removeLast()会移除数组中的最后一个元素。让我们用一个shoppingList数组来试一试：
- en: '![](Image00126.jpg)'
  id: totrans-6080
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00126.jpg)'
- en: Neat! Note that the removeLast() method returns the removed item, so you can
    store it in a new constant or variable if you want.
  id: totrans-6081
  prefs: []
  type: TYPE_NORMAL
  zh: 很棒！请注意，removeLast()方法会返回被移除的项，因此你可以将其存储到一个新的常量或变量中，如果你需要的话。
- en: 'You can also remove an item from a specific index by using the remove(at:)
    method. Let’s say that your mom doesn’t want you buying any candy and takes that
    off the list:'
  id: totrans-6082
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以使用remove(at:)方法从特定索引处移除元素。假设你的妈妈不希望你买糖果并把它从清单中移除：
- en: '![Image](Image00127.jpg)![](Image00128.jpg)'
  id: totrans-6083
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00127.jpg)![](Image00128.jpg)'
- en: Just like when we added an item to the middle of our array and all the items
    scooted over to make room, if you remove an item from the middle of an array,
    the rest of the items will scoot back to fill in that empty space. The "apples"
    item that was at index 3 is now at index 2, where "candy" was.
  id: totrans-6084
  prefs: []
  type: TYPE_NORMAL
  zh: 就像我们将元素添加到数组中间，其他元素会向一侧挪动以腾出空间一样，如果你从数组中间移除元素，剩下的元素会向回挪动以填补空缺。原来位于索引3的"apples"元素现在位于索引2的位置，原来"candy"所在的位置。
- en: 'You can also remove all items from an array with removeAll() . Try entering
    this into your playground:'
  id: totrans-6085
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以使用removeAll()从数组中移除所有元素。试着在你的 playground 中输入以下内容：
- en: '![](Image00129.jpg)'
  id: totrans-6086
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00129.jpg)'
- en: 'Note that trying to remove an item at an index that doesn’t exist will give
    you an error:'
  id: totrans-6087
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，尝试从不存在的索引处移除元素会导致错误：
- en: '![](Image00130.jpg)'
  id: totrans-6088
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00130.jpg)'
- en: Our array doesn’t have this many items (in fact, now it’s empty!), so this throws
    an error. We’ll also get an error if we use removeLast() on our empty array, because
    there’s nothing in it—there’s no last index at all! However, removeAll() is always
    safe to use, even on an empty array.
  id: totrans-6089
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的数组没有这么多元素（实际上，现在它已经是空的！），因此会抛出一个错误。如果我们在空数组上使用removeLast()，也会出错，因为数组中没有元素——根本没有最后一个索引！不过，removeAll()即使在空数组上使用也是安全的。
- en: '**REPLACING ITEMS IN AN ARRAY**'
  id: totrans-6090
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**替换数组中的元素**'
- en: 'To replace an item in an array, you set the index of the array to the new value,
    as shown here:'
  id: totrans-6091
  prefs: []
  type: TYPE_NORMAL
  zh: 要替换数组中的一个元素，你需要将该数组的索引设置为新的值，如下所示：
- en: '![](Image00131.jpg)'
  id: totrans-6092
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00131.jpg)'
- en: At ➊ , we replaced the item at index 2 (the third item) with "Unicorn" because
    magical animals count as favorite animals, too! At ➋ , we replaced the item at
    index 0 (the first item) with "Bearded dragon" . No, that’s not a real dragon—it’s
    just a lizard!
  id: totrans-6093
  prefs: []
  type: TYPE_NORMAL
  zh: 在 ➊ 处，我们将索引 2（第三个元素）处的元素替换为 "Unicorn" 因为魔法动物也算是最喜欢的动物！在 ➋ 处，我们将索引 0（第一个元素）处的元素替换为
    "Bearded dragon"。不，这不是一条真正的龙——它只是一只蜥蜴！
- en: Like any time you’re working with array index numbers, you have to be sure an
    item exists in the array at that index before you change its value, or you will
    get an Index out of range error.
  id: totrans-6094
  prefs: []
  type: TYPE_NORMAL
  zh: 像处理数组索引号一样，在更改某个元素的值之前，你必须确保该索引处的元素在数组中存在，否则你会遇到“超出范围”错误。
- en: '[Figure 6-3](text00016.html#ch06fig3) shows the error that occurs if you try
    to add "Standard poodle" using favoriteAnimals[3] = "Standard poodle" . To add
    an item to the end of an array, you should use the append(_:) method or += , as
    we covered in “[Adding Items to an Array](text00016.html#ch06lev2sec5) ” on [page
    70](text00016.html#page_70) .'
  id: totrans-6095
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 6-3](text00016.html#ch06fig3)展示了当你尝试通过 favoriteAnimals[3] = "Standard poodle"
    来添加 "Standard poodle" 时出现的错误。要向数组的末尾添加元素，你应该使用 append(_:) 方法或 += 运算符，正如我们在 “[向数组添加元素](text00016.html#ch06lev2sec5)”
    第[70页](text00016.html#page_70)中所讨论的那样。'
- en: '![Image](Image00132.jpg)'
  id: totrans-6096
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00132.jpg)'
- en: '*Figure 6-3: Don’t try to replace a value at an index beyond the existing array.*'
  id: totrans-6097
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 6-3：不要尝试替换超出现有数组索引的值。*'
- en: Now you know how to change arrays however you might need to. You can add items,
    take items away, or replace items. Next, we’ll look at how to use the properties
    of arrays to find out even more information about them.
  id: totrans-6098
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经知道如何根据需要更改数组了。你可以添加元素、移除元素或替换元素。接下来，我们将看看如何使用数组的属性来获取更多有关数组的信息。
- en: '![Image](Image00133.jpg)'
  id: totrans-6099
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00133.jpg)'
- en: '**USING ARRAY PROPERTIES**'
  id: totrans-6100
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**使用数组属性**'
- en: In addition to methods like append(_:) and removeLast() , arrays also have *properties*
    . An array’s properties are variables or constants that contain some information
    about the array. Two really helpful properties that you might use are the Boolean
    property isEmpty and the integer property count .
  id: totrans-6101
  prefs: []
  type: TYPE_NORMAL
  zh: 除了像 append(_:) 和 removeLast() 这样的方法外，数组还有 *属性*。数组的属性是包含有关数组的一些信息的变量或常量。你可能会用到的两个非常有用的属性是布尔属性
    isEmpty 和整数属性 count。
- en: The isEmpty property is true or false depending on whether the array is empty,
    and the count property will tell you how many items are in that array.
  id: totrans-6102
  prefs: []
  type: TYPE_NORMAL
  zh: isEmpty 属性根据数组是否为空来返回 true 或 false，而 count 属性则告诉你数组中有多少个元素。
- en: 'Check out how these two properties are used in the following if-else statement:'
  id: totrans-6103
  prefs: []
  type: TYPE_NORMAL
  zh: 看看以下 if-else 语句中如何使用这两个属性：
- en: '![Image](Image00134.jpg)'
  id: totrans-6104
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00134.jpg)'
- en: 'This if-else statement checks whether the array mySiblings is empty ➊ . If
    it is, then "I don''t have any siblings." is printed. But if there is something
    in the array, then the number of siblings that we have is printed: "I have 3 siblings."
    ➋ .'
  id: totrans-6105
  prefs: []
  type: TYPE_NORMAL
  zh: 这个 if-else 语句检查数组 mySiblings 是否为空 ➊。如果为空，则打印 "我没有兄弟姐妹"。但如果数组中有元素，则会打印我们有多少兄弟姐妹："我有
    3 个兄弟姐妹" ➋。
- en: '**LOOPING OVER AN ARRAY**'
  id: totrans-6106
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**遍历数组**'
- en: 'Sometimes when you’re working with arrays you might want to do something to
    every item in the array. You can use a for-in loop to do that! The following code
    will print every topping in a pizzaToppings array on a separate line:'
  id: totrans-6107
  prefs: []
  type: TYPE_NORMAL
  zh: 有时候，当你处理数组时，你可能想对数组中的每个元素做些事情。你可以使用 for-in 循环来做到这一点！以下代码将把 pizzaToppings 数组中的每个
    topping 打印到单独的一行：
- en: '![Image](Image00135.jpg)'
  id: totrans-6108
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00135.jpg)'
- en: To write a for-in loop for the pizzaToppings array, we used the keyword for
    , followed by the constant topping , then the keyword in , and finally the name
    of our array, pizzaToppings . Then we put the statements that we want to run for
    each topping inside the braces of the for-in loop. The constant topping ➊ temporarily
    represents each pizza topping in the array as we loop through it. We could have
    chosen any name for this constant, but it’s a good idea to pick something that
    makes sense. You can see the output of this for-in loop in [Figure 6-4](text00016.html#ch06fig4)
    .
  id: totrans-6109
  prefs: []
  type: TYPE_NORMAL
  zh: 为了编写 pizzaToppings 数组的 for-in 循环，我们使用了关键字 for，后面跟着常量 topping，然后是关键字 in，最后是我们数组的名称
    pizzaToppings。然后我们将希望对每个 topping 执行的语句放在 for-in 循环的大括号中。在循环过程中，常量 topping ➊ 临时代表数组中的每个
    pizza topping。我们本可以为这个常量选择任何名字，但选择一个有意义的名字是个好主意。你可以在 [图 6-4](text00016.html#ch06fig4)
    中看到这个 for-in 循环的输出。
- en: '![Image](Image00136.jpg)'
  id: totrans-6110
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00136.jpg)'
- en: '*Figure 6-4: Output of the example for-in loop*'
  id: totrans-6111
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 6-4：示例中 for-in 循环的输出*'
- en: '![Image](Image00137.jpg)'
  id: totrans-6112
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00137.jpg)'
- en: 'Using for-in loops is great for printing every value in an array. If you’re
    working with numbers, you can even use them to perform math operations on each
    item, which makes for some speedy calculations! The following code takes an array
    of numbers and calculates the square for each (the square of a number is that
    number multiplied by itself):'
  id: totrans-6113
  prefs: []
  type: TYPE_NORMAL
  zh: 使用for-in循环非常适合打印数组中的每个值。如果你正在处理数字，你甚至可以使用它们对每个项目执行数学运算，这样就能进行快速计算！以下代码接收一个数字数组，并计算每个数字的平方（数字的平方是该数字与它自身相乘）：
- en: '![Image](Image00138.jpg)'
  id: totrans-6114
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00138.jpg)'
- en: '[Figure 6-5](text00016.html#ch06fig5) shows the results.'
  id: totrans-6115
  prefs: []
  type: TYPE_NORMAL
  zh: '[图6-5](text00016.html#ch06fig5)展示了结果。'
- en: '![Image](Image00139.jpg)'
  id: totrans-6116
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00139.jpg)'
- en: '*Figure 6-5: Printing the squares for each number in the myNumbers array*'
  id: totrans-6117
  prefs: []
  type: TYPE_NORMAL
  zh: '*图6-5：打印myNumbers数组中每个数字的平方*'
- en: '**DICTIONARIES ARE KEY!**'
  id: totrans-6118
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**字典至关重要！**'
- en: A *dictionary* is also a collection of values, but instead of an ordered index,
    each value has its own *key* . Because there’s no index, the values are not stored
    in any particular order. To access values in a dictionary, you look them up by
    their key.
  id: totrans-6119
  prefs: []
  type: TYPE_NORMAL
  zh: '*字典*也是一个值的集合，但与有序索引不同，每个值都有自己的*键*。由于没有索引，值并没有按特定顺序存储。要访问字典中的值，你需要通过它们的键来查找。'
- en: A key must be unique. You can’t have the same key more than once in the same
    dictionary. If there were two identical keys and you asked the computer to give
    you the value for one of them, the computer wouldn’t know which one to choose!
  id: totrans-6120
  prefs: []
  type: TYPE_NORMAL
  zh: 键必须是唯一的。你不能在同一个字典中有重复的键。如果有两个相同的键，而你要求计算机返回其中一个的值，计算机就无法确定该选择哪一个！
- en: Let’s take a look at how to make a dictionary and write keys that will help
    you find all the information you need.
  id: totrans-6121
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如何创建一个字典，并编写键来帮助你找到所需的所有信息。
- en: '![Image](Image00140.jpg)'
  id: totrans-6122
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00140.jpg)'
- en: '**INITIALIZING A DICTIONARY**'
  id: totrans-6123
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**初始化字典**'
- en: 'To create and initialize a dictionary, first write var and the name of your
    dictionary. Then write the keys and corresponding values inside a pair of square
    brackets, similar to an array. Let’s create a dictionary to store the names of
    a few US states. The key for each state will be its two-letter abbreviation:'
  id: totrans-6124
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建并初始化一个字典，首先写var和字典的名称。然后，将键及其对应的值写在一对方括号内，类似于数组。让我们创建一个字典，存储一些美国州的名称。每个州的键将是它的两字母缩写：
- en: '![](Image00141.jpg)'
  id: totrans-6125
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00141.jpg)'
- en: As you can see, there’s a colon between each key and its value, and the key/value
    pairs are separated by commas.
  id: totrans-6126
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，每个键和它的值之间有一个冒号，键/值对之间由逗号分隔。
- en: Dictionaries are different from arrays in that they are *unordered* . Because
    of that, it’s likely that the order of the states that you see in your results
    pane ➋ is different from the order in which you entered your states ➊ . It might
    even be different than the order that’s printed in this book!
  id: totrans-6127
  prefs: []
  type: TYPE_NORMAL
  zh: 字典与数组的不同之处在于它们是*无序的*。因此，你在结果窗格中看到的状态顺序➋很可能与输入状态的顺序➊不同，甚至可能与本书中打印的顺序不同！
- en: As with arrays, you can use var to make a mutable dictionary or use let to make
    an immutable dictionary.
  id: totrans-6128
  prefs: []
  type: TYPE_NORMAL
  zh: 与数组一样，你可以使用var来创建一个可变字典，或者使用let来创建一个不可变字典。
- en: 'In Swift, all of the keys of a dictionary must be the same type, and all of
    the values of a dictionary must also be the same type, but the key type doesn’t
    have to match the value type. For example, if you wanted to store a collection
    of fractions, you could use doubles for the keys and strings for the values:'
  id: totrans-6129
  prefs: []
  type: TYPE_NORMAL
  zh: 在Swift中，字典的所有键必须是相同类型的，字典的所有值也必须是相同类型的，但键类型不必与值类型匹配。例如，如果你想存储一个分数的集合，你可以使用双精度数值作为键，使用字符串作为值：
- en: '![](Image00142.jpg)'
  id: totrans-6130
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00142.jpg)'
- en: In this dictionary, all of the keys must be doubles, and all of the values must
    be strings. Again, you’ll see that the order of the numbers in the results pane
    can be quite different from the order in which you wrote the fractions in your
    dictionary. This is fine because you don’t need to know the order to access anything.
    You can find any item that you need by its key. Let’s see how!
  id: totrans-6131
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个字典中，所有的键必须是双精度数值，所有的值必须是字符串。你会发现，结果窗格中数字的顺序可能与字典中书写的分数顺序大不相同。这没关系，因为你不需要知道顺序就能访问任何内容。你可以通过键来找到所需的任何项。我们来看看如何做到这一点！
- en: '**ACCESSING VALUES IN A DICTIONARY**'
  id: totrans-6132
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**访问字典中的值**'
- en: 'Looking up a value in a dictionary is similar to how you access a value in
    an array except that you use a key inside the square brackets instead of an index,
    like this: usStates["TX"] .'
  id: totrans-6133
  prefs: []
  type: TYPE_NORMAL
  zh: 查找字典中的值类似于你在数组中访问一个值的方式，只不过你使用的是字典中的键而不是索引，例如：usStates["TX"]。
- en: There is a big difference, however, in how Swift returns the values from a dictionary.
    When you access a value at an index of an array, you are simply given the value.
    When you access a value with a key in a dictionary, you are given an optional.
  id: totrans-6134
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，Swift从字典中返回值的方式与从数组的索引中获取值有很大区别。当你通过数组索引访问一个值时，你只会得到值。而当你通过字典中的键访问一个值时，你会得到一个可选项。
- en: In [Chapter 5](text00015.html#ch05) , you learned that optionals might contain
    a value or might be nil . The reason Swift returns optionals when you’re looking
    up items in a dictionary is that the key you used might not exist in the dictionary,
    in which case there’s no value to access. Trying to access a value that doesn’t
    exist would give you a big fat error! To avoid that problem, Swift returns optionals.
    That means you need to unwrap any value you get out of a dictionary before you
    can do anything with it.
  id: totrans-6135
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第5章](text00015.html#ch05)中，你已经学到可选项可能包含一个值，也可能是nil。Swift在你查找字典中的项时返回可选项的原因是，可能你使用的键在字典中不存在，在这种情况下就没有值可以访问。尝试访问一个不存在的值会导致一个大的错误！为避免这种问题，Swift返回了可选项。这意味着，在你对从字典中获取的任何值进行操作之前，需要解包它。
- en: 'To unwrap an optional, first you check whether it exists using an if-let statement,
    just like we did in [Chapter 5](text00015.html#ch05) . The following code shows
    you how to get a value out of a dictionary:'
  id: totrans-6136
  prefs: []
  type: TYPE_NORMAL
  zh: 要解包一个可选项，首先检查它是否存在，可以使用if-let语句，就像我们在[第5章](text00015.html#ch05)中做的那样。下面的代码展示了如何从字典中获取一个值：
- en: '![Image](Image00143.jpg)'
  id: totrans-6137
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00143.jpg)'
- en: To retrieve "Texas" from the dictionary, we use if let to set a constant loneStarState
    to usStates["TX"] ➊ . Because we have this state in our dictionary, the line I
    have Texas in my dictionary. is printed. Next we try to access a state that is
    not in our dictionary by using the key usStates["FL"] ➋ . Thankfully, because
    we used an if-let statement, the program won’t crash when the computer can’t find
    this state. Instead, I don't have that state in my dictionary. is printed.
  id: totrans-6138
  prefs: []
  type: TYPE_NORMAL
  zh: 要从字典中检索“Texas”，我们使用if let将常量loneStarState设置为usStates["TX"] ➊。因为字典中有这个州，所以打印出“我在字典中找到了Texas”。接下来，我们尝试通过使用键usStates["FL"]
    ➋来访问一个不在字典中的州。幸运的是，由于我们使用了if-let语句，当计算机找不到这个州时，程序不会崩溃。相反，打印出“我在字典中没有这个州”。
- en: '**ADDING ITEMS TO A DICTIONARY**'
  id: totrans-6139
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**向字典中添加项**'
- en: 'To add an item to a dictionary, first write the name of your dictionary and
    assign the new item to the key you want it to have in the dictionary. Let’s add
    "Minnesota" to our usStates dictionary:'
  id: totrans-6140
  prefs: []
  type: TYPE_NORMAL
  zh: 要向字典中添加一个项，首先写出字典的名称，并将新项赋值给你想要它在字典中拥有的键。我们来向我们的usStates字典中添加“Minnesota”：
- en: '![](Image00144.jpg)'
  id: totrans-6141
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00144.jpg)'
- en: 'Now when you look at usStates , you’ll see that it’s updated to ["MN": "Minnesota",
    "WA": "Washington", "MA": "Massachusetts", "TX": "Texas"] . Remember, because
    you don’t have to rely on indices, your new dictionary item might appear anywhere
    in the dictionary.'
  id: totrans-6142
  prefs: []
  type: TYPE_NORMAL
  zh: '现在当你查看usStates时，你会看到它更新为["MN": "Minnesota", "WA": "Washington", "MA": "Massachusetts",
    "TX": "Texas"]。记住，因为你不需要依赖索引，所以你的新字典项可能出现在字典中的任何位置。'
- en: '**REMOVING ITEMS FROM A DICTIONARY**'
  id: totrans-6143
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**从字典中移除项**'
- en: Removing an item from a dictionary is quite simple; you do so by setting the
    value to nil . Because the values in dictionaries are returned as optionals, you
    don’t have to worry about nil causing any problems in your dictionary.
  id: totrans-6144
  prefs: []
  type: TYPE_NORMAL
  zh: 从字典中移除一项非常简单；你只需要将该值设置为nil。因为字典中的值是作为可选项返回的，所以你不需要担心nil会导致字典中的问题。
- en: '![](Image00145.jpg)'
  id: totrans-6145
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00145.jpg)'
- en: 'You can see that after you remove the value at the key "MA" , usStates is updated
    to ["MN": "Minnesota", "WA": "Washington", "TX": "Texas"] . Remember that nil
    is special and means that there’s no value at all. That’s why you don’t see "MA":
    nil in our dictionary.'
  id: totrans-6146
  prefs: []
  type: TYPE_NORMAL
  zh: '你可以看到，在你移除键"MA"的值之后，usStates更新为["MN": "Minnesota", "WA": "Washington", "TX":
    "Texas"]。记住，nil是特殊的，它表示没有值。这就是为什么你在字典中看不到"MA": nil的原因。'
- en: '**REPLACING ITEMS IN A DICTIONARY**'
  id: totrans-6147
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**替换字典中的项**'
- en: 'Replacing an item in a dictionary is also easy. It works the same was as replacing
    an item in an array. You just set the item that you want to replace to something
    else. Say you create a dictionary of fruit colors:'
  id: totrans-6148
  prefs: []
  type: TYPE_NORMAL
  zh: 替换字典中的一项也很简单。它的工作方式和替换数组中的项一样。你只需要将你想替换的项设置为其他值。比如，你创建一个关于水果颜色的字典：
- en: '![](Image00146.jpg)'
  id: totrans-6149
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00146.jpg)'
- en: At first we had the value "apple" for "red" , but then we decided that "raspberry"
    is a better fruit to use since sometimes apples are green or yellow. To replace
    "apple" with "raspberry" , we set colorFruits["red"] to its new value ➊ .
  id: totrans-6150
  prefs: []
  type: TYPE_NORMAL
  zh: 起初，我们为“red”键设置的值是“apple”，但后来我们决定“raspberry”是一个更好的水果选择，因为有时苹果是绿色或黄色的。为了用“raspberry”替换“apple”，我们将
    colorFruits["red"] 设置为它的新值 ➊。
- en: You may remember that this is the same way we entered a new value into a dictionary.
    If the key already exists in the dictionary, then the value for that key is replaced.
    If the key doesn’t already exist, then the new key/value pair will be added to
    the dictionary.
  id: totrans-6151
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能记得，这与我们将新值添加到字典中的方式相同。如果键已经存在于字典中，则该键的值将被替换。如果键不存在，则新的键/值对将被添加到字典中。
- en: '![Image](Image00147.jpg)'
  id: totrans-6152
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Image00147.jpg)'
- en: '**USING DICTIONARY PROPERTIES**'
  id: totrans-6153
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**使用字典属性**'
- en: 'Like an array, a dictionary also has an isEmpty property and a count property.
    For example, the following code shows how you can use the isEmpty property to
    check if a dictionary is empty, and if it isn’t empty, the count property checks
    how many items you have. Imagine you have a basket of fruit for sale. You can
    use these properties to help you keep track of everything:'
  id: totrans-6154
  prefs: []
  type: TYPE_NORMAL
  zh: 和数组一样，字典也有 isEmpty 属性和 count 属性。例如，以下代码展示了如何使用 isEmpty 属性来检查字典是否为空，如果字典不为空，则
    count 属性可以检查字典中有多少项。假设你有一个水果篮子在出售，你可以使用这些属性来帮助你记录一切：
- en: '![Image](Image00148.jpg)'
  id: totrans-6155
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Image00148.jpg)'
- en: 'A dictionary also has two special properties: keys , which contains all of
    the dictionary’s keys, and values , which contains all of its values. We’ll use
    these two properties when we loop through the dictionary.'
  id: totrans-6156
  prefs: []
  type: TYPE_NORMAL
  zh: 字典还有两个特殊的属性：keys，它包含字典的所有键；以及 values，它包含字典的所有值。我们将在遍历字典时使用这两个属性。
- en: Let’s write some code that loops through our fruit baskets and prints the price
    of each fruit.
  id: totrans-6157
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们编写一些代码，遍历我们的水果篮子并打印每个水果的价格。
- en: '**LOOPING OVER A DICTIONARY**'
  id: totrans-6158
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**遍历字典**'
- en: 'You can loop through a dictionary using a for-in loop. Because each item has
    a key and a value, you can do this in two different ways. This is how to loop
    through a dictionary using its keys:'
  id: totrans-6159
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用 for-in 循环来遍历字典。由于每个项目都有键和值，你可以通过两种不同的方式来实现遍历。这是通过键来遍历字典的方式：
- en: '![Image](Image00149.jpg)'
  id: totrans-6160
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Image00149.jpg)'
- en: Here we use the dictionary’s keys property ➊ to loop through fruitBasket and
    print its contents. We start by writing the keyword for , followed by a constant
    name fruit for the dictionary key, the keyword in , the dictionary name, a period,
    and keys .
  id: totrans-6161
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们使用字典的 keys 属性 ➊ 来遍历 fruitBasket 并打印其内容。我们首先写上关键词 for，后面是一个常量名 fruit 用于字典的键，然后是关键词
    in，接着是字典名、一个句点以及 keys。
- en: Inside the braces of our for-in loop, we have access to both the key, which
    we call fruit ➋ , and the value at that key when we force-unwrap its contents
    with fruitBasket[fruit]! ➌ . That value will be the fruit’s price.
  id: totrans-6162
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的 for-in 循环的大括号内，我们可以访问到键（我们称之为 fruit ➋），以及当我们使用 fruitBasket[fruit]! ➌ 强制解包其内容时，该键对应的值。这个值将是水果的价格。
- en: In this case, it’s safe to force-unwrap the value using an exclamation point
    because we know that the fruit key we’re using is definitely inside the dictionary.
  id: totrans-6163
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，使用感叹号强制解包值是安全的，因为我们知道我们使用的水果键肯定存在于字典中。
- en: Any code we put inside the for-in loop will run once for every key in our dictionary.
    So you should see the print statement display three times.
  id: totrans-6164
  prefs: []
  type: TYPE_NORMAL
  zh: 我们放在 for-in 循环内部的任何代码都将在字典中的每个键上执行一次。所以你应该看到打印语句被打印三次。
- en: 'We can also loop through the dictionary using its values property:'
  id: totrans-6165
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以通过字典的 values 属性来遍历字典：
- en: '![Image](Image00150.jpg)'
  id: totrans-6166
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Image00150.jpg)'
- en: We use the same style of for-in loop, but now we use a constant to refer to
    each value, which we call price , in the values property. When looping through
    values, we don’t have access to the keys from inside the loop.
  id: totrans-6167
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用相同类型的 for-in 循环，但现在我们使用常量来引用 values 属性中的每个值，我们称其为 price。在遍历 values 时，我们无法从循环内部访问键。
- en: Another difference to note is that price is not an optional because it’s accessed
    directly as a value in the fruitBasket dictionary. That means we don’t have to
    unwrap it. You should still see the print statement printed three times. [Figure
    6-6](text00016.html#ch06fig6) shows the output of both loops.
  id: totrans-6168
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个需要注意的区别是，price 不是一个可选类型，因为它是直接作为值从 fruitBasket 字典中访问的。这意味着我们不需要解包它。你应该仍然能看到打印语句被打印三次。[图
    6-6](text00016.html#ch06fig6) 显示了两个循环的输出。
- en: '![Image](Image00151.jpg)'
  id: totrans-6169
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Image00151.jpg)'
- en: '*Figure 6-6: Looping through the keys and values of a dictionary with a for-in
    loop*'
  id: totrans-6170
  prefs: []
  type: TYPE_NORMAL
  zh: '*图6-6：使用for-in循环遍历字典的键和值*'
- en: The order of your results might be slightly different from ours. That’s because
    the items in a dictionary aren’t in a numbered order like they are in an array!
    And because the order is not guaranteed, you might see a different order printed
    if you run the same code again.
  id: totrans-6171
  prefs: []
  type: TYPE_NORMAL
  zh: 你的结果顺序可能会与你看到的略有不同。这是因为字典中的项不像数组那样按数字顺序排列！由于顺序无法保证，如果你再次运行相同的代码，可能会看到不同的顺序输出。
- en: '**WHAT YOU LEARNED**'
  id: totrans-6172
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**你学到的内容**'
- en: In this chapter, you learned how to store collections of items in an array and
    in a dictionary. To store items in an ordered list, you would use an array and
    look up each item by its index. If you wanted to store items by key instead, you
    would use a dictionary.
  id: totrans-6173
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一章节中，你学会了如何将项存储在数组和字典中。要将项存储在一个有序列表中，你应使用数组并通过索引查找每个项。如果你想按键存储项，你应使用字典。
- en: Knowing about arrays and dictionaries and how to use them is a powerful building
    block for almost any programming language. Next we will learn about functions,
    another very powerful tool. Functions are blocks of code that you create and name
    to perform a specific job. After you have written a function, you can use its
    name to call it from almost anywhere in your program.
  id: totrans-6174
  prefs: []
  type: TYPE_NORMAL
  zh: 了解数组和字典以及如何使用它们是几乎所有编程语言中的强大构建模块。接下来我们将学习函数，这是另一个非常强大的工具。函数是你创建并命名的一段代码，用于执行特定的任务。编写函数后，你可以使用它的名字在程序中的几乎任何地方调用它。
- en: '![Image](Image00125.jpg)'
  id: totrans-6175
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00125.jpg)'
- en: '**REMOVING ITEMS FROM AN ARRAY**'
  id: totrans-6176
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**从数组中删除项**'
- en: 'There are several methods for removing items from an array. Let’s start by
    looking at the array’s removeLast() method. As you might have guessed from its
    name, removeLast() removes the last item from your array. Let’s try it out with
    a shoppingList array:'
  id: totrans-6177
  prefs: []
  type: TYPE_NORMAL
  zh: 删除数组中的项有几种方法。我们先来看一下数组的removeLast()方法。正如你从它的名字中可能猜到的，removeLast()会删除数组中的最后一项。让我们用一个shoppingList数组来试试：
- en: '![](Image00126.jpg)'
  id: totrans-6178
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00126.jpg)'
- en: Neat! Note that the removeLast() method returns the removed item, so you can
    store it in a new constant or variable if you want.
  id: totrans-6179
  prefs: []
  type: TYPE_NORMAL
  zh: 真棒！请注意，removeLast()方法会返回被删除的项，因此如果你想的话，可以将其存储到一个新的常量或变量中。
- en: 'You can also remove an item from a specific index by using the remove(at:)
    method. Let’s say that your mom doesn’t want you buying any candy and takes that
    off the list:'
  id: totrans-6180
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以使用remove(at:)方法从特定的索引删除一项。假设你的妈妈不希望你买任何糖果，并将其从清单中删除：
- en: '![Image](Image00127.jpg)![](Image00128.jpg)'
  id: totrans-6181
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00127.jpg)![](Image00128.jpg)'
- en: Just like when we added an item to the middle of our array and all the items
    scooted over to make room, if you remove an item from the middle of an array,
    the rest of the items will scoot back to fill in that empty space. The "apples"
    item that was at index 3 is now at index 2, where "candy" was.
  id: totrans-6182
  prefs: []
  type: TYPE_NORMAL
  zh: 就像我们将一项添加到数组的中间并且所有项都向后挪动腾出空间一样，如果你从数组中间删除一项，其余项会向前挪动以填补那个空缺的位置。原本位于索引3的"apples"项现在位于索引2，即原本"candy"的位置。
- en: 'You can also remove all items from an array with removeAll() . Try entering
    this into your playground:'
  id: totrans-6183
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以使用removeAll()方法删除数组中的所有项。尝试将这个输入到你的游乐场中：
- en: '![](Image00129.jpg)'
  id: totrans-6184
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00129.jpg)'
- en: 'Note that trying to remove an item at an index that doesn’t exist will give
    you an error:'
  id: totrans-6185
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，尝试删除一个不存在的索引处的项会导致错误：
- en: '![](Image00130.jpg)'
  id: totrans-6186
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00130.jpg)'
- en: Our array doesn’t have this many items (in fact, now it’s empty!), so this throws
    an error. We’ll also get an error if we use removeLast() on our empty array, because
    there’s nothing in it—there’s no last index at all! However, removeAll() is always
    safe to use, even on an empty array.
  id: totrans-6187
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的数组没有这么多项（实际上，现在它是空的！），因此会抛出错误。如果我们在空数组上使用removeLast()，也会抛出错误，因为它里面没有任何东西——根本没有最后一个索引！然而，removeAll()是始终安全的，即使在空数组上使用。
- en: '**REPLACING ITEMS IN AN ARRAY**'
  id: totrans-6188
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**替换数组中的项**'
- en: 'To replace an item in an array, you set the index of the array to the new value,
    as shown here:'
  id: totrans-6189
  prefs: []
  type: TYPE_NORMAL
  zh: 要替换数组中的项，你只需将数组的索引设置为新值，如下所示：
- en: '![](Image00131.jpg)'
  id: totrans-6190
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00131.jpg)'
- en: At ➊ , we replaced the item at index 2 (the third item) with "Unicorn" because
    magical animals count as favorite animals, too! At ➋ , we replaced the item at
    index 0 (the first item) with "Bearded dragon" . No, that’s not a real dragon—it’s
    just a lizard!
  id: totrans-6191
  prefs: []
  type: TYPE_NORMAL
  zh: 在 ➊ 处，我们将索引为2（第三项）的位置的项替换成了"Unicorn"，因为魔法动物也是最喜欢的动物！在 ➋ 处，我们将索引为0（第一项）的位置的项替换成了"Bearded
    dragon"。不，这可不是一条真正的龙——它只是只蜥蜴！
- en: Like any time you’re working with array index numbers, you have to be sure an
    item exists in the array at that index before you change its value, or you will
    get an Index out of range error.
  id: totrans-6192
  prefs: []
  type: TYPE_NORMAL
  zh: 就像你在处理数组索引时一样，在更改值之前，你必须确保该索引处的项目在数组中存在，否则会出现索引超出范围的错误。
- en: '[Figure 6-3](text00016.html#ch06fig3) shows the error that occurs if you try
    to add "Standard poodle" using favoriteAnimals[3] = "Standard poodle" . To add
    an item to the end of an array, you should use the append(_:) method or += , as
    we covered in “[Adding Items to an Array](text00016.html#ch06lev2sec5) ” on [page
    70](text00016.html#page_70) .'
  id: totrans-6193
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 6-3](text00016.html#ch06fig3) 显示了如果你尝试使用 favoriteAnimals[3] = "Standard
    poodle" 添加“标准贵宾犬”时会发生的错误。要向数组末尾添加项目，你应该使用 append(_:) 方法或 +=，正如我们在 “[向数组添加项目](text00016.html#ch06lev2sec5)”（第
    70 页）中所讲解的。'
- en: '![Image](Image00132.jpg)'
  id: totrans-6194
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00132.jpg)'
- en: '*Figure 6-3: Don’t try to replace a value at an index beyond the existing array.*'
  id: totrans-6195
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 6-3：不要尝试替换超出现有数组索引的值。*'
- en: Now you know how to change arrays however you might need to. You can add items,
    take items away, or replace items. Next, we’ll look at how to use the properties
    of arrays to find out even more information about them.
  id: totrans-6196
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你知道如何根据需要更改数组。你可以添加项目、移除项目或替换项目。接下来，我们将看看如何使用数组的属性来获取更多关于数组的信息。
- en: '![Image](Image00133.jpg)'
  id: totrans-6197
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00133.jpg)'
- en: '**USING ARRAY PROPERTIES**'
  id: totrans-6198
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**使用数组属性**'
- en: In addition to methods like append(_:) and removeLast() , arrays also have *properties*
    . An array’s properties are variables or constants that contain some information
    about the array. Two really helpful properties that you might use are the Boolean
    property isEmpty and the integer property count .
  id: totrans-6199
  prefs: []
  type: TYPE_NORMAL
  zh: 除了像 append(_:) 和 removeLast() 这样的函数，数组还有 *属性*。数组的属性是包含数组相关信息的变量或常量。你可能会用到的两个非常有用的属性是布尔值属性
    isEmpty 和整数属性 count。
- en: The isEmpty property is true or false depending on whether the array is empty,
    and the count property will tell you how many items are in that array.
  id: totrans-6200
  prefs: []
  type: TYPE_NORMAL
  zh: isEmpty 属性根据数组是否为空返回 true 或 false，而 count 属性则会告诉你数组中有多少个项目。
- en: 'Check out how these two properties are used in the following if-else statement:'
  id: totrans-6201
  prefs: []
  type: TYPE_NORMAL
  zh: 查看以下 if-else 语句中如何使用这两个属性：
- en: '![Image](Image00134.jpg)'
  id: totrans-6202
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00134.jpg)'
- en: 'This if-else statement checks whether the array mySiblings is empty ➊ . If
    it is, then "I don''t have any siblings." is printed. But if there is something
    in the array, then the number of siblings that we have is printed: "I have 3 siblings."
    ➋ .'
  id: totrans-6203
  prefs: []
  type: TYPE_NORMAL
  zh: 这个 if-else 语句检查数组 mySiblings 是否为空 ➊。如果为空，则打印“我没有兄弟姐妹”。但如果数组中有内容，则会打印我们拥有的兄弟姐妹数量：“我有
    3 个兄弟姐妹。” ➋。
- en: '**LOOPING OVER AN ARRAY**'
  id: totrans-6204
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**遍历数组**'
- en: 'Sometimes when you’re working with arrays you might want to do something to
    every item in the array. You can use a for-in loop to do that! The following code
    will print every topping in a pizzaToppings array on a separate line:'
  id: totrans-6205
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，当你在处理数组时，可能想对数组中的每个项目执行某些操作。你可以使用 for-in 循环来做到这一点！下面的代码将会打印出 pizzaToppings
    数组中的每个配料，每个配料占一行：
- en: '![Image](Image00135.jpg)'
  id: totrans-6206
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00135.jpg)'
- en: To write a for-in loop for the pizzaToppings array, we used the keyword for
    , followed by the constant topping , then the keyword in , and finally the name
    of our array, pizzaToppings . Then we put the statements that we want to run for
    each topping inside the braces of the for-in loop. The constant topping ➊ temporarily
    represents each pizza topping in the array as we loop through it. We could have
    chosen any name for this constant, but it’s a good idea to pick something that
    makes sense. You can see the output of this for-in loop in [Figure 6-4](text00016.html#ch06fig4)
    .
  id: totrans-6207
  prefs: []
  type: TYPE_NORMAL
  zh: 为了为 pizzaToppings 数组编写一个 for-in 循环，我们使用了关键字 for，后跟常量 topping，然后是关键字 in，最后是我们数组的名称
    pizzaToppings。然后，我们将希望对每个 topping 执行的语句放在 for-in 循环的大括号内。常量 topping ➊ 临时表示我们在遍历数组时的每个披萨配料。我们可以为这个常量选择任何名字，但选择一个有意义的名称是一个好主意。你可以在
    [图 6-4](text00016.html#ch06fig4) 中看到这个 for-in 循环的输出。
- en: '![Image](Image00136.jpg)'
  id: totrans-6208
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00136.jpg)'
- en: '*Figure 6-4: Output of the example for-in loop*'
  id: totrans-6209
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 6-4：示例 for-in 循环的输出*'
- en: '![Image](Image00137.jpg)'
  id: totrans-6210
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00137.jpg)'
- en: 'Using for-in loops is great for printing every value in an array. If you’re
    working with numbers, you can even use them to perform math operations on each
    item, which makes for some speedy calculations! The following code takes an array
    of numbers and calculates the square for each (the square of a number is that
    number multiplied by itself):'
  id: totrans-6211
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`for-in`循环非常适合打印数组中的每个值。如果您正在处理数字，甚至可以用它们对每个项目执行数学运算，这样就能迅速完成计算！以下代码接收一个数字数组，并计算每个数字的平方（数字的平方是数字与其自身相乘）：
- en: '![Image](Image00138.jpg)'
  id: totrans-6212
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00138.jpg)'
- en: '[Figure 6-5](text00016.html#ch06fig5) shows the results.'
  id: totrans-6213
  prefs: []
  type: TYPE_NORMAL
  zh: '[图6-5](text00016.html#ch06fig5)展示了结果。'
- en: '![Image](Image00139.jpg)'
  id: totrans-6214
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00139.jpg)'
- en: '*Figure 6-5: Printing the squares for each number in the myNumbers array*'
  id: totrans-6215
  prefs: []
  type: TYPE_NORMAL
  zh: '*图6-5：打印myNumbers数组中每个数字的平方*'
- en: '**DICTIONARIES ARE KEY!**'
  id: totrans-6216
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**字典是关键！**'
- en: A *dictionary* is also a collection of values, but instead of an ordered index,
    each value has its own *key* . Because there’s no index, the values are not stored
    in any particular order. To access values in a dictionary, you look them up by
    their key.
  id: totrans-6217
  prefs: []
  type: TYPE_NORMAL
  zh: '*字典*也是一组值的集合，但不同于有序索引，每个值都有自己的*键*。因为没有索引，所以值并不是按任何特定顺序存储的。要访问字典中的值，您需要通过其键来查找。'
- en: A key must be unique. You can’t have the same key more than once in the same
    dictionary. If there were two identical keys and you asked the computer to give
    you the value for one of them, the computer wouldn’t know which one to choose!
  id: totrans-6218
  prefs: []
  type: TYPE_NORMAL
  zh: 键必须是唯一的。您不能在同一个字典中重复相同的键。如果有两个相同的键，而您要求计算机返回其中一个的值，计算机就不知道选择哪个！
- en: Let’s take a look at how to make a dictionary and write keys that will help
    you find all the information you need.
  id: totrans-6219
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看如何创建字典并编写键，这样您就可以找到所需的所有信息。
- en: '![Image](Image00140.jpg)'
  id: totrans-6220
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00140.jpg)'
- en: '**INITIALIZING A DICTIONARY**'
  id: totrans-6221
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**初始化字典**'
- en: 'To create and initialize a dictionary, first write var and the name of your
    dictionary. Then write the keys and corresponding values inside a pair of square
    brackets, similar to an array. Let’s create a dictionary to store the names of
    a few US states. The key for each state will be its two-letter abbreviation:'
  id: totrans-6222
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建并初始化一个字典，首先写上`var`和字典的名称。然后，将键和值写在一对方括号中，类似于数组。让我们创建一个字典来存储一些美国州的名称。每个州的键将是其两字母缩写：
- en: '![](Image00141.jpg)'
  id: totrans-6223
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00141.jpg)'
- en: As you can see, there’s a colon between each key and its value, and the key/value
    pairs are separated by commas.
  id: totrans-6224
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，键和值之间有一个冒号，键/值对之间用逗号分隔。
- en: Dictionaries are different from arrays in that they are *unordered* . Because
    of that, it’s likely that the order of the states that you see in your results
    pane ➋ is different from the order in which you entered your states ➊ . It might
    even be different than the order that’s printed in this book!
  id: totrans-6225
  prefs: []
  type: TYPE_NORMAL
  zh: 字典与数组的不同之处在于它们是*无序的*。因此，您在结果面板➋中看到的状态顺序很可能与您输入状态的顺序➊不同。甚至可能与本书中打印的顺序不同！
- en: As with arrays, you can use var to make a mutable dictionary or use let to make
    an immutable dictionary.
  id: totrans-6226
  prefs: []
  type: TYPE_NORMAL
  zh: 与数组一样，您可以使用`var`来创建可变字典，或使用`let`来创建不可变字典。
- en: 'In Swift, all of the keys of a dictionary must be the same type, and all of
    the values of a dictionary must also be the same type, but the key type doesn’t
    have to match the value type. For example, if you wanted to store a collection
    of fractions, you could use doubles for the keys and strings for the values:'
  id: totrans-6227
  prefs: []
  type: TYPE_NORMAL
  zh: 在Swift中，字典的所有键必须是相同类型，字典的所有值也必须是相同类型，但键的类型与值的类型不必匹配。例如，如果您想存储一个分数集合，可以使用双精度浮点数作为键，使用字符串作为值：
- en: '![](Image00142.jpg)'
  id: totrans-6228
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00142.jpg)'
- en: In this dictionary, all of the keys must be doubles, and all of the values must
    be strings. Again, you’ll see that the order of the numbers in the results pane
    can be quite different from the order in which you wrote the fractions in your
    dictionary. This is fine because you don’t need to know the order to access anything.
    You can find any item that you need by its key. Let’s see how!
  id: totrans-6229
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个字典中，所有的键必须是双精度浮点数（doubles），所有的值必须是字符串（strings）。再次提醒，您会发现结果面板中的数字顺序可能与您在字典中写入的分数顺序大不相同。这是可以的，因为您不需要知道顺序就可以访问任何内容。您可以通过键来查找所需的任何项。我们来看一下如何操作！
- en: '**ACCESSING VALUES IN A DICTIONARY**'
  id: totrans-6230
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**访问字典中的值**'
- en: 'Looking up a value in a dictionary is similar to how you access a value in
    an array except that you use a key inside the square brackets instead of an index,
    like this: usStates["TX"] .'
  id: totrans-6231
  prefs: []
  type: TYPE_NORMAL
  zh: 在字典中查找值的方式类似于访问数组中的值，不同的是，你在方括号中使用的是键而不是索引，像这样：usStates["TX"]。
- en: There is a big difference, however, in how Swift returns the values from a dictionary.
    When you access a value at an index of an array, you are simply given the value.
    When you access a value with a key in a dictionary, you are given an optional.
  id: totrans-6232
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，Swift从字典中返回值的方式有一个显著区别。当你在数组中访问一个值时，你只是得到该值。而当你使用字典中的键访问一个值时，你得到的是一个可选值。
- en: In [Chapter 5](text00015.html#ch05) , you learned that optionals might contain
    a value or might be nil . The reason Swift returns optionals when you’re looking
    up items in a dictionary is that the key you used might not exist in the dictionary,
    in which case there’s no value to access. Trying to access a value that doesn’t
    exist would give you a big fat error! To avoid that problem, Swift returns optionals.
    That means you need to unwrap any value you get out of a dictionary before you
    can do anything with it.
  id: totrans-6233
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第5章](text00015.html#ch05)中，你学习了可选值可能包含一个值，也可能是nil。当你在字典中查找项时，Swift返回可选值的原因是你使用的键在字典中可能不存在，在这种情况下，就没有值可以访问。尝试访问一个不存在的值会导致一个大错误！为了避免这个问题，Swift返回可选值。这意味着在对字典中的值进行任何操作之前，你需要先解包它。
- en: 'To unwrap an optional, first you check whether it exists using an if-let statement,
    just like we did in [Chapter 5](text00015.html#ch05) . The following code shows
    you how to get a value out of a dictionary:'
  id: totrans-6234
  prefs: []
  type: TYPE_NORMAL
  zh: 要解包一个可选值，首先你需要使用if-let语句检查它是否存在，就像我们在[第5章](text00015.html#ch05)中做的那样。以下代码演示了如何从字典中获取一个值：
- en: '![Image](Image00143.jpg)'
  id: totrans-6235
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00143.jpg)'
- en: To retrieve "Texas" from the dictionary, we use if let to set a constant loneStarState
    to usStates["TX"] ➊ . Because we have this state in our dictionary, the line I
    have Texas in my dictionary. is printed. Next we try to access a state that is
    not in our dictionary by using the key usStates["FL"] ➋ . Thankfully, because
    we used an if-let statement, the program won’t crash when the computer can’t find
    this state. Instead, I don't have that state in my dictionary. is printed.
  id: totrans-6236
  prefs: []
  type: TYPE_NORMAL
  zh: 要从字典中检索"Texas"，我们使用if let将常量loneStarState设置为usStates["TX"] ➊。因为我们在字典中有这个州，所以打印出“我在字典中有Texas”。接下来，我们尝试使用键usStates["FL"]
    ➋来访问一个不在字典中的州。幸运的是，由于我们使用了if-let语句，当计算机找不到这个州时，程序不会崩溃。相反，会打印出“我在字典中没有这个州”。
- en: '**ADDING ITEMS TO A DICTIONARY**'
  id: totrans-6237
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**向字典中添加项**'
- en: 'To add an item to a dictionary, first write the name of your dictionary and
    assign the new item to the key you want it to have in the dictionary. Let’s add
    "Minnesota" to our usStates dictionary:'
  id: totrans-6238
  prefs: []
  type: TYPE_NORMAL
  zh: 要向字典中添加一项，首先写出字典的名称，并将新项分配给你希望它在字典中拥有的键。让我们将"Minnesota"添加到我们的usStates字典中：
- en: '![](Image00144.jpg)'
  id: totrans-6239
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00144.jpg)'
- en: 'Now when you look at usStates , you’ll see that it’s updated to ["MN": "Minnesota",
    "WA": "Washington", "MA": "Massachusetts", "TX": "Texas"] . Remember, because
    you don’t have to rely on indices, your new dictionary item might appear anywhere
    in the dictionary.'
  id: totrans-6240
  prefs: []
  type: TYPE_NORMAL
  zh: '现在，当你查看usStates时，你会看到它已经更新为["MN": "Minnesota", "WA": "Washington", "MA": "Massachusetts",
    "TX": "Texas"]。记住，因为你不需要依赖索引，所以新的字典项可能出现在字典的任何位置。'
- en: '**REMOVING ITEMS FROM A DICTIONARY**'
  id: totrans-6241
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**从字典中移除项**'
- en: Removing an item from a dictionary is quite simple; you do so by setting the
    value to nil . Because the values in dictionaries are returned as optionals, you
    don’t have to worry about nil causing any problems in your dictionary.
  id: totrans-6242
  prefs: []
  type: TYPE_NORMAL
  zh: 从字典中移除一个项非常简单；你只需要将该值设置为nil。因为字典中的值是以可选值的形式返回的，所以你不需要担心nil会在字典中造成问题。
- en: '![](Image00145.jpg)'
  id: totrans-6243
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00145.jpg)'
- en: 'You can see that after you remove the value at the key "MA" , usStates is updated
    to ["MN": "Minnesota", "WA": "Washington", "TX": "Texas"] . Remember that nil
    is special and means that there’s no value at all. That’s why you don’t see "MA":
    nil in our dictionary.'
  id: totrans-6244
  prefs: []
  type: TYPE_NORMAL
  zh: '你可以看到，在你移除键"MA"的值之后，usStates被更新为["MN": "Minnesota", "WA": "Washington", "TX":
    "Texas"]。记住，nil是特殊的，意味着根本没有值。这就是为什么在我们的字典中你看不到"MA": nil。'
- en: '**REPLACING ITEMS IN A DICTIONARY**'
  id: totrans-6245
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**替换字典中的项**'
- en: 'Replacing an item in a dictionary is also easy. It works the same was as replacing
    an item in an array. You just set the item that you want to replace to something
    else. Say you create a dictionary of fruit colors:'
  id: totrans-6246
  prefs: []
  type: TYPE_NORMAL
  zh: 替换字典中的项也很简单。它与替换数组中的项的方式相同。你只需将要替换的项设置为其他值。假设你创建了一个水果颜色的字典：
- en: '![](Image00146.jpg)'
  id: totrans-6247
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00146.jpg)'
- en: At first we had the value "apple" for "red" , but then we decided that "raspberry"
    is a better fruit to use since sometimes apples are green or yellow. To replace
    "apple" with "raspberry" , we set colorFruits["red"] to its new value ➊ .
  id: totrans-6248
  prefs: []
  type: TYPE_NORMAL
  zh: 最开始，我们将值"apple"赋给了"red"键，但后来我们决定使用"raspberry"作为更好的水果，因为有时苹果是绿色或黄色的。为了将"apple"替换为"raspberry"，我们将colorFruits["red"]设置为新的值
    ➊。
- en: You may remember that this is the same way we entered a new value into a dictionary.
    If the key already exists in the dictionary, then the value for that key is replaced.
    If the key doesn’t already exist, then the new key/value pair will be added to
    the dictionary.
  id: totrans-6249
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能还记得，这是我们向字典中添加新值的相同方式。如果键已经存在于字典中，那么该键的值将被替换。如果该键不存在，则新的键/值对将被添加到字典中。
- en: '![Image](Image00147.jpg)'
  id: totrans-6250
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00147.jpg)'
- en: '**USING DICTIONARY PROPERTIES**'
  id: totrans-6251
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**使用字典属性**'
- en: 'Like an array, a dictionary also has an isEmpty property and a count property.
    For example, the following code shows how you can use the isEmpty property to
    check if a dictionary is empty, and if it isn’t empty, the count property checks
    how many items you have. Imagine you have a basket of fruit for sale. You can
    use these properties to help you keep track of everything:'
  id: totrans-6252
  prefs: []
  type: TYPE_NORMAL
  zh: 与数组一样，字典也有isEmpty属性和count属性。例如，下面的代码展示了如何使用isEmpty属性检查字典是否为空，如果不为空，count属性将检查字典中有多少项。想象你有一个水果篮子在销售。你可以使用这些属性来帮助你跟踪所有内容：
- en: '![Image](Image00148.jpg)'
  id: totrans-6253
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00148.jpg)'
- en: 'A dictionary also has two special properties: keys , which contains all of
    the dictionary’s keys, and values , which contains all of its values. We’ll use
    these two properties when we loop through the dictionary.'
  id: totrans-6254
  prefs: []
  type: TYPE_NORMAL
  zh: 字典还有两个特殊属性：keys，它包含字典的所有键，以及values，它包含字典的所有值。当我们遍历字典时，将使用这两个属性。
- en: Let’s write some code that loops through our fruit baskets and prints the price
    of each fruit.
  id: totrans-6255
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们编写一些代码，遍历我们的水果篮子并打印每个水果的价格。
- en: '**LOOPING OVER A DICTIONARY**'
  id: totrans-6256
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**遍历字典**'
- en: 'You can loop through a dictionary using a for-in loop. Because each item has
    a key and a value, you can do this in two different ways. This is how to loop
    through a dictionary using its keys:'
  id: totrans-6257
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用for-in循环遍历字典。因为每个项目都有一个键和值，所以你可以用两种不同的方式进行遍历。这是使用字典的键来遍历字典的方式：
- en: '![Image](Image00149.jpg)'
  id: totrans-6258
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00149.jpg)'
- en: Here we use the dictionary’s keys property ➊ to loop through fruitBasket and
    print its contents. We start by writing the keyword for , followed by a constant
    name fruit for the dictionary key, the keyword in , the dictionary name, a period,
    and keys .
  id: totrans-6259
  prefs: []
  type: TYPE_NORMAL
  zh: 这里我们使用字典的keys属性 ➊ 遍历fruitBasket并打印其内容。我们首先写关键词for，然后是常量名fruit作为字典的键，关键词in，字典名，句点，最后是keys。
- en: Inside the braces of our for-in loop, we have access to both the key, which
    we call fruit ➋ , and the value at that key when we force-unwrap its contents
    with fruitBasket[fruit]! ➌ . That value will be the fruit’s price.
  id: totrans-6260
  prefs: []
  type: TYPE_NORMAL
  zh: 在for-in循环的大括号内部，我们可以访问到键（我们称之为fruit ➋）和该键的值，当我们强制解包fruitBasket[fruit]!时 ➌。该值将是水果的价格。
- en: In this case, it’s safe to force-unwrap the value using an exclamation point
    because we know that the fruit key we’re using is definitely inside the dictionary.
  id: totrans-6261
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，强制解包值时使用感叹号是安全的，因为我们知道我们使用的fruit键肯定在字典中。
- en: Any code we put inside the for-in loop will run once for every key in our dictionary.
    So you should see the print statement display three times.
  id: totrans-6262
  prefs: []
  type: TYPE_NORMAL
  zh: 我们放入for-in循环中的任何代码都会针对字典中的每个键执行一次。因此，你应该会看到打印语句显示三次。
- en: 'We can also loop through the dictionary using its values property:'
  id: totrans-6263
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以使用字典的values属性来遍历字典：
- en: '![Image](Image00150.jpg)'
  id: totrans-6264
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00150.jpg)'
- en: We use the same style of for-in loop, but now we use a constant to refer to
    each value, which we call price , in the values property. When looping through
    values, we don’t have access to the keys from inside the loop.
  id: totrans-6265
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用相同类型的for-in循环，但现在我们使用一个常量来引用values属性中的每个值，我们称之为price。在遍历values时，我们无法在循环内部访问键。
- en: Another difference to note is that price is not an optional because it’s accessed
    directly as a value in the fruitBasket dictionary. That means we don’t have to
    unwrap it. You should still see the print statement printed three times. [Figure
    6-6](text00016.html#ch06fig6) shows the output of both loops.
  id: totrans-6266
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个需要注意的区别是，price不是一个可选值，因为它是直接作为值在fruitBasket字典中访问的。这意味着我们不需要解包它。你仍然应该看到打印语句显示三次。[图6-6](text00016.html#ch06fig6)展示了两个循环的输出。
- en: '![Image](Image00151.jpg)'
  id: totrans-6267
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00151.jpg)'
- en: '*Figure 6-6: Looping through the keys and values of a dictionary with a for-in
    loop*'
  id: totrans-6268
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 6-6：使用 for-in 循环遍历字典的键和值*'
- en: The order of your results might be slightly different from ours. That’s because
    the items in a dictionary aren’t in a numbered order like they are in an array!
    And because the order is not guaranteed, you might see a different order printed
    if you run the same code again.
  id: totrans-6269
  prefs: []
  type: TYPE_NORMAL
  zh: 您的结果顺序可能与我们的略有不同。这是因为字典中的项目不像数组中那样按编号顺序排列！并且由于顺序不被保证，如果您再次运行相同的代码，可能会看到不同的打印顺序。
- en: '**WHAT YOU LEARNED**'
  id: totrans-6270
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**您学到了什么**'
- en: In this chapter, you learned how to store collections of items in an array and
    in a dictionary. To store items in an ordered list, you would use an array and
    look up each item by its index. If you wanted to store items by key instead, you
    would use a dictionary.
  id: totrans-6271
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，您学会了如何在数组和字典中存储项目集合。要在有序列表中存储项目，您将使用数组，并按其索引查找每个项目。如果要根据键存储项目，则将使用字典。
- en: Knowing about arrays and dictionaries and how to use them is a powerful building
    block for almost any programming language. Next we will learn about functions,
    another very powerful tool. Functions are blocks of code that you create and name
    to perform a specific job. After you have written a function, you can use its
    name to call it from almost anywhere in your program.
  id: totrans-6272
  prefs: []
  type: TYPE_NORMAL
  zh: 知道如何使用数组和字典以及如何使用它们是几乎任何编程语言的强大基础模块。接下来我们将学习函数，另一个非常强大的工具。函数是您创建并命名以执行特定任务的代码块。编写函数后，您可以使用其名称从程序的几乎任何位置调用它。
- en: '**REMOVING ITEMS FROM AN ARRAY**'
  id: totrans-6273
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**从数组中删除项目**'
- en: 'There are several methods for removing items from an array. Let’s start by
    looking at the array’s removeLast() method. As you might have guessed from its
    name, removeLast() removes the last item from your array. Let’s try it out with
    a shoppingList array:'
  id: totrans-6274
  prefs: []
  type: TYPE_NORMAL
  zh: 有几种方法可以从数组中删除项目。让我们首先看看数组的 removeLast() 方法。正如您从名称中猜测的那样，removeLast() 会从数组中删除最后一个项目。让我们尝试在
    shoppingList 数组中使用它：
- en: '![](Image00126.jpg)'
  id: totrans-6275
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00126.jpg)'
- en: Neat! Note that the removeLast() method returns the removed item, so you can
    store it in a new constant or variable if you want.
  id: totrans-6276
  prefs: []
  type: TYPE_NORMAL
  zh: 不错！请注意，removeLast() 方法会返回已删除的项目，因此如果需要，您可以将其存储在新的常量或变量中。
- en: 'You can also remove an item from a specific index by using the remove(at:)
    method. Let’s say that your mom doesn’t want you buying any candy and takes that
    off the list:'
  id: totrans-6277
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以通过使用 remove(at:) 方法从特定索引处删除项目。假设您的妈妈不希望您购买任何糖果并将其从列表中移除：
- en: '![Image](Image00127.jpg)![](Image00128.jpg)'
  id: totrans-6278
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Image00127.jpg)![](Image00128.jpg)'
- en: Just like when we added an item to the middle of our array and all the items
    scooted over to make room, if you remove an item from the middle of an array,
    the rest of the items will scoot back to fill in that empty space. The "apples"
    item that was at index 3 is now at index 2, where "candy" was.
  id: totrans-6279
  prefs: []
  type: TYPE_NORMAL
  zh: 就像我们在数组中间添加一个项目并且所有项目都挪动以腾出空间一样，如果您从数组中间删除一个项目，剩余的项目将挪动回来填补空白。原来位于索引 3 处的 "apples"
    现在位于索引 2 处，即 "candy" 所在的地方。
- en: 'You can also remove all items from an array with removeAll() . Try entering
    this into your playground:'
  id: totrans-6280
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以使用 removeAll() 从数组中删除所有项目。尝试在您的 playground 中输入这个：
- en: '![](Image00129.jpg)'
  id: totrans-6281
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00129.jpg)'
- en: 'Note that trying to remove an item at an index that doesn’t exist will give
    you an error:'
  id: totrans-6282
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，尝试删除不存在的索引处的项目将导致错误：
- en: '![](Image00130.jpg)'
  id: totrans-6283
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00130.jpg)'
- en: Our array doesn’t have this many items (in fact, now it’s empty!), so this throws
    an error. We’ll also get an error if we use removeLast() on our empty array, because
    there’s nothing in it—there’s no last index at all! However, removeAll() is always
    safe to use, even on an empty array.
  id: totrans-6284
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的数组没有这么多项（实际上，现在它是空的！），所以会报错。如果我们在空数组上使用 removeLast() 也会报错，因为它里面什么都没有——根本没有最后一个索引！然而，无论何时使用
    removeAll() 都是安全的，即使在空数组上。
- en: '**REPLACING ITEMS IN AN ARRAY**'
  id: totrans-6285
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**在数组中替换项目**'
- en: 'To replace an item in an array, you set the index of the array to the new value,
    as shown here:'
  id: totrans-6286
  prefs: []
  type: TYPE_NORMAL
  zh: 要在数组中替换项目，您可以将数组的索引设置为新值，如下所示：
- en: '![](Image00131.jpg)'
  id: totrans-6287
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00131.jpg)'
- en: At ➊ , we replaced the item at index 2 (the third item) with "Unicorn" because
    magical animals count as favorite animals, too! At ➋ , we replaced the item at
    index 0 (the first item) with "Bearded dragon" . No, that’s not a real dragon—it’s
    just a lizard!
  id: totrans-6288
  prefs: []
  type: TYPE_NORMAL
  zh: 在 ➊ 处，我们替换了索引 2 处（第三个项目）的项目为 "Unicorn"，因为神奇的动物也算作喜爱的动物！在 ➋ 处，我们替换了索引 0 处（第一个项目）的项目为
    "Bearded dragon"。不，它不是真正的龙——它只是一只蜥蜴！
- en: Like any time you’re working with array index numbers, you have to be sure an
    item exists in the array at that index before you change its value, or you will
    get an Index out of range error.
  id: totrans-6289
  prefs: []
  type: TYPE_NORMAL
  zh: 就像在处理数组索引时一样，你必须确保在更改某个索引的值之前，该索引在数组中存在，否则会出现索引超出范围的错误。
- en: '[Figure 6-3](text00016.html#ch06fig3) shows the error that occurs if you try
    to add "Standard poodle" using favoriteAnimals[3] = "Standard poodle" . To add
    an item to the end of an array, you should use the append(_:) method or += , as
    we covered in “[Adding Items to an Array](text00016.html#ch06lev2sec5) ” on [page
    70](text00016.html#page_70) .'
  id: totrans-6290
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 6-3](text00016.html#ch06fig3)显示了如果你尝试使用 favoriteAnimals[3] = "Standard poodle"
    添加 "标准贵宾犬" 时发生的错误。要向数组末尾添加项，应该使用 append(_:) 方法或 += ，我们在 “[向数组添加项](text00016.html#ch06lev2sec5)”
    一节中已经讲过了，[第 70 页](text00016.html#page_70)。'
- en: '![Image](Image00132.jpg)'
  id: totrans-6291
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Image00132.jpg)'
- en: '*Figure 6-3: Don’t try to replace a value at an index beyond the existing array.*'
  id: totrans-6292
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 6-3：不要尝试替换超出现有数组索引的值。*'
- en: Now you know how to change arrays however you might need to. You can add items,
    take items away, or replace items. Next, we’ll look at how to use the properties
    of arrays to find out even more information about them.
  id: totrans-6293
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你知道如何根据需要更改数组了。你可以添加项、删除项或替换项。接下来，我们将学习如何使用数组的属性来获取更多信息。
- en: '![Image](Image00133.jpg)'
  id: totrans-6294
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Image00133.jpg)'
- en: '**USING ARRAY PROPERTIES**'
  id: totrans-6295
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**使用数组属性**'
- en: In addition to methods like append(_:) and removeLast() , arrays also have *properties*
    . An array’s properties are variables or constants that contain some information
    about the array. Two really helpful properties that you might use are the Boolean
    property isEmpty and the integer property count .
  id: totrans-6296
  prefs: []
  type: TYPE_NORMAL
  zh: 除了像 append(_:) 和 removeLast() 这样的函数方法，数组还具有 *属性* 。数组的属性是包含有关数组信息的变量或常量。有两个非常有用的属性，你可能会使用它们，它们分别是布尔值属性
    isEmpty 和整数属性 count 。
- en: The isEmpty property is true or false depending on whether the array is empty,
    and the count property will tell you how many items are in that array.
  id: totrans-6297
  prefs: []
  type: TYPE_NORMAL
  zh: isEmpty 属性的值为 true 或 false，取决于数组是否为空，而 count 属性则告诉你数组中有多少项。
- en: 'Check out how these two properties are used in the following if-else statement:'
  id: totrans-6298
  prefs: []
  type: TYPE_NORMAL
  zh: 请查看以下 if-else 语句中这两个属性的使用方法：
- en: '![Image](Image00134.jpg)'
  id: totrans-6299
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Image00134.jpg)'
- en: 'This if-else statement checks whether the array mySiblings is empty ➊ . If
    it is, then "I don''t have any siblings." is printed. But if there is something
    in the array, then the number of siblings that we have is printed: "I have 3 siblings."
    ➋ .'
  id: totrans-6300
  prefs: []
  type: TYPE_NORMAL
  zh: 这个 if-else 语句检查数组 mySiblings 是否为空 ➊ 。如果为空，则打印 "我没有兄弟姐妹。" 如果数组中有内容，则打印我们有多少个兄弟姐妹："我有
    3 个兄弟姐妹。" ➋ 。
- en: '**LOOPING OVER AN ARRAY**'
  id: totrans-6301
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**遍历数组**'
- en: 'Sometimes when you’re working with arrays you might want to do something to
    every item in the array. You can use a for-in loop to do that! The following code
    will print every topping in a pizzaToppings array on a separate line:'
  id: totrans-6302
  prefs: []
  type: TYPE_NORMAL
  zh: 有时在处理数组时，你可能想对数组中的每一项执行某些操作。你可以使用 for-in 循环来实现！以下代码将在每一行上打印 pizzaToppings 数组中的每个配料：
- en: '![Image](Image00135.jpg)'
  id: totrans-6303
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Image00135.jpg)'
- en: To write a for-in loop for the pizzaToppings array, we used the keyword for
    , followed by the constant topping , then the keyword in , and finally the name
    of our array, pizzaToppings . Then we put the statements that we want to run for
    each topping inside the braces of the for-in loop. The constant topping ➊ temporarily
    represents each pizza topping in the array as we loop through it. We could have
    chosen any name for this constant, but it’s a good idea to pick something that
    makes sense. You can see the output of this for-in loop in [Figure 6-4](text00016.html#ch06fig4)
    .
  id: totrans-6304
  prefs: []
  type: TYPE_NORMAL
  zh: 要为 pizzaToppings 数组编写一个 for-in 循环，我们使用了关键字 for ，后跟常量 topping ，然后是关键字 in ，最后是我们数组的名称
    pizzaToppings 。接着我们将想要在每个 topping 上运行的语句放入 for-in 循环的大括号中。常量 topping ➊ 临时代表数组中的每个披萨配料，随着循环的进行，我们可以访问每个配料。我们本可以为这个常量选择任何名称，但选择一个有意义的名称是个好主意。你可以在[图
    6-4](text00016.html#ch06fig4)中看到这个 for-in 循环的输出。
- en: '![Image](Image00136.jpg)'
  id: totrans-6305
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Image00136.jpg)'
- en: '*Figure 6-4: Output of the example for-in loop*'
  id: totrans-6306
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 6-4：示例中的 for-in 循环输出*'
- en: '![Image](Image00137.jpg)'
  id: totrans-6307
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Image00137.jpg)'
- en: 'Using for-in loops is great for printing every value in an array. If you’re
    working with numbers, you can even use them to perform math operations on each
    item, which makes for some speedy calculations! The following code takes an array
    of numbers and calculates the square for each (the square of a number is that
    number multiplied by itself):'
  id: totrans-6308
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`for-in`循环非常适合打印数组中的每个值。如果您处理的是数字，您甚至可以使用它们对每个项执行数学运算，从而进行快速计算！以下代码取一个数字数组，并计算每个数字的平方（数字的平方是该数字与其本身相乘）：
- en: '![Image](Image00138.jpg)'
  id: totrans-6309
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00138.jpg)'
- en: '[Figure 6-5](text00016.html#ch06fig5) shows the results.'
  id: totrans-6310
  prefs: []
  type: TYPE_NORMAL
  zh: '[图6-5](text00016.html#ch06fig5)显示了结果。'
- en: '![Image](Image00139.jpg)'
  id: totrans-6311
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00139.jpg)'
- en: '*Figure 6-5: Printing the squares for each number in the myNumbers array*'
  id: totrans-6312
  prefs: []
  type: TYPE_NORMAL
  zh: '*图6-5：打印myNumbers数组中每个数字的平方*'
- en: '**DICTIONARIES ARE KEY!**'
  id: totrans-6313
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**字典是关键！**'
- en: A *dictionary* is also a collection of values, but instead of an ordered index,
    each value has its own *key* . Because there’s no index, the values are not stored
    in any particular order. To access values in a dictionary, you look them up by
    their key.
  id: totrans-6314
  prefs: []
  type: TYPE_NORMAL
  zh: '*字典*也是一个值的集合，但与有序索引不同，每个值都有自己的*键*。由于没有索引，值不会按特定顺序存储。要访问字典中的值，您需要通过键查找它们。'
- en: A key must be unique. You can’t have the same key more than once in the same
    dictionary. If there were two identical keys and you asked the computer to give
    you the value for one of them, the computer wouldn’t know which one to choose!
  id: totrans-6315
  prefs: []
  type: TYPE_NORMAL
  zh: 键必须是唯一的。您不能在同一个字典中重复使用相同的键。如果有两个相同的键，并且您请求计算机返回其中一个的值，计算机将无法决定选择哪个！
- en: Let’s take a look at how to make a dictionary and write keys that will help
    you find all the information you need.
  id: totrans-6316
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如何创建字典并编写键，帮助您找到所需的所有信息。
- en: '![Image](Image00140.jpg)'
  id: totrans-6317
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00140.jpg)'
- en: '**INITIALIZING A DICTIONARY**'
  id: totrans-6318
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**初始化字典**'
- en: 'To create and initialize a dictionary, first write var and the name of your
    dictionary. Then write the keys and corresponding values inside a pair of square
    brackets, similar to an array. Let’s create a dictionary to store the names of
    a few US states. The key for each state will be its two-letter abbreviation:'
  id: totrans-6319
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建和初始化字典，首先写`var`和字典的名称。然后，将键及其对应的值写在一对方括号内，类似于数组。我们来创建一个字典，存储一些美国州的名称。每个州的键将是它的两字母缩写：
- en: '![](Image00141.jpg)'
  id: totrans-6320
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00141.jpg)'
- en: As you can see, there’s a colon between each key and its value, and the key/value
    pairs are separated by commas.
  id: totrans-6321
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，每个键和值之间有一个冒号，键/值对之间用逗号分隔。
- en: Dictionaries are different from arrays in that they are *unordered* . Because
    of that, it’s likely that the order of the states that you see in your results
    pane ➋ is different from the order in which you entered your states ➊ . It might
    even be different than the order that’s printed in this book!
  id: totrans-6322
  prefs: []
  type: TYPE_NORMAL
  zh: 字典与数组不同，字典是*无序的*。因此，您在结果面板➋中看到的状态顺序可能与您输入状态➊的顺序不同，甚至可能与本书中打印的顺序不同！
- en: As with arrays, you can use var to make a mutable dictionary or use let to make
    an immutable dictionary.
  id: totrans-6323
  prefs: []
  type: TYPE_NORMAL
  zh: 与数组一样，您可以使用`var`来创建可变字典，或使用`let`来创建不可变字典。
- en: 'In Swift, all of the keys of a dictionary must be the same type, and all of
    the values of a dictionary must also be the same type, but the key type doesn’t
    have to match the value type. For example, if you wanted to store a collection
    of fractions, you could use doubles for the keys and strings for the values:'
  id: totrans-6324
  prefs: []
  type: TYPE_NORMAL
  zh: 在Swift中，字典的所有键必须是相同类型，字典的所有值也必须是相同类型，但键类型不必与值类型匹配。例如，如果您想存储一个分数集合，可以使用`double`作为键，使用`string`作为值：
- en: '![](Image00142.jpg)'
  id: totrans-6325
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00142.jpg)'
- en: In this dictionary, all of the keys must be doubles, and all of the values must
    be strings. Again, you’ll see that the order of the numbers in the results pane
    can be quite different from the order in which you wrote the fractions in your
    dictionary. This is fine because you don’t need to know the order to access anything.
    You can find any item that you need by its key. Let’s see how!
  id: totrans-6326
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个字典中，所有的键必须是`double`类型，所有的值必须是`string`类型。同样，您会看到结果面板中的数字顺序可能与您在字典中写下分数的顺序有很大不同。这是正常的，因为您无需知道顺序就能访问任何内容。您可以通过键找到任何所需的项目。让我们看看如何操作！
- en: '**ACCESSING VALUES IN A DICTIONARY**'
  id: totrans-6327
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**访问字典中的值**'
- en: 'Looking up a value in a dictionary is similar to how you access a value in
    an array except that you use a key inside the square brackets instead of an index,
    like this: usStates["TX"] .'
  id: totrans-6328
  prefs: []
  type: TYPE_NORMAL
  zh: 查找字典中的值与访问数组中的值类似，只是你使用键而不是索引，像这样：usStates["TX"]。
- en: There is a big difference, however, in how Swift returns the values from a dictionary.
    When you access a value at an index of an array, you are simply given the value.
    When you access a value with a key in a dictionary, you are given an optional.
  id: totrans-6329
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在 Swift 从字典返回值时，存在一个重大区别。当你访问数组中某个索引的值时，你只是简单地得到那个值。当你使用键访问字典中的值时，你得到的是一个可选项。
- en: In [Chapter 5](text00015.html#ch05) , you learned that optionals might contain
    a value or might be nil . The reason Swift returns optionals when you’re looking
    up items in a dictionary is that the key you used might not exist in the dictionary,
    in which case there’s no value to access. Trying to access a value that doesn’t
    exist would give you a big fat error! To avoid that problem, Swift returns optionals.
    That means you need to unwrap any value you get out of a dictionary before you
    can do anything with it.
  id: totrans-6330
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第 5 章](text00015.html#ch05)中，你学到了可选项可能包含一个值，也可能是 nil。当你在字典中查找项目时，Swift 返回可选项的原因是你使用的键可能在字典中不存在，在这种情况下就没有值可以访问。试图访问一个不存在的值会导致一个严重的错误！为了避免这个问题，Swift
    返回可选项。这意味着你需要解包从字典中获取的任何值，才能对其进行操作。
- en: 'To unwrap an optional, first you check whether it exists using an if-let statement,
    just like we did in [Chapter 5](text00015.html#ch05) . The following code shows
    you how to get a value out of a dictionary:'
  id: totrans-6331
  prefs: []
  type: TYPE_NORMAL
  zh: 要解包一个可选项，首先使用 if-let 语句检查它是否存在，就像我们在[第 5 章](text00015.html#ch05)中做的那样。以下代码展示了如何从字典中获取一个值：
- en: '![Image](Image00143.jpg)'
  id: totrans-6332
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00143.jpg)'
- en: To retrieve "Texas" from the dictionary, we use if let to set a constant loneStarState
    to usStates["TX"] ➊ . Because we have this state in our dictionary, the line I
    have Texas in my dictionary. is printed. Next we try to access a state that is
    not in our dictionary by using the key usStates["FL"] ➋ . Thankfully, because
    we used an if-let statement, the program won’t crash when the computer can’t find
    this state. Instead, I don't have that state in my dictionary. is printed.
  id: totrans-6333
  prefs: []
  type: TYPE_NORMAL
  zh: 为了从字典中获取“Texas”，我们使用 `if let` 将常量 loneStarState 设置为 usStates["TX"] ➊。因为我们的字典中有这个州，所以会打印出“我在我的字典里有
    Texas”。接下来，我们尝试使用键 usStates["FL"] ➋ 来访问一个字典中没有的州。幸运的是，因为我们使用了 if-let 语句，当计算机找不到该州时，程序不会崩溃。相反，它会打印出“我在我的字典里没有这个州”。
- en: '**ADDING ITEMS TO A DICTIONARY**'
  id: totrans-6334
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**向字典中添加项目**'
- en: 'To add an item to a dictionary, first write the name of your dictionary and
    assign the new item to the key you want it to have in the dictionary. Let’s add
    "Minnesota" to our usStates dictionary:'
  id: totrans-6335
  prefs: []
  type: TYPE_NORMAL
  zh: 要向字典中添加一个项目，首先写出字典的名称，然后将新项目赋值给你希望它在字典中对应的键。让我们将 "Minnesota" 添加到我们的 usStates
    字典中：
- en: '![](Image00144.jpg)'
  id: totrans-6336
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00144.jpg)'
- en: 'Now when you look at usStates , you’ll see that it’s updated to ["MN": "Minnesota",
    "WA": "Washington", "MA": "Massachusetts", "TX": "Texas"] . Remember, because
    you don’t have to rely on indices, your new dictionary item might appear anywhere
    in the dictionary.'
  id: totrans-6337
  prefs: []
  type: TYPE_NORMAL
  zh: '现在，当你查看 usStates 时，你会看到它已经更新为 ["MN": "Minnesota", "WA": "Washington", "MA":
    "Massachusetts", "TX": "Texas"]。记住，因为你不必依赖索引，你的新字典项目可能出现在字典中的任何位置。'
- en: '**REMOVING ITEMS FROM A DICTIONARY**'
  id: totrans-6338
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**从字典中删除项目**'
- en: Removing an item from a dictionary is quite simple; you do so by setting the
    value to nil . Because the values in dictionaries are returned as optionals, you
    don’t have to worry about nil causing any problems in your dictionary.
  id: totrans-6339
  prefs: []
  type: TYPE_NORMAL
  zh: 从字典中删除一个项目非常简单；你只需要将该值设置为 nil。因为字典中的值作为可选项返回，所以你不必担心 nil 会在字典中造成任何问题。
- en: '![](Image00145.jpg)'
  id: totrans-6340
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00145.jpg)'
- en: 'You can see that after you remove the value at the key "MA" , usStates is updated
    to ["MN": "Minnesota", "WA": "Washington", "TX": "Texas"] . Remember that nil
    is special and means that there’s no value at all. That’s why you don’t see "MA":
    nil in our dictionary.'
  id: totrans-6341
  prefs: []
  type: TYPE_NORMAL
  zh: '你可以看到，在删除键 "MA" 对应的值后，usStates 被更新为 ["MN": "Minnesota", "WA": "Washington",
    "TX": "Texas"]。记住，nil 是特殊的，表示没有任何值。这就是为什么你在我们的字典中看不到 "MA": nil。'
- en: '**REPLACING ITEMS IN A DICTIONARY**'
  id: totrans-6342
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**替换字典中的项目**'
- en: 'Replacing an item in a dictionary is also easy. It works the same was as replacing
    an item in an array. You just set the item that you want to replace to something
    else. Say you create a dictionary of fruit colors:'
  id: totrans-6343
  prefs: []
  type: TYPE_NORMAL
  zh: 替换字典中的项目也很简单。它的工作方式和替换数组中的项目一样。你只需要将你想替换的项目设置为其他内容。例如，你创建了一个表示水果颜色的字典：
- en: '![](Image00146.jpg)'
  id: totrans-6344
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00146.jpg)'
- en: At first we had the value "apple" for "red" , but then we decided that "raspberry"
    is a better fruit to use since sometimes apples are green or yellow. To replace
    "apple" with "raspberry" , we set colorFruits["red"] to its new value ➊ .
  id: totrans-6345
  prefs: []
  type: TYPE_NORMAL
  zh: 一开始我们为"red"设置的值是"apple"，但后来我们决定使用"raspberry"作为更合适的水果，因为有时候苹果是绿色或黄色的。要将"apple"替换为"raspberry"，我们将`colorFruits["red"]`设置为新的值➊。
- en: You may remember that this is the same way we entered a new value into a dictionary.
    If the key already exists in the dictionary, then the value for that key is replaced.
    If the key doesn’t already exist, then the new key/value pair will be added to
    the dictionary.
  id: totrans-6346
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能记得我们之前是用相同的方式将新值添加到字典中的。如果键已经存在于字典中，则该键的值将被替换。如果键不存在，则新键值对将被添加到字典中。
- en: '![Image](Image00147.jpg)'
  id: totrans-6347
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00147.jpg)'
- en: '**USING DICTIONARY PROPERTIES**'
  id: totrans-6348
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**使用字典属性**'
- en: 'Like an array, a dictionary also has an isEmpty property and a count property.
    For example, the following code shows how you can use the isEmpty property to
    check if a dictionary is empty, and if it isn’t empty, the count property checks
    how many items you have. Imagine you have a basket of fruit for sale. You can
    use these properties to help you keep track of everything:'
  id: totrans-6349
  prefs: []
  type: TYPE_NORMAL
  zh: 类似于数组，字典也有`isEmpty`属性和`count`属性。例如，下面的代码展示了如何使用`isEmpty`属性来检查字典是否为空，如果字典不为空，`count`属性可以检查字典中有多少项。假设你有一个待售的水果篮子。你可以利用这些属性帮助你跟踪所有内容：
- en: '![Image](Image00148.jpg)'
  id: totrans-6350
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00148.jpg)'
- en: 'A dictionary also has two special properties: keys , which contains all of
    the dictionary’s keys, and values , which contains all of its values. We’ll use
    these two properties when we loop through the dictionary.'
  id: totrans-6351
  prefs: []
  type: TYPE_NORMAL
  zh: 字典还有两个特殊的属性：`keys`，包含字典的所有键，以及`values`，包含字典的所有值。我们将在遍历字典时使用这两个属性。
- en: Let’s write some code that loops through our fruit baskets and prints the price
    of each fruit.
  id: totrans-6352
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们编写一些代码，遍历我们的水果篮子并打印每种水果的价格。
- en: '**LOOPING OVER A DICTIONARY**'
  id: totrans-6353
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**遍历字典**'
- en: 'You can loop through a dictionary using a for-in loop. Because each item has
    a key and a value, you can do this in two different ways. This is how to loop
    through a dictionary using its keys:'
  id: totrans-6354
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用`for-in`循环遍历字典。由于每个项目都有一个键和值，因此你可以用两种不同的方式来遍历字典。下面是使用字典的键来遍历字典的方法：
- en: '![Image](Image00149.jpg)'
  id: totrans-6355
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00149.jpg)'
- en: Here we use the dictionary’s keys property ➊ to loop through fruitBasket and
    print its contents. We start by writing the keyword for , followed by a constant
    name fruit for the dictionary key, the keyword in , the dictionary name, a period,
    and keys .
  id: totrans-6356
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们使用字典的`keys`属性➊来遍历fruitBasket并打印其内容。我们从写`for`关键字开始，后面跟一个常量名`fruit`表示字典的键，再加上`in`关键字，接着是字典的名称，接着是一个点，最后是`keys`。
- en: Inside the braces of our for-in loop, we have access to both the key, which
    we call fruit ➋ , and the value at that key when we force-unwrap its contents
    with fruitBasket[fruit]! ➌ . That value will be the fruit’s price.
  id: totrans-6357
  prefs: []
  type: TYPE_NORMAL
  zh: 在`for-in`循环的花括号内，我们可以访问到键（我们称之为`fruit`➋）以及该键对应的值，强制解包其内容`fruitBasket[fruit]!`➌后，该值将是水果的价格。
- en: In this case, it’s safe to force-unwrap the value using an exclamation point
    because we know that the fruit key we’re using is definitely inside the dictionary.
  id: totrans-6358
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，由于我们知道所使用的`fruit`键肯定在字典中，因此可以安全地使用感叹号强制解包值。
- en: Any code we put inside the for-in loop will run once for every key in our dictionary.
    So you should see the print statement display three times.
  id: totrans-6359
  prefs: []
  type: TYPE_NORMAL
  zh: 我们放在`for-in`循环内部的任何代码都会为字典中的每个键执行一次。所以你应该看到`print`语句被打印三次。
- en: 'We can also loop through the dictionary using its values property:'
  id: totrans-6360
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以使用字典的`values`属性来遍历字典：
- en: '![Image](Image00150.jpg)'
  id: totrans-6361
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00150.jpg)'
- en: We use the same style of for-in loop, but now we use a constant to refer to
    each value, which we call price , in the values property. When looping through
    values, we don’t have access to the keys from inside the loop.
  id: totrans-6362
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用相同风格的`for-in`循环，但现在我们使用常量来引用`values`属性中的每个值，我们称之为`price`。在遍历`values`时，我们无法从循环内访问键。
- en: Another difference to note is that price is not an optional because it’s accessed
    directly as a value in the fruitBasket dictionary. That means we don’t have to
    unwrap it. You should still see the print statement printed three times. [Figure
    6-6](text00016.html#ch06fig6) shows the output of both loops.
  id: totrans-6363
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个需要注意的区别是，`price`不是可选的，因为它是直接作为值访问`fruitBasket`字典中的内容。这意味着我们不需要解包它。你应该仍然能看到`print`语句被打印三次。[图6-6](text00016.html#ch06fig6)展示了两个循环的输出。
- en: '![Image](Image00151.jpg)'
  id: totrans-6364
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00151.jpg)'
- en: '*Figure 6-6: Looping through the keys and values of a dictionary with a for-in
    loop*'
  id: totrans-6365
  prefs: []
  type: TYPE_NORMAL
  zh: '*图6-6：使用 for-in 循环遍历字典的键和值*'
- en: The order of your results might be slightly different from ours. That’s because
    the items in a dictionary aren’t in a numbered order like they are in an array!
    And because the order is not guaranteed, you might see a different order printed
    if you run the same code again.
  id: totrans-6366
  prefs: []
  type: TYPE_NORMAL
  zh: 你的结果顺序可能与我们的略有不同。这是因为字典中的项目不像数组那样按数字顺序排列！由于顺序无法保证，如果你再次运行相同的代码，打印出来的顺序可能会不同。
- en: '**WHAT YOU LEARNED**'
  id: totrans-6367
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**你学到了什么**'
- en: In this chapter, you learned how to store collections of items in an array and
    in a dictionary. To store items in an ordered list, you would use an array and
    look up each item by its index. If you wanted to store items by key instead, you
    would use a dictionary.
  id: totrans-6368
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你学习了如何将多个项目存储在数组和字典中。要将项目存储在一个有序的列表中，你可以使用数组，并通过索引查找每个项目。如果你想通过键来存储项目，则应使用字典。
- en: Knowing about arrays and dictionaries and how to use them is a powerful building
    block for almost any programming language. Next we will learn about functions,
    another very powerful tool. Functions are blocks of code that you create and name
    to perform a specific job. After you have written a function, you can use its
    name to call it from almost anywhere in your program.
  id: totrans-6369
  prefs: []
  type: TYPE_NORMAL
  zh: 了解数组和字典及其用法是几乎所有编程语言中的一个强大基础。接下来，我们将学习函数，这是另一项非常强大的工具。函数是你创建并命名的一段代码，用于执行特定任务。编写函数后，你可以通过它的名称在程序中的任何地方调用它。
- en: 'There are several methods for removing items from an array. Let’s start by
    looking at the array’s removeLast() method. As you might have guessed from its
    name, removeLast() removes the last item from your array. Let’s try it out with
    a shoppingList array:'
  id: totrans-6370
  prefs: []
  type: TYPE_NORMAL
  zh: 有多种方法可以从数组中移除项目。我们首先来看数组的 removeLast() 方法。你或许可以从名字猜到，removeLast() 会移除数组中的最后一项。我们来尝试一下
    shoppingList 数组：
- en: '![](Image00126.jpg)'
  id: totrans-6371
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00126.jpg)'
- en: Neat! Note that the removeLast() method returns the removed item, so you can
    store it in a new constant or variable if you want.
  id: totrans-6372
  prefs: []
  type: TYPE_NORMAL
  zh: 很棒！注意，removeLast() 方法会返回被移除的项目，所以如果需要，你可以将其存储在一个新的常量或变量中。
- en: 'You can also remove an item from a specific index by using the remove(at:)
    method. Let’s say that your mom doesn’t want you buying any candy and takes that
    off the list:'
  id: totrans-6373
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以通过使用 remove(at:) 方法从特定索引移除项目。假设你的妈妈不想让你买糖果，于是将其从列表中移除：
- en: '![Image](Image00127.jpg)![](Image00128.jpg)'
  id: totrans-6374
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00127.jpg)![](Image00128.jpg)'
- en: Just like when we added an item to the middle of our array and all the items
    scooted over to make room, if you remove an item from the middle of an array,
    the rest of the items will scoot back to fill in that empty space. The "apples"
    item that was at index 3 is now at index 2, where "candy" was.
  id: totrans-6375
  prefs: []
  type: TYPE_NORMAL
  zh: 就像我们在数组中间添加项目时，所有项目会自动移动以腾出空间一样，如果你从数组中间移除一个项目，其余的项目会自动向前移动，填补空缺。原本位于索引3的“苹果”现在位于索引2的位置，这里曾经是“糖果”。
- en: 'You can also remove all items from an array with removeAll() . Try entering
    this into your playground:'
  id: totrans-6376
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以使用 removeAll() 方法移除数组中的所有项目。尝试在你的 Playground 中输入这个命令：
- en: '![](Image00129.jpg)'
  id: totrans-6377
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00129.jpg)'
- en: 'Note that trying to remove an item at an index that doesn’t exist will give
    you an error:'
  id: totrans-6378
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，尝试从一个不存在的索引位置移除项目会导致错误：
- en: '![](Image00130.jpg)'
  id: totrans-6379
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00130.jpg)'
- en: Our array doesn’t have this many items (in fact, now it’s empty!), so this throws
    an error. We’ll also get an error if we use removeLast() on our empty array, because
    there’s nothing in it—there’s no last index at all! However, removeAll() is always
    safe to use, even on an empty array.
  id: totrans-6380
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的数组中没有这么多项目（事实上，现在它已经空了！），所以这会抛出一个错误。如果我们在空数组上使用 removeLast()，也会报错，因为数组中没有任何元素——根本没有最后一个索引！然而，removeAll()
    方法是始终安全的，即使在空数组上也可以使用。
- en: '**REPLACING ITEMS IN AN ARRAY**'
  id: totrans-6381
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**替换数组中的项目**'
- en: 'To replace an item in an array, you set the index of the array to the new value,
    as shown here:'
  id: totrans-6382
  prefs: []
  type: TYPE_NORMAL
  zh: 要替换数组中的一个项目，你需要将该数组的索引设置为新值，如下所示：
- en: '![](Image00131.jpg)'
  id: totrans-6383
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00131.jpg)'
- en: At ➊ , we replaced the item at index 2 (the third item) with "Unicorn" because
    magical animals count as favorite animals, too! At ➋ , we replaced the item at
    index 0 (the first item) with "Bearded dragon" . No, that’s not a real dragon—it’s
    just a lizard!
  id: totrans-6384
  prefs: []
  type: TYPE_NORMAL
  zh: 在 ➊，我们将索引为2（即第三项）的项目替换为“独角兽”，因为神奇的动物也算是最爱的动物！在 ➋，我们将索引为0（即第一项）的项目替换为“须龙”。不，这可不是一条真正的龙——它只是一个蜥蜴！
- en: Like any time you’re working with array index numbers, you have to be sure an
    item exists in the array at that index before you change its value, or you will
    get an Index out of range error.
  id: totrans-6385
  prefs: []
  type: TYPE_NORMAL
  zh: 就像处理数组索引时一样，必须确保在更改值之前，数组中该索引位置确实有一个项，否则会出现“索引超出范围”错误。
- en: '[Figure 6-3](text00016.html#ch06fig3) shows the error that occurs if you try
    to add "Standard poodle" using favoriteAnimals[3] = "Standard poodle" . To add
    an item to the end of an array, you should use the append(_:) method or += , as
    we covered in “[Adding Items to an Array](text00016.html#ch06lev2sec5) ” on [page
    70](text00016.html#page_70) .'
  id: totrans-6386
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 6-3](text00016.html#ch06fig3)展示了如果你尝试使用 favoriteAnimals[3] = "标准贵宾犬" 添加元素时发生的错误。要将项目添加到数组的末尾，应该使用
    append(_:) 方法或 +=，正如我们在 “[向数组添加项](text00016.html#ch06lev2sec5)” 一节中提到的那样，详见[第
    70 页](text00016.html#page_70)。'
- en: '![Image](Image00132.jpg)'
  id: totrans-6387
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00132.jpg)'
- en: '*Figure 6-3: Don’t try to replace a value at an index beyond the existing array.*'
  id: totrans-6388
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 6-3：不要尝试替换超出现有数组索引范围的值。*'
- en: Now you know how to change arrays however you might need to. You can add items,
    take items away, or replace items. Next, we’ll look at how to use the properties
    of arrays to find out even more information about them.
  id: totrans-6389
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你知道如何根据需要更改数组了。你可以添加元素、删除元素或替换元素。接下来，我们将看看如何使用数组的属性来获取更多有关它们的信息。
- en: '![Image](Image00133.jpg)'
  id: totrans-6390
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00133.jpg)'
- en: '**USING ARRAY PROPERTIES**'
  id: totrans-6391
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**使用数组属性**'
- en: In addition to methods like append(_:) and removeLast() , arrays also have *properties*
    . An array’s properties are variables or constants that contain some information
    about the array. Two really helpful properties that you might use are the Boolean
    property isEmpty and the integer property count .
  id: totrans-6392
  prefs: []
  type: TYPE_NORMAL
  zh: 除了像 append(_:) 和 removeLast() 这样的操作方法外，数组还有 *属性*。数组的属性是包含有关数组的一些信息的变量或常量。你可能会使用的两个非常有用的属性是布尔值属性
    isEmpty 和整数属性 count。
- en: The isEmpty property is true or false depending on whether the array is empty,
    and the count property will tell you how many items are in that array.
  id: totrans-6393
  prefs: []
  type: TYPE_NORMAL
  zh: isEmpty 属性会根据数组是否为空返回 true 或 false，count 属性会告诉你数组中有多少个元素。
- en: 'Check out how these two properties are used in the following if-else statement:'
  id: totrans-6394
  prefs: []
  type: TYPE_NORMAL
  zh: 看一下以下 if-else 语句中这两个属性是如何使用的：
- en: '![Image](Image00134.jpg)'
  id: totrans-6395
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00134.jpg)'
- en: 'This if-else statement checks whether the array mySiblings is empty ➊ . If
    it is, then "I don''t have any siblings." is printed. But if there is something
    in the array, then the number of siblings that we have is printed: "I have 3 siblings."
    ➋ .'
  id: totrans-6396
  prefs: []
  type: TYPE_NORMAL
  zh: 这个 if-else 语句检查数组 mySiblings 是否为空 ➊。如果为空，则输出 "我没有兄弟姐妹"。但如果数组中有内容，则输出我们有几个兄弟姐妹："我有
    3 个兄弟姐妹。" ➋。
- en: '**LOOPING OVER AN ARRAY**'
  id: totrans-6397
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**遍历数组**'
- en: 'Sometimes when you’re working with arrays you might want to do something to
    every item in the array. You can use a for-in loop to do that! The following code
    will print every topping in a pizzaToppings array on a separate line:'
  id: totrans-6398
  prefs: []
  type: TYPE_NORMAL
  zh: 有时在处理数组时，你可能想对数组中的每一项做些事情。你可以使用 for-in 循环来实现！以下代码将打印出 pizzaToppings 数组中的每个配料，每行一个：
- en: '![Image](Image00135.jpg)'
  id: totrans-6399
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00135.jpg)'
- en: To write a for-in loop for the pizzaToppings array, we used the keyword for
    , followed by the constant topping , then the keyword in , and finally the name
    of our array, pizzaToppings . Then we put the statements that we want to run for
    each topping inside the braces of the for-in loop. The constant topping ➊ temporarily
    represents each pizza topping in the array as we loop through it. We could have
    chosen any name for this constant, but it’s a good idea to pick something that
    makes sense. You can see the output of this for-in loop in [Figure 6-4](text00016.html#ch06fig4)
    .
  id: totrans-6400
  prefs: []
  type: TYPE_NORMAL
  zh: 要为 pizzaToppings 数组编写一个 for-in 循环，我们使用了关键字 for，后跟常量 topping，再接着是关键字 in，最后是数组的名称
    pizzaToppings。然后，我们将希望对每个 topping 执行的语句放在 for-in 循环的花括号内。常量 topping ➊ 临时代表数组中每个配料项，在我们遍历数组时。我们本可以选择任何名字作为这个常量的名称，但最好选择一个有意义的名称。你可以在[图
    6-4](text00016.html#ch06fig4)中查看这个 for-in 循环的输出。
- en: '![Image](Image00136.jpg)'
  id: totrans-6401
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00136.jpg)'
- en: '*Figure 6-4: Output of the example for-in loop*'
  id: totrans-6402
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 6-4：示例 for-in 循环的输出*'
- en: '![Image](Image00137.jpg)'
  id: totrans-6403
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00137.jpg)'
- en: 'Using for-in loops is great for printing every value in an array. If you’re
    working with numbers, you can even use them to perform math operations on each
    item, which makes for some speedy calculations! The following code takes an array
    of numbers and calculates the square for each (the square of a number is that
    number multiplied by itself):'
  id: totrans-6404
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 for-in 循环非常适合打印数组中的每个值。如果你正在处理数字，你甚至可以利用它们对每个项目执行数学运算，这样可以加速计算！以下代码将取一个数字数组，并计算每个数字的平方（数字的平方是该数字与自身相乘）：
- en: '![Image](Image00138.jpg)'
  id: totrans-6405
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00138.jpg)'
- en: '[Figure 6-5](text00016.html#ch06fig5) shows the results.'
  id: totrans-6406
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 6-5](text00016.html#ch06fig5)显示了结果。'
- en: '![Image](Image00139.jpg)'
  id: totrans-6407
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00139.jpg)'
- en: '*Figure 6-5: Printing the squares for each number in the myNumbers array*'
  id: totrans-6408
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 6-5：打印 myNumbers 数组中每个数字的平方*'
- en: '**DICTIONARIES ARE KEY!**'
  id: totrans-6409
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**字典是关键！**'
- en: A *dictionary* is also a collection of values, but instead of an ordered index,
    each value has its own *key* . Because there’s no index, the values are not stored
    in any particular order. To access values in a dictionary, you look them up by
    their key.
  id: totrans-6410
  prefs: []
  type: TYPE_NORMAL
  zh: '*字典* 也是一组值的集合，但与有序索引不同，每个值都有自己的 *键* 。由于没有索引，值的存储顺序并不重要。要访问字典中的值，你可以通过它们的键来查找。'
- en: A key must be unique. You can’t have the same key more than once in the same
    dictionary. If there were two identical keys and you asked the computer to give
    you the value for one of them, the computer wouldn’t know which one to choose!
  id: totrans-6411
  prefs: []
  type: TYPE_NORMAL
  zh: 一个键必须是唯一的。你不能在同一个字典中有重复的键。如果有两个相同的键，并且你要求计算机给出其中一个的值，计算机就无法知道该选择哪个！
- en: Let’s take a look at how to make a dictionary and write keys that will help
    you find all the information you need.
  id: totrans-6412
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如何创建一个字典，并编写键以帮助你找到所需的所有信息。
- en: '![Image](Image00140.jpg)'
  id: totrans-6413
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00140.jpg)'
- en: '**INITIALIZING A DICTIONARY**'
  id: totrans-6414
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**初始化字典**'
- en: 'To create and initialize a dictionary, first write var and the name of your
    dictionary. Then write the keys and corresponding values inside a pair of square
    brackets, similar to an array. Let’s create a dictionary to store the names of
    a few US states. The key for each state will be its two-letter abbreviation:'
  id: totrans-6415
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建并初始化一个字典，首先写 var 和字典的名称。然后将键和对应的值写在一对方括号内，类似于数组。让我们创建一个字典来存储一些美国州的名称。每个州的键将是它的两个字母缩写：
- en: '![](Image00141.jpg)'
  id: totrans-6416
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00141.jpg)'
- en: As you can see, there’s a colon between each key and its value, and the key/value
    pairs are separated by commas.
  id: totrans-6417
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，每个键和值之间有一个冒号，键/值对之间用逗号分隔。
- en: Dictionaries are different from arrays in that they are *unordered* . Because
    of that, it’s likely that the order of the states that you see in your results
    pane ➋ is different from the order in which you entered your states ➊ . It might
    even be different than the order that’s printed in this book!
  id: totrans-6418
  prefs: []
  type: TYPE_NORMAL
  zh: 字典与数组的不同之处在于它们是 *无序的* 。因此，你在结果窗格中看到的状态顺序 ➋ 可能与输入状态的顺序 ➊ 不同。它甚至可能与本书中打印的顺序不同！
- en: As with arrays, you can use var to make a mutable dictionary or use let to make
    an immutable dictionary.
  id: totrans-6419
  prefs: []
  type: TYPE_NORMAL
  zh: 与数组一样，你可以使用 var 来创建一个可变字典，或者使用 let 来创建一个不可变字典。
- en: 'In Swift, all of the keys of a dictionary must be the same type, and all of
    the values of a dictionary must also be the same type, but the key type doesn’t
    have to match the value type. For example, if you wanted to store a collection
    of fractions, you could use doubles for the keys and strings for the values:'
  id: totrans-6420
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Swift 中，字典的所有键必须是相同类型，字典的所有值也必须是相同类型，但键的类型不必与值的类型相匹配。例如，如果你想存储一个分数的集合，你可以使用双精度浮点数作为键，字符串作为值：
- en: '![](Image00142.jpg)'
  id: totrans-6421
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00142.jpg)'
- en: In this dictionary, all of the keys must be doubles, and all of the values must
    be strings. Again, you’ll see that the order of the numbers in the results pane
    can be quite different from the order in which you wrote the fractions in your
    dictionary. This is fine because you don’t need to know the order to access anything.
    You can find any item that you need by its key. Let’s see how!
  id: totrans-6422
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个字典中，所有的键必须是双精度浮点数，而所有的值必须是字符串。同样，你会发现结果窗格中的数字顺序可能与在字典中编写分数时的顺序完全不同。这没关系，因为你不需要知道顺序就能访问任何内容。你可以通过键找到你需要的任何项。让我们来看看如何做！
- en: '**ACCESSING VALUES IN A DICTIONARY**'
  id: totrans-6423
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**访问字典中的值**'
- en: 'Looking up a value in a dictionary is similar to how you access a value in
    an array except that you use a key inside the square brackets instead of an index,
    like this: usStates["TX"] .'
  id: totrans-6424
  prefs: []
  type: TYPE_NORMAL
  zh: 在字典中查找值类似于在数组中访问值，不同之处在于你在方括号内使用的是键，而不是索引，就像这样：usStates["TX"]。
- en: There is a big difference, however, in how Swift returns the values from a dictionary.
    When you access a value at an index of an array, you are simply given the value.
    When you access a value with a key in a dictionary, you are given an optional.
  id: totrans-6425
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，Swift 从字典中返回值的方式与数组有所不同。当你访问数组中某个索引的值时，你只是得到该值。而在字典中通过键访问值时，你会得到一个可选项。
- en: In [Chapter 5](text00015.html#ch05) , you learned that optionals might contain
    a value or might be nil . The reason Swift returns optionals when you’re looking
    up items in a dictionary is that the key you used might not exist in the dictionary,
    in which case there’s no value to access. Trying to access a value that doesn’t
    exist would give you a big fat error! To avoid that problem, Swift returns optionals.
    That means you need to unwrap any value you get out of a dictionary before you
    can do anything with it.
  id: totrans-6426
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第5章](text00015.html#ch05)中，你学到可选项可能包含一个值，也可能是 nil。Swift 在你查找字典中的项时返回可选项的原因是你使用的键可能在字典中不存在，这种情况下没有值可以访问。尝试访问不存在的值会导致一个大错误！为了避免这个问题，Swift
    返回可选项。这意味着在你使用字典中的任何值之前，你需要先解包它。
- en: 'To unwrap an optional, first you check whether it exists using an if-let statement,
    just like we did in [Chapter 5](text00015.html#ch05) . The following code shows
    you how to get a value out of a dictionary:'
  id: totrans-6427
  prefs: []
  type: TYPE_NORMAL
  zh: 要解包一个可选项，首先使用 if-let 语句检查它是否存在，就像我们在[第5章](text00015.html#ch05)中做的那样。以下代码展示了如何从字典中获取值：
- en: '![Image](Image00143.jpg)'
  id: totrans-6428
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00143.jpg)'
- en: To retrieve "Texas" from the dictionary, we use if let to set a constant loneStarState
    to usStates["TX"] ➊ . Because we have this state in our dictionary, the line I
    have Texas in my dictionary. is printed. Next we try to access a state that is
    not in our dictionary by using the key usStates["FL"] ➋ . Thankfully, because
    we used an if-let statement, the program won’t crash when the computer can’t find
    this state. Instead, I don't have that state in my dictionary. is printed.
  id: totrans-6429
  prefs: []
  type: TYPE_NORMAL
  zh: 要从字典中获取 "Texas"，我们使用 if-let 将常量 loneStarState 设置为 usStates["TX"] ➊。因为我们的字典中有这个州，所以打印出“我有
    Texas 在我的字典中”。接下来，我们尝试通过使用键 usStates["FL"] ➋ 访问一个不在字典中的州。幸运的是，因为我们使用了 if-let 语句，当计算机找不到这个州时，程序不会崩溃。相反，打印出“我在字典中没有这个州”。
- en: '**ADDING ITEMS TO A DICTIONARY**'
  id: totrans-6430
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**向字典添加项目**'
- en: 'To add an item to a dictionary, first write the name of your dictionary and
    assign the new item to the key you want it to have in the dictionary. Let’s add
    "Minnesota" to our usStates dictionary:'
  id: totrans-6431
  prefs: []
  type: TYPE_NORMAL
  zh: 要向字典添加项目，首先写下字典的名称，并将新项分配给你希望它在字典中拥有的键。让我们将 "Minnesota" 添加到我们的 usStates 字典中：
- en: '![](Image00144.jpg)'
  id: totrans-6432
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00144.jpg)'
- en: 'Now when you look at usStates , you’ll see that it’s updated to ["MN": "Minnesota",
    "WA": "Washington", "MA": "Massachusetts", "TX": "Texas"] . Remember, because
    you don’t have to rely on indices, your new dictionary item might appear anywhere
    in the dictionary.'
  id: totrans-6433
  prefs: []
  type: TYPE_NORMAL
  zh: '现在，当你查看 usStates 时，你会看到它已更新为 ["MN": "Minnesota", "WA": "Washington", "MA":
    "Massachusetts", "TX": "Texas"]。记住，因为你不必依赖索引，你的新字典项可能会出现在字典中的任何位置。'
- en: '**REMOVING ITEMS FROM A DICTIONARY**'
  id: totrans-6434
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**从字典中移除项目**'
- en: Removing an item from a dictionary is quite simple; you do so by setting the
    value to nil . Because the values in dictionaries are returned as optionals, you
    don’t have to worry about nil causing any problems in your dictionary.
  id: totrans-6435
  prefs: []
  type: TYPE_NORMAL
  zh: 从字典中移除一个项目非常简单；你只需要将值设置为 nil。因为字典中的值是以可选项的形式返回的，所以你不必担心 nil 会导致字典中的任何问题。
- en: '![](Image00145.jpg)'
  id: totrans-6436
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00145.jpg)'
- en: 'You can see that after you remove the value at the key "MA" , usStates is updated
    to ["MN": "Minnesota", "WA": "Washington", "TX": "Texas"] . Remember that nil
    is special and means that there’s no value at all. That’s why you don’t see "MA":
    nil in our dictionary.'
  id: totrans-6437
  prefs: []
  type: TYPE_NORMAL
  zh: '你可以看到，在移除键"MA"的值后，usStates 更新为 ["MN": "Minnesota", "WA": "Washington", "TX":
    "Texas"]。记住，nil 是特殊的，表示根本没有值。因此，你在我们的字典中看不到 "MA": nil。'
- en: '**REPLACING ITEMS IN A DICTIONARY**'
  id: totrans-6438
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**替换字典中的项目**'
- en: 'Replacing an item in a dictionary is also easy. It works the same was as replacing
    an item in an array. You just set the item that you want to replace to something
    else. Say you create a dictionary of fruit colors:'
  id: totrans-6439
  prefs: []
  type: TYPE_NORMAL
  zh: 替换字典中的项目也很容易。它的工作方式与替换数组中的项目相同。你只需将要替换的项目设置为其他值。例如，你创建了一个水果颜色的字典：
- en: '![](Image00146.jpg)'
  id: totrans-6440
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00146.jpg)'
- en: At first we had the value "apple" for "red" , but then we decided that "raspberry"
    is a better fruit to use since sometimes apples are green or yellow. To replace
    "apple" with "raspberry" , we set colorFruits["red"] to its new value ➊ .
  id: totrans-6441
  prefs: []
  type: TYPE_NORMAL
  zh: 一开始我们将“红色”对应的值设为“苹果”，但后来我们决定“覆盆子”是一个更合适的水果，因为有时苹果是绿色或黄色的。为了用“覆盆子”替换“苹果”，我们将
    colorFruits["red"] 设置为它的新值 ➊。
- en: You may remember that this is the same way we entered a new value into a dictionary.
    If the key already exists in the dictionary, then the value for that key is replaced.
    If the key doesn’t already exist, then the new key/value pair will be added to
    the dictionary.
  id: totrans-6442
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能还记得这是我们向字典中插入新值的方式。如果键已经存在于字典中，那么该键的值将被替换。如果该键不存在，那么新的键值对将被添加到字典中。
- en: '![Image](Image00147.jpg)'
  id: totrans-6443
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00147.jpg)'
- en: '**USING DICTIONARY PROPERTIES**'
  id: totrans-6444
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**使用字典属性**'
- en: 'Like an array, a dictionary also has an isEmpty property and a count property.
    For example, the following code shows how you can use the isEmpty property to
    check if a dictionary is empty, and if it isn’t empty, the count property checks
    how many items you have. Imagine you have a basket of fruit for sale. You can
    use these properties to help you keep track of everything:'
  id: totrans-6445
  prefs: []
  type: TYPE_NORMAL
  zh: 像数组一样，字典也有 isEmpty 属性和 count 属性。例如，以下代码展示了如何使用 isEmpty 属性检查字典是否为空，如果不为空，则使用
    count 属性检查字典中有多少项。假设你有一个出售的水果篮子。你可以使用这些属性来帮助你跟踪一切：
- en: '![Image](Image00148.jpg)'
  id: totrans-6446
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00148.jpg)'
- en: 'A dictionary also has two special properties: keys , which contains all of
    the dictionary’s keys, and values , which contains all of its values. We’ll use
    these two properties when we loop through the dictionary.'
  id: totrans-6447
  prefs: []
  type: TYPE_NORMAL
  zh: 字典还有两个特殊属性：keys，包含字典的所有键，以及 values，包含字典的所有值。我们在遍历字典时将使用这两个属性。
- en: Let’s write some code that loops through our fruit baskets and prints the price
    of each fruit.
  id: totrans-6448
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们编写一些代码，循环遍历我们的水果篮子并打印每种水果的价格。
- en: '**LOOPING OVER A DICTIONARY**'
  id: totrans-6449
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**遍历字典**'
- en: 'You can loop through a dictionary using a for-in loop. Because each item has
    a key and a value, you can do this in two different ways. This is how to loop
    through a dictionary using its keys:'
  id: totrans-6450
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用 for-in 循环遍历字典。因为每个项目都有一个键和值，你可以通过两种不同的方式来完成此操作。以下是如何使用键来遍历字典：
- en: '![Image](Image00149.jpg)'
  id: totrans-6451
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00149.jpg)'
- en: Here we use the dictionary’s keys property ➊ to loop through fruitBasket and
    print its contents. We start by writing the keyword for , followed by a constant
    name fruit for the dictionary key, the keyword in , the dictionary name, a period,
    and keys .
  id: totrans-6452
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们使用字典的 keys 属性 ➊ 来遍历 fruitBasket 并打印其内容。我们首先写出关键字 for，然后是一个常量名称 fruit 用于字典键，接着是关键字
    in，字典名称，句点和 keys。
- en: Inside the braces of our for-in loop, we have access to both the key, which
    we call fruit ➋ , and the value at that key when we force-unwrap its contents
    with fruitBasket[fruit]! ➌ . That value will be the fruit’s price.
  id: totrans-6453
  prefs: []
  type: TYPE_NORMAL
  zh: 在 for-in 循环的大括号内部，我们可以访问键（我们称之为 fruit ➋），以及当我们通过强制解包其内容 fruitBasket[fruit]!
    ➌ 时该键对应的值。这个值将是水果的价格。
- en: In this case, it’s safe to force-unwrap the value using an exclamation point
    because we know that the fruit key we’re using is definitely inside the dictionary.
  id: totrans-6454
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，使用感叹号强制解包该值是安全的，因为我们知道我们使用的 fruit 键肯定存在于字典中。
- en: Any code we put inside the for-in loop will run once for every key in our dictionary.
    So you should see the print statement display three times.
  id: totrans-6455
  prefs: []
  type: TYPE_NORMAL
  zh: 我们放入 for-in 循环中的任何代码都会对字典中的每个键执行一次。所以你应该看到打印语句执行三次。
- en: 'We can also loop through the dictionary using its values property:'
  id: totrans-6456
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以使用字典的 values 属性来遍历字典：
- en: '![Image](Image00150.jpg)'
  id: totrans-6457
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00150.jpg)'
- en: We use the same style of for-in loop, but now we use a constant to refer to
    each value, which we call price , in the values property. When looping through
    values, we don’t have access to the keys from inside the loop.
  id: totrans-6458
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用相同风格的 for-in 循环，但现在我们使用一个常量来引用 values 属性中的每个值，我们将其称为 price。当循环遍历 values
    时，我们无法从循环内部访问键。
- en: Another difference to note is that price is not an optional because it’s accessed
    directly as a value in the fruitBasket dictionary. That means we don’t have to
    unwrap it. You should still see the print statement printed three times. [Figure
    6-6](text00016.html#ch06fig6) shows the output of both loops.
  id: totrans-6459
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个需要注意的区别是 price 不是可选类型，因为它是直接作为字典 fruitBasket 中的值来访问的。这意味着我们不需要解包它。你仍然应该看到打印语句执行三次。[图
    6-6](text00016.html#ch06fig6) 展示了两个循环的输出。
- en: '![Image](Image00151.jpg)'
  id: totrans-6460
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00151.jpg)'
- en: '*Figure 6-6: Looping through the keys and values of a dictionary with a for-in
    loop*'
  id: totrans-6461
  prefs: []
  type: TYPE_NORMAL
  zh: '*图6-6：通过for-in循环遍历字典的键和值*'
- en: The order of your results might be slightly different from ours. That’s because
    the items in a dictionary aren’t in a numbered order like they are in an array!
    And because the order is not guaranteed, you might see a different order printed
    if you run the same code again.
  id: totrans-6462
  prefs: []
  type: TYPE_NORMAL
  zh: 你的结果顺序可能和我们的稍有不同。那是因为字典中的项目不像数组中的项目那样按顺序排列！由于顺序不保证，如果你重新运行相同的代码，你可能会看到不同的顺序输出。
- en: '**WHAT YOU LEARNED**'
  id: totrans-6463
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**你学到的内容**'
- en: In this chapter, you learned how to store collections of items in an array and
    in a dictionary. To store items in an ordered list, you would use an array and
    look up each item by its index. If you wanted to store items by key instead, you
    would use a dictionary.
  id: totrans-6464
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一章中，你学会了如何在数组和字典中存储项目的集合。要存储有序列表中的项目，你会使用数组，并通过索引查找每个项目。如果你想通过键来存储项目，那么你会使用字典。
- en: Knowing about arrays and dictionaries and how to use them is a powerful building
    block for almost any programming language. Next we will learn about functions,
    another very powerful tool. Functions are blocks of code that you create and name
    to perform a specific job. After you have written a function, you can use its
    name to call it from almost anywhere in your program.
  id: totrans-6465
  prefs: []
  type: TYPE_NORMAL
  zh: 了解数组和字典以及如何使用它们是几乎所有编程语言中的一个强大构建块。接下来，我们将学习函数，另一个非常强大的工具。函数是你创建并命名的代码块，用于执行特定的任务。写完一个函数后，你可以通过它的名称从程序中的几乎任何地方调用它。
- en: '![](Image00126.jpg)'
  id: totrans-6466
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00126.jpg)'
- en: Neat! Note that the removeLast() method returns the removed item, so you can
    store it in a new constant or variable if you want.
  id: totrans-6467
  prefs: []
  type: TYPE_NORMAL
  zh: 很棒！请注意，removeLast()方法会返回被移除的项目，因此你可以将它存储在一个新的常量或变量中，如果你需要的话。
- en: 'You can also remove an item from a specific index by using the remove(at:)
    method. Let’s say that your mom doesn’t want you buying any candy and takes that
    off the list:'
  id: totrans-6468
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以通过使用remove(at:)方法从特定的索引移除一个项目。假设你的妈妈不希望你买糖果并把它从清单上拿掉：
- en: '![Image](Image00127.jpg)![](Image00128.jpg)'
  id: totrans-6469
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00127.jpg)![](Image00128.jpg)'
- en: Just like when we added an item to the middle of our array and all the items
    scooted over to make room, if you remove an item from the middle of an array,
    the rest of the items will scoot back to fill in that empty space. The "apples"
    item that was at index 3 is now at index 2, where "candy" was.
  id: totrans-6470
  prefs: []
  type: TYPE_NORMAL
  zh: 就像我们在数组中间添加一个项目时，所有的项目都会挪动位置以腾出空间一样，如果你从数组的中间移除一个项目，其余的项目也会移回来填补这个空位。原本位于索引3的"苹果"项目现在位于索引2的位置，这里原本是"糖果"。
- en: 'You can also remove all items from an array with removeAll() . Try entering
    this into your playground:'
  id: totrans-6471
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以使用removeAll()从数组中删除所有项目。试试在你的游乐场中输入这个：
- en: '![](Image00129.jpg)'
  id: totrans-6472
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00129.jpg)'
- en: 'Note that trying to remove an item at an index that doesn’t exist will give
    you an error:'
  id: totrans-6473
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，尝试移除一个不存在的索引处的项目会导致错误：
- en: '![](Image00130.jpg)'
  id: totrans-6474
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00130.jpg)'
- en: Our array doesn’t have this many items (in fact, now it’s empty!), so this throws
    an error. We’ll also get an error if we use removeLast() on our empty array, because
    there’s nothing in it—there’s no last index at all! However, removeAll() is always
    safe to use, even on an empty array.
  id: totrans-6475
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的数组没有这么多项目（事实上，现在它是空的！），所以这会抛出一个错误。如果我们在空数组上使用removeLast()，也会出现错误，因为它里面没有任何内容——根本没有最后一个索引！然而，removeAll()在任何情况下都是安全的，即使是空数组。
- en: '**REPLACING ITEMS IN AN ARRAY**'
  id: totrans-6476
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**替换数组中的项目**'
- en: 'To replace an item in an array, you set the index of the array to the new value,
    as shown here:'
  id: totrans-6477
  prefs: []
  type: TYPE_NORMAL
  zh: 要替换数组中的项目，你只需将数组的索引设置为新值，如下所示：
- en: '![](Image00131.jpg)'
  id: totrans-6478
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00131.jpg)'
- en: At ➊ , we replaced the item at index 2 (the third item) with "Unicorn" because
    magical animals count as favorite animals, too! At ➋ , we replaced the item at
    index 0 (the first item) with "Bearded dragon" . No, that’s not a real dragon—it’s
    just a lizard!
  id: totrans-6479
  prefs: []
  type: TYPE_NORMAL
  zh: 在 ➊ 处，我们将索引2（第三个项目）处的项目替换为"独角兽"，因为魔法动物也算作最喜欢的动物！在 ➋ 处，我们将索引0（第一个项目）处的项目替换为"胡须龙"。不，那可不是一条真正的龙——它只是一种蜥蜴！
- en: Like any time you’re working with array index numbers, you have to be sure an
    item exists in the array at that index before you change its value, or you will
    get an Index out of range error.
  id: totrans-6480
  prefs: []
  type: TYPE_NORMAL
  zh: 就像你在处理数组索引时一样，在更改某个索引处的值之前，必须确保该索引处存在项目，否则你会遇到"索引超出范围"的错误。
- en: '[Figure 6-3](text00016.html#ch06fig3) shows the error that occurs if you try
    to add "Standard poodle" using favoriteAnimals[3] = "Standard poodle" . To add
    an item to the end of an array, you should use the append(_:) method or += , as
    we covered in “[Adding Items to an Array](text00016.html#ch06lev2sec5) ” on [page
    70](text00016.html#page_70) .'
  id: totrans-6481
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 6-3](text00016.html#ch06fig3) 显示了如果你尝试使用 favoriteAnimals[3] = "Standard
    poodle" 添加 "标准贵宾犬" 时发生的错误。要将一个项目添加到数组的末尾，你应该使用 append(_:) 方法或 += ，正如我们在 “[向数组添加项目](text00016.html#ch06lev2sec5)”
    中讲解的那样，[第 70 页](text00016.html#page_70)。'
- en: '![Image](Image00132.jpg)'
  id: totrans-6482
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Image00132.jpg)'
- en: '*Figure 6-3: Don’t try to replace a value at an index beyond the existing array.*'
  id: totrans-6483
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 6-3：不要尝试替换超出现有数组索引的值。*'
- en: Now you know how to change arrays however you might need to. You can add items,
    take items away, or replace items. Next, we’ll look at how to use the properties
    of arrays to find out even more information about them.
  id: totrans-6484
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你知道如何根据需要更改数组。你可以添加项目、删除项目或替换项目。接下来，我们将探讨如何使用数组的属性来获取更多关于它们的信息。
- en: '![Image](Image00133.jpg)'
  id: totrans-6485
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Image00133.jpg)'
- en: '**USING ARRAY PROPERTIES**'
  id: totrans-6486
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**使用数组属性**'
- en: In addition to methods like append(_:) and removeLast() , arrays also have *properties*
    . An array’s properties are variables or constants that contain some information
    about the array. Two really helpful properties that you might use are the Boolean
    property isEmpty and the integer property count .
  id: totrans-6487
  prefs: []
  type: TYPE_NORMAL
  zh: 除了 append(_:) 和 removeLast() 等方法外，数组还有 *属性*。数组的属性是包含有关数组的一些信息的变量或常量。你可能会用到的两个非常有用的属性是布尔类型的
    isEmpty 属性和整数类型的 count 属性。
- en: The isEmpty property is true or false depending on whether the array is empty,
    and the count property will tell you how many items are in that array.
  id: totrans-6488
  prefs: []
  type: TYPE_NORMAL
  zh: isEmpty 属性根据数组是否为空返回 true 或 false，而 count 属性会告诉你数组中有多少项。
- en: 'Check out how these two properties are used in the following if-else statement:'
  id: totrans-6489
  prefs: []
  type: TYPE_NORMAL
  zh: 查看以下 if-else 语句中如何使用这两个属性：
- en: '![Image](Image00134.jpg)'
  id: totrans-6490
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Image00134.jpg)'
- en: 'This if-else statement checks whether the array mySiblings is empty ➊ . If
    it is, then "I don''t have any siblings." is printed. But if there is something
    in the array, then the number of siblings that we have is printed: "I have 3 siblings."
    ➋ .'
  id: totrans-6491
  prefs: []
  type: TYPE_NORMAL
  zh: 这个 if-else 语句检查数组 mySiblings 是否为空 ➊。如果为空，则打印 "我没有兄弟姐妹"。但如果数组中有内容，则打印我们有多少个兄弟姐妹："我有
    3 个兄弟姐妹。" ➋。
- en: '**LOOPING OVER AN ARRAY**'
  id: totrans-6492
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**循环遍历数组**'
- en: 'Sometimes when you’re working with arrays you might want to do something to
    every item in the array. You can use a for-in loop to do that! The following code
    will print every topping in a pizzaToppings array on a separate line:'
  id: totrans-6493
  prefs: []
  type: TYPE_NORMAL
  zh: 有时在处理数组时，你可能想对数组中的每个项目执行某个操作。你可以使用 for-in 循环来实现！以下代码将在单独的行中打印出 pizzaToppings
    数组中的每个配料：
- en: '![Image](Image00135.jpg)'
  id: totrans-6494
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Image00135.jpg)'
- en: To write a for-in loop for the pizzaToppings array, we used the keyword for
    , followed by the constant topping , then the keyword in , and finally the name
    of our array, pizzaToppings . Then we put the statements that we want to run for
    each topping inside the braces of the for-in loop. The constant topping ➊ temporarily
    represents each pizza topping in the array as we loop through it. We could have
    chosen any name for this constant, but it’s a good idea to pick something that
    makes sense. You can see the output of this for-in loop in [Figure 6-4](text00016.html#ch06fig4)
    .
  id: totrans-6495
  prefs: []
  type: TYPE_NORMAL
  zh: 要为 pizzaToppings 数组编写 for-in 循环，我们使用关键字 for ，后跟常量 topping ，然后是关键字 in ，最后是我们的数组名称
    pizzaToppings 。接着，我们将要对每个 topping 执行的语句放在 for-in 循环的大括号内。常量 topping ➊ 在我们循环时临时代表数组中的每个比萨配料。我们可以为这个常量选择任何名称，但最好选择一个有意义的名字。你可以在
    [图 6-4](text00016.html#ch06fig4) 中看到这个 for-in 循环的输出。
- en: '![Image](Image00136.jpg)'
  id: totrans-6496
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Image00136.jpg)'
- en: '*Figure 6-4: Output of the example for-in loop*'
  id: totrans-6497
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 6-4：示例 for-in 循环的输出*'
- en: '![Image](Image00137.jpg)'
  id: totrans-6498
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Image00137.jpg)'
- en: 'Using for-in loops is great for printing every value in an array. If you’re
    working with numbers, you can even use them to perform math operations on each
    item, which makes for some speedy calculations! The following code takes an array
    of numbers and calculates the square for each (the square of a number is that
    number multiplied by itself):'
  id: totrans-6499
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 for-in 循环非常适合打印数组中的每个值。如果你处理的是数字，还可以使用它们对每个项目进行数学运算，这使得计算速度非常快！以下代码获取一个数字数组，并计算每个数字的平方（数字的平方是该数字与它自己相乘）：
- en: '![Image](Image00138.jpg)'
  id: totrans-6500
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Image00138.jpg)'
- en: '[Figure 6-5](text00016.html#ch06fig5) shows the results.'
  id: totrans-6501
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 6-5](text00016.html#ch06fig5) 显示了结果。'
- en: '![Image](Image00139.jpg)'
  id: totrans-6502
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Image00139.jpg)'
- en: '*Figure 6-5: Printing the squares for each number in the myNumbers array*'
  id: totrans-6503
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 6-5：打印 myNumbers 数组中每个数字的平方*'
- en: '**DICTIONARIES ARE KEY!**'
  id: totrans-6504
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**字典是关键！**'
- en: A *dictionary* is also a collection of values, but instead of an ordered index,
    each value has its own *key* . Because there’s no index, the values are not stored
    in any particular order. To access values in a dictionary, you look them up by
    their key.
  id: totrans-6505
  prefs: []
  type: TYPE_NORMAL
  zh: '*字典* 也是一个值的集合，但与数组不同的是，它没有有序的索引，而是每个值都有自己的*键*。由于没有索引，值并不按特定顺序存储。要访问字典中的值，你可以通过其键来查找。'
- en: A key must be unique. You can’t have the same key more than once in the same
    dictionary. If there were two identical keys and you asked the computer to give
    you the value for one of them, the computer wouldn’t know which one to choose!
  id: totrans-6506
  prefs: []
  type: TYPE_NORMAL
  zh: 键必须是唯一的。你不能在同一个字典中重复使用相同的键。如果有两个相同的键，而你要求计算机返回其中一个的值，计算机将不知道选择哪个！
- en: Let’s take a look at how to make a dictionary and write keys that will help
    you find all the information you need.
  id: totrans-6507
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看如何创建一个字典，并编写键来帮助你找到所需的所有信息。
- en: '![Image](Image00140.jpg)'
  id: totrans-6508
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00140.jpg)'
- en: '**INITIALIZING A DICTIONARY**'
  id: totrans-6509
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**初始化字典**'
- en: 'To create and initialize a dictionary, first write var and the name of your
    dictionary. Then write the keys and corresponding values inside a pair of square
    brackets, similar to an array. Let’s create a dictionary to store the names of
    a few US states. The key for each state will be its two-letter abbreviation:'
  id: totrans-6510
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建并初始化一个字典，首先写 var 和字典的名称。然后在一对方括号内写入键和值，类似于数组的写法。让我们创建一个字典来存储一些美国州的名称。每个州的键将是它的两字母缩写：
- en: '![](Image00141.jpg)'
  id: totrans-6511
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00141.jpg)'
- en: As you can see, there’s a colon between each key and its value, and the key/value
    pairs are separated by commas.
  id: totrans-6512
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，每个键和其值之间有一个冒号，键/值对之间由逗号分隔。
- en: Dictionaries are different from arrays in that they are *unordered* . Because
    of that, it’s likely that the order of the states that you see in your results
    pane ➋ is different from the order in which you entered your states ➊ . It might
    even be different than the order that’s printed in this book!
  id: totrans-6513
  prefs: []
  type: TYPE_NORMAL
  zh: 字典与数组不同，因为它们是*无序的*。因此，你在结果面板 ➋ 中看到的状态顺序，可能与输入状态的顺序 ➊ 不同，甚至可能与本书中打印的顺序不同！
- en: As with arrays, you can use var to make a mutable dictionary or use let to make
    an immutable dictionary.
  id: totrans-6514
  prefs: []
  type: TYPE_NORMAL
  zh: 与数组一样，你可以使用 var 来创建可变字典，或者使用 let 来创建不可变字典。
- en: 'In Swift, all of the keys of a dictionary must be the same type, and all of
    the values of a dictionary must also be the same type, but the key type doesn’t
    have to match the value type. For example, if you wanted to store a collection
    of fractions, you could use doubles for the keys and strings for the values:'
  id: totrans-6515
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Swift 中，字典的所有键必须是相同类型的，字典的所有值也必须是相同类型的，但键的类型不需要与值的类型匹配。例如，如果你想存储一个分数集合，你可以使用
    double 类型作为键，使用 string 类型作为值：
- en: '![](Image00142.jpg)'
  id: totrans-6516
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00142.jpg)'
- en: In this dictionary, all of the keys must be doubles, and all of the values must
    be strings. Again, you’ll see that the order of the numbers in the results pane
    can be quite different from the order in which you wrote the fractions in your
    dictionary. This is fine because you don’t need to know the order to access anything.
    You can find any item that you need by its key. Let’s see how!
  id: totrans-6517
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个字典中，所有的键必须是 double 类型，所有的值必须是 string 类型。同样，你会看到结果面板中数字的顺序可能与在字典中写入分数的顺序差异很大。这没关系，因为你不需要知道顺序就能访问任何东西。你可以通过键找到你需要的任何项。我们来看看怎么做！
- en: '**ACCESSING VALUES IN A DICTIONARY**'
  id: totrans-6518
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**访问字典中的值**'
- en: 'Looking up a value in a dictionary is similar to how you access a value in
    an array except that you use a key inside the square brackets instead of an index,
    like this: usStates["TX"] .'
  id: totrans-6519
  prefs: []
  type: TYPE_NORMAL
  zh: 在字典中查找一个值类似于在数组中访问值，不同之处在于你在方括号中使用的是键而不是索引，像这样：usStates["TX"]。
- en: There is a big difference, however, in how Swift returns the values from a dictionary.
    When you access a value at an index of an array, you are simply given the value.
    When you access a value with a key in a dictionary, you are given an optional.
  id: totrans-6520
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，Swift 在从字典返回值时有一个很大的不同。当你访问数组中的一个值时，你只会得到那个值。但当你使用字典的键来访问值时，你将得到一个可选值。
- en: In [Chapter 5](text00015.html#ch05) , you learned that optionals might contain
    a value or might be nil . The reason Swift returns optionals when you’re looking
    up items in a dictionary is that the key you used might not exist in the dictionary,
    in which case there’s no value to access. Trying to access a value that doesn’t
    exist would give you a big fat error! To avoid that problem, Swift returns optionals.
    That means you need to unwrap any value you get out of a dictionary before you
    can do anything with it.
  id: totrans-6521
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第5章](text00015.html#ch05)中，你学习了可选项可能包含值，也可能是nil。Swift在你查找字典中的项目时返回可选项的原因是，你使用的键可能在字典中不存在，这种情况下就没有值可访问。尝试访问一个不存在的值会给你带来一个大大的错误！为避免这个问题，Swift返回可选项。这意味着你需要解包从字典中获取的任何值，然后才能对其进行处理。
- en: 'To unwrap an optional, first you check whether it exists using an if-let statement,
    just like we did in [Chapter 5](text00015.html#ch05) . The following code shows
    you how to get a value out of a dictionary:'
  id: totrans-6522
  prefs: []
  type: TYPE_NORMAL
  zh: 要解包可选项，首先你要检查它是否存在，就像我们在[第5章](text00015.html#ch05)中做的那样。以下代码向你展示了如何从字典中获取值：
- en: '![Image](Image00143.jpg)'
  id: totrans-6523
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00143.jpg)'
- en: To retrieve "Texas" from the dictionary, we use if let to set a constant loneStarState
    to usStates["TX"] ➊ . Because we have this state in our dictionary, the line I
    have Texas in my dictionary. is printed. Next we try to access a state that is
    not in our dictionary by using the key usStates["FL"] ➋ . Thankfully, because
    we used an if-let statement, the program won’t crash when the computer can’t find
    this state. Instead, I don't have that state in my dictionary. is printed.
  id: totrans-6524
  prefs: []
  type: TYPE_NORMAL
  zh: 要从字典中检索“Texas”，我们使用if let将常量loneStarState设置为usStates["TX"] ➊。因为字典中有这个州，所以打印出“I
    have Texas in my dictionary”。接下来，我们尝试通过使用键usStates["FL"] ➋来访问一个不在字典中的州。幸运的是，因为我们使用了if-let语句，当计算机找不到该州时，程序不会崩溃。相反，打印出“I
    don't have that state in my dictionary”。
- en: '**ADDING ITEMS TO A DICTIONARY**'
  id: totrans-6525
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**向字典中添加项目**'
- en: 'To add an item to a dictionary, first write the name of your dictionary and
    assign the new item to the key you want it to have in the dictionary. Let’s add
    "Minnesota" to our usStates dictionary:'
  id: totrans-6526
  prefs: []
  type: TYPE_NORMAL
  zh: 要向字典中添加项目，首先写出字典的名称，并将新项目分配给你希望它在字典中拥有的键。让我们将“Minnesota”添加到我们的usStates字典中：
- en: '![](Image00144.jpg)'
  id: totrans-6527
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00144.jpg)'
- en: 'Now when you look at usStates , you’ll see that it’s updated to ["MN": "Minnesota",
    "WA": "Washington", "MA": "Massachusetts", "TX": "Texas"] . Remember, because
    you don’t have to rely on indices, your new dictionary item might appear anywhere
    in the dictionary.'
  id: totrans-6528
  prefs: []
  type: TYPE_NORMAL
  zh: '现在，当你查看usStates时，你会看到它已更新为["MN": "Minnesota", "WA": "Washington", "MA": "Massachusetts",
    "TX": "Texas"]。记住，因为你不必依赖索引，所以新的字典项可能会出现在字典中的任何位置。'
- en: '**REMOVING ITEMS FROM A DICTIONARY**'
  id: totrans-6529
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**从字典中移除项目**'
- en: Removing an item from a dictionary is quite simple; you do so by setting the
    value to nil . Because the values in dictionaries are returned as optionals, you
    don’t have to worry about nil causing any problems in your dictionary.
  id: totrans-6530
  prefs: []
  type: TYPE_NORMAL
  zh: 从字典中移除一个项目非常简单；你只需将其值设置为nil。由于字典中的值是作为可选项返回的，因此你不必担心nil会在字典中引发任何问题。
- en: '![](Image00145.jpg)'
  id: totrans-6531
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00145.jpg)'
- en: 'You can see that after you remove the value at the key "MA" , usStates is updated
    to ["MN": "Minnesota", "WA": "Washington", "TX": "Texas"] . Remember that nil
    is special and means that there’s no value at all. That’s why you don’t see "MA":
    nil in our dictionary.'
  id: totrans-6532
  prefs: []
  type: TYPE_NORMAL
  zh: '你可以看到，在你移除“MA”键的值之后，usStates被更新为["MN": "Minnesota", "WA": "Washington", "TX":
    "Texas"]。记住，nil是特殊的，意味着根本没有值。这就是为什么你没有看到"MA": nil出现在我们的字典中。'
- en: '**REPLACING ITEMS IN A DICTIONARY**'
  id: totrans-6533
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**替换字典中的项目**'
- en: 'Replacing an item in a dictionary is also easy. It works the same was as replacing
    an item in an array. You just set the item that you want to replace to something
    else. Say you create a dictionary of fruit colors:'
  id: totrans-6534
  prefs: []
  type: TYPE_NORMAL
  zh: 替换字典中的项目也很简单。它的工作方式与替换数组中的项目相同。你只需要将你想要替换的项目设置为其他内容。假设你创建了一个水果颜色的字典：
- en: '![](Image00146.jpg)'
  id: totrans-6535
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00146.jpg)'
- en: At first we had the value "apple" for "red" , but then we decided that "raspberry"
    is a better fruit to use since sometimes apples are green or yellow. To replace
    "apple" with "raspberry" , we set colorFruits["red"] to its new value ➊ .
  id: totrans-6536
  prefs: []
  type: TYPE_NORMAL
  zh: 起初我们将“红色”对应的值设为“apple”，但后来我们决定用“raspberry”更合适，因为有时候苹果是绿色或黄色的。为了将“apple”替换为“raspberry”，我们将colorFruits["red"]设置为它的新值
    ➊。
- en: You may remember that this is the same way we entered a new value into a dictionary.
    If the key already exists in the dictionary, then the value for that key is replaced.
    If the key doesn’t already exist, then the new key/value pair will be added to
    the dictionary.
  id: totrans-6537
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能还记得，这是我们将新值添加到字典中的方式。如果键已经存在于字典中，那么该键的值将被替换。如果键不存在，则新键/值对将被添加到字典中。
- en: '![Image](Image00147.jpg)'
  id: totrans-6538
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00147.jpg)'
- en: '**USING DICTIONARY PROPERTIES**'
  id: totrans-6539
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**使用字典属性**'
- en: 'Like an array, a dictionary also has an isEmpty property and a count property.
    For example, the following code shows how you can use the isEmpty property to
    check if a dictionary is empty, and if it isn’t empty, the count property checks
    how many items you have. Imagine you have a basket of fruit for sale. You can
    use these properties to help you keep track of everything:'
  id: totrans-6540
  prefs: []
  type: TYPE_NORMAL
  zh: 像数组一样，字典也有isEmpty属性和count属性。例如，下面的代码展示了如何使用isEmpty属性检查字典是否为空，如果不为空，则使用count属性检查字典中有多少项。想象你有一个待售的水果篮子。你可以使用这些属性来帮助你跟踪所有内容：
- en: '![Image](Image00148.jpg)'
  id: totrans-6541
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00148.jpg)'
- en: 'A dictionary also has two special properties: keys , which contains all of
    the dictionary’s keys, and values , which contains all of its values. We’ll use
    these two properties when we loop through the dictionary.'
  id: totrans-6542
  prefs: []
  type: TYPE_NORMAL
  zh: 字典还有两个特殊的属性：keys，它包含字典的所有键；values，它包含字典的所有值。我们将在遍历字典时使用这两个属性。
- en: Let’s write some code that loops through our fruit baskets and prints the price
    of each fruit.
  id: totrans-6543
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们写一些代码，遍历我们的水果篮子并打印每个水果的价格。
- en: '**LOOPING OVER A DICTIONARY**'
  id: totrans-6544
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**遍历字典**'
- en: 'You can loop through a dictionary using a for-in loop. Because each item has
    a key and a value, you can do this in two different ways. This is how to loop
    through a dictionary using its keys:'
  id: totrans-6545
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用for-in循环遍历字典。因为每个项目都有一个键和一个值，所以你可以用两种不同的方式来实现。下面是通过字典的键遍历字典的方法：
- en: '![Image](Image00149.jpg)'
  id: totrans-6546
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00149.jpg)'
- en: Here we use the dictionary’s keys property ➊ to loop through fruitBasket and
    print its contents. We start by writing the keyword for , followed by a constant
    name fruit for the dictionary key, the keyword in , the dictionary name, a period,
    and keys .
  id: totrans-6547
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们使用字典的keys属性 ➊ 来遍历fruitBasket并打印其内容。我们首先写下关键字for，后面跟着一个常量名fruit，表示字典的键，接着是关键字in，字典名，一个点，最后是keys。
- en: Inside the braces of our for-in loop, we have access to both the key, which
    we call fruit ➋ , and the value at that key when we force-unwrap its contents
    with fruitBasket[fruit]! ➌ . That value will be the fruit’s price.
  id: totrans-6548
  prefs: []
  type: TYPE_NORMAL
  zh: 在for-in循环的大括号内，我们可以访问键（我们称之为fruit ➋），以及通过强制解包其内容（使用fruitBasket[fruit]! ➌）时该键的值。该值将是水果的价格。
- en: In this case, it’s safe to force-unwrap the value using an exclamation point
    because we know that the fruit key we’re using is definitely inside the dictionary.
  id: totrans-6549
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，使用感叹号强制解包值是安全的，因为我们知道所使用的水果键肯定存在于字典中。
- en: Any code we put inside the for-in loop will run once for every key in our dictionary.
    So you should see the print statement display three times.
  id: totrans-6550
  prefs: []
  type: TYPE_NORMAL
  zh: 我们放入for-in循环中的任何代码都会针对字典中的每个键执行一次。因此，你应该看到打印语句打印三次。
- en: 'We can also loop through the dictionary using its values property:'
  id: totrans-6551
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以通过字典的values属性遍历字典：
- en: '![Image](Image00150.jpg)'
  id: totrans-6552
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00150.jpg)'
- en: We use the same style of for-in loop, but now we use a constant to refer to
    each value, which we call price , in the values property. When looping through
    values, we don’t have access to the keys from inside the loop.
  id: totrans-6553
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用相同类型的for-in循环，但这次我们使用一个常量来引用values属性中的每个值，我们称之为price。在遍历values时，循环内部无法访问键。
- en: Another difference to note is that price is not an optional because it’s accessed
    directly as a value in the fruitBasket dictionary. That means we don’t have to
    unwrap it. You should still see the print statement printed three times. [Figure
    6-6](text00016.html#ch06fig6) shows the output of both loops.
  id: totrans-6554
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个需要注意的区别是，price不是可选类型，因为它是直接作为fruitBasket字典中的值访问的。这意味着我们不需要解包它。你仍然应该看到打印语句打印三次。[图6-6](text00016.html#ch06fig6)显示了两个循环的输出。
- en: '![Image](Image00151.jpg)'
  id: totrans-6555
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00151.jpg)'
- en: '*Figure 6-6: Looping through the keys and values of a dictionary with a for-in
    loop*'
  id: totrans-6556
  prefs: []
  type: TYPE_NORMAL
  zh: '*图6-6：使用for-in循环遍历字典的键和值*'
- en: The order of your results might be slightly different from ours. That’s because
    the items in a dictionary aren’t in a numbered order like they are in an array!
    And because the order is not guaranteed, you might see a different order printed
    if you run the same code again.
  id: totrans-6557
  prefs: []
  type: TYPE_NORMAL
  zh: 你的结果顺序可能与我们的略有不同。这是因为字典中的项目不像数组中的项目那样按编号顺序排列！由于顺序没有保证，如果你再次运行相同的代码，你可能会看到不同的顺序。
- en: '**WHAT YOU LEARNED**'
  id: totrans-6558
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**你学到了什么**'
- en: In this chapter, you learned how to store collections of items in an array and
    in a dictionary. To store items in an ordered list, you would use an array and
    look up each item by its index. If you wanted to store items by key instead, you
    would use a dictionary.
  id: totrans-6559
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一章中，你学习了如何将项目存储在数组和字典中。要将项目存储在有序列表中，你会使用数组，并通过索引查找每个项目。如果你想通过键来存储项目，那么你将使用字典。
- en: Knowing about arrays and dictionaries and how to use them is a powerful building
    block for almost any programming language. Next we will learn about functions,
    another very powerful tool. Functions are blocks of code that you create and name
    to perform a specific job. After you have written a function, you can use its
    name to call it from almost anywhere in your program.
  id: totrans-6560
  prefs: []
  type: TYPE_NORMAL
  zh: 了解数组和字典及其使用方法，是几乎任何编程语言中强大的构建块。接下来，我们将学习函数，另一个非常强大的工具。函数是你创建并命名的一段代码，用来执行特定的任务。编写完函数后，你可以通过它的名字在程序中的几乎任何地方调用它。
- en: Neat! Note that the removeLast() method returns the removed item, so you can
    store it in a new constant or variable if you want.
  id: totrans-6561
  prefs: []
  type: TYPE_NORMAL
  zh: 很棒！请注意，removeLast()方法会返回被移除的项目，所以如果你需要的话，可以将它存储到一个新的常量或变量中。
- en: 'You can also remove an item from a specific index by using the remove(at:)
    method. Let’s say that your mom doesn’t want you buying any candy and takes that
    off the list:'
  id: totrans-6562
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以使用remove(at:)方法从特定索引移除项目。假设你的妈妈不希望你买任何糖果，并将其从列表中删除：
- en: '![Image](Image00127.jpg)![](Image00128.jpg)'
  id: totrans-6563
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00127.jpg)![](Image00128.jpg)'
- en: Just like when we added an item to the middle of our array and all the items
    scooted over to make room, if you remove an item from the middle of an array,
    the rest of the items will scoot back to fill in that empty space. The "apples"
    item that was at index 3 is now at index 2, where "candy" was.
  id: totrans-6564
  prefs: []
  type: TYPE_NORMAL
  zh: 就像我们向数组中间添加一个项目时，所有的项目都会向后挪动以腾出空间一样，如果你从数组的中间移除一个项目，其余的项目也会向前挪动，以填补那个空位。原本位于索引3的"apples"现在位于索引2的位置，即原来"candy"所在的位置。
- en: 'You can also remove all items from an array with removeAll() . Try entering
    this into your playground:'
  id: totrans-6565
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以使用removeAll()方法从数组中移除所有项目。试着在你的游乐场中输入以下内容：
- en: '![](Image00129.jpg)'
  id: totrans-6566
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00129.jpg)'
- en: 'Note that trying to remove an item at an index that doesn’t exist will give
    you an error:'
  id: totrans-6567
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，尝试删除一个不存在的索引位置的项目会抛出错误：
- en: '![](Image00130.jpg)'
  id: totrans-6568
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00130.jpg)'
- en: Our array doesn’t have this many items (in fact, now it’s empty!), so this throws
    an error. We’ll also get an error if we use removeLast() on our empty array, because
    there’s nothing in it—there’s no last index at all! However, removeAll() is always
    safe to use, even on an empty array.
  id: totrans-6569
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的数组没有这么多项目（实际上，现在它是空的！），所以这会抛出一个错误。如果我们在空数组上使用removeLast()，也会出错，因为里面没有任何东西——根本没有最后一个索引！然而，removeAll()始终可以安全使用，即使是在空数组上。
- en: '**REPLACING ITEMS IN AN ARRAY**'
  id: totrans-6570
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**替换数组中的项目**'
- en: 'To replace an item in an array, you set the index of the array to the new value,
    as shown here:'
  id: totrans-6571
  prefs: []
  type: TYPE_NORMAL
  zh: 要替换数组中的项目，你只需将数组的索引设置为新值，如下所示：
- en: '![](Image00131.jpg)'
  id: totrans-6572
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00131.jpg)'
- en: At ➊ , we replaced the item at index 2 (the third item) with "Unicorn" because
    magical animals count as favorite animals, too! At ➋ , we replaced the item at
    index 0 (the first item) with "Bearded dragon" . No, that’s not a real dragon—it’s
    just a lizard!
  id: totrans-6573
  prefs: []
  type: TYPE_NORMAL
  zh: 在➊处，我们用"Unicorn"替换了索引2（第三个项目）处的项目，因为神奇动物也算是最爱的动物！在➋处，我们用"Bearded dragon"替换了索引0（第一个项目）处的项目。不，这不是一条真正的龙——它只是一只蜥蜴！
- en: Like any time you’re working with array index numbers, you have to be sure an
    item exists in the array at that index before you change its value, or you will
    get an Index out of range error.
  id: totrans-6574
  prefs: []
  type: TYPE_NORMAL
  zh: 就像在处理数组索引时一样，你必须确保在修改某个索引位置的值之前，数组中该位置确实存在项目，否则你会遇到"Index out of range"错误。
- en: '[Figure 6-3](text00016.html#ch06fig3) shows the error that occurs if you try
    to add "Standard poodle" using favoriteAnimals[3] = "Standard poodle" . To add
    an item to the end of an array, you should use the append(_:) method or += , as
    we covered in “[Adding Items to an Array](text00016.html#ch06lev2sec5) ” on [page
    70](text00016.html#page_70) .'
  id: totrans-6575
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 6-3](text00016.html#ch06fig3) 显示了如果你尝试通过 favoriteAnimals[3] = "Standard
    poodle" 添加 "标准贵宾犬" 时发生的错误。要向数组末尾添加项，你应该使用 append(_:) 方法或 +=，就像我们在 “[向数组添加项](text00016.html#ch06lev2sec5)”
    中讲解的那样，见 [第 70 页](text00016.html#page_70)。'
- en: '![Image](Image00132.jpg)'
  id: totrans-6576
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Image00132.jpg)'
- en: '*Figure 6-3: Don’t try to replace a value at an index beyond the existing array.*'
  id: totrans-6577
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 6-3：不要尝试替换超出现有数组索引的值。*'
- en: Now you know how to change arrays however you might need to. You can add items,
    take items away, or replace items. Next, we’ll look at how to use the properties
    of arrays to find out even more information about them.
  id: totrans-6578
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你知道如何根据需要更改数组了。你可以添加项、删除项或替换项。接下来，我们将看看如何使用数组的属性来获取更多关于它们的信息。
- en: '![Image](Image00133.jpg)'
  id: totrans-6579
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Image00133.jpg)'
- en: '**USING ARRAY PROPERTIES**'
  id: totrans-6580
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**使用数组属性**'
- en: In addition to methods like append(_:) and removeLast() , arrays also have *properties*
    . An array’s properties are variables or constants that contain some information
    about the array. Two really helpful properties that you might use are the Boolean
    property isEmpty and the integer property count .
  id: totrans-6581
  prefs: []
  type: TYPE_NORMAL
  zh: 除了像 append(_:) 和 removeLast() 这样的函数方法外，数组还有 *属性*。数组的属性是包含数组信息的变量或常量。你可能会使用的两个非常有用的属性是布尔属性
    isEmpty 和整数属性 count。
- en: The isEmpty property is true or false depending on whether the array is empty,
    and the count property will tell you how many items are in that array.
  id: totrans-6582
  prefs: []
  type: TYPE_NORMAL
  zh: isEmpty 属性根据数组是否为空返回 true 或 false，而 count 属性会告诉你该数组中有多少项。
- en: 'Check out how these two properties are used in the following if-else statement:'
  id: totrans-6583
  prefs: []
  type: TYPE_NORMAL
  zh: 查看以下 if-else 语句中这两个属性的使用方式：
- en: '![Image](Image00134.jpg)'
  id: totrans-6584
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Image00134.jpg)'
- en: 'This if-else statement checks whether the array mySiblings is empty ➊ . If
    it is, then "I don''t have any siblings." is printed. But if there is something
    in the array, then the number of siblings that we have is printed: "I have 3 siblings."
    ➋ .'
  id: totrans-6585
  prefs: []
  type: TYPE_NORMAL
  zh: 这个 if-else 语句检查数组 mySiblings 是否为空 ➊。如果为空，则打印 "我没有兄弟姐妹"。但如果数组中有内容，则打印我们有几个兄弟姐妹：“我有
    3 个兄弟姐妹。” ➋。
- en: '**LOOPING OVER AN ARRAY**'
  id: totrans-6586
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**遍历数组**'
- en: 'Sometimes when you’re working with arrays you might want to do something to
    every item in the array. You can use a for-in loop to do that! The following code
    will print every topping in a pizzaToppings array on a separate line:'
  id: totrans-6587
  prefs: []
  type: TYPE_NORMAL
  zh: 有时在处理数组时，你可能希望对数组中的每个项执行相同的操作。你可以使用 for-in 循环来做到这一点！以下代码会在单独的行上打印出 pizzaToppings
    数组中的每个配料：
- en: '![Image](Image00135.jpg)'
  id: totrans-6588
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Image00135.jpg)'
- en: To write a for-in loop for the pizzaToppings array, we used the keyword for
    , followed by the constant topping , then the keyword in , and finally the name
    of our array, pizzaToppings . Then we put the statements that we want to run for
    each topping inside the braces of the for-in loop. The constant topping ➊ temporarily
    represents each pizza topping in the array as we loop through it. We could have
    chosen any name for this constant, but it’s a good idea to pick something that
    makes sense. You can see the output of this for-in loop in [Figure 6-4](text00016.html#ch06fig4)
    .
  id: totrans-6589
  prefs: []
  type: TYPE_NORMAL
  zh: 要为 pizzaToppings 数组编写一个 for-in 循环，我们使用关键字 for，接着是常量 topping，然后是关键字 in，最后是数组的名称
    pizzaToppings。然后我们把想要对每个 topping 执行的语句放在 for-in 循环的花括号内。常量 topping ➊ 在我们循环遍历数组时临时代表数组中的每个披萨配料。我们可以为这个常量选择任何名字，但最好选择一个有意义的名字。你可以在
    [图 6-4](text00016.html#ch06fig4) 中看到这个 for-in 循环的输出。
- en: '![Image](Image00136.jpg)'
  id: totrans-6590
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Image00136.jpg)'
- en: '*Figure 6-4: Output of the example for-in loop*'
  id: totrans-6591
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 6-4：示例 for-in 循环的输出*'
- en: '![Image](Image00137.jpg)'
  id: totrans-6592
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Image00137.jpg)'
- en: 'Using for-in loops is great for printing every value in an array. If you’re
    working with numbers, you can even use them to perform math operations on each
    item, which makes for some speedy calculations! The following code takes an array
    of numbers and calculates the square for each (the square of a number is that
    number multiplied by itself):'
  id: totrans-6593
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 for-in 循环非常适合打印数组中的每个值。如果你正在处理数字，你甚至可以用它们对每个项执行数学运算，这样可以加速计算！以下代码取一个数字数组，并计算每个数字的平方（数字的平方是该数字与其本身相乘）：
- en: '![Image](Image00138.jpg)'
  id: totrans-6594
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Image00138.jpg)'
- en: '[Figure 6-5](text00016.html#ch06fig5) shows the results.'
  id: totrans-6595
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 6-5](text00016.html#ch06fig5) 显示了结果。'
- en: '![Image](Image00139.jpg)'
  id: totrans-6596
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Image00139.jpg)'
- en: '*Figure 6-5: Printing the squares for each number in the myNumbers array*'
  id: totrans-6597
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 6-5：打印 myNumbers 数组中每个数字的平方*'
- en: '**DICTIONARIES ARE KEY!**'
  id: totrans-6598
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**字典至关重要！**'
- en: A *dictionary* is also a collection of values, but instead of an ordered index,
    each value has its own *key* . Because there’s no index, the values are not stored
    in any particular order. To access values in a dictionary, you look them up by
    their key.
  id: totrans-6599
  prefs: []
  type: TYPE_NORMAL
  zh: 一个*字典*也是一个值的集合，但与数组不同的是，每个值都有自己的*键*。因为没有索引，值不是按特定顺序存储的。要访问字典中的值，您需要通过它们的键来查找。
- en: A key must be unique. You can’t have the same key more than once in the same
    dictionary. If there were two identical keys and you asked the computer to give
    you the value for one of them, the computer wouldn’t know which one to choose!
  id: totrans-6600
  prefs: []
  type: TYPE_NORMAL
  zh: 键必须是唯一的。您不能在同一个字典中有重复的键。如果有两个相同的键并且您请求计算机返回其中一个的值，计算机将无法知道选择哪一个！
- en: Let’s take a look at how to make a dictionary and write keys that will help
    you find all the information you need.
  id: totrans-6601
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如何创建字典并写入键，以帮助您找到所需的所有信息。
- en: '![Image](Image00140.jpg)'
  id: totrans-6602
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00140.jpg)'
- en: '**INITIALIZING A DICTIONARY**'
  id: totrans-6603
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**初始化字典**'
- en: 'To create and initialize a dictionary, first write var and the name of your
    dictionary. Then write the keys and corresponding values inside a pair of square
    brackets, similar to an array. Let’s create a dictionary to store the names of
    a few US states. The key for each state will be its two-letter abbreviation:'
  id: totrans-6604
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建和初始化一个字典，首先写 `var` 和字典的名称。然后在一对方括号内写下键和值，类似于数组。让我们创建一个字典来存储一些美国州的名称。每个州的键将是它的两个字母缩写：
- en: '![](Image00141.jpg)'
  id: totrans-6605
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00141.jpg)'
- en: As you can see, there’s a colon between each key and its value, and the key/value
    pairs are separated by commas.
  id: totrans-6606
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，键和值之间有一个冒号，键/值对通过逗号分隔。
- en: Dictionaries are different from arrays in that they are *unordered* . Because
    of that, it’s likely that the order of the states that you see in your results
    pane ➋ is different from the order in which you entered your states ➊ . It might
    even be different than the order that’s printed in this book!
  id: totrans-6607
  prefs: []
  type: TYPE_NORMAL
  zh: 字典与数组的不同之处在于它们是*无序的*。因此，您在结果窗格➋中看到的州的顺序可能与您输入州的顺序➊不同。它甚至可能与本书中打印的顺序不同！
- en: As with arrays, you can use var to make a mutable dictionary or use let to make
    an immutable dictionary.
  id: totrans-6608
  prefs: []
  type: TYPE_NORMAL
  zh: 与数组一样，您可以使用 `var` 创建一个可变字典，或者使用 `let` 创建一个不可变字典。
- en: 'In Swift, all of the keys of a dictionary must be the same type, and all of
    the values of a dictionary must also be the same type, but the key type doesn’t
    have to match the value type. For example, if you wanted to store a collection
    of fractions, you could use doubles for the keys and strings for the values:'
  id: totrans-6609
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Swift 中，字典的所有键必须是相同的类型，字典的所有值也必须是相同的类型，但键的类型不必与值的类型匹配。例如，如果您想存储一个分数集合，可以使用双精度浮点数作为键，字符串作为值：
- en: '![](Image00142.jpg)'
  id: totrans-6610
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00142.jpg)'
- en: In this dictionary, all of the keys must be doubles, and all of the values must
    be strings. Again, you’ll see that the order of the numbers in the results pane
    can be quite different from the order in which you wrote the fractions in your
    dictionary. This is fine because you don’t need to know the order to access anything.
    You can find any item that you need by its key. Let’s see how!
  id: totrans-6611
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个字典中，所有的键必须是双精度浮点数，所有的值必须是字符串。同样，您会看到结果窗格中的数字顺序可能与您在字典中写入分数的顺序有很大不同。这是正常的，因为您不需要知道顺序就可以访问任何内容。您可以通过键找到您需要的任何项。让我们看看如何做！
- en: '**ACCESSING VALUES IN A DICTIONARY**'
  id: totrans-6612
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**访问字典中的值**'
- en: 'Looking up a value in a dictionary is similar to how you access a value in
    an array except that you use a key inside the square brackets instead of an index,
    like this: usStates["TX"] .'
  id: totrans-6613
  prefs: []
  type: TYPE_NORMAL
  zh: 在字典中查找一个值类似于您如何在数组中访问值，只不过您使用的是方括号内的键，而不是索引，像这样：usStates["TX"]。
- en: There is a big difference, however, in how Swift returns the values from a dictionary.
    When you access a value at an index of an array, you are simply given the value.
    When you access a value with a key in a dictionary, you are given an optional.
  id: totrans-6614
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，Swift 在从字典返回值的方式上有很大的不同。当您在数组中访问一个索引的值时，您会直接得到这个值。当您通过字典中的键访问一个值时，您得到的是一个可选值。
- en: In [Chapter 5](text00015.html#ch05) , you learned that optionals might contain
    a value or might be nil . The reason Swift returns optionals when you’re looking
    up items in a dictionary is that the key you used might not exist in the dictionary,
    in which case there’s no value to access. Trying to access a value that doesn’t
    exist would give you a big fat error! To avoid that problem, Swift returns optionals.
    That means you need to unwrap any value you get out of a dictionary before you
    can do anything with it.
  id: totrans-6615
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第5章](text00015.html#ch05)中，你学到可选项可能包含一个值，也可能是nil。当你在字典中查找项时，Swift返回可选项的原因是你使用的键可能在字典中不存在，这样就没有可以访问的值。尝试访问一个不存在的值会导致一个严重的错误！为了避免这个问题，Swift返回可选项。这意味着你需要在对字典中的任何值进行操作之前，解包该值。
- en: 'To unwrap an optional, first you check whether it exists using an if-let statement,
    just like we did in [Chapter 5](text00015.html#ch05) . The following code shows
    you how to get a value out of a dictionary:'
  id: totrans-6616
  prefs: []
  type: TYPE_NORMAL
  zh: 要解包一个可选值，首先使用if-let语句检查它是否存在，就像我们在[第5章](text00015.html#ch05)中做的那样。以下代码展示了如何从字典中获取一个值：
- en: '![Image](Image00143.jpg)'
  id: totrans-6617
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00143.jpg)'
- en: To retrieve "Texas" from the dictionary, we use if let to set a constant loneStarState
    to usStates["TX"] ➊ . Because we have this state in our dictionary, the line I
    have Texas in my dictionary. is printed. Next we try to access a state that is
    not in our dictionary by using the key usStates["FL"] ➋ . Thankfully, because
    we used an if-let statement, the program won’t crash when the computer can’t find
    this state. Instead, I don't have that state in my dictionary. is printed.
  id: totrans-6618
  prefs: []
  type: TYPE_NORMAL
  zh: 要从字典中获取“Texas”，我们使用if let语句将常量loneStarState设置为usStates["TX"] ➊ 。由于字典中有这个州，打印出“我在字典里有Texas”。
- en: '**ADDING ITEMS TO A DICTIONARY**'
  id: totrans-6619
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**向字典中添加项**'
- en: 'To add an item to a dictionary, first write the name of your dictionary and
    assign the new item to the key you want it to have in the dictionary. Let’s add
    "Minnesota" to our usStates dictionary:'
  id: totrans-6620
  prefs: []
  type: TYPE_NORMAL
  zh: 要向字典中添加项，首先写出字典的名称，并将新项赋值给你希望它在字典中对应的键。让我们把“Minnesota”添加到我们的usStates字典中：
- en: '![](Image00144.jpg)'
  id: totrans-6621
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00144.jpg)'
- en: 'Now when you look at usStates , you’ll see that it’s updated to ["MN": "Minnesota",
    "WA": "Washington", "MA": "Massachusetts", "TX": "Texas"] . Remember, because
    you don’t have to rely on indices, your new dictionary item might appear anywhere
    in the dictionary.'
  id: totrans-6622
  prefs: []
  type: TYPE_NORMAL
  zh: '现在当你查看usStates时，你会看到它已更新为["MN": "Minnesota", "WA": "Washington", "MA": "Massachusetts",
    "TX": "Texas"]。记住，由于你不需要依赖索引，你的新字典项可能出现在字典中的任何位置。'
- en: '**REMOVING ITEMS FROM A DICTIONARY**'
  id: totrans-6623
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**从字典中移除项**'
- en: Removing an item from a dictionary is quite simple; you do so by setting the
    value to nil . Because the values in dictionaries are returned as optionals, you
    don’t have to worry about nil causing any problems in your dictionary.
  id: totrans-6624
  prefs: []
  type: TYPE_NORMAL
  zh: 从字典中移除一项非常简单；你只需将值设置为nil。因为字典中的值是作为可选项返回的，所以你无需担心nil会在字典中造成任何问题。
- en: '![](Image00145.jpg)'
  id: totrans-6625
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00145.jpg)'
- en: 'You can see that after you remove the value at the key "MA" , usStates is updated
    to ["MN": "Minnesota", "WA": "Washington", "TX": "Texas"] . Remember that nil
    is special and means that there’s no value at all. That’s why you don’t see "MA":
    nil in our dictionary.'
  id: totrans-6626
  prefs: []
  type: TYPE_NORMAL
  zh: '你可以看到，在移除键“MA”对应的值后，usStates更新为["MN": "Minnesota", "WA": "Washington", "TX":
    "Texas"]。记住，nil是特殊的，表示根本没有值。这就是为什么在我们的字典中看不到"MA": nil。'
- en: '**REPLACING ITEMS IN A DICTIONARY**'
  id: totrans-6627
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**替换字典中的项**'
- en: 'Replacing an item in a dictionary is also easy. It works the same was as replacing
    an item in an array. You just set the item that you want to replace to something
    else. Say you create a dictionary of fruit colors:'
  id: totrans-6628
  prefs: []
  type: TYPE_NORMAL
  zh: 替换字典中的项也很简单。它和替换数组中的项一样。你只需将你要替换的项设置为其他内容。假设你创建了一个水果颜色的字典：
- en: '![](Image00146.jpg)'
  id: totrans-6629
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00146.jpg)'
- en: At first we had the value "apple" for "red" , but then we decided that "raspberry"
    is a better fruit to use since sometimes apples are green or yellow. To replace
    "apple" with "raspberry" , we set colorFruits["red"] to its new value ➊ .
  id: totrans-6630
  prefs: []
  type: TYPE_NORMAL
  zh: 一开始我们将"red"对应的值设为"apple"，但后来我们认为"raspberry"是更好的水果，因为有时苹果是绿色或黄色的。要将"apple"替换为"raspberry"，我们将colorFruits["red"]设置为新的值
    ➊。
- en: You may remember that this is the same way we entered a new value into a dictionary.
    If the key already exists in the dictionary, then the value for that key is replaced.
    If the key doesn’t already exist, then the new key/value pair will be added to
    the dictionary.
  id: totrans-6631
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能记得这与我们向字典中插入新值的方式相同。如果键已经存在于字典中，则该键的值会被替换。如果键不存在，则新的键/值对将被添加到字典中。
- en: '![Image](Image00147.jpg)'
  id: totrans-6632
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Image00147.jpg)'
- en: '**USING DICTIONARY PROPERTIES**'
  id: totrans-6633
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**使用字典属性**'
- en: 'Like an array, a dictionary also has an isEmpty property and a count property.
    For example, the following code shows how you can use the isEmpty property to
    check if a dictionary is empty, and if it isn’t empty, the count property checks
    how many items you have. Imagine you have a basket of fruit for sale. You can
    use these properties to help you keep track of everything:'
  id: totrans-6634
  prefs: []
  type: TYPE_NORMAL
  zh: 类似于数组，字典也具有 isEmpty 属性和 count 属性。例如，以下代码展示了如何使用 isEmpty 属性检查字典是否为空，如果不为空，则使用
    count 属性检查你有多少项。假设你有一个水果篮子出售。你可以使用这些属性帮助你跟踪所有物品：
- en: '![Image](Image00148.jpg)'
  id: totrans-6635
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Image00148.jpg)'
- en: 'A dictionary also has two special properties: keys , which contains all of
    the dictionary’s keys, and values , which contains all of its values. We’ll use
    these two properties when we loop through the dictionary.'
  id: totrans-6636
  prefs: []
  type: TYPE_NORMAL
  zh: 字典还具有两个特殊属性：keys，包含字典的所有键，以及 values，包含字典的所有值。我们将在遍历字典时使用这两个属性。
- en: Let’s write some code that loops through our fruit baskets and prints the price
    of each fruit.
  id: totrans-6637
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们编写一些代码，遍历我们的水果篮子并打印每个水果的价格。
- en: '**LOOPING OVER A DICTIONARY**'
  id: totrans-6638
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**遍历字典**'
- en: 'You can loop through a dictionary using a for-in loop. Because each item has
    a key and a value, you can do this in two different ways. This is how to loop
    through a dictionary using its keys:'
  id: totrans-6639
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用 for-in 循环遍历字典。因为每个项都有一个键和值，你可以通过两种不同的方式来做到这一点。这是使用字典的键遍历字典的方法：
- en: '![Image](Image00149.jpg)'
  id: totrans-6640
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Image00149.jpg)'
- en: Here we use the dictionary’s keys property ➊ to loop through fruitBasket and
    print its contents. We start by writing the keyword for , followed by a constant
    name fruit for the dictionary key, the keyword in , the dictionary name, a period,
    and keys .
  id: totrans-6641
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们使用字典的 keys 属性 ➊ 来遍历 fruitBasket 并打印其内容。我们从写下关键字 for 开始，后跟一个常量名称 fruit
    作为字典的键，关键字 in，字典名称，句点，以及 keys。
- en: Inside the braces of our for-in loop, we have access to both the key, which
    we call fruit ➋ , and the value at that key when we force-unwrap its contents
    with fruitBasket[fruit]! ➌ . That value will be the fruit’s price.
  id: totrans-6642
  prefs: []
  type: TYPE_NORMAL
  zh: 在 for-in 循环的大括号内，我们可以访问键（我们称之为 fruit ➋）以及该键对应的值，当我们强制解包其内容时，使用 fruitBasket[fruit]!
    ➌。该值将是水果的价格。
- en: In this case, it’s safe to force-unwrap the value using an exclamation point
    because we know that the fruit key we’re using is definitely inside the dictionary.
  id: totrans-6643
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，使用感叹号强制解包值是安全的，因为我们知道正在使用的 fruit 键一定存在于字典中。
- en: Any code we put inside the for-in loop will run once for every key in our dictionary.
    So you should see the print statement display three times.
  id: totrans-6644
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在 for-in 循环中放入的任何代码都会在字典中的每个键上执行一次。所以你应该看到打印语句会显示三次。
- en: 'We can also loop through the dictionary using its values property:'
  id: totrans-6645
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以使用字典的 values 属性遍历字典：
- en: '![Image](Image00150.jpg)'
  id: totrans-6646
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Image00150.jpg)'
- en: We use the same style of for-in loop, but now we use a constant to refer to
    each value, which we call price , in the values property. When looping through
    values, we don’t have access to the keys from inside the loop.
  id: totrans-6647
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用相同风格的 for-in 循环，但现在我们使用常量来引用每个值，称为 price，出现在 values 属性中。在遍历 values 时，我们无法从循环内部访问键。
- en: Another difference to note is that price is not an optional because it’s accessed
    directly as a value in the fruitBasket dictionary. That means we don’t have to
    unwrap it. You should still see the print statement printed three times. [Figure
    6-6](text00016.html#ch06fig6) shows the output of both loops.
  id: totrans-6648
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个需要注意的区别是 price 不是一个可选类型，因为它是直接作为值访问字典中的 fruitBasket 字典。这意味着我们不需要解包它。你仍然会看到打印语句被打印三次。[图
    6-6](text00016.html#ch06fig6) 显示了两次循环的输出。
- en: '![Image](Image00151.jpg)'
  id: totrans-6649
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Image00151.jpg)'
- en: '*Figure 6-6: Looping through the keys and values of a dictionary with a for-in
    loop*'
  id: totrans-6650
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 6-6：使用 for-in 循环遍历字典的键和值*'
- en: The order of your results might be slightly different from ours. That’s because
    the items in a dictionary aren’t in a numbered order like they are in an array!
    And because the order is not guaranteed, you might see a different order printed
    if you run the same code again.
  id: totrans-6651
  prefs: []
  type: TYPE_NORMAL
  zh: 你的结果顺序可能与我们的稍有不同。这是因为字典中的项不像数组那样按编号顺序排列！由于顺序无法保证，如果你再次运行相同的代码，打印出的顺序可能会不同。
- en: '**WHAT YOU LEARNED**'
  id: totrans-6652
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**你学到了什么**'
- en: In this chapter, you learned how to store collections of items in an array and
    in a dictionary. To store items in an ordered list, you would use an array and
    look up each item by its index. If you wanted to store items by key instead, you
    would use a dictionary.
  id: totrans-6653
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你学会了如何将项存储在数组和字典中。为了将项存储在有序列表中，你需要使用数组，并通过索引查找每个项。如果你想按键存储项，则应使用字典。
- en: Knowing about arrays and dictionaries and how to use them is a powerful building
    block for almost any programming language. Next we will learn about functions,
    another very powerful tool. Functions are blocks of code that you create and name
    to perform a specific job. After you have written a function, you can use its
    name to call it from almost anywhere in your program.
  id: totrans-6654
  prefs: []
  type: TYPE_NORMAL
  zh: 了解数组和字典及其使用方法是几乎所有编程语言中的一个强大构建块。接下来我们将学习函数，这是另一个非常强大的工具。函数是你创建并命名的一块代码，用于执行特定任务。编写了一个函数后，你可以通过它的名称在程序的几乎任何地方调用它。
- en: 'You can also remove an item from a specific index by using the remove(at:)
    method. Let’s say that your mom doesn’t want you buying any candy and takes that
    off the list:'
  id: totrans-6655
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以使用remove(at:)方法从特定索引中删除一个项。假设你的妈妈不希望你买糖果，并把它从列表中拿掉：
- en: '![Image](Image00127.jpg)![](Image00128.jpg)'
  id: totrans-6656
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Image00127.jpg)![](Image00128.jpg)'
- en: Just like when we added an item to the middle of our array and all the items
    scooted over to make room, if you remove an item from the middle of an array,
    the rest of the items will scoot back to fill in that empty space. The "apples"
    item that was at index 3 is now at index 2, where "candy" was.
  id: totrans-6657
  prefs: []
  type: TYPE_NORMAL
  zh: 就像我们在数组中间添加项时，所有项都会挪动以腾出空间一样，如果你从数组中间删除一项，其他项将会挪回去填补那个空位。原来在索引3处的“苹果”项现在位于索引2的位置，这里原来是“糖果”。
- en: 'You can also remove all items from an array with removeAll() . Try entering
    this into your playground:'
  id: totrans-6658
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以使用removeAll()删除数组中的所有项。试着将这个输入到你的游乐场中：
- en: '![](Image00129.jpg)'
  id: totrans-6659
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00129.jpg)'
- en: 'Note that trying to remove an item at an index that doesn’t exist will give
    you an error:'
  id: totrans-6660
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，尝试删除一个不存在的索引项会导致错误：
- en: '![](Image00130.jpg)'
  id: totrans-6661
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00130.jpg)'
- en: Our array doesn’t have this many items (in fact, now it’s empty!), so this throws
    an error. We’ll also get an error if we use removeLast() on our empty array, because
    there’s nothing in it—there’s no last index at all! However, removeAll() is always
    safe to use, even on an empty array.
  id: totrans-6662
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的数组没有这么多项（事实上，现在它是空的！），所以这会抛出一个错误。如果我们在空数组上使用removeLast()，也会得到错误，因为数组里什么都没有——根本没有最后一个索引！然而，使用removeAll()是始终安全的，即使在空数组上也能使用。
- en: '**REPLACING ITEMS IN AN ARRAY**'
  id: totrans-6663
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**替换数组中的项**'
- en: 'To replace an item in an array, you set the index of the array to the new value,
    as shown here:'
  id: totrans-6664
  prefs: []
  type: TYPE_NORMAL
  zh: 要替换数组中的项，你可以将数组的索引设置为新值，如下所示：
- en: '![](Image00131.jpg)'
  id: totrans-6665
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00131.jpg)'
- en: At ➊ , we replaced the item at index 2 (the third item) with "Unicorn" because
    magical animals count as favorite animals, too! At ➋ , we replaced the item at
    index 0 (the first item) with "Bearded dragon" . No, that’s not a real dragon—it’s
    just a lizard!
  id: totrans-6666
  prefs: []
  type: TYPE_NORMAL
  zh: 在➊处，我们用“独角兽”替换了索引2（第三个项目）中的项，因为魔法动物也算作是最喜欢的动物！在➋处，我们用“有须龙”替换了索引0（第一个项目）。不，那可不是一条真正的龙——它只是一个蜥蜴！
- en: Like any time you’re working with array index numbers, you have to be sure an
    item exists in the array at that index before you change its value, or you will
    get an Index out of range error.
  id: totrans-6667
  prefs: []
  type: TYPE_NORMAL
  zh: 就像你在操作数组索引时一样，必须确保该索引处存在一个项，否则你将遇到“索引超出范围”的错误。
- en: '[Figure 6-3](text00016.html#ch06fig3) shows the error that occurs if you try
    to add "Standard poodle" using favoriteAnimals[3] = "Standard poodle" . To add
    an item to the end of an array, you should use the append(_:) method or += , as
    we covered in “[Adding Items to an Array](text00016.html#ch06lev2sec5) ” on [page
    70](text00016.html#page_70) .'
  id: totrans-6668
  prefs: []
  type: TYPE_NORMAL
  zh: '[图6-3](text00016.html#ch06fig3)展示了当你尝试使用favoriteAnimals[3] = "标准贵宾犬"添加“标准贵宾犬”时发生的错误。要将项添加到数组末尾，你应该使用append(_:)方法或+=，正如我们在“[向数组添加项](text00016.html#ch06lev2sec5)”中讲解的那样，见[第70页](text00016.html#page_70)。'
- en: '![Image](Image00132.jpg)'
  id: totrans-6669
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Image00132.jpg)'
- en: '*Figure 6-3: Don’t try to replace a value at an index beyond the existing array.*'
  id: totrans-6670
  prefs: []
  type: TYPE_NORMAL
  zh: '*图6-3：不要尝试替换超出现有数组索引的值。*'
- en: Now you know how to change arrays however you might need to. You can add items,
    take items away, or replace items. Next, we’ll look at how to use the properties
    of arrays to find out even more information about them.
  id: totrans-6671
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经知道如何根据需要修改数组了。你可以添加项目、删除项目或替换项目。接下来，我们将看看如何利用数组的属性来获取更多关于它们的信息。
- en: '![Image](Image00133.jpg)'
  id: totrans-6672
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00133.jpg)'
- en: '**USING ARRAY PROPERTIES**'
  id: totrans-6673
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**使用数组属性**'
- en: In addition to methods like append(_:) and removeLast() , arrays also have *properties*
    . An array’s properties are variables or constants that contain some information
    about the array. Two really helpful properties that you might use are the Boolean
    property isEmpty and the integer property count .
  id: totrans-6674
  prefs: []
  type: TYPE_NORMAL
  zh: 除了像append(_:)和removeLast()这样的函数外，数组还具有*属性*。数组的属性是包含一些关于数组的信息的变量或常量。你可能会使用的两个非常有用的属性是布尔属性isEmpty和整数属性count。
- en: The isEmpty property is true or false depending on whether the array is empty,
    and the count property will tell you how many items are in that array.
  id: totrans-6675
  prefs: []
  type: TYPE_NORMAL
  zh: isEmpty属性为true或false，具体取决于数组是否为空，而count属性将告诉你数组中有多少个项目。
- en: 'Check out how these two properties are used in the following if-else statement:'
  id: totrans-6676
  prefs: []
  type: TYPE_NORMAL
  zh: 查看以下if-else语句中这两个属性是如何使用的：
- en: '![Image](Image00134.jpg)'
  id: totrans-6677
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00134.jpg)'
- en: 'This if-else statement checks whether the array mySiblings is empty ➊ . If
    it is, then "I don''t have any siblings." is printed. But if there is something
    in the array, then the number of siblings that we have is printed: "I have 3 siblings."
    ➋ .'
  id: totrans-6678
  prefs: []
  type: TYPE_NORMAL
  zh: 这个if-else语句检查数组mySiblings是否为空 ➊。如果为空，则打印"我没有兄弟姐妹。"。但如果数组中有内容，则打印我们有多少个兄弟姐妹："我有3个兄弟姐妹。"
    ➋。
- en: '**LOOPING OVER AN ARRAY**'
  id: totrans-6679
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**遍历数组**'
- en: 'Sometimes when you’re working with arrays you might want to do something to
    every item in the array. You can use a for-in loop to do that! The following code
    will print every topping in a pizzaToppings array on a separate line:'
  id: totrans-6680
  prefs: []
  type: TYPE_NORMAL
  zh: 有时在使用数组时，你可能希望对数组中的每个项目做一些操作。你可以使用for-in循环来做到这一点！以下代码将会把pizzaToppings数组中的每个配料打印在单独的一行上：
- en: '![Image](Image00135.jpg)'
  id: totrans-6681
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00135.jpg)'
- en: To write a for-in loop for the pizzaToppings array, we used the keyword for
    , followed by the constant topping , then the keyword in , and finally the name
    of our array, pizzaToppings . Then we put the statements that we want to run for
    each topping inside the braces of the for-in loop. The constant topping ➊ temporarily
    represents each pizza topping in the array as we loop through it. We could have
    chosen any name for this constant, but it’s a good idea to pick something that
    makes sense. You can see the output of this for-in loop in [Figure 6-4](text00016.html#ch06fig4)
    .
  id: totrans-6682
  prefs: []
  type: TYPE_NORMAL
  zh: 要为pizzaToppings数组编写一个for-in循环，我们使用了关键字for，后面跟着常量topping，然后是关键字in，最后是我们数组的名称pizzaToppings。然后，我们将希望对每个topping执行的语句放在for-in循环的大括号内。常量topping
    ➊临时代表我们在循环中遍历的每个披萨配料。我们可以为这个常量选择任何名字，但最好选择一个有意义的名字。你可以在[图6-4](text00016.html#ch06fig4)中看到这个for-in循环的输出。
- en: '![Image](Image00136.jpg)'
  id: totrans-6683
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00136.jpg)'
- en: '*Figure 6-4: Output of the example for-in loop*'
  id: totrans-6684
  prefs: []
  type: TYPE_NORMAL
  zh: '*图6-4：示例for-in循环的输出*'
- en: '![Image](Image00137.jpg)'
  id: totrans-6685
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00137.jpg)'
- en: 'Using for-in loops is great for printing every value in an array. If you’re
    working with numbers, you can even use them to perform math operations on each
    item, which makes for some speedy calculations! The following code takes an array
    of numbers and calculates the square for each (the square of a number is that
    number multiplied by itself):'
  id: totrans-6686
  prefs: []
  type: TYPE_NORMAL
  zh: 使用for-in循环非常适合打印数组中的每个值。如果你正在处理数字，你甚至可以使用它们对每个项目执行数学运算，这样可以快速进行计算！以下代码接受一个数字数组，并计算每个数字的平方（一个数字的平方是该数字乘以它本身）：
- en: '![Image](Image00138.jpg)'
  id: totrans-6687
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00138.jpg)'
- en: '[Figure 6-5](text00016.html#ch06fig5) shows the results.'
  id: totrans-6688
  prefs: []
  type: TYPE_NORMAL
  zh: '[图6-5](text00016.html#ch06fig5)显示了结果。'
- en: '![Image](Image00139.jpg)'
  id: totrans-6689
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00139.jpg)'
- en: '*Figure 6-5: Printing the squares for each number in the myNumbers array*'
  id: totrans-6690
  prefs: []
  type: TYPE_NORMAL
  zh: '*图6-5：打印myNumbers数组中每个数字的平方*'
- en: '**DICTIONARIES ARE KEY!**'
  id: totrans-6691
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**字典非常重要！**'
- en: A *dictionary* is also a collection of values, but instead of an ordered index,
    each value has its own *key* . Because there’s no index, the values are not stored
    in any particular order. To access values in a dictionary, you look them up by
    their key.
  id: totrans-6692
  prefs: []
  type: TYPE_NORMAL
  zh: '*字典*也是一个值的集合，但与有序索引不同，每个值都有自己的*键*。由于没有索引，值不会按特定顺序存储。要访问字典中的值，你需要通过它们的键进行查找。'
- en: A key must be unique. You can’t have the same key more than once in the same
    dictionary. If there were two identical keys and you asked the computer to give
    you the value for one of them, the computer wouldn’t know which one to choose!
  id: totrans-6693
  prefs: []
  type: TYPE_NORMAL
  zh: 一个键必须是唯一的。在同一个字典中，不能有相同的键。如果有两个相同的键，当你请求计算机返回其中一个的值时，计算机将不知道选择哪个！
- en: Let’s take a look at how to make a dictionary and write keys that will help
    you find all the information you need.
  id: totrans-6694
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看一下如何创建一个字典，并编写键来帮助你找到所有需要的信息。
- en: '![Image](Image00140.jpg)'
  id: totrans-6695
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00140.jpg)'
- en: '**INITIALIZING A DICTIONARY**'
  id: totrans-6696
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**初始化字典**'
- en: 'To create and initialize a dictionary, first write var and the name of your
    dictionary. Then write the keys and corresponding values inside a pair of square
    brackets, similar to an array. Let’s create a dictionary to store the names of
    a few US states. The key for each state will be its two-letter abbreviation:'
  id: totrans-6697
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建并初始化一个字典，首先写下var和字典的名称。然后将键和相应的值写在一对方括号内，类似于数组。让我们创建一个字典来存储一些美国州的名称。每个州的键将是它的两字母缩写：
- en: '![](Image00141.jpg)'
  id: totrans-6698
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00141.jpg)'
- en: As you can see, there’s a colon between each key and its value, and the key/value
    pairs are separated by commas.
  id: totrans-6699
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，每个键和值之间都有一个冒号，键值对之间用逗号分隔。
- en: Dictionaries are different from arrays in that they are *unordered* . Because
    of that, it’s likely that the order of the states that you see in your results
    pane ➋ is different from the order in which you entered your states ➊ . It might
    even be different than the order that’s printed in this book!
  id: totrans-6700
  prefs: []
  type: TYPE_NORMAL
  zh: 字典与数组的不同之处在于它们是*无序的*。因此，你在结果窗格 ➋ 中看到的状态顺序可能与输入状态的顺序 ➊ 不同。甚至可能与本书中打印的顺序不同！
- en: As with arrays, you can use var to make a mutable dictionary or use let to make
    an immutable dictionary.
  id: totrans-6701
  prefs: []
  type: TYPE_NORMAL
  zh: 和数组一样，你可以使用var来创建一个可变字典，或者使用let来创建一个不可变字典。
- en: 'In Swift, all of the keys of a dictionary must be the same type, and all of
    the values of a dictionary must also be the same type, but the key type doesn’t
    have to match the value type. For example, if you wanted to store a collection
    of fractions, you could use doubles for the keys and strings for the values:'
  id: totrans-6702
  prefs: []
  type: TYPE_NORMAL
  zh: 在Swift中，字典的所有键必须是相同类型，字典的所有值也必须是相同类型，但键的类型不必与值的类型匹配。例如，如果你想存储一组分数，可以使用双精度数作为键，字符串作为值：
- en: '![](Image00142.jpg)'
  id: totrans-6703
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00142.jpg)'
- en: In this dictionary, all of the keys must be doubles, and all of the values must
    be strings. Again, you’ll see that the order of the numbers in the results pane
    can be quite different from the order in which you wrote the fractions in your
    dictionary. This is fine because you don’t need to know the order to access anything.
    You can find any item that you need by its key. Let’s see how!
  id: totrans-6704
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个字典中，所有的键必须是双精度类型，所有的值必须是字符串类型。同样，你会发现结果窗格中数字的顺序与在字典中写下分数的顺序可能会有所不同。这没关系，因为你不需要知道顺序就能访问任何内容。你可以通过键来找到任何需要的项。让我们来看一下如何操作！
- en: '**ACCESSING VALUES IN A DICTIONARY**'
  id: totrans-6705
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**访问字典中的值**'
- en: 'Looking up a value in a dictionary is similar to how you access a value in
    an array except that you use a key inside the square brackets instead of an index,
    like this: usStates["TX"] .'
  id: totrans-6706
  prefs: []
  type: TYPE_NORMAL
  zh: 查找字典中的值与访问数组中的值类似，只是你在方括号内使用的是键而不是索引，像这样：usStates["TX"]。
- en: There is a big difference, however, in how Swift returns the values from a dictionary.
    When you access a value at an index of an array, you are simply given the value.
    When you access a value with a key in a dictionary, you are given an optional.
  id: totrans-6707
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，Swift返回字典值的方式有一个很大的不同。当你访问数组中的索引值时，你只会得到该值。而当你使用键访问字典中的值时，你会得到一个可选值。
- en: In [Chapter 5](text00015.html#ch05) , you learned that optionals might contain
    a value or might be nil . The reason Swift returns optionals when you’re looking
    up items in a dictionary is that the key you used might not exist in the dictionary,
    in which case there’s no value to access. Trying to access a value that doesn’t
    exist would give you a big fat error! To avoid that problem, Swift returns optionals.
    That means you need to unwrap any value you get out of a dictionary before you
    can do anything with it.
  id: totrans-6708
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第5章](text00015.html#ch05)中，你学到了可选值可能包含一个值，也可能是nil。Swift返回可选值的原因是在查找字典中的项时，使用的键可能不存在于字典中，在这种情况下就没有值可以访问。尝试访问不存在的值会导致一个大错误！为了避免这个问题，Swift返回可选值。这意味着你需要解包从字典中获取的任何值，然后才能对其进行处理。
- en: 'To unwrap an optional, first you check whether it exists using an if-let statement,
    just like we did in [Chapter 5](text00015.html#ch05) . The following code shows
    you how to get a value out of a dictionary:'
  id: totrans-6709
  prefs: []
  type: TYPE_NORMAL
  zh: 要解包一个可选值，首先你检查它是否存在，方法是使用 if-let 语句，就像我们在[第 5 章](text00015.html#ch05)中做的那样。以下代码展示了如何从字典中获取一个值：
- en: '![Image](Image00143.jpg)'
  id: totrans-6710
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00143.jpg)'
- en: To retrieve "Texas" from the dictionary, we use if let to set a constant loneStarState
    to usStates["TX"] ➊ . Because we have this state in our dictionary, the line I
    have Texas in my dictionary. is printed. Next we try to access a state that is
    not in our dictionary by using the key usStates["FL"] ➋ . Thankfully, because
    we used an if-let statement, the program won’t crash when the computer can’t find
    this state. Instead, I don't have that state in my dictionary. is printed.
  id: totrans-6711
  prefs: []
  type: TYPE_NORMAL
  zh: 要从字典中获取 "Texas"，我们使用 if let 将常量 loneStarState 设置为 usStates["TX"] ➊。由于我们在字典中有这个州，所以会打印出“我在我的字典中有德克萨斯州”。接下来，我们尝试通过使用键
    usStates["FL"] ➋ 访问一个不在字典中的州。幸运的是，由于我们使用了 if-let 语句，当计算机找不到这个州时，程序不会崩溃。相反，会打印出“我字典中没有这个州”。
- en: '**ADDING ITEMS TO A DICTIONARY**'
  id: totrans-6712
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**向字典添加项目**'
- en: 'To add an item to a dictionary, first write the name of your dictionary and
    assign the new item to the key you want it to have in the dictionary. Let’s add
    "Minnesota" to our usStates dictionary:'
  id: totrans-6713
  prefs: []
  type: TYPE_NORMAL
  zh: 要向字典添加一个项目，首先写下字典的名称，并将新项目赋值给你想要在字典中对应的键。让我们将 "Minnesota" 添加到我们的 usStates 字典中：
- en: '![](Image00144.jpg)'
  id: totrans-6714
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00144.jpg)'
- en: 'Now when you look at usStates , you’ll see that it’s updated to ["MN": "Minnesota",
    "WA": "Washington", "MA": "Massachusetts", "TX": "Texas"] . Remember, because
    you don’t have to rely on indices, your new dictionary item might appear anywhere
    in the dictionary.'
  id: totrans-6715
  prefs: []
  type: TYPE_NORMAL
  zh: '现在，当你查看 usStates 时，你会看到它已更新为 ["MN": "Minnesota", "WA": "Washington", "MA":
    "Massachusetts", "TX": "Texas"]。记住，由于你不必依赖索引，你的新字典项目可能出现在字典中的任何位置。'
- en: '**REMOVING ITEMS FROM A DICTIONARY**'
  id: totrans-6716
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**从字典中移除项目**'
- en: Removing an item from a dictionary is quite simple; you do so by setting the
    value to nil . Because the values in dictionaries are returned as optionals, you
    don’t have to worry about nil causing any problems in your dictionary.
  id: totrans-6717
  prefs: []
  type: TYPE_NORMAL
  zh: 从字典中移除一个项目是相当简单的；你只需要将该值设置为 nil。因为字典中的值是作为可选项返回的，所以你不必担心 nil 会在字典中引起任何问题。
- en: '![](Image00145.jpg)'
  id: totrans-6718
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00145.jpg)'
- en: 'You can see that after you remove the value at the key "MA" , usStates is updated
    to ["MN": "Minnesota", "WA": "Washington", "TX": "Texas"] . Remember that nil
    is special and means that there’s no value at all. That’s why you don’t see "MA":
    nil in our dictionary.'
  id: totrans-6719
  prefs: []
  type: TYPE_NORMAL
  zh: '你可以看到，当你移除键 "MA" 对应的值后，usStates 更新为 ["MN": "Minnesota", "WA": "Washington",
    "TX": "Texas"]。记住，nil 是特殊的，表示没有值。因此，你在字典中看不到 "MA": nil。'
- en: '**REPLACING ITEMS IN A DICTIONARY**'
  id: totrans-6720
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**替换字典中的项目**'
- en: 'Replacing an item in a dictionary is also easy. It works the same was as replacing
    an item in an array. You just set the item that you want to replace to something
    else. Say you create a dictionary of fruit colors:'
  id: totrans-6721
  prefs: []
  type: TYPE_NORMAL
  zh: 替换字典中的项目也很简单。它的工作方式与替换数组中的项目相同。你只需要将你想替换的项目设置为其他值。假设你创建了一个水果颜色的字典：
- en: '![](Image00146.jpg)'
  id: totrans-6722
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00146.jpg)'
- en: At first we had the value "apple" for "red" , but then we decided that "raspberry"
    is a better fruit to use since sometimes apples are green or yellow. To replace
    "apple" with "raspberry" , we set colorFruits["red"] to its new value ➊ .
  id: totrans-6723
  prefs: []
  type: TYPE_NORMAL
  zh: 一开始我们将“红色”对应的值设为“苹果”，但后来我们决定“覆盆子”是一个更好的水果，因为有时苹果是绿色或黄色的。为了将“苹果”替换为“覆盆子”，我们将
    colorFruits["red"] 设置为新的值 ➊。
- en: You may remember that this is the same way we entered a new value into a dictionary.
    If the key already exists in the dictionary, then the value for that key is replaced.
    If the key doesn’t already exist, then the new key/value pair will be added to
    the dictionary.
  id: totrans-6724
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能还记得，这与我们向字典中插入新值的方式是一样的。如果键已经存在于字典中，那么该键的值将被替换。如果键尚不存在，那么新的键/值对将被添加到字典中。
- en: '![Image](Image00147.jpg)'
  id: totrans-6725
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00147.jpg)'
- en: '**USING DICTIONARY PROPERTIES**'
  id: totrans-6726
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**使用字典属性**'
- en: 'Like an array, a dictionary also has an isEmpty property and a count property.
    For example, the following code shows how you can use the isEmpty property to
    check if a dictionary is empty, and if it isn’t empty, the count property checks
    how many items you have. Imagine you have a basket of fruit for sale. You can
    use these properties to help you keep track of everything:'
  id: totrans-6727
  prefs: []
  type: TYPE_NORMAL
  zh: 像数组一样，字典也有 isEmpty 属性和 count 属性。例如，以下代码展示了如何使用 isEmpty 属性检查字典是否为空，如果不为空，count
    属性可以检查你有多少个项目。假设你有一个待售的水果篮子。你可以使用这些属性来帮助你跟踪所有的内容：
- en: '![Image](Image00148.jpg)'
  id: totrans-6728
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00148.jpg)'
- en: 'A dictionary also has two special properties: keys , which contains all of
    the dictionary’s keys, and values , which contains all of its values. We’ll use
    these two properties when we loop through the dictionary.'
  id: totrans-6729
  prefs: []
  type: TYPE_NORMAL
  zh: 字典还有两个特殊属性：keys，包含字典的所有键，以及 values，包含字典的所有值。在循环遍历字典时，我们会使用这两个属性。
- en: Let’s write some code that loops through our fruit baskets and prints the price
    of each fruit.
  id: totrans-6730
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们写一些代码，遍历我们的水果篮并打印每种水果的价格。
- en: '**LOOPING OVER A DICTIONARY**'
  id: totrans-6731
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**遍历字典**'
- en: 'You can loop through a dictionary using a for-in loop. Because each item has
    a key and a value, you can do this in two different ways. This is how to loop
    through a dictionary using its keys:'
  id: totrans-6732
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用 for-in 循环遍历字典。因为每个项目都有一个键和值，你可以通过两种不同的方式来做到这一点。这是如何使用字典的键来遍历字典：
- en: '![Image](Image00149.jpg)'
  id: totrans-6733
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00149.jpg)'
- en: Here we use the dictionary’s keys property ➊ to loop through fruitBasket and
    print its contents. We start by writing the keyword for , followed by a constant
    name fruit for the dictionary key, the keyword in , the dictionary name, a period,
    and keys .
  id: totrans-6734
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们使用字典的 keys 属性 ➊ 来循环遍历 fruitBasket 并打印其内容。我们首先写关键词 for，然后是常量名称 fruit（作为字典键），接着是关键词
    in，字典名称，一个点，和 keys。
- en: Inside the braces of our for-in loop, we have access to both the key, which
    we call fruit ➋ , and the value at that key when we force-unwrap its contents
    with fruitBasket[fruit]! ➌ . That value will be the fruit’s price.
  id: totrans-6735
  prefs: []
  type: TYPE_NORMAL
  zh: 在 for-in 循环的大括号内，我们可以访问键（我们称之为 fruit ➋）和该键的值，当我们通过 fruitBasket[fruit]! 强制解包其内容时
    ➌。这个值将是水果的价格。
- en: In this case, it’s safe to force-unwrap the value using an exclamation point
    because we know that the fruit key we’re using is definitely inside the dictionary.
  id: totrans-6736
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，使用感叹号强制解包值是安全的，因为我们知道我们使用的水果键一定在字典中。
- en: Any code we put inside the for-in loop will run once for every key in our dictionary.
    So you should see the print statement display three times.
  id: totrans-6737
  prefs: []
  type: TYPE_NORMAL
  zh: 我们放在 for-in 循环中的任何代码都会对字典中的每个键执行一次。所以你应该看到打印语句显示三次。
- en: 'We can also loop through the dictionary using its values property:'
  id: totrans-6738
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以使用字典的 values 属性来遍历字典：
- en: '![Image](Image00150.jpg)'
  id: totrans-6739
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00150.jpg)'
- en: We use the same style of for-in loop, but now we use a constant to refer to
    each value, which we call price , in the values property. When looping through
    values, we don’t have access to the keys from inside the loop.
  id: totrans-6740
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用相同风格的 for-in 循环，但现在我们使用一个常量来引用 values 属性中的每个值，我们称之为 price。在循环遍历 values 时，我们无法在循环内访问键。
- en: Another difference to note is that price is not an optional because it’s accessed
    directly as a value in the fruitBasket dictionary. That means we don’t have to
    unwrap it. You should still see the print statement printed three times. [Figure
    6-6](text00016.html#ch06fig6) shows the output of both loops.
  id: totrans-6741
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个需要注意的区别是，price 不是一个可选值，因为它是直接作为字典中值的一部分来访问的。这意味着我们不需要解包它。你应该仍然看到打印语句被打印三次。[图
    6-6](text00016.html#ch06fig6) 显示了两个循环的输出。
- en: '![Image](Image00151.jpg)'
  id: totrans-6742
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00151.jpg)'
- en: '*Figure 6-6: Looping through the keys and values of a dictionary with a for-in
    loop*'
  id: totrans-6743
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 6-6：使用 for-in 循环遍历字典的键和值*'
- en: The order of your results might be slightly different from ours. That’s because
    the items in a dictionary aren’t in a numbered order like they are in an array!
    And because the order is not guaranteed, you might see a different order printed
    if you run the same code again.
  id: totrans-6744
  prefs: []
  type: TYPE_NORMAL
  zh: 你的结果顺序可能与你看到的稍有不同。这是因为字典中的项不像数组那样有编号顺序！由于顺序不保证，如果你再次运行相同的代码，你可能会看到不同的顺序。
- en: '**WHAT YOU LEARNED**'
  id: totrans-6745
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**你学到了什么**'
- en: In this chapter, you learned how to store collections of items in an array and
    in a dictionary. To store items in an ordered list, you would use an array and
    look up each item by its index. If you wanted to store items by key instead, you
    would use a dictionary.
  id: totrans-6746
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你学习了如何在数组和字典中存储项目集合。要在有序列表中存储项目，你将使用数组，并通过索引查找每个项目。如果你想按键存储项目，那么你会使用字典。
- en: Knowing about arrays and dictionaries and how to use them is a powerful building
    block for almost any programming language. Next we will learn about functions,
    another very powerful tool. Functions are blocks of code that you create and name
    to perform a specific job. After you have written a function, you can use its
    name to call it from almost anywhere in your program.
  id: totrans-6747
  prefs: []
  type: TYPE_NORMAL
  zh: 了解数组和字典，以及如何使用它们，是几乎所有编程语言中的一个强大构建块。接下来我们将学习函数，这是另一个非常强大的工具。函数是你创建并命名的代码块，用于执行特定任务。编写完一个函数后，你可以使用它的名字在程序中的几乎任何地方调用它。
- en: '![Image](Image00127.jpg)![](Image00128.jpg)'
  id: totrans-6748
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Image00127.jpg)![](Image00128.jpg)'
- en: Just like when we added an item to the middle of our array and all the items
    scooted over to make room, if you remove an item from the middle of an array,
    the rest of the items will scoot back to fill in that empty space. The "apples"
    item that was at index 3 is now at index 2, where "candy" was.
  id: totrans-6749
  prefs: []
  type: TYPE_NORMAL
  zh: 就像当我们向数组中间添加一个元素时，所有元素都会移动以腾出空间一样，如果你从数组中间移除一个元素，其余的元素将会向回移动以填补那个空白位置。原本在索引3位置的"apples"元素现在在索引2的位置，那里原本是"candy"。
- en: 'You can also remove all items from an array with removeAll() . Try entering
    this into your playground:'
  id: totrans-6750
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以使用removeAll()方法移除数组中的所有元素。试着在你的游乐场中输入以下内容：
- en: '![](Image00129.jpg)'
  id: totrans-6751
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00129.jpg)'
- en: 'Note that trying to remove an item at an index that doesn’t exist will give
    you an error:'
  id: totrans-6752
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，尝试移除一个不存在的索引位置的元素会导致错误：
- en: '![](Image00130.jpg)'
  id: totrans-6753
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00130.jpg)'
- en: Our array doesn’t have this many items (in fact, now it’s empty!), so this throws
    an error. We’ll also get an error if we use removeLast() on our empty array, because
    there’s nothing in it—there’s no last index at all! However, removeAll() is always
    safe to use, even on an empty array.
  id: totrans-6754
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的数组并没有这么多元素（事实上，现在它是空的！），所以这会抛出一个错误。如果我们对空数组使用removeLast()，也会出现错误，因为数组中没有任何元素——根本没有最后一个索引！然而，removeAll()方法是安全的，即使在空数组上使用也不会出错。
- en: '**REPLACING ITEMS IN AN ARRAY**'
  id: totrans-6755
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**替换数组中的元素**'
- en: 'To replace an item in an array, you set the index of the array to the new value,
    as shown here:'
  id: totrans-6756
  prefs: []
  type: TYPE_NORMAL
  zh: 要替换数组中的一个元素，你只需要将数组的索引设置为新值，如下所示：
- en: '![](Image00131.jpg)'
  id: totrans-6757
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00131.jpg)'
- en: At ➊ , we replaced the item at index 2 (the third item) with "Unicorn" because
    magical animals count as favorite animals, too! At ➋ , we replaced the item at
    index 0 (the first item) with "Bearded dragon" . No, that’s not a real dragon—it’s
    just a lizard!
  id: totrans-6758
  prefs: []
  type: TYPE_NORMAL
  zh: 在➊处，我们用"Unicorn"替换了索引2（第三个元素）上的元素，因为魔法动物也是最喜欢的动物！在➋处，我们用"Bearded dragon"替换了索引0（第一个元素）上的元素。不是的，那不是龙——它只是只蜥蜴！
- en: Like any time you’re working with array index numbers, you have to be sure an
    item exists in the array at that index before you change its value, or you will
    get an Index out of range error.
  id: totrans-6759
  prefs: []
  type: TYPE_NORMAL
  zh: 像处理数组索引一样，你必须确保数组中在该索引处存在元素，才可以修改它的值，否则会得到“索引超出范围”的错误。
- en: '[Figure 6-3](text00016.html#ch06fig3) shows the error that occurs if you try
    to add "Standard poodle" using favoriteAnimals[3] = "Standard poodle" . To add
    an item to the end of an array, you should use the append(_:) method or += , as
    we covered in “[Adding Items to an Array](text00016.html#ch06lev2sec5) ” on [page
    70](text00016.html#page_70) .'
  id: totrans-6760
  prefs: []
  type: TYPE_NORMAL
  zh: '[图6-3](text00016.html#ch06fig3)展示了当你尝试使用favoriteAnimals[3] = "Standard poodle"添加"标准贵宾犬"时出现的错误。要将一个元素添加到数组的末尾，你应该使用append(_:)方法或+=，正如我们在“[向数组添加元素](text00016.html#ch06lev2sec5)”中在[第70页](text00016.html#page_70)讨论的那样。'
- en: '![Image](Image00132.jpg)'
  id: totrans-6761
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Image00132.jpg)'
- en: '*Figure 6-3: Don’t try to replace a value at an index beyond the existing array.*'
  id: totrans-6762
  prefs: []
  type: TYPE_NORMAL
  zh: '*图6-3：不要尝试替换超出现有数组范围的索引位置的值。*'
- en: Now you know how to change arrays however you might need to. You can add items,
    take items away, or replace items. Next, we’ll look at how to use the properties
    of arrays to find out even more information about them.
  id: totrans-6763
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你知道如何根据需要修改数组了。你可以添加元素、移除元素，或者替换元素。接下来，我们将看看如何利用数组的属性获取更多关于数组的信息。
- en: '![Image](Image00133.jpg)'
  id: totrans-6764
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Image00133.jpg)'
- en: '**USING ARRAY PROPERTIES**'
  id: totrans-6765
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**使用数组属性**'
- en: In addition to methods like append(_:) and removeLast() , arrays also have *properties*
    . An array’s properties are variables or constants that contain some information
    about the array. Two really helpful properties that you might use are the Boolean
    property isEmpty and the integer property count .
  id: totrans-6766
  prefs: []
  type: TYPE_NORMAL
  zh: 除了append(_:)和removeLast()等方法，数组还具有*属性*。数组的属性是包含关于数组某些信息的变量或常量。有两个非常有用的属性，你可能会用到：布尔类型的isEmpty属性和整数类型的count属性。
- en: The isEmpty property is true or false depending on whether the array is empty,
    and the count property will tell you how many items are in that array.
  id: totrans-6767
  prefs: []
  type: TYPE_NORMAL
  zh: isEmpty 属性的值为 true 或 false，取决于数组是否为空，而 count 属性则会告诉你数组中有多少个项。
- en: 'Check out how these two properties are used in the following if-else statement:'
  id: totrans-6768
  prefs: []
  type: TYPE_NORMAL
  zh: 查看下面的 if-else 语句中这两个属性的使用方法：
- en: '![Image](Image00134.jpg)'
  id: totrans-6769
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00134.jpg)'
- en: 'This if-else statement checks whether the array mySiblings is empty ➊ . If
    it is, then "I don''t have any siblings." is printed. But if there is something
    in the array, then the number of siblings that we have is printed: "I have 3 siblings."
    ➋ .'
  id: totrans-6770
  prefs: []
  type: TYPE_NORMAL
  zh: 这个 if-else 语句检查数组 mySiblings 是否为空 ➊。如果为空，则打印 "我没有兄弟姐妹"。但如果数组中有内容，则打印我们有多少个兄弟姐妹："我有
    3 个兄弟姐妹" ➋。
- en: '**LOOPING OVER AN ARRAY**'
  id: totrans-6771
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**遍历数组**'
- en: 'Sometimes when you’re working with arrays you might want to do something to
    every item in the array. You can use a for-in loop to do that! The following code
    will print every topping in a pizzaToppings array on a separate line:'
  id: totrans-6772
  prefs: []
  type: TYPE_NORMAL
  zh: 有时候，当你在处理数组时，可能想对数组中的每个项做一些事情。你可以使用 for-in 循环来实现！以下代码将在每一行打印出 pizzaToppings
    数组中的每个配料：
- en: '![Image](Image00135.jpg)'
  id: totrans-6773
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00135.jpg)'
- en: To write a for-in loop for the pizzaToppings array, we used the keyword for
    , followed by the constant topping , then the keyword in , and finally the name
    of our array, pizzaToppings . Then we put the statements that we want to run for
    each topping inside the braces of the for-in loop. The constant topping ➊ temporarily
    represents each pizza topping in the array as we loop through it. We could have
    chosen any name for this constant, but it’s a good idea to pick something that
    makes sense. You can see the output of this for-in loop in [Figure 6-4](text00016.html#ch06fig4)
    .
  id: totrans-6774
  prefs: []
  type: TYPE_NORMAL
  zh: 为了为 pizzaToppings 数组编写一个 for-in 循环，我们使用了关键字 for，接着是常量 topping，再是关键字 in，最后是我们数组的名称
    pizzaToppings。然后，我们将想要为每个配料执行的语句放入 for-in 循环的大括号内。常量 topping ➊ 在我们遍历数组时，暂时代表数组中的每个配料。我们本可以选择任何名称，但最好选择一个有意义的名字。你可以在
    [图 6-4](text00016.html#ch06fig4) 中看到这个 for-in 循环的输出。
- en: '![Image](Image00136.jpg)'
  id: totrans-6775
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00136.jpg)'
- en: '*Figure 6-4: Output of the example for-in loop*'
  id: totrans-6776
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 6-4：示例 for-in 循环的输出*'
- en: '![Image](Image00137.jpg)'
  id: totrans-6777
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00137.jpg)'
- en: 'Using for-in loops is great for printing every value in an array. If you’re
    working with numbers, you can even use them to perform math operations on each
    item, which makes for some speedy calculations! The following code takes an array
    of numbers and calculates the square for each (the square of a number is that
    number multiplied by itself):'
  id: totrans-6778
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 for-in 循环非常适合打印数组中的每个值。如果你在处理数字，甚至可以用它们对每个项执行数学运算，这样可以加速计算！以下代码取一个数字数组，并计算每个数字的平方（一个数字的平方是该数字乘以它自己）：
- en: '![Image](Image00138.jpg)'
  id: totrans-6779
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00138.jpg)'
- en: '[Figure 6-5](text00016.html#ch06fig5) shows the results.'
  id: totrans-6780
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 6-5](text00016.html#ch06fig5) 显示了结果。'
- en: '![Image](Image00139.jpg)'
  id: totrans-6781
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00139.jpg)'
- en: '*Figure 6-5: Printing the squares for each number in the myNumbers array*'
  id: totrans-6782
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 6-5：打印 myNumbers 数组中每个数字的平方*'
- en: '**DICTIONARIES ARE KEY!**'
  id: totrans-6783
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**字典是关键！**'
- en: A *dictionary* is also a collection of values, but instead of an ordered index,
    each value has its own *key* . Because there’s no index, the values are not stored
    in any particular order. To access values in a dictionary, you look them up by
    their key.
  id: totrans-6784
  prefs: []
  type: TYPE_NORMAL
  zh: '*字典* 也是一个值的集合，但不同于有序的索引，每个值都有自己的 *键*。因为没有索引，值不会以特定的顺序存储。要访问字典中的值，您可以通过键查找它们。'
- en: A key must be unique. You can’t have the same key more than once in the same
    dictionary. If there were two identical keys and you asked the computer to give
    you the value for one of them, the computer wouldn’t know which one to choose!
  id: totrans-6785
  prefs: []
  type: TYPE_NORMAL
  zh: 键必须是唯一的。你不能在同一个字典中使用相同的键多次。如果有两个相同的键，而你要求计算机给你其中一个的值，计算机就不知道选择哪个了！
- en: Let’s take a look at how to make a dictionary and write keys that will help
    you find all the information you need.
  id: totrans-6786
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看如何创建一个字典，并编写键来帮助你找到所需的所有信息。
- en: '![Image](Image00140.jpg)'
  id: totrans-6787
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00140.jpg)'
- en: '**INITIALIZING A DICTIONARY**'
  id: totrans-6788
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**初始化字典**'
- en: 'To create and initialize a dictionary, first write var and the name of your
    dictionary. Then write the keys and corresponding values inside a pair of square
    brackets, similar to an array. Let’s create a dictionary to store the names of
    a few US states. The key for each state will be its two-letter abbreviation:'
  id: totrans-6789
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建并初始化一个字典，首先写 var 和字典的名称。然后，将键和相应的值写在一对方括号中，类似于数组。让我们创建一个字典来存储一些美国州的名称。每个州的键将是其两字母的缩写：
- en: '![](Image00141.jpg)'
  id: totrans-6790
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00141.jpg)'
- en: As you can see, there’s a colon between each key and its value, and the key/value
    pairs are separated by commas.
  id: totrans-6791
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，每个键和值之间有一个冒号，键/值对通过逗号分隔。
- en: Dictionaries are different from arrays in that they are *unordered* . Because
    of that, it’s likely that the order of the states that you see in your results
    pane ➋ is different from the order in which you entered your states ➊ . It might
    even be different than the order that’s printed in this book!
  id: totrans-6792
  prefs: []
  type: TYPE_NORMAL
  zh: 字典与数组的不同之处在于它们是*无序的*。因此，你在结果窗格中看到的状态顺序 ➋ 可能与你输入状态的顺序 ➊ 不同，甚至可能与本书中打印的顺序不同！
- en: As with arrays, you can use var to make a mutable dictionary or use let to make
    an immutable dictionary.
  id: totrans-6793
  prefs: []
  type: TYPE_NORMAL
  zh: 和数组一样，你可以使用 var 来创建可变字典，或者使用 let 来创建不可变字典。
- en: 'In Swift, all of the keys of a dictionary must be the same type, and all of
    the values of a dictionary must also be the same type, but the key type doesn’t
    have to match the value type. For example, if you wanted to store a collection
    of fractions, you could use doubles for the keys and strings for the values:'
  id: totrans-6794
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Swift 中，字典的所有键必须是相同类型的，字典的所有值也必须是相同类型的，但键的类型不必与值的类型匹配。例如，如果你想存储一组分数，可以使用双精度浮点数作为键，字符串作为值：
- en: '![](Image00142.jpg)'
  id: totrans-6795
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00142.jpg)'
- en: In this dictionary, all of the keys must be doubles, and all of the values must
    be strings. Again, you’ll see that the order of the numbers in the results pane
    can be quite different from the order in which you wrote the fractions in your
    dictionary. This is fine because you don’t need to know the order to access anything.
    You can find any item that you need by its key. Let’s see how!
  id: totrans-6796
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个字典中，所有的键必须是双精度浮点数，所有的值必须是字符串。同样，你会看到在结果窗格中数字的顺序可能与在字典中写入的分数顺序大不相同。这是正常的，因为你无需知道顺序就能访问任何内容。你可以通过键找到任何需要的项目。让我们看看如何做！
- en: '**ACCESSING VALUES IN A DICTIONARY**'
  id: totrans-6797
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**在字典中访问值**'
- en: 'Looking up a value in a dictionary is similar to how you access a value in
    an array except that you use a key inside the square brackets instead of an index,
    like this: usStates["TX"] .'
  id: totrans-6798
  prefs: []
  type: TYPE_NORMAL
  zh: 在字典中查找值类似于你在数组中访问值的方式，只是你使用的是键而不是索引，像这样：usStates["TX"]。
- en: There is a big difference, however, in how Swift returns the values from a dictionary.
    When you access a value at an index of an array, you are simply given the value.
    When you access a value with a key in a dictionary, you are given an optional.
  id: totrans-6799
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，Swift 在从字典返回值的方式上有一个很大的区别。当你在数组中按索引访问一个值时，你会直接得到值。当你在字典中通过键访问一个值时，你得到的是一个可选值。
- en: In [Chapter 5](text00015.html#ch05) , you learned that optionals might contain
    a value or might be nil . The reason Swift returns optionals when you’re looking
    up items in a dictionary is that the key you used might not exist in the dictionary,
    in which case there’s no value to access. Trying to access a value that doesn’t
    exist would give you a big fat error! To avoid that problem, Swift returns optionals.
    That means you need to unwrap any value you get out of a dictionary before you
    can do anything with it.
  id: totrans-6800
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第五章](text00015.html#ch05)中，你学习了可选值可能包含一个值，也可能是 nil。Swift 在查找字典中的项时返回可选值的原因是，你使用的键可能不存在于字典中，在这种情况下，就没有值可供访问。试图访问一个不存在的值会导致一个严重的错误！为避免这个问题，Swift
    返回可选值。这意味着你在使用字典中的任何值之前需要解开它。
- en: 'To unwrap an optional, first you check whether it exists using an if-let statement,
    just like we did in [Chapter 5](text00015.html#ch05) . The following code shows
    you how to get a value out of a dictionary:'
  id: totrans-6801
  prefs: []
  type: TYPE_NORMAL
  zh: 要解开一个可选值，首先你需要检查它是否存在，使用 if-let 语句，就像我们在[第五章](text00015.html#ch05)中所做的那样。以下代码展示了如何从字典中获取一个值：
- en: '![Image](Image00143.jpg)'
  id: totrans-6802
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00143.jpg)'
- en: To retrieve "Texas" from the dictionary, we use if let to set a constant loneStarState
    to usStates["TX"] ➊ . Because we have this state in our dictionary, the line I
    have Texas in my dictionary. is printed. Next we try to access a state that is
    not in our dictionary by using the key usStates["FL"] ➋ . Thankfully, because
    we used an if-let statement, the program won’t crash when the computer can’t find
    this state. Instead, I don't have that state in my dictionary. is printed.
  id: totrans-6803
  prefs: []
  type: TYPE_NORMAL
  zh: 要从字典中检索“德克萨斯”，我们使用 if let 将常量 loneStarState 设置为 usStates["TX"] ➊。因为字典中有这个州，所以打印了“我在字典中有德克萨斯”。接下来，我们尝试通过使用键
    usStates["FL"] ➋ 访问一个不在字典中的州。幸运的是，由于我们使用了 if-let 语句，当计算机无法找到该州时，程序不会崩溃。相反，打印了“我在字典中没有那个州”。
- en: '**ADDING ITEMS TO A DICTIONARY**'
  id: totrans-6804
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**向字典添加项**'
- en: 'To add an item to a dictionary, first write the name of your dictionary and
    assign the new item to the key you want it to have in the dictionary. Let’s add
    "Minnesota" to our usStates dictionary:'
  id: totrans-6805
  prefs: []
  type: TYPE_NORMAL
  zh: 向字典中添加项目时，首先写下字典的名称，并将新项目赋给你想要的键。让我们把 "Minnesota" 添加到 `usStates` 字典中：
- en: '![](Image00144.jpg)'
  id: totrans-6806
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00144.jpg)'
- en: 'Now when you look at usStates , you’ll see that it’s updated to ["MN": "Minnesota",
    "WA": "Washington", "MA": "Massachusetts", "TX": "Texas"] . Remember, because
    you don’t have to rely on indices, your new dictionary item might appear anywhere
    in the dictionary.'
  id: totrans-6807
  prefs: []
  type: TYPE_NORMAL
  zh: '现在，当你查看 `usStates` 时，你会看到它已经更新为 ["MN": "Minnesota", "WA": "Washington", "MA":
    "Massachusetts", "TX": "Texas"]。记住，由于你不需要依赖索引，新的字典项目可能出现在字典的任何位置。'
- en: '**REMOVING ITEMS FROM A DICTIONARY**'
  id: totrans-6808
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**从字典中移除项目**'
- en: Removing an item from a dictionary is quite simple; you do so by setting the
    value to nil . Because the values in dictionaries are returned as optionals, you
    don’t have to worry about nil causing any problems in your dictionary.
  id: totrans-6809
  prefs: []
  type: TYPE_NORMAL
  zh: 从字典中移除项目非常简单；你只需要将值设置为 `nil`。因为字典中的值是可选的，你无需担心 `nil` 会在字典中引发问题。
- en: '![](Image00145.jpg)'
  id: totrans-6810
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00145.jpg)'
- en: 'You can see that after you remove the value at the key "MA" , usStates is updated
    to ["MN": "Minnesota", "WA": "Washington", "TX": "Texas"] . Remember that nil
    is special and means that there’s no value at all. That’s why you don’t see "MA":
    nil in our dictionary.'
  id: totrans-6811
  prefs: []
  type: TYPE_NORMAL
  zh: '你可以看到，在移除 "MA" 键对应的值后，`usStates` 被更新为 ["MN": "Minnesota", "WA": "Washington",
    "TX": "Texas"]。记住，`nil` 是特殊的，表示根本没有值。这就是为什么你在我们的字典中看不到 "MA": nil。'
- en: '**REPLACING ITEMS IN A DICTIONARY**'
  id: totrans-6812
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**替换字典中的项目**'
- en: 'Replacing an item in a dictionary is also easy. It works the same was as replacing
    an item in an array. You just set the item that you want to replace to something
    else. Say you create a dictionary of fruit colors:'
  id: totrans-6813
  prefs: []
  type: TYPE_NORMAL
  zh: 替换字典中的项目也很简单。它与替换数组中的项目相同。你只需将你想替换的项目设置为其他内容。假设你创建了一个水果颜色的字典：
- en: '![](Image00146.jpg)'
  id: totrans-6814
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00146.jpg)'
- en: At first we had the value "apple" for "red" , but then we decided that "raspberry"
    is a better fruit to use since sometimes apples are green or yellow. To replace
    "apple" with "raspberry" , we set colorFruits["red"] to its new value ➊ .
  id: totrans-6815
  prefs: []
  type: TYPE_NORMAL
  zh: 起初我们给 "red" 键的值是 "apple"，但后来我们决定 "raspberry" 是更好的水果，因为有时候苹果是绿色或黄色的。为了将 "apple"
    替换为 "raspberry"，我们将 `colorFruits["red"]` 设置为它的新值 ➊。
- en: You may remember that this is the same way we entered a new value into a dictionary.
    If the key already exists in the dictionary, then the value for that key is replaced.
    If the key doesn’t already exist, then the new key/value pair will be added to
    the dictionary.
  id: totrans-6816
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能还记得，这与我们向字典中添加新值的方式相同。如果字典中已经存在该键，那么该键的值会被替换。如果该键不存在，则新的键/值对将被添加到字典中。
- en: '![Image](Image00147.jpg)'
  id: totrans-6817
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00147.jpg)'
- en: '**USING DICTIONARY PROPERTIES**'
  id: totrans-6818
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**使用字典属性**'
- en: 'Like an array, a dictionary also has an isEmpty property and a count property.
    For example, the following code shows how you can use the isEmpty property to
    check if a dictionary is empty, and if it isn’t empty, the count property checks
    how many items you have. Imagine you have a basket of fruit for sale. You can
    use these properties to help you keep track of everything:'
  id: totrans-6819
  prefs: []
  type: TYPE_NORMAL
  zh: 像数组一样，字典也有 `isEmpty` 属性和 `count` 属性。例如，以下代码展示了如何使用 `isEmpty` 属性来检查字典是否为空，如果不为空，`count`
    属性可以检查你有多少个项目。想象一下你有一个待售的水果篮。你可以使用这些属性来帮助你跟踪所有内容：
- en: '![Image](Image00148.jpg)'
  id: totrans-6820
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00148.jpg)'
- en: 'A dictionary also has two special properties: keys , which contains all of
    the dictionary’s keys, and values , which contains all of its values. We’ll use
    these two properties when we loop through the dictionary.'
  id: totrans-6821
  prefs: []
  type: TYPE_NORMAL
  zh: 字典还有两个特殊的属性：`keys`，它包含字典的所有键，以及 `values`，它包含字典的所有值。我们将在遍历字典时使用这两个属性。
- en: Let’s write some code that loops through our fruit baskets and prints the price
    of each fruit.
  id: totrans-6822
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们编写一些代码，遍历我们的水果篮，并打印每个水果的价格。
- en: '**LOOPING OVER A DICTIONARY**'
  id: totrans-6823
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**遍历字典**'
- en: 'You can loop through a dictionary using a for-in loop. Because each item has
    a key and a value, you can do this in two different ways. This is how to loop
    through a dictionary using its keys:'
  id: totrans-6824
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用 `for-in` 循环遍历字典。由于每个项目都有一个键和值，你可以通过两种不同的方式来实现这一点。以下是通过字典的键来遍历字典的方法：
- en: '![Image](Image00149.jpg)'
  id: totrans-6825
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00149.jpg)'
- en: Here we use the dictionary’s keys property ➊ to loop through fruitBasket and
    print its contents. We start by writing the keyword for , followed by a constant
    name fruit for the dictionary key, the keyword in , the dictionary name, a period,
    and keys .
  id: totrans-6826
  prefs: []
  type: TYPE_NORMAL
  zh: 这里我们使用字典的 keys 属性 ➊ 来遍历 fruitBasket 并打印其内容。我们首先写下关键字 for，然后是字典键的常量名称 fruit，接着是关键字
    in、字典名称、一个句点和 keys。
- en: Inside the braces of our for-in loop, we have access to both the key, which
    we call fruit ➋ , and the value at that key when we force-unwrap its contents
    with fruitBasket[fruit]! ➌ . That value will be the fruit’s price.
  id: totrans-6827
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的 for-in 循环的大括号内，我们既可以访问键（我们称之为 fruit ➋），也可以通过强制解包 fruitBasket[fruit]! ➌
    来访问该键对应的值。该值将是水果的价格。
- en: In this case, it’s safe to force-unwrap the value using an exclamation point
    because we know that the fruit key we’re using is definitely inside the dictionary.
  id: totrans-6828
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，使用感叹号强制解包值是安全的，因为我们知道所使用的 fruit 键肯定在字典中。
- en: Any code we put inside the for-in loop will run once for every key in our dictionary.
    So you should see the print statement display three times.
  id: totrans-6829
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在 for-in 循环中放入的任何代码都会针对字典中的每一个键执行一次。所以你应该看到 print 语句打印三次。
- en: 'We can also loop through the dictionary using its values property:'
  id: totrans-6830
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以通过字典的值属性来遍历字典：
- en: '![Image](Image00150.jpg)'
  id: totrans-6831
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00150.jpg)'
- en: We use the same style of for-in loop, but now we use a constant to refer to
    each value, which we call price , in the values property. When looping through
    values, we don’t have access to the keys from inside the loop.
  id: totrans-6832
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用相同类型的 for-in 循环，但现在我们使用一个常量来引用每个值，我们称之为 price，来自 values 属性。在循环遍历值时，我们无法从循环内部访问键。
- en: Another difference to note is that price is not an optional because it’s accessed
    directly as a value in the fruitBasket dictionary. That means we don’t have to
    unwrap it. You should still see the print statement printed three times. [Figure
    6-6](text00016.html#ch06fig6) shows the output of both loops.
  id: totrans-6833
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个需要注意的不同之处是，price 不是一个可选类型，因为它是直接作为 fruitBasket 字典中的值来访问的。这意味着我们不需要解包它。你应该仍然看到
    print 语句打印三次。[图 6-6](text00016.html#ch06fig6) 显示了两种循环的输出。
- en: '![Image](Image00151.jpg)'
  id: totrans-6834
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00151.jpg)'
- en: '*Figure 6-6: Looping through the keys and values of a dictionary with a for-in
    loop*'
  id: totrans-6835
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 6-6：使用 for-in 循环遍历字典的键和值*'
- en: The order of your results might be slightly different from ours. That’s because
    the items in a dictionary aren’t in a numbered order like they are in an array!
    And because the order is not guaranteed, you might see a different order printed
    if you run the same code again.
  id: totrans-6836
  prefs: []
  type: TYPE_NORMAL
  zh: 你的结果顺序可能与我们的略有不同。这是因为字典中的项不像数组那样按编号顺序排列！而且由于顺序无法保证，如果你再次运行相同的代码，可能会看到不同的顺序。
- en: '**WHAT YOU LEARNED**'
  id: totrans-6837
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**你学到的内容**'
- en: In this chapter, you learned how to store collections of items in an array and
    in a dictionary. To store items in an ordered list, you would use an array and
    look up each item by its index. If you wanted to store items by key instead, you
    would use a dictionary.
  id: totrans-6838
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一章中，你学习了如何在数组和字典中存储项。要存储有序的列表项，你可以使用数组并通过索引查找每个项。如果你想按键存储项，则应使用字典。
- en: Knowing about arrays and dictionaries and how to use them is a powerful building
    block for almost any programming language. Next we will learn about functions,
    another very powerful tool. Functions are blocks of code that you create and name
    to perform a specific job. After you have written a function, you can use its
    name to call it from almost anywhere in your program.
  id: totrans-6839
  prefs: []
  type: TYPE_NORMAL
  zh: 了解数组和字典以及如何使用它们，是几乎所有编程语言中非常强大的构建模块。接下来，我们将学习函数，这是另一个非常强大的工具。函数是你创建并命名的代码块，用于执行特定的任务。编写完一个函数后，你可以通过它的名字在程序的几乎任何地方调用它。
- en: '![](Image00128.jpg)'
  id: totrans-6840
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00128.jpg)'
- en: Just like when we added an item to the middle of our array and all the items
    scooted over to make room, if you remove an item from the middle of an array,
    the rest of the items will scoot back to fill in that empty space. The "apples"
    item that was at index 3 is now at index 2, where "candy" was.
  id: totrans-6841
  prefs: []
  type: TYPE_NORMAL
  zh: 就像我们在数组中间添加项时，所有的项都会移位以腾出空间一样，如果你从数组中间移除一个项，其余的项会向回移动，以填补那个空位。原本在索引 3 位置的 "apples"
    现在在索引 2 位置，原来的 "candy" 被挤到后面去了。
- en: 'You can also remove all items from an array with removeAll() . Try entering
    this into your playground:'
  id: totrans-6842
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以使用 removeAll() 从数组中删除所有项。试着在你的 playground 中输入这个：
- en: '![](Image00129.jpg)'
  id: totrans-6843
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00129.jpg)'
- en: 'Note that trying to remove an item at an index that doesn’t exist will give
    you an error:'
  id: totrans-6844
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，尝试删除一个不存在的索引项会导致错误：
- en: '![](Image00130.jpg)'
  id: totrans-6845
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00130.jpg)'
- en: Our array doesn’t have this many items (in fact, now it’s empty!), so this throws
    an error. We’ll also get an error if we use removeLast() on our empty array, because
    there’s nothing in it—there’s no last index at all! However, removeAll() is always
    safe to use, even on an empty array.
  id: totrans-6846
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的数组中没有这么多项（实际上，现在它是空的！），所以这会抛出一个错误。如果我们在空数组上使用 removeLast()，也会报错，因为数组中没有元素——根本没有最后一个索引！然而，使用
    removeAll() 总是安全的，即使是在空数组上。
- en: '**REPLACING ITEMS IN AN ARRAY**'
  id: totrans-6847
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**替换数组中的元素**'
- en: 'To replace an item in an array, you set the index of the array to the new value,
    as shown here:'
  id: totrans-6848
  prefs: []
  type: TYPE_NORMAL
  zh: 要替换数组中的元素，你只需要将数组的某个索引设置为新值，如下所示：
- en: '![](Image00131.jpg)'
  id: totrans-6849
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00131.jpg)'
- en: At ➊ , we replaced the item at index 2 (the third item) with "Unicorn" because
    magical animals count as favorite animals, too! At ➋ , we replaced the item at
    index 0 (the first item) with "Bearded dragon" . No, that’s not a real dragon—it’s
    just a lizard!
  id: totrans-6850
  prefs: []
  type: TYPE_NORMAL
  zh: 在 ➊ 处，我们将索引为 2（第三个元素）的项替换为“独角兽”，因为神奇的动物也算是最喜欢的动物！在 ➋ 处，我们将索引为 0（第一个元素）的项替换为“胡须龙”。不，这不是一只真正的龙——它只是一只蜥蜴！
- en: Like any time you’re working with array index numbers, you have to be sure an
    item exists in the array at that index before you change its value, or you will
    get an Index out of range error.
  id: totrans-6851
  prefs: []
  type: TYPE_NORMAL
  zh: 每当你处理数组索引时，你必须确保该索引处有一个元素，否则在修改其值时会出现“索引超出范围”的错误。
- en: '[Figure 6-3](text00016.html#ch06fig3) shows the error that occurs if you try
    to add "Standard poodle" using favoriteAnimals[3] = "Standard poodle" . To add
    an item to the end of an array, you should use the append(_:) method or += , as
    we covered in “[Adding Items to an Array](text00016.html#ch06lev2sec5) ” on [page
    70](text00016.html#page_70) .'
  id: totrans-6852
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 6-3](text00016.html#ch06fig3) 显示了如果你尝试通过 favoriteAnimals[3] = "Standard
    poodle" 添加“标准贵宾犬”时会发生的错误。要将项添加到数组的末尾，应该使用 append(_:) 方法或 += 运算符，就像我们在 “[向数组添加项](text00016.html#ch06lev2sec5)”
    第 70 页中讨论的那样。'
- en: '![Image](Image00132.jpg)'
  id: totrans-6853
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00132.jpg)'
- en: '*Figure 6-3: Don’t try to replace a value at an index beyond the existing array.*'
  id: totrans-6854
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 6-3：不要尝试替换超出现有数组索引的值。*'
- en: Now you know how to change arrays however you might need to. You can add items,
    take items away, or replace items. Next, we’ll look at how to use the properties
    of arrays to find out even more information about them.
  id: totrans-6855
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你知道如何根据需要修改数组了。你可以添加元素、移除元素或替换元素。接下来，我们将了解如何使用数组的属性来获取更多有关数组的信息。
- en: '![Image](Image00133.jpg)'
  id: totrans-6856
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00133.jpg)'
- en: '**USING ARRAY PROPERTIES**'
  id: totrans-6857
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**使用数组属性**'
- en: In addition to methods like append(_:) and removeLast() , arrays also have *properties*
    . An array’s properties are variables or constants that contain some information
    about the array. Two really helpful properties that you might use are the Boolean
    property isEmpty and the integer property count .
  id: totrans-6858
  prefs: []
  type: TYPE_NORMAL
  zh: 除了像 append(_:) 和 removeLast() 这样的函数方法外，数组还有一些 *属性* 。数组的属性是包含有关数组信息的变量或常量。你可能会使用的两个非常有用的属性是布尔类型的
    isEmpty 属性和整数类型的 count 属性。
- en: The isEmpty property is true or false depending on whether the array is empty,
    and the count property will tell you how many items are in that array.
  id: totrans-6859
  prefs: []
  type: TYPE_NORMAL
  zh: isEmpty 属性根据数组是否为空来返回 true 或 false，而 count 属性则会告诉你数组中有多少个元素。
- en: 'Check out how these two properties are used in the following if-else statement:'
  id: totrans-6860
  prefs: []
  type: TYPE_NORMAL
  zh: 查看以下 if-else 语句中这两个属性的使用方法：
- en: '![Image](Image00134.jpg)'
  id: totrans-6861
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00134.jpg)'
- en: 'This if-else statement checks whether the array mySiblings is empty ➊ . If
    it is, then "I don''t have any siblings." is printed. But if there is something
    in the array, then the number of siblings that we have is printed: "I have 3 siblings."
    ➋ .'
  id: totrans-6862
  prefs: []
  type: TYPE_NORMAL
  zh: 该 if-else 语句检查数组 mySiblings 是否为空 ➊ 。如果为空，则打印“我没有兄弟姐妹。”如果数组中有元素，则会打印出兄弟姐妹的数量：“我有
    3 个兄弟姐妹。” ➋ 。
- en: '**LOOPING OVER AN ARRAY**'
  id: totrans-6863
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**遍历数组**'
- en: 'Sometimes when you’re working with arrays you might want to do something to
    every item in the array. You can use a for-in loop to do that! The following code
    will print every topping in a pizzaToppings array on a separate line:'
  id: totrans-6864
  prefs: []
  type: TYPE_NORMAL
  zh: 有时在处理数组时，你可能想对数组中的每个元素执行某些操作。你可以使用 for-in 循环来实现这一点！以下代码将在每一行打印出 pizzaToppings
    数组中的每一个配料：
- en: '![Image](Image00135.jpg)'
  id: totrans-6865
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00135.jpg)'
- en: To write a for-in loop for the pizzaToppings array, we used the keyword for
    , followed by the constant topping , then the keyword in , and finally the name
    of our array, pizzaToppings . Then we put the statements that we want to run for
    each topping inside the braces of the for-in loop. The constant topping ➊ temporarily
    represents each pizza topping in the array as we loop through it. We could have
    chosen any name for this constant, but it’s a good idea to pick something that
    makes sense. You can see the output of this for-in loop in [Figure 6-4](text00016.html#ch06fig4)
    .
  id: totrans-6866
  prefs: []
  type: TYPE_NORMAL
  zh: 要为 pizzaToppings 数组编写一个 for-in 循环，我们使用了关键字 for，后面是常量 topping，然后是关键字 in，最后是我们数组的名称
    pizzaToppings。接着我们将希望对每个 topping 执行的语句放在 for-in 循环的大括号内。常量 topping ➊ 在我们遍历数组时，暂时代表数组中的每一个比萨配料。我们本可以为这个常量选择任何名字，但最好选一个有意义的名称。你可以在[图
    6-4](text00016.html#ch06fig4)中看到这个 for-in 循环的输出。
- en: '![Image](Image00136.jpg)'
  id: totrans-6867
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00136.jpg)'
- en: '*Figure 6-4: Output of the example for-in loop*'
  id: totrans-6868
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 6-4：示例 for-in 循环的输出*'
- en: '![Image](Image00137.jpg)'
  id: totrans-6869
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00137.jpg)'
- en: 'Using for-in loops is great for printing every value in an array. If you’re
    working with numbers, you can even use them to perform math operations on each
    item, which makes for some speedy calculations! The following code takes an array
    of numbers and calculates the square for each (the square of a number is that
    number multiplied by itself):'
  id: totrans-6870
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 for-in 循环非常适合打印数组中的每一个值。如果你正在处理数字，甚至可以用它们对每个项进行数学运算，这样就能快速进行计算！以下代码会对一个数字数组进行遍历，并计算每个数字的平方（数字的平方就是该数字乘以它自己）：
- en: '![Image](Image00138.jpg)'
  id: totrans-6871
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00138.jpg)'
- en: '[Figure 6-5](text00016.html#ch06fig5) shows the results.'
  id: totrans-6872
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 6-5](text00016.html#ch06fig5) 显示了结果。'
- en: '![Image](Image00139.jpg)'
  id: totrans-6873
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00139.jpg)'
- en: '*Figure 6-5: Printing the squares for each number in the myNumbers array*'
  id: totrans-6874
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 6-5：打印 myNumbers 数组中每个数字的平方*'
- en: '**DICTIONARIES ARE KEY!**'
  id: totrans-6875
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**字典至关重要！**'
- en: A *dictionary* is also a collection of values, but instead of an ordered index,
    each value has its own *key* . Because there’s no index, the values are not stored
    in any particular order. To access values in a dictionary, you look them up by
    their key.
  id: totrans-6876
  prefs: []
  type: TYPE_NORMAL
  zh: 一个*字典*也是一个值的集合，但是与有序索引不同，每个值都有它自己的*键*。由于没有索引，值的存储顺序没有特定要求。要访问字典中的值，你需要通过它们的键来查找。
- en: A key must be unique. You can’t have the same key more than once in the same
    dictionary. If there were two identical keys and you asked the computer to give
    you the value for one of them, the computer wouldn’t know which one to choose!
  id: totrans-6877
  prefs: []
  type: TYPE_NORMAL
  zh: 键必须是唯一的。你不能在同一个字典中使用相同的键两次。如果有两个相同的键，且你要求计算机给出其中一个的值，计算机将不知道选择哪个！
- en: Let’s take a look at how to make a dictionary and write keys that will help
    you find all the information you need.
  id: totrans-6878
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看一下如何创建一个字典，并编写能够帮助你找到所有所需信息的键。
- en: '![Image](Image00140.jpg)'
  id: totrans-6879
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00140.jpg)'
- en: '**INITIALIZING A DICTIONARY**'
  id: totrans-6880
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**初始化字典**'
- en: 'To create and initialize a dictionary, first write var and the name of your
    dictionary. Then write the keys and corresponding values inside a pair of square
    brackets, similar to an array. Let’s create a dictionary to store the names of
    a few US states. The key for each state will be its two-letter abbreviation:'
  id: totrans-6881
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建和初始化字典，首先写 var 和字典的名称。然后，在一对方括号中写入键和值对，类似于数组的写法。让我们创建一个字典来存储一些美国州的名称。每个州的键将是它的两字母缩写：
- en: '![](Image00141.jpg)'
  id: totrans-6882
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00141.jpg)'
- en: As you can see, there’s a colon between each key and its value, and the key/value
    pairs are separated by commas.
  id: totrans-6883
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，每个键和值之间都有一个冒号，并且键值对之间用逗号分隔。
- en: Dictionaries are different from arrays in that they are *unordered* . Because
    of that, it’s likely that the order of the states that you see in your results
    pane ➋ is different from the order in which you entered your states ➊ . It might
    even be different than the order that’s printed in this book!
  id: totrans-6884
  prefs: []
  type: TYPE_NORMAL
  zh: 字典与数组的不同之处在于它们是*无序*的。因此，你在结果面板中看到的状态顺序➋可能与输入状态的顺序➊不同。它甚至可能与本书中列出的顺序不同！
- en: As with arrays, you can use var to make a mutable dictionary or use let to make
    an immutable dictionary.
  id: totrans-6885
  prefs: []
  type: TYPE_NORMAL
  zh: 与数组一样，你可以使用 var 来创建一个可变字典，或者使用 let 来创建一个不可变字典。
- en: 'In Swift, all of the keys of a dictionary must be the same type, and all of
    the values of a dictionary must also be the same type, but the key type doesn’t
    have to match the value type. For example, if you wanted to store a collection
    of fractions, you could use doubles for the keys and strings for the values:'
  id: totrans-6886
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Swift 中，字典的所有键必须是相同类型，字典的所有值也必须是相同类型，但键的类型不必与值的类型匹配。例如，如果你想存储一组分数，你可以使用 doubles
    作为键，使用 strings 作为值：
- en: '![](Image00142.jpg)'
  id: totrans-6887
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00142.jpg)'
- en: In this dictionary, all of the keys must be doubles, and all of the values must
    be strings. Again, you’ll see that the order of the numbers in the results pane
    can be quite different from the order in which you wrote the fractions in your
    dictionary. This is fine because you don’t need to know the order to access anything.
    You can find any item that you need by its key. Let’s see how!
  id: totrans-6888
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个字典中，所有的键必须是 doubles，所有的值必须是 strings。同样，你会看到结果窗格中的数字顺序可能与在字典中编写分数的顺序完全不同。这没关系，因为你不需要知道顺序就能访问任何项目。你可以通过键来找到你需要的任何项目。我们来看看怎么做！
- en: '**ACCESSING VALUES IN A DICTIONARY**'
  id: totrans-6889
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**访问字典中的值**'
- en: 'Looking up a value in a dictionary is similar to how you access a value in
    an array except that you use a key inside the square brackets instead of an index,
    like this: usStates["TX"] .'
  id: totrans-6890
  prefs: []
  type: TYPE_NORMAL
  zh: 在字典中查找值类似于在数组中访问值，只是你在方括号内使用的是键，而不是索引，像这样：usStates["TX"]。
- en: There is a big difference, however, in how Swift returns the values from a dictionary.
    When you access a value at an index of an array, you are simply given the value.
    When you access a value with a key in a dictionary, you are given an optional.
  id: totrans-6891
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，Swift 从字典返回值的方式有很大不同。当你访问数组中某个索引的值时，你只会得到那个值。而当你通过字典中的键访问值时，你会得到一个可选值。
- en: In [Chapter 5](text00015.html#ch05) , you learned that optionals might contain
    a value or might be nil . The reason Swift returns optionals when you’re looking
    up items in a dictionary is that the key you used might not exist in the dictionary,
    in which case there’s no value to access. Trying to access a value that doesn’t
    exist would give you a big fat error! To avoid that problem, Swift returns optionals.
    That means you need to unwrap any value you get out of a dictionary before you
    can do anything with it.
  id: totrans-6892
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第 5 章](text00015.html#ch05)中，你学到了可选值可能包含一个值，也可能是 nil。Swift 在查找字典中的项目时返回可选值的原因是，你使用的键可能在字典中不存在，这种情况下就没有值可以访问。尝试访问一个不存在的值会导致一个严重的错误！为避免这个问题，Swift
    返回可选值。这意味着你需要解包从字典中获取的任何值，才能对其进行操作。
- en: 'To unwrap an optional, first you check whether it exists using an if-let statement,
    just like we did in [Chapter 5](text00015.html#ch05) . The following code shows
    you how to get a value out of a dictionary:'
  id: totrans-6893
  prefs: []
  type: TYPE_NORMAL
  zh: 要解包一个可选值，首先你需要使用 if-let 语句检查它是否存在，就像我们在[第 5 章](text00015.html#ch05)中做的那样。以下代码展示了如何从字典中获取一个值：
- en: '![Image](Image00143.jpg)'
  id: totrans-6894
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00143.jpg)'
- en: To retrieve "Texas" from the dictionary, we use if let to set a constant loneStarState
    to usStates["TX"] ➊ . Because we have this state in our dictionary, the line I
    have Texas in my dictionary. is printed. Next we try to access a state that is
    not in our dictionary by using the key usStates["FL"] ➋ . Thankfully, because
    we used an if-let statement, the program won’t crash when the computer can’t find
    this state. Instead, I don't have that state in my dictionary. is printed.
  id: totrans-6895
  prefs: []
  type: TYPE_NORMAL
  zh: 要从字典中检索“Texas”，我们使用 if let 将常量 loneStarState 设置为 usStates["TX"] ➊ 。因为我们的字典中有这个州，所以会打印出“我在字典中有
    Texas”。接下来，我们尝试通过使用键 usStates["FL"] ➋ 访问一个不在字典中的州。幸运的是，由于我们使用了 if-let 语句，当计算机找不到这个州时，程序不会崩溃。相反，会打印出“我在字典中没有这个州”。
- en: '**ADDING ITEMS TO A DICTIONARY**'
  id: totrans-6896
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**向字典添加项目**'
- en: 'To add an item to a dictionary, first write the name of your dictionary and
    assign the new item to the key you want it to have in the dictionary. Let’s add
    "Minnesota" to our usStates dictionary:'
  id: totrans-6897
  prefs: []
  type: TYPE_NORMAL
  zh: 要向字典中添加一个项目，首先写出字典的名称，并将新项目分配给你希望它在字典中拥有的键。让我们将“Minnesota”添加到我们的 usStates 字典中：
- en: '![](Image00144.jpg)'
  id: totrans-6898
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00144.jpg)'
- en: 'Now when you look at usStates , you’ll see that it’s updated to ["MN": "Minnesota",
    "WA": "Washington", "MA": "Massachusetts", "TX": "Texas"] . Remember, because
    you don’t have to rely on indices, your new dictionary item might appear anywhere
    in the dictionary.'
  id: totrans-6899
  prefs: []
  type: TYPE_NORMAL
  zh: '现在，当你查看 usStates 时，你会看到它已经更新为 ["MN": "Minnesota", "WA": "Washington", "MA":
    "Massachusetts", "TX": "Texas"]。记住，由于你不需要依赖索引，你的新字典项目可能会出现在字典中的任何位置。'
- en: '**REMOVING ITEMS FROM A DICTIONARY**'
  id: totrans-6900
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**从字典中移除项目**'
- en: Removing an item from a dictionary is quite simple; you do so by setting the
    value to nil . Because the values in dictionaries are returned as optionals, you
    don’t have to worry about nil causing any problems in your dictionary.
  id: totrans-6901
  prefs: []
  type: TYPE_NORMAL
  zh: 从字典中删除项非常简单；你只需将值设置为nil。由于字典中的值是作为可选项返回的，所以你无需担心nil会导致字典出现任何问题。
- en: '![](Image00145.jpg)'
  id: totrans-6902
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00145.jpg)'
- en: 'You can see that after you remove the value at the key "MA" , usStates is updated
    to ["MN": "Minnesota", "WA": "Washington", "TX": "Texas"] . Remember that nil
    is special and means that there’s no value at all. That’s why you don’t see "MA":
    nil in our dictionary.'
  id: totrans-6903
  prefs: []
  type: TYPE_NORMAL
  zh: '你可以看到，在删除了键“MA”对应的值后，usStates被更新为["MN": "Minnesota", "WA": "Washington", "TX":
    "Texas"]。记住，nil是特殊的，表示没有任何值。这就是为什么你不会在字典中看到"MA": nil。'
- en: '**REPLACING ITEMS IN A DICTIONARY**'
  id: totrans-6904
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**替换字典中的项**'
- en: 'Replacing an item in a dictionary is also easy. It works the same was as replacing
    an item in an array. You just set the item that you want to replace to something
    else. Say you create a dictionary of fruit colors:'
  id: totrans-6905
  prefs: []
  type: TYPE_NORMAL
  zh: 替换字典中的项也很简单。它的工作方式和替换数组中的项一样。你只需要将你想替换的项设置为其他值。假设你创建了一个水果颜色的字典：
- en: '![](Image00146.jpg)'
  id: totrans-6906
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00146.jpg)'
- en: At first we had the value "apple" for "red" , but then we decided that "raspberry"
    is a better fruit to use since sometimes apples are green or yellow. To replace
    "apple" with "raspberry" , we set colorFruits["red"] to its new value ➊ .
  id: totrans-6907
  prefs: []
  type: TYPE_NORMAL
  zh: 最开始我们将“apple”赋值给了“red”，但后来我们决定使用“raspberry”作为更合适的水果，因为有时候苹果是绿色或黄色的。要将“apple”替换为“raspberry”，我们将colorFruits["red"]设置为它的新值➊。
- en: You may remember that this is the same way we entered a new value into a dictionary.
    If the key already exists in the dictionary, then the value for that key is replaced.
    If the key doesn’t already exist, then the new key/value pair will be added to
    the dictionary.
  id: totrans-6908
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能还记得，这与我们向字典中输入新值的方式是一样的。如果字典中已存在该键，则会替换该键的值。如果该键不存在，则会将新的键/值对添加到字典中。
- en: '![Image](Image00147.jpg)'
  id: totrans-6909
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00147.jpg)'
- en: '**USING DICTIONARY PROPERTIES**'
  id: totrans-6910
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**使用字典属性**'
- en: 'Like an array, a dictionary also has an isEmpty property and a count property.
    For example, the following code shows how you can use the isEmpty property to
    check if a dictionary is empty, and if it isn’t empty, the count property checks
    how many items you have. Imagine you have a basket of fruit for sale. You can
    use these properties to help you keep track of everything:'
  id: totrans-6911
  prefs: []
  type: TYPE_NORMAL
  zh: 和数组一样，字典也有isEmpty属性和count属性。例如，下面的代码展示了如何使用isEmpty属性检查字典是否为空，如果字典不为空，count属性则用来检查字典中有多少项。假设你有一个出售的水果篮，你可以利用这些属性来帮助你跟踪所有的水果：
- en: '![Image](Image00148.jpg)'
  id: totrans-6912
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00148.jpg)'
- en: 'A dictionary also has two special properties: keys , which contains all of
    the dictionary’s keys, and values , which contains all of its values. We’ll use
    these two properties when we loop through the dictionary.'
  id: totrans-6913
  prefs: []
  type: TYPE_NORMAL
  zh: 字典还有两个特殊属性：keys，包含字典的所有键；values，包含字典的所有值。我们将在遍历字典时使用这两个属性。
- en: Let’s write some code that loops through our fruit baskets and prints the price
    of each fruit.
  id: totrans-6914
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们编写一些代码，循环遍历我们的水果篮，并打印每种水果的价格。
- en: '**LOOPING OVER A DICTIONARY**'
  id: totrans-6915
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**循环遍历字典**'
- en: 'You can loop through a dictionary using a for-in loop. Because each item has
    a key and a value, you can do this in two different ways. This is how to loop
    through a dictionary using its keys:'
  id: totrans-6916
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用for-in循环来遍历字典。因为每个项都有一个键和值，你可以用两种不同的方式来实现这一点。这是如何通过字典的键来循环遍历字典：
- en: '![Image](Image00149.jpg)'
  id: totrans-6917
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00149.jpg)'
- en: Here we use the dictionary’s keys property ➊ to loop through fruitBasket and
    print its contents. We start by writing the keyword for , followed by a constant
    name fruit for the dictionary key, the keyword in , the dictionary name, a period,
    and keys .
  id: totrans-6918
  prefs: []
  type: TYPE_NORMAL
  zh: 这里我们使用字典的keys属性➊来循环遍历fruitBasket并打印它的内容。我们从写出关键字for开始，接着是一个常量名称fruit代表字典的键，关键字in，字典名称，句点，最后是keys。
- en: Inside the braces of our for-in loop, we have access to both the key, which
    we call fruit ➋ , and the value at that key when we force-unwrap its contents
    with fruitBasket[fruit]! ➌ . That value will be the fruit’s price.
  id: totrans-6919
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的for-in循环的花括号内，我们可以访问到键（我们称其为fruit➋）以及通过强制解包fruitBasket[fruit]!➌获取的该键的值。这个值将是水果的价格。
- en: In this case, it’s safe to force-unwrap the value using an exclamation point
    because we know that the fruit key we’re using is definitely inside the dictionary.
  id: totrans-6920
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，强制解包值是安全的，因为我们知道我们使用的fruit键一定在字典中。
- en: Any code we put inside the for-in loop will run once for every key in our dictionary.
    So you should see the print statement display three times.
  id: totrans-6921
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在 for-in 循环中放入的任何代码都会对字典中的每个键执行一次。所以你应该会看到打印语句显示三次。
- en: 'We can also loop through the dictionary using its values property:'
  id: totrans-6922
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以通过字典的 values 属性来遍历字典：
- en: '![Image](Image00150.jpg)'
  id: totrans-6923
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00150.jpg)'
- en: We use the same style of for-in loop, but now we use a constant to refer to
    each value, which we call price , in the values property. When looping through
    values, we don’t have access to the keys from inside the loop.
  id: totrans-6924
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用相同的 for-in 循环，但现在我们使用常量来引用每个值，我们称之为 price ，它在 values 属性中。当遍历 values 时，我们无法从循环内部访问键。
- en: Another difference to note is that price is not an optional because it’s accessed
    directly as a value in the fruitBasket dictionary. That means we don’t have to
    unwrap it. You should still see the print statement printed three times. [Figure
    6-6](text00016.html#ch06fig6) shows the output of both loops.
  id: totrans-6925
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个需要注意的区别是，price 不是一个可选值，因为它是直接作为 fruitBasket 字典中的值进行访问的。这意味着我们不需要解包它。你应该仍然会看到打印语句打印三次。[图
    6-6](text00016.html#ch06fig6) 显示了两个循环的输出。
- en: '![Image](Image00151.jpg)'
  id: totrans-6926
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00151.jpg)'
- en: '*Figure 6-6: Looping through the keys and values of a dictionary with a for-in
    loop*'
  id: totrans-6927
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 6-6：使用 for-in 循环遍历字典的键和值*'
- en: The order of your results might be slightly different from ours. That’s because
    the items in a dictionary aren’t in a numbered order like they are in an array!
    And because the order is not guaranteed, you might see a different order printed
    if you run the same code again.
  id: totrans-6928
  prefs: []
  type: TYPE_NORMAL
  zh: 你的结果顺序可能会与我们的稍有不同。这是因为字典中的项不像数组中的项那样按数字顺序排列！由于顺序无法保证，因此如果你再次运行相同的代码，可能会看到不同的顺序。
- en: '**WHAT YOU LEARNED**'
  id: totrans-6929
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**你学到了什么**'
- en: In this chapter, you learned how to store collections of items in an array and
    in a dictionary. To store items in an ordered list, you would use an array and
    look up each item by its index. If you wanted to store items by key instead, you
    would use a dictionary.
  id: totrans-6930
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你学习了如何将项存储在数组和字典中。为了将项存储在有序列表中，你会使用数组，并通过索引查找每一项。如果你想按键存储项，则会使用字典。
- en: Knowing about arrays and dictionaries and how to use them is a powerful building
    block for almost any programming language. Next we will learn about functions,
    another very powerful tool. Functions are blocks of code that you create and name
    to perform a specific job. After you have written a function, you can use its
    name to call it from almost anywhere in your program.
  id: totrans-6931
  prefs: []
  type: TYPE_NORMAL
  zh: 了解数组和字典以及如何使用它们，是几乎所有编程语言中的一个强大构建块。接下来我们将学习函数，这是另一种非常强大的工具。函数是你创建并命名的代码块，用来执行特定的任务。在你编写了一个函数之后，你可以通过它的名字在程序中的几乎任何地方调用它。
- en: Just like when we added an item to the middle of our array and all the items
    scooted over to make room, if you remove an item from the middle of an array,
    the rest of the items will scoot back to fill in that empty space. The "apples"
    item that was at index 3 is now at index 2, where "candy" was.
  id: totrans-6932
  prefs: []
  type: TYPE_NORMAL
  zh: 就像我们将项添加到数组的中间时，所有项都向后移动以腾出空间一样，如果你从数组中间删除一项，其余项将会向前移动填补空位。原本在索引 3 处的 "apples"
    项现在位于索引 2 处，原来 "candy" 所在的位置。
- en: 'You can also remove all items from an array with removeAll() . Try entering
    this into your playground:'
  id: totrans-6933
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以使用 removeAll() 删除数组中的所有项。尝试将其输入到你的 Playground 中：
- en: '![](Image00129.jpg)'
  id: totrans-6934
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00129.jpg)'
- en: 'Note that trying to remove an item at an index that doesn’t exist will give
    you an error:'
  id: totrans-6935
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，尝试删除一个不存在索引的项会给出错误：
- en: '![](Image00130.jpg)'
  id: totrans-6936
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00130.jpg)'
- en: Our array doesn’t have this many items (in fact, now it’s empty!), so this throws
    an error. We’ll also get an error if we use removeLast() on our empty array, because
    there’s nothing in it—there’s no last index at all! However, removeAll() is always
    safe to use, even on an empty array.
  id: totrans-6937
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的数组没有这么多项（事实上，现在它是空的！），所以会抛出一个错误。如果我们在空数组上使用 removeLast()，也会发生错误，因为它里面没有任何内容——根本没有最后一个索引！然而，removeAll()
    即使在空数组上使用也是安全的。
- en: '**REPLACING ITEMS IN AN ARRAY**'
  id: totrans-6938
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**替换数组中的项**'
- en: 'To replace an item in an array, you set the index of the array to the new value,
    as shown here:'
  id: totrans-6939
  prefs: []
  type: TYPE_NORMAL
  zh: 要替换数组中的项，你需要将数组的索引设置为新值，如下所示：
- en: '![](Image00131.jpg)'
  id: totrans-6940
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00131.jpg)'
- en: At ➊ , we replaced the item at index 2 (the third item) with "Unicorn" because
    magical animals count as favorite animals, too! At ➋ , we replaced the item at
    index 0 (the first item) with "Bearded dragon" . No, that’s not a real dragon—it’s
    just a lizard!
  id: totrans-6941
  prefs: []
  type: TYPE_NORMAL
  zh: 在➊处，我们将索引为2（第三个项目）的项替换为“独角兽”，因为魔法动物也算作喜欢的动物！在➋处，我们将索引为0（第一个项目）的项替换为“胡须龙”。不，这不是一条真正的龙——它只是一只蜥蜴！
- en: Like any time you’re working with array index numbers, you have to be sure an
    item exists in the array at that index before you change its value, or you will
    get an Index out of range error.
  id: totrans-6942
  prefs: []
  type: TYPE_NORMAL
  zh: 就像每次操作数组索引时一样，你必须确保该索引处的项在数组中存在，才可以更改其值，否则会出现“超出范围”的错误。
- en: '[Figure 6-3](text00016.html#ch06fig3) shows the error that occurs if you try
    to add "Standard poodle" using favoriteAnimals[3] = "Standard poodle" . To add
    an item to the end of an array, you should use the append(_:) method or += , as
    we covered in “[Adding Items to an Array](text00016.html#ch06lev2sec5) ” on [page
    70](text00016.html#page_70) .'
  id: totrans-6943
  prefs: []
  type: TYPE_NORMAL
  zh: '[图6-3](text00016.html#ch06fig3)显示了如果你尝试使用favoriteAnimals[3] = "标准贵宾犬"来添加“标准贵宾犬”时发生的错误。要将项添加到数组的末尾，应该使用append(_:)方法或+=，正如我们在“[向数组中添加项](text00016.html#ch06lev2sec5)”一节中介绍的那样，在[第70页](text00016.html#page_70)中有详细说明。'
- en: '![Image](Image00132.jpg)'
  id: totrans-6944
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00132.jpg)'
- en: '*Figure 6-3: Don’t try to replace a value at an index beyond the existing array.*'
  id: totrans-6945
  prefs: []
  type: TYPE_NORMAL
  zh: '*图6-3：不要尝试替换数组中不存在的索引处的值。*'
- en: Now you know how to change arrays however you might need to. You can add items,
    take items away, or replace items. Next, we’ll look at how to use the properties
    of arrays to find out even more information about them.
  id: totrans-6946
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你知道如何根据需要更改数组。你可以添加项，删除项或替换项。接下来，我们将看看如何使用数组的属性来获取更多关于它们的信息。
- en: '![Image](Image00133.jpg)'
  id: totrans-6947
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00133.jpg)'
- en: '**USING ARRAY PROPERTIES**'
  id: totrans-6948
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**使用数组属性**'
- en: In addition to methods like append(_:) and removeLast() , arrays also have *properties*
    . An array’s properties are variables or constants that contain some information
    about the array. Two really helpful properties that you might use are the Boolean
    property isEmpty and the integer property count .
  id: totrans-6949
  prefs: []
  type: TYPE_NORMAL
  zh: 除了像append(_:)和removeLast()这样的方法外，数组还有*属性*。数组的属性是包含关于数组的一些信息的变量或常量。你可能会用到的两个非常有用的属性是布尔型属性isEmpty和整数型属性count。
- en: The isEmpty property is true or false depending on whether the array is empty,
    and the count property will tell you how many items are in that array.
  id: totrans-6950
  prefs: []
  type: TYPE_NORMAL
  zh: isEmpty属性为真或假，取决于数组是否为空，而count属性将告诉你数组中有多少项。
- en: 'Check out how these two properties are used in the following if-else statement:'
  id: totrans-6951
  prefs: []
  type: TYPE_NORMAL
  zh: 查看下面这个if-else语句中如何使用这两个属性：
- en: '![Image](Image00134.jpg)'
  id: totrans-6952
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00134.jpg)'
- en: 'This if-else statement checks whether the array mySiblings is empty ➊ . If
    it is, then "I don''t have any siblings." is printed. But if there is something
    in the array, then the number of siblings that we have is printed: "I have 3 siblings."
    ➋ .'
  id: totrans-6953
  prefs: []
  type: TYPE_NORMAL
  zh: 这个if-else语句检查数组mySiblings是否为空➊。如果为空，则打印“我没有兄弟姐妹”。如果数组中有内容，则打印我们拥有的兄弟姐妹数量：“我有3个兄弟姐妹。”➋。
- en: '**LOOPING OVER AN ARRAY**'
  id: totrans-6954
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**遍历数组**'
- en: 'Sometimes when you’re working with arrays you might want to do something to
    every item in the array. You can use a for-in loop to do that! The following code
    will print every topping in a pizzaToppings array on a separate line:'
  id: totrans-6955
  prefs: []
  type: TYPE_NORMAL
  zh: 有时在操作数组时，你可能希望对数组中的每个项做点什么。你可以使用for-in循环来做到这一点！下面的代码将在每一行打印pizzaToppings数组中的每个配料：
- en: '![Image](Image00135.jpg)'
  id: totrans-6956
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00135.jpg)'
- en: To write a for-in loop for the pizzaToppings array, we used the keyword for
    , followed by the constant topping , then the keyword in , and finally the name
    of our array, pizzaToppings . Then we put the statements that we want to run for
    each topping inside the braces of the for-in loop. The constant topping ➊ temporarily
    represents each pizza topping in the array as we loop through it. We could have
    chosen any name for this constant, but it’s a good idea to pick something that
    makes sense. You can see the output of this for-in loop in [Figure 6-4](text00016.html#ch06fig4)
    .
  id: totrans-6957
  prefs: []
  type: TYPE_NORMAL
  zh: 要编写pizzaToppings数组的for-in循环，我们使用了关键字for，后跟常量topping，然后是关键字in，最后是数组名称pizzaToppings。接着，我们把要在每个配料上运行的语句放在for-in循环的大括号内。常量topping
    ➊在我们遍历数组时暂时表示数组中的每个披萨配料。我们本可以为这个常量选择任何名称，但选择一个有意义的名称是个好主意。你可以在[图6-4](text00016.html#ch06fig4)中看到这个for-in循环的输出。
- en: '![Image](Image00136.jpg)'
  id: totrans-6958
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00136.jpg)'
- en: '*Figure 6-4: Output of the example for-in loop*'
  id: totrans-6959
  prefs: []
  type: TYPE_NORMAL
  zh: '*图6-4：示例for-in循环的输出*'
- en: '![Image](Image00137.jpg)'
  id: totrans-6960
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00137.jpg)'
- en: 'Using for-in loops is great for printing every value in an array. If you’re
    working with numbers, you can even use them to perform math operations on each
    item, which makes for some speedy calculations! The following code takes an array
    of numbers and calculates the square for each (the square of a number is that
    number multiplied by itself):'
  id: totrans-6961
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 for-in 循环非常适合打印数组中的每个值。如果你正在处理数字，你甚至可以利用它们对每个元素执行数学运算，从而进行快速的计算！以下代码获取一个数字数组并计算每个数字的平方（数字的平方是该数字与自身相乘）：
- en: '![Image](Image00138.jpg)'
  id: totrans-6962
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Image00138.jpg)'
- en: '[Figure 6-5](text00016.html#ch06fig5) shows the results.'
  id: totrans-6963
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 6-5](text00016.html#ch06fig5) 显示了结果。'
- en: '![Image](Image00139.jpg)'
  id: totrans-6964
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Image00139.jpg)'
- en: '*Figure 6-5: Printing the squares for each number in the myNumbers array*'
  id: totrans-6965
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 6-5：打印 myNumbers 数组中每个数字的平方*'
- en: '**DICTIONARIES ARE KEY!**'
  id: totrans-6966
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**字典是关键！**'
- en: A *dictionary* is also a collection of values, but instead of an ordered index,
    each value has its own *key* . Because there’s no index, the values are not stored
    in any particular order. To access values in a dictionary, you look them up by
    their key.
  id: totrans-6967
  prefs: []
  type: TYPE_NORMAL
  zh: '*字典* 也是一个值的集合，但与数组不同的是，每个值都有自己的 *键*。由于没有索引，值并不是按任何特定顺序存储的。要访问字典中的值，你需要通过它们的键来查找。'
- en: A key must be unique. You can’t have the same key more than once in the same
    dictionary. If there were two identical keys and you asked the computer to give
    you the value for one of them, the computer wouldn’t know which one to choose!
  id: totrans-6968
  prefs: []
  type: TYPE_NORMAL
  zh: 键必须是唯一的。在同一个字典中，不能有相同的键。如果有两个相同的键，而你要求计算机返回其中一个值，计算机将无法知道选择哪个！
- en: Let’s take a look at how to make a dictionary and write keys that will help
    you find all the information you need.
  id: totrans-6969
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看一下如何创建一个字典并编写键，以帮助你找到所有所需的信息。
- en: '![Image](Image00140.jpg)'
  id: totrans-6970
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Image00140.jpg)'
- en: '**INITIALIZING A DICTIONARY**'
  id: totrans-6971
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**初始化字典**'
- en: 'To create and initialize a dictionary, first write var and the name of your
    dictionary. Then write the keys and corresponding values inside a pair of square
    brackets, similar to an array. Let’s create a dictionary to store the names of
    a few US states. The key for each state will be its two-letter abbreviation:'
  id: totrans-6972
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建并初始化一个字典，首先写上 var 和字典的名称。然后在一对方括号内写上键和值，就像数组一样。让我们创建一个字典，用来存储一些美国州的名字。每个州的键将是其两个字母的缩写：
- en: '![](Image00141.jpg)'
  id: totrans-6973
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00141.jpg)'
- en: As you can see, there’s a colon between each key and its value, and the key/value
    pairs are separated by commas.
  id: totrans-6974
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，每个键和值之间有一个冒号，键值对之间由逗号分隔。
- en: Dictionaries are different from arrays in that they are *unordered* . Because
    of that, it’s likely that the order of the states that you see in your results
    pane ➋ is different from the order in which you entered your states ➊ . It might
    even be different than the order that’s printed in this book!
  id: totrans-6975
  prefs: []
  type: TYPE_NORMAL
  zh: 字典与数组的不同之处在于它们是 *无序的*。因此，可能在你的结果面板中看到的州的顺序 ➋ 与你输入州的顺序 ➊ 不同，甚至可能与本书中打印的顺序不同！
- en: As with arrays, you can use var to make a mutable dictionary or use let to make
    an immutable dictionary.
  id: totrans-6976
  prefs: []
  type: TYPE_NORMAL
  zh: 与数组一样，你可以使用 var 来创建一个可变字典，或者使用 let 来创建一个不可变字典。
- en: 'In Swift, all of the keys of a dictionary must be the same type, and all of
    the values of a dictionary must also be the same type, but the key type doesn’t
    have to match the value type. For example, if you wanted to store a collection
    of fractions, you could use doubles for the keys and strings for the values:'
  id: totrans-6977
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Swift 中，字典的所有键必须是相同的类型，所有的值也必须是相同的类型，但键的类型不必与值的类型匹配。例如，如果你想存储一组分数，你可以使用双精度数（doubles）作为键，字符串作为值：
- en: '![](Image00142.jpg)'
  id: totrans-6978
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00142.jpg)'
- en: In this dictionary, all of the keys must be doubles, and all of the values must
    be strings. Again, you’ll see that the order of the numbers in the results pane
    can be quite different from the order in which you wrote the fractions in your
    dictionary. This is fine because you don’t need to know the order to access anything.
    You can find any item that you need by its key. Let’s see how!
  id: totrans-6979
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个字典中，所有的键必须是双精度数，而所有的值必须是字符串。再次提醒，结果面板中数字的顺序可能与你在字典中输入分数的顺序不同。这是可以接受的，因为你不需要知道顺序来访问任何内容。你可以通过键来找到任何你需要的项。让我们看看！
- en: '**ACCESSING VALUES IN A DICTIONARY**'
  id: totrans-6980
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**访问字典中的值**'
- en: 'Looking up a value in a dictionary is similar to how you access a value in
    an array except that you use a key inside the square brackets instead of an index,
    like this: usStates["TX"] .'
  id: totrans-6981
  prefs: []
  type: TYPE_NORMAL
  zh: 在字典中查找值的方式类似于在数组中访问值，不同之处在于你需要使用方括号中的键，而不是索引，像这样：`usStates["TX"]`。
- en: There is a big difference, however, in how Swift returns the values from a dictionary.
    When you access a value at an index of an array, you are simply given the value.
    When you access a value with a key in a dictionary, you are given an optional.
  id: totrans-6982
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，Swift 在从字典返回值时有一个很大的区别。当你访问数组的某个索引值时，你只会得到该值。当你通过字典中的键访问值时，你得到的是一个可选项。
- en: In [Chapter 5](text00015.html#ch05) , you learned that optionals might contain
    a value or might be nil . The reason Swift returns optionals when you’re looking
    up items in a dictionary is that the key you used might not exist in the dictionary,
    in which case there’s no value to access. Trying to access a value that doesn’t
    exist would give you a big fat error! To avoid that problem, Swift returns optionals.
    That means you need to unwrap any value you get out of a dictionary before you
    can do anything with it.
  id: totrans-6983
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第5章](text00015.html#ch05)中，你学到过可选项可能包含一个值，也可能是 `nil`。Swift 在查找字典中的项时返回可选项的原因是你使用的键可能在字典中不存在，在这种情况下没有值可供访问。尝试访问一个不存在的值会给你带来一个大错误！为了避免这个问题，Swift
    返回了可选项。这意味着在你对字典中的值进行任何操作之前，你需要解包它。
- en: 'To unwrap an optional, first you check whether it exists using an if-let statement,
    just like we did in [Chapter 5](text00015.html#ch05) . The following code shows
    you how to get a value out of a dictionary:'
  id: totrans-6984
  prefs: []
  type: TYPE_NORMAL
  zh: 要解包一个可选项，首先你需要通过 `if-let` 语句检查它是否存在，就像我们在[第5章](text00015.html#ch05)中所做的那样。以下代码展示了如何从字典中获取一个值：
- en: '![Image](Image00143.jpg)'
  id: totrans-6985
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00143.jpg)'
- en: To retrieve "Texas" from the dictionary, we use if let to set a constant loneStarState
    to usStates["TX"] ➊ . Because we have this state in our dictionary, the line I
    have Texas in my dictionary. is printed. Next we try to access a state that is
    not in our dictionary by using the key usStates["FL"] ➋ . Thankfully, because
    we used an if-let statement, the program won’t crash when the computer can’t find
    this state. Instead, I don't have that state in my dictionary. is printed.
  id: totrans-6986
  prefs: []
  type: TYPE_NORMAL
  zh: 要从字典中检索 "Texas"，我们使用 `if let` 将常量 `loneStarState` 设置为 `usStates["TX"]` ➊。因为我们在字典中有这个州，所以会打印
    "I have Texas in my dictionary."。接下来，我们尝试通过使用键 `usStates["FL"]` ➋ 访问一个不在字典中的州。幸运的是，由于我们使用了
    `if-let` 语句，当计算机找不到这个州时，程序不会崩溃。相反，会打印 "I don't have that state in my dictionary."。
- en: '**ADDING ITEMS TO A DICTIONARY**'
  id: totrans-6987
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**向字典中添加项**'
- en: 'To add an item to a dictionary, first write the name of your dictionary and
    assign the new item to the key you want it to have in the dictionary. Let’s add
    "Minnesota" to our usStates dictionary:'
  id: totrans-6988
  prefs: []
  type: TYPE_NORMAL
  zh: 向字典添加项，首先写下字典的名称，并将新项分配给你希望它拥有的键。让我们将 "Minnesota" 添加到我们的 `usStates` 字典中：
- en: '![](Image00144.jpg)'
  id: totrans-6989
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00144.jpg)'
- en: 'Now when you look at usStates , you’ll see that it’s updated to ["MN": "Minnesota",
    "WA": "Washington", "MA": "Massachusetts", "TX": "Texas"] . Remember, because
    you don’t have to rely on indices, your new dictionary item might appear anywhere
    in the dictionary.'
  id: totrans-6990
  prefs: []
  type: TYPE_NORMAL
  zh: '当你查看 `usStates` 时，你会发现它已经更新为["MN": "Minnesota", "WA": "Washington", "MA": "Massachusetts",
    "TX": "Texas"]。记住，由于你不需要依赖索引，新的字典项可能会出现在字典中的任何位置。'
- en: '**REMOVING ITEMS FROM A DICTIONARY**'
  id: totrans-6991
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**从字典中删除项**'
- en: Removing an item from a dictionary is quite simple; you do so by setting the
    value to nil . Because the values in dictionaries are returned as optionals, you
    don’t have to worry about nil causing any problems in your dictionary.
  id: totrans-6992
  prefs: []
  type: TYPE_NORMAL
  zh: 从字典中删除项非常简单；你只需将值设置为 `nil`。因为字典中的值是作为可选项返回的，所以你不需要担心 `nil` 会在字典中引发问题。
- en: '![](Image00145.jpg)'
  id: totrans-6993
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00145.jpg)'
- en: 'You can see that after you remove the value at the key "MA" , usStates is updated
    to ["MN": "Minnesota", "WA": "Washington", "TX": "Texas"] . Remember that nil
    is special and means that there’s no value at all. That’s why you don’t see "MA":
    nil in our dictionary.'
  id: totrans-6994
  prefs: []
  type: TYPE_NORMAL
  zh: '你可以看到，在删除键"MA"的值后，`usStates` 更新为["MN": "Minnesota", "WA": "Washington", "TX":
    "Texas"]。记住，`nil` 是特殊的，表示没有值。这就是为什么在我们的字典中看不到 "MA": nil 的原因。'
- en: '**REPLACING ITEMS IN A DICTIONARY**'
  id: totrans-6995
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**替换字典中的项**'
- en: 'Replacing an item in a dictionary is also easy. It works the same was as replacing
    an item in an array. You just set the item that you want to replace to something
    else. Say you create a dictionary of fruit colors:'
  id: totrans-6996
  prefs: []
  type: TYPE_NORMAL
  zh: 替换字典中的项也很简单。它的操作方式与替换数组中的项相同。你只需将你想替换的项设置为其他值。例如，你可以创建一个描述水果颜色的字典：
- en: '![](Image00146.jpg)'
  id: totrans-6997
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00146.jpg)'
- en: At first we had the value "apple" for "red" , but then we decided that "raspberry"
    is a better fruit to use since sometimes apples are green or yellow. To replace
    "apple" with "raspberry" , we set colorFruits["red"] to its new value ➊ .
  id: totrans-6998
  prefs: []
  type: TYPE_NORMAL
  zh: 最初我们为 "red" 设置了值 "apple"，但后来我们决定 "raspberry" 是更好的水果选择，因为有时候苹果是绿色或黄色的。为了用 "raspberry"
    替换 "apple"，我们将 colorFruits["red"] 设置为它的新值 ➊。
- en: You may remember that this is the same way we entered a new value into a dictionary.
    If the key already exists in the dictionary, then the value for that key is replaced.
    If the key doesn’t already exist, then the new key/value pair will be added to
    the dictionary.
  id: totrans-6999
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能记得，这与我们向字典中添加新值的方式是一样的。如果字典中已经存在该键，那么该键的值将被替换。如果字典中没有该键，则新的键值对将被添加到字典中。
- en: '![Image](Image00147.jpg)'
  id: totrans-7000
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00147.jpg)'
- en: '**USING DICTIONARY PROPERTIES**'
  id: totrans-7001
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**使用字典属性**'
- en: 'Like an array, a dictionary also has an isEmpty property and a count property.
    For example, the following code shows how you can use the isEmpty property to
    check if a dictionary is empty, and if it isn’t empty, the count property checks
    how many items you have. Imagine you have a basket of fruit for sale. You can
    use these properties to help you keep track of everything:'
  id: totrans-7002
  prefs: []
  type: TYPE_NORMAL
  zh: 类似于数组，字典也有 isEmpty 属性和 count 属性。例如，以下代码展示了如何使用 isEmpty 属性检查字典是否为空，如果不为空，count
    属性则用来检查字典中有多少项。假设你有一个水果篮子要出售。你可以使用这些属性帮助你跟踪所有内容：
- en: '![Image](Image00148.jpg)'
  id: totrans-7003
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00148.jpg)'
- en: 'A dictionary also has two special properties: keys , which contains all of
    the dictionary’s keys, and values , which contains all of its values. We’ll use
    these two properties when we loop through the dictionary.'
  id: totrans-7004
  prefs: []
  type: TYPE_NORMAL
  zh: 字典还有两个特殊属性：keys，它包含字典的所有键，和 values，它包含字典的所有值。我们将在遍历字典时使用这两个属性。
- en: Let’s write some code that loops through our fruit baskets and prints the price
    of each fruit.
  id: totrans-7005
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们编写一些代码，遍历我们的水果篮子并打印每种水果的价格。
- en: '**LOOPING OVER A DICTIONARY**'
  id: totrans-7006
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**遍历字典**'
- en: 'You can loop through a dictionary using a for-in loop. Because each item has
    a key and a value, you can do this in two different ways. This is how to loop
    through a dictionary using its keys:'
  id: totrans-7007
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用 for-in 循环遍历字典。由于每个项目都有一个键和值，因此你可以用两种不同的方式进行循环。这是使用键遍历字典的方法：
- en: '![Image](Image00149.jpg)'
  id: totrans-7008
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00149.jpg)'
- en: Here we use the dictionary’s keys property ➊ to loop through fruitBasket and
    print its contents. We start by writing the keyword for , followed by a constant
    name fruit for the dictionary key, the keyword in , the dictionary name, a period,
    and keys .
  id: totrans-7009
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们使用字典的 keys 属性 ➊ 来循环遍历 fruitBasket 并打印其内容。我们首先编写关键字 for，然后是字典键的常量名称 fruit，关键字
    in，字典名称，一个句点，最后是 keys。
- en: Inside the braces of our for-in loop, we have access to both the key, which
    we call fruit ➋ , and the value at that key when we force-unwrap its contents
    with fruitBasket[fruit]! ➌ . That value will be the fruit’s price.
  id: totrans-7010
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的 for-in 循环的花括号内，我们可以访问到键（我们称之为 fruit ➋），以及通过强制解包其内容的 fruitBasket[fruit]!
    ➌ 来获取该键对应的值。该值将是水果的价格。
- en: In this case, it’s safe to force-unwrap the value using an exclamation point
    because we know that the fruit key we’re using is definitely inside the dictionary.
  id: totrans-7011
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，使用感叹号强制解包值是安全的，因为我们知道所使用的水果键一定在字典中。
- en: Any code we put inside the for-in loop will run once for every key in our dictionary.
    So you should see the print statement display three times.
  id: totrans-7012
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在 for-in 循环内放置的任何代码都将针对字典中的每个键执行一次。所以你应该看到打印语句显示了三次。
- en: 'We can also loop through the dictionary using its values property:'
  id: totrans-7013
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以使用字典的 values 属性来循环遍历字典：
- en: '![Image](Image00150.jpg)'
  id: totrans-7014
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00150.jpg)'
- en: We use the same style of for-in loop, but now we use a constant to refer to
    each value, which we call price , in the values property. When looping through
    values, we don’t have access to the keys from inside the loop.
  id: totrans-7015
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用相同风格的 for-in 循环，但这次我们使用一个常量来引用 values 属性中的每个值，我们称其为 price。在遍历 values 时，我们无法从循环内访问到键。
- en: Another difference to note is that price is not an optional because it’s accessed
    directly as a value in the fruitBasket dictionary. That means we don’t have to
    unwrap it. You should still see the print statement printed three times. [Figure
    6-6](text00016.html#ch06fig6) shows the output of both loops.
  id: totrans-7016
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个需要注意的区别是，价格不是一个可选值，因为它是直接作为字典中 fruitBasket 的值访问的。这意味着我们不需要解包它。你仍然应该能看到打印语句打印了三次。[图
    6-6](text00016.html#ch06fig6) 显示了两个循环的输出。
- en: '![Image](Image00151.jpg)'
  id: totrans-7017
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00151.jpg)'
- en: '*Figure 6-6: Looping through the keys and values of a dictionary with a for-in
    loop*'
  id: totrans-7018
  prefs: []
  type: TYPE_NORMAL
  zh: '*图6-6：使用 for-in 循环遍历字典的键和值*'
- en: The order of your results might be slightly different from ours. That’s because
    the items in a dictionary aren’t in a numbered order like they are in an array!
    And because the order is not guaranteed, you might see a different order printed
    if you run the same code again.
  id: totrans-7019
  prefs: []
  type: TYPE_NORMAL
  zh: 你的结果顺序可能与我们的略有不同。那是因为字典中的项目不像数组那样按数字顺序排列！并且因为顺序不保证，你可能会看到不同的顺序，如果再次运行相同的代码。
- en: '**WHAT YOU LEARNED**'
  id: totrans-7020
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**你学到的内容**'
- en: In this chapter, you learned how to store collections of items in an array and
    in a dictionary. To store items in an ordered list, you would use an array and
    look up each item by its index. If you wanted to store items by key instead, you
    would use a dictionary.
  id: totrans-7021
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你学习了如何在数组和字典中存储项目。为了将项目存储在有序列表中，你会使用数组，并通过索引查找每个项目。如果你想通过键来存储项目，你则会使用字典。
- en: Knowing about arrays and dictionaries and how to use them is a powerful building
    block for almost any programming language. Next we will learn about functions,
    another very powerful tool. Functions are blocks of code that you create and name
    to perform a specific job. After you have written a function, you can use its
    name to call it from almost anywhere in your program.
  id: totrans-7022
  prefs: []
  type: TYPE_NORMAL
  zh: 了解数组和字典以及如何使用它们是几乎所有编程语言中一个强大的构建模块。接下来我们将学习函数，另一个非常强大的工具。函数是你创建并命名的一段代码，用于执行特定的任务。在你写完一个函数后，你可以通过它的名字在程序中的几乎任何地方调用它。
- en: 'You can also remove all items from an array with removeAll() . Try entering
    this into your playground:'
  id: totrans-7023
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以使用 removeAll() 从数组中移除所有项目。试着在你的 playground 中输入这个：
- en: '![](Image00129.jpg)'
  id: totrans-7024
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00129.jpg)'
- en: 'Note that trying to remove an item at an index that doesn’t exist will give
    you an error:'
  id: totrans-7025
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，尝试在一个不存在的索引位置移除项目会导致错误：
- en: '![](Image00130.jpg)'
  id: totrans-7026
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00130.jpg)'
- en: Our array doesn’t have this many items (in fact, now it’s empty!), so this throws
    an error. We’ll also get an error if we use removeLast() on our empty array, because
    there’s nothing in it—there’s no last index at all! However, removeAll() is always
    safe to use, even on an empty array.
  id: totrans-7027
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的数组没有这么多项目（事实上，现在它是空的！），所以这会抛出一个错误。如果我们对空数组使用 removeLast() ，也会得到错误，因为数组中没有任何内容——根本没有最后一个索引！不过，removeAll()
    即使在空数组上也始终安全使用。
- en: '**REPLACING ITEMS IN AN ARRAY**'
  id: totrans-7028
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**替换数组中的项目**'
- en: 'To replace an item in an array, you set the index of the array to the new value,
    as shown here:'
  id: totrans-7029
  prefs: []
  type: TYPE_NORMAL
  zh: 要替换数组中的一个项目，你只需将数组的索引设置为新值，如下所示：
- en: '![](Image00131.jpg)'
  id: totrans-7030
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00131.jpg)'
- en: At ➊ , we replaced the item at index 2 (the third item) with "Unicorn" because
    magical animals count as favorite animals, too! At ➋ , we replaced the item at
    index 0 (the first item) with "Bearded dragon" . No, that’s not a real dragon—it’s
    just a lizard!
  id: totrans-7031
  prefs: []
  type: TYPE_NORMAL
  zh: 在 ➊ 处，我们将索引 2（第三个项目）处的项目替换为 "独角兽"，因为魔法动物也算是最喜欢的动物！在 ➋ 处，我们将索引 0（第一个项目）处的项目替换为
    "胡须龙"。不，这不是一条真正的龙——它只是一只蜥蜴！
- en: Like any time you’re working with array index numbers, you have to be sure an
    item exists in the array at that index before you change its value, or you will
    get an Index out of range error.
  id: totrans-7032
  prefs: []
  type: TYPE_NORMAL
  zh: 就像每次你在处理数组索引时一样，你必须确保在该索引位置存在某个项目，否则会得到“索引超出范围”错误。
- en: '[Figure 6-3](text00016.html#ch06fig3) shows the error that occurs if you try
    to add "Standard poodle" using favoriteAnimals[3] = "Standard poodle" . To add
    an item to the end of an array, you should use the append(_:) method or += , as
    we covered in “[Adding Items to an Array](text00016.html#ch06lev2sec5) ” on [page
    70](text00016.html#page_70) .'
  id: totrans-7033
  prefs: []
  type: TYPE_NORMAL
  zh: '[图6-3](text00016.html#ch06fig3) 显示了如果你尝试通过 favoriteAnimals[3] = "Standard poodle"
    来添加 "标准贵宾犬" 时会发生的错误。要将项目添加到数组的末尾，应该使用 append(_:) 方法或 += ，正如我们在 “[向数组添加项目](text00016.html#ch06lev2sec5)”
    中第 [70页](text00016.html#page_70) 所讲的那样。'
- en: '![Image](Image00132.jpg)'
  id: totrans-7034
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00132.jpg)'
- en: '*Figure 6-3: Don’t try to replace a value at an index beyond the existing array.*'
  id: totrans-7035
  prefs: []
  type: TYPE_NORMAL
  zh: '*图6-3：不要尝试在超出现有数组范围的索引位置替换值。*'
- en: Now you know how to change arrays however you might need to. You can add items,
    take items away, or replace items. Next, we’ll look at how to use the properties
    of arrays to find out even more information about them.
  id: totrans-7036
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你知道如何根据需要更改数组了。你可以添加项目、移除项目或替换项目。接下来，我们将了解如何使用数组的属性来获取更多信息。
- en: '![Image](Image00133.jpg)'
  id: totrans-7037
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00133.jpg)'
- en: '**USING ARRAY PROPERTIES**'
  id: totrans-7038
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**使用数组属性**'
- en: In addition to methods like append(_:) and removeLast() , arrays also have *properties*
    . An array’s properties are variables or constants that contain some information
    about the array. Two really helpful properties that you might use are the Boolean
    property isEmpty and the integer property count .
  id: totrans-7039
  prefs: []
  type: TYPE_NORMAL
  zh: 除了像append(_:)和removeLast()这样的函数，数组还有*属性*。数组的属性是包含数组信息的变量或常量。你可能会使用的两个非常有用的属性是布尔类型的isEmpty属性和整数类型的count属性。
- en: The isEmpty property is true or false depending on whether the array is empty,
    and the count property will tell you how many items are in that array.
  id: totrans-7040
  prefs: []
  type: TYPE_NORMAL
  zh: isEmpty属性根据数组是否为空返回true或false，而count属性则会告诉你数组中有多少项。
- en: 'Check out how these two properties are used in the following if-else statement:'
  id: totrans-7041
  prefs: []
  type: TYPE_NORMAL
  zh: 请查看以下if-else语句中这两个属性是如何使用的：
- en: '![Image](Image00134.jpg)'
  id: totrans-7042
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00134.jpg)'
- en: 'This if-else statement checks whether the array mySiblings is empty ➊ . If
    it is, then "I don''t have any siblings." is printed. But if there is something
    in the array, then the number of siblings that we have is printed: "I have 3 siblings."
    ➋ .'
  id: totrans-7043
  prefs: []
  type: TYPE_NORMAL
  zh: 这个if-else语句检查数组mySiblings是否为空 ➊。如果为空，那么打印出“我没有兄弟姐妹。”。但如果数组中有内容，则打印出我们有多少兄弟姐妹：“我有3个兄弟姐妹。”
    ➋。
- en: '**LOOPING OVER AN ARRAY**'
  id: totrans-7044
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**遍历数组**'
- en: 'Sometimes when you’re working with arrays you might want to do something to
    every item in the array. You can use a for-in loop to do that! The following code
    will print every topping in a pizzaToppings array on a separate line:'
  id: totrans-7045
  prefs: []
  type: TYPE_NORMAL
  zh: 有时在处理数组时，你可能想对数组中的每个项做一些操作。你可以使用for-in循环来做到这一点！以下代码将打印pizzaToppings数组中的每个配料，每个配料都在单独的一行显示：
- en: '![Image](Image00135.jpg)'
  id: totrans-7046
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00135.jpg)'
- en: To write a for-in loop for the pizzaToppings array, we used the keyword for
    , followed by the constant topping , then the keyword in , and finally the name
    of our array, pizzaToppings . Then we put the statements that we want to run for
    each topping inside the braces of the for-in loop. The constant topping ➊ temporarily
    represents each pizza topping in the array as we loop through it. We could have
    chosen any name for this constant, but it’s a good idea to pick something that
    makes sense. You can see the output of this for-in loop in [Figure 6-4](text00016.html#ch06fig4)
    .
  id: totrans-7047
  prefs: []
  type: TYPE_NORMAL
  zh: 为了写一个针对pizzaToppings数组的for-in循环，我们使用了关键字for，接着是常量topping，然后是关键字in，最后是数组的名称pizzaToppings。接着我们将希望在每个topping上执行的语句放在for-in循环的大括号内。常量topping
    ➊ 在我们循环数组时，暂时代表数组中的每个披萨配料。我们本可以为这个常量选择任何名称，但最好选择一个有意义的名字。你可以在[图6-4](text00016.html#ch06fig4)中看到这个for-in循环的输出。
- en: '![Image](Image00136.jpg)'
  id: totrans-7048
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00136.jpg)'
- en: '*Figure 6-4: Output of the example for-in loop*'
  id: totrans-7049
  prefs: []
  type: TYPE_NORMAL
  zh: '*图6-4：示例for-in循环的输出*'
- en: '![Image](Image00137.jpg)'
  id: totrans-7050
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00137.jpg)'
- en: 'Using for-in loops is great for printing every value in an array. If you’re
    working with numbers, you can even use them to perform math operations on each
    item, which makes for some speedy calculations! The following code takes an array
    of numbers and calculates the square for each (the square of a number is that
    number multiplied by itself):'
  id: totrans-7051
  prefs: []
  type: TYPE_NORMAL
  zh: 使用for-in循环非常适合打印数组中的每个值。如果你在处理数字，你甚至可以用它们对每个项进行数学运算，这样就能进行快速的计算！以下代码接收一个数字数组，并计算每个数字的平方（一个数字的平方是该数字乘以它本身）：
- en: '![Image](Image00138.jpg)'
  id: totrans-7052
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00138.jpg)'
- en: '[Figure 6-5](text00016.html#ch06fig5) shows the results.'
  id: totrans-7053
  prefs: []
  type: TYPE_NORMAL
  zh: '[图6-5](text00016.html#ch06fig5)显示了结果。'
- en: '![Image](Image00139.jpg)'
  id: totrans-7054
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00139.jpg)'
- en: '*Figure 6-5: Printing the squares for each number in the myNumbers array*'
  id: totrans-7055
  prefs: []
  type: TYPE_NORMAL
  zh: '*图6-5：打印myNumbers数组中每个数字的平方*'
- en: '**DICTIONARIES ARE KEY!**'
  id: totrans-7056
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**字典是关键！**'
- en: A *dictionary* is also a collection of values, but instead of an ordered index,
    each value has its own *key* . Because there’s no index, the values are not stored
    in any particular order. To access values in a dictionary, you look them up by
    their key.
  id: totrans-7057
  prefs: []
  type: TYPE_NORMAL
  zh: '*字典*也是一种值的集合，但不同于有序索引的是，每个值都有自己的*键*。由于没有索引，值不会按照特定的顺序存储。要访问字典中的值，你需要通过它们的键来查找。'
- en: A key must be unique. You can’t have the same key more than once in the same
    dictionary. If there were two identical keys and you asked the computer to give
    you the value for one of them, the computer wouldn’t know which one to choose!
  id: totrans-7058
  prefs: []
  type: TYPE_NORMAL
  zh: 键必须是唯一的。你不能在同一个字典中有两个相同的键。如果有两个相同的键，并且你要求计算机给你其中一个键的值，计算机就无法知道该选择哪个！
- en: Let’s take a look at how to make a dictionary and write keys that will help
    you find all the information you need.
  id: totrans-7059
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看如何创建一个字典，并编写键来帮助你查找所有需要的信息。
- en: '![Image](Image00140.jpg)'
  id: totrans-7060
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00140.jpg)'
- en: '**INITIALIZING A DICTIONARY**'
  id: totrans-7061
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**初始化字典**'
- en: 'To create and initialize a dictionary, first write var and the name of your
    dictionary. Then write the keys and corresponding values inside a pair of square
    brackets, similar to an array. Let’s create a dictionary to store the names of
    a few US states. The key for each state will be its two-letter abbreviation:'
  id: totrans-7062
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建并初始化一个字典，首先写上 `var` 和字典的名称。然后将键及对应的值放入一对方括号中，类似于数组。我们来创建一个字典来存储一些美国州的名字。每个州的键将是其两字母缩写：
- en: '![](Image00141.jpg)'
  id: totrans-7063
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00141.jpg)'
- en: As you can see, there’s a colon between each key and its value, and the key/value
    pairs are separated by commas.
  id: totrans-7064
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，每个键和值之间有一个冒号，键值对之间用逗号分隔。
- en: Dictionaries are different from arrays in that they are *unordered* . Because
    of that, it’s likely that the order of the states that you see in your results
    pane ➋ is different from the order in which you entered your states ➊ . It might
    even be different than the order that’s printed in this book!
  id: totrans-7065
  prefs: []
  type: TYPE_NORMAL
  zh: 字典与数组不同，因为字典是*无序的*。因此，你在结果面板➋中看到的州的顺序很可能与输入州的顺序➊不同，甚至可能与本书中打印的顺序也不同！
- en: As with arrays, you can use var to make a mutable dictionary or use let to make
    an immutable dictionary.
  id: totrans-7066
  prefs: []
  type: TYPE_NORMAL
  zh: 与数组一样，你可以使用 `var` 来创建一个可变字典，或使用 `let` 来创建一个不可变字典。
- en: 'In Swift, all of the keys of a dictionary must be the same type, and all of
    the values of a dictionary must also be the same type, but the key type doesn’t
    have to match the value type. For example, if you wanted to store a collection
    of fractions, you could use doubles for the keys and strings for the values:'
  id: totrans-7067
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Swift 中，字典的所有键必须是相同的类型，字典的所有值也必须是相同的类型，但键的类型不必与值的类型相匹配。例如，如果你想存储一组分数，你可以使用
    `double` 类型作为键，`string` 类型作为值：
- en: '![](Image00142.jpg)'
  id: totrans-7068
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00142.jpg)'
- en: In this dictionary, all of the keys must be doubles, and all of the values must
    be strings. Again, you’ll see that the order of the numbers in the results pane
    can be quite different from the order in which you wrote the fractions in your
    dictionary. This is fine because you don’t need to know the order to access anything.
    You can find any item that you need by its key. Let’s see how!
  id: totrans-7069
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个字典中，所有的键必须是 `double` 类型，所有的值必须是 `string` 类型。再次提醒你，结果面板中的数字顺序可能与你在字典中写入分数的顺序非常不同。这没关系，因为你不需要知道顺序就能访问任何内容。你可以通过键找到任何你需要的项目。让我们来看一下！
- en: '**ACCESSING VALUES IN A DICTIONARY**'
  id: totrans-7070
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**访问字典中的值**'
- en: 'Looking up a value in a dictionary is similar to how you access a value in
    an array except that you use a key inside the square brackets instead of an index,
    like this: usStates["TX"] .'
  id: totrans-7071
  prefs: []
  type: TYPE_NORMAL
  zh: 在字典中查找一个值类似于如何在数组中访问值，只不过你需要在方括号内使用一个键，而不是索引，像这样：usStates["TX"]。
- en: There is a big difference, however, in how Swift returns the values from a dictionary.
    When you access a value at an index of an array, you are simply given the value.
    When you access a value with a key in a dictionary, you are given an optional.
  id: totrans-7072
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在 Swift 中，从字典中返回值的方式与访问数组中的值有很大不同。当你访问数组中某个索引的值时，你直接获得该值。而当你通过键访问字典中的值时，你得到的是一个可选值。
- en: In [Chapter 5](text00015.html#ch05) , you learned that optionals might contain
    a value or might be nil . The reason Swift returns optionals when you’re looking
    up items in a dictionary is that the key you used might not exist in the dictionary,
    in which case there’s no value to access. Trying to access a value that doesn’t
    exist would give you a big fat error! To avoid that problem, Swift returns optionals.
    That means you need to unwrap any value you get out of a dictionary before you
    can do anything with it.
  id: totrans-7073
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第5章](text00015.html#ch05)中，你学到过可选值可能包含一个值，也可能是 `nil`。Swift 返回可选值的原因是，当你在字典中查找项目时，你使用的键可能在字典中不存在，在这种情况下没有值可以访问。尝试访问一个不存在的值会给你带来一个大大的错误！为避免这个问题，Swift
    返回了可选值。这意味着，在你做任何操作之前，你需要解包从字典中获取的任何值。
- en: 'To unwrap an optional, first you check whether it exists using an if-let statement,
    just like we did in [Chapter 5](text00015.html#ch05) . The following code shows
    you how to get a value out of a dictionary:'
  id: totrans-7074
  prefs: []
  type: TYPE_NORMAL
  zh: 要解包一个可选值，首先你需要用 `if-let` 语句检查它是否存在，就像我们在[第5章](text00015.html#ch05)中做的那样。以下代码展示了如何从字典中获取一个值：
- en: '![Image](Image00143.jpg)'
  id: totrans-7075
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Image00143.jpg)'
- en: To retrieve "Texas" from the dictionary, we use if let to set a constant loneStarState
    to usStates["TX"] ➊ . Because we have this state in our dictionary, the line I
    have Texas in my dictionary. is printed. Next we try to access a state that is
    not in our dictionary by using the key usStates["FL"] ➋ . Thankfully, because
    we used an if-let statement, the program won’t crash when the computer can’t find
    this state. Instead, I don't have that state in my dictionary. is printed.
  id: totrans-7076
  prefs: []
  type: TYPE_NORMAL
  zh: 要从字典中检索 "Texas"，我们使用 if let 语句将常量 loneStarState 设置为 usStates["TX"] ➊ 。因为我们在字典中有这个州，所以会打印出
    "I have Texas in my dictionary." 接下来，我们尝试通过使用键 usStates["FL"] ➋ 来访问一个不在字典中的州。幸运的是，由于我们使用了
    if-let 语句，当计算机找不到这个州时，程序不会崩溃。相反，会打印出 "I don't have that state in my dictionary."。
- en: '**ADDING ITEMS TO A DICTIONARY**'
  id: totrans-7077
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**向字典中添加项目**'
- en: 'To add an item to a dictionary, first write the name of your dictionary and
    assign the new item to the key you want it to have in the dictionary. Let’s add
    "Minnesota" to our usStates dictionary:'
  id: totrans-7078
  prefs: []
  type: TYPE_NORMAL
  zh: 要向字典中添加一个项目，首先写下字典的名称，并将新项目分配给字典中你想要的键。我们来向 usStates 字典中添加 "Minnesota"：
- en: '![](Image00144.jpg)'
  id: totrans-7079
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00144.jpg)'
- en: 'Now when you look at usStates , you’ll see that it’s updated to ["MN": "Minnesota",
    "WA": "Washington", "MA": "Massachusetts", "TX": "Texas"] . Remember, because
    you don’t have to rely on indices, your new dictionary item might appear anywhere
    in the dictionary.'
  id: totrans-7080
  prefs: []
  type: TYPE_NORMAL
  zh: '现在当你查看 usStates 时，你会看到它已经更新为 ["MN": "Minnesota", "WA": "Washington", "MA":
    "Massachusetts", "TX": "Texas"]。记住，由于你不需要依赖索引，你的新字典项目可能出现在字典中的任何位置。'
- en: '**REMOVING ITEMS FROM A DICTIONARY**'
  id: totrans-7081
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**从字典中移除项目**'
- en: Removing an item from a dictionary is quite simple; you do so by setting the
    value to nil . Because the values in dictionaries are returned as optionals, you
    don’t have to worry about nil causing any problems in your dictionary.
  id: totrans-7082
  prefs: []
  type: TYPE_NORMAL
  zh: 从字典中移除项目非常简单；你只需将值设置为 nil。由于字典中的值是作为可选项返回的，你不必担心 nil 会在字典中引发任何问题。
- en: '![](Image00145.jpg)'
  id: totrans-7083
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00145.jpg)'
- en: 'You can see that after you remove the value at the key "MA" , usStates is updated
    to ["MN": "Minnesota", "WA": "Washington", "TX": "Texas"] . Remember that nil
    is special and means that there’s no value at all. That’s why you don’t see "MA":
    nil in our dictionary.'
  id: totrans-7084
  prefs: []
  type: TYPE_NORMAL
  zh: '你可以看到，在你移除键为 "MA" 的值后，usStates 已更新为 ["MN": "Minnesota", "WA": "Washington",
    "TX": "Texas"]。记住，nil 是特殊的，表示根本没有值。这就是为什么你在字典中看不到 "MA": nil 的原因。'
- en: '**REPLACING ITEMS IN A DICTIONARY**'
  id: totrans-7085
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**替换字典中的项目**'
- en: 'Replacing an item in a dictionary is also easy. It works the same was as replacing
    an item in an array. You just set the item that you want to replace to something
    else. Say you create a dictionary of fruit colors:'
  id: totrans-7086
  prefs: []
  type: TYPE_NORMAL
  zh: 替换字典中的项目也很简单。它的工作原理与替换数组中的项目相同。你只需将要替换的项目设置为其他值。假设你创建了一个水果颜色的字典：
- en: '![](Image00146.jpg)'
  id: totrans-7087
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00146.jpg)'
- en: At first we had the value "apple" for "red" , but then we decided that "raspberry"
    is a better fruit to use since sometimes apples are green or yellow. To replace
    "apple" with "raspberry" , we set colorFruits["red"] to its new value ➊ .
  id: totrans-7088
  prefs: []
  type: TYPE_NORMAL
  zh: 一开始我们给 "red" 配置了值 "apple"，但后来我们决定使用 "raspberry" 作为更合适的水果，因为有时苹果是绿色或黄色的。为了将 "apple"
    替换为 "raspberry"，我们将 colorFruits["red"] 设置为其新值 ➊ 。
- en: You may remember that this is the same way we entered a new value into a dictionary.
    If the key already exists in the dictionary, then the value for that key is replaced.
    If the key doesn’t already exist, then the new key/value pair will be added to
    the dictionary.
  id: totrans-7089
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能记得，这与我们向字典中添加新值的方法相同。如果该键已经存在于字典中，那么该键的值会被替换。如果该键不存在，则新的键/值对将被添加到字典中。
- en: '![Image](Image00147.jpg)'
  id: totrans-7090
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00147.jpg)'
- en: '**USING DICTIONARY PROPERTIES**'
  id: totrans-7091
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**使用字典属性**'
- en: 'Like an array, a dictionary also has an isEmpty property and a count property.
    For example, the following code shows how you can use the isEmpty property to
    check if a dictionary is empty, and if it isn’t empty, the count property checks
    how many items you have. Imagine you have a basket of fruit for sale. You can
    use these properties to help you keep track of everything:'
  id: totrans-7092
  prefs: []
  type: TYPE_NORMAL
  zh: 像数组一样，字典也有 isEmpty 属性和 count 属性。例如，以下代码展示了如何使用 isEmpty 属性检查字典是否为空，如果不为空，count
    属性会检查字典中有多少项。假设你有一篮子待售的水果，你可以使用这些属性帮助你跟踪所有内容：
- en: '![Image](Image00148.jpg)'
  id: totrans-7093
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00148.jpg)'
- en: 'A dictionary also has two special properties: keys , which contains all of
    the dictionary’s keys, and values , which contains all of its values. We’ll use
    these two properties when we loop through the dictionary.'
  id: totrans-7094
  prefs: []
  type: TYPE_NORMAL
  zh: 字典还有两个特殊属性：keys，它包含字典的所有键；values，它包含字典的所有值。我们将在遍历字典时使用这两个属性。
- en: Let’s write some code that loops through our fruit baskets and prints the price
    of each fruit.
  id: totrans-7095
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们写一些代码，遍历我们的水果篮并打印每个水果的价格。
- en: '**LOOPING OVER A DICTIONARY**'
  id: totrans-7096
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**遍历字典**'
- en: 'You can loop through a dictionary using a for-in loop. Because each item has
    a key and a value, you can do this in two different ways. This is how to loop
    through a dictionary using its keys:'
  id: totrans-7097
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用 for-in 循环遍历字典。因为每个项目都有一个键和值，所以你可以通过两种不同的方式进行遍历。这是通过字典的键进行遍历的方法：
- en: '![Image](Image00149.jpg)'
  id: totrans-7098
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00149.jpg)'
- en: Here we use the dictionary’s keys property ➊ to loop through fruitBasket and
    print its contents. We start by writing the keyword for , followed by a constant
    name fruit for the dictionary key, the keyword in , the dictionary name, a period,
    and keys .
  id: totrans-7099
  prefs: []
  type: TYPE_NORMAL
  zh: 这里我们使用字典的 keys 属性 ➊ 来遍历 fruitBasket，并打印其内容。我们首先写下关键字 for，接着是常量名称 fruit（用于字典键），关键字
    in，字典名称，一个句点，以及 keys。
- en: Inside the braces of our for-in loop, we have access to both the key, which
    we call fruit ➋ , and the value at that key when we force-unwrap its contents
    with fruitBasket[fruit]! ➌ . That value will be the fruit’s price.
  id: totrans-7100
  prefs: []
  type: TYPE_NORMAL
  zh: 在 for-in 循环的花括号内，我们可以访问键（我们称之为 fruit ➋）以及通过 fruitBasket[fruit]! ➌ 强制解包获取的该键的值。该值将是水果的价格。
- en: In this case, it’s safe to force-unwrap the value using an exclamation point
    because we know that the fruit key we’re using is definitely inside the dictionary.
  id: totrans-7101
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，强制解包值时使用感叹号是安全的，因为我们知道正在使用的水果键肯定存在于字典中。
- en: Any code we put inside the for-in loop will run once for every key in our dictionary.
    So you should see the print statement display three times.
  id: totrans-7102
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在 for-in 循环中放入的任何代码都会针对字典中的每个键执行一次。因此，你应该看到打印语句会显示三次。
- en: 'We can also loop through the dictionary using its values property:'
  id: totrans-7103
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以通过字典的 values 属性进行遍历：
- en: '![Image](Image00150.jpg)'
  id: totrans-7104
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00150.jpg)'
- en: We use the same style of for-in loop, but now we use a constant to refer to
    each value, which we call price , in the values property. When looping through
    values, we don’t have access to the keys from inside the loop.
  id: totrans-7105
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用相同的 for-in 循环方式，但现在我们使用常量来引用每个值，我们将其称为 price，位于 values 属性中。在遍历值时，我们无法从循环内部访问键。
- en: Another difference to note is that price is not an optional because it’s accessed
    directly as a value in the fruitBasket dictionary. That means we don’t have to
    unwrap it. You should still see the print statement printed three times. [Figure
    6-6](text00016.html#ch06fig6) shows the output of both loops.
  id: totrans-7106
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个值得注意的区别是，price 不是一个可选值，因为它是通过直接在 fruitBasket 字典中访问而获取的。这意味着我们不需要解包它。你仍然应该看到打印语句会打印三次。[图
    6-6](text00016.html#ch06fig6) 显示了两个循环的输出结果。
- en: '![Image](Image00151.jpg)'
  id: totrans-7107
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00151.jpg)'
- en: '*Figure 6-6: Looping through the keys and values of a dictionary with a for-in
    loop*'
  id: totrans-7108
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 6-6：使用 for-in 循环遍历字典的键和值*'
- en: The order of your results might be slightly different from ours. That’s because
    the items in a dictionary aren’t in a numbered order like they are in an array!
    And because the order is not guaranteed, you might see a different order printed
    if you run the same code again.
  id: totrans-7109
  prefs: []
  type: TYPE_NORMAL
  zh: 你的结果顺序可能与我们的稍有不同。这是因为字典中的项目不像数组中的项目那样按编号顺序排列！并且因为顺序无法保证，你可能会在再次运行相同代码时看到不同的顺序。
- en: '**WHAT YOU LEARNED**'
  id: totrans-7110
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**你学到了什么**'
- en: In this chapter, you learned how to store collections of items in an array and
    in a dictionary. To store items in an ordered list, you would use an array and
    look up each item by its index. If you wanted to store items by key instead, you
    would use a dictionary.
  id: totrans-7111
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你学习了如何将项目集合存储在数组和字典中。要将项目存储在有序列表中，你将使用数组，并通过索引查找每个项目。如果你想按键存储项目，你则需要使用字典。
- en: Knowing about arrays and dictionaries and how to use them is a powerful building
    block for almost any programming language. Next we will learn about functions,
    another very powerful tool. Functions are blocks of code that you create and name
    to perform a specific job. After you have written a function, you can use its
    name to call it from almost anywhere in your program.
  id: totrans-7112
  prefs: []
  type: TYPE_NORMAL
  zh: 了解数组和字典以及如何使用它们，是几乎所有编程语言中强大的构建模块。接下来，我们将学习函数，另一个非常强大的工具。函数是你创建并命名的代码块，用于执行特定的任务。编写完函数后，你可以通过它的名称在程序中的几乎任何地方调用它。
- en: '![](Image00129.jpg)'
  id: totrans-7113
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00129.jpg)'
- en: 'Note that trying to remove an item at an index that doesn’t exist will give
    you an error:'
  id: totrans-7114
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，尝试删除一个不存在的索引处的项目将导致错误：
- en: '![](Image00130.jpg)'
  id: totrans-7115
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00130.jpg)'
- en: Our array doesn’t have this many items (in fact, now it’s empty!), so this throws
    an error. We’ll also get an error if we use removeLast() on our empty array, because
    there’s nothing in it—there’s no last index at all! However, removeAll() is always
    safe to use, even on an empty array.
  id: totrans-7116
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的数组没有这么多的元素（事实上，它现在是空的！），所以这会抛出一个错误。如果我们在空数组上使用removeLast()，也会出现错误，因为数组里没有任何东西——根本没有最后一个索引！然而，removeAll()总是安全可用的，即使是在空数组上。
- en: '**REPLACING ITEMS IN AN ARRAY**'
  id: totrans-7117
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**替换数组中的元素**'
- en: 'To replace an item in an array, you set the index of the array to the new value,
    as shown here:'
  id: totrans-7118
  prefs: []
  type: TYPE_NORMAL
  zh: 要替换数组中的元素，你只需要将数组的索引设置为新的值，如下所示：
- en: '![](Image00131.jpg)'
  id: totrans-7119
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00131.jpg)'
- en: At ➊ , we replaced the item at index 2 (the third item) with "Unicorn" because
    magical animals count as favorite animals, too! At ➋ , we replaced the item at
    index 0 (the first item) with "Bearded dragon" . No, that’s not a real dragon—it’s
    just a lizard!
  id: totrans-7120
  prefs: []
  type: TYPE_NORMAL
  zh: 在➊处，我们将索引为2（第三项）的元素替换为“独角兽”，因为魔法动物也算作最喜欢的动物！在➋处，我们将索引为0（第一项）的元素替换为“有鬃蜥蜴”。不，这可不是一条真的龙——它只是只蜥蜴！
- en: Like any time you’re working with array index numbers, you have to be sure an
    item exists in the array at that index before you change its value, or you will
    get an Index out of range error.
  id: totrans-7121
  prefs: []
  type: TYPE_NORMAL
  zh: 就像在处理数组索引时一样，在你更改数组中某个元素的值之前，必须确保该索引处的元素存在，否则你会得到“索引超出范围”的错误。
- en: '[Figure 6-3](text00016.html#ch06fig3) shows the error that occurs if you try
    to add "Standard poodle" using favoriteAnimals[3] = "Standard poodle" . To add
    an item to the end of an array, you should use the append(_:) method or += , as
    we covered in “[Adding Items to an Array](text00016.html#ch06lev2sec5) ” on [page
    70](text00016.html#page_70) .'
  id: totrans-7122
  prefs: []
  type: TYPE_NORMAL
  zh: '[图6-3](text00016.html#ch06fig3)展示了如果你尝试通过favoriteAnimals[3] = "标准贵宾犬"来添加“标准贵宾犬”时发生的错误。要将一个项目添加到数组的末尾，你应该使用append(_)方法或+=，就像我们在“[向数组添加项目](text00016.html#ch06lev2sec5)”中讲到的那样，[在第70页](text00016.html#page_70)。'
- en: '![Image](Image00132.jpg)'
  id: totrans-7123
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00132.jpg)'
- en: '*Figure 6-3: Don’t try to replace a value at an index beyond the existing array.*'
  id: totrans-7124
  prefs: []
  type: TYPE_NORMAL
  zh: '*图6-3：不要尝试替换超出现有数组范围的索引处的值。*'
- en: Now you know how to change arrays however you might need to. You can add items,
    take items away, or replace items. Next, we’ll look at how to use the properties
    of arrays to find out even more information about them.
  id: totrans-7125
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经知道如何根据需要更改数组。你可以添加元素，删除元素或替换元素。接下来，我们将看看如何使用数组的属性来了解更多关于数组的信息。
- en: '![Image](Image00133.jpg)'
  id: totrans-7126
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00133.jpg)'
- en: '**USING ARRAY PROPERTIES**'
  id: totrans-7127
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**使用数组属性**'
- en: In addition to methods like append(_:) and removeLast() , arrays also have *properties*
    . An array’s properties are variables or constants that contain some information
    about the array. Two really helpful properties that you might use are the Boolean
    property isEmpty and the integer property count .
  id: totrans-7128
  prefs: []
  type: TYPE_NORMAL
  zh: 除了像append(_)和removeLast()这样的操作方法外，数组还有*属性*。数组的属性是包含关于数组的一些信息的变量或常量。你可能会使用的两个非常有用的属性是布尔型属性isEmpty和整数型属性count。
- en: The isEmpty property is true or false depending on whether the array is empty,
    and the count property will tell you how many items are in that array.
  id: totrans-7129
  prefs: []
  type: TYPE_NORMAL
  zh: isEmpty属性的值为真或假，取决于数组是否为空，count属性会告诉你数组中有多少个元素。
- en: 'Check out how these two properties are used in the following if-else statement:'
  id: totrans-7130
  prefs: []
  type: TYPE_NORMAL
  zh: 看一下以下if-else语句中如何使用这两个属性：
- en: '![Image](Image00134.jpg)'
  id: totrans-7131
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00134.jpg)'
- en: 'This if-else statement checks whether the array mySiblings is empty ➊ . If
    it is, then "I don''t have any siblings." is printed. But if there is something
    in the array, then the number of siblings that we have is printed: "I have 3 siblings."
    ➋ .'
  id: totrans-7132
  prefs: []
  type: TYPE_NORMAL
  zh: 这个if-else语句检查数组mySiblings是否为空➊。如果为空，那么会打印出“我没有兄弟姐妹。”如果数组中有内容，则会打印出我们有多少个兄弟姐妹：“我有3个兄弟姐妹。”➋。
- en: '**LOOPING OVER AN ARRAY**'
  id: totrans-7133
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**循环遍历数组**'
- en: 'Sometimes when you’re working with arrays you might want to do something to
    every item in the array. You can use a for-in loop to do that! The following code
    will print every topping in a pizzaToppings array on a separate line:'
  id: totrans-7134
  prefs: []
  type: TYPE_NORMAL
  zh: 有时在操作数组时，你可能想对数组中的每一项进行操作。你可以使用for-in循环来实现！以下代码将在每一行打印pizzaToppings数组中的每一项：
- en: '![Image](Image00135.jpg)'
  id: totrans-7135
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00135.jpg)'
- en: To write a for-in loop for the pizzaToppings array, we used the keyword for
    , followed by the constant topping , then the keyword in , and finally the name
    of our array, pizzaToppings . Then we put the statements that we want to run for
    each topping inside the braces of the for-in loop. The constant topping ➊ temporarily
    represents each pizza topping in the array as we loop through it. We could have
    chosen any name for this constant, but it’s a good idea to pick something that
    makes sense. You can see the output of this for-in loop in [Figure 6-4](text00016.html#ch06fig4)
    .
  id: totrans-7136
  prefs: []
  type: TYPE_NORMAL
  zh: 为了为pizzaToppings数组编写一个for-in循环，我们使用了关键字for，接着是常量topping，然后是关键字in，最后是数组名称pizzaToppings。然后，我们将要对每个配料执行的语句放在for-in循环的大括号中。常量topping
    ➊在我们循环时临时代表数组中的每个比萨配料。我们可以为这个常量选择任何名字，但最好选择一个有意义的名字。你可以在[图6-4](text00016.html#ch06fig4)中看到这个for-in循环的输出。
- en: '![Image](Image00136.jpg)'
  id: totrans-7137
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Image00136.jpg)'
- en: '*Figure 6-4: Output of the example for-in loop*'
  id: totrans-7138
  prefs: []
  type: TYPE_NORMAL
  zh: '*图6-4：示例中的for-in循环输出*'
- en: '![Image](Image00137.jpg)'
  id: totrans-7139
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Image00137.jpg)'
- en: 'Using for-in loops is great for printing every value in an array. If you’re
    working with numbers, you can even use them to perform math operations on each
    item, which makes for some speedy calculations! The following code takes an array
    of numbers and calculates the square for each (the square of a number is that
    number multiplied by itself):'
  id: totrans-7140
  prefs: []
  type: TYPE_NORMAL
  zh: 使用for-in循环非常适合打印数组中的每个值。如果你正在处理数字，甚至可以用它们对每个项执行数学运算，这样可以加快计算速度！以下代码接收一个数字数组，并计算每个数字的平方（一个数字的平方是该数字乘以自身）：
- en: '![Image](Image00138.jpg)'
  id: totrans-7141
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Image00138.jpg)'
- en: '[Figure 6-5](text00016.html#ch06fig5) shows the results.'
  id: totrans-7142
  prefs: []
  type: TYPE_NORMAL
  zh: '[图6-5](text00016.html#ch06fig5)显示了结果。'
- en: '![Image](Image00139.jpg)'
  id: totrans-7143
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Image00139.jpg)'
- en: '*Figure 6-5: Printing the squares for each number in the myNumbers array*'
  id: totrans-7144
  prefs: []
  type: TYPE_NORMAL
  zh: '*图6-5：打印myNumbers数组中每个数字的平方*'
- en: '**DICTIONARIES ARE KEY!**'
  id: totrans-7145
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**字典是关键！**'
- en: A *dictionary* is also a collection of values, but instead of an ordered index,
    each value has its own *key* . Because there’s no index, the values are not stored
    in any particular order. To access values in a dictionary, you look them up by
    their key.
  id: totrans-7146
  prefs: []
  type: TYPE_NORMAL
  zh: '*字典*也是一个值的集合，不同于有序索引，每个值都有自己独立的*键*。由于没有索引，值并不会按照特定的顺序存储。要访问字典中的值，可以通过键来查找。'
- en: A key must be unique. You can’t have the same key more than once in the same
    dictionary. If there were two identical keys and you asked the computer to give
    you the value for one of them, the computer wouldn’t know which one to choose!
  id: totrans-7147
  prefs: []
  type: TYPE_NORMAL
  zh: 键必须是唯一的。你不能在同一个字典中使用相同的键。如果有两个相同的键，且你要求计算机返回其中一个的值，计算机将不知道选择哪个！
- en: Let’s take a look at how to make a dictionary and write keys that will help
    you find all the information you need.
  id: totrans-7148
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看如何创建字典并写入键，以帮助你找到所需的所有信息。
- en: '![Image](Image00140.jpg)'
  id: totrans-7149
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Image00140.jpg)'
- en: '**INITIALIZING A DICTIONARY**'
  id: totrans-7150
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**初始化字典**'
- en: 'To create and initialize a dictionary, first write var and the name of your
    dictionary. Then write the keys and corresponding values inside a pair of square
    brackets, similar to an array. Let’s create a dictionary to store the names of
    a few US states. The key for each state will be its two-letter abbreviation:'
  id: totrans-7151
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建并初始化一个字典，首先写下var和字典的名称。然后，将键和值对放在一对方括号中，类似于数组的写法。让我们创建一个字典来存储一些美国州的名称。每个州的键将是它的两个字母缩写：
- en: '![](Image00141.jpg)'
  id: totrans-7152
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00141.jpg)'
- en: As you can see, there’s a colon between each key and its value, and the key/value
    pairs are separated by commas.
  id: totrans-7153
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，每个键和值之间都有一个冒号，键/值对之间由逗号分隔。
- en: Dictionaries are different from arrays in that they are *unordered* . Because
    of that, it’s likely that the order of the states that you see in your results
    pane ➋ is different from the order in which you entered your states ➊ . It might
    even be different than the order that’s printed in this book!
  id: totrans-7154
  prefs: []
  type: TYPE_NORMAL
  zh: 字典与数组的不同之处在于它们是*无序的*。因此，结果窗格➋中的状态顺序可能与输入状态➊的顺序不同，甚至可能与本书中打印的顺序不同！
- en: As with arrays, you can use var to make a mutable dictionary or use let to make
    an immutable dictionary.
  id: totrans-7155
  prefs: []
  type: TYPE_NORMAL
  zh: 与数组一样，你可以使用var来创建一个可变字典，或使用let来创建一个不可变字典。
- en: 'In Swift, all of the keys of a dictionary must be the same type, and all of
    the values of a dictionary must also be the same type, but the key type doesn’t
    have to match the value type. For example, if you wanted to store a collection
    of fractions, you could use doubles for the keys and strings for the values:'
  id: totrans-7156
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Swift 中，字典的所有键必须是相同类型的，字典的所有值也必须是相同类型的，但键的类型不需要与值的类型匹配。例如，如果你想存储一组分数，你可以使用双精度数作为键，字符串作为值：
- en: '![](Image00142.jpg)'
  id: totrans-7157
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00142.jpg)'
- en: In this dictionary, all of the keys must be doubles, and all of the values must
    be strings. Again, you’ll see that the order of the numbers in the results pane
    can be quite different from the order in which you wrote the fractions in your
    dictionary. This is fine because you don’t need to know the order to access anything.
    You can find any item that you need by its key. Let’s see how!
  id: totrans-7158
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个字典中，所有的键必须是双精度数（doubles），而所有的值必须是字符串（strings）。同样，你会看到结果面板中的数字顺序可能与在字典中写入分数时的顺序大不相同。这没关系，因为你不需要知道顺序就能访问任何内容。你可以通过键找到任何你需要的项。让我们来看看怎么做！
- en: '**ACCESSING VALUES IN A DICTIONARY**'
  id: totrans-7159
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**访问字典中的值**'
- en: 'Looking up a value in a dictionary is similar to how you access a value in
    an array except that you use a key inside the square brackets instead of an index,
    like this: usStates["TX"] .'
  id: totrans-7160
  prefs: []
  type: TYPE_NORMAL
  zh: 在字典中查找一个值类似于如何在数组中访问一个值，不同之处在于你使用的是方括号中的键，而不是索引，像这样：`usStates["TX"]`。
- en: There is a big difference, however, in how Swift returns the values from a dictionary.
    When you access a value at an index of an array, you are simply given the value.
    When you access a value with a key in a dictionary, you are given an optional.
  id: totrans-7161
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在 Swift 中从字典返回值的方式有一个很大的不同。当你通过数组的索引访问一个值时，你只会得到那个值。当你通过字典的键访问一个值时，你得到的是一个可选值。
- en: In [Chapter 5](text00015.html#ch05) , you learned that optionals might contain
    a value or might be nil . The reason Swift returns optionals when you’re looking
    up items in a dictionary is that the key you used might not exist in the dictionary,
    in which case there’s no value to access. Trying to access a value that doesn’t
    exist would give you a big fat error! To avoid that problem, Swift returns optionals.
    That means you need to unwrap any value you get out of a dictionary before you
    can do anything with it.
  id: totrans-7162
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第5章](text00015.html#ch05)中，你学到了可选值可能包含一个值，也可能是 `nil` 。Swift 在查找字典中的项时返回可选值的原因是，你使用的键可能在字典中不存在，在这种情况下，就没有值可以访问。尝试访问一个不存在的值会给你带来一个大大的错误！为了避免这个问题，Swift
    返回了可选值。这意味着你需要在做任何操作之前解包字典中获取的值。
- en: 'To unwrap an optional, first you check whether it exists using an if-let statement,
    just like we did in [Chapter 5](text00015.html#ch05) . The following code shows
    you how to get a value out of a dictionary:'
  id: totrans-7163
  prefs: []
  type: TYPE_NORMAL
  zh: 要解包一个可选值，首先你检查它是否存在，就像我们在[第5章](text00015.html#ch05)中所做的那样。以下代码向你展示了如何从字典中获取一个值：
- en: '![Image](Image00143.jpg)'
  id: totrans-7164
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00143.jpg)'
- en: To retrieve "Texas" from the dictionary, we use if let to set a constant loneStarState
    to usStates["TX"] ➊ . Because we have this state in our dictionary, the line I
    have Texas in my dictionary. is printed. Next we try to access a state that is
    not in our dictionary by using the key usStates["FL"] ➋ . Thankfully, because
    we used an if-let statement, the program won’t crash when the computer can’t find
    this state. Instead, I don't have that state in my dictionary. is printed.
  id: totrans-7165
  prefs: []
  type: TYPE_NORMAL
  zh: 要从字典中检索“Texas”，我们使用 `if let` 来将常量 `loneStarState` 设置为 `usStates["TX"]` ➊ 。因为我们在字典中有这个州，所以会打印出
    "I have Texas in my dictionary."。接下来，我们尝试使用 `usStates["FL"]` ➋ 访问一个不在字典中的州。幸运的是，因为我们使用了
    `if-let` 语句，当计算机找不到这个州时，程序不会崩溃。相反，打印出 "I don't have that state in my dictionary."。
- en: '**ADDING ITEMS TO A DICTIONARY**'
  id: totrans-7166
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**向字典添加项**'
- en: 'To add an item to a dictionary, first write the name of your dictionary and
    assign the new item to the key you want it to have in the dictionary. Let’s add
    "Minnesota" to our usStates dictionary:'
  id: totrans-7167
  prefs: []
  type: TYPE_NORMAL
  zh: 要向字典中添加项目，首先写下字典的名称，然后将新项分配给你希望它在字典中对应的键。让我们把“Minnesota”添加到我们的 `usStates` 字典中：
- en: '![](Image00144.jpg)'
  id: totrans-7168
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00144.jpg)'
- en: 'Now when you look at usStates , you’ll see that it’s updated to ["MN": "Minnesota",
    "WA": "Washington", "MA": "Massachusetts", "TX": "Texas"] . Remember, because
    you don’t have to rely on indices, your new dictionary item might appear anywhere
    in the dictionary.'
  id: totrans-7169
  prefs: []
  type: TYPE_NORMAL
  zh: '现在，当你查看 `usStates` 时，你会看到它已经更新为 `["MN": "Minnesota", "WA": "Washington", "MA":
    "Massachusetts", "TX": "Texas"]`。记住，因为你不需要依赖索引，新的字典项可能出现在字典中的任何位置。'
- en: '**REMOVING ITEMS FROM A DICTIONARY**'
  id: totrans-7170
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**从字典中移除项**'
- en: Removing an item from a dictionary is quite simple; you do so by setting the
    value to nil . Because the values in dictionaries are returned as optionals, you
    don’t have to worry about nil causing any problems in your dictionary.
  id: totrans-7171
  prefs: []
  type: TYPE_NORMAL
  zh: 从字典中删除项非常简单；你只需将值设置为nil。由于字典中的值是作为可选项返回的，因此你无需担心nil会在字典中引发任何问题。
- en: '![](Image00145.jpg)'
  id: totrans-7172
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00145.jpg)'
- en: 'You can see that after you remove the value at the key "MA" , usStates is updated
    to ["MN": "Minnesota", "WA": "Washington", "TX": "Texas"] . Remember that nil
    is special and means that there’s no value at all. That’s why you don’t see "MA":
    nil in our dictionary.'
  id: totrans-7173
  prefs: []
  type: TYPE_NORMAL
  zh: '你可以看到，在移除"MA"键的值后，usStates被更新为["MN": "Minnesota", "WA": "Washington", "TX":
    "Texas"]。记住，nil是特殊的，表示根本没有值。这就是为什么你在我们的字典中看不到"MA": nil。'
- en: '**REPLACING ITEMS IN A DICTIONARY**'
  id: totrans-7174
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**替换字典中的项**'
- en: 'Replacing an item in a dictionary is also easy. It works the same was as replacing
    an item in an array. You just set the item that you want to replace to something
    else. Say you create a dictionary of fruit colors:'
  id: totrans-7175
  prefs: []
  type: TYPE_NORMAL
  zh: 替换字典中的项也很简单。它的操作方式与替换数组中的项相同。你只需将要替换的项设置为其他值。假设你创建了一个水果颜色的字典：
- en: '![](Image00146.jpg)'
  id: totrans-7176
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00146.jpg)'
- en: At first we had the value "apple" for "red" , but then we decided that "raspberry"
    is a better fruit to use since sometimes apples are green or yellow. To replace
    "apple" with "raspberry" , we set colorFruits["red"] to its new value ➊ .
  id: totrans-7177
  prefs: []
  type: TYPE_NORMAL
  zh: 最初我们为"red"的值设置了"apple"，但后来我们决定使用"raspberry"作为更好的水果，因为有时候苹果是绿色或黄色的。为了将"apple"替换为"raspberry"，我们将colorFruits["red"]设置为它的新值
    ➊。
- en: You may remember that this is the same way we entered a new value into a dictionary.
    If the key already exists in the dictionary, then the value for that key is replaced.
    If the key doesn’t already exist, then the new key/value pair will be added to
    the dictionary.
  id: totrans-7178
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能还记得，这与我们将新值输入字典的方式相同。如果键已经存在于字典中，那么该键的值会被替换。如果键不存在，则新的键/值对将被添加到字典中。
- en: '![Image](Image00147.jpg)'
  id: totrans-7179
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00147.jpg)'
- en: '**USING DICTIONARY PROPERTIES**'
  id: totrans-7180
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**使用字典属性**'
- en: 'Like an array, a dictionary also has an isEmpty property and a count property.
    For example, the following code shows how you can use the isEmpty property to
    check if a dictionary is empty, and if it isn’t empty, the count property checks
    how many items you have. Imagine you have a basket of fruit for sale. You can
    use these properties to help you keep track of everything:'
  id: totrans-7181
  prefs: []
  type: TYPE_NORMAL
  zh: 像数组一样，字典也有isEmpty属性和count属性。例如，下面的代码展示了如何使用isEmpty属性检查字典是否为空，如果不为空，count属性则检查你有多少项。假设你有一个待售的水果篮，你可以使用这些属性帮助你跟踪所有的内容：
- en: '![Image](Image00148.jpg)'
  id: totrans-7182
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00148.jpg)'
- en: 'A dictionary also has two special properties: keys , which contains all of
    the dictionary’s keys, and values , which contains all of its values. We’ll use
    these two properties when we loop through the dictionary.'
  id: totrans-7183
  prefs: []
  type: TYPE_NORMAL
  zh: 字典还具有两个特殊属性：keys，它包含字典的所有键，和values，它包含字典的所有值。我们在遍历字典时将使用这两个属性。
- en: Let’s write some code that loops through our fruit baskets and prints the price
    of each fruit.
  id: totrans-7184
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们写一些代码，遍历我们的水果篮并打印每个水果的价格。
- en: '**LOOPING OVER A DICTIONARY**'
  id: totrans-7185
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**遍历字典**'
- en: 'You can loop through a dictionary using a for-in loop. Because each item has
    a key and a value, you can do this in two different ways. This is how to loop
    through a dictionary using its keys:'
  id: totrans-7186
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用for-in循环遍历字典。因为每个项目都有一个键和值，你可以用两种不同的方式来做到这一点。这是使用字典的键遍历字典的方法：
- en: '![Image](Image00149.jpg)'
  id: totrans-7187
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00149.jpg)'
- en: Here we use the dictionary’s keys property ➊ to loop through fruitBasket and
    print its contents. We start by writing the keyword for , followed by a constant
    name fruit for the dictionary key, the keyword in , the dictionary name, a period,
    and keys .
  id: totrans-7188
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们使用字典的keys属性 ➊ 来遍历fruitBasket并打印其内容。我们首先写下关键字for，然后是常量名称fruit作为字典的键，再加上关键字in，字典名称，句点，最后是keys。
- en: Inside the braces of our for-in loop, we have access to both the key, which
    we call fruit ➋ , and the value at that key when we force-unwrap its contents
    with fruitBasket[fruit]! ➌ . That value will be the fruit’s price.
  id: totrans-7189
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的for-in循环的大括号内，我们可以访问键，我们称之为fruit ➋，以及当我们强制解包其内容时，fruitBasket[fruit]! ➌的键对应的值。这个值将是水果的价格。
- en: In this case, it’s safe to force-unwrap the value using an exclamation point
    because we know that the fruit key we’re using is definitely inside the dictionary.
  id: totrans-7190
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，由于我们知道所使用的fruit键肯定在字典中，因此可以安全地使用感叹号强制解包值。
- en: Any code we put inside the for-in loop will run once for every key in our dictionary.
    So you should see the print statement display three times.
  id: totrans-7191
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在`for-in`循环中放入的任何代码都会对字典中的每一个键执行一次。所以你应该会看到打印语句显示三次。
- en: 'We can also loop through the dictionary using its values property:'
  id: totrans-7192
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以通过字典的`values`属性来循环遍历它：
- en: '![Image](Image00150.jpg)'
  id: totrans-7193
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00150.jpg)'
- en: We use the same style of for-in loop, but now we use a constant to refer to
    each value, which we call price , in the values property. When looping through
    values, we don’t have access to the keys from inside the loop.
  id: totrans-7194
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用相同类型的`for-in`循环，但这次我们使用一个常量来引用`values`属性中的每个值，称为`price`。在遍历值时，我们无法从循环内访问键。
- en: Another difference to note is that price is not an optional because it’s accessed
    directly as a value in the fruitBasket dictionary. That means we don’t have to
    unwrap it. You should still see the print statement printed three times. [Figure
    6-6](text00016.html#ch06fig6) shows the output of both loops.
  id: totrans-7195
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个需要注意的区别是，`price`不是可选值，因为它是直接作为`fruitBasket`字典中的值访问的。这意味着我们不需要解包它。你仍然应该看到打印语句被打印三次。[图
    6-6](text00016.html#ch06fig6)显示了两个循环的输出结果。
- en: '![Image](Image00151.jpg)'
  id: totrans-7196
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00151.jpg)'
- en: '*Figure 6-6: Looping through the keys and values of a dictionary with a for-in
    loop*'
  id: totrans-7197
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 6-6：使用`for-in`循环遍历字典的键和值*'
- en: The order of your results might be slightly different from ours. That’s because
    the items in a dictionary aren’t in a numbered order like they are in an array!
    And because the order is not guaranteed, you might see a different order printed
    if you run the same code again.
  id: totrans-7198
  prefs: []
  type: TYPE_NORMAL
  zh: 你的结果顺序可能与我们的稍有不同。这是因为字典中的项目不像数组中的项目那样按顺序编号！由于顺序没有保证，如果你再次运行相同的代码，可能会看到不同的顺序。
- en: '**WHAT YOU LEARNED**'
  id: totrans-7199
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**你学到了什么**'
- en: In this chapter, you learned how to store collections of items in an array and
    in a dictionary. To store items in an ordered list, you would use an array and
    look up each item by its index. If you wanted to store items by key instead, you
    would use a dictionary.
  id: totrans-7200
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你学会了如何将一系列项目存储在数组和字典中。要将项目存储在有序列表中，你会使用数组，并通过索引查找每个项目。如果你想通过键存储项目，则会使用字典。
- en: Knowing about arrays and dictionaries and how to use them is a powerful building
    block for almost any programming language. Next we will learn about functions,
    another very powerful tool. Functions are blocks of code that you create and name
    to perform a specific job. After you have written a function, you can use its
    name to call it from almost anywhere in your program.
  id: totrans-7201
  prefs: []
  type: TYPE_NORMAL
  zh: 了解数组和字典及其使用方法是几乎所有编程语言中的一个强大构建模块。接下来我们将学习函数，这是另一个非常强大的工具。函数是你创建并命名的代码块，用于执行特定的任务。在你编写了一个函数之后，可以通过它的名称在程序中的几乎任何地方调用它。
- en: 'Note that trying to remove an item at an index that doesn’t exist will give
    you an error:'
  id: totrans-7202
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，尝试删除一个不存在的索引处的项目会导致错误：
- en: '![](Image00130.jpg)'
  id: totrans-7203
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00130.jpg)'
- en: Our array doesn’t have this many items (in fact, now it’s empty!), so this throws
    an error. We’ll also get an error if we use removeLast() on our empty array, because
    there’s nothing in it—there’s no last index at all! However, removeAll() is always
    safe to use, even on an empty array.
  id: totrans-7204
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的数组没有这么多项目（事实上，现在它是空的！），因此会抛出一个错误。如果我们在空数组上使用`removeLast()`，也会出错，因为里面没有任何东西——根本没有最后一个索引！然而，`removeAll()`始终是安全的，即使是在空数组上使用。
- en: '**REPLACING ITEMS IN AN ARRAY**'
  id: totrans-7205
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**替换数组中的项目**'
- en: 'To replace an item in an array, you set the index of the array to the new value,
    as shown here:'
  id: totrans-7206
  prefs: []
  type: TYPE_NORMAL
  zh: 要替换数组中的项目，你只需将数组的索引设置为新值，如下所示：
- en: '![](Image00131.jpg)'
  id: totrans-7207
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00131.jpg)'
- en: At ➊ , we replaced the item at index 2 (the third item) with "Unicorn" because
    magical animals count as favorite animals, too! At ➋ , we replaced the item at
    index 0 (the first item) with "Bearded dragon" . No, that’s not a real dragon—it’s
    just a lizard!
  id: totrans-7208
  prefs: []
  type: TYPE_NORMAL
  zh: 在➊处，我们将索引2（第三个项目）处的项目替换为“独角兽”，因为魔法动物也算是最喜欢的动物！在➋处，我们将索引0（第一个项目）处的项目替换为“胡须龙”。不，那不是一条真正的龙——它只是只蜥蜴！
- en: Like any time you’re working with array index numbers, you have to be sure an
    item exists in the array at that index before you change its value, or you will
    get an Index out of range error.
  id: totrans-7209
  prefs: []
  type: TYPE_NORMAL
  zh: 就像在任何时候使用数组索引时，你必须确保该索引处存在项目，否则你会得到“超出范围”的错误。
- en: '[Figure 6-3](text00016.html#ch06fig3) shows the error that occurs if you try
    to add "Standard poodle" using favoriteAnimals[3] = "Standard poodle" . To add
    an item to the end of an array, you should use the append(_:) method or += , as
    we covered in “[Adding Items to an Array](text00016.html#ch06lev2sec5) ” on [page
    70](text00016.html#page_70) .'
  id: totrans-7210
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 6-3](text00016.html#ch06fig3) 显示了如果你尝试通过 favoriteAnimals[3] = "Standard
    poodle" 添加 "标准贵宾犬" 会发生的错误。要将项目添加到数组末尾，应该使用 append(_:) 方法或 +=，就像我们在 “[向数组添加项](text00016.html#ch06lev2sec5)”
    中讲解的那样，见[第 70 页](text00016.html#page_70)。'
- en: '![Image](Image00132.jpg)'
  id: totrans-7211
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Image00132.jpg)'
- en: '*Figure 6-3: Don’t try to replace a value at an index beyond the existing array.*'
  id: totrans-7212
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 6-3：不要尝试在超过现有数组范围的索引位置替换值。*'
- en: Now you know how to change arrays however you might need to. You can add items,
    take items away, or replace items. Next, we’ll look at how to use the properties
    of arrays to find out even more information about them.
  id: totrans-7213
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你知道如何根据需要修改数组了。你可以添加项、删除项，或者替换项。接下来，我们将了解如何使用数组的属性来获取更多关于它们的信息。
- en: '![Image](Image00133.jpg)'
  id: totrans-7214
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Image00133.jpg)'
- en: '**USING ARRAY PROPERTIES**'
  id: totrans-7215
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**使用数组属性**'
- en: In addition to methods like append(_:) and removeLast() , arrays also have *properties*
    . An array’s properties are variables or constants that contain some information
    about the array. Two really helpful properties that you might use are the Boolean
    property isEmpty and the integer property count .
  id: totrans-7216
  prefs: []
  type: TYPE_NORMAL
  zh: 除了像 append(_:) 和 removeLast() 这样的函数方法外，数组还有 *属性*。数组的属性是包含数组相关信息的变量或常量。你可能会用到的两个非常有用的属性是布尔属性
    isEmpty 和整型属性 count。
- en: The isEmpty property is true or false depending on whether the array is empty,
    and the count property will tell you how many items are in that array.
  id: totrans-7217
  prefs: []
  type: TYPE_NORMAL
  zh: isEmpty 属性的值是 true 或 false，取决于数组是否为空，而 count 属性会告诉你数组中有多少项。
- en: 'Check out how these two properties are used in the following if-else statement:'
  id: totrans-7218
  prefs: []
  type: TYPE_NORMAL
  zh: 请查看以下 if-else 语句中如何使用这两个属性：
- en: '![Image](Image00134.jpg)'
  id: totrans-7219
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Image00134.jpg)'
- en: 'This if-else statement checks whether the array mySiblings is empty ➊ . If
    it is, then "I don''t have any siblings." is printed. But if there is something
    in the array, then the number of siblings that we have is printed: "I have 3 siblings."
    ➋ .'
  id: totrans-7220
  prefs: []
  type: TYPE_NORMAL
  zh: 这个 if-else 语句检查数组 mySiblings 是否为空 ➊。如果是空的，那么会打印出 "我没有兄弟姐妹。"。但如果数组中有内容，那么会打印出我们有几个兄弟姐妹：
    "我有 3 个兄弟姐妹。" ➋。
- en: '**LOOPING OVER AN ARRAY**'
  id: totrans-7221
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**遍历数组**'
- en: 'Sometimes when you’re working with arrays you might want to do something to
    every item in the array. You can use a for-in loop to do that! The following code
    will print every topping in a pizzaToppings array on a separate line:'
  id: totrans-7222
  prefs: []
  type: TYPE_NORMAL
  zh: 有时候在处理数组时，你可能需要对数组中的每个项目做某些操作。你可以使用 for-in 循环来实现！下面的代码将会把 pizzaToppings 数组中的每个配料单独打印到一行：
- en: '![Image](Image00135.jpg)'
  id: totrans-7223
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Image00135.jpg)'
- en: To write a for-in loop for the pizzaToppings array, we used the keyword for
    , followed by the constant topping , then the keyword in , and finally the name
    of our array, pizzaToppings . Then we put the statements that we want to run for
    each topping inside the braces of the for-in loop. The constant topping ➊ temporarily
    represents each pizza topping in the array as we loop through it. We could have
    chosen any name for this constant, but it’s a good idea to pick something that
    makes sense. You can see the output of this for-in loop in [Figure 6-4](text00016.html#ch06fig4)
    .
  id: totrans-7224
  prefs: []
  type: TYPE_NORMAL
  zh: 为了编写 pizzaToppings 数组的 for-in 循环，我们使用了关键字 for，后面跟着常量 topping，再加上关键字 in，最后是我们数组的名称
    pizzaToppings。然后我们将想要对每个 topping 执行的语句放在 for-in 循环的大括号内。常量 topping ➊ 在我们遍历数组时，临时代表数组中的每一个披萨配料。我们可以为这个常量选择任何名字，但选择一个有意义的名字是个不错的主意。你可以在[图
    6-4](text00016.html#ch06fig4)中看到这个 for-in 循环的输出。
- en: '![Image](Image00136.jpg)'
  id: totrans-7225
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Image00136.jpg)'
- en: '*Figure 6-4: Output of the example for-in loop*'
  id: totrans-7226
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 6-4：示例 for-in 循环的输出*'
- en: '![Image](Image00137.jpg)'
  id: totrans-7227
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Image00137.jpg)'
- en: 'Using for-in loops is great for printing every value in an array. If you’re
    working with numbers, you can even use them to perform math operations on each
    item, which makes for some speedy calculations! The following code takes an array
    of numbers and calculates the square for each (the square of a number is that
    number multiplied by itself):'
  id: totrans-7228
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 for-in 循环遍历数组是非常适合打印每个值的。如果你在处理数字，你甚至可以用它们对每个项执行数学运算，这样可以进行快速的计算！下面的代码获取一个数字数组，并计算每个数字的平方（数字的平方是这个数字与其本身相乘）：
- en: '![Image](Image00138.jpg)'
  id: totrans-7229
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Image00138.jpg)'
- en: '[Figure 6-5](text00016.html#ch06fig5) shows the results.'
  id: totrans-7230
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 6-5](text00016.html#ch06fig5) 显示了结果。'
- en: '![Image](Image00139.jpg)'
  id: totrans-7231
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Image00139.jpg)'
- en: '*Figure 6-5: Printing the squares for each number in the myNumbers array*'
  id: totrans-7232
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 6-5：打印 myNumbers 数组中每个数字的平方*'
- en: '**DICTIONARIES ARE KEY!**'
  id: totrans-7233
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**字典是关键！**'
- en: A *dictionary* is also a collection of values, but instead of an ordered index,
    each value has its own *key* . Because there’s no index, the values are not stored
    in any particular order. To access values in a dictionary, you look them up by
    their key.
  id: totrans-7234
  prefs: []
  type: TYPE_NORMAL
  zh: '*字典*也是一个值的集合，但与有序的数组不同，每个值都有自己的*键*。由于没有索引，值不会按任何特定顺序存储。要访问字典中的值，你需要通过它们的键进行查找。'
- en: A key must be unique. You can’t have the same key more than once in the same
    dictionary. If there were two identical keys and you asked the computer to give
    you the value for one of them, the computer wouldn’t know which one to choose!
  id: totrans-7235
  prefs: []
  type: TYPE_NORMAL
  zh: 键必须是唯一的。你不能在同一个字典中使用相同的键。如果有两个相同的键，并且你要求计算机给你其中一个的值，计算机将不知道选择哪一个！
- en: Let’s take a look at how to make a dictionary and write keys that will help
    you find all the information you need.
  id: totrans-7236
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如何创建一个字典，并编写键，以帮助你找到所需的所有信息。
- en: '![Image](Image00140.jpg)'
  id: totrans-7237
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00140.jpg)'
- en: '**INITIALIZING A DICTIONARY**'
  id: totrans-7238
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**初始化字典**'
- en: 'To create and initialize a dictionary, first write var and the name of your
    dictionary. Then write the keys and corresponding values inside a pair of square
    brackets, similar to an array. Let’s create a dictionary to store the names of
    a few US states. The key for each state will be its two-letter abbreviation:'
  id: totrans-7239
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建并初始化字典，首先写上 var 和字典的名称。然后将键及其对应的值写在一对方括号内，类似于数组。让我们创建一个字典来存储一些美国州的名称。每个州的键将是它的两字母缩写：
- en: '![](Image00141.jpg)'
  id: totrans-7240
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00141.jpg)'
- en: As you can see, there’s a colon between each key and its value, and the key/value
    pairs are separated by commas.
  id: totrans-7241
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，每个键和值之间有一个冒号，键/值对之间用逗号分隔。
- en: Dictionaries are different from arrays in that they are *unordered* . Because
    of that, it’s likely that the order of the states that you see in your results
    pane ➋ is different from the order in which you entered your states ➊ . It might
    even be different than the order that’s printed in this book!
  id: totrans-7242
  prefs: []
  type: TYPE_NORMAL
  zh: 字典与数组的不同之处在于它们是*无序的*。因此，你在结果面板中看到的州的顺序➋可能与你输入州的顺序➊不同。它甚至可能与本书中打印的顺序不同！
- en: As with arrays, you can use var to make a mutable dictionary or use let to make
    an immutable dictionary.
  id: totrans-7243
  prefs: []
  type: TYPE_NORMAL
  zh: 与数组一样，你可以使用 var 来创建一个可变字典，或者使用 let 来创建一个不可变字典。
- en: 'In Swift, all of the keys of a dictionary must be the same type, and all of
    the values of a dictionary must also be the same type, but the key type doesn’t
    have to match the value type. For example, if you wanted to store a collection
    of fractions, you could use doubles for the keys and strings for the values:'
  id: totrans-7244
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Swift 中，字典的所有键必须是相同类型，字典的所有值也必须是相同类型，但键的类型不需要与值的类型匹配。例如，如果你想存储一组分数，可以使用双精度浮点数（doubles）作为键，字符串作为值：
- en: '![](Image00142.jpg)'
  id: totrans-7245
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00142.jpg)'
- en: In this dictionary, all of the keys must be doubles, and all of the values must
    be strings. Again, you’ll see that the order of the numbers in the results pane
    can be quite different from the order in which you wrote the fractions in your
    dictionary. This is fine because you don’t need to know the order to access anything.
    You can find any item that you need by its key. Let’s see how!
  id: totrans-7246
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个字典中，所有的键必须是双精度浮点数，所有的值必须是字符串。同样，你会发现结果面板中数字的顺序可能与字典中输入分数的顺序完全不同。这是可以的，因为你不需要知道顺序就能访问任何内容。你可以通过键找到你需要的任何项目。让我们看看如何做！
- en: '**ACCESSING VALUES IN A DICTIONARY**'
  id: totrans-7247
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**访问字典中的值**'
- en: 'Looking up a value in a dictionary is similar to how you access a value in
    an array except that you use a key inside the square brackets instead of an index,
    like this: usStates["TX"] .'
  id: totrans-7248
  prefs: []
  type: TYPE_NORMAL
  zh: 在字典中查找一个值的方式类似于在数组中访问一个值，只不过你在方括号内使用键，而不是索引，像这样：usStates["TX"]。
- en: There is a big difference, however, in how Swift returns the values from a dictionary.
    When you access a value at an index of an array, you are simply given the value.
    When you access a value with a key in a dictionary, you are given an optional.
  id: totrans-7249
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在 Swift 中，字典返回值的方式有很大不同。当你访问数组中的某个索引时，你只会得到值。当你通过字典中的键访问值时，你会得到一个可选值（optional）。
- en: In [Chapter 5](text00015.html#ch05) , you learned that optionals might contain
    a value or might be nil . The reason Swift returns optionals when you’re looking
    up items in a dictionary is that the key you used might not exist in the dictionary,
    in which case there’s no value to access. Trying to access a value that doesn’t
    exist would give you a big fat error! To avoid that problem, Swift returns optionals.
    That means you need to unwrap any value you get out of a dictionary before you
    can do anything with it.
  id: totrans-7250
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第5章](text00015.html#ch05)中，你学到可选项可能包含一个值，也可能是nil。Swift返回可选项的原因是，当你在字典中查找项时，使用的键可能不存在，这样就没有可以访问的值。如果你尝试访问一个不存在的值，程序会报错！为了解决这个问题，Swift返回可选项。这意味着，在你对字典中取出的任何值进行操作之前，必须先解包它。
- en: 'To unwrap an optional, first you check whether it exists using an if-let statement,
    just like we did in [Chapter 5](text00015.html#ch05) . The following code shows
    you how to get a value out of a dictionary:'
  id: totrans-7251
  prefs: []
  type: TYPE_NORMAL
  zh: 要解包一个可选项，首先你需要使用if-let语句检查它是否存在，就像我们在[第5章](text00015.html#ch05)中做的那样。以下代码展示了如何从字典中获取一个值：
- en: '![Image](Image00143.jpg)'
  id: totrans-7252
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00143.jpg)'
- en: To retrieve "Texas" from the dictionary, we use if let to set a constant loneStarState
    to usStates["TX"] ➊ . Because we have this state in our dictionary, the line I
    have Texas in my dictionary. is printed. Next we try to access a state that is
    not in our dictionary by using the key usStates["FL"] ➋ . Thankfully, because
    we used an if-let statement, the program won’t crash when the computer can’t find
    this state. Instead, I don't have that state in my dictionary. is printed.
  id: totrans-7253
  prefs: []
  type: TYPE_NORMAL
  zh: 要从字典中检索"Texas"，我们使用if let将常量loneStarState设置为usStates["TX"]➊。因为字典中确实有这个州，程序会打印出我在字典中有Texas。接着，我们尝试使用键usStates["FL"]➋访问一个不存在于字典中的州。幸运的是，因为我们使用了if-let语句，当计算机找不到该州时，程序不会崩溃，而是打印出我在字典中没有那个州。
- en: '**ADDING ITEMS TO A DICTIONARY**'
  id: totrans-7254
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**向字典添加项**'
- en: 'To add an item to a dictionary, first write the name of your dictionary and
    assign the new item to the key you want it to have in the dictionary. Let’s add
    "Minnesota" to our usStates dictionary:'
  id: totrans-7255
  prefs: []
  type: TYPE_NORMAL
  zh: 要向字典添加一项，首先写出字典的名称，并将新项赋值给你想要它所在的键。让我们将"Minnesota"添加到我们的usStates字典中：
- en: '![](Image00144.jpg)'
  id: totrans-7256
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00144.jpg)'
- en: 'Now when you look at usStates , you’ll see that it’s updated to ["MN": "Minnesota",
    "WA": "Washington", "MA": "Massachusetts", "TX": "Texas"] . Remember, because
    you don’t have to rely on indices, your new dictionary item might appear anywhere
    in the dictionary.'
  id: totrans-7257
  prefs: []
  type: TYPE_NORMAL
  zh: '现在，当你查看usStates时，你会看到它已更新为["MN": "Minnesota", "WA": "Washington", "MA": "Massachusetts",
    "TX": "Texas"]。记住，由于你不需要依赖索引，新的字典项可能出现在字典的任何位置。'
- en: '**REMOVING ITEMS FROM A DICTIONARY**'
  id: totrans-7258
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**从字典中移除项**'
- en: Removing an item from a dictionary is quite simple; you do so by setting the
    value to nil . Because the values in dictionaries are returned as optionals, you
    don’t have to worry about nil causing any problems in your dictionary.
  id: totrans-7259
  prefs: []
  type: TYPE_NORMAL
  zh: 从字典中移除一项非常简单；你只需要将该值设置为nil即可。由于字典中的值是作为可选项返回的，你不需要担心nil会在字典中引发问题。
- en: '![](Image00145.jpg)'
  id: totrans-7260
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00145.jpg)'
- en: 'You can see that after you remove the value at the key "MA" , usStates is updated
    to ["MN": "Minnesota", "WA": "Washington", "TX": "Texas"] . Remember that nil
    is special and means that there’s no value at all. That’s why you don’t see "MA":
    nil in our dictionary.'
  id: totrans-7261
  prefs: []
  type: TYPE_NORMAL
  zh: '你可以看到，在移除"MA"键的值之后，usStates被更新为["MN": "Minnesota", "WA": "Washington", "TX":
    "Texas"]。记住，nil是特殊的，意味着完全没有值。这就是为什么你不会在我们的字典中看到"MA": nil。'
- en: '**REPLACING ITEMS IN A DICTIONARY**'
  id: totrans-7262
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**替换字典中的项**'
- en: 'Replacing an item in a dictionary is also easy. It works the same was as replacing
    an item in an array. You just set the item that you want to replace to something
    else. Say you create a dictionary of fruit colors:'
  id: totrans-7263
  prefs: []
  type: TYPE_NORMAL
  zh: 替换字典中的项也很简单。它的操作方式和替换数组中的项一样。你只需要将你想替换的项设置为其他值。比如你创建一个关于水果颜色的字典：
- en: '![](Image00146.jpg)'
  id: totrans-7264
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00146.jpg)'
- en: At first we had the value "apple" for "red" , but then we decided that "raspberry"
    is a better fruit to use since sometimes apples are green or yellow. To replace
    "apple" with "raspberry" , we set colorFruits["red"] to its new value ➊ .
  id: totrans-7265
  prefs: []
  type: TYPE_NORMAL
  zh: 起初我们为"red"指定了"apple"这个值，但后来我们决定使用"raspberry"作为更好的水果，因为有时候苹果是绿色或黄色的。为了将"apple"替换为"raspberry"，我们将colorFruits["red"]设置为新的值➊。
- en: You may remember that this is the same way we entered a new value into a dictionary.
    If the key already exists in the dictionary, then the value for that key is replaced.
    If the key doesn’t already exist, then the new key/value pair will be added to
    the dictionary.
  id: totrans-7266
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能记得，这是我们向字典中输入新值的相同方式。如果字典中已经存在该键，那么该键的值将被替换。如果该键不存在，那么新的键/值对将被添加到字典中。
- en: '![Image](Image00147.jpg)'
  id: totrans-7267
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Image00147.jpg)'
- en: '**USING DICTIONARY PROPERTIES**'
  id: totrans-7268
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**使用字典属性**'
- en: 'Like an array, a dictionary also has an isEmpty property and a count property.
    For example, the following code shows how you can use the isEmpty property to
    check if a dictionary is empty, and if it isn’t empty, the count property checks
    how many items you have. Imagine you have a basket of fruit for sale. You can
    use these properties to help you keep track of everything:'
  id: totrans-7269
  prefs: []
  type: TYPE_NORMAL
  zh: 像数组一样，字典也有一个isEmpty属性和一个count属性。例如，以下代码展示了如何使用isEmpty属性检查字典是否为空，如果不为空，count属性会检查你有多少项。假设你有一个待售的水果篮。你可以使用这些属性来帮助你跟踪所有的内容：
- en: '![Image](Image00148.jpg)'
  id: totrans-7270
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Image00148.jpg)'
- en: 'A dictionary also has two special properties: keys , which contains all of
    the dictionary’s keys, and values , which contains all of its values. We’ll use
    these two properties when we loop through the dictionary.'
  id: totrans-7271
  prefs: []
  type: TYPE_NORMAL
  zh: 字典还有两个特殊的属性：keys，包含字典的所有键，和values，包含所有的值。我们将在循环遍历字典时使用这两个属性。
- en: Let’s write some code that loops through our fruit baskets and prints the price
    of each fruit.
  id: totrans-7272
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们编写一些代码，循环遍历我们的水果篮并打印每种水果的价格。
- en: '**LOOPING OVER A DICTIONARY**'
  id: totrans-7273
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**循环遍历字典**'
- en: 'You can loop through a dictionary using a for-in loop. Because each item has
    a key and a value, you can do this in two different ways. This is how to loop
    through a dictionary using its keys:'
  id: totrans-7274
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用for-in循环遍历字典。由于每个项目都有一个键和值，你可以通过两种不同的方式来实现这一点。这是如何使用键遍历字典的方法：
- en: '![Image](Image00149.jpg)'
  id: totrans-7275
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Image00149.jpg)'
- en: Here we use the dictionary’s keys property ➊ to loop through fruitBasket and
    print its contents. We start by writing the keyword for , followed by a constant
    name fruit for the dictionary key, the keyword in , the dictionary name, a period,
    and keys .
  id: totrans-7276
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们使用字典的keys属性 ➊ 来循环遍历fruitBasket并打印其内容。我们从编写关键字for开始，后面跟着一个常量名称fruit作为字典键，关键字in，字典名称，句点和keys。
- en: Inside the braces of our for-in loop, we have access to both the key, which
    we call fruit ➋ , and the value at that key when we force-unwrap its contents
    with fruitBasket[fruit]! ➌ . That value will be the fruit’s price.
  id: totrans-7277
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的for-in循环的大括号内，我们可以访问到键（我们称之为fruit ➋）和该键的值，当我们使用fruitBasket[fruit]! ➌ 强制解包它的内容时。该值将是水果的价格。
- en: In this case, it’s safe to force-unwrap the value using an exclamation point
    because we know that the fruit key we’re using is definitely inside the dictionary.
  id: totrans-7278
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，使用感叹号强制解包值是安全的，因为我们知道我们使用的水果键一定在字典中。
- en: Any code we put inside the for-in loop will run once for every key in our dictionary.
    So you should see the print statement display three times.
  id: totrans-7279
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在for-in循环中放置的任何代码都会针对字典中的每个键执行一次。所以你应该看到打印语句显示三次。
- en: 'We can also loop through the dictionary using its values property:'
  id: totrans-7280
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以使用字典的values属性来循环遍历字典：
- en: '![Image](Image00150.jpg)'
  id: totrans-7281
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Image00150.jpg)'
- en: We use the same style of for-in loop, but now we use a constant to refer to
    each value, which we call price , in the values property. When looping through
    values, we don’t have access to the keys from inside the loop.
  id: totrans-7282
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用相同风格的for-in循环，但现在我们使用一个常量来引用values属性中的每个值，我们称之为price。在循环遍历values时，我们无法从循环内部访问键。
- en: Another difference to note is that price is not an optional because it’s accessed
    directly as a value in the fruitBasket dictionary. That means we don’t have to
    unwrap it. You should still see the print statement printed three times. [Figure
    6-6](text00016.html#ch06fig6) shows the output of both loops.
  id: totrans-7283
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个需要注意的区别是价格不是可选的，因为它是直接作为值访问的，存在于fruitBasket字典中。这意味着我们不需要解包它。你应该仍然会看到打印语句打印三次。[图6-6](text00016.html#ch06fig6)显示了两个循环的输出。
- en: '![Image](Image00151.jpg)'
  id: totrans-7284
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Image00151.jpg)'
- en: '*Figure 6-6: Looping through the keys and values of a dictionary with a for-in
    loop*'
  id: totrans-7285
  prefs: []
  type: TYPE_NORMAL
  zh: '*图6-6：使用for-in循环遍历字典的键和值*'
- en: The order of your results might be slightly different from ours. That’s because
    the items in a dictionary aren’t in a numbered order like they are in an array!
    And because the order is not guaranteed, you might see a different order printed
    if you run the same code again.
  id: totrans-7286
  prefs: []
  type: TYPE_NORMAL
  zh: 你的结果顺序可能与我们的略有不同。那是因为字典中的项目不像数组那样按编号顺序排列！由于顺序无法保证，如果你再次运行相同的代码，你可能会看到不同的顺序。
- en: '**WHAT YOU LEARNED**'
  id: totrans-7287
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**你学到了什么**'
- en: In this chapter, you learned how to store collections of items in an array and
    in a dictionary. To store items in an ordered list, you would use an array and
    look up each item by its index. If you wanted to store items by key instead, you
    would use a dictionary.
  id: totrans-7288
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你学习了如何在数组和字典中存储项目集合。要将项目存储在有序列表中，你可以使用数组，并通过索引查找每个项目。如果你想按键存储项目，则应使用字典。
- en: Knowing about arrays and dictionaries and how to use them is a powerful building
    block for almost any programming language. Next we will learn about functions,
    another very powerful tool. Functions are blocks of code that you create and name
    to perform a specific job. After you have written a function, you can use its
    name to call it from almost anywhere in your program.
  id: totrans-7289
  prefs: []
  type: TYPE_NORMAL
  zh: 了解数组和字典及其使用方法是几乎所有编程语言中的一个强大构建块。接下来，我们将学习函数，这是另一个非常强大的工具。函数是你创建并命名的代码块，用于执行特定任务。写好函数后，你可以通过其名称在程序中的几乎任何地方调用它。
- en: '![](Image00130.jpg)'
  id: totrans-7290
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00130.jpg)'
- en: Our array doesn’t have this many items (in fact, now it’s empty!), so this throws
    an error. We’ll also get an error if we use removeLast() on our empty array, because
    there’s nothing in it—there’s no last index at all! However, removeAll() is always
    safe to use, even on an empty array.
  id: totrans-7291
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的数组没有这么多项目（事实上，现在它是空的！），所以这会抛出一个错误。如果我们在空数组上使用removeLast()，也会发生错误，因为里面没有任何元素——根本没有最后一个索引！然而，removeAll()始终可以安全使用，即使是在空数组上。
- en: '**REPLACING ITEMS IN AN ARRAY**'
  id: totrans-7292
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**替换数组中的项目**'
- en: 'To replace an item in an array, you set the index of the array to the new value,
    as shown here:'
  id: totrans-7293
  prefs: []
  type: TYPE_NORMAL
  zh: 要替换数组中的项目，你只需将数组的索引设置为新值，如下所示：
- en: '![](Image00131.jpg)'
  id: totrans-7294
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00131.jpg)'
- en: At ➊ , we replaced the item at index 2 (the third item) with "Unicorn" because
    magical animals count as favorite animals, too! At ➋ , we replaced the item at
    index 0 (the first item) with "Bearded dragon" . No, that’s not a real dragon—it’s
    just a lizard!
  id: totrans-7295
  prefs: []
  type: TYPE_NORMAL
  zh: 在➊处，我们将索引2（第三个项目）处的项目替换为"独角兽"，因为魔法动物也算作最喜欢的动物！在➋处，我们将索引0（第一个项目）处的项目替换为"胡须龙"。不，这不是一只真正的龙——它只是一个蜥蜴！
- en: Like any time you’re working with array index numbers, you have to be sure an
    item exists in the array at that index before you change its value, or you will
    get an Index out of range error.
  id: totrans-7296
  prefs: []
  type: TYPE_NORMAL
  zh: 就像每次操作数组索引时一样，你必须确保该索引处的数组元素存在，才能修改其值，否则你将遇到索引越界错误。
- en: '[Figure 6-3](text00016.html#ch06fig3) shows the error that occurs if you try
    to add "Standard poodle" using favoriteAnimals[3] = "Standard poodle" . To add
    an item to the end of an array, you should use the append(_:) method or += , as
    we covered in “[Adding Items to an Array](text00016.html#ch06lev2sec5) ” on [page
    70](text00016.html#page_70) .'
  id: totrans-7297
  prefs: []
  type: TYPE_NORMAL
  zh: '[图6-3](text00016.html#ch06fig3)显示了如果你尝试使用favoriteAnimals[3] = "Standard poodle"
    来添加"标准贵宾犬"时出现的错误。要将项目添加到数组的末尾，应该使用append(_:)方法或+=，正如我们在“[向数组添加项目](text00016.html#ch06lev2sec5)”中第[70页](text00016.html#page_70)所讲解的那样。'
- en: '![Image](Image00132.jpg)'
  id: totrans-7298
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Image00132.jpg)'
- en: '*Figure 6-3: Don’t try to replace a value at an index beyond the existing array.*'
  id: totrans-7299
  prefs: []
  type: TYPE_NORMAL
  zh: '*图6-3：不要尝试在超出现有数组索引的地方替换值。*'
- en: Now you know how to change arrays however you might need to. You can add items,
    take items away, or replace items. Next, we’ll look at how to use the properties
    of arrays to find out even more information about them.
  id: totrans-7300
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你知道如何根据需要更改数组。你可以添加项目、移除项目或替换项目。接下来，我们将了解如何利用数组的属性获取更多有关它们的信息。
- en: '![Image](Image00133.jpg)'
  id: totrans-7301
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Image00133.jpg)'
- en: '**USING ARRAY PROPERTIES**'
  id: totrans-7302
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**使用数组属性**'
- en: In addition to methods like append(_:) and removeLast() , arrays also have *properties*
    . An array’s properties are variables or constants that contain some information
    about the array. Two really helpful properties that you might use are the Boolean
    property isEmpty and the integer property count .
  id: totrans-7303
  prefs: []
  type: TYPE_NORMAL
  zh: 除了像append(_:)和removeLast()这样的方法外，数组还有*属性*。数组的属性是包含有关数组信息的变量或常量。你可能会使用的两个非常有用的属性是布尔属性isEmpty和整数属性count。
- en: The isEmpty property is true or false depending on whether the array is empty,
    and the count property will tell you how many items are in that array.
  id: totrans-7304
  prefs: []
  type: TYPE_NORMAL
  zh: '`isEmpty` 属性是 true 或 false，取决于数组是否为空，而 `count` 属性将告诉你数组中有多少个项目。'
- en: 'Check out how these two properties are used in the following if-else statement:'
  id: totrans-7305
  prefs: []
  type: TYPE_NORMAL
  zh: 看一下以下 if-else 语句中如何使用这两个属性：
- en: '![Image](Image00134.jpg)'
  id: totrans-7306
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00134.jpg)'
- en: 'This if-else statement checks whether the array mySiblings is empty ➊ . If
    it is, then "I don''t have any siblings." is printed. But if there is something
    in the array, then the number of siblings that we have is printed: "I have 3 siblings."
    ➋ .'
  id: totrans-7307
  prefs: []
  type: TYPE_NORMAL
  zh: 这个 if-else 语句检查数组 `mySiblings` 是否为空 ➊。如果为空，则打印“我没有兄弟姐妹”。如果数组中有内容，则打印我们有多少个兄弟姐妹：“我有
    3 个兄弟姐妹。” ➋。
- en: '**LOOPING OVER AN ARRAY**'
  id: totrans-7308
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**遍历数组**'
- en: 'Sometimes when you’re working with arrays you might want to do something to
    every item in the array. You can use a for-in loop to do that! The following code
    will print every topping in a pizzaToppings array on a separate line:'
  id: totrans-7309
  prefs: []
  type: TYPE_NORMAL
  zh: 有时在处理数组时，你可能想对数组中的每个项目执行某些操作。你可以使用 for-in 循环来实现！以下代码会在新的一行打印 pizzaToppings 数组中的每个配料：
- en: '![Image](Image00135.jpg)'
  id: totrans-7310
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00135.jpg)'
- en: To write a for-in loop for the pizzaToppings array, we used the keyword for
    , followed by the constant topping , then the keyword in , and finally the name
    of our array, pizzaToppings . Then we put the statements that we want to run for
    each topping inside the braces of the for-in loop. The constant topping ➊ temporarily
    represents each pizza topping in the array as we loop through it. We could have
    chosen any name for this constant, but it’s a good idea to pick something that
    makes sense. You can see the output of this for-in loop in [Figure 6-4](text00016.html#ch06fig4)
    .
  id: totrans-7311
  prefs: []
  type: TYPE_NORMAL
  zh: 为了编写一个 for-in 循环处理 pizzaToppings 数组，我们使用了关键字 `for`，然后是常量 `topping`，接着是关键字 `in`，最后是数组的名称
    `pizzaToppings`。然后，我们把要对每个配料执行的语句放在 for-in 循环的大括号内。常量 `topping` ➊ 在我们遍历数组时，临时代表数组中的每个比萨配料。我们可以为这个常量选择任何名称，但最好选择一个有意义的名字。你可以在[图6-4](text00016.html#ch06fig4)中看到这个
    for-in 循环的输出。
- en: '![Image](Image00136.jpg)'
  id: totrans-7312
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00136.jpg)'
- en: '*Figure 6-4: Output of the example for-in loop*'
  id: totrans-7313
  prefs: []
  type: TYPE_NORMAL
  zh: '*图6-4：示例 for-in 循环的输出*'
- en: '![Image](Image00137.jpg)'
  id: totrans-7314
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00137.jpg)'
- en: 'Using for-in loops is great for printing every value in an array. If you’re
    working with numbers, you can even use them to perform math operations on each
    item, which makes for some speedy calculations! The following code takes an array
    of numbers and calculates the square for each (the square of a number is that
    number multiplied by itself):'
  id: totrans-7315
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 for-in 循环非常适合打印数组中的每个值。如果你处理的是数字，甚至可以用它们对每个项目进行数学运算，这样就能加速计算！以下代码接收一个数字数组并计算每个数字的平方（数字的平方是该数字与自身相乘）：
- en: '![Image](Image00138.jpg)'
  id: totrans-7316
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00138.jpg)'
- en: '[Figure 6-5](text00016.html#ch06fig5) shows the results.'
  id: totrans-7317
  prefs: []
  type: TYPE_NORMAL
  zh: '[图6-5](text00016.html#ch06fig5)展示了结果。'
- en: '![Image](Image00139.jpg)'
  id: totrans-7318
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00139.jpg)'
- en: '*Figure 6-5: Printing the squares for each number in the myNumbers array*'
  id: totrans-7319
  prefs: []
  type: TYPE_NORMAL
  zh: '*图6-5：打印 myNumbers 数组中每个数字的平方*'
- en: '**DICTIONARIES ARE KEY!**'
  id: totrans-7320
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**字典是关键！**'
- en: A *dictionary* is also a collection of values, but instead of an ordered index,
    each value has its own *key* . Because there’s no index, the values are not stored
    in any particular order. To access values in a dictionary, you look them up by
    their key.
  id: totrans-7321
  prefs: []
  type: TYPE_NORMAL
  zh: '*字典*也是一个值的集合，但不同于有序的索引，每个值都有自己的*键*。因为没有索引，值不会以任何特定顺序存储。要访问字典中的值，你需要通过它们的键来查找。'
- en: A key must be unique. You can’t have the same key more than once in the same
    dictionary. If there were two identical keys and you asked the computer to give
    you the value for one of them, the computer wouldn’t know which one to choose!
  id: totrans-7322
  prefs: []
  type: TYPE_NORMAL
  zh: 每个键必须是唯一的。你不能在同一个字典中使用相同的键。如果有两个相同的键，当你要求计算机返回其中一个的值时，计算机将不知道该选择哪个！
- en: Let’s take a look at how to make a dictionary and write keys that will help
    you find all the information you need.
  id: totrans-7323
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看一下如何创建字典并编写键，以帮助你找到所需的所有信息。
- en: '![Image](Image00140.jpg)'
  id: totrans-7324
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00140.jpg)'
- en: '**INITIALIZING A DICTIONARY**'
  id: totrans-7325
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**初始化字典**'
- en: 'To create and initialize a dictionary, first write var and the name of your
    dictionary. Then write the keys and corresponding values inside a pair of square
    brackets, similar to an array. Let’s create a dictionary to store the names of
    a few US states. The key for each state will be its two-letter abbreviation:'
  id: totrans-7326
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建并初始化一个字典，首先写上 `var` 和字典的名称。然后在一对方括号内写上键及其对应的值，类似于数组的写法。让我们创建一个字典来存储一些美国州的名称。每个州的键将是它的两位字母缩写：
- en: '![](Image00141.jpg)'
  id: totrans-7327
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00141.jpg)'
- en: As you can see, there’s a colon between each key and its value, and the key/value
    pairs are separated by commas.
  id: totrans-7328
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，每个键和值之间有一个冒号，键/值对之间用逗号分隔。
- en: Dictionaries are different from arrays in that they are *unordered* . Because
    of that, it’s likely that the order of the states that you see in your results
    pane ➋ is different from the order in which you entered your states ➊ . It might
    even be different than the order that’s printed in this book!
  id: totrans-7329
  prefs: []
  type: TYPE_NORMAL
  zh: 字典与数组的不同之处在于它们是*无序的*。因此，你在结果窗格中看到的州的顺序 ➋ 可能与输入这些州时的顺序 ➊ 不同，甚至可能与书中打印的顺序不同！
- en: As with arrays, you can use var to make a mutable dictionary or use let to make
    an immutable dictionary.
  id: totrans-7330
  prefs: []
  type: TYPE_NORMAL
  zh: 和数组一样，你可以使用 var 来创建一个可变字典，或者使用 let 来创建一个不可变字典。
- en: 'In Swift, all of the keys of a dictionary must be the same type, and all of
    the values of a dictionary must also be the same type, but the key type doesn’t
    have to match the value type. For example, if you wanted to store a collection
    of fractions, you could use doubles for the keys and strings for the values:'
  id: totrans-7331
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Swift 中，字典的所有键必须是相同的类型，字典的所有值也必须是相同的类型，但键的类型不需要与值的类型匹配。例如，如果你想存储一个分数集合，可以使用
    double 类型作为键，字符串作为值：
- en: '![](Image00142.jpg)'
  id: totrans-7332
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00142.jpg)'
- en: In this dictionary, all of the keys must be doubles, and all of the values must
    be strings. Again, you’ll see that the order of the numbers in the results pane
    can be quite different from the order in which you wrote the fractions in your
    dictionary. This is fine because you don’t need to know the order to access anything.
    You can find any item that you need by its key. Let’s see how!
  id: totrans-7333
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个字典中，所有的键必须是 double 类型，所有的值必须是字符串类型。同样，你会发现结果窗格中数字的顺序可能与字典中输入分数的顺序有很大不同。这是正常的，因为你不需要知道顺序就能访问任何内容。你可以通过键找到你需要的任何项。让我们看看如何实现！
- en: '**ACCESSING VALUES IN A DICTIONARY**'
  id: totrans-7334
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**访问字典中的值**'
- en: 'Looking up a value in a dictionary is similar to how you access a value in
    an array except that you use a key inside the square brackets instead of an index,
    like this: usStates["TX"] .'
  id: totrans-7335
  prefs: []
  type: TYPE_NORMAL
  zh: 在字典中查找一个值类似于你如何在数组中访问一个值，不同之处在于，你使用方括号内的键而不是索引，像这样：usStates["TX"]。
- en: There is a big difference, however, in how Swift returns the values from a dictionary.
    When you access a value at an index of an array, you are simply given the value.
    When you access a value with a key in a dictionary, you are given an optional.
  id: totrans-7336
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，Swift 在返回字典中的值时有一个显著的不同。当你访问数组中某个索引的值时，你只会获得该值。而当你通过键访问字典中的值时，你会获得一个可选项。
- en: In [Chapter 5](text00015.html#ch05) , you learned that optionals might contain
    a value or might be nil . The reason Swift returns optionals when you’re looking
    up items in a dictionary is that the key you used might not exist in the dictionary,
    in which case there’s no value to access. Trying to access a value that doesn’t
    exist would give you a big fat error! To avoid that problem, Swift returns optionals.
    That means you need to unwrap any value you get out of a dictionary before you
    can do anything with it.
  id: totrans-7337
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第5章](text00015.html#ch05)中，你学到可选项可能包含一个值，也可能为 nil。当你查找字典中的项时，Swift 返回可选项的原因是你使用的键可能在字典中不存在，在这种情况下就没有值可以访问。尝试访问不存在的值会导致一个严重的错误！为避免这种问题，Swift
    返回可选项。这意味着，在对字典中的任何值进行操作之前，你需要先解包它。
- en: 'To unwrap an optional, first you check whether it exists using an if-let statement,
    just like we did in [Chapter 5](text00015.html#ch05) . The following code shows
    you how to get a value out of a dictionary:'
  id: totrans-7338
  prefs: []
  type: TYPE_NORMAL
  zh: 要解包一个可选项，首先你需要检查它是否存在，就像我们在[第5章](text00015.html#ch05)中做的那样。以下代码展示了如何从字典中获取一个值：
- en: '![Image](Image00143.jpg)'
  id: totrans-7339
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00143.jpg)'
- en: To retrieve "Texas" from the dictionary, we use if let to set a constant loneStarState
    to usStates["TX"] ➊ . Because we have this state in our dictionary, the line I
    have Texas in my dictionary. is printed. Next we try to access a state that is
    not in our dictionary by using the key usStates["FL"] ➋ . Thankfully, because
    we used an if-let statement, the program won’t crash when the computer can’t find
    this state. Instead, I don't have that state in my dictionary. is printed.
  id: totrans-7340
  prefs: []
  type: TYPE_NORMAL
  zh: 要从字典中检索“Texas”，我们使用 if let 将常量 loneStarState 设置为 usStates["TX"] ➊ 。因为字典中包含这个州，所以会打印出“I
    have Texas in my dictionary.”。接下来，我们尝试通过使用键 usStates["FL"] ➋ 来访问字典中没有的州。幸运的是，由于我们使用了
    if-let 语句，当计算机找不到这个州时，程序不会崩溃。相反，打印出“I don't have that state in my dictionary.”。
- en: '**ADDING ITEMS TO A DICTIONARY**'
  id: totrans-7341
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**向字典添加项**'
- en: 'To add an item to a dictionary, first write the name of your dictionary and
    assign the new item to the key you want it to have in the dictionary. Let’s add
    "Minnesota" to our usStates dictionary:'
  id: totrans-7342
  prefs: []
  type: TYPE_NORMAL
  zh: 要向字典中添加一项，首先写下字典的名称，并将新项赋值给你想要它所在的键。让我们将 "Minnesota" 添加到我们的 usStates 字典中：
- en: '![](Image00144.jpg)'
  id: totrans-7343
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00144.jpg)'
- en: 'Now when you look at usStates , you’ll see that it’s updated to ["MN": "Minnesota",
    "WA": "Washington", "MA": "Massachusetts", "TX": "Texas"] . Remember, because
    you don’t have to rely on indices, your new dictionary item might appear anywhere
    in the dictionary.'
  id: totrans-7344
  prefs: []
  type: TYPE_NORMAL
  zh: '现在当你查看 usStates 时，你会看到它已经更新为 ["MN": "Minnesota", "WA": "Washington", "MA":
    "Massachusetts", "TX": "Texas"]。记住，由于你不必依赖索引，新的字典项可能会出现在字典中的任何位置。'
- en: '**REMOVING ITEMS FROM A DICTIONARY**'
  id: totrans-7345
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**从字典中移除项**'
- en: Removing an item from a dictionary is quite simple; you do so by setting the
    value to nil . Because the values in dictionaries are returned as optionals, you
    don’t have to worry about nil causing any problems in your dictionary.
  id: totrans-7346
  prefs: []
  type: TYPE_NORMAL
  zh: 从字典中移除一项非常简单；你只需要将值设置为 nil。因为字典中的值是以可选项形式返回的，所以你不必担心 nil 会导致字典出现问题。
- en: '![](Image00145.jpg)'
  id: totrans-7347
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00145.jpg)'
- en: 'You can see that after you remove the value at the key "MA" , usStates is updated
    to ["MN": "Minnesota", "WA": "Washington", "TX": "Texas"] . Remember that nil
    is special and means that there’s no value at all. That’s why you don’t see "MA":
    nil in our dictionary.'
  id: totrans-7348
  prefs: []
  type: TYPE_NORMAL
  zh: '你可以看到，在移除键为"MA"的值后，usStates 被更新为 ["MN": "Minnesota", "WA": "Washington", "TX":
    "Texas"]。记住，nil 是特殊的，表示完全没有值。这就是为什么在我们的字典中你看不到 "MA": nil 的原因。'
- en: '**REPLACING ITEMS IN A DICTIONARY**'
  id: totrans-7349
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**替换字典中的项**'
- en: 'Replacing an item in a dictionary is also easy. It works the same was as replacing
    an item in an array. You just set the item that you want to replace to something
    else. Say you create a dictionary of fruit colors:'
  id: totrans-7350
  prefs: []
  type: TYPE_NORMAL
  zh: 替换字典中的一项也很简单。它的工作方式和替换数组中的一项一样。你只需将要替换的项设置为其他值。假设你创建了一个关于水果颜色的字典：
- en: '![](Image00146.jpg)'
  id: totrans-7351
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00146.jpg)'
- en: At first we had the value "apple" for "red" , but then we decided that "raspberry"
    is a better fruit to use since sometimes apples are green or yellow. To replace
    "apple" with "raspberry" , we set colorFruits["red"] to its new value ➊ .
  id: totrans-7352
  prefs: []
  type: TYPE_NORMAL
  zh: 一开始我们给 "red" 配置了 "apple" 的值，但后来我们决定 "raspberry" 是更好的选择，因为有时候苹果是绿色或黄色的。为了用 "raspberry"
    替换 "apple"，我们将 colorFruits["red"] 设置为它的新值 ➊。
- en: You may remember that this is the same way we entered a new value into a dictionary.
    If the key already exists in the dictionary, then the value for that key is replaced.
    If the key doesn’t already exist, then the new key/value pair will be added to
    the dictionary.
  id: totrans-7353
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能记得，这和我们向字典中添加新值的方式是一样的。如果键已经存在于字典中，那么该键的值将被替换。如果键不存在，则新键/值对将被添加到字典中。
- en: '![Image](Image00147.jpg)'
  id: totrans-7354
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00147.jpg)'
- en: '**USING DICTIONARY PROPERTIES**'
  id: totrans-7355
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**使用字典属性**'
- en: 'Like an array, a dictionary also has an isEmpty property and a count property.
    For example, the following code shows how you can use the isEmpty property to
    check if a dictionary is empty, and if it isn’t empty, the count property checks
    how many items you have. Imagine you have a basket of fruit for sale. You can
    use these properties to help you keep track of everything:'
  id: totrans-7356
  prefs: []
  type: TYPE_NORMAL
  zh: 像数组一样，字典也有一个 isEmpty 属性和一个 count 属性。例如，以下代码展示了如何使用 isEmpty 属性来检查字典是否为空，如果不为空，count
    属性则检查字典中有多少项。想象你有一个水果篮子在出售。你可以使用这些属性帮助你跟踪每一样物品：
- en: '![Image](Image00148.jpg)'
  id: totrans-7357
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00148.jpg)'
- en: 'A dictionary also has two special properties: keys , which contains all of
    the dictionary’s keys, and values , which contains all of its values. We’ll use
    these two properties when we loop through the dictionary.'
  id: totrans-7358
  prefs: []
  type: TYPE_NORMAL
  zh: 字典还有两个特殊的属性：keys，包含字典的所有键；values，包含字典的所有值。我们将在遍历字典时使用这两个属性。
- en: Let’s write some code that loops through our fruit baskets and prints the price
    of each fruit.
  id: totrans-7359
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们写一些代码，遍历我们的水果篮子并打印每种水果的价格。
- en: '**LOOPING OVER A DICTIONARY**'
  id: totrans-7360
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**遍历字典**'
- en: 'You can loop through a dictionary using a for-in loop. Because each item has
    a key and a value, you can do this in two different ways. This is how to loop
    through a dictionary using its keys:'
  id: totrans-7361
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用 for-in 循环遍历字典。因为每一项都有一个键和值，你可以用两种不同的方式来遍历字典。这是使用键来遍历字典的方法：
- en: '![Image](Image00149.jpg)'
  id: totrans-7362
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00149.jpg)'
- en: Here we use the dictionary’s keys property ➊ to loop through fruitBasket and
    print its contents. We start by writing the keyword for , followed by a constant
    name fruit for the dictionary key, the keyword in , the dictionary name, a period,
    and keys .
  id: totrans-7363
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们使用字典的 `keys` 属性 ➊ 来循环遍历 `fruitBasket` 并打印其内容。我们从编写 `for` 关键字开始，后面跟上字典键的常量名
    `fruit`，然后是 `in` 关键字，字典名称，句点，以及 `keys`。
- en: Inside the braces of our for-in loop, we have access to both the key, which
    we call fruit ➋ , and the value at that key when we force-unwrap its contents
    with fruitBasket[fruit]! ➌ . That value will be the fruit’s price.
  id: totrans-7364
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `for-in` 循环的花括号内，我们可以访问键（我们称之为 `fruit` ➋）以及通过强制解包其内容 `fruitBasket[fruit]!`
    ➌ 后得到的值。该值将是水果的价格。
- en: In this case, it’s safe to force-unwrap the value using an exclamation point
    because we know that the fruit key we’re using is definitely inside the dictionary.
  id: totrans-7365
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，使用感叹号强制解包值是安全的，因为我们知道正在使用的 `fruit` 键肯定在字典中。
- en: Any code we put inside the for-in loop will run once for every key in our dictionary.
    So you should see the print statement display three times.
  id: totrans-7366
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在 `for-in` 循环中放入的任何代码都会在字典中的每个键上执行一次。所以你应该会看到打印语句执行三次。
- en: 'We can also loop through the dictionary using its values property:'
  id: totrans-7367
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以通过字典的 `values` 属性进行循环：
- en: '![Image](Image00150.jpg)'
  id: totrans-7368
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Image00150.jpg)'
- en: We use the same style of for-in loop, but now we use a constant to refer to
    each value, which we call price , in the values property. When looping through
    values, we don’t have access to the keys from inside the loop.
  id: totrans-7369
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用相同类型的 `for-in` 循环，但现在我们使用一个常量来引用 `values` 属性中的每个值，我们称之为 `price`。当循环遍历 `values`
    时，我们无法从循环内部访问键。
- en: Another difference to note is that price is not an optional because it’s accessed
    directly as a value in the fruitBasket dictionary. That means we don’t have to
    unwrap it. You should still see the print statement printed three times. [Figure
    6-6](text00016.html#ch06fig6) shows the output of both loops.
  id: totrans-7370
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个需要注意的区别是，`price` 不是一个可选值，因为它是直接作为 `fruitBasket` 字典中的值访问的。这意味着我们不需要解包它。你仍然会看到打印语句执行三次。[图6-6](text00016.html#ch06fig6)
    显示了两个循环的输出。
- en: '![Image](Image00151.jpg)'
  id: totrans-7371
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Image00151.jpg)'
- en: '*Figure 6-6: Looping through the keys and values of a dictionary with a for-in
    loop*'
  id: totrans-7372
  prefs: []
  type: TYPE_NORMAL
  zh: '*图6-6：使用 for-in 循环遍历字典的键和值*'
- en: The order of your results might be slightly different from ours. That’s because
    the items in a dictionary aren’t in a numbered order like they are in an array!
    And because the order is not guaranteed, you might see a different order printed
    if you run the same code again.
  id: totrans-7373
  prefs: []
  type: TYPE_NORMAL
  zh: 你的结果顺序可能与我们的略有不同。这是因为字典中的项目不像数组中的项目那样有编号顺序！由于顺序不保证，如果你重新运行相同的代码，可能会看到不同的输出顺序。
- en: '**WHAT YOU LEARNED**'
  id: totrans-7374
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**你学到了什么**'
- en: In this chapter, you learned how to store collections of items in an array and
    in a dictionary. To store items in an ordered list, you would use an array and
    look up each item by its index. If you wanted to store items by key instead, you
    would use a dictionary.
  id: totrans-7375
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你学习了如何将项目存储在数组和字典中。要将项目存储在有序列表中，你会使用数组，并通过索引查找每个项目。如果你想根据键来存储项目，则会使用字典。
- en: Knowing about arrays and dictionaries and how to use them is a powerful building
    block for almost any programming language. Next we will learn about functions,
    another very powerful tool. Functions are blocks of code that you create and name
    to perform a specific job. After you have written a function, you can use its
    name to call it from almost anywhere in your program.
  id: totrans-7376
  prefs: []
  type: TYPE_NORMAL
  zh: 了解数组和字典以及如何使用它们是几乎任何编程语言的强大构建块。接下来，我们将学习函数，这是另一个非常强大的工具。函数是你创建并命名的代码块，用于执行特定任务。在你编写完一个函数后，你可以通过它的名称在程序中的几乎任何地方调用它。
- en: Our array doesn’t have this many items (in fact, now it’s empty!), so this throws
    an error. We’ll also get an error if we use removeLast() on our empty array, because
    there’s nothing in it—there’s no last index at all! However, removeAll() is always
    safe to use, even on an empty array.
  id: totrans-7377
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的数组没有这么多项目（实际上，现在它是空的！），所以这会抛出一个错误。如果我们在空数组上使用 `removeLast()`，也会得到一个错误，因为它没有任何元素——根本没有最后一个索引！然而，`removeAll()`
    即使在空数组上使用也是安全的。
- en: '**REPLACING ITEMS IN AN ARRAY**'
  id: totrans-7378
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**替换数组中的项目**'
- en: 'To replace an item in an array, you set the index of the array to the new value,
    as shown here:'
  id: totrans-7379
  prefs: []
  type: TYPE_NORMAL
  zh: 要替换数组中的项目，你需要将数组的索引设置为新值，如下所示：
- en: '![](Image00131.jpg)'
  id: totrans-7380
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00131.jpg)'
- en: At ➊ , we replaced the item at index 2 (the third item) with "Unicorn" because
    magical animals count as favorite animals, too! At ➋ , we replaced the item at
    index 0 (the first item) with "Bearded dragon" . No, that’s not a real dragon—it’s
    just a lizard!
  id: totrans-7381
  prefs: []
  type: TYPE_NORMAL
  zh: 在 ➊ 处，我们用 "独角兽" 替换了索引 2 处（第三个项目），因为神奇动物也算作喜爱的动物！在 ➋ 处，我们用 "鬃蜥蜴" 替换了索引 0 处（第一个项目）。不，那不是真正的龙—只是一只蜥蜴！
- en: Like any time you’re working with array index numbers, you have to be sure an
    item exists in the array at that index before you change its value, or you will
    get an Index out of range error.
  id: totrans-7382
  prefs: []
  type: TYPE_NORMAL
  zh: 就像任何时候你在处理数组索引号一样，你必须确保在改变其值之前数组中确实存在该索引处的项目，否则你将会得到一个索引超出范围的错误。
- en: '[Figure 6-3](text00016.html#ch06fig3) shows the error that occurs if you try
    to add "Standard poodle" using favoriteAnimals[3] = "Standard poodle" . To add
    an item to the end of an array, you should use the append(_:) method or += , as
    we covered in “[Adding Items to an Array](text00016.html#ch06lev2sec5) ” on [page
    70](text00016.html#page_70) .'
  id: totrans-7383
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 6-3](text00016.html#ch06fig3) 显示了如果尝试使用 favoriteAnimals[3] = "标准贵宾犬" 来添加
    "标准贵宾犬" 时发生的错误。要将项添加到数组的末尾，应该使用 append(_:) 方法或 +=，就像我们在 "[向数组添加项](text00016.html#ch06lev2sec5)"
    和 "[第 70 页](text00016.html#page_70)" 中介绍的那样。'
- en: '![Image](Image00132.jpg)'
  id: totrans-7384
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Image00132.jpg)'
- en: '*Figure 6-3: Don’t try to replace a value at an index beyond the existing array.*'
  id: totrans-7385
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 6-3：不要试图替换超出现有数组索引的值。*'
- en: Now you know how to change arrays however you might need to. You can add items,
    take items away, or replace items. Next, we’ll look at how to use the properties
    of arrays to find out even more information about them.
  id: totrans-7386
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你知道如何根据需要更改数组了。你可以添加、删除或替换项。接下来，我们将看看如何使用数组的属性来获取更多信息。
- en: '![Image](Image00133.jpg)'
  id: totrans-7387
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Image00133.jpg)'
- en: '**USING ARRAY PROPERTIES**'
  id: totrans-7388
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**使用数组属性**'
- en: In addition to methods like append(_:) and removeLast() , arrays also have *properties*
    . An array’s properties are variables or constants that contain some information
    about the array. Two really helpful properties that you might use are the Boolean
    property isEmpty and the integer property count .
  id: totrans-7389
  prefs: []
  type: TYPE_NORMAL
  zh: 除了像 append(_:) 和 removeLast() 这样的方法外，数组还有 *属性* 。数组的属性是包含有关数组的某些信息的变量或常量。你可能会使用的两个非常有用的属性是布尔属性
    isEmpty 和整数属性 count 。
- en: The isEmpty property is true or false depending on whether the array is empty,
    and the count property will tell you how many items are in that array.
  id: totrans-7390
  prefs: []
  type: TYPE_NORMAL
  zh: isEmpty 属性根据数组是否为空返回 true 或 false，count 属性将告诉你数组中有多少项。
- en: 'Check out how these two properties are used in the following if-else statement:'
  id: totrans-7391
  prefs: []
  type: TYPE_NORMAL
  zh: 看看以下 if-else 语句中如何使用这两个属性：
- en: '![Image](Image00134.jpg)'
  id: totrans-7392
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Image00134.jpg)'
- en: 'This if-else statement checks whether the array mySiblings is empty ➊ . If
    it is, then "I don''t have any siblings." is printed. But if there is something
    in the array, then the number of siblings that we have is printed: "I have 3 siblings."
    ➋ .'
  id: totrans-7393
  prefs: []
  type: TYPE_NORMAL
  zh: 这个 if-else 语句检查数组 mySiblings 是否为空 ➊ 。如果是空的，就打印出 "我没有兄弟姐妹。"。但如果数组中有内容，就打印出我们有几个兄弟姐妹：
    "我有3个兄弟姐妹。" ➋ 。
- en: '**LOOPING OVER AN ARRAY**'
  id: totrans-7394
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**遍历数组**'
- en: 'Sometimes when you’re working with arrays you might want to do something to
    every item in the array. You can use a for-in loop to do that! The following code
    will print every topping in a pizzaToppings array on a separate line:'
  id: totrans-7395
  prefs: []
  type: TYPE_NORMAL
  zh: 有时候当你在处理数组时，你可能希望对数组中的每个项执行某些操作。你可以使用 for-in 循环来实现这一点！下面的代码将在不同的行上打印出 pizzaToppings
    数组中的每个配料：
- en: '![Image](Image00135.jpg)'
  id: totrans-7396
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Image00135.jpg)'
- en: To write a for-in loop for the pizzaToppings array, we used the keyword for
    , followed by the constant topping , then the keyword in , and finally the name
    of our array, pizzaToppings . Then we put the statements that we want to run for
    each topping inside the braces of the for-in loop. The constant topping ➊ temporarily
    represents each pizza topping in the array as we loop through it. We could have
    chosen any name for this constant, but it’s a good idea to pick something that
    makes sense. You can see the output of this for-in loop in [Figure 6-4](text00016.html#ch06fig4)
    .
  id: totrans-7397
  prefs: []
  type: TYPE_NORMAL
  zh: 要为 pizzaToppings 数组编写一个 for-in 循环，我们使用了关键字 for，后跟常量 topping，然后是关键字 in，最后是我们数组的名称
    pizzaToppings。然后我们将希望在每个配料上运行的语句放在 for-in 循环的大括号内。常量 topping ➊ 临时表示数组中每个披萨配料，我们在循环中遍历它。我们可以为这个常量选择任何名称，但选择一个有意义的名称是个好主意。你可以在
    [图 6-4](text00016.html#ch06fig4) 中看到这个 for-in 循环的输出。
- en: '![Image](Image00136.jpg)'
  id: totrans-7398
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Image00136.jpg)'
- en: '*Figure 6-4: Output of the example for-in loop*'
  id: totrans-7399
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 6-4：示例 for-in 循环的输出*'
- en: '![Image](Image00137.jpg)'
  id: totrans-7400
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Image00137.jpg)'
- en: 'Using for-in loops is great for printing every value in an array. If you’re
    working with numbers, you can even use them to perform math operations on each
    item, which makes for some speedy calculations! The following code takes an array
    of numbers and calculates the square for each (the square of a number is that
    number multiplied by itself):'
  id: totrans-7401
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 for-in 循环非常适合打印数组中的每个值。如果你正在处理数字，甚至可以使用它们对每个项目执行数学运算，这样可以进行快速计算！以下代码获取一个数字数组，并计算每个数字的平方（一个数字的平方是该数字与自身相乘）：
- en: '![Image](Image00138.jpg)'
  id: totrans-7402
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00138.jpg)'
- en: '[Figure 6-5](text00016.html#ch06fig5) shows the results.'
  id: totrans-7403
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 6-5](text00016.html#ch06fig5) 显示了结果。'
- en: '![Image](Image00139.jpg)'
  id: totrans-7404
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00139.jpg)'
- en: '*Figure 6-5: Printing the squares for each number in the myNumbers array*'
  id: totrans-7405
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 6-5：打印 myNumbers 数组中每个数字的平方*'
- en: '**DICTIONARIES ARE KEY!**'
  id: totrans-7406
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**字典是关键！**'
- en: A *dictionary* is also a collection of values, but instead of an ordered index,
    each value has its own *key* . Because there’s no index, the values are not stored
    in any particular order. To access values in a dictionary, you look them up by
    their key.
  id: totrans-7407
  prefs: []
  type: TYPE_NORMAL
  zh: '*字典* 也是一个值的集合，但与有序索引不同，每个值都有自己的 *键*。由于没有索引，值并不是以任何特定顺序存储的。要访问字典中的值，你可以通过它们的键来查找。'
- en: A key must be unique. You can’t have the same key more than once in the same
    dictionary. If there were two identical keys and you asked the computer to give
    you the value for one of them, the computer wouldn’t know which one to choose!
  id: totrans-7408
  prefs: []
  type: TYPE_NORMAL
  zh: 键必须是唯一的。你不能在同一个字典中使用相同的键两次。如果有两个相同的键，你请求计算机给出其中一个的值时，计算机就无法知道应该选择哪一个！
- en: Let’s take a look at how to make a dictionary and write keys that will help
    you find all the information you need.
  id: totrans-7409
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看一下如何制作字典并编写键，以帮助你找到所有需要的信息。
- en: '![Image](Image00140.jpg)'
  id: totrans-7410
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00140.jpg)'
- en: '**INITIALIZING A DICTIONARY**'
  id: totrans-7411
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**初始化字典**'
- en: 'To create and initialize a dictionary, first write var and the name of your
    dictionary. Then write the keys and corresponding values inside a pair of square
    brackets, similar to an array. Let’s create a dictionary to store the names of
    a few US states. The key for each state will be its two-letter abbreviation:'
  id: totrans-7412
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建并初始化字典，首先写上 var 和字典的名称。然后将键和值放在一对方括号中，类似于数组。我们来创建一个字典，用于存储一些美国州的名称。每个州的键将是它的两个字母缩写：
- en: '![](Image00141.jpg)'
  id: totrans-7413
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00141.jpg)'
- en: As you can see, there’s a colon between each key and its value, and the key/value
    pairs are separated by commas.
  id: totrans-7414
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，每个键和值之间有一个冒号，键/值对通过逗号分隔。
- en: Dictionaries are different from arrays in that they are *unordered* . Because
    of that, it’s likely that the order of the states that you see in your results
    pane ➋ is different from the order in which you entered your states ➊ . It might
    even be different than the order that’s printed in this book!
  id: totrans-7415
  prefs: []
  type: TYPE_NORMAL
  zh: 字典与数组不同，字典是 *无序的*。因此，你在结果面板中看到的州的顺序 ➋ 很可能与输入州的顺序 ➊ 不同。它甚至可能与书中打印的顺序不同！
- en: As with arrays, you can use var to make a mutable dictionary or use let to make
    an immutable dictionary.
  id: totrans-7416
  prefs: []
  type: TYPE_NORMAL
  zh: 与数组一样，你可以使用 var 来创建一个可变字典，或使用 let 来创建一个不可变字典。
- en: 'In Swift, all of the keys of a dictionary must be the same type, and all of
    the values of a dictionary must also be the same type, but the key type doesn’t
    have to match the value type. For example, if you wanted to store a collection
    of fractions, you could use doubles for the keys and strings for the values:'
  id: totrans-7417
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Swift 中，字典的所有键必须是相同类型的，字典的所有值也必须是相同类型的，但键类型不一定与值类型匹配。例如，如果你想存储一组分数，你可以使用双精度浮点数作为键，使用字符串作为值：
- en: '![](Image00142.jpg)'
  id: totrans-7418
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00142.jpg)'
- en: In this dictionary, all of the keys must be doubles, and all of the values must
    be strings. Again, you’ll see that the order of the numbers in the results pane
    can be quite different from the order in which you wrote the fractions in your
    dictionary. This is fine because you don’t need to know the order to access anything.
    You can find any item that you need by its key. Let’s see how!
  id: totrans-7419
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个字典中，所有的键必须是双精度浮点数，所有的值必须是字符串。再次强调，你会发现结果面板中数字的顺序可能与在字典中编写分数的顺序大不相同。这是可以接受的，因为你不需要知道顺序就能访问任何内容。你可以通过键找到你需要的任何项。让我们看看怎么做！
- en: '**ACCESSING VALUES IN A DICTIONARY**'
  id: totrans-7420
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**访问字典中的值**'
- en: 'Looking up a value in a dictionary is similar to how you access a value in
    an array except that you use a key inside the square brackets instead of an index,
    like this: usStates["TX"] .'
  id: totrans-7421
  prefs: []
  type: TYPE_NORMAL
  zh: 在字典中查找值类似于你在数组中访问值的方式，只是你使用键而不是索引，像这样：usStates["TX"]。
- en: There is a big difference, however, in how Swift returns the values from a dictionary.
    When you access a value at an index of an array, you are simply given the value.
    When you access a value with a key in a dictionary, you are given an optional.
  id: totrans-7422
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，Swift 从字典中返回值的方式有很大不同。当你访问数组的索引值时，你会直接得到值。当你使用字典中的键访问值时，你得到的是一个可选值。
- en: In [Chapter 5](text00015.html#ch05) , you learned that optionals might contain
    a value or might be nil . The reason Swift returns optionals when you’re looking
    up items in a dictionary is that the key you used might not exist in the dictionary,
    in which case there’s no value to access. Trying to access a value that doesn’t
    exist would give you a big fat error! To avoid that problem, Swift returns optionals.
    That means you need to unwrap any value you get out of a dictionary before you
    can do anything with it.
  id: totrans-7423
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第5章](text00015.html#ch05)中，你学习了可选值可能包含一个值，或者可能是 nil。Swift 在你查找字典中的项目时返回可选值的原因是，你使用的键可能不存在于字典中，在这种情况下就没有值可访问。尝试访问一个不存在的值会导致一个大错误！为避免这个问题，Swift
    返回了可选值。这意味着，在你对从字典中获取的值进行任何操作之前，你需要解包它。
- en: 'To unwrap an optional, first you check whether it exists using an if-let statement,
    just like we did in [Chapter 5](text00015.html#ch05) . The following code shows
    you how to get a value out of a dictionary:'
  id: totrans-7424
  prefs: []
  type: TYPE_NORMAL
  zh: 要解包一个可选值，首先你需要检查它是否存在，使用 if-let 语句，就像我们在[第5章](text00015.html#ch05)中做的那样。以下代码演示了如何从字典中获取值：
- en: '![Image](Image00143.jpg)'
  id: totrans-7425
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00143.jpg)'
- en: To retrieve "Texas" from the dictionary, we use if let to set a constant loneStarState
    to usStates["TX"] ➊ . Because we have this state in our dictionary, the line I
    have Texas in my dictionary. is printed. Next we try to access a state that is
    not in our dictionary by using the key usStates["FL"] ➋ . Thankfully, because
    we used an if-let statement, the program won’t crash when the computer can’t find
    this state. Instead, I don't have that state in my dictionary. is printed.
  id: totrans-7426
  prefs: []
  type: TYPE_NORMAL
  zh: 要从字典中检索 "Texas"，我们使用 if let 将常量 loneStarState 设置为 usStates["TX"] ➊。因为我们在字典中有这个州，所以会打印出“我在字典里有
    Texas”。接下来，我们尝试使用键 usStates["FL"] ➋ 来访问字典中不存在的州。幸运的是，因为我们使用了 if-let 语句，当计算机找不到这个州时，程序不会崩溃。相反，会打印出“我字典里没有这个州”。
- en: '**ADDING ITEMS TO A DICTIONARY**'
  id: totrans-7427
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**向字典添加项目**'
- en: 'To add an item to a dictionary, first write the name of your dictionary and
    assign the new item to the key you want it to have in the dictionary. Let’s add
    "Minnesota" to our usStates dictionary:'
  id: totrans-7428
  prefs: []
  type: TYPE_NORMAL
  zh: 要向字典添加项目，首先写出字典的名称，并将新项目赋值给你希望它在字典中拥有的键。让我们将 "Minnesota" 添加到我们的 usStates 字典中：
- en: '![](Image00144.jpg)'
  id: totrans-7429
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00144.jpg)'
- en: 'Now when you look at usStates , you’ll see that it’s updated to ["MN": "Minnesota",
    "WA": "Washington", "MA": "Massachusetts", "TX": "Texas"] . Remember, because
    you don’t have to rely on indices, your new dictionary item might appear anywhere
    in the dictionary.'
  id: totrans-7430
  prefs: []
  type: TYPE_NORMAL
  zh: '现在，当你查看 usStates 时，你会看到它更新为 ["MN": "Minnesota", "WA": "Washington", "MA": "Massachusetts",
    "TX": "Texas"]。记住，因为你不必依赖索引，你的新字典项目可能出现在字典中的任何位置。'
- en: '**REMOVING ITEMS FROM A DICTIONARY**'
  id: totrans-7431
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**从字典中移除项目**'
- en: Removing an item from a dictionary is quite simple; you do so by setting the
    value to nil . Because the values in dictionaries are returned as optionals, you
    don’t have to worry about nil causing any problems in your dictionary.
  id: totrans-7432
  prefs: []
  type: TYPE_NORMAL
  zh: 从字典中移除一个项目非常简单；你只需将值设置为 nil。因为字典中的值是作为可选值返回的，所以你不必担心 nil 会在字典中引发问题。
- en: '![](Image00145.jpg)'
  id: totrans-7433
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00145.jpg)'
- en: 'You can see that after you remove the value at the key "MA" , usStates is updated
    to ["MN": "Minnesota", "WA": "Washington", "TX": "Texas"] . Remember that nil
    is special and means that there’s no value at all. That’s why you don’t see "MA":
    nil in our dictionary.'
  id: totrans-7434
  prefs: []
  type: TYPE_NORMAL
  zh: '你可以看到，在移除键 "MA" 的值后，usStates 更新为 ["MN": "Minnesota", "WA": "Washington", "TX":
    "Texas"]。记住，nil 是特别的，表示没有任何值。因此，你不会在我们的字典中看到 "MA": nil。'
- en: '**REPLACING ITEMS IN A DICTIONARY**'
  id: totrans-7435
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**替换字典中的项目**'
- en: 'Replacing an item in a dictionary is also easy. It works the same was as replacing
    an item in an array. You just set the item that you want to replace to something
    else. Say you create a dictionary of fruit colors:'
  id: totrans-7436
  prefs: []
  type: TYPE_NORMAL
  zh: 替换字典中的项目也很简单。它的工作方式与替换数组中的项目相同。你只需将要替换的项目设置为其他值。假设你创建了一个水果颜色的字典：
- en: '![](Image00146.jpg)'
  id: totrans-7437
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00146.jpg)'
- en: At first we had the value "apple" for "red" , but then we decided that "raspberry"
    is a better fruit to use since sometimes apples are green or yellow. To replace
    "apple" with "raspberry" , we set colorFruits["red"] to its new value ➊ .
  id: totrans-7438
  prefs: []
  type: TYPE_NORMAL
  zh: 一开始我们为 "red" 设置了值 "apple" ，但是后来我们决定 "raspberry" 是更合适的水果，因为有时候苹果是绿色或黄色的。为了将 "apple"
    替换为 "raspberry" ，我们将 colorFruits["red"] 设置为它的新值 ➊ 。
- en: You may remember that this is the same way we entered a new value into a dictionary.
    If the key already exists in the dictionary, then the value for that key is replaced.
    If the key doesn’t already exist, then the new key/value pair will be added to
    the dictionary.
  id: totrans-7439
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能还记得，这与我们往字典中添加新值的方式相同。如果键已经存在于字典中，那么该键的值将被替换。如果键不存在，新的键/值对将会添加到字典中。
- en: '![Image](Image00147.jpg)'
  id: totrans-7440
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00147.jpg)'
- en: '**USING DICTIONARY PROPERTIES**'
  id: totrans-7441
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**使用字典属性**'
- en: 'Like an array, a dictionary also has an isEmpty property and a count property.
    For example, the following code shows how you can use the isEmpty property to
    check if a dictionary is empty, and if it isn’t empty, the count property checks
    how many items you have. Imagine you have a basket of fruit for sale. You can
    use these properties to help you keep track of everything:'
  id: totrans-7442
  prefs: []
  type: TYPE_NORMAL
  zh: 像数组一样，字典也有 isEmpty 属性和 count 属性。例如，下面的代码展示了如何使用 isEmpty 属性检查字典是否为空，如果不为空，则 count
    属性可以检查你有多少项。想象一下你有一个待售的水果篮。你可以使用这些属性帮助你跟踪一切：
- en: '![Image](Image00148.jpg)'
  id: totrans-7443
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00148.jpg)'
- en: 'A dictionary also has two special properties: keys , which contains all of
    the dictionary’s keys, and values , which contains all of its values. We’ll use
    these two properties when we loop through the dictionary.'
  id: totrans-7444
  prefs: []
  type: TYPE_NORMAL
  zh: 字典还有两个特殊属性：keys ，包含字典的所有键，和 values ，包含字典的所有值。在我们遍历字典时，我们将使用这两个属性。
- en: Let’s write some code that loops through our fruit baskets and prints the price
    of each fruit.
  id: totrans-7445
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们写一些代码，遍历我们的水果篮，并打印每个水果的价格。
- en: '**LOOPING OVER A DICTIONARY**'
  id: totrans-7446
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**遍历字典**'
- en: 'You can loop through a dictionary using a for-in loop. Because each item has
    a key and a value, you can do this in two different ways. This is how to loop
    through a dictionary using its keys:'
  id: totrans-7447
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用 for-in 循环遍历字典。因为每个项都有一个键和值，你可以通过两种不同的方式来实现这一点。这是使用键遍历字典的方法：
- en: '![Image](Image00149.jpg)'
  id: totrans-7448
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00149.jpg)'
- en: Here we use the dictionary’s keys property ➊ to loop through fruitBasket and
    print its contents. We start by writing the keyword for , followed by a constant
    name fruit for the dictionary key, the keyword in , the dictionary name, a period,
    and keys .
  id: totrans-7449
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们使用字典的 keys 属性 ➊ 来遍历 fruitBasket 并打印其内容。我们首先编写关键字 for ，接着是一个常量名称 fruit
    用于字典键，然后是 in 关键字，字典名称，句点，以及 keys 。
- en: Inside the braces of our for-in loop, we have access to both the key, which
    we call fruit ➋ , and the value at that key when we force-unwrap its contents
    with fruitBasket[fruit]! ➌ . That value will be the fruit’s price.
  id: totrans-7450
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们 for-in 循环的花括号内，我们可以访问键（我们称之为 fruit ➋ ），并且可以强制解包 fruitBasket[fruit] 中的值 ➌
    。该值将是水果的价格。
- en: In this case, it’s safe to force-unwrap the value using an exclamation point
    because we know that the fruit key we’re using is definitely inside the dictionary.
  id: totrans-7451
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，使用感叹号强制解包该值是安全的，因为我们知道我们使用的 fruit 键肯定在字典中。
- en: Any code we put inside the for-in loop will run once for every key in our dictionary.
    So you should see the print statement display three times.
  id: totrans-7452
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在 for-in 循环中放置的任何代码都会为字典中的每个键运行一次。因此你应该看到打印语句显示三次。
- en: 'We can also loop through the dictionary using its values property:'
  id: totrans-7453
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以使用字典的 values 属性来遍历字典：
- en: '![Image](Image00150.jpg)'
  id: totrans-7454
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00150.jpg)'
- en: We use the same style of for-in loop, but now we use a constant to refer to
    each value, which we call price , in the values property. When looping through
    values, we don’t have access to the keys from inside the loop.
  id: totrans-7455
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用相同风格的 for-in 循环，但现在我们使用一个常量来引用 values 属性中的每个值，我们称之为 price 。在遍历值时，我们无法从循环内部访问键。
- en: Another difference to note is that price is not an optional because it’s accessed
    directly as a value in the fruitBasket dictionary. That means we don’t have to
    unwrap it. You should still see the print statement printed three times. [Figure
    6-6](text00016.html#ch06fig6) shows the output of both loops.
  id: totrans-7456
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个需要注意的区别是，price 不是可选项，因为它是直接作为值访问的，存在于 fruitBasket 字典中。这意味着我们不需要解包它。你应该仍然看到打印语句显示三次。[图
    6-6](text00016.html#ch06fig6) 显示了两个循环的输出。
- en: '![Image](Image00151.jpg)'
  id: totrans-7457
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00151.jpg)'
- en: '*Figure 6-6: Looping through the keys and values of a dictionary with a for-in
    loop*'
  id: totrans-7458
  prefs: []
  type: TYPE_NORMAL
  zh: '*图6-6：使用 for-in 循环遍历字典的键和值*'
- en: The order of your results might be slightly different from ours. That’s because
    the items in a dictionary aren’t in a numbered order like they are in an array!
    And because the order is not guaranteed, you might see a different order printed
    if you run the same code again.
  id: totrans-7459
  prefs: []
  type: TYPE_NORMAL
  zh: 你的结果顺序可能会与我们的有所不同。那是因为字典中的项不像数组中的项那样是按编号顺序排列的！由于顺序无法保证，如果你再次运行相同的代码，可能会看到不同的输出顺序。
- en: '**WHAT YOU LEARNED**'
  id: totrans-7460
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**你学到了什么**'
- en: In this chapter, you learned how to store collections of items in an array and
    in a dictionary. To store items in an ordered list, you would use an array and
    look up each item by its index. If you wanted to store items by key instead, you
    would use a dictionary.
  id: totrans-7461
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一章中，你学习了如何将项目存储在数组和字典中。要将项目存储在有序列表中，你可以使用数组，并通过索引查找每个项目。如果你想按键存储项目，则可以使用字典。
- en: Knowing about arrays and dictionaries and how to use them is a powerful building
    block for almost any programming language. Next we will learn about functions,
    another very powerful tool. Functions are blocks of code that you create and name
    to perform a specific job. After you have written a function, you can use its
    name to call it from almost anywhere in your program.
  id: totrans-7462
  prefs: []
  type: TYPE_NORMAL
  zh: 了解数组和字典以及如何使用它们是几乎任何编程语言中的一个强大基础。接下来我们将学习函数，另一个非常强大的工具。函数是你创建并命名的代码块，用于执行特定的任务。编写完函数后，你可以使用其名称从程序的几乎任何地方调用它。
- en: '**REPLACING ITEMS IN AN ARRAY**'
  id: totrans-7463
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**替换数组中的项**'
- en: 'To replace an item in an array, you set the index of the array to the new value,
    as shown here:'
  id: totrans-7464
  prefs: []
  type: TYPE_NORMAL
  zh: 要替换数组中的项，你只需将数组的索引设置为新值，如下所示：
- en: '![](Image00131.jpg)'
  id: totrans-7465
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00131.jpg)'
- en: At ➊ , we replaced the item at index 2 (the third item) with "Unicorn" because
    magical animals count as favorite animals, too! At ➋ , we replaced the item at
    index 0 (the first item) with "Bearded dragon" . No, that’s not a real dragon—it’s
    just a lizard!
  id: totrans-7466
  prefs: []
  type: TYPE_NORMAL
  zh: 在 ➊ 处，我们将索引为 2（第三个项目）的项替换为 "独角兽"，因为神奇的动物也算是最喜欢的动物！在 ➋ 处，我们将索引为 0（第一个项目）的项替换为
    "胡须龙"。不，那不是一条真正的龙——它只是一只蜥蜴！
- en: Like any time you’re working with array index numbers, you have to be sure an
    item exists in the array at that index before you change its value, or you will
    get an Index out of range error.
  id: totrans-7467
  prefs: []
  type: TYPE_NORMAL
  zh: 像每次你处理数组索引号时一样，在修改值之前，你必须确保数组中该索引位置有项，否则你会遇到索引超出范围的错误。
- en: '[Figure 6-3](text00016.html#ch06fig3) shows the error that occurs if you try
    to add "Standard poodle" using favoriteAnimals[3] = "Standard poodle" . To add
    an item to the end of an array, you should use the append(_:) method or += , as
    we covered in “[Adding Items to an Array](text00016.html#ch06lev2sec5) ” on [page
    70](text00016.html#page_70) .'
  id: totrans-7468
  prefs: []
  type: TYPE_NORMAL
  zh: '[图6-3](text00016.html#ch06fig3) 显示了如果你尝试通过 favoriteAnimals[3] = "标准贵宾犬" 添加“标准贵宾犬”时发生的错误。要向数组末尾添加项，你应该使用
    append(_:) 方法或 +=，如我们在 “[向数组添加项](text00016.html#ch06lev2sec5)” 中第 [70页](text00016.html#page_70)
    所讲。'
- en: '![Image](Image00132.jpg)'
  id: totrans-7469
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Image00132.jpg)'
- en: '*Figure 6-3: Don’t try to replace a value at an index beyond the existing array.*'
  id: totrans-7470
  prefs: []
  type: TYPE_NORMAL
  zh: '*图6-3：不要尝试在超出现有数组范围的索引位置替换值。*'
- en: Now you know how to change arrays however you might need to. You can add items,
    take items away, or replace items. Next, we’ll look at how to use the properties
    of arrays to find out even more information about them.
  id: totrans-7471
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你知道如何根据需要修改数组。你可以添加项，移除项或替换项。接下来，我们将探讨如何使用数组的属性来获取更多关于数组的信息。
- en: '![Image](Image00133.jpg)'
  id: totrans-7472
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Image00133.jpg)'
- en: '**USING ARRAY PROPERTIES**'
  id: totrans-7473
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**使用数组属性**'
- en: In addition to methods like append(_:) and removeLast() , arrays also have *properties*
    . An array’s properties are variables or constants that contain some information
    about the array. Two really helpful properties that you might use are the Boolean
    property isEmpty and the integer property count .
  id: totrans-7474
  prefs: []
  type: TYPE_NORMAL
  zh: 除了像 append(_:) 和 removeLast() 这样的操作方法，数组还有 *属性*。数组的属性是包含一些关于数组信息的变量或常量。你可能会使用的两个非常有用的属性是布尔属性
    isEmpty 和整数属性 count。
- en: The isEmpty property is true or false depending on whether the array is empty,
    and the count property will tell you how many items are in that array.
  id: totrans-7475
  prefs: []
  type: TYPE_NORMAL
  zh: isEmpty 属性为 true 或 false，取决于数组是否为空，count 属性则会告诉你数组中有多少项。
- en: 'Check out how these two properties are used in the following if-else statement:'
  id: totrans-7476
  prefs: []
  type: TYPE_NORMAL
  zh: 请查看以下 if-else 语句中如何使用这两个属性：
- en: '![Image](Image00134.jpg)'
  id: totrans-7477
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Image00134.jpg)'
- en: 'This if-else statement checks whether the array mySiblings is empty ➊ . If
    it is, then "I don''t have any siblings." is printed. But if there is something
    in the array, then the number of siblings that we have is printed: "I have 3 siblings."
    ➋ .'
  id: totrans-7478
  prefs: []
  type: TYPE_NORMAL
  zh: 这个if-else语句检查数组mySiblings是否为空 ➊。如果为空，则打印"我没有兄弟姐妹。"。但如果数组中有内容，则打印我们有几个兄弟姐妹："我有3个兄弟姐妹。"
    ➋。
- en: '**LOOPING OVER AN ARRAY**'
  id: totrans-7479
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**遍历数组**'
- en: 'Sometimes when you’re working with arrays you might want to do something to
    every item in the array. You can use a for-in loop to do that! The following code
    will print every topping in a pizzaToppings array on a separate line:'
  id: totrans-7480
  prefs: []
  type: TYPE_NORMAL
  zh: 有时在处理数组时，你可能希望对数组中的每个项目执行某个操作。你可以使用for-in循环来实现！以下代码会在单独的一行上打印pizzaToppings数组中的每个配料：
- en: '![Image](Image00135.jpg)'
  id: totrans-7481
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00135.jpg)'
- en: To write a for-in loop for the pizzaToppings array, we used the keyword for
    , followed by the constant topping , then the keyword in , and finally the name
    of our array, pizzaToppings . Then we put the statements that we want to run for
    each topping inside the braces of the for-in loop. The constant topping ➊ temporarily
    represents each pizza topping in the array as we loop through it. We could have
    chosen any name for this constant, but it’s a good idea to pick something that
    makes sense. You can see the output of this for-in loop in [Figure 6-4](text00016.html#ch06fig4)
    .
  id: totrans-7482
  prefs: []
  type: TYPE_NORMAL
  zh: 为了为pizzaToppings数组编写一个for-in循环，我们使用了关键字for，接着是常量topping，然后是关键字in，最后是我们数组的名称pizzaToppings。然后，我们将希望对每个配料执行的语句放在for-in循环的花括号内。常量topping
    ➊ 在我们循环时暂时代表数组中的每个配料。我们本可以为这个常量选择任何名字，但最好选择一个有意义的名称。你可以在[图6-4](text00016.html#ch06fig4)中看到这个for-in循环的输出。
- en: '![Image](Image00136.jpg)'
  id: totrans-7483
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00136.jpg)'
- en: '*Figure 6-4: Output of the example for-in loop*'
  id: totrans-7484
  prefs: []
  type: TYPE_NORMAL
  zh: '*图6-4：示例中的for-in循环输出*'
- en: '![Image](Image00137.jpg)'
  id: totrans-7485
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00137.jpg)'
- en: 'Using for-in loops is great for printing every value in an array. If you’re
    working with numbers, you can even use them to perform math operations on each
    item, which makes for some speedy calculations! The following code takes an array
    of numbers and calculates the square for each (the square of a number is that
    number multiplied by itself):'
  id: totrans-7486
  prefs: []
  type: TYPE_NORMAL
  zh: 使用for-in循环非常适合打印数组中的每个值。如果你正在处理数字，你甚至可以用它们对每个项目进行数学运算，这样可以加速计算！以下代码获取一个数字数组，并计算每个数字的平方（数字的平方是该数字乘以它自身）：
- en: '![Image](Image00138.jpg)'
  id: totrans-7487
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00138.jpg)'
- en: '[Figure 6-5](text00016.html#ch06fig5) shows the results.'
  id: totrans-7488
  prefs: []
  type: TYPE_NORMAL
  zh: '[图6-5](text00016.html#ch06fig5)显示了结果。'
- en: '![Image](Image00139.jpg)'
  id: totrans-7489
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00139.jpg)'
- en: '*Figure 6-5: Printing the squares for each number in the myNumbers array*'
  id: totrans-7490
  prefs: []
  type: TYPE_NORMAL
  zh: '*图6-5：打印myNumbers数组中每个数字的平方*'
- en: '**DICTIONARIES ARE KEY!**'
  id: totrans-7491
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**字典是关键！**'
- en: A *dictionary* is also a collection of values, but instead of an ordered index,
    each value has its own *key* . Because there’s no index, the values are not stored
    in any particular order. To access values in a dictionary, you look them up by
    their key.
  id: totrans-7492
  prefs: []
  type: TYPE_NORMAL
  zh: '*字典*也是一组值，但与有序索引不同，每个值都有自己的*键*。由于没有索引，值不会按特定顺序存储。要访问字典中的值，你需要通过它们的键来查找。'
- en: A key must be unique. You can’t have the same key more than once in the same
    dictionary. If there were two identical keys and you asked the computer to give
    you the value for one of them, the computer wouldn’t know which one to choose!
  id: totrans-7493
  prefs: []
  type: TYPE_NORMAL
  zh: 一个键必须是唯一的。在同一个字典中不能有相同的键。如果有两个相同的键，你让计算机返回其中一个的值，计算机就无法知道该选择哪个！
- en: Let’s take a look at how to make a dictionary and write keys that will help
    you find all the information you need.
  id: totrans-7494
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如何创建字典并写出可以帮助你找到所需所有信息的键。
- en: '![Image](Image00140.jpg)'
  id: totrans-7495
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00140.jpg)'
- en: '**INITIALIZING A DICTIONARY**'
  id: totrans-7496
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**初始化字典**'
- en: 'To create and initialize a dictionary, first write var and the name of your
    dictionary. Then write the keys and corresponding values inside a pair of square
    brackets, similar to an array. Let’s create a dictionary to store the names of
    a few US states. The key for each state will be its two-letter abbreviation:'
  id: totrans-7497
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建并初始化字典，首先写var和字典的名称。然后像数组一样，将键和值对写在一对方括号内。让我们创建一个字典，用来存储几个美国州的名称。每个州的键将是它的两字母缩写：
- en: '![](Image00141.jpg)'
  id: totrans-7498
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00141.jpg)'
- en: As you can see, there’s a colon between each key and its value, and the key/value
    pairs are separated by commas.
  id: totrans-7499
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，每个键和它的值之间都有一个冒号，键/值对之间由逗号分隔。
- en: Dictionaries are different from arrays in that they are *unordered* . Because
    of that, it’s likely that the order of the states that you see in your results
    pane ➋ is different from the order in which you entered your states ➊ . It might
    even be different than the order that’s printed in this book!
  id: totrans-7500
  prefs: []
  type: TYPE_NORMAL
  zh: 字典与数组的不同之处在于它们是*无序的*。因此，你在结果窗格 ➋ 中看到的状态的顺序，很可能与你输入状态的顺序 ➊ 不同。甚至可能与本书中打印的顺序不同！
- en: As with arrays, you can use var to make a mutable dictionary or use let to make
    an immutable dictionary.
  id: totrans-7501
  prefs: []
  type: TYPE_NORMAL
  zh: 与数组一样，你可以使用 var 来创建一个可变字典，或者使用 let 来创建一个不可变字典。
- en: 'In Swift, all of the keys of a dictionary must be the same type, and all of
    the values of a dictionary must also be the same type, but the key type doesn’t
    have to match the value type. For example, if you wanted to store a collection
    of fractions, you could use doubles for the keys and strings for the values:'
  id: totrans-7502
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Swift 中，字典的所有键必须是相同类型的，字典的所有值也必须是相同类型的，但键的类型不必与值的类型匹配。例如，如果你想存储一个分数集合，你可以使用双精度数作为键，字符串作为值：
- en: '![](Image00142.jpg)'
  id: totrans-7503
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00142.jpg)'
- en: In this dictionary, all of the keys must be doubles, and all of the values must
    be strings. Again, you’ll see that the order of the numbers in the results pane
    can be quite different from the order in which you wrote the fractions in your
    dictionary. This is fine because you don’t need to know the order to access anything.
    You can find any item that you need by its key. Let’s see how!
  id: totrans-7504
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个字典中，所有的键必须是双精度数，所有的值必须是字符串。再次提醒，结果窗格中的数字顺序可能与您在字典中写入分数的顺序有很大不同。这是正常的，因为你不需要知道顺序来访问任何内容。你可以通过键找到所需的任何项目。让我们来看一下！
- en: '**ACCESSING VALUES IN A DICTIONARY**'
  id: totrans-7505
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**访问字典中的值**'
- en: 'Looking up a value in a dictionary is similar to how you access a value in
    an array except that you use a key inside the square brackets instead of an index,
    like this: usStates["TX"] .'
  id: totrans-7506
  prefs: []
  type: TYPE_NORMAL
  zh: 在字典中查找值类似于在数组中查找值，不同之处在于你使用的是方括号内的键，而不是索引，例如：usStates["TX"]。
- en: There is a big difference, however, in how Swift returns the values from a dictionary.
    When you access a value at an index of an array, you are simply given the value.
    When you access a value with a key in a dictionary, you are given an optional.
  id: totrans-7507
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，Swift 在从字典返回值时有一个很大的不同。当你访问数组中的一个索引位置的值时，你只会得到该值。而当你使用字典中的键访问值时，你会得到一个可选值。
- en: In [Chapter 5](text00015.html#ch05) , you learned that optionals might contain
    a value or might be nil . The reason Swift returns optionals when you’re looking
    up items in a dictionary is that the key you used might not exist in the dictionary,
    in which case there’s no value to access. Trying to access a value that doesn’t
    exist would give you a big fat error! To avoid that problem, Swift returns optionals.
    That means you need to unwrap any value you get out of a dictionary before you
    can do anything with it.
  id: totrans-7508
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第 5 章](text00015.html#ch05)中，你学到可选值可能包含一个值，也可能是 nil。Swift 在查找字典中的项时返回可选值的原因是，你使用的键可能在字典中不存在，这种情况下就没有值可以访问。尝试访问一个不存在的值会导致一个严重错误！为了避免这个问题，Swift
    返回可选值。这意味着你需要解包从字典中获取的任何值，才能对其进行操作。
- en: 'To unwrap an optional, first you check whether it exists using an if-let statement,
    just like we did in [Chapter 5](text00015.html#ch05) . The following code shows
    you how to get a value out of a dictionary:'
  id: totrans-7509
  prefs: []
  type: TYPE_NORMAL
  zh: 要解包一个可选值，首先你需要使用 if-let 语句检查它是否存在，就像我们在[第 5 章](text00015.html#ch05) 中所做的那样。以下代码展示了如何从字典中获取一个值：
- en: '![Image](Image00143.jpg)'
  id: totrans-7510
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Image00143.jpg)'
- en: To retrieve "Texas" from the dictionary, we use if let to set a constant loneStarState
    to usStates["TX"] ➊ . Because we have this state in our dictionary, the line I
    have Texas in my dictionary. is printed. Next we try to access a state that is
    not in our dictionary by using the key usStates["FL"] ➋ . Thankfully, because
    we used an if-let statement, the program won’t crash when the computer can’t find
    this state. Instead, I don't have that state in my dictionary. is printed.
  id: totrans-7511
  prefs: []
  type: TYPE_NORMAL
  zh: 要从字典中获取“德州”，我们使用 if let 将常量 loneStarState 设置为 usStates["TX"] ➊。由于字典中包含该州，程序会打印出“我在字典中找到了德州”。接下来，我们尝试通过使用键
    usStates["FL"] ➋ 访问一个字典中不存在的州。幸运的是，因为我们使用了 if-let 语句，当计算机找不到这个州时，程序不会崩溃。相反，程序会打印出“字典中没有这个州”。
- en: '**ADDING ITEMS TO A DICTIONARY**'
  id: totrans-7512
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**向字典添加项**'
- en: 'To add an item to a dictionary, first write the name of your dictionary and
    assign the new item to the key you want it to have in the dictionary. Let’s add
    "Minnesota" to our usStates dictionary:'
  id: totrans-7513
  prefs: []
  type: TYPE_NORMAL
  zh: 要向字典中添加一个项，首先写出字典的名称，并将新项分配给你希望它在字典中拥有的键。让我们把 "Minnesota" 添加到我们的 usStates 字典中：
- en: '![](Image00144.jpg)'
  id: totrans-7514
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00144.jpg)'
- en: 'Now when you look at usStates , you’ll see that it’s updated to ["MN": "Minnesota",
    "WA": "Washington", "MA": "Massachusetts", "TX": "Texas"] . Remember, because
    you don’t have to rely on indices, your new dictionary item might appear anywhere
    in the dictionary.'
  id: totrans-7515
  prefs: []
  type: TYPE_NORMAL
  zh: '现在，当你查看 usStates 时，你会看到它已经更新为 ["MN": "Minnesota", "WA": "Washington", "MA":
    "Massachusetts", "TX": "Texas"]。记住，因为你不需要依赖索引，所以新添加的字典项可能出现在字典的任何位置。'
- en: '**REMOVING ITEMS FROM A DICTIONARY**'
  id: totrans-7516
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**从字典中删除项**'
- en: Removing an item from a dictionary is quite simple; you do so by setting the
    value to nil . Because the values in dictionaries are returned as optionals, you
    don’t have to worry about nil causing any problems in your dictionary.
  id: totrans-7517
  prefs: []
  type: TYPE_NORMAL
  zh: 从字典中删除一项非常简单；你只需将该值设置为 nil。因为字典中的值作为可选项返回，所以你不必担心 nil 会导致字典中的问题。
- en: '![](Image00145.jpg)'
  id: totrans-7518
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00145.jpg)'
- en: 'You can see that after you remove the value at the key "MA" , usStates is updated
    to ["MN": "Minnesota", "WA": "Washington", "TX": "Texas"] . Remember that nil
    is special and means that there’s no value at all. That’s why you don’t see "MA":
    nil in our dictionary.'
  id: totrans-7519
  prefs: []
  type: TYPE_NORMAL
  zh: '你可以看到，在你删除 "MA" 键对应的值后，usStates 被更新为 ["MN": "Minnesota", "WA": "Washington",
    "TX": "Texas"]。记住，nil 是特殊的，它表示没有值。这就是为什么你在我们的字典中看不到 "MA": nil。'
- en: '**REPLACING ITEMS IN A DICTIONARY**'
  id: totrans-7520
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**替换字典中的项**'
- en: 'Replacing an item in a dictionary is also easy. It works the same was as replacing
    an item in an array. You just set the item that you want to replace to something
    else. Say you create a dictionary of fruit colors:'
  id: totrans-7521
  prefs: []
  type: TYPE_NORMAL
  zh: 替换字典中的项也很简单。它的工作原理与替换数组中的项相同。你只需要将你想替换的项设置为其他值。假设你创建了一个水果颜色的字典：
- en: '![](Image00146.jpg)'
  id: totrans-7522
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00146.jpg)'
- en: At first we had the value "apple" for "red" , but then we decided that "raspberry"
    is a better fruit to use since sometimes apples are green or yellow. To replace
    "apple" with "raspberry" , we set colorFruits["red"] to its new value ➊ .
  id: totrans-7523
  prefs: []
  type: TYPE_NORMAL
  zh: 一开始我们为 "red" 设置了值 "apple"，但后来我们决定用 "raspberry" 替代，因为有时候苹果是绿色或黄色的。要将 "apple"
    替换为 "raspberry"，我们将 colorFruits["red"] 设置为其新值 ➊。
- en: You may remember that this is the same way we entered a new value into a dictionary.
    If the key already exists in the dictionary, then the value for that key is replaced.
    If the key doesn’t already exist, then the new key/value pair will be added to
    the dictionary.
  id: totrans-7524
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能记得，这与我们向字典中添加新值的方式是一样的。如果键已经存在于字典中，那么该键的值会被替换。如果键不存在，则会将新的键/值对添加到字典中。
- en: '![Image](Image00147.jpg)'
  id: totrans-7525
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00147.jpg)'
- en: '**USING DICTIONARY PROPERTIES**'
  id: totrans-7526
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**使用字典属性**'
- en: 'Like an array, a dictionary also has an isEmpty property and a count property.
    For example, the following code shows how you can use the isEmpty property to
    check if a dictionary is empty, and if it isn’t empty, the count property checks
    how many items you have. Imagine you have a basket of fruit for sale. You can
    use these properties to help you keep track of everything:'
  id: totrans-7527
  prefs: []
  type: TYPE_NORMAL
  zh: 像数组一样，字典也有 isEmpty 属性和 count 属性。例如，下面的代码展示了如何使用 isEmpty 属性检查字典是否为空，如果不为空，count
    属性则用来检查字典中有多少项。假设你有一个水果篮子在出售，你可以使用这些属性帮助你跟踪一切：
- en: '![Image](Image00148.jpg)'
  id: totrans-7528
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00148.jpg)'
- en: 'A dictionary also has two special properties: keys , which contains all of
    the dictionary’s keys, and values , which contains all of its values. We’ll use
    these two properties when we loop through the dictionary.'
  id: totrans-7529
  prefs: []
  type: TYPE_NORMAL
  zh: 字典还有两个特殊属性：keys，包含字典的所有键；values，包含字典的所有值。我们在遍历字典时会用到这两个属性。
- en: Let’s write some code that loops through our fruit baskets and prints the price
    of each fruit.
  id: totrans-7530
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们写一些代码，遍历我们的水果篮子并打印出每个水果的价格。
- en: '**LOOPING OVER A DICTIONARY**'
  id: totrans-7531
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**遍历字典**'
- en: 'You can loop through a dictionary using a for-in loop. Because each item has
    a key and a value, you can do this in two different ways. This is how to loop
    through a dictionary using its keys:'
  id: totrans-7532
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用 for-in 循环遍历字典。因为每个项都有一个键和值，所以你可以通过两种不同的方式来遍历。以下是如何通过键遍历字典的方式：
- en: '![Image](Image00149.jpg)'
  id: totrans-7533
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00149.jpg)'
- en: Here we use the dictionary’s keys property ➊ to loop through fruitBasket and
    print its contents. We start by writing the keyword for , followed by a constant
    name fruit for the dictionary key, the keyword in , the dictionary name, a period,
    and keys .
  id: totrans-7534
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们使用字典的 keys 属性 ➊ 遍历 fruitBasket 并打印其内容。我们首先编写关键字 for，接着是常量名 fruit（代表字典的键），然后是关键字
    in，字典的名称，点符号，最后是 keys。
- en: Inside the braces of our for-in loop, we have access to both the key, which
    we call fruit ➋ , and the value at that key when we force-unwrap its contents
    with fruitBasket[fruit]! ➌ . That value will be the fruit’s price.
  id: totrans-7535
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的 for-in 循环的大括号内，我们可以访问到键（我们称之为 fruit ➋），以及通过 fruitBasket[fruit]! ➌ 强制解包后该键对应的值。这个值就是水果的价格。
- en: In this case, it’s safe to force-unwrap the value using an exclamation point
    because we know that the fruit key we’re using is definitely inside the dictionary.
  id: totrans-7536
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，由于我们知道所使用的果实键一定在字典中，因此可以安全地使用感叹号强制解包该值。
- en: Any code we put inside the for-in loop will run once for every key in our dictionary.
    So you should see the print statement display three times.
  id: totrans-7537
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在 for-in 循环中放入的任何代码都会在字典中的每个键上运行一次。因此，你应该会看到打印语句显示三次。
- en: 'We can also loop through the dictionary using its values property:'
  id: totrans-7538
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以使用字典的 values 属性进行循环：
- en: '![Image](Image00150.jpg)'
  id: totrans-7539
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Image00150.jpg)'
- en: We use the same style of for-in loop, but now we use a constant to refer to
    each value, which we call price , in the values property. When looping through
    values, we don’t have access to the keys from inside the loop.
  id: totrans-7540
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用相同类型的 for-in 循环，但这次我们使用常量来引用每个值，我们称之为 price，该值来自 values 属性。在循环值时，我们无法从循环内部访问键。
- en: Another difference to note is that price is not an optional because it’s accessed
    directly as a value in the fruitBasket dictionary. That means we don’t have to
    unwrap it. You should still see the print statement printed three times. [Figure
    6-6](text00016.html#ch06fig6) shows the output of both loops.
  id: totrans-7541
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个需要注意的区别是，价格不是可选的，因为它直接作为 fruitBasket 字典中的值进行访问。这意味着我们不需要解包它。你应该仍然会看到打印语句打印三次。[图
    6-6](text00016.html#ch06fig6) 显示了两个循环的输出。
- en: '![Image](Image00151.jpg)'
  id: totrans-7542
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Image00151.jpg)'
- en: '*Figure 6-6: Looping through the keys and values of a dictionary with a for-in
    loop*'
  id: totrans-7543
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 6-6：使用 for-in 循环遍历字典的键和值*'
- en: The order of your results might be slightly different from ours. That’s because
    the items in a dictionary aren’t in a numbered order like they are in an array!
    And because the order is not guaranteed, you might see a different order printed
    if you run the same code again.
  id: totrans-7544
  prefs: []
  type: TYPE_NORMAL
  zh: 你的结果顺序可能与我们的略有不同。这是因为字典中的项不像数组那样是按编号顺序排列的！并且由于顺序没有保证，如果你再次运行相同的代码，可能会看到不同的打印顺序。
- en: '**WHAT YOU LEARNED**'
  id: totrans-7545
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**你学到的内容**'
- en: In this chapter, you learned how to store collections of items in an array and
    in a dictionary. To store items in an ordered list, you would use an array and
    look up each item by its index. If you wanted to store items by key instead, you
    would use a dictionary.
  id: totrans-7546
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你学会了如何在数组和字典中存储项。要将项存储在有序列表中，你可以使用数组，并通过索引查找每个项。如果你想按键存储项，则应使用字典。
- en: Knowing about arrays and dictionaries and how to use them is a powerful building
    block for almost any programming language. Next we will learn about functions,
    another very powerful tool. Functions are blocks of code that you create and name
    to perform a specific job. After you have written a function, you can use its
    name to call it from almost anywhere in your program.
  id: totrans-7547
  prefs: []
  type: TYPE_NORMAL
  zh: 了解数组和字典以及如何使用它们，是几乎任何编程语言中强大基础构建块之一。接下来，我们将学习函数，另一种非常强大的工具。函数是你创建并命名的一段代码，用来执行特定的任务。在编写了一个函数后，你可以通过函数名在程序中的几乎任何地方调用它。
- en: 'To replace an item in an array, you set the index of the array to the new value,
    as shown here:'
  id: totrans-7548
  prefs: []
  type: TYPE_NORMAL
  zh: 要替换数组中的项，你需要将数组索引设置为新值，如下所示：
- en: '![](Image00131.jpg)'
  id: totrans-7549
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00131.jpg)'
- en: At ➊ , we replaced the item at index 2 (the third item) with "Unicorn" because
    magical animals count as favorite animals, too! At ➋ , we replaced the item at
    index 0 (the first item) with "Bearded dragon" . No, that’s not a real dragon—it’s
    just a lizard!
  id: totrans-7550
  prefs: []
  type: TYPE_NORMAL
  zh: 在 ➊ 处，我们将索引 2（第三项）处的项替换为“独角兽”，因为魔法动物也算是最喜欢的动物！在 ➋ 处，我们将索引 0（第一项）处的项替换为“胡须龙”。不，这不是一只真正的龙——它只是一只蜥蜴！
- en: Like any time you’re working with array index numbers, you have to be sure an
    item exists in the array at that index before you change its value, or you will
    get an Index out of range error.
  id: totrans-7551
  prefs: []
  type: TYPE_NORMAL
  zh: 就像每次你使用数组索引时，你必须确保该索引处的项在数组中存在，才能修改其值，否则你会遇到“超出索引范围”的错误。
- en: '[Figure 6-3](text00016.html#ch06fig3) shows the error that occurs if you try
    to add "Standard poodle" using favoriteAnimals[3] = "Standard poodle" . To add
    an item to the end of an array, you should use the append(_:) method or += , as
    we covered in “[Adding Items to an Array](text00016.html#ch06lev2sec5) ” on [page
    70](text00016.html#page_70) .'
  id: totrans-7552
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 6-3](text00016.html#ch06fig3) 显示了如果你尝试通过 favoriteAnimals[3] = "Standard
    poodle" 添加 "标准贵宾犬" 时出现的错误。要将项目添加到数组的末尾，应该使用 append(_:) 方法或 +=，就像我们在 “[向数组添加项](text00016.html#ch06lev2sec5)”
    中所介绍的那样，在 [第 70 页](text00016.html#page_70)。'
- en: '![Image](Image00132.jpg)'
  id: totrans-7553
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00132.jpg)'
- en: '*Figure 6-3: Don’t try to replace a value at an index beyond the existing array.*'
  id: totrans-7554
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 6-3：不要尝试在超出现有数组范围的索引位置替换值。*'
- en: Now you know how to change arrays however you might need to. You can add items,
    take items away, or replace items. Next, we’ll look at how to use the properties
    of arrays to find out even more information about them.
  id: totrans-7555
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你知道如何根据需要更改数组。你可以添加项、删除项或替换项。接下来，我们将了解如何使用数组的属性来获取更多信息。
- en: '![Image](Image00133.jpg)'
  id: totrans-7556
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00133.jpg)'
- en: '**USING ARRAY PROPERTIES**'
  id: totrans-7557
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**使用数组属性**'
- en: In addition to methods like append(_:) and removeLast() , arrays also have *properties*
    . An array’s properties are variables or constants that contain some information
    about the array. Two really helpful properties that you might use are the Boolean
    property isEmpty and the integer property count .
  id: totrans-7558
  prefs: []
  type: TYPE_NORMAL
  zh: 除了像 append(_:) 和 removeLast() 这样的操作方法外，数组还有 *属性*。数组的属性是包含数组相关信息的变量或常量。有两个非常有用的属性，你可能会使用，它们分别是布尔类型属性
    isEmpty 和整数类型属性 count。
- en: The isEmpty property is true or false depending on whether the array is empty,
    and the count property will tell you how many items are in that array.
  id: totrans-7559
  prefs: []
  type: TYPE_NORMAL
  zh: isEmpty 属性根据数组是否为空返回 true 或 false，而 count 属性会告诉你数组中有多少项。
- en: 'Check out how these two properties are used in the following if-else statement:'
  id: totrans-7560
  prefs: []
  type: TYPE_NORMAL
  zh: 看一下如何在以下 if-else 语句中使用这两个属性：
- en: '![Image](Image00134.jpg)'
  id: totrans-7561
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00134.jpg)'
- en: 'This if-else statement checks whether the array mySiblings is empty ➊ . If
    it is, then "I don''t have any siblings." is printed. But if there is something
    in the array, then the number of siblings that we have is printed: "I have 3 siblings."
    ➋ .'
  id: totrans-7562
  prefs: []
  type: TYPE_NORMAL
  zh: 这个 if-else 语句检查数组 mySiblings 是否为空 ➊。如果为空，则打印 "我没有兄弟姐妹"。但如果数组中有内容，则会打印我们有多少个兄弟姐妹："我有
    3 个兄弟姐妹" ➋。
- en: '**LOOPING OVER AN ARRAY**'
  id: totrans-7563
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**遍历数组**'
- en: 'Sometimes when you’re working with arrays you might want to do something to
    every item in the array. You can use a for-in loop to do that! The following code
    will print every topping in a pizzaToppings array on a separate line:'
  id: totrans-7564
  prefs: []
  type: TYPE_NORMAL
  zh: 有时在处理数组时，你可能想对数组中的每个项目做一些操作。你可以使用 for-in 循环来实现！以下代码会将 pizzaToppings 数组中的每个配料分别打印到新的一行：
- en: '![Image](Image00135.jpg)'
  id: totrans-7565
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00135.jpg)'
- en: To write a for-in loop for the pizzaToppings array, we used the keyword for
    , followed by the constant topping , then the keyword in , and finally the name
    of our array, pizzaToppings . Then we put the statements that we want to run for
    each topping inside the braces of the for-in loop. The constant topping ➊ temporarily
    represents each pizza topping in the array as we loop through it. We could have
    chosen any name for this constant, but it’s a good idea to pick something that
    makes sense. You can see the output of this for-in loop in [Figure 6-4](text00016.html#ch06fig4)
    .
  id: totrans-7566
  prefs: []
  type: TYPE_NORMAL
  zh: 为了编写 pizzaToppings 数组的 for-in 循环，我们使用了关键字 for，接着是常量 topping，然后是关键字 in，最后是我们的数组名称
    pizzaToppings。然后我们将希望对每个 topping 执行的语句放在 for-in 循环的大括号内。常量 topping ➊ 在循环过程中暂时代表数组中的每个披萨配料。我们可以为这个常量选择任何名称，但最好选择一个有意义的名字。你可以在
    [图 6-4](text00016.html#ch06fig4) 中看到这个 for-in 循环的输出。
- en: '![Image](Image00136.jpg)'
  id: totrans-7567
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00136.jpg)'
- en: '*Figure 6-4: Output of the example for-in loop*'
  id: totrans-7568
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 6-4：示例中 for-in 循环的输出结果*'
- en: '![Image](Image00137.jpg)'
  id: totrans-7569
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00137.jpg)'
- en: 'Using for-in loops is great for printing every value in an array. If you’re
    working with numbers, you can even use them to perform math operations on each
    item, which makes for some speedy calculations! The following code takes an array
    of numbers and calculates the square for each (the square of a number is that
    number multiplied by itself):'
  id: totrans-7570
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 for-in 循环很适合打印数组中的每个值。如果你处理的是数字，甚至可以用它们对每个项目进行数学运算，这样能迅速进行计算！以下代码对一个数字数组中的每个数字计算平方（数字的平方是该数字与自身相乘）：
- en: '![Image](Image00138.jpg)'
  id: totrans-7571
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00138.jpg)'
- en: '[Figure 6-5](text00016.html#ch06fig5) shows the results.'
  id: totrans-7572
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 6-5](text00016.html#ch06fig5) 显示了结果。'
- en: '![Image](Image00139.jpg)'
  id: totrans-7573
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00139.jpg)'
- en: '*Figure 6-5: Printing the squares for each number in the myNumbers array*'
  id: totrans-7574
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 6-5：打印 myNumbers 数组中每个数字的平方*'
- en: '**DICTIONARIES ARE KEY!**'
  id: totrans-7575
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**字典是关键！**'
- en: A *dictionary* is also a collection of values, but instead of an ordered index,
    each value has its own *key* . Because there’s no index, the values are not stored
    in any particular order. To access values in a dictionary, you look them up by
    their key.
  id: totrans-7576
  prefs: []
  type: TYPE_NORMAL
  zh: '*字典* 也是一个值的集合，但不同于有序索引，每个值都有自己的 *键*。由于没有索引，值不是按任何特定顺序存储的。要访问字典中的值，你需要通过键来查找它们。'
- en: A key must be unique. You can’t have the same key more than once in the same
    dictionary. If there were two identical keys and you asked the computer to give
    you the value for one of them, the computer wouldn’t know which one to choose!
  id: totrans-7577
  prefs: []
  type: TYPE_NORMAL
  zh: 键必须是唯一的。你不能在同一个字典中使用相同的键。如果有两个相同的键，当你要求计算机返回其中一个键的值时，计算机就不知道该选择哪一个！
- en: Let’s take a look at how to make a dictionary and write keys that will help
    you find all the information you need.
  id: totrans-7578
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看一下如何创建一个字典，并写下键来帮助你找到所有需要的信息。
- en: '![Image](Image00140.jpg)'
  id: totrans-7579
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00140.jpg)'
- en: '**INITIALIZING A DICTIONARY**'
  id: totrans-7580
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**初始化字典**'
- en: 'To create and initialize a dictionary, first write var and the name of your
    dictionary. Then write the keys and corresponding values inside a pair of square
    brackets, similar to an array. Let’s create a dictionary to store the names of
    a few US states. The key for each state will be its two-letter abbreviation:'
  id: totrans-7581
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建和初始化一个字典，首先写上 `var` 和字典的名称。然后，将键和值对写在一对方括号内，类似于数组。让我们创建一个字典来存储一些美国州的名称。每个州的键将是它的两字母缩写：
- en: '![](Image00141.jpg)'
  id: totrans-7582
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00141.jpg)'
- en: As you can see, there’s a colon between each key and its value, and the key/value
    pairs are separated by commas.
  id: totrans-7583
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，每个键和值之间有一个冒号，键/值对之间由逗号分隔。
- en: Dictionaries are different from arrays in that they are *unordered* . Because
    of that, it’s likely that the order of the states that you see in your results
    pane ➋ is different from the order in which you entered your states ➊ . It might
    even be different than the order that’s printed in this book!
  id: totrans-7584
  prefs: []
  type: TYPE_NORMAL
  zh: 字典与数组的不同之处在于它们是 *无序的*。因此，你在结果面板中看到的州的顺序 ➋ 很可能与输入州的顺序 ➊ 不同。它甚至可能与本书中打印的顺序不同！
- en: As with arrays, you can use var to make a mutable dictionary or use let to make
    an immutable dictionary.
  id: totrans-7585
  prefs: []
  type: TYPE_NORMAL
  zh: 和数组一样，你可以使用 `var` 来创建一个可变字典，或者使用 `let` 来创建一个不可变字典。
- en: 'In Swift, all of the keys of a dictionary must be the same type, and all of
    the values of a dictionary must also be the same type, but the key type doesn’t
    have to match the value type. For example, if you wanted to store a collection
    of fractions, you could use doubles for the keys and strings for the values:'
  id: totrans-7586
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Swift 中，字典的所有键必须是相同类型，字典的所有值也必须是相同类型，但键的类型不必与值的类型匹配。例如，如果你想存储一个分数集合，你可以使用双精度浮点数作为键，使用字符串作为值：
- en: '![](Image00142.jpg)'
  id: totrans-7587
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00142.jpg)'
- en: In this dictionary, all of the keys must be doubles, and all of the values must
    be strings. Again, you’ll see that the order of the numbers in the results pane
    can be quite different from the order in which you wrote the fractions in your
    dictionary. This is fine because you don’t need to know the order to access anything.
    You can find any item that you need by its key. Let’s see how!
  id: totrans-7588
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个字典中，所有的键必须是双精度浮点数（doubles），而所有的值必须是字符串（strings）。再次强调，你会发现结果面板中的数字顺序可能与字典中分数的顺序完全不同。这没关系，因为你不需要知道顺序就可以访问任何内容。你可以通过键找到任何你需要的项。让我们来看一下如何操作！
- en: '**ACCESSING VALUES IN A DICTIONARY**'
  id: totrans-7589
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**访问字典中的值**'
- en: 'Looking up a value in a dictionary is similar to how you access a value in
    an array except that you use a key inside the square brackets instead of an index,
    like this: usStates["TX"] .'
  id: totrans-7590
  prefs: []
  type: TYPE_NORMAL
  zh: 在字典中查找一个值类似于在数组中访问一个值，只是你需要在方括号中使用键，而不是索引，像这样：`usStates["TX"]`。
- en: There is a big difference, however, in how Swift returns the values from a dictionary.
    When you access a value at an index of an array, you are simply given the value.
    When you access a value with a key in a dictionary, you are given an optional.
  id: totrans-7591
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，Swift 在从字典中返回值时有很大不同。当你访问数组中的某个索引的值时，你只会得到那个值。而当你通过键访问字典中的值时，你得到的是一个可选值。
- en: In [Chapter 5](text00015.html#ch05) , you learned that optionals might contain
    a value or might be nil . The reason Swift returns optionals when you’re looking
    up items in a dictionary is that the key you used might not exist in the dictionary,
    in which case there’s no value to access. Trying to access a value that doesn’t
    exist would give you a big fat error! To avoid that problem, Swift returns optionals.
    That means you need to unwrap any value you get out of a dictionary before you
    can do anything with it.
  id: totrans-7592
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第5章](text00015.html#ch05)中，你学到过可选项可能包含值，也可能是 nil。Swift 返回可选项的原因是，当你查找字典中的项时，所使用的键可能在字典中不存在，在这种情况下没有值可以访问。尝试访问不存在的值会导致一个严重的错误！为了避免这个问题，Swift
    返回可选项。这意味着，在你对字典中的值做任何操作之前，你需要解包它。
- en: 'To unwrap an optional, first you check whether it exists using an if-let statement,
    just like we did in [Chapter 5](text00015.html#ch05) . The following code shows
    you how to get a value out of a dictionary:'
  id: totrans-7593
  prefs: []
  type: TYPE_NORMAL
  zh: 要解包一个可选项，首先你需要使用 if-let 语句检查它是否存在，就像我们在[第5章](text00015.html#ch05)中做的那样。以下代码展示了如何从字典中获取一个值：
- en: '![Image](Image00143.jpg)'
  id: totrans-7594
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00143.jpg)'
- en: To retrieve "Texas" from the dictionary, we use if let to set a constant loneStarState
    to usStates["TX"] ➊ . Because we have this state in our dictionary, the line I
    have Texas in my dictionary. is printed. Next we try to access a state that is
    not in our dictionary by using the key usStates["FL"] ➋ . Thankfully, because
    we used an if-let statement, the program won’t crash when the computer can’t find
    this state. Instead, I don't have that state in my dictionary. is printed.
  id: totrans-7595
  prefs: []
  type: TYPE_NORMAL
  zh: 要从字典中检索 "Texas"，我们使用 if let 将常量 loneStarState 设置为 `usStates["TX"]` ➊ 。因为字典中有这个州，"I
    have Texas in my dictionary." 这行会被打印出来。接下来，我们尝试通过使用键 `usStates["FL"]` ➋ 访问一个不在字典中的州。幸运的是，因为我们使用了
    if-let 语句，当计算机找不到这个州时，程序不会崩溃。相反，"I don't have that state in my dictionary." 这行会被打印出来。
- en: '**ADDING ITEMS TO A DICTIONARY**'
  id: totrans-7596
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**向字典中添加项**'
- en: 'To add an item to a dictionary, first write the name of your dictionary and
    assign the new item to the key you want it to have in the dictionary. Let’s add
    "Minnesota" to our usStates dictionary:'
  id: totrans-7597
  prefs: []
  type: TYPE_NORMAL
  zh: 要向字典中添加项，首先写下字典的名称，并将新项分配给你希望它在字典中拥有的键。让我们将 "Minnesota" 添加到我们的 `usStates` 字典中：
- en: '![](Image00144.jpg)'
  id: totrans-7598
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00144.jpg)'
- en: 'Now when you look at usStates , you’ll see that it’s updated to ["MN": "Minnesota",
    "WA": "Washington", "MA": "Massachusetts", "TX": "Texas"] . Remember, because
    you don’t have to rely on indices, your new dictionary item might appear anywhere
    in the dictionary.'
  id: totrans-7599
  prefs: []
  type: TYPE_NORMAL
  zh: '现在当你查看 `usStates` 时，你会看到它已更新为 ["MN": "Minnesota", "WA": "Washington", "MA":
    "Massachusetts", "TX": "Texas"] 。记住，因为你不需要依赖索引，所以新的字典项可能出现在字典中的任何位置。'
- en: '**REMOVING ITEMS FROM A DICTIONARY**'
  id: totrans-7600
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**从字典中移除项**'
- en: Removing an item from a dictionary is quite simple; you do so by setting the
    value to nil . Because the values in dictionaries are returned as optionals, you
    don’t have to worry about nil causing any problems in your dictionary.
  id: totrans-7601
  prefs: []
  type: TYPE_NORMAL
  zh: 从字典中移除项也非常简单；你可以通过将值设置为 nil 来实现。因为字典中的值是作为可选项返回的，所以你不必担心 nil 会导致字典出现问题。
- en: '![](Image00145.jpg)'
  id: totrans-7602
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00145.jpg)'
- en: 'You can see that after you remove the value at the key "MA" , usStates is updated
    to ["MN": "Minnesota", "WA": "Washington", "TX": "Texas"] . Remember that nil
    is special and means that there’s no value at all. That’s why you don’t see "MA":
    nil in our dictionary.'
  id: totrans-7603
  prefs: []
  type: TYPE_NORMAL
  zh: '你可以看到，在移除键为 "MA" 的值后，`usStates` 被更新为 ["MN": "Minnesota", "WA": "Washington",
    "TX": "Texas"] 。记住，nil 是特殊的，意味着根本没有值。这就是为什么你在我们的字典中看不到 "MA": nil 的原因。'
- en: '**REPLACING ITEMS IN A DICTIONARY**'
  id: totrans-7604
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**替换字典中的项**'
- en: 'Replacing an item in a dictionary is also easy. It works the same was as replacing
    an item in an array. You just set the item that you want to replace to something
    else. Say you create a dictionary of fruit colors:'
  id: totrans-7605
  prefs: []
  type: TYPE_NORMAL
  zh: 替换字典中的项也很简单。它的工作方式与替换数组中的项相同。你只需要将你想替换的项设置为其他值。假设你创建了一个水果颜色的字典：
- en: '![](Image00146.jpg)'
  id: totrans-7606
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00146.jpg)'
- en: At first we had the value "apple" for "red" , but then we decided that "raspberry"
    is a better fruit to use since sometimes apples are green or yellow. To replace
    "apple" with "raspberry" , we set colorFruits["red"] to its new value ➊ .
  id: totrans-7607
  prefs: []
  type: TYPE_NORMAL
  zh: 起初我们为 "red" 设置了 "apple" 的值，但后来我们决定 "raspberry" 是更好的水果，因为有时候苹果是绿色或黄色的。为了将 "apple"
    替换为 "raspberry"，我们将 `colorFruits["red"]` 设置为它的新值 ➊ 。
- en: You may remember that this is the same way we entered a new value into a dictionary.
    If the key already exists in the dictionary, then the value for that key is replaced.
    If the key doesn’t already exist, then the new key/value pair will be added to
    the dictionary.
  id: totrans-7608
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能记得，这与我们向字典中添加新值的方式相同。如果键已经存在于字典中，那么该键的值将被替换。如果键不存在，新的键值对将被添加到字典中。
- en: '![Image](Image00147.jpg)'
  id: totrans-7609
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00147.jpg)'
- en: '**USING DICTIONARY PROPERTIES**'
  id: totrans-7610
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**使用字典属性**'
- en: 'Like an array, a dictionary also has an isEmpty property and a count property.
    For example, the following code shows how you can use the isEmpty property to
    check if a dictionary is empty, and if it isn’t empty, the count property checks
    how many items you have. Imagine you have a basket of fruit for sale. You can
    use these properties to help you keep track of everything:'
  id: totrans-7611
  prefs: []
  type: TYPE_NORMAL
  zh: 像数组一样，字典也有 isEmpty 属性和 count 属性。例如，下面的代码展示了如何使用 isEmpty 属性来检查字典是否为空，如果不为空，count
    属性则检查字典中有多少项。假设你有一个待售的水果篮。你可以使用这些属性来帮助你跟踪所有内容：
- en: '![Image](Image00148.jpg)'
  id: totrans-7612
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00148.jpg)'
- en: 'A dictionary also has two special properties: keys , which contains all of
    the dictionary’s keys, and values , which contains all of its values. We’ll use
    these two properties when we loop through the dictionary.'
  id: totrans-7613
  prefs: []
  type: TYPE_NORMAL
  zh: 字典还有两个特殊的属性：keys，它包含字典的所有键，以及 values，它包含字典的所有值。在遍历字典时，我们将使用这两个属性。
- en: Let’s write some code that loops through our fruit baskets and prints the price
    of each fruit.
  id: totrans-7614
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们编写一些代码，遍历我们的水果篮，并打印出每个水果的价格。
- en: '**LOOPING OVER A DICTIONARY**'
  id: totrans-7615
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**遍历字典**'
- en: 'You can loop through a dictionary using a for-in loop. Because each item has
    a key and a value, you can do this in two different ways. This is how to loop
    through a dictionary using its keys:'
  id: totrans-7616
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用 for-in 循环遍历字典。因为每个项目都有一个键和值，所以你可以用两种不同的方式来实现这一点。这是通过键遍历字典的方法：
- en: '![Image](Image00149.jpg)'
  id: totrans-7617
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00149.jpg)'
- en: Here we use the dictionary’s keys property ➊ to loop through fruitBasket and
    print its contents. We start by writing the keyword for , followed by a constant
    name fruit for the dictionary key, the keyword in , the dictionary name, a period,
    and keys .
  id: totrans-7618
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们使用字典的 keys 属性 ➊ 来遍历 fruitBasket 并打印其内容。我们首先写下 for 关键字，然后是一个常量名 fruit 作为字典的键，接着是
    in 关键字、字典名、一个句点和 keys。
- en: Inside the braces of our for-in loop, we have access to both the key, which
    we call fruit ➋ , and the value at that key when we force-unwrap its contents
    with fruitBasket[fruit]! ➌ . That value will be the fruit’s price.
  id: totrans-7619
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的 for-in 循环的大括号内，我们可以访问到键，也就是我们称之为 fruit ➋ 的部分，以及通过强制解包 `fruitBasket[fruit]!`
    ➌ 获取到的该键对应的值。这个值就是水果的价格。
- en: In this case, it’s safe to force-unwrap the value using an exclamation point
    because we know that the fruit key we’re using is definitely inside the dictionary.
  id: totrans-7620
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，使用感叹号强制解包值是安全的，因为我们知道我们使用的水果键肯定在字典中。
- en: Any code we put inside the for-in loop will run once for every key in our dictionary.
    So you should see the print statement display three times.
  id: totrans-7621
  prefs: []
  type: TYPE_NORMAL
  zh: 我们放入 for-in 循环中的代码会针对字典中的每个键运行一次。因此，你应该会看到打印语句显示三次。
- en: 'We can also loop through the dictionary using its values property:'
  id: totrans-7622
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以通过字典的 values 属性来遍历字典：
- en: '![Image](Image00150.jpg)'
  id: totrans-7623
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00150.jpg)'
- en: We use the same style of for-in loop, but now we use a constant to refer to
    each value, which we call price , in the values property. When looping through
    values, we don’t have access to the keys from inside the loop.
  id: totrans-7624
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用相同风格的 for-in 循环，但现在我们使用一个常量来引用 values 属性中的每个值，我们称之为 price。当遍历 values 时，我们无法在循环内访问到键。
- en: Another difference to note is that price is not an optional because it’s accessed
    directly as a value in the fruitBasket dictionary. That means we don’t have to
    unwrap it. You should still see the print statement printed three times. [Figure
    6-6](text00016.html#ch06fig6) shows the output of both loops.
  id: totrans-7625
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个需要注意的区别是，price 不是一个可选项，因为它是直接作为 fruitBasket 字典中的值访问的。这意味着我们不需要解包它。你仍然应该看到打印语句显示三次。[图
    6-6](text00016.html#ch06fig6) 显示了两种循环的输出。
- en: '![Image](Image00151.jpg)'
  id: totrans-7626
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00151.jpg)'
- en: '*Figure 6-6: Looping through the keys and values of a dictionary with a for-in
    loop*'
  id: totrans-7627
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 6-6：使用 for-in 循环遍历字典的键和值*'
- en: The order of your results might be slightly different from ours. That’s because
    the items in a dictionary aren’t in a numbered order like they are in an array!
    And because the order is not guaranteed, you might see a different order printed
    if you run the same code again.
  id: totrans-7628
  prefs: []
  type: TYPE_NORMAL
  zh: 你的结果顺序可能与我们的略有不同。这是因为字典中的项不像数组那样按编号顺序排列！由于顺序无法保证，如果你重新运行相同的代码，可能会看到不同的顺序。
- en: '**WHAT YOU LEARNED**'
  id: totrans-7629
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**你学到了什么**'
- en: In this chapter, you learned how to store collections of items in an array and
    in a dictionary. To store items in an ordered list, you would use an array and
    look up each item by its index. If you wanted to store items by key instead, you
    would use a dictionary.
  id: totrans-7630
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你学会了如何在数组和字典中存储项目。要在有序列表中存储项目，你会使用数组，并通过索引查找每个项目。如果你想按键存储项目，则应使用字典。
- en: Knowing about arrays and dictionaries and how to use them is a powerful building
    block for almost any programming language. Next we will learn about functions,
    another very powerful tool. Functions are blocks of code that you create and name
    to perform a specific job. After you have written a function, you can use its
    name to call it from almost anywhere in your program.
  id: totrans-7631
  prefs: []
  type: TYPE_NORMAL
  zh: 了解数组和字典及其使用方法是几乎所有编程语言的强大构建块。接下来我们将学习函数，这是另一个非常强大的工具。函数是你创建并命名的一段代码，用于执行特定的任务。在你编写完函数之后，你可以通过它的名字在程序的几乎任何地方调用它。
- en: '![](Image00131.jpg)'
  id: totrans-7632
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00131.jpg)'
- en: At ➊ , we replaced the item at index 2 (the third item) with "Unicorn" because
    magical animals count as favorite animals, too! At ➋ , we replaced the item at
    index 0 (the first item) with "Bearded dragon" . No, that’s not a real dragon—it’s
    just a lizard!
  id: totrans-7633
  prefs: []
  type: TYPE_NORMAL
  zh: 在➊，我们将索引2（第三项）的项替换为"Unicorn"（独角兽），因为神奇动物也算是最喜欢的动物！在➋，我们将索引0（第一项）的项替换为"Bearded
    dragon"（鬃狮蜥）。不，这不是一条真正的龙，它只是一个蜥蜴！
- en: Like any time you’re working with array index numbers, you have to be sure an
    item exists in the array at that index before you change its value, or you will
    get an Index out of range error.
  id: totrans-7634
  prefs: []
  type: TYPE_NORMAL
  zh: 就像任何处理数组索引的情况一样，在你更改数组某个索引值之前，必须确保该索引位置的项存在，否则你会遇到“索引超出范围”的错误。
- en: '[Figure 6-3](text00016.html#ch06fig3) shows the error that occurs if you try
    to add "Standard poodle" using favoriteAnimals[3] = "Standard poodle" . To add
    an item to the end of an array, you should use the append(_:) method or += , as
    we covered in “[Adding Items to an Array](text00016.html#ch06lev2sec5) ” on [page
    70](text00016.html#page_70) .'
  id: totrans-7635
  prefs: []
  type: TYPE_NORMAL
  zh: '[图6-3](text00016.html#ch06fig3)显示了如果你尝试使用favoriteAnimals[3] = "Standard poodle"添加"标准贵宾犬"时发生的错误。要将项目添加到数组末尾，你应该使用append(_:)方法或+=，正如我们在“[向数组添加项目](text00016.html#ch06lev2sec5)”一节中在[第70页](text00016.html#page_70)所讲解的那样。'
- en: '![Image](Image00132.jpg)'
  id: totrans-7636
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00132.jpg)'
- en: '*Figure 6-3: Don’t try to replace a value at an index beyond the existing array.*'
  id: totrans-7637
  prefs: []
  type: TYPE_NORMAL
  zh: '*图6-3：不要尝试替换超出现有数组范围的索引值。*'
- en: Now you know how to change arrays however you might need to. You can add items,
    take items away, or replace items. Next, we’ll look at how to use the properties
    of arrays to find out even more information about them.
  id: totrans-7638
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你知道了如何根据需要修改数组。你可以添加项目、移除项目或替换项目。接下来，我们将了解如何使用数组的属性获取更多关于它们的信息。
- en: '![Image](Image00133.jpg)'
  id: totrans-7639
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00133.jpg)'
- en: '**USING ARRAY PROPERTIES**'
  id: totrans-7640
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**使用数组属性**'
- en: In addition to methods like append(_:) and removeLast() , arrays also have *properties*
    . An array’s properties are variables or constants that contain some information
    about the array. Two really helpful properties that you might use are the Boolean
    property isEmpty and the integer property count .
  id: totrans-7641
  prefs: []
  type: TYPE_NORMAL
  zh: 除了像append(_:)和removeLast()这样的函数，数组还有*属性*。数组的属性是包含数组相关信息的变量或常量。你可能会使用的两个非常有用的属性是布尔值属性isEmpty和整数属性count。
- en: The isEmpty property is true or false depending on whether the array is empty,
    and the count property will tell you how many items are in that array.
  id: totrans-7642
  prefs: []
  type: TYPE_NORMAL
  zh: isEmpty属性的值为true或false，取决于数组是否为空，而count属性则会告诉你数组中有多少项。
- en: 'Check out how these two properties are used in the following if-else statement:'
  id: totrans-7643
  prefs: []
  type: TYPE_NORMAL
  zh: 查看以下if-else语句中这两个属性是如何使用的：
- en: '![Image](Image00134.jpg)'
  id: totrans-7644
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00134.jpg)'
- en: 'This if-else statement checks whether the array mySiblings is empty ➊ . If
    it is, then "I don''t have any siblings." is printed. But if there is something
    in the array, then the number of siblings that we have is printed: "I have 3 siblings."
    ➋ .'
  id: totrans-7645
  prefs: []
  type: TYPE_NORMAL
  zh: 这个if-else语句检查数组mySiblings是否为空 ➊。如果为空，则打印"我没有兄弟姐妹。"如果数组中有内容，则打印我们有多少兄弟姐妹："我有3个兄弟姐妹。"
    ➋。
- en: '**LOOPING OVER AN ARRAY**'
  id: totrans-7646
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**遍历数组**'
- en: 'Sometimes when you’re working with arrays you might want to do something to
    every item in the array. You can use a for-in loop to do that! The following code
    will print every topping in a pizzaToppings array on a separate line:'
  id: totrans-7647
  prefs: []
  type: TYPE_NORMAL
  zh: 有时候，在处理数组时，你可能希望对数组中的每个项做某些操作。你可以使用 for-in 循环来做到这一点！下面的代码会将 `pizzaToppings`
    数组中的每个 topping 打印在单独的一行上：
- en: '![Image](Image00135.jpg)'
  id: totrans-7648
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Image00135.jpg)'
- en: To write a for-in loop for the pizzaToppings array, we used the keyword for
    , followed by the constant topping , then the keyword in , and finally the name
    of our array, pizzaToppings . Then we put the statements that we want to run for
    each topping inside the braces of the for-in loop. The constant topping ➊ temporarily
    represents each pizza topping in the array as we loop through it. We could have
    chosen any name for this constant, but it’s a good idea to pick something that
    makes sense. You can see the output of this for-in loop in [Figure 6-4](text00016.html#ch06fig4)
    .
  id: totrans-7649
  prefs: []
  type: TYPE_NORMAL
  zh: 要为 `pizzaToppings` 数组编写一个 for-in 循环，我们使用了关键字 `for`，后面跟着常量 `topping`，然后是关键字 `in`，最后是我们数组的名称
    `pizzaToppings`。接着，我们将希望对每个 topping 执行的语句放入 for-in 循环的大括号内。常量 `topping` ➊ 临时表示我们在循环中遍历的每个披萨配料。我们可以为这个常量选择任何名字，但最好选择一个有意义的名字。你可以在
    [图 6-4](text00016.html#ch06fig4) 中看到这个 for-in 循环的输出。
- en: '![Image](Image00136.jpg)'
  id: totrans-7650
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Image00136.jpg)'
- en: '*Figure 6-4: Output of the example for-in loop*'
  id: totrans-7651
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 6-4：示例 for-in 循环的输出*'
- en: '![Image](Image00137.jpg)'
  id: totrans-7652
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Image00137.jpg)'
- en: 'Using for-in loops is great for printing every value in an array. If you’re
    working with numbers, you can even use them to perform math operations on each
    item, which makes for some speedy calculations! The following code takes an array
    of numbers and calculates the square for each (the square of a number is that
    number multiplied by itself):'
  id: totrans-7653
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 for-in 循环非常适合打印数组中的每个值。如果你正在处理数字，你甚至可以用它们对每个项目执行数学运算，这样就能快速进行计算！下面的代码获取一个数字数组，并计算每个数字的平方（一个数字的平方是该数字乘以它自己）：
- en: '![Image](Image00138.jpg)'
  id: totrans-7654
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Image00138.jpg)'
- en: '[Figure 6-5](text00016.html#ch06fig5) shows the results.'
  id: totrans-7655
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 6-5](text00016.html#ch06fig5) 显示了结果。'
- en: '![Image](Image00139.jpg)'
  id: totrans-7656
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Image00139.jpg)'
- en: '*Figure 6-5: Printing the squares for each number in the myNumbers array*'
  id: totrans-7657
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 6-5：打印 `myNumbers` 数组中每个数字的平方*'
- en: '**DICTIONARIES ARE KEY!**'
  id: totrans-7658
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**字典至关重要！**'
- en: A *dictionary* is also a collection of values, but instead of an ordered index,
    each value has its own *key* . Because there’s no index, the values are not stored
    in any particular order. To access values in a dictionary, you look them up by
    their key.
  id: totrans-7659
  prefs: []
  type: TYPE_NORMAL
  zh: 一个 *字典* 也是一组值，但与有序索引不同，每个值都有自己的 *键*。由于没有索引，值不会以任何特定顺序存储。要访问字典中的值，你需要通过键来查找它们。
- en: A key must be unique. You can’t have the same key more than once in the same
    dictionary. If there were two identical keys and you asked the computer to give
    you the value for one of them, the computer wouldn’t know which one to choose!
  id: totrans-7660
  prefs: []
  type: TYPE_NORMAL
  zh: 键必须是唯一的。你不能在同一个字典中使用相同的键两次。如果有两个相同的键，并且你要求计算机为其中一个键提供值，计算机将不知道选择哪个！
- en: Let’s take a look at how to make a dictionary and write keys that will help
    you find all the information you need.
  id: totrans-7661
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如何创建一个字典，并编写有助于你找到所需信息的键。
- en: '![Image](Image00140.jpg)'
  id: totrans-7662
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Image00140.jpg)'
- en: '**INITIALIZING A DICTIONARY**'
  id: totrans-7663
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**初始化字典**'
- en: 'To create and initialize a dictionary, first write var and the name of your
    dictionary. Then write the keys and corresponding values inside a pair of square
    brackets, similar to an array. Let’s create a dictionary to store the names of
    a few US states. The key for each state will be its two-letter abbreviation:'
  id: totrans-7664
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建并初始化一个字典，首先写 `var` 和字典的名称。然后将键和值放在一对方括号内，类似于数组。让我们创建一个字典来存储一些美国州的名称。每个州的键将是它的两字母缩写：
- en: '![](Image00141.jpg)'
  id: totrans-7665
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00141.jpg)'
- en: As you can see, there’s a colon between each key and its value, and the key/value
    pairs are separated by commas.
  id: totrans-7666
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，每个键和值之间有一个冒号，键值对之间由逗号分隔。
- en: Dictionaries are different from arrays in that they are *unordered* . Because
    of that, it’s likely that the order of the states that you see in your results
    pane ➋ is different from the order in which you entered your states ➊ . It might
    even be different than the order that’s printed in this book!
  id: totrans-7667
  prefs: []
  type: TYPE_NORMAL
  zh: 字典与数组不同，它们是 *无序的*。因此，结果窗格中你看到的状态顺序 ➋ 很可能与输入状态的顺序 ➊ 不同，甚至可能与书中打印的顺序不同！
- en: As with arrays, you can use var to make a mutable dictionary or use let to make
    an immutable dictionary.
  id: totrans-7668
  prefs: []
  type: TYPE_NORMAL
  zh: 与数组一样，你可以使用 `var` 来创建一个可变字典，或者使用 `let` 来创建一个不可变字典。
- en: 'In Swift, all of the keys of a dictionary must be the same type, and all of
    the values of a dictionary must also be the same type, but the key type doesn’t
    have to match the value type. For example, if you wanted to store a collection
    of fractions, you could use doubles for the keys and strings for the values:'
  id: totrans-7669
  prefs: []
  type: TYPE_NORMAL
  zh: 在Swift中，字典的所有键必须是相同类型的，字典的所有值也必须是相同类型的，但键的类型不一定需要与值的类型相同。例如，如果你想存储一组分数，你可以使用双精度数作为键，字符串作为值：
- en: '![](Image00142.jpg)'
  id: totrans-7670
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00142.jpg)'
- en: In this dictionary, all of the keys must be doubles, and all of the values must
    be strings. Again, you’ll see that the order of the numbers in the results pane
    can be quite different from the order in which you wrote the fractions in your
    dictionary. This is fine because you don’t need to know the order to access anything.
    You can find any item that you need by its key. Let’s see how!
  id: totrans-7671
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个字典中，所有的键必须是双精度数，所有的值必须是字符串。同样，你会看到结果面板中数字的顺序可能与字典中书写分数的顺序完全不同。这是可以的，因为你不需要知道顺序来访问任何内容。你可以通过键找到你需要的任何项。我们来看看如何做！
- en: '**ACCESSING VALUES IN A DICTIONARY**'
  id: totrans-7672
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**访问字典中的值**'
- en: 'Looking up a value in a dictionary is similar to how you access a value in
    an array except that you use a key inside the square brackets instead of an index,
    like this: usStates["TX"] .'
  id: totrans-7673
  prefs: []
  type: TYPE_NORMAL
  zh: 在字典中查找一个值类似于在数组中访问一个值，只是你使用的是键而不是索引，像这样：usStates["TX"]。
- en: There is a big difference, however, in how Swift returns the values from a dictionary.
    When you access a value at an index of an array, you are simply given the value.
    When you access a value with a key in a dictionary, you are given an optional.
  id: totrans-7674
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，Swift在从字典中返回值的方式上有一个很大的不同。当你通过数组的索引访问值时，你会直接得到该值。而当你通过字典中的键访问值时，你得到的是一个可选项。
- en: In [Chapter 5](text00015.html#ch05) , you learned that optionals might contain
    a value or might be nil . The reason Swift returns optionals when you’re looking
    up items in a dictionary is that the key you used might not exist in the dictionary,
    in which case there’s no value to access. Trying to access a value that doesn’t
    exist would give you a big fat error! To avoid that problem, Swift returns optionals.
    That means you need to unwrap any value you get out of a dictionary before you
    can do anything with it.
  id: totrans-7675
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第5章](text00015.html#ch05)中，你学到了可选项可能包含一个值，也可能是nil。Swift在你查找字典中的项时返回可选项的原因是，你使用的键可能在字典中不存在，在这种情况下就没有值可以访问。尝试访问一个不存在的值会给你一个很大的错误！为了避免这个问题，Swift返回可选项。这意味着你在使用从字典中获取的任何值之前，需要先解包它。
- en: 'To unwrap an optional, first you check whether it exists using an if-let statement,
    just like we did in [Chapter 5](text00015.html#ch05) . The following code shows
    you how to get a value out of a dictionary:'
  id: totrans-7676
  prefs: []
  type: TYPE_NORMAL
  zh: 要解包一个可选项，首先你要检查它是否存在，使用if-let语句，就像我们在[第5章](text00015.html#ch05)中做的那样。以下代码展示了如何从字典中获取一个值：
- en: '![Image](Image00143.jpg)'
  id: totrans-7677
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Image00143.jpg)'
- en: To retrieve "Texas" from the dictionary, we use if let to set a constant loneStarState
    to usStates["TX"] ➊ . Because we have this state in our dictionary, the line I
    have Texas in my dictionary. is printed. Next we try to access a state that is
    not in our dictionary by using the key usStates["FL"] ➋ . Thankfully, because
    we used an if-let statement, the program won’t crash when the computer can’t find
    this state. Instead, I don't have that state in my dictionary. is printed.
  id: totrans-7678
  prefs: []
  type: TYPE_NORMAL
  zh: 要从字典中检索"Texas"，我们使用if let将常量loneStarState设置为usStates["TX"] ➊。因为我们在字典中有这个州，所以下面的语句“I
    have Texas in my dictionary.”会被打印出来。接下来，我们尝试访问一个不在字典中的州，使用键usStates["FL"] ➋。幸运的是，由于我们使用了if-let语句，当计算机找不到这个州时，程序不会崩溃。相反，打印出来的是“I
    don't have that state in my dictionary.”
- en: '**ADDING ITEMS TO A DICTIONARY**'
  id: totrans-7679
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**向字典中添加项目**'
- en: 'To add an item to a dictionary, first write the name of your dictionary and
    assign the new item to the key you want it to have in the dictionary. Let’s add
    "Minnesota" to our usStates dictionary:'
  id: totrans-7680
  prefs: []
  type: TYPE_NORMAL
  zh: 要向字典中添加项目，首先写下字典的名称，并将新项目分配给你想要在字典中使用的键。我们来将"Minnesota"添加到我们的usStates字典中：
- en: '![](Image00144.jpg)'
  id: totrans-7681
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00144.jpg)'
- en: 'Now when you look at usStates , you’ll see that it’s updated to ["MN": "Minnesota",
    "WA": "Washington", "MA": "Massachusetts", "TX": "Texas"] . Remember, because
    you don’t have to rely on indices, your new dictionary item might appear anywhere
    in the dictionary.'
  id: totrans-7682
  prefs: []
  type: TYPE_NORMAL
  zh: '现在，当你查看usStates时，你会看到它已更新为["MN": "Minnesota", "WA": "Washington", "MA": "Massachusetts",
    "TX": "Texas"]。记住，因为你不需要依赖索引，所以你的新字典项可能会出现在字典中的任何位置。'
- en: '**REMOVING ITEMS FROM A DICTIONARY**'
  id: totrans-7683
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**从字典中移除项目**'
- en: Removing an item from a dictionary is quite simple; you do so by setting the
    value to nil . Because the values in dictionaries are returned as optionals, you
    don’t have to worry about nil causing any problems in your dictionary.
  id: totrans-7684
  prefs: []
  type: TYPE_NORMAL
  zh: 从字典中删除项目非常简单；你只需将值设置为 nil。由于字典中的值是作为可选项返回的，因此你不必担心 nil 会导致字典出现任何问题。
- en: '![](Image00145.jpg)'
  id: totrans-7685
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00145.jpg)'
- en: 'You can see that after you remove the value at the key "MA" , usStates is updated
    to ["MN": "Minnesota", "WA": "Washington", "TX": "Texas"] . Remember that nil
    is special and means that there’s no value at all. That’s why you don’t see "MA":
    nil in our dictionary.'
  id: totrans-7686
  prefs: []
  type: TYPE_NORMAL
  zh: '你可以看到，在删除键 "MA" 处的值后，usStates 更新为 ["MN": "Minnesota", "WA": "Washington", "TX":
    "Texas"]。记住，nil 是特殊的，表示没有任何值。这就是为什么你在字典中看不到 "MA": nil 的原因。'
- en: '**REPLACING ITEMS IN A DICTIONARY**'
  id: totrans-7687
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**替换字典中的项目**'
- en: 'Replacing an item in a dictionary is also easy. It works the same was as replacing
    an item in an array. You just set the item that you want to replace to something
    else. Say you create a dictionary of fruit colors:'
  id: totrans-7688
  prefs: []
  type: TYPE_NORMAL
  zh: 在字典中替换一个项目也很简单。它的工作方式与替换数组中的项目相同。你只需将要替换的项目设置为其他值。假设你创建了一个水果颜色的字典：
- en: '![](Image00146.jpg)'
  id: totrans-7689
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00146.jpg)'
- en: At first we had the value "apple" for "red" , but then we decided that "raspberry"
    is a better fruit to use since sometimes apples are green or yellow. To replace
    "apple" with "raspberry" , we set colorFruits["red"] to its new value ➊ .
  id: totrans-7690
  prefs: []
  type: TYPE_NORMAL
  zh: 起初我们为“red”键设置了值“apple”，但后来我们决定使用“raspberry”作为更好的水果，因为有时苹果是绿色或黄色的。要用“raspberry”替换“apple”，我们将
    colorFruits["red"] 设置为新的值 ➊。
- en: You may remember that this is the same way we entered a new value into a dictionary.
    If the key already exists in the dictionary, then the value for that key is replaced.
    If the key doesn’t already exist, then the new key/value pair will be added to
    the dictionary.
  id: totrans-7691
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能还记得，这就是我们向字典中输入新值的方式。如果键已经存在于字典中，则该键的值会被替换。如果键不存在，则新的键/值对将被添加到字典中。
- en: '![Image](Image00147.jpg)'
  id: totrans-7692
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00147.jpg)'
- en: '**USING DICTIONARY PROPERTIES**'
  id: totrans-7693
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**使用字典属性**'
- en: 'Like an array, a dictionary also has an isEmpty property and a count property.
    For example, the following code shows how you can use the isEmpty property to
    check if a dictionary is empty, and if it isn’t empty, the count property checks
    how many items you have. Imagine you have a basket of fruit for sale. You can
    use these properties to help you keep track of everything:'
  id: totrans-7694
  prefs: []
  type: TYPE_NORMAL
  zh: 像数组一样，字典也有 isEmpty 属性和 count 属性。例如，以下代码展示了如何使用 isEmpty 属性检查字典是否为空，如果不为空，count
    属性则可以检查字典中的项目数。假设你有一个售卖的水果篮。你可以使用这些属性帮助你跟踪所有内容：
- en: '![Image](Image00148.jpg)'
  id: totrans-7695
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00148.jpg)'
- en: 'A dictionary also has two special properties: keys , which contains all of
    the dictionary’s keys, and values , which contains all of its values. We’ll use
    these two properties when we loop through the dictionary.'
  id: totrans-7696
  prefs: []
  type: TYPE_NORMAL
  zh: 字典也有两个特殊的属性：keys，它包含字典的所有键，和values，它包含字典的所有值。我们在遍历字典时会使用这两个属性。
- en: Let’s write some code that loops through our fruit baskets and prints the price
    of each fruit.
  id: totrans-7697
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们写些代码，遍历我们的水果篮并打印每个水果的价格。
- en: '**LOOPING OVER A DICTIONARY**'
  id: totrans-7698
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**遍历字典**'
- en: 'You can loop through a dictionary using a for-in loop. Because each item has
    a key and a value, you can do this in two different ways. This is how to loop
    through a dictionary using its keys:'
  id: totrans-7699
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用 for-in 循环遍历字典。因为每个项目都有一个键和值，所以你可以用两种不同的方式来做。以下是通过字典的键来遍历字典的方法：
- en: '![Image](Image00149.jpg)'
  id: totrans-7700
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00149.jpg)'
- en: Here we use the dictionary’s keys property ➊ to loop through fruitBasket and
    print its contents. We start by writing the keyword for , followed by a constant
    name fruit for the dictionary key, the keyword in , the dictionary name, a period,
    and keys .
  id: totrans-7701
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们使用字典的 keys 属性 ➊ 遍历 fruitBasket 并打印其内容。我们首先写下关键字 for，然后是字典键的常量名称 fruit，接着是关键字
    in，字典名称，句点，和 keys。
- en: Inside the braces of our for-in loop, we have access to both the key, which
    we call fruit ➋ , and the value at that key when we force-unwrap its contents
    with fruitBasket[fruit]! ➌ . That value will be the fruit’s price.
  id: totrans-7702
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的 for-in 循环的大括号内，我们可以访问键（我们称之为 fruit ➋）以及该键处的值，当我们通过 fruitBasket[fruit]!
    强制解包其内容时 ➌。该值将是水果的价格。
- en: In this case, it’s safe to force-unwrap the value using an exclamation point
    because we know that the fruit key we’re using is definitely inside the dictionary.
  id: totrans-7703
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，可以安全地使用感叹号强制解包值，因为我们知道我们使用的 fruit 键一定在字典中。
- en: Any code we put inside the for-in loop will run once for every key in our dictionary.
    So you should see the print statement display three times.
  id: totrans-7704
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在for-in循环中放入的任何代码都会对字典中的每个键运行一次。所以你应该会看到打印语句显示三次。
- en: 'We can also loop through the dictionary using its values property:'
  id: totrans-7705
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以通过字典的值属性进行循环：
- en: '![Image](Image00150.jpg)'
  id: totrans-7706
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00150.jpg)'
- en: We use the same style of for-in loop, but now we use a constant to refer to
    each value, which we call price , in the values property. When looping through
    values, we don’t have access to the keys from inside the loop.
  id: totrans-7707
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用相同的for-in循环样式，但现在我们使用常量来引用值属性中的每个值，我们称之为price。在遍历值时，我们无法从循环内部访问键。
- en: Another difference to note is that price is not an optional because it’s accessed
    directly as a value in the fruitBasket dictionary. That means we don’t have to
    unwrap it. You should still see the print statement printed three times. [Figure
    6-6](text00016.html#ch06fig6) shows the output of both loops.
  id: totrans-7708
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个需要注意的区别是，price不是一个可选值，因为它是作为fruitBasket字典中的值直接访问的。这意味着我们不需要解包它。你仍然应该看到打印语句打印三次。[图6-6](text00016.html#ch06fig6)显示了两个循环的输出。
- en: '![Image](Image00151.jpg)'
  id: totrans-7709
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00151.jpg)'
- en: '*Figure 6-6: Looping through the keys and values of a dictionary with a for-in
    loop*'
  id: totrans-7710
  prefs: []
  type: TYPE_NORMAL
  zh: '*图6-6：通过for-in循环遍历字典的键和值*'
- en: The order of your results might be slightly different from ours. That’s because
    the items in a dictionary aren’t in a numbered order like they are in an array!
    And because the order is not guaranteed, you might see a different order printed
    if you run the same code again.
  id: totrans-7711
  prefs: []
  type: TYPE_NORMAL
  zh: 你的结果顺序可能与我们的稍有不同。这是因为字典中的项不像数组那样有编号顺序！并且由于顺序无法保证，如果你再次运行相同的代码，可能会看到不同的打印顺序。
- en: '**WHAT YOU LEARNED**'
  id: totrans-7712
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**你学到的内容**'
- en: In this chapter, you learned how to store collections of items in an array and
    in a dictionary. To store items in an ordered list, you would use an array and
    look up each item by its index. If you wanted to store items by key instead, you
    would use a dictionary.
  id: totrans-7713
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你学会了如何在数组和字典中存储项目。要在有序列表中存储项，你会使用数组，并通过索引查找每个项。如果你想按键存储项，你应该使用字典。
- en: Knowing about arrays and dictionaries and how to use them is a powerful building
    block for almost any programming language. Next we will learn about functions,
    another very powerful tool. Functions are blocks of code that you create and name
    to perform a specific job. After you have written a function, you can use its
    name to call it from almost anywhere in your program.
  id: totrans-7714
  prefs: []
  type: TYPE_NORMAL
  zh: 了解数组和字典以及如何使用它们是几乎所有编程语言中的强大构建块。接下来，我们将学习函数，这是另一个非常强大的工具。函数是你创建并命名的代码块，用来执行特定的任务。编写完函数后，你可以通过它的名称在程序中的几乎任何地方调用它。
- en: At ➊ , we replaced the item at index 2 (the third item) with "Unicorn" because
    magical animals count as favorite animals, too! At ➋ , we replaced the item at
    index 0 (the first item) with "Bearded dragon" . No, that’s not a real dragon—it’s
    just a lizard!
  id: totrans-7715
  prefs: []
  type: TYPE_NORMAL
  zh: 在➊处，我们将索引2（第三项）处的项替换为“独角兽”，因为魔法动物也算作最喜欢的动物！在➋处，我们将索引0（第一项）处的项替换为“须龙”。不，那不是一种真正的龙——它只是一个蜥蜴！
- en: Like any time you’re working with array index numbers, you have to be sure an
    item exists in the array at that index before you change its value, or you will
    get an Index out of range error.
  id: totrans-7716
  prefs: []
  type: TYPE_NORMAL
  zh: 就像在处理数组索引时一样，你必须确保在该索引位置有一个项存在，再修改其值，否则会出现“索引超出范围”的错误。
- en: '[Figure 6-3](text00016.html#ch06fig3) shows the error that occurs if you try
    to add "Standard poodle" using favoriteAnimals[3] = "Standard poodle" . To add
    an item to the end of an array, you should use the append(_:) method or += , as
    we covered in “[Adding Items to an Array](text00016.html#ch06lev2sec5) ” on [page
    70](text00016.html#page_70) .'
  id: totrans-7717
  prefs: []
  type: TYPE_NORMAL
  zh: '[图6-3](text00016.html#ch06fig3)显示了如果你尝试通过favoriteAnimals[3] = "Standard poodle"添加“标准贵宾犬”时发生的错误。要将项添加到数组末尾，你应该使用append(_:)方法或+=，正如我们在[“向数组添加项”](text00016.html#ch06lev2sec5)中讨论的那样，见[第70页](text00016.html#page_70)。'
- en: '![Image](Image00132.jpg)'
  id: totrans-7718
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00132.jpg)'
- en: '*Figure 6-3: Don’t try to replace a value at an index beyond the existing array.*'
  id: totrans-7719
  prefs: []
  type: TYPE_NORMAL
  zh: '*图6-3：不要尝试在数组索引超出范围时替换值。*'
- en: Now you know how to change arrays however you might need to. You can add items,
    take items away, or replace items. Next, we’ll look at how to use the properties
    of arrays to find out even more information about them.
  id: totrans-7720
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你知道如何根据需要修改数组了。你可以添加项、删除项或替换项。接下来，我们将看看如何使用数组的属性来获取更多关于它们的信息。
- en: '![Image](Image00133.jpg)'
  id: totrans-7721
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00133.jpg)'
- en: '**USING ARRAY PROPERTIES**'
  id: totrans-7722
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**使用数组属性**'
- en: In addition to methods like append(_:) and removeLast() , arrays also have *properties*
    . An array’s properties are variables or constants that contain some information
    about the array. Two really helpful properties that you might use are the Boolean
    property isEmpty and the integer property count .
  id: totrans-7723
  prefs: []
  type: TYPE_NORMAL
  zh: 除了像 append(_:) 和 removeLast() 这样的函数，数组还有*属性*。数组的属性是包含数组相关信息的变量或常量。你可能会用到的两个非常有用的属性是布尔类型的
    isEmpty 属性和整数类型的 count 属性。
- en: The isEmpty property is true or false depending on whether the array is empty,
    and the count property will tell you how many items are in that array.
  id: totrans-7724
  prefs: []
  type: TYPE_NORMAL
  zh: isEmpty 属性的值为 true 或 false，取决于数组是否为空，count 属性则告诉你数组中有多少个项目。
- en: 'Check out how these two properties are used in the following if-else statement:'
  id: totrans-7725
  prefs: []
  type: TYPE_NORMAL
  zh: 查看下面的if-else语句中这两个属性是如何使用的：
- en: '![Image](Image00134.jpg)'
  id: totrans-7726
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00134.jpg)'
- en: 'This if-else statement checks whether the array mySiblings is empty ➊ . If
    it is, then "I don''t have any siblings." is printed. But if there is something
    in the array, then the number of siblings that we have is printed: "I have 3 siblings."
    ➋ .'
  id: totrans-7727
  prefs: []
  type: TYPE_NORMAL
  zh: 这个 if-else 语句检查 mySiblings 数组是否为空 ➊。如果为空，就会打印“我没有兄弟姐妹”。但如果数组里有东西，就会打印我们有多少个兄弟姐妹：“我有
    3 个兄弟姐妹。” ➋。
- en: '**LOOPING OVER AN ARRAY**'
  id: totrans-7728
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**遍历数组**'
- en: 'Sometimes when you’re working with arrays you might want to do something to
    every item in the array. You can use a for-in loop to do that! The following code
    will print every topping in a pizzaToppings array on a separate line:'
  id: totrans-7729
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，在处理数组时，你可能希望对数组中的每个项目做一些操作。你可以使用 for-in 循环来做到这一点！以下代码会将 pizzaToppings 数组中的每个配料单独打印出来：
- en: '![Image](Image00135.jpg)'
  id: totrans-7730
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00135.jpg)'
- en: To write a for-in loop for the pizzaToppings array, we used the keyword for
    , followed by the constant topping , then the keyword in , and finally the name
    of our array, pizzaToppings . Then we put the statements that we want to run for
    each topping inside the braces of the for-in loop. The constant topping ➊ temporarily
    represents each pizza topping in the array as we loop through it. We could have
    chosen any name for this constant, but it’s a good idea to pick something that
    makes sense. You can see the output of this for-in loop in [Figure 6-4](text00016.html#ch06fig4)
    .
  id: totrans-7731
  prefs: []
  type: TYPE_NORMAL
  zh: 在为 pizzaToppings 数组编写 for-in 循环时，我们使用了关键字 for，接着是常量 topping，再是关键字 in，最后是我们的数组名称
    pizzaToppings。然后我们把希望在每个配料上运行的语句放到 for-in 循环的括号里。常量 topping ➊ 在我们遍历数组时暂时代表数组中的每个披萨配料。我们本可以为这个常量选择任何名字，但最好选择一个有意义的名字。你可以在[图
    6-4](text00016.html#ch06fig4)中看到这个 for-in 循环的输出。
- en: '![Image](Image00136.jpg)'
  id: totrans-7732
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00136.jpg)'
- en: '*Figure 6-4: Output of the example for-in loop*'
  id: totrans-7733
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 6-4：示例 for-in 循环的输出*'
- en: '![Image](Image00137.jpg)'
  id: totrans-7734
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00137.jpg)'
- en: 'Using for-in loops is great for printing every value in an array. If you’re
    working with numbers, you can even use them to perform math operations on each
    item, which makes for some speedy calculations! The following code takes an array
    of numbers and calculates the square for each (the square of a number is that
    number multiplied by itself):'
  id: totrans-7735
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 for-in 循环非常适合打印数组中的每个值。如果你在处理数字，你甚至可以使用它们对每个项目执行数学运算，从而实现快速计算！以下代码会获取一个数字数组，并计算每个数字的平方（数字的平方是该数字乘以它自己）：
- en: '![Image](Image00138.jpg)'
  id: totrans-7736
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00138.jpg)'
- en: '[Figure 6-5](text00016.html#ch06fig5) shows the results.'
  id: totrans-7737
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 6-5](text00016.html#ch06fig5)展示了结果。'
- en: '![Image](Image00139.jpg)'
  id: totrans-7738
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00139.jpg)'
- en: '*Figure 6-5: Printing the squares for each number in the myNumbers array*'
  id: totrans-7739
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 6-5：打印 myNumbers 数组中每个数字的平方*'
- en: '**DICTIONARIES ARE KEY!**'
  id: totrans-7740
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**字典是关键！**'
- en: A *dictionary* is also a collection of values, but instead of an ordered index,
    each value has its own *key* . Because there’s no index, the values are not stored
    in any particular order. To access values in a dictionary, you look them up by
    their key.
  id: totrans-7741
  prefs: []
  type: TYPE_NORMAL
  zh: '*字典*也是一个值的集合，但与数组不同，每个值都有自己的*键*。由于没有索引，值没有按特定顺序存储。要访问字典中的值，你需要通过键来查找它们。'
- en: A key must be unique. You can’t have the same key more than once in the same
    dictionary. If there were two identical keys and you asked the computer to give
    you the value for one of them, the computer wouldn’t know which one to choose!
  id: totrans-7742
  prefs: []
  type: TYPE_NORMAL
  zh: 键必须是唯一的。你不能在同一个字典中使用相同的键。如果存在两个相同的键，且你要求计算机返回其中一个的值，计算机就无法知道应该选择哪一个！
- en: Let’s take a look at how to make a dictionary and write keys that will help
    you find all the information you need.
  id: totrans-7743
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看如何创建字典并编写键，帮助你找到所有需要的信息。
- en: '![Image](Image00140.jpg)'
  id: totrans-7744
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00140.jpg)'
- en: '**INITIALIZING A DICTIONARY**'
  id: totrans-7745
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**初始化字典**'
- en: 'To create and initialize a dictionary, first write var and the name of your
    dictionary. Then write the keys and corresponding values inside a pair of square
    brackets, similar to an array. Let’s create a dictionary to store the names of
    a few US states. The key for each state will be its two-letter abbreviation:'
  id: totrans-7746
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建并初始化一个字典，首先写 var 和字典的名称。然后在一对方括号内写入键及其对应的值，类似于数组的写法。让我们创建一个字典，用来存储几个美国州的名称。每个州的键将是它的两位字母缩写：
- en: '![](Image00141.jpg)'
  id: totrans-7747
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00141.jpg)'
- en: As you can see, there’s a colon between each key and its value, and the key/value
    pairs are separated by commas.
  id: totrans-7748
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，每个键和值之间有一个冒号，键/值对之间用逗号分隔。
- en: Dictionaries are different from arrays in that they are *unordered* . Because
    of that, it’s likely that the order of the states that you see in your results
    pane ➋ is different from the order in which you entered your states ➊ . It might
    even be different than the order that’s printed in this book!
  id: totrans-7749
  prefs: []
  type: TYPE_NORMAL
  zh: 字典与数组的不同之处在于它们是*无序的*。因此，你在结果窗格中看到的状态顺序 ➋ 可能与输入状态的顺序 ➊ 不同，甚至可能与本书中打印的顺序不同！
- en: As with arrays, you can use var to make a mutable dictionary or use let to make
    an immutable dictionary.
  id: totrans-7750
  prefs: []
  type: TYPE_NORMAL
  zh: 与数组一样，你可以使用 var 来创建一个可变字典，或使用 let 来创建一个不可变字典。
- en: 'In Swift, all of the keys of a dictionary must be the same type, and all of
    the values of a dictionary must also be the same type, but the key type doesn’t
    have to match the value type. For example, if you wanted to store a collection
    of fractions, you could use doubles for the keys and strings for the values:'
  id: totrans-7751
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Swift 中，字典的所有键必须是相同类型，所有值也必须是相同类型，但键的类型不必与值的类型匹配。例如，如果你想存储一个分数集合，你可以使用双精度数（doubles）作为键，使用字符串（strings）作为值：
- en: '![](Image00142.jpg)'
  id: totrans-7752
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00142.jpg)'
- en: In this dictionary, all of the keys must be doubles, and all of the values must
    be strings. Again, you’ll see that the order of the numbers in the results pane
    can be quite different from the order in which you wrote the fractions in your
    dictionary. This is fine because you don’t need to know the order to access anything.
    You can find any item that you need by its key. Let’s see how!
  id: totrans-7753
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个字典中，所有的键必须是双精度数（doubles），所有的值必须是字符串（strings）。同样，你会看到结果窗格中的数字顺序可能与字典中输入的分数顺序非常不同。这没关系，因为你不需要知道顺序来访问任何内容。你可以通过键来找到任何你需要的项。让我们看看如何做到这一点！
- en: '**ACCESSING VALUES IN A DICTIONARY**'
  id: totrans-7754
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**访问字典中的值**'
- en: 'Looking up a value in a dictionary is similar to how you access a value in
    an array except that you use a key inside the square brackets instead of an index,
    like this: usStates["TX"] .'
  id: totrans-7755
  prefs: []
  type: TYPE_NORMAL
  zh: 在字典中查找一个值与访问数组中的值类似，只不过你需要在方括号内使用键，而不是索引，像这样：usStates["TX"]。
- en: There is a big difference, however, in how Swift returns the values from a dictionary.
    When you access a value at an index of an array, you are simply given the value.
    When you access a value with a key in a dictionary, you are given an optional.
  id: totrans-7756
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，Swift 从字典中返回值的方式有很大不同。当你在数组的索引位置访问一个值时，你只会得到该值。而在字典中通过键访问一个值时，你得到的是一个可选值。
- en: In [Chapter 5](text00015.html#ch05) , you learned that optionals might contain
    a value or might be nil . The reason Swift returns optionals when you’re looking
    up items in a dictionary is that the key you used might not exist in the dictionary,
    in which case there’s no value to access. Trying to access a value that doesn’t
    exist would give you a big fat error! To avoid that problem, Swift returns optionals.
    That means you need to unwrap any value you get out of a dictionary before you
    can do anything with it.
  id: totrans-7757
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第5章](text00015.html#ch05)中，你学过可选值可能包含一个值，也可能是 nil。Swift 返回可选值的原因是，当你在字典中查找某个项时，使用的键可能在字典中不存在，这样就没有值可供访问。尝试访问一个不存在的值会导致一个错误！为了避免这个问题，Swift
    返回可选值。这意味着你需要解包从字典中获取的任何值，才能对其进行操作。
- en: 'To unwrap an optional, first you check whether it exists using an if-let statement,
    just like we did in [Chapter 5](text00015.html#ch05) . The following code shows
    you how to get a value out of a dictionary:'
  id: totrans-7758
  prefs: []
  type: TYPE_NORMAL
  zh: 要解包一个可选值，首先通过 if-let 语句检查它是否存在，就像我们在[第5章](text00015.html#ch05)中所做的那样。以下代码展示了如何从字典中获取一个值：
- en: '![Image](Image00143.jpg)'
  id: totrans-7759
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00143.jpg)'
- en: To retrieve "Texas" from the dictionary, we use if let to set a constant loneStarState
    to usStates["TX"] ➊ . Because we have this state in our dictionary, the line I
    have Texas in my dictionary. is printed. Next we try to access a state that is
    not in our dictionary by using the key usStates["FL"] ➋ . Thankfully, because
    we used an if-let statement, the program won’t crash when the computer can’t find
    this state. Instead, I don't have that state in my dictionary. is printed.
  id: totrans-7760
  prefs: []
  type: TYPE_NORMAL
  zh: 要从字典中检索“Texas”，我们使用 if let 将常量 loneStarState 设置为 usStates["TX"] ➊。由于我们在字典中有这个州，行“我在字典中有
    Texas”会被打印出来。接下来，我们尝试通过使用键 usStates["FL"] ➋ 访问字典中不存在的州。幸运的是，由于我们使用了 if-let 语句，当计算机找不到这个州时，程序不会崩溃。相反，“我没有这个州”会被打印出来。
- en: '**ADDING ITEMS TO A DICTIONARY**'
  id: totrans-7761
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**向字典中添加项目**'
- en: 'To add an item to a dictionary, first write the name of your dictionary and
    assign the new item to the key you want it to have in the dictionary. Let’s add
    "Minnesota" to our usStates dictionary:'
  id: totrans-7762
  prefs: []
  type: TYPE_NORMAL
  zh: 向字典添加项目时，首先写下字典的名称，并将新项目分配给你希望它在字典中具有的键。让我们将“Minnesota”添加到我们的 usStates 字典中：
- en: '![](Image00144.jpg)'
  id: totrans-7763
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00144.jpg)'
- en: 'Now when you look at usStates , you’ll see that it’s updated to ["MN": "Minnesota",
    "WA": "Washington", "MA": "Massachusetts", "TX": "Texas"] . Remember, because
    you don’t have to rely on indices, your new dictionary item might appear anywhere
    in the dictionary.'
  id: totrans-7764
  prefs: []
  type: TYPE_NORMAL
  zh: '现在，当你查看 usStates 时，你会看到它已更新为 ["MN": "Minnesota", "WA": "Washington", "MA":
    "Massachusetts", "TX": "Texas"]。记住，由于你不需要依赖索引，因此你的新字典项目可能会出现在字典中的任何位置。'
- en: '**REMOVING ITEMS FROM A DICTIONARY**'
  id: totrans-7765
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**从字典中移除项目**'
- en: Removing an item from a dictionary is quite simple; you do so by setting the
    value to nil . Because the values in dictionaries are returned as optionals, you
    don’t have to worry about nil causing any problems in your dictionary.
  id: totrans-7766
  prefs: []
  type: TYPE_NORMAL
  zh: 从字典中移除项目相当简单；你只需将值设置为 nil。由于字典中的值是作为可选项返回的，因此你无需担心 nil 会在字典中引发问题。
- en: '![](Image00145.jpg)'
  id: totrans-7767
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00145.jpg)'
- en: 'You can see that after you remove the value at the key "MA" , usStates is updated
    to ["MN": "Minnesota", "WA": "Washington", "TX": "Texas"] . Remember that nil
    is special and means that there’s no value at all. That’s why you don’t see "MA":
    nil in our dictionary.'
  id: totrans-7768
  prefs: []
  type: TYPE_NORMAL
  zh: '你可以看到，在移除键“MA”对应的值后，usStates 更新为 ["MN": "Minnesota", "WA": "Washington", "TX":
    "Texas"]。记住，nil 是特殊的，表示没有值。这就是为什么你在字典中看不到 "MA": nil 的原因。'
- en: '**REPLACING ITEMS IN A DICTIONARY**'
  id: totrans-7769
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**替换字典中的项目**'
- en: 'Replacing an item in a dictionary is also easy. It works the same was as replacing
    an item in an array. You just set the item that you want to replace to something
    else. Say you create a dictionary of fruit colors:'
  id: totrans-7770
  prefs: []
  type: TYPE_NORMAL
  zh: 替换字典中的项目也很简单。它的工作原理与替换数组中的项目相同。你只需将你想替换的项目设置为其他值。假设你创建了一个包含水果颜色的字典：
- en: '![](Image00146.jpg)'
  id: totrans-7771
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00146.jpg)'
- en: At first we had the value "apple" for "red" , but then we decided that "raspberry"
    is a better fruit to use since sometimes apples are green or yellow. To replace
    "apple" with "raspberry" , we set colorFruits["red"] to its new value ➊ .
  id: totrans-7772
  prefs: []
  type: TYPE_NORMAL
  zh: 起初，我们为“红色”设置了值“apple”，但后来我们决定用“raspberry”替代它，因为有时苹果是绿色或黄色的。为了将“apple”替换为“raspberry”，我们将
    colorFruits["red"] 设置为其新值 ➊。
- en: You may remember that this is the same way we entered a new value into a dictionary.
    If the key already exists in the dictionary, then the value for that key is replaced.
    If the key doesn’t already exist, then the new key/value pair will be added to
    the dictionary.
  id: totrans-7773
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能记得，这与我们向字典中添加新值的方式相同。如果键已经存在于字典中，那么该键的值将被替换。如果键不存在，则新的键/值对将被添加到字典中。
- en: '![Image](Image00147.jpg)'
  id: totrans-7774
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00147.jpg)'
- en: '**USING DICTIONARY PROPERTIES**'
  id: totrans-7775
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**使用字典属性**'
- en: 'Like an array, a dictionary also has an isEmpty property and a count property.
    For example, the following code shows how you can use the isEmpty property to
    check if a dictionary is empty, and if it isn’t empty, the count property checks
    how many items you have. Imagine you have a basket of fruit for sale. You can
    use these properties to help you keep track of everything:'
  id: totrans-7776
  prefs: []
  type: TYPE_NORMAL
  zh: 像数组一样，字典也具有 isEmpty 属性和 count 属性。例如，以下代码演示了如何使用 isEmpty 属性检查字典是否为空，如果不为空，则使用
    count 属性检查字典中有多少项。假设你有一个水果篮子出售，你可以使用这些属性来帮助你跟踪所有物品：
- en: '![Image](Image00148.jpg)'
  id: totrans-7777
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00148.jpg)'
- en: 'A dictionary also has two special properties: keys , which contains all of
    the dictionary’s keys, and values , which contains all of its values. We’ll use
    these two properties when we loop through the dictionary.'
  id: totrans-7778
  prefs: []
  type: TYPE_NORMAL
  zh: 字典还有两个特殊属性：keys，它包含字典的所有键；values，它包含字典的所有值。在遍历字典时，我们将使用这两个属性。
- en: Let’s write some code that loops through our fruit baskets and prints the price
    of each fruit.
  id: totrans-7779
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们编写一些代码，遍历我们的果篮并打印每种水果的价格。
- en: '**LOOPING OVER A DICTIONARY**'
  id: totrans-7780
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**遍历字典**'
- en: 'You can loop through a dictionary using a for-in loop. Because each item has
    a key and a value, you can do this in two different ways. This is how to loop
    through a dictionary using its keys:'
  id: totrans-7781
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用for-in循环遍历字典。因为每个项都有一个键和值，你可以通过两种方式来实现。以下是如何使用键来遍历字典：
- en: '![Image](Image00149.jpg)'
  id: totrans-7782
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00149.jpg)'
- en: Here we use the dictionary’s keys property ➊ to loop through fruitBasket and
    print its contents. We start by writing the keyword for , followed by a constant
    name fruit for the dictionary key, the keyword in , the dictionary name, a period,
    and keys .
  id: totrans-7783
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们使用字典的keys属性 ➊ 来遍历fruitBasket并打印其内容。我们从编写关键字for开始，后跟常量名fruit来表示字典的键，再是关键字in，字典名，一个句点，然后是keys。
- en: Inside the braces of our for-in loop, we have access to both the key, which
    we call fruit ➋ , and the value at that key when we force-unwrap its contents
    with fruitBasket[fruit]! ➌ . That value will be the fruit’s price.
  id: totrans-7784
  prefs: []
  type: TYPE_NORMAL
  zh: 在for-in循环的大括号内部，我们可以访问到键，即我们称之为fruit ➋ ，以及当我们强制解包它的内容（通过fruitBasket[fruit]!
    ➌）时，该键的值。该值将是水果的价格。
- en: In this case, it’s safe to force-unwrap the value using an exclamation point
    because we know that the fruit key we’re using is definitely inside the dictionary.
  id: totrans-7785
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，使用感叹号强制解包值是安全的，因为我们知道我们使用的fruit键肯定存在于字典中。
- en: Any code we put inside the for-in loop will run once for every key in our dictionary.
    So you should see the print statement display three times.
  id: totrans-7786
  prefs: []
  type: TYPE_NORMAL
  zh: 我们放入for-in循环中的任何代码都会对字典中的每个键执行一次。所以你应该看到打印语句显示三次。
- en: 'We can also loop through the dictionary using its values property:'
  id: totrans-7787
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以使用字典的values属性来遍历字典：
- en: '![Image](Image00150.jpg)'
  id: totrans-7788
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00150.jpg)'
- en: We use the same style of for-in loop, but now we use a constant to refer to
    each value, which we call price , in the values property. When looping through
    values, we don’t have access to the keys from inside the loop.
  id: totrans-7789
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用相同风格的for-in循环，但现在我们使用常量来引用values属性中的每个值，我们将其称为price。在遍历values时，我们无法从循环内部访问键。
- en: Another difference to note is that price is not an optional because it’s accessed
    directly as a value in the fruitBasket dictionary. That means we don’t have to
    unwrap it. You should still see the print statement printed three times. [Figure
    6-6](text00016.html#ch06fig6) shows the output of both loops.
  id: totrans-7790
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个需要注意的区别是价格不是可选的，因为它是通过直接访问fruitBasket字典中的值来获得的。这意味着我们不需要解包它。你应该仍然看到打印语句被打印三次。[图
    6-6](text00016.html#ch06fig6)展示了两个循环的输出。
- en: '![Image](Image00151.jpg)'
  id: totrans-7791
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00151.jpg)'
- en: '*Figure 6-6: Looping through the keys and values of a dictionary with a for-in
    loop*'
  id: totrans-7792
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 6-6：使用for-in循环遍历字典的键和值*'
- en: The order of your results might be slightly different from ours. That’s because
    the items in a dictionary aren’t in a numbered order like they are in an array!
    And because the order is not guaranteed, you might see a different order printed
    if you run the same code again.
  id: totrans-7793
  prefs: []
  type: TYPE_NORMAL
  zh: 你的结果顺序可能与我们的略有不同。这是因为字典中的项不像数组那样按编号顺序排列！而且由于顺序无法保证，如果你再次运行相同的代码，可能会看到不同的顺序。
- en: '**WHAT YOU LEARNED**'
  id: totrans-7794
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**你学到了什么**'
- en: In this chapter, you learned how to store collections of items in an array and
    in a dictionary. To store items in an ordered list, you would use an array and
    look up each item by its index. If you wanted to store items by key instead, you
    would use a dictionary.
  id: totrans-7795
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你学习了如何将项存储在数组和字典中。要将项存储在有序列表中，你会使用数组，并通过索引查找每个项。如果你想通过键来存储项，则需要使用字典。
- en: Knowing about arrays and dictionaries and how to use them is a powerful building
    block for almost any programming language. Next we will learn about functions,
    another very powerful tool. Functions are blocks of code that you create and name
    to perform a specific job. After you have written a function, you can use its
    name to call it from almost anywhere in your program.
  id: totrans-7796
  prefs: []
  type: TYPE_NORMAL
  zh: 了解数组和字典以及如何使用它们，是几乎所有编程语言中的一个强大构建块。接下来我们将学习函数，另一个非常强大的工具。函数是你创建并命名的一段代码，用来执行特定的任务。在你编写了一个函数之后，你可以通过它的名字在程序中的几乎任何地方调用它。
- en: Like any time you’re working with array index numbers, you have to be sure an
    item exists in the array at that index before you change its value, or you will
    get an Index out of range error.
  id: totrans-7797
  prefs: []
  type: TYPE_NORMAL
  zh: 就像你在处理数组索引时一样，你必须确保在修改数组中某个索引的值之前，该索引处确实存在项，否则你将遇到“索引超出范围”的错误。
- en: '[Figure 6-3](text00016.html#ch06fig3) shows the error that occurs if you try
    to add "Standard poodle" using favoriteAnimals[3] = "Standard poodle" . To add
    an item to the end of an array, you should use the append(_:) method or += , as
    we covered in “[Adding Items to an Array](text00016.html#ch06lev2sec5) ” on [page
    70](text00016.html#page_70) .'
  id: totrans-7798
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 6-3](text00016.html#ch06fig3) 显示了如果你尝试通过 `favoriteAnimals[3] = "Standard
    poodle"` 来添加 "标准贵宾犬"，会出现的错误。要向数组的末尾添加项目，你应该使用 `append(_:)` 方法或 `+=`，就像我们在 “[向数组添加项目](text00016.html#ch06lev2sec5)”
    一节中讲到的，在 [第 70 页](text00016.html#page_70)。'
- en: '![Image](Image00132.jpg)'
  id: totrans-7799
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00132.jpg)'
- en: '*Figure 6-3: Don’t try to replace a value at an index beyond the existing array.*'
  id: totrans-7800
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 6-3：不要尝试替换超出现有数组索引的值。*'
- en: Now you know how to change arrays however you might need to. You can add items,
    take items away, or replace items. Next, we’ll look at how to use the properties
    of arrays to find out even more information about them.
  id: totrans-7801
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你知道如何根据需要修改数组了。你可以添加项目、删除项目或替换项目。接下来，我们将看看如何利用数组的属性获取更多信息。
- en: '![Image](Image00133.jpg)'
  id: totrans-7802
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00133.jpg)'
- en: '**USING ARRAY PROPERTIES**'
  id: totrans-7803
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**使用数组属性**'
- en: In addition to methods like append(_:) and removeLast() , arrays also have *properties*
    . An array’s properties are variables or constants that contain some information
    about the array. Two really helpful properties that you might use are the Boolean
    property isEmpty and the integer property count .
  id: totrans-7804
  prefs: []
  type: TYPE_NORMAL
  zh: 除了像 `append(_:)` 和 `removeLast()` 这样的常用方法，数组还有 *属性*。数组的属性是包含有关数组的一些信息的变量或常量。你可能会使用的两个非常有用的属性是布尔类型的
    `isEmpty` 属性和整数类型的 `count` 属性。
- en: The isEmpty property is true or false depending on whether the array is empty,
    and the count property will tell you how many items are in that array.
  id: totrans-7805
  prefs: []
  type: TYPE_NORMAL
  zh: '`isEmpty` 属性会根据数组是否为空返回 `true` 或 `false`，而 `count` 属性则会告诉你数组中有多少个项目。'
- en: 'Check out how these two properties are used in the following if-else statement:'
  id: totrans-7806
  prefs: []
  type: TYPE_NORMAL
  zh: 请查看以下 if-else 语句中这两个属性的使用方式：
- en: '![Image](Image00134.jpg)'
  id: totrans-7807
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00134.jpg)'
- en: 'This if-else statement checks whether the array mySiblings is empty ➊ . If
    it is, then "I don''t have any siblings." is printed. But if there is something
    in the array, then the number of siblings that we have is printed: "I have 3 siblings."
    ➋ .'
  id: totrans-7808
  prefs: []
  type: TYPE_NORMAL
  zh: 这个 if-else 语句检查数组 `mySiblings` 是否为空 ➊。如果为空，则打印出 "我没有兄弟姐妹"。如果数组中有内容，则打印出我们有几个兄弟姐妹："我有
    3 个兄弟姐妹" ➋。
- en: '**LOOPING OVER AN ARRAY**'
  id: totrans-7809
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**遍历数组**'
- en: 'Sometimes when you’re working with arrays you might want to do something to
    every item in the array. You can use a for-in loop to do that! The following code
    will print every topping in a pizzaToppings array on a separate line:'
  id: totrans-7810
  prefs: []
  type: TYPE_NORMAL
  zh: 有时候在处理数组时，你可能想对数组中的每个元素进行某些操作。你可以使用 `for-in` 循环来实现这一点！以下代码会将 `pizzaToppings`
    数组中的每个配料打印在单独的一行上：
- en: '![Image](Image00135.jpg)'
  id: totrans-7811
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00135.jpg)'
- en: To write a for-in loop for the pizzaToppings array, we used the keyword for
    , followed by the constant topping , then the keyword in , and finally the name
    of our array, pizzaToppings . Then we put the statements that we want to run for
    each topping inside the braces of the for-in loop. The constant topping ➊ temporarily
    represents each pizza topping in the array as we loop through it. We could have
    chosen any name for this constant, but it’s a good idea to pick something that
    makes sense. You can see the output of this for-in loop in [Figure 6-4](text00016.html#ch06fig4)
    .
  id: totrans-7812
  prefs: []
  type: TYPE_NORMAL
  zh: 要编写针对 `pizzaToppings` 数组的 `for-in` 循环，我们使用了关键字 `for`，接着是常量 `topping`，然后是关键字
    `in`，最后是数组的名称 `pizzaToppings`。然后我们将希望在每次循环时执行的语句放入 `for-in` 循环的大括号内。常量 `topping`
    ➊ 在我们遍历数组时暂时表示每个比萨配料。我们本可以为这个常量选择任何名称，但选择一个有意义的名称是个好主意。你可以在[图 6-4](text00016.html#ch06fig4)中看到这个
    `for-in` 循环的输出。
- en: '![Image](Image00136.jpg)'
  id: totrans-7813
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00136.jpg)'
- en: '*Figure 6-4: Output of the example for-in loop*'
  id: totrans-7814
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 6-4：示例 `for-in` 循环的输出*'
- en: '![Image](Image00137.jpg)'
  id: totrans-7815
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00137.jpg)'
- en: 'Using for-in loops is great for printing every value in an array. If you’re
    working with numbers, you can even use them to perform math operations on each
    item, which makes for some speedy calculations! The following code takes an array
    of numbers and calculates the square for each (the square of a number is that
    number multiplied by itself):'
  id: totrans-7816
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `for-in` 循环是打印数组中每个值的好方法。如果你在处理数字，你甚至可以使用它们对每个元素执行数学运算，这样就能快速进行计算！以下代码接受一个数字数组，并计算每个数字的平方（数字的平方是该数字与自身相乘的结果）：
- en: '![Image](Image00138.jpg)'
  id: totrans-7817
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00138.jpg)'
- en: '[Figure 6-5](text00016.html#ch06fig5) shows the results.'
  id: totrans-7818
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 6-5](text00016.html#ch06fig5) 显示了结果。'
- en: '![Image](Image00139.jpg)'
  id: totrans-7819
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00139.jpg)'
- en: '*Figure 6-5: Printing the squares for each number in the myNumbers array*'
  id: totrans-7820
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 6-5：打印 myNumbers 数组中每个数字的平方*'
- en: '**DICTIONARIES ARE KEY!**'
  id: totrans-7821
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**字典是关键！**'
- en: A *dictionary* is also a collection of values, but instead of an ordered index,
    each value has its own *key* . Because there’s no index, the values are not stored
    in any particular order. To access values in a dictionary, you look them up by
    their key.
  id: totrans-7822
  prefs: []
  type: TYPE_NORMAL
  zh: '*字典* 也是一个值的集合，但不同于有序索引，每个值都有自己的*键*。因为没有索引，所以值并没有按特定顺序存储。要访问字典中的值，你需要通过键查找它们。'
- en: A key must be unique. You can’t have the same key more than once in the same
    dictionary. If there were two identical keys and you asked the computer to give
    you the value for one of them, the computer wouldn’t know which one to choose!
  id: totrans-7823
  prefs: []
  type: TYPE_NORMAL
  zh: 键必须是唯一的。你不能在同一个字典中有两个相同的键。如果有两个相同的键，而你要求计算机返回其中一个的值，计算机就不知道该选择哪个！
- en: Let’s take a look at how to make a dictionary and write keys that will help
    you find all the information you need.
  id: totrans-7824
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看如何创建一个字典，并编写可以帮助你找到所需信息的键。
- en: '![Image](Image00140.jpg)'
  id: totrans-7825
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Image00140.jpg)'
- en: '**INITIALIZING A DICTIONARY**'
  id: totrans-7826
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**初始化字典**'
- en: 'To create and initialize a dictionary, first write var and the name of your
    dictionary. Then write the keys and corresponding values inside a pair of square
    brackets, similar to an array. Let’s create a dictionary to store the names of
    a few US states. The key for each state will be its two-letter abbreviation:'
  id: totrans-7827
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建并初始化字典，首先写 var 和字典的名称。然后在一对方括号内写出键和值，类似于数组。让我们创建一个字典来存储一些美国州的名称。每个州的键将是它的两字母缩写：
- en: '![](Image00141.jpg)'
  id: totrans-7828
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00141.jpg)'
- en: As you can see, there’s a colon between each key and its value, and the key/value
    pairs are separated by commas.
  id: totrans-7829
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，键和值之间有一个冒号，键值对之间由逗号分隔。
- en: Dictionaries are different from arrays in that they are *unordered* . Because
    of that, it’s likely that the order of the states that you see in your results
    pane ➋ is different from the order in which you entered your states ➊ . It might
    even be different than the order that’s printed in this book!
  id: totrans-7830
  prefs: []
  type: TYPE_NORMAL
  zh: 字典与数组的不同之处在于它们是*无序的*。因此，你在结果面板 ➋ 中看到的州的顺序可能与你输入州的顺序 ➊ 不同。甚至可能与本书中打印的顺序不同！
- en: As with arrays, you can use var to make a mutable dictionary or use let to make
    an immutable dictionary.
  id: totrans-7831
  prefs: []
  type: TYPE_NORMAL
  zh: 和数组一样，你可以使用 var 来创建可变字典，或者使用 let 来创建不可变字典。
- en: 'In Swift, all of the keys of a dictionary must be the same type, and all of
    the values of a dictionary must also be the same type, but the key type doesn’t
    have to match the value type. For example, if you wanted to store a collection
    of fractions, you could use doubles for the keys and strings for the values:'
  id: totrans-7832
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Swift 中，字典的所有键必须是相同的类型，字典的所有值也必须是相同的类型，但键的类型不必与值的类型匹配。例如，如果你想存储一组分数，你可以使用双精度浮点数作为键，使用字符串作为值：
- en: '![](Image00142.jpg)'
  id: totrans-7833
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00142.jpg)'
- en: In this dictionary, all of the keys must be doubles, and all of the values must
    be strings. Again, you’ll see that the order of the numbers in the results pane
    can be quite different from the order in which you wrote the fractions in your
    dictionary. This is fine because you don’t need to know the order to access anything.
    You can find any item that you need by its key. Let’s see how!
  id: totrans-7834
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个字典中，所有的键必须是双精度浮点数，所有的值必须是字符串。再次提醒，你会看到结果面板中的数字顺序可能与字典中分数的顺序完全不同。这是没问题的，因为你不需要知道顺序就能访问任何内容。你可以通过键找到你需要的任何项。让我们看看如何做到这一点！
- en: '**ACCESSING VALUES IN A DICTIONARY**'
  id: totrans-7835
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**访问字典中的值**'
- en: 'Looking up a value in a dictionary is similar to how you access a value in
    an array except that you use a key inside the square brackets instead of an index,
    like this: usStates["TX"] .'
  id: totrans-7836
  prefs: []
  type: TYPE_NORMAL
  zh: 在字典中查找一个值类似于你如何访问数组中的值，区别在于你使用的是方括号内的键，而不是索引，像这样：usStates["TX"]。
- en: There is a big difference, however, in how Swift returns the values from a dictionary.
    When you access a value at an index of an array, you are simply given the value.
    When you access a value with a key in a dictionary, you are given an optional.
  id: totrans-7837
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在从字典中返回值时，Swift 有一个很大的区别。当你访问数组中某个索引的值时，你会直接得到该值。当你使用字典中的键来访问一个值时，你会得到一个可选值。
- en: In [Chapter 5](text00015.html#ch05) , you learned that optionals might contain
    a value or might be nil . The reason Swift returns optionals when you’re looking
    up items in a dictionary is that the key you used might not exist in the dictionary,
    in which case there’s no value to access. Trying to access a value that doesn’t
    exist would give you a big fat error! To avoid that problem, Swift returns optionals.
    That means you need to unwrap any value you get out of a dictionary before you
    can do anything with it.
  id: totrans-7838
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第5章](text00015.html#ch05)中，你学到了可选项可能包含一个值，也可能为nil。当你在字典中查找项目时，Swift 返回可选项是因为你使用的键可能在字典中不存在，在这种情况下没有值可供访问。试图访问一个不存在的值会导致一个大错误！为了避免这个问题，Swift
    返回了可选项。这意味着，在你对字典中的值进行任何操作之前，你需要解包（unwrap）它。
- en: 'To unwrap an optional, first you check whether it exists using an if-let statement,
    just like we did in [Chapter 5](text00015.html#ch05) . The following code shows
    you how to get a value out of a dictionary:'
  id: totrans-7839
  prefs: []
  type: TYPE_NORMAL
  zh: 要解包一个可选项，首先你需要使用 if-let 语句检查它是否存在，就像我们在[第5章](text00015.html#ch05)中做的那样。以下代码展示了如何从字典中获取一个值：
- en: '![Image](Image00143.jpg)'
  id: totrans-7840
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00143.jpg)'
- en: To retrieve "Texas" from the dictionary, we use if let to set a constant loneStarState
    to usStates["TX"] ➊ . Because we have this state in our dictionary, the line I
    have Texas in my dictionary. is printed. Next we try to access a state that is
    not in our dictionary by using the key usStates["FL"] ➋ . Thankfully, because
    we used an if-let statement, the program won’t crash when the computer can’t find
    this state. Instead, I don't have that state in my dictionary. is printed.
  id: totrans-7841
  prefs: []
  type: TYPE_NORMAL
  zh: 要从字典中检索 "Texas"，我们使用 if-let 将常量 loneStarState 设置为 usStates["TX"] ➊。因为我们在字典中有这个州，"I
    have Texas in my dictionary." 会被打印出来。接下来，我们尝试通过使用键 usStates["FL"] ➋ 访问一个不在字典中的州。幸运的是，因为我们使用了
    if-let 语句，当计算机找不到这个州时，程序不会崩溃。相反，"I don't have that state in my dictionary." 会被打印出来。
- en: '**ADDING ITEMS TO A DICTIONARY**'
  id: totrans-7842
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**向字典添加项目**'
- en: 'To add an item to a dictionary, first write the name of your dictionary and
    assign the new item to the key you want it to have in the dictionary. Let’s add
    "Minnesota" to our usStates dictionary:'
  id: totrans-7843
  prefs: []
  type: TYPE_NORMAL
  zh: 要向字典添加一个项目，首先写出字典的名称，然后将新项目分配给你希望它拥有的键。让我们向我们的 usStates 字典添加 "Minnesota"：
- en: '![](Image00144.jpg)'
  id: totrans-7844
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00144.jpg)'
- en: 'Now when you look at usStates , you’ll see that it’s updated to ["MN": "Minnesota",
    "WA": "Washington", "MA": "Massachusetts", "TX": "Texas"] . Remember, because
    you don’t have to rely on indices, your new dictionary item might appear anywhere
    in the dictionary.'
  id: totrans-7845
  prefs: []
  type: TYPE_NORMAL
  zh: '现在，当你查看 usStates 时，你会看到它已更新为 ["MN": "Minnesota", "WA": "Washington", "MA":
    "Massachusetts", "TX": "Texas"]。记住，因为你不必依赖索引，所以新的字典项目可能出现在字典的任何位置。'
- en: '**REMOVING ITEMS FROM A DICTIONARY**'
  id: totrans-7846
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**从字典中移除项目**'
- en: Removing an item from a dictionary is quite simple; you do so by setting the
    value to nil . Because the values in dictionaries are returned as optionals, you
    don’t have to worry about nil causing any problems in your dictionary.
  id: totrans-7847
  prefs: []
  type: TYPE_NORMAL
  zh: 从字典中移除项目非常简单；你只需将值设置为 nil。由于字典中的值是以可选项形式返回的，因此你不必担心 nil 会在字典中引起任何问题。
- en: '![](Image00145.jpg)'
  id: totrans-7848
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00145.jpg)'
- en: 'You can see that after you remove the value at the key "MA" , usStates is updated
    to ["MN": "Minnesota", "WA": "Washington", "TX": "Texas"] . Remember that nil
    is special and means that there’s no value at all. That’s why you don’t see "MA":
    nil in our dictionary.'
  id: totrans-7849
  prefs: []
  type: TYPE_NORMAL
  zh: '你可以看到，在移除键 "MA" 对应的值后，usStates 更新为 ["MN": "Minnesota", "WA": "Washington",
    "TX": "Texas"]。记住，nil 是特殊的，意味着没有任何值。这就是为什么你在我们的字典中看不到 "MA": nil。'
- en: '**REPLACING ITEMS IN A DICTIONARY**'
  id: totrans-7850
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**替换字典中的项目**'
- en: 'Replacing an item in a dictionary is also easy. It works the same was as replacing
    an item in an array. You just set the item that you want to replace to something
    else. Say you create a dictionary of fruit colors:'
  id: totrans-7851
  prefs: []
  type: TYPE_NORMAL
  zh: 替换字典中的项目也很简单。它的工作原理与替换数组中的项目相同。你只需要将你想替换的项目设置为其他值。假设你创建了一个关于水果颜色的字典：
- en: '![](Image00146.jpg)'
  id: totrans-7852
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00146.jpg)'
- en: At first we had the value "apple" for "red" , but then we decided that "raspberry"
    is a better fruit to use since sometimes apples are green or yellow. To replace
    "apple" with "raspberry" , we set colorFruits["red"] to its new value ➊ .
  id: totrans-7853
  prefs: []
  type: TYPE_NORMAL
  zh: 最初，我们为 "red" 设置了值 "apple"，但后来我们决定用 "raspberry" 作为更好的水果，因为有时候苹果是绿色或黄色的。要用 "raspberry"
    替换 "apple"，我们将 colorFruits["red"] 设置为它的新值 ➊。
- en: You may remember that this is the same way we entered a new value into a dictionary.
    If the key already exists in the dictionary, then the value for that key is replaced.
    If the key doesn’t already exist, then the new key/value pair will be added to
    the dictionary.
  id: totrans-7854
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能记得，这和我们向字典中插入新值的方法是一样的。如果键已经存在于字典中，那么该键的值会被替换。如果键不存在，则新的键/值对会被添加到字典中。
- en: '![Image](Image00147.jpg)'
  id: totrans-7855
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00147.jpg)'
- en: '**USING DICTIONARY PROPERTIES**'
  id: totrans-7856
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**使用字典属性**'
- en: 'Like an array, a dictionary also has an isEmpty property and a count property.
    For example, the following code shows how you can use the isEmpty property to
    check if a dictionary is empty, and if it isn’t empty, the count property checks
    how many items you have. Imagine you have a basket of fruit for sale. You can
    use these properties to help you keep track of everything:'
  id: totrans-7857
  prefs: []
  type: TYPE_NORMAL
  zh: 像数组一样，字典也有 `isEmpty` 属性和 `count` 属性。例如，下面的代码展示了如何使用 `isEmpty` 属性来检查字典是否为空，如果不为空，`count`
    属性将检查字典中有多少项。假设你有一个待售的水果篮子，你可以使用这些属性来帮助你跟踪所有的内容：
- en: '![Image](Image00148.jpg)'
  id: totrans-7858
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00148.jpg)'
- en: 'A dictionary also has two special properties: keys , which contains all of
    the dictionary’s keys, and values , which contains all of its values. We’ll use
    these two properties when we loop through the dictionary.'
  id: totrans-7859
  prefs: []
  type: TYPE_NORMAL
  zh: 字典还有两个特殊属性：`keys`，包含所有字典的键，以及 `values`，包含所有的值。我们将在遍历字典时使用这两个属性。
- en: Let’s write some code that loops through our fruit baskets and prints the price
    of each fruit.
  id: totrans-7860
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们编写一些代码，遍历我们的水果篮子并打印每种水果的价格。
- en: '**LOOPING OVER A DICTIONARY**'
  id: totrans-7861
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**遍历字典**'
- en: 'You can loop through a dictionary using a for-in loop. Because each item has
    a key and a value, you can do this in two different ways. This is how to loop
    through a dictionary using its keys:'
  id: totrans-7862
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用 `for-in` 循环来遍历字典。因为每一项都有一个键和值，所以你可以用两种不同的方式来遍历字典。这是通过字典的键来遍历字典的方法：
- en: '![Image](Image00149.jpg)'
  id: totrans-7863
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00149.jpg)'
- en: Here we use the dictionary’s keys property ➊ to loop through fruitBasket and
    print its contents. We start by writing the keyword for , followed by a constant
    name fruit for the dictionary key, the keyword in , the dictionary name, a period,
    and keys .
  id: totrans-7864
  prefs: []
  type: TYPE_NORMAL
  zh: 这里我们使用字典的 `keys` 属性 ➊ 来遍历 `fruitBasket` 并打印其内容。我们首先写上 `for` 关键字，接着是字典键的常量名称
    `fruit`，然后是 `in` 关键字，接着是字典名称，接着是一个点，最后是 `keys`。
- en: Inside the braces of our for-in loop, we have access to both the key, which
    we call fruit ➋ , and the value at that key when we force-unwrap its contents
    with fruitBasket[fruit]! ➌ . That value will be the fruit’s price.
  id: totrans-7865
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `for-in` 循环的大括号内，我们可以访问到键（我们称之为 fruit ➋），以及在强制解包字典内容时使用 `fruitBasket[fruit]!`
    获取到的该键对应的值 ➌ 。这个值就是水果的价格。
- en: In this case, it’s safe to force-unwrap the value using an exclamation point
    because we know that the fruit key we’re using is definitely inside the dictionary.
  id: totrans-7866
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，使用感叹号强制解包值是安全的，因为我们知道我们使用的水果键一定在字典中。
- en: Any code we put inside the for-in loop will run once for every key in our dictionary.
    So you should see the print statement display three times.
  id: totrans-7867
  prefs: []
  type: TYPE_NORMAL
  zh: 我们放入 `for-in` 循环中的任何代码都会针对字典中的每一个键执行一次。所以你应该看到打印语句执行三次。
- en: 'We can also loop through the dictionary using its values property:'
  id: totrans-7868
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以通过字典的 `values` 属性来遍历字典：
- en: '![Image](Image00150.jpg)'
  id: totrans-7869
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00150.jpg)'
- en: We use the same style of for-in loop, but now we use a constant to refer to
    each value, which we call price , in the values property. When looping through
    values, we don’t have access to the keys from inside the loop.
  id: totrans-7870
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用相同的 `for-in` 循环风格，但现在我们使用一个常量来引用每一个值，我们称之为 price ，这个值来自 `values` 属性。在遍历值时，我们无法通过循环内部访问键。
- en: Another difference to note is that price is not an optional because it’s accessed
    directly as a value in the fruitBasket dictionary. That means we don’t have to
    unwrap it. You should still see the print statement printed three times. [Figure
    6-6](text00016.html#ch06fig6) shows the output of both loops.
  id: totrans-7871
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个需要注意的区别是，price 不是可选类型，因为它是直接作为 `fruitBasket` 字典中的值来访问的。这意味着我们不需要解包它。你仍然会看到打印语句执行三次。[图
    6-6](text00016.html#ch06fig6) 显示了两个循环的输出结果。
- en: '![Image](Image00151.jpg)'
  id: totrans-7872
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00151.jpg)'
- en: '*Figure 6-6: Looping through the keys and values of a dictionary with a for-in
    loop*'
  id: totrans-7873
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 6-6：使用 `for-in` 循环遍历字典的键和值*'
- en: The order of your results might be slightly different from ours. That’s because
    the items in a dictionary aren’t in a numbered order like they are in an array!
    And because the order is not guaranteed, you might see a different order printed
    if you run the same code again.
  id: totrans-7874
  prefs: []
  type: TYPE_NORMAL
  zh: 你的结果顺序可能与我们的略有不同。这是因为字典中的项目不像数组那样按数字顺序排列！由于顺序无法保证，如果你再次运行相同的代码，可能会看到不同的顺序。
- en: '**WHAT YOU LEARNED**'
  id: totrans-7875
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**你学到的知识**'
- en: In this chapter, you learned how to store collections of items in an array and
    in a dictionary. To store items in an ordered list, you would use an array and
    look up each item by its index. If you wanted to store items by key instead, you
    would use a dictionary.
  id: totrans-7876
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你学会了如何将项目存储在数组和字典中。要将项目存储在有序列表中，你将使用数组，并通过索引查找每个项目。如果你想按键存储项目，则应使用字典。
- en: Knowing about arrays and dictionaries and how to use them is a powerful building
    block for almost any programming language. Next we will learn about functions,
    another very powerful tool. Functions are blocks of code that you create and name
    to perform a specific job. After you have written a function, you can use its
    name to call it from almost anywhere in your program.
  id: totrans-7877
  prefs: []
  type: TYPE_NORMAL
  zh: 了解数组和字典以及如何使用它们，是几乎所有编程语言中一个强大的构建模块。接下来，我们将学习函数，另一个非常强大的工具。函数是你创建并命名的代码块，用于执行特定的任务。编写完函数后，你可以在程序的几乎任何地方使用它的名称来调用它。
- en: '[Figure 6-3](text00016.html#ch06fig3) shows the error that occurs if you try
    to add "Standard poodle" using favoriteAnimals[3] = "Standard poodle" . To add
    an item to the end of an array, you should use the append(_:) method or += , as
    we covered in “[Adding Items to an Array](text00016.html#ch06lev2sec5) ” on [page
    70](text00016.html#page_70) .'
  id: totrans-7878
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 6-3](text00016.html#ch06fig3) 显示了如果你尝试使用 favoriteAnimals[3] = "Standard
    poodle" 来添加 "Standard poodle" 时发生的错误。要将项目添加到数组的末尾，应该使用 append(_:) 方法或 += ，如我们在
    “[向数组添加项目](text00016.html#ch06lev2sec5)” 中所讲的，在 [第 70 页](text00016.html#page_70)。'
- en: '![Image](Image00132.jpg)'
  id: totrans-7879
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00132.jpg)'
- en: '*Figure 6-3: Don’t try to replace a value at an index beyond the existing array.*'
  id: totrans-7880
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 6-3：不要尝试替换超过现有数组索引的值。*'
- en: Now you know how to change arrays however you might need to. You can add items,
    take items away, or replace items. Next, we’ll look at how to use the properties
    of arrays to find out even more information about them.
  id: totrans-7881
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你知道如何根据需要更改数组了。你可以添加项目、删除项目或替换项目。接下来，我们将看看如何使用数组的属性来获取更多关于数组的信息。
- en: '![Image](Image00133.jpg)'
  id: totrans-7882
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00133.jpg)'
- en: '**USING ARRAY PROPERTIES**'
  id: totrans-7883
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**使用数组属性**'
- en: In addition to methods like append(_:) and removeLast() , arrays also have *properties*
    . An array’s properties are variables or constants that contain some information
    about the array. Two really helpful properties that you might use are the Boolean
    property isEmpty and the integer property count .
  id: totrans-7884
  prefs: []
  type: TYPE_NORMAL
  zh: 除了像 append(_:) 和 removeLast() 这样的函数，数组还有 *属性*。数组的属性是包含有关数组信息的变量或常量。有两个非常有用的属性，你可能会用到：布尔型属性
    isEmpty 和整型属性 count。
- en: The isEmpty property is true or false depending on whether the array is empty,
    and the count property will tell you how many items are in that array.
  id: totrans-7885
  prefs: []
  type: TYPE_NORMAL
  zh: isEmpty 属性根据数组是否为空返回 true 或 false，而 count 属性则告诉你数组中有多少个项目。
- en: 'Check out how these two properties are used in the following if-else statement:'
  id: totrans-7886
  prefs: []
  type: TYPE_NORMAL
  zh: 查看以下 if-else 语句中如何使用这两个属性：
- en: '![Image](Image00134.jpg)'
  id: totrans-7887
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00134.jpg)'
- en: 'This if-else statement checks whether the array mySiblings is empty ➊ . If
    it is, then "I don''t have any siblings." is printed. But if there is something
    in the array, then the number of siblings that we have is printed: "I have 3 siblings."
    ➋ .'
  id: totrans-7888
  prefs: []
  type: TYPE_NORMAL
  zh: 这个 if-else 语句检查数组 mySiblings 是否为空 ➊。如果为空，则打印 "我没有兄弟姐妹"。但如果数组中有内容，则会打印我们有多少个兄弟姐妹："我有
    3 个兄弟姐妹" ➋。
- en: '**LOOPING OVER AN ARRAY**'
  id: totrans-7889
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**遍历数组**'
- en: 'Sometimes when you’re working with arrays you might want to do something to
    every item in the array. You can use a for-in loop to do that! The following code
    will print every topping in a pizzaToppings array on a separate line:'
  id: totrans-7890
  prefs: []
  type: TYPE_NORMAL
  zh: 有时当你处理数组时，可能想对数组中的每个项目做一些操作。你可以使用 for-in 循环来做到这一点！以下代码将打印 pizzaToppings 数组中的每个配料，每个配料占一行：
- en: '![Image](Image00135.jpg)'
  id: totrans-7891
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00135.jpg)'
- en: To write a for-in loop for the pizzaToppings array, we used the keyword for
    , followed by the constant topping , then the keyword in , and finally the name
    of our array, pizzaToppings . Then we put the statements that we want to run for
    each topping inside the braces of the for-in loop. The constant topping ➊ temporarily
    represents each pizza topping in the array as we loop through it. We could have
    chosen any name for this constant, but it’s a good idea to pick something that
    makes sense. You can see the output of this for-in loop in [Figure 6-4](text00016.html#ch06fig4)
    .
  id: totrans-7892
  prefs: []
  type: TYPE_NORMAL
  zh: 要为 pizzaToppings 数组编写一个 for-in 循环，我们使用了关键字 for，接着是常量 topping，然后是关键字 in，最后是我们数组的名称
    pizzaToppings。然后我们将想要对每个 topping 执行的语句放入 for-in 循环的花括号中。常量 topping ➊ 在我们遍历数组时暂时表示每个比萨配料。我们本可以为这个常量选择任何名字，但最好选择一个有意义的名字。你可以在
    [图 6-4](text00016.html#ch06fig4) 中看到这个 for-in 循环的输出。
- en: '![Image](Image00136.jpg)'
  id: totrans-7893
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Image00136.jpg)'
- en: '*Figure 6-4: Output of the example for-in loop*'
  id: totrans-7894
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 6-4：示例 for-in 循环的输出*'
- en: '![Image](Image00137.jpg)'
  id: totrans-7895
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Image00137.jpg)'
- en: 'Using for-in loops is great for printing every value in an array. If you’re
    working with numbers, you can even use them to perform math operations on each
    item, which makes for some speedy calculations! The following code takes an array
    of numbers and calculates the square for each (the square of a number is that
    number multiplied by itself):'
  id: totrans-7896
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 for-in 循环打印数组中的每个值非常方便。如果你在处理数字，你甚至可以利用它们对每个项执行数学运算，这样可以进行快速计算！以下代码接受一个数字数组，并计算每个数字的平方（一个数字的平方是该数字乘以它本身）：
- en: '![Image](Image00138.jpg)'
  id: totrans-7897
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Image00138.jpg)'
- en: '[Figure 6-5](text00016.html#ch06fig5) shows the results.'
  id: totrans-7898
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 6-5](text00016.html#ch06fig5) 显示了结果。'
- en: '![Image](Image00139.jpg)'
  id: totrans-7899
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Image00139.jpg)'
- en: '*Figure 6-5: Printing the squares for each number in the myNumbers array*'
  id: totrans-7900
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 6-5：打印 myNumbers 数组中每个数字的平方*'
- en: '**DICTIONARIES ARE KEY!**'
  id: totrans-7901
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**字典是关键！**'
- en: A *dictionary* is also a collection of values, but instead of an ordered index,
    each value has its own *key* . Because there’s no index, the values are not stored
    in any particular order. To access values in a dictionary, you look them up by
    their key.
  id: totrans-7902
  prefs: []
  type: TYPE_NORMAL
  zh: '*字典*也是一个值的集合，但与数组不同，字典中的每个值都有自己的*键*。由于没有索引，字典中的值没有固定的顺序。要访问字典中的值，你需要通过键来查找它们。'
- en: A key must be unique. You can’t have the same key more than once in the same
    dictionary. If there were two identical keys and you asked the computer to give
    you the value for one of them, the computer wouldn’t know which one to choose!
  id: totrans-7903
  prefs: []
  type: TYPE_NORMAL
  zh: 一个键必须是唯一的。你不能在同一个字典中使用相同的键两次。如果有两个相同的键，而你要求计算机给出其中一个的值，计算机就不知道该选择哪一个！
- en: Let’s take a look at how to make a dictionary and write keys that will help
    you find all the information you need.
  id: totrans-7904
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看如何创建一个字典，并编写键值对来帮助你查找所有需要的信息。
- en: '![Image](Image00140.jpg)'
  id: totrans-7905
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Image00140.jpg)'
- en: '**INITIALIZING A DICTIONARY**'
  id: totrans-7906
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**初始化字典**'
- en: 'To create and initialize a dictionary, first write var and the name of your
    dictionary. Then write the keys and corresponding values inside a pair of square
    brackets, similar to an array. Let’s create a dictionary to store the names of
    a few US states. The key for each state will be its two-letter abbreviation:'
  id: totrans-7907
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建并初始化一个字典，首先写 var 和字典的名称。然后在一对方括号中写入键和值，类似于数组的方式。让我们创建一个字典来存储几个美国州的名称。每个州的键将是它的两字母缩写：
- en: '![](Image00141.jpg)'
  id: totrans-7908
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00141.jpg)'
- en: As you can see, there’s a colon between each key and its value, and the key/value
    pairs are separated by commas.
  id: totrans-7909
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，每个键和值之间有一个冒号，键/值对之间用逗号分隔。
- en: Dictionaries are different from arrays in that they are *unordered* . Because
    of that, it’s likely that the order of the states that you see in your results
    pane ➋ is different from the order in which you entered your states ➊ . It might
    even be different than the order that’s printed in this book!
  id: totrans-7910
  prefs: []
  type: TYPE_NORMAL
  zh: 字典与数组不同，它们是*无序*的。因此，结果窗格 ➋ 中显示的状态顺序很可能与您输入的状态顺序 ➊ 不同。它甚至可能与本书中打印的顺序不同！
- en: As with arrays, you can use var to make a mutable dictionary or use let to make
    an immutable dictionary.
  id: totrans-7911
  prefs: []
  type: TYPE_NORMAL
  zh: 与数组一样，你可以使用 var 来创建一个可变字典，或者使用 let 来创建一个不可变字典。
- en: 'In Swift, all of the keys of a dictionary must be the same type, and all of
    the values of a dictionary must also be the same type, but the key type doesn’t
    have to match the value type. For example, if you wanted to store a collection
    of fractions, you could use doubles for the keys and strings for the values:'
  id: totrans-7912
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Swift 中，字典的所有键必须是相同的类型，而字典的所有值也必须是相同的类型，但键的类型不必与值的类型匹配。例如，如果你想存储一组分数，你可以使用双精度浮点数作为键，字符串作为值：
- en: '![](Image00142.jpg)'
  id: totrans-7913
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00142.jpg)'
- en: In this dictionary, all of the keys must be doubles, and all of the values must
    be strings. Again, you’ll see that the order of the numbers in the results pane
    can be quite different from the order in which you wrote the fractions in your
    dictionary. This is fine because you don’t need to know the order to access anything.
    You can find any item that you need by its key. Let’s see how!
  id: totrans-7914
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个字典中，所有的键必须是双精度浮点数，所有的值必须是字符串。同样，你会看到结果面板中的数字顺序可能与在字典中写入分数的顺序大不相同。这是可以的，因为你不需要知道顺序就能访问任何项目。你可以通过键找到你需要的任何项目。我们来看看怎么做！
- en: '**ACCESSING VALUES IN A DICTIONARY**'
  id: totrans-7915
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**访问字典中的值**'
- en: 'Looking up a value in a dictionary is similar to how you access a value in
    an array except that you use a key inside the square brackets instead of an index,
    like this: usStates["TX"] .'
  id: totrans-7916
  prefs: []
  type: TYPE_NORMAL
  zh: 在字典中查找一个值的方式类似于在数组中访问值，不同之处在于，你使用键而不是索引来访问值，例如：usStates["TX"]。
- en: There is a big difference, however, in how Swift returns the values from a dictionary.
    When you access a value at an index of an array, you are simply given the value.
    When you access a value with a key in a dictionary, you are given an optional.
  id: totrans-7917
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，有一个很大的区别，就是 Swift 返回字典中的值的方式。当你通过数组的索引访问一个值时，你会直接得到值。而当你通过字典的键访问一个值时，你得到的是一个可选项。
- en: In [Chapter 5](text00015.html#ch05) , you learned that optionals might contain
    a value or might be nil . The reason Swift returns optionals when you’re looking
    up items in a dictionary is that the key you used might not exist in the dictionary,
    in which case there’s no value to access. Trying to access a value that doesn’t
    exist would give you a big fat error! To avoid that problem, Swift returns optionals.
    That means you need to unwrap any value you get out of a dictionary before you
    can do anything with it.
  id: totrans-7918
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第5章](text00015.html#ch05)中，你学到了可选项可能包含一个值，也可能是 nil。Swift 返回可选项的原因是，当你在字典中查找项目时，所用的键可能在字典中不存在，这种情况下就没有值可供访问。如果你尝试访问一个不存在的值，程序会报错！为了避免这种问题，Swift
    返回可选项。这意味着，在你对从字典中获取的任何值进行操作之前，你需要解包它。
- en: 'To unwrap an optional, first you check whether it exists using an if-let statement,
    just like we did in [Chapter 5](text00015.html#ch05) . The following code shows
    you how to get a value out of a dictionary:'
  id: totrans-7919
  prefs: []
  type: TYPE_NORMAL
  zh: 要解包一个可选项，首先你需要使用 if-let 语句检查它是否存在，就像我们在[第5章](text00015.html#ch05)中做的那样。以下代码展示了如何从字典中获取一个值：
- en: '![Image](Image00143.jpg)'
  id: totrans-7920
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00143.jpg)'
- en: To retrieve "Texas" from the dictionary, we use if let to set a constant loneStarState
    to usStates["TX"] ➊ . Because we have this state in our dictionary, the line I
    have Texas in my dictionary. is printed. Next we try to access a state that is
    not in our dictionary by using the key usStates["FL"] ➋ . Thankfully, because
    we used an if-let statement, the program won’t crash when the computer can’t find
    this state. Instead, I don't have that state in my dictionary. is printed.
  id: totrans-7921
  prefs: []
  type: TYPE_NORMAL
  zh: 要从字典中检索 "Texas"，我们使用 if-let 来将常量 loneStarState 设置为 usStates["TX"] ➊。因为字典中有这个州，所以会打印出
    "I have Texas in my dictionary." 接下来，我们尝试使用键 usStates["FL"] ➋ 访问一个不在字典中的州。幸运的是，由于我们使用了
    if-let 语句，当计算机找不到这个州时，程序不会崩溃，而是打印出 "I don't have that state in my dictionary."。
- en: '**ADDING ITEMS TO A DICTIONARY**'
  id: totrans-7922
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**向字典添加项目**'
- en: 'To add an item to a dictionary, first write the name of your dictionary and
    assign the new item to the key you want it to have in the dictionary. Let’s add
    "Minnesota" to our usStates dictionary:'
  id: totrans-7923
  prefs: []
  type: TYPE_NORMAL
  zh: 要向字典添加项目，首先写出字典的名称，然后将新项目分配给你希望它在字典中拥有的键。我们来将 "Minnesota" 添加到我们的 usStates 字典中：
- en: '![](Image00144.jpg)'
  id: totrans-7924
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00144.jpg)'
- en: 'Now when you look at usStates , you’ll see that it’s updated to ["MN": "Minnesota",
    "WA": "Washington", "MA": "Massachusetts", "TX": "Texas"] . Remember, because
    you don’t have to rely on indices, your new dictionary item might appear anywhere
    in the dictionary.'
  id: totrans-7925
  prefs: []
  type: TYPE_NORMAL
  zh: '现在，当你查看 usStates 时，你会看到它已更新为 ["MN": "Minnesota", "WA": "Washington", "MA":
    "Massachusetts", "TX": "Texas"]。记住，由于你不需要依赖索引，你的新字典项目可能出现在字典中的任何位置。'
- en: '**REMOVING ITEMS FROM A DICTIONARY**'
  id: totrans-7926
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**从字典中删除项目**'
- en: Removing an item from a dictionary is quite simple; you do so by setting the
    value to nil . Because the values in dictionaries are returned as optionals, you
    don’t have to worry about nil causing any problems in your dictionary.
  id: totrans-7927
  prefs: []
  type: TYPE_NORMAL
  zh: 从字典中移除一个项非常简单；你只需将该值设置为 nil 。由于字典中的值会以可选项形式返回，因此你不必担心 nil 会在字典中引发任何问题。
- en: '![](Image00145.jpg)'
  id: totrans-7928
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00145.jpg)'
- en: 'You can see that after you remove the value at the key "MA" , usStates is updated
    to ["MN": "Minnesota", "WA": "Washington", "TX": "Texas"] . Remember that nil
    is special and means that there’s no value at all. That’s why you don’t see "MA":
    nil in our dictionary.'
  id: totrans-7929
  prefs: []
  type: TYPE_NORMAL
  zh: '你可以看到，当你移除 "MA" 键的值后，usStates 更新为 ["MN": "Minnesota", "WA": "Washington", "TX":
    "Texas"] 。记住，nil 是特殊的，表示完全没有值。这就是为什么你在字典中看不到 "MA": nil 的原因。'
- en: '**REPLACING ITEMS IN A DICTIONARY**'
  id: totrans-7930
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**替换字典中的项**'
- en: 'Replacing an item in a dictionary is also easy. It works the same was as replacing
    an item in an array. You just set the item that you want to replace to something
    else. Say you create a dictionary of fruit colors:'
  id: totrans-7931
  prefs: []
  type: TYPE_NORMAL
  zh: 替换字典中的项也很简单。它的工作方式与替换数组中的项相同。你只需要将你想替换的项设置为其他内容。例如，你创建了一个水果颜色的字典：
- en: '![](Image00146.jpg)'
  id: totrans-7932
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00146.jpg)'
- en: At first we had the value "apple" for "red" , but then we decided that "raspberry"
    is a better fruit to use since sometimes apples are green or yellow. To replace
    "apple" with "raspberry" , we set colorFruits["red"] to its new value ➊ .
  id: totrans-7933
  prefs: []
  type: TYPE_NORMAL
  zh: 最初我们为 "red" 设置了 "apple" 这个值，但后来我们决定使用 "raspberry" 更好，因为有时苹果是绿色或黄色的。为了将 "apple"
    替换为 "raspberry"，我们将 colorFruits["red"] 设置为新的值 ➊ 。
- en: You may remember that this is the same way we entered a new value into a dictionary.
    If the key already exists in the dictionary, then the value for that key is replaced.
    If the key doesn’t already exist, then the new key/value pair will be added to
    the dictionary.
  id: totrans-7934
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能记得，这与我们向字典中添加新值的方式相同。如果键已经存在于字典中，那么该键的值将被替换。如果键不存在，那么新的键值对将被添加到字典中。
- en: '![Image](Image00147.jpg)'
  id: totrans-7935
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00147.jpg)'
- en: '**USING DICTIONARY PROPERTIES**'
  id: totrans-7936
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**使用字典属性**'
- en: 'Like an array, a dictionary also has an isEmpty property and a count property.
    For example, the following code shows how you can use the isEmpty property to
    check if a dictionary is empty, and if it isn’t empty, the count property checks
    how many items you have. Imagine you have a basket of fruit for sale. You can
    use these properties to help you keep track of everything:'
  id: totrans-7937
  prefs: []
  type: TYPE_NORMAL
  zh: 就像数组一样，字典也有一个 isEmpty 属性和一个 count 属性。例如，以下代码展示了如何使用 isEmpty 属性检查字典是否为空，如果不为空，则使用
    count 属性检查字典中有多少项。假设你有一个出售水果的篮子，你可以利用这些属性帮助你跟踪所有内容：
- en: '![Image](Image00148.jpg)'
  id: totrans-7938
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00148.jpg)'
- en: 'A dictionary also has two special properties: keys , which contains all of
    the dictionary’s keys, and values , which contains all of its values. We’ll use
    these two properties when we loop through the dictionary.'
  id: totrans-7939
  prefs: []
  type: TYPE_NORMAL
  zh: 字典还具有两个特殊的属性：keys ，它包含了字典的所有键；以及 values ，它包含了字典的所有值。我们将在遍历字典时使用这两个属性。
- en: Let’s write some code that loops through our fruit baskets and prints the price
    of each fruit.
  id: totrans-7940
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们写一些代码，遍历我们的水果篮子，并打印每个水果的价格。
- en: '**LOOPING OVER A DICTIONARY**'
  id: totrans-7941
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**遍历字典**'
- en: 'You can loop through a dictionary using a for-in loop. Because each item has
    a key and a value, you can do this in two different ways. This is how to loop
    through a dictionary using its keys:'
  id: totrans-7942
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用 for-in 循环遍历字典。因为每个项都有一个键和值，所以你可以用两种不同的方式来做。以下是通过字典的键遍历字典的方法：
- en: '![Image](Image00149.jpg)'
  id: totrans-7943
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00149.jpg)'
- en: Here we use the dictionary’s keys property ➊ to loop through fruitBasket and
    print its contents. We start by writing the keyword for , followed by a constant
    name fruit for the dictionary key, the keyword in , the dictionary name, a period,
    and keys .
  id: totrans-7944
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们使用字典的 keys 属性 ➊ 来遍历 fruitBasket 并打印其内容。我们首先写出关键字 for ，接着是常量名 fruit 作为字典的键，关键字
    in ，字典名称，接一个句点，再加上 keys 。
- en: Inside the braces of our for-in loop, we have access to both the key, which
    we call fruit ➋ , and the value at that key when we force-unwrap its contents
    with fruitBasket[fruit]! ➌ . That value will be the fruit’s price.
  id: totrans-7945
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的 for-in 循环的花括号内，我们可以访问到键值，也就是我们称之为果实 ➋ ，以及当我们强制解包 `fruitBasket[fruit]!`
    ➌ 时该键的值。这个值将是水果的价格。
- en: In this case, it’s safe to force-unwrap the value using an exclamation point
    because we know that the fruit key we’re using is definitely inside the dictionary.
  id: totrans-7946
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，使用感叹号强制解包值是安全的，因为我们知道我们正在使用的水果键肯定在字典中。
- en: Any code we put inside the for-in loop will run once for every key in our dictionary.
    So you should see the print statement display three times.
  id: totrans-7947
  prefs: []
  type: TYPE_NORMAL
  zh: 我们放入 for-in 循环中的任何代码都会在字典的每个键上执行一次。所以你应该看到打印语句显示三次。
- en: 'We can also loop through the dictionary using its values property:'
  id: totrans-7948
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以使用字典的 values 属性来遍历字典：
- en: '![Image](Image00150.jpg)'
  id: totrans-7949
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Image00150.jpg)'
- en: We use the same style of for-in loop, but now we use a constant to refer to
    each value, which we call price , in the values property. When looping through
    values, we don’t have access to the keys from inside the loop.
  id: totrans-7950
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用相同的 for-in 循环风格，但现在我们使用一个常量来引用 values 属性中的每个值，称之为 price。在遍历值时，我们无法从循环内部访问键。
- en: Another difference to note is that price is not an optional because it’s accessed
    directly as a value in the fruitBasket dictionary. That means we don’t have to
    unwrap it. You should still see the print statement printed three times. [Figure
    6-6](text00016.html#ch06fig6) shows the output of both loops.
  id: totrans-7951
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个值得注意的区别是，price 不是一个可选项，因为它是直接作为值在 fruitBasket 字典中访问的。这意味着我们不需要解包它。你仍然应该看到打印语句打印三次。[图
    6-6](text00016.html#ch06fig6) 显示了两个循环的输出。
- en: '![Image](Image00151.jpg)'
  id: totrans-7952
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Image00151.jpg)'
- en: '*Figure 6-6: Looping through the keys and values of a dictionary with a for-in
    loop*'
  id: totrans-7953
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 6-6：使用 for-in 循环遍历字典的键和值*'
- en: The order of your results might be slightly different from ours. That’s because
    the items in a dictionary aren’t in a numbered order like they are in an array!
    And because the order is not guaranteed, you might see a different order printed
    if you run the same code again.
  id: totrans-7954
  prefs: []
  type: TYPE_NORMAL
  zh: 你的结果顺序可能与你的有所不同。这是因为字典中的项目不像数组那样是按编号顺序排列的！由于顺序无法保证，如果你再次运行相同的代码，可能会看到不同的顺序被打印出来。
- en: '**WHAT YOU LEARNED**'
  id: totrans-7955
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**你学到了什么**'
- en: In this chapter, you learned how to store collections of items in an array and
    in a dictionary. To store items in an ordered list, you would use an array and
    look up each item by its index. If you wanted to store items by key instead, you
    would use a dictionary.
  id: totrans-7956
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你学习了如何将项目集合存储在数组和字典中。要将项目存储在有序列表中，你可以使用数组，并通过索引查找每个项目。如果你想按键存储项目，则应使用字典。
- en: Knowing about arrays and dictionaries and how to use them is a powerful building
    block for almost any programming language. Next we will learn about functions,
    another very powerful tool. Functions are blocks of code that you create and name
    to perform a specific job. After you have written a function, you can use its
    name to call it from almost anywhere in your program.
  id: totrans-7957
  prefs: []
  type: TYPE_NORMAL
  zh: 了解数组和字典及其使用方法是几乎所有编程语言中的一个强大构建块。接下来，我们将学习函数，这是另一个非常强大的工具。函数是你创建并命名的代码块，用于执行特定任务。在你编写了一个函数之后，可以在程序中的几乎任何地方通过它的名字来调用它。
- en: '![Image](Image00132.jpg)'
  id: totrans-7958
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Image00132.jpg)'
- en: '*Figure 6-3: Don’t try to replace a value at an index beyond the existing array.*'
  id: totrans-7959
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 6-3：不要尝试替换超出现有数组索引的值。*'
- en: Now you know how to change arrays however you might need to. You can add items,
    take items away, or replace items. Next, we’ll look at how to use the properties
    of arrays to find out even more information about them.
  id: totrans-7960
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你知道如何根据需要修改数组。你可以添加项目、移除项目或替换项目。接下来，我们将查看如何使用数组的属性来获取更多关于数组的信息。
- en: '![Image](Image00133.jpg)'
  id: totrans-7961
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Image00133.jpg)'
- en: '**USING ARRAY PROPERTIES**'
  id: totrans-7962
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**使用数组属性**'
- en: In addition to methods like append(_:) and removeLast() , arrays also have *properties*
    . An array’s properties are variables or constants that contain some information
    about the array. Two really helpful properties that you might use are the Boolean
    property isEmpty and the integer property count .
  id: totrans-7963
  prefs: []
  type: TYPE_NORMAL
  zh: 除了像 append(_:) 和 removeLast() 这样的函数，数组还有 *属性*。数组的属性是包含关于数组信息的变量或常量。你可能会使用的两个非常有用的属性是布尔值属性
    isEmpty 和整数属性 count。
- en: The isEmpty property is true or false depending on whether the array is empty,
    and the count property will tell you how many items are in that array.
  id: totrans-7964
  prefs: []
  type: TYPE_NORMAL
  zh: isEmpty 属性的值为真或假，取决于数组是否为空，count 属性将告诉你数组中有多少个项目。
- en: 'Check out how these two properties are used in the following if-else statement:'
  id: totrans-7965
  prefs: []
  type: TYPE_NORMAL
  zh: 查看以下 if-else 语句中如何使用这两个属性：
- en: '![Image](Image00134.jpg)'
  id: totrans-7966
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Image00134.jpg)'
- en: 'This if-else statement checks whether the array mySiblings is empty ➊ . If
    it is, then "I don''t have any siblings." is printed. But if there is something
    in the array, then the number of siblings that we have is printed: "I have 3 siblings."
    ➋ .'
  id: totrans-7967
  prefs: []
  type: TYPE_NORMAL
  zh: 这个 if-else 语句检查数组 mySiblings 是否为空 ➊。如果为空，则打印 "我没有兄弟姐妹"。但如果数组中有内容，则会打印我们有多少个兄弟姐妹："我有
    3 个兄弟姐妹" ➋。
- en: '**LOOPING OVER AN ARRAY**'
  id: totrans-7968
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**遍历数组**'
- en: 'Sometimes when you’re working with arrays you might want to do something to
    every item in the array. You can use a for-in loop to do that! The following code
    will print every topping in a pizzaToppings array on a separate line:'
  id: totrans-7969
  prefs: []
  type: TYPE_NORMAL
  zh: 有时在处理数组时，你可能想对数组中的每个项目执行某些操作。你可以使用for-in循环来做到这一点！以下代码将把pizzaToppings数组中的每个配料逐行打印出来：
- en: '![Image](Image00135.jpg)'
  id: totrans-7970
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00135.jpg)'
- en: To write a for-in loop for the pizzaToppings array, we used the keyword for
    , followed by the constant topping , then the keyword in , and finally the name
    of our array, pizzaToppings . Then we put the statements that we want to run for
    each topping inside the braces of the for-in loop. The constant topping ➊ temporarily
    represents each pizza topping in the array as we loop through it. We could have
    chosen any name for this constant, but it’s a good idea to pick something that
    makes sense. You can see the output of this for-in loop in [Figure 6-4](text00016.html#ch06fig4)
    .
  id: totrans-7971
  prefs: []
  type: TYPE_NORMAL
  zh: 要为pizzaToppings数组编写一个for-in循环，我们使用了关键字for，后跟常量topping，然后是关键字in，最后是我们数组的名称pizzaToppings。接着，我们将希望对每个topping执行的语句放在for-in循环的花括号内。常量topping
    ➊在我们遍历数组时临时代表数组中的每个披萨配料。我们本可以为这个常量选择任何名字，但最好选择一个有意义的名称。你可以在[图6-4](text00016.html#ch06fig4)中查看这个for-in循环的输出。
- en: '![Image](Image00136.jpg)'
  id: totrans-7972
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00136.jpg)'
- en: '*Figure 6-4: Output of the example for-in loop*'
  id: totrans-7973
  prefs: []
  type: TYPE_NORMAL
  zh: '*图6-4：示例for-in循环的输出*'
- en: '![Image](Image00137.jpg)'
  id: totrans-7974
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00137.jpg)'
- en: 'Using for-in loops is great for printing every value in an array. If you’re
    working with numbers, you can even use them to perform math operations on each
    item, which makes for some speedy calculations! The following code takes an array
    of numbers and calculates the square for each (the square of a number is that
    number multiplied by itself):'
  id: totrans-7975
  prefs: []
  type: TYPE_NORMAL
  zh: 使用for-in循环非常适合打印数组中的每个值。如果你处理的是数字，甚至可以用它们对每个项目进行数学运算，这样就能快速进行计算！以下代码获取一个数字数组，并计算每个数字的平方（一个数字的平方就是它自己与自身相乘）：
- en: '![Image](Image00138.jpg)'
  id: totrans-7976
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00138.jpg)'
- en: '[Figure 6-5](text00016.html#ch06fig5) shows the results.'
  id: totrans-7977
  prefs: []
  type: TYPE_NORMAL
  zh: '[图6-5](text00016.html#ch06fig5)显示了结果。'
- en: '![Image](Image00139.jpg)'
  id: totrans-7978
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00139.jpg)'
- en: '*Figure 6-5: Printing the squares for each number in the myNumbers array*'
  id: totrans-7979
  prefs: []
  type: TYPE_NORMAL
  zh: '*图6-5：打印myNumbers数组中每个数字的平方*'
- en: '**DICTIONARIES ARE KEY!**'
  id: totrans-7980
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**字典是关键！**'
- en: A *dictionary* is also a collection of values, but instead of an ordered index,
    each value has its own *key* . Because there’s no index, the values are not stored
    in any particular order. To access values in a dictionary, you look them up by
    their key.
  id: totrans-7981
  prefs: []
  type: TYPE_NORMAL
  zh: '*字典*也是一个值的集合，但不同于有序索引，每个值都有自己的*键*。因为没有索引，值并没有按照特定顺序存储。要访问字典中的值，您需要通过其键查找它们。'
- en: A key must be unique. You can’t have the same key more than once in the same
    dictionary. If there were two identical keys and you asked the computer to give
    you the value for one of them, the computer wouldn’t know which one to choose!
  id: totrans-7982
  prefs: []
  type: TYPE_NORMAL
  zh: 一个键必须是唯一的。在同一个字典中，不能有相同的键。如果有两个相同的键，而你要求计算机给出其中一个的值，计算机就无法知道选择哪个！
- en: Let’s take a look at how to make a dictionary and write keys that will help
    you find all the information you need.
  id: totrans-7983
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看如何创建字典并编写键，以帮助你找到所需的所有信息。
- en: '![Image](Image00140.jpg)'
  id: totrans-7984
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00140.jpg)'
- en: '**INITIALIZING A DICTIONARY**'
  id: totrans-7985
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**初始化字典**'
- en: 'To create and initialize a dictionary, first write var and the name of your
    dictionary. Then write the keys and corresponding values inside a pair of square
    brackets, similar to an array. Let’s create a dictionary to store the names of
    a few US states. The key for each state will be its two-letter abbreviation:'
  id: totrans-7986
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建和初始化字典，首先编写var和字典的名称。然后，在一对方括号内写入键和值对，类似于数组。让我们创建一个字典，用来存储一些美国州的名称。每个州的键将是其两字母缩写：
- en: '![](Image00141.jpg)'
  id: totrans-7987
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00141.jpg)'
- en: As you can see, there’s a colon between each key and its value, and the key/value
    pairs are separated by commas.
  id: totrans-7988
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，每个键和值之间都有一个冒号，键/值对之间由逗号分隔。
- en: Dictionaries are different from arrays in that they are *unordered* . Because
    of that, it’s likely that the order of the states that you see in your results
    pane ➋ is different from the order in which you entered your states ➊ . It might
    even be different than the order that’s printed in this book!
  id: totrans-7989
  prefs: []
  type: TYPE_NORMAL
  zh: 字典不同于数组，因为它们是*无序的*。因此，结果面板中显示的状态顺序➋可能与您输入的状态顺序➊不同，甚至可能与本书中打印的顺序不同！
- en: As with arrays, you can use var to make a mutable dictionary or use let to make
    an immutable dictionary.
  id: totrans-7990
  prefs: []
  type: TYPE_NORMAL
  zh: 与数组一样，你可以使用 var 来创建一个可变字典，或使用 let 来创建一个不可变字典。
- en: 'In Swift, all of the keys of a dictionary must be the same type, and all of
    the values of a dictionary must also be the same type, but the key type doesn’t
    have to match the value type. For example, if you wanted to store a collection
    of fractions, you could use doubles for the keys and strings for the values:'
  id: totrans-7991
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Swift 中，字典的所有键必须是相同类型的，字典的所有值也必须是相同类型的，但键的类型不必与值的类型相匹配。例如，如果你想存储一个分数的集合，可以将键使用双精度数（doubles），而值使用字符串（strings）：
- en: '![](Image00142.jpg)'
  id: totrans-7992
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00142.jpg)'
- en: In this dictionary, all of the keys must be doubles, and all of the values must
    be strings. Again, you’ll see that the order of the numbers in the results pane
    can be quite different from the order in which you wrote the fractions in your
    dictionary. This is fine because you don’t need to know the order to access anything.
    You can find any item that you need by its key. Let’s see how!
  id: totrans-7993
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个字典中，所有的键必须是双精度数（doubles），而所有的值必须是字符串（strings）。再次提醒你，结果面板中的数字顺序可能与在字典中编写分数的顺序大不相同。这是可以接受的，因为你不需要知道顺序就能访问任何内容。你可以通过键找到任何需要的项。让我们看看怎么做！
- en: '**ACCESSING VALUES IN A DICTIONARY**'
  id: totrans-7994
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**访问字典中的值**'
- en: 'Looking up a value in a dictionary is similar to how you access a value in
    an array except that you use a key inside the square brackets instead of an index,
    like this: usStates["TX"] .'
  id: totrans-7995
  prefs: []
  type: TYPE_NORMAL
  zh: 查找字典中的值与访问数组中的值类似，区别在于你使用的是方括号内的键，而不是索引，例如：usStates["TX"]。
- en: There is a big difference, however, in how Swift returns the values from a dictionary.
    When you access a value at an index of an array, you are simply given the value.
    When you access a value with a key in a dictionary, you are given an optional.
  id: totrans-7996
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在 Swift 中从字典中返回值的方式有一个很大的区别。当你访问数组中某个索引的值时，你只会得到那个值。当你使用键从字典中访问一个值时，你会得到一个可选值。
- en: In [Chapter 5](text00015.html#ch05) , you learned that optionals might contain
    a value or might be nil . The reason Swift returns optionals when you’re looking
    up items in a dictionary is that the key you used might not exist in the dictionary,
    in which case there’s no value to access. Trying to access a value that doesn’t
    exist would give you a big fat error! To avoid that problem, Swift returns optionals.
    That means you need to unwrap any value you get out of a dictionary before you
    can do anything with it.
  id: totrans-7997
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第5章](text00015.html#ch05)中，你学到过可选值可能包含一个值，也可能是 nil。Swift 在查找字典项时返回可选值的原因是你使用的键可能不存在于字典中，在这种情况下是没有值可以访问的。尝试访问一个不存在的值会给你一个严重的错误！为了避免这个问题，Swift
    返回了可选值。这意味着在你对从字典中获取的任何值进行操作之前，需要先解包它。
- en: 'To unwrap an optional, first you check whether it exists using an if-let statement,
    just like we did in [Chapter 5](text00015.html#ch05) . The following code shows
    you how to get a value out of a dictionary:'
  id: totrans-7998
  prefs: []
  type: TYPE_NORMAL
  zh: 要解包一个可选值，首先你需要使用 if-let 语句检查它是否存在，就像我们在[第5章](text00015.html#ch05)中做的那样。以下代码展示了如何从字典中获取一个值：
- en: '![Image](Image00143.jpg)'
  id: totrans-7999
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00143.jpg)'
- en: To retrieve "Texas" from the dictionary, we use if let to set a constant loneStarState
    to usStates["TX"] ➊ . Because we have this state in our dictionary, the line I
    have Texas in my dictionary. is printed. Next we try to access a state that is
    not in our dictionary by using the key usStates["FL"] ➋ . Thankfully, because
    we used an if-let statement, the program won’t crash when the computer can’t find
    this state. Instead, I don't have that state in my dictionary. is printed.
  id: totrans-8000
  prefs: []
  type: TYPE_NORMAL
  zh: 为了从字典中检索“Texas”，我们使用 if let 将常量 loneStarState 设置为 usStates["TX"] ➊。由于字典中包含这个州，行文本“我有
    Texas 在我的字典中。”会被打印出来。接下来，我们尝试通过使用键 usStates["FL"] ➋ 访问一个不存在于字典中的州。幸运的是，由于我们使用了
    if-let 语句，当计算机无法找到该州时，程序不会崩溃。相反，“我没有那个州在我的字典中。”会被打印出来。
- en: '**ADDING ITEMS TO A DICTIONARY**'
  id: totrans-8001
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**向字典添加项**'
- en: 'To add an item to a dictionary, first write the name of your dictionary and
    assign the new item to the key you want it to have in the dictionary. Let’s add
    "Minnesota" to our usStates dictionary:'
  id: totrans-8002
  prefs: []
  type: TYPE_NORMAL
  zh: 要向字典中添加一项，首先写下字典的名称，并将新项分配给你希望它在字典中对应的键。让我们将 "Minnesota" 添加到我们的 usStates 字典中：
- en: '![](Image00144.jpg)'
  id: totrans-8003
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00144.jpg)'
- en: 'Now when you look at usStates , you’ll see that it’s updated to ["MN": "Minnesota",
    "WA": "Washington", "MA": "Massachusetts", "TX": "Texas"] . Remember, because
    you don’t have to rely on indices, your new dictionary item might appear anywhere
    in the dictionary.'
  id: totrans-8004
  prefs: []
  type: TYPE_NORMAL
  zh: '现在，当你查看 usStates 时，你会看到它已更新为 ["MN": "Minnesota", "WA": "Washington", "MA":
    "Massachusetts", "TX": "Texas"]。记住，由于你不需要依赖索引，新的字典项可能会出现在字典中的任何位置。'
- en: '**REMOVING ITEMS FROM A DICTIONARY**'
  id: totrans-8005
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**从字典中移除项目**'
- en: Removing an item from a dictionary is quite simple; you do so by setting the
    value to nil . Because the values in dictionaries are returned as optionals, you
    don’t have to worry about nil causing any problems in your dictionary.
  id: totrans-8006
  prefs: []
  type: TYPE_NORMAL
  zh: 从字典中移除一个项目非常简单；你只需将值设置为 nil。由于字典中的值是作为可选项返回的，因此你无需担心 nil 会在字典中引发问题。
- en: '![](Image00145.jpg)'
  id: totrans-8007
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00145.jpg)'
- en: 'You can see that after you remove the value at the key "MA" , usStates is updated
    to ["MN": "Minnesota", "WA": "Washington", "TX": "Texas"] . Remember that nil
    is special and means that there’s no value at all. That’s why you don’t see "MA":
    nil in our dictionary.'
  id: totrans-8008
  prefs: []
  type: TYPE_NORMAL
  zh: '你可以看到，在移除键 "MA" 的值后，usStates 更新为 ["MN": "Minnesota", "WA": "Washington", "TX":
    "Texas"]。记住，nil 是特殊的，表示根本没有值。因此，你不会在我们的字典中看到 "MA": nil。'
- en: '**REPLACING ITEMS IN A DICTIONARY**'
  id: totrans-8009
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**替换字典中的项目**'
- en: 'Replacing an item in a dictionary is also easy. It works the same was as replacing
    an item in an array. You just set the item that you want to replace to something
    else. Say you create a dictionary of fruit colors:'
  id: totrans-8010
  prefs: []
  type: TYPE_NORMAL
  zh: 在字典中替换项目也很简单。它与替换数组中的项目一样。你只需将要替换的项目设置为其他值。假设你创建了一个关于水果颜色的字典：
- en: '![](Image00146.jpg)'
  id: totrans-8011
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00146.jpg)'
- en: At first we had the value "apple" for "red" , but then we decided that "raspberry"
    is a better fruit to use since sometimes apples are green or yellow. To replace
    "apple" with "raspberry" , we set colorFruits["red"] to its new value ➊ .
  id: totrans-8012
  prefs: []
  type: TYPE_NORMAL
  zh: 最初，我们为 "red" 设置了值 "apple"，但后来我们决定使用 "raspberry" 作为更好的水果，因为有时苹果是绿色或黄色的。为了将 "apple"
    替换为 "raspberry"，我们将 colorFruits["red"] 设置为它的新值 ➊。
- en: You may remember that this is the same way we entered a new value into a dictionary.
    If the key already exists in the dictionary, then the value for that key is replaced.
    If the key doesn’t already exist, then the new key/value pair will be added to
    the dictionary.
  id: totrans-8013
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能还记得，这是我们将新值输入字典的方式。如果键已经存在于字典中，那么该键的值将被替换。如果键不存在，新的键/值对将被添加到字典中。
- en: '![Image](Image00147.jpg)'
  id: totrans-8014
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00147.jpg)'
- en: '**USING DICTIONARY PROPERTIES**'
  id: totrans-8015
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**使用字典属性**'
- en: 'Like an array, a dictionary also has an isEmpty property and a count property.
    For example, the following code shows how you can use the isEmpty property to
    check if a dictionary is empty, and if it isn’t empty, the count property checks
    how many items you have. Imagine you have a basket of fruit for sale. You can
    use these properties to help you keep track of everything:'
  id: totrans-8016
  prefs: []
  type: TYPE_NORMAL
  zh: 像数组一样，字典也有 isEmpty 属性和 count 属性。例如，下面的代码展示了如何使用 isEmpty 属性检查字典是否为空，如果不为空，则使用
    count 属性检查你拥有多少项。想象一下，你有一个待售的水果篮。你可以使用这些属性来帮助你跟踪所有内容：
- en: '![Image](Image00148.jpg)'
  id: totrans-8017
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00148.jpg)'
- en: 'A dictionary also has two special properties: keys , which contains all of
    the dictionary’s keys, and values , which contains all of its values. We’ll use
    these two properties when we loop through the dictionary.'
  id: totrans-8018
  prefs: []
  type: TYPE_NORMAL
  zh: 字典还有两个特殊属性：keys，包含字典的所有键；以及 values，包含字典的所有值。在遍历字典时，我们将使用这两个属性。
- en: Let’s write some code that loops through our fruit baskets and prints the price
    of each fruit.
  id: totrans-8019
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们写一些代码，遍历我们的水果篮并打印每个水果的价格。
- en: '**LOOPING OVER A DICTIONARY**'
  id: totrans-8020
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**遍历字典**'
- en: 'You can loop through a dictionary using a for-in loop. Because each item has
    a key and a value, you can do this in two different ways. This is how to loop
    through a dictionary using its keys:'
  id: totrans-8021
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用 for-in 循环遍历字典。由于每个项目都有一个键和值，因此你可以用两种不同的方式进行遍历。以下是使用键遍历字典的方法：
- en: '![Image](Image00149.jpg)'
  id: totrans-8022
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00149.jpg)'
- en: Here we use the dictionary’s keys property ➊ to loop through fruitBasket and
    print its contents. We start by writing the keyword for , followed by a constant
    name fruit for the dictionary key, the keyword in , the dictionary name, a period,
    and keys .
  id: totrans-8023
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们使用字典的 keys 属性 ➊ 遍历 fruitBasket 并打印其内容。我们首先写下关键字 for，然后是常量名 fruit 作为字典键，接着是关键字
    in、字典名、一个句点和 keys。
- en: Inside the braces of our for-in loop, we have access to both the key, which
    we call fruit ➋ , and the value at that key when we force-unwrap its contents
    with fruitBasket[fruit]! ➌ . That value will be the fruit’s price.
  id: totrans-8024
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `for-in` 循环的大括号内，我们可以访问键（我们称之为 `fruit` ➋）以及我们通过强制解包其内容 `fruitBasket[fruit]!`
    ➌ 获得的该键的值。该值将是水果的价格。
- en: In this case, it’s safe to force-unwrap the value using an exclamation point
    because we know that the fruit key we’re using is definitely inside the dictionary.
  id: totrans-8025
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，使用感叹号强制解包值是安全的，因为我们知道正在使用的 `fruit` 键肯定在字典中。
- en: Any code we put inside the for-in loop will run once for every key in our dictionary.
    So you should see the print statement display three times.
  id: totrans-8026
  prefs: []
  type: TYPE_NORMAL
  zh: 我们放在 `for-in` 循环中的任何代码都会针对字典中的每个键执行一次。所以你应该看到 `print` 语句打印三次。
- en: 'We can also loop through the dictionary using its values property:'
  id: totrans-8027
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以通过字典的`values`属性来循环遍历：
- en: '![Image](Image00150.jpg)'
  id: totrans-8028
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00150.jpg)'
- en: We use the same style of for-in loop, but now we use a constant to refer to
    each value, which we call price , in the values property. When looping through
    values, we don’t have access to the keys from inside the loop.
  id: totrans-8029
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用相同的 `for-in` 循环样式，但现在我们使用一个常量来引用 `values` 属性中的每个值，我们称之为 `price`。在循环 `values`
    时，我们无法从循环内部访问键。
- en: Another difference to note is that price is not an optional because it’s accessed
    directly as a value in the fruitBasket dictionary. That means we don’t have to
    unwrap it. You should still see the print statement printed three times. [Figure
    6-6](text00016.html#ch06fig6) shows the output of both loops.
  id: totrans-8030
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个需要注意的区别是，`price` 不是可选项，因为它直接作为值在 `fruitBasket` 字典中访问。这意味着我们不需要解包它。你仍然应该看到
    `print` 语句被打印三次。[图 6-6](text00016.html#ch06fig6) 显示了两个循环的输出。
- en: '![Image](Image00151.jpg)'
  id: totrans-8031
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00151.jpg)'
- en: '*Figure 6-6: Looping through the keys and values of a dictionary with a for-in
    loop*'
  id: totrans-8032
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 6-6：通过 `for-in` 循环遍历字典的键和值*'
- en: The order of your results might be slightly different from ours. That’s because
    the items in a dictionary aren’t in a numbered order like they are in an array!
    And because the order is not guaranteed, you might see a different order printed
    if you run the same code again.
  id: totrans-8033
  prefs: []
  type: TYPE_NORMAL
  zh: 你的结果顺序可能与你的不同。那是因为字典中的项目不像数组中的项目那样有编号顺序！由于顺序无法保证，如果你再次运行相同的代码，可能会看到不同的顺序。
- en: '**WHAT YOU LEARNED**'
  id: totrans-8034
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**你学到了什么**'
- en: In this chapter, you learned how to store collections of items in an array and
    in a dictionary. To store items in an ordered list, you would use an array and
    look up each item by its index. If you wanted to store items by key instead, you
    would use a dictionary.
  id: totrans-8035
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一章中，你学会了如何将一组项目存储在数组和字典中。要将项目存储在有序列表中，你将使用数组并通过索引查找每个项目。如果你想按键存储项目，你将使用字典。
- en: Knowing about arrays and dictionaries and how to use them is a powerful building
    block for almost any programming language. Next we will learn about functions,
    another very powerful tool. Functions are blocks of code that you create and name
    to perform a specific job. After you have written a function, you can use its
    name to call it from almost anywhere in your program.
  id: totrans-8036
  prefs: []
  type: TYPE_NORMAL
  zh: 了解数组和字典以及如何使用它们是几乎任何编程语言中的一个强大构建块。接下来我们将学习函数，另一个非常强大的工具。函数是你创建并命名的代码块，用于执行特定的任务。在你编写了一个函数之后，你可以在程序的几乎任何地方通过它的名称来调用它。
- en: '*Figure 6-3: Don’t try to replace a value at an index beyond the existing array.*'
  id: totrans-8037
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 6-3：不要尝试替换超出现有数组索引的值。*'
- en: Now you know how to change arrays however you might need to. You can add items,
    take items away, or replace items. Next, we’ll look at how to use the properties
    of arrays to find out even more information about them.
  id: totrans-8038
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经知道如何根据需要更改数组。你可以添加项目、移除项目或替换项目。接下来，我们将了解如何使用数组的属性来获取更多关于它们的信息。
- en: '![Image](Image00133.jpg)'
  id: totrans-8039
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00133.jpg)'
- en: '**USING ARRAY PROPERTIES**'
  id: totrans-8040
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**使用数组属性**'
- en: In addition to methods like append(_:) and removeLast() , arrays also have *properties*
    . An array’s properties are variables or constants that contain some information
    about the array. Two really helpful properties that you might use are the Boolean
    property isEmpty and the integer property count .
  id: totrans-8041
  prefs: []
  type: TYPE_NORMAL
  zh: 除了像 `append(_:)` 和 `removeLast()` 这样的方式，数组还有*属性*。数组的属性是包含一些关于数组信息的变量或常量。你可能会用到的两个非常有用的属性是布尔型属性
    `isEmpty` 和整数型属性 `count`。
- en: The isEmpty property is true or false depending on whether the array is empty,
    and the count property will tell you how many items are in that array.
  id: totrans-8042
  prefs: []
  type: TYPE_NORMAL
  zh: '`isEmpty` 属性根据数组是否为空来返回 `true` 或 `false`，而 `count` 属性将告诉你数组中有多少个项目。'
- en: 'Check out how these two properties are used in the following if-else statement:'
  id: totrans-8043
  prefs: []
  type: TYPE_NORMAL
  zh: 看看以下if-else语句中这两个属性是如何使用的：
- en: '![Image](Image00134.jpg)'
  id: totrans-8044
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00134.jpg)'
- en: 'This if-else statement checks whether the array mySiblings is empty ➊ . If
    it is, then "I don''t have any siblings." is printed. But if there is something
    in the array, then the number of siblings that we have is printed: "I have 3 siblings."
    ➋ .'
  id: totrans-8045
  prefs: []
  type: TYPE_NORMAL
  zh: 这个if-else语句检查数组mySiblings是否为空 ➊。如果为空，程序会打印出“我没有兄弟姐妹。”如果数组中有内容，则会打印出兄弟姐妹的数量：“我有3个兄弟姐妹。”
    ➋。
- en: '**LOOPING OVER AN ARRAY**'
  id: totrans-8046
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**遍历数组**'
- en: 'Sometimes when you’re working with arrays you might want to do something to
    every item in the array. You can use a for-in loop to do that! The following code
    will print every topping in a pizzaToppings array on a separate line:'
  id: totrans-8047
  prefs: []
  type: TYPE_NORMAL
  zh: 有时在处理数组时，你可能想对数组中的每个项执行某些操作。你可以使用for-in循环来实现！以下代码将打印出pizzaToppings数组中的每个配料，每个配料一行：
- en: '![Image](Image00135.jpg)'
  id: totrans-8048
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00135.jpg)'
- en: To write a for-in loop for the pizzaToppings array, we used the keyword for
    , followed by the constant topping , then the keyword in , and finally the name
    of our array, pizzaToppings . Then we put the statements that we want to run for
    each topping inside the braces of the for-in loop. The constant topping ➊ temporarily
    represents each pizza topping in the array as we loop through it. We could have
    chosen any name for this constant, but it’s a good idea to pick something that
    makes sense. You can see the output of this for-in loop in [Figure 6-4](text00016.html#ch06fig4)
    .
  id: totrans-8049
  prefs: []
  type: TYPE_NORMAL
  zh: 要为pizzaToppings数组编写for-in循环，我们使用了关键字for，接着是常量topping，然后是关键字in，最后是数组的名称pizzaToppings。然后，我们将希望对每个配料执行的语句放在for-in循环的花括号内。常量topping
    ➊在我们遍历数组时临时代表数组中的每个配料。我们可以为这个常量选择任何名字，但选择一个有意义的名字是个好主意。你可以在[图6-4](text00016.html#ch06fig4)中看到这个for-in循环的输出。
- en: '![Image](Image00136.jpg)'
  id: totrans-8050
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00136.jpg)'
- en: '*Figure 6-4: Output of the example for-in loop*'
  id: totrans-8051
  prefs: []
  type: TYPE_NORMAL
  zh: '*图6-4：示例for-in循环的输出*'
- en: '![Image](Image00137.jpg)'
  id: totrans-8052
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00137.jpg)'
- en: 'Using for-in loops is great for printing every value in an array. If you’re
    working with numbers, you can even use them to perform math operations on each
    item, which makes for some speedy calculations! The following code takes an array
    of numbers and calculates the square for each (the square of a number is that
    number multiplied by itself):'
  id: totrans-8053
  prefs: []
  type: TYPE_NORMAL
  zh: 使用for-in循环非常适合打印数组中的每个值。如果你处理的是数字，你甚至可以使用它们对每个项进行数学运算，从而快速完成计算！以下代码接收一个数字数组并计算每个数字的平方（数字的平方是该数字乘以它自己）：
- en: '![Image](Image00138.jpg)'
  id: totrans-8054
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00138.jpg)'
- en: '[Figure 6-5](text00016.html#ch06fig5) shows the results.'
  id: totrans-8055
  prefs: []
  type: TYPE_NORMAL
  zh: '[图6-5](text00016.html#ch06fig5)展示了结果。'
- en: '![Image](Image00139.jpg)'
  id: totrans-8056
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00139.jpg)'
- en: '*Figure 6-5: Printing the squares for each number in the myNumbers array*'
  id: totrans-8057
  prefs: []
  type: TYPE_NORMAL
  zh: '*图6-5：打印myNumbers数组中每个数字的平方*'
- en: '**DICTIONARIES ARE KEY!**'
  id: totrans-8058
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**字典是关键！**'
- en: A *dictionary* is also a collection of values, but instead of an ordered index,
    each value has its own *key* . Because there’s no index, the values are not stored
    in any particular order. To access values in a dictionary, you look them up by
    their key.
  id: totrans-8059
  prefs: []
  type: TYPE_NORMAL
  zh: '*字典*也是一种值的集合，但与有序索引不同，每个值都有其自己的*键*。由于没有索引，值的存储顺序没有特定的要求。要访问字典中的值，你需要通过它们的键来查找。'
- en: A key must be unique. You can’t have the same key more than once in the same
    dictionary. If there were two identical keys and you asked the computer to give
    you the value for one of them, the computer wouldn’t know which one to choose!
  id: totrans-8060
  prefs: []
  type: TYPE_NORMAL
  zh: 键必须是唯一的。你不能在同一个字典中使用相同的键。如果存在两个相同的键，而你要求计算机返回其中一个的值，计算机就无法知道选择哪一个！
- en: Let’s take a look at how to make a dictionary and write keys that will help
    you find all the information you need.
  id: totrans-8061
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看如何创建一个字典并编写键，以便你能找到所有需要的信息。
- en: '![Image](Image00140.jpg)'
  id: totrans-8062
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00140.jpg)'
- en: '**INITIALIZING A DICTIONARY**'
  id: totrans-8063
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**初始化字典**'
- en: 'To create and initialize a dictionary, first write var and the name of your
    dictionary. Then write the keys and corresponding values inside a pair of square
    brackets, similar to an array. Let’s create a dictionary to store the names of
    a few US states. The key for each state will be its two-letter abbreviation:'
  id: totrans-8064
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建并初始化一个字典，首先写var和字典的名称。然后在一对方括号内写入键和值，格式类似于数组。让我们创建一个字典来存储一些美国州的名称。每个州的键将是它的两字母缩写：
- en: '![](Image00141.jpg)'
  id: totrans-8065
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00141.jpg)'
- en: As you can see, there’s a colon between each key and its value, and the key/value
    pairs are separated by commas.
  id: totrans-8066
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，每个键和它的值之间有一个冒号，键/值对之间用逗号分隔。
- en: Dictionaries are different from arrays in that they are *unordered* . Because
    of that, it’s likely that the order of the states that you see in your results
    pane ➋ is different from the order in which you entered your states ➊ . It might
    even be different than the order that’s printed in this book!
  id: totrans-8067
  prefs: []
  type: TYPE_NORMAL
  zh: 字典与数组不同，字典是*无序*的。因此，你在结果窗格中看到的州的顺序 ➋ 很可能与输入州的顺序 ➊ 不同。甚至可能与本书中打印的顺序不同！
- en: As with arrays, you can use var to make a mutable dictionary or use let to make
    an immutable dictionary.
  id: totrans-8068
  prefs: []
  type: TYPE_NORMAL
  zh: 和数组一样，你可以使用 var 创建一个可变字典，或者使用 let 创建一个不可变字典。
- en: 'In Swift, all of the keys of a dictionary must be the same type, and all of
    the values of a dictionary must also be the same type, but the key type doesn’t
    have to match the value type. For example, if you wanted to store a collection
    of fractions, you could use doubles for the keys and strings for the values:'
  id: totrans-8069
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Swift 中，字典的所有键必须是相同类型，字典的所有值也必须是相同类型，但键的类型不必与值的类型相匹配。例如，如果你想存储一组分数，你可以使用 double
    类型作为键，使用 string 类型作为值：
- en: '![](Image00142.jpg)'
  id: totrans-8070
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00142.jpg)'
- en: In this dictionary, all of the keys must be doubles, and all of the values must
    be strings. Again, you’ll see that the order of the numbers in the results pane
    can be quite different from the order in which you wrote the fractions in your
    dictionary. This is fine because you don’t need to know the order to access anything.
    You can find any item that you need by its key. Let’s see how!
  id: totrans-8071
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个字典中，所有的键必须是 double 类型，所有的值必须是 string 类型。同样，你会看到，结果窗格中的数字顺序可能与字典中分数的输入顺序有很大的不同。这是可以接受的，因为你不需要知道顺序就能访问任何项。你可以通过键找到你需要的任何项。让我们来看看！
- en: '**ACCESSING VALUES IN A DICTIONARY**'
  id: totrans-8072
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**访问字典中的值**'
- en: 'Looking up a value in a dictionary is similar to how you access a value in
    an array except that you use a key inside the square brackets instead of an index,
    like this: usStates["TX"] .'
  id: totrans-8073
  prefs: []
  type: TYPE_NORMAL
  zh: 在字典中查找值类似于在数组中访问值，只是你在方括号中使用键而不是索引，如：usStates["TX"]。
- en: There is a big difference, however, in how Swift returns the values from a dictionary.
    When you access a value at an index of an array, you are simply given the value.
    When you access a value with a key in a dictionary, you are given an optional.
  id: totrans-8074
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，Swift 在从字典返回值时有一个很大的区别。当你在数组中访问某个索引的值时，你会直接获得该值。而当你在字典中使用键访问某个值时，你得到的是一个可选值（optional）。
- en: In [Chapter 5](text00015.html#ch05) , you learned that optionals might contain
    a value or might be nil . The reason Swift returns optionals when you’re looking
    up items in a dictionary is that the key you used might not exist in the dictionary,
    in which case there’s no value to access. Trying to access a value that doesn’t
    exist would give you a big fat error! To avoid that problem, Swift returns optionals.
    That means you need to unwrap any value you get out of a dictionary before you
    can do anything with it.
  id: totrans-8075
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第 5 章](text00015.html#ch05)中，你学到可选值可能包含一个值，也可能是 nil。Swift 在字典查找项时返回可选值的原因是，你使用的键可能在字典中不存在，在这种情况下就没有值可供访问。尝试访问不存在的值会导致一个错误！为了避免这个问题，Swift
    返回可选值。这意味着在对字典中的值进行任何操作之前，你需要解包它。
- en: 'To unwrap an optional, first you check whether it exists using an if-let statement,
    just like we did in [Chapter 5](text00015.html#ch05) . The following code shows
    you how to get a value out of a dictionary:'
  id: totrans-8076
  prefs: []
  type: TYPE_NORMAL
  zh: 要解包一个可选值，首先你需要使用 if-let 语句检查它是否存在，就像我们在[第 5 章](text00015.html#ch05)中做的那样。以下代码展示了如何从字典中获取一个值：
- en: '![Image](Image00143.jpg)'
  id: totrans-8077
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00143.jpg)'
- en: To retrieve "Texas" from the dictionary, we use if let to set a constant loneStarState
    to usStates["TX"] ➊ . Because we have this state in our dictionary, the line I
    have Texas in my dictionary. is printed. Next we try to access a state that is
    not in our dictionary by using the key usStates["FL"] ➋ . Thankfully, because
    we used an if-let statement, the program won’t crash when the computer can’t find
    this state. Instead, I don't have that state in my dictionary. is printed.
  id: totrans-8078
  prefs: []
  type: TYPE_NORMAL
  zh: 要从字典中检索“Texas”，我们使用 if let 将常量 loneStarState 设置为 usStates["TX"] ➊。由于字典中有该州，因此打印了
    "I have Texas in my dictionary."。接下来，我们尝试通过使用 usStates["FL"] ➋ 来访问一个不在字典中的州。幸运的是，由于我们使用了
    if-let 语句，当计算机找不到该州时，程序不会崩溃。相反，打印出 "I don't have that state in my dictionary."。
- en: '**ADDING ITEMS TO A DICTIONARY**'
  id: totrans-8079
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**向字典添加项**'
- en: 'To add an item to a dictionary, first write the name of your dictionary and
    assign the new item to the key you want it to have in the dictionary. Let’s add
    "Minnesota" to our usStates dictionary:'
  id: totrans-8080
  prefs: []
  type: TYPE_NORMAL
  zh: 要向字典中添加项，首先写下字典的名称，并将新项赋值给你希望它在字典中拥有的键。让我们向我们的 usStates 字典中添加 "Minnesota"：
- en: '![](Image00144.jpg)'
  id: totrans-8081
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00144.jpg)'
- en: 'Now when you look at usStates , you’ll see that it’s updated to ["MN": "Minnesota",
    "WA": "Washington", "MA": "Massachusetts", "TX": "Texas"] . Remember, because
    you don’t have to rely on indices, your new dictionary item might appear anywhere
    in the dictionary.'
  id: totrans-8082
  prefs: []
  type: TYPE_NORMAL
  zh: '现在，当你查看 usStates 时，你会看到它已经更新为 ["MN": "Minnesota", "WA": "Washington", "MA":
    "Massachusetts", "TX": "Texas"]。记住，由于你不需要依赖索引，新的字典项可能会出现在字典的任何位置。'
- en: '**REMOVING ITEMS FROM A DICTIONARY**'
  id: totrans-8083
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**从字典中移除项**'
- en: Removing an item from a dictionary is quite simple; you do so by setting the
    value to nil . Because the values in dictionaries are returned as optionals, you
    don’t have to worry about nil causing any problems in your dictionary.
  id: totrans-8084
  prefs: []
  type: TYPE_NORMAL
  zh: 从字典中移除项非常简单；你只需将值设置为 nil。因为字典中的值是作为可选值返回的，所以你不必担心 nil 会在字典中引起任何问题。
- en: '![](Image00145.jpg)'
  id: totrans-8085
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00145.jpg)'
- en: 'You can see that after you remove the value at the key "MA" , usStates is updated
    to ["MN": "Minnesota", "WA": "Washington", "TX": "Texas"] . Remember that nil
    is special and means that there’s no value at all. That’s why you don’t see "MA":
    nil in our dictionary.'
  id: totrans-8086
  prefs: []
  type: TYPE_NORMAL
  zh: '你可以看到，在你移除 "MA" 键对应的值后，usStates 更新为 ["MN": "Minnesota", "WA": "Washington",
    "TX": "Texas"]。记住，nil 是特殊的，表示完全没有值。这就是为什么你在字典中看不到 "MA": nil 的原因。'
- en: '**REPLACING ITEMS IN A DICTIONARY**'
  id: totrans-8087
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**替换字典中的项**'
- en: 'Replacing an item in a dictionary is also easy. It works the same was as replacing
    an item in an array. You just set the item that you want to replace to something
    else. Say you create a dictionary of fruit colors:'
  id: totrans-8088
  prefs: []
  type: TYPE_NORMAL
  zh: 替换字典中的项也很简单。它与替换数组中的项方式相同。你只需要将你想替换的项设置为其他值。例如，你可以创建一个水果颜色的字典：
- en: '![](Image00146.jpg)'
  id: totrans-8089
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00146.jpg)'
- en: At first we had the value "apple" for "red" , but then we decided that "raspberry"
    is a better fruit to use since sometimes apples are green or yellow. To replace
    "apple" with "raspberry" , we set colorFruits["red"] to its new value ➊ .
  id: totrans-8090
  prefs: []
  type: TYPE_NORMAL
  zh: 最初我们给 "red" 设置了值 "apple"，但后来我们决定 "raspberry" 更适合作为水果，因为有时苹果是绿色或黄色的。为了将 "apple"
    替换为 "raspberry"，我们将 colorFruits["red"] 设置为它的新值 ➊。
- en: You may remember that this is the same way we entered a new value into a dictionary.
    If the key already exists in the dictionary, then the value for that key is replaced.
    If the key doesn’t already exist, then the new key/value pair will be added to
    the dictionary.
  id: totrans-8091
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能还记得，这与我们向字典中添加新值的方式相同。如果键已经存在于字典中，那么该键的值将被替换。如果键不存在，新的键/值对将被添加到字典中。
- en: '![Image](Image00147.jpg)'
  id: totrans-8092
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00147.jpg)'
- en: '**USING DICTIONARY PROPERTIES**'
  id: totrans-8093
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**使用字典属性**'
- en: 'Like an array, a dictionary also has an isEmpty property and a count property.
    For example, the following code shows how you can use the isEmpty property to
    check if a dictionary is empty, and if it isn’t empty, the count property checks
    how many items you have. Imagine you have a basket of fruit for sale. You can
    use these properties to help you keep track of everything:'
  id: totrans-8094
  prefs: []
  type: TYPE_NORMAL
  zh: 像数组一样，字典也有一个 isEmpty 属性和一个 count 属性。例如，以下代码演示了如何使用 isEmpty 属性检查字典是否为空，如果不为空，count
    属性则检查字典中有多少项。假设你有一个待售的水果篮，你可以使用这些属性帮助你跟踪所有的内容：
- en: '![Image](Image00148.jpg)'
  id: totrans-8095
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00148.jpg)'
- en: 'A dictionary also has two special properties: keys , which contains all of
    the dictionary’s keys, and values , which contains all of its values. We’ll use
    these two properties when we loop through the dictionary.'
  id: totrans-8096
  prefs: []
  type: TYPE_NORMAL
  zh: 字典还有两个特殊的属性：keys，包含字典中的所有键，values，包含字典中的所有值。我们将在遍历字典时使用这两个属性。
- en: Let’s write some code that loops through our fruit baskets and prints the price
    of each fruit.
  id: totrans-8097
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们写一些代码，遍历我们的水果篮并打印每个水果的价格。
- en: '**LOOPING OVER A DICTIONARY**'
  id: totrans-8098
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**遍历字典**'
- en: 'You can loop through a dictionary using a for-in loop. Because each item has
    a key and a value, you can do this in two different ways. This is how to loop
    through a dictionary using its keys:'
  id: totrans-8099
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用 for-in 循环遍历字典。因为每个项都有一个键和值，所以你可以用两种不同的方式来遍历字典。以下是如何使用键遍历字典：
- en: '![Image](Image00149.jpg)'
  id: totrans-8100
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00149.jpg)'
- en: Here we use the dictionary’s keys property ➊ to loop through fruitBasket and
    print its contents. We start by writing the keyword for , followed by a constant
    name fruit for the dictionary key, the keyword in , the dictionary name, a period,
    and keys .
  id: totrans-8101
  prefs: []
  type: TYPE_NORMAL
  zh: 这里我们使用字典的 `keys` 属性 ➊ 来循环遍历 `fruitBasket` 并打印它的内容。我们首先写 `for` 关键字，然后是字典键的常量名
    `fruit`，接着是 `in` 关键字，字典名，句点，最后是 `keys`。
- en: Inside the braces of our for-in loop, we have access to both the key, which
    we call fruit ➋ , and the value at that key when we force-unwrap its contents
    with fruitBasket[fruit]! ➌ . That value will be the fruit’s price.
  id: totrans-8102
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `for-in` 循环的花括号内，我们可以访问键（我们称之为 `fruit` ➋）以及通过 `fruitBasket[fruit]!` 强制解包其内容时的值
    ➌。该值将是水果的价格。
- en: In this case, it’s safe to force-unwrap the value using an exclamation point
    because we know that the fruit key we’re using is definitely inside the dictionary.
  id: totrans-8103
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，使用感叹号强制解包值是安全的，因为我们知道正在使用的 `fruit` 键肯定存在于字典中。
- en: Any code we put inside the for-in loop will run once for every key in our dictionary.
    So you should see the print statement display three times.
  id: totrans-8104
  prefs: []
  type: TYPE_NORMAL
  zh: 我们放在 `for-in` 循环中的任何代码都会针对字典中的每个键执行一次。所以你应该看到打印语句被执行三次。
- en: 'We can also loop through the dictionary using its values property:'
  id: totrans-8105
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以通过字典的 `values` 属性来循环遍历字典：
- en: '![Image](Image00150.jpg)'
  id: totrans-8106
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00150.jpg)'
- en: We use the same style of for-in loop, but now we use a constant to refer to
    each value, which we call price , in the values property. When looping through
    values, we don’t have access to the keys from inside the loop.
  id: totrans-8107
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用相同类型的 `for-in` 循环，但现在我们使用常量来引用 `values` 属性中的每个值，我们称之为 `price`。在循环遍历 `values`
    时，我们无法从循环内部访问键。
- en: Another difference to note is that price is not an optional because it’s accessed
    directly as a value in the fruitBasket dictionary. That means we don’t have to
    unwrap it. You should still see the print statement printed three times. [Figure
    6-6](text00016.html#ch06fig6) shows the output of both loops.
  id: totrans-8108
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个需要注意的区别是，`price` 不是可选的，因为它作为值直接访问自 `fruitBasket` 字典。这意味着我们不需要解包它。你应该仍然看到打印语句被打印三次。[图
    6-6](text00016.html#ch06fig6) 显示了两种循环的输出。
- en: '![Image](Image00151.jpg)'
  id: totrans-8109
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00151.jpg)'
- en: '*Figure 6-6: Looping through the keys and values of a dictionary with a for-in
    loop*'
  id: totrans-8110
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 6-6：使用 `for-in` 循环遍历字典的键和值*'
- en: The order of your results might be slightly different from ours. That’s because
    the items in a dictionary aren’t in a numbered order like they are in an array!
    And because the order is not guaranteed, you might see a different order printed
    if you run the same code again.
  id: totrans-8111
  prefs: []
  type: TYPE_NORMAL
  zh: 你的结果顺序可能与我们的略有不同。这是因为字典中的项目不像数组那样按数字顺序排列！由于顺序无法保证，因此如果你重新运行相同的代码，可能会看到不同的顺序。
- en: '**WHAT YOU LEARNED**'
  id: totrans-8112
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**你学到了什么**'
- en: In this chapter, you learned how to store collections of items in an array and
    in a dictionary. To store items in an ordered list, you would use an array and
    look up each item by its index. If you wanted to store items by key instead, you
    would use a dictionary.
  id: totrans-8113
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你学习了如何在数组和字典中存储项目集合。要存储有序列表中的项目，你将使用数组并通过索引查找每个项目。如果你想根据键来存储项目，你则需要使用字典。
- en: Knowing about arrays and dictionaries and how to use them is a powerful building
    block for almost any programming language. Next we will learn about functions,
    another very powerful tool. Functions are blocks of code that you create and name
    to perform a specific job. After you have written a function, you can use its
    name to call it from almost anywhere in your program.
  id: totrans-8114
  prefs: []
  type: TYPE_NORMAL
  zh: 了解数组和字典及其使用方法是几乎所有编程语言中强大的构建模块。接下来，我们将学习函数，这是另一个非常强大的工具。函数是你创建并命名的代码块，用于执行特定任务。编写完函数后，你可以通过它的名字在程序的几乎任何地方调用它。
- en: Now you know how to change arrays however you might need to. You can add items,
    take items away, or replace items. Next, we’ll look at how to use the properties
    of arrays to find out even more information about them.
  id: totrans-8115
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你知道了如何根据需要修改数组。你可以添加项目、删除项目或替换项目。接下来，我们将学习如何使用数组的属性来获取更多关于它们的信息。
- en: '![Image](Image00133.jpg)'
  id: totrans-8116
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00133.jpg)'
- en: '**USING ARRAY PROPERTIES**'
  id: totrans-8117
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**使用数组属性**'
- en: In addition to methods like append(_:) and removeLast() , arrays also have *properties*
    . An array’s properties are variables or constants that contain some information
    about the array. Two really helpful properties that you might use are the Boolean
    property isEmpty and the integer property count .
  id: totrans-8118
  prefs: []
  type: TYPE_NORMAL
  zh: 除了像 append(_:) 和 removeLast() 这样的函数，数组还有 *属性*。数组的属性是包含有关数组的一些信息的变量或常量。你可能会用到的两个非常有用的属性是布尔属性
    isEmpty 和整数属性 count。
- en: The isEmpty property is true or false depending on whether the array is empty,
    and the count property will tell you how many items are in that array.
  id: totrans-8119
  prefs: []
  type: TYPE_NORMAL
  zh: isEmpty 属性的值为 true 或 false，取决于数组是否为空，而 count 属性则告诉你数组中有多少项。
- en: 'Check out how these two properties are used in the following if-else statement:'
  id: totrans-8120
  prefs: []
  type: TYPE_NORMAL
  zh: 看一下以下 if-else 语句中如何使用这两个属性：
- en: '![Image](Image00134.jpg)'
  id: totrans-8121
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Image00134.jpg)'
- en: 'This if-else statement checks whether the array mySiblings is empty ➊ . If
    it is, then "I don''t have any siblings." is printed. But if there is something
    in the array, then the number of siblings that we have is printed: "I have 3 siblings."
    ➋ .'
  id: totrans-8122
  prefs: []
  type: TYPE_NORMAL
  zh: 这个 if-else 语句检查数组 mySiblings 是否为空 ➊。如果是，它会打印出“我没有兄弟姐妹。”如果数组中有内容，它就会打印出我们有几个兄弟姐妹：“我有
    3 个兄弟姐妹。” ➋。
- en: '**LOOPING OVER AN ARRAY**'
  id: totrans-8123
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**遍历数组**'
- en: 'Sometimes when you’re working with arrays you might want to do something to
    every item in the array. You can use a for-in loop to do that! The following code
    will print every topping in a pizzaToppings array on a separate line:'
  id: totrans-8124
  prefs: []
  type: TYPE_NORMAL
  zh: 有时在使用数组时，你可能希望对数组中的每一项做一些操作。你可以使用 for-in 循环来实现！以下代码将在单独的行上打印 pizzaToppings 数组中的每个配料：
- en: '![Image](Image00135.jpg)'
  id: totrans-8125
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Image00135.jpg)'
- en: To write a for-in loop for the pizzaToppings array, we used the keyword for
    , followed by the constant topping , then the keyword in , and finally the name
    of our array, pizzaToppings . Then we put the statements that we want to run for
    each topping inside the braces of the for-in loop. The constant topping ➊ temporarily
    represents each pizza topping in the array as we loop through it. We could have
    chosen any name for this constant, but it’s a good idea to pick something that
    makes sense. You can see the output of this for-in loop in [Figure 6-4](text00016.html#ch06fig4)
    .
  id: totrans-8126
  prefs: []
  type: TYPE_NORMAL
  zh: 要为 pizzaToppings 数组编写一个 for-in 循环，我们使用了关键字 for，后跟常量 topping，然后是关键字 in，最后是我们数组的名称
    pizzaToppings。然后我们将希望对每个配料执行的语句放入 for-in 循环的大括号内。常量 topping ➊ 在我们循环遍历数组时暂时代表数组中的每个披萨配料。我们可以为这个常量选择任何名称，但最好选择一个有意义的名称。你可以在
    [图 6-4](text00016.html#ch06fig4) 中看到这个 for-in 循环的输出。
- en: '![Image](Image00136.jpg)'
  id: totrans-8127
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Image00136.jpg)'
- en: '*Figure 6-4: Output of the example for-in loop*'
  id: totrans-8128
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 6-4：示例 for-in 循环的输出*'
- en: '![Image](Image00137.jpg)'
  id: totrans-8129
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Image00137.jpg)'
- en: 'Using for-in loops is great for printing every value in an array. If you’re
    working with numbers, you can even use them to perform math operations on each
    item, which makes for some speedy calculations! The following code takes an array
    of numbers and calculates the square for each (the square of a number is that
    number multiplied by itself):'
  id: totrans-8130
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 for-in 循环非常适合打印数组中的每个值。如果你正在处理数字，甚至可以用它们对每一项进行数学运算，这样就能快速计算！以下代码将一个数字数组中的每个数进行平方计算（一个数字的平方是该数字乘以它本身）：
- en: '![Image](Image00138.jpg)'
  id: totrans-8131
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Image00138.jpg)'
- en: '[Figure 6-5](text00016.html#ch06fig5) shows the results.'
  id: totrans-8132
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 6-5](text00016.html#ch06fig5) 显示了结果。'
- en: '![Image](Image00139.jpg)'
  id: totrans-8133
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Image00139.jpg)'
- en: '*Figure 6-5: Printing the squares for each number in the myNumbers array*'
  id: totrans-8134
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 6-5：打印 myNumbers 数组中每个数字的平方*'
- en: '**DICTIONARIES ARE KEY!**'
  id: totrans-8135
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**字典很重要！**'
- en: A *dictionary* is also a collection of values, but instead of an ordered index,
    each value has its own *key* . Because there’s no index, the values are not stored
    in any particular order. To access values in a dictionary, you look them up by
    their key.
  id: totrans-8136
  prefs: []
  type: TYPE_NORMAL
  zh: '*字典*也是一种值的集合，但与有序索引不同，每个值都有自己的 *键*。由于没有索引，值不会按特定顺序存储。要访问字典中的值，你需要通过键查找它们。'
- en: A key must be unique. You can’t have the same key more than once in the same
    dictionary. If there were two identical keys and you asked the computer to give
    you the value for one of them, the computer wouldn’t know which one to choose!
  id: totrans-8137
  prefs: []
  type: TYPE_NORMAL
  zh: 键必须是唯一的。同一个字典中不能有相同的键。如果存在两个相同的键并且你要求计算机返回其中一个的值，计算机就不知道该选择哪个！
- en: Let’s take a look at how to make a dictionary and write keys that will help
    you find all the information you need.
  id: totrans-8138
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看如何创建一个字典并编写帮助你找到所有所需信息的键。
- en: '![Image](Image00140.jpg)'
  id: totrans-8139
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Image00140.jpg)'
- en: '**INITIALIZING A DICTIONARY**'
  id: totrans-8140
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**初始化字典**'
- en: 'To create and initialize a dictionary, first write var and the name of your
    dictionary. Then write the keys and corresponding values inside a pair of square
    brackets, similar to an array. Let’s create a dictionary to store the names of
    a few US states. The key for each state will be its two-letter abbreviation:'
  id: totrans-8141
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建并初始化一个字典，首先写 var 和字典的名称。然后，将键和对应的值写在一对方括号内，类似于数组。让我们创建一个字典来存储几个美国州的名称。每个州的键将是它的两字母缩写：
- en: '![](Image00141.jpg)'
  id: totrans-8142
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00141.jpg)'
- en: As you can see, there’s a colon between each key and its value, and the key/value
    pairs are separated by commas.
  id: totrans-8143
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，每个键和值之间有一个冒号，键/值对之间用逗号分隔。
- en: Dictionaries are different from arrays in that they are *unordered* . Because
    of that, it’s likely that the order of the states that you see in your results
    pane ➋ is different from the order in which you entered your states ➊ . It might
    even be different than the order that’s printed in this book!
  id: totrans-8144
  prefs: []
  type: TYPE_NORMAL
  zh: 字典与数组不同，它们是*无序的*。因此，你在结果窗格中看到的状态顺序 ➋ 可能与输入状态的顺序 ➊ 不同，甚至可能与本书中打印的顺序不同！这没关系，因为你不需要知道顺序来访问任何内容。你可以通过键找到所需的任何项。
- en: As with arrays, you can use var to make a mutable dictionary or use let to make
    an immutable dictionary.
  id: totrans-8145
  prefs: []
  type: TYPE_NORMAL
  zh: 与数组一样，你可以使用 var 来创建可变字典，或者使用 let 来创建不可变字典。
- en: 'In Swift, all of the keys of a dictionary must be the same type, and all of
    the values of a dictionary must also be the same type, but the key type doesn’t
    have to match the value type. For example, if you wanted to store a collection
    of fractions, you could use doubles for the keys and strings for the values:'
  id: totrans-8146
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Swift 中，字典的所有键必须是相同的类型，字典的所有值也必须是相同的类型，但键的类型不必与值的类型相匹配。例如，如果你想存储一组分数，你可以使用双精度浮点数作为键，使用字符串作为值：
- en: '![](Image00142.jpg)'
  id: totrans-8147
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00142.jpg)'
- en: In this dictionary, all of the keys must be doubles, and all of the values must
    be strings. Again, you’ll see that the order of the numbers in the results pane
    can be quite different from the order in which you wrote the fractions in your
    dictionary. This is fine because you don’t need to know the order to access anything.
    You can find any item that you need by its key. Let’s see how!
  id: totrans-8148
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个字典中，所有的键必须是双精度浮点数，所有的值必须是字符串。再次强调，你会发现结果窗格中数字的顺序可能与字典中写入分数的顺序大不相同。这是可以接受的，因为你不需要知道顺序来访问任何项。你可以通过键找到你需要的任何项。让我们看看怎么做！
- en: '**ACCESSING VALUES IN A DICTIONARY**'
  id: totrans-8149
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**访问字典中的值**'
- en: 'Looking up a value in a dictionary is similar to how you access a value in
    an array except that you use a key inside the square brackets instead of an index,
    like this: usStates["TX"] .'
  id: totrans-8150
  prefs: []
  type: TYPE_NORMAL
  zh: 在字典中查找一个值类似于在数组中访问一个值，不同之处在于，你需要在方括号内使用键而不是索引，比如这样：usStates["TX"]。
- en: There is a big difference, however, in how Swift returns the values from a dictionary.
    When you access a value at an index of an array, you are simply given the value.
    When you access a value with a key in a dictionary, you are given an optional.
  id: totrans-8151
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在 Swift 中从字典中返回值的方式有很大不同。当你在数组的某个索引处访问一个值时，你会直接得到这个值。而当你在字典中使用键访问一个值时，你得到的是一个可选值。
- en: In [Chapter 5](text00015.html#ch05) , you learned that optionals might contain
    a value or might be nil . The reason Swift returns optionals when you’re looking
    up items in a dictionary is that the key you used might not exist in the dictionary,
    in which case there’s no value to access. Trying to access a value that doesn’t
    exist would give you a big fat error! To avoid that problem, Swift returns optionals.
    That means you need to unwrap any value you get out of a dictionary before you
    can do anything with it.
  id: totrans-8152
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第5章](text00015.html#ch05)中，你已经学习了可选值可能包含一个值，也可能是 nil。Swift 返回可选值的原因是，当你在字典中查找项时，你使用的键可能在字典中不存在，这时就没有值可以访问。试图访问不存在的值会导致一个巨大的错误！为了解决这个问题，Swift
    返回可选值。这意味着你在使用从字典中获取的任何值之前，都需要先解包。
- en: 'To unwrap an optional, first you check whether it exists using an if-let statement,
    just like we did in [Chapter 5](text00015.html#ch05) . The following code shows
    you how to get a value out of a dictionary:'
  id: totrans-8153
  prefs: []
  type: TYPE_NORMAL
  zh: 要解包一个可选值，首先使用 if-let 语句检查它是否存在，就像我们在[第5章](text00015.html#ch05)中做的那样。以下代码展示了如何从字典中获取一个值：
- en: '![Image](Image00143.jpg)'
  id: totrans-8154
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Image00143.jpg)'
- en: To retrieve "Texas" from the dictionary, we use if let to set a constant loneStarState
    to usStates["TX"] ➊ . Because we have this state in our dictionary, the line I
    have Texas in my dictionary. is printed. Next we try to access a state that is
    not in our dictionary by using the key usStates["FL"] ➋ . Thankfully, because
    we used an if-let statement, the program won’t crash when the computer can’t find
    this state. Instead, I don't have that state in my dictionary. is printed.
  id: totrans-8155
  prefs: []
  type: TYPE_NORMAL
  zh: 要从字典中获取 "Texas"，我们使用 `if let` 将常量 `loneStarState` 设置为 `usStates["TX"]` ➊。因为字典中包含该州，所以会打印出
    "I have Texas in my dictionary." 接下来，我们尝试通过使用键 `usStates["FL"]` ➋ 来访问一个不在字典中的州。幸运的是，由于我们使用了
    `if-let` 语句，当计算机无法找到该州时，程序不会崩溃。相反，会打印出 "I don't have that state in my dictionary."。
- en: '**ADDING ITEMS TO A DICTIONARY**'
  id: totrans-8156
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**向字典中添加项**'
- en: 'To add an item to a dictionary, first write the name of your dictionary and
    assign the new item to the key you want it to have in the dictionary. Let’s add
    "Minnesota" to our usStates dictionary:'
  id: totrans-8157
  prefs: []
  type: TYPE_NORMAL
  zh: 要向字典中添加一项，首先写出字典的名称，并将新项赋给你希望它在字典中拥有的键。让我们向 `usStates` 字典添加 "Minnesota"：
- en: '![](Image00144.jpg)'
  id: totrans-8158
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00144.jpg)'
- en: 'Now when you look at usStates , you’ll see that it’s updated to ["MN": "Minnesota",
    "WA": "Washington", "MA": "Massachusetts", "TX": "Texas"] . Remember, because
    you don’t have to rely on indices, your new dictionary item might appear anywhere
    in the dictionary.'
  id: totrans-8159
  prefs: []
  type: TYPE_NORMAL
  zh: '现在，当你查看 `usStates` 时，你会看到它已经更新为 ["MN": "Minnesota", "WA": "Washington", "MA":
    "Massachusetts", "TX": "Texas"]。记住，因为你不需要依赖索引，所以新的字典项可能会出现在字典中的任何位置。'
- en: '**REMOVING ITEMS FROM A DICTIONARY**'
  id: totrans-8160
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**从字典中移除项**'
- en: Removing an item from a dictionary is quite simple; you do so by setting the
    value to nil . Because the values in dictionaries are returned as optionals, you
    don’t have to worry about nil causing any problems in your dictionary.
  id: totrans-8161
  prefs: []
  type: TYPE_NORMAL
  zh: 从字典中移除一项非常简单；你只需将值设置为 `nil`。因为字典中的值是以可选项形式返回的，所以你不必担心 `nil` 会在字典中引发任何问题。
- en: '![](Image00145.jpg)'
  id: totrans-8162
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00145.jpg)'
- en: 'You can see that after you remove the value at the key "MA" , usStates is updated
    to ["MN": "Minnesota", "WA": "Washington", "TX": "Texas"] . Remember that nil
    is special and means that there’s no value at all. That’s why you don’t see "MA":
    nil in our dictionary.'
  id: totrans-8163
  prefs: []
  type: TYPE_NORMAL
  zh: '你可以看到，在移除键 "MA" 对应的值后，`usStates` 被更新为 ["MN": "Minnesota", "WA": "Washington",
    "TX": "Texas"]。记住，`nil` 是特殊的，表示完全没有值。这就是为什么你在字典中看不到 "MA": nil 的原因。'
- en: '**REPLACING ITEMS IN A DICTIONARY**'
  id: totrans-8164
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**替换字典中的项**'
- en: 'Replacing an item in a dictionary is also easy. It works the same was as replacing
    an item in an array. You just set the item that you want to replace to something
    else. Say you create a dictionary of fruit colors:'
  id: totrans-8165
  prefs: []
  type: TYPE_NORMAL
  zh: 替换字典中的项也很简单。它与替换数组中的项方式相同。你只需要将要替换的项设置为其他值。例如，你可以创建一个水果颜色的字典：
- en: '![](Image00146.jpg)'
  id: totrans-8166
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00146.jpg)'
- en: At first we had the value "apple" for "red" , but then we decided that "raspberry"
    is a better fruit to use since sometimes apples are green or yellow. To replace
    "apple" with "raspberry" , we set colorFruits["red"] to its new value ➊ .
  id: totrans-8167
  prefs: []
  type: TYPE_NORMAL
  zh: 起初我们为 "red" 设置了 "apple" 的值，但后来我们决定使用 "raspberry"，因为有时候苹果是绿色或黄色的。要将 "apple" 替换为
    "raspberry"，我们将 `colorFruits["red"]` 设置为它的新值 ➊。
- en: You may remember that this is the same way we entered a new value into a dictionary.
    If the key already exists in the dictionary, then the value for that key is replaced.
    If the key doesn’t already exist, then the new key/value pair will be added to
    the dictionary.
  id: totrans-8168
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能还记得，这是我们将新值插入字典的相同方式。如果键已经存在于字典中，则该键的值会被替换。如果键不存在，则新的键值对将被添加到字典中。
- en: '![Image](Image00147.jpg)'
  id: totrans-8169
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00147.jpg)'
- en: '**USING DICTIONARY PROPERTIES**'
  id: totrans-8170
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**使用字典的属性**'
- en: 'Like an array, a dictionary also has an isEmpty property and a count property.
    For example, the following code shows how you can use the isEmpty property to
    check if a dictionary is empty, and if it isn’t empty, the count property checks
    how many items you have. Imagine you have a basket of fruit for sale. You can
    use these properties to help you keep track of everything:'
  id: totrans-8171
  prefs: []
  type: TYPE_NORMAL
  zh: 与数组一样，字典也有 `isEmpty` 属性和 `count` 属性。例如，以下代码展示了如何使用 `isEmpty` 属性来检查字典是否为空，如果不为空，则使用
    `count` 属性来检查字典中有多少项。假设你有一个水果篮子要出售。你可以使用这些属性帮助你跟踪所有内容：
- en: '![Image](Image00148.jpg)'
  id: totrans-8172
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00148.jpg)'
- en: 'A dictionary also has two special properties: keys , which contains all of
    the dictionary’s keys, and values , which contains all of its values. We’ll use
    these two properties when we loop through the dictionary.'
  id: totrans-8173
  prefs: []
  type: TYPE_NORMAL
  zh: 字典还有两个特殊的属性：keys，包含字典中的所有键；以及 values，包含字典中的所有值。当我们遍历字典时，我们会使用这两个属性。
- en: Let’s write some code that loops through our fruit baskets and prints the price
    of each fruit.
  id: totrans-8174
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们写一些代码，循环遍历我们的水果篮并打印每种水果的价格。
- en: '**LOOPING OVER A DICTIONARY**'
  id: totrans-8175
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**遍历字典**'
- en: 'You can loop through a dictionary using a for-in loop. Because each item has
    a key and a value, you can do this in two different ways. This is how to loop
    through a dictionary using its keys:'
  id: totrans-8176
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用 for-in 循环遍历字典。因为每个项都有一个键和值，所以你可以通过两种不同的方式来实现。这是使用字典的键来循环遍历的方法：
- en: '![Image](Image00149.jpg)'
  id: totrans-8177
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Image00149.jpg)'
- en: Here we use the dictionary’s keys property ➊ to loop through fruitBasket and
    print its contents. We start by writing the keyword for , followed by a constant
    name fruit for the dictionary key, the keyword in , the dictionary name, a period,
    and keys .
  id: totrans-8178
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们使用字典的 keys 属性 ➊ 来循环遍历 fruitBasket 并打印其内容。我们首先写下关键字 for，然后是一个常量名称 fruit（代表字典的键），接着是关键字
    in，字典的名称，一个句点和 keys。
- en: Inside the braces of our for-in loop, we have access to both the key, which
    we call fruit ➋ , and the value at that key when we force-unwrap its contents
    with fruitBasket[fruit]! ➌ . That value will be the fruit’s price.
  id: totrans-8179
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的 for-in 循环的大括号内，我们可以访问键（我们称之为水果 ➋），并通过强制解包 fruitBasket[fruit]! ➌ 获取该键对应的值。这个值就是水果的价格。
- en: In this case, it’s safe to force-unwrap the value using an exclamation point
    because we know that the fruit key we’re using is definitely inside the dictionary.
  id: totrans-8180
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，可以安全地使用感叹号强制解包值，因为我们知道我们使用的水果键一定在字典中。
- en: Any code we put inside the for-in loop will run once for every key in our dictionary.
    So you should see the print statement display three times.
  id: totrans-8181
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在 for-in 循环内放入的任何代码都会对字典中的每个键执行一次。因此，你应该看到打印语句显示三次。
- en: 'We can also loop through the dictionary using its values property:'
  id: totrans-8182
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以使用字典的 values 属性来循环遍历：
- en: '![Image](Image00150.jpg)'
  id: totrans-8183
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Image00150.jpg)'
- en: We use the same style of for-in loop, but now we use a constant to refer to
    each value, which we call price , in the values property. When looping through
    values, we don’t have access to the keys from inside the loop.
  id: totrans-8184
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用相同类型的 for-in 循环，但现在我们使用一个常量来引用 values 属性中的每个值，我们称之为价格。当遍历值时，我们无法从循环内部访问键。
- en: Another difference to note is that price is not an optional because it’s accessed
    directly as a value in the fruitBasket dictionary. That means we don’t have to
    unwrap it. You should still see the print statement printed three times. [Figure
    6-6](text00016.html#ch06fig6) shows the output of both loops.
  id: totrans-8185
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个需要注意的区别是，价格不是可选的，因为它是直接作为值访问的 fruitBasket 字典中的内容。这意味着我们不需要解包它。你仍然应该看到打印语句显示三次。[图
    6-6](text00016.html#ch06fig6) 显示了两种循环的输出。
- en: '![Image](Image00151.jpg)'
  id: totrans-8186
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Image00151.jpg)'
- en: '*Figure 6-6: Looping through the keys and values of a dictionary with a for-in
    loop*'
  id: totrans-8187
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 6-6：使用 for-in 循环遍历字典的键和值*'
- en: The order of your results might be slightly different from ours. That’s because
    the items in a dictionary aren’t in a numbered order like they are in an array!
    And because the order is not guaranteed, you might see a different order printed
    if you run the same code again.
  id: totrans-8188
  prefs: []
  type: TYPE_NORMAL
  zh: 你的结果顺序可能会与我们的稍有不同。那是因为字典中的项不像数组那样按编号顺序排列！由于顺序无法保证，如果你再次运行相同的代码，打印顺序可能会不同。
- en: '**WHAT YOU LEARNED**'
  id: totrans-8189
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**你学到了什么**'
- en: In this chapter, you learned how to store collections of items in an array and
    in a dictionary. To store items in an ordered list, you would use an array and
    look up each item by its index. If you wanted to store items by key instead, you
    would use a dictionary.
  id: totrans-8190
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一章中，你学会了如何将项目存储在数组和字典中。为了将项目存储在有序列表中，你会使用数组，并通过索引查找每个项目。如果你想通过键存储项目，则使用字典。
- en: Knowing about arrays and dictionaries and how to use them is a powerful building
    block for almost any programming language. Next we will learn about functions,
    another very powerful tool. Functions are blocks of code that you create and name
    to perform a specific job. After you have written a function, you can use its
    name to call it from almost anywhere in your program.
  id: totrans-8191
  prefs: []
  type: TYPE_NORMAL
  zh: 了解数组和字典及其使用方式是几乎所有编程语言的强大构建模块。接下来，我们将学习函数，这是另一个非常强大的工具。函数是你创建并命名的代码块，用来执行特定的任务。写完一个函数后，你可以通过它的名字在程序中的几乎任何地方调用它。
- en: '![Image](Image00133.jpg)'
  id: totrans-8192
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Image00133.jpg)'
- en: '**USING ARRAY PROPERTIES**'
  id: totrans-8193
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**使用数组属性**'
- en: In addition to methods like append(_:) and removeLast() , arrays also have *properties*
    . An array’s properties are variables or constants that contain some information
    about the array. Two really helpful properties that you might use are the Boolean
    property isEmpty and the integer property count .
  id: totrans-8194
  prefs: []
  type: TYPE_NORMAL
  zh: 除了像 append(_:) 和 removeLast() 这样的 方法，数组还有*属性*。数组的属性是包含有关数组一些信息的变量或常量。你可能会使用的两个非常有用的属性是布尔类型的属性
    isEmpty 和整数类型的属性 count。
- en: The isEmpty property is true or false depending on whether the array is empty,
    and the count property will tell you how many items are in that array.
  id: totrans-8195
  prefs: []
  type: TYPE_NORMAL
  zh: isEmpty 属性根据数组是否为空返回 true 或 false，count 属性则会告诉你数组中有多少个元素。
- en: 'Check out how these two properties are used in the following if-else statement:'
  id: totrans-8196
  prefs: []
  type: TYPE_NORMAL
  zh: 查看以下 if-else 语句中这两个属性的使用方法：
- en: '![Image](Image00134.jpg)'
  id: totrans-8197
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Image00134.jpg)'
- en: 'This if-else statement checks whether the array mySiblings is empty ➊ . If
    it is, then "I don''t have any siblings." is printed. But if there is something
    in the array, then the number of siblings that we have is printed: "I have 3 siblings."
    ➋ .'
  id: totrans-8198
  prefs: []
  type: TYPE_NORMAL
  zh: 这个 if-else 语句检查数组 mySiblings 是否为空 ➊。如果为空，那么会打印出 "我没有兄弟姐妹"。但是如果数组中有内容，就会打印出我们有多少兄弟姐妹："我有
    3 个兄弟姐妹" ➋。
- en: '**LOOPING OVER AN ARRAY**'
  id: totrans-8199
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**遍历数组**'
- en: 'Sometimes when you’re working with arrays you might want to do something to
    every item in the array. You can use a for-in loop to do that! The following code
    will print every topping in a pizzaToppings array on a separate line:'
  id: totrans-8200
  prefs: []
  type: TYPE_NORMAL
  zh: 有时候在处理数组时，你可能想对数组中的每个项做一些操作。你可以使用 for-in 循环来做到这一点！下面的代码会在每一行上打印出 pizzaToppings
    数组中的每个配料：
- en: '![Image](Image00135.jpg)'
  id: totrans-8201
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Image00135.jpg)'
- en: To write a for-in loop for the pizzaToppings array, we used the keyword for
    , followed by the constant topping , then the keyword in , and finally the name
    of our array, pizzaToppings . Then we put the statements that we want to run for
    each topping inside the braces of the for-in loop. The constant topping ➊ temporarily
    represents each pizza topping in the array as we loop through it. We could have
    chosen any name for this constant, but it’s a good idea to pick something that
    makes sense. You can see the output of this for-in loop in [Figure 6-4](text00016.html#ch06fig4)
    .
  id: totrans-8202
  prefs: []
  type: TYPE_NORMAL
  zh: 为了写一个针对 pizzaToppings 数组的 for-in 循环，我们使用了关键字 for，后面跟常量 topping，再加上关键字 in，最后是我们的数组名字
    pizzaToppings。然后我们把希望在每次循环中执行的语句放在 for-in 循环的大括号内。常量 topping ➊ 在我们循环时临时代表数组中的每个配料。我们本可以为这个常量选择任何名字，但选择一个有意义的名字是个不错的主意。你可以在
    [图 6-4](text00016.html#ch06fig4) 中看到这个 for-in 循环的输出。
- en: '![Image](Image00136.jpg)'
  id: totrans-8203
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Image00136.jpg)'
- en: '*Figure 6-4: Output of the example for-in loop*'
  id: totrans-8204
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 6-4：示例 for-in 循环的输出*'
- en: '![Image](Image00137.jpg)'
  id: totrans-8205
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Image00137.jpg)'
- en: 'Using for-in loops is great for printing every value in an array. If you’re
    working with numbers, you can even use them to perform math operations on each
    item, which makes for some speedy calculations! The following code takes an array
    of numbers and calculates the square for each (the square of a number is that
    number multiplied by itself):'
  id: totrans-8206
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 for-in 循环非常适合打印数组中的每个值。如果你在处理数字，甚至可以使用它们对每个项执行数学运算，这样就能进行快速计算！下面的代码会对一个数字数组中的每个数字计算平方（数字的平方是该数字乘以它自身）：
- en: '![Image](Image00138.jpg)'
  id: totrans-8207
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Image00138.jpg)'
- en: '[Figure 6-5](text00016.html#ch06fig5) shows the results.'
  id: totrans-8208
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 6-5](text00016.html#ch06fig5) 显示了结果。'
- en: '![Image](Image00139.jpg)'
  id: totrans-8209
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Image00139.jpg)'
- en: '*Figure 6-5: Printing the squares for each number in the myNumbers array*'
  id: totrans-8210
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 6-5：打印 myNumbers 数组中每个数字的平方*'
- en: '**DICTIONARIES ARE KEY!**'
  id: totrans-8211
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**字典是关键！**'
- en: A *dictionary* is also a collection of values, but instead of an ordered index,
    each value has its own *key* . Because there’s no index, the values are not stored
    in any particular order. To access values in a dictionary, you look them up by
    their key.
  id: totrans-8212
  prefs: []
  type: TYPE_NORMAL
  zh: '*字典* 也是一个值的集合，但与有序索引不同，每个值都有自己的*键*。由于没有索引，值并没有按照特定的顺序存储。要访问字典中的值，你需要通过它们的键来查找。'
- en: A key must be unique. You can’t have the same key more than once in the same
    dictionary. If there were two identical keys and you asked the computer to give
    you the value for one of them, the computer wouldn’t know which one to choose!
  id: totrans-8213
  prefs: []
  type: TYPE_NORMAL
  zh: 键必须是唯一的。你不能在同一个字典中使用相同的键。如果存在两个相同的键，当你要求计算机返回其中一个的值时，计算机将无法知道选择哪个！
- en: Let’s take a look at how to make a dictionary and write keys that will help
    you find all the information you need.
  id: totrans-8214
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如何创建一个字典，并编写键来帮助你找到所需的所有信息。
- en: '![Image](Image00140.jpg)'
  id: totrans-8215
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Image00140.jpg)'
- en: '**INITIALIZING A DICTIONARY**'
  id: totrans-8216
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**初始化字典**'
- en: 'To create and initialize a dictionary, first write var and the name of your
    dictionary. Then write the keys and corresponding values inside a pair of square
    brackets, similar to an array. Let’s create a dictionary to store the names of
    a few US states. The key for each state will be its two-letter abbreviation:'
  id: totrans-8217
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建和初始化字典，首先写下`var`和你的字典名称。然后在一对方括号内写下键和对应的值，类似于数组。让我们创建一个字典来存储几个美国州的名称。每个州的键将是其两个字母的缩写：
- en: '![](Image00141.jpg)'
  id: totrans-8218
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00141.jpg)'
- en: As you can see, there’s a colon between each key and its value, and the key/value
    pairs are separated by commas.
  id: totrans-8219
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所见，每个键和其值之间都有一个冒号，并且键值对之间用逗号分隔。
- en: Dictionaries are different from arrays in that they are *unordered* . Because
    of that, it’s likely that the order of the states that you see in your results
    pane ➋ is different from the order in which you entered your states ➊ . It might
    even be different than the order that’s printed in this book!
  id: totrans-8220
  prefs: []
  type: TYPE_NORMAL
  zh: 字典与数组不同，它们是*无序*的。因此，在结果窗格中看到的州的顺序可能与您输入的州的顺序不同，甚至可能与本书中打印的顺序不同！
- en: As with arrays, you can use var to make a mutable dictionary or use let to make
    an immutable dictionary.
  id: totrans-8221
  prefs: []
  type: TYPE_NORMAL
  zh: 与数组一样，你可以使用`var`创建可变字典，或者使用`let`创建不可变字典。
- en: 'In Swift, all of the keys of a dictionary must be the same type, and all of
    the values of a dictionary must also be the same type, but the key type doesn’t
    have to match the value type. For example, if you wanted to store a collection
    of fractions, you could use doubles for the keys and strings for the values:'
  id: totrans-8222
  prefs: []
  type: TYPE_NORMAL
  zh: 在Swift中，字典的所有键必须是相同的类型，所有值也必须是相同的类型，但键的类型不必与值的类型匹配。例如，如果你想存储一组分数，你可以使用双精度浮点数作为键，字符串作为值：
- en: '![](Image00142.jpg)'
  id: totrans-8223
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00142.jpg)'
- en: In this dictionary, all of the keys must be doubles, and all of the values must
    be strings. Again, you’ll see that the order of the numbers in the results pane
    can be quite different from the order in which you wrote the fractions in your
    dictionary. This is fine because you don’t need to know the order to access anything.
    You can find any item that you need by its key. Let’s see how!
  id: totrans-8224
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个字典中，所有的键必须是双精度浮点数，所有的值必须是字符串。同样，你会看到结果窗格中的数字顺序可能与你在字典中写分数的顺序完全不同。这没关系，因为你不需要知道顺序来访问任何东西。你可以通过键找到任何你需要的项目。让我们看看如何做到！
- en: '**ACCESSING VALUES IN A DICTIONARY**'
  id: totrans-8225
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**访问字典中的值**'
- en: 'Looking up a value in a dictionary is similar to how you access a value in
    an array except that you use a key inside the square brackets instead of an index,
    like this: usStates["TX"] .'
  id: totrans-8226
  prefs: []
  type: TYPE_NORMAL
  zh: 在字典中查找值类似于访问数组中的值，但你使用的是方括号内的键而不是索引，就像这样：usStates["TX"]。
- en: There is a big difference, however, in how Swift returns the values from a dictionary.
    When you access a value at an index of an array, you are simply given the value.
    When you access a value with a key in a dictionary, you are given an optional.
  id: totrans-8227
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，Swift从字典返回值的方式有很大的不同。当你访问数组的索引处的值时，你只是得到这个值。当你使用字典中的键访问值时，你得到的是一个可选项。
- en: In [Chapter 5](text00015.html#ch05) , you learned that optionals might contain
    a value or might be nil . The reason Swift returns optionals when you’re looking
    up items in a dictionary is that the key you used might not exist in the dictionary,
    in which case there’s no value to access. Trying to access a value that doesn’t
    exist would give you a big fat error! To avoid that problem, Swift returns optionals.
    That means you need to unwrap any value you get out of a dictionary before you
    can do anything with it.
  id: totrans-8228
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第五章](text00015.html#ch05)，你学到了可选项可能包含一个值，也可能为nil。Swift返回可选项的原因是，你使用的键可能不存在于字典中，这种情况下就没有值可供访问。试图访问不存在的值会导致一个大大的错误！为了避免这个问题，Swift返回可选项。这意味着在对字典中取出的任何值进行操作之前，你需要对其进行解包。
- en: 'To unwrap an optional, first you check whether it exists using an if-let statement,
    just like we did in [Chapter 5](text00015.html#ch05) . The following code shows
    you how to get a value out of a dictionary:'
  id: totrans-8229
  prefs: []
  type: TYPE_NORMAL
  zh: 要解包可选项，首先使用if-let语句检查其是否存在，就像我们在[第五章](text00015.html#ch05)中所做的那样。以下代码展示了如何从字典中获取值：
- en: '![Image](Image00143.jpg)'
  id: totrans-8230
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00143.jpg)'
- en: To retrieve "Texas" from the dictionary, we use if let to set a constant loneStarState
    to usStates["TX"] ➊ . Because we have this state in our dictionary, the line I
    have Texas in my dictionary. is printed. Next we try to access a state that is
    not in our dictionary by using the key usStates["FL"] ➋ . Thankfully, because
    we used an if-let statement, the program won’t crash when the computer can’t find
    this state. Instead, I don't have that state in my dictionary. is printed.
  id: totrans-8231
  prefs: []
  type: TYPE_NORMAL
  zh: 为了从字典中检索“Texas”，我们使用if let语句将常量loneStarState设置为usStates["TX"] ➊。因为字典中有这个州，所以会打印出“我在字典中有Texas”。接下来，我们尝试使用键usStates["FL"]
    ➋访问一个不在字典中的州。幸运的是，因为我们使用了if-let语句，当计算机找不到这个州时，程序不会崩溃。相反，会打印出“我字典中没有那个州”。
- en: '**ADDING ITEMS TO A DICTIONARY**'
  id: totrans-8232
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**向字典中添加项目**'
- en: 'To add an item to a dictionary, first write the name of your dictionary and
    assign the new item to the key you want it to have in the dictionary. Let’s add
    "Minnesota" to our usStates dictionary:'
  id: totrans-8233
  prefs: []
  type: TYPE_NORMAL
  zh: 要向字典中添加项目，首先写下字典的名称，并将新项目分配给你希望它在字典中拥有的键。让我们将“Minnesota”添加到我们的usStates字典中：
- en: '![](Image00144.jpg)'
  id: totrans-8234
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00144.jpg)'
- en: 'Now when you look at usStates , you’ll see that it’s updated to ["MN": "Minnesota",
    "WA": "Washington", "MA": "Massachusetts", "TX": "Texas"] . Remember, because
    you don’t have to rely on indices, your new dictionary item might appear anywhere
    in the dictionary.'
  id: totrans-8235
  prefs: []
  type: TYPE_NORMAL
  zh: '现在，当你查看usStates时，你会看到它更新为["MN": "Minnesota", "WA": "Washington", "MA": "Massachusetts",
    "TX": "Texas"]。记住，由于你不必依赖索引，因此新添加的字典项可能会出现在字典中的任何位置。'
- en: '**REMOVING ITEMS FROM A DICTIONARY**'
  id: totrans-8236
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**从字典中移除项目**'
- en: Removing an item from a dictionary is quite simple; you do so by setting the
    value to nil . Because the values in dictionaries are returned as optionals, you
    don’t have to worry about nil causing any problems in your dictionary.
  id: totrans-8237
  prefs: []
  type: TYPE_NORMAL
  zh: 从字典中移除项目非常简单；你只需将值设置为nil。由于字典中的值是以可选值的形式返回的，因此你不必担心nil会在字典中引发任何问题。
- en: '![](Image00145.jpg)'
  id: totrans-8238
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00145.jpg)'
- en: 'You can see that after you remove the value at the key "MA" , usStates is updated
    to ["MN": "Minnesota", "WA": "Washington", "TX": "Texas"] . Remember that nil
    is special and means that there’s no value at all. That’s why you don’t see "MA":
    nil in our dictionary.'
  id: totrans-8239
  prefs: []
  type: TYPE_NORMAL
  zh: '你可以看到，在你移除键“MA”的值后，usStates已更新为["MN": "Minnesota", "WA": "Washington", "TX":
    "Texas"]。记住，nil是特殊的，它表示没有值。因此，你不会在字典中看到"MA": nil。'
- en: '**REPLACING ITEMS IN A DICTIONARY**'
  id: totrans-8240
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**替换字典中的项目**'
- en: 'Replacing an item in a dictionary is also easy. It works the same was as replacing
    an item in an array. You just set the item that you want to replace to something
    else. Say you create a dictionary of fruit colors:'
  id: totrans-8241
  prefs: []
  type: TYPE_NORMAL
  zh: 替换字典中的项目也很简单。它的工作方式与替换数组中的项目相同。你只需将想要替换的项目设置为其他值。例如，你创建一个水果颜色的字典：
- en: '![](Image00146.jpg)'
  id: totrans-8242
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00146.jpg)'
- en: At first we had the value "apple" for "red" , but then we decided that "raspberry"
    is a better fruit to use since sometimes apples are green or yellow. To replace
    "apple" with "raspberry" , we set colorFruits["red"] to its new value ➊ .
  id: totrans-8243
  prefs: []
  type: TYPE_NORMAL
  zh: 起初我们将“red”赋值为“apple”，但后来我们决定使用“raspberry”作为更合适的水果，因为有时候苹果是绿色或黄色的。为了将“apple”替换为“raspberry”，我们将colorFruits["red"]设置为它的新值
    ➊。
- en: You may remember that this is the same way we entered a new value into a dictionary.
    If the key already exists in the dictionary, then the value for that key is replaced.
    If the key doesn’t already exist, then the new key/value pair will be added to
    the dictionary.
  id: totrans-8244
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能记得这是我们将新值输入到字典中的相同方式。如果字典中已经存在该键，则该键的值会被替换。如果该键不存在，则新的键/值对将被添加到字典中。
- en: '![Image](Image00147.jpg)'
  id: totrans-8245
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Image00147.jpg)'
- en: '**USING DICTIONARY PROPERTIES**'
  id: totrans-8246
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**使用字典属性**'
- en: 'Like an array, a dictionary also has an isEmpty property and a count property.
    For example, the following code shows how you can use the isEmpty property to
    check if a dictionary is empty, and if it isn’t empty, the count property checks
    how many items you have. Imagine you have a basket of fruit for sale. You can
    use these properties to help you keep track of everything:'
  id: totrans-8247
  prefs: []
  type: TYPE_NORMAL
  zh: 像数组一样，字典也有isEmpty属性和count属性。例如，下面的代码展示了如何使用isEmpty属性来检查字典是否为空，如果不为空，count属性可以检查字典中有多少个项目。假设你有一个售卖水果的篮子。你可以使用这些属性来帮助你跟踪所有内容：
- en: '![Image](Image00148.jpg)'
  id: totrans-8248
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Image00148.jpg)'
- en: 'A dictionary also has two special properties: keys , which contains all of
    the dictionary’s keys, and values , which contains all of its values. We’ll use
    these two properties when we loop through the dictionary.'
  id: totrans-8249
  prefs: []
  type: TYPE_NORMAL
  zh: 字典还有两个特殊属性：keys，它包含字典中的所有键；以及values，它包含所有的值。当我们遍历字典时，会使用这两个属性。
- en: Let’s write some code that loops through our fruit baskets and prints the price
    of each fruit.
  id: totrans-8250
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们编写一些代码，遍历我们的水果篮，并打印每个水果的价格。
- en: '**LOOPING OVER A DICTIONARY**'
  id: totrans-8251
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**遍历字典**'
- en: 'You can loop through a dictionary using a for-in loop. Because each item has
    a key and a value, you can do this in two different ways. This is how to loop
    through a dictionary using its keys:'
  id: totrans-8252
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用for-in循环遍历字典。因为每个项目都有一个键和值，所以你可以通过两种不同的方式来做。以下是使用字典的键遍历字典的方法：
- en: '![Image](Image00149.jpg)'
  id: totrans-8253
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00149.jpg)'
- en: Here we use the dictionary’s keys property ➊ to loop through fruitBasket and
    print its contents. We start by writing the keyword for , followed by a constant
    name fruit for the dictionary key, the keyword in , the dictionary name, a period,
    and keys .
  id: totrans-8254
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们使用字典的keys属性 ➊ 来遍历fruitBasket并打印它的内容。我们首先写下关键字for，接着是常量名称fruit作为字典键，接着是关键字in，字典名称，句点和keys。
- en: Inside the braces of our for-in loop, we have access to both the key, which
    we call fruit ➋ , and the value at that key when we force-unwrap its contents
    with fruitBasket[fruit]! ➌ . That value will be the fruit’s price.
  id: totrans-8255
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的for-in循环的大括号内，我们可以访问到键（我们称之为fruit ➋）以及通过强制解包其内容`fruitBasket[fruit]!` ➌获得的该键对应的值。这个值就是水果的价格。
- en: In this case, it’s safe to force-unwrap the value using an exclamation point
    because we know that the fruit key we’re using is definitely inside the dictionary.
  id: totrans-8256
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，使用感叹号强制解包值是安全的，因为我们知道正在使用的fruit键肯定存在于字典中。
- en: Any code we put inside the for-in loop will run once for every key in our dictionary.
    So you should see the print statement display three times.
  id: totrans-8257
  prefs: []
  type: TYPE_NORMAL
  zh: 我们放入for-in循环中的任何代码都会针对字典中的每个键执行一次。所以你应该看到print语句显示三次。
- en: 'We can also loop through the dictionary using its values property:'
  id: totrans-8258
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以使用字典的values属性来遍历：
- en: '![Image](Image00150.jpg)'
  id: totrans-8259
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00150.jpg)'
- en: We use the same style of for-in loop, but now we use a constant to refer to
    each value, which we call price , in the values property. When looping through
    values, we don’t have access to the keys from inside the loop.
  id: totrans-8260
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用相同类型的for-in循环，但现在我们用一个常量来引用values属性中的每个值，我们称之为price。在遍历values时，我们无法从循环内部访问到键。
- en: Another difference to note is that price is not an optional because it’s accessed
    directly as a value in the fruitBasket dictionary. That means we don’t have to
    unwrap it. You should still see the print statement printed three times. [Figure
    6-6](text00016.html#ch06fig6) shows the output of both loops.
  id: totrans-8261
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个需要注意的区别是，price不是一个可选值，因为它是直接作为fruitBasket字典中的值来访问的。这意味着我们不需要解包它。你仍然应该看到print语句打印三次。[图6-6](text00016.html#ch06fig6)展示了两个循环的输出。
- en: '![Image](Image00151.jpg)'
  id: totrans-8262
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00151.jpg)'
- en: '*Figure 6-6: Looping through the keys and values of a dictionary with a for-in
    loop*'
  id: totrans-8263
  prefs: []
  type: TYPE_NORMAL
  zh: '*图6-6：使用for-in循环遍历字典的键和值*'
- en: The order of your results might be slightly different from ours. That’s because
    the items in a dictionary aren’t in a numbered order like they are in an array!
    And because the order is not guaranteed, you might see a different order printed
    if you run the same code again.
  id: totrans-8264
  prefs: []
  type: TYPE_NORMAL
  zh: 你的结果顺序可能与我们的略有不同。这是因为字典中的项目不像数组那样按编号顺序排列！由于顺序不保证，你可能会看到不同的顺序，如果你重新运行相同的代码。
- en: '**WHAT YOU LEARNED**'
  id: totrans-8265
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**你学到了什么**'
- en: In this chapter, you learned how to store collections of items in an array and
    in a dictionary. To store items in an ordered list, you would use an array and
    look up each item by its index. If you wanted to store items by key instead, you
    would use a dictionary.
  id: totrans-8266
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你学会了如何在数组和字典中存储项目集合。为了将项目存储在有序列表中，你会使用数组，并通过索引查找每个项目。如果你想根据键来存储项目，你则会使用字典。
- en: Knowing about arrays and dictionaries and how to use them is a powerful building
    block for almost any programming language. Next we will learn about functions,
    another very powerful tool. Functions are blocks of code that you create and name
    to perform a specific job. After you have written a function, you can use its
    name to call it from almost anywhere in your program.
  id: totrans-8267
  prefs: []
  type: TYPE_NORMAL
  zh: 了解数组和字典以及如何使用它们是几乎所有编程语言的强大构建块。接下来，我们将学习函数，这是另一个非常强大的工具。函数是你创建并命名的代码块，用于执行特定的任务。写完函数后，你可以通过它的名字在程序中的几乎任何地方调用它。
- en: '**USING ARRAY PROPERTIES**'
  id: totrans-8268
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**使用数组属性**'
- en: In addition to methods like append(_:) and removeLast() , arrays also have *properties*
    . An array’s properties are variables or constants that contain some information
    about the array. Two really helpful properties that you might use are the Boolean
    property isEmpty and the integer property count .
  id: totrans-8269
  prefs: []
  type: TYPE_NORMAL
  zh: 除了像 append(_:) 和 removeLast() 这样的方法，数组还具有 *属性*。数组的属性是包含有关数组的一些信息的变量或常量。你可能会用到的两个非常有用的属性是布尔类型的
    isEmpty 属性和整数类型的 count 属性。
- en: The isEmpty property is true or false depending on whether the array is empty,
    and the count property will tell you how many items are in that array.
  id: totrans-8270
  prefs: []
  type: TYPE_NORMAL
  zh: isEmpty 属性根据数组是否为空返回 true 或 false，count 属性则会告诉你数组中有多少个元素。
- en: 'Check out how these two properties are used in the following if-else statement:'
  id: totrans-8271
  prefs: []
  type: TYPE_NORMAL
  zh: 看看以下 if-else 语句中如何使用这两个属性：
- en: '![Image](Image00134.jpg)'
  id: totrans-8272
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00134.jpg)'
- en: 'This if-else statement checks whether the array mySiblings is empty ➊ . If
    it is, then "I don''t have any siblings." is printed. But if there is something
    in the array, then the number of siblings that we have is printed: "I have 3 siblings."
    ➋ .'
  id: totrans-8273
  prefs: []
  type: TYPE_NORMAL
  zh: 这个 if-else 语句检查数组 mySiblings 是否为空 ➊。如果为空，则打印 "我没有兄弟姐妹"。如果数组中有元素，则打印出兄弟姐妹的数量："我有
    3 个兄弟姐妹" ➋。
- en: '**LOOPING OVER AN ARRAY**'
  id: totrans-8274
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**循环遍历数组**'
- en: 'Sometimes when you’re working with arrays you might want to do something to
    every item in the array. You can use a for-in loop to do that! The following code
    will print every topping in a pizzaToppings array on a separate line:'
  id: totrans-8275
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，当你在处理数组时，你可能想对数组中的每个项做些事情。你可以使用 for-in 循环来实现！以下代码会在单独的行中打印出 pizzaToppings
    数组中的每个配料：
- en: '![Image](Image00135.jpg)'
  id: totrans-8276
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00135.jpg)'
- en: To write a for-in loop for the pizzaToppings array, we used the keyword for
    , followed by the constant topping , then the keyword in , and finally the name
    of our array, pizzaToppings . Then we put the statements that we want to run for
    each topping inside the braces of the for-in loop. The constant topping ➊ temporarily
    represents each pizza topping in the array as we loop through it. We could have
    chosen any name for this constant, but it’s a good idea to pick something that
    makes sense. You can see the output of this for-in loop in [Figure 6-4](text00016.html#ch06fig4)
    .
  id: totrans-8277
  prefs: []
  type: TYPE_NORMAL
  zh: 为了编写 pizzaToppings 数组的 for-in 循环，我们使用了关键字 for，后面跟着常量 topping，然后是关键字 in，最后是我们数组的名称
    pizzaToppings。然后，我们将要对每个配料执行的语句放入 for-in 循环的花括号中。常量 topping ➊ 在我们遍历数组时临时表示数组中的每个配料。我们本可以为这个常量选择任何名称，但选择一个有意义的名称是一个好主意。你可以在
    [图 6-4](text00016.html#ch06fig4) 中看到这个 for-in 循环的输出。
- en: '![Image](Image00136.jpg)'
  id: totrans-8278
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00136.jpg)'
- en: '*Figure 6-4: Output of the example for-in loop*'
  id: totrans-8279
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 6-4：示例 for-in 循环的输出*'
- en: '![Image](Image00137.jpg)'
  id: totrans-8280
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00137.jpg)'
- en: 'Using for-in loops is great for printing every value in an array. If you’re
    working with numbers, you can even use them to perform math operations on each
    item, which makes for some speedy calculations! The following code takes an array
    of numbers and calculates the square for each (the square of a number is that
    number multiplied by itself):'
  id: totrans-8281
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 for-in 循环非常适合打印数组中的每个值。如果你正在处理数字，你甚至可以利用它们对每个项目执行数学运算，这样可以进行快速的计算！以下代码获取一个数字数组并计算每个数字的平方（一个数字的平方是该数字乘以自身）：
- en: '![Image](Image00138.jpg)'
  id: totrans-8282
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00138.jpg)'
- en: '[Figure 6-5](text00016.html#ch06fig5) shows the results.'
  id: totrans-8283
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 6-5](text00016.html#ch06fig5) 显示了结果。'
- en: '![Image](Image00139.jpg)'
  id: totrans-8284
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00139.jpg)'
- en: '*Figure 6-5: Printing the squares for each number in the myNumbers array*'
  id: totrans-8285
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 6-5：打印 myNumbers 数组中每个数字的平方*'
- en: '**DICTIONARIES ARE KEY!**'
  id: totrans-8286
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**字典至关重要！**'
- en: A *dictionary* is also a collection of values, but instead of an ordered index,
    each value has its own *key* . Because there’s no index, the values are not stored
    in any particular order. To access values in a dictionary, you look them up by
    their key.
  id: totrans-8287
  prefs: []
  type: TYPE_NORMAL
  zh: '*字典* 也是一个值的集合，但不同于有序的索引，每个值都有自己的 *键*。由于没有索引，值不会按特定顺序存储。要访问字典中的值，你需要通过键来查找它们。'
- en: A key must be unique. You can’t have the same key more than once in the same
    dictionary. If there were two identical keys and you asked the computer to give
    you the value for one of them, the computer wouldn’t know which one to choose!
  id: totrans-8288
  prefs: []
  type: TYPE_NORMAL
  zh: 键必须是唯一的。在同一个字典中不能有相同的键。如果有两个相同的键，当你要求计算机给出其中一个的值时，计算机将不知道选择哪个！
- en: Let’s take a look at how to make a dictionary and write keys that will help
    you find all the information you need.
  id: totrans-8289
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看如何创建一个字典，并编写键，以帮助你找到所需的所有信息。
- en: '![Image](Image00140.jpg)'
  id: totrans-8290
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00140.jpg)'
- en: '**INITIALIZING A DICTIONARY**'
  id: totrans-8291
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**初始化字典**'
- en: 'To create and initialize a dictionary, first write var and the name of your
    dictionary. Then write the keys and corresponding values inside a pair of square
    brackets, similar to an array. Let’s create a dictionary to store the names of
    a few US states. The key for each state will be its two-letter abbreviation:'
  id: totrans-8292
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建和初始化一个字典，首先写var和字典的名称。然后在一对方括号内写入键及其对应的值，类似于数组。我们来创建一个字典，存储一些美国州的名称。每个州的键将是它的两字母缩写：
- en: '![](Image00141.jpg)'
  id: totrans-8293
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00141.jpg)'
- en: As you can see, there’s a colon between each key and its value, and the key/value
    pairs are separated by commas.
  id: totrans-8294
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，每个键和它的值之间有一个冒号，键值对之间用逗号分隔。
- en: Dictionaries are different from arrays in that they are *unordered* . Because
    of that, it’s likely that the order of the states that you see in your results
    pane ➋ is different from the order in which you entered your states ➊ . It might
    even be different than the order that’s printed in this book!
  id: totrans-8295
  prefs: []
  type: TYPE_NORMAL
  zh: '字典与数组的不同之处在于它们是*无序的*。因此，你在结果窗格➋中看到的州的顺序可能与你输入州的顺序➊不同。甚至可能与本书中打印的顺序不同！ '
- en: As with arrays, you can use var to make a mutable dictionary or use let to make
    an immutable dictionary.
  id: totrans-8296
  prefs: []
  type: TYPE_NORMAL
  zh: 与数组类似，你可以使用var来创建一个可变字典，或使用let来创建一个不可变字典。
- en: 'In Swift, all of the keys of a dictionary must be the same type, and all of
    the values of a dictionary must also be the same type, but the key type doesn’t
    have to match the value type. For example, if you wanted to store a collection
    of fractions, you could use doubles for the keys and strings for the values:'
  id: totrans-8297
  prefs: []
  type: TYPE_NORMAL
  zh: 在Swift中，字典的所有键必须是相同的类型，字典的所有值也必须是相同的类型，但键的类型不必与值的类型相匹配。例如，如果你想存储一组分数，你可以使用双精度类型作为键，字符串类型作为值：
- en: '![](Image00142.jpg)'
  id: totrans-8298
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00142.jpg)'
- en: In this dictionary, all of the keys must be doubles, and all of the values must
    be strings. Again, you’ll see that the order of the numbers in the results pane
    can be quite different from the order in which you wrote the fractions in your
    dictionary. This is fine because you don’t need to know the order to access anything.
    You can find any item that you need by its key. Let’s see how!
  id: totrans-8299
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个字典中，所有的键必须是双精度类型，所有的值必须是字符串类型。同样，你会看到在结果窗格中数字的顺序可能与字典中分数的顺序完全不同。这是正常的，因为你不需要知道顺序就能访问任何内容。你可以通过键来查找任何需要的项。我们来看看怎么做！
- en: '**ACCESSING VALUES IN A DICTIONARY**'
  id: totrans-8300
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**访问字典中的值**'
- en: 'Looking up a value in a dictionary is similar to how you access a value in
    an array except that you use a key inside the square brackets instead of an index,
    like this: usStates["TX"] .'
  id: totrans-8301
  prefs: []
  type: TYPE_NORMAL
  zh: 在字典中查找一个值类似于在数组中访问值的方式，不同之处在于，你在方括号中使用的是一个键，而不是索引，比如这样：usStates["TX"]。
- en: There is a big difference, however, in how Swift returns the values from a dictionary.
    When you access a value at an index of an array, you are simply given the value.
    When you access a value with a key in a dictionary, you are given an optional.
  id: totrans-8302
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，Swift在返回字典的值时有一个很大的区别。当你访问数组的某个索引位置的值时，你只是得到那个值。当你用字典中的键访问值时，你得到的是一个可选值。
- en: In [Chapter 5](text00015.html#ch05) , you learned that optionals might contain
    a value or might be nil . The reason Swift returns optionals when you’re looking
    up items in a dictionary is that the key you used might not exist in the dictionary,
    in which case there’s no value to access. Trying to access a value that doesn’t
    exist would give you a big fat error! To avoid that problem, Swift returns optionals.
    That means you need to unwrap any value you get out of a dictionary before you
    can do anything with it.
  id: totrans-8303
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第5章](text00015.html#ch05)中，你学到可选值可能包含一个值，也可能为nil。Swift返回可选值的原因是，当你在字典中查找项时，使用的键可能在字典中不存在，这种情况下没有值可供访问。试图访问一个不存在的值会导致一个大错误！为了避免这个问题，Swift返回可选值。这意味着，在你做任何操作之前，你需要解包从字典中取出的值。
- en: 'To unwrap an optional, first you check whether it exists using an if-let statement,
    just like we did in [Chapter 5](text00015.html#ch05) . The following code shows
    you how to get a value out of a dictionary:'
  id: totrans-8304
  prefs: []
  type: TYPE_NORMAL
  zh: 要解包一个可选值，首先使用if-let语句检查它是否存在，就像我们在[第5章](text00015.html#ch05)中做的那样。以下代码展示了如何从字典中获取一个值：
- en: '![Image](Image00143.jpg)'
  id: totrans-8305
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00143.jpg)'
- en: To retrieve "Texas" from the dictionary, we use if let to set a constant loneStarState
    to usStates["TX"] ➊ . Because we have this state in our dictionary, the line I
    have Texas in my dictionary. is printed. Next we try to access a state that is
    not in our dictionary by using the key usStates["FL"] ➋ . Thankfully, because
    we used an if-let statement, the program won’t crash when the computer can’t find
    this state. Instead, I don't have that state in my dictionary. is printed.
  id: totrans-8306
  prefs: []
  type: TYPE_NORMAL
  zh: 要从字典中获取"Texas"，我们使用if let语句将常量loneStarState设置为usStates["TX"] ➊。由于字典中有这个州，因此打印出“我在字典中有Texas”。接下来，我们尝试使用键usStates["FL"]
    ➋访问字典中没有的州。幸运的是，由于我们使用了if-let语句，当计算机找不到该州时，程序不会崩溃。相反，打印出“我字典中没有那个州”。
- en: '**ADDING ITEMS TO A DICTIONARY**'
  id: totrans-8307
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**向字典中添加项目**'
- en: 'To add an item to a dictionary, first write the name of your dictionary and
    assign the new item to the key you want it to have in the dictionary. Let’s add
    "Minnesota" to our usStates dictionary:'
  id: totrans-8308
  prefs: []
  type: TYPE_NORMAL
  zh: 要向字典中添加一个项目，首先写出字典的名称，然后将新项目分配给你希望它在字典中拥有的键。让我们将"Minnesota"添加到我们的usStates字典中：
- en: '![](Image00144.jpg)'
  id: totrans-8309
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00144.jpg)'
- en: 'Now when you look at usStates , you’ll see that it’s updated to ["MN": "Minnesota",
    "WA": "Washington", "MA": "Massachusetts", "TX": "Texas"] . Remember, because
    you don’t have to rely on indices, your new dictionary item might appear anywhere
    in the dictionary.'
  id: totrans-8310
  prefs: []
  type: TYPE_NORMAL
  zh: '现在，当你查看usStates时，你会看到它已更新为["MN": "Minnesota", "WA": "Washington", "MA": "Massachusetts",
    "TX": "Texas"]。记住，由于你不需要依赖索引，你的新字典项可能会出现在字典中的任何位置。'
- en: '**REMOVING ITEMS FROM A DICTIONARY**'
  id: totrans-8311
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**从字典中移除项目**'
- en: Removing an item from a dictionary is quite simple; you do so by setting the
    value to nil . Because the values in dictionaries are returned as optionals, you
    don’t have to worry about nil causing any problems in your dictionary.
  id: totrans-8312
  prefs: []
  type: TYPE_NORMAL
  zh: 从字典中移除一个项目也很简单；你只需将该值设置为nil。由于字典中的值是可选类型，因此你不必担心nil会在字典中引起任何问题。
- en: '![](Image00145.jpg)'
  id: totrans-8313
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00145.jpg)'
- en: 'You can see that after you remove the value at the key "MA" , usStates is updated
    to ["MN": "Minnesota", "WA": "Washington", "TX": "Texas"] . Remember that nil
    is special and means that there’s no value at all. That’s why you don’t see "MA":
    nil in our dictionary.'
  id: totrans-8314
  prefs: []
  type: TYPE_NORMAL
  zh: '你可以看到，在你移除键"MA"的值后，usStates被更新为["MN": "Minnesota", "WA": "Washington", "TX":
    "Texas"]。记住，nil是特殊的，表示没有值。因此，你不会在字典中看到"MA": nil。'
- en: '**REPLACING ITEMS IN A DICTIONARY**'
  id: totrans-8315
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**在字典中替换项目**'
- en: 'Replacing an item in a dictionary is also easy. It works the same was as replacing
    an item in an array. You just set the item that you want to replace to something
    else. Say you create a dictionary of fruit colors:'
  id: totrans-8316
  prefs: []
  type: TYPE_NORMAL
  zh: 在字典中替换一个项目也很简单。它的工作方式与替换数组中的项目相同。你只需将要替换的项目设置为其他值。例如，假设你创建了一个水果颜色的字典：
- en: '![](Image00146.jpg)'
  id: totrans-8317
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00146.jpg)'
- en: At first we had the value "apple" for "red" , but then we decided that "raspberry"
    is a better fruit to use since sometimes apples are green or yellow. To replace
    "apple" with "raspberry" , we set colorFruits["red"] to its new value ➊ .
  id: totrans-8318
  prefs: []
  type: TYPE_NORMAL
  zh: 一开始，我们为"red"设置了值"apple"，但后来我们决定使用"raspberry"（覆盆子），因为有时候苹果是绿色或黄色的。为了将"apple"替换为"raspberry"，我们将colorFruits["red"]的值设置为新的值➊。
- en: You may remember that this is the same way we entered a new value into a dictionary.
    If the key already exists in the dictionary, then the value for that key is replaced.
    If the key doesn’t already exist, then the new key/value pair will be added to
    the dictionary.
  id: totrans-8319
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能还记得，这是我们向字典中添加新值的方式。如果键在字典中已经存在，那么该键的值将被替换。如果键不存在，则新的键/值对将被添加到字典中。
- en: '![Image](Image00147.jpg)'
  id: totrans-8320
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00147.jpg)'
- en: '**USING DICTIONARY PROPERTIES**'
  id: totrans-8321
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**使用字典属性**'
- en: 'Like an array, a dictionary also has an isEmpty property and a count property.
    For example, the following code shows how you can use the isEmpty property to
    check if a dictionary is empty, and if it isn’t empty, the count property checks
    how many items you have. Imagine you have a basket of fruit for sale. You can
    use these properties to help you keep track of everything:'
  id: totrans-8322
  prefs: []
  type: TYPE_NORMAL
  zh: 像数组一样，字典也有一个isEmpty属性和一个count属性。例如，下面的代码展示了如何使用isEmpty属性来检查字典是否为空，如果字典不为空，count属性会检查字典中有多少项。假设你有一个水果篮子在出售。你可以利用这些属性来帮助你记录一切：
- en: '![Image](Image00148.jpg)'
  id: totrans-8323
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00148.jpg)'
- en: 'A dictionary also has two special properties: keys , which contains all of
    the dictionary’s keys, and values , which contains all of its values. We’ll use
    these two properties when we loop through the dictionary.'
  id: totrans-8324
  prefs: []
  type: TYPE_NORMAL
  zh: 字典还有两个特殊属性：keys，包含字典的所有键；以及values，包含字典的所有值。我们在循环遍历字典时将使用这两个属性。
- en: Let’s write some code that loops through our fruit baskets and prints the price
    of each fruit.
  id: totrans-8325
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们编写一些代码，循环遍历我们的水果篮并打印每个水果的价格。
- en: '**LOOPING OVER A DICTIONARY**'
  id: totrans-8326
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**遍历字典**'
- en: 'You can loop through a dictionary using a for-in loop. Because each item has
    a key and a value, you can do this in two different ways. This is how to loop
    through a dictionary using its keys:'
  id: totrans-8327
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用 for-in 循环遍历字典。因为每个项目都有一个键和值，你可以通过两种不同的方式来实现这一点。以下是如何使用字典的键来遍历字典：
- en: '![Image](Image00149.jpg)'
  id: totrans-8328
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Image00149.jpg)'
- en: Here we use the dictionary’s keys property ➊ to loop through fruitBasket and
    print its contents. We start by writing the keyword for , followed by a constant
    name fruit for the dictionary key, the keyword in , the dictionary name, a period,
    and keys .
  id: totrans-8329
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们使用字典的 keys 属性 ➊ 来遍历 fruitBasket 并打印其内容。我们首先写下关键字 for，后跟常量名 fruit 作为字典的键，接着是关键字
    in，字典名称，句点和 keys。
- en: Inside the braces of our for-in loop, we have access to both the key, which
    we call fruit ➋ , and the value at that key when we force-unwrap its contents
    with fruitBasket[fruit]! ➌ . That value will be the fruit’s price.
  id: totrans-8330
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的 for-in 循环的大括号内部，我们可以访问键（我们称之为 fruit ➋）以及当我们强制解包其内容（通过 fruitBasket[fruit]!
    ➌）时该键对应的值。该值就是水果的价格。
- en: In this case, it’s safe to force-unwrap the value using an exclamation point
    because we know that the fruit key we’re using is definitely inside the dictionary.
  id: totrans-8331
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，使用感叹号强制解包值是安全的，因为我们知道我们使用的水果键肯定在字典中。
- en: Any code we put inside the for-in loop will run once for every key in our dictionary.
    So you should see the print statement display three times.
  id: totrans-8332
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在 for-in 循环中放入的任何代码都将对字典中的每个键执行一次。因此，你应该看到 print 语句被打印三次。
- en: 'We can also loop through the dictionary using its values property:'
  id: totrans-8333
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以使用字典的 values 属性遍历字典：
- en: '![Image](Image00150.jpg)'
  id: totrans-8334
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Image00150.jpg)'
- en: We use the same style of for-in loop, but now we use a constant to refer to
    each value, which we call price , in the values property. When looping through
    values, we don’t have access to the keys from inside the loop.
  id: totrans-8335
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用相同样式的 for-in 循环，但现在我们使用常量来引用每个值，我们称之为 price ，它在 values 属性中。当遍历 values 时，我们无法从循环内部访问键。
- en: Another difference to note is that price is not an optional because it’s accessed
    directly as a value in the fruitBasket dictionary. That means we don’t have to
    unwrap it. You should still see the print statement printed three times. [Figure
    6-6](text00016.html#ch06fig6) shows the output of both loops.
  id: totrans-8336
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个需要注意的区别是，price 不是一个可选值，因为它是直接作为 fruitBasket 字典中的值访问的。这意味着我们不需要解包它。你应该仍然能看到
    print 语句被打印三次。[图 6-6](text00016.html#ch06fig6) 显示了两个循环的输出结果。
- en: '![Image](Image00151.jpg)'
  id: totrans-8337
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Image00151.jpg)'
- en: '*Figure 6-6: Looping through the keys and values of a dictionary with a for-in
    loop*'
  id: totrans-8338
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 6-6：使用 for-in 循环遍历字典的键和值*'
- en: The order of your results might be slightly different from ours. That’s because
    the items in a dictionary aren’t in a numbered order like they are in an array!
    And because the order is not guaranteed, you might see a different order printed
    if you run the same code again.
  id: totrans-8339
  prefs: []
  type: TYPE_NORMAL
  zh: 你的结果顺序可能与我们的稍有不同。这是因为字典中的项不像数组那样按编号顺序排列！由于顺序不保证，如果你再次运行相同的代码，可能会看到不同的顺序被打印出来。
- en: '**WHAT YOU LEARNED**'
  id: totrans-8340
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**你学到了什么**'
- en: In this chapter, you learned how to store collections of items in an array and
    in a dictionary. To store items in an ordered list, you would use an array and
    look up each item by its index. If you wanted to store items by key instead, you
    would use a dictionary.
  id: totrans-8341
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你学习了如何将项目集合存储在数组和字典中。要存储有序列表中的项目，你会使用数组并通过索引查找每个项目。如果你想按键存储项目，则应使用字典。
- en: Knowing about arrays and dictionaries and how to use them is a powerful building
    block for almost any programming language. Next we will learn about functions,
    another very powerful tool. Functions are blocks of code that you create and name
    to perform a specific job. After you have written a function, you can use its
    name to call it from almost anywhere in your program.
  id: totrans-8342
  prefs: []
  type: TYPE_NORMAL
  zh: 了解数组和字典以及如何使用它们，是几乎所有编程语言中的一个强大的构建模块。接下来，我们将学习函数，另一个非常强大的工具。函数是你创建并命名的代码块，用来执行特定的任务。编写函数后，你可以通过它的名称从程序中的几乎任何地方调用它。
- en: In addition to methods like append(_:) and removeLast() , arrays also have *properties*
    . An array’s properties are variables or constants that contain some information
    about the array. Two really helpful properties that you might use are the Boolean
    property isEmpty and the integer property count .
  id: totrans-8343
  prefs: []
  type: TYPE_NORMAL
  zh: 除了像 append(_:) 和 removeLast() 这样的函数，数组还有*属性*。数组的属性是包含有关数组的一些信息的变量或常量。你可能会用到的两个非常有用的属性是布尔类型的
    isEmpty 属性和整数类型的 count 属性。
- en: The isEmpty property is true or false depending on whether the array is empty,
    and the count property will tell you how many items are in that array.
  id: totrans-8344
  prefs: []
  type: TYPE_NORMAL
  zh: isEmpty 属性根据数组是否为空返回 true 或 false，而 count 属性则告诉你数组中有多少个元素。
- en: 'Check out how these two properties are used in the following if-else statement:'
  id: totrans-8345
  prefs: []
  type: TYPE_NORMAL
  zh: 查看以下 if-else 语句中如何使用这两个属性：
- en: '![Image](Image00134.jpg)'
  id: totrans-8346
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00134.jpg)'
- en: 'This if-else statement checks whether the array mySiblings is empty ➊ . If
    it is, then "I don''t have any siblings." is printed. But if there is something
    in the array, then the number of siblings that we have is printed: "I have 3 siblings."
    ➋ .'
  id: totrans-8347
  prefs: []
  type: TYPE_NORMAL
  zh: 这个 if-else 语句检查数组 mySiblings 是否为空 ➊。如果为空，则打印 "我没有兄弟姐妹"。但如果数组中有内容，则打印我们拥有的兄弟姐妹数量：“我有
    3 个兄弟姐妹。” ➋。
- en: '**LOOPING OVER AN ARRAY**'
  id: totrans-8348
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**遍历数组**'
- en: 'Sometimes when you’re working with arrays you might want to do something to
    every item in the array. You can use a for-in loop to do that! The following code
    will print every topping in a pizzaToppings array on a separate line:'
  id: totrans-8349
  prefs: []
  type: TYPE_NORMAL
  zh: 有时候在处理数组时，你可能希望对数组中的每个元素做一些操作。你可以使用 for-in 循环来实现！以下代码将在一个 pizzaToppings 数组中逐行打印每种配料：
- en: '![Image](Image00135.jpg)'
  id: totrans-8350
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00135.jpg)'
- en: To write a for-in loop for the pizzaToppings array, we used the keyword for
    , followed by the constant topping , then the keyword in , and finally the name
    of our array, pizzaToppings . Then we put the statements that we want to run for
    each topping inside the braces of the for-in loop. The constant topping ➊ temporarily
    represents each pizza topping in the array as we loop through it. We could have
    chosen any name for this constant, but it’s a good idea to pick something that
    makes sense. You can see the output of this for-in loop in [Figure 6-4](text00016.html#ch06fig4)
    .
  id: totrans-8351
  prefs: []
  type: TYPE_NORMAL
  zh: 为了编写 pizzaToppings 数组的 for-in 循环，我们使用了关键字 for，后跟常量 topping，然后是关键字 in，最后是数组的名称
    pizzaToppings。接着我们将要对每个配料执行的语句放在 for-in 循环的大括号内。常量 topping ➊ 在我们遍历数组时，临时代表数组中的每个比萨配料。我们本可以为这个常量选择任何名字，但选择一个有意义的名字是个不错的主意。你可以在
    [图 6-4](text00016.html#ch06fig4) 中看到这个 for-in 循环的输出。
- en: '![Image](Image00136.jpg)'
  id: totrans-8352
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00136.jpg)'
- en: '*Figure 6-4: Output of the example for-in loop*'
  id: totrans-8353
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 6-4：示例 for-in 循环的输出*'
- en: '![Image](Image00137.jpg)'
  id: totrans-8354
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00137.jpg)'
- en: 'Using for-in loops is great for printing every value in an array. If you’re
    working with numbers, you can even use them to perform math operations on each
    item, which makes for some speedy calculations! The following code takes an array
    of numbers and calculates the square for each (the square of a number is that
    number multiplied by itself):'
  id: totrans-8355
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 for-in 循环非常适合打印数组中的每一个值。如果你正在处理数字，甚至可以用它们对每个元素进行数学运算，从而加快计算速度！以下代码接受一个数字数组，并计算每个数字的平方（一个数字的平方是这个数字与它本身的乘积）：
- en: '![Image](Image00138.jpg)'
  id: totrans-8356
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00138.jpg)'
- en: '[Figure 6-5](text00016.html#ch06fig5) shows the results.'
  id: totrans-8357
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 6-5](text00016.html#ch06fig5) 显示了结果。'
- en: '![Image](Image00139.jpg)'
  id: totrans-8358
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00139.jpg)'
- en: '*Figure 6-5: Printing the squares for each number in the myNumbers array*'
  id: totrans-8359
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 6-5：打印 myNumbers 数组中每个数字的平方*'
- en: '**DICTIONARIES ARE KEY!**'
  id: totrans-8360
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**字典是关键！**'
- en: A *dictionary* is also a collection of values, but instead of an ordered index,
    each value has its own *key* . Because there’s no index, the values are not stored
    in any particular order. To access values in a dictionary, you look them up by
    their key.
  id: totrans-8361
  prefs: []
  type: TYPE_NORMAL
  zh: '*字典* 也是一个值的集合，但不同于有序索引，每个值都有自己的*键*。因为没有索引，值并不会按特定顺序存储。要访问字典中的值，你需要通过键来查找它们。'
- en: A key must be unique. You can’t have the same key more than once in the same
    dictionary. If there were two identical keys and you asked the computer to give
    you the value for one of them, the computer wouldn’t know which one to choose!
  id: totrans-8362
  prefs: []
  type: TYPE_NORMAL
  zh: 键必须是唯一的。在同一个字典中不能有相同的键。如果有两个相同的键，并且你要求计算机返回其中一个的值，计算机就不知道该选择哪个！
- en: Let’s take a look at how to make a dictionary and write keys that will help
    you find all the information you need.
  id: totrans-8363
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看一下如何创建字典，并编写键来帮助你找到所有需要的信息。
- en: '![Image](Image00140.jpg)'
  id: totrans-8364
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00140.jpg)'
- en: '**INITIALIZING A DICTIONARY**'
  id: totrans-8365
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**初始化字典**'
- en: 'To create and initialize a dictionary, first write var and the name of your
    dictionary. Then write the keys and corresponding values inside a pair of square
    brackets, similar to an array. Let’s create a dictionary to store the names of
    a few US states. The key for each state will be its two-letter abbreviation:'
  id: totrans-8366
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建并初始化一个字典，首先写var和字典的名称。然后在一对方括号内写入键和对应的值，类似于数组的写法。让我们创建一个字典来存储几个美国州的名称。每个州的键将是它的两个字母缩写：
- en: '![](Image00141.jpg)'
  id: totrans-8367
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00141.jpg)'
- en: As you can see, there’s a colon between each key and its value, and the key/value
    pairs are separated by commas.
  id: totrans-8368
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，每个键和值之间有一个冒号，键值对之间用逗号分隔。
- en: Dictionaries are different from arrays in that they are *unordered* . Because
    of that, it’s likely that the order of the states that you see in your results
    pane ➋ is different from the order in which you entered your states ➊ . It might
    even be different than the order that’s printed in this book!
  id: totrans-8369
  prefs: []
  type: TYPE_NORMAL
  zh: 字典与数组的不同之处在于它们是*无序的*。因此，你在结果面板➋中看到的州的顺序可能与你输入州的顺序➊不同，甚至可能和本书中打印的顺序不同！
- en: As with arrays, you can use var to make a mutable dictionary or use let to make
    an immutable dictionary.
  id: totrans-8370
  prefs: []
  type: TYPE_NORMAL
  zh: 和数组一样，你可以使用var来创建可变字典，或者使用let来创建不可变字典。
- en: 'In Swift, all of the keys of a dictionary must be the same type, and all of
    the values of a dictionary must also be the same type, but the key type doesn’t
    have to match the value type. For example, if you wanted to store a collection
    of fractions, you could use doubles for the keys and strings for the values:'
  id: totrans-8371
  prefs: []
  type: TYPE_NORMAL
  zh: 在Swift中，字典的所有键必须是相同类型的，字典的所有值也必须是相同类型的，但键的类型不需要与值的类型相同。例如，如果你想存储一组分数，你可以使用双精度浮点数作为键，字符串作为值：
- en: '![](Image00142.jpg)'
  id: totrans-8372
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00142.jpg)'
- en: In this dictionary, all of the keys must be doubles, and all of the values must
    be strings. Again, you’ll see that the order of the numbers in the results pane
    can be quite different from the order in which you wrote the fractions in your
    dictionary. This is fine because you don’t need to know the order to access anything.
    You can find any item that you need by its key. Let’s see how!
  id: totrans-8373
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个字典中，所有的键必须是双精度浮点数，而所有的值必须是字符串。同样，你会看到结果面板中的数字顺序可能与你在字典中写入分数的顺序大不相同。这是可以接受的，因为你无需知道顺序就能访问任何项。你可以通过键找到你需要的任何项。让我们来看一下！
- en: '**ACCESSING VALUES IN A DICTIONARY**'
  id: totrans-8374
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**在字典中访问值**'
- en: 'Looking up a value in a dictionary is similar to how you access a value in
    an array except that you use a key inside the square brackets instead of an index,
    like this: usStates["TX"] .'
  id: totrans-8375
  prefs: []
  type: TYPE_NORMAL
  zh: 在字典中查找一个值类似于你在数组中访问值的方式，只不过你在方括号内使用的是键而不是索引，例如这样：usStates["TX"]。
- en: There is a big difference, however, in how Swift returns the values from a dictionary.
    When you access a value at an index of an array, you are simply given the value.
    When you access a value with a key in a dictionary, you are given an optional.
  id: totrans-8376
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在Swift中访问字典中的值有一个显著的区别。当你通过数组的索引访问一个值时，你会直接得到值。而当你通过字典的键访问一个值时，你得到的是一个可选值。
- en: In [Chapter 5](text00015.html#ch05) , you learned that optionals might contain
    a value or might be nil . The reason Swift returns optionals when you’re looking
    up items in a dictionary is that the key you used might not exist in the dictionary,
    in which case there’s no value to access. Trying to access a value that doesn’t
    exist would give you a big fat error! To avoid that problem, Swift returns optionals.
    That means you need to unwrap any value you get out of a dictionary before you
    can do anything with it.
  id: totrans-8377
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第5章](text00015.html#ch05)中，你学到了可选值可能包含一个值，也可能是nil。Swift在你查找字典中的项时返回可选值，是因为你使用的键可能在字典中不存在，在这种情况下，就没有值可以访问。尝试访问一个不存在的值会导致一个大错误！为了避免这个问题，Swift返回可选值。这意味着在你对从字典中获取的值进行任何操作之前，你需要先解包它。
- en: 'To unwrap an optional, first you check whether it exists using an if-let statement,
    just like we did in [Chapter 5](text00015.html#ch05) . The following code shows
    you how to get a value out of a dictionary:'
  id: totrans-8378
  prefs: []
  type: TYPE_NORMAL
  zh: 要解包一个可选值，首先使用if-let语句检查它是否存在，就像我们在[第5章](text00015.html#ch05)中做的那样。以下代码展示了如何从字典中获取一个值：
- en: '![Image](Image00143.jpg)'
  id: totrans-8379
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00143.jpg)'
- en: To retrieve "Texas" from the dictionary, we use if let to set a constant loneStarState
    to usStates["TX"] ➊ . Because we have this state in our dictionary, the line I
    have Texas in my dictionary. is printed. Next we try to access a state that is
    not in our dictionary by using the key usStates["FL"] ➋ . Thankfully, because
    we used an if-let statement, the program won’t crash when the computer can’t find
    this state. Instead, I don't have that state in my dictionary. is printed.
  id: totrans-8380
  prefs: []
  type: TYPE_NORMAL
  zh: 要从字典中检索“Texas”，我们使用if let将常量loneStarState设置为usStates["TX"] ➊。因为我们在字典中有这个州，所以会打印出"I
    have Texas in my dictionary"。接下来，我们尝试使用键usStates["FL"] ➋访问一个不在字典中的州。幸运的是，由于我们使用了if-let语句，当计算机找不到这个州时，程序不会崩溃。相反，打印出"I
    don't have that state in my dictionary"。
- en: '**ADDING ITEMS TO A DICTIONARY**'
  id: totrans-8381
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**向字典添加项**'
- en: 'To add an item to a dictionary, first write the name of your dictionary and
    assign the new item to the key you want it to have in the dictionary. Let’s add
    "Minnesota" to our usStates dictionary:'
  id: totrans-8382
  prefs: []
  type: TYPE_NORMAL
  zh: 要向字典中添加一个项，首先写出字典的名称，并将新项分配给你希望它在字典中具有的键。让我们把“Minnesota”添加到我们的usStates字典中：
- en: '![](Image00144.jpg)'
  id: totrans-8383
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00144.jpg)'
- en: 'Now when you look at usStates , you’ll see that it’s updated to ["MN": "Minnesota",
    "WA": "Washington", "MA": "Massachusetts", "TX": "Texas"] . Remember, because
    you don’t have to rely on indices, your new dictionary item might appear anywhere
    in the dictionary.'
  id: totrans-8384
  prefs: []
  type: TYPE_NORMAL
  zh: '现在，当你查看usStates时，你会看到它已更新为["MN": "Minnesota", "WA": "Washington", "MA": "Massachusetts",
    "TX": "Texas"]。记住，由于你不需要依赖索引，新的字典项可能出现在字典中的任何位置。'
- en: '**REMOVING ITEMS FROM A DICTIONARY**'
  id: totrans-8385
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**从字典中删除项**'
- en: Removing an item from a dictionary is quite simple; you do so by setting the
    value to nil . Because the values in dictionaries are returned as optionals, you
    don’t have to worry about nil causing any problems in your dictionary.
  id: totrans-8386
  prefs: []
  type: TYPE_NORMAL
  zh: 从字典中删除项是非常简单的；你只需将值设置为nil。由于字典中的值作为可选项返回，因此你不必担心nil会在字典中引起任何问题。
- en: '![](Image00145.jpg)'
  id: totrans-8387
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00145.jpg)'
- en: 'You can see that after you remove the value at the key "MA" , usStates is updated
    to ["MN": "Minnesota", "WA": "Washington", "TX": "Texas"] . Remember that nil
    is special and means that there’s no value at all. That’s why you don’t see "MA":
    nil in our dictionary.'
  id: totrans-8388
  prefs: []
  type: TYPE_NORMAL
  zh: '你可以看到，在删除键"MA"对应的值后，usStates已更新为["MN": "Minnesota", "WA": "Washington", "TX":
    "Texas"]。记住，nil是特殊的，表示没有任何值。这就是为什么你在字典中看不到"MA": nil。'
- en: '**REPLACING ITEMS IN A DICTIONARY**'
  id: totrans-8389
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**替换字典中的项**'
- en: 'Replacing an item in a dictionary is also easy. It works the same was as replacing
    an item in an array. You just set the item that you want to replace to something
    else. Say you create a dictionary of fruit colors:'
  id: totrans-8390
  prefs: []
  type: TYPE_NORMAL
  zh: 替换字典中的项也很简单。它的工作原理与替换数组中的项相同。你只需将你想替换的项设置为其他内容。假设你创建了一个水果颜色字典：
- en: '![](Image00146.jpg)'
  id: totrans-8391
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00146.jpg)'
- en: At first we had the value "apple" for "red" , but then we decided that "raspberry"
    is a better fruit to use since sometimes apples are green or yellow. To replace
    "apple" with "raspberry" , we set colorFruits["red"] to its new value ➊ .
  id: totrans-8392
  prefs: []
  type: TYPE_NORMAL
  zh: 起初我们为"red"赋值"apple"，但后来我们决定“raspberry”是更好的水果，因为有时候苹果是绿色或黄色的。要将"apple"替换为"raspberry"，我们将colorFruits["red"]设置为它的新值
    ➊。
- en: You may remember that this is the same way we entered a new value into a dictionary.
    If the key already exists in the dictionary, then the value for that key is replaced.
    If the key doesn’t already exist, then the new key/value pair will be added to
    the dictionary.
  id: totrans-8393
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能还记得，这与我们向字典中输入新值的方式相同。如果键已经存在于字典中，那么该键的值将被替换。如果键不存在，则新的键/值对将被添加到字典中。
- en: '![Image](Image00147.jpg)'
  id: totrans-8394
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00147.jpg)'
- en: '**USING DICTIONARY PROPERTIES**'
  id: totrans-8395
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**使用字典属性**'
- en: 'Like an array, a dictionary also has an isEmpty property and a count property.
    For example, the following code shows how you can use the isEmpty property to
    check if a dictionary is empty, and if it isn’t empty, the count property checks
    how many items you have. Imagine you have a basket of fruit for sale. You can
    use these properties to help you keep track of everything:'
  id: totrans-8396
  prefs: []
  type: TYPE_NORMAL
  zh: 像数组一样，字典也有isEmpty属性和count属性。例如，以下代码展示了如何使用isEmpty属性检查字典是否为空，如果不为空，count属性则检查你有多少个项。假设你有一个水果篮子要出售。你可以使用这些属性帮助你跟踪所有物品：
- en: '![Image](Image00148.jpg)'
  id: totrans-8397
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00148.jpg)'
- en: 'A dictionary also has two special properties: keys , which contains all of
    the dictionary’s keys, and values , which contains all of its values. We’ll use
    these two properties when we loop through the dictionary.'
  id: totrans-8398
  prefs: []
  type: TYPE_NORMAL
  zh: 字典还有两个特殊属性：keys，包含字典的所有键，以及values，包含字典的所有值。我们在遍历字典时会使用这两个属性。
- en: Let’s write some code that loops through our fruit baskets and prints the price
    of each fruit.
  id: totrans-8399
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们写一些代码，遍历我们的水果篮并打印每个水果的价格。
- en: '**LOOPING OVER A DICTIONARY**'
  id: totrans-8400
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**遍历字典**'
- en: 'You can loop through a dictionary using a for-in loop. Because each item has
    a key and a value, you can do this in two different ways. This is how to loop
    through a dictionary using its keys:'
  id: totrans-8401
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用`for-in`循环遍历字典。因为每个项都有一个键和值，所以你可以用两种不同的方式来进行遍历。这是通过键遍历字典的方法：
- en: '![Image](Image00149.jpg)'
  id: totrans-8402
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00149.jpg)'
- en: Here we use the dictionary’s keys property ➊ to loop through fruitBasket and
    print its contents. We start by writing the keyword for , followed by a constant
    name fruit for the dictionary key, the keyword in , the dictionary name, a period,
    and keys .
  id: totrans-8403
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们使用字典的`keys`属性 ➊ 来遍历`fruitBasket`并打印其内容。我们首先写下关键字`for`，然后是常量名`fruit`（字典的键），接着是关键字`in`，字典名，接着是一个句点，再加上`keys`。
- en: Inside the braces of our for-in loop, we have access to both the key, which
    we call fruit ➋ , and the value at that key when we force-unwrap its contents
    with fruitBasket[fruit]! ➌ . That value will be the fruit’s price.
  id: totrans-8404
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的`for-in`循环的大括号内，我们可以访问到键（我们称之为fruit ➋）以及通过`fruitBasket[fruit]!`强制解包其内容时得到的键对应的值
    ➌。这个值就是水果的价格。
- en: In this case, it’s safe to force-unwrap the value using an exclamation point
    because we know that the fruit key we’re using is definitely inside the dictionary.
  id: totrans-8405
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，使用感叹号强制解包是安全的，因为我们知道正在使用的水果键肯定存在于字典中。
- en: Any code we put inside the for-in loop will run once for every key in our dictionary.
    So you should see the print statement display three times.
  id: totrans-8406
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在`for-in`循环内放置的任何代码都会在字典的每个键上执行一次。所以你应该看到打印语句会打印三次。
- en: 'We can also loop through the dictionary using its values property:'
  id: totrans-8407
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以通过字典的`values`属性来遍历字典：
- en: '![Image](Image00150.jpg)'
  id: totrans-8408
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00150.jpg)'
- en: We use the same style of for-in loop, but now we use a constant to refer to
    each value, which we call price , in the values property. When looping through
    values, we don’t have access to the keys from inside the loop.
  id: totrans-8409
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用相同类型的`for-in`循环，但现在我们使用常量来引用每个值，这个常量我们称之为`price`，并使用`values`属性。当遍历值时，我们不能从循环内部访问到键。
- en: Another difference to note is that price is not an optional because it’s accessed
    directly as a value in the fruitBasket dictionary. That means we don’t have to
    unwrap it. You should still see the print statement printed three times. [Figure
    6-6](text00016.html#ch06fig6) shows the output of both loops.
  id: totrans-8410
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个需要注意的区别是，`price`不是可选的，因为它是直接作为字典`fruitBasket`中的值访问的。这意味着我们不需要解包它。你仍然应该看到打印语句会打印三次。[图6-6](text00016.html#ch06fig6)显示了两个循环的输出。
- en: '![Image](Image00151.jpg)'
  id: totrans-8411
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00151.jpg)'
- en: '*Figure 6-6: Looping through the keys and values of a dictionary with a for-in
    loop*'
  id: totrans-8412
  prefs: []
  type: TYPE_NORMAL
  zh: '*图6-6：使用`for-in`循环遍历字典的键和值*'
- en: The order of your results might be slightly different from ours. That’s because
    the items in a dictionary aren’t in a numbered order like they are in an array!
    And because the order is not guaranteed, you might see a different order printed
    if you run the same code again.
  id: totrans-8413
  prefs: []
  type: TYPE_NORMAL
  zh: 你的结果顺序可能与我们的略有不同。这是因为字典中的项不像数组那样按顺序排列！由于顺序没有保证，因此如果再次运行相同的代码，你可能会看到不同的顺序输出。
- en: '**WHAT YOU LEARNED**'
  id: totrans-8414
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**你学到了什么**'
- en: In this chapter, you learned how to store collections of items in an array and
    in a dictionary. To store items in an ordered list, you would use an array and
    look up each item by its index. If you wanted to store items by key instead, you
    would use a dictionary.
  id: totrans-8415
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你学习了如何将项存储在数组和字典中。为了将项存储在有序列表中，你会使用数组并通过索引查找每个项。如果你想按键存储项，则会使用字典。
- en: Knowing about arrays and dictionaries and how to use them is a powerful building
    block for almost any programming language. Next we will learn about functions,
    another very powerful tool. Functions are blocks of code that you create and name
    to perform a specific job. After you have written a function, you can use its
    name to call it from almost anywhere in your program.
  id: totrans-8416
  prefs: []
  type: TYPE_NORMAL
  zh: 了解数组和字典及其使用方法是几乎所有编程语言中的一个强大基础。接下来，我们将学习函数，这是另一种非常强大的工具。函数是你创建并命名的代码块，用于执行特定的任务。写完函数后，你可以在程序的几乎任何地方通过其名称调用它。
- en: The isEmpty property is true or false depending on whether the array is empty,
    and the count property will tell you how many items are in that array.
  id: totrans-8417
  prefs: []
  type: TYPE_NORMAL
  zh: '`isEmpty`属性根据数组是否为空返回`true`或`false`，而`count`属性则会告诉你数组中有多少项。'
- en: 'Check out how these two properties are used in the following if-else statement:'
  id: totrans-8418
  prefs: []
  type: TYPE_NORMAL
  zh: 查看以下if-else语句中如何使用这两个属性：
- en: '![Image](Image00134.jpg)'
  id: totrans-8419
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00134.jpg)'
- en: 'This if-else statement checks whether the array mySiblings is empty ➊ . If
    it is, then "I don''t have any siblings." is printed. But if there is something
    in the array, then the number of siblings that we have is printed: "I have 3 siblings."
    ➋ .'
  id: totrans-8420
  prefs: []
  type: TYPE_NORMAL
  zh: 这个if-else语句检查数组mySiblings是否为空➊。如果为空，那么会打印“我没有兄弟姐妹。”。但如果数组中有元素，则会打印我们有多少兄弟姐妹：“我有3个兄弟姐妹。”➋。
- en: '**LOOPING OVER AN ARRAY**'
  id: totrans-8421
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**遍历数组**'
- en: 'Sometimes when you’re working with arrays you might want to do something to
    every item in the array. You can use a for-in loop to do that! The following code
    will print every topping in a pizzaToppings array on a separate line:'
  id: totrans-8422
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，当你处理数组时，可能想对数组中的每个元素做一些操作。你可以使用for-in循环来做到这一点！以下代码会将pizzaToppings数组中的每个配料打印在单独的一行：
- en: '![Image](Image00135.jpg)'
  id: totrans-8423
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00135.jpg)'
- en: To write a for-in loop for the pizzaToppings array, we used the keyword for
    , followed by the constant topping , then the keyword in , and finally the name
    of our array, pizzaToppings . Then we put the statements that we want to run for
    each topping inside the braces of the for-in loop. The constant topping ➊ temporarily
    represents each pizza topping in the array as we loop through it. We could have
    chosen any name for this constant, but it’s a good idea to pick something that
    makes sense. You can see the output of this for-in loop in [Figure 6-4](text00016.html#ch06fig4)
    .
  id: totrans-8424
  prefs: []
  type: TYPE_NORMAL
  zh: 为了为pizzaToppings数组编写for-in循环，我们使用了关键字`for`，后面跟着常量`topping`，然后是关键字`in`，最后是我们数组的名称pizzaToppings。接着，我们将每个配料的处理语句放在for-in循环的花括号内。常量`topping`➊在我们循环时临时代表数组中的每个披萨配料。我们可以为这个常量选择任何名字，但最好选一个有意义的名字。你可以在[图6-4](text00016.html#ch06fig4)中看到这个for-in循环的输出。
- en: '![Image](Image00136.jpg)'
  id: totrans-8425
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00136.jpg)'
- en: '*Figure 6-4: Output of the example for-in loop*'
  id: totrans-8426
  prefs: []
  type: TYPE_NORMAL
  zh: '*图6-4：示例for-in循环的输出*'
- en: '![Image](Image00137.jpg)'
  id: totrans-8427
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00137.jpg)'
- en: 'Using for-in loops is great for printing every value in an array. If you’re
    working with numbers, you can even use them to perform math operations on each
    item, which makes for some speedy calculations! The following code takes an array
    of numbers and calculates the square for each (the square of a number is that
    number multiplied by itself):'
  id: totrans-8428
  prefs: []
  type: TYPE_NORMAL
  zh: 使用for-in循环非常适合打印数组中的每个值。如果你在处理数字，甚至可以用它们对每个项目进行数学运算，这样可以快速进行计算！以下代码会取一个数字数组，并计算每个数字的平方（数字的平方是该数字乘以它自己）：
- en: '![Image](Image00138.jpg)'
  id: totrans-8429
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00138.jpg)'
- en: '[Figure 6-5](text00016.html#ch06fig5) shows the results.'
  id: totrans-8430
  prefs: []
  type: TYPE_NORMAL
  zh: '[图6-5](text00016.html#ch06fig5)展示了结果。'
- en: '![Image](Image00139.jpg)'
  id: totrans-8431
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00139.jpg)'
- en: '*Figure 6-5: Printing the squares for each number in the myNumbers array*'
  id: totrans-8432
  prefs: []
  type: TYPE_NORMAL
  zh: '*图6-5：打印myNumbers数组中每个数字的平方*'
- en: '**DICTIONARIES ARE KEY!**'
  id: totrans-8433
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**字典至关重要！**'
- en: A *dictionary* is also a collection of values, but instead of an ordered index,
    each value has its own *key* . Because there’s no index, the values are not stored
    in any particular order. To access values in a dictionary, you look them up by
    their key.
  id: totrans-8434
  prefs: []
  type: TYPE_NORMAL
  zh: '*字典*也是一组值的集合，但与有序索引不同，每个值都有其独特的*键*。由于没有索引，值并不以任何特定顺序存储。要访问字典中的值，您需要通过它们的键进行查找。'
- en: A key must be unique. You can’t have the same key more than once in the same
    dictionary. If there were two identical keys and you asked the computer to give
    you the value for one of them, the computer wouldn’t know which one to choose!
  id: totrans-8435
  prefs: []
  type: TYPE_NORMAL
  zh: 键必须是唯一的。在同一个字典中，你不能有重复的键。如果有两个相同的键，且你要求计算机提供其中一个的值，计算机将无法选择使用哪个！
- en: Let’s take a look at how to make a dictionary and write keys that will help
    you find all the information you need.
  id: totrans-8436
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看如何创建一个字典，并编写键，以帮助你找到所需的所有信息。
- en: '![Image](Image00140.jpg)'
  id: totrans-8437
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00140.jpg)'
- en: '**INITIALIZING A DICTIONARY**'
  id: totrans-8438
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**初始化字典**'
- en: 'To create and initialize a dictionary, first write var and the name of your
    dictionary. Then write the keys and corresponding values inside a pair of square
    brackets, similar to an array. Let’s create a dictionary to store the names of
    a few US states. The key for each state will be its two-letter abbreviation:'
  id: totrans-8439
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建并初始化字典，首先写上`var`和字典的名称。然后在一对方括号内写下键和对应的值，类似于数组的写法。让我们创建一个字典来存储一些美国州的名字。每个州的键将是它的两位字母缩写：
- en: '![](Image00141.jpg)'
  id: totrans-8440
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00141.jpg)'
- en: As you can see, there’s a colon between each key and its value, and the key/value
    pairs are separated by commas.
  id: totrans-8441
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，键和值之间有一个冒号，键/值对之间用逗号分隔。
- en: Dictionaries are different from arrays in that they are *unordered* . Because
    of that, it’s likely that the order of the states that you see in your results
    pane ➋ is different from the order in which you entered your states ➊ . It might
    even be different than the order that’s printed in this book!
  id: totrans-8442
  prefs: []
  type: TYPE_NORMAL
  zh: 字典与数组的不同之处在于它们是*无序的*。因此，你在结果面板中看到的州的顺序 ➋ 很可能与输入字典时州的顺序 ➊ 不同。它甚至可能与本书中打印出来的顺序不同！
- en: As with arrays, you can use var to make a mutable dictionary or use let to make
    an immutable dictionary.
  id: totrans-8443
  prefs: []
  type: TYPE_NORMAL
  zh: 与数组一样，你可以使用var来创建一个可变字典，或者使用let来创建一个不可变字典。
- en: 'In Swift, all of the keys of a dictionary must be the same type, and all of
    the values of a dictionary must also be the same type, but the key type doesn’t
    have to match the value type. For example, if you wanted to store a collection
    of fractions, you could use doubles for the keys and strings for the values:'
  id: totrans-8444
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Swift 中，字典的所有键必须是相同的类型，字典的所有值也必须是相同的类型，但键的类型不需要与值的类型匹配。例如，如果你想存储一组分数，你可以使用双精度浮点数（doubles）作为键，使用字符串（strings）作为值：
- en: '![](Image00142.jpg)'
  id: totrans-8445
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00142.jpg)'
- en: In this dictionary, all of the keys must be doubles, and all of the values must
    be strings. Again, you’ll see that the order of the numbers in the results pane
    can be quite different from the order in which you wrote the fractions in your
    dictionary. This is fine because you don’t need to know the order to access anything.
    You can find any item that you need by its key. Let’s see how!
  id: totrans-8446
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个字典中，所有的键都必须是双精度浮点数（doubles），而所有的值都必须是字符串（strings）。你会发现，结果面板中数字的顺序可能与在字典中输入分数的顺序大不相同。这是可以接受的，因为你不需要知道顺序就能访问任何内容。你可以通过键找到你需要的任何项目。我们来看一下是如何操作的！
- en: '**ACCESSING VALUES IN A DICTIONARY**'
  id: totrans-8447
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**访问字典中的值**'
- en: 'Looking up a value in a dictionary is similar to how you access a value in
    an array except that you use a key inside the square brackets instead of an index,
    like this: usStates["TX"] .'
  id: totrans-8448
  prefs: []
  type: TYPE_NORMAL
  zh: 查找字典中的值类似于你在数组中访问值的方式，只不过你在方括号中使用的是键，而不是索引，如：usStates["TX"]。
- en: There is a big difference, however, in how Swift returns the values from a dictionary.
    When you access a value at an index of an array, you are simply given the value.
    When you access a value with a key in a dictionary, you are given an optional.
  id: totrans-8449
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，Swift 在从字典返回值的方式上有很大不同。当你访问数组中的某个索引时，你会直接得到该值。而当你通过字典中的键访问值时，你得到的是一个可选值。
- en: In [Chapter 5](text00015.html#ch05) , you learned that optionals might contain
    a value or might be nil . The reason Swift returns optionals when you’re looking
    up items in a dictionary is that the key you used might not exist in the dictionary,
    in which case there’s no value to access. Trying to access a value that doesn’t
    exist would give you a big fat error! To avoid that problem, Swift returns optionals.
    That means you need to unwrap any value you get out of a dictionary before you
    can do anything with it.
  id: totrans-8450
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第5章](text00015.html#ch05)中，你学习了可选值可能包含一个值，也可能是nil。Swift 在查找字典中的项目时返回可选值的原因是，使用的键可能在字典中不存在，这种情况下就没有值可以访问。尝试访问一个不存在的值会导致一个大的错误！为了避免这个问题，Swift
    返回可选值。这意味着你需要在对字典中取出的值进行任何操作之前先将其解包。
- en: 'To unwrap an optional, first you check whether it exists using an if-let statement,
    just like we did in [Chapter 5](text00015.html#ch05) . The following code shows
    you how to get a value out of a dictionary:'
  id: totrans-8451
  prefs: []
  type: TYPE_NORMAL
  zh: 要解包一个可选值，首先你需要使用if-let语句检查它是否存在，就像我们在[第5章](text00015.html#ch05)中所做的那样。以下代码展示了如何从字典中获取一个值：
- en: '![Image](Image00143.jpg)'
  id: totrans-8452
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00143.jpg)'
- en: To retrieve "Texas" from the dictionary, we use if let to set a constant loneStarState
    to usStates["TX"] ➊ . Because we have this state in our dictionary, the line I
    have Texas in my dictionary. is printed. Next we try to access a state that is
    not in our dictionary by using the key usStates["FL"] ➋ . Thankfully, because
    we used an if-let statement, the program won’t crash when the computer can’t find
    this state. Instead, I don't have that state in my dictionary. is printed.
  id: totrans-8453
  prefs: []
  type: TYPE_NORMAL
  zh: 为了从字典中检索“Texas”，我们使用if let将常量loneStarState设置为usStates["TX"] ➊。因为字典中有这个州，"我在字典中有Texas"这一行会被打印出来。接下来，我们尝试访问一个字典中没有的州，通过使用键usStates["FL"]
    ➋。幸运的是，因为我们使用了if-let语句，当计算机找不到这个州时，程序不会崩溃。相反，"我在字典中没有这个州"会被打印出来。
- en: '**ADDING ITEMS TO A DICTIONARY**'
  id: totrans-8454
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**向字典添加项目**'
- en: 'To add an item to a dictionary, first write the name of your dictionary and
    assign the new item to the key you want it to have in the dictionary. Let’s add
    "Minnesota" to our usStates dictionary:'
  id: totrans-8455
  prefs: []
  type: TYPE_NORMAL
  zh: 要向字典中添加项，首先写出字典的名称，并将新项赋值给你希望它在字典中对应的键。我们来给我们的 usStates 字典添加 "Minnesota"：
- en: '![](Image00144.jpg)'
  id: totrans-8456
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00144.jpg)'
- en: 'Now when you look at usStates , you’ll see that it’s updated to ["MN": "Minnesota",
    "WA": "Washington", "MA": "Massachusetts", "TX": "Texas"] . Remember, because
    you don’t have to rely on indices, your new dictionary item might appear anywhere
    in the dictionary.'
  id: totrans-8457
  prefs: []
  type: TYPE_NORMAL
  zh: '现在，当你查看 usStates 时，你会看到它被更新为 ["MN": "Minnesota", "WA": "Washington", "MA":
    "Massachusetts", "TX": "Texas"]。记住，因为你不需要依赖索引，你的新字典项可能会出现在字典的任何位置。'
- en: '**REMOVING ITEMS FROM A DICTIONARY**'
  id: totrans-8458
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**从字典中移除项**'
- en: Removing an item from a dictionary is quite simple; you do so by setting the
    value to nil . Because the values in dictionaries are returned as optionals, you
    don’t have to worry about nil causing any problems in your dictionary.
  id: totrans-8459
  prefs: []
  type: TYPE_NORMAL
  zh: 从字典中移除一项非常简单；你只需将该项的值设置为 nil。由于字典中的值是以可选项的形式返回的，所以你不需要担心 nil 会在字典中引发任何问题。
- en: '![](Image00145.jpg)'
  id: totrans-8460
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00145.jpg)'
- en: 'You can see that after you remove the value at the key "MA" , usStates is updated
    to ["MN": "Minnesota", "WA": "Washington", "TX": "Texas"] . Remember that nil
    is special and means that there’s no value at all. That’s why you don’t see "MA":
    nil in our dictionary.'
  id: totrans-8461
  prefs: []
  type: TYPE_NORMAL
  zh: '你可以看到，在你移除键 "MA" 的值之后，usStates 被更新为 ["MN": "Minnesota", "WA": "Washington",
    "TX": "Texas"]。记住，nil 是特殊的，意味着没有值。因此，你不会在字典中看到 "MA": nil。'
- en: '**REPLACING ITEMS IN A DICTIONARY**'
  id: totrans-8462
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**替换字典中的项**'
- en: 'Replacing an item in a dictionary is also easy. It works the same was as replacing
    an item in an array. You just set the item that you want to replace to something
    else. Say you create a dictionary of fruit colors:'
  id: totrans-8463
  prefs: []
  type: TYPE_NORMAL
  zh: 替换字典中的项也很简单。它的操作方式与替换数组中的项相同。你只需将你想替换的项设为其他值。比如你创建了一个水果颜色的字典：
- en: '![](Image00146.jpg)'
  id: totrans-8464
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00146.jpg)'
- en: At first we had the value "apple" for "red" , but then we decided that "raspberry"
    is a better fruit to use since sometimes apples are green or yellow. To replace
    "apple" with "raspberry" , we set colorFruits["red"] to its new value ➊ .
  id: totrans-8465
  prefs: []
  type: TYPE_NORMAL
  zh: 一开始我们将 "red" 的值设为 "apple"，但是后来我们决定用 "raspberry" 代替，因为有时候苹果是绿色或黄色的。所以为了将 "apple"
    替换成 "raspberry"，我们将 colorFruits["red"] 设置为它的新值 ➊。
- en: You may remember that this is the same way we entered a new value into a dictionary.
    If the key already exists in the dictionary, then the value for that key is replaced.
    If the key doesn’t already exist, then the new key/value pair will be added to
    the dictionary.
  id: totrans-8466
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能记得，这与我们向字典中输入新值的方式是相同的。如果键已经存在于字典中，那么该键的值将被替换。如果键不存在，那么新的键/值对将会被添加到字典中。
- en: '![Image](Image00147.jpg)'
  id: totrans-8467
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00147.jpg)'
- en: '**USING DICTIONARY PROPERTIES**'
  id: totrans-8468
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**使用字典属性**'
- en: 'Like an array, a dictionary also has an isEmpty property and a count property.
    For example, the following code shows how you can use the isEmpty property to
    check if a dictionary is empty, and if it isn’t empty, the count property checks
    how many items you have. Imagine you have a basket of fruit for sale. You can
    use these properties to help you keep track of everything:'
  id: totrans-8469
  prefs: []
  type: TYPE_NORMAL
  zh: 像数组一样，字典也有 isEmpty 属性和 count 属性。例如，下面的代码展示了如何使用 isEmpty 属性来检查字典是否为空，如果不为空，count
    属性则可以检查你有多少个项。假设你有一个出售的水果篮子，你可以使用这些属性帮助你跟踪所有内容：
- en: '![Image](Image00148.jpg)'
  id: totrans-8470
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00148.jpg)'
- en: 'A dictionary also has two special properties: keys , which contains all of
    the dictionary’s keys, and values , which contains all of its values. We’ll use
    these two properties when we loop through the dictionary.'
  id: totrans-8471
  prefs: []
  type: TYPE_NORMAL
  zh: 字典还有两个特殊的属性：keys，包含字典的所有键，和 values，包含字典的所有值。在我们遍历字典时，将会使用这两个属性。
- en: Let’s write some code that loops through our fruit baskets and prints the price
    of each fruit.
  id: totrans-8472
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们编写一些代码，遍历我们的水果篮子，并打印每种水果的价格。
- en: '**LOOPING OVER A DICTIONARY**'
  id: totrans-8473
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**遍历字典**'
- en: 'You can loop through a dictionary using a for-in loop. Because each item has
    a key and a value, you can do this in two different ways. This is how to loop
    through a dictionary using its keys:'
  id: totrans-8474
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用 for-in 循环遍历字典。因为每一项都有一个键和值，你可以用两种不同的方式来做这件事。这是使用字典的键来遍历字典的方法：
- en: '![Image](Image00149.jpg)'
  id: totrans-8475
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00149.jpg)'
- en: Here we use the dictionary’s keys property ➊ to loop through fruitBasket and
    print its contents. We start by writing the keyword for , followed by a constant
    name fruit for the dictionary key, the keyword in , the dictionary name, a period,
    and keys .
  id: totrans-8476
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们使用字典的 keys 属性 ➊ 来遍历 fruitBasket 并打印其内容。我们首先写下关键字 for，然后是常量名 fruit 作为字典的键，再加上关键字
    in、字典名称、一个句点和 keys。
- en: Inside the braces of our for-in loop, we have access to both the key, which
    we call fruit ➋ , and the value at that key when we force-unwrap its contents
    with fruitBasket[fruit]! ➌ . That value will be the fruit’s price.
  id: totrans-8477
  prefs: []
  type: TYPE_NORMAL
  zh: 在 for-in 循环的大括号内，我们可以访问到键，我们称之为 fruit ➋，以及该键对应的值，当我们通过 fruitBasket[fruit]! 强制解包其内容时
    ➌。该值将是水果的价格。
- en: In this case, it’s safe to force-unwrap the value using an exclamation point
    because we know that the fruit key we’re using is definitely inside the dictionary.
  id: totrans-8478
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，使用感叹号强制解包值是安全的，因为我们知道正在使用的水果键肯定在字典中。
- en: Any code we put inside the for-in loop will run once for every key in our dictionary.
    So you should see the print statement display three times.
  id: totrans-8479
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在 for-in 循环中放入的任何代码都会对字典中的每个键执行一次。所以你应该能看到打印语句显示三次。
- en: 'We can also loop through the dictionary using its values property:'
  id: totrans-8480
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以使用字典的 values 属性来遍历字典：
- en: '![Image](Image00150.jpg)'
  id: totrans-8481
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Image00150.jpg)'
- en: We use the same style of for-in loop, but now we use a constant to refer to
    each value, which we call price , in the values property. When looping through
    values, we don’t have access to the keys from inside the loop.
  id: totrans-8482
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用相同的 for-in 循环样式，但现在我们使用常量来引用每个值，称之为 price，这个值来自 values 属性。当循环遍历值时，我们无法在循环内访问键。
- en: Another difference to note is that price is not an optional because it’s accessed
    directly as a value in the fruitBasket dictionary. That means we don’t have to
    unwrap it. You should still see the print statement printed three times. [Figure
    6-6](text00016.html#ch06fig6) shows the output of both loops.
  id: totrans-8483
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个需要注意的区别是，price 不是可选项，因为它是直接作为值在 fruitBasket 字典中访问的。这意味着我们不需要解包它。你应该依然看到打印语句被打印三次。[图
    6-6](text00016.html#ch06fig6) 展示了两个循环的输出。
- en: '![Image](Image00151.jpg)'
  id: totrans-8484
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Image00151.jpg)'
- en: '*Figure 6-6: Looping through the keys and values of a dictionary with a for-in
    loop*'
  id: totrans-8485
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 6-6：使用 for-in 循环遍历字典的键和值*'
- en: The order of your results might be slightly different from ours. That’s because
    the items in a dictionary aren’t in a numbered order like they are in an array!
    And because the order is not guaranteed, you might see a different order printed
    if you run the same code again.
  id: totrans-8486
  prefs: []
  type: TYPE_NORMAL
  zh: 你的结果顺序可能与我们的稍有不同。那是因为字典中的项不像数组那样按编号顺序排列！由于顺序无法保证，如果你再次运行相同的代码，可能会看到不同的顺序。
- en: '**WHAT YOU LEARNED**'
  id: totrans-8487
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**你学到了什么**'
- en: In this chapter, you learned how to store collections of items in an array and
    in a dictionary. To store items in an ordered list, you would use an array and
    look up each item by its index. If you wanted to store items by key instead, you
    would use a dictionary.
  id: totrans-8488
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你学习了如何在数组和字典中存储集合。要在有序列表中存储项，可以使用数组，并通过索引查找每个项。如果你想通过键存储项，则需要使用字典。
- en: Knowing about arrays and dictionaries and how to use them is a powerful building
    block for almost any programming language. Next we will learn about functions,
    another very powerful tool. Functions are blocks of code that you create and name
    to perform a specific job. After you have written a function, you can use its
    name to call it from almost anywhere in your program.
  id: totrans-8489
  prefs: []
  type: TYPE_NORMAL
  zh: 了解数组和字典以及如何使用它们，是几乎任何编程语言中非常强大的构建块。接下来我们将学习函数，这是另一种非常强大的工具。函数是你创建并命名的一段代码，用于执行特定的任务。写完函数后，你可以使用它的名字从程序的几乎任何地方调用它。
- en: 'Check out how these two properties are used in the following if-else statement:'
  id: totrans-8490
  prefs: []
  type: TYPE_NORMAL
  zh: 查看以下 if-else 语句中如何使用这两个属性：
- en: '![Image](Image00134.jpg)'
  id: totrans-8491
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Image00134.jpg)'
- en: 'This if-else statement checks whether the array mySiblings is empty ➊ . If
    it is, then "I don''t have any siblings." is printed. But if there is something
    in the array, then the number of siblings that we have is printed: "I have 3 siblings."
    ➋ .'
  id: totrans-8492
  prefs: []
  type: TYPE_NORMAL
  zh: 这个 if-else 语句检查数组 mySiblings 是否为空 ➊。如果是，则打印“我没有兄弟姐妹”。但如果数组中有内容，则打印我们拥有的兄弟姐妹数量：“我有
    3 个兄弟姐妹。” ➋。
- en: '**LOOPING OVER AN ARRAY**'
  id: totrans-8493
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**循环遍历数组**'
- en: 'Sometimes when you’re working with arrays you might want to do something to
    every item in the array. You can use a for-in loop to do that! The following code
    will print every topping in a pizzaToppings array on a separate line:'
  id: totrans-8494
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，在处理数组时，你可能想对数组中的每个项目执行某个操作。你可以使用 for-in 循环来实现！以下代码将把 pizzaToppings 数组中的每个配料打印在单独的一行：
- en: '![Image](Image00135.jpg)'
  id: totrans-8495
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00135.jpg)'
- en: To write a for-in loop for the pizzaToppings array, we used the keyword for
    , followed by the constant topping , then the keyword in , and finally the name
    of our array, pizzaToppings . Then we put the statements that we want to run for
    each topping inside the braces of the for-in loop. The constant topping ➊ temporarily
    represents each pizza topping in the array as we loop through it. We could have
    chosen any name for this constant, but it’s a good idea to pick something that
    makes sense. You can see the output of this for-in loop in [Figure 6-4](text00016.html#ch06fig4)
    .
  id: totrans-8496
  prefs: []
  type: TYPE_NORMAL
  zh: 为了为 pizzaToppings 数组编写 for-in 循环，我们使用了关键字 for，后面跟着常量 topping，然后是关键字 in，最后是数组的名称
    pizzaToppings。接着我们将希望对每个配料执行的语句放入 for-in 循环的花括号内。常量 topping ➊ 临时表示数组中的每个披萨配料，随着循环的进行。我们本可以为这个常量选择任何名字，但最好选择一个有意义的名称。你可以在
    [图 6-4](text00016.html#ch06fig4) 中看到这个 for-in 循环的输出。
- en: '![Image](Image00136.jpg)'
  id: totrans-8497
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00136.jpg)'
- en: '*Figure 6-4: Output of the example for-in loop*'
  id: totrans-8498
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 6-4：示例 for-in 循环的输出*'
- en: '![Image](Image00137.jpg)'
  id: totrans-8499
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00137.jpg)'
- en: 'Using for-in loops is great for printing every value in an array. If you’re
    working with numbers, you can even use them to perform math operations on each
    item, which makes for some speedy calculations! The following code takes an array
    of numbers and calculates the square for each (the square of a number is that
    number multiplied by itself):'
  id: totrans-8500
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 for-in 循环非常适合打印数组中的每个值。如果你处理的是数字，甚至可以使用它们对每个项目进行数学运算，这样可以进行快速计算！以下代码接受一个数字数组，并计算每个数字的平方（数字的平方是该数字乘以它自己）：
- en: '![Image](Image00138.jpg)'
  id: totrans-8501
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00138.jpg)'
- en: '[Figure 6-5](text00016.html#ch06fig5) shows the results.'
  id: totrans-8502
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 6-5](text00016.html#ch06fig5) 显示了结果。'
- en: '![Image](Image00139.jpg)'
  id: totrans-8503
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00139.jpg)'
- en: '*Figure 6-5: Printing the squares for each number in the myNumbers array*'
  id: totrans-8504
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 6-5：打印 myNumbers 数组中每个数字的平方*'
- en: '**DICTIONARIES ARE KEY!**'
  id: totrans-8505
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**字典是关键！**'
- en: A *dictionary* is also a collection of values, but instead of an ordered index,
    each value has its own *key* . Because there’s no index, the values are not stored
    in any particular order. To access values in a dictionary, you look them up by
    their key.
  id: totrans-8506
  prefs: []
  type: TYPE_NORMAL
  zh: '*字典* 也是一种值的集合，但与有序的索引不同，每个值都有自己的*键*。因为没有索引，值的存储顺序是不固定的。要访问字典中的值，你需要通过其键来查找。'
- en: A key must be unique. You can’t have the same key more than once in the same
    dictionary. If there were two identical keys and you asked the computer to give
    you the value for one of them, the computer wouldn’t know which one to choose!
  id: totrans-8507
  prefs: []
  type: TYPE_NORMAL
  zh: 键必须是唯一的。你不能在同一个字典中使用相同的键。如果有两个相同的键，且你要求计算机返回其中一个的值，计算机将不知道选择哪个！
- en: Let’s take a look at how to make a dictionary and write keys that will help
    you find all the information you need.
  id: totrans-8508
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看如何创建一个字典，并编写键，以帮助你找到所有需要的信息。
- en: '![Image](Image00140.jpg)'
  id: totrans-8509
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00140.jpg)'
- en: '**INITIALIZING A DICTIONARY**'
  id: totrans-8510
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**初始化字典**'
- en: 'To create and initialize a dictionary, first write var and the name of your
    dictionary. Then write the keys and corresponding values inside a pair of square
    brackets, similar to an array. Let’s create a dictionary to store the names of
    a few US states. The key for each state will be its two-letter abbreviation:'
  id: totrans-8511
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建并初始化一个字典，首先写 var 和字典的名称。然后，在一对方括号内写入键及其对应的值，类似于数组。让我们创建一个字典来存储几个美国州的名称。每个州的键将是它的两个字母缩写：
- en: '![](Image00141.jpg)'
  id: totrans-8512
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00141.jpg)'
- en: As you can see, there’s a colon between each key and its value, and the key/value
    pairs are separated by commas.
  id: totrans-8513
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，每个键和其对应的值之间有一个冒号，键值对之间用逗号分隔。
- en: Dictionaries are different from arrays in that they are *unordered* . Because
    of that, it’s likely that the order of the states that you see in your results
    pane ➋ is different from the order in which you entered your states ➊ . It might
    even be different than the order that’s printed in this book!
  id: totrans-8514
  prefs: []
  type: TYPE_NORMAL
  zh: 字典与数组的不同之处在于它们是*无序的*。因此，结果窗格 ➋ 中显示的州的顺序可能与输入州时的顺序 ➊ 不同，甚至可能与本书中打印的顺序不同！
- en: As with arrays, you can use var to make a mutable dictionary or use let to make
    an immutable dictionary.
  id: totrans-8515
  prefs: []
  type: TYPE_NORMAL
  zh: 与数组一样，你可以使用 var 来创建一个可变字典，或者使用 let 来创建一个不可变字典。
- en: 'In Swift, all of the keys of a dictionary must be the same type, and all of
    the values of a dictionary must also be the same type, but the key type doesn’t
    have to match the value type. For example, if you wanted to store a collection
    of fractions, you could use doubles for the keys and strings for the values:'
  id: totrans-8516
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Swift 中，字典的所有键必须是相同类型的，字典的所有值也必须是相同类型的，但键的类型不必与值的类型匹配。例如，如果你想存储一个分数的集合，你可以使用双精度数（doubles）作为键，字符串（strings）作为值：
- en: '![](Image00142.jpg)'
  id: totrans-8517
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00142.jpg)'
- en: In this dictionary, all of the keys must be doubles, and all of the values must
    be strings. Again, you’ll see that the order of the numbers in the results pane
    can be quite different from the order in which you wrote the fractions in your
    dictionary. This is fine because you don’t need to know the order to access anything.
    You can find any item that you need by its key. Let’s see how!
  id: totrans-8518
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个字典中，所有的键必须是双精度数（doubles），所有的值必须是字符串（strings）。同样，你会发现结果面板中数字的顺序与字典中分数的顺序可能完全不同。这是没问题的，因为你不需要知道顺序就能访问任何项。你可以通过键找到任何你需要的项。让我们来看看怎么做！
- en: '**ACCESSING VALUES IN A DICTIONARY**'
  id: totrans-8519
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**访问字典中的值**'
- en: 'Looking up a value in a dictionary is similar to how you access a value in
    an array except that you use a key inside the square brackets instead of an index,
    like this: usStates["TX"] .'
  id: totrans-8520
  prefs: []
  type: TYPE_NORMAL
  zh: 查找字典中的值与访问数组中的值类似，只是你需要使用键来代替索引，像这样：`usStates["TX"]`。
- en: There is a big difference, however, in how Swift returns the values from a dictionary.
    When you access a value at an index of an array, you are simply given the value.
    When you access a value with a key in a dictionary, you are given an optional.
  id: totrans-8521
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，Swift 在从字典返回值时存在一个很大的区别。当你访问数组的某个索引的值时，你会直接得到该值。而当你通过字典中的键访问值时，你会得到一个可选值。
- en: In [Chapter 5](text00015.html#ch05) , you learned that optionals might contain
    a value or might be nil . The reason Swift returns optionals when you’re looking
    up items in a dictionary is that the key you used might not exist in the dictionary,
    in which case there’s no value to access. Trying to access a value that doesn’t
    exist would give you a big fat error! To avoid that problem, Swift returns optionals.
    That means you need to unwrap any value you get out of a dictionary before you
    can do anything with it.
  id: totrans-8522
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [第 5 章](text00015.html#ch05) 中，你学到过可选值可能包含一个值，也可能是 `nil`。Swift 返回可选值是因为你查找字典中的项时，所使用的键可能在字典中不存在，在这种情况下，没有值可以访问。尝试访问一个不存在的值会导致一个严重的错误！为了避免这个问题，Swift
    返回可选值。这意味着在你对字典中的任何值做进一步操作之前，你需要解包它。
- en: 'To unwrap an optional, first you check whether it exists using an if-let statement,
    just like we did in [Chapter 5](text00015.html#ch05) . The following code shows
    you how to get a value out of a dictionary:'
  id: totrans-8523
  prefs: []
  type: TYPE_NORMAL
  zh: 要解包一个可选值，首先检查它是否存在，使用 `if-let` 语句，就像我们在 [第 5 章](text00015.html#ch05) 中所做的那样。以下代码展示了如何从字典中获取一个值：
- en: '![Image](Image00143.jpg)'
  id: totrans-8524
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00143.jpg)'
- en: To retrieve "Texas" from the dictionary, we use if let to set a constant loneStarState
    to usStates["TX"] ➊ . Because we have this state in our dictionary, the line I
    have Texas in my dictionary. is printed. Next we try to access a state that is
    not in our dictionary by using the key usStates["FL"] ➋ . Thankfully, because
    we used an if-let statement, the program won’t crash when the computer can’t find
    this state. Instead, I don't have that state in my dictionary. is printed.
  id: totrans-8525
  prefs: []
  type: TYPE_NORMAL
  zh: 要从字典中获取 "Texas"，我们使用 `if let` 将常量 `loneStarState` 设置为 `usStates["TX"]` ➊。因为我们的字典中包含这个州，所以会打印出
    "I have Texas in my dictionary"。接下来，我们尝试通过键 `usStates["FL"]` ➋ 访问一个不在字典中的州。幸运的是，由于我们使用了
    `if-let` 语句，当计算机找不到该州时，程序不会崩溃。相反，会打印出 "I don't have that state in my dictionary"。
- en: '**ADDING ITEMS TO A DICTIONARY**'
  id: totrans-8526
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**向字典添加项**'
- en: 'To add an item to a dictionary, first write the name of your dictionary and
    assign the new item to the key you want it to have in the dictionary. Let’s add
    "Minnesota" to our usStates dictionary:'
  id: totrans-8527
  prefs: []
  type: TYPE_NORMAL
  zh: 要向字典中添加项，首先写下字典的名称，并将新项分配给你希望它在字典中拥有的键。让我们向 `usStates` 字典中添加 "Minnesota"：
- en: '![](Image00144.jpg)'
  id: totrans-8528
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00144.jpg)'
- en: 'Now when you look at usStates , you’ll see that it’s updated to ["MN": "Minnesota",
    "WA": "Washington", "MA": "Massachusetts", "TX": "Texas"] . Remember, because
    you don’t have to rely on indices, your new dictionary item might appear anywhere
    in the dictionary.'
  id: totrans-8529
  prefs: []
  type: TYPE_NORMAL
  zh: '现在，当你查看 `usStates` 时，你会看到它已经更新为 ["MN": "Minnesota", "WA": "Washington", "MA":
    "Massachusetts", "TX": "Texas"]。记住，由于你不需要依赖索引，新的字典项可能出现在字典中的任何位置。'
- en: '**REMOVING ITEMS FROM A DICTIONARY**'
  id: totrans-8530
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**从字典中移除项**'
- en: Removing an item from a dictionary is quite simple; you do so by setting the
    value to nil . Because the values in dictionaries are returned as optionals, you
    don’t have to worry about nil causing any problems in your dictionary.
  id: totrans-8531
  prefs: []
  type: TYPE_NORMAL
  zh: 从字典中移除一个项目非常简单；你只需将值设置为 nil。由于字典中的值是作为可选项返回的，因此你不需要担心 nil 会在字典中引起任何问题。
- en: '![](Image00145.jpg)'
  id: totrans-8532
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00145.jpg)'
- en: 'You can see that after you remove the value at the key "MA" , usStates is updated
    to ["MN": "Minnesota", "WA": "Washington", "TX": "Texas"] . Remember that nil
    is special and means that there’s no value at all. That’s why you don’t see "MA":
    nil in our dictionary.'
  id: totrans-8533
  prefs: []
  type: TYPE_NORMAL
  zh: '你可以看到，在移除“MA”键的值后，usStates 更新为 ["MN": "Minnesota", "WA": "Washington", "TX":
    "Texas"]。记住，nil 是特别的，表示完全没有值。这就是为什么你在字典中看不到 "MA": nil。'
- en: '**REPLACING ITEMS IN A DICTIONARY**'
  id: totrans-8534
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**替换字典中的项目**'
- en: 'Replacing an item in a dictionary is also easy. It works the same was as replacing
    an item in an array. You just set the item that you want to replace to something
    else. Say you create a dictionary of fruit colors:'
  id: totrans-8535
  prefs: []
  type: TYPE_NORMAL
  zh: 替换字典中的项目也很简单。它的工作原理与替换数组中的项目相同。你只需将你想替换的项目设置为其他值。例如，你可以创建一个包含水果颜色的字典：
- en: '![](Image00146.jpg)'
  id: totrans-8536
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00146.jpg)'
- en: At first we had the value "apple" for "red" , but then we decided that "raspberry"
    is a better fruit to use since sometimes apples are green or yellow. To replace
    "apple" with "raspberry" , we set colorFruits["red"] to its new value ➊ .
  id: totrans-8537
  prefs: []
  type: TYPE_NORMAL
  zh: 最初我们为“red”键设置了值“apple”，但后来我们决定使用“raspberry”作为更好的水果，因为有时候苹果是绿色或黄色的。为了用“raspberry”替换“apple”，我们将
    colorFruits["red"] 设置为其新值 ➊。
- en: You may remember that this is the same way we entered a new value into a dictionary.
    If the key already exists in the dictionary, then the value for that key is replaced.
    If the key doesn’t already exist, then the new key/value pair will be added to
    the dictionary.
  id: totrans-8538
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能记得，这是我们向字典中输入新值的方式。如果字典中已经存在该键，则该键的值会被替换。如果该键不存在，则新的键/值对会被添加到字典中。
- en: '![Image](Image00147.jpg)'
  id: totrans-8539
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00147.jpg)'
- en: '**USING DICTIONARY PROPERTIES**'
  id: totrans-8540
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**使用字典属性**'
- en: 'Like an array, a dictionary also has an isEmpty property and a count property.
    For example, the following code shows how you can use the isEmpty property to
    check if a dictionary is empty, and if it isn’t empty, the count property checks
    how many items you have. Imagine you have a basket of fruit for sale. You can
    use these properties to help you keep track of everything:'
  id: totrans-8541
  prefs: []
  type: TYPE_NORMAL
  zh: 像数组一样，字典也有 isEmpty 属性和 count 属性。例如，下面的代码展示了如何使用 isEmpty 属性来检查字典是否为空，如果不为空，则
    count 属性检查你有多少个项目。假设你有一个待售的水果篮，你可以使用这些属性来帮助你跟踪所有内容：
- en: '![Image](Image00148.jpg)'
  id: totrans-8542
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00148.jpg)'
- en: 'A dictionary also has two special properties: keys , which contains all of
    the dictionary’s keys, and values , which contains all of its values. We’ll use
    these two properties when we loop through the dictionary.'
  id: totrans-8543
  prefs: []
  type: TYPE_NORMAL
  zh: 字典还有两个特殊的属性：keys，包含字典的所有键，以及 values，包含字典的所有值。当我们遍历字典时，将使用这两个属性。
- en: Let’s write some code that loops through our fruit baskets and prints the price
    of each fruit.
  id: totrans-8544
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们写一些代码，遍历我们的水果篮并打印每个水果的价格。
- en: '**LOOPING OVER A DICTIONARY**'
  id: totrans-8545
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**遍历字典**'
- en: 'You can loop through a dictionary using a for-in loop. Because each item has
    a key and a value, you can do this in two different ways. This is how to loop
    through a dictionary using its keys:'
  id: totrans-8546
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用 for-in 循环来遍历字典。因为每个项目都有一个键和值，你可以用两种不同的方式来完成。下面是如何使用字典的键来遍历字典：
- en: '![Image](Image00149.jpg)'
  id: totrans-8547
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00149.jpg)'
- en: Here we use the dictionary’s keys property ➊ to loop through fruitBasket and
    print its contents. We start by writing the keyword for , followed by a constant
    name fruit for the dictionary key, the keyword in , the dictionary name, a period,
    and keys .
  id: totrans-8548
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们使用字典的 keys 属性 ➊ 来遍历 fruitBasket 并打印其内容。我们首先写下关键字 for，后跟一个常量名 fruit 作为字典的键，然后是关键字
    in，字典的名称，一个句点，最后是 keys。
- en: Inside the braces of our for-in loop, we have access to both the key, which
    we call fruit ➋ , and the value at that key when we force-unwrap its contents
    with fruitBasket[fruit]! ➌ . That value will be the fruit’s price.
  id: totrans-8549
  prefs: []
  type: TYPE_NORMAL
  zh: 在 for-in 循环的大括号内，我们可以访问键，也就是我们称之为 fruit ➋，以及当我们强制解包 fruitBasket[fruit]! ➌ 时该键对应的值。这个值将是水果的价格。
- en: In this case, it’s safe to force-unwrap the value using an exclamation point
    because we know that the fruit key we’re using is definitely inside the dictionary.
  id: totrans-8550
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，使用感叹号强制解包值是安全的，因为我们知道我们使用的水果键一定存在于字典中。
- en: Any code we put inside the for-in loop will run once for every key in our dictionary.
    So you should see the print statement display three times.
  id: totrans-8551
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将所有的代码放入for-in循环中，将针对字典中的每个键执行一次。所以你应该看到打印语句显示三次。
- en: 'We can also loop through the dictionary using its values property:'
  id: totrans-8552
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以通过字典的values属性进行循环：
- en: '![Image](Image00150.jpg)'
  id: totrans-8553
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00150.jpg)'
- en: We use the same style of for-in loop, but now we use a constant to refer to
    each value, which we call price , in the values property. When looping through
    values, we don’t have access to the keys from inside the loop.
  id: totrans-8554
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用相同的for-in循环样式，但现在我们使用常量来引用values属性中的每个值，称之为price。在循环遍历值时，我们无法从循环内部访问键。
- en: Another difference to note is that price is not an optional because it’s accessed
    directly as a value in the fruitBasket dictionary. That means we don’t have to
    unwrap it. You should still see the print statement printed three times. [Figure
    6-6](text00016.html#ch06fig6) shows the output of both loops.
  id: totrans-8555
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个需要注意的区别是，价格不是可选的，因为它是直接作为值在fruitBasket字典中访问的。这意味着我们不需要解包它。你仍然应该看到打印语句打印三次。[图6-6](text00016.html#ch06fig6)显示了两个循环的输出。
- en: '![Image](Image00151.jpg)'
  id: totrans-8556
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00151.jpg)'
- en: '*Figure 6-6: Looping through the keys and values of a dictionary with a for-in
    loop*'
  id: totrans-8557
  prefs: []
  type: TYPE_NORMAL
  zh: '*图6-6：使用for-in循环遍历字典的键和值*'
- en: The order of your results might be slightly different from ours. That’s because
    the items in a dictionary aren’t in a numbered order like they are in an array!
    And because the order is not guaranteed, you might see a different order printed
    if you run the same code again.
  id: totrans-8558
  prefs: []
  type: TYPE_NORMAL
  zh: 你的结果顺序可能与我们的稍有不同。这是因为字典中的项不像数组那样按编号顺序排列！由于顺序不保证，因此如果你再次运行相同的代码，可能会看到不同的顺序输出。
- en: '**WHAT YOU LEARNED**'
  id: totrans-8559
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**你学到了什么**'
- en: In this chapter, you learned how to store collections of items in an array and
    in a dictionary. To store items in an ordered list, you would use an array and
    look up each item by its index. If you wanted to store items by key instead, you
    would use a dictionary.
  id: totrans-8560
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你学习了如何在数组和字典中存储项。要将项存储在有序列表中，你会使用数组，并通过索引查找每个项。如果你想按键存储项，则会使用字典。
- en: Knowing about arrays and dictionaries and how to use them is a powerful building
    block for almost any programming language. Next we will learn about functions,
    another very powerful tool. Functions are blocks of code that you create and name
    to perform a specific job. After you have written a function, you can use its
    name to call it from almost anywhere in your program.
  id: totrans-8561
  prefs: []
  type: TYPE_NORMAL
  zh: 了解数组和字典以及如何使用它们，是几乎任何编程语言中的强大基础。接下来我们将学习函数，这是另一个非常强大的工具。函数是你创建并命名的代码块，用来执行特定的任务。编写了函数之后，你可以通过其名称从程序中的几乎任何地方调用它。
- en: '![Image](Image00134.jpg)'
  id: totrans-8562
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00134.jpg)'
- en: 'This if-else statement checks whether the array mySiblings is empty ➊ . If
    it is, then "I don''t have any siblings." is printed. But if there is something
    in the array, then the number of siblings that we have is printed: "I have 3 siblings."
    ➋ .'
  id: totrans-8563
  prefs: []
  type: TYPE_NORMAL
  zh: 这个if-else语句检查数组mySiblings是否为空 ➊ 。如果为空，则打印“我没有兄弟姐妹”。但如果数组中有内容，则会打印我们有多少兄弟姐妹：“我有3个兄弟姐妹。”
    ➋ 。
- en: '**LOOPING OVER AN ARRAY**'
  id: totrans-8564
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**循环遍历数组**'
- en: 'Sometimes when you’re working with arrays you might want to do something to
    every item in the array. You can use a for-in loop to do that! The following code
    will print every topping in a pizzaToppings array on a separate line:'
  id: totrans-8565
  prefs: []
  type: TYPE_NORMAL
  zh: 有时在处理数组时，你可能想对数组中的每个项做一些操作。你可以使用for-in循环来做到这一点！以下代码会在每一行打印pizzaToppings数组中的每个配料：
- en: '![Image](Image00135.jpg)'
  id: totrans-8566
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00135.jpg)'
- en: To write a for-in loop for the pizzaToppings array, we used the keyword for
    , followed by the constant topping , then the keyword in , and finally the name
    of our array, pizzaToppings . Then we put the statements that we want to run for
    each topping inside the braces of the for-in loop. The constant topping ➊ temporarily
    represents each pizza topping in the array as we loop through it. We could have
    chosen any name for this constant, but it’s a good idea to pick something that
    makes sense. You can see the output of this for-in loop in [Figure 6-4](text00016.html#ch06fig4)
    .
  id: totrans-8567
  prefs: []
  type: TYPE_NORMAL
  zh: 为了写一个针对pizzaToppings数组的for-in循环，我们使用了关键字for，接着是常量topping，然后是关键字in，最后是我们的数组名称pizzaToppings。接着，我们将每个披萨配料要执行的语句放入for-in循环的花括号内。常量topping
    ➊ 临时代表我们遍历数组时的每个披萨配料。我们可以为这个常量选择任何名称，但选择一个有意义的名称是个好主意。你可以在[图6-4](text00016.html#ch06fig4)中看到这个for-in循环的输出。
- en: '![Image](Image00136.jpg)'
  id: totrans-8568
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00136.jpg)'
- en: '*Figure 6-4: Output of the example for-in loop*'
  id: totrans-8569
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 6-4：示例 for-in 循环的输出*'
- en: '![Image](Image00137.jpg)'
  id: totrans-8570
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00137.jpg)'
- en: 'Using for-in loops is great for printing every value in an array. If you’re
    working with numbers, you can even use them to perform math operations on each
    item, which makes for some speedy calculations! The following code takes an array
    of numbers and calculates the square for each (the square of a number is that
    number multiplied by itself):'
  id: totrans-8571
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 for-in 循环非常适合打印数组中的每个值。如果您正在处理数字，甚至可以用它们对每个项目执行数学运算，从而进行快速计算！以下代码接受一个数字数组，并计算每个数字的平方（一个数字的平方是该数字与它自己相乘）：
- en: '![Image](Image00138.jpg)'
  id: totrans-8572
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00138.jpg)'
- en: '[Figure 6-5](text00016.html#ch06fig5) shows the results.'
  id: totrans-8573
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 6-5](text00016.html#ch06fig5) 显示了结果。'
- en: '![Image](Image00139.jpg)'
  id: totrans-8574
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00139.jpg)'
- en: '*Figure 6-5: Printing the squares for each number in the myNumbers array*'
  id: totrans-8575
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 6-5：打印 myNumbers 数组中每个数字的平方*'
- en: '**DICTIONARIES ARE KEY!**'
  id: totrans-8576
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**字典至关重要！**'
- en: A *dictionary* is also a collection of values, but instead of an ordered index,
    each value has its own *key* . Because there’s no index, the values are not stored
    in any particular order. To access values in a dictionary, you look them up by
    their key.
  id: totrans-8577
  prefs: []
  type: TYPE_NORMAL
  zh: '*字典* 也是一个值的集合，但与有序索引不同，每个值都有自己的*键*。因为没有索引，所以值没有按照特定的顺序存储。要访问字典中的值，您需要通过键来查找它们。'
- en: A key must be unique. You can’t have the same key more than once in the same
    dictionary. If there were two identical keys and you asked the computer to give
    you the value for one of them, the computer wouldn’t know which one to choose!
  id: totrans-8578
  prefs: []
  type: TYPE_NORMAL
  zh: 每个键必须是唯一的。一个字典中不能有重复的键。如果有两个相同的键，而您请求计算机返回其中一个的值，计算机将不知道该选择哪个！
- en: Let’s take a look at how to make a dictionary and write keys that will help
    you find all the information you need.
  id: totrans-8579
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看如何创建字典，并编写键来帮助您找到所有需要的信息。
- en: '![Image](Image00140.jpg)'
  id: totrans-8580
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00140.jpg)'
- en: '**INITIALIZING A DICTIONARY**'
  id: totrans-8581
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**初始化字典**'
- en: 'To create and initialize a dictionary, first write var and the name of your
    dictionary. Then write the keys and corresponding values inside a pair of square
    brackets, similar to an array. Let’s create a dictionary to store the names of
    a few US states. The key for each state will be its two-letter abbreviation:'
  id: totrans-8582
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建和初始化字典，首先写上 var 和字典的名称。然后像数组一样，在一对方括号内写上键和值的对应关系。我们来创建一个字典来存储一些美国州的名称。每个州的键将是它的两字母缩写：
- en: '![](Image00141.jpg)'
  id: totrans-8583
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00141.jpg)'
- en: As you can see, there’s a colon between each key and its value, and the key/value
    pairs are separated by commas.
  id: totrans-8584
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，每个键和值之间有一个冒号，键/值对之间用逗号分隔。
- en: Dictionaries are different from arrays in that they are *unordered* . Because
    of that, it’s likely that the order of the states that you see in your results
    pane ➋ is different from the order in which you entered your states ➊ . It might
    even be different than the order that’s printed in this book!
  id: totrans-8585
  prefs: []
  type: TYPE_NORMAL
  zh: 字典与数组不同，字典是*无序的*。因此，您在结果窗格中看到的状态顺序 ➋ 可能与您输入状态时的顺序 ➊ 不同。甚至可能与书中打印的顺序不同！
- en: As with arrays, you can use var to make a mutable dictionary or use let to make
    an immutable dictionary.
  id: totrans-8586
  prefs: []
  type: TYPE_NORMAL
  zh: 与数组一样，您可以使用 var 来创建一个可变字典，或者使用 let 来创建一个不可变字典。
- en: 'In Swift, all of the keys of a dictionary must be the same type, and all of
    the values of a dictionary must also be the same type, but the key type doesn’t
    have to match the value type. For example, if you wanted to store a collection
    of fractions, you could use doubles for the keys and strings for the values:'
  id: totrans-8587
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Swift 中，字典的所有键必须是相同的类型，字典的所有值也必须是相同的类型，但键的类型不必与值的类型匹配。例如，如果您想存储一个分数集合，您可以使用双精度数作为键，使用字符串作为值：
- en: '![](Image00142.jpg)'
  id: totrans-8588
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00142.jpg)'
- en: In this dictionary, all of the keys must be doubles, and all of the values must
    be strings. Again, you’ll see that the order of the numbers in the results pane
    can be quite different from the order in which you wrote the fractions in your
    dictionary. This is fine because you don’t need to know the order to access anything.
    You can find any item that you need by its key. Let’s see how!
  id: totrans-8589
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个字典中，所有键必须是双精度数，所有值必须是字符串。同样，您会发现结果窗格中数字的顺序可能与您在字典中编写分数的顺序大不相同。这没关系，因为您不需要知道顺序就能访问任何内容。您可以通过键找到任何您需要的项。我们来看看怎么做！
- en: '**ACCESSING VALUES IN A DICTIONARY**'
  id: totrans-8590
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**访问字典中的值**'
- en: 'Looking up a value in a dictionary is similar to how you access a value in
    an array except that you use a key inside the square brackets instead of an index,
    like this: usStates["TX"] .'
  id: totrans-8591
  prefs: []
  type: TYPE_NORMAL
  zh: 在字典中查找一个值类似于你在数组中访问一个值的方式，不同的是你使用的是键而不是索引，比如：usStates["TX"]。
- en: There is a big difference, however, in how Swift returns the values from a dictionary.
    When you access a value at an index of an array, you are simply given the value.
    When you access a value with a key in a dictionary, you are given an optional.
  id: totrans-8592
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，Swift返回字典值的方式与访问数组索引的方式有很大不同。当你访问数组中的某个索引的值时，你会直接获得值。当你用键访问字典中的值时，你获得的是一个可选值。
- en: In [Chapter 5](text00015.html#ch05) , you learned that optionals might contain
    a value or might be nil . The reason Swift returns optionals when you’re looking
    up items in a dictionary is that the key you used might not exist in the dictionary,
    in which case there’s no value to access. Trying to access a value that doesn’t
    exist would give you a big fat error! To avoid that problem, Swift returns optionals.
    That means you need to unwrap any value you get out of a dictionary before you
    can do anything with it.
  id: totrans-8593
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第5章](text00015.html#ch05)中，你学到过可选值可能包含一个值，也可能是nil。Swift在你查找字典中的项时返回可选值，是因为你使用的键可能在字典中不存在，在这种情况下就没有值可以访问。尝试访问一个不存在的值会导致一个大错误！为避免这个问题，Swift返回的是可选值。这意味着你需要解包你从字典中获得的任何值，才能对它做任何操作。
- en: 'To unwrap an optional, first you check whether it exists using an if-let statement,
    just like we did in [Chapter 5](text00015.html#ch05) . The following code shows
    you how to get a value out of a dictionary:'
  id: totrans-8594
  prefs: []
  type: TYPE_NORMAL
  zh: 要解包一个可选值，首先你需要使用if-let语句检查它是否存在，就像我们在[第5章](text00015.html#ch05)中做的那样。以下代码展示了如何从字典中获取一个值：
- en: '![Image](Image00143.jpg)'
  id: totrans-8595
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00143.jpg)'
- en: To retrieve "Texas" from the dictionary, we use if let to set a constant loneStarState
    to usStates["TX"] ➊ . Because we have this state in our dictionary, the line I
    have Texas in my dictionary. is printed. Next we try to access a state that is
    not in our dictionary by using the key usStates["FL"] ➋ . Thankfully, because
    we used an if-let statement, the program won’t crash when the computer can’t find
    this state. Instead, I don't have that state in my dictionary. is printed.
  id: totrans-8596
  prefs: []
  type: TYPE_NORMAL
  zh: 要从字典中检索“德州”，我们使用`if let`将常量loneStarState设置为usStates["TX"] ➊。因为我们的字典中包含这个州，所以会打印出“我在字典中找到了德州”。接下来，我们尝试通过使用键usStates["FL"]
    ➋来访问一个不在字典中的州。幸运的是，由于我们使用了if-let语句，当计算机无法找到这个州时，程序不会崩溃。相反，会打印出“我在字典中没有那个州”。
- en: '**ADDING ITEMS TO A DICTIONARY**'
  id: totrans-8597
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**向字典中添加项**'
- en: 'To add an item to a dictionary, first write the name of your dictionary and
    assign the new item to the key you want it to have in the dictionary. Let’s add
    "Minnesota" to our usStates dictionary:'
  id: totrans-8598
  prefs: []
  type: TYPE_NORMAL
  zh: 要向字典中添加项，首先写出字典的名称，并将新项赋值给你希望它在字典中拥有的键。让我们将"明尼苏达州"添加到我们的usStates字典中：
- en: '![](Image00144.jpg)'
  id: totrans-8599
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00144.jpg)'
- en: 'Now when you look at usStates , you’ll see that it’s updated to ["MN": "Minnesota",
    "WA": "Washington", "MA": "Massachusetts", "TX": "Texas"] . Remember, because
    you don’t have to rely on indices, your new dictionary item might appear anywhere
    in the dictionary.'
  id: totrans-8600
  prefs: []
  type: TYPE_NORMAL
  zh: '现在，当你查看usStates时，你会看到它已更新为["MN": "Minnesota", "WA": "Washington", "MA": "Massachusetts",
    "TX": "Texas"]。记住，由于你不需要依赖索引，你的新字典项可能出现在字典的任何位置。'
- en: '**REMOVING ITEMS FROM A DICTIONARY**'
  id: totrans-8601
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**从字典中删除项**'
- en: Removing an item from a dictionary is quite simple; you do so by setting the
    value to nil . Because the values in dictionaries are returned as optionals, you
    don’t have to worry about nil causing any problems in your dictionary.
  id: totrans-8602
  prefs: []
  type: TYPE_NORMAL
  zh: 从字典中删除项也很简单；你只需要将该项的值设置为nil。因为字典中的值是以可选值返回的，所以你不必担心nil会导致字典中的任何问题。
- en: '![](Image00145.jpg)'
  id: totrans-8603
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00145.jpg)'
- en: 'You can see that after you remove the value at the key "MA" , usStates is updated
    to ["MN": "Minnesota", "WA": "Washington", "TX": "Texas"] . Remember that nil
    is special and means that there’s no value at all. That’s why you don’t see "MA":
    nil in our dictionary.'
  id: totrans-8604
  prefs: []
  type: TYPE_NORMAL
  zh: '你可以看到，在你删除键为"MA"的值后，usStates更新为["MN": "Minnesota", "WA": "Washington", "TX":
    "Texas"]。记住，nil是特殊的，表示根本没有值。因此，你不会在字典中看到"MA": nil。'
- en: '**REPLACING ITEMS IN A DICTIONARY**'
  id: totrans-8605
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**替换字典中的项**'
- en: 'Replacing an item in a dictionary is also easy. It works the same was as replacing
    an item in an array. You just set the item that you want to replace to something
    else. Say you create a dictionary of fruit colors:'
  id: totrans-8606
  prefs: []
  type: TYPE_NORMAL
  zh: 替换字典中的项也很简单。它的工作方式与替换数组中的项相同。你只需将你想替换的项设置为其他值。例如，你创建一个表示水果颜色的字典：
- en: '![](Image00146.jpg)'
  id: totrans-8607
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00146.jpg)'
- en: At first we had the value "apple" for "red" , but then we decided that "raspberry"
    is a better fruit to use since sometimes apples are green or yellow. To replace
    "apple" with "raspberry" , we set colorFruits["red"] to its new value ➊ .
  id: totrans-8608
  prefs: []
  type: TYPE_NORMAL
  zh: 起初，我们将"红色"的值设为"apple"，但后来我们决定使用"raspberry"作为更好的水果，因为有时苹果是绿色或黄色的。为了将"apple"替换为"raspberry"，我们将colorFruits["red"]设置为其新值➊。
- en: You may remember that this is the same way we entered a new value into a dictionary.
    If the key already exists in the dictionary, then the value for that key is replaced.
    If the key doesn’t already exist, then the new key/value pair will be added to
    the dictionary.
  id: totrans-8609
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能还记得，这是我们将新值添加到字典中的方式。如果字典中已经存在该键，则该键的值会被替换。如果该键不存在，则新的键/值对将被添加到字典中。
- en: '![Image](Image00147.jpg)'
  id: totrans-8610
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00147.jpg)'
- en: '**USING DICTIONARY PROPERTIES**'
  id: totrans-8611
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**使用字典属性**'
- en: 'Like an array, a dictionary also has an isEmpty property and a count property.
    For example, the following code shows how you can use the isEmpty property to
    check if a dictionary is empty, and if it isn’t empty, the count property checks
    how many items you have. Imagine you have a basket of fruit for sale. You can
    use these properties to help you keep track of everything:'
  id: totrans-8612
  prefs: []
  type: TYPE_NORMAL
  zh: 类似于数组，字典也有isEmpty属性和count属性。例如，以下代码展示了如何使用isEmpty属性检查字典是否为空，如果不为空，count属性检查你有多少个项。假设你有一个待售的水果篮。你可以使用这些属性来帮助你跟踪所有物品：
- en: '![Image](Image00148.jpg)'
  id: totrans-8613
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00148.jpg)'
- en: 'A dictionary also has two special properties: keys , which contains all of
    the dictionary’s keys, and values , which contains all of its values. We’ll use
    these two properties when we loop through the dictionary.'
  id: totrans-8614
  prefs: []
  type: TYPE_NORMAL
  zh: 字典还有两个特殊属性：keys，它包含字典的所有键；values，它包含字典的所有值。我们将在遍历字典时使用这两个属性。
- en: Let’s write some code that loops through our fruit baskets and prints the price
    of each fruit.
  id: totrans-8615
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们编写一些代码，遍历我们的水果篮并打印每种水果的价格。
- en: '**LOOPING OVER A DICTIONARY**'
  id: totrans-8616
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**遍历字典**'
- en: 'You can loop through a dictionary using a for-in loop. Because each item has
    a key and a value, you can do this in two different ways. This is how to loop
    through a dictionary using its keys:'
  id: totrans-8617
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用for-in循环遍历字典。因为每个项都有一个键和值，所以你可以用两种不同的方式来做到这一点。下面是使用字典的键遍历字典的方法：
- en: '![Image](Image00149.jpg)'
  id: totrans-8618
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00149.jpg)'
- en: Here we use the dictionary’s keys property ➊ to loop through fruitBasket and
    print its contents. We start by writing the keyword for , followed by a constant
    name fruit for the dictionary key, the keyword in , the dictionary name, a period,
    and keys .
  id: totrans-8619
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们使用字典的keys属性➊遍历fruitBasket并打印其内容。我们从写入关键字for开始，接着是字典键的常量名称fruit，关键字in，字典名称，一个句点，和keys。
- en: Inside the braces of our for-in loop, we have access to both the key, which
    we call fruit ➋ , and the value at that key when we force-unwrap its contents
    with fruitBasket[fruit]! ➌ . That value will be the fruit’s price.
  id: totrans-8620
  prefs: []
  type: TYPE_NORMAL
  zh: 在for-in循环的大括号内，我们可以访问键（我们称其为fruit➋）和通过强制解包其内容fruitBasket[fruit]! ➌访问该键的值。该值将是水果的价格。
- en: In this case, it’s safe to force-unwrap the value using an exclamation point
    because we know that the fruit key we’re using is definitely inside the dictionary.
  id: totrans-8621
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，使用感叹号强制解包值是安全的，因为我们知道我们正在使用的水果键一定在字典中。
- en: Any code we put inside the for-in loop will run once for every key in our dictionary.
    So you should see the print statement display three times.
  id: totrans-8622
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在for-in循环内写的任何代码都会在字典中的每个键上执行一次。所以你应该看到print语句会显示三次。
- en: 'We can also loop through the dictionary using its values property:'
  id: totrans-8623
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以使用字典的values属性遍历字典：
- en: '![Image](Image00150.jpg)'
  id: totrans-8624
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00150.jpg)'
- en: We use the same style of for-in loop, but now we use a constant to refer to
    each value, which we call price , in the values property. When looping through
    values, we don’t have access to the keys from inside the loop.
  id: totrans-8625
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用相同风格的for-in循环，但现在我们使用常量来引用values属性中的每个值，我们称之为price。在遍历值时，我们无法从循环内访问键。
- en: Another difference to note is that price is not an optional because it’s accessed
    directly as a value in the fruitBasket dictionary. That means we don’t have to
    unwrap it. You should still see the print statement printed three times. [Figure
    6-6](text00016.html#ch06fig6) shows the output of both loops.
  id: totrans-8626
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个需要注意的区别是，price不是可选的，因为它是直接作为fruitBasket字典中的值访问的。这意味着我们不需要解包它。你仍然应该看到print语句显示三次。[图6-6](text00016.html#ch06fig6)展示了两个循环的输出。
- en: '![Image](Image00151.jpg)'
  id: totrans-8627
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00151.jpg)'
- en: '*Figure 6-6: Looping through the keys and values of a dictionary with a for-in
    loop*'
  id: totrans-8628
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 6-6：使用 for-in 循环遍历字典的键和值*'
- en: The order of your results might be slightly different from ours. That’s because
    the items in a dictionary aren’t in a numbered order like they are in an array!
    And because the order is not guaranteed, you might see a different order printed
    if you run the same code again.
  id: totrans-8629
  prefs: []
  type: TYPE_NORMAL
  zh: 你的结果顺序可能与我们的略有不同。这是因为字典中的项目不像数组那样有编号顺序！由于顺序无法保证，因此如果你再次运行相同的代码，可能会看到不同的顺序。
- en: '**WHAT YOU LEARNED**'
  id: totrans-8630
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**你学到的内容**'
- en: In this chapter, you learned how to store collections of items in an array and
    in a dictionary. To store items in an ordered list, you would use an array and
    look up each item by its index. If you wanted to store items by key instead, you
    would use a dictionary.
  id: totrans-8631
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一章中，你学会了如何将项集合存储在数组和字典中。要在有序列表中存储项，你会使用数组，并通过索引查找每个项。如果你想通过键来存储项，则应使用字典。
- en: Knowing about arrays and dictionaries and how to use them is a powerful building
    block for almost any programming language. Next we will learn about functions,
    another very powerful tool. Functions are blocks of code that you create and name
    to perform a specific job. After you have written a function, you can use its
    name to call it from almost anywhere in your program.
  id: totrans-8632
  prefs: []
  type: TYPE_NORMAL
  zh: 了解数组和字典以及如何使用它们，是几乎所有编程语言中非常强大的构建块。接下来，我们将学习函数，另一个非常强大的工具。函数是你创建并命名的代码块，用来执行特定任务。在你写完一个函数后，可以通过它的名字在程序中的几乎任何地方调用它。
- en: 'This if-else statement checks whether the array mySiblings is empty ➊ . If
    it is, then "I don''t have any siblings." is printed. But if there is something
    in the array, then the number of siblings that we have is printed: "I have 3 siblings."
    ➋ .'
  id: totrans-8633
  prefs: []
  type: TYPE_NORMAL
  zh: 这个 if-else 语句检查数组 mySiblings 是否为空 ➊。如果为空，则打印 "我没有兄弟姐妹"。但如果数组中有内容，则会打印我们有多少兄弟姐妹："我有
    3 个兄弟姐妹。" ➋。
- en: '**LOOPING OVER AN ARRAY**'
  id: totrans-8634
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**遍历数组**'
- en: 'Sometimes when you’re working with arrays you might want to do something to
    every item in the array. You can use a for-in loop to do that! The following code
    will print every topping in a pizzaToppings array on a separate line:'
  id: totrans-8635
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，当你在处理数组时，可能希望对数组中的每一项做点什么。你可以使用 for-in 循环来实现这一点！以下代码将在新的一行打印 pizzaToppings
    数组中的每个配料：
- en: '![Image](Image00135.jpg)'
  id: totrans-8636
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00135.jpg)'
- en: To write a for-in loop for the pizzaToppings array, we used the keyword for
    , followed by the constant topping , then the keyword in , and finally the name
    of our array, pizzaToppings . Then we put the statements that we want to run for
    each topping inside the braces of the for-in loop. The constant topping ➊ temporarily
    represents each pizza topping in the array as we loop through it. We could have
    chosen any name for this constant, but it’s a good idea to pick something that
    makes sense. You can see the output of this for-in loop in [Figure 6-4](text00016.html#ch06fig4)
    .
  id: totrans-8637
  prefs: []
  type: TYPE_NORMAL
  zh: 要为 pizzaToppings 数组编写一个 for-in 循环，我们使用了关键字 for，接着是常量 topping，然后是关键字 in，最后是我们的数组名称
    pizzaToppings。然后我们将希望对每个配料执行的语句放在 for-in 循环的括号内。常量 topping ➊ 在我们循环遍历数组时暂时代表每个披萨配料。我们本可以为这个常量选择任何名字，但最好选择一个有意义的名字。你可以在
    [图 6-4](text00016.html#ch06fig4) 中看到这个 for-in 循环的输出。
- en: '![Image](Image00136.jpg)'
  id: totrans-8638
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00136.jpg)'
- en: '*Figure 6-4: Output of the example for-in loop*'
  id: totrans-8639
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 6-4：示例 for-in 循环的输出*'
- en: '![Image](Image00137.jpg)'
  id: totrans-8640
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00137.jpg)'
- en: 'Using for-in loops is great for printing every value in an array. If you’re
    working with numbers, you can even use them to perform math operations on each
    item, which makes for some speedy calculations! The following code takes an array
    of numbers and calculates the square for each (the square of a number is that
    number multiplied by itself):'
  id: totrans-8641
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 for-in 循环非常适合打印数组中的每个值。如果你在处理数字，你甚至可以用它们对每个项目执行数学运算，这样可以快速进行计算！以下代码取一个数字数组，并计算每个数字的平方（一个数字的平方是该数字与它自己相乘）：
- en: '![Image](Image00138.jpg)'
  id: totrans-8642
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00138.jpg)'
- en: '[Figure 6-5](text00016.html#ch06fig5) shows the results.'
  id: totrans-8643
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 6-5](text00016.html#ch06fig5) 显示了结果。'
- en: '![Image](Image00139.jpg)'
  id: totrans-8644
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00139.jpg)'
- en: '*Figure 6-5: Printing the squares for each number in the myNumbers array*'
  id: totrans-8645
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 6-5：打印 myNumbers 数组中每个数字的平方*'
- en: '**DICTIONARIES ARE KEY!**'
  id: totrans-8646
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**字典是关键！**'
- en: A *dictionary* is also a collection of values, but instead of an ordered index,
    each value has its own *key* . Because there’s no index, the values are not stored
    in any particular order. To access values in a dictionary, you look them up by
    their key.
  id: totrans-8647
  prefs: []
  type: TYPE_NORMAL
  zh: '*字典*也是一种值的集合，但不同于有序索引，每个值都有自己的*键*。因为没有索引，值并没有按特定顺序存储。要访问字典中的值，你需要通过它们的键来查找。'
- en: A key must be unique. You can’t have the same key more than once in the same
    dictionary. If there were two identical keys and you asked the computer to give
    you the value for one of them, the computer wouldn’t know which one to choose!
  id: totrans-8648
  prefs: []
  type: TYPE_NORMAL
  zh: 键必须是唯一的。同一个字典中不能有相同的键。如果有两个相同的键，并且你请求计算机给你其中一个值，计算机就无法知道选择哪个！
- en: Let’s take a look at how to make a dictionary and write keys that will help
    you find all the information you need.
  id: totrans-8649
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看一下如何创建字典，并写下能够帮助你找到所有需要信息的键。
- en: '![Image](Image00140.jpg)'
  id: totrans-8650
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00140.jpg)'
- en: '**INITIALIZING A DICTIONARY**'
  id: totrans-8651
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**初始化字典**'
- en: 'To create and initialize a dictionary, first write var and the name of your
    dictionary. Then write the keys and corresponding values inside a pair of square
    brackets, similar to an array. Let’s create a dictionary to store the names of
    a few US states. The key for each state will be its two-letter abbreviation:'
  id: totrans-8652
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建并初始化一个字典，首先写上var和字典的名称。然后，在一对方括号内写入键及其对应的值，类似于数组。让我们创建一个字典来存储几个美国州的名称。每个州的键将是它的两个字母的缩写：
- en: '![](Image00141.jpg)'
  id: totrans-8653
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00141.jpg)'
- en: As you can see, there’s a colon between each key and its value, and the key/value
    pairs are separated by commas.
  id: totrans-8654
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，每个键和值之间有一个冒号，键/值对之间用逗号分隔。
- en: Dictionaries are different from arrays in that they are *unordered* . Because
    of that, it’s likely that the order of the states that you see in your results
    pane ➋ is different from the order in which you entered your states ➊ . It might
    even be different than the order that’s printed in this book!
  id: totrans-8655
  prefs: []
  type: TYPE_NORMAL
  zh: 字典与数组的不同之处在于它们是*无序的*。因此，你在结果窗格中看到的州的顺序➋可能与输入这些州时的顺序➊不同。甚至可能与本书中打印的顺序不同！
- en: As with arrays, you can use var to make a mutable dictionary or use let to make
    an immutable dictionary.
  id: totrans-8656
  prefs: []
  type: TYPE_NORMAL
  zh: 与数组一样，你可以使用var来创建一个可变字典，或者使用let来创建一个不可变字典。
- en: 'In Swift, all of the keys of a dictionary must be the same type, and all of
    the values of a dictionary must also be the same type, but the key type doesn’t
    have to match the value type. For example, if you wanted to store a collection
    of fractions, you could use doubles for the keys and strings for the values:'
  id: totrans-8657
  prefs: []
  type: TYPE_NORMAL
  zh: 在Swift中，字典的所有键必须是相同类型，字典的所有值也必须是相同类型，但键的类型不一定要与值的类型匹配。例如，如果你想存储一个分数集合，你可以使用双精度类型作为键，字符串作为值：
- en: '![](Image00142.jpg)'
  id: totrans-8658
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00142.jpg)'
- en: In this dictionary, all of the keys must be doubles, and all of the values must
    be strings. Again, you’ll see that the order of the numbers in the results pane
    can be quite different from the order in which you wrote the fractions in your
    dictionary. This is fine because you don’t need to know the order to access anything.
    You can find any item that you need by its key. Let’s see how!
  id: totrans-8659
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个字典中，所有的键必须是双精度类型，而所有的值必须是字符串类型。同样，你会发现结果窗格中的数字顺序与在字典中写入分数的顺序可能完全不同。这是没问题的，因为你不需要知道顺序来访问任何内容。你可以通过键找到你需要的任何项。让我们看看怎么做！
- en: '**ACCESSING VALUES IN A DICTIONARY**'
  id: totrans-8660
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**访问字典中的值**'
- en: 'Looking up a value in a dictionary is similar to how you access a value in
    an array except that you use a key inside the square brackets instead of an index,
    like this: usStates["TX"] .'
  id: totrans-8661
  prefs: []
  type: TYPE_NORMAL
  zh: 在字典中查找一个值类似于在数组中访问一个值，只不过你是使用键而不是索引，像这样：usStates["TX"]。
- en: There is a big difference, however, in how Swift returns the values from a dictionary.
    When you access a value at an index of an array, you are simply given the value.
    When you access a value with a key in a dictionary, you are given an optional.
  id: totrans-8662
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，Swift在从字典中返回值时有一个很大的不同。当你通过数组的索引访问一个值时，你会直接得到该值。而当你通过字典的键访问一个值时，你得到的是一个可选值。
- en: In [Chapter 5](text00015.html#ch05) , you learned that optionals might contain
    a value or might be nil . The reason Swift returns optionals when you’re looking
    up items in a dictionary is that the key you used might not exist in the dictionary,
    in which case there’s no value to access. Trying to access a value that doesn’t
    exist would give you a big fat error! To avoid that problem, Swift returns optionals.
    That means you need to unwrap any value you get out of a dictionary before you
    can do anything with it.
  id: totrans-8663
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第5章](text00015.html#ch05)中，你学到了可选值可能包含一个值，也可能是 nil。Swift 在查找字典中的项目时返回可选值的原因是，使用的键可能在字典中不存在，在这种情况下没有值可供访问。尝试访问一个不存在的值会导致一个大错误！为了避免这个问题，Swift
    返回可选值。这意味着在你对从字典中获取的任何值进行操作之前，必须先解包它。
- en: 'To unwrap an optional, first you check whether it exists using an if-let statement,
    just like we did in [Chapter 5](text00015.html#ch05) . The following code shows
    you how to get a value out of a dictionary:'
  id: totrans-8664
  prefs: []
  type: TYPE_NORMAL
  zh: 要解包一个可选值，首先使用 if-let 语句检查它是否存在，就像我们在[第5章](text00015.html#ch05)中做的那样。下面的代码展示了如何从字典中获取一个值：
- en: '![Image](Image00143.jpg)'
  id: totrans-8665
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00143.jpg)'
- en: To retrieve "Texas" from the dictionary, we use if let to set a constant loneStarState
    to usStates["TX"] ➊ . Because we have this state in our dictionary, the line I
    have Texas in my dictionary. is printed. Next we try to access a state that is
    not in our dictionary by using the key usStates["FL"] ➋ . Thankfully, because
    we used an if-let statement, the program won’t crash when the computer can’t find
    this state. Instead, I don't have that state in my dictionary. is printed.
  id: totrans-8666
  prefs: []
  type: TYPE_NORMAL
  zh: 要从字典中获取 "Texas"，我们使用 if let 将常量 loneStarState 设置为 usStates["TX"] ➊。因为我们的字典中有这个州，所以打印出“I
    have Texas in my dictionary”。接下来，我们尝试通过使用键 usStates["FL"] ➋ 访问一个不在字典中的州。幸运的是，由于我们使用了
    if-let 语句，当计算机找不到这个州时，程序不会崩溃。相反，打印出“I don't have that state in my dictionary”。
- en: '**ADDING ITEMS TO A DICTIONARY**'
  id: totrans-8667
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**向字典添加项**'
- en: 'To add an item to a dictionary, first write the name of your dictionary and
    assign the new item to the key you want it to have in the dictionary. Let’s add
    "Minnesota" to our usStates dictionary:'
  id: totrans-8668
  prefs: []
  type: TYPE_NORMAL
  zh: 向字典中添加项很简单，首先写出字典的名称，然后将新项赋给你想要在字典中使用的键。我们来将 "Minnesota" 添加到我们的 usStates 字典中：
- en: '![](Image00144.jpg)'
  id: totrans-8669
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00144.jpg)'
- en: 'Now when you look at usStates , you’ll see that it’s updated to ["MN": "Minnesota",
    "WA": "Washington", "MA": "Massachusetts", "TX": "Texas"] . Remember, because
    you don’t have to rely on indices, your new dictionary item might appear anywhere
    in the dictionary.'
  id: totrans-8670
  prefs: []
  type: TYPE_NORMAL
  zh: '现在，当你查看 usStates 时，你会看到它被更新为 ["MN": "Minnesota", "WA": "Washington", "MA":
    "Massachusetts", "TX": "Texas"]。记住，因为你不需要依赖索引，新的字典项可能会出现在字典中的任何位置。'
- en: '**REMOVING ITEMS FROM A DICTIONARY**'
  id: totrans-8671
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**从字典中删除项**'
- en: Removing an item from a dictionary is quite simple; you do so by setting the
    value to nil . Because the values in dictionaries are returned as optionals, you
    don’t have to worry about nil causing any problems in your dictionary.
  id: totrans-8672
  prefs: []
  type: TYPE_NORMAL
  zh: 从字典中删除项也很简单；你只需要将值设置为 nil。因为字典中的值是作为可选值返回的，所以你无需担心 nil 会在字典中引发问题。
- en: '![](Image00145.jpg)'
  id: totrans-8673
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00145.jpg)'
- en: 'You can see that after you remove the value at the key "MA" , usStates is updated
    to ["MN": "Minnesota", "WA": "Washington", "TX": "Texas"] . Remember that nil
    is special and means that there’s no value at all. That’s why you don’t see "MA":
    nil in our dictionary.'
  id: totrans-8674
  prefs: []
  type: TYPE_NORMAL
  zh: '你可以看到，在移除键为 "MA" 的值之后，usStates 更新为 ["MN": "Minnesota", "WA": "Washington",
    "TX": "Texas"]。记住，nil 是特殊的，表示没有任何值。这就是为什么你在字典中看不到 "MA": nil 的原因。'
- en: '**REPLACING ITEMS IN A DICTIONARY**'
  id: totrans-8675
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**在字典中替换项**'
- en: 'Replacing an item in a dictionary is also easy. It works the same was as replacing
    an item in an array. You just set the item that you want to replace to something
    else. Say you create a dictionary of fruit colors:'
  id: totrans-8676
  prefs: []
  type: TYPE_NORMAL
  zh: 替换字典中的项也很简单。它与替换数组中的项一样。你只需要将你想替换的项设置为其他值。例如，你创建一个水果颜色的字典：
- en: '![](Image00146.jpg)'
  id: totrans-8677
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00146.jpg)'
- en: At first we had the value "apple" for "red" , but then we decided that "raspberry"
    is a better fruit to use since sometimes apples are green or yellow. To replace
    "apple" with "raspberry" , we set colorFruits["red"] to its new value ➊ .
  id: totrans-8678
  prefs: []
  type: TYPE_NORMAL
  zh: 一开始我们给“red”赋值为“apple”，但后来我们决定使用“raspberry”作为更好的水果，因为有时候苹果是绿色或黄色的。为了用“raspberry”替代“apple”，我们将
    colorFruits["red"] 设置为它的新值 ➊。
- en: You may remember that this is the same way we entered a new value into a dictionary.
    If the key already exists in the dictionary, then the value for that key is replaced.
    If the key doesn’t already exist, then the new key/value pair will be added to
    the dictionary.
  id: totrans-8679
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能还记得，这与我们将新值插入字典的方式相同。如果键已经存在于字典中，则该键的值会被替换。如果键不存在，那么新的键/值对将被添加到字典中。
- en: '![Image](Image00147.jpg)'
  id: totrans-8680
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00147.jpg)'
- en: '**USING DICTIONARY PROPERTIES**'
  id: totrans-8681
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**使用字典属性**'
- en: 'Like an array, a dictionary also has an isEmpty property and a count property.
    For example, the following code shows how you can use the isEmpty property to
    check if a dictionary is empty, and if it isn’t empty, the count property checks
    how many items you have. Imagine you have a basket of fruit for sale. You can
    use these properties to help you keep track of everything:'
  id: totrans-8682
  prefs: []
  type: TYPE_NORMAL
  zh: 像数组一样，字典也有一个 isEmpty 属性和一个 count 属性。例如，下面的代码展示了如何使用 isEmpty 属性检查字典是否为空，如果不为空，count
    属性则用来检查你有多少个项。想象你有一个出售水果的篮子。你可以使用这些属性来帮助你跟踪一切：
- en: '![Image](Image00148.jpg)'
  id: totrans-8683
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00148.jpg)'
- en: 'A dictionary also has two special properties: keys , which contains all of
    the dictionary’s keys, and values , which contains all of its values. We’ll use
    these two properties when we loop through the dictionary.'
  id: totrans-8684
  prefs: []
  type: TYPE_NORMAL
  zh: 字典还有两个特殊的属性：keys，它包含字典的所有键，和 values，它包含字典的所有值。我们在遍历字典时会使用这两个属性。
- en: Let’s write some code that loops through our fruit baskets and prints the price
    of each fruit.
  id: totrans-8685
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们编写一些代码，遍历我们的水果篮并打印每种水果的价格。
- en: '**LOOPING OVER A DICTIONARY**'
  id: totrans-8686
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**遍历字典**'
- en: 'You can loop through a dictionary using a for-in loop. Because each item has
    a key and a value, you can do this in two different ways. This is how to loop
    through a dictionary using its keys:'
  id: totrans-8687
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用 for-in 循环遍历字典。因为每个项都有一个键和值，所以你可以通过两种不同的方式来完成这件事。以下是如何使用字典的键遍历字典：
- en: '![Image](Image00149.jpg)'
  id: totrans-8688
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00149.jpg)'
- en: Here we use the dictionary’s keys property ➊ to loop through fruitBasket and
    print its contents. We start by writing the keyword for , followed by a constant
    name fruit for the dictionary key, the keyword in , the dictionary name, a period,
    and keys .
  id: totrans-8689
  prefs: []
  type: TYPE_NORMAL
  zh: 这里我们使用字典的 keys 属性 ➊ 遍历 fruitBasket 并打印它的内容。我们从编写关键字 for 开始，后面是一个常量名 fruit 来代表字典的键，接着是关键字
    in、字典名称、一个句点和 keys。
- en: Inside the braces of our for-in loop, we have access to both the key, which
    we call fruit ➋ , and the value at that key when we force-unwrap its contents
    with fruitBasket[fruit]! ➌ . That value will be the fruit’s price.
  id: totrans-8690
  prefs: []
  type: TYPE_NORMAL
  zh: 在 for-in 循环的大括号内，我们可以访问键（我们称之为 fruit ➋）和通过 fruitBasket[fruit]! ➌ 强制解包其内容时的值。这个值将是水果的价格。
- en: In this case, it’s safe to force-unwrap the value using an exclamation point
    because we know that the fruit key we’re using is definitely inside the dictionary.
  id: totrans-8691
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，使用感叹号强制解包值是安全的，因为我们知道我们使用的水果键肯定在字典中。
- en: Any code we put inside the for-in loop will run once for every key in our dictionary.
    So you should see the print statement display three times.
  id: totrans-8692
  prefs: []
  type: TYPE_NORMAL
  zh: 我们放入 for-in 循环中的任何代码都会对字典中的每个键执行一次。因此，你应该能看到打印语句被打印了三次。
- en: 'We can also loop through the dictionary using its values property:'
  id: totrans-8693
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以使用字典的 values 属性遍历字典：
- en: '![Image](Image00150.jpg)'
  id: totrans-8694
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00150.jpg)'
- en: We use the same style of for-in loop, but now we use a constant to refer to
    each value, which we call price , in the values property. When looping through
    values, we don’t have access to the keys from inside the loop.
  id: totrans-8695
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用相同类型的 for-in 循环，但现在我们使用一个常量来引用每个值，我们称之为 price ，它来自 values 属性。在遍历值时，我们无法在循环内部访问键。
- en: Another difference to note is that price is not an optional because it’s accessed
    directly as a value in the fruitBasket dictionary. That means we don’t have to
    unwrap it. You should still see the print statement printed three times. [Figure
    6-6](text00016.html#ch06fig6) shows the output of both loops.
  id: totrans-8696
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个需要注意的区别是，价格（price）不是可选的，因为它是直接作为值从 fruitBasket 字典中访问的。这意味着我们不需要解包它。你应该仍然能看到打印语句被打印了三次。[图
    6-6](text00016.html#ch06fig6)展示了两个循环的输出。
- en: '![Image](Image00151.jpg)'
  id: totrans-8697
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00151.jpg)'
- en: '*Figure 6-6: Looping through the keys and values of a dictionary with a for-in
    loop*'
  id: totrans-8698
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 6-6：使用 for-in 循环遍历字典的键和值*'
- en: The order of your results might be slightly different from ours. That’s because
    the items in a dictionary aren’t in a numbered order like they are in an array!
    And because the order is not guaranteed, you might see a different order printed
    if you run the same code again.
  id: totrans-8699
  prefs: []
  type: TYPE_NORMAL
  zh: 你的结果顺序可能与我们的稍有不同。这是因为字典中的项不像数组那样按编号顺序排列！而且由于顺序没有保证，如果你再次运行相同的代码，可能会看到不同的顺序输出。
- en: '**WHAT YOU LEARNED**'
  id: totrans-8700
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**你学到了什么**'
- en: In this chapter, you learned how to store collections of items in an array and
    in a dictionary. To store items in an ordered list, you would use an array and
    look up each item by its index. If you wanted to store items by key instead, you
    would use a dictionary.
  id: totrans-8701
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你学会了如何在数组和字典中存储项目。要存储有序列表中的项目，你可以使用数组并通过索引查找每个项目。如果你想根据键来存储项目，则应使用字典。
- en: Knowing about arrays and dictionaries and how to use them is a powerful building
    block for almost any programming language. Next we will learn about functions,
    another very powerful tool. Functions are blocks of code that you create and name
    to perform a specific job. After you have written a function, you can use its
    name to call it from almost anywhere in your program.
  id: totrans-8702
  prefs: []
  type: TYPE_NORMAL
  zh: 了解数组和字典以及如何使用它们是几乎任何编程语言中强大的构建块。接下来我们将学习函数，另一个非常强大的工具。函数是你创建并命名的一段代码块，用于执行特定的任务。编写完函数后，你可以通过它的名称从程序的几乎任何地方调用它。
- en: '**LOOPING OVER AN ARRAY**'
  id: totrans-8703
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**遍历数组**'
- en: 'Sometimes when you’re working with arrays you might want to do something to
    every item in the array. You can use a for-in loop to do that! The following code
    will print every topping in a pizzaToppings array on a separate line:'
  id: totrans-8704
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，当你处理数组时，你可能希望对数组中的每个项执行某些操作。你可以使用 for-in 循环来做到这一点！以下代码将在单独的一行中打印 pizzaToppings
    数组中的每一项配料：
- en: '![Image](Image00135.jpg)'
  id: totrans-8705
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Image00135.jpg)'
- en: To write a for-in loop for the pizzaToppings array, we used the keyword for
    , followed by the constant topping , then the keyword in , and finally the name
    of our array, pizzaToppings . Then we put the statements that we want to run for
    each topping inside the braces of the for-in loop. The constant topping ➊ temporarily
    represents each pizza topping in the array as we loop through it. We could have
    chosen any name for this constant, but it’s a good idea to pick something that
    makes sense. You can see the output of this for-in loop in [Figure 6-4](text00016.html#ch06fig4)
    .
  id: totrans-8706
  prefs: []
  type: TYPE_NORMAL
  zh: 为了为 pizzaToppings 数组编写 for-in 循环，我们使用了关键字 for，接着是常量 topping，再是关键字 in，最后是我们的数组名称
    pizzaToppings。然后我们将希望为每个配料执行的语句放在 for-in 循环的大括号内。常量 topping ➊ 在我们遍历数组时暂时表示每一个配料。我们本可以为这个常量选择任何名称，但选择一个有意义的名称是个好主意。你可以在
    [图 6-4](text00016.html#ch06fig4) 中看到这个 for-in 循环的输出。
- en: '![Image](Image00136.jpg)'
  id: totrans-8707
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Image00136.jpg)'
- en: '*Figure 6-4: Output of the example for-in loop*'
  id: totrans-8708
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 6-4：示例 for-in 循环的输出*'
- en: '![Image](Image00137.jpg)'
  id: totrans-8709
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Image00137.jpg)'
- en: 'Using for-in loops is great for printing every value in an array. If you’re
    working with numbers, you can even use them to perform math operations on each
    item, which makes for some speedy calculations! The following code takes an array
    of numbers and calculates the square for each (the square of a number is that
    number multiplied by itself):'
  id: totrans-8710
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 for-in 循环非常适合打印数组中的每一个值。如果你正在处理数字，甚至可以使用它们对每个项进行数学运算，这样就能进行快速计算！以下代码取一个数字数组，并计算每个数字的平方（一个数字的平方是该数字与自身相乘）：
- en: '![Image](Image00138.jpg)'
  id: totrans-8711
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Image00138.jpg)'
- en: '[Figure 6-5](text00016.html#ch06fig5) shows the results.'
  id: totrans-8712
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 6-5](text00016.html#ch06fig5) 显示了结果。'
- en: '![Image](Image00139.jpg)'
  id: totrans-8713
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Image00139.jpg)'
- en: '*Figure 6-5: Printing the squares for each number in the myNumbers array*'
  id: totrans-8714
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 6-5：打印 myNumbers 数组中每个数字的平方*'
- en: '**DICTIONARIES ARE KEY!**'
  id: totrans-8715
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**字典是关键！**'
- en: A *dictionary* is also a collection of values, but instead of an ordered index,
    each value has its own *key* . Because there’s no index, the values are not stored
    in any particular order. To access values in a dictionary, you look them up by
    their key.
  id: totrans-8716
  prefs: []
  type: TYPE_NORMAL
  zh: '*字典* 也是一个值的集合，但与数组不同的是，每个值都有自己的 *键*。由于没有索引，值没有特定的顺序。要访问字典中的值，你需要通过它们的键来查找。'
- en: A key must be unique. You can’t have the same key more than once in the same
    dictionary. If there were two identical keys and you asked the computer to give
    you the value for one of them, the computer wouldn’t know which one to choose!
  id: totrans-8717
  prefs: []
  type: TYPE_NORMAL
  zh: 键必须是唯一的。你不能在同一个字典中使用相同的键。如果有两个相同的键，并且你要求计算机返回其中一个的值，计算机就不知道该选择哪一个！
- en: Let’s take a look at how to make a dictionary and write keys that will help
    you find all the information you need.
  id: totrans-8718
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看一下如何创建一个字典，并写入有助于你找到所需信息的键。
- en: '![Image](Image00140.jpg)'
  id: totrans-8719
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00140.jpg)'
- en: '**INITIALIZING A DICTIONARY**'
  id: totrans-8720
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**初始化字典**'
- en: 'To create and initialize a dictionary, first write var and the name of your
    dictionary. Then write the keys and corresponding values inside a pair of square
    brackets, similar to an array. Let’s create a dictionary to store the names of
    a few US states. The key for each state will be its two-letter abbreviation:'
  id: totrans-8721
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建并初始化一个字典，首先写`var`和字典的名称。然后在一对方括号内写入键和值，类似于数组的方式。让我们创建一个字典来存储一些美国州的名称。每个州的键将是它的两字母缩写：
- en: '![](Image00141.jpg)'
  id: totrans-8722
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00141.jpg)'
- en: As you can see, there’s a colon between each key and its value, and the key/value
    pairs are separated by commas.
  id: totrans-8723
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，每个键和值之间有一个冒号，键/值对之间用逗号分隔。
- en: Dictionaries are different from arrays in that they are *unordered* . Because
    of that, it’s likely that the order of the states that you see in your results
    pane ➋ is different from the order in which you entered your states ➊ . It might
    even be different than the order that’s printed in this book!
  id: totrans-8724
  prefs: []
  type: TYPE_NORMAL
  zh: 字典与数组不同，它们是*无序的*。因此，你在结果面板中看到的州的顺序➋可能与输入州的顺序➊不同。它甚至可能与本书中打印的顺序不同！
- en: As with arrays, you can use var to make a mutable dictionary or use let to make
    an immutable dictionary.
  id: totrans-8725
  prefs: []
  type: TYPE_NORMAL
  zh: 和数组一样，你可以使用`var`来创建一个可变字典，或者使用`let`来创建一个不可变字典。
- en: 'In Swift, all of the keys of a dictionary must be the same type, and all of
    the values of a dictionary must also be the same type, but the key type doesn’t
    have to match the value type. For example, if you wanted to store a collection
    of fractions, you could use doubles for the keys and strings for the values:'
  id: totrans-8726
  prefs: []
  type: TYPE_NORMAL
  zh: 在Swift中，字典的所有键必须是相同类型，字典的所有值也必须是相同类型，但键的类型不必与值的类型匹配。例如，如果你想存储一组分数，你可以使用双精度类型作为键，字符串作为值：
- en: '![](Image00142.jpg)'
  id: totrans-8727
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00142.jpg)'
- en: In this dictionary, all of the keys must be doubles, and all of the values must
    be strings. Again, you’ll see that the order of the numbers in the results pane
    can be quite different from the order in which you wrote the fractions in your
    dictionary. This is fine because you don’t need to know the order to access anything.
    You can find any item that you need by its key. Let’s see how!
  id: totrans-8728
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个字典中，所有的键必须是双精度类型，所有的值必须是字符串类型。同样，你会看到结果面板中的数字顺序可能与在字典中写入分数时的顺序非常不同。这是没问题的，因为你不需要知道顺序就能访问任何项。你可以通过键来找到你需要的任何项目。让我们看看如何做！
- en: '**ACCESSING VALUES IN A DICTIONARY**'
  id: totrans-8729
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**访问字典中的值**'
- en: 'Looking up a value in a dictionary is similar to how you access a value in
    an array except that you use a key inside the square brackets instead of an index,
    like this: usStates["TX"] .'
  id: totrans-8730
  prefs: []
  type: TYPE_NORMAL
  zh: 在字典中查找一个值类似于在数组中访问一个值，只不过你使用的是方括号中的键，而不是索引，像这样：usStates["TX"]。
- en: There is a big difference, however, in how Swift returns the values from a dictionary.
    When you access a value at an index of an array, you are simply given the value.
    When you access a value with a key in a dictionary, you are given an optional.
  id: totrans-8731
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，Swift从字典中返回值的方式有一个很大的区别。当你通过索引访问数组中的值时，你直接得到这个值。当你通过键访问字典中的值时，你得到的是一个可选项。
- en: In [Chapter 5](text00015.html#ch05) , you learned that optionals might contain
    a value or might be nil . The reason Swift returns optionals when you’re looking
    up items in a dictionary is that the key you used might not exist in the dictionary,
    in which case there’s no value to access. Trying to access a value that doesn’t
    exist would give you a big fat error! To avoid that problem, Swift returns optionals.
    That means you need to unwrap any value you get out of a dictionary before you
    can do anything with it.
  id: totrans-8732
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第5章](text00015.html#ch05)中，你学到可选项可能包含一个值，也可能是nil。当你在字典中查找项目时，Swift返回可选项的原因是你使用的键可能在字典中不存在，在这种情况下没有值可供访问。尝试访问一个不存在的值会导致一个错误！为了避免这个问题，Swift返回可选项。这意味着你需要解包从字典中获取的任何值，才能对其进行操作。
- en: 'To unwrap an optional, first you check whether it exists using an if-let statement,
    just like we did in [Chapter 5](text00015.html#ch05) . The following code shows
    you how to get a value out of a dictionary:'
  id: totrans-8733
  prefs: []
  type: TYPE_NORMAL
  zh: 要解包一个可选项，首先使用`if-let`语句检查它是否存在，就像我们在[第5章](text00015.html#ch05)中做的那样。以下代码展示了如何从字典中获取一个值：
- en: '![Image](Image00143.jpg)'
  id: totrans-8734
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00143.jpg)'
- en: To retrieve "Texas" from the dictionary, we use if let to set a constant loneStarState
    to usStates["TX"] ➊ . Because we have this state in our dictionary, the line I
    have Texas in my dictionary. is printed. Next we try to access a state that is
    not in our dictionary by using the key usStates["FL"] ➋ . Thankfully, because
    we used an if-let statement, the program won’t crash when the computer can’t find
    this state. Instead, I don't have that state in my dictionary. is printed.
  id: totrans-8735
  prefs: []
  type: TYPE_NORMAL
  zh: 要从字典中检索 "Texas"，我们使用 if let 将常量 loneStarState 设置为 usStates["TX"] ➊。因为字典中有这个州，所以会打印出
    "I have Texas in my dictionary." 接着，我们尝试使用键 usStates["FL"] ➋ 访问一个不在字典中的州。幸运的是，因为我们使用了
    if-let 语句，当计算机找不到这个州时，程序不会崩溃。相反，会打印出 "I don't have that state in my dictionary."。
- en: '**ADDING ITEMS TO A DICTIONARY**'
  id: totrans-8736
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**向字典添加项**'
- en: 'To add an item to a dictionary, first write the name of your dictionary and
    assign the new item to the key you want it to have in the dictionary. Let’s add
    "Minnesota" to our usStates dictionary:'
  id: totrans-8737
  prefs: []
  type: TYPE_NORMAL
  zh: 要向字典添加项，首先写出字典的名称，并将新项赋值给你希望它在字典中具有的键。让我们将 "Minnesota" 添加到我们的 usStates 字典中：
- en: '![](Image00144.jpg)'
  id: totrans-8738
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00144.jpg)'
- en: 'Now when you look at usStates , you’ll see that it’s updated to ["MN": "Minnesota",
    "WA": "Washington", "MA": "Massachusetts", "TX": "Texas"] . Remember, because
    you don’t have to rely on indices, your new dictionary item might appear anywhere
    in the dictionary.'
  id: totrans-8739
  prefs: []
  type: TYPE_NORMAL
  zh: '现在，当你查看 usStates 时，你会看到它已更新为 ["MN": "Minnesota", "WA": "Washington", "MA":
    "Massachusetts", "TX": "Texas"]。请记住，因为你不需要依赖索引，所以新的字典项可能出现在字典的任何位置。'
- en: '**REMOVING ITEMS FROM A DICTIONARY**'
  id: totrans-8740
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**从字典中移除项**'
- en: Removing an item from a dictionary is quite simple; you do so by setting the
    value to nil . Because the values in dictionaries are returned as optionals, you
    don’t have to worry about nil causing any problems in your dictionary.
  id: totrans-8741
  prefs: []
  type: TYPE_NORMAL
  zh: 从字典中移除一项非常简单；你只需将该值设置为 nil。由于字典中的值是可选的，因此你不必担心 nil 会导致字典出现任何问题。
- en: '![](Image00145.jpg)'
  id: totrans-8742
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00145.jpg)'
- en: 'You can see that after you remove the value at the key "MA" , usStates is updated
    to ["MN": "Minnesota", "WA": "Washington", "TX": "Texas"] . Remember that nil
    is special and means that there’s no value at all. That’s why you don’t see "MA":
    nil in our dictionary.'
  id: totrans-8743
  prefs: []
  type: TYPE_NORMAL
  zh: '你可以看到，在移除键 "MA" 的值后，usStates 更新为 ["MN": "Minnesota", "WA": "Washington", "TX":
    "Texas"]。请记住，nil 是特殊的，表示根本没有值。这就是为什么你在字典中看不到 "MA": nil 的原因。'
- en: '**REPLACING ITEMS IN A DICTIONARY**'
  id: totrans-8744
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**替换字典中的项**'
- en: 'Replacing an item in a dictionary is also easy. It works the same was as replacing
    an item in an array. You just set the item that you want to replace to something
    else. Say you create a dictionary of fruit colors:'
  id: totrans-8745
  prefs: []
  type: TYPE_NORMAL
  zh: 替换字典中的项也很简单。它与替换数组中的项一样。你只需将要替换的项设置为其他内容。假设你创建了一个水果颜色的字典：
- en: '![](Image00146.jpg)'
  id: totrans-8746
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00146.jpg)'
- en: At first we had the value "apple" for "red" , but then we decided that "raspberry"
    is a better fruit to use since sometimes apples are green or yellow. To replace
    "apple" with "raspberry" , we set colorFruits["red"] to its new value ➊ .
  id: totrans-8747
  prefs: []
  type: TYPE_NORMAL
  zh: 一开始，我们为 "red" 设置了 "apple" 的值，但后来我们决定 "raspberry" 是一个更好的水果，因为有时候苹果是绿色或黄色的。为了用
    "raspberry" 替换 "apple"，我们将 colorFruits["red"] 设置为新的值 ➊。
- en: You may remember that this is the same way we entered a new value into a dictionary.
    If the key already exists in the dictionary, then the value for that key is replaced.
    If the key doesn’t already exist, then the new key/value pair will be added to
    the dictionary.
  id: totrans-8748
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能还记得，这和我们将新值添加到字典中的方式一样。如果键已经存在于字典中，那么该键的值将被替换。如果键尚不存在，那么新的键/值对将被添加到字典中。
- en: '![Image](Image00147.jpg)'
  id: totrans-8749
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00147.jpg)'
- en: '**USING DICTIONARY PROPERTIES**'
  id: totrans-8750
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**使用字典属性**'
- en: 'Like an array, a dictionary also has an isEmpty property and a count property.
    For example, the following code shows how you can use the isEmpty property to
    check if a dictionary is empty, and if it isn’t empty, the count property checks
    how many items you have. Imagine you have a basket of fruit for sale. You can
    use these properties to help you keep track of everything:'
  id: totrans-8751
  prefs: []
  type: TYPE_NORMAL
  zh: 像数组一样，字典也有 isEmpty 属性和 count 属性。例如，下面的代码展示了如何使用 isEmpty 属性检查字典是否为空，如果不为空，count
    属性则会检查字典中有多少项。想象你有一个待售的水果篮。你可以使用这些属性帮助你跟踪所有的东西：
- en: '![Image](Image00148.jpg)'
  id: totrans-8752
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00148.jpg)'
- en: 'A dictionary also has two special properties: keys , which contains all of
    the dictionary’s keys, and values , which contains all of its values. We’ll use
    these two properties when we loop through the dictionary.'
  id: totrans-8753
  prefs: []
  type: TYPE_NORMAL
  zh: 字典还有两个特殊的属性：keys，它包含字典的所有键，和 values，它包含字典的所有值。我们将在循环遍历字典时使用这两个属性。
- en: Let’s write some code that loops through our fruit baskets and prints the price
    of each fruit.
  id: totrans-8754
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们编写一些代码，遍历我们的水果篮子，并打印每个水果的价格。
- en: '**LOOPING OVER A DICTIONARY**'
  id: totrans-8755
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**遍历字典**'
- en: 'You can loop through a dictionary using a for-in loop. Because each item has
    a key and a value, you can do this in two different ways. This is how to loop
    through a dictionary using its keys:'
  id: totrans-8756
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用 for-in 循环遍历字典。由于每个项都有一个键和值，你可以用两种不同的方式来做。以下是如何使用字典的键遍历它：
- en: '![Image](Image00149.jpg)'
  id: totrans-8757
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Image00149.jpg)'
- en: Here we use the dictionary’s keys property ➊ to loop through fruitBasket and
    print its contents. We start by writing the keyword for , followed by a constant
    name fruit for the dictionary key, the keyword in , the dictionary name, a period,
    and keys .
  id: totrans-8758
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们使用字典的 keys 属性 ➊ 遍历 fruitBasket 并打印其内容。我们首先编写关键字 for，后跟一个常量名称 fruit 用于字典键，接着是关键字
    in，字典名称，一个句点和 keys。
- en: Inside the braces of our for-in loop, we have access to both the key, which
    we call fruit ➋ , and the value at that key when we force-unwrap its contents
    with fruitBasket[fruit]! ➌ . That value will be the fruit’s price.
  id: totrans-8759
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的 for-in 循环的大括号内，我们可以访问到键，也就是我们称之为 fruit ➋ 的那个键，以及当我们强制解包其内容时，通过 fruitBasket[fruit]!
    ➌ 获取到的键值。这个值将是水果的价格。
- en: In this case, it’s safe to force-unwrap the value using an exclamation point
    because we know that the fruit key we’re using is definitely inside the dictionary.
  id: totrans-8760
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，使用感叹号强制解包值是安全的，因为我们知道我们使用的水果键肯定在字典中。
- en: Any code we put inside the for-in loop will run once for every key in our dictionary.
    So you should see the print statement display three times.
  id: totrans-8761
  prefs: []
  type: TYPE_NORMAL
  zh: 我们放入 for-in 循环中的任何代码都会针对字典中的每个键运行一次。所以你应该看到打印语句显示三次。
- en: 'We can also loop through the dictionary using its values property:'
  id: totrans-8762
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以通过字典的 values 属性遍历字典：
- en: '![Image](Image00150.jpg)'
  id: totrans-8763
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Image00150.jpg)'
- en: We use the same style of for-in loop, but now we use a constant to refer to
    each value, which we call price , in the values property. When looping through
    values, we don’t have access to the keys from inside the loop.
  id: totrans-8764
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用相同类型的 for-in 循环，但现在我们使用一个常量来引用每个值，我们称其为 price，位于 values 属性中。在遍历值时，我们无法从循环内部访问到键。
- en: Another difference to note is that price is not an optional because it’s accessed
    directly as a value in the fruitBasket dictionary. That means we don’t have to
    unwrap it. You should still see the print statement printed three times. [Figure
    6-6](text00016.html#ch06fig6) shows the output of both loops.
  id: totrans-8765
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个需要注意的区别是，price 不是一个可选值，因为它是通过直接在 fruitBasket 字典中访问而获得的。这意味着我们不需要解包它。你应该仍然能看到打印语句会打印三次。[图
    6-6](text00016.html#ch06fig6) 显示了两个循环的输出。
- en: '![Image](Image00151.jpg)'
  id: totrans-8766
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Image00151.jpg)'
- en: '*Figure 6-6: Looping through the keys and values of a dictionary with a for-in
    loop*'
  id: totrans-8767
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 6-6：使用 for-in 循环遍历字典的键和值*'
- en: The order of your results might be slightly different from ours. That’s because
    the items in a dictionary aren’t in a numbered order like they are in an array!
    And because the order is not guaranteed, you might see a different order printed
    if you run the same code again.
  id: totrans-8768
  prefs: []
  type: TYPE_NORMAL
  zh: 你的结果顺序可能与我们的稍有不同。这是因为字典中的项目不像数组中的项目那样按编号排序！由于顺序不能保证，因此如果你再次运行相同的代码，可能会看到不同的顺序打印出来。
- en: '**WHAT YOU LEARNED**'
  id: totrans-8769
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**你学到了什么**'
- en: In this chapter, you learned how to store collections of items in an array and
    in a dictionary. To store items in an ordered list, you would use an array and
    look up each item by its index. If you wanted to store items by key instead, you
    would use a dictionary.
  id: totrans-8770
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一章中，你学习了如何将一组项目存储在数组和字典中。要将项目存储在有序列表中，你会使用数组并通过索引查找每个项目。如果你想通过键存储项目，则会使用字典。
- en: Knowing about arrays and dictionaries and how to use them is a powerful building
    block for almost any programming language. Next we will learn about functions,
    another very powerful tool. Functions are blocks of code that you create and name
    to perform a specific job. After you have written a function, you can use its
    name to call it from almost anywhere in your program.
  id: totrans-8771
  prefs: []
  type: TYPE_NORMAL
  zh: 了解数组和字典以及如何使用它们是几乎所有编程语言中非常强大的构建块。接下来，我们将学习函数，另一个非常强大的工具。函数是你创建并命名的一段代码，用来执行特定任务。编写完一个函数后，你可以使用它的名称在程序中的任何地方调用它。
- en: 'Sometimes when you’re working with arrays you might want to do something to
    every item in the array. You can use a for-in loop to do that! The following code
    will print every topping in a pizzaToppings array on a separate line:'
  id: totrans-8772
  prefs: []
  type: TYPE_NORMAL
  zh: 有时候，当你在处理数组时，你可能希望对数组中的每一项做一些操作。你可以使用for-in循环来实现这一点！以下代码将在每一行打印出pizzaToppings数组中的每一项配料：
- en: '![Image](Image00135.jpg)'
  id: totrans-8773
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00135.jpg)'
- en: To write a for-in loop for the pizzaToppings array, we used the keyword for
    , followed by the constant topping , then the keyword in , and finally the name
    of our array, pizzaToppings . Then we put the statements that we want to run for
    each topping inside the braces of the for-in loop. The constant topping ➊ temporarily
    represents each pizza topping in the array as we loop through it. We could have
    chosen any name for this constant, but it’s a good idea to pick something that
    makes sense. You can see the output of this for-in loop in [Figure 6-4](text00016.html#ch06fig4)
    .
  id: totrans-8774
  prefs: []
  type: TYPE_NORMAL
  zh: 为pizzaToppings数组写for-in循环时，我们使用了关键字for，后跟常量topping，再是关键字in，最后是我们的数组名称pizzaToppings。然后，我们把要对每个配料执行的语句放在for-in循环的大括号内。常量topping➊在我们循环遍历数组时，暂时代表数组中的每个配料。我们可以为这个常量选择任何名字，但最好选择一个有意义的名字。你可以在[图6-4](text00016.html#ch06fig4)中看到这个for-in循环的输出。
- en: '![Image](Image00136.jpg)'
  id: totrans-8775
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00136.jpg)'
- en: '*Figure 6-4: Output of the example for-in loop*'
  id: totrans-8776
  prefs: []
  type: TYPE_NORMAL
  zh: '*图6-4：示例中的for-in循环输出*'
- en: '![Image](Image00137.jpg)'
  id: totrans-8777
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00137.jpg)'
- en: 'Using for-in loops is great for printing every value in an array. If you’re
    working with numbers, you can even use them to perform math operations on each
    item, which makes for some speedy calculations! The following code takes an array
    of numbers and calculates the square for each (the square of a number is that
    number multiplied by itself):'
  id: totrans-8778
  prefs: []
  type: TYPE_NORMAL
  zh: 使用for-in循环非常适合打印数组中的每个值。如果你处理的是数字，你甚至可以用它们对每个项进行数学运算，从而实现快速计算！以下代码取一个数字数组，并计算每个数字的平方（一个数字的平方是该数字乘以它自身）：
- en: '![Image](Image00138.jpg)'
  id: totrans-8779
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00138.jpg)'
- en: '[Figure 6-5](text00016.html#ch06fig5) shows the results.'
  id: totrans-8780
  prefs: []
  type: TYPE_NORMAL
  zh: '[图6-5](text00016.html#ch06fig5)展示了结果。'
- en: '![Image](Image00139.jpg)'
  id: totrans-8781
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00139.jpg)'
- en: '*Figure 6-5: Printing the squares for each number in the myNumbers array*'
  id: totrans-8782
  prefs: []
  type: TYPE_NORMAL
  zh: '*图6-5：打印myNumbers数组中每个数字的平方*'
- en: '**DICTIONARIES ARE KEY!**'
  id: totrans-8783
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**字典至关重要！**'
- en: A *dictionary* is also a collection of values, but instead of an ordered index,
    each value has its own *key* . Because there’s no index, the values are not stored
    in any particular order. To access values in a dictionary, you look them up by
    their key.
  id: totrans-8784
  prefs: []
  type: TYPE_NORMAL
  zh: '*字典*也是一种值的集合，但与有序索引不同，每个值都有自己的*键*。由于没有索引，值的存储顺序是无序的。要访问字典中的值，你需要通过键来查找它们。'
- en: A key must be unique. You can’t have the same key more than once in the same
    dictionary. If there were two identical keys and you asked the computer to give
    you the value for one of them, the computer wouldn’t know which one to choose!
  id: totrans-8785
  prefs: []
  type: TYPE_NORMAL
  zh: 键必须是唯一的。在同一个字典中不能有重复的键。如果有两个相同的键，当你要求计算机返回其中一个键的值时，计算机就不知道该选择哪一个！
- en: Let’s take a look at how to make a dictionary and write keys that will help
    you find all the information you need.
  id: totrans-8786
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看一下如何创建一个字典，并编写有助于你找到所需信息的键。
- en: '![Image](Image00140.jpg)'
  id: totrans-8787
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00140.jpg)'
- en: '**INITIALIZING A DICTIONARY**'
  id: totrans-8788
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**初始化字典**'
- en: 'To create and initialize a dictionary, first write var and the name of your
    dictionary. Then write the keys and corresponding values inside a pair of square
    brackets, similar to an array. Let’s create a dictionary to store the names of
    a few US states. The key for each state will be its two-letter abbreviation:'
  id: totrans-8789
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建和初始化字典，首先写上var和字典的名称。然后在一对方括号内写入键及其对应的值，类似于数组的写法。我们来创建一个字典，用来存储一些美国州的名称。每个州的键将是它的两位字母缩写：
- en: '![](Image00141.jpg)'
  id: totrans-8790
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00141.jpg)'
- en: As you can see, there’s a colon between each key and its value, and the key/value
    pairs are separated by commas.
  id: totrans-8791
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，键和值之间有一个冒号，而键/值对之间由逗号分隔。
- en: Dictionaries are different from arrays in that they are *unordered* . Because
    of that, it’s likely that the order of the states that you see in your results
    pane ➋ is different from the order in which you entered your states ➊ . It might
    even be different than the order that’s printed in this book!
  id: totrans-8792
  prefs: []
  type: TYPE_NORMAL
  zh: 字典与数组不同，它们是*无序的*。因此，你在结果面板中看到的州的顺序➋可能与输入州的顺序➊不同，甚至可能与本书中的顺序不同！
- en: As with arrays, you can use var to make a mutable dictionary or use let to make
    an immutable dictionary.
  id: totrans-8793
  prefs: []
  type: TYPE_NORMAL
  zh: 与数组一样，你可以使用var来创建可变字典，或者使用let来创建不可变字典。
- en: 'In Swift, all of the keys of a dictionary must be the same type, and all of
    the values of a dictionary must also be the same type, but the key type doesn’t
    have to match the value type. For example, if you wanted to store a collection
    of fractions, you could use doubles for the keys and strings for the values:'
  id: totrans-8794
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Swift 中，字典的所有键必须是相同类型的，字典的所有值也必须是相同类型的，但键类型不需要与值类型匹配。例如，如果你想存储一组分数，你可以使用浮动类型作为键，使用字符串作为值：
- en: '![](Image00142.jpg)'
  id: totrans-8795
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00142.jpg)'
- en: In this dictionary, all of the keys must be doubles, and all of the values must
    be strings. Again, you’ll see that the order of the numbers in the results pane
    can be quite different from the order in which you wrote the fractions in your
    dictionary. This is fine because you don’t need to know the order to access anything.
    You can find any item that you need by its key. Let’s see how!
  id: totrans-8796
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个字典中，所有的键必须是浮动类型，所有的值必须是字符串类型。同样，你会看到结果窗格中数字的顺序可能与在字典中书写分数时的顺序完全不同。这是没问题的，因为你不需要知道顺序就可以访问任何内容。你可以通过键来找到任何你需要的项目。让我们来看一下！
- en: '**ACCESSING VALUES IN A DICTIONARY**'
  id: totrans-8797
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**访问字典中的值**'
- en: 'Looking up a value in a dictionary is similar to how you access a value in
    an array except that you use a key inside the square brackets instead of an index,
    like this: usStates["TX"] .'
  id: totrans-8798
  prefs: []
  type: TYPE_NORMAL
  zh: 在字典中查找一个值类似于你在数组中访问值的方式，只不过你在方括号中使用的是键，而不是索引，像这样：`usStates["TX"]`。
- en: There is a big difference, however, in how Swift returns the values from a dictionary.
    When you access a value at an index of an array, you are simply given the value.
    When you access a value with a key in a dictionary, you are given an optional.
  id: totrans-8799
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，Swift 在返回字典中的值时有一个很大的区别。当你通过数组的索引访问一个值时，你只会得到这个值。当你通过字典中的键访问一个值时，你会得到一个可选项。
- en: In [Chapter 5](text00015.html#ch05) , you learned that optionals might contain
    a value or might be nil . The reason Swift returns optionals when you’re looking
    up items in a dictionary is that the key you used might not exist in the dictionary,
    in which case there’s no value to access. Trying to access a value that doesn’t
    exist would give you a big fat error! To avoid that problem, Swift returns optionals.
    That means you need to unwrap any value you get out of a dictionary before you
    can do anything with it.
  id: totrans-8800
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第5章](text00015.html#ch05)中，你学习了可选项可能包含一个值，也可能是 `nil`。Swift 在你查找字典中的项目时返回可选项的原因是，你使用的键可能在字典中不存在，在这种情况下就没有值可以访问。尝试访问一个不存在的值会给你带来一个大错误！为了避免这个问题，Swift
    返回可选项。这意味着你需要在使用字典中获取的任何值之前解包它。
- en: 'To unwrap an optional, first you check whether it exists using an if-let statement,
    just like we did in [Chapter 5](text00015.html#ch05) . The following code shows
    you how to get a value out of a dictionary:'
  id: totrans-8801
  prefs: []
  type: TYPE_NORMAL
  zh: 要解包一个可选项，首先你需要使用 `if-let` 语句检查它是否存在，就像我们在[第5章](text00015.html#ch05)中做的那样。以下代码展示了如何从字典中获取一个值：
- en: '![Image](Image00143.jpg)'
  id: totrans-8802
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00143.jpg)'
- en: To retrieve "Texas" from the dictionary, we use if let to set a constant loneStarState
    to usStates["TX"] ➊ . Because we have this state in our dictionary, the line I
    have Texas in my dictionary. is printed. Next we try to access a state that is
    not in our dictionary by using the key usStates["FL"] ➋ . Thankfully, because
    we used an if-let statement, the program won’t crash when the computer can’t find
    this state. Instead, I don't have that state in my dictionary. is printed.
  id: totrans-8803
  prefs: []
  type: TYPE_NORMAL
  zh: 要从字典中检索 "德克萨斯"，我们使用 `if let` 将常量 `loneStarState` 设置为 `usStates["TX"]` ➊。因为我们在字典中有这个州，所以会打印出
    "我在字典中找到了德克萨斯"。接下来，我们尝试通过键 `usStates["FL"]` ➋ 访问一个不在字典中的州。幸运的是，因为我们使用了 `if-let`
    语句，当计算机找不到这个州时，程序不会崩溃。相反，会打印出 "我在字典中没有这个州"。
- en: '**ADDING ITEMS TO A DICTIONARY**'
  id: totrans-8804
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**向字典中添加项目**'
- en: 'To add an item to a dictionary, first write the name of your dictionary and
    assign the new item to the key you want it to have in the dictionary. Let’s add
    "Minnesota" to our usStates dictionary:'
  id: totrans-8805
  prefs: []
  type: TYPE_NORMAL
  zh: 要向字典中添加一个项目，首先写出你的字典名称，并将新项目分配给你希望它在字典中具有的键。让我们把 "明尼苏达" 添加到我们的 `usStates` 字典中：
- en: '![](Image00144.jpg)'
  id: totrans-8806
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00144.jpg)'
- en: 'Now when you look at usStates , you’ll see that it’s updated to ["MN": "Minnesota",
    "WA": "Washington", "MA": "Massachusetts", "TX": "Texas"] . Remember, because
    you don’t have to rely on indices, your new dictionary item might appear anywhere
    in the dictionary.'
  id: totrans-8807
  prefs: []
  type: TYPE_NORMAL
  zh: '现在当你查看 `usStates` 时，你会看到它已更新为 ["MN": "明尼苏达", "WA": "华盛顿", "MA": "马萨诸塞", "TX":
    "德克萨斯"]。记住，由于你不需要依赖索引，新的字典项可能会出现在字典的任何位置。'
- en: '**REMOVING ITEMS FROM A DICTIONARY**'
  id: totrans-8808
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**从字典中移除项目**'
- en: Removing an item from a dictionary is quite simple; you do so by setting the
    value to nil . Because the values in dictionaries are returned as optionals, you
    don’t have to worry about nil causing any problems in your dictionary.
  id: totrans-8809
  prefs: []
  type: TYPE_NORMAL
  zh: 从字典中移除一个项目也很简单；你只需将值设置为 nil。因为字典中的值是以可选项返回的，所以你不必担心 nil 会在字典中引发任何问题。
- en: '![](Image00145.jpg)'
  id: totrans-8810
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00145.jpg)'
- en: 'You can see that after you remove the value at the key "MA" , usStates is updated
    to ["MN": "Minnesota", "WA": "Washington", "TX": "Texas"] . Remember that nil
    is special and means that there’s no value at all. That’s why you don’t see "MA":
    nil in our dictionary.'
  id: totrans-8811
  prefs: []
  type: TYPE_NORMAL
  zh: '你可以看到，在移除键"MA"的值后，usStates 被更新为 ["MN": "Minnesota", "WA": "Washington", "TX":
    "Texas"]。记住，nil 是特殊的，表示没有任何值。这就是为什么我们在字典中看不到 "MA": nil 的原因。'
- en: '**REPLACING ITEMS IN A DICTIONARY**'
  id: totrans-8812
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**替换字典中的项目**'
- en: 'Replacing an item in a dictionary is also easy. It works the same was as replacing
    an item in an array. You just set the item that you want to replace to something
    else. Say you create a dictionary of fruit colors:'
  id: totrans-8813
  prefs: []
  type: TYPE_NORMAL
  zh: 在字典中替换一个项目也很简单。它的工作方式和替换数组中的项目一样。你只需要将你想替换的项目设置为其他内容。假设你创建了一个水果颜色的字典：
- en: '![](Image00146.jpg)'
  id: totrans-8814
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00146.jpg)'
- en: At first we had the value "apple" for "red" , but then we decided that "raspberry"
    is a better fruit to use since sometimes apples are green or yellow. To replace
    "apple" with "raspberry" , we set colorFruits["red"] to its new value ➊ .
  id: totrans-8815
  prefs: []
  type: TYPE_NORMAL
  zh: 一开始我们给"red"键赋的值是"apple"，但是后来我们决定使用"raspberry"作为更好的水果，因为有时候苹果是绿色或黄色的。为了用"raspberry"替换"apple"，我们将
    colorFruits["red"] 设置为它的新值 ➊。
- en: You may remember that this is the same way we entered a new value into a dictionary.
    If the key already exists in the dictionary, then the value for that key is replaced.
    If the key doesn’t already exist, then the new key/value pair will be added to
    the dictionary.
  id: totrans-8816
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能记得，我们之前是以相同的方式将一个新值加入字典。如果字典中已经存在该键，那么这个键的值会被替换。如果该键不存在，则新的键/值对会被添加到字典中。
- en: '![Image](Image00147.jpg)'
  id: totrans-8817
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00147.jpg)'
- en: '**USING DICTIONARY PROPERTIES**'
  id: totrans-8818
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**使用字典属性**'
- en: 'Like an array, a dictionary also has an isEmpty property and a count property.
    For example, the following code shows how you can use the isEmpty property to
    check if a dictionary is empty, and if it isn’t empty, the count property checks
    how many items you have. Imagine you have a basket of fruit for sale. You can
    use these properties to help you keep track of everything:'
  id: totrans-8819
  prefs: []
  type: TYPE_NORMAL
  zh: 像数组一样，字典也有 isEmpty 属性和 count 属性。例如，以下代码展示了如何使用 isEmpty 属性检查字典是否为空，如果不为空，count
    属性则检查你有多少个项目。假设你有一个待售的水果篮。你可以使用这些属性来帮助你跟踪所有的内容：
- en: '![Image](Image00148.jpg)'
  id: totrans-8820
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00148.jpg)'
- en: 'A dictionary also has two special properties: keys , which contains all of
    the dictionary’s keys, and values , which contains all of its values. We’ll use
    these two properties when we loop through the dictionary.'
  id: totrans-8821
  prefs: []
  type: TYPE_NORMAL
  zh: 字典还有两个特殊属性：keys，包含字典的所有键；values，包含字典的所有值。我们将在遍历字典时使用这两个属性。
- en: Let’s write some code that loops through our fruit baskets and prints the price
    of each fruit.
  id: totrans-8822
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们写些代码，遍历我们的水果篮，并打印每个水果的价格。
- en: '**LOOPING OVER A DICTIONARY**'
  id: totrans-8823
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**遍历字典**'
- en: 'You can loop through a dictionary using a for-in loop. Because each item has
    a key and a value, you can do this in two different ways. This is how to loop
    through a dictionary using its keys:'
  id: totrans-8824
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用 for-in 循环遍历字典。由于每个项目都有一个键和值，你可以用两种不同的方式来做这件事。以下是如何使用键来遍历字典：
- en: '![Image](Image00149.jpg)'
  id: totrans-8825
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00149.jpg)'
- en: Here we use the dictionary’s keys property ➊ to loop through fruitBasket and
    print its contents. We start by writing the keyword for , followed by a constant
    name fruit for the dictionary key, the keyword in , the dictionary name, a period,
    and keys .
  id: totrans-8826
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们使用字典的 keys 属性 ➊ 来遍历 fruitBasket 并打印其内容。我们首先写关键字 for，然后是字典键的常量名称 fruit，接着是关键字
    in，字典名称，接着是一个点，最后是 keys。
- en: Inside the braces of our for-in loop, we have access to both the key, which
    we call fruit ➋ , and the value at that key when we force-unwrap its contents
    with fruitBasket[fruit]! ➌ . That value will be the fruit’s price.
  id: totrans-8827
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的 for-in 循环的大括号内，我们可以访问键，我们称之为 fruit ➋，以及当我们强制解包 fruitBasket[fruit]! ➌ 的内容时，那个键的值。那个值就是水果的价格。
- en: In this case, it’s safe to force-unwrap the value using an exclamation point
    because we know that the fruit key we’re using is definitely inside the dictionary.
  id: totrans-8828
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，使用感叹号强制解包值是安全的，因为我们知道我们使用的水果键肯定在字典中。
- en: Any code we put inside the for-in loop will run once for every key in our dictionary.
    So you should see the print statement display three times.
  id: totrans-8829
  prefs: []
  type: TYPE_NORMAL
  zh: 我们放入 `for-in` 循环中的任何代码都会为字典中的每个键执行一次。所以你应该会看到打印语句显示三次。
- en: 'We can also loop through the dictionary using its values property:'
  id: totrans-8830
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以使用字典的 `values` 属性来遍历字典：
- en: '![Image](Image00150.jpg)'
  id: totrans-8831
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00150.jpg)'
- en: We use the same style of for-in loop, but now we use a constant to refer to
    each value, which we call price , in the values property. When looping through
    values, we don’t have access to the keys from inside the loop.
  id: totrans-8832
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用相同风格的 `for-in` 循环，但现在我们使用常量来引用每个值，我们称之为 `price`，它位于 `values` 属性中。在遍历值时，我们无法从循环内部访问键。
- en: Another difference to note is that price is not an optional because it’s accessed
    directly as a value in the fruitBasket dictionary. That means we don’t have to
    unwrap it. You should still see the print statement printed three times. [Figure
    6-6](text00016.html#ch06fig6) shows the output of both loops.
  id: totrans-8833
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个需要注意的区别是，价格不是一个可选项，因为它直接作为值被访问在 `fruitBasket` 字典中。这意味着我们不需要解包它。你应该仍然会看到打印语句被打印三次。[图
    6-6](text00016.html#ch06fig6) 显示了两个循环的输出结果。
- en: '![Image](Image00151.jpg)'
  id: totrans-8834
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00151.jpg)'
- en: '*Figure 6-6: Looping through the keys and values of a dictionary with a for-in
    loop*'
  id: totrans-8835
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 6-6：使用 `for-in` 循环遍历字典的键和值*'
- en: The order of your results might be slightly different from ours. That’s because
    the items in a dictionary aren’t in a numbered order like they are in an array!
    And because the order is not guaranteed, you might see a different order printed
    if you run the same code again.
  id: totrans-8836
  prefs: []
  type: TYPE_NORMAL
  zh: 你的结果顺序可能与我们的略有不同。这是因为字典中的项目不像数组中的那样有编号顺序！而且由于顺序不保证，如果你再次运行相同的代码，打印的顺序可能会不同。
- en: '**WHAT YOU LEARNED**'
  id: totrans-8837
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**你学到的内容**'
- en: In this chapter, you learned how to store collections of items in an array and
    in a dictionary. To store items in an ordered list, you would use an array and
    look up each item by its index. If you wanted to store items by key instead, you
    would use a dictionary.
  id: totrans-8838
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你学习了如何将多个项目存储在数组和字典中。要将项目存储在有序列表中，你会使用数组，并通过索引查找每个项目。如果你想根据键来存储项目，那么你会使用字典。
- en: Knowing about arrays and dictionaries and how to use them is a powerful building
    block for almost any programming language. Next we will learn about functions,
    another very powerful tool. Functions are blocks of code that you create and name
    to perform a specific job. After you have written a function, you can use its
    name to call it from almost anywhere in your program.
  id: totrans-8839
  prefs: []
  type: TYPE_NORMAL
  zh: 了解数组和字典及其使用方法是几乎所有编程语言中的一个强大构建模块。接下来，我们将学习函数，另一种非常强大的工具。函数是你创建并命名的代码块，用于执行特定的任务。在你编写了一个函数后，你可以通过其名称在程序的几乎任何地方调用它。
- en: '![Image](Image00135.jpg)'
  id: totrans-8840
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00135.jpg)'
- en: To write a for-in loop for the pizzaToppings array, we used the keyword for
    , followed by the constant topping , then the keyword in , and finally the name
    of our array, pizzaToppings . Then we put the statements that we want to run for
    each topping inside the braces of the for-in loop. The constant topping ➊ temporarily
    represents each pizza topping in the array as we loop through it. We could have
    chosen any name for this constant, but it’s a good idea to pick something that
    makes sense. You can see the output of this for-in loop in [Figure 6-4](text00016.html#ch06fig4)
    .
  id: totrans-8841
  prefs: []
  type: TYPE_NORMAL
  zh: 为 `pizzaToppings` 数组编写 `for-in` 循环时，我们使用了关键字 `for`，接着是常量 `topping`，然后是关键字 `in`，最后是数组的名称
    `pizzaToppings`。然后，我们将希望对每个配料执行的语句放入 `for-in` 循环的花括号内。常量 `topping` ➊ 临时代表数组中的每个比萨配料，当我们遍历数组时。我们可以为这个常量选择任何名字，但最好选一个有意义的名字。你可以在
    [图 6-4](text00016.html#ch06fig4) 中看到这个 `for-in` 循环的输出。
- en: '![Image](Image00136.jpg)'
  id: totrans-8842
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00136.jpg)'
- en: '*Figure 6-4: Output of the example for-in loop*'
  id: totrans-8843
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 6-4：示例 `for-in` 循环的输出*'
- en: '![Image](Image00137.jpg)'
  id: totrans-8844
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00137.jpg)'
- en: 'Using for-in loops is great for printing every value in an array. If you’re
    working with numbers, you can even use them to perform math operations on each
    item, which makes for some speedy calculations! The following code takes an array
    of numbers and calculates the square for each (the square of a number is that
    number multiplied by itself):'
  id: totrans-8845
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `for-in` 循环非常适合打印数组中的每个值。如果你正在处理数字，你甚至可以使用它们对每个项进行数学运算，这样就能快速计算！以下代码接受一个数字数组，并计算每个数字的平方（一个数字的平方是该数字与自身相乘）：
- en: '![Image](Image00138.jpg)'
  id: totrans-8846
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00138.jpg)'
- en: '[Figure 6-5](text00016.html#ch06fig5) shows the results.'
  id: totrans-8847
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 6-5](text00016.html#ch06fig5) 显示了结果。'
- en: '![Image](Image00139.jpg)'
  id: totrans-8848
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00139.jpg)'
- en: '*Figure 6-5: Printing the squares for each number in the myNumbers array*'
  id: totrans-8849
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 6-5：打印 myNumbers 数组中每个数字的平方*'
- en: '**DICTIONARIES ARE KEY!**'
  id: totrans-8850
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**字典是关键！**'
- en: A *dictionary* is also a collection of values, but instead of an ordered index,
    each value has its own *key* . Because there’s no index, the values are not stored
    in any particular order. To access values in a dictionary, you look them up by
    their key.
  id: totrans-8851
  prefs: []
  type: TYPE_NORMAL
  zh: '*字典*也是一个值的集合，但与有序索引不同，每个值都有一个自己的*键*。因为没有索引，值不是按任何特定顺序存储的。要访问字典中的值，您需要通过键查找它们。'
- en: A key must be unique. You can’t have the same key more than once in the same
    dictionary. If there were two identical keys and you asked the computer to give
    you the value for one of them, the computer wouldn’t know which one to choose!
  id: totrans-8852
  prefs: []
  type: TYPE_NORMAL
  zh: 每个键必须是唯一的。您不能在同一个字典中使用相同的键两次。如果有两个相同的键，而您请求计算机返回其中一个的值，计算机将不知道选择哪个！
- en: Let’s take a look at how to make a dictionary and write keys that will help
    you find all the information you need.
  id: totrans-8853
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如何创建一个字典，并写出能够帮助您找到所有所需信息的键。
- en: '![Image](Image00140.jpg)'
  id: totrans-8854
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00140.jpg)'
- en: '**INITIALIZING A DICTIONARY**'
  id: totrans-8855
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**初始化字典**'
- en: 'To create and initialize a dictionary, first write var and the name of your
    dictionary. Then write the keys and corresponding values inside a pair of square
    brackets, similar to an array. Let’s create a dictionary to store the names of
    a few US states. The key for each state will be its two-letter abbreviation:'
  id: totrans-8856
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建并初始化字典，首先写 var 和字典的名称。然后将键和值放在一对方括号中，类似于数组。让我们创建一个字典，用来存储一些美国州的名称。每个州的键将是它的两个字母缩写：
- en: '![](Image00141.jpg)'
  id: totrans-8857
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00141.jpg)'
- en: As you can see, there’s a colon between each key and its value, and the key/value
    pairs are separated by commas.
  id: totrans-8858
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您所看到的，每个键和值之间有一个冒号，键值对之间用逗号分隔。
- en: Dictionaries are different from arrays in that they are *unordered* . Because
    of that, it’s likely that the order of the states that you see in your results
    pane ➋ is different from the order in which you entered your states ➊ . It might
    even be different than the order that’s printed in this book!
  id: totrans-8859
  prefs: []
  type: TYPE_NORMAL
  zh: 字典与数组不同，字典是*无序*的。因此，您在结果窗格 ➋ 中看到的状态顺序可能与您输入状态 ➊ 的顺序不同，甚至可能与本书中打印的顺序不同！
- en: As with arrays, you can use var to make a mutable dictionary or use let to make
    an immutable dictionary.
  id: totrans-8860
  prefs: []
  type: TYPE_NORMAL
  zh: 与数组一样，您可以使用 var 来创建一个可变字典，或者使用 let 来创建一个不可变字典。
- en: 'In Swift, all of the keys of a dictionary must be the same type, and all of
    the values of a dictionary must also be the same type, but the key type doesn’t
    have to match the value type. For example, if you wanted to store a collection
    of fractions, you could use doubles for the keys and strings for the values:'
  id: totrans-8861
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Swift 中，字典的所有键必须是相同类型的，字典的所有值也必须是相同类型的，但键的类型不必与值的类型相匹配。例如，如果您想存储一个分数集合，您可以使用
    double 类型作为键，使用字符串类型作为值：
- en: '![](Image00142.jpg)'
  id: totrans-8862
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00142.jpg)'
- en: In this dictionary, all of the keys must be doubles, and all of the values must
    be strings. Again, you’ll see that the order of the numbers in the results pane
    can be quite different from the order in which you wrote the fractions in your
    dictionary. This is fine because you don’t need to know the order to access anything.
    You can find any item that you need by its key. Let’s see how!
  id: totrans-8863
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个字典中，所有的键必须是 double 类型，所有的值必须是字符串类型。同样，您会发现结果窗格中的数字顺序可能与您在字典中编写分数的顺序大不相同。这没关系，因为您不需要知道顺序就能访问任何内容。您可以通过键找到所需的任何项目。让我们看看怎么做！
- en: '**ACCESSING VALUES IN A DICTIONARY**'
  id: totrans-8864
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**访问字典中的值**'
- en: 'Looking up a value in a dictionary is similar to how you access a value in
    an array except that you use a key inside the square brackets instead of an index,
    like this: usStates["TX"] .'
  id: totrans-8865
  prefs: []
  type: TYPE_NORMAL
  zh: 查找字典中的值类似于如何访问数组中的值，只是您使用的是键而不是索引，像这样：usStates["TX"]。
- en: There is a big difference, however, in how Swift returns the values from a dictionary.
    When you access a value at an index of an array, you are simply given the value.
    When you access a value with a key in a dictionary, you are given an optional.
  id: totrans-8866
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，Swift 在从字典返回值时有一个很大的区别。当您通过数组的索引访问值时，您会直接得到该值。当您通过字典的键访问值时，您会得到一个可选值。
- en: In [Chapter 5](text00015.html#ch05) , you learned that optionals might contain
    a value or might be nil . The reason Swift returns optionals when you’re looking
    up items in a dictionary is that the key you used might not exist in the dictionary,
    in which case there’s no value to access. Trying to access a value that doesn’t
    exist would give you a big fat error! To avoid that problem, Swift returns optionals.
    That means you need to unwrap any value you get out of a dictionary before you
    can do anything with it.
  id: totrans-8867
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第5章](text00015.html#ch05)中，你学到了可选值可能包含一个值，也可能是 nil。Swift 在查找字典中的项时返回可选值，因为你使用的键可能在字典中不存在，在这种情况下没有值可以访问。尝试访问一个不存在的值会导致一个严重的错误！为了解决这个问题，Swift
    返回可选值。这意味着你需要解包从字典中获取的任何值，才能对其进行操作。
- en: 'To unwrap an optional, first you check whether it exists using an if-let statement,
    just like we did in [Chapter 5](text00015.html#ch05) . The following code shows
    you how to get a value out of a dictionary:'
  id: totrans-8868
  prefs: []
  type: TYPE_NORMAL
  zh: 要解包一个可选值，首先使用 if-let 语句检查它是否存在，就像我们在[第5章](text00015.html#ch05)中做的那样。以下代码演示了如何从字典中获取一个值：
- en: '![Image](Image00143.jpg)'
  id: totrans-8869
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00143.jpg)'
- en: To retrieve "Texas" from the dictionary, we use if let to set a constant loneStarState
    to usStates["TX"] ➊ . Because we have this state in our dictionary, the line I
    have Texas in my dictionary. is printed. Next we try to access a state that is
    not in our dictionary by using the key usStates["FL"] ➋ . Thankfully, because
    we used an if-let statement, the program won’t crash when the computer can’t find
    this state. Instead, I don't have that state in my dictionary. is printed.
  id: totrans-8870
  prefs: []
  type: TYPE_NORMAL
  zh: 要从字典中获取 "Texas"，我们使用 if-let 来将常量 loneStarState 设置为 usStates["TX"] ➊。因为我们在字典中有这个州，所以会打印出
    "I have Texas in my dictionary." 接下来，我们尝试通过使用键 usStates["FL"] ➋ 访问一个不在字典中的州。幸运的是，由于我们使用了
    if-let 语句，当计算机找不到这个州时，程序不会崩溃。相反，打印出 "I don't have that state in my dictionary."。
- en: '**ADDING ITEMS TO A DICTIONARY**'
  id: totrans-8871
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**向字典添加项**'
- en: 'To add an item to a dictionary, first write the name of your dictionary and
    assign the new item to the key you want it to have in the dictionary. Let’s add
    "Minnesota" to our usStates dictionary:'
  id: totrans-8872
  prefs: []
  type: TYPE_NORMAL
  zh: 要向字典中添加项，首先写出字典的名称，并将新项分配给你希望它在字典中拥有的键。让我们向 usStates 字典中添加 "Minnesota"：
- en: '![](Image00144.jpg)'
  id: totrans-8873
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00144.jpg)'
- en: 'Now when you look at usStates , you’ll see that it’s updated to ["MN": "Minnesota",
    "WA": "Washington", "MA": "Massachusetts", "TX": "Texas"] . Remember, because
    you don’t have to rely on indices, your new dictionary item might appear anywhere
    in the dictionary.'
  id: totrans-8874
  prefs: []
  type: TYPE_NORMAL
  zh: '现在，当你查看 usStates 时，你会看到它已更新为 ["MN": "Minnesota", "WA": "Washington", "MA":
    "Massachusetts", "TX": "Texas"]。记住，由于你不需要依赖索引，你的新字典项可能出现在字典中的任何位置。'
- en: '**REMOVING ITEMS FROM A DICTIONARY**'
  id: totrans-8875
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**从字典中移除项**'
- en: Removing an item from a dictionary is quite simple; you do so by setting the
    value to nil . Because the values in dictionaries are returned as optionals, you
    don’t have to worry about nil causing any problems in your dictionary.
  id: totrans-8876
  prefs: []
  type: TYPE_NORMAL
  zh: 从字典中移除一个项是非常简单的；你只需将值设置为 nil。因为字典中的值是可选类型，所以你不需要担心 nil 会导致字典出现任何问题。
- en: '![](Image00145.jpg)'
  id: totrans-8877
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00145.jpg)'
- en: 'You can see that after you remove the value at the key "MA" , usStates is updated
    to ["MN": "Minnesota", "WA": "Washington", "TX": "Texas"] . Remember that nil
    is special and means that there’s no value at all. That’s why you don’t see "MA":
    nil in our dictionary.'
  id: totrans-8878
  prefs: []
  type: TYPE_NORMAL
  zh: '你可以看到，在移除键“MA”的值后，usStates 被更新为 ["MN": "Minnesota", "WA": "Washington", "TX":
    "Texas"]。请记住，nil 是特殊的，表示完全没有值。这就是为什么在我们的字典中没有看到 "MA": nil。'
- en: '**REPLACING ITEMS IN A DICTIONARY**'
  id: totrans-8879
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**替换字典中的项**'
- en: 'Replacing an item in a dictionary is also easy. It works the same was as replacing
    an item in an array. You just set the item that you want to replace to something
    else. Say you create a dictionary of fruit colors:'
  id: totrans-8880
  prefs: []
  type: TYPE_NORMAL
  zh: 替换字典中的一个项也很容易。它的工作方式和替换数组中的项一样。你只需将要替换的项设置为其他值。假设你创建了一个关于水果颜色的字典：
- en: '![](Image00146.jpg)'
  id: totrans-8881
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00146.jpg)'
- en: At first we had the value "apple" for "red" , but then we decided that "raspberry"
    is a better fruit to use since sometimes apples are green or yellow. To replace
    "apple" with "raspberry" , we set colorFruits["red"] to its new value ➊ .
  id: totrans-8882
  prefs: []
  type: TYPE_NORMAL
  zh: 一开始，我们为 "red" 赋值了 "apple"，但后来我们决定 "raspberry" 是一个更好的水果，因为有时苹果是绿色或黄色的。为了将 "apple"
    替换为 "raspberry"，我们将 colorFruits["red"] 设置为其新值 ➊。
- en: You may remember that this is the same way we entered a new value into a dictionary.
    If the key already exists in the dictionary, then the value for that key is replaced.
    If the key doesn’t already exist, then the new key/value pair will be added to
    the dictionary.
  id: totrans-8883
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能还记得，这与我们往字典中插入新值的方式相同。如果键已经存在于字典中，那么该键的值将被替换。如果键不存在，则新的键/值对将被添加到字典中。
- en: '![Image](Image00147.jpg)'
  id: totrans-8884
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00147.jpg)'
- en: '**USING DICTIONARY PROPERTIES**'
  id: totrans-8885
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**使用字典属性**'
- en: 'Like an array, a dictionary also has an isEmpty property and a count property.
    For example, the following code shows how you can use the isEmpty property to
    check if a dictionary is empty, and if it isn’t empty, the count property checks
    how many items you have. Imagine you have a basket of fruit for sale. You can
    use these properties to help you keep track of everything:'
  id: totrans-8886
  prefs: []
  type: TYPE_NORMAL
  zh: 类似于数组，字典也有`isEmpty`属性和`count`属性。例如，以下代码展示了如何使用`isEmpty`属性来检查字典是否为空，如果不为空，则使用`count`属性来检查字典中有多少个项。假设你有一个待售的水果篮子。你可以利用这些属性帮助你记录所有内容：
- en: '![Image](Image00148.jpg)'
  id: totrans-8887
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00148.jpg)'
- en: 'A dictionary also has two special properties: keys , which contains all of
    the dictionary’s keys, and values , which contains all of its values. We’ll use
    these two properties when we loop through the dictionary.'
  id: totrans-8888
  prefs: []
  type: TYPE_NORMAL
  zh: 字典还有两个特殊的属性：`keys`，它包含字典的所有键；`values`，它包含字典的所有值。当我们遍历字典时，将使用这两个属性。
- en: Let’s write some code that loops through our fruit baskets and prints the price
    of each fruit.
  id: totrans-8889
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们编写一些代码，遍历我们的水果篮并打印每个水果的价格。
- en: '**LOOPING OVER A DICTIONARY**'
  id: totrans-8890
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**遍历字典**'
- en: 'You can loop through a dictionary using a for-in loop. Because each item has
    a key and a value, you can do this in two different ways. This is how to loop
    through a dictionary using its keys:'
  id: totrans-8891
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用`for-in`循环遍历字典。由于每个项都有一个键和值，因此你可以以两种不同的方式来进行遍历。这是如何使用字典的键来遍历字典：
- en: '![Image](Image00149.jpg)'
  id: totrans-8892
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00149.jpg)'
- en: Here we use the dictionary’s keys property ➊ to loop through fruitBasket and
    print its contents. We start by writing the keyword for , followed by a constant
    name fruit for the dictionary key, the keyword in , the dictionary name, a period,
    and keys .
  id: totrans-8893
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们使用字典的`keys`属性➊来遍历`fruitBasket`并打印其内容。我们首先写下`for`关键字，后跟字典键的常量名`fruit`，接着是`in`关键字，字典名称，一个点，最后是`keys`。
- en: Inside the braces of our for-in loop, we have access to both the key, which
    we call fruit ➋ , and the value at that key when we force-unwrap its contents
    with fruitBasket[fruit]! ➌ . That value will be the fruit’s price.
  id: totrans-8894
  prefs: []
  type: TYPE_NORMAL
  zh: 在`for-in`循环的大括号内，我们可以访问到键（我们称之为`fruit` ➋）以及该键的值，当我们通过`fruitBasket[fruit]!`强制解包它的内容时
    ➌。该值将是水果的价格。
- en: In this case, it’s safe to force-unwrap the value using an exclamation point
    because we know that the fruit key we’re using is definitely inside the dictionary.
  id: totrans-8895
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，使用感叹号强制解包值是安全的，因为我们知道所使用的`fruit`键肯定存在于字典中。
- en: Any code we put inside the for-in loop will run once for every key in our dictionary.
    So you should see the print statement display three times.
  id: totrans-8896
  prefs: []
  type: TYPE_NORMAL
  zh: 我们放入`for-in`循环中的任何代码都会针对字典中的每个键执行一次。所以你应该看到打印语句被显示三次。
- en: 'We can also loop through the dictionary using its values property:'
  id: totrans-8897
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以使用字典的`values`属性来遍历字典：
- en: '![Image](Image00150.jpg)'
  id: totrans-8898
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00150.jpg)'
- en: We use the same style of for-in loop, but now we use a constant to refer to
    each value, which we call price , in the values property. When looping through
    values, we don’t have access to the keys from inside the loop.
  id: totrans-8899
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用相同的`for-in`循环风格，但现在我们使用一个常量来引用`values`属性中的每个值，我们将其称为`price`。当遍历`values`时，我们无法从循环内部访问到键。
- en: Another difference to note is that price is not an optional because it’s accessed
    directly as a value in the fruitBasket dictionary. That means we don’t have to
    unwrap it. You should still see the print statement printed three times. [Figure
    6-6](text00016.html#ch06fig6) shows the output of both loops.
  id: totrans-8900
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个需要注意的区别是，`price`不是一个可选值，因为它直接作为值从`fruitBasket`字典中访问。这意味着我们不需要解包它。你仍然应该能看到打印语句打印三次。[图
    6-6](text00016.html#ch06fig6)展示了两个循环的输出。
- en: '![Image](Image00151.jpg)'
  id: totrans-8901
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00151.jpg)'
- en: '*Figure 6-6: Looping through the keys and values of a dictionary with a for-in
    loop*'
  id: totrans-8902
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 6-6：使用`for-in`循环遍历字典的键和值*'
- en: The order of your results might be slightly different from ours. That’s because
    the items in a dictionary aren’t in a numbered order like they are in an array!
    And because the order is not guaranteed, you might see a different order printed
    if you run the same code again.
  id: totrans-8903
  prefs: []
  type: TYPE_NORMAL
  zh: 你的结果顺序可能与我们的稍有不同。这是因为字典中的项不像数组那样按编号顺序排列！由于顺序没有保证，如果你再次运行相同的代码，你可能会看到不同的顺序输出。
- en: '**WHAT YOU LEARNED**'
  id: totrans-8904
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**你学到了什么**'
- en: In this chapter, you learned how to store collections of items in an array and
    in a dictionary. To store items in an ordered list, you would use an array and
    look up each item by its index. If you wanted to store items by key instead, you
    would use a dictionary.
  id: totrans-8905
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你学习了如何将项存储在数组和字典中。要在有序列表中存储项，你会使用数组，并通过索引查找每一项。如果你想通过键来存储项，则会使用字典。
- en: Knowing about arrays and dictionaries and how to use them is a powerful building
    block for almost any programming language. Next we will learn about functions,
    another very powerful tool. Functions are blocks of code that you create and name
    to perform a specific job. After you have written a function, you can use its
    name to call it from almost anywhere in your program.
  id: totrans-8906
  prefs: []
  type: TYPE_NORMAL
  zh: 了解数组和字典以及如何使用它们是几乎任何编程语言的强大构建模块。接下来，我们将学习函数，这是另一种非常强大的工具。函数是你创建并命名的代码块，用于执行特定的任务。在你编写了一个函数之后，你可以在程序的几乎任何地方使用它的名称来调用它。
- en: To write a for-in loop for the pizzaToppings array, we used the keyword for
    , followed by the constant topping , then the keyword in , and finally the name
    of our array, pizzaToppings . Then we put the statements that we want to run for
    each topping inside the braces of the for-in loop. The constant topping ➊ temporarily
    represents each pizza topping in the array as we loop through it. We could have
    chosen any name for this constant, but it’s a good idea to pick something that
    makes sense. You can see the output of this for-in loop in [Figure 6-4](text00016.html#ch06fig4)
    .
  id: totrans-8907
  prefs: []
  type: TYPE_NORMAL
  zh: 为了为pizzaToppings数组编写一个for-in循环，我们使用了关键字for，后跟常量topping，然后是关键字in，最后是我们数组的名称pizzaToppings。接着，我们把要对每个配料运行的语句放在for-in循环的大括号内。常量topping
    ➊暂时表示我们在循环中遍历的每个披萨配料。我们可以为这个常量选择任何名字，但最好选择一个有意义的名字。你可以在[图6-4](text00016.html#ch06fig4)中看到这个for-in循环的输出。
- en: '![Image](Image00136.jpg)'
  id: totrans-8908
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00136.jpg)'
- en: '*Figure 6-4: Output of the example for-in loop*'
  id: totrans-8909
  prefs: []
  type: TYPE_NORMAL
  zh: '*图6-4：示例中的for-in循环输出*'
- en: '![Image](Image00137.jpg)'
  id: totrans-8910
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00137.jpg)'
- en: 'Using for-in loops is great for printing every value in an array. If you’re
    working with numbers, you can even use them to perform math operations on each
    item, which makes for some speedy calculations! The following code takes an array
    of numbers and calculates the square for each (the square of a number is that
    number multiplied by itself):'
  id: totrans-8911
  prefs: []
  type: TYPE_NORMAL
  zh: 使用for-in循环非常适合打印数组中的每个值。如果你处理的是数字，你甚至可以使用它们对每个项执行数学运算，这样可以进行快速计算！以下代码获取一个数字数组并计算每个数字的平方（数字的平方是该数字乘以它自己）：
- en: '![Image](Image00138.jpg)'
  id: totrans-8912
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00138.jpg)'
- en: '[Figure 6-5](text00016.html#ch06fig5) shows the results.'
  id: totrans-8913
  prefs: []
  type: TYPE_NORMAL
  zh: '[图6-5](text00016.html#ch06fig5)展示了结果。'
- en: '![Image](Image00139.jpg)'
  id: totrans-8914
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00139.jpg)'
- en: '*Figure 6-5: Printing the squares for each number in the myNumbers array*'
  id: totrans-8915
  prefs: []
  type: TYPE_NORMAL
  zh: '*图6-5：打印myNumbers数组中每个数字的平方*'
- en: '**DICTIONARIES ARE KEY!**'
  id: totrans-8916
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**字典是关键！**'
- en: A *dictionary* is also a collection of values, but instead of an ordered index,
    each value has its own *key* . Because there’s no index, the values are not stored
    in any particular order. To access values in a dictionary, you look them up by
    their key.
  id: totrans-8917
  prefs: []
  type: TYPE_NORMAL
  zh: '*字典*也是一个值的集合，但与有序索引不同，每个值都有自己的*键*。由于没有索引，值没有以任何特定的顺序存储。要访问字典中的值，你需要通过它们的键来查找。'
- en: A key must be unique. You can’t have the same key more than once in the same
    dictionary. If there were two identical keys and you asked the computer to give
    you the value for one of them, the computer wouldn’t know which one to choose!
  id: totrans-8918
  prefs: []
  type: TYPE_NORMAL
  zh: 键必须是唯一的。你不能在同一个字典中有相同的键。如果有两个相同的键，而你请求计算机给你其中一个的值，计算机将无法知道该选择哪个！
- en: Let’s take a look at how to make a dictionary and write keys that will help
    you find all the information you need.
  id: totrans-8919
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看如何创建一个字典，并编写能够帮助你找到所需信息的键。
- en: '![Image](Image00140.jpg)'
  id: totrans-8920
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00140.jpg)'
- en: '**INITIALIZING A DICTIONARY**'
  id: totrans-8921
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**初始化字典**'
- en: 'To create and initialize a dictionary, first write var and the name of your
    dictionary. Then write the keys and corresponding values inside a pair of square
    brackets, similar to an array. Let’s create a dictionary to store the names of
    a few US states. The key for each state will be its two-letter abbreviation:'
  id: totrans-8922
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建并初始化一个字典，首先写上 var 和字典的名称。然后在一对方括号内写上键和值，类似于数组。我们来创建一个字典来存储一些美国州的名称。每个州的键将是它的两位字母缩写：
- en: '![](Image00141.jpg)'
  id: totrans-8923
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00141.jpg)'
- en: As you can see, there’s a colon between each key and its value, and the key/value
    pairs are separated by commas.
  id: totrans-8924
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，每个键和值之间有一个冒号，并且键/值对之间用逗号分隔。
- en: Dictionaries are different from arrays in that they are *unordered* . Because
    of that, it’s likely that the order of the states that you see in your results
    pane ➋ is different from the order in which you entered your states ➊ . It might
    even be different than the order that’s printed in this book!
  id: totrans-8925
  prefs: []
  type: TYPE_NORMAL
  zh: 字典与数组不同，它们是*无序的*。因此，你在结果面板 ➋ 中看到的州的顺序可能与你输入的顺序 ➊ 不同，甚至可能与书中打印的顺序也不一样！
- en: As with arrays, you can use var to make a mutable dictionary or use let to make
    an immutable dictionary.
  id: totrans-8926
  prefs: []
  type: TYPE_NORMAL
  zh: 和数组一样，你可以使用 var 来创建一个可变字典，或者使用 let 来创建一个不可变字典。
- en: 'In Swift, all of the keys of a dictionary must be the same type, and all of
    the values of a dictionary must also be the same type, but the key type doesn’t
    have to match the value type. For example, if you wanted to store a collection
    of fractions, you could use doubles for the keys and strings for the values:'
  id: totrans-8927
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Swift 中，字典的所有键必须是相同类型，字典的所有值也必须是相同类型，但键类型不必与值类型匹配。例如，如果你想存储一组分数，你可以使用双精度数作为键，字符串作为值：
- en: '![](Image00142.jpg)'
  id: totrans-8928
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00142.jpg)'
- en: In this dictionary, all of the keys must be doubles, and all of the values must
    be strings. Again, you’ll see that the order of the numbers in the results pane
    can be quite different from the order in which you wrote the fractions in your
    dictionary. This is fine because you don’t need to know the order to access anything.
    You can find any item that you need by its key. Let’s see how!
  id: totrans-8929
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个字典中，所有的键必须是双精度数，所有的值必须是字符串。再说一次，你会看到结果面板中数字的顺序可能与字典中写入分数的顺序差异很大。这没关系，因为你不需要知道顺序就可以访问任何东西。你可以通过键找到任何你需要的项目。我们来看一下怎么做！
- en: '**ACCESSING VALUES IN A DICTIONARY**'
  id: totrans-8930
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**访问字典中的值**'
- en: 'Looking up a value in a dictionary is similar to how you access a value in
    an array except that you use a key inside the square brackets instead of an index,
    like this: usStates["TX"] .'
  id: totrans-8931
  prefs: []
  type: TYPE_NORMAL
  zh: 在字典中查找一个值的方式类似于在数组中访问值，不同之处在于你在方括号内使用的是键，而不是索引，比如这样：usStates["TX"]。
- en: There is a big difference, however, in how Swift returns the values from a dictionary.
    When you access a value at an index of an array, you are simply given the value.
    When you access a value with a key in a dictionary, you are given an optional.
  id: totrans-8932
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，Swift 从字典中返回值的方式与数组中的索引访问值有很大的不同。当你在数组的索引位置访问一个值时，你会直接得到这个值。而当你通过键访问字典中的值时，你会得到一个可选值。
- en: In [Chapter 5](text00015.html#ch05) , you learned that optionals might contain
    a value or might be nil . The reason Swift returns optionals when you’re looking
    up items in a dictionary is that the key you used might not exist in the dictionary,
    in which case there’s no value to access. Trying to access a value that doesn’t
    exist would give you a big fat error! To avoid that problem, Swift returns optionals.
    That means you need to unwrap any value you get out of a dictionary before you
    can do anything with it.
  id: totrans-8933
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第5章](text00015.html#ch05)中，你学到过可选值可能包含一个值，也可能是 nil。Swift 在字典中查找项目时返回可选值的原因是你使用的键可能在字典中不存在，在这种情况下就没有值可访问。尝试访问一个不存在的值会给你一个大错误！为避免这个问题，Swift
    返回了可选值。这意味着你需要在使用字典中的任何值之前解包它。
- en: 'To unwrap an optional, first you check whether it exists using an if-let statement,
    just like we did in [Chapter 5](text00015.html#ch05) . The following code shows
    you how to get a value out of a dictionary:'
  id: totrans-8934
  prefs: []
  type: TYPE_NORMAL
  zh: 要解包一个可选值，首先你需要使用 if-let 语句检查它是否存在，就像我们在[第5章](text00015.html#ch05)中所做的那样。下面的代码展示了如何从字典中获取一个值：
- en: '![Image](Image00143.jpg)'
  id: totrans-8935
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00143.jpg)'
- en: To retrieve "Texas" from the dictionary, we use if let to set a constant loneStarState
    to usStates["TX"] ➊ . Because we have this state in our dictionary, the line I
    have Texas in my dictionary. is printed. Next we try to access a state that is
    not in our dictionary by using the key usStates["FL"] ➋ . Thankfully, because
    we used an if-let statement, the program won’t crash when the computer can’t find
    this state. Instead, I don't have that state in my dictionary. is printed.
  id: totrans-8936
  prefs: []
  type: TYPE_NORMAL
  zh: 要从字典中检索 "Texas"，我们使用 if let 将常量 loneStarState 设置为 usStates["TX"] ➊。因为我们的字典中有这个州，所以会打印出
    "I have Texas in my dictionary." 接下来，我们尝试通过使用键 usStates["FL"] ➋ 来访问字典中没有的州。幸运的是，由于我们使用了
    if-let 语句，当计算机找不到这个州时，程序不会崩溃。相反，"I don't have that state in my dictionary." 会被打印出来。
- en: '**ADDING ITEMS TO A DICTIONARY**'
  id: totrans-8937
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**向字典添加项**'
- en: 'To add an item to a dictionary, first write the name of your dictionary and
    assign the new item to the key you want it to have in the dictionary. Let’s add
    "Minnesota" to our usStates dictionary:'
  id: totrans-8938
  prefs: []
  type: TYPE_NORMAL
  zh: 要向字典添加项，首先写出字典的名称，并将新项分配给你希望它在字典中拥有的键。让我们将 "Minnesota" 添加到我们的 usStates 字典中：
- en: '![](Image00144.jpg)'
  id: totrans-8939
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00144.jpg)'
- en: 'Now when you look at usStates , you’ll see that it’s updated to ["MN": "Minnesota",
    "WA": "Washington", "MA": "Massachusetts", "TX": "Texas"] . Remember, because
    you don’t have to rely on indices, your new dictionary item might appear anywhere
    in the dictionary.'
  id: totrans-8940
  prefs: []
  type: TYPE_NORMAL
  zh: '现在，当你查看 usStates 时，你会看到它已更新为 ["MN": "Minnesota", "WA": "Washington", "MA":
    "Massachusetts", "TX": "Texas"]。记住，因为你不需要依赖索引，所以你的新字典项可能出现在字典中的任何位置。'
- en: '**REMOVING ITEMS FROM A DICTIONARY**'
  id: totrans-8941
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**从字典中删除项**'
- en: Removing an item from a dictionary is quite simple; you do so by setting the
    value to nil . Because the values in dictionaries are returned as optionals, you
    don’t have to worry about nil causing any problems in your dictionary.
  id: totrans-8942
  prefs: []
  type: TYPE_NORMAL
  zh: 从字典中删除项非常简单；你只需将该值设置为 nil。由于字典中的值是可选的，你无需担心 nil 会在字典中引发任何问题。
- en: '![](Image00145.jpg)'
  id: totrans-8943
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00145.jpg)'
- en: 'You can see that after you remove the value at the key "MA" , usStates is updated
    to ["MN": "Minnesota", "WA": "Washington", "TX": "Texas"] . Remember that nil
    is special and means that there’s no value at all. That’s why you don’t see "MA":
    nil in our dictionary.'
  id: totrans-8944
  prefs: []
  type: TYPE_NORMAL
  zh: '你可以看到，在删除键 "MA" 对应的值后，usStates 被更新为 ["MN": "Minnesota", "WA": "Washington",
    "TX": "Texas"]。记住，nil 是特殊的，表示没有任何值。这就是为什么你在字典中看不到 "MA": nil 的原因。'
- en: '**REPLACING ITEMS IN A DICTIONARY**'
  id: totrans-8945
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**替换字典中的项**'
- en: 'Replacing an item in a dictionary is also easy. It works the same was as replacing
    an item in an array. You just set the item that you want to replace to something
    else. Say you create a dictionary of fruit colors:'
  id: totrans-8946
  prefs: []
  type: TYPE_NORMAL
  zh: 替换字典中的项也很简单。它的工作方式与替换数组中的项相同。你只需要将要替换的项设置为其他值。例如，你可以创建一个水果颜色的字典：
- en: '![](Image00146.jpg)'
  id: totrans-8947
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00146.jpg)'
- en: At first we had the value "apple" for "red" , but then we decided that "raspberry"
    is a better fruit to use since sometimes apples are green or yellow. To replace
    "apple" with "raspberry" , we set colorFruits["red"] to its new value ➊ .
  id: totrans-8948
  prefs: []
  type: TYPE_NORMAL
  zh: 起初我们为 "red" 设置了值 "apple"，但后来我们决定 "raspberry" 是更合适的水果，因为有时苹果是绿色或黄色的。为了将 "apple"
    替换为 "raspberry"，我们将 colorFruits["red"] 设置为它的新值 ➊。
- en: You may remember that this is the same way we entered a new value into a dictionary.
    If the key already exists in the dictionary, then the value for that key is replaced.
    If the key doesn’t already exist, then the new key/value pair will be added to
    the dictionary.
  id: totrans-8949
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能还记得，这与我们向字典中添加新值的方式相同。如果键已经存在于字典中，那么该键的值会被替换。如果键不存在，则新的键值对将被添加到字典中。
- en: '![Image](Image00147.jpg)'
  id: totrans-8950
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00147.jpg)'
- en: '**USING DICTIONARY PROPERTIES**'
  id: totrans-8951
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**使用字典属性**'
- en: 'Like an array, a dictionary also has an isEmpty property and a count property.
    For example, the following code shows how you can use the isEmpty property to
    check if a dictionary is empty, and if it isn’t empty, the count property checks
    how many items you have. Imagine you have a basket of fruit for sale. You can
    use these properties to help you keep track of everything:'
  id: totrans-8952
  prefs: []
  type: TYPE_NORMAL
  zh: 像数组一样，字典也有一个 isEmpty 属性和一个 count 属性。例如，以下代码展示了如何使用 isEmpty 属性检查字典是否为空，如果字典不为空，则使用
    count 属性检查其中有多少项。假设你有一个水果篮子在卖。你可以使用这些属性来帮助你跟踪一切：
- en: '![Image](Image00148.jpg)'
  id: totrans-8953
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00148.jpg)'
- en: 'A dictionary also has two special properties: keys , which contains all of
    the dictionary’s keys, and values , which contains all of its values. We’ll use
    these two properties when we loop through the dictionary.'
  id: totrans-8954
  prefs: []
  type: TYPE_NORMAL
  zh: 字典还有两个特殊属性：keys，包含字典的所有键；和 values，包含字典的所有值。我们将在遍历字典时使用这两个属性。
- en: Let’s write some code that loops through our fruit baskets and prints the price
    of each fruit.
  id: totrans-8955
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们写一些代码，遍历我们的水果篮，并打印每个水果的价格。
- en: '**LOOPING OVER A DICTIONARY**'
  id: totrans-8956
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**遍历字典**'
- en: 'You can loop through a dictionary using a for-in loop. Because each item has
    a key and a value, you can do this in two different ways. This is how to loop
    through a dictionary using its keys:'
  id: totrans-8957
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用`for-in`循环遍历字典。因为每个项都有一个键和值，所以你可以有两种不同的方式来做到这一点。下面是如何使用字典的键来遍历字典：
- en: '![Image](Image00149.jpg)'
  id: totrans-8958
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00149.jpg)'
- en: Here we use the dictionary’s keys property ➊ to loop through fruitBasket and
    print its contents. We start by writing the keyword for , followed by a constant
    name fruit for the dictionary key, the keyword in , the dictionary name, a period,
    and keys .
  id: totrans-8959
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们使用字典的`keys`属性 ➊ 来遍历`fruitBasket`并打印其内容。我们从编写关键字`for`开始，后跟字典键的常量名`fruit`，关键字`in`，字典名，句点和`keys`。
- en: Inside the braces of our for-in loop, we have access to both the key, which
    we call fruit ➋ , and the value at that key when we force-unwrap its contents
    with fruitBasket[fruit]! ➌ . That value will be the fruit’s price.
  id: totrans-8960
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们`for-in`循环的大括号内，我们既可以访问键（我们称之为`fruit` ➋），也可以访问通过强制解包`fruitBasket[fruit]!`得到的该键的值
    ➌。该值将是水果的价格。
- en: In this case, it’s safe to force-unwrap the value using an exclamation point
    because we know that the fruit key we’re using is definitely inside the dictionary.
  id: totrans-8961
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，使用感叹号强制解包值是安全的，因为我们知道我们使用的果实键一定存在于字典中。
- en: Any code we put inside the for-in loop will run once for every key in our dictionary.
    So you should see the print statement display three times.
  id: totrans-8962
  prefs: []
  type: TYPE_NORMAL
  zh: 我们放入`for-in`循环中的任何代码都会针对字典中的每个键运行一次。所以你应该会看到打印语句显示三次。
- en: 'We can also loop through the dictionary using its values property:'
  id: totrans-8963
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以使用字典的`values`属性来遍历字典：
- en: '![Image](Image00150.jpg)'
  id: totrans-8964
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00150.jpg)'
- en: We use the same style of for-in loop, but now we use a constant to refer to
    each value, which we call price , in the values property. When looping through
    values, we don’t have access to the keys from inside the loop.
  id: totrans-8965
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用相同的`for-in`循环样式，但现在我们使用常量来引用每个值，我们称其为`price`，它位于`values`属性中。在循环遍历值时，我们无法在循环内访问键。
- en: Another difference to note is that price is not an optional because it’s accessed
    directly as a value in the fruitBasket dictionary. That means we don’t have to
    unwrap it. You should still see the print statement printed three times. [Figure
    6-6](text00016.html#ch06fig6) shows the output of both loops.
  id: totrans-8966
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个需要注意的区别是，`price`不是可选的，因为它是直接作为`fruitBasket`字典中的值进行访问的。这意味着我们不需要解包它。你仍然应该看到打印语句打印三次。[图6-6](text00016.html#ch06fig6)显示了两个循环的输出。
- en: '![Image](Image00151.jpg)'
  id: totrans-8967
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00151.jpg)'
- en: '*Figure 6-6: Looping through the keys and values of a dictionary with a for-in
    loop*'
  id: totrans-8968
  prefs: []
  type: TYPE_NORMAL
  zh: '*图6-6：使用`for-in`循环遍历字典的键和值*'
- en: The order of your results might be slightly different from ours. That’s because
    the items in a dictionary aren’t in a numbered order like they are in an array!
    And because the order is not guaranteed, you might see a different order printed
    if you run the same code again.
  id: totrans-8969
  prefs: []
  type: TYPE_NORMAL
  zh: 你的结果顺序可能与我们的略有不同。这是因为字典中的项不像数组那样有编号顺序！而且因为顺序不能保证，如果你再次运行相同的代码，你可能会看到不同的输出顺序。
- en: '**WHAT YOU LEARNED**'
  id: totrans-8970
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**你学到了什么**'
- en: In this chapter, you learned how to store collections of items in an array and
    in a dictionary. To store items in an ordered list, you would use an array and
    look up each item by its index. If you wanted to store items by key instead, you
    would use a dictionary.
  id: totrans-8971
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你学习了如何将项目集合存储在数组和字典中。要将项目存储在有序列表中，你可以使用数组，并通过索引查找每个项目。如果你想按键存储项目，则可以使用字典。
- en: Knowing about arrays and dictionaries and how to use them is a powerful building
    block for almost any programming language. Next we will learn about functions,
    another very powerful tool. Functions are blocks of code that you create and name
    to perform a specific job. After you have written a function, you can use its
    name to call it from almost anywhere in your program.
  id: totrans-8972
  prefs: []
  type: TYPE_NORMAL
  zh: 了解数组和字典以及如何使用它们是几乎所有编程语言中的强大构建块。接下来，我们将学习函数，另一个非常强大的工具。函数是你创建并命名的代码块，用来执行特定的工作。在你编写完一个函数后，你可以在程序中的几乎任何地方通过其名称来调用它。
- en: '![Image](Image00136.jpg)'
  id: totrans-8973
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00136.jpg)'
- en: '*Figure 6-4: Output of the example for-in loop*'
  id: totrans-8974
  prefs: []
  type: TYPE_NORMAL
  zh: '*图6-4：示例`for-in`循环的输出*'
- en: '![Image](Image00137.jpg)'
  id: totrans-8975
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00137.jpg)'
- en: 'Using for-in loops is great for printing every value in an array. If you’re
    working with numbers, you can even use them to perform math operations on each
    item, which makes for some speedy calculations! The following code takes an array
    of numbers and calculates the square for each (the square of a number is that
    number multiplied by itself):'
  id: totrans-8976
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 for-in 循环非常适合打印数组中的每个值。如果你在处理数字，甚至可以用它们对每个项执行数学运算，这样就能进行快速计算！以下代码接受一个数字数组，并计算每个数字的平方（数字的平方是该数字与自身相乘）：
- en: '![Image](Image00138.jpg)'
  id: totrans-8977
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00138.jpg)'
- en: '[Figure 6-5](text00016.html#ch06fig5) shows the results.'
  id: totrans-8978
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 6-5](text00016.html#ch06fig5) 显示了结果。'
- en: '![Image](Image00139.jpg)'
  id: totrans-8979
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00139.jpg)'
- en: '*Figure 6-5: Printing the squares for each number in the myNumbers array*'
  id: totrans-8980
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 6-5：打印 myNumbers 数组中每个数字的平方*'
- en: '**DICTIONARIES ARE KEY!**'
  id: totrans-8981
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**字典至关重要！**'
- en: A *dictionary* is also a collection of values, but instead of an ordered index,
    each value has its own *key* . Because there’s no index, the values are not stored
    in any particular order. To access values in a dictionary, you look them up by
    their key.
  id: totrans-8982
  prefs: []
  type: TYPE_NORMAL
  zh: '*字典* 也是一个值的集合，但不同于有序索引，每个值都有自己的*键*。由于没有索引，值并没有按特定顺序存储。要访问字典中的值，你需要通过键来查找它们。'
- en: A key must be unique. You can’t have the same key more than once in the same
    dictionary. If there were two identical keys and you asked the computer to give
    you the value for one of them, the computer wouldn’t know which one to choose!
  id: totrans-8983
  prefs: []
  type: TYPE_NORMAL
  zh: 键必须是唯一的。你不能在同一个字典中有相同的键。如果有两个相同的键，并且你请求计算机给出其中一个的值，计算机就无法确定选择哪一个！
- en: Let’s take a look at how to make a dictionary and write keys that will help
    you find all the information you need.
  id: totrans-8984
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看如何创建一个字典并编写键，帮助你找到所需的所有信息。
- en: '![Image](Image00140.jpg)'
  id: totrans-8985
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00140.jpg)'
- en: '**INITIALIZING A DICTIONARY**'
  id: totrans-8986
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**初始化字典**'
- en: 'To create and initialize a dictionary, first write var and the name of your
    dictionary. Then write the keys and corresponding values inside a pair of square
    brackets, similar to an array. Let’s create a dictionary to store the names of
    a few US states. The key for each state will be its two-letter abbreviation:'
  id: totrans-8987
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建并初始化一个字典，首先写上 var 和字典的名称。然后在一对方括号内写下键及其对应的值，类似于数组。让我们创建一个字典来存储一些美国州的名称。每个州的键将是它的两个字母缩写：
- en: '![](Image00141.jpg)'
  id: totrans-8988
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00141.jpg)'
- en: As you can see, there’s a colon between each key and its value, and the key/value
    pairs are separated by commas.
  id: totrans-8989
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，每个键和值之间有一个冒号，键/值对由逗号分隔。
- en: Dictionaries are different from arrays in that they are *unordered* . Because
    of that, it’s likely that the order of the states that you see in your results
    pane ➋ is different from the order in which you entered your states ➊ . It might
    even be different than the order that’s printed in this book!
  id: totrans-8990
  prefs: []
  type: TYPE_NORMAL
  zh: 字典与数组不同，因为它们是*无序的*。因此，你在结果面板 ➋ 中看到的状态顺序可能与输入状态的顺序 ➊ 不同，甚至可能与本书中打印的顺序不同！
- en: As with arrays, you can use var to make a mutable dictionary or use let to make
    an immutable dictionary.
  id: totrans-8991
  prefs: []
  type: TYPE_NORMAL
  zh: 与数组一样，你可以使用 var 来创建可变字典，或者使用 let 来创建不可变字典。
- en: 'In Swift, all of the keys of a dictionary must be the same type, and all of
    the values of a dictionary must also be the same type, but the key type doesn’t
    have to match the value type. For example, if you wanted to store a collection
    of fractions, you could use doubles for the keys and strings for the values:'
  id: totrans-8992
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Swift 中，字典的所有键必须是相同类型，字典的所有值也必须是相同类型，但键的类型不必与值的类型匹配。例如，如果你想存储一个分数集合，你可以使用双精度数（doubles）作为键，使用字符串（strings）作为值：
- en: '![](Image00142.jpg)'
  id: totrans-8993
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00142.jpg)'
- en: In this dictionary, all of the keys must be doubles, and all of the values must
    be strings. Again, you’ll see that the order of the numbers in the results pane
    can be quite different from the order in which you wrote the fractions in your
    dictionary. This is fine because you don’t need to know the order to access anything.
    You can find any item that you need by its key. Let’s see how!
  id: totrans-8994
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个字典中，所有键必须是双精度数，所有值必须是字符串。同样，你会看到结果面板中的数字顺序可能与在字典中写下分数的顺序不同。这没关系，因为你不需要知道顺序就可以访问任何内容。你可以通过键找到任何你需要的项。我们来看一下如何操作！
- en: '**ACCESSING VALUES IN A DICTIONARY**'
  id: totrans-8995
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**访问字典中的值**'
- en: 'Looking up a value in a dictionary is similar to how you access a value in
    an array except that you use a key inside the square brackets instead of an index,
    like this: usStates["TX"] .'
  id: totrans-8996
  prefs: []
  type: TYPE_NORMAL
  zh: 在字典中查找一个值类似于你在数组中访问值的方式，不同之处在于你在方括号中使用的是键而不是索引，像这样：usStates["TX"]。
- en: There is a big difference, however, in how Swift returns the values from a dictionary.
    When you access a value at an index of an array, you are simply given the value.
    When you access a value with a key in a dictionary, you are given an optional.
  id: totrans-8997
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在 Swift 返回字典中值的方式上有一个很大的不同。当你访问数组中某个索引的值时，你直接得到该值。而当你用一个键访问字典中的值时，你得到的是一个可选项。
- en: In [Chapter 5](text00015.html#ch05) , you learned that optionals might contain
    a value or might be nil . The reason Swift returns optionals when you’re looking
    up items in a dictionary is that the key you used might not exist in the dictionary,
    in which case there’s no value to access. Trying to access a value that doesn’t
    exist would give you a big fat error! To avoid that problem, Swift returns optionals.
    That means you need to unwrap any value you get out of a dictionary before you
    can do anything with it.
  id: totrans-8998
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第 5 章](text00015.html#ch05)中，你学习了可选项可能包含一个值，也可能是 nil。Swift 返回可选项的原因是在查找字典中的项时，你使用的键可能不存在于字典中，这种情况下就没有值可以访问。尝试访问一个不存在的值会导致一个错误！为了避免这个问题，Swift
    返回可选项。这意味着你需要在对字典中的值做任何操作之前先解包它。
- en: 'To unwrap an optional, first you check whether it exists using an if-let statement,
    just like we did in [Chapter 5](text00015.html#ch05) . The following code shows
    you how to get a value out of a dictionary:'
  id: totrans-8999
  prefs: []
  type: TYPE_NORMAL
  zh: 要解包一个可选项，首先你需要使用 if-let 语句检查它是否存在，就像我们在[第 5 章](text00015.html#ch05)中所做的那样。以下代码展示了如何从字典中获取一个值：
- en: '![Image](Image00143.jpg)'
  id: totrans-9000
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00143.jpg)'
- en: To retrieve "Texas" from the dictionary, we use if let to set a constant loneStarState
    to usStates["TX"] ➊ . Because we have this state in our dictionary, the line I
    have Texas in my dictionary. is printed. Next we try to access a state that is
    not in our dictionary by using the key usStates["FL"] ➋ . Thankfully, because
    we used an if-let statement, the program won’t crash when the computer can’t find
    this state. Instead, I don't have that state in my dictionary. is printed.
  id: totrans-9001
  prefs: []
  type: TYPE_NORMAL
  zh: 要从字典中获取 "Texas"，我们使用 if let 来将常量 loneStarState 设置为 usStates["TX"] ➊。因为我们在字典中有这个州，所以打印出
    "I have Texas in my dictionary."。接下来，我们尝试使用键 usStates["FL"] ➋ 来访问一个不在字典中的州。幸运的是，因为我们使用了
    if-let 语句，当计算机找不到这个州时，程序不会崩溃。相反，打印出 "I don't have that state in my dictionary."。
- en: '**ADDING ITEMS TO A DICTIONARY**'
  id: totrans-9002
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**向字典添加项**'
- en: 'To add an item to a dictionary, first write the name of your dictionary and
    assign the new item to the key you want it to have in the dictionary. Let’s add
    "Minnesota" to our usStates dictionary:'
  id: totrans-9003
  prefs: []
  type: TYPE_NORMAL
  zh: 要向字典中添加一项，首先写出字典的名称，并将新项赋值给你想要它存储的键。让我们把 "Minnesota" 添加到我们的 usStates 字典中：
- en: '![](Image00144.jpg)'
  id: totrans-9004
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00144.jpg)'
- en: 'Now when you look at usStates , you’ll see that it’s updated to ["MN": "Minnesota",
    "WA": "Washington", "MA": "Massachusetts", "TX": "Texas"] . Remember, because
    you don’t have to rely on indices, your new dictionary item might appear anywhere
    in the dictionary.'
  id: totrans-9005
  prefs: []
  type: TYPE_NORMAL
  zh: '现在，当你查看 usStates 时，你会发现它已经更新为 ["MN": "Minnesota", "WA": "Washington", "MA":
    "Massachusetts", "TX": "Texas"]。记住，因为你不必依赖索引，所以新的字典项可能出现在字典的任何位置。'
- en: '**REMOVING ITEMS FROM A DICTIONARY**'
  id: totrans-9006
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**从字典删除项**'
- en: Removing an item from a dictionary is quite simple; you do so by setting the
    value to nil . Because the values in dictionaries are returned as optionals, you
    don’t have to worry about nil causing any problems in your dictionary.
  id: totrans-9007
  prefs: []
  type: TYPE_NORMAL
  zh: 从字典中删除项是相当简单的；你只需将该值设为 nil。因为字典中的值是作为可选项返回的，所以你不必担心 nil 会在字典中引发任何问题。
- en: '![](Image00145.jpg)'
  id: totrans-9008
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00145.jpg)'
- en: 'You can see that after you remove the value at the key "MA" , usStates is updated
    to ["MN": "Minnesota", "WA": "Washington", "TX": "Texas"] . Remember that nil
    is special and means that there’s no value at all. That’s why you don’t see "MA":
    nil in our dictionary.'
  id: totrans-9009
  prefs: []
  type: TYPE_NORMAL
  zh: '你可以看到，在删除键 "MA" 的值后，usStates 被更新为 ["MN": "Minnesota", "WA": "Washington", "TX":
    "Texas"]。记住，nil 是特殊的，意味着根本没有值。因此，你在字典中看不到 "MA": nil。'
- en: '**REPLACING ITEMS IN A DICTIONARY**'
  id: totrans-9010
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**替换字典中的项**'
- en: 'Replacing an item in a dictionary is also easy. It works the same was as replacing
    an item in an array. You just set the item that you want to replace to something
    else. Say you create a dictionary of fruit colors:'
  id: totrans-9011
  prefs: []
  type: TYPE_NORMAL
  zh: 替换字典中的项也很简单。它与替换数组中的项一样。你只需将你想替换的项设置为其他内容。例如，你创建一个水果颜色的字典：
- en: '![](Image00146.jpg)'
  id: totrans-9012
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00146.jpg)'
- en: At first we had the value "apple" for "red" , but then we decided that "raspberry"
    is a better fruit to use since sometimes apples are green or yellow. To replace
    "apple" with "raspberry" , we set colorFruits["red"] to its new value ➊ .
  id: totrans-9013
  prefs: []
  type: TYPE_NORMAL
  zh: 最初我们为 "red" 配置了值 "apple"，但后来我们决定 "raspberry" 是更好的水果，因为有时苹果是绿色或黄色的。要将 "apple"
    替换为 "raspberry"，我们将 `colorFruits["red"]` 设置为它的新值 ➊。
- en: You may remember that this is the same way we entered a new value into a dictionary.
    If the key already exists in the dictionary, then the value for that key is replaced.
    If the key doesn’t already exist, then the new key/value pair will be added to
    the dictionary.
  id: totrans-9014
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能还记得，这和我们向字典中插入新值的方式是一样的。如果键已经存在于字典中，那么该键的值将被替换。如果键不存在，则新的键/值对将被添加到字典中。
- en: '![Image](Image00147.jpg)'
  id: totrans-9015
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Image00147.jpg)'
- en: '**USING DICTIONARY PROPERTIES**'
  id: totrans-9016
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**使用字典属性**'
- en: 'Like an array, a dictionary also has an isEmpty property and a count property.
    For example, the following code shows how you can use the isEmpty property to
    check if a dictionary is empty, and if it isn’t empty, the count property checks
    how many items you have. Imagine you have a basket of fruit for sale. You can
    use these properties to help you keep track of everything:'
  id: totrans-9017
  prefs: []
  type: TYPE_NORMAL
  zh: 和数组一样，字典也有 `isEmpty` 属性和 `count` 属性。例如，以下代码展示了如何使用 `isEmpty` 属性检查字典是否为空，如果不为空，`count`
    属性检查字典中有多少项。假设你有一个待售的水果篮子，你可以使用这些属性来帮助你追踪所有内容：
- en: '![Image](Image00148.jpg)'
  id: totrans-9018
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Image00148.jpg)'
- en: 'A dictionary also has two special properties: keys , which contains all of
    the dictionary’s keys, and values , which contains all of its values. We’ll use
    these two properties when we loop through the dictionary.'
  id: totrans-9019
  prefs: []
  type: TYPE_NORMAL
  zh: 字典还有两个特殊的属性：`keys`，它包含字典的所有键；以及 `values`，它包含字典的所有值。在遍历字典时，我们将使用这两个属性。
- en: Let’s write some code that loops through our fruit baskets and prints the price
    of each fruit.
  id: totrans-9020
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们写一些代码，循环遍历我们的水果篮子并打印每种水果的价格。
- en: '**LOOPING OVER A DICTIONARY**'
  id: totrans-9021
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**遍历字典**'
- en: 'You can loop through a dictionary using a for-in loop. Because each item has
    a key and a value, you can do this in two different ways. This is how to loop
    through a dictionary using its keys:'
  id: totrans-9022
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用 `for-in` 循环遍历字典。因为每个项目都有一个键和值，所以你可以用两种不同的方式来做。以下是通过字典的键来循环的方式：
- en: '![Image](Image00149.jpg)'
  id: totrans-9023
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Image00149.jpg)'
- en: Here we use the dictionary’s keys property ➊ to loop through fruitBasket and
    print its contents. We start by writing the keyword for , followed by a constant
    name fruit for the dictionary key, the keyword in , the dictionary name, a period,
    and keys .
  id: totrans-9024
  prefs: []
  type: TYPE_NORMAL
  zh: 这里我们使用字典的 `keys` 属性 ➊ 来遍历 `fruitBasket` 并打印它的内容。我们首先写上关键字 `for`，接着是常量名 `fruit`，代表字典的键，关键字
    `in`，字典名，一个句点，和 `keys`。
- en: Inside the braces of our for-in loop, we have access to both the key, which
    we call fruit ➋ , and the value at that key when we force-unwrap its contents
    with fruitBasket[fruit]! ➌ . That value will be the fruit’s price.
  id: totrans-9025
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的 `for-in` 循环的花括号内，我们可以访问到键（我们称之为 `fruit` ➋）以及该键的值，当我们强制解包它的内容时，通过 `fruitBasket[fruit]!`
    ➌。这个值将是水果的价格。
- en: In this case, it’s safe to force-unwrap the value using an exclamation point
    because we know that the fruit key we’re using is definitely inside the dictionary.
  id: totrans-9026
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，使用感叹号强制解包值是安全的，因为我们知道我们使用的水果键一定存在于字典中。
- en: Any code we put inside the for-in loop will run once for every key in our dictionary.
    So you should see the print statement display three times.
  id: totrans-9027
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在 `for-in` 循环中放入的任何代码都会对字典中的每个键执行一次。所以你应该看到打印语句被打印了三次。
- en: 'We can also loop through the dictionary using its values property:'
  id: totrans-9028
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以使用字典的 `values` 属性来遍历字典：
- en: '![Image](Image00150.jpg)'
  id: totrans-9029
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Image00150.jpg)'
- en: We use the same style of for-in loop, but now we use a constant to refer to
    each value, which we call price , in the values property. When looping through
    values, we don’t have access to the keys from inside the loop.
  id: totrans-9030
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用相同风格的 `for-in` 循环，但这次我们使用常量来引用值，我们称之为 `price`，它位于 `values` 属性中。在遍历 `values`
    时，我们无法从循环内部访问键。
- en: Another difference to note is that price is not an optional because it’s accessed
    directly as a value in the fruitBasket dictionary. That means we don’t have to
    unwrap it. You should still see the print statement printed three times. [Figure
    6-6](text00016.html#ch06fig6) shows the output of both loops.
  id: totrans-9031
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个需要注意的区别是，`price` 不是一个可选值，因为它是直接作为水果篮子字典中的值来访问的。这意味着我们不需要解包它。你应该依然看到打印语句被打印了三次。[图
    6-6](text00016.html#ch06fig6) 展示了两个循环的输出结果。
- en: '![Image](Image00151.jpg)'
  id: totrans-9032
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Image00151.jpg)'
- en: '*Figure 6-6: Looping through the keys and values of a dictionary with a for-in
    loop*'
  id: totrans-9033
  prefs: []
  type: TYPE_NORMAL
  zh: '*图6-6：使用 for-in 循环遍历字典的键和值*'
- en: The order of your results might be slightly different from ours. That’s because
    the items in a dictionary aren’t in a numbered order like they are in an array!
    And because the order is not guaranteed, you might see a different order printed
    if you run the same code again.
  id: totrans-9034
  prefs: []
  type: TYPE_NORMAL
  zh: 你的结果顺序可能与我们的稍有不同。这是因为字典中的项目不像数组中的项目那样按编号顺序排列！由于顺序不确定，如果你再次运行相同的代码，可能会看到不同的顺序。
- en: '**WHAT YOU LEARNED**'
  id: totrans-9035
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**你学到的内容**'
- en: In this chapter, you learned how to store collections of items in an array and
    in a dictionary. To store items in an ordered list, you would use an array and
    look up each item by its index. If you wanted to store items by key instead, you
    would use a dictionary.
  id: totrans-9036
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一章中，你学习了如何将项目存储在数组和字典中。要将项目存储在有序列表中，你会使用数组，并通过索引查找每个项目。如果你想通过键来存储项目，则会使用字典。
- en: Knowing about arrays and dictionaries and how to use them is a powerful building
    block for almost any programming language. Next we will learn about functions,
    another very powerful tool. Functions are blocks of code that you create and name
    to perform a specific job. After you have written a function, you can use its
    name to call it from almost anywhere in your program.
  id: totrans-9037
  prefs: []
  type: TYPE_NORMAL
  zh: 了解数组和字典及其使用方法，是几乎所有编程语言中的一个强大构建块。接下来我们将学习函数，另一个非常强大的工具。函数是你创建并命名的代码块，用来执行特定任务。在编写完一个函数后，你可以通过它的名称从程序中的几乎任何地方调用它。
- en: '*Figure 6-4: Output of the example for-in loop*'
  id: totrans-9038
  prefs: []
  type: TYPE_NORMAL
  zh: '*图6-4：示例 for-in 循环的输出*'
- en: '![Image](Image00137.jpg)'
  id: totrans-9039
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Image00137.jpg)'
- en: 'Using for-in loops is great for printing every value in an array. If you’re
    working with numbers, you can even use them to perform math operations on each
    item, which makes for some speedy calculations! The following code takes an array
    of numbers and calculates the square for each (the square of a number is that
    number multiplied by itself):'
  id: totrans-9040
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 for-in 循环非常适合打印数组中的每个值。如果你正在处理数字，你甚至可以用它们对每个项执行数学运算，这样就能进行快速计算！以下代码获取一个数字数组，并计算每个数字的平方（一个数字的平方是该数字与自身相乘）：
- en: '![Image](Image00138.jpg)'
  id: totrans-9041
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Image00138.jpg)'
- en: '[Figure 6-5](text00016.html#ch06fig5) shows the results.'
  id: totrans-9042
  prefs: []
  type: TYPE_NORMAL
  zh: '[图6-5](text00016.html#ch06fig5)展示了结果。'
- en: '![Image](Image00139.jpg)'
  id: totrans-9043
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Image00139.jpg)'
- en: '*Figure 6-5: Printing the squares for each number in the myNumbers array*'
  id: totrans-9044
  prefs: []
  type: TYPE_NORMAL
  zh: '*图6-5：打印 myNumbers 数组中每个数字的平方*'
- en: '**DICTIONARIES ARE KEY!**'
  id: totrans-9045
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**字典是关键！**'
- en: A *dictionary* is also a collection of values, but instead of an ordered index,
    each value has its own *key* . Because there’s no index, the values are not stored
    in any particular order. To access values in a dictionary, you look them up by
    their key.
  id: totrans-9046
  prefs: []
  type: TYPE_NORMAL
  zh: 一个 *字典* 也是一组值，但与有序索引不同，每个值都有自己的 *键*。由于没有索引，值并不按任何特定顺序存储。要访问字典中的值，你需要通过其键来查找。
- en: A key must be unique. You can’t have the same key more than once in the same
    dictionary. If there were two identical keys and you asked the computer to give
    you the value for one of them, the computer wouldn’t know which one to choose!
  id: totrans-9047
  prefs: []
  type: TYPE_NORMAL
  zh: 键必须是唯一的。你不能在同一个字典中使用相同的键多次。如果有两个相同的键，并且你要求计算机返回其中一个的值，计算机就无法选择哪个键！
- en: Let’s take a look at how to make a dictionary and write keys that will help
    you find all the information you need.
  id: totrans-9048
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如何创建一个字典，并编写有助于你查找所需信息的键。
- en: '![Image](Image00140.jpg)'
  id: totrans-9049
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Image00140.jpg)'
- en: '**INITIALIZING A DICTIONARY**'
  id: totrans-9050
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**初始化字典**'
- en: 'To create and initialize a dictionary, first write var and the name of your
    dictionary. Then write the keys and corresponding values inside a pair of square
    brackets, similar to an array. Let’s create a dictionary to store the names of
    a few US states. The key for each state will be its two-letter abbreviation:'
  id: totrans-9051
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建并初始化一个字典，首先写 `var` 和你的字典名称。然后将键和值放在一对方括号内，类似于数组的写法。让我们创建一个字典来存储一些美国州的名称。每个州的键将是它的两字母缩写：
- en: '![](Image00141.jpg)'
  id: totrans-9052
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00141.jpg)'
- en: As you can see, there’s a colon between each key and its value, and the key/value
    pairs are separated by commas.
  id: totrans-9053
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，每个键和值之间有一个冒号，键/值对之间用逗号分隔。
- en: Dictionaries are different from arrays in that they are *unordered* . Because
    of that, it’s likely that the order of the states that you see in your results
    pane ➋ is different from the order in which you entered your states ➊ . It might
    even be different than the order that’s printed in this book!
  id: totrans-9054
  prefs: []
  type: TYPE_NORMAL
  zh: 字典与数组不同，字典是*无序的*。因此，你在结果面板中看到的州的顺序 ➋ 可能与输入时的顺序 ➊ 不同，甚至可能与本书中打印的顺序不同！
- en: As with arrays, you can use var to make a mutable dictionary or use let to make
    an immutable dictionary.
  id: totrans-9055
  prefs: []
  type: TYPE_NORMAL
  zh: 与数组一样，你可以使用`var`来创建一个可变字典，或者使用`let`来创建一个不可变字典。
- en: 'In Swift, all of the keys of a dictionary must be the same type, and all of
    the values of a dictionary must also be the same type, but the key type doesn’t
    have to match the value type. For example, if you wanted to store a collection
    of fractions, you could use doubles for the keys and strings for the values:'
  id: totrans-9056
  prefs: []
  type: TYPE_NORMAL
  zh: 在Swift中，字典的所有键必须是相同类型，所有的值也必须是相同类型，但键的类型不必与值的类型匹配。例如，如果你想存储一组分数，你可以使用`double`类型作为键，使用`string`类型作为值：
- en: '![](Image00142.jpg)'
  id: totrans-9057
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00142.jpg)'
- en: In this dictionary, all of the keys must be doubles, and all of the values must
    be strings. Again, you’ll see that the order of the numbers in the results pane
    can be quite different from the order in which you wrote the fractions in your
    dictionary. This is fine because you don’t need to know the order to access anything.
    You can find any item that you need by its key. Let’s see how!
  id: totrans-9058
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个字典中，所有的键必须是`double`类型，所有的值必须是`string`类型。你还会发现，结果面板中数字的顺序可能与在字典中输入分数的顺序完全不同。这没关系，因为你不需要知道顺序来访问任何东西。你可以通过键找到你需要的任何项目。让我们来看一下！
- en: '**ACCESSING VALUES IN A DICTIONARY**'
  id: totrans-9059
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**访问字典中的值**'
- en: 'Looking up a value in a dictionary is similar to how you access a value in
    an array except that you use a key inside the square brackets instead of an index,
    like this: usStates["TX"] .'
  id: totrans-9060
  prefs: []
  type: TYPE_NORMAL
  zh: 在字典中查找值与在数组中查找值类似，只不过你使用的是方括号内的键，而不是索引，例如：usStates["TX"]。
- en: There is a big difference, however, in how Swift returns the values from a dictionary.
    When you access a value at an index of an array, you are simply given the value.
    When you access a value with a key in a dictionary, you are given an optional.
  id: totrans-9061
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，Swift在从字典返回值的方式上有很大的不同。当你通过数组的索引访问值时，你会直接得到值。而当你通过字典的键访问值时，返回的是一个可选值。
- en: In [Chapter 5](text00015.html#ch05) , you learned that optionals might contain
    a value or might be nil . The reason Swift returns optionals when you’re looking
    up items in a dictionary is that the key you used might not exist in the dictionary,
    in which case there’s no value to access. Trying to access a value that doesn’t
    exist would give you a big fat error! To avoid that problem, Swift returns optionals.
    That means you need to unwrap any value you get out of a dictionary before you
    can do anything with it.
  id: totrans-9062
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第5章](text00015.html#ch05)中，你学过可选值可能包含一个值，也可能是`nil`。Swift返回可选值是因为你使用的键可能在字典中不存在，在这种情况下，就没有值可供访问。如果尝试访问一个不存在的值，会导致严重的错误！为了避免这个问题，Swift返回了可选值。这意味着你在对字典中的值进行操作之前，需要先解包它。
- en: 'To unwrap an optional, first you check whether it exists using an if-let statement,
    just like we did in [Chapter 5](text00015.html#ch05) . The following code shows
    you how to get a value out of a dictionary:'
  id: totrans-9063
  prefs: []
  type: TYPE_NORMAL
  zh: 要解包一个可选值，首先你需要通过`if-let`语句检查它是否存在，就像我们在[第5章](text00015.html#ch05)中做的那样。以下代码展示了如何从字典中获取一个值：
- en: '![Image](Image00143.jpg)'
  id: totrans-9064
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00143.jpg)'
- en: To retrieve "Texas" from the dictionary, we use if let to set a constant loneStarState
    to usStates["TX"] ➊ . Because we have this state in our dictionary, the line I
    have Texas in my dictionary. is printed. Next we try to access a state that is
    not in our dictionary by using the key usStates["FL"] ➋ . Thankfully, because
    we used an if-let statement, the program won’t crash when the computer can’t find
    this state. Instead, I don't have that state in my dictionary. is printed.
  id: totrans-9065
  prefs: []
  type: TYPE_NORMAL
  zh: 为了从字典中检索“Texas”，我们使用`if let`语句将常量`loneStarState`设置为`usStates["TX"]` ➊。因为字典中包含这个州，所以输出了“I
    have Texas in my dictionary。”接下来，我们尝试使用不存在于字典中的键`usStates["FL"]` ➋ 来访问一个州。幸运的是，由于我们使用了`if-let`语句，当计算机无法找到该州时，程序不会崩溃。相反，输出了“I
    don't have that state in my dictionary.”。
- en: '**ADDING ITEMS TO A DICTIONARY**'
  id: totrans-9066
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**向字典中添加项目**'
- en: 'To add an item to a dictionary, first write the name of your dictionary and
    assign the new item to the key you want it to have in the dictionary. Let’s add
    "Minnesota" to our usStates dictionary:'
  id: totrans-9067
  prefs: []
  type: TYPE_NORMAL
  zh: 要向字典中添加一个项目，首先写出字典的名称，然后将新项目分配给你希望它在字典中拥有的键。让我们将"Minnesota"添加到我们的usStates字典中：
- en: '![](Image00144.jpg)'
  id: totrans-9068
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00144.jpg)'
- en: 'Now when you look at usStates , you’ll see that it’s updated to ["MN": "Minnesota",
    "WA": "Washington", "MA": "Massachusetts", "TX": "Texas"] . Remember, because
    you don’t have to rely on indices, your new dictionary item might appear anywhere
    in the dictionary.'
  id: totrans-9069
  prefs: []
  type: TYPE_NORMAL
  zh: '现在，当你查看usStates时，你会看到它已更新为["MN": "Minnesota", "WA": "Washington", "MA": "Massachusetts",
    "TX": "Texas"]。记住，因为你不必依赖索引，所以新的字典项可能会出现在字典的任何位置。'
- en: '**REMOVING ITEMS FROM A DICTIONARY**'
  id: totrans-9070
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**从字典中移除项目**'
- en: Removing an item from a dictionary is quite simple; you do so by setting the
    value to nil . Because the values in dictionaries are returned as optionals, you
    don’t have to worry about nil causing any problems in your dictionary.
  id: totrans-9071
  prefs: []
  type: TYPE_NORMAL
  zh: 从字典中移除项目非常简单；你只需将值设置为nil。由于字典中的值是作为可选项返回的，所以你不必担心nil会在字典中引起任何问题。
- en: '![](Image00145.jpg)'
  id: totrans-9072
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00145.jpg)'
- en: 'You can see that after you remove the value at the key "MA" , usStates is updated
    to ["MN": "Minnesota", "WA": "Washington", "TX": "Texas"] . Remember that nil
    is special and means that there’s no value at all. That’s why you don’t see "MA":
    nil in our dictionary.'
  id: totrans-9073
  prefs: []
  type: TYPE_NORMAL
  zh: '你可以看到，在移除键"MA"的值后，usStates更新为["MN": "Minnesota", "WA": "Washington", "TX":
    "Texas"]。记住，nil是特殊的，表示没有任何值。因此，你不会在我们的字典中看到"MA": nil。'
- en: '**REPLACING ITEMS IN A DICTIONARY**'
  id: totrans-9074
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**替换字典中的项目**'
- en: 'Replacing an item in a dictionary is also easy. It works the same was as replacing
    an item in an array. You just set the item that you want to replace to something
    else. Say you create a dictionary of fruit colors:'
  id: totrans-9075
  prefs: []
  type: TYPE_NORMAL
  zh: 替换字典中的项目也很简单。它的工作方式与替换数组中的项目相同。你只需将要替换的项目设置为其他内容。假设你创建了一个水果颜色的字典：
- en: '![](Image00146.jpg)'
  id: totrans-9076
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00146.jpg)'
- en: At first we had the value "apple" for "red" , but then we decided that "raspberry"
    is a better fruit to use since sometimes apples are green or yellow. To replace
    "apple" with "raspberry" , we set colorFruits["red"] to its new value ➊ .
  id: totrans-9077
  prefs: []
  type: TYPE_NORMAL
  zh: 最初，我们为"red"设置了值"apple"，但后来我们决定"raspberry"是更好的水果，因为有时候苹果是绿色或黄色的。为了将"apple"替换为"raspberry"，我们将colorFruits["red"]设置为它的新值➊。
- en: You may remember that this is the same way we entered a new value into a dictionary.
    If the key already exists in the dictionary, then the value for that key is replaced.
    If the key doesn’t already exist, then the new key/value pair will be added to
    the dictionary.
  id: totrans-9078
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能还记得，这就是我们向字典中添加新值的方式。如果键在字典中已存在，那么该键的值将被替换。如果该键不存在，则新的键/值对将被添加到字典中。
- en: '![Image](Image00147.jpg)'
  id: totrans-9079
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00147.jpg)'
- en: '**USING DICTIONARY PROPERTIES**'
  id: totrans-9080
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**使用字典属性**'
- en: 'Like an array, a dictionary also has an isEmpty property and a count property.
    For example, the following code shows how you can use the isEmpty property to
    check if a dictionary is empty, and if it isn’t empty, the count property checks
    how many items you have. Imagine you have a basket of fruit for sale. You can
    use these properties to help you keep track of everything:'
  id: totrans-9081
  prefs: []
  type: TYPE_NORMAL
  zh: 类似于数组，字典也有一个isEmpty属性和一个count属性。例如，下面的代码展示了如何使用isEmpty属性来检查字典是否为空，如果不为空，count属性则可以检查字典中有多少项。假设你有一个待售的水果篮子，你可以利用这些属性来帮助你跟踪所有内容：
- en: '![Image](Image00148.jpg)'
  id: totrans-9082
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00148.jpg)'
- en: 'A dictionary also has two special properties: keys , which contains all of
    the dictionary’s keys, and values , which contains all of its values. We’ll use
    these two properties when we loop through the dictionary.'
  id: totrans-9083
  prefs: []
  type: TYPE_NORMAL
  zh: 字典还有两个特殊的属性：keys，包含字典的所有键，以及values，包含字典的所有值。当我们遍历字典时，将会用到这两个属性。
- en: Let’s write some code that loops through our fruit baskets and prints the price
    of each fruit.
  id: totrans-9084
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们写一些代码，遍历我们的水果篮子并打印每种水果的价格。
- en: '**LOOPING OVER A DICTIONARY**'
  id: totrans-9085
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**遍历字典**'
- en: 'You can loop through a dictionary using a for-in loop. Because each item has
    a key and a value, you can do this in two different ways. This is how to loop
    through a dictionary using its keys:'
  id: totrans-9086
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用for-in循环遍历字典。因为每个项目都有一个键和值，所以你可以用两种不同的方式来遍历字典。这是使用键遍历字典的方式：
- en: '![Image](Image00149.jpg)'
  id: totrans-9087
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00149.jpg)'
- en: Here we use the dictionary’s keys property ➊ to loop through fruitBasket and
    print its contents. We start by writing the keyword for , followed by a constant
    name fruit for the dictionary key, the keyword in , the dictionary name, a period,
    and keys .
  id: totrans-9088
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们使用字典的 keys 属性 ➊ 来遍历 fruitBasket 并打印其内容。我们首先写出关键字 for，后跟一个常量名称 fruit 作为字典的键，接着是关键字
    in，字典名称，句点，再加上 keys。
- en: Inside the braces of our for-in loop, we have access to both the key, which
    we call fruit ➋ , and the value at that key when we force-unwrap its contents
    with fruitBasket[fruit]! ➌ . That value will be the fruit’s price.
  id: totrans-9089
  prefs: []
  type: TYPE_NORMAL
  zh: 在 for-in 循环的大括号内，我们可以访问键，我们称之为 fruit ➋ ，以及通过强制解包其内容（fruitBasket[fruit]! ➌ ）后在该键下的值。这个值将是水果的价格。
- en: In this case, it’s safe to force-unwrap the value using an exclamation point
    because we know that the fruit key we’re using is definitely inside the dictionary.
  id: totrans-9090
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，使用感叹号强制解包值是安全的，因为我们知道我们正在使用的 fruit 键一定存在于字典中。
- en: Any code we put inside the for-in loop will run once for every key in our dictionary.
    So you should see the print statement display three times.
  id: totrans-9091
  prefs: []
  type: TYPE_NORMAL
  zh: 我们放入 for-in 循环中的任何代码都会为字典中的每个键执行一次。因此，你应该看到打印语句显示三次。
- en: 'We can also loop through the dictionary using its values property:'
  id: totrans-9092
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以通过字典的 values 属性来遍历字典：
- en: '![Image](Image00150.jpg)'
  id: totrans-9093
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00150.jpg)'
- en: We use the same style of for-in loop, but now we use a constant to refer to
    each value, which we call price , in the values property. When looping through
    values, we don’t have access to the keys from inside the loop.
  id: totrans-9094
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用相同的 for-in 循环样式，但现在我们使用一个常量来引用 values 属性中的每个值，我们称其为 price。当遍历 values 时，我们无法从循环内部访问键。
- en: Another difference to note is that price is not an optional because it’s accessed
    directly as a value in the fruitBasket dictionary. That means we don’t have to
    unwrap it. You should still see the print statement printed three times. [Figure
    6-6](text00016.html#ch06fig6) shows the output of both loops.
  id: totrans-9095
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个需要注意的区别是，价格不是一个可选类型，因为它是直接作为字典中的值访问的。这意味着我们不需要解包它。你应该仍然看到打印语句显示三次。[图 6-6](text00016.html#ch06fig6)
    显示了两个循环的输出。
- en: '![Image](Image00151.jpg)'
  id: totrans-9096
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00151.jpg)'
- en: '*Figure 6-6: Looping through the keys and values of a dictionary with a for-in
    loop*'
  id: totrans-9097
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 6-6：使用 for-in 循环遍历字典的键和值*'
- en: The order of your results might be slightly different from ours. That’s because
    the items in a dictionary aren’t in a numbered order like they are in an array!
    And because the order is not guaranteed, you might see a different order printed
    if you run the same code again.
  id: totrans-9098
  prefs: []
  type: TYPE_NORMAL
  zh: 你的结果顺序可能与我们的略有不同。这是因为字典中的项目不像数组那样按编号顺序排列！并且由于顺序无法保证，如果你再次运行相同的代码，你可能会看到不同的打印顺序。
- en: '**WHAT YOU LEARNED**'
  id: totrans-9099
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**你学到了什么**'
- en: In this chapter, you learned how to store collections of items in an array and
    in a dictionary. To store items in an ordered list, you would use an array and
    look up each item by its index. If you wanted to store items by key instead, you
    would use a dictionary.
  id: totrans-9100
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一章中，你学会了如何将项目集合存储在数组和字典中。要将项目存储在有序列表中，你需要使用数组并通过索引查找每个项目。如果你想通过键来存储项目，你应该使用字典。
- en: Knowing about arrays and dictionaries and how to use them is a powerful building
    block for almost any programming language. Next we will learn about functions,
    another very powerful tool. Functions are blocks of code that you create and name
    to perform a specific job. After you have written a function, you can use its
    name to call it from almost anywhere in your program.
  id: totrans-9101
  prefs: []
  type: TYPE_NORMAL
  zh: 了解数组和字典以及如何使用它们是几乎所有编程语言中的一个强大构建模块。接下来我们将学习函数，这是另一个非常强大的工具。函数是你创建并命名的代码块，用于执行特定任务。在你编写了一个函数后，你可以通过它的名字在程序的几乎任何地方调用它。
- en: '![Image](Image00137.jpg)'
  id: totrans-9102
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00137.jpg)'
- en: 'Using for-in loops is great for printing every value in an array. If you’re
    working with numbers, you can even use them to perform math operations on each
    item, which makes for some speedy calculations! The following code takes an array
    of numbers and calculates the square for each (the square of a number is that
    number multiplied by itself):'
  id: totrans-9103
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 for-in 循环非常适合打印数组中的每个值。如果你处理的是数字，甚至可以使用它们对每个项目执行数学运算，从而进行快速计算！以下代码获取一个数字数组，并计算每个数字的平方（一个数字的平方是该数字与其自身相乘）：
- en: '![Image](Image00138.jpg)'
  id: totrans-9104
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00138.jpg)'
- en: '[Figure 6-5](text00016.html#ch06fig5) shows the results.'
  id: totrans-9105
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 6-5](text00016.html#ch06fig5) 展示了结果。'
- en: '![Image](Image00139.jpg)'
  id: totrans-9106
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00139.jpg)'
- en: '*Figure 6-5: Printing the squares for each number in the myNumbers array*'
  id: totrans-9107
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 6-5：打印 myNumbers 数组中每个数字的平方*'
- en: '**DICTIONARIES ARE KEY!**'
  id: totrans-9108
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**字典是关键！**'
- en: A *dictionary* is also a collection of values, but instead of an ordered index,
    each value has its own *key* . Because there’s no index, the values are not stored
    in any particular order. To access values in a dictionary, you look them up by
    their key.
  id: totrans-9109
  prefs: []
  type: TYPE_NORMAL
  zh: '*字典* 也是一个值的集合，但与有序索引的数组不同，每个值都有自己的 *键*。由于没有索引，值的存储顺序是无序的。要访问字典中的值，你需要通过键来查找它们。'
- en: A key must be unique. You can’t have the same key more than once in the same
    dictionary. If there were two identical keys and you asked the computer to give
    you the value for one of them, the computer wouldn’t know which one to choose!
  id: totrans-9110
  prefs: []
  type: TYPE_NORMAL
  zh: 键必须是唯一的。你不能在同一个字典中有相同的键。如果有两个相同的键，而你请求计算机给出其中一个的值，计算机将无法选择哪个！
- en: Let’s take a look at how to make a dictionary and write keys that will help
    you find all the information you need.
  id: totrans-9111
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看如何创建一个字典并编写能够帮助你找到所需信息的键。
- en: '![Image](Image00140.jpg)'
  id: totrans-9112
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00140.jpg)'
- en: '**INITIALIZING A DICTIONARY**'
  id: totrans-9113
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**初始化字典**'
- en: 'To create and initialize a dictionary, first write var and the name of your
    dictionary. Then write the keys and corresponding values inside a pair of square
    brackets, similar to an array. Let’s create a dictionary to store the names of
    a few US states. The key for each state will be its two-letter abbreviation:'
  id: totrans-9114
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建并初始化一个字典，首先写上 var 和字典的名称。然后在一对方括号内写上键和值的对应关系，类似于数组的写法。让我们创建一个字典来存储一些美国州的名字。每个州的键将是它的两字母缩写：
- en: '![](Image00141.jpg)'
  id: totrans-9115
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00141.jpg)'
- en: As you can see, there’s a colon between each key and its value, and the key/value
    pairs are separated by commas.
  id: totrans-9116
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，每个键和值之间有一个冒号，键值对之间用逗号分隔。
- en: Dictionaries are different from arrays in that they are *unordered* . Because
    of that, it’s likely that the order of the states that you see in your results
    pane ➋ is different from the order in which you entered your states ➊ . It might
    even be different than the order that’s printed in this book!
  id: totrans-9117
  prefs: []
  type: TYPE_NORMAL
  zh: 字典与数组不同，因为字典是 *无序的*。因此，你在结果窗格中看到的州的顺序 ➋ 可能与输入州的顺序 ➊ 不同。它甚至可能与书中打印的顺序不同！
- en: As with arrays, you can use var to make a mutable dictionary or use let to make
    an immutable dictionary.
  id: totrans-9118
  prefs: []
  type: TYPE_NORMAL
  zh: 与数组一样，你可以使用 var 来创建一个可变字典，或者使用 let 来创建一个不可变字典。
- en: 'In Swift, all of the keys of a dictionary must be the same type, and all of
    the values of a dictionary must also be the same type, but the key type doesn’t
    have to match the value type. For example, if you wanted to store a collection
    of fractions, you could use doubles for the keys and strings for the values:'
  id: totrans-9119
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Swift 中，字典的所有键必须是相同类型的，字典的所有值也必须是相同类型的，但键类型不需要与值类型匹配。例如，如果你想存储一组分数，你可以使用双精度浮点数（doubles）作为键，字符串（strings）作为值：
- en: '![](Image00142.jpg)'
  id: totrans-9120
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00142.jpg)'
- en: In this dictionary, all of the keys must be doubles, and all of the values must
    be strings. Again, you’ll see that the order of the numbers in the results pane
    can be quite different from the order in which you wrote the fractions in your
    dictionary. This is fine because you don’t need to know the order to access anything.
    You can find any item that you need by its key. Let’s see how!
  id: totrans-9121
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个字典中，所有的键必须是双精度浮点数（doubles），所有的值必须是字符串（strings）。再次提醒，你会发现结果窗格中的数字顺序可能与字典中分数的顺序大不相同。这是没问题的，因为你不需要知道顺序来访问任何东西。你可以通过键找到你需要的任何项目。让我们来看看如何操作！
- en: '**ACCESSING VALUES IN A DICTIONARY**'
  id: totrans-9122
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**访问字典中的值**'
- en: 'Looking up a value in a dictionary is similar to how you access a value in
    an array except that you use a key inside the square brackets instead of an index,
    like this: usStates["TX"] .'
  id: totrans-9123
  prefs: []
  type: TYPE_NORMAL
  zh: 查找字典中的值类似于访问数组中的值，不同之处在于你在方括号中使用的是键而不是索引，像这样：usStates["TX"]。
- en: There is a big difference, however, in how Swift returns the values from a dictionary.
    When you access a value at an index of an array, you are simply given the value.
    When you access a value with a key in a dictionary, you are given an optional.
  id: totrans-9124
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，Swift 在从字典中返回值时有一个很大的区别。当你在数组中访问某个索引的值时，你直接得到该值。当你通过字典中的键访问某个值时，你会得到一个可选值（optional）。
- en: In [Chapter 5](text00015.html#ch05) , you learned that optionals might contain
    a value or might be nil . The reason Swift returns optionals when you’re looking
    up items in a dictionary is that the key you used might not exist in the dictionary,
    in which case there’s no value to access. Trying to access a value that doesn’t
    exist would give you a big fat error! To avoid that problem, Swift returns optionals.
    That means you need to unwrap any value you get out of a dictionary before you
    can do anything with it.
  id: totrans-9125
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第5章](text00015.html#ch05)中，你学到了可选值可能包含一个值，也可能为 nil。Swift 返回可选值的原因是，当你在字典中查找项时，你使用的键可能在字典中不存在，这种情况下就没有可访问的值。如果尝试访问一个不存在的值，就会抛出一个错误！为了避免这个问题，Swift
    返回可选值。这意味着在对字典中的任何值进行操作之前，你必须先解包它。
- en: 'To unwrap an optional, first you check whether it exists using an if-let statement,
    just like we did in [Chapter 5](text00015.html#ch05) . The following code shows
    you how to get a value out of a dictionary:'
  id: totrans-9126
  prefs: []
  type: TYPE_NORMAL
  zh: 要解包一个可选值，首先你需要使用 if-let 语句检查它是否存在，就像我们在[第5章](text00015.html#ch05)中做的那样。以下代码展示了如何从字典中获取一个值：
- en: '![Image](Image00143.jpg)'
  id: totrans-9127
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00143.jpg)'
- en: To retrieve "Texas" from the dictionary, we use if let to set a constant loneStarState
    to usStates["TX"] ➊ . Because we have this state in our dictionary, the line I
    have Texas in my dictionary. is printed. Next we try to access a state that is
    not in our dictionary by using the key usStates["FL"] ➋ . Thankfully, because
    we used an if-let statement, the program won’t crash when the computer can’t find
    this state. Instead, I don't have that state in my dictionary. is printed.
  id: totrans-9128
  prefs: []
  type: TYPE_NORMAL
  zh: 要从字典中检索 "Texas"，我们使用 if let 语句将常量 loneStarState 设置为 usStates["TX"] ➊。由于我们在字典中有这个州，所以会打印出
    "I have Texas in my dictionary." 接下来，我们尝试访问一个不存在于字典中的州，使用键 usStates["FL"] ➋。幸运的是，由于我们使用了
    if-let 语句，当计算机找不到这个州时，程序不会崩溃。相反，会打印出 "I don't have that state in my dictionary."
- en: '**ADDING ITEMS TO A DICTIONARY**'
  id: totrans-9129
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**向字典中添加项**'
- en: 'To add an item to a dictionary, first write the name of your dictionary and
    assign the new item to the key you want it to have in the dictionary. Let’s add
    "Minnesota" to our usStates dictionary:'
  id: totrans-9130
  prefs: []
  type: TYPE_NORMAL
  zh: 要向字典添加项，首先写出字典的名称，然后将新项分配给你希望它在字典中对应的键。让我们将 "Minnesota" 添加到我们的 usStates 字典中：
- en: '![](Image00144.jpg)'
  id: totrans-9131
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00144.jpg)'
- en: 'Now when you look at usStates , you’ll see that it’s updated to ["MN": "Minnesota",
    "WA": "Washington", "MA": "Massachusetts", "TX": "Texas"] . Remember, because
    you don’t have to rely on indices, your new dictionary item might appear anywhere
    in the dictionary.'
  id: totrans-9132
  prefs: []
  type: TYPE_NORMAL
  zh: '现在，当你查看 usStates 时，你会看到它已经更新为 ["MN": "Minnesota", "WA": "Washington", "MA":
    "Massachusetts", "TX": "Texas"]。记住，因为你不需要依赖索引，所以新的字典项可能出现在字典的任何位置。'
- en: '**REMOVING ITEMS FROM A DICTIONARY**'
  id: totrans-9133
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**从字典中移除项**'
- en: Removing an item from a dictionary is quite simple; you do so by setting the
    value to nil . Because the values in dictionaries are returned as optionals, you
    don’t have to worry about nil causing any problems in your dictionary.
  id: totrans-9134
  prefs: []
  type: TYPE_NORMAL
  zh: 从字典中移除项非常简单；你只需将值设置为 nil。因为字典中的值是以可选值的形式返回的，所以你不必担心 nil 会在字典中引发任何问题。
- en: '![](Image00145.jpg)'
  id: totrans-9135
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00145.jpg)'
- en: 'You can see that after you remove the value at the key "MA" , usStates is updated
    to ["MN": "Minnesota", "WA": "Washington", "TX": "Texas"] . Remember that nil
    is special and means that there’s no value at all. That’s why you don’t see "MA":
    nil in our dictionary.'
  id: totrans-9136
  prefs: []
  type: TYPE_NORMAL
  zh: '你可以看到，当你移除键 "MA" 对应的值后，usStates 更新为 ["MN": "Minnesota", "WA": "Washington",
    "TX": "Texas"]。记住，nil 是特别的，表示没有值。这就是为什么在字典中看不到 "MA": nil 的原因。'
- en: '**REPLACING ITEMS IN A DICTIONARY**'
  id: totrans-9137
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**替换字典中的项**'
- en: 'Replacing an item in a dictionary is also easy. It works the same was as replacing
    an item in an array. You just set the item that you want to replace to something
    else. Say you create a dictionary of fruit colors:'
  id: totrans-9138
  prefs: []
  type: TYPE_NORMAL
  zh: 替换字典中的项也很简单。它的操作方式与替换数组中的项相同。你只需将要替换的项设置为其他值。假设你创建了一个水果颜色的字典：
- en: '![](Image00146.jpg)'
  id: totrans-9139
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00146.jpg)'
- en: At first we had the value "apple" for "red" , but then we decided that "raspberry"
    is a better fruit to use since sometimes apples are green or yellow. To replace
    "apple" with "raspberry" , we set colorFruits["red"] to its new value ➊ .
  id: totrans-9140
  prefs: []
  type: TYPE_NORMAL
  zh: 最初，我们为 "red" 配置了值 "apple"，但后来我们决定使用 "raspberry" 更合适，因为有时候苹果是绿色或黄色的。为了用 "raspberry"
    替换 "apple"，我们将 colorFruits["red"] 设置为新的值 ➊。
- en: You may remember that this is the same way we entered a new value into a dictionary.
    If the key already exists in the dictionary, then the value for that key is replaced.
    If the key doesn’t already exist, then the new key/value pair will be added to
    the dictionary.
  id: totrans-9141
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能还记得，这与我们向字典中添加新值的方式相同。如果键已经存在于字典中，那么该键的值会被替换。如果键不存在，那么新的键/值对将会被添加到字典中。
- en: '![Image](Image00147.jpg)'
  id: totrans-9142
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00147.jpg)'
- en: '**USING DICTIONARY PROPERTIES**'
  id: totrans-9143
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**使用字典属性**'
- en: 'Like an array, a dictionary also has an isEmpty property and a count property.
    For example, the following code shows how you can use the isEmpty property to
    check if a dictionary is empty, and if it isn’t empty, the count property checks
    how many items you have. Imagine you have a basket of fruit for sale. You can
    use these properties to help you keep track of everything:'
  id: totrans-9144
  prefs: []
  type: TYPE_NORMAL
  zh: 和数组一样，字典也有 isEmpty 属性和 count 属性。例如，以下代码展示了如何使用 isEmpty 属性来检查字典是否为空，如果不为空，则使用
    count 属性来检查字典中有多少项。假设你有一个水果篮子待售。你可以使用这些属性来帮助你跟踪一切：
- en: '![Image](Image00148.jpg)'
  id: totrans-9145
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00148.jpg)'
- en: 'A dictionary also has two special properties: keys , which contains all of
    the dictionary’s keys, and values , which contains all of its values. We’ll use
    these two properties when we loop through the dictionary.'
  id: totrans-9146
  prefs: []
  type: TYPE_NORMAL
  zh: 字典还有两个特殊的属性：keys，它包含字典的所有键，以及 values，它包含所有的值。我们在遍历字典时会使用这两个属性。
- en: Let’s write some code that loops through our fruit baskets and prints the price
    of each fruit.
  id: totrans-9147
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们编写一些代码，遍历我们的水果篮子并打印每个水果的价格。
- en: '**LOOPING OVER A DICTIONARY**'
  id: totrans-9148
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**遍历字典**'
- en: 'You can loop through a dictionary using a for-in loop. Because each item has
    a key and a value, you can do this in two different ways. This is how to loop
    through a dictionary using its keys:'
  id: totrans-9149
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用 for-in 循环遍历字典。因为每个项都有一个键和值，你可以通过两种不同的方式进行循环。这是通过键遍历字典的方法：
- en: '![Image](Image00149.jpg)'
  id: totrans-9150
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00149.jpg)'
- en: Here we use the dictionary’s keys property ➊ to loop through fruitBasket and
    print its contents. We start by writing the keyword for , followed by a constant
    name fruit for the dictionary key, the keyword in , the dictionary name, a period,
    and keys .
  id: totrans-9151
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们使用字典的 keys 属性 ➊ 来遍历 fruitBasket 并打印其内容。我们首先写出关键字 for，接着是字典键的常量名称 fruit，关键字
    in，字典名称，句点，然后是 keys。
- en: Inside the braces of our for-in loop, we have access to both the key, which
    we call fruit ➋ , and the value at that key when we force-unwrap its contents
    with fruitBasket[fruit]! ➌ . That value will be the fruit’s price.
  id: totrans-9152
  prefs: []
  type: TYPE_NORMAL
  zh: 在 for-in 循环的花括号内，我们可以访问键（我们称之为 fruit ➋）以及通过使用 fruitBasket[fruit]! ➌ 强制解包其内容时得到的值。这个值就是水果的价格。
- en: In this case, it’s safe to force-unwrap the value using an exclamation point
    because we know that the fruit key we’re using is definitely inside the dictionary.
  id: totrans-9153
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，可以安全地使用感叹号强制解包值，因为我们知道我们使用的水果键一定在字典中。
- en: Any code we put inside the for-in loop will run once for every key in our dictionary.
    So you should see the print statement display three times.
  id: totrans-9154
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在 for-in 循环中放置的任何代码都会为字典中的每个键执行一次。所以你应该看到打印语句显示三次。
- en: 'We can also loop through the dictionary using its values property:'
  id: totrans-9155
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以使用字典的 values 属性来遍历字典：
- en: '![Image](Image00150.jpg)'
  id: totrans-9156
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00150.jpg)'
- en: We use the same style of for-in loop, but now we use a constant to refer to
    each value, which we call price , in the values property. When looping through
    values, we don’t have access to the keys from inside the loop.
  id: totrans-9157
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用相同风格的 for-in 循环，但现在我们使用一个常量来引用 values 属性中的每个值，称其为 price。在遍历 values 时，我们无法从循环内访问键。
- en: Another difference to note is that price is not an optional because it’s accessed
    directly as a value in the fruitBasket dictionary. That means we don’t have to
    unwrap it. You should still see the print statement printed three times. [Figure
    6-6](text00016.html#ch06fig6) shows the output of both loops.
  id: totrans-9158
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个需要注意的区别是，price 不是可选的，因为它是直接作为值从 fruitBasket 字典中访问的。这意味着我们不需要解包它。你仍然应该看到打印语句打印三次。[图
    6-6](text00016.html#ch06fig6) 显示了两个循环的输出。
- en: '![Image](Image00151.jpg)'
  id: totrans-9159
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00151.jpg)'
- en: '*Figure 6-6: Looping through the keys and values of a dictionary with a for-in
    loop*'
  id: totrans-9160
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 6-6：使用 for-in 循环遍历字典的键和值*'
- en: The order of your results might be slightly different from ours. That’s because
    the items in a dictionary aren’t in a numbered order like they are in an array!
    And because the order is not guaranteed, you might see a different order printed
    if you run the same code again.
  id: totrans-9161
  prefs: []
  type: TYPE_NORMAL
  zh: 你的结果顺序可能与我们的顺序略有不同。这是因为字典中的项目不像数组那样按编号顺序排列！而且由于顺序不确定，如果你再次运行相同的代码，可能会看到不同的顺序。
- en: '**WHAT YOU LEARNED**'
  id: totrans-9162
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**你学到了什么**'
- en: In this chapter, you learned how to store collections of items in an array and
    in a dictionary. To store items in an ordered list, you would use an array and
    look up each item by its index. If you wanted to store items by key instead, you
    would use a dictionary.
  id: totrans-9163
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你学会了如何在数组和字典中存储项。要将项目存储在有序列表中，你会使用数组，并通过索引查找每个项目。如果你想通过键来存储项目，而不是按顺序存储，你会使用字典。
- en: Knowing about arrays and dictionaries and how to use them is a powerful building
    block for almost any programming language. Next we will learn about functions,
    another very powerful tool. Functions are blocks of code that you create and name
    to perform a specific job. After you have written a function, you can use its
    name to call it from almost anywhere in your program.
  id: totrans-9164
  prefs: []
  type: TYPE_NORMAL
  zh: 了解数组和字典以及如何使用它们，是几乎任何编程语言中非常强大的基础。接下来我们将学习函数，这是另一种非常强大的工具。函数是你创建并命名的代码块，用来执行特定的任务。在你编写完函数后，可以通过它的名称在程序的几乎任何地方调用它。
- en: 'Using for-in loops is great for printing every value in an array. If you’re
    working with numbers, you can even use them to perform math operations on each
    item, which makes for some speedy calculations! The following code takes an array
    of numbers and calculates the square for each (the square of a number is that
    number multiplied by itself):'
  id: totrans-9165
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`for-in`循环非常适合打印数组中的每个值。如果你在处理数字，你甚至可以使用它们对每个项目执行数学运算，从而加速计算！以下代码接受一个数字数组，并计算每个数字的平方（一个数字的平方是该数字与自身相乘）：
- en: '![Image](Image00138.jpg)'
  id: totrans-9166
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00138.jpg)'
- en: '[Figure 6-5](text00016.html#ch06fig5) shows the results.'
  id: totrans-9167
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 6-5](text00016.html#ch06fig5)显示了结果。'
- en: '![Image](Image00139.jpg)'
  id: totrans-9168
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00139.jpg)'
- en: '*Figure 6-5: Printing the squares for each number in the myNumbers array*'
  id: totrans-9169
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 6-5：打印myNumbers数组中每个数字的平方*'
- en: '**DICTIONARIES ARE KEY!**'
  id: totrans-9170
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**字典是关键！**'
- en: A *dictionary* is also a collection of values, but instead of an ordered index,
    each value has its own *key* . Because there’s no index, the values are not stored
    in any particular order. To access values in a dictionary, you look them up by
    their key.
  id: totrans-9171
  prefs: []
  type: TYPE_NORMAL
  zh: '*字典*也是一个值的集合，但与有序索引的数组不同，每个值都有自己的*键*。因为没有索引，值不会按特定顺序存储。要访问字典中的值，你需要通过它们的键来查找。'
- en: A key must be unique. You can’t have the same key more than once in the same
    dictionary. If there were two identical keys and you asked the computer to give
    you the value for one of them, the computer wouldn’t know which one to choose!
  id: totrans-9172
  prefs: []
  type: TYPE_NORMAL
  zh: 键必须是唯一的。你不能在同一个字典中有相同的键。如果有两个相同的键，而你要求计算机给你其中一个的值，计算机就不知道选择哪个！
- en: Let’s take a look at how to make a dictionary and write keys that will help
    you find all the information you need.
  id: totrans-9173
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看如何创建字典并编写键，以帮助你查找所需的所有信息。
- en: '![Image](Image00140.jpg)'
  id: totrans-9174
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00140.jpg)'
- en: '**INITIALIZING A DICTIONARY**'
  id: totrans-9175
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**初始化字典**'
- en: 'To create and initialize a dictionary, first write var and the name of your
    dictionary. Then write the keys and corresponding values inside a pair of square
    brackets, similar to an array. Let’s create a dictionary to store the names of
    a few US states. The key for each state will be its two-letter abbreviation:'
  id: totrans-9176
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建并初始化一个字典，首先写出`var`和字典的名称。然后将键和值写在一对方括号内，类似于数组。让我们创建一个字典来存储一些美国州的名称。每个州的键将是它的两个字母的缩写：
- en: '![](Image00141.jpg)'
  id: totrans-9177
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00141.jpg)'
- en: As you can see, there’s a colon between each key and its value, and the key/value
    pairs are separated by commas.
  id: totrans-9178
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，每个键和它的值之间都有一个冒号，键/值对之间由逗号分隔。
- en: Dictionaries are different from arrays in that they are *unordered* . Because
    of that, it’s likely that the order of the states that you see in your results
    pane ➋ is different from the order in which you entered your states ➊ . It might
    even be different than the order that’s printed in this book!
  id: totrans-9179
  prefs: []
  type: TYPE_NORMAL
  zh: 字典与数组不同，它们是*无序*的。因此，你在结果面板中看到的州的顺序➋可能与输入州的顺序➊不同。它甚至可能与书中打印的顺序不同！
- en: As with arrays, you can use var to make a mutable dictionary or use let to make
    an immutable dictionary.
  id: totrans-9180
  prefs: []
  type: TYPE_NORMAL
  zh: 与数组一样，你可以使用`var`来创建一个可变的字典，或者使用`let`来创建一个不可变的字典。
- en: 'In Swift, all of the keys of a dictionary must be the same type, and all of
    the values of a dictionary must also be the same type, but the key type doesn’t
    have to match the value type. For example, if you wanted to store a collection
    of fractions, you could use doubles for the keys and strings for the values:'
  id: totrans-9181
  prefs: []
  type: TYPE_NORMAL
  zh: 在Swift中，字典的所有键必须是相同的类型，所有的值也必须是相同的类型，但键的类型不必与值的类型匹配。例如，如果你想存储一组分数，你可以将键设置为双精度浮点数，而值设置为字符串：
- en: '![](Image00142.jpg)'
  id: totrans-9182
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00142.jpg)'
- en: In this dictionary, all of the keys must be doubles, and all of the values must
    be strings. Again, you’ll see that the order of the numbers in the results pane
    can be quite different from the order in which you wrote the fractions in your
    dictionary. This is fine because you don’t need to know the order to access anything.
    You can find any item that you need by its key. Let’s see how!
  id: totrans-9183
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个字典中，所有的键必须是双精度浮点数，所有的值必须是字符串。再说一次，你会发现结果面板中数字的顺序可能与字典中你编写的分数顺序完全不同。这是正常的，因为你无需知道顺序就能访问任何内容。你可以通过键来查找任何需要的项。让我们看看如何操作！
- en: '**ACCESSING VALUES IN A DICTIONARY**'
  id: totrans-9184
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**访问字典中的值**'
- en: 'Looking up a value in a dictionary is similar to how you access a value in
    an array except that you use a key inside the square brackets instead of an index,
    like this: usStates["TX"] .'
  id: totrans-9185
  prefs: []
  type: TYPE_NORMAL
  zh: 查找字典中的值类似于你在数组中访问值的方式，只不过你需要在方括号中使用键，而不是索引，像这样：usStates["TX"]。
- en: There is a big difference, however, in how Swift returns the values from a dictionary.
    When you access a value at an index of an array, you are simply given the value.
    When you access a value with a key in a dictionary, you are given an optional.
  id: totrans-9186
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，Swift在从字典返回值时有一个很大的不同。当你通过数组的索引访问一个值时，你只是简单地得到这个值。但当你通过字典的键访问值时，Swift会返回一个可选值。
- en: In [Chapter 5](text00015.html#ch05) , you learned that optionals might contain
    a value or might be nil . The reason Swift returns optionals when you’re looking
    up items in a dictionary is that the key you used might not exist in the dictionary,
    in which case there’s no value to access. Trying to access a value that doesn’t
    exist would give you a big fat error! To avoid that problem, Swift returns optionals.
    That means you need to unwrap any value you get out of a dictionary before you
    can do anything with it.
  id: totrans-9187
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第5章](text00015.html#ch05)中，你已经学习了可选值可能包含一个值，或者可能是nil。当你在字典中查找项目时，Swift返回可选值的原因是你使用的键可能在字典中不存在，在这种情况下就没有值可供访问。尝试访问一个不存在的值会给你带来一个大的错误！为了避免这个问题，Swift返回了可选值。这意味着你需要解包从字典中获取的任何值，才能对其进行任何操作。
- en: 'To unwrap an optional, first you check whether it exists using an if-let statement,
    just like we did in [Chapter 5](text00015.html#ch05) . The following code shows
    you how to get a value out of a dictionary:'
  id: totrans-9188
  prefs: []
  type: TYPE_NORMAL
  zh: 要解包一个可选值，首先使用if-let语句检查它是否存在，就像我们在[第5章](text00015.html#ch05)中做的那样。以下代码展示了如何从字典中获取一个值：
- en: '![Image](Image00143.jpg)'
  id: totrans-9189
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00143.jpg)'
- en: To retrieve "Texas" from the dictionary, we use if let to set a constant loneStarState
    to usStates["TX"] ➊ . Because we have this state in our dictionary, the line I
    have Texas in my dictionary. is printed. Next we try to access a state that is
    not in our dictionary by using the key usStates["FL"] ➋ . Thankfully, because
    we used an if-let statement, the program won’t crash when the computer can’t find
    this state. Instead, I don't have that state in my dictionary. is printed.
  id: totrans-9190
  prefs: []
  type: TYPE_NORMAL
  zh: 要从字典中检索"Texas"，我们使用if let语句将常量loneStarState设置为usStates["TX"] ➊。因为我们字典中有这个州，所以会打印出“我在字典中有Texas”。接下来，我们尝试通过键usStates["FL"]
    ➋访问一个字典中没有的州。幸运的是，因为我们使用了if-let语句，当计算机找不到该州时，程序不会崩溃。相反，会打印出“我在字典中没有那个州”。
- en: '**ADDING ITEMS TO A DICTIONARY**'
  id: totrans-9191
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**向字典添加项目**'
- en: 'To add an item to a dictionary, first write the name of your dictionary and
    assign the new item to the key you want it to have in the dictionary. Let’s add
    "Minnesota" to our usStates dictionary:'
  id: totrans-9192
  prefs: []
  type: TYPE_NORMAL
  zh: 要向字典中添加一个项目，首先写出字典的名称，并将新项目赋值给你希望它在字典中具有的键。让我们向usStates字典中添加"Minneapolis"：
- en: '![](Image00144.jpg)'
  id: totrans-9193
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00144.jpg)'
- en: 'Now when you look at usStates , you’ll see that it’s updated to ["MN": "Minnesota",
    "WA": "Washington", "MA": "Massachusetts", "TX": "Texas"] . Remember, because
    you don’t have to rely on indices, your new dictionary item might appear anywhere
    in the dictionary.'
  id: totrans-9194
  prefs: []
  type: TYPE_NORMAL
  zh: '现在，当你查看usStates时，你会看到它已更新为["MN": "Minnesota", "WA": "Washington", "MA": "Massachusetts",
    "TX": "Texas"]。记住，由于你不需要依赖索引，新的字典项可能会出现在字典中的任何位置。'
- en: '**REMOVING ITEMS FROM A DICTIONARY**'
  id: totrans-9195
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**从字典中移除项目**'
- en: Removing an item from a dictionary is quite simple; you do so by setting the
    value to nil . Because the values in dictionaries are returned as optionals, you
    don’t have to worry about nil causing any problems in your dictionary.
  id: totrans-9196
  prefs: []
  type: TYPE_NORMAL
  zh: 从字典中删除项目非常简单；你只需将值设置为nil。由于字典中的值是作为可选项返回的，所以你无需担心nil会在字典中引发任何问题。
- en: '![](Image00145.jpg)'
  id: totrans-9197
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00145.jpg)'
- en: 'You can see that after you remove the value at the key "MA" , usStates is updated
    to ["MN": "Minnesota", "WA": "Washington", "TX": "Texas"] . Remember that nil
    is special and means that there’s no value at all. That’s why you don’t see "MA":
    nil in our dictionary.'
  id: totrans-9198
  prefs: []
  type: TYPE_NORMAL
  zh: '你可以看到，在你删除“MA”键的值之后，usStates更新为["MN": "Minnesota", "WA": "Washington", "TX":
    "Texas"]。记住，nil是特殊的，表示没有值。这就是为什么你在我们的字典中看不到"MA": nil的原因。'
- en: '**REPLACING ITEMS IN A DICTIONARY**'
  id: totrans-9199
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**替换字典中的项目**'
- en: 'Replacing an item in a dictionary is also easy. It works the same was as replacing
    an item in an array. You just set the item that you want to replace to something
    else. Say you create a dictionary of fruit colors:'
  id: totrans-9200
  prefs: []
  type: TYPE_NORMAL
  zh: 替换字典中的项目也很简单。它的工作原理与替换数组中的项目相同。你只需要将你想替换的项目设置为其他内容。假设你创建了一个水果颜色的字典：
- en: '![](Image00146.jpg)'
  id: totrans-9201
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00146.jpg)'
- en: At first we had the value "apple" for "red" , but then we decided that "raspberry"
    is a better fruit to use since sometimes apples are green or yellow. To replace
    "apple" with "raspberry" , we set colorFruits["red"] to its new value ➊ .
  id: totrans-9202
  prefs: []
  type: TYPE_NORMAL
  zh: 最初，我们为“red”键设置了值“apple”，但后来我们决定使用“raspberry”更合适，因为有时候苹果是绿色或黄色的。为了将“apple”替换为“raspberry”，我们将colorFruits["red"]设置为它的新值
    ➊。
- en: You may remember that this is the same way we entered a new value into a dictionary.
    If the key already exists in the dictionary, then the value for that key is replaced.
    If the key doesn’t already exist, then the new key/value pair will be added to
    the dictionary.
  id: totrans-9203
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能还记得，这与我们将新值输入字典的方式相同。如果键已经存在于字典中，那么该键的值将被替换。如果该键不存在，则新的键/值对将被添加到字典中。
- en: '![Image](Image00147.jpg)'
  id: totrans-9204
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00147.jpg)'
- en: '**USING DICTIONARY PROPERTIES**'
  id: totrans-9205
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**使用字典属性**'
- en: 'Like an array, a dictionary also has an isEmpty property and a count property.
    For example, the following code shows how you can use the isEmpty property to
    check if a dictionary is empty, and if it isn’t empty, the count property checks
    how many items you have. Imagine you have a basket of fruit for sale. You can
    use these properties to help you keep track of everything:'
  id: totrans-9206
  prefs: []
  type: TYPE_NORMAL
  zh: 像数组一样，字典也有isEmpty属性和count属性。例如，以下代码展示了如何使用isEmpty属性来检查字典是否为空，如果不为空，count属性可以检查字典中有多少项。假设你有一个出售的水果篮子，你可以使用这些属性来帮助你跟踪所有物品：
- en: '![Image](Image00148.jpg)'
  id: totrans-9207
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00148.jpg)'
- en: 'A dictionary also has two special properties: keys , which contains all of
    the dictionary’s keys, and values , which contains all of its values. We’ll use
    these two properties when we loop through the dictionary.'
  id: totrans-9208
  prefs: []
  type: TYPE_NORMAL
  zh: 字典还有两个特殊的属性：keys，包含字典的所有键，和values，包含字典的所有值。我们将在遍历字典时使用这两个属性。
- en: Let’s write some code that loops through our fruit baskets and prints the price
    of each fruit.
  id: totrans-9209
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们写一些代码，遍历我们的水果篮子并打印每种水果的价格。
- en: '**LOOPING OVER A DICTIONARY**'
  id: totrans-9210
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**遍历字典**'
- en: 'You can loop through a dictionary using a for-in loop. Because each item has
    a key and a value, you can do this in two different ways. This is how to loop
    through a dictionary using its keys:'
  id: totrans-9211
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过for-in循环遍历字典。由于每个项目都有一个键和值，你可以用两种不同的方式来遍历字典。这是通过键遍历字典的方式：
- en: '![Image](Image00149.jpg)'
  id: totrans-9212
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00149.jpg)'
- en: Here we use the dictionary’s keys property ➊ to loop through fruitBasket and
    print its contents. We start by writing the keyword for , followed by a constant
    name fruit for the dictionary key, the keyword in , the dictionary name, a period,
    and keys .
  id: totrans-9213
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们使用字典的keys属性 ➊ 遍历fruitBasket并打印其内容。我们首先写出关键字for，后面跟着字典键的常量名fruit，然后是关键字in，接着是字典名称，一个句点，最后是keys。
- en: Inside the braces of our for-in loop, we have access to both the key, which
    we call fruit ➋ , and the value at that key when we force-unwrap its contents
    with fruitBasket[fruit]! ➌ . That value will be the fruit’s price.
  id: totrans-9214
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的for-in循环的大括号内，我们可以访问到键fruit ➋ 和通过强制解包fruitBasket[fruit]! ➌ 获取的该键的值。这个值就是水果的价格。
- en: In this case, it’s safe to force-unwrap the value using an exclamation point
    because we know that the fruit key we’re using is definitely inside the dictionary.
  id: totrans-9215
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，使用感叹号强制解包值是安全的，因为我们知道我们使用的“fruit”键一定在字典中。
- en: Any code we put inside the for-in loop will run once for every key in our dictionary.
    So you should see the print statement display three times.
  id: totrans-9216
  prefs: []
  type: TYPE_NORMAL
  zh: 我们放入`for-in`循环中的任何代码都会为字典中的每个键执行一次。所以你应该看到打印语句显示三次。
- en: 'We can also loop through the dictionary using its values property:'
  id: totrans-9217
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以通过字典的`values`属性来循环遍历：
- en: '![Image](Image00150.jpg)'
  id: totrans-9218
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Image00150.jpg)'
- en: We use the same style of for-in loop, but now we use a constant to refer to
    each value, which we call price , in the values property. When looping through
    values, we don’t have access to the keys from inside the loop.
  id: totrans-9219
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用相同风格的`for-in`循环，但现在我们使用常量来引用`values`属性中的每个值，我们称之为`price`。在循环遍历值时，我们无法从循环内部访问键。
- en: Another difference to note is that price is not an optional because it’s accessed
    directly as a value in the fruitBasket dictionary. That means we don’t have to
    unwrap it. You should still see the print statement printed three times. [Figure
    6-6](text00016.html#ch06fig6) shows the output of both loops.
  id: totrans-9220
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个需要注意的区别是，价格不是可选项，因为它是直接作为一个值访问的，在`fruitBasket`字典中。也就是说，我们不需要解包它。你仍然应该看到打印语句打印三次。[图6-6](text00016.html#ch06fig6)显示了两个循环的输出。
- en: '![Image](Image00151.jpg)'
  id: totrans-9221
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Image00151.jpg)'
- en: '*Figure 6-6: Looping through the keys and values of a dictionary with a for-in
    loop*'
  id: totrans-9222
  prefs: []
  type: TYPE_NORMAL
  zh: '*图6-6：使用`for-in`循环遍历字典的键和值*'
- en: The order of your results might be slightly different from ours. That’s because
    the items in a dictionary aren’t in a numbered order like they are in an array!
    And because the order is not guaranteed, you might see a different order printed
    if you run the same code again.
  id: totrans-9223
  prefs: []
  type: TYPE_NORMAL
  zh: 你的结果顺序可能与我们的稍有不同。那是因为字典中的项不像数组中的项那样是按数字顺序排列的！由于顺序无法保证，如果你再次运行相同的代码，打印出来的顺序可能会不同。
- en: '**WHAT YOU LEARNED**'
  id: totrans-9224
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**你学到了什么**'
- en: In this chapter, you learned how to store collections of items in an array and
    in a dictionary. To store items in an ordered list, you would use an array and
    look up each item by its index. If you wanted to store items by key instead, you
    would use a dictionary.
  id: totrans-9225
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你学习了如何在数组和字典中存储集合。如果要将项存储在有序列表中，你应该使用数组，并通过索引查找每一项。如果你想按键存储项，则应使用字典。
- en: Knowing about arrays and dictionaries and how to use them is a powerful building
    block for almost any programming language. Next we will learn about functions,
    another very powerful tool. Functions are blocks of code that you create and name
    to perform a specific job. After you have written a function, you can use its
    name to call it from almost anywhere in your program.
  id: totrans-9226
  prefs: []
  type: TYPE_NORMAL
  zh: 了解数组和字典及其使用方法是几乎所有编程语言中非常强大的构建块。接下来，我们将学习函数，这是另一个非常强大的工具。函数是你创建并命名的代码块，用于执行特定的工作。编写完函数后，你可以通过它的名称在程序中的几乎任何地方调用它。
- en: '![Image](Image00138.jpg)'
  id: totrans-9227
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Image00138.jpg)'
- en: '[Figure 6-5](text00016.html#ch06fig5) shows the results.'
  id: totrans-9228
  prefs: []
  type: TYPE_NORMAL
  zh: '[图6-5](text00016.html#ch06fig5)显示了结果。'
- en: '![Image](Image00139.jpg)'
  id: totrans-9229
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Image00139.jpg)'
- en: '*Figure 6-5: Printing the squares for each number in the myNumbers array*'
  id: totrans-9230
  prefs: []
  type: TYPE_NORMAL
  zh: '*图6-5：打印myNumbers数组中每个数字的平方*'
- en: '**DICTIONARIES ARE KEY!**'
  id: totrans-9231
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**字典是关键！**'
- en: A *dictionary* is also a collection of values, but instead of an ordered index,
    each value has its own *key* . Because there’s no index, the values are not stored
    in any particular order. To access values in a dictionary, you look them up by
    their key.
  id: totrans-9232
  prefs: []
  type: TYPE_NORMAL
  zh: '*字典*也是一个值的集合，但是与有序索引不同，每个值都有自己的*键*。由于没有索引，值不会按特定顺序存储。要访问字典中的值，你需要通过它们的键来查找。'
- en: A key must be unique. You can’t have the same key more than once in the same
    dictionary. If there were two identical keys and you asked the computer to give
    you the value for one of them, the computer wouldn’t know which one to choose!
  id: totrans-9233
  prefs: []
  type: TYPE_NORMAL
  zh: 键必须是唯一的。你不能在同一个字典中有两个相同的键。如果有两个相同的键，而你请求计算机给出其中一个的值，计算机将无法知道选择哪一个！
- en: Let’s take a look at how to make a dictionary and write keys that will help
    you find all the information you need.
  id: totrans-9234
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看一下如何创建一个字典，并编写能够帮助你找到所需信息的键。
- en: '![Image](Image00140.jpg)'
  id: totrans-9235
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Image00140.jpg)'
- en: '**INITIALIZING A DICTIONARY**'
  id: totrans-9236
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**初始化字典**'
- en: 'To create and initialize a dictionary, first write var and the name of your
    dictionary. Then write the keys and corresponding values inside a pair of square
    brackets, similar to an array. Let’s create a dictionary to store the names of
    a few US states. The key for each state will be its two-letter abbreviation:'
  id: totrans-9237
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建并初始化一个字典，首先写`var`和字典的名称。然后将键和值写在一对方括号内，类似于数组。我们来创建一个字典，存储几个美国州的名称。每个州的键将是其两位字母缩写：
- en: '![](Image00141.jpg)'
  id: totrans-9238
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00141.jpg)'
- en: As you can see, there’s a colon between each key and its value, and the key/value
    pairs are separated by commas.
  id: totrans-9239
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，每个键和值之间都有一个冒号，键值对之间由逗号分隔。
- en: Dictionaries are different from arrays in that they are *unordered* . Because
    of that, it’s likely that the order of the states that you see in your results
    pane ➋ is different from the order in which you entered your states ➊ . It might
    even be different than the order that’s printed in this book!
  id: totrans-9240
  prefs: []
  type: TYPE_NORMAL
  zh: 字典与数组的不同之处在于，它们是*无序的*。因此，你在结果面板中看到的州的顺序 ➋ 可能与输入州的顺序 ➊ 不同。它甚至可能与本书中打印的顺序不同！
- en: As with arrays, you can use var to make a mutable dictionary or use let to make
    an immutable dictionary.
  id: totrans-9241
  prefs: []
  type: TYPE_NORMAL
  zh: 和数组一样，你可以使用 `var` 来创建一个可变字典，或者使用 `let` 创建一个不可变字典。
- en: 'In Swift, all of the keys of a dictionary must be the same type, and all of
    the values of a dictionary must also be the same type, but the key type doesn’t
    have to match the value type. For example, if you wanted to store a collection
    of fractions, you could use doubles for the keys and strings for the values:'
  id: totrans-9242
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Swift 中，字典的所有键必须是相同类型的，字典的所有值也必须是相同类型的，但键类型不必与值类型匹配。例如，如果你想存储一组分数，可以使用双精度浮点数作为键，字符串作为值：
- en: '![](Image00142.jpg)'
  id: totrans-9243
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00142.jpg)'
- en: In this dictionary, all of the keys must be doubles, and all of the values must
    be strings. Again, you’ll see that the order of the numbers in the results pane
    can be quite different from the order in which you wrote the fractions in your
    dictionary. This is fine because you don’t need to know the order to access anything.
    You can find any item that you need by its key. Let’s see how!
  id: totrans-9244
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个字典中，所有的键必须是双精度浮点数，所有的值必须是字符串。同样，你会发现结果面板中的数字顺序可能与字典中分数的书写顺序大不相同。这是可以接受的，因为你不需要知道顺序就可以访问任何内容。你可以通过键找到任何需要的项目。我们来看看如何操作！
- en: '**ACCESSING VALUES IN A DICTIONARY**'
  id: totrans-9245
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**访问字典中的值**'
- en: 'Looking up a value in a dictionary is similar to how you access a value in
    an array except that you use a key inside the square brackets instead of an index,
    like this: usStates["TX"] .'
  id: totrans-9246
  prefs: []
  type: TYPE_NORMAL
  zh: 查找字典中的值类似于你在数组中访问值的方式，只不过你在方括号中使用的是键，而不是索引，像这样：`usStates["TX"]`。
- en: There is a big difference, however, in how Swift returns the values from a dictionary.
    When you access a value at an index of an array, you are simply given the value.
    When you access a value with a key in a dictionary, you are given an optional.
  id: totrans-9247
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，Swift 在从字典中返回值时有一个很大的不同。当你访问数组中的一个索引值时，你会直接得到这个值。当你通过键访问字典中的值时，你会得到一个可选值。
- en: In [Chapter 5](text00015.html#ch05) , you learned that optionals might contain
    a value or might be nil . The reason Swift returns optionals when you’re looking
    up items in a dictionary is that the key you used might not exist in the dictionary,
    in which case there’s no value to access. Trying to access a value that doesn’t
    exist would give you a big fat error! To avoid that problem, Swift returns optionals.
    That means you need to unwrap any value you get out of a dictionary before you
    can do anything with it.
  id: totrans-9248
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第5章](text00015.html#ch05)中，你学过可选值可能包含一个值，也可能为 `nil`。Swift 在你查找字典中的项目时返回可选值的原因是，你使用的键可能不存在于字典中，在这种情况下，就没有值可以访问。尝试访问一个不存在的值会导致一个大错误！为了避免这个问题，Swift
    返回可选值。这意味着你需要在使用字典中的任何值之前，先解包它。
- en: 'To unwrap an optional, first you check whether it exists using an if-let statement,
    just like we did in [Chapter 5](text00015.html#ch05) . The following code shows
    you how to get a value out of a dictionary:'
  id: totrans-9249
  prefs: []
  type: TYPE_NORMAL
  zh: 要解包一个可选值，首先你需要使用 `if-let` 语句检查它是否存在，就像我们在[第5章](text00015.html#ch05)中做的那样。以下代码展示了如何从字典中获取一个值：
- en: '![Image](Image00143.jpg)'
  id: totrans-9250
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00143.jpg)'
- en: To retrieve "Texas" from the dictionary, we use if let to set a constant loneStarState
    to usStates["TX"] ➊ . Because we have this state in our dictionary, the line I
    have Texas in my dictionary. is printed. Next we try to access a state that is
    not in our dictionary by using the key usStates["FL"] ➋ . Thankfully, because
    we used an if-let statement, the program won’t crash when the computer can’t find
    this state. Instead, I don't have that state in my dictionary. is printed.
  id: totrans-9251
  prefs: []
  type: TYPE_NORMAL
  zh: 为了从字典中检索 "Texas"（德州），我们使用 `if let` 将常量 `loneStarState` 设置为 `usStates["TX"]`
    ➊ 。因为我们在字典中有这个州，所以会打印出 "I have Texas in my dictionary."。接下来，我们尝试使用一个不在字典中的州来访问数据，使用键
    `usStates["FL"]` ➋ 。幸运的是，由于我们使用了 `if-let` 语句，当计算机找不到该州时，程序不会崩溃。相反，打印出 "I don't
    have that state in my dictionary."。
- en: '**ADDING ITEMS TO A DICTIONARY**'
  id: totrans-9252
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**向字典中添加项目**'
- en: 'To add an item to a dictionary, first write the name of your dictionary and
    assign the new item to the key you want it to have in the dictionary. Let’s add
    "Minnesota" to our usStates dictionary:'
  id: totrans-9253
  prefs: []
  type: TYPE_NORMAL
  zh: 要向字典中添加一个项目，首先写出字典的名称，并将新项目分配给你希望它在字典中拥有的键。让我们向我们的 usStates 字典中添加 "Minnesota"：
- en: '![](Image00144.jpg)'
  id: totrans-9254
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00144.jpg)'
- en: 'Now when you look at usStates , you’ll see that it’s updated to ["MN": "Minnesota",
    "WA": "Washington", "MA": "Massachusetts", "TX": "Texas"] . Remember, because
    you don’t have to rely on indices, your new dictionary item might appear anywhere
    in the dictionary.'
  id: totrans-9255
  prefs: []
  type: TYPE_NORMAL
  zh: '现在当你查看 usStates 时，你会看到它已经更新为 ["MN": "Minnesota", "WA": "Washington", "MA":
    "Massachusetts", "TX": "Texas"]。记住，由于你不需要依赖索引，你的新字典项可能出现在字典中的任何位置。'
- en: '**REMOVING ITEMS FROM A DICTIONARY**'
  id: totrans-9256
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**从字典中删除项目**'
- en: Removing an item from a dictionary is quite simple; you do so by setting the
    value to nil . Because the values in dictionaries are returned as optionals, you
    don’t have to worry about nil causing any problems in your dictionary.
  id: totrans-9257
  prefs: []
  type: TYPE_NORMAL
  zh: 从字典中删除项目非常简单；你只需将该值设置为 nil。由于字典中的值是以可选项形式返回的，你不需要担心 nil 会导致字典出现问题。
- en: '![](Image00145.jpg)'
  id: totrans-9258
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00145.jpg)'
- en: 'You can see that after you remove the value at the key "MA" , usStates is updated
    to ["MN": "Minnesota", "WA": "Washington", "TX": "Texas"] . Remember that nil
    is special and means that there’s no value at all. That’s why you don’t see "MA":
    nil in our dictionary.'
  id: totrans-9259
  prefs: []
  type: TYPE_NORMAL
  zh: '你可以看到，当你删除 "MA" 这个键的值时，usStates 更新为 ["MN": "Minnesota", "WA": "Washington",
    "TX": "Texas"]。记住，nil 是特殊的，表示没有值。这就是为什么你在我们的字典中看不到 "MA": nil。'
- en: '**REPLACING ITEMS IN A DICTIONARY**'
  id: totrans-9260
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**替换字典中的项目**'
- en: 'Replacing an item in a dictionary is also easy. It works the same was as replacing
    an item in an array. You just set the item that you want to replace to something
    else. Say you create a dictionary of fruit colors:'
  id: totrans-9261
  prefs: []
  type: TYPE_NORMAL
  zh: 替换字典中的项目也很简单。它与替换数组中的项目一样。你只需要将要替换的项目设置为其他值。例如，假设你创建了一个水果颜色的字典：
- en: '![](Image00146.jpg)'
  id: totrans-9262
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00146.jpg)'
- en: At first we had the value "apple" for "red" , but then we decided that "raspberry"
    is a better fruit to use since sometimes apples are green or yellow. To replace
    "apple" with "raspberry" , we set colorFruits["red"] to its new value ➊ .
  id: totrans-9263
  prefs: []
  type: TYPE_NORMAL
  zh: 起初，我们为 "red" 设置的值是 "apple"，但后来我们决定用 "raspberry" 作为更合适的水果，因为有时苹果是绿色或黄色的。为了用 "raspberry"
    替换 "apple"，我们将 colorFruits["red"] 设置为它的新值 ➊。
- en: You may remember that this is the same way we entered a new value into a dictionary.
    If the key already exists in the dictionary, then the value for that key is replaced.
    If the key doesn’t already exist, then the new key/value pair will be added to
    the dictionary.
  id: totrans-9264
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能还记得，这与我们将新值添加到字典中的方式相同。如果字典中已经存在该键，则该键的值将被替换。如果键不存在，则新的键/值对将被添加到字典中。
- en: '![Image](Image00147.jpg)'
  id: totrans-9265
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Image00147.jpg)'
- en: '**USING DICTIONARY PROPERTIES**'
  id: totrans-9266
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**使用字典属性**'
- en: 'Like an array, a dictionary also has an isEmpty property and a count property.
    For example, the following code shows how you can use the isEmpty property to
    check if a dictionary is empty, and if it isn’t empty, the count property checks
    how many items you have. Imagine you have a basket of fruit for sale. You can
    use these properties to help you keep track of everything:'
  id: totrans-9267
  prefs: []
  type: TYPE_NORMAL
  zh: 像数组一样，字典也有 isEmpty 属性和 count 属性。例如，以下代码演示了如何使用 isEmpty 属性来检查字典是否为空，如果字典不为空，则使用
    count 属性来检查你有多少个项目。假设你有一个待售的水果篮子。你可以使用这些属性来帮助你跟踪所有内容：
- en: '![Image](Image00148.jpg)'
  id: totrans-9268
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Image00148.jpg)'
- en: 'A dictionary also has two special properties: keys , which contains all of
    the dictionary’s keys, and values , which contains all of its values. We’ll use
    these two properties when we loop through the dictionary.'
  id: totrans-9269
  prefs: []
  type: TYPE_NORMAL
  zh: 字典还有两个特殊的属性：keys，包含字典中所有的键；values，包含字典中所有的值。在我们遍历字典时，将会用到这两个属性。
- en: Let’s write some code that loops through our fruit baskets and prints the price
    of each fruit.
  id: totrans-9270
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们写一些代码，遍历我们的水果篮子并打印每种水果的价格。
- en: '**LOOPING OVER A DICTIONARY**'
  id: totrans-9271
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**遍历字典**'
- en: 'You can loop through a dictionary using a for-in loop. Because each item has
    a key and a value, you can do this in two different ways. This is how to loop
    through a dictionary using its keys:'
  id: totrans-9272
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用 for-in 循环遍历字典。由于每个项目都有一个键和值，因此你可以通过两种不同的方式来实现。下面是通过键遍历字典的方式：
- en: '![Image](Image00149.jpg)'
  id: totrans-9273
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Image00149.jpg)'
- en: Here we use the dictionary’s keys property ➊ to loop through fruitBasket and
    print its contents. We start by writing the keyword for , followed by a constant
    name fruit for the dictionary key, the keyword in , the dictionary name, a period,
    and keys .
  id: totrans-9274
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们使用字典的键属性 ➊ 来循环遍历fruitBasket，并打印其内容。我们首先写出关键字for，后面是字典键的常量名称fruit，接着是关键字in，字典名称，一个句点，最后是keys。
- en: Inside the braces of our for-in loop, we have access to both the key, which
    we call fruit ➋ , and the value at that key when we force-unwrap its contents
    with fruitBasket[fruit]! ➌ . That value will be the fruit’s price.
  id: totrans-9275
  prefs: []
  type: TYPE_NORMAL
  zh: 在for-in循环的花括号内，我们可以访问键（我们称其为fruit ➋），以及通过强制解包fruitBasket[fruit]! ➌ 获取的该键对应的值。该值就是水果的价格。
- en: In this case, it’s safe to force-unwrap the value using an exclamation point
    because we know that the fruit key we’re using is definitely inside the dictionary.
  id: totrans-9276
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，使用感叹号强制解包值是安全的，因为我们知道正在使用的水果键肯定在字典中。
- en: Any code we put inside the for-in loop will run once for every key in our dictionary.
    So you should see the print statement display three times.
  id: totrans-9277
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在for-in循环内部放入的任何代码都会为字典中的每个键执行一次。因此，你应该看到打印语句打印三次。
- en: 'We can also loop through the dictionary using its values property:'
  id: totrans-9278
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以使用字典的值属性来循环遍历：
- en: '![Image](Image00150.jpg)'
  id: totrans-9279
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00150.jpg)'
- en: We use the same style of for-in loop, but now we use a constant to refer to
    each value, which we call price , in the values property. When looping through
    values, we don’t have access to the keys from inside the loop.
  id: totrans-9280
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用相同风格的for-in循环，但现在我们使用一个常量来引用values属性中的每个值，称之为price。循环遍历值时，我们无法在循环内访问键。
- en: Another difference to note is that price is not an optional because it’s accessed
    directly as a value in the fruitBasket dictionary. That means we don’t have to
    unwrap it. You should still see the print statement printed three times. [Figure
    6-6](text00016.html#ch06fig6) shows the output of both loops.
  id: totrans-9281
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个需要注意的区别是，价格不是一个可选值，因为它是直接作为水果篮字典中的一个值来访问的。这意味着我们不需要解包它。你仍然应该看到打印语句打印三次。[图6-6](text00016.html#ch06fig6)显示了两个循环的输出。
- en: '![Image](Image00151.jpg)'
  id: totrans-9282
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00151.jpg)'
- en: '*Figure 6-6: Looping through the keys and values of a dictionary with a for-in
    loop*'
  id: totrans-9283
  prefs: []
  type: TYPE_NORMAL
  zh: '*图6-6：通过for-in循环遍历字典的键和值*'
- en: The order of your results might be slightly different from ours. That’s because
    the items in a dictionary aren’t in a numbered order like they are in an array!
    And because the order is not guaranteed, you might see a different order printed
    if you run the same code again.
  id: totrans-9284
  prefs: []
  type: TYPE_NORMAL
  zh: 你的结果顺序可能与我们的略有不同。那是因为字典中的项目不像数组那样按编号顺序排列！而且由于顺序无法保证，如果你再次运行相同的代码，可能会看到不同的顺序输出。
- en: '**WHAT YOU LEARNED**'
  id: totrans-9285
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**你学到了什么**'
- en: In this chapter, you learned how to store collections of items in an array and
    in a dictionary. To store items in an ordered list, you would use an array and
    look up each item by its index. If you wanted to store items by key instead, you
    would use a dictionary.
  id: totrans-9286
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你学习了如何在数组和字典中存储项目。要将项目存储在有序列表中，你需要使用数组，并通过索引查找每个项目。如果你想通过键来存储项目，则需要使用字典。
- en: Knowing about arrays and dictionaries and how to use them is a powerful building
    block for almost any programming language. Next we will learn about functions,
    another very powerful tool. Functions are blocks of code that you create and name
    to perform a specific job. After you have written a function, you can use its
    name to call it from almost anywhere in your program.
  id: totrans-9287
  prefs: []
  type: TYPE_NORMAL
  zh: 了解数组和字典以及如何使用它们是几乎任何编程语言的强大构建块。接下来，我们将学习函数，另一种非常强大的工具。函数是你创建并命名的代码块，用于执行特定的任务。编写函数后，你可以在程序中的几乎任何地方通过函数名来调用它。
- en: '[Figure 6-5](text00016.html#ch06fig5) shows the results.'
  id: totrans-9288
  prefs: []
  type: TYPE_NORMAL
  zh: '[图6-5](text00016.html#ch06fig5)显示了结果。'
- en: '![Image](Image00139.jpg)'
  id: totrans-9289
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00139.jpg)'
- en: '*Figure 6-5: Printing the squares for each number in the myNumbers array*'
  id: totrans-9290
  prefs: []
  type: TYPE_NORMAL
  zh: '*图6-5：打印myNumbers数组中每个数字的平方*'
- en: '**DICTIONARIES ARE KEY!**'
  id: totrans-9291
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**字典是关键！**'
- en: A *dictionary* is also a collection of values, but instead of an ordered index,
    each value has its own *key* . Because there’s no index, the values are not stored
    in any particular order. To access values in a dictionary, you look them up by
    their key.
  id: totrans-9292
  prefs: []
  type: TYPE_NORMAL
  zh: '*字典*也是一种值的集合，但与有序的索引不同，每个值都有自己的*键*。由于没有索引，值并不会按特定顺序存储。要访问字典中的值，你需要通过键来查找它们。'
- en: A key must be unique. You can’t have the same key more than once in the same
    dictionary. If there were two identical keys and you asked the computer to give
    you the value for one of them, the computer wouldn’t know which one to choose!
  id: totrans-9293
  prefs: []
  type: TYPE_NORMAL
  zh: 键必须是唯一的。你不能在同一个字典中有重复的键。如果有两个相同的键，而你要求计算机给出其中一个的值，计算机将不知道选择哪个！
- en: Let’s take a look at how to make a dictionary and write keys that will help
    you find all the information you need.
  id: totrans-9294
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看一下如何创建字典并编写键，这将帮助你找到所有需要的信息。
- en: '![Image](Image00140.jpg)'
  id: totrans-9295
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00140.jpg)'
- en: '**INITIALIZING A DICTIONARY**'
  id: totrans-9296
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**初始化字典**'
- en: 'To create and initialize a dictionary, first write var and the name of your
    dictionary. Then write the keys and corresponding values inside a pair of square
    brackets, similar to an array. Let’s create a dictionary to store the names of
    a few US states. The key for each state will be its two-letter abbreviation:'
  id: totrans-9297
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建并初始化字典，首先写上 var 和字典的名称。然后，将键及其对应的值写在一对方括号内，类似于数组的写法。让我们创建一个字典来存储一些美国州的名称。每个州的键将是它的两字母缩写：
- en: '![](Image00141.jpg)'
  id: totrans-9298
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00141.jpg)'
- en: As you can see, there’s a colon between each key and its value, and the key/value
    pairs are separated by commas.
  id: totrans-9299
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，每个键和值之间有一个冒号，键/值对之间用逗号分隔。
- en: Dictionaries are different from arrays in that they are *unordered* . Because
    of that, it’s likely that the order of the states that you see in your results
    pane ➋ is different from the order in which you entered your states ➊ . It might
    even be different than the order that’s printed in this book!
  id: totrans-9300
  prefs: []
  type: TYPE_NORMAL
  zh: 字典与数组不同，因为它们是 *无序* 的。因此，你看到的结果面板中州的顺序 ➋ 可能与你输入州的顺序 ➊ 完全不同，甚至可能不同于书中列出的顺序！
- en: As with arrays, you can use var to make a mutable dictionary or use let to make
    an immutable dictionary.
  id: totrans-9301
  prefs: []
  type: TYPE_NORMAL
  zh: 和数组一样，你可以使用 var 来创建可变字典，或使用 let 来创建不可变字典。
- en: 'In Swift, all of the keys of a dictionary must be the same type, and all of
    the values of a dictionary must also be the same type, but the key type doesn’t
    have to match the value type. For example, if you wanted to store a collection
    of fractions, you could use doubles for the keys and strings for the values:'
  id: totrans-9302
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Swift 中，字典的所有键必须是相同类型的，字典的所有值也必须是相同类型的，但键的类型不必与值的类型匹配。例如，如果你想存储一个分数集合，可以使用浮动类型作为键，字符串作为值：
- en: '![](Image00142.jpg)'
  id: totrans-9303
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00142.jpg)'
- en: In this dictionary, all of the keys must be doubles, and all of the values must
    be strings. Again, you’ll see that the order of the numbers in the results pane
    can be quite different from the order in which you wrote the fractions in your
    dictionary. This is fine because you don’t need to know the order to access anything.
    You can find any item that you need by its key. Let’s see how!
  id: totrans-9304
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个字典中，所有的键必须是浮动类型（doubles），而所有的值必须是字符串类型（strings）。再说一次，你会发现结果面板中的数字顺序可能与字典中输入分数的顺序完全不同。这是没问题的，因为你不需要了解顺序就能访问任何内容。你可以通过键找到你需要的任何项。让我们来看一下！
- en: '**ACCESSING VALUES IN A DICTIONARY**'
  id: totrans-9305
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**访问字典中的值**'
- en: 'Looking up a value in a dictionary is similar to how you access a value in
    an array except that you use a key inside the square brackets instead of an index,
    like this: usStates["TX"] .'
  id: totrans-9306
  prefs: []
  type: TYPE_NORMAL
  zh: 在字典中查找一个值类似于在数组中访问一个值，唯一不同的是，字典使用键而不是索引，例如：usStates["TX"]。
- en: There is a big difference, however, in how Swift returns the values from a dictionary.
    When you access a value at an index of an array, you are simply given the value.
    When you access a value with a key in a dictionary, you are given an optional.
  id: totrans-9307
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，Swift 返回字典中的值的方式有一个很大的区别。当你在数组中按索引访问一个值时，你只是简单地得到该值。当你在字典中使用键访问一个值时，你得到的是一个可选值。
- en: In [Chapter 5](text00015.html#ch05) , you learned that optionals might contain
    a value or might be nil . The reason Swift returns optionals when you’re looking
    up items in a dictionary is that the key you used might not exist in the dictionary,
    in which case there’s no value to access. Trying to access a value that doesn’t
    exist would give you a big fat error! To avoid that problem, Swift returns optionals.
    That means you need to unwrap any value you get out of a dictionary before you
    can do anything with it.
  id: totrans-9308
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第 5 章](text00015.html#ch05)中，你学习了可选类型（optionals）可能包含一个值，也可能是 nil。Swift 在查找字典中的项目时返回可选类型的原因是，你使用的键可能在字典中不存在，在这种情况下就没有值可以访问。尝试访问一个不存在的值会给你一个大错误！为了避免这个问题，Swift
    返回了可选类型。这意味着你需要解包（unwrap）从字典中获取的任何值，然后才能对其进行操作。
- en: 'To unwrap an optional, first you check whether it exists using an if-let statement,
    just like we did in [Chapter 5](text00015.html#ch05) . The following code shows
    you how to get a value out of a dictionary:'
  id: totrans-9309
  prefs: []
  type: TYPE_NORMAL
  zh: 要解包一个可选值，首先你需要使用 `if-let` 语句检查它是否存在，就像我们在[第 5 章](text00015.html#ch05)中做的那样。以下代码展示了如何从字典中获取一个值：
- en: '![Image](Image00143.jpg)'
  id: totrans-9310
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00143.jpg)'
- en: To retrieve "Texas" from the dictionary, we use if let to set a constant loneStarState
    to usStates["TX"] ➊ . Because we have this state in our dictionary, the line I
    have Texas in my dictionary. is printed. Next we try to access a state that is
    not in our dictionary by using the key usStates["FL"] ➋ . Thankfully, because
    we used an if-let statement, the program won’t crash when the computer can’t find
    this state. Instead, I don't have that state in my dictionary. is printed.
  id: totrans-9311
  prefs: []
  type: TYPE_NORMAL
  zh: 要从字典中检索 "Texas"，我们使用 `if let` 来将常量 `loneStarState` 设置为 `usStates["TX"]` ➊ 。因为我们在字典中有这个州，所以下面会打印出
    "I have Texas in my dictionary." 接下来，我们尝试使用键 `usStates["FL"]` ➋ 来访问一个不在字典中的州。幸运的是，由于我们使用了
    `if-let` 语句，当计算机无法找到这个州时，程序不会崩溃。相反，"I don't have that state in my dictionary."
    会被打印出来。
- en: '**ADDING ITEMS TO A DICTIONARY**'
  id: totrans-9312
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**向字典中添加项**'
- en: 'To add an item to a dictionary, first write the name of your dictionary and
    assign the new item to the key you want it to have in the dictionary. Let’s add
    "Minnesota" to our usStates dictionary:'
  id: totrans-9313
  prefs: []
  type: TYPE_NORMAL
  zh: 要向字典中添加一个项，首先写出字典的名称，并将新项赋值给你想要的字典键。让我们将 "Minnesota" 添加到我们的 `usStates` 字典中：
- en: '![](Image00144.jpg)'
  id: totrans-9314
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00144.jpg)'
- en: 'Now when you look at usStates , you’ll see that it’s updated to ["MN": "Minnesota",
    "WA": "Washington", "MA": "Massachusetts", "TX": "Texas"] . Remember, because
    you don’t have to rely on indices, your new dictionary item might appear anywhere
    in the dictionary.'
  id: totrans-9315
  prefs: []
  type: TYPE_NORMAL
  zh: '现在当你查看 `usStates` 时，你会看到它已更新为 ["MN": "Minnesota", "WA": "Washington", "MA":
    "Massachusetts", "TX": "Texas"] 。记住，由于你不需要依赖索引，新的字典项可能出现在字典中的任何位置。'
- en: '**REMOVING ITEMS FROM A DICTIONARY**'
  id: totrans-9316
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**从字典中移除项**'
- en: Removing an item from a dictionary is quite simple; you do so by setting the
    value to nil . Because the values in dictionaries are returned as optionals, you
    don’t have to worry about nil causing any problems in your dictionary.
  id: totrans-9317
  prefs: []
  type: TYPE_NORMAL
  zh: 从字典中移除一个项非常简单；你只需将该值设置为 `nil`。因为字典中的值是作为可选项返回的，所以你无需担心 `nil` 会在字典中引起任何问题。
- en: '![](Image00145.jpg)'
  id: totrans-9318
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00145.jpg)'
- en: 'You can see that after you remove the value at the key "MA" , usStates is updated
    to ["MN": "Minnesota", "WA": "Washington", "TX": "Texas"] . Remember that nil
    is special and means that there’s no value at all. That’s why you don’t see "MA":
    nil in our dictionary.'
  id: totrans-9319
  prefs: []
  type: TYPE_NORMAL
  zh: '你可以看到，在移除键 "MA" 对应的值之后，`usStates` 被更新为 ["MN": "Minnesota", "WA": "Washington",
    "TX": "Texas"] 。记住，`nil` 是特殊的，表示完全没有值。这就是为什么你不会在字典中看到 "MA": nil。'
- en: '**REPLACING ITEMS IN A DICTIONARY**'
  id: totrans-9320
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**在字典中替换项**'
- en: 'Replacing an item in a dictionary is also easy. It works the same was as replacing
    an item in an array. You just set the item that you want to replace to something
    else. Say you create a dictionary of fruit colors:'
  id: totrans-9321
  prefs: []
  type: TYPE_NORMAL
  zh: 在字典中替换项目也很简单。它的工作方式与替换数组中的项目相同。你只需将要替换的项设置为其他值。例如，你创建一个包含水果颜色的字典：
- en: '![](Image00146.jpg)'
  id: totrans-9322
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00146.jpg)'
- en: At first we had the value "apple" for "red" , but then we decided that "raspberry"
    is a better fruit to use since sometimes apples are green or yellow. To replace
    "apple" with "raspberry" , we set colorFruits["red"] to its new value ➊ .
  id: totrans-9323
  prefs: []
  type: TYPE_NORMAL
  zh: 起初，我们为 "red" 分配了值 "apple"，但后来我们决定使用 "raspberry" 作为更好的水果，因为有时苹果是绿色或黄色的。要将 "apple"
    替换为 "raspberry"，我们将 `colorFruits["red"]` 设置为新的值 ➊。
- en: You may remember that this is the same way we entered a new value into a dictionary.
    If the key already exists in the dictionary, then the value for that key is replaced.
    If the key doesn’t already exist, then the new key/value pair will be added to
    the dictionary.
  id: totrans-9324
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能记得，这与我们向字典中输入新值的方式相同。如果键已经存在于字典中，那么该键的值会被替换。如果键不存在，那么新的键值对将会被添加到字典中。
- en: '![Image](Image00147.jpg)'
  id: totrans-9325
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00147.jpg)'
- en: '**USING DICTIONARY PROPERTIES**'
  id: totrans-9326
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**使用字典属性**'
- en: 'Like an array, a dictionary also has an isEmpty property and a count property.
    For example, the following code shows how you can use the isEmpty property to
    check if a dictionary is empty, and if it isn’t empty, the count property checks
    how many items you have. Imagine you have a basket of fruit for sale. You can
    use these properties to help you keep track of everything:'
  id: totrans-9327
  prefs: []
  type: TYPE_NORMAL
  zh: 像数组一样，字典也具有 `isEmpty` 属性和 `count` 属性。例如，以下代码展示了如何使用 `isEmpty` 属性来检查字典是否为空，如果字典不为空，则
    `count` 属性可以检查字典中有多少项。假设你有一个水果篮子在售卖。你可以利用这些属性帮助你跟踪每一项：
- en: '![Image](Image00148.jpg)'
  id: totrans-9328
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00148.jpg)'
- en: 'A dictionary also has two special properties: keys , which contains all of
    the dictionary’s keys, and values , which contains all of its values. We’ll use
    these two properties when we loop through the dictionary.'
  id: totrans-9329
  prefs: []
  type: TYPE_NORMAL
  zh: 字典还有两个特殊属性：`keys`，它包含字典中的所有键；以及 `values`，它包含字典中的所有值。当我们循环遍历字典时，会使用这两个属性。
- en: Let’s write some code that loops through our fruit baskets and prints the price
    of each fruit.
  id: totrans-9330
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们写些代码，遍历我们的水果篮并打印每个水果的价格。
- en: '**LOOPING OVER A DICTIONARY**'
  id: totrans-9331
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**遍历字典**'
- en: 'You can loop through a dictionary using a for-in loop. Because each item has
    a key and a value, you can do this in two different ways. This is how to loop
    through a dictionary using its keys:'
  id: totrans-9332
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用 `for-in` 循环遍历字典。因为每个条目都有一个键和值，所以你可以用两种不同的方式来做到这一点。以下是如何通过字典的键来循环遍历字典：
- en: '![Image](Image00149.jpg)'
  id: totrans-9333
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00149.jpg)'
- en: Here we use the dictionary’s keys property ➊ to loop through fruitBasket and
    print its contents. We start by writing the keyword for , followed by a constant
    name fruit for the dictionary key, the keyword in , the dictionary name, a period,
    and keys .
  id: totrans-9334
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们使用字典的 `keys` 属性 ➊ 来遍历 `fruitBasket` 并打印其内容。我们首先写 `for` 关键字，然后是常量名 `fruit`，代表字典的键，接着是
    `in` 关键字，字典名，句点，最后是 `keys`。
- en: Inside the braces of our for-in loop, we have access to both the key, which
    we call fruit ➋ , and the value at that key when we force-unwrap its contents
    with fruitBasket[fruit]! ➌ . That value will be the fruit’s price.
  id: totrans-9335
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `for-in` 循环的花括号内，我们可以访问键 `fruit` ➋，并且当我们强制解包其内容时，能够通过 `fruitBasket[fruit]!`
    ➌ 获取该键的值。这个值将是水果的价格。
- en: In this case, it’s safe to force-unwrap the value using an exclamation point
    because we know that the fruit key we’re using is definitely inside the dictionary.
  id: totrans-9336
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，强制解包值是安全的，因为我们知道我们使用的水果键一定在字典中。
- en: Any code we put inside the for-in loop will run once for every key in our dictionary.
    So you should see the print statement display three times.
  id: totrans-9337
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在 `for-in` 循环内部放置的任何代码都会在字典中的每个键上运行一次。因此，你应该能看到打印语句打印三次。
- en: 'We can also loop through the dictionary using its values property:'
  id: totrans-9338
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以通过字典的 `values` 属性来循环遍历字典：
- en: '![Image](Image00150.jpg)'
  id: totrans-9339
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00150.jpg)'
- en: We use the same style of for-in loop, but now we use a constant to refer to
    each value, which we call price , in the values property. When looping through
    values, we don’t have access to the keys from inside the loop.
  id: totrans-9340
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用相同类型的 `for-in` 循环，但现在我们使用常量来引用 `values` 属性中的每个值，我们称之为 `price`。在循环遍历 `values`
    时，我们无法从循环内访问键。
- en: Another difference to note is that price is not an optional because it’s accessed
    directly as a value in the fruitBasket dictionary. That means we don’t have to
    unwrap it. You should still see the print statement printed three times. [Figure
    6-6](text00016.html#ch06fig6) shows the output of both loops.
  id: totrans-9341
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个需要注意的区别是价格不是可选的，因为它直接作为值访问于 `fruitBasket` 字典中。这意味着我们不需要解包它。你应该仍然能看到打印语句被打印三次。[图
    6-6](text00016.html#ch06fig6) 显示了两个循环的输出。
- en: '![Image](Image00151.jpg)'
  id: totrans-9342
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00151.jpg)'
- en: '*Figure 6-6: Looping through the keys and values of a dictionary with a for-in
    loop*'
  id: totrans-9343
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 6-6：使用 `for-in` 循环遍历字典的键和值*'
- en: The order of your results might be slightly different from ours. That’s because
    the items in a dictionary aren’t in a numbered order like they are in an array!
    And because the order is not guaranteed, you might see a different order printed
    if you run the same code again.
  id: totrans-9344
  prefs: []
  type: TYPE_NORMAL
  zh: 你的结果顺序可能与我们的略有不同。那是因为字典中的项不像数组中的项那样按编号顺序排列！并且因为顺序不保证，所以如果你再次运行相同的代码，可能会看到不同的打印顺序。
- en: '**WHAT YOU LEARNED**'
  id: totrans-9345
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**你学到了什么**'
- en: In this chapter, you learned how to store collections of items in an array and
    in a dictionary. To store items in an ordered list, you would use an array and
    look up each item by its index. If you wanted to store items by key instead, you
    would use a dictionary.
  id: totrans-9346
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你学会了如何将项存储在数组和字典中。要将项存储在有序列表中，你会使用数组并通过索引查找每个项。如果你想通过键存储项，你则使用字典。
- en: Knowing about arrays and dictionaries and how to use them is a powerful building
    block for almost any programming language. Next we will learn about functions,
    another very powerful tool. Functions are blocks of code that you create and name
    to perform a specific job. After you have written a function, you can use its
    name to call it from almost anywhere in your program.
  id: totrans-9347
  prefs: []
  type: TYPE_NORMAL
  zh: 了解数组和字典及其使用方法是几乎任何编程语言中的一个强大构建块。接下来，我们将学习函数，这是另一个非常强大的工具。函数是你创建并命名的代码块，用于执行特定的任务。编写了函数后，你可以通过它的名称在程序中的几乎任何地方调用它。
- en: '![Image](Image00139.jpg)'
  id: totrans-9348
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00139.jpg)'
- en: '*Figure 6-5: Printing the squares for each number in the myNumbers array*'
  id: totrans-9349
  prefs: []
  type: TYPE_NORMAL
  zh: '*图6-5：打印myNumbers数组中每个数字的平方*'
- en: '**DICTIONARIES ARE KEY!**'
  id: totrans-9350
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**字典是关键！**'
- en: A *dictionary* is also a collection of values, but instead of an ordered index,
    each value has its own *key* . Because there’s no index, the values are not stored
    in any particular order. To access values in a dictionary, you look them up by
    their key.
  id: totrans-9351
  prefs: []
  type: TYPE_NORMAL
  zh: 一个*字典*也是一个值的集合，但不同于有序的索引，每个值都有自己的*键*。由于没有索引，值不会按特定顺序存储。要访问字典中的值，你需要通过键查找它们。
- en: A key must be unique. You can’t have the same key more than once in the same
    dictionary. If there were two identical keys and you asked the computer to give
    you the value for one of them, the computer wouldn’t know which one to choose!
  id: totrans-9352
  prefs: []
  type: TYPE_NORMAL
  zh: 键必须是唯一的。你不能在同一个字典中有两个相同的键。如果有两个相同的键，而你要求计算机给出其中一个的值，计算机将不知道该选择哪个！
- en: Let’s take a look at how to make a dictionary and write keys that will help
    you find all the information you need.
  id: totrans-9353
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如何创建一个字典，并写下能够帮助你找到所需信息的键。
- en: '![Image](Image00140.jpg)'
  id: totrans-9354
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00140.jpg)'
- en: '**INITIALIZING A DICTIONARY**'
  id: totrans-9355
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**初始化字典**'
- en: 'To create and initialize a dictionary, first write var and the name of your
    dictionary. Then write the keys and corresponding values inside a pair of square
    brackets, similar to an array. Let’s create a dictionary to store the names of
    a few US states. The key for each state will be its two-letter abbreviation:'
  id: totrans-9356
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建和初始化一个字典，首先写上`var`和字典的名称。然后将键和值放在一对方括号内，类似于数组的写法。让我们创建一个字典来存储一些美国州的名称。每个州的键将是它的两字母缩写：
- en: '![](Image00141.jpg)'
  id: totrans-9357
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00141.jpg)'
- en: As you can see, there’s a colon between each key and its value, and the key/value
    pairs are separated by commas.
  id: totrans-9358
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，每个键和值之间有一个冒号，键/值对由逗号分隔。
- en: Dictionaries are different from arrays in that they are *unordered* . Because
    of that, it’s likely that the order of the states that you see in your results
    pane ➋ is different from the order in which you entered your states ➊ . It might
    even be different than the order that’s printed in this book!
  id: totrans-9359
  prefs: []
  type: TYPE_NORMAL
  zh: 字典与数组的不同之处在于它是*无序的*。因此，结果窗格中显示的州的顺序➋可能与输入时的顺序➊不同，甚至可能与本书中打印的顺序不同！
- en: As with arrays, you can use var to make a mutable dictionary or use let to make
    an immutable dictionary.
  id: totrans-9360
  prefs: []
  type: TYPE_NORMAL
  zh: 与数组一样，你可以使用`var`来创建一个可变字典，或者使用`let`来创建一个不可变字典。
- en: 'In Swift, all of the keys of a dictionary must be the same type, and all of
    the values of a dictionary must also be the same type, but the key type doesn’t
    have to match the value type. For example, if you wanted to store a collection
    of fractions, you could use doubles for the keys and strings for the values:'
  id: totrans-9361
  prefs: []
  type: TYPE_NORMAL
  zh: 在Swift中，字典的所有键必须是相同类型的，字典的所有值也必须是相同类型的，但键类型不必与值类型匹配。例如，如果你想存储一组分数，你可以使用`double`作为键，`string`作为值：
- en: '![](Image00142.jpg)'
  id: totrans-9362
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00142.jpg)'
- en: In this dictionary, all of the keys must be doubles, and all of the values must
    be strings. Again, you’ll see that the order of the numbers in the results pane
    can be quite different from the order in which you wrote the fractions in your
    dictionary. This is fine because you don’t need to know the order to access anything.
    You can find any item that you need by its key. Let’s see how!
  id: totrans-9363
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个字典中，所有的键必须是`double`类型，所有的值必须是`string`类型。再次强调，你会发现结果窗格中的数字顺序可能与字典中分数的顺序大不相同。这没问题，因为你无需了解顺序就能访问任何内容。你可以通过键找到你需要的任何项。让我们来看看！
- en: '**ACCESSING VALUES IN A DICTIONARY**'
  id: totrans-9364
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**访问字典中的值**'
- en: 'Looking up a value in a dictionary is similar to how you access a value in
    an array except that you use a key inside the square brackets instead of an index,
    like this: usStates["TX"] .'
  id: totrans-9365
  prefs: []
  type: TYPE_NORMAL
  zh: 在字典中查找值类似于你在数组中访问值的方式，只不过你是在方括号内使用键，而不是索引，像这样：usStates["TX"]。
- en: There is a big difference, however, in how Swift returns the values from a dictionary.
    When you access a value at an index of an array, you are simply given the value.
    When you access a value with a key in a dictionary, you are given an optional.
  id: totrans-9366
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在 Swift 中返回字典值的方式有很大不同。当你访问数组中的某个索引时，你直接得到值。当你通过键访问字典中的值时，你得到的是一个可选值。
- en: In [Chapter 5](text00015.html#ch05) , you learned that optionals might contain
    a value or might be nil . The reason Swift returns optionals when you’re looking
    up items in a dictionary is that the key you used might not exist in the dictionary,
    in which case there’s no value to access. Trying to access a value that doesn’t
    exist would give you a big fat error! To avoid that problem, Swift returns optionals.
    That means you need to unwrap any value you get out of a dictionary before you
    can do anything with it.
  id: totrans-9367
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第5章](text00015.html#ch05)中，你学到过可选值可能包含一个值，也可能是 nil。Swift 在你查找字典中的项目时返回可选值的原因是你使用的键可能在字典中不存在，这种情况下就没有值可供访问。尝试访问一个不存在的值会导致一个错误！为了避免这个问题，Swift
    返回可选值。这意味着你需要在使用字典中的值之前，先解包它。
- en: 'To unwrap an optional, first you check whether it exists using an if-let statement,
    just like we did in [Chapter 5](text00015.html#ch05) . The following code shows
    you how to get a value out of a dictionary:'
  id: totrans-9368
  prefs: []
  type: TYPE_NORMAL
  zh: 要解包一个可选值，首先使用 if-let 语句检查它是否存在，就像我们在[第5章](text00015.html#ch05)中做的那样。下面的代码展示了如何从字典中获取一个值：
- en: '![Image](Image00143.jpg)'
  id: totrans-9369
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00143.jpg)'
- en: To retrieve "Texas" from the dictionary, we use if let to set a constant loneStarState
    to usStates["TX"] ➊ . Because we have this state in our dictionary, the line I
    have Texas in my dictionary. is printed. Next we try to access a state that is
    not in our dictionary by using the key usStates["FL"] ➋ . Thankfully, because
    we used an if-let statement, the program won’t crash when the computer can’t find
    this state. Instead, I don't have that state in my dictionary. is printed.
  id: totrans-9370
  prefs: []
  type: TYPE_NORMAL
  zh: 要从字典中获取 "Texas"，我们使用 if let 将常量 loneStarState 设置为 usStates["TX"] ➊。由于我们在字典中有这个州，打印出
    "I have Texas in my dictionary." 接着，我们尝试通过使用键 usStates["FL"] ➋ 访问一个不在字典中的州。幸运的是，由于我们使用了
    if-let 语句，当计算机找不到该州时，程序不会崩溃。相反，打印出 "I don't have that state in my dictionary."。
- en: '**ADDING ITEMS TO A DICTIONARY**'
  id: totrans-9371
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**向字典添加项**'
- en: 'To add an item to a dictionary, first write the name of your dictionary and
    assign the new item to the key you want it to have in the dictionary. Let’s add
    "Minnesota" to our usStates dictionary:'
  id: totrans-9372
  prefs: []
  type: TYPE_NORMAL
  zh: 要向字典中添加一项，首先写出字典的名称，并将新项分配给你希望它在字典中拥有的键。让我们把 "Minnesota" 添加到我们的 usStates 字典中：
- en: '![](Image00144.jpg)'
  id: totrans-9373
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00144.jpg)'
- en: 'Now when you look at usStates , you’ll see that it’s updated to ["MN": "Minnesota",
    "WA": "Washington", "MA": "Massachusetts", "TX": "Texas"] . Remember, because
    you don’t have to rely on indices, your new dictionary item might appear anywhere
    in the dictionary.'
  id: totrans-9374
  prefs: []
  type: TYPE_NORMAL
  zh: '现在，当你查看 usStates 时，你会看到它已更新为 ["MN": "Minnesota", "WA": "Washington", "MA":
    "Massachusetts", "TX": "Texas"]。记住，由于你不需要依赖索引，因此新的字典项可能出现在字典的任何位置。'
- en: '**REMOVING ITEMS FROM A DICTIONARY**'
  id: totrans-9375
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**从字典中移除项**'
- en: Removing an item from a dictionary is quite simple; you do so by setting the
    value to nil . Because the values in dictionaries are returned as optionals, you
    don’t have to worry about nil causing any problems in your dictionary.
  id: totrans-9376
  prefs: []
  type: TYPE_NORMAL
  zh: 从字典中移除一项非常简单；你只需将该值设置为 nil。因为字典中的值是作为可选值返回的，所以你无需担心 nil 会在字典中造成任何问题。
- en: '![](Image00145.jpg)'
  id: totrans-9377
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00145.jpg)'
- en: 'You can see that after you remove the value at the key "MA" , usStates is updated
    to ["MN": "Minnesota", "WA": "Washington", "TX": "Texas"] . Remember that nil
    is special and means that there’s no value at all. That’s why you don’t see "MA":
    nil in our dictionary.'
  id: totrans-9378
  prefs: []
  type: TYPE_NORMAL
  zh: '你可以看到，当你移除键 "MA" 对应的值时，usStates 被更新为 ["MN": "Minnesota", "WA": "Washington",
    "TX": "Texas"]。记住，nil 是特殊的，意味着根本没有值。这就是为什么你在字典中看不到 "MA": nil 的原因。'
- en: '**REPLACING ITEMS IN A DICTIONARY**'
  id: totrans-9379
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**替换字典中的项**'
- en: 'Replacing an item in a dictionary is also easy. It works the same was as replacing
    an item in an array. You just set the item that you want to replace to something
    else. Say you create a dictionary of fruit colors:'
  id: totrans-9380
  prefs: []
  type: TYPE_NORMAL
  zh: 替换字典中的一项也很简单。它的工作方式与替换数组中的项相同。你只需将要替换的项设置为其他值。假设你创建了一个水果颜色的字典：
- en: '![](Image00146.jpg)'
  id: totrans-9381
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00146.jpg)'
- en: At first we had the value "apple" for "red" , but then we decided that "raspberry"
    is a better fruit to use since sometimes apples are green or yellow. To replace
    "apple" with "raspberry" , we set colorFruits["red"] to its new value ➊ .
  id: totrans-9382
  prefs: []
  type: TYPE_NORMAL
  zh: 起初，我们给"red"赋了"apple"的值，但后来我们决定"raspberry"是一个更好的水果，因为有时候苹果是绿色或黄色的。为了将"apple"替换为"raspberry"，我们将`colorFruits["red"]`设置为它的新值
    ➊ 。
- en: You may remember that this is the same way we entered a new value into a dictionary.
    If the key already exists in the dictionary, then the value for that key is replaced.
    If the key doesn’t already exist, then the new key/value pair will be added to
    the dictionary.
  id: totrans-9383
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能记得，这是我们将新值输入字典的相同方式。如果字典中已经存在该键，那么该键的值将被替换。如果该键不存在，那么新的键/值对将会被添加到字典中。
- en: '![Image](Image00147.jpg)'
  id: totrans-9384
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00147.jpg)'
- en: '**USING DICTIONARY PROPERTIES**'
  id: totrans-9385
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**使用字典属性**'
- en: 'Like an array, a dictionary also has an isEmpty property and a count property.
    For example, the following code shows how you can use the isEmpty property to
    check if a dictionary is empty, and if it isn’t empty, the count property checks
    how many items you have. Imagine you have a basket of fruit for sale. You can
    use these properties to help you keep track of everything:'
  id: totrans-9386
  prefs: []
  type: TYPE_NORMAL
  zh: 像数组一样，字典也有`isEmpty`属性和`count`属性。例如，以下代码展示了如何使用`isEmpty`属性检查字典是否为空，如果不为空，则`count`属性检查你有多少项。假设你有一个待售的水果篮子。你可以使用这些属性来帮助你跟踪一切：
- en: '![Image](Image00148.jpg)'
  id: totrans-9387
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00148.jpg)'
- en: 'A dictionary also has two special properties: keys , which contains all of
    the dictionary’s keys, and values , which contains all of its values. We’ll use
    these two properties when we loop through the dictionary.'
  id: totrans-9388
  prefs: []
  type: TYPE_NORMAL
  zh: 字典还有两个特殊属性：`keys`，它包含字典的所有键，以及`values`，它包含所有的值。我们将在循环遍历字典时使用这两个属性。
- en: Let’s write some code that loops through our fruit baskets and prints the price
    of each fruit.
  id: totrans-9389
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们写一些代码，循环遍历我们的水果篮子并打印每种水果的价格。
- en: '**LOOPING OVER A DICTIONARY**'
  id: totrans-9390
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**循环遍历字典**'
- en: 'You can loop through a dictionary using a for-in loop. Because each item has
    a key and a value, you can do this in two different ways. This is how to loop
    through a dictionary using its keys:'
  id: totrans-9391
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用`for-in`循环遍历字典。因为每个项都有键和值，你可以通过两种不同的方式来做到这一点。以下是如何使用字典的键来循环遍历字典：
- en: '![Image](Image00149.jpg)'
  id: totrans-9392
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00149.jpg)'
- en: Here we use the dictionary’s keys property ➊ to loop through fruitBasket and
    print its contents. We start by writing the keyword for , followed by a constant
    name fruit for the dictionary key, the keyword in , the dictionary name, a period,
    and keys .
  id: totrans-9393
  prefs: []
  type: TYPE_NORMAL
  zh: 这里我们使用字典的`keys`属性 ➊ 来循环遍历`fruitBasket`并打印其内容。我们首先写出`for`关键字，后跟字典键的常量名称`fruit`，然后是`in`关键字，字典名，句点，和`keys`。
- en: Inside the braces of our for-in loop, we have access to both the key, which
    we call fruit ➋ , and the value at that key when we force-unwrap its contents
    with fruitBasket[fruit]! ➌ . That value will be the fruit’s price.
  id: totrans-9394
  prefs: []
  type: TYPE_NORMAL
  zh: 在`for-in`循环的大括号内部，我们可以访问键（我们称之为`fruit` ➋ ）以及通过`fruitBasket[fruit]!`强制解包其内容后的值
    ➌ 。该值将是水果的价格。
- en: In this case, it’s safe to force-unwrap the value using an exclamation point
    because we know that the fruit key we’re using is definitely inside the dictionary.
  id: totrans-9395
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，使用感叹号强制解包值是安全的，因为我们知道我们使用的水果键肯定在字典中。
- en: Any code we put inside the for-in loop will run once for every key in our dictionary.
    So you should see the print statement display three times.
  id: totrans-9396
  prefs: []
  type: TYPE_NORMAL
  zh: 我们放入`for-in`循环中的任何代码都会对字典中的每个键执行一次。所以你应该看到打印语句打印三次。
- en: 'We can also loop through the dictionary using its values property:'
  id: totrans-9397
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以使用字典的`values`属性来循环遍历字典：
- en: '![Image](Image00150.jpg)'
  id: totrans-9398
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00150.jpg)'
- en: We use the same style of for-in loop, but now we use a constant to refer to
    each value, which we call price , in the values property. When looping through
    values, we don’t have access to the keys from inside the loop.
  id: totrans-9399
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用相同风格的`for-in`循环，但现在我们使用一个常量来引用`values`属性中的每个值，我们称之为`price`。在循环遍历`values`时，我们无法从循环内部访问键。
- en: Another difference to note is that price is not an optional because it’s accessed
    directly as a value in the fruitBasket dictionary. That means we don’t have to
    unwrap it. You should still see the print statement printed three times. [Figure
    6-6](text00016.html#ch06fig6) shows the output of both loops.
  id: totrans-9400
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个需要注意的区别是，`price`不是一个可选项，因为它是直接作为值在`fruitBasket`字典中访问的。这意味着我们不需要解包它。你仍然应该看到打印语句打印三次。[图
    6-6](text00016.html#ch06fig6)显示了两个循环的输出。
- en: '![Image](Image00151.jpg)'
  id: totrans-9401
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00151.jpg)'
- en: '*Figure 6-6: Looping through the keys and values of a dictionary with a for-in
    loop*'
  id: totrans-9402
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 6-6：使用 for-in 循环遍历字典的键和值*'
- en: The order of your results might be slightly different from ours. That’s because
    the items in a dictionary aren’t in a numbered order like they are in an array!
    And because the order is not guaranteed, you might see a different order printed
    if you run the same code again.
  id: totrans-9403
  prefs: []
  type: TYPE_NORMAL
  zh: 你的结果顺序可能会与我们的稍有不同。这是因为字典中的项目不像数组那样按编号顺序排列！并且由于顺序没有保证，如果你再次运行相同的代码，可能会看到不同的顺序。
- en: '**WHAT YOU LEARNED**'
  id: totrans-9404
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**你学到了什么**'
- en: In this chapter, you learned how to store collections of items in an array and
    in a dictionary. To store items in an ordered list, you would use an array and
    look up each item by its index. If you wanted to store items by key instead, you
    would use a dictionary.
  id: totrans-9405
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你学习了如何将项目集合存储在数组和字典中。要将项目存储在有序列表中，你会使用数组，并通过索引查找每个项目。如果你想通过键存储项目，则会使用字典。
- en: Knowing about arrays and dictionaries and how to use them is a powerful building
    block for almost any programming language. Next we will learn about functions,
    another very powerful tool. Functions are blocks of code that you create and name
    to perform a specific job. After you have written a function, you can use its
    name to call it from almost anywhere in your program.
  id: totrans-9406
  prefs: []
  type: TYPE_NORMAL
  zh: 了解数组和字典以及如何使用它们，是几乎任何编程语言的一个强大基础。接下来我们将学习函数，这是另一个非常强大的工具。函数是你创建并命名的代码块，用来执行特定的任务。编写完一个函数后，你可以通过它的名称在程序的几乎任何地方调用它。
- en: '*Figure 6-5: Printing the squares for each number in the myNumbers array*'
  id: totrans-9407
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 6-5：打印 myNumbers 数组中每个数字的平方*'
- en: '**DICTIONARIES ARE KEY!**'
  id: totrans-9408
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**字典是关键！**'
- en: A *dictionary* is also a collection of values, but instead of an ordered index,
    each value has its own *key* . Because there’s no index, the values are not stored
    in any particular order. To access values in a dictionary, you look them up by
    their key.
  id: totrans-9409
  prefs: []
  type: TYPE_NORMAL
  zh: 一个*字典*也是一个值的集合，但与数组不同，每个值都有自己的*键*。由于没有索引，值并没有按照特定顺序存储。要访问字典中的值，你需要通过键查找它们。
- en: A key must be unique. You can’t have the same key more than once in the same
    dictionary. If there were two identical keys and you asked the computer to give
    you the value for one of them, the computer wouldn’t know which one to choose!
  id: totrans-9410
  prefs: []
  type: TYPE_NORMAL
  zh: 一个键必须是唯一的。你不能在同一个字典中使用相同的键两次。如果有两个相同的键，当你请求计算机给出其中一个的值时，计算机将不知道选择哪一个！
- en: Let’s take a look at how to make a dictionary and write keys that will help
    you find all the information you need.
  id: totrans-9411
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看如何创建一个字典，并编写键，以帮助你找到所有需要的信息。
- en: '![Image](Image00140.jpg)'
  id: totrans-9412
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00140.jpg)'
- en: '**INITIALIZING A DICTIONARY**'
  id: totrans-9413
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**初始化字典**'
- en: 'To create and initialize a dictionary, first write var and the name of your
    dictionary. Then write the keys and corresponding values inside a pair of square
    brackets, similar to an array. Let’s create a dictionary to store the names of
    a few US states. The key for each state will be its two-letter abbreviation:'
  id: totrans-9414
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建和初始化字典，首先写下 var 和字典的名称。然后，在一对方括号内写下键及其对应的值，类似于数组。让我们创建一个字典来存储一些美国州的名称。每个州的键将是它的两字母缩写：
- en: '![](Image00141.jpg)'
  id: totrans-9415
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00141.jpg)'
- en: As you can see, there’s a colon between each key and its value, and the key/value
    pairs are separated by commas.
  id: totrans-9416
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，键和值之间有一个冒号，键值对之间由逗号分隔。
- en: Dictionaries are different from arrays in that they are *unordered* . Because
    of that, it’s likely that the order of the states that you see in your results
    pane ➋ is different from the order in which you entered your states ➊ . It might
    even be different than the order that’s printed in this book!
  id: totrans-9417
  prefs: []
  type: TYPE_NORMAL
  zh: 字典与数组的不同之处在于，它们是*无序*的。由于这一点，你在结果面板➋中看到的状态顺序可能与输入状态的顺序➊不同，甚至可能与本书中打印的顺序不同！
- en: As with arrays, you can use var to make a mutable dictionary or use let to make
    an immutable dictionary.
  id: totrans-9418
  prefs: []
  type: TYPE_NORMAL
  zh: 与数组一样，你可以使用 var 来创建可变字典，或者使用 let 来创建不可变字典。
- en: 'In Swift, all of the keys of a dictionary must be the same type, and all of
    the values of a dictionary must also be the same type, but the key type doesn’t
    have to match the value type. For example, if you wanted to store a collection
    of fractions, you could use doubles for the keys and strings for the values:'
  id: totrans-9419
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Swift 中，字典的所有键必须是相同类型的，字典的所有值也必须是相同类型的，但键的类型不必与值的类型匹配。例如，如果你想存储一个分数集合，你可以使用双精度浮点数作为键，字符串作为值：
- en: '![](Image00142.jpg)'
  id: totrans-9420
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00142.jpg)'
- en: In this dictionary, all of the keys must be doubles, and all of the values must
    be strings. Again, you’ll see that the order of the numbers in the results pane
    can be quite different from the order in which you wrote the fractions in your
    dictionary. This is fine because you don’t need to know the order to access anything.
    You can find any item that you need by its key. Let’s see how!
  id: totrans-9421
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个字典中，所有的键必须是双精度数，所有的值必须是字符串。再次强调，你会看到结果窗格中的数字顺序可能与写入字典中的分数顺序有很大不同。这没关系，因为你不需要知道顺序就能访问任何内容。你可以通过键找到你需要的任何项。让我们看看怎么做！
- en: '**ACCESSING VALUES IN A DICTIONARY**'
  id: totrans-9422
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**访问字典中的值**'
- en: 'Looking up a value in a dictionary is similar to how you access a value in
    an array except that you use a key inside the square brackets instead of an index,
    like this: usStates["TX"] .'
  id: totrans-9423
  prefs: []
  type: TYPE_NORMAL
  zh: 在字典中查找值类似于在数组中访问值，只是你使用方括号中的键，而不是索引，像这样：usStates["TX"]。
- en: There is a big difference, however, in how Swift returns the values from a dictionary.
    When you access a value at an index of an array, you are simply given the value.
    When you access a value with a key in a dictionary, you are given an optional.
  id: totrans-9424
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，Swift从字典中返回值的方式有很大的不同。当你访问数组中的一个值时，你只是得到这个值。当你使用键访问字典中的值时，你得到的是一个可选项。
- en: In [Chapter 5](text00015.html#ch05) , you learned that optionals might contain
    a value or might be nil . The reason Swift returns optionals when you’re looking
    up items in a dictionary is that the key you used might not exist in the dictionary,
    in which case there’s no value to access. Trying to access a value that doesn’t
    exist would give you a big fat error! To avoid that problem, Swift returns optionals.
    That means you need to unwrap any value you get out of a dictionary before you
    can do anything with it.
  id: totrans-9425
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第5章](text00015.html#ch05)中，你学到了可选项可能包含一个值，也可能是nil。当你在字典中查找项目时，Swift返回可选项的原因是你使用的键在字典中可能不存在，在这种情况下无法访问任何值。尝试访问一个不存在的值会导致一个巨大的错误！为避免这个问题，Swift返回可选项。这意味着你需要解包字典中得到的任何值，才能对其进行操作。
- en: 'To unwrap an optional, first you check whether it exists using an if-let statement,
    just like we did in [Chapter 5](text00015.html#ch05) . The following code shows
    you how to get a value out of a dictionary:'
  id: totrans-9426
  prefs: []
  type: TYPE_NORMAL
  zh: 要解包一个可选项，首先使用if-let语句检查它是否存在，就像我们在[第5章](text00015.html#ch05)中做的那样。以下代码演示了如何从字典中获取一个值：
- en: '![Image](Image00143.jpg)'
  id: totrans-9427
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00143.jpg)'
- en: To retrieve "Texas" from the dictionary, we use if let to set a constant loneStarState
    to usStates["TX"] ➊ . Because we have this state in our dictionary, the line I
    have Texas in my dictionary. is printed. Next we try to access a state that is
    not in our dictionary by using the key usStates["FL"] ➋ . Thankfully, because
    we used an if-let statement, the program won’t crash when the computer can’t find
    this state. Instead, I don't have that state in my dictionary. is printed.
  id: totrans-9428
  prefs: []
  type: TYPE_NORMAL
  zh: 要从字典中检索"Texas"，我们使用if let将常量loneStarState设置为usStates["TX"] ➊。因为我们在字典中有这个州，所以打印出“我在字典中有Texas”。接下来，我们尝试通过使用键usStates["FL"]
    ➋访问一个不在字典中的州。幸运的是，因为我们使用了if-let语句，当计算机找不到这个州时，程序不会崩溃。相反，打印出“我在字典中没有那个州”。
- en: '**ADDING ITEMS TO A DICTIONARY**'
  id: totrans-9429
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**向字典添加项**'
- en: 'To add an item to a dictionary, first write the name of your dictionary and
    assign the new item to the key you want it to have in the dictionary. Let’s add
    "Minnesota" to our usStates dictionary:'
  id: totrans-9430
  prefs: []
  type: TYPE_NORMAL
  zh: 要向字典添加项，首先写下字典的名称，并将新项分配给你希望它在字典中拥有的键。让我们将"Minnesota"添加到我们的usStates字典中：
- en: '![](Image00144.jpg)'
  id: totrans-9431
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00144.jpg)'
- en: 'Now when you look at usStates , you’ll see that it’s updated to ["MN": "Minnesota",
    "WA": "Washington", "MA": "Massachusetts", "TX": "Texas"] . Remember, because
    you don’t have to rely on indices, your new dictionary item might appear anywhere
    in the dictionary.'
  id: totrans-9432
  prefs: []
  type: TYPE_NORMAL
  zh: '现在当你查看usStates时，你会看到它已更新为["MN": "Minnesota", "WA": "Washington", "MA": "Massachusetts",
    "TX": "Texas"]。记住，因为你不需要依赖索引，所以新的字典项可能出现在字典的任何位置。'
- en: '**REMOVING ITEMS FROM A DICTIONARY**'
  id: totrans-9433
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**从字典中删除项**'
- en: Removing an item from a dictionary is quite simple; you do so by setting the
    value to nil . Because the values in dictionaries are returned as optionals, you
    don’t have to worry about nil causing any problems in your dictionary.
  id: totrans-9434
  prefs: []
  type: TYPE_NORMAL
  zh: 从字典中删除项非常简单；你只需将值设置为nil。因为字典中的值是以可选项返回的，所以你无需担心nil会在字典中引起任何问题。
- en: '![](Image00145.jpg)'
  id: totrans-9435
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00145.jpg)'
- en: 'You can see that after you remove the value at the key "MA" , usStates is updated
    to ["MN": "Minnesota", "WA": "Washington", "TX": "Texas"] . Remember that nil
    is special and means that there’s no value at all. That’s why you don’t see "MA":
    nil in our dictionary.'
  id: totrans-9436
  prefs: []
  type: TYPE_NORMAL
  zh: '你可以看到，在你移除 "MA" 键对应的值之后，`usStates` 被更新为 `["MN": "Minnesota", "WA": "Washington",
    "TX": "Texas"]`。记住，`nil` 是特别的，表示没有值。这就是为什么在字典中你看不到 "MA": nil。'
- en: '**REPLACING ITEMS IN A DICTIONARY**'
  id: totrans-9437
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**替换字典中的项**'
- en: 'Replacing an item in a dictionary is also easy. It works the same was as replacing
    an item in an array. You just set the item that you want to replace to something
    else. Say you create a dictionary of fruit colors:'
  id: totrans-9438
  prefs: []
  type: TYPE_NORMAL
  zh: 替换字典中的项目也很简单。它和替换数组中的项目是一样的。你只需要将你想要替换的项设置为其他值。例如，你创建了一个包含水果颜色的字典：
- en: '![](Image00146.jpg)'
  id: totrans-9439
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00146.jpg)'
- en: At first we had the value "apple" for "red" , but then we decided that "raspberry"
    is a better fruit to use since sometimes apples are green or yellow. To replace
    "apple" with "raspberry" , we set colorFruits["red"] to its new value ➊ .
  id: totrans-9440
  prefs: []
  type: TYPE_NORMAL
  zh: 一开始，我们为 "red" 设置了值 "apple"，但后来我们决定 "raspberry" 更适合作为水果，因为有时苹果是绿色或黄色的。为了将 "apple"
    替换为 "raspberry"，我们将 `colorFruits["red"]` 设置为新的值 ➊。
- en: You may remember that this is the same way we entered a new value into a dictionary.
    If the key already exists in the dictionary, then the value for that key is replaced.
    If the key doesn’t already exist, then the new key/value pair will be added to
    the dictionary.
  id: totrans-9441
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能记得，这和我们将新值添加到字典中的方式是一样的。如果键已经存在于字典中，那么该键的值会被替换。如果键不存在，新的键/值对会被添加到字典中。
- en: '![Image](Image00147.jpg)'
  id: totrans-9442
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00147.jpg)'
- en: '**USING DICTIONARY PROPERTIES**'
  id: totrans-9443
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**使用字典属性**'
- en: 'Like an array, a dictionary also has an isEmpty property and a count property.
    For example, the following code shows how you can use the isEmpty property to
    check if a dictionary is empty, and if it isn’t empty, the count property checks
    how many items you have. Imagine you have a basket of fruit for sale. You can
    use these properties to help you keep track of everything:'
  id: totrans-9444
  prefs: []
  type: TYPE_NORMAL
  zh: 像数组一样，字典也有 `isEmpty` 属性和 `count` 属性。例如，以下代码展示了如何使用 `isEmpty` 属性检查字典是否为空，如果不为空，则
    `count` 属性可以检查字典中有多少项。假设你有一个待售的水果篮，你可以使用这些属性帮助你跟踪所有内容：
- en: '![Image](Image00148.jpg)'
  id: totrans-9445
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00148.jpg)'
- en: 'A dictionary also has two special properties: keys , which contains all of
    the dictionary’s keys, and values , which contains all of its values. We’ll use
    these two properties when we loop through the dictionary.'
  id: totrans-9446
  prefs: []
  type: TYPE_NORMAL
  zh: 字典还有两个特殊的属性：`keys`，它包含字典中的所有键，和 `values`，它包含所有的值。当我们遍历字典时，会用到这两个属性。
- en: Let’s write some code that loops through our fruit baskets and prints the price
    of each fruit.
  id: totrans-9447
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们编写一些代码，遍历我们的水果篮并打印每种水果的价格。
- en: '**LOOPING OVER A DICTIONARY**'
  id: totrans-9448
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**遍历字典**'
- en: 'You can loop through a dictionary using a for-in loop. Because each item has
    a key and a value, you can do this in two different ways. This is how to loop
    through a dictionary using its keys:'
  id: totrans-9449
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用 `for-in` 循环遍历字典。由于每一项都有键和值，你可以用两种不同的方式来遍历。下面是通过字典的键来遍历的方法：
- en: '![Image](Image00149.jpg)'
  id: totrans-9450
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00149.jpg)'
- en: Here we use the dictionary’s keys property ➊ to loop through fruitBasket and
    print its contents. We start by writing the keyword for , followed by a constant
    name fruit for the dictionary key, the keyword in , the dictionary name, a period,
    and keys .
  id: totrans-9451
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们使用字典的 `keys` 属性 ➊ 来遍历 `fruitBasket` 并打印它的内容。我们首先写 `for` 关键字，接着是常量名 `fruit`（表示字典的键），然后是
    `in` 关键字，字典名称，接着是一个点号，最后是 `keys`。
- en: Inside the braces of our for-in loop, we have access to both the key, which
    we call fruit ➋ , and the value at that key when we force-unwrap its contents
    with fruitBasket[fruit]! ➌ . That value will be the fruit’s price.
  id: totrans-9452
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的 `for-in` 循环的大括号内部，我们可以访问到键（我们称之为 fruit ➋）以及通过 `fruitBasket[fruit]!` 强制解包该键对应的值
    ➌。这个值就是水果的价格。
- en: In this case, it’s safe to force-unwrap the value using an exclamation point
    because we know that the fruit key we’re using is definitely inside the dictionary.
  id: totrans-9453
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，使用感叹号强制解包值是安全的，因为我们知道所用的水果键肯定在字典中。
- en: Any code we put inside the for-in loop will run once for every key in our dictionary.
    So you should see the print statement display three times.
  id: totrans-9454
  prefs: []
  type: TYPE_NORMAL
  zh: 我们放在 `for-in` 循环中的任何代码都会为字典中的每一个键执行一次。所以你应该看到打印语句执行三次。
- en: 'We can also loop through the dictionary using its values property:'
  id: totrans-9455
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以通过字典的 `values` 属性来遍历字典：
- en: '![Image](Image00150.jpg)'
  id: totrans-9456
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00150.jpg)'
- en: We use the same style of for-in loop, but now we use a constant to refer to
    each value, which we call price , in the values property. When looping through
    values, we don’t have access to the keys from inside the loop.
  id: totrans-9457
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用相同的 for-in 循环样式，但现在我们使用常量来引用每个值，我们称之为 price，存在 values 属性中。在循环遍历 values 时，我们无法从循环内部访问键。
- en: Another difference to note is that price is not an optional because it’s accessed
    directly as a value in the fruitBasket dictionary. That means we don’t have to
    unwrap it. You should still see the print statement printed three times. [Figure
    6-6](text00016.html#ch06fig6) shows the output of both loops.
  id: totrans-9458
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个需要注意的区别是，price 不是可选的，因为它是直接作为值访问 fruitBasket 字典中的项。这意味着我们不需要解包它。你应该仍然能看到打印语句打印三次。[图
    6-6](text00016.html#ch06fig6) 显示了两个循环的输出结果。
- en: '![Image](Image00151.jpg)'
  id: totrans-9459
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Image00151.jpg)'
- en: '*Figure 6-6: Looping through the keys and values of a dictionary with a for-in
    loop*'
  id: totrans-9460
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 6-6：使用 for-in 循环遍历字典的键和值*'
- en: The order of your results might be slightly different from ours. That’s because
    the items in a dictionary aren’t in a numbered order like they are in an array!
    And because the order is not guaranteed, you might see a different order printed
    if you run the same code again.
  id: totrans-9461
  prefs: []
  type: TYPE_NORMAL
  zh: 你的结果顺序可能会与我们的略有不同。这是因为字典中的项目不像数组那样按编号顺序排列！由于顺序无法保证，如果你重新运行相同的代码，你可能会看到不同的输出顺序。
- en: '**WHAT YOU LEARNED**'
  id: totrans-9462
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**你学到了什么**'
- en: In this chapter, you learned how to store collections of items in an array and
    in a dictionary. To store items in an ordered list, you would use an array and
    look up each item by its index. If you wanted to store items by key instead, you
    would use a dictionary.
  id: totrans-9463
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你学习了如何将项目存储在数组和字典中。要将项目存储在有序列表中，你将使用数组，并通过索引查找每个项目。如果你想按键存储项目，你则需要使用字典。
- en: Knowing about arrays and dictionaries and how to use them is a powerful building
    block for almost any programming language. Next we will learn about functions,
    another very powerful tool. Functions are blocks of code that you create and name
    to perform a specific job. After you have written a function, you can use its
    name to call it from almost anywhere in your program.
  id: totrans-9464
  prefs: []
  type: TYPE_NORMAL
  zh: 了解数组和字典及其用法，是几乎所有编程语言中的一个强大的构建模块。接下来，我们将学习函数，另一个非常强大的工具。函数是你创建并命名的代码块，用来执行特定任务。在编写完函数后，你可以通过其名称在程序中的几乎任何地方调用它。
- en: '**DICTIONARIES ARE KEY!**'
  id: totrans-9465
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**字典是关键！**'
- en: A *dictionary* is also a collection of values, but instead of an ordered index,
    each value has its own *key* . Because there’s no index, the values are not stored
    in any particular order. To access values in a dictionary, you look them up by
    their key.
  id: totrans-9466
  prefs: []
  type: TYPE_NORMAL
  zh: '*字典* 也是一个值的集合，但与有序的索引不同，每个值都有自己的 *键* 。由于没有索引，值不会按照特定顺序存储。要访问字典中的值，你需要通过它们的键来查找。'
- en: A key must be unique. You can’t have the same key more than once in the same
    dictionary. If there were two identical keys and you asked the computer to give
    you the value for one of them, the computer wouldn’t know which one to choose!
  id: totrans-9467
  prefs: []
  type: TYPE_NORMAL
  zh: 键必须是唯一的。你不能在同一个字典中重复使用相同的键。如果有两个相同的键，并且你要求计算机给你其中一个的值，计算机将无法确定该选择哪个！
- en: Let’s take a look at how to make a dictionary and write keys that will help
    you find all the information you need.
  id: totrans-9468
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如何创建字典并写出能够帮助你找到所有信息的键。
- en: '![Image](Image00140.jpg)'
  id: totrans-9469
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Image00140.jpg)'
- en: '**INITIALIZING A DICTIONARY**'
  id: totrans-9470
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**初始化字典**'
- en: 'To create and initialize a dictionary, first write var and the name of your
    dictionary. Then write the keys and corresponding values inside a pair of square
    brackets, similar to an array. Let’s create a dictionary to store the names of
    a few US states. The key for each state will be its two-letter abbreviation:'
  id: totrans-9471
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建和初始化字典，首先写 var 和字典的名称。然后将键及其对应的值写在一对方括号内，类似于数组。让我们创建一个字典来存储一些美国州的名称。每个州的键将是它的两字母缩写：
- en: '![](Image00141.jpg)'
  id: totrans-9472
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00141.jpg)'
- en: As you can see, there’s a colon between each key and its value, and the key/value
    pairs are separated by commas.
  id: totrans-9473
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，每个键和值之间有一个冒号，键/值对之间用逗号分隔。
- en: Dictionaries are different from arrays in that they are *unordered* . Because
    of that, it’s likely that the order of the states that you see in your results
    pane ➋ is different from the order in which you entered your states ➊ . It might
    even be different than the order that’s printed in this book!
  id: totrans-9474
  prefs: []
  type: TYPE_NORMAL
  zh: 字典与数组的不同之处在于它们是 *无序的* 。因此，你在结果面板 ➋ 中看到的状态顺序很可能与输入状态时的顺序 ➊ 不同！它甚至可能与本书中打印的顺序不同！
- en: As with arrays, you can use var to make a mutable dictionary or use let to make
    an immutable dictionary.
  id: totrans-9475
  prefs: []
  type: TYPE_NORMAL
  zh: 与数组一样，你可以使用`var`来创建一个可变字典，或者使用`let`来创建一个不可变字典。
- en: 'In Swift, all of the keys of a dictionary must be the same type, and all of
    the values of a dictionary must also be the same type, but the key type doesn’t
    have to match the value type. For example, if you wanted to store a collection
    of fractions, you could use doubles for the keys and strings for the values:'
  id: totrans-9476
  prefs: []
  type: TYPE_NORMAL
  zh: 在Swift中，字典的所有键必须是相同的类型，字典的所有值也必须是相同的类型，但键的类型不一定需要与值的类型匹配。例如，如果你想存储一组分数，你可以使用双精度浮点数作为键，字符串作为值：
- en: '![](Image00142.jpg)'
  id: totrans-9477
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00142.jpg)'
- en: In this dictionary, all of the keys must be doubles, and all of the values must
    be strings. Again, you’ll see that the order of the numbers in the results pane
    can be quite different from the order in which you wrote the fractions in your
    dictionary. This is fine because you don’t need to know the order to access anything.
    You can find any item that you need by its key. Let’s see how!
  id: totrans-9478
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个字典中，所有的键必须是双精度浮点数，所有的值必须是字符串。同样，你会看到结果面板中的数字顺序可能与在字典中编写分数的顺序有所不同。这是可以接受的，因为你不需要知道顺序来访问任何项。你可以通过键找到任何你需要的项。让我们看看！
- en: '**ACCESSING VALUES IN A DICTIONARY**'
  id: totrans-9479
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**访问字典中的值**'
- en: 'Looking up a value in a dictionary is similar to how you access a value in
    an array except that you use a key inside the square brackets instead of an index,
    like this: usStates["TX"] .'
  id: totrans-9480
  prefs: []
  type: TYPE_NORMAL
  zh: 在字典中查找一个值的方式类似于通过数组访问值，不同之处在于你需要在方括号内使用一个键，而不是一个索引，像这样：usStates["TX"]。
- en: There is a big difference, however, in how Swift returns the values from a dictionary.
    When you access a value at an index of an array, you are simply given the value.
    When you access a value with a key in a dictionary, you are given an optional.
  id: totrans-9481
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，Swift从字典中返回值的方式有一个很大的不同。当你通过数组的索引访问值时，你会直接得到值。而当你通过字典中的键访问值时，你会得到一个可选值。
- en: In [Chapter 5](text00015.html#ch05) , you learned that optionals might contain
    a value or might be nil . The reason Swift returns optionals when you’re looking
    up items in a dictionary is that the key you used might not exist in the dictionary,
    in which case there’s no value to access. Trying to access a value that doesn’t
    exist would give you a big fat error! To avoid that problem, Swift returns optionals.
    That means you need to unwrap any value you get out of a dictionary before you
    can do anything with it.
  id: totrans-9482
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第5章](text00015.html#ch05)中，你学习了可选值可能包含一个值，也可能是nil。Swift返回可选值的原因是在字典中查找项时，你使用的键可能不存在于字典中，在这种情况下就没有值可以访问。尝试访问一个不存在的值会导致一个严重错误！为避免这个问题，Swift返回了可选值。这意味着你需要解包从字典中获取的任何值，才能对其进行操作。
- en: 'To unwrap an optional, first you check whether it exists using an if-let statement,
    just like we did in [Chapter 5](text00015.html#ch05) . The following code shows
    you how to get a value out of a dictionary:'
  id: totrans-9483
  prefs: []
  type: TYPE_NORMAL
  zh: 要解包一个可选值，首先使用`if-let`语句检查它是否存在，就像我们在[第5章](text00015.html#ch05)中做的那样。以下代码演示了如何从字典中获取值：
- en: '![Image](Image00143.jpg)'
  id: totrans-9484
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00143.jpg)'
- en: To retrieve "Texas" from the dictionary, we use if let to set a constant loneStarState
    to usStates["TX"] ➊ . Because we have this state in our dictionary, the line I
    have Texas in my dictionary. is printed. Next we try to access a state that is
    not in our dictionary by using the key usStates["FL"] ➋ . Thankfully, because
    we used an if-let statement, the program won’t crash when the computer can’t find
    this state. Instead, I don't have that state in my dictionary. is printed.
  id: totrans-9485
  prefs: []
  type: TYPE_NORMAL
  zh: 要从字典中获取“Texas”，我们使用`if let`将常量loneStarState设置为usStates["TX"] ➊。因为字典中包含这个州，所以下面会打印出“I
    have Texas in my dictionary.”。接下来，我们尝试使用不存在于字典中的键usStates["FL"] ➋来访问一个州。幸运的是，因为我们使用了`if-let`语句，当计算机找不到这个州时，程序不会崩溃。相反，会打印出“I
    don't have that state in my dictionary.”。
- en: '**ADDING ITEMS TO A DICTIONARY**'
  id: totrans-9486
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**向字典中添加项**'
- en: 'To add an item to a dictionary, first write the name of your dictionary and
    assign the new item to the key you want it to have in the dictionary. Let’s add
    "Minnesota" to our usStates dictionary:'
  id: totrans-9487
  prefs: []
  type: TYPE_NORMAL
  zh: 要向字典添加一项，首先写出字典的名称，并将新项分配给你希望它在字典中拥有的键。让我们将“Minnesota”添加到我们的usStates字典中：
- en: '![](Image00144.jpg)'
  id: totrans-9488
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00144.jpg)'
- en: 'Now when you look at usStates , you’ll see that it’s updated to ["MN": "Minnesota",
    "WA": "Washington", "MA": "Massachusetts", "TX": "Texas"] . Remember, because
    you don’t have to rely on indices, your new dictionary item might appear anywhere
    in the dictionary.'
  id: totrans-9489
  prefs: []
  type: TYPE_NORMAL
  zh: '现在，当你查看 usStates 时，你会看到它已经更新为 ["MN": "Minnesota", "WA": "Washington", "MA":
    "Massachusetts", "TX": "Texas"]。记住，因为你不需要依赖索引，你的新字典项可能出现在字典中的任何位置。'
- en: '**REMOVING ITEMS FROM A DICTIONARY**'
  id: totrans-9490
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**从字典中移除项**'
- en: Removing an item from a dictionary is quite simple; you do so by setting the
    value to nil . Because the values in dictionaries are returned as optionals, you
    don’t have to worry about nil causing any problems in your dictionary.
  id: totrans-9491
  prefs: []
  type: TYPE_NORMAL
  zh: 从字典中移除项非常简单；你只需将该值设置为 nil。由于字典中的值是作为可选项返回的，因此你不需要担心 nil 会在字典中引发任何问题。
- en: '![](Image00145.jpg)'
  id: totrans-9492
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00145.jpg)'
- en: 'You can see that after you remove the value at the key "MA" , usStates is updated
    to ["MN": "Minnesota", "WA": "Washington", "TX": "Texas"] . Remember that nil
    is special and means that there’s no value at all. That’s why you don’t see "MA":
    nil in our dictionary.'
  id: totrans-9493
  prefs: []
  type: TYPE_NORMAL
  zh: '你可以看到，在你移除键 "MA" 的值后，usStates 被更新为 ["MN": "Minnesota", "WA": "Washington",
    "TX": "Texas"]。记住，nil 是特殊的，表示完全没有值。因此，你不会在我们的字典中看到 "MA": nil。'
- en: '**REPLACING ITEMS IN A DICTIONARY**'
  id: totrans-9494
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**字典中替换项**'
- en: 'Replacing an item in a dictionary is also easy. It works the same was as replacing
    an item in an array. You just set the item that you want to replace to something
    else. Say you create a dictionary of fruit colors:'
  id: totrans-9495
  prefs: []
  type: TYPE_NORMAL
  zh: 在字典中替换项也很容易。它的工作方式与替换数组中的项相同。你只需将要替换的项设置为其他内容。比如你创建了一个水果颜色的字典：
- en: '![](Image00146.jpg)'
  id: totrans-9496
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00146.jpg)'
- en: At first we had the value "apple" for "red" , but then we decided that "raspberry"
    is a better fruit to use since sometimes apples are green or yellow. To replace
    "apple" with "raspberry" , we set colorFruits["red"] to its new value ➊ .
  id: totrans-9497
  prefs: []
  type: TYPE_NORMAL
  zh: 起初，我们为“red”设置了值“apple”，但后来我们决定“raspberry”是更好的水果，因为有时候苹果是绿色或黄色的。为了将“apple”替换为“raspberry”，我们将
    colorFruits["red"] 设置为它的新值 ➊。
- en: You may remember that this is the same way we entered a new value into a dictionary.
    If the key already exists in the dictionary, then the value for that key is replaced.
    If the key doesn’t already exist, then the new key/value pair will be added to
    the dictionary.
  id: totrans-9498
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能还记得，这与我们将新值添加到字典中的方式相同。如果键已经存在于字典中，那么该键的值会被替换。如果键不存在，则新的键/值对会被添加到字典中。
- en: '![Image](Image00147.jpg)'
  id: totrans-9499
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00147.jpg)'
- en: '**USING DICTIONARY PROPERTIES**'
  id: totrans-9500
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**使用字典属性**'
- en: 'Like an array, a dictionary also has an isEmpty property and a count property.
    For example, the following code shows how you can use the isEmpty property to
    check if a dictionary is empty, and if it isn’t empty, the count property checks
    how many items you have. Imagine you have a basket of fruit for sale. You can
    use these properties to help you keep track of everything:'
  id: totrans-9501
  prefs: []
  type: TYPE_NORMAL
  zh: 和数组一样，字典也有 isEmpty 属性和 count 属性。例如，以下代码演示了如何使用 isEmpty 属性检查字典是否为空，如果字典不为空，count
    属性将检查你有多少项。想象你有一个出售水果的篮子。你可以使用这些属性来帮助你跟踪所有的内容：
- en: '![Image](Image00148.jpg)'
  id: totrans-9502
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00148.jpg)'
- en: 'A dictionary also has two special properties: keys , which contains all of
    the dictionary’s keys, and values , which contains all of its values. We’ll use
    these two properties when we loop through the dictionary.'
  id: totrans-9503
  prefs: []
  type: TYPE_NORMAL
  zh: 字典还有两个特殊的属性：keys，包含字典的所有键，和 values，包含字典的所有值。我们将在遍历字典时使用这两个属性。
- en: Let’s write some code that loops through our fruit baskets and prints the price
    of each fruit.
  id: totrans-9504
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们写一些代码，遍历我们的水果篮并打印每个水果的价格。
- en: '**LOOPING OVER A DICTIONARY**'
  id: totrans-9505
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**遍历字典**'
- en: 'You can loop through a dictionary using a for-in loop. Because each item has
    a key and a value, you can do this in two different ways. This is how to loop
    through a dictionary using its keys:'
  id: totrans-9506
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用 for-in 循环遍历字典。由于每个项都有一个键和值，你可以通过两种不同的方式进行遍历。以下是使用键遍历字典的方式：
- en: '![Image](Image00149.jpg)'
  id: totrans-9507
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00149.jpg)'
- en: Here we use the dictionary’s keys property ➊ to loop through fruitBasket and
    print its contents. We start by writing the keyword for , followed by a constant
    name fruit for the dictionary key, the keyword in , the dictionary name, a period,
    and keys .
  id: totrans-9508
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们使用字典的 keys 属性 ➊ 来遍历 fruitBasket 并打印它的内容。我们从编写关键字 for 开始，后面跟着一个常量名称 fruit
    作为字典的键，再加上关键字 in、字典名称、一个句点和 keys。
- en: Inside the braces of our for-in loop, we have access to both the key, which
    we call fruit ➋ , and the value at that key when we force-unwrap its contents
    with fruitBasket[fruit]! ➌ . That value will be the fruit’s price.
  id: totrans-9509
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的for-in循环的大括号内，我们可以访问到键，也就是我们称之为fruit ➋ 的部分，以及当我们强制解包其内容时的该键对应的值，即fruitBasket[fruit]!
    ➌。该值将是水果的价格。
- en: In this case, it’s safe to force-unwrap the value using an exclamation point
    because we know that the fruit key we’re using is definitely inside the dictionary.
  id: totrans-9510
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，使用感叹号强制解包值是安全的，因为我们知道我们使用的fruit键肯定在字典中。
- en: Any code we put inside the for-in loop will run once for every key in our dictionary.
    So you should see the print statement display three times.
  id: totrans-9511
  prefs: []
  type: TYPE_NORMAL
  zh: 我们放入for-in循环中的任何代码都会为字典中的每个键运行一次。所以你应该看到打印语句显示三次。
- en: 'We can also loop through the dictionary using its values property:'
  id: totrans-9512
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以通过字典的values属性来遍历字典：
- en: '![Image](Image00150.jpg)'
  id: totrans-9513
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Image00150.jpg)'
- en: We use the same style of for-in loop, but now we use a constant to refer to
    each value, which we call price , in the values property. When looping through
    values, we don’t have access to the keys from inside the loop.
  id: totrans-9514
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用相同类型的for-in循环，但现在我们使用常量来引用每个值，这里我们称其为price，它位于values属性中。在遍历值时，我们无法从循环内部访问到键。
- en: Another difference to note is that price is not an optional because it’s accessed
    directly as a value in the fruitBasket dictionary. That means we don’t have to
    unwrap it. You should still see the print statement printed three times. [Figure
    6-6](text00016.html#ch06fig6) shows the output of both loops.
  id: totrans-9515
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个需要注意的区别是，price不是一个可选值，因为它是通过直接访问fruitBasket字典中的值来获得的。这意味着我们不需要解包它。你仍然应该看到打印语句被打印三次。[图6-6](text00016.html#ch06fig6)展示了两次循环的输出。
- en: '![Image](Image00151.jpg)'
  id: totrans-9516
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Image00151.jpg)'
- en: '*Figure 6-6: Looping through the keys and values of a dictionary with a for-in
    loop*'
  id: totrans-9517
  prefs: []
  type: TYPE_NORMAL
  zh: '*图6-6：使用for-in循环遍历字典的键和值*'
- en: The order of your results might be slightly different from ours. That’s because
    the items in a dictionary aren’t in a numbered order like they are in an array!
    And because the order is not guaranteed, you might see a different order printed
    if you run the same code again.
  id: totrans-9518
  prefs: []
  type: TYPE_NORMAL
  zh: 你的结果顺序可能与我们的略有不同。这是因为字典中的项不像数组那样按数字顺序排列！由于顺序无法保证，因此如果你再次运行相同的代码，你可能会看到不同的顺序。
- en: '**WHAT YOU LEARNED**'
  id: totrans-9519
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**你学到了什么**'
- en: In this chapter, you learned how to store collections of items in an array and
    in a dictionary. To store items in an ordered list, you would use an array and
    look up each item by its index. If you wanted to store items by key instead, you
    would use a dictionary.
  id: totrans-9520
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你学会了如何将项目集合存储在数组和字典中。要将项目存储在有序列表中，你将使用数组并通过索引查找每个项目。如果你想通过键来存储项目，则应使用字典。
- en: Knowing about arrays and dictionaries and how to use them is a powerful building
    block for almost any programming language. Next we will learn about functions,
    another very powerful tool. Functions are blocks of code that you create and name
    to perform a specific job. After you have written a function, you can use its
    name to call it from almost anywhere in your program.
  id: totrans-9521
  prefs: []
  type: TYPE_NORMAL
  zh: 了解数组和字典及其用法是几乎所有编程语言中一个强大的构建块。接下来，我们将学习函数，这是另一个非常强大的工具。函数是你创建并命名的代码块，用于执行特定的工作。编写完函数后，你可以通过它的名称在程序中的几乎任何地方调用它。
- en: A *dictionary* is also a collection of values, but instead of an ordered index,
    each value has its own *key* . Because there’s no index, the values are not stored
    in any particular order. To access values in a dictionary, you look them up by
    their key.
  id: totrans-9522
  prefs: []
  type: TYPE_NORMAL
  zh: '*字典*也是一个值的集合，但与有序索引不同，每个值都有自己的*键*。因为没有索引，所以值没有以特定的顺序存储。要访问字典中的值，你需要通过它们的键来查找。'
- en: A key must be unique. You can’t have the same key more than once in the same
    dictionary. If there were two identical keys and you asked the computer to give
    you the value for one of them, the computer wouldn’t know which one to choose!
  id: totrans-9523
  prefs: []
  type: TYPE_NORMAL
  zh: 键必须是唯一的。同一个字典中不能有相同的键。如果有两个相同的键，你要求计算机给出其中一个的值，计算机将无法知道该选择哪个！
- en: Let’s take a look at how to make a dictionary and write keys that will help
    you find all the information you need.
  id: totrans-9524
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如何创建一个字典，并编写键，帮助你找到所有需要的信息。
- en: '![Image](Image00140.jpg)'
  id: totrans-9525
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Image00140.jpg)'
- en: '**INITIALIZING A DICTIONARY**'
  id: totrans-9526
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**初始化字典**'
- en: 'To create and initialize a dictionary, first write var and the name of your
    dictionary. Then write the keys and corresponding values inside a pair of square
    brackets, similar to an array. Let’s create a dictionary to store the names of
    a few US states. The key for each state will be its two-letter abbreviation:'
  id: totrans-9527
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建和初始化一个字典，首先写var和字典的名称。然后，将键和值对放入一对方括号中，类似于数组。让我们创建一个字典来存储一些美国州的名称。每个州的键将是它的两个字母缩写：
- en: '![](Image00141.jpg)'
  id: totrans-9528
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00141.jpg)'
- en: As you can see, there’s a colon between each key and its value, and the key/value
    pairs are separated by commas.
  id: totrans-9529
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，每个键和它的值之间有一个冒号，并且键/值对之间由逗号分隔。
- en: Dictionaries are different from arrays in that they are *unordered* . Because
    of that, it’s likely that the order of the states that you see in your results
    pane ➋ is different from the order in which you entered your states ➊ . It might
    even be different than the order that’s printed in this book!
  id: totrans-9530
  prefs: []
  type: TYPE_NORMAL
  zh: 字典与数组的不同之处在于它们是*无序*的。由于这一点，你在结果面板中看到的州的顺序 ➋ 可能与输入州的顺序 ➊ 不同，甚至可能与书中打印的顺序不同！
- en: As with arrays, you can use var to make a mutable dictionary or use let to make
    an immutable dictionary.
  id: totrans-9531
  prefs: []
  type: TYPE_NORMAL
  zh: 与数组一样，你可以使用var来创建一个可变字典，或者使用let来创建一个不可变字典。
- en: 'In Swift, all of the keys of a dictionary must be the same type, and all of
    the values of a dictionary must also be the same type, but the key type doesn’t
    have to match the value type. For example, if you wanted to store a collection
    of fractions, you could use doubles for the keys and strings for the values:'
  id: totrans-9532
  prefs: []
  type: TYPE_NORMAL
  zh: 在Swift中，字典的所有键必须是相同的类型，字典的所有值也必须是相同的类型，但键的类型不需要与值的类型匹配。例如，如果你想存储一个分数的集合，你可以使用双精度浮点数作为键，使用字符串作为值：
- en: '![](Image00142.jpg)'
  id: totrans-9533
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00142.jpg)'
- en: In this dictionary, all of the keys must be doubles, and all of the values must
    be strings. Again, you’ll see that the order of the numbers in the results pane
    can be quite different from the order in which you wrote the fractions in your
    dictionary. This is fine because you don’t need to know the order to access anything.
    You can find any item that you need by its key. Let’s see how!
  id: totrans-9534
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个字典中，所有的键必须是双精度浮点数，而所有的值必须是字符串。同样，你会看到结果面板中的数字顺序可能与字典中写入分数的顺序大不相同。这是可以的，因为你不需要知道顺序来访问任何东西。你可以通过键找到你需要的任何项。让我们看看如何做到这一点！
- en: '**ACCESSING VALUES IN A DICTIONARY**'
  id: totrans-9535
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**访问字典中的值**'
- en: 'Looking up a value in a dictionary is similar to how you access a value in
    an array except that you use a key inside the square brackets instead of an index,
    like this: usStates["TX"] .'
  id: totrans-9536
  prefs: []
  type: TYPE_NORMAL
  zh: 在字典中查找一个值类似于你在数组中访问值的方式，只不过你在方括号内使用的是一个键，而不是索引，例如：usStates["TX"]。
- en: There is a big difference, however, in how Swift returns the values from a dictionary.
    When you access a value at an index of an array, you are simply given the value.
    When you access a value with a key in a dictionary, you are given an optional.
  id: totrans-9537
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，Swift在返回字典中的值时存在一个很大的区别。当你访问数组中某个索引的值时，你只会得到该值。当你通过键访问字典中的值时，你会得到一个可选值。
- en: In [Chapter 5](text00015.html#ch05) , you learned that optionals might contain
    a value or might be nil . The reason Swift returns optionals when you’re looking
    up items in a dictionary is that the key you used might not exist in the dictionary,
    in which case there’s no value to access. Trying to access a value that doesn’t
    exist would give you a big fat error! To avoid that problem, Swift returns optionals.
    That means you need to unwrap any value you get out of a dictionary before you
    can do anything with it.
  id: totrans-9538
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第5章](text00015.html#ch05)中，你学到了可选值可能包含一个值，也可能是nil。Swift返回可选值的原因是你在字典中查找的键可能不存在，在这种情况下，就没有值可以访问。尝试访问一个不存在的值会给你带来一个大错误！为了避免这个问题，Swift返回可选值。这意味着你需要解包从字典中获取的任何值，然后才能对其进行操作。
- en: 'To unwrap an optional, first you check whether it exists using an if-let statement,
    just like we did in [Chapter 5](text00015.html#ch05) . The following code shows
    you how to get a value out of a dictionary:'
  id: totrans-9539
  prefs: []
  type: TYPE_NORMAL
  zh: 要解包一个可选值，首先使用if-let语句检查它是否存在，就像我们在[第5章](text00015.html#ch05)中做的那样。以下代码展示了如何从字典中获取一个值：
- en: '![Image](Image00143.jpg)'
  id: totrans-9540
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00143.jpg)'
- en: To retrieve "Texas" from the dictionary, we use if let to set a constant loneStarState
    to usStates["TX"] ➊ . Because we have this state in our dictionary, the line I
    have Texas in my dictionary. is printed. Next we try to access a state that is
    not in our dictionary by using the key usStates["FL"] ➋ . Thankfully, because
    we used an if-let statement, the program won’t crash when the computer can’t find
    this state. Instead, I don't have that state in my dictionary. is printed.
  id: totrans-9541
  prefs: []
  type: TYPE_NORMAL
  zh: 要从字典中获取"Texas"的值，我们使用`if let`将常量loneStarState设置为usStates["TX"] ➊。因为字典中包含这个州，所以会打印出"I
    have Texas in my dictionary."。接下来，我们尝试访问一个不在字典中的州，使用键usStates["FL"] ➋。幸运的是，由于我们使用了`if-let`语句，当计算机找不到这个州时，程序不会崩溃。相反，打印出"I
    don't have that state in my dictionary."。
- en: '**ADDING ITEMS TO A DICTIONARY**'
  id: totrans-9542
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**向字典中添加项目**'
- en: 'To add an item to a dictionary, first write the name of your dictionary and
    assign the new item to the key you want it to have in the dictionary. Let’s add
    "Minnesota" to our usStates dictionary:'
  id: totrans-9543
  prefs: []
  type: TYPE_NORMAL
  zh: 要向字典中添加项目，首先写下字典的名称，并将新项目分配给你希望它在字典中拥有的键。我们来给我们的usStates字典添加"明尼苏达州"：
- en: '![](Image00144.jpg)'
  id: totrans-9544
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00144.jpg)'
- en: 'Now when you look at usStates , you’ll see that it’s updated to ["MN": "Minnesota",
    "WA": "Washington", "MA": "Massachusetts", "TX": "Texas"] . Remember, because
    you don’t have to rely on indices, your new dictionary item might appear anywhere
    in the dictionary.'
  id: totrans-9545
  prefs: []
  type: TYPE_NORMAL
  zh: '现在，当你查看usStates时，你会看到它被更新为["MN": "Minnesota", "WA": "Washington", "MA": "Massachusetts",
    "TX": "Texas"]。记住，由于你不需要依赖索引，新的字典项目可能会出现在字典中的任何位置。'
- en: '**REMOVING ITEMS FROM A DICTIONARY**'
  id: totrans-9546
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**从字典中移除项目**'
- en: Removing an item from a dictionary is quite simple; you do so by setting the
    value to nil . Because the values in dictionaries are returned as optionals, you
    don’t have to worry about nil causing any problems in your dictionary.
  id: totrans-9547
  prefs: []
  type: TYPE_NORMAL
  zh: 从字典中移除项目非常简单；你只需将该值设置为`nil`。因为字典中的值是作为可选项返回的，所以你不必担心`nil`会在字典中造成任何问题。
- en: '![](Image00145.jpg)'
  id: totrans-9548
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00145.jpg)'
- en: 'You can see that after you remove the value at the key "MA" , usStates is updated
    to ["MN": "Minnesota", "WA": "Washington", "TX": "Texas"] . Remember that nil
    is special and means that there’s no value at all. That’s why you don’t see "MA":
    nil in our dictionary.'
  id: totrans-9549
  prefs: []
  type: TYPE_NORMAL
  zh: '你可以看到，在移除"MA"键的值后，usStates更新为["MN": "Minnesota", "WA": "Washington", "TX":
    "Texas"]。记住，`nil`是特殊的，表示没有值。这就是为什么你在字典中看不到"MA": nil。'
- en: '**REPLACING ITEMS IN A DICTIONARY**'
  id: totrans-9550
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**替换字典中的项目**'
- en: 'Replacing an item in a dictionary is also easy. It works the same was as replacing
    an item in an array. You just set the item that you want to replace to something
    else. Say you create a dictionary of fruit colors:'
  id: totrans-9551
  prefs: []
  type: TYPE_NORMAL
  zh: 替换字典中的项目也很简单。它的操作方式和替换数组中的项目一样。你只需要将你想替换的项目设置为其他值。例如，你创建了一个水果颜色的字典：
- en: '![](Image00146.jpg)'
  id: totrans-9552
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00146.jpg)'
- en: At first we had the value "apple" for "red" , but then we decided that "raspberry"
    is a better fruit to use since sometimes apples are green or yellow. To replace
    "apple" with "raspberry" , we set colorFruits["red"] to its new value ➊ .
  id: totrans-9553
  prefs: []
  type: TYPE_NORMAL
  zh: 起初我们为"red"设置了"apple"作为值，但后来我们决定使用"raspberry"（覆盆子）作为更合适的水果，因为有时苹果是绿色或黄色的。为了将"apple"替换为"raspberry"，我们将colorFruits["red"]的值设置为新的值
    ➊。
- en: You may remember that this is the same way we entered a new value into a dictionary.
    If the key already exists in the dictionary, then the value for that key is replaced.
    If the key doesn’t already exist, then the new key/value pair will be added to
    the dictionary.
  id: totrans-9554
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能还记得，这和我们往字典中输入新值的方式是一样的。如果键已经存在于字典中，那么该键的值会被替换。如果键不存在，则新的键值对会被添加到字典中。
- en: '![Image](Image00147.jpg)'
  id: totrans-9555
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Image00147.jpg)'
- en: '**USING DICTIONARY PROPERTIES**'
  id: totrans-9556
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**使用字典属性**'
- en: 'Like an array, a dictionary also has an isEmpty property and a count property.
    For example, the following code shows how you can use the isEmpty property to
    check if a dictionary is empty, and if it isn’t empty, the count property checks
    how many items you have. Imagine you have a basket of fruit for sale. You can
    use these properties to help you keep track of everything:'
  id: totrans-9557
  prefs: []
  type: TYPE_NORMAL
  zh: 像数组一样，字典也有`isEmpty`属性和`count`属性。例如，以下代码展示了如何使用`isEmpty`属性来检查字典是否为空，如果字典不为空，`count`属性可以检查字典中有多少项。假设你有一个水果篮在出售。你可以使用这些属性来帮助你跟踪一切：
- en: '![Image](Image00148.jpg)'
  id: totrans-9558
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Image00148.jpg)'
- en: 'A dictionary also has two special properties: keys , which contains all of
    the dictionary’s keys, and values , which contains all of its values. We’ll use
    these two properties when we loop through the dictionary.'
  id: totrans-9559
  prefs: []
  type: TYPE_NORMAL
  zh: 字典还有两个特殊属性：keys，包含字典的所有键；values，包含字典的所有值。在我们遍历字典时，将会使用这两个属性。
- en: Let’s write some code that loops through our fruit baskets and prints the price
    of each fruit.
  id: totrans-9560
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们写一些代码，遍历我们的水果篮子并打印每种水果的价格。
- en: '**LOOPING OVER A DICTIONARY**'
  id: totrans-9561
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**遍历字典**'
- en: 'You can loop through a dictionary using a for-in loop. Because each item has
    a key and a value, you can do this in two different ways. This is how to loop
    through a dictionary using its keys:'
  id: totrans-9562
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用for-in循环遍历字典。由于每个项都有一个键和值，你可以用两种不同的方式来遍历字典。这是通过键遍历字典的方法：
- en: '![Image](Image00149.jpg)'
  id: totrans-9563
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00149.jpg)'
- en: Here we use the dictionary’s keys property ➊ to loop through fruitBasket and
    print its contents. We start by writing the keyword for , followed by a constant
    name fruit for the dictionary key, the keyword in , the dictionary name, a period,
    and keys .
  id: totrans-9564
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们使用字典的keys属性 ➊ 来遍历fruitBasket并打印其内容。我们首先写下关键字for，然后是常量名称fruit代表字典的键，接着是关键字in，字典的名称，一个句点，最后是keys。
- en: Inside the braces of our for-in loop, we have access to both the key, which
    we call fruit ➋ , and the value at that key when we force-unwrap its contents
    with fruitBasket[fruit]! ➌ . That value will be the fruit’s price.
  id: totrans-9565
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们for-in循环的大括号内，我们可以访问到键（我们称之为fruit ➋）以及通过`fruitBasket[fruit]!`强制解包该键的值 ➌。这个值将是水果的价格。
- en: In this case, it’s safe to force-unwrap the value using an exclamation point
    because we know that the fruit key we’re using is definitely inside the dictionary.
  id: totrans-9566
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，强制解包值是安全的，因为我们知道我们使用的水果键肯定存在于字典中。
- en: Any code we put inside the for-in loop will run once for every key in our dictionary.
    So you should see the print statement display three times.
  id: totrans-9567
  prefs: []
  type: TYPE_NORMAL
  zh: 我们放入for-in循环中的任何代码会对字典中的每个键执行一次。因此，你应该能看到打印语句显示三次。
- en: 'We can also loop through the dictionary using its values property:'
  id: totrans-9568
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以使用字典的values属性来遍历字典：
- en: '![Image](Image00150.jpg)'
  id: totrans-9569
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00150.jpg)'
- en: We use the same style of for-in loop, but now we use a constant to refer to
    each value, which we call price , in the values property. When looping through
    values, we don’t have access to the keys from inside the loop.
  id: totrans-9570
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用相同风格的for-in循环，但现在我们使用一个常量来表示每个值，我们称之为price，在values属性中。当循环遍历值时，我们无法在循环内访问到键。
- en: Another difference to note is that price is not an optional because it’s accessed
    directly as a value in the fruitBasket dictionary. That means we don’t have to
    unwrap it. You should still see the print statement printed three times. [Figure
    6-6](text00016.html#ch06fig6) shows the output of both loops.
  id: totrans-9571
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个需要注意的区别是，价格不是一个可选值，因为它是直接作为fruitBasket字典中的值访问的。这意味着我们不需要解包它。你应该仍然能看到打印语句打印三次。[图
    6-6](text00016.html#ch06fig6)显示了两个循环的输出。
- en: '![Image](Image00151.jpg)'
  id: totrans-9572
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00151.jpg)'
- en: '*Figure 6-6: Looping through the keys and values of a dictionary with a for-in
    loop*'
  id: totrans-9573
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 6-6：使用for-in循环遍历字典的键和值*'
- en: The order of your results might be slightly different from ours. That’s because
    the items in a dictionary aren’t in a numbered order like they are in an array!
    And because the order is not guaranteed, you might see a different order printed
    if you run the same code again.
  id: totrans-9574
  prefs: []
  type: TYPE_NORMAL
  zh: 你的结果顺序可能与我们的略有不同。这是因为字典中的项不像数组那样按编号顺序排列！并且由于顺序无法保证，如果你再次运行相同的代码，可能会看到不同的输出顺序。
- en: '**WHAT YOU LEARNED**'
  id: totrans-9575
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**你学到了什么**'
- en: In this chapter, you learned how to store collections of items in an array and
    in a dictionary. To store items in an ordered list, you would use an array and
    look up each item by its index. If you wanted to store items by key instead, you
    would use a dictionary.
  id: totrans-9576
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你学会了如何将项存储在数组和字典中。要将项存储在有序列表中，你可以使用数组，并通过索引查找每个项。如果你想按键存储项，那么你应该使用字典。
- en: Knowing about arrays and dictionaries and how to use them is a powerful building
    block for almost any programming language. Next we will learn about functions,
    another very powerful tool. Functions are blocks of code that you create and name
    to perform a specific job. After you have written a function, you can use its
    name to call it from almost anywhere in your program.
  id: totrans-9577
  prefs: []
  type: TYPE_NORMAL
  zh: 了解数组和字典以及如何使用它们，是几乎所有编程语言中的强大构建块。接下来，我们将学习函数，这是另一个非常强大的工具。函数是你创建并命名的代码块，用来执行特定的任务。在你编写了一个函数后，你可以使用其名称在程序的几乎任何地方调用它。
- en: A key must be unique. You can’t have the same key more than once in the same
    dictionary. If there were two identical keys and you asked the computer to give
    you the value for one of them, the computer wouldn’t know which one to choose!
  id: totrans-9578
  prefs: []
  type: TYPE_NORMAL
  zh: 键必须是唯一的。你不能在同一个字典中重复使用相同的键。如果有两个相同的键，并且你要求计算机返回其中一个的值，计算机就不知道选择哪个！
- en: Let’s take a look at how to make a dictionary and write keys that will help
    you find all the information you need.
  id: totrans-9579
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如何创建一个字典并写下键，以帮助你找到所有你需要的信息。
- en: '![Image](Image00140.jpg)'
  id: totrans-9580
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00140.jpg)'
- en: '**INITIALIZING A DICTIONARY**'
  id: totrans-9581
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**初始化字典**'
- en: 'To create and initialize a dictionary, first write var and the name of your
    dictionary. Then write the keys and corresponding values inside a pair of square
    brackets, similar to an array. Let’s create a dictionary to store the names of
    a few US states. The key for each state will be its two-letter abbreviation:'
  id: totrans-9582
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建和初始化一个字典，首先写上 var 和字典的名称。然后将键和值写在一对方括号中，类似于数组。让我们创建一个字典来存储几个美国州的名字。每个州的键将是它的两字母缩写：
- en: '![](Image00141.jpg)'
  id: totrans-9583
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00141.jpg)'
- en: As you can see, there’s a colon between each key and its value, and the key/value
    pairs are separated by commas.
  id: totrans-9584
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，每个键和值之间都有一个冒号，键/值对之间由逗号分隔。
- en: Dictionaries are different from arrays in that they are *unordered* . Because
    of that, it’s likely that the order of the states that you see in your results
    pane ➋ is different from the order in which you entered your states ➊ . It might
    even be different than the order that’s printed in this book!
  id: totrans-9585
  prefs: []
  type: TYPE_NORMAL
  zh: 字典与数组的不同之处在于它们是*无序的*。因此，你在结果窗格 ➋ 中看到的州的顺序可能与你输入州的顺序 ➊ 不同。它甚至可能与本书中打印的顺序不同！
- en: As with arrays, you can use var to make a mutable dictionary or use let to make
    an immutable dictionary.
  id: totrans-9586
  prefs: []
  type: TYPE_NORMAL
  zh: 与数组类似，你可以使用 var 来创建一个可变字典，或者使用 let 来创建一个不可变字典。
- en: 'In Swift, all of the keys of a dictionary must be the same type, and all of
    the values of a dictionary must also be the same type, but the key type doesn’t
    have to match the value type. For example, if you wanted to store a collection
    of fractions, you could use doubles for the keys and strings for the values:'
  id: totrans-9587
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Swift 中，字典的所有键必须是相同类型，字典的所有值也必须是相同类型，但键的类型不需要与值的类型匹配。例如，如果你想存储一组分数，你可以使用双精度数（doubles）作为键，字符串作为值：
- en: '![](Image00142.jpg)'
  id: totrans-9588
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00142.jpg)'
- en: In this dictionary, all of the keys must be doubles, and all of the values must
    be strings. Again, you’ll see that the order of the numbers in the results pane
    can be quite different from the order in which you wrote the fractions in your
    dictionary. This is fine because you don’t need to know the order to access anything.
    You can find any item that you need by its key. Let’s see how!
  id: totrans-9589
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个字典中，所有的键必须是双精度数（doubles），所有的值必须是字符串。再次提醒，你会看到结果窗格中的数字顺序可能与字典中输入分数的顺序有所不同。这是正常的，因为你不需要知道顺序就能访问任何内容。你可以通过键来找到你需要的任何项目。让我们来看看如何做！
- en: '**ACCESSING VALUES IN A DICTIONARY**'
  id: totrans-9590
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**访问字典中的值**'
- en: 'Looking up a value in a dictionary is similar to how you access a value in
    an array except that you use a key inside the square brackets instead of an index,
    like this: usStates["TX"] .'
  id: totrans-9591
  prefs: []
  type: TYPE_NORMAL
  zh: 查找字典中的值与访问数组中的值类似，不同之处在于你使用的是键而不是索引，像这样：usStates["TX"]。
- en: There is a big difference, however, in how Swift returns the values from a dictionary.
    When you access a value at an index of an array, you are simply given the value.
    When you access a value with a key in a dictionary, you are given an optional.
  id: totrans-9592
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，Swift 返回字典值的方式与数组不同。当你访问数组中某个索引的值时，你只会得到这个值。当你在字典中用键访问值时，你得到的是一个可选值（optional）。
- en: In [Chapter 5](text00015.html#ch05) , you learned that optionals might contain
    a value or might be nil . The reason Swift returns optionals when you’re looking
    up items in a dictionary is that the key you used might not exist in the dictionary,
    in which case there’s no value to access. Trying to access a value that doesn’t
    exist would give you a big fat error! To avoid that problem, Swift returns optionals.
    That means you need to unwrap any value you get out of a dictionary before you
    can do anything with it.
  id: totrans-9593
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第 5 章](text00015.html#ch05)，你学过可选值可能包含一个值，也可能是 nil。Swift 在你查找字典中的项目时返回可选值的原因是，你使用的键可能在字典中不存在，在这种情况下，就没有值可以访问。尝试访问不存在的值会导致一个严重错误！为了避免这个问题，Swift
    返回了可选值。这意味着，在你使用字典中返回的任何值之前，你需要先解包（unwrap）它。
- en: 'To unwrap an optional, first you check whether it exists using an if-let statement,
    just like we did in [Chapter 5](text00015.html#ch05) . The following code shows
    you how to get a value out of a dictionary:'
  id: totrans-9594
  prefs: []
  type: TYPE_NORMAL
  zh: 要展开一个可选值，首先你需要检查它是否存在，就像我们在[第五章](text00015.html#ch05)中做的那样。以下代码展示了如何从字典中获取一个值：
- en: '![Image](Image00143.jpg)'
  id: totrans-9595
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00143.jpg)'
- en: To retrieve "Texas" from the dictionary, we use if let to set a constant loneStarState
    to usStates["TX"] ➊ . Because we have this state in our dictionary, the line I
    have Texas in my dictionary. is printed. Next we try to access a state that is
    not in our dictionary by using the key usStates["FL"] ➋ . Thankfully, because
    we used an if-let statement, the program won’t crash when the computer can’t find
    this state. Instead, I don't have that state in my dictionary. is printed.
  id: totrans-9596
  prefs: []
  type: TYPE_NORMAL
  zh: 要从字典中检索“Texas”，我们使用if let将常量loneStarState设置为usStates["TX"]➊。由于我们在字典中有这个州，输出行“I
    have Texas in my dictionary.”会被打印。接下来，我们尝试使用不存在于字典中的键usStates["FL"]➋来访问一个州。幸运的是，因为我们使用了if-let语句，当计算机找不到这个州时，程序不会崩溃。相反，输出“我字典中没有这个州。”会被打印。
- en: '**ADDING ITEMS TO A DICTIONARY**'
  id: totrans-9597
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**向字典添加项目**'
- en: 'To add an item to a dictionary, first write the name of your dictionary and
    assign the new item to the key you want it to have in the dictionary. Let’s add
    "Minnesota" to our usStates dictionary:'
  id: totrans-9598
  prefs: []
  type: TYPE_NORMAL
  zh: 要向字典中添加一个项目，首先写下字典的名称，并将新项目赋给你希望它在字典中具有的键。让我们向我们的usStates字典中添加“Minnesota”：
- en: '![](Image00144.jpg)'
  id: totrans-9599
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00144.jpg)'
- en: 'Now when you look at usStates , you’ll see that it’s updated to ["MN": "Minnesota",
    "WA": "Washington", "MA": "Massachusetts", "TX": "Texas"] . Remember, because
    you don’t have to rely on indices, your new dictionary item might appear anywhere
    in the dictionary.'
  id: totrans-9600
  prefs: []
  type: TYPE_NORMAL
  zh: '现在，当你查看usStates时，你会看到它已经更新为["MN": "Minnesota", "WA": "Washington", "MA": "Massachusetts",
    "TX": "Texas"]。记住，由于你不需要依赖索引，你的新增字典项目可能出现在字典中的任何位置。'
- en: '**REMOVING ITEMS FROM A DICTIONARY**'
  id: totrans-9601
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**从字典中移除项目**'
- en: Removing an item from a dictionary is quite simple; you do so by setting the
    value to nil . Because the values in dictionaries are returned as optionals, you
    don’t have to worry about nil causing any problems in your dictionary.
  id: totrans-9602
  prefs: []
  type: TYPE_NORMAL
  zh: 从字典中移除一个项目非常简单；你只需要将该值设置为nil。由于字典中的值是可选的，所以你不必担心nil会导致字典中的任何问题。
- en: '![](Image00145.jpg)'
  id: totrans-9603
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00145.jpg)'
- en: 'You can see that after you remove the value at the key "MA" , usStates is updated
    to ["MN": "Minnesota", "WA": "Washington", "TX": "Texas"] . Remember that nil
    is special and means that there’s no value at all. That’s why you don’t see "MA":
    nil in our dictionary.'
  id: totrans-9604
  prefs: []
  type: TYPE_NORMAL
  zh: '你可以看到，在你移除“MA”键的值后，usStates被更新为["MN": "Minnesota", "WA": "Washington", "TX":
    "Texas"]。记住，nil是特殊的，意味着根本没有值。这就是为什么你在字典中看不到"MA": nil的原因。'
- en: '**REPLACING ITEMS IN A DICTIONARY**'
  id: totrans-9605
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**替换字典中的项目**'
- en: 'Replacing an item in a dictionary is also easy. It works the same was as replacing
    an item in an array. You just set the item that you want to replace to something
    else. Say you create a dictionary of fruit colors:'
  id: totrans-9606
  prefs: []
  type: TYPE_NORMAL
  zh: 替换字典中的项目也很容易。它与替换数组中的项目方式相同。你只需要将你想要替换的项目设置为其他值。假设你创建了一个水果颜色的字典：
- en: '![](Image00146.jpg)'
  id: totrans-9607
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00146.jpg)'
- en: At first we had the value "apple" for "red" , but then we decided that "raspberry"
    is a better fruit to use since sometimes apples are green or yellow. To replace
    "apple" with "raspberry" , we set colorFruits["red"] to its new value ➊ .
  id: totrans-9608
  prefs: []
  type: TYPE_NORMAL
  zh: 起初我们给“red”赋值为“apple”，但后来我们决定“raspberry”是更合适的水果，因为有时候苹果是绿色或黄色的。要用“raspberry”替换“apple”，我们将colorFruits["red"]设置为它的新值➊。
- en: You may remember that this is the same way we entered a new value into a dictionary.
    If the key already exists in the dictionary, then the value for that key is replaced.
    If the key doesn’t already exist, then the new key/value pair will be added to
    the dictionary.
  id: totrans-9609
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能还记得，这就是我们向字典中输入新值的方式。如果键已经存在于字典中，那么该键的值将被替换。如果键不存在，那么新的键值对将被添加到字典中。
- en: '![Image](Image00147.jpg)'
  id: totrans-9610
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00147.jpg)'
- en: '**USING DICTIONARY PROPERTIES**'
  id: totrans-9611
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**使用字典属性**'
- en: 'Like an array, a dictionary also has an isEmpty property and a count property.
    For example, the following code shows how you can use the isEmpty property to
    check if a dictionary is empty, and if it isn’t empty, the count property checks
    how many items you have. Imagine you have a basket of fruit for sale. You can
    use these properties to help you keep track of everything:'
  id: totrans-9612
  prefs: []
  type: TYPE_NORMAL
  zh: 像数组一样，字典也有isEmpty属性和count属性。例如，以下代码展示了如何使用isEmpty属性来检查字典是否为空，如果字典不为空，则count属性检查字典中有多少项。假设你有一个待售的水果篮，你可以使用这些属性来帮助你跟踪所有内容：
- en: '![Image](Image00148.jpg)'
  id: totrans-9613
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00148.jpg)'
- en: 'A dictionary also has two special properties: keys , which contains all of
    the dictionary’s keys, and values , which contains all of its values. We’ll use
    these two properties when we loop through the dictionary.'
  id: totrans-9614
  prefs: []
  type: TYPE_NORMAL
  zh: 字典还具有两个特殊属性：keys，包含字典中的所有键；以及 values，包含字典中的所有值。在遍历字典时，我们将使用这两个属性。
- en: Let’s write some code that loops through our fruit baskets and prints the price
    of each fruit.
  id: totrans-9615
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们编写一些代码，遍历水果篮并打印每种水果的价格。
- en: '**LOOPING OVER A DICTIONARY**'
  id: totrans-9616
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**遍历字典**'
- en: 'You can loop through a dictionary using a for-in loop. Because each item has
    a key and a value, you can do this in two different ways. This is how to loop
    through a dictionary using its keys:'
  id: totrans-9617
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用 `for-in` 循环遍历字典。由于每个项都有一个键和值，因此你可以通过两种不同的方式来遍历字典。这是使用键遍历字典的方式：
- en: '![Image](Image00149.jpg)'
  id: totrans-9618
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00149.jpg)'
- en: Here we use the dictionary’s keys property ➊ to loop through fruitBasket and
    print its contents. We start by writing the keyword for , followed by a constant
    name fruit for the dictionary key, the keyword in , the dictionary name, a period,
    and keys .
  id: totrans-9619
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们使用字典的 keys 属性 ➊ 来遍历 `fruitBasket` 并打印其内容。我们首先写下关键字 `for`，然后是常量名 `fruit`（代表字典的键），接着是关键字
    `in`，然后是字典名、一个点和 `keys`。
- en: Inside the braces of our for-in loop, we have access to both the key, which
    we call fruit ➋ , and the value at that key when we force-unwrap its contents
    with fruitBasket[fruit]! ➌ . That value will be the fruit’s price.
  id: totrans-9620
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们 `for-in` 循环的大括号内部，我们可以访问到键（我们称之为 fruit ➋）和该键对应的值，当我们通过 `fruitBasket[fruit]!`
    强制解包其内容时 ➌。这个值将是水果的价格。
- en: In this case, it’s safe to force-unwrap the value using an exclamation point
    because we know that the fruit key we’re using is definitely inside the dictionary.
  id: totrans-9621
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，使用感叹号强制解包值是安全的，因为我们知道我们使用的水果键一定存在于字典中。
- en: Any code we put inside the for-in loop will run once for every key in our dictionary.
    So you should see the print statement display three times.
  id: totrans-9622
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在 `for-in` 循环中放入的任何代码都会针对字典中的每个键执行一次。所以你应该看到打印语句显示三次。
- en: 'We can also loop through the dictionary using its values property:'
  id: totrans-9623
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以使用字典的 `values` 属性来遍历字典：
- en: '![Image](Image00150.jpg)'
  id: totrans-9624
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00150.jpg)'
- en: We use the same style of for-in loop, but now we use a constant to refer to
    each value, which we call price , in the values property. When looping through
    values, we don’t have access to the keys from inside the loop.
  id: totrans-9625
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用相同的 `for-in` 循环风格，但现在我们使用常量来引用 `values` 属性中的每个值，称之为 `price`。在遍历值时，我们无法从循环内部访问键。
- en: Another difference to note is that price is not an optional because it’s accessed
    directly as a value in the fruitBasket dictionary. That means we don’t have to
    unwrap it. You should still see the print statement printed three times. [Figure
    6-6](text00016.html#ch06fig6) shows the output of both loops.
  id: totrans-9626
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个需要注意的区别是，`price` 不是可选项，因为它是作为 `fruitBasket` 字典中的值直接访问的。这意味着我们不需要解包它。你仍然应该看到打印语句打印三次。[图6-6](text00016.html#ch06fig6)
    显示了两种循环的输出。
- en: '![Image](Image00151.jpg)'
  id: totrans-9627
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00151.jpg)'
- en: '*Figure 6-6: Looping through the keys and values of a dictionary with a for-in
    loop*'
  id: totrans-9628
  prefs: []
  type: TYPE_NORMAL
  zh: '*图6-6：使用 `for-in` 循环遍历字典的键和值*'
- en: The order of your results might be slightly different from ours. That’s because
    the items in a dictionary aren’t in a numbered order like they are in an array!
    And because the order is not guaranteed, you might see a different order printed
    if you run the same code again.
  id: totrans-9629
  prefs: []
  type: TYPE_NORMAL
  zh: 你的结果顺序可能会与我们的略有不同。这是因为字典中的项不像数组那样按顺序排列！由于顺序并不保证，因此如果你重新运行相同的代码，可能会看到不同的顺序。
- en: '**WHAT YOU LEARNED**'
  id: totrans-9630
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**你学到了什么**'
- en: In this chapter, you learned how to store collections of items in an array and
    in a dictionary. To store items in an ordered list, you would use an array and
    look up each item by its index. If you wanted to store items by key instead, you
    would use a dictionary.
  id: totrans-9631
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你学习了如何将项存储在数组和字典中。为了将项存储在有序列表中，你会使用数组，并通过索引查找每个项。如果你想按键存储项，则会使用字典。
- en: Knowing about arrays and dictionaries and how to use them is a powerful building
    block for almost any programming language. Next we will learn about functions,
    another very powerful tool. Functions are blocks of code that you create and name
    to perform a specific job. After you have written a function, you can use its
    name to call it from almost anywhere in your program.
  id: totrans-9632
  prefs: []
  type: TYPE_NORMAL
  zh: 了解数组和字典以及如何使用它们是几乎所有编程语言中的一个强大构建块。接下来，我们将学习函数，另一个非常强大的工具。函数是你创建并命名的代码块，用于执行特定的任务。写完一个函数后，你可以通过它的名称从程序中的几乎任何地方调用它。
- en: Let’s take a look at how to make a dictionary and write keys that will help
    you find all the information you need.
  id: totrans-9633
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看如何创建一个字典并写出能够帮助你找到所需信息的键。
- en: '![Image](Image00140.jpg)'
  id: totrans-9634
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00140.jpg)'
- en: '**INITIALIZING A DICTIONARY**'
  id: totrans-9635
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**初始化字典**'
- en: 'To create and initialize a dictionary, first write var and the name of your
    dictionary. Then write the keys and corresponding values inside a pair of square
    brackets, similar to an array. Let’s create a dictionary to store the names of
    a few US states. The key for each state will be its two-letter abbreviation:'
  id: totrans-9636
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建和初始化一个字典，首先写下 var 和字典的名称。然后，在一对方括号内写下键及其对应的值，类似于数组。让我们创建一个字典来存储一些美国州的名称。每个州的键将是其两字母的缩写：
- en: '![](Image00141.jpg)'
  id: totrans-9637
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00141.jpg)'
- en: As you can see, there’s a colon between each key and its value, and the key/value
    pairs are separated by commas.
  id: totrans-9638
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，每个键与其值之间有一个冒号，键值对之间用逗号分隔。
- en: Dictionaries are different from arrays in that they are *unordered* . Because
    of that, it’s likely that the order of the states that you see in your results
    pane ➋ is different from the order in which you entered your states ➊ . It might
    even be different than the order that’s printed in this book!
  id: totrans-9639
  prefs: []
  type: TYPE_NORMAL
  zh: 字典与数组的不同之处在于它们是*无序的*。因此，你在结果面板中看到的状态顺序➋很可能与你输入状态时的顺序➊不同。甚至可能与书中打印的顺序不同！
- en: As with arrays, you can use var to make a mutable dictionary or use let to make
    an immutable dictionary.
  id: totrans-9640
  prefs: []
  type: TYPE_NORMAL
  zh: 与数组一样，你可以使用 var 来创建一个可变字典，或者使用 let 来创建一个不可变字典。
- en: 'In Swift, all of the keys of a dictionary must be the same type, and all of
    the values of a dictionary must also be the same type, but the key type doesn’t
    have to match the value type. For example, if you wanted to store a collection
    of fractions, you could use doubles for the keys and strings for the values:'
  id: totrans-9641
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Swift 中，字典的所有键必须是相同类型，字典的所有值也必须是相同类型，但键类型不必与值类型匹配。例如，如果你想存储一组分数，你可以使用双精度浮点数作为键，字符串作为值：
- en: '![](Image00142.jpg)'
  id: totrans-9642
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00142.jpg)'
- en: In this dictionary, all of the keys must be doubles, and all of the values must
    be strings. Again, you’ll see that the order of the numbers in the results pane
    can be quite different from the order in which you wrote the fractions in your
    dictionary. This is fine because you don’t need to know the order to access anything.
    You can find any item that you need by its key. Let’s see how!
  id: totrans-9643
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个字典中，所有的键必须是双精度浮点数，所有的值必须是字符串。同样，你会发现结果面板中数字的顺序可能与字典中分数的顺序大不相同。这是可以的，因为你不需要知道顺序就能访问任何内容。你可以通过键找到任何你需要的项。让我们看看如何做到这一点！
- en: '**ACCESSING VALUES IN A DICTIONARY**'
  id: totrans-9644
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**访问字典中的值**'
- en: 'Looking up a value in a dictionary is similar to how you access a value in
    an array except that you use a key inside the square brackets instead of an index,
    like this: usStates["TX"] .'
  id: totrans-9645
  prefs: []
  type: TYPE_NORMAL
  zh: 在字典中查找值类似于在数组中访问值，只是你使用键而不是索引，像这样：usStates["TX"]。
- en: There is a big difference, however, in how Swift returns the values from a dictionary.
    When you access a value at an index of an array, you are simply given the value.
    When you access a value with a key in a dictionary, you are given an optional.
  id: totrans-9646
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在 Swift 中从字典返回值有一个很大的区别。当你访问数组中某个索引的值时，你只是简单地得到这个值。而当你用字典中的键访问一个值时，你得到的是一个可选值。
- en: In [Chapter 5](text00015.html#ch05) , you learned that optionals might contain
    a value or might be nil . The reason Swift returns optionals when you’re looking
    up items in a dictionary is that the key you used might not exist in the dictionary,
    in which case there’s no value to access. Trying to access a value that doesn’t
    exist would give you a big fat error! To avoid that problem, Swift returns optionals.
    That means you need to unwrap any value you get out of a dictionary before you
    can do anything with it.
  id: totrans-9647
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第5章](text00015.html#ch05)中，你学到了可选项可能包含一个值，也可能是 nil。Swift 在查找字典中的项目时返回可选项的原因是你使用的键可能在字典中不存在，在这种情况下就没有值可以访问。尝试访问一个不存在的值会导致一个错误！为避免此问题，Swift
    返回可选项。这意味着你需要解包从字典中获取的任何值，才能对其进行操作。
- en: 'To unwrap an optional, first you check whether it exists using an if-let statement,
    just like we did in [Chapter 5](text00015.html#ch05) . The following code shows
    you how to get a value out of a dictionary:'
  id: totrans-9648
  prefs: []
  type: TYPE_NORMAL
  zh: 要解包一个可选项，首先使用 if-let 语句检查它是否存在，就像我们在[第5章](text00015.html#ch05)中做的那样。以下代码展示了如何从字典中获取一个值：
- en: '![Image](Image00143.jpg)'
  id: totrans-9649
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00143.jpg)'
- en: To retrieve "Texas" from the dictionary, we use if let to set a constant loneStarState
    to usStates["TX"] ➊ . Because we have this state in our dictionary, the line I
    have Texas in my dictionary. is printed. Next we try to access a state that is
    not in our dictionary by using the key usStates["FL"] ➋ . Thankfully, because
    we used an if-let statement, the program won’t crash when the computer can’t find
    this state. Instead, I don't have that state in my dictionary. is printed.
  id: totrans-9650
  prefs: []
  type: TYPE_NORMAL
  zh: 要从字典中检索 "Texas"，我们使用 if let 将常量 loneStarState 设置为 usStates["TX"] ➊。因为我们在字典中有这个州，所以打印出
    "I have Texas in my dictionary"。接下来，我们尝试通过使用键 usStates["FL"] ➋ 来访问一个不在字典中的州。幸运的是，因为我们使用了
    if-let 语句，当计算机找不到该州时，程序不会崩溃。相反，打印出 "I don't have that state in my dictionary"。
- en: '**ADDING ITEMS TO A DICTIONARY**'
  id: totrans-9651
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**向字典中添加项目**'
- en: 'To add an item to a dictionary, first write the name of your dictionary and
    assign the new item to the key you want it to have in the dictionary. Let’s add
    "Minnesota" to our usStates dictionary:'
  id: totrans-9652
  prefs: []
  type: TYPE_NORMAL
  zh: 要向字典中添加一个项目，首先写出字典的名称，并将新项目分配给你希望它在字典中具有的键。让我们将 "Minnesota" 添加到我们的 usStates
    字典中：
- en: '![](Image00144.jpg)'
  id: totrans-9653
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00144.jpg)'
- en: 'Now when you look at usStates , you’ll see that it’s updated to ["MN": "Minnesota",
    "WA": "Washington", "MA": "Massachusetts", "TX": "Texas"] . Remember, because
    you don’t have to rely on indices, your new dictionary item might appear anywhere
    in the dictionary.'
  id: totrans-9654
  prefs: []
  type: TYPE_NORMAL
  zh: '现在，当你查看 usStates 时，你会看到它已更新为 ["MN": "Minnesota", "WA": "Washington", "MA":
    "Massachusetts", "TX": "Texas"]。记住，因为你不需要依赖索引，你的新字典项目可能出现在字典的任何位置。'
- en: '**REMOVING ITEMS FROM A DICTIONARY**'
  id: totrans-9655
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**从字典中删除项目**'
- en: Removing an item from a dictionary is quite simple; you do so by setting the
    value to nil . Because the values in dictionaries are returned as optionals, you
    don’t have to worry about nil causing any problems in your dictionary.
  id: totrans-9656
  prefs: []
  type: TYPE_NORMAL
  zh: 从字典中删除项目非常简单；你只需将值设置为 nil。由于字典中的值作为可选项返回，因此你不必担心 nil 会在字典中引发任何问题。
- en: '![](Image00145.jpg)'
  id: totrans-9657
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00145.jpg)'
- en: 'You can see that after you remove the value at the key "MA" , usStates is updated
    to ["MN": "Minnesota", "WA": "Washington", "TX": "Texas"] . Remember that nil
    is special and means that there’s no value at all. That’s why you don’t see "MA":
    nil in our dictionary.'
  id: totrans-9658
  prefs: []
  type: TYPE_NORMAL
  zh: '你可以看到，在你删除了键 "MA" 的值后，usStates 被更新为 ["MN": "Minnesota", "WA": "Washington",
    "TX": "Texas"]。记住，nil 是特殊的，表示根本没有值。因此，你不会在字典中看到 "MA": nil。'
- en: '**REPLACING ITEMS IN A DICTIONARY**'
  id: totrans-9659
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**在字典中替换项目**'
- en: 'Replacing an item in a dictionary is also easy. It works the same was as replacing
    an item in an array. You just set the item that you want to replace to something
    else. Say you create a dictionary of fruit colors:'
  id: totrans-9660
  prefs: []
  type: TYPE_NORMAL
  zh: 替换字典中的项目也很简单。它的工作方式与替换数组中的项目相同。你只需将你想要替换的项目设置为其他值。假设你创建了一个水果颜色的字典：
- en: '![](Image00146.jpg)'
  id: totrans-9661
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00146.jpg)'
- en: At first we had the value "apple" for "red" , but then we decided that "raspberry"
    is a better fruit to use since sometimes apples are green or yellow. To replace
    "apple" with "raspberry" , we set colorFruits["red"] to its new value ➊ .
  id: totrans-9662
  prefs: []
  type: TYPE_NORMAL
  zh: 起初我们为 "red" 设置了值 "apple"，但后来我们决定使用 "raspberry" 更合适，因为有时苹果是绿色或黄色的。为了用 "raspberry"
    替换 "apple"，我们将 colorFruits["red"] 设置为新的值 ➊。
- en: You may remember that this is the same way we entered a new value into a dictionary.
    If the key already exists in the dictionary, then the value for that key is replaced.
    If the key doesn’t already exist, then the new key/value pair will be added to
    the dictionary.
  id: totrans-9663
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能记得这正是我们向字典中输入新值的方式。如果键已经存在于字典中，则该键的值会被替换。如果键不存在，则新的键/值对将被添加到字典中。
- en: '![Image](Image00147.jpg)'
  id: totrans-9664
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00147.jpg)'
- en: '**USING DICTIONARY PROPERTIES**'
  id: totrans-9665
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**使用字典属性**'
- en: 'Like an array, a dictionary also has an isEmpty property and a count property.
    For example, the following code shows how you can use the isEmpty property to
    check if a dictionary is empty, and if it isn’t empty, the count property checks
    how many items you have. Imagine you have a basket of fruit for sale. You can
    use these properties to help you keep track of everything:'
  id: totrans-9666
  prefs: []
  type: TYPE_NORMAL
  zh: 和数组一样，字典也有 isEmpty 属性和 count 属性。例如，以下代码展示了如何使用 isEmpty 属性检查字典是否为空，如果不为空，count
    属性检查字典中有多少个条目。假设你有一个出售的水果篮。你可以使用这些属性来帮助你跟踪一切：
- en: '![Image](Image00148.jpg)'
  id: totrans-9667
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00148.jpg)'
- en: 'A dictionary also has two special properties: keys , which contains all of
    the dictionary’s keys, and values , which contains all of its values. We’ll use
    these two properties when we loop through the dictionary.'
  id: totrans-9668
  prefs: []
  type: TYPE_NORMAL
  zh: 字典还具有两个特殊属性：keys，其中包含字典的所有键，以及 values，其中包含字典的所有值。我们将在遍历字典时使用这两个属性。
- en: Let’s write some code that loops through our fruit baskets and prints the price
    of each fruit.
  id: totrans-9669
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们编写一些代码，遍历我们的水果篮并打印每个水果的价格。
- en: '**LOOPING OVER A DICTIONARY**'
  id: totrans-9670
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**遍历字典**'
- en: 'You can loop through a dictionary using a for-in loop. Because each item has
    a key and a value, you can do this in two different ways. This is how to loop
    through a dictionary using its keys:'
  id: totrans-9671
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用 for-in 循环遍历字典。因为每个条目都有一个键和值，所以你可以用两种不同的方式来实现。这是使用键来遍历字典的方式：
- en: '![Image](Image00149.jpg)'
  id: totrans-9672
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00149.jpg)'
- en: Here we use the dictionary’s keys property ➊ to loop through fruitBasket and
    print its contents. We start by writing the keyword for , followed by a constant
    name fruit for the dictionary key, the keyword in , the dictionary name, a period,
    and keys .
  id: totrans-9673
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们使用字典的 keys 属性 ➊ 来遍历 fruitBasket 并打印其内容。我们从编写关键字 for 开始，接着是常量名称 fruit（代表字典键），关键字
    in，字典名称，句点，然后是 keys。
- en: Inside the braces of our for-in loop, we have access to both the key, which
    we call fruit ➋ , and the value at that key when we force-unwrap its contents
    with fruitBasket[fruit]! ➌ . That value will be the fruit’s price.
  id: totrans-9674
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们 for-in 循环的大括号内，我们可以访问键（我们称之为 fruit ➋）以及该键的值，当我们通过 fruitBasket[fruit]! ➌
    强制解包其内容时。该值将是水果的价格。
- en: In this case, it’s safe to force-unwrap the value using an exclamation point
    because we know that the fruit key we’re using is definitely inside the dictionary.
  id: totrans-9675
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，使用感叹号强制解包值是安全的，因为我们知道我们使用的 fruit 键肯定在字典中。
- en: Any code we put inside the for-in loop will run once for every key in our dictionary.
    So you should see the print statement display three times.
  id: totrans-9676
  prefs: []
  type: TYPE_NORMAL
  zh: 我们放入 for-in 循环中的任何代码都会对字典中的每个键执行一次。所以你应该看到打印语句显示三次。
- en: 'We can also loop through the dictionary using its values property:'
  id: totrans-9677
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以通过字典的 values 属性来遍历字典：
- en: '![Image](Image00150.jpg)'
  id: totrans-9678
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00150.jpg)'
- en: We use the same style of for-in loop, but now we use a constant to refer to
    each value, which we call price , in the values property. When looping through
    values, we don’t have access to the keys from inside the loop.
  id: totrans-9679
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用相同类型的 for-in 循环，但现在我们使用常量来引用每个值，我们称之为 price，它位于 values 属性中。在遍历值时，我们无法从循环内部访问键。
- en: Another difference to note is that price is not an optional because it’s accessed
    directly as a value in the fruitBasket dictionary. That means we don’t have to
    unwrap it. You should still see the print statement printed three times. [Figure
    6-6](text00016.html#ch06fig6) shows the output of both loops.
  id: totrans-9680
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个需要注意的区别是，price 不是可选值，因为它是作为水果篮字典中的一个值直接访问的。这意味着我们不需要解包它。你仍然应该看到打印语句打印三次。[图
    6-6](text00016.html#ch06fig6) 显示了两个循环的输出。
- en: '![Image](Image00151.jpg)'
  id: totrans-9681
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00151.jpg)'
- en: '*Figure 6-6: Looping through the keys and values of a dictionary with a for-in
    loop*'
  id: totrans-9682
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 6-6：使用 for-in 循环遍历字典的键和值*'
- en: The order of your results might be slightly different from ours. That’s because
    the items in a dictionary aren’t in a numbered order like they are in an array!
    And because the order is not guaranteed, you might see a different order printed
    if you run the same code again.
  id: totrans-9683
  prefs: []
  type: TYPE_NORMAL
  zh: 你得到的结果顺序可能与我们的略有不同。这是因为字典中的项不像数组中的项那样按编号顺序排列！由于顺序无法保证，因此如果你再次运行相同的代码，打印的顺序可能会有所不同。
- en: '**WHAT YOU LEARNED**'
  id: totrans-9684
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**你学到了什么**'
- en: In this chapter, you learned how to store collections of items in an array and
    in a dictionary. To store items in an ordered list, you would use an array and
    look up each item by its index. If you wanted to store items by key instead, you
    would use a dictionary.
  id: totrans-9685
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你学习了如何在数组和字典中存储项。为了将项存储在一个有序列表中，你应该使用数组，并通过索引查找每个项。如果你想根据键来存储项，则应使用字典。
- en: Knowing about arrays and dictionaries and how to use them is a powerful building
    block for almost any programming language. Next we will learn about functions,
    another very powerful tool. Functions are blocks of code that you create and name
    to perform a specific job. After you have written a function, you can use its
    name to call it from almost anywhere in your program.
  id: totrans-9686
  prefs: []
  type: TYPE_NORMAL
  zh: 了解数组和字典以及如何使用它们是几乎任何编程语言的一个强大基础。接下来，我们将学习函数，另一个非常强大的工具。函数是你创建并命名的代码块，用于执行特定任务。在你编写完一个函数后，你可以通过它的名称在程序的几乎任何地方调用它。
- en: '![Image](Image00140.jpg)'
  id: totrans-9687
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00140.jpg)'
- en: '**INITIALIZING A DICTIONARY**'
  id: totrans-9688
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**初始化字典**'
- en: 'To create and initialize a dictionary, first write var and the name of your
    dictionary. Then write the keys and corresponding values inside a pair of square
    brackets, similar to an array. Let’s create a dictionary to store the names of
    a few US states. The key for each state will be its two-letter abbreviation:'
  id: totrans-9689
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建和初始化字典，首先写上 var 和字典的名称。然后在一对方括号中写上键和值，类似于数组。让我们创建一个字典来存储几个美国州的名称。每个州的键将是它的两个字母缩写：
- en: '![](Image00141.jpg)'
  id: totrans-9690
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00141.jpg)'
- en: As you can see, there’s a colon between each key and its value, and the key/value
    pairs are separated by commas.
  id: totrans-9691
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，每个键和值之间都有一个冒号，键/值对之间用逗号分隔。
- en: Dictionaries are different from arrays in that they are *unordered* . Because
    of that, it’s likely that the order of the states that you see in your results
    pane ➋ is different from the order in which you entered your states ➊ . It might
    even be different than the order that’s printed in this book!
  id: totrans-9692
  prefs: []
  type: TYPE_NORMAL
  zh: 字典不同于数组，它们是*无序的*。因此，你在结果面板中看到的州的顺序➋可能与输入州时的顺序➊不同，甚至可能与本书中打印的顺序不同！
- en: As with arrays, you can use var to make a mutable dictionary or use let to make
    an immutable dictionary.
  id: totrans-9693
  prefs: []
  type: TYPE_NORMAL
  zh: 与数组一样，你可以使用 var 来创建一个可变字典，或者使用 let 来创建一个不可变字典。
- en: 'In Swift, all of the keys of a dictionary must be the same type, and all of
    the values of a dictionary must also be the same type, but the key type doesn’t
    have to match the value type. For example, if you wanted to store a collection
    of fractions, you could use doubles for the keys and strings for the values:'
  id: totrans-9694
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Swift 中，字典的所有键必须是相同类型，而字典的所有值也必须是相同类型，但键的类型不需要与值的类型匹配。例如，如果你想存储一组分数，你可以将键设为双精度浮点数，而将值设为字符串：
- en: '![](Image00142.jpg)'
  id: totrans-9695
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00142.jpg)'
- en: In this dictionary, all of the keys must be doubles, and all of the values must
    be strings. Again, you’ll see that the order of the numbers in the results pane
    can be quite different from the order in which you wrote the fractions in your
    dictionary. This is fine because you don’t need to know the order to access anything.
    You can find any item that you need by its key. Let’s see how!
  id: totrans-9696
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个字典中，所有的键必须是双精度浮点数，所有的值必须是字符串。同样，你会发现结果面板中的数字顺序可能与你在字典中输入分数的顺序大相径庭。这是正常的，因为你不需要知道顺序就能访问任何项。你可以通过键找到任何你需要的项。我们来看看！
- en: '**ACCESSING VALUES IN A DICTIONARY**'
  id: totrans-9697
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**访问字典中的值**'
- en: 'Looking up a value in a dictionary is similar to how you access a value in
    an array except that you use a key inside the square brackets instead of an index,
    like this: usStates["TX"] .'
  id: totrans-9698
  prefs: []
  type: TYPE_NORMAL
  zh: 在字典中查找一个值的方式类似于访问数组中的值，不同之处在于，你需要在方括号内使用一个键而不是索引，例如：usStates["TX"]。
- en: There is a big difference, however, in how Swift returns the values from a dictionary.
    When you access a value at an index of an array, you are simply given the value.
    When you access a value with a key in a dictionary, you are given an optional.
  id: totrans-9699
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，Swift在从字典中返回值时有一个重要区别。当你访问数组中的某个索引的值时，你只是获得该值。当你通过键访问字典中的值时，你得到的是一个可选值。
- en: In [Chapter 5](text00015.html#ch05) , you learned that optionals might contain
    a value or might be nil . The reason Swift returns optionals when you’re looking
    up items in a dictionary is that the key you used might not exist in the dictionary,
    in which case there’s no value to access. Trying to access a value that doesn’t
    exist would give you a big fat error! To avoid that problem, Swift returns optionals.
    That means you need to unwrap any value you get out of a dictionary before you
    can do anything with it.
  id: totrans-9700
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第5章](text00015.html#ch05)中，你学习了可选值可能包含一个值，也可能是nil。当你在字典中查找项目时，Swift返回可选值的原因是你使用的键可能在字典中不存在，在这种情况下没有值可以访问。尝试访问一个不存在的值会给你一个大错误！为避免这个问题，Swift返回可选值。这意味着你在对字典中的值进行任何操作之前，需要解包任何从字典中获取的值。
- en: 'To unwrap an optional, first you check whether it exists using an if-let statement,
    just like we did in [Chapter 5](text00015.html#ch05) . The following code shows
    you how to get a value out of a dictionary:'
  id: totrans-9701
  prefs: []
  type: TYPE_NORMAL
  zh: 要解包一个可选值，首先你需要使用if-let语句检查它是否存在，就像我们在[第5章](text00015.html#ch05)中做的那样。以下代码展示了如何从字典中获取一个值：
- en: '![Image](Image00143.jpg)'
  id: totrans-9702
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00143.jpg)'
- en: To retrieve "Texas" from the dictionary, we use if let to set a constant loneStarState
    to usStates["TX"] ➊ . Because we have this state in our dictionary, the line I
    have Texas in my dictionary. is printed. Next we try to access a state that is
    not in our dictionary by using the key usStates["FL"] ➋ . Thankfully, because
    we used an if-let statement, the program won’t crash when the computer can’t find
    this state. Instead, I don't have that state in my dictionary. is printed.
  id: totrans-9703
  prefs: []
  type: TYPE_NORMAL
  zh: 要从字典中检索“Texas”，我们使用if let将常量loneStarState设置为usStates["TX"] ➊。因为字典中有这个州，所以打印了“I
    have Texas in my dictionary.”接下来，我们尝试使用不存在的州键usStates["FL"] ➋访问一个州。幸运的是，由于我们使用了if-let语句，当计算机找不到该州时，程序不会崩溃。相反，打印了“I
    don't have that state in my dictionary.”
- en: '**ADDING ITEMS TO A DICTIONARY**'
  id: totrans-9704
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**向字典中添加项目**'
- en: 'To add an item to a dictionary, first write the name of your dictionary and
    assign the new item to the key you want it to have in the dictionary. Let’s add
    "Minnesota" to our usStates dictionary:'
  id: totrans-9705
  prefs: []
  type: TYPE_NORMAL
  zh: 要向字典中添加一个项目，首先写出字典的名称，并将新项目赋给你想要它在字典中对应的键。让我们将"Michigan"添加到我们的usStates字典：
- en: '![](Image00144.jpg)'
  id: totrans-9706
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00144.jpg)'
- en: 'Now when you look at usStates , you’ll see that it’s updated to ["MN": "Minnesota",
    "WA": "Washington", "MA": "Massachusetts", "TX": "Texas"] . Remember, because
    you don’t have to rely on indices, your new dictionary item might appear anywhere
    in the dictionary.'
  id: totrans-9707
  prefs: []
  type: TYPE_NORMAL
  zh: '现在当你查看usStates时，你会看到它已更新为["MN": "Minnesota", "WA": "Washington", "MA": "Massachusetts",
    "TX": "Texas"]。记住，因为你不需要依赖索引，所以新的字典项可能出现在字典的任何位置。'
- en: '**REMOVING ITEMS FROM A DICTIONARY**'
  id: totrans-9708
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**从字典中移除项目**'
- en: Removing an item from a dictionary is quite simple; you do so by setting the
    value to nil . Because the values in dictionaries are returned as optionals, you
    don’t have to worry about nil causing any problems in your dictionary.
  id: totrans-9709
  prefs: []
  type: TYPE_NORMAL
  zh: 从字典中移除项目非常简单；你只需将值设置为nil即可。因为字典中的值是作为可选值返回的，所以你不必担心nil会在字典中造成任何问题。
- en: '![](Image00145.jpg)'
  id: totrans-9710
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00145.jpg)'
- en: 'You can see that after you remove the value at the key "MA" , usStates is updated
    to ["MN": "Minnesota", "WA": "Washington", "TX": "Texas"] . Remember that nil
    is special and means that there’s no value at all. That’s why you don’t see "MA":
    nil in our dictionary.'
  id: totrans-9711
  prefs: []
  type: TYPE_NORMAL
  zh: '你可以看到，在移除键"MA"对应的值后，usStates被更新为["MN": "Minnesota", "WA": "Washington", "TX":
    "Texas"]。记住，nil是特殊的，表示没有任何值。这就是为什么在我们的字典中没有看到"MA": nil的原因。'
- en: '**REPLACING ITEMS IN A DICTIONARY**'
  id: totrans-9712
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**在字典中替换项目**'
- en: 'Replacing an item in a dictionary is also easy. It works the same was as replacing
    an item in an array. You just set the item that you want to replace to something
    else. Say you create a dictionary of fruit colors:'
  id: totrans-9713
  prefs: []
  type: TYPE_NORMAL
  zh: 在字典中替换项目也很简单。它与替换数组中的项目是一样的。你只需要将你想替换的项目设为另一个值。例如，假设你创建了一个水果颜色的字典：
- en: '![](Image00146.jpg)'
  id: totrans-9714
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00146.jpg)'
- en: At first we had the value "apple" for "red" , but then we decided that "raspberry"
    is a better fruit to use since sometimes apples are green or yellow. To replace
    "apple" with "raspberry" , we set colorFruits["red"] to its new value ➊ .
  id: totrans-9715
  prefs: []
  type: TYPE_NORMAL
  zh: 起初我们为“red”赋值为“apple”，但后来我们决定使用“raspberry”作为更好的水果，因为有时苹果是绿色或黄色的。为了将“apple”替换为“raspberry”，我们将colorFruits["red"]设置为其新值➊。
- en: You may remember that this is the same way we entered a new value into a dictionary.
    If the key already exists in the dictionary, then the value for that key is replaced.
    If the key doesn’t already exist, then the new key/value pair will be added to
    the dictionary.
  id: totrans-9716
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能还记得，这与我们将新值插入字典时的方式相同。如果键已经存在于字典中，那么该键的值将被替换。如果键不存在，则新的键/值对将被添加到字典中。
- en: '![Image](Image00147.jpg)'
  id: totrans-9717
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00147.jpg)'
- en: '**USING DICTIONARY PROPERTIES**'
  id: totrans-9718
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**使用字典属性**'
- en: 'Like an array, a dictionary also has an isEmpty property and a count property.
    For example, the following code shows how you can use the isEmpty property to
    check if a dictionary is empty, and if it isn’t empty, the count property checks
    how many items you have. Imagine you have a basket of fruit for sale. You can
    use these properties to help you keep track of everything:'
  id: totrans-9719
  prefs: []
  type: TYPE_NORMAL
  zh: 就像数组一样，字典也有isEmpty属性和count属性。例如，下面的代码展示了如何使用isEmpty属性检查字典是否为空，如果字典不为空，count属性将检查你有多少项。假设你有一个水果篮子在出售。你可以使用这些属性来帮助你追踪一切：
- en: '![Image](Image00148.jpg)'
  id: totrans-9720
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00148.jpg)'
- en: 'A dictionary also has two special properties: keys , which contains all of
    the dictionary’s keys, and values , which contains all of its values. We’ll use
    these two properties when we loop through the dictionary.'
  id: totrans-9721
  prefs: []
  type: TYPE_NORMAL
  zh: 字典还有两个特殊的属性：keys，包含所有字典的键，和values，包含所有字典的值。我们将在遍历字典时使用这两个属性。
- en: Let’s write some code that loops through our fruit baskets and prints the price
    of each fruit.
  id: totrans-9722
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们编写一些代码，遍历我们的水果篮子并打印每个水果的价格。
- en: '**LOOPING OVER A DICTIONARY**'
  id: totrans-9723
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**遍历字典**'
- en: 'You can loop through a dictionary using a for-in loop. Because each item has
    a key and a value, you can do this in two different ways. This is how to loop
    through a dictionary using its keys:'
  id: totrans-9724
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用for-in循环遍历字典。由于每个项目都有一个键和值，因此你可以通过两种不同的方式来实现。下面是通过键来遍历字典的方式：
- en: '![Image](Image00149.jpg)'
  id: totrans-9725
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00149.jpg)'
- en: Here we use the dictionary’s keys property ➊ to loop through fruitBasket and
    print its contents. We start by writing the keyword for , followed by a constant
    name fruit for the dictionary key, the keyword in , the dictionary name, a period,
    and keys .
  id: totrans-9726
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们使用字典的keys属性➊来遍历fruitBasket并打印其内容。我们从写下关键字for开始，接着是字典键的常量名称fruit，关键字in，字典名称，句点，和keys。
- en: Inside the braces of our for-in loop, we have access to both the key, which
    we call fruit ➋ , and the value at that key when we force-unwrap its contents
    with fruitBasket[fruit]! ➌ . That value will be the fruit’s price.
  id: totrans-9727
  prefs: []
  type: TYPE_NORMAL
  zh: 在for-in循环的花括号内，我们可以访问键（我们称之为fruit➋）和该键的值，当我们强制解包其内容时，使用fruitBasket[fruit]!➌。该值将是水果的价格。
- en: In this case, it’s safe to force-unwrap the value using an exclamation point
    because we know that the fruit key we’re using is definitely inside the dictionary.
  id: totrans-9728
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，可以安全地强制解包值，因为我们知道我们使用的水果键肯定在字典中。
- en: Any code we put inside the for-in loop will run once for every key in our dictionary.
    So you should see the print statement display three times.
  id: totrans-9729
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在for-in循环中放入的任何代码都会为字典中的每个键执行一次。所以你应该会看到打印语句显示三次。
- en: 'We can also loop through the dictionary using its values property:'
  id: totrans-9730
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以使用字典的values属性来遍历字典：
- en: '![Image](Image00150.jpg)'
  id: totrans-9731
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00150.jpg)'
- en: We use the same style of for-in loop, but now we use a constant to refer to
    each value, which we call price , in the values property. When looping through
    values, we don’t have access to the keys from inside the loop.
  id: totrans-9732
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用相同的for-in循环风格，但现在我们使用常量来引用values属性中的每个值，我们称之为price。在遍历values时，我们无法从循环内部访问键。
- en: Another difference to note is that price is not an optional because it’s accessed
    directly as a value in the fruitBasket dictionary. That means we don’t have to
    unwrap it. You should still see the print statement printed three times. [Figure
    6-6](text00016.html#ch06fig6) shows the output of both loops.
  id: totrans-9733
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个需要注意的区别是，price不是可选的，因为它直接作为值访问fruitBasket字典。这意味着我们不需要解包它。你仍然应该看到打印语句被打印三次。[图6-6](text00016.html#ch06fig6)展示了两个循环的输出。
- en: '![Image](Image00151.jpg)'
  id: totrans-9734
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00151.jpg)'
- en: '*Figure 6-6: Looping through the keys and values of a dictionary with a for-in
    loop*'
  id: totrans-9735
  prefs: []
  type: TYPE_NORMAL
  zh: '*图6-6：使用 for-in 循环遍历字典的键和值*'
- en: The order of your results might be slightly different from ours. That’s because
    the items in a dictionary aren’t in a numbered order like they are in an array!
    And because the order is not guaranteed, you might see a different order printed
    if you run the same code again.
  id: totrans-9736
  prefs: []
  type: TYPE_NORMAL
  zh: 你的结果顺序可能与你的不同。这是因为字典中的项不像数组那样按编号顺序排列！由于顺序不确定，如果你再次运行相同的代码，你可能会看到不同的顺序。
- en: '**WHAT YOU LEARNED**'
  id: totrans-9737
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**你学到了什么**'
- en: In this chapter, you learned how to store collections of items in an array and
    in a dictionary. To store items in an ordered list, you would use an array and
    look up each item by its index. If you wanted to store items by key instead, you
    would use a dictionary.
  id: totrans-9738
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你学会了如何在数组和字典中存储集合。要在有序列表中存储项，你将使用数组并通过索引查找每个项。如果你想按键存储项，你将使用字典。
- en: Knowing about arrays and dictionaries and how to use them is a powerful building
    block for almost any programming language. Next we will learn about functions,
    another very powerful tool. Functions are blocks of code that you create and name
    to perform a specific job. After you have written a function, you can use its
    name to call it from almost anywhere in your program.
  id: totrans-9739
  prefs: []
  type: TYPE_NORMAL
  zh: 了解数组和字典以及如何使用它们是几乎任何编程语言的一个强大构建块。接下来我们将学习函数，另一个非常强大的工具。函数是你创建并命名的代码块，用来执行特定的任务。编写完函数后，你可以通过它的名称在程序的几乎任何地方调用它。
- en: '**INITIALIZING A DICTIONARY**'
  id: totrans-9740
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**初始化字典**'
- en: 'To create and initialize a dictionary, first write var and the name of your
    dictionary. Then write the keys and corresponding values inside a pair of square
    brackets, similar to an array. Let’s create a dictionary to store the names of
    a few US states. The key for each state will be its two-letter abbreviation:'
  id: totrans-9741
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建并初始化一个字典，首先写上 var 和字典的名称。然后在一对方括号内写上键和值，类似于数组。让我们创建一个字典来存储几个美国州的名称。每个州的键将是它的两个字母的缩写：
- en: '![](Image00141.jpg)'
  id: totrans-9742
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00141.jpg)'
- en: As you can see, there’s a colon between each key and its value, and the key/value
    pairs are separated by commas.
  id: totrans-9743
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，每个键和值之间有一个冒号，并且键/值对是由逗号分隔的。
- en: Dictionaries are different from arrays in that they are *unordered* . Because
    of that, it’s likely that the order of the states that you see in your results
    pane ➋ is different from the order in which you entered your states ➊ . It might
    even be different than the order that’s printed in this book!
  id: totrans-9744
  prefs: []
  type: TYPE_NORMAL
  zh: 字典与数组不同，因为它们是 *无序的*。因此，你在结果面板中看到的州的顺序 ➋ 可能与你输入州的顺序 ➊ 不同。它甚至可能与书中打印的顺序不同！
- en: As with arrays, you can use var to make a mutable dictionary or use let to make
    an immutable dictionary.
  id: totrans-9745
  prefs: []
  type: TYPE_NORMAL
  zh: 与数组一样，你可以使用 var 来创建一个可变字典，或者使用 let 创建一个不可变字典。
- en: 'In Swift, all of the keys of a dictionary must be the same type, and all of
    the values of a dictionary must also be the same type, but the key type doesn’t
    have to match the value type. For example, if you wanted to store a collection
    of fractions, you could use doubles for the keys and strings for the values:'
  id: totrans-9746
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Swift 中，字典的所有键必须是相同类型的，字典的所有值也必须是相同类型的，但键的类型不必与值的类型匹配。例如，如果你想存储一个分数集合，你可以使用双精度浮点数作为键，字符串作为值：
- en: '![](Image00142.jpg)'
  id: totrans-9747
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00142.jpg)'
- en: In this dictionary, all of the keys must be doubles, and all of the values must
    be strings. Again, you’ll see that the order of the numbers in the results pane
    can be quite different from the order in which you wrote the fractions in your
    dictionary. This is fine because you don’t need to know the order to access anything.
    You can find any item that you need by its key. Let’s see how!
  id: totrans-9748
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个字典中，所有的键必须是双精度浮点数，所有的值必须是字符串。再次提醒，结果面板中的数字顺序可能与您在字典中书写分数的顺序大不相同。这是没问题的，因为你不需要知道顺序才能访问任何内容。你可以通过键找到任何你需要的项。我们来看看怎么做！
- en: '**ACCESSING VALUES IN A DICTIONARY**'
  id: totrans-9749
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**访问字典中的值**'
- en: 'Looking up a value in a dictionary is similar to how you access a value in
    an array except that you use a key inside the square brackets instead of an index,
    like this: usStates["TX"] .'
  id: totrans-9750
  prefs: []
  type: TYPE_NORMAL
  zh: 在字典中查找值类似于你在数组中访问值的方式，只是你在方括号中使用的是键而不是索引，像这样：usStates["TX"]。
- en: There is a big difference, however, in how Swift returns the values from a dictionary.
    When you access a value at an index of an array, you are simply given the value.
    When you access a value with a key in a dictionary, you are given an optional.
  id: totrans-9751
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，Swift 从字典中返回值的方式有很大不同。当你访问数组中某个索引的值时，你会直接得到这个值。而当你用键访问字典中的值时，你得到的是一个可选项。
- en: In [Chapter 5](text00015.html#ch05) , you learned that optionals might contain
    a value or might be nil . The reason Swift returns optionals when you’re looking
    up items in a dictionary is that the key you used might not exist in the dictionary,
    in which case there’s no value to access. Trying to access a value that doesn’t
    exist would give you a big fat error! To avoid that problem, Swift returns optionals.
    That means you need to unwrap any value you get out of a dictionary before you
    can do anything with it.
  id: totrans-9752
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第五章](text00015.html#ch05)中，你学习过可选项可能包含一个值，也可能是 nil。Swift 在查找字典中的项时返回可选项的原因是，你使用的键可能在字典中不存在，在这种情况下没有值可以访问。试图访问不存在的值会导致一个严重错误！为了避免这个问题，Swift
    返回可选项。这意味着，在你对字典中获取的任何值进行操作之前，你需要先解包它。
- en: 'To unwrap an optional, first you check whether it exists using an if-let statement,
    just like we did in [Chapter 5](text00015.html#ch05) . The following code shows
    you how to get a value out of a dictionary:'
  id: totrans-9753
  prefs: []
  type: TYPE_NORMAL
  zh: 要解包一个可选项，首先使用 if-let 语句检查它是否存在，就像我们在[第五章](text00015.html#ch05)中做的那样。以下代码演示了如何从字典中获取一个值：
- en: '![Image](Image00143.jpg)'
  id: totrans-9754
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00143.jpg)'
- en: To retrieve "Texas" from the dictionary, we use if let to set a constant loneStarState
    to usStates["TX"] ➊ . Because we have this state in our dictionary, the line I
    have Texas in my dictionary. is printed. Next we try to access a state that is
    not in our dictionary by using the key usStates["FL"] ➋ . Thankfully, because
    we used an if-let statement, the program won’t crash when the computer can’t find
    this state. Instead, I don't have that state in my dictionary. is printed.
  id: totrans-9755
  prefs: []
  type: TYPE_NORMAL
  zh: 要从字典中检索"Texas"，我们使用 if let 将常量 loneStarState 设置为 usStates["TX"] ➊。因为我们字典中有这个州，所以会打印出
    "I have Texas in my dictionary."。接下来，我们尝试使用键 usStates["FL"] ➋ 访问一个不在字典中的州。幸运的是，因为我们使用了
    if-let 语句，当计算机找不到这个州时，程序不会崩溃。相反，会打印出 "I don't have that state in my dictionary."。
- en: '**ADDING ITEMS TO A DICTIONARY**'
  id: totrans-9756
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**向字典中添加项**'
- en: 'To add an item to a dictionary, first write the name of your dictionary and
    assign the new item to the key you want it to have in the dictionary. Let’s add
    "Minnesota" to our usStates dictionary:'
  id: totrans-9757
  prefs: []
  type: TYPE_NORMAL
  zh: 要向字典中添加一项，首先写下字典的名称，然后将新项赋给你希望它拥有的键。让我们把 "Minnesota" 添加到我们的 usStates 字典中：
- en: '![](Image00144.jpg)'
  id: totrans-9758
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00144.jpg)'
- en: 'Now when you look at usStates , you’ll see that it’s updated to ["MN": "Minnesota",
    "WA": "Washington", "MA": "Massachusetts", "TX": "Texas"] . Remember, because
    you don’t have to rely on indices, your new dictionary item might appear anywhere
    in the dictionary.'
  id: totrans-9759
  prefs: []
  type: TYPE_NORMAL
  zh: '现在，当你查看 usStates 时，你会看到它已更新为["MN": "Minnesota", "WA": "Washington", "MA": "Massachusetts",
    "TX": "Texas"]。记住，因为你不需要依赖索引，所以新的字典项可能出现在字典中的任何位置。'
- en: '**REMOVING ITEMS FROM A DICTIONARY**'
  id: totrans-9760
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**从字典中移除项**'
- en: Removing an item from a dictionary is quite simple; you do so by setting the
    value to nil . Because the values in dictionaries are returned as optionals, you
    don’t have to worry about nil causing any problems in your dictionary.
  id: totrans-9761
  prefs: []
  type: TYPE_NORMAL
  zh: 从字典中移除一项非常简单；你只需将该值设置为 nil。因为字典中的值是作为可选项返回的，所以你不必担心 nil 会在字典中造成任何问题。
- en: '![](Image00145.jpg)'
  id: totrans-9762
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00145.jpg)'
- en: 'You can see that after you remove the value at the key "MA" , usStates is updated
    to ["MN": "Minnesota", "WA": "Washington", "TX": "Texas"] . Remember that nil
    is special and means that there’s no value at all. That’s why you don’t see "MA":
    nil in our dictionary.'
  id: totrans-9763
  prefs: []
  type: TYPE_NORMAL
  zh: '你可以看到，在你移除键为"MA"的值后，usStates 更新为["MN": "Minnesota", "WA": "Washington", "TX":
    "Texas"]。记住，nil 是特殊的，意味着根本没有值。这就是为什么你在字典中看不到"MA": nil。'
- en: '**REPLACING ITEMS IN A DICTIONARY**'
  id: totrans-9764
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**替换字典中的项**'
- en: 'Replacing an item in a dictionary is also easy. It works the same was as replacing
    an item in an array. You just set the item that you want to replace to something
    else. Say you create a dictionary of fruit colors:'
  id: totrans-9765
  prefs: []
  type: TYPE_NORMAL
  zh: 替换字典中的项也很简单。它的工作方式与替换数组中的项相同。你只需将要替换的项设置为其他值。例如，你可以创建一个包含水果颜色的字典：
- en: '![](Image00146.jpg)'
  id: totrans-9766
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00146.jpg)'
- en: At first we had the value "apple" for "red" , but then we decided that "raspberry"
    is a better fruit to use since sometimes apples are green or yellow. To replace
    "apple" with "raspberry" , we set colorFruits["red"] to its new value ➊ .
  id: totrans-9767
  prefs: []
  type: TYPE_NORMAL
  zh: 最开始我们为“红色”设置了值“apple”，但后来我们决定“raspberry”是更好的水果选择，因为有时苹果是绿色或黄色的。为了将“apple”替换为“raspberry”，我们将
    colorFruits["red"] 设置为新的值 ➊。
- en: You may remember that this is the same way we entered a new value into a dictionary.
    If the key already exists in the dictionary, then the value for that key is replaced.
    If the key doesn’t already exist, then the new key/value pair will be added to
    the dictionary.
  id: totrans-9768
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能还记得，这和我们将新值输入字典的方式相同。如果键已经存在于字典中，那么该键对应的值将被替换。如果该键尚不存在，则会将新的键值对添加到字典中。
- en: '![Image](Image00147.jpg)'
  id: totrans-9769
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00147.jpg)'
- en: '**USING DICTIONARY PROPERTIES**'
  id: totrans-9770
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**使用字典属性**'
- en: 'Like an array, a dictionary also has an isEmpty property and a count property.
    For example, the following code shows how you can use the isEmpty property to
    check if a dictionary is empty, and if it isn’t empty, the count property checks
    how many items you have. Imagine you have a basket of fruit for sale. You can
    use these properties to help you keep track of everything:'
  id: totrans-9771
  prefs: []
  type: TYPE_NORMAL
  zh: 像数组一样，字典也有 isEmpty 属性和 count 属性。例如，下面的代码展示了如何使用 isEmpty 属性来检查字典是否为空，如果字典不为空，则
    count 属性可以检查字典中有多少项。假设你有一个待售的水果篮，你可以使用这些属性来帮助你跟踪所有的东西：
- en: '![Image](Image00148.jpg)'
  id: totrans-9772
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00148.jpg)'
- en: 'A dictionary also has two special properties: keys , which contains all of
    the dictionary’s keys, and values , which contains all of its values. We’ll use
    these two properties when we loop through the dictionary.'
  id: totrans-9773
  prefs: []
  type: TYPE_NORMAL
  zh: 字典还有两个特殊属性：keys，其中包含字典的所有键，values，其中包含字典的所有值。我们将在循环遍历字典时使用这两个属性。
- en: Let’s write some code that loops through our fruit baskets and prints the price
    of each fruit.
  id: totrans-9774
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们写一些代码，循环遍历我们的水果篮并打印每个水果的价格。
- en: '**LOOPING OVER A DICTIONARY**'
  id: totrans-9775
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**循环遍历字典**'
- en: 'You can loop through a dictionary using a for-in loop. Because each item has
    a key and a value, you can do this in two different ways. This is how to loop
    through a dictionary using its keys:'
  id: totrans-9776
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用 for-in 循环来遍历字典。由于每个项都有一个键和值，因此你可以通过两种不同的方式来遍历字典。这是使用字典的键来循环遍历字典的方法：
- en: '![Image](Image00149.jpg)'
  id: totrans-9777
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00149.jpg)'
- en: Here we use the dictionary’s keys property ➊ to loop through fruitBasket and
    print its contents. We start by writing the keyword for , followed by a constant
    name fruit for the dictionary key, the keyword in , the dictionary name, a period,
    and keys .
  id: totrans-9778
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们使用字典的 keys 属性 ➊ 来循环遍历 fruitBasket 并打印其内容。我们从写下关键字 for 开始，后跟一个常量名称 fruit
    用来表示字典的键，接着是关键字 in，字典的名称，一个点，最后是 keys。
- en: Inside the braces of our for-in loop, we have access to both the key, which
    we call fruit ➋ , and the value at that key when we force-unwrap its contents
    with fruitBasket[fruit]! ➌ . That value will be the fruit’s price.
  id: totrans-9779
  prefs: []
  type: TYPE_NORMAL
  zh: 在 for-in 循环的花括号内，我们可以访问键（我们将其命名为 fruit ➋），并通过强制解包 fruitBasket[fruit]! ➌ 来访问该键对应的值。这个值将是水果的价格。
- en: In this case, it’s safe to force-unwrap the value using an exclamation point
    because we know that the fruit key we’re using is definitely inside the dictionary.
  id: totrans-9780
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，强制解包该值是安全的，因为我们知道我们使用的水果键肯定存在于字典中。
- en: Any code we put inside the for-in loop will run once for every key in our dictionary.
    So you should see the print statement display three times.
  id: totrans-9781
  prefs: []
  type: TYPE_NORMAL
  zh: 我们放入 for-in 循环中的任何代码都会对字典中的每个键执行一次。所以你应该看到打印语句会显示三次。
- en: 'We can also loop through the dictionary using its values property:'
  id: totrans-9782
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以通过字典的 values 属性来循环遍历字典：
- en: '![Image](Image00150.jpg)'
  id: totrans-9783
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00150.jpg)'
- en: We use the same style of for-in loop, but now we use a constant to refer to
    each value, which we call price , in the values property. When looping through
    values, we don’t have access to the keys from inside the loop.
  id: totrans-9784
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用相同类型的 for-in 循环，但现在我们使用一个常量来引用 values 属性中的每个值，我们将其命名为 price。在循环遍历值时，我们无法访问循环内的键。
- en: Another difference to note is that price is not an optional because it’s accessed
    directly as a value in the fruitBasket dictionary. That means we don’t have to
    unwrap it. You should still see the print statement printed three times. [Figure
    6-6](text00016.html#ch06fig6) shows the output of both loops.
  id: totrans-9785
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个需要注意的区别是，price 不是一个可选值，因为它是直接作为值在 fruitBasket 字典中访问的。这意味着我们不需要解包它。你仍然应该能看到打印语句显示三次。[图
    6-6](text00016.html#ch06fig6) 显示了两个循环的输出结果。
- en: '![Image](Image00151.jpg)'
  id: totrans-9786
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00151.jpg)'
- en: '*Figure 6-6: Looping through the keys and values of a dictionary with a for-in
    loop*'
  id: totrans-9787
  prefs: []
  type: TYPE_NORMAL
  zh: '*图6-6：使用 for-in 循环遍历字典的键和值*'
- en: The order of your results might be slightly different from ours. That’s because
    the items in a dictionary aren’t in a numbered order like they are in an array!
    And because the order is not guaranteed, you might see a different order printed
    if you run the same code again.
  id: totrans-9788
  prefs: []
  type: TYPE_NORMAL
  zh: 你的结果顺序可能与我们的顺序略有不同。这是因为字典中的项不像数组那样按编号顺序排列！而且由于顺序不保证，如果你再次运行相同的代码，可能会看到不同的顺序。
- en: '**WHAT YOU LEARNED**'
  id: totrans-9789
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**你学到的内容**'
- en: In this chapter, you learned how to store collections of items in an array and
    in a dictionary. To store items in an ordered list, you would use an array and
    look up each item by its index. If you wanted to store items by key instead, you
    would use a dictionary.
  id: totrans-9790
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一章中，你学会了如何在数组和字典中存储一组项。要将项存储在有序列表中，你可以使用数组并通过索引查找每个项。如果你想通过键存储项，你应该使用字典。
- en: Knowing about arrays and dictionaries and how to use them is a powerful building
    block for almost any programming language. Next we will learn about functions,
    another very powerful tool. Functions are blocks of code that you create and name
    to perform a specific job. After you have written a function, you can use its
    name to call it from almost anywhere in your program.
  id: totrans-9791
  prefs: []
  type: TYPE_NORMAL
  zh: 了解数组和字典以及如何使用它们是几乎所有编程语言中的一个强大构建模块。接下来，我们将学习函数，这是另一个非常强大的工具。函数是你创建并命名的代码块，用于执行特定的任务。在你编写了一个函数之后，你可以使用它的名称从程序中的几乎任何地方调用它。
- en: 'To create and initialize a dictionary, first write var and the name of your
    dictionary. Then write the keys and corresponding values inside a pair of square
    brackets, similar to an array. Let’s create a dictionary to store the names of
    a few US states. The key for each state will be its two-letter abbreviation:'
  id: totrans-9792
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建并初始化一个字典，首先写上 var 和字典的名称。然后将键和值放在一对方括号内，类似于数组。让我们创建一个字典来存储几个美国州的名称。每个州的键将是它的两字母缩写：
- en: '![](Image00141.jpg)'
  id: totrans-9793
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00141.jpg)'
- en: As you can see, there’s a colon between each key and its value, and the key/value
    pairs are separated by commas.
  id: totrans-9794
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，每个键和值之间有一个冒号，键值对之间用逗号分隔。
- en: Dictionaries are different from arrays in that they are *unordered* . Because
    of that, it’s likely that the order of the states that you see in your results
    pane ➋ is different from the order in which you entered your states ➊ . It might
    even be different than the order that’s printed in this book!
  id: totrans-9795
  prefs: []
  type: TYPE_NORMAL
  zh: 字典与数组不同，因为它们是*无序的*。因此，你看到的结果面板中州的顺序➋可能与输入这些州时的顺序➊不同。甚至可能与本书中打印的顺序不同！
- en: As with arrays, you can use var to make a mutable dictionary or use let to make
    an immutable dictionary.
  id: totrans-9796
  prefs: []
  type: TYPE_NORMAL
  zh: 与数组一样，你可以使用 var 来创建可变字典，或者使用 let 来创建不可变字典。
- en: 'In Swift, all of the keys of a dictionary must be the same type, and all of
    the values of a dictionary must also be the same type, but the key type doesn’t
    have to match the value type. For example, if you wanted to store a collection
    of fractions, you could use doubles for the keys and strings for the values:'
  id: totrans-9797
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Swift 中，字典的所有键必须是相同类型的，字典的所有值也必须是相同类型的，但键的类型不必与值的类型匹配。例如，如果你想存储一组分数，你可以使用双精度浮点数作为键，使用字符串作为值：
- en: '![](Image00142.jpg)'
  id: totrans-9798
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00142.jpg)'
- en: In this dictionary, all of the keys must be doubles, and all of the values must
    be strings. Again, you’ll see that the order of the numbers in the results pane
    can be quite different from the order in which you wrote the fractions in your
    dictionary. This is fine because you don’t need to know the order to access anything.
    You can find any item that you need by its key. Let’s see how!
  id: totrans-9799
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个字典中，所有的键必须是双精度浮点数，所有的值必须是字符串。同样，你会看到结果面板中的数字顺序与在字典中写入分数时的顺序可能大不相同。这是正常的，因为你不需要知道顺序就可以访问任何内容。你可以通过键来查找任何需要的项。让我们看看如何操作！
- en: '**ACCESSING VALUES IN A DICTIONARY**'
  id: totrans-9800
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**访问字典中的值**'
- en: 'Looking up a value in a dictionary is similar to how you access a value in
    an array except that you use a key inside the square brackets instead of an index,
    like this: usStates["TX"] .'
  id: totrans-9801
  prefs: []
  type: TYPE_NORMAL
  zh: 在字典中查找一个值类似于在数组中访问一个值，唯一不同的是，你在方括号中使用的是键，而不是索引，像这样：usStates["TX"]。
- en: There is a big difference, however, in how Swift returns the values from a dictionary.
    When you access a value at an index of an array, you are simply given the value.
    When you access a value with a key in a dictionary, you are given an optional.
  id: totrans-9802
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，Swift返回字典中的值与数组的不同。当你访问数组中的一个索引值时，你只是得到该值。当你使用键访问字典中的一个值时，你得到的是一个可选项。
- en: In [Chapter 5](text00015.html#ch05) , you learned that optionals might contain
    a value or might be nil . The reason Swift returns optionals when you’re looking
    up items in a dictionary is that the key you used might not exist in the dictionary,
    in which case there’s no value to access. Trying to access a value that doesn’t
    exist would give you a big fat error! To avoid that problem, Swift returns optionals.
    That means you need to unwrap any value you get out of a dictionary before you
    can do anything with it.
  id: totrans-9803
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第5章](text00015.html#ch05)中，你学到了可选项可能包含一个值，也可能是nil。Swift在查找字典中的项目时返回可选项的原因是你使用的键可能在字典中不存在，在这种情况下，就没有值可以访问。试图访问一个不存在的值会导致一个巨大的错误！为了避免这个问题，Swift返回了可选项。这意味着你需要解包从字典中取出的任何值，才能对其进行操作。
- en: 'To unwrap an optional, first you check whether it exists using an if-let statement,
    just like we did in [Chapter 5](text00015.html#ch05) . The following code shows
    you how to get a value out of a dictionary:'
  id: totrans-9804
  prefs: []
  type: TYPE_NORMAL
  zh: 要解包一个可选项，首先使用 if-let 语句检查它是否存在，就像我们在[第5章](text00015.html#ch05)中做的那样。以下代码展示了如何从字典中取出一个值：
- en: '![Image](Image00143.jpg)'
  id: totrans-9805
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00143.jpg)'
- en: To retrieve "Texas" from the dictionary, we use if let to set a constant loneStarState
    to usStates["TX"] ➊ . Because we have this state in our dictionary, the line I
    have Texas in my dictionary. is printed. Next we try to access a state that is
    not in our dictionary by using the key usStates["FL"] ➋ . Thankfully, because
    we used an if-let statement, the program won’t crash when the computer can’t find
    this state. Instead, I don't have that state in my dictionary. is printed.
  id: totrans-9806
  prefs: []
  type: TYPE_NORMAL
  zh: 要从字典中检索 "Texas"，我们使用 if let 语句将常量 loneStarState 设置为 usStates["TX"] ➊。由于我们在字典中有这个州，所以会打印
    "I have Texas in my dictionary"。接下来，我们尝试使用键 usStates["FL"] ➋ 访问一个不在字典中的州。幸运的是，由于我们使用了
    if-let 语句，当计算机找不到这个州时，程序不会崩溃。相反，打印的是 "I don't have that state in my dictionary"。
- en: '**ADDING ITEMS TO A DICTIONARY**'
  id: totrans-9807
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**向字典中添加项目**'
- en: 'To add an item to a dictionary, first write the name of your dictionary and
    assign the new item to the key you want it to have in the dictionary. Let’s add
    "Minnesota" to our usStates dictionary:'
  id: totrans-9808
  prefs: []
  type: TYPE_NORMAL
  zh: 要向字典中添加一个项目，首先写出字典的名称，并将新项目分配给你希望它在字典中拥有的键。让我们将 "Minnesota" 添加到我们的 usStates
    字典中：
- en: '![](Image00144.jpg)'
  id: totrans-9809
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00144.jpg)'
- en: 'Now when you look at usStates , you’ll see that it’s updated to ["MN": "Minnesota",
    "WA": "Washington", "MA": "Massachusetts", "TX": "Texas"] . Remember, because
    you don’t have to rely on indices, your new dictionary item might appear anywhere
    in the dictionary.'
  id: totrans-9810
  prefs: []
  type: TYPE_NORMAL
  zh: '现在，当你查看 usStates 时，你会看到它已更新为 ["MN": "Minnesota", "WA": "Washington", "MA":
    "Massachusetts", "TX": "Texas"]。记住，因为你不需要依赖索引，所以你的新字典项可能会出现在字典中的任何位置。'
- en: '**REMOVING ITEMS FROM A DICTIONARY**'
  id: totrans-9811
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**从字典中移除项目**'
- en: Removing an item from a dictionary is quite simple; you do so by setting the
    value to nil . Because the values in dictionaries are returned as optionals, you
    don’t have to worry about nil causing any problems in your dictionary.
  id: totrans-9812
  prefs: []
  type: TYPE_NORMAL
  zh: 从字典中移除项目非常简单；你只需将该值设置为nil即可。因为字典中的值是作为可选项返回的，所以你不必担心nil会在字典中引发任何问题。
- en: '![](Image00145.jpg)'
  id: totrans-9813
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00145.jpg)'
- en: 'You can see that after you remove the value at the key "MA" , usStates is updated
    to ["MN": "Minnesota", "WA": "Washington", "TX": "Texas"] . Remember that nil
    is special and means that there’s no value at all. That’s why you don’t see "MA":
    nil in our dictionary.'
  id: totrans-9814
  prefs: []
  type: TYPE_NORMAL
  zh: '你可以看到，在移除键 "MA" 对应的值后，usStates 被更新为 ["MN": "Minnesota", "WA": "Washington",
    "TX": "Texas"]。记住，nil 是特别的，表示没有值。这就是为什么你在字典中看不到 "MA": nil 的原因。'
- en: '**REPLACING ITEMS IN A DICTIONARY**'
  id: totrans-9815
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**替换字典中的项目**'
- en: 'Replacing an item in a dictionary is also easy. It works the same was as replacing
    an item in an array. You just set the item that you want to replace to something
    else. Say you create a dictionary of fruit colors:'
  id: totrans-9816
  prefs: []
  type: TYPE_NORMAL
  zh: 替换字典中的项目也很简单。它的工作原理与替换数组中的项目相同。你只需将你想要替换的项目设置为其他内容。例如，你可以创建一个水果颜色的字典：
- en: '![](Image00146.jpg)'
  id: totrans-9817
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00146.jpg)'
- en: At first we had the value "apple" for "red" , but then we decided that "raspberry"
    is a better fruit to use since sometimes apples are green or yellow. To replace
    "apple" with "raspberry" , we set colorFruits["red"] to its new value ➊ .
  id: totrans-9818
  prefs: []
  type: TYPE_NORMAL
  zh: 起初我们为 "red" 设置了值 "apple"，但后来我们决定 "raspberry" 是更好的水果选择，因为有时苹果是绿色或黄色的。为了将 "apple"
    替换为 "raspberry"，我们将 `colorFruits["red"]` 设置为其新值 ➊。
- en: You may remember that this is the same way we entered a new value into a dictionary.
    If the key already exists in the dictionary, then the value for that key is replaced.
    If the key doesn’t already exist, then the new key/value pair will be added to
    the dictionary.
  id: totrans-9819
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能记得，这与我们将新值输入字典的方式相同。如果键已经存在于字典中，那么该键的值会被替换。如果该键不存在，则新的键值对会被添加到字典中。
- en: '![Image](Image00147.jpg)'
  id: totrans-9820
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00147.jpg)'
- en: '**USING DICTIONARY PROPERTIES**'
  id: totrans-9821
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**使用字典属性**'
- en: 'Like an array, a dictionary also has an isEmpty property and a count property.
    For example, the following code shows how you can use the isEmpty property to
    check if a dictionary is empty, and if it isn’t empty, the count property checks
    how many items you have. Imagine you have a basket of fruit for sale. You can
    use these properties to help you keep track of everything:'
  id: totrans-9822
  prefs: []
  type: TYPE_NORMAL
  zh: 像数组一样，字典也有一个 `isEmpty` 属性和一个 `count` 属性。例如，以下代码展示了如何使用 `isEmpty` 属性来检查字典是否为空，如果字典不为空，`count`
    属性则用来检查字典中有多少项。想象一下你有一个待售的水果篮。你可以使用这些属性帮助你追踪所有内容：
- en: '![Image](Image00148.jpg)'
  id: totrans-9823
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00148.jpg)'
- en: 'A dictionary also has two special properties: keys , which contains all of
    the dictionary’s keys, and values , which contains all of its values. We’ll use
    these two properties when we loop through the dictionary.'
  id: totrans-9824
  prefs: []
  type: TYPE_NORMAL
  zh: 字典还有两个特殊的属性：`keys`，它包含字典的所有键，和 `values`，它包含所有的值。我们将在遍历字典时使用这两个属性。
- en: Let’s write some code that loops through our fruit baskets and prints the price
    of each fruit.
  id: totrans-9825
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们写一些代码，遍历我们的水果篮并打印每种水果的价格。
- en: '**LOOPING OVER A DICTIONARY**'
  id: totrans-9826
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**遍历字典**'
- en: 'You can loop through a dictionary using a for-in loop. Because each item has
    a key and a value, you can do this in two different ways. This is how to loop
    through a dictionary using its keys:'
  id: totrans-9827
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用 `for-in` 循环遍历字典。因为每一项都有一个键和一个值，所以你可以用两种不同的方式来遍历字典。以下是使用字典的键来遍历字典的方法：
- en: '![Image](Image00149.jpg)'
  id: totrans-9828
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00149.jpg)'
- en: Here we use the dictionary’s keys property ➊ to loop through fruitBasket and
    print its contents. We start by writing the keyword for , followed by a constant
    name fruit for the dictionary key, the keyword in , the dictionary name, a period,
    and keys .
  id: totrans-9829
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们使用字典的 `keys` 属性 ➊ 来遍历 `fruitBasket` 并打印其内容。我们首先写下 `for` 关键字，接着是常量名称 `fruit`，表示字典的键，后面跟着
    `in` 关键字，字典的名称，一个句点，以及 `keys`。
- en: Inside the braces of our for-in loop, we have access to both the key, which
    we call fruit ➋ , and the value at that key when we force-unwrap its contents
    with fruitBasket[fruit]! ➌ . That value will be the fruit’s price.
  id: totrans-9830
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `for-in` 循环的花括号内，我们可以访问键（我们称之为 `fruit` ➋）和该键的值，通过强制解包其内容 `fruitBasket[fruit]!`
    ➌。这个值就是水果的价格。
- en: In this case, it’s safe to force-unwrap the value using an exclamation point
    because we know that the fruit key we’re using is definitely inside the dictionary.
  id: totrans-9831
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，可以安全地使用感叹号强制解包值，因为我们知道我们使用的 `fruit` 键一定在字典中。
- en: Any code we put inside the for-in loop will run once for every key in our dictionary.
    So you should see the print statement display three times.
  id: totrans-9832
  prefs: []
  type: TYPE_NORMAL
  zh: 我们放在 `for-in` 循环中的任何代码将会为字典中的每个键执行一次。所以你应该看到打印语句显示三次。
- en: 'We can also loop through the dictionary using its values property:'
  id: totrans-9833
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以通过字典的 `values` 属性来遍历字典：
- en: '![Image](Image00150.jpg)'
  id: totrans-9834
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00150.jpg)'
- en: We use the same style of for-in loop, but now we use a constant to refer to
    each value, which we call price , in the values property. When looping through
    values, we don’t have access to the keys from inside the loop.
  id: totrans-9835
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用相同风格的 `for-in` 循环，但现在我们使用常量来引用 `values` 属性中的每个值，我们称之为 `price`。当遍历 `values`
    时，我们无法从循环内访问键。
- en: Another difference to note is that price is not an optional because it’s accessed
    directly as a value in the fruitBasket dictionary. That means we don’t have to
    unwrap it. You should still see the print statement printed three times. [Figure
    6-6](text00016.html#ch06fig6) shows the output of both loops.
  id: totrans-9836
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个需要注意的区别是，`price` 不是可选的，因为它是直接作为 `fruitBasket` 字典中的值访问的。这意味着我们不需要解包它。你应该仍然能看到打印语句显示三次。[图
    6-6](text00016.html#ch06fig6) 显示了两个循环的输出。
- en: '![Image](Image00151.jpg)'
  id: totrans-9837
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00151.jpg)'
- en: '*Figure 6-6: Looping through the keys and values of a dictionary with a for-in
    loop*'
  id: totrans-9838
  prefs: []
  type: TYPE_NORMAL
  zh: '*图6-6：使用for-in循环遍历字典的键和值*'
- en: The order of your results might be slightly different from ours. That’s because
    the items in a dictionary aren’t in a numbered order like they are in an array!
    And because the order is not guaranteed, you might see a different order printed
    if you run the same code again.
  id: totrans-9839
  prefs: []
  type: TYPE_NORMAL
  zh: 你的结果顺序可能与我们的略有不同。这是因为字典中的项不像数组那样是按编号顺序排列的！由于顺序没有保证，如果你再次运行相同的代码，可能会看到不同的顺序。
- en: '**WHAT YOU LEARNED**'
  id: totrans-9840
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**你学到了什么**'
- en: In this chapter, you learned how to store collections of items in an array and
    in a dictionary. To store items in an ordered list, you would use an array and
    look up each item by its index. If you wanted to store items by key instead, you
    would use a dictionary.
  id: totrans-9841
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你学习了如何将多个项存储在数组和字典中。要将项存储在有序列表中，你会使用数组，并通过索引查找每个项。如果你想按键存储项，则应使用字典。
- en: Knowing about arrays and dictionaries and how to use them is a powerful building
    block for almost any programming language. Next we will learn about functions,
    another very powerful tool. Functions are blocks of code that you create and name
    to perform a specific job. After you have written a function, you can use its
    name to call it from almost anywhere in your program.
  id: totrans-9842
  prefs: []
  type: TYPE_NORMAL
  zh: 了解数组和字典及其用法是几乎所有编程语言中的一个强大构建块。接下来我们将学习函数，另一个非常强大的工具。函数是你创建并命名的一段代码，用于执行特定任务。写完函数后，你可以通过它的名称从程序中的几乎任何地方调用它。
- en: '![](Image00141.jpg)'
  id: totrans-9843
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00141.jpg)'
- en: As you can see, there’s a colon between each key and its value, and the key/value
    pairs are separated by commas.
  id: totrans-9844
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，每个键和值之间有一个冒号，键/值对之间用逗号分隔。
- en: Dictionaries are different from arrays in that they are *unordered* . Because
    of that, it’s likely that the order of the states that you see in your results
    pane ➋ is different from the order in which you entered your states ➊ . It might
    even be different than the order that’s printed in this book!
  id: totrans-9845
  prefs: []
  type: TYPE_NORMAL
  zh: 字典不同于数组，因为它们是*无序的*。因此，你在结果面板中看到的州的顺序➋很可能与输入的顺序➊不同。甚至可能与书中列出的顺序不同！
- en: As with arrays, you can use var to make a mutable dictionary or use let to make
    an immutable dictionary.
  id: totrans-9846
  prefs: []
  type: TYPE_NORMAL
  zh: 和数组一样，你可以使用var来创建可变字典，或使用let来创建不可变字典。
- en: 'In Swift, all of the keys of a dictionary must be the same type, and all of
    the values of a dictionary must also be the same type, but the key type doesn’t
    have to match the value type. For example, if you wanted to store a collection
    of fractions, you could use doubles for the keys and strings for the values:'
  id: totrans-9847
  prefs: []
  type: TYPE_NORMAL
  zh: 在Swift中，字典的所有键必须是相同类型的，字典的所有值也必须是相同类型的，但键类型不需要与值类型匹配。例如，如果你想存储一个分数集合，你可以使用双精度浮点数作为键，字符串作为值：
- en: '![](Image00142.jpg)'
  id: totrans-9848
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00142.jpg)'
- en: In this dictionary, all of the keys must be doubles, and all of the values must
    be strings. Again, you’ll see that the order of the numbers in the results pane
    can be quite different from the order in which you wrote the fractions in your
    dictionary. This is fine because you don’t need to know the order to access anything.
    You can find any item that you need by its key. Let’s see how!
  id: totrans-9849
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个字典中，所有的键必须是双精度浮点数，所有的值必须是字符串。再一次，你会看到结果面板中数字的顺序可能与在字典中书写分数的顺序有很大的不同。这没关系，因为你不需要知道顺序就能访问任何内容。你可以通过键找到你需要的任何项。让我们来看看如何做到！
- en: '**ACCESSING VALUES IN A DICTIONARY**'
  id: totrans-9850
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**访问字典中的值**'
- en: 'Looking up a value in a dictionary is similar to how you access a value in
    an array except that you use a key inside the square brackets instead of an index,
    like this: usStates["TX"] .'
  id: totrans-9851
  prefs: []
  type: TYPE_NORMAL
  zh: 在字典中查找值类似于在数组中访问值，区别在于你使用的是键而不是索引，像这样：usStates["TX"]。
- en: There is a big difference, however, in how Swift returns the values from a dictionary.
    When you access a value at an index of an array, you are simply given the value.
    When you access a value with a key in a dictionary, you are given an optional.
  id: totrans-9852
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，Swift从字典中返回值的方式有一个显著的区别。当你访问数组中的一个索引值时，你直接得到这个值。当你用一个键访问字典中的值时，你得到的是一个可选值。
- en: In [Chapter 5](text00015.html#ch05) , you learned that optionals might contain
    a value or might be nil . The reason Swift returns optionals when you’re looking
    up items in a dictionary is that the key you used might not exist in the dictionary,
    in which case there’s no value to access. Trying to access a value that doesn’t
    exist would give you a big fat error! To avoid that problem, Swift returns optionals.
    That means you need to unwrap any value you get out of a dictionary before you
    can do anything with it.
  id: totrans-9853
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第5章](text00015.html#ch05)中，你学到可选值可能包含一个值，也可能是 nil。Swift 返回可选值的原因是在字典中查找项时，使用的键可能在字典中不存在，这种情况下就没有可访问的值。尝试访问一个不存在的值会导致错误！为了避免这个问题，Swift
    返回了可选值。这意味着你需要解包从字典中获取的任何值，才能对其进行操作。
- en: 'To unwrap an optional, first you check whether it exists using an if-let statement,
    just like we did in [Chapter 5](text00015.html#ch05) . The following code shows
    you how to get a value out of a dictionary:'
  id: totrans-9854
  prefs: []
  type: TYPE_NORMAL
  zh: 要解包一个可选值，首先通过 if-let 语句检查它是否存在，就像我们在[第5章](text00015.html#ch05)中做的那样。以下代码展示了如何从字典中获取一个值：
- en: '![Image](Image00143.jpg)'
  id: totrans-9855
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00143.jpg)'
- en: To retrieve "Texas" from the dictionary, we use if let to set a constant loneStarState
    to usStates["TX"] ➊ . Because we have this state in our dictionary, the line I
    have Texas in my dictionary. is printed. Next we try to access a state that is
    not in our dictionary by using the key usStates["FL"] ➋ . Thankfully, because
    we used an if-let statement, the program won’t crash when the computer can’t find
    this state. Instead, I don't have that state in my dictionary. is printed.
  id: totrans-9856
  prefs: []
  type: TYPE_NORMAL
  zh: 要从字典中获取“Texas”，我们使用 if let 将常量 loneStarState 设置为 usStates["TX"] ➊。由于我们在字典中有这个州，因此会打印出“我在字典中找到了
    Texas”。接下来，我们尝试访问一个在字典中不存在的州，通过使用键 usStates["FL"] ➋。幸运的是，由于我们使用了 if-let 语句，当计算机找不到该州时，程序不会崩溃。相反，会打印出“我在字典中没有这个州”。
- en: '**ADDING ITEMS TO A DICTIONARY**'
  id: totrans-9857
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**向字典中添加项**'
- en: 'To add an item to a dictionary, first write the name of your dictionary and
    assign the new item to the key you want it to have in the dictionary. Let’s add
    "Minnesota" to our usStates dictionary:'
  id: totrans-9858
  prefs: []
  type: TYPE_NORMAL
  zh: 要向字典中添加一项，首先写下字典的名称，并将新项赋给你希望它在字典中拥有的键。让我们把“Minnesota”添加到我们的 usStates 字典中：
- en: '![](Image00144.jpg)'
  id: totrans-9859
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00144.jpg)'
- en: 'Now when you look at usStates , you’ll see that it’s updated to ["MN": "Minnesota",
    "WA": "Washington", "MA": "Massachusetts", "TX": "Texas"] . Remember, because
    you don’t have to rely on indices, your new dictionary item might appear anywhere
    in the dictionary.'
  id: totrans-9860
  prefs: []
  type: TYPE_NORMAL
  zh: '现在当你查看 usStates 时，你会看到它已更新为 ["MN": "Minnesota", "WA": "Washington", "MA": "Massachusetts",
    "TX": "Texas"]。记住，由于你不必依赖索引，因此新的字典项可能出现在字典中的任何位置。'
- en: '**REMOVING ITEMS FROM A DICTIONARY**'
  id: totrans-9861
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**从字典中移除项**'
- en: Removing an item from a dictionary is quite simple; you do so by setting the
    value to nil . Because the values in dictionaries are returned as optionals, you
    don’t have to worry about nil causing any problems in your dictionary.
  id: totrans-9862
  prefs: []
  type: TYPE_NORMAL
  zh: 从字典中移除一个项非常简单；你只需要将其值设置为 nil。由于字典中的值是以可选值的形式返回的，因此你不需要担心 nil 会在字典中造成任何问题。
- en: '![](Image00145.jpg)'
  id: totrans-9863
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00145.jpg)'
- en: 'You can see that after you remove the value at the key "MA" , usStates is updated
    to ["MN": "Minnesota", "WA": "Washington", "TX": "Texas"] . Remember that nil
    is special and means that there’s no value at all. That’s why you don’t see "MA":
    nil in our dictionary.'
  id: totrans-9864
  prefs: []
  type: TYPE_NORMAL
  zh: '你可以看到，在移除键“MA”对应的值后，usStates 更新为 ["MN": "Minnesota", "WA": "Washington", "TX":
    "Texas"]。记住，nil 是特殊的，表示没有任何值。这就是为什么你在字典中看不到 "MA": nil。'
- en: '**REPLACING ITEMS IN A DICTIONARY**'
  id: totrans-9865
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**替换字典中的项**'
- en: 'Replacing an item in a dictionary is also easy. It works the same was as replacing
    an item in an array. You just set the item that you want to replace to something
    else. Say you create a dictionary of fruit colors:'
  id: totrans-9866
  prefs: []
  type: TYPE_NORMAL
  zh: 在字典中替换一项也很简单。它的工作方式与替换数组中的项相同。你只需要将你想替换的项设置为其他值。例如，假设你创建了一个水果颜色的字典：
- en: '![](Image00146.jpg)'
  id: totrans-9867
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00146.jpg)'
- en: At first we had the value "apple" for "red" , but then we decided that "raspberry"
    is a better fruit to use since sometimes apples are green or yellow. To replace
    "apple" with "raspberry" , we set colorFruits["red"] to its new value ➊ .
  id: totrans-9868
  prefs: []
  type: TYPE_NORMAL
  zh: 最开始我们将值“apple”赋给“red”，但是后来我们决定使用“raspberry”，因为有时苹果是绿色或黄色的。为了将“apple”替换为“raspberry”，我们将
    colorFruits["red"] 设置为其新值 ➊。
- en: You may remember that this is the same way we entered a new value into a dictionary.
    If the key already exists in the dictionary, then the value for that key is replaced.
    If the key doesn’t already exist, then the new key/value pair will be added to
    the dictionary.
  id: totrans-9869
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能还记得，这是我们向字典中输入新值的相同方式。如果键已经存在于字典中，那么该键的值会被替换。如果该键尚不存在，则新键/值对将被添加到字典中。
- en: '![Image](Image00147.jpg)'
  id: totrans-9870
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00147.jpg)'
- en: '**USING DICTIONARY PROPERTIES**'
  id: totrans-9871
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**使用字典属性**'
- en: 'Like an array, a dictionary also has an isEmpty property and a count property.
    For example, the following code shows how you can use the isEmpty property to
    check if a dictionary is empty, and if it isn’t empty, the count property checks
    how many items you have. Imagine you have a basket of fruit for sale. You can
    use these properties to help you keep track of everything:'
  id: totrans-9872
  prefs: []
  type: TYPE_NORMAL
  zh: 和数组一样，字典也有 isEmpty 属性和 count 属性。例如，以下代码展示了如何使用 isEmpty 属性来检查字典是否为空，如果不为空，count
    属性则检查字典中有多少项。假设你有一个水果篮在售，你可以使用这些属性帮助你跟踪一切：
- en: '![Image](Image00148.jpg)'
  id: totrans-9873
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00148.jpg)'
- en: 'A dictionary also has two special properties: keys , which contains all of
    the dictionary’s keys, and values , which contains all of its values. We’ll use
    these two properties when we loop through the dictionary.'
  id: totrans-9874
  prefs: []
  type: TYPE_NORMAL
  zh: 字典还有两个特殊属性：keys，包含字典的所有键，以及 values，包含字典的所有值。在遍历字典时，我们将使用这两个属性。
- en: Let’s write some code that loops through our fruit baskets and prints the price
    of each fruit.
  id: totrans-9875
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们编写一些代码，遍历我们的水果篮并打印每种水果的价格。
- en: '**LOOPING OVER A DICTIONARY**'
  id: totrans-9876
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**遍历字典**'
- en: 'You can loop through a dictionary using a for-in loop. Because each item has
    a key and a value, you can do this in two different ways. This is how to loop
    through a dictionary using its keys:'
  id: totrans-9877
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用 for-in 循环遍历字典。因为每个项都有一个键和值，你可以通过两种方式来实现这一点。下面是使用键遍历字典的方式：
- en: '![Image](Image00149.jpg)'
  id: totrans-9878
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00149.jpg)'
- en: Here we use the dictionary’s keys property ➊ to loop through fruitBasket and
    print its contents. We start by writing the keyword for , followed by a constant
    name fruit for the dictionary key, the keyword in , the dictionary name, a period,
    and keys .
  id: totrans-9879
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们使用字典的 keys 属性 ➊ 来遍历 fruitBasket 并打印其内容。我们首先编写关键字 for，然后是常量名称 fruit 作为字典键，关键字
    in，字典名称，点，最后是 keys。
- en: Inside the braces of our for-in loop, we have access to both the key, which
    we call fruit ➋ , and the value at that key when we force-unwrap its contents
    with fruitBasket[fruit]! ➌ . That value will be the fruit’s price.
  id: totrans-9880
  prefs: []
  type: TYPE_NORMAL
  zh: 在 for-in 循环的大括号内部，我们可以访问到键，称之为 fruit ➋，以及通过 fruitBasket[fruit]! ➌ 强制解包其内容后获取的值。该值将是水果的价格。
- en: In this case, it’s safe to force-unwrap the value using an exclamation point
    because we know that the fruit key we’re using is definitely inside the dictionary.
  id: totrans-9881
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，使用感叹号强制解包值是安全的，因为我们知道我们使用的水果键肯定在字典中。
- en: Any code we put inside the for-in loop will run once for every key in our dictionary.
    So you should see the print statement display three times.
  id: totrans-9882
  prefs: []
  type: TYPE_NORMAL
  zh: 我们放入 for-in 循环中的任何代码都会针对字典中的每个键执行一次。所以你应该看到打印语句会显示三次。
- en: 'We can also loop through the dictionary using its values property:'
  id: totrans-9883
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以使用字典的 values 属性进行循环：
- en: '![Image](Image00150.jpg)'
  id: totrans-9884
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00150.jpg)'
- en: We use the same style of for-in loop, but now we use a constant to refer to
    each value, which we call price , in the values property. When looping through
    values, we don’t have access to the keys from inside the loop.
  id: totrans-9885
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用相同的 for-in 循环样式，但现在我们使用常量来引用 values 属性中的每个值，我们称之为 price。在循环值时，我们无法从循环内部访问到键。
- en: Another difference to note is that price is not an optional because it’s accessed
    directly as a value in the fruitBasket dictionary. That means we don’t have to
    unwrap it. You should still see the print statement printed three times. [Figure
    6-6](text00016.html#ch06fig6) shows the output of both loops.
  id: totrans-9886
  prefs: []
  type: TYPE_NORMAL
  zh: 需要注意的另一个不同之处是，price 不是一个可选类型，因为它是直接作为水果篮字典中的值来访问的。这意味着我们不需要解包它。你仍然应该看到打印语句会显示三次。[图
    6-6](text00016.html#ch06fig6) 显示了两种循环的输出。
- en: '![Image](Image00151.jpg)'
  id: totrans-9887
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00151.jpg)'
- en: '*Figure 6-6: Looping through the keys and values of a dictionary with a for-in
    loop*'
  id: totrans-9888
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 6-6：使用 for-in 循环遍历字典的键和值*'
- en: The order of your results might be slightly different from ours. That’s because
    the items in a dictionary aren’t in a numbered order like they are in an array!
    And because the order is not guaranteed, you might see a different order printed
    if you run the same code again.
  id: totrans-9889
  prefs: []
  type: TYPE_NORMAL
  zh: 你的结果顺序可能与我们的略有不同。这是因为字典中的项目不像数组那样按数字顺序排列！由于顺序不保证，如果你再次运行相同的代码，可能会看到不同的顺序。
- en: '**WHAT YOU LEARNED**'
  id: totrans-9890
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**你学到了什么**'
- en: In this chapter, you learned how to store collections of items in an array and
    in a dictionary. To store items in an ordered list, you would use an array and
    look up each item by its index. If you wanted to store items by key instead, you
    would use a dictionary.
  id: totrans-9891
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你学会了如何在数组和字典中存储项目。要将项目存储在有序列表中，你应该使用数组并通过索引查找每个项目。如果你想通过键存储项目，则应该使用字典。
- en: Knowing about arrays and dictionaries and how to use them is a powerful building
    block for almost any programming language. Next we will learn about functions,
    another very powerful tool. Functions are blocks of code that you create and name
    to perform a specific job. After you have written a function, you can use its
    name to call it from almost anywhere in your program.
  id: totrans-9892
  prefs: []
  type: TYPE_NORMAL
  zh: 了解数组和字典及其使用方法是几乎所有编程语言中的一个强大构建模块。接下来，我们将学习函数，另一个非常强大的工具。函数是你创建并命名的一段代码，用于执行特定任务。编写了一个函数后，你可以通过它的名字在程序中的几乎任何地方调用它。
- en: As you can see, there’s a colon between each key and its value, and the key/value
    pairs are separated by commas.
  id: totrans-9893
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，每个键和它的值之间都有一个冒号，键值对之间用逗号分隔。
- en: Dictionaries are different from arrays in that they are *unordered* . Because
    of that, it’s likely that the order of the states that you see in your results
    pane ➋ is different from the order in which you entered your states ➊ . It might
    even be different than the order that’s printed in this book!
  id: totrans-9894
  prefs: []
  type: TYPE_NORMAL
  zh: 字典与数组的不同之处在于它们是*无序的*。因此，你在结果窗格中看到的状态顺序 ➋ 可能与输入状态的顺序 ➊ 不同。它甚至可能与本书中打印的顺序不同！
- en: As with arrays, you can use var to make a mutable dictionary or use let to make
    an immutable dictionary.
  id: totrans-9895
  prefs: []
  type: TYPE_NORMAL
  zh: 和数组一样，你可以使用 `var` 来创建一个可变字典，或者使用 `let` 来创建一个不可变字典。
- en: 'In Swift, all of the keys of a dictionary must be the same type, and all of
    the values of a dictionary must also be the same type, but the key type doesn’t
    have to match the value type. For example, if you wanted to store a collection
    of fractions, you could use doubles for the keys and strings for the values:'
  id: totrans-9896
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Swift 中，字典的所有键必须是相同的类型，字典的所有值也必须是相同的类型，但键的类型不需要与值的类型匹配。例如，如果你想存储一个分数的集合，你可以将键定义为
    `double` 类型，值定义为 `string` 类型：
- en: '![](Image00142.jpg)'
  id: totrans-9897
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00142.jpg)'
- en: In this dictionary, all of the keys must be doubles, and all of the values must
    be strings. Again, you’ll see that the order of the numbers in the results pane
    can be quite different from the order in which you wrote the fractions in your
    dictionary. This is fine because you don’t need to know the order to access anything.
    You can find any item that you need by its key. Let’s see how!
  id: totrans-9898
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个字典中，所有键必须是 `double` 类型，所有值必须是 `string` 类型。同样，你会发现结果窗格中数字的顺序可能与在字典中编写分数的顺序大不相同。这没问题，因为你无需知道顺序就能访问任何内容。你可以通过键找到你需要的任何项目。让我们来看一下！
- en: '**ACCESSING VALUES IN A DICTIONARY**'
  id: totrans-9899
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**在字典中访问值**'
- en: 'Looking up a value in a dictionary is similar to how you access a value in
    an array except that you use a key inside the square brackets instead of an index,
    like this: usStates["TX"] .'
  id: totrans-9900
  prefs: []
  type: TYPE_NORMAL
  zh: 在字典中查找一个值类似于在数组中访问一个值，唯一的区别是你需要在方括号中使用键，而不是索引，像这样：usStates["TX"]。
- en: There is a big difference, however, in how Swift returns the values from a dictionary.
    When you access a value at an index of an array, you are simply given the value.
    When you access a value with a key in a dictionary, you are given an optional.
  id: totrans-9901
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，Swift 在从字典返回值的方式上有很大的不同。当你在数组的索引位置访问一个值时，你会直接得到该值。而在字典中通过键访问值时，你会得到一个可选值。
- en: In [Chapter 5](text00015.html#ch05) , you learned that optionals might contain
    a value or might be nil . The reason Swift returns optionals when you’re looking
    up items in a dictionary is that the key you used might not exist in the dictionary,
    in which case there’s no value to access. Trying to access a value that doesn’t
    exist would give you a big fat error! To avoid that problem, Swift returns optionals.
    That means you need to unwrap any value you get out of a dictionary before you
    can do anything with it.
  id: totrans-9902
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第5章](text00015.html#ch05)中，你学习了可选值可能包含一个值，也可能是 nil。Swift 在查找字典中的项目时返回可选值的原因是，你使用的键可能在字典中不存在，在这种情况下就没有值可访问。尝试访问一个不存在的值会导致一个大错误！为了避免这个问题，Swift
    返回了可选值。这意味着你在对字典中的任何值进行操作之前，都需要先解包它。
- en: 'To unwrap an optional, first you check whether it exists using an if-let statement,
    just like we did in [Chapter 5](text00015.html#ch05) . The following code shows
    you how to get a value out of a dictionary:'
  id: totrans-9903
  prefs: []
  type: TYPE_NORMAL
  zh: 要解包一个可选值，首先使用 if-let 语句检查它是否存在，就像我们在[第5章](text00015.html#ch05)中做的那样。以下代码演示了如何从字典中获取值：
- en: '![Image](Image00143.jpg)'
  id: totrans-9904
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Image00143.jpg)'
- en: To retrieve "Texas" from the dictionary, we use if let to set a constant loneStarState
    to usStates["TX"] ➊ . Because we have this state in our dictionary, the line I
    have Texas in my dictionary. is printed. Next we try to access a state that is
    not in our dictionary by using the key usStates["FL"] ➋ . Thankfully, because
    we used an if-let statement, the program won’t crash when the computer can’t find
    this state. Instead, I don't have that state in my dictionary. is printed.
  id: totrans-9905
  prefs: []
  type: TYPE_NORMAL
  zh: 要从字典中获取 "Texas" 的值，我们使用 if let 将常量 loneStarState 设置为 usStates["TX"] ➊。由于我们在字典中有这个州，输出
    "I have Texas in my dictionary."。接下来，我们尝试访问字典中没有的州，使用键 usStates["FL"] ➋。幸运的是，因为我们使用了
    if-let 语句，当计算机找不到这个州时，程序不会崩溃。相反，输出 "I don't have that state in my dictionary."。
- en: '**ADDING ITEMS TO A DICTIONARY**'
  id: totrans-9906
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**向字典中添加项目**'
- en: 'To add an item to a dictionary, first write the name of your dictionary and
    assign the new item to the key you want it to have in the dictionary. Let’s add
    "Minnesota" to our usStates dictionary:'
  id: totrans-9907
  prefs: []
  type: TYPE_NORMAL
  zh: 要向字典中添加项目，首先写出字典的名称，并将新项目分配给你希望它在字典中具有的键。让我们将 "Minnesota" 添加到我们的 usStates 字典中：
- en: '![](Image00144.jpg)'
  id: totrans-9908
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00144.jpg)'
- en: 'Now when you look at usStates , you’ll see that it’s updated to ["MN": "Minnesota",
    "WA": "Washington", "MA": "Massachusetts", "TX": "Texas"] . Remember, because
    you don’t have to rely on indices, your new dictionary item might appear anywhere
    in the dictionary.'
  id: totrans-9909
  prefs: []
  type: TYPE_NORMAL
  zh: '现在，当你查看 usStates 时，你会看到它已更新为 ["MN": "Minnesota", "WA": "Washington", "MA":
    "Massachusetts", "TX": "Texas"]。记住，由于你不必依赖索引，你的新字典项目可能会出现在字典的任何位置。'
- en: '**REMOVING ITEMS FROM A DICTIONARY**'
  id: totrans-9910
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**从字典中移除项目**'
- en: Removing an item from a dictionary is quite simple; you do so by setting the
    value to nil . Because the values in dictionaries are returned as optionals, you
    don’t have to worry about nil causing any problems in your dictionary.
  id: totrans-9911
  prefs: []
  type: TYPE_NORMAL
  zh: 从字典中移除项目非常简单；你只需将值设置为 nil。由于字典中的值是作为可选值返回的，因此你不必担心 nil 会在字典中引发问题。
- en: '![](Image00145.jpg)'
  id: totrans-9912
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00145.jpg)'
- en: 'You can see that after you remove the value at the key "MA" , usStates is updated
    to ["MN": "Minnesota", "WA": "Washington", "TX": "Texas"] . Remember that nil
    is special and means that there’s no value at all. That’s why you don’t see "MA":
    nil in our dictionary.'
  id: totrans-9913
  prefs: []
  type: TYPE_NORMAL
  zh: '你可以看到，在移除键 "MA" 对应的值后，usStates 被更新为 ["MN": "Minnesota", "WA": "Washington",
    "TX": "Texas"]。记住，nil 是特殊的，意味着根本没有值。这就是为什么你在字典中看不到 "MA": nil 的原因。'
- en: '**REPLACING ITEMS IN A DICTIONARY**'
  id: totrans-9914
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**替换字典中的项目**'
- en: 'Replacing an item in a dictionary is also easy. It works the same was as replacing
    an item in an array. You just set the item that you want to replace to something
    else. Say you create a dictionary of fruit colors:'
  id: totrans-9915
  prefs: []
  type: TYPE_NORMAL
  zh: 替换字典中的项目也很简单。它的工作方式与替换数组中的项目相同。你只需将要替换的项目设置为其他值。比如你创建了一个水果颜色的字典：
- en: '![](Image00146.jpg)'
  id: totrans-9916
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00146.jpg)'
- en: At first we had the value "apple" for "red" , but then we decided that "raspberry"
    is a better fruit to use since sometimes apples are green or yellow. To replace
    "apple" with "raspberry" , we set colorFruits["red"] to its new value ➊ .
  id: totrans-9917
  prefs: []
  type: TYPE_NORMAL
  zh: 一开始，我们为 "red" 设置了值 "apple"，但后来我们决定 "raspberry" 是一个更好的水果，因为有时候苹果是绿色或黄色的。为了将 "apple"
    替换为 "raspberry"，我们将 colorFruits["red"] 设置为它的新值 ➊。
- en: You may remember that this is the same way we entered a new value into a dictionary.
    If the key already exists in the dictionary, then the value for that key is replaced.
    If the key doesn’t already exist, then the new key/value pair will be added to
    the dictionary.
  id: totrans-9918
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能还记得，这和我们将新值插入字典的方式是一样的。如果字典中已经存在该键，那么该键的值将被替换。如果该键不存在，那么新的键/值对将被添加到字典中。
- en: '![Image](Image00147.jpg)'
  id: totrans-9919
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00147.jpg)'
- en: '**USING DICTIONARY PROPERTIES**'
  id: totrans-9920
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**使用字典属性**'
- en: 'Like an array, a dictionary also has an isEmpty property and a count property.
    For example, the following code shows how you can use the isEmpty property to
    check if a dictionary is empty, and if it isn’t empty, the count property checks
    how many items you have. Imagine you have a basket of fruit for sale. You can
    use these properties to help you keep track of everything:'
  id: totrans-9921
  prefs: []
  type: TYPE_NORMAL
  zh: 类似于数组，字典也有isEmpty属性和count属性。例如，以下代码展示了如何使用isEmpty属性检查字典是否为空，如果不为空，则使用count属性检查字典中有多少项。假设你有一个待售的水果篮，你可以使用这些属性来帮助你跟踪所有物品：
- en: '![Image](Image00148.jpg)'
  id: totrans-9922
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00148.jpg)'
- en: 'A dictionary also has two special properties: keys , which contains all of
    the dictionary’s keys, and values , which contains all of its values. We’ll use
    these two properties when we loop through the dictionary.'
  id: totrans-9923
  prefs: []
  type: TYPE_NORMAL
  zh: 字典还有两个特殊的属性：keys，包含字典的所有键，和values，包含字典的所有值。在遍历字典时，我们将使用这两个属性。
- en: Let’s write some code that loops through our fruit baskets and prints the price
    of each fruit.
  id: totrans-9924
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们编写一些代码，遍历我们的水果篮并打印每个水果的价格。
- en: '**LOOPING OVER A DICTIONARY**'
  id: totrans-9925
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**遍历字典**'
- en: 'You can loop through a dictionary using a for-in loop. Because each item has
    a key and a value, you can do this in two different ways. This is how to loop
    through a dictionary using its keys:'
  id: totrans-9926
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用for-in循环遍历字典。因为每个项都有一个键和值，所以你可以通过两种不同的方式来实现这一点。这是使用字典的键进行遍历的方法：
- en: '![Image](Image00149.jpg)'
  id: totrans-9927
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00149.jpg)'
- en: Here we use the dictionary’s keys property ➊ to loop through fruitBasket and
    print its contents. We start by writing the keyword for , followed by a constant
    name fruit for the dictionary key, the keyword in , the dictionary name, a period,
    and keys .
  id: totrans-9928
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们使用字典的键属性 ➊ 来遍历fruitBasket并打印其内容。我们首先写下关键字for，然后是一个常量名称fruit表示字典的键，接着是关键字in，字典名称，点符号，最后是keys。
- en: Inside the braces of our for-in loop, we have access to both the key, which
    we call fruit ➋ , and the value at that key when we force-unwrap its contents
    with fruitBasket[fruit]! ➌ . That value will be the fruit’s price.
  id: totrans-9929
  prefs: []
  type: TYPE_NORMAL
  zh: 在for-in循环的花括号内，我们可以访问键，我们称之为fruit ➋，以及该键对应的值，当我们强制解包其内容时，使用fruitBasket[fruit]!
    ➌。那个值将是水果的价格。
- en: In this case, it’s safe to force-unwrap the value using an exclamation point
    because we know that the fruit key we’re using is definitely inside the dictionary.
  id: totrans-9930
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，使用感叹号强制解包值是安全的，因为我们知道所使用的fruit键一定在字典中。
- en: Any code we put inside the for-in loop will run once for every key in our dictionary.
    So you should see the print statement display three times.
  id: totrans-9931
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在for-in循环中放入的任何代码都会在字典中的每个键上运行一次。因此，你应该看到打印语句执行三次。
- en: 'We can also loop through the dictionary using its values property:'
  id: totrans-9932
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以通过字典的values属性来遍历字典：
- en: '![Image](Image00150.jpg)'
  id: totrans-9933
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00150.jpg)'
- en: We use the same style of for-in loop, but now we use a constant to refer to
    each value, which we call price , in the values property. When looping through
    values, we don’t have access to the keys from inside the loop.
  id: totrans-9934
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用相同风格的for-in循环，但现在我们使用一个常量来引用values属性中的每个值，我们称之为price。在遍历values时，我们无法从循环内部访问键。
- en: Another difference to note is that price is not an optional because it’s accessed
    directly as a value in the fruitBasket dictionary. That means we don’t have to
    unwrap it. You should still see the print statement printed three times. [Figure
    6-6](text00016.html#ch06fig6) shows the output of both loops.
  id: totrans-9935
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个需要注意的区别是，price不是可选项，因为它是作为fruitBasket字典中的值直接访问的。这意味着我们不需要解包它。你仍然应该看到打印语句打印三次。[图6-6](text00016.html#ch06fig6)显示了两个循环的输出。
- en: '![Image](Image00151.jpg)'
  id: totrans-9936
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00151.jpg)'
- en: '*Figure 6-6: Looping through the keys and values of a dictionary with a for-in
    loop*'
  id: totrans-9937
  prefs: []
  type: TYPE_NORMAL
  zh: '*图6-6：使用for-in循环遍历字典的键和值*'
- en: The order of your results might be slightly different from ours. That’s because
    the items in a dictionary aren’t in a numbered order like they are in an array!
    And because the order is not guaranteed, you might see a different order printed
    if you run the same code again.
  id: totrans-9938
  prefs: []
  type: TYPE_NORMAL
  zh: 你的结果顺序可能与我们的稍有不同。这是因为字典中的项不像数组那样按顺序排列！而且由于顺序并不被保证，如果你再次运行相同的代码，打印出的顺序可能会不同。
- en: '**WHAT YOU LEARNED**'
  id: totrans-9939
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**你学到了什么**'
- en: In this chapter, you learned how to store collections of items in an array and
    in a dictionary. To store items in an ordered list, you would use an array and
    look up each item by its index. If you wanted to store items by key instead, you
    would use a dictionary.
  id: totrans-9940
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你学会了如何在数组和字典中存储项。要将项存储在一个有序列表中，你应该使用数组，并通过索引查找每个项。如果你想通过键存储项，你应该使用字典。
- en: Knowing about arrays and dictionaries and how to use them is a powerful building
    block for almost any programming language. Next we will learn about functions,
    another very powerful tool. Functions are blocks of code that you create and name
    to perform a specific job. After you have written a function, you can use its
    name to call it from almost anywhere in your program.
  id: totrans-9941
  prefs: []
  type: TYPE_NORMAL
  zh: 了解数组和字典以及如何使用它们是几乎所有编程语言的强大构建块。接下来，我们将学习函数，另一种非常强大的工具。函数是你创建并命名的一段代码，用于执行特定的任务。写完函数后，你可以通过它的名字在程序中的几乎任何地方调用它。
- en: Dictionaries are different from arrays in that they are *unordered* . Because
    of that, it’s likely that the order of the states that you see in your results
    pane ➋ is different from the order in which you entered your states ➊ . It might
    even be different than the order that’s printed in this book!
  id: totrans-9942
  prefs: []
  type: TYPE_NORMAL
  zh: 字典与数组的不同之处在于它们是*无序的*。因此，你在结果面板中看到的州的顺序➋可能与你输入州的顺序➊不同。甚至可能与本书中打印出的顺序不同！
- en: As with arrays, you can use var to make a mutable dictionary or use let to make
    an immutable dictionary.
  id: totrans-9943
  prefs: []
  type: TYPE_NORMAL
  zh: 与数组一样，你可以使用var来创建一个可变字典，或使用let来创建一个不可变字典。
- en: 'In Swift, all of the keys of a dictionary must be the same type, and all of
    the values of a dictionary must also be the same type, but the key type doesn’t
    have to match the value type. For example, if you wanted to store a collection
    of fractions, you could use doubles for the keys and strings for the values:'
  id: totrans-9944
  prefs: []
  type: TYPE_NORMAL
  zh: 在Swift中，字典的所有键必须是相同类型，字典的所有值也必须是相同类型，但键的类型不必与值的类型匹配。例如，如果你想存储一组分数，你可以使用双精度数作为键，字符串作为值：
- en: '![](Image00142.jpg)'
  id: totrans-9945
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00142.jpg)'
- en: In this dictionary, all of the keys must be doubles, and all of the values must
    be strings. Again, you’ll see that the order of the numbers in the results pane
    can be quite different from the order in which you wrote the fractions in your
    dictionary. This is fine because you don’t need to know the order to access anything.
    You can find any item that you need by its key. Let’s see how!
  id: totrans-9946
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个字典中，所有的键必须是双精度数，而所有的值必须是字符串。再次提醒，你会看到结果面板中的数字顺序与在字典中书写分数时的顺序可能完全不同。这是可以的，因为你不需要知道顺序就能访问任何内容。你可以通过键找到你需要的任何项。让我们来看一下！
- en: '**ACCESSING VALUES IN A DICTIONARY**'
  id: totrans-9947
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**访问字典中的值**'
- en: 'Looking up a value in a dictionary is similar to how you access a value in
    an array except that you use a key inside the square brackets instead of an index,
    like this: usStates["TX"] .'
  id: totrans-9948
  prefs: []
  type: TYPE_NORMAL
  zh: 在字典中查找一个值类似于你在数组中访问一个值，不同之处在于你使用的是方括号中的键而不是索引，像这样：usStates["TX"]。
- en: There is a big difference, however, in how Swift returns the values from a dictionary.
    When you access a value at an index of an array, you are simply given the value.
    When you access a value with a key in a dictionary, you are given an optional.
  id: totrans-9949
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在Swift中从字典中返回值时存在很大的区别。当你通过数组的索引访问一个值时，你只是简单地得到这个值。当你通过字典的键访问一个值时，你得到的是一个可选值。
- en: In [Chapter 5](text00015.html#ch05) , you learned that optionals might contain
    a value or might be nil . The reason Swift returns optionals when you’re looking
    up items in a dictionary is that the key you used might not exist in the dictionary,
    in which case there’s no value to access. Trying to access a value that doesn’t
    exist would give you a big fat error! To avoid that problem, Swift returns optionals.
    That means you need to unwrap any value you get out of a dictionary before you
    can do anything with it.
  id: totrans-9950
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第5章](text00015.html#ch05)中，你学到可选值可能包含一个值，也可能是nil。Swift在你查找字典中的项目时返回可选值，是因为你使用的键可能在字典中不存在，这种情况下就没有值可以访问。如果尝试访问一个不存在的值，会导致一个严重错误！为了避免这个问题，Swift返回可选值。这意味着在你做任何操作之前，你需要解包从字典中获取的任何值。
- en: 'To unwrap an optional, first you check whether it exists using an if-let statement,
    just like we did in [Chapter 5](text00015.html#ch05) . The following code shows
    you how to get a value out of a dictionary:'
  id: totrans-9951
  prefs: []
  type: TYPE_NORMAL
  zh: 要解包一个可选值，首先你需要检查它是否存在，方法是使用if-let语句，就像我们在[第5章](text00015.html#ch05)中做的那样。以下代码展示了如何从字典中获取一个值：
- en: '![Image](Image00143.jpg)'
  id: totrans-9952
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00143.jpg)'
- en: To retrieve "Texas" from the dictionary, we use if let to set a constant loneStarState
    to usStates["TX"] ➊ . Because we have this state in our dictionary, the line I
    have Texas in my dictionary. is printed. Next we try to access a state that is
    not in our dictionary by using the key usStates["FL"] ➋ . Thankfully, because
    we used an if-let statement, the program won’t crash when the computer can’t find
    this state. Instead, I don't have that state in my dictionary. is printed.
  id: totrans-9953
  prefs: []
  type: TYPE_NORMAL
  zh: 要从字典中检索"Texas"，我们使用if-let将常量loneStarState设置为usStates["TX"] ➊。因为我们在字典中有这个州，所以打印出"I
    have Texas in my dictionary."。接下来，我们尝试使用键usStates["FL"] ➋访问一个不在字典中的州。幸运的是，由于我们使用了if-let语句，当计算机找不到这个州时，程序不会崩溃。相反，打印出"I
    don't have that state in my dictionary."。
- en: '**ADDING ITEMS TO A DICTIONARY**'
  id: totrans-9954
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**向字典中添加项目**'
- en: 'To add an item to a dictionary, first write the name of your dictionary and
    assign the new item to the key you want it to have in the dictionary. Let’s add
    "Minnesota" to our usStates dictionary:'
  id: totrans-9955
  prefs: []
  type: TYPE_NORMAL
  zh: 向字典中添加项目，首先写出字典的名称，并将新项目分配给你想要它在字典中拥有的键。让我们将"Minnesota"添加到我们的usStates字典中：
- en: '![](Image00144.jpg)'
  id: totrans-9956
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00144.jpg)'
- en: 'Now when you look at usStates , you’ll see that it’s updated to ["MN": "Minnesota",
    "WA": "Washington", "MA": "Massachusetts", "TX": "Texas"] . Remember, because
    you don’t have to rely on indices, your new dictionary item might appear anywhere
    in the dictionary.'
  id: totrans-9957
  prefs: []
  type: TYPE_NORMAL
  zh: '现在，当你查看usStates时，你会看到它已经更新为["MN": "Minnesota", "WA": "Washington", "MA": "Massachusetts",
    "TX": "Texas"]。记住，因为你不需要依赖索引，所以你的新字典项目可能会出现在字典中的任何位置。'
- en: '**REMOVING ITEMS FROM A DICTIONARY**'
  id: totrans-9958
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**从字典中移除项目**'
- en: Removing an item from a dictionary is quite simple; you do so by setting the
    value to nil . Because the values in dictionaries are returned as optionals, you
    don’t have to worry about nil causing any problems in your dictionary.
  id: totrans-9959
  prefs: []
  type: TYPE_NORMAL
  zh: 从字典中移除一个项目非常简单；你只需将其值设置为nil。因为字典中的值以可选值形式返回，你无需担心nil会导致字典中的任何问题。
- en: '![](Image00145.jpg)'
  id: totrans-9960
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00145.jpg)'
- en: 'You can see that after you remove the value at the key "MA" , usStates is updated
    to ["MN": "Minnesota", "WA": "Washington", "TX": "Texas"] . Remember that nil
    is special and means that there’s no value at all. That’s why you don’t see "MA":
    nil in our dictionary.'
  id: totrans-9961
  prefs: []
  type: TYPE_NORMAL
  zh: '你可以看到，在移除键"MA"的值后，usStates被更新为["MN": "Minnesota", "WA": "Washington", "TX":
    "Texas"]。记住，nil是特殊的，表示没有任何值。因此，你不会在字典中看到"MA": nil。'
- en: '**REPLACING ITEMS IN A DICTIONARY**'
  id: totrans-9962
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**替换字典中的项目**'
- en: 'Replacing an item in a dictionary is also easy. It works the same was as replacing
    an item in an array. You just set the item that you want to replace to something
    else. Say you create a dictionary of fruit colors:'
  id: totrans-9963
  prefs: []
  type: TYPE_NORMAL
  zh: 替换字典中的项目也很简单。它的工作方式与替换数组中的项目相同。你只需将要替换的项目设置为其他内容。假设你创建了一个水果颜色的字典：
- en: '![](Image00146.jpg)'
  id: totrans-9964
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00146.jpg)'
- en: At first we had the value "apple" for "red" , but then we decided that "raspberry"
    is a better fruit to use since sometimes apples are green or yellow. To replace
    "apple" with "raspberry" , we set colorFruits["red"] to its new value ➊ .
  id: totrans-9965
  prefs: []
  type: TYPE_NORMAL
  zh: 最初我们为"red"设置了值"apple"，但后来我们决定用"raspberry"代替，因为有时苹果是绿色或黄色的。为了将"apple"替换为"raspberry"，我们将colorFruits["red"]的值设为新的值
    ➊。
- en: You may remember that this is the same way we entered a new value into a dictionary.
    If the key already exists in the dictionary, then the value for that key is replaced.
    If the key doesn’t already exist, then the new key/value pair will be added to
    the dictionary.
  id: totrans-9966
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能还记得，这与我们将新值添加到字典中的方式相同。如果键已经存在于字典中，则该键的值将被替换。如果键不存在，则新的键/值对将被添加到字典中。
- en: '![Image](Image00147.jpg)'
  id: totrans-9967
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00147.jpg)'
- en: '**USING DICTIONARY PROPERTIES**'
  id: totrans-9968
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**使用字典属性**'
- en: 'Like an array, a dictionary also has an isEmpty property and a count property.
    For example, the following code shows how you can use the isEmpty property to
    check if a dictionary is empty, and if it isn’t empty, the count property checks
    how many items you have. Imagine you have a basket of fruit for sale. You can
    use these properties to help you keep track of everything:'
  id: totrans-9969
  prefs: []
  type: TYPE_NORMAL
  zh: 像数组一样，字典也有isEmpty属性和count属性。例如，下面的代码展示了如何使用isEmpty属性来检查字典是否为空，如果不为空，则使用count属性检查字典中有多少个条目。想象你有一个水果篮子在出售。你可以使用这些属性来帮助你跟踪所有内容：
- en: '![Image](Image00148.jpg)'
  id: totrans-9970
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00148.jpg)'
- en: 'A dictionary also has two special properties: keys , which contains all of
    the dictionary’s keys, and values , which contains all of its values. We’ll use
    these two properties when we loop through the dictionary.'
  id: totrans-9971
  prefs: []
  type: TYPE_NORMAL
  zh: 字典还有两个特殊的属性：keys，包含字典的所有键，和values，包含字典的所有值。我们将在遍历字典时使用这两个属性。
- en: Let’s write some code that loops through our fruit baskets and prints the price
    of each fruit.
  id: totrans-9972
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们写一些代码，遍历我们的水果篮子并打印每个水果的价格。
- en: '**LOOPING OVER A DICTIONARY**'
  id: totrans-9973
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**遍历字典**'
- en: 'You can loop through a dictionary using a for-in loop. Because each item has
    a key and a value, you can do this in two different ways. This is how to loop
    through a dictionary using its keys:'
  id: totrans-9974
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用for-in循环遍历字典。由于每个条目都有一个键和值，因此你可以通过两种不同的方式来实现。以下是如何使用字典的键遍历字典：
- en: '![Image](Image00149.jpg)'
  id: totrans-9975
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00149.jpg)'
- en: Here we use the dictionary’s keys property ➊ to loop through fruitBasket and
    print its contents. We start by writing the keyword for , followed by a constant
    name fruit for the dictionary key, the keyword in , the dictionary name, a period,
    and keys .
  id: totrans-9976
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们使用字典的keys属性➊遍历fruitBasket并打印其内容。我们首先写下关键字for，后跟常量名称fruit作为字典键，接着是关键字in，字典名称，一个句点，和keys。
- en: Inside the braces of our for-in loop, we have access to both the key, which
    we call fruit ➋ , and the value at that key when we force-unwrap its contents
    with fruitBasket[fruit]! ➌ . That value will be the fruit’s price.
  id: totrans-9977
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的for-in循环的花括号内部，我们可以访问键（我们称之为fruit ➋）以及使用fruitBasket[fruit]! ➌强制解包其内容时该键的值。该值将是水果的价格。
- en: In this case, it’s safe to force-unwrap the value using an exclamation point
    because we know that the fruit key we’re using is definitely inside the dictionary.
  id: totrans-9978
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，可以放心地使用感叹号强制解包值，因为我们知道我们使用的水果键一定在字典中。
- en: Any code we put inside the for-in loop will run once for every key in our dictionary.
    So you should see the print statement display three times.
  id: totrans-9979
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在for-in循环中放入的任何代码都会针对字典中的每个键执行一次。所以你应该看到打印语句显示三次。
- en: 'We can also loop through the dictionary using its values property:'
  id: totrans-9980
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以通过字典的values属性来遍历字典：
- en: '![Image](Image00150.jpg)'
  id: totrans-9981
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00150.jpg)'
- en: We use the same style of for-in loop, but now we use a constant to refer to
    each value, which we call price , in the values property. When looping through
    values, we don’t have access to the keys from inside the loop.
  id: totrans-9982
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用相同类型的for-in循环，但现在我们使用常量来引用values属性中的每个值，我们称其为price。在遍历值时，我们无法从循环内部访问键。
- en: Another difference to note is that price is not an optional because it’s accessed
    directly as a value in the fruitBasket dictionary. That means we don’t have to
    unwrap it. You should still see the print statement printed three times. [Figure
    6-6](text00016.html#ch06fig6) shows the output of both loops.
  id: totrans-9983
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个需要注意的区别是，price不是可选的，因为它是作为fruitBasket字典中的值直接访问的。这意味着我们不需要解包它。你仍然应该看到打印语句被打印三次。[图6-6](text00016.html#ch06fig6)显示了两个循环的输出。
- en: '![Image](Image00151.jpg)'
  id: totrans-9984
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00151.jpg)'
- en: '*Figure 6-6: Looping through the keys and values of a dictionary with a for-in
    loop*'
  id: totrans-9985
  prefs: []
  type: TYPE_NORMAL
  zh: '*图6-6：使用for-in循环遍历字典的键和值*'
- en: The order of your results might be slightly different from ours. That’s because
    the items in a dictionary aren’t in a numbered order like they are in an array!
    And because the order is not guaranteed, you might see a different order printed
    if you run the same code again.
  id: totrans-9986
  prefs: []
  type: TYPE_NORMAL
  zh: 你的结果顺序可能与我们的略有不同。这是因为字典中的项不像数组那样按数字顺序排列！而且由于顺序没有保证，如果你再次运行相同的代码，可能会看到不同的顺序。
- en: '**WHAT YOU LEARNED**'
  id: totrans-9987
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**你学到了什么**'
- en: In this chapter, you learned how to store collections of items in an array and
    in a dictionary. To store items in an ordered list, you would use an array and
    look up each item by its index. If you wanted to store items by key instead, you
    would use a dictionary.
  id: totrans-9988
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一章中，你学会了如何将项目存储在数组和字典中。要将项目存储在有序列表中，你可以使用数组，并通过索引查找每一项。如果你想通过键来存储项目，则可以使用字典。
- en: Knowing about arrays and dictionaries and how to use them is a powerful building
    block for almost any programming language. Next we will learn about functions,
    another very powerful tool. Functions are blocks of code that you create and name
    to perform a specific job. After you have written a function, you can use its
    name to call it from almost anywhere in your program.
  id: totrans-9989
  prefs: []
  type: TYPE_NORMAL
  zh: 了解数组和字典及其使用方法是几乎所有编程语言的强大构建块。接下来我们将学习函数，这是另一个非常强大的工具。函数是你创建并命名的一段代码，用于执行特定的任务。在你编写了一个函数后，可以通过函数名从程序中的几乎任何地方调用它。
- en: As with arrays, you can use var to make a mutable dictionary or use let to make
    an immutable dictionary.
  id: totrans-9990
  prefs: []
  type: TYPE_NORMAL
  zh: 与数组一样，你可以使用`var`来创建一个可变的字典，或者使用`let`来创建一个不可变的字典。
- en: 'In Swift, all of the keys of a dictionary must be the same type, and all of
    the values of a dictionary must also be the same type, but the key type doesn’t
    have to match the value type. For example, if you wanted to store a collection
    of fractions, you could use doubles for the keys and strings for the values:'
  id: totrans-9991
  prefs: []
  type: TYPE_NORMAL
  zh: 在Swift中，字典的所有键必须是相同的类型，而字典的所有值也必须是相同的类型，但键类型不必与值类型相匹配。例如，如果你想存储一组分数，可以使用双精度数作为键，字符串作为值：
- en: '![](Image00142.jpg)'
  id: totrans-9992
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00142.jpg)'
- en: In this dictionary, all of the keys must be doubles, and all of the values must
    be strings. Again, you’ll see that the order of the numbers in the results pane
    can be quite different from the order in which you wrote the fractions in your
    dictionary. This is fine because you don’t need to know the order to access anything.
    You can find any item that you need by its key. Let’s see how!
  id: totrans-9993
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个字典中，所有的键必须是双精度数（doubles），所有的值必须是字符串（strings）。再次提醒你，你会发现结果面板中数字的顺序可能与字典中分数的书写顺序完全不同。这是可以接受的，因为你无需知道顺序就能访问任何内容。你可以通过键来查找所需的任何项。我们来看看如何操作！
- en: '**ACCESSING VALUES IN A DICTIONARY**'
  id: totrans-9994
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**访问字典中的值**'
- en: 'Looking up a value in a dictionary is similar to how you access a value in
    an array except that you use a key inside the square brackets instead of an index,
    like this: usStates["TX"] .'
  id: totrans-9995
  prefs: []
  type: TYPE_NORMAL
  zh: 在字典中查找一个值类似于在数组中访问一个值，不同之处在于你使用的是方括号内的键，而不是索引，例如：usStates["TX"]。
- en: There is a big difference, however, in how Swift returns the values from a dictionary.
    When you access a value at an index of an array, you are simply given the value.
    When you access a value with a key in a dictionary, you are given an optional.
  id: totrans-9996
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，Swift从字典返回值的方式有一个很大的不同。当你在数组的索引处访问值时，你会直接得到那个值。而在字典中，通过键访问值时，你会得到一个可选值（optional）。
- en: In [Chapter 5](text00015.html#ch05) , you learned that optionals might contain
    a value or might be nil . The reason Swift returns optionals when you’re looking
    up items in a dictionary is that the key you used might not exist in the dictionary,
    in which case there’s no value to access. Trying to access a value that doesn’t
    exist would give you a big fat error! To avoid that problem, Swift returns optionals.
    That means you need to unwrap any value you get out of a dictionary before you
    can do anything with it.
  id: totrans-9997
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第五章](text00015.html#ch05)中，你学到了可选值可能包含一个值，也可能是`nil`。Swift在查找字典中的项时返回可选值的原因是，你使用的键可能在字典中不存在，在这种情况下没有值可访问。如果尝试访问不存在的值，将会出现一个严重的错误！为避免这个问题，Swift返回可选值。这意味着你需要解包从字典中获取的任何值，才能对其进行进一步操作。
- en: 'To unwrap an optional, first you check whether it exists using an if-let statement,
    just like we did in [Chapter 5](text00015.html#ch05) . The following code shows
    you how to get a value out of a dictionary:'
  id: totrans-9998
  prefs: []
  type: TYPE_NORMAL
  zh: 要解包一个可选值，首先你需要使用`if-let`语句检查它是否存在，就像我们在[第五章](text00015.html#ch05)中做的那样。以下代码展示了如何从字典中获取一个值：
- en: '![Image](Image00143.jpg)'
  id: totrans-9999
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00143.jpg)'
- en: To retrieve "Texas" from the dictionary, we use if let to set a constant loneStarState
    to usStates["TX"] ➊ . Because we have this state in our dictionary, the line I
    have Texas in my dictionary. is printed. Next we try to access a state that is
    not in our dictionary by using the key usStates["FL"] ➋ . Thankfully, because
    we used an if-let statement, the program won’t crash when the computer can’t find
    this state. Instead, I don't have that state in my dictionary. is printed.
  id: totrans-10000
  prefs: []
  type: TYPE_NORMAL
  zh: 要从字典中检索"Texas"，我们使用`if let`语句将常量`loneStarState`设置为`usStates["TX"]` ➊。因为字典中有这个州，所以会打印出"I
    have Texas in my dictionary"。接下来，我们尝试使用`usStates["FL"]` ➋访问一个字典中没有的州。幸运的是，由于我们使用了`if-let`语句，当计算机找不到该州时，程序不会崩溃。相反，会打印出"I
    don't have that state in my dictionary"。
- en: '**ADDING ITEMS TO A DICTIONARY**'
  id: totrans-10001
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**向字典中添加项**'
- en: 'To add an item to a dictionary, first write the name of your dictionary and
    assign the new item to the key you want it to have in the dictionary. Let’s add
    "Minnesota" to our usStates dictionary:'
  id: totrans-10002
  prefs: []
  type: TYPE_NORMAL
  zh: 要向字典中添加项，首先写下字典的名称，并将新项分配给你想要的键。让我们向`usStates`字典中添加"Minnesota"：
- en: '![](Image00144.jpg)'
  id: totrans-10003
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00144.jpg)'
- en: 'Now when you look at usStates , you’ll see that it’s updated to ["MN": "Minnesota",
    "WA": "Washington", "MA": "Massachusetts", "TX": "Texas"] . Remember, because
    you don’t have to rely on indices, your new dictionary item might appear anywhere
    in the dictionary.'
  id: totrans-10004
  prefs: []
  type: TYPE_NORMAL
  zh: '现在，当你查看`usStates`时，你会看到它被更新为["MN": "Minnesota", "WA": "Washington", "MA": "Massachusetts",
    "TX": "Texas"]。记住，因为你不需要依赖索引，你的新字典项可能会出现在字典的任何位置。'
- en: '**REMOVING ITEMS FROM A DICTIONARY**'
  id: totrans-10005
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**从字典中移除项**'
- en: Removing an item from a dictionary is quite simple; you do so by setting the
    value to nil . Because the values in dictionaries are returned as optionals, you
    don’t have to worry about nil causing any problems in your dictionary.
  id: totrans-10006
  prefs: []
  type: TYPE_NORMAL
  zh: 从字典中移除项非常简单；你只需要将值设置为`nil`。因为字典中的值是作为可选项返回的，所以你不必担心`nil`会在字典中引发任何问题。
- en: '![](Image00145.jpg)'
  id: totrans-10007
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00145.jpg)'
- en: 'You can see that after you remove the value at the key "MA" , usStates is updated
    to ["MN": "Minnesota", "WA": "Washington", "TX": "Texas"] . Remember that nil
    is special and means that there’s no value at all. That’s why you don’t see "MA":
    nil in our dictionary.'
  id: totrans-10008
  prefs: []
  type: TYPE_NORMAL
  zh: '你可以看到，在删除键"MA"对应的值后，`usStates`被更新为["MN": "Minnesota", "WA": "Washington", "TX":
    "Texas"]。记住，`nil`是特殊的，意味着根本没有值。这就是为什么你在字典中看不到"MA": nil。'
- en: '**REPLACING ITEMS IN A DICTIONARY**'
  id: totrans-10009
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**替换字典中的项**'
- en: 'Replacing an item in a dictionary is also easy. It works the same was as replacing
    an item in an array. You just set the item that you want to replace to something
    else. Say you create a dictionary of fruit colors:'
  id: totrans-10010
  prefs: []
  type: TYPE_NORMAL
  zh: 替换字典中的项也很简单。它的工作方式与替换数组中的项相同。你只需要将你想替换的项设置为其他值。假设你创建了一个包含水果颜色的字典：
- en: '![](Image00146.jpg)'
  id: totrans-10011
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00146.jpg)'
- en: At first we had the value "apple" for "red" , but then we decided that "raspberry"
    is a better fruit to use since sometimes apples are green or yellow. To replace
    "apple" with "raspberry" , we set colorFruits["red"] to its new value ➊ .
  id: totrans-10012
  prefs: []
  type: TYPE_NORMAL
  zh: 一开始我们为"red"键设置了值"apple"，但后来我们决定"raspberry"更适合，因为有时候苹果是绿色或黄色的。为了用"raspberry"替换"apple"，我们将`colorFruits["red"]`设置为它的新值
    ➊。
- en: You may remember that this is the same way we entered a new value into a dictionary.
    If the key already exists in the dictionary, then the value for that key is replaced.
    If the key doesn’t already exist, then the new key/value pair will be added to
    the dictionary.
  id: totrans-10013
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能还记得，这与我们将新值添加到字典中的方式相同。如果键已经存在于字典中，那么该键对应的值将被替换。如果键不存在，则新的键/值对将被添加到字典中。
- en: '![Image](Image00147.jpg)'
  id: totrans-10014
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00147.jpg)'
- en: '**USING DICTIONARY PROPERTIES**'
  id: totrans-10015
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**使用字典属性**'
- en: 'Like an array, a dictionary also has an isEmpty property and a count property.
    For example, the following code shows how you can use the isEmpty property to
    check if a dictionary is empty, and if it isn’t empty, the count property checks
    how many items you have. Imagine you have a basket of fruit for sale. You can
    use these properties to help you keep track of everything:'
  id: totrans-10016
  prefs: []
  type: TYPE_NORMAL
  zh: 像数组一样，字典也有`isEmpty`属性和`count`属性。例如，下面的代码展示了如何使用`isEmpty`属性检查字典是否为空，如果不为空，`count`属性可以检查字典中有多少项。假设你有一个待售的水果篮子，你可以使用这些属性来帮助你跟踪所有内容：
- en: '![Image](Image00148.jpg)'
  id: totrans-10017
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00148.jpg)'
- en: 'A dictionary also has two special properties: keys , which contains all of
    the dictionary’s keys, and values , which contains all of its values. We’ll use
    these two properties when we loop through the dictionary.'
  id: totrans-10018
  prefs: []
  type: TYPE_NORMAL
  zh: 字典还有两个特殊的属性：`keys`，它包含字典的所有键；`values`，它包含字典的所有值。我们将在遍历字典时使用这两个属性。
- en: Let’s write some code that loops through our fruit baskets and prints the price
    of each fruit.
  id: totrans-10019
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们编写一些代码，遍历我们的水果篮子并打印每种水果的价格。
- en: '**LOOPING OVER A DICTIONARY**'
  id: totrans-10020
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**遍历字典**'
- en: 'You can loop through a dictionary using a for-in loop. Because each item has
    a key and a value, you can do this in two different ways. This is how to loop
    through a dictionary using its keys:'
  id: totrans-10021
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用 for-in 循环遍历字典。由于每个项目都有一个键和值，你可以通过两种不同的方式来做。以下是使用键遍历字典的方法：
- en: '![Image](Image00149.jpg)'
  id: totrans-10022
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Image00149.jpg)'
- en: Here we use the dictionary’s keys property ➊ to loop through fruitBasket and
    print its contents. We start by writing the keyword for , followed by a constant
    name fruit for the dictionary key, the keyword in , the dictionary name, a period,
    and keys .
  id: totrans-10023
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们使用字典的 keys 属性 ➊ 来遍历 fruitBasket 并打印其内容。我们从写关键词 for 开始，接着是字典键的常量名 fruit，关键词
    in，字典名，句点，以及 keys。
- en: Inside the braces of our for-in loop, we have access to both the key, which
    we call fruit ➋ , and the value at that key when we force-unwrap its contents
    with fruitBasket[fruit]! ➌ . That value will be the fruit’s price.
  id: totrans-10024
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的 for-in 循环的大括号内，我们可以访问键（我们称之为 fruit ➋）以及该键对应的值，方法是通过 fruitBasket[fruit]!
    强制解包其内容 ➌。该值就是水果的价格。
- en: In this case, it’s safe to force-unwrap the value using an exclamation point
    because we know that the fruit key we’re using is definitely inside the dictionary.
  id: totrans-10025
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，使用感叹号强制解包值是安全的，因为我们知道我们使用的果实键一定在字典中。
- en: Any code we put inside the for-in loop will run once for every key in our dictionary.
    So you should see the print statement display three times.
  id: totrans-10026
  prefs: []
  type: TYPE_NORMAL
  zh: 我们放入 for-in 循环中的任何代码都会针对字典中的每个键执行一次。所以你应该会看到打印语句显示三次。
- en: 'We can also loop through the dictionary using its values property:'
  id: totrans-10027
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以通过字典的 values 属性来遍历字典：
- en: '![Image](Image00150.jpg)'
  id: totrans-10028
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Image00150.jpg)'
- en: We use the same style of for-in loop, but now we use a constant to refer to
    each value, which we call price , in the values property. When looping through
    values, we don’t have access to the keys from inside the loop.
  id: totrans-10029
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用相同风格的 for-in 循环，但现在我们使用常量来引用 values 属性中的每个值，我们将其命名为 price。当遍历值时，我们无法从循环内部访问键。
- en: Another difference to note is that price is not an optional because it’s accessed
    directly as a value in the fruitBasket dictionary. That means we don’t have to
    unwrap it. You should still see the print statement printed three times. [Figure
    6-6](text00016.html#ch06fig6) shows the output of both loops.
  id: totrans-10030
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个需要注意的区别是，price 不是一个可选值，因为它是直接作为 fruitBasket 字典中的值来访问的。这意味着我们不需要解包它。你仍然应该会看到打印语句打印三次。[图
    6-6](text00016.html#ch06fig6) 显示了两个循环的输出。
- en: '![Image](Image00151.jpg)'
  id: totrans-10031
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Image00151.jpg)'
- en: '*Figure 6-6: Looping through the keys and values of a dictionary with a for-in
    loop*'
  id: totrans-10032
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 6-6：使用 for-in 循环遍历字典的键和值*'
- en: The order of your results might be slightly different from ours. That’s because
    the items in a dictionary aren’t in a numbered order like they are in an array!
    And because the order is not guaranteed, you might see a different order printed
    if you run the same code again.
  id: totrans-10033
  prefs: []
  type: TYPE_NORMAL
  zh: 你的结果顺序可能与我们的略有不同。这是因为字典中的项目不像数组中的项目那样按编号排序！由于顺序不能保证，如果你重新运行相同的代码，你可能会看到不同的顺序。
- en: '**WHAT YOU LEARNED**'
  id: totrans-10034
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**你学到的知识**'
- en: In this chapter, you learned how to store collections of items in an array and
    in a dictionary. To store items in an ordered list, you would use an array and
    look up each item by its index. If you wanted to store items by key instead, you
    would use a dictionary.
  id: totrans-10035
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你学习了如何将项目集合存储在数组和字典中。要在有序列表中存储项目，你会使用数组，并通过索引查找每个项目。如果你想通过键来存储项目，你会使用字典。
- en: Knowing about arrays and dictionaries and how to use them is a powerful building
    block for almost any programming language. Next we will learn about functions,
    another very powerful tool. Functions are blocks of code that you create and name
    to perform a specific job. After you have written a function, you can use its
    name to call it from almost anywhere in your program.
  id: totrans-10036
  prefs: []
  type: TYPE_NORMAL
  zh: 了解数组和字典以及如何使用它们，是几乎所有编程语言中的一个强大构建块。接下来我们将学习函数，另一个非常强大的工具。函数是你创建并命名的代码块，用于执行特定的任务。在你编写了一个函数之后，你可以通过它的名称在程序中的几乎任何地方调用它。
- en: 'In Swift, all of the keys of a dictionary must be the same type, and all of
    the values of a dictionary must also be the same type, but the key type doesn’t
    have to match the value type. For example, if you wanted to store a collection
    of fractions, you could use doubles for the keys and strings for the values:'
  id: totrans-10037
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Swift 中，字典的所有键必须是相同类型，字典的所有值也必须是相同类型，但键的类型不必与值的类型匹配。例如，如果你想存储一组分数，可以将键设置为
    double 类型，将值设置为字符串类型：
- en: '![](Image00142.jpg)'
  id: totrans-10038
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00142.jpg)'
- en: In this dictionary, all of the keys must be doubles, and all of the values must
    be strings. Again, you’ll see that the order of the numbers in the results pane
    can be quite different from the order in which you wrote the fractions in your
    dictionary. This is fine because you don’t need to know the order to access anything.
    You can find any item that you need by its key. Let’s see how!
  id: totrans-10039
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个字典中，所有键必须是 double 类型，所有值必须是字符串类型。再次提醒，你会看到结果面板中数字的顺序可能与在字典中编写分数的顺序大不相同。这是正常的，因为你不需要知道顺序就可以访问任何项。你可以通过键找到你需要的任何项。让我们看看如何做！
- en: '**ACCESSING VALUES IN A DICTIONARY**'
  id: totrans-10040
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**在字典中访问值**'
- en: 'Looking up a value in a dictionary is similar to how you access a value in
    an array except that you use a key inside the square brackets instead of an index,
    like this: usStates["TX"] .'
  id: totrans-10041
  prefs: []
  type: TYPE_NORMAL
  zh: 在字典中查找值类似于你在数组中访问值的方式，唯一的区别是你在方括号内使用的是键而不是索引，就像这样：usStates["TX"]。
- en: There is a big difference, however, in how Swift returns the values from a dictionary.
    When you access a value at an index of an array, you are simply given the value.
    When you access a value with a key in a dictionary, you are given an optional.
  id: totrans-10042
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，Swift 返回字典中值的方式有很大不同。当你访问数组中某个索引的值时，你会直接获得该值。而当你使用字典中的键来访问值时，你会得到一个可选值。
- en: In [Chapter 5](text00015.html#ch05) , you learned that optionals might contain
    a value or might be nil . The reason Swift returns optionals when you’re looking
    up items in a dictionary is that the key you used might not exist in the dictionary,
    in which case there’s no value to access. Trying to access a value that doesn’t
    exist would give you a big fat error! To avoid that problem, Swift returns optionals.
    That means you need to unwrap any value you get out of a dictionary before you
    can do anything with it.
  id: totrans-10043
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第5章](text00015.html#ch05)中，你学到了可选值可能包含一个值，也可能是 nil。当你在字典中查找项时，Swift 返回可选值的原因是，你使用的键可能在字典中不存在，在这种情况下，没有值可供访问。尝试访问一个不存在的值会导致一个大错误！为了避免这个问题，Swift
    返回可选值。这意味着在你可以对其进行任何操作之前，你需要解包从字典中获取的任何值。
- en: 'To unwrap an optional, first you check whether it exists using an if-let statement,
    just like we did in [Chapter 5](text00015.html#ch05) . The following code shows
    you how to get a value out of a dictionary:'
  id: totrans-10044
  prefs: []
  type: TYPE_NORMAL
  zh: 要解包一个可选值，首先使用 if-let 语句检查它是否存在，就像我们在[第5章](text00015.html#ch05) 中做的那样。以下代码展示了如何从字典中获取值：
- en: '![Image](Image00143.jpg)'
  id: totrans-10045
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00143.jpg)'
- en: To retrieve "Texas" from the dictionary, we use if let to set a constant loneStarState
    to usStates["TX"] ➊ . Because we have this state in our dictionary, the line I
    have Texas in my dictionary. is printed. Next we try to access a state that is
    not in our dictionary by using the key usStates["FL"] ➋ . Thankfully, because
    we used an if-let statement, the program won’t crash when the computer can’t find
    this state. Instead, I don't have that state in my dictionary. is printed.
  id: totrans-10046
  prefs: []
  type: TYPE_NORMAL
  zh: 要从字典中检索"Texas"，我们使用 if let 将常量 loneStarState 设置为 usStates["TX"] ➊。因为我们在字典中有这个州，所以会打印出
    I have Texas in my dictionary。接下来，我们尝试通过使用键 usStates["FL"] ➋ 来访问字典中不存在的州。幸运的是，由于我们使用了
    if-let 语句，当计算机找不到这个州时，程序不会崩溃。相反，会打印出 I don't have that state in my dictionary。
- en: '**ADDING ITEMS TO A DICTIONARY**'
  id: totrans-10047
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**向字典添加项**'
- en: 'To add an item to a dictionary, first write the name of your dictionary and
    assign the new item to the key you want it to have in the dictionary. Let’s add
    "Minnesota" to our usStates dictionary:'
  id: totrans-10048
  prefs: []
  type: TYPE_NORMAL
  zh: 要向字典添加项，首先写下字典的名称，并将新项分配给你希望它在字典中拥有的键。让我们将 "Minnesota" 添加到我们的 usStates 字典中：
- en: '![](Image00144.jpg)'
  id: totrans-10049
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00144.jpg)'
- en: 'Now when you look at usStates , you’ll see that it’s updated to ["MN": "Minnesota",
    "WA": "Washington", "MA": "Massachusetts", "TX": "Texas"] . Remember, because
    you don’t have to rely on indices, your new dictionary item might appear anywhere
    in the dictionary.'
  id: totrans-10050
  prefs: []
  type: TYPE_NORMAL
  zh: '现在，当你查看 usStates 时，你会看到它已更新为["MN": "Minnesota", "WA": "Washington", "MA": "Massachusetts",
    "TX": "Texas"]。记住，由于你不必依赖索引，新的字典项可能出现在字典中的任何位置。'
- en: '**REMOVING ITEMS FROM A DICTIONARY**'
  id: totrans-10051
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**从字典中移除项**'
- en: Removing an item from a dictionary is quite simple; you do so by setting the
    value to nil . Because the values in dictionaries are returned as optionals, you
    don’t have to worry about nil causing any problems in your dictionary.
  id: totrans-10052
  prefs: []
  type: TYPE_NORMAL
  zh: 从字典中删除项非常简单；你只需要将值设置为 nil。由于字典中的值是作为可选类型返回的，你无需担心 nil 会导致字典中的任何问题。
- en: '![](Image00145.jpg)'
  id: totrans-10053
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00145.jpg)'
- en: 'You can see that after you remove the value at the key "MA" , usStates is updated
    to ["MN": "Minnesota", "WA": "Washington", "TX": "Texas"] . Remember that nil
    is special and means that there’s no value at all. That’s why you don’t see "MA":
    nil in our dictionary.'
  id: totrans-10054
  prefs: []
  type: TYPE_NORMAL
  zh: '你可以看到，当你删除 "MA" 键的值后，usStates 会更新为 ["MN": "Minnesota", "WA": "Washington",
    "TX": "Texas"]。记住，nil 是特殊的，表示根本没有值。因此，你不会在字典中看到 "MA": nil。'
- en: '**REPLACING ITEMS IN A DICTIONARY**'
  id: totrans-10055
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**替换字典中的项**'
- en: 'Replacing an item in a dictionary is also easy. It works the same was as replacing
    an item in an array. You just set the item that you want to replace to something
    else. Say you create a dictionary of fruit colors:'
  id: totrans-10056
  prefs: []
  type: TYPE_NORMAL
  zh: 替换字典中的项也很简单。它的工作方式与替换数组中的项相同。你只需要将你想替换的项设置为其他值。假设你创建了一个水果颜色的字典：
- en: '![](Image00146.jpg)'
  id: totrans-10057
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00146.jpg)'
- en: At first we had the value "apple" for "red" , but then we decided that "raspberry"
    is a better fruit to use since sometimes apples are green or yellow. To replace
    "apple" with "raspberry" , we set colorFruits["red"] to its new value ➊ .
  id: totrans-10058
  prefs: []
  type: TYPE_NORMAL
  zh: 最初，我们为 "red" 键设置了值 "apple"，但是后来我们决定使用 "raspberry"（树莓）作为水果，因为有时候苹果是绿色或黄色的。为了将
    "apple" 替换为 "raspberry"，我们将 colorFruits["red"] 设置为新的值 ➊。
- en: You may remember that this is the same way we entered a new value into a dictionary.
    If the key already exists in the dictionary, then the value for that key is replaced.
    If the key doesn’t already exist, then the new key/value pair will be added to
    the dictionary.
  id: totrans-10059
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能记得，这和我们向字典中插入新值的方式是一样的。如果键已经存在于字典中，那么该键的值会被替换。如果键不存在，那么新的键值对将会被添加到字典中。
- en: '![Image](Image00147.jpg)'
  id: totrans-10060
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00147.jpg)'
- en: '**USING DICTIONARY PROPERTIES**'
  id: totrans-10061
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**使用字典属性**'
- en: 'Like an array, a dictionary also has an isEmpty property and a count property.
    For example, the following code shows how you can use the isEmpty property to
    check if a dictionary is empty, and if it isn’t empty, the count property checks
    how many items you have. Imagine you have a basket of fruit for sale. You can
    use these properties to help you keep track of everything:'
  id: totrans-10062
  prefs: []
  type: TYPE_NORMAL
  zh: 像数组一样，字典也有一个 isEmpty 属性和一个 count 属性。例如，以下代码展示了如何使用 isEmpty 属性来检查字典是否为空，如果字典不为空，count
    属性则检查你有多少项内容。假设你有一个水果篮子在出售，你可以使用这些属性来帮助你跟踪所有内容：
- en: '![Image](Image00148.jpg)'
  id: totrans-10063
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00148.jpg)'
- en: 'A dictionary also has two special properties: keys , which contains all of
    the dictionary’s keys, and values , which contains all of its values. We’ll use
    these two properties when we loop through the dictionary.'
  id: totrans-10064
  prefs: []
  type: TYPE_NORMAL
  zh: 字典还有两个特殊的属性：keys，它包含字典的所有键；以及 values，它包含字典的所有值。在我们遍历字典时，将使用这两个属性。
- en: Let’s write some code that loops through our fruit baskets and prints the price
    of each fruit.
  id: totrans-10065
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们编写一些代码，遍历我们的水果篮子并打印每个水果的价格。
- en: '**LOOPING OVER A DICTIONARY**'
  id: totrans-10066
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**遍历字典**'
- en: 'You can loop through a dictionary using a for-in loop. Because each item has
    a key and a value, you can do this in two different ways. This is how to loop
    through a dictionary using its keys:'
  id: totrans-10067
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用 for-in 循环遍历字典。因为每一项都有一个键和值，你可以用两种不同的方式来进行。下面是如何使用字典的键来遍历它：
- en: '![Image](Image00149.jpg)'
  id: totrans-10068
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00149.jpg)'
- en: Here we use the dictionary’s keys property ➊ to loop through fruitBasket and
    print its contents. We start by writing the keyword for , followed by a constant
    name fruit for the dictionary key, the keyword in , the dictionary name, a period,
    and keys .
  id: totrans-10069
  prefs: []
  type: TYPE_NORMAL
  zh: 这里我们使用字典的 keys 属性 ➊ 来遍历 fruitBasket 并打印其内容。我们首先写下关键字 for，接着是字典键的常量名 fruit，关键字
    in，字典名，一个句点，最后是 keys。
- en: Inside the braces of our for-in loop, we have access to both the key, which
    we call fruit ➋ , and the value at that key when we force-unwrap its contents
    with fruitBasket[fruit]! ➌ . That value will be the fruit’s price.
  id: totrans-10070
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们 for-in 循环的花括号内，我们可以访问键（我们称之为 fruit ➋）和该键的值，当我们强制解包它的内容时，可以通过 fruitBasket[fruit]!
    ➌ 获取。这个值将是水果的价格。
- en: In this case, it’s safe to force-unwrap the value using an exclamation point
    because we know that the fruit key we’re using is definitely inside the dictionary.
  id: totrans-10071
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，使用感叹号强制解包值是安全的，因为我们知道我们使用的水果键肯定在字典中。
- en: Any code we put inside the for-in loop will run once for every key in our dictionary.
    So you should see the print statement display three times.
  id: totrans-10072
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在 for-in 循环中放入的任何代码都会针对字典中的每个键执行一次。因此，你应该看到打印语句显示三次。
- en: 'We can also loop through the dictionary using its values property:'
  id: totrans-10073
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以通过字典的 values 属性进行循环：
- en: '![Image](Image00150.jpg)'
  id: totrans-10074
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00150.jpg)'
- en: We use the same style of for-in loop, but now we use a constant to refer to
    each value, which we call price , in the values property. When looping through
    values, we don’t have access to the keys from inside the loop.
  id: totrans-10075
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用相同的 for-in 循环样式，但现在我们使用一个常量来引用 values 属性中的每个值，我们称之为 price。在循环遍历值时，我们无法从循环内访问键。
- en: Another difference to note is that price is not an optional because it’s accessed
    directly as a value in the fruitBasket dictionary. That means we don’t have to
    unwrap it. You should still see the print statement printed three times. [Figure
    6-6](text00016.html#ch06fig6) shows the output of both loops.
  id: totrans-10076
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个需要注意的区别是，price 不是一个可选值，因为它直接作为果篮字典中的值进行访问。这意味着我们不需要解包它。你仍然应该看到打印语句打印三次。[图
    6-6](text00016.html#ch06fig6) 显示了两个循环的输出。
- en: '![Image](Image00151.jpg)'
  id: totrans-10077
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00151.jpg)'
- en: '*Figure 6-6: Looping through the keys and values of a dictionary with a for-in
    loop*'
  id: totrans-10078
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 6-6：使用 for-in 循环遍历字典的键和值*'
- en: The order of your results might be slightly different from ours. That’s because
    the items in a dictionary aren’t in a numbered order like they are in an array!
    And because the order is not guaranteed, you might see a different order printed
    if you run the same code again.
  id: totrans-10079
  prefs: []
  type: TYPE_NORMAL
  zh: 你的结果顺序可能与我们的略有不同。那是因为字典中的项不像数组那样是有编号顺序的！由于顺序不可保证，如果你再次运行相同的代码，你可能会看到不同的顺序。
- en: '**WHAT YOU LEARNED**'
  id: totrans-10080
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**你学到了什么**'
- en: In this chapter, you learned how to store collections of items in an array and
    in a dictionary. To store items in an ordered list, you would use an array and
    look up each item by its index. If you wanted to store items by key instead, you
    would use a dictionary.
  id: totrans-10081
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你学习了如何将项存储在数组和字典中。要将项存储在有序列表中，你应该使用数组，并通过索引查找每个项。如果你想通过键存储项，则应该使用字典。
- en: Knowing about arrays and dictionaries and how to use them is a powerful building
    block for almost any programming language. Next we will learn about functions,
    another very powerful tool. Functions are blocks of code that you create and name
    to perform a specific job. After you have written a function, you can use its
    name to call it from almost anywhere in your program.
  id: totrans-10082
  prefs: []
  type: TYPE_NORMAL
  zh: 了解数组和字典以及如何使用它们是几乎任何编程语言中的强大构建块。接下来我们将学习函数，另一个非常强大的工具。函数是你创建并命名的代码块，用来执行特定的任务。在你编写了一个函数后，你可以通过它的名称从程序中的几乎任何地方调用它。
- en: '![](Image00142.jpg)'
  id: totrans-10083
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00142.jpg)'
- en: In this dictionary, all of the keys must be doubles, and all of the values must
    be strings. Again, you’ll see that the order of the numbers in the results pane
    can be quite different from the order in which you wrote the fractions in your
    dictionary. This is fine because you don’t need to know the order to access anything.
    You can find any item that you need by its key. Let’s see how!
  id: totrans-10084
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个字典中，所有的键必须是双精度浮点数，所有的值必须是字符串。同样，你会发现结果面板中的数字顺序可能与字典中分数的顺序大不相同。这是正常的，因为你不需要知道顺序就能访问任何项。你可以通过键找到你需要的任何项。让我们看看怎么做！
- en: '**ACCESSING VALUES IN A DICTIONARY**'
  id: totrans-10085
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**访问字典中的值**'
- en: 'Looking up a value in a dictionary is similar to how you access a value in
    an array except that you use a key inside the square brackets instead of an index,
    like this: usStates["TX"] .'
  id: totrans-10086
  prefs: []
  type: TYPE_NORMAL
  zh: 在字典中查找一个值类似于在数组中访问值的方式，只是你在方括号内使用键，而不是索引，像这样：usStates["TX"]。
- en: There is a big difference, however, in how Swift returns the values from a dictionary.
    When you access a value at an index of an array, you are simply given the value.
    When you access a value with a key in a dictionary, you are given an optional.
  id: totrans-10087
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，Swift 从字典中返回值的方式有很大不同。当你访问数组中索引位置的值时，你只会得到该值。当你通过字典中的键访问值时，你会得到一个可选值。
- en: In [Chapter 5](text00015.html#ch05) , you learned that optionals might contain
    a value or might be nil . The reason Swift returns optionals when you’re looking
    up items in a dictionary is that the key you used might not exist in the dictionary,
    in which case there’s no value to access. Trying to access a value that doesn’t
    exist would give you a big fat error! To avoid that problem, Swift returns optionals.
    That means you need to unwrap any value you get out of a dictionary before you
    can do anything with it.
  id: totrans-10088
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第五章](text00015.html#ch05)中，你学到了可选值可能包含一个值，也可能是 nil。Swift 在查找字典中的项时返回可选值的原因是，你使用的键可能在字典中不存在，在这种情况下就没有值可以访问。尝试访问一个不存在的值会导致严重的错误！为了避免这个问题，Swift
    返回可选值。这意味着，在你对从字典中获取的任何值进行操作之前，必须先解包该值。
- en: 'To unwrap an optional, first you check whether it exists using an if-let statement,
    just like we did in [Chapter 5](text00015.html#ch05) . The following code shows
    you how to get a value out of a dictionary:'
  id: totrans-10089
  prefs: []
  type: TYPE_NORMAL
  zh: 要解包一个可选值，首先你需要使用 if-let 语句检查它是否存在，就像我们在[第五章](text00015.html#ch05)中做的那样。以下代码展示了如何从字典中获取一个值：
- en: '![Image](Image00143.jpg)'
  id: totrans-10090
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00143.jpg)'
- en: To retrieve "Texas" from the dictionary, we use if let to set a constant loneStarState
    to usStates["TX"] ➊ . Because we have this state in our dictionary, the line I
    have Texas in my dictionary. is printed. Next we try to access a state that is
    not in our dictionary by using the key usStates["FL"] ➋ . Thankfully, because
    we used an if-let statement, the program won’t crash when the computer can’t find
    this state. Instead, I don't have that state in my dictionary. is printed.
  id: totrans-10091
  prefs: []
  type: TYPE_NORMAL
  zh: 要从字典中获取“Texas”，我们使用 if let 语句将常量 loneStarState 设置为 usStates["TX"] ➊。因为我们在字典中有这个州，所以会打印出
    "I have Texas in my dictionary."。接下来，我们尝试通过使用键 usStates["FL"] ➋ 访问一个不在字典中的州。幸运的是，由于我们使用了
    if-let 语句，当计算机找不到该州时，程序不会崩溃。相反，打印出 "I don't have that state in my dictionary."。
- en: '**ADDING ITEMS TO A DICTIONARY**'
  id: totrans-10092
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**向字典中添加项**'
- en: 'To add an item to a dictionary, first write the name of your dictionary and
    assign the new item to the key you want it to have in the dictionary. Let’s add
    "Minnesota" to our usStates dictionary:'
  id: totrans-10093
  prefs: []
  type: TYPE_NORMAL
  zh: 要向字典中添加一项，首先写下字典的名称，并将新项分配给你想要它在字典中对应的键。让我们向我们的 usStates 字典中添加“Minnesota”：
- en: '![](Image00144.jpg)'
  id: totrans-10094
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00144.jpg)'
- en: 'Now when you look at usStates , you’ll see that it’s updated to ["MN": "Minnesota",
    "WA": "Washington", "MA": "Massachusetts", "TX": "Texas"] . Remember, because
    you don’t have to rely on indices, your new dictionary item might appear anywhere
    in the dictionary.'
  id: totrans-10095
  prefs: []
  type: TYPE_NORMAL
  zh: '现在，当你查看 usStates 时，你会看到它已更新为 ["MN": "Minnesota", "WA": "Washington", "MA":
    "Massachusetts", "TX": "Texas"]。记住，由于你不需要依赖索引，新的字典项可能出现在字典中的任何位置。'
- en: '**REMOVING ITEMS FROM A DICTIONARY**'
  id: totrans-10096
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**从字典中移除项**'
- en: Removing an item from a dictionary is quite simple; you do so by setting the
    value to nil . Because the values in dictionaries are returned as optionals, you
    don’t have to worry about nil causing any problems in your dictionary.
  id: totrans-10097
  prefs: []
  type: TYPE_NORMAL
  zh: 从字典中移除一个项非常简单；你只需将该值设置为 nil。由于字典中的值是以可选值的形式返回的，所以你不必担心 nil 会在字典中引发任何问题。
- en: '![](Image00145.jpg)'
  id: totrans-10098
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00145.jpg)'
- en: 'You can see that after you remove the value at the key "MA" , usStates is updated
    to ["MN": "Minnesota", "WA": "Washington", "TX": "Texas"] . Remember that nil
    is special and means that there’s no value at all. That’s why you don’t see "MA":
    nil in our dictionary.'
  id: totrans-10099
  prefs: []
  type: TYPE_NORMAL
  zh: '你可以看到，在移除键“MA”对应的值之后，usStates 更新为 ["MN": "Minnesota", "WA": "Washington", "TX":
    "Texas"]。记住，nil 是特别的，表示完全没有值。这就是为什么在我们的字典中没有看到“MA”: nil。'
- en: '**REPLACING ITEMS IN A DICTIONARY**'
  id: totrans-10100
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**替换字典中的项**'
- en: 'Replacing an item in a dictionary is also easy. It works the same was as replacing
    an item in an array. You just set the item that you want to replace to something
    else. Say you create a dictionary of fruit colors:'
  id: totrans-10101
  prefs: []
  type: TYPE_NORMAL
  zh: 在字典中替换一个项也很简单。它的工作方式与替换数组中的项相同。你只需将你想替换的项设置为其他值。假设你创建了一个水果颜色的字典：
- en: '![](Image00146.jpg)'
  id: totrans-10102
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00146.jpg)'
- en: At first we had the value "apple" for "red" , but then we decided that "raspberry"
    is a better fruit to use since sometimes apples are green or yellow. To replace
    "apple" with "raspberry" , we set colorFruits["red"] to its new value ➊ .
  id: totrans-10103
  prefs: []
  type: TYPE_NORMAL
  zh: 起初，我们将“red”赋值为“apple”，但后来我们决定使用“raspberry”作为更合适的水果，因为有时苹果是绿色或黄色的。为了将“apple”替换为“raspberry”，我们将colorFruits["red"]设置为其新值➊。
- en: You may remember that this is the same way we entered a new value into a dictionary.
    If the key already exists in the dictionary, then the value for that key is replaced.
    If the key doesn’t already exist, then the new key/value pair will be added to
    the dictionary.
  id: totrans-10104
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能记得这与我们将新值输入字典的方式相同。如果键已经存在于字典中，那么该键的值会被替换。如果键还不存在，那么新的键/值对将被添加到字典中。
- en: '![Image](Image00147.jpg)'
  id: totrans-10105
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00147.jpg)'
- en: '**USING DICTIONARY PROPERTIES**'
  id: totrans-10106
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**使用字典属性**'
- en: 'Like an array, a dictionary also has an isEmpty property and a count property.
    For example, the following code shows how you can use the isEmpty property to
    check if a dictionary is empty, and if it isn’t empty, the count property checks
    how many items you have. Imagine you have a basket of fruit for sale. You can
    use these properties to help you keep track of everything:'
  id: totrans-10107
  prefs: []
  type: TYPE_NORMAL
  zh: 像数组一样，字典也有isEmpty属性和count属性。例如，下面的代码展示了如何使用isEmpty属性来检查字典是否为空，如果不为空，count属性则检查你有多少个项目。假设你有一个待售的水果篮。你可以使用这些属性帮助你跟踪所有内容：
- en: '![Image](Image00148.jpg)'
  id: totrans-10108
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00148.jpg)'
- en: 'A dictionary also has two special properties: keys , which contains all of
    the dictionary’s keys, and values , which contains all of its values. We’ll use
    these two properties when we loop through the dictionary.'
  id: totrans-10109
  prefs: []
  type: TYPE_NORMAL
  zh: 字典还有两个特殊的属性：keys，包含字典的所有键；values，包含字典的所有值。我们将在循环遍历字典时使用这两个属性。
- en: Let’s write some code that loops through our fruit baskets and prints the price
    of each fruit.
  id: totrans-10110
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们写一些代码，循环遍历我们的水果篮并打印每个水果的价格。
- en: '**LOOPING OVER A DICTIONARY**'
  id: totrans-10111
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**循环遍历字典**'
- en: 'You can loop through a dictionary using a for-in loop. Because each item has
    a key and a value, you can do this in two different ways. This is how to loop
    through a dictionary using its keys:'
  id: totrans-10112
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用for-in循环来遍历字典。由于每个项目都有一个键和值，因此你可以用两种不同的方式来遍历字典。这是使用字典的键来循环的方式：
- en: '![Image](Image00149.jpg)'
  id: totrans-10113
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00149.jpg)'
- en: Here we use the dictionary’s keys property ➊ to loop through fruitBasket and
    print its contents. We start by writing the keyword for , followed by a constant
    name fruit for the dictionary key, the keyword in , the dictionary name, a period,
    and keys .
  id: totrans-10114
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们使用字典的keys属性 ➊ 来循环遍历fruitBasket并打印其内容。我们从写关键字for开始，接着是字典键的常量名称fruit，关键字in，字典名称，句点，然后是keys。
- en: Inside the braces of our for-in loop, we have access to both the key, which
    we call fruit ➋ , and the value at that key when we force-unwrap its contents
    with fruitBasket[fruit]! ➌ . That value will be the fruit’s price.
  id: totrans-10115
  prefs: []
  type: TYPE_NORMAL
  zh: 在for-in循环的大括号内，我们可以访问到键（我们称之为fruit ➋）和该键对应的值，当我们使用fruitBasket[fruit]!强制解包其内容时
    ➌。该值将是水果的价格。
- en: In this case, it’s safe to force-unwrap the value using an exclamation point
    because we know that the fruit key we’re using is definitely inside the dictionary.
  id: totrans-10116
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，强制解包值是安全的，因为我们知道我们使用的水果键肯定在字典中。
- en: Any code we put inside the for-in loop will run once for every key in our dictionary.
    So you should see the print statement display three times.
  id: totrans-10117
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在for-in循环中放入的任何代码都会为字典中的每个键执行一次。因此，你应该看到打印语句显示三次。
- en: 'We can also loop through the dictionary using its values property:'
  id: totrans-10118
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以通过字典的values属性来进行循环：
- en: '![Image](Image00150.jpg)'
  id: totrans-10119
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00150.jpg)'
- en: We use the same style of for-in loop, but now we use a constant to refer to
    each value, which we call price , in the values property. When looping through
    values, we don’t have access to the keys from inside the loop.
  id: totrans-10120
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用相同风格的for-in循环，但现在我们使用一个常量来引用每个值，这个常量我们称之为price，存在values属性中。在循环遍历values时，我们无法从循环内部访问到键。
- en: Another difference to note is that price is not an optional because it’s accessed
    directly as a value in the fruitBasket dictionary. That means we don’t have to
    unwrap it. You should still see the print statement printed three times. [Figure
    6-6](text00016.html#ch06fig6) shows the output of both loops.
  id: totrans-10121
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个需要注意的区别是价格不是一个可选项，因为它是直接作为值在fruitBasket字典中访问的。这意味着我们不需要解包它。你应该仍然能看到打印语句打印三次。[图6-6](text00016.html#ch06fig6)展示了两个循环的输出。
- en: '![Image](Image00151.jpg)'
  id: totrans-10122
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00151.jpg)'
- en: '*Figure 6-6: Looping through the keys and values of a dictionary with a for-in
    loop*'
  id: totrans-10123
  prefs: []
  type: TYPE_NORMAL
  zh: '*图6-6：使用for-in循环遍历字典的键和值*'
- en: The order of your results might be slightly different from ours. That’s because
    the items in a dictionary aren’t in a numbered order like they are in an array!
    And because the order is not guaranteed, you might see a different order printed
    if you run the same code again.
  id: totrans-10124
  prefs: []
  type: TYPE_NORMAL
  zh: 你的结果顺序可能与我们的稍有不同。这是因为字典中的项不像数组那样按编号顺序排列！而且由于顺序无法保证，如果你再次运行相同的代码，可能会看到不同的顺序。
- en: '**WHAT YOU LEARNED**'
  id: totrans-10125
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**你学到了什么**'
- en: In this chapter, you learned how to store collections of items in an array and
    in a dictionary. To store items in an ordered list, you would use an array and
    look up each item by its index. If you wanted to store items by key instead, you
    would use a dictionary.
  id: totrans-10126
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你学习了如何将项目存储在数组和字典中。要将项目存储在一个有序列表中，你会使用数组，并通过索引查找每个项目。如果你想按键存储项目，你会使用字典。
- en: Knowing about arrays and dictionaries and how to use them is a powerful building
    block for almost any programming language. Next we will learn about functions,
    another very powerful tool. Functions are blocks of code that you create and name
    to perform a specific job. After you have written a function, you can use its
    name to call it from almost anywhere in your program.
  id: totrans-10127
  prefs: []
  type: TYPE_NORMAL
  zh: 了解数组和字典以及如何使用它们，是几乎所有编程语言中一个强大的构建块。接下来，我们将学习函数，这是另一个非常强大的工具。函数是你创建并命名的代码块，用来执行特定的任务。写完一个函数后，你可以通过它的名字在程序中的几乎任何地方调用它。
- en: In this dictionary, all of the keys must be doubles, and all of the values must
    be strings. Again, you’ll see that the order of the numbers in the results pane
    can be quite different from the order in which you wrote the fractions in your
    dictionary. This is fine because you don’t need to know the order to access anything.
    You can find any item that you need by its key. Let’s see how!
  id: totrans-10128
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个字典中，所有的键必须是双引号的，所有的值必须是字符串。同样，你会发现结果面板中数字的顺序可能与写入字典中的分数顺序非常不同。这没关系，因为你不需要知道顺序就能访问任何内容。你可以通过键来查找你需要的任何项目。让我们看看如何操作！
- en: '**ACCESSING VALUES IN A DICTIONARY**'
  id: totrans-10129
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**访问字典中的值**'
- en: 'Looking up a value in a dictionary is similar to how you access a value in
    an array except that you use a key inside the square brackets instead of an index,
    like this: usStates["TX"] .'
  id: totrans-10130
  prefs: []
  type: TYPE_NORMAL
  zh: 在字典中查找一个值类似于在数组中访问一个值，唯一不同的是，你在方括号中使用的是键，而不是索引，像这样：usStates["TX"]。
- en: There is a big difference, however, in how Swift returns the values from a dictionary.
    When you access a value at an index of an array, you are simply given the value.
    When you access a value with a key in a dictionary, you are given an optional.
  id: totrans-10131
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，Swift从字典返回值的方式与访问数组索引的值有很大不同。当你访问数组中的一个值时，你会直接得到该值。而当你通过键访问字典中的一个值时，你会得到一个可选值。
- en: In [Chapter 5](text00015.html#ch05) , you learned that optionals might contain
    a value or might be nil . The reason Swift returns optionals when you’re looking
    up items in a dictionary is that the key you used might not exist in the dictionary,
    in which case there’s no value to access. Trying to access a value that doesn’t
    exist would give you a big fat error! To avoid that problem, Swift returns optionals.
    That means you need to unwrap any value you get out of a dictionary before you
    can do anything with it.
  id: totrans-10132
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第5章](text00015.html#ch05)中，你学到了可选项可能包含一个值，也可能是nil。Swift在查找字典中的项时返回可选项的原因是，你使用的键可能在字典中不存在，这种情况下就没有值可访问。尝试访问一个不存在的值会给你带来一个大错误！为避免这个问题，Swift返回可选项。这意味着你需要解包从字典中获取的任何值，才能对其进行处理。
- en: 'To unwrap an optional, first you check whether it exists using an if-let statement,
    just like we did in [Chapter 5](text00015.html#ch05) . The following code shows
    you how to get a value out of a dictionary:'
  id: totrans-10133
  prefs: []
  type: TYPE_NORMAL
  zh: 要解包一个可选值，首先你需要使用if-let语句检查它是否存在，就像我们在[第5章](text00015.html#ch05)中做的那样。以下代码展示了如何从字典中获取一个值：
- en: '![Image](Image00143.jpg)'
  id: totrans-10134
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00143.jpg)'
- en: To retrieve "Texas" from the dictionary, we use if let to set a constant loneStarState
    to usStates["TX"] ➊ . Because we have this state in our dictionary, the line I
    have Texas in my dictionary. is printed. Next we try to access a state that is
    not in our dictionary by using the key usStates["FL"] ➋ . Thankfully, because
    we used an if-let statement, the program won’t crash when the computer can’t find
    this state. Instead, I don't have that state in my dictionary. is printed.
  id: totrans-10135
  prefs: []
  type: TYPE_NORMAL
  zh: 要从字典中获取“Texas”，我们使用 `if let` 将常量 loneStarState 设置为 usStates["TX"] ➊ 。因为我们的字典中有这个州，所以会打印出“我在字典里有
    Texas。”接下来，我们尝试通过使用键 usStates["FL"] ➋ 来访问一个不在字典中的州。幸运的是，由于我们使用了 if-let 语句，当计算机找不到该州时，程序不会崩溃。相反，打印出“我在字典里没有那个州。”
- en: '**ADDING ITEMS TO A DICTIONARY**'
  id: totrans-10136
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**向字典添加项**'
- en: 'To add an item to a dictionary, first write the name of your dictionary and
    assign the new item to the key you want it to have in the dictionary. Let’s add
    "Minnesota" to our usStates dictionary:'
  id: totrans-10137
  prefs: []
  type: TYPE_NORMAL
  zh: 要向字典中添加项，首先写出字典的名称，并将新项分配给你希望它在字典中拥有的键。我们来往 usStates 字典中添加“Minnesota”：
- en: '![](Image00144.jpg)'
  id: totrans-10138
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00144.jpg)'
- en: 'Now when you look at usStates , you’ll see that it’s updated to ["MN": "Minnesota",
    "WA": "Washington", "MA": "Massachusetts", "TX": "Texas"] . Remember, because
    you don’t have to rely on indices, your new dictionary item might appear anywhere
    in the dictionary.'
  id: totrans-10139
  prefs: []
  type: TYPE_NORMAL
  zh: '现在当你查看 usStates 时，你会看到它已经更新为 ["MN": "Minnesota", "WA": "Washington", "MA":
    "Massachusetts", "TX": "Texas"]。记住，因为你不需要依赖索引，所以新的字典项可能出现在字典中的任何位置。'
- en: '**REMOVING ITEMS FROM A DICTIONARY**'
  id: totrans-10140
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**从字典中移除项**'
- en: Removing an item from a dictionary is quite simple; you do so by setting the
    value to nil . Because the values in dictionaries are returned as optionals, you
    don’t have to worry about nil causing any problems in your dictionary.
  id: totrans-10141
  prefs: []
  type: TYPE_NORMAL
  zh: 从字典中移除项是相当简单的；你只需将该值设置为 nil。由于字典中的值是作为可选项返回的，因此你不必担心 nil 会导致字典出现问题。
- en: '![](Image00145.jpg)'
  id: totrans-10142
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00145.jpg)'
- en: 'You can see that after you remove the value at the key "MA" , usStates is updated
    to ["MN": "Minnesota", "WA": "Washington", "TX": "Texas"] . Remember that nil
    is special and means that there’s no value at all. That’s why you don’t see "MA":
    nil in our dictionary.'
  id: totrans-10143
  prefs: []
  type: TYPE_NORMAL
  zh: '你可以看到，在删除了键为“MA”的值之后，usStates 被更新为 ["MN": "Minnesota", "WA": "Washington",
    "TX": "Texas"]。记住，nil 是特殊的，意味着根本没有值。这就是为什么你在字典中看不到 "MA": nil。'
- en: '**REPLACING ITEMS IN A DICTIONARY**'
  id: totrans-10144
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**替换字典中的项**'
- en: 'Replacing an item in a dictionary is also easy. It works the same was as replacing
    an item in an array. You just set the item that you want to replace to something
    else. Say you create a dictionary of fruit colors:'
  id: totrans-10145
  prefs: []
  type: TYPE_NORMAL
  zh: 替换字典中的项也很简单。它与替换数组中的项的方式相同。你只需将要替换的项设置为其他内容。例如，你创建了一个水果颜色的字典：
- en: '![](Image00146.jpg)'
  id: totrans-10146
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00146.jpg)'
- en: At first we had the value "apple" for "red" , but then we decided that "raspberry"
    is a better fruit to use since sometimes apples are green or yellow. To replace
    "apple" with "raspberry" , we set colorFruits["red"] to its new value ➊ .
  id: totrans-10147
  prefs: []
  type: TYPE_NORMAL
  zh: 最初我们将“红色”对应的值设置为“apple”，但后来我们决定“raspberry”是更好的水果选择，因为有时苹果是绿色或黄色的。为了用“raspberry”替换“apple”，我们将
    colorFruits["red"] 设置为它的新值 ➊。
- en: You may remember that this is the same way we entered a new value into a dictionary.
    If the key already exists in the dictionary, then the value for that key is replaced.
    If the key doesn’t already exist, then the new key/value pair will be added to
    the dictionary.
  id: totrans-10148
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能还记得，这与我们如何将新值添加到字典中的方式相同。如果该键已经存在于字典中，那么该键的值会被替换。如果该键不存在，新的键/值对将被添加到字典中。
- en: '![Image](Image00147.jpg)'
  id: totrans-10149
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Image00147.jpg)'
- en: '**USING DICTIONARY PROPERTIES**'
  id: totrans-10150
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**使用字典属性**'
- en: 'Like an array, a dictionary also has an isEmpty property and a count property.
    For example, the following code shows how you can use the isEmpty property to
    check if a dictionary is empty, and if it isn’t empty, the count property checks
    how many items you have. Imagine you have a basket of fruit for sale. You can
    use these properties to help you keep track of everything:'
  id: totrans-10151
  prefs: []
  type: TYPE_NORMAL
  zh: 就像数组一样，字典也有 isEmpty 属性和 count 属性。例如，下面的代码展示了如何使用 isEmpty 属性检查字典是否为空，如果不为空，count
    属性则检查字典中有多少项。假设你有一个待售的水果篮子，你可以利用这些属性帮助你跟踪所有物品：
- en: '![Image](Image00148.jpg)'
  id: totrans-10152
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Image00148.jpg)'
- en: 'A dictionary also has two special properties: keys , which contains all of
    the dictionary’s keys, and values , which contains all of its values. We’ll use
    these two properties when we loop through the dictionary.'
  id: totrans-10153
  prefs: []
  type: TYPE_NORMAL
  zh: 字典还有两个特殊的属性：keys，包含字典的所有键，和 values，包含字典的所有值。我们将在循环遍历字典时使用这两个属性。
- en: Let’s write some code that loops through our fruit baskets and prints the price
    of each fruit.
  id: totrans-10154
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们编写一些代码，循环遍历我们的水果篮子，并打印每种水果的价格。
- en: '**LOOPING OVER A DICTIONARY**'
  id: totrans-10155
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**循环遍历字典**'
- en: 'You can loop through a dictionary using a for-in loop. Because each item has
    a key and a value, you can do this in two different ways. This is how to loop
    through a dictionary using its keys:'
  id: totrans-10156
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用 for-in 循环遍历字典。因为每个项目都有一个键和一个值，所以你可以用两种不同的方式来做。这是如何使用其键循环遍历字典的方法：
- en: '![Image](Image00149.jpg)'
  id: totrans-10157
  prefs: []
  type: TYPE_IMG
  zh: '![图像](Image00149.jpg)'
- en: Here we use the dictionary’s keys property ➊ to loop through fruitBasket and
    print its contents. We start by writing the keyword for , followed by a constant
    name fruit for the dictionary key, the keyword in , the dictionary name, a period,
    and keys .
  id: totrans-10158
  prefs: []
  type: TYPE_NORMAL
  zh: 这里我们使用字典的 keys 属性 ➊ 遍历 fruitBasket 并打印其内容。我们首先写下关键字 for ，随后是常量名称 fruit 用于字典键，关键字
    in ，字典名称，句点以及 keys 。
- en: Inside the braces of our for-in loop, we have access to both the key, which
    we call fruit ➋ , and the value at that key when we force-unwrap its contents
    with fruitBasket[fruit]! ➌ . That value will be the fruit’s price.
  id: totrans-10159
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的 for-in 循环的大括号内，我们可以访问键（我们称之为 fruit ➋ ）以及当我们使用 fruitBasket[fruit]! ➌ 强制展开其内容时该键的值，即水果的价格。
- en: In this case, it’s safe to force-unwrap the value using an exclamation point
    because we know that the fruit key we’re using is definitely inside the dictionary.
  id: totrans-10160
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们可以安全地使用感叹号强制展开值，因为我们知道我们使用的 fruit 键肯定存在于字典中。
- en: Any code we put inside the for-in loop will run once for every key in our dictionary.
    So you should see the print statement display three times.
  id: totrans-10161
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将任何代码放入 for-in 循环中，将会为我们字典中的每个键运行一次。所以你应该看到打印语句显示三次。
- en: 'We can also loop through the dictionary using its values property:'
  id: totrans-10162
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以使用其值属性循环遍历字典：
- en: '![Image](Image00150.jpg)'
  id: totrans-10163
  prefs: []
  type: TYPE_IMG
  zh: '![图像](Image00150.jpg)'
- en: We use the same style of for-in loop, but now we use a constant to refer to
    each value, which we call price , in the values property. When looping through
    values, we don’t have access to the keys from inside the loop.
  id: totrans-10164
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用相同风格的 for-in 循环，但现在我们使用一个常量来引用每个值，我们称之为 price ，在 values 属性中。在循环遍历值时，我们无法从循环内部访问键。
- en: Another difference to note is that price is not an optional because it’s accessed
    directly as a value in the fruitBasket dictionary. That means we don’t have to
    unwrap it. You should still see the print statement printed three times. [Figure
    6-6](text00016.html#ch06fig6) shows the output of both loops.
  id: totrans-10165
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个要注意的区别是，价格不是可选的，因为它直接作为 fruitBasket 字典中的值访问。这意味着我们不必展开它。你仍然应该看到打印语句打印三次。[图
    6-6](text00016.html#ch06fig6) 显示了两个循环的输出结果。
- en: '![Image](Image00151.jpg)'
  id: totrans-10166
  prefs: []
  type: TYPE_IMG
  zh: '![图像](Image00151.jpg)'
- en: '*Figure 6-6: Looping through the keys and values of a dictionary with a for-in
    loop*'
  id: totrans-10167
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 6-6：使用 for-in 循环遍历字典的键和值*'
- en: The order of your results might be slightly different from ours. That’s because
    the items in a dictionary aren’t in a numbered order like they are in an array!
    And because the order is not guaranteed, you might see a different order printed
    if you run the same code again.
  id: totrans-10168
  prefs: []
  type: TYPE_NORMAL
  zh: 你的结果顺序可能与我们的略有不同。这是因为字典中的项目没有像数组中那样按编号顺序排列！由于顺序不保证，如果再次运行相同的代码，你可能会看到不同的顺序打印出来。
- en: '**WHAT YOU LEARNED**'
  id: totrans-10169
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**你学到了什么**'
- en: In this chapter, you learned how to store collections of items in an array and
    in a dictionary. To store items in an ordered list, you would use an array and
    look up each item by its index. If you wanted to store items by key instead, you
    would use a dictionary.
  id: totrans-10170
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你学习了如何在数组和字典中存储项目集合。要将项目存储在有序列表中，你会使用数组，并通过索引查找每个项目。如果你想按键存储项目，你会使用字典。
- en: Knowing about arrays and dictionaries and how to use them is a powerful building
    block for almost any programming language. Next we will learn about functions,
    another very powerful tool. Functions are blocks of code that you create and name
    to perform a specific job. After you have written a function, you can use its
    name to call it from almost anywhere in your program.
  id: totrans-10171
  prefs: []
  type: TYPE_NORMAL
  zh: 了解数组和字典以及如何使用它们是几乎任何编程语言的强大基础。接下来，我们将学习另一个非常强大的工具——函数。函数是你创建并命名以执行特定任务的代码块。编写函数后，你可以使用其名称从程序的几乎任何位置调用它。
- en: '**ACCESSING VALUES IN A DICTIONARY**'
  id: totrans-10172
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**访问字典中的值**'
- en: 'Looking up a value in a dictionary is similar to how you access a value in
    an array except that you use a key inside the square brackets instead of an index,
    like this: usStates["TX"] .'
  id: totrans-10173
  prefs: []
  type: TYPE_NORMAL
  zh: 在字典中查找值与访问数组中的值类似，不同之处在于你在方括号内使用键而不是索引，像这样：usStates["TX"] 。
- en: There is a big difference, however, in how Swift returns the values from a dictionary.
    When you access a value at an index of an array, you are simply given the value.
    When you access a value with a key in a dictionary, you are given an optional.
  id: totrans-10174
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，Swift 在从字典中返回值的方式上有很大不同。当你通过索引访问数组中的值时，你只是得到该值。而当你通过键访问字典中的值时，你得到的是一个可选值（optional）。
- en: In [Chapter 5](text00015.html#ch05) , you learned that optionals might contain
    a value or might be nil . The reason Swift returns optionals when you’re looking
    up items in a dictionary is that the key you used might not exist in the dictionary,
    in which case there’s no value to access. Trying to access a value that doesn’t
    exist would give you a big fat error! To avoid that problem, Swift returns optionals.
    That means you need to unwrap any value you get out of a dictionary before you
    can do anything with it.
  id: totrans-10175
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第5章](text00015.html#ch05)中，你已经学到过，可选值可能包含一个值，也可能是 nil。Swift 返回可选值的原因是，在你查找字典中的项时，所使用的键可能在字典中不存在，这种情况下没有值可以访问。尝试访问一个不存在的值会导致一个大错误！为了解决这个问题，Swift
    返回可选值。这意味着，在你对从字典中获取的任何值进行操作之前，必须先解包它。
- en: 'To unwrap an optional, first you check whether it exists using an if-let statement,
    just like we did in [Chapter 5](text00015.html#ch05) . The following code shows
    you how to get a value out of a dictionary:'
  id: totrans-10176
  prefs: []
  type: TYPE_NORMAL
  zh: 要解包一个可选值，首先你需要使用 if-let 语句检查它是否存在，就像我们在[第5章](text00015.html#ch05)中所做的那样。以下代码展示了如何从字典中获取一个值：
- en: '![Image](Image00143.jpg)'
  id: totrans-10177
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00143.jpg)'
- en: To retrieve "Texas" from the dictionary, we use if let to set a constant loneStarState
    to usStates["TX"] ➊ . Because we have this state in our dictionary, the line I
    have Texas in my dictionary. is printed. Next we try to access a state that is
    not in our dictionary by using the key usStates["FL"] ➋ . Thankfully, because
    we used an if-let statement, the program won’t crash when the computer can’t find
    this state. Instead, I don't have that state in my dictionary. is printed.
  id: totrans-10178
  prefs: []
  type: TYPE_NORMAL
  zh: 要从字典中检索 "Texas"，我们使用 if let 来将常量 loneStarState 设置为 usStates["TX"] ➊。因为我们在字典中有这个州，所以打印出了
    "I have Texas in my dictionary."。接下来，我们尝试通过使用键 usStates["FL"] ➋ 来访问一个不在字典中的州。幸运的是，由于我们使用了
    if-let 语句，当计算机找不到这个州时，程序不会崩溃。相反，打印出了 "I don't have that state in my dictionary."。
- en: '**ADDING ITEMS TO A DICTIONARY**'
  id: totrans-10179
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**向字典添加项**'
- en: 'To add an item to a dictionary, first write the name of your dictionary and
    assign the new item to the key you want it to have in the dictionary. Let’s add
    "Minnesota" to our usStates dictionary:'
  id: totrans-10180
  prefs: []
  type: TYPE_NORMAL
  zh: 向字典添加项时，首先写出字典的名称，并将新项分配给你希望它在字典中拥有的键。让我们将 "Minnesota" 添加到我们的 usStates 字典中：
- en: '![](Image00144.jpg)'
  id: totrans-10181
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00144.jpg)'
- en: 'Now when you look at usStates , you’ll see that it’s updated to ["MN": "Minnesota",
    "WA": "Washington", "MA": "Massachusetts", "TX": "Texas"] . Remember, because
    you don’t have to rely on indices, your new dictionary item might appear anywhere
    in the dictionary.'
  id: totrans-10182
  prefs: []
  type: TYPE_NORMAL
  zh: '现在，当你查看 usStates 时，你会看到它更新为 ["MN": "Minnesota", "WA": "Washington", "MA": "Massachusetts",
    "TX": "Texas"]。记住，因为你不需要依赖索引，新的字典项可能出现在字典中的任何位置。'
- en: '**REMOVING ITEMS FROM A DICTIONARY**'
  id: totrans-10183
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**从字典中删除项**'
- en: Removing an item from a dictionary is quite simple; you do so by setting the
    value to nil . Because the values in dictionaries are returned as optionals, you
    don’t have to worry about nil causing any problems in your dictionary.
  id: totrans-10184
  prefs: []
  type: TYPE_NORMAL
  zh: 从字典中删除项非常简单；你只需将值设置为 nil。因为字典中的值是以可选值的形式返回的，所以你不必担心 nil 会在字典中引发任何问题。
- en: '![](Image00145.jpg)'
  id: totrans-10185
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00145.jpg)'
- en: 'You can see that after you remove the value at the key "MA" , usStates is updated
    to ["MN": "Minnesota", "WA": "Washington", "TX": "Texas"] . Remember that nil
    is special and means that there’s no value at all. That’s why you don’t see "MA":
    nil in our dictionary.'
  id: totrans-10186
  prefs: []
  type: TYPE_NORMAL
  zh: '你可以看到，在你删除键 "MA" 对应的值之后，usStates 更新为 ["MN": "Minnesota", "WA": "Washington",
    "TX": "Texas"]。记住，nil 是特殊的，意味着没有值。这就是为什么你在字典中看不到 "MA": nil。'
- en: '**REPLACING ITEMS IN A DICTIONARY**'
  id: totrans-10187
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**替换字典中的项**'
- en: 'Replacing an item in a dictionary is also easy. It works the same was as replacing
    an item in an array. You just set the item that you want to replace to something
    else. Say you create a dictionary of fruit colors:'
  id: totrans-10188
  prefs: []
  type: TYPE_NORMAL
  zh: 替换字典中的项也很简单。它的工作方式与替换数组中的项相同。你只需将要替换的项设置为其他值。假设你创建了一个水果颜色的字典：
- en: '![](Image00146.jpg)'
  id: totrans-10189
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00146.jpg)'
- en: At first we had the value "apple" for "red" , but then we decided that "raspberry"
    is a better fruit to use since sometimes apples are green or yellow. To replace
    "apple" with "raspberry" , we set colorFruits["red"] to its new value ➊ .
  id: totrans-10190
  prefs: []
  type: TYPE_NORMAL
  zh: 最开始，我们为 “red” 设置了值 "apple"，但是后来我们决定 "raspberry" 是更好的水果选择，因为有时苹果是绿色或黄色的。为了将 "apple"
    替换为 "raspberry"，我们将 `colorFruits["red"]` 设置为它的新值 ➊。
- en: You may remember that this is the same way we entered a new value into a dictionary.
    If the key already exists in the dictionary, then the value for that key is replaced.
    If the key doesn’t already exist, then the new key/value pair will be added to
    the dictionary.
  id: totrans-10191
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能还记得，这和我们将新值插入字典的方式是一样的。如果键已经存在于字典中，那么该键的值会被替换。如果键不存在，则会将新的键/值对添加到字典中。
- en: '![Image](Image00147.jpg)'
  id: totrans-10192
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00147.jpg)'
- en: '**USING DICTIONARY PROPERTIES**'
  id: totrans-10193
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**使用字典属性**'
- en: 'Like an array, a dictionary also has an isEmpty property and a count property.
    For example, the following code shows how you can use the isEmpty property to
    check if a dictionary is empty, and if it isn’t empty, the count property checks
    how many items you have. Imagine you have a basket of fruit for sale. You can
    use these properties to help you keep track of everything:'
  id: totrans-10194
  prefs: []
  type: TYPE_NORMAL
  zh: 像数组一样，字典也有 `isEmpty` 属性和 `count` 属性。例如，以下代码展示了如何使用 `isEmpty` 属性检查字典是否为空，如果字典不为空，`count`
    属性可以用来检查字典中有多少项。想象一下你有一个水果篮子要卖。你可以使用这些属性来帮助你跟踪所有的情况：
- en: '![Image](Image00148.jpg)'
  id: totrans-10195
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00148.jpg)'
- en: 'A dictionary also has two special properties: keys , which contains all of
    the dictionary’s keys, and values , which contains all of its values. We’ll use
    these two properties when we loop through the dictionary.'
  id: totrans-10196
  prefs: []
  type: TYPE_NORMAL
  zh: 字典还有两个特殊属性：`keys`，它包含字典的所有键；`values`，它包含字典的所有值。我们将在遍历字典时使用这两个属性。
- en: Let’s write some code that loops through our fruit baskets and prints the price
    of each fruit.
  id: totrans-10197
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们编写一些代码，遍历我们的水果篮子并打印每种水果的价格。
- en: '**LOOPING OVER A DICTIONARY**'
  id: totrans-10198
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**遍历字典**'
- en: 'You can loop through a dictionary using a for-in loop. Because each item has
    a key and a value, you can do this in two different ways. This is how to loop
    through a dictionary using its keys:'
  id: totrans-10199
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用 `for-in` 循环遍历字典。因为每个项目都有一个键和一个值，所以你可以用两种不同的方式来实现。以下是通过键遍历字典的方法：
- en: '![Image](Image00149.jpg)'
  id: totrans-10200
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00149.jpg)'
- en: Here we use the dictionary’s keys property ➊ to loop through fruitBasket and
    print its contents. We start by writing the keyword for , followed by a constant
    name fruit for the dictionary key, the keyword in , the dictionary name, a period,
    and keys .
  id: totrans-10201
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们使用字典的 `keys` 属性 ➊ 来遍历 `fruitBasket` 并打印其内容。我们首先写下关键字 `for`，然后是一个常量名 `fruit`
    用来表示字典键，接着是关键字 `in`，字典名，接着一个句点和 `keys`。
- en: Inside the braces of our for-in loop, we have access to both the key, which
    we call fruit ➋ , and the value at that key when we force-unwrap its contents
    with fruitBasket[fruit]! ➌ . That value will be the fruit’s price.
  id: totrans-10202
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `for-in` 循环的大括号内，我们可以访问键（我们称之为 `fruit` ➋）以及该键对应的值，通过强制解包其内容 `fruitBasket[fruit]!`
    ➌。这个值将是水果的价格。
- en: In this case, it’s safe to force-unwrap the value using an exclamation point
    because we know that the fruit key we’re using is definitely inside the dictionary.
  id: totrans-10203
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，使用感叹号强制解包值是安全的，因为我们知道我们使用的水果键肯定在字典中。
- en: Any code we put inside the for-in loop will run once for every key in our dictionary.
    So you should see the print statement display three times.
  id: totrans-10204
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在 `for-in` 循环内编写的任何代码都会针对字典中的每个键运行一次。因此，你应该看到 `print` 语句打印三次。
- en: 'We can also loop through the dictionary using its values property:'
  id: totrans-10205
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以使用字典的 `values` 属性遍历字典：
- en: '![Image](Image00150.jpg)'
  id: totrans-10206
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00150.jpg)'
- en: We use the same style of for-in loop, but now we use a constant to refer to
    each value, which we call price , in the values property. When looping through
    values, we don’t have access to the keys from inside the loop.
  id: totrans-10207
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用相同样式的 `for-in` 循环，但现在我们使用一个常量来表示 `values` 属性中的每个值，我们称之为 `price`。在遍历 `values`
    时，我们无法在循环内访问键。
- en: Another difference to note is that price is not an optional because it’s accessed
    directly as a value in the fruitBasket dictionary. That means we don’t have to
    unwrap it. You should still see the print statement printed three times. [Figure
    6-6](text00016.html#ch06fig6) shows the output of both loops.
  id: totrans-10208
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个需要注意的区别是，`price` 不是一个可选值，因为它是直接作为 `fruitBasket` 字典中的值来访问的。这意味着我们不需要解包它。你应该还是能看到
    `print` 语句被打印了三次。[图 6-6](text00016.html#ch06fig6) 展示了两个循环的输出结果。
- en: '![Image](Image00151.jpg)'
  id: totrans-10209
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00151.jpg)'
- en: '*Figure 6-6: Looping through the keys and values of a dictionary with a for-in
    loop*'
  id: totrans-10210
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 6-6：使用 for-in 循环遍历字典的键和值*'
- en: The order of your results might be slightly different from ours. That’s because
    the items in a dictionary aren’t in a numbered order like they are in an array!
    And because the order is not guaranteed, you might see a different order printed
    if you run the same code again.
  id: totrans-10211
  prefs: []
  type: TYPE_NORMAL
  zh: 你的结果顺序可能会与我们的略有不同。这是因为字典中的项目不像数组中的项目那样是按编号排序的！而且由于顺序无法保证，如果你再次运行相同的代码，可能会看到不同的顺序。
- en: '**WHAT YOU LEARNED**'
  id: totrans-10212
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**你学到了什么**'
- en: In this chapter, you learned how to store collections of items in an array and
    in a dictionary. To store items in an ordered list, you would use an array and
    look up each item by its index. If you wanted to store items by key instead, you
    would use a dictionary.
  id: totrans-10213
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一章中，你学会了如何将项目存储在数组和字典中。要将项目存储在有序列表中，你将使用数组，并通过索引查找每个项目。如果你想按键存储项目，则需要使用字典。
- en: Knowing about arrays and dictionaries and how to use them is a powerful building
    block for almost any programming language. Next we will learn about functions,
    another very powerful tool. Functions are blocks of code that you create and name
    to perform a specific job. After you have written a function, you can use its
    name to call it from almost anywhere in your program.
  id: totrans-10214
  prefs: []
  type: TYPE_NORMAL
  zh: 了解数组和字典以及如何使用它们，是几乎所有编程语言的一个强大基础。接下来，我们将学习函数，这是另一个非常强大的工具。函数是你创建并命名的代码块，用来执行特定的任务。编写函数后，你可以通过函数名从程序中的几乎任何地方调用它。
- en: 'Looking up a value in a dictionary is similar to how you access a value in
    an array except that you use a key inside the square brackets instead of an index,
    like this: usStates["TX"] .'
  id: totrans-10215
  prefs: []
  type: TYPE_NORMAL
  zh: 在字典中查找值类似于你如何访问数组中的值，只是你使用的是键而不是索引，如：usStates["TX"]。
- en: There is a big difference, however, in how Swift returns the values from a dictionary.
    When you access a value at an index of an array, you are simply given the value.
    When you access a value with a key in a dictionary, you are given an optional.
  id: totrans-10216
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，Swift 从字典中返回值的方式与数组有所不同。当你访问数组中的某个索引值时，你只会得到该值。当你使用键访问字典中的值时，你得到的是一个可选值。
- en: In [Chapter 5](text00015.html#ch05) , you learned that optionals might contain
    a value or might be nil . The reason Swift returns optionals when you’re looking
    up items in a dictionary is that the key you used might not exist in the dictionary,
    in which case there’s no value to access. Trying to access a value that doesn’t
    exist would give you a big fat error! To avoid that problem, Swift returns optionals.
    That means you need to unwrap any value you get out of a dictionary before you
    can do anything with it.
  id: totrans-10217
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第 5 章](text00015.html#ch05)中，你学到了可选值可能包含一个值，也可能是 nil。当你在字典中查找项目时，Swift 返回可选值的原因是，你使用的键可能不存在于字典中，在这种情况下就没有值可访问。试图访问一个不存在的值会给你一个严重的错误！为了避免这个问题，Swift
    返回可选值。这意味着你需要在对字典中的任何值进行操作之前，先解包它。
- en: 'To unwrap an optional, first you check whether it exists using an if-let statement,
    just like we did in [Chapter 5](text00015.html#ch05) . The following code shows
    you how to get a value out of a dictionary:'
  id: totrans-10218
  prefs: []
  type: TYPE_NORMAL
  zh: 要解包一个可选值，首先你需要使用 if-let 语句检查它是否存在，就像我们在[第 5 章](text00015.html#ch05)中做的那样。以下代码展示了如何从字典中获取一个值：
- en: '![Image](Image00143.jpg)'
  id: totrans-10219
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00143.jpg)'
- en: To retrieve "Texas" from the dictionary, we use if let to set a constant loneStarState
    to usStates["TX"] ➊ . Because we have this state in our dictionary, the line I
    have Texas in my dictionary. is printed. Next we try to access a state that is
    not in our dictionary by using the key usStates["FL"] ➋ . Thankfully, because
    we used an if-let statement, the program won’t crash when the computer can’t find
    this state. Instead, I don't have that state in my dictionary. is printed.
  id: totrans-10220
  prefs: []
  type: TYPE_NORMAL
  zh: 要从字典中获取“Texas”，我们使用 if let 将常量 loneStarState 设置为 usStates["TX"] ➊。因为我们的字典中包含这个州，所以打印了“我在字典中有
    Texas。”接下来，我们尝试通过使用键 usStates["FL"] ➋ 访问一个不在字典中的州。幸运的是，由于我们使用了 if-let 语句，当计算机找不到这个州时，程序不会崩溃。相反，打印了“我在字典中没有那个州。”
- en: '**ADDING ITEMS TO A DICTIONARY**'
  id: totrans-10221
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**向字典中添加项目**'
- en: 'To add an item to a dictionary, first write the name of your dictionary and
    assign the new item to the key you want it to have in the dictionary. Let’s add
    "Minnesota" to our usStates dictionary:'
  id: totrans-10222
  prefs: []
  type: TYPE_NORMAL
  zh: 要向字典中添加一个项目，首先写下字典的名称，并将新项目分配给你希望它在字典中具有的键。让我们将“Minnesota”添加到我们的 usStates 字典中：
- en: '![](Image00144.jpg)'
  id: totrans-10223
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00144.jpg)'
- en: 'Now when you look at usStates , you’ll see that it’s updated to ["MN": "Minnesota",
    "WA": "Washington", "MA": "Massachusetts", "TX": "Texas"] . Remember, because
    you don’t have to rely on indices, your new dictionary item might appear anywhere
    in the dictionary.'
  id: totrans-10224
  prefs: []
  type: TYPE_NORMAL
  zh: '现在，当你查看usStates时，你会看到它已更新为["MN": "Minnesota", "WA": "Washington", "MA": "Massachusetts",
    "TX": "Texas"]。记住，因为你不需要依赖索引，所以你的新字典项可能出现在字典的任何位置。'
- en: '**REMOVING ITEMS FROM A DICTIONARY**'
  id: totrans-10225
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**从字典中移除项目**'
- en: Removing an item from a dictionary is quite simple; you do so by setting the
    value to nil . Because the values in dictionaries are returned as optionals, you
    don’t have to worry about nil causing any problems in your dictionary.
  id: totrans-10226
  prefs: []
  type: TYPE_NORMAL
  zh: 从字典中移除一个项目非常简单；你只需要将其值设置为nil。因为字典中的值是以可选类型返回的，所以你无需担心nil会在字典中引起任何问题。
- en: '![](Image00145.jpg)'
  id: totrans-10227
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00145.jpg)'
- en: 'You can see that after you remove the value at the key "MA" , usStates is updated
    to ["MN": "Minnesota", "WA": "Washington", "TX": "Texas"] . Remember that nil
    is special and means that there’s no value at all. That’s why you don’t see "MA":
    nil in our dictionary.'
  id: totrans-10228
  prefs: []
  type: TYPE_NORMAL
  zh: '你可以看到，在你移除键"MA"的值之后，usStates已更新为["MN": "Minnesota", "WA": "Washington", "TX":
    "Texas"]。记住，nil是特殊的，意味着没有值。因此，你不会在我们的字典中看到"MA": nil。'
- en: '**REPLACING ITEMS IN A DICTIONARY**'
  id: totrans-10229
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**替换字典中的项目**'
- en: 'Replacing an item in a dictionary is also easy. It works the same was as replacing
    an item in an array. You just set the item that you want to replace to something
    else. Say you create a dictionary of fruit colors:'
  id: totrans-10230
  prefs: []
  type: TYPE_NORMAL
  zh: 替换字典中的项目也很简单。它的工作方式与替换数组中的项目相同。你只需要将你想要替换的项目设置为其他值。假设你创建了一个水果颜色的字典：
- en: '![](Image00146.jpg)'
  id: totrans-10231
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00146.jpg)'
- en: At first we had the value "apple" for "red" , but then we decided that "raspberry"
    is a better fruit to use since sometimes apples are green or yellow. To replace
    "apple" with "raspberry" , we set colorFruits["red"] to its new value ➊ .
  id: totrans-10232
  prefs: []
  type: TYPE_NORMAL
  zh: 起初我们为"red"键设置了值"apple"，但后来我们决定用"raspberry"替换它，因为有时苹果是绿色或黄色的。为了将"apple"替换为"raspberry"，我们将colorFruits["red"]设置为它的新值
    ➊。
- en: You may remember that this is the same way we entered a new value into a dictionary.
    If the key already exists in the dictionary, then the value for that key is replaced.
    If the key doesn’t already exist, then the new key/value pair will be added to
    the dictionary.
  id: totrans-10233
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能还记得，这是我们将新值添加到字典中的相同方式。如果该键已经存在于字典中，那么该键的值将被替换。如果该键不存在，那么新的键/值对将被添加到字典中。
- en: '![Image](Image00147.jpg)'
  id: totrans-10234
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Image00147.jpg)'
- en: '**USING DICTIONARY PROPERTIES**'
  id: totrans-10235
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**使用字典属性**'
- en: 'Like an array, a dictionary also has an isEmpty property and a count property.
    For example, the following code shows how you can use the isEmpty property to
    check if a dictionary is empty, and if it isn’t empty, the count property checks
    how many items you have. Imagine you have a basket of fruit for sale. You can
    use these properties to help you keep track of everything:'
  id: totrans-10236
  prefs: []
  type: TYPE_NORMAL
  zh: 与数组一样，字典也有isEmpty属性和count属性。例如，以下代码展示了如何使用isEmpty属性来检查字典是否为空，如果不为空，则count属性可以检查你有多少项。假设你有一个待售的水果篮。你可以使用这些属性来帮助你跟踪所有内容：
- en: '![Image](Image00148.jpg)'
  id: totrans-10237
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Image00148.jpg)'
- en: 'A dictionary also has two special properties: keys , which contains all of
    the dictionary’s keys, and values , which contains all of its values. We’ll use
    these two properties when we loop through the dictionary.'
  id: totrans-10238
  prefs: []
  type: TYPE_NORMAL
  zh: 字典还有两个特殊的属性：keys，包含字典的所有键，以及values，包含所有值。当我们遍历字典时，我们将使用这两个属性。
- en: Let’s write some code that loops through our fruit baskets and prints the price
    of each fruit.
  id: totrans-10239
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们编写一些代码，遍历我们的水果篮并打印每种水果的价格。
- en: '**LOOPING OVER A DICTIONARY**'
  id: totrans-10240
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**遍历字典**'
- en: 'You can loop through a dictionary using a for-in loop. Because each item has
    a key and a value, you can do this in two different ways. This is how to loop
    through a dictionary using its keys:'
  id: totrans-10241
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用for-in循环遍历字典。因为每个项目都有一个键和值，所以你可以用两种不同的方式来遍历字典。这是使用键遍历字典的方法：
- en: '![Image](Image00149.jpg)'
  id: totrans-10242
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Image00149.jpg)'
- en: Here we use the dictionary’s keys property ➊ to loop through fruitBasket and
    print its contents. We start by writing the keyword for , followed by a constant
    name fruit for the dictionary key, the keyword in , the dictionary name, a period,
    and keys .
  id: totrans-10243
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们使用字典的keys属性 ➊ 来遍历fruitBasket并打印其内容。我们从写出关键字for开始，后跟字典键的常量名称fruit，再写in，字典名称，句点，最后是keys。
- en: Inside the braces of our for-in loop, we have access to both the key, which
    we call fruit ➋ , and the value at that key when we force-unwrap its contents
    with fruitBasket[fruit]! ➌ . That value will be the fruit’s price.
  id: totrans-10244
  prefs: []
  type: TYPE_NORMAL
  zh: 在 for-in 循环的大括号内部，我们可以访问键，我们称之为 fruit ➋，以及通过 fruitBasket[fruit]! ➌ 强制解包其内容后得到的键对应的值。这个值就是水果的价格。
- en: In this case, it’s safe to force-unwrap the value using an exclamation point
    because we know that the fruit key we’re using is definitely inside the dictionary.
  id: totrans-10245
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，由于我们知道正在使用的 fruit 键一定在字典中，因此可以安全地使用感叹号强制解包值。
- en: Any code we put inside the for-in loop will run once for every key in our dictionary.
    So you should see the print statement display three times.
  id: totrans-10246
  prefs: []
  type: TYPE_NORMAL
  zh: 我们放在 for-in 循环中的任何代码都会对字典中的每一个键执行一次。因此，你应该看到打印语句显示三次。
- en: 'We can also loop through the dictionary using its values property:'
  id: totrans-10247
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以通过字典的 values 属性来循环遍历字典：
- en: '![Image](Image00150.jpg)'
  id: totrans-10248
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00150.jpg)'
- en: We use the same style of for-in loop, but now we use a constant to refer to
    each value, which we call price , in the values property. When looping through
    values, we don’t have access to the keys from inside the loop.
  id: totrans-10249
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用相同的 for-in 循环样式，但现在我们使用常量来引用 values 属性中的每个值，我们称之为 price。在遍历值时，我们无法从循环内部访问键。
- en: Another difference to note is that price is not an optional because it’s accessed
    directly as a value in the fruitBasket dictionary. That means we don’t have to
    unwrap it. You should still see the print statement printed three times. [Figure
    6-6](text00016.html#ch06fig6) shows the output of both loops.
  id: totrans-10250
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个需要注意的区别是，价格不是一个可选值，因为它直接作为值从 fruitBasket 字典中访问。这意味着我们不需要对它进行解包。你应该仍然会看到打印语句显示三次。[图6-6](text00016.html#ch06fig6)显示了两个循环的输出结果。
- en: '![Image](Image00151.jpg)'
  id: totrans-10251
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00151.jpg)'
- en: '*Figure 6-6: Looping through the keys and values of a dictionary with a for-in
    loop*'
  id: totrans-10252
  prefs: []
  type: TYPE_NORMAL
  zh: '*图6-6：使用 for-in 循环遍历字典的键和值*'
- en: The order of your results might be slightly different from ours. That’s because
    the items in a dictionary aren’t in a numbered order like they are in an array!
    And because the order is not guaranteed, you might see a different order printed
    if you run the same code again.
  id: totrans-10253
  prefs: []
  type: TYPE_NORMAL
  zh: 你的结果顺序可能与我们的稍有不同。这是因为字典中的项不像数组中的项那样按编号顺序排列！而且由于顺序不保证，如果你重新运行相同的代码，你可能会看到不同的顺序。
- en: '**WHAT YOU LEARNED**'
  id: totrans-10254
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**你学到了什么**'
- en: In this chapter, you learned how to store collections of items in an array and
    in a dictionary. To store items in an ordered list, you would use an array and
    look up each item by its index. If you wanted to store items by key instead, you
    would use a dictionary.
  id: totrans-10255
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你学习了如何在数组和字典中存储项。要将项存储在有序列表中，你应该使用数组并通过索引查找每个项。如果你想根据键存储项，则应该使用字典。
- en: Knowing about arrays and dictionaries and how to use them is a powerful building
    block for almost any programming language. Next we will learn about functions,
    another very powerful tool. Functions are blocks of code that you create and name
    to perform a specific job. After you have written a function, you can use its
    name to call it from almost anywhere in your program.
  id: totrans-10256
  prefs: []
  type: TYPE_NORMAL
  zh: 了解数组和字典以及如何使用它们，是几乎所有编程语言的强大构建块。接下来，我们将学习函数，这是另一种非常强大的工具。函数是你创建并命名的代码块，用于执行特定的任务。在你编写了一个函数之后，你可以使用它的名称在程序的几乎任何地方调用它。
- en: There is a big difference, however, in how Swift returns the values from a dictionary.
    When you access a value at an index of an array, you are simply given the value.
    When you access a value with a key in a dictionary, you are given an optional.
  id: totrans-10257
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，Swift 从字典中返回值的方式与数组有所不同。当你访问数组中的某个索引的值时，你直接得到该值。而当你通过键访问字典中的某个值时，你会得到一个可选值。
- en: In [Chapter 5](text00015.html#ch05) , you learned that optionals might contain
    a value or might be nil . The reason Swift returns optionals when you’re looking
    up items in a dictionary is that the key you used might not exist in the dictionary,
    in which case there’s no value to access. Trying to access a value that doesn’t
    exist would give you a big fat error! To avoid that problem, Swift returns optionals.
    That means you need to unwrap any value you get out of a dictionary before you
    can do anything with it.
  id: totrans-10258
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第5章](text00015.html#ch05)中，你学习了可选值可能包含一个值，也可能是 nil。当你查找字典中的项时，Swift 返回可选值的原因是你使用的键可能在字典中不存在，这种情况下没有值可访问。尝试访问一个不存在的值会导致一个大的错误！为避免这个问题，Swift
    返回可选值。这意味着你需要在使用字典中取出的任何值之前进行解包。
- en: 'To unwrap an optional, first you check whether it exists using an if-let statement,
    just like we did in [Chapter 5](text00015.html#ch05) . The following code shows
    you how to get a value out of a dictionary:'
  id: totrans-10259
  prefs: []
  type: TYPE_NORMAL
  zh: 要解包一个可选项，首先你需要使用 if-let 语句检查它是否存在，就像我们在[第5章](text00015.html#ch05)中做的那样。以下代码展示了如何从字典中获取值：
- en: '![Image](Image00143.jpg)'
  id: totrans-10260
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00143.jpg)'
- en: To retrieve "Texas" from the dictionary, we use if let to set a constant loneStarState
    to usStates["TX"] ➊ . Because we have this state in our dictionary, the line I
    have Texas in my dictionary. is printed. Next we try to access a state that is
    not in our dictionary by using the key usStates["FL"] ➋ . Thankfully, because
    we used an if-let statement, the program won’t crash when the computer can’t find
    this state. Instead, I don't have that state in my dictionary. is printed.
  id: totrans-10261
  prefs: []
  type: TYPE_NORMAL
  zh: 要从字典中获取"德克萨斯州"，我们使用 if-let 语句将常量 loneStarState 设置为 usStates["TX"] ➊。因为我们在字典中有这个州，所以会打印出“我在字典中有德克萨斯州。”接下来，我们尝试访问一个不在字典中的州，通过使用键
    usStates["FL"] ➋。幸运的是，由于我们使用了 if-let 语句，当计算机找不到这个州时，程序不会崩溃。相反，会打印出“我在字典中没有这个州。”
- en: '**ADDING ITEMS TO A DICTIONARY**'
  id: totrans-10262
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**向字典中添加项**'
- en: 'To add an item to a dictionary, first write the name of your dictionary and
    assign the new item to the key you want it to have in the dictionary. Let’s add
    "Minnesota" to our usStates dictionary:'
  id: totrans-10263
  prefs: []
  type: TYPE_NORMAL
  zh: 要向字典中添加一项，首先写出字典的名称，并将新项分配给你希望它在字典中拥有的键。让我们向 usStates 字典中添加"明尼苏达"：
- en: '![](Image00144.jpg)'
  id: totrans-10264
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00144.jpg)'
- en: 'Now when you look at usStates , you’ll see that it’s updated to ["MN": "Minnesota",
    "WA": "Washington", "MA": "Massachusetts", "TX": "Texas"] . Remember, because
    you don’t have to rely on indices, your new dictionary item might appear anywhere
    in the dictionary.'
  id: totrans-10265
  prefs: []
  type: TYPE_NORMAL
  zh: '现在，当你查看 usStates 时，你会看到它已经更新为["MN": "明尼苏达", "WA": "华盛顿", "MA": "马萨诸塞", "TX":
    "德克萨斯州"]。记住，因为你不需要依赖索引，所以新的字典项可能出现在字典的任何位置。'
- en: '**REMOVING ITEMS FROM A DICTIONARY**'
  id: totrans-10266
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**从字典中删除项**'
- en: Removing an item from a dictionary is quite simple; you do so by setting the
    value to nil . Because the values in dictionaries are returned as optionals, you
    don’t have to worry about nil causing any problems in your dictionary.
  id: totrans-10267
  prefs: []
  type: TYPE_NORMAL
  zh: 从字典中删除一项非常简单；你只需将值设置为 nil。因为字典中的值是以可选项的形式返回的，所以你不必担心 nil 会导致字典出现任何问题。
- en: '![](Image00145.jpg)'
  id: totrans-10268
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00145.jpg)'
- en: 'You can see that after you remove the value at the key "MA" , usStates is updated
    to ["MN": "Minnesota", "WA": "Washington", "TX": "Texas"] . Remember that nil
    is special and means that there’s no value at all. That’s why you don’t see "MA":
    nil in our dictionary.'
  id: totrans-10269
  prefs: []
  type: TYPE_NORMAL
  zh: '你可以看到，当你删除键"MA"处的值后，usStates 更新为["MN": "明尼苏达", "WA": "华盛顿", "TX": "德克萨斯州"]。记住，nil
    是特别的，表示根本没有值。这就是为什么你在字典中看不到"MA": nil。'
- en: '**REPLACING ITEMS IN A DICTIONARY**'
  id: totrans-10270
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**替换字典中的项**'
- en: 'Replacing an item in a dictionary is also easy. It works the same was as replacing
    an item in an array. You just set the item that you want to replace to something
    else. Say you create a dictionary of fruit colors:'
  id: totrans-10271
  prefs: []
  type: TYPE_NORMAL
  zh: 替换字典中的项也很简单。它的工作原理和替换数组中的项一样。你只需要将你想替换的项设置为其他值。比如，你创建了一个水果颜色的字典：
- en: '![](Image00146.jpg)'
  id: totrans-10272
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00146.jpg)'
- en: At first we had the value "apple" for "red" , but then we decided that "raspberry"
    is a better fruit to use since sometimes apples are green or yellow. To replace
    "apple" with "raspberry" , we set colorFruits["red"] to its new value ➊ .
  id: totrans-10273
  prefs: []
  type: TYPE_NORMAL
  zh: 最初我们为"红色"设置了"苹果"的值，但后来我们决定"树莓"是更好的水果，因为有时候苹果是绿色或黄色的。为了将"苹果"替换为"树莓"，我们将 colorFruits["红色"]
    设置为它的新值 ➊。
- en: You may remember that this is the same way we entered a new value into a dictionary.
    If the key already exists in the dictionary, then the value for that key is replaced.
    If the key doesn’t already exist, then the new key/value pair will be added to
    the dictionary.
  id: totrans-10274
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能记得，这是我们向字典中添加新值的方式。如果键已经存在于字典中，则该键的值会被替换。如果键不存在，则新的键/值对会被添加到字典中。
- en: '![Image](Image00147.jpg)'
  id: totrans-10275
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00147.jpg)'
- en: '**USING DICTIONARY PROPERTIES**'
  id: totrans-10276
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**使用字典属性**'
- en: 'Like an array, a dictionary also has an isEmpty property and a count property.
    For example, the following code shows how you can use the isEmpty property to
    check if a dictionary is empty, and if it isn’t empty, the count property checks
    how many items you have. Imagine you have a basket of fruit for sale. You can
    use these properties to help you keep track of everything:'
  id: totrans-10277
  prefs: []
  type: TYPE_NORMAL
  zh: 和数组一样，字典也有 isEmpty 属性和 count 属性。例如，以下代码展示了如何使用 isEmpty 属性检查字典是否为空，如果不为空，则使用
    count 属性检查字典中的项数。假设你有一个待售的水果篮子。你可以使用这些属性帮助你跟踪所有的水果：
- en: '![Image](Image00148.jpg)'
  id: totrans-10278
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00148.jpg)'
- en: 'A dictionary also has two special properties: keys , which contains all of
    the dictionary’s keys, and values , which contains all of its values. We’ll use
    these two properties when we loop through the dictionary.'
  id: totrans-10279
  prefs: []
  type: TYPE_NORMAL
  zh: 字典还有两个特殊的属性：keys ，包含字典中的所有键，以及 values ，包含字典中的所有值。当我们遍历字典时，将使用这两个属性。
- en: Let’s write some code that loops through our fruit baskets and prints the price
    of each fruit.
  id: totrans-10280
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们编写一些代码，遍历我们的水果篮并打印每种水果的价格。
- en: '**LOOPING OVER A DICTIONARY**'
  id: totrans-10281
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**遍历字典**'
- en: 'You can loop through a dictionary using a for-in loop. Because each item has
    a key and a value, you can do this in two different ways. This is how to loop
    through a dictionary using its keys:'
  id: totrans-10282
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过 `for-in` 循环遍历字典。由于每个项目都有一个键和一个值，你可以用两种不同的方式来实现。以下是使用键遍历字典的方法：
- en: '![Image](Image00149.jpg)'
  id: totrans-10283
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00149.jpg)'
- en: Here we use the dictionary’s keys property ➊ to loop through fruitBasket and
    print its contents. We start by writing the keyword for , followed by a constant
    name fruit for the dictionary key, the keyword in , the dictionary name, a period,
    and keys .
  id: totrans-10284
  prefs: []
  type: TYPE_NORMAL
  zh: 这里我们使用字典的 keys 属性 ➊ 来遍历 `fruitBasket` 并打印其内容。我们从写关键字 `for` 开始，接着是字典键的常量名 `fruit`，然后是关键字
    `in`，字典名，句点，最后是 `keys`。
- en: Inside the braces of our for-in loop, we have access to both the key, which
    we call fruit ➋ , and the value at that key when we force-unwrap its contents
    with fruitBasket[fruit]! ➌ . That value will be the fruit’s price.
  id: totrans-10285
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `for-in` 循环的花括号内部，我们可以访问到键（我们称之为 fruit ➋ ）以及该键对应的值，当我们强制展开其内容时，使用 `fruitBasket[fruit]!`
    ➌ 。这个值就是水果的价格。
- en: In this case, it’s safe to force-unwrap the value using an exclamation point
    because we know that the fruit key we’re using is definitely inside the dictionary.
  id: totrans-10286
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，使用感叹号强制展开值是安全的，因为我们知道我们使用的水果键肯定在字典中。
- en: Any code we put inside the for-in loop will run once for every key in our dictionary.
    So you should see the print statement display three times.
  id: totrans-10287
  prefs: []
  type: TYPE_NORMAL
  zh: 我们放在 `for-in` 循环内部的任何代码都会针对字典中的每个键执行一次。所以你应该能看到打印语句显示三次。
- en: 'We can also loop through the dictionary using its values property:'
  id: totrans-10288
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以使用字典的 values 属性遍历字典：
- en: '![Image](Image00150.jpg)'
  id: totrans-10289
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00150.jpg)'
- en: We use the same style of for-in loop, but now we use a constant to refer to
    each value, which we call price , in the values property. When looping through
    values, we don’t have access to the keys from inside the loop.
  id: totrans-10290
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用相同风格的 `for-in` 循环，但这次我们使用常量来引用值，这个值我们称之为 price ，它在 values 属性中。当遍历值时，我们无法从循环内部访问键。
- en: Another difference to note is that price is not an optional because it’s accessed
    directly as a value in the fruitBasket dictionary. That means we don’t have to
    unwrap it. You should still see the print statement printed three times. [Figure
    6-6](text00016.html#ch06fig6) shows the output of both loops.
  id: totrans-10291
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个需要注意的区别是，price 不是一个可选值，因为它是直接作为 `fruitBasket` 字典中的值访问的。这意味着我们不需要解包它。你应该仍然能看到打印语句被打印三次。[图6-6](text00016.html#ch06fig6)
    展示了两个循环的输出结果。
- en: '![Image](Image00151.jpg)'
  id: totrans-10292
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00151.jpg)'
- en: '*Figure 6-6: Looping through the keys and values of a dictionary with a for-in
    loop*'
  id: totrans-10293
  prefs: []
  type: TYPE_NORMAL
  zh: '*图6-6：使用 `for-in` 循环遍历字典的键和值*'
- en: The order of your results might be slightly different from ours. That’s because
    the items in a dictionary aren’t in a numbered order like they are in an array!
    And because the order is not guaranteed, you might see a different order printed
    if you run the same code again.
  id: totrans-10294
  prefs: []
  type: TYPE_NORMAL
  zh: 你的结果顺序可能会与我们的稍有不同。这是因为字典中的项目不像数组那样是按顺序排列的！由于顺序没有保证，因此如果你再次运行相同的代码，可能会看到不同的输出顺序。
- en: '**WHAT YOU LEARNED**'
  id: totrans-10295
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**你学到了什么**'
- en: In this chapter, you learned how to store collections of items in an array and
    in a dictionary. To store items in an ordered list, you would use an array and
    look up each item by its index. If you wanted to store items by key instead, you
    would use a dictionary.
  id: totrans-10296
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你学会了如何将项目集合存储在数组和字典中。为了将项目存储在有序列表中，你会使用数组，并通过索引查找每个项目。如果你想按键存储项目，你会使用字典。
- en: Knowing about arrays and dictionaries and how to use them is a powerful building
    block for almost any programming language. Next we will learn about functions,
    another very powerful tool. Functions are blocks of code that you create and name
    to perform a specific job. After you have written a function, you can use its
    name to call it from almost anywhere in your program.
  id: totrans-10297
  prefs: []
  type: TYPE_NORMAL
  zh: 了解数组和字典以及如何使用它们，是几乎所有编程语言的强大构建块。接下来我们将学习函数，这是另一种非常强大的工具。函数是你创建并命名的代码块，用于执行特定任务。写完一个函数后，你可以在程序的几乎任何地方通过调用其名称来使用它。
- en: In [Chapter 5](text00015.html#ch05) , you learned that optionals might contain
    a value or might be nil . The reason Swift returns optionals when you’re looking
    up items in a dictionary is that the key you used might not exist in the dictionary,
    in which case there’s no value to access. Trying to access a value that doesn’t
    exist would give you a big fat error! To avoid that problem, Swift returns optionals.
    That means you need to unwrap any value you get out of a dictionary before you
    can do anything with it.
  id: totrans-10298
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第5章](text00015.html#ch05)中，你学到了可选值可能包含一个值，也可能是 nil 。Swift 在查找字典中的项时返回可选值的原因是，你使用的键可能在字典中不存在，在这种情况下就没有值可以访问。尝试访问一个不存在的值会导致一个严重错误！为了避免这个问题，Swift
    返回可选值。这意味着你在对字典中的任何值进行操作之前，必须先解包它。
- en: 'To unwrap an optional, first you check whether it exists using an if-let statement,
    just like we did in [Chapter 5](text00015.html#ch05) . The following code shows
    you how to get a value out of a dictionary:'
  id: totrans-10299
  prefs: []
  type: TYPE_NORMAL
  zh: 要解包一个可选值，首先你需要使用 if-let 语句检查它是否存在，就像我们在[第5章](text00015.html#ch05)中所做的那样。以下代码展示了如何从字典中获取一个值：
- en: '![Image](Image00143.jpg)'
  id: totrans-10300
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00143.jpg)'
- en: To retrieve "Texas" from the dictionary, we use if let to set a constant loneStarState
    to usStates["TX"] ➊ . Because we have this state in our dictionary, the line I
    have Texas in my dictionary. is printed. Next we try to access a state that is
    not in our dictionary by using the key usStates["FL"] ➋ . Thankfully, because
    we used an if-let statement, the program won’t crash when the computer can’t find
    this state. Instead, I don't have that state in my dictionary. is printed.
  id: totrans-10301
  prefs: []
  type: TYPE_NORMAL
  zh: 要从字典中获取 "Texas"，我们使用 if let 将常量 loneStarState 设置为 usStates["TX"] ➊ 。因为我们在字典中有这个州，所以下面的
    "I have Texas in my dictionary." 会被打印出来。接下来，我们尝试通过使用键 usStates["FL"] ➋ 来访问字典中不存在的一个州。幸运的是，由于我们使用了
    if-let 语句，当计算机找不到这个州时，程序不会崩溃。相反，"I don't have that state in my dictionary." 会被打印出来。
- en: '**ADDING ITEMS TO A DICTIONARY**'
  id: totrans-10302
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**向字典中添加项目**'
- en: 'To add an item to a dictionary, first write the name of your dictionary and
    assign the new item to the key you want it to have in the dictionary. Let’s add
    "Minnesota" to our usStates dictionary:'
  id: totrans-10303
  prefs: []
  type: TYPE_NORMAL
  zh: 要向字典中添加项目，首先写出字典的名称，并将新项目分配给你希望它拥有的键。让我们将 "Minnesota" 添加到我们的 usStates 字典中：
- en: '![](Image00144.jpg)'
  id: totrans-10304
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00144.jpg)'
- en: 'Now when you look at usStates , you’ll see that it’s updated to ["MN": "Minnesota",
    "WA": "Washington", "MA": "Massachusetts", "TX": "Texas"] . Remember, because
    you don’t have to rely on indices, your new dictionary item might appear anywhere
    in the dictionary.'
  id: totrans-10305
  prefs: []
  type: TYPE_NORMAL
  zh: '现在，当你查看 usStates 时，你会看到它已更新为 ["MN": "Minnesota", "WA": "Washington", "MA":
    "Massachusetts", "TX": "Texas"] 。记住，因为你不需要依赖索引，所以新的字典项可能出现在字典的任何位置。'
- en: '**REMOVING ITEMS FROM A DICTIONARY**'
  id: totrans-10306
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**从字典中删除项目**'
- en: Removing an item from a dictionary is quite simple; you do so by setting the
    value to nil . Because the values in dictionaries are returned as optionals, you
    don’t have to worry about nil causing any problems in your dictionary.
  id: totrans-10307
  prefs: []
  type: TYPE_NORMAL
  zh: 从字典中删除一个项目非常简单；你只需要将该值设置为 nil 。因为字典中的值是以可选值的形式返回的，所以你不必担心 nil 会导致字典出现任何问题。
- en: '![](Image00145.jpg)'
  id: totrans-10308
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00145.jpg)'
- en: 'You can see that after you remove the value at the key "MA" , usStates is updated
    to ["MN": "Minnesota", "WA": "Washington", "TX": "Texas"] . Remember that nil
    is special and means that there’s no value at all. That’s why you don’t see "MA":
    nil in our dictionary.'
  id: totrans-10309
  prefs: []
  type: TYPE_NORMAL
  zh: '你可以看到，在删除键 "MA" 对应的值后，usStates 被更新为 ["MN": "Minnesota", "WA": "Washington",
    "TX": "Texas"] 。记住，nil 是特殊的，表示没有任何值。这就是为什么你在字典中看不到 "MA": nil 的原因。'
- en: '**REPLACING ITEMS IN A DICTIONARY**'
  id: totrans-10310
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**替换字典中的项目**'
- en: 'Replacing an item in a dictionary is also easy. It works the same was as replacing
    an item in an array. You just set the item that you want to replace to something
    else. Say you create a dictionary of fruit colors:'
  id: totrans-10311
  prefs: []
  type: TYPE_NORMAL
  zh: 替换字典中的项目也很简单。它的工作方式与替换数组中的项目相同。你只需将你想要替换的项目设置为其他值。假设你创建了一个关于水果颜色的字典：
- en: '![](Image00146.jpg)'
  id: totrans-10312
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00146.jpg)'
- en: At first we had the value "apple" for "red" , but then we decided that "raspberry"
    is a better fruit to use since sometimes apples are green or yellow. To replace
    "apple" with "raspberry" , we set colorFruits["red"] to its new value ➊ .
  id: totrans-10313
  prefs: []
  type: TYPE_NORMAL
  zh: 一开始我们为“red”设定的值是“apple”，但后来我们决定使用“raspberry”作为更好的水果，因为有时候苹果是绿色或黄色的。为了将“apple”替换成“raspberry”，我们将colorFruits["red"]设置为它的新值
    ➊。
- en: You may remember that this is the same way we entered a new value into a dictionary.
    If the key already exists in the dictionary, then the value for that key is replaced.
    If the key doesn’t already exist, then the new key/value pair will be added to
    the dictionary.
  id: totrans-10314
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能记得这与我们将新值插入字典的方式相同。如果键已经存在于字典中，那么该键的值将被替换。如果键不存在，新的键值对将会被添加到字典中。
- en: '![Image](Image00147.jpg)'
  id: totrans-10315
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00147.jpg)'
- en: '**USING DICTIONARY PROPERTIES**'
  id: totrans-10316
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**使用字典属性**'
- en: 'Like an array, a dictionary also has an isEmpty property and a count property.
    For example, the following code shows how you can use the isEmpty property to
    check if a dictionary is empty, and if it isn’t empty, the count property checks
    how many items you have. Imagine you have a basket of fruit for sale. You can
    use these properties to help you keep track of everything:'
  id: totrans-10317
  prefs: []
  type: TYPE_NORMAL
  zh: 和数组一样，字典也有isEmpty属性和count属性。例如，下面的代码展示了如何使用isEmpty属性来检查字典是否为空，如果字典不为空，则count属性会检查字典中有多少项。假设你有一个水果篮子在出售，你可以使用这些属性来帮助你跟踪所有的内容：
- en: '![Image](Image00148.jpg)'
  id: totrans-10318
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00148.jpg)'
- en: 'A dictionary also has two special properties: keys , which contains all of
    the dictionary’s keys, and values , which contains all of its values. We’ll use
    these two properties when we loop through the dictionary.'
  id: totrans-10319
  prefs: []
  type: TYPE_NORMAL
  zh: 字典还有两个特殊的属性：keys，它包含字典的所有键，和values，它包含字典的所有值。我们将在遍历字典时使用这两个属性。
- en: Let’s write some code that loops through our fruit baskets and prints the price
    of each fruit.
  id: totrans-10320
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们写一些代码，遍历我们的水果篮子并打印每个水果的价格。
- en: '**LOOPING OVER A DICTIONARY**'
  id: totrans-10321
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**遍历字典**'
- en: 'You can loop through a dictionary using a for-in loop. Because each item has
    a key and a value, you can do this in two different ways. This is how to loop
    through a dictionary using its keys:'
  id: totrans-10322
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用for-in循环遍历字典。由于每个项都有一个键和值，因此你可以用两种不同的方式来实现。下面是如何使用字典的键来遍历字典：
- en: '![Image](Image00149.jpg)'
  id: totrans-10323
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00149.jpg)'
- en: Here we use the dictionary’s keys property ➊ to loop through fruitBasket and
    print its contents. We start by writing the keyword for , followed by a constant
    name fruit for the dictionary key, the keyword in , the dictionary name, a period,
    and keys .
  id: totrans-10324
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们使用字典的keys属性 ➊ 遍历fruitBasket并打印其内容。我们从写关键字for开始，接着是常量名fruit代表字典的键，然后是关键字in，字典名，一个点，最后是keys。
- en: Inside the braces of our for-in loop, we have access to both the key, which
    we call fruit ➋ , and the value at that key when we force-unwrap its contents
    with fruitBasket[fruit]! ➌ . That value will be the fruit’s price.
  id: totrans-10325
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的for-in循环的花括号内部，我们可以访问到键，我们称其为fruit ➋，以及通过强制解包其内容（使用fruitBasket[fruit]! ➌）时该键的值。这个值就是水果的价格。
- en: In this case, it’s safe to force-unwrap the value using an exclamation point
    because we know that the fruit key we’re using is definitely inside the dictionary.
  id: totrans-10326
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，使用感叹号强制解包值是安全的，因为我们知道我们使用的水果键一定在字典中。
- en: Any code we put inside the for-in loop will run once for every key in our dictionary.
    So you should see the print statement display three times.
  id: totrans-10327
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在for-in循环中放置的任何代码都会为字典中的每个键执行一次。因此，你应该看到打印语句显示三次。
- en: 'We can also loop through the dictionary using its values property:'
  id: totrans-10328
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以通过字典的值属性来遍历字典：
- en: '![Image](Image00150.jpg)'
  id: totrans-10329
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00150.jpg)'
- en: We use the same style of for-in loop, but now we use a constant to refer to
    each value, which we call price , in the values property. When looping through
    values, we don’t have access to the keys from inside the loop.
  id: totrans-10330
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用相同样式的for-in循环，但这次我们使用常量来引用每个值，我们将其称为price，来自values属性。在遍历values时，我们无法从循环内部访问键。
- en: Another difference to note is that price is not an optional because it’s accessed
    directly as a value in the fruitBasket dictionary. That means we don’t have to
    unwrap it. You should still see the print statement printed three times. [Figure
    6-6](text00016.html#ch06fig6) shows the output of both loops.
  id: totrans-10331
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个需要注意的区别是，price不是可选的，因为它是直接作为值从fruitBasket字典中访问的。这意味着我们不需要解包它。你仍然应该看到打印语句打印三次。[图6-6](text00016.html#ch06fig6)展示了两个循环的输出结果。
- en: '![Image](Image00151.jpg)'
  id: totrans-10332
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00151.jpg)'
- en: '*Figure 6-6: Looping through the keys and values of a dictionary with a for-in
    loop*'
  id: totrans-10333
  prefs: []
  type: TYPE_NORMAL
  zh: '*图6-6：使用 for-in 循环遍历字典的键和值*'
- en: The order of your results might be slightly different from ours. That’s because
    the items in a dictionary aren’t in a numbered order like they are in an array!
    And because the order is not guaranteed, you might see a different order printed
    if you run the same code again.
  id: totrans-10334
  prefs: []
  type: TYPE_NORMAL
  zh: 你的结果顺序可能会与我们的稍有不同。这是因为字典中的项不像数组那样按编号顺序排列！并且由于顺序并不保证，所以如果你再次运行相同的代码，你可能会看到不同的输出顺序。
- en: '**WHAT YOU LEARNED**'
  id: totrans-10335
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**你学到了什么**'
- en: In this chapter, you learned how to store collections of items in an array and
    in a dictionary. To store items in an ordered list, you would use an array and
    look up each item by its index. If you wanted to store items by key instead, you
    would use a dictionary.
  id: totrans-10336
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你学习了如何在数组和字典中存储项目。要存储按顺序排列的项目，你会使用数组，并通过索引查找每个项。如果你想按键存储项目，你将使用字典。
- en: Knowing about arrays and dictionaries and how to use them is a powerful building
    block for almost any programming language. Next we will learn about functions,
    another very powerful tool. Functions are blocks of code that you create and name
    to perform a specific job. After you have written a function, you can use its
    name to call it from almost anywhere in your program.
  id: totrans-10337
  prefs: []
  type: TYPE_NORMAL
  zh: 了解数组和字典以及如何使用它们，是几乎所有编程语言中一个强大的构建块。接下来，我们将学习函数，这是另一个非常强大的工具。函数是你创建并命名的代码块，用于执行特定的任务。编写完函数后，你可以通过它的名称在程序中的几乎任何地方调用它。
- en: 'To unwrap an optional, first you check whether it exists using an if-let statement,
    just like we did in [Chapter 5](text00015.html#ch05) . The following code shows
    you how to get a value out of a dictionary:'
  id: totrans-10338
  prefs: []
  type: TYPE_NORMAL
  zh: 要解包一个可选类型，首先通过 if-let 语句检查它是否存在，就像我们在 [第五章](text00015.html#ch05) 中所做的那样。以下代码展示了如何从字典中获取一个值：
- en: '![Image](Image00143.jpg)'
  id: totrans-10339
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00143.jpg)'
- en: To retrieve "Texas" from the dictionary, we use if let to set a constant loneStarState
    to usStates["TX"] ➊ . Because we have this state in our dictionary, the line I
    have Texas in my dictionary. is printed. Next we try to access a state that is
    not in our dictionary by using the key usStates["FL"] ➋ . Thankfully, because
    we used an if-let statement, the program won’t crash when the computer can’t find
    this state. Instead, I don't have that state in my dictionary. is printed.
  id: totrans-10340
  prefs: []
  type: TYPE_NORMAL
  zh: 要从字典中检索 "Texas"，我们使用 if let 将常量 loneStarState 设置为 usStates["TX"] ➊。因为字典中有这个州，所以打印了
    "I have Texas in my dictionary." 接下来，我们尝试使用键 usStates["FL"] ➋ 访问一个不在字典中的州。幸运的是，由于我们使用了
    if-let 语句，当计算机找不到该州时，程序不会崩溃。相反，打印了 "I don't have that state in my dictionary."。
- en: '**ADDING ITEMS TO A DICTIONARY**'
  id: totrans-10341
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**向字典添加项**'
- en: 'To add an item to a dictionary, first write the name of your dictionary and
    assign the new item to the key you want it to have in the dictionary. Let’s add
    "Minnesota" to our usStates dictionary:'
  id: totrans-10342
  prefs: []
  type: TYPE_NORMAL
  zh: 要向字典中添加一项，首先写出字典的名称，并将新项分配给你希望它在字典中具有的键。让我们把 "Minnesota" 添加到我们的 usStates 字典中：
- en: '![](Image00144.jpg)'
  id: totrans-10343
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00144.jpg)'
- en: 'Now when you look at usStates , you’ll see that it’s updated to ["MN": "Minnesota",
    "WA": "Washington", "MA": "Massachusetts", "TX": "Texas"] . Remember, because
    you don’t have to rely on indices, your new dictionary item might appear anywhere
    in the dictionary.'
  id: totrans-10344
  prefs: []
  type: TYPE_NORMAL
  zh: '现在当你查看 usStates 时，你会看到它已更新为 ["MN": "Minnesota", "WA": "Washington", "MA": "Massachusetts",
    "TX": "Texas"]。记住，由于你不需要依赖索引，你的新字典项可能会出现在字典中的任何位置。'
- en: '**REMOVING ITEMS FROM A DICTIONARY**'
  id: totrans-10345
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**从字典中删除项**'
- en: Removing an item from a dictionary is quite simple; you do so by setting the
    value to nil . Because the values in dictionaries are returned as optionals, you
    don’t have to worry about nil causing any problems in your dictionary.
  id: totrans-10346
  prefs: []
  type: TYPE_NORMAL
  zh: 从字典中删除项非常简单；你只需将值设置为 nil。由于字典中的值作为可选类型返回，因此你不必担心 nil 会在字典中引发问题。
- en: '![](Image00145.jpg)'
  id: totrans-10347
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00145.jpg)'
- en: 'You can see that after you remove the value at the key "MA" , usStates is updated
    to ["MN": "Minnesota", "WA": "Washington", "TX": "Texas"] . Remember that nil
    is special and means that there’s no value at all. That’s why you don’t see "MA":
    nil in our dictionary.'
  id: totrans-10348
  prefs: []
  type: TYPE_NORMAL
  zh: '你可以看到，在你删除了键 "MA" 对应的值后，usStates 已更新为 ["MN": "Minnesota", "WA": "Washington",
    "TX": "Texas"]。记住，nil 是特殊的，表示没有任何值。这就是为什么你在我们的字典中看不到 "MA": nil。'
- en: '**REPLACING ITEMS IN A DICTIONARY**'
  id: totrans-10349
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**替换字典中的项**'
- en: 'Replacing an item in a dictionary is also easy. It works the same was as replacing
    an item in an array. You just set the item that you want to replace to something
    else. Say you create a dictionary of fruit colors:'
  id: totrans-10350
  prefs: []
  type: TYPE_NORMAL
  zh: 替换字典中的项也很简单。它与替换数组中的项的方式相同。你只需将想要替换的项设置为其他值。例如，你创建一个包含水果颜色的字典：
- en: '![](Image00146.jpg)'
  id: totrans-10351
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00146.jpg)'
- en: At first we had the value "apple" for "red" , but then we decided that "raspberry"
    is a better fruit to use since sometimes apples are green or yellow. To replace
    "apple" with "raspberry" , we set colorFruits["red"] to its new value ➊ .
  id: totrans-10352
  prefs: []
  type: TYPE_NORMAL
  zh: 起初，我们为“红色”赋值为“苹果”，但后来我们决定“树莓”是更好的选择，因为有时苹果是绿色或黄色的。为了将“苹果”替换为“树莓”，我们将 colorFruits["red"]
    设置为其新值 ➊。
- en: You may remember that this is the same way we entered a new value into a dictionary.
    If the key already exists in the dictionary, then the value for that key is replaced.
    If the key doesn’t already exist, then the new key/value pair will be added to
    the dictionary.
  id: totrans-10353
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能记得，这与我们向字典中输入新值的方式相同。如果字典中已经存在该键，则该键的值将被替换。如果该键不存在，则新的键值对将被添加到字典中。
- en: '![Image](Image00147.jpg)'
  id: totrans-10354
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00147.jpg)'
- en: '**USING DICTIONARY PROPERTIES**'
  id: totrans-10355
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**使用字典属性**'
- en: 'Like an array, a dictionary also has an isEmpty property and a count property.
    For example, the following code shows how you can use the isEmpty property to
    check if a dictionary is empty, and if it isn’t empty, the count property checks
    how many items you have. Imagine you have a basket of fruit for sale. You can
    use these properties to help you keep track of everything:'
  id: totrans-10356
  prefs: []
  type: TYPE_NORMAL
  zh: 像数组一样，字典也有 isEmpty 属性和 count 属性。例如，下面的代码展示了如何使用 isEmpty 属性检查字典是否为空，如果不为空，count
    属性则用于检查字典中有多少项。假设你有一个待售的水果篮。你可以使用这些属性来帮助你跟踪所有内容：
- en: '![Image](Image00148.jpg)'
  id: totrans-10357
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00148.jpg)'
- en: 'A dictionary also has two special properties: keys , which contains all of
    the dictionary’s keys, and values , which contains all of its values. We’ll use
    these two properties when we loop through the dictionary.'
  id: totrans-10358
  prefs: []
  type: TYPE_NORMAL
  zh: 字典还有两个特殊的属性：keys，包含字典的所有键，以及 values，包含字典的所有值。我们将在遍历字典时使用这两个属性。
- en: Let’s write some code that loops through our fruit baskets and prints the price
    of each fruit.
  id: totrans-10359
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们写一些代码，遍历我们的水果篮并打印每个水果的价格。
- en: '**LOOPING OVER A DICTIONARY**'
  id: totrans-10360
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**遍历字典**'
- en: 'You can loop through a dictionary using a for-in loop. Because each item has
    a key and a value, you can do this in two different ways. This is how to loop
    through a dictionary using its keys:'
  id: totrans-10361
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用 for-in 循环遍历字典。因为每个项都有键和值，你可以用两种不同的方式来遍历字典。以下是如何使用字典的键来遍历字典：
- en: '![Image](Image00149.jpg)'
  id: totrans-10362
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00149.jpg)'
- en: Here we use the dictionary’s keys property ➊ to loop through fruitBasket and
    print its contents. We start by writing the keyword for , followed by a constant
    name fruit for the dictionary key, the keyword in , the dictionary name, a period,
    and keys .
  id: totrans-10363
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们使用字典的 keys 属性 ➊ 来遍历 fruitBasket 并打印其内容。我们首先写下关键字 for，然后是常量名称 fruit 作为字典键，接着是
    in 关键字，字典名称，句点，以及 keys。
- en: Inside the braces of our for-in loop, we have access to both the key, which
    we call fruit ➋ , and the value at that key when we force-unwrap its contents
    with fruitBasket[fruit]! ➌ . That value will be the fruit’s price.
  id: totrans-10364
  prefs: []
  type: TYPE_NORMAL
  zh: 在 for-in 循环的大括号内，我们可以访问到键，我们称之为 fruit ➋，以及通过强制解包 fruitBasket[fruit]! ➌ 获取的该键对应的值。该值将是水果的价格。
- en: In this case, it’s safe to force-unwrap the value using an exclamation point
    because we know that the fruit key we’re using is definitely inside the dictionary.
  id: totrans-10365
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，使用感叹号强制解包值是安全的，因为我们知道我们使用的水果键一定在字典中。
- en: Any code we put inside the for-in loop will run once for every key in our dictionary.
    So you should see the print statement display three times.
  id: totrans-10366
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在 for-in 循环内部放置的任何代码都会针对字典中的每个键执行一次。所以你应该看到打印语句显示三次。
- en: 'We can also loop through the dictionary using its values property:'
  id: totrans-10367
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以使用字典的 values 属性来遍历字典：
- en: '![Image](Image00150.jpg)'
  id: totrans-10368
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00150.jpg)'
- en: We use the same style of for-in loop, but now we use a constant to refer to
    each value, which we call price , in the values property. When looping through
    values, we don’t have access to the keys from inside the loop.
  id: totrans-10369
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用相同的 for-in 循环风格，但这次我们用常量来引用每个值，这个常量我们叫做 price，在 values 属性中。当遍历 values 时，我们无法在循环内部访问到键。
- en: Another difference to note is that price is not an optional because it’s accessed
    directly as a value in the fruitBasket dictionary. That means we don’t have to
    unwrap it. You should still see the print statement printed three times. [Figure
    6-6](text00016.html#ch06fig6) shows the output of both loops.
  id: totrans-10370
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个需要注意的区别是，`price` 不是可选项，因为它是直接作为值访问的，存储在 `fruitBasket` 字典中。这意味着我们不需要解包它。你仍然应该看到打印语句被打印三次。[图
    6-6](text00016.html#ch06fig6) 显示了两个循环的输出。
- en: '![Image](Image00151.jpg)'
  id: totrans-10371
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00151.jpg)'
- en: '*Figure 6-6: Looping through the keys and values of a dictionary with a for-in
    loop*'
  id: totrans-10372
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 6-6：使用 for-in 循环遍历字典的键和值*'
- en: The order of your results might be slightly different from ours. That’s because
    the items in a dictionary aren’t in a numbered order like they are in an array!
    And because the order is not guaranteed, you might see a different order printed
    if you run the same code again.
  id: totrans-10373
  prefs: []
  type: TYPE_NORMAL
  zh: 你的结果顺序可能与我们的略有不同。这是因为字典中的项不像数组那样是按数字顺序排列的！并且因为顺序无法保证，如果你再次运行相同的代码，可能会看到不同的顺序。
- en: '**WHAT YOU LEARNED**'
  id: totrans-10374
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**你学到的内容**'
- en: In this chapter, you learned how to store collections of items in an array and
    in a dictionary. To store items in an ordered list, you would use an array and
    look up each item by its index. If you wanted to store items by key instead, you
    would use a dictionary.
  id: totrans-10375
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你学习了如何在数组和字典中存储项。要将项存储在有序列表中，你将使用数组，并通过其索引查找每一项。如果你想根据键存储项，则应使用字典。
- en: Knowing about arrays and dictionaries and how to use them is a powerful building
    block for almost any programming language. Next we will learn about functions,
    another very powerful tool. Functions are blocks of code that you create and name
    to perform a specific job. After you have written a function, you can use its
    name to call it from almost anywhere in your program.
  id: totrans-10376
  prefs: []
  type: TYPE_NORMAL
  zh: 了解数组和字典及其使用方法，是几乎所有编程语言的强大构建块。接下来，我们将学习函数，这是另一个非常强大的工具。函数是你创建并命名的代码块，用于执行特定任务。在编写了函数后，你可以几乎在程序的任何地方使用它的名称来调用它。
- en: '![Image](Image00143.jpg)'
  id: totrans-10377
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00143.jpg)'
- en: To retrieve "Texas" from the dictionary, we use if let to set a constant loneStarState
    to usStates["TX"] ➊ . Because we have this state in our dictionary, the line I
    have Texas in my dictionary. is printed. Next we try to access a state that is
    not in our dictionary by using the key usStates["FL"] ➋ . Thankfully, because
    we used an if-let statement, the program won’t crash when the computer can’t find
    this state. Instead, I don't have that state in my dictionary. is printed.
  id: totrans-10378
  prefs: []
  type: TYPE_NORMAL
  zh: 要从字典中检索 "Texas"，我们使用 if let 将常量 `loneStarState` 设置为 `usStates["TX"]` ➊。因为我们在字典中有这个州，"I
    have Texas in my dictionary." 这行会被打印出来。接下来，我们尝试通过使用键 `usStates["FL"]` ➋ 来访问一个不在字典中的州。幸运的是，由于我们使用了
    if-let 语句，当计算机找不到这个州时，程序不会崩溃。而是打印出 "I don't have that state in my dictionary."。
- en: '**ADDING ITEMS TO A DICTIONARY**'
  id: totrans-10379
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**向字典添加项**'
- en: 'To add an item to a dictionary, first write the name of your dictionary and
    assign the new item to the key you want it to have in the dictionary. Let’s add
    "Minnesota" to our usStates dictionary:'
  id: totrans-10380
  prefs: []
  type: TYPE_NORMAL
  zh: 要向字典中添加一项，首先写下字典的名称，并将新项分配给你希望它在字典中具有的键。让我们将 "Minnesota" 添加到我们的 `usStates` 字典中：
- en: '![](Image00144.jpg)'
  id: totrans-10381
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00144.jpg)'
- en: 'Now when you look at usStates , you’ll see that it’s updated to ["MN": "Minnesota",
    "WA": "Washington", "MA": "Massachusetts", "TX": "Texas"] . Remember, because
    you don’t have to rely on indices, your new dictionary item might appear anywhere
    in the dictionary.'
  id: totrans-10382
  prefs: []
  type: TYPE_NORMAL
  zh: '现在，当你查看 `usStates` 时，你会看到它已经更新为["MN": "Minnesota", "WA": "Washington", "MA":
    "Massachusetts", "TX": "Texas"]。记住，因为你不需要依赖索引，所以新的字典项可能出现在字典的任何位置。'
- en: '**REMOVING ITEMS FROM A DICTIONARY**'
  id: totrans-10383
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**从字典中移除项**'
- en: Removing an item from a dictionary is quite simple; you do so by setting the
    value to nil . Because the values in dictionaries are returned as optionals, you
    don’t have to worry about nil causing any problems in your dictionary.
  id: totrans-10384
  prefs: []
  type: TYPE_NORMAL
  zh: 从字典中移除一项非常简单；你只需要将值设置为 nil。因为字典中的值是作为可选项返回的，所以你不必担心 nil 会在字典中引发任何问题。
- en: '![](Image00145.jpg)'
  id: totrans-10385
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00145.jpg)'
- en: 'You can see that after you remove the value at the key "MA" , usStates is updated
    to ["MN": "Minnesota", "WA": "Washington", "TX": "Texas"] . Remember that nil
    is special and means that there’s no value at all. That’s why you don’t see "MA":
    nil in our dictionary.'
  id: totrans-10386
  prefs: []
  type: TYPE_NORMAL
  zh: '你可以看到，在移除键 "MA" 的值后，`usStates` 被更新为 ["MN": "Minnesota", "WA": "Washington",
    "TX": "Texas"]。记住，nil 是特别的，表示根本没有值。这就是为什么你在字典中看不到 "MA": nil 的原因。'
- en: '**REPLACING ITEMS IN A DICTIONARY**'
  id: totrans-10387
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**替换字典中的项**'
- en: 'Replacing an item in a dictionary is also easy. It works the same was as replacing
    an item in an array. You just set the item that you want to replace to something
    else. Say you create a dictionary of fruit colors:'
  id: totrans-10388
  prefs: []
  type: TYPE_NORMAL
  zh: 替换字典中的项目也很简单。它与替换数组中的项目工作方式相同。你只需将你想替换的项目设置为其他值。例如，你可以创建一个包含水果颜色的字典：
- en: '![](Image00146.jpg)'
  id: totrans-10389
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00146.jpg)'
- en: At first we had the value "apple" for "red" , but then we decided that "raspberry"
    is a better fruit to use since sometimes apples are green or yellow. To replace
    "apple" with "raspberry" , we set colorFruits["red"] to its new value ➊ .
  id: totrans-10390
  prefs: []
  type: TYPE_NORMAL
  zh: 起初我们为"red"设定了值"apple"，但是后来我们决定"raspberry"是更好的水果，因为有时候苹果是绿色或黄色的。为了将"apple"替换成"raspberry"，我们将colorFruits["red"]设置为它的新值
    ➊。
- en: You may remember that this is the same way we entered a new value into a dictionary.
    If the key already exists in the dictionary, then the value for that key is replaced.
    If the key doesn’t already exist, then the new key/value pair will be added to
    the dictionary.
  id: totrans-10391
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能还记得，这与我们将新值添加到字典中的方式是一样的。如果键已经存在于字典中，那么该键的值将被替换。如果键不存在，那么新的键/值对将被添加到字典中。
- en: '![Image](Image00147.jpg)'
  id: totrans-10392
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00147.jpg)'
- en: '**USING DICTIONARY PROPERTIES**'
  id: totrans-10393
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**使用字典属性**'
- en: 'Like an array, a dictionary also has an isEmpty property and a count property.
    For example, the following code shows how you can use the isEmpty property to
    check if a dictionary is empty, and if it isn’t empty, the count property checks
    how many items you have. Imagine you have a basket of fruit for sale. You can
    use these properties to help you keep track of everything:'
  id: totrans-10394
  prefs: []
  type: TYPE_NORMAL
  zh: 就像数组一样，字典也有isEmpty属性和count属性。例如，以下代码展示了如何使用isEmpty属性检查字典是否为空，如果不为空，则使用count属性检查你有多少项。假设你有一个出售的水果篮。你可以使用这些属性来帮助你跟踪所有的东西：
- en: '![Image](Image00148.jpg)'
  id: totrans-10395
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00148.jpg)'
- en: 'A dictionary also has two special properties: keys , which contains all of
    the dictionary’s keys, and values , which contains all of its values. We’ll use
    these two properties when we loop through the dictionary.'
  id: totrans-10396
  prefs: []
  type: TYPE_NORMAL
  zh: 字典还有两个特殊的属性：keys，它包含字典的所有键；以及values，它包含字典的所有值。我们将在遍历字典时使用这两个属性。
- en: Let’s write some code that loops through our fruit baskets and prints the price
    of each fruit.
  id: totrans-10397
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们写些代码，遍历我们的水果篮并打印每个水果的价格。
- en: '**LOOPING OVER A DICTIONARY**'
  id: totrans-10398
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**遍历字典**'
- en: 'You can loop through a dictionary using a for-in loop. Because each item has
    a key and a value, you can do this in two different ways. This is how to loop
    through a dictionary using its keys:'
  id: totrans-10399
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用for-in循环遍历字典。由于每个项目都有一个键和值，你可以通过两种方式来进行遍历。这是使用键遍历字典的方式：
- en: '![Image](Image00149.jpg)'
  id: totrans-10400
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00149.jpg)'
- en: Here we use the dictionary’s keys property ➊ to loop through fruitBasket and
    print its contents. We start by writing the keyword for , followed by a constant
    name fruit for the dictionary key, the keyword in , the dictionary name, a period,
    and keys .
  id: totrans-10401
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们使用字典的keys属性 ➊ 来遍历fruitBasket并打印其内容。我们首先写出for关键字，接着是字典键的常量名称fruit，接着是in关键字，字典名称，句点和keys。
- en: Inside the braces of our for-in loop, we have access to both the key, which
    we call fruit ➋ , and the value at that key when we force-unwrap its contents
    with fruitBasket[fruit]! ➌ . That value will be the fruit’s price.
  id: totrans-10402
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的for-in循环的大括号内，我们可以访问到键（我们称之为fruit ➋）以及通过强制解包其内容获取到的值：fruitBasket[fruit]!
    ➌。这个值将是水果的价格。
- en: In this case, it’s safe to force-unwrap the value using an exclamation point
    because we know that the fruit key we’re using is definitely inside the dictionary.
  id: totrans-10403
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，使用感叹号强制解包值是安全的，因为我们知道我们使用的fruit键肯定存在于字典中。
- en: Any code we put inside the for-in loop will run once for every key in our dictionary.
    So you should see the print statement display three times.
  id: totrans-10404
  prefs: []
  type: TYPE_NORMAL
  zh: 我们放在for-in循环中的任何代码都会为字典中的每个键运行一次。因此，你应该看到打印语句显示三次。
- en: 'We can also loop through the dictionary using its values property:'
  id: totrans-10405
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以通过字典的values属性进行遍历：
- en: '![Image](Image00150.jpg)'
  id: totrans-10406
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00150.jpg)'
- en: We use the same style of for-in loop, but now we use a constant to refer to
    each value, which we call price , in the values property. When looping through
    values, we don’t have access to the keys from inside the loop.
  id: totrans-10407
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用相同风格的for-in循环，但现在我们使用一个常量来表示values属性中的每个值，我们称之为price。当遍历values时，我们无法在循环内部访问键。
- en: Another difference to note is that price is not an optional because it’s accessed
    directly as a value in the fruitBasket dictionary. That means we don’t have to
    unwrap it. You should still see the print statement printed three times. [Figure
    6-6](text00016.html#ch06fig6) shows the output of both loops.
  id: totrans-10408
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个需要注意的区别是，price 不是一个可选项，因为它是直接作为值在 fruitBasket 字典中访问的。这意味着我们不需要解包它。你仍然应该看到
    print 语句被打印三次。[图 6-6](text00016.html#ch06fig6) 显示了两个循环的输出。
- en: '![Image](Image00151.jpg)'
  id: totrans-10409
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00151.jpg)'
- en: '*Figure 6-6: Looping through the keys and values of a dictionary with a for-in
    loop*'
  id: totrans-10410
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 6-6: 使用 for-in 循环遍历字典的键和值*'
- en: The order of your results might be slightly different from ours. That’s because
    the items in a dictionary aren’t in a numbered order like they are in an array!
    And because the order is not guaranteed, you might see a different order printed
    if you run the same code again.
  id: totrans-10411
  prefs: []
  type: TYPE_NORMAL
  zh: 你的结果顺序可能与我们的略有不同。这是因为字典中的项不像数组那样按编号排序！由于顺序没有保证，如果你重新运行相同的代码，可能会看到不同的输出顺序。
- en: '**WHAT YOU LEARNED**'
  id: totrans-10412
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**你学到的内容**'
- en: In this chapter, you learned how to store collections of items in an array and
    in a dictionary. To store items in an ordered list, you would use an array and
    look up each item by its index. If you wanted to store items by key instead, you
    would use a dictionary.
  id: totrans-10413
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你学习了如何在数组和字典中存储集合项。为了将项存储在有序列表中，你会使用数组，并通过索引查找每个项。如果你想通过键来存储项，你会使用字典。
- en: Knowing about arrays and dictionaries and how to use them is a powerful building
    block for almost any programming language. Next we will learn about functions,
    another very powerful tool. Functions are blocks of code that you create and name
    to perform a specific job. After you have written a function, you can use its
    name to call it from almost anywhere in your program.
  id: totrans-10414
  prefs: []
  type: TYPE_NORMAL
  zh: 了解数组和字典以及如何使用它们是几乎所有编程语言中强大构建块的一部分。接下来，我们将学习函数，这是另一个非常强大的工具。函数是你创建并命名的代码块，用来执行特定的工作。编写完函数后，你可以使用其名称从程序中的几乎任何地方调用它。
- en: To retrieve "Texas" from the dictionary, we use if let to set a constant loneStarState
    to usStates["TX"] ➊ . Because we have this state in our dictionary, the line I
    have Texas in my dictionary. is printed. Next we try to access a state that is
    not in our dictionary by using the key usStates["FL"] ➋ . Thankfully, because
    we used an if-let statement, the program won’t crash when the computer can’t find
    this state. Instead, I don't have that state in my dictionary. is printed.
  id: totrans-10415
  prefs: []
  type: TYPE_NORMAL
  zh: 要从字典中获取 "Texas"，我们使用 if let 将常量 loneStarState 设置为 usStates["TX"] ➊ 。因为我们的字典中有这个州，所以打印了
    "I have Texas in my dictionary."。接下来，我们尝试通过使用键 usStates["FL"] ➋ 访问一个不在字典中的州。幸运的是，因为我们使用了
    if-let 语句，当计算机找不到这个州时，程序不会崩溃。相反，打印了 "I don't have that state in my dictionary."。
- en: '**ADDING ITEMS TO A DICTIONARY**'
  id: totrans-10416
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**向字典添加项**'
- en: 'To add an item to a dictionary, first write the name of your dictionary and
    assign the new item to the key you want it to have in the dictionary. Let’s add
    "Minnesota" to our usStates dictionary:'
  id: totrans-10417
  prefs: []
  type: TYPE_NORMAL
  zh: 要向字典添加项，首先写出字典的名称，并将新项分配给你希望它在字典中拥有的键。让我们将 "Minnesota" 添加到我们的 usStates 字典中：
- en: '![](Image00144.jpg)'
  id: totrans-10418
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00144.jpg)'
- en: 'Now when you look at usStates , you’ll see that it’s updated to ["MN": "Minnesota",
    "WA": "Washington", "MA": "Massachusetts", "TX": "Texas"] . Remember, because
    you don’t have to rely on indices, your new dictionary item might appear anywhere
    in the dictionary.'
  id: totrans-10419
  prefs: []
  type: TYPE_NORMAL
  zh: '现在当你查看 usStates 时，你会看到它已经更新为 ["MN": "Minnesota", "WA": "Washington", "MA":
    "Massachusetts", "TX": "Texas"] 。记住，因为你不需要依赖索引，所以你的新字典项可能会出现在字典的任何位置。'
- en: '**REMOVING ITEMS FROM A DICTIONARY**'
  id: totrans-10420
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**从字典中删除项**'
- en: Removing an item from a dictionary is quite simple; you do so by setting the
    value to nil . Because the values in dictionaries are returned as optionals, you
    don’t have to worry about nil causing any problems in your dictionary.
  id: totrans-10421
  prefs: []
  type: TYPE_NORMAL
  zh: 从字典中删除项非常简单；你只需要将其值设置为 nil 。因为字典中的值是可选的，你不必担心 nil 会在字典中引发任何问题。
- en: '![](Image00145.jpg)'
  id: totrans-10422
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00145.jpg)'
- en: 'You can see that after you remove the value at the key "MA" , usStates is updated
    to ["MN": "Minnesota", "WA": "Washington", "TX": "Texas"] . Remember that nil
    is special and means that there’s no value at all. That’s why you don’t see "MA":
    nil in our dictionary.'
  id: totrans-10423
  prefs: []
  type: TYPE_NORMAL
  zh: '你可以看到，在删除键 "MA" 的值后，usStates 被更新为 ["MN": "Minnesota", "WA": "Washington", "TX":
    "Texas"] 。记住，nil 是特殊的，它意味着完全没有值。这就是为什么你在字典中看不到 "MA": nil 的原因。'
- en: '**REPLACING ITEMS IN A DICTIONARY**'
  id: totrans-10424
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**替换字典中的项**'
- en: 'Replacing an item in a dictionary is also easy. It works the same was as replacing
    an item in an array. You just set the item that you want to replace to something
    else. Say you create a dictionary of fruit colors:'
  id: totrans-10425
  prefs: []
  type: TYPE_NORMAL
  zh: 替换字典中的项目也很简单。它的操作与替换数组中的项目一样。你只需将要替换的项目设置为其他内容。假设你创建了一个水果颜色的字典：
- en: '![](Image00146.jpg)'
  id: totrans-10426
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00146.jpg)'
- en: At first we had the value "apple" for "red" , but then we decided that "raspberry"
    is a better fruit to use since sometimes apples are green or yellow. To replace
    "apple" with "raspberry" , we set colorFruits["red"] to its new value ➊ .
  id: totrans-10427
  prefs: []
  type: TYPE_NORMAL
  zh: 最初我们为“red”设置了值“apple”，但后来我们认为“raspberry”是更好的水果，因为有时苹果是绿色或黄色的。要将“apple”替换为“raspberry”，我们将
    colorFruits["red"] 设置为新的值 ➊。
- en: You may remember that this is the same way we entered a new value into a dictionary.
    If the key already exists in the dictionary, then the value for that key is replaced.
    If the key doesn’t already exist, then the new key/value pair will be added to
    the dictionary.
  id: totrans-10428
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能还记得，我们用相同的方法将一个新值插入字典。如果键已经存在于字典中，那么该键的值将被替换。如果键不存在，则会将新的键/值对添加到字典中。
- en: '![Image](Image00147.jpg)'
  id: totrans-10429
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00147.jpg)'
- en: '**USING DICTIONARY PROPERTIES**'
  id: totrans-10430
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**使用字典属性**'
- en: 'Like an array, a dictionary also has an isEmpty property and a count property.
    For example, the following code shows how you can use the isEmpty property to
    check if a dictionary is empty, and if it isn’t empty, the count property checks
    how many items you have. Imagine you have a basket of fruit for sale. You can
    use these properties to help you keep track of everything:'
  id: totrans-10431
  prefs: []
  type: TYPE_NORMAL
  zh: 像数组一样，字典也有 isEmpty 属性和 count 属性。例如，下面的代码演示了如何使用 isEmpty 属性检查字典是否为空，如果不为空，count
    属性则用来检查字典中的项数。假设你有一个销售水果的篮子。你可以使用这些属性帮助你跟踪一切：
- en: '![Image](Image00148.jpg)'
  id: totrans-10432
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00148.jpg)'
- en: 'A dictionary also has two special properties: keys , which contains all of
    the dictionary’s keys, and values , which contains all of its values. We’ll use
    these two properties when we loop through the dictionary.'
  id: totrans-10433
  prefs: []
  type: TYPE_NORMAL
  zh: 字典还有两个特殊属性：keys，包含字典所有键；values，包含字典所有值。在遍历字典时，我们会使用这两个属性。
- en: Let’s write some code that loops through our fruit baskets and prints the price
    of each fruit.
  id: totrans-10434
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们写一些代码，遍历我们的水果篮并打印每种水果的价格。
- en: '**LOOPING OVER A DICTIONARY**'
  id: totrans-10435
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**遍历字典**'
- en: 'You can loop through a dictionary using a for-in loop. Because each item has
    a key and a value, you can do this in two different ways. This is how to loop
    through a dictionary using its keys:'
  id: totrans-10436
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用 for-in 循环遍历字典。因为每个项都有一个键和值，你可以通过两种不同的方式进行操作。下面是如何使用键遍历字典：
- en: '![Image](Image00149.jpg)'
  id: totrans-10437
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00149.jpg)'
- en: Here we use the dictionary’s keys property ➊ to loop through fruitBasket and
    print its contents. We start by writing the keyword for , followed by a constant
    name fruit for the dictionary key, the keyword in , the dictionary name, a period,
    and keys .
  id: totrans-10438
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们使用字典的 keys 属性 ➊ 来遍历 fruitBasket 并打印其内容。我们首先写下关键字 for，然后是一个常量名称 fruit 作为字典键，接着是关键字
    in，字典名称，一个句点，然后是 keys。
- en: Inside the braces of our for-in loop, we have access to both the key, which
    we call fruit ➋ , and the value at that key when we force-unwrap its contents
    with fruitBasket[fruit]! ➌ . That value will be the fruit’s price.
  id: totrans-10439
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的 for-in 循环的大括号内，我们可以访问键（我们称之为 fruit ➋）以及通过强制展开其内容获取的该键的值，使用 fruitBasket[fruit]!
    ➌。该值将是水果的价格。
- en: In this case, it’s safe to force-unwrap the value using an exclamation point
    because we know that the fruit key we’re using is definitely inside the dictionary.
  id: totrans-10440
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，使用感叹号强制展开值是安全的，因为我们知道我们使用的果实键肯定在字典中。
- en: Any code we put inside the for-in loop will run once for every key in our dictionary.
    So you should see the print statement display three times.
  id: totrans-10441
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在 for-in 循环中写的任何代码会在字典中的每个键上执行一次。所以你应该看到打印语句显示三次。
- en: 'We can also loop through the dictionary using its values property:'
  id: totrans-10442
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以使用字典的 values 属性遍历字典：
- en: '![Image](Image00150.jpg)'
  id: totrans-10443
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00150.jpg)'
- en: We use the same style of for-in loop, but now we use a constant to refer to
    each value, which we call price , in the values property. When looping through
    values, we don’t have access to the keys from inside the loop.
  id: totrans-10444
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用相同风格的 for-in 循环，但现在我们使用一个常量来引用 values 属性中的每个值，我们称之为 price。在遍历值时，我们无法从循环内访问键。
- en: Another difference to note is that price is not an optional because it’s accessed
    directly as a value in the fruitBasket dictionary. That means we don’t have to
    unwrap it. You should still see the print statement printed three times. [Figure
    6-6](text00016.html#ch06fig6) shows the output of both loops.
  id: totrans-10445
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个需要注意的区别是，价格不是一个可选项，因为它直接作为 `fruitBasket` 字典中的一个值进行访问。这意味着我们不需要解包它。你仍然会看到打印语句打印三次。[图
    6-6](text00016.html#ch06fig6)显示了两个循环的输出。
- en: '![Image](Image00151.jpg)'
  id: totrans-10446
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00151.jpg)'
- en: '*Figure 6-6: Looping through the keys and values of a dictionary with a for-in
    loop*'
  id: totrans-10447
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 6-6：使用 for-in 循环遍历字典的键和值*'
- en: The order of your results might be slightly different from ours. That’s because
    the items in a dictionary aren’t in a numbered order like they are in an array!
    And because the order is not guaranteed, you might see a different order printed
    if you run the same code again.
  id: totrans-10448
  prefs: []
  type: TYPE_NORMAL
  zh: 你的结果顺序可能与你看到的有所不同。这是因为字典中的项不像数组那样有编号顺序！由于顺序不可保证，如果你再次运行相同的代码，你可能会看到不同的顺序打印出来。
- en: '**WHAT YOU LEARNED**'
  id: totrans-10449
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**你学到了什么**'
- en: In this chapter, you learned how to store collections of items in an array and
    in a dictionary. To store items in an ordered list, you would use an array and
    look up each item by its index. If you wanted to store items by key instead, you
    would use a dictionary.
  id: totrans-10450
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你学习了如何将项存储在数组和字典中。要将项存储在有序列表中，你会使用数组，并通过索引查找每个项。如果你想根据键来存储项，你将使用字典。
- en: Knowing about arrays and dictionaries and how to use them is a powerful building
    block for almost any programming language. Next we will learn about functions,
    another very powerful tool. Functions are blocks of code that you create and name
    to perform a specific job. After you have written a function, you can use its
    name to call it from almost anywhere in your program.
  id: totrans-10451
  prefs: []
  type: TYPE_NORMAL
  zh: 了解数组和字典以及如何使用它们，是几乎所有编程语言中非常强大的构建模块。接下来我们将学习函数，另一个非常强大的工具。函数是你创建并命名的代码块，用来执行特定的任务。编写完函数后，你可以通过其名称从程序的几乎任何地方调用它。
- en: '**ADDING ITEMS TO A DICTIONARY**'
  id: totrans-10452
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**向字典添加项**'
- en: 'To add an item to a dictionary, first write the name of your dictionary and
    assign the new item to the key you want it to have in the dictionary. Let’s add
    "Minnesota" to our usStates dictionary:'
  id: totrans-10453
  prefs: []
  type: TYPE_NORMAL
  zh: 要向字典中添加一个项，首先写出字典的名称，并将新项分配给字典中你希望它拥有的键。让我们向我们的 `usStates` 字典添加“明尼苏达”：
- en: '![](Image00144.jpg)'
  id: totrans-10454
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00144.jpg)'
- en: 'Now when you look at usStates , you’ll see that it’s updated to ["MN": "Minnesota",
    "WA": "Washington", "MA": "Massachusetts", "TX": "Texas"] . Remember, because
    you don’t have to rely on indices, your new dictionary item might appear anywhere
    in the dictionary.'
  id: totrans-10455
  prefs: []
  type: TYPE_NORMAL
  zh: '现在当你查看 `usStates` 时，你会看到它已更新为 ["MN": "Minnesota", "WA": "Washington", "MA":
    "Massachusetts", "TX": "Texas"]。记住，因为你不需要依赖索引，所以新的字典项可能出现在字典的任何位置。'
- en: '**REMOVING ITEMS FROM A DICTIONARY**'
  id: totrans-10456
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**从字典中移除项**'
- en: Removing an item from a dictionary is quite simple; you do so by setting the
    value to nil . Because the values in dictionaries are returned as optionals, you
    don’t have to worry about nil causing any problems in your dictionary.
  id: totrans-10457
  prefs: []
  type: TYPE_NORMAL
  zh: 从字典中移除一个项非常简单；你通过将值设置为 `nil` 来实现。因为字典中的值是作为可选项返回的，所以你不需要担心 `nil` 会在字典中引起任何问题。
- en: '![](Image00145.jpg)'
  id: totrans-10458
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00145.jpg)'
- en: 'You can see that after you remove the value at the key "MA" , usStates is updated
    to ["MN": "Minnesota", "WA": "Washington", "TX": "Texas"] . Remember that nil
    is special and means that there’s no value at all. That’s why you don’t see "MA":
    nil in our dictionary.'
  id: totrans-10459
  prefs: []
  type: TYPE_NORMAL
  zh: '你可以看到，在移除键“MA”对应的值后，`usStates` 更新为 ["MN": "Minnesota", "WA": "Washington",
    "TX": "Texas"]。记住，`nil` 是特殊的，表示没有值。这就是为什么你在字典中看不到 "MA": nil 的原因。'
- en: '**REPLACING ITEMS IN A DICTIONARY**'
  id: totrans-10460
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**替换字典中的项**'
- en: 'Replacing an item in a dictionary is also easy. It works the same was as replacing
    an item in an array. You just set the item that you want to replace to something
    else. Say you create a dictionary of fruit colors:'
  id: totrans-10461
  prefs: []
  type: TYPE_NORMAL
  zh: 替换字典中的项也很简单。它的工作方式与替换数组中的项相同。你只需将你想要替换的项设为其他值。例如，你可以创建一个水果颜色的字典：
- en: '![](Image00146.jpg)'
  id: totrans-10462
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00146.jpg)'
- en: At first we had the value "apple" for "red" , but then we decided that "raspberry"
    is a better fruit to use since sometimes apples are green or yellow. To replace
    "apple" with "raspberry" , we set colorFruits["red"] to its new value ➊ .
  id: totrans-10463
  prefs: []
  type: TYPE_NORMAL
  zh: 起初我们为“红色”设置了“苹果”作为值，但后来我们决定“覆盆子”是一个更好的选择，因为有时候苹果是绿色或黄色的。为了用“覆盆子”替换“苹果”，我们将 `colorFruits["red"]`
    设置为它的新值 ➊。
- en: You may remember that this is the same way we entered a new value into a dictionary.
    If the key already exists in the dictionary, then the value for that key is replaced.
    If the key doesn’t already exist, then the new key/value pair will be added to
    the dictionary.
  id: totrans-10464
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能记得，这和我们向字典中插入新值的方式相同。如果键已经存在于字典中，则该键的值会被替换。如果键不存在，则新的键/值对会被添加到字典中。
- en: '![Image](Image00147.jpg)'
  id: totrans-10465
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00147.jpg)'
- en: '**USING DICTIONARY PROPERTIES**'
  id: totrans-10466
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**使用字典属性**'
- en: 'Like an array, a dictionary also has an isEmpty property and a count property.
    For example, the following code shows how you can use the isEmpty property to
    check if a dictionary is empty, and if it isn’t empty, the count property checks
    how many items you have. Imagine you have a basket of fruit for sale. You can
    use these properties to help you keep track of everything:'
  id: totrans-10467
  prefs: []
  type: TYPE_NORMAL
  zh: 像数组一样，字典也有 `isEmpty` 属性和 `count` 属性。例如，以下代码展示了如何使用 `isEmpty` 属性来检查字典是否为空，如果不为空，`count`
    属性则检查你有多少个项。假设你有一个待售的水果篮，你可以使用这些属性来帮助你跟踪一切：
- en: '![Image](Image00148.jpg)'
  id: totrans-10468
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00148.jpg)'
- en: 'A dictionary also has two special properties: keys , which contains all of
    the dictionary’s keys, and values , which contains all of its values. We’ll use
    these two properties when we loop through the dictionary.'
  id: totrans-10469
  prefs: []
  type: TYPE_NORMAL
  zh: 字典还有两个特殊属性：`keys`，它包含字典的所有键，以及 `values`，它包含字典的所有值。在我们遍历字典时将使用这两个属性。
- en: Let’s write some code that loops through our fruit baskets and prints the price
    of each fruit.
  id: totrans-10470
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们编写一些代码，循环遍历我们的水果篮，并打印每种水果的价格。
- en: '**LOOPING OVER A DICTIONARY**'
  id: totrans-10471
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**循环遍历字典**'
- en: 'You can loop through a dictionary using a for-in loop. Because each item has
    a key and a value, you can do this in two different ways. This is how to loop
    through a dictionary using its keys:'
  id: totrans-10472
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用 `for-in` 循环遍历字典。因为每个项都有一个键和值，你可以通过两种不同的方式来做。以下是使用键来循环遍历字典的方法：
- en: '![Image](Image00149.jpg)'
  id: totrans-10473
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00149.jpg)'
- en: Here we use the dictionary’s keys property ➊ to loop through fruitBasket and
    print its contents. We start by writing the keyword for , followed by a constant
    name fruit for the dictionary key, the keyword in , the dictionary name, a period,
    and keys .
  id: totrans-10474
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们使用字典的 `keys` 属性 ➊ 来循环遍历 `fruitBasket` 并打印其内容。我们从编写关键字 `for` 开始，后跟字典键的常量名
    `fruit`，关键字 `in`，字典名称，句点和 `keys`。
- en: Inside the braces of our for-in loop, we have access to both the key, which
    we call fruit ➋ , and the value at that key when we force-unwrap its contents
    with fruitBasket[fruit]! ➌ . That value will be the fruit’s price.
  id: totrans-10475
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `for-in` 循环的花括号内，我们可以访问键（我们称之为 `fruit` ➋）以及通过 `fruitBasket[fruit]!` 强制解包其内容时的值
    ➌。该值就是水果的价格。
- en: In this case, it’s safe to force-unwrap the value using an exclamation point
    because we know that the fruit key we’re using is definitely inside the dictionary.
  id: totrans-10476
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，使用感叹号强制解包值是安全的，因为我们知道我们使用的水果键肯定在字典中。
- en: Any code we put inside the for-in loop will run once for every key in our dictionary.
    So you should see the print statement display three times.
  id: totrans-10477
  prefs: []
  type: TYPE_NORMAL
  zh: 我们放在 `for-in` 循环中的任何代码都会对字典中的每个键执行一次。所以你应该看到打印语句显示三次。
- en: 'We can also loop through the dictionary using its values property:'
  id: totrans-10478
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以使用字典的 `values` 属性进行循环：
- en: '![Image](Image00150.jpg)'
  id: totrans-10479
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00150.jpg)'
- en: We use the same style of for-in loop, but now we use a constant to refer to
    each value, which we call price , in the values property. When looping through
    values, we don’t have access to the keys from inside the loop.
  id: totrans-10480
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用相同的 `for-in` 循环方式，但现在我们使用一个常量来引用 `values` 属性中的每个值，我们称之为 `price`。当遍历值时，我们无法在循环内部访问键。
- en: Another difference to note is that price is not an optional because it’s accessed
    directly as a value in the fruitBasket dictionary. That means we don’t have to
    unwrap it. You should still see the print statement printed three times. [Figure
    6-6](text00016.html#ch06fig6) shows the output of both loops.
  id: totrans-10481
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个需要注意的区别是，`price` 不是可选的，因为它是直接作为 `fruitBasket` 字典中的值进行访问的。这意味着我们不需要解包它。你应该仍然会看到打印语句打印三次。[图
    6-6](text00016.html#ch06fig6) 显示了两个循环的输出。
- en: '![Image](Image00151.jpg)'
  id: totrans-10482
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00151.jpg)'
- en: '*Figure 6-6: Looping through the keys and values of a dictionary with a for-in
    loop*'
  id: totrans-10483
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 6-6：使用 `for-in` 循环遍历字典的键和值*'
- en: The order of your results might be slightly different from ours. That’s because
    the items in a dictionary aren’t in a numbered order like they are in an array!
    And because the order is not guaranteed, you might see a different order printed
    if you run the same code again.
  id: totrans-10484
  prefs: []
  type: TYPE_NORMAL
  zh: 你的结果顺序可能会与你的不同。这是因为字典中的项不像数组那样有编号顺序！而且，由于顺序没有保证，如果你重新运行相同的代码，可能会看到不同的顺序。
- en: '**WHAT YOU LEARNED**'
  id: totrans-10485
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**你学到了什么**'
- en: In this chapter, you learned how to store collections of items in an array and
    in a dictionary. To store items in an ordered list, you would use an array and
    look up each item by its index. If you wanted to store items by key instead, you
    would use a dictionary.
  id: totrans-10486
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一章中，你学会了如何在数组和字典中存储项。要在有序列表中存储项，你将使用数组，并通过索引查找每个项。如果你想按键来存储项，你应该使用字典。
- en: Knowing about arrays and dictionaries and how to use them is a powerful building
    block for almost any programming language. Next we will learn about functions,
    another very powerful tool. Functions are blocks of code that you create and name
    to perform a specific job. After you have written a function, you can use its
    name to call it from almost anywhere in your program.
  id: totrans-10487
  prefs: []
  type: TYPE_NORMAL
  zh: 了解数组和字典以及如何使用它们，是几乎所有编程语言的强大基础。接下来，我们将学习函数，另一个非常强大的工具。函数是你创建并命名的代码块，用来执行特定的任务。写完一个函数后，你可以通过它的名称在程序中的几乎任何地方调用它。
- en: 'To add an item to a dictionary, first write the name of your dictionary and
    assign the new item to the key you want it to have in the dictionary. Let’s add
    "Minnesota" to our usStates dictionary:'
  id: totrans-10488
  prefs: []
  type: TYPE_NORMAL
  zh: 要向字典中添加一个项，首先写出字典的名称，并将新项分配给你希望它在字典中拥有的键。让我们将 "Minnesota" 添加到我们的 usStates 字典中：
- en: '![](Image00144.jpg)'
  id: totrans-10489
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00144.jpg)'
- en: 'Now when you look at usStates , you’ll see that it’s updated to ["MN": "Minnesota",
    "WA": "Washington", "MA": "Massachusetts", "TX": "Texas"] . Remember, because
    you don’t have to rely on indices, your new dictionary item might appear anywhere
    in the dictionary.'
  id: totrans-10490
  prefs: []
  type: TYPE_NORMAL
  zh: '现在，当你查看 usStates 时，你会看到它已经更新为 ["MN": "Minnesota", "WA": "Washington", "MA":
    "Massachusetts", "TX": "Texas"]。记住，因为你不需要依赖索引，所以新的字典项可能出现在字典中的任何位置。'
- en: '**REMOVING ITEMS FROM A DICTIONARY**'
  id: totrans-10491
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**从字典中删除项**'
- en: Removing an item from a dictionary is quite simple; you do so by setting the
    value to nil . Because the values in dictionaries are returned as optionals, you
    don’t have to worry about nil causing any problems in your dictionary.
  id: totrans-10492
  prefs: []
  type: TYPE_NORMAL
  zh: 从字典中删除项非常简单；你只需将该值设置为 nil。因为字典中的值是作为可选项返回的，所以你不必担心 nil 会在字典中引起任何问题。
- en: '![](Image00145.jpg)'
  id: totrans-10493
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00145.jpg)'
- en: 'You can see that after you remove the value at the key "MA" , usStates is updated
    to ["MN": "Minnesota", "WA": "Washington", "TX": "Texas"] . Remember that nil
    is special and means that there’s no value at all. That’s why you don’t see "MA":
    nil in our dictionary.'
  id: totrans-10494
  prefs: []
  type: TYPE_NORMAL
  zh: '你可以看到，在你移除 "MA" 键对应的值后，usStates 被更新为 ["MN": "Minnesota", "WA": "Washington",
    "TX": "Texas"]。记住，nil 是特殊的，表示没有任何值。因此你不会在字典中看到 "MA": nil。'
- en: '**REPLACING ITEMS IN A DICTIONARY**'
  id: totrans-10495
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**在字典中替换项**'
- en: 'Replacing an item in a dictionary is also easy. It works the same was as replacing
    an item in an array. You just set the item that you want to replace to something
    else. Say you create a dictionary of fruit colors:'
  id: totrans-10496
  prefs: []
  type: TYPE_NORMAL
  zh: 替换字典中的项也很简单。它的操作方式与替换数组中的项相同。你只需将你想要替换的项设置为其他值。例如，你创建了一个水果颜色的字典：
- en: '![](Image00146.jpg)'
  id: totrans-10497
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00146.jpg)'
- en: At first we had the value "apple" for "red" , but then we decided that "raspberry"
    is a better fruit to use since sometimes apples are green or yellow. To replace
    "apple" with "raspberry" , we set colorFruits["red"] to its new value ➊ .
  id: totrans-10498
  prefs: []
  type: TYPE_NORMAL
  zh: 起初我们为 "red" 设置了值 "apple"，但是后来我们决定 "raspberry" 是一个更好的水果，因为有时候苹果是绿色或黄色的。为了用 "raspberry"
    替换 "apple"，我们将 colorFruits["red"] 设置为它的新值 ➊。
- en: You may remember that this is the same way we entered a new value into a dictionary.
    If the key already exists in the dictionary, then the value for that key is replaced.
    If the key doesn’t already exist, then the new key/value pair will be added to
    the dictionary.
  id: totrans-10499
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能还记得，这和我们向字典中输入新值的方式是一样的。如果键已经存在于字典中，那么该键的值会被替换。如果键不存在，则新的键/值对会被添加到字典中。
- en: '![Image](Image00147.jpg)'
  id: totrans-10500
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00147.jpg)'
- en: '**USING DICTIONARY PROPERTIES**'
  id: totrans-10501
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**使用字典属性**'
- en: 'Like an array, a dictionary also has an isEmpty property and a count property.
    For example, the following code shows how you can use the isEmpty property to
    check if a dictionary is empty, and if it isn’t empty, the count property checks
    how many items you have. Imagine you have a basket of fruit for sale. You can
    use these properties to help you keep track of everything:'
  id: totrans-10502
  prefs: []
  type: TYPE_NORMAL
  zh: 像数组一样，字典也有 isEmpty 属性和 count 属性。例如，以下代码展示了如何使用 isEmpty 属性检查字典是否为空，如果不为空，则使用
    count 属性检查有多少项。假设您有一个待售的水果篮，您可以使用这些属性来帮助您跟踪所有内容：
- en: '![Image](Image00148.jpg)'
  id: totrans-10503
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00148.jpg)'
- en: 'A dictionary also has two special properties: keys , which contains all of
    the dictionary’s keys, and values , which contains all of its values. We’ll use
    these two properties when we loop through the dictionary.'
  id: totrans-10504
  prefs: []
  type: TYPE_NORMAL
  zh: 字典还有两个特殊的属性：keys，它包含字典的所有键，和 values，它包含字典的所有值。我们将在遍历字典时使用这两个属性。
- en: Let’s write some code that loops through our fruit baskets and prints the price
    of each fruit.
  id: totrans-10505
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们编写一些代码，遍历我们的水果篮并打印每个水果的价格。
- en: '**LOOPING OVER A DICTIONARY**'
  id: totrans-10506
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**遍历字典**'
- en: 'You can loop through a dictionary using a for-in loop. Because each item has
    a key and a value, you can do this in two different ways. This is how to loop
    through a dictionary using its keys:'
  id: totrans-10507
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用 for-in 循环遍历字典。由于每个项目都有一个键和值，您可以通过两种不同的方式来实现这一点。这是使用字典的键来遍历字典的方法：
- en: '![Image](Image00149.jpg)'
  id: totrans-10508
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00149.jpg)'
- en: Here we use the dictionary’s keys property ➊ to loop through fruitBasket and
    print its contents. We start by writing the keyword for , followed by a constant
    name fruit for the dictionary key, the keyword in , the dictionary name, a period,
    and keys .
  id: totrans-10509
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们使用字典的 keys 属性 ➊ 来遍历 fruitBasket 并打印其内容。我们首先写下关键字 for，然后是字典键的常量名称 fruit，接着是关键字
    in、字典名称、一个句点和 keys。
- en: Inside the braces of our for-in loop, we have access to both the key, which
    we call fruit ➋ , and the value at that key when we force-unwrap its contents
    with fruitBasket[fruit]! ➌ . That value will be the fruit’s price.
  id: totrans-10510
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们 for-in 循环的大括号内，我们可以访问到键（我们称之为 fruit ➋），以及当我们强制解包其内容（通过 fruitBasket[fruit]!
    ➌）时该键的值。该值将是水果的价格。
- en: In this case, it’s safe to force-unwrap the value using an exclamation point
    because we know that the fruit key we’re using is definitely inside the dictionary.
  id: totrans-10511
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，使用感叹号强制解包值是安全的，因为我们知道我们正在使用的 fruit 键肯定在字典中。
- en: Any code we put inside the for-in loop will run once for every key in our dictionary.
    So you should see the print statement display three times.
  id: totrans-10512
  prefs: []
  type: TYPE_NORMAL
  zh: 我们放在 for-in 循环中的任何代码都会针对字典中的每个键执行一次。因此，您应该看到 print 语句显示三次。
- en: 'We can also loop through the dictionary using its values property:'
  id: totrans-10513
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以使用字典的 values 属性来遍历字典：
- en: '![Image](Image00150.jpg)'
  id: totrans-10514
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00150.jpg)'
- en: We use the same style of for-in loop, but now we use a constant to refer to
    each value, which we call price , in the values property. When looping through
    values, we don’t have access to the keys from inside the loop.
  id: totrans-10515
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用相同的 for-in 循环样式，但这次我们使用一个常量来引用 values 属性中的每个值，我们称其为 price。在遍历值时，我们无法从循环内部访问到键。
- en: Another difference to note is that price is not an optional because it’s accessed
    directly as a value in the fruitBasket dictionary. That means we don’t have to
    unwrap it. You should still see the print statement printed three times. [Figure
    6-6](text00016.html#ch06fig6) shows the output of both loops.
  id: totrans-10516
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个需要注意的区别是，price 不是可选的，因为它是直接作为值访问字典中的元素。这意味着我们不需要解包它。您仍然应该看到 print 语句打印三次。[图
    6-6](text00016.html#ch06fig6) 显示了两个循环的输出。
- en: '![Image](Image00151.jpg)'
  id: totrans-10517
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00151.jpg)'
- en: '*Figure 6-6: Looping through the keys and values of a dictionary with a for-in
    loop*'
  id: totrans-10518
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 6-6：使用 for-in 循环遍历字典的键和值*'
- en: The order of your results might be slightly different from ours. That’s because
    the items in a dictionary aren’t in a numbered order like they are in an array!
    And because the order is not guaranteed, you might see a different order printed
    if you run the same code again.
  id: totrans-10519
  prefs: []
  type: TYPE_NORMAL
  zh: 结果的顺序可能与我们的稍有不同。那是因为字典中的项目不像数组那样按编号顺序排列！由于顺序不保证，如果再次运行相同的代码，您可能会看到不同的顺序。
- en: '**WHAT YOU LEARNED**'
  id: totrans-10520
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**你学到了什么**'
- en: In this chapter, you learned how to store collections of items in an array and
    in a dictionary. To store items in an ordered list, you would use an array and
    look up each item by its index. If you wanted to store items by key instead, you
    would use a dictionary.
  id: totrans-10521
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你学会了如何在数组和字典中存储项目。为了将项目存储在有序列表中，你会使用数组，并通过索引查找每个项目。如果你希望根据键存储项目，那么你会使用字典。
- en: Knowing about arrays and dictionaries and how to use them is a powerful building
    block for almost any programming language. Next we will learn about functions,
    another very powerful tool. Functions are blocks of code that you create and name
    to perform a specific job. After you have written a function, you can use its
    name to call it from almost anywhere in your program.
  id: totrans-10522
  prefs: []
  type: TYPE_NORMAL
  zh: 了解数组和字典，以及如何使用它们，是几乎所有编程语言的强大基础。接下来，我们将学习函数，另一个非常强大的工具。函数是你创建并命名的一段代码，用于执行特定的任务。写完一个函数后，你可以通过它的名称在程序中的几乎任何地方调用它。
- en: '![](Image00144.jpg)'
  id: totrans-10523
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00144.jpg)'
- en: 'Now when you look at usStates , you’ll see that it’s updated to ["MN": "Minnesota",
    "WA": "Washington", "MA": "Massachusetts", "TX": "Texas"] . Remember, because
    you don’t have to rely on indices, your new dictionary item might appear anywhere
    in the dictionary.'
  id: totrans-10524
  prefs: []
  type: TYPE_NORMAL
  zh: '现在当你查看 usStates 时，你会看到它已更新为 ["MN": "Minnesota", "WA": "Washington", "MA": "Massachusetts",
    "TX": "Texas"]。记住，由于你不必依赖索引，你的新字典项可能出现在字典的任何位置。'
- en: '**REMOVING ITEMS FROM A DICTIONARY**'
  id: totrans-10525
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**从字典中移除项**'
- en: Removing an item from a dictionary is quite simple; you do so by setting the
    value to nil . Because the values in dictionaries are returned as optionals, you
    don’t have to worry about nil causing any problems in your dictionary.
  id: totrans-10526
  prefs: []
  type: TYPE_NORMAL
  zh: 从字典中移除一项也相当简单；你只需要将其值设置为 nil。因为字典中的值是以可选类型返回的，所以你不必担心 nil 会在字典中引起任何问题。
- en: '![](Image00145.jpg)'
  id: totrans-10527
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00145.jpg)'
- en: 'You can see that after you remove the value at the key "MA" , usStates is updated
    to ["MN": "Minnesota", "WA": "Washington", "TX": "Texas"] . Remember that nil
    is special and means that there’s no value at all. That’s why you don’t see "MA":
    nil in our dictionary.'
  id: totrans-10528
  prefs: []
  type: TYPE_NORMAL
  zh: '你可以看到，在移除键为 "MA" 的值后，usStates 更新为 ["MN": "Minnesota", "WA": "Washington", "TX":
    "Texas"]。记住，nil 是特殊的，表示完全没有值。因此你不会在我们的字典中看到 "MA": nil。'
- en: '**REPLACING ITEMS IN A DICTIONARY**'
  id: totrans-10529
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**在字典中替换项**'
- en: 'Replacing an item in a dictionary is also easy. It works the same was as replacing
    an item in an array. You just set the item that you want to replace to something
    else. Say you create a dictionary of fruit colors:'
  id: totrans-10530
  prefs: []
  type: TYPE_NORMAL
  zh: 在字典中替换项也很简单。它的工作方式与替换数组中的项一样。你只需将要替换的项设置为其他值。比如，你创建了一个水果颜色的字典：
- en: '![](Image00146.jpg)'
  id: totrans-10531
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00146.jpg)'
- en: At first we had the value "apple" for "red" , but then we decided that "raspberry"
    is a better fruit to use since sometimes apples are green or yellow. To replace
    "apple" with "raspberry" , we set colorFruits["red"] to its new value ➊ .
  id: totrans-10532
  prefs: []
  type: TYPE_NORMAL
  zh: 一开始我们为 "red" 配置了值 "apple"，但后来我们决定使用 "raspberry" 作为更合适的水果，因为有时苹果是绿色或黄色的。为了用 "raspberry"
    替换 "apple"，我们将 colorFruits["red"] 设置为新的值 ➊。
- en: You may remember that this is the same way we entered a new value into a dictionary.
    If the key already exists in the dictionary, then the value for that key is replaced.
    If the key doesn’t already exist, then the new key/value pair will be added to
    the dictionary.
  id: totrans-10533
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能记得，这与我们在字典中输入新值的方式是一样的。如果键已经存在于字典中，则该键的值会被替换。如果该键尚不存在，则新的键/值对将被添加到字典中。
- en: '![Image](Image00147.jpg)'
  id: totrans-10534
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00147.jpg)'
- en: '**USING DICTIONARY PROPERTIES**'
  id: totrans-10535
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**使用字典属性**'
- en: 'Like an array, a dictionary also has an isEmpty property and a count property.
    For example, the following code shows how you can use the isEmpty property to
    check if a dictionary is empty, and if it isn’t empty, the count property checks
    how many items you have. Imagine you have a basket of fruit for sale. You can
    use these properties to help you keep track of everything:'
  id: totrans-10536
  prefs: []
  type: TYPE_NORMAL
  zh: 像数组一样，字典也具有 isEmpty 属性和 count 属性。例如，以下代码展示了如何使用 isEmpty 属性检查字典是否为空，如果字典不为空，count
    属性则检查你有多少个项目。假设你有一个出售水果的篮子，你可以使用这些属性来帮助你跟踪所有的东西：
- en: '![Image](Image00148.jpg)'
  id: totrans-10537
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00148.jpg)'
- en: 'A dictionary also has two special properties: keys , which contains all of
    the dictionary’s keys, and values , which contains all of its values. We’ll use
    these two properties when we loop through the dictionary.'
  id: totrans-10538
  prefs: []
  type: TYPE_NORMAL
  zh: 字典还有两个特殊属性：keys，包含字典的所有键；values，包含字典的所有值。我们将在遍历字典时使用这两个属性。
- en: Let’s write some code that loops through our fruit baskets and prints the price
    of each fruit.
  id: totrans-10539
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们编写一些代码，遍历我们的水果篮并打印每种水果的价格。
- en: '**LOOPING OVER A DICTIONARY**'
  id: totrans-10540
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**遍历字典**'
- en: 'You can loop through a dictionary using a for-in loop. Because each item has
    a key and a value, you can do this in two different ways. This is how to loop
    through a dictionary using its keys:'
  id: totrans-10541
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用for-in循环遍历字典。因为每个项都有一个键和值，所以你可以用两种不同的方式来遍历。这是通过键遍历字典的方法：
- en: '![Image](Image00149.jpg)'
  id: totrans-10542
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00149.jpg)'
- en: Here we use the dictionary’s keys property ➊ to loop through fruitBasket and
    print its contents. We start by writing the keyword for , followed by a constant
    name fruit for the dictionary key, the keyword in , the dictionary name, a period,
    and keys .
  id: totrans-10543
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们使用字典的keys属性 ➊ 来遍历fruitBasket并打印其内容。我们首先编写关键字for，后跟字典键的常量名称fruit，再加上关键字in，字典名称，一个句点和keys。
- en: Inside the braces of our for-in loop, we have access to both the key, which
    we call fruit ➋ , and the value at that key when we force-unwrap its contents
    with fruitBasket[fruit]! ➌ . That value will be the fruit’s price.
  id: totrans-10544
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的for-in循环的大括号内，我们可以访问键（我们称之为fruit ➋）以及通过fruitBasket[fruit]! ➌ 强制解包其内容时该键的值。该值将是水果的价格。
- en: In this case, it’s safe to force-unwrap the value using an exclamation point
    because we know that the fruit key we’re using is definitely inside the dictionary.
  id: totrans-10545
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，使用感叹号强制解包值是安全的，因为我们知道我们正在使用的水果键一定在字典中。
- en: Any code we put inside the for-in loop will run once for every key in our dictionary.
    So you should see the print statement display three times.
  id: totrans-10546
  prefs: []
  type: TYPE_NORMAL
  zh: 我们放入for-in循环中的任何代码都会针对字典中的每个键运行一次。因此，你应该看到打印语句会显示三次。
- en: 'We can also loop through the dictionary using its values property:'
  id: totrans-10547
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以通过字典的values属性遍历字典：
- en: '![Image](Image00150.jpg)'
  id: totrans-10548
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00150.jpg)'
- en: We use the same style of for-in loop, but now we use a constant to refer to
    each value, which we call price , in the values property. When looping through
    values, we don’t have access to the keys from inside the loop.
  id: totrans-10549
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用相同风格的for-in循环，但现在我们使用常量来引用每个值，我们称之为price，来自values属性。在遍历值时，我们无法从循环内部访问键。
- en: Another difference to note is that price is not an optional because it’s accessed
    directly as a value in the fruitBasket dictionary. That means we don’t have to
    unwrap it. You should still see the print statement printed three times. [Figure
    6-6](text00016.html#ch06fig6) shows the output of both loops.
  id: totrans-10550
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个需要注意的区别是，price不是一个可选项，因为它是直接作为fruitBasket字典中的值访问的。这意味着我们不需要解包它。你仍然应该看到打印语句被打印三次。[图6-6](text00016.html#ch06fig6)显示了两种循环的输出。
- en: '![Image](Image00151.jpg)'
  id: totrans-10551
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00151.jpg)'
- en: '*Figure 6-6: Looping through the keys and values of a dictionary with a for-in
    loop*'
  id: totrans-10552
  prefs: []
  type: TYPE_NORMAL
  zh: '*图6-6：使用for-in循环遍历字典的键和值*'
- en: The order of your results might be slightly different from ours. That’s because
    the items in a dictionary aren’t in a numbered order like they are in an array!
    And because the order is not guaranteed, you might see a different order printed
    if you run the same code again.
  id: totrans-10553
  prefs: []
  type: TYPE_NORMAL
  zh: 你的结果顺序可能与我们的略有不同。这是因为字典中的项不像数组中的项那样是按编号排序的！由于顺序无法保证，如果你重新运行相同的代码，你可能会看到不同的顺序。
- en: '**WHAT YOU LEARNED**'
  id: totrans-10554
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**你学到了什么**'
- en: In this chapter, you learned how to store collections of items in an array and
    in a dictionary. To store items in an ordered list, you would use an array and
    look up each item by its index. If you wanted to store items by key instead, you
    would use a dictionary.
  id: totrans-10555
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你学习了如何在数组和字典中存储项的集合。为了将项存储在有序列表中，你会使用数组并通过索引查找每个项。如果你想按键存储项，你则会使用字典。
- en: Knowing about arrays and dictionaries and how to use them is a powerful building
    block for almost any programming language. Next we will learn about functions,
    another very powerful tool. Functions are blocks of code that you create and name
    to perform a specific job. After you have written a function, you can use its
    name to call it from almost anywhere in your program.
  id: totrans-10556
  prefs: []
  type: TYPE_NORMAL
  zh: 了解数组和字典及其使用方法，是几乎所有编程语言中的一个强大基础。接下来我们将学习函数，另一个非常强大的工具。函数是你创建并命名的代码块，用于执行特定的任务。在编写完函数后，你可以使用其名称从程序的几乎任何地方调用它。
- en: 'Now when you look at usStates , you’ll see that it’s updated to ["MN": "Minnesota",
    "WA": "Washington", "MA": "Massachusetts", "TX": "Texas"] . Remember, because
    you don’t have to rely on indices, your new dictionary item might appear anywhere
    in the dictionary.'
  id: totrans-10557
  prefs: []
  type: TYPE_NORMAL
  zh: '现在，当你查看 `usStates` 时，你会看到它已经更新为 ["MN": "Minnesota", "WA": "Washington", "MA":
    "Massachusetts", "TX": "Texas"]。记住，由于你不需要依赖索引，所以新的字典项可能出现在字典的任何位置。'
- en: '**REMOVING ITEMS FROM A DICTIONARY**'
  id: totrans-10558
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**从字典中移除项**'
- en: Removing an item from a dictionary is quite simple; you do so by setting the
    value to nil . Because the values in dictionaries are returned as optionals, you
    don’t have to worry about nil causing any problems in your dictionary.
  id: totrans-10559
  prefs: []
  type: TYPE_NORMAL
  zh: 从字典中移除项非常简单；你只需将其值设置为 `nil`。因为字典中的值是以可选项返回的，所以你不必担心 `nil` 会在字典中引发任何问题。
- en: '![](Image00145.jpg)'
  id: totrans-10560
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00145.jpg)'
- en: 'You can see that after you remove the value at the key "MA" , usStates is updated
    to ["MN": "Minnesota", "WA": "Washington", "TX": "Texas"] . Remember that nil
    is special and means that there’s no value at all. That’s why you don’t see "MA":
    nil in our dictionary.'
  id: totrans-10561
  prefs: []
  type: TYPE_NORMAL
  zh: '你可以看到，在你移除键为 "MA" 的值之后，`usStates` 已更新为 ["MN": "Minnesota", "WA": "Washington",
    "TX": "Texas"]。记住，`nil` 是特殊的，意味着没有任何值。这就是为什么你在字典中看不到 "MA": nil 的原因。'
- en: '**REPLACING ITEMS IN A DICTIONARY**'
  id: totrans-10562
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**替换字典中的项**'
- en: 'Replacing an item in a dictionary is also easy. It works the same was as replacing
    an item in an array. You just set the item that you want to replace to something
    else. Say you create a dictionary of fruit colors:'
  id: totrans-10563
  prefs: []
  type: TYPE_NORMAL
  zh: 替换字典中的项也很简单。它的工作方式与替换数组中的项相同。你只需将你想要替换的项设置为其他值。假设你创建了一个水果颜色的字典：
- en: '![](Image00146.jpg)'
  id: totrans-10564
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00146.jpg)'
- en: At first we had the value "apple" for "red" , but then we decided that "raspberry"
    is a better fruit to use since sometimes apples are green or yellow. To replace
    "apple" with "raspberry" , we set colorFruits["red"] to its new value ➊ .
  id: totrans-10565
  prefs: []
  type: TYPE_NORMAL
  zh: 一开始我们为 "red" 设置了值 "apple"，但后来我们决定 "raspberry" 是一个更合适的水果，因为有时苹果是绿色或黄色的。为了将 "apple"
    替换为 "raspberry"，我们将 `colorFruits["red"]` 设置为它的新值 ➊。
- en: You may remember that this is the same way we entered a new value into a dictionary.
    If the key already exists in the dictionary, then the value for that key is replaced.
    If the key doesn’t already exist, then the new key/value pair will be added to
    the dictionary.
  id: totrans-10566
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能记得，这与我们将新值输入字典的方式相同。如果字典中已存在该键，则会替换该键的值。如果该键不存在，则新的键/值对会被添加到字典中。
- en: '![Image](Image00147.jpg)'
  id: totrans-10567
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00147.jpg)'
- en: '**USING DICTIONARY PROPERTIES**'
  id: totrans-10568
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**使用字典属性**'
- en: 'Like an array, a dictionary also has an isEmpty property and a count property.
    For example, the following code shows how you can use the isEmpty property to
    check if a dictionary is empty, and if it isn’t empty, the count property checks
    how many items you have. Imagine you have a basket of fruit for sale. You can
    use these properties to help you keep track of everything:'
  id: totrans-10569
  prefs: []
  type: TYPE_NORMAL
  zh: 与数组一样，字典也有一个 `isEmpty` 属性和一个 `count` 属性。例如，以下代码展示了如何使用 `isEmpty` 属性检查字典是否为空，如果字典不为空，`count`
    属性则用来检查你有多少项。假设你有一个水果篮子在售卖。你可以使用这些属性来帮助你追踪一切：
- en: '![Image](Image00148.jpg)'
  id: totrans-10570
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00148.jpg)'
- en: 'A dictionary also has two special properties: keys , which contains all of
    the dictionary’s keys, and values , which contains all of its values. We’ll use
    these two properties when we loop through the dictionary.'
  id: totrans-10571
  prefs: []
  type: TYPE_NORMAL
  zh: 字典还有两个特殊属性：`keys`，它包含所有字典的键，以及 `values`，它包含所有的值。我们将在遍历字典时使用这两个属性。
- en: Let’s write some code that loops through our fruit baskets and prints the price
    of each fruit.
  id: totrans-10572
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们写一些代码，遍历我们的水果篮子并打印每种水果的价格。
- en: '**LOOPING OVER A DICTIONARY**'
  id: totrans-10573
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**遍历字典**'
- en: 'You can loop through a dictionary using a for-in loop. Because each item has
    a key and a value, you can do this in two different ways. This is how to loop
    through a dictionary using its keys:'
  id: totrans-10574
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用 `for-in` 循环遍历字典。因为每一项都有一个键和值，你可以用两种不同的方式来做。以下是通过字典的键遍历字典的方法：
- en: '![Image](Image00149.jpg)'
  id: totrans-10575
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00149.jpg)'
- en: Here we use the dictionary’s keys property ➊ to loop through fruitBasket and
    print its contents. We start by writing the keyword for , followed by a constant
    name fruit for the dictionary key, the keyword in , the dictionary name, a period,
    and keys .
  id: totrans-10576
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们使用字典的 `keys` 属性 ➊ 来遍历 `fruitBasket` 并打印其内容。我们首先写出关键字 `for`，然后是字典键的常量名
    `fruit`，接着是关键字 `in`，字典名，句点，以及 `keys`。
- en: Inside the braces of our for-in loop, we have access to both the key, which
    we call fruit ➋ , and the value at that key when we force-unwrap its contents
    with fruitBasket[fruit]! ➌ . That value will be the fruit’s price.
  id: totrans-10577
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们 for-in 循环的大括号内，我们可以访问键（我们称之为 fruit ➋）和该键对应的值，当我们使用 fruitBasket[fruit]! ➌
    强制解包其内容时。该值将是水果的价格。
- en: In this case, it’s safe to force-unwrap the value using an exclamation point
    because we know that the fruit key we’re using is definitely inside the dictionary.
  id: totrans-10578
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，使用感叹号强制解包值是安全的，因为我们知道我们使用的水果键肯定存在于字典中。
- en: Any code we put inside the for-in loop will run once for every key in our dictionary.
    So you should see the print statement display three times.
  id: totrans-10579
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在 for-in 循环中放置的任何代码都会针对字典中的每个键运行一次。所以你应该看到 print 语句显示三次。
- en: 'We can also loop through the dictionary using its values property:'
  id: totrans-10580
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以通过字典的 values 属性遍历字典：
- en: '![Image](Image00150.jpg)'
  id: totrans-10581
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00150.jpg)'
- en: We use the same style of for-in loop, but now we use a constant to refer to
    each value, which we call price , in the values property. When looping through
    values, we don’t have access to the keys from inside the loop.
  id: totrans-10582
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用相同样式的 for-in 循环，但这次我们使用一个常量来引用每个值，我们称之为 price，位于 values 属性中。在循环遍历值时，我们无法从循环内访问键。
- en: Another difference to note is that price is not an optional because it’s accessed
    directly as a value in the fruitBasket dictionary. That means we don’t have to
    unwrap it. You should still see the print statement printed three times. [Figure
    6-6](text00016.html#ch06fig6) shows the output of both loops.
  id: totrans-10583
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个需要注意的区别是，price 不是一个可选项，因为它是通过直接访问 fruitBasket 字典中的值来获取的。这意味着我们不需要解包它。你仍然应该看到
    print 语句显示三次。[图 6-6](text00016.html#ch06fig6) 显示了两个循环的输出。
- en: '![Image](Image00151.jpg)'
  id: totrans-10584
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00151.jpg)'
- en: '*Figure 6-6: Looping through the keys and values of a dictionary with a for-in
    loop*'
  id: totrans-10585
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 6-6：使用 for-in 循环遍历字典的键和值*'
- en: The order of your results might be slightly different from ours. That’s because
    the items in a dictionary aren’t in a numbered order like they are in an array!
    And because the order is not guaranteed, you might see a different order printed
    if you run the same code again.
  id: totrans-10586
  prefs: []
  type: TYPE_NORMAL
  zh: 你的结果顺序可能与我们的略有不同。这是因为字典中的项不像数组那样按编号排序！由于顺序没有保证，如果你再次运行相同的代码，可能会看到不同的顺序。
- en: '**WHAT YOU LEARNED**'
  id: totrans-10587
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**你学到了什么**'
- en: In this chapter, you learned how to store collections of items in an array and
    in a dictionary. To store items in an ordered list, you would use an array and
    look up each item by its index. If you wanted to store items by key instead, you
    would use a dictionary.
  id: totrans-10588
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一章中，你学会了如何将项目存储在数组和字典中。为了在有序列表中存储项目，你会使用数组，并通过索引查找每个项目。如果你想通过键存储项目，则会使用字典。
- en: Knowing about arrays and dictionaries and how to use them is a powerful building
    block for almost any programming language. Next we will learn about functions,
    another very powerful tool. Functions are blocks of code that you create and name
    to perform a specific job. After you have written a function, you can use its
    name to call it from almost anywhere in your program.
  id: totrans-10589
  prefs: []
  type: TYPE_NORMAL
  zh: 了解数组和字典及其使用方法是几乎所有编程语言中强大构建模块的基础。接下来我们将学习函数，另一个非常强大的工具。函数是你创建并命名的代码块，用来执行特定的任务。在你编写了一个函数后，你可以通过它的名称从程序中的几乎任何地方调用它。
- en: '**REMOVING ITEMS FROM A DICTIONARY**'
  id: totrans-10590
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**从字典中移除项**'
- en: Removing an item from a dictionary is quite simple; you do so by setting the
    value to nil . Because the values in dictionaries are returned as optionals, you
    don’t have to worry about nil causing any problems in your dictionary.
  id: totrans-10591
  prefs: []
  type: TYPE_NORMAL
  zh: 从字典中移除项非常简单；你只需将该值设置为 nil。由于字典中的值是作为可选项返回的，因此你不必担心 nil 会在字典中引发任何问题。
- en: '![](Image00145.jpg)'
  id: totrans-10592
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00145.jpg)'
- en: 'You can see that after you remove the value at the key "MA" , usStates is updated
    to ["MN": "Minnesota", "WA": "Washington", "TX": "Texas"] . Remember that nil
    is special and means that there’s no value at all. That’s why you don’t see "MA":
    nil in our dictionary.'
  id: totrans-10593
  prefs: []
  type: TYPE_NORMAL
  zh: '你可以看到，在你移除键"MA"对应的值后，usStates 更新为["MN": "Minnesota", "WA": "Washington", "TX":
    "Texas"]。记住，nil 是特殊的，表示没有任何值。这就是为什么你在我们的字典中看不到 "MA": nil 的原因。'
- en: '**REPLACING ITEMS IN A DICTIONARY**'
  id: totrans-10594
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**替换字典中的项**'
- en: 'Replacing an item in a dictionary is also easy. It works the same was as replacing
    an item in an array. You just set the item that you want to replace to something
    else. Say you create a dictionary of fruit colors:'
  id: totrans-10595
  prefs: []
  type: TYPE_NORMAL
  zh: 替换字典中的项也很简单。它与替换数组中的项的方式相同。你只需要将想要替换的项设置为其他值。例如，你创建了一个水果颜色的字典：
- en: '![](Image00146.jpg)'
  id: totrans-10596
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00146.jpg)'
- en: At first we had the value "apple" for "red" , but then we decided that "raspberry"
    is a better fruit to use since sometimes apples are green or yellow. To replace
    "apple" with "raspberry" , we set colorFruits["red"] to its new value ➊ .
  id: totrans-10597
  prefs: []
  type: TYPE_NORMAL
  zh: 最初，我们为“red”设置了值“apple”，但后来我们决定使用“raspberry”作为更好的水果，因为有时苹果是绿色或黄色的。为了用“raspberry”替换“apple”，我们将
    `colorFruits["red"]` 设置为它的新值 ➊。
- en: You may remember that this is the same way we entered a new value into a dictionary.
    If the key already exists in the dictionary, then the value for that key is replaced.
    If the key doesn’t already exist, then the new key/value pair will be added to
    the dictionary.
  id: totrans-10598
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能记得，这是我们向字典中添加新值的相同方式。如果键已经存在于字典中，那么该键的值将被替换。如果键不存在，则新键/值对将被添加到字典中。
- en: '![Image](Image00147.jpg)'
  id: totrans-10599
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00147.jpg)'
- en: '**USING DICTIONARY PROPERTIES**'
  id: totrans-10600
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**使用字典属性**'
- en: 'Like an array, a dictionary also has an isEmpty property and a count property.
    For example, the following code shows how you can use the isEmpty property to
    check if a dictionary is empty, and if it isn’t empty, the count property checks
    how many items you have. Imagine you have a basket of fruit for sale. You can
    use these properties to help you keep track of everything:'
  id: totrans-10601
  prefs: []
  type: TYPE_NORMAL
  zh: 与数组一样，字典也具有 `isEmpty` 属性和 `count` 属性。例如，以下代码展示了如何使用 `isEmpty` 属性检查字典是否为空，如果不为空，则
    `count` 属性检查你有多少项。假设你有一个水果篮在出售，你可以使用这些属性来帮助你跟踪所有内容：
- en: '![Image](Image00148.jpg)'
  id: totrans-10602
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00148.jpg)'
- en: 'A dictionary also has two special properties: keys , which contains all of
    the dictionary’s keys, and values , which contains all of its values. We’ll use
    these two properties when we loop through the dictionary.'
  id: totrans-10603
  prefs: []
  type: TYPE_NORMAL
  zh: 字典还有两个特殊属性：`keys`，它包含字典的所有键，以及 `values`，它包含字典的所有值。我们将在遍历字典时使用这两个属性。
- en: Let’s write some code that loops through our fruit baskets and prints the price
    of each fruit.
  id: totrans-10604
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们写一些代码，遍历我们的水果篮，并打印每种水果的价格。
- en: '**LOOPING OVER A DICTIONARY**'
  id: totrans-10605
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**遍历字典**'
- en: 'You can loop through a dictionary using a for-in loop. Because each item has
    a key and a value, you can do this in two different ways. This is how to loop
    through a dictionary using its keys:'
  id: totrans-10606
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用 `for-in` 循环遍历字典。由于每个项都有一个键和值，因此你可以通过两种不同的方式来做到这一点。这是使用字典的键来遍历字典的方法：
- en: '![Image](Image00149.jpg)'
  id: totrans-10607
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00149.jpg)'
- en: Here we use the dictionary’s keys property ➊ to loop through fruitBasket and
    print its contents. We start by writing the keyword for , followed by a constant
    name fruit for the dictionary key, the keyword in , the dictionary name, a period,
    and keys .
  id: totrans-10608
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们使用字典的键属性 ➊ 来遍历 `fruitBasket` 并打印其内容。我们从编写关键字 `for` 开始，后跟字典键的常量名称 `fruit`，关键字
    `in`，字典名称，句点以及 `keys`。
- en: Inside the braces of our for-in loop, we have access to both the key, which
    we call fruit ➋ , and the value at that key when we force-unwrap its contents
    with fruitBasket[fruit]! ➌ . That value will be the fruit’s price.
  id: totrans-10609
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `for-in` 循环的花括号内，我们可以访问键（我们称之为 `fruit` ➋）以及通过强制解包其内容 `fruitBasket[fruit]!`
    ➌ 来访问该键对应的值。这个值将是水果的价格。
- en: In this case, it’s safe to force-unwrap the value using an exclamation point
    because we know that the fruit key we’re using is definitely inside the dictionary.
  id: totrans-10610
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，使用感叹号强制解包值是安全的，因为我们知道我们使用的水果键肯定在字典中。
- en: Any code we put inside the for-in loop will run once for every key in our dictionary.
    So you should see the print statement display three times.
  id: totrans-10611
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在 `for-in` 循环中放置的任何代码都会对字典中的每个键运行一次。因此，你应该看到打印语句显示三次。
- en: 'We can also loop through the dictionary using its values property:'
  id: totrans-10612
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以通过字典的 `values` 属性来遍历字典：
- en: '![Image](Image00150.jpg)'
  id: totrans-10613
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00150.jpg)'
- en: We use the same style of for-in loop, but now we use a constant to refer to
    each value, which we call price , in the values property. When looping through
    values, we don’t have access to the keys from inside the loop.
  id: totrans-10614
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用相同的 `for-in` 循环样式，但现在我们使用一个常量来引用 `values` 属性中的每个值，我们称之为 `price`。当遍历 `values`
    时，我们无法从循环内访问键。
- en: Another difference to note is that price is not an optional because it’s accessed
    directly as a value in the fruitBasket dictionary. That means we don’t have to
    unwrap it. You should still see the print statement printed three times. [Figure
    6-6](text00016.html#ch06fig6) shows the output of both loops.
  id: totrans-10615
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个需要注意的区别是，`price` 不是可选的，因为它是直接作为 `fruitBasket` 字典中的值访问的。这意味着我们不需要解包它。你仍然应该看到打印语句打印三次。[图
    6-6](text00016.html#ch06fig6) 显示了两个循环的输出。
- en: '![Image](Image00151.jpg)'
  id: totrans-10616
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00151.jpg)'
- en: '*Figure 6-6: Looping through the keys and values of a dictionary with a for-in
    loop*'
  id: totrans-10617
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 6-6：使用 for-in 循环遍历字典的键和值*'
- en: The order of your results might be slightly different from ours. That’s because
    the items in a dictionary aren’t in a numbered order like they are in an array!
    And because the order is not guaranteed, you might see a different order printed
    if you run the same code again.
  id: totrans-10618
  prefs: []
  type: TYPE_NORMAL
  zh: 你的结果顺序可能与我们的略有不同。这是因为字典中的项不像数组那样按编号顺序排列！由于顺序并不保证，你可能会看到不同的顺序，如果你再次运行相同的代码。
- en: '**WHAT YOU LEARNED**'
  id: totrans-10619
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**你学到的内容**'
- en: In this chapter, you learned how to store collections of items in an array and
    in a dictionary. To store items in an ordered list, you would use an array and
    look up each item by its index. If you wanted to store items by key instead, you
    would use a dictionary.
  id: totrans-10620
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你学会了如何在数组和字典中存储项目。为了存储有序列表中的项目，你将使用数组，并通过索引查找每个项。如果你想按键存储项目，你将使用字典。
- en: Knowing about arrays and dictionaries and how to use them is a powerful building
    block for almost any programming language. Next we will learn about functions,
    another very powerful tool. Functions are blocks of code that you create and name
    to perform a specific job. After you have written a function, you can use its
    name to call it from almost anywhere in your program.
  id: totrans-10621
  prefs: []
  type: TYPE_NORMAL
  zh: 了解数组和字典以及如何使用它们是几乎所有编程语言的强大构建块。接下来我们将学习函数，另一个非常强大的工具。函数是你创建并命名的一段代码，用于执行特定的任务。在你编写完一个函数后，可以使用它的名称从程序中的几乎任何地方调用它。
- en: Removing an item from a dictionary is quite simple; you do so by setting the
    value to nil . Because the values in dictionaries are returned as optionals, you
    don’t have to worry about nil causing any problems in your dictionary.
  id: totrans-10622
  prefs: []
  type: TYPE_NORMAL
  zh: 从字典中移除一项非常简单；你只需将该项的值设置为 nil。由于字典中的值是作为可选项返回的，因此你无需担心 nil 会在字典中引发任何问题。
- en: '![](Image00145.jpg)'
  id: totrans-10623
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00145.jpg)'
- en: 'You can see that after you remove the value at the key "MA" , usStates is updated
    to ["MN": "Minnesota", "WA": "Washington", "TX": "Texas"] . Remember that nil
    is special and means that there’s no value at all. That’s why you don’t see "MA":
    nil in our dictionary.'
  id: totrans-10624
  prefs: []
  type: TYPE_NORMAL
  zh: '你可以看到，在移除键 "MA" 对应的值之后，usStates 被更新为 ["MN": "Minnesota", "WA": "Washington",
    "TX": "Texas"]。记住，nil 是特殊的，它表示没有任何值。这就是为什么在我们的字典中看不到 "MA": nil 的原因。'
- en: '**REPLACING ITEMS IN A DICTIONARY**'
  id: totrans-10625
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**替换字典中的项**'
- en: 'Replacing an item in a dictionary is also easy. It works the same was as replacing
    an item in an array. You just set the item that you want to replace to something
    else. Say you create a dictionary of fruit colors:'
  id: totrans-10626
  prefs: []
  type: TYPE_NORMAL
  zh: 替换字典中的项也很简单。它的工作方式与替换数组中的项相同。你只需要将你想替换的项设置为其他内容。比如你创建一个水果颜色的字典：
- en: '![](Image00146.jpg)'
  id: totrans-10627
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00146.jpg)'
- en: At first we had the value "apple" for "red" , but then we decided that "raspberry"
    is a better fruit to use since sometimes apples are green or yellow. To replace
    "apple" with "raspberry" , we set colorFruits["red"] to its new value ➊ .
  id: totrans-10628
  prefs: []
  type: TYPE_NORMAL
  zh: 最开始我们将 "apple" 作为 "red" 的值，但后来我们决定 "raspberry" 是一个更好的水果选择，因为有时候苹果是绿色或黄色的。为了用
    "raspberry" 替换 "apple"，我们将 colorFruits["red"] 设置为它的新值 ➊。
- en: You may remember that this is the same way we entered a new value into a dictionary.
    If the key already exists in the dictionary, then the value for that key is replaced.
    If the key doesn’t already exist, then the new key/value pair will be added to
    the dictionary.
  id: totrans-10629
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能记得，这是我们将新值插入字典的方式。如果字典中已经存在该键，那么该键对应的值将被替换。如果该键不存在，那么新的键/值对将被添加到字典中。
- en: '![Image](Image00147.jpg)'
  id: totrans-10630
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Image00147.jpg)'
- en: '**USING DICTIONARY PROPERTIES**'
  id: totrans-10631
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**使用字典属性**'
- en: 'Like an array, a dictionary also has an isEmpty property and a count property.
    For example, the following code shows how you can use the isEmpty property to
    check if a dictionary is empty, and if it isn’t empty, the count property checks
    how many items you have. Imagine you have a basket of fruit for sale. You can
    use these properties to help you keep track of everything:'
  id: totrans-10632
  prefs: []
  type: TYPE_NORMAL
  zh: 与数组一样，字典也有 isEmpty 属性和 count 属性。例如，下面的代码展示了如何使用 isEmpty 属性检查字典是否为空，如果字典不为空，count
    属性则检查你有多少项。假设你有一个待售的水果篮子，你可以使用这些属性来帮助你跟踪一切：
- en: '![Image](Image00148.jpg)'
  id: totrans-10633
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Image00148.jpg)'
- en: 'A dictionary also has two special properties: keys , which contains all of
    the dictionary’s keys, and values , which contains all of its values. We’ll use
    these two properties when we loop through the dictionary.'
  id: totrans-10634
  prefs: []
  type: TYPE_NORMAL
  zh: 字典还有两个特殊属性：keys，包含字典中的所有键，以及 values，包含所有的值。我们将在遍历字典时使用这两个属性。
- en: Let’s write some code that loops through our fruit baskets and prints the price
    of each fruit.
  id: totrans-10635
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们写一些代码，循环遍历我们的水果篮子，并打印每个水果的价格。
- en: '**LOOPING OVER A DICTIONARY**'
  id: totrans-10636
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**遍历字典**'
- en: 'You can loop through a dictionary using a for-in loop. Because each item has
    a key and a value, you can do this in two different ways. This is how to loop
    through a dictionary using its keys:'
  id: totrans-10637
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用 for-in 循环遍历字典。由于每个项目都有一个键和值，你可以通过两种不同的方式来完成这项工作。这是通过键来遍历字典的方法：
- en: '![Image](Image00149.jpg)'
  id: totrans-10638
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Image00149.jpg)'
- en: Here we use the dictionary’s keys property ➊ to loop through fruitBasket and
    print its contents. We start by writing the keyword for , followed by a constant
    name fruit for the dictionary key, the keyword in , the dictionary name, a period,
    and keys .
  id: totrans-10639
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们使用字典的 keys 属性 ➊ 来循环遍历 fruitBasket，并打印其内容。我们从写关键字 for 开始，接着是常量名 fruit 来表示字典的键，再是关键字
    in，字典名，点号，最后是 keys。
- en: Inside the braces of our for-in loop, we have access to both the key, which
    we call fruit ➋ , and the value at that key when we force-unwrap its contents
    with fruitBasket[fruit]! ➌ . That value will be the fruit’s price.
  id: totrans-10640
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们 for-in 循环的大括号内，我们可以访问到键，即我们称之为 fruit ➋ 的键，以及当我们通过 fruitBasket[fruit]! ➌
    强制解包其内容时得到的值。这个值将是水果的价格。
- en: In this case, it’s safe to force-unwrap the value using an exclamation point
    because we know that the fruit key we’re using is definitely inside the dictionary.
  id: totrans-10641
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，强制解包这个值是安全的，因为我们知道正在使用的 fruit 键肯定在字典中。
- en: Any code we put inside the for-in loop will run once for every key in our dictionary.
    So you should see the print statement display three times.
  id: totrans-10642
  prefs: []
  type: TYPE_NORMAL
  zh: 我们放入 for-in 循环中的任何代码都会针对字典中的每个键运行一次。所以你应该会看到打印语句显示三次。
- en: 'We can also loop through the dictionary using its values property:'
  id: totrans-10643
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以通过字典的 values 属性来循环遍历：
- en: '![Image](Image00150.jpg)'
  id: totrans-10644
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Image00150.jpg)'
- en: We use the same style of for-in loop, but now we use a constant to refer to
    each value, which we call price , in the values property. When looping through
    values, we don’t have access to the keys from inside the loop.
  id: totrans-10645
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用相同的 for-in 循环样式，但现在我们用一个常量来引用每个值，我们称之为 price，存在 values 属性中。在循环遍历 values
    时，我们无法在循环内访问到键。
- en: Another difference to note is that price is not an optional because it’s accessed
    directly as a value in the fruitBasket dictionary. That means we don’t have to
    unwrap it. You should still see the print statement printed three times. [Figure
    6-6](text00016.html#ch06fig6) shows the output of both loops.
  id: totrans-10646
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个需要注意的区别是，price 不是可选的，因为它是直接作为水果篮字典中的一个值来访问的。这意味着我们不需要解包它。你仍然应该看到打印语句打印三次。[图
    6-6](text00016.html#ch06fig6) 显示了两个循环的输出。
- en: '![Image](Image00151.jpg)'
  id: totrans-10647
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Image00151.jpg)'
- en: '*Figure 6-6: Looping through the keys and values of a dictionary with a for-in
    loop*'
  id: totrans-10648
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 6-6：使用 for-in 循环遍历字典的键和值*'
- en: The order of your results might be slightly different from ours. That’s because
    the items in a dictionary aren’t in a numbered order like they are in an array!
    And because the order is not guaranteed, you might see a different order printed
    if you run the same code again.
  id: totrans-10649
  prefs: []
  type: TYPE_NORMAL
  zh: 你的结果顺序可能与我们的略有不同。这是因为字典中的项目不像数组那样按编号顺序排列！而且因为顺序不保证，如果你重新运行相同的代码，你可能会看到不同的输出顺序。
- en: '**WHAT YOU LEARNED**'
  id: totrans-10650
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**你学到的内容**'
- en: In this chapter, you learned how to store collections of items in an array and
    in a dictionary. To store items in an ordered list, you would use an array and
    look up each item by its index. If you wanted to store items by key instead, you
    would use a dictionary.
  id: totrans-10651
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一章中，你学会了如何将项目集合存储在数组和字典中。要将项目存储在有序列表中，你会使用数组，并通过索引查找每个项目。如果你想通过键来存储项目，你会使用字典。
- en: Knowing about arrays and dictionaries and how to use them is a powerful building
    block for almost any programming language. Next we will learn about functions,
    another very powerful tool. Functions are blocks of code that you create and name
    to perform a specific job. After you have written a function, you can use its
    name to call it from almost anywhere in your program.
  id: totrans-10652
  prefs: []
  type: TYPE_NORMAL
  zh: 了解数组和字典以及如何使用它们是几乎所有编程语言中非常强大的构建模块。接下来，我们将学习函数，这是另一个非常强大的工具。函数是你创建并命名的一段代码，用来执行特定的任务。编写完函数后，你可以通过其名称从程序的几乎任何地方调用它。
- en: '![](Image00145.jpg)'
  id: totrans-10653
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00145.jpg)'
- en: 'You can see that after you remove the value at the key "MA" , usStates is updated
    to ["MN": "Minnesota", "WA": "Washington", "TX": "Texas"] . Remember that nil
    is special and means that there’s no value at all. That’s why you don’t see "MA":
    nil in our dictionary.'
  id: totrans-10654
  prefs: []
  type: TYPE_NORMAL
  zh: '你可以看到，在移除键"MA"对应的值后，usStates被更新为["MN": "Minnesota", "WA": "Washington", "TX":
    "Texas"]。记住，nil是特殊的，表示没有值。这就是为什么在我们的字典中看不到"MA": nil。'
- en: '**REPLACING ITEMS IN A DICTIONARY**'
  id: totrans-10655
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**替换字典中的项**'
- en: 'Replacing an item in a dictionary is also easy. It works the same was as replacing
    an item in an array. You just set the item that you want to replace to something
    else. Say you create a dictionary of fruit colors:'
  id: totrans-10656
  prefs: []
  type: TYPE_NORMAL
  zh: 替换字典中的项也很简单。它的工作方式和替换数组中的项一样。你只需要将你想替换的项设置为其他值。比如你创建了一个水果颜色的字典：
- en: '![](Image00146.jpg)'
  id: totrans-10657
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00146.jpg)'
- en: At first we had the value "apple" for "red" , but then we decided that "raspberry"
    is a better fruit to use since sometimes apples are green or yellow. To replace
    "apple" with "raspberry" , we set colorFruits["red"] to its new value ➊ .
  id: totrans-10658
  prefs: []
  type: TYPE_NORMAL
  zh: 最初，我们为"red"设置了值"apple"，但后来我们决定"raspberry"是一个更好的水果，因为有时苹果是绿色或黄色的。为了将"apple"替换为"raspberry"，我们将colorFruits["red"]设置为它的新值
    ➊。
- en: You may remember that this is the same way we entered a new value into a dictionary.
    If the key already exists in the dictionary, then the value for that key is replaced.
    If the key doesn’t already exist, then the new key/value pair will be added to
    the dictionary.
  id: totrans-10659
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能还记得，这和我们向字典中添加新值的方式相同。如果键已存在于字典中，那么该键的值将被替换。如果该键不存在，则新的键值对将被添加到字典中。
- en: '![Image](Image00147.jpg)'
  id: totrans-10660
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00147.jpg)'
- en: '**USING DICTIONARY PROPERTIES**'
  id: totrans-10661
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**使用字典属性**'
- en: 'Like an array, a dictionary also has an isEmpty property and a count property.
    For example, the following code shows how you can use the isEmpty property to
    check if a dictionary is empty, and if it isn’t empty, the count property checks
    how many items you have. Imagine you have a basket of fruit for sale. You can
    use these properties to help you keep track of everything:'
  id: totrans-10662
  prefs: []
  type: TYPE_NORMAL
  zh: 像数组一样，字典也有isEmpty属性和count属性。例如，以下代码展示了如何使用isEmpty属性检查字典是否为空，如果不为空，则count属性会检查你有多少个项目。假设你有一个待售的水果篮子。你可以利用这些属性帮助你跟踪所有内容：
- en: '![Image](Image00148.jpg)'
  id: totrans-10663
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00148.jpg)'
- en: 'A dictionary also has two special properties: keys , which contains all of
    the dictionary’s keys, and values , which contains all of its values. We’ll use
    these two properties when we loop through the dictionary.'
  id: totrans-10664
  prefs: []
  type: TYPE_NORMAL
  zh: 字典还有两个特殊的属性：keys，它包含所有字典的键，以及values，它包含所有字典的值。我们将在遍历字典时使用这两个属性。
- en: Let’s write some code that loops through our fruit baskets and prints the price
    of each fruit.
  id: totrans-10665
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们编写一些代码，遍历我们的水果篮子并打印每种水果的价格。
- en: '**LOOPING OVER A DICTIONARY**'
  id: totrans-10666
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**遍历字典**'
- en: 'You can loop through a dictionary using a for-in loop. Because each item has
    a key and a value, you can do this in two different ways. This is how to loop
    through a dictionary using its keys:'
  id: totrans-10667
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用for-in循环遍历字典。因为每个项都有一个键和值，所以你可以用两种不同的方式进行遍历。这是使用键遍历字典的方式：
- en: '![Image](Image00149.jpg)'
  id: totrans-10668
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00149.jpg)'
- en: Here we use the dictionary’s keys property ➊ to loop through fruitBasket and
    print its contents. We start by writing the keyword for , followed by a constant
    name fruit for the dictionary key, the keyword in , the dictionary name, a period,
    and keys .
  id: totrans-10669
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们使用字典的keys属性 ➊ 来遍历fruitBasket并打印其内容。我们从写关键字for开始，后面跟着常量名fruit作为字典的键，接着是关键字in，字典的名字，一个句点，再加上keys。
- en: Inside the braces of our for-in loop, we have access to both the key, which
    we call fruit ➋ , and the value at that key when we force-unwrap its contents
    with fruitBasket[fruit]! ➌ . That value will be the fruit’s price.
  id: totrans-10670
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们for-in循环的大括号内，我们可以访问到键值（我们称之为fruit ➋）和通过强制解包其内容（fruitBasket[fruit]! ➌）获得的该键对应的值。这个值将是水果的价格。
- en: In this case, it’s safe to force-unwrap the value using an exclamation point
    because we know that the fruit key we’re using is definitely inside the dictionary.
  id: totrans-10671
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，使用感叹号强制解包值是安全的，因为我们知道我们使用的水果键肯定在字典中。
- en: Any code we put inside the for-in loop will run once for every key in our dictionary.
    So you should see the print statement display three times.
  id: totrans-10672
  prefs: []
  type: TYPE_NORMAL
  zh: 我们放入for-in循环中的任何代码都会对字典中的每个键执行一次。所以你应该能看到打印语句显示三次。
- en: 'We can also loop through the dictionary using its values property:'
  id: totrans-10673
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以使用字典的values属性进行循环遍历：
- en: '![Image](Image00150.jpg)'
  id: totrans-10674
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00150.jpg)'
- en: We use the same style of for-in loop, but now we use a constant to refer to
    each value, which we call price , in the values property. When looping through
    values, we don’t have access to the keys from inside the loop.
  id: totrans-10675
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用相同的for-in循环样式，但现在我们使用常量来引用每个值，称之为price，存在values属性中。在循环遍历值时，我们无法从循环内部访问键。
- en: Another difference to note is that price is not an optional because it’s accessed
    directly as a value in the fruitBasket dictionary. That means we don’t have to
    unwrap it. You should still see the print statement printed three times. [Figure
    6-6](text00016.html#ch06fig6) shows the output of both loops.
  id: totrans-10676
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个需要注意的区别是，price不是一个可选项，因为它是直接作为fruitBasket字典中的值进行访问的。这意味着我们不需要解包它。你仍然应该看到print语句被打印三次。[图6-6](text00016.html#ch06fig6)显示了两个循环的输出。
- en: '![Image](Image00151.jpg)'
  id: totrans-10677
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00151.jpg)'
- en: '*Figure 6-6: Looping through the keys and values of a dictionary with a for-in
    loop*'
  id: totrans-10678
  prefs: []
  type: TYPE_NORMAL
  zh: '*图6-6：使用for-in循环遍历字典的键和值*'
- en: The order of your results might be slightly different from ours. That’s because
    the items in a dictionary aren’t in a numbered order like they are in an array!
    And because the order is not guaranteed, you might see a different order printed
    if you run the same code again.
  id: totrans-10679
  prefs: []
  type: TYPE_NORMAL
  zh: 你的结果顺序可能与我们的略有不同。这是因为字典中的项目不像数组中的项目那样按编号顺序排列！由于顺序不可保证，所以如果你再次运行相同的代码，可能会看到不同的顺序输出。
- en: '**WHAT YOU LEARNED**'
  id: totrans-10680
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**你学到了什么**'
- en: In this chapter, you learned how to store collections of items in an array and
    in a dictionary. To store items in an ordered list, you would use an array and
    look up each item by its index. If you wanted to store items by key instead, you
    would use a dictionary.
  id: totrans-10681
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你学会了如何将一组项目存储在数组和字典中。要将项目存储在有序列表中，你会使用数组，并通过索引查找每个项目。如果你想通过键来存储项目，而不是索引，你会使用字典。
- en: Knowing about arrays and dictionaries and how to use them is a powerful building
    block for almost any programming language. Next we will learn about functions,
    another very powerful tool. Functions are blocks of code that you create and name
    to perform a specific job. After you have written a function, you can use its
    name to call it from almost anywhere in your program.
  id: totrans-10682
  prefs: []
  type: TYPE_NORMAL
  zh: 了解数组和字典及其用法是几乎任何编程语言的强大构建模块。接下来，我们将学习函数，这是另一个非常强大的工具。函数是你创建并命名的代码块，用于执行特定的工作。在编写函数之后，你可以通过它的名称在程序中的几乎任何地方调用它。
- en: 'You can see that after you remove the value at the key "MA" , usStates is updated
    to ["MN": "Minnesota", "WA": "Washington", "TX": "Texas"] . Remember that nil
    is special and means that there’s no value at all. That’s why you don’t see "MA":
    nil in our dictionary.'
  id: totrans-10683
  prefs: []
  type: TYPE_NORMAL
  zh: '你可以看到，在删除键“MA”的值之后，usStates被更新为["MN": "Minnesota", "WA": "Washington", "TX":
    "Texas"]。记住，nil是特殊的，意味着根本没有值。因此，你不会在我们的字典中看到"MA": nil。'
- en: '**REPLACING ITEMS IN A DICTIONARY**'
  id: totrans-10684
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**替换字典中的项目**'
- en: 'Replacing an item in a dictionary is also easy. It works the same was as replacing
    an item in an array. You just set the item that you want to replace to something
    else. Say you create a dictionary of fruit colors:'
  id: totrans-10685
  prefs: []
  type: TYPE_NORMAL
  zh: 在字典中替换项目也很简单。它的工作方式与替换数组中的项目相同。你只需将你想替换的项目设置为其他值。假设你创建了一个水果颜色的字典：
- en: '![](Image00146.jpg)'
  id: totrans-10686
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00146.jpg)'
- en: At first we had the value "apple" for "red" , but then we decided that "raspberry"
    is a better fruit to use since sometimes apples are green or yellow. To replace
    "apple" with "raspberry" , we set colorFruits["red"] to its new value ➊ .
  id: totrans-10687
  prefs: []
  type: TYPE_NORMAL
  zh: 最开始我们为“red”赋值为“apple”，但是后来我们决定“raspberry”是一个更好的水果选择，因为有时候苹果是绿色或黄色的。为了用“raspberry”替换“apple”，我们将colorFruits["red"]设置为它的新值➊。
- en: You may remember that this is the same way we entered a new value into a dictionary.
    If the key already exists in the dictionary, then the value for that key is replaced.
    If the key doesn’t already exist, then the new key/value pair will be added to
    the dictionary.
  id: totrans-10688
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能记得，这与我们将新值插入字典的方式相同。如果键已经存在于字典中，那么该键的值会被替换。如果键不存在，则新的键/值对会被添加到字典中。
- en: '![Image](Image00147.jpg)'
  id: totrans-10689
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00147.jpg)'
- en: '**USING DICTIONARY PROPERTIES**'
  id: totrans-10690
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**使用字典属性**'
- en: 'Like an array, a dictionary also has an isEmpty property and a count property.
    For example, the following code shows how you can use the isEmpty property to
    check if a dictionary is empty, and if it isn’t empty, the count property checks
    how many items you have. Imagine you have a basket of fruit for sale. You can
    use these properties to help you keep track of everything:'
  id: totrans-10691
  prefs: []
  type: TYPE_NORMAL
  zh: 与数组一样，字典也有一个 `isEmpty` 属性和一个 `count` 属性。例如，以下代码展示了如何使用 `isEmpty` 属性来检查字典是否为空，如果不为空，则使用
    `count` 属性检查你有多少项。假设你有一个待售的水果篮子。你可以使用这些属性来帮助你跟踪一切：
- en: '![Image](Image00148.jpg)'
  id: totrans-10692
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00148.jpg)'
- en: 'A dictionary also has two special properties: keys , which contains all of
    the dictionary’s keys, and values , which contains all of its values. We’ll use
    these two properties when we loop through the dictionary.'
  id: totrans-10693
  prefs: []
  type: TYPE_NORMAL
  zh: 字典还有两个特殊属性：`keys`，它包含字典的所有键；`values`，它包含字典的所有值。我们将在遍历字典时使用这两个属性。
- en: Let’s write some code that loops through our fruit baskets and prints the price
    of each fruit.
  id: totrans-10694
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们写一些代码，遍历我们的水果篮子并打印每个水果的价格。
- en: '**LOOPING OVER A DICTIONARY**'
  id: totrans-10695
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**遍历字典**'
- en: 'You can loop through a dictionary using a for-in loop. Because each item has
    a key and a value, you can do this in two different ways. This is how to loop
    through a dictionary using its keys:'
  id: totrans-10696
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用 `for-in` 循环遍历字典。因为每个条目都有一个键和值，所以你可以通过两种不同的方式来实现这一点。这是通过键来遍历字典的方法：
- en: '![Image](Image00149.jpg)'
  id: totrans-10697
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00149.jpg)'
- en: Here we use the dictionary’s keys property ➊ to loop through fruitBasket and
    print its contents. We start by writing the keyword for , followed by a constant
    name fruit for the dictionary key, the keyword in , the dictionary name, a period,
    and keys .
  id: totrans-10698
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们使用字典的 `keys` 属性 ➊ 来遍历 `fruitBasket` 并打印其内容。我们首先写关键词 `for`，然后是字典键的常量名称
    `fruit`，关键词 `in`，字典名称，句点和 `keys`。
- en: Inside the braces of our for-in loop, we have access to both the key, which
    we call fruit ➋ , and the value at that key when we force-unwrap its contents
    with fruitBasket[fruit]! ➌ . That value will be the fruit’s price.
  id: totrans-10699
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `for-in` 循环的大括号内，我们可以访问键（我们称之为 `fruit` ➋）以及通过 `fruitBasket[fruit]!` 强制解包其内容后的该键的值
    ➌。该值将是水果的价格。
- en: In this case, it’s safe to force-unwrap the value using an exclamation point
    because we know that the fruit key we’re using is definitely inside the dictionary.
  id: totrans-10700
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，使用感叹号强制解包值是安全的，因为我们知道我们使用的水果键肯定在字典中。
- en: Any code we put inside the for-in loop will run once for every key in our dictionary.
    So you should see the print statement display three times.
  id: totrans-10701
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在 `for-in` 循环中放入的任何代码都会针对字典中的每个键执行一次。所以你应该会看到打印语句显示三次。
- en: 'We can also loop through the dictionary using its values property:'
  id: totrans-10702
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以通过字典的 `values` 属性进行循环：
- en: '![Image](Image00150.jpg)'
  id: totrans-10703
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00150.jpg)'
- en: We use the same style of for-in loop, but now we use a constant to refer to
    each value, which we call price , in the values property. When looping through
    values, we don’t have access to the keys from inside the loop.
  id: totrans-10704
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用相同样式的 `for-in` 循环，但现在我们用一个常量来引用每个值，我们称其为 `price`，该常量来自 `values` 属性。在遍历值时，我们无法从循环内部访问键。
- en: Another difference to note is that price is not an optional because it’s accessed
    directly as a value in the fruitBasket dictionary. That means we don’t have to
    unwrap it. You should still see the print statement printed three times. [Figure
    6-6](text00016.html#ch06fig6) shows the output of both loops.
  id: totrans-10705
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个需要注意的区别是，`price` 不是可选的，因为它是直接作为 `fruitBasket` 字典中的值访问的。这意味着我们不需要解包它。你仍然应该看到打印语句打印三次。[图
    6-6](text00016.html#ch06fig6) 显示了两个循环的输出。
- en: '![Image](Image00151.jpg)'
  id: totrans-10706
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00151.jpg)'
- en: '*Figure 6-6: Looping through the keys and values of a dictionary with a for-in
    loop*'
  id: totrans-10707
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 6-6：使用 `for-in` 循环遍历字典的键和值*'
- en: The order of your results might be slightly different from ours. That’s because
    the items in a dictionary aren’t in a numbered order like they are in an array!
    And because the order is not guaranteed, you might see a different order printed
    if you run the same code again.
  id: totrans-10708
  prefs: []
  type: TYPE_NORMAL
  zh: 你的结果顺序可能与我们的略有不同。这是因为字典中的项不像数组中的项那样按编号排序！由于顺序不保证，如果你重新运行相同的代码，你可能会看到不同的顺序。
- en: '**WHAT YOU LEARNED**'
  id: totrans-10709
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**你学到了什么**'
- en: In this chapter, you learned how to store collections of items in an array and
    in a dictionary. To store items in an ordered list, you would use an array and
    look up each item by its index. If you wanted to store items by key instead, you
    would use a dictionary.
  id: totrans-10710
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你学习了如何将项目存储在数组和字典中。如果你希望按顺序存储项目，可以使用数组，并通过索引查找每个项目。如果你希望按键存储项目，则应使用字典。
- en: Knowing about arrays and dictionaries and how to use them is a powerful building
    block for almost any programming language. Next we will learn about functions,
    another very powerful tool. Functions are blocks of code that you create and name
    to perform a specific job. After you have written a function, you can use its
    name to call it from almost anywhere in your program.
  id: totrans-10711
  prefs: []
  type: TYPE_NORMAL
  zh: 了解数组和字典及其使用方式是几乎所有编程语言的一个强大构建块。接下来，我们将学习函数，这是另一个非常强大的工具。函数是你创建并命名的一段代码，用于执行特定任务。编写函数后，你可以通过其名称在程序的几乎任何地方调用它。
- en: '**REPLACING ITEMS IN A DICTIONARY**'
  id: totrans-10712
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**替换字典中的项目**'
- en: 'Replacing an item in a dictionary is also easy. It works the same was as replacing
    an item in an array. You just set the item that you want to replace to something
    else. Say you create a dictionary of fruit colors:'
  id: totrans-10713
  prefs: []
  type: TYPE_NORMAL
  zh: 替换字典中的项目也很简单。它的工作方式与替换数组中的项目相同。你只需将要替换的项目设置为其他值。假设你创建了一个水果颜色的字典：
- en: '![](Image00146.jpg)'
  id: totrans-10714
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00146.jpg)'
- en: At first we had the value "apple" for "red" , but then we decided that "raspberry"
    is a better fruit to use since sometimes apples are green or yellow. To replace
    "apple" with "raspberry" , we set colorFruits["red"] to its new value ➊ .
  id: totrans-10715
  prefs: []
  type: TYPE_NORMAL
  zh: 一开始我们为“red”设置了值“apple”，但是后来我们决定使用“raspberry”作为更好的水果，因为有时候苹果是绿色或黄色的。为了将“apple”替换为“raspberry”，我们将colorFruits["red"]设置为它的新值➊。
- en: You may remember that this is the same way we entered a new value into a dictionary.
    If the key already exists in the dictionary, then the value for that key is replaced.
    If the key doesn’t already exist, then the new key/value pair will be added to
    the dictionary.
  id: totrans-10716
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能还记得，这与我们向字典中输入新值的方法相同。如果字典中已经存在该键，则会替换该键的值。如果该键不存在，则会将新的键/值对添加到字典中。
- en: '![Image](Image00147.jpg)'
  id: totrans-10717
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00147.jpg)'
- en: '**USING DICTIONARY PROPERTIES**'
  id: totrans-10718
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**使用字典属性**'
- en: 'Like an array, a dictionary also has an isEmpty property and a count property.
    For example, the following code shows how you can use the isEmpty property to
    check if a dictionary is empty, and if it isn’t empty, the count property checks
    how many items you have. Imagine you have a basket of fruit for sale. You can
    use these properties to help you keep track of everything:'
  id: totrans-10719
  prefs: []
  type: TYPE_NORMAL
  zh: 类似于数组，字典也有isEmpty属性和count属性。例如，以下代码展示了如何使用isEmpty属性检查字典是否为空，如果不为空，count属性会检查字典中有多少项。假设你有一个水果篮出售。你可以使用这些属性帮助你跟踪所有物品：
- en: '![Image](Image00148.jpg)'
  id: totrans-10720
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00148.jpg)'
- en: 'A dictionary also has two special properties: keys , which contains all of
    the dictionary’s keys, and values , which contains all of its values. We’ll use
    these two properties when we loop through the dictionary.'
  id: totrans-10721
  prefs: []
  type: TYPE_NORMAL
  zh: 字典还具有两个特殊属性：keys，包含字典的所有键，以及values，包含所有的值。在我们遍历字典时，将使用这两个属性。
- en: Let’s write some code that loops through our fruit baskets and prints the price
    of each fruit.
  id: totrans-10722
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们编写一些代码，遍历我们的水果篮并打印每种水果的价格。
- en: '**LOOPING OVER A DICTIONARY**'
  id: totrans-10723
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**遍历字典**'
- en: 'You can loop through a dictionary using a for-in loop. Because each item has
    a key and a value, you can do this in two different ways. This is how to loop
    through a dictionary using its keys:'
  id: totrans-10724
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用for-in循环遍历字典。由于每个项目都有一个键和值，所以你可以用两种不同的方式来实现。以下是使用字典的键遍历字典的方法：
- en: '![Image](Image00149.jpg)'
  id: totrans-10725
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00149.jpg)'
- en: Here we use the dictionary’s keys property ➊ to loop through fruitBasket and
    print its contents. We start by writing the keyword for , followed by a constant
    name fruit for the dictionary key, the keyword in , the dictionary name, a period,
    and keys .
  id: totrans-10726
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们使用字典的keys属性➊来遍历fruitBasket并打印其内容。我们首先编写关键字for，然后是字典键的常量名称fruit，接着是关键字in，字典的名称，再加上一个点和keys。
- en: Inside the braces of our for-in loop, we have access to both the key, which
    we call fruit ➋ , and the value at that key when we force-unwrap its contents
    with fruitBasket[fruit]! ➌ . That value will be the fruit’s price.
  id: totrans-10727
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的for-in循环的花括号内，我们可以访问键，也就是我们称之为fruit➋的部分，以及通过强制解包其内容fruitBasket[fruit]!➌时该键的值。该值将是水果的价格。
- en: In this case, it’s safe to force-unwrap the value using an exclamation point
    because we know that the fruit key we’re using is definitely inside the dictionary.
  id: totrans-10728
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，使用感叹号强制解包值是安全的，因为我们知道所使用的水果键一定存在于字典中。
- en: Any code we put inside the for-in loop will run once for every key in our dictionary.
    So you should see the print statement display three times.
  id: totrans-10729
  prefs: []
  type: TYPE_NORMAL
  zh: 我们放入`for-in`循环中的任何代码都会针对字典中的每个键执行一次。所以你应该能看到打印语句会显示三次。
- en: 'We can also loop through the dictionary using its values property:'
  id: totrans-10730
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以通过字典的`values`属性遍历字典：
- en: '![Image](Image00150.jpg)'
  id: totrans-10731
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00150.jpg)'
- en: We use the same style of for-in loop, but now we use a constant to refer to
    each value, which we call price , in the values property. When looping through
    values, we don’t have access to the keys from inside the loop.
  id: totrans-10732
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用相同的`for-in`循环方式，但现在我们使用常量来引用每个值，我们称之为`price`，它位于`values`属性中。在遍历`values`时，我们无法从循环内部访问到键。
- en: Another difference to note is that price is not an optional because it’s accessed
    directly as a value in the fruitBasket dictionary. That means we don’t have to
    unwrap it. You should still see the print statement printed three times. [Figure
    6-6](text00016.html#ch06fig6) shows the output of both loops.
  id: totrans-10733
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个需要注意的区别是，`price`不是一个可选项，因为它是直接作为`fruitBasket`字典中的值访问的。这意味着我们不需要解包它。你仍然应该看到打印语句显示三次。[图
    6-6](text00016.html#ch06fig6)显示了两个循环的输出。
- en: '![Image](Image00151.jpg)'
  id: totrans-10734
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00151.jpg)'
- en: '*Figure 6-6: Looping through the keys and values of a dictionary with a for-in
    loop*'
  id: totrans-10735
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 6-6：使用`for-in`循环遍历字典的键和值*'
- en: The order of your results might be slightly different from ours. That’s because
    the items in a dictionary aren’t in a numbered order like they are in an array!
    And because the order is not guaranteed, you might see a different order printed
    if you run the same code again.
  id: totrans-10736
  prefs: []
  type: TYPE_NORMAL
  zh: 你的结果顺序可能与我们的稍有不同。那是因为字典中的项不像数组中的项那样按编号顺序排列！由于顺序不保证，如果你再次运行相同的代码，可能会看到不同的打印顺序。
- en: '**WHAT YOU LEARNED**'
  id: totrans-10737
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**你学到的内容**'
- en: In this chapter, you learned how to store collections of items in an array and
    in a dictionary. To store items in an ordered list, you would use an array and
    look up each item by its index. If you wanted to store items by key instead, you
    would use a dictionary.
  id: totrans-10738
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一章中，你学会了如何将项存储在数组和字典中。要将项存储在有序列表中，你会使用数组，并通过索引查找每个项。如果你想根据键存储项，则会使用字典。
- en: Knowing about arrays and dictionaries and how to use them is a powerful building
    block for almost any programming language. Next we will learn about functions,
    another very powerful tool. Functions are blocks of code that you create and name
    to perform a specific job. After you have written a function, you can use its
    name to call it from almost anywhere in your program.
  id: totrans-10739
  prefs: []
  type: TYPE_NORMAL
  zh: 了解数组和字典及其使用方法，是几乎所有编程语言中一个强大的构建模块。接下来我们将学习函数，另一个非常强大的工具。函数是你创建并命名的代码块，用于执行特定的任务。在你编写了一个函数之后，你可以通过它的名字在程序中的几乎任何地方调用它。
- en: 'Replacing an item in a dictionary is also easy. It works the same was as replacing
    an item in an array. You just set the item that you want to replace to something
    else. Say you create a dictionary of fruit colors:'
  id: totrans-10740
  prefs: []
  type: TYPE_NORMAL
  zh: 替换字典中的项也很简单。它的工作方式与替换数组中的项相同。你只需要将你想要替换的项设置为其他值。比如你创建了一个水果颜色的字典：
- en: '![](Image00146.jpg)'
  id: totrans-10741
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00146.jpg)'
- en: At first we had the value "apple" for "red" , but then we decided that "raspberry"
    is a better fruit to use since sometimes apples are green or yellow. To replace
    "apple" with "raspberry" , we set colorFruits["red"] to its new value ➊ .
  id: totrans-10742
  prefs: []
  type: TYPE_NORMAL
  zh: 最初我们为“红色”设置了“苹果”作为值，但后来我们决定“覆盆子”是一个更好的水果，因为有时苹果是绿色或黄色的。为了将“苹果”替换为“覆盆子”，我们将`colorFruits["red"]`设置为它的新值
    ➊ 。
- en: You may remember that this is the same way we entered a new value into a dictionary.
    If the key already exists in the dictionary, then the value for that key is replaced.
    If the key doesn’t already exist, then the new key/value pair will be added to
    the dictionary.
  id: totrans-10743
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能还记得，我们以相同的方式将新值添加到字典中。如果键已经存在于字典中，那么该键对应的值将被替换。如果该键不存在，则会将新的键/值对添加到字典中。
- en: '![Image](Image00147.jpg)'
  id: totrans-10744
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00147.jpg)'
- en: '**USING DICTIONARY PROPERTIES**'
  id: totrans-10745
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**使用字典属性**'
- en: 'Like an array, a dictionary also has an isEmpty property and a count property.
    For example, the following code shows how you can use the isEmpty property to
    check if a dictionary is empty, and if it isn’t empty, the count property checks
    how many items you have. Imagine you have a basket of fruit for sale. You can
    use these properties to help you keep track of everything:'
  id: totrans-10746
  prefs: []
  type: TYPE_NORMAL
  zh: 像数组一样，字典也有 isEmpty 属性和 count 属性。例如，以下代码展示了如何使用 isEmpty 属性检查字典是否为空，如果不为空，则 count
    属性会检查字典中的项数。假设你有一个水果篮子在出售。你可以使用这些属性帮助你跟踪所有内容：
- en: '![Image](Image00148.jpg)'
  id: totrans-10747
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00148.jpg)'
- en: 'A dictionary also has two special properties: keys , which contains all of
    the dictionary’s keys, and values , which contains all of its values. We’ll use
    these two properties when we loop through the dictionary.'
  id: totrans-10748
  prefs: []
  type: TYPE_NORMAL
  zh: 字典还有两个特殊的属性：keys，包含字典中的所有键；以及 values，包含字典中的所有值。我们将在遍历字典时使用这两个属性。
- en: Let’s write some code that loops through our fruit baskets and prints the price
    of each fruit.
  id: totrans-10749
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们写一些代码，遍历我们的水果篮并打印每种水果的价格。
- en: '**LOOPING OVER A DICTIONARY**'
  id: totrans-10750
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**遍历字典**'
- en: 'You can loop through a dictionary using a for-in loop. Because each item has
    a key and a value, you can do this in two different ways. This is how to loop
    through a dictionary using its keys:'
  id: totrans-10751
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用 for-in 循环遍历字典。因为每个项目都有一个键和值，所以你可以有两种不同的方式来进行循环。下面是如何使用键遍历字典：
- en: '![Image](Image00149.jpg)'
  id: totrans-10752
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00149.jpg)'
- en: Here we use the dictionary’s keys property ➊ to loop through fruitBasket and
    print its contents. We start by writing the keyword for , followed by a constant
    name fruit for the dictionary key, the keyword in , the dictionary name, a period,
    and keys .
  id: totrans-10753
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们使用字典的 keys 属性 ➊ 来遍历 fruitBasket 并打印其内容。我们从写下关键词 for 开始，接着是字典键的常量名 fruit，关键词
    in，字典名，句点，然后是 keys。
- en: Inside the braces of our for-in loop, we have access to both the key, which
    we call fruit ➋ , and the value at that key when we force-unwrap its contents
    with fruitBasket[fruit]! ➌ . That value will be the fruit’s price.
  id: totrans-10754
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们 for-in 循环的大括号内部，我们可以访问到键（我们称之为 fruit ➋）以及当我们通过 fruitBasket[fruit]! ➌ 强制解包时该键对应的值。该值将是水果的价格。
- en: In this case, it’s safe to force-unwrap the value using an exclamation point
    because we know that the fruit key we’re using is definitely inside the dictionary.
  id: totrans-10755
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，强制解包值时使用感叹号是安全的，因为我们知道我们使用的 fruit 键一定在字典中。
- en: Any code we put inside the for-in loop will run once for every key in our dictionary.
    So you should see the print statement display three times.
  id: totrans-10756
  prefs: []
  type: TYPE_NORMAL
  zh: 我们放入 for-in 循环中的任何代码都会针对字典中的每个键执行一次。所以你应该能看到打印语句执行三次。
- en: 'We can also loop through the dictionary using its values property:'
  id: totrans-10757
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以使用字典的 values 属性来进行循环：
- en: '![Image](Image00150.jpg)'
  id: totrans-10758
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00150.jpg)'
- en: We use the same style of for-in loop, but now we use a constant to refer to
    each value, which we call price , in the values property. When looping through
    values, we don’t have access to the keys from inside the loop.
  id: totrans-10759
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用相同样式的 for-in 循环，但现在我们使用一个常量来引用 values 属性中的每个值，我们称之为 price。在遍历值时，我们无法从循环内部访问键。
- en: Another difference to note is that price is not an optional because it’s accessed
    directly as a value in the fruitBasket dictionary. That means we don’t have to
    unwrap it. You should still see the print statement printed three times. [Figure
    6-6](text00016.html#ch06fig6) shows the output of both loops.
  id: totrans-10760
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个需要注意的区别是，price 不是一个可选值，因为它是直接作为 fruitBasket 字典中的值来访问的。这意味着我们不需要解包它。你应该仍然能看到打印语句执行三次。[图
    6-6](text00016.html#ch06fig6) 显示了两个循环的输出。
- en: '![Image](Image00151.jpg)'
  id: totrans-10761
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00151.jpg)'
- en: '*Figure 6-6: Looping through the keys and values of a dictionary with a for-in
    loop*'
  id: totrans-10762
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 6-6：使用 for-in 循环遍历字典的键和值*'
- en: The order of your results might be slightly different from ours. That’s because
    the items in a dictionary aren’t in a numbered order like they are in an array!
    And because the order is not guaranteed, you might see a different order printed
    if you run the same code again.
  id: totrans-10763
  prefs: []
  type: TYPE_NORMAL
  zh: 结果的顺序可能与你的有所不同。这是因为字典中的项目不像数组那样按编号顺序排列！由于顺序没有保证，如果你再次运行相同的代码，可能会看到不同的顺序。
- en: '**WHAT YOU LEARNED**'
  id: totrans-10764
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**你学到了什么**'
- en: In this chapter, you learned how to store collections of items in an array and
    in a dictionary. To store items in an ordered list, you would use an array and
    look up each item by its index. If you wanted to store items by key instead, you
    would use a dictionary.
  id: totrans-10765
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一章中，你学习了如何将项目集合存储在数组和字典中。为了将项目存储在一个有序的列表中，你会使用数组，并通过索引查找每个项目。如果你想按键存储项目，则可以使用字典。
- en: Knowing about arrays and dictionaries and how to use them is a powerful building
    block for almost any programming language. Next we will learn about functions,
    another very powerful tool. Functions are blocks of code that you create and name
    to perform a specific job. After you have written a function, you can use its
    name to call it from almost anywhere in your program.
  id: totrans-10766
  prefs: []
  type: TYPE_NORMAL
  zh: 了解数组和字典以及如何使用它们，是几乎所有编程语言中的一个强大构建块。接下来我们将学习函数，另一个非常强大的工具。函数是你创建并命名的一段代码，用来执行特定的任务。写完一个函数后，你可以通过它的名称从程序中的几乎任何地方调用它。
- en: '![](Image00146.jpg)'
  id: totrans-10767
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00146.jpg)'
- en: At first we had the value "apple" for "red" , but then we decided that "raspberry"
    is a better fruit to use since sometimes apples are green or yellow. To replace
    "apple" with "raspberry" , we set colorFruits["red"] to its new value ➊ .
  id: totrans-10768
  prefs: []
  type: TYPE_NORMAL
  zh: 一开始我们为“red”设置了值“apple”，但后来我们决定使用“raspberry”作为更好的水果，因为有时候苹果是绿色或黄色的。为了将“apple”替换成“raspberry”，我们将
    colorFruits["red"] 设置为它的新值 ➊。
- en: You may remember that this is the same way we entered a new value into a dictionary.
    If the key already exists in the dictionary, then the value for that key is replaced.
    If the key doesn’t already exist, then the new key/value pair will be added to
    the dictionary.
  id: totrans-10769
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能还记得，这和我们将新值输入字典的方式是一样的。如果键已经存在于字典中，那么该键的值会被替换。如果键不存在，则新的键/值对会被添加到字典中。
- en: '![Image](Image00147.jpg)'
  id: totrans-10770
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Image00147.jpg)'
- en: '**USING DICTIONARY PROPERTIES**'
  id: totrans-10771
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**使用字典属性**'
- en: 'Like an array, a dictionary also has an isEmpty property and a count property.
    For example, the following code shows how you can use the isEmpty property to
    check if a dictionary is empty, and if it isn’t empty, the count property checks
    how many items you have. Imagine you have a basket of fruit for sale. You can
    use these properties to help you keep track of everything:'
  id: totrans-10772
  prefs: []
  type: TYPE_NORMAL
  zh: 和数组一样，字典也有 isEmpty 属性和 count 属性。例如，下面的代码展示了如何使用 isEmpty 属性检查字典是否为空，如果不为空，则 count
    属性会检查你有多少个项目。假设你有一个待售的水果篮。你可以使用这些属性来帮助你跟踪所有物品：
- en: '![Image](Image00148.jpg)'
  id: totrans-10773
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Image00148.jpg)'
- en: 'A dictionary also has two special properties: keys , which contains all of
    the dictionary’s keys, and values , which contains all of its values. We’ll use
    these two properties when we loop through the dictionary.'
  id: totrans-10774
  prefs: []
  type: TYPE_NORMAL
  zh: 字典还有两个特殊的属性：keys，包含字典的所有键，以及 values，包含所有值。在遍历字典时，我们将使用这两个属性。
- en: Let’s write some code that loops through our fruit baskets and prints the price
    of each fruit.
  id: totrans-10775
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们写些代码，遍历我们的水果篮并打印每种水果的价格。
- en: '**LOOPING OVER A DICTIONARY**'
  id: totrans-10776
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**遍历字典**'
- en: 'You can loop through a dictionary using a for-in loop. Because each item has
    a key and a value, you can do this in two different ways. This is how to loop
    through a dictionary using its keys:'
  id: totrans-10777
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用 for-in 循环遍历字典。由于每个项目都有一个键和值，因此你可以通过两种不同的方式来进行遍历。这是使用字典的键来遍历字典的方式：
- en: '![Image](Image00149.jpg)'
  id: totrans-10778
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Image00149.jpg)'
- en: Here we use the dictionary’s keys property ➊ to loop through fruitBasket and
    print its contents. We start by writing the keyword for , followed by a constant
    name fruit for the dictionary key, the keyword in , the dictionary name, a period,
    and keys .
  id: totrans-10779
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们使用字典的 keys 属性 ➊ 来遍历 fruitBasket 并打印其内容。我们首先写关键字 for，然后是常量名称 fruit（表示字典的键），接着是关键字
    in，字典的名称，再加一个点，最后是 keys。
- en: Inside the braces of our for-in loop, we have access to both the key, which
    we call fruit ➋ , and the value at that key when we force-unwrap its contents
    with fruitBasket[fruit]! ➌ . That value will be the fruit’s price.
  id: totrans-10780
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们 for-in 循环的大括号内，我们可以访问到键（我们称之为 fruit ➋）和该键对应的值，通过强制解包它的内容 fruitBasket[fruit]!
    ➌。那个值将是水果的价格。
- en: In this case, it’s safe to force-unwrap the value using an exclamation point
    because we know that the fruit key we’re using is definitely inside the dictionary.
  id: totrans-10781
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，使用感叹号强制解包值是安全的，因为我们知道我们使用的水果键肯定存在于字典中。
- en: Any code we put inside the for-in loop will run once for every key in our dictionary.
    So you should see the print statement display three times.
  id: totrans-10782
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在 for-in 循环中写的任何代码都会针对字典中的每个键执行一次。因此，你应该能看到打印语句显示三次。
- en: 'We can also loop through the dictionary using its values property:'
  id: totrans-10783
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以使用字典的values属性遍历字典：
- en: '![Image](Image00150.jpg)'
  id: totrans-10784
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00150.jpg)'
- en: We use the same style of for-in loop, but now we use a constant to refer to
    each value, which we call price , in the values property. When looping through
    values, we don’t have access to the keys from inside the loop.
  id: totrans-10785
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用相同风格的for-in循环，但现在我们使用一个常量来引用values属性中的每个值，我们称之为price。在循环中遍历值时，我们无法从循环内部访问键。
- en: Another difference to note is that price is not an optional because it’s accessed
    directly as a value in the fruitBasket dictionary. That means we don’t have to
    unwrap it. You should still see the print statement printed three times. [Figure
    6-6](text00016.html#ch06fig6) shows the output of both loops.
  id: totrans-10786
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个需要注意的区别是，price不是可选的，因为它是直接作为fruitBasket字典中的值来访问的。这意味着我们不需要解包它。你仍然应该看到打印语句打印三次。[图6-6](text00016.html#ch06fig6)展示了两个循环的输出。
- en: '![Image](Image00151.jpg)'
  id: totrans-10787
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00151.jpg)'
- en: '*Figure 6-6: Looping through the keys and values of a dictionary with a for-in
    loop*'
  id: totrans-10788
  prefs: []
  type: TYPE_NORMAL
  zh: '*图6-6：使用for-in循环遍历字典的键和值*'
- en: The order of your results might be slightly different from ours. That’s because
    the items in a dictionary aren’t in a numbered order like they are in an array!
    And because the order is not guaranteed, you might see a different order printed
    if you run the same code again.
  id: totrans-10789
  prefs: []
  type: TYPE_NORMAL
  zh: 你的结果顺序可能与你的不同。那是因为字典中的项目不像数组那样按数字顺序排列！由于顺序没有保证，如果你再次运行相同的代码，可能会看到不同的顺序。
- en: '**WHAT YOU LEARNED**'
  id: totrans-10790
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**你学到了什么**'
- en: In this chapter, you learned how to store collections of items in an array and
    in a dictionary. To store items in an ordered list, you would use an array and
    look up each item by its index. If you wanted to store items by key instead, you
    would use a dictionary.
  id: totrans-10791
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你学习了如何将项目存储在数组和字典中。要将项目存储在有序列表中，你应该使用数组，并通过索引查找每个项目。如果你想按键存储项目，你应该使用字典。
- en: Knowing about arrays and dictionaries and how to use them is a powerful building
    block for almost any programming language. Next we will learn about functions,
    another very powerful tool. Functions are blocks of code that you create and name
    to perform a specific job. After you have written a function, you can use its
    name to call it from almost anywhere in your program.
  id: totrans-10792
  prefs: []
  type: TYPE_NORMAL
  zh: 了解数组和字典及其使用方法是几乎所有编程语言中的一个强大构建块。接下来，我们将学习函数，这是另一个非常强大的工具。函数是你创建并命名的代码块，用来执行特定的任务。编写了函数后，你可以通过其名称在程序中的几乎任何地方调用它。
- en: At first we had the value "apple" for "red" , but then we decided that "raspberry"
    is a better fruit to use since sometimes apples are green or yellow. To replace
    "apple" with "raspberry" , we set colorFruits["red"] to its new value ➊ .
  id: totrans-10793
  prefs: []
  type: TYPE_NORMAL
  zh: 最初我们为“red”赋值为“apple”，但后来我们决定使用“raspberry”作为更合适的水果，因为有时苹果是绿色或黄色的。为了将“apple”替换为“raspberry”，我们将colorFruits["red"]设置为其新值➊。
- en: You may remember that this is the same way we entered a new value into a dictionary.
    If the key already exists in the dictionary, then the value for that key is replaced.
    If the key doesn’t already exist, then the new key/value pair will be added to
    the dictionary.
  id: totrans-10794
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能记得这与我们如何将新值输入字典的方式相同。如果字典中已经存在该键，那么该键的值会被替换。如果该键不存在，则会将新的键/值对添加到字典中。
- en: '![Image](Image00147.jpg)'
  id: totrans-10795
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00147.jpg)'
- en: '**USING DICTIONARY PROPERTIES**'
  id: totrans-10796
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**使用字典属性**'
- en: 'Like an array, a dictionary also has an isEmpty property and a count property.
    For example, the following code shows how you can use the isEmpty property to
    check if a dictionary is empty, and if it isn’t empty, the count property checks
    how many items you have. Imagine you have a basket of fruit for sale. You can
    use these properties to help you keep track of everything:'
  id: totrans-10797
  prefs: []
  type: TYPE_NORMAL
  zh: 与数组类似，字典也有isEmpty属性和count属性。例如，下面的代码展示了如何使用isEmpty属性检查字典是否为空，如果不为空，count属性会检查你有多少个项目。假设你有一个待售的水果篮子，你可以使用这些属性来帮助你跟踪所有内容：
- en: '![Image](Image00148.jpg)'
  id: totrans-10798
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00148.jpg)'
- en: 'A dictionary also has two special properties: keys , which contains all of
    the dictionary’s keys, and values , which contains all of its values. We’ll use
    these two properties when we loop through the dictionary.'
  id: totrans-10799
  prefs: []
  type: TYPE_NORMAL
  zh: 字典还有两个特殊属性：keys，它包含字典的所有键；values，它包含字典的所有值。在遍历字典时，我们将使用这两个属性。
- en: Let’s write some code that loops through our fruit baskets and prints the price
    of each fruit.
  id: totrans-10800
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们写一些代码，遍历我们的水果篮子并打印每个水果的价格。
- en: '**LOOPING OVER A DICTIONARY**'
  id: totrans-10801
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**遍历字典**'
- en: 'You can loop through a dictionary using a for-in loop. Because each item has
    a key and a value, you can do this in two different ways. This is how to loop
    through a dictionary using its keys:'
  id: totrans-10802
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用for-in循环遍历字典。由于每个项都有一个键和值，你可以用两种不同的方式进行遍历。这是使用字典的键遍历字典的方法：
- en: '![Image](Image00149.jpg)'
  id: totrans-10803
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00149.jpg)'
- en: Here we use the dictionary’s keys property ➊ to loop through fruitBasket and
    print its contents. We start by writing the keyword for , followed by a constant
    name fruit for the dictionary key, the keyword in , the dictionary name, a period,
    and keys .
  id: totrans-10804
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们使用字典的keys属性 ➊ 来遍历fruitBasket并打印其内容。我们首先写出关键字for，接着是字典键的常量名fruit，然后是关键字in，字典的名称，一个句点和keys。
- en: Inside the braces of our for-in loop, we have access to both the key, which
    we call fruit ➋ , and the value at that key when we force-unwrap its contents
    with fruitBasket[fruit]! ➌ . That value will be the fruit’s price.
  id: totrans-10805
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们for-in循环的花括号内，我们可以访问到键（我们称之为fruit ➋），以及当我们使用fruitBasket[fruit]! ➌ 强制解包其内容时，该键的值。这个值就是水果的价格。
- en: In this case, it’s safe to force-unwrap the value using an exclamation point
    because we know that the fruit key we’re using is definitely inside the dictionary.
  id: totrans-10806
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，使用感叹号强制解包值是安全的，因为我们知道所使用的fruit键一定在字典中。
- en: Any code we put inside the for-in loop will run once for every key in our dictionary.
    So you should see the print statement display three times.
  id: totrans-10807
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在for-in循环内放入的任何代码都会对字典中的每个键执行一次。所以你应该能看到print语句打印三次。
- en: 'We can also loop through the dictionary using its values property:'
  id: totrans-10808
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以通过字典的values属性遍历字典：
- en: '![Image](Image00150.jpg)'
  id: totrans-10809
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00150.jpg)'
- en: We use the same style of for-in loop, but now we use a constant to refer to
    each value, which we call price , in the values property. When looping through
    values, we don’t have access to the keys from inside the loop.
  id: totrans-10810
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用相同样式的for-in循环，但现在我们用常量来表示values属性中的每个值，称其为price。遍历values时，我们无法在循环内部访问到键。
- en: Another difference to note is that price is not an optional because it’s accessed
    directly as a value in the fruitBasket dictionary. That means we don’t have to
    unwrap it. You should still see the print statement printed three times. [Figure
    6-6](text00016.html#ch06fig6) shows the output of both loops.
  id: totrans-10811
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个需要注意的区别是，price不是一个可选类型，因为它直接作为fruitBasket字典中的一个值来访问。这意味着我们不需要对它进行解包。你应该仍然能看到print语句打印三次。[图6-6](text00016.html#ch06fig6)展示了两个循环的输出结果。
- en: '![Image](Image00151.jpg)'
  id: totrans-10812
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00151.jpg)'
- en: '*Figure 6-6: Looping through the keys and values of a dictionary with a for-in
    loop*'
  id: totrans-10813
  prefs: []
  type: TYPE_NORMAL
  zh: '*图6-6：使用for-in循环遍历字典的键和值*'
- en: The order of your results might be slightly different from ours. That’s because
    the items in a dictionary aren’t in a numbered order like they are in an array!
    And because the order is not guaranteed, you might see a different order printed
    if you run the same code again.
  id: totrans-10814
  prefs: []
  type: TYPE_NORMAL
  zh: 你的结果顺序可能与我们的稍有不同。这是因为字典中的项不像数组那样是按编号顺序排列的！由于顺序并不保证，你可能会看到不同的顺序，尤其是如果你再次运行相同的代码时。
- en: '**WHAT YOU LEARNED**'
  id: totrans-10815
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**你学到的内容**'
- en: In this chapter, you learned how to store collections of items in an array and
    in a dictionary. To store items in an ordered list, you would use an array and
    look up each item by its index. If you wanted to store items by key instead, you
    would use a dictionary.
  id: totrans-10816
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你学习了如何将项目存储在数组和字典中。要将项目存储在有序列表中，你会使用数组，并通过索引查找每个项目。如果你想通过键来存储项目，你则需要使用字典。
- en: Knowing about arrays and dictionaries and how to use them is a powerful building
    block for almost any programming language. Next we will learn about functions,
    another very powerful tool. Functions are blocks of code that you create and name
    to perform a specific job. After you have written a function, you can use its
    name to call it from almost anywhere in your program.
  id: totrans-10817
  prefs: []
  type: TYPE_NORMAL
  zh: 了解数组和字典以及如何使用它们是几乎所有编程语言的强大构建块。接下来我们将学习函数，另一个非常强大的工具。函数是你创建并命名的一段代码，用于执行特定的任务。写完一个函数后，你可以通过其名称在程序中的几乎任何地方调用它。
- en: You may remember that this is the same way we entered a new value into a dictionary.
    If the key already exists in the dictionary, then the value for that key is replaced.
    If the key doesn’t already exist, then the new key/value pair will be added to
    the dictionary.
  id: totrans-10818
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能记得，这和我们向字典中插入新值的方式是一样的。如果键已经存在于字典中，那么该键的值会被替换。如果键不存在，那么新的键/值对将会被添加到字典中。
- en: '![Image](Image00147.jpg)'
  id: totrans-10819
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00147.jpg)'
- en: '**USING DICTIONARY PROPERTIES**'
  id: totrans-10820
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**使用字典属性**'
- en: 'Like an array, a dictionary also has an isEmpty property and a count property.
    For example, the following code shows how you can use the isEmpty property to
    check if a dictionary is empty, and if it isn’t empty, the count property checks
    how many items you have. Imagine you have a basket of fruit for sale. You can
    use these properties to help you keep track of everything:'
  id: totrans-10821
  prefs: []
  type: TYPE_NORMAL
  zh: 和数组一样，字典也有 isEmpty 属性和 count 属性。例如，以下代码展示了如何使用 isEmpty 属性检查字典是否为空，如果字典不为空，count
    属性则检查字典中有多少项。想象你有一个待售的水果篮。你可以使用这些属性帮助你跟踪所有内容：
- en: '![Image](Image00148.jpg)'
  id: totrans-10822
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00148.jpg)'
- en: 'A dictionary also has two special properties: keys , which contains all of
    the dictionary’s keys, and values , which contains all of its values. We’ll use
    these two properties when we loop through the dictionary.'
  id: totrans-10823
  prefs: []
  type: TYPE_NORMAL
  zh: 字典还有两个特殊属性：keys，包含字典的所有键；values，包含字典的所有值。我们将在遍历字典时使用这两个属性。
- en: Let’s write some code that loops through our fruit baskets and prints the price
    of each fruit.
  id: totrans-10824
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们写一些代码，遍历我们的水果篮并打印每个水果的价格。
- en: '**LOOPING OVER A DICTIONARY**'
  id: totrans-10825
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**遍历字典**'
- en: 'You can loop through a dictionary using a for-in loop. Because each item has
    a key and a value, you can do this in two different ways. This is how to loop
    through a dictionary using its keys:'
  id: totrans-10826
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用 for-in 循环遍历字典。由于每个项都有一个键和一个值，你可以通过两种方式来实现遍历。以下是使用键遍历字典的方法：
- en: '![Image](Image00149.jpg)'
  id: totrans-10827
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00149.jpg)'
- en: Here we use the dictionary’s keys property ➊ to loop through fruitBasket and
    print its contents. We start by writing the keyword for , followed by a constant
    name fruit for the dictionary key, the keyword in , the dictionary name, a period,
    and keys .
  id: totrans-10828
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们使用字典的 keys 属性 ➊ 来遍历 fruitBasket 并打印其内容。我们首先编写关键字 for，然后是常量名 fruit 来表示字典的键，接着是关键字
    in，字典名，一个点，最后是 keys。
- en: Inside the braces of our for-in loop, we have access to both the key, which
    we call fruit ➋ , and the value at that key when we force-unwrap its contents
    with fruitBasket[fruit]! ➌ . That value will be the fruit’s price.
  id: totrans-10829
  prefs: []
  type: TYPE_NORMAL
  zh: 在 for-in 循环的花括号内部，我们可以访问键，我们称之为 fruit ➋，以及该键的值，当我们使用 fruitBasket[fruit]! 强制展开其内容时
    ➌。该值将是水果的价格。
- en: In this case, it’s safe to force-unwrap the value using an exclamation point
    because we know that the fruit key we’re using is definitely inside the dictionary.
  id: totrans-10830
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，强制展开值时使用感叹号是安全的，因为我们知道我们使用的水果键肯定在字典中。
- en: Any code we put inside the for-in loop will run once for every key in our dictionary.
    So you should see the print statement display three times.
  id: totrans-10831
  prefs: []
  type: TYPE_NORMAL
  zh: 我们放在 for-in 循环中的任何代码都会对字典中的每个键执行一次。所以你应该能看到打印语句显示三次。
- en: 'We can also loop through the dictionary using its values property:'
  id: totrans-10832
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以通过字典的 values 属性来遍历字典：
- en: '![Image](Image00150.jpg)'
  id: totrans-10833
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00150.jpg)'
- en: We use the same style of for-in loop, but now we use a constant to refer to
    each value, which we call price , in the values property. When looping through
    values, we don’t have access to the keys from inside the loop.
  id: totrans-10834
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用相同样式的 for-in 循环，但这次我们用常量引用 values 属性中的每个值，我们称之为 price。当遍历值时，我们无法从循环内部访问键。
- en: Another difference to note is that price is not an optional because it’s accessed
    directly as a value in the fruitBasket dictionary. That means we don’t have to
    unwrap it. You should still see the print statement printed three times. [Figure
    6-6](text00016.html#ch06fig6) shows the output of both loops.
  id: totrans-10835
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个需要注意的区别是 price 不是可选类型，因为它是直接作为字典值来访问的。这意味着我们不需要解包它。你仍然应该能看到打印语句打印三次。[图6-6](text00016.html#ch06fig6)
    显示了两个循环的输出。
- en: '![Image](Image00151.jpg)'
  id: totrans-10836
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00151.jpg)'
- en: '*Figure 6-6: Looping through the keys and values of a dictionary with a for-in
    loop*'
  id: totrans-10837
  prefs: []
  type: TYPE_NORMAL
  zh: '*图6-6：通过 for-in 循环遍历字典的键和值*'
- en: The order of your results might be slightly different from ours. That’s because
    the items in a dictionary aren’t in a numbered order like they are in an array!
    And because the order is not guaranteed, you might see a different order printed
    if you run the same code again.
  id: totrans-10838
  prefs: []
  type: TYPE_NORMAL
  zh: 你的结果顺序可能与我们的略有不同。这是因为字典中的项不像数组中的项那样有编号顺序！由于顺序无法保证，如果你再次运行相同的代码，可能会看到不同的打印顺序。
- en: '**WHAT YOU LEARNED**'
  id: totrans-10839
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**你学到了什么**'
- en: In this chapter, you learned how to store collections of items in an array and
    in a dictionary. To store items in an ordered list, you would use an array and
    look up each item by its index. If you wanted to store items by key instead, you
    would use a dictionary.
  id: totrans-10840
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你学会了如何将项目存储在数组和字典中。要将项目存储在有序列表中，你可以使用数组，并通过索引查找每个项目。如果你想通过键来存储项目，则应该使用字典。
- en: Knowing about arrays and dictionaries and how to use them is a powerful building
    block for almost any programming language. Next we will learn about functions,
    another very powerful tool. Functions are blocks of code that you create and name
    to perform a specific job. After you have written a function, you can use its
    name to call it from almost anywhere in your program.
  id: totrans-10841
  prefs: []
  type: TYPE_NORMAL
  zh: 了解数组和字典以及如何使用它们是几乎所有编程语言中的一个强大构建块。接下来，我们将学习函数，这是另一个非常强大的工具。函数是你创建并命名的代码块，用于执行特定的任务。写完函数后，你可以通过其名称在程序中的几乎任何地方调用它。
- en: '![Image](Image00147.jpg)'
  id: totrans-10842
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00147.jpg)'
- en: '**USING DICTIONARY PROPERTIES**'
  id: totrans-10843
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**使用字典属性**'
- en: 'Like an array, a dictionary also has an isEmpty property and a count property.
    For example, the following code shows how you can use the isEmpty property to
    check if a dictionary is empty, and if it isn’t empty, the count property checks
    how many items you have. Imagine you have a basket of fruit for sale. You can
    use these properties to help you keep track of everything:'
  id: totrans-10844
  prefs: []
  type: TYPE_NORMAL
  zh: 就像数组一样，字典也有一个 isEmpty 属性和一个 count 属性。例如，以下代码展示了如何使用 isEmpty 属性检查字典是否为空，如果不为空，则使用
    count 属性检查字典中有多少项。假设你有一个待售的水果篮子。你可以使用这些属性来帮助你追踪一切：
- en: '![Image](Image00148.jpg)'
  id: totrans-10845
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00148.jpg)'
- en: 'A dictionary also has two special properties: keys , which contains all of
    the dictionary’s keys, and values , which contains all of its values. We’ll use
    these two properties when we loop through the dictionary.'
  id: totrans-10846
  prefs: []
  type: TYPE_NORMAL
  zh: 字典还有两个特殊属性：keys，它包含所有字典的键；以及 values，它包含所有的值。我们将在循环遍历字典时使用这两个属性。
- en: Let’s write some code that loops through our fruit baskets and prints the price
    of each fruit.
  id: totrans-10847
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们写一些代码，通过循环遍历我们的水果篮子并打印每个水果的价格。
- en: '**LOOPING OVER A DICTIONARY**'
  id: totrans-10848
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**遍历字典**'
- en: 'You can loop through a dictionary using a for-in loop. Because each item has
    a key and a value, you can do this in two different ways. This is how to loop
    through a dictionary using its keys:'
  id: totrans-10849
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用 for-in 循环遍历字典。因为每个项目都有一个键和值，所以你可以通过两种不同的方式进行循环。这是通过字典的键来循环的方式：
- en: '![Image](Image00149.jpg)'
  id: totrans-10850
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00149.jpg)'
- en: Here we use the dictionary’s keys property ➊ to loop through fruitBasket and
    print its contents. We start by writing the keyword for , followed by a constant
    name fruit for the dictionary key, the keyword in , the dictionary name, a period,
    and keys .
  id: totrans-10851
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们使用字典的 keys 属性 ➊ 来遍历 fruitBasket 并打印其内容。我们首先写下关键字 for，然后是一个常量名称 fruit 作为字典的键，再是关键字
    in、字典名称、一个点符号，最后是 keys。
- en: Inside the braces of our for-in loop, we have access to both the key, which
    we call fruit ➋ , and the value at that key when we force-unwrap its contents
    with fruitBasket[fruit]! ➌ . That value will be the fruit’s price.
  id: totrans-10852
  prefs: []
  type: TYPE_NORMAL
  zh: 在 for-in 循环的花括号内，我们可以访问键（我们称之为 fruit ➋），以及通过强制解包其内容的 fruitBasket[fruit]! ➌ 获得该键对应的值。这个值将是水果的价格。
- en: In this case, it’s safe to force-unwrap the value using an exclamation point
    because we know that the fruit key we’re using is definitely inside the dictionary.
  id: totrans-10853
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，使用感叹号强制解包值是安全的，因为我们知道我们使用的水果键肯定存在于字典中。
- en: Any code we put inside the for-in loop will run once for every key in our dictionary.
    So you should see the print statement display three times.
  id: totrans-10854
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在 for-in 循环中放入的任何代码都会在字典中的每个键上执行一次。因此，你应该看到打印语句显示三次。
- en: 'We can also loop through the dictionary using its values property:'
  id: totrans-10855
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以通过字典的 values 属性进行循环：
- en: '![Image](Image00150.jpg)'
  id: totrans-10856
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00150.jpg)'
- en: We use the same style of for-in loop, but now we use a constant to refer to
    each value, which we call price , in the values property. When looping through
    values, we don’t have access to the keys from inside the loop.
  id: totrans-10857
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用相同的 for-in 循环样式，但现在我们使用常量来引用 values 属性中的每个值，我们将其命名为 price。在循环遍历值时，我们无法在循环内访问键。
- en: Another difference to note is that price is not an optional because it’s accessed
    directly as a value in the fruitBasket dictionary. That means we don’t have to
    unwrap it. You should still see the print statement printed three times. [Figure
    6-6](text00016.html#ch06fig6) shows the output of both loops.
  id: totrans-10858
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个需要注意的区别是价格不是一个可选项，因为它是作为水果篮字典中的值直接访问的。这意味着我们不需要解包它。你应该仍然看到打印语句被打印三次。[图 6-6](text00016.html#ch06fig6)
    显示了两个循环的输出。
- en: '![Image](Image00151.jpg)'
  id: totrans-10859
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00151.jpg)'
- en: '*Figure 6-6: Looping through the keys and values of a dictionary with a for-in
    loop*'
  id: totrans-10860
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 6-6：使用for-in循环遍历字典的键和值*'
- en: The order of your results might be slightly different from ours. That’s because
    the items in a dictionary aren’t in a numbered order like they are in an array!
    And because the order is not guaranteed, you might see a different order printed
    if you run the same code again.
  id: totrans-10861
  prefs: []
  type: TYPE_NORMAL
  zh: 你得到的结果顺序可能与我们的略有不同。这是因为字典中的项不像数组那样是按编号顺序排列的！由于顺序无法保证，如果你再次运行相同的代码，可能会看到不同的顺序打印出来。
- en: '**WHAT YOU LEARNED**'
  id: totrans-10862
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**你学到了什么**'
- en: In this chapter, you learned how to store collections of items in an array and
    in a dictionary. To store items in an ordered list, you would use an array and
    look up each item by its index. If you wanted to store items by key instead, you
    would use a dictionary.
  id: totrans-10863
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你学习了如何在数组和字典中存储项目。要存储有序列表中的项目，你可以使用数组并通过索引查找每个项目。如果你想通过键来存储项目，则可以使用字典。
- en: Knowing about arrays and dictionaries and how to use them is a powerful building
    block for almost any programming language. Next we will learn about functions,
    another very powerful tool. Functions are blocks of code that you create and name
    to perform a specific job. After you have written a function, you can use its
    name to call it from almost anywhere in your program.
  id: totrans-10864
  prefs: []
  type: TYPE_NORMAL
  zh: 了解数组和字典及其使用方式是几乎任何编程语言中一个强大的基础模块。接下来我们将学习函数，这是另一个非常强大的工具。函数是你创建并命名的一段代码，用于执行特定任务。编写完函数后，你可以通过它的名称在程序中的几乎任何地方调用它。
- en: '**USING DICTIONARY PROPERTIES**'
  id: totrans-10865
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**使用字典属性**'
- en: 'Like an array, a dictionary also has an isEmpty property and a count property.
    For example, the following code shows how you can use the isEmpty property to
    check if a dictionary is empty, and if it isn’t empty, the count property checks
    how many items you have. Imagine you have a basket of fruit for sale. You can
    use these properties to help you keep track of everything:'
  id: totrans-10866
  prefs: []
  type: TYPE_NORMAL
  zh: 和数组一样，字典也有isEmpty属性和count属性。例如，以下代码展示了如何使用isEmpty属性检查字典是否为空，如果不为空，count属性会检查你有多少个项目。假设你有一个水果篮子出售。你可以使用这些属性帮助你跟踪一切：
- en: '![Image](Image00148.jpg)'
  id: totrans-10867
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00148.jpg)'
- en: 'A dictionary also has two special properties: keys , which contains all of
    the dictionary’s keys, and values , which contains all of its values. We’ll use
    these two properties when we loop through the dictionary.'
  id: totrans-10868
  prefs: []
  type: TYPE_NORMAL
  zh: 字典还具有两个特殊属性：keys，包含字典中所有的键，和values，包含所有的值。我们将在遍历字典时使用这两个属性。
- en: Let’s write some code that loops through our fruit baskets and prints the price
    of each fruit.
  id: totrans-10869
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们编写一些代码，遍历我们的水果篮并打印每种水果的价格。
- en: '**LOOPING OVER A DICTIONARY**'
  id: totrans-10870
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**遍历字典**'
- en: 'You can loop through a dictionary using a for-in loop. Because each item has
    a key and a value, you can do this in two different ways. This is how to loop
    through a dictionary using its keys:'
  id: totrans-10871
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用for-in循环遍历字典。因为每个项目都有一个键和值，你可以通过两种不同的方式来实现这一点。以下是如何使用字典的键来遍历字典：
- en: '![Image](Image00149.jpg)'
  id: totrans-10872
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00149.jpg)'
- en: Here we use the dictionary’s keys property ➊ to loop through fruitBasket and
    print its contents. We start by writing the keyword for , followed by a constant
    name fruit for the dictionary key, the keyword in , the dictionary name, a period,
    and keys .
  id: totrans-10873
  prefs: []
  type: TYPE_NORMAL
  zh: 这里我们使用字典的keys属性 ➊ 来遍历fruitBasket并打印它的内容。我们首先写下关键字for，后跟字典键的常量名称fruit，然后是关键字in，字典名称，一个点，最后是keys。
- en: Inside the braces of our for-in loop, we have access to both the key, which
    we call fruit ➋ , and the value at that key when we force-unwrap its contents
    with fruitBasket[fruit]! ➌ . That value will be the fruit’s price.
  id: totrans-10874
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的for-in循环的大括号内，我们可以访问键（我们称之为fruit ➋）以及通过强制解包fruitBasket[fruit]! ➌ 获取该键的值。这个值将是水果的价格。
- en: In this case, it’s safe to force-unwrap the value using an exclamation point
    because we know that the fruit key we’re using is definitely inside the dictionary.
  id: totrans-10875
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，使用感叹号强制解包值是安全的，因为我们知道正在使用的fruit键肯定在字典中。
- en: Any code we put inside the for-in loop will run once for every key in our dictionary.
    So you should see the print statement display three times.
  id: totrans-10876
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在 for-in 循环中放入的任何代码都会为字典中的每一个键执行一次。所以你应该看到打印语句会执行三次。
- en: 'We can also loop through the dictionary using its values property:'
  id: totrans-10877
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以通过字典的 values 属性遍历字典：
- en: '![Image](Image00150.jpg)'
  id: totrans-10878
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00150.jpg)'
- en: We use the same style of for-in loop, but now we use a constant to refer to
    each value, which we call price , in the values property. When looping through
    values, we don’t have access to the keys from inside the loop.
  id: totrans-10879
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用相同类型的 for-in 循环，但现在我们用常量来引用每个值，我们称其为 price，位于 values 属性中。遍历值时，我们无法在循环内部访问键。
- en: Another difference to note is that price is not an optional because it’s accessed
    directly as a value in the fruitBasket dictionary. That means we don’t have to
    unwrap it. You should still see the print statement printed three times. [Figure
    6-6](text00016.html#ch06fig6) shows the output of both loops.
  id: totrans-10880
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个需要注意的区别是，price 不是可选的，因为它是直接作为值访问的，位于 fruitBasket 字典中。这意味着我们不需要解包它。你仍然会看到打印语句执行三次。[图
    6-6](text00016.html#ch06fig6) 显示了两种循环的输出结果。
- en: '![Image](Image00151.jpg)'
  id: totrans-10881
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00151.jpg)'
- en: '*Figure 6-6: Looping through the keys and values of a dictionary with a for-in
    loop*'
  id: totrans-10882
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 6-6：使用 for-in 循环遍历字典的键和值*'
- en: The order of your results might be slightly different from ours. That’s because
    the items in a dictionary aren’t in a numbered order like they are in an array!
    And because the order is not guaranteed, you might see a different order printed
    if you run the same code again.
  id: totrans-10883
  prefs: []
  type: TYPE_NORMAL
  zh: 你的结果顺序可能与我们的稍有不同。这是因为字典中的项不像数组中的项那样按数字顺序排列！由于顺序无法保证，如果你重新运行相同的代码，可能会看到不同的打印顺序。
- en: '**WHAT YOU LEARNED**'
  id: totrans-10884
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**你学到了什么**'
- en: In this chapter, you learned how to store collections of items in an array and
    in a dictionary. To store items in an ordered list, you would use an array and
    look up each item by its index. If you wanted to store items by key instead, you
    would use a dictionary.
  id: totrans-10885
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你学习了如何将多个项存储在数组和字典中。要将项存储在有序列表中，你会使用数组，并通过索引查找每一项。如果你想通过键存储项，你则会使用字典。
- en: Knowing about arrays and dictionaries and how to use them is a powerful building
    block for almost any programming language. Next we will learn about functions,
    another very powerful tool. Functions are blocks of code that you create and name
    to perform a specific job. After you have written a function, you can use its
    name to call it from almost anywhere in your program.
  id: totrans-10886
  prefs: []
  type: TYPE_NORMAL
  zh: 了解数组和字典以及如何使用它们，是几乎任何编程语言的强大构建块。接下来，我们将学习函数，这是另一个非常强大的工具。函数是你创建并命名的代码块，用来执行特定的任务。写完一个函数后，你可以使用它的名字从程序中的任何地方调用它。
- en: 'Like an array, a dictionary also has an isEmpty property and a count property.
    For example, the following code shows how you can use the isEmpty property to
    check if a dictionary is empty, and if it isn’t empty, the count property checks
    how many items you have. Imagine you have a basket of fruit for sale. You can
    use these properties to help you keep track of everything:'
  id: totrans-10887
  prefs: []
  type: TYPE_NORMAL
  zh: 像数组一样，字典也有 isEmpty 属性和 count 属性。例如，下面的代码展示了如何使用 isEmpty 属性来检查字典是否为空，如果不为空，则通过
    count 属性检查字典中有多少项。假设你有一个水果篮子在出售，你可以使用这些属性帮助你跟踪所有内容：
- en: '![Image](Image00148.jpg)'
  id: totrans-10888
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00148.jpg)'
- en: 'A dictionary also has two special properties: keys , which contains all of
    the dictionary’s keys, and values , which contains all of its values. We’ll use
    these two properties when we loop through the dictionary.'
  id: totrans-10889
  prefs: []
  type: TYPE_NORMAL
  zh: 字典还有两个特殊的属性：keys，包含字典的所有键；values，包含字典的所有值。在遍历字典时，我们将使用这两个属性。
- en: Let’s write some code that loops through our fruit baskets and prints the price
    of each fruit.
  id: totrans-10890
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们写一些代码，遍历我们的水果篮子并打印每个水果的价格。
- en: '**LOOPING OVER A DICTIONARY**'
  id: totrans-10891
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**遍历字典**'
- en: 'You can loop through a dictionary using a for-in loop. Because each item has
    a key and a value, you can do this in two different ways. This is how to loop
    through a dictionary using its keys:'
  id: totrans-10892
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用 for-in 循环遍历字典。由于每个项都有一个键和值，因此你可以通过两种方式来遍历字典。这是通过字典的键进行遍历的方式：
- en: '![Image](Image00149.jpg)'
  id: totrans-10893
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00149.jpg)'
- en: Here we use the dictionary’s keys property ➊ to loop through fruitBasket and
    print its contents. We start by writing the keyword for , followed by a constant
    name fruit for the dictionary key, the keyword in , the dictionary name, a period,
    and keys .
  id: totrans-10894
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们使用字典的keys属性 ➊ 来遍历fruitBasket并打印其内容。我们首先写下关键词`for`，接着是常量名称`fruit`作为字典键，关键词`in`，字典名称，接着是句点，再加上`keys`。
- en: Inside the braces of our for-in loop, we have access to both the key, which
    we call fruit ➋ , and the value at that key when we force-unwrap its contents
    with fruitBasket[fruit]! ➌ . That value will be the fruit’s price.
  id: totrans-10895
  prefs: []
  type: TYPE_NORMAL
  zh: 在`for-in`循环的花括号内部，我们可以访问键，称之为`fruit` ➋ ，以及当我们强制解包其内容时的该键的值，使用`fruitBasket[fruit]!`
    ➌ 。该值就是水果的价格。
- en: In this case, it’s safe to force-unwrap the value using an exclamation point
    because we know that the fruit key we’re using is definitely inside the dictionary.
  id: totrans-10896
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，使用感叹号强制解包值是安全的，因为我们知道正在使用的水果键肯定在字典中。
- en: Any code we put inside the for-in loop will run once for every key in our dictionary.
    So you should see the print statement display three times.
  id: totrans-10897
  prefs: []
  type: TYPE_NORMAL
  zh: 我们放入`for-in`循环中的任何代码都会在字典中的每个键上运行一次。所以你应该看到打印语句显示三次。
- en: 'We can also loop through the dictionary using its values property:'
  id: totrans-10898
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以使用字典的values属性来遍历字典：
- en: '![Image](Image00150.jpg)'
  id: totrans-10899
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00150.jpg)'
- en: We use the same style of for-in loop, but now we use a constant to refer to
    each value, which we call price , in the values property. When looping through
    values, we don’t have access to the keys from inside the loop.
  id: totrans-10900
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用相同的`for-in`循环样式，但现在我们使用一个常量来引用`values`属性中的每个值，称之为`price`。当遍历值时，我们无法从循环内部访问键。
- en: Another difference to note is that price is not an optional because it’s accessed
    directly as a value in the fruitBasket dictionary. That means we don’t have to
    unwrap it. You should still see the print statement printed three times. [Figure
    6-6](text00016.html#ch06fig6) shows the output of both loops.
  id: totrans-10901
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个需要注意的区别是，`price`不是一个可选值，因为它是直接作为值从`fruitBasket`字典中访问的。这意味着我们不需要解包它。你应该仍然看到打印语句打印三次。[图6-6](text00016.html#ch06fig6)展示了两个循环的输出。
- en: '![Image](Image00151.jpg)'
  id: totrans-10902
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00151.jpg)'
- en: '*Figure 6-6: Looping through the keys and values of a dictionary with a for-in
    loop*'
  id: totrans-10903
  prefs: []
  type: TYPE_NORMAL
  zh: '*图6-6：使用for-in循环遍历字典的键和值*'
- en: The order of your results might be slightly different from ours. That’s because
    the items in a dictionary aren’t in a numbered order like they are in an array!
    And because the order is not guaranteed, you might see a different order printed
    if you run the same code again.
  id: totrans-10904
  prefs: []
  type: TYPE_NORMAL
  zh: 你的结果顺序可能会与我们的略有不同。这是因为字典中的项不像数组中的项那样是按编号顺序排列的！由于顺序没有保证，如果你再次运行相同的代码，你可能会看到不同的打印顺序。
- en: '**WHAT YOU LEARNED**'
  id: totrans-10905
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**你学到了什么**'
- en: In this chapter, you learned how to store collections of items in an array and
    in a dictionary. To store items in an ordered list, you would use an array and
    look up each item by its index. If you wanted to store items by key instead, you
    would use a dictionary.
  id: totrans-10906
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你学会了如何将项目存储在数组和字典中。要将项目存储在有序列表中，你会使用数组，并通过索引查找每个项目。如果你想根据键存储项目，应该使用字典。
- en: Knowing about arrays and dictionaries and how to use them is a powerful building
    block for almost any programming language. Next we will learn about functions,
    another very powerful tool. Functions are blocks of code that you create and name
    to perform a specific job. After you have written a function, you can use its
    name to call it from almost anywhere in your program.
  id: totrans-10907
  prefs: []
  type: TYPE_NORMAL
  zh: 了解数组和字典以及如何使用它们，是几乎所有编程语言中一个强大的基础模块。接下来，我们将学习函数，这是另一个非常强大的工具。函数是你创建并命名的一段代码，用于执行特定任务。编写了函数后，你可以在程序中的几乎任何地方通过它的名字来调用它。
- en: '![Image](Image00148.jpg)'
  id: totrans-10908
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00148.jpg)'
- en: 'A dictionary also has two special properties: keys , which contains all of
    the dictionary’s keys, and values , which contains all of its values. We’ll use
    these two properties when we loop through the dictionary.'
  id: totrans-10909
  prefs: []
  type: TYPE_NORMAL
  zh: 字典还有两个特殊的属性：keys，它包含字典的所有键；以及values，它包含字典的所有值。在遍历字典时，我们将使用这两个属性。
- en: Let’s write some code that loops through our fruit baskets and prints the price
    of each fruit.
  id: totrans-10910
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们写一些代码，遍历我们的水果篮并打印每种水果的价格。
- en: '**LOOPING OVER A DICTIONARY**'
  id: totrans-10911
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**遍历字典**'
- en: 'You can loop through a dictionary using a for-in loop. Because each item has
    a key and a value, you can do this in two different ways. This is how to loop
    through a dictionary using its keys:'
  id: totrans-10912
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用`for-in`循环遍历字典。因为每个项都有一个键和值，你可以通过两种方式进行遍历。这是使用字典的键来遍历字典的方法：
- en: '![Image](Image00149.jpg)'
  id: totrans-10913
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Image00149.jpg)'
- en: Here we use the dictionary’s keys property ➊ to loop through fruitBasket and
    print its contents. We start by writing the keyword for , followed by a constant
    name fruit for the dictionary key, the keyword in , the dictionary name, a period,
    and keys .
  id: totrans-10914
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们使用字典的`keys`属性 ➊ 来遍历`fruitBasket`并打印其内容。我们首先编写关键字`for`，然后是字典键的常量名称`fruit`，接着是关键字`in`，字典名称，一个句点，然后是`keys`。
- en: Inside the braces of our for-in loop, we have access to both the key, which
    we call fruit ➋ , and the value at that key when we force-unwrap its contents
    with fruitBasket[fruit]! ➌ . That value will be the fruit’s price.
  id: totrans-10915
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们`for-in`循环的大括号内部，我们可以访问键（我们称之为fruit ➋）和通过强制解包`fruitBasket[fruit]!` ➌ 获取的键对应的值。这个值就是水果的价格。
- en: In this case, it’s safe to force-unwrap the value using an exclamation point
    because we know that the fruit key we’re using is definitely inside the dictionary.
  id: totrans-10916
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，使用感叹号强制解包值是安全的，因为我们知道我们正在使用的水果键肯定存在于字典中。
- en: Any code we put inside the for-in loop will run once for every key in our dictionary.
    So you should see the print statement display three times.
  id: totrans-10917
  prefs: []
  type: TYPE_NORMAL
  zh: 我们放在`for-in`循环中的任何代码都会对字典中的每个键运行一次。所以你应该看到打印语句显示三次。
- en: 'We can also loop through the dictionary using its values property:'
  id: totrans-10918
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以通过字典的`values`属性来循环遍历：
- en: '![Image](Image00150.jpg)'
  id: totrans-10919
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Image00150.jpg)'
- en: We use the same style of for-in loop, but now we use a constant to refer to
    each value, which we call price , in the values property. When looping through
    values, we don’t have access to the keys from inside the loop.
  id: totrans-10920
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用相同的`for-in`循环样式，但现在我们使用常量来引用`values`属性中的每个值，我们称之为price。在遍历值时，我们无法从循环内部访问键。
- en: Another difference to note is that price is not an optional because it’s accessed
    directly as a value in the fruitBasket dictionary. That means we don’t have to
    unwrap it. You should still see the print statement printed three times. [Figure
    6-6](text00016.html#ch06fig6) shows the output of both loops.
  id: totrans-10921
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个需要注意的区别是，价格不是可选的，因为它直接作为值访问`fruitBasket`字典中的数据。这意味着我们不需要解包它。你仍然应该看到打印语句打印三次。[图
    6-6](text00016.html#ch06fig6)展示了两个循环的输出。
- en: '![Image](Image00151.jpg)'
  id: totrans-10922
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Image00151.jpg)'
- en: '*Figure 6-6: Looping through the keys and values of a dictionary with a for-in
    loop*'
  id: totrans-10923
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 6-6：使用`for-in`循环遍历字典的键和值*'
- en: The order of your results might be slightly different from ours. That’s because
    the items in a dictionary aren’t in a numbered order like they are in an array!
    And because the order is not guaranteed, you might see a different order printed
    if you run the same code again.
  id: totrans-10924
  prefs: []
  type: TYPE_NORMAL
  zh: 你的结果顺序可能与你的不同。那是因为字典中的项目不像数组那样按数字顺序排列！由于顺序不可保证，如果你再次运行相同的代码，可能会看到不同的顺序。
- en: '**WHAT YOU LEARNED**'
  id: totrans-10925
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**你学到的内容**'
- en: In this chapter, you learned how to store collections of items in an array and
    in a dictionary. To store items in an ordered list, you would use an array and
    look up each item by its index. If you wanted to store items by key instead, you
    would use a dictionary.
  id: totrans-10926
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你学会了如何将项目存储在数组和字典中。为了将项目存储在有序列表中，你将使用数组，并通过索引查找每个项目。如果你想按键存储项目，则应使用字典。
- en: Knowing about arrays and dictionaries and how to use them is a powerful building
    block for almost any programming language. Next we will learn about functions,
    another very powerful tool. Functions are blocks of code that you create and name
    to perform a specific job. After you have written a function, you can use its
    name to call it from almost anywhere in your program.
  id: totrans-10927
  prefs: []
  type: TYPE_NORMAL
  zh: 了解数组和字典以及如何使用它们，是几乎所有编程语言中的一个强大构建块。接下来我们将学习函数，另一个非常强大的工具。函数是你创建并命名的代码块，用来执行特定的工作。编写函数后，你可以使用它的名称在程序的几乎任何地方调用它。
- en: 'A dictionary also has two special properties: keys , which contains all of
    the dictionary’s keys, and values , which contains all of its values. We’ll use
    these two properties when we loop through the dictionary.'
  id: totrans-10928
  prefs: []
  type: TYPE_NORMAL
  zh: 字典还有两个特殊的属性：`keys`，它包含字典的所有键，以及`values`，它包含所有的值。在我们遍历字典时，我们会使用这两个属性。
- en: Let’s write some code that loops through our fruit baskets and prints the price
    of each fruit.
  id: totrans-10929
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们编写一些代码，循环遍历我们的水果篮并打印每种水果的价格。
- en: '**LOOPING OVER A DICTIONARY**'
  id: totrans-10930
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**遍历字典**'
- en: 'You can loop through a dictionary using a for-in loop. Because each item has
    a key and a value, you can do this in two different ways. This is how to loop
    through a dictionary using its keys:'
  id: totrans-10931
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用`for-in`循环遍历字典。由于每个项目都有一个键和值，因此你可以以两种不同的方式进行遍历。以下是通过字典的键来循环遍历的方法：
- en: '![Image](Image00149.jpg)'
  id: totrans-10932
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00149.jpg)'
- en: Here we use the dictionary’s keys property ➊ to loop through fruitBasket and
    print its contents. We start by writing the keyword for , followed by a constant
    name fruit for the dictionary key, the keyword in , the dictionary name, a period,
    and keys .
  id: totrans-10933
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们使用字典的键属性 ➊ 来遍历果篮并打印其内容。我们从写关键字 for 开始，接着是一个常量名 fruit 来代表字典键，再是关键字 in ，字典名，句点和
    keys 。
- en: Inside the braces of our for-in loop, we have access to both the key, which
    we call fruit ➋ , and the value at that key when we force-unwrap its contents
    with fruitBasket[fruit]! ➌ . That value will be the fruit’s price.
  id: totrans-10934
  prefs: []
  type: TYPE_NORMAL
  zh: 在 for-in 循环的花括号内，我们可以访问到键，即我们称之为 fruit ➋ ，以及通过强制解包其内容（使用 fruitBasket[fruit]!
    ➌ ）时该键对应的值。这个值就是水果的价格。
- en: In this case, it’s safe to force-unwrap the value using an exclamation point
    because we know that the fruit key we’re using is definitely inside the dictionary.
  id: totrans-10935
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，使用感叹号强制解包值是安全的，因为我们知道我们使用的水果键一定在字典中。
- en: Any code we put inside the for-in loop will run once for every key in our dictionary.
    So you should see the print statement display three times.
  id: totrans-10936
  prefs: []
  type: TYPE_NORMAL
  zh: 我们放在 for-in 循环中的任何代码都会为字典中的每个键执行一次。所以你应该能看到打印语句执行三次。
- en: 'We can also loop through the dictionary using its values property:'
  id: totrans-10937
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以使用字典的 values 属性进行遍历：
- en: '![Image](Image00150.jpg)'
  id: totrans-10938
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00150.jpg)'
- en: We use the same style of for-in loop, but now we use a constant to refer to
    each value, which we call price , in the values property. When looping through
    values, we don’t have access to the keys from inside the loop.
  id: totrans-10939
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用相同风格的 for-in 循环，但这次我们使用一个常量来引用每个值，这个常量叫做 price ，它位于 values 属性中。当遍历 values
    时，我们无法在循环内部访问到键。
- en: Another difference to note is that price is not an optional because it’s accessed
    directly as a value in the fruitBasket dictionary. That means we don’t have to
    unwrap it. You should still see the print statement printed three times. [Figure
    6-6](text00016.html#ch06fig6) shows the output of both loops.
  id: totrans-10940
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个需要注意的区别是，价格（price）不是一个可选类型，因为它是直接作为值从果篮字典中访问的。这意味着我们不需要解包它。你仍然应该能看到打印语句执行三次。[图6-6](text00016.html#ch06fig6)
    显示了两个循环的输出。
- en: '![Image](Image00151.jpg)'
  id: totrans-10941
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00151.jpg)'
- en: '*Figure 6-6: Looping through the keys and values of a dictionary with a for-in
    loop*'
  id: totrans-10942
  prefs: []
  type: TYPE_NORMAL
  zh: '*图6-6：使用 for-in 循环遍历字典的键和值*'
- en: The order of your results might be slightly different from ours. That’s because
    the items in a dictionary aren’t in a numbered order like they are in an array!
    And because the order is not guaranteed, you might see a different order printed
    if you run the same code again.
  id: totrans-10943
  prefs: []
  type: TYPE_NORMAL
  zh: 你的结果顺序可能与我们的略有不同。这是因为字典中的项不像数组那样按编号顺序排列！而且由于顺序无法保证，如果你再次运行相同的代码，可能会看到不同的顺序。
- en: '**WHAT YOU LEARNED**'
  id: totrans-10944
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**你学到的内容**'
- en: In this chapter, you learned how to store collections of items in an array and
    in a dictionary. To store items in an ordered list, you would use an array and
    look up each item by its index. If you wanted to store items by key instead, you
    would use a dictionary.
  id: totrans-10945
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你学习了如何将项集合存储在数组和字典中。要将项存储在有序列表中，你会使用数组并通过索引查找每个项。如果你想按键存储项，你将使用字典。
- en: Knowing about arrays and dictionaries and how to use them is a powerful building
    block for almost any programming language. Next we will learn about functions,
    another very powerful tool. Functions are blocks of code that you create and name
    to perform a specific job. After you have written a function, you can use its
    name to call it from almost anywhere in your program.
  id: totrans-10946
  prefs: []
  type: TYPE_NORMAL
  zh: 了解数组和字典及其使用方法是几乎所有编程语言的强大构建模块。接下来我们将学习函数，另一种非常强大的工具。函数是你创建并命名的一块代码，用来执行特定的任务。在编写完函数后，你可以通过它的名字从程序中的几乎任何地方调用它。
- en: Let’s write some code that loops through our fruit baskets and prints the price
    of each fruit.
  id: totrans-10947
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们写一些代码，遍历我们的果篮并打印每种水果的价格。
- en: '**LOOPING OVER A DICTIONARY**'
  id: totrans-10948
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**遍历字典**'
- en: 'You can loop through a dictionary using a for-in loop. Because each item has
    a key and a value, you can do this in two different ways. This is how to loop
    through a dictionary using its keys:'
  id: totrans-10949
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用 for-in 循环遍历字典。因为每个项都有一个键和值，你可以通过两种不同的方式来完成。下面是使用字典的键进行遍历的方法：
- en: '![Image](Image00149.jpg)'
  id: totrans-10950
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00149.jpg)'
- en: Here we use the dictionary’s keys property ➊ to loop through fruitBasket and
    print its contents. We start by writing the keyword for , followed by a constant
    name fruit for the dictionary key, the keyword in , the dictionary name, a period,
    and keys .
  id: totrans-10951
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们使用字典的键属性 ➊ 遍历 fruitBasket 并打印其内容。我们首先写下关键字 for，后面跟上一个常量名称 fruit，表示字典的键，然后是关键字
    in，字典的名称，句点和 keys。
- en: Inside the braces of our for-in loop, we have access to both the key, which
    we call fruit ➋ , and the value at that key when we force-unwrap its contents
    with fruitBasket[fruit]! ➌ . That value will be the fruit’s price.
  id: totrans-10952
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的 for-in 循环的大括号内，我们可以访问到键（我们称之为 fruit ➋），以及通过强制解包其内容 fruitBasket[fruit]!
    ➌ 获取的该键对应的值。这个值将是水果的价格。
- en: In this case, it’s safe to force-unwrap the value using an exclamation point
    because we know that the fruit key we’re using is definitely inside the dictionary.
  id: totrans-10953
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，使用感叹号强制解包值是安全的，因为我们知道正在使用的水果键一定在字典中。
- en: Any code we put inside the for-in loop will run once for every key in our dictionary.
    So you should see the print statement display three times.
  id: totrans-10954
  prefs: []
  type: TYPE_NORMAL
  zh: 我们放入 for-in 循环中的任何代码都会对字典中的每个键运行一次。所以你应该看到打印语句显示三次。
- en: 'We can also loop through the dictionary using its values property:'
  id: totrans-10955
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以使用字典的值属性进行遍历：
- en: '![Image](Image00150.jpg)'
  id: totrans-10956
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00150.jpg)'
- en: We use the same style of for-in loop, but now we use a constant to refer to
    each value, which we call price , in the values property. When looping through
    values, we don’t have access to the keys from inside the loop.
  id: totrans-10957
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用相同的 for-in 循环风格，但现在我们使用一个常量来引用每个值，我们称之为 price，位于 values 属性中。在遍历值时，我们无法从循环内部访问键。
- en: Another difference to note is that price is not an optional because it’s accessed
    directly as a value in the fruitBasket dictionary. That means we don’t have to
    unwrap it. You should still see the print statement printed three times. [Figure
    6-6](text00016.html#ch06fig6) shows the output of both loops.
  id: totrans-10958
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个需要注意的区别是 price 不是一个可选值，因为它直接作为值从 fruitBasket 字典中访问。这意味着我们不需要解包它。你仍然应该看到打印语句打印三次。[图
    6-6](text00016.html#ch06fig6) 显示了两种循环的输出。
- en: '![Image](Image00151.jpg)'
  id: totrans-10959
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00151.jpg)'
- en: '*Figure 6-6: Looping through the keys and values of a dictionary with a for-in
    loop*'
  id: totrans-10960
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 6-6：使用 for-in 循环遍历字典的键和值*'
- en: The order of your results might be slightly different from ours. That’s because
    the items in a dictionary aren’t in a numbered order like they are in an array!
    And because the order is not guaranteed, you might see a different order printed
    if you run the same code again.
  id: totrans-10961
  prefs: []
  type: TYPE_NORMAL
  zh: 你的结果顺序可能与我们的略有不同。那是因为字典中的项不像数组中的项那样按编号顺序排列！而且由于顺序不保证，你可能会看到不同的顺序，如果你再次运行相同的代码。
- en: '**WHAT YOU LEARNED**'
  id: totrans-10962
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**你学到了什么**'
- en: In this chapter, you learned how to store collections of items in an array and
    in a dictionary. To store items in an ordered list, you would use an array and
    look up each item by its index. If you wanted to store items by key instead, you
    would use a dictionary.
  id: totrans-10963
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你学会了如何在数组和字典中存储项。为了在有序列表中存储项，你会使用数组并通过索引查找每个项。如果你想根据键存储项，你将使用字典。
- en: Knowing about arrays and dictionaries and how to use them is a powerful building
    block for almost any programming language. Next we will learn about functions,
    another very powerful tool. Functions are blocks of code that you create and name
    to perform a specific job. After you have written a function, you can use its
    name to call it from almost anywhere in your program.
  id: totrans-10964
  prefs: []
  type: TYPE_NORMAL
  zh: 了解数组和字典以及如何使用它们是几乎所有编程语言中一个强大的构建块。接下来我们将学习函数，另一个非常强大的工具。函数是你创建并命名的代码块，用于执行特定的任务。编写完函数后，你可以通过其名称从程序中的几乎任何地方调用它。
- en: '**LOOPING OVER A DICTIONARY**'
  id: totrans-10965
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**遍历字典**'
- en: 'You can loop through a dictionary using a for-in loop. Because each item has
    a key and a value, you can do this in two different ways. This is how to loop
    through a dictionary using its keys:'
  id: totrans-10966
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用 for-in 循环遍历字典。因为每个项都有一个键和值，所以你可以通过两种不同的方式来遍历字典。这是通过键遍历字典的方式：
- en: '![Image](Image00149.jpg)'
  id: totrans-10967
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00149.jpg)'
- en: Here we use the dictionary’s keys property ➊ to loop through fruitBasket and
    print its contents. We start by writing the keyword for , followed by a constant
    name fruit for the dictionary key, the keyword in , the dictionary name, a period,
    and keys .
  id: totrans-10968
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们使用字典的键属性 ➊ 遍历 fruitBasket 并打印其内容。我们首先写下关键字 for，后面跟上一个常量名称 fruit，表示字典的键，然后是关键字
    in，字典的名称，句点和 keys。
- en: Inside the braces of our for-in loop, we have access to both the key, which
    we call fruit ➋ , and the value at that key when we force-unwrap its contents
    with fruitBasket[fruit]! ➌ . That value will be the fruit’s price.
  id: totrans-10969
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们 for-in 循环的大括号内部，我们可以同时访问键（我们称之为 fruit ➋）和通过强制解包其内容（使用 fruitBasket[fruit]!
    ➌）获得的该键的值。该值就是水果的价格。
- en: In this case, it’s safe to force-unwrap the value using an exclamation point
    because we know that the fruit key we’re using is definitely inside the dictionary.
  id: totrans-10970
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，使用感叹号强制解包值是安全的，因为我们知道我们使用的水果键一定在字典中。
- en: Any code we put inside the for-in loop will run once for every key in our dictionary.
    So you should see the print statement display three times.
  id: totrans-10971
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在 for-in 循环内部放置的任何代码都会针对字典中的每个键执行一次。所以你应该看到打印语句显示三次。
- en: 'We can also loop through the dictionary using its values property:'
  id: totrans-10972
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以通过字典的 values 属性来遍历字典：
- en: '![Image](Image00150.jpg)'
  id: totrans-10973
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00150.jpg)'
- en: We use the same style of for-in loop, but now we use a constant to refer to
    each value, which we call price , in the values property. When looping through
    values, we don’t have access to the keys from inside the loop.
  id: totrans-10974
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用相同的 for-in 循环样式，但现在我们使用一个常量来引用 values 属性中的每个值，我们称之为 price。在遍历值时，我们无法从循环内部访问键。
- en: Another difference to note is that price is not an optional because it’s accessed
    directly as a value in the fruitBasket dictionary. That means we don’t have to
    unwrap it. You should still see the print statement printed three times. [Figure
    6-6](text00016.html#ch06fig6) shows the output of both loops.
  id: totrans-10975
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个需要注意的区别是，价格不是一个可选值，因为它是作为 fruitBasket 字典中的一个值直接访问的。这意味着我们不需要解包它。你仍然应该看到打印语句被打印三次。[图
    6-6](text00016.html#ch06fig6) 显示了两个循环的输出。
- en: '![Image](Image00151.jpg)'
  id: totrans-10976
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00151.jpg)'
- en: '*Figure 6-6: Looping through the keys and values of a dictionary with a for-in
    loop*'
  id: totrans-10977
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 6-6：使用 for-in 循环遍历字典的键和值*'
- en: The order of your results might be slightly different from ours. That’s because
    the items in a dictionary aren’t in a numbered order like they are in an array!
    And because the order is not guaranteed, you might see a different order printed
    if you run the same code again.
  id: totrans-10978
  prefs: []
  type: TYPE_NORMAL
  zh: 你的结果顺序可能与我们的稍有不同。这是因为字典中的项目不像数组中的项目那样按数字顺序排列！由于顺序无法保证，如果你再次运行相同的代码，可能会看到不同的顺序。
- en: '**WHAT YOU LEARNED**'
  id: totrans-10979
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**你学到了什么**'
- en: In this chapter, you learned how to store collections of items in an array and
    in a dictionary. To store items in an ordered list, you would use an array and
    look up each item by its index. If you wanted to store items by key instead, you
    would use a dictionary.
  id: totrans-10980
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一章中，你学习了如何将一组项目存储在数组和字典中。要将项目存储在有序列表中，你会使用数组，并通过索引查找每个项目。如果你想按键存储项目，则需要使用字典。
- en: Knowing about arrays and dictionaries and how to use them is a powerful building
    block for almost any programming language. Next we will learn about functions,
    another very powerful tool. Functions are blocks of code that you create and name
    to perform a specific job. After you have written a function, you can use its
    name to call it from almost anywhere in your program.
  id: totrans-10981
  prefs: []
  type: TYPE_NORMAL
  zh: 了解数组和字典以及如何使用它们，是几乎所有编程语言的一个强大构建模块。接下来我们将学习函数，另一个非常强大的工具。函数是你创建并命名的代码块，用来执行特定的任务。编写完函数后，你可以通过其名称在程序的几乎任何地方调用它。
- en: 'You can loop through a dictionary using a for-in loop. Because each item has
    a key and a value, you can do this in two different ways. This is how to loop
    through a dictionary using its keys:'
  id: totrans-10982
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用 for-in 循环遍历字典。因为每个项目都有一个键和一个值，所以你可以用两种不同的方式来实现。以下是使用键遍历字典的方法：
- en: '![Image](Image00149.jpg)'
  id: totrans-10983
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00149.jpg)'
- en: Here we use the dictionary’s keys property ➊ to loop through fruitBasket and
    print its contents. We start by writing the keyword for , followed by a constant
    name fruit for the dictionary key, the keyword in , the dictionary name, a period,
    and keys .
  id: totrans-10984
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们使用字典的 keys 属性 ➊ 来遍历 fruitBasket 并打印其内容。我们首先写下关键字 for，然后是字典键的常量名称 fruit，接着是关键字
    in，字典名称，一个句点，最后是 keys。
- en: Inside the braces of our for-in loop, we have access to both the key, which
    we call fruit ➋ , and the value at that key when we force-unwrap its contents
    with fruitBasket[fruit]! ➌ . That value will be the fruit’s price.
  id: totrans-10985
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们 for-in 循环的大括号内部，我们可以同时访问键（我们称之为 fruit ➋）和通过强制解包其内容（使用 fruitBasket[fruit]!
    ➌）获得的该键的值。该值就是水果的价格。
- en: In this case, it’s safe to force-unwrap the value using an exclamation point
    because we know that the fruit key we’re using is definitely inside the dictionary.
  id: totrans-10986
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，可以安全地使用感叹号强制解包值，因为我们知道我们使用的水果键肯定在字典中。
- en: Any code we put inside the for-in loop will run once for every key in our dictionary.
    So you should see the print statement display three times.
  id: totrans-10987
  prefs: []
  type: TYPE_NORMAL
  zh: 我们放入 `for-in` 循环中的每一行代码会在字典中的每个键上执行一次。所以你应该会看到打印语句显示三次。
- en: 'We can also loop through the dictionary using its values property:'
  id: totrans-10988
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以使用字典的 `values` 属性来遍历字典：
- en: '![Image](Image00150.jpg)'
  id: totrans-10989
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00150.jpg)'
- en: We use the same style of for-in loop, but now we use a constant to refer to
    each value, which we call price , in the values property. When looping through
    values, we don’t have access to the keys from inside the loop.
  id: totrans-10990
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用相同风格的 `for-in` 循环，但现在我们使用常量来引用 `values` 属性中的每个值，我们称其为 `price`。在遍历值时，我们无法从循环内部访问键。
- en: Another difference to note is that price is not an optional because it’s accessed
    directly as a value in the fruitBasket dictionary. That means we don’t have to
    unwrap it. You should still see the print statement printed three times. [Figure
    6-6](text00016.html#ch06fig6) shows the output of both loops.
  id: totrans-10991
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个值得注意的区别是，`price` 不是一个可选值，因为它是通过直接访问 `fruitBasket` 字典中的值来获取的。这意味着我们不需要解包它。你仍然应该会看到打印语句打印三次。[图
    6-6](text00016.html#ch06fig6) 显示了两个循环的输出。
- en: '![Image](Image00151.jpg)'
  id: totrans-10992
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00151.jpg)'
- en: '*Figure 6-6: Looping through the keys and values of a dictionary with a for-in
    loop*'
  id: totrans-10993
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 6-6：使用 `for-in` 循环遍历字典的键和值*'
- en: The order of your results might be slightly different from ours. That’s because
    the items in a dictionary aren’t in a numbered order like they are in an array!
    And because the order is not guaranteed, you might see a different order printed
    if you run the same code again.
  id: totrans-10994
  prefs: []
  type: TYPE_NORMAL
  zh: 你的结果顺序可能会与你看到的略有不同。这是因为字典中的项不像数组那样按编号顺序排列！而且由于顺序没有保证，如果你再次运行相同的代码，你可能会看到不同的顺序打印。
- en: '**WHAT YOU LEARNED**'
  id: totrans-10995
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**你学到了什么**'
- en: In this chapter, you learned how to store collections of items in an array and
    in a dictionary. To store items in an ordered list, you would use an array and
    look up each item by its index. If you wanted to store items by key instead, you
    would use a dictionary.
  id: totrans-10996
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你学习了如何在数组和字典中存储项的集合。要在有序列表中存储项，你会使用数组并通过索引查找每个项。如果你想通过键来存储项，则应该使用字典。
- en: Knowing about arrays and dictionaries and how to use them is a powerful building
    block for almost any programming language. Next we will learn about functions,
    another very powerful tool. Functions are blocks of code that you create and name
    to perform a specific job. After you have written a function, you can use its
    name to call it from almost anywhere in your program.
  id: totrans-10997
  prefs: []
  type: TYPE_NORMAL
  zh: 了解数组和字典以及如何使用它们是几乎所有编程语言中的一个强大构建模块。接下来，我们将学习函数，这是另一个非常强大的工具。函数是你创建并命名的一段代码，用来执行特定的任务。在你编写了一个函数之后，可以通过它的名称在程序的几乎任何地方调用它。
- en: '![Image](Image00149.jpg)'
  id: totrans-10998
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00149.jpg)'
- en: Here we use the dictionary’s keys property ➊ to loop through fruitBasket and
    print its contents. We start by writing the keyword for , followed by a constant
    name fruit for the dictionary key, the keyword in , the dictionary name, a period,
    and keys .
  id: totrans-10999
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们使用字典的 keys 属性 ➊ 来遍历 fruitBasket 并打印其内容。我们从写出关键字 `for` 开始，接着是常量名 `fruit`
    作为字典键，关键字 `in`，字典名，句点，和 `keys`。
- en: Inside the braces of our for-in loop, we have access to both the key, which
    we call fruit ➋ , and the value at that key when we force-unwrap its contents
    with fruitBasket[fruit]! ➌ . That value will be the fruit’s price.
  id: totrans-11000
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `for-in` 循环的大括号内，我们可以访问到键，也就是我们称之为 `fruit` ➋ 的那个键，并且可以通过 `fruitBasket[fruit]!`
    强制解包其内容 ➌ 来访问该键的值。该值将是水果的价格。
- en: In this case, it’s safe to force-unwrap the value using an exclamation point
    because we know that the fruit key we’re using is definitely inside the dictionary.
  id: totrans-11001
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，可以安全地使用感叹号强制解包值，因为我们知道我们使用的水果键肯定在字典中。
- en: Any code we put inside the for-in loop will run once for every key in our dictionary.
    So you should see the print statement display three times.
  id: totrans-11002
  prefs: []
  type: TYPE_NORMAL
  zh: 我们放入 `for-in` 循环中的每一行代码会在字典中的每个键上执行一次。所以你应该会看到打印语句显示三次。
- en: 'We can also loop through the dictionary using its values property:'
  id: totrans-11003
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以使用字典的 `values` 属性来遍历字典：
- en: '![Image](Image00150.jpg)'
  id: totrans-11004
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00150.jpg)'
- en: We use the same style of for-in loop, but now we use a constant to refer to
    each value, which we call price , in the values property. When looping through
    values, we don’t have access to the keys from inside the loop.
  id: totrans-11005
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用相同样式的`for-in`循环，但现在我们使用一个常量来引用每个值，我们称之为`price`，它位于`values`属性中。当遍历值时，我们无法在循环内部访问键。
- en: Another difference to note is that price is not an optional because it’s accessed
    directly as a value in the fruitBasket dictionary. That means we don’t have to
    unwrap it. You should still see the print statement printed three times. [Figure
    6-6](text00016.html#ch06fig6) shows the output of both loops.
  id: totrans-11006
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个需要注意的区别是，`price`不是可选项，因为它是直接作为值访问`fruitBasket`字典中的。这意味着我们不需要解包它。你仍然应该会看到打印语句打印三次。[图6-6](text00016.html#ch06fig6)显示了两个循环的输出。
- en: '![Image](Image00151.jpg)'
  id: totrans-11007
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00151.jpg)'
- en: '*Figure 6-6: Looping through the keys and values of a dictionary with a for-in
    loop*'
  id: totrans-11008
  prefs: []
  type: TYPE_NORMAL
  zh: '*图6-6：使用`for-in`循环遍历字典的键和值*'
- en: The order of your results might be slightly different from ours. That’s because
    the items in a dictionary aren’t in a numbered order like they are in an array!
    And because the order is not guaranteed, you might see a different order printed
    if you run the same code again.
  id: totrans-11009
  prefs: []
  type: TYPE_NORMAL
  zh: 你的结果顺序可能会与我们的稍有不同。这是因为字典中的项目不像数组那样按编号顺序排列！由于顺序无法保证，因此如果你再次运行相同的代码，可能会看到不同的顺序。
- en: '**WHAT YOU LEARNED**'
  id: totrans-11010
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**你学到的内容**'
- en: In this chapter, you learned how to store collections of items in an array and
    in a dictionary. To store items in an ordered list, you would use an array and
    look up each item by its index. If you wanted to store items by key instead, you
    would use a dictionary.
  id: totrans-11011
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你学习了如何将多个项目存储在数组和字典中。要将项目存储在有序列表中，你应该使用数组并通过索引查找每个项目。如果你想按键存储项目，则应该使用字典。
- en: Knowing about arrays and dictionaries and how to use them is a powerful building
    block for almost any programming language. Next we will learn about functions,
    another very powerful tool. Functions are blocks of code that you create and name
    to perform a specific job. After you have written a function, you can use its
    name to call it from almost anywhere in your program.
  id: totrans-11012
  prefs: []
  type: TYPE_NORMAL
  zh: 了解数组和字典以及如何使用它们，是几乎所有编程语言的强大构建模块。接下来，我们将学习函数，这是另一个非常强大的工具。函数是你创建并命名的代码块，用于执行特定任务。在你编写函数后，你可以在程序中的几乎任何地方使用其名称来调用它。
- en: Here we use the dictionary’s keys property ➊ to loop through fruitBasket and
    print its contents. We start by writing the keyword for , followed by a constant
    name fruit for the dictionary key, the keyword in , the dictionary name, a period,
    and keys .
  id: totrans-11013
  prefs: []
  type: TYPE_NORMAL
  zh: 这里我们使用字典的`keys`属性➊来遍历`fruitBasket`并打印其内容。我们首先写关键字`for`，然后是常量名称`fruit`（作为字典键），接着是关键字`in`，然后是字典名称、句点，最后是`keys`。
- en: Inside the braces of our for-in loop, we have access to both the key, which
    we call fruit ➋ , and the value at that key when we force-unwrap its contents
    with fruitBasket[fruit]! ➌ . That value will be the fruit’s price.
  id: totrans-11014
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们`for-in`循环的花括号内，我们可以访问键（我们称之为`fruit`➋）以及强制解包其内容后在该键处的值，使用`fruitBasket[fruit]!`➌。该值将是水果的价格。
- en: In this case, it’s safe to force-unwrap the value using an exclamation point
    because we know that the fruit key we’re using is definitely inside the dictionary.
  id: totrans-11015
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，使用感叹号强制解包该值是安全的，因为我们知道我们使用的`fruit`键一定在字典中。
- en: Any code we put inside the for-in loop will run once for every key in our dictionary.
    So you should see the print statement display three times.
  id: totrans-11016
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在`for-in`循环中放入的任何代码都会为字典中的每个键执行一次。因此，你应该会看到打印语句显示三次。
- en: 'We can also loop through the dictionary using its values property:'
  id: totrans-11017
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以通过字典的`values`属性进行遍历：
- en: '![Image](Image00150.jpg)'
  id: totrans-11018
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00150.jpg)'
- en: We use the same style of for-in loop, but now we use a constant to refer to
    each value, which we call price , in the values property. When looping through
    values, we don’t have access to the keys from inside the loop.
  id: totrans-11019
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用相同样式的`for-in`循环，但现在我们使用一个常量来引用每个值，我们称之为`price`，它位于`values`属性中。当遍历值时，我们无法在循环内部访问键。
- en: Another difference to note is that price is not an optional because it’s accessed
    directly as a value in the fruitBasket dictionary. That means we don’t have to
    unwrap it. You should still see the print statement printed three times. [Figure
    6-6](text00016.html#ch06fig6) shows the output of both loops.
  id: totrans-11020
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个需要注意的区别是，`price`不是可选项，因为它是直接作为值访问`fruitBasket`字典中的。这意味着我们不需要解包它。你仍然应该会看到打印语句打印三次。[图6-6](text00016.html#ch06fig6)显示了两个循环的输出。
- en: '![Image](Image00151.jpg)'
  id: totrans-11021
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00151.jpg)'
- en: '*Figure 6-6: Looping through the keys and values of a dictionary with a for-in
    loop*'
  id: totrans-11022
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 6-6：使用 for-in 循环遍历字典的键和值*'
- en: The order of your results might be slightly different from ours. That’s because
    the items in a dictionary aren’t in a numbered order like they are in an array!
    And because the order is not guaranteed, you might see a different order printed
    if you run the same code again.
  id: totrans-11023
  prefs: []
  type: TYPE_NORMAL
  zh: 你的结果顺序可能与我们的略有不同。这是因为字典中的项不像数组那样按编号排序！而且，由于顺序不能保证，如果你再次运行相同的代码，可能会看到不同的顺序。
- en: '**WHAT YOU LEARNED**'
  id: totrans-11024
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**你学到的内容**'
- en: In this chapter, you learned how to store collections of items in an array and
    in a dictionary. To store items in an ordered list, you would use an array and
    look up each item by its index. If you wanted to store items by key instead, you
    would use a dictionary.
  id: totrans-11025
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你学习了如何将项存储在数组和字典中。要将项存储在有序列表中，你会使用数组，并通过索引查找每一项。如果你想按键存储项，则会使用字典。
- en: Knowing about arrays and dictionaries and how to use them is a powerful building
    block for almost any programming language. Next we will learn about functions,
    another very powerful tool. Functions are blocks of code that you create and name
    to perform a specific job. After you have written a function, you can use its
    name to call it from almost anywhere in your program.
  id: totrans-11026
  prefs: []
  type: TYPE_NORMAL
  zh: 了解数组和字典以及如何使用它们，是几乎任何编程语言中强大的构建模块。接下来我们将学习函数，这是另一个非常强大的工具。函数是你创建并命名的一段代码，用于执行特定的任务。写完函数后，你可以通过函数名称在程序中的几乎任何地方调用它。
- en: Inside the braces of our for-in loop, we have access to both the key, which
    we call fruit ➋ , and the value at that key when we force-unwrap its contents
    with fruitBasket[fruit]! ➌ . That value will be the fruit’s price.
  id: totrans-11027
  prefs: []
  type: TYPE_NORMAL
  zh: 在 for-in 循环的大括号内，我们可以访问键（我们称之为 fruit ➋），并通过强制解包它的内容（使用 fruitBasket[fruit]! ➌）来访问该键的值。该值将是水果的价格。
- en: In this case, it’s safe to force-unwrap the value using an exclamation point
    because we know that the fruit key we’re using is definitely inside the dictionary.
  id: totrans-11028
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，使用感叹号强制解包值是安全的，因为我们知道我们使用的 fruit 键肯定在字典中。
- en: Any code we put inside the for-in loop will run once for every key in our dictionary.
    So you should see the print statement display three times.
  id: totrans-11029
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在 for-in 循环中放入的任何代码都会针对字典中的每个键运行一次。所以你应该看到打印语句显示三次。
- en: 'We can also loop through the dictionary using its values property:'
  id: totrans-11030
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以使用字典的 values 属性遍历字典：
- en: '![Image](Image00150.jpg)'
  id: totrans-11031
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00150.jpg)'
- en: We use the same style of for-in loop, but now we use a constant to refer to
    each value, which we call price , in the values property. When looping through
    values, we don’t have access to the keys from inside the loop.
  id: totrans-11032
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用相同风格的 for-in 循环，但现在我们使用一个常量来引用 values 属性中的每个值，我们称之为 price。当遍历 values 时，我们无法在循环内部访问键。
- en: Another difference to note is that price is not an optional because it’s accessed
    directly as a value in the fruitBasket dictionary. That means we don’t have to
    unwrap it. You should still see the print statement printed three times. [Figure
    6-6](text00016.html#ch06fig6) shows the output of both loops.
  id: totrans-11033
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个需要注意的区别是，price 不是可选类型，因为它是直接作为值访问 fruitBasket 字典中的。因此，我们不需要解包它。你仍然应该看到打印语句显示三次。[图
    6-6](text00016.html#ch06fig6) 显示了两个循环的输出结果。
- en: '![Image](Image00151.jpg)'
  id: totrans-11034
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00151.jpg)'
- en: '*Figure 6-6: Looping through the keys and values of a dictionary with a for-in
    loop*'
  id: totrans-11035
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 6-6：使用 for-in 循环遍历字典的键和值*'
- en: The order of your results might be slightly different from ours. That’s because
    the items in a dictionary aren’t in a numbered order like they are in an array!
    And because the order is not guaranteed, you might see a different order printed
    if you run the same code again.
  id: totrans-11036
  prefs: []
  type: TYPE_NORMAL
  zh: 你的结果顺序可能与我们的略有不同。这是因为字典中的项不像数组那样按编号排序！而且，由于顺序不能保证，如果你再次运行相同的代码，可能会看到不同的顺序。
- en: '**WHAT YOU LEARNED**'
  id: totrans-11037
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**你学到的内容**'
- en: In this chapter, you learned how to store collections of items in an array and
    in a dictionary. To store items in an ordered list, you would use an array and
    look up each item by its index. If you wanted to store items by key instead, you
    would use a dictionary.
  id: totrans-11038
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你学习了如何将项存储在数组和字典中。要将项存储在有序列表中，你会使用数组，并通过索引查找每一项。如果你想按键存储项，则会使用字典。
- en: Knowing about arrays and dictionaries and how to use them is a powerful building
    block for almost any programming language. Next we will learn about functions,
    another very powerful tool. Functions are blocks of code that you create and name
    to perform a specific job. After you have written a function, you can use its
    name to call it from almost anywhere in your program.
  id: totrans-11039
  prefs: []
  type: TYPE_NORMAL
  zh: 了解数组和字典以及如何使用它们是几乎所有编程语言中强大的构建块。接下来，我们将学习函数，这是另一个非常强大的工具。函数是你创建并命名的代码块，用于执行特定的任务。编写完函数后，你可以使用它的名称从程序的几乎任何地方调用它。
- en: In this case, it’s safe to force-unwrap the value using an exclamation point
    because we know that the fruit key we’re using is definitely inside the dictionary.
  id: totrans-11040
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，强制解包该值时使用感叹号是安全的，因为我们知道我们使用的fruit键肯定在字典中。
- en: Any code we put inside the for-in loop will run once for every key in our dictionary.
    So you should see the print statement display three times.
  id: totrans-11041
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在for-in循环中放入的任何代码都会对字典中的每个键执行一次。因此，你应该看到打印语句显示三次。
- en: 'We can also loop through the dictionary using its values property:'
  id: totrans-11042
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以使用字典的values属性进行循环：
- en: '![Image](Image00150.jpg)'
  id: totrans-11043
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Image00150.jpg)'
- en: We use the same style of for-in loop, but now we use a constant to refer to
    each value, which we call price , in the values property. When looping through
    values, we don’t have access to the keys from inside the loop.
  id: totrans-11044
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用相同类型的for-in循环，但现在我们使用一个常量来引用值（我们称之为price），该值位于values属性中。在遍历值时，我们无法从循环内部访问键。
- en: Another difference to note is that price is not an optional because it’s accessed
    directly as a value in the fruitBasket dictionary. That means we don’t have to
    unwrap it. You should still see the print statement printed three times. [Figure
    6-6](text00016.html#ch06fig6) shows the output of both loops.
  id: totrans-11045
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个需要注意的区别是，价格不是可选的，因为它在fruitBasket字典中作为值直接访问。这意味着我们不需要解包它。你仍然应该看到打印语句打印了三次。[图
    6-6](text00016.html#ch06fig6)展示了两个循环的输出结果。
- en: '![Image](Image00151.jpg)'
  id: totrans-11046
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Image00151.jpg)'
- en: '*Figure 6-6: Looping through the keys and values of a dictionary with a for-in
    loop*'
  id: totrans-11047
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 6-6：使用for-in循环遍历字典的键和值*'
- en: The order of your results might be slightly different from ours. That’s because
    the items in a dictionary aren’t in a numbered order like they are in an array!
    And because the order is not guaranteed, you might see a different order printed
    if you run the same code again.
  id: totrans-11048
  prefs: []
  type: TYPE_NORMAL
  zh: 你的结果顺序可能与我们的略有不同。这是因为字典中的项目不像数组那样按编号顺序排列！由于顺序不保证，因此如果再次运行相同的代码，你可能会看到不同的顺序打印出来。
- en: '**WHAT YOU LEARNED**'
  id: totrans-11049
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**你学到的内容**'
- en: In this chapter, you learned how to store collections of items in an array and
    in a dictionary. To store items in an ordered list, you would use an array and
    look up each item by its index. If you wanted to store items by key instead, you
    would use a dictionary.
  id: totrans-11050
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一章中，你学习了如何在数组和字典中存储项目集合。要将项目存储在有序列表中，你需要使用数组并通过索引查找每个项目。如果你想通过键存储项目，则需要使用字典。
- en: Knowing about arrays and dictionaries and how to use them is a powerful building
    block for almost any programming language. Next we will learn about functions,
    another very powerful tool. Functions are blocks of code that you create and name
    to perform a specific job. After you have written a function, you can use its
    name to call it from almost anywhere in your program.
  id: totrans-11051
  prefs: []
  type: TYPE_NORMAL
  zh: 了解数组和字典以及如何使用它们是几乎所有编程语言中强大的构建块。接下来，我们将学习函数，这是另一个非常强大的工具。函数是你创建并命名的代码块，用于执行特定的任务。编写完函数后，你可以使用它的名称从程序的几乎任何地方调用它。
- en: Any code we put inside the for-in loop will run once for every key in our dictionary.
    So you should see the print statement display three times.
  id: totrans-11052
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在for-in循环中放入的任何代码都会对字典中的每个键执行一次。因此，你应该看到打印语句显示三次。
- en: 'We can also loop through the dictionary using its values property:'
  id: totrans-11053
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以使用字典的values属性进行循环：
- en: '![Image](Image00150.jpg)'
  id: totrans-11054
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Image00150.jpg)'
- en: We use the same style of for-in loop, but now we use a constant to refer to
    each value, which we call price , in the values property. When looping through
    values, we don’t have access to the keys from inside the loop.
  id: totrans-11055
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用相同类型的for-in循环，但现在我们使用一个常量来引用值（我们称之为price），该值位于values属性中。在遍历值时，我们无法从循环内部访问键。
- en: Another difference to note is that price is not an optional because it’s accessed
    directly as a value in the fruitBasket dictionary. That means we don’t have to
    unwrap it. You should still see the print statement printed three times. [Figure
    6-6](text00016.html#ch06fig6) shows the output of both loops.
  id: totrans-11056
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个需要注意的区别是，`price` 不是一个可选项，因为它是直接作为值访问的，在 `fruitBasket` 字典中。这意味着我们不需要解包它。您仍然应该看到打印语句被打印三次。[图
    6-6](text00016.html#ch06fig6) 显示了两个循环的输出。
- en: '![Image](Image00151.jpg)'
  id: totrans-11057
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00151.jpg)'
- en: '*Figure 6-6: Looping through the keys and values of a dictionary with a for-in
    loop*'
  id: totrans-11058
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 6-6：使用 for-in 循环遍历字典的键和值*'
- en: The order of your results might be slightly different from ours. That’s because
    the items in a dictionary aren’t in a numbered order like they are in an array!
    And because the order is not guaranteed, you might see a different order printed
    if you run the same code again.
  id: totrans-11059
  prefs: []
  type: TYPE_NORMAL
  zh: 您的结果顺序可能与我们的略有不同。这是因为字典中的项目不像数组那样按编号顺序排列！而且因为顺序不保证，您如果再次运行相同的代码，可能会看到不同的顺序。
- en: '**WHAT YOU LEARNED**'
  id: totrans-11060
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**您学到了什么**'
- en: In this chapter, you learned how to store collections of items in an array and
    in a dictionary. To store items in an ordered list, you would use an array and
    look up each item by its index. If you wanted to store items by key instead, you
    would use a dictionary.
  id: totrans-11061
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，您学习了如何在数组和字典中存储项目集合。要将项目存储在有序列表中，您将使用数组，并通过其索引查找每个项目。如果您想通过键来存储项目，则应使用字典。
- en: Knowing about arrays and dictionaries and how to use them is a powerful building
    block for almost any programming language. Next we will learn about functions,
    another very powerful tool. Functions are blocks of code that you create and name
    to perform a specific job. After you have written a function, you can use its
    name to call it from almost anywhere in your program.
  id: totrans-11062
  prefs: []
  type: TYPE_NORMAL
  zh: 了解数组和字典及其用法是几乎任何编程语言的强大构建块。接下来，我们将学习函数，这是另一个非常强大的工具。函数是您创建并命名的代码块，用来执行特定的任务。编写完函数后，您可以通过其名称从程序中的几乎任何地方调用它。
- en: 'We can also loop through the dictionary using its values property:'
  id: totrans-11063
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以通过字典的 `values` 属性来循环遍历：
- en: '![Image](Image00150.jpg)'
  id: totrans-11064
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00150.jpg)'
- en: We use the same style of for-in loop, but now we use a constant to refer to
    each value, which we call price , in the values property. When looping through
    values, we don’t have access to the keys from inside the loop.
  id: totrans-11065
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用相同的 for-in 循环样式，但现在我们使用常量来引用 `values` 属性中的每个值，我们称其为 `price`。在遍历值时，我们无法从循环内部访问键。
- en: Another difference to note is that price is not an optional because it’s accessed
    directly as a value in the fruitBasket dictionary. That means we don’t have to
    unwrap it. You should still see the print statement printed three times. [Figure
    6-6](text00016.html#ch06fig6) shows the output of both loops.
  id: totrans-11066
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个需要注意的区别是，`price` 不是一个可选项，因为它是直接作为值访问的，在 `fruitBasket` 字典中。这意味着我们不需要解包它。您仍然应该看到打印语句被打印三次。[图
    6-6](text00016.html#ch06fig6) 显示了两个循环的输出。
- en: '![Image](Image00151.jpg)'
  id: totrans-11067
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00151.jpg)'
- en: '*Figure 6-6: Looping through the keys and values of a dictionary with a for-in
    loop*'
  id: totrans-11068
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 6-6：使用 for-in 循环遍历字典的键和值*'
- en: The order of your results might be slightly different from ours. That’s because
    the items in a dictionary aren’t in a numbered order like they are in an array!
    And because the order is not guaranteed, you might see a different order printed
    if you run the same code again.
  id: totrans-11069
  prefs: []
  type: TYPE_NORMAL
  zh: 您的结果顺序可能与我们的略有不同。这是因为字典中的项目不像数组那样按编号顺序排列！而且因为顺序不保证，您如果再次运行相同的代码，可能会看到不同的顺序。
- en: '**WHAT YOU LEARNED**'
  id: totrans-11070
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**您学到了什么**'
- en: In this chapter, you learned how to store collections of items in an array and
    in a dictionary. To store items in an ordered list, you would use an array and
    look up each item by its index. If you wanted to store items by key instead, you
    would use a dictionary.
  id: totrans-11071
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，您学习了如何在数组和字典中存储项目集合。要将项目存储在有序列表中，您将使用数组，并通过其索引查找每个项目。如果您想通过键来存储项目，则应使用字典。
- en: Knowing about arrays and dictionaries and how to use them is a powerful building
    block for almost any programming language. Next we will learn about functions,
    another very powerful tool. Functions are blocks of code that you create and name
    to perform a specific job. After you have written a function, you can use its
    name to call it from almost anywhere in your program.
  id: totrans-11072
  prefs: []
  type: TYPE_NORMAL
  zh: 了解数组和字典及其用法是几乎任何编程语言的强大构建块。接下来，我们将学习函数，这是另一个非常强大的工具。函数是您创建并命名的代码块，用来执行特定的任务。编写完函数后，您可以通过其名称从程序中的几乎任何地方调用它。
- en: '![Image](Image00150.jpg)'
  id: totrans-11073
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Image00150.jpg)'
- en: We use the same style of for-in loop, but now we use a constant to refer to
    each value, which we call price , in the values property. When looping through
    values, we don’t have access to the keys from inside the loop.
  id: totrans-11074
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用相同风格的 for-in 循环，但现在我们使用一个常量来引用每个值，我们称之为 price，它在 values 属性中。当遍历 values 时，我们无法从循环内部访问到键。
- en: Another difference to note is that price is not an optional because it’s accessed
    directly as a value in the fruitBasket dictionary. That means we don’t have to
    unwrap it. You should still see the print statement printed three times. [Figure
    6-6](text00016.html#ch06fig6) shows the output of both loops.
  id: totrans-11075
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个需要注意的区别是 price 不是可选类型，因为它是直接作为 fruitBasket 字典中的一个值访问的。这意味着我们不需要解包它。你仍然会看到
    print 语句打印三次。[图 6-6](text00016.html#ch06fig6) 显示了两个循环的输出。
- en: '![Image](Image00151.jpg)'
  id: totrans-11076
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Image00151.jpg)'
- en: '*Figure 6-6: Looping through the keys and values of a dictionary with a for-in
    loop*'
  id: totrans-11077
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 6-6：使用 for-in 循环遍历字典的键和值*'
- en: The order of your results might be slightly different from ours. That’s because
    the items in a dictionary aren’t in a numbered order like they are in an array!
    And because the order is not guaranteed, you might see a different order printed
    if you run the same code again.
  id: totrans-11078
  prefs: []
  type: TYPE_NORMAL
  zh: 你的结果顺序可能会与你的不同。那是因为字典中的项不像数组那样按编号顺序排列！并且由于顺序不保证，如果你再次运行相同的代码，可能会看到不同的输出顺序。
- en: '**WHAT YOU LEARNED**'
  id: totrans-11079
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**你学到了什么**'
- en: In this chapter, you learned how to store collections of items in an array and
    in a dictionary. To store items in an ordered list, you would use an array and
    look up each item by its index. If you wanted to store items by key instead, you
    would use a dictionary.
  id: totrans-11080
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你学习了如何将项目存储在数组和字典中。要在有序列表中存储项目，你会使用数组，并通过索引查找每个项目。如果你想通过键存储项目，则会使用字典。
- en: Knowing about arrays and dictionaries and how to use them is a powerful building
    block for almost any programming language. Next we will learn about functions,
    another very powerful tool. Functions are blocks of code that you create and name
    to perform a specific job. After you have written a function, you can use its
    name to call it from almost anywhere in your program.
  id: totrans-11081
  prefs: []
  type: TYPE_NORMAL
  zh: 了解数组和字典及其使用方法是几乎所有编程语言的一个强大基础。接下来，我们将学习函数，另一个非常强大的工具。函数是你创建并命名的代码块，用于执行特定的任务。写完函数后，你可以通过它的名称在程序中的几乎任何地方调用它。
- en: We use the same style of for-in loop, but now we use a constant to refer to
    each value, which we call price , in the values property. When looping through
    values, we don’t have access to the keys from inside the loop.
  id: totrans-11082
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用相同风格的 for-in 循环，但现在我们使用一个常量来引用每个值，我们称之为 price，它在 values 属性中。当遍历 values 时，我们无法从循环内部访问到键。
- en: Another difference to note is that price is not an optional because it’s accessed
    directly as a value in the fruitBasket dictionary. That means we don’t have to
    unwrap it. You should still see the print statement printed three times. [Figure
    6-6](text00016.html#ch06fig6) shows the output of both loops.
  id: totrans-11083
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个需要注意的区别是 price 不是可选类型，因为它是直接作为 fruitBasket 字典中的一个值访问的。这意味着我们不需要解包它。你仍然会看到
    print 语句打印三次。[图 6-6](text00016.html#ch06fig6) 显示了两个循环的输出。
- en: '![Image](Image00151.jpg)'
  id: totrans-11084
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Image00151.jpg)'
- en: '*Figure 6-6: Looping through the keys and values of a dictionary with a for-in
    loop*'
  id: totrans-11085
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 6-6：使用 for-in 循环遍历字典的键和值*'
- en: The order of your results might be slightly different from ours. That’s because
    the items in a dictionary aren’t in a numbered order like they are in an array!
    And because the order is not guaranteed, you might see a different order printed
    if you run the same code again.
  id: totrans-11086
  prefs: []
  type: TYPE_NORMAL
  zh: 你的结果顺序可能会与你的不同。那是因为字典中的项不像数组那样按编号顺序排列！并且由于顺序不保证，如果你再次运行相同的代码，可能会看到不同的输出顺序。
- en: '**WHAT YOU LEARNED**'
  id: totrans-11087
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**你学到了什么**'
- en: In this chapter, you learned how to store collections of items in an array and
    in a dictionary. To store items in an ordered list, you would use an array and
    look up each item by its index. If you wanted to store items by key instead, you
    would use a dictionary.
  id: totrans-11088
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你学习了如何将项目存储在数组和字典中。要在有序列表中存储项目，你会使用数组，并通过索引查找每个项目。如果你想通过键存储项目，则会使用字典。
- en: Knowing about arrays and dictionaries and how to use them is a powerful building
    block for almost any programming language. Next we will learn about functions,
    another very powerful tool. Functions are blocks of code that you create and name
    to perform a specific job. After you have written a function, you can use its
    name to call it from almost anywhere in your program.
  id: totrans-11089
  prefs: []
  type: TYPE_NORMAL
  zh: 了解数组和字典及其使用方法是几乎任何编程语言中的一个强大构建块。接下来我们将学习函数，这是另一个非常强大的工具。函数是你创建并命名的代码块，用于执行特定的任务。在编写完函数后，你可以通过其名称在程序的几乎任何地方调用它。
- en: Another difference to note is that price is not an optional because it’s accessed
    directly as a value in the fruitBasket dictionary. That means we don’t have to
    unwrap it. You should still see the print statement printed three times. [Figure
    6-6](text00016.html#ch06fig6) shows the output of both loops.
  id: totrans-11090
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个需要注意的区别是，price 不是一个可选项，因为它是直接作为值在fruitBasket字典中访问的。这意味着我们不需要解包它。你仍然应该看到print语句打印三次。[图6-6](text00016.html#ch06fig6)显示了两个循环的输出。
- en: '![Image](Image00151.jpg)'
  id: totrans-11091
  prefs: []
  type: TYPE_IMG
  zh: '![图像](Image00151.jpg)'
- en: '*Figure 6-6: Looping through the keys and values of a dictionary with a for-in
    loop*'
  id: totrans-11092
  prefs: []
  type: TYPE_NORMAL
  zh: '*图6-6：使用for-in循环遍历字典的键和值*'
- en: The order of your results might be slightly different from ours. That’s because
    the items in a dictionary aren’t in a numbered order like they are in an array!
    And because the order is not guaranteed, you might see a different order printed
    if you run the same code again.
  id: totrans-11093
  prefs: []
  type: TYPE_NORMAL
  zh: 你的结果顺序可能与我们的略有不同。这是因为字典中的项不像数组那样按数字顺序排列！而且，由于顺序无法保证，如果你再次运行相同的代码，你可能会看到不同的顺序打印出来。
- en: '**WHAT YOU LEARNED**'
  id: totrans-11094
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**你学到了什么**'
- en: In this chapter, you learned how to store collections of items in an array and
    in a dictionary. To store items in an ordered list, you would use an array and
    look up each item by its index. If you wanted to store items by key instead, you
    would use a dictionary.
  id: totrans-11095
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你学会了如何在数组和字典中存储项的集合。要将项存储在有序列表中，你可以使用数组并通过索引查找每个项。如果你想通过键来存储项，则应使用字典。
- en: Knowing about arrays and dictionaries and how to use them is a powerful building
    block for almost any programming language. Next we will learn about functions,
    another very powerful tool. Functions are blocks of code that you create and name
    to perform a specific job. After you have written a function, you can use its
    name to call it from almost anywhere in your program.
  id: totrans-11096
  prefs: []
  type: TYPE_NORMAL
  zh: 了解数组和字典及其使用方法是几乎任何编程语言中的一个强大构建块。接下来我们将学习函数，这是另一个非常强大的工具。函数是你创建并命名的代码块，用于执行特定的任务。在编写完函数后，你可以通过其名称在程序的几乎任何地方调用它。
- en: '![Image](Image00151.jpg)'
  id: totrans-11097
  prefs: []
  type: TYPE_IMG
  zh: '![图像](Image00151.jpg)'
- en: '*Figure 6-6: Looping through the keys and values of a dictionary with a for-in
    loop*'
  id: totrans-11098
  prefs: []
  type: TYPE_NORMAL
  zh: '*图6-6：使用for-in循环遍历字典的键和值*'
- en: The order of your results might be slightly different from ours. That’s because
    the items in a dictionary aren’t in a numbered order like they are in an array!
    And because the order is not guaranteed, you might see a different order printed
    if you run the same code again.
  id: totrans-11099
  prefs: []
  type: TYPE_NORMAL
  zh: 你的结果顺序可能与我们的略有不同。这是因为字典中的项不像数组那样按数字顺序排列！而且，由于顺序无法保证，如果你再次运行相同的代码，你可能会看到不同的顺序打印出来。
- en: '**WHAT YOU LEARNED**'
  id: totrans-11100
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**你学到了什么**'
- en: In this chapter, you learned how to store collections of items in an array and
    in a dictionary. To store items in an ordered list, you would use an array and
    look up each item by its index. If you wanted to store items by key instead, you
    would use a dictionary.
  id: totrans-11101
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你学会了如何在数组和字典中存储项的集合。要将项存储在有序列表中，你可以使用数组并通过索引查找每个项。如果你想通过键来存储项，则应使用字典。
- en: Knowing about arrays and dictionaries and how to use them is a powerful building
    block for almost any programming language. Next we will learn about functions,
    another very powerful tool. Functions are blocks of code that you create and name
    to perform a specific job. After you have written a function, you can use its
    name to call it from almost anywhere in your program.
  id: totrans-11102
  prefs: []
  type: TYPE_NORMAL
  zh: 了解数组和字典及其使用方法是几乎任何编程语言中的一个强大构建块。接下来我们将学习函数，这是另一个非常强大的工具。函数是你创建并命名的代码块，用于执行特定的任务。在编写完函数后，你可以通过其名称在程序的几乎任何地方调用它。
- en: '*Figure 6-6: Looping through the keys and values of a dictionary with a for-in
    loop*'
  id: totrans-11103
  prefs: []
  type: TYPE_NORMAL
  zh: '*图6-6：使用for-in循环遍历字典的键和值*'
- en: The order of your results might be slightly different from ours. That’s because
    the items in a dictionary aren’t in a numbered order like they are in an array!
    And because the order is not guaranteed, you might see a different order printed
    if you run the same code again.
  id: totrans-11104
  prefs: []
  type: TYPE_NORMAL
  zh: 你结果的顺序可能与我们的稍有不同。这是因为字典中的项不像数组那样按编号顺序排列！而且因为顺序无法保证，如果你再次运行相同的代码，你可能会看到不同的输出顺序。
- en: '**WHAT YOU LEARNED**'
  id: totrans-11105
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**你学到的**'
- en: In this chapter, you learned how to store collections of items in an array and
    in a dictionary. To store items in an ordered list, you would use an array and
    look up each item by its index. If you wanted to store items by key instead, you
    would use a dictionary.
  id: totrans-11106
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你学会了如何在数组和字典中存储一系列项。要将项存储在有序列表中，你会使用数组，并通过索引查找每个项。如果你想通过键来存储项，则应使用字典。
- en: Knowing about arrays and dictionaries and how to use them is a powerful building
    block for almost any programming language. Next we will learn about functions,
    another very powerful tool. Functions are blocks of code that you create and name
    to perform a specific job. After you have written a function, you can use its
    name to call it from almost anywhere in your program.
  id: totrans-11107
  prefs: []
  type: TYPE_NORMAL
  zh: 了解数组和字典及其使用方法是几乎所有编程语言的一个强大构建块。接下来，我们将学习函数，另一个非常强大的工具。函数是你创建并命名的代码块，用来执行特定的任务。在你编写完一个函数后，你可以通过它的名称在程序中的几乎任何地方调用它。
- en: The order of your results might be slightly different from ours. That’s because
    the items in a dictionary aren’t in a numbered order like they are in an array!
    And because the order is not guaranteed, you might see a different order printed
    if you run the same code again.
  id: totrans-11108
  prefs: []
  type: TYPE_NORMAL
  zh: 你结果的顺序可能与我们的稍有不同。这是因为字典中的项不像数组那样按编号顺序排列！而且因为顺序无法保证，如果你再次运行相同的代码，你可能会看到不同的输出顺序。
- en: '**WHAT YOU LEARNED**'
  id: totrans-11109
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**你学到的**'
- en: In this chapter, you learned how to store collections of items in an array and
    in a dictionary. To store items in an ordered list, you would use an array and
    look up each item by its index. If you wanted to store items by key instead, you
    would use a dictionary.
  id: totrans-11110
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你学会了如何在数组和字典中存储一系列项。要将项存储在有序列表中，你会使用数组，并通过索引查找每个项。如果你想通过键来存储项，则应使用字典。
- en: Knowing about arrays and dictionaries and how to use them is a powerful building
    block for almost any programming language. Next we will learn about functions,
    another very powerful tool. Functions are blocks of code that you create and name
    to perform a specific job. After you have written a function, you can use its
    name to call it from almost anywhere in your program.
  id: totrans-11111
  prefs: []
  type: TYPE_NORMAL
  zh: 了解数组和字典及其使用方法是几乎所有编程语言的一个强大构建块。接下来，我们将学习函数，另一个非常强大的工具。函数是你创建并命名的代码块，用来执行特定的任务。在你编写完一个函数后，你可以通过它的名称在程序中的几乎任何地方调用它。
- en: '**WHAT YOU LEARNED**'
  id: totrans-11112
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**你学到的**'
- en: In this chapter, you learned how to store collections of items in an array and
    in a dictionary. To store items in an ordered list, you would use an array and
    look up each item by its index. If you wanted to store items by key instead, you
    would use a dictionary.
  id: totrans-11113
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你学会了如何在数组和字典中存储一系列项。要将项存储在有序列表中，你会使用数组，并通过索引查找每个项。如果你想通过键来存储项，则应使用字典。
- en: Knowing about arrays and dictionaries and how to use them is a powerful building
    block for almost any programming language. Next we will learn about functions,
    another very powerful tool. Functions are blocks of code that you create and name
    to perform a specific job. After you have written a function, you can use its
    name to call it from almost anywhere in your program.
  id: totrans-11114
  prefs: []
  type: TYPE_NORMAL
  zh: 了解数组和字典及其使用方法是几乎所有编程语言的一个强大构建块。接下来，我们将学习函数，另一个非常强大的工具。函数是你创建并命名的代码块，用来执行特定的任务。在你编写完一个函数后，你可以通过它的名称在程序中的几乎任何地方调用它。
- en: In this chapter, you learned how to store collections of items in an array and
    in a dictionary. To store items in an ordered list, you would use an array and
    look up each item by its index. If you wanted to store items by key instead, you
    would use a dictionary.
  id: totrans-11115
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你学会了如何在数组和字典中存储一系列项。要将项存储在有序列表中，你会使用数组，并通过索引查找每个项。如果你想通过键来存储项，则应使用字典。
- en: Knowing about arrays and dictionaries and how to use them is a powerful building
    block for almost any programming language. Next we will learn about functions,
    another very powerful tool. Functions are blocks of code that you create and name
    to perform a specific job. After you have written a function, you can use its
    name to call it from almost anywhere in your program.
  id: totrans-11116
  prefs: []
  type: TYPE_NORMAL
  zh: 了解数组和字典以及如何使用它们是几乎任何编程语言中强大的构建块。接下来，我们将学习函数，另一种非常强大的工具。函数是你创建并命名的代码块，用于执行特定任务。在你编写完一个函数后，可以通过它的名字从程序中的几乎任何地方调用它。
- en: Knowing about arrays and dictionaries and how to use them is a powerful building
    block for almost any programming language. Next we will learn about functions,
    another very powerful tool. Functions are blocks of code that you create and name
    to perform a specific job. After you have written a function, you can use its
    name to call it from almost anywhere in your program.
  id: totrans-11117
  prefs: []
  type: TYPE_NORMAL
  zh: 了解数组和字典以及如何使用它们是几乎任何编程语言中强大的构建块。接下来，我们将学习函数，另一种非常强大的工具。函数是你创建并命名的代码块，用于执行特定任务。在你编写完一个函数后，可以通过它的名字从程序中的几乎任何地方调用它。
