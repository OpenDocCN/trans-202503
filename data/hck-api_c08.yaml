- en: '8'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '8'
- en: Attacking Authentication
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 攻击认证
- en: '![](image_fi/book_art/chapterart.png)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![](image_fi/book_art/chapterart.png)'
- en: 'When it comes to testing authentication, you’ll find that many of the flaws
    that have plagued web applications for decades have been ported over to APIs:
    bad passwords and password requirements, default credentials, verbose error messaging,
    and bad password reset processes.'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在测试认证时，你会发现许多困扰Web应用程序数十年的缺陷已经被移植到了API中：糟糕的密码和密码要求、默认凭证、冗长的错误信息以及糟糕的密码重置流程。
- en: In addition, several weaknesses are much more commonly found in APIs than traditional
    web apps. Broken API authentication comes in many forms. You might encounter a
    lack of authentication altogether, a lack of rate limiting applied to authentication
    attempts, the use of a single token or key for all requests, tokens created with
    insufficient entropy, and several JSON Web Token (JWT) configuration weaknesses.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，API中常见的一些弱点比传统的Web应用程序更为普遍。API认证漏洞有多种形式。你可能会遇到完全没有认证、没有对认证尝试进行速率限制、为所有请求使用相同的令牌或密钥、使用熵不足的令牌以及一些JSON
    Web Token（JWT）配置漏洞。
- en: This chapter will guide you through classic authentication attacks like brute-force
    attacks and password spraying, and then we’ll cover API-specific token attacks,
    such as token forgery and JWT attacks. Generally, these attacks share the common
    goal of gaining unauthorized access, whether this means going from a state of
    no access to a state of unauthorized access, obtaining access to the resources
    of other users, or going from a state of limited API access to one of privileged
    access.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将引导你了解经典的认证攻击，如暴力破解攻击和密码喷洒攻击，之后我们将讨论特定于API的令牌攻击，例如令牌伪造和JWT攻击。一般来说，这些攻击都有一个共同的目标，即获得未授权访问，无论是从无访问状态到未授权访问状态，从其他用户的资源中获得访问权限，还是从有限的API访问状态升级为特权访问状态。
- en: Classic Authentication Attacks
  id: totrans-6
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 经典认证攻击
- en: 'In Chapter 2, we covered the simplest form of authentication used in APIs:
    basic authentication. To authenticate using this method, the consumer issues a
    request containing a username and password. As we know, RESTful APIs do not maintain
    state, so if the API uses basic authentication across the API, a username and
    password would have to be issued with every request. Thus, providers typically
    use basic authentication only as part of a registration process. Then, after users
    have successfully authenticated, the provider issues an API key or token. The
    provider then checks that the username and password match the authentication information
    stored. If the credentials match, the provider issues a successful response. If
    they don’t match, the API may issue one of several responses. The provider may
    just send a generic response for all incorrect authentication attempts: “Incorrect
    username or password.” This tells us the least amount of information, but sometimes
    providers will tilt the scales toward consumer convenience and provide us with
    more useful information. The provider could specifically tell us that a username
    does not exist. Then we will have a response we can use to help us discover and
    validate usernames.'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 在第二章中，我们介绍了API中使用的最简单的认证方式：基本认证。要使用此方法进行认证，消费者会发送一个包含用户名和密码的请求。如我们所知，RESTful
    API不保持状态，因此，如果API在整个API中使用基本认证，每个请求都必须带上用户名和密码。因此，提供者通常只在注册过程中使用基本认证。然后，在用户成功认证后，提供者会发放API密钥或令牌。提供者接着会检查用户名和密码是否与存储的认证信息匹配。如果凭证匹配，提供者会返回成功响应。如果不匹配，API可能会返回几种响应之一。提供者可能会对所有错误的认证尝试发送一个通用响应：“用户名或密码错误。”这会告诉我们最少的信息，但有时提供者会倾向于方便消费者，提供更多有用的信息。提供者可能会特别告诉我们某个用户名不存在。那么我们就会得到一个可以帮助我们发现并验证用户名的响应。
- en: Password Brute-Force Attacks
  id: totrans-8
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 密码暴力破解攻击
- en: One of the more straightforward methods for gaining access to an API is performing
    a brute-force attack. Brute-forcing an API’s authentication is not very different
    from any other brute-force attack, except you’ll send the request to an API endpoint,
    the payload will often be in JSON, and the authentication values may be base64
    encoded. Brute-force attacks are loud, often time-consuming, and brutish, but
    if an API lacks security controls to prevent brute-force attacks, we should not
    shy away from using this to our advantage.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 获得 API 访问权限的一种更直接的方法是进行暴力破解攻击。暴力破解 API 的身份验证与其他暴力破解攻击没有太大区别，只不过你会将请求发送到 API
    端点，负载通常是 JSON 格式，并且身份验证值可能是 base64 编码的。暴力破解攻击通常会发出很大的噪音，耗时且粗暴，但如果 API 缺乏防止暴力破解攻击的安全控制，我们不应该避免利用这一点来获得优势。
- en: 'One of the best ways to fine-tune your brute-force attack is to generate passwords
    specific to your target. To do this, you could leverage the information revealed
    in an excessive data exposure vulnerability, like the one you found in Lab #4,
    to compile a username and password list. The excess data could reveal technical
    details about the user’s account, such as whether the user was using multifactor
    authentication, whether they had a default password, and whether the account has
    been activated. If the excess data involved information about the user, you could
    feed it to tools that can generate large, targeted password lists for brute-force
    attacks. For more information about creating targeted password lists, check out
    the Mentalist app ([https://github.com/sc0tfree/mentalist](https://github.com/sc0tfree/mentalist))
    or the Common User Passwords Profiler ([https://github.com/Mebus/cupp](https://github.com/Mebus/cupp)).'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: '微调暴力破解攻击的最佳方法之一是生成针对目标的密码。为此，你可以利用在数据泄露漏洞中揭示的信息，比如你在实验室 #4 中发现的漏洞，来编制用户名和密码列表。泄露的数据可能揭示有关用户帐户的技术细节，例如用户是否使用了多因素认证，是否使用了默认密码，以及帐户是否已激活。如果泄露的数据涉及用户信息，你可以将其输入到能够生成大型、有针对性的密码列表的工具中，以进行暴力破解攻击。有关创建针对性密码列表的更多信息，请查看
    Mentalist 应用程序（[https://github.com/sc0tfree/mentalist](https://github.com/sc0tfree/mentalist)）或常见用户密码分析工具（[https://github.com/Mebus/cupp](https://github.com/Mebus/cupp)）。'
- en: 'To actually perform the brute-force attack once you have a suitable wordlist,
    you can use tools such as Burp Suite’s brute forcer or Wfuzz, introduced in Chapter
    4. The following example uses Wfuzz with an old, well-known password list, *rockyou.txt*:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你有了合适的字典来进行暴力破解攻击，你可以使用像 Burp Suite 的暴力破解工具或第4章介绍的 Wfuzz 等工具。以下示例使用 Wfuzz
    和一个旧的、广为人知的密码列表 *rockyou.txt*：
- en: '[PRE0]'
  id: totrans-12
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The `-d` option allows you to fuzz content that is sent in the body of a POST
    request. The curly brackets that follow contain the POST request body. To discover
    the request format used in this example, I attempted to authenticate to a web
    application using a browser, and then I captured the authentication attempt and
    replicated its structure here. In this instance, the web app issues a POST request
    with the parameters `"email"` and `"password"`. The structure of this body will
    change for each API. In this example, you can see that we’ve specified a known
    email and used the `FUZZ` parameter as the password.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: '`-d` 选项允许你模糊化发送在 POST 请求体中的内容。后面的花括号包含了 POST 请求体。为了发现此示例中使用的请求格式，我尝试使用浏览器进行身份验证，然后捕获了身份验证请求并在这里复制了它的结构。在这个例子中，Web
    应用发出了包含 `"email"` 和 `"password"` 参数的 POST 请求。每个 API 的请求体结构会有所不同。在此示例中，你可以看到我们指定了一个已知的电子邮件并将
    `FUZZ` 参数用作密码。'
- en: The `--hc` option hides responses with certain response codes. This is useful
    if you often receive the same status code, word length, and character count in
    many requests. If you know what a typical failure response looks like for your
    target, there is no need to see hundreds or thousands of that same response. The
    `–hc` option helps you filter out the responses you don’t want to see.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: '`--hc` 选项用于隐藏带有特定响应代码的响应。如果你经常在许多请求中收到相同的状态代码、字长和字符数，这个选项很有用。如果你知道目标的典型失败响应是什么样的，那么就没有必要看到数百或数千个相同的响应。`–hc`
    选项可以帮助你过滤掉不想看到的响应。'
- en: In the tested instance, the typical failed request results in a 405 status code,
    but this may also differ with each API. Next, the `-H` option lets you add a header
    to the request. Some API providers may issue an HTTP 415 Unsupported Media Type
    error code if you don’t include the `Content-Type:application/json` header when
    sending JSON data in the request body.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在测试实例中，典型的失败请求会返回 405 状态码，但这在不同的 API 中可能有所不同。接下来，`-H` 选项允许你在请求中添加一个头部。如果你在发送
    JSON 数据时没有包含 `Content-Type:application/json` 头部，某些 API 提供者可能会返回 HTTP 415 不支持的媒体类型错误码。
- en: Once your request has been sent, you can review the results in the command line.
    If your `–hc` Wfuzz option has worked out, your results should be fairly easy
    to read. Otherwise, status codes in the 200s and 300s should be good indicators
    that you have successfully brute-forced credentials.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦请求发送完毕，你可以在命令行中查看结果。如果你的 `–hc` Wfuzz 选项生效，那么结果应该相对容易阅读。否则，200 到 300 范围的状态码通常表明你已经成功破解了凭证。
- en: Password Reset and Multifactor Authentication Brute-Force Attacks
  id: totrans-17
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 密码重置和多因素认证暴力破解攻击
- en: While you can apply brute-force techniques directly to the authentication requests,
    you can also use them against password reset and multifactor authentication (MFA)
    functionality. If a password reset process includes security questions and does
    not apply rate limiting to requests, we can target it in such an attack.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然你可以将暴力破解技术直接应用于认证请求，但你也可以将其用于密码重置和多因素认证（MFA）功能。如果密码重置过程包括安全问题，并且没有对请求进行速率限制，那么我们就可以在这种攻击中加以利用。
- en: Like GUI web applications, APIs often use SMS recovery codes or one-time passwords
    (OTPs) in order to verify the identity of a user who wants to reset their password.
    Additionally, a provider may deploy MFA to successful authentication attempts,
    so you’ll have to bypass that process to gain access to the account. On the backend,
    an API often implements this functionality using a service that sends a four-
    to six-digit code to the phone number or email associated with the account. If
    we’re not stopped by rate limiting, we should be able to brute-force these codes
    to gain access to the targeted account.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 与 GUI Web 应用程序类似，API 通常会使用 SMS 恢复码或一次性密码（OTP）来验证想要重置密码的用户身份。此外，提供者可能会在成功的身份验证尝试中部署
    MFA，因此你需要绕过该过程才能访问账户。在后台，API 通常会通过一个服务来实现此功能，向与账户关联的电话号码或电子邮件发送一个四到六位数的验证码。如果我们没有被速率限制阻止，我们应该能够通过暴力破解这些验证码来访问目标账户。
- en: Begin by capturing a request for the relevant process, such as a password reset
    process. In the following request, you can see that the consumer includes an OTP
    in the request body, along with the username and new password. Thus, to reset
    a user’s password, we’ll need to guess the OTP.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 首先捕获相关过程的请求，例如密码重置过程。在以下请求中，你可以看到消费者在请求体中包括了一个 OTP，以及用户名和新密码。因此，要重置用户的密码，我们需要猜测
    OTP。
- en: '[PRE1]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: In this example, we’ll leverage the brute forcer payload type in Burp Suite,
    but you could configure and run an equivalent attack using Wfuzz with brute-force
    options. Once you’ve captured a password reset request in Burp Suite, highlight
    the OTP and add the attack position markers discussed in Chapter 4 to turn the
    value into a variable. Next, select the **Payloads** tab and set the payload type
    to **brute forcer** (see [Figure 8-1](#figure8-1)).
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们将利用 Burp Suite 中的暴力破解负载类型，但你也可以使用 Wfuzz 配置并运行一个等效的攻击，使用暴力破解选项。一旦你在
    Burp Suite 中捕获到密码重置请求，突出显示 OTP 并添加第 4 章讨论的攻击位置标记，将该值转化为变量。接下来，选择 **Payloads**
    选项卡，并将负载类型设置为 **brute forcer**（参见 [图 8-1](#figure8-1)）。
- en: '![Screenshot of the Burp Suite Payloads tab with the “Payload set” field set
    to “1,” the “Payload type” field set to “Brute forcer,” the “Character set” field
    set to” 0123456789,” and the Min length and Max length fields both set to “4”](image_fi/502444c08/F08001.png)'
  id: totrans-23
  prefs: []
  type: TYPE_IMG
  zh: '![Burp Suite Payloads 选项卡截图，"Payload set" 字段设置为“1”，"Payload type" 字段设置为“Brute
    forcer”，"Character set" 字段设置为“0123456789”，Min length 和 Max length 字段都设置为“4”](image_fi/502444c08/F08001.png)'
- en: 'Figure 8-1: Configuring Burp Suite Intruder with the brute forcer payload type
    set'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8-1：配置 Burp Suite Intruder，设置暴力破解负载类型
- en: If you’ve configured your payload settings correctly, they should match those
    in [Figure 8-1](#figure8-1). In the character set field, only include numbers
    and characters used for the OTP. In its verbose error messaging, the API provider
    may indicate what values it expects. You can often test this by initiating a password
    reset of your own account and checking to see what the OTP consists of. For example,
    if the API uses a four-digit numeric code, add the numbers 0 to 9 to the character
    set. Then set the minimum and maximum length of the code to **4**.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你正确配置了负载设置，它们应该与[图 8-1](#figure8-1)中的设置匹配。在字符集字段中，只包含数字和用于一次性密码（OTP）的字符。在其详细错误信息中，API提供者可能会指明它期望的值。你通常可以通过启动你自己账户的密码重置并查看OTP的组成来测试这一点。例如，如果API使用的是四位数字验证码，那么将数字0到9添加到字符集中。然后将验证码的最小和最大长度设置为**4**。
- en: Brute-forcing the password reset code is definitely worth a try. However, many
    web applications will both enforce rate limiting and limit the number of times
    you can guess the OTP. If rate limiting is holding you back, perhaps one of the
    evasion techniques in Chapter 13 could be of some use.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 对密码重置代码进行暴力破解绝对值得一试。然而，许多Web应用会同时强制实施速率限制，并限制你猜测OTP的次数。如果速率限制阻碍了你，你可以尝试第13章中的某些规避技巧。
- en: Password Spraying
  id: totrans-27
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 密码喷射攻击
- en: Many security controls could prevent you from successfully brute-forcing an
    API’s authentication. A technique called *password spraying* can evade many of
    these controls by combining a long list of users with a short list of targeted
    passwords. Let’s say you know that an API authentication process has a lockout
    policy in place and will only allow 10 login attempts. You could craft a list
    of the nine most likely passwords (one less password than the limit) and use these
    to attempt to log in to many user accounts.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 许多安全控制措施可能会阻止你成功暴力破解API的身份验证。一种叫做*密码喷射攻击*的技巧能够通过将一个长用户列表与一个短目标密码列表相结合，避开这些控制。假设你知道某个API的身份验证过程有一个锁定策略，并且只允许10次登录尝试。你可以制作一个包含九个最可能密码的列表（比限制少一个密码），然后用这些密码尝试登录许多用户账户。
- en: When you’re password spraying, large and outdated wordlists like *rockyou.txt*
    won’t work. There are way too many unlikely passwords in such a file to have any
    success. Instead, craft a short list of likely passwords, taking into account
    the constraints of the API provider’s password policy, which you can discover
    during reconnaissance. Most password policies likely require a minimum character
    length, upper- and lowercase letters, and perhaps a number or special character.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 当你进行密码喷射攻击时，像*rockyou.txt*这样的庞大且过时的词库将不起作用。这样的文件中包含了太多不太可能的密码，无法取得任何成功。相反，你应该根据API提供者的密码策略约束（你可以在侦察过程中发现这些约束），制作一个简短的可能密码列表。大多数密码策略可能要求最小字符长度、大写字母和小写字母，可能还会要求数字或特殊字符。
- en: 'Try mixing your password-spraying list with two types of *path of small-resistance
    (POS)* passwords, or passwords that are simple enough to guess but complex enough
    to meet basic password requirements (generally a minimum of eight characters,
    a symbol, upper- and lowercase letters, and a number). The first type includes
    obvious passwords like QWER!@#$, Password1!, and the formula *Season+Year+Symbol*
    (such as Winter2021!, Spring2021?, Fall2021!, and Autumn2021?). The second type
    includes more advanced passwords that relate directly to the target, often including
    a capitalized letter, a number, a detail about the organization, and a symbol.
    Here is a short password-spraying list I might generate if I were attacking an
    endpoint for Twitter employees:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试将你的密码喷射列表与两种*低阻力路径（POS）*密码混合，或者是那些足够简单以供猜测，但又足够复杂以满足基本密码要求的密码（通常要求至少八个字符、一个符号、大小写字母和一个数字）。第一种类型包括明显的密码，如QWER!@#$、Password1!，以及公式*季节+年份+符号*（例如Winter2021!、Spring2021?、Fall2021!和Autumn2021?）。第二种类型包括更为复杂的密码，这些密码通常直接与目标相关，通常包含一个大写字母、一个数字、组织的某个细节和一个符号。如果我要攻击Twitter员工的端点，以下是我可能生成的一个简短密码喷射列表：
- en: Winter2021!
  id: totrans-31
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Winter2021!
- en: Spring2021!
  id: totrans-32
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Spring2021!
- en: QWER!@#$
  id: totrans-33
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: QWER!@#$
- en: Password1!
  id: totrans-34
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Password1!
- en: March212006!
  id: totrans-35
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: March212006!
- en: July152006!
  id: totrans-36
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: July152006!
- en: Twitter@2022
  id: totrans-37
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Twitter@2022
- en: JPD1976!
  id: totrans-38
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: JPD1976!
- en: Dorsey@2021
  id: totrans-39
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Dorsey@2021
- en: The key to password spraying is to maximize your user list. The more usernames
    you include, the higher your odds of gaining access. Build a user list during
    your reconnaissance efforts or by discovering excessive data exposure vulnerabilities.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 密码喷射攻击的关键在于最大化你的用户列表。你包含的用户名越多，获得访问权限的机会就越大。在进行侦察工作时，或者通过发现过度的数据暴露漏洞来构建用户列表。
- en: In Burp Suite’s Intruder, you can set up this attack in a similar manner to
    the standard brute-force attack, except you’ll use both a list of users and a
    list of passwords. Choose the cluster bomb attack type and set the attack positions
    around the username and password, as shown in [Figure 8-2](#figure8-2).
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Burp Suite 的 Intruder 中，你可以以类似标准暴力破解攻击的方式设置此攻击，唯一的区别是你将同时使用用户列表和密码列表。选择 cluster
    bomb 攻击类型，并将攻击位置设置在用户名和密码周围，如[图 8-2](#figure8-2)所示。
- en: '![Screenshot of the Burp Suite Payload Positions screen with the Attack type
    set to “Cluster bomb” and the email and password fields set to payload positions
    in the POST request body](image_fi/502444c08/F08002.png)'
  id: totrans-42
  prefs: []
  type: TYPE_IMG
  zh: '![Burp Suite 有效载荷位置屏幕截图，攻击类型设置为“Cluster bomb”，电子邮件和密码字段设置为 POST 请求体中的有效载荷位置。](image_fi/502444c08/F08002.png)'
- en: 'Figure 8-2: A credential-spraying attack using Intruder'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8-2：使用 Intruder 进行凭证喷射攻击的示例
- en: Notice that the first attack position is set to replace the username in front
    of *@email.com*, which you can do if you’ll only be testing for users within a
    specific email domain.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，第一个攻击位置设置为替换 *@email.com* 前的用户名，如果你只针对特定电子邮件域名的用户进行测试，可以这样做。
- en: Next, add the list of collected users as the first payload set and a short list
    of passwords as your second payload set. Once your payloads are configured as
    in [Figure 8-3](#figure8-3), you’re ready to perform a password-spraying attack.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，将收集的用户列表添加为第一个有效载荷集，将一个简短的密码列表作为第二个有效载荷集。一旦你的有效载荷如[图 8-3](#figure8-3)所示配置好，你就可以开始执行密码喷射攻击。
- en: '![Two screenshots of Burp Suite’s Payload Sets and Payload Options screens.
    The first has the “Payload set” field set to one and a list of names as the Payload
    Options. The second has the “Payload set” field set to 2 and a list of common
    passwords as the Payload Options.](image_fi/502444c08/F08003.png)'
  id: totrans-46
  prefs: []
  type: TYPE_IMG
  zh: '![Burp Suite 有效载荷集和有效载荷选项屏幕的两张截图。第一张的“有效载荷集”字段设置为 1，并且列出了一些名称作为有效载荷选项。第二张的“有效载荷集”字段设置为
    2，并列出了一些常见的密码作为有效载荷选项。](image_fi/502444c08/F08003.png)'
- en: 'Figure 8-3: Burp Suite Intruder example payloads for a cluster bomb attack'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8-3：Burp Suite Intruder 的 cluster bomb 攻击示例有效载荷
- en: 'When you’re analyzing the results, it helps if you have an idea of what a standard
    successful login looks like. If you’re unsure, search for anomalies in the lengths
    and response codes returned. Most web applications respond to successful login
    results with an HTTP status code in the 200s or 300s. In [Figure 8-4](#figure8-4),
    you can see a successful password-spraying attempt that has two anomalous features:
    a status code of 200 and a response length of 682.'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 当你分析结果时，如果你大致了解标准成功登录的样子，会有所帮助。如果不确定，可以通过检查返回的长度和响应代码中的异常来寻找线索。大多数 Web 应用程序在成功登录时返回的
    HTTP 状态代码位于 200 或 300 系列。在[图 8-4](#figure8-4)中，你可以看到一次成功的密码喷射攻击，其中有两个异常特征：状态代码为
    200，响应长度为 682。
- en: '![Screenshot of Burp Suite Intruder with a list of submitted payloads, the
    status codes received in the response, and the length of each response. Most have
    a status code of 500 and a length of 479, but one has a status code of 200 and
    a length of 682.](image_fi/502444c08/F08004.png)'
  id: totrans-49
  prefs: []
  type: TYPE_IMG
  zh: '![Burp Suite Intruder 截图，显示已提交的有效载荷列表、响应中的状态代码以及每个响应的长度。大多数的状态代码为 500，长度为 479，但有一个状态代码为
    200，长度为 682。](image_fi/502444c08/F08004.png)'
- en: 'Figure 8-4: A successful password-spraying attack using Intruder'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8-4：使用 Intruder 进行成功密码喷射攻击的示例
- en: To help spot anomalies using Intruder, you can sort the results by status code
    or response length.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 为了帮助通过 Intruder 识别异常，你可以按状态代码或响应长度对结果进行排序。
- en: Including Base64 Authentication in Brute-Force Attacks
  id: totrans-52
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 在暴力破解攻击中包含 Base64 身份验证
- en: Some APIs will base64-encode authentication payloads sent in an API request.
    There are many reasons to do this, but it’s important to know that security is
    not one of them. You can easily bypass this minor inconvenience.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 一些 API 会对 API 请求中发送的身份验证有效载荷进行 Base64 编码。这样做有很多原因，但需要知道的是，安全性并不是其中之一。你可以轻松绕过这个小小的不便。
- en: If you test an authentication attempt and notice that an API is encoding to
    base64, it is likely making a comparison to base64-encoded credentials on the
    backend. This means you should adjust your fuzzing attacks to include base64 payloads
    using Burp Suite Intruder, which can both encode and decode base64 values. For
    example, the password and email values in [Figure 8-5](#figure8-5) are base64
    encoded. You can decode them by highlighting the payload, right-clicking, and
    selecting **Base64-decode** (or the shortcut ctrl-shift-B). This will reveal the
    payload so that you can see how it is formatted.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你测试身份验证尝试并注意到一个API正在进行base64编码，它很可能是在后台将数据与base64编码的凭据进行比较。这意味着你应该调整你的模糊测试攻击，包括使用Burp
    Suite Intruder进行base64有效负载，它可以同时进行base64的编码和解码。例如，[图8-5](#figure8-5)中的密码和邮箱值是base64编码的。你可以通过高亮显示有效负载，右键单击并选择**Base64解码**（或快捷键ctrl-shift-B）来解码它们。这将揭示有效负载内容，让你可以看到它的格式。
- en: To perform, say, a password-spraying attack using base64 encoding, begin by
    selecting the attack positions. In this case, we’ll select the base64-encoded
    password from the request in [Figure 8-5](#figure8-5). Next, add the payload set;
    we’ll use the passwords listed in the previous section.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 比如，要使用base64编码执行密码喷洒攻击，首先选择攻击位置。在本例中，我们将选择[图8-5](#figure8-5)中的base64编码密码。接下来，添加有效负载集；我们将使用上一节列出的密码。
- en: Now, in order to encode each password before it is sent in a request, we must
    use a payload-processing rule. Under the Payloads tab is an option to add such
    a rule. Select **Add**▶**Encoded**▶**Base64-encode** and then click **OK**. Your
    payload-processing window should look like [Figure 8-6](#figure8-6).
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，为了在请求发送之前对每个密码进行编码，我们必须使用一个有效负载处理规则。在“有效负载”标签下有一个选项可以添加这样的规则。选择**添加**▶**编码**▶**Base64编码**，然后点击**确定**。你的有效负载处理窗口应该如下所示：[图8-6](#figure8-6)。
- en: '![Screenshot of an HTTP request in Burp Suite with a value highlighted and
    right-clicked, and “Convert selection, Base64, Base64-decode” selected in the
    menu](image_fi/502444c08/F08005.png)'
  id: totrans-57
  prefs: []
  type: TYPE_IMG
  zh: '![Burp Suite中一个HTTP请求的截图，突出显示并右键单击一个值，菜单中选择“转换选择，Base64，Base64解码”](image_fi/502444c08/F08005.png)'
- en: 'Figure 8-5: Decoding base64 using Burp Suite Intruder'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 图8-5：使用Burp Suite Intruder解码base64
- en: '![Screenshot of Burp Suite’s “Add Payload Processing Rule” menu. “Encode” and
    “Base64-encode” are selected in the drop-down menus.](image_fi/502444c08/F08006.png)'
  id: totrans-59
  prefs: []
  type: TYPE_IMG
  zh: '![Burp Suite的“添加有效负载处理规则”菜单截图。下拉菜单中选择了“编码”和“Base64编码”。](image_fi/502444c08/F08006.png)'
- en: 'Figure 8-6: Adding a payload-processing rule to Burp Suite Intruder'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 图8-6：在Burp Suite Intruder中添加有效负载处理规则
- en: Now your base64-encoded password-spraying attack is ready to launch.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你的base64编码的密码喷洒攻击已经准备好启动。
- en: Forging Tokens
  id: totrans-62
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 伪造令牌
- en: When implemented correctly, tokens can be an excellent way for APIs to authenticate
    users and authorize them to access their resources. However, if anything goes
    wrong when generating, processing, or handling tokens, they’ll become our keys
    to the kingdom.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 如果正确实现，令牌可以成为API验证用户并授权他们访问资源的优秀方法。然而，如果在生成、处理或处理令牌时出现问题，它们就会成为我们进入系统的钥匙。
- en: The problem with tokens is that they can be stolen, leaked, and forged. We’ve
    already covered how to steal and find leaked tokens in Chapter 6. In this section,
    I’ll guide you through the process of forging your own tokens when weaknesses
    are present in the token generation process. This requires first analyzing how
    predictable an API provider’s token generation process is. If we can discover
    any patterns in the tokens being provided, we may be able to forge our own or
    hijack another user’s tokens.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 令牌的问题在于它们可能被窃取、泄露或伪造。我们已经在第六章中介绍了如何窃取和查找泄露的令牌。在本节中，我将指导你如何在令牌生成过程中存在漏洞时伪造自己的令牌。这首先需要分析API提供方的令牌生成过程是否具有可预测性。如果我们能发现提供的令牌中存在任何模式，可能就能够伪造自己的令牌或劫持其他用户的令牌。
- en: APIs will often use tokens as an authorization method. A consumer may have to
    initially authenticate using a username and password combination, but then the
    provider will generate a token and give that token to the consumer to use with
    their API requests. If the token generation process is flawed, we will be able
    to analyze the tokens, hijack other user tokens, and then use them to access the
    resources and additional API functionality of the affected users.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: API通常会使用令牌作为授权方法。消费者可能首先需要使用用户名和密码组合进行身份验证，但之后，提供方会生成一个令牌并将该令牌提供给消费者，用于他们的API请求。如果令牌生成过程存在缺陷，我们就能够分析令牌，劫持其他用户的令牌，然后使用它们访问受影响用户的资源和额外的API功能。
- en: 'Burp Suite’s Sequencer provides two methods for token analysis: manually analyzing
    tokens provided in a text file and performing a live capture to automatically
    generate tokens. I will guide you through both processes.'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: Burp Suite 的 Sequencer 提供两种令牌分析方法：手动分析提供的文本文件中的令牌和执行实时捕获以自动生成令牌。我将引导你完成这两个过程。
- en: Manual Load Analysis
  id: totrans-67
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 手动加载分析
- en: To perform a manual load analysis, select the **Sequencer** module and choose
    the **Manual Load** tab. Click **Load** and provide the list of tokens you want
    to analyze. The more tokens you have in your sample, the better the results will
    be. Sequencer requires a minimum of 100 tokens to perform a basic analysis, which
    includes a *bit-level* analysis, or an automated analysis of the token converted
    to sets of bits. These sets of bits are then put through a series of tests involving
    compression, correlation, and spectral testing, as well as four tests based on
    the Federal Information Processing Standard (FIPS) 140-2 security requirements.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 要执行手动加载分析，请选择**Sequencer**模块并选择**Manual Load**标签。点击**Load**并提供要分析的令牌列表。样本中的令牌越多，结果会越好。Sequencer
    至少需要 100 个令牌才能执行基本分析，其中包括*位级*分析，或将令牌转换为比特集合后进行的自动化分析。这些比特集合会通过一系列压缩、相关性和频谱测试，同时还包括基于联邦信息处理标准（FIPS）140-2安全要求的四个测试。
- en: A full analysis will also include *character-level* analysis, a series of tests
    performed on each character in the given position in the original form of the
    tokens. The tokens are then put through a character count analysis and a character
    transition analysis, two tests that analyze how characters are distributed within
    a token and the differences between tokens. To perform a full analysis, Sequencer
    could require thousands of tokens, depending on the size and complexity of each
    individual token.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 完整的分析还包括*字符级*分析，这是在原始令牌形式中对每个字符在特定位置进行的一系列测试。然后，令牌会经过字符计数分析和字符过渡分析，这两个测试分别分析字符在令牌中的分布以及令牌之间的差异。要执行完整分析，Sequencer
    可能需要成千上万的令牌，具体取决于每个令牌的大小和复杂性。
- en: Once your tokens are loaded, you should see the total number of tokens loaded,
    the shortest token, and the longest token, as shown in [Figure 8-7](#figure8-7).
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 令牌加载完成后，你应该能看到加载的令牌总数、最短的令牌和最长的令牌，如[图 8-7](#figure8-7)所示。
- en: '![Screenshot of Burp Suite Sequencer with token values loaded to the Manual
    Load field.](image_fi/502444c08/F08007.png)'
  id: totrans-71
  prefs: []
  type: TYPE_IMG
  zh: '![Burp Suite Sequencer 截图，显示加载到手动加载字段中的令牌值。](image_fi/502444c08/F08007.png)'
- en: 'Figure 8-7: Manually loaded tokens in Burp Suite Sequencer'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8-7：Burp Suite Sequencer 中手动加载的令牌
- en: Now you can begin the analysis by clicking **Analyze Now**. Burp Suite should
    then generate a report (see [Figure 8-8](#figure8-8)).
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你可以点击**Analyze Now**开始分析。Burp Suite 会生成一份报告（见[图 8-8](#figure8-8)）。
- en: '![Screenshot of the Burp Suite Sequencer Summary tab with “Overall result”
    and “Effective Entropy” sections describing the results of the analysis](image_fi/502444c08/F08008.png)'
  id: totrans-74
  prefs: []
  type: TYPE_IMG
  zh: '![Burp Suite Sequencer 摘要标签截图，显示“总体结果”和“有效熵”部分，描述分析结果](image_fi/502444c08/F08008.png)'
- en: 'Figure 8-8: The Summary tab of the token analysis report provided by Sequencer'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8-8：Sequencer 提供的令牌分析报告的摘要标签
- en: The token analysis report begins with a summary of the findings. The overall
    results include the quality of randomness within the token sample. In [Figure
    8-8](#figure8-8), you can see that the quality of randomness was extremely poor,
    indicating that we’ll likely be able to brute-force other existing tokens.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 令牌分析报告以结果摘要开始。总体结果包括令牌样本中随机性的质量。在[图 8-8](#figure8-8)中，你可以看到随机性质量极差，表明我们很可能能够通过暴力破解其他现有的令牌。
- en: To minimize the effort required to brute-force tokens, we’ll want to determine
    if there are parts of the token that do not change and other parts that often
    change. Use the character position analysis to determine which characters should
    be brute-forced (see [Figure 8-9](#figure8-9)). You can find this feature under
    Character Setwithin the Character-Level Analysis tab.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 为了最小化暴力破解令牌所需的工作量，我们希望确定令牌中哪些部分不变，哪些部分经常变化。使用字符位置分析来确定哪些字符应进行暴力破解（见[图 8-9](#figure8-9)）。你可以在字符级分析标签下的字符集选项中找到此功能。
- en: As you can see, the token character positions do not change all that much, with
    the exception of the final three characters; the string `Ab4dt0k3n` remains the
    same throughout the sampling. Now we know we should perform a brute force of only
    the final three characters and leave the remainder of the token untouched.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，令牌的字符位置变化不大，除了最后三个字符；字符串`Ab4dt0k3n`在整个采样过程中保持不变。现在我们知道应该对最后三个字符进行暴力破解，而不触动令牌的其余部分。
- en: '![Screenshot of the Burp Suite Sequencer “Character Set” menu. Shows a chart
    of the size of the character set used in each position. Most positions have a
    character set smaller than 5, but the 10th position has more than 25 characters
    in its character set.](image_fi/502444c08/F08009.png)'
  id: totrans-79
  prefs: []
  type: TYPE_IMG
  zh: '![Burp Suite Sequencer “字符集”菜单的截图。显示了每个位置使用的字符集大小的图表。大多数位置的字符集小于5，但第10个位置的字符集包含超过25个字符。](image_fi/502444c08/F08009.png)'
- en: 'Figure 8-9: The character position chart found within Sequencer’s character-level
    analysis'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 图8-9：Sequencer的字符级分析中找到的字符位置图表
- en: Live Token Capture Analysis
  id: totrans-81
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 实时令牌捕获分析
- en: Burp Suite’s Sequencer can automatically ask an API provider to generate 20,000
    tokens for analysis. To do this, we simply intercept the provider’s token generation
    process and then configure Sequencer. Burp Suite will repeat the token generation
    process up to 20,000 times to analyze the tokens for similarities.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: Burp Suite的Sequencer可以自动请求API提供者生成20,000个令牌进行分析。为此，我们只需拦截提供者的令牌生成过程，然后配置Sequencer。Burp
    Suite将重复令牌生成过程，最多达到20,000次，以分析令牌之间的相似性。
- en: In Burp Suite, intercept the request that initiates the token generation process.
    Select **Action** (or right-click the request) and then forward it to Sequencer.
    Within Sequencer, make sure you have the live capture tab selected, and under
    **Token Location Within Response**, select the **Configure for the Custom Location**
    option. As shown in [Figure 8-10](#figure8-10), highlight the generated token
    and click **OK**.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 在Burp Suite中，拦截启动令牌生成过程的请求。选择**操作**（或右键点击请求），然后将其转发到Sequencer。在Sequencer中，确保选中了实时捕获标签，然后在**响应中的令牌位置**下，选择**为自定义位置配置**选项。如[图8-10](#figure8-10)所示，选中生成的令牌并点击**确定**。
- en: Select **Start Live Capture**. Burp Sequencer will now begin capturing tokens
    for analysis. If you select the Auto analyze checkbox, Sequencer will show the
    effective entropy results at different milestones.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 选择**开始实时捕获**。Burp Sequencer现在将开始捕获令牌进行分析。如果你选中“自动分析”复选框，Sequencer将在不同的里程碑处显示有效的熵结果。
- en: In addition to performing an entropy analysis, Burp Suite will provide you with
    a large collection of tokens, which could be useful for evading security controls
    (a topic we explore in Chapter 13). If an API doesn’t invalidate the tokens once
    new ones are created and the security controls use tokens as the method of identity,
    you now have up to 20,000 identities to help you avoid detection.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 除了执行熵分析，Burp Suite还会为你提供大量的令牌，这些令牌在绕过安全控制时可能会非常有用（我们在第13章中探讨这一话题）。如果某个API在创建新令牌后没有使旧令牌失效，并且安全控制使用令牌作为身份验证方法，那么你现在就有最多20,000个身份，可以帮助你避免被检测到。
- en: If there are token character positions with low entropy, you can attempt a brute-force
    attack against those character positions. Reviewing tokens with low entropy could
    reveal certain patterns you could take advantage of. For example, if you noticed
    that characters in certain positions only contained lowercase letters, or a certain
    range of numbers, you’ll be able to enhance your brute-force attacks by minimizing
    the number of request attempts.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 如果某些令牌字符位置的熵较低，你可以尝试对这些字符位置进行暴力攻击。审查熵低的令牌可能会揭示出你可以利用的某些模式。例如，如果你发现某些位置的字符只包含小写字母，或某个范围内的数字，你将能够通过减少请求尝试的次数来增强暴力破解攻击。
- en: '![Screenshot of Burp Suite Sequencer’s “Define custom token location” menu.
    “Define start and end” is checked, an expression is set for both the “Start after
    expression” and “End at delimiter” fields, and a token value is shown highlighted
    in an HTTP response.](image_fi/502444c08/F08010.png)'
  id: totrans-87
  prefs: []
  type: TYPE_IMG
  zh: '![Burp Suite Sequencer的“定义自定义令牌位置”菜单截图。选中了“定义起始和结束”，为“起始位置后表达式”和“结束位置分隔符”字段设置了表达式，并在HTTP响应中显示了高亮的令牌值。](image_fi/502444c08/F08010.png)'
- en: 'Figure 8-10: The API provider’s token response selected for analysis'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 图8-10：选中的API提供者令牌响应进行分析
- en: Brute-Forcing Predictable Tokens
  id: totrans-89
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 暴力破解可预测的令牌
- en: Let’s return to the bad tokens discovered during manual load analysis (whose
    final three characters are the only ones that change) and brute-force possible
    letter and number combinations to find other valid tokens. Once we’ve discovered
    valid tokens, we can test our access to the API and find out what we’re authorized
    to do.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回到手动负载分析中发现的坏令牌（其最后三个字符是唯一变化的部分），并对可能的字母和数字组合进行暴力破解，以找到其他有效的令牌。一旦发现有效令牌，我们可以测试对
    API 的访问并找出我们被授权执行的操作。
- en: When you’re brute-forcing through combinations of numbers and letters, it is
    best to minimize the number of variables. The character-level analysis has already
    informed us that the first nine characters of the token `Ab4dt0k3n` remain static.
    The final three characters are the variables, and based on the sample, we can
    see that they follow a pattern of *letter1* + *letter2* + *number*. Moreover,
    a sample of the tokens tells us that that *letter1* only ever consists of letters
    between *a* and *d*. Observations like this will help minimize the total amount
    of brute force required.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 当你通过字母和数字的组合进行暴力破解时，最好尽量减少变量的数量。字符级分析已经告诉我们，令牌`Ab4dt0k3n`的前九个字符保持静态。最后三个字符是变量，根据样本，我们可以看到它们遵循*字母1*
    + *字母2* + *数字*的模式。此外，令牌样本告诉我们，*字母1*仅由*a*到*d*之间的字母组成。像这样的观察将帮助我们减少所需的暴力破解总量。
- en: Use Burp Suite Intruder or Wfuzz to brute-force the weak token. In Burp Suite,
    capture a request to an API endpoint that requires a token. In [Figure 8-11](#figure8-11),
    we use a GET request to the */identity/api/v2/user/dashboard* endpoint and include
    the token as a header. Send the captured request to Intruder, and under the Intruder
    Payload Positions tab, select the attack positions.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 Burp Suite Intruder 或 Wfuzz 对弱令牌进行暴力破解。在 Burp Suite 中，捕获一个需要令牌的 API 端点请求。在[图
    8-11](#figure8-11)中，我们使用对 */identity/api/v2/user/dashboard* 端点的 GET 请求，并将令牌作为头信息。将捕获的请求发送到
    Intruder，并在 Intruder 有效载荷位置选项卡下选择攻击位置。
- en: '![The Burp Suite Payload Positions menu, with the attack type set to “Cluster
    bomb” and the last three characters of the token each set to a payload position](image_fi/502444c08/F08011.png)'
  id: totrans-93
  prefs: []
  type: TYPE_IMG
  zh: '![Burp Suite 有效载荷位置菜单，攻击类型设置为“Cluster bomb”，令牌的最后三个字符每个都设置为一个有效载荷位置](image_fi/502444c08/F08011.png)'
- en: 'Figure 8-11: A cluster bomb attack in Burp Suite Intruder'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8-11：Burp Suite Intruder 中的 Cluster Bomb 攻击
- en: 'Since we’re brute-forcing the final three characters only, create three attack
    positions: one for the third character from the end, one for the second character
    from the end, and one for the final character. Update the attack type to **cluster
    bomb** so Intruder will iterate through each possible combination. Next, configure
    the payloads, as shown in [Figure 8-12](#figure8-12).'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们仅暴力破解最后三个字符，因此创建三个攻击位置：一个用于倒数第三个字符，一个用于倒数第二个字符，一个用于最后一个字符。将攻击类型更新为**cluster
    bomb**，这样 Intruder 就会遍历每个可能的组合。接下来，配置有效载荷，如[图 8-12](#figure8-12)所示。
- en: '![Screenshot of the Burp Suite Payloads tab with “Payload set” set to “1,”
    “Payload type” set to “Brute forcer,” “Character set” set to “abcd,” and the “Min
    length” and “Max length” fields both set to “1”](image_fi/502444c08/F08012.png)'
  id: totrans-96
  prefs: []
  type: TYPE_IMG
  zh: '![Burp Suite 有效载荷选项卡的截图，设置为“Payload set”为“1”，“Payload type”为“Brute forcer”，“Character
    set”为“abcd”，“Min length”和“Max length”字段都设置为“1”](image_fi/502444c08/F08012.png)'
- en: 'Figure 8-12: The payloads tab in Burp Suite’s Intruder'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8-12：Burp Suite 的 Intruder 中的有效载荷选项卡
- en: Select the **Payload Set** number, which represents a specific attack position,
    and set the payload type to **brute forcer**. In the character set field, include
    all numbers and letters to be tested in that position. Because the first two payloads
    are letters, we’ll want to try all letters from *a* to *d*. For payload set 3,
    the character set should include the digits 0 through 9\. Set both the minimum
    and maximum length to **1**, as each attack position is one character long. Start
    the attack, and Burp Suite will send all 160 token possibilities in requests to
    the endpoint.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 选择**Payload Set**编号，它代表特定的攻击位置，并将有效载荷类型设置为**brute forcer**。在字符集字段中，包含要在该位置测试的所有数字和字母。由于前两个有效载荷是字母，我们将尝试从*a*到*d*的所有字母。对于有效载荷集
    3，字符集应包括数字 0 到 9。将最小长度和最大长度都设置为**1**，因为每个攻击位置只有一个字符。启动攻击后，Burp Suite 将发送所有 160
    种令牌可能性请求到该端点。
- en: 'Burp Suite CE throttles Intruder requests. As a faster, free alternative, you
    may want to use Wfuzz, like so:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: Burp Suite CE 限制了 Intruder 请求的速度。作为更快且免费的替代方案，你可能希望使用 Wfuzz，方法如下：
- en: '[PRE2]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Include a header token in your request using `-H`. To specify three payload
    positions, label the first as `FUZZ`, the second as `FUZ2Z`, and the third as
    `FUZ3Z`. Following `-z`, list the payloads. We use `-z list,a-b-c-d` to cycle
    through the letters *a* to *d* for the first two payload positions, and we use
    `-z range,0-9` to cycle through the numbers in the final payload position.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 在请求中使用`-H`包含头部令牌。要指定三个有效载荷位置，将第一个标记为`FUZZ`，第二个标记为`FUZ2Z`，第三个标记为`FUZ3Z`。在`-z`后列出有效载荷。我们使用`-z
    list,a-b-c-d`来循环遍历前两个有效载荷位置的字母*a*到*d*，并使用`-z range,0-9`来循环遍历最后一个有效载荷位置的数字。
- en: Armed with a list of valid tokens, leverage them in API requests to find out
    more about what privileges they have. If you have a collection of requests in
    Postman, try simply updating the token variable to a captured one and use the
    Postman Runner to quickly test all the requests in the collection. That should
    give you a fairly good idea of a given token’s capabilities.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 拥有有效令牌的列表后，可以在API请求中利用它们，以了解它们所具备的权限。如果你有Postman中的一组请求，可以尝试简单地将令牌变量更新为捕获到的令牌，并使用Postman
    Runner快速测试集合中的所有请求。这应该能帮助你大致了解给定令牌的能力。
- en: JSON Web Token Abuse
  id: totrans-103
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: JSON Web Token滥用
- en: I introduced JSON Web Tokens (JWTs) in Chapter 2. They’re one of the more prevalent
    API token types because they operate across a wide variety of programming languages,
    including Python, Java, Node.js, and Ruby. While the tactics described in the
    last section could work against JWTs as well, these tokens can be vulnerable to
    several additional attacks. This section will guide you through a few attacks
    you can use to test and break poorly implemented JWTs. These attacks could grant
    you basic unauthorized access or even administrative access to an API.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 我在第二章中介绍了JSON Web Token（JWT）。它们是较为常见的API令牌类型之一，因为它们可以在多种编程语言中使用，包括Python、Java、Node.js和Ruby。虽然上一节描述的策略同样适用于JWT，但这些令牌可能容易受到几种额外的攻击。本节将指导你进行一些可以用来测试和攻破实现不当的JWT的攻击。这些攻击可能会让你获得基本的未经授权的访问权限，甚至是API的管理员权限。
- en: If you’ve captured another user’s JWT, you can try sending it to the provider
    and pass it off as your own. There is a chance that the token is still valid and
    you can gain access to the API as the user specified in the payload. More commonly,
    though, you’ll register with an API and the provider will respond with a JWT.
    Once you have been issued a JWT, you will need to include it in all subsequent
    requests. If you are using a browser, this process will happen automatically.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你捕获了另一个用户的JWT，可以尝试将其发送给提供方，并冒充为你自己的令牌。令牌仍然有效的可能性是存在的，你可以像有效载荷中指定的用户一样访问API。不过，更常见的是，你会在API注册后，提供方会响应一个JWT。一旦你获得了JWT，你将需要在所有后续请求中包括它。如果你使用浏览器，这个过程会自动发生。
- en: Recognizing and Analyzing JWTs
  id: totrans-106
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 识别与分析JWT
- en: 'You should be able to distinguish JWTs from other tokens because they consist
    of three parts separated by periods: the header, payload, and signature. As you
    can see in the following JWT, the header and payload will normally begin with
    `ey`:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该能够区分JWT与其他令牌，因为它们由三个由点分隔的部分组成：头部、有效载荷和签名。如以下JWT所示，头部和有效载荷通常以`ey`开头：
- en: '[PRE3]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The first step to attacking a JWT is to decode and analyze it. If you discovered
    exposed JWTs during reconnaissance, stick them into a decoder tool to see if the
    JWT payload contains any useful information, such as username and user ID. You
    might also get lucky and obtain a JWT that contains username and password combinations.
    In Burp Suite’s Decoder, paste the JWT into the top window, select **Decode As**,
    and choose the **Base64** option (see [Figure 8-13](#figure8-13)).
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 攻击JWT的第一步是解码并分析它。如果在侦察过程中发现了暴露的JWT，可以将其粘贴到解码工具中，查看JWT的有效载荷是否包含任何有用的信息，例如用户名和用户ID。你可能会运气好，获得一个包含用户名和密码组合的JWT。在Burp
    Suite的解码器中，将JWT粘贴到上方窗口，选择**Decode As**，然后选择**Base64**选项（见[图8-13](#figure8-13)）。
- en: '![Screenshot of the Burp Suite Decoder with a long string decoded to a series
    of header fields](image_fi/502444c08/F08013.png)'
  id: totrans-110
  prefs: []
  type: TYPE_IMG
  zh: '![Burp Suite解码器的截图，长字符串被解码为一系列头部字段](image_fi/502444c08/F08013.png)'
- en: 'Figure 8-13: Using Burp Suite Decoder to decode a JWT'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 图8-13：使用Burp Suite解码器解码JWT
- en: 'The *header* is a base64-encoded value that includes information about the
    type of token and hashing algorithm used for signing. A decoded header will look
    like the following:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: '*头部*是一个Base64编码的值，包含关于令牌类型和签名所用的哈希算法的信息。解码后的头部将如下所示：'
- en: '[PRE4]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: In this example, the hashing algorithm is HMAC using SHA256\. HMAC is primarily
    used to provide integrity checks similar to digital signatures. SHA256 is a hashing
    encryption with function developed by the NSA and released in 2001\. Another common
    hashing algorithm you might see is RS256, or RSA using SHA256, an asymmetric hashing
    algorithm. For additional information, check out the Microsoft API documentation
    on cryptography at [https://docs.microsoft.com/en-us/dotnet/api/system.security.cryptography](https://docs.microsoft.com/en-us/dotnet/api/system.security.cryptography).
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 在此示例中，哈希算法是使用SHA256的HMAC。HMAC主要用于提供类似数字签名的完整性检查。SHA256是一种由NSA开发并于2001年发布的哈希加密函数。你可能还会看到另一种常见的哈希算法RS256，或者RSA使用SHA256，它是一种非对称哈希算法。如需更多信息，请查看微软API文档中的加密部分：[https://docs.microsoft.com/en-us/dotnet/api/system.security.cryptography](https://docs.microsoft.com/en-us/dotnet/api/system.security.cryptography)。
- en: When a JWT uses a symmetric key system, both the consumer and provider will
    need to have a single key. When a JWT uses an asymmetric key system, the provider
    and consumer will use two different keys. Understanding the difference between
    symmetric and asymmetric encryption will give you a boost when performing a JWT
    algorithm bypass attack, found later in this chapter.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 当JWT使用对称密钥系统时，消费者和提供者都需要拥有相同的密钥。而当JWT使用非对称密钥系统时，提供者和消费者将使用两个不同的密钥。理解对称和非对称加密的区别，将在执行JWT算法绕过攻击时给你带来帮助，该攻击将在本章后面介绍。
- en: If the algorithm value is `"none"`, the token has not been signed with any hashing
    algorithm. We will return to how we can take advantage of JWTs without a hashing
    algorithm later in this chapter.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 如果算法值是`"none"`，则令牌没有使用任何哈希算法签名。稍后在本章中，我们将回到如何利用没有哈希算法的JWT。
- en: 'The *payload*is the data included within the token. The fields within the payload
    differ per API but typically contain information used for authorization, such
    as a username, user ID, password, email address, date of token creation (often
    called IAT), and privilege level. A decoded payload should look like the following:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: '*负载*是令牌中包含的数据。负载中的字段根据API的不同而有所不同，但通常包含用于授权的信息，例如用户名、用户ID、密码、电子邮件地址、令牌创建日期（通常称为IAT）和权限级别。解码后的负载应如下所示：'
- en: '[PRE5]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Finally,the*signature* is the output of HMAC used for token validation and generated
    with the algorithm specified in the header. To create the signature, the API base64-encodes
    the header and payload and then applies the hashing algorithm and a secret. The
    secret can be in the form of a password or a secret string, such as a 256-bit
    key. Without knowledge of the secret, the payload of the JWT will remain encoded.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，*签名*是用于令牌验证的HMAC输出，并且是通过头部指定的算法生成的。为了创建签名，API将头部和负载进行base64编码，然后应用哈希算法和一个密钥。密钥可以是密码或密钥串，例如256位密钥。如果没有密钥，JWT的负载将保持编码状态。
- en: 'A signature using HS256 will look like the following:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 使用HS256的签名将如下所示：
- en: '[PRE6]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'To help you analyze JWTs, leverage the JSON Web Token Toolkit by using the
    following command:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 为了帮助你分析JWT，可以通过以下命令使用JSON Web Token工具包：
- en: '[PRE7]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: As you can see, `jwt_tool` makes the header and payload values nice and clear.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，`jwt_tool`使得头部和负载值变得清晰明了。
- en: 'Additionally, `jwt_tool` has a “Playbook Scan” that can be used to target a
    web application and scan for common JWT vulnerabilities. You can run this scan
    by using the following:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，`jwt_tool`还有一个“Playbook扫描”，可以用来定位Web应用程序并扫描常见的JWT漏洞。你可以通过以下命令运行此扫描：
- en: '[PRE8]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: To use this command, you’ll need to know what you should expect as the JWT header.
    When you have this information, replace `"Header"`with the name of the header
    and `"JWT_Token"` with the actual token value.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用此命令，你需要了解JWT头部应该是什么。当你掌握这些信息时，将`"Header"`替换为头部的名称，`"JWT_Token"`替换为实际的令牌值。
- en: The None Attack
  id: totrans-128
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 无签名攻击
- en: 'If you ever come across a JWT using `"none"` as its algorithm, you’ve found
    an easy win. After decoding the token, you should be able to clearly see the header,
    payload, and signature. From here, you can alter the information contained in
    the payload to be whatever you’d like. For example, you could change the username
    to something likely used by the provider’s admin account (like root, admin, administrator,
    test, or adm), as shown here:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你遇到一个使用`"none"`作为算法的JWT，那你就发现了一个轻松的漏洞。解码令牌后，你应该能清楚地看到头部、负载和签名。从这里，你可以修改负载中包含的信息，任意更改。例如，你可以将用户名更改为可能是提供者管理员账户（如root、admin、administrator、test或adm）使用的名称，如下所示：
- en: '[PRE9]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Once you’ve edited the payload, use Burp Suite’s Decoder to encode the payload
    with base64; then insert it into the JWT. Importantly, since the algorithm is
    set to `"none"`, any signature that was present can be removed. In other words,
    you can remove everything following the third period in the JWT. Send the JWT
    to the provider in a request and check whether you’ve gained unauthorized access
    to the API.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你编辑了有效载荷，使用Burp Suite的Decoder对有效载荷进行base64编码；然后将其插入到JWT中。重要的是，由于算法设置为`"none"`，任何存在的签名都可以被移除。换句话说，你可以移除JWT中第三个句点后的所有内容。将JWT发送给提供者并检查你是否获得了对API的未经授权的访问。
- en: The Algorithm Switch Attack
  id: totrans-132
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 算法切换攻击
- en: There is a chance the API provider isn’t checking the JWTs properly. If this
    is the case, we may be able to trick a provider into accepting a JWT with an altered
    algorithm.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 也有可能API提供者没有正确检查JWT。如果是这种情况，我们可能能够欺骗提供者接受一个更改了算法的JWT。
- en: 'One of the first things you should attempt is sending a JWT without including
    the signature. This can be done by erasing the signature altogether and leaving
    the last period in place, like this:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 你首先应该尝试的事情之一是发送没有包含签名的JWT。可以通过完全删除签名并保留最后一个句点来实现，如下所示：
- en: '[PRE10]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: If this isn’t successful, attempt to alter the algorithm header field to `"none"`.
    Decode the JWT, updating the `"alg"` value to `"none"`, base64-encode the header,
    and send it to the provider. If successful, pivot to the None attack.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 如果这不成功，尝试将算法头字段更改为`"none"`。解码JWT，更新`"alg"`值为`"none"`，然后对头部进行base64编码，并将其发送给提供者。如果成功，转到None攻击。
- en: '[PRE11]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'You can use JWT_Tool to create a variety of tokens with the algorithm set to
    `"none"`:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用JWT_Tool创建各种令牌，算法设置为`"none"`：
- en: '[PRE12]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Using this command will automatically create several JWTs that have different
    forms of “no algorithm” applied.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 使用此命令将自动创建多个JWT，它们应用了不同形式的“无算法”。
- en: A more likely scenario than the provider accepting no algorithm is that they
    accept multiple algorithms. For example, if the provider uses RS256 but doesn’t
    limit the acceptable algorithm values, we could alter the algorithm to HS256\.
    This is useful, as RS256 is an asymmetric encryption scheme, meaning we need both
    the provider’s private key and a public key in order to accurately hash the JWT
    signature. Meanwhile, HS256 is symmetric encryption, so only one key is used for
    both the signature and verification of the token. If you can discover the provider’s
    RS256 public key and then switch the algorithm from RS256 to HS256, there is a
    chance you may be able to leverage the RS256 public key as the HS256 key.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 比提供者接受没有算法的情况更可能的场景是他们接受多种算法。例如，如果提供者使用RS256，但没有限制可接受的算法值，我们可以将算法更改为HS256。这个方法很有用，因为RS256是非对称加密方案，这意味着我们需要提供者的私钥和公钥来准确地对JWT签名进行哈希。而HS256是对称加密，所以签名和令牌验证使用同一个密钥。如果你能发现提供者的RS256公钥，然后将算法从RS256切换为HS256，可能有机会将RS256公钥作为HS256密钥来利用。
- en: The JWT_Tool can make this attack a bit easier. It uses the format `jwt_tool
    <JWT_Token> -X k -pk public-key.pem`, as shown next. You will need to save the
    captured public key as a file on your attacking machine.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: JWT_Tool可以让这个攻击变得稍微简单一些。它使用以下格式`jwt_tool <JWT_Token> -X k -pk public-key.pem`，如下面所示。你需要将捕获的公钥保存为文件，存储在你的攻击机器上。
- en: '[PRE13]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Once you run the command, JWT_Tool will provide you with a new token to use
    against the API provider. If the provider is vulnerable, you’ll be able to hijack
    other tokens, since you now have the key required to sign tokens. Try repeating
    the process, this time creating a new token based on other API users, especially
    administrative ones.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你运行了命令，JWT_Tool将提供一个新的令牌，可以用于对抗API提供者。如果提供者存在漏洞，你将能够劫持其他令牌，因为你现在拥有签名令牌所需的密钥。尝试重复这个过程，这次基于其他API用户，尤其是管理员用户创建一个新令牌。
- en: The JWT Crack Attack
  id: totrans-145
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: JWT破解攻击
- en: The JWT Crack attack attempts to crack the secret used for the JWT signature
    hash, giving us full control over the process of creating our own valid JWTs.
    Hash-cracking attacks like this take place offline and do not interact with the
    provider. Therefore, we do not need to worry about causing havoc by sending millions
    of requests to an API provider.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: JWT破解攻击试图破解JWT签名哈希使用的密钥，从而让我们完全控制创建自己有效JWT的过程。像这样的哈希破解攻击是离线进行的，不会与提供者进行交互。因此，我们不需要担心通过向API提供者发送数百万请求来造成混乱。
- en: You can use JWT_Tool or a tool like Hashcat to crack JWT secrets. You’ll feed
    your hash cracker a list of words. The hash cracker will then hash those words
    and compare the values to the original hashed signature to determine if one of
    those words was used as the hash secret. If you’re performing a long-term brute-force
    attack of every character possibility, you may want to use the dedicated GPUs
    that power Hashcat instead of JWT_Tool. That being said, JWT_Tool can still test
    12 million passwords in under a minute.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用JWT_Tool或像Hashcat这样的工具来破解JWT密钥。你将向哈希破解工具输入一个单词列表，哈希破解工具会将这些单词进行哈希处理，并将结果与原始哈希签名进行比较，以确定这些单词中是否有被用作哈希密钥。如果你正在进行长期的暴力破解，尝试所有字符的可能性，可能需要使用Hashcat所依赖的专用GPU，而不是JWT_Tool。不过，JWT_Tool仍然可以在不到一分钟的时间内测试1200万个密码。
- en: 'To perform a JWT Crack attack using JWT_Tool, use the following command:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 使用JWT_Tool进行JWT破解攻击时，请使用以下命令：
- en: '[PRE14]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The `-C` option indicates that you’ll be conducting a hash crack attack and
    the `-d` option specifies the dictionary or wordlist you’ll be using against the
    hash. In this example, the name of my dictionary is *wordlist.txt*, but you can
    specify the directory and name of whatever wordlist you would like to use. JWT_Tool
    will either return “CORRECT key!” for each value in the dictionary or indicate
    an unsuccessful attempt with “key not found in dictionary.”
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: '`-C`选项表示你将进行哈希破解攻击，`-d`选项指定你将用于破解哈希的字典或单词列表。在这个例子中，我的字典名为*wordlist.txt*，但你可以指定你想要使用的任何字典的目录和名称。JWT_Tool将针对字典中的每个值返回“CORRECT
    key!”或者以“key not found in dictionary”表示破解失败。'
- en: Summary
  id: totrans-151
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 总结
- en: This chapter covered various methods of hacking API authentication, exploiting
    tokens, and attacking JSON Web Tokens specifically. When present, authentication
    is usually an API’s first defense mechanism, so if your authentication attacks
    are successful, your unauthorized access can become a foothold for additional
    attacks.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 本章介绍了各种破解API认证、利用令牌以及专门攻击JSON Web Tokens的方法。当认证机制存在时，通常是API的首要防御机制，因此如果你的认证攻击成功，未经授权的访问就能成为进一步攻击的立足点。
- en: 'Lab #5: Cracking a crAPI JWT Signature'
  id: totrans-153
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '实验 #5：破解crAPI JWT签名'
- en: 'Return to the crAPI authentication page to try your hand at attacking the authentication
    process. We know that this authentication process has three parts: account registration,
    password reset functionality, and the login operation. All three of these should
    be thoroughly tested. In this lab, we’ll focus on attacking the token provided
    after a successful authentication attempt.'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 返回到crAPI认证页面，尝试攻击认证过程。我们知道，这个认证过程分为三个部分：账户注册、密码重置功能和登录操作。所有这三部分都应该经过充分测试。在本实验中，我们将重点攻击成功认证后提供的令牌。
- en: If you remember your crAPI login information, go ahead and log in. (Otherwise,
    sign up for a new account.) Make sure you have Burp Suite open and FoxyProxy set
    to proxy traffic to Burp so you can intercept the login request. Then forward
    the intercepted request to the crAPI provider. If you’ve entered in your email
    and password correctly, you should receive an HTTP 200 response and a Bearer token.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你记得你的crAPI登录信息，可以直接登录。（如果记不得，可以注册一个新账户。）确保Burp Suite已打开，且FoxyProxy已设置为将流量代理到Burp，这样你就可以拦截登录请求。然后将拦截到的请求转发给crAPI提供商。如果你正确输入了电子邮件和密码，应该会收到HTTP
    200响应和一个Bearer令牌。
- en: 'Hopefully, you now notice something special about the Bearer token. That’s
    right: it is broken down into three parts separated by periods, and the first
    two parts begin with `ey`. We have ourselves a JSON Web Token! Let’s begin by
    analyzing the JWT using a site like [https://jwt.io](https://jwt.io) or JWT_Tool.
    For visual purposes, [Figure 8-14](#figure8-14) shows the token in the JWT.io
    debugger.'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 希望你现在已经注意到Bearer令牌的特别之处。没错，它被分为三个部分，且由句点分隔，前两部分都以`ey`开头。我们有了一个JSON Web令牌！让我们开始使用像[https://jwt.io](https://jwt.io)或JWT_Tool之类的站点来分析JWT。为了方便视觉展示，[图8-14](#figure8-14)展示了JWT.io调试器中的令牌。
- en: '![Screenshot of jwt.io with a long string in the “Encoded” field and each section
    of the JWT decoded in the “Decoded” field](image_fi/502444c08/F08014.png)'
  id: totrans-157
  prefs: []
  type: TYPE_IMG
  zh: '![jwt.io截图，"Encoded"字段中有一个长字符串，每个JWT部分在"Decoded"字段中被解码](image_fi/502444c08/F08014.png)'
- en: 'Figure 8-14: A captured JWT being analyzed in JWT.io’s debugger'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 图8-14：在JWT.io调试器中分析捕获到的JWT
- en: 'As you can see, the JWT header tells us that the algorithm is set to HS512,
    an even stronger hash algorithm than those covered earlier. Also, the payload
    contains a `"sub"` value with our email. The payload also contains two values
    used for token expiration: `iat` and `exp`. Finally, the signature confirms that
    HMAC+SHA512 is in use and that a secret key is required to sign the JWT.'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，JWT 头部告诉我们算法设置为 HS512，这是一种比之前介绍的更强大的哈希算法。此外，载荷包含一个 `"sub"` 值，其中有我们的电子邮件。载荷还包含两个用于令牌过期的值：`iat`
    和 `exp`。最后，签名确认正在使用 HMAC+SHA512，并且需要一个密钥来签署 JWT。
- en: A natural next step would be to conduct None attacks to try to bypass the hashing
    algorithm. I will leave that for you to explore on your own. We won’t attempt
    any other algorithm switch attack, as we’re already attacking a symmetric key
    encryption system, so switching the algorithm type won’t benefit us here. That
    leaves us with performing JWT Crack attacks.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来的自然步骤是进行 None 攻击，尝试绕过哈希算法。我会留给你自己探索这部分内容。我们不会尝试其他算法切换攻击，因为我们已经在攻击一个对称密钥加密系统，因此切换算法类型在这里不会带来好处。这就剩下执行
    JWT Crack 攻击了。
- en: 'To perform a Crack attack against your captured token, copy the token from
    the intercepted request. Open a terminal and run JWT_Tool. As a first-round attack,
    we can use the *rockyou.txt* file as our dictionary:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 要对捕获的令牌进行 Crack 攻击，请从拦截到的请求中复制令牌。打开终端并运行 JWT_Tool。作为第一次攻击，我们可以使用 *rockyou.txt*
    文件作为字典：
- en: '[PRE15]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: At the beginning of this chapter, I mentioned that *rockyou.txt* is outdated,
    so it likely won’t yield any successes. Let’s try brainstorming some likely secrets
    and save them to our own *crapi.txt* file (see [Table 8-1](#table8-1)). You can
    also generate a similar list using a password profiler, as recommended earlier
    in this chapter.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章开头，我提到过 *rockyou.txt* 已经过时，因此它可能无法带来任何成功。让我们尝试集思广益，找出一些可能的秘密，并将它们保存到我们自己的
    *crapi.txt* 文件中（见 [表 8-1](#table8-1)）。你也可以使用密码分析工具生成类似的列表，正如本章早些时候推荐的那样。
- en: 'Table 8-1: Potential crAPI JWT Secrets'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: '表 8-1: 潜在的 crAPI JWT 秘密'
- en: '| Crapi2020 | OWASP | iparc2022 |'
  id: totrans-165
  prefs: []
  type: TYPE_TB
  zh: '| Crapi2020 | OWASP | iparc2022 |'
- en: '| crapi2022 | owasp | iparc2023 |'
  id: totrans-166
  prefs: []
  type: TYPE_TB
  zh: '| crapi2022 | owasp | iparc2023 |'
- en: '| crAPI2022 | Jwt2022 | iparc2020 |'
  id: totrans-167
  prefs: []
  type: TYPE_TB
  zh: '| crAPI2022 | Jwt2022 | iparc2020 |'
- en: '| crAPI2020 | Jwt2020 | iparc2021 |'
  id: totrans-168
  prefs: []
  type: TYPE_TB
  zh: '| crAPI2020 | Jwt2020 | iparc2021 |'
- en: '| crAPI2021 | Jwt_2022 | iparc |'
  id: totrans-169
  prefs: []
  type: TYPE_TB
  zh: '| crAPI2021 | Jwt_2022 | iparc |'
- en: '| crapi | Jwt_2020 | JWT |'
  id: totrans-170
  prefs: []
  type: TYPE_TB
  zh: '| crapi | Jwt_2020 | JWT |'
- en: '| community | Owasp2021 | jwt2020 |'
  id: totrans-171
  prefs: []
  type: TYPE_TB
  zh: '| community | Owasp2021 | jwt2020 |'
- en: 'Now run this targeted hash crack attack using JWT_Tool:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 现在使用 JWT_Tool 运行这个针对性的哈希破解攻击：
- en: '[PRE16]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Great! We’ve discovered that the crAPI JWT secret is `"crapi"`.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 太棒了！我们已经发现 crAPI JWT 秘密是 `"crapi"`。
- en: This secret isn’t too useful unless we have email addresses of other valid users,
    which we’ll need to forge their tokens. Luckily, we accomplished this at the end
    of Chapter 7’s lab. Let’s see if we can gain unauthorized access to the robot
    account. As you can see in [Figure 8-15](#figure8-15), we use JWT.io to generate
    a token for the crAPI robot account.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 这个密钥并不是特别有用，除非我们有其他有效用户的电子邮件地址，这样我们才能伪造他们的令牌。幸运的是，我们在第 7 章实验的结尾已经完成了这项工作。让我们看看能否获得对机器人账户的未授权访问。如[图
    8-15](#figure8-15)所示，我们使用 JWT.io 为 crAPI 机器人账户生成了一个令牌。
- en: '![Screenshot of jwt.io with a long string in the “Encoded” field and each section
    of the JWT decoded in the “Decoded field](image_fi/502444c08/F08015.png)'
  id: totrans-176
  prefs: []
  type: TYPE_IMG
  zh: '![jwt.io 截图，显示“Encoded”字段中的长字符串，并且 JWT 的每个部分在“Decoded”字段中解码](image_fi/502444c08/F08015.png)'
- en: 'Figure 8-15: Using JWT.io to generate a token'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: '图 8-15: 使用 JWT.io 生成令牌'
- en: Don’t forget that the algorithm value of this token is HS512 and that you need
    to add the HS512 secret to the signature. Once the token is generated, you can
    copy it into a saved Postman request or into a request using Burp Suite’s Repeater,
    and then you can send it to the API. If successful, you’ll have hijacked the crAPI
    robot account. Congrats!
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 别忘了，这个令牌的算法值是 HS512，你需要将 HS512 密钥添加到签名中。令牌生成后，你可以将其复制到已保存的 Postman 请求中，或者使用
    Burp Suite 的 Repeater 发送请求，然后发送到 API。如果成功，你将劫持 crAPI 机器人账户。祝贺！
