- en: <hgroup>
  id: totrans-0
  prefs: []
  type: TYPE_NORMAL
  zh: <hgroup>
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">1</samp> <samp class="SANS_Dogma_OT_Bold_B_11">GETTING
    STARTED WITH C</samp>
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">1</samp> <samp class="SANS_Dogma_OT_Bold_B_11">开始使用
    C</samp>
- en: </hgroup>
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: </hgroup>
- en: '![](../images/opener.jpg)'
  id: totrans-3
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/opener.jpg)'
- en: 'In this chapter, you’ll develop your first C program: the traditional “Hello,
    world!” program. We’ll examine the various aspects of this simple C program, compile
    it, and run it. Then I’ll review some editor and compiler options and lay out
    common portability issues you’ll quickly become familiar with as you code in C.'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你将开发你的第一个 C 程序：传统的 “Hello, world!” 程序。我们将分析这个简单 C 程序的各个方面，编译并运行它。然后我会回顾一些编辑器和编译器选项，并列出你在编写
    C 代码时会很快遇到的常见可移植性问题。
- en: <samp class="SANS_Futura_Std_Bold_B_11">Developing Your First C Program</samp>
  id: totrans-5
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">开发你的第一个 C 程序</samp>
- en: The most effective way to learn C programming is to start writing C programs,
    and the traditional program to start with is “Hello, world!” Open your favorite
    text editor and enter the program in [Listing 1-1](chapter1.xhtml#Lis1-1).
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 学习 C 编程的最有效方法是开始编写 C 程序，传统的起步程序就是 “Hello, world!” 打开你最喜欢的文本编辑器，并输入 [列表 1-1](chapter1.xhtml#Lis1-1)
    中的程序。
- en: <samp class="SANS_Futura_Std_Medium_Oblique_I_11">hello.c</samp>
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Medium_Oblique_I_11">hello.c</samp>
- en: '[PRE0]'
  id: totrans-8
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 1-1: The “Hello, world!”
    program</samp>'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">列表 1-1： “Hello, world!” 程序</samp>
- en: The first two lines use the <samp class="SANS_TheSansMonoCd_W5Regular_11">#include</samp>
    preprocessor directive, which behaves as if you replaced it with the contents
    of the specified file at the exact same location. In this program, <samp class="SANS_TheSansMonoCd_W5Regular_11"><stdio.h></samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11"><stdlib.h></samp> are both headers.
    A *header* is a source file that, by convention, contains the definitions, function
    declarations, and constant definitions required by the users of the corresponding
    source file. As the filenames suggest, <samp class="SANS_TheSansMonoCd_W5Regular_11"><stdio.h></samp>
    defines the interface for C standard input/output (I/O) functions, and <samp class="SANS_TheSansMonoCd_W5Regular_11"><stdlib.h></samp>
    declares several general utility types and functions and defines several macros.
    You need to include the declarations for any library functions that you use in
    your program. (You’ll learn more about the appropriate use of headers in [Chapter
    9](chapter9.xhtml).)
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 前两行使用了 <samp class="SANS_TheSansMonoCd_W5Regular_11">#include</samp> 预处理指令，其行为就像你将其替换为指定文件的内容，并放在相同位置一样。在这个程序中，<samp
    class="SANS_TheSansMonoCd_W5Regular_11"><stdio.h></samp> 和 <samp class="SANS_TheSansMonoCd_W5Regular_11"><stdlib.h></samp>
    都是头文件。*头文件* 是一种源文件，按照约定，它包含了对应源文件的定义、函数声明和常量定义。正如文件名所示，<samp class="SANS_TheSansMonoCd_W5Regular_11"><stdio.h></samp>
    定义了 C 标准输入/输出 (I/O) 函数的接口，而 <samp class="SANS_TheSansMonoCd_W5Regular_11"><stdlib.h></samp>
    声明了多个通用的实用类型和函数，并定义了多个宏。你需要包含你在程序中使用的任何库函数的声明。（你将会在 [第 9 章](chapter9.xhtml) 学到更多关于头文件的适当使用。）
- en: Here, we include <samp class="SANS_TheSansMonoCd_W5Regular_11"><stdio.h></samp>
    to access the declaration of the <samp class="SANS_TheSansMonoCd_W5Regular_11">puts</samp>
    function called by the <samp class="SANS_TheSansMonoCd_W5Regular_11">main</samp>
    function. We include the <samp class="SANS_TheSansMonoCd_W5Regular_11"><stdlib.h></samp>
    to access the definition of the <samp class="SANS_TheSansMonoCd_W5Regular_11">EXIT_SUCCESS</samp>
    macro, which is used in the <samp class="SANS_TheSansMonoCd_W5Regular_11">return</samp>
    statement.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们包含 <samp class="SANS_TheSansMonoCd_W5Regular_11"><stdio.h></samp> 以访问
    <samp class="SANS_TheSansMonoCd_W5Regular_11">puts</samp> 函数的声明，该函数由 <samp class="SANS_TheSansMonoCd_W5Regular_11">main</samp>
    函数调用。我们包含 <samp class="SANS_TheSansMonoCd_W5Regular_11"><stdlib.h></samp> 以访问
    <samp class="SANS_TheSansMonoCd_W5Regular_11">EXIT_SUCCESS</samp> 宏的定义，该宏在 <samp
    class="SANS_TheSansMonoCd_W5Regular_11">return</samp> 语句中使用。
- en: 'This line defines the <samp class="SANS_TheSansMonoCd_W5Regular_11">main</samp>
    function that’s called at program startup:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 这一行定义了程序启动时调用的 <samp class="SANS_TheSansMonoCd_W5Regular_11">main</samp> 函数：
- en: '[PRE1]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The <samp class="SANS_TheSansMonoCd_W5Regular_11">main</samp> function defines
    the entry point for the program that’s executed in a hosted environment when the
    program is invoked from the command line or from another program. C defines two
    possible execution environments: freestanding and hosted. A *freestanding* environment
    may not provide an operating system and is typically used in embedded programming.
    These implementations provide a minimal set of library functions, and the name
    and type of the function called at program startup are implementation defined.
    Most of the examples in this book work on the assumption that the <samp class="SANS_TheSansMonoCd_W5Regular_11">main</samp>
    function is the one and only entry point.'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W5Regular_11">main</samp> 函数定义了程序的入口点，当程序从命令行或另一个程序调用时，会在托管环境中执行。C语言定义了两种可能的执行环境：独立环境和托管环境。*独立*环境可能不提供操作系统，通常用于嵌入式编程。这些实现提供了一组最小的库函数，程序启动时调用的函数的名称和类型由实现定义。本书中的大多数示例都假设
    <samp class="SANS_TheSansMonoCd_W5Regular_11">main</samp> 函数是唯一的入口点。
- en: 'Like other procedural languages, C programs contain *functions* that can accept
    arguments and return values. Each function is a reusable unit of work that you
    can invoke as often as required in your program. The <samp class="SANS_TheSansMonoCd_W5Regular_11">puts</samp>
    function is invoked from the <samp class="SANS_TheSansMonoCd_W5Regular_11">main</samp>
    function to print out the line <samp class="SANS_TheSansMonoCd_W5Regular_11">Hello,
    world!</samp>:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 像其他过程式语言一样，C程序包含可以接受参数并返回值的*函数*。每个函数都是一个可重用的工作单元，你可以根据需要在程序中多次调用。<samp class="SANS_TheSansMonoCd_W5Regular_11">puts</samp>
    函数从 <samp class="SANS_TheSansMonoCd_W5Regular_11">main</samp> 函数中调用，用来打印出一行 <samp
    class="SANS_TheSansMonoCd_W5Regular_11">Hello, world!</samp>：
- en: '[PRE2]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The <samp class="SANS_TheSansMonoCd_W5Regular_11">puts</samp> function is a
    C standard library function that writes a string argument to the <samp class="SANS_TheSansMonoCd_W5Regular_11">stdout</samp>
    stream and appends a newline character to the output. The <samp class="SANS_TheSansMonoCd_W5Regular_11">stdout</samp>
    stream typically represents the console or terminal window. <samp class="SANS_TheSansMonoCd_W5Regular_11">"Hello,
    world!"</samp> is a string literal that behaves like a read-only string. This
    function invocation outputs <samp class="SANS_TheSansMonoCd_W5Regular_11">Hello,
    world!</samp> to the terminal.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W5Regular_11">puts</samp> 函数是一个 C 标准库函数，用于将一个字符串参数写入
    <samp class="SANS_TheSansMonoCd_W5Regular_11">stdout</samp> 流，并在输出中附加一个换行符。<samp
    class="SANS_TheSansMonoCd_W5Regular_11">stdout</samp> 流通常代表控制台或终端窗口。<samp class="SANS_TheSansMonoCd_W5Regular_11">"Hello,
    world!"</samp> 是一个字符串字面量，它表现得像一个只读字符串。此函数调用将 <samp class="SANS_TheSansMonoCd_W5Regular_11">Hello,
    world!</samp> 输出到终端。
- en: 'Once your program has completed, you’ll want it to exit. The <samp class="SANS_TheSansMonoCd_W5Regular_11">return</samp>
    statement will exit <samp class="SANS_TheSansMonoCd_W5Regular_11">main</samp>
    and return an integer value to the host environment or invocation script:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦程序执行完毕，你会希望它退出。<samp class="SANS_TheSansMonoCd_W5Regular_11">return</samp>
    语句会退出 <samp class="SANS_TheSansMonoCd_W5Regular_11">main</samp> 函数，并将一个整数值返回给宿主环境或调用脚本：
- en: '[PRE3]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '<samp class="SANS_TheSansMonoCd_W5Regular_11">EXIT_SUCCESS</samp> is an object-like
    macro that may be defined as follows:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W5Regular_11">EXIT_SUCCESS</samp> 是一个类对象宏，可能定义如下：
- en: '[PRE4]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Each occurrence of <samp class="SANS_TheSansMonoCd_W5Regular_11">EXIT_SUCCESS</samp>
    is replaced by a 0, which is then returned to the host environment from the call
    to <samp class="SANS_TheSansMonoCd_W5Regular_11">main</samp>. The script that
    invokes the program can then check its status to determine whether the invocation
    was successful. A return from the initial call to the <samp class="SANS_TheSansMonoCd_W5Regular_11">main</samp>
    function is equivalent to calling the C standard library <samp class="SANS_TheSansMonoCd_W5Regular_11">exit</samp>
    function with the value returned by the <samp class="SANS_TheSansMonoCd_W5Regular_11">main</samp>
    function as its argument.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 每次出现 <samp class="SANS_TheSansMonoCd_W5Regular_11">EXIT_SUCCESS</samp> 时都会被替换为
    0，然后从对 <samp class="SANS_TheSansMonoCd_W5Regular_11">main</samp> 的调用中返回给宿主环境。调用该程序的脚本可以检查其状态，以确定调用是否成功。从初始调用返回的
    <samp class="SANS_TheSansMonoCd_W5Regular_11">main</samp> 函数相当于调用 C 标准库的 <samp
    class="SANS_TheSansMonoCd_W5Regular_11">exit</samp> 函数，并将 <samp class="SANS_TheSansMonoCd_W5Regular_11">main</samp>
    函数返回的值作为其参数。
- en: 'The final line of this program consists of a closing brace (<samp class="SANS_TheSansMonoCd_W5Regular_11">}</samp>),
    which closes the code block we opened with the declaration of the <samp class="SANS_TheSansMonoCd_W5Regular_11">main</samp>
    function:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 该程序的最后一行包含一个闭合大括号（<samp class="SANS_TheSansMonoCd_W5Regular_11">}</samp>），它关闭了我们用声明
    <samp class="SANS_TheSansMonoCd_W5Regular_11">main</samp> 函数打开的代码块：
- en: '[PRE5]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'You can place the opening brace on the same line as the declaration or on its
    own line, as follows:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以将开括号放在与声明同一行，也可以将其放在单独的一行，如下所示：
- en: '[PRE6]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: This decision is strictly a stylistic one, because whitespace characters (including
    newlines) are generally not syntactically meaningful. In this book, I usually
    place the opening brace on the line with the function declaration because it’s
    stylistically more compact.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 这个决定完全是一个风格问题，因为空白字符（包括换行符）通常在语法上没有意义。在本书中，我通常将开括号放在函数声明所在的行，因为这样风格上更简洁。
- en: For now, save this file as *hello.c*. The file extension *.c* indicates that
    the file contains C language source code.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，将这个文件保存为 *hello.c*。文件扩展名 *.c* 表示该文件包含 C 语言源代码。
- en: <samp class="SANS_Dogma_OT_Bold_B_15">NOTE</samp>
  id: totrans-29
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: <samp class="SANS_Dogma_OT_Bold_B_15">注意</samp>
- en: '*If you’ve purchased an ebook, cut and paste the program into the editor. Using
    cut and paste can reduce transcription errors.*'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: '*如果你购买了电子书，可以将程序剪切并粘贴到编辑器中。使用剪切和粘贴可以减少转录错误。*'
- en: <samp class="SANS_Futura_Std_Bold_B_11">Compiling and Running a Program</samp>
  id: totrans-31
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">编译和运行程序</samp>
- en: 'Next, you need to compile and run the program, which involves two steps. The
    command to compile the program depends on which compiler you’re using. On Linux
    and other Unix-like operating systems, enter <samp class="SANS_TheSansMonoCd_W7Bold_B_11">cc</samp>
    on the command line followed by the name of the file you want to compile:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，你需要编译并运行程序，这包括两个步骤。编译程序的命令取决于你使用的编译器。在 Linux 和其他类 Unix 操作系统中，在命令行中输入 <samp
    class="SANS_TheSansMonoCd_W7Bold_B_11">cc</samp>，然后跟上你要编译的文件名：
- en: '[PRE7]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: If you enter the program correctly, the compile command will create a new file
    called *a.out* in the same directory as your source code.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你正确输入了程序，编译命令将在与你的源代码相同的目录下创建一个名为 *a.out* 的新文件。
- en: <samp class="SANS_Dogma_OT_Bold_B_15">NOTE</samp>
  id: totrans-35
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: <samp class="SANS_Dogma_OT_Bold_B_15">注意</samp>
- en: '*Compilers are invoked differently on other operating systems such as Windows
    or macOS. Refer to the documentation for your specific compiler.*'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: '*在其他操作系统，如 Windows 或 macOS 上，编译器的调用方式有所不同。请参考你的特定编译器的文档。*'
- en: 'Inspect your directory with the following command:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 使用以下命令检查你的目录：
- en: '[PRE8]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'The *a.out* file in the output is the executable program, which you can now
    run on the command line:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 输出中的 *a.out* 文件就是可执行程序，你现在可以在命令行中运行它：
- en: '[PRE9]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: If everything goes right, the program should print <samp class="SANS_TheSansMonoCd_W5Regular_11">Hello,
    world!</samp> to the terminal window. If it doesn’t, compare the program text
    from [Listing 1-1](chapter1.xhtml#Lis1-1) to your program and make sure they are
    the same.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一切顺利，程序应该会将 <samp class="SANS_TheSansMonoCd_W5Regular_11">Hello, world!</samp>
    打印到终端窗口。如果没有，比较一下来自 [清单 1-1](chapter1.xhtml#Lis1-1) 的程序文本和你的程序，确保它们是一样的。
- en: 'The <samp class="SANS_TheSansMonoCd_W5Regular_11">cc</samp> command accepts
    numerous compiler options. The <samp class="SANS_TheSansMonoCd_W5Regular_11">-o
    file</samp> compiler option, for example, lets you give the executable file a
    memorable name instead of *a.out*. The following compiler invocation names the
    executable *hello*:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W5Regular_11">cc</samp> 命令接受许多编译器选项。例如，<samp
    class="SANS_TheSansMonoCd_W5Regular_11">-o file</samp> 编译器选项允许你为可执行文件指定一个易记的名称，而不是
    *a.out*。以下编译命令将可执行文件命名为 *hello*：
- en: '[PRE10]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: We’ll introduce other compiler and linker options (aka flags) throughout the
    book and dedicate a section to them in [Chapter 11](chapter11.xhtml).
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书中，我们将介绍其他编译器和链接器选项（也称为标志），并将在 [第 11 章](chapter11.xhtml)中专门讨论它们。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Function Return Values</samp>
  id: totrans-45
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">函数返回值</samp>
- en: Functions will often return a value that’s the result of a computation or that
    signifies whether the function successfully completed its task. For example, the
    <samp class="SANS_TheSansMonoCd_W5Regular_11">puts</samp> function we used in
    our “Hello, world!” program takes a string to print and returns a value of type
    <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp>. The <samp class="SANS_TheSansMonoCd_W5Regular_11">puts</samp>
    function returns the value of the macro <samp class="SANS_TheSansMonoCd_W5Regular_11">EOF</samp>
    (a negative integer) if a write error occurs; otherwise, it returns a nonnegative
    integer value.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 函数通常会返回一个值，该值是计算结果，或者表示函数是否成功完成了任务。例如，我们在“Hello, world!”程序中使用的 <samp class="SANS_TheSansMonoCd_W5Regular_11">puts</samp>
    函数接收一个字符串并打印，返回一个 <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp> 类型的值。如果发生写入错误，<samp
    class="SANS_TheSansMonoCd_W5Regular_11">puts</samp> 函数将返回宏 <samp class="SANS_TheSansMonoCd_W5Regular_11">EOF</samp>
    的值（一个负整数）；否则，返回一个非负整数值。
- en: 'Although it’s unlikely that the <samp class="SANS_TheSansMonoCd_W5Regular_11">puts</samp>
    function will fail and return <samp class="SANS_TheSansMonoCd_W5Regular_11">EOF</samp>
    for our simple program, it’s possible. Because the call to <samp class="SANS_TheSansMonoCd_W5Regular_11">puts</samp>
    can fail and return <samp class="SANS_TheSansMonoCd_W5Regular_11">EOF</samp>,
    it means that your first C program has a bug or, at least, can be improved as
    follows:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管在我们的简单程序中，<samp class="SANS_TheSansMonoCd_W5Regular_11">puts</samp> 函数发生失败并返回
    <samp class="SANS_TheSansMonoCd_W5Regular_11">EOF</samp> 的可能性很小，但它是可能发生的。由于调用
    <samp class="SANS_TheSansMonoCd_W5Regular_11">puts</samp> 函数可能会失败并返回 <samp class="SANS_TheSansMonoCd_W5Regular_11">EOF</samp>，这意味着你的第一个
    C 程序存在 bug，或者至少可以按以下方式进行改进：
- en: '[PRE11]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: This revised version of the “Hello, world!” program checks whether the <samp
    class="SANS_TheSansMonoCd_W5Regular_11">puts</samp> call returns the value <samp
    class="SANS_TheSansMonoCd_W5Regular_11">EOF</samp>, indicating a write error.
    If the function returns <samp class="SANS_TheSansMonoCd_W5Regular_11">EOF</samp>,
    the program returns the value of the <samp class="SANS_TheSansMonoCd_W5Regular_11">EXIT_FAILURE</samp>
    macro (which evaluates to a nonzero value). Otherwise, the function succeeds,
    and the program returns <samp class="SANS_TheSansMonoCd_W5Regular_11">EXIT_SUCCESS</samp>.
    The script that invokes the program can check its status to determine whether
    it was successful. Code following a return statement is *dead code* that never
    executes. This is indicated by a single-line comment in the revised program. Everything
    following <samp class="SANS_TheSansMonoCd_W5Regular_11">//</samp> is disregarded
    by the compiler.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 这个修改版的“Hello, world!”程序检查 <samp class="SANS_TheSansMonoCd_W5Regular_11">puts</samp>
    调用是否返回 <samp class="SANS_TheSansMonoCd_W5Regular_11">EOF</samp>，表示写入错误。如果函数返回
    <samp class="SANS_TheSansMonoCd_W5Regular_11">EOF</samp>，程序返回 <samp class="SANS_TheSansMonoCd_W5Regular_11">EXIT_FAILURE</samp>
    宏的值（该值为非零值）。否则，函数执行成功，程序返回 <samp class="SANS_TheSansMonoCd_W5Regular_11">EXIT_SUCCESS</samp>。调用程序的脚本可以检查其状态以确定是否成功。紧随返回语句之后的代码是
    *死代码*，永远不会执行。程序中的这一点通过单行注释表示，注释符号 <samp class="SANS_TheSansMonoCd_W5Regular_11">//</samp>
    后面的内容会被编译器忽略。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Formatted Output</samp>
  id: totrans-50
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">格式化输出</samp>
- en: 'The <samp class="SANS_TheSansMonoCd_W5Regular_11">puts</samp> function is a
    simple way to write a string to <samp class="SANS_TheSansMonoCd_W5Regular_11">stdout</samp>,
    but to print arguments other than strings, you’ll need the <samp class="SANS_TheSansMonoCd_W5Regular_11">printf</samp>
    function. The <samp class="SANS_TheSansMonoCd_W5Regular_11">printf</samp> function
    takes a format string that defines how the output is formatted, followed by a
    variable number of arguments that are the actual values you want to print. For
    example, if you want to use the <samp class="SANS_TheSansMonoCd_W5Regular_11">printf</samp>
    function to print out <samp class="SANS_TheSansMonoCd_W5Regular_11">Hello, world!</samp>,
    you could write it like this:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W5Regular_11">puts</samp> 函数是一个简单的方式将字符串写入 <samp
    class="SANS_TheSansMonoCd_W5Regular_11">stdout</samp>，但是要打印除字符串以外的参数，你需要使用 <samp
    class="SANS_TheSansMonoCd_W5Regular_11">printf</samp> 函数。<samp class="SANS_TheSansMonoCd_W5Regular_11">printf</samp>
    函数接受一个格式化字符串，定义输出的格式，然后跟随一个可变数量的参数，这些参数是你希望打印的实际值。例如，如果你想使用 <samp class="SANS_TheSansMonoCd_W5Regular_11">printf</samp>
    函数打印 <samp class="SANS_TheSansMonoCd_W5Regular_11">Hello, world!</samp>，你可以这样写：
- en: '[PRE12]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'The first argument is the format string <samp class="SANS_TheSansMonoCd_W5Regular_11">"%s\n"</samp>.
    The <samp class="SANS_TheSansMonoCd_W5Regular_11">%s</samp> is a conversion specification
    that instructs the <samp class="SANS_TheSansMonoCd_W5Regular_11">printf</samp>
    function to read the second argument (a string literal) and print it to <samp
    class="SANS_TheSansMonoCd_W5Regular_11">stdout</samp>. The <samp class="SANS_TheSansMonoCd_W5Regular_11">\n</samp>
    is an alphabetic escape sequence used to represent nongraphic characters and tells
    the function to include a new line after the string. Without the newline sequence,
    the next characters printed (likely the command prompt) would appear on the same
    line. This function call outputs the following:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个参数是格式化字符串 <samp class="SANS_TheSansMonoCd_W5Regular_11">"%s\n"</samp>。<samp
    class="SANS_TheSansMonoCd_W5Regular_11">%s</samp> 是一个转换说明符，它指示 <samp class="SANS_TheSansMonoCd_W5Regular_11">printf</samp>
    函数读取第二个参数（一个字符串字面量）并将其打印到 <samp class="SANS_TheSansMonoCd_W5Regular_11">stdout</samp>。<samp
    class="SANS_TheSansMonoCd_W5Regular_11">\n</samp> 是一个字母转义序列，用于表示非图形字符，并告诉函数在字符串后面插入一个新行。如果没有换行序列，接下来的字符（可能是命令提示符）将显示在同一行。这个函数调用输出如下：
- en: '[PRE13]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Take care not to pass user-supplied data as part of the first argument to the
    <samp class="SANS_TheSansMonoCd_W5Regular_11">printf</samp> function, because
    doing so can result in a formatted output security vulnerability (Seacord 2013).
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 请小心不要将用户提供的数据作为第一个参数传递给 <samp class="SANS_TheSansMonoCd_W5Regular_11">printf</samp>
    函数，因为这样做可能会导致格式化输出的安全漏洞（Seacord 2013）。
- en: The simplest way to output a string is to use the <samp class="SANS_TheSansMonoCd_W5Regular_11">puts</samp>
    function, as previously shown. If you use <samp class="SANS_TheSansMonoCd_W5Regular_11">printf</samp>
    instead of <samp class="SANS_TheSansMonoCd_W5Regular_11">puts</samp> in the revised
    version of the “Hello, world!” program, however, you’ll find it no longer works
    because the <samp class="SANS_TheSansMonoCd_W5Regular_11">printf</samp> function
    returns the status differently than the <samp class="SANS_TheSansMonoCd_W5Regular_11">puts</samp>
    function. The <samp class="SANS_TheSansMonoCd_W5Regular_11">printf</samp> function
    returns the number of characters printed when successful, or a negative value
    if an output or encoding error occurred. Try modifying the “Hello, world!” program
    to use the <samp class="SANS_TheSansMonoCd_W5Regular_11">printf</samp> function
    as an exercise.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 输出字符串的最简单方法是使用 <samp class="SANS_TheSansMonoCd_W5Regular_11">puts</samp> 函数，如前所示。然而，如果你在修改版的“Hello,
    world!”程序中使用 <samp class="SANS_TheSansMonoCd_W5Regular_11">printf</samp> 而不是 <samp
    class="SANS_TheSansMonoCd_W5Regular_11">puts</samp>，你会发现它不再起作用，因为 <samp class="SANS_TheSansMonoCd_W5Regular_11">printf</samp>
    函数返回的状态与 <samp class="SANS_TheSansMonoCd_W5Regular_11">puts</samp> 函数不同。<samp
    class="SANS_TheSansMonoCd_W5Regular_11">printf</samp> 函数成功时返回打印的字符数，如果发生输出或编码错误，则返回负值。作为练习，尝试修改“Hello,
    world!”程序以使用 <samp class="SANS_TheSansMonoCd_W5Regular_11">printf</samp> 函数。
- en: '## <samp class="SANS_Futura_Std_Bold_B_11">Editors and Integrated Development
    Environments</samp>'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: '## <samp class="SANS_Futura_Std_Bold_B_11">编辑器和集成开发环境</samp>'
- en: You can use a variety of editors and integrated development environments (IDEs)
    to develop your C programs. [Figure 1-1](chapter1.xhtml#fig1-1) shows the most
    used editors, according to a 2023 JetBrains survey (*[https://<wbr>www<wbr>.jetbrains<wbr>.com<wbr>/lp<wbr>/devecosystem<wbr>-2023<wbr>/c<wbr>/](https://www.jetbrains.com/lp/devecosystem-2023/c/)*).
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用多种编辑器和集成开发环境（IDE）来开发你的 C 程序。[图 1-1](chapter1.xhtml#fig1-1) 显示了根据 2023 年
    JetBrains 调查（*[https://<wbr>www<wbr>.jetbrains<wbr>.com<wbr>/lp<wbr>/devecosystem<wbr>-2023<wbr>/c<wbr>/](https://www.jetbrains.com/lp/devecosystem-2023/c/)*）使用最广泛的编辑器。
- en: '![](../images/f01001.jpg)'
  id: totrans-59
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/f01001.jpg)'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 1-1: Popular IDEs and
    editors</samp>'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">图 1-1：流行的 IDE 和编辑器</samp>
- en: The exact tools available depend on which system you’re using.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 可用的工具具体取决于你使用的系统。
- en: 'For Microsoft Windows, Microsoft’s Visual Studio IDE (*[https://<wbr>visualstudio<wbr>.microsoft<wbr>.com](https://visualstudio.microsoft.com)*)
    is an obvious choice. Visual Studio comes in three editions: Community, Professional,
    and Enterprise. The Community edition has the advantage of being free, while the
    other editions add features at a cost. For this book, you’ll need only the Community
    edition.'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 Microsoft Windows，微软的 Visual Studio IDE (*[https://<wbr>visualstudio<wbr>.microsoft<wbr>.com](https://visualstudio.microsoft.com)*)
    是一个显而易见的选择。Visual Studio 有三个版本：Community、Professional 和 Enterprise。Community 版本的优势在于免费，而其他版本则需要付费以获得额外功能。本书中，你只需要使用
    Community 版本。
- en: For Linux, the choice is less obvious as there are a variety of options. A popular
    choice is Visual Studio Code (VS Code). VS Code is a streamlined code editor with
    support for development operations such as debugging, task running, and version
    control (covered in [Chapter 11](chapter11.xhtml)). It provides just the tools
    a developer needs for a quick code-build-debug cycle. VS Code runs on macOS, Linux,
    and Windows and is free for private or commercial use. Installation instructions
    are available for Linux and other platforms (*[https://<wbr>code<wbr>.visualstudio<wbr>.com](https://code.visualstudio.com)*).
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 Linux，选择不那么明显，因为有多种选项。一种流行的选择是 Visual Studio Code（VS Code）。VS Code 是一个精简的代码编辑器，支持调试、任务运行和版本控制等开发操作（在[第
    11 章](chapter11.xhtml)中涵盖）。它提供了开发者进行快速代码构建调试周期所需的工具。VS Code 可以在 macOS、Linux 和
    Windows 上运行，并且可以免费用于私人或商业用途。对于 Linux 和其他平台，安装说明可用（*[https://<wbr>code<wbr>.visualstudio<wbr>.com](https://code.visualstudio.com)*）。
- en: '[Figure 1-2](chapter1.xhtml#fig1-2) shows VS Code being used to develop the
    “Hello, world!” program on Ubuntu. The debug console shows that the program exited
    with status code 0 as expected.'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 1-2](chapter1.xhtml#fig1-2) 显示了在 Ubuntu 上使用 VS Code 开发 “Hello, world!” 程序。调试控制台显示程序按预期以状态码
    0 退出。'
- en: '![](../images/f01002.jpg)'
  id: totrans-65
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/f01002.jpg)'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 1-2: Visual Studio Code
    running on Ubuntu</samp>'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">图 1-2：在 Ubuntu 上运行的 Visual Studio
    Code</samp>
- en: Vim is the editor of choice for many developers and power users. It is a text
    editor based on the vi editor written by Bill Joy in the 1970s for a version of
    Unix. It inherits the key bindings of vi but also adds functionality and extensibility
    that are missing from the original vi. You can optionally install Vim plug-ins
    such as YouCompleteMe (*[https://<wbr>github<wbr>.com<wbr>/ycm<wbr>-core<wbr>/YouCompleteMe](https://github.com/ycm-core/YouCompleteMe)*)
    or deoplete (*[https://<wbr>github<wbr>.com<wbr>/Shougo<wbr>/deoplete<wbr>.nvim](https://github.com/Shougo/deoplete.nvim)*)
    that provide native semantic code completion for C programming.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: Vim 是许多开发者和高级用户的首选编辑器。它是一个基于 Bill Joy 在 1970 年代为 Unix 版本编写的 vi 编辑器的文本编辑器。它继承了
    vi 的快捷键绑定，但还增加了原始 vi 所没有的功能和扩展性。你可以选择安装 Vim 插件，如 YouCompleteMe (*[https://<wbr>github<wbr>.com<wbr>/ycm<wbr>-core<wbr>/YouCompleteMe](https://github.com/ycm-core/YouCompleteMe)*)
    或 deoplete (*[https://<wbr>github<wbr>.com<wbr>/Shougo<wbr>/deoplete<wbr>.nvim](https://github.com/Shougo/deoplete.nvim)*)，它们为
    C 编程提供原生语义代码补全。
- en: 'GNU Emacs is an extensible, customizable, and free text editor. At its core,
    it’s an interpreter for Emacs Lisp, a dialect of the Lisp programming language
    with extensions to support text editing—although I’ve never found this to be a
    problem. Full disclosure: Almost all the production C code I’ve developed was
    edited in Emacs.'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: GNU Emacs 是一个可扩展、可定制的免费文本编辑器。从本质上讲，它是 Emacs Lisp 的解释器，Emacs Lisp 是一种支持文本编辑的
    Lisp 编程语言方言—尽管我从未发现这成为问题。完全公开：我开发的几乎所有生产级 C 代码都是在 Emacs 中编辑的。
- en: <samp class="SANS_Futura_Std_Bold_B_11">Compilers</samp>
  id: totrans-69
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">编译器</samp>
- en: Many C compilers are available, so I won’t discuss them all here. Different
    compilers implement different versions of the C standard. Many compilers for embedded
    systems support only C89/C90\. Popular compilers for Linux and Windows work harder
    to support modern versions of the C standard, up to and including support for
    C23.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 有许多 C 编译器可供选择，因此我不会在这里讨论所有的编译器。不同的编译器实现了不同版本的 C 标准。许多嵌入式系统的编译器仅支持 C89/C90。流行的
    Linux 和 Windows 编译器更努力地支持现代版本的 C 标准，直到包括对 C23 的支持。
- en: '### <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">GNU Compiler
    Collection</samp>'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: '### <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">GNU 编译器集合</samp>'
- en: The GNU Compiler Collection (GCC) includes frontends for C, C++, and Objective-C,
    as well as other languages (*[https://<wbr>gcc<wbr>.gnu<wbr>.org](https://gcc.gnu.org)*).
    GCC follows a well-defined development plan under the guidance of the GCC steering
    committee.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: GNU 编译器集合（GCC）包括 C、C++ 和 Objective-C 的前端，以及其他语言（*[https://<wbr>gcc<wbr>.gnu<wbr>.org](https://gcc.gnu.org)*）。GCC
    在 GCC 指导委员会的指导下，遵循一个明确定义的开发计划。
- en: 'GCC has been adopted as the standard compiler for Linux systems, although versions
    are also available for Microsoft Windows, macOS, and other platforms. Installing
    GCC on Linux is easy. The following command, for example, should install GCC on
    Ubuntu:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: GCC 已被采纳为 Linux 系统的标准编译器，虽然也有适用于 Microsoft Windows、macOS 和其他平台的版本。在 Linux 上安装
    GCC 很容易。例如，以下命令应该会在 Ubuntu 上安装 GCC：
- en: '[PRE14]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'You can test the version of GCC you’re using with the following command:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用以下命令测试你正在使用的 GCC 版本：
- en: '[PRE15]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The output will display the version and copyright information for the installed
    GCC version.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 输出将显示已安装的 GCC 版本的版本和版权信息。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Clang</samp>
  id: totrans-78
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Clang</samp>
- en: 'Another popular compiler is Clang (*[https://<wbr>clang<wbr>.llvm<wbr>.org](https://clang.llvm.org)*).
    Installing Clang on Linux is also easy. You can use the following command to install
    Clang on Ubuntu:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个流行的编译器是 Clang (*[https://<wbr>clang<wbr>.llvm<wbr>.org](https://clang.llvm.org)*)。在
    Linux 上安装 Clang 也很简单。你可以使用以下命令在 Ubuntu 上安装 Clang：
- en: '[PRE16]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'You can test the version of Clang you’re using with the following command:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用以下命令来测试你使用的 Clang 版本：
- en: '[PRE17]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: This displays the installed Clang version.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 这将显示已安装的 Clang 版本。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Microsoft Visual
    Studio</samp>
  id: totrans-84
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Microsoft Visual
    Studio</samp>
- en: As previously mentioned, the most popular development environment for Windows
    is Microsoft Visual Studio, which includes both the IDE and the compiler. Visual
    Studio (*[https://<wbr>visualstudio<wbr>.microsoft<wbr>.com<wbr>/downloads<wbr>/](https://visualstudio.microsoft.com/downloads/)*)
    is bundled with Visual C++ 2022, which includes both the C and C++ compilers.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，Windows 最流行的开发环境是 Microsoft Visual Studio，它包括 IDE 和编译器。Visual Studio (*[https://<wbr>visualstudio<wbr>.microsoft<wbr>.com<wbr>/downloads<wbr>/](https://visualstudio.microsoft.com/downloads/)*)
    附带了 Visual C++ 2022，其中包括 C 和 C++ 编译器。
- en: You can set options for Visual Studio on the Project Property pages. On the
    Advanced tab under C/C++, make sure you compile as C code by using the Compile
    as C Code (<samp class="SANS_TheSansMonoCd_W5Regular_11">/TC</samp>) option and
    not the Compile as C++ Code (<samp class="SANS_TheSansMonoCd_W5Regular_11">/TP</samp>)
    option. By default, when you name a file with a *.c* extension, it’s compiled
    with <samp class="SANS_TheSansMonoCd_W5Regular_11">/TC</samp>. If the file is
    named with *.cpp*, *.cxx*, or a few other extensions, it’s compiled with <samp
    class="SANS_TheSansMonoCd_W5Regular_11">/TP</samp>.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在项目属性页面中为 Visual Studio 设置选项。在 C/C++ 的“高级”选项卡下，确保使用编译为 C 代码（<samp class="SANS_TheSansMonoCd_W5Regular_11">/TC</samp>）选项，而不是编译为
    C++ 代码（<samp class="SANS_TheSansMonoCd_W5Regular_11">/TP</samp>）选项。默认情况下，当你命名一个文件为
    *.c* 扩展名时，它会使用 <samp class="SANS_TheSansMonoCd_W5Regular_11">/TC</samp> 进行编译。如果文件命名为
    *.cpp*、*.cxx* 或其他几个扩展名，它将使用 <samp class="SANS_TheSansMonoCd_W5Regular_11">/TP</samp>
    进行编译。
- en: '## <samp class="SANS_Futura_Std_Bold_B_11">Portability</samp>'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: '## <samp class="SANS_Futura_Std_Bold_B_11">可移植性</samp>'
- en: Every C compiler implementation is a little different. Compilers continually
    evolve—so, for example, a compiler like GCC might provide full support for C17
    but be working toward support for C23, in which case it might have some C23 features
    implemented but not others. Consequently, compilers support a full spectrum of
    C standard versions (including in-between versions). The overall evolution of
    C implementations is slow, with many compilers significantly lagging behind the
    C standard.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 每个 C 编译器的实现都有一些不同。编译器在不断发展—例如，像 GCC 这样的编译器可能已经完全支持 C17，但正在向支持 C23 过渡，在这种情况下，它可能实现了一些
    C23 特性，但没有实现其他特性。因此，编译器支持一整套 C 标准版本（包括中间版本）。C 实现的整体演进是缓慢的，许多编译器显著滞后于 C 标准。
- en: Programs written for C can be considered *strictly conforming* if they use only
    those features of the language and library specified in the standard. These programs
    are intended to be maximally portable. However, because of the range of implementation
    behaviors, no real-world C program is strictly conforming, nor will it ever be
    (and probably shouldn’t be). Instead, the C standard allows you to write *conforming*
    programs that may depend on nonportable language and library features.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 为 C 编写的程序可以被认为是*严格符合*标准的，如果它们仅使用语言和库中标准所规定的特性。这些程序旨在实现最大程度的可移植性。然而，由于实现行为的差异，实际上没有任何真实世界中的
    C 程序是严格符合标准的，也不可能是（而且可能不应该是）。相反，C 标准允许你编写*符合标准*的程序，这些程序可能依赖于不可移植的语言和库特性。
- en: It’s common practice to write code for a single reference implementation, or
    sometimes several implementations, depending on the platforms to which you plan
    to deploy your code. The C standard ensures that these implementations don’t differ
    too much, and it allows you to target several at once without having to learn
    a new language each time.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 编写代码时，通常是为单一的参考实现编写代码，或者根据你计划部署代码的平台编写几个不同的实现。C 标准确保这些实现之间的差异不会太大，并允许你一次性面向多个平台，而无需每次都学习一种新的语言。
- en: 'Five kinds of portability issues are enumerated in Annex J of the C standard
    documents:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: C标准文档的附录J列出了五种可移植性问题：
- en: Implementation-defined behavior
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现定义行为
- en: Unspecified behavior
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 未指定行为
- en: Undefined behavior
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 未定义行为
- en: Locale-specific behavior
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 特定区域行为
- en: Common extensions
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 常见扩展
- en: As you learn about the C language, you’ll encounter examples of all five kinds
    of behaviors, so it’s important to understand precisely what these are.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 在学习C语言时，您将遇到所有五种行为的例子，因此准确理解它们是什么非常重要。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Implementation-Defined
    Behavior</samp>
  id: totrans-98
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">实现定义行为</samp>
- en: '*Implementation-defined behavior* is program behavior that’s not specified
    by the C standard and that may produce different results between implementations
    but has consistent, documented behavior within an implementation. An example of
    implementation-defined behavior is the number of bits in a byte.'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: '*实现定义行为*是指C标准未指定的程序行为，它可能在不同的实现之间产生不同的结果，但在同一实现中有一致的、已记录的行为。实现定义行为的一个例子是字节中的位数。'
- en: Implementation-defined behaviors are mostly harmless but can cause defects when
    porting to different implementations. Whenever possible, avoid writing code that
    depends on implementation-defined behaviors that vary among the C implementations
    you plan to compile your code with. A complete list of implementation-defined
    behaviors is enumerated in Annex J.3 of the C standard. You can document your
    dependencies on these implementation-defined behaviors by using a <samp class="SANS_TheSansMonoCd_W5Regular_11">static_assert</samp>
    declaration, as discussed in [Chapter 11](chapter11.xhtml).
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 实现定义的行为大多数是无害的，但在移植到不同的实现时可能会引起缺陷。尽可能避免编写依赖于实现定义行为的代码，这些行为在不同的C实现之间可能有所不同。实现定义行为的完整列表列在C标准的附录J.3中。您可以通过使用<samp
    class="SANS_TheSansMonoCd_W5Regular_11">static_assert</samp>声明来记录您对这些实现定义行为的依赖，正如在[第11章](chapter11.xhtml)中讨论的那样。
- en: '### <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Unspecified
    Behavior</samp>'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: '### <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">未指定行为</samp>'
- en: '*Unspecified behavior* is program behavior for which the standard provides
    two or more options but doesn’t mandate which option is chosen in any instance.
    Each execution of a given expression may yield different results or produce a
    different value than a previous execution of the same expression. An example of
    unspecified behavior is function parameter storage layout, which can vary among
    function invocations within the same program. Unspecified behaviors are enumerated
    in Annex J.1 of the C standard.'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: '*未指定行为*是指程序行为，标准提供了两个或更多的选项，但并未强制规定在任何情况下选择哪个选项。每次执行给定表达式时，可能会产生不同的结果，或与前一次执行同一表达式时产生的值不同。未指定行为的一个例子是函数参数存储布局，这在同一个程序中的多个函数调用之间可能会有所不同。未指定行为列在C标准的附录J.1中。'
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Undefined Behavior</samp>
  id: totrans-103
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">未定义行为</samp>
- en: '*Undefined behavior* is behavior that isn’t defined by the C standard or, less
    circularly, “behavior, upon use of a nonportable or erroneous program construct
    or of erroneous data, for which the standard imposes no requirements” (ISO/IEC
    9899:2024). Examples of undefined behavior include signed integer overflow and
    dereferencing an invalid pointer value. Code that has undefined behavior is often
    incorrect, but not always. Undefined behaviors are identified in the standard
    as follows:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: '*未定义行为*是指C标准未定义的行为，或者更准确地说，“行为，在使用不可移植或错误的程序结构或错误数据时，标准没有强制要求”（ISO/IEC 9899:2024）。未定义行为的例子包括有符号整数溢出和解引用无效指针值。具有未定义行为的代码通常是错误的，但并非总是如此。未定义行为在标准中标识如下：'
- en: When a “shall” or “shall not” requirement is violated and that requirement appears
    outside a constraint, behavior is undefined.
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当“应当”或“不得”要求被违反，并且该要求出现在约束之外时，行为是未定义的。
- en: When behavior is explicitly specified by the words “undefined behavior.”
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当行为明确由“未定义行为”这一术语指定时。
- en: By the omission of any explicit definition of behavior.
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过省略任何明确的行为定义。
- en: The first two kinds of undefined behavior are frequently referred to as *explicit
    undefined behaviors*, while the third kind is referred to as *implicit undefined
    behavior*. There is no difference in emphasis among these three; they all describe
    behavior that is undefined. The C standard Annex J.2, “Undefined behavior,” lists
    the explicit undefined behaviors in C.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 前两种未定义行为通常被称为*显式未定义行为*，而第三种则称为*隐式未定义行为*。这三者在强调上没有区别，它们都描述了未定义的行为。《C标准》附录J.2“未定义行为”列出了C语言中的显式未定义行为。
- en: 'Developers often misconstrue undefined behaviors as errors or omissions in
    the C standard, but the decision to classify a behavior as undefined is *intentional*
    and *considered*. Behaviors are classified as undefined by the C standards committee
    for one of the following reasons:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 开发人员常常将未定义行为误解为C标准中的错误或遗漏，但将行为归类为未定义是*故意的*并且是*经过深思熟虑的*。C标准委员会将行为归类为未定义的原因如下：
- en: Give the implementer license not to catch program errors that are difficult
    to diagnose
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 授予实现者不捕捉难以诊断的程序错误的许可
- en: Avoid defining obscure corner cases that would favor one implementation strategy
    over another
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 避免定义模糊的边界情况，这些情况可能会偏向某种实现策略
- en: Identify areas of possible conforming language extension in which the implementer
    may augment the language by providing a definition of the officially undefined
    behavior
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 确定可能符合的语言扩展领域，在这些领域中，实施者可以通过提供未定义行为的定义来扩展语言
- en: 'These three reasons are quite different but are all considered portability
    issues. We’ll examine examples of all three as they come up over the course of
    this book. Upon encountering undefined behavior, compilers have the latitude to
    do the following:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 这三种原因虽然截然不同，但都被视为可移植性问题。在本书的过程中，我们会逐一讨论这三种情况的示例。当遇到未定义行为时，编译器可以执行以下操作：
- en: Ignore undefined behavior completely, giving unpredictable results
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 完全忽视未定义行为，导致不可预测的结果
- en: Behave in a documented manner characteristic of the environment (with or without
    issuing a diagnostic)
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 以环境特征的已记录方式进行行为（可以不发出诊断信息）
- en: Terminate a translation or execution (and issue a diagnostic)
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 终止翻译或执行（并发出诊断信息）
- en: None of these options are great (particularly the first), so it’s best to avoid
    undefined behaviors except when the compiler specifies that these behaviors are
    defined to allow you to invoke a language augmentation. Compilers sometimes have
    a *pedantic* mode that can help notify the programmer of these portability issues.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 这些选项都不好（尤其是第一个），因此最好避免未定义行为，除非编译器明确指定这些行为是已定义的，以便你调用语言扩展。编译器有时会有*迂腐*模式，帮助通知程序员这些可移植性问题。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Locale-Specific Behavior
    and Common Extensions</samp>
  id: totrans-118
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">区域特定行为和常见扩展</samp>
- en: '*Locale-specific behavior* depends on local conventions of nationality, culture,
    and language that each implementation documents. *Common extensions* are widely
    used in many systems but are not portable to all implementations.'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: '*区域特定行为*依赖于每个实现文档中规定的国家、文化和语言的本地习惯。*常见扩展*在许多系统中被广泛使用，但并不具有所有实现的可移植性。'
- en: <samp class="SANS_Futura_Std_Bold_B_11">Summary</samp>
  id: totrans-120
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">摘要</samp>
- en: In this chapter, you learned how to write a simple C language program, compile
    it, and run it. We looked at several editors and integrated development environments
    as well as a few compilers that you can use to develop C programs on Windows,
    Linux, and macOS systems. You should use newer versions of the compilers and other
    tools, as they tend to support newer features of the C programming language and
    provide better diagnostics and optimizations. However, you may not want to use
    newer versions of compilers if they break your existing code or if you’re getting
    ready to deploy your code to avoid introducing unnecessary changes into your already
    tested application. We concluded this chapter with a discussion of the portability
    of C language programs.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你学会了如何编写一个简单的C语言程序、编译它并运行。我们还看了几种编辑器和集成开发环境，以及一些你可以用来在Windows、Linux和macOS系统上开发C程序的编译器。你应该使用更新版本的编译器和其他工具，因为它们通常支持C语言的新特性，并提供更好的诊断和优化。然而，如果更新的编译器破坏了你现有的代码，或者如果你准备部署代码以避免在已经测试的应用中引入不必要的变化，可能不想使用更新版本的编译器。我们在本章的结尾讨论了C语言程序的可移植性。
- en: Subsequent chapters will examine specific features of the C language and library,
    starting with objects, functions, and types in the next chapter.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 随后的章节将探讨 C 语言及其库的具体特性，从下一章的对象、函数和类型开始。
