- en: 'Chapter 7. The Hash Table: The Workhorse of Ruby Internals'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第7章. 哈希表：Ruby 内部的工作马
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages1853819.png.jpg)'
  id: totrans-1
  prefs:
  - PREF_BQ
  type: TYPE_IMG
  zh: '![没有标题的图片](httpatomoreillycomsourcenostarchimages1853819.png.jpg)'
- en: ''
  id: totrans-2
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '*Ruby stores much of its own internal data in hash tables.*'
  id: totrans-3
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '*Ruby 将大量内部数据存储在哈希表中。*'
- en: '[Experiment 5-1: How Long Does It Take to Save a New Instance Variable?](ch05.html#experiment_5-1_how_long_does_it_take_to
    "Experiment 5-1: How Long Does It Take to Save a New Instance Variable?") showed
    us how in Ruby 1.9 and 2.0 the `ivptr` member of the `RObject` structure pointed
    to a simple array of instance variable values. We learned that adding a new value
    was usually very fast but that Ruby was somewhat slower while saving every third
    or fourth instance variable because it had to allocate a larger array.'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: '[实验 5-1：保存一个新的实例变量需要多长时间？](ch05.html#experiment_5-1_how_long_does_it_take_to
    "实验 5-1：保存一个新的实例变量需要多长时间？") 向我们展示了在 Ruby 1.9 和 2.0 中，`RObject` 结构体的 `ivptr` 成员指向一个简单的实例变量值数组。我们了解到，添加新值通常非常快速，但
    Ruby 在保存每第三个或第四个实例变量时会稍微变慢，因为它必须分配一个更大的数组。'
- en: 'Taking a broader look across Ruby’s C source code base, we find that this technique
    is unusual. Instead, Ruby often uses a data structure called a *hash table*. Unlike
    the simple array we saw in [Experiment 5-1: How Long Does It Take to Save a New
    Instance Variable?](ch05.html#experiment_5-1_how_long_does_it_take_to "Experiment
    5-1: How Long Does It Take to Save a New Instance Variable?"), hash tables can
    automatically expand to accommodate more values; the client of a hash table doesn’t
    need to worry about how much space is available or about allocating more memory
    for it.'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 从 Ruby 的 C 源代码库的更广泛角度来看，我们发现这种技术并不常见。相反，Ruby 经常使用一种称为 *哈希表* 的数据结构。与我们在 [实验 5-1：保存一个新的实例变量需要多长时间？](ch05.html#experiment_5-1_how_long_does_it_take_to
    "实验 5-1：保存一个新的实例变量需要多长时间？") 中看到的简单数组不同，哈希表可以自动扩展以容纳更多的值；哈希表的客户端无需担心可用空间或为其分配更多内存。
- en: 'Among other things, Ruby uses a hash table to hold the data you save in the
    hash objects you create in your Ruby script. Ruby also saves much of its internal
    data in hash tables. Every time you create a method or a constant, Ruby inserts
    a new value in a hash table, and Ruby saves many of the special variables we saw
    in [Experiment 3-2: Exploring Special Variables](ch03.html#experiment_3-2_exploring_special_variabl
    "Experiment 3-2: Exploring Special Variables") in hash tables. Additionally, Ruby
    saves instance variables for generic objects, such as integers or symbols, in
    hash tables. Thus, the hash table is the workhorse of Ruby internals.'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 除此之外，Ruby 使用哈希表来保存你在 Ruby 脚本中创建的哈希对象中的数据。Ruby 还将大量内部数据保存在哈希表中。每当你创建一个方法或常量时，Ruby
    会将一个新值插入哈希表中，Ruby 还将我们在 [实验 3-2：探索特殊变量](ch03.html#experiment_3-2_exploring_special_variabl
    "实验 3-2：探索特殊变量") 中看到的许多特殊变量保存在哈希表中。此外，Ruby 将泛型对象（如整数或符号）的实例变量保存在哈希表中。因此，哈希表是 Ruby
    内部的工作马。
- en: 'In this chapter I’ll begin by explaining how hash tables work: what happens
    inside the table when you save a new value with a key and what happens when you
    later retrieve that value using the same key. I’ll also explain how hash tables
    automatically expand to accommodate more values. Finally, we’ll look at how hash
    functions work in Ruby.'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我将首先解释哈希表是如何工作的：当你用一个键保存一个新值时，表内会发生什么，以及当你稍后使用相同的键检索该值时会发生什么。我还将解释哈希表是如何自动扩展以容纳更多的值的。最后，我们将探讨哈希函数在
    Ruby 中是如何工作的。
- en: Roadmap
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 路线图
- en: '[Hash Tables in Ruby](ch07.html#hash_tables_in_ruby "Hash Tables in Ruby")'
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[Ruby 中的哈希表](ch07.html#hash_tables_in_ruby "Ruby 中的哈希表")'
- en: '[Saving a Value in a Hash Table](ch07.html#saving_a_value_in_a_hash_table "Saving
    a Value in a Hash Table")'
  id: totrans-10
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[在哈希表中保存一个值](ch07.html#saving_a_value_in_a_hash_table "在哈希表中保存一个值")'
- en: '[Retrieving a Value from a Hash Table](ch07.html#retrieving_a_value_from_a_hash_table
    "Retrieving a Value from a Hash Table")'
  id: totrans-11
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[从哈希表中检索值](ch07.html#retrieving_a_value_from_a_hash_table "从哈希表中检索值")'
- en: '**[Experiment 7-1: Retrieving a Value from Hashes of Varying Sizes](ch07.html#experiment_7-1_retrieving_a_value_from_h
    "Experiment 7-1: Retrieving a Value from Hashes of Varying Sizes")**'
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**[实验 7-1：从不同大小的哈希中检索值](ch07.html#experiment_7-1_retrieving_a_value_from_h
    "实验 7-1：从不同大小的哈希中检索值")**'
- en: '[How Hash Tables Expand to Accommodate More Values](ch07.html#how_hash_tables_expand_to_accommodate_mo
    "How Hash Tables Expand to Accommodate More Values")'
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[哈希表如何扩展以容纳更多值](ch07.html#how_hash_tables_expand_to_accommodate_mo "哈希表如何扩展以容纳更多值")'
- en: '[Hash Collisions](ch07.html#hash_collisions "Hash Collisions")'
  id: totrans-14
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[哈希冲突](ch07.html#hash_collisions "哈希冲突")'
- en: '[Rehashing Entries](ch07.html#rehashing_entries "Rehashing Entries")'
  id: totrans-15
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[重新哈希条目](ch07.html#rehashing_entries "重新哈希条目")'
- en: '[How Does Ruby Rehash Entries in a Hash Table?](ch07.html#how_does_ruby_rehash_entries_in_a_hash_t
    "How Does Ruby Rehash Entries in a Hash Table?")'
  id: totrans-16
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[Ruby如何在哈希表中重新哈希条目？](ch07.html#how_does_ruby_rehash_entries_in_a_hash_t "Ruby如何在哈希表中重新哈希条目？")'
- en: '**[Experiment 7-2: Inserting One New Element into Hashes of Varying Sizes](ch07.html#experiment_7-2_inserting_one_new_element
    "Experiment 7-2: Inserting One New Element into Hashes of Varying Sizes")**'
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**[实验7-2：在不同大小的哈希中插入一个新元素](ch07.html#experiment_7-2_inserting_one_new_element
    "实验7-2：在不同大小的哈希中插入一个新元素")**'
- en: '[Where Do the Magic Numbers 57 and 67 Come From?](ch07.html#where_do_the_magic_numbers_57_and_67_com
    "Where Do the Magic Numbers 57 and 67 Come From?")'
  id: totrans-18
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[魔法数字57和67从哪里来？](ch07.html#where_do_the_magic_numbers_57_and_67_com "魔法数字57和67从哪里来？")'
- en: '[How Ruby Implements Hash Functions](ch07.html#how_ruby_implements_hash_functions
    "How Ruby Implements Hash Functions")'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[Ruby如何实现哈希函数](ch07.html#how_ruby_implements_hash_functions "Ruby如何实现哈希函数")'
- en: '**[Experiment 7-3: Using Objects as Keys in a Hash](ch07.html#experiment_7-3_using_objects_as_keys_in
    "Experiment 7-3: Using Objects as Keys in a Hash")**'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**[实验7-3：在哈希中使用对象作为键](ch07.html#experiment_7-3_using_objects_as_keys_in "实验7-3：在哈希中使用对象作为键")**'
- en: '[Hash Optimization in Ruby 2.0](ch07.html#hash_optimization_in_ruby_2dot0 "Hash
    Optimization in Ruby 2.0")'
  id: totrans-21
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[Ruby 2.0中的哈希优化](ch07.html#hash_optimization_in_ruby_2dot0 "Ruby 2.0中的哈希优化")'
- en: '[Summary](ch07.html#summary-id00028 "Summary")'
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[总结](ch07.html#summary-id00028 "总结")'
- en: Hash Tables in Ruby
  id: totrans-23
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Ruby中的哈希表
- en: '*Hash tables* are a commonly used, well-known, age-old concept in computer
    science. They organize values into groups, or *bins*, based on an integer value
    calculated from each value—a *hash*. When you need to find a value, you can figure
    out which bin it’s in by recalculating its hash value, thus speeding up the search.'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: '*哈希表*是计算机科学中常用的、广为人知的、历史悠久的概念。它们根据从每个值计算得到的整数值——即*哈希*——将值组织成不同的组或*桶*。当你需要查找某个值时，可以通过重新计算它的哈希值来确定它所在的桶，从而加速搜索过程。'
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages1854143.png.jpg)'
  id: totrans-25
  prefs: []
  type: TYPE_IMG
  zh: '![没有标题的图片](httpatomoreillycomsourcenostarchimages1854143.png.jpg)'
- en: '*Every time you write a method, Ruby creates an entry in a hash table.*'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: '*每次你编写方法时，Ruby都会在哈希表中创建一个条目。*'
- en: Saving a Value in a Hash Table
  id: totrans-27
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在哈希表中保存一个值
- en: '[Figure 7-1](ch07.html#ruby_hash_object_with_an_empty_hash_ta "Figure 7-1. A
    Ruby hash object with an empty hash table") shows a single hash object and its
    hash table.'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: '[图7-1](ch07.html#ruby_hash_object_with_an_empty_hash_ta "图7-1：一个包含空哈希表的Ruby哈希对象")展示了一个单一的哈希对象及其哈希表。'
- en: '![A Ruby hash object with an empty hash table](httpatomoreillycomsourcenostarchimages1854145.png.jpg)'
  id: totrans-29
  prefs: []
  type: TYPE_IMG
  zh: '![一个包含空哈希表的Ruby哈希对象](httpatomoreillycomsourcenostarchimages1854145.png.jpg)'
- en: Figure 7-1. A Ruby hash object with an empty hash table
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 图7-1：一个包含空哈希表的Ruby哈希对象
- en: On the left is the `RHash` (short for *Ruby hash*) structure. On the right,
    you see the hash table used by this hash, represented by the `st_table` structure.
    This C structure contains the basic information about the hash table, including
    the number of entries saved in the table, the number of bins, and a pointer to
    the bins. Each `RHash` structure contains a pointer to a corresponding `st_table`
    structure. The empty bins on the lower right are there because Ruby 1.8 and 1.9
    initially create 11 bins for a new, empty hash. (Ruby 2.0 works somewhat differently;
    see [Hash Optimization in Ruby 2.0](ch07.html#hash_optimization_in_ruby_2dot0
    "Hash Optimization in Ruby 2.0").)
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 左边是`RHash`（即*Ruby哈希*）结构。右边是该哈希使用的哈希表，表示为`st_table`结构。这个C结构包含了哈希表的基本信息，包括表中保存的条目数量、桶的数量以及指向桶的指针。每个`RHash`结构包含一个指向相应`st_table`结构的指针。右下角的空桶是因为Ruby
    1.8和1.9最初为一个新的空哈希创建了11个桶。（Ruby 2.0略有不同；请参见[Ruby 2.0中的哈希优化](ch07.html#hash_optimization_in_ruby_2dot0
    "Ruby 2.0中的哈希优化")。）
- en: 'The best way to understand how a hash table works is by stepping through an
    example. Suppose I add a new key/value to a hash called `my_hash`:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 理解哈希表如何工作最好的方式是通过一个例子。假设我向一个名为`my_hash`的哈希中添加一个新的键/值对：
- en: '[PRE0]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: While executing this line of code, Ruby creates a new structure called an `st_table_entry`
    that it will save into the hash table for `my_hash`, as shown in [Figure 7-2](ch07.html#ruby_hash_object_containing_a_single_v
    "Figure 7-2. A Ruby hash object containing a single value").
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 在执行这行代码时，Ruby 会创建一个新的结构，叫做 `st_table_entry`，并将其保存到 `my_hash` 的哈希表中，如 [图 7-2](ch07.html#ruby_hash_object_containing_a_single_v
    "图 7-2. 一个包含单个值的 Ruby 哈希对象") 所示。
- en: '![A Ruby hash object containing a single value](httpatomoreillycomsourcenostarchimages1854147.png.jpg)'
  id: totrans-35
  prefs: []
  type: TYPE_IMG
  zh: '![一个包含单个值的 Ruby 哈希对象](httpatomoreillycomsourcenostarchimages1854147.png.jpg)'
- en: Figure 7-2. A Ruby hash object containing a single value
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7-2. 一个包含单个值的 Ruby 哈希对象
- en: 'Here you can see Ruby saved the new key/value pair under the third bucket,
    number 2\. Ruby did this by taking the given key—in this example, the symbol `:key`—and
    passing it to an internal hash function that returns a pseudorandom integer:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，你可以看到 Ruby 将新的键/值对保存在了第三个桶，也就是第 2 号桶下。Ruby 通过获取给定的键——在这个例子中是符号 `:key`——并将其传递给一个内部哈希函数，返回一个伪随机整数来完成这一步：
- en: '[PRE1]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Next, Ruby takes the hash value—in this example, `some_value`—and calculates
    the modulus by the number of bins, which is the remainder after dividing by the
    number of bins.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，Ruby 会取哈希值——在这个例子中是 `some_value`——并通过桶的数量计算余数，即除以桶的数量后的余数。
- en: '[PRE2]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Note
  id: totrans-41
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '*In [Figure 7-2](ch07.html#ruby_hash_object_containing_a_single_v "Figure 7-2. A
    Ruby hash object containing a single value"), I assume that the actual hash value
    for `:key` divided by 11 leaves a remainder of 2\. Later in this chapter, I’ll
    explore in more detail the hash functions that Ruby actually uses.*'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: '*在 [图 7-2](ch07.html#ruby_hash_object_containing_a_single_v "图 7-2. 一个包含单个值的
    Ruby 哈希对象") 中，我假设 `:key` 的实际哈希值除以 11 后的余数是 2。稍后在本章中，我将更详细地探讨 Ruby 实际使用的哈希函数。*'
- en: 'Now let’s add a second element to the hash:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们为哈希表添加第二个元素：
- en: '[PRE3]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: This time let’s imagine that the hash value of `:key2` divided by 11 yields
    a remainder of 5.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 这次让我们假设 `:key2` 的哈希值除以 11 得到的余数是 5。
- en: '[PRE4]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '[Figure 7-3](ch07.html#ruby_hash_object_containing_two_values "Figure 7-3. A
    Ruby hash object containing two values") shows that Ruby places a second `st_table_entry`
    structure under bin number 5, the sixth bin.'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 7-3](ch07.html#ruby_hash_object_containing_two_values "图 7-3. 一个包含两个值的 Ruby
    哈希对象") 显示了 Ruby 将第二个 `st_table_entry` 结构放在了第 5 个桶，也就是第六个桶下。'
- en: '![A Ruby hash object containing two values](httpatomoreillycomsourcenostarchimages1854149.png.jpg)'
  id: totrans-48
  prefs: []
  type: TYPE_IMG
  zh: '![一个包含两个值的 Ruby 哈希对象](httpatomoreillycomsourcenostarchimages1854149.png.jpg)'
- en: Figure 7-3. A Ruby hash object containing two values
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7-3. 一个包含两个值的 Ruby 哈希对象
- en: Retrieving a Value from a Hash Table
  id: totrans-50
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 从哈希表中检索值
- en: 'The benefit of using a hash table becomes clear when you ask Ruby to retrieve
    the value for a given key. For example:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 使用哈希表的好处在于，当你要求 Ruby 根据给定的键来检索值时，这种优势会变得非常明显。例如：
- en: '[PRE5]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: If Ruby had saved all of the keys and values in an array or linked list, it
    would have to iterate over all the elements in that array or list, looking for
    `:key`. This might take a very long time, depending on the number of elements.
    But using a hash table, Ruby can jump straight to the key it needs to find by
    recalculating the hash value for that key.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 Ruby 将所有键和值保存在一个数组或链表中，它就必须遍历数组或链表中的所有元素来查找 `:key`。根据元素的数量，这可能会花费很长时间。但使用哈希表时，Ruby
    可以通过重新计算该键的哈希值，直接跳到它需要查找的键。
- en: 'To recalculate the hash value for a particular key, Ruby simply calls the hash
    function again:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 为了重新计算某个特定键的哈希值，Ruby 只需再次调用哈希函数：
- en: '[PRE6]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Then, it redivides the hash value by the number of bins to get the remainder,
    or the modulus.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，它重新将哈希值除以桶的数量来得到余数，或者说是模值。
- en: '[PRE7]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: At this point, Ruby knows to look in bin number 2 for the entry with the key
    of `:key`. Ruby can later find the value for `:key2` by repeating the same hash
    calculation.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 到此为止，Ruby 知道要在第 2 个桶中查找键为 `:key` 的条目。Ruby 之后可以通过重复相同的哈希计算来找到 `:key2` 的值。
- en: '[PRE8]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Note
  id: totrans-60
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '*The C library used by Ruby to implement hash tables was written in the 1980s
    by Peter Moore from the University of California, Berkeley. Later, it was modified
    by the Ruby core team. You can find Moore’s hash table code in the C code files*
    st.c *and* include/ruby/st.h. *All of the function and structure names in that
    code use the naming convention `st_`. The definition of the `RHash` structure
    that represents every Ruby Hash object is in the* include/ruby/ruby.h *file. Along
    with `RHash`, this file contains all of the other primary object structures used
    in the Ruby source code: `RString`, `RArray`, `RValue`, and so on.*'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: '*Ruby 用来实现哈希表的 C 库是由加利福尼亚大学伯克利分校的彼得·摩尔（Peter Moore）在 1980 年代编写的。后来，这个库经过了 Ruby
    核心团队的修改。你可以在 C 代码文件* st.c *和* include/ruby/st.h *中找到摩尔的哈希表代码。*该代码中所有的函数和结构体名称都遵循
    `st_` 的命名规范。表示每个 Ruby Hash 对象的 `RHash` 结构体的定义位于* include/ruby/ruby.h *文件中。除了 `RHash`，该文件还包含
    Ruby 源代码中使用的所有其他主要对象结构体：`RString`、`RArray`、`RValue` 等。*'
- en: 'Experiment 7-1: Retrieving a Value from Hashes of Varying Sizes'
  id: totrans-62
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实验 7-1：从不同大小的哈希表中检索值
- en: This experiment will create hashes of wildly different sizes, from 1 to 1 million
    elements, and then measure how long it takes to find and return a value from each
    of these hashes. [Example 7-1](ch07.html#measuring_how_long_it_takes_to_retrieve
    "Example 7-1. Measuring how long it takes to retrieve an element from hashes of
    wildly different sizes") shows the experiment code.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 这个实验将创建大小差异巨大的哈希表，从 1 个到 100 万个元素不等，然后测量从这些哈希表中查找并返回一个值所需的时间。[示例 7-1](ch07.html#measuring_how_long_it_takes_to_retrieve
    "示例 7-1。测量从不同大小的哈希表中检索一个元素所需的时间") 展示了实验代码。
- en: Example 7-1. Measuring how long it takes to retrieve an element from hashes
    of wildly different sizes
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 7-1。测量从大小差异巨大的哈希表中检索一个元素所需的时间
- en: '[PRE9]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: At ![](httpatomoreillycomsourcenostarchimages1853843.png.jpg) the outer loop
    iterates over powers of two, calculating different values for `size` at ![](httpatomoreillycomsourcenostarchimages1853845.png.jpg).
    These sizes will vary from 1 to about 1 million. Next, the inner loop at ![](httpatomoreillycomsourcenostarchimages1853847.png.jpg)
    inserts that number of elements into a new empty hash at ![](httpatomoreillycomsourcenostarchimages1854043.png.jpg).
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 在 ![](httpatomoreillycomsourcenostarchimages1853843.png.jpg)，外层循环遍历二的幂次，计算不同的
    `size` 值，如 ![](httpatomoreillycomsourcenostarchimages1853845.png.jpg) 所示。这些大小从
    1 到大约 100 万不等。接下来，内层循环在 ![](httpatomoreillycomsourcenostarchimages1853847.png.jpg)
    插入指定数量的元素到一个新的空哈希表中，位置在 ![](httpatomoreillycomsourcenostarchimages1854043.png.jpg)。
- en: 'After disabling garbage collection to avoid skewing the results, [Experiment
    7-1: Retrieving a Value from Hashes of Varying Sizes](ch07.html#experiment_7-1_retrieving_a_value_from_h
    "Experiment 7-1: Retrieving a Value from Hashes of Varying Sizes") uses the benchmark
    library to measure how long it takes to retrieve a value 10,000 times from each
    hash at ![](httpatomoreillycomsourcenostarchimages1854045.png.jpg). The line of
    code at ![](httpatomoreillycomsourcenostarchimages1853937.png.jpg) saves one of
    the random key values to use below at ![](httpatomoreillycomsourcenostarchimages1854045.png.jpg)
    as `target_key`.'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 在禁用垃圾回收以避免影响结果后，[实验 7-1：从不同大小的哈希表中检索值](ch07.html#experiment_7-1_retrieving_a_value_from_h
    "实验 7-1：从不同大小的哈希表中检索值") 使用基准库来测量从每个哈希表中检索一个值 10,000 次所需的时间，如下所示 ![](httpatomoreillycomsourcenostarchimages1854045.png.jpg)。代码行
    ![](httpatomoreillycomsourcenostarchimages1853937.png.jpg) 保存一个随机的键值，稍后将在 ![](httpatomoreillycomsourcenostarchimages1854045.png.jpg)
    处作为 `target_key` 使用。
- en: The results in [Figure 7-4](ch07.html#time_to_retrieve_10comma000_values_left
    "Figure 7-4. Time to retrieve 10,000 values (ms) vs. hash size for Ruby 2.0")
    show that Ruby can find and return a value from a hash containing over 1 million
    elements just as fast as it can return one from a small hash.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 7-4](ch07.html#time_to_retrieve_10comma000_values_left "图 7-4。Ruby 2.0 中检索
    10,000 个值所需的时间（毫秒）与哈希大小的关系") 中的结果显示，Ruby 能以与从小哈希表中返回值相同的速度，从包含超过 100 万个元素的哈希表中找到并返回一个值。'
- en: '![Time to retrieve 10,000 values (ms) vs. hash size for Ruby 2.0](httpatomoreillycomsourcenostarchimages1854151.png)'
  id: totrans-69
  prefs: []
  type: TYPE_IMG
  zh: '![Ruby 2.0 中检索 10,000 个值所需的时间（毫秒）与哈希大小的关系](httpatomoreillycomsourcenostarchimages1854151.png)'
- en: Figure 7-4. Time to retrieve 10,000 values (ms) vs. hash size for Ruby 2.0
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7-4。Ruby 2.0 中检索 10,000 个值所需的时间（毫秒）与哈希大小的关系
- en: Clearly Ruby’s hash function is very fast, and once Ruby identifies the bin
    containing the target key, it can very quickly find the corresponding value and
    return it. What’s remarkable here is that the chart is more or less flat.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，Ruby 的哈希函数非常快速，一旦 Ruby 确定了包含目标键的桶，它就可以非常迅速地找到对应的值并返回。这里值得注意的是，图表基本上是平坦的。
- en: How Hash Tables Expand to Accommodate More Values
  id: totrans-72
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 哈希表如何扩展以容纳更多值
- en: If there are millions of `st_table_entry` structures, why does distributing
    them among 11 bins help Ruby search quickly? Because even if the hash function
    is fast, and even if Ruby distributes the values evenly among the 11 bins in the
    hash table, Ruby still has to search among almost 100,000 elements in each bin
    to find the target key if there are 1 million elements overall.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 如果有数百万个 `st_table_entry` 结构，为什么将它们分布到 11 个桶中能帮助 Ruby 快速查找？因为即使哈希函数很快，且 Ruby
    将值均匀地分配到哈希表的 11 个桶中，如果总共有 100 万个元素，Ruby 仍然需要在每个桶中搜索近 100,000 个元素来找到目标键。
- en: Something else must be going on here. It seems that Ruby must add more bins
    to the hash table as more and more elements are added. Let’s look again at how
    Ruby’s internal hash table code works. Continuing with the example from [Figure 7-1](ch07.html#ruby_hash_object_with_an_empty_hash_ta
    "Figure 7-1. A Ruby hash object with an empty hash table") through [Figure 7-3](ch07.html#ruby_hash_object_containing_two_values
    "Figure 7-3. A Ruby hash object containing two values"), suppose I keep adding
    more and more elements to my hash.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 这里肯定发生了其他的事情。似乎随着元素的不断增加，Ruby 必须为哈希表添加更多的桶。让我们再次看看 Ruby 内部哈希表代码是如何工作的。继续看 [图
    7-1](ch07.html#ruby_hash_object_with_an_empty_hash_ta "图 7-1. 一个空哈希表的 Ruby 哈希对象")
    到 [图 7-3](ch07.html#ruby_hash_object_containing_two_values "图 7-3. 一个包含两个值的 Ruby
    哈希对象") 的示例，假设我不断向哈希表中添加更多的元素。
- en: '[PRE10]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: As we add more elements, Ruby continues to create more `st_table_entry` structures
    and add them to different bins.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 随着我们添加更多元素，Ruby 会继续创建更多的 `st_table_entry` 结构并将它们添加到不同的桶中。
- en: Hash Collisions
  id: totrans-77
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 哈希碰撞
- en: Eventually two or more elements might be saved into the same bin. When this
    happens, we have a *hash collision*. This means that Ruby is no longer able to
    uniquely identify and retrieve a key based solely on the hash function.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 最终，可能会有两个或多个元素被保存到同一个桶中。当发生这种情况时，我们就遇到了 *哈希碰撞*。这意味着 Ruby 不再能够仅凭哈希函数唯一地识别和检索一个键。
- en: '[Figure 7-5](ch07.html#hash_table_containing_44_values "Figure 7-5. A hash
    table containing 44 values") shows the linked list Ruby uses to track the entries
    in each bin. Each `st_table_entry` structure contains a pointer to the next entry
    in the same bin. As you add more entries to the hash, the linked lists get longer
    and longer.'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 7-5](ch07.html#hash_table_containing_44_values "图 7-5. 包含 44 个值的哈希表") 显示了
    Ruby 用来跟踪每个桶中条目的链表。每个 `st_table_entry` 结构包含指向同一桶中下一个条目的指针。随着你向哈希表中添加更多条目，链表会变得越来越长。'
- en: '![A hash table containing 44 values](httpatomoreillycomsourcenostarchimages1854153.png.jpg)'
  id: totrans-80
  prefs: []
  type: TYPE_IMG
  zh: '![包含 44 个值的哈希表](httpatomoreillycomsourcenostarchimages1854153.png.jpg)'
- en: Figure 7-5. A hash table containing 44 values
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7-5. 包含 44 个值的哈希表
- en: To retrieve a value, Ruby needs to iterate over the linked list and compare
    each key with the target. This isn’t a serious problem as long as the number of
    entries in a single bin doesn’t grow too large. For integers or symbols, which
    are typically used as hash keys, this is a simple numerical comparison. However,
    if you use a more complex data type, such as a custom object, Ruby calls the `eql?`
    method on the keys to check whether each key in the list is the target. As you
    might guess, `eql?` returns *true* if two values are equal and *false* if they
    are not.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 为了检索一个值，Ruby 需要遍历链表并将每个键与目标进行比较。只要单个桶中的条目数量不增长到太大，这并不是一个严重的问题。对于整数或符号（通常用作哈希键），这只是一个简单的数值比较。然而，如果你使用更复杂的数据类型，如自定义对象，Ruby
    会对键调用 `eql?` 方法，以检查链表中的每个键是否是目标。正如你可能猜到的那样，`eql?` 如果两个值相等，则返回 *true*，如果不相等，则返回
    *false*。
- en: Rehashing Entries
  id: totrans-83
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 重新哈希条目
- en: To keep these linked lists from growing out of control, Ruby measures the *density*,
    or average number of entries per bin. In [Figure 7-5](ch07.html#hash_table_containing_44_values
    "Figure 7-5. A hash table containing 44 values") you can see that the average
    number of entries per bin is about 4\. This means that the hash value modulus
    11 has started to return repeated values for different keys and hash values; thus,
    there have been some hash collisions.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 为了防止这些链表失控地增长，Ruby 会衡量每个桶的 *密度*，即每个桶的平均条目数。在 [图 7-5](ch07.html#hash_table_containing_44_values
    "图 7-5. 包含 44 个值的哈希表") 中，你可以看到每个桶的平均条目数大约是 4。 这意味着哈希值取模 11 开始为不同的键和哈希值返回重复的值；因此，发生了哈希碰撞。
- en: Once the density exceeds 5, a constant value in Ruby’s C source code, Ruby allocates
    more bins and then *rehashes*, or redistributes, the existing entries across the
    new bin set. If we keep adding more key/value pairs, for example, Ruby eventually
    discards the array of 11 bins and allocates an array of 19 bins, as shown in [Figure 7-6](ch07.html#hash_table_containing_65_values
    "Figure 7-6. A hash table containing 65 values").
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦密度超过 5（这是Ruby C源代码中的常量），Ruby就会分配更多的桶，然后*重新哈希*，或者重新分配现有条目到新的桶集中。如果我们继续添加更多的键值对，例如，Ruby最终会丢弃
    11 个桶的数组，并分配一个包含 19 个桶的数组，如[图 7-6](ch07.html#hash_table_containing_65_values "图
    7-6. 包含 65 个值的哈希表")所示。
- en: '![A hash table containing 65 values](httpatomoreillycomsourcenostarchimages1854155.png.jpg)'
  id: totrans-86
  prefs: []
  type: TYPE_IMG
  zh: '![包含 65 个值的哈希表](httpatomoreillycomsourcenostarchimages1854155.png.jpg)'
- en: Figure 7-6. A hash table containing 65 values
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7-6：包含 65 个值的哈希表
- en: In this figure the bin density has dropped to about 3.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个图中，桶的密度已降到大约 3。
- en: By monitoring bin density, Ruby guarantees that the linked lists remain short
    and that retrieving a hash element is always fast. After calculating the hash
    value, Ruby just needs to step through one or two elements to find the target
    key.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 通过监控桶的密度，Ruby确保链表保持简短，并且检索哈希元素始终是快速的。在计算出哈希值后，Ruby只需要遍历一两个元素就能找到目标键。
- en: How Does Ruby Rehash Entries in a Hash Table?
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: Ruby是如何重新哈希哈希表中的条目？
- en: You can find the `rehash` function (the code that loops through the `st_table_entry`
    structures and recalculates which bin to put the entry into) in the *st.c* source
    file. To keep things simple, [Example 7-2](ch07.html#c_code_inside_ruby_1dot8dot7_that_re
    "Example 7-2. The C code inside Ruby 1.8.7 that rehashes a hash table") shows
    the version of `rehash` from Ruby 1.8.7\. While Ruby 1.9 and 2.0 work largely
    the same way, their C rehash code is somewhat more complex.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在*st.c*源文件中找到`rehash`函数（这段代码会循环遍历`st_table_entry`结构并重新计算每个条目的桶位置）。为了简化，[示例
    7-2](ch07.html#c_code_inside_ruby_1dot8dot7_that_re "示例 7-2. Ruby 1.8.7 中重新哈希哈希表的
    C 代码")展示了来自Ruby 1.8.7的`rehash`版本。虽然Ruby 1.9和2.0的工作方式大致相同，但它们的C语言重哈希代码稍微复杂一些。
- en: Example 7-2. The C code inside Ruby 1.8.7 that rehashes a hash table
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 7-2：Ruby 1.8.7 中重新哈希哈希表的 C 代码
- en: '[PRE11]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'In this listing, the `new_size` method call at ![](httpatomoreillycomsourcenostarchimages1853843.png.jpg)
    returns the new bin count. Once Ruby has the new bin count, it allocates the new
    bins and then iterates over all the existing `st_table_entry` structures (all
    the key/value pairs in the hash) beginning at ![](httpatomoreillycomsourcenostarchimages1853845.png.jpg).
    For each `st_table_entry` Ruby recalculates the bin position using the same modulus
    formula at ![](httpatomoreillycomsourcenostarchimages1853847.png.jpg): `hash_val
    = ptr->hash % new_num_bins`. Then, Ruby saves each entry in the linked list for
    that new bin at ![](httpatomoreillycomsourcenostarchimages1853937.png.jpg). Finally,
    Ruby updates the `st_table` structure and frees the old bins at ![](httpatomoreillycomsourcenostarchimages1854043.png.jpg).'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，`new_size`方法调用在![](httpatomoreillycomsourcenostarchimages1853843.png.jpg)处返回新的桶数。一旦Ruby得到了新的桶数，它会分配新的桶，然后从![](httpatomoreillycomsourcenostarchimages1853845.png.jpg)开始，遍历所有现有的`st_table_entry`结构（哈希中的所有键值对）。对于每个`st_table_entry`，Ruby使用![](httpatomoreillycomsourcenostarchimages1853847.png.jpg)处相同的取模公式重新计算桶的位置：`hash_val
    = ptr->hash % new_num_bins`。然后，Ruby将每个条目保存到该新桶的链表中，位置在![](httpatomoreillycomsourcenostarchimages1853937.png.jpg)。最后，Ruby更新`st_table`结构，并在![](httpatomoreillycomsourcenostarchimages1854043.png.jpg)处释放旧的桶。
- en: 'Experiment 7-2: Inserting One New Element into Hashes of Varying Sizes'
  id: totrans-95
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实验 7-2：向不同大小的哈希表中插入一个新元素
- en: One way to test whether this rehashing, or redistribution, of entries really
    occurs is to measure the amount of time Ruby takes to save one new element into
    existing hashes of different sizes. As we add more elements to the same hash,
    we should eventually see evidence that Ruby is taking extra time to rehash the
    elements.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 测试这个重新哈希（或重新分配）条目是否真的发生的一种方法是，测量Ruby将一个新元素保存到不同大小的现有哈希表中所需的时间。当我们向同一个哈希表中添加更多元素时，我们最终应该能够看到Ruby花费额外时间重新哈希这些元素的证据。
- en: The code for this experiment is shown in [Example 7-3](ch07.html#adding_one_more_element_to_hashes_of_dif
    "Example 7-3. Adding one more element to hashes of different sizes").
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 这个实验的代码展示在[示例 7-3](ch07.html#adding_one_more_element_to_hashes_of_dif "示例 7-3.
    向不同大小的哈希表中添加一个元素")中。
- en: Example 7-3. Adding one more element to hashes of different sizes
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 7-3：向不同大小的哈希表中添加一个元素
- en: '[PRE12]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: At ![](httpatomoreillycomsourcenostarchimages1853843.png.jpg) the outer loop
    iterates over hash sizes from 0 to 100, and at ![](httpatomoreillycomsourcenostarchimages1853845.png.jpg)
    the inner loop creates 10,000 hashes of the given size. After disabling garbage
    collection, this experiment uses the benchmark library to measure how long it
    takes Ruby to insert a single new value at ![](httpatomoreillycomsourcenostarchimages1853847.png.jpg)
    into all 10,000 hashes of the given size.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 在 ![](httpatomoreillycomsourcenostarchimages1853843.png.jpg) 外部循环遍历从 0 到 100
    的哈希表大小，而在 ![](httpatomoreillycomsourcenostarchimages1853845.png.jpg) 内部循环创建给定大小的
    10,000 个哈希表。在禁用垃圾回收后，实验使用基准库测量 Ruby 插入单个新值所需的时间，在 ![](httpatomoreillycomsourcenostarchimages1853847.png.jpg)
    将新值插入所有 10,000 个给定大小的哈希表中。
- en: The results are surprising! [Figure 7-7](ch07.html#time_to_add_10comma000_keysolidusvalue_p
    "Figure 7-7. Time to add 10,000 key/value pairs vs. hash size (Ruby 1.8)") shows
    the results for Ruby 1.8.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 结果令人惊讶！[图 7-7](ch07.html#time_to_add_10comma000_keysolidusvalue_p "图 7-7. 添加
    10,000 对键值对所需的时间与哈希表大小的关系（Ruby 1.8）") 显示了 Ruby 1.8 的结果。
- en: '![Time to add 10,000 key/value pairs vs. hash size (Ruby 1.8)](httpatomoreillycomsourcenostarchimages1854157.png.jpg)'
  id: totrans-102
  prefs: []
  type: TYPE_IMG
  zh: '![添加 10,000 对键值对所需的时间与哈希表大小的关系（Ruby 1.8）](httpatomoreillycomsourcenostarchimages1854157.png.jpg)'
- en: Figure 7-7. Time to add 10,000 key/value pairs vs. hash size (Ruby 1.8)
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7-7. 添加 10,000 对键值对所需的时间与哈希表大小的关系（Ruby 1.8）
- en: 'Interpreting these data values from left to right, we see the following:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 从左到右解释这些数据值，我们可以看到以下内容：
- en: It takes about 7 ms to insert the first element into an empty hash (10,000 times).
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 向空哈希表插入第一个元素大约需要 7 毫秒（共插入 10,000 次）。
- en: As the hash size increases from 2 to 3 and then up to about 60 or 65, the amount
    of time required to insert a new element slowly increases.
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 随着哈希表大小从 2 增加到 3，再到大约 60 或 65，插入新元素所需的时间缓慢增加。
- en: It takes around 11 to 12 ms to insert each new key/value pair into a hash that
    contains 64, 65, or 66 elements (10,000 times).
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在包含 64、65 或 66 个元素的哈希表中，每插入一个新的键值对大约需要 11 到 12 毫秒（共插入 10,000 次）。
- en: 'A huge spike! Inserting the 67th key/value pair takes over twice as much time:
    about 26 ms instead of 11 ms for 10,000 hashes!'
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个巨大的尖峰！插入第 67 个键值对所需的时间是之前的两倍多：大约 26 毫秒，而不是 10,000 个哈希表的 11 毫秒！
- en: After inserting the 67th element, the time required to insert additional elements
    drops to about 10 ms or 11 ms and then slowly increases again from there.
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在插入第 67 个元素后，插入其他元素所需的时间降至约 10 毫秒或 11 毫秒，然后从此处开始缓慢增加。
- en: What’s going on here? Well, Ruby spends the extra time required to insert that
    67th key/value pair reallocating the bin array from 11 to 19 bins and then reassigning
    the `st_table_entry` structures to the new bin array.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 这里发生了什么？嗯，Ruby 花费额外时间来插入第 67 个键值对，将桶数组从 11 个桶重新分配到 19 个桶，然后将 `st_table_entry`
    结构重新分配到新的桶数组中。
- en: '[Figure 7-8](ch07.html#time_required_to_add_10comma000_keysolid "Figure 7-8. Time
    required to add 10,000 key/value pairs vs. hash size (Ruby 2.0)") shows the same
    graph for Ruby 2.0\. This time the bin density threshold is different. Instead
    of taking extra time to reallocate the elements into bins on the 67th insert,
    Ruby 2.0 does it when the 57th element is inserted. Later Ruby 2.0 performs another
    reallocation after the 97th element is inserted.'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 7-8](ch07.html#time_required_to_add_10comma000_keysolid "图 7-8. 添加 10,000
    对键值对所需的时间与哈希表大小的关系（Ruby 2.0）") 显示了 Ruby 2.0 的相同图表。这次的桶密度阈值有所不同。Ruby 2.0 在插入第 57
    个元素时就开始重新分配元素到桶中，而不是像之前在第 67 次插入时才进行这项操作。随后，Ruby 2.0 在插入第 97 个元素后再次进行重新分配。'
- en: '![Time required to add 10,000 key/value pairs vs. hash size (Ruby 2.0)](httpatomoreillycomsourcenostarchimages1854159.png.jpg)'
  id: totrans-112
  prefs: []
  type: TYPE_IMG
  zh: '![添加 10,000 对键值对所需的时间与哈希表大小的关系（Ruby 2.0）](httpatomoreillycomsourcenostarchimages1854159.png.jpg)'
- en: Figure 7-8. Time required to add 10,000 key/value pairs vs. hash size (Ruby
    2.0)
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7-8. 添加 10,000 对键值对所需的时间与哈希表大小的关系（Ruby 2.0）
- en: The two smaller spikes on the 1st and 7th insert in this figure are curious.
    While not as pronounced as the spikes at the 57th and 97th elements, these smaller
    spikes are nonetheless noticeable. As it turns out, Ruby 2.0 contains another
    optimization that speeds up hash access even more for small hashes that contain
    less than 7 elements. I’ll discuss this further in [Hash Optimization in Ruby
    2.0](ch07.html#hash_optimization_in_ruby_2dot0 "Hash Optimization in Ruby 2.0").
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 在图中，第一次和第七次插入时出现的两个较小的尖峰非常引人注目。尽管它们不像第 57 和第 97 个元素处的尖峰那样明显，但这些较小的尖峰仍然是可以察觉的。事实证明，Ruby
    2.0 还包含另一个优化，使得在包含少于 7 个元素的小哈希表中，哈希访问速度更快。我将在[Ruby 2.0 中的哈希优化](ch07.html#hash_optimization_in_ruby_2dot0
    "Ruby 2.0 中的哈希优化")中进一步讨论这个问题。
- en: Where Do the Magic Numbers 57 and 67 Come From?
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 魔术数字 57 和 67 从哪里来？
- en: To see where these magic numbers come from (57, 67, and so on), look at the
    top of the *st.c* code file for your version of Ruby. You should find a list of
    prime numbers like the ones shown in [Example 7-4](ch07.html#ruby_uses_an_algorithm_based_on_prime_nu
    "Example 7-4. Ruby uses an algorithm based on prime numbers to determine the number
    of buckets required in each hash table.").
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解这些魔法数字（57、67等）是从哪里来的，查看你所使用的 Ruby 版本的*st.c*代码文件顶部。你应该能找到像[示例 7-4](ch07.html#ruby_uses_an_algorithm_based_on_prime_nu
    "示例 7-4. Ruby 使用基于素数的算法来确定每个哈希表中所需的桶数")中所示的素数列表。
- en: Example 7-4. Ruby uses an algorithm based on prime numbers to determine the
    number of buckets required in each hash table.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 7-4. Ruby 使用基于素数的算法来确定每个哈希表中所需的桶数。
- en: '[PRE13]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: This C array lists some prime numbers that occur near powers of 2\. Peter Moore’s
    hash table code uses this table to decide how many bins to use in the hash table.
    For example, the first prime number in the list above is 11 at ![](httpatomoreillycomsourcenostarchimages1853843.png.jpg),
    which is why Ruby hash tables start with 11 bins. Later, as the number of elements
    increases, the number of bins increases to 19 at ![](httpatomoreillycomsourcenostarchimages1853845.png.jpg),
    then to 37 at ![](httpatomoreillycomsourcenostarchimages1853847.png.jpg), and
    so on.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 这个 C 数组列出了接近 2 的幂的素数。Peter Moore 的哈希表代码使用这个表来决定在哈希表中使用多少个桶。例如，上面列表中的第一个素数是 11，在
    ![](httpatomoreillycomsourcenostarchimages1853843.png.jpg)，这就是为什么 Ruby 哈希表一开始有
    11 个桶。后来，随着元素数量的增加，桶的数量增加到 19，在 ![](httpatomoreillycomsourcenostarchimages1853845.png.jpg)，接着是
    37，在 ![](httpatomoreillycomsourcenostarchimages1853847.png.jpg)，依此类推。
- en: Ruby always sets the number of hash table bins to a prime number in order to
    make it more likely that the hash values will be evenly distributed among the
    bins. Mathematically, prime numbers help here because they are less likely to
    share a common factor with the hash values, should a poor hash function return
    not entirely random values. Remember Ruby divides the hash values by the number
    of bins while calculating which bin to place the value into. If the hash values
    and bin count shared a factor, or even worse if the hash values were multiples
    of the bin count, the bin number (modulus) might always be the same. This would
    lead to the table entries being unevenly distributed among the bins.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: Ruby 总是将哈希表桶的数量设置为素数，以便更有可能使哈希值在桶之间均匀分布。在数学上，素数在这里的作用是因为它们与哈希值共享的因子较少，如果一个较差的哈希函数返回的哈希值不完全随机的话。记住，Ruby
    在计算应该将值放入哪个桶时，会将哈希值除以桶的数量。如果哈希值和桶的数量有共同因子，甚至更糟的是，如果哈希值是桶数量的倍数，那么桶号（模数）可能总是相同的。这将导致表中的条目在桶之间分布不均。
- en: 'Elsewhere in the *st.c* file, you should see this C constant:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 在 *st.c* 文件的其他地方，你应该能看到这个 C 常量：
- en: '[PRE14]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: This constant defines the maximum allowed density, or the average number of
    elements per bin.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 这个常量定义了允许的最大密度，或者说每个桶中的平均元素数量。
- en: 'Finally, you should see the code that decides when to perform a bin reallocation
    by finding where the constant `ST_DEFAULT_MAX_DENSITY` is used in *st.c*. For
    Ruby 1.8, you’ll find this code:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，你应该能看到决定何时执行桶重新分配的代码，方法是查找在*st.c*中使用常量`ST_DEFAULT_MAX_DENSITY`的地方。对于 Ruby
    1.8，你将看到这段代码：
- en: '[PRE15]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Ruby 1.8 rehashes from 11 to 19 bins when the value `num_entries/11` is greater
    than 5—that is, when it equals 66\. As this check is performed before a new element
    is added, the condition becomes true when you add the 67th element because `num_entries`
    would then be 66.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: Ruby 1.8 在 `num_entries/11` 大于 5 时（即当它等于 66）会将桶从 11 重新哈希到 19。由于这个检查是在添加新元素之前进行的，所以当你添加第
    67 个元素时条件成立，因为此时 `num_entries` 会是 66。
- en: 'For Ruby 1.9 and Ruby 2.0, you’ll find this code instead:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 Ruby 1.9 和 Ruby 2.0，你将看到以下代码：
- en: '[PRE16]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: You can see that Ruby 2.0 rehashes for the first time when `num_entries` is
    greater than 5*11, or when you insert the 57th element.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以看到，Ruby 2.0 在 `num_entries` 大于 5*11 时首次重新哈希，或者当你插入第 57 个元素时。
- en: How Ruby Implements Hash Functions
  id: totrans-130
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Ruby 如何实现哈希函数
- en: Now for a closer look at the actual hash function Ruby uses to assign keys and
    values to bins in hash tables. This function is central to the way the hash object
    is implemented—if it works well, Ruby hashes are fast, but a poor hash function
    can cause severe performance problems. Furthermore, Ruby uses hash tables internally
    to store its own information, in addition to the data values you save in hash
    objects. Clearly having a good hash function is very important!
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，仔细看看 Ruby 用于将键和值分配到哈希表中的桶的实际哈希函数。这个函数是哈希对象实现的核心——如果它运作良好，Ruby 哈希非常快速，但一个糟糕的哈希函数会导致严重的性能问题。此外，Ruby
    内部使用哈希表来存储其自身的信息，除了你保存在哈希对象中的数据值之外。显然，拥有一个好的哈希函数是非常重要的！
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages1854161.png.jpg)'
  id: totrans-132
  prefs: []
  type: TYPE_IMG
  zh: '![无标题图片](httpatomoreillycomsourcenostarchimages1854161.png.jpg)'
- en: '*Hash functions allow Ruby to find which bin contains a given key and value.*'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: '*哈希函数允许 Ruby 找到包含给定键和值的桶。*'
- en: Let’s review how Ruby uses hash values. Remember that when you save a new element
    in a hash—a new key/value pair—Ruby assigns that element to a bin inside the internal
    hash table used by that hash object, as shown in [Figure 7-9](ch07.html#ruby_hash_object_containing_a_si-id00025
    "Figure 7-9. A Ruby hash object containing a single value (repeated from Figure 7-2)").
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回顾一下 Ruby 如何使用哈希值。记住，当你在哈希中保存一个新元素——即一个新的键/值对——Ruby 会将该元素分配到哈希对象使用的内部哈希表中的一个桶（bin）里，如
    [图7-9](ch07.html#ruby_hash_object_containing_a_si-id00025 "图7-9. 一个包含单个值的 Ruby
    哈希对象（重复自图7-2）") 所示。
- en: Ruby calculates the modulus of the key’s hash value based on the number of bins.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: Ruby 根据桶的数量计算键的哈希值的余数。
- en: '[PRE17]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Using the same example values we used earlier, this formula becomes:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 使用我们之前使用的相同示例值，这个公式变成了：
- en: '[PRE18]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: '![A Ruby hash object containing a single value (repeated from )](httpatomoreillycomsourcenostarchimages1854163.png.jpg)'
  id: totrans-139
  prefs: []
  type: TYPE_IMG
  zh: '![一个包含单个值的 Ruby 哈希对象（重复自）](httpatomoreillycomsourcenostarchimages1854163.png.jpg)'
- en: Figure 7-9. A Ruby hash object containing a single value (repeated from [Figure 7-2](ch07.html#ruby_hash_object_containing_a_single_v
    "Figure 7-2. A Ruby hash object containing a single value"))
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 图7-9. 一个包含单个值的 Ruby 哈希对象（重复自 [图7-2](ch07.html#ruby_hash_object_containing_a_single_v
    "图7-2. 一个包含单个值的 Ruby 哈希对象")）
- en: This formula works well because Ruby’s hash values are basically random integers
    for any given input data. To get a feel for how Ruby’s hash function works, call
    the `hash` method, as shown in [Example 7-5](ch07.html#displaying_the_hash_value_for_different
    "Example 7-5. Displaying the hash value for different Ruby objects").
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 这个公式之所以有效，是因为 Ruby 的哈希值对于任何给定的输入数据基本上是随机整数。为了更好地理解 Ruby 的哈希函数如何工作，可以调用 `hash`
    方法，如 [示例7-5](ch07.html#displaying_the_hash_value_for_different "示例7-5. 显示不同 Ruby
    对象的哈希值") 所示。
- en: Example 7-5. Displaying the hash value for different Ruby objects
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 示例7-5. 显示不同 Ruby 对象的哈希值
- en: '[PRE19]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Here, even similar values have very different hash values. And if we call `hash`
    again, we always get the same integer value for the same input data.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，即使是相似的值，它们的哈希值也有很大的不同。如果我们再次调用`hash`，对于相同的输入数据，我们总是会得到相同的整数值。
- en: '[PRE20]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Here’s how Ruby’s hash function actually works for most Ruby objects:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是 Ruby 哈希函数如何实际运作的说明，适用于大多数 Ruby 对象：
- en: When you call `hash`, Ruby finds the default implementation in the `Object`
    class. You can override this if you want to.
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当你调用`hash`时，Ruby 会在 `Object` 类中找到默认的实现。如果需要，你可以重写它。
- en: The C code used by the `Object` class’s implementation of the `hash` method
    gets the C pointer value for the target object—that is, the actual memory address
    of that object’s `RValue` structure. This is essentially a unique ID for that
    object.
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Object` 类的 `hash` 方法实现所使用的 C 代码获取目标对象的 C 指针值——即该对象 `RValue` 结构的实际内存地址。这本质上是该对象的唯一
    ID。'
- en: Ruby passes the pointer value through a complex C function (the hash function),
    which scrambles the bits in the value, producing a pseudo-random integer in a
    repeatable way.
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Ruby 将指针值传递给一个复杂的 C 函数（哈希函数），该函数会打乱值中的位，从而以可重复的方式生成一个伪随机整数。
- en: In the case of strings and arrays, Ruby actually iterates through all of the
    characters in the string or the elements in the array and calculates a cumulative
    hash value. This guarantees that the hash will always be the same for any instance
    of a string or array and that it will change if any of the values in the string
    or array change. Integers and symbols are another special case. Ruby just passes
    their values right to the hash function.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 对于字符串和数组，Ruby 实际上会遍历字符串中的所有字符或数组中的所有元素，并计算一个累积的哈希值。这保证了字符串或数组的任何实例的哈希值总是相同的，并且如果字符串或数组中的任何值发生变化，哈希值也会随之变化。整数和符号是另一种特殊情况。Ruby
    直接将它们的值传递给哈希函数。
- en: 'To calculate hashes from values, Ruby 1.9 and 2.0 use a hash function called
    *MurmurHash*, which was invented by Austin Appleby in 2008\. The name *Murmur*
    comes from the machine language operations used in the algorithm: *multiply* and
    *rotate*. (To learn how the Murmur algorithm actually works, read its C code in
    the *st.c* Ruby source code file. Or read Austin’s web page on Murmur: *[http://sites.google.com/site/murmurhash/](http://sites.google.com/site/murmurhash/)*.)'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 为了从值中计算哈希，Ruby 1.9 和 2.0 使用一种叫做 *MurmurHash* 的哈希函数，它是由 Austin Appleby 在 2008
    年发明的。*Murmur* 这个名字来自于该算法中使用的机器语言操作：*multiply* 和 *rotate*。（要了解 Murmur 算法是如何工作的，可以阅读其
    C 语言代码，该代码在 *st.c* Ruby 源代码文件中。或者阅读 Austin 关于 Murmur 的网页：*[http://sites.google.com/site/murmurhash/](http://sites.google.com/site/murmurhash/)*。）
- en: Ruby 1.9 and 2.0 initialize MurmurHash using a random seed value that is reinitialized
    each time you restart Ruby. This means that if you stop and restart Ruby, you’ll
    get different hash values for the same input data. It also means that if you try
    this yourself, you’ll get different values than those above, but the hash values
    will always be the same within the same Ruby process.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: Ruby 1.9 和 2.0 使用一个随机种子值初始化 MurmurHash，该值在每次重新启动 Ruby 时都会重新初始化。这意味着如果你停止并重新启动
    Ruby，你将会得到相同输入数据的不同哈希值。这也意味着如果你自己尝试，你将会得到与上面不同的值，但在同一个 Ruby 进程中，哈希值始终是相同的。
- en: 'Experiment 7-3: Using Objects as Keys in a Hash'
  id: totrans-153
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实验 7-3：在哈希中使用对象作为键
- en: Because hash values are pseudorandom numbers, once Ruby divides them by the
    bin count, say 11, the remaining values (the modulus values) are random numbers
    between 0 and 10\. This means that the `st_table_entry` structures are evenly
    distributed over the available bins as they are saved in the hash table, which
    ensures that Ruby will be able to quickly find any given key. The number of entries
    per bin will always be small.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 因为哈希值是伪随机数，一旦 Ruby 将其除以桶的数量，例如 11，剩余的值（模值）就是 0 到 10 之间的随机数。这意味着当 `st_table_entry`
    结构保存在哈希表中时，它们会均匀地分布在可用的桶中，从而确保 Ruby 可以快速查找任何给定的键。每个桶中的条目数始终很少。
- en: But what if Ruby’s hash function didn’t return random integers but rather returned
    the same integer for every input data value? What would happen?
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，如果 Ruby 的哈希函数不返回随机整数，而是对于每个输入数据值返回相同的整数，会发生什么呢？
- en: In that case, every time you added a key/value to a hash, it would always be
    assigned to the same bin. Ruby would end up with all of the entries in a single
    long list under that one bin, with no entries in any other bin, as shown in [Figure 7-10](ch07.html#hash_table_created_with_a_very_poor_ha
    "Figure 7-10. A hash table created with a very poor hash function").
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，每次你向哈希中添加键/值时，它总是会被分配到同一个桶。Ruby 最终会将所有条目都放在该一个桶下的一个长列表中，而其他任何桶中都没有条目，正如在[图
    7-10](ch07.html#hash_table_created_with_a_very_poor_ha "图 7-10。使用非常差的哈希函数创建的哈希表")中所示。
- en: '![A hash table created with a very poor hash function](httpatomoreillycomsourcenostarchimages1854165.png.jpg)'
  id: totrans-157
  prefs: []
  type: TYPE_IMG
  zh: '![使用非常差的哈希函数创建的哈希表](httpatomoreillycomsourcenostarchimages1854165.png.jpg)'
- en: Figure 7-10. A hash table created with a very poor hash function
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7-10。使用非常差的哈希函数创建的哈希表
- en: If you tried to retrieve a value from this hash, Ruby would have to look through
    this long list, one element at a time, to find the requested key. In this scenario,
    loading a value from the hash would be very, very slow.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你尝试从这个哈希中检索一个值，Ruby 就必须一个一个地查找这个长列表中的每个元素，以找到请求的键。在这种情况下，从哈希中加载一个值将会非常非常慢。
- en: 'To prove this is the case—and to illustrate just how important Ruby’s hash
    function really is—we’ll use objects with poor hash functions as keys in a hash.
    We’ll repeat [Experiment 7-1: Retrieving a Value from Hashes of Varying Sizes](ch07.html#experiment_7-1_retrieving_a_value_from_h
    "Experiment 7-1: Retrieving a Value from Hashes of Varying Sizes") here, but we’ll
    use instances of a class I defined as the key values instead of random numbers.
    [Example 7-6](ch07.html#measuring_how_long_it_takes_to_r-id00026 "Example 7-6. Measuring
    how long it takes to retrieve an element from hashes of wildly different sizes.
    This is the same as Example 7-1, but using instances of KeyObject as keys.") shows
    the code from [Experiment 7-1: Retrieving a Value from Hashes of Varying Sizes](ch07.html#experiment_7-1_retrieving_a_value_from_h
    "Experiment 7-1: Retrieving a Value from Hashes of Varying Sizes"), updated in
    two places.'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 为了证明这一点，并且说明 Ruby 的哈希函数有多重要，我们将使用哈希函数较差的对象作为哈希中的键。我们将在这里重复[实验 7-1：从大小差异的哈希中检索值](ch07.html#experiment_7-1_retrieving_a_value_from_h
    "实验 7-1：从大小差异的哈希中检索值")，但这次使用我定义的类的实例作为键值，而不是随机数。[示例 7-6](ch07.html#measuring_how_long_it_takes_to_r-id00026
    "示例 7-6. 测量从大小差异极大的哈希中检索元素所需的时间。这与示例 7-1相同，只不过使用的是`KeyObject`实例作为键。")展示了[实验 7-1：从大小差异的哈希中检索值](ch07.html#experiment_7-1_retrieving_a_value_from_h
    "实验 7-1：从大小差异的哈希中检索值")的代码，并且做了两处更新。
- en: Example 7-6. Measuring how long it takes to retrieve an element from hashes
    of wildly different sizes. This is the same as [Example 7-1](ch07.html#measuring_how_long_it_takes_to_retrieve
    "Example 7-1. Measuring how long it takes to retrieve an element from hashes of
    wildly different sizes"), but using instances of `KeyObject` as keys.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 7-6. 测量从大小差异极大的哈希中检索元素所需的时间。这与[示例 7-1](ch07.html#measuring_how_long_it_takes_to_retrieve
    "示例 7-1. 测量从大小差异极大的哈希中检索元素所需的时间")相同，只不过这次使用的是`KeyObject`实例作为键。
- en: '[PRE21]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: At ![](httpatomoreillycomsourcenostarchimages1853843.png.jpg) we define an empty
    class called `KeyObject`. Note that I implemented the `eql?` method; this allows
    Ruby to search for the target key properly when I retrieve a value. However, in
    this example, I don’t have any interesting data in `KeyObject`, so I simply call
    `super` and use the default implementation of `eql?` in the `Object` class.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 在 ![](httpatomoreillycomsourcenostarchimages1853843.png.jpg) 处，我们定义了一个名为`KeyObject`的空类。注意，我实现了`eql?`方法；这使得
    Ruby 在检索值时能够正确地搜索目标键。然而，在这个示例中，`KeyObject`中没有任何有趣的数据，因此我只是调用了`super`并使用了`Object`类中`eql?`方法的默认实现。
- en: Then, at ![](httpatomoreillycomsourcenostarchimages1853845.png.jpg) we use new
    instances of `KeyObject` as the keys for my hash values. [Figure 7-11](ch07.html#time_to_retrieve_10comma000_values_vsdot
    "Figure 7-11. Time to retrieve 10,000 values vs. hash size, using objects as keys
    (Ruby 2.0)") shows the results of this test.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，在 ![](httpatomoreillycomsourcenostarchimages1853845.png.jpg) 处，我们使用`KeyObject`的新实例作为哈希值的键。[图
    7-11](ch07.html#time_to_retrieve_10comma000_values_vsdot "图 7-11. 使用对象作为键时，检索
    10,000 个值的时间与哈希大小的关系（Ruby 2.0）")展示了这个测试的结果。
- en: '![Time to retrieve 10,000 values vs. hash size, using objects as keys (Ruby
    2.0)](httpatomoreillycomsourcenostarchimages1854167.png)'
  id: totrans-165
  prefs: []
  type: TYPE_IMG
  zh: '![使用对象作为键时，检索 10,000 个值的时间与哈希大小的关系（Ruby 2.0）](httpatomoreillycomsourcenostarchimages1854167.png)'
- en: Figure 7-11. Time to retrieve 10,000 values vs. hash size, using objects as
    keys (Ruby 2.0)
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7-11. 使用对象作为键时，检索 10,000 个值的时间与哈希大小的关系（Ruby 2.0）
- en: As you can see, the results are very similar to those in [Figure 7-4](ch07.html#time_to_retrieve_10comma000_values_left
    "Figure 7-4. Time to retrieve 10,000 values (ms) vs. hash size for Ruby 2.0").
    The chart is more or less flat. It takes about the same amount of time to retrieve
    a value from a hash with 1 million elements as it does for a hash with just 1
    element. No surprise there; using objects as keys hasn’t slowed down Ruby at all.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，结果与[图 7-4](ch07.html#time_to_retrieve_10comma000_values_left "图 7-4. Ruby
    2.0：检索 10,000 个值的时间（毫秒）与哈希大小的关系")非常相似。图表几乎是平的。无论哈希中有 100 万个元素还是只有 1 个元素，检索一个值所需的时间差不多。毫无意外；使用对象作为键并没有让
    Ruby 变慢。
- en: Now let’s change the `KeyObject` class and try again. [Example 7-7](ch07.html#keyobject_now_has_a_very_poor_hash_funct
    "Example 7-7. KeyObject now has a very poor hash function.") shows the same code
    with a new hash function added at ![](httpatomoreillycomsourcenostarchimages1853843.png.jpg).
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们改变`KeyObject`类并再试一次。[示例 7-7](ch07.html#keyobject_now_has_a_very_poor_hash_funct
    "示例 7-7. `KeyObject`现在有一个非常差的哈希函数。")展示了相同的代码，并在 ![](httpatomoreillycomsourcenostarchimages1853843.png.jpg)
    处添加了一个新的哈希函数。
- en: Example 7-7. `KeyObject` now has a very poor hash function.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 示例7-7. `KeyObject`现在有一个非常差的哈希函数。
- en: '[PRE22]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: I’ve purposefully written a very poor hash function. Instead of returning a
    pseudorandom integer, the hash function in [Example 7-7](ch07.html#keyobject_now_has_a_very_poor_hash_funct
    "Example 7-7. KeyObject now has a very poor hash function.") always returns the
    integer 4 at ![](httpatomoreillycomsourcenostarchimages1853843.png.jpg), regardless
    of which `KeyObject` object instance you call it on. Now Ruby will always get
    4 when it calculates the hash value. It will have to assign all of the hash elements
    to bin number 4 in the internal hash table, as in [Figure 7-10](ch07.html#hash_table_created_with_a_very_poor_ha
    "Figure 7-10. A hash table created with a very poor hash function").
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 我故意编写了一个非常差的哈希函数。这个哈希函数不像返回伪随机整数，而是始终返回整数4，正如在[示例7-7](ch07.html#keyobject_now_has_a_very_poor_hash_funct
    "示例7-7. KeyObject现在有一个非常差的哈希函数。")中所示，不管你在哪个`KeyObject`对象实例上调用它。现在，Ruby在计算哈希值时总是会得到4。它将必须将所有哈希元素都分配到内部哈希表中的4号桶里，正如在[图7-10](ch07.html#hash_table_created_with_a_very_poor_ha
    "图7-10. 使用非常差的哈希函数创建的哈希表")所示。
- en: Let’s try this to see what happens! [Figure 7-12](ch07.html#time_to_retrieve_10comma000_valu-id00027
    "Figure 7-12. Time to retrieve 10,000 values vs. hash size, using a poor hash
    function (Ruby 2.0)") shows the results of running the code from [Example 7-7](ch07.html#keyobject_now_has_a_very_poor_hash_funct
    "Example 7-7. KeyObject now has a very poor hash function.").
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来尝试一下，看看会发生什么！[图7-12](ch07.html#time_to_retrieve_10comma000_valu-id00027
    "图7-12. 使用较差哈希函数（Ruby 2.0）时，检索10,000个值所需的时间与哈希大小的关系") 显示了运行[示例7-7](ch07.html#keyobject_now_has_a_very_poor_hash_funct
    "示例7-7. KeyObject现在有一个非常差的哈希函数。")代码的结果。
- en: '![Time to retrieve 10,000 values vs. hash size, using a poor hash function
    (Ruby 2.0)](httpatomoreillycomsourcenostarchimages1854169.png.jpg)'
  id: totrans-173
  prefs: []
  type: TYPE_IMG
  zh: '![使用较差哈希函数（Ruby 2.0）时，检索10,000个值所需的时间与哈希大小的关系](httpatomoreillycomsourcenostarchimages1854169.png.jpg)'
- en: Figure 7-12. Time to retrieve 10,000 values vs. hash size, using a poor hash
    function (Ruby 2.0)
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 图7-12. 使用较差哈希函数（Ruby 2.0）时，检索10,000个值所需的时间与哈希大小的关系
- en: '[Figure 7-12](ch07.html#time_to_retrieve_10comma000_valu-id00027 "Figure 7-12. Time
    to retrieve 10,000 values vs. hash size, using a poor hash function (Ruby 2.0)")
    is very different from [Figure 7-11](ch07.html#time_to_retrieve_10comma000_values_vsdot
    "Figure 7-11. Time to retrieve 10,000 values vs. hash size, using objects as keys
    (Ruby 2.0)")! Notice the scale of the graph. The y-axis shows milliseconds, and
    the x-axis shows the number of elements in the hash on a logarithmic scale. But
    this time, notice that we have thousands of milliseconds—which means actual seconds—on
    the y-axis!'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: '[图7-12](ch07.html#time_to_retrieve_10comma000_valu-id00027 "图7-12. 使用较差哈希函数（Ruby
    2.0）时，检索10,000个值所需的时间与哈希大小的关系") 与 [图7-11](ch07.html#time_to_retrieve_10comma000_values_vsdot
    "图7-11. 使用对象作为键时，检索10,000个值所需的时间与哈希大小的关系（Ruby 2.0）") 有很大的不同！注意图表的比例。y轴显示的是毫秒，x轴则是哈希中元素的数量，以对数尺度显示。但这次请注意，y轴上有数千毫秒——也就是说，实际的秒数！'
- en: With one or a few elements, we can retrieve the 10,000 values very quickly—so
    quickly that the time is too small to appear on this graph. In fact, it takes
    about the same 1.5 ms. However, when the number of elements increases past 100
    and especially 1,000, the time required to load the 10,000 values increases linearly
    with the hash size. For a hash containing about 10,000 elements, it takes over
    1.6 full seconds to load the 10,000 values. If we continued the test with larger
    hashes, it would take minutes or even hours to load the values.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 使用一个或少数几个元素，我们可以非常快速地检索到10,000个值——如此之快，时间短到在图表上无法显示。事实上，这大约需要1.5毫秒。然而，当元素数量超过100，尤其是超过1,000时，加载10,000个值所需的时间会随着哈希大小的增加而线性增长。对于一个包含大约10,000个元素的哈希表，加载这10,000个值需要超过1.6秒。如果我们继续用更大的哈希表进行测试，加载这些值可能需要几分钟甚至几小时。
- en: What’s happening here is that all of the hash elements are saved into the same
    bin, forcing Ruby to search through the list one key at a time.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 这里发生的情况是，所有哈希元素都被保存到同一个桶中，这迫使Ruby一个一个地查找键。
- en: Hash Optimization in Ruby 2.0
  id: totrans-178
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Ruby 2.0中的哈希优化
- en: Starting with version 2.0, Ruby introduced a new optimization to make hashes
    work even faster. For hashes that contain 6 or fewer elements, Ruby now avoids
    calculating the hash value entirely and simply saves the hash data in an array.
    These are known as *packed hashes*. [Figure 7-13](ch07.html#internallycomma_ruby_2dot0_saves_small_h
    "Figure 7-13. Internally, Ruby 2.0 saves small hashes with 6 or fewer elements
    as arrays.") shows a packed hash.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 从 2.0 版本开始，Ruby 引入了一种新的优化，使得哈希表的运作更快。对于包含 6 个或更少元素的哈希表，Ruby 现在完全避免计算哈希值，而是将哈希数据直接保存为数组。这些被称为
    *紧凑哈希表*。[图 7-13](ch07.html#internallycomma_ruby_2dot0_saves_small_h "图 7-13。内部，Ruby
    2.0 将包含 6 个或更少元素的小哈希表保存为数组。") 显示了一个紧凑的哈希表。
- en: '![Internally, Ruby 2.0 saves small hashes with 6 or fewer elements as arrays.](httpatomoreillycomsourcenostarchimages1854171.png.jpg)'
  id: totrans-180
  prefs: []
  type: TYPE_IMG
  zh: '![在内部，Ruby 2.0 将包含 6 个或更少元素的小哈希表保存为数组。](httpatomoreillycomsourcenostarchimages1854171.png.jpg)'
- en: Figure 7-13. Internally, Ruby 2.0 saves small hashes with 6 or fewer elements
    as arrays.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7-13。内部，Ruby 2.0 将包含 6 个或更少元素的小哈希表保存为数组。
- en: Ruby 2.0 doesn’t use the `st_table_entry` structure for small hashes, nor does
    it create a table of bins. Instead, it creates an array and saves the key/value
    pairs directly into this array. The array is large enough to fit 6 key/value pairs;
    once you insert a 7th key and value, Ruby discards the array, creates the bin
    array, and moves all 7 elements into `st_table_entry` structures as usual by calculating
    hash values. This explains the small spike we saw inserting the 7th element in
    [Figure 7-8](ch07.html#time_required_to_add_10comma000_keysolid "Figure 7-8. Time
    required to add 10,000 key/value pairs vs. hash size (Ruby 2.0)"). `real_entries`
    saves the number of values saved in the array between 0 and 6.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: Ruby 2.0 不使用 `st_table_entry` 结构来处理小哈希表，也不创建桶数组。相反，它创建一个数组，并将键/值对直接保存到该数组中。这个数组足够大，可以容纳
    6 个键/值对；一旦插入第 7 个键和值，Ruby 就会丢弃该数组，创建桶数组，并像往常一样通过计算哈希值将所有 7 个元素移动到 `st_table_entry`
    结构中。这解释了我们在插入第 7 个元素时在[图 7-8](ch07.html#time_required_to_add_10comma000_keysolid
    "图 7-8。插入 10,000 个键/值对所需的时间与哈希表大小（Ruby 2.0）")中看到的小幅波动。`real_entries` 保存数组中保存的值的数量，范围从
    0 到 6。
- en: In a packed hash, there are only 6 or fewer elements; thus, it’s faster for
    Ruby to iterate over the key values looking for a target value than it would be
    to calculate a hash value and use a bin array. [Figure 7-14](ch07.html#for_small_hashescomma_ruby_2dot0_iterate
    "Figure 7-14. For small hashes, Ruby 2.0 iterates over the array to find a given
    key.") shows how Ruby 2.0 retrieves an element from a packed hash.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 在一个紧凑的哈希表中，只有 6 个或更少的元素；因此，Ruby 遍历键值寻找目标值的速度比计算哈希值并使用桶数组要快。[图 7-14](ch07.html#for_small_hashescomma_ruby_2dot0_iterate
    "图 7-14。对于小哈希表，Ruby 2.0 通过遍历数组来查找给定的键。") 显示了 Ruby 2.0 如何从紧凑的哈希表中获取一个元素。
- en: To find the value for a given key of `target`, Ruby iterates through the array
    and calls the `eql?` method on each key value if the values are objects. For simple
    values, such as integers or symbols, Ruby just uses a numerical comparison. Ruby
    2.0 never calls the hash function at all for packed hashes.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 要查找给定键 `target` 的值，Ruby 会遍历数组并在每个键值上调用 `eql?` 方法（如果值是对象）。对于简单的值，如整数或符号，Ruby
    直接使用数值比较。Ruby 2.0 对于紧凑哈希表从不调用哈希函数。
- en: '![For small hashes, Ruby 2.0 iterates over the array to find a given key.](httpatomoreillycomsourcenostarchimages1854173.png.jpg)'
  id: totrans-185
  prefs: []
  type: TYPE_IMG
  zh: '![对于小哈希表，Ruby 2.0 通过遍历数组来查找给定的键。](httpatomoreillycomsourcenostarchimages1854173.png.jpg)'
- en: Figure 7-14. For small hashes, Ruby 2.0 iterates over the array to find a given
    key.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7-14。对于小哈希表，Ruby 2.0 通过遍历数组来查找给定的键。
- en: Summary
  id: totrans-187
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: Understanding hash tables is key to understanding how Ruby works internally
    because the speed and flexibility of hash tables allow Ruby to use them in many
    ways.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 理解哈希表是理解 Ruby 内部工作原理的关键，因为哈希表的速度和灵活性使得 Ruby 能够以多种方式使用它们。
- en: At the beginning of this chapter, we learned how hash tables are able to return
    values quickly, regardless of how many elements are in the table. Next, we learned
    how Ruby automatically increases the size of a hash table as you add more and
    more elements to it. The user of the hash table doesn’t need to worry about how
    fast or large the table is. Hash tables will always be fast and will automatically
    expand as necessary.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章开始时，我们学习了哈希表如何能够快速返回值，无论表中有多少元素。接下来，我们学习了 Ruby 如何在你添加更多元素时自动增大哈希表的大小。哈希表的用户无需担心表的速度或大小。哈希表始终会保持快速，并会根据需要自动扩展。
- en: Finally, we looked at the importance of Ruby’s hash function. The hash table’s
    algorithm depends on the underlying hash function. With an effective hash function,
    values are evenly distributed across the bins in the hash table with few collisions,
    allowing them to be saved and retrieved quickly. However, with a poor hash function,
    values would be saved in the same bin, leading to poor performance.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们看了 Ruby 哈希函数的重要性。哈希表的算法依赖于底层的哈希函数。使用有效的哈希函数时，值会在哈希表的桶中均匀分布，碰撞较少，从而使得数据能够快速保存和检索。然而，如果使用一个差的哈希函数，值将会被保存到同一个桶中，导致性能下降。
