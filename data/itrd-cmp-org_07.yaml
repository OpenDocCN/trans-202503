- en: '**7'
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '**7'
- en: SEQUENTIAL LOGIC CIRCUITS**
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 顺序逻辑电路**
- en: '![Image](../images/pg23_Image_2.jpg)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/pg23_Image_2.jpg)'
- en: 'In the previous chapter, you learned about combinational logic circuits, which
    are circuits that depend only on their current input. Another way of thinking
    about this is that combinational logic circuits are instantaneous (except for
    the time required for the electronics to settle): their output depends only on
    the input at the time the output is observed. *Sequential logic circuits*, on
    the other hand, depend on both the current and past inputs. They have a time history,
    which can be summarized by the current state of the circuit.'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，你学习了组合逻辑电路，它们仅依赖于当前的输入。换句话说，组合逻辑电路是瞬时的（除了电子元件需要的稳定时间）：它们的输出仅依赖于在观察输出时的输入。另一方面，*顺序逻辑电路*依赖于当前输入和过去输入。它们有一个时间历史，可以通过电路的当前状态来总结。
- en: Formally, the *system state* is a description of the system such that the state
    at time *t*[0] and the inputs from time *t*[0] through time *t*[1] uniquely determines
    the state at time *t*[1] and the outputs from time *t*[0] through time *t*[1].
    In other words, the system state provides a summary of everything that has affected
    the system. Knowing the state of a system at any given time *t* tells you everything
    you need to know to specify the system’s behavior from that time on. How it got
    into that state is irrelevant.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 从形式上讲，*系统状态*是对系统的一种描述，使得在时间 *t*[0] 时的状态和从时间 *t*[0] 到时间 *t*[1] 的输入能够唯一地确定在时间
    *t*[1] 时的状态，以及从时间 *t*[0] 到时间 *t*[1] 的输出。换句话说，系统状态提供了影响系统的所有因素的总结。知道系统在任意时刻 *t*
    的状态，你就能知道从此时起系统的行为如何。这些状态是如何产生的则无关紧要。
- en: The concept of system state is captured in a *finite state machine*, a mathematical
    model of computation that exists in any one of a finite number of states. External
    inputs to a finite state machine cause it to transition from one state to another
    or to the same state, while possibly producing an output. Sequential logic circuits
    are used to implement finite state machines. If a sequential logic circuit is
    designed such that its output depends only on the state it’s in, it’s called a
    *Moore state machine*. If the output also depends on the input causing a transition
    to a state, it’s called a *Mealy state machine*.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 系统状态的概念通过*有限状态机*得以体现，有限状态机是一种计算的数学模型，它存在于有限个状态中的某一个。有限状态机的外部输入使得它从一个状态转移到另一个状态，或者保持在同一状态，同时可能产生一个输出。顺序逻辑电路用于实现有限状态机。如果一个顺序逻辑电路的输出仅依赖于它所处的状态，那么它被称为*摩尔状态机*。如果输出还依赖于导致状态转换的输入，那么它被称为*梅利状态机*。
- en: In this chapter, you’ll learn how *feedback* is used in a logic circuit to keep
    the gates in a particular state over time, thus implementing memory. We’ll use
    *state diagrams* to show how inputs cause a sequential logic circuit to transition
    between states and what the corresponding outputs are. You’ll also learn how sequential
    logic circuits can be synchronized with a clock to provide reliable results.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你将学习如何在逻辑电路中使用*反馈*来保持门电路在特定的状态下，从而实现存储。我们将使用*状态图*来展示输入如何导致顺序逻辑电路在不同状态之间转换，以及相应的输出是什么。你还将学习如何使用时钟同步顺序逻辑电路，以提供可靠的结果。
- en: '**Latches**'
  id: totrans-7
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**锁存器**'
- en: The first sequential logic circuit we’ll look at is a *latch*, a 1-bit storage
    device that can be in one of two states, depending on its input. A latch can be
    constructed by connecting two or more logic gates such that the output from one
    gate feeds into the input of another gate; this keeps the output of both gates
    in the same state as long as power is applied. The state of a latch does not depend
    on time. (The term *latch* is also used for a multiple-bit storage device that
    behaves like the 1-bit device described here.)
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先学习的顺序逻辑电路是*锁存器*，它是一个 1 位存储设备，依据输入可以处于两种状态之一。锁存器可以通过连接两个或更多的逻辑门来构造，使得一个门的输出作为另一个门的输入；只要电源保持连接，这样就能保持两个门的输出处于相同的状态。锁存器的状态不依赖于时间。（术语*锁存器*也用于描述一个多位存储设备，其行为类似于这里描述的
    1 位设备。）
- en: '***SR Latch Using NOR Gates***'
  id: totrans-9
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***使用 NOR 门的 SR 锁存器***'
- en: The most basic latch is the *Set–Reset (SR)* latch. It has two inputs, *S* and
    *R*, and two states, *set* and *reset*. The state is used as the primary output,
    *Q*. It’s common to also provide the complemented output, ¬*Q*. The SR latch is
    said to be in the set state when the outputs are *Q* = `1` and ¬*Q* = `0`. It’s
    in the reset state when *Q* = `0` and ¬*Q* = `1`. [Figure 7-1](ch07.xhtml#ch7fig1)
    shows a simple implementation of an SR latch using NOR gates.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 最基本的锁存器是 *置位-复位 (SR)* 锁存器。它有两个输入，*S* 和 *R*，以及两个状态，*置位* 和 *复位*。该状态作为主要输出，*Q*。通常还会提供补充输出，¬*Q*。当输出为
    *Q* = `1` 和 ¬*Q* = `0` 时，SR 锁存器处于置位状态。当 *Q* = `0` 和 ¬*Q* = `1` 时，它处于复位状态。[图 7-1](ch07.xhtml#ch7fig1)
    展示了使用 NOR 门实现 SR 锁存器的简单示例。
- en: '![Image](../images/pg156_Image_206.jpg)'
  id: totrans-11
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/pg156_Image_206.jpg)'
- en: '*Figure 7-1: A NOR gate implementation of an SR latch*'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 7-1：SR 锁存器的 NOR 门实现*'
- en: The output of each NOR gate is fed into the input of the other. As I describe
    the behavior of the circuit in this chapter, you’ll see that this feedback is
    what keeps the latch in one state.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 每个 NOR 门的输出都被送入另一个门的输入。正如我在本章中描述电路的行为时，你将看到这种反馈是保持锁存器处于某一状态的原因。
- en: 'There are four possible input combinations for an SR latch, as detailed in
    the following list:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: SR 锁存器有四种可能的输入组合，如下所述：
- en: '***S*** **=** 0**,** ***R*** **=** 0**: Keep current state**'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: '***S*** **=** 0**,** ***R*** **=** 0**：保持当前状态**'
- en: If the latch is in the set state (*Q* = `1` and ¬*Q* = `0`), an input of *S*
    = `0` and *R* = `0` will cause ¬*Q*, the output of the upper NOR gate, to yield
    ¬(`0` ∨ `1`) = `0` and *Q*, the output of the lower NOR gate, to yield ¬(`0` ∨
    `0`) = `1`. Conversely, if the latch is in the reset state (*Q* = `0` and ¬*Q*
    = `1`), then the output of the upper NOR gate yields ¬(`0` ∨ `0`) = `1`, and the
    lower NOR gate yields ¬(`1` ∨ `0`) = `0`. Thus, the cross-feedback between the
    two NOR gates maintains the current state of the latch.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 如果锁存器处于置位状态 (*Q* = `1` 和 ¬*Q* = `0`)，输入 *S* = `0` 和 *R* = `0` 将导致上方 NOR 门输出
    ¬(`0` ∨ `1`) = `0`，下方 NOR 门输出 ¬(`0` ∨ `0`) = `1`。相反，如果锁存器处于复位状态 (*Q* = `0` 和 ¬*Q*
    = `1`)，则上方 NOR 门输出为 ¬(`0` ∨ `0`) = `1`，下方 NOR 门输出为 ¬(`1` ∨ `0`) = `0`。因此，两个 NOR
    门之间的交叉反馈维持了锁存器当前的状态。
- en: '***S*** **=** 1**,** ***R*** **=** 0**: Set (*****Q*** **=** 1**)**'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: '***S*** **=** 1**,** ***R*** **=** 0**：置位 (*****Q*** **=** 1**)**'
- en: If the latch is in the reset state, these inputs cause the output of the upper
    NOR gate to be ¬(`1` ∨ `0`) = `0`, thus changing ¬*Q* to `0`. This is fed back
    to the input of the lower NOR gate to yield ¬(`0` ∨ `0`) = `1`. The feedback from
    the output of the lower NOR gate to the input of the upper NOR gate keeps the
    output of the upper gate at ¬(`1` ∨ `1`) = `0`. The latch has then moved into
    the set state (*Q* = `1` and ¬*Q* = `0`).
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 如果锁存器处于复位状态，这些输入将导致上方 NOR 门输出为 ¬(`1` ∨ `0`) = `0`，从而将 ¬*Q* 改为 `0`。这一输出被反馈至下方
    NOR 门的输入，得到 ¬(`0` ∨ `0`) = `1`。下方 NOR 门输出的反馈保持上方 NOR 门输出为 ¬(`1` ∨ `1`) = `0`。锁存器随后进入置位状态
    (*Q* = `1` 和 ¬*Q* = `0`)。
- en: If the latch is in the set state, the upper NOR gate yields ¬(`1` ∨ `1`) = `0`
    and the output of the lower NOR gate is ¬(`0` ∨ `0`) = `1`. The latch thus remains
    in the set state.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 如果锁存器处于置位状态，则上方的 NOR 门输出 ¬(`1` ∨ `1`) = `0`，下方的 NOR 门输出为 ¬(`0` ∨ `0`) = `1`。因此，锁存器保持在置位状态。
- en: '***S*** **=** 0**,** ***R*** **=** 1**: Reset (*****Q*** **=** 0**)**'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: '***S*** **=** 0**,** ***R*** **=** 1**：复位 (*****Q*** **=** 0**)**'
- en: If the latch is in the set state, the lower NOR gate yields ¬(`0` ∨ `1`) = `0`,
    thus changing *Q* to be `0`. This is fed back to the input of the upper NOR gate
    to yield ¬(`0` ∨ `0`) = `1`. The feedback from the output of the upper NOR gate
    to the input of the lower NOR gate keeps the output of the lower gate at ¬(`1`
    ∨ `1`) = `0`. The latch has then moved into the reset state (*Q* = `0` and ¬*Q*
    = `1`).
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 如果锁存器处于置位状态，则下方的 NOR 门输出 ¬(`0` ∨ `1`) = `0`，从而将 *Q* 改为 `0`。这一输出被反馈至上方 NOR 门的输入，得到
    ¬(`0` ∨ `0`) = `1`。上方 NOR 门输出的反馈保持下方 NOR 门的输出为 ¬(`1` ∨ `1`) = `0`。锁存器随后进入复位状态（*Q*
    = `0`，¬*Q* = `1`）。
- en: If the latch is already in the reset state, the lower NOR gate yields ¬(`1`
    ∨ `1`) = `0` and the output of the upper NOR gate is ¬(`0` ∨ `0`) = `1`, so the
    latch remains in the reset state.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 如果锁存器已经处于复位状态，则下方的 NOR 门输出 ¬(`1` ∨ `1`) = `0`，上方的 NOR 门输出为 ¬(`0` ∨ `0`) = `1`，因此锁存器保持在复位状态。
- en: '***S*** **=** 1**,** ***R*** **=** 1**: Not allowed**'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: '***S*** **=** 1**,** ***R*** **=** 1**：不允许**'
- en: If *Q* = `0` and ¬*Q* = `1`, the upper NOR gate yields ¬(`1` ∨ `0`) = `0`. This
    is fed back to the input of the lower NOR gate to yield ¬(`0` ∨ `1`) = `0`. This
    would give *Q* = ¬*Q*, which is inconsistent with the laws of Boolean algebra.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 如果*Q* = `0` 且 ¬*Q* = `1`，则上部的 NOR 门产生 ¬(`1` ∨ `0`) = `0`。这一结果被反馈到下部 NOR 门的输入，产生
    ¬(`0` ∨ `1`) = `0`。这将导致*Q* = ¬*Q*，这与布尔代数定律不一致。
- en: If *Q* = `1` and ¬*Q* = `0`, the lower NOR gate yields ¬(`0` ∨ `1`) = `0`. This
    is fed back to the input of the upper NOR gate to yield ¬(`1` ∨ `0`) = `0`. This
    would also give *Q* = ¬*Q*, which is inconsistent. Circuits must be designed to
    prevent this input combination.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 如果*Q* = `1` 且 ¬*Q* = `0`，则下部的 NOR 门产生 ¬(`0` ∨ `1`) = `0`。这一结果被反馈到上部 NOR 门的输入，产生
    ¬(`1` ∨ `0`) = `0`。这将导致*Q* = ¬*Q*，这是不一致的。电路必须设计成避免这种输入组合。
- en: 'To simplify things, we can represent this logic visually. [Figure 7-2](ch07.xhtml#ch7fig2)
    introduces a graphic way to show the behavior of a NOR gate SR latch: the state
    diagram. In this figure, the current state is shown in the bubbles and the corresponding
    primary output is below the state. The lines with arrows show the possible transitions
    between the states and are labeled with the inputs that cause the transition to
    the next state.'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 为了简化，我们可以通过图示表示这一逻辑。[图 7-2](ch07.xhtml#ch7fig2)介绍了一种图形化方式来展示 NOR 门 SR 锁存器的行为：状态图。在该图中，当前状态显示在气泡中，且对应的主输出位于状态下方。带有箭头的线显示状态之间的可能转换，并标注了导致状态转换到下一状态的输入。
- en: '![Image](../images/pg158_Image_207.jpg)'
  id: totrans-27
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/pg158_Image_207.jpg)'
- en: '*Figure 7-2: A state diagram for a NOR gate SR latch*'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 7-2：NOR 门 SR 锁存器的状态图*'
- en: 'The two circles in [Figure 7-2](ch07.xhtml#ch7fig2) show the two possible states
    of the SR latch: set or reset. The labels on the lines show the combination of
    inputs, *SR*, that causes each state transition. For example, when the latch is
    in the reset state, there are two possible inputs, *SR* = `00` and *SR* = `01`,
    that cause it to remain in that state. The input *SR* = `10` causes it to transition
    to the set state. Since the output is dependent only on the state—and not on the
    input—a latch is a Moore state machine.'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 7-2](ch07.xhtml#ch7fig2)中的两个圆圈表示 SR 锁存器的两个可能状态：设置或重置。线上的标签显示了导致每次状态转换的输入组合*SR*。例如，当锁存器处于重置状态时，有两个可能的输入，*SR*
    = `00` 和 *SR* = `01`，这将使其保持在该状态。输入*SR* = `10`会使其转换到设置状态。由于输出仅依赖于状态，而不依赖于输入，因此锁存器是一个摩尔状态机。'
- en: 'Those familiar with graph theory will recognize that a state diagram is a directed
    graph: the states are the vertices and the inputs that cause transitions are the
    edges. Although they are beyond the scope of this book, tools from graph theory
    can be useful in the design process.'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 熟悉图论的人会认识到，状态图是一个有向图：状态是顶点，导致转换的输入是边。尽管这些内容超出了本书的范围，但图论中的工具在设计过程中是非常有用的。
- en: As in graph theory, we can also show the same behavior in a tabular form using
    a *state transition table*, as shown in [Table 7-1](ch07.xhtml#ch7tab1).
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 和图论一样，我们也可以通过*状态转换表*以表格形式展示相同的行为，如[表 7-1](ch07.xhtml#ch7tab1)所示。
- en: '**Table 7-1:** A NOR Gate SR Latch State Transition Table'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: '**表 7-1：** NOR 门 SR 锁存器状态转换表'
- en: '| ***S*** | ***R*** | ***Q*** | ***Q***[***next***] |'
  id: totrans-33
  prefs: []
  type: TYPE_TB
  zh: '| ***S*** | ***R*** | ***Q*** | ***Q***[***next***] |'
- en: '| --- | --- | --- | --- |'
  id: totrans-34
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- |'
- en: '| `0` | `0` | `0` | `0` |'
  id: totrans-35
  prefs: []
  type: TYPE_TB
  zh: '| `0` | `0` | `0` | `0` |'
- en: '| `0` | `0` | `1` | `1` |'
  id: totrans-36
  prefs: []
  type: TYPE_TB
  zh: '| `0` | `0` | `1` | `1` |'
- en: '| `0` | `1` | `0` | `0` |'
  id: totrans-37
  prefs: []
  type: TYPE_TB
  zh: '| `0` | `1` | `0` | `0` |'
- en: '| `0` | `1` | `1` | `0` |'
  id: totrans-38
  prefs: []
  type: TYPE_TB
  zh: '| `0` | `1` | `1` | `0` |'
- en: '| `1` | `0` | `0` | `1` |'
  id: totrans-39
  prefs: []
  type: TYPE_TB
  zh: '| `1` | `0` | `0` | `1` |'
- en: '| `1` | `0` | `1` | `1` |'
  id: totrans-40
  prefs: []
  type: TYPE_TB
  zh: '| `1` | `0` | `1` | `1` |'
- en: '| `1` | `1` | `0` | x |'
  id: totrans-41
  prefs: []
  type: TYPE_TB
  zh: '| `1` | `1` | `0` | x |'
- en: '| `1` | `1` | `1` | x |'
  id: totrans-42
  prefs: []
  type: TYPE_TB
  zh: '| `1` | `1` | `1` | x |'
- en: In [Table 7-1](ch07.xhtml#ch7tab1), *S* and *R* are the inputs, *Q* is the output
    in the current state, and *Q[next]* shows the output in the state that results
    from the corresponding input. The x in the bottom two rows indicates an impossible
    condition.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 在[表 7-1](ch07.xhtml#ch7tab1)中，*S* 和 *R* 是输入，*Q* 是当前状态下的输出，*Q[next]* 显示由于相应输入所导致的下一状态的输出。底部两行中的x表示一种不可能的情况。
- en: Both inputs to a NOR gate SR latch are normally held at `0`, which maintains
    the current state, giving the output *Q*. Momentarily changing only *R* to `1`
    causes the state to go to reset, which changes the output to *Q* = `0`, as shown
    in the *Q[next]* column of the state transition table. Momentarily changing only
    *S* to `1` causes the state to go to set, giving the output *Q* = `1`.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 NOR 门 SR 锁存器，两个输入通常保持在 `0`，从而维持当前状态，使输出为*Q*。暂时将*R*改为 `1` 会使状态重置，从而将输出更改为*Q*
    = `0`，如状态转换表中的*Q[next]*列所示。暂时将*S*改为 `1` 会使状态设置，从而使输出为*Q* = `1`。
- en: As described earlier, the input combination *S* = *R* = `1` is not allowed because
    that would cause an inconsistent state for the SR latch, as indicated in the prohibited
    rows of the state transition table by an x in the *Q[next]* column.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，输入组合 *S* = *R* = `1` 不被允许，因为这会导致 SR 锁存器处于不一致状态，正如状态转换表中的 *Q[next]* 列所示的禁止行，那里标有
    x。
- en: '#### ***SR Latch Using NAND Gates***'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: '#### ***使用 NAND 门的 SR 锁存器***'
- en: 'The physics of their construction tends to make NAND gates faster than NOR
    gates. Let’s start with the equation for the output of a NOR gate:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 它们的构造物理特性使得 NAND 门比 NOR 门更快。让我们从 NOR 门输出的方程式开始：
- en: '![Image](../images/pg159_Image_208.jpg)'
  id: totrans-48
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/pg159_Image_208.jpg)'
- en: 'From De Morgan’s law, we get the following:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 从德摩根定律，我们得到以下结果：
- en: '![Image](../images/pg159_Image_209.jpg)'
  id: totrans-50
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/pg159_Image_209.jpg)'
- en: This shows that a NAND gate is functionally equivalent to a NOR gate if we complement
    the two inputs, except that the output is complemented.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 这表明，如果我们对两个输入取反，则 NAND 门在功能上等同于 NOR 门，只是输出取反。
- en: This leads to the circuit shown in [Figure 7-3](ch07.xhtml#ch7fig3), with ¬*S*
    and ¬*R* as the inputs. To emphasize the logical duality of the two designs, NAND
    and NOR, I have drawn the circuit with the output *Q* at the top and ¬*Q* on the
    bottom.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 这导致了如[图 7-3](ch07.xhtml#ch7fig3)所示的电路，使用 ¬*S* 和 ¬*R* 作为输入。为了强调两种设计的逻辑对偶性（NAND
    和 NOR），我绘制了电路，输出 *Q* 位于顶部，¬*Q* 位于底部。
- en: '![Image](../images/pg159_Image_210.jpg)'
  id: totrans-53
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/pg159_Image_210.jpg)'
- en: '*Figure 7-3: A NAND gate implementation of an SR latch*'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 7-3：SR 锁存器的 NAND 门实现*'
- en: 'Like the NOR gate SR latch, the NAND gate SR latch is said to be in the set
    state when the outputs are *Q* = `1` and ¬*Q* = `0`; it’s in the reset state when
    *Q* = `0` and ¬*Q* = `1`. There are four possible input combinations:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 与 NOR 门 SR 锁存器一样，NAND 门 SR 锁存器在输出为 *Q* = `1` 且 ¬*Q* = `0` 时被认为处于置位状态；在 *Q* =
    `0` 且 ¬*Q* = `1` 时则处于复位状态。输入组合有四种可能：
- en: '¬***S*** **=** 1**,** ¬***R*** **=** 1**: Keep current state**'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: ¬***S*** **=** 1**,** ¬***R*** **=** 1**：保持当前状态**
- en: If the latch is in the set state (*Q* = `1` and ¬*Q* = `0`), the upper NAND
    gate yields ¬(`1` ∧ `0`) = `1`, and the lower NAND gate yields ¬(`1` ∧ `1`) =
    `0`. If *Q* = `0` and ¬*Q* = `1`, the latch is in the reset state; the upper NAND
    gate yields ¬(`1` ∧ `1`) = `0`, and the lower NAND gate yields ¬(`0` ∧ `1`) =
    `1`. The cross feedback between the two NAND gates maintains the state of the
    latch.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 如果锁存器处于置位状态（*Q* = `1` 且 ¬*Q* = `0`），则上部 NAND 门输出为¬(`1` ∧ `0`) = `1`，下部 NAND
    门输出为¬(`1` ∧ `1`) = `0`。如果 *Q* = `0` 且 ¬*Q* = `1`，则锁存器处于复位状态；上部 NAND 门输出为¬(`1`
    ∧ `1`) = `0`，下部 NAND 门输出为¬(`0` ∧ `1`) = `1`。两个 NAND 门之间的交叉反馈保持锁存器的状态。
- en: '¬***S*** **=** 0**,** ¬***R*** **=** 1**: Set (*****Q*** **=** 1**)**'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: ¬***S*** **=** 0**,** ¬***R*** **=** 1**：置位（*****Q*** **=** 1**)**
- en: If the latch is in the reset state, the upper NAND gate yields ¬(`0` ∧ `1`)
    = `1`, thus changing *Q* to be `1`. This is fed back to the input of the lower
    NAND gate to yield ¬(`1` ∧ `1`) = `0`. The feedback from the output of the lower
    NAND gate to the input of the upper NAND gate keeps the output of the upper gate
    at ¬(`0` ∧ `0`) = `1`. The latch has moved into the set state (*Q* = `1` and ¬*Q*
    = `0`).
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 如果锁存器处于复位状态，则上部 NAND 门的输出为¬(`0` ∧ `1`) = `1`，从而将 *Q* 更改为 `1`。该信号反馈到下部 NAND 门的输入，得到¬(`1`
    ∧ `1`) = `0`。从下部 NAND 门输出到上部 NAND 门输入的反馈保持上部门的输出为¬(`0` ∧ `0`) = `1`。锁存器已进入置位状态（*Q*
    = `1` 且 ¬*Q* = `0`）。
- en: If the latch is already in the set state, then the upper NAND gate yields ¬(`0`
    ∧ *mathtt*0) = `1`, and the output of the lower NAND gate is ¬(`1` ∧ `1`) = `0`.
    The latch thus remains in the set state.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 如果锁存器已处于置位状态，则上部 NAND 门输出为¬(`0` ∧ *mathtt*0) = `1`，下部 NAND 门的输出为¬(`1` ∧ `1`)
    = `0`。因此，锁存器保持在置位状态。
- en: '¬***S*** **=** 1**,** ¬***R*** **=** 0**: Reset (*****Q*** **=** 0**)**'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: ¬***S*** **=** 1**,** ¬***R*** **=** 0**：复位（*****Q*** **=** 0**)**
- en: If the latch is in the set state, the lower NAND gate yields ¬(`1` ∧ `0`) =
    `1`. This is fed back to the input of the upper NAND gate, thereby making *Q*
    = ¬(`1` ∧ `1`) = `0`. The feedback from the output of the upper NAND gate to the
    input of the lower NAND gate keeps the output of the lower gate at ¬(`0` ∧ `0`)
    = `1`, so the latch moves into the reset state (*Q* = `0` and ¬*Q* = `1`).
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 如果锁存器处于置位状态，下部 NAND 门输出为¬(`1` ∧ `0`) = `1`。该信号反馈到上部 NAND 门的输入，从而使 *Q* = ¬(`1`
    ∧ `1`) = `0`。从上部 NAND 门输出到下部 NAND 门输入的反馈保持下部门的输出为¬(`0` ∧ `0`) = `1`，因此锁存器进入复位状态（*Q*
    = `0` 且 ¬*Q* = `1`）。
- en: If the latch is already in the reset state, the lower NAND gate yields ¬(`0`
    ∧ `0`) = `1`, and the output of the upper NAND gate is ¬(`1` ∧ `1`) = `0`. The
    latch remains in the reset state.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 如果锁存器已经处于复位状态，底部的NAND门输出¬(`0` ∧ `0`) = `1`，顶部NAND门的输出是¬(`1` ∧ `1`) = `0`。锁存器保持在复位状态。
- en: '¬***S*** **=** 0**,** ¬***R*** **=** 0**: Not allowed**'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: ¬***S*** **=** 0**,** ¬***R*** **=** 0**：不允许**
- en: If the latch is in the reset state, the upper NAND gate yields ¬(`0` ∧ `1`)
    = `1`. This is fed back to the input of the lower NAND gate to yield ¬(`1` ∧ `0`)
    = `1`. This would give *Q* = ¬*Q*, which is inconsistent.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 如果锁存器处于复位状态，顶部的NAND门输出¬(`0` ∧ `1`) = `1`。这个结果会反馈到底部NAND门的输入，导致输出¬(`1` ∧ `0`)
    = `1`。这也会导致*Q* = ¬*Q*，这种情况是不一致的。
- en: If the latch is in the set state, the lower NAND gate yields ¬(`1` ∧ `0`) =
    `1`. This is fed back to the input of the upper NAND gate to yield ¬(`0` ∧ `1`)
    = `1`. This would also give *Q* = ¬*Q*, which is inconsistent. Circuits must be
    designed to prevent this input combination.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 如果锁存器处于设定状态，底部的NAND门输出¬(`1` ∧ `0`) = `1`。这个结果会反馈到顶部NAND门的输入，导致输出¬(`0` ∧ `1`)
    = `1`。这也会导致*Q* = ¬*Q*，这种情况是不一致的。电路设计必须防止这种输入组合。
- en: '[Figure 7-4](ch07.xhtml#ch7fig4) shows the behavior of a NAND gate SR latch
    using a state diagram.'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: '[图7-4](ch07.xhtml#ch7fig4)展示了使用状态图表示的NAND门SR锁存器的行为。'
- en: '![Image](../images/pg160_Image_211.jpg)'
  id: totrans-68
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/pg160_Image_211.jpg)'
- en: '*Figure 7-4: A NAND gate SR latch*'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: '*图7-4：NAND门SR锁存器*'
- en: Comparing this with the NOR gate SR latch in [Figure 7-2](ch07.xhtml#ch7fig2),
    you can see that they both describe the same behavior. For example, an input of
    *SR* = `10` to the NOR gate SR latch will place it in the set state, while an
    input of
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 将此与[图7-2](ch07.xhtml#ch7fig2)中的NOR门SR锁存器进行比较，你会发现它们描述的是相同的行为。例如，向NOR门SR锁存器输入*SR*
    = `10`会将其置于设定状态，而输入
- en: ¬*S¬R* = `01` to the NAND gate SR latch will place it in the set state. I find
    that I have to think carefully about this when analyzing circuits. An off-by-one
    error when there are only two choices can cause behavior opposite to what I want.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: ¬*S¬R* = `01`输入到NAND门SR锁存器会将其置于设定状态。我发现，在分析电路时，必须仔细思考这个问题。当只有两个选择时，一点点偏差就可能导致行为与预期相反。
- en: '[Table 7-2](ch07.xhtml#ch7tab2) is a state transition table for a NAND gate
    SR latch.'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: '[表7-2](ch07.xhtml#ch7tab2)是一个NAND门SR锁存器的状态转移表。'
- en: '**Table 7-2:** A NAND Gate SR Latch State Transition Table'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: '**表7-2：** 一个NAND门SR锁存器状态转移表'
- en: '| ***¬******S*** | ***¬******R*** | ***Q*** | ***Q****[next]*** |'
  id: totrans-74
  prefs: []
  type: TYPE_TB
  zh: '| ***¬******S*** | ***¬******R*** | ***Q*** | ***Q****[next]*** |'
- en: '| --- | --- | --- | --- |'
  id: totrans-75
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- |'
- en: '| `1` | `1` | `0` | `0` |'
  id: totrans-76
  prefs: []
  type: TYPE_TB
  zh: '| `1` | `1` | `0` | `0` |'
- en: '| `1` | `1` | `1` | `1` |'
  id: totrans-77
  prefs: []
  type: TYPE_TB
  zh: '| `1` | `1` | `1` | `1` |'
- en: '| `1` | `0` | `0` | `0` |'
  id: totrans-78
  prefs: []
  type: TYPE_TB
  zh: '| `1` | `0` | `0` | `0` |'
- en: '| `1` | `0` | `1` | `0` |'
  id: totrans-79
  prefs: []
  type: TYPE_TB
  zh: '| `1` | `0` | `1` | `0` |'
- en: '| `0` | `1` | `0` | `1` |'
  id: totrans-80
  prefs: []
  type: TYPE_TB
  zh: '| `0` | `1` | `0` | `1` |'
- en: '| `0` | `1` | `1` | `1` |'
  id: totrans-81
  prefs: []
  type: TYPE_TB
  zh: '| `0` | `1` | `1` | `1` |'
- en: '| `0` | `0` | `0` | x |'
  id: totrans-82
  prefs: []
  type: TYPE_TB
  zh: '| `0` | `0` | `0` | x |'
- en: '| `0` | `0` | `1` | x |'
  id: totrans-83
  prefs: []
  type: TYPE_TB
  zh: '| `0` | `0` | `1` | x |'
- en: Placing `0` on both inputs at the same time causes a problem—namely, that the
    outputs of both NAND gates would become `1`. In other words, *Q* = ¬*Q* = `1`,
    which is logically impossible. The circuit design must prevent this input combination.
    The x in the bottom two rows indicates an impossible condition.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 同时将`0`输入到两个端口会导致问题——即两个NAND门的输出都会变为`1`。换句话说，*Q* = ¬*Q* = `1`，这是逻辑上不可能的。电路设计必须防止这种输入组合。底部两行中的x表示一个不可能的状态。
- en: The SR latch implemented with two NAND gates can be thought of as the complement
    of the NOR gate SR latch. The state is maintained by holding both ¬*S* and ¬*R*
    at `1`. Momentarily changing ¬*S* to `0` causes the state to be set with the output
    *Q* = `1`, and setting ¬*R* = `0` causes it to be reset with the output *Q* =
    `0`.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 使用两个NAND门实现的SR锁存器可以被看作是NOR门SR锁存器的补集。通过将¬*S*和¬*R*保持在`1`，状态得以保持。暂时将¬*S*设为`0`会将状态设定为*Q*
    = `1`，而将¬*R*设为`0`会将其复位，输出*Q* = `0`。
- en: Thus far, we have been looking at a single latch. The problem here is that the
    state of the latch, and its output, will change whenever the input changes. In
    a computer, it would be interconnected with many other devices, each changing
    state with new inputs. It takes time for each device to change state and for its
    output(s) to propagate to the next device(s). The precise timing depends on slight
    manufacturing differences in the devices, so the results can be unreliable. We
    need a means for synchronizing the activity to bring some order to the operations.
    We’ll start by adding an *Enable* input to the SR latch, which will allow us to
    control more precisely when the inputs will be allowed to affect the state.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们一直在查看一个单独的锁存器。问题在于，当输入发生变化时，锁存器的状态及其输出也会发生变化。在计算机中，它将与许多其他设备互连，每个设备都随新输入变化状态。每个设备改变状态并将其输出传播到下一个设备需要时间。精确的时序取决于设备制造中的细微差异，因此结果可能不可靠。我们需要一种手段来同步活动，为操作带来一些秩序。我们将通过向SR锁存器添加一个*Enable*输入来开始，这将使我们能够更精确地控制何时允许输入影响状态。
- en: '***SR Latch with Enable***'
  id: totrans-87
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***带Enable的SR锁存器***'
- en: We can get better control over the SR latch by adding two NAND gates to provide
    an *Enable* input. Connecting the outputs of these two NAND gates to the inputs
    of a ¬*S¬R* latch gives us a *gated SR latch*, as depicted in [Figure 7-5](ch07.xhtml#ch7fig5).
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 通过添加两个NAND门以提供*Enable*输入，我们可以更好地控制SR锁存器。将这两个NAND门的输出连接到¬*S¬R*锁存器的输入，便得到了一个*门控SR锁存器*，如[图7-5](ch07.xhtml#ch7fig5)所示。
- en: '![Image](../images/pg161_Image_212.jpg)'
  id: totrans-89
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/pg161_Image_212.jpg)'
- en: '*Figure 7-5: A gated SR latch*'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: '*图7-5：带门控的SR锁存器*'
- en: In this circuit, the outputs of both the control NAND gates remain at `1` as
    long as *Enable* = `0`. This sends ¬*S* = `1` and ¬*R* = `1` to the inputs of
    the ¬*S¬R* latch portion of this circuit, which causes the state to remain the
    same. By AND-ing the additional *Enable* input with the *S* and *R* input lines,
    we can control the time when the state should be changed to the next value.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个电路中，只要*Enable* = `0`，两个控制NAND门的输出就会保持在`1`。这将发送¬*S* = `1` 和 ¬*R* = `1` 到该电路的¬*S¬R*锁存器部分的输入，从而使状态保持不变。通过将额外的*Enable*输入与*S*和*R*输入线进行与运算，我们可以控制状态何时改变为下一个值。
- en: '[Table 7-3](ch07.xhtml#ch7tab3) shows the state behavior of the SR latch with
    the *Enable* control.'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: '[表7-3](ch07.xhtml#ch7tab3)显示了带*Enable*控制的SR锁存器的状态行为。'
- en: '**Table 7-3:** A Gated SR Latch State Transition Table'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: '**表 7-3：** 带门控的SR锁存器状态转换表'
- en: '| ***Enable*** | ***S*** | ***R*** | ***Q*** | ***Q****[next]*** |'
  id: totrans-94
  prefs: []
  type: TYPE_TB
  zh: '| ***Enable*** | ***S*** | ***R*** | ***Q*** | ***Q****[next]*** |'
- en: '| --- | --- | --- | --- | --- |'
  id: totrans-95
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- | --- |'
- en: '| `0` | — | — | `0` | `0` |'
  id: totrans-96
  prefs: []
  type: TYPE_TB
  zh: '| `0` | — | — | `0` | `0` |'
- en: '| `0` | — | — | `1` | `1` |'
  id: totrans-97
  prefs: []
  type: TYPE_TB
  zh: '| `0` | — | — | `1` | `1` |'
- en: '| `1` | `0` | `0` | `0` | `0` |'
  id: totrans-98
  prefs: []
  type: TYPE_TB
  zh: '| `1` | `0` | `0` | `0` | `0` |'
- en: '| `1` | `0` | `0` | `1` | `1` |'
  id: totrans-99
  prefs: []
  type: TYPE_TB
  zh: '| `1` | `0` | `0` | `1` | `1` |'
- en: '| `1` | `0` | `1` | `0` | `0` |'
  id: totrans-100
  prefs: []
  type: TYPE_TB
  zh: '| `1` | `0` | `1` | `0` | `0` |'
- en: '| `1` | `0` | `1` | `1` | `0` |'
  id: totrans-101
  prefs: []
  type: TYPE_TB
  zh: '| `1` | `0` | `1` | `1` | `0` |'
- en: '| `1` | `1` | `0` | `0` | `1` |'
  id: totrans-102
  prefs: []
  type: TYPE_TB
  zh: '| `1` | `1` | `0` | `0` | `1` |'
- en: '| `1` | `1` | `0` | `1` | `1` |'
  id: totrans-103
  prefs: []
  type: TYPE_TB
  zh: '| `1` | `1` | `0` | `1` | `1` |'
- en: '| `1` | `1` | `1` | `0` | x |'
  id: totrans-104
  prefs: []
  type: TYPE_TB
  zh: '| `1` | `1` | `1` | `0` | x |'
- en: '| `1` | `1` | `1` | `1` | x |'
  id: totrans-105
  prefs: []
  type: TYPE_TB
  zh: '| `1` | `1` | `1` | `1` | x |'
- en: In [Table 7-3](ch07.xhtml#ch7tab3), a — indicates that an input does not matter
    and an x indicates a prohibited result. As explained earlier, the design must
    prevent input combinations that would produce prohibited results. The state of
    the latch can follow the *S* and *R* inputs only when *Enable* = `1`. Such a device
    is said to be *level-triggered*.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 在[表 7-3](ch07.xhtml#ch7tab3)中，a —表示某个输入无关紧要，x表示禁止的结果。如前所述，设计必须防止产生禁止结果的输入组合。只有当*Enable*
    = `1`时，锁存器的状态才能跟随*S*和*R*输入。因此，这种设备被称为*电平触发型*。
- en: In the next section, I’ll simplify the gated SR latch and create a latch that
    takes a single data input, *D*, with control over when this input will affect
    the state of the latch.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我将简化门控的SR锁存器，并创建一个只接收单一数据输入*D*的锁存器，并控制何时这个输入会影响锁存器的状态。
- en: '***The D Latch***'
  id: totrans-108
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***D型锁存器***'
- en: A *D latch* allows us to store the value of 1 bit. We start with the truth table
    in [Table 7-4](ch07.xhtml#ch7tab4), which includes the rows from [Table 7-3](ch07.xhtml#ch7tab3)
    where *Enable* = `1` and *R* = ¬*S*.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: '*D型锁存器*允许我们存储1位的值。我们从[表7-4](ch07.xhtml#ch7tab4)的真值表开始，该表包括[表7-3](ch07.xhtml#ch7tab3)中当*Enable*
    = `1` 且 *R* = ¬*S*时的行。'
- en: '**Table 7-4:** A Truth Table for a D Latch with *Enable*'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: '**表 7-4：** 带*Enable*的D型锁存器真值表'
- en: '| ***Enable*** | ***S*** | ***R*** | ***D*** | ***Q*** | ***Q****[next]***
    |'
  id: totrans-111
  prefs: []
  type: TYPE_TB
  zh: '| ***Enable*** | ***S*** | ***R*** | ***D*** | ***Q*** | ***Q****[next]***
    |'
- en: '| --- | --- | --- | --- | --- | --- |'
  id: totrans-112
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- | --- | --- |'
- en: '| `0` | — | — | — | `0` | `0` |'
  id: totrans-113
  prefs: []
  type: TYPE_TB
  zh: '| `0` | — | — | — | `0` | `0` |'
- en: '| `0` | — | — | — | `1` | `1` |'
  id: totrans-114
  prefs: []
  type: TYPE_TB
  zh: '| `0` | — | — | — | `1` | `1` |'
- en: '| `1` | `0` | `1` | `0` | `0` | `0` |'
  id: totrans-115
  prefs: []
  type: TYPE_TB
  zh: '| `1` | `0` | `1` | `0` | `0` | `0` |'
- en: '| `1` | `0` | `1` | `0` | `1` | `0` |'
  id: totrans-116
  prefs: []
  type: TYPE_TB
  zh: '| `1` | `0` | `1` | `0` | `1` | `0` |'
- en: '| `1` | `1` | `0` | `1` | `0` | `1` |'
  id: totrans-117
  prefs: []
  type: TYPE_TB
  zh: '| `1` | `1` | `0` | `1` | `0` | `1` |'
- en: '| `1` | `1` | `0` | `1` | `1` | `1` |'
  id: totrans-118
  prefs: []
  type: TYPE_TB
  zh: '| `1` | `1` | `0` | `1` | `1` | `1` |'
- en: 'We’re looking for a design that will have two inputs: one for *Enable* and
    the other for *D* (short for data). We want *D* = `1` to set the state, giving
    the output *Q* = `1`, and *D* = `0` to reset it, giving the output *Q* = `0`,
    when the *Enable* line becomes `1`. The value of *D* should have no effect on
    the state when *Enable* = `0`.'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 我们正在寻找一种设计，具有两个输入：一个是*使能*，另一个是*D*（数据的简写）。我们希望*D* = `1`时设置状态，使得输出*Q* = `1`，而*D*
    = `0`时重置状态，使得输出*Q* = `0`，当*使能*线变为`1`时。*D*的值在*使能* = `0`时不应对状态产生任何影响。
- en: We can construct a gated D latch from a gated SR latch by adding a NOT gate,
    as shown in [Figure 7-6](ch07.xhtml#ch7fig6).
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过添加一个NOT门，从一个带使能的SR锁存器构造出一个带使能的D锁存器，具体如[图7-6](ch07.xhtml#ch7fig6)所示。
- en: '![Image](../images/pg163_Image_213.jpg)'
  id: totrans-121
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/pg163_Image_213.jpg)'
- en: '*Figure 7-6: A gated D latch constructed from an SR latch*'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: '*图7-6：由SR锁存器构造的带使能的D锁存器*'
- en: The one data input, *D*, is fed to the *S* side of the SR latch; the complement
    of the data value is fed to the *R* side.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 唯一的数据输入*D*被送入SR锁存器的*S*端；数据值的反码被送入*R*端。
- en: Now, we have a circuit that can store 1 bit of data using the *D* input and
    can be synchronized with other operations using the *Enable* input. However, there
    are some problems with the D latch. The state of a D latch can be affected by
    the input while the D latch is enabled. Thus, its output can change while the
    latch is enabled, making it difficult to synchronize reliably with other devices.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们有了一个可以使用*D*输入存储1位数据的电路，并且可以通过*使能*输入与其他操作进行同步。然而，D锁存器存在一些问题。D锁存器的状态可能会在启用时受到输入的影响。因此，它的输出可能在锁存器启用时发生变化，这使得它很难与其他设备可靠地同步。
- en: This scheme does work well when the latch should remain in one state for an
    extended period. In general, latches work for operations where we want to select
    a state and leave it for a period of time that is not synchronized with other
    operations in the computer. An example is an I/O port, where the timing is dependent
    on the behavior of the device connected to the port. For instance, a running program
    cannot know when the user will press a key on the keyboard. When a key is pressed,
    the program may not be ready for the character, so the binary code for the character
    should be latched at the input port. Once the character code is stored at the
    input port, the latch will be disabled until the program reads the character code
    from the latch.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方案在锁存器需要长时间保持在某一状态时非常有效。一般来说，锁存器适用于那些我们希望选择一个状态并保持一段时间的操作，这段时间与计算机中的其他操作不同步。例如，I/O端口的时序取决于连接到端口的设备的行为。例如，正在运行的程序无法知道用户何时按下键盘上的一个键。当按下键时，程序可能还没有准备好接收字符，因此该字符的二进制代码应被锁存到输入端口中。一旦字符代码存储在输入端口，锁存器将被禁用，直到程序从锁存器读取字符代码。
- en: Most of the computing operations within the CPU and main memory must be coordinated
    in time. Connecting many circuits to the same clock signal allows us to synchronize
    their operations. Let’s consider how we might synchronize a D latch connected
    in a circuit. We could feed an input to this D latch and enable the latch with
    a clock signal, but its output can change if the input changes, making its output
    unreliable during the time it’s enabled. If the output from our D latch is connected
    to the input of another device, the input to this second device is thus unreliable
    while our D latch is enabled. To avoid this problem and provide a reliable input,
    we should disable our D latch once it has settled.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: CPU和主内存中的大多数计算操作必须进行时间上的协调。将多个电路连接到相同的时钟信号可以同步它们的操作。让我们考虑如何同步连接在电路中的D锁存器。我们可以将一个输入信号送入这个D锁存器，并通过时钟信号使能锁存器，但如果输入变化，它的输出也会变化，这会导致在启用时输出不可靠。如果我们的D锁存器的输出连接到另一个设备的输入，那么在D锁存器启用时，第二个设备的输入也变得不可靠。为了解决这个问题并提供可靠的输入，我们应当在D锁存器稳定后禁用它。
- en: It also takes some time, called *propagation delay*, for the output of our D
    latch to reach the input of the second device, due to the physics of the connections.
    So, this second device should be disabled until the input to our D latch is reliable
    and we have allowed for the propagation delay.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 由于连接的物理原因，我们的D触发器的输出到达第二个设备的输入也需要一些时间，这被称为*传播延迟*。因此，第二个设备应该被禁用，直到我们D触发器的输入是可靠的，并且我们已经考虑了传播延迟。
- en: While the second device is disabled and waiting for a reliable input from our
    D latch, its output (from the previous clock cycle) is reliable. So, if it’s connected
    to the input of yet another device, this third device can be enabled. This leads
    to a scheme where every other device is enabled, while the alternate devices are
    disabled. After waiting for a period equal to the sum of the longest settling
    time and propagation delay time of all the devices connected together, the disabled
    devices are enabled and the enabled devices are disabled. The digital `1`s and
    `0`s are propagated through this circuit of devices by means of this alternating
    enable/disable cycle.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 当第二个设备被禁用并等待来自我们D触发器的可靠输入时，它的输出（来自上一个时钟周期）是可靠的。因此，如果它连接到另一个设备的输入，这第三个设备就可以被启用。这导致了一种方案，其中每隔一个设备被启用，而交替的设备被禁用。在等待的时间等于所有连接设备的最长稳定时间和传播延迟时间之和后，禁用的设备被启用，启用的设备被禁用。数字`1`和`0`通过这种交替启用/禁用周期在这些设备的电路中传播。
- en: As you can probably imagine, coordinating this flipping back and forth between
    enabled and disabled can be difficult. I’ll give you a solution to this problem
    in the next section.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你可能想象的那样，协调启用和禁用之间的这种反复切换可能是困难的。我将在下一节中给出这个问题的解决方案。
- en: '**Flip-Flops**'
  id: totrans-130
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**翻转触发器**'
- en: While a latch could be controlled by the levels of a clock signal, its output
    would be affected by any changes in its input during the portion of time when
    the clock signal enables the latch. A *flip-flop* provides an output at a specific
    time in the clock cycle, such as when the clock signal transitions from `0` to
    `1`. Because the output becomes available at a clock signal transition point,
    it is said to be *edge triggered*. After the trigger event, the output of a flip-flop
    remains throughout the duration of the clock cycle. This provides the reliability
    needed to connect many flip-flops in a circuit and synchronize their operations
    with one clock. I’ll start this section with a discussion of clocks, and then
    we’ll look at a few examples of flip-flops.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然触发器可以通过时钟信号的电平来控制，但在时钟信号启用触发器的时间段内，输入的任何变化都会影响它的输出。*翻转触发器*在时钟周期的特定时间提供输出，例如当时钟信号从`0`转换为`1`时。由于输出在时钟信号的转换点变得可用，它被称为*边缘触发*。触发事件发生后，翻转触发器的输出会持续整个时钟周期。这提供了将多个翻转触发器连接在一起并通过一个时钟同步它们操作所需的可靠性。我将从时钟的讨论开始，然后我们将看看一些翻转触发器的例子。
- en: '**NOTE**'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*The terminology varies. Some people also call latches* flip-flops*. I will
    use the term* latch *to mean a level-triggered device, with no timing considerations,
    and* flip-flop *to mean an edge-triggered device controlled by a clock signal.*'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: '*术语有所不同。有些人也称触发器*为翻转触发器*。我将使用术语*触发器*来指代一个级别触发的设备，没有时间要求，而*翻转触发器*则指由时钟信号控制的边缘触发设备。*'
- en: '***Clocks***'
  id: totrans-134
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***时钟***'
- en: Sequential logic circuits have a time history, summarized in their state. We
    keep track of time with a *clock*, a device that provides an electronic *clock
    signal*. This is typically a square wave that alternates between the `0` and `1`
    levels, as shown in [Figure 7-7](ch07.xhtml#ch7fig7). This signal is used as the
    enabling/disabling input to devices that need to be synchronized.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 顺序逻辑电路具有时间历史，这些历史被其状态所总结。我们通过*时钟*来跟踪时间，时钟是一个提供电子*时钟信号*的设备。这通常是一个方波，在`0`和`1`电平之间交替变化，如[图7-7](ch07.xhtml#ch7fig7)所示。这个信号作为需要同步的设备的启用/禁用输入。
- en: '![Image](../images/pg164_Image_214.jpg)'
  id: totrans-136
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/pg164_Image_214.jpg)'
- en: '*Figure 7-7: A typical clock signal used to synchronize sequential logic circuits*'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: '*图7-7：用于同步顺序逻辑电路的典型时钟信号*'
- en: In order to achieve reliable behavior, most synchronous circuits use edge-triggered
    devices. The amount of time spent at each level is usually the same, and either
    the positive-going (`0` to `1`) or negative-going (`1` to `0`) edge of a clock
    signal may be used.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 为了实现可靠的行为，大多数同步电路使用边缘触发的设备。每个电平上的时间通常是相同的，时钟信号的正边缘（`0`到`1`）或负边缘（`1`到`0`）都可以使用。
- en: The clock frequency must be slow enough that the circuit elements have time
    to complete their operations before the next clock transition occurs. For example,
    reliable operation of a latch or flip-flop requires that the input signal be stable
    for a period of time, called the *setup time*, before the device is enabled. The
    input signal must remain stable for another period of time, the *hold time*, after
    the start of the enabling signal. In practice, these times can vary with temperature,
    manufacturing variations, and so forth. Hardware designers need to consult manufacturers’
    specifications for the limits of these time values.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 时钟频率必须足够慢，以便电路元件有时间在下一个时钟过渡发生之前完成它们的操作。例如，可靠操作锁存器或触发器要求输入信号在设备启用之前的某段时间内保持稳定，这段时间称为*建立时间*。输入信号在启用信号开始后必须保持稳定一段时间，这段时间称为*保持时间*。实际上，这些时间可能会随温度、制造差异等因素变化。硬件设计人员需要参考制造商的规格来确定这些时间值的极限。
- en: Let’s look at a few examples of flip-flop circuits that can be controlled by
    a clock.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看几个可以由时钟控制的触发器电路的例子。
- en: '***D Flip-Flop***'
  id: totrans-141
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***D触发器***'
- en: We’ll begin by connecting a clock signal to the *Enable* input of the gated
    D latch in [Figure 7-6](ch07.xhtml#ch7fig6). Here, the input affects the output
    as long as *Enable* = `1`. The problem is that if the input changes while *Enable*
    = `1`, the output will also change, leading to an unreliable design.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将通过将时钟信号连接到[图7-6](ch07.xhtml#ch7fig6)中的受控D锁存器的*Enable*输入开始。在这里，只要*Enable*
    = `1`，输入就会影响输出。问题是如果在*Enable* = `1`时输入发生变化，输出也会变化，导致设计不可靠。
- en: One way to isolate the output from input changes is to connect the outputs of
    our D latch to the inputs of an SR latch in a primary/secondary configuration,
    as shown in [Figure 7-8](ch07.xhtml#ch7fig8).
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 一种将输出与输入变化隔离的方法是将我们的D锁存器的输出连接到SR锁存器的输入，以主/从配置连接，如[图7-8](ch07.xhtml#ch7fig8)所示。
- en: '![Image](../images/pg165_Image_215.jpg)'
  id: totrans-144
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/pg165_Image_215.jpg)'
- en: '*Figure 7-8: A D flip-flop, positive-edge triggering*'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: '*图7-8：一个D触发器，正边沿触发*'
- en: The primary portion of the D flip-flop processes the input and provides a reliable
    input to the secondary portion for final output. The bit we want to store, `0`
    or `1`, is fed to the *D* input of the D latch, and the clock signal is fed to
    the *CLK* input. The uncomplemented output of the D latch is fed to the *S* input,
    and its complemented output is fed to the *R* input of the SR latch. The final
    output of the D flip-flop is the output from the SR latch.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: D触发器的主部分处理输入并向副部分提供可靠的输入以获得最终输出。我们想要存储的位`0`或`1`被送入D锁存器的*D*输入，时钟信号则送入*CLK*输入。D锁存器的未反转输出送入*S*输入，其反转输出送入SR锁存器的*R*输入。D触发器的最终输出来自SR锁存器的输出。
- en: I’ll walk you through how this circuit works. The behavior of the primary portion
    is shown in the truth table for a D latch in [Table 7-4](ch07.xhtml#ch7tab4).
    The behavior of the secondary portion is shown in the truth table for an SR latch
    in [Table 7-3](ch07.xhtml#ch7tab3). [Figure 7-9](ch07.xhtml#ch7fig9) shows the
    timing of the key points in our D flip-flop.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 我将向你解释这个电路是如何工作的。主部分的行为在[表7-4](ch07.xhtml#ch7tab4)中显示了D锁存器的真值表。副部分的行为在[表7-3](ch07.xhtml#ch7tab3)中显示了SR锁存器的真值表。[图7-9](ch07.xhtml#ch7fig9)展示了我们D触发器中关键点的时序。
- en: '![Image](../images/pg166_Image_216.jpg)'
  id: totrans-148
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/pg166_Image_216.jpg)'
- en: '*Figure 7-9: The timing of a D flip-flop*'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: '*图7-9：D触发器的时序*'
- en: The data input, *D*, in [Figure 7-9](ch07.xhtml#ch7fig9) is not in complete
    synchrony with the clock signal, and its timing is somewhat irregular. This can
    occur due to propagation delays, interference from other components, temperature
    gradients in the circuits, and other factors.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: '[图7-9](ch07.xhtml#ch7fig9)中的数据输入*D*与时钟信号并不完全同步，它的时序有些不规则。这可能是由于传播延迟、其他组件的干扰、电路中的温度梯度以及其他因素引起的。'
- en: We’ll start at the point where CLK first goes to `0`. This signal is inverted,
    which enables the D latch. The output of the D latch, *S*, follows the *D* input,
    going from `0` to `1`. The second inverter in the CLK path to the SR latch disables
    it, latching the flip-flop output, *Q*, at the `0` level.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从CLK首次变为`0`的时刻开始。这个信号被反转，从而启用D锁存器。D锁存器的输出*S*跟随*D*输入，从`0`变为`1`。时钟路径中的第二个反相器禁用SR锁存器，从而锁存触发器的输出*Q*，保持在`0`电平。
- en: When the CLK signal goes to `1`, the D latch is disabled, which latches its
    outputs, *S* and *R*, at `1` and `0`. This presents stable inputs to the SR latch
    during this clock half-cycle. The twice-inverted CLK signal enables the SR latch,
    which causes the output of the flip-flop, *Q*, to go to `1`.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 当CLK信号为`1`时，D锁存器被禁用，这将其输出*S*和*R*分别锁存为`1`和`0`。在这个时钟半周期内，这为SR锁存器提供了稳定的输入信号。经过两次反转的CLK信号使SR锁存器被启用，从而使触发器的输出*Q*变为`1`。
- en: The CLK signal then goes to `0`, disabling the SR latch in the secondary portion,
    which remains latched at the `1` level for this clock half-cycle.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，CLK信号变为`0`，禁用二级部分的SR锁存器，这在该时钟半周期内保持在`1`电平。
- en: Thus, the flip-flop introduces a time delay of one-half clock cycle between
    accepting an input and providing an output, but the output is stable for an entire
    clock period. The output is available at a precise point in time, the `0` to `1`
    transition. This is called *positive-edge triggering*. If the first NOT gate connected
    to the CLK signal in [Figure 7-8](ch07.xhtml#ch7fig8) were removed, we would have
    a D flip-flop with *negative-edge triggering*.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，触发器引入了一个半个时钟周期的时间延迟，用于接受输入并提供输出，但输出在整个时钟周期内保持稳定。输出在一个精确的时间点可用，即从`0`到`1`的过渡。这就是所谓的*正边缘触发*。如果[图7-8](ch07.xhtml#ch7fig8)中连接到CLK信号的第一个NOT门被移除，我们就会得到一个具有*负边缘触发*的D触发器。
- en: Sometimes a flip-flop must be set to a known value before the clocking begins—for
    example, when a computer is first starting up. These known values are input independently
    of the clock process; hence, they are *asynchronous inputs*.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，触发器必须在时钟信号开始之前被设置为已知值——例如，在计算机启动时。这些已知值是独立于时钟过程输入的；因此，它们是*异步输入*。
- en: '[Figure 7-10](ch07.xhtml#ch7fig10) shows a D flip-flop with an *asynchronous
    preset* (*PR*) input added to it.'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: '[图7-10](ch07.xhtml#ch7fig10)展示了一种添加了*异步预置*（*PR*）输入的D触发器。'
- en: '![Image](../images/pg167_Image_217.jpg)'
  id: totrans-157
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/pg167_Image_217.jpg)'
- en: '*Figure 7-10: A positive-edge triggering D flip-flop with an asynchronous preset*'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: '*图7-10：带有异步预置的正边缘触发D触发器*'
- en: When a `1` is applied to the *PR* input, *Q* becomes `1` and ¬*Q* becomes `0`,
    regardless of what the other inputs are—even CLK. It is also common to have an
    asynchronous clear input (*CLR*) that sets the state (and output) to `0`.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 当`1`被施加到*PR*输入时，*Q*变为`1`，而¬*Q*变为`0`，无论其他输入是什么——即使是CLK也不例外。通常也会有一个异步清除输入（*CLR*），它将状态（和输出）设置为`0`。
- en: There are more efficient circuits for implementing edge-triggered D flip-flops,
    but this discussion shows that they can be constructed from ordinary logic gates.
    They are economical and efficient, so they are widely used in *very large scale
    integration (VLSI)* circuits, which are circuits that include billions of transistor
    gates on a single semiconductor microchip.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然实现边沿触发的D触发器有更高效的电路，但本讨论展示了它们如何通过普通的逻辑门来构建。它们既经济又高效，因此被广泛应用于*超大规模集成（VLSI）*电路中，这些电路在单一半导体微芯片上集成了数十亿个晶体管门。
- en: Rather than draw the implementation details for each D flip-flop, circuit designers
    use the symbols shown in [Figure 7-11](ch07.xhtml#ch7fig11).
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 与其绘制每个D触发器的实现细节，电路设计师通常使用[图7-11](ch07.xhtml#ch7fig11)中显示的符号。
- en: '![Image](../images/pg167_Image_218.jpg)'
  id: totrans-162
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/pg167_Image_218.jpg)'
- en: '*Figure 7-11: The symbols used for D flip-flops: (a) positive-edge triggering,
    (b) negative-edge triggering*'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: '*图7-11：用于D触发器的符号：（a）正边缘触发，（b）负边缘触发*'
- en: The various inputs and outputs are labeled in [Figure 7-11](ch07.xhtml#ch7fig11).
    Hardware designers typically use *Ǭ* instead of ¬*Q*. It’s common to label the
    flip-flop as *Qn*, where *n* = 1, 2, . . . , which is used to identify the flip-flop
    within the overall circuit. The small circle at the clock input in [Figure 7-11](ch07.xhtml#ch7fig11)(b)
    means that this D flip-flop is triggered by a negative-going clock transition.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: '[图7-11](ch07.xhtml#ch7fig11)中标出了各种输入和输出。硬件设计师通常使用*Ǭ*代替¬*Q*。通常会将触发器标记为*Qn*，其中*n*
    = 1, 2, . . .，用来识别整个电路中的触发器。[图7-11](ch07.xhtml#ch7fig11)(b)中时钟输入处的小圆圈表示该D触发器是由负脉冲时钟触发的。'
- en: Now that you’ve seen some logic components that save state, let’s look at the
    process of designing sequential logic circuits using these components.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经看到了保存状态的一些逻辑组件，让我们来看看使用这些组件设计顺序逻辑电路的过程。
- en: '### **Designing Sequential Logic Circuits**'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: '### **设计顺序逻辑电路**'
- en: We’ll consider a general set of steps for designing sequential logic circuits.
    Design in any field is usually iterative, as you have no doubt learned from your
    programming experience. You start with a design, analyze it, and then refine the
    design to make it faster, less expensive, and so on. After you’ve gained some
    experience, the design process usually requires fewer iterations.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将考虑设计时序逻辑电路的一般步骤。设计通常是迭代的，正如你从编程经验中无疑已经学到的那样。你从一个设计开始，分析它，然后完善设计，使其更快、更便宜，等等。随着经验的积累，设计过程通常需要更少的迭代。
- en: 'The following steps are a good method for building a first working design:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 以下步骤是构建第一个工作设计的好方法：
- en: From the plain-language description of the problem, create a state transition
    table and state diagram showing what the circuit must do. These form the basic
    technical specifications for the circuit you will be designing.
  id: totrans-169
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从问题的自然语言描述中，创建状态转换表和状态图，展示电路需要执行的操作。这些形成了你将设计的电路的基本技术规范。
- en: Choose a binary code for the states and create a binary-coded version of the
    state table and/or state diagram. For *N* states, the code will need log[2] *N*
    bits. Any code will work, but some codes may lead to simpler combinational logic
    in the circuit.
  id: totrans-170
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择一个二进制代码来表示状态，并创建状态表和/或状态图的二进制编码版本。对于*N*个状态，代码需要log[2] *N*位。任何代码都可以使用，但某些代码可能会导致电路中组合逻辑的简化。
- en: Choose a type of flip-flop. This choice is often dictated by the components
    you have on hand.
  id: totrans-171
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择一个触发器类型。这个选择通常由你手头的组件决定。
- en: Determine the inputs required to each flip-flop to cause each of the required
    transitions.
  id: totrans-172
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确定每个触发器所需的输入，以实现每个所需的转换。
- en: Simplify the inputs to each flip-flop. Karnaugh maps or algebraic methods are
    good tools for the simplification process.
  id: totrans-173
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 简化每个触发器的输入。卡诺图或代数方法是简化过程中的好工具。
- en: Draw the circuit.
  id: totrans-174
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 绘制电路。
- en: Step 5 may cause you to rethink your choice of type of flip-flop. The three
    steps of flip-flop choice, determining inputs, and simplification may need to
    be repeated several times to reach a good design. The following two examples illustrate
    this process. You can think of these as guided “Your Turn” exercises; if you have
    access to a digital circuit simulator, or the required hardware, I suggest you
    use those resources to follow along.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 步骤5可能会让你重新思考选择的触发器类型。选择触发器、确定输入和简化这三个步骤可能需要反复进行，直到达到一个好的设计。以下两个例子说明了这个过程。你可以把这些当作引导性的“你的回合”练习；如果你有数字电路模拟器或所需的硬件，我建议你利用这些资源跟随练习。
- en: '***A Counter***'
  id: totrans-176
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***计数器***'
- en: 'We want to design a counter that has an *Enable* input. When *Enable* = `1`,
    it increments through the sequence 0, 1, 2, 3, 0, 1, . . . , incrementing with
    each clock tick. *Enable* = `0` causes the counter to remain in its current state.
    The output is the sequence number in 2-bit binary. Here are the steps:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 我们想设计一个具有*使能*输入的计数器。当*使能* = `1`时，它会按照序列 0, 1, 2, 3, 0, 1, . . . 递增，每次时钟信号触发时递增。*使能*
    = `0`会使计数器保持在当前状态。输出是该序列的2位二进制数。以下是步骤：
- en: '**Step 1: Create a state transition table and state diagram.**'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: '**步骤 1：创建状态转换表和状态图。**'
- en: At each clock tick, the counter increments by 1 if *Enable* = `1`. If *Enable*
    = `0`, it remains in the current state. [Figure 7-12](ch07.xhtml#ch7fig12) shows
    the four states—0, 1, 2, and 3—and the corresponding 2-bit output for each state.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 每个时钟信号触发时，如果*使能* = `1`，计数器会递增1。如果*使能* = `0`，它会保持在当前状态。[图 7-12](ch07.xhtml#ch7fig12)展示了四个状态—0,
    1, 2, 3—以及每个状态对应的2位输出。
- en: '![Image](../images/pg169_Image_219.jpg)'
  id: totrans-180
  prefs: []
  type: TYPE_IMG
  zh: '![图像](../images/pg169_Image_219.jpg)'
- en: '*Figure 7-12: A state diagram for a counter that cycles through 0, 1, 2, 3,
    0, 1, . . .*'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 7-12：计数器的状态图，循环经过0, 1, 2, 3, 0, 1, . . .*'
- en: '[Table 7-5](ch07.xhtml#ch7tab5) shows the state transition table for this counter.'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: '[表 7-5](ch07.xhtml#ch7tab5)展示了这个计数器的状态转换表。'
- en: '**Table 7-5:** A State Transition Table for the Counter'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: '**表 7-5：计数器的状态转换表**'
- en: '|  | ***Enable*** = 0 | ***Enable*** = 1 |'
  id: totrans-184
  prefs: []
  type: TYPE_TB
  zh: '|  | ***使能*** = 0 | ***使能*** = 1 |'
- en: '| --- | --- | --- |'
  id: totrans-185
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| **Current ***n***** | **Next ***n***** | **Next ***n***** |'
  id: totrans-186
  prefs: []
  type: TYPE_TB
  zh: '| **当前***n***** | **下一个***n***** | **下一个***n***** |'
- en: '| --- | --- | --- |'
  id: totrans-187
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| 0 | 0 | 1 |'
  id: totrans-188
  prefs: []
  type: TYPE_TB
  zh: '| 0 | 0 | 1 |'
- en: '| 1 | 1 | 2 |'
  id: totrans-189
  prefs: []
  type: TYPE_TB
  zh: '| 1 | 1 | 2 |'
- en: '| 2 | 2 | 3 |'
  id: totrans-190
  prefs: []
  type: TYPE_TB
  zh: '| 2 | 2 | 3 |'
- en: '| 3 | 3 | 0 |'
  id: totrans-191
  prefs: []
  type: TYPE_TB
  zh: '| 3 | 3 | 0 |'
- en: When *Enable* = `0`, the counter is essentially turned off; when *Enable* =
    `1`, the counter automatically increments by 1, wrapping around to 0 after it
    reaches its limit of 3.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 当*使能* = `0`时，计数器基本上是关闭的；当*使能* = `1`时，计数器会自动递增1，达到上限3后回绕到0。
- en: '**Step 2: Create a binary-coded version of the state table/state diagram.**'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: '**步骤 2：创建状态表/状态图的二进制编码版本。**'
- en: With four states, we need 2 bits. We’ll let *n* be the state, which we represent
    with the 2-bit binary number *n*[1]*n*[0]. [Table 7-6](ch07.xhtml#ch7tab6) shows
    the behavior.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 对于四个状态，我们需要2位。我们将*n*定义为状态，用2位二进制数*n*[1]*n*[0]表示。[表 7-6](ch07.xhtml#ch7tab6)展示了其行为。
- en: '**Table 7-6:** A State Transition Table for a 2-Bit Counter'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: '**表 7-6：** 2位计数器的状态转换表'
- en: '|  | **Current** | **Next** |'
  id: totrans-196
  prefs: []
  type: TYPE_TB
  zh: '|  | **当前** | **下一个** |'
- en: '| --- | --- | --- |'
  id: totrans-197
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| ***Enable*** | ***n***[1] | ***n***[0] | ***n***[1] | ***n***[0] |'
  id: totrans-198
  prefs: []
  type: TYPE_TB
  zh: '| ***使能*** | ***n***[1] | ***n***[0] | ***n***[1] | ***n***[0] |'
- en: '| --- | --- | --- | --- | --- |'
  id: totrans-199
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- | --- |'
- en: '| `0` | `0` | `0` | `0` | `0` |'
  id: totrans-200
  prefs: []
  type: TYPE_TB
  zh: '| `0` | `0` | `0` | `0` | `0` |'
- en: '| `0` | `0` | `1` | `0` | `1` |'
  id: totrans-201
  prefs: []
  type: TYPE_TB
  zh: '| `0` | `0` | `1` | `0` | `1` |'
- en: '| `0` | `1` | `0` | `1` | `0` |'
  id: totrans-202
  prefs: []
  type: TYPE_TB
  zh: '| `0` | `1` | `0` | `1` | `0` |'
- en: '| `0` | `1` | `1` | `1` | `1` |'
  id: totrans-203
  prefs: []
  type: TYPE_TB
  zh: '| `0` | `1` | `1` | `1` | `1` |'
- en: '| `1` | `0` | `0` | `0` | `1` |'
  id: totrans-204
  prefs: []
  type: TYPE_TB
  zh: '| `1` | `0` | `0` | `0` | `1` |'
- en: '| `1` | `0` | `1` | `1` | `0` |'
  id: totrans-205
  prefs: []
  type: TYPE_TB
  zh: '| `1` | `0` | `1` | `1` | `0` |'
- en: '| `1` | `1` | `0` | `1` | `1` |'
  id: totrans-206
  prefs: []
  type: TYPE_TB
  zh: '| `1` | `1` | `0` | `1` | `1` |'
- en: '| `1` | `1` | `1` | `0` | `0` |'
  id: totrans-207
  prefs: []
  type: TYPE_TB
  zh: '| `1` | `1` | `1` | `0` | `0` |'
- en: '**Step 3: Select a flip-flop.**'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: '**步骤 3：选择触发器。**'
- en: We’ll use D flip-flops. After going through the design, we may decide that another
    flip-flop might work better. We could then come back to this step and go through
    the remaining steps again. An experienced designer may have some insight into
    the problem that would suggest starting with another type of flip-flop. Often,
    any potential savings in cost or power consumption do not justify changing to
    another type of flip-flop.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用D触发器。经过设计后，我们可能会决定使用另一种触发器效果更好。然后，我们可以返回这一阶段，重新执行剩余步骤。一位经验丰富的设计师可能会对问题有一些见解，建议从另一种类型的触发器开始。通常，任何潜在的成本或功耗节省都不足以证明更换为另一种类型的触发器是值得的。
- en: '**Step 4: Determine the inputs to the flip-flops.**'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: '**步骤 4：确定触发器的输入。**'
- en: We need two flip-flops, one for each bit. A D flip-flop simply stores the value
    of its input on the next clock cycle, so the inputs that cause each flip-flop
    to change to the next state are shown under the two “Next” columns in [Table 7-6](ch07.xhtml#ch7tab6).
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要两个触发器，每个比特一个。D触发器会在下一个时钟周期存储其输入的值，因此导致每个触发器变化到下一个状态的输入在[表 7-6](ch07.xhtml#ch7tab6)的“Next”列下显示。
- en: 'We can write the Boolean equations that show the logical combinations of the
    inputs, *Enable* and the current *n*[1] and *n*[0], that produce the required
    inputs. We’ll use *E* for *Enable* and *D*[1] and *D*[0] for the inputs to the
    respective D flip-flops:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以写出布尔方程，显示输入*使能*（Enable）和当前的*n*[1]和*n*[0]的逻辑组合，从而产生所需的输入。我们将使用*E*表示*使能*，用*D*[1]和*D*[0]表示各自D触发器的输入：
- en: '![Image](../images/pg170_Image_220.jpg)'
  id: totrans-213
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/pg170_Image_220.jpg)'
- en: '**Step 5: Simplify the required inputs.**'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: '**步骤 5：简化所需的输入。**'
- en: We can use Karnaugh maps to find a simpler solution, as shown in [Figure 7-13](ch07.xhtml#ch7fig13).
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用卡诺图来找到更简单的解决方案，如[图 7-13](ch07.xhtml#ch7fig13)所示。
- en: '![Image](../images/pg170_Image_221.jpg)'
  id: totrans-216
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/pg170_Image_221.jpg)'
- en: '*Figure 7-13: Karnaugh maps for a 2-bit counter implemented with D flip-flops*'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 7-13：使用D触发器实现的2位计数器的卡诺图*'
- en: 'The Karnaugh maps allow us to simplify the Boolean equations for the input
    to each flip-flop:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 卡诺图使我们能够简化每个触发器输入的布尔方程：
- en: '![Image](../images/pg170_Image_222.jpg)'
  id: totrans-219
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/pg170_Image_222.jpg)'
- en: '**Step 6: Draw the circuit.**'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: '**步骤 6：绘制电路图。**'
- en: We’ll use a PLA (introduced in “Programmable Logic Array” on [page 120](ch06.xhtml#ch06lev2sec5)
    in [Chapter 6](ch06.xhtml)) to generate the inputs to the two D flip-flops. [Figure
    7-14](ch07.xhtml#ch7fig14) shows our resulting circuit used to implement this
    counter.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用一个PLA（在[第6章](ch06.xhtml#ch06lev2sec5)的“可编程逻辑阵列”中介绍）来生成两个D触发器的输入。[图 7-14](ch07.xhtml#ch7fig14)展示了我们用来实现该计数器的电路。
- en: '![Image](../images/pg171_Image_223.jpg)'
  id: totrans-222
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/pg171_Image_223.jpg)'
- en: '*Figure 7-14: A 2-bit counter implemented with a PLA and two D flip-flops*'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 7-14：用PLA和两个D触发器实现的2位计数器*'
- en: '[Figure 7-15](ch07.xhtml#ch7fig15) shows the timing of the binary counter when
    progressing through the sequence 3, 0, 1, 2, 3 (`11, 00, 01, 10, 11`).'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 7-15](ch07.xhtml#ch7fig15)展示了二进制计数器的时序图，当其按顺序进展 3、0、1、2、3（`11, 00, 01, 10,
    11`）时。'
- en: '![Image](../images/pg171_Image_224.jpg)'
  id: totrans-225
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/pg171_Image_224.jpg)'
- en: '*Figure 7-15: The timing of a 2-bit counter implemented with D flip-flops*'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 7-15：用D触发器实现的2位计数器的时序图*'
- en: '*D[i]* is the input to the *i*th D flip-flop, and *n[i]* is its output. Remember
    that when the *i*th input, *D[i]*, is applied to its D flip-flop, the output of
    the flip-flop does not change until the second half of the clock cycle. This can
    be seen when comparing the trace for the corresponding output, *n[i]*, in the
    figure.'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: '*D[i]* 是第 *i* 个 D 触发器的输入，*n[i]* 是其输出。请记住，当第 *i* 个输入 *D[i]* 被应用到其 D 触发器时，触发器的输出直到时钟周期的后半段才会发生变化。这可以通过比较图中相应输出
    *n[i]* 的迹线来看到。'
- en: '***A Branch Predictor***'
  id: totrans-228
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***分支预测器***'
- en: For our second example, we’ll design a branch predictor. This example is a bit
    more complicated than the previous one.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的第二个示例中，我们将设计一个分支预测器。这个例子比前一个要复杂一些。
- en: 'Except for very inexpensive microcontrollers, most modern CPUs execute instructions
    in stages. Each stage consists of hardware that is specialized to perform the
    operations in that stage. An instruction passes through each stage in an assembly-line
    fashion. For example, if you were to create an assembly line to manufacture wooden
    chairs, you could do it in three stages: saw the wood to make the parts for the
    chair, assemble the parts, and paint the chair. The hardware needed at each stage
    would be saw, hammer and screwdriver, and paintbrush.'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 除了非常便宜的微控制器，大多数现代CPU都分阶段执行指令。每个阶段由专门的硬件组成，用于执行该阶段的操作。指令像流水线一样通过每个阶段。例如，如果你要创建一个流水线来制造木椅，你可以分为三个阶段：锯木头制作椅子的零件，组装零件，最后涂漆椅子。每个阶段所需的硬件分别是锯子、锤子和螺丝刀、以及画笔。
- en: The arrangement of specialized hardware in the CPU is called a *pipeline*. The
    hardware in the first stage is designed to fetch an instruction from memory, as
    you’ll see in [Chapter 9](ch09.xhtml). After an instruction is fetched from memory,
    it passes on to the next stage of the pipeline, where it is decoded. Simultaneously,
    the first stage of the pipeline fetches the next instruction from memory. The
    result is that the CPU is working on several instructions at the same time. This
    provides some parallelism, thus improving execution speed.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: CPU中专用硬件的安排称为*流水线*。流水线的第一阶段硬件设计用于从内存中提取指令，正如你在[第9章](ch09.xhtml)中将看到的那样。在从内存中提取指令后，指令会传递到流水线的下一个阶段，在那里进行解码。同时，流水线的第一阶段会从内存中提取下一条指令。结果是CPU同时处理多条指令，这提供了一些并行性，从而提高了执行速度。
- en: Almost all programs contain *conditional branch points*—places where the next
    instruction to be fetched can be in one of two different memory locations. Unfortunately,
    there is no way to know which of the two instructions to fetch until the decision-making
    instruction has moved several stages into the pipeline.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 几乎所有程序都包含*条件分支点*——即下一个要提取的指令可能位于两个不同内存位置的地方。不幸的是，直到决策指令经过流水线的多个阶段，才知道应该提取哪一条指令。
- en: To maintain execution speed, as soon as a conditional branch instruction has
    passed on from the fetch stage, it’s helpful if the CPU can predict where to fetch
    the next instruction from. Then it can go ahead and do so. If the prediction was
    wrong, the CPU simply ignores the work it has done on the predicted instruction
    by flushing out the pipeline and fetching the other instruction, which enters
    the beginning of the pipeline.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 为了保持执行速度，一旦条件分支指令从提取阶段传递过来，如果CPU能够预测从哪里提取下一条指令，就会很有帮助。然后，它可以继续执行。如果预测错误，CPU会通过清空流水线并提取其他指令来忽略在预测指令上所做的工作，新的指令进入流水线的开始阶段。
- en: In this section, we’ll design a circuit that predicts whether a conditional
    branch will be taken. The predictor will continue to predict the same outcome,
    and the branch will be either taken or not taken, until it makes two mistakes
    in a row.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一节中，我们将设计一个电路，用于预测条件分支是否会被执行。预测器将持续预测相同的结果，直到连续两次预测错误，分支才会被执行或不执行。
- en: 'Here are the steps we will follow in designing our branch predictor circuit:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是我们设计分支预测器电路时将遵循的步骤：
- en: '**Step 1: Create a state table and state diagram.**'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: '**步骤 1：创建状态表和状态图。**'
- en: We’ll use Yes to indicate when the branch is taken and No to indicate when it
    isn’t. The state diagram in [Figure 7-16](ch07.xhtml#ch7fig16) shows the four
    possible states.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用“Yes”表示分支被执行，使用“No”表示分支未被执行。状态图在[图 7-16](ch07.xhtml#ch7fig16)中显示了四种可能的状态。
- en: '![Image](../images/pg173_Image_225.jpg)'
  id: totrans-238
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/pg173_Image_225.jpg)'
- en: '*Figure 7-16: The four possible states for our branch predictor*'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 7-16：我们的分支预测器的四种可能状态*'
- en: Let’s begin in the No state. Here, the branch was not taken at least the last
    two times this instruction was executed. The output is to predict that it will
    also not be taken this time. The input to the circuit is whether the branch has
    actually been taken when the instruction has completed execution.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从 No 状态开始。在这里，至少在最后两次执行此指令时，分支都未被执行。输出是预测这次也不会被执行。电路的输入是指令执行完毕后，分支是否实际被执行。
- en: The arc labeled Actual = Not Taken in [Figure 7-16](ch07.xhtml#ch7fig16) loops
    back to the No state, with the prediction (the output) that the branch will not
    be taken the next time the instruction is executed. If the branch is taken, the
    Actual = Taken arc shows that the circuit moves into the No–Error state to indicate
    one error in the prediction. But because it must be wrong twice in a row to change
    our prediction, the circuit is still predicting Don’t Take as the output.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 在[图7-16](ch07.xhtml#ch7fig16)中标记为 Actual = Not Taken 的弧线回到 No 状态，预测（输出）是下次执行指令时分支将不会被执行。如果分支被执行，Actual
    = Taken 的弧线表明电路进入 No–Error 状态，表示预测出现一次错误。但因为必须连续两次出错才能改变预测，所以电路仍然预测不会执行分支（Don’t
    Take）作为输出。
- en: From the No–Error state, if the branch is not taken (the prediction is correct),
    the circuit returns to the No state. However, if the branch is taken, the circuit
    predicted incorrectly twice in a row, so the circuit moves to the Yes state and
    the output is to predict Take.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 从 No–Error 状态出发，如果分支未被执行（预测正确），电路返回到 No 状态。然而，如果分支被执行，电路连续两次预测错误，因此电路进入 Yes
    状态，并且输出为预测执行分支（Take）。
- en: I’ll leave tracing through the remainder of this state diagram as an exercise
    for you. Once you’re satisfied with how it works, take a look at [Table 7-7](ch07.xhtml#ch7tab7),
    which provides the technical specifications for our circuit.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 我将剩余部分的状态图追踪留给你作为练习。一旦你对其工作原理感到满意，请查看[表7-7](ch07.xhtml#ch7tab7)，该表提供了我们电路的技术规格。
- en: '**Table 7-7:** The Branch Predictor State Table'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: '**表7-7：** 分支预测器状态表'
- en: '|  |  | **Actual = Not Taken** | **Actual = Taken** |'
  id: totrans-245
  prefs: []
  type: TYPE_TB
  zh: '|  |  | **Actual = Not Taken** | **Actual = Taken** |'
- en: '| --- | --- | --- | --- |'
  id: totrans-246
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- |'
- en: '| **Current state** | **Prediction** | **Next state** | **Prediction** | **Next
    state** | **Prediction** |'
  id: totrans-247
  prefs: []
  type: TYPE_TB
  zh: '| **当前状态** | **预测** | **下一个状态** | **预测** | **下一个状态** | **预测** |'
- en: '| --- | --- | --- | --- | --- | --- |'
  id: totrans-248
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- | --- | --- |'
- en: '| No | Don’t Take | No | Don’t Take | No–Error | Don’t Take |'
  id: totrans-249
  prefs: []
  type: TYPE_TB
  zh: '| No | 不执行 | No | 不执行 | No–Error | 不执行 |'
- en: '| No–Error | Don’t Take | No | Don’t Take | Yes | Take |'
  id: totrans-250
  prefs: []
  type: TYPE_TB
  zh: '| No–Error | 不执行 | No | 不执行 | 是 | 执行 |'
- en: '| Yes–Error | Take | No | Don’t Take | Yes | Take |'
  id: totrans-251
  prefs: []
  type: TYPE_TB
  zh: '| Yes–Error | 执行 | No | 不执行 | Yes | 执行 |'
- en: '| Yes | Take | Yes–Error | Take | Yes | Take |'
  id: totrans-252
  prefs: []
  type: TYPE_TB
  zh: '| Yes | 执行 | Yes–Error | 执行 | Yes | 执行 |'
- en: When the result of the conditional branch (taken or not taken) is determined
    in the pipeline, [Table 7-7](ch07.xhtml#ch7tab7) shows the next state and the
    corresponding prediction. This prediction will be used to determine which of the
    two possible addresses—the address of the next instruction or the address of the
    branch target—to store for use the next time this instruction is encountered in
    the program.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 当条件分支的结果（是否执行分支）在流水线中被确定时，[表7-7](ch07.xhtml#ch7tab7)显示下一个状态以及相应的预测。这个预测将用于确定下次遇到此指令时，应该存储哪个地址——下一个指令的地址还是分支目标的地址。
- en: '**Step 2: Represent the states.**'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: '**步骤 2：表示状态。**'
- en: For this problem, we’ll choose a binary code for the state, *s*[1]*s*[0], as
    shown in [Table 7-8](ch07.xhtml#ch7tab8).
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个问题，我们将选择一个二进制代码表示状态，*s*[1]*s*[0]，如[表7-8](ch07.xhtml#ch7tab8)所示。
- en: '**Table 7-8:** The States of the Branch Predictor'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: '**表7-8：** 分支预测器的状态'
- en: '| **State** | ***s***[1] | ***s***[0] | **Prediction** |'
  id: totrans-257
  prefs: []
  type: TYPE_TB
  zh: '| **状态** | ***s***[1] | ***s***[0] | **预测** |'
- en: '| --- | --- | --- | --- |'
  id: totrans-258
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- |'
- en: '| No | `0` | `0` | Don’t Take |'
  id: totrans-259
  prefs: []
  type: TYPE_TB
  zh: '| No | `0` | `0` | 不执行 |'
- en: '| No–Error | `0` | `1` | Don’t Take |'
  id: totrans-260
  prefs: []
  type: TYPE_TB
  zh: '| No–Error | `0` | `1` | 不执行 |'
- en: '| Yes–Error | `1` | `0` | Take |'
  id: totrans-261
  prefs: []
  type: TYPE_TB
  zh: '| Yes–Error | `1` | `0` | 执行 |'
- en: '| Yes | `1` | `1` | Take |'
  id: totrans-262
  prefs: []
  type: TYPE_TB
  zh: '| Yes | `1` | `1` | 执行 |'
- en: The prediction is 1 bit, *s*[1], which is `0` if the prediction is Don’t Take
    and `1` if the prediction is Take.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 预测是 1 位的，*s*[1]，如果预测为不执行分支（Don’t Take），则为 `0`，如果预测为执行分支（Take），则为 `1`。
- en: Letting the input, Actual, be `0` when the branch is not taken and `1` when
    it is taken and using the state notation of [Table 7-8](ch07.xhtml#ch7tab8), we
    get the state transition table shown in [Table 7-9](ch07.xhtml#ch7tab9).
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 让输入 Actual 在分支未被执行时为 `0`，在分支被执行时为 `1`，并使用[表7-8](ch07.xhtml#ch7tab8)中的状态表示法，我们得到[表7-9](ch07.xhtml#ch7tab9)所示的状态转移表。
- en: '**Table 7-9:** The State Transition Table for the Branch Predictor'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: '**表 7-9：分支预测器的状态转移表**'
- en: '|  | **Current** | **Next** |'
  id: totrans-266
  prefs: []
  type: TYPE_TB
  zh: '|  | **当前** | **下一个** |'
- en: '| --- | --- | --- |'
  id: totrans-267
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| **Actual** | ***s***[1] | ***s***[0] | ***s***[1] | ***s***[0] |'
  id: totrans-268
  prefs: []
  type: TYPE_TB
  zh: '| **实际** | ***s***[1] | ***s***[0] | ***s***[1] | ***s***[0] |'
- en: '| --- | --- | --- | --- | --- |'
  id: totrans-269
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- | --- |'
- en: '| `0` | `0` | `0` | `0` | `0` |'
  id: totrans-270
  prefs: []
  type: TYPE_TB
  zh: '| `0` | `0` | `0` | `0` | `0` |'
- en: '| `0` | `0` | `1` | `0` | `0` |'
  id: totrans-271
  prefs: []
  type: TYPE_TB
  zh: '| `0` | `0` | `1` | `0` | `0` |'
- en: '| `0` | `1` | `0` | `0` | `0` |'
  id: totrans-272
  prefs: []
  type: TYPE_TB
  zh: '| `0` | `1` | `0` | `0` | `0` |'
- en: '| `0` | `1` | `1` | `1` | `0` |'
  id: totrans-273
  prefs: []
  type: TYPE_TB
  zh: '| `0` | `1` | `1` | `1` | `0` |'
- en: '| `1` | `0` | `0` | `0` | `1` |'
  id: totrans-274
  prefs: []
  type: TYPE_TB
  zh: '| `1` | `0` | `0` | `0` | `1` |'
- en: '| `1` | `0` | `1` | `1` | `1` |'
  id: totrans-275
  prefs: []
  type: TYPE_TB
  zh: '| `1` | `0` | `1` | `1` | `1` |'
- en: '| `1` | `1` | `0` | `1` | `1` |'
  id: totrans-276
  prefs: []
  type: TYPE_TB
  zh: '| `1` | `1` | `0` | `1` | `1` |'
- en: '| `1` | `1` | `1` | `1` | `1` |'
  id: totrans-277
  prefs: []
  type: TYPE_TB
  zh: '| `1` | `1` | `1` | `1` | `1` |'
- en: When the conditional branch instruction reaches a point in the pipeline where
    it is determined whether the branch should be taken or not, this information is
    used as the input, Actual, to the predictor circuit, which transforms the state
    from Current to Next for the next time this instruction is encountered.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 当条件分支指令到达流水线中的一个点时，系统将决定是否执行该分支，这个信息作为输入 Actual 被传递到预测器电路中，该电路将状态从当前状态（Current）转换为下一个状态（Next），以便在下次遇到该指令时使用。
- en: '**Step 3: Select a flip-flop.**'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: '**步骤 3：选择一个触发器。**'
- en: We’ll use D flip-flops again here, with the same caveats as in the previous
    example.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里再次使用 D 触发器，并且与前一个例子一样，仍然有相同的注意事项。
- en: '**Step 4: Determine the inputs to the flip-flops.**'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: '**步骤 4：确定触发器的输入。**'
- en: We need two flip-flops, one for each bit. A D flip-flop simply stores the value
    of its input on the next clock cycle, so the inputs that cause each flip-flop
    to change to the next state are shown under the two “Next” columns in [Table 7-9](ch07.xhtml#ch7tab9).
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要两个触发器，每个位一个。D 触发器会在下一个时钟周期存储其输入值，因此引起每个触发器状态变化的输入显示在[表 7-9](ch07.xhtml#ch7tab9)中的两个“下一个”列下。
- en: 'We can write the Boolean equations that show the logical combinations of the
    three signals, Actual and the Current *s*[1] and *s*[0] that produce the required
    input to each D flip-flop to cause it to go to the Next *s*[1] and *s*[0]. We’ll
    use *A* for Actual and *D*[1] and *D*[0] for the inputs to the respective D flip-flops:'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以写出布尔方程，显示三个信号的逻辑组合，Actual 和当前的 *s*[1] 与 *s*[0]，它们产生所需的输入给每个 D 触发器，使其转到下一个
    *s*[1] 和 *s*[0]。我们将使用 *A* 来表示 Actual，使用 *D*[1] 和 *D*[0] 来表示分别传递给 D 触发器的输入：
- en: '![Image](../images/pg175_Image_226.jpg) **Step 5: Simplify the required inputs.**'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: '![Image](../images/pg175_Image_226.jpg) **步骤 5：简化所需的输入。**'
- en: 'We’ll start by using the following Boolean identities:'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将通过使用以下布尔恒等式开始：
- en: '![Image](../images/pg176_Image_227.jpg)'
  id: totrans-286
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/pg176_Image_227.jpg)'
- en: 'Our equations become:'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的方程变为：
- en: '![Image](../images/pg176_Image_228.jpg)'
  id: totrans-288
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/pg176_Image_228.jpg)'
- en: '**Step 6: Draw the circuit.**'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: '**步骤 6：绘制电路图。**'
- en: In this circuit, the input is Actual = `0` if the branch was not taken the last
    time and Actual = `1` if it was taken. As with our counter, we’ll use a PLA with
    our two D flip-flops, as shown in [Figure 7-17](ch07.xhtml#ch7fig17).
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个电路中，输入为 Actual = `0`，如果上次分支未被执行；如果分支被执行，则输入为 Actual = `1`。与我们的计数器一样，我们将使用一个
    PLA 和两个 D 触发器，正如在[图 7-17](ch07.xhtml#ch7fig17)中所示。
- en: '![Image](../images/pg176_Image_229.jpg)'
  id: totrans-291
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/pg176_Image_229.jpg)'
- en: '*Figure 7-17: The branch predictor circuit using a PLA and two D flip-flops*'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 7-17：使用 PLA 和两个 D 触发器的分支预测器电路*'
- en: This example shows the simplest method of branch prediction. More complex methods
    exist, and there is also ongoing research into branch prediction’s effectiveness.
    Although it can speed up some algorithms, the additional hardware required for
    branch prediction consumes more electrical power, which is a concern in battery-powered
    devices.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子展示了最简单的分支预测方法。虽然存在更复杂的方法，且关于分支预测效果的研究仍在进行中，尽管它可以加速某些算法，但分支预测所需的额外硬件会消耗更多电力，这在电池供电的设备中是一个值得关注的问题。
- en: 'We used D flip-flops and PLAs in both of these example designs, but as usual,
    the choice of components depends on multiple factors: cost, availability of components,
    design tools, design time, power usage, and so forth.'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这两个例子设计中都使用了 D 触发器和 PLA，但像往常一样，组件的选择取决于多个因素：成本、组件的可用性、设计工具、设计时间、电力消耗等等。
- en: '**YOUR TURN**'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: '**现在轮到你了**'
- en: 7.1     Redesign the 2-bit counter in [Figure 7-14](ch07.xhtml#ch7fig14) to
    use individual gates instead of a PLA.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 7.1    重新设计[图 7-14](ch07.xhtml#ch7fig14)中的 2 位计数器，使用单独的门而不是 PLA。
- en: 7.2     Redesign the branch predictor in [Figure 7-17](ch07.xhtml#ch7fig17)
    to use individual gates instead of a PLA.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 7.2    重新设计[图 7-17](ch07.xhtml#ch7fig17)中的分支预测器，使用单独的门而不是 PLA。
- en: '**What You’ve Learned**'
  id: totrans-298
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**你学到了什么**'
- en: '**Sequential logic circuits**   These depend on both the current and past inputs.
    They have a time history, which can be summarized by the current state of the
    circuit.'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: '**顺序逻辑电路（Sequential logic circuits）**  这些电路的输出依赖于当前和过去的输入。它们具有时间历史，可以通过电路的当前状态进行概括。'
- en: '**Latch**   A device that stores 1 bit of data. The ability to change the value
    of the bit is controlled by the level of an enabling signal; this is called level
    triggering.'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: '**锁存器（Latch）**  一种存储1位数据的设备。改变该位值的能力由使能信号的电平控制；这种方式称为电平触发。'
- en: '**Flip-flop**   A device that stores 1 bit of data. The ability to change the
    value of the bit is controlled by the transition of a clock signal; this is called
    edge triggering.'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: '**触发器（Flip-flop）**  一种存储1位数据的设备。改变该位值的能力由时钟信号的边沿变化控制；这种方式称为边沿触发。'
- en: '**SR latch**   The state of an SR latch depends on its input and is either
    set or reset.'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: '**SR锁存器（SR latch）**  SR锁存器的状态取决于其输入，可以是设置状态或复位状态。'
- en: '**D flip-flop**   A D flip-flop stores 1 bit of data. By connecting two latches
    in a primary–secondary configuration, the output is isolated from the input, allowing
    a flip-flop to be synchronized with a clock signal. The output of a D flip-flop
    can be changed only once per clock cycle.'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: '**D触发器（D flip-flop）**  D触发器存储1位数据。通过将两个锁存器连接成主从配置，输出与输入隔离，从而使触发器能够与时钟信号同步。D触发器的输出只能在每个时钟周期内更改一次。'
- en: You saw two examples of designing sequential logic circuits with D flip-flops
    and PLAs in this chapter. In the next chapter, you’ll learn about some of the
    various memory structures used in a computer system.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你看到的两个设计顺序逻辑电路的示例是基于D触发器和可编程逻辑阵列（PLAs）。在下一章中，你将学习计算机系统中使用的各种存储结构。
