- en: '3'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '3'
- en: Designing Interfaces
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 设计接口
- en: '![](Images/chapterart.png)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/chapterart.png)'
- en: 'Every project, no matter how large or small, has an API. In fact, it usually
    has several. Some of these are user-facing, like an HTTP endpoint or a command
    line interface, and some are developer-facing, like a library’s public interface.
    On top of these, Rust crates also have a number of internal interfaces: every
    type, trait, and module boundary has its own miniature API that the rest of your
    code interfaces with. As your codebase grows in size and complexity, you’ll find
    it worthwhile to invest some thought and care into how you design even the internal
    APIs to make the experience of using and maintaining the code over time as pleasant
    as possible.'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 每个项目，无论大小，都有 API。实际上，通常有多个 API。其中一些是面向用户的，例如 HTTP 端点或命令行界面，而另一些是面向开发者的，比如库的公共接口。除了这些外，Rust
    的 crate 还拥有许多内部接口：每个类型、trait 和模块边界都有自己的小型 API，其他代码也会与之交互。随着代码库的规模和复杂性增加，你会发现投入一些思考和心思来设计内部
    API 是值得的，这样可以尽量让代码的使用和维护体验变得更为愉快。
- en: 'In this chapter we’ll look at some of the most important considerations for
    writing idiomatic interfaces in Rust, whether the users of those interfaces are
    your own code or other developers using your library. These essentially boil down
    to four principles: your interfaces should be *unsurprising*, *flexible*, *obvious*,
    and *constrained*. I’ll discuss each of these principles in turn, to provide some
    guidance for writing reliable and usable interfaces.'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将介绍编写 Rust 语言习惯接口时需要考虑的一些重要因素，无论这些接口的用户是你自己的代码，还是其他开发者在使用你的库。这些因素本质上可以归结为四个原则：接口应该是*不令人惊讶*的、*灵活*的、*显而易见*的以及*受限*的。我将依次讨论这四个原则，提供编写可靠且易用接口的指导。
- en: I highly recommend taking a look at the Rust API Guidelines ([https://rust-lang.github.io/api-guidelines/](https://rust-lang.github.io/api-guidelines/))
    after you’ve read this chapter. There’s an excellent checklist you can follow,
    with a detailed run-through of each recommendation. Many of the recommendations
    in this chapter are also checked by the `cargo clippy` tool, which you should
    start running on your code if you aren’t already. I also encourage you to read
    through Rust RFC 1105 ([https://rust-lang.github.io/rfcs/1105-api-evolution.html](https://rust-lang.github.io/rfcs/1105-api-evolution.html))
    and the chapter of *The Cargo Book* on SemVer compatibility ([https://doc.rust-lang.org/cargo/reference/semver.html](https://doc.rust-lang.org/cargo/reference/semver.html)),
    which cover what is and is not a breaking change in Rust.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 强烈推荐在阅读完本章之后查看 Rust API 指南（[https://rust-lang.github.io/api-guidelines/](https://rust-lang.github.io/api-guidelines/)）。这里有一个非常好的检查清单，详细解释了每项推荐。许多本章中的建议也会通过
    `cargo clippy` 工具进行检查，如果你还没有使用该工具，应该尽早在代码中运行它。我还鼓励你阅读 Rust RFC 1105（[https://rust-lang.github.io/rfcs/1105-api-evolution.html](https://rust-lang.github.io/rfcs/1105-api-evolution.html)）以及《Cargo
    手册》中关于 SemVer 兼容性的章节（[https://doc.rust-lang.org/cargo/reference/semver.html](https://doc.rust-lang.org/cargo/reference/semver.html)），它们涵盖了在
    Rust 中什么是 breaking change，什么不是。
- en: Unsurprising
  id: totrans-6
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 不足为奇
- en: The Principle of Least Surprise, otherwise known as the Law of Least Astonishment,
    comes up a lot in software engineering, and it holds true for Rust interfaces
    as well. Where possible, your interfaces should be intuitive enough that if the
    user has to guess, they usually guess correctly. Of course, not everything about
    your application is going to be immediately intuitive in this way, but anything
    that *can* be unsurprising should be. The core idea here is to stick close to
    things the user is likely to already know so that they don’t have to relearn concepts
    in a different way than they’re used to. That way you can save their brain power
    for figuring out the things that are actually specific to your interface.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: '**最小惊讶原则**（The Principle of Least Surprise），也称为**最小惊讶法则**（Law of Least Astonishment），在软件工程中经常出现，这一原则同样适用于
    Rust 接口。尽可能地，接口应该足够直观，用户如果不得不猜测，通常能够猜对。当然，应用程序的所有内容并不总是能够以这种方式直观易懂，但任何*可以*做到不令人惊讶的部分，都应该做到不令人惊讶。这里的核心思想是，尽量贴近用户可能已经知道的事物，这样他们就不需要以不同于他们习惯的方式重新学习概念。这样，你就可以节省他们的脑力，让他们专注于理解那些实际上是特定于你接口的内容。'
- en: There are a variety of ways you can make your interfaces predictable. Here,
    we’ll look at how you can use naming, common traits, and ergonomic trait tricks
    to help the user out.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过多种方式使接口具有可预测性。在这里，我们将探讨如何利用命名、共性特征以及人体工程学特征技巧来帮助用户。
- en: Naming Practices
  id: totrans-9
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 命名规范
- en: A user of your interface will encounter it first through its names; they will
    immediately start to infer things from the names of types, methods, variables,
    fields, and libraries they come across. If your interface reuses names for things—say,
    methods and types—from other (perhaps common) interfaces, the user will know they
    can make certain assumptions about your methods and types. A method called `iter`
    probably takes `&self`, and probably gives you an iterator. A method called `into_inner`
    probably takes `self` and likely returns some kind of wrapped type. A type called
    `SomethingError` probably implements `std::error::Error` and appears in various
    `Result`s. By reusing common names for the same purpose, you make it easier for
    the user to guess what things do and allow them to more easily understand the
    things that are different about your interface.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 用户首先会通过接口的名称接触到它；他们会立即从遇到的类型、方法、变量、字段和库的名称中推断出一些信息。如果你的接口重用了其他（可能是常见的）接口中的名称——比如方法和类型——用户会知道他们可以对你的方法和类型做出某些假设。一个叫做`iter`的方法可能接受`&self`，并且很可能会给你一个迭代器。一个叫做`into_inner`的方法可能接受`self`，并很可能返回某种包装类型。一个叫做`SomethingError`的类型可能实现了`std::error::Error`并出现在各种`Result`中。通过为相同目的重用常见名称，你可以让用户更容易猜测某些事物的作用，并帮助他们更容易理解你的接口中与众不同的部分。
- en: A corollary to this is that things that share a name *should* in fact work the
    same way. Otherwise—for example, if your `iter` method takes `self`, or if your
    `SomethingError` type does not implement `Error`—the user will likely write incorrect
    code based on how they expect the interface to work. They will be surprised and
    frustrated and will have to spend time digging into how your interface differs
    from their expectations. When we can save the user this kind of friction, we should.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 由此产生的一个推论是，具有相同名称的事物*应该*以相同的方式工作。否则——例如，如果你的`iter`方法接受`self`，或者你的`SomethingError`类型没有实现`Error`——用户可能会根据他们对接口的预期编写错误的代码。他们会感到惊讶和沮丧，并且不得不花时间去弄清楚你的接口与他们的预期有什么不同。当我们能够为用户减少这种摩擦时，我们应该尽量做到。
- en: Common Traits for Types
  id: totrans-12
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 类型的常见特征
- en: Users in Rust will also make the major assumption that everything in the interface
    “just works.” They expect to be able to print any type with `{:?}` and send anything
    and everything to another thread, and they expect that every type is `Clone`.
    Where possible, we should again avoid surprising the user and eagerly implement
    most of the standard traits even if we do not need them immediately.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: Rust 用户通常会做出一个重要的假设，即接口中的所有东西“都能正常工作”。他们期望能够使用`{:?}`打印任何类型，并将任何东西发送到另一个线程，而且他们还期望每个类型都实现了`Clone`。在可能的情况下，我们应避免给用户带来意外，并且积极实现大多数标准特征，即使我们暂时不需要它们。
- en: Because of the coherence rules discussed in Chapter 2, the compiler will not
    allow users to implement these traits when they need them. Users aren’t allowed
    to implement a foreign trait (like `Clone`) for a foreign type like one from your
    interface. They would instead need to wrap your interface type in their own type,
    and even then it may be quite difficult to write a reasonable implementation without
    access to the type’s internals.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 由于第2章讨论的连贯性规则，编译器将不允许用户在需要这些特征时自行实现它们。用户不能为外部类型（如来自你接口的类型）实现外部特征（例如`Clone`）。他们需要将你的接口类型包装在自己的类型中，即使如此，没有访问类型内部信息的权限，编写一个合理的实现也可能非常困难。
- en: First among these standard traits is the `Debug` trait. Nearly every type can,
    and should, implement `Debug`, even if it only prints the type’s name. Using `#[derive(Debug)]`
    is often the best way to implement the `Debug` trait in your interface, but keep
    in mind that all derived traits automatically add the same bound for any generic
    parameters. You could also simply write your own implementation by leveraging
    the various `debug_` helpers on `fmt::Formatter`.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 这些标准特征中的首个是`Debug`特征。几乎每种类型都可以且应该实现`Debug`，即使它仅仅是打印类型的名称。使用`#[derive(Debug)]`通常是实现接口中`Debug`特征的最佳方式，但请记住，所有派生特征会自动为任何泛型参数添加相同的限制。你也可以通过利用`fmt::Formatter`上的各种`debug_`辅助方法来编写自己的实现。
- en: Tied in close second are the Rust auto-traits `Send` and `Sync` (and, to a lesser
    extent, `Unpin`). If a type does not implement one of these traits, it should
    be for a very good reason. A type that is not `Send` can’t be placed in a `Mutex`
    and can’t be used even transitively in an application that contains a thread pool.
    A type that is not `Sync` can’t be shared through an `Arc` or placed in a static
    variable. Users have come to expect that types *just work* in these contexts,
    especially in the asynchronous world where nearly everything runs on a thread
    pool, and will become frustrated if you don’t ensure that your types implement
    these traits. If your types cannot implement them, make sure that fact, and the
    reason why, is well documented!
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 紧随其后的是 Rust 自动特性 `Send` 和 `Sync`（以及，较少程度上，`Unpin`）。如果一个类型没有实现其中一个特性，那么它应该有充分的理由。一个非
    `Send` 的类型不能放入 `Mutex`，即使在包含线程池的应用中，也不能被传递使用。一个非 `Sync` 的类型不能通过 `Arc` 共享，也不能放入静态变量。用户已经习惯于这些类型在这些上下文中*正常工作*，特别是在异步环境中，几乎所有东西都运行在线程池上。如果你没有确保你的类型实现了这些特性，用户会感到沮丧。如果你的类型无法实现这些特性，确保在文档中清楚地说明这一事实及其原因！
- en: The next set of nearly universal traits you should implement is `Clone` and
    `Default`. These traits can be derived or implemented easily and make sense to
    implement for most types. If your type cannot implement these traits, make sure
    to call it out in your documentation, as users will usually expect to be able
    to easily create more (and new) instances of types as they see fit. If they cannot,
    they will be surprised.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来是你应该实现的几乎普遍适用的特性：`Clone` 和 `Default`。这些特性可以很容易地派生或实现，对于大多数类型来说实现它们是有意义的。如果你的类型不能实现这些特性，确保在文档中指出，因为用户通常会期望能够轻松创建更多（以及新的）类型实例。如果不能做到这一点，他们会感到惊讶。
- en: 'One step further down in the hierarchy of expected traits is the comparison
    traits: `PartialEq`, `PartialOrd`, `Hash`, `Eq`, and `Ord`. The `PartialEq` trait
    is particularly desirable, because users will at some point inevitably have two
    instances of your type that they wish to compare with `==` or `assert_eq!`. Even
    if your type would compare equal for only the same instance of the type, it’s
    worth implementing `PartialEq` to enable your users to use `assert_eq!`.'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 在预期特性的层级中，接下来是比较特性：`PartialEq`、`PartialOrd`、`Hash`、`Eq` 和 `Ord`。`PartialEq`
    特性尤其受欢迎，因为用户最终会遇到两个你类型的实例，他们希望用 `==` 或 `assert_eq!` 来比较它们。即使你的类型仅在同一个实例之间才会比较相等，还是值得实现
    `PartialEq`，以便让用户能够使用 `assert_eq!`。
- en: '`PartialOrd` and `Hash` are more specialized, and may not apply quite as broadly,
    but where possible you will want to implement them too. This is especially true
    for types a user might use as the key in a map, or a type they may deduplicate
    using any of the `std::collection` set types, since they tend to require these
    bounds. `Eq` and `Ord` come with additional semantic requirements on the implementing
    type’s comparison operations beyond those of `PartialEq` and `PartialOrd`. These
    are well documented in the documentation for those traits, and you should implement
    them *only* if you’re sure those semantics actually apply to your type.'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: '`PartialOrd` 和 `Hash` 是更为专业化的特性，可能并不适用于所有情况，但在可能的情况下，你也需要实现它们。尤其是对于用户可能用作映射中的键，或是可能通过任何
    `std::collection` 集合类型进行去重的类型，因为这些类型通常需要这些边界。`Eq` 和 `Ord` 在实现类型的比较操作时，除了 `PartialEq`
    和 `PartialOrd` 的要求之外，还带有额外的语义要求。这些要求在这些特性的文档中有详细说明，只有在你确定这些语义适用于你的类型时，才应实现它们，*仅限于此*。'
- en: Finally, for most types, it makes sense to implement the `serde` crate’s `Serialize`
    and `Deserialize` traits. These can be easily derived, and the `serde_derive`
    crate even comes with mechanisms for overwriting the serialization for just one
    field or enum variant. Since `serde` is a third-party crate, you may not wish
    to add a required dependency on it. Most libraries therefore choose to provide
    a `serde` feature that adds support for `serde` only when the user opts into it.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，对于大多数类型，实现 `serde` crate 的 `Serialize` 和 `Deserialize` 特性是有意义的。这些特性可以轻松派生，`serde_derive`
    crate 甚至提供了仅重写某个字段或枚举变体的序列化机制。由于 `serde` 是一个第三方 crate，你可能不希望将其作为必需的依赖项。因此，大多数库选择提供一个
    `serde` 特性，仅在用户选择时才添加对 `serde` 的支持。
- en: 'You might be wondering why I haven’t included the derivable trait `Copy` in
    this section. There are two things that set `Copy` apart from the other traits
    mentioned. The first is that users do not generally expect types to be `Copy`;
    quite to the contrary, they tend to expect that if they want two copies of something,
    they have to call `clone`. `Copy` changes the semantics of moving a value of the
    given type, which might surprise the user. This ties in to the second observation:
    it is very easy for a type to *stop* being `Copy`, because `Copy` types are highly
    restricted. A type that starts out simple can easily end up having to hold a `String`,
    or some other non-`Copy` type. Should that happen, and you have to remove the
    `Copy` implementation, that’s a backward incompatible change. In contrast, you
    rarely have to remove a `Clone` implementation, so that’s a less onerous commitment.'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会好奇为什么我没有在这一节中包括可派生特征`Copy`。`Copy`与前面提到的其他特征有两点不同。首先，用户通常不期望类型是`Copy`；相反，他们往往期望如果需要两个副本的话，必须调用`clone`。`Copy`改变了移动给定类型的值的语义，这可能会让用户感到惊讶。第二个观察点是：类型变得不再是`Copy`非常容易，因为`Copy`类型的限制非常严格。一个开始时很简单的类型，最终可能需要持有`String`或其他非`Copy`类型。如果发生这种情况，而你需要移除`Copy`实现，那将是一个不兼容的改变。相比之下，通常你不需要移除`Clone`实现，因此这是一种较为轻松的承诺。
- en: Ergonomic Trait Implementations
  id: totrans-22
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 人体工学特征实现
- en: 'Rust does not automatically implement traits for references to types that implement
    traits. To phrase this a different way, you cannot generally call `fn foo<T: Trait>(t:
    T)` with a `&Bar`, even if `Bar: Trait`. This is because `Trait` may contain methods
    that take `&mut self` or `self`, which obviously cannot be called on `&Bar`. Nonetheless,
    this behavior might be very surprising to a user who sees that `Trait` has only
    `&self` methods!'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 'Rust 并不会自动为引用类型实现特征。换句话说，你通常不能使用`fn foo<T: Trait>(t: T)`来传入`&Bar`，即使`Bar: Trait`。这是因为`Trait`可能包含一些接受`&mut
    self`或`self`的方法，而显然这些方法不能在`&Bar`上调用。然而，这种行为对于看到`Trait`只有`&self`方法的用户来说可能会非常令人惊讶！'
- en: 'For this reason, when you define a new trait, you’ll usually want to provide
    blanket implementations as appropriate for that trait for `&T where T: Trait`,
    `&mut T where T: Trait`, and `Box<T> where T: Trait`. You may be able to implement
    only some of these depending on what receivers the methods of `Trait` have. Many
    of the traits in the standard library have similar implementations, precisely
    because that leads to fewer surprises for the user.'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: '正因如此，当你定义一个新的特征时，通常希望为`&T where T: Trait`、`&mut T where T: Trait`以及`Box<T>
    where T: Trait`提供适当的通用实现。根据`Trait`方法的接收者，你可能只能实现其中的一些。标准库中的许多特征都有类似的实现，正是因为这可以减少用户的意外。'
- en: Iterators are another case where you’ll often want to specifically add trait
    implementations on references to a type. For any type that can be iterated over,
    consider implementing `IntoIterator` for both `&MyType` and `&mut MyType` where
    applicable. This makes `for` loops work with borrowed instances of your type as
    well out of the box, just like users would expect.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 迭代器是另一个常见的情况，你通常会想要专门为类型的引用添加特征实现。对于任何可以被迭代的类型，考虑为`&MyType`和`&mut MyType`分别实现`IntoIterator`（如果适用）。这使得`for`循环能够像用户期望的那样，在你的类型的借用实例上直接工作。
- en: Wrapper Types
  id: totrans-26
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 包装类型
- en: 'Rust does not have object inheritance in the classical sense. However, the
    `Deref` trait and its cousin `AsRef` both provide something a little like inheritance.
    These traits allow you to have a value of type `T` and call methods on some type
    `U` by calling them directly on the `T`-typed value if `T: Deref<Target = U>`.
    This feels like magic to the user, and is generally great.'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 'Rust 并没有像传统意义上的对象继承。然而，`Deref`特征及其“亲戚”`AsRef`提供了一些类似继承的功能。这些特征允许你拥有一个类型为`T`的值，并通过直接调用`T`类型的值来调用类型`U`的方法，只要`T:
    Deref<Target = U>`。这对用户来说像是魔法，通常效果很好。'
- en: If you provide a relatively transparent wrapper type (like `Arc`), there’s a
    good chance you’ll want to implement `Deref` so that users can call methods on
    the inner type by just using the `.` operator. If accessing the inner type does
    not require any complex or potentially slow logic, you should also consider implementing
    `AsRef`, which allows users to easily use a `&WrapperType` as an `&InnerType`.
    For most wrapper types, you will also want to implement `From<InnerType>` and
    `Into<InnerType>` where possible so that your users can easily add or remove your
    wrapping.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你提供一个相对透明的包装类型（如 `Arc`），你很可能希望实现 `Deref`，以便用户可以仅使用 `.` 运算符调用内部类型的方法。如果访问内部类型不需要任何复杂或可能较慢的逻辑，你还应该考虑实现
    `AsRef`，这样用户就可以轻松地将 `&WrapperType` 用作 `&InnerType`。对于大多数包装类型，你还会希望在可能的情况下实现 `From<InnerType>`
    和 `Into<InnerType>`，以便用户可以轻松地添加或移除你的包装。
- en: 'You may also have come across the `Borrow` trait, which feels very similar
    to `Deref` and `AsRef` but is really a bit of a different beast. Specifically,
    `Borrow` is tailored for a much narrower use case: allowing the caller to supply
    any one of multiple essentially identical variants of the same type. It could,
    perhaps, have been called `Equivalent` instead. For example, for a `HashSet<String>`,
    `Borrow` allows the caller to supply either a `&str` *or* a `&String`. While the
    same could have been achieved with `AsRef`, that would not be safe without `Borrow`’s
    additional requirement that the target type implements `Hash`, `Eq`, and `Ord`
    exactly the same as the implementing type. `Borrow` also has a blanket implementation
    of `Borrow<T>` for `T`, `&T`, and `&mut T`, which makes it convenient to use in
    trait bounds to accept either owned *or* referenced values of a given type. In
    general, `Borrow` is intended only for when your type is essentially equivalent
    to another type, whereas `Deref` and `AsRef` are intended to be implemented more
    widely for anything your type can “act as.”'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能也遇到过 `Borrow` 特征，它看起来与 `Deref` 和 `AsRef` 非常相似，但实际上它是有些不同的。具体来说，`Borrow` 是为一个更窄的用例量身定制的：允许调用者提供多个基本相同的类型变体中的任何一个。它或许本可以被称为
    `Equivalent`。例如，对于一个 `HashSet<String>`，`Borrow` 允许调用者提供一个 `&str` *或* `&String`。虽然同样可以通过
    `AsRef` 实现这一点，但没有 `Borrow` 的额外要求（目标类型必须实现与实现类型完全相同的 `Hash`、`Eq` 和 `Ord`），这将是不安全的。`Borrow`
    还对 `T`、`&T` 和 `&mut T` 实现了 `Borrow<T>` 的广泛实现，这使得它在特征边界中非常方便，可以接受给定类型的所有权 *或* 引用值。一般来说，`Borrow`
    仅用于当你的类型与另一种类型本质上等价时，而 `Deref` 和 `AsRef` 更广泛地用于实现任何你的类型可以“充当”的内容。
- en: Flexible
  id: totrans-30
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 灵活
- en: Every piece of code you write includes, implicitly or explicitly, a contract.
    The contract consists of a set of requirements and a set of promises. The requirements
    are restrictions on how the code can be used, while the promises are guarantees
    about how the code can be used. When designing a new interface, you want to think
    carefully about this contract. A good rule of thumb is to avoid imposing unnecessary
    restrictions and to only make promises you can keep. Adding restrictions or removing
    promises usually requires a major semantic version change and is likely to break
    code elsewhere. Relaxing restrictions or giving additional promises, on the other
    hand, is usually backward compatible.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 你编写的每一行代码，隐式或显式地都包含一个合同。这个合同由一组要求和一组承诺组成。要求是对代码如何使用的限制，而承诺是关于代码如何使用的保证。在设计新接口时，你需要仔细考虑这个合同。一个好的经验法则是避免施加不必要的限制，并且只做出你能够兑现的承诺。增加限制或去除承诺通常需要进行重大语义版本的更改，并且可能会破坏其他地方的代码。另一方面，放宽限制或增加承诺通常是向后兼容的。
- en: In Rust, restrictions usually come in the form of trait bounds and argument
    types, and promises come in the form of trait implementations and return types.
    For example, compare the three function signatures in [Listing 3-1](#listing3-1).
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Rust 中，限制通常表现为特征边界和参数类型，而承诺则表现为特征实现和返回类型。例如，比较 [Listing 3-1](#listing3-1)
    中的三个函数签名。
- en: '[PRE0]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Listing 3-1: Similar function signatures with different contracts'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 'Listing 3-1: 相似的函数签名，具有不同的合同'
- en: These three function signatures all take a string and return a string, but they
    do so under very different contracts.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 这三个函数签名都接受一个字符串并返回一个字符串，但它们的合同却大不相同。
- en: The first function requires the caller to own the string in the form of the
    `String` type, and it promises that it will return an owned `String`. Since the
    contract requires the caller to allocate and requires us to return an owned `String`,
    we cannot later make this function allocation-free in a backward compatible way.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个函数要求调用者拥有一个`String`类型的字符串，并且承诺返回一个拥有所有权的`String`。由于契约要求调用者分配内存，并要求我们返回一个拥有所有权的`String`，因此我们不能在不破坏向后兼容性的情况下使这个函数不再需要分配内存。
- en: 'The second function relaxes the contract: the caller can provide any reference
    to a string, so the user no longer needs to allocate or give up ownership of a
    `String`. It also promises to give back a `std::borrow::Cow`, meaning it can return
    either a string reference or an owned `String`, depending on whether it needs
    to own the string. The promise here is that the function will always return a
    `Cow`, which means that we cannot, say, change it to use some other optimized
    string representation later. The caller must also specifically provide a `&str`,
    so if they have, say, a pre-existing `String` of their own, they must dereference
    it to a `&str` to call our function.'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个函数放宽了契约：调用者可以提供任何字符串引用，因此用户不再需要分配内存或放弃`String`的所有权。它还承诺返回一个`std::borrow::Cow`，意味着它可以根据是否需要拥有字符串的所有权，返回字符串引用或拥有所有权的`String`。这里的承诺是函数将始终返回一个`Cow`，这意味着我们不能后来将其改为使用其他优化的字符串表示。调用者还必须特别提供一个`&str`，因此如果他们有一个现成的`String`，必须将其解引用为`&str`才能调用我们的函数。
- en: The third function lifts these restrictions. It requires only that the user
    pass in a type that can produce a reference to a string, and it promises only
    that the return value can produce a reference to a string.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 第三个函数解除这些限制。它仅要求用户传入一个能够生成字符串引用的类型，并且只承诺返回值能够生成字符串引用。
- en: None of these function signatures is *better* than the others. If you need ownership
    of a string in the function, you can use the first argument type to avoid an extra
    string copy. If you want to allow the caller to take advantage of the case where
    an owned string was allocated and returned, the second function with a return
    type of `Cow` may be a good choice. Instead, what I want you to take away from
    this is that you should think carefully about what contract your interface binds
    you to, because changing it after the fact can be disruptive.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 这些函数签名中没有一个比其他的*更好*。如果你需要在函数中拥有一个字符串的所有权，你可以使用第一个参数类型来避免额外的字符串复制。如果你希望允许调用者利用已经分配并返回的拥有所有权的字符串的情况，那么第二个返回类型为`Cow`的函数可能是一个不错的选择。相反，我希望你从中得到的是，你应该仔细考虑接口所绑定的契约，因为事后修改它可能会带来破坏性影响。
- en: In the remainder of this section I give examples of interface design decisions
    that often come up, and their implications for your interface contract.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节的其余部分，我将给出一些接口设计决策的例子，这些决策经常出现，并且它们对你的接口契约的影响。
- en: Generic Arguments
  id: totrans-41
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 泛型参数
- en: One obvious requirement your interface must place on users is what types they
    must provide to your code. If your function explicitly takes a `Foo`, the user
    must own and give you a `Foo`. There is no way around it. In most cases it pays
    off to use generics rather than concrete types, to allow the caller to pass any
    type that conforms to what your function actually needs, rather than only a particular
    type. Changing `&str` in [Listing 3-1](#listing3-1) to `impl AsRef<str>` is an
    example of this kind of relaxing. One way to go about relaxing requirements this
    way is to start with the argument fully generic with no bounds, and then just
    follow the compiler errors to discover what bounds you need to add.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 你的接口必须对用户施加的一个明显要求是，他们必须为你的代码提供什么类型。如果你的函数明确地接受一个`Foo`类型，用户必须拥有并提供一个`Foo`。这是无法绕过的。在大多数情况下，使用泛型而不是具体类型是值得的，这样可以允许调用者传递任何符合你函数实际需求的类型，而不仅仅是某个特定类型。将[示例3-1](#listing3-1)中的`&str`改为`impl
    AsRef<str>`就是这种宽松的一个例子。通过这种方式放宽要求的一种方法是，从完全泛型且没有边界的参数开始，然后通过编译器的错误信息来发现你需要添加哪些边界。
- en: However, if taken to the extreme, this approach would make every argument to
    every function its own generic type, which would be both hard to read and hard
    to understand. There are no hard-and-fast rules for exactly when you should or
    should not make a given parameter generic, so use your best judgment. A good rule
    of thumb is to make an argument generic if you can think of other types a user
    might reasonably and frequently want to use instead of the concrete type you started
    with.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果把这种方法推到极限，它会让每个函数的每个参数都成为它自己的泛型类型，这将既难以阅读也难以理解。并没有硬性规则说明什么时候应该或者不应该将某个参数设为泛型，所以要凭借你的最佳判断来决定。一个好的经验法则是，如果你能想到其他类型，用户合理且频繁地想要使用而不是你最初使用的具体类型，那么就可以将该参数设为泛型。
- en: You may remember from Chapter 2 that generic code is duplicated for every combination
    of types ever used with the generic code through monomorphization. With that in
    mind, the idea of making lots of arguments generic might make you worried about
    overly enlarging your binaries. In Chapter 2 we also discussed how you can use
    dynamic dispatch to mitigate this at a (usually) negligible performance cost,
    and that applies here too. For arguments that you take by reference anyway (recall
    that `dyn Trait` is not `Sized`, and that you need a wide pointer to use them),
    you can easily replace your generic argument with one that uses dynamic dispatch.
    For instance, instead of `impl AsRef<str>`, you could take `&dyn AsRef<str>`.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能还记得在第二章中提到过，泛型代码会通过单态化（monomorphization）为每个与泛型代码一起使用的类型组合生成一份副本。考虑到这一点，过度泛化大量参数的想法可能会让你担心会使二进制文件过于庞大。在第二章中，我们还讨论了如何通过动态调度（dynamic
    dispatch）来缓解这一问题，并且通常不会对性能造成明显影响，这一点在这里同样适用。对于那些你反正会通过引用传递的参数（回想一下，`dyn Trait`不是`Sized`，你需要一个宽指针才能使用它们），你可以轻松地将泛型参数替换为使用动态调度的参数。例如，代替`impl
    AsRef<str>`，你可以使用`&dyn AsRef<str>`。
- en: 'Before you go running to do that, though, there are a few things you should
    consider. First, you are making this choice on behalf of your users, who cannot
    opt out of dynamic dispatch. If you know that the code you’re applying dynamic
    dispatch to will never be performance-sensitive, that may be fine. But if a user
    comes along who wants to use your library in their high-performance application,
    dynamic dispatch in a function that is called in a hot loop may be a deal breaker.
    Second, at the time of writing, using dynamic dispatch will work only when you
    have a simple trait bound like `T: AsRef<str>` or `impl AsRef<str>`. For more
    complex bounds, Rust does not know how to construct a dynamic dispatch vtable,
    so you cannot take, say, `&dyn Hash + Eq`. And finally, remember that with generics,
    the caller can always choose dynamic dispatch themselves by passing in a trait
    object. The reverse is not true: if you take a trait object, that is what the
    caller must provide.'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: '不过，在你开始这么做之前，还是有几个问题需要考虑。首先，你是代表你的用户做这个选择的，用户无法选择不使用动态调度。如果你知道你正在应用动态调度的代码永远不会对性能产生敏感影响，那么这样做可能没问题。但如果有用户想在他们的高性能应用中使用你的库，在一个热循环中调用的函数中使用动态调度可能会成为一个障碍。其次，在撰写本文时，使用动态调度仅在你拥有像`T:
    AsRef<str>`或`impl AsRef<str>`这样简单的特征约束时才有效。对于更复杂的约束，Rust无法构建动态调度的vtable，因此你不能使用像`&dyn
    Hash + Eq`这样的类型。最后，请记住，对于泛型，调用者始终可以通过传递特征对象来选择动态调度。而反过来则不成立：如果你接收一个特征对象，那么调用者必须提供它。'
- en: 'It may be tempting to start your interfaces off with concrete types and then
    turn them generic over time. This can work, but keep in mind that such changes
    are not necessarily backward compatible. To see why, imagine that you change a
    function from `fn foo(v: &Vec<usize>)` to `fn foo(v: impl AsRef<[usize]>)`. While
    every `&Vec<usize>` implements `AsRef<[usize]>`, type inference can still cause
    issues for users. Consider what happens if the caller invokes `foo` with `foo(&iter.collect())`.
    In the original version, the compiler could determine that it should collect into
    a `Vec`, but now it just knows that it needs to collect into some type that implements
    `AsRef<[usize]>`. And there could be multiple such types, so with this change,
    the caller’s code will no longer compile!'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: '你可能会觉得很有诱惑力，从具体类型开始你的接口，然后随着时间的推移将它们变为泛型。这是可行的，但请记住，这样的变化不一定是向后兼容的。为了说明为什么，假设你将一个函数从`fn
    foo(v: &Vec<usize>)`改为`fn foo(v: impl AsRef<[usize]>)`。虽然每个`&Vec<usize>`都实现了`AsRef<[usize]>`，但类型推断仍然可能给用户带来问题。想象一下，如果调用者以`foo(&iter.collect())`的方式调用`foo`，会发生什么情况。在原始版本中，编译器能够确定它应该将数据收集到`Vec`中，但现在它只知道需要将数据收集到实现了`AsRef<[usize]>`的某个类型中。而且可能有多个这样的类型，因此经过此更改后，调用者的代码将无法编译！'
- en: Object Safety
  id: totrans-47
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 对象安全
- en: 'When you define a new trait, whether or not that trait is object-safe (see
    the end of “Compilation and Dispatch” in Chapter 2) is an unwritten part of the
    trait’s contract. If the trait is object-safe, users can treat different types
    that implement your trait as a single common type using `dyn Trait`. If it isn’t,
    the compiler will disallow `dyn Trait` for that trait. You should prefer your
    traits to be object-safe even if that comes at a slight cost to the ergonomics
    of using them (such as taking `impl AsRef<str>` over `&str`), since object safety
    enables new ways to use your traits. If your trait must have a generic method,
    consider whether its generic parameters can be on the trait itself or if its generic
    arguments can also use dynamic dispatch to preserve the object safety of the trait.
    Alternatively, you can add a `where Self: Sized` trait bound to that method, which
    makes it possible to call the method only with a concrete instance of the trait
    (and not through `dyn Trait`). You can see examples of this pattern in the `Iterator`
    and `Read` traits, which are object-safe but provide some additional convenience
    methods on concrete instances.'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: '当你定义一个新特性时，该特性是否具备对象安全性（请参见第二章“编译与分发”部分的结尾）是特性的契约中一个未明确写明的部分。如果特性是对象安全的，用户可以将实现该特性的不同类型当作一个通用类型来使用`dyn
    Trait`。如果不是，编译器将不允许为该特性使用`dyn Trait`。即使这样做会稍微影响使用它们的可用性（比如，采用`impl AsRef<str>`而不是`&str`），你也应该倾向于使你的特性具备对象安全性，因为对象安全性能为你的特性提供新的使用方式。如果你的特性必须有一个泛型方法，考虑它的泛型参数是否可以位于特性本身，或者它的泛型参数是否也可以使用动态分发来保持特性的对象安全性。或者，你可以为该方法添加`where
    Self: Sized`的特性约束，这样就可以仅使用特性实例（而不是通过`dyn Trait`）调用该方法。你可以在`Iterator`和`Read`特性中看到这种模式的例子，这些特性是对象安全的，但在具体实例上提供了一些额外的便利方法。'
- en: There is no single answer to the question of how many sacrifices you should
    be willing to make to preserve object safety. My recommendation is that you consider
    how your trait will be used, and whether it makes sense for users to want to use
    it as a trait object. If you think it’s likely that users will want to use many
    different instances of your trait together, you should work harder to provide
    object safety than if you don’t think that use case makes much sense. For example,
    dynamic dispatch would not be useful for the `FromIterator` trait because its
    one method does not take `self`, so you wouldn’t be able to construct a trait
    object in the first place. Similarly, `std::io::Seek` is fairly useless as a trait
    object on its own, because the only thing you would be able to do with such a
    trait object is seek, without being able to read or write.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 对于“你应该愿意为保持对象安全做出多少牺牲”这个问题，并没有唯一的答案。我的建议是，你应该考虑你的特性将如何被使用，用户是否有必要将其用作特性对象。如果你认为用户可能会希望将你的特性与许多不同的实例一起使用，那么你应该更加努力地提供对象安全，而不是认为这种用例没有什么意义。例如，动态分发对于`FromIterator`特性没有用处，因为它的唯一方法不接受`self`，因此你根本无法构造一个特性对象。类似地，`std::io::Seek`作为一个特性对象本身几乎没有用，因为你只能在特性对象上进行寻址，而无法进行读写操作。
- en: Remember that object safety is a part of your public interface! If you modify
    a trait in an otherwise backward compatible way, such as by adding a method with
    a default implementation, but it makes the trait not object-safe, you need to
    bump your major semantic version number.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，对象安全是你公共接口的一部分！如果你以向后兼容的方式修改了特性，比如添加一个具有默认实现的方法，但却导致特性不再具备对象安全性，那么你需要增加你的主语义版本号。
- en: Borrowed vs. Owned
  id: totrans-51
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 借用与拥有
- en: For nearly every function, trait, and type you define in Rust, you must decide
    whether it should own, or just hold a reference to, its data. Whatever decision
    you make will have far-reaching implications for the ergonomics and performance
    of your interface. Luckily, these decisions very often make themselves.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 对于你在 Rust 中定义的几乎每个函数、特性和类型，你都必须决定它是应该拥有其数据，还是仅仅持有其数据的引用。无论你做出什么决定，都将对你的接口的可用性和性能产生深远的影响。幸运的是，这些决策通常会自己显现出来。
- en: If the code you write needs ownership of the data, such as to call methods that
    take `self` or to move the data to another thread, it must store the owned data.
    When your code must own data, it should generally also make the caller provide
    owned data, rather than taking values by reference and cloning them. This leaves
    the caller in control of allocation, and it is upfront about the cost of using
    the interface in question.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你编写的代码需要拥有数据，例如调用需要`self`的方式或将数据移动到另一个线程，它必须存储拥有的数据。当你的代码必须拥有数据时，通常也应该要求调用者提供拥有的数据，而不是通过引用获取值并克隆它们。这让调用者控制分配过程，并且明确了使用该接口的成本。
- en: On the other hand, if your code doesn’t need to own the data, it should operate
    on references instead. One common exception to this rule is with small types like
    `i32`, `bool`, or `f64`, which are just as cheap to store and copy directly as
    to store through references. Be wary of assuming this holds true for all `Copy`
    types, though; `[u8; 8192]` is `Copy`, but it would be expensive to store and
    copy it all over the place.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，如果你的代码不需要拥有数据，它应该改为操作引用。一个常见的例外是像`i32`、`bool`或`f64`这样的简单类型，它们直接存储和复制的成本与通过引用存储的成本相当。然而，要小心假设这一规则适用于所有`Copy`类型；`[u8;
    8192]`是`Copy`类型，但将它到处存储和复制会非常昂贵。
- en: Sometimes, you don’t know if your code must own data or not, as it is runtime
    dependent. For this, the `Cow` type is your friend. It lets you represent data
    that *may* be owned by holding either a reference or an owned value. If asked
    to produce an owned value when it only has a reference, a `Cow` uses the `ToOwned`
    trait to make one behind the scenes, usually by cloning. `Cow` is typically used
    in return types to represent functions that sometimes allocate. For example, `String::from_utf8_lossy`
    allocates only if the input contains invalid UTF-8\. `Cow` can also be used in
    arguments for functions that can sometimes make use of owned inputs, but that’s
    rarer in practice.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，你并不知道代码是否需要拥有数据，因为这取决于运行时。在这种情况下，`Cow`类型是你的朋友。它允许你通过持有引用或拥有的值来表示可能拥有的数据。如果要求在只有引用时生成一个拥有的值，`Cow`会使用`ToOwned`特性在幕后创建一个，通常是通过克隆。`Cow`通常用于返回类型，表示某些函数可能会分配内存。例如，`String::from_utf8_lossy`只有在输入包含无效UTF-8时才会分配内存。`Cow`也可以用于函数的参数，这些函数有时会使用拥有的输入，但在实践中这种情况较少见。
- en: Other times, reference lifetimes complicate the interface so much that it becomes
    a pain to use. If your users are struggling to get code to compile on top of your
    interface, that’s a sign that you may want to (even unnecessarily) take ownership
    of certain pieces of data. If you do this, start with data that is cheap to clone
    or is not part of anything performance-sensitive before you decide to heap-allocate
    what might be a huge chunk of bytes.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，引用生命周期会使接口变得复杂到让它使用起来很麻烦。如果你的用户在使用你的接口时难以让代码编译通过，那通常是一个信号，表明你可能希望（即使不必要）对某些数据拥有所有权。如果你这么做，应该从那些克隆成本较低或不涉及性能敏感的部分数据开始，然后再决定是否为可能是大块字节的数据分配堆内存。
- en: Fallible and Blocking Destructors
  id: totrans-57
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 可失败和阻塞的析构函数
- en: Types centered on I/O often need to perform cleanup when they’re dropped. This
    may include flushing writes to disk, closing files, or gracefully terminating
    connections to remote hosts. The natural place to perform this cleanup is in the
    type’s `Drop` implementation. Unfortunately, once a value is dropped, we no longer
    have a way to communicate errors to the user except by panicking. A similar problem
    arises in asynchronous code, where we wish to finish up when there is work pending.
    By the time `drop` is called, the executor may be shutting down, and we have no
    way to do more work. We could try to start another executor, but that comes with
    its own host of problems, such as blocking in asynchronous code, as we will see
    in Chapter 8.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 以 I/O 为中心的类型通常在被丢弃时需要执行清理操作。这可能包括将数据刷新到磁盘、关闭文件或优雅地终止与远程主机的连接。执行这些清理操作的自然位置是在该类型的`Drop`实现中。不幸的是，一旦值被丢弃，我们就没有办法通过其他方式向用户报告错误，除了触发恐慌（panic）。在异步代码中也会出现类似的问题，我们希望在有待完成的工作时完成任务。等到`drop`被调用时，执行器可能已经在关闭中，我们也无法再执行更多的工作。我们可以尝试启动另一个执行器，但这会带来一系列问题，例如在异步代码中阻塞，正如我们在第8章中将看到的那样。
- en: There is no perfect solution to these problems, and no matter what we do, some
    applications will inevitably fall back to our `Drop` implementation. For that
    reason, we need to provide best-effort cleanup through `Drop`. If cleanup errors,
    at least we tried—we swallow the error and move on. If an executor is still available,
    we might spawn a future to do cleanup, but if it never gets to run, we did what
    we could.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 这些问题没有完美的解决方案，无论我们做什么，一些应用程序不可避免地会回落到我们的`Drop`实现。因此，我们需要通过`Drop`提供尽力而为的清理工作。如果清理出错，至少我们尝试过——我们会吞下错误并继续。如果执行器仍然可用，我们可能会启动一个未来任务来进行清理，但如果它永远无法执行，我们也尽力了。
- en: However, we ought to provide a better alternative for users who wish to leave
    no loose threads. We can do this by providing an explicit destructor. This usually
    takes the form of a method that takes ownership of `self` and exposes any errors
    (using `-> Result<_, _>`) or asynchrony (using `async fn`) that are inherent to
    the destruction. A careful user can then use that method to gracefully tear down
    any associated resources.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，我们应该为那些希望不留下任何悬而未决问题的用户提供更好的替代方案。我们可以通过提供显式析构函数来做到这一点。这通常表现为一个方法，该方法获取`self`的所有权，并暴露销毁过程中固有的任何错误（使用`->
    Result<_, _>`）或异步操作（使用`async fn`）。谨慎的用户可以使用该方法优雅地拆除任何相关资源。
- en: As always, there’s a trade-off. The moment you add an explicit destructor, you
    will run into two issues. First, since your type implements `Drop`, you can no
    longer move out of any of that type’s fields in the destructor. This is because
    `Drop::drop` will still be called after your explicit destructor runs, and it
    takes `&mut self`, which requires that no part of `self` has been moved. Second,
    `drop` takes `&mut self`, not `self`, so your `Drop` implementation cannot simply
    call your explicit destructor and ignore its result (because it doesn’t own `self`).
    There are a couple of ways around these problems, none of which are perfect.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 和往常一样，这里有一个权衡。一旦你添加了显式析构函数，你将遇到两个问题。首先，由于你的类型实现了`Drop`，你无法在析构函数中从任何该类型的字段中移动出来。这是因为`Drop::drop`会在显式析构函数运行后被调用，它需要`&mut
    self`，这要求`self`的任何部分都不能被移动。其次，`drop`接受的是`&mut self`，而不是`self`，因此你的`Drop`实现不能简单地调用显式析构函数并忽略其结果（因为它不拥有`self`）。有几种方法可以绕过这些问题，但没有一种是完美的。
- en: The first is to make your top-level type a newtype wrapper around an `Option`,
    which in turn holds some inner type that holds all of the type’s fields. You can
    then use `Option::take` in both destructors, and call the inner type’s explicit
    destructor only if the inner type has not already been taken. Since the inner
    type does not implement `Drop`, you can take ownership of all the fields there.
    The downside of this approach is that all the methods you wish to provide on the
    top-level type must now include code to get through the `Option` (which you know
    is always `Some` since `drop` has not yet been called) to the fields on the inner
    type.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个方法是将你的顶层类型做成一个围绕`Option`的新类型包装器，`Option`又包含一个内部类型，该类型包含所有字段。然后，你可以在两个析构函数中使用`Option::take`，并且仅在内部类型尚未被取走时，才调用内部类型的显式析构函数。由于内部类型没有实现`Drop`，你可以获得所有字段的所有权。此方法的缺点是，你希望在顶层类型上提供的所有方法现在必须包含代码，绕过`Option`（你知道它总是`Some`，因为`drop`尚未被调用）以访问内部类型的字段。
- en: The second workaround is to make each of your fields *takeable*. You can “take”
    an `Option` by replacing it with `None` (which is what `Option::take` does), but
    you can do this with many other types as well. For example, you can take a `Vec`
    or `HashMap` by simply replacing them with their cheap-to-construct default values—`std::mem::take`
    is your friend here. This approach works great if your types have sane “empty”
    values but gets tedious if you must wrap nearly every field in an `Option` and
    then modify every access of those fields with a matching `unwrap`.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个解决方法是让每个字段都变得*可取走*。你可以通过将`Option`替换为`None`来“取走”它（这就是`Option::take`的作用），但你也可以对许多其他类型进行类似操作。例如，你可以通过将`Vec`或`HashMap`替换为它们便宜的默认构造值来取走它们——`std::mem::take`在这里非常有用。如果你的类型有合理的“空”值，这种方法非常有效，但如果你必须将几乎每个字段都包装在`Option`中，然后在访问这些字段时用匹配的`unwrap`来修改每个访问，就会变得非常繁琐。
- en: The third option is to hold the data inside the `ManuallyDrop` type, which dereferences
    to the inner type, so there’s no need for unwraps. You can also use `ManuallyDrop::take`
    in `drop` to take ownership at destruction time. The primary downside of this
    approach is that `ManuallyDrop::take` is unsafe. There are no safety mechanisms
    in place to ensure that you don’t try to use the value inside the `ManuallyDrop`
    after you’ve called `take` or that you don’t call `take` multiple times. If you
    do, your program will silently exhibit undefined behavior, and bad things will
    happen.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 第三个选项是将数据保存在`ManuallyDrop`类型中，该类型解引用到内部类型，因此无需进行unwrap。你也可以在`drop`中使用`ManuallyDrop::take`来在销毁时获取所有权。这个方法的主要缺点是`ManuallyDrop::take`是一个不安全的操作。没有任何安全机制来确保你在调用`take`之后不会尝试使用`ManuallyDrop`中的值，或者确保你不会多次调用`take`。如果你这样做了，程序将悄无声息地表现出未定义的行为，且可能会发生严重问题。
- en: Ultimately, you should choose whichever of these approaches fits your application
    best. I would err on the side of going with the second option, and switching to
    the others only if you find yourself in a sea of `Option`s. The `ManuallyDrop`
    solution is excellent if the code is simple enough that you can easily check the
    safety of your code, and you are confident in your ability to do so.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 最终，你应该选择最适合你的应用程序的方式。我倾向于选择第二种方式，只有当你发现自己陷入了大量`Option`的困境时，才切换到其他方式。如果代码足够简单，你可以轻松检查代码的安全性，并且你对自己能够做到这一点有信心，那么`ManuallyDrop`的解决方案是非常好的。
- en: Obvious
  id: totrans-66
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 显而易见
- en: While some users may be familiar with aspects of the implementation that underpins
    your interface, they are unlikely to understand all of its rules and limitations.
    They won’t know that it’s never okay to call `foo` after calling `bar`, or that
    it’s only safe to call the unsafe method `baz` when the moon is at a 47-degree
    angle and no one has sneezed in the past 18 seconds. Only if the interface makes
    it clear that something strange is going on will they reach for the documentation
    or carefully read type signatures. It’s therefore critical for you to make it
    as easy as possible for users to understand your interface and as hard as possible
    for them to use it incorrectly. The two primary techniques at your disposal for
    this are your documentation and the type system, so let’s look at each of those
    in turn.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然一些用户可能熟悉支撑你接口实现的某些方面，但他们不太可能理解所有的规则和限制。他们可能不知道在调用`bar`之后调用`foo`永远是不可以的，也不知道只有当月亮位于47度角并且过去18秒内没有人打喷嚏时，调用不安全方法`baz`才是安全的。只有当接口明确表明某些行为很奇怪时，用户才会去查阅文档或仔细阅读类型签名。因此，为用户提供尽可能简便的理解接口的方式，并尽可能使其难以错误使用接口是至关重要的。实现这一点的两大主要技术手段就是文档和类型系统，接下来我们分别来看一下这两者。
- en: Documentation
  id: totrans-68
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 文档
- en: The first step to making your interfaces transparent is to write good documentation.
    I could write an entire book dedicated to how to write documentation, but let’s
    focus on Rust-specific advice here.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 让你的接口透明的第一步是写好文档。我可以写一本书来专门讨论如何写文档，但在这里我们将专注于Rust的特定建议。
- en: 'First, clearly document any cases where your code may do something unexpected,
    or where it relies on the user doing something beyond what’s dictated by the type
    signature. Panics are a good example of both of these circumstances: if your code
    can panic, document that fact, along with the circumstances it might panic under.
    Similarly, if your code might return an error, document the cases in which it
    does. For unsafe functions, document what the caller must guarantee in order for
    the call to be safe.'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，清楚地记录下任何可能导致代码产生意外行为的情况，或者代码依赖用户在类型签名之外执行的操作。恐慌是这两种情况的一个好例子：如果你的代码可能发生恐慌，文档中需要记录这一事实，并说明在什么情况下可能发生恐慌。同样，如果代码可能返回错误，也需要记录在哪些情况下会返回错误。对于不安全的函数，记录调用者需要保证什么条件才能确保调用是安全的。
- en: Second, include end-to-end usage examples for your code on a crate and module
    level. These are more important than examples for specific types or methods, since
    they give the user a feel for how everything fits together. With a decent high-level
    understanding of the interface’s structure, the developer may soon realize what
    particular methods and types do and where they should be used. End-to-end examples
    also give the user a starting point for customizing their usage, and they can,
    and often will, copy-paste the example and then modify it to suit their needs.
    This kind of “learning by doing” tends to work better than having them try to
    piece something together from the components.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 第二，为你的代码提供端到端的使用示例，分别在crate和模块层级上。这些示例比针对特定类型或方法的示例更为重要，因为它们可以让用户了解整个系统是如何协同工作的。通过对接口结构的高层次理解，开发者很快就能意识到某些方法和类型的作用以及它们应该如何使用。端到端的示例还为用户提供了定制使用的起点，他们通常会复制并粘贴示例，然后根据自己的需求修改它。这种“做中学”的方法通常比让用户从各个组件拼凑起来要有效得多。
- en: Third, organize your documentation. Having all your types, traits, and functions
    in a single top-level module makes it difficult for the user to get a sense of
    where to start. Take advantage of modules to group together semantically related
    items. Then, use intra-documentation links to interlink items. If the documentation
    on type A talks about trait B, then it should link to that trait right there.
    If you make it easy for the user to explore your interface, they are less likely
    to miss important connections or dependencies. Also consider marking parts of
    your interface that are not intended to be public but are needed for legacy reasons
    with `#[doc(hidden)]`, so that they do not clutter up your documentation.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 第三，组织好你的文档。将所有的类型、特征和函数放在一个顶级模块中会让用户很难判断从哪里开始。利用模块将语义相关的项组合在一起。然后，使用文档内链接相互关联这些项目。如果类型A的文档中提到特征B，那么就应该直接链接到该特征。如果你让用户更容易探索你的接口，他们就不太可能错过重要的连接或依赖关系。还要考虑使用`#[doc(hidden)]`标记那些由于历史原因而需要存在但不打算公开的接口部分，这样它们就不会干扰文档。
- en: And finally, enrich your documentation wherever possible. Link to external resources
    that explain concepts, data structures, algorithms, or other aspects of your interface
    that may have good explanations elsewhere. RFCs, blog posts, and whitepapers are
    great for this, if any are relevant. Use `#[doc(cfg(..))]` to highlight items
    that are available only under certain configurations so the user quickly realizes
    why some method that’s listed in the documentation isn’t available. Use `#[doc(alias
    = "...")]` to make types and methods discoverable under other names that users
    may search for them by. In the top-level documentation, point the user to commonly
    used modules, features, types, traits, and methods.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，尽可能丰富你的文档。链接到外部资源，解释概念、数据结构、算法或其他接口方面的内容，这些可能在其他地方有很好的解释。RFC、博客文章和白皮书是很好的资源，如果有相关的。使用`#[doc(cfg(..))]`突出显示那些只有在特定配置下才可用的项，让用户快速理解为什么某些文档中列出的方法不可用。使用`#[doc(alias
    = "...")]`使类型和方法能通过用户可能搜索的其他名称进行发现。在顶级文档中，引导用户查看常用的模块、功能、类型、特征和方法。
- en: Type System Guidance
  id: totrans-74
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 类型系统指导
- en: The type system is an excellent tool to ensure that your interfaces are obvious,
    self-documenting, and misuse-resistant. You have several techniques at your disposal
    that can make your interfaces very hard to misuse, and thus, make it more likely
    that they will be used correctly.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 类型系统是确保你的接口明显、自动文档化且抗滥用的优秀工具。你有多种技术手段可以使你的接口不容易被滥用，从而更有可能正确地使用它们。
- en: 'The first of these is *semantic typing*, in which you add types to represent
    the *meaning* of a value, not just its primitive type. The classic example here
    is for Booleans: if your function takes three `bool` arguments, chances are some
    user will mess up the order of the values and realize it only after something
    has gone terribly wrong. If, on the other hand, it takes three arguments of distinct
    two-variant enum types, the user cannot get the order wrong without the compiler
    yelling at them: if they attempt to pass `DryRun::Yes` to the `overwrite` argument,
    that will simply not work, nor will passing `Overwrite::No` as the `dry_run` argument.
    You can apply semantic typing beyond Booleans as well. For example, a newtype
    around a numeric type may provide a unit for the contained value, or it could
    constrain raw pointer arguments to only those that have been returned by another
    method.'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 其中第一个是*语义类型*，即你添加类型来表示一个值的*含义*，而不仅仅是它的原始类型。经典的例子是布尔类型：如果你的函数接受三个`bool`类型的参数，通常某个用户会搞错参数顺序，并且只有在某些严重问题发生后才会意识到这一点。而另一方面，如果它接受三个不同的、带有两个变体的枚举类型作为参数，用户就无法搞错顺序，因为编译器会立即报错：如果他们试图将`DryRun::Yes`传给`overwrite`参数，这是行不通的，传`Overwrite::No`给`dry_run`参数也不行。你可以将语义类型应用到布尔类型之外的其他类型。例如，围绕数字类型的新类型可能为包含的值提供一个单位，或者它可以限制原始指针参数，只接受由其他方法返回的指针。
- en: A closely related technique is to use zero-sized types to indicate that a particular
    fact is true about an instance of a type. Consider, for instance, a type called
    `Rocket` that represents the state of a real rocket. Some operations (methods)
    on `Rocket` should be available no matter what state the rocket is in, but some
    make sense only in particular situations. It is, for example, impossible to launch
    a rocket if it has already been launched. Similarly, it should probably not be
    possible to separate the fuel tank if the rocket has not yet launched. We could
    model these as enum variants, but then all the methods would be available at every
    stage, and we’d need to introduce possible panics.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 一个密切相关的技术是使用零大小类型来表示类型实例的某些事实。例如，考虑一个名为`Rocket`的类型，它表示一个真实火箭的状态。在`Rocket`上的某些操作（方法）无论火箭处于何种状态都应该可用，但有些操作只有在特定情况下才有意义。例如，如果火箭已经发射，就无法再次发射。同样，如果火箭尚未发射，可能也不应允许拆卸燃料箱。我们可以将这些操作建模为枚举变体，但那样的话，所有方法在每个阶段都会可用，并且我们需要引入可能的恐慌（panic）。
- en: Instead, as shown in [Listing 3-2](#listing3-2), we can introduce a generic
    parameter on `Rocket`, `Stage`, and use it to restrict what methods are available
    when.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，如[清单 3-2](#listing3-2)所示，我们可以在`Rocket`、`Stage`上引入一个泛型参数，并使用它来限制在何时可以调用哪些方法。
- en: '[PRE1]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Listing 3-2: Using marker types to restrict implementations'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 清单 3-2：使用标记类型来限制实现
- en: We introduce unit types to represent each stage of the rocket 1. We don’t actually
    need to store the stage—only the meta-information it provides—so we store it behind
    a `PhantomData` 2 to guarantee that it is eliminated at compile time. Then, we
    write implementation blocks for `Rocket` only when it holds a particular type
    parameter. You can construct a rocket only on the ground (for now), and you can
    launch it only from the ground 3. Only when the rocket has been launched can you
    control its velocity 4. There are some things you can always do with the rocket,
    no matter what state it is in, and those we place in a generic implementation
    block 5. You’ll notice that with the interface designed this way, it’s simply
    not possible for the user to call a method at the wrong time—we have encoded the
    usage rules in the types themselves, and made illegal states *unrepresentable*.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 我们引入了单位类型来表示火箭的每个阶段。实际上，我们并不需要存储阶段本身——只需存储它提供的元信息——因此我们通过`PhantomData`存储它，以确保它在编译时被消除。然后，我们仅在`Rocket`持有特定类型参数时，才编写实现块。你只能在地面上构建火箭（暂时如此），并且只能从地面发射它。只有当火箭已被发射时，才能控制其速度。有些事情是你无论火箭处于什么状态时都可以做的，这些操作我们放入了泛型实现块中。你会注意到，以这种方式设计接口时，用户不可能在错误的时机调用方法——我们已经将使用规则编码在类型本身中，并使非法状态*无法表示*。
- en: This notion extends to many other domains as well; if your function ignores
    a pointer argument unless a given Boolean argument is true, it’s better to combine
    the two arguments instead. With an enum type with one variant for `false` (and
    no pointer) and one variant for `true` that holds a pointer, neither the caller
    nor the implementer can misunderstand the relationship between the two. This is
    a powerful idea that I highly encourage you to make use of.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 这个概念也扩展到了许多其他领域；如果你的函数忽略了一个指针参数，除非给定的布尔参数为真，那么最好将这两个参数合并在一起。使用一个枚举类型，其中一个变体表示`false`（且没有指针），另一个变体表示`true`并携带一个指针，这样调用者和实现者都不会误解这两者之间的关系。这是一个强大的思想，我强烈鼓励你加以利用。
- en: 'Another small but useful tool in making interfaces obvious is the `#[must_use]`
    annotation. Add it to any type, trait, or function, and the compiler will issue
    a warning if the user’s code receives an element of that type or trait, or calls
    that function, and does not explicitly handle it. You may already have seen this
    in the context of `Result`: if a function returns a `Result` and you do not assign
    its return value somewhere, you get a compiler warning. Be careful not to overuse
    this annotation, though—add it only if the user is very likely to make a mistake
    if they are not using the return value.'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个小而有用的工具，能够使接口更直观的是`#[must_use]`注解。将其添加到任何类型、特征或函数上，如果用户的代码接收了该类型或特征的元素，或者调用了该函数，却没有显式处理它，编译器将发出警告。你可能已经在`Result`的上下文中见过这种用法：如果一个函数返回一个`Result`，而你没有在某个地方使用其返回值，就会收到编译器的警告。不过，要小心不要过度使用这个注解——只有当用户如果不使用返回值时，很可能会犯错误时，才应该添加它。
- en: Constrained
  id: totrans-84
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 受限
- en: Over time, some user will depend on every property of your interface, whether
    bug or feature. This is especially true for publicly available libraries where
    you have no control over your users. As a result, you should think carefully before
    you make user-visible changes. Whether you’re adding a new type, field, method,
    or trait implementation or changing an existing one, you want to make sure that
    the change will not break existing users’ code, and that you are planning to keep
    that change around for a while. Frequent backward incompatible changes (major
    version increases in semantic versioning) are sure to draw the ire of your users.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 随着时间的推移，某些用户会依赖你接口的每个属性，无论是bug还是功能。这对于那些公开可用的库尤其如此，因为你无法控制用户的使用方式。因此，在做出对用户可见的修改之前，你应该仔细思考。无论是添加一个新的类型、字段、方法或特征实现，还是修改现有的，你都需要确保这些修改不会破坏现有用户的代码，并且你打算在一段时间内保留这个修改。频繁的向后不兼容修改（语义版本管理中的主版本增加）必然会引起用户的不满。
- en: Many backward incompatible changes are obvious, like renaming a public type
    or removing a public method, but some are subtler and tie in deeply with the way
    Rust works. Here, we’ll cover some of the thornier subtle changes and how to plan
    for them. You’ll see that you need to balance some of these against how flexible
    you want your interface to be—sometimes, something’s got to give.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 许多向后不兼容的更改是显而易见的，比如重命名公共类型或删除公共方法，但有些更改则更为微妙，并且与Rust的工作方式深度结合。在这里，我们将讨论一些更棘手、微妙的更改，以及如何为它们做好规划。你会看到，你需要在这些变化与希望接口灵活性之间找到平衡——有时候，必须做出妥协。
- en: Type Modifications
  id: totrans-87
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 类型修改
- en: Removing or renaming a public type will almost certainly break some user’s code.
    To counter this, you’ll want to take advantage of Rust’s visibility modifiers,
    like `pub(crate)` and `pub(in path)`, whenever possible. The fewer public types
    you have, the more freedom you have to change things later without breaking existing
    code.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 删除或重命名公共类型几乎肯定会破坏某些用户的代码。为了应对这一点，你需要尽可能利用Rust的可见性修饰符，如`pub(crate)`和`pub(in path)`。公共类型越少，你在以后修改代码时，就能越自由地避免破坏现有代码。
- en: User code can depend on your types in more ways than just by name, though. Consider
    the public type in [Listing 3-3](#listing3-3) and the given use of that code.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，用户的代码可以以比仅仅通过名称依赖你的类型更多的方式进行依赖。考虑一下[列表 3-3](#listing3-3)中的公共类型以及该代码的使用方式。
- en: '[PRE2]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Listing 3-3: An innocent-looking public type'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 3-3：一个看似无害的公共类型
- en: Now consider what happens if you add a private field to `Unit`. Even though
    the field you add is private, the change will still break the user’s code, because
    the constructor they relied on has disappeared. Similarly, consider the code and
    use in [Listing 3-4](#listing3-4).
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 现在考虑一下，如果你向`Unit`添加一个私有字段会发生什么。即使你添加的字段是私有的，这个改变仍然会破坏用户的代码，因为他们依赖的构造函数已经消失了。类似地，考虑一下[列表
    3-4](#listing3-4)中的代码和用法。
- en: '[PRE3]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Listing 3-4: User code accessing a single public field'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 3-4：用户代码访问单一公共字段
- en: 'Here, too, adding a private field to `Unit` will break user code, this time
    because Rust’s exhaustive pattern match checking logic is able to see parts of
    the interface that the user cannot see. It recognizes that there are more fields,
    even though the user code cannot access them, and rejects the user’s pattern as
    incomplete. A similar issue arises if we turn a tuple struct into a regular struct
    with named fields: even if the fields themselves are exactly the same, any old
    patterns will no longer be valid for the new type definition.'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，向 `Unit` 添加一个私有字段会破坏用户代码，这次是因为 Rust 的穷举模式匹配检查逻辑能够看到用户无法看到的接口部分。它会识别出有更多的字段，尽管用户代码无法访问它们，并拒绝用户的模式作为不完整模式。如果我们将元组结构体转换为带有命名字段的常规结构体，也会出现类似的问题：即使字段本身完全相同，任何旧模式也将不再适用于新的类型定义。
- en: 'Rust provides the `#[non_exhaustive]` attribute to help mitigate these issues.
    You can add it to any type definition, and the compiler will disallow the use
    of implicit constructors (like `lib::Unit { field1: true }`) and nonexhaustive
    pattern matches (that is, patterns without a trailing `, ..`) on that type. This
    is a great attribute to add if you suspect that you’re likely to modify a particular
    type in the future. It does constrain user code though, such as by taking away
    users’ ability to rely on exhaustive pattern matches, so avoid adding it if you
    think a given type is likely to remain stable.'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 'Rust 提供了 `#[non_exhaustive]` 属性来帮助缓解这些问题。你可以将它添加到任何类型定义中，编译器将禁止在该类型上使用隐式构造函数（例如
    `lib::Unit { field1: true }`）和非穷举模式匹配（即没有尾随 `, ..` 的模式）。如果你怀疑将来可能会修改某个特定类型，那么添加这个属性是非常有用的。然而，它确实会约束用户代码，例如剥夺用户依赖穷举模式匹配的能力，因此，如果你认为某个类型可能保持稳定，最好避免添加这个属性。'
- en: Trait Implementations
  id: totrans-97
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 特征实现
- en: As you’ll recall from Chapter 2, Rust’s coherence rules disallow multiple implementations
    of a given trait for a given type. Since we do not know what implementations downstream
    code may have added, adding a blanket implementation of an existing trait is generally
    a breaking change. The same holds true for implementing a foreign trait for an
    existing type, or an existing trait for a foreign type—in both cases, the owner
    of the foreign trait or type may simultaneously add a conflicting implementation,
    so this must be a breaking change.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你在第 2 章中回顾到的，Rust 的一致性规则不允许对给定类型的特征进行多重实现。由于我们不知道下游代码可能已经添加了什么实现，添加现有特征的通用实现通常是一个破坏性更改。对现有类型实现外部特征，或对外部类型实现现有特征也是如此——在这两种情况下，外部特征或类型的拥有者可能会同时添加冲突的实现，因此这必须是一个破坏性更改。
- en: Removing a trait implementation is a breaking change, but implementing traits
    for a *new* type is never a problem, since no crate can have implementations that
    conflict with that type.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 移除一个特征实现是一个破坏性更改，但为一个*新*类型实现特征永远不是问题，因为没有 crate 会有与该类型冲突的实现。
- en: Perhaps counterintuitively, you also want to be careful about implementing *any*
    trait for an existing type. To see why, consider the code in [Listing 3-5](#listing3-5).
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 或许反直觉的是，你也需要小心为现有类型实现*任何*特征。为了理解原因，考虑[列表 3-5](#listing3-5)中的代码。
- en: '[PRE4]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Listing 3-5: Implementing a trait for an existing type may cause problems.'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 3-5：为现有类型实现特征可能会导致问题。
- en: If you add `impl Foo1 for Unit` to `crate1` without marking it a breaking change,
    the downstream code will suddenly stop compiling since the call to `foo` is now
    ambiguous. This can even apply to implementations of *new* public traits, if the
    downstream crate uses wildcard imports (`use crate1::*`). You will particularly
    want to keep this in mind if you provide a `prelude` module that you instruct
    users to use wildcard imports for.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你为 `crate1` 添加了 `impl Foo1 for Unit`，却没有标记为破坏性更改，下游代码将突然停止编译，因为对 `foo` 的调用现在变得模糊不清。这甚至适用于实现*新*公共特征的情况，如果下游
    crate 使用了通配符导入（`use crate1::*`）。如果你提供了一个 `prelude` 模块，并指示用户使用通配符导入，你尤其需要牢记这一点。
- en: Most changes to existing traits are also breaking changes, such as changing
    a method signature or adding a new method. Changing a method signature breaks
    all implementations, and probably many uses, of the trait, whereas adding a new
    method “just” breaks all implementations. Adding a new method with a default implementation
    is fine though, since existing implementations will continue to apply.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 对现有特征的大多数更改也是破坏性更改，例如更改方法签名或添加新方法。更改方法签名会破坏所有实现，并可能破坏特征的许多使用情况，而添加新方法“仅仅”会破坏所有实现。然而，添加带有默认实现的新方法是可以的，因为现有的实现将继续适用。
- en: 'I say “generally” and “most” here, because as interface authors, we have a
    tool available to us that lets us skirt some of these rules: *sealed traits*.
    Asealed trait is one that can be used only, and not implemented, by other crates.
    This immediately makes a number of breaking changes non-breaking. For example,
    you can add a new method to a sealed trait, since you know there are no implementations
    outside of the current crate to consider. Similarly, you can implement a sealed
    trait for new foreign types, since you know the foreign crate that defined that
    type cannot have added a conflicting implementation.'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 我这里说“通常”和“最”是因为作为接口的作者，我们有一个工具可以让我们绕过一些规则：*封闭特征*。封闭特征是只能由其他 crate 使用，而不能由它们实现的特征。这立即使得一些破坏性更改变得非破坏性。例如，你可以向封闭特征添加一个新方法，因为你知道没有其他实现需要考虑。同样，你可以为新的外部类型实现封闭特征，因为你知道定义该类型的外部
    crate 不可能添加与之冲突的实现。
- en: Sealed traits are most commonly used for *derived* traits—traits that provide
    blanket implementations for types that implement particular other traits. You
    should seal a trait only if it does not make sense for a foreign crate to implement
    your trait; it severely restricts the usefulness of the trait, since downstream
    crates will no longer be able to implement it for their own types. You can also
    use sealed traits to restrict which types can be used as type arguments, such
    as restricting the `Stage` type in the `Rocket` example from [Listing 3-2](#listing3-2)
    to only the `Grounded` and `Launched` types.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 封闭特征最常用于*派生*特征——为实现特定其他特征的类型提供通用实现的特征。只有当你认为外部 crate 不应实现你的特征时，才应该封闭特征；这会严重限制特征的可用性，因为下游
    crate 将无法为自己的类型实现该特征。你还可以使用封闭特征来限制哪些类型可以作为类型参数，例如在 [列表 3-2](#listing3-2) 的 `Rocket`
    示例中，将 `Stage` 类型限制为仅 `Grounded` 和 `Launched` 类型。
- en: '[Listing 3-6](#listing3-6) shows how to seal a trait and how to then still
    add implementations for it in the defining crate.'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: '[列表 3-6](#listing3-6)展示了如何封闭一个特征，并如何在定义 crate 中为其添加实现。'
- en: '[PRE5]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Listing 3-6: How to seal a trait and add implementations for it'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 3-6：如何封闭一个特征并为其添加实现
- en: The trick is to add a private, empty trait as a supertrait of the trait you
    wish to seal 1. Since the supertrait is in a private module, other crates cannot
    reach it and thus cannot implement it. The sealed trait requires the underlying
    type to implement `Sealed`, so only the types that we explicitly allow 2 are able
    to ultimately implement the trait.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 诀窍是将一个私有的、空的特征作为你希望封闭的特征的超特征 1。由于超特征位于私有模块中，其他 crate 无法访问它，因此也无法实现它。封闭特征要求底层类型实现
    `Sealed`，因此只有我们明确允许的类型 2 才能最终实现该特征。
- en: Hidden Contracts
  id: totrans-111
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 隐藏的契约
- en: Sometimes, changes you make to one part of your code affect the contract elsewhere
    in your interface in subtle ways. The two primary ways this happens are through
    re-exports and auto-traits.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，你对代码某一部分所做的更改会以微妙的方式影响接口中其他部分的契约。发生这种情况的两种主要方式是通过重新导出和自动特征。
- en: Re-Exports
  id: totrans-113
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 重新导出
- en: If any part of your interface exposes foreign types, then any change to one
    of those foreign types is *also* a change to your interface. For example, consider
    what happens if you move to a new major version of a dependency and expose a type
    from that dependency as, say, an iterator type in your interface. A user that
    depends on your interface may also depend directly on that dependency and expect
    that the type your interface provides is the same as the one by the same name
    in that dependency. But if you change the major version of your dependency, that
    is no longer true even though the *name* of the type is the same. [Listing 3-7](#listing3-7)
    shows an example of this.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你的接口的任何部分暴露了外部类型，那么这些外部类型的任何变化*也*会影响你的接口。例如，考虑如果你迁移到依赖项的新主版本，并将该依赖项中的某个类型作为迭代器类型暴露在你的接口中，会发生什么。依赖于你的接口的用户可能也会直接依赖该依赖项，并期望你的接口提供的类型与该依赖项中相同名称的类型相同。但如果你更改了依赖项的主版本，即使类型的*名称*相同，这种假设也不再成立。[列表
    3-7](#listing3-7)展示了这一点的示例。
- en: '[PRE6]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Listing 3-7: Re-exports make foreign crates part of your interface contract.'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 3-7：重新导出使外部 crate 成为你接口契约的一部分。
- en: If your crate moves from `itercrate 1.0` to `itercrate 2.0` but otherwise does
    not change, the code in this listing will no longer compile. Even though no types
    have changed, the compiler believes (correctly) that `itercrate1.0::Empty` and
    `itercrate2.0::Empty` are *different* types. Therefore, you cannot assign the
    latter to the former, making this a breaking change in your interface.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你的 crate 从 `itercrate 1.0` 迁移到 `itercrate 2.0`，但其他方面没有变化，那么此列表中的代码将无法编译。即使类型没有发生变化，编译器也会（正确地）认为
    `itercrate1.0::Empty` 和 `itercrate2.0::Empty` 是*不同*的类型。因此，你不能将后者赋值给前者，这使得这是一个破坏性的接口变更。
- en: To mitigate issues like this, it’s often best to wrap foreign types using the
    newtype pattern, and then expose only the parts of the foreign type that you think
    are useful. In many cases, you can avoid the newtype wrapper altogether by using
    `impl Trait` to provide only the very minimal contract to the caller. By promising
    less, you make fewer changes breaking.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 为了减轻类似问题，通常最好的做法是使用新类型模式（newtype pattern）来包装外部类型，然后仅暴露你认为有用的外部类型部分。在许多情况下，你可以完全避免使用新类型包装器，通过
    `impl Trait` 只提供非常简化的契约给调用者。通过承诺更少，你可以减少破坏性变化。
- en: Auto-Traits
  id: totrans-119
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 自动特性
- en: Rust has a handful of traits that are automatically implemented for every type
    depending on what that type contains. The most relevant of these for this discussion
    are `Send` and `Sync`, though the `Unpin`, `Sized`, and `UnwindSafe` traits have
    similar issues. By their very nature, these add a hidden promise made by nearly
    every type in your interface. These traits even propagate through otherwise type-erased
    types like `impl Trait`.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: Rust 有一些特性（traits）会根据类型所包含的内容自动实现。对于本次讨论，最相关的是 `Send` 和 `Sync`，尽管 `Unpin`、`Sized`
    和 `UnwindSafe` 特性也存在类似的问题。从本质上讲，这些特性为你的接口中的几乎每个类型添加了一个隐藏的承诺。这些特性甚至会通过像 `impl Trait`
    这样的类型擦除类型传播。
- en: Implementations for these traits are (generally) automatically added by the
    compiler, but that also means that they are *not* automatically added if they
    no longer apply. So, if you have a public type `A` that contains a private type
    `B`, and you change `B` so that it is no longer `Send`, then `A` is now *also*
    not `Send`. That is a breaking change!
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 这些特性的实现（通常）是由编译器自动添加的，但这也意味着，如果它们不再适用，它们*不会*被自动添加。所以，如果你有一个包含私有类型 `B` 的公共类型
    `A`，并且你修改 `B` 使其不再是 `Send`，那么 `A` 现在*也*不再是 `Send`。这就是一个破坏性更改！
- en: These changes can be hard to keep track of and are often not discovered until
    a user of your interface complains that their code no longer works. To catch these
    cases before they happen, it’s good practice to include some simple tests in your
    test suite that check that all your types implement these traits the way you expect.
    [Listing 3-8](#listing3-8) gives an example of what such a test might look like.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 这些变化可能很难追踪，并且通常直到接口的用户抱怨他们的代码不再工作时才会被发现。为了在问题发生前捕捉到这些情况，良好的做法是在测试套件中包含一些简单的测试，检查你的所有类型是否按照预期实现了这些特性。[列表
    3-8](#listing3-8) 给出了一个此类测试的示例。
- en: '[PRE7]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Listing 3-8: Testing that a type implements a set of traits'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 3-8：测试类型是否实现了一组特性
- en: Notice that this test does not run any code, but simply tests that the code
    compiles. If `MyType` no longer implements `Sync`, the test code will not compile,
    and you will know that the change you just made broke the auto-trait implementation.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，这个测试不会运行任何代码，而只是测试代码是否能成功编译。如果 `MyType` 不再实现 `Sync`，测试代码将无法编译，你将知道你刚刚做的更改破坏了自动特性实现。
- en: Summary
  id: totrans-126
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 总结
- en: 'In this chapter we’ve explored the many facets of designing a Rust interface,
    whether it’s intended for external use or just as an abstraction boundary between
    the different modules within your crate. We covered a lot of specific pitfalls
    and tricks, but ultimately, the high-level principles are what should guide your
    thinking: your interfaces should be unsurprising, flexible, obvious, and constrained.
    In the next chapter, we will dig into how to represent and handle errors in Rust
    code.'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们探讨了设计 Rust 接口的多个方面，无论它是面向外部使用，还是仅作为你 crate 内部不同模块之间的抽象边界。我们覆盖了许多具体的陷阱和技巧，但最终，高层的原则应该是引导你思考的方向：你的接口应该是让人毫不意外、灵活、显而易见且有约束的。在下一章中，我们将深入讨论如何在
    Rust 代码中表示和处理错误。
