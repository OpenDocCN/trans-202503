- en: <hgroup>
  id: totrans-0
  prefs: []
  type: TYPE_NORMAL
  zh: <hgroup>
- en: 8 ADVANCED ARITHMETIC
  id: totrans-1
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 8 高级算术
- en: </hgroup>
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: </hgroup>
- en: '![](../images/opener.jpg)'
  id: totrans-3
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/opener.jpg)'
- en: This chapter covers extended-precision arithmetic and arithmetic on operands
    of different sizes. By the end of this chapter, you should know how to apply arithmetic
    and logical operations to integer operands of any size, including those larger
    than 64 bits, and how to convert operands of different sizes into a compatible
    format.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 本章讲解了扩展精度算术和不同大小操作数的算术运算。到本章结束时，你应该能够了解如何对任意大小的整数操作数执行算术和逻辑运算，包括超过64位的操作数，以及如何将不同大小的操作数转换为兼容的格式。
- en: 8.1 Extended-Precision Operations
  id: totrans-5
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 8.1 扩展精度运算
- en: 'Assembly language does not limit the size of integer operations, a major advantage
    over HLLs (which typically rely on functions, written in assembly language, to
    handle extended-precision arithmetic). For example, the standard C programming
    language defines four integer sizes: short int, int, long int, and long long int.
    On the PC, these are often 16-, 32-, and 64-bit integers.'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 汇编语言不限制整数运算的大小，这是与高级语言（HLLs）相比的一个主要优势，高级语言通常依赖于汇编语言编写的函数来处理扩展精度算术。例如，标准C语言定义了四种整数大小：short
    int、int、long int和long long int。在PC上，这些通常是16位、32位和64位整数。
- en: Although the ARM machine instructions limit you to processing 32- or 64-bit
    integers with a single instruction, you can use multiple instructions to process
    integers of any size. This section describes how to extend various arithmetic
    and logical operations from 32 or 64 bits to as many bits as you please.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管ARM的机器指令限制你使用单一指令处理32位或64位整数，但你可以使用多个指令处理任意大小的整数。本节描述了如何将各种算术和逻辑操作从32位或64位扩展到任意位数。
- en: 8.1.1 Addition
  id: totrans-8
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 8.1.1 加法
- en: The ARM add/adds instruction adds two 32- or 64-bit numbers. After the execution
    of adds, the ARM carry flag is set if you have an overflow out of the HO bit of
    the sum. You can use this information to do extended-precision addition operations.
    (This book uses *multidigit* and *multibyte* as synonyms for *extended precision*.)
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: ARM的`add`/`adds`指令可以加两个32位或64位数字。执行`adds`后，如果和的高位（HO位）发生溢出，ARM会设置进位标志。你可以利用这一信息进行扩展精度的加法运算。（本书将*多位数*和*多字节*视为*扩展精度*的同义词。）
- en: Consider the way you manually perform a multidigit addition operation, as shown
    in [Figure 8-1](chapter8.xhtml#fig8-1).
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑你手动执行多位数加法运算的方式，如[图8-1](chapter8.xhtml#fig8-1)所示。
- en: '![](../images/Figure8-1.jpg)'
  id: totrans-11
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/Figure8-1.jpg)'
- en: 'Figure 8-1: Multidigit addition'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 图8-1：多位数加法
- en: The ARM handles extended-precision arithmetic the same way, except instead of
    adding the numbers a digit at a time, it adds them together a word or double word
    at a time, breaking a larger operation into a sequence of smaller ones. For example,
    consider the three-double-word (192-bit) addition operation in [Figure 8-2](chapter8.xhtml#fig8-2).
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: ARM以相同的方式处理扩展精度算术，不同之处在于，它不是一次加一个数字，而是一次加一个字或双字，将较大的操作分解为一系列较小的操作。例如，考虑[图8-2](chapter8.xhtml#fig8-2)中展示的三双字（192位）加法操作。
- en: '![](../images/Figure8-2.jpg)'
  id: totrans-14
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/Figure8-2.jpg)'
- en: 'Figure 8-2: Adding two 192-bit objects together'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 图8-2：将两个192位对象相加
- en: 'Since the ARM processor family is capable of adding together at most 64 bits
    at a time (using general-purpose registers), the operation must proceed in blocks
    of 64 bits or fewer, according to the following steps:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 由于ARM处理器系列每次最多只能加64位（使用通用寄存器），因此运算必须按64位或更小的块进行，遵循以下步骤：
- en: 1.  Add the two LO double words together just as you would add the two LO digits
    of a decimal number together in the manual algorithm, using the adds instruction.
    If there is a carry out of the LO addition, adds sets the carry flag to 1\. Otherwise,
    it clears the carry flag.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 1.  就像在手动算法中将两个十进制数的低位数字相加一样，将两个低位双字相加，使用`adds`指令。如果低位相加时有进位，`adds`会将进位标志设置为1；否则，进位标志会被清除。
- en: '2.  Add together the second pair of double words in the two 192-bit values,
    plus the carry out of the previous addition (if any), using the adcs (add with
    carry) instruction. The adcs instruction uses the same syntax as adds and performs
    almost the same operation:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 2.  将两个192位值中的第二对双字以及前一次加法的进位（如果有）加在一起，使用`adcs`（带进位加法）指令。`adcs`指令的语法与`adds`相同，执行的几乎是相同的操作：
- en: '[PRE0]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The only difference is that adcs adds in the value of the carry flag along with
    the source operands. It sets the flags the same way adds does (including setting
    the carry flag if there is an unsigned overflow). This is exactly what we need
    in order to add together the middle two double words of our 192-bit sum.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 唯一的区别是adcs指令在加源操作数的同时加上了进位标志的值。它设置标志的方式与adds指令相同（包括在发生无符号溢出时设置进位标志）。这正是我们需要的，以便将192位和的中间两个双字加在一起。
- en: 3.  Add the HO double words of the 192-bit value with the carry out of the sum
    of the middle two quad words by using adcs. (You could also use a plain adc instruction
    if you don’t need the flag settings after the instruction.)
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 3. 使用adcs将192位值的高阶双字与中间两个四字的和的进位相加。（如果你不需要指令后的标志设置，也可以使用普通的adc指令。）
- en: To summarize, the adds instruction adds the LO double words together, and adcs
    adds all other double-word pairs together. At the end of the extended-precision
    addition sequence, the carry flag indicates unsigned overflow (if set), a set
    overflow flag indicates signed overflow, and the sign flag indicates the sign
    of the result. The zero flag doesn’t have any real meaning at the end of the extended-precision
    addition; it simply means that the sum of the two HO double words is 0 and does
    not indicate that the whole result is 0.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 总结来说，adds指令将低阶双字相加，而adcs指令将所有其他双字对相加。在扩展精度加法序列结束时，进位标志表示无符号溢出（如果设置），溢出标志表示符号溢出，而符号标志表示结果的符号。零标志在扩展精度加法结束时没有实际意义；它仅表示两个高阶双字的和为0，并不表示整个结果为0。
- en: 'For example, suppose you have two 128-bit values you wish to add together,
    defined as follows:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，假设你有两个128位的值需要相加，定义如下：
- en: '[PRE1]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Say you want to store the sum in a third variable Z, which is also a qword.
    The following ARM code will accomplish this task:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你想将和存储在第三个变量Z中，Z也是一个四字。以下ARM代码将完成这项任务：
- en: '[PRE2]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The first seven instructions add the LO double words of X and Y together and
    store the result into the LO double word of Z. The last four instructions add
    the HO double words of X and Y together, along with the carry from the LO word,
    and store the result in the HO double word of Z.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 前七条指令将X和Y的低阶双字相加，并将结果存储到Z的低阶双字中。最后四条指令将X和Y的高阶双字加在一起，并加上低阶字的进位，将结果存储到Z的高阶双字中。
- en: 'You can extend this algorithm to any number of bits by using adcs to add in
    the higher-order values. For example, to add together two 256-bit values declared
    as arrays of four double words, you could use code like the following:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过使用adcs指令将更高阶的值加在一起，来扩展此算法到任何位数。例如，要将两个声明为四个双字数组的256位值加在一起，你可以使用如下代码：
- en: '[PRE3]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: This produces a 256-bit sum and stores it in the memory location BigVal3.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 这会产生一个256位的和，并将其存储在内存位置BigVal3中。
- en: 8.1.2 Subtraction
  id: totrans-31
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 8.1.2 减法
- en: The ARM also performs multibyte subtraction the same way you would manually,
    except that it subtracts whole words or double words at a time rather than decimal
    digits. Use the subs instruction on the LO word or double word and the sbc/sbcs
    (subtract with carry) instruction on the HO values.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: ARM也以手动方式执行多字节减法，只是它一次减去整字或双字，而不是十进制位。使用subs指令在低阶字或双字上进行操作，并在高阶值上使用sbc/sbcs（带进位减法）指令。
- en: 'The following example demonstrates a 128-bit subtraction using the 64-bit registers
    on the ARM:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例演示了使用ARM的64位寄存器进行128位减法：
- en: '[PRE4]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The following example demonstrates a 256-bit subtraction:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例演示了256位减法：
- en: '[PRE5]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: This produces a 256-bit difference and stores it in the memory location BigVal3.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 这会产生一个256位的差值，并将其存储在内存位置BigVal3中。
- en: 8.1.3 Comparisons
  id: totrans-38
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 8.1.3 比较
- en: Unfortunately, there’s no “compare with carry” instruction that you can use
    to perform extended-precision comparisons. However, you can compare extended-precision
    values by using just a cmp instruction.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，没有可以用来执行扩展精度比较的“带进位比较”指令。然而，你可以通过仅使用cmp指令来比较扩展精度值。
- en: Consider the two unsigned values 0x2157 and 0x1293\. The LO bytes of these two
    values do not affect the outcome of the comparison. Simply comparing the HO bytes,
    0x21 with 0x12, tells you that the first value is greater than the second.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你想比较两个无符号值0x2157和0x1293。这两个值的低字节不会影响比较的结果。仅比较高字节，0x21与0x12，就能得出第一个值大于第二个值的结论。
- en: 'You must look at both bytes of a pair of values if the HO bytes are equal.
    In all other cases, comparing the HO bytes tells you everything you need to know
    about the values. This is true for any number of bytes, not just two. The following
    code compares two signed 128-bit integers by comparing their HO double words first
    and comparing their LO double words only if the HO quad words are equal:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 如果高位字节相等，则必须查看一对值的两个字节。在其他情况下，比较高位字节即可得知有关值的所有信息。这适用于任何字节数，而不仅仅是两个字节。以下代码首先比较两个有符号128位整数的高位双字，如果高位四字相等，则再比较它们的低位双字：
- en: '[PRE6]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: To compare unsigned values, use the bhi and blo instructions in place of bgt
    and blt.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 比较无符号值时，使用bhi和blo指令替代bgt和blt。
- en: 'You can synthesize any comparison from the preceding sequence, as shown in
    the following examples that demonstrate signed comparisons; just substitute bhi,
    bhs, blo, and bls for bgt, bge, blt, and ble (respectively) if you want unsigned
    comparisons. Each of the following examples assumes these declarations:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过以下示例合成任何比较操作，这些示例演示了有符号比较；如果你想进行无符号比较，只需将bhi、bhs、blo和bls分别替换为bgt、bge、blt和ble即可。以下每个示例都假设有以下声明：
- en: '[PRE7]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'The following code implements a 128-bit test to see if OW1 < OW2 (signed).
    Control transfers to the IsLess label if OW1 < OW2. Control falls through to the
    next statement (label NotLess) if this is not true:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码实现了一个128位测试，用来判断OW1是否小于OW2（有符号）。如果OW1小于OW2，控制会跳转到IsLess标签。如果条件不成立，控制会继续执行下一个语句（标签NotLess）：
- en: '[PRE8]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Here is a 128-bit test to see if OW1 <= OW2 (signed). This code jumps to IsLessEQ
    if the condition is true:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个128位的测试，用来判断OW1是否小于或等于OW2（有符号）。如果条件成立，代码会跳转到IsLessEQ标签：
- en: '[PRE9]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'This is a 128-bit test to see if OW1 > OW2 (signed). It jumps to IsGtr if this
    condition is true:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个128位的测试，用来判断OW1是否大于OW2（有符号）。如果条件成立，程序将跳转到IsGtr标签：
- en: '[PRE10]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'The following is a 128-bit test to see if OW1 >= OW2 (signed). This code jumps
    to label IsGtrEQ if this is the case:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个128位的测试，用来判断OW1是否大于或等于OW2（有符号）。如果条件成立，代码将跳转到IsGtrEQ标签：
- en: '[PRE11]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Here is a 128-bit test to see if OW1 == OW2 (signed or unsigned). This code
    branches to the label IsEqual if OW1 == OW2. It falls through to the next instruction
    if they are not equal:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个128位的测试，用来判断OW1是否等于OW2（有符号或无符号）。如果OW1等于OW2，代码会跳转到IsEqual标签。如果它们不相等，则会继续执行下一个指令：
- en: '[PRE12]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'The following is a 128-bit test to see if OW1 != OW2 (signed or unsigned).
    This code branches to the label IsNotEqual if OW1 != OW2. It falls through to
    the next instruction if they are equal:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个128位的测试，用来判断OW1是否不等于OW2（有符号或无符号）。如果OW1不等于OW2，代码会跳转到IsNotEqual标签。如果它们相等，则会继续执行下一个指令：
- en: '[PRE13]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'To generalize the preceding code for objects larger than 128 bits, start the
    comparison with the objects’ HO double words and work your way down to their LO
    double words, as long as the corresponding double words are equal. The following
    example compares two 256-bit values to see if the first is less than or equal
    (unsigned) to the second:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 为了将前面的代码推广到大于128位的对象，首先比较对象的高位双字（HO双字），然后逐步向低位双字（LO双字）比较，前提是对应的双字相等。以下示例比较两个256位的值，判断第一个值是否小于或等于（无符号）第二个值：
- en: '[PRE14]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Presumably, there is a branch immediately before the notLE label to skip over
    the code to execute if Big1 > Big2.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 假设，在notLE标签之前有一个分支，用于跳过如果Big1 > Big2时需要执行的代码。
- en: 8.1.4 Multiplication
  id: totrans-61
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 8.1.4 乘法
- en: Although 64 × 64-bit multiplication (or one of the smaller variants) is usually
    sufficient, sometimes you may want to multiply larger values. Use the ARM single-operand
    umul and smul instructions for extended-precision multiplication operations, using
    the same techniques that you employ when manually multiplying two values.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管64 × 64位乘法（或较小的变体）通常足够使用，但有时你可能需要乘以更大的值。使用ARM的单操作数umul和smul指令来执行扩展精度乘法操作，采用手动乘法时相同的技巧。
- en: You likely perform multidigit multiplication by hand using the method shown
    in [Figure 8-3](chapter8.xhtml#fig8-3).
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会使用手动的方法执行多位数乘法，如[图8-3](chapter8.xhtml#fig8-3)所示。
- en: '![](../images/Figure8-3.jpg)'
  id: totrans-64
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/Figure8-3.jpg)'
- en: 'Figure 8-3: Multidigit multiplication'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 图8-3：多位数乘法
- en: The ARM does extended-precision multiplication in the same manner, but with
    words and double words rather than digits, as shown in [Figure 8-4](chapter8.xhtml#fig8-4).
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: ARM以相同的方式执行扩展精度乘法，但使用字和双字而不是数字，如[图8-4](chapter8.xhtml#fig8-4)所示。
- en: '![](../images/Figure8-4.jpg)'
  id: totrans-67
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/Figure8-4.jpg)'
- en: 'Figure 8-4: Extended-precision multiplication'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 图8-4：扩展精度乘法
- en: When performing an extended-precision multiplication, remember that you must
    also perform an extended-precision addition at the same time. Adding up all the
    partial products requires several additions.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 执行扩展精度乘法时，请记住，你还必须同时执行扩展精度加法。将所有部分积相加需要多次加法操作。
- en: 'The umul and smul instructions you’ve seen thus far multiply two *n*-bit operands
    (32 or 64 bits), producing an *n*-bit result, ignoring any overflow. You can’t
    easily use these instructions for multiprecision multiplication operations. Fortunately,
    the ARM CPU provides two sets of extended-precision multiplication instructions
    that will do the job: one set for 32 × 32 multiplications (producing a 64-bit
    result), and a second set for 64 × 64 multiplications (producing a 128-bit result).'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，你所看到的 umul 和 smul 指令将两个 *n* 位操作数（32 位或 64 位）相乘，产生 *n* 位结果，忽略任何溢出。你不能轻易使用这些指令进行多精度乘法运算。幸运的是，ARM
    CPU 提供了两组扩展精度乘法指令，可以完成这项工作：一组用于 32 × 32 乘法（产生 64 位结果），另一组用于 64 × 64 乘法（产生 128
    位结果）。
- en: 'Here are the instructions that produce 64-bit results:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是产生 64 位结果的指令：
- en: '[PRE15]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The smull (signed multiply long) and umull (unsigned multiply long) instructions
    multiply the 32-bit registers to produce a 64-bit result, storing the result in
    the 64-bit destination register. The smnegl and umnegl also multiply two 32-bit
    values but negate the 64-bit result before storing it in the destination register.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: smull（带符号长整型乘法）和 umull（无符号长整型乘法）指令将 32 位寄存器相乘，产生 64 位结果，并将结果存储在 64 位目标寄存器中。smnegl
    和 umnegl 也会将两个 32 位值相乘，但在将 64 位结果存储到目标寄存器之前会对结果取反。
- en: The smaddl/umaddl and smsubl/umsubl instructions multiply their 32-bit operands,
    producing a 64-bit result, then add or subtract a 64-bit register from the result
    before storing the result into the 64-bit destination register. You could use
    the smaddl/umaddl instruction, for example, to multiply C × B and simultaneously
    add in D × A in [Figure 8-4](chapter8.xhtml#fig8-4).
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: smaddl/umaddl 和 smsubl/umsubl 指令将它们的 32 位操作数相乘，产生 64 位结果，然后在将结果存储到 64 位目标寄存器之前，再将一个
    64 位寄存器加或减到结果中。例如，你可以使用 smaddl/umaddl 指令来将 C × B 相乘，并同时加上 D × A，如 [图 8-4](chapter8.xhtml#fig8-4)
    所示。
- en: The 32 × 32 multiplication instructions are less useful than they seem because
    the existing mxxx instructions will accept 64-bit operands (producing a 64-bit
    result). You can easily zero- or sign-extend a 32-bit value into a 64-bit register
    and use the standard multiply instructions to achieve the same result as the long
    multiply instructions.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 32 × 32 乘法指令看似有用，但实际上不如它们看起来那样有用，因为现有的 mxxx 指令将接受 64 位操作数（产生 64 位结果）。你可以轻松地将一个
    32 位值零扩展或符号扩展到 64 位寄存器，并使用标准乘法指令实现与长整型乘法指令相同的结果。
- en: 'You could use the 32-bit long multiply instructions to synthesize larger multiplications
    (for example, a 128-bit multiplication). However, the ARM provides two additional
    instructions that are better suited for this: smulh and umulh (signed and unsigned
    multiply high):'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用 32 位长整型乘法指令来合成更大的乘法（例如，128 位乘法）。然而，ARM 提供了两条更适合此操作的附加指令：smulh 和 umulh（带符号和无符号高位乘法）：
- en: '[PRE16]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'These instructions multiply the two 64-bit source operands and store the HO
    64 bits of the 128-bit result into the destination register. The standard mul
    instruction produces the LO 64 bits of the result, so between the mul and smulh/umulh
    instructions, you can compute the full 128-bit result:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 这些指令将两个 64 位源操作数相乘，并将 128 位结果的高 64 位存储到目标寄存器中。标准的 mul 指令产生结果的低 64 位，因此在 mul
    和 smulh/umulh 指令之间，你可以计算出完整的 128 位结果：
- en: '[PRE17]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: For signed multiplication, simply substitute smulh for umulh.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 对于带符号的乘法，只需将 smulh 替换为 umulh 即可。
- en: To multiply larger values together, you can use the mul, umulh, and smulh instructions
    to implement the algorithm depicted in [Figure 8-4](chapter8.xhtml#fig8-4). Listing
    8-1 demonstrates how to multiply two 128-bit values (producing a 256-bit result)
    by using 64-bit instructions.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 要将更大的值相乘，可以使用 mul、umulh 和 smulh 指令来实现 [图 8-4](chapter8.xhtml#fig8-4) 所示的算法。示例
    8-1 展示了如何使用 64 位指令将两个 128 位值相乘（产生一个 256 位的结果）。
- en: '[PRE18]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: The mul128 procedure ❶ multiplies two 128-bit values passed on the stack (note
    that this is not ARM ABI–compliant). Although X0 through X7 are volatile in the
    ARM ABI, this function is nice and preserves those registers ❷. The code loads
    the two 128-bit values from the stack into the X1:X0 and X3:X2 register pairs
    ❸. The 128-bit multiplication algorithm follows, as described in the program comments.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: mul128 过程❶将堆栈中传递的两个 128 位值相乘（注意这不符合 ARM ABI）。尽管在 ARM ABI 中 X0 到 X7 是易失的，但此函数很好地保存了这些寄存器❷。代码将堆栈中的两个
    128 位值加载到 X1:X0 和 X3:X2 寄存器对❸中。128 位乘法算法如下，程序注释中有详细说明。
- en: The code stores the 256-bit result into the memory location passed to this function
    in the X8 register ❹; then the mul128 function restores the preserved registers
    and returns to the caller. The main program calls mul128 ❺ and displays the result
    (in hexadecimal form) ❻.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 该代码将 256 位的结果存储到通过 X8 寄存器传递给此函数的内存位置❹；然后，mul128 函数恢复保存的寄存器并返回给调用者。主程序调用 mul128
    ❺并显示结果（以十六进制形式）❻。
- en: 'Here’s the build command and output from Listing 8-1:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 这是清单 8-1 的构建命令和输出：
- en: '[PRE19]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: The code works only for unsigned operands. To multiply two signed values, you
    must change the umulh instructions to smulh.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 该代码仅适用于无符号操作数。要乘以两个有符号值，必须将 umulh 指令更改为 smulh。
- en: Listing 8-1 is fairly straightforward because it is possible to keep the partial
    products in various registers. If you need to multiply larger values together,
    you will need to maintain the partial products in temporary (memory) variables.
    Other than that, the algorithm that Listing 8-1 uses generalizes to any number
    of words.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 清单 8-1 相对简单，因为可以将部分积保存在不同的寄存器中。如果需要将更大的值相乘，就需要将部分积保存在临时（内存）变量中。除此之外，清单 8-1 使用的算法可以推广到任何数量的字。
- en: 8.1.5 Division
  id: totrans-89
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 8.1.5 除法
- en: You cannot synthesize a general *n*-bit / *m*-bit division operation by using
    the sdiv and udiv instructions. A generic extended-precision division requires
    a sequence of shift and subtract operations, which takes quite a few instructions
    and runs much slower. This section presents the algorithm for extended-precision
    division.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 你不能使用 sdiv 和 udiv 指令合成通用的 *n* 位 / *m* 位除法操作。通用的扩展精度除法需要一系列移位和减法操作，这需要很多指令并且执行速度较慢。本节介绍了扩展精度除法的算法。
- en: As with multiplication, the best way to understand how the computer performs
    division is to study how you were probably taught to do long division by hand.
    Consider the steps you’d take to manually divide 3,456 by 12, as shown in [Figure
    8-5](chapter8.xhtml#fig8-5).
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 与乘法类似，理解计算机如何执行除法的最佳方法是研究你可能被教导的手工长除法方法。考虑你手动将 3,456 除以 12 的步骤，如[图 8-5](chapter8.xhtml#fig8-5)所示。
- en: '![](../images/Figure8-5.jpg)'
  id: totrans-92
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/Figure8-5.jpg)'
- en: 'Figure 8-5: Manual digit-by-digit division operation'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8-5：手动逐位除法操作
- en: This algorithm is easier in binary because you don’t have to guess at each step
    how many times 12 goes into the remainder, nor do you have to multiply 12 by your
    guess to obtain the amount to subtract. At each step in the binary algorithm,
    the divisor goes into the remainder exactly zero or one times. For example, [Figure
    8-6](chapter8.xhtml#fig8-6) shows how to divide 27 by 3 in binary (that is, dividing
    11011 by 11).
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 在二进制下，算法更容易，因为你不需要在每一步猜测 12 多少次能进入余数，也不需要将 12 乘以你的猜测来得到要减去的数值。在二进制算法的每一步，除数要么将余数整除一次，要么完全不能整除。例如，[图
    8-6](chapter8.xhtml#fig8-6) 展示了如何用二进制将 27 除以 3（即将 11011 除以 11）。
- en: '![](../images/Figure8-6.jpg)'
  id: totrans-95
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/Figure8-6.jpg)'
- en: 'Figure 8-6: Longhand division in binary'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8-6：二进制的长除法
- en: 'The following algorithm implements this binary division operation in a way
    that computes the quotient and the remainder at the same time:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 以下算法以一种同时计算商和余数的方式实现了二进制除法操作：
- en: '[PRE20]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: NumberBits is the number of bits in the Remainder, Quotient, Divisor, and Dividend
    variables. LSL is the shift-left operator. The statement Quotient := Quotient
    + 1; sets the LO bit of Quotient to 1 because this algorithm previously shifted
    Quotient 1 bit to the left. Listing 8-2 implements this algorithm.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: NumberBits 是余数、商、除数和被除数变量中的位数。LSL 是左移操作符。语句 Quotient := Quotient + 1; 将商的最低有效位（LO
    bit）设置为 1，因为该算法之前将商左移了 1 位。清单 8-2 实现了这个算法。
- en: '[PRE21]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: The div128 function ❶ is a 128 × 128-bit division operation that simultaneously
    produces the quotient and the remainder. Unlike the extended-precision multiplication
    given earlier, this function passes its arguments by reference (in X0 and X1)
    rather than by value on the stack. It stores the 128-bit quotient in the location
    pointed at by X8 and the remainder in the location pointed at by X9\. As in the
    multiplication code, the div128 function ❷ preserves all the volatile registers
    it modifies.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: div128 函数 ❶ 是一个 128 × 128 位的除法操作，它同时生成商和余数。与之前给出的扩展精度乘法不同，这个函数通过引用传递其参数（在 X0
    和 X1 中），而不是通过栈上的值。它将 128 位的商存储在 X8 指向的位置，将余数存储在 X9 指向的位置。与乘法代码一样，div128 函数 ❷ 会保存它修改的所有易失性寄存器。
- en: Next is the division algorithm ❸, as described in the program comments. The
    code stores the quotient and remainder away ❹ and then restores the preserved
    registers ❺. The main program ❻ demonstrates the div128 function with a pair of
    calls, along with the code to display the results.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来是除法算法 ❸，如程序注释中所描述的。代码将商和余数存储起来 ❹，然后恢复已保存的寄存器 ❺。主程序 ❻ 通过一对调用来演示 div128 函数，并包含显示结果的代码。
- en: 'Here’s the build command and program output:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是构建命令和程序输出：
- en: '[PRE22]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: This code does not check for division by 0 (it will produce the quotient 0xFFFF_FFFF_FFFF_FFFF
    if you attempt to divide by 0). It handles only unsigned values and is very slow,
    a couple of orders of magnitude worse than the sdiv/udiv instructions. To handle
    division by 0, check the divisor against 0 prior to running this code and return
    an appropriate error code if the divisor is 0\. To deal with signed values, note
    the signs, take the operands’ absolute values, do the unsigned division, and then
    fix the sign afterward by setting the result negative if the operand signs were
    different.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 该代码未检查除以 0 的情况（如果尝试除以 0，它会产生商 0xFFFF_FFFF_FFFF_FFFF）。它仅处理无符号值，并且非常慢，比 sdiv/udiv
    指令差几个数量级。为了处理除以 0 的情况，在执行此代码之前请检查除数是否为 0，并在除数为 0 时返回适当的错误代码。处理有符号值时，请注意符号，取操作数的绝对值，执行无符号除法，然后通过设置结果为负值来修正符号（如果操作数符号不同）。
- en: 8.1.6 Negation
  id: totrans-106
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 8.1.6 取反
- en: The neg instruction doesn’t provide a generic extended-precision form. However,
    a negation is equivalent to subtracting a value from 0, so you can easily simulate
    an extended-precision negation by using the subs and sbcs instructions.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: neg 指令没有提供通用的扩展精度形式。然而，取反等同于从 0 中减去一个值，因此可以通过使用 subs 和 sbcs 指令轻松模拟扩展精度的取反。
- en: 'The following code provides a simple way to negate a (320-bit) value by subtracting
    that value from 0, using an extended-precision subtraction:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码提供了一种简单的方法，通过从 0 中减去一个值来取反（320 位值），使用扩展精度减法：
- en: '[PRE23]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: You can extend this algorithm to any number of bits (or reduce it to fewer bits)
    by using the scheme I presented for extended-precision subtraction.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过使用我为扩展精度减法提供的方案，将此算法扩展到任意数量的位（或缩减为更少的位）。
- en: 8.1.7 AND
  id: totrans-111
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 8.1.7 AND
- en: 'Performing an *n*-byte AND operation is easy: simply AND the corresponding
    bytes between the two operands, saving the result. For example, to perform the
    AND operation with all operands 128 bits long, you could use the following code:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 执行 *n* 字节的 AND 操作很简单：只需对两个操作数之间的相应字节进行 AND 运算，并保存结果。例如，要对所有 128 位长的操作数执行 AND
    操作，可以使用以下代码：
- en: '[PRE24]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: To extend this technique to any number of dwords, logically AND the corresponding
    dwords together in the operands.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 要将此技术扩展到任意数量的双字（dword），在操作数中对相应的双字执行逻辑与操作（AND）。
- en: 'When testing the flags after an AND sequence, remember that the ands instruction
    will set the flags only for that particular portion of the AND sequence. If you
    convert the last and to an ands instruction, it will properly set the N flag but
    will not properly set the Z flag. To set the Z flag (indicating a 0 result for
    the entire 128 bits), you can use ccmp (conditional compare) to test the Z flag
    from the ands instruction and compare X2 with 0 (see section 6.1.4, “Conditional
    Instructions,” on [page 297](chapter6.xhtml#pg_297)):'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 在执行 AND 序列后测试标志时，请记住，and 指令只会为 AND 序列中的特定部分设置标志。如果将最后一个 and 转换为 ands 指令，它会正确设置
    N 标志，但不会正确设置 Z 标志。要设置 Z 标志（表示整个 128 位结果为 0），可以使用 ccmp（条件比较）指令来测试 ands 指令中的 Z 标志，并将
    X2 与 0 进行比较（请参见第 6.1.4 节“条件指令”，在[第 297 页](chapter6.xhtml#pg_297)）：
- en: '[PRE25]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: If you need to test both the N and Z flags after this sequence, consider using
    the tbz/tbnz instructions to test the HO bit of register X3, which contains the
    sign bit.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在这个序列后你需要测试N标志和Z标志，可以考虑使用tbz/tbnz指令来测试寄存器X3中的HO位，它包含符号位。
- en: 8.1.8 OR
  id: totrans-118
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 8.1.8 或运算
- en: 'Multibyte logical OR operations are performed in the same way as multibyte
    AND operations: you OR the corresponding bytes in the two operands together. For
    example, to logically OR two 256-bit values, use the following code:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 多字节的逻辑或操作与多字节的与操作执行方式相同：你将两个操作数中对应的字节进行或运算。例如，要对两个256位的值进行逻辑或操作，可以使用以下代码：
- en: '[PRE26]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Remember that the orr instruction does not affect any flags (and there is no
    orrs instruction). If you need to test the zero flag after an extended-precision
    OR, you must compare all the resulting double words to 0.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，orr指令不会影响任何标志（并且没有orrs指令）。如果你需要在扩展精度的或操作后测试零标志，必须将所有结果双字与0进行比较。
- en: You can also use the V*n* registers to perform extended-precision logical operations,
    up to 128 bits at a time. See section 11.13, “Use of SIMD Instructions in Real
    Programs,” on [page 699](chapter11.xhtml#pg_699) for more details.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以使用V*n*寄存器执行扩展精度的逻辑操作，最多一次处理128位。有关更多详细信息，请参阅第11.13节“在实际程序中使用SIMD指令”，见[第699页](chapter11.xhtml#pg_699)。
- en: 8.1.9 XOR
  id: totrans-123
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 8.1.9 异或
- en: 'As with other logical operations, extended-precision XOR operations will XOR
    the corresponding bytes in the two operands to obtain the extended-precision result.
    The following code sequence operates on two 128-bit operands, computes their exclusive-OR,
    and stores the result into a 128-bit variable:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 与其他逻辑操作一样，扩展精度的XOR操作会对两个操作数中对应的字节进行异或运算，得到扩展精度的结果。以下代码序列作用于两个128位的操作数，计算它们的异或，并将结果存储到一个128位的变量中：
- en: '[PRE27]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: The comment about the zero flag in the previous section applies here, as well
    as the comment about V*n* registers.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 前一节中关于零标志的评论也适用于这里，以及关于V*n*寄存器的评论。
- en: 8.1.10 NOT
  id: totrans-127
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 8.1.10 非操作
- en: 'The mvn instruction inverts all the bits in the specified operand. Perform
    an extended-precision NOT by executing the mvn instruction on all the affected
    operands. For example, to perform a 128-bit NOT operation on the value in X1:X0,
    execute the following instructions:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: mvn指令会反转指定操作数的所有位。通过在所有受影响的操作数上执行mvn指令，执行扩展精度的NOT操作。例如，要对X1:X0中的值执行128位的NOT操作，可以执行以下指令：
- en: '[PRE28]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: If you execute the mvn instruction twice, you wind up with the original value.
    Also, exclusive-ORing a value with all 1s (such as 0xFF, 0xFFFF, 0xFFFF_FFFF,
    or 0xFFFF_FFFF_FFFF_FFFF) performs the same operation as the mvn instruction.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你执行两次mvn指令，你会得到原始值。同样，用所有1的值（例如0xFF、0xFFFF、0xFFFF_FFFF或0xFFFF_FFFF_FFFF_FFFF）对某个值进行异或运算，效果与mvn指令相同。
- en: 8.1.11 Shift Operations
  id: totrans-131
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 8.1.11 移位操作
- en: Extended-precision shift operations on the ARM are somewhat problematic. Traditionally,
    the way you accomplish an extended-precision shift is to shift a bit out of one
    register into the carry flag, then rotate that carry bit into another register.
    Unfortunately, the ARM doesn’t provide such instructions, so a different approach
    is necessary.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: ARM上的扩展精度移位操作存在一些问题。传统上，实现扩展精度移位的方法是将一个位从一个寄存器移到进位标志中，然后将该进位位旋转到另一个寄存器中。不幸的是，ARM没有提供这样的指令，因此需要采用不同的方法。
- en: 'The exact approach depends on two things, as described in the following subsections:
    the number of bits to shift and the direction of the shift.'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 具体的实现方法取决于以下两个因素，详见下面的子章节：需要移位的位数和移位的方向。
- en: 8.1.11.1 Shift Left
  id: totrans-134
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 8.1.11.1 左移
- en: A 128-bit lsl (logical shift left) takes the form shown in [Figure 8-7](chapter8.xhtml#fig8-7).
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 128位的lsl（逻辑左移）呈现出[图8-7](chapter8.xhtml#fig8-7)所示的形式。
- en: '![](../images/Figure8-7.jpg)'
  id: totrans-136
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/Figure8-7.jpg)'
- en: 'Figure 8-7: The 128-bit shift-left operation'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 图8-7：128位左移操作
- en: To accomplish this with machine instructions, you must first shift the LO dword
    to the left (for example, using the lsls instruction) and capture the output from
    bit 63 (conveniently, the carry flag does this for us). Next, shift this bit into
    the LO bit of the HO dword while simultaneously shifting all the other bits to
    the left (and capturing the output by using the carry flag). No instruction specifically
    rotates the carry flag into a register, but you can use the magic instruction
    adc/adcs to do this if you supply appropriate operands.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使用机器指令实现这一操作，你必须首先将 LO 双字左移（例如，使用 lsls 指令），并从第 63 位捕获输出（幸运的是，进位标志会为我们做到这一点）。接着，将该位移入
    HO 双字的 LO 位，同时将所有其他位左移（并通过进位标志捕获输出）。没有指令专门将进位标志旋转到寄存器中，但你可以使用神奇的指令 adc/adcs 来实现此功能，只要你提供适当的操作数。
- en: 'Remember, a shift left is the same thing as a multiplication by 2\. Adding
    a value to itself is the very definition of a multiplication by 2\. Therefore,
    the lsls and adds instructions can both shift an operand to the left, moving the
    overflow bit into the carry flag. In order for adds to behave like a shift-left
    operation, you must supply the same operand in both source positions:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，左移操作等同于乘以 2。将一个值加到它自身上，正是乘以 2 的定义。因此，lsls 和 adds 指令都可以将操作数左移，并将溢出位移入进位标志。为了让
    adds 像左移操作一样工作，你必须在两个源操作数位置提供相同的操作数：
- en: '[PRE29]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: The adcs instruction (with the same operands) will also shift all the bits to
    the left one position and shift the carry flag into bit 0 (as well as shift the
    HO bit into the carry flag at the end of the operation). This is, effectively,
    a single-bit *rotate-through-carry-left* operation, as illustrated in [Figure
    8-8](chapter8.xhtml#fig8-8).
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: adcs 指令（使用相同的操作数）也将所有位左移一个位置，并将进位标志移入第 0 位（同时将 HO 位移入进位标志，操作结束时如此）。这实际上是一个单比特的*进位左旋操作*，如[图
    8-8](chapter8.xhtml#fig8-8)所示。
- en: '![](../images/Figure8-8.jpg)'
  id: totrans-142
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/Figure8-8.jpg)'
- en: 'Figure 8-8: The rotate-through-carry-left operation'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8-8：通过进位左旋操作
- en: 'You can use the adds and adcs instructions to implement a 128-bit shift. For
    example, to shift the 128-bit quantity in X1:X0 one position to the left, use
    the following instructions:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用 adds 和 adcs 指令实现 128 位的左移。例如，要将 X1:X0 中的 128 位数据左移一位，可以使用以下指令：
- en: '[PRE30]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: The adds instruction shifts a 0 into bit 0 of the 128-bit operand and shifts
    bit 63 into the carry flag. The adcs instruction then shifts the carry flag into
    bit 64 and shifts bit 127 into the carry flag, giving you exactly the result you
    want, as shown in [Figure 8-9](chapter8.xhtml#fig8-9).
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: adds 指令将 0 移入 128 位操作数的第 0 位，并将第 63 位移入进位标志。接着，adcs 指令将进位标志移入第 64 位，并将第 127
    位移入进位标志，从而得到你想要的结果，如[图 8-9](chapter8.xhtml#fig8-9)所示。
- en: '![](../images/Figure8-9.jpg)'
  id: totrans-147
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/Figure8-9.jpg)'
- en: 'Figure 8-9: Extended-precision shift left using adds/adcs'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8-9：使用 adds/adcs 指令进行扩展精度左移
- en: Using this technique, you can shift an extended-precision value only 1 bit at
    a time. You cannot shift an extended-precision operand several bits by using a
    register, nor can you specify a constant value greater than 1 when using this
    technique.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这种技巧，你只能一次性将扩展精度值左移 1 位。你无法通过寄存器将扩展精度操作数左移多个比特，也无法在使用此技术时指定大于 1 的常量值。
- en: 'To perform a shift left on an operand larger than 128 bits, use additional
    adcs instructions. An extended-precision shift-left operation always starts with
    the least-significant double word, and each succeeding adcs instruction operates
    on the next-most-significant double word. For example, to perform a 192-bit shift-left
    operation on a memory location, you could use the following instructions:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 要对大于 128 位的操作数进行左移，使用额外的 adcs 指令。扩展精度左移操作总是从最低有效双字开始，每个随后的 adcs 指令操作下一个更高位的双字。例如，要对一个内存位置执行
    192 位的左移操作，你可以使用以下指令：
- en: '[PRE31]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'If you need to shift your data by 2 or more bits, you can either repeat the
    preceding sequence the desired number of times for a constant number of shifts
    or place the instructions in a loop to repeat them a certain number of times.
    For example, the following code shifts the 192-bit value in X0, X1, and X2 to
    the left by the number of bits specified in W3:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你需要将数据左移 2 位或更多位，可以重复前面的指令序列以实现固定次数的左移，或者将这些指令放入循环中，以便按需重复执行。例如，以下代码将 X0、X1
    和 X2 中的 192 位值左移 W3 中指定的位数：
- en: '[PRE32]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: The only problem with this multibit shift is that it can run rather slowly when
    shifting more than a few bits to the left. In general, we say that this algorithm
    is O(n), meaning the runtime is proportional to the number of bits we shift to
    the left.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 这个多位移位的唯一问题是，当移位超过几个位时，它可能会运行得比较慢。通常，我们说这个算法是 O(n)，意味着运行时间与我们左移的位数成正比。
- en: 'An instruction to shift multiple bits simultaneously, as the lsl instruction
    can do, would help solve this problem. If a rol instruction existed, you could
    use it to shift the 128 bits in X1:X0 to the left 8 bits:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 一条可以同时移位多个位的指令，就像 lsl 指令那样，将有助于解决这个问题。如果存在 rol 指令，你可以用它将 X1:X0 中的 128 位值向左移
    8 位：
- en: '[PRE33]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Unfortunately, the ARM CPU’s instruction set has no rol instruction; however,
    you can use the ror instruction to do anything a rol instruction would do. For
    any bit shift that occurs in the range 1–63, rol(n) is equivalent to ror((64 -
    n) % 64), where rox(n) means “rotate left/right *n* bits.” For the special case
    of rol(0), ror(0) ((64 - 0) % 64) is 0) will also rotate the value 0 bits. Therefore,
    you can replace the previous noncompiling code with this:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，ARM CPU 的指令集没有 rol 指令；不过，你可以使用 ror 指令来做任何 rol 指令可以做的事。对于范围在 1–63 之间的任何位移，rol(n)
    等同于 ror((64 - n) % 64)，其中 rox(n) 意味着“将值左/右旋转 *n* 位”。对于 rol(0) 的特殊情况，ror(0) ((64
    - 0) % 64) 是 0，也会将值旋转 0 位。因此，你可以用这个来替换之前的无法编译代码：
- en: '[PRE34]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: When *n* is greater than 2 or 3, this sequence will execute much faster than
    the adds/adcs loop given earlier.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 当 *n* 大于 2 或 3 时，这个序列的执行速度比之前给出的 adds/adcs 循环要快得多。
- en: '[Figures 8-10](chapter8.xhtml#fig8-10) through [8-14](chapter8.xhtml#fig8-14)
    show the operations for this extended-precision shift left.'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 8-10](chapter8.xhtml#fig8-10) 到 [图 8-14](chapter8.xhtml#fig8-14) 显示了此扩展精度左移操作的过程。'
- en: '![](../images/Figure8-10.jpg)'
  id: totrans-161
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/Figure8-10.jpg)'
- en: 'Figure 8-10: Extended-precision shift left using ror, before the shift'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8-10：使用 ror 进行的扩展精度左移，移位前
- en: In [Figure 8-11](chapter8.xhtml#fig8-11), the algorithm makes a temporary copy
    of bits 0 to 63 and rotates the value to the left by 8 bits.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [图 8-11](chapter8.xhtml#fig8-11) 中，算法会临时复制从第 0 位到第 63 位的位并将值左移 8 位。
- en: '![](../images/Figure8-11.jpg)'
  id: totrans-164
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/Figure8-11.jpg)'
- en: 'Figure 8-11: Step 1: Making a temporary copy and shifting bits'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8-11：步骤 1：制作临时副本并移位
- en: '[Figure 8-12](chapter8.xhtml#fig8-12) shows shifting the original value to
    the left 8 bits (which clears the LO bits) and clearing the HO temporary bits
    (via an AND operation).'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 8-12](chapter8.xhtml#fig8-12) 显示了将原始值左移 8 位（这会清除 LO 位）并通过与操作清除 HO 临时位。'
- en: '![](../images/Figure8-12.jpg)'
  id: totrans-167
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/Figure8-12.jpg)'
- en: 'Figure 8-12: Step 2: Shifting and clearing bits'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8-12：步骤 2：移位并清除位
- en: '[Figure 8-13](chapter8.xhtml#fig8-13) shows the merging of the temporary and
    HO dwords (OR operation).'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 8-13](chapter8.xhtml#fig8-13) 显示了临时 dword 和 HO dword 的合并（或操作）。'
- en: '![](../images/Figure8-13.jpg)'
  id: totrans-170
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/Figure8-13.jpg)'
- en: 'Figure 8-13: Step 3: Merging the temporary and HO dwords'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8-13：步骤 3：合并临时和 HO dword
- en: '[Figure 8-14](chapter8.xhtml#fig8-14) shows the result after the shift.'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 8-14](chapter8.xhtml#fig8-14) 显示了移位后的结果。'
- en: '![](../images/Figure8-14.jpg)'
  id: totrans-173
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/Figure8-14.jpg)'
- en: 'Figure 8-14: Step 4: After the shift'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8-14：步骤 4：移位后
- en: 'To implement a variable extended-precision shift-left operation, the code needs
    to generate a bitmask to clear the LO bits (the and instructions in the previous
    code). As it turns out, you can generate the mask for an *n*-bit shift by using
    the following code:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 要实现一个可变的扩展精度左移操作，代码需要生成一个位掩码来清除 LO 位（之前代码中的 and 指令）。事实证明，你可以通过以下代码生成一个 *n* 位移的掩码：
- en: '[PRE35]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'The trick here is that lsl(n) produces 2*^n*. Then, 2*^n* – 1 is all 1 bits
    from bit 0 to position *n* – 1.  ##### 8.1.11.2 Shift Right and Arithmetic Shift
    Right'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: '这里的技巧是 lsl(n) 生成 2*^n*，然后，2*^n* - 1 是从第 0 位到第 *n* - 1 位的全 1 位。 ##### 8.1.11.2 右移和算术右移'
- en: 'Unfortunately, no trick like using the adds/adcs instructions allows you to
    perform a *rotate through carry right* operation (shifting all the bits right
    through the carry, and shifting the original carry back into the HO bit). Therefore,
    to do an extended-precision shift right (or arithmetic shift right), you must
    use the ror instruction again. Here’s an example that shifts a 128-bit value in
    X1:X0 to the right 8 bits:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，像使用 adds/adcs 指令的技巧并不能让你执行 *通过进位右旋* 操作（将所有位通过进位向右移，并将原始进位重新移入 HO 位）。因此，要执行扩展精度右移（或算术右移），你必须再次使用
    ror 指令。以下是一个示例，将 128 位值从 X1:X0 右移 8 位：
- en: '[PRE36]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'The code for the extended-precision arithmetic shift-right operation is similar:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 该扩展精度的算术右移操作的代码类似：
- en: '[PRE37]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: In this case, you substitute an asr instruction for the lsr on the HO dword.
    Note that you continue to use a lsr instruction on the LO dword; lsr is necessary
    to shift 0s into the HO bits so that the orr instruction properly merges the bits
    shifted out of the HO dword.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，你将asr指令替换了HO双字上的lsr指令。请注意，LO双字仍然使用lsr指令；lsr是必要的，它将0填充到HO位，以便orr指令能够正确合并从HO双字移出的位。
- en: 'As a last example, here’s a 192-bit arithmetic shift right that shifts the
    bits in X2:X1:X0 to the right 4 bits:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 作为最后一个例子，以下是一个192位的算术右移操作，将X2:X1:X0中的位向右移动4位：
- en: '[PRE38]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: The Neon instructions allow you to shift 128-bit values left and right; see
    [Chapter 11](chapter11.xhtml) for details.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: Neon指令允许你将128位值左右移动；详细信息请参见[第11章](chapter11.xhtml)。
- en: 8.2 Operating on Different-Size Operands
  id: totrans-186
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 8.2 对不同大小操作数的操作
- en: Occasionally, you may need to do a computation on a pair of operands that are
    not the same size (*mixed-size*, or *mixed-mode*, arithmetic). For example, you
    may need to add a word and a double word together or subtract a byte value from
    a word value. To do so, extend the smaller operand to the size of the larger operand,
    then operate on two same-size operands. For signed operands, sign-extend the smaller
    operand to the same size as the larger operand; for unsigned values, zero-extend
    the smaller operand. This works for any operation.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，你可能需要对一对不同大小的操作数进行计算（*混合大小*或*混合模式*算术运算）。例如，你可能需要将一个字与一个双字相加，或者从一个字值中减去一个字节值。为了做到这一点，将较小的操作数扩展到较大操作数的大小，然后对两个相同大小的操作数进行操作。对于符号操作数，将较小的操作数符号扩展到与较大操作数相同的大小；对于无符号值，将较小的操作数零扩展。这适用于任何运算。
- en: 'The following examples demonstrate adding a byte variable, a half-word variable,
    and a dword variable:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 以下例子演示了字节变量、半字变量和双字变量的加法操作：
- en: '[PRE39]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: In both cases, the byte variable is loaded into the W0 register, extended to
    32 bits, and then added with the half-word operand (also extended to 32 bits).
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 在这两种情况下，字节变量被加载到W0寄存器中，扩展为32位，然后与半字操作数相加（半字操作数也扩展为32位）。
- en: All these examples add a byte value to a half-word value. By zero- or sign-extending
    the operands to the same size, you can easily add any two different-size variables
    together.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些例子都是将字节值与半字值相加。通过将操作数零扩展或符号扩展为相同的大小，你可以轻松地将任何两个不同大小的变量相加。
- en: 'As a last example, consider adding an 8-bit signed value to a qword (128-bit)
    value:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 作为最后一个例子，考虑将一个8位的符号值加到一个qword（128位）值上：
- en: '[PRE40]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: The trick in this code is the asr instruction. This instruction sign-extends
    X0 into X1:X0 by copying the sign bit in X0 throughout X1 (an arithmetic shift
    right by 63 bits effectively copies bit 63 into bits 0–62). Once X0 has been sign-extended
    into X1, you have a 128-bit value in X1:X0 that you can add to the 128-bit value
    in variable var3.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 该代码中的技巧是asr指令。此指令通过将X0中的符号位复制到X1中，从而将X0符号扩展到X1:X0（算术右移63位实际上将位63复制到位0–62）。一旦X0已被符号扩展到X1，你就拥有了一个128位的值X1:X0，可以将其与变量var3中的128位值相加。
- en: The previous examples in this chapter assumed that the different-size operands
    were memory variables. They used the ldrb/ldrsb and ldrh/ldrsh instructions to
    zero- and sign-extend 8- and 16-bit operands to 32 bits (which could also extend
    their operands to 64 bits by supplying a 64-bit register). Although these examples
    did not demonstrate mixing 32- and 64-bit operands, you could also have used the
    ldrsw instruction to sign-extend 32 bits to 64.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 本章前面的例子假设不同大小的操作数是内存变量。它们使用了ldrb/ldrsb和ldrh/ldrsh指令将8位和16位操作数零扩展或符号扩展为32位（也可以通过提供64位寄存器将操作数扩展到64位）。虽然这些例子没有演示32位和64位操作数的混合使用，但你也可以使用ldrsw指令将32位符号扩展为64位。
- en: 'If your operands are already in registers (not memory), you can use the uxtb/uxth/uxtw
    and sxtb/sxth/sxtw instructions to zero- or sign-extend the operands. For example,
    the following code sign-extends the 32-bit value in W0 to 128 bits:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你的操作数已经在寄存器中（而不是内存中），你可以使用uxtb/uxth/uxtw和sxtb/sxth/sxtw指令来零扩展或符号扩展操作数。例如，以下代码将W0中的32位值符号扩展到128位：
- en: '[PRE41]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'When adding smaller values to 32- or 64-bit registers that don’t require sign-extending
    the smaller value to 128 bits or more, you can use the sign-extension modifiers
    for Operand2 in arithmetic instructions to zero- and sign-extend the smaller values
    to the larger size:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 当将较小的值加到32位或64位寄存器中，而不需要将较小的值符号扩展到128位或更高时，你可以在算术指令中使用操作数2的符号扩展修饰符，将较小的值零扩展或符号扩展到较大的大小：
- en: '[PRE42]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: To add bytes and half words to 64-bit dwords, just change the W1 registers to
    X1 in this code.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 要将字节和半字添加到64位双字中，只需在此代码中将 W1 寄存器改为 X1。
- en: 8.3 Moving On
  id: totrans-201
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 8.3 继续前进
- en: Extended-precision arithmetic is difficult or impossible in HLLs but is fairly
    easy in assembly language. This chapter described the extended-precision arithmetic,
    comparison, and logical operations in ARM assembly language. It concluded by discussing
    mixed-mode (mixed-size) arithmetic, where the operands have differing sizes.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 扩展精度算术在高级语言（HLLs）中是困难的，甚至是无法实现的，但在汇编语言中相对容易。本章描述了 ARM 汇编语言中的扩展精度算术、比较和逻辑运算。最后讨论了混合模式（混合大小）算术，其中操作数的大小不同。
- en: Armed with the information from this chapter, it’s easy to handle arithmetic
    and logical operations that are difficult to achieve in most HLLs. The next chapter,
    which covers numeric-to-string conversions, will use these extended-precision
    operations when converting values larger than 64 bits.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 拥有本章提供的信息后，处理大多数高级语言中难以实现的算术和逻辑操作变得轻松。下一章将介绍数值到字符串的转换，当转换大于64位的值时，将使用这些扩展精度操作。
- en: 8.4 For More Information
  id: totrans-204
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 8.4 更多信息
- en: 'One arithmetic feature missing from the ARM instruction set is *decimal arithmetic*
    (base-10), meaning if the need arises, you’ll have to perform that arithmetic
    in software. Though most of the code is in C, visit the General Decimal Arithmetic
    site if you want to implement decimal arithmetic: *[https://<wbr>speleotrove<wbr>.com<wbr>/decimal<wbr>/](https://speleotrove.com/decimal/)*.'
  id: totrans-205
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: ARM 指令集缺少的一个算术特性是*十进制算术*（基数10），这意味着如果需要，你必须在软件中执行该算术操作。尽管大部分代码是用 C 编写的，但如果你想实现十进制算术，请访问[十进制算术网站](https://speleotrove.com/decimal/)。
- en: 'Donald Knuth’s *The Art of Computer Programming, Volume 2: Seminumerical Algorithms*
    (Addison-Wesley Professional, 1997) contains lots of useful information about
    decimal arithmetic and extended-precision arithmetic, though the text is generic
    and describes how to do this in MIXAL assembly language rather than ARM assembly
    language.'
  id: totrans-206
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 唐纳德·克努斯的*《计算机程序设计的艺术，第2卷：半数值算法》*（Addison-Wesley Professional，1997年）包含了关于十进制算术和扩展精度算术的许多有用信息，尽管该书内容较为通用，描述的是如何在
    MIXAL 汇编语言中实现这些操作，而非 ARM 汇编语言。
