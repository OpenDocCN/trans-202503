- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">6</samp> <samp class="SANS_Dogma_OT_Bold_B_11">FILESYSTEM
    MINIFILTER DRIVERS</samp>
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">6</samp> <samp class="SANS_Dogma_OT_Bold_B_11">文件系统小型过滤驱动程序</samp>
- en: '![](../images/opener-img.png)'
  id: totrans-1
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/opener-img.png)'
- en: 'While the drivers covered in previous chapters can monitor many important events
    on the system, they aren’t able to detect a particularly critical kind of activity:
    filesystem operations. Using filesystem minifilter drivers, or *minifilters* for
    short, endpoint security products can learn about the files being created, modified,
    written to, and deleted.'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然前几章介绍的驱动程序可以监控系统上的许多重要事件，但它们无法检测到一种特别关键的活动类型：文件系统操作。通过使用文件系统小型过滤驱动程序，或简称*小型过滤器*，终端安全产品可以了解文件的创建、修改、写入和删除情况。
- en: These drivers are useful because they can observe an attacker’s interactions
    with the filesystem, such as the dropping of malware to disk. Often, they work
    in conjunction with other components of the system. By integrating with the agent’s
    scanning engine, for example, they can enable the EDR to scan files.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 这些驱动程序非常有用，因为它们可以观察攻击者与文件系统的交互，例如将恶意软件写入磁盘。通常，它们与系统的其他组件协同工作。例如，通过与代理扫描引擎的集成，它们可以使EDR扫描文件。
- en: Minifilters might, of course, monitor the native Windows filesystem, which is
    called the New Technology File System (NTFS) and is implemented in *ntfs.sys*.
    However, they might also monitor other important filesystems, including named
    pipes, a bidirectional inter-process communication mechanism implemented in *npfs.sys*,
    and mailslots, a unidirectional inter-process communication mechanism implemented
    in *msfs.sys*. Adversary tools, particularly command-and-control agents, tend
    to make heavy use of these mechanisms, so tracking their activities provides crucial
    telemetry. For example, Cobalt Strike’s Beacon uses named pipes for tasking and
    the linking of peer-to-peer agents.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 小型过滤器当然可以监控本地Windows文件系统，即被称为新技术文件系统（NTFS），并由*ntfs.sys*实现。然而，它们也可以监控其他重要的文件系统，包括命名管道，这是一种双向进程间通信机制，由*npfs.sys*实现，以及邮件槽，这是一种单向进程间通信机制，由*msfs.sys*实现。对手工具，特别是指挥与控制代理，往往大量使用这些机制，因此跟踪其活动提供了至关重要的遥测数据。例如，Cobalt
    Strike的Beacon使用命名管道进行任务分配和点对点代理的链接。
- en: Minifilters are similar in design to the drivers discussed in the previous chapters,
    but this chapter covers some unique details about their implementations, capabilities,
    and operations on Windows. We’ll also discuss evasion techniques that attackers
    can leverage to interfere with them.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 小型过滤器的设计与前几章讨论的驱动程序类似，但本章将介绍它们在Windows上的实现、能力和操作的一些独特细节。我们还将讨论攻击者可能利用的规避技术，以干扰这些过滤器。
- en: <samp class="SANS_Futura_Std_Bold_B_11">Legacy Filters and the Filter Manager</samp>
  id: totrans-6
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">遗留过滤器与过滤器管理器</samp>
- en: Before Microsoft introduced minifilters, EDR developers would write legacy filter
    drivers to monitor filesystem operations. These drivers would sit on the filesystem
    stack, directly inline of user-mode calls destined for the filesystem, as shown
    in [Figure 6-1](#fig6-1).
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 在微软引入小型过滤器之前，EDR开发人员会编写遗留过滤器驱动程序来监控文件系统操作。这些驱动程序会直接位于文件系统堆栈上，紧跟在面向文件系统的用户模式调用之前，如[图6-1](#fig6-1)所示。
- en: '![](../images/Figure6-1.png)'
  id: totrans-8
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/Figure6-1.png)'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 6-1: The legacy filter
    driver architecture</samp>'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">图6-1：遗留过滤器驱动程序架构</samp>
- en: 'These drivers were notoriously difficult to develop and support in production
    environments. A 2019 article published in *The NT Insider*, titled “Understanding
    Minifilters: Why and How File System Filter Drivers Evolved,” highlights seven
    large problems that developers face when writing legacy filter drivers:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 这些驱动程序因开发和在生产环境中的支持而广为人知，难度很大。2019年发布的一篇名为《理解小型过滤器：文件系统过滤驱动程序为何以及如何发展》的文章（发表于*The
    NT Insider*）突出了开发者在编写遗留过滤器驱动程序时面临的七大难题：
- en: '**Confusing Filter Layering**'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: '**过滤器层次结构混乱**'
- en: In cases when there is more than one legacy filter installed on the system,
    the architecture defines no order for how these drivers should be placed on the
    filesystem stack. This prevents the driver developer from knowing when the system
    will load their driver in relation to the others.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在系统上安装多个遗留过滤器的情况下，架构并未定义这些驱动程序应如何在文件系统堆栈中排序。这使得驱动程序开发者无法知道系统何时加载他们的驱动程序与其他驱动程序的相对顺序。
- en: '**A Lack of Dynamic Loading and Unloading**'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: '**缺乏动态加载和卸载功能**'
- en: Legacy filter drivers can’t be inserted into a specific location on the device
    stack and can only be loaded at the top of the stack. Additionally, legacy filters
    can’t be unloaded easily and typically require a full system reboot to unload.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 传统过滤驱动程序无法插入到设备堆栈的特定位置，只能加载到堆栈的顶部。此外，传统过滤驱动程序不能轻松卸载，通常需要完全重启系统才能卸载。
- en: '**Tricky Filesystem-Stack Attachment and Detachment**'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: '**复杂的文件系统堆栈附加与分离**'
- en: The mechanics of how the filesystem stack attaches and detaches devices are
    extremely complicated, and developers must have a substantial amount of arcane
    knowledge to ensure that their driver can appropriately handle odd edge cases.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 文件系统堆栈如何附加和分离设备的机制极为复杂，开发者必须拥有大量深奥的知识，才能确保他们的驱动程序能够恰当地处理各种边缘情况。
- en: '**Indiscriminate IRP Processing**'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: '**无差别的 IRP 处理**'
- en: Legacy filter drivers are responsible for processing *all* Interrupt Request
    Packets (IRPs) sent to the device stack, regardless of whether they are interested
    in the IRPs or not.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 传统过滤驱动程序负责处理发送到设备堆栈的*所有*中断请求包（IRP），无论它们是否对 IRP 感兴趣。
- en: '**Challenges with Fast I/O Data Operations**'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: '**快速 I/O 数据操作的挑战**'
- en: Windows supports a mechanism for working with cached files, called *Fast I/O*,
    that provides an alternative to its standard packet-based I/O model. It relies
    on a dispatch table implemented in the legacy drivers. Each driver processes Fast
    I/O requests and passes them down the stack to the next driver. If a single driver
    in the stack lacks a dispatch table, it disables Fast I/O processing for the entire
    device stack.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: Windows 支持一个用于处理缓存文件的机制，称为*快速 I/O*，它提供了一种替代标准基于数据包的 I/O 模型的方法。它依赖于传统驱动程序中实现的调度表。每个驱动程序处理快速
    I/O 请求，并将其传递到堆栈中的下一个驱动程序。如果堆栈中的某个驱动程序缺少调度表，则会禁用整个设备堆栈的快速 I/O 处理。
- en: '**An Inability to Monitor Non-data Fast I/O Operations**'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: '**无法监控非数据快速 I/O 操作**'
- en: In Windows, filesystems are deeply integrated into other system components,
    such as the memory manager. For instance, when a user requests that a file be
    mapped into memory, the memory manager calls the Fast I/O callback <samp class="SANS_TheSansMonoCd_W5Regular_11">AcquireFileForNtCreateSection</samp>.
    These non-data requests always bypass the device stack, making it hard for a legacy
    filter driver to collect information about them. It wasn’t until Windows XP, which
    introduced <samp class="SANS_TheSansMonoCd_W5Regular_11">nt!FsRtlRegisterFileSystemFilterCallbacks()</samp>,
    that developers could request this information.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Windows 中，文件系统与其他系统组件深度集成，例如内存管理器。例如，当用户请求将文件映射到内存时，内存管理器会调用快速 I/O 回调 <samp
    class="SANS_TheSansMonoCd_W5Regular_11">AcquireFileForNtCreateSection</samp>。这些非数据请求始终绕过设备堆栈，使得传统过滤驱动程序难以收集关于它们的信息。直到
    Windows XP 引入了 <samp class="SANS_TheSansMonoCd_W5Regular_11">nt!FsRtlRegisterFileSystemFilterCallbacks()</samp>，开发者才能请求这些信息。
- en: '**Issues with Handling Recursion**'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: '**递归处理问题**'
- en: Filesystems make heavy use of recursion, so filters in the filesystem stack
    must support it as well. However, due to the way that Windows manages I/O operations,
    this is easier said than done. Because each request passes through the entire
    device stack, a driver could easily deadlock or exhaust its resources if it handles
    recursion poorly.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 文件系统大量使用递归，因此文件系统堆栈中的过滤器也必须支持递归。然而，由于 Windows 管理 I/O 操作的方式，这并不容易实现。因为每个请求都会经过整个设备堆栈，如果驱动程序处理递归不当，可能会导致死锁或资源耗尽。
- en: To address some of these limitations, Microsoft introduced the filter manager
    model. The filter manager (*fltmgr.sys*) is a driver that ships with Windows and
    exposes functionality commonly used by filter drivers when intercepting filesystem
    operations. To leverage this functionality, developers can write minifilters.
    The filter manager then intercepts requests destined for the filesystem and passes
    them to the minifilters loaded on the system, which exist in their own sorted
    stack, as shown in [Figure 6-2](#fig6-2).
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解决这些限制，微软引入了过滤器管理器模型。过滤器管理器（*fltmgr.sys*）是一个随 Windows 一起发布的驱动程序，提供过滤器驱动程序在拦截文件系统操作时常用的功能。为了利用这些功能，开发者可以编写最小过滤器。然后，过滤器管理器拦截目标文件系统的请求，并将它们传递给已加载在系统上的最小过滤器，这些过滤器存在于它们自己的排序堆栈中，如[图
    6-2](#fig6-2)所示。
- en: Minifilters are substantially easier to develop than their legacy counterparts,
    and EDRs can manage them more easily by dynamically loading and unloading them
    on a running system. The ability to access functionality exposed by the filter
    manager makes for less complex drivers, allowing for easier maintenance. Microsoft
    has made tremendous efforts to move developers away from the legacy filter model
    and over to the minifilter model. It has even included an optional registry value
    that allows administrators to block legacy filter drivers from being loaded on
    the system altogether.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: Minifilter比传统的驱动程序更容易开发，EDR（端点检测和响应）也可以通过在运行系统上动态加载和卸载它们来更轻松地进行管理。通过访问过滤器管理器暴露的功能，Minifilter使得驱动程序更加简洁，便于维护。微软做出了巨大努力，推动开发人员摆脱传统过滤器模型，转向Minifilter模型。它甚至提供了一个可选的注册表值，允许管理员完全阻止传统过滤器驱动程序在系统上的加载。
- en: '![](../images/Figure6-2.png)'
  id: totrans-27
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/Figure6-2.png)'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 6-2: The filter manager
    and minifilter architecture</samp>'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">图6-2：过滤器管理器和Minifilter架构</samp>
- en: <samp class="SANS_Futura_Std_Bold_B_11">Minifilter Architecture</samp>
  id: totrans-29
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">Minifilter架构</samp>
- en: Minifilters have a unique architecture in several respects. First is the role
    of the filter manager itself. In a legacy architecture, filesystem drivers would
    filter I/O requests directly, while in a minifilter architecture, the filter manager
    handles this task before passing information about the requests to the minifilters
    loaded on the system. This means that minifilters are only indirectly attached
    to the filesystem stack. Also, they register with the filter manager for the specific
    operations they’re interested in, removing the need for them to handle all I/O
    requests.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: Minifilter在多个方面具有独特的架构。首先是过滤器管理器本身的角色。在传统架构中，文件系统驱动程序会直接过滤I/O请求，而在Minifilter架构中，过滤器管理器在将请求信息传递给系统中加载的Minifilter之前，先处理这一任务。这意味着Minifilter仅间接地附加到文件系统堆栈上。此外，它们会向过滤器管理器注册自己感兴趣的特定操作，避免了需要处理所有I/O请求。
- en: Next is how they interact with registered callback routines. As with the drivers
    discussed in the previous chapters, minifilters may register both pre- and post-operation
    callbacks. When a supported operation occurs, the filter manager first calls the
    correlated pre-operation callback function in each of the loaded minifilters.
    Once a minifilter completes its pre-operation routine, it passes control back
    to the filter manager, which calls the next callback function in the subsequent
    driver. When all drivers have completed their pre-operation callbacks, the request
    travels to the filesystem driver, which processes the operation. After receiving
    the I/O request for completion, the filter manager invokes the post-operation
    callback functions in the minifilters in reverse order. Once the post-operation
    callbacks complete, control is transferred back to the I/O manager, which eventually
    passes control back to the caller application.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来是它们如何与注册的回调例程进行交互。与前几章讨论的驱动程序一样，Minifilter可以注册操作前（pre-operation）和操作后（post-operation）回调。当发生支持的操作时，过滤器管理器首先调用每个已加载的Minifilter中关联的操作前回调函数。一旦Minifilter完成操作前例程，它将控制权返回给过滤器管理器，后者调用下一个驱动程序中的回调函数。当所有驱动程序完成操作前回调后，请求会传递给文件系统驱动程序进行处理。接收到I/O请求完成后，过滤器管理器以相反的顺序调用Minifilter中的操作后回调函数。操作后回调完成后，控制权会被转交回I/O管理器，最终传递回调用应用程序。
- en: Each minifilter has an *altitude*, which is a number that identifies its location
    in the minifilter stack and determines when the system will load that minifilter.
    Altitudes address the issue of ordering that plagued legacy filter drivers. Ideally,
    Microsoft assigns altitudes to the minifilters of production applications, and
    these values are specified in the drivers’ registry keys, under <samp class="SANS_TheSansMonoCd_W5Regular_11">Altitude</samp>.
    Microsoft sorts altitudes into load-order groups, which are shown in [Table 6-1](#tab6-1).
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 每个Minifilter都有一个*高度*，这是一个数字，用于标识其在Minifilter堆栈中的位置，并决定系统何时加载该Minifilter。高度解决了困扰传统过滤器驱动程序的排序问题。理想情况下，微软会为生产应用程序的Minifilter分配高度，这些值会在驱动程序的注册表键下指定，在<samp
    class="SANS_TheSansMonoCd_W5Regular_11">Altitude</samp>下。微软将高度按加载顺序分组，具体内容请见[表6-1](#tab6-1)。
- en: <samp class="SANS_Futura_Std_Heavy_B_11">Table 6-1:</samp> <samp class="SANS_Futura_Std_Book_11">Microsoft’s
    Minifilter Load-Order Groups</samp>
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Heavy_B_11">表 6-1：</samp> <samp class="SANS_Futura_Std_Book_11">微软的迷你过滤器加载顺序组</samp>
- en: '| <samp class="SANS_Futura_Std_Heavy_B_11">Altitude range</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">Load-order
    group name</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">Minifilter role</samp>
    |'
  id: totrans-34
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_Futura_Std_Heavy_B_11">高度范围</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">加载顺序组名称</samp>
    | <samp class="SANS_Futura_Std_Heavy_B_11">迷你过滤器角色</samp> |'
- en: '| --- | --- | --- |'
  id: totrans-35
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| <samp class="SANS_Futura_Std_Book_11">420000–429999</samp> | <samp class="SANS_Futura_Std_Book_11">Filter</samp>
    | <samp class="SANS_Futura_Std_Book_11">Legacy filter drivers</samp> |'
  id: totrans-36
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_Futura_Std_Book_11">420000–429999</samp> | <samp class="SANS_Futura_Std_Book_11">过滤器</samp>
    | <samp class="SANS_Futura_Std_Book_11">传统过滤器驱动程序</samp> |'
- en: '| <samp class="SANS_Futura_Std_Book_11">400000–409999</samp> | <samp class="SANS_Futura_Std_Book_11">FSFilter
    Top</samp> | <samp class="SANS_Futura_Std_Book_11">Filters that must attach above
    all others</samp> |'
  id: totrans-37
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_Futura_Std_Book_11">400000–409999</samp> | <samp class="SANS_Futura_Std_Book_11">FSFilter
    顶级</samp> | <samp class="SANS_Futura_Std_Book_11">必须在所有其他过滤器之上附加的过滤器</samp> |'
- en: '| <samp class="SANS_Futura_Std_Book_11">360000–389999</samp> | <samp class="SANS_Futura_Std_Book_11">FSFilter
    Activity Monitor</samp> | <samp class="SANS_Futura_Std_Book_11">Drivers that observe
    and report on file I/O</samp> |'
  id: totrans-38
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_Futura_Std_Book_11">360000–389999</samp> | <samp class="SANS_Futura_Std_Book_11">FSFilter
    活动监视器</samp> | <samp class="SANS_Futura_Std_Book_11">观察并报告文件I/O的驱动程序</samp> |'
- en: '| <samp class="SANS_Futura_Std_Book_11">340000–349999</samp> | <samp class="SANS_Futura_Std_Book_11">FSFilter
    Undelete</samp> | <samp class="SANS_Futura_Std_Book_11">Drivers that recover deleted
    files</samp> |'
  id: totrans-39
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_Futura_Std_Book_11">340000–349999</samp> | <samp class="SANS_Futura_Std_Book_11">FSFilter
    恢复删除</samp> | <samp class="SANS_Futura_Std_Book_11">恢复已删除文件的驱动程序</samp> |'
- en: '| <samp class="SANS_Futura_Std_Book_11">320000–329998</samp> | <samp class="SANS_Futura_Std_Book_11">FSFilter
    Anti-Virus</samp> | <samp class="SANS_Futura_Std_Book_11">Antimalware drivers</samp>
    |'
  id: totrans-40
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_Futura_Std_Book_11">320000–329998</samp> | <samp class="SANS_Futura_Std_Book_11">FSFilter
    防病毒</samp> | <samp class="SANS_Futura_Std_Book_11">恶意软件驱动程序</samp> |'
- en: '| <samp class="SANS_Futura_Std_Book_11">300000–309998</samp> | <samp class="SANS_Futura_Std_Book_11">FSFilter
    Replication</samp> | <samp class="SANS_Futura_Std_Book_11">Drivers that copy data
    to a remote system</samp> |'
  id: totrans-41
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_Futura_Std_Book_11">300000–309998</samp> | <samp class="SANS_Futura_Std_Book_11">FSFilter
    复制</samp> | <samp class="SANS_Futura_Std_Book_11">将数据复制到远程系统的驱动程序</samp> |'
- en: '| <samp class="SANS_Futura_Std_Book_11">280000–289998</samp> | <samp class="SANS_Futura_Std_Book_11">FSFilter
    Continuous Backup</samp> | <samp class="SANS_Futura_Std_Book_11">Drivers that
    copy data to backup media</samp> |'
  id: totrans-42
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_Futura_Std_Book_11">280000–289998</samp> | <samp class="SANS_Futura_Std_Book_11">FSFilter
    持续备份</samp> | <samp class="SANS_Futura_Std_Book_11">将数据复制到备份介质的驱动程序</samp> |'
- en: '| <samp class="SANS_Futura_Std_Book_11">260000–269998</samp> | <samp class="SANS_Futura_Std_Book_11">FSFilter
    Content Screener</samp> | <samp class="SANS_Futura_Std_Book_11">Drivers that prevent
    the creation of specific files or content</samp> |'
  id: totrans-43
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_Futura_Std_Book_11">260000–269998</samp> | <samp class="SANS_Futura_Std_Book_11">FSFilter
    内容筛选器</samp> | <samp class="SANS_Futura_Std_Book_11">防止创建特定文件或内容的驱动程序</samp> |'
- en: '| <samp class="SANS_Futura_Std_Book_11">240000–249999</samp> | <samp class="SANS_Futura_Std_Book_11">FSFilter
    Quota Management</samp> | <samp class="SANS_Futura_Std_Book_11">Drivers that provide
    enhanced filesystem quotas that limit the space allowed for a volume or folder</samp>
    |'
  id: totrans-44
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_Futura_Std_Book_11">240000–249999</samp> | <samp class="SANS_Futura_Std_Book_11">FSFilter
    配额管理</samp> | <samp class="SANS_Futura_Std_Book_11">提供增强文件系统配额，限制卷或文件夹空间的驱动程序</samp>
    |'
- en: '| <samp class="SANS_Futura_Std_Book_11">220000–229999</samp> | <samp class="SANS_Futura_Std_Book_11">FSFilter
    System Recovery</samp> | <samp class="SANS_Futura_Std_Book_11">Drivers that maintain
    operating system integrity</samp> |'
  id: totrans-45
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_Futura_Std_Book_11">220000–229999</samp> | <samp class="SANS_Futura_Std_Book_11">FSFilter
    系统恢复</samp> | <samp class="SANS_Futura_Std_Book_11">维护操作系统完整性的驱动程序</samp> |'
- en: '| <samp class="SANS_Futura_Std_Book_11">200000–209999</samp> | <samp class="SANS_Futura_Std_Book_11">FSFilter
    Cluster File System</samp> | <samp class="SANS_Futura_Std_Book_11">Drivers used
    by applications that provide file server metadata across a network</samp> |'
  id: totrans-46
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_Futura_Std_Book_11">200000–209999</samp> | <samp class="SANS_Futura_Std_Book_11">FSFilter
    集群文件系统</samp> | <samp class="SANS_Futura_Std_Book_11">提供文件服务器元数据的应用程序使用的驱动程序</samp>
    |'
- en: '| <samp class="SANS_Futura_Std_Book_11">180000–189999</samp> | <samp class="SANS_Futura_Std_Book_11">FSFilter
    HSM</samp> | <samp class="SANS_Futura_Std_Book_11">Hierarchical storage management
    drivers</samp> |'
  id: totrans-47
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_Futura_Std_Book_11">180000–189999</samp> | <samp class="SANS_Futura_Std_Book_11">FSFilter
    HSM</samp> | <samp class="SANS_Futura_Std_Book_11">层级存储管理驱动程序</samp> |'
- en: '| <samp class="SANS_Futura_Std_Book_11">170000–174999</samp> | <samp class="SANS_Futura_Std_Book_11">FSFilter
    Imaging</samp> | <samp class="SANS_Futura_Std_Book_11">ZIP-like drivers that provide
    a virtual namespace</samp> |'
  id: totrans-48
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_Futura_Std_Book_11">170000–174999</samp> | <samp class="SANS_Futura_Std_Book_11">FSFilter
    图像处理</samp> | <samp class="SANS_Futura_Std_Book_11">类似ZIP的驱动程序，提供虚拟命名空间</samp>
    |'
- en: '| <samp class="SANS_Futura_Std_Book_11">160000–169999</samp> | <samp class="SANS_Futura_Std_Book_11">FSFilter
    Compression</samp> | <samp class="SANS_Futura_Std_Book_11">File-data compression
    drivers</samp> |'
  id: totrans-49
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_Futura_Std_Book_11">160000–169999</samp> | <samp class="SANS_Futura_Std_Book_11">FSFilter
    压缩</samp> | <samp class="SANS_Futura_Std_Book_11">文件数据压缩驱动程序</samp> |'
- en: '| <samp class="SANS_Futura_Std_Book_11">140000–149999</samp> | <samp class="SANS_Futura_Std_Book_11">FSFilter
    Encryption</samp> | <samp class="SANS_Futura_Std_Book_11">File-data encryption
    and decryption drivers</samp> |'
  id: totrans-50
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_Futura_Std_Book_11">140000–149999</samp> | <samp class="SANS_Futura_Std_Book_11">FSFilter
    加密</samp> | <samp class="SANS_Futura_Std_Book_11">文件数据加密和解密驱动程序</samp> |'
- en: '| <samp class="SANS_Futura_Std_Book_11">130000–139999</samp> | <samp class="SANS_Futura_Std_Book_11">FSFilter
    Virtualization</samp> | <samp class="SANS_Futura_Std_Book_11">Filepath virtualization
    drivers</samp> |'
  id: totrans-51
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_Futura_Std_Book_11">130000–139999</samp> | <samp class="SANS_Futura_Std_Book_11">FSFilter
    虚拟化</samp> | <samp class="SANS_Futura_Std_Book_11">文件路径虚拟化驱动程序</samp> |'
- en: '| <samp class="SANS_Futura_Std_Book_11">120000–129999</samp> | <samp class="SANS_Futura_Std_Book_11">FSFilter
    Physical Quota Management</samp> | <samp class="SANS_Futura_Std_Book_11">Drivers
    that manage quotes by using physical block counts</samp> |'
  id: totrans-52
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_Futura_Std_Book_11">120000–129999</samp> | <samp class="SANS_Futura_Std_Book_11">FSFilter
    物理配额管理</samp> | <samp class="SANS_Futura_Std_Book_11">通过使用物理块计数来管理配额的驱动程序</samp>
    |'
- en: '| <samp class="SANS_Futura_Std_Book_11">100000–109999</samp> | <samp class="SANS_Futura_Std_Book_11">FSFilter
    Open File</samp> | <samp class="SANS_Futura_Std_Book_11">Drivers that provide
    snapshots of already-opened files</samp> |'
  id: totrans-53
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_Futura_Std_Book_11">100000–109999</samp> | <samp class="SANS_Futura_Std_Book_11">FSFilter
    打开文件</samp> | <samp class="SANS_Futura_Std_Book_11">提供已打开文件快照的驱动程序</samp> |'
- en: '| <samp class="SANS_Futura_Std_Book_11">80000–89999</samp> | <samp class="SANS_Futura_Std_Book_11">FSFilter
    Security Enhancer</samp> | <samp class="SANS_Futura_Std_Book_11">Drivers that
    apply file-based lockdowns and enhanced access control</samp> |'
  id: totrans-54
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_Futura_Std_Book_11">80000–89999</samp> | <samp class="SANS_Futura_Std_Book_11">FSFilter
    安全增强</samp> | <samp class="SANS_Futura_Std_Book_11">应用基于文件的锁定和增强访问控制的驱动程序</samp>
    |'
- en: '| <samp class="SANS_Futura_Std_Book_11">60000–69999</samp> | <samp class="SANS_Futura_Std_Book_11">FSFilter
    Copy Protection</samp> | <samp class="SANS_Futura_Std_Book_11">Drivers that check
    for out-of-band data on storage media</samp> |'
  id: totrans-55
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_Futura_Std_Book_11">60000–69999</samp> | <samp class="SANS_Futura_Std_Book_11">FSFilter
    复制保护</samp> | <samp class="SANS_Futura_Std_Book_11">检查存储介质上是否存在带外数据的驱动程序</samp>
    |'
- en: '| <samp class="SANS_Futura_Std_Book_11">40000–49999</samp> | <samp class="SANS_Futura_Std_Book_11">FSFilter
    Bottom</samp> | <samp class="SANS_Futura_Std_Book_11">Filters that must attach
    below all others</samp> |'
  id: totrans-56
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_Futura_Std_Book_11">40000–49999</samp> | <samp class="SANS_Futura_Std_Book_11">FSFilter
    底部</samp> | <samp class="SANS_Futura_Std_Book_11">必须附加在所有其他过滤器下面的过滤器</samp> |'
- en: '| <samp class="SANS_Futura_Std_Book_11">20000–29999</samp> | <samp class="SANS_Futura_Std_Book_11">FSFilter
    System</samp> | <samp class="SANS_Futura_Std_Book_11">Reserved</samp> |'
  id: totrans-57
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_Futura_Std_Book_11">20000–29999</samp> | <samp class="SANS_Futura_Std_Book_11">FSFilter
    系统</samp> | <samp class="SANS_Futura_Std_Book_11">保留</samp> |'
- en: '| <samp class="SANS_Futura_Std_Book_11"><20000</samp> | <samp class="SANS_Futura_Std_Book_11">FSFilter
    Infrastructure</samp> | <samp class="SANS_Futura_Std_Book_11">Reserved for system
    use but attaches closest to the filesystem</samp> |'
  id: totrans-58
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_Futura_Std_Book_11"><20000</samp> | <samp class="SANS_Futura_Std_Book_11">FSFilter
    基础设施</samp> | <samp class="SANS_Futura_Std_Book_11">为系统使用保留，但最接近文件系统附加</samp>
    |'
- en: Most EDR vendors register their minifilters in the FSFilter Anti-Virus or FSFilter
    Activity Monitor group. Microsoft publishes a list of registered altitudes, as
    well as their associated filenames and publishers. [Table 6-2](#tab6-2) lists
    altitudes assigned to minifilters belonging to popular commercial EDR solutions.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数EDR供应商将其minifilter注册到FSFilter 防病毒或FSFilter 活动监控器组中。微软发布了注册的高度列表，以及它们关联的文件名和发布者。[表6-2](#tab6-2)列出了分配给流行商业EDR解决方案的minifilter的高度。
- en: <samp class="SANS_Futura_Std_Heavy_B_11">Table 6-2:</samp> <samp class="SANS_Futura_Std_Book_11">Altitudes
    of Popular EDRs</samp>
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Heavy_B_11">表 6-2：</samp> <samp class="SANS_Futura_Std_Book_11">流行
    EDR 的高度</samp>
- en: '| <samp class="SANS_Futura_Std_Heavy_B_11">Altitude</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">Vendor</samp>
    | <samp class="SANS_Futura_Std_Heavy_B_11">EDR</samp> |'
  id: totrans-61
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_Futura_Std_Heavy_B_11">Altitude</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">Vendor</samp>
    | <samp class="SANS_Futura_Std_Heavy_B_11">EDR</samp> |'
- en: '| --- | --- | --- |'
  id: totrans-62
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| <samp class="SANS_Futura_Std_Book_11">389220</samp> | <samp class="SANS_Futura_Std_Book_11">Sophos</samp>
    | <samp class="SANS_Futura_Std_Book_Oblique_I_11">sophosed.sys</samp> |'
  id: totrans-63
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_Futura_Std_Book_11">389220</samp> | <samp class="SANS_Futura_Std_Book_11">Sophos</samp>
    | <samp class="SANS_Futura_Std_Book_Oblique_I_11">sophosed.sys</samp> |'
- en: '| <samp class="SANS_Futura_Std_Book_11">389040</samp> | <samp class="SANS_Futura_Std_Book_11">SentinelOne</samp>
    | <samp class="SANS_Futura_Std_Book_Oblique_I_11">sentinelmonitor.sys</samp> |'
  id: totrans-64
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_Futura_Std_Book_11">389040</samp> | <samp class="SANS_Futura_Std_Book_11">SentinelOne</samp>
    | <samp class="SANS_Futura_Std_Book_Oblique_I_11">sentinelmonitor.sys</samp> |'
- en: '| <samp class="SANS_Futura_Std_Book_11">328010</samp> | <samp class="SANS_Futura_Std_Book_11">Microsoft</samp>
    | <samp class="SANS_Futura_Std_Book_Oblique_I_11">wdfilter.sys</samp> |'
  id: totrans-65
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_Futura_Std_Book_11">328010</samp> | <samp class="SANS_Futura_Std_Book_11">Microsoft</samp>
    | <samp class="SANS_Futura_Std_Book_Oblique_I_11">wdfilter.sys</samp> |'
- en: '| <samp class="SANS_Futura_Std_Book_11">321410</samp> | <samp class="SANS_Futura_Std_Book_11">CrowdStrike</samp>
    | <samp class="SANS_Futura_Std_Book_Oblique_I_11">csagent.sys</samp> |'
  id: totrans-66
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_Futura_Std_Book_11">321410</samp> | <samp class="SANS_Futura_Std_Book_11">CrowdStrike</samp>
    | <samp class="SANS_Futura_Std_Book_Oblique_I_11">csagent.sys</samp> |'
- en: '| <samp class="SANS_Futura_Std_Book_11">388360</samp> | <samp class="SANS_Futura_Std_Book_11">FireEye/Trellix</samp>
    | <samp class="SANS_Futura_Std_Book_Oblique_I_11">fekern.sys</samp> |'
  id: totrans-67
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_Futura_Std_Book_11">388360</samp> | <samp class="SANS_Futura_Std_Book_11">FireEye/Trellix</samp>
    | <samp class="SANS_Futura_Std_Book_Oblique_I_11">fekern.sys</samp> |'
- en: '| <samp class="SANS_Futura_Std_Book_11">386720</samp> | <samp class="SANS_Futura_Std_Book_11">Bit9/Carbon
    Black/VMWare</samp> | <samp class="SANS_Futura_Std_Book_Oblique_I_11">carbonblackk.sys</samp>
    |'
  id: totrans-68
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_Futura_Std_Book_11">386720</samp> | <samp class="SANS_Futura_Std_Book_11">Bit9/Carbon
    Black/VMWare</samp> | <samp class="SANS_Futura_Std_Book_Oblique_I_11">carbonblackk.sys</samp>
    |'
- en: While an administrator can change a minifilter’s altitude, the system can load
    only one minifilter at a single altitude at one time.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然管理员可以更改 minifilter 的高度，但系统一次只能加载一个高度的 minifilter。
- en: <samp class="SANS_Futura_Std_Bold_B_11">Writing a Minifilter</samp>
  id: totrans-70
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">编写 Minifilter</samp>
- en: Let’s walk through the process of writing a minifilter. Each minifilter begins
    with a <samp class="SANS_TheSansMonoCd_W5Regular_11">DriverEntry()</samp> function,
    defined in the same way as other drivers. This function performs any required
    global initializations and then registers the minifilter. Finally, it starts filtering
    I/O operations and returns an appropriate value.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来了解编写 minifilter 的过程。每个 minifilter 都以一个 <samp class="SANS_TheSansMonoCd_W5Regular_11">DriverEntry()</samp>
    函数开始，定义方式与其他驱动程序相同。这个函数执行任何必需的全局初始化，然后注册 minifilter。最后，它开始过滤 I/O 操作并返回适当的值。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Beginning the Registration</samp>
  id: totrans-72
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">开始注册</samp>
- en: The first, and most important, of these actions is registration, which the <samp
    class="SANS_TheSansMonoCd_W5Regular_11">DriverEntry()</samp> function performs
    by calling <samp class="SANS_TheSansMonoCd_W5Regular_11">fltmgr!FltRegisterFilter()</samp>.
    This function adds the minifilter to the list of registered minifilter drivers
    on the host and provides the filter manager with information about the minifilter,
    including a list of callback routines. This function is defined in [Listing 6-1](#list6-1).
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 这些操作中，最重要的一步是注册，<samp class="SANS_TheSansMonoCd_W5Regular_11">DriverEntry()</samp>
    函数通过调用 <samp class="SANS_TheSansMonoCd_W5Regular_11">fltmgr!FltRegisterFilter()</samp>
    来完成。这函数将 minifilter 添加到主机上已注册 minifilter 驱动程序的列表中，并向过滤器管理器提供有关 minifilter 的信息，包括回调例程的列表。该函数的定义见
    [清单 6-1](#list6-1)。
- en: '[PRE0]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Listing 6-1: The <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">fltmgr!FltRegisterFilter()</samp>
    function definition'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 清单 6-1：<samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">fltmgr!FltRegisterFilter()</samp>
    函数定义
- en: Of the three parameters passed to it, the <samp class="SANS_TheSansMonoCd_W5Regular_11">Registration</samp>
    parameter is the most interesting. This is a pointer to an <samp class="SANS_TheSansMonoCd_W5Regular_11">FLT_REGISTRATION</samp>
    structure, defined in [Listing 6-2](#list6-2), which houses all the relevant information
    about the minifilter.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 传递给它的三个参数中，<samp class="SANS_TheSansMonoCd_W5Regular_11">Registration</samp>
    参数是最有趣的。它是一个指向 <samp class="SANS_TheSansMonoCd_W5Regular_11">FLT_REGISTRATION</samp>
    结构的指针，该结构在 [清单 6-2](#list6-2) 中定义，包含关于微过滤器的所有相关信息。
- en: '[PRE1]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Listing 6-2: The <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">FLT_REGISTRATION</samp>
    structure definition'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 清单 6-2：<samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">FLT_REGISTRATION</samp>
    结构定义
- en: 'The first two members of this structure set the structure size, which is always
    <samp class="SANS_TheSansMonoCd_W5Regular_11">sizeof(FLT_REGISTRATION)</samp>,
    and the structure revision level, which is always <samp class="SANS_TheSansMonoCd_W5Regular_11">FLT_REGISTRATION_VERSION</samp>.
    The next member is *flags*, which is a bitmask that may be zero or a combination
    of any of the following three values:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 该结构的前两个成员设置了结构的大小，大小始终为 <samp class="SANS_TheSansMonoCd_W5Regular_11">sizeof(FLT_REGISTRATION)</samp>，并设置结构修订级别，始终为
    <samp class="SANS_TheSansMonoCd_W5Regular_11">FLT_REGISTRATION_VERSION</samp>。下一个成员是
    *flags*，它是一个位掩码，可能为零或以下三个值的任意组合：
- en: <samp class="SANS_TheSansMonoCd_W7Bold_B_11">FLTFL_REGISTRATION_DO_NOT_SUPPORT_SERVICE_STOP
    (1)</samp>
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W7Bold_B_11">FLTFL_REGISTRATION_DO_NOT_SUPPORT_SERVICE_STOP
    (1)</samp>
- en: The minifilter won’t be unloaded in the event of a service stop request.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 微过滤器在请求停止服务时不会被卸载。
- en: <samp class="SANS_TheSansMonoCd_W7Bold_B_11">FLTFL_REGISTRATION_SUPPORT_NPFS_MSFS</samp>
    <samp class="SANS_TheSansMonoCd_W7Bold_B_11">(2)</samp>
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W7Bold_B_11">FLTFL_REGISTRATION_SUPPORT_NPFS_MSFS</samp>
    <samp class="SANS_TheSansMonoCd_W7Bold_B_11">(2)</samp>
- en: The minifilter supports named pipe and mailslot requests.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 微过滤器支持命名管道和邮件插槽请求。
- en: <samp class="SANS_TheSansMonoCd_W7Bold_B_11">FLTFL_REGISTRATION_SUPPORT_DAX_VOLUME
    (4)</samp>
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W7Bold_B_11">FLTFL_REGISTRATION_SUPPORT_DAX_VOLUME
    (4)</samp>
- en: The minifilter supports attaching to a Direct Access (DAX) volume.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 该微过滤器支持附加到直接访问（DAX）卷。
- en: Following this member is the context registration. This will be either an array
    of <samp class="SANS_TheSansMonoCd_W5Regular_11">FLT_CONTEXT_REGISTRATION</samp>
    structures or null. These contexts allow a minifilter to associate related objects
    and preserve state across I/O operations. After this array of context comes the
    critically important operation registration array. This is a variable length array
    of <samp class="SANS_TheSansMonoCd_W5Regular_11">FLT_OPERATION_REGISTRATION</samp>
    structures, which are defined in [Listing 6-3](#list6-3). While this array can
    technically be null, it’s rare to see that configuration in an EDR sensor. The
    minifilter must provide a structure for each type of I/O for which it registers
    a pre-operation or post-operation callback routine.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 紧随其后的是上下文注册。这将是一个 <samp class="SANS_TheSansMonoCd_W5Regular_11">FLT_CONTEXT_REGISTRATION</samp>
    结构的数组或 null。这些上下文允许微过滤器将相关对象关联起来，并在 I/O 操作之间保持状态。在此上下文数组之后是至关重要的操作注册数组。这是一个可变长度的
    <samp class="SANS_TheSansMonoCd_W5Regular_11">FLT_OPERATION_REGISTRATION</samp>
    结构的数组，这些结构在 [清单 6-3](#list6-3) 中定义。虽然这个数组在技术上可以为 null，但在 EDR 传感器中很少见到这种配置。微过滤器必须为每种类型的
    I/O 提供一个结构，以便它注册预操作或后操作回调例程。
- en: '[PRE2]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Listing 6-3: The <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">FLT_OPERATION_REGISTRATION</samp>
    structure definition'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 清单 6-3：<samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">FLT_OPERATION_REGISTRATION</samp>
    结构定义
- en: The first parameter indicates which major function the minifilter is interested
    in processing. These are constants defined in *wdm.h*, and [Table 6-3](#tab6-3)
    lists some of those most relevant to security monitoring.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个参数表示微过滤器感兴趣处理的主要功能。这些是 *wdm.h* 中定义的常量，[表 6-3](#tab6-3) 列出了与安全监控最相关的一些常量。
- en: <samp class="SANS_Futura_Std_Heavy_B_11">Table 6-3:</samp> <samp class="SANS_Futura_Std_Book_11">Major
    Functions and Their Purposes</samp>
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Heavy_B_11">表 6-3：</samp> <samp class="SANS_Futura_Std_Book_11">主要功能及其目的</samp>
- en: '| <samp class="SANS_Futura_Std_Heavy_B_11">Major function</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">Purpose</samp>
    |'
  id: totrans-91
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_Futura_Std_Heavy_B_11">主要功能</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">目的</samp>
    |'
- en: '| --- | --- |'
  id: totrans-92
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">IRP_MJ_CREATE</samp> <samp
    class="SANS_TheSansMonoCd_W5Regular_11">(0x00)</samp> | <samp class="SANS_Futura_Std_Book_11">A
    new file is being created or a handle to an existing one is being opened.</samp>
    |'
  id: totrans-93
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">IRP_MJ_CREATE</samp> <samp
    class="SANS_TheSansMonoCd_W5Regular_11">(0x00)</samp> | <samp class="SANS_Futura_Std_Book_11">正在创建新文件或打开现有文件的句柄。</samp>
    |'
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">IRP_MJ_CREATE_NAMED_PIPE</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">(0x01)</samp> | <samp class="SANS_Futura_Std_Book_11">A
    named pipe is being created or opened.</samp> |'
  id: totrans-94
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">IRP_MJ_CREATE_NAMED_PIPE</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">(0x01)</samp> | <samp class="SANS_Futura_Std_Book_11">正在创建或打开一个命名管道。</samp>
    |'
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">IRP_MJ_CLOSE (0x02)</samp>
    | <samp class="SANS_Futura_Std_Book_11">A handle to a file object is being closed.</samp>
    |'
  id: totrans-95
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">IRP_MJ_CLOSE (0x02)</samp>
    | <samp class="SANS_Futura_Std_Book_11">正在关闭文件对象的句柄。</samp> |'
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">IRP_MJ_READ</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">(0x03)</samp>
    | <samp class="SANS_Futura_Std_Book_11">Data is being read from a file.</samp>
    |'
  id: totrans-96
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">IRP_MJ_READ</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">(0x03)</samp>
    | <samp class="SANS_Futura_Std_Book_11">正在从文件中读取数据。</samp> |'
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">IRP_MJ_WRITE</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">(0x04)</samp>
    | <samp class="SANS_Futura_Std_Book_11">Data is being written to a file.</samp>
    |'
  id: totrans-97
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">IRP_MJ_WRITE</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">(0x04)</samp>
    | <samp class="SANS_Futura_Std_Book_11">正在向文件写入数据。</samp> |'
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">IRP_MJ_QUERY_INFORMATION</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">(0x05)</samp> | <samp class="SANS_Futura_Std_Book_11">Information
    about a file, such as its creation time, has been requested.</samp> |'
  id: totrans-98
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">IRP_MJ_QUERY_INFORMATION</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">(0x05)</samp> | <samp class="SANS_Futura_Std_Book_11">已请求有关文件的信息，如其创建时间。</samp>
    |'
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">IRP_MJ_SET_INFORMATION</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">(0x06)</samp> | <samp class="SANS_Futura_Std_Book_11">Information
    about a file, such as its name, is being set or updated.</samp> |'
  id: totrans-99
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">IRP_MJ_SET_INFORMATION</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">(0x06)</samp> | <samp class="SANS_Futura_Std_Book_11">正在设置或更新文件的信息，如其名称。</samp>
    |'
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">IRP_MJ_QUERY_EA</samp> <samp
    class="SANS_TheSansMonoCd_W5Regular_11">(0x07)</samp> | <samp class="SANS_Futura_Std_Book_11">A
    file’s extended information has been requested.</samp> |'
  id: totrans-100
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">IRP_MJ_QUERY_EA</samp> <samp
    class="SANS_TheSansMonoCd_W5Regular_11">(0x07)</samp> | <samp class="SANS_Futura_Std_Book_11">已请求文件的扩展信息。</samp>
    |'
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">IRP_MJ_SET_EA</samp> <samp
    class="SANS_TheSansMonoCd_W5Regular_11">(0x08)</samp> | <samp class="SANS_Futura_Std_Book_11">A
    file’s extended information is being set or updated.</samp> |'
  id: totrans-101
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">IRP_MJ_SET_EA</samp> <samp
    class="SANS_TheSansMonoCd_W5Regular_11">(0x08)</samp> | <samp class="SANS_Futura_Std_Book_11">正在设置或更新文件的扩展信息。</samp>
    |'
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">IRP_MJ_LOCK_CONTROL</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">(0x11)</samp> | <samp class="SANS_Futura_Std_Book_11">A
    lock is being placed on a file, such as via a call to</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">kernel32!LockFileEx()</samp><samp
    class="SANS_Futura_Std_Book_11">.</samp> |'
  id: totrans-102
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">IRP_MJ_LOCK_CONTROL</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">(0x11)</samp> | <samp class="SANS_Futura_Std_Book_11">正在对文件加锁，例如通过调用</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">kernel32!LockFileEx()</samp><samp
    class="SANS_Futura_Std_Book_11">。</samp> |'
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">IRP_MJ_CREATE_MAILSLOT</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">(0x13)</samp> | <samp class="SANS_Futura_Std_Book_11">A
    new mailslot is being created or opened.</samp> |'
  id: totrans-103
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">IRP_MJ_CREATE_MAILSLOT</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">(0x13)</samp> | <samp class="SANS_Futura_Std_Book_11">正在创建或打开一个新的邮件插槽。</samp>
    |'
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">IRP_MJ_QUERY_SECURITY</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">(0x14)</samp> | <samp class="SANS_Futura_Std_Book_11">Security
    information about a file is being requested.</samp> |'
  id: totrans-104
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">IRP_MJ_QUERY_SECURITY</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">(0x14)</samp> | <samp class="SANS_Futura_Std_Book_11">正在请求有关文件的安全信息。</samp>
    |'
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">IRP_MJ_SET_SECURITY</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">(0x15)</samp> | <samp class="SANS_Futura_Std_Book_11">Security
    information related to a file is being set or updated.</samp> |'
  id: totrans-105
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">IRP_MJ_SET_SECURITY</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">(0x15)</samp> | <samp class="SANS_Futura_Std_Book_11">与文件相关的安全信息正在设置或更新。</samp>
    |'
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">IRP_MJ_SYSTEM_CONTROL</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">(0x17)</samp> | <samp class="SANS_Futura_Std_Book_11">A
    new driver has been registered as a supplier of Windows Management Instrumentation.</samp>
    |'
  id: totrans-106
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">IRP_MJ_SYSTEM_CONTROL</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">(0x17)</samp> | <samp class="SANS_Futura_Std_Book_11">一个新的驱动程序已注册为
    Windows 管理工具的供应商。</samp> |'
- en: The next member of the structure specifies the flags. This bitmask describes
    when the callback functions should be invoked for cached I/O or paging I/O operations.
    At the time of this writing, there are four supported flags, all of which are
    prefixed with <samp class="SANS_TheSansMonoCd_W5Regular_11">FLTFL_OPERATION_REGISTRATION_</samp>.
    First, <samp class="SANS_TheSansMonoCd_W5Regular_11">SKIP_PAGING_IO</samp> indicates
    whether a callback should be invoked for IRP-based read or write paging I/O operations.
    The <samp class="SANS_TheSansMonoCd_W5Regular_11">SKIP_CACHED_IO</samp> flag is
    used to prevent the invocation of callbacks on fast I/O-based read or write cached
    I/O operations. Next, <samp class="SANS_TheSansMonoCd_W5Regular_11">SKIP_NON_DASD_IO</samp>
    is used for requests issued on a Direct Access Storage Device (DASD) volume handle.
    Finally, <samp class="SANS_TheSansMonoCd_W5Regular_11">SKIP_NON_CACHED_NON_PAGING_IO</samp>
    prevents callback invocation on read or write I/O operations that are not cached
    or paging operations.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 结构的下一个成员指定标志位。此位掩码描述了何时应为缓存 I/O 或分页 I/O 操作调用回调函数。写本文时，支持四个标志，所有标志的前缀都是 <samp
    class="SANS_TheSansMonoCd_W5Regular_11">FLTFL_OPERATION_REGISTRATION_</samp>。首先，<samp
    class="SANS_TheSansMonoCd_W5Regular_11">SKIP_PAGING_IO</samp> 表示是否应为基于 IRP 的读或写分页
    I/O 操作调用回调。<samp class="SANS_TheSansMonoCd_W5Regular_11">SKIP_CACHED_IO</samp>
    标志用于防止在基于快速 I/O 的读写缓存 I/O 操作中调用回调。接下来，<samp class="SANS_TheSansMonoCd_W5Regular_11">SKIP_NON_DASD_IO</samp>
    用于对在直接访问存储设备（DASD）卷句柄上发出的请求。最后，<samp class="SANS_TheSansMonoCd_W5Regular_11">SKIP_NON_CACHED_NON_PAGING_IO</samp>
    防止在非缓存或非分页 I/O 操作的读写中调用回调。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Defining Pre-operation
    Callbacks</samp>
  id: totrans-108
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">定义预操作回调</samp>
- en: The next two members of the <samp class="SANS_TheSansMonoCd_W5Regular_11">FLT_OPERATION_REGISTRATION</samp>
    structure define the pre-operation or post-operation callbacks to be invoked when
    each of the target major functions occurs on the system. Pre-operation callbacks
    are passed via a pointer to an <samp class="SANS_TheSansMonoCd_W5Regular_11">FLT_PRE_OPERATION_CALLBACK</samp>
    structure, and post-operation routines are specified as a pointer to an <samp
    class="SANS_TheSansMonoCd_W5Regular_11">FLT_POST_OPERATION_CALLBACK</samp> structure.
    While these functions’ definitions aren’t too dissimilar, their capabilities and
    limitations vary substantially.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W5Regular_11">FLT_OPERATION_REGISTRATION</samp>
    结构的接下来两个成员定义了当系统上发生每个目标主要功能时要调用的预操作或后操作回调。预操作回调通过指向 <samp class="SANS_TheSansMonoCd_W5Regular_11">FLT_PRE_OPERATION_CALLBACK</samp>
    结构的指针传递，后操作例程则指定为指向 <samp class="SANS_TheSansMonoCd_W5Regular_11">FLT_POST_OPERATION_CALLBACK</samp>
    结构的指针。虽然这些函数的定义并没有太大不同，但它们的功能和限制差异非常大。
- en: As with callbacks in other types of drivers, pre-operation callback functions
    allow the developer to inspect an operation on its way to its destination (the
    target filesystem, in the case of a minifilter). These callback functions receive
    a pointer to the callback data for the operation and some opaque pointers for
    the objects related to the current I/O request, and they return an <samp class="SANS_TheSansMonoCd_W5Regular_11">FLT_PREOP_CALLBACK_STATUS</samp>
    return code. In code, this would look like what is shown in [Listing 6-4](#list6-4).
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 与其他类型驱动程序中的回调一样，预操作回调函数允许开发人员在操作到达目标之前（在 minifilter 的情况下为目标文件系统）检查该操作。这些回调函数接收指向操作回调数据的指针，以及一些与当前
    I/O 请求相关的 opaque 指针，并返回一个 <samp class="SANS_TheSansMonoCd_W5Regular_11">FLT_PREOP_CALLBACK_STATUS</samp>
    返回代码。在代码中，这看起来像是[清单 6-4](#list6-4)所示的内容。
- en: '[PRE3]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Listing 6-4: Registering a pre-operation callback'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 清单 6-4：注册预操作回调
- en: 'The first parameter, <samp class="SANS_TheSansMonoCd_W5Regular_11">Data</samp>,
    is the most complex of the three and contains all the major information related
    to the request that the minifilter is processing. The <samp class="SANS_TheSansMonoCd_W5Regular_11">FLT_CALLBACK_DATA</samp>
    structure is used by both the filter manager and the minifilter to process I/O
    operations and contains a ton of useful data for any EDR agent monitoring filesystem
    operations. Some of the important members of this structure include:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个参数，<samp class="SANS_TheSansMonoCd_W5Regular_11">Data</samp>，是最复杂的一个，包含与minifilter正在处理的请求相关的所有主要信息。<samp
    class="SANS_TheSansMonoCd_W5Regular_11">FLT_CALLBACK_DATA</samp>结构由过滤器管理器和minifilter共同使用，用于处理I/O操作，并包含大量对任何监视文件系统操作的EDR代理有用的数据。该结构的一些重要成员包括：
- en: '<samp class="SANS_TheSansMonoCd_W7Bold_B_11">Flags</samp>   A bitmask that
    describes the I/O operation. These flags may come preset from the filter manager,
    though the minifilter may set additional flags in some circumstances. When the
    filter manager initializes the data structure, it sets a flag to indicate what
    type of I/O operation it represents: either fast I/O, filter, or IRP operations.
    The filter manager may also set flags indicating whether a minifilter generated
    or reissued the operation, whether it came from the non-paged pool, and whether
    the operation completed.'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W7Bold_B_11">Flags</samp>   描述I/O操作的位掩码。这些标志可能会由过滤器管理器预设，尽管在某些情况下，minifilter可能会设置额外的标志。当过滤器管理器初始化数据结构时，它会设置一个标志，指示它代表哪种类型的I/O操作：快速I/O、过滤器操作或IRP操作。过滤器管理器还可以设置标志，指示minifilter是否生成或重新发出该操作，是否来自非分页池，以及操作是否已完成。
- en: <samp class="SANS_TheSansMonoCd_W7Bold_B_11">Thread</samp>   A pointer to the
    thread that initiated the I/O request. This is useful for identifying the application
    performing the operation.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W7Bold_B_11">Thread</samp>   指向发起I/O请求的线程的指针。这对于识别执行操作的应用程序非常有用。
- en: <samp class="SANS_TheSansMonoCd_W7Bold_B_11">Iopb</samp>   The I/O parameter
    block that contains information about IRP-based operations (for example, <samp
    class="SANS_TheSansMonoCd_W5Regular_11">IRP_BUFFERED_IO</samp>, which indicates
    that it is a buffered I/O operation); the major function code; special flags related
    to the operation (for example, <samp class="SANS_TheSansMonoCd_W5Regular_11">SL_CASE_SENSITIVE</samp>,
    which informs drivers in the stack that filename comparisons should be case sensitive);
    a pointer to the file object that is the target of the operation; and an <samp
    class="SANS_TheSansMonoCd_W5Regular_11">FLT_PARAMETERS</samp> structure containing
    the parameters unique to the specific I/O operation specified by the major or
    minor function code member of the structure.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W7Bold_B_11">Iopb</samp>   包含关于基于IRP的操作（例如，<samp
    class="SANS_TheSansMonoCd_W5Regular_11">IRP_BUFFERED_IO</samp>，表示这是一个缓冲I/O操作）的信息；主功能代码；与操作相关的特殊标志（例如，<samp
    class="SANS_TheSansMonoCd_W5Regular_11">SL_CASE_SENSITIVE</samp>，该标志通知堆栈中的驱动程序，文件名比较应区分大小写）；指向作为操作目标的文件对象的指针；以及一个包含特定I/O操作唯一参数的<samp
    class="SANS_TheSansMonoCd_W5Regular_11">FLT_PARAMETERS</samp>结构体，该结构体由结构中的主功能代码或次功能代码成员指定。
- en: <samp class="SANS_TheSansMonoCd_W7Bold_B_11">IoStatus</samp>   A structure that
    contains the completion status of the I/O operation set by the filter manager.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W7Bold_B_11">IoStatus</samp>   一个结构体，包含由过滤器管理器设置的I/O操作的完成状态。
- en: <samp class="SANS_TheSansMonoCd_W7Bold_B_11">TagData</samp>   A pointer to an
    <samp class="SANS_TheSansMonoCd_W5Regular_11">FLT_TAG_DATA_BUFFER</samp> structure
    containing information about reparse points, such as in the case of NTFS hard
    links or junctions.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W7Bold_B_11">TagData</samp>   指向一个<samp class="SANS_TheSansMonoCd_W5Regular_11">FLT_TAG_DATA_BUFFER</samp>结构的指针，该结构包含关于重新解析点的信息，例如在NTFS硬链接或连接点的情况下。
- en: <samp class="SANS_TheSansMonoCd_W7Bold_B_11">RequestorMode</samp>   A value
    indicating whether the request came from user mode or kernel mode.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W7Bold_B_11">RequestorMode</samp>   一个值，表示请求是来自用户模式还是内核模式。
- en: This structure contains much of the information that an EDR agent needs to track
    file operations on the system. The second parameter passed to the pre-operation
    callback, a pointer to an <samp class="SANS_TheSansMonoCd_W5Regular_11">FLT_RELATED_OBJECTS</samp>
    structure, provides supplemental information. This structure contains opaque pointers
    to the object associated with the operation, including the volume, minifilter
    instance, and file object (if present). The last parameter, <samp class="SANS_TheSansMonoCd_W5Regular_11">CompletionContext</samp>,
    contains an optional context pointer that will be passed to the correlated post-operation
    callback if the minifilter returns <samp class="SANS_TheSansMonoCd_W5Regular_11">FLT_PREOP_SUCCESS_WITH_CALLBACK</samp>
    or <samp class="SANS_TheSansMonoCd_W5Regular_11">FLT_PREOP_SYNCHRONIZE</samp>.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 该结构包含 EDR 代理需要追踪系统中文件操作的大部分信息。传递给预操作回调的第二个参数是指向 <samp class="SANS_TheSansMonoCd_W5Regular_11">FLT_RELATED_OBJECTS</samp>
    结构的指针，提供补充信息。该结构包含指向与操作相关联的对象的不可透明指针，包括卷、迷你过滤器实例和文件对象（如果存在）。最后一个参数 <samp class="SANS_TheSansMonoCd_W5Regular_11">CompletionContext</samp>
    包含一个可选的上下文指针，如果迷你过滤器返回 <samp class="SANS_TheSansMonoCd_W5Regular_11">FLT_PREOP_SUCCESS_WITH_CALLBACK</samp>
    或 <samp class="SANS_TheSansMonoCd_W5Regular_11">FLT_PREOP_SYNCHRONIZE</samp>，该指针将传递给相关联的后操作回调。
- en: 'On completion of the routine, the minifilter must return an <samp class="SANS_TheSansMonoCd_W5Regular_11">FLT_PREOP_CALLBACK_STATUS</samp>
    value. Pre-operation callbacks may return one of seven supported values:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 在例程完成后，迷你过滤器必须返回一个 <samp class="SANS_TheSansMonoCd_W5Regular_11">FLT_PREOP_CALLBACK_STATUS</samp>
    值。预操作回调可能返回七种支持的值之一：
- en: <samp class="SANS_TheSansMonoCd_W7Bold_B_11">FLT_PREOP_SUCCESS_WITH_CALLBACK
    (0)</samp>
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W7Bold_B_11">FLT_PREOP_SUCCESS_WITH_CALLBACK
    (0)</samp>
- en: Return the I/O operation to the filter manager for processing and instruct it
    to call the minifilter’s post-operation callback during completion.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 将 I/O 操作传回过滤器管理器进行处理，并指示它在完成期间调用迷你过滤器的后操作回调。
- en: <samp class="SANS_TheSansMonoCd_W7Bold_B_11">FLT_PREOP_SUCCESS_NO_CALLBACK (1)</samp>
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W7Bold_B_11">FLT_PREOP_SUCCESS_NO_CALLBACK (1)</samp>
- en: Return the I/O operation to the filter manager for processing and instruct it
    *not* to call the minifilter’s post-operation callback during completion.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 将 I/O 操作传回过滤器管理器进行处理，并指示它在完成期间*不要*调用迷你过滤器的后操作回调。
- en: <samp class="SANS_TheSansMonoCd_W7Bold_B_11">FLT_PREOP_PENDING (2)</samp>
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W7Bold_B_11">FLT_PREOP_PENDING (2)</samp>
- en: Pend the I/O operation and do not process it further until the minifilter calls
    <samp class="SANS_TheSansMonoCd_W5Regular_11">fltmgr!FltCompletePendedPreOperation()</samp>.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 挂起 I/O 操作，并且在迷你过滤器调用 <samp class="SANS_TheSansMonoCd_W5Regular_11">fltmgr!FltCompletePendedPreOperation()</samp>
    之前，不进一步处理它。
- en: <samp class="SANS_TheSansMonoCd_W7Bold_B_11">FLT_PREOP_DISALLOW_FASTIO (3)</samp>
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W7Bold_B_11">FLT_PREOP_DISALLOW_FASTIO (3)</samp>
- en: Block the fast I/O path in the operation. This code instructs the filter manager
    not to pass the operation to any other minifilters below the current one in the
    stack and to only call the post-operation callbacks of those drivers at higher
    altitudes.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 阻止操作中的快速 I/O 路径。此代码指示过滤器管理器不要将操作传递给栈中当前过滤器下方的任何其他迷你过滤器，并且仅调用在较高层级的驱动程序的后操作回调。
- en: <samp class="SANS_TheSansMonoCd_W7Bold_B_11">FLT_PREOP_COMPLETE (4)</samp>
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W7Bold_B_11">FLT_PREOP_COMPLETE (4)</samp>
- en: Instruct the filter manager not to send the request to minifilters below the
    current driver in the stack and to only call the post-operation callbacks of those
    minifilters above it in the driver stack.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 指示过滤器管理器不要将请求发送到当前驱动栈下方的迷你过滤器，并且仅调用当前驱动栈中上述迷你过滤器的后操作回调。
- en: <samp class="SANS_TheSansMonoCd_W7Bold_B_11">FLT_PREOP_SYNCHRONIZE (5)</samp>
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W7Bold_B_11">FLT_PREOP_SYNCHRONIZE (5)</samp>
- en: Pass the request back to the filter manager but don’t complete it. This code
    ensures that the minifilter’s post-operation callback is called at IRQL ≤ *APC_LEVEL*
    in the context of the original thread.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 将请求传回过滤器管理器，但不完成它。此代码确保迷你过滤器的后操作回调在 IRQL ≤ *APC_LEVEL* 的原线程上下文中被调用。
- en: <samp class="SANS_TheSansMonoCd_W7Bold_B_11">FLT_PREOP_DISALLOW_FSFILTER_IO
    (6)</samp>
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W7Bold_B_11">FLT_PREOP_DISALLOW_FSFILTER_IO
    (6)</samp>
- en: Disallow a fast <samp class="SANS_TheSansMonoCd_W5Regular_11">QueryOpen</samp>
    operation and force the operation down the slower path, causing the I/O manager
    to process the request using an open, query, or close operation on the file.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 禁止快速的 <samp class="SANS_TheSansMonoCd_W5Regular_11">QueryOpen</samp> 操作，并强制操作走较慢的路径，导致
    I/O 管理器使用打开、查询或关闭操作处理该请求。
- en: The filter manager invokes the pre-operation callbacks for all minifilters that
    have registered functions for the I/O operation being processed before passing
    their requests to the filesystem, beginning with the highest altitude.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 过滤器管理器在将请求传递给文件系统之前，调用所有为正在处理的I/O操作注册了函数的迷你过滤器的前操作回调，从最高的优先级开始。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Defining Post-operation
    Callbacks</samp>
  id: totrans-137
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">定义后操作回调</samp>
- en: After the filesystem performs the operations defined in every minifilter’s pre-operation
    callbacks, control is passed up the filter stack to the filter manager. The filter
    manager then invokes the post-operation callbacks of all minifilters for the request
    type, beginning with the lowest altitude. These post-operation callbacks have
    a similar definition to the pre-operation routines, as shown in [Listing 6-5](#list6-5).
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 在文件系统执行每个迷你过滤器的前操作回调所定义的操作后，控制权会传递到过滤器栈的过滤器管理器。然后，过滤器管理器从最低优先级开始，调用所有迷你过滤器的后操作回调。这些后操作回调的定义与前操作回调例程类似，如[列表
    6-5](#list6-5)所示。
- en: '[PRE4]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Listing 6-5: Post-operation callback routine definitions'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 6-5：后操作回调例程定义
- en: Two notable differences here are the addition of the <samp class="SANS_TheSansMonoCd_W5Regular_11">Flags</samp>
    parameter and the different return type. The only documented flag that a minifilter
    can pass is <samp class="SANS_TheSansMonoCd_W5Regular_11">FLTFL_POST_OPERATION_DRAINING</samp>,
    which indicates that the minifilter is in the process of unloading. Additionally,
    post-operation callbacks can return different statuses. If the callback returns
    <samp class="SANS_TheSansMonoCd_W5Regular_11">FLT_POSTOP_FINISHED_PROCESSING</samp>
    (*0*), the minifilter has completed its post-operation callback routine and is
    passing control back to the filter manager to continue processing the I/O request.
    If it returns <samp class="SANS_TheSansMonoCd_W5Regular_11">FLT_POSTOP_MORE_PROCESSING_REQUIRED</samp>
    (*1*), the minifilter has posted the IRP-based I/O operation to a work queue and
    halted completion of the request until the work item completes, and it calls <samp
    class="SANS_TheSansMonoCd_W5Regular_11">fltmgr!FltCompletePendedPostOperation()</samp>.
    Lastly, if it returns <samp class="SANS_TheSansMonoCd_W5Regular_11">FLT_POSTOP_DISALLOW_FSFILTER_IO</samp>
    (*2*), the minifilter is disallowing a fast <samp class="SANS_TheSansMonoCd_W5Regular_11">QueryOpen</samp>
    operation and forcing the operation down the slower path. This is the same as
    <samp class="SANS_TheSansMonoCd_W5Regular_11">FLT_PREOP_DISALLOW_FSFILTER_IO</samp>.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有两个显著的区别：增加了<samp class="SANS_TheSansMonoCd_W5Regular_11">Flags</samp>参数和不同的返回类型。迷你过滤器唯一可以传递的已记录标志是<samp
    class="SANS_TheSansMonoCd_W5Regular_11">FLTFL_POST_OPERATION_DRAINING</samp>，它表示迷你过滤器正在卸载过程中。此外，后操作回调可以返回不同的状态。如果回调返回<samp
    class="SANS_TheSansMonoCd_W5Regular_11">FLT_POSTOP_FINISHED_PROCESSING</samp>
    (*0*)，表示迷你过滤器已完成其后操作回调例程，并将控制权返回给过滤器管理器以继续处理I/O请求。如果返回<samp class="SANS_TheSansMonoCd_W5Regular_11">FLT_POSTOP_MORE_PROCESSING_REQUIRED</samp>
    (*1*)，表示迷你过滤器已将基于IRP的I/O操作发布到工作队列，并暂停请求的完成，直到工作项完成，然后调用<samp class="SANS_TheSansMonoCd_W5Regular_11">fltmgr!FltCompletePendedPostOperation()</samp>。最后，如果返回<samp
    class="SANS_TheSansMonoCd_W5Regular_11">FLT_POSTOP_DISALLOW_FSFILTER_IO</samp>
    (*2*)，表示迷你过滤器不允许快速<samp class="SANS_TheSansMonoCd_W5Regular_11">QueryOpen</samp>操作，并强制该操作走较慢的路径。这与<samp
    class="SANS_TheSansMonoCd_W5Regular_11">FLT_PREOP_DISALLOW_FSFILTER_IO</samp>相同。
- en: Post-operation callbacks have some notable limitations that reduce their viability
    for security monitoring. The first is that they’re invoked in an arbitrary thread
    unless the pre-operation callback passes the <samp class="SANS_TheSansMonoCd_W5Regular_11">FLT_PREOP_SYNCHRONIZE</samp>
    flag, preventing the system from attributing the operation to the requesting application.
    Next is that post-operation callbacks are invoked at IRQL ≤ *DISPATCH_LEVEL*.
    This means that certain operations are restricted, including accessing most synchronization
    primitives (for example, mutexes), calling kernel APIs that require an IRQL ≤
    *DISPATCH_LEVEL*, and accessing paged memory. One workaround to these limitations
    involves delaying the execution of the post-operation callback via the use of
    <samp class="SANS_TheSansMonoCd_W5Regular_11">fltmgr!FltDoCompletionProcessingWhenSafe()</samp>,
    but this solution has its own challenges.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 后操作回调有一些显著的限制，减少了它们在安全监控中的可行性。首先，它们会在任意线程中调用，除非前操作回调传递了<samp class="SANS_TheSansMonoCd_W5Regular_11">FLT_PREOP_SYNCHRONIZE</samp>标志，防止系统将操作归因于请求的应用程序。接下来是，后操作回调在IRQL
    ≤ *DISPATCH_LEVEL* 时调用。这意味着某些操作受到限制，包括访问大多数同步原语（例如互斥锁）、调用需要IRQL ≤ *DISPATCH_LEVEL*的内核API，以及访问分页内存。解决这些限制的一种方法是通过使用<samp
    class="SANS_TheSansMonoCd_W5Regular_11">fltmgr!FltDoCompletionProcessingWhenSafe()</samp>延迟后操作回调的执行，但该解决方案也有其挑战。
- en: The array of these <samp class="SANS_TheSansMonoCd_W5Regular_11">FLT_OPERATION_REGISTRATION</samp>
    structures passed in the <samp class="SANS_TheSansMonoCd_W5Regular_11">OperationRegistration</samp>
    member of <samp class="SANS_TheSansMonoCd_W5Regular_11">FLT_REGISTRATION</samp>
    may look like [Listing 6-6](#list6-6).
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 这些<samp class="SANS_TheSansMonoCd_W5Regular_11">FLT_OPERATION_REGISTRATION</samp>结构体数组作为<samp
    class="SANS_TheSansMonoCd_W5Regular_11">FLT_REGISTRATION</samp>的<code>OperationRegistration</code>成员传递，可能如下所示：[列表
    6-6](#list6-6)。
- en: '[PRE5]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Listing 6-6: An array of operation registration callback structures'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 6-6：一个操作注册回调结构体数组
- en: This array registers pre- and post-operation callbacks for <samp class="SANS_TheSansMonoCd_W5Regular_11">IRP_MJ_CREATE</samp>
    and only pre-operation callbacks for <samp class="SANS_TheSansMonoCd_W5Regular_11">IRP_MJ_READ</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">IRP_MJ_WRITE</samp>. No flags
    are passed in for any of the target operations. Also note that the final element
    in the array is <samp class="SANS_TheSansMonoCd_W5Regular_11">IRP_MJ_OPERATION_END</samp>.
    Microsoft requires this value to be present at the end of the array, and it serves
    no functional purpose in the context of monitoring.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 该数组为<samp class="SANS_TheSansMonoCd_W5Regular_11">IRP_MJ_CREATE</samp>注册了前后操作回调，为<samp
    class="SANS_TheSansMonoCd_W5Regular_11">IRP_MJ_READ</samp>和<samp class="SANS_TheSansMonoCd_W5Regular_11">IRP_MJ_WRITE</samp>仅注册了前操作回调。对于任何目标操作都没有传入标志。此外，请注意数组中的最后一个元素是<samp
    class="SANS_TheSansMonoCd_W5Regular_11">IRP_MJ_OPERATION_END</samp>。微软要求该值出现在数组的末尾，并且在监控上下文中没有功能用途。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Defining Optional
    Callbacks</samp>
  id: totrans-147
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">定义可选回调</samp>
- en: The last section in the <samp class="SANS_TheSansMonoCd_W5Regular_11">FLT_REGISTRATION</samp>
    structure contains the optional callbacks. The first three callbacks, <samp class="SANS_TheSansMonoCd_W5Regular_11">FilterUnloadCallback</samp>,
    <samp class="SANS_TheSansMonoCd_W5Regular_11">InstanceSetupCallback</samp>, and
    <samp class="SANS_TheSansMonoCd_W5Regular_11">InstanceQueryTeardownCallback</samp>,
    may all technically be null, but this will impose some restrictions on the minifilter
    and system behavior. For example, the system won’t be able to unload the minifilter
    or attach to new filesystem volumes. The rest of the callbacks in this section
    of the structure relate to various functionality provided by the minifilter. These
    include things such as the interception of filename requests (<samp class="SANS_TheSansMonoCd_W5Regular_11">GenerateFileNameCallback</samp>)
    and filename normalization (<samp class="SANS_TheSansMonoCd_W5Regular_11">NormalizeNameComponentCallback</samp>).
    In general, only the first three semi-optional callbacks are registered, and the
    rest are rarely used.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W5Regular_11">FLT_REGISTRATION</samp> 结构体中的最后一部分包含了可选的回调函数。前三个回调函数：<samp
    class="SANS_TheSansMonoCd_W5Regular_11">FilterUnloadCallback</samp>、<samp class="SANS_TheSansMonoCd_W5Regular_11">InstanceSetupCallback</samp>
    和 <samp class="SANS_TheSansMonoCd_W5Regular_11">InstanceQueryTeardownCallback</samp>，技术上都可以为空，但这将对迷你过滤器和系统行为产生一定的限制。例如，系统将无法卸载该迷你过滤器或附加新的文件系统卷。结构体中该部分的其他回调函数与迷你过滤器提供的各种功能相关。例如，拦截文件名请求（<samp
    class="SANS_TheSansMonoCd_W5Regular_11">GenerateFileNameCallback</samp>）和文件名规范化（<samp
    class="SANS_TheSansMonoCd_W5Regular_11">NormalizeNameComponentCallback</samp>）。通常，只有前三个半可选的回调函数会被注册，其余的很少使用。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Activating the Minifilter</samp>
  id: totrans-149
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">激活迷你过滤器</samp>
- en: After all callback routines have been set, a pointer to the created <samp class="SANS_TheSansMonoCd_W5Regular_11">FLT_REGISTRATION</samp>
    structure is passed as the second parameter to <samp class="SANS_TheSansMonoCd_W5Regular_11">fltmgr!FltRegisterFilter()</samp>.
    Upon completion of this function, an opaque filter pointer (<samp class="SANS_TheSansMonoCd_W5Regular_11">PFLT_FILTER</samp>)
    is returned to the caller in the <samp class="SANS_TheSansMonoCd_W5Regular_11">RetFilter</samp>
    parameter. This pointer uniquely identifies the minifilter and remains static
    as long as the driver is loaded on the system. This pointer is typically preserved
    as a global variable.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 在设置完所有回调例程后，创建的 <samp class="SANS_TheSansMonoCd_W5Regular_11">FLT_REGISTRATION</samp>
    结构体的指针作为第二个参数传递给 <samp class="SANS_TheSansMonoCd_W5Regular_11">fltmgr!FltRegisterFilter()</samp>。该函数完成后，会返回一个不透明的过滤器指针
    (<samp class="SANS_TheSansMonoCd_W5Regular_11">PFLT_FILTER</samp>) 给调用者，返回值保存在
    <samp class="SANS_TheSansMonoCd_W5Regular_11">RetFilter</samp> 参数中。这个指针唯一标识了该迷你过滤器，并且只要驱动程序在系统中加载，该指针将保持不变。这个指针通常会作为全局变量保留。
- en: When the minifilter is ready to start processing events, it passes the <samp
    class="SANS_TheSansMonoCd_W5Regular_11">PFLT_FILTER</samp> pointer to <samp class="SANS_TheSansMonoCd_W5Regular_11">fltmgr!FltStartFilter()</samp>.
    This notifies the filter manager that the driver is ready to attach to filesystem
    volumes and start filtering I/O requests. After this function returns, the minifilter
    will be considered active and sit inline of all relevant filesystem operations.
    The callbacks registered in the <samp class="SANS_TheSansMonoCd_W5Regular_11">FLT_REGISTRATION</samp>
    structure will be invoked for their associated major functions. Whenever the minifilter
    is ready to unload itself, it passes the <samp class="SANS_TheSansMonoCd_W5Regular_11">PFLT_FILTER</samp>
    pointer to <samp class="SANS_TheSansMonoCd_W5Regular_11">fltmgr!FltUnregisterFilter()</samp>
    to remove any contexts that the minifilter has set on files, volumes, and other
    components and calls the registered <samp class="SANS_TheSansMonoCd_W5Regular_11">InstanceTeardownStartCallback</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">InstanceTeardownCompleteCallback</samp>
    functions.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 当minifilter准备开始处理事件时，它将<sup class="SANS_TheSansMonoCd_W5Regular_11">PFLT_FILTER</sup>指针传递给<sup
    class="SANS_TheSansMonoCd_W5Regular_11">fltmgr!FltStartFilter()</sup>。这会通知过滤器管理器，驱动程序已准备好附加到文件系统卷并开始过滤I/O请求。此函数返回后，minifilter将被视为活动，并插入所有相关的文件系统操作中。<sup
    class="SANS_TheSansMonoCd_W5Regular_11">FLT_REGISTRATION</sup>结构中注册的回调函数将根据其关联的主要功能进行调用。每当minifilter准备卸载时，它会将<sup
    class="SANS_TheSansMonoCd_W5Regular_11">PFLT_FILTER</sup>指针传递给<sup class="SANS_TheSansMonoCd_W5Regular_11">fltmgr!FltUnregisterFilter()</sup>，以移除minifilter在文件、卷和其他组件上设置的任何上下文，并调用注册的<sup
    class="SANS_TheSansMonoCd_W5Regular_11">InstanceTeardownStartCallback</sup>和<sup
    class="SANS_TheSansMonoCd_W5Regular_11">InstanceTeardownCompleteCallback</sup>函数。
- en: <samp class="SANS_Futura_Std_Bold_B_11">Managing a Minifilter</samp>
  id: totrans-152
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: <sup class="SANS_Futura_Std_Bold_B_11">管理一个Minifilter</sup>
- en: Compared to working with other drivers, the process of installing, loading,
    and unloading a minifilter requires special consideration. This is because minifilters
    have specific requirements related to the setting of registry values. To make
    the installation process easier, Microsoft recommends installing minifilters through
    a *setup information (INF)* file. The format of these INF files is beyond the
    scope of this book, but there are some interesting details relevant to how minifilters
    work that are worth mentioning.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 与其他驱动程序的工作相比，安装、加载和卸载minifilter的过程需要特别考虑。这是因为minifilter在设置注册表值方面有特定的要求。为了简化安装过程，微软建议通过*设置信息（INF）*文件来安装minifilter。这些INF文件的格式超出了本书的讨论范围，但有一些与minifilter工作相关的有趣细节，值得一提。
- en: The <samp class="SANS_TheSansMonoCd_W5Regular_11">ClassGuid</samp> entry in
    the <samp class="SANS_TheSansMonoCd_W5Regular_11">Version</samp> section of the
    INF file is a GUID that corresponds to the desired load-order group (for example,
    <samp class="SANS_TheSansMonoCd_W5Regular_11">FSFilter Activity Monitor</samp>).
    In the <samp class="SANS_TheSansMonoCd_W5Regular_11">AddRegistry</samp> section
    of the file, which specifies the registry keys to be created, you’ll find information
    about the minifilter’s altitude. This section may include multiple similar entries
    to describe where the system should load various instances of the minifilter.
    The altitude can be set to the name of a variable (for example, <samp class="SANS_TheSansMonoCd_W5Regular_11">%MyAltitude%</samp>)
    defined in the <samp class="SANS_TheSansMonoCd_W5Regular_11">Strings</samp> section
    of the INF file. Lastly, the <samp class="SANS_TheSansMonoCd_W5Regular_11">ServiceType</samp>
    entry under the <samp class="SANS_TheSansMonoCd_W5Regular_11">ServiceInstall</samp>
    section is always set to <samp class="SANS_TheSansMonoCd_W5Regular_11">SERVICE_FILE_SYSTEM_DRIVER</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">(2)</samp>.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 在INF文件的<sup class="SANS_TheSansMonoCd_W5Regular_11">Version</sup>部分，<sup class="SANS_TheSansMonoCd_W5Regular_11">ClassGuid</sup>条目是一个GUID，它对应于所需的加载顺序组（例如，<sup
    class="SANS_TheSansMonoCd_W5Regular_11">FSFilter Activity Monitor</sup>）。在文件的<sup
    class="SANS_TheSansMonoCd_W5Regular_11">AddRegistry</sup>部分，指定了要创建的注册表键，你将找到有关minifilter的高度信息。此部分可能包含多个类似的条目，以描述系统应在哪些位置加载minifilter的不同实例。高度可以设置为在INF文件的<sup
    class="SANS_TheSansMonoCd_W5Regular_11">Strings</sup>部分中定义的变量名称（例如，<sup class="SANS_TheSansMonoCd_W5Regular_11">%MyAltitude%</sup>）。最后，<sup
    class="SANS_TheSansMonoCd_W5Regular_11">ServiceType</sup>条目位于<sup class="SANS_TheSansMonoCd_W5Regular_11">ServiceInstall</sup>部分，总是设置为<sup
    class="SANS_TheSansMonoCd_W5Regular_11">SERVICE_FILE_SYSTEM_DRIVER</sup> <sup
    class="SANS_TheSansMonoCd_W5Regular_11">(2)</sup>。
- en: Executing the INF installs the driver, copying files to their specified locations
    and setting up the required registry keys. [Listing 6-7](#list6-7) shows an example
    of what this looks like in the registry keys for *WdFilter*, Microsoft Defender’s
    minifilter driver.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 执行 INF 安装程序会安装驱动程序，将文件复制到指定位置并设置所需的注册表键。[示例 6-7](#list6-7) 显示了 *WdFilter*（微软
    Defender 的 minifilter 驱动程序）在注册表键中的配置示例。
- en: '[PRE6]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Listing 6-7: Viewing WdFilter’s altitude with PowerShell'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 6-7：使用 PowerShell 查看 WdFilter 的高度
- en: The <samp class="SANS_TheSansMonoCd_W5Regular_11">Start</samp> key dictates
    when the minifilter will be loaded. The service can be started and stopped using
    the Service Control Manager APIs, as well as through a client such as *sc.exe*
    or the Services snap-in. In addition, we can manage minifilters with the filter
    manager library, *FltLib*, which is leveraged by the *fltmc.exe* utility included
    by default on Windows. This setup also includes setting the altitude of the minifilter,
    which for *WdFilter* is 328010.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W5Regular_11">Start</samp> 键决定了 minifilter 何时被加载。该服务可以通过服务控制管理器
    API 启动和停止，也可以通过如 *sc.exe* 或服务管理单元等客户端进行管理。此外，我们还可以通过过滤器管理器库 *FltLib* 来管理 minifilter，该库由
    *fltmc.exe* 实用程序提供，默认包含在 Windows 中。此设置还包括设置 minifilter 的高度，对于 *WdFilter* 来说，高度为
    328010。
- en: <samp class="SANS_Futura_Std_Bold_B_11">Detecting Adversary Tradecraft with
    Minifilters</samp>
  id: totrans-159
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">通过 Minifilters 检测对抗者技术</samp>
- en: Now that you understand the inner workings of minifilters, let’s explore how
    they contribute to the detection of attacks on a system. As discussed in “Writing
    a Minifilter” on [page 108](#sec3), a minifilter can register pre- or post-operation
    callbacks for activities that target any filesystem, including NTFS, named pipes,
    and mailslots. This provides an EDR with an extremely powerful sensor for detecting
    adversary activity on the host.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经理解了 minifilter 的内部工作原理，让我们来探讨它们是如何帮助检测系统中的攻击的。如在“编写 Minifilter”一节中所讨论的，[第
    108 页](#sec3)，minifilter 可以注册针对任何文件系统的操作前或操作后回调，包括 NTFS、命名管道和邮件槽。这为 EDR 提供了一个极其强大的传感器，用于检测主机上的对抗者活动。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">File Detections</samp>
  id: totrans-161
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">文件检测</samp>
- en: If an adversary interacts with the filesystem, such as by creating new files
    or modifying the contents of existing files, the minifilter has an opportunity
    to detect the behavior. Modern attacks have tended to avoid dropping artifacts
    directly onto the host filesystem in this way, embracing the “disk is lava” mentality,
    but many hacking tools continue to interact with files due to limitations of the
    APIs being leveraged. For example, consider <samp class="SANS_TheSansMonoCd_W5Regular_11">dbghelp!MiniDumpWriteDump()</samp>,
    a function used to create process memory dumps. This API requires that the caller
    pass in a handle to a file for the dump to be written to. The attacker must work
    with files if they want to use this API, so any minifilter that processes <samp
    class="SANS_TheSansMonoCd_W5Regular_11">IRP_MJ_CREATE</samp> or <samp class="SANS_TheSansMonoCd_W5Regular_11">IRP_MJ_WRITE</samp>
    I/O operations can indirectly detect those memory-dumping operations.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 如果对抗者与文件系统进行交互，例如创建新文件或修改现有文件的内容，minifilter 就有机会检测到这种行为。现代攻击倾向于避免直接将工件丢到主机文件系统中，采用“磁盘即熔岩”的思维方式，但许多黑客工具由于所使用的
    API 限制，仍然继续与文件进行交互。例如，考虑 <samp class="SANS_TheSansMonoCd_W5Regular_11">dbghelp!MiniDumpWriteDump()</samp>，这是一个用于创建进程内存转储的函数。此
    API 要求调用者传入一个文件句柄，用于写入转储数据。如果攻击者想使用这个 API，就必须与文件进行交互，因此任何处理 <samp class="SANS_TheSansMonoCd_W5Regular_11">IRP_MJ_CREATE</samp>
    或 <samp class="SANS_TheSansMonoCd_W5Regular_11">IRP_MJ_WRITE</samp> I/O 操作的 minifilter
    都可以间接检测到这些内存转储操作。
- en: Additionally, the attacker has no control over the format of the data being
    written to the file, allowing a minifilter to coordinate with a scanner to detect
    a memory-dump file without using function hooking. An attacker might try to work
    around this by opening a handle to an existing file and overwriting its content
    with the dump of the target process’s memory, but a minifilter monitoring <samp
    class="SANS_TheSansMonoCd_W5Regular_11">IRP_MJ_CREATE</samp> could still detect
    this activity, as both the creation of a new file and the opening of a handle
    to an existing file would trigger it.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，攻击者无法控制写入文件的数据格式，这使得微筛选器能够与扫描器协作，检测内存转储文件，而无需使用函数挂钩。攻击者可能试图通过打开现有文件的句柄并将目标进程的内存转储覆盖其内容来规避这一点，但监控<samp
    class="SANS_TheSansMonoCd_W5Regular_11">IRP_MJ_CREATE</samp>的微筛选器仍然能够检测到这一活动，因为无论是创建新文件还是打开现有文件的句柄都会触发该请求。
- en: Some defenders use these concepts to implement *filesystem canaries*. These
    are files created in key locations that users should seldom, if ever, interact
    with. If an application other than a backup agent or the EDR requests a handle
    to a canary file, the minifilter can take immediate action, including crashing
    the system. Filesystem canaries provide strong (though at times brutal) anti-ransomware
    control, as ransomware tends to indiscriminately encrypt files on the host. By
    placing a canary file in a directory nested deep in the filesystem, hidden from
    the user but still in one of the paths typically targeted by ransomware, an EDR
    can limit the damage to the files that the ransomware encountered before reaching
    the canary.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 一些防御者使用这些概念来实现*文件系统金丝雀*。这些是创建在关键位置的文件，用户应该很少甚至永远不会与其交互。如果除了备份代理或EDR之外的应用程序请求打开金丝雀文件的句柄，微筛选器可以立即采取行动，包括使系统崩溃。文件系统金丝雀提供了强大的（虽然有时是残酷的）反勒索软件控制，因为勒索软件往往会肆意加密主机上的文件。通过将金丝雀文件放置在文件系统中深层的目录中，这些文件对用户隐藏，但仍位于勒索软件通常会攻击的路径之一，EDR可以将损害限制在勒索软件接触到金丝雀之前所加密的文件。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Named Pipe Detections</samp>
  id: totrans-165
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">命名管道检测</samp>
- en: Another key piece of adversary tradecraft that minifilters can detect highly
    effectively is the use of named pipes. Many command-and-control agents, like Cobalt
    Strike’s Beacon, make use of named pipes for tasking, I/O, and linking. Other
    offensive techniques, such as those that use token impersonation for privilege
    escalation, revolve around the creation of a named pipe. In both cases, a minifilter
    monitoring <samp class="SANS_TheSansMonoCd_W5Regular_11">IRP_MJ_CREATE_NAMED_PIPE</samp>
    requests would be able to detect the attacker’s behavior, in much the same way
    as those that detect file creation via <samp class="SANS_TheSansMonoCd_W5Regular_11">IRP_MJ_CREATE</samp>.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种对抗性技巧，微筛选器可以高效检测的关键手段是命名管道的使用。许多指挥控制代理，如Cobalt Strike的Beacon，都使用命名管道进行任务分配、I/O操作和链接。其他攻击技术，例如使用令牌冒充进行特权升级的技术，也围绕创建命名管道展开。在这两种情况下，监控<samp
    class="SANS_TheSansMonoCd_W5Regular_11">IRP_MJ_CREATE_NAMED_PIPE</samp>请求的微筛选器能够检测攻击者的行为，方式与通过<samp
    class="SANS_TheSansMonoCd_W5Regular_11">IRP_MJ_CREATE</samp>检测文件创建相似。
- en: Minifilters commonly look for the creation of anomalously named pipes, or those
    originating from atypical processes. This is useful because many tools used by
    adversaries rely on the use of named pipes, so an attacker who wants to blend
    in should pick pipe and host process names that are typical in the environment.
    Thankfully for attackers and defenders alike, Windows makes enumerating existing
    named pipes easy, and we can straightforwardly identify many of the common process-to-pipe
    relationships. One of the most well-known named pipes in the realm of security
    is *mojo*. When a Chromium process spawns, it creates several named pipes with
    the format *mojo.PID.TID.VALUE* for use by an IPC abstraction library called Mojo.
    This named pipe became popular after its inclusion in a well-known repository
    for documenting Cobalt Strike’s Malleable profile options.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 微筛选器通常会寻找创建异常命名的管道，或者那些来自不典型进程的管道。这是有用的，因为许多对手使用的工具依赖于命名管道的使用，所以想要伪装的攻击者会选择在环境中典型的管道和主机进程名称。幸运的是，对于攻击者和防御者来说，Windows使得枚举现有命名管道变得容易，我们可以直接识别出许多常见的进程与管道之间的关系。在安全领域，最著名的命名管道之一是*mojo*。当Chromium进程启动时，它会创建多个命名管道，格式为*mojo.PID.TID.VALUE*，供一个名为Mojo的IPC抽象库使用。这个命名管道因其被纳入一个著名的文档库来记录Cobalt
    Strike的可变配置选项而变得流行。
- en: There are a few problems with using this specific named pipe that a minifilter
    can detect. The main one is related to the structured formatting used for the
    name of the pipe. Because Cobalt Strike’s pipe name is a static attribute tied
    to the instance of the Malleable profile, it is immutable at runtime. This means
    that an adversary would need to accurately predict the process and thread IDs
    of their Beacon to ensure the attributes of their process match those of the pipe
    name format used by Mojo. Remember that minifilters with pre-operation callbacks
    for monitoring <samp class="SANS_TheSansMonoCd_W5Regular_11">IRP_MJ_CREATE_NAMED_PIPE</samp>
    requests are guaranteed to be invoked in the context of the calling thread. This
    means that when a Beacon process creates the “mojo” named pipe, the minifilter
    can check that its current context matches the information in the pipe name. Pseudocode
    to demonstrate this would look like that shown in [Listing 6-8](#list6-8).
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这个特定的命名管道存在一些问题，最小过滤器可以检测到。其中一个主要问题与管道名称的结构化格式有关。由于 Cobalt Strike 的管道名称是与可变配置文件实例相关联的静态属性，它在运行时是不可更改的。这意味着对手需要准确预测其
    Beacon 的进程和线程 ID，以确保其进程的属性与 Mojo 使用的管道名称格式匹配。请记住，带有预操作回调的最小过滤器，用于监控 <samp class="SANS_TheSansMonoCd_W5Regular_11">IRP_MJ_CREATE_NAMED_PIPE</samp>
    请求时，保证会在调用线程的上下文中被触发。这意味着当 Beacon 进程创建 “mojo” 命名管道时，最小过滤器可以检查其当前上下文是否与管道名称中的信息匹配。为了演示这一点，伪代码如下所示
    [列表 6-8](#list6-8)。
- en: '[PRE7]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Listing 6-8: Detecting anomalous Mojo named pipes'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 6-8：检测异常 Mojo 命名管道
- en: Since the format used in Mojo named pipes is known, we can simply concatenate
    the PID and TID ❶ of the thread creating the named pipe and ensure that it matches
    what is expected. If not, we can take some defensive action.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 Mojo 命名管道使用的格式已知，我们可以简单地将创建命名管道的线程的 PID 和 TID ❶ 连接起来，确保它们与预期匹配。如果不匹配，我们可以采取一些防御措施。
- en: Not every command inside Beacon will create a named pipe. There are certain
    functions that will create an anonymous pipe (as in, a pipe without a name), such
    as <samp class="SANS_TheSansMonoCd_W5Regular_11">execute-assembly</samp>. These
    types of pipes have limited operational viability, as their name can’t be referenced
    and code can interact with them through an open handle only. What they lose in
    functionality, however, they gain in evasiveness.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 并不是 Beacon 中的每个命令都会创建命名管道。有些函数会创建匿名管道（即没有名称的管道），比如 <samp class="SANS_TheSansMonoCd_W5Regular_11">execute-assembly</samp>。这类管道的操作性有限，因为它们的名称无法被引用，代码只能通过打开的句柄与其交互。然而，它们在功能上的不足换来了更强的隐蔽性。
- en: Riccardo Ancarani’s blog post “Detecting Cobalt Strike Default Modules via Named
    Pipe Analysis” details the OPSEC considerations related to Beacon’s usage of anonymous
    pipes. In his research, he found that while Windows components rarely used anonymous
    pipes, their creation could be profiled, and their creators could be used as viable
    *spawnto* binaries. These included *ngen.exe*, *wsmprovhost.exe*, and *firefox.exe*,
    among others. By setting their sacrificial processes to one of these executables,
    attackers could ensure that any actions resulting in the creation of anonymous
    pipes would likely remain undetected.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: Riccardo Ancarani 的博客文章《通过命名管道分析检测 Cobalt Strike 默认模块》详细描述了与 Beacon 使用匿名管道相关的
    OPSEC 考虑。在他的研究中，他发现尽管 Windows 组件很少使用匿名管道，但它们的创建是可以被分析的，而且创建者可以作为有效的 *spawnto*
    二进制文件使用。这些包括 *ngen.exe*、*wsmprovhost.exe* 和 *firefox.exe* 等。通过将其牺牲进程设置为这些可执行文件之一，攻击者可以确保任何导致匿名管道创建的操作很可能不会被检测到。
- en: Bear in mind, however, that activities making use of named pipes would still
    be vulnerable to detection, so operators would need to restrict their tradecraft
    to activities that create anonymous pipes only.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，请记住，利用命名管道的活动仍然会容易被检测到，因此操作员需要将其技术限制在仅创建匿名管道的活动上。
- en: <samp class="SANS_Futura_Std_Bold_B_11">Evading Minifilters</samp>
  id: totrans-175
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">规避最小过滤器</samp>
- en: 'Most strategies for evading an EDR’s minifilters rely on one of three techniques:
    unloading, prevention, or interference. Let’s walk through examples of each to
    demonstrate how we can use them to our advantage.'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 规避 EDR 最小过滤器的策略通常依赖于三种技术之一：卸载、预防或干扰。让我们通过一些例子来展示如何利用这些技术为自己谋取优势。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Unloading</samp>
  id: totrans-177
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">卸载</samp>
- en: The first technique is to completely unload the minifilter. While you’ll need
    administrator access to do this (specifically, the <samp class="SANS_TheSansMonoCd_W5Regular_11">SeLoadDriverPrivilege</samp>
    token privilege), it’s the most surefire way to evade the minifilter. After all,
    if the driver is no longer on the stack, it can’t capture events.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个技术是完全卸载minifilter。虽然你需要管理员访问权限才能执行此操作（特别是<sup class="SANS_TheSansMonoCd_W5Regular_11">SeLoadDriverPrivilege</sup>令牌权限），但这是避开minifilter的最可靠方法。毕竟，如果驱动程序不再堆栈中，它就无法捕获事件。
- en: Unloading the minifilter can be as simple as calling <samp class="SANS_TheSansMonoCd_W5Regular_11">fltmc.exe</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">unload</samp>, but if the vendor
    has put a lot of effort into hiding the presence of their minifilter, it might
    require complex custom tooling. To explore this idea further, let’s target Sysmon,
    whose minifilter, *SysmonDrv*, is configured in the registry, as shown in [Listing
    6-9](#list6-9).
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 卸载minifilter可能像调用<sup class="SANS_TheSansMonoCd_W5Regular_11">fltmc.exe</sup>
    <sup class="SANS_TheSansMonoCd_W5Regular_11">unload</sup>一样简单，但如果厂商付出了大量努力隐藏其minifilter的存在，可能需要复杂的定制工具。为了进一步探索这一点，让我们以Sysmon为目标，其minifilter
    *SysmonDrv* 配置在注册表中，如[Listing 6-9](#list6-9)所示。
- en: '[PRE8]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Listing 6-9: Using PowerShell to view SysmonDrv’s configuration'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: Listing 6-9：使用PowerShell查看SysmonDrv的配置
- en: By default, *SysmonDrv* has the altitude 385201, and we can easily unload it
    via a call to <samp class="SANS_TheSansMonoCd_W5Regular_11">fltmc.exe unload SysmonDrv</samp>,
    assuming the caller has the required privilege. Doing so would create a *FilterManager*
    event ID of 1, which indicates that a filesystem filter was unloaded, and a Sysmon
    event ID of 255, which indicates a driver communication failure. However, Sysmon
    will no longer receive events.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，*SysmonDrv*的高度为385201，我们可以通过调用<sup class="SANS_TheSansMonoCd_W5Regular_11">fltmc.exe
    unload SysmonDrv</sup>轻松卸载它，前提是调用者具有所需的权限。这样做会产生一个*FilterManager*事件ID为1，表示文件系统过滤器已被卸载，同时产生一个Sysmon事件ID为255，表示驱动程序通信失败。然而，Sysmon将不再接收到事件。
- en: To complicate this process for attackers, the minifilter sometimes uses a random
    service name to conceal its presence on the system. In the case of Sysmon, an
    administrator can implement this approach during installation by passing the <samp
    class="SANS_TheSansMonoCd_W5Regular_11">-d</samp> flag to the installer and specifying
    a new name. This prevents an attacker from using the built-in *fltmc.exe* utility
    unless they can also identify the service name.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 为了增加攻击者的难度，minifilter有时会使用随机的服务名称来掩盖其在系统上的存在。以Sysmon为例，管理员可以通过在安装时向安装程序传递<sup
    class="SANS_TheSansMonoCd_W5Regular_11">-d</sup>标志并指定一个新名称来实现这种方法。这可以防止攻击者使用内置的*fltmc.exe*工具，除非他们能够识别出服务名称。
- en: 'However, an attacker can abuse another feature of production minifilters to
    locate the driver and unload it: their altitudes. Because Microsoft reserves specific
    altitudes for certain vendors, an attacker can learn these values and then simply
    walk the registry or use <samp class="SANS_TheSansMonoCd_W5Regular_11">fltlib!FilterFindNext()</samp>
    to locate any driver with the altitude in question. We can’t use *fltmc.exe* to
    unload minifilters based on an altitude, but we can either resolve the driver’s
    name in the registry or pass the minifilter’s name to <samp class="SANS_TheSansMonoCd_W5Regular_11">fltlib!FilterUnload()</samp>
    for tooling that makes use of <samp class="SANS_TheSansMonoCd_W5Regular_11">fltlib!FilterFindNext()</samp>.
    This is how the Shhmon tool, which hunts and unloads *SysmonDrv*, works under
    the hood.'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，攻击者可以利用生产环境minifilters的另一个特性来定位驱动程序并卸载它：它们的高度。因为微软为某些厂商保留了特定的高度，攻击者可以学习这些值，然后简单地遍历注册表或使用<sup
    class="SANS_TheSansMonoCd_W5Regular_11">fltlib!FilterFindNext()</sup>来定位具有特定高度的驱动程序。我们不能使用*fltmc.exe*根据高度卸载minifilters，但我们可以在注册表中解析驱动程序的名称，或者将minifilter的名称传递给<sup
    class="SANS_TheSansMonoCd_W5Regular_11">fltlib!FilterUnload()</sup>，对于使用<sup class="SANS_TheSansMonoCd_W5Regular_11">fltlib!FilterFindNext()</sup>的工具来说，这是一种可行的方式。这就是Shhmon工具在背后如何工作，用于追踪并卸载*SysmonDrv*。
- en: Defenders could further thwart attackers by modifying the minifilter’s altitude.
    This isn’t recommended in production applications, however, because another application
    might already be using the chosen value. EDR agents sometimes operate across millions
    of devices, raising the odds of an altitude collision. To mitigate this risk,
    a vendor might compile a list of active minifilter allocations from Microsoft
    and choose one not already in use, although this strategy isn’t bulletproof.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 防御者可以通过修改 minifilter 的高度进一步阻止攻击者。然而，在生产环境中不推荐这样做，因为其他应用程序可能已经在使用所选择的值。EDR 代理有时会在数百万台设备上运行，这增加了高度冲突的可能性。为了降低这种风险，供应商可能会从
    Microsoft 编译一个活动 minifilter 分配列表，并选择一个尚未使用的值，尽管这种策略并非万无一失。
- en: In the case of Sysmon, defenders could either patch the installer to set the
    altitude value in the registry to a different value upon installation or manually
    change the altitude after installation by directly modifying the registry value.
    Since Windows doesn’t place any technical controls on altitudes, the engineer
    could move *SysmonDrv* to any altitude they wish. Bear in mind, however, that
    the altitude affects the minifilter’s position in the stack, so choosing too low
    a value could have unintended implications for the efficacy of the tool.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Sysmon 的情况下，防御者可以通过修改安装程序，在安装时将高度值设置为不同的值，或者通过直接修改注册表值在安装后手动更改高度。由于 Windows
    对高度没有任何技术控制，工程师可以将*SysmonDrv*移到任何他们希望的位置。然而，值得注意的是，高度影响 minifilter 在堆栈中的位置，因此选择过低的值可能会对工具的有效性产生意想不到的影响。
- en: Even with all these obfuscation methods applied, an attacker could still unload
    a minifilter. Starting in Windows 10, both the vendor and Microsoft must sign
    a production driver before it can be loaded onto the system, and because these
    signatures are meant to identify the drivers, they include information about the
    vendor that signed them. This information is often enough to tip an adversary
    off to the presence of the target minifilter. In practice, the attacker could
    walk the registry or use the <samp class="SANS_TheSansMonoCd_W5Regular_11">fltlib!FilterFindNext()</samp>
    approach to enumerate minifilters, extract the path to the driver on disk, and
    parse the digital signatures of all enumerated files until they’ve identified
    a file signed by an EDR. At that point, they can unload the minifilter using one
    of the previously covered methods.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 即使应用了所有这些混淆方法，攻击者仍然可以卸载 minifilter。从 Windows 10 开始，供应商和 Microsoft 必须在加载驱动程序到系统之前对其进行签名，且这些签名用于识别驱动程序，其中包含签名供应商的信息。此信息通常足以使对手察觉到目标
    minifilter 的存在。在实际操作中，攻击者可以遍历注册表，或者使用 <samp class="SANS_TheSansMonoCd_W5Regular_11">fltlib!FilterFindNext()</samp>
    方法枚举 minifilter，提取磁盘上驱动程序的路径，并解析所有枚举文件的数字签名，直到他们找出一个由 EDR 签名的文件。到那时，他们可以使用之前介绍的方法卸载
    minifilter。
- en: As you’ve just learned, there are no particularly great ways to hide a minifilter
    on the system. This doesn’t mean, however, that these obfuscations aren’t worthwhile.
    An attacker might lack the tooling or knowledge to counter the obfuscations, providing
    time for the EDR’s sensors to detect their activity without interference.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你刚刚了解到的那样，目前并没有特别好的方法来隐藏系统上的 minifilter。然而，这并不意味着这些混淆方法毫无价值。攻击者可能缺乏工具或知识来对抗这些混淆，从而为
    EDR 的传感器提供了在不受干扰的情况下检测其活动的时间。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Prevention</samp>
  id: totrans-189
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">预防</samp>
- en: To prevent filesystem operations from ever passing through an EDR’s minifilter,
    attackers can register their own minifilter and use it to force the completion
    of I/O operations. As an example, let’s register a malicious pre-operation callback
    for <samp class="SANS_TheSansMonoCd_W5Regular_11">IRP_MJ_WRITE</samp> requests,
    as shown in [Listing 6-10](#list6-10).
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 为了防止文件系统操作经过 EDR 的 minifilter，攻击者可以注册他们自己的 minifilter，并用它强制完成 I/O 操作。例如，我们可以为
    <samp class="SANS_TheSansMonoCd_W5Regular_11">IRP_MJ_WRITE</samp> 请求注册一个恶意的预操作回调，如
    [列表 6-10](#list6-10) 所示。
- en: '[PRE9]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Listing 6-10: Registering a malicious pre-operation callback routine'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 6-10：注册恶意的预操作回调例程
- en: When the filter manager invokes this callback routine, it must return an <samp
    class="SANS_TheSansMonoCd_W5Regular_11">FLT_PREOP_CALLBACK_STATUS</samp> value.
    One of the possible values, <samp class="SANS_TheSansMonoCd_W5Regular_11">FLT_PREOP_COMPLETE</samp>,
    tells the filter manager that the current minifilter is in the process of completing
    the request, so the request shouldn’t be passed to any minifilters below the current
    altitude. If a minifilter returns this value, it must set the <samp class="SANS_TheSansMonoCd_W5Regular_11">NTSTATUS</samp>
    value in the <samp class="SANS_TheSansMonoCd_W5Regular_11">Status</samp> member
    of the I/O status block to the operation’s final status. Antivirus engines whose
    minifilters communicate with user-mode scanning engines commonly use this functionality
    to determine whether malicious content is being written to a file. If the scanner
    indicates to the minifilter that the content is malicious, the minifilter completes
    the request and returns a failure status, such as <samp class="SANS_TheSansMonoCd_W5Regular_11">STATUS_VIRUS_INFECTED</samp>,
    to the caller.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 当过滤器管理器调用此回调例程时，它必须返回一个 <samp class="SANS_TheSansMonoCd_W5Regular_11">FLT_PREOP_CALLBACK_STATUS</samp>
    值。可能的值之一是 <samp class="SANS_TheSansMonoCd_W5Regular_11">FLT_PREOP_COMPLETE</samp>，它告诉过滤器管理器当前微过滤器正在完成请求，因此请求不应再传递给任何低于当前高度的微过滤器。如果微过滤器返回此值，它必须将
    <samp class="SANS_TheSansMonoCd_W5Regular_11">NTSTATUS</samp> 值设置到 I/O 状态块的 <samp
    class="SANS_TheSansMonoCd_W5Regular_11">Status</samp> 成员，表示操作的最终状态。那些微过滤器与用户模式扫描引擎通信的杀毒引擎通常会使用此功能来确定是否有恶意内容正在写入文件。如果扫描器通知微过滤器内容是恶意的，微过滤器将完成请求并返回失败状态，例如
    <samp class="SANS_TheSansMonoCd_W5Regular_11">STATUS_VIRUS_INFECTED</samp>，并将其返回给调用者。
- en: But attackers can abuse this feature of minifilters to prevent the security
    agent from ever intercepting their filesystem operations. Using the earlier callback
    we registered, this would look something like what’s shown in [Listing 6-11](#list6-11).
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 但攻击者可以利用这个微过滤器的特性，阻止安全代理拦截它们的文件系统操作。通过我们之前注册的回调，效果可能类似于[清单 6-11](#list6-11)中所示的内容。
- en: '[PRE10]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Listing 6-11: Intercepting write operations and forcing their completion'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 清单 6-11：拦截写操作并强制完成
- en: The attacker first inserts their malicious minifilter at an altitude higher
    than the minifilter belonging to the EDR. Inside the malicious minifilter’s pre-operation
    callback would exist logic to complete the I/O requests coming from the adversary’s
    processes in user mode ❶, preventing them from being passed down the stack to
    the EDR.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 攻击者首先将其恶意微过滤器插入到比 EDR 所有的微过滤器更高的高度。恶意微过滤器的预操作回调中将包含逻辑，用于完成来自对手进程的 I/O 请求❶，从而防止这些请求传递到堆栈下方的
    EDR。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Interference</samp>
  id: totrans-198
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">干扰</samp>
- en: A final evasion technique, interference, is built around the fact that a minifilter
    can alter members of the <samp class="SANS_TheSansMonoCd_W5Regular_11">FLT_CALLBACK_DATA</samp>
    structure passed to its callbacks on a request. An attacker can modify any members
    of this structure except the <samp class="SANS_TheSansMonoCd_W5Regular_11">RequestorMode</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">Thread</samp> members. This
    includes the file pointer in the <samp class="SANS_TheSansMonoCd_W5Regular_11">FLT_IO_PARAMETER_BLOCK</samp>
    structure’s <samp class="SANS_TheSansMonoCd_W5Regular_11">TargetFileObject</samp>
    member. The only requirement of the malicious minifilter is that it calls <samp
    class="SANS_TheSansMonoCd_W5Regular_11">fltmgr!FltSetCallbackDataDirty()</samp>,
    which indicates that the callback data structure has been modified when it is
    passing the request to minifilters lower in the stack.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 最终的规避技术——干扰，围绕着微过滤器可以在请求时修改传递给其回调的 <samp class="SANS_TheSansMonoCd_W5Regular_11">FLT_CALLBACK_DATA</samp>
    结构体的成员。攻击者可以修改该结构体中的任何成员，除了 <samp class="SANS_TheSansMonoCd_W5Regular_11">RequestorMode</samp>
    和 <samp class="SANS_TheSansMonoCd_W5Regular_11">Thread</samp> 成员。这包括 <samp class="SANS_TheSansMonoCd_W5Regular_11">FLT_IO_PARAMETER_BLOCK</samp>
    结构体中的 <samp class="SANS_TheSansMonoCd_W5Regular_11">TargetFileObject</samp> 成员。恶意微过滤器的唯一要求是它必须调用
    <samp class="SANS_TheSansMonoCd_W5Regular_11">fltmgr!FltSetCallbackDataDirty()</samp>，该函数会在将请求传递给堆栈下方的微过滤器时，指示回调数据结构已被修改。
- en: An adversary can abuse this behavior to pass bogus data to the minifilter associated
    with an EDR by inserting itself anywhere above it in the stack, modifying the
    data tied to the request and passing control back to the filter manager. A minifilter
    that receives the modified request may evaluate whether <samp class="SANS_TheSansMonoCd_W5Regular_11">FLTFL_CALLBACK_DATA_DIRTY</samp>,
    which is set by <samp class="SANS_TheSansMonoCd_W5Regular_11">fltmgr!FltSetCallbackDataDirty()</samp>,
    is present and act accordingly, but the data will still be modified.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 攻击者可以利用这种行为，通过将自己插入到堆栈中的任何位置，修改与请求相关的数据并将控制权返回给过滤器管理器，从而向与 EDR 相关联的 minifilter
    传递虚假数据。接收到修改后的请求的 minifilter 可能会评估是否存在 <samp class="SANS_TheSansMonoCd_W5Regular_11">FLTFL_CALLBACK_DATA_DIRTY</samp>，该标志由
    <samp class="SANS_TheSansMonoCd_W5Regular_11">fltmgr!FltSetCallbackDataDirty()</samp>
    设置，并据此采取行动，但数据仍然会被修改。
- en: <samp class="SANS_Futura_Std_Bold_B_11">Conclusion</samp>
  id: totrans-201
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">结论</samp>
- en: Minifilters are the de facto standard for monitoring filesystem activity on
    Windows, whether it be for NTFS, named pipes, or even mailslots. Their implementation
    is somewhat more complex than the drivers discussed earlier in this book, but
    the way they work is very similar; they sit inline of some system operation and
    receive data about the activity. Attackers can evade minifilters by abusing some
    logical issue in the sensor or even unloading the driver entirely, but most adversaries
    have adapted their tradecraft to drastically limit creating new artifacts on disk
    to reduce the chances of a minifilter picking up their activity.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: Minifilter 是 Windows 上监控文件系统活动的事实标准，无论是 NTFS、命名管道还是邮件插槽。它们的实现比本书早些章节中讨论的驱动程序更复杂一些，但它们的工作原理非常相似；它们位于某些系统操作的内联位置，接收关于活动的数据。攻击者可以通过利用传感器中的某些逻辑问题或完全卸载驱动程序来规避
    minifilter，但大多数对手已经调整了他们的技术，极大地限制了在磁盘上创建新工件的可能性，从而减少了 minifilter 识别其活动的机会。
