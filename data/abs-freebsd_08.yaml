- en: '**8'
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '**8'
- en: CONFIGURING NETWORKING**
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 配置网络**
- en: '![image](../images/common01.jpg)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/common01.jpg)'
- en: Now that you know enough networking to be dangerous, you can configure a network
    connection. While FreeBSD supports many different protocols, we’ll focus on the
    nearly ubiquitous Ethernet connection, generally delivered over CAT5 or CAT6 cables.^([1](footnote.xhtml#ch08fn1))
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您已经掌握了足够的网络知识，可以配置网络连接了。虽然FreeBSD支持许多不同的协议，但我们将专注于几乎无处不在的以太网连接，通常通过CAT5或CAT6电缆提供。^([1](footnote.xhtml#ch08fn1))
- en: We’ll start with the essentials for getting a host on the network and able to
    access other internet hosts. Raw TCP/IP connectivity isn’t enough, however; you
    also need the ability to resolve host names to IP addresses, so we’ll cover that
    next. Then we’ll talk about measuring network activity, performance, VLANs, and
    aggregating links.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从确保主机能够连接到网络并访问其他互联网主机的基本步骤开始。然而，原始的TCP/IP连接不足够；您还需要能够将主机名解析为IP地址的功能，因此接下来我们将介绍这一点。然后，我们将讨论网络活动的测量、性能、VLAN以及链路聚合。
- en: Before you can do any of that, though, you need some information.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在您做任何事情之前，您需要一些信息。
- en: '**Network Prerequisites**'
  id: totrans-6
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**网络先决条件**'
- en: 'If your network offers Dynamic Host Configuration Protocol (DHCP), you can
    connect to the network as a client without knowing anything about the network.
    A static IP address makes much more sense on a server, however. While the installer
    will configure the network for you, eventually every server needs changes. Both
    IPv4 and IPv6 require the following information:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您的网络提供动态主机配置协议（DHCP），您可以作为客户端连接到网络，而无需了解网络的任何信息。然而，在服务器上，静态IP地址更加合适。虽然安装程序会为您配置网络，但最终每台服务器都需要进行更改。IPv4和IPv6都需要以下信息：
- en: An IP address
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个IP地址
- en: The netmask for that IP address and protocol
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 该IP地址和协议的子网掩码
- en: The IP address of the default gateway
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 默认网关的IP地址
- en: Armed with this information, attach your system to the network with ifconfig(8)
    and route(8) and then make the configuration permanent in */etc/rc.conf*.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 拥有这些信息后，使用ifconfig(8)和route(8)将系统连接到网络，并将配置保存到*/etc/rc.conf*中。
- en: '***Configuring Changes with ifconfig(8)***'
  id: totrans-12
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***使用ifconfig(8)配置更改***'
- en: 'The ifconfig(8) program displays the interfaces on your computer and lets you
    configure them. Start by listing the existing interfaces on your system by running
    ifconfig(8) without any arguments:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: ifconfig(8)程序显示您计算机上的接口，并允许您配置它们。首先，通过不带任何参数运行ifconfig(8)来列出系统上现有的接口：
- en: '[PRE0]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Our first network interface is em0 ➊, or the first network card that uses the
    em(4) driver. The em(4) man page reveals that this is an Intel PRO/1000 card.
    You’ll then see basic information about this card ➋, including that it is in the
    UP state, meaning it’s either working or trying to work. It’s assigned the IPv4
    address 203.0.113.43 ➌ and the netmask 0xfffffff0 (or 255.255.255.240, per [Table
    7-2](ch07.xhtml#ch07tab2)). This card has two IPv6 addresses, the link-local address
    (beginning with fe80) ➍ and the global IPv6 address ➎. You’ll also see the MAC
    address ➏ and the connection speed ➐. Finally, the `status` entry shows that this
    card is active ➑: a cable is plugged in and we have a link light.'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的第一个网络接口是em0 ➊，即使用em(4)驱动程序的第一张网卡。em(4)的手册页显示，这是Intel PRO/1000卡。接下来，您将看到有关此卡的基本信息
    ➋，包括它处于UP状态，意味着它正在工作或正在尝试工作。它被分配了IPv4地址203.0.113.43 ➌和子网掩码0xfffffff0（或255.255.255.240，参见[表7-2](ch07.xhtml#ch07tab2)）。这张卡有两个IPv6地址，链路本地地址（以fe80开头）
    ➍和全局IPv6地址 ➎。您还会看到MAC地址 ➏和连接速度 ➐。最后，`status`条目显示该卡是活动的 ➑：电缆已插入，我们有连接指示灯。
- en: 'The second card, rl0, has almost none of this information associated with it.
    One key fact is the `no carrier` signal ➒: it’s not plugged in and there is no
    link light. This card is not in use.'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 第二张卡片，rl0，几乎没有任何相关信息。一个关键事实是`no carrier`信号 ➒：它没有插入，并且没有连接指示灯。这张卡片没有被使用。
- en: Finally we have the interface lo0 ➓, the loopback. This interface has the IPv4
    address 127.0.0.1 and IPv6 address ::1 on every machine. This loopback address
    is used when the machine talks to itself. This is a standard software interface,
    which does not have any associated physical hardware. Do not attempt to delete
    the loopback interface, and do not change its IP address—things will break in
    an amusing way if you do so. FreeBSD supports other software interfaces, such
    as disc(4), tap(4), gif(4), and many more.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们有lo0接口➓，即回环接口。该接口在每台机器上都有IPv4地址127.0.0.1和IPv6地址::1。这个回环地址用于机器与自己通信。这是一个标准的软件接口，没有关联的物理硬件。不要尝试删除回环接口，也不要更改其IP地址——如果这么做，系统会以一种有趣的方式出错。FreeBSD还支持其他软件接口，如disc(4)、tap(4)、gif(4)等。
- en: '***Adding an IP to an Interface***'
  id: totrans-18
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***向接口添加IP地址***'
- en: The install process will configure any network cards you have working at install
    time. If you didn’t configure the network for all of your cards during the setup
    process, or if you add or remove network cards after finishing the install, you
    can assign an IP address to your network card with ifconfig(8). You need the card’s
    assigned IP address and netmask.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 安装过程将会配置所有在安装时可用的网络卡。如果在安装过程中没有配置所有网卡的网络，或者在安装完成后你添加或移除网络卡，你可以通过ifconfig(8)为网卡分配IP地址。你需要网卡的分配IP地址和子网掩码。
- en: '[PRE1]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'For example, if your network card is em0, your IP address is 203.0.113.250,
    and your netmask is 255.255.255.0, you would type:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果你的网卡是em0，IP地址是203.0.113.250，子网掩码是255.255.255.0，你可以输入：
- en: '[PRE2]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Specify the netmask in dotted-quad notation as above or in hex format (0xffffff00).
    Perhaps simplest of all is to use slash notation, like this:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 如上所示，可以以点分十进制表示法或十六进制格式（0xffffff00）指定子网掩码。最简单的方式可能是使用斜杠表示法，如下所示：
- en: '[PRE3]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: To configure an IPv6 address, add the `inet6` keyword between the interface
    name and the address.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 要配置IPv6地址，在接口名称和地址之间添加`inet6`关键字。
- en: '[PRE4]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The ifconfig(8) program can also perform any other configuration your network
    cards require, letting you work around hardware bugs in features such as the various
    sorts of checksum offloading, like setting media type and duplex mode for sub-gigabit
    interfaces. You’ll find supported options in the man pages for the driver and
    ifconfig(8). Here, I disable checksum offloading and TCP segmentation offloading
    on my em0 interface, even while I set the IP address.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: ifconfig(8)程序还可以执行其他网络卡所需的配置，帮助你绕过硬件问题，比如各种类型的校验和卸载功能，设置子千兆网卡的媒体类型和双工模式等。你可以在驱动程序和ifconfig(8)的手册页中找到支持的选项。这里，我在设置IP地址的同时，禁用了em0接口的校验和卸载和TCP分段卸载。
- en: '[PRE5]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'To make this persist across reboots, add an entry to */etc/rc.conf* that tells
    the system to configure the card at boot. An IPv4 entry has the form `ifconfig_`interfacename`="`ifconfig
    arguments`"`. For example, configuring the idle rl0 card would require an entry
    much like this:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 为了在重启后保持该配置，向*/etc/rc.conf*中添加一行，告诉系统在启动时配置该网卡。IPv4的配置项形式是`ifconfig_`接口名称`="`ifconfig参数`"`。例如，配置空闲的rl0网卡时需要像下面这样添加配置项：
- en: '[PRE6]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: An IPv6 entry has the form `ifconfig_`interfacename`_ipv6="`ifconfig arguments`"`.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: IPv6的配置项形式是`ifconfig_`接口名称`_ipv6="`ifconfig参数`"`。
- en: '[PRE7]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Once you have a working configuration for your interface, copy your ifconfig(8)
    arguments into a */etc/rc.conf* entry.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你有了一个正常工作的接口配置，将你的ifconfig(8)参数复制到*/etc/rc.conf*配置文件中。
- en: '***Testing Your Interface***'
  id: totrans-34
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***测试你的接口***'
- en: Now that your interface has an IP address, try to ping the IPv4 address of your
    default gateway. If you get a response, as shown in the following example, you’re
    on the local network. Interrupt the ping with CTRL-C.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你的接口已分配了IP地址，尝试ping一下默认网关的IPv4地址。如果你得到了响应，如下例所示，那么你就连接到了本地网络。用CTRL-C中断ping命令。
- en: '[PRE8]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: For IPv6, use ping6(8) instead of ping(8). If you use router discovery, the
    default route will almost always be a link-local address.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 对于IPv6，使用ping6(8)而不是ping(8)。如果你使用路由器发现功能，默认路由几乎总是一个链路本地地址。
- en: '[PRE9]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: If you don’t get any answers, your network connection isn’t working. Either
    you have a bad connection (check your cables and link lights) or you have misconfigured
    your card.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 如果没有得到任何回应，说明你的网络连接没有正常工作。要么是连接有问题（检查你的电缆和连接指示灯），要么是网卡配置错误。
- en: '***Set Default Route***'
  id: totrans-40
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***设置默认路由***'
- en: The default route is the address where your system sends all traffic that’s
    not on the local network. If you can ping the default route’s IPv4 address, set
    it via route(8).
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 默认路由是系统将所有非本地网络流量发送到的地址。如果你能ping通默认路由的IPv4地址，可以通过route(8)设置它。
- en: '[PRE10]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: That’s it! You should now be able to ping any public IPv4 address on the internet.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 就是这样！现在您应该能够 ping 任何公共 IPv4 地址。
- en: Adding the default IPv6 route is much the same, but you need to add the `-6`
    command line flag to change the IPv6 routing table.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 添加默认的 IPv6 路由非常相似，但您需要添加 `-6` 命令行标志来更改 IPv6 路由表。
- en: '[PRE11]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: If you didn’t choose nameservers during the system install, you’ll have to use
    the IP address rather than the hostname.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在系统安装时没有选择名称服务器，则必须使用 IP 地址而不是主机名。
- en: 'Once you have a working default router, make it persist across reboots by adding
    the proper `defaultrouter` and `ipv6_defaultrouter` entries in */etc/rc.conf*:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦您有了有效的默认路由器，可以通过在 */etc/rc.conf* 中添加适当的 `defaultrouter` 和 `ipv6_defaultrouter`
    条目，使其在重启后仍然有效：
- en: '[PRE12]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '***Multiple IP Addresses on One Interface***'
  id: totrans-49
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***一个接口上的多个 IP 地址***'
- en: A FreeBSD system can respond to multiple IP addresses on one interface. This
    is especially useful for jails (see [Chapter 22](ch22.xhtml#ch22)). Specify additional
    IPv4 addresses for an interface with ifconfig(8) and the keywords `inet` and `alias`.
    The netmask on an IPv4 alias is always /32, regardless of the size of the network
    address block the main address uses.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 一个 FreeBSD 系统可以在一个接口上响应多个 IP 地址。这对 Jail（参见 [第 22 章](ch22.xhtml#ch22)）尤其有用。使用
    ifconfig(8) 和 `inet` 及 `alias` 关键字为一个接口指定额外的 IPv4 地址。IPv4 别名的子网掩码总是 /32，无论主地址使用的网络地址块大小如何。
- en: '[PRE13]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: IPv6 aliases use the actual prefix length (slash) of the subnet they’re on.
    Be sure you use the `inet6` keyword.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: IPv6 别名使用它们所在子网的实际前缀长度（斜杠）。请确保使用 `inet6` 关键字。
- en: '[PRE14]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Once you add an alias to the interface, the additional IP address appears in
    ifconfig(8) output. The main IP always appears first, and aliases follow.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦为接口添加了别名，额外的 IP 地址将在 ifconfig(8) 输出中显示。主 IP 地址总是首先出现，别名随后列出。
- en: '[PRE15]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Here we see our brand new IPv4 ➊ and IPv6 ➋ aliases. Hosts that ping your aliased
    addresses will get a response from this server.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们看到了全新的 IPv4 ➊ 和 IPv6 ➋ 别名。对您的别名地址进行 ping 的主机会从此服务器获得响应。
- en: 'Once you have the aliases working as you like, make them persist across reboots
    by adding additional `ifconfig` statements in */etc/rc.conf*:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦您将别名设置按预期工作，可以通过在 */etc/rc.conf* 中添加额外的 `ifconfig` 语句，使其在重启后仍然有效：
- en: '[PRE16]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The only real difference between this entry and the standard *rc.conf* ’s “here’s
    my IP address” entry are the `alias0` and `alias1` chunks. The `alias` keyword
    tells FreeBSD that this is an aliased IP, and the `0` and `1` are unique numbers
    assigned to each alias. Every alias set in */etc/rc.conf* must have a unique number,
    and this number must be sequential. If you skip a number, aliases after the gap
    won’t be installed at boot. This is the most common interface misconfiguration
    I’ve seen.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 这个条目和标准 *rc.conf* 中的“这是我的 IP 地址”条目之间唯一的真正区别是 `alias0` 和 `alias1` 部分。`alias`
    关键字告诉 FreeBSD 这是一个别名 IP，`0` 和 `1` 是分配给每个别名的唯一编号。每个在 */etc/rc.conf* 中设置的别名必须具有唯一的编号，并且该编号必须是连续的。如果跳过了某个编号，则跳过的后面的别名在启动时不会被安装。这是我见过的最常见的接口配置错误。
- en: Many daemons, such as inetd(8) and sshd(8), can be bound to a single address
    (see [Chapter 20](ch20.xhtml#ch20)), so you can run multiple instances of the
    same program on the same server using multiple addresses.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 许多守护进程，如 inetd(8) 和 sshd(8)，可以绑定到一个单一的地址（参见 [第 20 章](ch20.xhtml#ch20)），因此您可以使用多个地址在同一服务器上运行多个相同程序的实例。
- en: '**ALIASES AND OUTGOING CONNECTIONS**'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: '**别名和外部连接**'
- en: All connections from your FreeBSD system use the system’s real IP address. You
    might have 2,000 addresses bound to one network card, but when you `ssh` from
    that machine, the connection comes from the primary IP address. Keep this in mind
    when writing firewall rules and other access-control filters. Jails initiate all
    connections from the jail IP address, but we won’t cover jails until [Chapter
    22](ch22.xhtml#ch22).
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 所有来自您的 FreeBSD 系统的连接都使用系统的真实 IP 地址。您可能将 2,000 个地址绑定到一张网卡上，但当您从该机器 `ssh` 时，连接将来自主
    IP 地址。在编写防火墙规则和其他访问控制过滤器时，请记住这一点。Jail 从 Jail 的 IP 地址发起所有连接，但我们直到 [第 22 章](ch22.xhtml#ch22)
    才会讨论 Jail。
- en: '***Renaming Interfaces***'
  id: totrans-63
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***重命名接口***'
- en: FreeBSD names its network interfaces after the device driver used by the network
    card. This is a fine old tradition in the Unix world and common behavior among
    most industrial operating systems. Some operating systems name their network interfaces
    by the type of interface—for example, Linux calls its Ethernet interfaces *eth0*,
    *eth1*, and so on. At times, it makes sense to rename an interface, either to
    comply with an internal standard or to make its function more apparent. For example,
    I have one device with 12 network interfaces, each plugged into a different network.
    Each network has a name such as *test*, *QA*, and so on. Renaming these network
    interfaces to match the attached networks makes sense.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: FreeBSD 根据网络卡所使用的设备驱动程序为其网络接口命名。这是 Unix 世界中的一项悠久传统，也是大多数工业操作系统的常见行为。一些操作系统通过接口类型来命名其网络接口——例如，Linux
    将其以太网接口命名为*eth0*、*eth1*，以此类推。有时，重新命名接口是有意义的，要么是为了遵循内部标准，要么是为了使其功能更加明显。例如，我有一台设备，拥有
    12 个网络接口，每个接口都连接到不同的网络。每个网络都有一个名称，如*test*、*QA*等。将这些网络接口重新命名为与附加网络相匹配是合理的。
- en: 'While FreeBSD is flexible on interface names, some software isn’t—it assumes
    that a network interface name is a short word followed by a number. This isn’t
    likely to change any time in the near future, so it’s best practice to use a short
    interface name ending in a digit. Use ifconfig(8)’s `name` keyword to rename an
    interface. For example, to rename *em1* to *test1*, you would run:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然 FreeBSD 在接口名称方面比较灵活，但一些软件则不然——它假设网络接口名称是一个短单词，后面跟着一个数字。预计在不久的将来这种情况不会改变，因此最佳实践是使用以数字结尾的短接口名称。使用
    ifconfig(8) 的 `name` 关键字来重命名接口。例如，要将 *em1* 重命名为 *test1*，可以运行：
- en: '[PRE17]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Running ifconfig(8) without arguments shows that you have renamed that interface.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 运行 ifconfig(8) 不带参数将显示你已重命名该接口。
- en: '[PRE18]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Make this change permanent with the `ifconfig_`interface`_name` option in */etc/rc.conf*.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `ifconfig_`interface`_name` 选项在 */etc/rc.conf* 中使此更改永久生效。
- en: '[PRE19]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'FreeBSD renames interfaces early in the boot process, before setting IP addresses
    or other values. This means that any further interface configuration must reference
    the new interface name rather than the old. Full configuration of a renamed interface
    with IP addresses and aliases would look something like this:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: FreeBSD 在启动过程中早期就重命名接口，在设置 IP 地址或其他值之前。这意味着任何进一步的接口配置必须引用新接口名称，而不是旧接口名称。对重命名接口进行完整配置，包括
    IP 地址和别名，应该如下所示：
- en: '[PRE20]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: '***DHCP***'
  id: totrans-73
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***DHCP***'
- en: 'Very few networks use DHCP for everything, including servers. A DHCP server
    will set the server’s IP address, netmask, nameservers, and default gateway for
    you. If your network administrator configures servers via DHCP, you can tell the
    network card to take its configuration via DHCP with the following:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 很少有网络使用 DHCP 来处理所有设备，包括服务器。DHCP 服务器会为你设置服务器的 IP 地址、子网掩码、域名服务器和默认网关。如果你的网络管理员通过
    DHCP 配置服务器，你可以告诉网络卡通过 DHCP 获取配置，方法如下：
- en: '[PRE21]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: '***Reboot!***'
  id: totrans-76
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***重启！***'
- en: Now that you have your network interfaces fully configured, be sure to reboot
    to test any changes you made to */etc/rc.conf*. If FreeBSD finds an error in */etc/rc.conf*,
    especially in network configuration, you’ll have problems accessing the system
    remotely. It’s much better to learn that you made a typo under controlled conditions
    as opposed to the middle of your sleeping hours.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你已经完全配置了网络接口，务必重启以测试你对*/etc/rc.conf*所做的任何更改。如果 FreeBSD 在 */etc/rc.conf* 中发现错误，特别是在网络配置方面，你将遇到远程访问系统的问题。在受控条件下发现打字错误总比在你睡觉的时候发现要好得多。
- en: If you feel like living dangerously, you can run `service netif restart` with
    the interface name to reconfigure only a single interface.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你觉得挑战刺激，你可以运行 `service netif restart` 并指定接口名称来仅重新配置单个接口。
- en: '[PRE22]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Skip the interface name, and this will restart all interfaces. It’s not a perfect
    test, but it will catch a bunch of daftness. A reboot is always the best test.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 如果省略接口名称，则会重启所有接口。这不是一个完美的测试，但它可以捕捉到一些愚蠢的错误。重启始终是最好的测试。
- en: '**The Domain Name Service**'
  id: totrans-81
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**域名服务**'
- en: The *Domain Name Service*, or *DNS*, is one of those quiet, behind-the-scenes
    services that doesn’t get half the attention it deserves. Although most users
    have never heard of it, DNS makes the internet as we know it work. Also called
    *name service*, DNS provides a map between hostnames and IP addresses. It also
    provides the reverse map, of IP addresses to hostnames. Without DNS, web browsers
    and email programs couldn’t use the nice and convenient hostnames like *[www.michaelwlucas.com](http://www.michaelwlucas.com)*
    or *[www.nostarch.com](http://www.nostarch.com)*; instead, you’d have to browse
    the web by typing in appalling things like *https://2001:19f0:5c00:9041:225:90ff:fee8:1270*.
    This would greatly reduce the internet’s popularity.^([2](footnote.xhtml#ch08fn2))
    To most end users, a DNS failure is an internet failure, end of story. While we
    won’t discuss building your own authoritative nameserver, we must cover configuring
    your server to use DNS.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: '*域名服务*，或*DNS*，是那些安静的幕后服务之一，通常得不到应有的关注。尽管大多数用户从未听说过它，DNS却是我们所知的互联网能够正常工作的原因。DNS也叫做*名称服务*，它提供了主机名与IP地址之间的映射。它还提供了反向映射，即IP地址到主机名的映射。没有DNS，网页浏览器和电子邮件程序无法使用像*
    [www.michaelwlucas.com](http://www.michaelwlucas.com) *或* [www.nostarch.com](http://www.nostarch.com)
    *这样的简便主机名；相反，你将不得不输入一些令人震惊的东西，如*https://2001:19f0:5c00:9041:225:90ff:fee8:1270*来浏览网页。这将极大地减少互联网的普及率。^([2](footnote.xhtml#ch08fn2))
    对大多数终端用户来说，DNS故障就是互联网故障，故事到此为止。虽然我们不会讨论如何构建自己的权威型名称服务器，但我们必须讲解如何配置你的服务器以使用DNS。'
- en: A host that trawls the internet to dig up DNS mappings is called a *nameserver*,
    or *DNS server*. DNS servers aren’t difficult to run, but most individuals don’t
    need one. DNS servers are needed only by organizations who run their own servers
    (and lunatics who have dozens of hosts in their basement, like me). Nameservers
    come in two varieties, authoritative and recursive.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 一个用于在互联网上搜寻DNS映射的主机被称为*名称服务器*，或*DNS服务器*。DNS服务器并不难以运行，但大多数个人不需要一个。只有那些运行自己服务器的组织（以及像我一样在地下室有数十台主机的疯子）才需要DNS服务器。名称服务器有两种类型，权威型和递归型。
- en: '*Authoritative* nameservers provide DNS mappings for the public to find an
    organization’s nameservers. As the operator of *[michaelwlucas.com](http://michaelwlucas.com)*,
    I must provide authoritative nameservers for that domain and let the public query
    them. These authoritative nameservers answer queries only about the domains I
    manage. Configuring an authoritative nameserver is beyond the scope of this book.'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: '*权威型*名称服务器提供DNS映射，使公众能够找到组织的名称服务器。作为* [michaelwlucas.com](http://michaelwlucas.com)
    *的运营者，我必须为该域提供权威型名称服务器并让公众查询它们。这些权威型名称服务器只回答关于我管理的域的查询。配置权威型名称服务器超出了本书的范围。'
- en: '*Recursive* nameservers service client requests. When you try to browse to
    *[https://www.michaelwlucas.com](https://www.michaelwlucas.com)*, your local recursive
    nameserver searches the internet for my authoritative nameserver. Once the recursive
    nameserver retrieves the hostname-to-IP mapping, it returns that response to your
    client. This book shows you how to use recursive nameservers and how to enable
    your own recursive nameserver.'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: '*递归型*名称服务器处理客户端请求。当你尝试浏览* [https://www.michaelwlucas.com](https://www.michaelwlucas.com)
    *时，你的本地递归型名称服务器会在互联网上查找我的权威型名称服务器。一旦递归型名称服务器找到了主机名到IP地址的映射，它会将该响应返回给客户端。本书将向你展示如何使用递归型名称服务器，以及如何启用你自己的递归型名称服务器。'
- en: 'The system’s *resolver* is responsible for configuring how the host performs
    DNS queries and relaying the responses to programs. Configuring the resolver is
    a vital part of system administration. Even DNS servers need a configured resolver,
    because the host won’t know it’s a nameserver unless you tell it so. Configuring
    a resolver requires answering a few questions:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 系统的*解析器*负责配置主机如何执行DNS查询，并将响应转发给程序。配置解析器是系统管理中的一项重要工作。即使是DNS服务器，也需要配置解析器，因为除非你告诉它，否则主机不会知道自己是名称服务器。配置解析器需要回答一些问题：
- en: Where does the server look for DNS information?
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 服务器在哪里查找DNS信息？
- en: What local overrides do you want?
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你想要哪些本地覆盖？
- en: What are the local domain names?
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 什么是本地域名？
- en: Which nameservers should be queried?
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应该查询哪些名称服务器？
- en: The answers to these questions are configured in */etc/nsswitch.conf* and */etc/resolv.conf*.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 这些问题的答案在*/etc/nsswitch.conf*和*/etc/resolv.conf*中进行配置。
- en: '***Host/IP Information Sources***'
  id: totrans-92
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***主机/IP信息来源***'
- en: This should be easy. A server gets its host information from a nameserver, right?
    I just spent a few paragraphs telling you that, didn’t I?
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 这应该很简单。服务器通过名称服务器获取主机信息，对吧？我刚刚花了几段话告诉你这个，不是吗？
- en: The real world isn’t quite that simple, though. Perhaps you have a small home
    network with only three machines. You want each machine to be able to find each
    other by hostname, but you don’t want to run a local authoritative nameserver.
    Or maybe you’re on a large corporate network where completing DNS changes takes
    weeks, and you have a couple test systems that need to talk to each other. FreeBSD,
    like all Unix-like operating systems, can get information from both DNS and from
    the plaintext hosts file */etc/hosts*.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，现实情况并没有那么简单。也许你有一个只有三台机器的小型家庭网络，你希望每台机器都能通过主机名互相找到，但你不想运行一个本地的权威名称服务器。或者，也许你在一个大型公司网络中，完成
    DNS 更改需要几周时间，而你有几台需要相互通信的测试系统。像所有类 Unix 操作系统一样，FreeBSD 可以从 DNS 和明文 hosts 文件 */etc/hosts*
    中获取信息。
- en: When FreeBSD needs to know the address of a host (or the hostname of an address),
    by default the query goes first to the hosts file and then the configured nameservers.
    This means that you can locally override nameserver results, which is very useful
    for hosts behind a NAT or on large corporate networks with odd requirements. In
    some cases, you might need to reverse this order to query DNS first and the hosts
    file second. Set this order in */etc/nsswitch.conf*.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 当 FreeBSD 需要知道一个主机的地址（或者一个地址的主机名）时，默认情况下查询首先会访问 hosts 文件，然后是配置的名称服务器。这意味着你可以本地覆盖名称服务器的结果，这对于位于
    NAT 后的主机或在大型公司网络中具有特殊需求的主机非常有用。在某些情况下，你可能需要反转这个顺序，首先查询 DNS，然后再查询 hosts 文件。可以在
    */etc/nsswitch.conf* 中设置此顺序。
- en: '**NAME SERVICE SWITCHING**'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: '**名称服务切换**'
- en: The file */etc/nsswitch.conf* is used not only by the resolver, but also by
    all other name services. A networked operating system includes many different
    name services. The TCP/IP ports in */etc/services* are a name service as well
    as network protocol names and numbers. Determining a user’s UID and GID requires
    a different sort of name lookup (see [Chapter 9](ch09.xhtml#ch09)). */etc/nsswitch.conf*
    determines ordering for all of these queries and more. We’re discussing only hostname
    lookups here, but [Chapter 20](ch20.xhtml#ch20) covers more on name service switching.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 文件 */etc/nsswitch.conf* 不仅由解析器使用，还由所有其他名称服务使用。一个网络操作系统包括许多不同的名称服务。*/etc/services*
    中的 TCP/IP 端口既是名称服务，也是网络协议的名称和编号。确定用户的 UID 和 GID 需要不同类型的名称查找（参见 [第 9 章](ch09.xhtml#ch09)）。*/etc/nsswitch.conf*
    确定所有这些查询的顺序及更多内容。我们这里只讨论主机名查找，更多关于名称服务切换的内容请参考 [第 20 章](ch20.xhtml#ch20)。
- en: 'Each entry in */etc/nsswitch.conf* is a single line containing the name of
    the name service, a colon, and a list of information sources. Here’s the hostname
    service lookup configuration:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: '*/etc/nsswitch.conf* 中的每个条目都是一行，包含名称服务的名称、冒号和信息源列表。以下是主机名服务查找的配置：'
- en: '[PRE23]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: The resolver queries the information sources in the order listed. If you have
    an additional information source, such as nscd(8), list it here. The documentation
    sources for these add-ons should include the name of the service.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 解析器按照列出的顺序查询信息源。如果你有额外的信息源，例如 nscd(8)，请在此列出。关于这些附加组件的文档来源应包括服务的名称。
- en: '***Local Names with /etc/hosts***'
  id: totrans-101
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***使用 /etc/hosts 设置本地名称***'
- en: The */etc/hosts* file matches internet addresses to hostnames. Once upon a time,
    before the Domain Name Service, the internet had a single hosts file that provided
    the hostnames and IP addresses of every node on the internet. Sysadmins submitted
    their host changes to a central maintainer, who issued a revised hosts file every
    few months. Sysadmins would then download the hosts file and install it on all
    of their machines. This worked fine when the whole internet had four systems on
    it, and was even acceptable when there were hundreds of hosts. As soon as the
    internet began its exponential growth, however, this scheme became totally unmaintainable.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: '*/etc/hosts* 文件将互联网地址与主机名匹配。曾几何时，在域名服务（DNS）之前，互联网有一个单一的 hosts 文件，提供互联网中每个节点的主机名和
    IP 地址。系统管理员将他们的主机更改提交给一个中央维护者，后者每隔几个月发布一次更新的 hosts 文件。然后，系统管理员会下载该文件并将其安装到他们的所有机器上。当整个互联网只有四个系统时，这种方式运行得很好，当主机数量只有几百个时也能接受。然而，一旦互联网开始呈指数增长，这种方案就变得完全无法维护。'
- en: While the hosts file is very effective, it works only on the machine it’s installed
    on and must be maintained by the sysadmin. The public DNS has largely supplanted
    */etc/hosts*, but it’s still useful in environments where you don’t want to run
    local authoritative DNS^([3](footnote.xhtml#ch08fn3)) or you’re behind an IPv4
    NAT device. Using the hosts file makes perfect sense if you have one or two servers
    at home, or if someone else manages your authoritative nameservers. Once you have
    enough hosts that the thought of updating the hosts file makes you ill, it’s time
    to learn to build an authoritative nameserver.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然 hosts 文件非常有效，但它只在安装它的机器上工作，并且必须由系统管理员维护。公共 DNS 在很大程度上取代了 */etc/hosts*，但它在你不想运行本地权威
    DNS^([3](footnote.xhtml#ch08fn3)) 或者你处于 IPv4 NAT 设备后面时仍然很有用。如果你在家有一两台服务器，或者由别人管理你的权威名称服务器，使用
    hosts 文件是完全合理的。一旦你有足够多的主机，以至于更新 hosts 文件的想法让你感到恶心，就该学习构建权威名称服务器了。
- en: Each line in */etc/hosts* represents one host. The first entry on each line
    is an IP address, and the second is the fully qualified domain name of the host,
    such as *mail.michaelwlucas.com*. Following these two entries, you can list an
    arbitrary number of aliases for that host.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 每行 */etc/hosts* 中的条目代表一个主机。每行的第一个条目是 IP 地址，第二个是主机的完全限定域名，例如 *mail.michaelwlucas.com*。在这两个条目之后，你可以列出该主机的任意数量的别名。
- en: 'For example, a small company might have a single server handling email, serving
    FTP, web pages, and DNS, as well as performing a variety of other functions. A
    desktop on that network might have a hosts file entry like this:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，一个小公司可能只有一台服务器处理电子邮件、提供 FTP、网页和 DNS 服务，并执行其他各种功能。该网络上的桌面计算机可能会有类似这样的 hosts
    文件条目：
- en: '[PRE24]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: With this */etc/hosts* entry, the desktop could find the server with either
    the full domain name or any of the brief aliases listed. This won’t get you to
    Facebook, however. For that, you need nameservice.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这个 */etc/hosts* 条目，桌面计算机可以通过完整的域名或列出的任何简短别名来找到服务器。然而，这不会让你访问 Facebook。为此，你需要名称服务。
- en: '***Configuring Nameservice***'
  id: totrans-108
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***配置名称服务***'
- en: Tell your host how to query nameservers with the file */etc/resolv.conf*. You
    probably want to provide a local domain or a domain search list and then list
    the nameservers.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 通过文件 */etc/resolv.conf* 告诉你的主机如何查询名称服务器。你可能希望提供一个本地域名或一个域名搜索列表，然后列出名称服务器。
- en: '**Local Domain and Search List**'
  id: totrans-110
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**本地域名和搜索列表**'
- en: If your organization has many machines, typing out complete hostnames can quickly
    get old. If you’re doing maintenance and need to log into every web server, by
    the time you get to *www87.BertJWRegeerHasTooManyBlastedComputers.com* you’ll
    need treatment for impending carpal tunnel syndrome. You can either provide a
    local domain or a list of domains to search on the first line of */etc/resolv.conf*.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你的组织有许多机器，逐个输入完整的主机名会很快让人感到厌烦。如果你正在进行维护并需要登录每一台 Web 服务器，当你输入到 *www87.BertJWRegeerHasTooManyBlastedComputers.com*
    时，你可能已经需要治疗即将到来的腕管综合症了。你可以在 */etc/resolv.conf* 的第一行提供一个本地域名或一个要搜索的域名列表。
- en: The *domain* keyword tells the resolver which local domain to check, by default,
    for all hostnames. All of my test hosts are in the domain *[michaelwlucas.com](http://michaelwlucas.com)*,
    so I could set that as the default domain.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: '*domain* 关键字告诉解析器默认检查哪个本地域名，用于所有主机名。我的所有测试主机都在域名 *[michaelwlucas.com](http://michaelwlucas.com)*
    下，所以我可以将其设置为默认域。'
- en: '[PRE25]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Once you specify a local domain, the resolver will automatically append the
    domain to any short hostname. If I type `ping www`, the resolver will append the
    local domain and send ping(8) to *[www.michaelwlucas.com](http://www.michaelwlucas.com)*.
    If I give a complete hostname, such as *[www.bertjwregeer.com](http://www.bertjwregeer.com)*,
    though, the resolver doesn’t add the default domain.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你指定了一个本地域名，解析器将自动将该域名附加到任何简短的主机名上。如果我输入 `ping www`，解析器会附加本地域名并将 ping(8) 发送到
    *[www.michaelwlucas.com](http://www.michaelwlucas.com)*。但如果我提供一个完整的主机名，比如 *[www.bertjwregeer.com](http://www.bertjwregeer.com)*，解析器就不会添加默认域名。
- en: Maybe I have more than one domain I’d like to search. Use the *search* keyword
    to give a list of domain names to try, in order. Like `domain`, `search` must
    be the first line of *resolv.conf*.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 也许我有多个域名想要搜索。使用 *search* 关键字来提供一个按顺序尝试的域名列表。像 `domain` 一样，*search* 必须是 *resolv.conf*
    的第一行。
- en: '[PRE26]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: When you use a brief hostname, such as *www*, the resolver appends the first
    domain name in the search list. If there’s no answer, it repeats the query with
    the second domain name, and then the third. If I run `ping` `petulance`, the resolver
    searches for *petulance.michaelwlucas.com*, *petulance.bertwjregeer.com*, and
    *petulance.mwl.io*. If no such host exists in any of these domains, the search
    fails.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 当你使用简短的主机名，如*www*时，解析器会将第一个域名添加到搜索列表中。如果没有找到结果，它会使用第二个域名重复查询，然后是第三个。如果我运行`ping`
    `petulance`，解析器会依次搜索*petulance.michaelwlucas.com*、*petulance.bertwjregeer.com*和*petulance.mwl.io*。如果在这些域名中都没有该主机，查询将失败。
- en: If you have neither domain nor search entries in */etc/resolv.conf*, but the
    machine’s hostname includes a domain name, the resolver uses the local machine’s
    domain name.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在*/etc/resolv.conf*中既没有域名（domain）也没有搜索项（search），但机器的主机名中包含域名，解析器将使用本地机器的域名。
- en: '**The Nameserver List**'
  id: totrans-119
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**名称服务器列表**'
- en: 'Now that your resolver knows which domains to try, tell it which nameservers
    to query. List each in */etc/resolv.conf* on its own line, in order of preference.
    Use the keyword `nameserver` and the DNS server’s IP address. The resolver queries
    the listed nameservers in order. A complete *resolv.conf* might look like this:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你的解析器已经知道了尝试哪些域名，接下来告诉它查询哪些名称服务器。在*/etc/resolv.conf*中为每个名称服务器列出一行，按优先顺序排列。使用关键字`nameserver`和
    DNS 服务器的 IP 地址。解析器会按顺序查询列出的名称服务器。一个完整的*resolv.conf*可能如下所示：
- en: '[PRE27]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: This resolver is ready to rock.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 这个解析器已经准备好工作了。
- en: Note the first nameserver entry, though. The address 127.0.0.1 is always attached
    to the local host. This machine is running a local recursive nameserver. You can
    too!
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 注意第一个名称服务器条目。地址 127.0.0.1 总是与本地主机相关联。此机器正在运行一个本地递归名称服务器。你也可以这样做！
- en: '***Caching Nameserver***'
  id: totrans-124
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***缓存名称服务器***'
- en: Your host needs to perform a DNS lookup every single time it must contact a
    host. A busy server makes a whole bunch of queries, and by itself, the resolver
    doesn’t cache any of these responses. A host needs to connect to Google 500 times
    in a minute? That’s 500 DNS lookups. While setting up an authoritative DNS server
    requires a specific skill set, configuring a local recursive server requires only
    one line in */etc/rc.conf*. This lets your FreeBSD host cache its DNS responses
    while reducing network congestion and improving performance.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 每次主机必须联系一个主机时，都需要执行 DNS 查找。一个忙碌的服务器会发出大量查询，而解析器本身并不会缓存这些响应。如果一个主机一分钟内需要连接 Google
    500 次，那就意味着有 500 次 DNS 查找。虽然设置一个权威 DNS 服务器需要特定的技能，但配置一个本地递归服务器只需要在*/etc/rc.conf*中添加一行。这让你的
    FreeBSD 主机能够缓存 DNS 响应，同时减少网络拥堵并提高性能。
- en: Enable the local nameserver with the *rc.conf* variable `local_unbound_enable`.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 使用*rc.conf*变量`local_unbound_enable`启用本地名称服务器。
- en: '[PRE28]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: You can now start the local nameserver.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 现在可以启动本地名称服务器。
- en: '[PRE29]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: When you start the service the first time, `unbound` configures itself. It extracts
    your system’s nameservers from */etc/resolv.conf* and configures itself to forward
    all queries to those nameservers. The setup process then edits */etc/resolv.conf*
    to point all queries at the local nameserver, running on the IP address 127.0.0.1.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 当你第一次启动该服务时，`unbound`会自行配置。它会从*/etc/resolv.conf*中提取系统的名称服务器，并配置自己将所有查询转发到这些名称服务器。然后，设置过程会编辑*/etc/resolv.conf*，使所有查询指向运行在
    IP 地址 127.0.0.1 上的本地名称服务器。
- en: When your host makes a DNS query, the resolver queries `unbound`. The local
    nameserver checks its cache to see whether it has a valid and unexpired answer
    for the query. If it doesn’t have a cached response, `unbound` queries your preferred
    nameservers.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 当你的主机发起 DNS 查询时，解析器会查询`unbound`。本地名称服务器会检查其缓存，看看是否有有效且未过期的查询结果。如果没有缓存的响应，`unbound`会查询你偏好的名称服务器。
- en: I recommend enabling `local_unbound` on every server that isn’t a DNS server.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 我建议在每台不是 DNS 服务器的服务器上启用`local_unbound`。
- en: '**Network Activity**'
  id: totrans-133
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**网络活动**'
- en: Now that you’re on the network, how can you see what’s going on? There are several
    ways to look at the network, and we’ll consider each in turn. Unlike many commercial
    operating systems, FreeBSD commands such as netstat(8) and sockstat(1) give you
    more information about the network than can possibly be healthy.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经接入网络，怎么查看发生了什么呢？有几种方法可以查看网络，我们将逐一考虑。与许多商业操作系统不同，FreeBSD 中的命令如 netstat(8)
    和 sockstat(1) 能为你提供比健康所需更多的网络信息。
- en: '***Current Network Activity***'
  id: totrans-135
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***当前网络活动***'
- en: 'The general-purpose network management program netstat(8) displays different
    information depending on the flags it’s given. One common question people have
    is, “How much traffic is my system pushing right now?” The netstat(8) `-w` (for
    *wait*) option displays how many packets and bytes your system is processing.
    The `-w` flag takes one argument, the number of seconds between updates. Adding
    the `-d` (for *drop*) flag tells netstat(8) to include information about packets
    that never made it to the system. Here, we ask netstat(8) to update its display
    every five seconds:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 通用网络管理程序 netstat(8) 根据给定的标志显示不同的信息。人们常问的一个问题是：“我的系统现在正在处理多少流量？” netstat(8) 的
    `-w`（即 *等待*）选项显示系统正在处理多少数据包和字节。`-w` 标志需要一个参数，即更新之间的秒数。添加 `-d`（即 *丢弃*）标志会告诉 netstat(8)
    包含有关未到达系统的数据包的信息。在这里，我们要求 netstat(8) 每五秒更新一次显示：
- en: '[PRE30]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Nothing appears to happen when you enter this command, but in a few seconds,
    the display prints a single line of information. The first three columns describe
    inbound traffic, while the next three describe outbound traffic. We see the number
    of packets received since the last update ➊, the number of interface errors for
    inbound traffic since the last update ➋, and the number of inbound dropped packets
    ➌. The input information ends with the number of bytes received since the last
    update ➍. The next three columns show the number of packets the machine transmitted
    since the last update ➎, the number of errors in transmission since the last update
    ➏, and how many bytes we sent ➐. We then see the number of network collisions
    that have occurred since the last update ➑, and the number of packets that have
    been dropped ➒. For example, in this display, the system received 34 packets ➊
    since `netstat -w 5 -d` started running.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 当你输入此命令时，似乎什么也没有发生，但几秒钟后，显示屏会打印出一行信息。前三列描述了入站流量，接下来的三列描述了出站流量。我们可以看到自上次更新以来接收的数据包数
    ➊，入站流量的接口错误数 ➋，以及丢失的入站数据包数 ➌。输入信息的最后是自上次更新以来接收的字节数 ➍。接下来的三列显示了机器自上次更新以来传输的数据包数
    ➎，传输中的错误数 ➏，以及我们发送的字节数 ➐。然后，我们会看到自上次更新以来发生的网络冲突数 ➑，以及丢失的数据包数 ➒。例如，在此显示中，系统自 `netstat
    -w 5 -d` 开始运行以来接收了 34 个数据包 ➊。
- en: Five seconds later, netstat(8) prints a second line describing the activity
    since the first line was printed.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 五秒钟后，netstat(8) 打印出第二行，描述自第一行打印以来的活动。
- en: You can make the output as detailed as you want and run it as long as you like.
    If you’d like to get updates every second, just run `netstat -w 1 -d`. If once
    a minute is good enough for you, `netstat -w 60 -d` will do the trick. I find
    a five-second interval most suitable when I’m actively watching the network, but
    you’ll quickly learn what best fits your network and your problems.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以根据需要使输出尽可能详细，并随时运行它。如果你想每秒获取更新，只需运行 `netstat -w 1 -d`。如果每分钟一次足够，你可以使用 `netstat
    -w 60 -d`。我发现当我在积极监控网络时，五秒的间隔最合适，但你会很快学到什么最适合你的网络和问题。
- en: Hit CTRL-C to stop the report once you’ve had enough.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 按 CTRL-C 停止报告，直到你看够为止。
- en: '***What’s Listening on Which Port?***'
  id: totrans-142
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***哪个端口在监听什么？***'
- en: Another popular question is, “Which ports are open and what programs are listening
    on them?” FreeBSD includes sockstat(1), a friendly tool to answer this question.
    It shows both active connections and ports available for client use.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个常见问题是：“哪些端口是开放的，哪些程序在监听这些端口？” FreeBSD 包含了 sockstat(1)，这是一个友好的工具来回答这个问题。它显示了活跃的连接和可供客户端使用的端口。
- en: 'The sockstat(1) program not only lists ports listening to the network, but
    also any other ports (or *sockets*) on the system. Use the `-4` flag to see IPv4
    sockets and `-6` to view IPv6\. Here’s trimmed sockstat(1) output from a *very*
    small server:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: sockstat(1) 程序不仅列出了监听网络的端口，还包括系统上的其他任何端口（或 *套接字*）。使用 `-4` 标志可以查看 IPv4 套接字，使用
    `-6` 可以查看 IPv6。以下是来自一个 *非常* 小型服务器的截断 sockstat(1) 输出：
- en: '![image](../images/f0155-01.jpg)'
  id: totrans-145
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f0155-01.jpg)'
- en: The first column gives us the username that’s running the program attached to
    the port in question. The second column is the name of the command. We then have
    the process ID of the program and the file descriptor number attached to the socket.
    The next column shows what transport protocol the socket uses—either `tcp4` for
    TCP on TCP/IP version 4, or `udp4` for UDP on TCP/IP version 4\. We then list
    the local IP address and port number, and finally the remote IP address and port
    number for each existing connection.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 第一列给出了运行附加到相关端口的程序的用户名。第二列是命令的名称。接下来是程序的进程ID以及附加到套接字的文件描述符号。接下来的列显示了套接字使用的传输协议——如果是TCP/IP版本4上的TCP，则为`tcp4`，如果是TCP/IP版本4上的UDP，则为`udp4`。接着列出了本地IP地址和端口号，最后是每个现有连接的远程IP地址和端口号。
- en: Take a look at our very first entry. I’m running the program sshd ➊. A man page
    search takes you to sshd(8), the SSH daemon. The main sshd(8) daemon forked a
    child process on my behalf to handle my connection, so we see multiple instances
    of sshd(8) with different process IDs. I’m connected to the local IP address 203.0.113.43
    ➋ on TCP port 22\. The remote end of this connection is at the IP address 24.192.127.92
    ➌ on port 62937\. This is an SSH connection from a remote system to the local
    computer.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 看看我们第一个条目。我正在运行程序sshd ➊。一个手册页搜索会带你到sshd(8)，即SSH守护进程。主sshd(8)守护进程为我分叉了一个子进程来处理我的连接，因此我们看到多个不同进程ID的sshd(8)实例。我连接到本地IP地址203.0.113.43
    ➋上的TCP端口22。这个连接的远端IP地址是24.192.127.92 ➌，端口为62937。 这是来自远程系统到本地计算机的SSH连接。
- en: Other available connections include Sendmail ➍, the mail server, running on
    port 25\. Note that this entry doesn’t have any IP address listed as the foreign
    address. This socket is listening for incoming connections. Our httpd process
    ➎ is listening for incoming connections on port 80.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 其他可用的连接包括运行在端口25上的Sendmail ➍邮件服务器。请注意，此项没有列出作为外部地址的IP地址。这个套接字正在监听传入的连接。我们的httpd进程
    ➎ 正在监听端口80上的传入连接。
- en: The astute among you might notice that this server has two SSH daemons available
    for incoming connections, one on port 23 ➏ and one on port 22 ➐. As */etc/services*
    shows, SSH normally runs on port 22 while port 23 is reserved for telnet. Anyone
    who telnets to this machine will be connected to an SSH daemon, which won’t work
    as they expect. The suspicious among you might suspect that this SSH server was
    set up to waltz around firewalls that only filter traffic based on source and
    destination ports and not the actual protocol. (I have no comment on such allegations.)
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 机智的你可能会注意到，这台服务器有两个SSH守护进程可以接受传入连接，一个在端口23 ➏上，另一个在端口22 ➐上。正如*/etc/services*所示，SSH通常运行在端口22上，而端口23则预留给telnet。任何通过telnet连接到此机器的人都会连接到一个SSH守护进程，而这并不会按他们预期的那样工作。怀疑的你可能会猜测，这个SSH服务器是为了绕过只基于源和目标端口而非实际协议过滤流量的防火墙而设置的。（对于这样的指控，我不做评论。）
- en: The last two entries are for a nameserver, named, awaiting incoming connections
    on port 53\. This nameserver is listening for both UDP ➑ and TCP ➒ connections
    and is attached to the single IP address 203.0.113.8.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 最后两项是一个命名服务器，名为named，正在等待端口53上的传入连接。这个命名服务器正在监听UDP ➑和TCP ➒连接，并附加到单个IP地址203.0.113.8。
- en: '***Port Listeners in Detail***'
  id: totrans-151
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***端口监听器详细信息***'
- en: 'While sockstat(1) provides a nice high-level view of network service availability,
    you can get a little more detailed information about individual connections with
    netstat(8). To view open network connections, use netstat(8)’s `-a` flag. The
    `-n` flag tells netstat(8) not to bother translating IP addresses to hostnames;
    not only can this translation slow down the output, it can cause ambiguous output.
    Finally, the `-f inet` option tells netstat(8) to worry only about IPv4 network
    connections, while `-f inet6` addresses IPv6\. Here’s matching netstat output
    from the same machine we just ran sockstat(1) on:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然sockstat(1)提供了一个网络服务可用性的高层视图，但你可以通过netstat(8)获得有关单个连接的更详细信息。要查看开放的网络连接，请使用netstat(8)的`-a`标志。`-n`标志告诉netstat(8)不要翻译IP地址为主机名；这种翻译不仅可能减慢输出速度，还可能导致模糊的输出。最后，`-f
    inet`选项告诉netstat(8)只关注IPv4网络连接，而`-f inet6`则关注IPv6。以下是与我们刚刚运行sockstat(1)相同机器的netstat输出：
- en: '[PRE31]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Here, we get no idea of what program is attached to any port. The first entry
    in each column is the transport protocol used by the socket—mostly TCP, but the
    last line shows UDP.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们无法得知任何端口上附加的程序是什么。每一列的第一项是套接字使用的传输协议——通常是TCP，但最后一行显示的是UDP。
- en: The `Recv-Q` and `Send-Q` columns show the number of bytes waiting to be handled
    by this connection. If you see nonzero `Recv-Q` numbers for some connection most
    of the time, you know that the program listening on that port can’t process incoming
    data quickly enough to keep up with the network stack. Similarly, if the `Send-Q`
    column keeps having nonzero entries, you know that either the network or the remote
    system can’t accept data as quickly as you’re sending it. Occasional queued packets
    are normal, but if they don’t go away, you might want to investigate why things
    are slow. You must watch your own system to learn what’s normal.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: '`Recv-Q` 和 `Send-Q` 列显示了等待被该连接处理的字节数。如果你看到某些连接的 `Recv-Q` 数字大部分时间都不为零，说明监听该端口的程序处理传入数据的速度不够，无法跟上网络堆栈的速度。同样，如果
    `Send-Q` 列持续出现非零值，说明网络或远程系统无法以你发送的速度接收数据。偶尔的队列数据包是正常的，但如果它们一直存在，你可能需要调查为什么处理速度慢。你需要观察自己的系统，了解什么是正常的。'
- en: The `Local Address` is, as you might guess, the IP address and network port
    number on the local system that the network connection is listening on. The network
    port appears at the end of the entry and is separated from the IP address by a
    dot. For example, 203.0.113.43.22 is the IP address 203.0.113.43, port 22\. If
    the entry is an asterisk followed by a period and a port number, that means that
    the system is listening on that port on all available IP addresses. The system
    is ready to accept a connection on that port.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: '`Local Address` 是你猜的那样，表示本地系统上网络连接监听的 IP 地址和端口号。网络端口出现在条目的末尾，并且与 IP 地址之间由一个点分隔。例如，203.0.113.43.22
    就是 IP 地址 203.0.113.43，端口 22。如果条目是一个星号后跟一个点和端口号，意味着该系统在所有可用的 IP 地址上都在监听该端口，系统已准备好接受该端口上的连接。'
- en: The `Foreign Address` column shows the remote address and port number of any
    connection.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: '`Foreign Address` 列显示任何连接的远程地址和端口号。'
- en: Finally, the `(state)` column shows the status of the TCP handshake. You don’t
    need to know all of the possible TCP connection states, so long as you learn what’s
    normal. `ESTABLISHED` means that a connection exists and that data is probably
    flowing. `LAST_ACK`, `FIN_WAIT_1`, and `FIN_WAIT_2` mean that the connection is
    being closed. `SYN_RCVD`, `ACK`, and `SYN+ACK` are all parts of connection creation
    (the three-way handshake from [Chapter 7](ch07.xhtml#ch07)). `LISTEN` indicates
    that the port is ready for incoming connections. In the preceding example, one
    TCP connection is running and four are ready to accept clients. As UDP is stateless,
    those connections list no state information.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，`(state)` 列显示 TCP 握手的状态。你不需要了解所有可能的 TCP 连接状态，只要了解什么是正常的就行。`ESTABLISHED` 表示连接已建立，数据可能正在流动。`LAST_ACK`、`FIN_WAIT_1`
    和 `FIN_WAIT_2` 表示连接正在关闭。`SYN_RCVD`、`ACK` 和 `SYN+ACK` 是连接创建的一部分（来自 [第 7 章](ch07.xhtml#ch07)
    的三次握手）。`LISTEN` 表示端口已准备好接收传入连接。在前面的示例中，一个 TCP 连接正在运行，四个连接准备接受客户端。由于 UDP 是无状态的，这些连接没有列出状态信息。
- en: By reading this output and combining it with information provided by sockstat(1),
    you can learn exactly which programs are behaving well and which are suffering
    bottlenecks.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 通过读取这些输出并结合 sockstat(1) 提供的信息，你可以准确了解哪些程序表现良好，哪些程序存在瓶颈。
- en: If you’re not interested in listening sockets but only those with active connections,
    use netstat(8)’s `-b` option instead of `-a`. Running `netstat -nb -f inet` displays
    only connections with foreign systems.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你对监听套接字不感兴趣，只关心那些有活动连接的套接字，可以使用 netstat(8) 的 `-b` 选项，而不是 `-a`。运行 `netstat
    -nb -f inet` 只会显示与远程系统的连接。
- en: You can also use netstat -T to display TCP retransmits and out-of-order packets
    on individual connections. Retransmits and misordered packets are symptoms of
    dropped packets.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以使用 `netstat -T` 来显示单个连接的 TCP 重传和乱序数据包。重传和乱序数据包是丢包的症状。
- en: '***Network Capacity in the Kernel***'
  id: totrans-162
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***内核中的网络容量***'
- en: The FreeBSD kernel handles network memory by using mbufs. An *mbuf* is a chunk
    of kernel memory used for networking. You’ll keep tripping across mentions of
    mbufs throughout the FreeBSD network stack documentation, so it’s important to
    have at least a vague idea of them.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: FreeBSD 内核通过使用 mbufs 来处理网络内存。*mbuf* 是用于网络的内核内存块。你将在 FreeBSD 网络堆栈文档中不断遇到关于 mbuf
    的提及，因此了解它们至少有一个模糊的概念是很重要的。
- en: FreeBSD automatically allocates network capacity at boot time based on the amount
    of physical RAM in the system. We assume that if you have a system with 64GB RAM,
    you want to use more memory for networking than on a little box with 1GB RAM.
    View how FreeBSD uses its resources with `netstat -s` and `netstat -m`. Let’s
    look at the shortest one first.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: FreeBSD 在启动时会自动根据系统中物理内存的大小分配网络带宽。我们假设，如果你有一个64GB内存的系统，你希望在网络上使用更多的内存，而不是一个只有1GB内存的小设备。通过
    `netstat -s` 和 `netstat -m` 查看 FreeBSD 如何使用其资源。我们先来看最简洁的一个。
- en: 'To get a generic view of kernel memory used for networking, run `netstat -m`.
    The output can be divided into two general categories: how much is used and how
    many requests failed. The following output is trimmed to include only a few examples
    of these, but they all follow the same general format:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 要获取关于用于网络的内核内存的概览，运行 `netstat -m`。输出可以分为两个大类：使用了多少内存和有多少请求失败。以下是经过剪裁的输出，只包括这些项中的几个例子，但它们都遵循相同的格式：
- en: '[PRE32]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Here we see how many mbuf clusters are used ➊. You’d probably guess that these
    are related to mbufs, and you’d be right. You don’t have to know exactly what
    mbuf clusters are; the important thing is that you know how many you can allocate
    ➋ and can see that you’re under that limit.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里我们看到使用了多少个 mbuf 集群 ➊。你可能会猜测这些与 mbuf 有关，答案是对的。你不需要完全知道 mbuf 集群是什么；重要的是你知道可以分配多少个，并且能够看到自己没有超过这个限制
    ➋。
- en: Similarly, we can see how many different requests for mbufs the kernel has denied
    ➌. This system hasn’t rejected any requests for mbufs, which means that we aren’t
    having performance problems due to memory shortages. If your system starts rejecting
    mbuf requests because it’s out of memory, you’re in trouble. See “Optimizing Network
    Performance” next.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，我们可以看到内核拒绝了多少次对 mbuf 的请求 ➌。这个系统没有拒绝任何 mbuf 请求，这意味着我们没有因为内存不足而造成的性能问题。如果你的系统开始因为内存不足而拒绝
    mbuf 请求，那就麻烦了。接下来请查看“优化网络性能”部分。
- en: While `netstat -m` produces a dozen lines of output, `netstat -s` runs for pages
    and pages. It provides per-protocol performance statistics. Much like `netstat
    -m`, you can break up these statistics into categories of how much was done and
    how many problems you had. Run both of these commands occasionally on your systems
    and review the results so you know what passes for normal on your servers and
    can recognize abnormal numbers when you have problems.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然 `netstat -m` 会生成十几行输出，`netstat -s` 则会产生多页输出。它提供了每种协议的性能统计数据。与 `netstat -m`
    类似，你可以将这些统计数据分为两类：做了多少事情以及遇到了多少问题。偶尔在你的系统上运行这两个命令，并查看结果，这样你就知道服务器上什么是正常的，并且在遇到问题时能够识别出异常的数据。
- en: '**Optimizing Network Performance**'
  id: totrans-170
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**优化网络性能**'
- en: 'Now that you can see what’s going on, how could you improve FreeBSD’s network
    performance? There’s a simple rule of thumb when considering optimizing: *don’t*.
    Network performance is generally limited only by your hardware. Many applications
    can’t process data as quickly as your network can provide. If you think that you
    need to optimize your performance, you’re probably looking in the wrong spot.
    Check [Chapter 21](ch21.xhtml#ch21) for hints on investigating performance bottlenecks.'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 既然你已经了解了发生了什么，那么如何提高 FreeBSD 的网络性能呢？在考虑优化时有一个简单的经验法则：*不要优化*。网络性能通常只受硬件的限制。许多应用程序处理数据的速度跟不上网络的提供速度。如果你认为需要优化性能，可能是你在错误的地方寻求解决方案。查看[第21章](ch21.xhtml#ch21)，那里有关于调查性能瓶颈的提示。
- en: Generally speaking, network performance should be adjusted only when you experience
    network problems. This means that you should have output from `netstat -m` or
    `netstat -s` indicating that the kernel is having resource problems. If the kernel
    starts denying requests for resources or dropping connection requests, look at
    the hints in this section. If you have issues or if you think you should be getting
    better performance, look at the hardware first.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 一般来说，只有在遇到网络问题时，才需要调整网络性能。这意味着你应该从 `netstat -m` 或 `netstat -s` 中获得输出，显示内核正在面临资源问题。如果内核开始拒绝资源请求或丢弃连接请求，请查看本节中的提示。如果你遇到问题，或者认为应该获得更好的性能，首先检查硬件。
- en: '***Optimizing Network Hardware***'
  id: totrans-173
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***优化网络硬件***'
- en: 'Not all network hardware is created equal. While anyone in IT hears this frequently,
    FreeBSD’s open nature makes this obvious. For example, here’s a comment from the
    source code of the rl(4) network card driver:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 不是所有的网络硬件都是一样的。虽然在 IT 行业中这句话被频繁提到，但 FreeBSD 的开放性让这一点显而易见。例如，以下是 rl(4) 网卡驱动源代码中的一条注释：
- en: '[PRE33]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: This can be summarized as, “This card sucks and blows at the same time. Buy
    another card.” While this is the most vitriolic comment that I’ve seen in the
    FreeBSD source code, and this particular hardware is very hard to find today,
    the drivers for certain other cards say the same thing in a more polite manner.
    Optimizing network performance with low-end hardware is like putting a high-performance
    racing transmission in your 1974 Gremlin. Replacing your cheap network card will
    probably fix your problems. Generally speaking, Intel makes decent network cards;
    they maintain a FreeBSD driver for their wired network cards and provide support
    so that the FreeBSD community can help maintain the drivers. (Wireless cards are
    another story.) Similarly, many companies that build server-grade machines make
    a point of using server-grade network cards. Some companies provide a FreeBSD
    driver but do not provide documentation for their hardware. This means that the
    driver probably works, but you’re entirely dependent upon the vendor’s future
    fondness of FreeBSD for your updates. Companies that specialize in inexpensive
    consumer network equipment are not your best choice for high-performance cards—after
    all, the average home user has no idea how to pick a network card, so they go
    by price alone. If in doubt, check the FreeBSD-questions mailing list archives
    for recent network card recommendations.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 这可以总结为：“这张卡同时又烂又差。买一张新卡吧。”虽然这是我在 FreeBSD 源代码中看到的最尖刻的评论，而且这款硬件今天很难找到，但某些其他卡的驱动程序以更礼貌的方式表达了相同的观点。用低端硬件优化网络性能就像将高性能赛车变速器装进
    1974 年的 Gremlin 车里。更换你的廉价网卡可能会解决你的问题。一般来说，英特尔生产的网卡不错；他们为有线网卡维护 FreeBSD 驱动程序，并提供支持，以便
    FreeBSD 社区帮助维护这些驱动程序。（无线网卡则是另一回事。）类似地，许多制造服务器级机器的公司特别注重使用服务器级网卡。有些公司提供 FreeBSD
    驱动程序，但不提供硬件文档。这意味着驱动程序可能正常工作，但你完全依赖于厂商未来对 FreeBSD 的喜好来获取更新。专注于低成本消费级网络设备的公司并不是高性能卡的最佳选择——毕竟，普通家庭用户通常不知道如何选择网卡，所以他们只看价格。如果不确定，可以查阅
    FreeBSD-questions 邮件列表的档案，寻找近期的网卡推荐。
- en: 'Similarly, switch quality varies wildly. The claim that a switch speaks the
    protocol used in gigabit connections doesn’t mean that you can actually push gigabit
    speed through every port! I have a 100Mb switch that bottlenecks at 15Mbps and
    a “gigabit” switch that seems to choke at about 50Mbps. I recommend that you think
    of a switch’s speed as a protocol or a language: I could claim that I speak Russian,
    but 30 years after my studies ceased, my speech bottlenecks at about three words
    a minute. My Russian language interface is of terrible quality. Again, switches
    designed for home use are not your best choice in a production environment.'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，交换机的质量差异也非常大。声称交换机支持千兆连接协议并不意味着你能够通过每个端口真正达到千兆速度！我有一台 100Mb 的交换机，在 15Mbps
    时会形成瓶颈，还有一台“千兆”交换机似乎在大约 50Mbps 时就开始卡顿。我建议你将交换机的速度视为一种协议或语言：我可以声称我会说俄语，但在我停止学习
    30 年后，我的口语速度每分钟大约只能说三个词。我的俄语接口质量非常差。同样，专为家庭使用设计的交换机并不是生产环境中的最佳选择。
- en: If getting decent hardware doesn’t solve your problems, read on.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 如果获得合适的硬件没有解决你的问题，请继续阅读。
- en: '***Memory Usage***'
  id: totrans-179
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***内存使用***'
- en: FreeBSD uses the amount of memory installed in a system to decide how much memory
    space to reserve for mbufs. Don’t adjust the number of mbufs you create unless
    `netstat -m` tells you that you’re short on mbuf space. If you have an mbuf problem,
    the real fix is to add memory to your machine. This will make FreeBSD recompute
    the number of mbufs created at boot and solve your problem. Otherwise, you’ll
    just shift the problem to a different part of the system or a different application.
    You might configure gobs of memory for network connections and find that you’ve
    smothered your database server. If you’re sure you want to proceed, though, here’s
    how you do it.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: FreeBSD 使用系统中安装的内存量来决定为 mbuf 保留多少内存空间。除非 `netstat -m` 告诉你 mbuf 空间不足，否则不要调整你创建的
    mbuf 数量。如果你遇到 mbuf 问题，真正的解决方法是向你的机器添加内存。这将使 FreeBSD 在启动时重新计算创建的 mbuf 数量，并解决你的问题。否则，你只会将问题转移到系统的其他部分或其他应用程序上。你可能为网络连接配置了大量内存，却发现你的数据库服务器被压垮了。不过，如果你确定要继续操作，下面是如何做的。
- en: Two sysctl values control mbuf allocation, `kern.maxusers` and `kern.ipc.nmbclusters`.
    The first, `kern.maxusers`, is a boot-time tunable. Your system automatically
    determines an appropriate `kern.maxusers` value from the system hardware at boot
    time. Adjusting this value is probably the best way to scale your system as a
    whole. In older versions of FreeBSD, `kern.maxusers` preallocated memory for networking
    and refused to release it for other tasks, so increasing `kern.maxusers` could
    badly impact other parts of the system. Modern FreeBSD does not preallocate network
    memory, however, so this is just an upper limit on networking memory. If `kern.maxusers`
    is too small, you’ll get warnings in */var/log/messages* (see [Chapter 21](ch21.xhtml#ch21)).
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 有两个 sysctl 值控制 mbuf 的分配，`kern.maxusers` 和 `kern.ipc.nmbclusters`。第一个，`kern.maxusers`，是一个启动时可调的参数。你的系统会在启动时自动根据系统硬件确定合适的
    `kern.maxusers` 值。调整这个值可能是扩展系统整体规模的最佳方法。在旧版本的 FreeBSD 中，`kern.maxusers` 会预分配网络内存，并拒绝将其释放给其他任务，因此增加
    `kern.maxusers` 可能会严重影响系统的其他部分。然而，现代 FreeBSD 并不会预分配网络内存，因此这仅仅是网络内存的上限。如果 `kern.maxusers`
    设置得过小，你将在 */var/log/messages* 中收到警告（请参阅 [第 21 章](ch21.xhtml#ch21)）。
- en: The sysctl `kern.ipc.nmbclusters` specifically controls the number of mbufs
    allocated by the system for data sitting in socket buffers, waiting to be sent
    to or read by an application. Although this is runtime tunable, it’s best to set
    it early at boot by defining it in */etc/sysctl.conf* (see [Chapter 6](ch06.xhtml#ch06)).
    If you set this too high, however, you can actually starve the kernel of memory
    for other tasks and panic the machine.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: sysctl `kern.ipc.nmbclusters` 专门控制系统为数据（存储在套接字缓冲区中，等待被应用程序发送或读取）分配的 mbufs 数量。尽管这是一个可以在运行时调整的参数，但最好在启动时就通过在
    */etc/sysctl.conf* 中定义它来进行设置（请参阅 [第 6 章](ch06.xhtml#ch06)）。然而，如果设置得过高，你实际上可能会导致内核无法为其他任务分配内存，从而使机器发生崩溃。
- en: '[PRE34]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Mbufs are allocated in units called *nmbclusters* (sometimes called *mbuf clusters*).
    While the size of an mbuf varies, one cluster is about 2KB. You can use simple
    math to figure out how much RAM your current nmbcluster setting requires and then
    calculate sensible values for your system and applications. This example machine
    has 25,600 nmbclusters, which means the kernel can use up to about 50MB RAM for
    networking purposes. This is negligible on my test laptop’s gig of RAM, but it
    might be unsuitable on an embedded system.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: Mbufs 是以称为 *nmbclusters*（有时也称为 *mbuf 集群*）的单位进行分配的。虽然一个 mbuf 的大小有所不同，但一个集群大约是
    2KB。你可以使用简单的数学计算来确定当前 nmbcluster 设置需要多少内存，然后为你的系统和应用程序计算出合适的值。这个示例机器有 25,600 个
    nmbclusters，这意味着内核可以为网络通信用途使用大约 50MB 的内存。对于我这台具有 1GB 内存的测试笔记本来说，这几乎可以忽略不计，但在嵌入式系统上可能不适用。
- en: 'To calculate an appropriate number of mbuf clusters, run `netstat -m` when
    the server is really busy. The second line of the output will give you the number
    of mbufs in use and the total number available. If your server at its busiest
    doesn’t use nearly as many nmbclusters as it has available, you’re barking up
    the wrong tree—stop futzing with mbufs and replace your hardware already.^([4](footnote.xhtml#ch08fn4))
    For example:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 要计算适当数量的 mbuf 集群，当服务器非常繁忙时运行 `netstat -m`。输出的第二行将显示正在使用的 mbuf 数量和可用的总数量。如果你的服务器在最繁忙时使用的
    nmbclusters 数量远远少于可用数量，那说明你可能走错了方向——停止调整 mbufs，尽早更换硬件吧。^([4](footnote.xhtml#ch08fn4))
    例如：
- en: '[PRE35]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: This system is currently using 32 nmbclusters ➊ on this machine and has cached
    372 previously used nmbclusters ➋. With this total of 404 clusters ➌ in memory
    at this time, our capacity of 25,600 clusters ➍ is 1.5 percent utilized. If this
    is your real system load, actually reducing the number of nmbclusters might make
    sense.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 目前此系统在此机器上使用了 32 个 nmbclusters ➊，并且缓存了 372 个之前使用过的 nmbclusters ➋。此时内存中共有 404
    个集群 ➌，而我们的 25,600 个集群 ➍ 仅使用了 1.5%。如果这就是你实际的系统负载，实际上减少 nmbclusters 的数量可能是有意义的。
- en: My personal rule of thumb is that a server should have enough mbufs to handle
    twice its standard high load. If your server uses 25,000 nmbclusters during peak
    hours, it should have at least 50,000 available to handle those brief irregular
    peaks.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 我的个人经验是，服务器应该有足够的 mbufs 来处理其标准高负载的两倍。如果你的服务器在高峰时段使用了 25,000 个 nmbclusters，那么它至少应该有
    50,000 个可用来应对这些短暂的异常高峰。
- en: '**ONCE-IN-A-LIFETIME VS. STANDARD LOAD**'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: '**一生一次的负载与标准负载**'
- en: Always distinguish planning for once-in-a-lifetime events from planning for
    normal load. When the US Government’s Affordable Care Act health insurance registration
    site went live, millions of users immediately tried to sign up. The first few
    days, the site was fiendishly slow. After a week, the hardware handled the load
    without trouble. This was certainly correct capacity planning.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 始终将一次性事件的规划与常规负载的规划区分开。当美国政府的《平价医疗法案》健康保险注册网站上线时，数百万用户立即尝试注册。在最初几天，该网站极其缓慢。经过一周，硬件处理负载时没有问题。这无疑是正确的容量规划。
- en: '***Maximum Incoming Connections***'
  id: totrans-191
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***最大并发连接数***'
- en: The FreeBSD kernel provides capacity to handle a certain number of incoming
    new TCP connections. This doesn’t refer to connections that the server previously
    received and is handling, but rather to clients who are attempting to initiate
    connections simultaneously. For example, the web pages currently being delivered
    to clients don’t count, but the incoming requests that have reached the kernel
    but not the web server process do. It’s a *very* narrow window, but some sites
    do overflow it.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: FreeBSD 内核提供了处理一定数量新 TCP 连接的能力。这并不是指服务器之前接收到并正在处理的连接，而是指那些尝试同时发起连接的客户端。例如，目前正在传递给客户端的网页不算在内，但已经到达内核但还未到达
    Web 服务器进程的请求则会计算在内。这是一个*非常*狭窄的窗口，但有些网站会超出这个限制。
- en: The sysctl `kern.ipc.somaxconn` dictates how many simultaneous connection attempts
    the system will try to handle. This defaults to 128, which might not be enough
    for a highly loaded web server. If you’re running a high-capacity server where
    you expect more than 128 new requests to be arriving simultaneously, you probably
    need to increase this sysctl. If users start complaining that they can’t connect,
    this might be your culprit. Of course, very few applications will accept that
    many simultaneous new connections; you’ll probably have to tune your app well
    before you hit this point.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: sysctl `kern.ipc.somaxconn` 决定了系统将尝试处理的同时连接请求的最大数量。默认值为 128，这对于高负载的 Web 服务器可能不够。如果你正在运行一个高容量的服务器，并且预计会有超过
    128 个新请求同时到达，你可能需要增加这个 sysctl 的值。如果用户开始抱怨无法连接，这可能就是问题所在。当然，很少有应用程序会接受这么多同时的新连接；在遇到这个问题之前，你可能需要对应用程序进行优化。
- en: '***Polling***'
  id: totrans-194
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***轮询***'
- en: Some gigabit cards can improve their performance with *polling*. Polling takes
    the time-honored idea of interrupts and IRQs and boots it out the window, replacing
    it with regular checks for network activity. In the classic interrupt-driven model,
    whenever a packet arrives at the network card, the card demands attention from
    the CPU by generating an interrupt. The CPU stops whatever it’s doing and handles
    that data. This is grand, and even desirable, when the card doesn’t process a
    huge amount of traffic. Once a system starts handling large amounts of data, however,
    the card generates interrupts continuously. Instead of constantly interrupting,
    the system is more efficient if the kernel grabs network data from the card at
    regular intervals. This regular checking is called *polling*. Generally speaking,
    polling is useful only if you push large amounts of traffic.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 一些千兆网卡可以通过*轮询*来提高性能。轮询采用了传统的中断和 IRQ 的概念，并将其抛出窗外，取而代之的是定期检查网络活动。在经典的中断驱动模式中，每当数据包到达网卡时，网卡会通过生成中断来请求
    CPU 的注意。CPU 会停止当前的任务，处理这些数据。当网卡处理的数据量不大的时候，这样做是很棒的，甚至是必要的。然而，一旦系统开始处理大量数据，网卡会持续生成中断。与其不断中断，系统更高效的做法是内核定期从网卡抓取网络数据。这个定期检查的过程叫做*轮询*。一般来说，轮询只有在推送大量流量时才有用。
- en: Polling isn’t available as a kernel module as of this writing, since it requires
    modifications to device drivers. This also means that not all network cards support
    polling, so be sure to check polling(4) for the complete list. Enable polling
    by adding `DEVICE_POLLING` to your kernel configuration. After your reboot, enable
    polling on a per-interface basis with ifconfig(8).
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，轮询（Polling）并未作为内核模块提供，因为它需要修改设备驱动程序。这也意味着并非所有网络卡都支持轮询，因此请务必查阅 polling(4)
    获取完整的支持列表。通过在内核配置中添加 `DEVICE_POLLING` 来启用轮询。重启后，可以通过 ifconfig(8) 逐个接口启用轮询。
- en: '[PRE36]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Similarly, disable polling with the argument `-polling`. The ifconfig(8) command
    also displays if polling is enabled on an interface. As you can enable and disable
    polling on the fly, enable polling when your system is under a heavy load and
    see whether performance improves.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 同样地，使用参数`-polling`禁用轮询。ifconfig(8)命令还会显示接口上是否启用了轮询。由于可以动态启用和禁用轮询，当系统负载较重时，启用轮询，看看性能是否有所改善。
- en: Polling is used only on older cards. 10GB cards and faster can’t poll.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 轮询仅在旧卡上使用。10GB卡及更快的卡无法进行轮询。
- en: '***Other Optimizations***'
  id: totrans-200
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***其他优化***'
- en: FreeBSD has about 200 networking-related sysctls. You have all the tools you
    need to optimize your system so greatly that it no longer passes any traffic at
    all. Be very careful when playing with network optimizations. Many settings that
    seem to fix problems actually fix only one set of problems while introducing a
    whole new spectrum of issues.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: FreeBSD有大约200个与网络相关的sysctl。你拥有所有的工具，可以优化系统到一个极限，以至于它完全不再通过任何流量。玩网络优化时要非常小心。许多看似能解决问题的设置，实际上只修复了某一类问题，却引入了新的问题。
- en: Some software vendors (i.e., Samba) recommend particular network sysctl changes.
    Try them cautiously, and watch for unexpected side effects on other programs before
    accepting them as your new default. TCP/IP is a terribly, terribly complicated
    protocol, and FreeBSD’s defaults and autotuning reflect years of experience, testing,
    and sysadmin suffering.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 一些软件供应商（例如Samba）推荐特定的网络sysctl更改。谨慎尝试这些更改，并观察它们是否对其他程序产生意外的副作用，然后再将其作为新默认设置。TCP/IP是一个极其复杂的协议，而FreeBSD的默认设置和自动调优反映了多年的经验、测试和系统管理员的痛苦。
- en: Also remember that FreeBSD is over two decades old. Mailing list and forum posts
    from more than a few years ago are probably not useful in network tuning.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 还要记住，FreeBSD已经有二十多年历史了。几年前的邮件列表和论坛帖子可能对网络调优不再有用。
- en: '**Network Adapter Teaming**'
  id: totrans-204
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**网络适配器团队**'
- en: As network servers become more and more vital to business, redundancy becomes
    more important. We have redundant hard drives in a server and redundant bandwidth
    into a data center, but what about redundant bandwidth into a server? On a smaller
    scale, as you move around your office, you might move your laptop between wired
    and wireless connections. It would be really nice not to lose your existing SSH
    sessions because you unplugged a cable.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 随着网络服务器在业务中的重要性不断增加，冗余变得愈发重要。我们在服务器中有冗余硬盘，在数据中心有冗余带宽，但服务器的冗余带宽如何解决呢？在小范围内，当你在办公室内移动时，可能会在有线和无线连接之间切换。能够在拔掉电缆后仍然保持现有的SSH会话不掉线，真的是一件非常棒的事情。
- en: FreeBSD can treat two network cards as a single entity, allowing you to have
    multiple connections with a single switch. This is commonly called *network adapter
    teaming*, *bonding*, or *link aggregation*. FreeBSD implements adapter teaming
    through lagg(4), the link aggregation interface.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: FreeBSD可以将两个网卡视为一个实体，允许你与一个交换机建立多个连接。这通常被称为*网络适配器团队*、*绑定*或*链路聚合*。FreeBSD通过lagg(4)实现适配器团队，即链路聚合接口。
- en: '**TRUNKING, TEAMING, AND VLANS**'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: '**TRUNKING、TEAMING 和 VLANs**'
- en: Some vendors use the word *trunk* to describe link aggregation. Other vendors
    use the word *trunk* to describe one cable with multiple networks (VLANs). FreeBSD
    avoids this argument by not using the word *trunk*. If someone starts discussing
    trunks in your presence, ask them what kind they’re talking about.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 一些供应商使用*trunk*这个词来描述链路聚合。其他供应商则使用*trunk*来描述一根带有多个网络（VLAN）的电缆。FreeBSD通过不使用*trunk*这个词来避免这种争议。如果有人在你面前讨论trunk，问问他们指的是哪一种。
- en: The kernel module lagg(4) provides a lagg0 virtual interface. You assign physical
    interfaces to the lagg0 interface, making them part of the aggregated link. While
    you could use lagg(4) with only one physical interface, aggregating links only
    makes sense when you have two or more physical interfaces to assign to the aggregated
    link. The lagg(4) module allows you to implement seamless roaming between wired
    and wireless networks, failover, and several different aggregation protocols.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 内核模块lagg(4)提供了一个lagg0虚拟接口。你将物理接口分配给lagg0接口，使它们成为聚合链路的一部分。虽然你可以只使用一个物理接口来使用lagg(4)，但只有在你有两个或更多物理接口可分配到聚合链路时，聚合链路才有意义。lagg(4)模块允许你在有线和无线网络之间实现无缝漫游、故障转移，以及几种不同的聚合协议。
- en: '***Aggregation Protocols***'
  id: totrans-210
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***聚合协议***'
- en: Not all network switches support all link aggregation protocols. FreeBSD has
    basic implementation of some complicated high-end protocols and also includes
    very basic failover setups. The three I recommend are Fast EtherChannel, LACP,
    and failover. (There are more schemes, which you can read about in lagg(4).)
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 不是所有的网络交换机都支持所有的链路聚合协议。FreeBSD对一些复杂的高端协议提供了基本实现，同时也包括了非常基础的故障转移设置。我推荐的三种协议是Fast
    EtherChannel、LACP和故障转移。（还有更多的方案，可以在lagg(4)中查看。）
- en: Cisco’s *Fast EtherChannel (FEC)* is a reliable link aggregation protocol, but
    it works only on high- to medium-end Cisco switches running particular versions
    of Cisco’s operating system. If you have an unmanaged switch, Fast EtherChannel
    is not a viable choice. Fast EtherChannel is complicated to configure (on the
    switch), so I recommend FEC only when it is already your corporate standard for
    link aggregation.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: Cisco的*Fast EtherChannel (FEC)*是一个可靠的链路聚合协议，但仅适用于运行特定版本Cisco操作系统的高端到中端Cisco交换机。如果你使用的是非托管交换机，Fast
    EtherChannel就不是一个可行的选择。Fast EtherChannel的配置比较复杂（在交换机上），因此我只建议在它已经成为你公司链路聚合标准的情况下使用FEC。
- en: The *Link Aggregation Control Protocol (LACP)* is an industry standard for link
    aggregation. The physical interfaces are bonded into a single virtual interface
    with approximately the same bandwidth as all of the individual links combined.
    LACP provides excellent fault tolerance, and almost all switches support it. I
    recommend LACP unless you have a specific requirement for Fast EtherChannel or
    a switch that chokes when you use LACP.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: '*链路聚合控制协议（LACP）*是链路聚合的行业标准。物理接口被合并为一个虚拟接口，其带宽大约等于所有单独链接的总和。LACP提供了出色的容错能力，几乎所有交换机都支持它。除非你有特定要求使用Fast
    EtherChannel，或者在使用LACP时交换机会出现问题，否则我推荐使用LACP。'
- en: If you do have a switch that chokes on LACP, use *failover*. The failover method
    sends traffic through one physical interface at a time. If that interface goes
    down, the connection fails over to the next connection in the pool. While you
    don’t get aggregated bandwidth, you do get the ability to attach your server to
    multiple switches for fault tolerance. Use failover to let your laptop roam between
    wired and wireless connections.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你的交换机在使用LACP时出现问题，使用*failover*。故障转移方法一次通过一个物理接口传输流量。如果该接口出现故障，连接会自动切换到池中的下一个连接。虽然你无法获得聚合带宽，但你可以将服务器连接到多个交换机上以实现容错。使用故障转移可以让你的笔记本电脑在有线和无线连接之间切换。
- en: '***Configuring lagg(4)***'
  id: totrans-215
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***配置lagg(4)***'
- en: The lagg interface is virtual, meaning there is no physical part of the machine
    that you could point to and say, “That is interface lagg0.” Before you can configure
    the interface, you must create it. FreeBSD lets you create interfaces with `ifconfig`
    interfacename `create`, but you can also do this in */etc/rc.conf* with the `cloned_interfaces`
    statement.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: lagg接口是虚拟的，意味着没有物理部分可以指认为“这是lagg0接口”。在你配置该接口之前，必须先创建它。FreeBSD允许你使用`ifconfig`命令通过`ifconfig
    interfacename create`创建接口，但你也可以在*/etc/rc.conf*中使用`cloned_interfaces`语句来创建接口。
- en: 'Configuring a lagg(4) interface in *rc.conf* has three steps: creating the
    interface, bringing up the physical interfaces, and aggregating them. Here, we
    create a single lagg0 interface out of two Intel gigabit Ethernet cards, em0 and
    em1.'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 在*rc.conf*中配置lagg(4)接口有三个步骤：创建接口、启动物理接口、以及聚合它们。在这里，我们通过两个Intel千兆以太网卡em0和em1创建一个单独的lagg0接口。
- en: '[PRE37]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: First, you list lagg0 as a cloned interface, so FreeBSD will create this interface
    at boot. Then, bring interfaces em0 and em1 up, but don’t configure them. Finally,
    tell the lagg0 interface what aggregation protocol to use (LACP), what physical
    interfaces belong to it, and its network information. These few lines of configuration
    give you a high-availability Ethernet connection.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，你将lagg0列为一个克隆接口，这样FreeBSD在启动时就会创建这个接口。然后，启动em0和em1接口，但不要配置它们。最后，告诉lagg0接口使用哪种聚合协议（LACP）、哪些物理接口属于它，以及它的网络信息。这几行配置将为你提供一个高可用性的以太网连接。
- en: '**Virtual LANs**'
  id: totrans-220
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**虚拟局域网（VLAN）**'
- en: A *virtual LAN*, or *VLAN*, lets you get multiple Ethernet segments on a single
    piece of wire. You’ll sometimes see VLANs called *802.1q*, *tagging*, or a combination
    of these terms. You can use these multiple networks by configuring additional
    logical interfaces attached to a physical interface. The physical wire can still
    carry only so much data, however, so all VLANs and the regular network (or *native
    VLAN* ) that share the wire use a common pool of bandwidth. If you need a FreeBSD
    host on multiple Ethernet segments simultaneously, this is one way to do it without
    running more cable.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: '*虚拟局域网*，或*VLAN*，允许你在一根线上的多个以太网段。你有时会看到VLAN被称为*802.1q*、*标记*，或这几个术语的组合。你可以通过配置附加到物理接口的额外逻辑接口来使用这些多个网络。然而，物理线路仍然只能承载有限的数据量，因此所有VLAN和共享线路的常规网络（或*原生VLAN*）都使用一个共同的带宽池。如果你需要在多个以太网段上同时使用FreeBSD主机，这就是一种不需要再拉更多电缆的方式。'
- en: VLAN frames that arrive at your network card are like regular Ethernet frames,
    tagged with an additional header that says “This is part of VLAN number whatever.”
    Each VLAN is identified by a tag from 1 to 4096\. The native VLAN arrives without
    any tagging whatsoever. The network often (but not always) calls this *VLAN 1*
    internally.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 到达网络卡的VLAN帧就像常规以太网帧，附带一个额外的头部，表示“这是VLAN编号的部分。”每个VLAN通过1到4096之间的标签来识别。原生VLAN则没有任何标签。网络通常（但不总是）内部称其为*VLAN
    1*。
- en: Configuring a VLAN on your FreeBSD host doesn’t magically connect the host to
    the VLAN. The network must be configured to send those VLANs to your host. You
    must work with the network team to get access to the VLANs.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 在你的FreeBSD主机上配置VLAN并不会自动将主机连接到VLAN。网络必须配置为将这些VLAN发送到你的主机。你需要与网络团队合作以获得VLAN的访问权限。
- en: '***Configuring VLAN Devices***'
  id: totrans-224
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***配置VLAN设备***'
- en: Use ifconfig(8) to create VLAN interfaces. You must know the physical interface
    and the VLAN tag.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 使用ifconfig(8)来创建VLAN接口。你必须知道物理接口和VLAN标签。
- en: '[PRE38]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Here, I create an interface for VLAN 2 and attach it to the interface em0.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我为VLAN 2创建一个接口，并将其附加到接口em0。
- en: '[PRE39]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: I can now configure interface em0.2 as I would a physical interface.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我可以像配置物理接口一样配置接口em0.2。
- en: '[PRE40]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: In reality, I’d probably do all of this in a single command.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，我可能会在一个命令中完成所有这些操作。
- en: '[PRE41]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: That’s everything. Now use ifconfig(8) to display your new interface.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 一切完成了。现在使用ifconfig(8)来显示你的新接口。
- en: '[PRE42]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: This looks almost exactly like any other physical interface. The media information
    ➊ comes directly from the underlying interface. You’ll see a label with VLAN information
    ➋ and a note that this is grouped with the other VLAN interfaces ➌.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 这看起来几乎和任何其他物理接口一样。媒体信息➊直接来自底层接口。你会看到一个带有VLAN信息的标签➋，以及一个说明这是与其他VLAN接口分组的注释➌。
- en: '***Configuring VLANs at Boot***'
  id: totrans-236
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***启动时配置VLAN***'
- en: Configure VLANs at boot with *rc.conf* variables. First, use a `vlan_` variable
    tagged with the interface name to list the VLANs attached to that interface. Here,
    I tell FreeBSD to enable VLAN 2 and 3 on interface em0 and assign an IP configuration
    to each.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 使用*rc.conf*变量在启动时配置VLAN。首先，使用带有接口名称的`vlan_`变量列出附加到该接口的VLAN。在这里，我告诉FreeBSD在接口em0上启用VLAN
    2和3，并为每个VLAN分配IP配置。
- en: '[PRE43]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: If the underlying interface has no configuration, you need to at least bring
    it up. The VLAN interfaces won’t work unless the physical interface is on.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 如果底层接口没有配置，你至少需要将其启用。除非物理接口开启，否则VLAN接口无法工作。
- en: '[PRE44]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: You now have virtual LANs at boot. Congratulations!
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你在启动时已经有了虚拟局域网。恭喜！
- en: Now that you have a working network, let’s get a little more local and look
    at basic system security.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经有了一个正常工作的网络，让我们稍微本地化一点，来看一下基本的系统安全。
