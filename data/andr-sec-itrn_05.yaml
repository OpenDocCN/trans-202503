- en: Chapter 5. Cryptographic Providers
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第 5 章. 加密提供者
- en: This chapter introduces Android’s cryptographic provider architecture and discusses
    the built-in providers and the algorithms they support. Because Android builds
    on the *Java Cryptography Architecture (JCA)*, we introduce its design in brief,
    starting with the *cryptographic service provider (CSP)* framework. We then discuss
    the main JCA classes and interfaces, and the cryptographic primitives they implement.
    (We will briefly introduce each cryptographic primitive, but a thorough discussion
    is beyond the scope of this book and some familiarity with basic cryptography
    is assumed.) Next, we present Android’s JCA providers and cryptographic libraries
    as well as the algorithms each provider supports. Finally, we show how to use
    additional cryptography algorithms by installing a custom JCA provider.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章介绍了 Android 的加密提供者架构，并讨论了内置的提供者及其支持的算法。由于 Android 构建于*Java 加密架构（JCA）*之上，我们简要介绍了其设计，从*加密服务提供者（CSP）*框架开始。接着，我们讨论了主要的
    JCA 类和接口，以及它们实现的加密原语。（我们将简要介绍每个加密原语，但详细讨论超出了本书的范围，假设读者对基本的加密学有一定了解。）然后，我们介绍了 Android
    的 JCA 提供者和加密库，以及每个提供者支持的算法。最后，我们展示了如何通过安装自定义的 JCA 提供者来使用额外的加密算法。
- en: JCA Provider Architecture
  id: totrans-2
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: JCA 提供者架构
- en: JCA provides an extensible cryptographic provider framework and a set of APIs
    covering the major cryptographic primitives in use today (block ciphers, message
    digests, digital signatures, and so on). This architecture aims to be implementation-independent
    and extensible. Applications that use the standard JCA APIs only need to specify
    the cryptographic algorithm they want to use and (in most cases) do not depend
    on a particular provider implementation. Support for new cryptographic algorithms
    can be added by simply registering an additional provider that implements the
    required algorithms. Additionally, cryptographic services offered by different
    providers are generally interoperable (with certain restrictions when keys are
    hardware-protected or key material is otherwise not directly available) and applications
    are free to mix and match services from different providers as needed. Let’s look
    at JCA’s architecture in more detail.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: JCA 提供了一个可扩展的加密提供者框架和一组 API，涵盖了当今使用的主要加密原语（块密码、消息摘要、数字签名等）。该架构旨在实现独立且可扩展。仅使用标准
    JCA API 的应用程序只需要指定它们想要使用的加密算法，并且（在大多数情况下）不依赖于特定的提供者实现。通过简单地注册一个实现所需算法的附加提供者，可以为新的加密算法添加支持。此外，不同提供者提供的加密服务通常是互操作的（当密钥受到硬件保护或密钥材料不可直接访问时，会有某些限制），并且应用程序可以根据需要自由混合和匹配来自不同提供者的服务。让我们更详细地了解
    JCA 的架构。
- en: Cryptographic Service Providers
  id: totrans-4
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 加密服务提供者
- en: JCA splits cryptographic functionality into a number of abstract cryptographic
    services called *engines* and defines APIs for each service in the form of an
    *engine class*. For example, digital signatures are represented by the `Signature`
    engine class, and encryption is modeled with the `Cipher` class. (You’ll find
    a comprehensive list of engine classes in the next section.)
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: JCA 将加密功能分为多个抽象的加密服务，称为*引擎*，并为每项服务定义了相应的 API，形式为*引擎类*。例如，数字签名由 `Signature` 引擎类表示，加密则通过
    `Cipher` 类建模。（你将在下一节找到完整的引擎类列表。）
- en: In the context of JCA, a *cryptographic service provider* (*CSP*, or simply
    *provider*) is a package (or set of packages) that provides a concrete implementation
    of certain cryptographic services. Each provider advertises the services and algorithms
    it implements, allowing the JCA framework to maintain a registry of supported
    algorithms and their implementing providers. This registry maintains a preference
    order for providers, so if a certain algorithm is offered by more than one provider,
    the one with higher preference order is returned to the requesting application.
    An exception to this rule is made for engine classes that support *delayed provider
    selection* (`Cipher`, `KeyAgreement`, `Mac`, and `Signature`). With delayed provider
    selection, the provider is selected not when an instance of the engine class is
    created, but when the engine class is initialized for a particular cryptographic
    operation. Initialization requires a `Key` instance, which the system uses to
    find a provider that can accept the specified `Key` object. Delayed provider selection
    is helpful when using keys that are stored in hardware because the system cannot
    find the hardware-backed provider based on the algorithm name alone. However,
    concrete `Key` instances passed to initialization methods usually have enough
    information to determine the underlying provider.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 在 JCA 的上下文中，*加密服务提供者*（*CSP*，简称*提供者*）是一个包（或一组包），提供某些加密服务的具体实现。每个提供者都会发布它实现的服务和算法，使得
    JCA 框架能够维护一个支持的算法及其实现提供者的注册表。这个注册表会保持提供者的优先顺序，因此，如果某个算法被多个提供者提供，系统会返回优先顺序更高的那个提供者给请求的应用程序。这个规则有一个例外，那就是对于支持*延迟提供者选择*（`Cipher`、`KeyAgreement`、`Mac`
    和 `Signature`）的引擎类。在延迟提供者选择的情况下，提供者不是在引擎类实例化时选择，而是在引擎类为特定加密操作初始化时选择。初始化需要一个`Key`实例，系统使用该实例来找到能够接受指定`Key`对象的提供者。延迟提供者选择在使用硬件存储的密钥时特别有用，因为系统仅凭算法名称无法找到硬件支持的提供者。然而，传递给初始化方法的具体`Key`实例通常包含足够的信息来确定底层的提供者。
- en: Note
  id: totrans-7
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '*Current Android versions don’t support delayed provider selection, but some
    related work is being done in the master branch, and delayed provider selection
    will likely be supported in a future version.*'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: '*当前的 Android 版本不支持延迟提供者选择，但在主分支中正在进行相关工作，未来版本可能会支持延迟提供者选择。*'
- en: Let’s look at an example using the provider configuration illustrated in [Figure 5-1](ch05.html#jca_algorithm_implementation_selection_w
    "Figure 5-1. JCA algorithm implementation selection when provider is not specified").
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 我们来看一个使用提供者配置的例子，如[图 5-1](ch05.html#jca_algorithm_implementation_selection_w
    "图 5-1. JCA 算法实现选择（当未指定提供者时）")所示。
- en: '![JCA algorithm implementation selection when provider is not specified](figs/web/05fig01.png.jpg)'
  id: totrans-10
  prefs: []
  type: TYPE_IMG
  zh: '![JCA 算法实现选择（当未指定提供者时）](figs/web/05fig01.png.jpg)'
- en: Figure 5-1. JCA algorithm implementation selection when provider is not specified
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5-1. JCA 算法实现选择（当未指定提供者时）
- en: If an application requests an implementation of the SHA-256 digest algorithm
    without specifying a provider (as shown in [Example 5-1](ch05.html#requesting_a_sha-256_implementation_with
    "Example 5-1. Requesting a SHA-256 implementation without specifying a provider")),
    the provider framework returns the implementation found in *ProviderB* (number
    2 in the list in [Figure 5-1](ch05.html#jca_algorithm_implementation_selection_w
    "Figure 5-1. JCA algorithm implementation selection when provider is not specified")),
    not the one in *ProviderC*, which also supports SHA-256, but which is number 3
    in the list in [Figure 5-1](ch05.html#jca_algorithm_implementation_selection_w
    "Figure 5-1. JCA algorithm implementation selection when provider is not specified").
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 如果应用程序请求 SHA-256 摘要算法的实现而没有指定提供者（如[示例 5-1](ch05.html#requesting_a_sha-256_implementation_with
    "示例 5-1. 请求未指定提供者的 SHA-256 实现")所示），则提供者框架返回在*ProviderB*中找到的实现（[图 5-1](ch05.html#jca_algorithm_implementation_selection_w
    "图 5-1. JCA 算法实现选择（当未指定提供者时）")中列表中的第 2 项），而不是在*ProviderC*中找到的实现，后者也支持 SHA-256，但在[图
    5-1](ch05.html#jca_algorithm_implementation_selection_w "图 5-1. JCA 算法实现选择（当未指定提供者时）")中的列表中排在第
    3 位。
- en: Example 5-1. Requesting a SHA-256 implementation without specifying a provider
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 5-1. 请求未指定提供者的 SHA-256 实现
- en: '[PRE0]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: On the other hand, if the application specifically requests *ProviderC* (as
    shown in [Example 5-2](ch05.html#requesting_a_sha-256_implementation_from "Example 5-2. Requesting
    a SHA-256 implementation from a specific provider")), its implementation will
    be returned even though *ProviderB* has a higher preference order.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，如果应用程序明确请求 *ProviderC*（如[示例 5-2](ch05.html#requesting_a_sha-256_implementation_from
    "示例 5-2. 从特定提供者请求 SHA-256 实现")）所示，即使 *ProviderB* 的优先级较高，它的实现仍会被返回。
- en: Example 5-2. Requesting a SHA-256 implementation from a specific provider
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 5-2. 从特定提供者请求 SHA-256 实现
- en: '[PRE1]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Generally, applications should not explicitly request a provider unless they
    include the requested provider as part of the application or can handle fallback
    if the preferred provider is not available.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，应用程序不应显式请求提供者，除非它们将所请求的提供者作为应用程序的一部分，或能够在首选提供者不可用时处理回退。
- en: Provider Implementation
  id: totrans-19
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提供者实现
- en: The JCA framework guarantees implementation independence by requiring all implementations
    of a particular cryptographic service or algorithm to conform to a common interface.
    For each engine class that represents a particular cryptographic service, the
    framework defines a corresponding abstract *Service Provider Interface (SPI)*
    class. Providers that offer a particular cryptographic service implement and advertise
    the corresponding SPI class. For example, a provider that implements a given encryption
    algorithm would have an implementation of the `CipherSpi` class that corresponds
    to the `Cipher` engine class. When an application calls the `Cipher.getInstance()`
    factory method, the JCA framework finds the appropriate provider by using the
    process outlined in “[Cryptographic Service Providers](ch05.html#cryptographic_service_providers
    "Cryptographic Service Providers")” and returns a `Cipher` instance that routes
    all of its method calls to the `CipherSpi` subclass implemented in the selected
    provider.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: JCA 框架通过要求所有特定加密服务或算法的实现符合一个公共接口，保证了实现的独立性。对于每个表示特定加密服务的引擎类，框架定义了一个对应的抽象 *服务提供者接口（SPI）*
    类。提供特定加密服务的提供者实现并公布相应的 SPI 类。例如，提供实现某个加密算法的提供者，将有一个对应于 `Cipher` 引擎类的 `CipherSpi`
    类实现。当应用程序调用 `Cipher.getInstance()` 工厂方法时，JCA 框架通过使用 “[加密服务提供者](ch05.html#cryptographic_service_providers
    "加密服务提供者")” 中概述的过程，找到合适的提供者，并返回一个 `Cipher` 实例，该实例将所有方法调用路由到所选提供者中实现的 `CipherSpi`
    子类。
- en: In addition to SPI implementation classes, each provider has a subclass of the
    abstract `java.security.Provider` class that defines the name and version of the
    provider and, more importantly, a list of the supported algorithms and matching
    SPI implementation classes. The JCA provider framework uses this `Provider` class
    to build the provider registry, and queries it when searching for algorithm implementations
    to return to its clients.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 除了 SPI 实现类外，每个提供者还有一个 `java.security.Provider` 类的子类，该子类定义了提供者的名称和版本，更重要的是，定义了支持的算法列表以及匹配的
    SPI 实现类。JCA 提供者框架使用这个 `Provider` 类来构建提供者注册表，并在搜索算法实现时查询它，以返回给客户端。
- en: Static Provider Registration
  id: totrans-22
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 静态提供者注册
- en: 'In order for a provider to be visible to the JCA framework, it must be registered
    first. There are two ways to register a provider: statically and dynamically.
    Static registration requires editing the system security properties file and adding
    an entry for the provider. (On Android, this properties file is called *security.properties*
    and is only present inside the *core.jar* system library. Therefore, it cannot
    be edited and static provider registration is not supported. We describe it here
    only for completeness.)'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使提供者对 JCA 框架可见，它必须首先注册。注册提供者有两种方式：静态注册和动态注册。静态注册需要编辑系统安全属性文件并为提供者添加条目。（在 Android
    上，这个属性文件叫做 *security.properties*，并仅存在于 *core.jar* 系统库内。因此，它无法编辑，并且不支持静态提供者注册。我们这里只是为了完整性提到它。）
- en: A provider entry in the security properties file is formatted as shown in [Example 5-3](ch05.html#static_registration_of_a_jca_provider
    "Example 5-3. Static registration of a JCA provider").
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 安全属性文件中的提供者条目格式如[示例 5-3](ch05.html#static_registration_of_a_jca_provider "示例
    5-3. JCA 提供者的静态注册")所示。
- en: Example 5-3. Static registration of a JCA provider
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 5-3. JCA 提供者的静态注册
- en: '[PRE2]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Here, *n* is the provider’s preference order that is used when searching for
    requested algorithms (when no provider name is specified). The order is 1-based;
    that is, 1 is the most preferred, followed by 2, and so on. `ProviderClassName`
    is the name of the `java.security.Provider` class implementation described in
    “[Provider Implementation](ch05.html#provider_implementation "Provider Implementation")”.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，*n*是提供者的优先顺序，用于在搜索请求的算法时（当未指定提供者名称时）。顺序是基于1的；即，1为最优先，接下来是2，依此类推。`ProviderClassName`是`java.security.Provider`类实现的名称，如“[提供者实现](ch05.html#provider_implementation
    "提供者实现")”所述。
- en: Dynamic Provider Registration
  id: totrans-28
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 动态提供者注册
- en: Providers are registered dynamically (at runtime) with the `addProvider()` and
    `insertProviderAt()` methods of the `java.security.Security` class. These methods
    return the actual position in which the provider was added, or –1 if the provider
    was not added because it was already installed. Providers can also be removed
    dynamically by calling the `removeProvider()` method.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 提供者通过`java.security.Security`类的`addProvider()`和`insertProviderAt()`方法动态注册（在运行时）。这些方法返回提供者添加的实际位置，或者如果提供者未被添加（因为它已安装），则返回-1。还可以通过调用`removeProvider()`方法动态移除提供者。
- en: The `Security` class manages the list of security `Provider`s and effectively
    acts as the provider registry described in the previous sections. In Java SE,
    programs require special permissions in order to register providers and modify
    the provider registry because by inserting a new provider at the top of the provider
    list, they can effectively replace the system security implementation. In Android,
    modifications to the provider registry are limited to the current app process
    and cannot affect the system or other applications. Therefore, no special permissions
    are required in order to register a JCA provider.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: '`Security`类管理安全`Provider`列表，并有效地充当前面章节描述的提供者注册表。在Java SE中，程序需要特殊权限才能注册提供者并修改提供者注册表，因为通过将新提供者插入到提供者列表的顶部，它们可以有效地替换系统安全实现。在Android中，提供者注册表的修改仅限于当前应用进程，不能影响系统或其他应用程序。因此，注册JCA提供者无需特殊权限。'
- en: Dynamic modifications to the provider registry are typically placed in a static
    block to ensure that they are executed before any application code. [Example 5-4](ch05.html#dynamically_inserting_a_custom_jca_provi
    "Example 5-4. Dynamically inserting a custom JCA provider") shows an example of
    replacing the default (top priority) provider with a custom one.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 对提供者注册表的动态修改通常放置在静态代码块中，以确保它们在任何应用程序代码之前执行。[示例 5-4](ch05.html#dynamically_inserting_a_custom_jca_provi
    "示例 5-4. 动态插入自定义JCA提供者")展示了一个将默认（优先级最高）提供者替换为自定义提供者的示例。
- en: Example 5-4. Dynamically inserting a custom JCA provider
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 5-4. 动态插入自定义JCA提供者
- en: '[PRE3]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Note
  id: totrans-34
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '*If the class is loaded more than once (for example, by different class loaders),
    the static block may be executed multiple times. You can work around this by checking
    whether the provider is already available or by using a holder class that is loaded
    only once.*'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: '*如果类被加载多次（例如，由不同的类加载器加载），静态代码块可能会多次执行。可以通过检查提供者是否已可用或使用仅加载一次的持有类来解决此问题。*'
- en: JCA Engine Classes
  id: totrans-36
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: JCA引擎类
- en: 'An engine class provides the interface to a specific type of cryptographic
    service. JCA engines provide one of the following services:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 引擎类提供特定类型加密服务的接口。JCA引擎提供以下服务之一：
- en: Cryptographic operations (encrypt/decrypt, sign/verify, hash, and so on)
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 加密操作（加密/解密、签名/验证、哈希等）
- en: Generation or conversion of cryptographic material (keys and algorithm parameters)
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 生成或转换加密材料（密钥和算法参数）
- en: Management and storage of cryptographic objects, such as keys and digital certificates
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 加密对象的管理和存储，如密钥和数字证书
- en: Obtaining an Engine Class Instance
  id: totrans-41
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 获取引擎类实例
- en: In addition to providing a unified interface to cryptographic operations, engine
    classes decouple client code from the underlying implementation, which is why
    they cannot be instantiated directly; instead, they provide a static factory method
    called `getInstance()` that lets you request an implementation indirectly. The
    `getInstance()` method typically has one of the signatures shown in [Example 5-5](ch05.html#jca_engine_class_factory_method_signatur
    "Example 5-5. JCA engine class factory method signatures").
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 除了提供统一的加密操作接口外，engine类还将客户端代码与底层实现解耦，这就是为什么它们不能直接实例化的原因；相反，它们提供了一个静态工厂方法`getInstance()`，使你可以间接请求一个实现。`getInstance()`方法通常具有[示例5-5](ch05.html#jca_engine_class_factory_method_signatur
    "Example 5-5. JCA engine class factory method signatures")中显示的签名之一。
- en: Example 5-5. JCA engine class factory method signatures
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 示例5-5. JCA engine类工厂方法签名
- en: '[PRE4]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Usually, you would use the signature at ➊ and specify only the algorithm name.
    The signatures at ➋ and ➌ allow you to request an implementation from a specific
    provider. All variants throw a `NoSuchAlgorithmException` if an implementation
    for the requested algorithm is not available and ➋ throws `NoSuchProviderException`
    if a provider with the specified name is not registered.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，你会使用➊处的签名并仅指定算法名称。➋和➌处的签名允许你从特定提供者请求实现。如果请求的算法没有可用的实现，所有变体都会抛出`NoSuchAlgorithmException`，而➋会抛出`NoSuchProviderException`，如果指定名称的提供者未注册。
- en: Algorithm Names
  id: totrans-46
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 算法名称
- en: The string `algorithm` parameter that all factory methods take maps to a particular
    cryptographic algorithm or transformation, or specifies an implementation strategy
    for higher-level objects that manage collections of certificates or keys. Usually,
    the mapping is straightforward. For example, *SHA-256* maps to an implementation
    of the SHA-256 hashing algorithm and *AES* requests an implementation of the AES
    encryption algorithm. However, some algorithm names have structure and specify
    more than one parameter of the requested implementation. For example, *SHA256withRSA*
    specifies a signature implementation that uses SHA-256 for hashing the signed
    message and RSA to perform the signature operation. Algorithms can also have aliases,
    and more than one algorithm name can map to the same implementation.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 所有工厂方法所接受的`algorithm`参数映射到特定的加密算法或变换，或指定用于管理证书或密钥集合的更高层对象的实现策略。通常，映射是直接的。例如，*SHA-256*映射到SHA-256哈希算法的实现，*AES*请求AES加密算法的实现。然而，一些算法名称具有结构，指定请求的实现的多个参数。例如，*SHA256withRSA*指定一个签名实现，使用SHA-256对签名的消息进行哈希处理，使用RSA执行签名操作。算法还可以有别名，多个算法名称可以映射到相同的实现。
- en: Algorithm names are case-insensitive. The standard algorithm names supported
    by each JCA engine class are defined in the *JCA Standard Algorithm Name Documentation*
    (sometimes referred to as just *Standard Names*).^([[38](#ftn.ch05fn01)]) In addition
    to those, providers can define their own algorithm names and aliases. (See each
    provider’s documentation for details.) You can use the code in [Example 5-6](ch05.html#listing_all_jca_providers_and_the_algori
    "Example 5-6. Listing all JCA providers and the algorithms they support") to list
    all providers, the algorithm names of cryptographic services offered by each provider,
    and the implementation classes they map to.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 算法名称不区分大小写。每个JCA engine类支持的标准算法名称在*JCA标准算法名称文档*中定义（有时简称为*标准名称*）。^([[38](#ftn.ch05fn01)])
    除了这些，提供者还可以定义自己的算法名称和别名。（有关详细信息，请参见每个提供者的文档。）你可以使用[示例5-6](ch05.html#listing_all_jca_providers_and_the_algori
    "Example 5-6. Listing all JCA providers and the algorithms they support")中的代码列出所有提供者、每个提供者提供的加密服务的算法名称，以及它们映射到的实现类。
- en: Example 5-6. Listing all JCA providers and the algorithms they support
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 示例5-6. 列出所有JCA提供者及其支持的算法
- en: '[PRE5]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: We will show the format for the algorithm name of major engine classes as we
    introduce them in the following sections.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在接下来的各节中介绍每个主要engine类的算法名称格式。
- en: SecureRandom
  id: totrans-52
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: SecureRandom
- en: The `SecureRandom` class represents a cryptographic *Random Number Generator
    (RNG)*. While you may not directly use it too often, it is used internally by
    most cryptographic operations to generate keys and other cryptographic material.
    The typical software implementation is usually a *Cryptographically Secure Pseudo
    Random Number Generator (CSPRNG)*, which produces a sequence of numbers that approximate
    the properties of true random numbers based on an initial value called a *seed*.
    As the quality of random numbers produced by a CSPRNG largely depends on its seed,
    it is chosen carefully, usually based on the output of a true RNG.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: '`SecureRandom` 类代表一个加密的 *随机数生成器（RNG）*。虽然你可能不会直接频繁使用它，但它被大多数加密操作内部使用，用于生成密钥和其他加密材料。典型的软件实现通常是一个
    *加密安全伪随机数生成器（CSPRNG）*，它根据一个初始值（称为 *种子*）生成一系列近似真正随机数的数字。由于 CSPRNG 生成的随机数的质量在很大程度上取决于其种子，因此种子的选择非常重要，通常基于一个真实随机数生成器的输出。'
- en: On Android, CSPRNG implementations are seeded by reading seed bytes from the
    standard Linux */dev/urandom* device file, which is an interface to the kernel
    CSPRNG. As the kernel CSPRNG itself may be in a fairly predictable state right
    after starting, Android periodically saves the state (which is 4096 bytes as of
    Android 4.4) of the kernel CSPRNG to the */data/system/entropy.dat* file. The
    contents of that file are written back to */dev/urandom* on boot in order to carry
    over the previous CSPRNG state. This is performed by the `EntropyMixer` system
    service.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Android 上，CSPRNG 实现通过从标准 Linux 的 */dev/urandom* 设备文件读取种子字节来进行种子设置，该文件是内核 CSPRNG
    的接口。由于内核 CSPRNG 本身在启动后可能处于一个相对可预测的状态，Android 会定期将内核 CSPRNG 的状态（在 Android 4.4 中为
    4096 字节）保存到 */data/system/entropy.dat* 文件中。该文件的内容在启动时会被写回到 */dev/urandom*，以便保留之前的
    CSPRNG 状态。此操作由 `EntropyMixer` 系统服务执行。
- en: Unlike most engine classes, `SecureRandom` has public constructors that you
    can use to create an instance. The recommended way to get a properly seeded instance
    on Android is to use the default (no argument) constructor (➊ in [Example 5-7](ch05.html#using_securerandom_to_generate_random_by
    "Example 5-7. Using SecureRandom to generate random bytes")). If you use the `getInstance()`
    factory method, you need to pass *SHA1PRNG* as the algorithm name, which is the
    only universally supported algorithm name for `SecureRandom`. Because *SHA1PRNG*
    is not exactly a cryptographic standard, implementations from different providers
    might behave differently. To have `SecureRandom` generate random bytes, you pass
    a byte array to its `nextBytes()` method (➋ in [Example 5-7](ch05.html#using_securerandom_to_generate_random_by
    "Example 5-7. Using SecureRandom to generate random bytes")). It will generate
    as many bytes as the array length (16 in [Example 5-7](ch05.html#using_securerandom_to_generate_random_by
    "Example 5-7. Using SecureRandom to generate random bytes")) and store them in
    it.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 与大多数引擎类不同，`SecureRandom` 具有公共构造函数，你可以使用这些构造函数创建实例。在 Android 上，推荐的获取正确种子实例的方式是使用默认（无参数）构造函数（➊
    在 [示例 5-7](ch05.html#using_securerandom_to_generate_random_by "示例 5-7. 使用 SecureRandom
    生成随机字节") 中）。如果使用 `getInstance()` 工厂方法，你需要传递 *SHA1PRNG* 作为算法名称，这是 `SecureRandom`
    唯一被普遍支持的算法名称。由于 *SHA1PRNG* 并不是一个严格的加密标准，不同提供者的实现可能会有不同的表现。为了让 `SecureRandom` 生成随机字节，你将一个字节数组传递给它的
    `nextBytes()` 方法（➋ 在 [示例 5-7](ch05.html#using_securerandom_to_generate_random_by
    "示例 5-7. 使用 SecureRandom 生成随机字节") 中）。它会生成与数组长度相等的字节（在 [示例 5-7](ch05.html#using_securerandom_to_generate_random_by
    "示例 5-7. 使用 SecureRandom 生成随机字节") 中为 16），并将这些字节存储到数组中。
- en: Example 5-7. Using `SecureRandom` to generate random bytes
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 5-7. 使用 `SecureRandom` 生成随机字节
- en: '[PRE6]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Seeding `SecureRandom` manually is not recommended because seeding the system
    CSPRNG improperly may result in it producing a predictable sequence of bytes,
    which could compromise any higher-level operations that require random input.
    However, if you need to manually seed `SecureRandom` for some reason (for example,
    if the default system seeding implementation is known to be flawed), you can do
    so by using the `SecureRandom(byte[] seed)` constructor or by calling the `setSeed()`
    method. When seeding manually, make sure that the seed you are using is sufficiently
    random; for example, by reading it from */dev/urandom*.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 不推荐手动设置 `SecureRandom` 的种子，因为不正确地设置系统 CSPRNG 的种子可能会导致其生成可预测的字节序列，从而可能危及任何需要随机输入的高级操作。然而，如果你出于某些原因需要手动设置
    `SecureRandom` 的种子（例如，如果已知默认的系统种子实现存在缺陷），你可以通过使用 `SecureRandom(byte[] seed)` 构造函数或调用
    `setSeed()` 方法来进行设置。手动设置种子时，确保使用的种子足够随机；例如，可以从 */dev/urandom* 中读取。
- en: Additionally, depending on the underlying implementation, calling `setSeed()`
    may not replace, but instead only add to the internal CSPRNG state; so two `SecureRandom`
    instances seeded with the same seed value may not produce the same number sequence.
    Therefore, `SecureRandom` should not be used when deterministic values are required.
    Instead, use a cryptographic primitive that is designed to produce deterministic
    output from a given input, such as a hash algorithm or a key derivation function.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，根据底层实现的不同，调用 `setSeed()` 可能不会替换内部的 CSPRNG 状态，而是仅仅将其添加到内部状态中；因此，用相同种子值初始化的两个
    `SecureRandom` 实例可能不会产生相同的数字序列。因此，当需要确定性值时，不应使用 `SecureRandom`。而应使用一个设计用于根据给定输入生成确定性输出的加密原语，例如哈希算法或密钥派生函数。
- en: MessageDigest
  id: totrans-60
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: MessageDigest
- en: The `MessageDigest` class represents the functionality of a cryptographic message
    digest, also referred to as a hash function. A cryptographic message digest takes
    an arbitrarily long sequence of bytes and generates a fixed-size byte sequence
    called a *digest* or *hash*. A good hash function guarantees that even a small
    change in its input results in completely different output and that it is very
    difficult to find two inputs that are different but produce the same hash value
    (*collision resistance*), or generate an input that has a given hash (*pre-image
    resistance*). Another important property of hash functions is second pre-image
    resistance. In order to withstand second pre-image attacks, a hash function should
    make it difficult to find a second input m[2] that hashes to the same value as
    a given input m[1].
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: '`MessageDigest` 类表示加密消息摘要的功能，也称为哈希函数。加密消息摘要接受任意长度的字节序列并生成一个固定大小的字节序列，称为 *摘要*
    或 *哈希*。一个好的哈希函数保证即使输入发生微小变化，也会产生完全不同的输出，并且很难找到两个不同的输入但产生相同的哈希值（*碰撞抗性*），或者生成具有特定哈希值的输入（*原像抗性*）。哈希函数的另一个重要属性是第二原像抗性。为了抵御第二原像攻击，哈希函数应使得很难找到第二个输入
    m[2]，其哈希值与给定输入 m[1] 相同。'
- en: '[Example 5-8](ch05.html#using_messagedigest_to_hash_data "Example 5-8. Using
    MessageDigest to hash data") shows how to use the `MessageDigest` class.'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 5-8](ch05.html#using_messagedigest_to_hash_data "示例 5-8. 使用 MessageDigest
    进行数据哈希") 展示了如何使用 `MessageDigest` 类。'
- en: Example 5-8. Using `MessageDigest` to hash data
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 5-8. 使用 `MessageDigest` 进行数据哈希
- en: '[PRE7]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: A `MessageDigest` instance is created by passing the hash algorithm name to
    the `getInstance()` factory method ➊. Input may be provided in chunks by using
    one of the `update()` methods, and then calling one of the `digest()` methods
    to get the calculated hash value. Alternatively, if the input data size is fixed
    and relatively short, it can be hashed in one step by using the `digest(byte[]
    input)` method ➋, as shown in [Example 5-8](ch05.html#using_messagedigest_to_hash_data
    "Example 5-8. Using MessageDigest to hash data").
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: '`MessageDigest` 实例是通过将哈希算法名称传递给 `getInstance()` 工厂方法 ➊ 来创建的。可以通过使用其中一个 `update()`
    方法分块提供输入数据，然后调用 `digest()` 方法之一来获取计算出的哈希值。或者，如果输入数据的大小是固定且相对较短的，也可以通过使用 `digest(byte[]
    input)` 方法 ➋ 一次性进行哈希，如 [示例 5-8](ch05.html#using_messagedigest_to_hash_data "示例
    5-8. 使用 MessageDigest 进行数据哈希") 中所示。'
- en: Signature
  id: totrans-66
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 签名
- en: The `Signature` class provides a common interface for digital signature algorithms
    based on asymmetric encryption. A digital signature algorithm takes an arbitrary
    message and a private key and produces a fixed-sized byte string called a *signature*.
    Digital signatures typically apply a digest algorithm to the input message, encode
    the calculated hash value, and then use a private key operation to produce the
    signature. The signature can then be verified using the corresponding public key
    by applying the reverse operation, calculating the hash value of the signed message,
    and comparing it to the one encoded in the signature. Successful verification
    guarantees the integrity of the signed message and, on the condition that the
    signing private key has remained indeed private, its authenticity.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: '`Signature` 类提供了一个基于非对称加密的数字签名算法的通用接口。数字签名算法接受一个任意消息和一个私钥，并生成一个固定大小的字节串，称为
    *签名*。数字签名通常会对输入消息应用摘要算法，编码计算出的哈希值，然后使用私钥操作生成签名。然后，可以通过应用反向操作、计算签名消息的哈希值，并将其与签名中编码的哈希值进行比较，使用相应的公钥来验证签名。成功的验证保证了签名消息的完整性，并且在签名私钥保持确实私密的前提下，保证了其真实性。'
- en: '`Signature` instances are created with the standard `getInstance()` factory
    method. The algorithm name used is generally in the form *<digest>with <encryption>*,
    where *<digest>* is a hash algorithm name as used by `MessageDigest` (such as
    *SHA256*), and *<encryption>* is an asymmetric encryption algorithm (such as *RSA*
    or *DSA*). For example, a *SHA512withRSA* `Signature` would first use the SHA-512
    hash algorithm to produce a digest value and then encrypt the encoded digest with
    an RSA private key to produce the signature. For signature algorithms that use
    a mask generation function such as RSA-PSS, the algorithm name takes the form
    *<digest>with<encryption>and<mgf>* (for example, *SHA256withRSAandMGF1*).'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: '`Signature`实例通过标准的`getInstance()`工厂方法创建。所使用的算法名称通常采用*<digest>with <encryption>*的形式，其中*<digest>*是`MessageDigest`使用的哈希算法名称（例如*SHA256*），*<encryption>*是非对称加密算法（例如*RSA*或*DSA*）。例如，*SHA512withRSA*的`Signature`将首先使用SHA-512哈希算法生成摘要值，然后使用RSA私钥加密编码后的摘要值以生成签名。对于使用掩码生成函数（如RSA-PSS）的签名算法，算法名称采用*<digest>with<encryption>and<mgf>*的形式（例如，*SHA256withRSAandMGF1*）。'
- en: '[Example 5-9](ch05.html#generating_and_verifying_a_signature_wit "Example 5-9. Generating
    and verifying a signature with the Signature class") shows how to use the `Signature`
    class to generate and verify a cryptographic signature.'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 5-9](ch05.html#generating_and_verifying_a_signature_wit "示例 5-9. 使用`Signature`类生成和验证签名")展示了如何使用`Signature`类生成和验证加密签名。'
- en: Example 5-9. Generating and verifying a signature with the `Signature` class
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 5-9. 使用`Signature`类生成和验证签名
- en: '[PRE8]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: After obtaining an instance, the `Signature` object is initialized for either
    signing, by passing a private key to the `initSign()` method (➊ in [Example 5-9](ch05.html#generating_and_verifying_a_signature_wit
    "Example 5-9. Generating and verifying a signature with the Signature class")),
    or verification, by passing a public key or certificate to the `initVerify()`
    method ➍ for verification.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 获取实例后，`Signature`对象通过传递私钥给`initSign()`方法（➊，在[示例 5-9](ch05.html#generating_and_verifying_a_signature_wit
    "示例 5-9. 使用`Signature`类生成和验证签名")中）来初始化签名，或者通过传递公钥或证书给`initVerify()`方法 ➍来初始化验证。
- en: 'Signing is similar to calculating a hash with `MessageDigest`: the data to
    be signed is fed in chunks to one of the `update()` methods ➋ or in bulk to the
    `sign()` method ➌, which returns the signature value. To verify a signature, the
    signed data is passed to one of the `update()` methods. Finally, the signature
    is passed to the `verify()` method ➎, which returns `true` if the signature is
    valid.'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 签名类似于使用`MessageDigest`计算哈希值：要签名的数据被分块传递给`update()`方法 ➋，或批量传递给`sign()`方法 ➌，后者返回签名值。要验证签名，已签名的数据被传递给`update()`方法。最后，签名被传递给`verify()`方法
    ➎，如果签名有效，则返回`true`。
- en: Cipher
  id: totrans-74
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Cipher
- en: The `Cipher` class provides a common interface to encryption and decryption
    operations. Encryption is the process of using some algorithm (called a *cipher*)
    and a key to transform data (called *plaintext,* or *plaintext message*) into
    a randomly looking form (called *ciphertext*). The inverse operation, called *decryption*,
    transforms the ciphertext back into the original plaintext.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: '`Cipher`类提供了一个用于加密和解密操作的通用接口。加密是使用某种算法（称为*加密算法*）和密钥将数据（称为*明文*或*明文消息*）转换为看似随机的形式（称为*密文*）。逆操作，称为*解密*，将密文转换回原始的明文。'
- en: 'The two major types of encryption widely used today are *symmetric encryption*
    and *asymmetric encryption*. Symmetric, or *secret key*, encryption uses the same
    key to encrypt and decrypt data. Asymmetric encryption uses a pair of keys: a
    *public key* and a *private key*. Data encrypted with one of the keys can only
    be decrypted with the other key of the pair. The `Cipher` class supports both
    symmetric and asymmetric encryption.'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 当今广泛使用的两种主要加密类型是*symmetric encryption*（对称加密）和*asymmetric encryption*（非对称加密）。对称加密或*秘密密钥*加密使用相同的密钥进行数据加密和解密。非对称加密使用一对密钥：*公钥*和*私钥*。使用其中一个密钥加密的数据只能用另一把密钥解密。`Cipher`类支持对称加密和非对称加密。
- en: Depending on how they process input, ciphers can be *block* or *stream*. Block
    ciphers work on fixed-sized chunks of data called *blocks*. If the input cannot
    be divided into an integral number of blocks, the last block is *padded* by adding
    the necessary number of bytes to match the block size. Both the operation and
    the added bytes are called *padding*. Padding is removed in the decryption process
    and is not included in the decrypted plaintext. If a padding algorithm is specified,
    the `Cipher` class can add and remove padding automatically. On the other hand,
    stream ciphers process input data one byte (or even bit) at a time and do not
    require padding.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 根据处理输入的方式，密码算法可以是*分组密码*或*流密码*。分组密码处理固定大小的数据块，这些数据块称为*数据块*。如果输入数据无法分割成一个整数个数据块，最后一个数据块将通过添加必要的字节来进行*填充*，以匹配数据块的大小。操作和添加的字节都被称为*填充*。在解密过程中，填充会被去除，并且不会包含在解密后的明文中。如果指定了填充算法，`Cipher`类可以自动添加和去除填充。另一方面，流密码一次处理一个字节（甚至一个比特）数据，不需要填充。
- en: Block Cipher Modes of Operation
  id: totrans-78
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 分组密码操作模式
- en: Block ciphers employ different strategies when processing input blocks in order
    to produce the final ciphertext (or plaintext when decrypting). Those strategies
    are called *modes of operation*, *cipher modes*, or simply *modes*. The simplest
    processing strategy is to split the plaintext into blocks (padding as necessary),
    apply the cipher to each block, and then concatenate the encrypted blocks to produce
    the ciphertext. This mode is called *Electronic Code Book (ECB)* mode, and while
    it’s straightforward and easy to use, it has the major disadvantage that identical
    plaintext blocks produce identical ciphertext blocks. Thus, plaintext structure
    is reflected in the ciphertext, which compromises message confidentiality and
    facilitates cryptanalysis. This has often been illustrated with the infamous “ECB
    Penguin” from the Wikipedia entry on block cipher modes.^([[39](#ftn.ch05fn02)])
    We present our Android version in [Figure 5-2](ch05.html#ciphertext_patterns_produced_by_differen
    "Figure 5-2. Ciphertext patterns produced by different cipher modes").^([[40](#ftn.ch05fn03)])
    Here, ➊ is the original image, ➋ is the image encrypted in ECB mode, and ➌ is
    the same image encrypted in CBC mode. As you can see, the pattern of the original
    image is distinguishable in ➋, while ➌ looks like random noise.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 分组密码在处理输入数据块时采用不同的策略，以生成最终的密文（或在解密时生成明文）。这些策略称为*操作模式*、*密码模式*，或简单地称为*模式*。最简单的处理策略是将明文分割成数据块（根据需要进行填充），对每个数据块应用密码算法，然后将加密后的数据块连接在一起以生成密文。这种模式称为*电子代码本（ECB）*模式，虽然它简单易用，但它的主要缺点是相同的明文块会生成相同的密文块。因此，明文的结构会在密文中反映出来，这破坏了消息的机密性，并有助于密码分析。这个问题常常通过维基百科上的“ECB企鹅”图示来说明。^([[39](#ftn.ch05fn02)])
    我们在[图5-2](ch05.html#ciphertext_patterns_produced_by_differen "图5-2. 不同密码模式产生的密文模式")中展示了我们的Android版本。^([[40](#ftn.ch05fn03)])
    这里，➊是原始图像，➋是使用ECB模式加密后的图像，➌是使用CBC模式加密后的相同图像。正如你所看到的，原始图像的模式在➋中是可辨识的，而➌看起来像是随机噪声。
- en: '![Ciphertext patterns produced by different cipher modes](figs/web/05fig02.png.jpg)'
  id: totrans-80
  prefs: []
  type: TYPE_IMG
  zh: '![不同密码模式产生的密文模式](figs/web/05fig02.png.jpg)'
- en: Figure 5-2. Ciphertext patterns produced by different cipher modes
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 图5-2. 不同密码模式产生的密文模式
- en: '*Feedback modes* add randomness to the ciphertext by combining the previous
    encrypted block with the current plaintext block before encrypting. In order to
    produce the first cipher block, they combine the first plaintext block with a
    block-sized string of bytes not found in the original plain text, called an *initialization
    vector (IV)*. When configured to use a feedback mode, the `Cipher` class can use
    a client-specified IV or generate one automatically. Commonly used feedback modes
    are *Cipher-block chaining (CBC)*, *Cipher feedback (CFB)*, and *Output feedback
    (OFB)*.'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: '*反馈模式*通过在加密之前将前一个加密块与当前明文块结合来增加密文的随机性。为了生成第一个密文块，它们将第一个明文块与一个未出现在原始明文中的、大小与数据块相同的字节串结合，这个字节串称为*初始化向量（IV）*。在配置为使用反馈模式时，`Cipher`类可以使用客户端指定的IV，或者自动生成一个。常用的反馈模式包括*密码块链（CBC）*、*密码反馈（CFB）*和*输出反馈（OFB）*。'
- en: Another way to add randomness to the ciphertext, employed by the *Counter (CTR)*
    mode, is to encrypt the successive values of a counter sequence in order to produce
    a new key for each plaintext block that needs to be encrypted. This effectively
    turns the underlying block cipher into a stream cipher and no padding is required.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种向密文添加随机性的方式是 *Counter (CTR)* 模式，它通过加密连续的计数器序列值，为每个需要加密的明文块生成一个新的密钥。这实际上将底层的块密码转换为流密码，因此不需要填充。
- en: Newer cipher modes, such as *Galois/Counter Mode (GCM)*, not only diffuse patterns
    in the original plaintext but also authenticate the ciphertext, making sure it
    has not been tampered with. They provide *authenticated encryption (AE)* or *Authenticated
    Encryption with Associated Data (AEAD)*.^([[41](#ftn.ch05fn04)]) The `Cipher`
    APIs have been extended to support authenticated encryption in Java SE 7, and
    those extensions have been available since Android 4.4, which has a Java 7–compatible
    runtime library API. AE ciphers concatenate the authentication tag output by the
    encryption operation to the ciphertext that operation produces in order to form
    their final output. In the Java `Cipher` API, the tag is included (or verified,
    when decrypting) implicitly after calling `doFinal()`, so you should not use the
    output of `update()` until you’re sure the implicit tag at the end validates.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 更新的密码模式，如 *Galois/Counter Mode (GCM)*，不仅能扩散原始明文中的模式，还能对密文进行认证，确保其未被篡改。它们提供了
    *认证加密 (AE)* 或 *带关联数据的认证加密 (AEAD)*。^([[41](#ftn.ch05fn04)]) `Cipher` API 在 Java
    SE 7 中扩展了对认证加密的支持，并且这些扩展自 Android 4.4 以来就已经可用，该版本具有与 Java 7 兼容的运行时库 API。AE 密码通过将加密操作输出的认证标签与该操作生成的密文拼接在一起，从而形成最终输出。在
    Java `Cipher` API 中，标签会在调用 `doFinal()` 后隐式包含（或在解密时进行验证），因此在确定隐式标签验证通过之前，不应使用 `update()`
    的输出。
- en: Obtaining a Cipher Instance
  id: totrans-85
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 获取 Cipher 实例
- en: Having reviewed the major parameters of a cipher, we can finally discuss how
    to create `Cipher` instances. Like the other engine classes, `Cipher` objects
    are created with the `getInstance()` factory method, which requires not just a
    simple algorithm name, but that you fully specify the cryptographic *transformation*
    that the requested cipher will perform.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 在回顾了密码的主要参数后，我们终于可以讨论如何创建 `Cipher` 实例。像其他引擎类一样，`Cipher` 对象是通过 `getInstance()`
    工厂方法创建的，这不仅要求提供一个简单的算法名称，还需要你完全指定所请求的密码将执行的加密 *转换*。
- en: '[Example 5-10](ch05.html#creating_a_cipher_instance "Example 5-10. Creating
    a Cipher instance") shows how to create a `Cipher` instance by passing a transformation
    string to `getInstance()`.'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 5-10](ch05.html#creating_a_cipher_instance "示例 5-10. 创建一个 Cipher 实例") 展示了如何通过将转换字符串传递给
    `getInstance()` 来创建一个 `Cipher` 实例。'
- en: Example 5-10. Creating a `Cipher` instance
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 5-10. 创建一个 `Cipher` 实例
- en: '[PRE9]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: A transformation needs to specify the encryption algorithm, cipher mode, and
    padding. The transformation string passed to `getInstance()` is in the *algorithm/mode/padding*
    format. For example, the transformation string used in [Example 5-10](ch05.html#creating_a_cipher_instance
    "Example 5-10. Creating a Cipher instance") would create a `Cipher` instance that
    uses AES as the encryption algorithm, CBC as the cipher mode, and PKCS#5 padding.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 转换需要指定加密算法、密码模式和填充方式。传递给 `getInstance()` 的转换字符串采用 *算法/模式/填充* 格式。例如，在 [示例 5-10](ch05.html#creating_a_cipher_instance
    "示例 5-10. 创建一个 Cipher 实例") 中使用的转换字符串将创建一个使用 AES 作为加密算法、CBC 作为密码模式、PKCS#5 填充的 `Cipher`
    实例。
- en: Note
  id: totrans-91
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '*The term* PKCS *will appear quite a few times in our discussion of JCA providers
    and engine classes. The acronym stands for* Public Key Cryptography Standard *and
    refers to a group of cryptography standards that were originally developed and
    published by RSA Security, Inc. in the early 1990s. Most have evolved into public
    Internet standard and are now published and maintained as RFCs (Requests for Comments,
    formal documents describing Internet standards), but they are still referred to
    by their original name. Notable standards include PKCS#1, which defines the basic
    algorithms for RSA encryption and signatures; PKCS#5, which defines password-based
    encryption; PKCS#7, which defines message encryption and signing under a PKI and
    became the basis of S/MIME; and PKCS#12, which defines a container for keys and
    certificates. A full list can be found on EMC’s website.*^([[42](#ftn.ch05fn05)])'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: '*术语* PKCS *将在我们讨论 JCA 提供者和引擎类时多次出现。这个缩写代表* 公钥密码学标准 *，它指的是一组最初由 RSA Security,
    Inc. 在 1990 年代初期开发和发布的密码学标准。大多数已经发展成为公共互联网标准，并以 RFC（请求评论，描述互联网标准的正式文件）的形式发布和维护，但它们仍然以原始名称被称呼。著名的标准包括
    PKCS#1，它定义了 RSA 加密和签名的基本算法；PKCS#5，它定义了基于密码的加密；PKCS#7，它定义了在公钥基础设施下的消息加密和签名，并成为
    S/MIME 的基础；以及 PKCS#12，它定义了密钥和证书的容器。完整的标准列表可以在 EMC 的网站上找到。*^([[42](#ftn.ch05fn05)])'
- en: A `Cipher` instance can be created by passing only the algorithm name, but in
    that case the returned implementation would use provider-specific defaults for
    the cipher mode and padding. This is not only not portable across providers, but
    could severely impact the security of the system if, for example, a less-secure-than-intended
    cipher mode (such as ECB) is used at runtime. This “shortcut” is a major design
    flaw of the JCA provider framework and should never be used.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 可以仅通过传递算法名称来创建一个 `Cipher` 实例，但在这种情况下，返回的实现会使用提供者特定的默认值来设置加密模式和填充方式。这不仅无法在不同提供者之间移植，而且如果运行时使用了不如预期安全的加密模式（例如
    ECB 模式），可能会严重影响系统的安全性。这种“快捷方式”是 JCA 提供者框架的一个重大设计缺陷，绝对不应该使用。
- en: Using a Cipher
  id: totrans-94
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用 Cipher
- en: Once a `Cipher` instance has been obtained, it needs to be initialized before
    encrypting or decrypting data. A `Cipher` is initialized by passing an integer
    constant that denotes the operation mode (`ENCRYPT_MODE`, `DECRYPT_MODE`, `WRAP_MODE`,
    or `UNWRAP_MODE`), a key or certificate, and, optionally, algorithm parameters,
    to one of the corresponding `init()` methods. `ENCRYPT_MODE` and `DECRYPT_MODE`
    are used to encrypt and decrypt arbitrary data, while `WRAP_MODE` and `UNWRAP_MODE`
    are specialized modes used when encrypting (*wrapping*) and decrypting (*unwrapping*)
    the key material of a `Key` object with another key.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦获得了 `Cipher` 实例，它需要在加密或解密数据之前进行初始化。`Cipher` 通过将表示操作模式的整数常量（`ENCRYPT_MODE`、`DECRYPT_MODE`、`WRAP_MODE`
    或 `UNWRAP_MODE`）、密钥或证书，以及可选的算法参数，传递给相应的 `init()` 方法来进行初始化。`ENCRYPT_MODE` 和 `DECRYPT_MODE`
    用于加密和解密任意数据，而 `WRAP_MODE` 和 `UNWRAP_MODE` 是专门用于加密（*封装*）和解密（*解封装*） `Key` 对象的密钥材料的模式。
- en: '[Example 5-11](ch05.html#using_the_cipher_class_to_encrypt_and_de "Example 5-11. Using
    the Cipher class to encrypt and decrypt data") shows how to use the `Cipher` class
    to encrypt and decrypt data.'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 5-11](ch05.html#using_the_cipher_class_to_encrypt_and_de "示例 5-11. 使用 Cipher
    类加密和解密数据") 演示了如何使用 `Cipher` 类加密和解密数据。'
- en: Example 5-11. Using the `Cipher` class to encrypt and decrypt data
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 5-11. 使用 `Cipher` 类加密和解密数据
- en: '[PRE10]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: In this example, we create a `Cipher` instance that uses AES in CBC mode and
    PKCS#5 padding ➊; generate a random IV and wrap it into an `IvParameterSpec` object
    ➋; and then initialize the `Cipher` for encryption by passing `ENCRYPT_MODE`,
    the encryption key, and the IV to the `init()` method ➌. We can then encrypt data
    by passing data chunks to the `update()` method ➍, which returns intermediate
    results (or `null` if the input data is too short to result in a new block), and
    obtain the last block by calling the `doFinal()` method ➎. The final ciphertext
    is obtained by concatenating the intermediate result(s) with the final block.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们创建了一个使用 AES CBC 模式和 PKCS#5 填充的 `Cipher` 实例 ➊；生成一个随机的 IV 并将其封装进 `IvParameterSpec`
    对象 ➋；然后通过将 `ENCRYPT_MODE`、加密密钥和 IV 传递给 `init()` 方法来初始化 `Cipher` 进行加密 ➌。接着，我们可以通过将数据块传递给
    `update()` 方法 ➍ 来加密数据，该方法返回中间结果（如果输入数据太短以至于无法形成新块，则返回 `null`），并通过调用 `doFinal()`
    方法 ➎ 获得最后一个数据块。最终的密文是将中间结果和最后一个数据块连接起来得到的。
- en: To decrypt, we initialize the `cipher` in `DECRYPT_MODE` ➏, passing the same
    key and the IV used for encryption. We then call `update()` ➐, this time using
    the ciphertext as input, and finally call `doFinal()` ➑ to obtain the last chunk
    of plaintext. The final plaintext is obtained by concatenating the intermediate
    result(s) with the final chunk ➒.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 要进行解密，我们将`cipher`初始化为`DECRYPT_MODE` ➏，并传入与加密时相同的密钥和IV。然后调用`update()` ➐，这时使用密文作为输入，最后调用`doFinal()`
    ➑以获得最后一块明文。最终的明文是通过将中间结果与最后一块明文连接起来获得的 ➒。
- en: Mac
  id: totrans-101
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 消息认证码（MAC）
- en: The `Mac` class provides a common interface to *Message Authentication Code
    (MAC)* algorithms. A MAC is used to check the integrity of messages transmitted
    over an unreliable channel. MAC algorithms use a secret key to calculate a value,
    *the MAC* (also called a *tag*), which can be used to authenticate the message
    and check its integrity. The same key is used to perform verification, so it needs
    to be shared between the communicating parties. (A MAC is often combined with
    a cipher to provide both confidentiality and integrity.)
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: '`Mac`类提供了一个通用接口，用于*消息认证码（MAC）*算法。MAC用于检查通过不可靠通道传输的消息的完整性。MAC算法使用一个密钥计算一个值，即*MAC*（也叫做*标签*），该值可用于验证消息并检查其完整性。相同的密钥用于进行验证，因此它需要在通信双方之间共享。（MAC通常与密码学算法结合使用，以提供保密性和完整性。）'
- en: Example 5-12. Using the `Mac` class to generate a message authentication code
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 5-12. 使用`Mac`类生成消息认证码
- en: '[PRE11]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: A `Mac` instance is obtained with the `getInstance()` factory method ➊ (as shown
    in [Example 5-12](ch05.html#using_the_mac_class_to_generate_a_messag "Example 5-12. Using
    the Mac class to generate a message authentication code")) by requesting an implementation
    of the HMAC^([[43](#ftn.ch05fn06)]) MAC algorithm that uses SHA-256 as the hash
    function. It is then initialized ➋ with a `SecretKey` instance, which may be generated
    with a `KeyGenerator` (see “[KeyGenerator](ch05.html#keygenerator "KeyGenerator")”),
    derived from a password or directly instantiated from raw key bytes. For MAC implementations
    based on hash functions (such as HMAC SHA-256 in this example), the type of key
    does not matter, but implementations that use a symmetric cipher may require a
    matching key type to be passed. We can then pass the message in chunks using one
    of the `update()` methods and call `doFinal()` to obtain the final MAC value,
    or perform the operation in one step by passing the message bytes directly to
    `doFinal()` ➌.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 一个`Mac`实例是通过`getInstance()`工厂方法 ➊（如[示例 5-12](ch05.html#using_the_mac_class_to_generate_a_messag
    "示例 5-12. 使用Mac类生成消息认证码")）获取的，它请求一个实现HMAC^([[43](#ftn.ch05fn06)]) MAC算法，该算法使用SHA-256作为哈希函数。然后它被初始化
    ➋，使用`SecretKey`实例，这个实例可以通过`KeyGenerator`生成（见“[KeyGenerator](ch05.html#keygenerator
    "KeyGenerator")”），也可以通过密码派生或直接从原始密钥字节实例化。对于基于哈希函数的MAC实现（例如本例中的HMAC SHA-256），密钥的类型不重要，但使用对称密码的实现可能需要传入匹配的密钥类型。然后，我们可以通过使用`update()`方法之一分批传递消息，并调用`doFinal()`以获得最终的MAC值，或者通过将消息字节直接传递给`doFinal()`
    ➌来一步完成操作。
- en: Key
  id: totrans-106
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 密钥
- en: The `Key` interface represents *opaque* keys in the JCA framework. Opaque keys
    can be used in cryptographic operations, but usually do not provide access to
    the underlying *key material* (raw key bytes). This allows us to use the same
    JCA classes and interfaces both with software implementations of cryptographic
    algorithms that store key material on memory, and with hardware-backed ones, where
    the key material may reside in a hardware token (smart card, HSM^([[44](#ftn.ch05fn07)])
    and so on) and is not directly accessible.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: '`Key`接口表示JCA框架中的*不透明*密钥。不透明密钥可以用于加密操作，但通常无法访问底层的*密钥材料*（原始密钥字节）。这使得我们可以在使用存储密钥材料于内存的软件加密算法实现和硬件支持的加密算法（密钥材料可能存储在硬件令牌中，如智能卡、HSM^([[44](#ftn.ch05fn07)])等）之间，使用相同的JCA类和接口，并且密钥材料是不可直接访问的。'
- en: 'The `Key` interface defines only three methods:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: '`Key`接口仅定义了三个方法：'
- en: '****`String getAlgorithm()`****. Returns the name of the encryption algorithm
    (symmetric or asymmetric) that this key can be used with. Examples are *AES* or
    *RSA*.'
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '****`String getAlgorithm()`****。返回此密钥可以使用的加密算法（对称或非对称）的名称。例如，*AES*或*RSA*。'
- en: '****`byte[] getEncoded()`****. Returns a standard encoded form of the key that
    can be used when transmitting the key to other systems. This can be encrypted
    for private keys. For hardware-backed implementations that do not allow exporting
    key material, this method typically returns `null`.'
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '****`byte[] getEncoded()`****。返回密钥的标准编码形式，通常用于将密钥传输到其他系统。这可以针对私钥进行加密。对于不允许导出密钥材料的硬件支持实现，这个方法通常会返回
    `null`。'
- en: '****`String getFormat()`****. Returns the format of the encoded key. This is
    usually *RAW* for keys that are not encoded in any particular format. Other formats
    defined in JCA are *X.509* and *PKCS#8*.'
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '****`String getFormat()`****。返回编码密钥的格式。对于未以特定格式编码的密钥，这通常是 *RAW*。JCA 中定义的其他格式有
    *X.509* 和 *PKCS#8*。'
- en: 'You can obtain a `Key` instance in the following ways:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过以下方式获取 `Key` 实例：
- en: Generate keys using a `KeyGenerator` or a `KeyPairGenerator`.
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `KeyGenerator` 或 `KeyPairGenerator` 生成密钥。
- en: Convert from some encoded representation using a `KeyFactory`.
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `KeyFactory` 从某些编码表示中转换。
- en: Retrieve a stored key from a `KeyStore`.
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从 `KeyStore` 中检索已存储的密钥。
- en: We discuss different `Key` types and how they are created and accessed in the
    next sections.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在接下来的小节中讨论不同的 `Key` 类型以及如何创建和访问它们。
- en: SecretKey and PBEKey
  id: totrans-117
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: SecretKey 和 PBEKey
- en: The `SecretKey` interface represents keys used in symmetric algorithms. It is
    a marker interface and does not add any methods to those of the parent `Key` interface.
    It has only one implementation that can be directly instantiated, namely `SecretKeySpec`.
    It is both a key implementation and a key specification (as discussed in the “[KeySpec](ch05.html#keyspec
    "KeySpec")” section that follows) and allows you to instantiate `SecretKey` instances
    based on the raw key material.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: '`SecretKey` 接口表示对称算法中使用的密钥。它是一个标记接口，并没有为父接口 `Key` 增加任何方法。它只有一个可以直接实例化的实现类，即
    `SecretKeySpec`。它既是一个密钥实现类，也是一个密钥规格类（如后文的 “[KeySpec](ch05.html#keyspec "KeySpec")”
    小节所述），并允许你根据原始密钥材料实例化 `SecretKey` 实例。'
- en: 'The `PBEKey` subinterface represents keys derived using *Password Based Encryption
    (PBE)*.^([[45](#ftn.ch05fn08)]) PBE defines algorithms that derive strong cryptographic
    keys from passwords and passphrases, which typically have low entropy and thus
    cannot be used directly as keys. PBE is based on two main ideas: using a *salt*
    to protect from table-assisted (pre-computed) dictionary attacks (*salting*),
    and using a large iteration count to make the key derivation computationally expensive
    (*key stretching*). The salt and iteration count are used as parameters to PBE
    algorithms and thus need to be retained in order to generate the same key from
    a particular password. Thus `PBEKey` implementations are required to implement
    `getSalt()` and `getIterationCount()` along with `getPassword()`.'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: '`PBEKey` 子接口表示通过 *基于密码的加密 (PBE)* 派生的密钥。^([[45](#ftn.ch05fn08)]) PBE 定义了从密码和口令短语（通常具有低熵，因此不能直接作为密钥使用）中派生强加密密钥的算法。PBE
    基于两个主要思想：使用 *盐值* 保护免受表辅助（预计算）字典攻击（*加盐*），并使用较大的迭代次数使密钥派生计算上变得昂贵（*密钥拉伸*）。盐值和迭代次数作为
    PBE 算法的参数，因此需要保留，以便从特定的密码生成相同的密钥。因此，`PBEKey` 实现需要实现 `getSalt()`、`getIterationCount()`
    和 `getPassword()` 方法。'
- en: PublicKey, PrivateKey, and KeyPair
  id: totrans-120
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 公钥、私钥和密钥对
- en: Public and private keys for asymmetric encryption algorithms are modeled with
    the `PublicKey` and `PrivateKey` interfaces. They are marker interfaces and do
    not add any new methods. JCA defines specialized classes for concrete asymmetric
    algorithms that hold the parameters of the corresponding keys, such as `RSAPublicKey`
    and `RSAPrivateCrtKey`. The `KeyPair` interface is simply a container for a public
    key and a private key.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 非对称加密算法的公钥和私钥通过 `PublicKey` 和 `PrivateKey` 接口进行建模。它们是标记接口，并没有增加任何新方法。JCA 定义了具体非对称算法的专用类，这些类包含相应密钥的参数，例如
    `RSAPublicKey` 和 `RSAPrivateCrtKey`。`KeyPair` 接口只是一个容器，包含一个公钥和一个私钥。
- en: KeySpec
  id: totrans-122
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: KeySpec
- en: As discussed in [Key](ch05.html#key "Key"), the JCA `Key` interface represents
    opaque keys. On the other hand, `KeySpec` models a *key specification*, which
    is a *transparent* key representation that allows you to access individual key
    parameters.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 如在 [Key](ch05.html#key "Key") 小节所述，JCA 的 `Key` 接口表示不透明的密钥。另一方面，`KeySpec` 模型化了一个
    *密钥规格*，它是一个 *透明的* 密钥表示形式，允许你访问各个密钥参数。
- en: In practice, most `Key` and `KeySpec` interfaces for concrete algorithms overlap
    considerably because the key parameters need to be accessible in order to implement
    the encryption algorithms. For example, both `RSAPrivateKey` and `RSAPrivateKeySpec`
    define `getModulus()` and `getPrivateExponent()` methods. The difference is only
    important when an algorithm is implemented in hardware, in which case the `KeySpec`
    will only contain a reference to the hardware-managed key and not the actual key
    parameters. The corresponding `Key` will hold a handle to the hardware-managed
    key and can be used to perform cryptographic operations, but it will not hold
    any key material. For example, an `RSAPrivateKey` that is stored in hardware will
    return `null` when its `getPrivateExponent()` method is called.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 在实际应用中，大多数具体算法的`Key`和`KeySpec`接口有很大的重叠，因为密钥参数需要可访问，以便实现加密算法。例如，`RSAPrivateKey`和`RSAPrivateKeySpec`都定义了`getModulus()`和`getPrivateExponent()`方法。只有在算法实现为硬件时，差异才变得重要，此时`KeySpec`只包含对硬件管理密钥的引用，而不包含实际的密钥参数。相应的`Key`将持有指向硬件管理密钥的句柄，并可用于执行加密操作，但它不会包含任何密钥材料。例如，存储在硬件中的`RSAPrivateKey`在调用其`getPrivateExponent()`方法时将返回`null`。
- en: '`KeySpec` implementations can hold an encoded key representation, in which
    case they are algorithm independent. For example, the `PKCS8EncodedKeySpec` can
    hold either an RSA key or a DSA key in DER-encoded PKCS#8 format.^([[46](#ftn.ch05fn09)])
    On the other hand, an algorithm-specific `KeySpec` holds all key parameters as
    fields. For example, `RSAPrivateKeySpec` contains the modulus and private exponent
    for an RSA key, which can be obtained using the `getModulus()` and `getPrivateExponent()`
    methods, respectively. Regardless of their type, `KeySpec`s are converted to `Key`
    objects using a `KeyFactory`.'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: '`KeySpec`实现可以持有编码后的密钥表示，在这种情况下，它们是与算法无关的。例如，`PKCS8EncodedKeySpec`可以持有RSA密钥或DSA密钥，格式为DER编码的PKCS#8格式。^([[46](#ftn.ch05fn09)])另一方面，特定算法的`KeySpec`将所有密钥参数作为字段保存。例如，`RSAPrivateKeySpec`包含RSA密钥的模数和私有指数，可以分别通过`getModulus()`和`getPrivateExponent()`方法获取。无论类型如何，`KeySpec`都可以通过`KeyFactory`转换为`Key`对象。'
- en: KeyFactory
  id: totrans-126
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: KeyFactory
- en: A `KeyFactory` encapsulates a conversion routine needed to turn a transparent
    public or private key representation (some `KeySpec` subclass) into an opaque^([[47](#ftn.ch05fn10)])
    key object (some `Key` subclass) that can be used to perform a cryptographic operation,
    or vice versa. A `KeyFactory` that converts an encoded key typically parses the
    encoded key data and stores each key parameter in the corresponding field of the
    concrete `Key` class. For example, to parse an X.509-encoded RSA public key, you
    can use the following code (see [Example 5-13](ch05.html#using_a_keyfactory_to_convert_an_xdot509
    "Example 5-13. Using a KeyFactory to convert an X.509 encoded key to an RSAPublicKey
    object")).
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: '`KeyFactory`封装了一个转换例程，用于将透明的公钥或私钥表示（某个`KeySpec`子类）转换为不可见的密钥对象（某个`Key`子类），该对象可以用于执行加密操作，反之亦然。一个转换编码密钥的`KeyFactory`通常会解析编码的密钥数据，并将每个密钥参数存储在具体`Key`类的相应字段中。例如，要解析一个X.509编码的RSA公钥，可以使用以下代码（参见[示例
    5-13](ch05.html#using_a_keyfactory_to_convert_an_xdot509 "示例 5-13. 使用KeyFactory将X.509编码的密钥转换为RSAPublicKey对象")）。'
- en: Example 5-13. Using a `KeyFactory` to convert an X.509 encoded key to an `RSAPublicKey`
    object
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 5-13. 使用`KeyFactory`将X.509编码的密钥转换为`RSAPublicKey`对象
- en: '[PRE12]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Here we create an RSA `KeyFactory` by passing *RSA* to `KeyFactory.getInstance()`
    ➊. We then read the encoded RSA key, use the encoded key bytes to instantiate
    an `X509EncodedKeySpec` ➋, and finally pass the `KeySpec` to the factory’s `generatePublic()`
    method ➌ in order to obtain an `RSAPublicKey` instance.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们通过将*RSA*传递给`KeyFactory.getInstance()` ➊来创建一个RSA `KeyFactory`。然后，我们读取编码后的RSA密钥，使用编码后的密钥字节实例化一个`X509EncodedKeySpec`
    ➋，最后将`KeySpec`传递给工厂的`generatePublic()`方法 ➌，以获取一个`RSAPublicKey`实例。
- en: A `KeyFactory` can also convert an algorithm-specific `KeySpec`, such as `RSAPrivateKeySpec`,
    to a matching `Key` (`RSAPrivateKey`, in this example) instance, but in that case
    it merely copies the key parameters (or key handle) from one class to the other.
    Calling the `KeyFactory.getKeySpec()` method converts a `Key` object to a `KeySpec`,
    but this usage is not very common because an encoded key representation can be
    obtained simply by calling `getEncoded()` directly on the key object, and algorithm-specific
    `KeySpec`s generally do not provide any more information than a concrete `Key`
    class does.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: '`KeyFactory`也可以将特定算法的`KeySpec`（如`RSAPrivateKeySpec`）转换为匹配的`Key`（在这个例子中是`RSAPrivateKey`）实例，但在这种情况下，它仅仅是将密钥参数（或密钥句柄）从一个类复制到另一个类。调用`KeyFactory.getKeySpec()`方法将`Key`对象转换为`KeySpec`，但这种用法并不常见，因为通过直接调用`getEncoded()`方法在密钥对象上可以简单地获取编码的密钥表示，而且特定算法的`KeySpec`通常并不会提供比具体的`Key`类更多的信息。'
- en: Another feature of `KeyFactory` is converting a `Key` instance from a different
    provider into a corresponding key object compatible with the current provider.
    The operation is called *key translation* and is performed using the `translateKey(Key
    key)` method.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: '`KeyFactory`的另一个特性是将来自不同提供者的`Key`实例转换为与当前提供者兼容的相应密钥对象。这个操作称为*密钥转换*，是通过调用`translateKey(Key
    key)`方法来执行的。'
- en: SecretKeyFactory
  id: totrans-133
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: SecretKeyFactory
- en: '`SecretKeyFactory` is very similar to `KeyFactory` except that it only operates
    on secret (symmetric) keys. You can use it to convert a symmetric key specification
    into a `Key` object and vice versa. In practice though, if you have access to
    the key material of a symmetric key, it is much easier to use it to instantiate
    directly a `SecretKeySpec` that is also a `Key`, so it is not used very often
    in this fashion.'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: '`SecretKeyFactory`与`KeyFactory`非常相似，区别在于它只处理对称（秘密）密钥。你可以使用它将对称密钥规格转换为`Key`对象，反之亦然。然而在实践中，如果你能够访问对称密钥的密钥材料，那么直接实例化一个`SecretKeySpec`（它也是一个`Key`）要简单得多，因此这种用法并不常见。'
- en: A much more common use case is generating a symmetric key from a user-supplied
    password using PBE (see [Example 5-14](ch05.html#generating_a_secret_key_from_a_password
    "Example 5-14. Generating a secret key from a password using SecretKeyFactory")).
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 一个更常见的使用场景是使用 PBE 从用户提供的密码生成对称密钥（参见[示例 5-14](ch05.html#generating_a_secret_key_from_a_password
    "示例 5-14. 从密码生成密钥使用 SecretKeyFactory")）。
- en: Example 5-14. Generating a secret key from a password using `SecretKeyFactory`
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 5-14. 使用`SecretKeyFactory`从密码生成密钥
- en: '[PRE13]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: In this case, a `PBEKeySpec` is initialized with the password, a randomly generated
    salt, iteration count, and the desired key length ➊. A `SecretKey` factory that
    implements a PBE key derivation algorithm (in this case, PBKDF2) is then obtained
    with a call to `getInstance()` ➋. Passing the `PBEKeySpec` to `generateSecret()`
    executes the key derivation algorithm and returns a `SecretKey` instance ➌ that
    can be used for encryption or decryption.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，`PBEKeySpec`通过密码、随机生成的盐值、迭代次数和所需的密钥长度来初始化 ➊。然后，通过调用`getInstance()` ➋
    获取实现 PBE 密钥派生算法（在此例中为 PBKDF2）的`SecretKey`工厂。将`PBEKeySpec`传递给`generateSecret()`执行密钥派生算法，并返回一个可以用于加密或解密的`SecretKey`实例
    ➌。
- en: KeyPairGenerator
  id: totrans-139
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: KeyPairGenerator
- en: The `KeyPairGenerator` class generates pairs of public and private keys. A `KeyPairGenerator`
    is instantiated by passing an asymmetric algorithm name to the `getInstance()`
    factory method (➊ in [Example 5-15](ch05.html#initializing_keypairgenerator_with_algor
    "Example 5-15. Initializing KeyPairGenerator with algorithm-specific parameters")).
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: '`KeyPairGenerator`类生成公钥和私钥对。通过将非对称算法名称传递给`getInstance()`工厂方法来实例化`KeyPairGenerator`（➊，参见[示例
    5-15](ch05.html#initializing_keypairgenerator_with_algor "示例 5-15. 使用特定算法参数初始化
    KeyPairGenerator")）。'
- en: Example 5-15. Initializing `KeyPairGenerator` with algorithm-specific parameters
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 5-15. 使用特定算法参数初始化`KeyPairGenerator`
- en: '[PRE14]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'There are two ways to initialize a `KeyPairGenerator`: by specifying the desired
    key size and by specifying algorithm-specific parameters. In both cases, you can
    optionally pass a `SecureRandom` instance to be used for key generation. If only
    a key size is specified, key generation will use default parameters (if any).
    To specify additional parameters, you must instantiate and configure an `AlgorithmParameterSpec`
    instance appropriate for the asymmetric algorithm you are using and pass it to
    the `initialize()` method, as shown in [Example 5-15](ch05.html#initializing_keypairgenerator_with_algor
    "Example 5-15. Initializing KeyPairGenerator with algorithm-specific parameters").
    In this example, the `ECGenParameterSpec` initialized in ➋ is an `AlgorithmParameterSpec`
    that allows you to specify the curve name used when generating *Elliptic Curve
    (EC)* cryptography keys. After it is passed to the `initialize()` method in ➌,
    the subsequent `generateKeyPair()` call in ➍ will use the specified curve (*secp256r1*)
    to generate the key pair.'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 有两种方法可以初始化 `KeyPairGenerator`：一种是指定所需的密钥大小，另一种是指定算法特定的参数。在这两种情况下，你都可以选择性地传入一个
    `SecureRandom` 实例用于密钥生成。如果仅指定了密钥大小，密钥生成将使用默认参数（如果有的话）。要指定其他参数，必须实例化并配置一个适用于你所使用的非对称算法的
    `AlgorithmParameterSpec` 实例，并将其传递给 `initialize()` 方法，如 [示例 5-15](ch05.html#initializing_keypairgenerator_with_algor
    "示例 5-15. 使用算法特定参数初始化 KeyPairGenerator") 中所示。在此示例中，➋ 初始化的 `ECGenParameterSpec`
    是一个 `AlgorithmParameterSpec`，它允许你在生成 *椭圆曲线（EC）* 密码学密钥时指定使用的曲线名称。将其传递给 ➌ 中的 `initialize()`
    方法后，随后的 `generateKeyPair()` 调用将在 ➍ 中使用指定的曲线（*secp256r1*）来生成密钥对。
- en: Note
  id: totrans-144
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '*While named curves have been defined by various standards, the Oracle JCA
    specification does not explicitly define any elliptic curve names. As there is
    no official JCA standard, curve names supported by Android may vary based on platform
    version.*'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: '*虽然许多标准已经定义了命名曲线，但 Oracle JCA 规范并未明确规定任何椭圆曲线名称。由于没有官方的 JCA 标准，Android 支持的曲线名称可能会根据平台版本有所不同。*'
- en: KeyGenerator
  id: totrans-146
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: KeyGenerator
- en: The `KeyGenerator` is very similar to the `KeyPairGenerator` class, except that
    it generates symmetric keys. While you can generate most symmetric keys by requesting
    a sequence of random bytes from `SecureRandom`, `KeyGenerator` implementations
    perform additional checks for weak keys and set key parity bytes where appropriate
    (for DES and derived algorithms) and can take advantage of available cryptography
    hardware, so it’s best to use `KeyGenerator` instead of generating keys manually.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: '`KeyGenerator` 类与 `KeyPairGenerator` 类非常相似，不同之处在于它生成的是对称密钥。虽然你可以通过从 `SecureRandom`
    请求一系列随机字节来生成大多数对称密钥，但 `KeyGenerator` 实现会进行额外的弱密钥检查，并在适当的位置设置密钥奇偶校验字节（对于 DES 及衍生算法），还可以利用可用的密码硬件，因此最好使用
    `KeyGenerator` 而不是手动生成密钥。'
- en: '[Example 5-16](ch05.html#generating_an_aes_key_with_keygenerator "Example 5-16. Generating
    an AES key with KeyGenerator") shows how to generate an AES key using `KeyGenerator`.'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 5-16](ch05.html#generating_an_aes_key_with_keygenerator "示例 5-16. 使用 KeyGenerator
    生成 AES 密钥") 展示了如何使用 `KeyGenerator` 生成 AES 密钥。'
- en: Example 5-16. Generating an AES key with `KeyGenerator`
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 5-16. 使用 `KeyGenerator` 生成 AES 密钥
- en: '[PRE15]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: To generate a key using `KeyGenerator`, create an instance ➊, specify the desired
    key size with `init()` ➋, and then call `generateKey()` ➌ to generate the key.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用 `KeyGenerator` 生成密钥，首先创建一个实例 ➊，通过 `init()` 方法指定所需的密钥大小 ➋，然后调用 `generateKey()`
    ➌ 生成密钥。
- en: KeyAgreement
  id: totrans-152
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: KeyAgreement
- en: The `KeyAgreement` class represents a *key agreement protocol* that allows two
    or more parties to generate a shared key without needing to exchange secret information.
    While there are different key agreement protocols, the ones most widely used today
    are based on the *Diffie-Hellman (DH) key exchange*— either the original one based
    on discrete logarithm cryptography^([[48](#ftn.ch05fn11)]) (simply known as *DH*),
    or the newer variant based on elliptic key cryptography (*ECDH*^([[49](#ftn.ch05fn12)])).
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: '`KeyAgreement` 类表示一个 *密钥协商协议*，它允许两个或更多方生成一个共享密钥，而无需交换秘密信息。虽然有多种密钥协商协议，但目前最广泛使用的协议是基于
    *Diffie-Hellman (DH) 密钥交换*——无论是基于离散对数密码学的原始协议^([[48](#ftn.ch05fn11)])（通常称为 *DH*），还是基于椭圆曲线密码学的更新版协议（*ECDH*^([[49](#ftn.ch05fn12)]))。'
- en: Both variants of the protocol are modeled in JCA using the `KeyAgreement` class
    and can be performed in the same way, with the only difference being the keys.
    For both variants, each communicating party needs to have a key pair, with both
    key pairs generated with the same key parameters (prime modulus and base generator
    for DH, and typically the same well-defined named curve for ECDH). Then the parties
    only need to exchange public keys and execute the key agreement algorithm to arrive
    at a common secret.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 协议的两种变体在 JCA 中都通过 `KeyAgreement` 类建模，并且可以以相同的方式执行，唯一的区别在于密钥。对于这两种变体，每个通信方都需要拥有一对密钥，且这两对密钥是使用相同的密钥参数生成的（DH
    的素数模数和基生成器，通常 ECDH 使用相同的预定义命名曲线）。然后，通信方只需要交换公钥并执行密钥协议算法以达成共享密钥。
- en: '[Example 5-17](ch05.html#using_keyagreement_to_generate_a_shared "Example 5-17. Using
    KeyAgreement to generate a shared secret") illustrates using the `KeyAgreement`
    class to generate a shared secret using ECDH.'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 5-17](ch05.html#using_keyagreement_to_generate_a_shared "示例 5-17. 使用 KeyAgreement
    生成共享密钥") 展示了如何使用 `KeyAgreement` 类通过 ECDH 生成共享密钥。'
- en: Example 5-17. Using `KeyAgreement` to generate a shared secret
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 5-17. 使用 `KeyAgreement` 生成共享密钥
- en: '[PRE16]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: A `KeyAgreement` instance is first created by passing the algorithm name, *ECDH*,
    to the `getInstance()` factory method ➊. Then the agreement is initialized by
    passing the local private key to the `init()` method ➋. Next, the `doPhase()`
    method is called *N* – 1 times, where *N* is the number of communicating parties,
    passing each party’s public key as the first parameter, and setting the second
    parameter to `true` when executing the last phase of the agreement ➌. (For two
    communicating parties, as in this example, the `doPhase()` method needs to be
    called only once.) Finally, calling the `generateSecret()` method ➍ produces the
    shared secret.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 首先通过将算法名称 *ECDH* 传递给 `getInstance()` 工厂方法 ➊ 来创建 `KeyAgreement` 实例。然后，通过将本地私钥传递给
    `init()` 方法 ➋ 来初始化协议。接下来，调用 `doPhase()` 方法 *N* - 1 次，其中 *N* 是通信方的数量，每次传递每个通信方的公钥作为第一个参数，当执行协议的最后阶段时，将第二个参数设置为
    `true` ➌。（对于两个通信方，如本示例所示，`doPhase()` 方法只需要调用一次。）最后，调用 `generateSecret()` 方法 ➍
    生成共享密钥。
- en: '[Example 5-17](ch05.html#using_keyagreement_to_generate_a_shared "Example 5-17. Using
    KeyAgreement to generate a shared secret") shows the call flow for only one of
    the parties (*A*), but the other party (*B*) needs to execute the same sequence
    using its own private key to initialize the agreement, and passing *A*’s public
    key to `doPhase()`.'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 5-17](ch05.html#using_keyagreement_to_generate_a_shared "示例 5-17. 使用 KeyAgreement
    生成共享密钥") 展示了其中一方（*A*）的调用流程，但另一方（*B*）需要使用自己的私钥执行相同的步骤来初始化协议，并将 *A* 的公钥传递给 `doPhase()`。'
- en: Note that while the value (or part of it) returned by `generateSecret()` can
    be used directly as a symmetric key, the preferred method is to use it as the
    input for a *key-derivation function (KDF)* and use the output of the KDF as key(s).
    Directly using the generated shared secret may lead to some loss of entropy, and
    doing so limits the number of keys that can be produced using a single DH key
    agreement operation. On the other hand, using a KDF diffuses any structure that
    the secret may have (such as padding) and allows for generating multiple derived
    keys by mixing in a salt.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，虽然 `generateSecret()` 返回的值（或其部分）可以直接用作对称密钥，但推荐的做法是将其作为 *密钥派生函数（KDF）* 的输入，并使用
    KDF 的输出作为密钥。直接使用生成的共享密钥可能会导致一些熵丧失，并且这样做限制了使用单次 DH 密钥协议操作生成密钥的数量。另一方面，使用 KDF 可以扩散密钥的结构（如填充），并通过混合盐值来生成多个派生密钥。
- en: '`KeyAgreement` has another `generateSecret()` method which takes an algorithm
    name as a parameter and returns a `SecretKey` instance that can be used to initialize
    a `Cipher` directly. If the `KeyAgreement` instance has been created with an algorithm
    string that includes a KDF specification (for example, *ECDHwithSHA1KDF*), this
    method will apply the KDF to the shared secret before returning a `SecretKey`.
    If a KDF has not been specified, most implementations simply truncate the shared
    secret in order to obtain key material for the returned `SecretKey`.'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: '`KeyAgreement` 还有另一个 `generateSecret()` 方法，该方法接收一个算法名称作为参数，并返回一个可以直接用于初始化 `Cipher`
    的 `SecretKey` 实例。如果 `KeyAgreement` 实例是使用包含 KDF 规格的算法字符串创建的（例如 *ECDHwithSHA1KDF*），该方法会在返回
    `SecretKey` 之前将 KDF 应用到共享密钥上。如果没有指定 KDF，大多数实现会简单地截断共享密钥，以获得用于返回 `SecretKey` 的密钥材料。'
- en: KeyStore
  id: totrans-162
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 密钥库
- en: 'JCA uses the term *keystore* to refer to a database of keys and certificates.
    A keystore manages multiple cryptographic objects, referred to as *entries* that
    are each associated with a string *alias.* The `KeyStore` class offers a well-defined
    interface to a keystore that defines three types of entries:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: JCA 使用术语 *keystore* 来指代包含密钥和证书的数据库。密钥库管理多个加密对象，这些对象称为 *entries*，每个条目都与一个字符串
    *alias* 相关联。`KeyStore` 类为密钥库提供了一个明确定义的接口，该接口定义了三种类型的条目：
- en: '****`PrivateKeyEntry`****. A private key with an associated certificate chain.
    For a software implementation, the private key material is usually encrypted and
    protected by a user-supplied passphrase.'
  id: totrans-164
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '****`PrivateKeyEntry`****。一个私钥和一个关联的证书链。对于软件实现，私钥通常是加密的，并由用户提供的密码短语保护。'
- en: '****`SecretKeyEntry`****. A secret (symmetric) key. Not all `KeyStore` implementations
    support storing secret keys.'
  id: totrans-165
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '****`SecretKeyEntry`****。一个对称（秘密）密钥。并非所有 `KeyStore` 实现都支持存储秘密密钥。'
- en: '****`TrustedCertificateEntry`****. A public key certificate of another party.
    `TrustedCertificateEntry`s often contain CA certificates that can be used to establish
    trust relationships. A keystore that contains only `TrustedCertificateEntry`s
    is called a *truststore*.'
  id: totrans-166
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '****`TrustedCertificateEntry`****。 另一个方的公钥证书。`TrustedCertificateEntry` 通常包含可用于建立信任关系的
    CA 证书。只包含 `TrustedCertificateEntry` 的密钥库被称为 *信任库*。'
- en: KeyStore Types
  id: totrans-167
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 密钥库类型
- en: A `KeyStore` implementation does not need to be persistent, but most implementations
    are. Different implementations are identified by a *keystore type* that defines
    the storage and data format of the keystore, as well as the methods used to protect
    stored keys. The default `KeyStore` type is set with the `keystore.type` system
    property.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: '`KeyStore` 实现不需要持久化，但大多数实现是持久化的。不同的实现通过 *密钥库类型* 来识别，该类型定义了密钥库的存储和数据格式，以及用于保护存储密钥的方法。默认的
    `KeyStore` 类型通过 `keystore.type` 系统属性设置。'
- en: The default `KeyStore` implementation of most JCA providers is usually a keystore
    type that stores its data in a file. The file format may be proprietary or based
    on a public standard. Proprietary formats include the original Java SE *JKS* format
    and its security enhanced version *JCEKS*, as well as the *Bouncy Castle KeyStore
    (BKS)* format, which is the default in Android.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数 JCA 提供程序的默认`KeyStore`实现通常是一种将数据存储在文件中的密钥库类型。文件格式可能是专有的，也可能基于公开标准。专有格式包括原始的
    Java SE *JKS* 格式及其安全增强版本 *JCEKS*，以及 *Bouncy Castle KeyStore (BKS)* 格式，这是 Android
    中的默认格式。
- en: PKCS#12 File-Backed KeyStores
  id: totrans-170
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: PKCS#12 文件支持的密钥库
- en: The most widely used public standard that allows for bundling private keys and
    associated certificates in a file is the *Personal Information Exchange Syntax
    Standard*, commonly referred to as *PKCS#12*. It is a successor of the *Personal
    Information Exchange Syntax (PFX)* standard, so the terms PKCS#12 and PFX are
    used somewhat interchangeably, and PKCS#12 files are often called PFX files.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 最广泛使用的公共标准之一，是允许将私钥及其关联证书捆绑在一个文件中的 *个人信息交换语法标准*，通常称为 *PKCS#12*。它是 *个人信息交换语法（PFX）*
    标准的继承者，因此 PKCS#12 和 PFX 这两个术语在一定程度上可以互换使用，PKCS#12 文件通常被称为 PFX 文件。
- en: PKCS#12 is a container format that can contain multiple embedded objects, such
    as private keys, certificates, and even CRLs. Like the previous PKCS standards,
    which PKCS#12 builds upon, the container contents are defined in *ASN.1*^([[50](#ftn.ch05fn13)])
    and are essentially a sequence of nested structures. The internal container structures
    are called `SafeBags`, with different bags defined for certificates (`CertBag`),
    private keys (`KeyBag`), and encrypted private keys (`PKCS8ShroudedKeyBag`). The
    integrity of the whole file is protected by a MAC that uses a key derived from
    an *integrity password*, and each individual private key entry is encrypted with
    a key derived from a *privacy password*. In practice, the two passwords are usually
    the same. PKCS#12 can also use public keys to protect the privacy and integrity
    of the archive contents, but this usage is not very common.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: PKCS#12 是一种容器格式，可以包含多个嵌入对象，例如私钥、证书，甚至 CRL。像 PKCS#12 所基于的前几个 PKCS 标准一样，容器内容在
    *ASN.1*^([[50](#ftn.ch05fn13)]) 中定义，本质上是一个嵌套结构的序列。内部容器结构称为 `SafeBags`，并为证书（`CertBag`）、私钥（`KeyBag`）和加密私钥（`PKCS8ShroudedKeyBag`）定义了不同的袋子。整个文件的完整性由一个使用
    *完整性密码* 派生的密钥保护的 MAC 保护，每个私钥条目都使用一个从 *隐私密码* 派生的密钥加密。实际上，这两个密码通常是相同的。PKCS#12 还可以使用公钥来保护归档内容的隐私性和完整性，但这种用法并不常见。
- en: A typical PKCS#12 file that contains a user’s encrypted password key and an
    associated certificate might have structure like that illustrated in Figure 5-3
    (note that some of the wrapper structures have been removed for clarity).
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 一个典型的 PKCS#12 文件包含用户加密的密码密钥和关联证书，其结构可能如图 5-3 所示（注意，为了简洁，某些包装结构已被移除）。
- en: '![Structure of a PKCS#12 file holding a private key and an associated certificate](figs/web/05fig03.png)'
  id: totrans-174
  prefs: []
  type: TYPE_IMG
  zh: '![持有私钥和关联证书的 PKCS#12 文件结构](figs/web/05fig03.png)'
- en: Figure 5-3. Structure of a PKCS#12 file holding a private key and an associated
    certificate
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5-3. 持有私钥和关联证书的 PKCS#12 文件结构
- en: '[Example 5-18](ch05.html#using_the_keystore_class_to_extract_a_pr "Example 5-18. Using
    the KeyStore class to extract a private key and certificate from a PKCS#12 file")
    shows how to obtain a private key and certificate from a PKCS#12 file.'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 5-18](ch05.html#using_the_keystore_class_to_extract_a_pr "示例 5-18. 使用 KeyStore
    类从 PKCS#12 文件中提取私钥和证书") 展示了如何从 PKCS#12 文件中获取私钥和证书。'
- en: Example 5-18. Using the `KeyStore` class to extract a private key and certificate
    from a PKCS#12 file
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 5-18. 使用 `KeyStore` 类从 PKCS#12 文件中提取私钥和证书
- en: '[PRE17]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: The `KeyStore` class can be used to access the contents of a PKCS#12 file by
    specifying *PKCS12* as the keystore type when creating an instance (➊ in [Example 5-18](ch05.html#using_the_keystore_class_to_extract_a_pr
    "Example 5-18. Using the KeyStore class to extract a private key and certificate
    from a PKCS#12 file")). To load and parse the PKCS#12 file, we call the `load()`
    method ➋, passing an `InputStream` from which to read the file, and the file integrity
    password. Once the file is loaded, we can obtain a private key entry by calling
    the `getEntry()` method and passing the key alias ➌ and, optionally, a `KeyStore.PasswordProtection`
    instance initialized with the password for the requested entry, if it’s different
    from the file integrity password. If the alias is unknown, all aliases can be
    listed with the `aliases()` method. Once we have a `PrivateKeyEntry`, we can access
    the public key certificate ➍ or the private key ➎. New entries can be added with
    the `setEntry()` method and deleted with the `deleteEntry()` method. Changes to
    the `KeyStore` contents can be persisted to disk by calling the `store()` method,
    which accepts an `OutputStream` (to which the keystore bytes are written) and
    an integrity password (which is used to derive MAC and encryption keys) as parameters.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: '`KeyStore` 类可以通过在创建实例时指定 *PKCS12* 作为密钥库类型来访问 PKCS#12 文件的内容（➊，见[示例 5-18](ch05.html#using_the_keystore_class_to_extract_a_pr
    "示例 5-18. 使用 KeyStore 类从 PKCS#12 文件中提取私钥和证书")）。为了加载和解析 PKCS#12 文件，我们调用 `load()`
    方法 ➋，传入用于读取文件的 `InputStream` 和文件完整性密码。文件加载后，我们可以通过调用 `getEntry()` 方法并传入密钥别名 ➌
    来获取私钥条目，另外，如果请求的条目密码与文件完整性密码不同，还可以传入一个用该密码初始化的 `KeyStore.PasswordProtection` 实例。如果别名未知，可以使用
    `aliases()` 方法列出所有别名。一旦获得了 `PrivateKeyEntry`，我们可以访问公钥证书 ➍ 或私钥 ➎。可以使用 `setEntry()`
    方法添加新条目，使用 `deleteEntry()` 方法删除条目。通过调用 `store()` 方法，可以将对 `KeyStore` 内容的更改持久化到磁盘，该方法接受一个
    `OutputStream`（将密钥库字节写入该流）和一个完整性密码（用于推导 MAC 和加密密钥）作为参数。'
- en: A `KeyStore` implementation does not have to use a single file for storing key
    and certificate objects. It can use multiple files, a database, or any other storage
    mechanism. In fact, keys may not be stored on the host system at all, but on a
    separate hardware device such as a smart card or a *hardware security module (HSM)*.
    (Android-specific `KeyStore` implementations that provide an interface to the
    system’s trust store and credential storage are introduced in [Chapter 6](ch06.html
    "Chapter 6. Network Security and PKI") and [Chapter 7](ch07.html "Chapter 7. Credential
    Storage").)
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: '`KeyStore` 实现不一定需要使用单个文件来存储密钥和证书对象。它可以使用多个文件、数据库或任何其他存储机制。事实上，密钥可能根本不存储在主机系统上，而是存储在单独的硬件设备上，例如智能卡或*硬件安全模块（HSM）*。（针对
    Android 的 `KeyStore` 实现提供了对系统的信任存储和凭证存储的接口，相关内容在[第 6 章](ch06.html "第 6 章 网络安全与公钥基础设施")和[第
    7 章](ch07.html "第 7 章 凭证存储")中介绍。）'
- en: CertificateFactory and CertPath
  id: totrans-181
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: CertificateFactory 和 CertPath
- en: '`CertificateFactory` acts as a certificate and CRL parser and can build certificate
    chains from a list of certificates. It can read a stream that contains encoded
    certificates or CRLs and output a collection (or a single instance) of `java.security.cert.Certificate`
    and `java.security.cert.CRL` objects. Usually, only an *X.509* implementation
    that parses X.509 certificates and CRLs is available.'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: '`CertificateFactory` 充当证书和 CRL 解析器，可以从证书列表中构建证书链。它可以读取包含编码证书或 CRL 的流，并输出一个
    `java.security.cert.Certificate` 和 `java.security.cert.CRL` 对象的集合（或单个实例）。通常，只有解析
    X.509 证书和 CRL 的 *X.509* 实现是可用的。'
- en: '[Example 5-19](ch05.html#parsing_an_xdot509_certificate_file_with "Example 5-19. Parsing
    an X.509 certificate file with CertificateFactory") shows how to parse a certificate
    file using `CertificateFactory`.'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 5-19](ch05.html#parsing_an_xdot509_certificate_file_with "示例 5-19. 使用 CertificateFactory
    解析 X.509 证书文件") 展示了如何使用 `CertificateFactory` 解析证书文件。'
- en: Example 5-19. Parsing an X.509 certificate file with `CertificateFactory`
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 5-19. 使用 `CertificateFactory` 解析 X.509 证书文件
- en: '[PRE18]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: To create a `CertificateFactory`, we pass *X.509* as the factory type to `getInstance()`
    ➊, and then call `generateCertificate()`, passing an `InputStream` from which
    to read ➋. Because this is an *X.509* factory, the obtained object can be safely
    cast to `java.security.cert.X509Certificate`. If the read file includes multiple
    certificates that form a certificate chain, a `CertPath` object can be obtained
    by calling the `generateCertPath()` method.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建一个 `CertificateFactory`，我们将 *X.509* 作为工厂类型传递给 `getInstance()` ➊，然后调用 `generateCertificate()`，传入一个
    `InputStream` 来读取数据 ➋。由于这是一个 *X.509* 工厂，获取的对象可以安全地转换为 `java.security.cert.X509Certificate`。如果读取的文件包含多个证书，形成一个证书链，可以通过调用
    `generateCertPath()` 方法获得一个 `CertPath` 对象。
- en: CertPathValidator and CertPathBuilder
  id: totrans-187
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: CertPathValidator 和 CertPathBuilder
- en: The `CertPathValidator` class encapsulates a certificate chain validation algorithm
    as defined by the *Public-Key Infrastructure (X.509)* or *PKIX* standard.^([[51](#ftn.ch05fn14)])
    We discuss PKIX and certificate chain validation in more detail in [Chapter 6](ch06.html
    "Chapter 6. Network Security and PKI"), but [Example 5-20](ch05.html#building_and_validating_a_certificate_ch
    "Example 5-20. Building and validating a certificate chain with CertPathValidator")
    shows how to use `CertificateFactory` and `CertPathValidator` to build and validate
    a certificate chain.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: '`CertPathValidator` 类封装了一个证书链验证算法，该算法由 *公钥基础设施（X.509）* 或 *PKIX* 标准定义。我们在[第
    6 章](ch06.html "第 6 章. 网络安全与公钥基础设施")中将更详细地讨论 PKIX 和证书链验证，但[示例 5-20](ch05.html#building_and_validating_a_certificate_ch
    "示例 5-20. 使用 CertPathValidator 构建并验证证书链")展示了如何使用 `CertificateFactory` 和 `CertPathValidator`
    来构建和验证证书链。'
- en: Example 5-20. Building and validating a certificate chain with `CertPathValidator`
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 5-20. 使用 `CertPathValidator` 构建并验证证书链
- en: '[PRE19]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: As you can see, we first obtain a `CertPathValidator` instance by passing *PKIX*
    to the `getInstance()` method ➊. We then build a certificate chain using `CertificateFactory`’s
    `generateCertPath()` method ➋. Note that if the passed list of certificates does
    not form a valid chain, this method throws a `CertificateException`. If we do
    not already have all the certificates needed to form a chain, we can use a `CertPathBuilder`
    initialized with a `CertStore` to find the needed certificates and build a `CertPath`
    (not shown).
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，我们首先通过将 *PKIX* 传递给 `getInstance()` 方法 ➊ 获得一个 `CertPathValidator` 实例。然后，我们使用
    `CertificateFactory` 的 `generateCertPath()` 方法 ➋ 构建证书链。请注意，如果传入的证书列表无法形成有效的链条，方法将抛出
    `CertificateException`。如果我们还没有所有构成链条所需的证书，我们可以使用初始化为 `CertStore` 的 `CertPathBuilder`
    来查找所需的证书并构建一个 `CertPath`（未显示）。
- en: Once we have a `CertPath`, we initialize the `PKIXParameters` class with a set
    of *trust anchors* (typically, these are trusted CA certificates; see [Chapter 6](ch06.html
    "Chapter 6. Network Security and PKI") for details) ➌, and then call `CertPathValidator.validate()`
    ➍, passing the `CertPath` that we built in ➋ and the `PKIXParameters` instance.
    If validation succeeds, `validate()` returns a `PKIXCertPathValidatorResult` instance;
    if not, it throws a `CertPathValidatorException` that contains detailed information
    about why it failed.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们拥有了 `CertPath`，我们通过一组 *信任锚*（通常这些是可信的 CA 证书；详细信息请参见[第 6 章](ch06.html "第 6
    章. 网络安全与公钥基础设施")）初始化 `PKIXParameters` 类 ➌，然后调用 `CertPathValidator.validate()`
    ➍，传入我们在 ➋ 中构建的 `CertPath` 和 `PKIXParameters` 实例。如果验证成功，`validate()` 返回一个 `PKIXCertPathValidatorResult`
    实例；如果失败，则抛出一个包含失败原因的 `CertPathValidatorException`。
- en: Android JCA Providers
  id: totrans-193
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Android JCA 提供者
- en: Android’s cryptography providers are based on JCA and follow its architecture
    with some relatively minor exceptions. While low-level Android components directly
    use native cryptography libraries (such as OpenSSL), JCA is the main cryptographic
    API and is used by system components and third-party applications alike.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: Android 的加密提供者基于 JCA，并遵循其架构，只有一些相对较小的例外。虽然低级 Android 组件直接使用本地加密库（如 OpenSSL），JCA
    是主要的加密 API，系统组件和第三方应用程序都在使用它。
- en: Android has three core JCA providers that include implementations of the engine
    classes outlined in the previous section and two *Java Secure Socket Extension
    (JSSE)* providers that implement SSL functionality. (JSSE is discussed in detail
    in [Chapter 6](ch06.html "Chapter 6. Network Security and PKI").)
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: Android 有三个核心 JCA 提供者，其中包括前述引擎类的实现，还有两个 *Java Secure Socket Extension (JSSE)*
    提供者，它们实现了 SSL 功能。（JSSE 在[第 6 章](ch06.html "第 6 章. 网络安全和 PKI")中有详细讨论。）
- en: Let’s examine Android’s core JCA providers.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看 Android 的核心 JCA 提供者。
- en: Harmony’s Crypto Provider
  id: totrans-197
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Harmony 的 Crypto 提供者
- en: Android’s Java runtime library implementation is derived from the retired Apache
    Harmony project,^([[52](#ftn.ch05fn15)]) which also includes a limited JCA provider
    simply named *Crypto* that provides implementations for basic cryptographic services
    like random number generation, hashing, and digital signatures. Crypto is still
    included in Android for backward compatibility but has the lowest priority of
    all JCA providers, so engine class implementations from Crypto are not returned
    unless explicitly requested. [Table 5-1](ch05.html#algorithms_supported_by_the_crypto_provi
    "Table 5-1. Algorithms Supported by the Crypto Provider as of Android 4.4.4")
    shows the engine classes and algorithms that Crypto supports.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: Android 的 Java 运行时库实现来源于已退役的 Apache Harmony 项目，^([[52](#ftn.ch05fn15)])，该项目还包括一个名为
    *Crypto* 的有限 JCA 提供者，提供了基本的加密服务实现，如随机数生成、哈希和数字签名。Crypto 仍然包含在 Android 中，以确保向后兼容，但它在所有
    JCA 提供者中优先级最低，因此，除非显式请求，否则不会返回 Crypto 的引擎类实现。[表 5-1](ch05.html#algorithms_supported_by_the_crypto_provi
    "表 5-1. 截至 Android 4.4.4 加密提供者支持的算法") 显示了 Crypto 支持的引擎类和算法。
- en: Table 5-1. Algorithms Supported by the Crypto Provider as of Android 4.4.4
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 表 5-1. 截至 Android 4.4.4 加密提供者支持的算法
- en: '| Engine Class Name | Supported Algorithms |'
  id: totrans-200
  prefs: []
  type: TYPE_TB
  zh: '| 引擎类名称 | 支持的算法 |'
- en: '| --- | --- |'
  id: totrans-201
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `KeyFactory` | *DSA* |'
  id: totrans-202
  prefs: []
  type: TYPE_TB
  zh: '| `KeyFactory` | *DSA* |'
- en: '| `MessageDigest` | *SHA-1* |'
  id: totrans-203
  prefs: []
  type: TYPE_TB
  zh: '| `MessageDigest` | *SHA-1* |'
- en: '| `SecureRandom` | *SHA1PRNG* |'
  id: totrans-204
  prefs: []
  type: TYPE_TB
  zh: '| `SecureRandom` | *SHA1PRNG* |'
- en: '| `Signature` | *SHA1withDSA* |'
  id: totrans-205
  prefs: []
  type: TYPE_TB
  zh: '| `Signature` | *SHA1withDSA* |'
- en: Note
  id: totrans-206
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '*While the algorithms listed in [Table 5-1](ch05.html#algorithms_supported_by_the_crypto_provi
    "Table 5-1. Algorithms Supported by the Crypto Provider as of Android 4.4.4")
    are still available in Android 4.4, all except* SHA1PRNG *have been removed in
    the Android master branch and may not be available in future versions.*'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: '*虽然 [表 5-1](ch05.html#algorithms_supported_by_the_crypto_provi "表 5-1. 截至 Android
    4.4.4 加密提供者支持的算法") 中列出的算法仍然可以在 Android 4.4 中使用，但除* SHA1PRNG *外，所有算法已在 Android
    主分支中移除，并可能在未来的版本中不可用。*'
- en: Android’s Bouncy Castle Provider
  id: totrans-208
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Android 的 Bouncy Castle 提供者
- en: Before Android version 4.0, the only full-featured JCA provider in Android was
    the Bouncy Castle provider. The Bouncy Castle provider is part of the Bouncy Castle
    Crypto APIs,^([[53](#ftn.ch05fn16)]) a set of open source Java implementations
    of cryptographic algorithms and protocols.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Android 4.0 之前，Android 唯一的全功能 JCA 提供者是 Bouncy Castle 提供者。Bouncy Castle 提供者是
    Bouncy Castle 加密 API 的一部分，^([[53](#ftn.ch05fn16)])，这是一套开源的 Java 加密算法和协议实现。
- en: Android includes a modified version of the Bouncy Castle provider, which is
    derived from the mainstream version by applying a set of Android-specific patches.
    Those patches are maintained in the Android source tree and updated for each new
    release of the mainstream Bouncy Castle provider. The main differences from the
    mainstream version are summarized below.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: Android 包含了一个修改版的 Bouncy Castle 提供者，该版本通过应用一系列 Android 特定的补丁从主流版本派生而来。这些补丁在
    Android 源代码树中维护，并随着主流 Bouncy Castle 提供者的每个新版本进行更新。与主流版本的主要差异如下所述。
- en: Algorithms, modes, and algorithm parameters not supported by Java’s reference
    implementation (RI) have been removed (RIPEMD, SHA-224, GOST3411, Twofish, CMAC,
    El Gamal, RSA-PSS, ECMQV, and so on).
  id: totrans-211
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不被 Java 参考实现（RI）支持的算法、模式和算法参数已被移除（如 RIPEMD、SHA-224、GOST3411、Twofish、CMAC、El
    Gamal、RSA-PSS、ECMQV 等）。
- en: Insecure algorithms such as MD2 and RC2 have been removed.
  id: totrans-212
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不安全的算法如 MD2 和 RC2 已被移除。
- en: Java-based implementations of MD5 and the SHA family of digest algorithms have
    been replaced with a native implementation.
  id: totrans-213
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基于 Java 的 MD5 和 SHA 系列摘要算法的实现已被本地实现所替代。
- en: Some PBE algorithms have been removed (for example, *PBEwithHmacSHA256*).
  id: totrans-214
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 已移除一些 PBE 算法（例如，*PBEwithHmacSHA256*）。
- en: Support for accessing certificates stored in LDAP has been removed.
  id: totrans-215
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 已移除对存储在 LDAP 中的证书的访问支持。
- en: Support for certificate blacklists has been added (blacklists are discussed
    in [Chapter 6](ch06.html "Chapter 6. Network Security and PKI")).
  id: totrans-216
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 已添加对证书黑名单的支持（黑名单详见 [第 6 章](ch06.html "第 6 章. 网络安全与 PKI")）。
- en: Various performance optimizations have been made.
  id: totrans-217
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 已进行各种性能优化。
- en: The package name has been changed to `com.android.org.bouncycastle` to avoid
    conflict with apps that bundle in Bouncy Castle (since Android 3.0).
  id: totrans-218
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 包名已更改为 `com.android.org.bouncycastle`，以避免与捆绑 Bouncy Castle 的应用程序发生冲突（自 Android
    3.0 起）。
- en: The engine classes and algorithms supported by Android’s Bouncy Castle provider
    as of version 4.4.4 (based on Bouncy Castle 1.49) are listed in [Table 5-2](ch05.html#algorithms_supported_by_androidapostroph
    "Table 5-2. Algorithms Supported by Android’s Bouncy Castle Provider as of Android
    4.4.4").
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: Android Bouncy Castle 提供程序支持的引擎类和算法列表（基于 Bouncy Castle 1.49，版本为 4.4.4）见 [表 5-2](ch05.html#algorithms_supported_by_androidapostroph
    "表 5-2. Android 4.4.4 版本的 Bouncy Castle 提供程序支持的算法")。
- en: Table 5-2. Algorithms Supported by Android’s Bouncy Castle Provider as of Android
    4.4.4
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 表 5-2. Android 4.4.4 版本的 Bouncy Castle 提供程序支持的算法
- en: '| Engine Class Name | Supported Algorithms |'
  id: totrans-221
  prefs: []
  type: TYPE_TB
  zh: '| 引擎类名称 | 支持的算法 |'
- en: '| --- | --- |'
  id: totrans-222
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `CertPathBuilder` | *PKIX* |'
  id: totrans-223
  prefs: []
  type: TYPE_TB
  zh: '| `CertPathBuilder` | *PKIX* |'
- en: '| `CertPathValidator` | *PKIX* |'
  id: totrans-224
  prefs: []
  type: TYPE_TB
  zh: '| `CertPathValidator` | *PKIX* |'
- en: '| `CertStore` | *Collection* |'
  id: totrans-225
  prefs: []
  type: TYPE_TB
  zh: '| `CertStore` | *Collection* |'
- en: '| `CertificateFactory` | *X.509* |'
  id: totrans-226
  prefs: []
  type: TYPE_TB
  zh: '| `CertificateFactory` | *X.509* |'
- en: '| `Cipher` | *AES**AESWRAP**ARC4**BLOWFISH**DES**DESEDE**DESEDEWRAP**PBEWITHMD5AND128BITAES-CBC-OPENSSL**PBEWITHMD5AND192BITAES-CBC-OPENSSL**PBEWITHMD5AND256BITAES-CBC-OPENSSL**PBEWITHMD5ANDDES**PBEWITHMD5ANDRC2**PBEWITHSHA1ANDDES**PBEWITHSHA1ANDRC2**PBEWITHSHA256AND128BITAES-CBC-BC**PBEWITHSHA256AND192BITAES-CBC-BC**PBEWITHSHA256AND256BITAES-CBC-BC**PBEWITHSHAAND128BITAES-CBC-BC**PBEWITHSHAAND128BITRC2-CBC**PBEWITHSHAAND128BITRC4**PBEWITHSHAAND192BITAES-CBC-BC**PBEWITHSHAAND2-KEYTRIPLEDES-CBC**PBEWITHSHAAND256BITAES-CBC-BC**PBEWITHSHAAND3-KEYTRIPLEDES-CBC**PBEWITHSHAAND40BITRC2-CBC**PBEWITHSHAAND40BITRC4**PBEWITHSHAANDTWOFISH-CBC**RSA*
    |'
  id: totrans-227
  prefs: []
  type: TYPE_TB
  zh: '| `Cipher` | *AES**AESWRAP**ARC4**BLOWFISH**DES**DESEDE**DESEDEWRAP**PBEWITHMD5AND128BITAES-CBC-OPENSSL**PBEWITHMD5AND192BITAES-CBC-OPENSSL**PBEWITHMD5AND256BITAES-CBC-OPENSSL**PBEWITHMD5ANDDES**PBEWITHMD5ANDRC2**PBEWITHSHA1ANDDES**PBEWITHSHA1ANDRC2**PBEWITHSHA256AND128BITAES-CBC-BC**PBEWITHSHA256AND192BITAES-CBC-BC**PBEWITHSHA256AND256BITAES-CBC-BC**PBEWITHSHAAND128BITAES-CBC-BC**PBEWITHSHAAND128BITRC2-CBC**PBEWITHSHAAND128BITRC4**PBEWITHSHAAND192BITAES-CBC-BC**PBEWITHSHAAND2-KEYTRIPLEDES-CBC**PBEWITHSHAAND256BITAES-CBC-BC**PBEWITHSHAAND3-KEYTRIPLEDES-CBC**PBEWITHSHAAND40BITRC2-CBC**PBEWITHSHAAND40BITRC4**PBEWITHSHAANDTWOFISH-CBC**RSA*
    |'
- en: '| `KeyAgreement` | *DH**ECDH* |'
  id: totrans-228
  prefs: []
  type: TYPE_TB
  zh: '| `KeyAgreement` | *DH**ECDH* |'
- en: '| `KeyFactory` | *DH**DSA**EC**RSA* |'
  id: totrans-229
  prefs: []
  type: TYPE_TB
  zh: '| `KeyFactory` | *DH**DSA**EC**RSA* |'
- en: '| `KeyGenerator` | *AES**ARC4**BLOWFISH**DES**DESEDE**HMACMD5**HMACSHA1**HMACSHA256**HMACSHA384**HMACSHA512*
    |'
  id: totrans-230
  prefs: []
  type: TYPE_TB
  zh: '| `KeyGenerator` | *AES**ARC4**BLOWFISH**DES**DESEDE**HMACMD5**HMACSHA1**HMACSHA256**HMACSHA384**HMACSHA512*
    |'
- en: '| `KeyPairGenerator` | *DH**DSA**EC**RSA* |'
  id: totrans-231
  prefs: []
  type: TYPE_TB
  zh: '| `KeyPairGenerator` | *DH**DSA**EC**RSA* |'
- en: '| `KeyStore` | *BKS* (default)*BouncyCastle**PKCS12* |'
  id: totrans-232
  prefs: []
  type: TYPE_TB
  zh: '| `KeyStore` | *BKS*（默认）*BouncyCastle**PKCS12* |'
- en: '| `Mac` | *HMACMD5**HMACSHA1**HMACSHA256**HMACSHA384**HMACSHA512**PBEWITHHMACSHA**PBEWITHHMACSHA1*
    |'
  id: totrans-233
  prefs: []
  type: TYPE_TB
  zh: '| `Mac` | *HMACMD5**HMACSHA1**HMACSHA256**HMACSHA384**HMACSHA512**PBEWITHHMACSHA**PBEWITHHMACSHA1*
    |'
- en: '| `MessageDigest` | *MD5**SHA-1**SHA-256**SHA-384**SHA-512* |'
  id: totrans-234
  prefs: []
  type: TYPE_TB
  zh: '| `MessageDigest` | *MD5**SHA-1**SHA-256**SHA-384**SHA-512* |'
- en: '| `SecretKeyFactory` | *DES**DESEDE**PBEWITHHMACSHA1**PBEWITHMD5AND128BITAES-CBC-OPENSSL**PBEWITHMD5AND192BITAES-CBC-OPENSSL**PBEWITHMD5AND256BITAES-CBC-OPENSSL**PBEWITHMD5ANDDES**PBEWITHMD5ANDRC2**PBEWITHSHA1ANDDES**PBEWITHSHA1ANDRC2**PBEWITHSHA256AND128BITAES-CBC-BC**PBEWITHSHA256AND192BITAES-CBC-BC**PBEWITHSHA256AND256BITAES-CBC-BC**PBEWITHSHAAND128BITAES-CBC-BC**PBEWITHSHAAND128BITRC2-CBC**PBEWITHSHAAND128BITRC4**PBEWITHSHAAND192BITAES-CBC-BC**PBEWITHSHAAND2-KEYTRIPLEDES-CBC**PBEWITHSHAAND256BITAES-CBC-BC**PBEWITHSHAAND3-KEYTRIPLEDES-CBC**PBEWITHSHAAND40BITRC2-CBC**PBEWITHSHAAND40BITRC4**PBEWITHSHAANDTWOFISH-CBC**PBKDF2WithHmacSHA1**PBKDF2WithHmacSHA1And8BIT*
    |'
  id: totrans-235
  prefs: []
  type: TYPE_TB
  zh: '| `SecretKeyFactory` | *DES**DESEDE**PBEWITHHMACSHA1**PBEWITHMD5AND128BITAES-CBC-OPENSSL**PBEWITHMD5AND192BITAES-CBC-OPENSSL**PBEWITHMD5AND256BITAES-CBC-OPENSSL**PBEWITHMD5ANDDES**PBEWITHMD5ANDRC2**PBEWITHSHA1ANDDES**PBEWITHSHA1ANDRC2**PBEWITHSHA256AND128BITAES-CBC-BC**PBEWITHSHA256AND192BITAES-CBC-BC**PBEWITHSHA256AND256BITAES-CBC-BC**PBEWITHSHAAND128BITAES-CBC-BC**PBEWITHSHAAND128BITRC2-CBC**PBEWITHSHAAND128BITRC4**PBEWITHSHAAND192BITAES-CBC-BC**PBEWITHSHAAND2-KEYTRIPLEDES-CBC**PBEWITHSHAAND256BITAES-CBC-BC**PBEWITHSHAAND3-KEYTRIPLEDES-CBC**PBEWITHSHAAND40BITRC2-CBC**PBEWITHSHAAND40BITRC4**PBEWITHSHAANDTWOFISH-CBC**PBKDF2WithHmacSHA1**PBKDF2WithHmacSHA1And8BIT*
    |'
- en: '| `Signature` | *ECDSA**MD5WITHRSA**NONEWITHDSA**NONEwithECDSA**SHA1WITHRSA**SHA1withDSA**SHA256WITHECDSA**SHA256WITHRSA**SHA384WITHECDSA**SHA384WITHRSA**SHA512WITHECDSA**SHA512WITHRSA*
    |'
  id: totrans-236
  prefs: []
  type: TYPE_TB
  zh: '| `Signature` | *ECDSA**MD5WITHRSA**NONEWITHDSA**NONEwithECDSA**SHA1WITHRSA**SHA1withDSA**SHA256WITHECDSA**SHA256WITHRSA**SHA384WITHECDSA**SHA384WITHRSA**SHA512WITHECDSA**SHA512WITHRSA*
    |'
- en: AndroidOpenSSL Provider
  id: totrans-237
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: AndroidOpenSSL 提供程序
- en: As mentioned in [Android’s Bouncy Castle Provider](ch05.html#androidapostrophes_bouncy_castle_provide
    "Android’s Bouncy Castle Provider"), hash algorithms in Android’s Bouncy Castle
    provider have been replaced with native code for performance reasons. In order
    to further improve cryptographic performance, the number of supported engine classes
    and algorithms in the native AndroidOpenSSL provider has been steadily growing
    with each release since 4.0.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 如在[Android 的 Bouncy Castle 提供程序](ch05.html#androidapostrophes_bouncy_castle_provide
    "Android 的 Bouncy Castle 提供程序")中提到的，Android 的 Bouncy Castle 提供程序中的哈希算法已经被本地代码替换，以提高性能。为了进一步提高加密性能，自
    4.0 版本以来，每次发布时本地 AndroidOpenSSL 提供程序支持的引擎类和算法数量都在稳步增长。
- en: Originally, AndroidOpenSSL was only used to implement SSL sockets, but as of
    Android 4.4, it covers most of the functionality offered by Bouncy Castle. Because
    it is the preferred provider (with the highest priority, 1), engine classes that
    don’t explicitly request Bouncy Castle get an implementation from the AndroidOpenSSL
    provider. As the name implies, its cryptographic functionality is provided by
    the OpenSSL library. The provider implementation uses JNI to link OpenSSL’s native
    code to the Java SPI classes required to implement a JCA provider. The bulk of
    the implementation is in the `NativeCrypto` Java class, which is called by most
    SPI classes.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 最初，AndroidOpenSSL 仅用于实现 SSL 套接字，但从 Android 4.4 开始，它涵盖了 Bouncy Castle 提供程序提供的大部分功能。由于它是首选提供程序（具有最高优先级，1），因此那些没有明确请求
    Bouncy Castle 的引擎类会从 AndroidOpenSSL 提供程序获取实现。顾名思义，它的加密功能由 OpenSSL 库提供。提供程序实现通过
    JNI 将 OpenSSL 的本地代码与实现 JCA 提供程序所需的 Java SPI 类连接起来。大部分实现位于 `NativeCrypto` Java
    类中，该类被大多数 SPI 类调用。
- en: AndroidOpenSSL is part of Android’s *libcore* library, which implements the
    core part of Android’s Java runtime library. Starting with Android 4.4, AndroidOpenSSL
    has been decoupled from *libcore* so that it can be compiled as a standalone library
    and included in applications that want a stable cryptographic implementation that
    does not depend on the platform version. The standalone provider is called *Conscrypt*
    and lives in the `org.conscrypt` package, renamed to `com.android.org.conscrypt`
    when built as part of the Android platform.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: AndroidOpenSSL 是 Android *libcore* 库的一部分，该库实现了 Android Java 运行时库的核心部分。从 Android
    4.4 开始，AndroidOpenSSL 已与 *libcore* 解耦，以便可以作为独立库进行编译，并包含在需要稳定加密实现且不依赖于平台版本的应用程序中。独立提供程序名为
    *Conscrypt*，并位于 `org.conscrypt` 包中，当作为 Android 平台的一部分构建时，该包重命名为 `com.android.org.conscrypt`。
- en: The engine classes and algorithms supported by the AndroidOpenSSL provider as
    of version 4.4.4 are listed in [Table 5-3](ch05.html#algorithms_supported_by_the_androidopens
    "Table 5-3. Algorithms Supported by the AndroidOpenSSL Provider as of Android
    4.4.4").
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: AndroidOpenSSL 提供程序在 4.4.4 版本中支持的引擎类和算法列在[表 5-3](ch05.html#algorithms_supported_by_the_androidopens
    "表 5-3. AndroidOpenSSL 提供程序在 Android 4.4.4 版本中支持的算法")中。
- en: Table 5-3. Algorithms Supported by the AndroidOpenSSL Provider as of Android
    4.4.4
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 表 5-3. AndroidOpenSSL 提供程序在 Android 4.4.4 版本中支持的算法
- en: '| Engine Class Name | Supported Algorithms |'
  id: totrans-243
  prefs: []
  type: TYPE_TB
  zh: '| 引擎类名称 | 支持的算法 |'
- en: '| --- | --- |'
  id: totrans-244
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `CertificateFactory` | *X509* |'
  id: totrans-245
  prefs: []
  type: TYPE_TB
  zh: '| `CertificateFactory` | *X509* |'
- en: '| `Cipher` | *AES/CBC/NoPadding**AES/CBC/PKCS5Padding**AES/CFB/NoPadding**AES/CTR/NoPadding**AES/ECB/NoPadding**AES/ECB/PKCS5Padding**AES/OFB/NoPadding**ARC4**DESEDE/CBC/NoPadding**DESEDE/CBC/PKCS5Padding**DESEDE/CFB/NoPadding**DESEDE/ECB/NoPadding**DESEDE/ECB/PKCS5Padding**DESEDE/OFB/NoPadding**RSA/ECB/NoPadding**RSA/ECB/PKCS1Padding*
    |'
  id: totrans-246
  prefs: []
  type: TYPE_TB
  zh: '| `Cipher` | *AES/CBC/NoPadding**AES/CBC/PKCS5Padding**AES/CFB/NoPadding**AES/CTR/NoPadding**AES/ECB/NoPadding**AES/ECB/PKCS5Padding**AES/OFB/NoPadding**ARC4**DESEDE/CBC/NoPadding**DESEDE/CBC/PKCS5Padding**DESEDE/CFB/NoPadding**DESEDE/ECB/NoPadding**DESEDE/ECB/PKCS5Padding**DESEDE/OFB/NoPadding**RSA/ECB/NoPadding**RSA/ECB/PKCS1Padding*
    |'
- en: '| `KeyAgreement` | *ECDH* |'
  id: totrans-247
  prefs: []
  type: TYPE_TB
  zh: '| `KeyAgreement` | *ECDH* |'
- en: '| `KeyFactory` | *DSA**EC**RSA* |'
  id: totrans-248
  prefs: []
  type: TYPE_TB
  zh: '| `KeyFactory` | *DSA**EC**RSA* |'
- en: '| `KeyPairGenerator` | *DSA**EC**RSA* |'
  id: totrans-249
  prefs: []
  type: TYPE_TB
  zh: '| `KeyPairGenerator` | *DSA**EC**RSA* |'
- en: '| `Mac` | *HmacMD5**HmacSHA1**HmacSHA256**HmacSHA384**HmacSHA512* |'
  id: totrans-250
  prefs: []
  type: TYPE_TB
  zh: '| `Mac` | *HmacMD5**HmacSHA1**HmacSHA256**HmacSHA384**HmacSHA512* |'
- en: '| `MessageDigest` | *MD5**SHA-1**SHA-256**SHA-384**SHA-512* |'
  id: totrans-251
  prefs: []
  type: TYPE_TB
  zh: '| `MessageDigest` | *MD5**SHA-1**SHA-256**SHA-384**SHA-512* |'
- en: '| `SecureRandom` | *SHA1PRNG* |'
  id: totrans-252
  prefs: []
  type: TYPE_TB
  zh: '| `SecureRandom` | *SHA1PRNG* |'
- en: '| `Signature` | *ECDSA**MD5WithRSA**NONEwithRSA**SHA1WithRSA**SHA1withDSA**SHA256WithRSA**SHA256withECDSA**SHA384WithRSA**SHA384withECDSA**SHA512WithRSA**SHA512withECDSA*
    |'
  id: totrans-253
  prefs: []
  type: TYPE_TB
  zh: '| `Signature` | *ECDSA**MD5WithRSA**NONEwithRSA**SHA1WithRSA**SHA1withDSA**SHA256WithRSA**SHA256withECDSA**SHA384WithRSA**SHA384withECDSA**SHA512WithRSA**SHA512withECDSA*
    |'
- en: OpenSSL
  id: totrans-254
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: OpenSSL
- en: OpenSSL is an open source cryptographic toolkit that implements the SSL and
    TLS protocols and is widely used as a general purpose cryptography library.^([[54](#ftn.ch05fn17)])
    It is included in Android as a system library and used to implement the AndroidOpenSSL
    JCA provider that was introduced in “[AndroidOpenSSL Provider](ch05.html#androidopenssl_provider
    "AndroidOpenSSL Provider")”, as well as by some other system components.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: OpenSSL 是一个开源加密工具包，实施了 SSL 和 TLS 协议，并被广泛用作通用加密库。^([[54](#ftn.ch05fn17)]) 它作为系统库包含在
    Android 中，并用于实现 AndroidOpenSSL JCA 提供者，该提供者在 “[AndroidOpenSSL Provider](ch05.html#androidopenssl_provider
    "AndroidOpenSSL Provider")” 中引入，也被一些其他系统组件使用。
- en: Different Android releases use different OpenSSL versions (generally the latest
    stable version, which is 1.0.1e in Android 4.4), with an evolving set of patches
    applied. Therefore, Android does not offer a stable public OpenSSL API, so applications
    that need to use OpenSSL should include the library and not link to the system
    version. The only public cryptographic API is the JCA one, which offers a stable
    interface decoupled from the underlying implementation.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 不同的 Android 版本使用不同的 OpenSSL 版本（通常是最新的稳定版本，例如 Android 4.4 中的 1.0.1e），并应用了一系列的补丁。因此，Android
    并未提供稳定的公开 OpenSSL API，因此需要使用 OpenSSL 的应用程序应当包含该库，而不是链接到系统版本。唯一的公开加密 API 是 JCA
    API，它提供了一个稳定的接口，独立于底层实现。
- en: Using a Custom Provider
  id: totrans-257
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用自定义提供者
- en: While Android’s built-in providers cover most widely used cryptographic primitives,
    they do not support some more exotic algorithms and even some newer standards.
    As mentioned in our discussion of the JCA architecture, Android applications can
    register custom providers for their own use, but cannot affect system-wide providers.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管 Android 的内置提供者覆盖了大多数广泛使用的加密原语，但它们并不支持一些更为特殊的算法，甚至一些较新的标准。如在 JCA 架构讨论中所述，Android
    应用程序可以注册自定义提供者供自身使用，但无法影响系统范围内的提供者。
- en: One of the most widely used and full-featured JCA providers is Bouncy Castle,
    also the base of one of Android’s built-in providers. However, as discussed in
    [Android’s Bouncy Castle Provider](ch05.html#androidapostrophes_bouncy_castle_provide
    "Android’s Bouncy Castle Provider"), the version shipped with Android has had
    a number of algorithms removed. If you need to use any of those algorithms, you
    can try simply bundling the full Bouncy Castle library with your application—but
    that may cause class loading conflicts, especially on versions of Android earlier
    than 3.0, which do not change the system’s Bouncy Castle’s package name. To avoid
    this, you can change the library’s root package with a tool such as jarjar,^([[55](#ftn.ch05fn18)])
    or use Spongy Castle.^([[56](#ftn.ch05fn19)])
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: Bouncy Castle 是最广泛使用且功能最全的 JCA 提供者之一，也是 Android 内置提供者的基础。然而，如在 [Android’s Bouncy
    Castle Provider](ch05.html#androidapostrophes_bouncy_castle_provide "Android’s
    Bouncy Castle Provider") 中讨论的那样，Android 随附的版本已经移除了一些算法。如果你需要使用这些算法，可以尝试将完整的 Bouncy
    Castle 库直接捆绑到你的应用中——但这可能会导致类加载冲突，特别是在 Android 3.0 之前的版本中，因为它们不会更改系统 Bouncy Castle
    的包名称。为避免此问题，你可以使用 jarjar 等工具更改库的根包名，^([[55](#ftn.ch05fn18)]) 或者使用 Spongy Castle。^([[56](#ftn.ch05fn19)])
- en: Spongy Castle
  id: totrans-260
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Spongy Castle
- en: Spongy Castle is a repackaged version of Bouncy Castle. It moves all package
    names from `org.bouncycastle.*` to `org.spongycastle.*` in order to avoid class
    loader conflicts, and changes the provider name from *BC* to *SC*. No class names
    are changed, so the API is the same as Bouncy Castle. To use Spongy Castle, you
    simply need to register it with the JCA framework using `Security.addProvider()`
    or `Security.insertProviderAt()`. You can then request algorithms not implemented
    by Android’s built-in providers simply by passing the algorithm name to the respective
    `getInstance()` method.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: Spongy Castle 是 Bouncy Castle 的重新包装版本。它将所有的包名称从 `org.bouncycastle.*` 移动到 `org.spongycastle.*`，以避免类加载器冲突，并将提供者名称从
    *BC* 改为 *SC*。类名没有改变，因此 API 与 Bouncy Castle 相同。要使用 Spongy Castle，你只需通过 `Security.addProvider()`
    或 `Security.insertProviderAt()` 将其注册到 JCA 框架中。然后，你可以通过将算法名称传递给相应的 `getInstance()`
    方法，简单地请求 Android 内置提供者未实现的算法。
- en: To explicitly request an implementation from Spongy Castle, pass the *SC* string
    as the provider name. If you bundle the Spongy Castle library with your app, you
    can also directly use Bouncy Castle’s lightweight cryptographic API (which is
    often more flexible) without going through the JCA engine classes. Additionally,
    some cryptographic operations, such as signing an X.509 certificate or creating
    an S/MIME message, have no matching JCA APIs and can only be performed using the
    lower-level Bouncy Castle APIs.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 若要明确请求 Spongy Castle 提供程序的实现，可以将 *SC* 字符串作为提供程序名称。如果你将 Spongy Castle 库与应用打包在一起，你也可以直接使用
    Bouncy Castle 的轻量级加密 API（通常更灵活），而无需经过 JCA 引擎类。此外，某些加密操作，例如签署 X.509 证书或创建 S/MIME
    消息，并没有与之匹配的 JCA API，只能通过更低层次的 Bouncy Castle API 执行。
- en: '[Example 5-21](ch05.html#registering_and_using_the_spongy_castle "Example 5-21. Registering
    and using the Spongy Castle provider") shows how to register the Spongy Castle
    provider and request an RSA-PSS (originally defined in PKCS#1^([[57](#ftn.ch05fn20)]))
    `Signature` implementation, which is not supported by any of Android’s built-in
    JCA providers.'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 5-21](ch05.html#registering_and_using_the_spongy_castle "示例 5-21. 注册并使用
    Spongy Castle 提供程序") 显示了如何注册 Spongy Castle 提供程序并请求一个 RSA-PSS（最初在 PKCS#1^([[57](#ftn.ch05fn20)]))
    `Signature` 实现，该实现并未被 Android 内置的任何 JCA 提供程序所支持。'
- en: Example 5-21. Registering and using the Spongy Castle provider
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 5-21. 注册并使用 Spongy Castle 提供程序
- en: '[PRE20]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Summary
  id: totrans-266
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: Android implements the Java Cryptography Architecture (JCA) and comes bundled
    with a number of cryptographic providers. JCA defines interfaces to common cryptographic
    algorithms in the form of engine classes. Cryptographic providers offer implementations
    of those engine classes and allow clients to request an algorithm implementation
    by name, without having to know about the actual underlying implementation. The
    two main JCA providers in Android are the Bouncy Castle provider and the AndroidOpenSSL
    provider. Bouncy Castle is implemented in pure Java, while AndroidOpenSSL is backed
    by native code and offers better performance. As of Android 4.4, AndroidOpenSSL
    is the preferred JCA provider.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: Android 实现了 Java 加密体系结构（JCA），并自带多个加密提供程序。JCA 定义了以引擎类形式存在的常见加密算法的接口。加密提供程序提供这些引擎类的实现，并允许客户端按名称请求算法的实现，而无需了解实际的底层实现。Android
    中的两个主要 JCA 提供程序是 Bouncy Castle 提供程序和 AndroidOpenSSL 提供程序。Bouncy Castle 以纯 Java
    实现，而 AndroidOpenSSL 由本地代码支持，提供更好的性能。自 Android 4.4 起，AndroidOpenSSL 被视为首选的 JCA
    提供程序。
- en: '* * *'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: ^([[38](#ch05fn01)]) Oracle, *Java™ Cryptography Architecture Standard Algorithm
    Name Documentation*, *[http://docs.oracle.com/javase/7/docs/technotes/guides/security/StandardNames.html](http://docs.oracle.com/javase/7/docs/technotes/guides/security/StandardNames.html)*
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: ^([[38](#ch05fn01)]) Oracle, *Java™ 加密体系结构标准算法名称文档*, *[http://docs.oracle.com/javase/7/docs/technotes/guides/security/StandardNames.html](http://docs.oracle.com/javase/7/docs/technotes/guides/security/StandardNames.html)*
- en: ^([[39](#ch05fn02)]) Wikipedia, “Block cipher mode of operation,” *[https://en.wikipedia.org/wiki/Block_cipher_mode_of_operation](https://en.wikipedia.org/wiki/Block_cipher_mode_of_operation)*
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: ^([[39](#ch05fn02)]) 维基百科，“分组密码操作模式，” *[https://en.wikipedia.org/wiki/Block_cipher_mode_of_operation](https://en.wikipedia.org/wiki/Block_cipher_mode_of_operation)*
- en: ^([[40](#ch05fn03)]) The Android robot is reproduced or modified from work created
    and shared by Google and used according to terms described in the Creative Commons
    3.0 Attribution License.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: ^([[40](#ch05fn03)]) Android 机器人是由 Google 创作并共享的作品，按照 Creative Commons 3.0 署名许可协议的条款使用。
- en: ^([[41](#ch05fn04)]) D. McGrew, *RFC 5116 – An Interface and Algorithms for
    Authenticated Encryption*, *[http://www.ietf.org/rfc/rfc5116.txt](http://www.ietf.org/rfc/rfc5116.txt)*
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: ^([[41](#ch05fn04)]) D. McGrew, *RFC 5116 – 认证加密接口与算法*, *[http://www.ietf.org/rfc/rfc5116.txt](http://www.ietf.org/rfc/rfc5116.txt)*
- en: ^([[42](#ch05fn05)]) RSA Laboratories, *Public-Key Cryptography Standards (PKCS)*,
    *[http://www.emc.com/emc-plus/rsa-labs/standards-initiatives/public-key-cryptography-standards.htm](http://www.emc.com/emc-plus/rsa-labs/standards-initiatives/public-key-cryptography-standards.htm)*
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: ^([[42](#ch05fn05)]) RSA 实验室, *公钥加密标准（PKCS）*, *[http://www.emc.com/emc-plus/rsa-labs/standards-initiatives/public-key-cryptography-standards.htm](http://www.emc.com/emc-plus/rsa-labs/standards-initiatives/public-key-cryptography-standards.htm)*
- en: '^([[43](#ch05fn06)]) H. Krawczyk, M. Bellare, and R. Canetti, *HMAC: Keyed-Hashing
    for Message Authentication*, *[http://tools.ietf.org/html/rfc2104](http://tools.ietf.org/html/rfc2104)*'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: '^([[43](#ch05fn06)]) H. Krawczyk, M. Bellare, 和 R. Canetti, *HMAC: 基于密钥的消息认证哈希*,
    *[http://tools.ietf.org/html/rfc2104](http://tools.ietf.org/html/rfc2104)*'
- en: ^([[44](#ch05fn07)]) Hardware Security Module
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: ^([[44](#ch05fn07)]) 硬件安全模块
- en: '^([[45](#ch05fn08)]) B. Kaliski, *PKCS #5: Password-Based Cryptography Specification,
    Version 2.0*, *[http://www.ietf.org/rfc/rfc2898.txt](http://www.ietf.org/rfc/rfc2898.txt)*'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: '^([[45](#ch05fn08)]) B. Kaliski, *PKCS #5: 基于密码的密码学规范，版本 2.0*, *[http://www.ietf.org/rfc/rfc2898.txt](http://www.ietf.org/rfc/rfc2898.txt)*'
- en: '^([[46](#ch05fn09)]) RSA Laboratories, *PKCS #8: Private-Key Information Syntax
    Standard*, *[http://www.emc.com/emc-plus/rsa-labs/standards-initiatives/pkcs-8-private-key-information-syntax-stand.htm](http://www.emc.com/emc-plus/rsa-labs/standards-initiatives/pkcs-8-private-key-information-syntax-stand.htm)*'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: '^([[46](#ch05fn09)]) RSA 实验室, *PKCS #8: 私钥信息语法标准*, *[http://www.emc.com/emc-plus/rsa-labs/standards-initiatives/pkcs-8-private-key-information-syntax-stand.htm](http://www.emc.com/emc-plus/rsa-labs/standards-initiatives/pkcs-8-private-key-information-syntax-stand.htm)*'
- en: ^([[47](#ch05fn10)]) Some `Key` subclasses, such as `RSAPrivateKey`, expose
    all key material and thus are not technically opaque.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: ^([[47](#ch05fn10)]) 一些 `Key` 子类，诸如 `RSAPrivateKey`，暴露所有密钥材料，因此在技术上并不完全是封闭的。
- en: '^([[48](#ch05fn11)]) RSA Laboratories, *PKCS #3: Diffie-Hellman Key-Agreement
    Standard*, *[ftp://ftp.rsasecurity.com/pub/pkcs/ascii/pkcs-3.asc](ftp://ftp.rsasecurity.com/pub/pkcs/ascii/pkcs-3.asc)*'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: '^([[48](#ch05fn11)]) RSA 实验室, *PKCS #3: Diffie-Hellman 密钥协商标准*, *[ftp://ftp.rsasecurity.com/pub/pkcs/ascii/pkcs-3.asc](ftp://ftp.rsasecurity.com/pub/pkcs/ascii/pkcs-3.asc)*'
- en: ^([[49](#ch05fn12)]) NIST, *Recommendation for Pair-Wise Key Establishment Schemes
    Using Discrete Logarithm Cryptography*, *[http://csrc.nist.gov/publications/nistpubs/800-56A/SP800-56A_Revision1_Mar08-2007.pdf](http://csrc.nist.gov/publications/nistpubs/800-56A/SP800-56A_Revision1_Mar08-2007.pdf)*
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: ^([[49](#ch05fn12)]) NIST, *使用离散对数密码学的配对密钥建立方案建议*, *[http://csrc.nist.gov/publications/nistpubs/800-56A/SP800-56A_Revision1_Mar08-2007.pdf](http://csrc.nist.gov/publications/nistpubs/800-56A/SP800-56A_Revision1_Mar08-2007.pdf)*
- en: '^([[50](#ch05fn13)]) *Abstract Syntax Notation One (ASN.1)*: A standard notation
    that describes rules and structures for encoding data in telecommunications and
    computer networking. Extensively used in cryptography standards to define the
    structure of cryptographic objects.'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: '^([[50](#ch05fn13)]) *抽象语法表示法（ASN.1）*: 一种描述数据编码规则和结构的标准符号，广泛应用于电信和计算机网络中。广泛用于密码学标准中，以定义加密对象的结构。'
- en: ^([[51](#ch05fn14)]) D. Cooper et al., *Internet X.509 Public Key Infrastructure
    Certificate and Certificate Revocation List (CRL) Profile*, May 2008, *[http://tools.ietf.org/html/rfc5280](http://tools.ietf.org/html/rfc5280)*
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: ^([[51](#ch05fn14)]) D. Cooper 等, *互联网 X.509 公钥基础设施证书和证书吊销列表（CRL）规范*, 2008 年
    5 月, *[http://tools.ietf.org/html/rfc5280](http://tools.ietf.org/html/rfc5280)*
- en: ^([[52](#ch05fn15)]) The Apache Software Foundation, “Apache Harmony,” *[http://harmony.apache.org/](http://harmony.apache.org/)*
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: ^([[52](#ch05fn15)]) Apache 软件基金会, “Apache Harmony,” *[http://harmony.apache.org/](http://harmony.apache.org/)*
- en: ^([[53](#ch05fn16)]) Legion of the Bouncy Castle Inc., “Bouncy Castle Crypto
    APIs,” *[https://www.bouncycastle.org/java.html](https://www.bouncycastle.org/java.html)*
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: ^([[53](#ch05fn16)]) Bouncy Castle 公司, “Bouncy Castle 加密 API,” *[https://www.bouncycastle.org/java.html](https://www.bouncycastle.org/java.html)*
- en: '^([[54](#ch05fn17)]) The OpenSSL Project, “OpenSSL: The Open Source toolkit
    for SSL/TLS,” *[http://www.openssl.org/](http://www.openssl.org/)*'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: ^([[54](#ch05fn17)]) OpenSSL 项目, “OpenSSL：SSL/TLS 的开源工具包,” *[http://www.openssl.org/](http://www.openssl.org/)*
- en: ^([[55](#ch05fn18)]) Chris Nokleberg, “Jar Jar Links,” *[https://code.google.com/p/jarjar/](https://code.google.com/p/jarjar/)*
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: ^([[55](#ch05fn18)]) Chris Nokleberg, “Jar Jar Links,” *[https://code.google.com/p/jarjar/](https://code.google.com/p/jarjar/)*
- en: ^([[56](#ch05fn19)]) Roberto Tyley, “Spongy Castle,” *[http://rtyley.github.io/spongycastle/](http://rtyley.github.io/spongycastle/)*
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: ^([[56](#ch05fn19)]) Roberto Tyley, “Spongy Castle,” *[http://rtyley.github.io/spongycastle/](http://rtyley.github.io/spongycastle/)*
- en: '^([[57](#ch05fn20)]) J. Jonsson and B. Kaliski, *Public-Key Cryptography Standards
    (PKCS) #1: RSA Cryptography Specifications Version 2.1*, *[http://tools.ietf.org/html/rfc3447](http://tools.ietf.org/html/rfc3447)*'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: ^([[57](#ch05fn20)]) J. Jonsson 和 B. Kaliski, *公钥密码学标准（PKCS）#1：RSA 密码学规范版本 2.1*,
    *[http://tools.ietf.org/html/rfc3447](http://tools.ietf.org/html/rfc3447)*
