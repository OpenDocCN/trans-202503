- en: <hgroup>
  id: totrans-0
  prefs: []
  type: TYPE_NORMAL
  zh: <hgroup>
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">13</samp> <samp class="SANS_Dogma_OT_Bold_B_11">TLS</samp>
  id: totrans-1
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">13</samp> <samp class="SANS_Dogma_OT_Bold_B_11">TLS</samp>
- en: </hgroup>
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: </hgroup>
- en: '![](../images/opener.jpg)'
  id: totrans-3
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/opener.jpg)'
- en: The *Transport Layer Security (TLS) protocol* is the workhorse of internet security.
    TLS protects connections between servers and clients, whether between a website
    and its visitors, email servers, a mobile application and its servers, or video
    game servers and players. Without TLS, the internet wouldn’t be very secure.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: '*传输层安全（TLS）协议*是互联网安全的主力军。TLS保护服务器和客户端之间的连接，无论是网站与其访客之间、电子邮件服务器之间、移动应用程序与其服务器之间，还是视频游戏服务器与玩家之间。如果没有TLS，互联网将不会那么安全。'
- en: TLS is application agnostic, meaning you can use it for web-based applications
    that rely on the HTTP protocol, as well as for any system where a client computer
    or device needs to initiate a connection with a remote server. For example, TLS
    is widely used for machine-to-machine communications in internet of things (IoT)
    applications, such as smart refrigerators that communicate with remote servers.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: TLS与应用程序无关，意味着你可以将它用于依赖HTTP协议的基于Web的应用程序，也可以用于任何客户端计算机或设备需要与远程服务器建立连接的系统。例如，TLS广泛应用于物联网（IoT）应用中的机器对机器通信，如与远程服务器通信的智能冰箱。
- en: This chapter provides an abbreviated view of TLS, which has become increasingly
    complex over the years. Unfortunately, complexity and bloat brought multiple vulnerabilities,
    and bugs found in its cluttered implementations have made headlines—Heartbleed,
    BEAST, CRIME, and POODLE are all vulnerabilities that impacted millions of web
    servers.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 本章提供了TLS的简要概述，随着时间的推移，TLS变得越来越复杂。不幸的是，复杂性和臃肿带来了多个漏洞，其实现中的错误也屡次成为头条新闻——Heartbleed、BEAST、CRIME和POODLE都是影响了数百万个Web服务器的漏洞。
- en: <samp class="SANS_Dogma_OT_Bold_B_15">NOTE</samp>
  id: totrans-7
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: <samp class="SANS_Dogma_OT_Bold_B_15">注意</samp>
- en: '*You may see folks refer to TLS as* Secure Sockets Layer (SSL)*, which is the
    name of its predecessor.*'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: '*你可能会听到有人将TLS称为*安全套接字层（SSL）*，它是TLS的前身名称。*'
- en: In 2013, engineers started working on TLS 1.3\. As you’ll learn in this chapter,
    TLS 1.3 ditched unnecessary and insecure features and replaced old algorithms
    with then state-of-the-art ones. The result is a simpler, faster, and more secure
    protocol.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 2013年，工程师们开始着手开发TLS 1.3。如你在本章中将学到的，TLS 1.3摒弃了不必要且不安全的特性，用当时最先进的算法替代了旧算法，最终结果是一个更简洁、更快速、更安全的协议。
- en: Before we explore how TLS 1.3 works, let’s review the problem that TLS aims
    to solve and the reason for its existence.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们探讨TLS 1.3的工作原理之前，让我们回顾一下TLS旨在解决的问题以及它存在的原因。
- en: <samp class="SANS_Futura_Std_Bold_B_11">Target Applications and Requirements</samp>
  id: totrans-11
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">目标应用程序和要求</samp>
- en: TLS is the *S* in HTTPS websites, and the padlock that appears in a browser’s
    address bar indicates that a page is secure. The primary driver for creating TLS
    was to enable secure browsing in applications such as e-commerce or e-banking,
    by authenticating the site and encrypting traffic to protect sensitive information
    such as personal data, credit card numbers, and user credentials.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: TLS是HTTPS网站中的*S*，浏览器地址栏中出现的挂锁图标表示该页面是安全的。创建TLS的主要驱动力是通过认证站点并加密流量来实现安全浏览，保护个人数据、信用卡号码和用户凭证等敏感信息，广泛应用于电子商务和电子银行等领域。
- en: TLS also helps protect general internet-based communication by establishing
    a *secure channel* between a client and a server that ensures the data transferred
    is confidential, authenticated, and unmodified.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: TLS还通过在客户端和服务器之间建立一个*安全通道*来保护一般的基于互联网的通信，确保传输的数据是机密的、已验证的并且未经修改。
- en: One of TLS’s security goals is to prevent man-in-the-middle attacks, wherein
    an attacker intercepts encrypted traffic from the transmitting party, decrypts
    the traffic to capture the clear content, and reencrypts it to send to the receiving
    party. TLS defeats these attacks by authenticating servers (and optionally clients)
    using certificates and trusted certificate authorities, as we’ll discuss in “Certificates
    and Certificate Authorities” on [page 258](#sec5).
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: TLS的安全目标之一是防止中间人攻击，在这种攻击中，攻击者截获传输方的加密流量，解密流量以捕获明文内容，然后重新加密并发送给接收方。TLS通过使用证书和受信任的证书颁发机构来验证服务器（可选地验证客户端），从而防止这些攻击，具体内容将在“证书和证书颁发机构”一节中讨论，见[第258页](#sec5)。
- en: 'To ensure wide adoption, TLS needed to satisfy four more requirements: efficiency,
    interoperability, extensibility, and versatility. For TLS, efficiency means minimizing
    the performance penalty compared with unencrypted connections. This is good for
    both the server (to reduce the cost of hardware for the service providers) and
    the clients (to avoid perceptible delays or the reduction of the battery life
    of mobile devices). The protocol needed to be interoperable so that it would work
    on any hardware and any operating system. It was to be extensible so that it could
    support additional features or algorithms. And it had to be versatile—that is,
    not bound to a specific application. This parallels the Transport Control Protocol
    (TCP), which doesn’t care about the application protocol used on top of it.'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 为了确保广泛采用，TLS 需要满足四个额外的要求：效率、互操作性、可扩展性和多功能性。对于 TLS，效率意味着尽量减少与未加密连接相比的性能损失。这对服务器（减少服务提供商硬件成本）和客户端（避免明显的延迟或减少移动设备的电池寿命）都有好处。该协议需要具备互操作性，以便能够在任何硬件和任何操作系统上工作。它还必须具备可扩展性，以便支持额外的功能或算法。最后，它必须是多功能的——也就是说，不局限于某个特定的应用程序。这与传输控制协议（TCP）相似，TCP
    不关心其上层应用协议是什么。
- en: <samp class="SANS_Futura_Std_Bold_B_11">The TLS Protocol Suite</samp>
  id: totrans-16
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">TLS 协议套件</samp>
- en: To protect client-server communications, TLS consists of multiple versions of
    several protocols that form the TLS protocol *suite*. TLS is not a transport protocol
    and usually sits between the transport protocol (TCP) and an application layer
    protocol such as HTTP or SMTP, to secure data transmitted over a TCP connection.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 为了保护客户端和服务器之间的通信，TLS 由多个版本的几个协议组成，形成了 TLS 协议的 *套件*。TLS 不是一个传输协议，通常位于传输协议（TCP）和应用层协议（如
    HTTP 或 SMTP）之间，以加密通过 TCP 连接传输的数据。
- en: TLS also works over the *User Datagram Protocol (UDP)* transport protocol, which
    is used for “connectionless” transmissions when latency must be minimal, such
    as audio or video streaming and online gaming. However, unlike TCP, UDP doesn’t
    guarantee delivery or correct packet ordering. The UDP version of TLS, *Datagram
    Transport Layer Security (DTLS)*, is therefore slightly different. For more on
    TCP and UDP, see Charles Kozierok’s *The TCP/IP Guide* (No Starch Press, 2005).
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: TLS 也可以在 *用户数据报协议 (UDP)* 传输协议上工作，这通常用于“无连接”传输，尤其是在延迟必须最小化的场景中，如音频或视频流媒体以及在线游戏。然而，与
    TCP 不同，UDP 不保证数据的传输或正确的包排序。因此，TLS 的 UDP 版本——*数据报传输层安全协议 (DTLS)*——有所不同。关于 TCP 和
    UDP 的更多信息，请参见 Charles Kozierok 的 *《TCP/IP指南》*（No Starch Press，2005年）。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">The TLS and SSL Families
    of Protocols</samp>
  id: totrans-19
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">TLS 和 SSL 协议家族</samp>
- en: TLS began in 1995 when Netscape developed TLS’s ancestor, the SSL protocol.
    SSL was far from perfect, and both SSL 2.0 and SSL 3.0 had security flaws. You
    should never use SSL, and you should always use TLS—what adds to the confusion
    is that people often refer to TLS as SSL, including security experts.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: TLS 始于1995年，当时 Netscape 开发了 TLS 的前身——SSL 协议。SSL 远非完美，SSL 2.0 和 SSL 3.0 都存在安全漏洞。你永远不应该使用
    SSL，而应该始终使用 TLS——令人困惑的是，人们常常将 TLS 称为 SSL，包括安全专家。
- en: Not all versions of TLS are secure. TLS 1.0 (1999) is the least secure version,
    though it’s still more secure than SSL 3.0\. TLS 1.1 (2006) is better but includes
    a number of weak algorithms. TLS 1.2 (2008) is better yet, but it’s complex and
    provides high security only if configured correctly. Also, its complexity increases
    the risk of bugs in implementations and the risk of incorrect configurations.
    For example, TLS 1.2 supports AES in CBC mode, which is often vulnerable to padding
    oracle attacks.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 并非所有版本的 TLS 都是安全的。TLS 1.0（1999年）是最不安全的版本，尽管它比 SSL 3.0 更安全。TLS 1.1（2006年）更好，但包含了一些弱算法。TLS
    1.2（2008年）更好，但它复杂，只有在正确配置的情况下才能提供高安全性。此外，它的复杂性增加了实现中的错误风险和配置错误的风险。例如，TLS 1.2 支持
    AES 在 CBC 模式下，这常常容易受到填充 oracle 攻击。
- en: TLS 1.2 inherited dozens of features and design choices from earlier versions
    of TLS that make it suboptimal in terms of security and performance. To clean
    up this mess, cryptography engineers reinvented TLS—keeping only the good parts
    and adding security features. The result is TLS 1.3, an overhaul that’s simplified
    a bloated design and made it more secure, more efficient, and simpler. Essentially,
    TLS 1.3 is mature TLS.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: TLS 1.2 继承了 TLS 较早版本的数十个特性和设计选择，这使得其在安全性和性能方面并不理想。为了整顿这一混乱局面，密码学工程师重新设计了 TLS——只保留了优秀的部分并添加了安全功能。结果是
    TLS 1.3，这是一次全面革新，简化了臃肿的设计并提升了安全性和效率。本质上，TLS 1.3 是成熟的 TLS。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">TLS in a Nutshell</samp>
  id: totrans-23
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">TLS 简介</samp>
- en: 'TLS has two main protocols: the *handshake protocol* (or just *handshake*)
    determines the secret keys shared between the two parties; the *record protocol*
    describes how to use these keys to protect data. The data packets TLS processes
    are called *records*. TLS defines a packet format for encapsulating data from
    higher-layer protocols for transmission to another party.'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: TLS 有两个主要协议：*握手协议*（或简称*握手*）确定了双方共享的密钥；*记录协议*描述了如何使用这些密钥来保护数据。TLS 处理的数据包称为*记录*。TLS
    定义了一种封装来自更高层协议数据的数据包格式，以便传输到另一方。
- en: The handshake starts with a client that initiates a secure connection with a
    server. The client sends an initial message called ClientHello with parameters
    that include the cipher it wants to use. The server checks this message and its
    parameters and then responds with a ServerHello message. Once the client and the
    server process each other’s messages, they’re ready to exchange encrypted data
    using session keys established through the handshake protocol, as you’ll see in
    “The TLS Handshake Protocol” on [page 263](#sec10).
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 握手由启动安全连接的客户端开始。客户端发送一个称为 ClientHello 的初始消息，其中包含它希望使用的密码。服务器检查此消息及其参数，然后响应一个
    ServerHello 消息。一旦客户端和服务器处理彼此的消息，它们就可以使用通过握手协议建立的会话密钥交换加密数据，详见“TLS 握手协议”第[263页](#sec10)。
- en: '#### <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Certificates
    and Certificate Authorities</samp>'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: '#### <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">证书和证书颁发机构</samp>'
- en: The most critical step in the TLS handshake, and the crux of TLS’s security,
    is the *certificate validation step*, wherein a server uses a certificate to authenticate
    itself to a client.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: TLS 握手中最关键的步骤，也是 TLS 安全性的核心，是*证书验证步骤*，在此步骤中，服务器使用证书向客户端进行身份验证。
- en: A *certificate* is essentially a public key accompanied by a signature of that
    key and associated information (including the domain name). For example, when
    connecting to *[https://<wbr>www<wbr>.google<wbr>.com](https://www.google.com)*,
    your browser receives a certificate from some network host and then verifies the
    certificate’s signature, which reads something like “I am *google.com*, and my
    public key is [*key*].” If the signature is verified, the certificate and its
    public key are *trusted*, and the browser proceeds with establishing the connection.
    (See [Chapters 10](chapter10.xhtml) and [12](chapter12.xhtml) for details regarding
    signatures.)
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: '*证书*本质上是一对公钥及其签名以及相关信息（包括域名）。例如，当连接到*[https://<wbr>www<wbr>.google<wbr>.com](https://www.google.com)*时，您的浏览器从某个网络主机接收证书，然后验证证书的签名，其内容类似于“我是*google.com*，我的公钥是[*key*]”。如果签名验证成功，证书及其公钥就是*受信任的*，浏览器会继续建立连接。（有关签名的详细信息，请参阅[第10章](chapter10.xhtml)和[第12章](chapter12.xhtml)。）'
- en: The browser knows the public key needed to verify the signature through a *certificate
    authority (CA)*, which is essentially a public key hardcoded in your browser or
    operating system. The public key’s private key (that is, its signing capability)
    belongs to a trusted organization that ensures the public keys in certificates
    it issues belong to the website or entity that claims them. That is, a CA acts
    as a *trusted third party*. Without CAs, there’s no way to verify that the public
    key served by *google.com* belongs to Google and not to an eavesdropper performing
    a man-in-the-middle attack.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 浏览器通过*证书颁发机构（CA）*知道用于验证签名的公钥，这本质上是在浏览器或操作系统中硬编码的公钥。公钥的私钥（即其签名能力）属于一个受信任的组织，该组织确保其签发的证书中的公钥属于声称拥有它们的网站或实体。换句话说，CA
    充当*受信任的第三方*。如果没有 CA，就无法验证由*google.com*提供的公钥是否属于 Google 而不是中间人进行的中间人攻击。
- en: For example, [Listing 13-1](chapter13.xhtml#Lis13-1) shows what happens when
    you use the OpenSSL command line tool to initiate a TLS connection to *www.google.com*
    on port 443, the network port used for TLS-based HTTP connections (HTTPS).
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，[清单 13-1](chapter13.xhtml#Lis13-1)展示了当你使用 OpenSSL 命令行工具在 443 端口发起到 *www.google.com*
    的 TLS 连接时会发生什么，443 端口是用于基于 TLS 的 HTTP 连接（HTTPS）的网络端口。
- en: '[PRE0]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 13-1: Establishing
    a TLS connection with</samp> <samp class="SANS_Futura_Std_Book_11">[www<wbr>.google<wbr>.com](http://www.google.com)</samp>
    <samp class="SANS_Futura_Std_Book_Oblique_I_11">and receiving certificates to
    authenticate the connection</samp>'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">清单 13-1：与</samp> <samp class="SANS_Futura_Std_Book_11">[www<wbr>.google<wbr>.com](http://www.google.com)</samp>
    <samp class="SANS_Futura_Std_Book_Oblique_I_11">建立 TLS 连接并接收证书以验证连接</samp>
- en: The certificate data is between the <samp class="SANS_TheSansMonoCd_W5Regular_11">BEGIN
    CERTIFICATE</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">END CERTIFICATE</samp>
    markers. Before this, the <samp class="SANS_TheSansMonoCd_W5Regular_11">Certificate
    chain</samp> contains a description of the certificate chain, wherein the lines
    beginning with <samp class="SANS_TheSansMonoCd_W5Regular_11">s:</samp> describe
    the *subject* of the certified entity, and the lines beginning with <samp class="SANS_TheSansMonoCd_W5Regular_11">i:</samp>
    describe the *issuer* of the signature. Certificate number 0 is received by *[www<wbr>.google<wbr>.com](http://www.google.com)*,
    certificate 1 belongs to the entity that signed certificate 0, and certificate
    2 belongs to the entity that signed certificate 1.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 证书数据位于 <samp class="SANS_TheSansMonoCd_W5Regular_11">BEGIN CERTIFICATE</samp>
    和 <samp class="SANS_TheSansMonoCd_W5Regular_11">END CERTIFICATE</samp> 标记之间。在此之前，<samp
    class="SANS_TheSansMonoCd_W5Regular_11">证书链</samp> 包含证书链的描述，其中以 <samp class="SANS_TheSansMonoCd_W5Regular_11">s:</samp>
    开头的行描述了经认证实体的 *主题*，以 <samp class="SANS_TheSansMonoCd_W5Regular_11">i:</samp> 开头的行描述了签名的
    *颁发者*。证书 0 是 *[www<wbr>.google<wbr>.com](http://www.google.com)* 收到的，证书 1 属于签署证书
    0 的实体，证书 2 属于签署证书 1 的实体。
- en: The organization that issued certificate 0 is Google (via the Google Trust Services
    entity, GTS), which authorized the issuance of certificate 0 for the domain name
    *[www<wbr>.google<wbr>.com](http://www.google.com)* by signing the certificate
    with the private key GTS CA 1C3\. The certificate attesting that this key belongs
    to the Google key hierarchy is certificate 1, which is signed by the GTS key Root
    R1, a root certificate within Google. Certificate 2, issued by GlobalSign (a recognized
    certification authority), attests that the GTS Root R1 key belongs to the Google
    organization.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 颁发证书 0 的组织是 Google（通过 Google Trust Services 实体，GTS），它授权颁发证书 0 给域名 *[www<wbr>.google<wbr>.com](http://www.google.com)*，并使用私钥
    GTS CA 1C3 对证书进行签名。证明该密钥属于 Google 密钥层次结构的证书是证书 1，它由 Google 内的根证书 GTS Root R1 签名。证书
    2 由 GlobalSign（一个公认的认证机构）颁发，证明 GTS Root R1 密钥属于 Google 组织。
- en: 'In this example, your operating system usually already has certificates 1 and
    2, which it considers trusted certificates. In such a case, you just need to check
    two signatures: Google’s GTS CA 1C3 entity in certificate 0 and Google’s GTS Root
    R1 entity in certificate 1\. If your system doesn’t already include certificate
    2 as a trusted certificate but has GlobalSign’s root certificate (GlobalSign Root
    CA), then you’ll also need to check GlobalSign’s signature in certificate 2.'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，你的操作系统通常已经有证书 1 和证书 2，并将其视为受信任的证书。在这种情况下，你只需要验证两个签名：证书 0 中的 Google GTS
    CA 1C3 实体签名和证书 1 中的 Google GTS Root R1 实体签名。如果你的系统尚未将证书 2 作为受信任证书，但却包含了 GlobalSign
    的根证书（GlobalSign Root CA），那么你还需要验证证书 2 中的 GlobalSign 签名。
- en: Certificate authority organizations such as Google and GlobalSign must be trustworthy
    and issue certificates only to trustworthy entities, and they must protect their
    private keys in order to prevent an attacker from issuing certificates on their
    behalf (for example, to impersonate a legitimate *[www<wbr>.google<wbr>.com](http://www.google.com)*
    server).
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 证书颁发机构如 Google 和 GlobalSign 必须是可信的，只会向可信实体颁发证书，并且必须保护其私钥，以防止攻击者代表它们颁发证书（例如，伪装成合法的
    *[www<wbr>.google<wbr>.com](http://www.google.com)* 服务器）。
- en: To see what’s in a certificate, enter the command <samp class="SANS_TheSansMonoCd_W7Bold_B_11">openssl
    x509 -text -noout</samp> in a Unix terminal and then paste the certificate in
    [Listing 13-1](chapter13.xhtml#Lis13-1). The output appears in [Listing 13-2](chapter13.xhtml#Lis13-2).
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 要查看证书内容，可以在 Unix 终端中输入命令 <samp class="SANS_TheSansMonoCd_W7Bold_B_11">openssl
    x509 -text -noout</samp>，然后将证书粘贴到 [列表 13-1](chapter13.xhtml#Lis13-1) 中。输出将显示在
    [列表 13-2](chapter13.xhtml#Lis13-2) 中。
- en: '[PRE1]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 13-2: Decoding a certificate
    received from</samp> <samp class="SANS_Futura_Std_Book_11">[www<wbr>.google<wbr>.com](http://www.google.com)</samp>'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">列表 13-2：解码从</samp> <samp class="SANS_Futura_Std_Book_11">[www<wbr>.google<wbr>.com](http://www.google.com)</samp>
    接收到的证书
- en: This listing shows the command <samp class="SANS_TheSansMonoCd_W5Regular_11">openssl
    x509</samp> decoding a certificate, originally provided as a block of base64-encoded
    data. Because OpenSSL knows the structure of this data, it can tell you what’s
    inside the certificate, including a serial number and version information, identifying
    information, validity dates (the <samp class="SANS_TheSansMonoCd_W5Regular_11">Not
    Before</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">Not After</samp>
    lines), a public key (here as an RSA modulus and its public exponent), and a signature
    of the preceding information.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 本列表展示了命令 <samp class="SANS_TheSansMonoCd_W5Regular_11">openssl x509</samp> 解码证书，证书最初以一块
    base64 编码的数据形式提供。由于 OpenSSL 知道这些数据的结构，它可以告诉你证书中的内容，包括序列号、版本信息、标识信息、有效期（<samp class="SANS_TheSansMonoCd_W5Regular_11">Not
    Before</samp> 和 <samp class="SANS_TheSansMonoCd_W5Regular_11">Not After</samp>
    行）、公钥（这里是 RSA 模数及其公钥指数），以及前述信息的签名。
- en: Although security experts and cryptographers often claim the whole certificate
    system is inherently broken, it’s one of the best solutions we have, along with
    the trust-on-first-use (TOFU) policy adopted by SSH, for example.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管安全专家和密码学家经常声称整个证书系统本质上是有缺陷的，但它仍然是我们所拥有的最佳解决方案之一，例如 SSH 采用的“首次使用信任”（TOFU）策略。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">The Record Protocol</samp>
  id: totrans-42
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">记录协议</samp>
- en: All data exchanged through TLS 1.3 communications is transmitted as sequences
    of TLS records, the data packets used by TLS. The TLS record protocol (the *record
    layer*) is essentially a transport protocol, agnostic of the transported data’s
    meaning; this makes TLS suitable for any application.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 通过 TLS 1.3 通信交换的所有数据都以 TLS 记录的序列传输，TLS 使用的数据包。TLS 记录协议（即*记录层*）本质上是一个传输协议，与传输数据的意义无关；这使得
    TLS 适用于任何应用。
- en: The TLS record protocol first carries the data exchanged during the handshake.
    Once the handshake is complete and both parties share a secret key, application
    data is fragmented into chunks that transmit as part of the TLS records.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: TLS 记录协议首先传输在握手过程中交换的数据。一旦握手完成且双方共享一个秘密密钥，应用数据将被分段并作为 TLS 记录的一部分进行传输。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">The Structure of a TLS Record</samp>
  id: totrans-45
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">TLS 记录的结构</samp>
- en: 'A TLS record is a chunk of data of at most 16KB with the following structure:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 一个 TLS 记录是一个最多为 16KB 的数据块，具有以下结构：
- en: The first byte represents the type of data transmitted and is set to the value
    <samp class="SANS_TheSansMonoCd_W5Regular_11">22</samp> for handshake data, <samp
    class="SANS_TheSansMonoCd_W5Regular_11">23</samp> for encrypted data, and <samp
    class="SANS_TheSansMonoCd_W5Regular_11">21</samp> for alerts. The TLS 1.3 specifications
    call this value ContentType.
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第一个字节表示传输数据的类型，并设置为值 <samp class="SANS_TheSansMonoCd_W5Regular_11">22</samp>
    以表示握手数据，<samp class="SANS_TheSansMonoCd_W5Regular_11">23</samp> 以表示加密数据，<samp
    class="SANS_TheSansMonoCd_W5Regular_11">21</samp> 以表示警报。TLS 1.3 规范将此值称为 ContentType。
- en: The second and third bytes are set to <samp class="SANS_TheSansMonoCd_W5Regular_11">03</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">01</samp>, respectively. These
    bytes are fixed for historical reasons and aren’t unique to TLS version 1.3\.
    The specifications call this 2-byte value ProtocolVersion.
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第二个和第三个字节分别设置为 <samp class="SANS_TheSansMonoCd_W5Regular_11">03</samp> 和 <samp
    class="SANS_TheSansMonoCd_W5Regular_11">01</samp>。这些字节是出于历史原因而固定的，并且并非 TLS 1.3
    版本所特有。规范将此 2 字节值称为 ProtocolVersion。
- en: The fourth and fifth bytes encode the length of the data to transmit as a 16-bit
    integer, which can be no larger than 2^(14) bytes (16KB).
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第四个和第五个字节对要传输的数据的长度进行编码，作为一个 16 位整数，长度不能大于 2^(14) 字节（16KB）。
- en: The rest of the bytes are the data to transmit (or the *payload*), of a length
    equal to the value encoded by the record’s fourth and fifth bytes.
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 剩余的字节是要传输的数据（或*负载*），其长度等于记录第四和第五个字节所编码的值。
- en: <samp class="SANS_Dogma_OT_Bold_B_15">NOTE</samp>
  id: totrans-51
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: <samp class="SANS_Dogma_OT_Bold_B_15">注意</samp>
- en: '*A TLS record has a relatively simple structure. As you’ve seen, a TLS record’s
    header includes only three fields. For comparison, an IPv4 packet includes 14
    fields before its payload, and a TCP segment includes 13 fields.*'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: '*TLS 记录有一个相对简单的结构。如你所见，TLS 记录的头部仅包含三个字段。相比之下，IPv4 数据包在负载之前包含 14 个字段，TCP 段包含
    13 个字段。*'
- en: 'When the first byte of a TLS 1.3 record (ContentType) is set to <samp class="SANS_TheSansMonoCd_W5Regular_11">23</samp>,
    an authenticated cipher encrypts and authenticates its payload. The payload consists
    of a ciphertext followed by an authentication tag, which the receiving end, respectively,
    decrypts and verifies. The recipient knows which cipher and key to decrypt with,
    thanks to the magic of TLS: if you receive an encrypted TLS record, you already
    know the cipher and key because executing the handshake protocol establishes them.'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 当 TLS 1.3 记录的第一个字节（ContentType）设置为 <samp class="SANS_TheSansMonoCd_W5Regular_11">23</samp>
    时，经过身份验证的加密算法对负载进行加密和认证。负载包括密文和随后的认证标签，接收端分别对其进行解密和验证。接收者知道使用哪种加密算法和密钥进行解密，这是
    TLS 协议的魔力：如果你接收到一个加密的 TLS 记录，你已经知道了加密算法和密钥，因为执行握手协议时已建立这些信息。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">Nonces</samp>
  id: totrans-54
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">随机数</samp>
- en: Unlike many other protocols, such as IPsec’s Encapsulating Security Payload
    (ESP), TLS records don’t specify the nonce the authenticated cipher will use.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 与许多其他协议不同，例如 IPsec 的封装安全负载（ESP），TLS 记录没有指定认证加密算法将使用的随机数。
- en: The nonces that encrypt and decrypt TLS records are derived from 64-bit sequence
    numbers, maintained locally by each party and incremented for each new record.
    When the client encrypts data, it derives a nonce by XORing the sequence number
    with a <samp class="SANS_TheSansMonoCd_W5Regular_11">client_write_iv</samp> value,
    itself derived from the shared secret. The server uses a similar method to choose
    nonces when transmitting data, but with a <samp class="SANS_TheSansMonoCd_W5Regular_11">server_write_iv</samp>
    value.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 加密和解密 TLS 记录的随机数（nonce）源自 64 位的序列号，由每一方本地维护，并在每个新记录中递增。当客户端加密数据时，它通过将序列号与 <samp
    class="SANS_TheSansMonoCd_W5Regular_11">client_write_iv</samp> 值（本身源自共享密钥）进行异或操作来生成一个随机数。服务器在传输数据时使用类似的方法选择随机数，但使用的是
    <samp class="SANS_TheSansMonoCd_W5Regular_11">server_write_iv</samp> 值。
- en: For example, if you transmit three TLS records, you’ll derive a nonce from 0
    for the first record, from 1 for the second, and from 2 for the third; if you
    then receive three records, you’ll also use nonces 0, 1, and 2, in this order.
    Reusing the same sequence numbers values for encrypting transmitted data and decrypting
    receiving data isn’t a weakness because they’re XORed with different constants
    (<samp class="SANS_TheSansMonoCd_W5Regular_11">client_write_iv</samp> and <samp
    class="SANS_TheSansMonoCd_W5Regular_11">server_write_iv</samp>) and because you
    use different secret keys for each direction.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果你传输三个 TLS 记录，你将从第一个记录推导出随机数 0，从第二个记录推导出随机数 1，从第三个记录推导出随机数 2；如果随后接收三个记录，你也将按此顺序使用随机数
    0、1 和 2。重新使用相同的序列号值加密传输数据并解密接收数据并不是一个弱点，因为它们与不同的常量（<samp class="SANS_TheSansMonoCd_W5Regular_11">client_write_iv</samp>
    和 <samp class="SANS_TheSansMonoCd_W5Regular_11">server_write_iv</samp>）进行异或操作，而且每个方向使用不同的密钥。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">The Zero Padding Feature</samp>
  id: totrans-58
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">零填充功能</samp>
- en: TLS 1.3 records support *zero padding*, which mitigates traffic analysis attacks.
    Attackers use *traffic analysis* to extract information from traffic patterns
    using timing, volume of data transferred, and so on. For example, because ciphertexts
    are approximately the same size as plaintexts, even when using strong encryption,
    attackers can determine the approximate size of messages by simply looking at
    the length of their ciphertext.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: TLS 1.3 记录支持*零填充*，这有助于缓解流量分析攻击。攻击者通过*流量分析*利用传输数据的时序、数据量等特征，从流量模式中提取信息。例如，即使在使用强加密的情况下，由于密文和明文的大小大致相同，攻击者仅通过观察密文的长度，就可以推测消息的大致大小。
- en: Zero padding adds zeros to the plaintext to inflate the ciphertext’s size, fooling
    observers into thinking that an encrypted message is longer than it really is.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 零填充通过向明文中添加零来增加密文的大小，从而欺骗观察者认为加密后的消息比实际长度要长。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">The TLS Handshake
    Protocol</samp>
  id: totrans-61
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">TLS握手协议</samp>
- en: The handshake is the crux of the TLS agreement protocol—the process by which
    a client and a server establish shared secret keys to initiate secure communications.
    During a TLS handshake, the client and the server play different roles. The client
    proposes some configurations (the TLS version and a suite of ciphers, in order
    of preference), and the server chooses the configuration it will use. The server
    should follow the client’s preferences. To ensure interoperability between implementations
    and that any server implementing TLS 1.3 will be able to read TLS 1.3 data sent
    by any client implementing TLS 1.3 (even if it’s using a different library or
    programming language), the TLS 1.3 specifications also describe the format data
    should be sent in.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 握手是TLS协议的核心——这是客户端和服务器建立共享秘密密钥以开始安全通信的过程。在TLS握手期间，客户端和服务器扮演不同的角色。客户端提出一些配置（TLS版本和一组密码套件，按优先顺序排列），服务器选择它将使用的配置。服务器应遵循客户端的偏好。为了确保不同实现之间的互操作性，并确保任何实现TLS
    1.3的服务器都能读取任何实现TLS 1.3的客户端发送的数据（即使它使用的是不同的库或编程语言），TLS 1.3规范还描述了数据应该以何种格式发送。
- en: '[Figure 13-1](chapter13.xhtml#fig13-1) shows how the handshake process exchanges
    data, as the TLS 1.3 specifications describe.'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: '[图13-1](chapter13.xhtml#fig13-1)展示了握手过程如何交换数据，如TLS 1.3规范所描述。'
- en: '![](../images/fig13-1.jpg)'
  id: totrans-64
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/fig13-1.jpg)'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 13-1: The TLS 1.3 handshake
    process</samp>'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">图13-1：TLS 1.3握手过程</samp>
- en: In the TLS 1.3 handshake, the client sends a message to the server saying, “I
    want to establish a TLS connection with you. Here are the ciphers that I support
    to encrypt TLS records, and here is a Diffie–Hellman public key.” The public key
    must be generated specifically for this TLS session, and the client keeps the
    associated private key. The message sent by the client also includes a 32-byte
    random value and optional information (such as additional parameters). This first
    message, *ClientHello*, must follow a specific format when transmitted as a series
    of bytes, as the TLS 1.3 specification defines.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 在TLS 1.3握手中，客户端向服务器发送一条消息，内容是：“我想与你建立TLS连接。这里是我支持的用于加密TLS记录的密码算法，还有一个Diffie–Hellman公钥。”该公钥必须专门为此TLS会话生成，客户端保留与之对应的私钥。客户端发送的消息还包括一个32字节的随机值和可选信息（如附加参数）。这条初始消息，*ClientHello*，在作为一系列字节传输时必须遵循特定的格式，如TLS
    1.3规范所定义的。
- en: The server receives the ClientHello message, verifies that it’s correctly formatted,
    and responds with a ServerHello message, which is loaded with information. Typically,
    when connecting to an HTTPS website, it contains the cipher that will encrypt
    TLS records, a Diffie–Hellman public key, a 32-byte random value (discussed in
    “Downgrade Protection” on [page 266](#sec13)), a certificate, a signature of all
    the previous information in ClientHello and ServerHello messages (computed using
    the private key associated with the certificate’s public key), and a MAC of that
    same information, plus the signature. The MAC is computed using a symmetric key
    derived from the Diffie–Hellman shared secret, which the server computes from
    its Diffie–Hellman private key and the client’s public key.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 服务器接收到ClientHello消息后，验证其格式是否正确，并响应一个包含丰富信息的ServerHello消息。通常，当连接到HTTPS网站时，该消息包含将用于加密TLS记录的密码算法、Diffie–Hellman公钥、一个32字节的随机值（在“降级保护”一节中讨论，见[第266页](#sec13)）、证书、ClientHello和ServerHello消息中所有先前信息的签名（使用与证书公钥关联的私钥计算），以及该信息的MAC值，外加签名。MAC是使用从Diffie–Hellman共享秘密派生的对称密钥计算的，服务器通过其Diffie–Hellman私钥和客户端公钥计算出该共享秘密。
- en: When the client receives the ServerHello message, it verifies the certificate’s
    validity, verifies the signature, computes the shared Diffie–Hellman secret and
    derives symmetric keys from it, and verifies the MAC sent by the server. Once
    everything is verified, the client is ready to send encrypted messages to the
    server.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 当客户端收到ServerHello消息时，它验证证书的有效性，验证签名，计算共享的Diffie–Hellman秘密，并从中派生对称密钥，同时验证服务器发送的MAC。一旦所有内容都验证无误，客户端就准备好向服务器发送加密消息。
- en: <samp class="SANS_Dogma_OT_Bold_B_15">NOTE</samp>
  id: totrans-69
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: <samp class="SANS_Dogma_OT_Bold_B_15">注意</samp>
- en: '*TLS 1.3 supports many options and extensions, so it may behave differently.
    You can, for example, configure the TLS 1.3 handshake to require a client certificate
    so that the server verifies the identity of the client. TLS 1.3 also supports
    a handshake with preshared keys.*'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: '*TLS 1.3 支持许多选项和扩展，因此它可能表现得不同。例如，你可以配置 TLS 1.3 握手，要求客户端证书，以便服务器验证客户端的身份。TLS
    1.3 还支持使用预共享密钥的握手方式。*'
- en: Let’s look at this in practice. Say you’ve deployed TLS 1.3 to provide secure
    access to the website *[https://<wbr>www<wbr>.nostarch<wbr>.com](https://www.nostarch.com)*.
    When you point your browser (the client) to this site, your browser sends a ClientHello
    message to the site’s server that includes the ciphers that it supports. The website
    responds with a ServerHello message and a certificate that includes a public key
    associated with the domain *[www<wbr>.nostarch<wbr>.com](http://www.nostarch.com)*.
    The client verifies the certificate’s validity using one of the certificate authorities
    embedded in the browser (a trusted certificate authority, whose certificate should
    be included in the browser’s or the operating system’s certificate store to be
    validated, should sign the received certificate). Once all checks pass, the browser
    requests the site’s initial page from the *[www<wbr>.nostarch<wbr>.com](http://www.nostarch.com)*
    server.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看实际操作中的情况。假设你已经部署了 TLS 1.3 来提供对网站 *[https://<wbr>www<wbr>.nostarch<wbr>.com](https://www.nostarch.com)*
    的安全访问。当你将浏览器（客户端）指向这个网站时，浏览器会向网站的服务器发送一个 ClientHello 消息，其中包含它支持的加密算法。网站会用一个 ServerHello
    消息和一个包含与该域名 *[www<wbr>.nostarch<wbr>.com](http://www.nostarch.com)* 关联的公钥的证书进行响应。客户端使用浏览器中嵌入的证书颁发机构验证证书的有效性（一个受信任的证书颁发机构，它的证书应该包含在浏览器或操作系统的证书存储中以供验证）。一旦所有检查通过，浏览器会请求来自
    *[www<wbr>.nostarch<wbr>.com](http://www.nostarch.com)* 服务器的初始页面。
- en: Upon a successful TLS 1.3 handshake, all communications between the client and
    the server are encrypted and authenticated. An eavesdropper can learn that a client
    at a given IP address is talking to a server at another given IP address and can
    observe the encrypted content exchanged but can’t learn the underlying plaintext
    or modify the encrypted messages (if they do, the receiving party will notice
    that the communication has been tampered with, because messages are authenticated).
    That’s enough security for many applications.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 在成功完成 TLS 1.3 握手后，客户端和服务器之间的所有通信都将被加密并认证。窃听者可以得知某个特定 IP 地址的客户端正在与另一个特定 IP 地址的服务器通信，并且可以观察到交换的加密内容，但无法得知底层的明文内容或修改加密消息（如果他们修改了消息，接收方会注意到通信被篡改，因为消息是经过认证的）。这对于许多应用来说已经足够安全。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">TLS 1.3 Cryptographic
    Algorithms</samp>
  id: totrans-73
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">TLS 1.3 加密算法</samp>
- en: TLS 1.3 uses authenticated encryption algorithms, a key derivation function
    (a hash function that derives secret keys from a shared secret), as well as a
    Diffie–Hellman operation—but how exactly do these work, what algorithms are used,
    and how secure are they?
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: TLS 1.3 使用已认证的加密算法、密钥派生函数（从共享秘密派生密钥的哈希函数）以及 Diffie–Hellman 操作——但是这些是如何工作的，使用了哪些算法，以及它们的安全性如何呢？
- en: 'With regard to the choice of authenticated ciphers, TLS 1.3 supports only three
    algorithms: AES-GCM, AES-CCM (a slightly less efficient mode than GCM), and the
    ChaCha20 stream cipher combined with the Poly1305 MAC (as defined in RFC 7539).
    Because TLS 1.3 prevents using an unsafe key length such as 64 or 80 bits, the
    secret key can be either 128 bits (AES-GCM or AES-CCM) or 256 bits (AES-GCM or
    ChaCha20-Poly1305).'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 关于已认证的加密算法的选择，TLS 1.3 仅支持三种算法：AES-GCM、AES-CCM（比 GCM 略微低效的模式）以及结合 Poly1305 MAC
    的 ChaCha20 流加密算法（如 RFC 7539 中所定义）。由于 TLS 1.3 防止使用不安全的密钥长度，例如 64 位或 80 位，因此密钥可以是
    128 位（AES-GCM 或 AES-CCM）或 256 位（AES-GCM 或 ChaCha20-Poly1305）。
- en: The key derivation operation (KDF) in [Figure 13-1](chapter13.xhtml#fig13-1)
    is based on HKDF, a construction based on HMAC (see [Chapter 7](chapter7.xhtml))
    and defined in RFC 5869 that uses either the SHA-256 or the SHA-384 hash function.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 13-1](chapter13.xhtml#fig13-1) 中的密钥派生操作（KDF）基于 HKDF，它是一个基于 HMAC（参见 [第 7
    章](chapter7.xhtml)）的构造，并在 RFC 5869 中定义，使用 SHA-256 或 SHA-384 哈希函数。'
- en: 'Your options for performing the Diffie–Hellman operation (the core of the TLS
    1.3 handshake) are limited to elliptic curve cryptography and a multiplicative
    group of integers modulo a prime number (as in traditional Diffie–Hellman). But
    you can’t use just any elliptic curve or group: the supported curves include three
    NIST curves as well as Curve25519 (see [Chapter 12](chapter12.xhtml)) and Curve448,
    both defined in RFC 7748\. TLS 1.3 also supports DH over groups of integers, as
    opposed to elliptic curves. The groups supported are the five groups defined in
    RFC 7919: groups of 2,048, 3,072, 4,096, 6,144, and 8,192 bits.'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 执行 Diffie–Hellman 操作（TLS 1.3 握手的核心）的选项仅限于椭圆曲线加密和模素数的整数乘法群（如传统的 Diffie–Hellman）。但你不能随便使用任何椭圆曲线或群体：支持的曲线包括三种
    NIST 曲线，以及 Curve25519（见 [第 12 章](chapter12.xhtml)）和 Curve448，这两者在 RFC 7748 中有定义。TLS
    1.3 还支持基于整数群体的 DH，而不是椭圆曲线。支持的群体是 RFC 7919 中定义的五个群体：2,048 位、3,072 位、4,096 位、6,144
    位和 8,192 位。
- en: The 2,048-bit group may in theory be TLS 1.3’s weakest link. Whereas the other
    options provide at least 128-bit security, 2,048-bit Diffie–Hellman is believed
    to provide less than 100-bit security. Supporting a 2,048-bit group can therefore
    be seen as inconsistent with other TLS 1.3 design choices. In practice, 100-bit
    security is about as hard to crack as 128-bit—that is, practically impossible.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 2,048 位的组在理论上可能是 TLS 1.3 最薄弱的环节。其他选项至少提供 128 位的安全性，而 2,048 位的 Diffie–Hellman
    被认为提供的安全性低于 100 位。因此，支持 2,048 位组可以被视为与 TLS 1.3 其他设计选择不一致。实际上，100 位的安全性大致等同于 128
    位的安全性——也就是说，几乎不可能破解。
- en: <samp class="SANS_Futura_Std_Bold_B_11">TLS 1.3 Improvements over TLS 1.2</samp>
  id: totrans-79
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">TLS 1.3 相对于 TLS 1.2 的改进</samp>
- en: TLS 1.3 is very different from its predecessor. For one, it gets rid of weak
    algorithms like MD5, SHA-1, RC4, and AES in CBC mode. Also, whereas TLS 1.2 often
    protected records using a combination of a cipher and a MAC (such as HMAC-SHA-1)
    within a MAC-then-encrypt construction, TLS 1.3 supports only the more efficient
    and secure authenticated ciphers. TLS 1.3 also ditches elliptic curve point encoding
    negotiation and defines a single point format for each curve.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: TLS 1.3 与其前身大不相同。首先，它淘汰了 MD5、SHA-1、RC4 和 CBC 模式中的 AES 等弱算法。此外，TLS 1.2 通常使用加密算法和
    MAC（如 HMAC-SHA-1）的组合来保护记录，这种组合在 MAC-然后加密的构造中使用，而 TLS 1.3 只支持更高效且安全的认证加密算法。TLS
    1.3 还摒弃了椭圆曲线点编码协商，并为每个曲线定义了一个单一的点格式。
- en: TLS 1.3 removed features in 1.2 that weakened the protocol, and it reduced the
    protocol’s overall complexity and thereby its attack surface. For example, TLS
    1.3 ditches optional data compression, a feature that enabled the CRIME attack
    on TLS 1.2\. This attack exploited the fact that the length of the compressed
    version of a message leaks information on the content of the message.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: TLS 1.3 移除了 1.2 中削弱协议的特性，降低了协议的整体复杂性，从而减少了攻击面。例如，TLS 1.3 放弃了可选的数据压缩功能，这是 TLS
    1.2 中启用了 CRIME 攻击的功能。该攻击利用了消息压缩版本的长度泄露了消息内容的信息这一事实。
- en: 'But TLS 1.3 also brings new features that make connections either more secure
    or more efficient. I’ll discuss three of these features: downgrade protection,
    the single round-trip handshake, and session resumption.'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 但 TLS 1.3 也带来了新的功能，使得连接更安全或更高效。我将讨论其中的三项功能：降级保护、单次往返握手和会话恢复。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Downgrade Protection</samp>
  id: totrans-83
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">降级保护</samp>
- en: TLS 1.3’s *downgrade protection* feature is a defense against *downgrade attacks*,
    wherein an attacker forces the client and the server to use a weaker version of
    TLS than 1.3\. To carry out a downgrade attack, an attacker forces the server
    to use a weaker version of TLS by intercepting and modifying the ClientHello message
    to tell the server that the client doesn’t support TLS 1.3\. Now the attacker
    can exploit vulnerabilities in earlier versions of TLS.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: TLS 1.3 的 *降级保护* 功能是防止 *降级攻击* 的防御措施，在这种攻击中，攻击者强迫客户端和服务器使用比 1.3 更弱的 TLS 版本。为了执行降级攻击，攻击者通过拦截并修改
    ClientHello 消息，将客户端不支持 TLS 1.3 的信息传递给服务器，从而迫使服务器使用较弱的 TLS 版本。现在，攻击者可以利用 TLS 较早版本中的漏洞。
- en: In an effort to defeat downgrade attacks, the TLS 1.3 server uses three types
    of patterns in the 32-byte random value sent within the ServerHello message to
    identify the type of connection requested. The pattern should match the client’s
    request for a specific type of TLS connection. If the client receives the wrong
    pattern, it knows something is up.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 为了防止降级攻击，TLS 1.3服务器在ServerHello消息中发送的32字节随机值中使用三种类型的模式来识别请求的连接类型。模式应与客户端请求的特定类型的TLS连接相匹配。如果客户端收到错误的模式，它就会知道出了问题。
- en: Specifically, if the client asks for a TLS 1.2 connection, the first 8 of the
    32 bytes are set to <samp class="SANS_TheSansMonoCd_W5Regular_11">44 4F 57 4E
    47 52 44 01</samp>, and if it asks for a TLS 1.1 connection, they’re set to <samp
    class="SANS_TheSansMonoCd_W5Regular_11">44 4F 57 4E 47 52 44 00</samp>. However,
    if the client requests a TLS 1.3 connection, these first 8 bits should be random.
    For example, if a client sends a ClientHello asking for a TLS 1.3 connection,
    but an attacker on the network modifies it to ask for a TLS 1.1 connection, when
    the client receives the ServerHello with the wrong pattern, it knows that its
    ClientHello message was modified. (The attacker can’t arbitrarily modify the server’s
    32-byte random value because this value is cryptographically signed.)
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 具体来说，如果客户端请求TLS 1.2连接，前8个32字节设置为<samp class="SANS_TheSansMonoCd_W5Regular_11">44
    4F 57 4E 47 52 44 01</samp>，如果请求TLS 1.1连接，则设置为<samp class="SANS_TheSansMonoCd_W5Regular_11">44
    4F 57 4E 47 52 44 00</samp>。然而，如果客户端请求TLS 1.3连接，这前8个字节应该是随机的。例如，如果客户端发送一个ClientHello请求TLS
    1.3连接，但网络上的攻击者将其修改为请求TLS 1.1连接，当客户端收到包含错误模式的ServerHello时，它会知道自己的ClientHello消息已被修改。（攻击者无法随意修改服务器的32字节随机值，因为这个值是经过加密签名的。）
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Single Round-Trip
    Handshake</samp>
  id: totrans-87
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">单回合握手</samp>
- en: In a typical TLS 1.2 handshake, the client sends some data to the server, waits
    for a response, and then sends more data and waits for the server’s response before
    sending encrypted messages. The delay is that of two round-trip times (RTT). In
    contrast, TLS 1.3’s handshake takes a single round-trip time (see [Figure 13-1](chapter13.xhtml#fig13-1)).
    The time saved can be in the hundreds of milliseconds. This is significant when
    you consider that servers of popular services handle thousands of connections
    per second.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 在典型的TLS 1.2握手中，客户端发送一些数据到服务器，等待回应，然后再发送更多数据并等待服务器回应后才发送加密消息。延迟是两次往返时间（RTT）。相比之下，TLS
    1.3的握手只需要一次往返时间（见[图13-1](chapter13.xhtml#fig13-1)）。节省的时间可以达到几百毫秒。在考虑到流行服务的服务器每秒处理数千个连接时，这一差异非常重要。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Session Resumption</samp>
  id: totrans-89
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">会话恢复</samp>
- en: 'TLS 1.3 is faster than TLS 1.2, but it can be made even faster (on the order
    of hundreds of milliseconds) by completely eliminating the round trips that precede
    an encrypted session. The trick is to use *session resumption*, which leverages
    the preshared key exchanged between the client and the server in a previous session
    to bootstrap a new session. Session resumption brings two major benefits: the
    client can start encrypting immediately, and there’s no need to use certificates
    in subsequent sessions.'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: TLS 1.3比TLS 1.2更快，但通过完全消除加密会话前的往返时间，它甚至可以更快（可节省几百毫秒）。诀窍在于使用*会话恢复*，该方法利用在先前会话中客户端和服务器之间交换的预共享密钥来启动新会话。会话恢复带来了两个主要好处：客户端可以立即开始加密，并且后续会话无需使用证书。
- en: '[Figure 13-2](chapter13.xhtml#fig13-2) shows how session resumption works.'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: '[图13-2](chapter13.xhtml#fig13-2)展示了会话恢复的工作原理。'
- en: '![](../images/fig13-2.jpg)'
  id: totrans-92
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/fig13-2.jpg)'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 13-2: The TLS 1.3 session
    resumption handshake, wherein the 0-RTT data is the session resumption data sent
    along with the ClientHello</samp>'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">图13-2：TLS 1.3会话恢复握手，其中0-RTT数据是与ClientHello一起发送的会话恢复数据</samp>
- en: First, the client sends a ClientHello message that includes the identifier of
    the key already shared (called *PSK* for *preshared key*) with the server, along
    with a fresh DH public key. The client can also include encrypted data in this
    first message (called *0-RTT data*). When the server responds to a ClientHello
    message, it provides a MAC over the data exchange. The client verifies the MAC
    and knows that it’s talking to the same server as it did previously, thus rendering
    certificate validation somewhat superfluous. The client and the server perform
    a Diffie–Hellman key agreement as in the normal handshake, and subsequent messages
    are encrypted using keys that depend on both the PSK and the newly computed Diffie–Hellman
    shared secret.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，客户端发送包含已经与服务器共享的密钥标识符（称为*PSK*，即*预共享密钥*）和一个新的 DH 公钥的 ClientHello 消息。客户端还可以在这条消息中包含加密数据（称为*0-RTT
    数据*）。当服务器响应 ClientHello 消息时，它会提供一个数据交换的 MAC。客户端验证 MAC 后，可以确认它与之前的服务器进行通信，从而使证书验证显得有些多余。客户端和服务器执行如同正常握手中的
    Diffie–Hellman 密钥协商，后续的消息将使用依赖于 PSK 和新计算的 Diffie–Hellman 共享密钥的密钥进行加密。
- en: <samp class="SANS_Futura_Std_Bold_B_11">The Strengths of TLS Security</samp>
  id: totrans-95
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">TLS 安全性的优势</samp>
- en: 'We’ll evaluate the strengths of TLS 1.3 with respect to two main security notions
    from [Chapter 11](chapter11.xhtml): authentication and forward secrecy.'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将评估 TLS 1.3 在[第 11 章](chapter11.xhtml)中提到的两种主要安全概念下的优势：身份验证和前向保密。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Authentication</samp>
  id: totrans-97
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">身份验证</samp>
- en: During the TLS 1.3 handshake, the server authenticates to the client using the
    certificate mechanism. However, the client isn’t authenticated, and clients may
    authenticate with a server-based application (such as Gmail) by providing a username
    and password in a TLS record after performing the handshake. If the client’s already
    established a session with the remote service, it may authenticate by sending
    a *secure cookie*, which can be sent only through a TLS connection.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 在 TLS 1.3 握手期间，服务器通过证书机制对客户端进行身份验证。然而，客户端并未进行身份验证，客户端可以通过在握手后向服务器端应用程序（如 Gmail）提供用户名和密码来进行身份验证。如果客户端已与远程服务建立会话，它可以通过发送*安全
    Cookie*来进行身份验证，该 Cookie 只能通过 TLS 连接发送。
- en: 'In certain cases, clients can authenticate to a server using a certificate-based
    mechanism similar to what the server uses to authenticate to the client: the client
    sends a *client certificate* to the server, which verifies this certificate before
    authorizing the client. However, you will rarely use client certificates because
    they complicate things for both clients and the server (that is, the certificate
    issuer): clients need to perform complex operations to integrate the certificate
    into their system and to protect its private key, while the issuer needs to make
    sure that only authorized clients received a certificate, among other requirements.'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些情况下，客户端可以使用类似服务器用于身份验证的基于证书的机制来对服务器进行身份验证：客户端向服务器发送*客户端证书*，服务器在授权客户端之前验证该证书。然而，由于客户端证书会增加客户端和服务器（即证书颁发机构）的复杂性，因此你很少会使用客户端证书：客户端需要执行复杂的操作将证书集成到系统中并保护其私钥，而证书颁发机构需要确保只有授权的客户端收到证书，并且满足其他要求。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Forward Secrecy</samp>
  id: totrans-100
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">前向保密性</samp>
- en: Recall from “Key Agreement Protocols” in [Chapter 11](chapter11.xhtml) that
    a key agreement provides forward secrecy if previous sessions aren’t compromised
    when the present session is compromised. In the data leak model, only temporary
    secrets are compromised, whereas in the breach model, long-term secrets are exposed.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 回顾[第 11 章](chapter11.xhtml)中的“密钥协商协议”，密钥协商提供前向保密性，前提是当当前会话受到攻击时，先前的会话不会受到影响。在数据泄露模型中，只有临时秘密被泄露，而在漏洞模型中，长期秘密被暴露。
- en: Thankfully, TLS 1.3 forward secrecy holds up in the face of both a data leak
    and a breach. In the data leak model, the attacker recovers temporary secrets
    such as the session keys or Diffie–Hellman private keys of a specific session
    (the values *c*, *s*, *secret*, and *keys* in [Figure 13-1](chapter13.xhtml#fig13-1)).
    However, they can use these values to decrypt communications from only the present
    session, not previous sessions, because different values of *c* and *s* were used
    (thus yielding different keys).
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，TLS 1.3 的前向保密性在数据泄露和安全漏洞面前依然有效。在数据泄露模型中，攻击者恢复了临时密钥，如特定会话的会话密钥或 Diffie–Hellman
    私钥（[图 13-1](chapter13.xhtml#fig13-1) 中的 *c*、*s*、*secret* 和 *keys* 的值）。然而，攻击者只能使用这些值解密当前会话的通信，而无法解密先前的会话，因为不同的
    *c* 和 *s* 值被使用了（从而产生不同的密钥）。
- en: In the breach model, the attacker also recovers long-term secrets (namely, the
    private key that corresponds to the public key in the certificate). However, this
    is no more useful when decrypting previous sessions than temporary secrets, because
    this private key serves to authenticate only the server, and forward secrecy holds
    up again.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 在漏洞模型中，攻击者也会恢复长期密钥（即与证书中的公钥对应的私钥）。然而，这在解密先前会话时并没有比临时密钥更有用，因为这个私钥仅用于验证服务器身份，前向保密性依然有效。
- en: In practice, if an attacker compromises a client’s machine and gains access
    to all of its memory, they may recover the client’s TLS session keys and secrets
    for the current session from memory. But more importantly, if previous keys are
    still in memory, the attacker may be able to find them and decrypt previous sessions,
    thereby bypassing the theoretical forward secrecy. Therefore, for a TLS implementation
    to ensure forward secrecy, it must properly erase keys from memory once they’re
    no longer used, typically by zeroing out the memory.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，如果攻击者攻破了客户端的机器，并获得了其所有内存的访问权限，他们可能从内存中恢复出当前会话的 TLS 会话密钥和秘密信息。但更重要的是，如果先前的密钥仍然保存在内存中，攻击者可能会找到它们并解密先前的会话，从而绕过理论上的前向保密性。因此，为了确保前向保密性，TLS
    实现必须在密钥不再使用时正确地将其从内存中擦除，通常通过清空内存来实现。
- en: <samp class="SANS_Futura_Std_Bold_B_11">How Things Can Go Wrong</samp>
  id: totrans-105
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">事情如何出错</samp>
- en: TLS 1.3 fits the bill as a general-purpose secure communications protocol, but
    it’s not bulletproof. Like any security system, it can fail under certain circumstances
    (for example, when the assumptions made by its designers about real attacks are
    wrong). Unfortunately, even the latest version of TLS 1.3, configured with the
    most secure ciphers, can be compromised. For example, TLS 1.3 security relies
    on the assumption that all three parties (the client, the server, and the certificate
    authority) will behave honestly, but what if one party is compromised or the TLS
    implementation itself is poorly implemented?
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: TLS 1.3 作为一种通用的安全通信协议符合要求，但它并不是万无一失的。像任何安全系统一样，在某些情况下它可能会失败（例如，当设计者对真实攻击的假设错误时）。不幸的是，即使是配置了最安全密码的最新版本
    TLS 1.3 也可能被攻破。例如，TLS 1.3 的安全性依赖于假设三方（客户端、服务器和证书授权机构）都将诚实地行为，但如果某一方被攻破，或者 TLS
    实现本身存在问题该怎么办？
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Compromised Certificate
    Authority</samp>
  id: totrans-107
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">受损的证书授权机构</samp>
- en: Root certificate authorities (root CAs) are organizations that browsers trust
    to validate certificates served by remote hosts. For example, if your browser
    accepts the certificate provided by *[www<wbr>.google<wbr>.com](http://www.google.com)*,
    the assumption is that a trusted CA has verified the legitimacy of the certificate
    owner. The browser verifies the certificate by checking its CA-issued signature.
    Since only the CA knows the private key required to create this signature, we
    assume others can’t create valid certificates on behalf of the CA. Very often
    a website’s certificate won’t be signed by a root CA but by an intermediate CA,
    which is connected to the root CA through a certificate chain.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 根证书授权机构（根 CA）是浏览器信任的组织，用来验证远程主机提供的证书。例如，如果你的浏览器接受 *[www<wbr>.google<wbr>.com](http://www.google.com)*
    提供的证书，假设一个受信任的 CA 已经验证了证书所有者的合法性。浏览器通过检查 CA 签发的签名来验证证书。由于只有 CA 才知道创建此签名所需的私钥，我们假设其他人无法代表
    CA 创建有效证书。通常情况下，网站的证书不会由根 CA 签署，而是由一个中级 CA 签署，后者通过证书链与根 CA 连接。
- en: If a CA’s private key is compromised, the attacker is able to use the CA’s private
    key to create a certificate for any URLs in, say, the *google.com* domain without
    Google’s approval. The attacker can then use those certificates to pretend to
    host a legitimate server or subdomain like *mail.google.com* and intercept a user’s
    credentials and communications. That’s exactly what happened in 2011 when an attacker
    hacked into the network of the Dutch certificate authority DigiNotar and created
    seemingly legitimate certificates. The attacker used these fake certificates for
    several Google services.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 如果CA的私钥被攻破，攻击者能够使用CA的私钥为任何URL生成证书，例如*google.com*域名下的URL，而不需要Google的批准。攻击者可以利用这些证书冒充合法服务器或子域名，如*mail.google.com*，并截获用户的凭证和通信。这正是2011年发生的事件，当时一名攻击者入侵了荷兰证书机构DigiNotar的网络，并创建了看似合法的证书。攻击者使用这些伪造的证书对多个Google服务进行攻击。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Compromised Server</samp>
  id: totrans-110
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">受损服务器</samp>
- en: 'If a server is compromised and fully controlled by an attacker, all is lost:
    the server holds the session keys, being the termination point of the TLS connection.
    The attacker can see all transmitted data before it’s encrypted and all received
    data once it’s decrypted. They’ll also likely get their hands on the server’s
    private key, which could allow them to impersonate the legitimate server using
    their own malicious server. TLS won’t save you in this case.'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 如果服务器被攻破并完全被攻击者控制，那么一切都失去了：服务器持有会话密钥，作为TLS连接的终点。攻击者可以在数据加密前看到所有传输的数据，也可以在数据解密后看到所有接收的数据。他们还可能获取到服务器的私钥，这可能使他们能够使用自己的恶意服务器冒充合法服务器。此时，TLS并不能保护你。
- en: Fortunately, such security disasters are rarely seen in high-profile applications
    such as Gmail and iCloud, which are well protected and sometimes have their private
    keys stored in a separate security module, such as a hardware security module
    (HSM), directly or via a key management system (KMS) application.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，这类安全灾难在像Gmail和iCloud这样的高关注度应用中很少发生，它们得到了很好的保护，有时甚至将私钥存储在独立的安全模块中，例如硬件安全模块（HSM），直接或通过密钥管理系统（KMS）应用。
- en: Attacks on web applications via vulnerabilities such as database query injections
    and cross-site scripting are more common because they’re mostly independent of
    TLS’s security and are carried out by attackers over a legitimate TLS connection.
    Such attacks may compromise usernames, passwords, and so on.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 通过诸如数据库查询注入和跨站脚本等漏洞对Web应用程序的攻击更为常见，因为它们大多数不依赖于TLS的安全性，并且通过攻击者在合法的TLS连接上进行。这类攻击可能会泄露用户名、密码等信息。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Compromised Client</samp>
  id: totrans-114
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">受损客户端</samp>
- en: TLS security is also jeopardized when a client, such as a browser, is compromised
    by a remote attacker. Having compromised the client, the attacker is able to capture
    session keys, read any decrypted data, and so on. They could even install a rogue
    CA certificate in the client’s system to have it silently accept otherwise-invalid
    certificates, thereby letting attackers intercept TLS connections.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 当客户端，如浏览器，受到远程攻击者的攻击时，TLS安全性也会受到威胁。攻击者通过攻破客户端，能够捕获会话密钥、读取任何解密的数据等。他们甚至可以在客户端系统中安装一个恶意CA证书，使其默默接受本应无效的证书，从而让攻击者截获TLS连接。
- en: The difference between the compromised CA or server scenarios and the compromised
    client scenario is that in the case of the compromised client, only the targeted
    client is affected, instead of potentially *all* clients.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 受损的CA或服务器场景与受损客户端场景的区别在于，在受损客户端的情况下，只有目标客户端受到影响，而不是可能影响到*所有*客户端。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Bugs in Implementations</samp>
  id: totrans-117
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">实现中的漏洞</samp>
- en: As with any cryptographic component, TLS can fail when there are bugs in its
    implementation. The poster child for TLS bugs is Heartbleed (see [Figure 13-3](chapter13.xhtml#fig13-3)),
    a buffer overflow in the OpenSSL implementation of a minor TLS feature called
    *heartbeat*. Heartbleed was discovered in 2014, independently by a Google researcher
    and by the Codenomicon company, and affected millions of TLS servers and clients.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 和任何加密组件一样，当TLS的实现中存在漏洞时，它也可能会失败。TLS漏洞的典型案例是Heartbleed（见[图13-3](chapter13.xhtml#fig13-3)），这是OpenSSL在一个名为*heartbeat*的小型TLS特性中的缓冲区溢出漏洞。Heartbleed在2014年由一名Google研究员和Codenomicon公司独立发现，影响了数百万的TLS服务器和客户端。
- en: '![](../images/fig13-3.jpg)'
  id: totrans-119
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/fig13-3.jpg)'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 13-3: The Heartbleed
    bug in OpenSSL implementations of TLS</samp>'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">图 13-3：OpenSSL 实现的 TLS 中的 Heartbleed
    漏洞</samp>
- en: A client first sends a buffer along with a buffer length to the server to check
    whether the server is online. In this example, the buffer is the string *BANANAS*,
    and the client explicitly says that this word is seven letters long. The server
    reads the seven-letter word and returns it to the client.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 客户端首先将一个缓冲区和缓冲区长度发送给服务器，以检查服务器是否在线。在这个例子中，缓冲区是字符串*BANANAS*，客户端明确表示这个词有七个字母。服务器读取这个七个字母的单词并将其返回给客户端。
- en: The problem is that the server doesn’t confirm that the length is correct and
    attempts to read as many characters as the client tells it to. Consequently, if
    the client provides a length that is longer than the string’s actual length, the
    server reads too much data from memory and returns it to the client, together
    with any extra data that may contain sensitive information, such as private keys
    or session cookies.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 问题在于服务器没有确认长度是否正确，而是按照客户端提供的长度读取尽可能多的字符。因此，如果客户端提供的长度比字符串的实际长度长，服务器就会从内存中读取过多的数据，并将其连同任何可能包含敏感信息（如私钥或会话
    cookie）的额外数据一起返回给客户端。
- en: The Heartbleed bug came as a shock. To avoid similar future bugs, OpenSSL and
    other major TLS implementations now perform rigorous code reviews and use automated
    tools such as fuzzers to identify potential issues.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: Heartbleed 漏洞让人震惊。为了避免类似的未来漏洞，OpenSSL 和其他主要的 TLS 实现现在进行严格的代码审查，并使用自动化工具如模糊测试（fuzzers）来识别潜在问题。
- en: <samp class="SANS_Futura_Std_Bold_B_11">Further Reading</samp>
  id: totrans-124
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">进一步阅读</samp>
- en: This chapter isn’t a comprehensive guide to TLS, and you may want to dig deeper
    into the history of TLS, its previous vulnerabilities, and its latest version.
    The complete TLS 1.3 specifications, found on the home page of the TLS Working
    Group (TLSWG) at *[https://<wbr>tlswg<wbr>.org](https://tlswg.org)*, include everything
    about the protocol (though not necessarily its underlying rationale).
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 本章并不是 TLS 的全面指南，你可能想深入了解 TLS 的历史、以前的漏洞以及其最新版本。完整的 TLS 1.3 规范可以在 TLS 工作组（TLSWG）主页上找到，网址是
    *[https://<wbr>tlswg<wbr>.org](https://tlswg.org)*，其中包含了协议的所有内容（虽然不一定包括其底层的理论依据）。
- en: I also suggest you learn about major protocols that use TLS, such as QUIC (used
    in connections between Chrome and Google servers) and SRTP (used for videoconferencing
    and streaming traffic).
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 我还建议你了解一些使用 TLS 的主要协议，如 QUIC（用于 Chrome 和 Google 服务器之间的连接）和 SRTP（用于视频会议和流媒体传输）。
- en: 'In addition, here are two important initiatives related to TLS deployment:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，以下是与 TLS 部署相关的两个重要倡议：
- en: SSL Labs TLS test (*[https://<wbr>www<wbr>.ssllabs<wbr>.com<wbr>/ssltest](https://www.ssllabs.com/ssltest)*)
    is a free service by Qualys that lets you test a browser’s or a server’s TLS configuration,
    providing a security rating as well as improvement suggestions. If you set up
    your own TLS server, use this test to make sure everything is safe.
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: SSL Labs TLS 测试 (*[https://<wbr>www<wbr>.ssllabs<wbr>.com<wbr>/ssltest](https://www.ssllabs.com/ssltest)*)
    是由 Qualys 提供的免费服务，允许你测试浏览器或服务器的 TLS 配置，提供安全评分以及改进建议。如果你设置了自己的 TLS 服务器，可以使用这个测试来确保一切安全。
- en: Let’s Encrypt (*[https://<wbr>letsencrypt<wbr>.org](https://letsencrypt.org)*)
    is a nonprofit that offers a service to “automagically” deploy TLS on your HTTP
    servers. It includes features to automatically generate a certificate and configure
    the TLS server, and it supports all the common web servers and operating systems.
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Let’s Encrypt (*[https://<wbr>letsencrypt<wbr>.org](https://letsencrypt.org)*)
    是一个非营利组织，提供“自动化”部署 TLS 到你的 HTTP 服务器的服务。它包括自动生成证书和配置 TLS 服务器的功能，并支持所有常见的 Web 服务器和操作系统。
