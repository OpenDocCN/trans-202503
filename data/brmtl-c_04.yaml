- en: '3'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '3'
- en: Programming the Microcontroller
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 微控制器编程
- en: '![](image_fi/book_art/chapterart.png)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![](image_fi/book_art/chapterart.png)'
- en: Now that we’ve written and run a “Hello World” program in the IDE, we’ll do
    the same on the STM32 NUCLEO-F030R8 development board, which contains the STM32F030R8
    processor and several other components needed to use the processor. On an embedded
    system, the equivalent of “Hello World” is a program that makes an LED blink.
    By making an LED blink, you’ll learn the steps needed to make a complex program
    at a smaller scale.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经在IDE中编写并运行了一个“Hello World”程序，我们将在STM32 NUCLEO-F030R8开发板上做同样的事情，该开发板包含STM32F030R8处理器以及使用该处理器所需的其他多个组件。在嵌入式系统中，“Hello
    World”的等效程序是使LED闪烁的程序。通过让LED闪烁，你将学习如何在较小的规模上进行复杂程序的开发步骤。
- en: In the process, you’ll learn how to use the System Workbench for STM32, which
    we explored in the last chapter, to create an embedded program. To assist us,
    we’ll use STMicroelectronics software called the hardware abstraction layer (HAL),
    which hides some of the more annoying details of the hardware from you. (However,
    the details aren’t hidden very deep, and you can examine the source code to see
    what was done.) We’ll also get into what the IDE is doing behind the scenes with
    a detailed explanation of the options it’s using to compile the code.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个过程中，你将学习如何使用STM32的系统工作台（我们在上一章中探讨过）来创建嵌入式程序。为了帮助我们，我们将使用STMicroelectronics的软件——硬件抽象层（HAL），它隐藏了硬件的一些繁琐细节。（然而，这些细节并没有被隐藏得很深，你可以查看源代码了解实现的内容。）我们还将详细解释IDE在幕后执行的操作，并解释它使用的编译选项。
- en: Finally, like we did in Chapter 2, we’ll run the debugger to see our program
    execute one statement at a time, which will prove extremely useful when we start
    to make larger and larger programs.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，像我们在第2章所做的那样，我们将运行调试器，逐行执行程序，这对于我们开始制作越来越大的程序时非常有用。
- en: The NUCLEO-F030R8 Development Board
  id: totrans-6
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: NUCLEO-F030R8开发板
- en: '*Development boards* are circuit boards that contain a processor chip and various
    other components required to develop applications for that processor, including
    a lot of useful items for developing programs and circuits that use the chip.
    In addition to programming and debugging support, the development board includes
    numerous *connectors*, which allow you to hook up your prototype hardware. It
    also includes a few *peripherals* such as a serial port, a push button switch,
    and an LED, although some of the fancier boards will have additional peripherals.'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: '*开发板*是包含处理器芯片和开发该处理器应用所需的各种组件的电路板，包含许多有助于开发程序和电路的有用元件。除了编程和调试支持，开发板还包括多个*连接器*，让你可以连接原型硬件。它还包括一些*外设*，如串行端口、按钮开关和LED，尽管一些更高级的开发板会包含更多外设。'
- en: Thus, the development board provides you with an instant prototype for developing
    the initial software with breadboarded hardware. Microprocessor manufacturers
    generally sell development boards with all that stuff included to get people to
    use their chips.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，开发板为你提供了一个即时原型，用于开发具有面包板硬件的初始软件。微处理器制造商通常会出售包含所有这些设备的开发板，以便让人们使用他们的芯片。
- en: The STM32 NUCLEO-F030R8 board bundles the STM32F030R8 chip with a clock circuit,
    a power supply, and some devices to talk to, including an LED, a button, and a
    serial I/O device. [Figure 3-1](#figure3-1) shows the basic building blocks of
    our processor board.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: STM32 NUCLEO-F030R8开发板将STM32F030R8芯片与时钟电路、电源以及一些外部设备（包括LED、按钮和串行I/O设备）打包在一起。[图3-1](#figure3-1)展示了我们处理器板的基本组成部分。
- en: '![f03001](image_fi/501621c03/f03001.png)'
  id: totrans-10
  prefs: []
  type: TYPE_IMG
  zh: '![f03001](image_fi/501621c03/f03001.png)'
- en: 'Figure 3-1: The processor board'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 图3-1：处理器板
- en: The power and clock drive the CPU, the reset button restarts the CPU, the user
    LED and push button are for user interaction, and the serial port and connectors
    are for programming and debugging.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 电源和时钟驱动CPU，重置按钮重启CPU，用户LED和按钮用于用户交互，串行端口和连接器用于编程和调试。
- en: Programming and Debugging the Board
  id: totrans-13
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 编程与调试开发板
- en: The development board contains three devices useful for programming and debugging
    the chip—a flash programmer, a JTAG pod, and a serial I/O device—all of which
    connect to your computer through a single USB cable. (One cable, three devices.)
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 开发板包含三个有助于编程和调试芯片的设备——一个闪存编程器，一个JTAG调试器和一个串行I/O设备——所有这些设备通过一个USB电缆连接到计算机。（一根电缆，三种设备。）
- en: To program the chip, we use the *flash programmer*, a device that allows our
    PC to reprogram the memory of the chip. Reprogramming memory is how we get our
    program into the machine.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 要对芯片进行编程，我们使用*闪存编程器*，这是一种允许 PC 重新编程芯片内存的设备。重新编程内存就是将程序加载到设备中。
- en: To facilitate debugging, the chip has a JTAG port. JTAG, which stands for Joint
    Test Action Group, is a standard debugging interface. Before this standard came
    out, everyone created their own debugging interface or, more often, left it out,
    leaving programmers to get very creative when it came to debugging programs. To
    debug with the JTAG port, we need to connect it to our computer. This is done
    through a *debug pod*, which has a connection to the JTAG port on our development
    board on one end and a connection to our computer’s USB port on the other.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 为了方便调试，芯片上有一个 JTAG 端口。JTAG，代表联合测试行动小组（Joint Test Action Group），是一种标准的调试接口。在这个标准发布之前，每个人都创建了自己的调试接口，或者更常见的是直接不做接口，这导致程序员在调试程序时必须非常有创意。要通过
    JTAG 端口进行调试，我们需要将其连接到计算机。这是通过一个*调试盒*完成的，调试盒一端连接到开发板上的 JTAG 端口，另一端连接到计算机的 USB 端口。
- en: Another very useful debugging and maintenance tool is the printing of diagnostic
    messages. The problem when it comes to embedded programs is where to print them.
    You don’t have a screen, so printing to the screen is out. Printing the messages
    in a logfile is difficult because you don’t have a filesystem. What most device
    designers do is put a *serial port*, a simple three-wire communication interface,
    on the board. Chapter 9 goes into the details of this device.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个非常有用的调试和维护工具是打印诊断信息。嵌入式程序的一个问题是哪里打印信息。因为没有显示屏，所以无法将信息打印到屏幕上。将信息打印到日志文件中也很困难，因为没有文件系统。大多数设备设计师做的是在板上放置一个*串口*，这是一个简单的三线通信接口。第
    9 章将详细介绍该设备。
- en: Setting Up the Board
  id: totrans-18
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 设置开发板
- en: The bottom half of the Nucleo board contains the chip and support circuitry,
    with lots and lots of pins broken out to connectors on the sides of the board
    (for connecting peripherals). Above that is the support board containing a programmer,
    a debugger, a serial-to-USB device, and a USB storage device.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: Nucleo 开发板的下半部分包含芯片及其支持电路，板的两侧有许多引脚连接到连接器（用于连接外部设备）。其上方是包含编程器、调试器、串口转 USB 设备和
    USB 存储设备的支持板。
- en: '[Figure 3-2](#figure3-2) shows how the board is put together.'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 3-2](#figure3-2)展示了开发板的组成。'
- en: '![f03002](image_fi/501621c03/f03002.png)'
  id: totrans-21
  prefs: []
  type: TYPE_IMG
  zh: '![f03002](image_fi/501621c03/f03002.png)'
- en: 'Figure 3-2: The NUCLEO-F030R8 board'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3-2：NUCLEO-F030R8 开发板
- en: 'The board also contains several jumpers and LEDs. *Jumpers* are small plastic
    devices that short two pins together. They are used to select hardware options,
    such as enabling the onboard debugger (ST-LINK), and should be installed as shown
    in [Figure 3-3](#figure3-3). Follow these steps to do so:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 板上还包含了多个跳线和 LED。*跳线*是小型塑料元件，用于将两个引脚短接在一起。它们用于选择硬件选项，如启用板载调试器（ST-LINK），并应按照[图
    3-3](#figure3-3)所示进行安装。请按照以下步骤操作：
- en: Install the ST-LINK with two jumpers (CN2). Doing so configures the onboard
    debugging pod (ST-LINK) to debug the onboard microcontroller. If you remove these
    two jumpers, you can use the ST-LINK pod to debug other boards instead.
  id: totrans-24
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 安装带有两个跳线（CN2）的 ST-LINK。这样做会将板载调试盒（ST-LINK）配置为调试板载微控制器。如果移除这两个跳线，您可以使用 ST-LINK
    调试其他开发板。
- en: Do not install the power supply jumper (JP1). This configuration allows the
    Nucleo board to draw up to 300mA of power through the USB port, letting you power
    the device using the USB port. If you connected lots of power-hungry peripherals
    to the board, you could use JP1 to enable an external power supply. This book
    doesn’t use any external hardware, so leave JP1 out.
  id: totrans-25
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 不要安装电源跳线（JP1）。这种配置允许 Nucleo 开发板通过 USB 端口最多吸取 300mA 的电流，从而使用 USB 端口为设备供电。如果您将许多高功耗外设连接到开发板，可以使用
    JP1 启用外部电源。本书不使用任何外部硬件，因此请不要安装 JP1。
- en: Do not install RX-TX, a debug option that shorts the input and output of the
    serial port together. We’ll use the serial port as an actual serial port later,
    so leave this jumper off.
  id: totrans-26
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 不要安装 RX-TX 跳线，这是一种将串口的输入和输出短接在一起的调试选项。我们稍后会将串口用作实际的串口，因此请不要安装这个跳线。
- en: Install the JP5 jumper to the right position (U5V). Doing so ensures the board
    will be powered through the USB port instead of through an external power source.
  id: totrans-27
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 JP5 跳线安装到正确的位置（U5V）。这样做可以确保开发板通过 USB 端口供电，而不是通过外部电源。
- en: Power the measurement jump (JP6). This is a lower-power device. The two pins
    shorted by JP6 supply power to the chip. Remove the jumper and connect an amp
    meter to measure power consumption.
  id: totrans-28
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开测量跳线（JP6）。这是一个低功耗设备。JP6短接的两个引脚为芯片供电。移除跳线并连接安培计来测量功耗。
- en: CN11 and CN12 are places to store jumpers when not in use. Installing jumpers
    there won’t affect the circuitry.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: CN11 和 CN12 是不使用时存放跳线的位置。将跳线安装到那里不会影响电路。
- en: '![f03003](image_fi/501621c03/f03003.png)'
  id: totrans-30
  prefs: []
  type: TYPE_IMG
  zh: '![f03003](image_fi/501621c03/f03003.png)'
- en: 'Figure 3-3: Jumper and LED locations'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3-3：跳线和 LED 位置
- en: Now plug the device into your computer using a mini USB cable. LD1 should turn
    red, indicating the programmer has power. LD2 should blink, because the board
    comes with a preinstalled program that blinks LD2\. (This is true assuming you
    bought the board new. If, like me, you got your first board from your buddy down
    the hall, it will contain your buddy’s last experiment.) LD3 should also turn
    red, indicating that the chip has power.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 现在使用迷你 USB 电缆将设备插入您的计算机。LD1 应该变红，表示编程器已通电。LD2 应该闪烁，因为板子自带一个预安装的程序，该程序会使 LD2
    闪烁。（如果您购买了全新的开发板，情况是这样的。如果像我一样从楼道里的朋友那里拿到了第一块开发板，它将包含您朋友上次的实验。）LD3 也应该变红，表示芯片已通电。
- en: Setting Up an Embedded Project
  id: totrans-33
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 设置嵌入式项目
- en: Before you begin programming, close any open editing windows in System Workbench
    for STM32\. The editing window identifies the filename, not the project name,
    which causes a problem; all our projects will have a *main.c* file, and things
    would get pretty confusing with half a dozen *main.c* editing windows open.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 在开始编程之前，关闭 STM32 系统工作台中所有打开的编辑窗口。编辑窗口显示的是文件名，而不是项目名，这会导致问题；我们所有的项目都会有一个*main.c*文件，如果有半打*main.c*编辑窗口打开，事情会变得相当混乱。
- en: Next, create an embedded project by selecting **File**▶**New**▶**C Project**.
    (A checklist detailing these steps can be found in the appendix.) The C Project
    dialog should appear (see [Figure 3-4](#figure3-4)).
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，通过选择**文件**▶**新建**▶**C 项目**来创建一个嵌入式项目。（这些步骤的详细清单可以在附录中找到。）C 项目对话框应出现（见[图
    3-4](#figure3-4)）。
- en: '![f03004](image_fi/501621c03/f03004.png)'
  id: totrans-36
  prefs: []
  type: TYPE_IMG
  zh: '![f03004](image_fi/501621c03/f03004.png)'
- en: 'Figure 3-4: The C Project dialog'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3-4：C 项目对话框
- en: For the project name, enter **03.blink**. For the project type, select **Ac6
    STM32 MCU Project**. On first startup, the IDE downloads the GCC ARM toolchain
    to the directory where you installed the IDE, as well as the entire STM32 firmware
    library, a portion of which will get copied to your project. If you’d like to
    explore this library’s code and examples further, the cache directory it uses
    is *~/.ac6* on Linux and macOS and *C:\Users\<username>\AppData\Roaming\Ac6* on
    Windows. Be warned, however, that these examples are designed to show off the
    STM chips and aren’t easily understood by novice programmers.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 在项目名称中输入**03.blink**。在项目类型中选择**Ac6 STM32 MCU 项目**。首次启动时，IDE 会将 GCC ARM 工具链下载到您安装
    IDE 的目录，并下载整个 STM32 固件库，其中一部分将被复制到您的项目中。如果您想进一步探索这个库的代码和示例，它使用的缓存目录在 Linux 和 macOS
    上是*~/.ac6*，在 Windows 上是*C:\Users\<username>\AppData\Roaming\Ac6*。但请注意，这些示例是为了展示
    STM 芯片的功能，初学者可能不容易理解。
- en: Click **Next**. The Select Configurations dialog, shown in [Figure 3-5](#figure3-5),
    should appear.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 点击**下一步**。选择配置对话框，如[图 3-5](#figure3-5)所示，应会出现。
- en: '![f03005](image_fi/501621c03/f03005.png)'
  id: totrans-40
  prefs: []
  type: TYPE_IMG
  zh: '![f03005](image_fi/501621c03/f03005.png)'
- en: 'Figure 3-5: The Select Configurations dialog'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3-5：选择配置对话框
- en: Leave **Debug** selected and deselect **Release**. To keep things simple, we’ll
    perform only one type of build. Click **Next**.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 保持**调试**选中，并取消选中**发布**。为了简化操作，我们只执行一种类型的构建。点击**下一步**。
- en: Next is the Target Configuration dialog (see [Figure 3-6](#figure3-6)).
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来是目标配置对话框（见[图 3-6](#figure3-6)）。
- en: '![f03006](image_fi/501621c03/f03006.png)'
  id: totrans-44
  prefs: []
  type: TYPE_IMG
  zh: '![f03006](image_fi/501621c03/f03006.png)'
- en: 'Figure 3-6: The Target Configuration dialog'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3-6：目标配置对话框
- en: For the series, select **STM32F0**, and for the board, select **NUCLEO-F030R8**.
    Click **Next**.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 对于系列，选择**STM32F0**，对于板卡，选择**NUCLEO-F030R8**。点击**下一步**。
- en: This brings us to the Project Firmware Configuration dialog (see [Figure 3-7](#figure3-7)).
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 这将带我们进入项目固件配置对话框（见[图 3-7](#figure3-7)）。
- en: '![f03007](image_fi/501621c03/f03007.png)'
  id: totrans-48
  prefs: []
  type: TYPE_IMG
  zh: '![f03007](image_fi/501621c03/f03007.png)'
- en: 'Figure 3-7: The Project Firmware Configuration dialog'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3-7：项目固件配置对话框
- en: The project firmware configuration options let us use free standard code available
    from STMicroelectronics and other suppliers. Since someone else has written most
    of the hard stuff, let’s use their work. Select **Hardware Abstraction Layer (Cube
    HAL)** and then click the button labeled **Download Target Firmware** when it
    appears. Accept the license agreement, and the IDE will download the firmware
    library.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 项目固件配置选项让我们可以使用来自 STMicroelectronics 和其他供应商的免费标准代码。既然其他人已经写好了大部分复杂的代码，那就使用他们的成果吧。选择
    **硬件抽象层（Cube HAL）**，然后在出现的界面中点击标有 **下载目标固件** 的按钮。接受许可协议，IDE 将下载固件库。
- en: After the long download completes, the system displays additional options. Leave
    them to the default values and click **Finish**.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 下载完成后，系统会显示其他选项。保持默认值，然后点击 **完成**。
- en: Back in the C/C++ Project view, you should see an entry in the project list
    for *blink*. Click the triangle next to *blink* to see a list of directories that
    make up the project, and click the triangle next to *src* to expand that directory.
    Double-click *main.c* to make it appear in the editing window, as shown in [Figure
    3-8](#figure3-8).
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 返回到 C/C++ 项目视图，你应该能在项目列表中看到 *blink* 的条目。点击 *blink* 旁边的三角形，可以看到组成项目的目录列表，再点击
    *src* 旁边的三角形展开该目录。双击 *main.c* 使其在编辑窗口中显示，如 [图 3-8](#figure3-8) 所示。
- en: '![f03008](image_fi/501621c03/f03008.png)'
  id: totrans-53
  prefs: []
  type: TYPE_IMG
  zh: '![f03008](image_fi/501621c03/f03008.png)'
- en: 'Figure 3-8: The editing window, showing *main.c*'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3-8：编辑窗口，显示 *main.c*
- en: Your First Embedded Program
  id: totrans-55
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 你的第一个嵌入式程序
- en: 'The IDE has conveniently supplied you with a main file that has the minimal
    features of your program filled in: a comment, the code libraries for the Nucleo
    board, and a generic `main` function. The + icon next to line 3 indicates that
    some program lines have been *folded*, or hidden from view. Click the + icon to
    expand the long comment describing the file:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: IDE 方便地为你提供了一个主文件，其中填写了程序的最小功能：注释、Nucleo 板的代码库和一个通用的 `main` 函数。第 3 行旁边的 + 图标表示某些程序行已被
    *折叠*，或者被隐藏。点击 + 图标以展开描述文件的长注释：
- en: '[PRE0]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: You may wish to update this comment with your name and information. The keywords
    that begin with `@` are designed to work with *Doxygen*, a complex and full-featured
    system that extracts documentation out of large programs. We won’t be using this
    tool for our small programs, so you can edit the comment any way you want.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能希望更新此注释，添加你的名字和信息。以 `@` 开头的关键字是为 *Doxygen* 设计的，这是一个复杂且功能全面的系统，用于从大型程序中提取文档。我们不会在小型程序中使用这个工具，所以你可以根据自己的需要编辑该注释。
- en: The `main` function doesn’t have a `return` statement because the `return` statement
    returns control from the program to the operating system, but a bare metal system
    doesn’t have an operating system. One of the jobs of the operating system is to
    start and stop programs (among other things). Since we don’t have an operating
    system, the processor halts whenever our program stops and does absolutely nothing.
    So we don’t stop. Ever. To see how we accomplish this, notice the `for(;;);` on
    line 19\. This is C code for “loop forever” (`for(;;)`) and “do nothing” (the
    closing semicolon).
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: '`main` 函数没有 `return` 语句，因为 `return` 语句将控制权从程序返回给操作系统，但裸机系统没有操作系统。操作系统的一个任务是启动和停止程序（以及其他功能）。由于我们没有操作系统，每当我们的程序停止时，处理器就会停下来，什么也不做。因此，我们不会停止。永远不会。要了解我们是如何实现这一点的，注意第
    19 行的 `for(;;);`。这是 C 语言中的“永远循环”（`for(;;)`）和“什么也不做”（分号）的代码。'
- en: But without an operating system, how do we start? Our program starts when the
    processor is turned on or is reset (hence the need for a big black reset button
    on the board).
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 但是没有操作系统，我们该如何启动呢？当处理器开启或复位时，我们的程序就开始运行（因此板子上有一个大黑色复位按钮）。
- en: As it stands now, our program doesn’t do anything and takes forever to do it.
    Let’s put in some code to do something.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 按目前的情况，我们的程序什么也不做，并且要花很长时间才能做到这一点。让我们添加一些代码来做点什么。
- en: Initializing the Hardware
  id: totrans-62
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 初始化硬件
- en: First, we need to initialize the hardware. To do so, we’ll make our first use
    of the HAL library. The HAL software layer is designed to hide all the ugly details
    involved with getting the chip to work. For example, we have to initialize the
    on-chip clock before we can use it to time the blinks of an LED. Doing this ourselves
    would require programming specific *I/O* *registers* that directly control how
    an I/O device acts. They are part of the hardware.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要初始化硬件。为此，我们将首次使用 HAL 库。HAL 软件层的设计目的是隐藏与芯片工作相关的所有复杂细节。例如，我们必须在使用芯片来定时
    LED 的闪烁之前，初始化片上时钟。自己完成这一工作将需要编程特定的 *I/O* *寄存器*，它们直接控制 I/O 设备的行为。这些是硬件的一部分。
- en: Although we could go through the chip’s 700-page reference manual to determine
    what registers to program, and then do all the calculations to figure out what
    values to program them with, this would take a lot of work.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管我们可以通过查看芯片的 700 页参考手册来确定需要编程的寄存器，然后进行所有计算以确定应该编程的值，但这将会非常繁琐。
- en: 'Instead, we can use the HAL software, and specifically the `HAL_Init` function,
    to do all that work for us. The `HAL_Init` function programs the system clock
    so we can use it later to time our LED. Insert a call to `HAL_Init` just after
    the first curly bracket in the `main` function, as follows:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，我们可以使用 HAL 软件，特别是 `HAL_Init` 函数，来为我们完成所有这些工作。`HAL_Init` 函数会编程系统时钟，这样我们以后就可以用它来控制
    LED 的定时。请在 `main` 函数的第一个大括号后插入对 `HAL_Init` 的调用，如下所示：
- en: '[PRE1]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: In general, it’s best practice to indent by four spaces for every set of curly
    brackets you use. The C language does not require this, but it makes understanding
    the program easier. (There’s nothing magical about four spaces. Some programs
    use two, some eight, and a few strange people use three.)
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 一般来说，最佳实践是每使用一对大括号就缩进四个空格。C 语言并不要求这样做，但这样可以让程序更易于理解。（四个空格并没有什么神奇之处。有些程序使用两个空格，有些使用八个空格，还有一些奇怪的人使用三个空格。）
- en: That takes care of the basic hardware.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 这就解决了基本硬件的问题。
- en: Programming a GPIO Pin
  id: totrans-69
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 编程 GPIO 引脚
- en: The chip has a number of *general-purpose input/output pins*, referred to as
    *GPIO pins*, which we can program to either receive input or send output for a
    variety of things. For example, we can program a pin for output and connect it
    to an LED (which is exactly what we’ll do in this program). Alternatively, we
    can program a pin for input and connect it to a switch (which we’ll do in the
    next chapter).
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 芯片有多个 *通用输入/输出引脚*，简称 *GPIO 引脚*，我们可以编程使其接收输入或发送输出，用于各种功能。例如，我们可以将一个引脚编程为输出，并将其连接到一个
    LED（这正是我们在本程序中要做的）。另外，我们可以将一个引脚编程为输入，并将其连接到开关（这将在下一章中进行）。
- en: Some of the microcontroller’s pins can be used as analog input or output. Most
    GPIO pins can be either on or off. Analog pins can handle voltages between on
    and off, such as 32765/65536 on. Others can be connected to a *USART* (serial
    I/O controller) or an *I2C bus* (simple I/O bus) to communicate with I2C peripheral
    chips. The good news is that these pins can do a lot of things. The bad news is
    that we have to program our chip to tell it, “Don’t do all that fancy stuff. Just
    turn on when I want you to turn on and turn off when I want you to turn off.”
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 一些微控制器的引脚可以用作模拟输入或输出。大多数 GPIO 引脚只能是开或关。模拟引脚可以处理开和关之间的电压，例如 32765/65536 开。其他引脚可以连接到
    *USART*（串行 I/O 控制器）或 *I2C 总线*（简单 I/O 总线）来与 I2C 外设芯片进行通信。好消息是这些引脚可以做很多事情。坏消息是我们必须编程告诉芯片，“不要做那些复杂的事情。当我想让你开时就开，想让你关时就关。”
- en: 'We will program the GPIO pin that is connected to the user LED (LED2). We need
    to tell the chip that we are using this pin for output; then we must tell it a
    lot about how we are going to use it. This includes setting up a GPIO clock, which
    controls how fast it reacts. The HAL firmware can do most of this work, but we
    have to tell the HAL what to do by passing a structure of configuration information
    to the `HAL_GPIO_Init` function (C’s structure concept is covered in more detail
    in Chapter 7):'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将编程连接到用户 LED（LED2）的 GPIO 引脚。我们需要告诉芯片，我们将此引脚用作输出；然后我们必须告诉它关于如何使用这个引脚的详细信息。这包括设置
    GPIO 时钟，它控制引脚响应的速度。HAL 固件可以完成大部分工作，但我们需要通过将配置结构信息传递给 `HAL_GPIO_Init` 函数来告诉 HAL
    要做什么（C 语言的结构概念将在第 7 章中详细介绍）：
- en: '[PRE2]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: We set the pin on in order to transmit data to `LED2_PIN`, which is the one
    connected to the user LED. Next, we specify that the pin will be used for output
    because we’re sending data to the LED rather than retrieving data, and we set
    the mode to push/pull. This mode is determined by what you connect to the output
    pin. In this case, our circuit needs push/pull. This option controls the internal
    hardware used to drive the GPIO pin. The STM chip reference shows you how this
    circuit is organized (or, better put, it shows your hardware person how the chip
    is organized, and they can tell you which mode to use).
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将引脚设置为开启状态，以便向`LED2_PIN`传输数据，该引脚连接到用户LED。接下来，我们指定该引脚将用于输出，因为我们是向LED发送数据，而不是获取数据，并将模式设置为推挽模式。这个模式由你连接到输出引脚的硬件决定。在这种情况下，我们的电路需要推挽模式。此选项控制用于驱动GPIO引脚的内部硬件。STM芯片参考资料展示了电路是如何组织的（或者说，它展示了给硬件工程师看芯片如何组织，然后他们会告诉你应该使用哪种模式）。
- en: The pullup flags configure the GPIO pin so that, in input mode, a pullup resister
    is part of the circuit. This is irrelevant for output pins, but it still needs
    to be set. We set it to `GPIO_PULLUP`, which means absolutely nothing. Finally,
    we set the speed to high with `GPIO_SPEED_FREQ_HIGH`.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 上拉标志配置GPIO引脚，使其在输入模式下有一个上拉电阻。对于输出引脚而言，这个设置无关紧要，但仍然需要设置。我们将其设置为`GPIO_PULLUP`，实际上这并没有任何意义。最后，我们通过`GPIO_SPEED_FREQ_HIGH`将速度设置为高。
- en: Toggling the LED
  id: totrans-76
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 切换LED
- en: 'Now remove the final `;` after the `for(;;)` statement. Remember that this
    semicolon essentially means “do nothing.” To introduce code that the `for` loop
    should execute, add these new lines:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 现在去掉`for(;;)`语句后的最后一个`;`。记住，这个分号基本上意味着“什么也不做”。为了引入`for`循环应该执行的代码，添加以下新行：
- en: '[PRE3]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The function `HAL_GPIO_TogglePin` toggles the `LED2` GPIO pin. On our chip,
    GPIO pins are organized into groups of 32 bits, collectively called a *GPIO register*.
    Our pin is in register `LED2_GPIO_PORT`. To tell the function which of the 32
    GPIO pins to toggle, we specify `LED2_PIN`.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: '`HAL_GPIO_TogglePin`函数切换`LED2` GPIO引脚。在我们的芯片中，GPIO引脚按32位一组组织，统称为*GPIO寄存器*。我们的引脚位于寄存器`LED2_GPIO_PORT`中。为了告诉函数切换哪一个32个GPIO引脚，我们指定了`LED2_PIN`。'
- en: After we toggle the pin, we need to do nothing for a while; otherwise, the LED
    will blink so fast we can’t see it. We use the `HAL_Delay` function to delay for
    400 milliseconds (ms).
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 切换引脚后，我们需要暂停一段时间；否则，LED会闪烁得太快，以至于我们看不见。我们使用`HAL_Delay`函数延迟400毫秒（ms）。
- en: Building the Completed Program
  id: totrans-81
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 构建完整的程序
- en: 'Our full program looks like this:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的完整程序如下所示：
- en: '[PRE4]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Now build the project by selecting **Project**▶**Build Project**. If everything
    went okay, you should see no problems in the Problems window. If there are problems,
    fix them and try again.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 现在通过选择**项目**▶**构建项目**来构建项目。如果一切顺利，你应该在问题窗口中看不到任何问题。如果有问题，修复它们然后再试一次。
- en: In the Console window, you’ll see that the IDE invoked `make`, which then invoked
    the GCC compiler named `arm-none-eabi-gcc`. This is the compiler for our embedded
    chip.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 在控制台窗口中，你会看到IDE调用了`make`，然后调用了名为`arm-none-eabi-gcc`的GCC编译器。这是我们嵌入式芯片的编译器。
- en: Start the program by selecting **Run**▶**Run**. (Be sure to click **Run** on
    the main menu. You can also right-click the project, but that runs a slightly
    different command.) The Run command hides a lot of work. First, the IDE checks
    whether the project needs to be built. Then it runs a program that takes the program
    file and communicates with the flash programmer on our development board to flash
    the program in memory. Finally, the programmer tells the chip to reset and start
    our program.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 通过选择**运行**▶**运行**来启动程序。（确保在主菜单上点击**运行**。你也可以右键点击项目，但那样会运行一个稍有不同的命令。）运行命令会隐藏许多操作。首先，IDE检查项目是否需要构建。然后，它运行一个程序，该程序获取程序文件并与开发板上的闪存编程器通信，将程序烧录到内存中。最后，编程器告诉芯片重置并启动我们的程序。
- en: As a result, you should see the green LED blink slowly.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 结果，你应该看到绿色LED缓慢闪烁。
- en: Exploring the Build Process
  id: totrans-88
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 探索构建过程
- en: The Console window shown in [Figure 3-9](#figure3-9) contains the output of
    the build process. (If this window is empty, you can re-create the contents with
    **Project**▶**Clean** followed by **Project**▶**Build Project**.)
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 如[图 3-9](#figure3-9)所示的控制台窗口包含了构建过程的输出。（如果该窗口为空，你可以通过**项目**▶**清理**，然后**项目**▶**构建项目**来重新创建内容。）
- en: '![f03009](image_fi/501621c03/f03009.png)'
  id: totrans-90
  prefs: []
  type: TYPE_IMG
  zh: '![f03009](image_fi/501621c03/f03009.png)'
- en: 'Figure 3-9: The Console window'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3-9：控制台窗口
- en: 'Let’s scroll up and look at one line in the build process, a typical invocation
    of the GCC compiler:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们向上滚动，看看构建过程中的一行，这是GCC编译器的典型调用：
- en: '[PRE5]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'This is a single line in the Console window, broken apart for formatting. As
    you can see, the compiler is being given a lot of additional options. The following
    are the key items on this command line:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 这是控制台窗口中的一行，为了格式化被拆分开来。如你所见，编译器被提供了许多额外的选项。以下是此命令行中的关键项目：
- en: '`arm-none-eabi-gcc` This is a GCC compiler, but unlike the native GCC, which
    compiles for your computer, it is a cross-compiler producing code for the ARM
    processor. There is no underlying operating system (hence the `none` option),
    and the system is designed for an embedded application binary interface (`eabi`),
    which defines how pieces of the program communicate with one another and with
    the outside world.'
  id: totrans-95
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`arm-none-eabi-gcc` 这是一个 GCC 编译器，但与本地 GCC 不同，本地 GCC 为计算机编译，而它是一个交叉编译器，为 ARM
    处理器生成代码。没有底层操作系统（因此使用 `none` 选项），该系统为嵌入式应用程序二进制接口（`eabi`）设计，定义了程序各部分如何与彼此及外部世界进行通信。'
- en: '`-mcpu=cortex-m0` This produces code for the `cortex-m0` version of the CPU.
    ARM has multiple processor variations, and this flag tells GCC which version to
    use.'
  id: totrans-96
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`-mcpu=cortex-m0` 生成适用于 `cortex-m0` 版本 CPU 的代码。ARM 有多个处理器版本，这个标志告诉 GCC 使用哪一个版本。'
- en: '`-mthumb` Some ARM processors can execute two different instruction sets. There
    is the full 32-bit RISC instruction set, which executes very quickly but uses
    lots and lots of memory, and there is the *thumb* set, which is slower but far
    more compact. This directive tells GCC that we want thumb code (a good idea if
    you are using a cheap chip with limited memory, which we are).'
  id: totrans-97
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`-mthumb` 一些 ARM 处理器可以执行两种不同的指令集。一个是完整的 32 位 RISC 指令集，执行速度非常快，但占用大量内存；另一个是
    *thumb* 指令集，执行速度较慢，但更加紧凑。此指令告诉 GCC 我们需要使用 thumb 代码（如果你使用的是内存有限的廉价芯片，这通常是个好主意，而我们正是使用这种芯片）。'
- en: '`-mfloat-abi=soft` Our processor does not have floating-point hardware, so
    this flag tells GCC to fake it with software. (More on floating point can be found
    in Chapter 16.)'
  id: totrans-98
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`-mfloat-abi=soft` 我们的处理器没有浮点硬件，因此这个标志告诉 GCC 用软件模拟浮点运算。（有关浮点运算的更多内容，请参见第 16
    章。）'
- en: '`-O0` Specifies level `0` (that is, no) optimization. This turns off a compiler
    feature where the compiler analyzes your code and performs all sorts of tricks
    to make it go faster. These tricks make the underlying code harder to understand
    and debug.'
  id: totrans-99
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`-O0` 指定优化级别为 `0`（即不优化）。这会关闭编译器的一个功能，避免编译器分析代码并执行各种加速代码的技巧。这些技巧使得底层代码更难以理解和调试。'
- en: '`-g3` Turns on debugging.'
  id: totrans-100
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`-g3` 启用调试功能。'
- en: '`-Wall` Turns on the set of warnings named `all`, which contains almost all
    of the useful warnings.'
  id: totrans-101
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`-Wall` 启用名为 `all` 的警告集合，其中包含几乎所有有用的警告。'
- en: '`-c` Compiles a single source file into a single object file.'
  id: totrans-102
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`-c` 将单个源文件编译为单个目标文件。'
- en: '`-o"HALDriver/Src/stm32f0xxll_tim.o"` Stores the object file in the given file.'
  id: totrans-103
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`-o"HALDriver/Src/stm32f0xxll_tim.o"` 将目标文件存储在指定文件中。'
- en: '`"../HALDriver/Src/stm32f0xxll_tim.c"` Specifies name of the source file.'
  id: totrans-104
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`"../HALDriver/Src/stm32f0xxll_tim.c"` 指定源文件的名称。'
- en: The other options tell the compiler where the included files are for the library
    and how these files should be configured. (We discuss the `-D` directive in Chapter
    12.) The `-I` directive tells the compiler to search for include files in the
    specified directory in addition to the standard include file directories.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 其他选项告诉编译器库的包含文件在哪里以及这些文件应如何配置。（第 12 章中我们将讨论 `-D` 指令。）`-I` 指令告诉编译器除标准包含文件目录外，还要在指定的目录中搜索包含文件。
- en: 'In addition to the compilation commands, we can see the linker command:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 除了编译命令外，我们还可以看到链接器命令：
- en: '[PRE6]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The key directive, `-T"/home/sdo/bare/workspace/blink/LinkerScript.ld"`, tells
    the linker to use *LinkerScript.ld* to tell it where to put the various pieces
    of the program. (This is discussed in detail in Chapter 11.)
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 关键指令 `-T"/home/sdo/bare/workspace/blink/LinkerScript.ld"` 告诉链接器使用 *LinkerScript.ld*
    来指定程序各部分的位置。（第 11 章中将详细讨论此内容。）
- en: 'The build process ends with the following two commands:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 构建过程以以下两个命令结束：
- en: '[PRE7]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The `arm-none-eabi-objcopy` command takes the *.elf* file and turns it into
    a raw binary image. ELF is a complex file format that tells the loader where to
    place various things. The raw binary image is exactly what’s going into your flash
    memory.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: '`arm-none-eabi-objcopy` 命令将 *.elf* 文件转换为原始二进制映像。ELF 是一种复杂的文件格式，它告诉加载器在哪里放置各种内容。原始二进制映像就是将写入闪存的内容。'
- en: Finally, `arm-none-eabi-size` prints out the size of the resulting program ([Table
    3-1](#table3-1)).
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，`arm-none-eabi-size` 打印出最终程序的大小（[表 3-1](#table3-1)）。
- en: 'Table 3-1: Program Memory Section Sizes'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 表 3-1：程序内存段大小
- en: '| **Segment** | **Description** |'
  id: totrans-114
  prefs: []
  type: TYPE_TB
  zh: '| **段** | **描述** |'
- en: '| --- | --- |'
  id: totrans-115
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `text` | Size of read-only data (goes into flash) |'
  id: totrans-116
  prefs: []
  type: TYPE_TB
  zh: '| `text` | 只读数据的大小（进入闪存） |'
- en: '| `data` | Size of read/write data that requires initialization (goes into
    RAM) |'
  id: totrans-117
  prefs: []
  type: TYPE_TB
  zh: '| `data` | 需要初始化的读/写数据的大小（进入 RAM） |'
- en: '| `bss` | Size of read/write data that is initialized to zero (goes into RAM)
    |'
  id: totrans-118
  prefs: []
  type: TYPE_TB
  zh: '| `bss` | 初始化为零的读/写数据的大小（进入 RAM） |'
- en: '| `dec` | Total size in decimal |'
  id: totrans-119
  prefs: []
  type: TYPE_TB
  zh: '| `dec` | 十进制总大小 |'
- en: '| `hex` | Total size in hexadecimal |'
  id: totrans-120
  prefs: []
  type: TYPE_TB
  zh: '| `hex` | 十六进制总大小 |'
- en: We will explore the different types of memory, like flash and RAM, in later
    chapters. For now, understand that this step is done to answer the question, “If
    I keep programming, when will I run out of memory?”
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在后续章节中探索不同类型的内存，如闪存和 RAM。目前，理解这一点：此步骤是为了回答问题，“如果我继续编程，什么时候内存会用尽？”
- en: Exploring the Project Files
  id: totrans-122
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 探索项目文件
- en: System Workbench for STM32 has created and downloaded a lot of files for our
    project. Let’s go through the key files.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: STM32 的系统工作台已经为我们的项目创建并下载了许多文件。让我们来查看这些关键文件。
- en: We can view our *src* directory by clicking the triangle next to the directory
    name. It contains the files listed in [Table 3-2](#table3-2).
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过点击目录名称旁边的三角形来查看我们的 *src* 目录。它包含了 [表 3-2](#table3-2) 中列出的文件。
- en: 'Table 3-2: The *src* Directory Files'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 表 3-2：*src* 目录文件
- en: '| **File** | **Description** |'
  id: totrans-126
  prefs: []
  type: TYPE_TB
  zh: '| **文件** | **描述** |'
- en: '| --- | --- |'
  id: totrans-127
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| *main.c* | The main program, where all our code goes. |'
  id: totrans-128
  prefs: []
  type: TYPE_TB
  zh: '| *main.c* | 主程序，我们的所有代码都在这里。 |'
- en: '| *stm32f0xxit.c* | The interrupt service routines. You will learn about interrupts
    in Chapter 10. For this simple program, the only interrupt we care about is the
    system clock, and even then, we don’t see the details of it directly. It’s used
    by `HAL_Delay`. |'
  id: totrans-129
  prefs: []
  type: TYPE_TB
  zh: '| *stm32f0xxit.c* | 中断服务例程。你将在第 10 章学习关于中断的知识。对于这个简单的程序，我们关心的唯一中断是系统时钟，即便如此，我们也不会直接看到它的细节。它被
    `HAL_Delay` 使用。 |'
- en: '| *syscalls.c* | Dummy functions that are not used. |'
  id: totrans-130
  prefs: []
  type: TYPE_TB
  zh: '| *syscalls.c* | 不使用的虚拟函数。 |'
- en: '| *Systemstm32f0xx.c* | Code that supports the system clock (explained in later
    chapters). |'
  id: totrans-131
  prefs: []
  type: TYPE_TB
  zh: '| *Systemstm32f0xx.c* | 支持系统时钟的代码（将在后面的章节中解释）。 |'
- en: 'The *startup* directory contains one file: *startup_stm32f030x8.S*. This is
    an assembly language file that performs just enough initialization that the processor
    can run C code; it then jumps to the C startup code. This program contains the
    first instruction executed when you press the reset button.'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: '*startup* 目录包含一个文件：*startup_stm32f030x8.S*。这是一个汇编语言文件，执行足够的初始化操作，使得处理器可以运行
    C 代码；然后跳转到 C 启动代码。这是按下复位按钮时执行的第一条指令。'
- en: The *inc* directory contains one file, *stm32f0xx_it.h*, which is used to tell
    other programs about the interrupt handlers in *stm32f0xx_it.c*. It’s a very small
    and boring file.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: '*inc* 目录包含一个文件 *stm32f0xx_it.h*，用于告诉其他程序关于 *stm32f0xx_it.c* 中的中断处理程序。这是一个非常小且无聊的文件。'
- en: Now we come to the *HAL_Driver* directory. This directory contains approximately
    130 files that provide a HAL library for use in the program. The HAL hides (abstracts)
    the fact that different ARM CPUs have different capabilities. For example, the
    function `HAL_Init` will initialize all the hardware. If you have a Cortex-M0
    processor, the Cortex-M0 version will initialize all the Cortex-M0 hardware. If
    you have a Cortex-M4 processor, all the Cortex-M4 hardware will be set up. There
    are so many files in this directory because the board we are using has lots of
    hardware. (And this is the simple version of the system.)
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们来看 *HAL_Driver* 目录。这个目录包含大约 130 个文件，这些文件提供了一个 HAL 库，可供程序使用。HAL 隐藏了不同 ARM
    CPU 具有不同能力的事实。例如，`HAL_Init` 函数将初始化所有硬件。如果你使用的是 Cortex-M0 处理器，Cortex-M0 版本将初始化所有
    Cortex-M0 硬件。如果你使用的是 Cortex-M4 处理器，所有 Cortex-M4 硬件将被设置。这个目录中有这么多文件，因为我们使用的板子有许多硬件。（而且这是系统的简化版本。）
- en: The *CMSIS* directory contains low-level code designed to support the HAL layer.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: '*CMSIS* 目录包含了旨在支持 HAL 层的低级代码。'
- en: Finally, the *Debug* directory contains all the files related to our Debug build.
    In particular, it contains a `make` input file called *Makefile* and some generated
    files (see [Table 3-3](#table3-3)).
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，*Debug* 目录包含所有与调试构建相关的文件。特别是，它包含一个名为 *Makefile* 的 `make` 输入文件和一些生成的文件（参见
    [表 3-3](#table3-3)）。
- en: 'Table 3-3: Generated Files in the *Debug* Directory'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 表 3-3：*Debug* 目录中的生成文件
- en: '| **File** | **Description** |'
  id: totrans-138
  prefs: []
  type: TYPE_TB
  zh: '| **文件** | **描述** |'
- en: '| --- | --- |'
  id: totrans-139
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| *blink.elf* | Our program in ELF format (a file format for executables) |'
  id: totrans-140
  prefs: []
  type: TYPE_TB
  zh: '| *blink.elf* | 我们的 ELF 格式程序（可执行文件格式） |'
- en: '| *blink.bin* | Our program as a memory image (raw code) |'
  id: totrans-141
  prefs: []
  type: TYPE_TB
  zh: '| *blink.bin* | 我们的程序的内存映像（原始代码） |'
- en: '| *output.map* | The memory map for the program |'
  id: totrans-142
  prefs: []
  type: TYPE_TB
  zh: '| *output.map* | 程序的内存映射 |'
- en: 'The last file on our list is at the top level: *LinkerScript.ld*. It tells
    the linker what the memory layout of our chip looks like and where to load the
    various pieces of the program. More on this in Chapter 11.'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 我们列表中的最后一个文件是顶层文件：*LinkerScript.ld*。它告诉链接器我们的芯片内存布局是什么样的，以及在哪里加载程序的各个部分。更多内容将在第11章介绍。
- en: Debugging the Application
  id: totrans-144
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 调试应用程序
- en: Our blink program is simple and it works, but later we’re going to make more
    complex programs, and they will have bugs in them. Since the board we are programming
    has such a good debugger, we might as well get started learning how to use it.
    Start the debugger by selecting **Run**▶**Debug**, as shown in [Figure 3-10](#figure3-10).
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的闪烁程序很简单且能正常工作，但以后我们会写更复杂的程序，而这些程序中会有bug。由于我们正在编程的板子有一个如此强大的调试器，不妨从现在开始学习如何使用它。通过选择**运行**▶**调试**来启动调试器，如[图
    3-10](#figure3-10)所示。
- en: '![f03010](image_fi/501621c03/f03010.png)'
  id: totrans-146
  prefs: []
  type: TYPE_IMG
  zh: '![f03010](image_fi/501621c03/f03010.png)'
- en: 'Figure 3-10: Starting the debugger'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3-10：启动调试器
- en: The IDE will then ask you for what type of debugger to run, as shown in [Figure
    3-11](#figure3-11). Select **Ac6 STM32 C/C++ Application**.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，IDE会询问您要运行什么类型的调试器，如[图 3-11](#figure3-11)所示。请选择**Ac6 STM32 C/C++ 应用程序**。
- en: '![f03011](image_fi/501621c03/f03011.png)'
  id: totrans-149
  prefs: []
  type: TYPE_IMG
  zh: '![f03011](image_fi/501621c03/f03011.png)'
- en: 'Figure 3-11: Debugger selection'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3-11：调试器选择
- en: 'The system will ask if you want to “Switch to the Debug Perspective.” Answer
    **Yes**. The system then goes through a number of steps automatically:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 系统会询问是否要“切换到调试视图”。请选择**是**。系统随后会自动执行若干步骤：
- en: It builds the software.
  id: totrans-152
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 它构建了软件。
- en: The IDE downloads the program to the chip using the flash programmer.
  id: totrans-153
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: IDE通过闪存编程器将程序下载到芯片。
- en: A debugger is attached to the device through the JTAG interface.
  id: totrans-154
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 调试器通过JTAG接口附加到设备。
- en: The debugger sets a breakpoint at the first line of `main`.
  id: totrans-155
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 调试器在`main`的第一行设置了断点。
- en: The breakpoint tells the chip to stop just before the first line of `main` is
    executed.
  id: totrans-156
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 断点告诉芯片在执行`main`的第一行之前停止。
- en: The microprocessor resets, and the program runs up to `main`.
  id: totrans-157
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 微处理器复位，程序运行到`main`。
- en: The debugger regains control when the program reaches the breakpoint at `main`.
  id: totrans-158
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当程序执行到`main`的断点时，调试器重新获得控制权。
- en: Once the debugger reaches the breakpoint, you are ready to debug the program,
    as seen in [Figure 3-12](#figure3-12). At this point, the program has executed
    until the first statement of the `main` function and is paused before the call
    to `HAL_Init`.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦调试器到达断点，您就准备好调试程序，如[图 3-12](#figure3-12)所示。此时，程序已经执行到`main`函数的第一条语句，并在调用`HAL_Init`之前暂停。
- en: '![f03012](image_fi/501621c03/f03012.png)'
  id: totrans-160
  prefs: []
  type: TYPE_IMG
  zh: '![f03012](image_fi/501621c03/f03012.png)'
- en: 'Figure 3-12: Debugging the program'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3-12：调试程序
- en: Now that we’ve got control, let’s use it. Use the command **Run**▶**Step Over**
    to start executing the program one line at a time. We’ll do this a number of times,
    so remember the shortcut key F6\. Keep stepping over lines using F6 until you
    get into the `for` loop.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经掌控了控制权，接下来就用它。使用命令**运行**▶**单步跳过**来逐行执行程序。我们会执行多次，所以记得快捷键是F6。继续使用F6单步跳过，直到进入`for`循环。
- en: Notice that every time you execute the `HAL_GPIO_TogglePin(LED2_GPIO_PORT, LED2_PIN)`
    function, the LED turns on or off. Since you are in the `for` loop, you ping-pong
    back and forth indefinitely between the toggling and the delay. If you are really
    observant, you’ll notice that it takes a little over 400 ms (two-fifths of a second)
    to execute the call to `HAL_Delay`. You can change this value to something really
    big if you would like to better observe the delay.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，每次执行`HAL_GPIO_TogglePin(LED2_GPIO_PORT, LED2_PIN)`函数时，LED会开或关。由于您处于`for`循环中，您会在切换和延迟之间不断来回。如果您足够细心，您会注意到执行`HAL_Delay`调用大约需要400毫秒（即两分之五秒）。如果您想更清楚地观察延迟，可以将该值更改为一个更大的值。
- en: Stepping Through the Program
  id: totrans-164
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 单步执行程序
- en: Now we’ll get into some of the details of this program. Most of the concepts
    are covered in more depth in future chapters, but I’ll give you a taste of them
    now. First, let’s abort the current debugging session with **Run**▶**Terminate**.
    Now let’s start all over again, with **Run**▶**Debug**. You should be back to
    the line that calls `HAL_Init`. To step through the program, use a different command,
    **Run**▶**Step Into** (or shortcut key F5).
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将深入了解这个程序的一些细节。大多数概念将在后面的章节中更深入地讲解，但我现在会给你一个初步的了解。首先，让我们用**运行**▶**终止**来中止当前的调试会话。现在，我们重新开始，选择**运行**▶**调试**。你应该会回到调用`HAL_Init`的那一行。要逐步执行程序，使用另一个命令，**运行**▶**逐过程执行**（或快捷键F5）。
- en: All of a sudden, the file *stm32f0xx_hal.c* appears in our editing window (see
    [Figure 3-13](#figure3-13)). Where did this file come from?
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 突然，文件*stm32f0xx_hal.c*出现在我们的编辑窗口中（参见[图3-13](#figure3-13)）。这个文件是从哪里来的？
- en: '![f03013](image_fi/501621c03/f03013.png)'
  id: totrans-167
  prefs: []
  type: TYPE_IMG
  zh: '![f03013](image_fi/501621c03/f03013.png)'
- en: 'Figure 3-13: Debugging *stm32f0xx_hal.c*'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 图3-13：调试*stm32f0xx_hal.c*
- en: Well, we called the procedure `HAL_Init`. That procedure is defined in *stm32f0xx_hal.c*,
    so the debugger automatically opened that file when we stepped into the call to
    `HAL_Init`. Alternatively, the Step Over command would treat the statement (in
    this case, `HAL_INIT();`) as a single unit and step over the function, hiding
    all the details.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 我们调用的过程是`HAL_Init`。该过程在*stm32f0xx_hal.c*中定义，因此当我们进入`HAL_Init`调用时，调试器会自动打开这个文件。或者，使用“Step
    Over”命令会将该语句（在本例中为`HAL_INIT();`）视为一个整体并跳过该函数，隐藏所有细节。
- en: The Step Into command knows we are calling a function and steps into its code.
    As you can see, it takes a lot of extra code to support our little program. When
    you program on a PC, the code is hidden from you, and it’s very difficult to get
    its source. The STM32 Workbench supplies all that code for you in the *HAL_Driver/Src*
    directory.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: “Step Into”命令知道我们正在调用一个函数，并进入它的代码。如你所见，支持我们这个小程序需要大量额外的代码。当你在PC上编程时，代码对你是隐藏的，很难获取其源代码。STM32工作台在*HAL_Driver/Src*目录中为你提供了所有这些代码。
- en: In addition to showing the code inside functions, the debugger can show us the
    status of all program variables. To see this in action, select **Run**▶**Step
    Over** (or press F6) about half a dozen times until you wind up back in *main.c*
    at the line that selects the pin to use. In the upper-right corner of the screen,
    you’ll see a panel titled Variables (see [Figure 3-14](#figure3-14)).
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 除了显示函数内部的代码，调试器还可以显示我们程序中所有变量的状态。要看到这一点，选择**运行**▶**逐过程执行**（或按F6键）大约六次，直到你回到*main.c*中的那一行，选择要使用的引脚。在屏幕的右上角，你会看到一个标题为“变量”的面板（参见[图3-14](#figure3-14)）。
- en: '![f03014](image_fi/501621c03/f03014.png)'
  id: totrans-172
  prefs: []
  type: TYPE_IMG
  zh: '![f03014](image_fi/501621c03/f03014.png)'
- en: 'Figure 3-14: The Variables panel'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 图3-14：变量面板
- en: In our program, we’ve defined a variable called `GPIO_InitStruct`. In the Variables
    panel, the + before the name indicates that `GPIO_InitStruct` is a *complex* variable,
    which means that it contains more than a simple integer, Boolean, or other single
    value. To see the all the components inside, expand it by clicking the + icon
    (see [Figure 3-15](#figure3-15)).
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的程序中，我们定义了一个名为`GPIO_InitStruct`的变量。在变量面板中，名称前面的+号表示`GPIO_InitStruct`是一个*复杂*变量，这意味着它不仅仅包含一个简单的整数、布尔值或其他单一的值。要查看其中的所有组件，可以通过点击+图标来展开它（参见[图3-15](#figure3-15)）。
- en: '![f03015](image_fi/501621c03/f03015.png)'
  id: totrans-175
  prefs: []
  type: TYPE_IMG
  zh: '![f03015](image_fi/501621c03/f03015.png)'
- en: 'Figure 3-15: An expanded variable'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 图3-15：展开的变量
- en: 'You’ll learn about the components of `GPIO_InitStruct`, and how to create variables
    yourself, in later chapters. The `GPIO_InitStruct` variable was created by a programmer
    who read the 700-page reference manual on our chip and designed a variable to
    hold this information. Believe it or not, this variable significantly simplifies
    what’s presented in the manual: about 30 pages of compressed technical information
    on just the GPIO subsystem.'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 你将在后面的章节中学习到`GPIO_InitStruct`的各个组件，以及如何自己创建变量。`GPIO_InitStruct`变量是由一位程序员创建的，他阅读了我们芯片的700页参考手册，并设计了一个变量来存储这些信息。不管你信不信，这个变量大大简化了手册中呈现的内容：仅关于GPIO子系统的技术信息就压缩了大约30页。
- en: Now step through the next few statements to see the values of the components
    of this variable.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 现在逐步执行接下来的几条语句，以查看该变量各个组件的值。
- en: Summary
  id: totrans-179
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 总结
- en: I’ve tried to make this program as simple as possible, but as you can see, with
    today’s complex chips, even the simplest operation takes a bit of work. Getting
    a program running requires a lot of support.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 我尽量使这个程序尽可能简单，但正如你所看到的，今天的复杂芯片即使是最简单的操作也需要一些工作。让程序运行需要大量的支持。
- en: In the first chapter, our “Hello World” program required pretty much the same
    number of files mentioned here, but they existed behind the scenes. For example,
    the initialization file was installed as part of the GCC package. In our blink
    project, the file *startup_stm32f030x8.S* must be explicitly included.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一章中，我们的“Hello World”程序需要的文件数量与这里提到的差不多，但它们是隐式存在的。例如，初始化文件作为GCC包的一部分安装。在我们的闪烁项目中，文件*startup_stm32f030x8.S*必须显式包含。
- en: This chapter threw a ton of new concepts at you. Don’t worry if you don’t understand
    them all yet. We’ll dive deeper into them in future chapters.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 本章给你带来了大量的新概念。如果你还不完全理解它们，别担心，我们将在后续章节深入探讨。
- en: Programming Problems
  id: totrans-183
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 编程问题
- en: Experiment with changing the delay in the `Hal_Delay();` statement to make the
    blink frequency longer and shorter.
  id: totrans-184
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 尝试更改`Hal_Delay();`语句中的延迟，以使闪烁频率变长或变短。
- en: 'Examine *LinkerScript.ld* to find the answers to the following questions:'
  id: totrans-185
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 查看*LinkerScript.ld*以找到以下问题的答案：
- en: How much flash (read-only) memory do you have?
  id: totrans-186
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你有多少闪存（只读存储）？
- en: How much RAM (read/write memory) do you have?
  id: totrans-187
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你有多少RAM（读/写内存）？
- en: Examine the file *output.map* and determine the actual address of `Reset_Handler`.
  id: totrans-188
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 查看文件*output.map*并确定`Reset_Handler`的实际地址。
- en: 'For intermediate readers: Change the program so it turns the LED on for a short
    time, then off for a longer time.'
  id: totrans-189
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于中级读者：修改程序，使其先将LED打开一段短时间，然后再长时间关闭。
- en: Questions
  id: totrans-190
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 问题
- en: What files are generated by the IDE, and what do they contain?
  id: totrans-191
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: IDE生成了哪些文件，它们包含了什么？
- en: Where on your system did the IDE stash the compiler?
  id: totrans-192
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在你的系统中，IDE将编译器存放在哪里？
- en: What does a commercial JTAG debugger look like? How much does it cost? What
    does it take to hook it up to a typical development board? (And be glad you got
    an integrated system!)
  id: totrans-193
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 商用JTAG调试器是什么样子的？它多少钱？如何将其连接到典型的开发板上？（而且，庆幸你得到了一个集成系统！）
