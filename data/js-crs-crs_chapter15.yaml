- en: <hgroup>
  id: totrans-0
  prefs: []
  type: TYPE_NORMAL
  zh: <hgroup>
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">15</samp> <samp class="SANS_Dogma_OT_Bold_B_11">VISUALIZING
    DATA FROM THE GITHUB SEARCH API</samp>
  id: totrans-1
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">15</samp> <samp class="SANS_Dogma_OT_Bold_B_11">从
    GitHub 搜索 API 可视化数据</samp>
- en: </hgroup>
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: </hgroup>
- en: '![](../images/opener.png)'
  id: totrans-3
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/opener.png)'
- en: In this final project, you’ll build an application that reads data from a public
    API and uses D3 to build an interactive bar chart based on that data. We’ll be
    reading data from the GitHub Search API. This API allows you to search for data
    on GitHub, a service that hosts Git repositories (Git is a popular version control
    system for keeping track of software project source code). The API uses the HTTPS
    protocol and returns JSON-formatted data based on a search query you encode into
    a URL.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个最终项目中，你将构建一个应用程序，从公共 API 中读取数据，并使用 D3 基于这些数据构建一个交互式条形图。我们将从 GitHub 搜索 API
    中读取数据。这个 API 允许你在 GitHub 上搜索数据，GitHub 是一个托管 Git 仓库的服务（Git 是一种流行的版本控制系统，用于跟踪软件项目的源代码）。该
    API 使用 HTTPS 协议，并根据你编码到 URL 中的搜索查询返回 JSON 格式的数据。
- en: If you haven’t used GitHub before, go to [*https://<wbr>github<wbr>.com*](https://github.com)
    to see what it looks like. At the top of the page, you’ll see a search box that
    you can use to search for public, *open source* repositories (that is, repositories
    whose source code is available to anyone to read and use). Instead of using that
    search box manually, the GitHub Search API lets us perform searches programmatically—for
    example, with JavaScript. The API can search for various items on GitHub, such
    as repositories, users, and issues. We’ll be using the repository search feature
    to find top JavaScript repositories. Then we’ll draw a D3 bar chart ranking the
    repositories by popularity. The viewer will be able to learn more about each repository
    by hovering over its bar. We’ll also add some interactivity by allowing the viewer
    to hide or show repositories based on their software license.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你以前没有使用过 GitHub，可以访问[*https://<wbr>github<wbr>.com*](https://github.com)查看它的样子。在页面的顶部，你会看到一个搜索框，你可以用它来搜索公共的，*开源*代码库（即，源代码对任何人开放阅读和使用的代码库）。GitHub
    搜索 API 允许我们以编程方式进行搜索——例如，使用 JavaScript，而不是手动使用该搜索框。该 API 可以搜索 GitHub 上的各种项目，如代码库、用户和问题。我们将使用代码库搜索功能来查找流行的
    JavaScript 代码库。然后，我们将绘制一个 D3 条形图，根据流行程度对这些代码库进行排名。用户可以通过悬停在条形图上，了解每个代码库的更多信息。我们还将通过允许用户根据软件许可证来隐藏或显示代码库，增加一些互动性。
- en: This project will give you experience working with real-world data from a JSON
    API. A huge amount of programming boils down to making requests to third-party
    APIs and then doing some work with the returned data, as you’ll practice here.
    You’ll also put everything you learned about D3 in [Chapter 14](chapter14.xhtml)
    to work, building up a more interesting, interactive chart, and you’ll learn some
    techniques for creating richer visualizations.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 这个项目将让你获得使用 JSON API 中实际数据的经验。大量的编程工作都归结为向第三方 API 发出请求，然后对返回的数据进行处理，正如你在这里所实践的那样。你还将把你在[第
    14 章](chapter14.xhtml)中学到的关于 D3 的所有内容付诸实践，构建一个更有趣、互动性更强的图表，并学习一些技术，用于创建更丰富的可视化效果。
- en: <samp class="SANS_Futura_Std_Bold_B_11">Setting Up</samp>
  id: totrans-7
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">设置</samp>
- en: To get started, create a new directory called *github*, and add empty *style.css*
    and *script.js* files. Then make an *index.html* file and add the code in [Listing
    15-1](#Lis15-1).
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 要开始，创建一个名为 *github* 的新目录，并添加空的 *style.css* 和 *script.js* 文件。然后创建一个 *index.html*
    文件，并添加[列表 15-1](#Lis15-1)中的代码。
- en: '[PRE0]'
  id: totrans-9
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 15-1: An</samp> <samp
    class="SANS_Futura_Std_Book_11">index.html</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">file
    for our GitHub Search API visualization</samp>'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">列表 15-1：我们的 GitHub 搜索 API 可视化的</samp>
    <samp class="SANS_Futura_Std_Book_11">index.html</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">文件</samp>
- en: This is the same basic HTML file we used in [Chapter 14](chapter14.xhtml). It
    gives us access to D3 through a script element linking to a copy of the library
    on [*https://<wbr>unpkg<wbr>.com*](https://unpkg.com).
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们在[第 14 章](chapter14.xhtml)中使用的相同基本 HTML 文件。它通过一个脚本元素链接到 [*https://<wbr>unpkg<wbr>.com*](https://unpkg.com)，使我们能够访问
    D3 库。
- en: <samp class="SANS_Futura_Std_Bold_B_11">Fetching Data</samp>
  id: totrans-12
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">获取数据</samp>
- en: 'Now let’s try getting some data from the GitHub Search API. To do this, we
    need to format our request for data as part of a URL. Visiting that URL retrieves
    the data. The whole URL, including the search query we’ll be using, looks like
    this (note that it’s been broken onto two lines here to fit the page):'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们尝试从 GitHub 搜索 API 获取一些数据。为此，我们需要将我们的数据请求格式化为 URL 的一部分。访问该 URL 即可检索数据。整个
    URL（包括我们将使用的搜索查询）如下所示（请注意，为了适应页面，它已经被分成了两行）：
- en: '[PRE1]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Rather than type out the URL manually, however, we’ll build it up using JavaScript,
    which will make it easier to understand and modify.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，我们不会手动输入 URL，而是通过 JavaScript 来构建它，这样更容易理解和修改。
- en: 'The URL has two parts: a base URL, which gives us access to the API, and a
    query string, where we specify what data we want. These two parts are separated
    by a question mark (?). The query string contains pairs of keys and values that
    are used to send information to the API about the query we’re making. Each key
    and value is joined by an equal sign (=), and each key-value pair is separated
    by an ampersand (&). In this URL, the keys are q (search query), per_page (number
    of results per page), and sort (how to sort the results). The keys and values
    in query strings are allowed to contain only a limited set of characters: a–z,
    A–Z, 0–9, hyphen (-), period (.), underscore (_), tilde (~), and a limited set
    of other special characters. All other characters must be represented using the
    *URL encoding* system, which is where all the percent (%) characters in the URL
    come from. For example, a colon (:) is encoded as %3A and a space is encoded as
    %20.'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: URL 有两个部分：一个是基础 URL，它让我们可以访问 API，另一个是查询字符串，指定我们想要的数据。这两部分由问号（?）分隔。查询字符串包含一对对的键值对，用于向
    API 发送我们查询的信息。每个键和值通过等号（=）连接，每对键值对之间由和号（&）分隔。在这个 URL 中，键有 q（搜索查询）、per_page（每页的结果数量）和
    sort（如何排序结果）。查询字符串中的键和值只能包含有限的字符集：a–z、A–Z、0–9、连字符（-）、句点（.）、下划线（_）、波浪号（~）和一些其他特殊字符。所有其他字符必须通过*URL
    编码*系统表示，这就是 URL 中所有百分号（%）字符的来源。例如，冒号（:）编码为 %3A，空格编码为 %20。
- en: To simplify things, we’ll write a function that takes an object with the unencoded
    query string parameters and converts it to a properly formatted and encoded URL.
    Add the code in [Listing 15-2](#Lis15-2) to *script.js*.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 为了简化操作，我们将编写一个函数，它接受一个包含未编码查询字符串参数的对象，并将其转换为正确格式化和编码的 URL。将 [Listing 15-2](#Lis15-2)
    中的代码添加到 *script.js* 文件中。
- en: '[PRE2]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 15-2: Creating the
    URL</samp>'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 15-2: 创建 URL</samp>'
- en: The code to create the URL lives in the getUrl function. This function first
    sets the base URL (the part of the URL before the query string) ❶. Then, to build
    the query string, we start by creating a params object ❷, with the search query
    q using GitHub’s search query format. Specifically, we’re searching for repositories
    whose language is JavaScript that have over 10,000 stars (users on GitHub can
    “star” repositories to save them for later, so the number of stars is a rough
    measure of popularity). You can try out this query in the search box on [*https://<wbr>github<wbr>.com*](https://github.com)
    if you want.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 创建 URL 的代码位于 getUrl 函数中。这个函数首先设置基础 URL（查询字符串之前的部分）❶。然后，为了构建查询字符串，我们通过创建一个 params
    对象 ❷ 来开始，其中包含搜索查询 q，采用 GitHub 的搜索查询格式。具体来说，我们正在搜索语言为 JavaScript 的、星标数超过 10,000
    的仓库（GitHub 用户可以为仓库添加“星标”，以便稍后查看，因此星标数是受欢迎程度的粗略衡量标准）。如果你想尝试这个查询，可以在 [*https://<wbr>github<wbr>.com*](https://github.com)
    的搜索框中输入。
- en: Next, we map over the key-value pairs in params, creating a string for each
    pair with the format "key=value" ❸. The keys don’t need to be URL-encoded—unquoted
    object keys don’t contain any special characters, so they’re already valid in
    URLs—but we encode the values using the built-in function encodeURIComponent,
    which replaces any disallowed characters with their percent-encoded versions.
    We then join the strings together, separating them with the & character, and build
    and return the final URL by combining the base URL, the ? character, and the query
    string ❹. We end the script by calling our getUrl function and logging the result
    to the console.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们遍历 params 中的键值对，为每对键值对创建一个格式为 "key=value" 的字符串 ❸。键不需要进行 URL 编码——未加引号的对象键不包含特殊字符，因此它们已经是有效的
    URL 组成部分——但我们使用内建函数 encodeURIComponent 来编码值，该函数将任何不允许的字符替换为其百分号编码版本。然后，我们将这些字符串连接起来，用
    & 字符分隔，并通过将基础 URL、? 字符和查询字符串组合起来，构建并返回最终的 URL ❹。最后，我们通过调用 getUrl 函数并将结果输出到控制台来结束脚本。
- en: When you load the page and open the console, you should see the URL shown earlier
    printed there. If you copy that URL and paste it into your browser’s address bar,
    you should see a bunch of JSON data. If not, make sure the URL matches the URL
    on the previous page, and check your code if it doesn’t. If the URL looks correct
    and you’re not getting data, or you’re getting an error message, it’s possible
    that GitHub has changed the way its API works. See the upcoming box “Authenticated
    vs. Unauthenticated APIs” for guidance on what to do in this case.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 当你加载页面并打开控制台时，你应该能看到之前显示的 URL。如果你复制那个 URL 并将其粘贴到浏览器的地址栏中，你应该能看到一堆 JSON 数据。如果没有，确保
    URL 与上一页上的 URL 匹配，并检查你的代码是否有问题。如果 URL 看起来正确而你没有获取到数据，或者你收到了错误信息，可能是 GitHub 改变了其
    API 的工作方式。有关此情况的处理方法，请参见下面的“认证 API 与非认证 API”部分。
- en: To bring the JSON data into your application you can use D3’s json helper method,
    which fetches JSON from a given URL. Update the end of *script.js* as shown in
    [Listing 15-3](#Lis15-3).
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 要将 JSON 数据导入你的应用程序，你可以使用 D3 的 json 辅助方法，它从给定的 URL 获取 JSON。按照 [Listing 15-3](#Lis15-3)
    中的示例更新 *script.js* 的结尾部分。
- en: '[PRE3]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 15-3: Fetching JSON
    data</samp>'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 15-3: 获取 JSON 数据</samp>'
- en: Fetching a bunch of data from an API may take a little time, so the d3.json
    method returns a Promise, a type of object that represents something that will
    be available in the future. The then method takes a function that will be called
    when the data is ready. D3 converts the JSON response string into a JavaScript
    object, so data will be an object. Here, we just log it to the console.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 从 API 获取大量数据可能需要一点时间，因此 d3.json 方法返回一个 Promise，这是一种代表将来某个时间会得到的对象类型。then 方法接受一个函数，当数据准备好时会调用该函数。D3
    将 JSON 响应字符串转换为 JavaScript 对象，因此 data 将是一个对象。在这里，我们只是将其日志记录到控制台。
- en: 'When you reload the page, after waiting a few seconds you should see the data
    in the console. Take a moment to inspect it. You should see three top-level properties:
    incomplete_results, items, and total_count. The incomplete _results property will
    be true if the query took too long and the API was able to return only partial
    results; otherwise, it will be false. The total_count property gives the total
    number of results for this search query (this is the total number of results the
    search found, of which only the first 20 are returned). The items array contains
    the results of the current call; it should contain 20 items. Each item is an object
    with some information about a particular repository, including its name, description,
    and various other details. Several of the fields are themselves GitHub API URLs
    that can be called to get additional information about the repository. For example,
    languages_url is an API URL that tells you what programming languages are used
    in the repository, broken down by the number of lines of code per language.'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 当你重新加载页面后，等待几秒钟，你应该能在控制台看到数据。花点时间检查它。你应该能看到三个顶级属性：incomplete_results、items 和
    total_count。如果查询耗时过长并且 API 只能返回部分结果，则 incomplete _results 属性为 true；否则，它为 false。total_count
    属性提供此搜索查询的结果总数（这是搜索找到的所有结果的总数，其中只有前 20 条结果被返回）。items 数组包含当前调用的结果；它应该包含 20 条数据。每个条目是一个对象，包含关于特定仓库的一些信息，包括其名称、描述以及各种其他细节。几个字段本身就是
    GitHub API URL，可以调用它们获取仓库的更多信息。例如，languages_url 是一个 API URL，它告诉你该仓库中使用了哪些编程语言，并按每种语言的代码行数进行细分。
- en: 'In this project, we’ll be using several fields from each item: full_name, stargazers_count,
    html_url, and license. The full_name field holds the name of the repository owner
    and the name of the repository joined with a forward slash: for example, "facebook/react".
    The stargazers_count field gives the number of times the repository has been starred
    by users. The html_url field holds the repository’s URL on GitHub. Finally, license
    has data about which software license the repository uses.'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个项目中，我们将使用每个条目的几个字段：full_name、stargazers_count、html_url 和 license。full_name
    字段包含仓库所有者的名称和仓库名称，它们用斜杠连接：例如，“facebook/react”。stargazers_count 字段提供仓库被用户标星的次数。html_url
    字段包含仓库在 GitHub 上的 URL。最后，license 字段提供有关仓库使用的哪个软件许可证的数据。
- en: <samp class="SANS_Dogma_OT_Bold_B_21">NOTE</samp>
  id: totrans-29
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: <samp class="SANS_Dogma_OT_Bold_B_21">注意</samp>
- en: '*Open source code owners use software licenses to tell other users what they
    can and can’t do with their code. For example, some licenses are very restrictive,
    stating that the code can’t be used in an application whose code isn’t itself
    open source. Others are much more permissive, allowing you to do whatever you
    want with the code.*'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: '*开源代码的所有者使用软件许可证来告诉其他用户他们可以对代码做什么和不能做什么。例如，一些许可证非常严格，规定代码不能用于非开源代码的应用程序。其他许可证则更加宽松，允许你对代码做任何你想做的事情。*'
- en: <samp class="SANS_Futura_Std_Bold_B_11">The Basic Visualization</samp>
  id: totrans-31
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">基本可视化</samp>
- en: Now that we have the data, we’ll create a basic bar chart showing how many stars
    each repository in the dataset has received. To do this, we’ll create the required
    SVG elements, draw the axes, and draw the bars themselves. Later we’ll improve
    on this basic chart, making it more informative, stylish, and interactive.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经有了数据，我们将创建一个基本的条形图，显示数据集中每个仓库收到的星标数量。为此，我们将创建所需的SVG元素，绘制坐标轴，并绘制条形图本身。稍后我们将改进这个基本图表，使其更具信息性、更有风格并且更具交互性。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Creating the Elements</samp>
  id: totrans-33
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">创建元素</samp>
- en: To create our chart, we first have to create the svg element that will hold
    it and the two g elements for the axes. In this case, the axes will be on the
    bottom and left sides. Add the code in [Listing 15-4](#Lis15-4) to the start of
    *script.js*, before the getUrl function.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建我们的图表，我们首先必须创建一个将容纳图表的svg元素，以及两个用于坐标轴的g元素。在这种情况下，坐标轴将在底部和左侧。将[清单 15-4](#Lis15-4)中的代码添加到*script.js*的开头，位于getUrl函数之前。
- en: '[PRE4]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 15-4: Setting up the
    elements</samp>'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">清单 15-4：设置元素</samp>
- en: Much like we did for the character frequency chart in [Chapter 14](chapter14.xhtml),
    we append an svg element to the page ❶ and set its width and height. We then create
    a margin object ❷ and append the g elements for containing the bottom ❸ and left
    ❹ axes, which we position based on the margins.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 就像我们在[第14章](chapter14.xhtml)中为字符频率图表所做的那样，我们将一个svg元素添加到页面 ❶ 并设置其宽度和高度。然后我们创建一个边距对象
    ❷ 并添加用于容纳底部 ❸ 和左侧 ❹ 坐标轴的g元素，并根据边距进行定位。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Drawing the Axes</samp>
  id: totrans-38
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">绘制坐标轴</samp>
- en: With the elements created, we can make a start on the update function, which
    will draw the visualization. First, we’ll create the scales based on the data
    and draw the axes. Make the changes to *script.js* shown in [Listing 15-5](#Lis15-5).
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 有了创建的元素，我们可以开始编写更新函数，它将绘制可视化图形。首先，我们将基于数据创建刻度并绘制坐标轴。请在*script.js*中做出[清单 15-5](#Lis15-5)所示的更改。
- en: '[PRE5]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 15-5: Drawing the axes</samp>'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">清单 15-5：绘制坐标轴</samp>
- en: The update function takes the items array from the API response. Our bar chart
    will have a vertical bar for each repository, so we create the horizontal xScale
    using the scaleBand helper to evenly space the bars ❶. The domain is the full_name
    from each repository. Each repository’s full name is unique, so this will result
    in 20 bands. The vertical yScale is used to visualize the number of stars that
    each repository has, so its domain goes from zero to the max stargazers_count
    ❷. We use nice here to round the top of the scale to the next tick value. After
    creating the scales, we create the axis generators ❸ and then use those generators
    to draw the axes to the containers ❹, as we did for the character frequencies
    project.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 更新函数从API响应中获取items数组。我们的条形图将为每个仓库绘制一个垂直条形，因此我们使用scaleBand助手创建水平xScale来均匀地间隔这些条形
    ❶。域是每个仓库的full_name。每个仓库的全名是唯一的，因此这将导致20个带。垂直的yScale用于可视化每个仓库的星标数，因此它的域从零到最大的stargazers_count
    ❷。我们在这里使用nice将刻度的顶部四舍五入到下一个刻度值。创建刻度之后，我们创建轴生成器 ❸，然后使用这些生成器将坐标轴绘制到容器 ❹ 中，正如我们在字符频率项目中所做的那样。
- en: The last thing to do here is call our update function from inside the d3.json
    callback, passing the items array ❺. We’re able to go straight from fetching the
    data to calling update because the GitHub Search API conveniently returns the
    data in the format we need for rendering. There’s no need to do any processing
    of the data like we did in the character frequencies example, where the source
    data was just a string and we needed a sorted array of objects describing each
    character and its count.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一步是从 d3.json 回调中调用我们的更新函数，并传递 `items` 数组❺。我们能够直接从获取数据到调用更新函数，因为 GitHub 搜索
    API 方便地以我们需要的格式返回数据用于渲染。与字符频率示例中的数据处理不同，在那个示例中，源数据只是一个字符串，我们需要一个描述每个字符及其计数的排序对象数组。
- en: When you reload *index.html* you should now see the axes, as shown in [Figure
    15-1](chapter15.xhtml#fig15-1). We’ll fix the bottom axis labels shortly; they’re
    a mess right now because D3 is trying to render the full name of each repository.
    Also, your left axis scale may go higher than the 200,000 shown in the figure,
    depending on how many stars the most popular JavaScript project has when you run
    this code. At the time of this writing, facebook/react had the most stars of any
    JavaScript project on GitHub, at around 196,000.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 当你重新加载 *index.html* 时，应该可以看到坐标轴，如[Figure 15-1](chapter15.xhtml#fig15-1)所示。我们稍后会修复底部轴标签；它们现在很乱，因为
    D3 正在尝试渲染每个仓库的完整名称。此外，左轴的刻度值可能会超过图中显示的 200,000，具体取决于你运行此代码时最受欢迎的 JavaScript 项目的星标数。撰写本文时，facebook/react
    是 GitHub 上最受欢迎的 JavaScript 项目，拥有大约 196,000 个星标。
- en: '![](../images/Figure_15-1.png)'
  id: totrans-45
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/Figure_15-1.png)'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 15-1: The axes</samp>'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 15-1: 坐标轴</samp>'
- en: Given that we’re working with such large numbers here (and getting larger every
    day), we can increase readability by using SI prefixes like *k* for 1,000\. This
    is easy to do in D3 with the right number format. While we make that change, we’ll
    also remove the ticks from the bottom axis. See [Listing 15-6](#Lis15-6) for these
    changes.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们在这里处理的是如此大的数字（而且数字每天都在增大），我们可以通过使用 SI 前缀来提高可读性，比如 *k* 表示 1,000。这在 D3 中很容易做到，只需使用正确的数字格式。在进行此更改时，我们还将从底部轴中移除刻度。有关这些更改，请参见[Listing
    15-6](#Lis15-6)。
- en: '[PRE6]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 15-6: Cleaning up the
    scales</samp>'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 15-6: 清理坐标轴刻度</samp>'
- en: For the bottom axis, we’re updating the tick values to be an empty list ❶, which
    effectively removes the ticks. For the left axis, we’re adding a tick format using
    the format specifier "~s" ❷, which will, for example, render the number 200,000
    as 200k and 1,000,000 as 1M. [Figure 15-2](chapter15.xhtml#fig15-2) shows how
    the updated axes should now look.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 对于底部轴，我们将刻度值更新为空列表❶，这样就有效地移除了刻度。对于左轴，我们添加了一个刻度格式，使用格式说明符 "~s" ❷，例如，它会将数字 200,000
    渲染为 200k，1,000,000 渲染为 1M。[Figure 15-2](chapter15.xhtml#fig15-2) 显示了更新后的坐标轴应该是什么样子。
- en: '![](../images/Figure_15-2.png)'
  id: totrans-51
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/Figure_15-2.png)'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 15-2: The axes after
    some cleanup</samp>'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 15-2: 清理后的坐标轴</samp>'
- en: The numbers in the left axis are now easier to read at a glance, and the bottom
    axis is no longer a jumble of text.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 左轴上的数字现在一目了然，底部的轴也不再是杂乱的文本。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Drawing the Bars</samp>
  id: totrans-54
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">绘制条形图</samp>
- en: Now that the axes are drawn, we need to draw the bars themselves. Add the code
    in [Listing 15-7](#Lis15-7) to the end of the update function.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 现在轴已经画好，我们需要绘制条形图本身。将[Listing 15-7](#Lis15-7)中的代码添加到更新函数的末尾。
- en: '[PRE7]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 15-7: Drawing the bars</samp>'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 15-7: 绘制条形图</samp>'
- en: As in the character frequencies project, we’re drawing a bunch of rect elements.
    The key function ❶ extracts the full_name property, which we’re using here as
    the unique identifier for each repository. For now, we’re using the simple join
    technique, without separate handling for entering, updating, and exiting elements
    (that will come later).
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 和字符频率项目一样，我们正在绘制一堆 `rect` 元素。关键函数❶提取了 `full_name` 属性，我们在这里将其用作每个仓库的唯一标识符。目前，我们使用简单的
    `join` 技巧，没有对进入、更新和退出元素进行单独处理（这些将在后面处理）。
- en: The x attribute is set based on looking up the full_name in xScale, and the
    width is based on the bandwidth method on xScale. The y and height attributes
    are a bit trickier this time and require some explanation. If you look back at
    the definition of yScale in [Listing 15-5](#Lis15-5), you’ll see that the domain
    is [0, d3.max(items, d => d.stargazers_count)] and the range is [height - margin
    .bottom, margin.top]. With the values we’ve set, that range expands to [380, 20].
    The range goes from high to low, meaning that high values in the domain map to
    lower values in the range, and vice versa. This is because y values in computer
    graphics count down from the top of the screen, but in our graph we want y values
    to count up from the bottom of the graph. The other thing that makes this tricky
    is that SVG rectangles are drawn from the top-left corner, which will likely be
    different for each bar, so we need to set a variable height that makes all the
    bars hit the bottom axis.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: x 属性是根据在 xScale 中查找 full_name 来设置的，宽度则基于 xScale 的带宽方法。y 和高度属性这次稍微复杂一些，需要一些解释。如果您回顾一下
    [清单 15-5](#Lis15-5) 中 yScale 的定义，您会看到域是 [0, d3.max(items, d => d.stargazers_count)]，范围是
    [height - margin.bottom, margin.top]。通过我们设置的值，这个范围扩展为 [380, 20]。这个范围是从高到低的，意味着域中的高值会映射到范围中的低值，反之亦然。这是因为计算机图形中的
    y 值是从屏幕顶部开始递减的，而在我们的图表中，我们希望 y 值是从图表底部开始递增的。让这变得复杂的另一件事是 SVG 矩形是从左上角开始绘制的，这对于每个条形图来说可能会有所不同，因此我们需要设置一个变量高度，使得所有的条形图都能触及到底部坐标轴。
- en: Because of all this, we set the y attribute of the bar to yScale(d.stargazers
    _count) ❷, which gives the vertical position of the top of the bar. To calculate
    the height of the bar, we use yScale(0) - yScale(d.stargazers_count) ❸. Calling
    yScale(0) gives the vertical position of the bottom of the bar (all the bars should
    have their base at 0 in the domain), so subtracting the position of the top of
    the bar from the position of the bottom of the bar gives the height of the bar.
    We need to end up with a positive height, so we have to subtract the smaller number
    from the larger number. The top of the bar is a smaller number in the display
    range, even though it’s a larger number in the domain. [Figure 15-3](chapter15.xhtml#fig15-3)
    shows how the bars should look, though keep in mind that your bar heights may
    be different based on how the data evolves.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们将条形图的 y 属性设置为 yScale(d.stargazers_count) ❷，它给出了条形图顶部的垂直位置。为了计算条形图的高度，我们使用
    yScale(0) - yScale(d.stargazers_count) ❸。调用 yScale(0) 会给出条形图底部的垂直位置（所有条形图的基线应该位于
    0 位置），所以从条形图底部到顶部的高度就是两个位置的差值。我们需要得到一个正的高度，因此必须将较小的数值从较大的数值中减去。尽管条形图的顶部在显示范围内是一个较小的数字，但它在数据域中是一个较大的数值。[图
    15-3](chapter15.xhtml#fig15-3) 显示了条形图的应有样式，但请记住，根据数据的变化，您的条形图高度可能会有所不同。
- en: '![](../images/Figure_15-3.png)'
  id: totrans-61
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/Figure_15-3.png)'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 15-3: Drawing the bars
    as rect elements</samp>'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">图 15-3：将条形图绘制为矩形元素</samp>
- en: As you look at the bars, remember that each bar is drawn from its top-left corner,
    and that the heights are calculated such that the bottoms of all the bars align.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 在查看条形图时，请记住，每个条形图是从其左上角开始绘制的，并且高度是计算得当的，使得所有条形图的底部都对齐。
- en: <samp class="SANS_Futura_Std_Bold_B_11">Improving the Visualization</samp>
  id: totrans-64
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">改进可视化效果</samp>
- en: We now have a basic visualization up and running, but it isn’t terribly informative.
    In this section, we’ll implement some improvements to make the visualization more
    meaningful. We’ll create a way to see more information about each repository.
    We’ll also color-code the bars to show each repository’s license type, and make
    sure the axes are properly labeled.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在已经有了一个基本的可视化效果，但它并不太具有信息性。在本节中，我们将实现一些改进，使可视化效果更加有意义。我们将创建一种方法，查看每个仓库的更多信息。我们还将为条形图添加颜色编码，以显示每个仓库的许可证类型，并确保坐标轴正确标注。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Showing Repository
    Info</samp>
  id: totrans-66
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">显示仓库信息</samp>
- en: The current graph doesn’t give any way of identifying which repository each
    bar represents. There are various ways to solve this (for example, vertically
    or diagonally oriented tick labels, or some kind of *tooltip*, a text field that
    pops up when a bar is hovered), but for this project we’ll add a permanent sidebar
    that shows more information about a bar when you hover over it. First, we’ll add
    the HTML for the sidebar to *index.html*, as shown in [Listing 15-8](#Lis15-8).
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 当前的图表没有提供任何方式来识别每个条形图所代表的仓库。我们有多种方法可以解决这个问题（例如，垂直或对角线方向的刻度标签，或者某种*提示框*，即当鼠标悬停在条形图上时弹出的文本框），但在这个项目中，我们将添加一个永久的侧边栏，当你悬停在条形图上时，它会显示更多关于该条形图的信息。首先，我们将把侧边栏的
    HTML 添加到*index.html*中，如[清单 15-8](#Lis15-8)所示。
- en: '[PRE8]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 15-8: Adding the sidebar
    HTML to</samp> <samp class="SANS_Futura_Std_Book_11">index.html</samp>'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">清单 15-8：将侧边栏 HTML 添加到</samp>
    <samp class="SANS_Futura_Std_Book_11">index.html</samp>
- en: Here we set up a div called info with the elements that we’ll need to display
    the repository information. It’s nested inside another div called sidebar. This
    outer div may seem superfluous now, but later we’ll add another div element to
    the sidebar, so we’ll need the parent div element to contain the two sidebar div
    elements.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们设置了一个名为 info 的 div，其中包含我们需要显示仓库信息的元素。它被嵌套在另一个名为 sidebar 的 div 中。这个外部 div
    现在看起来可能是多余的，但稍后我们将向侧边栏添加另一个 div 元素，因此我们需要父 div 元素来包含这两个侧边栏 div 元素。
- en: The info div will show the repository name, its license type, and its number
    of stars. We use span elements to wrap parts of the text. A span is a container
    element like a div, but unlike div elements, which create a new block, span is
    an inline element, so it can enclose part of a line of text without making a new
    line. Later, we’ll update the content of the value spans when you hover over a
    bar to show the relevant information about that bar.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: info div 会显示仓库名称、许可证类型以及其星标数。我们使用 span 元素来包装文本的一部分。span 是一个容器元素，像 div 元素一样，但与
    div 不同，span 是一个内联元素，因此它可以在不换行的情况下包裹一行文本的某一部分。稍后，当你悬停在条形图上时，我们会更新值的 span 内容，显示关于该条形图的相关信息。
- en: One of the span elements contains an a element ❶, which creates a hyperlink
    to another page or website. The URL of the link is specified with an href attribute,
    which we’ll set dynamically later. The target="_blank" attribute instructs the
    browser to open the link in a new tab or window.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 其中一个 span 元素包含一个 a 元素 ❶，它创建一个指向另一个页面或网站的超链接。链接的 URL 是通过 href 属性指定的，我们稍后会动态设置它。target="_blank"
    属性指示浏览器在新标签页或窗口中打开链接。
- en: The sidebar looks a bit ugly at this stage, so let’s add some CSS. Add the code
    in [Listing 15-9](#Lis15-9) to *style.css*.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 侧边栏在此阶段看起来有点丑，所以让我们添加一些 CSS。将[清单 15-9](#Lis15-9)中的代码添加到*style.css*中。
- en: '[PRE9]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 15-9: Styling the sidebar</samp>'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">清单 15-9：为侧边栏添加样式</samp>
- en: 'For this project we’re using a CSS technique called *flexbox* ❶, which is a
    relatively recent addition to the CSS specification. Flexbox makes it much easier
    to define layouts, especially those that will work flexibly across a variety of
    screen and viewport sizes. Flexbox layouts have two main components: the *flex
    container* and the *flex items*. The flex container is a parent element that defines
    how its child flex items (the direct children of the container) are sized and
    how they flow. In our case, the flex container is the body element, and the flex
    items are the svg element and the #sidebar element. By default, the items are
    arranged left to right (meaning that the #sidebar element will appear on the left
    of the screen, followed by the svg element to its right). The declaration align-items:
    flex-start; means that the items will be aligned to the top of the parent container.'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: '在这个项目中，我们使用了一种叫做*flexbox* ❶的 CSS 技术，这是 CSS 规范中较新的一个特性。Flexbox 使得定义布局变得更加容易，特别是那些能够在各种屏幕和视口尺寸上灵活工作的布局。Flexbox
    布局有两个主要组成部分：*flex 容器*和*flex 项目*。flex 容器是一个父元素，它定义了其子 flex 项目（容器的直接子元素）的尺寸和排列方式。在我们的例子中，flex
    容器是 body 元素，而 flex 项目是 svg 元素和 #sidebar 元素。默认情况下，项目从左到右排列（这意味着 #sidebar 元素会出现在屏幕的左侧，接着是右侧的
    svg 元素）。声明 align-items: flex-start; 表示这些项目将对齐到父容器的顶部。'
- en: <samp class="SANS_Dogma_OT_Bold_B_21">NOTE</samp>
  id: totrans-77
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: <samp class="SANS_Dogma_OT_Bold_B_21">注意</samp>
- en: '*If you want to learn more about flexbox, check out* [https://css-tricks.com/snippets/css/a-guide-to-flexbox/](https://css-tricks.com/snippets/css/a-guide-to-flexbox/).'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: '*如果你想了解更多关于 flexbox 的内容，请查看* [https://css-tricks.com/snippets/css/a-guide-to-flexbox/](https://css-tricks.com/snippets/css/a-guide-to-flexbox/)。'
- en: Currently the svg element is being appended to the body element, meaning that
    it comes after the sidebar, but for layout reasons we want it to come before.
    To do that, we’ll need to switch from the append method to the insert method when
    we create the svg element, since the latter allows us to specify an element to
    insert before. The *script.js* change for this is shown in [Listing 15-10](#Lis15-10).
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 当前，svg 元素被附加到 body 元素上，这意味着它位于侧边栏之后，但出于布局原因，我们希望它位于侧边栏之前。为此，我们需要在创建 svg 元素时，从
    append 方法切换到 insert 方法，因为后者允许我们指定一个元素插入在其前面。实现这一点的 *script.js* 代码更改显示在 [Listing
    15-10](#Lis15-10) 中。
- en: '[PRE10]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 15-10: Inserting the
    svg element before the sidebar</samp>'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 15-10: 在侧边栏之前插入 svg
    元素</samp>'
- en: Now the sidebar will appear to the right of the graph, as the svg element now
    appears before the sidebar in the flex container.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，侧边栏将出现在图表的右侧，因为 svg 元素现在出现在 flex 容器中的侧边栏之前。
- en: Before we write the code for displaying the details about a repository in the
    sidebar, we need a function for getting the name of the repository’s license.
    Accessing the other pieces of information will be straightforward, but not all
    repositories have a license, so our function has to handle the case where no license
    data is available. [Listing 15-11](#Lis15-11) shows the new getLicense function,
    which you can insert into *script.js* just before the update function.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 在编写用于显示仓库详细信息的代码之前，我们需要一个用于获取仓库许可证名称的函数。访问其他信息将是直接的，但并非所有仓库都有许可证，因此我们的函数必须处理没有许可证数据的情况。新的
    getLicense 函数见 [Listing 15-11](#Lis15-11)，你可以将其插入到 *script.js* 中，紧接在 update 函数之前。
- en: '[PRE11]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 15-11: The getLicense
    function</samp>'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 15-11: getLicense 函数</samp>'
- en: If a repository has a license, the license name will be available as d.license.name,
    but if it doesn’t have a license, d.license will be undefined. We test for this
    situation using the ?. operator, called the *optional chaining operator* ❶. Like
    the regular . operator, ?. attempts to take the object specified to the left of
    the operator and access the method or property specified to the right of the operator.
    Unlike the regular . operator, however, ?. will return undefined if the object
    to the left of the operator is null or undefined. Thus, if d.license is undefined
    (meaning the repository doesn’t have a license), our license variable will be
    set to undefined, but if d.license is an object (meaning the repository has a
    license), then license will be set to d.license.name. If license ends up undefined
    ❷, our getLicense function returns the string "No License". Otherwise, the value
    of license is returned.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 如果仓库有许可证，许可证名称将作为 d.license.name 可用，但如果没有许可证，d.license 将是 undefined。我们使用 ?.
    运算符来测试这种情况，称为 *可选链运算符* ❶。像常规的 . 运算符一样，?. 尝试获取运算符左边指定的对象并访问运算符右边指定的方法或属性。但与常规的
    . 运算符不同，?. 如果运算符左边的对象为 null 或 undefined，则返回 undefined。因此，如果 d.license 为 undefined（意味着仓库没有许可证），我们的许可证变量将设置为
    undefined，但如果 d.license 是一个对象（意味着仓库有许可证），那么 license 将设置为 d.license.name。如果 license
    最终为 undefined ❷，我们的 getLicense 函数将返回字符串 "No License"。否则，将返回许可证的值。
- en: Now we can add the code that will update the sidebar when the bars are hovered
    over. We’ll do this by adding a mouseover event handler to the rect elements.
    Update *script.js* with the code in [Listing 15-12](#Lis15-12). This code goes
    at the end of the update function.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以添加代码，在鼠标悬停在条形图上时更新侧边栏。我们将通过向 rect 元素添加 mouseover 事件处理程序来实现。请用 [Listing
    15-12](#Lis15-12) 中的代码更新 *script.js*，该代码放在 update 函数的末尾。
- en: '[PRE12]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 15-12: Updating the
    sidebar on hover</samp>'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 15-12: 在悬停时更新侧边栏</samp>'
- en: 'D3 event handlers are called with two arguments: the event object (e) and the
    datum bound to the element that the event was triggered on (d). The first thing
    we do in the handler is select the #info element, because all the elements we
    want to modify are children of that element. We then update the a element inside
    the .value element inside the .repo element ❶ (refer back to [Listing 15-8](#Lis15-8)
    or look at *index.html* to remind yourself of the HTML structure). We’re setting
    both the text content of this element and the href attribute. This has the effect
    of making a link to the repository, with the full name of the repository as the
    link text. We similarly set the text of the .value .license element to whatever
    getLicense returns for this datum and the text of the .stars .value element to
    the number of stars.'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 'D3 事件处理函数会接收两个参数：事件对象（e）和绑定到触发事件的元素的 datum（d）。我们在处理函数中做的第一件事是选择 #info 元素，因为我们要修改的所有元素都是该元素的子元素。然后，我们更新
    .repo 元素 ❶ 中 .value 元素内的 a 元素（参考[列表 15-8](#Lis15-8)或查看 *index.html* 来回顾 HTML 结构）。我们同时设置该元素的文本内容和
    href 属性。这样就会生成一个指向仓库的链接，链接文本是仓库的完整名称。我们同样设置 .value .license 元素的文本为 getLicense
    为此 datum 返回的内容，并将 .stars .value 元素的文本设置为星标数量。'
- en: Reload the page and try hovering over some of the bars. You should see something
    like [Figure 15-4](chapter15.xhtml#fig15-4).
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 重新加载页面并尝试悬停在一些条形图上。你应该会看到类似于[图 15-4](chapter15.xhtml#fig15-4)的内容。
- en: '![](../images/Figure_15-4.png)'
  id: totrans-92
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/Figure_15-4.png)'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 15-4: The sidebar showing
    details about one of the repositories</samp>'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">图 15-4：侧边栏显示一个仓库的详细信息</samp>
- en: For each bar you hover over, the details for that repository should show up
    in the new sidebar. If you click the repository name, your browser should open
    up a new tab and take you to the repository’s GitHub page.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 当你悬停在每个条形图上时，该仓库的详细信息应该会显示在新的侧边栏中。如果你点击仓库名称，浏览器应当打开一个新的标签页并跳转到该仓库的 GitHub 页面。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Color-Coding the
    Bars</samp>
  id: totrans-95
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">为条形图上色</samp>
- en: In order to convey some additional information visually, we’re going to color-code
    the bars based on the license types. D3 lets you create scales whose inputs (the
    domain) are values and whose outputs (the range) are colors. You’ll see how to
    do that in [Listing 15-13](#Lis15-13).
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 为了通过视觉方式传达一些额外信息，我们将根据许可证类型为条形图上色。D3 允许你创建输入（域）为值、输出（范围）为颜色的刻度。你将在[列表 15-13](#Lis15-13)中看到如何实现这一点。
- en: '[PRE13]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 15-13: Creating a color
    scale for the licenses</samp>'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">列表 15-13：为许可证创建颜色刻度</samp>
- en: First, we need to collect all the unique license names. To do this, we map over
    the items, calling our getLicense function for each one ❶. This gives an array
    of the license names. In the same line, we pass the resulting array to the Set
    constructor. In programming terms, a *set* is a collection of unique items, so
    the Set constructor can take an array of items and filter out any duplicates.
    In JavaScript, sets maintain their order, like arrays.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要收集所有唯一的许可证名称。为此，我们对项目进行映射，对每个项目调用我们的 getLicense 函数 ❶。这会生成一个包含许可证名称的数组。在同一行中，我们将结果数组传递给
    Set 构造函数。从编程角度讲，*集合* 是一组唯一的项目，因此 Set 构造函数可以接受一个包含项目的数组并过滤掉重复项。在 JavaScript 中，集合保持其顺序，像数组一样。
- en: 'The d3.scaleOrdinal helper ❷ creates a scale with discrete inputs and discrete
    outputs. Here, the inputs are the unique license names and the outputs are color
    names. For the scale’s range, we’re using d3.schemeCategory10, which is an array
    of 10 hex color strings. You can check it out in the console:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: d3.scaleOrdinal 辅助函数 ❷ 创建一个具有离散输入和离散输出的刻度。在这里，输入是唯一的许可证名称，输出是颜色名称。对于刻度的范围，我们使用
    d3.schemeCategory10，这是一个包含 10 个十六进制颜色字符串的数组。你可以在控制台中查看它：
- en: '[PRE14]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Each license in the set will map to one of these colors, index-wise. If there
    are more than 10 licenses, the colors will wrap around to the beginning again
    (the eleventh and twelfth licenses will use the same colors as the first and second
    ones).
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 集合中的每个许可证将按索引映射到这些颜色之一。如果许可证超过 10 个，颜色将会重新循环（第十一和第十二个许可证将使用与第一个和第二个相同的颜色）。
- en: Next we have to set the color of the bar based on its license and the color
    scale. [Listing 15-14](#Lis15-14) shows how to make that change near the end of
    the update function.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要根据许可证和颜色刻度设置条形图的颜色。[列表 15-14](#Lis15-14)展示了如何在更新函数的末尾进行此更改。
- en: '[PRE15]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 15-14: Setting the
    fill color of the rect</samp>'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 15-14: 设置矩形的填充颜色</samp>'
- en: We have to call our getLicense function on d to get the license name (because
    it could be "No License"), before passing the license name to the colorScale.
    This gives us the color value for setting the fill attribute of the rect.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 我们必须在 d 上调用我们的 getLicense 函数以获取许可证名称（因为它可能是 "No License"），然后将许可证名称传递给 colorScale。这会为我们提供填充属性的颜色值，以设置矩形的填充颜色。
- en: With color-coding like this, you really need a key so users know what each color
    means. We’ll create that key as another box in the sidebar, beneath the repository
    info box. It will include squares of color alongside the corresponding license
    names. First, we’ll need some more HTML. Update *index.html* with the changes
    in [Listing 15-15](#Lis15-15).
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这样的颜色编码，你确实需要一个图例，让用户知道每种颜色代表什么含义。我们将把这个图例作为侧边栏中的另一个框，放在仓库信息框下方。它将包括颜色方块和相应的许可证名称。首先，我们需要更多的
    HTML。使用[Listing 15-15](#Lis15-15)中的更改更新*index.html*。
- en: '[PRE16]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 15-15: Adding the div
    and heading for the license key</samp>'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 15-15: 添加许可证图例的 div
    和标题</samp>'
- en: Here we’re creating another div called key inside the sidebar div and giving
    it a heading. We’ll create the other elements for the key using JavaScript.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们在侧边栏 div 内创建另一个名为 key 的 div，并给它一个标题。我们将使用 JavaScript 创建图例的其他元素。
- en: Next comes the CSS for styling these new elements and the children we’ll be
    adding with JavaScript. Add the code in [Listing 15-16](#Lis15-16) to the end
    of *style.css*.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来是为这些新元素和我们将通过 JavaScript 添加的子元素进行样式设计的 CSS。将[Listing 15-16](#Lis15-16)中的代码添加到*style.css*的末尾。
- en: '[PRE17]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 15-16: Styling the
    key</samp>'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 15-16: 样式化图例</samp>'
- en: 'The font size for the h1 element here is set to 1.5em, which means 1.5 times
    the font size of the parent element. This ensures that this heading will be 1.5
    times bigger than the rest of the text. The #key .color ruleset is used to style
    the squares of color that will appear as part of the key. These will be div elements,
    but display: inline-block means that they’ll act like a cross between an inline
    element (like a span), in that they won’t force a new line, and a block element
    (like a div), in that they’ll be able to have fixed dimensions and margins. (Inline
    elements are unable to have a width and height because they’re sized based on
    their content, and in this case the squares have no content.)'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: '这里的 h1 元素的字体大小设置为 1.5em，这意味着是父元素字体大小的 1.5 倍。这确保了这个标题比其他文本大 1.5 倍。#key .color
    规则集用于样式化作为图例一部分的颜色方块。这些将是 div 元素，但 display: inline-block 意味着它们将像内联元素（如 span）一样表现，既不会强制换行，又像块元素（如
    div）一样，可以有固定的尺寸和边距。（内联元素无法具有宽度和高度，因为它们的大小是基于内容的，而在这个例子中，方块没有内容。）'
- en: Now we can add the JavaScript that will generate the key. This will entail a
    new data join at the end of the update function, to join the licenses to the elements
    used to render them. Update *script.js* with the changes in [Listing 15-17](#Lis15-17).
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以添加将生成图例的 JavaScript。这将涉及在更新函数的末尾进行一次新的数据连接，以将许可证与用于渲染它们的元素关联。使用[Listing
    15-17](#Lis15-17)中的更改更新*script.js*。
- en: '[PRE18]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 15-17: Generating the
    key</samp>'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 15-17: 生成图例</samp>'
- en: 'Here we’re using the #key element as the container for our new join, and we’re
    joining in a bunch of p elements to bind to each license datum. We’re using the
    advanced join technique, but just with an enter function; we don’t need custom
    behavior for updating or exiting items. (We can’t use the regular join technique
    here because then the element appends would happen every time update is called.)
    First we create the p element for each new datum ❶, then we append a div element
    where we’ll display the square of color to the p element ❷. Adding the color class
    to the div means that it will have the styling from [Listing 15-16](#Lis15-16).
    To give it the right color, we use the style method ❸, which sets an inline CSS
    style on the element. We set the color to the appropriate value for the datum
    using colorScale. Finally, we add a span element to the p element for holding
    the actual name of the license ❹.'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们使用#key元素作为新连接的容器，并通过连接一堆p元素来绑定每个许可证数据。我们使用了高级连接技术，但仅使用了enter函数；我们不需要自定义更新或退出项目的行为。（我们不能在这里使用常规的连接技术，因为每次调用update时，元素的附加操作都会发生。）首先，我们为每个新数据创建p元素
    ❶，然后将一个div元素附加到p元素上，在其中显示颜色的方块 ❷。为div元素添加color类意味着它将具有[清单 15-16](#Lis15-16)中的样式。为了给它正确的颜色，我们使用style方法
    ❸，它在元素上设置内联CSS样式。我们使用colorScale设置颜色为数据的适当值。最后，我们为p元素添加一个span元素，用于容纳许可证的实际名称 ❹。
- en: Reload the page and you should see something like [Figure 15-5](chapter15.xhtml#fig15-5).
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 重新加载页面后，你应该能看到类似[图 15-5](chapter15.xhtml#fig15-5)的效果。
- en: '![](../images/Figure_15-5.png)'
  id: totrans-120
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/Figure_15-5.png)'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 15-5: Color-coded bars
    with a key</samp>'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">图 15-5：带有图例的颜色编码条</samp>
- en: Our visualization now has a full key showing the license that each color maps
    to, making the colors much more meaningful.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的可视化现在有了完整的图例，显示了每种颜色对应的许可证，使颜色变得更加有意义。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Labeling the Left
    Axis</samp>
  id: totrans-123
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">标注左侧坐标轴</samp>
- en: It’s implied that our graph’s left axis shows the number of stars each repository
    has, but that isn’t explicitly stated in the chart. To fix this, we’ll add a text
    element to label the left axis. The code for this is in [Listing 15-18](#Lis15-18).
    Add this code right before the getLicense function.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 这里隐含的是，图表的左侧坐标轴显示的是每个仓库的星标数，但图表中并未明确指出这一点。为了解决这个问题，我们将添加一个文本元素来标注左侧坐标轴。相关代码在[清单
    15-18](#Lis15-18)中。将这段代码添加到getLicense函数之前。
- en: '[PRE19]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 15-18: Adding a left
    axis label</samp>'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">清单 15-18：添加左侧坐标轴标签</samp>
- en: First, we need to calculate where to draw the label. Its vertical position should
    be in the middle of the chart. We calculate the height of the chart based on the
    total height and the two margins, then calculate the midpoint based on adding
    the top margin and half the height of the chart.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要计算标签绘制的位置。它的垂直位置应该位于图表的中间。我们通过总高度减去上下边距来计算图表的高度，然后根据添加上边距和图表高度的一半来计算中点位置。
- en: 'Next, we append a text element with the word *Stars* to the svg element. We
    set the font earlier in *style.css* by applying a font-family to the body element.
    Setting the text-anchor attribute to middle ❶ causes the text to be centered around
    its calculated position. We also specify two transformations ❷: a translate followed
    by a rotate. The translate moves the center of the label to the correct position,
    and the rotate turns it 90 degrees counterclockwise (or 270 degrees clockwise).'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将带有*Stars*字样的文本元素添加到svg元素中。我们在*style.css*文件中通过为body元素应用font-family属性来设置字体。将text-anchor属性设置为middle
    ❶使文本围绕其计算位置居中。我们还指定了两个变换 ❷：一个平移和一个旋转。平移将标签的中心移动到正确的位置，旋转则将其逆时针旋转90度（或顺时针旋转270度）。
- en: <samp class="SANS_Futura_Std_Bold_B_11">Adding Interactivity</samp>
  id: totrans-129
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">添加交互性</samp>
- en: Our visualization is already somewhat interactive in the sense that hovering
    over a bar shows details about that repository in the sidebar. It would be fun
    to add another interactive element that allows the user to filter the data. For
    example, now that we have a key listing the different license types, we could
    use it to selectively show or hide repositories with those licenses. We’ll implement
    this interactive feature now, while also adding animation to smooth out the changes
    to the graph.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的可视化已经具有一定的交互性，因为悬停在条形图上可以在侧边栏显示该仓库的详细信息。现在，加入另一个交互元素来允许用户过滤数据会很有趣。例如，现在我们有一个列出不同许可证类型的键，我们可以使用它来有选择性地显示或隐藏具有这些许可证的仓库。我们将实现这个交互功能，并同时为图表的变化添加动画效果。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Filtering the Data
    by License</samp>
  id: totrans-131
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">按许可证过滤数据</samp>
- en: To let the user filter the data by license type, we’re going to add a checkbox
    to each of the items in the key. We’ll then use those checkboxes to determine
    which repositories to (temporarily) exclude from the graph. This will require
    keeping track of the licenses we want to hide and removing any repositories that
    use those licenses before rendering.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 为了让用户按许可证类型过滤数据，我们将为键中的每一项添加一个复选框。然后，我们将使用这些复选框来决定哪些仓库需要（临时）从图表中排除。这将需要追踪我们想要隐藏的许可证，并在渲染之前删除使用这些许可证的任何仓库。
- en: First we’ll add the checkboxes. Change *script.js* as shown in [Listing 15-19](#Lis15-19)
    to do this.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将添加复选框。按[清单 15-19](#Lis15-19)中的方式更改*script.js*来实现这一点。
- en: '[PRE20]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 15-19: Adding checkboxes</samp>'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">清单 15-19：添加复选框</samp>
- en: In HTML, a checkbox is an input element with a type attribute value of checkbox.
    In the code, we add one of these at the start of each p element in the key. The
    checked attribute determines whether the checkbox is checked or not; we set them
    to be checked by default, so all the repositories will be shown when the visualization
    first loads. The title attribute gives a tooltip with helper text if you hover
    over the element.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 在HTML中，复选框是一个具有类型属性值为checkbox的输入元素。在代码中，我们在键的每个p元素开始处添加一个复选框。checked属性决定复选框是否被选中；我们将它们默认设置为选中状态，因此在可视化首次加载时，所有的仓库都会显示。title属性会在悬停元素时显示一个带有帮助文本的提示框。
- en: Next, we need to create a mechanism for keeping track of which licenses should
    be hidden. The code for this is in [Listing 15-20](#Lis15-20).
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要创建一个机制来追踪哪些许可证应该被隐藏。相关代码在[清单 15-20](#Lis15-20)中。
- en: '[PRE21]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 15-20: Keeping track
    of the hidden licenses</samp>'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">清单 15-20：追踪隐藏的许可证</samp>
- en: First, we create a new empty Set called hiddenLicenses, just before the update
    function ❶. We’re using Set here to make it easier to add or remove licenses—with
    an array it’s trickier to remove a specific element. Then, after the code that
    renders the key, we create a change event handler for the checkboxes ❷. Whenever
    a checkbox changes from checked to unchecked or vice versa, this handler will
    run. In the handler, e is the change event and d is the bound datum (even though
    the license is bound to the p element, the children, like this checkbox, also
    inherit the datum). We use e.target.checked to determine whether, after the change,
    the checkbox is checked or not. If it is, then we know the datum should be removed
    from the hiddenLicenses set, using the delete method on the set ❸. Conversely,
    if the checkbox is now unchecked we add that datum to hiddenLicenses, using the
    add method on the set ❹.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们在更新函数❶之前创建一个新的空Set，名为hiddenLicenses。我们使用Set是为了方便添加或删除许可证——如果使用数组，删除特定元素会更麻烦。然后，在渲染键的代码之后，我们为复选框创建一个变更事件处理器❷。每当复选框从选中变为未选中或反之时，这个处理器就会执行。在处理器中，e是变更事件，d是绑定的数据（尽管许可证绑定在p元素上，但像复选框这样的子元素也会继承数据）。我们使用e.target.checked来确定变更后复选框是否被选中。如果是，那么我们知道该数据应该从hiddenLicenses集合中移除，使用集合的delete方法❸。相反，如果复选框现在未选中，我们将该数据添加到hiddenLicenses中，使用集合的add方法❹。
- en: Finally, with the hiddenLicenses set modified, we log the set to the console
    and call the update function again ❺, with the same items it was called with originally.
    When you reload the page, you won’t see any new behavior because we’re not actually
    updating the graph yet, but if you open the console you’ll see how the hiddenLicenses
    set changes as you check and uncheck the various checkboxes. The hiddenLicenses
    set should always correspond to the unchecked licenses in the key.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，在修改了hiddenLicenses集合后，我们将该集合日志记录到控制台，并再次调用更新函数 ❺，使用最初调用时的相同项。当你重新加载页面时，你不会看到任何新的行为，因为我们实际上还没有更新图表，但如果你打开控制台，你会看到当你勾选和取消勾选不同的复选框时，hiddenLicenses集合是如何变化的。hiddenLicenses集合应始终与键中的未勾选许可证对应。
- en: Now we need to determine which repositories to show when there are hidden licenses.
    To do that, we’ll create a new array called filtered at the top of the update
    method. It will be a version of the items array with the repositories with hidden
    licenses removed. The code for this change is in [Listing 15-21](#Lis15-21).
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们需要确定在隐藏许可证时要显示哪些仓库。为此，我们将在update方法的顶部创建一个名为filtered的新数组。它将是items数组的一个版本，其中移除了具有隐藏许可证的仓库。此更改的代码在[清单
    15-21](#Lis15-21)中。
- en: '[PRE22]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 15-21: Determining
    the repositories with hidden licenses</samp>'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">清单 15-21：确定具有隐藏许可证的仓库</samp>
- en: To filter the list of items, for each item we check to see if its license name
    is in the hiddenLicenses set, using the set’s has method. If the name isn’t included
    the set, then it will be in the filtered list. Otherwise, it’s filtered out.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 为了过滤项列表，对于每一项，我们检查其许可证名称是否在hiddenLicenses集合中，使用集合的has方法。如果名称不在集合中，则它将出现在filtered列表中。否则，它会被过滤掉。
- en: Finally, we need to switch to using the filtered array rather than the items
    array for rendering. The new graph will be rendering only the filtered data, so
    we need to change the scales and the bar drawing code to work with filtered. On
    the other hand, we shouldn’t filter the licenses set because it’s needed to maintain
    a consistent color scheme and to render the key, regardless of whether certain
    licenses are currently hidden in the bar chart. [Listing 15-22](#Lis15-22) shows
    all the places in the update function that need to be changed to use filtered
    instead of items.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们需要切换到使用filtered数组，而不是items数组来进行渲染。新的图表将只渲染过滤后的数据，因此我们需要更改比例尺和条形绘制代码，以便它们与filtered一起工作。另一方面，我们不应该过滤licenses集合，因为它需要保持一致的颜色方案，并渲染键，无论某些许可证是否当前在条形图中隐藏。[清单
    15-22](#Lis15-22)显示了在update函数中需要更改为使用filtered而不是items的所有位置。
- en: '[PRE23]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 15-22: Replacing items
    with filtered</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">for rendering
    the bar chart</samp>'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">清单 15-22：用filtered替换items</samp>
    <samp class="SANS_Futura_Std_Book_Oblique_I_11">用于渲染条形图</samp>
- en: We update the code for creating the bottom ❶ and left axis ❷ scales, as well
    as the code for drawing the bars ❸, changing items to filtered in each case. Refresh
    the page and deselect some of the licenses in the key. You should now see the
    corresponding bars disappear from the bar chart. The changes are rendered because,
    as you saw in [Listing 15-20](#Lis15-20), we’re calling update from the change
    event handler for the checkboxes.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 我们更新了创建底部 ❶ 和左侧轴 ❷ 的比例尺的代码，以及绘制条形图 ❸ 的代码，在每个情况下将项更改为filtered。刷新页面并取消选择键中的一些许可证。此时，你应该看到相应的条形图从条形图中消失。变化得以呈现，因为正如你在[清单
    15-20](#Lis15-20)中看到的，我们正在从复选框的更改事件处理程序中调用update。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Animating the Changes</samp>
  id: totrans-150
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">动画化变化</samp>
- en: 'For the icing on the cake, let’s add some animations. These will make it easier
    to see changes to the bars as licenses are shown or hidden, and also just make
    the visualization look cooler. We’re going to animate two parts of the graph:
    the left axis and the bars. To do this, make the changes shown in [Listing 15-23](#Lis15-23).'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 为了锦上添花，我们来添加一些动画效果。这将使得在许可证显示或隐藏时，条形图的变化更容易看到，同时也让可视化效果看起来更酷。我们将对图表的两个部分进行动画：左侧轴和条形图。为此，进行[清单
    15-23](#Lis15-23)中所示的更改。
- en: '[PRE24]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 15-23: Adding animations</samp>'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">清单 15-23：添加动画效果</samp>
- en: 'Animating the left axis is straightforward: we just call transition on the
    axis’s container before the axis is drawn to it ❶, and the left axis will transition
    anytime the scale changes (which will happen only if the biggest bar is hidden
    or unhidden, which changes the upper bound of the domain).'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 动画化左轴非常简单：我们只需在绘制左轴之前，对轴的容器调用过渡❶，左轴将在每次缩放变化时过渡（只有在最大条形图隐藏或显示时才会发生变化，这会改变域的上界）。
- en: To animate the bars, we follow the standard practice of switching to the advanced
    join technique and adding transitions for entering, updating, and exiting elements.
    Entering elements start out with all their attributes set and an opacity of 0
    (meaning that they are 100 percent transparent) ❷. We then call transition and
    animate up to 100 percent opaque ❸, which has the effect of fading in entering
    elements. Updating elements remain the same color and opacity, but their position
    and dimensions can change, so we animate all of these ❹. This has the effect of
    stretching and sliding these updated elements to their new size and position.
    Exiting elements do the opposite of entering elements and fade out, which we achieve
    by transitioning their opacity back to 0 ❺. Remember that we also have to call
    remove on any exiting elements after the transition is complete ❻.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使条形图动画化，我们遵循标准做法，采用高级连接技术，并为元素的进入、更新和退出添加过渡效果。进入的元素初始时所有属性已设置，并且透明度为0（意味着它们是完全透明的）❷。然后我们调用过渡动画，将透明度动画至100%不透明❸，这会产生元素渐显的效果。更新的元素保持相同的颜色和透明度，但它们的位置和尺寸可能发生变化，因此我们对所有这些元素进行动画处理❹。这会让这些更新的元素伸展并滑动到新的大小和位置。退出的元素则与进入的元素相反，逐渐消失，我们通过将它们的透明度过渡回0❺来实现这个效果。记住，在过渡完成后，我们还需要对任何退出的元素调用remove❻。
- en: Reload the page and try hiding and unhiding various licenses. The first license
    in the key should always correspond to the repository with the most stars (because
    the repositories are ordered that way and we extract the license names from the
    repositories in order), so if you want to see the left axis resize, you’ll need
    to turn off that license. You should see the repositories with that license fade
    out and the other repositories expand to fill the space and the recomputed scale.
    [Figure 15-6](chapter15.xhtml#fig15-6)(a) shows the chart with all the licenses
    shown, and [Figure 15-6](chapter15.xhtml#fig15-6)(b) shows the chart with the
    MIT license (at the time of writing, the most popular license in the dataset)
    hidden.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 重新加载页面并尝试隐藏和显示不同的许可证。关键中的第一个许可证应该始终对应于拥有最多星标的仓库（因为仓库是按这个顺序排列的，我们也按这个顺序从仓库中提取许可证名称），所以如果你想看到左轴的缩放效果，你需要关闭那个许可证。你应该能看到该许可证对应的仓库淡出，而其他仓库则会扩展以填充空间，并重新计算比例。[图
    15-6](chapter15.xhtml#fig15-6)(a)展示了所有许可证显示时的图表，[图 15-6](chapter15.xhtml#fig15-6)(b)展示了MIT许可证（在撰写时，是数据集中最流行的许可证）被隐藏时的图表。
- en: '![](../images/Figure_15-6.png)'
  id: totrans-157
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/Figure_15-6.png)'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 15-6: The final chart
    showing all licenses (a) and with the top license hidden (b)</samp>'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">图 15-6: 显示所有许可证的最终图表（a），以及隐藏顶部许可证的图表（b）</samp>'
- en: Try showing and hiding different licenses to get a feel for how the animations
    work. Is there anything you would change about them? How else might you make the
    visualization more interesting?
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试展示和隐藏不同的许可证，感受一下动画效果的运作方式。你会对它们做出什么修改吗？你还可以通过什么方式让可视化效果更有趣？
- en: <samp class="SANS_Futura_Std_Bold_B_11">The Complete Code</samp>
  id: totrans-160
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">完整代码</samp>
- en: If you’d like to see what the full *script.js* file should look like, you can
    find the complete code in [Listing 15-24](#Lis15-24).
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想查看完整的*script.js*文件内容，可以在[清单 15-24](#Lis15-24)中找到完整的代码。
- en: '[PRE25]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 15-24: The full</samp>
    <samp class="SANS_Futura_Std_Book_11">script.js</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">file
    for this project</samp>'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">清单 15-24: 本项目的完整</samp> <samp
    class="SANS_Futura_Std_Book_11">script.js</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">文件</samp>'
- en: <samp class="SANS_Futura_Std_Bold_B_11">Summary</samp>
  id: totrans-164
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">总结</samp>
- en: In this final project, you created a pretty complex interactive chart using
    live data fetched from the GitHub Search API. You now have the tools you need
    to create your own custom charts using D3\. We’ve touched on only a small part
    of what this library offers, however; it has support for many different kinds
    of visualizations, like trees, cartographic maps, and other more esoteric layouts.
    Each of these visualization types has the same basis in SVG, data binding, joins,
    scales, and transitions, so what you’ve learned here will set you up well if you
    decide to explore data visualization with JavaScript further. The D3 website,
    [*https://<wbr>d3js<wbr>.org*](https://d3js.org), is an excellent starting point
    for further research.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个最终项目中，你使用从 GitHub 搜索 API 获取的实时数据创建了一个相当复杂的交互式图表。你现在已经掌握了使用 D3 创建自定义图表所需的工具。我们这里只涉及了该库提供的功能的一小部分；实际上，它支持许多不同类型的可视化，比如树状图、制图地图和其他一些更为深奥的布局。每种可视化类型都以
    SVG、数据绑定、连接、比例和过渡为基础，因此，如果你决定进一步探索使用 JavaScript 进行数据可视化，你在这里学到的知识将为你打下良好的基础。[*https://<wbr>d3js<wbr>.org*](https://d3js.org)
    是进一步研究的一个极好的起点。
