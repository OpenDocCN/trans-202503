- en: '9'
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '9'
- en: COMPUTING MACHINES
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 计算机
- en: '![Image](../images/common01.jpg)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/common01.jpg)'
- en: We’re all used to having access to powerful computing devices with complex architectures
    and instruction sets, but fundamental ideas of computer science are based on far
    simpler devices. The basic idea is to begin with the simplest possible devices
    and determine what types of computations are possible. We’ll explore three such
    devices below, ranging from ones that can only perform simple operations like
    recognizing strings to ones that can carry out any algorithm.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 我们都习惯于使用强大的计算设备，这些设备拥有复杂的架构和指令集，但计算机科学的基本理念是基于更简单的设备。基本的思路是从最简单的设备开始，确定哪些类型的计算是可能的。下面我们将探讨三种此类设备，范围从只能执行简单操作（如识别字符串）的设备到能够执行任何算法的设备。
- en: Finite-State Automata
  id: totrans-4
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 有限状态自动机
- en: In this section, we’ll introduce an abstract machine—a computational model,
    not a physical machine—called a *finite-state automaton (FSA)* or *finite-state
    machine (FSM)*. In spite of its impressive name, a finite-state automaton is really
    something very simple. The entire raison d’être of finite-state automata is to
    execute conditional expressions.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将介绍一种抽象机器——计算模型，而非物理机器——称为*有限状态自动机（FSA）*或*有限状态机（FSM）*。尽管其名字很有威慑力，有限状态自动机实际上非常简单。有限状态自动机的存在意义就是执行条件表达式。
- en: An FSA has a (metaphorical) tape with a series of symbols as inputs. Each symbol
    is read exactly once, and the machine then moves to the next symbol in the sequence.
    An FSM is modeled using a finite number of states and transitions, hence the name
    finite-state machine. The machine starts in a given initial state and transitions
    to another state based on the input symbol. It can exist in exactly one state
    at any given time. Some of the states are *accepting states*, and if the machine
    finishes in an accepting state, the input string is valid. It’s possible that,
    depending on the input and possible transitions from a state, the machine can’t
    continue, in which case the string is invalid. The key is that for *every* input,
    there’s a *condition* for each transition.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: FSA（有限状态自动机）有一条（比喻的）带子，上面有一系列符号作为输入。每个符号只读取一次，机器随后会移动到序列中的下一个符号。FSM是通过有限的状态和转换来建模的，因此得名有限状态机。机器从给定的初始状态开始，根据输入符号转换到另一个状态。在任何给定时刻，它只能处于一个状态。一些状态是*接受状态*，如果机器在接受状态结束，输入字符串就是有效的。根据输入和从某个状态出发的可能转换，机器可能无法继续，在这种情况下，字符串就是无效的。关键在于，对于*每个*输入，每个转换都有一个*条件*。
- en: 'Finite-state automata can be used to model many different types of computations,
    but in this section, we’ll focus on their popular use in computer science as *recognizers*:
    programs that, given an input string, indicate whether the sequence is valid or
    invalid. As an example, we’ll look at a recognizer that will accept strings of
    the form “HELLO,” “HELLLO,” “HELLOOO,” and so on, and reject all other strings.
    It’s clear from the nature of this problem that not only does an FSA need to be
    able to perform computations conditionally, but repetition (and hence, iteration)
    also comes into play.'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 有限状态自动机可以用于建模许多不同类型的计算，但在本节中，我们将重点介绍它们在计算机科学中的常见用途——*识别器*：给定输入字符串的程序，判断该字符串是否有效。作为示例，我们将看看一个识别器，它接受形如“HELLO”、“HELLLO”、“HELLOOO”等的字符串，并拒绝所有其他字符串。从这个问题的性质可以看出，FSA不仅需要能够按条件执行计算，而且重复性（因此也包括迭代）也起着作用。
- en: 'There are a number of different ways to represent an FSM program; we’ll employ
    two of them: a *state-transitions diagram* and a *state table*. A state-transitions
    diagram is a directed graph that describes how the FSM transitions from one state
    to the next. Each state is indicated by a circle. The initial state is identified
    by an arrow pointing to one of the states, and the accepting states (there can
    be more than one) are usually indicated by double circles. States are connected
    by lines or arcs, each of which is labeled with an input symbol. The FSM transitions
    from one state to the next based on whether the current input symbol matches the
    label on one of its exiting arcs. A string is said to be accepted if it eventually
    reaches one of the accepting states; otherwise, it’s rejected.'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 表示 FSM 程序有很多不同的方式；我们将使用其中两种：*状态转换图*和*状态表*。状态转换图是一个有向图，描述了 FSM 如何从一个状态转换到另一个状态。每个状态由一个圆圈表示。初始状态由指向某一状态的箭头表示，接受状态（可以有多个）通常由双圆圈表示。状态通过线条或弧连接，每条线或弧上标有输入符号。FSM
    根据当前输入符号是否与其出弧的标签匹配来从一个状态转换到下一个状态。一个字符串如果最终到达某个接受状态，则认为它被接受；否则，它被拒绝。
- en: An FSM for recognizing our “HELLO” strings is shown in [Figure 9-1](ch09.xhtml#ch9fig1).
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 用于识别我们的“HELLO”字符串的 FSM 如[图 9-1](ch09.xhtml#ch9fig1)所示。
- en: '![Image](../images/09fig01.jpg)'
  id: totrans-10
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/09fig01.jpg)'
- en: '*Figure 9-1: An FSM for “HELLO” strings*'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 9-1：用于“HELLO”字符串的 FSM*'
- en: The FSM begins in state 0, and when it receives an “H” for input, it moves to
    state 1; otherwise, it halts at state 0 (indicating a rejected string). Once in
    state 1, it expects an “E” and accepts or rejects the input value as before. It
    proceeds in this fashion until it reaches the final accepting state (state 4).
    Observe that state 3 can accept either an “L” or an “O.” An FSM, such as this
    one, built in such a way that every state has only a single transition for each
    input symbol, is called a *deterministic FSM* (or a *DFA*). It’s possible to build
    finite-state automata where one or more states may transition to more than one
    state for the same input symbol. Such an FSM is called a *nondeterministic FSM*
    (or an *NFA*). For any nondeterministic FSM, we can construct a deterministic
    FSM so they’re both capable of recognizing the same set of strings. The advantage
    of nondeterministic FSMs is that in some cases, they’re simpler than their deterministic
    counterparts. In this text, we’ll only be using deterministic finite-state machines.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: FSM 从状态 0 开始，当接收到输入“H”时，它会转移到状态 1；否则，它会停留在状态 0（表示字符串被拒绝）。一旦进入状态 1，它会期待一个“E”并像之前一样接受或拒绝输入值。它以这种方式继续，直到到达最终的接受状态（状态
    4）。请注意，状态 3 可以接受“L”或“O”。像这样的 FSM，每个状态对于每个输入符号只有一个转换，称为*确定性有限状态机*（或*DFA*）。也可以构建有限状态自动机，其中一个或多个状态对于相同的输入符号可能转移到多个状态。这种
    FSM 称为*非确定性有限状态机*（或*NFA*）。对于任何非确定性 FSM，我们可以构造一个确定性 FSM，使它们都能识别相同的字符串集。非确定性 FSM
    的优势在于，在某些情况下，它们比确定性版本更简单。在本书中，我们将只使用确定性有限状态机。
- en: We can also represent our FSM as a state table (sometimes called an *event table*).
    See [Table 9-1](ch09.xhtml#ch9tab1). The first column of the table contains the
    state number, and the remaining columns represent the input symbols. The table
    cells contain the next state for a given input symbol. If no state is given, the
    input symbol is rejected.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以将我们的有限状态机（FSM）表示为一个状态表（有时称为*事件表*）。请参见[表 9-1](ch09.xhtml#ch9tab1)。表的第一列包含状态编号，其余列表示输入符号。表格单元格包含给定输入符号对应的下一个状态。如果没有给出状态，则该输入符号会被拒绝。
- en: '**Table 9-1**: State Table for "HELLO" Strings'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: '**表 9-1**： “HELLO” 字符串的状态表'
- en: '| S | H | E | L | O |'
  id: totrans-15
  prefs: []
  type: TYPE_TB
  zh: '| S | H | E | L | O |'
- en: '| 0 | 1 |  |  |  |'
  id: totrans-16
  prefs: []
  type: TYPE_TB
  zh: '| 0 | 1 |  |  |  |'
- en: '| 1 |  | 2 |  |  |'
  id: totrans-17
  prefs: []
  type: TYPE_TB
  zh: '| 1 |  | 2 |  |  |'
- en: '| 2 |  |  | 3 |  |'
  id: totrans-18
  prefs: []
  type: TYPE_TB
  zh: '| 2 |  |  | 3 |  |'
- en: '| 3 |  |  | 3 | 4 |'
  id: totrans-19
  prefs: []
  type: TYPE_TB
  zh: '| 3 |  |  | 3 | 4 |'
- en: '| 4 |  |  |  | 4 |'
  id: totrans-20
  prefs: []
  type: TYPE_TB
  zh: '| 4 |  |  |  | 4 |'
- en: 'To implement an FSM to recognize our “HELLO” strings in Racket, we first define
    a state table as follows:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 为了在 Racket 中实现一个 FSM 来识别我们的“HELLO”字符串，我们首先定义一个状态表，如下所示：
- en: '[PRE0]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: In this case, we’re using `#f` to indicate an invalid transition.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们使用 `#f` 来表示无效的转换。
- en: Since we’re using vectors for our state table, we need a way to convert characters
    to indexes. This is done with a hash table, as shown in the following definition.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们使用向量来表示状态表，我们需要一种方法将字符转换为索引。这是通过哈希表来实现的，如下面的定义所示。
- en: '[PRE1]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Given a state number and character, the following `next-state` function gives
    the next state (or `#f`) from the state table.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 给定一个状态编号和字符，以下的 `next-state` 函数会根据状态表返回下一个状态（或 `#f`）。
- en: '[PRE2]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Finally, here’s the DFA to recognize our “HELLO” strings.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，这是用来识别我们“HELLO”字符串的DFA。
- en: '[PRE3]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: First, we convert our string to a list of characters ➊. Then we loop on this
    list, first checking to see whether all the characters have been read ➋. We then
    check the state ➌. If we’re in an accepting state (in this case, state 4), we
    return `#t` indicating an accepted string; otherwise, we return `#f`. If the entire
    string hasn’t been processed, we get the next state and the rest of the string
    ➍. We then start the process over again with the remainder of the string ➎. Here
    are a few sample runs.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将字符串转换为字符列表 ➊。然后我们遍历这个列表，首先检查是否所有字符都已经被读取 ➋。接着我们检查状态 ➌。如果我们处于接受状态（在本例中是状态4），我们返回`#t`表示接受的字符串；否则，我们返回`#f`。如果整个字符串还没有处理完，我们获取下一个状态和剩余的字符串
    ➍。然后我们用剩余的字符串重新开始这个过程 ➎。下面是一些示例运行。
- en: '[PRE4]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: It turns out that finite-state automata (both deterministic and nondeterministic)
    have certain limitations. For example, it’s not possible to build a finite-state
    machine that recognizes matching parentheses (since at any point, we would need
    a mechanism to remember how many open parentheses had been encountered). In the
    next section, we’ll introduce the FSM’s smarter brother, the Turing machine.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 事实证明，有限状态自动机（无论是确定性还是非确定性）都有一定的局限性。例如，不可能构建一个识别匹配括号的有限状态机（因为在任何时刻，我们都需要一个机制来记住遇到多少个左括号）。在下一节中，我们将介绍有限状态机的更智能的兄弟——图灵机。
- en: The Turing Machine
  id: totrans-33
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 图灵机
- en: The *Turing machine* is an invention of the brilliant British mathematician
    Alan Turing. In its simplest form, a Turing machine is an abstract computer that
    consists of the following components.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: '*图灵机*是英国杰出数学家艾伦·图灵的发明。在最简单的形式下，图灵机是一个由以下组件构成的抽象计算机。'
- en: An infinite tape of cells that can contain either a zero or a one (arbitrary
    symbols are also allowed, but we don’t use them here)
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一条可以包含零或一的无限带（也允许任意符号，但我们在这里不使用）
- en: A head that can read or write a value in each cell and move left or right (see
    [Figure 9-2](ch09.xhtml#ch9fig2))
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个可以在每个单元格中读取或写入值并向左或向右移动的头（参见[图9-2](ch09.xhtml#ch9fig2)）
- en: A state table
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个状态表
- en: A state register that contains the current state
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个包含当前状态的状态寄存器
- en: '![Image](../images/09fig02.jpg)'
  id: totrans-39
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/09fig02.jpg)'
- en: '*Figure 9-2: Turing machine tape and head*'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: '*图9-2：图灵机带和头部*'
- en: Despite this apparent simplicity, given any computer algorithm, a Turing machine
    can be constructed that’s capable of simulating that algorithm’s logic. Conversely,
    any computing device or programming language that can simulate a Turing machine
    is said to be *Turing complete*. Thus, a Turing machine is not hampered by the
    limitations we mentioned for finite-state automata. There’s a large body of literature
    where the Turing machine plays into the analysis of whether certain functions
    are theoretically computable. We won’t engage in these speculations, but rather
    concentrate on the basic operation of the machine itself.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管这看似简单，但对于任何计算机算法，都可以构造一个图灵机来模拟该算法的逻辑。反过来，任何可以模拟图灵机的计算设备或编程语言都被称为*图灵完备*。因此，图灵机不受我们前面提到的有限状态自动机的局限性。关于图灵机在分析某些函数是否在理论上可计算的文献非常丰富。我们不会深入这些推测，而是集中讨论机器本身的基本操作。
- en: The machine we construct will have the simple task of adding two numbers. A
    number, *n*, will be represented as a contiguous string of *n* ones. The numbers
    to be added will be separated by a single zero, and the head will be positioned
    at the leftmost one of the first number. The result will be a string of ones,
    whose length will be the sum of the two numbers. At the end of the computation,
    the head will be positioned at the leftmost one of the result.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 我们构造的机器将执行一个简单的任务——加两个数字。一个数字，*n*，将表示为由*n*个一组成的连续字符串。要加的两个数字将由一个零分隔，头部将位于第一个数字的最左边的一个一上。结果将是一个由一组成的字符串，其长度是两个数字的和。在计算结束时，头部将位于结果的最左边的一个一上。
- en: 'In a nutshell, the program works by changing the leftmost one of the leftmost
    number to zero, then scanning to the right until it reaches the end of the second
    number and writing a one just after the last one. The head then moves to the left
    until one of two things happens:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 简而言之，程序通过将最左边的最左边数字中的一个一改为零，然后向右扫描，直到遇到第二个数字的末尾，并在最后一个一后写入一个一。然后头部向左移动，直到发生以下两种情况之一：
- en: It encounters a zero followed by a one, which means there are more ones left
    to move, so it continues to the left so that it can start over.
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它遇到一个零，后跟一个一，这意味着还有更多的1需要移动，所以它继续向左移动，以便重新开始。
- en: It encounters two consecutive zeros, in which case the addition is done (because
    there are no other ones left from the first number), and it moves to the right
    until it is positioned over the leftmost one of the final number.
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它遇到两个连续的零，在这种情况下，进行加法操作（因为第一个数字没有剩下其他的1），并向右移动，直到它定位在最终数字最左边的1上。
- en: '[Figure 9-3](ch09.xhtml#ch9fig3) contains some snapshots of the tape at various
    times during the computation (the triangle shows the head at the start and end
    of the computation).'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 9-3](ch09.xhtml#ch9fig3)展示了计算过程中不同时间的带子快照（图中的三角形表示计算开始和结束时的头位置）。'
- en: '![Image](../images/09fig03.jpg)'
  id: totrans-47
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/09fig03.jpg)'
- en: '*Figure 9-3: The tale of the tape*'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 9-3：带子的故事*'
- en: You may have already figured out that there are more direct ways to combine
    the two strings of numbers, but the method described lends itself to being adapted
    to other computations like multiplication.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能已经猜到，实际上有更直接的方法来组合这两串数字，但所描述的方法更适合应用于其他计算，例如乘法。
- en: Programming a Turing machine consists of constructing a *state table*. Each
    row in the table represents a particular state. Each state specifies three actions
    depending on whether the head currently reads a zero or a one. The actions will
    be to either write a one or a zero to the current cell, whether to move left or
    right afterward, and what the next state should be. [Table 9-2](ch09.xhtml#ch9tab2)
    contains our adder program.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 编程图灵机包括构造一个*状态表*。表中的每一行表示一个特定的状态。每个状态根据当前头部读取的零或一来指定三种动作。这些动作包括：写入1或0到当前单元格、接下来是向左或向右移动，以及下一个状态应该是什么。[表
    9-2](ch09.xhtml#ch9tab2)包含了我们的加法器程序。
- en: '**Table 9-2**: Turing Machine State Table'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: '**表 9-2**：图灵机状态表'
- en: '![Image](../images/p0264.jpg)'
  id: totrans-52
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/p0264.jpg)'
- en: The topmost row indicates the input symbol. The columns labeled with a W indicate
    the value that should be written, the columns headed by an M indicate the direction
    to move (left or right), and the columns headed by an N indicate the next state
    number. Entries marked with an x are states that will never be reached (this is
    assuming the inputs and start state are properly set)—in such cases, the entries
    would be irrelevant. The machine starts in state 0\. The final state (or halting
    state) is state 7, indicted by an H in the move column for a one input.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 最上面的行表示输入符号。标有W的列表示应写入的值，标有M的列表示移动方向（向左或向右），标有N的列表示下一个状态编号。标有x的条目表示永远不会到达的状态（假设输入和起始状态设置正确）——在这种情况下，条目将无关紧要。机器从状态0开始。最终状态（或停机状态）是状态7，在一的输入的移动列中以H表示。
- en: 'An alternative (and possibly easier-to-decipher) method of representing a Turing
    machine’s state changes is with a state-transition diagram, as shown in [Figure
    9-4](ch09.xhtml#ch9fig4). In the state diagram, each transition label has three
    components: the symbol being read, the symbol to write, and the direction to move.'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 表示图灵机状态变化的另一种方法（可能更容易解读）是使用状态转换图，如[图 9-4](ch09.xhtml#ch9fig4)所示。在状态图中，每个转换标签包含三个组成部分：读取的符号、要写入的符号，以及移动的方向。
- en: '![Image](../images/09fig04.jpg)'
  id: totrans-55
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/09fig04.jpg)'
- en: '*Figure 9-4: Turing machine state-transition diagram*'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 9-4：图灵机状态转换图*'
- en: '***A Racket Turing Machine***'
  id: totrans-57
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***一个Racket图灵机***'
- en: 'As mentioned at the beginning of this section, a programming language that
    can simulate a Turing machine is said to be Turing complete. We’ll demonstrate
    that Racket is itself Turing complete by constructing just such a simulation (using
    our addition machine as an example program). We’ll of course have to compromise
    a bit on the infinite tape, so our machine will have a more modest tape, with
    just 10 cells. The state table will consist of a vector where each cell represents
    a state. Each state is a two-cell vector where the first cell consists of the
    actions when a zero is read, and the second cell consists of the actions when
    a one is read. The actions will be represented by a structure called `act`. The
    `act` structure will have fields `write`, `move`, and `next` (with obvious meanings).
    The state will be given in a variable called `state`, and the position of the
    head will be in `head`. Given these initial considerations, we have the following:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 正如本节开头提到的，能够模拟图灵机的编程语言被称为图灵完备。我们将通过构建这样一个模拟来演示Racket本身是图灵完备的（以我们的加法机作为示例程序）。当然，我们不得不在无限磁带上做一些妥协，因此我们的机器将拥有更为简单的磁带，只有10个单元格。状态表将由一个向量组成，其中每个单元格代表一个状态。每个状态是一个包含两个单元格的向量，第一个单元格包含读取零时的动作，第二个单元格包含读取一时的动作。动作将由一个名为`act`的结构表示。`act`结构将包含字段`write`、`move`和`next`（含义显而易见）。状态将存储在一个名为`state`的变量中，而头部位置则在`head`中。考虑到这些初步设定，我们有如下内容：
- en: '[PRE5]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: While not strictly required by the definition, we’ve included an `#f` value
    (indicating fail) in the “don’t care” states just in case there was some error
    introduced in the initial setup of the problem (hey, nobody’s perfect).
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管在定义中并不严格要求，我们在“无关”状态中加入了一个`#f`值（表示失败），以防在问题初始设置时引入了某些错误（嘿，谁能做到完美呢）。
- en: Before getting to the code that specifies the machine’s execution, we define
    a few helper functions to get at various components. The first function returns
    the next state given the current state and input symbol, and the other two get
    and set the value at the tape head.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 在编写指定机器执行的代码之前，我们定义了几个辅助函数来获取各个组件。第一个函数返回给定当前状态和输入符号时的下一个状态，其他两个函数用于获取和设置磁带头的值。
- en: '[PRE6]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The program for running the machine is straightforward. Note that this code
    is the same for *any* Turing machine you program; only the `tape` and `state-table`
    change.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 运行该机器的程序很简单。请注意，这段代码对于*任何*你编程的图灵机都是一样的；只有`tape`和`state-table`会有所变化。
- en: '[PRE7]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: First we capture the actions for the current state and input ➊. Then we capture
    the next symbol to write ➌ and update the next state ➐. We also test whether the
    head is about to change a value on the tape ➍, in which case we print out the
    updated tape ➏. The head position is updated earlier ➎. Once the final state is
    reached ➋, the program will print `Done!`. Here’s the output.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们捕捉当前状态和输入➊的动作。然后，我们捕捉下一个要写入的符号➌，并更新下一个状态➐。我们还测试头部是否即将改变磁带上的值➍，如果是这种情况，我们会打印出更新后的磁带➏。头部位置会提前更新➎。一旦达到最终状态➋，程序会打印`Done!`。以下是输出结果。
- en: '[PRE8]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Pushdown Automata
  id: totrans-67
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 推入自动机
- en: The phrase “pushdown automata” is not a call to go out and knock over un-suspecting
    robots. No, the term *pushdown automaton* (or *PDA*) refers to a class of abstract
    computing devices that use a *pushdown stack* (or just *stack* to friends). In
    terms of computing power, pushdown automata lie squarely between that of finite-state
    automata and Turing machines.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: “推入自动机”这个词并不是让你去推翻毫无防备的机器人。不，术语*推入自动机*（或*PDA*）指的是一类抽象计算设备，它们使用*推入堆栈*（或仅称为*堆栈*）。从计算能力上讲，推入自动机的能力恰好介于有限状态自动机和图灵机之间。
- en: 'The advantage of a PDA over a finite-state automaton lies in the stack. The
    stack forms a basic type of memory. Conceptually, a stack is like a stack of plates
    where you’re only allowed to remove a plate from the top of the stack (called
    a pop) or add (push) a plate to the top. The rest of the stack can only be accessed
    via adds or removes from the top. To simulate this in Racket, we define a stack
    as a string of symbols with two operations:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: PDA相较于有限状态自动机的优势在于堆栈。堆栈形成了一种基本的内存类型。从概念上讲，堆栈就像一堆盘子，你只能从堆栈顶端移走一个盘子（称为弹出操作）或把一个盘子添加到顶部（称为推入操作）。堆栈的其余部分只能通过从顶部进行添加或移除来访问。为了在Racket中模拟这一点，我们将堆栈定义为一个符号串，并且提供两个操作：
- en: '**Push**. This operation adds a symbol to the top of the stack (front of the
    string).'
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**推入（Push）**。此操作将一个符号添加到堆栈的顶部（字符串的前端）。'
- en: '**Pop**. Pop removes the symbol at the top of the stack and returns it.'
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**弹出（Pop）**。弹出操作移除堆栈顶部的符号并返回该符号。'
- en: A PDA is allowed to read the top symbol on the stack, but it has no access to
    other stack values. Stack values don’t necessarily have to match the values used
    as input symbols.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: PDA 允许读取栈顶符号，但无法访问其他栈值。栈值不一定要与输入符号相匹配。
- en: Like an FSA, a PDA sequentially reads its input and uses state transitions to
    determine the next state, but a PDA has the requirement that in addition to being
    in an accepting state, the stack must also be empty for a string to be accepted
    (but for practical purposes, in the example below we pre-populate the stack with
    a unique marker to indicate an empty stack). Be aware that pushdown automata come
    in deterministic and nondeterministic varieties. Further, nondeterministic pushdown
    automata are capable of performing a wider range of computations.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 像 FSA 一样，PDA 按顺序读取输入并通过状态转移来确定下一个状态，但 PDA 有一个要求：除了处于接受状态外，栈也必须为空，才能接受字符串（但为了实际应用，在下面的示例中我们预先在栈中放入一个唯一标记来表示空栈）。需要注意的是，压栈自动机有确定性和非确定性两种类型。此外，非确定性压栈自动机能够执行更广泛的计算。
- en: While we generally try to keep the presentation informal, we’re going to provide
    a formal description of a PDA since you’re likely to run across this type of notation
    if you elect to do further research on abstract computing machines.^([1](footnote.xhtml#ch09foot_1))
    If you’re not familiar with set notation, you may want to jump to “Set Theory”
    in [Chapter 4](ch04.xhtml) to brush up.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管我们通常尽量保持介绍的非正式性，但我们将提供一个 PDA 的正式描述，因为如果你决定进一步研究抽象计算机，你很可能会遇到这种类型的符号表示。^([1](footnote.xhtml#ch09foot_1))
    如果你不熟悉集合符号，可能需要跳到 [第 4 章](ch04.xhtml) 中的“集合理论”部分来复习。
- en: 'Generally, a PDA is defined as a machine *M* = (*Q*, *Σ*, *Γ*, *q*[0], *Z*,
    *F*, *δ*), where the following is true:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，PDA 被定义为一个机器 *M* = (*Q*, *Σ*, *Γ*, *q*[0], *Z*, *F*, *δ*)，其中以下内容成立：
- en: '*Q* is a finite set of states.'
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*Q* 是有限状态集。'
- en: '*Σ* is the set of input symbols.'
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*Σ* 是输入符号的集合。'
- en: '*Γ* is the set of possible stack values.'
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*Γ* 是可能的栈值集合。'
- en: '*q*[0] ∈ *Q* is the start state.'
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*q*[0] ∈ *Q* 是起始状态。'
- en: '*Z* ∈ *Γ* is the initial stack symbol.'
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*Z* ∈ *Γ* 是初始栈符号。'
- en: '*F* ⊆ *Q* is the set of accepting states.'
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*F* ⊆ *Q* 是接受状态的集合。'
- en: '*δ* is the set of possible transitions.'
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*δ* 是可能的转移集合。'
- en: The set of permissible transitions are then defined by this somewhat intimidating
    expression (where Γ^* is used to designate all the possible stack strings, and
    the symbol ϵ is used to represent the empty string, a string with no symbols in
    it).
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 允许的转移集合由这个略显复杂的表达式定义（其中 Γ^* 用于表示所有可能的栈字符串，符号 ϵ 用来表示空字符串，即没有任何符号的字符串）。
- en: δ ⊆ (Q × (Σ ∪ {ϵ}) × Γ) × (Q × Γ*)
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: δ ⊆ (Q × (Σ ∪ {ϵ}) × Γ) × (Q × Γ*)
- en: 'This isn’t as bad as it looks. It’s basically saying that the set of possible
    transitions is a subset of all possible combinations of states, input symbols,
    and stack values (that is, all possibilities pre-transition) with all possible
    states and stack strings (the possibilities post-transition). The first set of
    values in parentheses represents inputs to the transition function and consists
    of the following:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 这并不像看起来那么复杂。基本上，它是说可能的转移集合是所有可能的状态、输入符号和栈值组合的子集（也就是说，转移前的所有可能性），以及所有可能的状态和栈字符串（转移后的所有可能性）。括号中的第一组值表示转移函数的输入，包括以下内容：
- en: 'the currents state: *q* ∈ *Q*'
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当前状态：*q* ∈ *Q*
- en: 'the current input symbol: *i* ∈ (*Σ* ∪ {ϵ}) (remember that we use *ϵ* to indicate
    that the remaining string can be empty at some point)'
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当前输入符号：*i* ∈ (*Σ* ∪ {ϵ})（记住，我们使用 *ϵ* 来表示在某个时刻剩余的字符串可以为空）
- en: 'the value at the top of the stack: *s* ∈ *Γ*'
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 栈顶的值：*s* ∈ *Γ*
- en: Given these values, a transition defines the next state (the second *Q*) and
    the potential new stack values (Γ^*). For any transition, either the stack will
    be unaltered, new values will be pushed, or a value will be popped from the top.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 给定这些值，转移定义了下一个状态（第二个 *Q*）和潜在的新栈值（Γ^*）。对于任何转移，栈要么不变，要么推入新值，或者从栈顶弹出一个值。
- en: Changes to the stack are designated by the notation *a*/*b*, where *a* is the
    symbol at the top of the stack and *b* is the resulting string at the top of the
    stack. For example, if we match some input symbol, the value *α* is at the top
    of the stack, and we pop this value without replacing it, we designate this by
    *α*/*ϵ*. If we match the input with *α* at the top of the stack and need to push
    *β* to the top of the stack, this would be designated as *α*/*βα*.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 栈的变化通过符号 *a*/*b* 表示，其中 *a* 是栈顶的符号，*b* 是栈顶结果的字符串。例如，如果我们匹配某个输入符号，栈顶是 *α*，并且我们弹出这个值而不替换它，那么我们用
    *α*/*ϵ* 来表示。如果我们匹配输入时栈顶是 *α*，并且需要将 *β* 压入栈顶，则表示为 *α*/*βα*。
- en: '***Recognizing Zeros and Ones***'
  id: totrans-91
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***识别零和一***'
- en: Let’s set the formalities aside for now and look at a simple example. A popular
    exercise is to build a PDA that recognizes a string of zeros followed by ones
    such that the string of ones is exactly the same length as the string of zeros.
    This isn’t possible with a finite-state automaton, since it would need to remember
    how many zeros it had scanned before it started scanning the ones.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们暂时搁置形式化内容，来看一个简单的例子。一种常见的练习是构建一个 PDA，它能够识别由零和一组成的字符串，其中一串一的长度正好与一串零的长度相等。使用有限状态自动机是做不到这一点的，因为它需要记住在开始扫描一之前已经扫描了多少个零。
- en: The expression 0^(*n*)1^(*n*) denotes the string format we’re looking for (zero
    repeated *n* times followed by one repeated *n* times), and our input alphabet
    is Σ = {0, 1}. Any other inputs won’t be accepted. To recognize this string, we
    only need to keep track of the number of zeros read so far, so we’ll push a zero
    to the top of the stack whenever a zero is encountered in the input. When a one
    is encountered, we pop a zero off the stack; if the number of zeros and ones matches,
    no zeros will remain on the stack at the end of the input. In order to tell when
    we have popped the last zero from the stack, we’ll pre-populate the stack with
    a special marker, *ω*. So our stack symbols are the set Γ = {0, ω}.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 表达式 0^(*n*)1^(*n*) 表示我们要寻找的字符串格式（零重复 *n* 次，后跟一重复 *n* 次），我们的输入字母表是 Σ = {0, 1}。任何其他输入都不会被接受。为了识别这个字符串，我们只需要跟踪已经读取的零的数量，因此每当输入中遇到零时，我们会将零压入栈顶。当遇到一时，我们从栈中弹出一个零；如果零和一的数量匹配，输入结束时栈中将不剩任何零。为了判断何时弹出了栈中的最后一个零，我们会预先在栈中放入一个特殊标记
    *ω*。因此我们的栈符号集是 Γ = {0, ω}。
- en: '[Figure 9-5](ch09.xhtml#ch9fig5) is the transition diagram for our PDA.'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 9-5](ch09.xhtml#ch9fig5) 是我们 PDA 的状态转移图。'
- en: '![Image](../images/09fig05.jpg)'
  id: totrans-95
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/09fig05.jpg)'
- en: '*Figure 9-5: Pushdown automaton for* 0^(*n*)1^(*n*)'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 9-5：用于* 0^(*n*)1^(*n*)的下推自动机'
- en: The label 0;*ω*/0*ω* on the transition looping back to state 0 represents reading
    a zero on the input with the marker *ω* at the top of the stack and pushing a
    zero to the stack. (This is the first transition taken.) Likewise, the label 0;0/00
    on this loop represents reading a zero on the input with a zero at the top of
    the stack and pushing a zero to the stack. The label 1;0/*ϵ* on the transition
    from state 0 to state 1 represents reading a one on the input and popping a zero
    from the stack. The loop on state 1 continues to read ones on the input and pops
    a zero from the stack for each one read. Once there are no input values and the
    stack is empty of zeros, the machine moves to state 2, which is an accepting state.
    Clearly the stack must contain the same number of zeros as the number of ones
    read in order for the accepting state to be reached.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 转移到状态 0 的循环上标签 0;*ω*/0*ω* 表示在输入中读取一个零，并且栈顶的标记是 *ω*，然后将零压入栈中。（这是第一个转移。）同样，标签
    0;0/00 表示在输入中读取一个零，并且栈顶是零，然后将零压入栈中。标签 1;0/*ϵ* 表示从状态 0 转移到状态 1，表示读取一个一，并从栈中弹出一个零。状态
    1 上的循环继续读取输入中的一，并为每个读取的零从栈中弹出一个零。一旦没有更多的输入值，并且栈中没有零，机器将转移到状态 2，这是一个接受状态。显然，栈中必须包含与读取的零和一相同数量的零，才能到达接受状态。
- en: '***More Zeros and Ones***'
  id: totrans-98
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***更多的零和一***'
- en: Suppose we up the ante a bit and allow any string of zeros and ones, with the
    only requirement being that there’s an equal number of zeros and ones.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们稍微提高难度，允许任何零和一的字符串，唯一的要求是零和一的数量相等。
- en: 'Again we assume that the stack is preloaded with *ω*. This time we allow both
    zero and one onto the stack. The process is basically this:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 再次假设栈已经预加载了 *ω*。这次我们允许零和一都进入栈中。这个过程基本上是这样的：
- en: If the top of the stack is *ω* and there’s no more input, the string is accepted.
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果栈顶是 *ω*，且没有更多输入，则接受该字符串。
- en: If the top of the stack is *ω*, push the symbol being read.
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果栈顶是 *ω*，则将当前读取的符号压入栈中。
- en: If the top of the stack is the same as the symbol being read, push the symbol
    being read.
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果栈顶的符号与当前读取的符号相同，则将当前读取的符号压入栈中。
- en: Otherwise, pop the symbol being read.
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 否则，弹出当前读取的符号。
- en: This process is illustrated by the transition diagram in [Figure 9-6](ch09.xhtml#ch9fig6).
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 该过程通过[图9-6](ch09.xhtml#ch9fig6)中的状态转移图进行了说明。
- en: Neither of these recognizers is possible with finite-state automata. This is
    due to the fact that in both cases there’s a need to remember the number of symbols
    previously read. The PDA stack (which is not available in a plain FSA) provides
    this capability.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 这两种识别器都无法使用有限状态自动机（FSA）来实现。这是因为在这两种情况下，都需要记住之前读取的符号数量。PDA 栈（在普通 FSA 中不可用）提供了这一功能。
- en: '![Image](../images/09fig06.jpg)'
  id: totrans-107
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/09fig06.jpg)'
- en: '*Figure 9-6: PDA to match count of zeros and ones*'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: '*图9-6：PDA 用于匹配零和一的计数*'
- en: '***A Racket PDA***'
  id: totrans-109
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***一个 Racket PDA***'
- en: In this section, we’ll construct a PDA to recognize the strings described in
    [Figure 9-6](ch09.xhtml#ch9fig6). The input will be a list consisting of some
    sequence of ones and zeros. To process the input, we’ll define `make-reader`,
    which returns another function.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将构造一个 PDA 来识别[图9-6](ch09.xhtml#ch9fig6)中描述的字符串。输入将是一个包含若干个 1 和 0 的序列的列表。为了处理该输入，我们将定义
    `make-reader`，它返回另一个函数。
- en: '[PRE9]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: We call `make-reader` with the list we want to use as input, and it returns
    a function that will return the next value in the list every time it’s called.
    Here’s an example of how it’s used.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用 `make-reader` 函数，并传入我们希望用作输入的列表，它将返回一个函数，每次调用时返回列表中的下一个值。以下是如何使用它的示例。
- en: '[PRE10]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The stack will also be represented by a list. The following code gives the definitions
    we need to perform the various stack operations.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 栈也将由一个列表表示。以下代码给出了执行各种栈操作所需的定义。
- en: '[PRE11]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Since there’s only one state of any significance, we won’t bother building a
    state table. We’ll instead take this as an opportunity to exercise another of
    Racket’s hidden treasures, *pattern matching*. This form of pattern matching is
    Racket’s built-in pattern matching as distinct from the pattern matching capability
    provided by the Racklog library introduced in [Chapter 8](ch08.xhtml). Pattern
    matching uses the `match` form included in the *racket/match* library.^([2](footnote.xhtml#ch09foot_2))
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 由于只有一个有意义的状态，我们不必费心构建状态表。我们将借此机会练习 Racket 的另一个隐藏宝藏——*模式匹配*。这种模式匹配是 Racket 内置的，与在[第8章](ch08.xhtml)中介绍的
    Racklog 库提供的模式匹配功能不同。模式匹配使用 `match` 表达式，该表达式包含在 *racket/match* 库中。^([2](footnote.xhtml#ch09foot_2))
- en: A `match` expression looks a bit like a `cond` expression, but instead of having
    to use a complex Boolean expression, we simply provide the data structure we want
    to match against. It’s possible to use a number of different structures as patterns
    to match against, including literal values, but we’ll simply use a list for this
    exercise.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: '`match` 表达式看起来有点像 `cond` 表达式，但我们无需使用复杂的布尔表达式，而是简单地提供我们想要匹配的数据结构。我们可以使用许多不同的结构作为匹配模式，包括字面值，但我们在这个练习中将简单地使用一个列表。'
- en: '[PRE12]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Notice how the `match` expression closely mirrors the transitions shown in [Figure
    9-6](ch09.xhtml#ch9fig6). We use `#t` and `#f` to signal whether the input is
    accepted or rejected. A single underscore (`_`) serves as a wildcard that matches
    anything. In this case, matching the wildcard would indicated a rejected string.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，`match` 表达式如何紧密地与[图9-6](ch09.xhtml#ch9fig6)中显示的状态转移相似。我们使用 `#t` 和 `#f` 来表示输入是否被接受或拒绝。单个下划线（`_`）作为通配符，匹配任何内容。在这种情况下，匹配通配符表示该字符串被拒绝。
- en: Let’s take it for a spin.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们试试看。
- en: '[PRE13]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '***More Automata Fun***'
  id: totrans-122
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***更多的自动机乐趣***'
- en: Here are a couple of other PDA exercises you may want to try on your own.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 这是另外几个你可以自己尝试的 PDA 练习。
- en: Construct a PDA that matches parentheses (for example, “(())((()))” okay, “(())((())”
    not okay).
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构建一个匹配括号的 PDA（例如，“(())((()))” 是正确的，“(())((())” 不是正确的）。
- en: Build a palindrome recognizer (for example, “madam i’m adam” or “racecar").
    This one is tricky and requires constructing a nondeterministic PDA (and also
    ignoring spaces and punctuation).
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构建一个回文识别器（例如，“madam i’m adam” 或 “racecar”）。这个比较棘手，需要构造一个非确定性 PDA（还要忽略空格和标点符号）。
- en: A Few Words About Languages
  id: totrans-126
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 关于语言的一些话
- en: Finite-state automata and pushdown automata serve as recognizers for different
    classes of languages. A set of symbol strings is called a *regular language* if
    there’s some finite-state machine that accepts the entire set of strings. Examples
    of regular languages are the set of strings of digits that represent integers,
    or strings representing floating-point numbers like 1.246e52.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 有限状态自动机和下推自动机作为不同类型语言的识别器发挥作用。如果有某个有限状态机器能够接受整个符号字符串集合，那么这个符号字符串集合就叫做*正则语言*。正则语言的例子包括表示整数的数字字符串集合，或者像
    1.246e52 这样的浮点数表示字符串。
- en: The set of valid arithmetic expressions (for example, *a* + *x*(1 + *y*)) is
    an example of a context-free grammar (CFG). A language consisting of strings accepted
    by a pushdown automaton is called a context-free language. This means we can construct
    a pushdown automaton to recognize arithmetic expressions.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 有效的算术表达式集合（例如，*a* + *x*(1 + *y*)）是上下文无关文法（CFG）的一个例子。由下推自动机接受的字符串所组成的语言被称为上下文无关语言。这意味着我们可以构造一个下推自动机来识别算术表达式。
- en: Finite-state automata and pushdown automata play a key role in converting modern-day
    computer language strings into tokens that can then be fed to a PDA to parse the
    input language. The parser converts the input language into something called an
    *abstract syntax tree*, which can then be fed to a compiler or interpreter for
    further processing.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 有限状态自动机和下推自动机在将现代计算机语言字符串转换为令牌中发挥着关键作用，这些令牌可以被传递给 PDA 进行语法分析。解析器将输入语言转换为一种叫做*抽象语法树*的结构，然后可以将其传递给编译器或解释器进行进一步处理。
- en: Summary
  id: totrans-130
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 总结
- en: 'In this chapter, we explored a number of simple computing machines: finite-state
    automata, pushdown automata, and the Turing machine. We saw that, while simple,
    such machines are capable of solving practical problems. In the next chapter,
    we’ll make extensive use of these concepts where their capability to recognize
    general classes of strings and expressions will be used to develop an interactive
    calculator.'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们探讨了几种简单的计算机机器：有限状态自动机、下推自动机和图灵机。我们看到，尽管这些机器简单，但它们能够解决实际问题。在下一章中，我们将广泛应用这些概念，它们识别通用字符串和表达式的能力将用于开发一个交互式计算器。
