- en: '**9**'
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '**9**'
- en: '**POINTER DATA TYPES**'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: '**指针数据类型**'
- en: '![image](../images/common01.jpg)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/common01.jpg)'
- en: 'Pointers are the data type equivalent of a `goto` statement. Used carelessly,
    they can turn a robust and efficient program into a buggy and inefficient junk
    pile. Unlike `goto` statements, however, pointers can be difficult to avoid in
    many common programming languages. There are no “pointers considered harmful”
    papers in academic journals like Dijkstra’s “Go To Statement Considered Harmful”
    letter.^([1](footnotes.xhtml#ch9fn1)) Many languages, like Java and Swift, attempt
    to restrict pointers, but several popular languages still use them, so great programmers
    need to be able to deal with them. To that end, this chapter will discuss:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 指针是 `goto` 语句的数据类型等价物。若使用不当，它们会将一个稳健高效的程序变成一个充满 bug 和效率低下的垃圾堆。然而，与 `goto` 语句不同，指针在许多常见编程语言中难以避免。像
    Dijkstra 的《Go To 语句不良影响》一文那样的“指针有害”文章，在学术期刊中是不存在的。^[1] 许多语言，如 Java 和 Swift，试图限制指针，但一些流行语言仍然使用它们，因此优秀的程序员需要能够处理它们。因此，本章将讨论：
- en: The memory representation of pointers
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 指针的内存表示
- en: How high-level languages implement pointers
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 高级语言如何实现指针
- en: Dynamic memory allocation and its relationship to pointers
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 动态内存分配及其与指针的关系
- en: Pointer arithmetic
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 指针运算
- en: How memory allocators work
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 内存分配器如何工作
- en: Garbage collection
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 垃圾回收
- en: Common pointer problems
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 常见的指针问题
- en: By understanding the low-level implementation and use of pointers, you’ll be
    able to write high-level code that is more efficient, safer, and more readable.
    This chapter will provide the information you need to use pointers appropriately
    and avoid the problems normally associated with them.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 通过理解指针的低级实现和使用，你将能够编写更高效、更安全、更易读的高级代码。本章将提供你需要的所有信息，帮助你正确使用指针，并避免通常与指针相关的问题。
- en: '**9.1 The Definition of a Pointer**'
  id: totrans-12
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**9.1 指针的定义**'
- en: A pointer is simply a variable whose value refers to some other object. High-level
    languages like Pascal and C/C++ hide the simplicity of pointers behind a wall
    of abstraction. HLL programmers generally rely on the high degree of abstraction
    provided by the language because they don’t want to know what’s going on behind
    the scenes. They just want a “black box” that produces predictable results. In
    the case of pointers, though, the abstraction may be *too* effective; pointers
    seem intimidating and opaque to many programmers. Well, fear not! Pointers are
    actually easy to deal with.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 指针只是一个变量，其值指向其他对象。像 Pascal 和 C/C++ 这样的高级语言通过抽象层隐藏了指针的简单性。HLL 程序员通常依赖于语言提供的高度抽象，因为他们不想了解幕后发生了什么。他们只需要一个“黑箱”，能够生成可预测的结果。然而，在指针的情况下，这种抽象可能*过于*有效；许多程序员觉得指针既令人畏惧又晦涩难懂。好吧，别怕！指针其实很容易处理。
- en: 'To understand how pointers work, I’ll use the array data type as an example.
    Consider the following array declaration in Pascal:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 为了理解指针是如何工作的，我将使用数组数据类型作为例子。考虑以下 Pascal 中的数组声明：
- en: '[PRE0]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Even if you don’t know Pascal, the concept here is easy to understand. `M` is
    an array of 1,024 integers, indexed from `M[0]` to `M[1023]`. Each array element
    can hold an independent integer value. In other words, this array gives you 1,024
    different integer variables, each of which you access via an array index (the
    variable’s sequential position within the array) rather than by name.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 即使你不知道 Pascal，这里的概念也很容易理解。`M` 是一个包含 1,024 个整数的数组，索引从 `M[0]` 到 `M[1023]`。每个数组元素都可以存储一个独立的整数值。换句话说，这个数组给你提供了
    1,024 个不同的整数变量，你可以通过数组索引（变量在数组中的顺序位置）来访问它们，而不是通过名称。
- en: 'The statement `M[0] := 100;` stores the value `100` into the first element
    of the array `M`. Now consider the following two statements:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 语句 `M[0] := 100;` 将值 `100` 存储到数组 `M` 的第一个元素中。现在考虑以下两个语句：
- en: '[PRE1]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'These two statements do the same thing as `M[0] := 100;`. In fact, you can
    use any integer expression producing a value in the range `0..1023` as an index
    into this array. The following statements still perform the same operation as
    our earlier statements:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个语句的作用与 `M[0] := 100;` 相同。事实上，你可以使用任何产生 `0..1023` 范围内的整数表达式作为该数组的索引。以下语句仍然执行与之前语句相同的操作：
- en: '[PRE2]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'But now look at the following statements:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 但现在看看以下语句：
- en: '[PRE3]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: At first glance, these statements might seem confusing; however, they perform
    the same operation as in the previous examples. The first statement stores `0`
    into array element `M[1]`. The second statement fetches the value of `M[1]`, which
    is `0`, and uses that value to determine where to store the value `100`.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 初看之下，这些语句可能会让人困惑；然而，它们执行的操作与前面的例子相同。第一条语句将 `0` 存储到数组元素 `M[1]` 中。第二条语句取出 `M[1]`
    的值，即 `0`，并利用该值来决定将 `100` 存储到哪里。
- en: If you think this example is reasonable—perhaps bizarre, but usable nonetheless—then
    you’ll have no problems with pointers, because `M[1]` is a pointer! Well, not
    really, but if you were to change `M` to “memory” and treat each element of this
    array as a separate memory location, then it would meet the definition of a pointer—that
    is, a memory variable whose value is the address of some other memory object.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你认为这个例子是合理的——或许有点奇怪，但仍然可用——那么你就不会对指针感到困惑，因为`M[1]`是一个指针！好吧，严格来说不是，但如果你将 `M`
    改为“内存”，并将该数组的每个元素视为单独的内存位置，那么它就符合指针的定义——即，一个内存变量，其值是某个其他内存对象的地址。
- en: '**9.2 Pointer Implementation in High-Level Languages**'
  id: totrans-25
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**9.2 高级语言中的指针实现**'
- en: Although most languages implement pointers using memory addresses, a pointer
    is actually an abstraction of a memory address. Therefore, a language could define
    a pointer using any mechanism that maps the value of the pointer to the address
    of some object in memory. Some implementations of Pascal, for example, use offsets
    from a fixed memory address as pointer values. Some languages (including dynamic
    languages like Lisp) might actually implement pointers by using *double indirection*;
    that is, the pointer object contains the address of some memory variable whose
    value is the address of the object to access. This approach may seem somewhat
    convoluted, but it offers certain advantages in a complex memory management system,
    making it easier and more efficient to reuse blocks of memory. However, for simplicity’s
    sake we’ll assume that, as defined earlier, a pointer is a variable whose value
    is the address of some other object in memory. This is a safe assumption for many
    of the high-performance HLLs you’re likely to encounter, such as C, C++, and Delphi.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管大多数语言使用内存地址实现指针，但指针实际上是内存地址的抽象。因此，一种语言可以通过任何机制来定义指针，这种机制将指针的值映射到内存中某个对象的地址。例如，一些
    Pascal 的实现使用相对于固定内存地址的偏移量作为指针值。一些语言（包括像 Lisp 这样的动态语言）可能实际上使用*双级间接寻址*来实现指针；也就是说，指针对象包含某个内存变量的地址，而该内存变量的值是要访问对象的地址。这种方法看起来有点复杂，但它在复杂的内存管理系统中提供了某些优势，使得重用内存块变得更容易和高效。然而，为了简化起见，我们假设，如前所定义，指针是一个其值为内存中某个对象地址的变量。这对于许多你可能遇到的高性能高级语言（如
    C、C++ 和 Delphi）来说是一个安全的假设。
- en: 'You can indirectly access an object using a pointer with two 80x86 machine
    instructions, as follows:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过两条 80x86 机器指令间接访问对象，具体如下：
- en: '[PRE4]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Now consider the double-indirect pointer implementation described earlier.
    Access to data via double indirection is less efficient than the straight pointer
    implementation because it takes an extra machine instruction to fetch the data
    from memory. This isn’t obvious even in an HLL like C/C++ or Pascal, where using
    double indirection is explicit:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 现在考虑前面描述的双级间接指针实现。通过双级间接访问数据比直接指针实现效率低，因为它需要额外的一条机器指令来从内存中取出数据。这在像 C/C++ 或 Pascal
    这样的高级语言中并不明显，在这些语言中使用双级间接是显式的：
- en: '[PRE5]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'This is syntactically similar to single indirection. In assembly language,
    however, you’ll see the extra work involved:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 这在语法上类似于单级间接寻址。然而，在汇编语言中，你将看到额外的工作：
- en: '[PRE6]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Contrast this with the two earlier assembly instructions to access an object
    using single indirection. Because double indirection requires 50 percent more
    code (and twice as many slow memory accesses) than single indirection, you can
    see why many languages implement pointers using single indirection. To verify
    this, consider the machine code produced by a couple of different compilers when
    processing the following C code:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 与之前的两条汇编指令使用单级间接寻址访问对象相比，双级间接寻址需要比单级间接多 50% 的代码（并且需要两倍的内存访问速度），你可以理解为什么许多语言采用单级间接来实现指针。为了验证这一点，考虑以下
    C 代码在不同编译器下生成的机器代码：
- en: '[PRE7]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Here’s the GCC output for the PowerPC processor:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是 PowerPC 处理器的 GCC 输出：
- en: '[PRE8]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'As you can see in this PowerPC example, fetching the value using double indirection
    takes one more instruction than it does using single indirection. Of course, the
    total number of instructions is rather large here, so this extra instruction doesn’t
    contribute as much to the execution time as it does on the 80x86 where fewer instructions
    are involved. Consider the following GCC code output for the 32-bit 80x86:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 如你在这个 PowerPC 示例中看到的，使用双重间接寻址获取值比使用单重间接寻址多一条指令。当然，这里的总指令数相当大，因此这条额外的指令对执行时间的影响没有
    80x86 中那么大，因为 80x86 中涉及的指令较少。考虑以下为 32 位 80x86 生成的 GCC 代码输出：
- en: '[PRE9]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: As we saw with the PowerPC code, double indirection requires extra machine instructions,
    so programs using double indirection will be larger and slower.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在 PowerPC 代码中看到的，双重间接寻址需要额外的机器指令，因此使用双重间接寻址的程序将变得更大且更慢。
- en: Notice that the PowerPC instruction sequences are twice as long as the 80x86
    instruction sequences.^([2](footnotes.xhtml#ch9fn2)) One positive way of viewing
    this is that double indirection has less of an impact on the execution time of
    the PowerPC code than it does on the 80x86 code. That is, the extra instruction
    represents only 13 percent of the total in the PowerPC code, versus 25 percent
    of the total in the 80x86 code.^([3](footnotes.xhtml#ch9fn3)) This brief example
    should demonstrate that execution time and code space are not processor independent.
    Bad coding practices (such as using double indirection when it’s not required)
    can have more impact on some processors than others.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，PowerPC 指令序列的长度是 80x86 指令序列的两倍。^([2](footnotes.xhtml#ch9fn2)) 一种积极的看法是，双重间接寻址对
    PowerPC 代码的执行时间的影响比对 80x86 代码的影响小。也就是说，额外的指令在 PowerPC 代码中只占总指令的 13%，而在 80x86 代码中则占总指令的
    25%。^([3](footnotes.xhtml#ch9fn3)) 这个简短的例子应该能表明，执行时间和代码空间不是处理器独立的。糟糕的编码实践（例如在不需要时使用双重间接寻址）可能对某些处理器的影响更大。
- en: '**9.3 Pointers and Dynamic Memory Allocation**'
  id: totrans-41
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**9.3 指针和动态内存分配**'
- en: Pointers typically reference anonymous variables that you allocate on the heap
    using memory allocation/deallocation functions like `malloc()`/`free()`, `new()`/`dispose()`,
    and `new()`/`delete()` (`std::make_unique` in C++17). Objects that you allocate
    on the heap are known as *anonymous variables* because you refer to them by their
    address rather than by name. While the pointer variable may have a name, that
    name applies to the pointer’s data (an address), not the object referenced by
    this address.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 指针通常引用匿名变量，这些匿名变量是通过堆上的内存分配/释放函数（如 `malloc()`/`free()`、`new()`/`dispose()`、以及
    `new()`/`delete()`（C++17中的 `std::make_unique`））进行分配的。你在堆上分配的对象被称为*匿名变量*，因为你通过它们的地址而不是名称来引用它们。虽然指针变量可能有一个名称，但该名称适用于指针的数据（一个地址），而不是该地址所引用的对象。
- en: '**NOTE**'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*The heap, as [Chapter 7](ch07.xhtml#ch07) explained, is a region in memory
    reserved for dynamic storage allocation.*'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: '*正如[第 7 章](ch07.xhtml#ch07)所解释的，堆是内存中为动态存储分配保留的区域。*'
- en: Dynamic languages handle memory allocation and deallocation operations in a
    transparent, automatic fashion. The application simply uses the dynamic data and
    leaves it up to the runtime system to allocate memory as needed and reuse storage
    for a different purpose when it is no longer needed. Without the need to explicitly
    allocate and deallocate memory for pointer variables, applications written in
    dynamic languages (such as AWK or Perl) are usually much easier to program and
    often contain far fewer errors. But this comes at the cost of efficiency, as they
    often run much slower than programs written in other languages. Conversely, traditional
    languages (such as C/C++) that require programmers to explicitly manage memory
    often produce more efficient applications, although the memory management code
    is prone to a higher percentage of defects due to its additional complexity.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 动态语言以透明、自动的方式处理内存分配和释放操作。应用程序仅使用动态数据，并将内存分配的任务交给运行时系统，根据需要分配内存，并在内存不再需要时将存储空间重新用于其他目的。由于无需显式地为指针变量分配和释放内存，用动态语言（如
    AWK 或 Perl）编写的应用程序通常更容易编写，而且往往包含更少的错误。但这也带来了效率上的代价，因为它们通常比用其他语言编写的程序运行得要慢。相反，传统语言（如
    C/C++）要求程序员显式地管理内存，通常能够生成更高效的应用程序，尽管由于内存管理代码的额外复杂性，它更容易出现缺陷。
- en: '**9.4 Pointer Operations and Pointer Arithmetic**'
  id: totrans-46
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**9.4 指针操作和指针算术**'
- en: Most HLLs that provide a pointer data type let you assign addresses to pointer
    variables, compare pointer values for equality or inequality, and indirectly reference
    an object via a pointer. Some languages also allow additional operations, as you’ll
    see in this section.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数提供指针数据类型的高级语言（HLL）允许你将地址分配给指针变量，比较指针值的相等性或不等性，并通过指针间接引用对象。一些语言还允许进行其他操作，正如你在本节中将看到的那样。
- en: 'Many programming languages enable you to do limited arithmetic with pointers.
    At the very least, these languages allow you to add an integer constant to, or
    subtract one from, a pointer. To understand the purpose of these two arithmetic
    operations, recall the syntax of the `malloc()` function in the C standard library:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 许多编程语言允许你对指针进行有限的算术操作。至少，这些语言允许你向指针添加一个整数常量，或从指针中减去一个整数。为了理解这两种算术操作的目的，请回顾一下
    C 标准库中 `malloc()` 函数的语法：
- en: '[PRE10]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'The parameter you pass `malloc()` specifies the number of bytes of storage
    to allocate. A good C programmer generally supplies an expression like `sizeof(int)`
    as this parameter. The `sizeof()` function returns the number of bytes needed
    by its single parameter. Therefore, `sizeof(int)` tells `malloc()` to allocate
    at least enough storage for an `int` variable. Now consider the following call
    to `malloc()`:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 你传递给 `malloc()` 的参数指定了要分配的存储字节数。一个好的 C 程序员通常会提供像 `sizeof(int)` 这样的表达式作为此参数。`sizeof()`
    函数返回其单一参数所需的字节数。因此，`sizeof(int)` 告诉 `malloc()` 至少分配足够存储一个 `int` 变量的空间。现在考虑以下对
    `malloc()` 的调用：
- en: '[PRE11]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: If the size of an integer is 4 bytes, this call to `malloc()` will allocate
    storage for 32 bytes, at consecutive addresses in memory (see [Figure 9-1](ch09.xhtml#ch9fig1)).
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一个整数的大小是 4 字节，那么对 `malloc()` 的调用将分配 32 字节的存储空间，位于内存中的连续地址（参见[图 9-1](ch09.xhtml#ch9fig1)）。
- en: '![Image](../images/09fig01.jpg)'
  id: totrans-53
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/09fig01.jpg)'
- en: '*Figure 9-1: Memory allocation via malloc(sizeof(int) * 8 )*'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 9-1：通过 malloc(sizeof(int) * 8) 分配内存*'
- en: The pointer that `malloc()` returns contains the address of the first integer
    in this set, so the C program can directly access only the very first of these
    eight integers. To access the individual addresses of the other seven integers,
    you need to add an integer offset to that *base* address. On machines that support
    byte-addressable memory (such as the 80x86), the address of each successive integer
    in memory is the address of the previous integer plus the integer size. For example,
    if a call to the C standard library `malloc()` routine returns the memory address
    `$0300_1000`, then the eight integers that `malloc()` allocates will reside at
    the memory addresses shown in [Table 9-1](ch09.xhtml#ch9tab1).
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: '`malloc()` 返回的指针包含此集合中第一个整数的地址，因此 C 程序只能直接访问这八个整数中的第一个。要访问其他七个整数的单独地址，你需要在该
    *基准* 地址上加上一个整数偏移量。在支持字节可寻址内存的机器（如 80x86）上，内存中每个连续整数的地址是前一个整数地址加上整数大小。例如，如果对 C
    标准库中的 `malloc()` 函数的调用返回内存地址 `$0300_1000`，那么 `malloc()` 分配的八个整数将位于[表 9-1](ch09.xhtml#ch9tab1)中显示的内存地址。'
- en: '**Table 9-1:** Integer Addresses Allocated for Base Address `$0300_1000`'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: '**表 9-1：为基地址 `$0300_1000` 分配的整数地址**'
- en: '| **Integer** | **Memory address** |'
  id: totrans-57
  prefs: []
  type: TYPE_TB
  zh: '| **整数** | **内存地址** |'
- en: '| First | `$0300_1000..$0300_1003` |'
  id: totrans-58
  prefs: []
  type: TYPE_TB
  zh: '| 第一 | `$0300_1000..$0300_1003` |'
- en: '| Second | `$0300_1004..$0300..1007` |'
  id: totrans-59
  prefs: []
  type: TYPE_TB
  zh: '| 第二 | `$0300_1004..$0300..1007` |'
- en: '| Third | `$0300_1008..$0300_100b` |'
  id: totrans-60
  prefs: []
  type: TYPE_TB
  zh: '| 第三 | `$0300_1008..$0300_100b` |'
- en: '| Fourth | `$0300_100c..$0300_100f` |'
  id: totrans-61
  prefs: []
  type: TYPE_TB
  zh: '| 第四 | `$0300_100c..$0300_100f` |'
- en: '| Fifth | `$0300_1010..$0300_1013` |'
  id: totrans-62
  prefs: []
  type: TYPE_TB
  zh: '| 第五 | `$0300_1010..$0300_1013` |'
- en: '| Sixth | `$0300_1014..$0300..1017` |'
  id: totrans-63
  prefs: []
  type: TYPE_TB
  zh: '| 第六 | `$0300_1014..$0300..1017` |'
- en: '| Seventh | `$0300_1018..$0300_101b` |'
  id: totrans-64
  prefs: []
  type: TYPE_TB
  zh: '| 第七 | `$0300_1018..$0300_101b` |'
- en: '| Eighth | `$0300_101c..$0300_101f` |'
  id: totrans-65
  prefs: []
  type: TYPE_TB
  zh: '| 第八 | `$0300_101c..$0300_101f` |'
- en: '**9.4.1 Adding an Integer to a Pointer**'
  id: totrans-66
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**9.4.1 将整数添加到指针**'
- en: 'Because the eight integers in the previous section are exactly 4 bytes apart,
    you add 4 to the address of the first integer to obtain the address of the second
    integer. Likewise, the address of the third integer is the address of the second
    integer plus 4 bytes, and so on. In assembly language, you could access these
    eight integers using code like the following:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 由于前一部分中的八个整数相隔恰好 4 字节，你可以通过将 4 加到第一个整数的地址来获得第二个整数的地址。同样，第三个整数的地址是第二个整数的地址加上
    4 字节，依此类推。在汇编语言中，你可以使用如下代码访问这八个整数：
- en: '[PRE12]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Notice the use of the 80x86 indexed addressing mode to access the eight integers
    that `malloc()` allocates. The EAX register maintains the base (first) address
    of the eight integers that this code allocates, and the constant in the addressing
    mode of the `mov()` instruction indicates the offset of the specific integer from
    this base address.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意使用 80x86 索引寻址模式来访问 `malloc()` 分配的八个整数。EAX 寄存器保持了这段代码分配的八个整数的基地址（第一个地址），而
    `mov()` 指令的寻址模式中的常数表示相对于这个基地址的特定整数的偏移量。
- en: 'Most CPUs use byte addresses for memory objects. Therefore, when a program
    allocates multiple copies of some *n*-byte object in memory, the objects won’t
    begin at consecutive memory addresses; instead, they’ll appear in memory at addresses
    that are *n* bytes apart. Some machines, however, don’t allow a program to access
    memory at any arbitrary address; they require it to access data on address boundaries
    that are a multiple of a word, a double word, or even a quad word. Any attempt
    to access memory on some other boundary will raise an exception and potentially
    halt the application. If an HLL supports pointer arithmetic, it must take this
    fact into consideration and provide a generic pointer arithmetic scheme that’s
    portable across different CPU architectures. The most common solution that HLLs
    use when adding an integer offset to a pointer is to multiply that offset by the
    size of the object that the pointer references. That is, if you have a pointer
    `p` to a 16-byte object in memory, then `p + 1` points 16 bytes beyond where `p`
    points. Likewise, `p + 2` points 32 bytes beyond the address contained in `p`.
    As long as the size of the data object is a multiple of the required alignment
    size (which the compiler can enforce by adding padding bytes, if necessary), this
    scheme avoids problems on architectures that require aligned data access. Consider,
    for example, the following C/C++ code:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数 CPU 使用字节地址来表示内存对象。因此，当一个程序在内存中分配多个 *n* 字节对象时，这些对象不会从连续的内存地址开始；相反，它们会出现在相隔
    *n* 字节的内存地址上。然而，某些机器不允许程序访问任意地址的内存；它们要求程序只能在对齐边界上访问数据，这些边界是字、双字甚至四字的倍数。任何试图在其他边界访问内存的行为都将引发异常，可能会终止应用程序。如果高级语言（HLL）支持指针运算，它必须考虑到这一点，并提供一个跨不同
    CPU 架构可移植的通用指针运算方案。当 HLL 在指针上加上一个整数偏移时，最常见的解决方案是将该偏移量乘以指针所引用对象的大小。也就是说，如果你有一个指向内存中
    16 字节对象的指针 `p`，那么 `p + 1` 指向比 `p` 指向的位置多 16 字节。同样，`p + 2` 指向比 `p` 指向的地址多 32 字节。只要数据对象的大小是所需对齐大小的倍数（编译器可以通过添加填充字节来强制执行，如果需要），这个方案就能避免在需要对齐数据访问的架构上出现问题。举个例子，考虑以下
    C/C++ 代码：
- en: '[PRE13]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: This example demonstrates how C/C++ uses pointer arithmetic to specify an integer-sized
    offset from the base pointer address.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子演示了 C/C++ 如何使用指针运算来指定相对于基指针地址的整数大小偏移。
- en: It’s important to note that the addition operator only makes sense between a
    pointer and an integer value. For example, in C/C++ you can indirectly access
    objects in memory using an expression like `*(p + i)` (where `p` is a pointer
    to an object and `i` is an integer value). It doesn’t make sense to add two pointers
    together. Similarly, it isn’t logical to add other data types with a pointer—for
    example, adding a floating-point value to a pointer. (What does it mean to reference
    the data at some base address plus 1.5612?) Operations on pointers involving strings,
    characters, and other data types don’t make much sense, either. Integers (signed
    and unsigned) are the only reasonable values to add to a pointer.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 需要注意的是，加法运算符只在指针和整数值之间才有意义。例如，在 C/C++ 中，你可以使用像 `*(p + i)` 这样的表达式间接访问内存中的对象（其中
    `p` 是指向某个对象的指针，`i` 是整数值）。将两个指针相加是没有意义的。同样，将其他数据类型与指针相加也是不合理的——例如，将一个浮动点值加到指针上。（参考某个基地址加上
    1.5612 是什么意思呢？）涉及字符串、字符和其他数据类型的指针运算也没有多大意义。整数（有符号和无符号）是唯一合理的可以加到指针上的值。
- en: On the other hand, not only can you add an integer to a pointer, but you can
    also add a pointer to an integer and the result is still a pointer (both `p +
    i` and `i + p` are legal). This is because addition is *commutative*—the order
    of the operands does not affect the result.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，你不仅可以将整数加到指针上，还可以将指针加到整数上，结果仍然是一个指针（`p + i` 和 `i + p` 都是合法的）。这是因为加法是 *可交换的*——操作数的顺序不会影响结果。
- en: '**9.4.2 Subtracting an Integer from a Pointer**'
  id: totrans-75
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**9.4.2 从指针中减去一个整数**'
- en: Subtracting an integer from a pointer references a memory location immediately
    before the base address held in the pointer. However, subtraction is not commutative,
    and subtracting a pointer from an integer is not a legal operation (`p - i` is
    legal, but `i - p` is not).
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 从指针中减去一个整数会引用紧接在指针所指向的基地址之前的内存位置。然而，减法不是交换律的，且将指针从整数中减去并不是一个合法操作（`p - i` 是合法的，但
    `i - p` 不是）。
- en: 'In C/C++, `*(p - i)` accesses the `i`th object immediately before the object
    at which `p` points. In 80x86 assembly language, as in assembly on many processors,
    you can also specify a negative constant offset when using an indexed addressing
    mode. For example:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 在 C/C++ 中，`*(p - i)` 访问的是紧接在 `p` 所指向的对象之前的第 `i` 个对象。在 80x86 汇编语言中，和许多处理器上的汇编语言一样，你还可以在使用索引寻址模式时指定一个负常量偏移量。例如：
- en: '[PRE14]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Keep in mind, 80x86 assembly language uses byte offsets, not object offsets
    (as C/C++ does). Therefore, this statement loads into EAX the double word in memory
    immediately preceding the memory address in EBX.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，80x86 汇编语言使用的是字节偏移量，而不是对象偏移量（如同 C/C++ 中使用的那样）。因此，这条语句将内存中紧接着 EBX 所指向的内存地址前面的双字加载到
    EAX 中。
- en: '**9.4.3 Subtracting a Pointer from a Pointer**'
  id: totrans-80
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**9.4.3 从指针中减去另一个指针**'
- en: 'In contrast to addition, it makes sense to subtract the value of one pointer
    variable from another. Consider the following C/C++ code, which proceeds through
    a string of characters looking for the first `e` character that follows the first
    `a` that it finds (you could use the result of such a calculation, for example,
    to extract a substring):'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 与加法不同，减去一个指针变量的值是有意义的。考虑以下 C/C++ 代码，它通过一个字符字符串查找紧随第一个 `a` 字符之后的第一个 `e` 字符（例如，你可以使用这种计算的结果来提取子字符串）：
- en: '[PRE15]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Subtracting one pointer from the other produces the number of data objects that
    exist between them (in this case, `ePtr` and `aPtr` point at characters, so this
    subtraction produces the number of characters, or bytes if 1-byte characters,
    between the two pointers).
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 将一个指针从另一个指针中减去，得到的是它们之间存在的数据对象的数量（在本例中，`ePtr` 和 `aPtr` 指向的是字符，因此这次减法得到的是两个指针之间的字符数，或者如果是
    1 字节字符的话，则是字节数）。
- en: The subtraction of two pointer values makes sense only if they both reference
    the same data structure (for example, an array, string, or record) in memory.
    Although assembly language will allow you to subtract two pointers that point
    at completely different objects in memory, their difference will probably have
    very little meaning.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 只有当两个指针都引用内存中相同的数据结构（例如数组、字符串或记录）时，指针值的减法才是有意义的。虽然汇编语言允许你减去指向内存中完全不同对象的两个指针，但它们的差值可能几乎没有什么意义。
- en: For pointer subtraction in C/C++, the base types of the two pointers must be
    identical (that is, the two pointers must contain the address of two objects whose
    types are identical). This restriction exists because pointer subtraction in C/C++
    produces the number of objects, not the number of bytes, between the two pointers.
    Computing the number of objects between a byte in memory and a double word in
    memory wouldn’t make any sense. The result would be neither a byte count nor a
    double-word count.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 在 C/C++ 中进行指针减法时，两个指针的基类型必须相同（即，两个指针必须包含类型相同的两个对象的地址）。这个限制存在的原因是，在 C/C++ 中，指针减法计算的是两个指针之间的对象数量，而不是字节数。计算内存中的字节与双字之间的对象数量是没有意义的。结果既不是字节数也不是双字数。
- en: The subtraction of two pointers can return a negative number if the left pointer
    operand is at a lower memory address than the right pointer operand. Depending
    on your language and its implementation, you might need to take the absolute value
    of the result if you’re interested only in the distance between the two pointers
    and you don’t care which pointer contains the greater address.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 如果左侧指针操作数的内存地址低于右侧指针操作数的内存地址，则两个指针的减法可能返回一个负数。根据你使用的语言及其实现，如果你只关心两个指针之间的距离，而不在乎哪个指针包含较大的地址，可能需要取结果的绝对值。
- en: '**9.4.4 Comparing Pointers**'
  id: totrans-87
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**9.4.4 比较指针**'
- en: 'Comparisons are another set of operations that make sense for pointers. Almost
    every language that supports pointers allows you to compare two pointers to see
    whether or not they are equal. A pointer comparison tells you whether the pointers
    reference the same object in memory. Some languages (such as assembly and C/C++)
    also let you compare two pointers to see if one pointer is less than or greater
    than the other. Like subtracting two pointers, comparing two pointers makes sense
    only if they have the same base type and point into the same data structure. If
    one pointer is less than another, this tells you that the pointer references an
    object within the data structure that appears before the object whose address
    the second pointer contains. The converse is true for the greater-than comparison.
    This short example in C demonstrates pointer comparison:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 比较是另一类对指针有意义的操作。几乎所有支持指针的语言都允许你比较两个指针，以查看它们是否相等。指针比较告诉你这些指针是否引用了内存中的同一对象。一些语言（如汇编和
    C/C++）还允许你比较两个指针，查看一个指针是否小于或大于另一个指针。像减去两个指针一样，比较两个指针只有在它们具有相同的基类型并指向相同的数据结构时才有意义。如果一个指针小于另一个指针，这意味着该指针引用的数据结构中的某个对象出现在第二个指针包含的对象之前。大于比较的反之亦然。以下是一个
    C 语言示例，演示了指针比较：
- en: '[PRE16]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'At the (x86-64) machine language level, addresses are simply 64-bit quantities,
    so the machine code can compare these pointers as though they’re 64-bit integer
    values. Here’s the x86-64 assembly code that Visual C++ emits for this example:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 在 (x86-64) 机器语言层面，地址仅仅是 64 位的量，因此机器代码可以将这些指针当作 64 位整数值进行比较。以下是 Visual C++ 为此示例生成的
    x86-64 汇编代码：
- en: '[PRE17]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Other than the trickery behind computing `true` (`1`) or `false` (`0`) after
    comparing the two addresses, this code is a very straightforward compilation to
    machine code.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 除了比较两个地址后计算 `true`（`1`）或 `false`（`0`）的技巧之外，这段代码是一个非常直接的机器代码编译。
- en: '**9.4.5 Using Logical AND/OR Operations with Pointers**'
  id: totrans-93
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**9.4.5 使用逻辑与/或操作与指针**'
- en: 'On byte-addressable machines, it makes sense to logically AND an address with
    a bit string value, because masking off the low-order (LO) bits in an address
    is an easy way to align it on a boundary that is a power of 2\. For example, if
    the 32-bit 80x86 EBX register contains an arbitrary address, the following assembly
    language statement rounds the pointer in EBX down to an address that is a multiple
    of 4 bytes:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 在字节可寻址的机器上，使用与（AND）操作符对地址与位串值进行逻辑与运算是有意义的，因为掩码低位（LO）位是将地址对齐到 2 的幂次方边界的一种简单方法。例如，如果
    32 位的 80x86 EBX 寄存器包含一个任意地址，以下汇编语言语句将指针 EBX 向下舍入到一个 4 字节对齐的地址：
- en: '[PRE18]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'This operation is very useful when you want to ensure that memory is accessed
    on a nice memory boundary. For example, suppose you have a memory allocation function
    that can return a pointer to a block of memory that begins at an arbitrary byte
    boundary. To ensure that the data structure the pointer points to begins on a
    double word (`dword`) boundary, you can use assembly code like the following:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 这种操作在确保内存以良好的内存边界进行访问时非常有用。例如，假设你有一个内存分配函数，它返回一个指向在任意字节边界开始的内存块的指针。为了确保指针所指向的数据结构从双字（`dword`）边界开始，你可以使用类似下面的汇编代码：
- en: '[PRE19]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: This code allocates an extra 3 bytes when calling `malloc()` so that it can
    add 0, 1, 2, or 3 to the address that `malloc()` returns in order to align the
    object on a `dword` address. On return from `malloc()`, the code adds 3 to the
    address and, if it wasn’t already a multiple of 4, the address will cross the
    next `dword` boundary. Using the AND instruction reduces the address back to the
    previous `dword` boundary (either the next `dword` boundary, or the original address
    if it was already `dword`-aligned).
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码在调用 `malloc()` 时额外分配了 3 个字节，以便它可以将 0、1、2 或 3 加到 `malloc()` 返回的地址上，从而将对象对齐到一个
    `dword` 地址上。从 `malloc()` 返回时，代码将地址加 3，如果它本来不是 4 的倍数，那么地址将跨越到下一个 `dword` 边界。使用
    AND 指令可以将地址还原到之前的 `dword` 边界（无论是下一个 `dword` 边界，还是如果它已经是 `dword` 对齐的原始地址）。
- en: '**9.4.6 Using Other Operations with Pointers**'
  id: totrans-99
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**9.4.6 使用其他操作与指针**'
- en: Beyond addition, subtraction, comparison, and possibly AND or OR operations,
    very few arithmetic operations make sense with pointer operands. What does it
    mean to multiply a pointer by some integer value (or another pointer)? What does
    division of pointers mean? What do you get when you shift a pointer to the left
    by one bit position? You could make up some sort of definition for these operations,
    but considering the original arithmetic definitions, these operations just aren’t
    reasonable for pointers.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 除了加法、减法、比较操作，以及可能的与操作（AND）或或操作（OR）外，极少有算术操作对于指针操作数是有意义的。将指针乘以某个整数值（或另一个指针）是什么意思？指针的除法是什么意思？将指针左移一位是什么意思？你可以为这些操作编造一些定义，但考虑到原始的算术定义，这些操作对于指针来说根本不合理。
- en: 'Several languages (including C/C++ and Pascal) restrict other pointer operations.
    There are several good reasons for limiting what a programmer can do with a pointer,
    such as:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 一些语言（包括 C/C++ 和 Pascal）限制了其他指针操作。有几个好的理由限制程序员对指针的操作，例如：
- en: Code involving pointers is notoriously difficult to optimize. By limiting the
    number of pointer operations, the compiler can make assumptions about the code
    that it could not otherwise. This allows the compiler (in theory) to produce better
    machine code.
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 涉及指针的代码通常很难优化。通过限制指针操作的数量，编译器可以对代码做出一些假设，这是在没有限制的情况下无法做到的。这使得编译器（理论上）能够生成更好的机器代码。
- en: Code containing pointer manipulations is more likely to be defective. Limiting
    programmers’ options in this area helps prevent pointer abuse, and leads to more
    robust code.
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 包含指针操作的代码更容易出现缺陷。限制程序员在这一领域的选择有助于防止指针滥用，从而导致更健壮的代码。
- en: '**NOTE**'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*The section “Common Pointer Problems” on [page 286](ch09.xhtml#page_286) describes
    the most serious of these errors and ways to avoid them in your code.*'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: '*“常见指针问题”一节在[第286页](ch09.xhtml#page_286)中描述了这些错误中最严重的，并提供了避免它们的方法。*'
- en: Some pointer operations—particularly certain arithmetic operations—are not portable
    across CPU architectures. For example, on some segmented architectures (such as
    the original 16-bit 80x86), subtracting the values of two pointers may not produce
    an expected result.
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一些指针操作——尤其是某些算术操作——在不同的 CPU 架构之间并不具有可移植性。例如，在一些分段架构（如原始的 16 位 80x86 架构）上，减去两个指针的值可能无法产生预期的结果。
- en: 'The proper use of pointers can help create efficient programs, but the converse
    is also true: the improper use of pointers can destroy program efficiency. By
    limiting the number of pointer operations it supports, a language can prevent
    the kinds of code inefficiencies that often result from the gratuitous use of
    pointers.'
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 正确使用指针有助于创建高效的程序，但反过来也成立：不当使用指针会破坏程序的效率。通过限制语言支持的指针操作数量，可以防止由于过度使用指针而导致的代码低效。
- en: The major problem with these justifications for limiting pointer operations
    is that most exist to protect programmers from themselves, and indeed, many programmers
    (especially beginners) benefit from the discipline these restrictions enforce.
    However, for careful programmers who do not abuse pointers, these restrictions
    may eliminate some opportunities for writing great code. Therefore, languages
    that provide a rich set of pointer operations, like C/C++ and assembly, are popular
    with advanced programmers who prefer absolute control over the use of pointers
    in their programs.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 限制指针操作的这些理由的主要问题在于，大多数理由是为了保护程序员不犯错误，事实上，许多程序员（尤其是初学者）从这些限制所强制执行的纪律中受益。然而，对于那些谨慎使用指针、不滥用指针的程序员来说，这些限制可能会消除一些编写优秀代码的机会。因此，像
    C/C++ 和汇编语言这样提供丰富指针操作集的语言，深受那些更喜欢对指针使用拥有完全控制的高级程序员欢迎。
- en: '**9.5 A Simple Memory Allocator Example**'
  id: totrans-109
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**9.5 一个简单的内存分配器示例**'
- en: To demonstrate the performance and memory costs of using dynamically allocated
    memory and pointers to it, this section presents a simple memory allocation/deallocation
    system. By considering the operations associated with memory allocation and deallocation,
    you’ll be more aware of their costs and better equipped to use them in an appropriate
    way.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 为了演示使用动态分配的内存和指向它的指针的性能和内存成本，本节展示了一个简单的内存分配/释放系统。通过考虑与内存分配和释放相关的操作，你将更加意识到它们的成本，并更好地了解如何以合适的方式使用它们。
- en: An extremely simple (and fast) memory allocation scheme would maintain a single
    variable that forms a pointer into the heap region of memory. Whenever a memory
    allocation request comes along, the system makes a copy of this heap pointer to
    return to the application. The heap management routines add the size of the memory
    request to the address held in the pointer variable and verify that the memory
    request won’t try to use more memory than is available in the heap. (Some memory
    managers return an error indication, like a `NULL` pointer, when the memory request
    is too great; others raise an exception.) The problem with this simple memory
    management scheme is that it wastes memory because there’s no *garbage collection*
    mechanism for the application to free the memory so it can be reused later. Garbage
    collection is one of the main purposes of a heap management system.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 一个极其简单（且快速）的内存分配方案是维护一个指向堆内存区域的单一变量。每当有内存分配请求时，系统就会复制这个堆指针并返回给应用程序。堆管理例程会将内存请求的大小加到指针变量中的地址上，并验证内存请求是否会尝试使用超过堆可用内存的空间。（一些内存管理器在内存请求过大时会返回一个错误指示，如`NULL`指针；其他则会抛出异常。）这个简单的内存管理方案的问题在于它浪费内存，因为没有*垃圾回收*机制让应用程序能够释放内存以便后续重用。垃圾回收是堆管理系统的一个主要目的。
- en: 'The only catch is that supporting garbage collection requires some overhead.
    The memory management code will need to be more sophisticated, will take longer
    to execute, and will require some additional memory to maintain the internal data
    structures the heap management system uses. Consider an easy implementation of
    a heap manager that supports garbage collection on a 32-bit system. This simple
    system maintains a (linked) list of free memory blocks. Each free memory block
    in the list requires two `dword` values: one specifying the size of the free block,
    and the other containing the address of the next free block in the list (that
    is, the link); see [Figure 9-2](ch09.xhtml#ch9fig2).'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 唯一的问题是，支持垃圾回收需要一些额外开销。内存管理代码将需要更复杂，执行时间更长，并且需要一些额外的内存来维护堆管理系统使用的内部数据结构。考虑一个支持垃圾回收的堆管理器的简单实现，该实现适用于32位系统。这个简单的系统维护一个（链式）空闲内存块的列表。列表中的每个空闲内存块需要两个`dword`值：一个指定空闲块的大小，另一个包含下一个空闲块的地址（即链接）；参见[图9-2](ch09.xhtml#ch9fig2)。
- en: '![Image](../images/09fig02.jpg)'
  id: totrans-113
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/09fig02.jpg)'
- en: '*Figure 9-2: Heap management using a list of free memory blocks*'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: '*图9-2：使用空闲内存块列表的堆管理*'
- en: The system initializes the heap with a `NULL` link pointer, and the size field
    contains the size of the heap’s entire free space. When a memory allocation request
    comes along, the heap manager searches through the list to find a free block with
    enough memory to satisfy the request. This search process is one of the defining
    characteristics of a heap manager. Some common search algorithms are first-fit
    search and best-fit search. A *first-fit search*, as its name suggests, scans
    the list of blocks until it finds the *first* block of memory large enough to
    satisfy the allocation request. A *best-fit search* scans the entire list and
    finds the *smallest* block large enough to satisfy the request. The advantage
    of the best-fit algorithm is that it tends to preserve larger blocks better than
    the first-fit algorithm, so the system is still able to satisfy larger subsequent
    allocation requests when they arrive. The first-fit algorithm, on the other hand,
    just grabs the first suitably large block it finds, even if there’s a smaller
    block that would suffice, which may limit the system’s ability to handle future
    large memory requests.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 系统用一个`NULL`链接指针初始化堆，并且大小字段包含堆中所有空闲空间的大小。当有内存分配请求时，堆管理器会在列表中搜索，找到一个足够大的空闲块来满足请求。这个搜索过程是堆管理器的一个特征。一些常见的搜索算法包括首次适应搜索和最佳适应搜索。*首次适应搜索*顾名思义，会扫描块列表，直到找到第一个足够大的内存块来满足分配请求。*最佳适应搜索*则扫描整个列表，找到一个最小的足够大的块来满足请求。最佳适应算法的优点是，它比首次适应算法更能有效保存较大的块，因此在后续有更大的分配请求时，系统仍然能够满足这些请求。而首次适应算法则是抓住第一个合适大小的块，哪怕有一个较小的块也能满足需求，这可能会限制系统处理未来大内存请求的能力。
- en: That said, the first-fit algorithm does have a couple of advantages over the
    best-fit algorithm. The most obvious is that it is usually faster. The best-fit
    algorithm has to scan through every block in the free block list in order to find
    the smallest one large enough to satisfy the allocation request (unless, of course,
    it finds a perfectly sized block along the way). The first-fit algorithm, on the
    other hand, can stop once it finds a block large enough to satisfy the request.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 话虽如此，首次适配算法确实比最佳适配算法有一些优势。最明显的一点是，它通常更快。最佳适配算法必须扫描空闲块列表中的每个块，以找到一个足够大的最小块来满足分配请求（当然，如果途中找到一个完全合适的块，它就会停止）。而首次适配算法则可以在找到一个足够大的块满足请求后立即停止。
- en: Another advantage to the first-fit algorithm is that it tends to suffer less
    from a degenerate condition known as *external fragmentation*. Fragmentation occurs
    after a long sequence of allocation and deallocation requests.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个首次适配算法的优点是，它往往较少遭受一种叫做*外部碎片*的退化状况。碎片化发生在一系列分配和释放请求之后。
- en: 'Remember, when the heap manager satisfies a memory allocation request, it usually
    creates two blocks of memory: one in-use block for the request, and one free block
    that contains the remaining bytes from the original block (assuming the request
    did not exactly match the block size). After operating for a while, the best-fit
    algorithm may have produced lots of leftover blocks of memory that are too small
    to satisfy an average memory request, making them effectively unusable. As these
    small fragments accumulate throughout the heap, they can end up consuming a fair
    amount of memory. This can lead to a situation where the heap doesn’t have a sufficiently
    large block to satisfy a memory allocation request even though there is enough
    total free memory available (spread throughout the heap). See [Figure 9-3](ch09.xhtml#ch9fig3)
    for an example of this condition.'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，当堆管理器满足内存分配请求时，它通常会创建两个内存块：一个是用于请求的在用块，另一个是包含原始块剩余字节的空闲块（假设请求的大小与块大小不完全匹配）。经过一段时间后，最佳适配算法可能会产生许多剩余的内存块，这些块太小，无法满足一般的内存请求，从而变得实际上不可用。随着这些小碎片在堆中积累，它们可能会消耗相当多的内存。这可能导致即使堆中有足够的空闲内存（分布在堆的各个位置），堆也没有足够大的块来满足内存分配请求。请参见[图
    9-3](ch09.xhtml#ch9fig3)中的示例。
- en: '![Image](../images/09fig03.jpg)'
  id: totrans-119
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/09fig03.jpg)'
- en: '*Figure 9-3: Memory fragmentation*'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 9-3：内存碎片化*'
- en: There are other memory allocation strategies in addition to the first-fit and
    best-fit search algorithms. Some of these execute faster, some have less memory
    overhead, some are easy to understand (and some are very complex), some produce
    less fragmentation, and some can combine and use noncontiguous blocks of free
    memory. Memory/heap management is one of the more heavily studied subjects in
    computer science, and there’s a considerable amount of literature explaining the
    benefits of one scheme over another. For more information on memory allocation
    strategies, check out a good book on OS design.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 除了首次适配（first-fit）和最佳适配（best-fit）搜索算法，还有其他内存分配策略。它们中的一些执行速度更快，一些内存开销更少，一些容易理解（也有一些非常复杂），一些产生更少的碎片，而有些则可以组合并使用不连续的空闲内存块。内存/堆管理是计算机科学中研究较多的课题之一，关于不同方案的优缺点有大量文献解释。如需了解更多内存分配策略的信息，请参考一本关于操作系统设计的好书。
- en: '**9.6 Garbage Collection**'
  id: totrans-122
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**9.6 垃圾回收**'
- en: Memory allocation is only half of the story. As mentioned earlier, the heap
    manager also has to provide a call that allows an application to free memory it
    no longer needs for future reuse—a process known as garbage collection. In C and
    HLA, for example, an application accomplishes this by calling the `free()` function.
    At first blush, `free()` might seem to be a very simple function to write. All
    it has to do is append the previously allocated and now unused block to the end
    of the free list, right? The problem with this trivial implementation of `free()`
    is that it almost guarantees that the heap will become fragmented and unusable
    in very short order. Consider the situation in [Figure 9-4](ch09.xhtml#ch9fig4).
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 内存分配只是故事的一半。如前所述，堆管理器还需要提供一个调用，允许应用程序释放其不再需要的内存，以供将来重用——这一过程称为垃圾回收。例如，在 C 和
    HLA 中，应用程序通过调用`free()`函数来完成这一操作。乍一看，`free()`似乎是一个非常简单的函数。它要做的只是将先前分配的、现在未使用的内存块附加到空闲列表的末尾，对吧？然而，这种简单实现的`free()`存在一个问题，那就是它几乎可以确保堆会在短时间内变得碎片化并不可用。考虑[图
    9-4](ch09.xhtml#ch9fig4)中的情况。
- en: If `free()` simply takes the block to be freed and appends it to the free list,
    the memory organization in [Figure 9-4](ch09.xhtml#ch9fig4) produces three free
    blocks. However, because these three blocks are contiguous, the heap manager should
    really combine them into a single free block, so that it will be able to satisfy
    a larger request. Unfortunately, this operation would require it to scan the free
    block list to determine if there are any free blocks adjacent to the block the
    system is freeing. While you could come up with a data structure that makes it
    easier to combine adjacent free blocks, such schemes generally add 8 or more bytes
    of overhead with each block on the heap. Whether this is a reasonable tradeoff
    depends on the average size of a memory allocation. If the applications that use
    the heap manager tend to allocate small objects, the extra overhead for each memory
    block could wind up consuming a large percentage of the heap space. However, if
    most allocations are large, the few bytes of overhead won’t matter much.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`free()`仅仅将要释放的内存块添加到空闲列表中，则在[图9-4](ch09.xhtml#ch9fig4)所示的内存组织方式下会生成三个空闲块。然而，由于这三个块是连续的，堆管理器实际上应该将它们合并为一个单一的空闲块，以便能够满足更大的请求。不幸的是，这个操作需要扫描空闲块列表，以确定是否有任何空闲块与系统正在释放的块相邻。虽然你可以设计一种数据结构，使得合并相邻空闲块更加容易，但这种方案通常会为堆中的每个块增加8个或更多字节的开销。是否这是一个合理的权衡，取决于内存分配的平均大小。如果使用堆管理器的应用程序倾向于分配小对象，则每个内存块的额外开销可能会占用堆空间的很大一部分。然而，如果大多数分配是大的，少量的开销就不会有什么影响。
- en: '![Image](../images/09fig04.jpg)'
  id: totrans-125
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/09fig04.jpg)'
- en: '*Figure 9-4: Freeing a memory block*'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: '*图9-4：释放内存块*'
- en: '**9.7 The OS and Memory Allocation**'
  id: totrans-127
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**9.7 操作系统与内存分配**'
- en: The performance of the algorithms and data structures used by the heap manager
    is only one piece of the performance puzzle. The heap manager ultimately needs
    to request blocks of memory from the operating system. At one extreme, the OS
    handles all memory allocation requests directly. At the other extreme, the heap
    manager is a runtime library routine that links with your application, first requesting
    large blocks of memory from the OS and then doling out pieces of them as allocation
    requests arrive from the application.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 堆管理器所使用的算法和数据结构的性能只是性能难题的一部分。堆管理器最终需要向操作系统请求内存块。在一种极端情况下，操作系统直接处理所有的内存分配请求。在另一种极端情况下，堆管理器是一个与应用程序链接的运行时库例程，首先向操作系统请求大量的内存块，然后根据应用程序发出的分配请求将其拆分成小块。
- en: The problem with making direct memory allocation requests to the operating system
    is that OS API calls are often very slow. This is because they generally involve
    switching between kernel mode and user mode on the CPU (which is not fast). Therefore,
    a heap manager that the OS implements directly will not perform well if your application
    makes frequent calls to the memory allocation and deallocation routines.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 向操作系统直接请求内存分配的问题在于操作系统的API调用通常非常慢。这是因为它们通常涉及在CPU上切换内核模式和用户模式（这并不快）。因此，如果操作系统直接实现堆管理器，而应用程序频繁调用内存分配和释放例程，堆管理器的性能将不会很好。
- en: Because of the high overhead of an OS call, most languages implement their own
    versions of the `malloc()` and `free()` functions within their runtime library.
    On the very first memory allocation, the `malloc()` routine requests a large block
    of memory from the OS, and the application’s `malloc()` and `free()` routines
    manage this block of memory themselves. If an allocation request comes along that
    the `malloc()` function cannot fulfill in the block it originally created, `malloc()`
    will request another large block (generally much larger than the request) from
    the OS and add that block to the end of its free list. Because the application’s
    `malloc()` and `free()` routines call the OS only occasionally, the application
    doesn’t suffer the performance hit associated with frequent OS calls.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 由于操作系统调用的高开销，大多数语言在它们的运行时库中实现了自己的`malloc()`和`free()`函数版本。在第一次内存分配时，`malloc()`例程向操作系统请求一个大块内存，而应用程序的`malloc()`和`free()`例程自行管理这块内存。如果出现了一个`malloc()`函数无法在它最初创建的内存块中满足的分配请求，`malloc()`将向操作系统请求另一个大块内存（通常比请求的要大得多），并将该块添加到其空闲列表的末尾。因为应用程序的`malloc()`和`free()`例程仅偶尔调用操作系统，所以应用程序不会遭遇频繁操作系统调用带来的性能损失。
- en: However, keep in mind that this procedure is very implementation- and language-specific;
    it’s dangerous to assume that `malloc()` and `free()` are relatively efficient
    when writing software that requires high-performance components. The only portable
    way to ensure a high-performance heap manager is to develop your own application-specific
    set of allocation/deallocation routines. Writing such routines is beyond the scope
    of this book (and most standard heap management functions perform well for a typical
    program), but you should know you have this option.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，请记住，这个过程是非常依赖实现和语言的；在编写需要高性能组件的软件时，假设 `malloc()` 和 `free()` 是相对高效的做法是危险的。确保高性能堆管理器的唯一便携方法是开发自己特定应用程序的分配/释放例程。编写这些例程超出了本书的范围（大多数标准堆管理函数对于典型程序的表现良好），但你应该知道你有这个选择。
- en: '**9.8 Heap Memory Overhead**'
  id: totrans-132
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**9.8 堆内存开销**'
- en: 'A heap manager often exhibits two types of overhead: performance (speed) and
    memory (space). Until now, this discussion has mainly dealt with the performance
    aspects, but now we’ll turn our attention to memory.'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 堆管理器通常会表现出两种类型的开销：性能（速度）和内存（空间）。到目前为止，这个讨论主要处理了性能方面的问题，但现在我们将把注意力转向内存。
- en: Each block the system allocates requires some amount of overhead beyond the
    storage the application requests; at the very least, this overhead is a few bytes
    to keep track of the block’s size. Fancier (higher-performance) schemes may require
    additional bytes, but typically the overhead is between 8 and 64 bytes. The heap
    manager can keep this information in a separate internal table, or it can attach
    the block size and other memory management information directly to the block it
    allocates.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 系统分配的每个块都需要一定的额外开销，这些开销超出了应用程序请求的存储空间；至少，这些开销是一些字节，用于跟踪块的大小。更复杂（高性能）的方案可能需要额外的字节，但通常开销在
    8 到 64 字节之间。堆管理器可以将这些信息保存在一个单独的内部表中，也可以将块的大小和其他内存管理信息直接附加到它分配的块上。
- en: Saving this information in an internal table has a couple of advantages. First,
    it is difficult for the application to accidentally overwrite the information
    stored there; attaching the data to the heap memory blocks themselves doesn’t
    provide as much protection against this possibility. Second, putting memory management
    information in an internal data structure allows the memory manager to easily
    determine if a given pointer is valid (that is, points at some block of memory
    that the heap manager believes it has allocated).
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 将这些信息保存在内部表中有几个优点。首先，应用程序很难意外覆盖存储在其中的信息；将数据附加到堆内存块本身并不能提供足够的保护，防止这种情况发生。其次，将内存管理信息放入内部数据结构中，使得内存管理器可以轻松地确定给定的指针是否有效（也就是说，指向堆管理器认为已分配的某个内存块）。
- en: The advantage of attaching the control information directly to each block that
    the heap manager allocates is that it’s very easy to locate this information,
    whereas storing the information in an internal table might require a search operation.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 将控制信息直接附加到堆管理器分配的每个块的优点在于，定位这些信息非常容易，而将信息存储在内部表中可能需要进行搜索操作。
- en: Another issue that affects the overhead associated with the heap manager is
    the *allocation granularity*—the minimum number of bytes the heap manager supports.
    Although most heap managers allow you to request an allocation as small as 1 byte,
    they may actually allocate some minimum number of bytes greater than 1\. Generally,
    the engineer designing the memory allocation functions chooses a granularity guaranteeing
    that any object allocated on the heap will begin at a reasonably aligned memory
    address for that object. Thus, most heap managers allocate memory blocks on a
    4-, 8-, or 16-byte boundary. For performance reasons, many heap managers begin
    each allocation on a cache line boundary, usually 16, 32, or 64 bytes. Whatever
    the granularity, if the application requests some number of bytes that is less
    than or not a multiple of the heap manager’s granularity, the heap manager will
    allocate extra bytes of storage (see [Figure 9-5](ch09.xhtml#ch9fig5)). This amount
    varies by heap manager (and possibly even by version of a specific heap manager),
    so programmers should never assume that their application has more memory available
    than they request; if they’re tempted to do so, they should request more memory
    upfront.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个影响堆管理器开销的问题是*分配粒度*——即堆管理器支持的最小字节数。尽管大多数堆管理器允许你请求最小为1字节的分配，但实际上它们可能分配大于1字节的最小字节数。通常，设计内存分配函数的工程师会选择一个粒度，确保堆上分配的任何对象都能以该对象合理对齐的内存地址开始。因此，大多数堆管理器会在4字节、8字节或16字节边界上分配内存块。出于性能考虑，许多堆管理器会在缓存行边界上开始每次分配，通常是16、32或64字节。不管粒度是多少，如果应用程序请求的字节数少于堆管理器粒度或不是粒度的倍数，堆管理器就会分配额外的存储字节（参见[图9-5](ch09.xhtml#ch9fig5)）。这个数值因堆管理器而异（甚至可能因特定堆管理器的版本而异），因此程序员不应该假设应用程序有比请求的更多内存可用；如果他们有这种想法，应该提前请求更多的内存。
- en: The extra memory the heap manager allocates results in another form of fragmentation
    called *internal fragmentation* (also shown in [Figure 9-5](ch09.xhtml#ch9fig5)).
    Like external fragmentation, internal fragmentation produces small amounts of
    leftover memory throughout the system that cannot satisfy future allocation requests.
    Assuming random-sized memory allocations, the average amount of internal fragmentation
    that occurs on each allocation is one-half the granularity size. Fortunately,
    the granularity size is quite small for most memory managers (typically 16 bytes
    or less), so after thousands and thousands of memory allocations you’ll lose only
    a couple dozen or so kilobytes to internal fragmentation.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 堆管理器分配的额外内存导致了另一种形式的碎片化，称为*内部碎片化*（在[图9-5](ch09.xhtml#ch9fig5)中也有显示）。与外部碎片化类似，内部碎片化会在系统中产生少量无法满足未来分配请求的剩余内存。假设是随机大小的内存分配，每次分配时发生的平均内部碎片化量是粒度大小的一半。幸运的是，对于大多数内存管理器来说，粒度大小通常非常小（通常为16字节或更少），因此经过成千上万次的内存分配后，你失去的内部碎片也只会是几十个字节。
- en: '![Image](../images/09fig05.jpg)'
  id: totrans-139
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/09fig05.jpg)'
- en: '*Figure 9-5: Allocation granularity and internal fragmentation*'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: '*图9-5：分配粒度和内部碎片化*'
- en: Between the costs associated with allocation granularity and the memory control
    information, a typical memory request may require between 8 and 64 bytes plus
    whatever the application requests. If you’re making large memory allocation requests
    (hundreds or thousands of bytes), the overhead bytes won’t consume a large percentage
    of memory on the heap. However, if you allocate lots of small objects, the memory
    consumed by internal fragmentation and memory control information may represent
    a significant portion of your heap area. For example, consider a simple memory
    manager that always allocates blocks of data on 4-byte boundaries and requires
    a single 4-byte length value that it attaches to each allocation request for memory
    storage. This means that the minimum amount of storage the heap manager requires
    for each allocation is 8 bytes. If you make a series of `malloc()` calls to allocate
    a single byte, the application won’t be able to use almost 88 percent of the memory
    it allocates. Even if you allocate 4-byte values on each allocation request, the
    heap manager consumes two-thirds of the memory for overhead purposes. However,
    if your average allocation is a block of 256 bytes, the overhead requires only
    about 2 percent of the total memory allocation. In short, the larger your allocation
    request, the less impact the control information and internal fragmentation will
    have on your heap.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 在分配粒度的成本和内存控制信息之间，典型的内存请求可能需要 8 到 64 字节，再加上应用程序请求的内存。如果你进行大规模内存分配（几百或几千字节），则开销字节不会占用堆内存的大部分比例。然而，如果你分配许多小对象，内部碎片和内存控制信息所消耗的内存可能占用堆区域的相当大一部分。例如，考虑一个简单的内存管理器，它总是在
    4 字节对齐的边界上分配数据块，并且为每个内存存储分配请求附加一个 4 字节的长度值。这意味着堆管理器为每次分配所需的最小存储量是 8 字节。如果你进行一系列
    `malloc()` 调用来分配一个字节，应用程序几乎无法使用它分配的 88% 内存。即使你在每次分配请求时分配 4 字节的值，堆管理器也会消耗三分之二的内存作为开销。然而，如果你的平均分配是
    256 字节的块，开销仅占总内存分配的约 2%。简而言之，你的分配请求越大，控制信息和内部碎片对堆的影响就越小。
- en: Many software engineering studies in computer science journals have found that
    memory allocation/deallocation requests cause a significant loss of performance.
    In such studies, the authors often obtained performance improvements of 100 percent
    or better by simply implementing their own simplified, application-specific, memory
    management algorithms rather than calling the standard runtime library or OS kernel
    memory allocation code. Hopefully, this section has made you aware of this potential
    problem in your own code.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 许多计算机科学期刊中的软件工程研究发现，内存分配/释放请求会导致性能的显著损失。在这些研究中，作者通过简单实现自己特定应用的简化内存管理算法，而不是调用标准运行时库或操作系统内核的内存分配代码，通常能获得
    100% 或更好的性能提升。希望这一节已经让你意识到自己代码中可能存在的这个问题。
- en: '**9.9 Common Pointer Problems**'
  id: totrans-143
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**9.9 常见的指针问题**'
- en: 'Programmers make six common mistakes when using pointers. Some of these mistakes
    immediately stop a program with a diagnostic message. Others are subtler, yielding
    incorrect results without otherwise reporting an error. Still others simply negatively
    affect the program’s performance. Great programmers are always aware of the risks
    of using pointers and avoid these mistakes:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 程序员在使用指针时会犯六个常见的错误。其中一些错误会立即通过诊断信息停止程序。其他错误则较为微妙，会导致错误结果，而不报告其他错误。还有一些错误会直接影响程序的性能。优秀的程序员始终意识到使用指针的风险，并避免这些错误：
- en: Using an uninitialized pointer
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用未初始化的指针
- en: Using a pointer that contains an illegal value such as `NULL`
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用包含非法值的指针，例如 `NULL`
- en: Continuing to use storage after it has been freed
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在存储已释放后继续使用
- en: Failing to free storage once the program is done using it
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 程序使用完存储后未释放
- en: Accessing indirect data using the wrong data type
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用错误的数据类型访问间接数据
- en: Performing invalid pointer operations
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 执行无效的指针操作
- en: '**9.9.1 Using an Uninitialized Pointer**'
  id: totrans-151
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**9.9.1 使用未初始化的指针**'
- en: 'Using a pointer variable before you’ve assigned a valid memory address to the
    pointer is a very common error. Beginning programmers often don’t realize that
    declaring a pointer variable reserves storage only for the pointer itself, not
    for the data that the pointer references. The following short C/C++ program demonstrates
    this problem:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 在为指针分配有效的内存地址之前使用指针变量是一个非常常见的错误。初学的程序员往往没有意识到，声明一个指针变量只会为指针本身保留存储空间，而不是为指针所引用的数据分配存储空间。以下是一个简短的C/C++程序，演示了这个问题：
- en: '[PRE20]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Although static variables you declare are, technically, initialized with `0`
    (that is, `NULL`), static initialization doesn’t initialize the pointer with a
    valid address. Therefore, when this program executes, the variable pointer won’t
    contain a valid address, and the program will fail. To avoid this problem, ensure
    that all pointer variables contain a valid address prior to dereferencing those
    pointers. For example:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管你声明的静态变量从技术上讲是以`0`（即`NULL`）初始化的，但静态初始化并不会将指针初始化为有效的地址。因此，当该程序执行时，变量指针将不包含有效地址，程序将会失败。为避免这个问题，确保所有指针变量在解引用之前包含有效地址。例如：
- en: '[PRE21]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Of course, there’s no such thing as a truly uninitialized variable on most
    CPUs. Variables are initialized in two different ways:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，在大多数CPU上并没有真正的未初始化变量。变量的初始化有两种方式：
- en: The programmer explicitly gives them an initial value.
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 程序员显式地为它们赋予初始值。
- en: They inherit whatever bit pattern happens to be in memory when the system binds
    storage to them.
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它们继承了系统为其绑定存储时内存中的任何位模式。
- en: Much of the time, garbage bit patterns laying around in memory don’t correspond
    to a valid memory address. Attempting to *dereference* such an invalid pointer
    (that is, to access the data in memory at which it points) raises a Memory Access
    Violation exception, if your OS is capable of trapping this exception.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数时候，内存中残留的垃圾位模式并不对应有效的内存地址。尝试*解引用*这样的无效指针（即访问它所指向的内存中的数据）会引发内存访问违规异常，前提是你的操作系统能够捕捉到这个异常。
- en: Sometimes, however, those random bits in memory just happen to correspond to
    a valid memory location you can access. In this situation, the CPU accesses the
    specified memory location without aborting the program. A novice programmer might
    think that accessing random memory is preferable to aborting a program. However,
    ignoring the error is far worse because your defective program continues to run
    without alerting you. If you store data using an uninitialized pointer, you may
    very well overwrite the values of other important variables in memory. This can
    produce some problems that are very difficult to locate.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，有时候内存中的这些随机位恰好对应于一个你可以访问的有效内存位置。在这种情况下，CPU会访问指定的内存位置而不会中止程序。一个初学者可能会认为，访问随机内存比中止程序更可取。然而，忽视错误要糟糕得多，因为你的有缺陷的程序会继续运行，而没有提醒你。如果你使用未初始化的指针存储数据，很可能会覆盖内存中其他重要变量的值。这会产生一些非常难以定位的问题。
- en: '**9.9.2 Using a Pointer That Contains an Illegal Value**'
  id: totrans-161
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**9.9.2 使用包含非法值的指针**'
- en: The second common mistake programmers make with pointers is assigning them invalid
    values (“invalid” in the sense of not containing the address of an actual object
    in memory). This can be considered a more general case of the first problem; without
    initialization, the garbage bits in memory supply the invalid address. The effects
    are the same. If you attempt to dereference a pointer containing an invalid address,
    you will either get a Memory Access Violation exception or access an unexpected
    memory location. Take care when dereferencing a pointer variable and make sure
    that you’ve assigned a valid address to the pointer before using it.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 程序员在使用指针时常犯的第二个错误是将无效值赋给它们（“无效”是指指针不包含内存中实际对象的地址）。这可以看作是第一个问题的一个更一般的情况；如果没有初始化，内存中的垃圾位就会提供无效的地址。其效果是一样的。如果你尝试解引用一个包含无效地址的指针，你将会遇到内存访问违规异常，或者访问一个意外的内存位置。解引用指针变量时要小心，确保在使用它之前已经为指针分配了有效地址。
- en: '**9.9.3 Continuing to Use Storage After It Has Been Freed**'
  id: totrans-163
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**9.9.3 在释放存储后继续使用它**'
- en: 'The third mistake is known as the *dangling pointer problem*. To understand
    it, consider the following Pascal code fragment:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 第三个错误被称为*悬空指针问题*。为了理解它，考虑以下Pascal代码片段：
- en: '[PRE22]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'This program allocates some storage and saves the address of that storage in
    the `p` variable. The code uses the storage for a while and then frees it, returning
    it to the system for other uses. Note that calling `dispose()` doesn’t change
    any data in the allocated memory. It doesn’t change the value of `p` in any way;
    `p` still points at the block of memory allocated earlier by `new()`. However,
    calling `dispose()` does tell the system that the program no longer needs this
    block of memory so that the system can use the memory for other purposes. The
    `dispose()` function cannot enforce the fact that you’ll never access this data
    again, however. You’re simply promising that you won’t. Of course, this code fragment
    breaks that promise: the last statement stores the value `5` at the address pointed
    to by `p` in memory.'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 该程序分配了一些存储空间，并将该存储空间的地址保存在`p`变量中。代码使用这块存储空间一段时间后，再通过`dispose()`释放它，将内存归还给系统供其他用途。请注意，调用`dispose()`并不会改变分配的内存中的任何数据。它不会以任何方式改变`p`的值；`p`仍然指向之前由`new()`分配的内存块。然而，调用`dispose()`确实通知系统该程序不再需要这块内存，因此系统可以将该内存用于其他目的。`dispose()`函数无法强制确保你再也不会访问这些数据，你只是承诺不会再访问。当然，这段代码打破了这个承诺：最后一条语句将值`5`存储到`p`指向的内存地址中。
- en: 'The biggest problem with dangling pointers is that sometimes you can get away
    with using them, so you won’t immediately know there’s a problem. As long as the
    system doesn’t reuse the storage you’ve freed, using a dangling pointer produces
    no ill effects in your program. However, with each additional call to `new()`,
    the system may decide to reuse the memory released by that previous call to `dispose()`.
    When it does reuse the memory, any subsequent attempt to dereference the dangling
    pointer may produce some unintended consequences. The problems can include reading
    data that has been overwritten, overwriting the new data, and (in the worst case)
    overwriting system heap management pointers (which will probably cause your program
    to crash). The solution is clear: never use a pointer value once you free the
    storage associated with that pointer.'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 悬挂指针的最大问题在于，有时候你可能会侥幸使用它们，因此你不会立刻发现问题。只要系统没有重用你已经释放的存储空间，使用悬挂指针对你的程序没有直接影响。然而，随着每次调用`new()`，系统可能会决定重用之前调用`dispose()`释放的内存。当系统重用内存时，任何后续对悬挂指针的解引用操作可能会产生一些意想不到的后果。这些问题包括读取已被覆盖的数据、覆盖新的数据，或者（在最坏的情况下）覆盖系统堆管理指针（这可能导致程序崩溃）。解决方案很明确：一旦释放了与指针关联的存储空间，就绝不再使用该指针的值。
- en: '**9.9.4 Failing to Free Storage After Using It**'
  id: totrans-168
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**9.9.4 使用后未释放存储空间**'
- en: 'Of all these mistakes, failing to free allocated storage probably has the least
    impact on the proper operation of your program. The following C code fragment
    demonstrates this problem:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 在所有这些错误中，未能释放已分配的存储空间可能对程序的正常运行影响最小。以下C语言代码片段展示了这个问题：
- en: '[PRE23]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: In this example, the program allocates 256 bytes of storage and references this
    storage using the `ptr` variable. Later, the program allocates another block of
    512 bytes and overwrites the value in `ptr` with the address of this new block.
    The former address value in `ptr` is lost. And because the program has overwritten
    this former value, there’s no way to pass the address of the first 256 bytes to
    the `free()` function. As a result, these 256 bytes of memory are no longer available
    to your program.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，程序分配了256字节的存储空间，并使用`ptr`变量引用该存储空间。随后，程序分配了另一块512字节的存储空间，并将`ptr`中的值覆盖为新块的地址。原来在`ptr`中的地址值丢失了。由于程序已经覆盖了这个值，所以没有办法将最初的256字节的地址传递给`free()`函数。因此，这256字节的内存就无法再被程序使用。
- en: While making 256 bytes of memory inaccessible to your program might not seem
    like a big deal, imagine that this code executes within a loop. With each iteration
    of the loop, the program loses another 256 bytes of memory. After a sufficient
    number of repetitions, the program exhausts the memory available on the heap.
    This problem is often called a *memory leak* because the effect is as if the memory
    bits were leaking out of your computer during program execution.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管让程序无法访问256字节的内存看起来似乎没什么大不了的，但想象一下这段代码在循环中执行的情况。每次循环迭代，程序都会丧失另外256字节的内存。经过足够多次的重复后，程序就会耗尽堆上的可用内存。这个问题通常被称为*内存泄漏*，因为其效果就像是内存数据在程序执行过程中从计算机中“泄漏”出去。
- en: 'Memory leaks are less of a problem than dangling pointers. Indeed, there are
    only two problems with memory leaks:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 内存泄漏不如悬空指针问题严重。实际上，内存泄漏只有两个问题：
- en: The danger of running out of heap space (which, ultimately, may cause the program
    to abort, though this is rare)
  id: totrans-174
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 堆空间耗尽的危险（这最终可能导致程序中止，尽管这种情况比较罕见）
- en: Performance problems due to virtual memory page swapping (*thrashing*)
  id: totrans-175
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由于虚拟内存页面交换导致的性能问题（*换页*）
- en: Nevertheless, freeing all of the storage you allocate is a good habit to develop.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管如此，释放你分配的所有存储空间是一个值得培养的好习惯。
- en: '**NOTE**'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*When your program quits, the OS will reclaim all of the storage, including
    the data lost via memory leaks. Therefore, memory lost via a leak is lost only
    to your program, not the whole system.*'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: '*当你的程序退出时，操作系统将回收所有存储空间，包括通过内存泄漏丢失的数据。因此，泄漏的内存只是对你的程序丢失，而不是整个系统。*'
- en: '**9.9.5 Accessing Indirect Data Using the Wrong Data Type**'
  id: totrans-179
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**9.9.5 使用错误的数据类型访问间接数据**'
- en: 'Another problem with pointers is that their lack of type-safe access makes
    it easy to accidentally use the wrong data type. Some languages, like assembly,
    cannot and do not enforce pointer type checking. Others, like C/C++, make it very
    easy to override the type of the object a pointer references. For example, consider
    the following C/C++ program fragment:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 指针的另一个问题是，它们缺乏类型安全的访问，使得容易不小心使用错误的数据类型。一些语言，比如汇编语言，不能也不强制进行指针类型检查。其他语言，比如C/C++，则非常容易覆盖指针引用对象的类型。例如，考虑以下C/C++程序片段：
- en: '[PRE24]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Generally, if you attempt to assign the value `5000` to the object pointed to
    by `pc`, the compiler will complain bitterly. The value `5000` won’t fit in the
    amount of storage associated with a character (`char`) object, which is 1 byte.
    This example, however, uses *type casting* (or *coercion*) to tell the compiler
    that `pc` really contains a pointer to an integer rather than a pointer to a character.
    Therefore, the compiler will assume that this assignment is legal.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，如果你试图将值`5000`赋给`pc`指向的对象，编译器会强烈抱怨。值`5000`无法适应与字符（`char`）对象相关联的存储空间，即1字节。然而，本文使用了*类型转换*（或*强制转换*）来告诉编译器，`pc`实际上包含的是指向一个整数的指针，而不是指向字符的指针。因此，编译器会认为这个赋值是合法的。
- en: However, if `pc` doesn’t actually point at an integer object, the last statement
    in this sequence can be disastrous. Characters are 1 byte long, and integers are
    usually larger. If the integer is larger than 1 byte, this assignment will overwrite
    some number of bytes beyond the 1 byte of storage that `malloc()` allocated. Whether
    or not this is catastrophic depends upon what data immediately follows the character
    object in memory.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果`pc`实际上没有指向一个整数对象，这个序列中的最后一条语句可能会造成灾难。字符是1字节长，而整数通常更大。如果整数大于1字节，这个赋值会覆盖`malloc()`分配的1字节存储空间之外的若干字节。是否灾难性取决于字符对象后面在内存中紧跟的数据是什么。
- en: '**9.9.6 Performing Illegal Operations on Pointers**'
  id: totrans-184
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**9.9.6 对指针执行非法操作**'
- en: 'The last category of common pointer mistakes has to do with operations on the
    pointers themselves. Arbitrary pointer arithmetic can lead to a pointer that points
    outside the range of the data originally allocated. By doing some crazy arithmetic,
    you can even modify a pointer so that it doesn’t point at a correct object. Consider
    the following (really nasty) C code:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 常见的指针错误的最后一类与指针本身的操作有关。任意的指针运算可能导致指针指向原本分配的数据范围之外的地方。通过一些疯狂的运算，甚至可以修改指针，使其不再指向正确的对象。考虑以下（非常糟糕的）C代码：
- en: '[PRE25]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: This example casts `p` as a pointer to a `char`. Then it adds `1` to the value
    in `p`. As the compiler thinks that `p` is pointing at a character (because of
    the cast), it actually adds the value `1` to the address held in `p`. The last
    instruction in this sequence stores the value `5` into the memory address pointed
    at by `p`, which is now 1 byte into the 4 bytes set aside for the `i[0]` element.
    On some machines, this will cause a fault; on others, it will store a bizarre
    value into `i[0]` and `i[1]`.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 这个示例将`p`转换为指向`char`的指针。然后，它将`1`加到`p`中值的基础上。由于编译器认为`p`指向一个字符（因为有类型转换），它实际上将值`1`加到`p`中保存的地址上。这个序列中的最后一条指令将值`5`存储到`p`指向的内存地址中，这个地址现在距离`i[0]`元素的4字节区间只有1字节。在一些机器上，这将导致故障；而在其他机器上，它将把一个奇怪的值存储到`i[0]`和`i[1]`中。
- en: Comparing two pointers for less than or greater than when the two pointers do
    not point to the same object (typically an array or struct) is another example
    of an illegal operation on a pointer, as is casting a pointer as an integer and
    assigning an integer value to that pointer, which can produce unexpected results.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 比较两个指针是否小于或大于当这两个指针不指向同一个对象（通常是数组或结构体）时，就是另一个非法的指针操作例子，类似地，将指针强制转换为整数并赋予该指针一个整数值，也可能产生意想不到的结果。
- en: '**9.10 Pointers in Modern Languages**'
  id: totrans-189
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**9.10 现代语言中的指针**'
- en: Because of the problems described in the previous section, modern HLLs (like
    Java, C#, Swift, and C++11/C++14) try to eliminate manual memory allocation and
    deallocation. These languages let you create new objects on the heap (typically
    using a `new()` function) but don’t provide any facilities for explicitly deallocating
    that storage. Instead, the language’s runtime system tracks memory usage and automatically
    recovers the storage, via garbage collection, once the program is no longer using
    it. This eliminates most (but not all) of the problems with uninitialized and
    dangling pointers. It also lowers the likelihood of memory leaks. These new languages
    dramatically reduce the number of problems related to errant pointer use.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 由于上一节中描述的问题，现代高级语言（如Java、C#、Swift和C++11/C++14）尝试消除手动内存分配和释放。这些语言允许你在堆上创建新的对象（通常使用`new()`函数），但不提供显式释放存储的设施。相反，语言的运行时系统会追踪内存使用情况，并在程序不再使用内存时通过垃圾回收自动回收存储。这消除了大多数（但不是所有）与未初始化和悬空指针相关的问题，也降低了内存泄漏的可能性。这些新语言大大减少了与错误指针使用相关的问题数量。
- en: Of course, ceding control over memory allocation and deallocation introduces
    some problems of its own. In particular, you give up the ability to control the
    memory allocation lifetime. Now, the runtime system determines when to garbage-collect
    unused data, so large chunks of data could still be reserved for some time after
    you’ve finished using them.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，放弃对内存分配和释放的控制也会带来一些问题。特别是，你失去了控制内存分配生命周期的能力。现在，运行时系统决定何时进行垃圾回收以回收未使用的数据，因此，即使你已经不再使用某些数据，这些数据可能仍然会保留一段时间。
- en: '**9.11 Managed Pointers**'
  id: totrans-192
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**9.11 托管指针**'
- en: 'Some programming languages provide very limited pointer capabilities. For example,
    standard Pascal allows only a few operations on pointers: assignment (copy), comparison
    (for equality/inequality), and dereferencing. It does not support pointer arithmetic,
    meaning many types of mistakes with pointers are impossible.^([4](footnotes.xhtml#ch9fn4))
    At the other extreme is C/C++, which allows different arithmetic operations on
    pointers that make the language very powerful but introduce the likelihood of
    defects in the code.'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 一些编程语言提供非常有限的指针功能。例如，标准Pascal仅允许对指针进行少数几种操作：赋值（复制）、比较（用于相等/不相等）和解引用。它不支持指针算术，这意味着许多指针相关的错误是不可能发生的^([4](footnotes.xhtml#ch9fn4))。另一方面，C/C++允许对指针进行不同的算术运算，使得该语言非常强大，但也引入了代码缺陷的可能性。
- en: Modern language systems (for example, C# and the Microsoft Common Language Runtime
    system) introduce *managed pointers*, which allow various arithmetic operations
    on pointers, providing greater flexibility than a language like standard Pascal,
    but with restrictions that help avoid many common pointer pitfalls. For example,
    in these languages you cannot add an arbitrary integer to an arbitrary pointer
    (as is possible in C/C++). If you want to add an integer to a pointer and obtain
    a legal result, the pointer must contain the address of an array object (or other
    collection of like elements in memory). Furthermore, the integer’s value must
    be limited to a value that does not exceed the size of the data type (that is,
    the runtime system enforces array bounds checking).
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 现代语言系统（例如，C#和微软通用语言运行时系统）引入了*托管指针*，它允许对指针进行各种算术运算，比标准的Pascal语言提供了更大的灵活性，但也有一些限制，帮助避免许多常见的指针问题。例如，在这些语言中，你不能将任意整数加到任意指针上（这在C/C++中是可能的）。如果你想将一个整数加到指针上并获得合法的结果，指针必须包含一个数组对象的地址（或内存中其他类似元素的集合）。此外，整数的值必须限制在不超过数据类型大小的范围内（即，运行时系统会强制执行数组边界检查）。
- en: While using managed pointers won’t eliminate all pointer problems, it does prevent
    wiping out data outside the range of a data object referenced by a pointer. It
    also helps prevent security issues in software, such as attempts to break into
    a system by providing illegal offsets in pointer arithmetic.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然使用智能指针不能消除所有指针问题，但它确实可以防止指针引用的数据对象范围外的数据被擦除。它还帮助防止软件中的安全问题，例如通过在指针运算中提供非法偏移量来尝试攻击系统。
- en: '**9.12 For More Information**'
  id: totrans-196
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**9.12 更多信息**'
- en: 'Duntemann, Jeff. *Assembly Language Step-by-Step*. 3rd ed. Indianapolis: Wiley,
    2009.'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: Duntemann, Jeff. *汇编语言一步步*. 第3版。印第安纳波利斯：Wiley，2009年。
- en: 'Hyde, Randall. *The Art of Assembly Language*. 2nd ed. San Francisco: No Starch
    Press, 2010.'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: Hyde, Randall. *汇编语言艺术*。第2版。旧金山：No Starch Press，2010年。
- en: 'Oualline, Steve. *How Not to Program in C++*. San Francisco: No Starch Press,
    2003.'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: Oualline, Steve. *如何避免在C++中编程错误*。旧金山：No Starch Press，2003年。
