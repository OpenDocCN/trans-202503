- en: <hgroup>
  id: totrans-0
  prefs: []
  type: TYPE_NORMAL
  zh: <hgroup>
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">12</samp> <samp class="SANS_Dogma_OT_Bold_B_11">GENERATING
    SOUNDS</samp>
  id: totrans-1
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">12</samp> <samp class="SANS_Dogma_OT_Bold_B_11">生成声音</samp>
- en: </hgroup>
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: </hgroup>
- en: '![](../images/opener.png)'
  id: totrans-3
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/opener.png)'
- en: Now it’s time for something completely different! In this next project, you’ll
    create a song using JavaScript and the Web Audio API. You’ll also learn some general
    tips about sound synthesis and how electronic music is made.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是时候做点完全不同的事情了！在下一个项目中，你将使用 JavaScript 和 Web Audio API 创建一首歌曲。你还将学习一些关于声音合成的通用技巧，以及电子音乐是如何制作的。
- en: This chapter will introduce the Web Audio API and Tone.js, a JavaScript library
    built on top of it. This will be your first taste of the wide world of third-party
    JavaScript libraries, which are collections of prewritten code that you can harness
    to simplify complex tasks. Tone.js raises the level of abstraction compared with
    the Web Audio API, allowing you to think about and implement musical concepts
    in a more natural way. Once you’re familiar with how it works, in [Chapter 13](chapter13.xhtml)
    you’ll put everything you’ve learned to use to make a song that you can customize
    or even rewrite.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将介绍 Web Audio API 以及基于它构建的 JavaScript 库 Tone.js。这将是你第一次接触广阔的第三方 JavaScript
    库世界，它们是一些预先编写好的代码集合，可以帮助你简化复杂的任务。与 Web Audio API 相比，Tone.js 提高了抽象层次，让你能够以更自然的方式思考和实现音乐概念。掌握其工作原理后，在[第13章](chapter13.xhtml)中，你将运用所学的知识制作一首歌曲，你可以自定义甚至重写它。
- en: <samp class="SANS_Futura_Std_Bold_B_11">The Web Audio API</samp>
  id: totrans-6
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">Web Audio API</samp>
- en: This section covers the basics of the Web Audio API, which provides a way to
    create and manipulate sounds in the browser using JavaScript. Google Chrome introduced
    the Web Audio API in 2011, and soon after that it was released as a W3C standard
    (the W3C, or World Wide Web Consortium, is an organization that develops standards
    for the web). To use it, you create nodes and then connect them together. Each
    *node* represents some aspect of a sound—one node might generate a basic tone,
    a second node might set its volume, a third might apply an effect such as reverb
    or distortion to the tone, and so on. With this scheme, you can produce almost
    any kind of sound you might want.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 本节内容介绍 Web Audio API 的基础知识，它提供了一种使用 JavaScript 在浏览器中创建和操控声音的方法。Google Chrome
    在 2011 年引入了 Web Audio API，随后它被发布为 W3C 标准（W3C，或称万维网联盟，是一个制定 Web 标准的组织）。使用 Web Audio
    API 时，你需要创建节点并将它们连接在一起。每个*节点*表示声音的某个方面——一个节点可能生成基本音调，第二个节点可能设置其音量，第三个节点可能为音调应用效果，例如混响或失真，依此类推。通过这种方式，你可以制作几乎任何你想要的声音。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Setting Up</samp>
  id: totrans-8
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">设置</samp>
- en: As always, we’ll start with a simple HTML file. The file will give the user
    the ability to play a sound generated by the Web Audio API. Create a new directory
    called *music* and enter the content in [Listing 12-1](#Lis12-1) into a new file
    called *index.html*.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 一如既往，我们从一个简单的 HTML 文件开始。该文件将允许用户播放 Web Audio API 生成的声音。创建一个名为*music*的新目录，并将[示例
    12-1](#Lis12-1)中的内容放入一个名为*index.html*的新文件中。
- en: '[PRE0]'
  id: totrans-10
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 12-1: An</samp> <samp
    class="SANS_Futura_Std_Book_11">index.html</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">file
    for exploring the Web Audio API</samp>'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">示例 12-1: 用于探索 Web Audio API
    的</samp> <samp class="SANS_Futura_Std_Book_11">index.html</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">文件</samp>'
- en: 'This listing creates two visual elements: a Play button ❶ and a paragraph containing
    the text “Playing” ❷. The paragraph uses an inline style attribute, which allows
    us to add CSS declarations directly to the element from the HTML file. In this
    case, we’re setting display to none, which hides the element. Later, we’ll use
    JavaScript to remove the style and show the element when the audio is playing.'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 这个示例创建了两个可视化元素：一个播放按钮 ❶ 和一个包含文本“正在播放” ❷ 的段落。该段落使用了内联样式属性，这使我们能够直接在 HTML 文件中向元素添加
    CSS 声明。在这种情况下，我们将 display 设置为 none，从而隐藏该元素。稍后，我们将使用 JavaScript 删除该样式，并在音频播放时显示该元素。
- en: Next, we’ll start writing the JavaScript. In many browsers, including Google
    Chrome, the Web Audio API won’t play any sound until the user interacts with the
    page. We’re using the Play button as our interactive element, which will trigger
    our audio code. Because we only need the button to be clicked once, we’ll hide
    it after it’s been clicked.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将开始编写 JavaScript 代码。在许多浏览器中，包括谷歌 Chrome，Web Audio API 在用户与页面交互之前不会播放任何声音。我们使用播放按钮作为交互元素，点击该按钮将触发我们的音频代码。因为我们只需要按钮被点击一次，所以点击后我们将隐藏按钮。
- en: Create *script.js* in the same directory as the HTML file and add the content
    shown in [Listing 12-2](#Lis12-2). This code hides the Play button and shows the
    “Playing” text when the user clicks the button. Note that we’re not doing any
    Web Audio API code yet—this is just setting up the button.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在与 HTML 文件相同的目录下创建*script.js*文件，并添加[Listing 12-2](#Lis12-2)中显示的内容。该代码隐藏了播放按钮，并在用户点击按钮时显示“播放中”文本。请注意，我们现在还没有编写任何
    Web Audio API 的代码——这只是设置按钮的部分。
- en: '[PRE1]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 12-2: Switching the
    visibility of the elements on a mouse click</samp>'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 12-2：在鼠标点击时切换元素的可见性</samp>
- en: 'First, we get references to the two elements using the document.querySelector
    method ❶. Then we add a click event listener to the Play button ❷. When the user
    clicks it, our event listener adds an inline style attribute of display: none
    to the button and sets the inline style of the paragraph to an empty string, effectively
    removing the inline style set as an attribute in the HTML file. The net effect
    of this code is that clicking the Play button will hide the button and show the
    paragraph. This has two purposes: it lets the user know that music should now
    be playing, and it removes the Play button so it can’t be clicked a second time.'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: '首先，我们使用 document.querySelector 方法 ❶ 获取两个元素的引用。然后，我们为播放按钮添加点击事件监听器 ❷。当用户点击按钮时，我们的事件监听器会将
    display: none 内联样式属性添加到按钮上，并将段落的内联样式设置为空字符串，从而有效地移除在 HTML 文件中设置的内联样式。此代码的最终效果是，点击播放按钮会隐藏按钮并显示段落。这样做有两个目的：一是让用户知道音乐应该开始播放了，二是移除播放按钮，防止再次点击。'
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Generating a Tone
    with the Web Audio API</samp>
  id: totrans-18
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">使用 Web Audio API
    生成音调</samp>
- en: With our setup out of the way, we can now write some Web Audio API code. To
    get started, we’ll just generate a single tone, the audio equivalent of “Hello,
    world!” The code to generate the tone is shown in [Listing 12-3](#Lis12-3). As
    I mentioned earlier, the audio won’t play unless it’s triggered by a user event,
    such as a mouse click, so all the audio code lives inside the click handler.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 在完成设置后，我们现在可以编写一些 Web Audio API 的代码。首先，我们将生成一个单一的音调，相当于“你好，世界！”的音频。生成音调的代码显示在[Listing
    12-3](#Lis12-3)中。如前所述，音频不会播放，除非由用户事件触发，例如鼠标点击，因此所有音频代码都放在点击事件处理程序中。
- en: '[PRE2]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 12-3: Playing a single
    tone with the Web Audio API</samp>'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 12-3：使用 Web Audio API
    播放单一音调</samp>
- en: The first thing we do is create the *audio context* ❶. This is the object through
    which we interact with the Web Audio API, similar to the drawing context for the
    canvas element. Next, we create our first node, an oscillator ❷. In electronics
    and signal processing terms, an *oscillator* is a device that creates a signal
    that repeatedly goes up and down in a regular pattern. The default waveform a
    Web Audio API oscillator outputs is a sine wave, shown in [Figure 12-1](chapter12.xhtml#fig12-1).
    When the wave oscillates fast enough, and is connected to a speaker, it creates
    an audible tone. In this example, we’re setting the frequency to 440 Hertz (Hz),
    or 440 cycles per second. In other words, the oscillator is outputting a signal
    that transitions from 0 to 1 to –1 and back to 0 a total of 440 times every second.
    This means that one cycle of the wave lasts 1/440 of a second, or 2.27 ms. I used
    440 Hz here because it’s the standard reference pitch for tuning musical instruments.
    The frequency corresponds to the note A above middle C.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先做的是创建*音频上下文* ❶。这是我们与 Web Audio API 交互的对象，类似于画布元素的绘图上下文。接下来，我们创建第一个节点，一个振荡器
    ❷。在电子学和信号处理术语中，*振荡器*是一个生成信号的设备，该信号会按照规律的模式反复上下波动。Web Audio API 振荡器输出的默认波形是正弦波，如[图
    12-1](chapter12.xhtml#fig12-1)所示。当波形振荡足够快，并且与扬声器连接时，它会产生可听的音调。在这个例子中，我们将频率设置为
    440 赫兹（Hz），即每秒 440 次循环。换句话说，振荡器输出的信号在每秒内会从 0 到 1 再到 –1，然后返回 0，共经历 440 次变化。这意味着波形的一个周期持续
    1/440 秒，约为 2.27 毫秒。我这里使用 440 Hz，因为它是调音时常用的标准参考音高，对应的是中央 C 上的 A 音。
- en: '![](../images/Figure_12-1.png)'
  id: totrans-23
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/Figure_12-1.png)'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 12-1: One cycle of a
    sine wave</samp>'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">图 12-1：一个正弦波的周期</samp>
- en: Next, we create a gain node ❸ and set its value to 0.5. In signal processing,
    *gain* refers to an increase or decrease in a signal’s amplitude, or its range
    of values. In practical terms, gain acts as a volume control. A gain of 2 doubles
    the amplitude, making the sound louder, a gain of 0.5 halves the amplitude, making
    the sound softer, and a gain of 1 (the default value of a gain node) has no effect
    on the amplitude. Applying a gain of 0.5 to the sine wave from [Figure 12-1](chapter12.xhtml#fig12-1)
    would produce a sine wave with a maximum value of 0.5 and a minimum value of –0.5,
    as shown in [Figure 12-2](chapter12.xhtml#fig12-2).
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们创建一个增益节点 ❸ 并将其值设置为 0.5。在信号处理术语中，*增益*指的是信号幅度的增减，或其数值范围的变化。实际上，增益就像是音量控制。增益为
    2 时，幅度加倍，声音变得更大；增益为 0.5 时，幅度减半，声音变得更小；而增益为 1（增益节点的默认值）则对幅度没有影响。对来自[图 12-1](chapter12.xhtml#fig12-1)的正弦波应用
    0.5 的增益，将产生一个最大值为 0.5、最小值为 –0.5 的正弦波，如[图 12-2](chapter12.xhtml#fig12-2)所示。
- en: '![](../images/Figure_12-2.png)'
  id: totrans-26
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/Figure_12-2.png)'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 12-2: The sine wave
    from [Figure 12-1](chapter12.xhtml#fig12-1), with a gain of 0.5 applied</samp>'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">图 12-2：[图 12-1](chapter12.xhtml#fig12-1)
    中的正弦波，应用了 0.5 的增益</samp>
- en: 'So far we have two nodes: an oscillator node and a gain node. To actually apply
    the gain to the oscillator’s signal, we need to connect the nodes together. We
    link the output of the oscillator node to the input of the gain node using the
    oscillator node’s connect method ❹. Then, to be able to hear the result, we connect
    the output of the gain node to the main output, which is available to us through
    the audio context as ctx.destination. These connections mean that the oscillator
    signal is passed through the gain node and then passed to the output, which will
    ultimately go to your headphones or speakers, if the sound is turned on. [Figure
    12-3](chapter12.xhtml#fig12-3) illustrates these connections.'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们有两个节点：一个振荡器节点和一个增益节点。为了将增益应用于振荡器的信号，我们需要将这些节点连接在一起。我们使用振荡器节点的连接方法 ❹，将振荡器节点的输出连接到增益节点的输入。然后，为了能够听到结果，我们将增益节点的输出连接到主输出，这可以通过音频上下文中的
    ctx.destination 获取。这些连接意味着振荡器信号经过增益节点后传递到输出，最终会传送到你的耳机或扬声器，如果声音已开启的话。[图 12-3](chapter12.xhtml#fig12-3)
    展示了这些连接。
- en: '![](../images/Figure_12-3.png)'
  id: totrans-29
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/Figure_12-3.png)'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 12-3: The graph of nodes</samp>'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">图 12-3：节点的图示</samp>
- en: The oscillator node doesn’t actually create a signal until we tell it to. To
    do that, we call the start method on the oscillator, passing audioCtx .currentTime
    as an argument ❺. The currentTime property corresponds to the amount of time in
    seconds that the audio context has been active. By passing audioCtx.currentTime
    to the start method, we’re telling the oscillator to start playing immediately.
    Then we call the stop method, passing audioCtx .currentTime + 2. This tells the
    oscillator to stop two seconds after it started.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 振荡器节点实际上在我们告诉它之前并不会创建信号。为了做到这一点，我们调用振荡器的 start 方法，并将 audioCtx.currentTime 作为参数传递
    ❺。currentTime 属性对应于音频上下文已激活的秒数。通过将 audioCtx.currentTime 传递给 start 方法，我们告诉振荡器立即开始播放。然后我们调用
    stop 方法，将 audioCtx.currentTime + 2 传递给它。这告诉振荡器在开始播放两秒后停止。
- en: The effect of all of this code is that when you load the *index.html* page in
    your browser and click the Play button, a tone of 440 Hz should play for two seconds.
    If you don’t hear anything, make sure sound is enabled on your computer and browser—for
    example, by playing a YouTube video. If it still doesn’t work, check the console
    to make sure there aren’t any errors.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码的效果是，当你在浏览器中加载 *index.html* 页面并点击播放按钮时，应该播放一个 440 Hz 的音调，持续两秒钟。如果没有声音，请确保你的计算机和浏览器的声音已启用——例如，通过播放
    YouTube 视频。如果仍然没有声音，请检查控制台，确保没有错误。
- en: You might be thinking that you just had to write a lot of code for a very simple
    example, and you’d be right! The Web Audio API is quite powerful, but you have
    to work at a very low level with extremely basic building blocks. To simplify
    things, next we’re going to shift our focus to a popular, higher-level audio library
    called Tone.js.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会想，为什么要为一个非常简单的示例写这么多代码，没错，你的想法是对的！Web Audio API 功能强大，但你必须在非常低的层次上使用极其基本的构建块。为了简化，接下来我们将把焦点转向一个流行的高级音频库——Tone.js。
- en: <samp class="SANS_Futura_Std_Bold_B_11">The Tone.js Library</samp>
  id: totrans-34
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">Tone.js 库</samp>
- en: The Tone.js library is built on top of the Web Audio API. It’s designed to make
    it easier to create music using the API. For example, instead of having to fiddle
    with oscillators and gain nodes, Tone.js lets you use electronic instruments with
    volume controls. Instead of using frequencies, you can use the names of musical
    notes. And instead of using seconds for controlling when events happen, you can
    use bars and beats.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: Tone.js 库建立在 Web Audio API 之上。它的设计目的是简化使用 API 创建音乐的过程。例如，Tone.js 让你可以使用电子乐器并控制音量，而不必手动调节振荡器和增益节点。你可以使用音符名称代替频率，也可以用小节和拍子代替使用秒来控制事件的发生时间。
- en: The Tone.js website, [*https://<wbr>tonejs<wbr>.github<wbr>.io*](https://tonejs.github.io),
    provides details on installing and using the library. The easiest option is to
    use a prebuilt file hosted on a content delivery network (CDN) like [*https://<wbr>unpkg<wbr>.com*](https://unpkg.com),
    which is what we’ll do here. This way all you have to do to access the library
    is reference a URL directly from a script element in your HTML file. There’s no
    need to download a copy of the library, as long as you have access to the internet
    while you’re working.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: Tone.js 网站 [*https://<wbr>tonejs<wbr>.github<wbr>.io*](https://tonejs.github.io)
    提供了安装和使用该库的详细信息。最简单的方式是使用托管在内容分发网络（CDN）上的预构建文件，例如 [*https://<wbr>unpkg<wbr>.com*](https://unpkg.com)，这就是我们在这里所做的。通过这种方式，您只需通过
    HTML 文件中的脚本元素直接引用 URL 即可访问该库。只要在工作时能连接互联网，就无需下载库的副本。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Generating a Tone
    with Tone.js</samp>
  id: totrans-37
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">使用 Tone.js 生成音调</samp>
- en: Let’s re-create our Web Audio API “Hello, world!” example using the Tone.js
    library instead. We can keep all the HTML the same, except for adding a new script
    tag for the library, as shown in [Listing 12-4](#Lis12-4).
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用 Tone.js 库重新创建 Web Audio API “Hello, world!” 示例。除了添加一个新的脚本标签用于库之外，其他 HTML
    保持不变，如 [示例 12-4](#Lis12-4) 所示。
- en: '[PRE3]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 12-4: Including Tone.js
    in the</samp> <samp class="SANS_Futura_Std_Book_11">index.html</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">file</samp>'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">示例 12-4：在</samp> <samp class="SANS_Futura_Std_Book_11">index.html</samp>
    <samp class="SANS_Futura_Std_Book_Oblique_I_11">文件中包含 Tone.js</samp>
- en: We set the src of the new script element to an *unpkg.com* file containing the
    full Tone.js library as a single JavaScript file.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将新脚本元素的 `src` 设置为包含完整 Tone.js 库的 *unpkg.com* 文件，该库作为一个单独的 JavaScript 文件。
- en: Next, we’ll write the JavaScript. Since Tone.js uses the Web Audio API underneath,
    we still have the limitation that user input is required to start playing the
    audio. We therefore still need the click event handler, but everything else in
    *script.js* will change. [Listing 12-5](#Lis12-5) shows the updated JavaScript
    file.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将编写 JavaScript 代码。由于 Tone.js 底层使用的是 Web Audio API，我们仍然面临一个限制，即需要用户输入来开始播放音频。因此，我们仍然需要点击事件处理程序，但
    *script.js* 中的其他部分将发生变化。[Listing 12-5](#Lis12-5) 显示了更新后的 JavaScript 文件。
- en: '[PRE4]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 12-5: Playing a single
    tone with Tone.js</samp>'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 12-5: 使用 Tone.js 播放单一音调</samp>'
- en: The first thing we need to do is call Tone.start. This triggers the Tone.js
    library to start inside the click handler, ensuring that the browser will allow
    it to play audio. Next, we create a new Tone.Synth object. *Synth* is short for
    *synthesizer*, an electronic instrument, usually with a keyboard, that can generate
    (synthesize) all kinds of sounds. A Tone.Synth is a simple code version of such
    an instrument.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要做的第一件事是调用 Tone.start。这将触发 Tone.js 库在点击事件处理程序中启动，确保浏览器允许播放音频。接下来，我们创建一个新的
    Tone.Synth 对象。*Synth* 是 *synthesizer*（合成器）的缩写，是一种电子乐器，通常带有键盘，可以生成（合成）各种声音。Tone.Synth
    是这种乐器的简化代码版本。
- en: The Tone.Synth constructor takes an object as its argument that allows us to
    configure various aspects of the synthesizer. In this case, we’re telling the
    synth to use an oscillator that generates sine waves. We’re also giving the synth
    a simple amplitude envelope and a volume of -6. I’ll explain what these settings
    mean in the following section, but for now, this is what we need to match the
    Web Audio API oscillator from [Listing 12-3](#Lis12-3). After the constructor
    we chain the toDestination method, which connects the output of the synth to the
    audio context’s output.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: Tone.Synth 构造函数接受一个对象作为参数，允许我们配置合成器的各个方面。在这种情况下，我们告诉合成器使用一个生成正弦波的振荡器。我们还给合成器设置了一个简单的振幅包络和
    -6 的音量。我将在接下来的章节中解释这些设置的含义，但现在，这些设置是我们需要的，以匹配 [Listing 12-3](#Lis12-3) 中的 Web
    Audio API 振荡器。构造函数之后，我们链式调用 toDestination 方法，将合成器的输出连接到音频上下文的输出。
- en: Finally, we tell the synth to play a single note using its triggerAttackRelease
    method. This method takes the note’s name, the duration, and the time at which
    to play the note. We’re passing "A4" for the note name, which is equivalent to
    440 Hz, and telling it to play for two seconds, starting immediately. When you
    reload your browser and click the Play button, you should hear the same sound
    as when you ran [Listing 12-3](#Lis12-3).
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们告诉合成器使用它的 triggerAttackRelease 方法播放一个音符。这个方法需要音符名称、时长和播放时间。我们传入 "A4" 作为音符名称，它等于
    440 Hz，并告诉它播放两秒钟，从现在开始。重新加载浏览器并点击播放按钮后，你应该能听到和运行 [Listing 12-3](#Lis12-3) 时相同的声音。
- en: As you can hopefully see, using the Tone.js library simplifies the process of
    making music with the Web Audio API. Instead of having to create separate nodes
    for different aspects of a sound (pitch, gain, and so on), everything is unified
    under one Synth object. If you have any musical knowledge, you’ll also find that
    the library uses concepts much closer to your understanding than the API does,
    for example, by using note names instead of frequencies. As you learn more about
    Tone.js, you’ll see more examples of this.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，使用 Tone.js 库简化了通过 Web Audio API 制作音乐的过程。你不需要为声音的不同方面（如音高、增益等）创建单独的节点，所有内容都统一在一个
    Synth 对象下。如果你有任何音乐方面的知识，你会发现该库使用的概念比 API 更接近你的理解，例如使用音符名称而不是频率。随着你对 Tone.js 的了解增加，你将看到更多类似的例子。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Understanding the
    Tone.Synth Options</samp>
  id: totrans-49
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">理解 Tone.Synth 选项</samp>
- en: Let’s take a closer look at the object we passed to the Tone.Synth constructor
    in [Listing 12-5](#Lis12-5). The first property, oscillator, defines the options
    for the oscillator generating the signal. In this case, we’re just setting the
    type of the oscillator to be a sine wave, using the type property.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们仔细看看我们在 [Listing 12-5](#Lis12-5) 中传递给 Tone.Synth 构造函数的对象。第一个属性，oscillator，定义了生成信号的振荡器选项。在这种情况下，我们只是设置振荡器的类型为正弦波，使用
    type 属性。
- en: The next property defines the options for the *amplitude envelope*, which determines
    how the volume of a note changes over the course of its duration. Most synthesizers,
    hardware and software, allow you to configure amplitude envelopes. The most common
    type of envelope is an *ADSR envelope*, short for *attack, decay, sustain, release*.
    The *attack* is the amount of time between the note being triggered (for example,
    when you press a key on a synthesizer) and the note reaching its maximum volume.
    The *decay* is the amount of time between the end of the attack and the sustain
    portion of the note. The *sustain* is a gain value that defines the volume the
    note will remain at after the attack and decay, for as long as the key is held
    down. Typically this is some fraction of the full volume achieved by the attack
    portion of the envelope. The *release* defines how long it will take for the note’s
    amplitude to get back down to zero after the key is released. [Figure 12-4](chapter12.xhtml#fig12-4)
    shows these different values graphically.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个属性定义了*振幅包络*的选项，振幅包络决定了音符在其持续时间内音量的变化。大多数合成器，无论硬件还是软件，都允许你配置振幅包络。最常见的包络类型是*ADSR
    包络*，即*攻击、衰减、保持、释放*的缩写。*攻击*是指从音符被触发（例如，当你按下合成器上的一个键）到音符达到最大音量之间的时间。*衰减*是指从攻击结束到音符进入保持阶段之间的时间。*保持*是一个增益值，定义了音符在攻击和衰减之后，在按键保持按下时音符将保持的音量。通常，这个值是包络攻击部分所达到的最大音量的某个比例。*释放*定义了当释放按键后，音符的振幅降到零所需的时间。[图
    12-4](chapter12.xhtml#fig12-4)以图形方式展示了这些不同的值。
- en: '![](../images/Figure_12-4.png)'
  id: totrans-52
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/Figure_12-4.png)'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 12-4: The parts of an
    ADSR envelope</samp>'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">图 12-4：ADSR 包络的各个部分</samp>
- en: ADSR envelopes are an approximation of how many real-world musical instruments
    work. For example, when you bow a violin, it takes some time for the note to get
    up to its full volume—that is, it has a long attack. By contrast, when you press
    a key on a piano, the attack is very short. Similarly, when you stop bowing a
    note on a violin it takes a little time for the string to stop vibrating, whereas
    the release of a piano note is more immediate. Synthetic ADSR envelopes are still
    pretty simplistic—they aren’t a perfect simulation of real-life instruments—but
    they add a lot of expressivity to what would otherwise just be a boring tone.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: ADSR 包络是许多现实世界乐器工作原理的近似。例如，当你拉小提琴弓时，音符需要一些时间才能达到最大音量——也就是说，它有一个较长的攻击时间。相比之下，当你按下钢琴的一个键时，攻击时间非常短。类似地，当你停止拉小提琴弓时，弦的振动需要一点时间才能停止，而钢琴音符的释放则更为立即。合成的
    ADSR 包络仍然相当简化——它们并不是现实乐器的完美模拟——但它们为原本可能只是单调音调的声音添加了很多表现力。
- en: That said, the ADSR envelope we’ve used for our synth is as boring as they come.
    We’ve set the attack, decay, and release values to 0 and the sustain to 1, meaning
    the tone is at full volume for its entire duration. This matches what we did with
    the simple Web Audio API oscillator from [Listing 12-3](#Lis12-3), and it’s part
    of why the resulting tone sounds so synthetic.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 话虽如此，我们用于合成器的 ADSR 包络还是非常单调。我们将攻击、衰减和释放值设置为 0，保持值设置为 1，这意味着音调在整个持续时间内都保持最大音量。这与我们在[清单
    12-3](#Lis12-3)中使用简单的 Web 音频 API 振荡器所做的相匹配，这也是为什么生成的音调听起来如此合成的原因之一。
- en: The final property of the synth options object, volume, sets the overall volume
    of the synthesizer in decibels (dB). Decibels are an alternative way to talk about
    gain, and in some ways they match the way we think about gain better. A setting
    of 0 decibels is equivalent to a gain of 1 (no change to the volume), –6 decibels
    is equivalent to a gain of 0.5, or half the volume, –12 decibels corresponds to
    a gain of 0.25, or a quarter of the volume, and so on; every +6 decibels doubles
    the volume, and every –6 decibels halves it. Our ears are attuned to the relative
    volume between sounds, so every time the level is halved or doubled, it sounds
    to us like it’s going down or up by a fixed amount. This “fixed amount” is a fixed
    number of decibels that are added or subtracted, which is why decibels can be
    easier to use for setting volume. In this case, we’re passing –6 dB to match the
    gain of 0.5 from [Listing 12-3](#Lis12-3).
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 合成器选项对象的最后一个属性，volume，设置了合成器的总体音量，单位为分贝（dB）。分贝是一种表示增益的替代方式，在某些方面它们比其他方式更符合我们对增益的理解。0
    分贝的设置相当于增益为 1（音量没有变化），–6 分贝相当于增益为 0.5，即音量减半，–12 分贝对应于增益为 0.25，即音量的四分之一，依此类推；每增加
    +6 分贝，音量翻倍，每减少 –6 分贝，音量减半。我们的耳朵对声音之间的相对音量敏感，因此每次音量减半或翻倍时，我们感觉它像是以固定的量上升或下降。这“固定量”是增加或减少的固定分贝数，这也是为什么分贝在设置音量时可能更容易使用。在这种情况下，我们传递了
    –6 dB，以匹配[清单 12-3](#Lis12-3)中的 0.5 增益。
- en: Now that you know what the options are, let’s try playing with them! First,
    we’ll modify the type of the oscillator. Currently the oscillator is set to generate
    a sine wave, but we’re going to switch to a square wave instead. [Figure 12-5](chapter12.xhtml#fig12-5)
    shows the waveform of a single cycle of a square wave.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你知道了有哪些选项，让我们试着玩一玩它们！首先，我们将修改振荡器的类型。目前振荡器设置为生成正弦波，但我们将改为生成方波。[图 12-5](chapter12.xhtml#fig12-5)展示了方波一个周期的波形。
- en: '![](../images/Figure_12-5.png)'
  id: totrans-58
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/Figure_12-5.png)'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 12-5: A square wave</samp>'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">图 12-5：方波</samp>
- en: Notice that a square wave has abrupt transitions between amplitude values, instead
    of the smooth curves of a sine wave. The code change to switch to a square wave
    oscillator is shown in [Listing 12-6](#Lis12-6).
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，方波的幅度值之间有突变的过渡，而不像正弦波那样有平滑的曲线。切换到方波振荡器的代码更改显示在[清单 12-6](#Lis12-6)中。
- en: '[PRE5]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 12-6: Changing the
    oscillator type to a square wave</samp>'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">清单 12-6：将振荡器类型更改为方波</samp>
- en: When you reload the code in your browser, you should hear a very different tone.
    The square wave is louder and brighter than the sine wave. Some other values you
    can try out for the oscillator type are "triangle" and "sawtooth". [Figure 12-6](chapter12.xhtml#fig12-6)
    shows the waveforms of these two.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 当你在浏览器中重新加载代码时，你应该能听到一个非常不同的音调。方波比正弦波更响亮、更明亮。你还可以尝试一些其他的振荡器类型，如“triangle”（三角波）和“sawtooth”（锯齿波）。[图
    12-6](chapter12.xhtml#fig12-6)展示了这两种波形。
- en: '![](../images/Figure_12-6.png)'
  id: totrans-64
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/Figure_12-6.png)'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 12-6: Sawtooth and triangle
    waves</samp>'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">图 12-6：锯齿波和三角波</samp>
- en: Think about how these other oscillator types differ from "sine" and "square".
    The distinctive sound of each oscillator is known as its *color*, or *timbre*.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 想一想这些其他振荡器类型与“正弦波”和“方波”有什么不同。每种振荡器独特的声音被称为它的*音色*或*音质*。
- en: Next, let’s try changing the envelope. We intentionally used a very basic envelope
    in [Listing 12-5](#Lis12-5) to match the Web Audio API example from [Listing 12-3](#Lis12-3),
    which had no envelope. Now we’ll set those values to something that sounds a little
    more musical, as shown in [Listing 12-7](#Lis12-7).
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们尝试改变包络。我们故意在[清单 12-5](#Lis12-5)中使用了一个非常基础的包络，以匹配[清单 12-3](#Lis12-3)中的
    Web 音频 API 示例，该示例没有包络。现在我们将这些值设置为听起来更有音乐感的值，如[清单 12-7](#Lis12-7)所示。
- en: '[PRE6]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 12-7: Changing the
    oscillator type to a square wave</samp>'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">清单 12-7：将振荡器类型更改为方波</samp>
- en: The values of attack, decay, and release are all given in seconds, while sustain
    is a number between 0 and 1 representing the amplitude level to be sustained at.
    Here we’re setting attack to 0.8 seconds, decay to 0.3 seconds, sustain to 0.8,
    and release to a whole second. When you reload the page and play the sound, you
    should hear the note slowly fade in to its max volume, then slightly reduce. After
    two seconds, the note is released and fades out over a second.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 攻击、衰减和释放的数值都是以秒为单位，而持续时间则是一个介于0和1之间的数值，表示要持续的音量水平。这里我们将攻击设置为0.8秒，衰减为0.3秒，持续时间为0.8，释放时间为1秒。当你重新加载页面并播放声音时，你应该会听到音符逐渐达到最大音量，然后稍微减小。两秒后，音符被释放并在一秒钟内逐渐消失。
- en: The final parameter to play with is the volume. As I explained earlier, every
    time you subtract 6 dB, the level is halved, and when you add 6 dB, it’s doubled.
    Try out some different values here, for example, –12, –18, or –24. You can also
    go the other way, up to 0 dB.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 最后的参数是音量。如我之前所解释的，每次减少6 dB，音量就会减半，而增加6 dB时，音量会翻倍。可以尝试一些不同的数值，例如–12、–18或–24。你也可以反向调整，直到0
    dB。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Playing More Notes
    in Sequence</samp>
  id: totrans-72
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">顺序播放多个音符</samp>
- en: Our synthesizer is currently playing only a single note, but we can easily play
    more notes. Note frequencies in Tone.js can be given in Hz or with note names,
    like A4, as we did in [Listing 12-5](#Lis12-5). These note names correspond to
    keys on a keyboard, as shown in [Figure 12-7](chapter12.xhtml#fig12-7).
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的合成器当前只播放一个音符，但我们可以轻松播放更多音符。Tone.js中的音符频率可以用赫兹（Hz）表示，也可以用音符名称表示，像我们在[清单12-5](#Lis12-5)中做的那样。这些音符名称对应于键盘上的键，如[图12-7](chapter12.xhtml#fig12-7)所示。
- en: '![](../images/Figure_12-7.png)'
  id: totrans-74
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/Figure_12-7.png)'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 12-7: Note names on
    a keyboard</samp>'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">图12-7：键盘上的音符名称</samp>
- en: C4 is known as *middle C* and is located near the middle of most piano keyboards.
    Each octave on the keyboard from each C to the B above is given a number. For
    example, the leftmost key in [Figure 12-7](chapter12.xhtml#fig12-7) is C3, and
    an octave above that is C4\. As mentioned previously, 440 Hz corresponds to A4,
    which is the A above C4\. The black notes are known as *accidentals* and are a
    semitone higher than the key to their left, or a semitone lower than the key to
    their right. For example, the black key to the right of C4 can be called C♯4 or
    D♭4 (♯ is the symbol for *sharp*, meaning a semitone higher, while ♭ is the symbol
    for *flat*, meaning a semitone lower). When writing note names in Tone.js, we
    use a hash mark (#) for sharp and the letter b for flat.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: C4被称为*中音C*，它位于大多数钢琴键盘的中央。每个音阶的C到上方的B都有一个编号。例如，[图12-7](chapter12.xhtml#fig12-7)中最左边的键是C3，而它上方的一个八度就是C4。如前所述，440
    Hz对应A4，它是C4上的A。黑键被称为*变音*，它们比左侧的键高一个半音，或者比右侧的键低一个半音。例如，C4右侧的黑键可以叫做C♯4或D♭4（♯是*升音*的符号，表示比左边的音高一个半音，而♭是*降音*的符号，表示比右边的音低一个半音）。在Tone.js中书写音符名称时，我们使用井号（#）表示升音，字母b表示降音。
- en: <samp class="SANS_Dogma_OT_Bold_B_21">NOTE</samp>
  id: totrans-77
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: <samp class="SANS_Dogma_OT_Bold_B_21">注意</samp>
- en: '*There are no black keys between B and C or E and F because these notes are
    only a semitone apart.*'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: '*B和C之间、E和F之间没有黑键，因为这两个音符之间只有一个半音的距离。*'
- en: We’re going to play a major scale from A3 to A4, which consists of the notes
    A3, B3, C♯4, D4, E4, F♯4, G♯4, and A4\. Update your *script.js* to include the
    code in [Listing 12-8](#Lis12-8) to implement this scale.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从A3到A4播放一个大调音阶，包括A3、B3、C♯4、D4、E4、F♯4、G♯4和A4。更新你的*script.js*，将[清单12-8](#Lis12-8)中的代码包含进去，实现这个音阶。
- en: '[PRE7]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 12-8: Playing a scale</samp>'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">清单12-8：播放音阶</samp>
- en: This is very similar to [Listing 12-5](#Lis12-5), except that we’re triggering
    multiple notes, one after the other. Notice we’ve updated the envelope to have
    a shorter attack and release ❶. The release, in particular, needs to be shorter
    so the end of each note doesn’t overlap with the start of the next.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 这与[清单12-5](#Lis12-5)非常相似，不同之处在于我们依次触发多个音符。请注意，我们已更新了包络线，使其具有较短的攻击和释放时间❶。尤其是释放时间需要更短，以免每个音符的结束与下一个音符的开始重叠。
- en: As I mentioned earlier, the second argument to triggerAttackRelease is the duration
    of the note in seconds, and the third argument is the time at which to play the
    note, also in seconds. The first note, A3, is played for 0.9 seconds, starting
    at time zero (that is, immediately). The 0.1-second release happens after the
    0.9-second duration, so each note will play for 1 second in total. The next note,
    B3, has the same duration, but the third argument of 1 means it will start a second
    later than the first note. The third note is programmed to start two seconds later
    than the first note, and so on for the rest of the notes. Play this in your browser,
    and you should hear a single octave of an A major scale.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我之前提到的，triggerAttackRelease的第二个参数是音符的持续时间，单位为秒，第三个参数是播放音符的时间，也是秒。第一个音符A3的持续时间为0.9秒，从时间零开始（也就是立即播放）。0.1秒的释放发生在0.9秒的持续时间之后，所以每个音符总共会播放1秒。下一个音符B3有相同的持续时间，但第三个参数1意味着它会比第一个音符晚1秒开始。第三个音符被设置为比第一个音符晚2秒开始，依此类推。把这个代码放到浏览器中运行，你应该会听到一个A大调音阶的单个八度。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Playing Multiple
    Notes at Once</samp>
  id: totrans-84
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">同时演奏多个音符</samp>
- en: The synthesizer we’ve been using so far is a *monophonic synth*, meaning it
    can play only a single note at a time. To play multiple notes at once, we’ll need
    to create a *polyphonic synth* instead. In [Listing 12-9](#Lis12-9), we update
    the code to create a new polyphonic synth and play two or three notes at a time.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 我们到目前为止使用的合成器是一个*单音合成器*，意味着它一次只能播放一个音符。为了同时演奏多个音符，我们需要创建一个*多音合成器*。在[示例 12-9](#Lis12-9)中，我们更新了代码，创建了一个新的多音合成器，并同时播放两个或三个音符。
- en: '[PRE8]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 12-9: Creating and
    playing a polyphonic synth</samp>'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">示例 12-9：创建和演奏一个多音合成器</samp>
- en: 'Here we call new Tone.PolySynth instead of new Tone.Synth to create a polyphonic
    synth object. The Tone.PolySynth constructor takes two arguments: a monophonic
    synth (in this case, Tone.Synth) and an object with the options that would normally
    be passed to that monophonic synth’s constructor (in this case, the same synth
    options we passed to the Tone .Synth constructor in [Listing 12-8](#Lis12-8)).
    The polysynth then creates multiple monophonic synths with the specified settings,
    effectively allowing it to play multiple notes at once.'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们调用 new Tone.PolySynth 而不是 new Tone.Synth 来创建一个多音合成器对象。Tone.PolySynth 构造函数接受两个参数：一个单音合成器（在本例中是
    Tone.Synth）和一个对象，其中包含通常传递给该单音合成器构造函数的选项（在本例中，是我们在[示例 12-8](#Lis12-8)中传递给 Tone.Synth
    构造函数的相同选项）。然后，polySynth 会创建多个具有指定设置的单音合成器，从而使它能够同时播放多个音符。
- en: Next, we play the same scale, but with additional simultaneous notes. This is
    achieved by passing an array of note names to the triggerAttackRelease method
    instead of a single note name—for example, we pass the array ["A3", "C#4"] to
    play A3 and C♯4 at the same time. By default, you can play a maximum of 32 notes
    with a polysynth.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们演奏相同的音阶，但加入了额外的同时音符。这是通过将音符名称数组传递给triggerAttackRelease方法实现的，而不是传递单个音符名称——例如，我们传递数组["A3",
    "C#4"]来同时演奏A3和C♯4。默认情况下，你可以通过多音合成器播放最多32个音符。
- en: When you play this example, you should hear a harmonized scale with a nice major
    chord at the end.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 当你播放这个例子时，你应该听到一个和声音阶，最后有一个漂亮的大三和弦。
- en: <samp class="SANS_Futura_Std_Bold_B_11">The Tone.js Transport</samp>
  id: totrans-91
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">Tone.js Transport</samp>
- en: Now that you’ve learned how to play notes, let’s look at how to make songs.
    Although you could program a whole song by specifying the timing of every single
    note, as you did to play a scale in the last few examples, this technique quickly
    gets tedious. Fortunately, Tone.js has a concept called the *transport* that makes
    writing songs much easier. The transport keeps track of the current position in
    the song, as measured in bars and beats. This lets you schedule notes to play
    at certain points in the song in a musically intuitive way. The transport also
    allows you to have looped sequences of notes that start playing at a certain point
    along the transport and repeat over and over until you tell them to stop.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经学会了如何演奏音符，让我们来看一下如何创作歌曲。尽管你可以像在前几个例子中演奏音阶时那样，通过指定每个音符的时间来编程一整首歌，但这种方式很快会变得枯燥乏味。幸运的是，Tone.js
    有一个叫做*transport*的概念，它让编写歌曲变得更加容易。transport 会跟踪歌曲当前的位置，按小节和拍子来衡量。这使得你可以以音乐直观的方式安排音符在歌曲中的某些时刻播放。transport
    还允许你拥有循环的音符序列，这些音符在 transport 上的某个点开始播放，并重复直到你告诉它们停止。
- en: Western music tends to be structured around bars and beats, and it’s most common
    to have four beats in a bar. The speed of the music is given in *beats per minute
    (BPM)*, and in our examples we’ll be using the default Tone.js BPM of 120, which
    means a beat every 0.5 seconds. Beats are also known as *quarter notes* (because
    when there are four beats in a bar, one beat is a quarter of a bar). *Eighth notes*
    are half the duration of a quarter note, and *sixteenth notes* are half the duration
    of an eighth note, so there are four sixteenth notes per quarter note.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 西方音乐通常围绕小节和节拍构建，最常见的是每小节有四拍。音乐的速度以*每分钟节拍数（BPM）*来表示，在我们的示例中，我们将使用Tone.js的默认BPM值120，这意味着每个节拍持续0.5秒。节拍也被称为*四分音符*（因为每小节有四拍，一拍是小节的四分之一）。*八分音符*的时值是四分音符的一半，*十六分音符*的时值是八分音符的一半，因此每个四分音符包含四个十六分音符。
- en: Positions along the transport are given as strings of three numbers separated
    by colons, like "0:0:0". The three numbers correspond to the current bar number,
    the current beat within that bar, and the current sixteenth note within that beat,
    respectively. Everything is zero-indexed. This means, for example, that "0:0:0"
    represents the beginning of the first bar, "1:1:0" represents the second beat
    of the second bar, and "6:3:2" refers to the third sixteenth note of the fourth
    beat in the seventh bar. We refer to these strings as *bars:quarters:sixteenths
    notation*.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: transport中的位置表示为由冒号分隔的三个数字字符串，类似“0:0:0”。这三个数字分别对应当前的小节号、该小节内的当前节拍和该节拍内的当前十六分音符。所有的计数都是从零开始的。例如，“0:0:0”表示第一小节的开始，“1:1:0”表示第二小节的第二拍，而“6:3:2”表示第七小节第四拍的第三个十六分音符。我们将这些字符串称为*bars:quarters:sixteenths表示法*。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Tone.Loop</samp>
  id: totrans-95
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Tone.Loop</samp>
- en: The Tone.js transport gives us an easy way to define musical loops, including
    when they start and when they finish. The simplest of these, Tone.Loop, defines
    a way to constantly produce new notes. Let’s try that out by playing a single
    note repeatedly every quarter note for four bars. Modify *script.js* with the
    code in [Listing 12-10](#Lis12-10).
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: Tone.js的transport为我们提供了一种简单的方法来定义音乐循环，包括它们的开始和结束时间。其中最简单的是Tone.Loop，它定义了一种持续不断地产生新音符的方法。我们通过每个四分音符重复播放一个音符，持续四个小节来尝试这一点。修改*script.js*，加入[Listing
    12-10](#Lis12-10)中的代码。
- en: '[PRE9]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 12-10: Looping</samp>'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 12-10: 循环</samp>'
- en: We start by creating a simple synth ❶. Notice we aren’t passing an object to
    define the oscillator, envelope, or volume options, so the synth will be created
    using the library’s default settings. Next, we create a new instance of Tone.Loop
    ❷, which has a constructor with two arguments. The first argument is some function
    that requires a time value, and the second argument is a duration indicating how
    often to call the function in the first argument. In this case, we pass the string
    "4n" as the second argument, which is Tone.js’s notation for a quarter note (“4n”
    is short for “1/4 note”). This means the loop will repeat every beat.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从创建一个简单的合成器开始❶。注意，我们并没有传递一个对象来定义振荡器、包络或音量选项，因此合成器将使用库的默认设置创建。接下来，我们创建了Tone.Loop的新实例❷，它的构造函数有两个参数。第一个参数是一个需要时间值的函数，第二个参数是一个表示调用第一个参数中函数的频率的持续时间。在这种情况下，我们传递了字符串“4n”作为第二个参数，这是Tone.js表示四分音符的符号（“4n”是“1/4
    note”的简写）。这意味着循环会在每个节拍时重复。
- en: <samp class="SANS_Dogma_OT_Bold_B_21">NOTE</samp>
  id: totrans-100
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: <samp class="SANS_Dogma_OT_Bold_B_21">注意</samp>
- en: '*In our earlier listings we were passing numbers for durations, which give
    the duration in seconds. The advantage of using note length durations like "4n"
    for a quarter note or "16n" for a sixteenth note is that they will scale automatically
    if we change the BPM. For example, doubling the BPM will halve the duration of
    each quarter note.*'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: '*在我们之前的列表中，我们传递了表示持续时间的数字，这些数字表示秒数。使用类似“4n”表示四分音符或“16n”表示十六分音符的音符时值的优势在于，如果我们改变BPM，它们会自动缩放。例如，将BPM加倍会将每个四分音符的持续时间减半。*'
- en: The body of the callback function we pass to Tone.Loop calls the triggerAttackRelease
    method on the synth to play the note C4 with a sixteenth note duration ❸. The
    third argument of the triggerAttackRelease method, time, represents the time to
    play a note. The Tone.Loop object will provide a new time value whenever it calls
    the callback function, filling it in with the appropriate location on the transport.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 我们传递给 Tone.Loop 的回调函数的主体调用了合成器上的 triggerAttackRelease 方法，播放 C4 音符，时值为十六分音符 ❸。triggerAttackRelease
    方法的第三个参数 time 表示播放音符的时间。每次 Tone.Loop 调用回调函数时，它都会提供一个新的时间值，并根据传输位置填充它。
- en: 'Finally, we call the start and stop methods on the loop returned by the Tone.Loop
    constructor ❹, passing the time when we want this loop to start and when we want
    it to stop, followed by a call to Tone.Transport.start, which starts the transport
    playing from the beginning. We start at "0:0:0", the beginning of the first bar,
    and stop at "4:0:0", the beginning of the fifth bar, meaning that this snippet
    will last four full bars with four beats each. Our loop repeats at every beat,
    playing one note each time, so we’ll play a total of 16 notes. Try reloading the
    page and see! You can use the musician’s trick of counting bars and beats like
    this: “*one* two three four, *two* two three four, *three* two three four, *four*
    two three four.” Notice that Tone.js doesn’t play a seventeenth note at time location
    "4:0:0" because the end of the loop isn’t inclusive.'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们对 Tone.Loop 构造函数返回的循环调用 start 和 stop 方法 ❹，并传递我们希望这个循环开始和停止的时间，随后调用 Tone.Transport.start，开始从头播放传输。我们从
    "0:0:0"（第一小节的开始）开始，直到 "4:0:0"（第五小节的开始）停止，这意味着这个片段将持续四个完整的小节，每个小节四拍。我们的循环在每一拍上重复，播放一个音符，因此我们将播放
    16 个音符。试着重新加载页面看看！你可以像这样使用音乐家的技巧来数小节和拍子：“*一*二三四，*二*二三四，*三*二三四，*四*二三四。”请注意，Tone.js
    不会在时间位置 "4:0:0" 播放第十七个音符，因为循环的结束不包括该时刻。
- en: '[Listing 12-11](#Lis12-11) shows an alternative way of creating the same loop
    we wrote in [Listing 12-10](#Lis12-10). This time we chain the start and stop
    methods directly to the Tone.Loop constructor.'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 12-11](#Lis12-11) 显示了一种替代方式，用来创建我们在 [示例 12-10](#Lis12-10) 中编写的相同循环。这次我们将
    start 和 stop 方法直接链到 Tone.Loop 构造函数上。'
- en: '[PRE10]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 12-11: Looping with
    fewer lines of code</samp>'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">示例 12-11: 使用更少的代码行进行循环</samp>'
- en: With this notation, we don’t need to create a variable to hold the Tone .Loop
    object, and we save a few lines of code by chaining the start and stop methods.
    We’ll be using this pattern in the rest of this section.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这种表示法，我们无需创建一个变量来保存 Tone.Loop 对象，并且通过链式调用 start 和 stop 方法，节省了几行代码。在本节的其余部分，我们将使用这种模式。
- en: Tone.Loop is basic, but it’s also quite versatile. You can run any arbitrary
    code in the callback, so you can do more than play the same note over and over.
    For example, you could choose to play a new random note each time. [Listing 12-12](#Lis12-12)
    shows how you could generate a short piece of music by randomly playing notes
    from a pentatonic, or five-note, scale (I chose a pentatonic scale here because
    any combination of notes in a pentatonic scale tends to sound pleasing).
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: Tone.Loop 基本，但也非常灵活。你可以在回调中运行任何任意代码，因此你可以做的不仅仅是重复播放相同的音符。例如，你可以选择每次播放一个新的随机音符。[示例
    12-12](#Lis12-12) 展示了如何通过随机播放五声音阶（或五个音符的音阶）中的音符来生成一段简短的音乐（我在这里选择五声音阶，因为五声音阶中的任何音符组合往往都很和谐）。
- en: '[PRE11]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 12-12: Using Tone.Loop
    to generate random music</samp>'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">示例 12-12: 使用 Tone.Loop 生成随机音乐</samp>'
- en: For this example, we’re switching to a polysynth ❶ so we can play multiple notes
    at once. The notes array contains one octave of a C major pentatonic scale, including
    the C from the next octave ❷. Inside the Tone .Loop callback, we use a for loop
    to run some code three times. Each time around, we call Math.random() ❸, which
    returns a random number between 0 and 1, to determine whether to play a note or
    not. If the value is less than 0.5, we play a note. Otherwise, that note is skipped.
    The note name is determined by picking a random index into the notes array, using
    the code Math .floor(Math.random() * notes.length) ❹.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个示例，我们切换到一个多音色合成器❶，这样我们就可以同时演奏多个音符。音符数组包含一个C大调五声音阶的一个八度，包括下一个八度的C❷。在Tone.Loop的回调函数中，我们使用一个for循环来执行一些代码三次。每次循环时，我们调用`Math.random()`❸，它返回一个0到1之间的随机数，用来决定是否播放一个音符。如果值小于0.5，我们播放一个音符。否则，跳过这个音符。音符的名称通过在音符数组中随机选择一个索引来确定，使用代码`Math.floor(Math.random()
    * notes.length)`❹。
- en: The Tone.Loop object calls this code every eighth note ("8n") for eight bars
    ("0:0:0" to "8:0:0"). The effect of all this is that every eighth note, up to
    three notes from the array will be played (there’s no guarantee of uniqueness,
    so the same note could be played two or three times at once, causing that note
    to be louder). For each of the three notes, there’s a one in two chance it will
    be played, so overall there’s a one in eight chance that no notes will be played
    on any given eighth note.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: Tone.Loop对象每隔一个八分音符（"8n"）调用这段代码，持续八小节（从"0:0:0"到"8:0:0"）。所有这些的效果是，每个八分音符时，最多会从数组中播放三个音符（没有唯一性的保证，所以相同的音符可能会被播放两次或三次，导致这个音符更响亮）。对于每个音符，它有一半的机会被播放，所以总体上，在任何给定的八分音符上，没有音符被播放的机会是八分之一。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Tone.Sequence</samp>
  id: totrans-113
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Tone.Sequence</samp>
- en: 'In this section we’ll look at another Tone.js helper, called Tone.Sequence.
    This lets you provide a list of note names to be scheduled to play at regular
    intervals. You can repeat the whole sequence as many times as you want. As an
    example, we’ll create a repeating pattern of four notes: a G4 followed by three
    C4s. Update *script.js* with the code in [Listing 12-13](#Lis12-13).'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一节中，我们将介绍另一个Tone.js的辅助工具，叫做Tone.Sequence。它允许你提供一个音符名称列表，这些音符将在固定的时间间隔内被安排播放。你可以根据需要重复整个序列。作为示例，我们将创建一个四个音符的重复模式：一个G4，后面跟着三个C4。使用[Listing
    12-13](#Lis12-13)中的代码更新*script.js*。
- en: '[PRE12]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 12-13: Creating a repeating
    sequence with Tone.Sequence</samp>'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 12-13: 使用Tone.Sequence创建一个重复的序列</samp>'
- en: This is very similar to our first Tone.Loop example ([Listing 12-10](#Lis12-10)),
    but with two important changes. First, the callback function takes two arguments,
    time and note ❶, instead of a single time argument. Second, there’s an extra argument
    after the callback, which contains a list of notes ❷. Each time the callback is
    called, the next note in this list is passed as the note argument. It will keep
    cycling through the notes in the list over and over until it’s time to stop. The
    third argument to Tone.Sequence gives the duration between each callback ❸. In
    this case we’ve used "4n", which means that a new note will be played every quarter
    note.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 这与我们的第一个Tone.Loop示例非常相似([Listing 12-10](#Lis12-10))，但有两个重要的变化。首先，回调函数接受两个参数，`time`和`note`❶，而不是一个`time`参数。其次，在回调函数之后有一个额外的参数，它包含一个音符列表❷。每次调用回调时，下一个音符会作为`note`参数传递。它将不断循环播放列表中的音符，直到停止。Tone.Sequence的第三个参数给出了每次回调之间的持续时间❸。在这种情况下，我们使用了"4n"，意味着每次四分音符都会播放一个新的音符。
- en: 'When you run this example, you should hear a pattern play for 4 bars, with
    4 beats per bar, making 16 notes in total. If we wrote out all the calls to synth.triggerAttackRelease
    manually, instead of relying on Tone.Sequence to automate them, they would look
    like this:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 当你运行这个示例时，你应该会听到一个模式演奏4小节，每小节4拍，总共16个音符。如果我们手动写出所有调用`synth.triggerAttackRelease`的代码，而不是依赖Tone.Sequence来自动化它们，它们应该是这样的：
- en: '[PRE13]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Here, I’ve just replaced the note and time arguments with what they would actually
    be for the first six calls of the callback. Notice how the second number is incrementing
    in the bars:quarters:sixteenths notation because of the "4n" we used as the duration
    between callbacks. (In practice, however, Tone.Sequence passes time as a number
    of seconds rather than using bars:quarters:sixteenths notation.)
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我只是将音符和时间参数替换为回调函数前六次调用时的实际值。注意，由于我们在回调之间使用了 "4n" 作为时值，第二个数字在小节:拍:十六分音符的表示法中是递增的。（但在实践中，Tone.Sequence
    传递的时间是以秒为单位，而不是使用小节:拍:十六分音符的表示法。）
- en: If you want a sequence with some silent gaps (*rests* in musical terms), you
    can use null in place of a note name in the array of note names. Modify *script.js*
    with the code in [Listing 12-14](#Lis12-14) to see this in action.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你希望有一个包含一些静默间隙（音乐术语中的*休止符*）的序列，你可以在音符名称数组中使用 null 代替音符名称。通过修改 *script.js*，并使用
    [清单 12-14](#Lis12-14) 中的代码，可以看到这个效果。
- en: '[PRE14]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 12-14: Adding rests
    with</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">null</samp>'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">清单 12-14：使用 null 添加休止符</samp>
- en: Now we have a longer sequence of notes, with some nulls interspersed to insert
    pauses into the sequence. We’ve also changed the duration from "4n" to "8n", which
    means the notes will play twice as fast as before. When you play this updated
    example, you should hear a more interesting sequence of notes, including some
    rests.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了一个更长的音符序列，其中插入了一些空值来在序列中插入暂停。我们还将时值从 "4n" 改为 "8n"，这意味着音符的播放速度将是之前的两倍。当你播放这个更新后的示例时，你应该能听到一个更有趣的音符序列，包括一些休止符。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Tone.Part</samp>
  id: totrans-125
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Tone.Part</samp>
- en: The last of the transport helpers we’ll be looking at is Tone.Part. This is
    the most flexible of the helpers, as it allows us to specify the exact timing
    of every note played. With Tone.Part, instead of passing an array of note names,
    we pass an array of time/note pairs. For example, [["0:0:0", "C4"], ["0:1:0",
    "D4"], ["0:1:2", "E4"]] would play the three notes C4, D4, and E4 at the three
    times specified. This way, unlike with Tone.Loop and Tone.Sequence, the notes
    don’t have to be played at equal time intervals. Also, by default Tone.Part doesn’t
    loop, so the sequence of notes in the array is played only once. See the code
    in [Listing 12-15](#Lis12-15) for an example.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将要看的最后一个传输辅助工具是 Tone.Part。它是最灵活的辅助工具，因为它允许我们精确指定每个音符的播放时间。使用 Tone.Part 时，我们传递的是一个时间/音符对的数组，而不是音符名称数组。例如，
    [["0:0:0", "C4"], ["0:1:0", "D4"], ["0:1:2", "E4"]] 将会在指定的三个时间播放 C4、D4 和 E4 这三个音符。这样，与
    Tone.Loop 和 Tone.Sequence 不同，音符不必在相等的时间间隔内播放。此外，Tone.Part 默认不会循环，因此数组中的音符序列只会播放一次。请查看
    [清单 12-15](#Lis12-15) 中的代码示例。
- en: '[PRE15]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 12-15: Playing a melody
    with Tone.Part</samp>'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">清单 12-15：使用 Tone.Part 播放旋律</samp>
- en: The first change we’re making here is to the synth ❶. This time we’re back to
    using a polyphonic synth, so we can play multiple notes at the same time. Other
    than the synth being different, the body of the callback function is the same.
    We’re still calling synth.triggerAttackRelease and passing the note and time parameters,
    which Tone.Part will fill in automatically. Next comes the array of time/note
    pairs. You may notice that some of the notes are arrays themselves; for example,
    the first “note” in the list is ["C3", "E4"] ❷. This pair of notes will be passed
    to the triggerAttackRelease method unchanged and will have the effect of playing
    two notes at once, just like our other polyphonic synth examples.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里做的第一个改变是合成器 ❶。这次我们回到使用多音合成器，这样我们可以同时演奏多个音符。除了合成器不同外，回调函数的主体保持不变。我们仍然调用
    synth.triggerAttackRelease 并传递音符和时间参数，这些参数会由 Tone.Part 自动填充。接下来是时间/音符对的数组。你可能会注意到其中一些音符本身是数组；例如，列表中的第一个“音符”是
    ["C3", "E4"] ❷。这一对音符将原样传递给 triggerAttackRelease 方法，并会同时播放两个音符，就像我们其他的多音合成器示例一样。
- en: Finally, we call .start("0:0:0") ❸, which has the effect of playing this part
    immediately. If we used .start("1:0:0") instead, for example, then the melody
    would start after a bar’s pause. The times given for each time/note pair are relative
    to the time passed to the start method.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们调用 .start("0:0:0") ❸，这会立即播放这一部分。如果我们使用 .start("1:0:0")，例如，那么旋律将在一个小节的暂停后开始。每对时间/音符的时间是相对于传递给
    start 方法的时间的。
- en: When you play this example, you should hear the beginning of “Mary Had a Little
    Lamb.”
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 当你播放这个例子时，你应该会听到《玛丽有只小羊》的开头部分。
- en: <samp class="SANS_Futura_Std_Bold_B_11">Making Drum Sounds</samp>
  id: totrans-132
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">制作鼓声</samp>
- en: 'Most electronic music has some kind of drum beat. The drum sounds used to make
    the beat can come from audio files, or they can be synthesized. We’re going to
    be using the latter technique here. The core of a drum beat is built around three
    components: the kick drum (a “boom” sound), the snare drum (a “bah” sound), and
    the hi-hat (a “ti” sound). In this section, you’ll learn techniques for synthesizing
    those sounds.'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数电子音乐都有某种鼓点。用来制作鼓点的鼓声可以来自音频文件，也可以通过合成产生。我们这里将使用后者技术。鼓点的核心由三个组件组成：低音鼓（“轰”声）、军鼓（“啪”声）和踩镲（“嘀”声）。在这一部分，你将学习合成这些声音的技巧。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Hi-Hat Synthesis</samp>
  id: totrans-134
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">踩镲合成</samp>
- en: A real-world hi-hat is made up of two cymbals facing each other. The top cymbal
    is connected to a pedal so the drummer can make the cymbals touch or move apart.
    We’re going for a closed (cymbals touching) sound here. When you hit closed hi-hats
    with a drum stick, they make a high-pitched noise that quickly fades away.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 现实中的踩镲由两块相对的镲片组成。上面的镲片连接到一个踏板，鼓手可以通过踏板让镲片接触或分开。我们这里要模拟的是闭合（镲片接触）的声音。当你用鼓棒击打闭合的踩镲时，它们会发出一个高频噪声，迅速消失。
- en: We’ll approximate this by using a different kind of synth, a NoiseSynth, to
    generate white noise instead of notes with pitches. In signal processing, *white
    noise* is a random signal that has equal-level components at all frequencies.
    We’ll give the NoiseSynth an amplitude envelope that simulates the abrupt attacks
    of hitting the hi-hat with a stick. Finally, we’ll pass the noise through a *filter*—a
    device that allows through some frequencies while reducing the level of others—to
    remove the low frequencies and make it sound higher and more cymbal-like.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过使用另一种合成器，NoiseSynth，来生成白噪声，而不是带有音高的音符，从而近似这个效果。在信号处理中，*白噪声*是一种所有频率上都有相等强度成分的随机信号。我们会给NoiseSynth一个幅度包络，模拟用棒子击打踩镲的突然起音。最后，我们将噪声通过一个*滤波器*—一个允许某些频率通过，同时降低其他频率的设备—来去除低频，使声音听起来更高、更像镲片。
- en: First, we’ll set up the NoiseSynth and envelope, and play the hi-hat sound in
    a loop. Update your *script.js* with the code in [Listing 12-16](#Lis12-16).
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将设置NoiseSynth和包络，并以循环的方式播放踩镲声音。使用[Listing 12-16](#Lis12-16)中的代码更新你的*script.js*。
- en: '[PRE16]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 12-16: The beginnings
    of a hi-hat sound</samp>'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 12-16: 踩镲声音的初步实现</samp>'
- en: We create a new NoiseSynth ❶, passing an amplitude envelope and a volume of
    –6 dB. The envelope has a very short attack (1/1000 of a second) and a longer
    decay (1/10 of a second), which is supposed to mimic the amplitude envelope of
    a hi-hat being struck. Because sustain and release are both set to 0, the sound
    will be over immediately after the initial attack and decay periods (0.001 + 0.1
    s). In particular, the sustain of 0 means the sound will sustain at 0 percent
    of its full volume, so even if the duration of the note is longer, you won’t hear
    anything after the attack and decay.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建一个新的NoiseSynth ❶，传入一个幅度包络和–6 dB的音量。这个包络有一个非常短的起音（1/1000秒）和一个较长的衰减（1/10秒），这模拟了打击踩镲时的幅度包络。由于延音和释放都设置为0，声音会在初始的起音和衰减之后立即结束（0.001
    + 0.1秒）。特别地，延音为0意味着声音会在其最大音量的0%时保持，因此即使音符的持续时间更长，在起音和衰减之后你也不会听到任何声音。
- en: Next, we use Tone.Loop to play a continuous stream of eighth-note hi-hats for
    four bars ❷. Note that the triggerAttackRelease method on NoiseSynth doesn’t take
    a note name, because noise doesn’t have any particular pitch. You have to specify
    only the duration and the time when the note should be played.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们使用Tone.Loop播放一个连续的八分音符踩镲声，持续四小节 ❷。注意，NoiseSynth的triggerAttackRelease方法不接受音符名称，因为噪声没有特定的音高。你只需要指定持续时间和音符应播放的时间。
- en: When you play this example, you should hear a stream of hi-hat sounds. It doesn’t
    sound great yet, because we haven’t added the filter. We’ll do that in [Listing
    12-17](#Lis12-17).
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 当你播放这个例子时，你应该会听到一连串的踩镲声音。它听起来还不太好，因为我们还没有添加滤波器。我们将在[Listing 12-17](#Lis12-17)中进行这个操作。
- en: '[PRE17]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 12-17: Applying a filter
    to the hi-hat sound</samp>'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 12-17: 对踩镲声音应用滤波器</samp>'
- en: First, we use Tone.Filter to create a *bandpass filter* ❶. This kind of filter
    lets through (“passes”) only the frequencies at or around a frequency of your
    choice. In this case, we tell the filter to pass the band of frequencies around
    15,000 Hz, or 15 kHz, while eliminating all others. The human range of hearing
    is roughly 20 Hz to 20 kHz, so our filter lets through only parts of the noise
    that are very high in pitch.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们使用 Tone.Filter 创建一个 *带通滤波器* ❶。这种滤波器只允许通过（“传递”）你选择的频率附近的频率。在本例中，我们告诉滤波器传递大约
    15,000 Hz 或 15 kHz 频率范围的信号，同时消除其他频率。人耳的听觉范围大约是 20 Hz 到 20 kHz，因此我们的滤波器只让非常高频的噪声通过。
- en: In [Listing 12-16](#Lis12-16), we used toDestination() on the NoiseSynth to
    connect it directly to the output. In [Listing 12-17](#Lis12-17), we’re instead
    connecting the filter to the output ❶, and then connecting the synth to the filter
    ❷. This means that the synth’s sound is run through the filter before being output
    through your speakers or headphones. As a result, when you play this example you
    should hear the same hi-hat sounds, but limited to high frequencies only, which
    sounds a bit more like a real hi-hat.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [清单 12-16](#Lis12-16) 中，我们使用了 toDestination() 将 NoiseSynth 直接连接到输出。在 [清单 12-17](#Lis12-17)
    中，我们则将滤波器连接到输出 ❶，然后将合成器连接到滤波器 ❷。这意味着合成器的声音在输出到扬声器或耳机之前会通过滤波器处理。因此，当你播放这个示例时，你应该听到相同的
    hi-hat 声音，但仅限于高频，这听起来更像真实的 hi-hat。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Snare Synthesis</samp>
  id: totrans-147
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">军鼓合成</samp>
- en: 'In this section we’ll synthesize a snare drum. A snare drum has a series of
    wires (known as the *snare*) resting against the bottom drumhead that rattle against
    the drumhead when the drum is hit. This gives it a relatively complex sound, composed
    of some noise and some more pitched sound. To mimic this, we’ll use two separate
    sound sources: a noise synth and a regular synth with a fixed frequency. Both
    will have a short amplitude envelope to create a percussive feel, and we’ll also
    pass the noise component of the sound through a bandpass filter to make the snare
    lower than the hi-hat. We’ll create a new Snare class to encapsulate these details,
    as shown in [Listing 12-18](#Lis12-18).'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将合成一个军鼓。军鼓有一系列的钢丝（称为 *军鼓丝*）靠在底部的鼓膜上，当鼓被击打时，这些钢丝会撞击鼓膜发出声音。这使得军鼓的声音相对复杂，由一些噪声和一些更具音调的声音组成。为了模拟这一点，我们将使用两个独立的声音源：一个噪声合成器和一个固定频率的常规合成器。两者都将有一个短暂的振幅包络，以产生打击乐的感觉，我们还将通过带通滤波器传递声音的噪声成分，以使军鼓的声音低于
    hi-hat。我们将创建一个新的 Snare 类来封装这些细节，如 [清单 12-18](#Lis12-18) 所示。
- en: '[PRE18]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 12-18: Synthesizing
    a snare drum</samp>'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">清单 12-18：合成军鼓</samp>
- en: At a high level, the Snare class has two methods, constructor and trigger AttackRelease.
    The constructor creates a filter and two synths. The trigger AttackRelease method
    calls the triggerAttackRelease methods on the two synths to play them simultaneously.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 从高层次来看，Snare 类有两个方法，构造函数和触发器 AttackRelease。构造函数创建一个滤波器和两个合成器。触发器 AttackRelease
    方法调用两个合成器上的 triggerAttackRelease 方法，以同时播放它们。
- en: In the constructor, we start by creating the filter ❶ and noise synth ❷. This
    is very similar to how we created the hi-hat, except we use a frequency of 5,000
    Hz for the bandpass filter, to reflect the lower sound of a snare drum. Next,
    we create the pitched synth ❸, which uses a similar amplitude envelope to the
    noise synth but with an even shorter attack to simulate the sound of a snare drum
    (in a real snare drum, the snares are triggered by the vibration of the drum skin,
    so they lag behind the sound of the drum slightly). The synth is configured with
    a sine wave oscillator. Since we’ll be playing the two synths simultaneously,
    we give each one a volume of –12, which results in an overall volume similar to
    the hi-hat.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 在构造函数中，我们首先创建滤波器 ❶ 和噪声合成器 ❷。这与我们创建 hi-hat 时非常相似，不同之处在于我们使用 5,000 Hz 的频率来进行带通滤波，以反映军鼓较低的声音。接下来，我们创建音调合成器
    ❸，它使用与噪声合成器类似的振幅包络，但攻击时间更短，以模拟军鼓的声音（在真实的军鼓中，军鼓丝是通过鼓皮的振动触发的，因此它们的声音会稍微滞后于鼓声）。该合成器配置为正弦波振荡器。由于我们将同时播放这两个合成器，我们给每个合成器的音量设置为
    -12，这样整体音量与 hi-hat 类似。
- en: The triggerAttackRelease method ❹ takes just a duration and a when parameter.
    These are passed to the underlying synths’ triggerAttackRelease methods. When
    we trigger the pitched synth, we give it a note name of "G3", which is the pitch
    I decided to tune the snare to. The inclusion of the pitched synth is subtle but
    makes the drum sound a bit more realistic.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: triggerAttackRelease 方法 ❹ 只接受持续时间和触发时间参数。这些参数会传递给底层合成器的 triggerAttackRelease
    方法。当我们触发带音高的合成器时，我们给它一个 "G3" 的音符名，这个音符是我决定用来调小军鼓的音高。加入带音高的合成器非常微妙，但能让鼓声听起来更为真实。
- en: Next, we instantiate the class ❺, and finally we create a new Tone.Loop object
    ❻. This loop is four times as long as the hi-hat loop ("2n" instead of "8n", or
    a half note instead of an eighth note) and starts after one quarter note. This
    means there will be a snare hit on the second and fourth beats of every bar. When
    you play this example, you should hear the hi-hat every eighth note and the snare
    every two quarter notes.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们实例化类 ❺，最后创建一个新的 Tone.Loop 对象 ❻。这个循环是高帽子循环的四倍长（"2n" 而不是 "8n"，即半音符而不是八分音符），并且在一个四分音符后开始。这意味着每小节的第二拍和第四拍会有小军鼓的击打。当你播放这个例子时，你应该能听到每个八分音符有高帽子，每两个四分音符有小军鼓。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Kick Synthesis</samp>
  id: totrans-155
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">踢鼓合成</samp>
- en: The last drum sound to synthesize is the kick drum. A kick drum is much larger
    than a snare drum, and it doesn’t have the rattling snare to make it sound noisy.
    The sound of a kick drum is fairly complex, but luckily Tone.js has a synth called
    a MembraneSynth that mimics it quite well. This synth takes a regular oscillator
    and lowers its frequency over a short period of time, which ends up sounding a
    lot like a kick drum when set up correctly. [Listing 12-19](#Lis12-19) shows how
    this is done.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 最后需要合成的鼓声是踢鼓。踢鼓比小军鼓大得多，并且没有像小军鼓那样的颤动声，使其声音更加嘈杂。踢鼓的声音相当复杂，但幸运的是，Tone.js 有一个名为
    MembraneSynth 的合成器，它能够很好地模拟踢鼓的声音。这个合成器使用一个常规振荡器，并在短时间内降低其频率，设置正确时最终听起来非常像踢鼓。[列表
    12-19](#Lis12-19)展示了如何做到这一点。
- en: '[PRE19]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 12-19: Synthesizing
    a kick drum</samp>'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">列表 12-19：合成踢鼓</samp>
- en: The options for the MembraneSynth include pitchDecay ❶, which specifies in seconds
    how quickly the frequency should change, and octaves, which specifies how many
    octaves to drop the frequency in that time. In our loop ❷, we trigger the synth
    with a frequency of 50 Hz. This loop has the same "2n" duration as the snare loop,
    but starting at time zero, which means that the kick and snare sounds will alternate
    every quarter note, giving a classic rock drum beat. When you play this example,
    you might recognize it as the basic drum pattern of a lot of songs.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: MembraneSynth 的选项包括 pitchDecay ❶，它指定频率变化的速度，以秒为单位，并且包括 octaves，它指定在这段时间内频率下降多少个八度。在我们的循环
    ❷ 中，我们以 50 Hz 的频率触发合成器。这个循环与小军鼓循环有相同的 "2n" 持续时间，但从零时刻开始，这意味着踢鼓和小军鼓的声音将每四分音符交替一次，呈现经典摇滚鼓点。当你播放这个例子时，你可能会认出它是很多歌曲的基本鼓点模式。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Reverb</samp>
  id: totrans-160
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">混响</samp>
- en: '*Reverb* (short for *reverberation*) is an effect that makes music sound like
    it’s being played in a room or larger enclosed space. The random echoes that real-world
    sounds make as they bounce around the walls of a room are what give this reverb
    effect. Reverb makes each sound take a little time to die away, and it will make
    our drums sound a bit more realistic. We can add reverb with Tone.Reverb, as you’ll
    see in [Listing 12-20](#Lis12-20).'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: '*混响*（即 *reverberation*）是一种效果，使得音乐听起来像是在一个房间或更大的封闭空间内播放。真实世界的声音在房间的墙壁上反弹时产生的随机回声，便是这种混响效果的来源。混响使得每个声音在消失时需要一点时间，这会让我们的鼓声听起来更真实。我们可以通过
    Tone.Reverb 添加混响，正如你在[列表 12-20](#Lis12-20)中看到的那样。'
- en: '[PRE20]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 12-20: Adding reverb</samp>'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">列表 12-20：添加混响</samp>
- en: First we create our Reverb effect. The decay setting describes how long (in
    seconds) the reverberation will continue after the sound stops. The higher this
    number, the more echoey the effect. The wet setting specifies how much of the
    reverb sound is passed through compared with the original sound. In this case,
    0.3 means that the output of this effect will be 30 percent reverb and 70 percent
    the original sound. The higher the wet setting, the more prominent the reverb
    effect will be.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们创建我们的混响效果。衰减设置描述了声音停止后混响将持续多久（以秒为单位）。这个数值越高，效果就越有回音。wet 设置指定了通过的混响声音与原始声音的比例。在这种情况下，0.3
    表示该效果的输出将是 30% 的混响和 70% 的原始声音。wet 设置越高，混响效果就越突出。
- en: The rest of the changes in [Listing 12-20](#Lis12-20) replace any instances
    of toDestination() with connect(reverb). This way all the drum sounds are passed
    through the reverb effect before the reverb effect is sent to the output. When
    you play this example, the drums should sound more like they’re being played in
    a room. You can make the effect more pronounced by increasing the value of wet
    (to 0.6, say) or by increasing the decay in the Tone.Reverb settings.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: '[清单 12-20](#Lis12-20) 中的其他更改将所有的 toDestination() 替换为 connect(reverb)。这样，所有的鼓声都将通过混响效果，然后将混响效果发送到输出。当你播放这个示例时，鼓声应该听起来像是在一个房间里演奏的。你可以通过增加
    wet 的值（例如设置为 0.6）或者增加 Tone.Reverb 设置中的衰减来使效果更加明显。'
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">A Drum Loop</samp>
  id: totrans-166
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">鼓循环</samp>
- en: 'Now that we have our drum sounds set up, it would be nice to have an easier
    way to trigger them. Ideally, we would want to create a drum pattern by writing
    something like this:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经设置了鼓声，接下来希望能有一种更简单的方式来触发它们。理想情况下，我们希望通过编写如下内容来创建一个鼓点模式：
- en: '[PRE21]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Then we can let JavaScript do the work of converting that notation into code
    that Tone.js can understand. Here, each x represents a note, each dot (.) represents
    a silence, and each column represents an eighth note. For example, in the first
    eighth note the kick and hi-hat play, in the second only the hi-hat plays, in
    the third the snare and hi-hat play, and so on. The pattern shown here matches
    the drum beat we built up in the previous sections.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们可以让 JavaScript 处理将这些符号转换成 Tone.js 能理解的代码。在这里，每个 x 代表一个音符，每个点（.）代表一个停顿，每一列代表一个八分音符。例如，在第一个八分音符中，低音鼓和高帽一起演奏，在第二个八分音符中只有高帽演奏，在第三个八分音符中军鼓和高帽一起演奏，以此类推。这里显示的模式与我们在前面章节中构建的鼓点一致。
- en: To accomplish this, we’ll make a helper function that will convert a string
    of x’s and dots into an array of values that the Tone.Sequence transport helper
    can use. Recall that Tone.Sequence takes an array of note names and plays them
    repeatedly in sequence, with null being used for rests. Our function should convert
    dots to nulls, while leaving x’s the same.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 为了实现这一点，我们将编写一个辅助函数，将一串 x 和点转换成 Tone.Sequence 传输助手可以使用的值数组。回想一下，Tone.Sequence
    接受一个音符名称的数组并重复按顺序播放它们，使用 null 表示休止符。我们的函数应该将点转换为 null，同时保留 x 不变。
- en: <samp class="SANS_Dogma_OT_Bold_B_21">NOTE</samp>
  id: totrans-171
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: <samp class="SANS_Dogma_OT_Bold_B_21">注意</samp>
- en: '*Since drum sounds don’t have note names, any string can actually represent
    a drum hit to Tone.Sequence (we’re just using x’s for convenience). All that matters
    is that it isn’t null.*'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: '*由于鼓声没有音符名称，任何字符串实际上都可以表示 Tone.Sequence 的鼓击（我们只是为了方便使用 x）。重要的是它不能为 null。*'
- en: '[Listing 12-21](#Lis12-21) shows the definition of this function. Add it to
    your *script.js* file, before the current drum code.'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: '[清单 12-21](#Lis12-21) 显示了此函数的定义。将其添加到你的 *script.js* 文件中，放在当前的鼓声代码之前。'
- en: '[PRE22]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 12-21: The mkSequence
    helper function</samp>'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">清单 12-21: mkSequence 辅助函数</samp>'
- en: The mkSequence function takes a string like "x…x…" and converts it to an array
    of strings and nulls, like ["x", null, null, null, "x", null, null, null], which
    is the format we need for Tone.Sequence. It splits the string into an array of
    individual characters using the split method and uses the array map method to
    create a new array by calling a function for each character. If the character
    is ".", then it replaces it with a null in the new array. Otherwise, it passes
    the character through unchanged.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: mkSequence 函数接受一个像 "x…x…" 这样的字符串，并将其转换为一个字符串和 null 的数组，例如 ["x", null, null,
    null, "x", null, null, null]，这是我们为 Tone.Sequence 所需要的格式。它使用 split 方法将字符串拆分为单个字符的数组，并使用
    map 方法通过为每个字符调用一个函数来创建一个新数组。如果字符是 "."，则将其替换为 null；否则，它保持字符不变。
- en: Next, we’ll create the strings that will be passed into this function, as shown
    in [Listing 12-22](#Lis12-22). Add this code after the mkSequence function definition.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将创建传递给此函数的字符串，正如[Listing 12-22](#Lis12-22)所示。在mkSequence函数定义后添加此代码。
- en: '[PRE23]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 12-22: Defining drumPattern</samp>'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 12-22: 定义drumPattern</samp>'
- en: We’re storing the three strings in an object called drumPattern to keep them
    organized. I’ve added spaces to line up the strings so it’s easier to see the
    pattern.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将三个字符串存储在一个名为drumPattern的对象中，以保持它们的组织性。我添加了空格来对齐字符串，这样更容易看到模式。
- en: Finally, we’ll use the helper and Tone.Sequence in place of our three existing
    calls to Tone.Loop, as shown in [Listing 12-23](#Lis12-23).
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将使用helper和Tone.Sequence来替代我们之前的三个Tone.Loop调用，正如[Listing 12-23](#Lis12-23)所示。
- en: '[PRE24]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 12-23: Using mkSequence
    with Tone.Sequence</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">in place
    of Tone.Loop</samp>'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 12-23: 使用mkSequence与Tone.Sequence</samp>
    <samp class="SANS_Futura_Std_Book_Oblique_I_11">替代Tone.Loop</samp>'
- en: Here, we replace each of the Tone.Loop calls with the new Tone.Sequence calls.
    In each case we call mkSequence, passing one of the strings from our drumPattern
    object, which will create an array of x’s and nulls. The result of this call is
    passed to the Tone.Sequence helper, which we use to trigger the appropriate drum
    sounds. Again, Tone.Sequence will interpret any string, such as "x", as an appropriate
    note name for a drum hit, while the nulls represent silences. The last argument
    to Tone.Sequence, "8n", means that each dot or x in the drum pattern string represents
    an eighth note.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们用新的Tone.Sequence调用替换了每一个Tone.Loop调用。在每种情况下，我们调用mkSequence，传递我们drumPattern对象中的一个字符串，这将创建一个包含x和null的数组。此调用的结果被传递给Tone.Sequence助手，我们用它来触发相应的鼓声。同样，Tone.Sequence会将任何字符串（如"x"）解释为适合鼓点的音符名称，而null则表示静音。Tone.Sequence的最后一个参数"8n"表示鼓点模式字符串中的每个点或x代表一个八分音符。
- en: If you now reload the page, you should hear the same drum beat as before. This
    might seem like a lot of work to get the same output, but now we have a lot more
    flexibility to write different drum patterns, and we can easily modify them as
    we see fit. Try adding some extra snare or kick notes to the strings in drumPattern
    to see how it sounds.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你现在重新加载页面，你应该能听到和之前相同的鼓点。这看起来可能是为了得到相同的输出而做了很多工作，但现在我们有了更多的灵活性来编写不同的鼓点模式，并且可以根据需要轻松修改它们。试着在drumPattern中的字符串中加入一些额外的军鼓或低音鼓音符，看看效果如何。
- en: <samp class="SANS_Futura_Std_Bold_B_11">Working with Samples</samp>
  id: totrans-186
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">与样本合作</samp>
- en: 'An important part of electronic music is *sampling*: using snippets of existing
    audio to build up a new piece of music. One common technique is to modify the
    playback speed of the samples to change their pitch, so a single sample can be
    used for multiple notes. If you’ve ever sped up a recording of someone’s voice
    to make them sound high-pitched like a chipmunk, or slowed it down to make them
    sound low-pitched like a giant, it’s the same principle.'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 电子音乐的一个重要部分是*采样*：使用现有音频片段来构建一首新的音乐。一种常见的技巧是通过修改样本的播放速度来改变其音高，这样一个样本就可以用于多个音符。如果你曾经加速某人声音的录音，让他们听起来像松鼠一样高亢，或者减慢速度让他们听起来像巨人一样低沉，那就是相同的原理。
- en: Tone.js makes it easy to work with samples with the Tone.Sampler instrument.
    This instrument acts a lot like the synths we’ve seen so far, in that it has a
    triggerAttackRelease method that lets you play a certain note at a certain time.
    The difference is that instead of using an oscillator or noise generator as a
    source, it plays a snippet of an audio file, possibly pitch-shifted to the requested
    pitch.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: Tone.js通过Tone.Sampler工具使得处理样本变得容易。这个工具的作用类似于我们之前看到的合成器，因为它也有一个triggerAttackRelease方法，可以让你在某个时间播放一个特定的音符。不同之处在于，它不是使用振荡器或噪音发生器作为音源，而是播放一个音频文件的片段，可能会根据需要调整音高。
- en: 'To avoid any issues of copyright, I’ve sourced some samples from a free online
    sample database, [*https://<wbr>freesound<wbr>.org*](https://freesound.org). I’ve
    reuploaded them to Amazon S3 (Simple Storage Service) in such a way that you can
    access them directly from your code without having to download them (if you want
    to know the technical details, the files are in a public S3 bucket with CORS headers
    enabling access from any origin). The samples are of three different trumpet notes,
    and are found at the following URLs:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 为了避免版权问题，我从一个免费的在线样本数据库[*https://<wbr>freesound<wbr>.org*](https://freesound.org)获取了一些样本。我已经将它们重新上传到
    Amazon S3（简单存储服务），以便你可以直接从代码中访问它们，而不需要下载（如果你想了解技术细节，这些文件位于一个公开的 S3 桶中，并且启用了 CORS
    头部，允许从任何来源访问）。这些样本是三种不同的喇叭音符，分别位于以下 URL：
- en: '[*https://<wbr>skilldrick<wbr>-jscc<wbr>.s3<wbr>.us<wbr>-west<wbr>-2<wbr>.amazonaws<wbr>.com<wbr>/trumpet<wbr>-c5<wbr>.mp3*](https://skilldrick-jscc.s3.us-west-2.amazonaws.com/trumpet-c5.mp3)'
  id: totrans-190
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*https://<wbr>skilldrick<wbr>-jscc<wbr>.s3<wbr>.us<wbr>-west<wbr>-2<wbr>.amazonaws<wbr>.com<wbr>/trumpet<wbr>-c5<wbr>.mp3*](https://skilldrick-jscc.s3.us-west-2.amazonaws.com/trumpet-c5.mp3)'
- en: '[*https://<wbr>skilldrick<wbr>-jscc<wbr>.s3<wbr>.us<wbr>-west<wbr>-2<wbr>.amazonaws<wbr>.com<wbr>/trumpet<wbr>-d5<wbr>.mp3*](https://skilldrick-jscc.s3.us-west-2.amazonaws.com/trumpet-d5.mp3)'
  id: totrans-191
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*https://<wbr>skilldrick<wbr>-jscc<wbr>.s3<wbr>.us<wbr>-west<wbr>-2<wbr>.amazonaws<wbr>.com<wbr>/trumpet<wbr>-d5<wbr>.mp3*](https://skilldrick-jscc.s3.us-west-2.amazonaws.com/trumpet-d5.mp3)'
- en: '[*https://<wbr>skilldrick<wbr>-jscc<wbr>.s3<wbr>.us<wbr>-west<wbr>-2<wbr>.amazonaws<wbr>.com<wbr>/trumpet<wbr>-f5<wbr>.mp3*](https://skilldrick-jscc.s3.us-west-2.amazonaws.com/trumpet-f5.mp3)'
  id: totrans-192
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*https://<wbr>skilldrick<wbr>-jscc<wbr>.s3<wbr>.us<wbr>-west<wbr>-2<wbr>.amazonaws<wbr>.com<wbr>/trumpet<wbr>-f5<wbr>.mp3*](https://skilldrick-jscc.s3.us-west-2.amazonaws.com/trumpet-f5.mp3)'
- en: If you enter any of these URLs into your web browser, the sample should play
    automatically.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你将这些 URL 输入到浏览器中，样本应该会自动播放。
- en: Let’s see how to load these samples into a new Tone.Sampler object. Tone.js
    lets you load all your samples from external URLs, such as our three S3 URLs,
    which we do in [Listing 12-24](#Lis12-24). Insert the new sampler code at the
    end of *script.js*.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如何将这些样本加载到一个新的 Tone.Sampler 对象中。Tone.js 允许你从外部 URL 加载所有样本，比如我们的三个 S3 URL，我们在[列表
    12-24](#Lis12-24)中实现了这一点。将新的采样器代码插入到 *script.js* 的末尾。
- en: '[PRE25]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 12-24: Creating a sampler</samp>'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">列表 12-24：创建采样器</samp>
- en: We create the sampler by passing a configuration object to the Tone.Sampler
    constructor. In this example, the configuration object contains five properties.
    The first property, urls, contains an object mapping note names to filenames.
    For example, we’re saying that the note name C5 corresponds to the filename *trumpet-c5.mp3*.
    Next, baseUrl defines the shared prefix of all the URLs, which saves us from having
    to write out the full URL for each sample. All the URLs are in the same S3 bucket,
    so we can use that as the base URL and then just provide the filenames in urls.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过将一个配置对象传递给 Tone.Sampler 构造函数来创建采样器。在这个例子中，配置对象包含五个属性。第一个属性 urls 包含一个对象，将音符名称映射到文件名。例如，我们说音符名称
    C5 对应文件名 *trumpet-c5.mp3*。接下来，baseUrl 定义了所有 URL 的共享前缀，这样我们就不需要为每个样本编写完整的 URL。所有的
    URL 都在同一个 S3 桶中，因此我们可以使用它作为基本 URL，然后在 urls 中仅提供文件名。
- en: The sampler instrument doesn’t apply a full ADSR envelope when it plays samples,
    but it does allow you to set the attack (fade-in speed) and release (fade-out
    speed). We use an instant attack (because the sample already has its own attack),
    and a long release of one second. We also set volume to –24 dB so the sampler
    isn’t too loud. Finally, the onload property allows us to specify what happens
    once all the samples have been downloaded. In this example, we call triggerAttackRelease
    to play a three-note chord. Note that Tone.Sampler is by default polyphonic, so
    it can play multiple samples at once.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 采样器乐器在播放样本时不会应用完整的 ADSR 包络，但它确实允许你设置攻击（渐入速度）和释放（渐出速度）。我们使用即时攻击（因为样本已经有自己的攻击），并设置长达一秒的释放。我们还将音量设置为
    –24 dB，这样采样器不会太响。最后，onload 属性让我们能够指定在所有样本下载完成后发生的事情。在这个例子中，我们调用 triggerAttackRelease
    来播放一个三音符和弦。请注意，Tone.Sampler 默认是多音的，所以它可以同时播放多个样本。
- en: When you play this example, you’ll still hear the drums. Once the samples load,
    you should also hear a C major chord played by the trumpet sampler. One interesting
    thing to note here is that although we provided a sample for the note C5, we didn’t
    provide one for E5 or G5, the other pitches in the C major chord. When we tell
    the sampler to play these notes, it picks the closest provided sample and shifts
    its pitch by changing the playback speed. For instance, the closest sample to
    G5 has a pitch of F5, so this sample will be sped up slightly to sound like G5
    instead. As long as the note we’re trying to play isn’t too far away from one
    of the provided samples, it will sound fine. If we push it too far, however, the
    result won’t sound as realistic. For example, try raising the notes an octave
    by setting them to C6, E6, and G6 instead. They’ll start to sound a bit silly
    now. Also, because the samples are being played back twice as fast, they’re half
    the duration, so they won’t last the full bar they’re supposed to (the higher
    notes will finish earlier because they’re played back faster). You can also go
    the other way and set the notes to C4, E4, and G4\. This time the duration won’t
    be a problem, since the samples are being played slower in order to shift them
    down in pitch, but the notes still won’t sound as realistic.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 当你播放这个示例时，你仍然会听到鼓声。一旦样本加载完成，你还应该听到由小号采样器演奏的C大调和弦。有一点有趣的是，虽然我们提供了C5音符的样本，但我们没有提供E5或G5音符的样本，这是C大调和弦中的其他音符。当我们告诉采样器播放这些音符时，它会选择最接近的提供样本，并通过改变播放速度来调整音高。例如，最接近G5的样本是F5，所以这个样本会稍微加速播放，听起来就像G5一样。只要我们要播放的音符离提供的样本不太远，它就会听起来正常。然而，如果我们推得太远，结果就不会那么真实。例如，尝试通过将音符设置为C6、E6和G6来提高一个八度，它们现在会开始听起来有些可笑。而且，因为样本播放速度是原来的两倍，所以它们的持续时间是原来的一半，因此不会持续整个小节（因为它们播放得更快，高音的音符会更早结束）。你也可以尝试将音符设置为C4、E4和G4。这次持续时间就不是问题了，因为样本播放速度变慢以将音高调低，但音符仍然听起来不那么真实。
- en: <samp class="SANS_Futura_Std_Bold_B_11">Summary</samp>
  id: totrans-200
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">总结</samp>
- en: In this chapter you learned about making sounds and music using the Web Audio
    API, and you saw how using a library like Tone.js can make your life much easier
    by hiding a lot of the lower-level details. You also learned a lot of tricks for
    sound synthesis and sampling using the Tone.js library. If some of the musical
    details went over your head, don’t worry. The most important thing here was getting
    used to working with a new JavaScript API and library. We’ll be putting all this
    to use in the next chapter, where we’ll write an actual song using the instruments
    created in this chapter!
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一章中，你学习了如何使用Web Audio API制作声音和音乐，并且你看到通过使用像Tone.js这样的库，可以通过隐藏许多底层细节来让你的工作变得更加轻松。你还学习了许多使用Tone.js库进行声音合成和采样的技巧。如果有些音乐细节你没有完全理解，不用担心。这里最重要的是熟悉使用一个新的JavaScript
    API和库。在下一章中，我们将把这些知识付诸实践，编写一首实际的歌曲，使用本章中创建的乐器！
