- en: '**9**'
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '**9**'
- en: '**THE ROOT CAUSES OF VULNERABILITIES**'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: '**漏洞的根本原因**'
- en: This chapter describes the common root causes of security vulnerabilities that
    result from the implementation of a protocol. These causes are distinct from vulnerabilities
    that derive from a protocol’s specification (as discussed in [Chapter 7](../Text/ch07.xhtml#ch07)).
    A vulnerability does not have to be directly exploitable for it to be considered
    a vulnerability. It might weaken the security stance of the protocol, making other
    attacks easier. Or it might allow access to more serious vulnerabilities.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章描述了由协议实现引起的常见安全漏洞的根本原因。这些原因不同于源自协议规范的漏洞（如[第7章](../Text/ch07.xhtml#ch07)中所讨论）。漏洞不一定必须是可以直接利用的才算漏洞。它可能削弱协议的安全防护，使其他攻击更容易发生，或者它可能导致访问更严重的漏洞。
- en: After reading this chapter, you’ll begin to see patterns in protocols that will
    help you identify security vulnerabilities during your analysis. (I won’t discuss
    how to exploit the different classes until [Chapter 10](../Text/ch10.xhtml#ch10).)
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 阅读完这一章后，你将开始识别协议中的模式，这将帮助你在分析过程中发现安全漏洞。（我不会在本章讨论如何利用不同类别的漏洞，直到[第10章](../Text/ch10.xhtml#ch10)才会涉及。）
- en: In this chapter, I’ll assume you are investigating the protocol using all means
    available to you, including analyzing the network traffic, reverse engineering
    the application’s binaries, reviewing source code, and manually testing the client
    and servers to determine actual vulnerabilities. Some vulnerabilities will always
    be easier to find using techniques such as *fuzzing* (a technique by which network
    protocol data is mutated to uncover issues) whereas others will be easier to find
    by reviewing code.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我将假设你在使用所有可用手段进行协议分析，包括分析网络流量、反向工程应用程序的二进制文件、审查源代码以及手动测试客户端和服务器，以确定实际漏洞。有些漏洞通过使用如*模糊测试*（通过变异网络协议数据来揭示问题的技术）等技术总是更容易发现，而其他漏洞则通过审查代码更易于发现。
- en: '**Vulnerability Classes**'
  id: totrans-5
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**漏洞类别**'
- en: When you’re dealing with security vulnerabilities, it’s useful to categorize
    them into a set of distinct classes to assess the risk posed by the exploitation
    of the vulnerability. As an example, consider a vulnerability that, when exploited,
    allows an attack to compromise the system an application is running on.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 当处理安全漏洞时，将它们分类为一组不同的类别有助于评估漏洞被利用时所带来的风险。例如，考虑一个漏洞，当它被利用时，允许攻击者入侵应用程序所在的系统。
- en: '***Remote Code Execution***'
  id: totrans-7
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***远程代码执行***'
- en: '*Remote code execution* is a catchall term for any vulnerability that allows
    an attacker to run arbitrary code in the context of the application that implements
    the protocol. This could occur through hijacking the logic of the application
    or influencing the command line of subprocesses created during normal operation.'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: '*远程代码执行*是指任何允许攻击者在实现协议的应用程序上下文中执行任意代码的漏洞。这可能通过劫持应用程序逻辑或影响正常操作中创建的子进程的命令行来发生。'
- en: Remote code execution vulnerabilities are usually the most security critical
    because they allow an attacker to compromise the system on which the application
    is executing. Such a compromise would provide the attacker with access to anything
    the application can access and might even allow the hosting network to be compromised.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 远程代码执行漏洞通常是最为关键的安全漏洞，因为它们允许攻击者入侵应用程序执行所在的系统。这种入侵会使攻击者能够访问应用程序可以访问的任何内容，甚至可能导致托管网络被攻破。
- en: '***Denial-of-Service***'
  id: totrans-10
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***拒绝服务***'
- en: Applications are generally designed to provide a service. If a vulnerability
    exists that when exploited causes an application to crash or become unresponsive,
    an attacker can use that vulnerability to deny legitimate users access to a particular
    application and the service it provides. Commonly referred to as a *denial-of-service*
    vulnerability, it requires few resources, sometimes as little as a single network
    packet, to bring down the entire application. Without a doubt, this can be quite
    detrimental in the wrong hands.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序通常被设计用来提供某种服务。如果存在某个漏洞，一旦被利用，就会导致应用程序崩溃或无法响应，攻击者可以利用该漏洞拒绝合法用户访问特定应用程序及其提供的服务。通常被称为*拒绝服务*漏洞，它所需的资源很少，有时甚至只需一个网络数据包，就能让整个应用程序瘫痪。毫无疑问，这在不法分子手中可能造成极大的危害。
- en: We can categorize denial-of-service vulnerabilities as either *persistent* or
    *nonpersistent*. A persistent vulnerability permanently prevents legitimate users
    from accessing the service (at least until an administrator corrects the issue).
    The reason is that exploiting the vulnerability corrupts some stored state that
    ensures the application crashes when it’s restarted. A nonpersistent vulnerability
    lasts only as long as an attacker is sending data to cause the denial-of-service
    condition. Usually, if the application is allowed to restart on its own or given
    sufficient time, service will be restored.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将拒绝服务漏洞分为*持久性*和*非持久性*两类。持久性漏洞会永久阻止合法用户访问服务（至少在管理员修复问题之前）。原因是利用该漏洞会破坏某些存储的状态，导致应用程序重启时崩溃。非持久性漏洞则仅在攻击者持续发送数据导致拒绝服务条件时存在。通常，如果允许应用程序自行重启或给予足够的时间，服务将恢复。
- en: '***Information Disclosure***'
  id: totrans-13
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***信息泄露***'
- en: Many applications are black boxes, which in normal operation provide you with
    only certain information over the network. An *information disclosure* vulnerability
    exists if there is a way to get an application to provide information it wasn’t
    originally designed to provide, such as the contents of memory, filesystem paths,
    or authentication credentials. Such information might be directly useful to an
    attacker because it could aid further exploitation. For example, the information
    could disclose the location of important in-memory structures that could help
    in remote code execution.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 许多应用程序是黑箱，在正常操作中，它们只通过网络向你提供某些信息。如果存在一种方式可以让应用程序提供它最初未设计提供的信息，比如内存内容、文件系统路径或认证凭据，那么就存在*信息泄露*漏洞。这类信息对攻击者可能直接有用，因为它可能有助于进一步的利用。例如，信息泄露可能会揭示重要内存结构的位置，这些结构可能有助于远程代码执行。
- en: '***Authentication Bypass***'
  id: totrans-15
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***认证绕过***'
- en: Many applications require users to supply authentication credentials to access
    an application completely. Valid credentials might be a username and password
    or a more complex verification, like a cryptographically secure exchange. Authentication
    limits access to resources, but it can also reduce an application’s attack surface
    when an attacker is unauthenticated.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 许多应用程序要求用户提供认证凭据，以完全访问应用程序。有效的凭据可能是用户名和密码，或者更复杂的验证，如加密安全交换。认证限制了对资源的访问，但当攻击者未经认证时，它也能减少应用程序的攻击面。
- en: An *authentication bypass* vulnerability exists in an application if there is
    a way to authenticate to the application without providing all the authentication
    credentials. Such vulnerabilities might be as simple as an application incorrectly
    checking a password—for example, because it compares a simple checksum of the
    password, which is easy to brute force. Or vulnerabilities could be due to more
    complex issues, such as SQL injection (discussed later in “[SQL Injection](../Text/ch09.xhtml#ch00lev1sec268)”
    on [page 228](../Text/ch09.xhtml#page_228)).
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 如果有一种方式可以在没有提供完整认证凭据的情况下验证应用程序，那么该应用程序就存在*认证绕过*漏洞。这类漏洞可能非常简单，比如应用程序错误地检查密码——例如，因为它只比较密码的简单校验和，而这个校验和很容易被暴力破解。或者，漏洞也可能由于更复杂的问题，如
    SQL 注入（稍后在“[SQL 注入](../Text/ch09.xhtml#ch00lev1sec268)”一节中讨论，[第228页](../Text/ch09.xhtml#page_228)）。
- en: '***Authorization Bypass***'
  id: totrans-18
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***授权绕过***'
- en: Not all users are created equal. Applications may support different types of
    users, such as read-only, low-privilege, or administrator, through the same interface.
    If an application provides access to resources like files, it might need to restrict
    access based on authentication. To allow access to secured resources, an authorization
    process must be built in to determine which rights and resources have been assigned
    to a user.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 不是所有用户都相同。应用程序可能通过相同的接口支持不同类型的用户，例如只读用户、低权限用户或管理员。如果应用程序提供对资源（如文件）的访问，它可能需要根据认证来限制访问。为了允许访问受保护的资源，必须建立一个授权过程，以确定分配给用户的权限和资源。
- en: An *authorization bypass* vulnerability occurs when an attacker can gain extra
    rights or access to resources they are not privileged to access. For example,
    an attacker might change the authenticated user or user privileges directly, or
    a protocol might not correctly check user permissions.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: '*授权绕过*漏洞发生在攻击者能够获得额外的权限或访问他们没有权限访问的资源时。例如，攻击者可能直接改变认证用户或用户权限，或者协议可能没有正确检查用户权限。'
- en: '**NOTE**'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*Don’t confuse authorization bypass with authentication bypass vulnerabilities.
    The major difference between the two is that an authentication bypass allows you
    to authenticate as a specific user from the system’s point of view; an authorization
    bypass allows an attacker to access a resource from an incorrect authentication
    state (which might in fact be unauthenticated).*'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: '*不要将授权绕过与身份验证绕过漏洞混淆。两者之间的主要区别在于，身份验证绕过允许您从系统角度验证为特定用户；而授权绕过允许攻击者从不正确的认证状态访问资源（实际上可能未经验证）。*'
- en: Having defined the vulnerability classes, let’s look at their causes in more
    detail and explore some of the protocol structures in which you’ll find them.
    Each type of root cause contains a list of the possible vulnerability classes
    that it might lead to. Although this is not an exhaustive list, I cover those
    you are most likely to encounter regularly.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 定义了漏洞类别后，让我们更详细地了解它们的根本原因，并探索一些可能存在的协议结构。每种根本原因都包含可能导致的漏洞类别列表。尽管这不是详尽无遗的列表，我涵盖了您经常会遇到的那些。
- en: '**Memory Corruption Vulnerabilities**'
  id: totrans-24
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**内存损坏漏洞**'
- en: If you’ve done any analysis, memory corruption is most likely the primary security
    vulnerability you’ll have encountered. Applications store their current state
    in memory, and if that memory can be corrupted in a controlled way, the result
    can cause any class of security vulnerability. Such vulnerabilities can simply
    cause an application to crash (resulting in a denial-of-service condition) or
    be more dangerous, such as allowing an attacker to run executable code on the
    target system.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您进行过任何分析，那么内存损坏很可能是您遇到的主要安全漏洞。应用程序将其当前状态存储在内存中，如果可以以受控的方式损坏该内存，则结果可能导致任何类别的安全漏洞。此类漏洞可能仅导致应用程序崩溃（导致服务拒绝状态），或者更危险，例如允许攻击者在目标系统上运行可执行代码。
- en: '***Memory-Safe vs. Memory-Unsafe Programming Languages***'
  id: totrans-26
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***内存安全 vs. 内存不安全编程语言***'
- en: Memory corruption vulnerabilities are heavily dependent on the programming language
    the application was developed in. When it comes to memory corruption, the biggest
    difference between languages is tied to whether a language (and its hosting environment)
    is *memory safe* or *memory unsafe*. Memory-safe languages, such as Java, C#,
    Python, and Ruby, do not normally require the developer to deal with low-level
    memory management. They sometimes provide libraries or constructs to perform unsafe
    operations (such as C#’s `unsafe` keyword). But using these libraries or constructs
    requires developers to make their use explicit, which allows that use to be audited
    for safety. Memory-safe languages will also commonly perform bounds checking for
    in-memory buffer access to prevent out-of-bounds reads and writes. Just because
    a language is memory safe doesn’t mean it’s completely immune to memory corruption.
    However, corruption is more likely to be a bug in the language runtime than a
    mistake by the original developer.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 内存损坏漏洞在很大程度上取决于应用程序开发时所使用的编程语言。在涉及内存损坏时，语言之间最大的区别在于语言（及其托管环境）是否*内存安全*或*内存不安全*。像Java、C#、Python和Ruby这样的内存安全语言通常不要求开发人员处理低级别的内存管理。它们有时会提供库或结构来执行不安全操作（例如C#的`unsafe`关键字）。但是，使用这些库或结构需要开发人员明确指定其使用方式，这允许对其进行安全性审计。内存安全语言通常还会对内存缓冲区访问进行边界检查，以防止越界读写。然而，即使语言是内存安全的，也不意味着它完全免于内存损坏。然而，损坏更可能是语言运行时中的错误，而不是原始开发人员的错误。
- en: On the other hand, memory-unsafe languages, such as C and C++, perform very
    little memory access verification and lack robust mechanisms for automatically
    managing memory. As a result, many types of memory corruption can occur. How exploitable
    these vulnerabilities are depends on the operating system, the compiler used,
    and how the application is structured.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，像C和C++这样的内存不安全语言，执行非常有限的内存访问验证，并且缺乏自动管理内存的强大机制。因此，可能发生多种类型的内存损坏。这些漏洞的可利用性取决于操作系统、使用的编译器以及应用程序的结构。
- en: Memory corruption is one of the oldest and best known root causes of vulnerabilities;
    therefore, considerable effort has been made to eliminate it. (I’ll discuss some
    of the mitigation strategies in more depth in [Chapter 10](../Text/ch10.xhtml#ch10)
    when I detail how you might exploit these vulnerabilities.)
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 内存损坏是最古老且最著名的漏洞根源之一，因此已经做出了大量努力来消除它。（我将在[第10章](../Text/ch10.xhtml#ch10)详细讨论一些缓解策略，解释如何利用这些漏洞。）
- en: '***Memory Buffer Overflows***'
  id: totrans-30
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***内存缓冲区溢出***'
- en: Perhaps the best known memory corruption vulnerability is a *buffer overflow*.
    This vulnerability occurs when an application tries to put more data into a region
    of memory than that region was designed to hold. Buffer overflows may be exploited
    to get arbitrary programs to run or to bypass security restrictions, such as user
    access controls. [Figure 9-1](../Text/ch09.xhtml#ch9fig1) shows a simple buffer
    overflow caused by input data that is too large for the allocated buffer, resulting
    in memory corruption.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 也许最著名的内存损坏漏洞是*缓冲区溢出*。当应用程序尝试将更多的数据放入内存区域时，超过了该区域设计时能够容纳的大小，就会发生这种漏洞。缓冲区溢出可能被利用来执行任意程序，或者绕过安全限制，例如用户访问控制。[图
    9-1](../Text/ch09.xhtml#ch9fig1)展示了一个简单的缓冲区溢出，原因是输入数据超出了分配的缓冲区，导致内存损坏。
- en: '![image](../Images/f09-01.jpg)'
  id: totrans-32
  prefs: []
  type: TYPE_IMG
  zh: '![image](../Images/f09-01.jpg)'
- en: '*Figure 9-1: Buffer overflow memory corruption*'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 9-1：缓冲区溢出导致的内存损坏*'
- en: 'Buffer overflows can occur for either of two reasons: Commonly referred to
    as a *fixed-length buffer overflow*, an application incorrectly assumes the input
    buffer will fit into the allocated buffer. A *variable-length buffer overflow*
    occurs because the size of the allocated buffer is incorrectly calculated.'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 缓冲区溢出可能有两种原因：通常所说的*固定长度缓冲区溢出*，即应用程序错误地假设输入缓冲区会适配分配的缓冲区。而*可变长度缓冲区溢出*则发生在分配的缓冲区大小计算错误时。
- en: '**Fixed-Length Buffer Overflows**'
  id: totrans-35
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**固定长度缓冲区溢出**'
- en: By far, the simplest buffer overflow occurs when an application incorrectly
    checks the length of an external data value relative to a fixed-length buffer
    in memory. That buffer might reside on the stack, be allocated on a heap, or exist
    as a global buffer defined at compile time. The key is that the memory length
    is determined prior to knowledge of the actual data length.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 迄今为止，最简单的缓冲区溢出发生在应用程序错误地检查外部数据值的长度与内存中固定长度缓冲区的关系时。该缓冲区可能位于栈上、堆中分配，或者作为编译时定义的全局缓冲区存在。关键在于，内存长度在实际数据长度被知晓之前就已经确定。
- en: The cause of the overflow depends on the application, but it can be as simple
    as the application not checking length at all or checking length incorrectly.
    [Listing 9-1](../Text/ch09.xhtml#ch9list1) is an example.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 溢出的原因取决于应用程序，但它可能像应用程序根本不检查长度或错误地检查长度一样简单。[列表 9-1](../Text/ch09.xhtml#ch9list1)是一个例子。
- en: '[PRE0]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '*Listing 9-1: A simple fixed-length buffer overflow*'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 9-1：一个简单的固定长度缓冲区溢出*'
- en: This code first allocates the buffer where it will store the string (on the
    stack) and allocates 32 bytes of data ➊. Next, it goes into a loop that reads
    a byte from the network and stores it an incrementing index in the buffer ➋. The
    loop exits when the last byte read from the network is equal to zero, which indicates
    that the value has been sent ➌.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码首先分配一个缓冲区，用于存储字符串（位于栈上），并分配32字节的数据 ➊。接着，它进入一个循环，从网络读取一个字节，并将其存储在缓冲区中的递增索引位置
    ➋。当从网络读取的最后一个字节为零时，循环退出，这表示数据已发送 ➌。
- en: 'In this case, the developer has made a mistake: the loop doesn’t verify the
    current length at ➌ and therefore reads as much data as available from the network,
    leading to memory corruption. Of course, this problem is due to the fact that
    unsafe programming languages do not perform bounds checks on arrays. This vulnerability
    might be very simple to exploit if no compiler mitigations are in place, such
    as stack cookies to detect the corruption.'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，开发人员犯了一个错误：循环在 ➌ 处没有验证当前的长度，因此读取了网络上可用的所有数据，导致内存损坏。当然，这个问题是由于不安全的编程语言没有对数组进行边界检查。这种漏洞如果没有编译器的缓解措施（例如堆栈保护来检测损坏），可能会非常容易被利用。
- en: '**UNSAFE STRING FUNCTIONS**'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: '**不安全的字符串函数**'
- en: The C programming language does not define a string type. Instead, it uses memory
    pointers to a list of *char* types. The end of the string is indicated by a zero-value
    character. This isn’t a security problem directly. However, when the built-in
    libraries to manipulate strings were developed, safety was not considered. Consequently,
    many of these string functions are very dangerous to use in a security-critical
    application.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: C 编程语言没有定义字符串类型。相反，它使用指向*char*类型的内存指针来表示字符串。字符串的结尾由一个零值字符表示。这本身并不构成安全问题。然而，当用于操作字符串的内置库被开发时，并未考虑安全性。因此，许多这些字符串函数在安全关键的应用中非常危险。
- en: 'To understand how dangerous these functions can be, let’s look at an example
    using `strcpy`, the function that copies strings. This function takes only two
    arguments: a pointer to the source string and a pointer to the destination memory
    buffer to store the copy. Notice that nothing indicates the length of the destination
    memory buffer. And as you’ve already seen, a memory-unsafe language like C doesn’t
    keep track of buffer sizes. If a programmer tries to copy a string that is longer
    than the destination buffer, especially if it’s from an external untrusted source,
    memory corruption will occur.'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 为了理解这些函数的危险性，我们来看一个使用`strcpy`的例子，这个函数用于复制字符串。该函数只接受两个参数：指向源字符串的指针和指向目标内存缓冲区的指针，用于存储复制的内容。请注意，没有任何信息表示目标内存缓冲区的长度。而正如你已经看到的，像
    C 这样的内存不安全语言并不会跟踪缓冲区的大小。如果程序员尝试复制一个比目标缓冲区更长的字符串，尤其是来自外部不可信源的字符串，就会发生内存破坏。
- en: More recent C compilers and standardizations of the language have added more
    secure versions of these functions, such as `strcpy_s`, which adds a destination
    length argument. But if an application uses an older string function, such as
    `strcpy`, `strcat`, or `sprintf`, then there’s a good chance of a serious memory
    corruption vulnerability.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 更新版的 C 编译器和语言标准已经加入了更安全的版本，比如 `strcpy_s`，它增加了目标长度参数。但是，如果应用程序使用的是旧版的字符串函数，如
    `strcpy`、`strcat` 或 `sprintf`，那么就很有可能存在严重的内存破坏漏洞。
- en: Even if a developer performs a length check, that check may not be done correctly.
    Without automatic bounds checking on array access, it is up to the developer to
    verify all reads and writes. [Listing 9-2](../Text/ch09.xhtml#ch9list2) shows
    a corrected version of [Listing 9-1](../Text/ch09.xhtml#ch9list1) that takes into
    account strings that are longer than the buffer size. Still, even with the fix,
    a vulnerability is lurking in the code.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 即使开发者执行了长度检查，这个检查也可能做得不正确。没有自动边界检查的数组访问，必须由开发者手动验证所有的读写操作。[清单 9-2](../Text/ch09.xhtml#ch9list2)展示了一个修正版本，相比于[清单
    9-1](../Text/ch09.xhtml#ch9list1)，它考虑了比缓冲区大小更长的字符串。尽管如此，即便修正了代码，漏洞仍然潜藏其中。
- en: '[PRE1]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '*Listing 9-2: An off-by-one buffer overflow*'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 9-2：越界缓冲区溢出*'
- en: As in [Listing 9-1](../Text/ch09.xhtml#ch9list1), at ➊ and ➋, the code allocates
    a fixed-stack buffer and reads the string in a loop. The first difference is at
    ➌. The developer has added a check to make sure to exit the loop if it has already
    read 32 bytes, the maximum the stack buffer can hold. Unfortunately, to ensure
    that the string buffer is suitably terminated, a zero byte is written to the last
    position available in the buffer ➍. At this point, `i` has the value of 32\. But
    because languages like C start buffer indexing from 0, this actually means it
    will write 0 to the 33rd element of the buffer, thereby causing corruption, as
    shown in [Figure 9-2](../Text/ch09.xhtml#ch9fig2).
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 如同在[清单 9-1](../Text/ch09.xhtml#ch9list1)中所示，在 ➊ 和 ➋，代码分配了一个固定大小的栈缓冲区，并在循环中读取字符串。第一个不同之处出现在
    ➌。开发者添加了一个检查，以确保如果已经读取了 32 字节（栈缓冲区能容纳的最大字节数），就退出循环。不幸的是，为了确保字符串缓冲区正确终止，代码在缓冲区最后一个可用位置写入了零字节
    ➍。此时，`i` 的值为 32。由于像 C 这样的语言从 0 开始计数，这实际上意味着它会将 0 写入缓冲区的第 33 个元素，从而导致内存破坏，如[图 9-2](../Text/ch09.xhtml#ch9fig2)所示。
- en: '![image](../Images/f09-02.jpg)'
  id: totrans-50
  prefs: []
  type: TYPE_IMG
  zh: '![image](../Images/f09-02.jpg)'
- en: '*Figure 9-2: An off-by-one error memory corruption*'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 9-2：越界错误引发的内存破坏*'
- en: This results in an *off-by-one* error (due to the shift in index position),
    a common error in memory-unsafe languages with zero-based buffer indexing. If
    the overwritten value is important—for example, if it is the return address for
    the function—this vulnerability can be exploitable.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 这会导致一个*越界错误*（由于索引位置的偏移），这是内存不安全语言中一个常见的错误，尤其是在使用从 0 开始的缓冲区索引时。如果被覆盖的值很重要——例如，它是函数的返回地址——这个漏洞就可能被利用。
- en: '**Variable-Length Buffer Overflows**'
  id: totrans-53
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**可变长度缓冲区溢出**'
- en: An application doesn’t have to use fixed-length buffers to stored protocol data.
    In most situations, it’s possible for the application to allocate a buffer of
    the correct size for the data being stored. However, if the application incorrectly
    calculates the buffer size, a variable-length buffer overflow can occur.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序不必使用固定长度的缓冲区来存储协议数据。在大多数情况下，应用程序可以为存储的数据分配一个正确大小的缓冲区。然而，如果应用程序错误地计算了缓冲区的大小，就可能发生变长缓冲区溢出。
- en: As the length of the buffer is calculated at runtime based on the length of
    the protocol data, you might think a variable-length buffer overflow is unlikely
    to be a real-world vulnerability. But this vulnerability can still occur in a
    number of ways. For one, an application might simply incorrectly calculate the
    buffer length. (Applications should be rigorously tested prior to being made generally
    available, but that’s not always the case.)
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 由于缓冲区的长度是在运行时根据协议数据的长度计算的，你可能认为变长缓冲区溢出在现实世界中不太可能成为一个漏洞。但实际上，这个漏洞仍然可以通过多种方式发生。例如，应用程序可能会错误地计算缓冲区的长度。（应用程序应该在公开发布之前经过严格测试，但这并不总是能够做到的。）
- en: A bigger issue occurs if the calculation induces undefined behavior by the language
    or platform. For example, [Listing 9-3](../Text/ch09.xhtml#ch9list3) demonstrates
    a common way in which the length calculation is incorrect.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 更严重的问题发生在计算引发语言或平台的未定义行为时。例如，[清单 9-3](../Text/ch09.xhtml#ch9list3)展示了长度计算错误的常见方式。
- en: '[PRE2]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '*Listing 9-3: An incorrect allocation length calculation*'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 9-3：一个错误的分配长度计算*'
- en: Here the memory buffer is dynamically allocated at runtime to contain the total
    size of the input data from the protocol. First, the code reads a 32-bit integer,
    which it uses to determine the number of following 32-bit values in the protocol
    ➊. Next, it determines the total allocation size and then allocates a buffer of
    a corresponding size ➋. Finally, the code starts a loop that reads each value
    from the protocol into the allocated buffer ➌.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，内存缓冲区在运行时动态分配，用于容纳协议中输入数据的总大小。首先，代码读取一个 32 位整数，并利用该整数确定协议中后续 32 位值的数量 ➊。接着，它计算总的分配大小，然后分配一个相应大小的缓冲区
    ➋。最后，代码启动一个循环，从协议中读取每个值并将其存储到已分配的缓冲区中 ➌。
- en: What could possibly go wrong? To answer, let’s take a quick look at *integer
    overflows*.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，可能会发生什么问题呢？为了回答这个问题，让我们快速看一下*整数溢出*。
- en: '**Integer Overflows**'
  id: totrans-61
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**整数溢出**'
- en: At the processor instruction level, integer arithmetic operations are commonly
    performed using *modulo arithmetic*. Modulo arithmetic allows values to wrap if
    they go above a certain value, which is called the *modulus*. A processor uses
    modulo arithmetic if it supports only a certain native integer size, such as 32
    or 64 bits. This means that the result of any arithmetic operation must always
    be within the ranges allowed for the fixed-size integer value. For example, an
    8-bit integer can take only the values between 0 and 255; it cannot possibly represent
    any other values. [Figure 9-3](../Text/ch09.xhtml#ch9fig3) shows what happens
    when you multiply a value by 4, causing the integer to overflow.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 在处理器指令层面，整数算术操作通常使用*模运算*进行。模运算允许值在超过某个值后进行回绕，这个值被称为*模数*。如果处理器仅支持某一固定大小的整数（如
    32 位或 64 位），那么它就会使用模运算。这意味着任何算术操作的结果必须始终在允许的固定大小整数值范围内。例如，一个 8 位整数只能取 0 到 255
    之间的值；它不可能表示其他任何值。[图 9-3](../Text/ch09.xhtml#ch9fig3)展示了当你将一个值乘以 4 导致整数溢出时的情况。
- en: '![image](../Images/f09-03.jpg)'
  id: totrans-63
  prefs: []
  type: TYPE_IMG
  zh: '![image](../Images/f09-03.jpg)'
- en: '*Figure 9-3: A simple integer overflow*'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 9-3：一个简单的整数溢出*'
- en: Although this figure shows 8-bit integers for the sake of brevity, the same
    logic applies to 32-bit integers. When we multiply the original length 0x41 or
    65 by 4, the result is 0x104 or 260\. That result can’t possibly fit into an 8-bit
    integer with a range of 0 to 255\. So the processor drops the overflowed bit (or
    more likely stores it in a special flag indicating that an overflow has occurred),
    and the result is the value 4—not what we expected. The processor might issue
    an error to indicate that an overflow has occurred, but memory-unsafe programming
    languages typically ignore this sort of error. In fact, the act of wrapping the
    integer value is used in architectures such as x86 to indicate the signed result
    of an operation. Higher-level languages might indicate the error, or they might
    not support integer overflow at all, for instance, by extending the size of the
    integer on demand.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管图中为了简洁起见显示的是8位整数，但相同的逻辑适用于32位整数。当我们将原始长度0x41或65乘以4时，结果是0x104或260。这个结果显然无法适应0到255的8位整数范围。因此，处理器会丢弃溢出的位（更可能的是将其存储在一个特殊标志中，指示溢出发生），结果是值为4——这并不是我们预期的。处理器可能会发出错误，表示发生了溢出，但内存不安全的编程语言通常会忽略这种错误。事实上，在像x86这样的架构中，包装整数值的行为被用来指示操作的符号结果。更高级的语言可能会指示错误，或者根本不支持整数溢出，例如通过按需扩展整数的大小。
- en: Returning to [Listing 9-3](../Text/ch09.xhtml#ch9list3), you can see that if
    an attacker supplies a suitably chosen value for the buffer length, the multiplication
    by 4 will overflow. This results in a smaller number being allocated to memory
    than is being transmitted over the network. When the values are being read from
    the network and inserted into the allocated buffer, the parser uses the original
    length. Because the original length of the data doesn’t match up to the size of
    the allocation, values will be written outside of the buffer, causing memory corruption.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 回到[示例 9-3](../Text/ch09.xhtml#ch9list3)，你可以看到如果攻击者提供了一个合适选择的缓冲区长度值，乘以4的结果会发生溢出。这样会导致分配给内存的数字比通过网络传输的数字小。当从网络读取值并将其插入已分配的缓冲区时，解析器使用原始长度。由于数据的原始长度与分配的大小不匹配，值会被写入缓冲区之外，从而导致内存损坏。
- en: '**WHAT HAPPENS IF WE ALLOCATE ZERO BYTES?**'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: '**如果我们分配零字节，会发生什么？**'
- en: Consider what happens when we calculate an allocation length of zero bytes.
    Would the allocation simply fail because you can’t allocate a zero-length buffer?
    As with many issues in languages like C, it is up to the implementation to determine
    what occurs (the dreaded implementation-defined behavior). In the case of the
    C allocator function, `malloc`, passing zero as the requested size can return
    a failure, or it can return a buffer of indeterminate size, which hardly instills
    confidence.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑一下当我们计算分配长度为零字节时会发生什么。分配会因为无法分配零长度的缓冲区而失败吗？像C语言这样的语言中，很多问题都由实现决定（这就是令人畏惧的实现定义行为）。对于C语言的分配器函数`malloc`，传入零作为请求的大小，可能返回失败，也可能返回一个不确定大小的缓冲区，这显然不可信。
- en: '***Out-of-Bounds Buffer Indexing***'
  id: totrans-69
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***越界缓冲区索引***'
- en: 'You’ve already seen that memory-unsafe languages do not perform bounds checks.
    But sometimes a vulnerability occurs because the size of the buffer is incorrect,
    leading to memory corruption. Out-of-bounds indexing stems from a different root
    cause: instead of incorrectly specifying the size of a data value, we’ll have
    some control over the position in the buffer we’ll access. If incorrect bounds
    checking is done on the access position, a vulnerability exists. The vulnerability
    can in many cases be exploited to write data outside the buffer, leading to selective
    memory corruption. Or it can be exploited by reading a value outside the buffer,
    which could lead to information disclosure or even remote code execution. [Listing
    9-4](../Text/ch09.xhtml#ch9list4) shows an example that exploits the first case—writing
    data outside the buffer.'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 你已经看到内存不安全的语言不会执行边界检查。但有时，由于缓冲区大小不正确，会导致内存损坏。越界索引源于一个不同的根本原因：不是错误地指定数据值的大小，而是我们可以控制访问缓冲区中某个位置。如果访问位置做了不正确的边界检查，就会存在漏洞。在许多情况下，这个漏洞可以被利用来将数据写入缓冲区之外，从而导致选择性内存损坏。或者，它还可以通过读取缓冲区外的值来被利用，这可能会导致信息泄露甚至远程代码执行。[示例
    9-4](../Text/ch09.xhtml#ch9list4)展示了一个利用第一个情况——将数据写入缓冲区外部——的示例。
- en: '[PRE3]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '*Listing 9-4: Writing to an out-of-bound buffer index*'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: '*示例 9-4：写入越界缓冲区索引*'
- en: 'This short example shows a protocol with a common set of flags that can be
    updated by the client. Perhaps it’s designed to control certain server properties.
    The listing defines a fixed buffer of 32 flags at ➊. At ➋ it reads a byte from
    the network, which it will use as the index (with a range of 0 to 255 possible
    values), and then it writes the byte to the flag buffer ➌. The vulnerability in
    this case should be obvious: an attacker can provide values outside the range
    of 0 to 32 with the index, leading to selective memory corruption.'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 这个简短的例子展示了一个协议，其中包含一组客户端可以更新的常见标志。它可能是为了控制某些服务器属性而设计的。列表定义了一个包含32个标志的固定缓冲区 ➊。在
    ➋ 处，它从网络读取一个字节，该字节将作为索引（可能的值范围是0到255），然后将该字节写入标志缓冲区 ➌。在这种情况下，漏洞应该很明显：攻击者可以提供超出0到32范围的索引值，从而导致选择性内存损坏。
- en: Out-of-bounds indexing doesn’t just have to involve writing. It works just as
    well when values are read from a buffer with an incorrect index. If the index
    were used to read a value and return it to the client, a simple information disclosure
    vulnerability would exist.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 越界索引不仅仅涉及写操作。当从缓冲区读取一个值并返回给客户端时，使用不正确的索引也同样会导致漏洞。此时会存在一个简单的信息泄露漏洞。
- en: A particularly critical vulnerability could occur if the index were used to
    identify functions within an application to run. This usage could be something
    simple, such as using a command identifier as the index, which would usually be
    programmed by storing memory pointers to functions in a buffer. The index is then
    used to look up the function used to handle the specified command from the network.
    Out-of-bounds indexing would result in reading an unexpected value from memory
    that would be interpreted as a pointer to a function. This issue can easily result
    in exploitable remote code execution vulnerabilities. Typically, all that is required
    is finding an index value that, when read as a function pointer, would cause execution
    to transfer to a memory location an attacker can easily control.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 如果索引被用来识别应用程序中的函数并执行，可能会发生特别严重的漏洞。此用法可能很简单，例如使用命令标识符作为索引，通常通过将指向函数的内存指针存储在缓冲区中来进行编程。然后使用该索引从网络中查找处理指定命令的函数。越界索引会导致从内存中读取一个意外的值，该值会被解释为指向函数的指针。这个问题很容易导致可利用的远程代码执行漏洞。通常，只需要找到一个索引值，当它被当作函数指针读取时，会导致执行转移到攻击者可以轻松控制的内存位置。
- en: '***Data Expansion Attack***'
  id: totrans-76
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***数据扩展攻击***'
- en: Even modern, high-speed networks compress data to reduce the number of raw octets
    being sent, whether to improve performance by reducing data transfer time or to
    reduce bandwidth costs. At some point, that data must be decompressed, and if
    compression is done by an application, data expansion attacks are possible, as
    shown in [Listing 9-5](../Text/ch09.xhtml#ch9list5).
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 即使是现代高速网络也会压缩数据，以减少发送的原始字节数，无论是通过减少数据传输时间来提高性能，还是通过降低带宽成本来节省费用。某个时刻，这些数据必须被解压，如果压缩是由应用程序执行的，则可能会发生数据扩展攻击，如[列表9-5](../Text/ch09.xhtml#ch9list5)所示。
- en: '[PRE4]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '*Listing 9-5: Example code vulnerable to a data expansion attack*'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表9-5：易受数据扩展攻击的示例代码*'
- en: Here, the compressed data is prefixed with the total size of the decompressed
    data. The size is read from the network ➊ and is used to allocate the required
    buffer ➋. After that, a call is made to decompress the data to the buffer ➌ using
    a streaming algorithm, such as gzip. The code does not check the decompressed
    data to see if it will actually fit into the allocated buffer.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，压缩数据前面加上了解压数据的总大小。大小从网络中读取 ➊，并用于分配所需的缓冲区 ➋。之后，使用流式算法（如gzip）将数据解压到缓冲区 ➌。代码没有检查解压后的数据是否能够实际适应分配的缓冲区。
- en: Of course, this attack isn’t limited to compression. Any data transformation
    process, whether it’s encryption, compression, or text encoding conversions, can
    change the data size and lead to an expansion attack.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，这种攻击不仅限于压缩。任何数据转换过程，无论是加密、压缩还是文本编码转换，都可能改变数据大小并导致扩展攻击。
- en: '***Dynamic Memory Allocation Failures***'
  id: totrans-82
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***动态内存分配失败***'
- en: A system’s memory is finite, and when the memory pool runs dry, a dynamic memory
    allocation pool must handle situations in which an application needs more. In
    the C language, this usually results in an error value being returned from the
    allocation functions (usually a NUL pointer); in other languages, it might result
    in the termination of the environment or the generation of an exception.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 系统的内存是有限的，当内存池耗尽时，动态内存分配池必须处理应用程序需要更多内存的情况。在 C 语言中，这通常会导致从分配函数返回一个错误值（通常是一个空指针）；在其他语言中，可能会导致环境终止或生成异常。
- en: Several possible vulnerabilities may arise from not correctly handling a dynamic
    memory allocation failure. The most obvious is an application crash, which can
    lead to a denial-of-service condition.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 如果没有正确处理动态内存分配失败，可能会引发几种潜在的漏洞。最明显的问题是应用程序崩溃，这可能导致服务拒绝状态。
- en: '**Default or Hardcoded Credentials**'
  id: totrans-85
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**默认或硬编码凭据**'
- en: When one is deploying an application that uses authentication, default credentials
    are commonly added as part of the installation process. Usually, these accounts
    have a default username and password associated with them. The defaults create
    a problem if the administrator deploying the application does not reconfigure
    the credentials for these accounts prior to making the service available.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 当部署使用身份验证的应用程序时，默认凭据通常作为安装过程的一部分添加。通常，这些账户会关联一个默认的用户名和密码。如果部署应用程序的管理员在使服务可用之前没有重新配置这些账户的凭据，则默认凭据会引发问题。
- en: A more serious problem occurs when an application has hardcoded credentials
    that can be changed only by rebuilding the application. These credentials may
    have been added for debugging purposes during development and not removed before
    final release. Or they could be an intentional backdoor added with malicious intent.
    [Listing 9-6](../Text/ch09.xhtml#ch9list6) shows an example of authentication
    compromised by hardcoded credentials.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 当应用程序中存在硬编码凭据且只能通过重新构建应用程序来更改时，问题会变得更加严重。这些凭据可能在开发过程中为了调试目的被添加，但在最终发布之前没有被移除。或者，它们可能是带有恶意意图的故意后门。[列表
    9-6](../Text/ch09.xhtml#ch9list6) 显示了一个被硬编码凭据破解的身份验证示例。
- en: '[PRE5]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '*Listing 9-6: An example of default credentials*'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 9-6：默认凭据示例*'
- en: The application first reads the username and password from the network ➊ and
    then checks for a hardcoded username, *debug* ➋. If the application finds username
    *debug*, it automatically passes the authentication process; otherwise, it follows
    the normal checking process ➌. To exploit such a default username, all you’d need
    to do is log in as the *debug* user. In a real-world application, the credentials
    might not be that simple to use. The login process might require you to have an
    accepted source IP address, send a magic string to the application prior to login,
    and so on.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序首先从网络 ➊ 读取用户名和密码，然后检查是否存在硬编码的用户名 *debug* ➋。若应用程序发现用户名为 *debug*，则自动通过身份验证过程；否则，按照正常的检查流程
    ➌ 进行。要利用这种默认用户名，你只需要以 *debug* 用户身份登录即可。在实际应用中，凭据可能不会如此简单。登录过程可能要求你具有已接受的源 IP 地址、在登录之前向应用程序发送一个魔术字符串，等等。
- en: '**User Enumeration**'
  id: totrans-91
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**用户枚举**'
- en: 'Most user-facing authentication mechanisms use usernames to control access
    to resources. Typically, that username will be combined with a token, such as
    a password, to complete authentication. The user identity doesn’t have to be a
    secret: usernames are often a publicly available email address.'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数面向用户的身份验证机制使用用户名来控制资源访问。通常，用户名会与令牌（如密码）结合使用来完成身份验证。用户身份不必是保密的：用户名通常是公开可用的电子邮件地址。
- en: There are still some advantages to not allowing someone, especially unauthenticated
    users, to gain access to this information. By identifying valid user accounts,
    it is more likely that an attacker could brute force passwords. Therefore, any
    vulnerability that discloses the existence of valid usernames or provides access
    to the user list is an issue worth identifying. A vulnerability that discloses
    the existence of users is shown in [Listing 9-7](../Text/ch09.xhtml#ch9list7).
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，仍然有一些好处是，不允许某人，特别是未认证用户，访问这些信息。通过识别有效的用户账户，攻击者更有可能通过暴力破解密码。因此，任何披露有效用户名存在或提供用户列表访问的漏洞，都是值得识别的问题。[列表
    9-7](../Text/ch09.xhtml#ch9list7) 显示了一个披露用户存在的漏洞。
- en: '[PRE6]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '*Listing 9-7: Disclosing the existence of users in an application*'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 9-7：披露应用程序中存在的用户*'
- en: The listing shows a simple authentication process where the username and password
    are read from the network. It first checks for the existence of a user ➊; if the
    user doesn’t exist, an error is returned ➋. If the user exists, the listing checks
    the password for that user ➌. Again, if this fails, an error is written ➍. You’ll
    notice that the two error messages in ➋ and ➍ are different depending on whether
    the user does not exist or only the password is incorrect. This information is
    sufficient to determine which usernames are valid.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 该列表展示了一个简单的身份验证过程，其中用户名和密码从网络读取。它首先检查用户是否存在 ➊；如果用户不存在，则返回错误 ➋。如果用户存在，列表会检查该用户的密码
    ➌。同样，如果检查失败，则写入错误信息 ➍。你会注意到，错误信息在 ➋ 和 ➍ 处是不同的，这取决于是用户不存在还是只有密码错误。这些信息足以确定哪些用户名是有效的。
- en: By knowing a username, an attacker can more easily brute force valid authentication
    credentials. (It’s simpler to guess only a password rather than both a password
    and username.) Knowing a username can also give an attacker enough information
    to mount a successful social-engineering attack that would convince a user to
    disclose their password or other sensitive information.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 通过知道用户名，攻击者可以更容易地暴力破解有效的身份验证凭证。（仅猜测密码比同时猜测密码和用户名更简单。）知道用户名还可以为攻击者提供足够的信息，进行成功的社交工程攻击，诱使用户泄露他们的密码或其他敏感信息。
- en: '**Incorrect Resource Access**'
  id: totrans-98
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**不正确的资源访问**'
- en: Protocols that provide access to resources, such as HTTP or other file-sharing
    protocols, use an identifier for the resource you want to access. That identifier
    could be a file path or other unique identifier. The application must resolve
    that identifier in order to access the target resource. On success, the contents
    of the resource are accessed; otherwise, the protocol throws an error.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 提供资源访问的协议，如HTTP或其他文件共享协议，使用一个标识符来表示你想要访问的资源。该标识符可能是文件路径或其他唯一标识符。应用程序必须解析该标识符才能访问目标资源。如果成功，资源的内容将被访问；否则，协议将抛出错误。
- en: Several vulnerabilities can affect such protocols when they’re processing resource
    identifiers. It’s worth testing for all possible vulnerabilities and carefully
    observing the response from the application.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 当这些协议处理资源标识符时，可能会受到多个漏洞的影响。值得测试所有可能的漏洞，并仔细观察应用程序的响应。
- en: '***Canonicalization***'
  id: totrans-101
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***规范化***'
- en: If the resource identifier is a hierarchical list of resources and directories,
    it’s normally referred to as a *path*. Operating systems typically define the
    way to specify relative path information is to use two dots (..) to indicate a
    parent directory relationship. Before a file can be accessed, the OS must find
    it using this relative path information. A very naive remote file protocol could
    take a path supplied by a remote user, concatenate it with a base directory, and
    pass that directly to the OS, as shown in [Listing 9-8](../Text/ch09.xhtml#ch9list8).
    This is known as a *canonicalization* vulnerability.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 如果资源标识符是一个包含资源和目录的层次列表，通常称之为*路径*。操作系统通常定义相对路径信息的指定方式，即使用两个点（..）表示父目录关系。在文件可以被访问之前，操作系统必须使用这个相对路径信息来找到它。一种非常简单的远程文件协议可能会接受一个远程用户提供的路径，将其与基本目录连接起来，并直接传递给操作系统，如[列表9-8](../Text/ch09.xhtml#ch9list8)所示。这被称为*规范化*漏洞。
- en: '[PRE7]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '*Listing 9-8: A path canonicalization vulnerability*'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表9-8：路径规范化漏洞*'
- en: This listing reads a string from the network that represents the name of the
    file to access ➊. This string is then concatenated with a fixed base path into
    the full path ➋ to allow access only to a limited area of the filesystem. The
    file is then opened by the operating system ➌, and if the path contains relative
    components, they are resolved. Finally, the file is read into memory ➍ and returned
    to the client ➎.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 这个列表从网络读取一个字符串，表示要访问的文件名 ➊。然后，将该字符串与固定的基本路径连接起来，形成完整路径 ➋，以仅允许访问文件系统的有限区域。操作系统然后打开该文件
    ➌，如果路径包含相对组件，则会被解析。最后，文件被读取到内存 ➍，并返回给客户端 ➎。
- en: If you find code that performs this same sequence of operations, you’ve identified
    a canonicalization vulnerability. An attacker could send a relative path that
    is resolved by the OS to a file outside the base directory, resulting in sensitive
    files being disclosed, as shown in [Figure 9-4](../Text/ch09.xhtml#ch9fig4).
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你发现代码执行了相同的操作序列，那么你已经找到了一个规范化漏洞。攻击者可以发送一个相对路径，该路径会被操作系统解析为基目录之外的文件，从而导致敏感文件被泄露，如[图9-4](../Text/ch09.xhtml#ch9fig4)所示。
- en: Even if an application does some checking on the path before sending it to the
    OS, the application must correctly match how the OS will interpret the string.
    For example, on Microsoft Windows backslashes (\) and forward slashes (/) are
    acceptable as path separators. If an application checks only backslashes, the
    standard for Windows, there might still be a vulnerability.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 即使应用程序在将路径发送给操作系统之前进行了一些检查，应用程序仍必须正确匹配操作系统对该字符串的解释。例如，在 Microsoft Windows 上，反斜杠（\）和正斜杠（/）都可以作为路径分隔符。如果应用程序只检查反斜杠，按照
    Windows 的标准，仍然可能存在漏洞。
- en: '![image](../Images/f09-04.jpg)'
  id: totrans-108
  prefs: []
  type: TYPE_IMG
  zh: '![image](../Images/f09-04.jpg)'
- en: '*Figure 9-4: A normal path canonicalization operation versus a vulnerable one*'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 9-4：正常路径标准化操作与易受攻击操作的对比*'
- en: Although having the ability to download files from a system might be enough
    to compromise it, a more serious issue results if the canonicalization vulnerability
    occurs in file upload protocols. If you can upload files to the application-hosting
    system and specify an arbitrary path, it’s much easier to compromise a system.
    You could, for example, upload scripts or other executable content to the system
    and get the system to execute that content, leading to remote code execution.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管从系统下载文件的能力可能足以使其受到威胁，但如果文件上传协议中存在标准化漏洞，问题会更加严重。如果你可以将文件上传到应用程序托管系统并指定任意路径，那么更容易使系统受到威胁。例如，你可以将脚本或其他可执行内容上传到系统，并让系统执行这些内容，从而导致远程代码执行。
- en: '***Verbose Errors***'
  id: totrans-111
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***冗长的错误信息***'
- en: If, when an application attempts to retrieve a resource, the resource is not
    found, applications typically return some error information. That error can be
    as simple as an error code or a full description of what doesn’t exist; however,
    it should not disclose any more information than required. Of course, that’s not
    always the case.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 如果应用程序在尝试检索资源时没有找到资源，通常会返回一些错误信息。这个错误可能只是一个错误代码，或者是对不存在内容的完整描述；然而，错误信息不应泄露超出必要的信息。当然，这并非总是如此。
- en: 'If an application returns an error message when requesting a resource that
    doesn’t exist and inserts local information about the resource being accessed
    into the error, a simple vulnerability is present. If a file was being accessed,
    the error might contain the local path to the file that was passed to the OS:
    this information might prove useful for someone trying to get further access to
    the hosting system, as shown in [Listing 9-9](../Text/ch09.xhtml#ch9list9).'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 如果应用程序在请求不存在的资源时返回错误信息，并将访问资源的本地信息插入错误中，则存在一个简单的漏洞。如果访问的是一个文件，错误信息可能包含传递给操作系统的文件的本地路径：这些信息可能对试图进一步获取系统访问权限的人有用，如[列表
    9-9](../Text/ch09.xhtml#ch9list9)所示。
- en: '[PRE8]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '*Listing 9-9: An error message information disclosure*'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 9-9：错误信息泄露*'
- en: This listing shows a simple example of an error message being returned to a
    client when a requested file doesn’t exist. At ➊ it reads a string from the network
    that represents the name of the file to access. This string is then concatenated
    with a fixed base path into the full path at ➋. The existence of the file is checked
    with the operating system at ➌. If the file doesn’t exist, the full path to the
    file is added to an error string and returned to the client ➍; otherwise, the
    data is returned ➎.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 这个列表展示了当请求的文件不存在时，返回给客户端的简单错误信息示例。在➊处，它从网络读取一个字符串，表示要访问的文件名。然后，这个字符串与一个固定的基础路径连接，形成完整路径，在➋处进行拼接。文件是否存在由操作系统在➌处检查。如果文件不存在，文件的完整路径会被添加到错误字符串中并返回给客户端
    ➍；否则，数据将被返回 ➎。
- en: The listing is vulnerable to disclosing the location of the base path on the
    local filesystem. Furthermore, the path could be used with other vulnerabilities
    to get more access to the system. It could also disclose the current user running
    the application if, for example, the resource directory was in the user’s home
    directory.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 该列表容易泄露本地文件系统上基础路径的位置。此外，该路径可能与其他漏洞结合使用，从而获得更多的系统访问权限。如果资源目录位于用户的主目录中，举个例子，可能还会泄露当前运行应用程序的用户信息。
- en: '**Memory Exhaustion Attacks**'
  id: totrans-118
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**内存耗尽攻击**'
- en: 'The resources of the system on which an application runs are finite: available
    disk space, memory, and processing power have limits. Once a critical system resource
    is exhausted, the system might start failing in unexpected ways, such as by no
    longer responding to new network connections.'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序运行所在系统的资源是有限的：可用的磁盘空间、内存和处理能力都有其上限。一旦某个关键系统资源耗尽，系统可能会以意想不到的方式开始失败，比如不再响应新的网络连接。
- en: When dynamic memory is used to process a protocol, the risk of overallocating
    memory or forgetting to free the allocated blocks always exists, resulting in
    *memory exhaustion*. The simplest way in which a protocol can be susceptible to
    a memory exhaustion vulnerability is if it allocates memory dynamically based
    on an absolute value transmitted in the protocol. For example, consider [Listing
    9-10](../Text/ch09.xhtml#ch9list10).
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 当动态内存用于处理协议时，存在内存过度分配或忘记释放分配的内存块的风险，从而导致*内存耗尽*。协议易受内存耗尽漏洞影响的最简单方式是，如果它基于协议中传输的绝对值动态分配内存。例如，考虑[清单9-10](../Text/ch09.xhtml#ch9list10)。
- en: '[PRE9]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '*Listing 9-10: A memory exhaustion attack*'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单9-10：内存耗尽攻击*'
- en: This listing reads a variable-length buffer from the protocol. First, it reads
    in the length in bytes ➊ as an unsigned 32-bit integer. Next, it tries to allocate
    a buffer of that length, prior to reading it from the network ➋. Finally, it reads
    the data from the network ➌. The problem is that an attacker could easily specify
    a very large length, say 2 gigabytes, which when allocated would block out a large
    region of memory that no other part of the application could access. The attacker
    could then slowly send data to the server (to try to prevent the connection from
    closing due to a timeout) and, by repeating this multiple times, eventually starve
    the system of memory.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 这个清单从协议中读取一个可变长度的缓冲区。首先，它以无符号32位整数的形式读取字节长度➊。接下来，它尝试根据该长度分配一个缓冲区，然后再从网络中读取数据➋。最后，它从网络中读取数据➌。问题在于，攻击者可以轻松指定一个非常大的长度，比如2GB，当内存被分配时，它会阻塞一大片内存区域，使得应用程序的其他部分无法访问。然后，攻击者可以缓慢地向服务器发送数据（试图防止连接因超时而关闭），通过多次重复此过程，最终使系统内存耗尽。
- en: Most systems would not allocate physical memory until it was used, thereby limiting
    the general impact on the system as a whole. However, this attack would be more
    serious on dedicated embedded systems where memory is at a premium and virtual
    memory is nonexistent.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数系统不会在未使用时分配物理内存，从而限制了对系统整体的影响。然而，对于专用嵌入式系统而言，这种攻击可能更加严重，因为这些系统内存稀缺，并且没有虚拟内存。
- en: '**Storage Exhaustion Attacks**'
  id: totrans-125
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**存储耗尽攻击**'
- en: Storage exhaustion attacks are less likely to occur with today’s multi-terabyte
    hard disks but can still be a problem for more compact embedded systems or devices
    without storage. If an attacker can exhaust a system’s storage capacity, the application
    or others on that system could begin failing. Such an attack might even prevent
    the system from rebooting. For example, if an operating system needs to write
    certain files to disk before starting but can’t, a permanent denial-of-service
    condition can occur.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 随着今天的多TB硬盘的普及，存储耗尽攻击发生的可能性较小，但对于更紧凑的嵌入式系统或没有存储的设备，依然可能成为问题。如果攻击者能够耗尽系统的存储容量，则该系统上的应用程序或其他进程可能会开始失败。这样的攻击甚至可能阻止系统重启。例如，如果操作系统需要在启动之前将某些文件写入磁盘，但无法写入，则可能会导致永久性的拒绝服务（DoS）状态。
- en: The most common cause of this type of vulnerability is in the logging of operating
    information to disk. For example, if logging is very verbose, generating a few
    hundred kilobytes of data per connection, and the maximum log size has no restrictions,
    it would be fairly simple to flood storage by making repeated connections to a
    service. Such an attack might be particularly effective if an application logs
    data sent to it remotely and supports compressed data. In such a case, an attacker
    could spend very little network bandwidth to cause a large amount of data to be
    logged.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 这种类型漏洞最常见的原因是在将操作信息记录到磁盘时。例如，如果日志记录非常详细，每次连接产生几百千字节的数据，并且最大日志大小没有任何限制，那么通过反复连接到服务，攻击者很容易就能将存储空间填满。如果一个应用程序记录发送给它的远程数据，并且支持压缩数据，那么这种攻击可能特别有效。在这种情况下，攻击者可以通过非常少的网络带宽，导致大量数据被记录。
- en: '**CPU Exhaustion Attacks**'
  id: totrans-128
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**CPU 耗尽攻击**'
- en: 'Even though today’s average smartphone has multiple CPUs at its disposal, CPUs
    can do only a certain number of tasks at one time. It is possible to cause a denial-of-service
    condition if an attacker can consume CPU resources with a minimal amount of effort
    and bandwidth. Although this can be done in several ways, I’ll discuss only two:
    exploiting algorithmic complexity and identifying external controllable parameters
    to cryptographic systems.'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管今天的平均智能手机有多个CPU可供使用，但CPU一次只能执行有限数量的任务。如果攻击者能够用极少的努力和带宽消耗CPU资源，便有可能导致拒绝服务条件的发生。虽然可以通过多种方式做到这一点，但我将仅讨论两种方法：利用算法复杂性和识别加密系统中的外部可控参数。
- en: '***Algorithmic Complexity***'
  id: totrans-130
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***算法复杂性***'
- en: All computer algorithms have an associated computational cost that represents
    how much work needs to be performed for a particular input to get the desired
    output. The more work an algorithm requires, the more time it needs from the system’s
    processor. In an ideal world, an algorithm should take a constant amount of time,
    no matter what input it receives. But that is rarely the case.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 所有计算机算法都有一个相关的计算成本，表示为特定输入获得期望输出所需执行的工作量。算法所需的工作量越多，它就需要系统处理器更多的时间。在理想的世界中，算法应该无论收到什么输入都需要恒定的时间。但现实中，情况往往并非如此。
- en: Some algorithms become particularly expensive as the number of input parameters
    increases. For example, consider the sorting algorithm *Bubble Sort*. This algorithm
    inspects each value pair in a buffer and swaps them if the left value of the pair
    is greater than the right. This has the effect of bubbling the higher values to
    the end of the buffer until the entire buffer is sorted. [Listing 9-11](../Text/ch09.xhtml#ch9list11)
    shows a simple implementation.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 一些算法在输入参数数量增加时变得特别昂贵。例如，考虑排序算法*冒泡排序*。该算法检查缓冲区中每一对值，如果左侧的值大于右侧的值，则交换它们。这会将较大的值“冒泡”到缓冲区的末尾，直到整个缓冲区排序完成。[列表
    9-11](../Text/ch09.xhtml#ch9list11)展示了一个简单的实现。
- en: '[PRE10]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '*Listing 9-11: A simple Bubble Sort implementation*'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 9-11：一个简单的冒泡排序实现*'
- en: The amount of work this algorithm requires is proportional to the number of
    elements (let’s call the number *N*) in the buffer you need to sort. In the best
    case, this necessitates a single pass through the buffer, requiring *N* iterations,
    which occurs when all elements are already sorted. In the worst case, when the
    buffer is sorted in reverse, the algorithm needs to repeat the sort process *N*
    ² times. If an attacker could specify a large number of reverse-sorted values,
    the computational cost of doing this sort becomes significant. As a result, the
    sort could consume 100 percent of a CPU’s processing time and lead to denial-of-service.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 该算法所需的工作量与需要排序的缓冲区中元素的数量（我们称元素数量为*N*）成正比。在最佳情况下，这只需要一次遍历缓冲区，进行*N*次迭代，当所有元素已经排序时就会发生这种情况。在最坏情况下，当缓冲区是逆序排列时，算法需要重复排序过程*N*²次。如果攻击者能够指定大量逆序排列的值，那么执行这种排序的计算成本就会变得非常高。因此，排序可能会消耗CPU
    100%的处理时间，导致拒绝服务。
- en: In a real-world example of this, it was discovered that some programming environments,
    including PHP and Java, used an algorithm for the hash table implementations that
    took *N* ² operations in the worst case. A *hash table* is a data structure that
    holds values keyed to another value, such as a textual name. The keys are first
    hashed using a simple algorithm, which then determines a *bucket* into which the
    value is placed. The *N* ² algorithm is used when inserting the new value into
    the bucket; ideally, there should be few collisions between the hash values of
    keys so the size of the bucket is small. But by crafting a set of keys with the
    same hash (but, crucially, different key values), an attacker could cause a denial-of-service
    condition on a network service (such as a web server) by sending only a few requests.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 在一个现实世界的例子中，发现一些编程环境（包括PHP和Java）在哈希表实现中使用了一种最坏情况下需要*N*²次操作的算法。*哈希表*是一种数据结构，它将值与另一个值（例如文本名称）相关联。首先使用一个简单的算法对键进行哈希处理，然后确定一个*桶*，将值放入该桶中。当将新值插入桶时，使用的是*N*²算法；理想情况下，键的哈希值之间应该发生很少的碰撞，这样桶的大小就会很小。但是，通过构造一组具有相同哈希值（但至关重要的是，具有不同键值）的键，攻击者可以通过发送少量请求，在网络服务（如Web服务器）上引发拒绝服务状态。
- en: '**BIG-O NOTATION**'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: '**大O符号**'
- en: '*Big-O* notation, a common representation of computational complexity, represents
    the upper bound for an algorithm’s complexity. [Table 9-1](../Text/ch09.xhtml#ch9tab1)
    lists some common Big-O notations for various algorithms, from least to most complex.'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: '*大O* 表示法，是对计算复杂度的常见表示，表示算法复杂度的上限。[表 9-1](../Text/ch09.xhtml#ch9tab1)列出了各种算法的常见大O表示法，从最简单到最复杂。'
- en: '**Table 9-1:** Big-O Notation for Worst-Case Algorithm Complexity'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: '**表 9-1：** 最坏情况算法复杂度的大O表示法'
- en: '| **Notation** | **Description** |'
  id: totrans-140
  prefs: []
  type: TYPE_TB
  zh: '| **符号** | **描述** |'
- en: '| --- | --- |'
  id: totrans-141
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| O(1) | Constant time; the algorithm always takes the same amount of time.
    |'
  id: totrans-142
  prefs: []
  type: TYPE_TB
  zh: '| O(1) | 常数时间；算法始终花费相同的时间。 |'
- en: '| O(log *N*) | Logarithmic; the worst case is proportional to the logarithm
    of the number of inputs. |'
  id: totrans-143
  prefs: []
  type: TYPE_TB
  zh: '| O(log *N*) | 对数；最坏情况下与输入数量的对数成正比。 |'
- en: '| O(*N*) | Linear time; the worst case is proportional to the number of inputs.
    |'
  id: totrans-144
  prefs: []
  type: TYPE_TB
  zh: '| O(*N*) | 线性时间；最坏情况下与输入数量成正比。 |'
- en: '| O(*N* ²) | Quadratic; the worst case is proportional to the square of the
    number of inputs. |'
  id: totrans-145
  prefs: []
  type: TYPE_TB
  zh: '| O(*N* ²) | 二次；最坏情况下与输入数量的平方成正比。 |'
- en: '| O(2*^N*) | Exponential; the worst case is proportional to 2 raised to the
    power *N*. |'
  id: totrans-146
  prefs: []
  type: TYPE_TB
  zh: '| O(2*^N*) | 指数；最坏情况下与2的*N*次方成正比。 |'
- en: Bear in mind that these are worst-case values that don’t necessarily represent
    real-world complexity. That said, with knowledge of a specific algorithm, such
    as the Bubble Sort, there is a good chance that an attacker could intentionally
    trigger the worst case.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，这些是最坏情况值，并不一定代表真实世界的复杂性。也就是说，如果了解特定算法，例如冒泡排序，有很大可能攻击者会故意触发最坏情况。
- en: '***Configurable Cryptography***'
  id: totrans-148
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***可配置的密码学***'
- en: Cryptographic primitives processing, such as hashing algorithms, can also create
    a significant amount of computational workload, especially when dealing with authentication
    credentials. The rule in computer security is that passwords should always be
    hashed using a cryptographic digest algorithm before they are stored. This converts
    the password into a hash value, which is virtually impossible to reverse into
    the original password. Even if the hash was disclosed, it would be difficult to
    get the original password. But someone could still guess the password and generate
    the hash. If the guessed password matches when hashed, then they’ve discovered
    the original password. To mitigate this problem, it’s typical to run the hashing
    operation multiple times to increase an attacker’s computational requirement.
    Unfortunately, this process also increases computational cost for the application,
    which might be a problem when it comes to a denial-of-service condition.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 密码学原语处理，如哈希算法，在处理认证凭据时可能会产生大量的计算工作量。在计算机安全中的一项规则是，在存储密码之前，密码应始终使用密码学摘要算法进行哈希处理。这将密码转换为哈希值，几乎不可能逆向还原为原始密码。即使哈希值泄露，也很难获得原始密码。但是有人仍然可以猜测密码并生成哈希值。如果猜测的密码在哈希处理后匹配，则他们已经发现了原始密码。为了缓解这个问题，通常会多次运行哈希操作，以增加攻击者的计算需求。不幸的是，这个过程也会增加应用程序的计算成本，这可能在面对拒绝服务条件时成为问题。
- en: A vulnerability can occur if either the hashing algorithm takes an exponential
    amount of time (based on the size of the input) or the algorithm’s number of iterations
    can be specified externally. The relationship between the time required by most
    cryptographic algorithms and a given input is fairly linear. However, if you can
    specify the algorithm’s number of iterations without any sensible upper bound,
    processing could take as long as the attacker desired. Such a vulnerable application
    is shown in [Listing 9-12](../Text/ch09.xhtml#ch9list12).
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 如果哈希算法花费的时间是指数级（根据输入大小），或者可以从外部指定算法的迭代次数，就会发生漏洞。大多数密码算法所需时间与给定输入的关系相当线性。但是，如果可以无限制地指定算法的迭代次数，处理时间可能会持续到攻击者所需的任意时间。这样一个易受攻击的应用程序显示在[清单
    9-12](../Text/ch09.xhtml#ch9list12)中。
- en: '[PRE11]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '*Listing 9-12: Checking a vulnerable authentication*'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 9-12：检查易受攻击的认证*'
- en: First, the username and password are read from the network ➊. Next, the hashing
    algorithm’s number of iterations is read ➋, and the hashing process is applied
    that number of times ➌. Finally, the hashed password is checked against one stored
    by the application ➍. Clearly, an attacker could supply a very large value for
    the iteration count that would likely consume a significant amount of CPU resources
    for an extended period of time, especially if the hashing algorithm is computationally
    complex.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，从网络读取用户名和密码 ➊。接下来，读取哈希算法的迭代次数 ➋，并应用该次数进行哈希处理 ➌。最后，将哈希后的密码与应用程序存储的密码进行对比 ➍。显然，攻击者可以提供一个非常大的迭代次数，这可能会消耗大量的CPU资源，尤其是在哈希算法计算复杂的情况下，持续的时间也会很长。
- en: A good example of a cryptographic algorithm that a client can configure is the
    handling of public/private keys. Algorithms such as RSA rely on the computational
    cost of factoring a large public key value. The larger the key value, the more
    time it takes to perform encryption/decryption and the longer it takes to generate
    a new key pair.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 客户端可以配置的一个很好的加密算法示例是公钥/私钥的处理。像RSA这样的算法依赖于对大公钥值的因式分解计算成本。公钥值越大，执行加密/解密所需的时间就越长，生成新密钥对的时间也会更长。
- en: '**Format String Vulnerabilities**'
  id: totrans-155
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**格式化字符串漏洞**'
- en: Most programming languages have a mechanism to convert arbitrary data into a
    string, and it’s common to define some formatting mechanism to specify how the
    developer wants the output. Some of these mechanisms are quite powerful and privileged,
    especially in memory-unsafe languages.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数编程语言都有将任意数据转换为字符串的机制，并且通常会定义一些格式化机制来指定开发者希望的输出方式。这些机制中的一些非常强大且特权，尤其是在内存不安全的语言中。
- en: A *format string* vulnerability occurs when the attacker can supply a string
    value to an application that is then used directly as the format string. The best-known,
    and probably the most dangerous, formatter is used by the C language’s `printf`
    and its variants, such as `sprintf`, which print to a string. The `printf` function
    takes a format string as its first argument and then a list of the values to format.
    [Listing 9-13](../Text/ch09.xhtml#ch9list13) shows such a vulnerable application.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: '*格式化字符串*漏洞发生在攻击者能够向应用程序提供一个字符串值，并将其直接作为格式字符串使用时。最著名、也可能是最危险的格式化器由C语言的`printf`及其变体（如`sprintf`，它会打印到字符串）使用。`printf`函数将格式字符串作为第一个参数，然后是要格式化的值列表。[列表9-13](../Text/ch09.xhtml#ch9list13)展示了这样的易受攻击的应用程序。'
- en: '[PRE12]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '*Listing 9-13: The `printf` format string vulnerability*'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表9-13：`printf`格式字符串漏洞*'
- en: The format string for `printf` specifies the position and type of data using
    a `%?` syntax where the question mark is replaced by an alphanumeric character.
    The format specifier can also include formatting information, such as the number
    of decimal places in a number. An attacker who can directly control the format
    string could corrupt memory or disclose information about the current stack that
    might prove useful for further attacks. [Table 9-2](../Text/ch09.xhtml#ch9tab2)
    shows a list of common `printf` format specifiers that an attacker could abuse.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: '`printf`的格式字符串使用`%?`语法来指定数据的位置和类型，其中问号由字母数字字符替换。格式说明符还可以包含格式化信息，例如数字的小数位数。如果攻击者可以直接控制格式字符串，可能会破坏内存或泄露当前堆栈的信息，这些信息可能对进一步攻击有用。[表9-2](../Text/ch09.xhtml#ch9tab2)展示了攻击者可能滥用的常见`printf`格式说明符列表。'
- en: '**Table 9-2:** List of Commonly Exploitable `printf` Format Specifiers'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: '**表9-2:** 常见可利用的`printf`格式说明符列表'
- en: '| **Format specifier** | **Description** | **Potential vulnerabilities** |'
  id: totrans-162
  prefs: []
  type: TYPE_TB
  zh: '| **格式说明符** | **描述** | **潜在漏洞** |'
- en: '| --- | --- | --- |'
  id: totrans-163
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| `%d`, `%p`, `%u`, `%x` | Prints integers | Can be used to disclose information
    from the stack if returned to an attacker |'
  id: totrans-164
  prefs: []
  type: TYPE_TB
  zh: '| `%d`、`%p`、`%u`、`%x` | 打印整数 | 如果返回给攻击者，可能会泄露堆栈中的信息 |'
- en: '| `%s` | Prints a zero terminated string | Can be used to disclose information
    from the stack if returned to an attacker or cause invalid memory accesses to
    occur, leading to denial-of-service |'
  id: totrans-165
  prefs: []
  type: TYPE_TB
  zh: '| `%s` | 打印一个零终止的字符串 | 如果返回给攻击者，可能会泄露堆栈中的信息，或者导致无效内存访问，从而引发服务拒绝（DoS） |'
- en: '| `%n` | Writes the current number of printed characters to a pointer specified
    in the arguments | Can be used to cause selective memory corruption or application
    crashes |'
  id: totrans-166
  prefs: []
  type: TYPE_TB
  zh: '| `%n` | 将当前已打印的字符数写入参数中指定的指针 | 可能用于导致选择性内存损坏或应用崩溃 |'
- en: '**Command Injection**'
  id: totrans-167
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**命令注入**'
- en: Most OSes, especially Unix-based OSes, include a rich set of utilities designed
    for various tasks. Sometimes developers decide that the easiest way to execute
    a particular task, say password updating, is to execute an external application
    or operating system utility. Although this might not be a problem if the command
    line executed is entirely specified by the developer, often some data from the
    network client is inserted into the command line to perform the desired operation.
    [Listing 9-14](../Text/ch09.xhtml#ch9list14) shows such a vulnerable application.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数操作系统，特别是基于 Unix 的操作系统，都包含了一个功能丰富的实用工具集，用于执行各种任务。有时候，开发人员决定，执行某个特定任务（比如更新密码）的最简单方法是执行外部应用程序或操作系统实用工具。尽管如果执行的命令行完全由开发人员指定，这通常不会构成问题，但经常会将一些来自网络客户端的数据插入到命令行中以执行所需的操作。[列表
    9-14](../Text/ch09.xhtml#ch9list14)展示了一个这样的易受攻击的应用程序。
- en: '[PRE13]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '*Listing 9-14: A password update vulnerable to command injection*'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 9-14：一个易受命令注入攻击的密码更新示例*'
- en: The listing updates the current user’s password as long as the original password
    is known ➊. It then builds a command line and invokes the Unix-style `system`
    function ➋. Although we don’t control the `username` or `oldpassword` parameters
    (they must be correct for the `system` call to be made), we do have complete control
    over `newpassword`. Because no sanitization is done, the code in the listing is
    vulnerable to command injection because the system function uses the current Unix
    shell to execute the command line. For example, we could specify a value for `newpassword`
    such as `password; xcalc`, which would first execute the password update command.
    Then the shell could execute `xcalc` as it treats the semicolon as a separator
    in a list of commands to execute.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 该代码段会在知道原始密码的情况下更新当前用户的密码 ➊。接着它构建一个命令行，并调用 Unix 风格的 `system` 函数 ➋。虽然我们不能控制 `username`
    或 `oldpassword` 参数（它们必须正确才能执行 `system` 调用），但我们完全控制 `newpassword`。因为没有进行任何数据净化，这段代码容易受到命令注入的攻击，因为
    `system` 函数使用当前的 Unix shell 来执行命令行。例如，我们可以为 `newpassword` 指定一个值，如 `password; xcalc`，这样就会首先执行密码更新命令。然后，shell
    会将分号作为命令分隔符，执行 `xcalc`。
- en: '**SQL Injection**'
  id: totrans-172
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**SQL 注入**'
- en: Even the simplest application might need to persistently store and retrieve
    data. Applications can do this in a number of ways, but one of the most common
    is to use a relational database. Databases offer many advantages, not least of
    which is the ability to issue queries against the data to perform complex grouping
    and analysis.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 即使是最简单的应用程序也可能需要持久化存储和检索数据。应用程序可以通过多种方式实现这一点，但最常见的一种方式是使用关系型数据库。数据库提供了许多优势，其中之一就是能够针对数据发出查询，以执行复杂的分组和分析。
- en: 'The de facto standard for defining queries to relational databases is the *Structured
    Query Language (SQL)*. This text-based language defines what data tables to read
    and how to filter that data to get the results the application wants. When using
    a text-based language there is a temptation is to build queries using string operations.
    However, this can easily result in a vulnerability like command injection: instead
    of inserting untrusted data into a command line without appropriately escaping,
    the attacker inserts data into a SQL query, which is executed on the database.
    This technique can modify the operation of the query to return known results.
    For example, what if the query extracted the current password for the authenticating
    user, as shown in [Listing 9-15](../Text/ch09.xhtml#ch9list15)?'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 定义关系型数据库查询的事实标准是*结构化查询语言（SQL）*。这种基于文本的语言定义了要读取的数据表以及如何过滤这些数据，以获取应用程序所需的结果。在使用基于文本的语言时，常常会有一个诱惑，就是通过字符串操作构建查询。然而，这很容易导致类似命令注入的漏洞：攻击者并不是将不可信的数据插入到命令行中而不进行适当的转义，而是将数据插入到
    SQL 查询中，随后该查询在数据库上执行。这种技术可以修改查询的操作，返回已知的结果。例如，如果查询提取了当前身份验证用户的密码，如[列表 9-15](../Text/ch09.xhtml#ch9list15)所示，结果会怎样呢？
- en: '[PRE14]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '*Listing 9-15: An example of authentication vulnerable to SQL injection*'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 9-15：一个容易受到 SQL 注入攻击的身份验证示例*'
- en: This listing reads the username and password from the network ➊. Then it builds
    a new SQL query as a string, using a `SELECT` statement to extract the password
    associated with the user from the user table ➋. Finally, it executes that query
    on the database and checks that the password read from the network matches the
    one in the database ➌.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 这个代码段从网络读取用户名和密码 ➊。然后，它构建一个新的 SQL 查询字符串，使用 `SELECT` 语句从用户表中提取与用户相关的密码 ➋。最后，它在数据库上执行该查询，并检查从网络读取的密码是否与数据库中的密码匹配
    ➌。
- en: The vulnerability in this listing is easy to exploit. In SQL, the strings need
    to be enclosed in single quotes to prevent them from being interpreted as commands
    in the SQL statement. If a username is sent in the protocol with an embedded single
    quote, an attacker could terminate the quoted string early. This would lead to
    an injection of new commands into the SQL query. For example, a `UNION SELECT`
    statement would allow the query to return an arbitrary password value. An attacker
    could use the SQL injection to bypass the authentication of an application.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 这个漏洞很容易被利用。在 SQL 中，字符串需要用单引号括起来，以防它们被误解为 SQL 语句中的命令。如果用户名在协议中包含了单引号，攻击者就可以提前结束引号中的字符串，从而将新的命令注入到
    SQL 查询中。例如，一个 `UNION SELECT` 语句就可以让查询返回任意的密码值。攻击者可以利用 SQL 注入绕过应用程序的身份验证。
- en: SQL injection attacks can even result in remote code execution. For example,
    although disabled by default, Microsoft’s SQL Server’s database function `xp_cmdshell`
    allows you to execute OS commands. Oracle’s database even allows uploading arbitrary
    Java code. And of course, it’s also possible to find applications that pass raw
    SQL queries over the network. Even if a protocol is not intended for controlling
    the database, there’s still a good chance that it can be exploited to access the
    underlying database engine.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: SQL 注入攻击甚至可能导致远程代码执行。例如，尽管默认情况下被禁用，Microsoft SQL Server 的数据库功能 `xp_cmdshell`
    允许执行操作系统命令。Oracle 的数据库甚至允许上传任意的 Java 代码。当然，也有一些应用程序通过网络传递原始的 SQL 查询。即使某个协议本身并不是为了控制数据库，仍然很可能被利用来访问底层的数据库引擎。
- en: '**Text-Encoding Character Replacement**'
  id: totrans-180
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**文本编码字符替换**'
- en: In an ideal world, everyone would be able to use one type of text encoding for
    all different languages. But we don’t live in an ideal world, and we use multiple
    text encodings as discussed in [Chapter 3](../Text/ch03.xhtml#ch03), such as ASCII
    and variants of Unicode.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 在理想的世界里，每个人都可以使用一种文本编码来处理所有不同的语言。但是我们并不生活在理想的世界里，正如在[第 3 章](../Text/ch03.xhtml#ch03)中讨论的那样，我们使用多种文本编码，比如
    ASCII 和各种 Unicode 变体。
- en: 'Some conversions between text encodings cannot be round-tripped: converting
    from one encoding to another loses important information such that if the reverse
    process is applied, the original text can’t be restored. This is especially problematic
    when converting from a wide character set such as Unicode to a narrow one such
    as ASCII. It’s simply impossible to encode the entire Unicode character set in
    7 bits.'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 一些文本编码之间的转换无法做到“往返”：从一种编码转换到另一种编码时会丢失重要信息，以至于如果再进行反向操作，原始文本无法恢复。特别是在从像 Unicode
    这样的大字符集转换到像 ASCII 这样的小字符集时，这个问题尤为突出。因为用 7 位无法编码整个 Unicode 字符集。
- en: Text-encoding conversions manage this problem in one of two ways. The simplest
    approach replaces the character that cannot be represented with a placeholder,
    such as the question mark (?) character. This might be a problem if the data value
    refers to something where the question mark is used as a delimiter or as a special
    character, for example, as in URL parsing where it represents the beginning of
    a query string.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 文本编码转换通过两种方式来处理这个问题。最简单的方法是用占位符替换无法表示的字符，例如问号（?）字符。如果数据值引用的是某些特殊情况，比如 URL 解析中，问号作为查询字符串的开始，那么这样就可能成问题。
- en: The other approach is to apply a best-fit mapping. This is used for characters
    for which there is a similar character in the new encoding. For example, the quotation
    mark characters in Unicode have left-facing and right-facing forms that are mapped
    to specific code points, such as U+201C and U+201D for left and right double quotation
    marks. These are outside the ASCII range, but in a conversion to ASCII, they’re
    commonly replaced with the equivalent character, such as U+0022 or the quotation
    mark. Best-fit mapping can become a problem when the converted text is processed
    by the application. Although slightly corrupted text won’t usually cause much
    of a problem for a user, the automatic conversion process could cause the application
    to mishandle the data.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种方法是应用最佳匹配映射。这种方法用于那些在新编码中有类似字符的字符。例如，Unicode 中的引号字符有左双引号和右双引号的形式，分别映射到特定的代码点，如
    U+201C 和 U+201D。虽然这些字符不在 ASCII 范围内，但在转换到 ASCII 时，它们通常会被替换成等效的字符，如 U+0022 或引号。最佳匹配映射可能会在应用程序处理转换后的文本时产生问题。虽然略微损坏的文本通常不会对用户造成太大问题，但自动转换过程可能会导致应用程序错误地处理数据。
- en: The important implementation issue is that the application first verifies the
    security condition using one encoded form of a string. Then it uses the other
    encoded form of a string for a specific action, such as reading a resource or
    executing a command, as shown in [Listing 9-16](../Text/ch09.xhtml#ch9list16).
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的实现问题是，应用程序首先使用一种编码形式的字符串来验证安全条件。然后，它使用另一种编码形式的字符串执行特定操作，例如读取资源或执行命令，如在[示例
    9-16](../Text/ch09.xhtml#ch9list16)中所示。
- en: '[PRE15]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '*Listing 9-16: A text conversion vulnerability*'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: '*示例 9-16：文本转换漏洞*'
- en: In this listing, the application reads in a Unicode string representing a user
    to add to the system ➊. It will pass the value to the `add_user` command, but
    it wants to avoid a command injection vulnerability; therefore, it first ensures
    that the username doesn’t contain any single quote characters that could be misinterpreted
    ➋. Once satisfied that the string is okay, it converts it to ASCII (Unix systems
    typically work on a narrow character set, although many support UTF-8) and ensures
    that the value is enclosed with single quotes to prevent spaces from being misinterpreted
    ➌.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，应用程序读取一个表示用户的 Unicode 字符串，以将其添加到系统中 ➊。它将把该值传递给 `add_user` 命令，但为了避免命令注入漏洞，因此它首先确保用户名不包含任何可能被误解的单引号字符
    ➋。一旦确认字符串没有问题，它会将其转换为 ASCII（Unix 系统通常使用狭窄的字符集，尽管许多系统支持 UTF-8），并确保该值被单引号包围，以防止空格被误解
    ➌。
- en: Of course, if the best-fit mapping rules convert other characters back to a
    single quote, it would be possible to prematurely terminate the quoted string
    and return to the same sort of command injection vulnerabilities discussed earlier.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，如果最佳匹配规则将其他字符转换回单引号，那么就有可能提前终止引号字符串，并导致前面讨论的同样类型的命令注入漏洞。
- en: '**Final Words**'
  id: totrans-190
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**结束语**'
- en: This chapter showed you that many possible root causes exist for vulnerabilities,
    with a seemingly limitless number of variants in the wild. Even if something doesn’t
    immediately look vulnerable, persist. Vulnerabilities can appear in the most surprising
    places.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 本章向你展示了漏洞的许多可能根本原因，并且在实际中存在着几乎无限的变种。即使某些东西看起来并不立即显示出漏洞，仍然要保持警觉。漏洞可能出现在最令人意想不到的地方。
- en: I’ve covered vulnerabilities ranging from memory corruptions, causing an application
    to behave in a different manner than it was originally designed, to preventing
    legitimate users from accessing the services provided. It can be a complex process
    to identify all these different issues.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 我已经涵盖了从内存损坏导致应用程序行为与原始设计不符，到阻止合法用户访问提供的服务等漏洞。识别这些不同问题可能是一个复杂的过程。
- en: As a protocol analyzer, you have a number of possible angles. It is also vital
    that you change your strategy when looking for implementation vulnerabilities.
    Take into account whether the application is written in memory-safe or unsafe
    languages, keeping in mind that you are less likely to find memory corruption
    in, for example, a Java application.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 作为协议分析员，你有多个可能的切入点。同时，当寻找实现漏洞时，改变策略也至关重要。考虑应用程序是用内存安全语言还是不安全语言编写的，记住，例如在 Java
    应用程序中，你不太可能找到内存损坏问题。
