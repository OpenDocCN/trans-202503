- en: '**8**'
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '**8**'
- en: '**SPECIAL IMAGE ACCESS TOPICS**'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: '**特殊镜像访问主题**'
- en: '![image](../images/common-01.jpg)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/common-01.jpg)'
- en: This chapter demonstrates techniques for getting information about disk image
    files and making them accessible as block devices and as mounted directories.
    You’ll learn to set up loop devices and create logical devices with device mapper
    tools. You’ll also explore methods to map or convert software-encrypted disk images,
    making them accessible by forensic tools. These methods are useful in situations
    in which the contents of an image cannot be accessed directly and a layer of active
    translation or decryption is needed. Examples of such images include encrypted
    filesystems, virtual machine (VM) images, and other image file formats that forensic
    tools do not directly support.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章展示了如何获取磁盘镜像文件的信息，并将其作为块设备和挂载目录使其可访问。你将学习如何设置循环设备，并使用设备映射工具创建逻辑设备。你还将探索映射或转换软件加密磁盘镜像的方法，使其能够被取证工具访问。这些方法在图像内容无法直接访问且需要进行主动翻译或解密时非常有用。此类图像的示例包括加密文件系统、虚拟机（VM）镜像以及其他取证工具不直接支持的镜像文件格式。
- en: Each section also includes examples of safely mounting (read-only) image files
    as regular filesystems on the forensic acquisition host. Then you can easily browse
    and access the filesystem using common programs, such as file managers, office
    suites, file viewers, media players, and so on.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 每个部分还包括将（只读）镜像文件安全挂载为常规文件系统的示例，这些镜像文件将被挂载到取证采集主机上。然后，你可以使用常见程序轻松浏览和访问文件系统，如文件管理器、办公套件、文件查看器、媒体播放器等。
- en: '**Forensically Acquired Image Files**'
  id: totrans-5
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**取证采集的镜像文件**'
- en: The basis for many of the methods and examples you’ll see in this section is
    the Linux loop device (not to be confused with a loopback device, which is a network
    interface). A *loop device* is a pseudo device that can be associated with a regular
    file, making the file accessible as a block device in */dev*.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 本部分中许多方法和示例的基础是 Linux 循环设备（不要与环回设备混淆，环回设备是网络接口）。*循环设备*是一种伪设备，可以与常规文件关联，使得该文件可以作为块设备在*/dev*中访问。
- en: Linux systems typically create eight loop devices by default, which might not
    be enough for a forensic acquisition host, but you can increase that number, either
    manually or automatically, on boot up. To create 32 loop devices during boot up,
    add `max_loop=32` to the `GRUB_CMDLINE_LINUX_DEFAULT=` line in the */etc/default/grub*
    file; after reboot, 32 unused loop devices should be available. The sfsimage script
    uses loop devices to mount SquashFS forensic evidence containers.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: Linux 系统通常默认创建八个循环设备，这对于取证采集主机可能不够，但你可以手动或自动在启动时增加这个数量。要在启动时创建 32 个循环设备，可以在*/etc/default/grub*文件的`GRUB_CMDLINE_LINUX_DEFAULT=`行中添加`max_loop=32`；重启后，应有
    32 个未使用的循环设备可用。sfsimage 脚本使用循环设备挂载 SquashFS 取证证据容器。
- en: 'This chapter will cover different VM images from common VM systems from QEMU,
    VirtualBox, VMWare, and Microsoft Virtual PC. I also describe access to OS-encrypted
    filesystems, including Microsoft’s BitLocker, Apple’s FileVault, Linux LUKS, and
    VeraCrypt (a fork of TrueCrypt). But let’s begin the with the simplest form of
    image: a raw disk image acquired using a dd-style acquisition tool.'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将介绍来自常见虚拟机系统（如 QEMU、VirtualBox、VMWare 和 Microsoft Virtual PC）的不同虚拟机镜像。我还将描述如何访问操作系统加密的文件系统，包括微软的
    BitLocker、苹果的 FileVault、Linux LUKS 和 VeraCrypt（TrueCrypt 的一个分支）。但让我们从最简单的镜像类型开始：通过
    dd 风格的采集工具获取的原始磁盘镜像。
- en: '***Raw Image Files with Loop Devices***'
  id: totrans-9
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***使用循环设备的原始镜像文件***'
- en: 'The simplest demonstration of a loop device can be shown using a raw image
    file (possibly acquired from a simple `dd` command). The `losetup` command attaches
    and detaches loop devices from a Linux system. This example creates a block device
    for an *image.raw* file:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 最简单的循环设备演示可以使用原始镜像文件（可能是通过简单的`dd`命令采集的）。`losetup`命令用于在 Linux 系统中附加和分离循环设备。此示例为*image.raw*文件创建一个块设备：
- en: '[PRE0]'
  id: totrans-11
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Here, the flags specify that the loop should be read-only (`--read-only`) and
    the next available loop device should be used (`--find`) and displayed on completion
    (`--show`). The filename specified (*image.raw*) will then become available as
    an attached block device.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，标志指定循环设备应为只读（`--read-only`），并且应使用下一个可用的循环设备（`--find`），并在完成后显示（`--show`）。指定的文件名（*image.raw*）随后将作为附加的块设备可用。
- en: 'Running the `losetup` command without parameters displays the status of all
    configured loop devices. Here we can see the one just created:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 运行没有参数的`losetup`命令将显示所有已配置循环设备的状态。这里我们可以看到刚刚创建的一个：
- en: '[PRE1]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The */dev/loop0* device now points to */exam/image.raw*, and you can access
    it with any tools that operate on block devices. For example, here the Sleuth
    Kit `mmls` command is able to see the partition table on the *image.raw* file
    using the loop device:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，*/dev/loop0*设备指向*/exam/image.raw*，你可以使用任何操作块设备的工具访问它。例如，这里使用Sleuth Kit的`mmls`命令，通过循环设备查看*image.raw*文件中的分区表：
- en: '[PRE2]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'When you no longer need a loop device, simply detach it as follows:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 当你不再需要循环设备时，只需按照以下方式分离它：
- en: '[PRE3]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Loop devices are flexible and configurable. In the previous mmls example, a
    filesystem starts at sector 2048\. It’s possible to specify an offset each time
    you run a forensic tool, but it’s easier to have a separate device for each partition
    (similar to */dev/sda1* for example). You can create a separate loop device with
    the `losetup` command just for that partition by specifying the correct offset
    flag (`--offset`) and size flag (`--sizelimit`). However, a more commonly accepted
    way is to use the device mapper.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 循环设备是灵活且可配置的。在前面的mmls示例中，文件系统从第2048扇区开始。每次运行取证工具时，都可以指定偏移量，但为每个分区创建一个单独的设备（类似于*/dev/sda1*）会更容易。你可以通过指定正确的偏移量标志（`--offset`）和大小标志（`--sizelimit`）来仅为该分区创建一个单独的循环设备。然而，通常接受的做法是使用设备映射器。
- en: 'You could do this manually using dmsetup and mapping tables as described in
    “[RAID and Multidisk Systems](ch06.xhtml#ch06lev1sec07)” on [page 178](ch06.xhtml#page_178).
    However, the kpartx tool automates the creation of partition devices for a particular
    image file. A forensically acquired image with four partitions is used in the
    following example to demonstrate the kpartx tool making mapper devices for each
    partition:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以手动使用dmsetup和映射表，如在[《RAID和多磁盘系统》](ch06.xhtml#ch06lev1sec07)的[第178页](ch06.xhtml#page_178)中所描述的那样。然而，kpartx工具自动化了为特定镜像文件创建分区设备的过程。以下示例中使用了一个具有四个分区的取证获取的镜像文件，展示了kpartx工具如何为每个分区创建映射设备：
- en: '[PRE4]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Here, the kpartx tool reads the partition table on a disk or image file, creates
    a loop device for the whole image, and then creates mapper devices for each partition.
    The `-r` flag ensures the drive loop and partition mappings are read-only, and
    the `-a` flag instructs kpartx to map everything it finds. Use the verbose flag
    `-v` to document the command output and to indicate what was just mapped.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，kpartx工具读取磁盘或镜像文件中的分区表，创建一个用于整个镜像的循环设备，然后为每个分区创建映射设备。`-r`标志确保驱动器循环和分区映射为只读，`-a`标志指示kpartx映射它找到的所有内容。使用详细标志`-v`来记录命令输出，并指示刚才映射了什么。
- en: 'In this example, a loop device is created (*/dev/loop0*) for the whole image
    file and is accessible as a raw block device. In addition, partition devices are
    now available in the */dev/mapper* directory, and you can access them using forensic
    tools that operate on partitions, without specifying any offsets. Here are a few
    example Sleuth Kit commands for some of the partitions:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，创建了一个循环设备（*/dev/loop0*）用于整个镜像文件，并作为原始块设备可以访问。此外，分区设备现在可以在*/dev/mapper*目录中找到，你可以使用操作分区的取证工具访问它们，而无需指定任何偏移量。以下是一些用于某些分区的Sleuth
    Kit命令示例：
- en: '[PRE5]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'A filesystem mapped to a device from an image file can be safely mounted as
    read-only. This will allow you access it with a standard file manager, applications,
    and other file-analysis tools. You can mount and unmount loop partitions, as shown
    in this example:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 从镜像文件映射到设备的文件系统可以安全地以只读模式挂载。这将允许你通过标准文件管理器、应用程序和其他文件分析工具访问它。你可以像示例中所示那样挂载和卸载循环分区：
- en: '[PRE6]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Here, a directory, *p3*, representing the partition was created in the same
    directory as the raw image. Then *p3* was used as the mount point (the chosen
    mount point can be anywhere on the examiner host filesystem). Midnight Commander
    (`mc`) is a text-based file manager (a Norton Commander clone) and is used in
    this example to review the files on the mounted partition. When the mount point
    is no longer needed, the `umount` command (this command is spelled correctly with
    only one *n*) unmounts the filesystem, and rmdir removes the mount point directory.
    This is the traditional Unix way to mount and unmount a filesystem on a host system.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，创建了一个目录，*p3*，表示该分区，并且该目录与原始镜像文件位于同一目录下。然后，*p3*被用作挂载点（选择的挂载点可以是检查主机文件系统中的任何位置）。Midnight
    Commander（`mc`）是一个基于文本的文件管理器（Norton Commander的克隆版），在本示例中用于查看挂载分区中的文件。当不再需要挂载点时，`umount`命令（此命令只有一个*n*）卸载文件系统，rmdir则移除挂载点目录。这是传统的Unix方式，用于在主机系统上挂载和卸载文件系统。
- en: 'When you no longer need the drive loop and partition mappings, you can remove
    them all by using the kpartx delete (`-d`) flag and the name of the image file,
    like this:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 当您不再需要驱动环回和分区映射时，可以通过使用kpartx删除（`-d`）标志和镜像文件名来删除它们，如下所示：
- en: '[PRE7]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Note that this “delete” has no effect on the disk image’s contents. The loop
    and mappings are deleted, not the drive image, and the drive image is not modified.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，这个“删除”操作不会影响磁盘镜像的内容。删除的是环回设备和映射，而不是驱动镜像，驱动镜像并没有被修改。
- en: If a raw image has a corrupt or overwritten partition table, you can scan the
    image for filesystems and use dmsetup to manually map filesystems as devices (using
    dmsetup tables).
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 如果原始镜像具有损坏或被覆盖的分区表，您可以扫描镜像文件查找文件系统，并使用dmsetup手动将文件系统映射为设备（使用dmsetup表格）。
- en: When you create, mount, unmount, or detach a loop device, root privileges are
    required. They’re also required for operating on the */dev/loopX* device with
    forensic tools. The examples shown in this section were run as the root user to
    reduce the complexity of the command lines, making them easier to understand.
    Prefixing the commands with `sudo` can be used to run privileged commands as a
    non-root user.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 创建、挂载、卸载或分离环回设备时需要root权限。操作*/dev/loopX*设备时也需要root权限，尤其是使用取证工具时。本节中的示例是作为root用户运行的，以简化命令行的复杂性，使其更易理解。通过在命令前加`sudo`，可以作为非root用户执行特权命令。
- en: '***Forensic Format Image Files***'
  id: totrans-33
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***取证格式镜像文件***'
- en: The ewflib software package includes a tool called ewfmount to “mount” the contents
    of a forensic image, making it accessible as a regular raw image file.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: ewflib软件包包括一个名为ewfmount的工具，用于“挂载”取证镜像的内容，使其可以作为常规原始镜像文件访问。
- en: 'The following example shows a group of **.e01* files. A mount point, `raw`
    in this example, is created with `mkdir` and will contain the raw image file:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例展示了一组**.e01*文件。通过`mkdir`创建了一个挂载点，在本例中为`raw`，该挂载点将包含原始镜像文件：
- en: '[PRE8]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'The ewfmount tool creates a FUSE filesystem containing a virtual raw image
    from one or more EWF files. You can run `ewfmount` command with the first of the
    EnCase EWF files and the mount point to access a raw image file like this:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: ewfmount工具创建了一个FUSE文件系统，其中包含一个来自一个或多个EWF文件的虚拟原始镜像。您可以使用第一个EnCase EWF文件和挂载点运行`ewfmount`命令来访问一个原始镜像文件，如下所示：
- en: '[PRE9]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'You can then operate on this virtual raw image file using tools that don’t
    support EWF formats directly. In the following example, a hex editor (without
    EWF support) is used in sector mode to analyze the raw image:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，您可以使用不直接支持EWF格式的工具来操作这个虚拟原始镜像文件。在下面的例子中，使用十六进制编辑器（不支持EWF）在扇区模式下分析原始镜像：
- en: '[PRE10]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'The kpartx tool is again useful to identify partitions and create corresponding
    loop devices, enabling the use of tools that can operate on block devices and
    allowing the mounting of the filesystems for regular browsing. The kpartx output
    of the **.e01* files mounted with ewfmount is shown here:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: kpartx工具再次用于识别分区并创建相应的环回设备，从而使可以使用操作块设备的工具，并允许挂载文件系统进行常规浏览。以下是使用ewfmount挂载的**.e01*文件的kpartx输出：
- en: '[PRE11]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Let’s continue using this example to create a mount point for a partition and
    mount and access a filesystem:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们继续使用这个例子来为一个分区创建挂载点，并挂载和访问文件系统：
- en: '[PRE12]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: In this example, a mount point corresponding to the partition is created in
    the local directory, the partition device is mounted on it, and the file-system
    is accessed with `ls`. If possible, avoid the use of */mnt* or other shared mount
    directories when mounting evidence files and containers. It is easier to perform
    forensic work when the mount points for an image are in the same working directory
    as other related case files.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 在此示例中，创建了一个与分区对应的挂载点并将分区设备挂载到该点，然后通过`ls`访问文件系统。如果可能，避免在挂载证据文件和容器时使用*/mnt*或其他共享挂载目录。当镜像的挂载点与其他相关案件文件位于同一工作目录时，取证工作会更容易进行。
- en: 'As before, when the work is completed, you need to clean up the mounts and
    virtual files. Again, this is done in the reverse order:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 如之前所述，当工作完成后，您需要清理挂载点和虚拟文件。这一步依旧按照反向顺序进行：
- en: '[PRE13]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The `fusermount` command is shown in this example, but the standard Linux `umount`
    command would also work. Make sure your current working directory is not inside
    the mount point and that no programs have open files inside the mount points.
    Both conditions will cause these cleanup steps to fail.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 本示例中展示了`fusermount`命令，但标准的Linux `umount`命令也可以使用。确保您的当前工作目录不在挂载点内，并且没有程序在挂载点内打开文件。如果满足这两个条件，清理步骤将会失败。
- en: 'When using SquashFS forensic evidence containers, you can access the raw image
    by mounting the **.sfs* file with `sfsimage -m`, creating the partition devices,
    and then mounting the desired partition. You can then execute regular commands
    on the subject image’s filesystem. A complete example is shown here:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 SquashFS 法医证据容器时，您可以通过使用 `sfsimage -m` 挂载 **.sfs** 文件，创建分区设备，然后挂载所需的分区来访问原始镜像。然后，您可以在目标镜像的文件系统上执行常规命令。完整的示例如下：
- en: '[PRE14]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Once you are finished accessing the raw image and its filesystems, clean up
    with SquashFS forensic evidence containers is also done in reverse. The `sfsimage
    -u` command unmounts a SquashFS filesytem as shown in this example:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 完成访问原始镜像及其文件系统后，SquashFS 法医证据容器的清理过程也需要反向操作。`sfsimage -u` 命令卸载 SquashFS 文件系统，如本示例所示：
- en: '[PRE15]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: This section has demonstrated several methods for accessing the contents of
    forensic formats, both as block devices and as regular filesystems. The ewfmount
    tool also works with FTK SMART files. Afflib has a similar tool called affuse
    for mounting **.aff* files. Both ewfmount and affuse can operate on single or
    split files of their respective formats.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 本节演示了几种访问法医格式内容的方法，既可以作为块设备，也可以作为常规文件系统。ewfmount 工具也适用于 FTK SMART 文件。Afflib
    有一个类似的工具叫做 affuse，用于挂载 **.aff** 文件。ewfmount 和 affuse 都可以在各自格式的单个文件或分割文件上操作。
- en: Note that many forensic tools (Sleuth Kit, for example) are able to operate
    directly on forensic formats without the need for a raw block device or raw file.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，许多法医工具（例如 Sleuth Kit）能够直接操作法医格式，而无需原始块设备或原始文件。
- en: '***Prepare Boot Images with xmount***'
  id: totrans-55
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***使用 xmount 准备启动镜像***'
- en: Forensic investigators often want to examine a subject drive image with nonforensic
    tools, such file managers, office suites, applications, or other file viewer tools.
    This can be done by making the drive contents safely available over a read-only
    mount for the local examiner machine to access.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 法医调查员通常希望使用非法医工具（如文件管理器、办公套件、应用程序或其他文件查看工具）检查目标驱动器镜像。这可以通过使驱动器内容通过只读挂载安全地提供给本地考官机器访问来实现。
- en: In some cases, it is useful to boot a subject drive in a VM to observe and interact
    directly with the live subject environment. This allows you to view the subject’s
    desktop and use the installed programs of the subject PC. To do this, you can
    use a number of tools described in this section.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些情况下，启动目标驱动器到虚拟机中进行观察和直接与目标环境互动是有用的。这允许您查看目标桌面并使用目标计算机上安装的程序。为此，您可以使用本节中描述的多种工具。
- en: The xmount (pronounced “crossmount”) tool creates a virtual disk image that
    you can boot using VM software, such as VirtualBox or kvmqemu. The xmount tool
    allows you to simulate a read-write drive, making the VM think the disk is writable,
    but it continues to protect the image in a read-only state. Multiple VM output
    formats are available, including raw, DMG, VDI, VHD, VMDK, and VMDKS.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: xmount（发音为“crossmount”）工具创建一个虚拟磁盘镜像，您可以使用虚拟机软件（如 VirtualBox 或 kvmqemu）启动。xmount
    工具允许您模拟一个读写驱动器，使虚拟机认为磁盘是可写的，但它仍然保持镜像为只读状态。提供多种虚拟机输出格式，包括 raw、DMG、VDI、VHD、VMDK
    和 VMDKS。
- en: The input formats include forensically acquired image files, such as **.raw*,
    EnCase **.ewf*, and AFFlib **.aff* files.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 输入格式包括法医获取的镜像文件，如 **.raw**、EnCase **.ewf** 和 AFFlib **.aff** 文件。
- en: 'Here is an example of a raw image (*image.raw*) set up with xmount as a VirtualBox
    **.vdi* file:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个使用 xmount 设置的原始镜像（*image.raw*），作为 VirtualBox **.vdi** 文件的示例：
- en: '[PRE16]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: In this example, the directory *virtual* is created to hold the virtual image
    file (it will be FUSE mounted). From an existing *image.raw* file, the `xmount`
    command creates a write-cached VirtualBox VDI image in the *./virtual* directory.
    This is just a virtual representation of the image file; it is not copied or converted
    (thus not wasting disk space on the examiner machine). The `--in` and `--out`
    flags specify the image format used. The input formats must be raw, AFF, or EWF.
    Multiple output formats are possible.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 在此示例中，创建了一个名为 *virtual* 的目录，用于保存虚拟镜像文件（该文件将通过 FUSE 挂载）。从现有的 *image.raw* 文件中，`xmount`
    命令在 *./virtual* 目录中创建一个写缓存的 VirtualBox VDI 镜像。这仅仅是镜像文件的虚拟表示；它不会被复制或转换（因此不会浪费考官机器的磁盘空间）。`--in`
    和 `--out` 标志指定使用的镜像格式。输入格式必须是 raw、AFF 或 EWF。可以选择多种输出格式。
- en: Booting an OS image in a VM can be challenging when the installed OS is expecting
    a different hardware configuration than provided by the VM. Typically, this is
    less of an issue with Linux installations but can be problematic with Windows
    and OS X. To solve this problem, two tools, opengates and openjobs, were created
    to prepare Windows and OS X images for safely booting subject disks in a virtual
    environment. I won’t cover how to use opengates and openjobs, but you can find
    more information about them at *[https://www.pinguin.lu/openjobs/](https://www.pinguin.lu/openjobs/)*
    and *[https://www.pinguin.lu/opengates/](https://www.pinguin.lu/opengates/)*.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 在虚拟机中启动操作系统镜像可能会遇到困难，特别是当已安装的操作系统期望的硬件配置与虚拟机提供的配置不同。通常，Linux安装较少遇到此问题，但Windows和OS
    X可能会出现此问题。为了解决这个问题，创建了两个工具，opengates和openjobs，用于准备Windows和OS X镜像，以便在虚拟环境中安全启动目标磁盘。我不会介绍如何使用opengates和openjobs，但你可以在*[https://www.pinguin.lu/openjobs/](https://www.pinguin.lu/openjobs/)*和*[https://www.pinguin.lu/opengates/](https://www.pinguin.lu/opengates/)*上找到更多相关信息。
- en: 'When you no longer need the VM image, you can clean up by unmounting the virtual
    image and removing the mount point directory:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 当你不再需要虚拟机镜像时，可以通过卸载虚拟镜像并删除挂载点目录来进行清理：
- en: '[PRE17]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: A *xmount.cache* file containing data written during the use of the VM might
    exist. You can save the file if you need to continue the previous VM session,
    or you can remove it.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 一个包含在使用虚拟机时写入数据的*xmount.cache*文件可能存在。如果需要继续之前的虚拟机会话，可以保存该文件，或者选择删除它。
- en: '**VM Images**'
  id: totrans-67
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**虚拟机镜像**'
- en: With the increasing performance of home computers, hardware virtualization in
    most modern CPUs, and the availability of inexpensive or free virtualization software,
    there is an increased need to analyze the contents of VM images. In some cases,
    you might find many VM images on subject PCs. This section focuses on accessing
    common VM image file types such as QCOW2, VDI, VMDK, and VHD.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 随着家庭计算机性能的提升、现代CPU支持的硬件虚拟化和廉价或免费的虚拟化软件的可用性，对虚拟机镜像内容的分析需求不断增加。在某些情况下，你可能会在目标PC上发现许多虚拟机镜像。本节将重点介绍如何访问常见的虚拟机镜像文件类型，如QCOW2、VDI、VMDK和VHD。
- en: '***QEMU QCOW2***'
  id: totrans-69
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***QEMU QCOW2***'
- en: The QCOW2 format is a common VM image type found on Linux and used by the QEMU
    emulator. In this section, I’ll make a QCOW2 image available as a block device
    and safely mount it for browsing.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: QCOW2格式是Linux中常见的虚拟机镜像类型，并且被QEMU模拟器使用。在本节中，我将展示如何将QCOW2镜像作为块设备提供，并安全地挂载以供浏览。
- en: The libqcow-utils package (written by Joachim Metz, author of ewflib) contains
    the qcowinfo and qcowmount tools. You can use both tools in the same way as you
    used the ewfinfo and ewfmount tools in previous examples. But the following example
    shows an alternative method using the `qemu-img` command, the nbd kernel module,
    and the qemu-nbd tool. This method offers performance advantages because it operates
    in the kernel and saves you a few steps because you don’t need to use kpartx.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: libqcow-utils软件包（由Joachim Metz编写，ewflib的作者）包含qcowinfo和qcowmount工具。你可以像使用之前示例中的ewfinfo和ewfmount工具一样使用这两个工具。但以下示例展示了使用`qemu-img`命令、nbd内核模块和qemu-nbd工具的替代方法。这种方法具有性能优势，因为它在内核中运行，并且省去了几个步骤，因为你不需要使用kpartx。
- en: 'Given a **.qcow2* file, the `qemu-img` command can provide a summary of the
    file:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 给定一个**.qcow2**文件，`qemu-img`命令可以提供该文件的概述：
- en: '[PRE18]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'To access a QCOW image in a raw image representation with nbd, you need to
    load the nbd kernel module:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 若要使用nbd以原始镜像表示访问QCOW镜像，你需要加载nbd内核模块：
- en: '[PRE19]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Unlike with the `losetup` command, the device is not automatically chosen.
    A */dev/nbd** device needs to be specified as follows:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 与`losetup`命令不同，设备不会自动选择。需要按如下方式指定一个*/dev/nbd*设备：
- en: '[PRE20]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Here, the QCOW2 image file was connected to the kernel module in read-only
    mode, and the partition device was automatically detected. You can use this raw
    device with forensic tools, as shown in this example:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，QCOW2镜像文件已连接到内核模块，并以只读模式挂载，分区设备已自动检测。你可以像示例中所示，使用此原始设备进行取证工具分析：
- en: '[PRE21]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'The partition devices (the raw device name with `p1` in this example) are also
    ready for you to use directly with forensic tools. To illustrate, here’s the `fls`
    command operating directly on a filesystem on the partition device:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 分区设备（本示例中的原始设备名称加上`p1`）也可以直接用于取证工具。为了说明这一点，以下是直接在分区设备的文件系统上操作的`fls`命令：
- en: '[PRE22]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Mounting the devices locally for browsing is trivial. A local mount point directory
    is created, and the filesystem is mounted normally, as follows:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 在本地挂载设备进行浏览是很简单的。创建一个本地挂载点目录，并按正常方式挂载文件系统，如下所示：
- en: '[PRE23]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'The cleanup here is similar to the examples using loop devices, but with fewer
    steps. All processes should close files, and you should leave the mounted directory
    so it can be unmounted. A `qemu-nbd disconnect` command specifying the device
    name will unregister the device from the kernel, like so:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的清理过程类似于使用 loop 设备的示例，但步骤更少。所有进程应该关闭文件，且在卸载前需要离开挂载目录。`qemu-nbd disconnect`
    命令指定设备名称，将设备从内核中注销，如下所示：
- en: '[PRE24]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: An optional step is to remove the kernel module using `rmmod nbd`. But there
    is no harm in leaving it in if you’ll be doing more QCOW mounts. You can also
    autoload the nbd module at boot by adding it to the */etc/modules* file.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 一个可选步骤是使用 `rmmod nbd` 移除内核模块。但如果您还会进行更多 QCOW 挂载，保留它也没有问题。您还可以通过将其添加到 */etc/modules*
    文件中，在启动时自动加载 nbd 模块。
- en: '***VirtualBox VDI***'
  id: totrans-87
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***VirtualBox VDI***'
- en: VirtualBox is an open source project maintained by Oracle (formerly Sun Microsystems).
    Although it supports multiple VM image formats, VirtualBox VDI images are used
    in the examples that follow. The same `qemu-nbd` command is used as before but
    with an OpenSolaris image.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: VirtualBox 是由 Oracle（前身为 Sun Microsystems）维护的开源项目。虽然它支持多种虚拟机镜像格式，但以下示例中使用的是
    VirtualBox VDI 镜像。与之前一样，使用相同的 `qemu-nbd` 命令，但这次使用的是 OpenSolaris 镜像。
- en: 'The VirtualBox software package includes a number of utilities; the VBoxManage
    tool is shown here, providing information about the VDI image:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: VirtualBox 软件包包括多个实用工具；这里显示的是 VBoxManage 工具，提供有关 VDI 镜像的信息：
- en: '[PRE25]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'You can mount VirtualBox images using `qemu-nbd` and the nbd kernel module
    (as you saw in the previous section using QCOW2). The Open-Solaris example shown
    here is slightly different from the partitioning scheme Windows and Linux use.
    Multiple disk slices^([1](footnote.xhtml#fn42)) are also shown:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用 `qemu-nbd` 和 nbd 内核模块来挂载 VirtualBox 镜像（如前节中使用 QCOW2 时所见）。这里展示的 Open-Solaris
    示例与 Windows 和 Linux 使用的分区方案略有不同。也展示了多个磁盘切片^([1](footnote.xhtml#fn42))：
- en: '[PRE26]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: In this example, a single Solaris partition (`p1`) contains multiple slices
    (`p5`, `p6`, `p7`, and `p8`).
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 在本示例中，单一的 Solaris 分区（`p1`）包含多个切片（`p5`、`p6`、`p7` 和 `p8`）。
- en: You can use the same methods as in the previous QEMU example to access the raw
    and partition devices, then mount the partitions as read-only to a local mount
    point. Here again, you don’t need to use kpartx to find the partitions, because
    the kernel does it automatically. Once you are finished accessing the partitions
    (or slices, here), perform the cleanup steps to unmount filesystems and disconnect
    the nbd device.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用与前面 QEMU 示例相同的方法访问原始设备和分区设备，然后将分区以只读方式挂载到本地挂载点。这里同样不需要使用 kpartx 来查找分区，因为内核会自动完成。访问完分区（或切片）后，执行清理步骤，卸载文件系统并断开
    nbd 设备连接。
- en: '***VMWare VMDK***'
  id: totrans-95
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***VMWare VMDK***'
- en: 'The *Virtual Machine DisK (VMDK)* format is used by VMWare’s VM software products.
    The following example uses the libvmdk-utils software package on an Apple Lion
    VMDK image split into multiple parts:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: '*虚拟机磁盘（VMDK）*格式由 VMWare 的虚拟机软件产品使用。以下示例使用 libvmdk-utils 软件包在 Apple Lion VMDK
    镜像上，该镜像被分割成多个部分：'
- en: '[PRE27]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'You can retrieve information about the assembled image and each of the “Extents”
    using `vmdkinfo`:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用 `vmdkinfo` 获取有关已组装镜像及每个“扩展”（Extents）的信息：
- en: '[PRE28]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Creating a mount point and mounting the image makes it accessible as a raw
    image file:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 创建挂载点并挂载镜像文件后，可以将其作为原始镜像文件进行访问：
- en: '[PRE29]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Using kpartx, as shown earlier in the chapter, will create the associated disk
    and partition block devices. You can then use forensic analysis tools on them
    directly or mount them on the local machine to browse the filesystem.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 如本章前面所示，使用 kpartx 将创建关联的磁盘和分区块设备。然后，您可以直接使用取证分析工具对其进行分析，或将其挂载到本地机器上以浏览文件系统。
- en: '***Microsoft VHD***'
  id: totrans-103
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***Microsoft VHD***'
- en: A number of methods help you make the Microsoft VHD virtual image format accessible.
    For example, you can use the qemu-nbd method or use the libvhdi-utils with vhdiinfo
    and vhdimount.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 有多种方法可以使 Microsoft VHD 虚拟镜像格式变得可访问。例如，您可以使用 qemu-nbd 方法或使用 libvhdi-utils 配合
    vhdiinfo 和 vhdimount。
- en: A third method is available using the blktap-utils with the Xen blktap xapi
    interface. Similar to the nbd method, the blktap requires you to insert a kernel
    module and manually allocate a device. A tapdisk process is spawned, attached
    to the driver, and instructed to open a disk image. The manual pages for blktap-utils
    aren’t very useful, but you can find a description on the Xen website at *[http://wiki.xen.org/wiki/Mounting_a_.vhd_disk_image_using_blktap/tapdisk](http://wiki.xen.org/wiki/Mounting_a_.vhd_disk_image_using_blktap/tapdisk)*
    and at *[http://lists.xen.org/archives/html/xen-api/2012-05/msg00149.html](http://lists.xen.org/archives/html/xen-api/2012-05/msg00149.html)*.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种方法是使用带有 Xen blktap xapi 接口的 blktap-utils。与 nbd 方法类似，blktap 需要你插入内核模块并手动分配一个设备。会启动一个
    tapdisk 进程，附加到驱动程序，并指示其打开磁盘映像。blktap-utils 的手册页面不太有用，但你可以在 Xen 网站上找到相关描述，链接为 *[http://wiki.xen.org/wiki/Mounting_a_.vhd_disk_image_using_blktap/tapdisk](http://wiki.xen.org/wiki/Mounting_a_.vhd_disk_image_using_blktap/tapdisk)*
    和 *[http://lists.xen.org/archives/html/xen-api/2012-05/msg00149.html](http://lists.xen.org/archives/html/xen-api/2012-05/msg00149.html)*。
- en: To complete this section, I’ll repeat the process for setting up devices using
    the libvhdi tools. For simplicity, the previous examples used the privileged root
    user. But the following examples demonstrate a nonprivileged user authorized to
    use `sudo`.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 为了完成这一部分，我将重复使用 libvhdi 工具设置设备的过程。为了简便起见，之前的示例使用了特权 root 用户。但接下来的示例演示了授权使用`sudo`的非特权用户。
- en: To run the FUSE `mount` and `unmount` commands as a nonprivileged user, you
    need to set *user_allow_other* in */etc/fuse.conf*.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 要作为非特权用户运行 FUSE的`mount`和`unmount`命令，你需要在*/etc/fuse.conf*中设置*user_allow_other*。
- en: 'You can find information about the image using `vhdiinfo`, and no special privileges
    are required:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用`vhdiinfo`来查找关于映像的信息，不需要特别的权限：
- en: '[PRE30]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'You can FUSE mount the image without root privileges, but you need to explicitly
    instruct the `vhdimount` command to allow the root user access by adding the `-X
    allow_root` flag. This flag is also needed to allow root to perform further actions
    through `sudo` (like creating block devices with kpartx):'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在没有 root 权限的情况下使用 FUSE 挂载映像，但你需要明确地指示`vhdimount`命令通过添加`-X allow_root`标志来允许
    root 用户访问。这个标志也需要允许 root 通过`sudo`执行进一步的操作（例如使用 kpartx 创建块设备）：
- en: '[PRE31]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'The raw image is now available in the *./raw* directory, and you can access
    it with standard tools. To create loop and mapper devices, run `kpartx` with the
    `sudo` command. Once the devices are created, you can access them with tools via
    the `sudo` command. The `sudo` command is required for all block device access.
    Examples with kpartx and fls are shown here:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 原始映像现在可以在*./raw*目录中找到，你可以使用标准工具访问它。要创建循环设备和映射器设备，使用`sudo`命令运行`kpartx`。一旦设备创建完成，你可以通过`sudo`命令访问它们。所有块设备的访问都需要`sudo`命令。以下是使用
    kpartx 和 fls 的示例：
- en: '[PRE32]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Mounting the filesystem also requires `sudo`, and explicitly specifying `-o
    ro` mounts it as read-only. An example of creating a mount point, mounting the
    filesystem from the previous example, and accessing it with `ls` is shown here:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 挂载文件系统同样需要`sudo`，并且通过明确指定`-o ro`可以将其挂载为只读。这里展示了创建挂载点、挂载上一个示例中的文件系统并通过`ls`命令访问它的示例：
- en: '[PRE33]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'The cleanup of this session requires `sudo` for unmounting the raw image and
    removing the loop and mapper devices. You can remove the FUSE mount of the **.vhd*
    file without root privileges. These steps are shown here:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 清理此会话需要`sudo`来卸载原始映像并移除循环设备和映射器设备。你可以在没有 root 权限的情况下移除**.vhd**文件的 FUSE 挂载。以下是步骤：
- en: '[PRE34]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: You configure the `sudo` command by editing the */etc/sudoers* file. Many of
    the examples in this book use the root user for simplicity’s sake to reduce the
    number of commands on an already complex command line. It’s good practice to work
    as a nonprivileged user with security mechanisms such as `sudo`.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过编辑*/etc/sudoers*文件来配置`sudo`命令。本书中的许多示例为了简化命令行操作，使用了 root 用户，减少了复杂命令的数量。作为一种良好的实践，建议作为非特权用户工作，并使用诸如`sudo`之类的安全机制。
- en: '**OS-Encrypted Filesystems**'
  id: totrans-119
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**操作系统加密文件系统**'
- en: Now let’s look at accessing popular encrypted filesystems. The focus is not
    on key recovery (although I do provide a couple of suggestions) but on accessing
    the filesystems with a known key. It’s assumed the keys or passwords are available
    from memory dumps, escrow/backup in enterprise organizations, individuals legally
    compelled to provide them, victims offering to help, commercial recovery services/software,
    or other sources.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们来看一下如何访问常见的加密文件系统。重点不在于密钥恢复（虽然我提供了一些建议），而是如何使用已知密钥访问文件系统。假设密钥或密码可以通过内存转储、企业组织中的托管/备份、依法强制提供的个人、愿意提供帮助的受害者、商业恢复服务/软件或其他来源获得。
- en: You can determine the type of filesystem encryption with various partition-analysis
    tools that can identify headers, magic numbers, and other artifacts unique to
    a particular encrypted filesystem type. You’ll find an overview of identifying
    filesystem encryption in a forensic context at *[http://encase-forensic-blog.guidancesoftware.com/2014/04/version-7-tech-tip-spotting-full-disk.html](http://encase-forensic-blog.guidancesoftware.com/2014/04/version-7-tech-tip-spotting-full-disk.html)*.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用各种分区分析工具来确定文件系统加密的类型，这些工具能够识别头部、魔法数字以及其他特定加密文件系统类型的独特标志物。在取证环境中，你可以在 *[http://encase-forensic-blog.guidancesoftware.com/2014/04/version-7-tech-tip-spotting-full-disk.html](http://encase-forensic-blog.guidancesoftware.com/2014/04/version-7-tech-tip-spotting-full-disk.html)*
    找到有关识别文件系统加密的概述。
- en: In this section, you’ll find the information about a particular encrypted image
    needed to create an unencrypted block device or file that you can access using
    forensic tools or safely mount for local browsing.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，你将找到有关特定加密镜像的信息，这些信息用于创建一个未加密的块设备或文件，你可以使用取证工具访问，或者安全地挂载以进行本地浏览。
- en: '***Microsoft BitLocker***'
  id: totrans-123
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***微软 BitLocker***'
- en: Microsoft’s current default filesystem encryption is BitLocker. It encrypts
    at the block level, protecting entire volumes. A variant of BitLocker designed
    for removable media is called BitLocker-To-Go, which uses encrypted container
    files on a regular unencrypted filesystem. Two open source tools, dislocker and
    libbde, are shown in the examples in this section.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 微软当前的默认文件系统加密是 BitLocker。它在块级别进行加密，保护整个卷。为可移动介质设计的 BitLocker 变体称为 BitLocker-To-Go，它在常规的未加密文件系统上使用加密容器文件。本节中的示例展示了两个开源工具：dislocker
    和 libbde。
- en: Written by Romain Coltel, you’ll find the dislocker package at *[https://github.com/Aorimn/dislocker/](https://github.com/Aorimn/dislocker/)*.
    It provides various tools for handling BitLocker volumes, including viewing metadata,
    creating decrypted image files, and FUSE mounting volumes.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 由 Romain Coltel 编写，你可以在 *[https://github.com/Aorimn/dislocker/](https://github.com/Aorimn/dislocker/)*
    找到 dislocker 包。它提供了处理 BitLocker 卷的各种工具，包括查看元数据、创建解密的镜像文件和 FUSE 挂载卷。
- en: The dislocker-find tool scans all attached partition devices and specified files
    to identify the existence of any BitLocker volumes. Scanning for BitLocker devices
    might not be necessary if the subject device was already identified during the
    process of attaching it to the acquisition host.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: dislocker-find 工具扫描所有附加的分区设备和指定文件，以识别任何 BitLocker 卷的存在。如果在将设备附加到获取主机的过程中已经识别了目标设备，可能就不需要扫描
    BitLocker 设备了。
- en: 'The `dislocker-metadata` command provides an overview of a BitLocker drive.
    The next example is an image taken from a USB thumb drive. The entire drive is
    encrypted, and it doesn’t have a partition table. The image file can be queried
    as follows:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: '`dislocker-metadata` 命令提供了 BitLocker 驱动器的概览。下一个示例来自一个 USB 闪存驱动器的镜像。整个驱动器都被加密，并且没有分区表。可以通过以下方式查询该镜像文件：'
- en: '[PRE35]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: The output of this command provides a lot of detailed cryptographic information
    not shown here. You can save the output of `dislocker-metadata` to a text file
    for documentation purposes. This command can also operate directly on attached
    devices.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 此命令的输出提供了许多详细的加密信息，这里未展示。你可以将 `dislocker-metadata` 的输出保存为文本文件，以供文档记录使用。该命令也可以直接在附加的设备上操作。
- en: As in previous password and encryption examples, it’s assumed that you have
    the key. Some commercial tools are available to attempt password brute force to
    recover the key. In addition, you can use a volatility plug-in to extract the
    FVEK from a memory image (*[https://github.com/elceef/bitlocker/](https://github.com/elceef/bitlocker/)*),
    and you could use this tool in conjunction with the inception memorydumping tool.
    The use of these tools is not covered here.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 与之前的密码和加密示例一样，假设您已经拥有密钥。有些商业工具可用于尝试密码暴力破解以恢复密钥。此外，您还可以使用波动性插件从内存镜像中提取 FVEK（*[https://github.com/elceef/bitlocker/](https://github.com/elceef/bitlocker/)*），并且可以将该工具与
    inception memorydumping 工具一起使用。这里不涉及这些工具的使用。
- en: 'You can create a virtual file or block device to operate on a decrypted view
    of the disk image “in place.” The process to do so is similar to the examples
    in “[VM Images](ch08.xhtml#ch08lev1sec02)” on [page 237](ch08.xhtml#page_237).
    The dislocker software package provides a tool to create a FUSE filesystem with
    virtual representation of the decrypted volume:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以创建一个虚拟文件或块设备，在“原地”操作解密后的磁盘镜像视图。执行此过程与 “[VM Images](ch08.xhtml#ch08lev1sec02)”
    中的示例类似，详见 [第 237 页](ch08.xhtml#page_237)。dislocker 软件包提供了一个工具，可以创建一个虚拟表示解密卷的 FUSE
    文件系统：
- en: '[PRE36]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'The file that appears in the *clear* directory is a decrypted representation
    of the encrypted filesystem, and you can operate on it using regular forensic
    tools. An example using Sleuth Kit’s fsstat is shown here:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 出现在 *clear* 目录中的文件是加密文件系统的解密表示，您可以使用常规的取证工具对其进行操作。以下是使用 Sleuth Kit 的 fsstat
    工具的示例：
- en: '[PRE37]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'You can safely mount the decrypted filesystem image for normal browsing. The
    `mount` command has a `loop` option, which allows a partition image file to be
    directly mounted, as shown here:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以安全地挂载解密后的文件系统镜像以进行正常浏览。`mount` 命令具有 `loop` 选项，允许直接挂载分区镜像文件，如下所示：
- en: '[PRE38]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'The cleanup in this example is a simple matter of unmounting the files’ mount
    point, removing the FUSE mount, and deleting the mount directories:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 本示例中的清理工作很简单，只需卸载文件的挂载点，移除 FUSE 挂载，并删除挂载目录：
- en: '[PRE39]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Note that the preceding examples were done with root privileges to reduce complexity
    and make them easier to understand. You can perform the same commands as a nonprivileged
    user, as shown here:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，前面的示例是使用 root 权限执行的，以减少复杂性并使其更易于理解。您可以作为非特权用户执行相同的命令，如下所示：
- en: '[PRE40]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Here `dislocker-fuse` passes `-o allow_root` to the FUSE driver, allowing `sudo`
    to be used for mounting and unmounting. The `uid=holmes` ensures that Mr. Holmes
    can access the mounted files without root privileges. It’s assumed that Mr. Holmes
    is a member of the FUSE Unix group, and the */etc/fuse.conf* file contains the
    line *user_allow_other*.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`dislocker-fuse` 将 `-o allow_root` 传递给 FUSE 驱动程序，允许使用 `sudo` 进行挂载和卸载。`uid=holmes`
    确保 Holmes 先生可以在没有 root 权限的情况下访问挂载的文件。假设 Holmes 先生是 FUSE Unix 组的成员，并且 */etc/fuse.conf*
    文件中包含 *user_allow_other* 行。
- en: Using dislocker, you can provide three possible credentials to unlock a BitLocker
    container. A `-u` flag (used in the previous example) specifies that the user’s
    password be requested. A `-p` flag provides a recovery password (48 digits long).
    And an `-f` flag specifies a key file (BEK file).
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 dislocker，您可以提供三种可能的凭证来解锁 BitLocker 容器。`-u` 标志（在前面的示例中使用）指定请求用户密码。`-p` 标志提供恢复密码（长达
    48 位）。`-f` 标志指定一个密钥文件（BEK 文件）。
- en: 'Using a recovery password (`-p`) instead of a user password (`-u`) requires
    manually keying in the 48-digit recovery password, as follows:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 使用恢复密码（`-p`）而不是用户密码（`-u`）需要手动输入 48 位恢复密码，如下所示：
- en: '[PRE41]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'The non-root version of this command passes flags to FUSE, which allows for
    mounting with `sudo`:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 此命令的非 root 版本将标志传递给 FUSE，允许使用 `sudo` 进行挂载：
- en: '[PRE42]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'You can also decrypt the BitLocker image and save it separately as a regular
    filesystem image (only the specified volume is saved, not the partition table
    or other partitions). This will take some time depending on the size of the BitLocker
    image, as the entire image is decrypted and written to a new image file on the
    disk. You’ll need to do some capacity planning, because the two images, encrypted
    and decrypted, will take up space on the acquisition host. You can create a decrypted
    version of the volume as follows:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以解密 BitLocker 镜像，并将其单独保存为常规的文件系统镜像（仅保存指定的卷，而不是分区表或其他分区）。根据 BitLocker 镜像的大小，这将需要一些时间，因为整个镜像会被解密并写入到磁盘上的新镜像文件。您需要进行一些容量规划，因为加密和解密后的两个镜像会占用获取主机的存储空间。您可以按如下方式创建解密后的卷版本：
- en: '[PRE43]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: The resulting decrypted image file is the same size as the original because
    each BitLocker block was decrypted and the cleartext block written to the new
    image. This command does not need root privileges.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 解密后的镜像文件与原始文件的大小相同，因为每个BitLocker块都已被解密，并将明文块写入新镜像中。此命令不需要root权限。
- en: 'Now you can mount the decrypted BitLocker image file and access it as a partition
    using a `mount` command with a `loop` option:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你可以挂载解密后的BitLocker镜像文件，并使用带有`loop`选项的`mount`命令将其作为分区访问：
- en: '[PRE44]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'The only command that is different for non-root use is `mount`:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 唯一不同的命令是非root用户使用的`mount`：
- en: '[PRE45]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: Because BitLocker is the default filesystem encryption on the dominant OS platform,
    it’s worth providing a second example using a different software package. The
    libbde package (written by Joachim Metz, the author of ewflib) also provides libraries
    and tools to access BitLocker images.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 由于BitLocker是主流操作系统平台上的默认文件系统加密，因此提供第二个使用不同软件包的示例是很有价值的。libbde包（由ewflib的作者Joachim
    Metz编写）也提供了访问BitLocker镜像的库和工具。
- en: The example shown next is slightly more complex than the previous one, because
    it involves a notebook disk with a regular partition table (in contrast to a USB
    thumb drive without a partition table). After calculating the offsets from the
    mmls output, the bdeinfo tool is demonstrated to provide a compact overview of
    the BitLocker container.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个示例比前一个稍微复杂一些，因为它涉及到一个带有常规分区表的笔记本硬盘（与没有分区表的USB闪存驱动器不同）。在计算了来自mmls输出的偏移量后，展示了bdeinfo工具，它提供了一个紧凑的BitLocker容器概览。
- en: Both dislocker and libbde can be given a byte offset for the start of the BitLocker-encrypted
    volume. But this is unnecessary when working with image files of volumes/partitions
    or devices without partitions. In this example, an acquired image has a partition
    table, and the BitLocker-encrypted volume offset (in bytes) must be calculated.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 无论是dislocker还是libbde，都可以给定字节偏移量，表示BitLocker加密卷的起始位置。但在处理没有分区的卷/分区或设备的镜像文件时，这一点是多余的。在本示例中，获取的镜像有一个分区表，因此必须计算BitLocker加密卷的偏移量（以字节为单位）。
- en: '**NOTE**'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*Always be sure about the units used for a command. Some tools use sector offsets,
    and others use byte offsets. It is important to distinguish and convert between
    the two.*'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: '*始终确保了解命令使用的单位。一些工具使用扇区偏移量，而另一些使用字节偏移量。区分并转换这两者非常重要。*'
- en: 'The next example demonstrates how to determine the byte offset. The Sleuth
    Kit `mmls` command displays the partition table and the sector offsets for each
    partition. The sector offset must be converted into a byte offset, which can be
    used with the decryption tools:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个示例演示了如何确定字节偏移量。Sleuth Kit的`mmls`命令显示了分区表和每个分区的扇区偏移量。必须将扇区偏移量转换为字节偏移量，然后可以与解密工具一起使用：
- en: '[PRE46]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'You can convert the sector offset shown by `mmls` to a byte offset by multiplying
    by the sector size. On the command line it is convenient to use Bash math expansion.
    In this example, the sector offset is 4098048 and the sector size is 512\. Multiplying
    these gives a byte offset of 2098200576\. You can use this value for the `bdeinfo`
    command as follows:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过将`mmls`显示的扇区偏移量乘以扇区大小，将其转换为字节偏移量。在命令行中，使用Bash数学扩展非常方便。在本示例中，扇区偏移量是4098048，扇区大小是512。将这两个数相乘，得到字节偏移量为2098200576。你可以将此值用于`bdeinfo`命令，如下所示：
- en: '[PRE47]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'The `bdemount` command operates similarly to the `dislocker` command and creates
    a virtual file that represents the decrypted image (the full key has been shortened
    here):'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: '`bdemount`命令的操作方式类似于`dislocker`命令，并创建一个虚拟文件，表示解密后的镜像（这里的完整密钥已简化）：'
- en: '[PRE48]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: The file will appear in the *./raw* directory, where you can analyze it directly
    or mount it to a loop device for regular browsing. The mount commands are the
    same as the previous BitLocker example, so they’re not repeated here.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 文件将出现在*./raw*目录中，你可以直接分析它，或将其挂载到循环设备上进行常规浏览。挂载命令与前面的BitLocker示例相同，因此此处不再重复。
- en: '***Apple FileVault***'
  id: totrans-166
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***Apple FileVault***'
- en: Apple’s filesystem encryption built into OS X is FileVault. It is also a block-level
    encryption system, and several open source tools are available to decrypt it.
    Two tools I’ll describe here are libfvde and VFDecrypt. (The libfvde software
    package was written by Omar Choudary and Joachim Metz, and you’ll find it at *[https://github.com/libyal/libfvde/](https://github.com/libyal/libfvde/)*.)
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 苹果的文件系统加密内置在OS X中，名为FileVault。它也是一种块级加密系统，市面上有几种开源工具可以用来解密它。我在这里描述的两个工具是libfvde和VFDecrypt。（libfvde软件包是由Omar
    Choudary和Joachim Metz编写的，你可以在* [https://github.com/libyal/libfvde/](https://github.com/libyal/libfvde/)
    *找到它。）
- en: 'Before you use the libfvde tools, you need to calculate the correct byte offset
    of the FileVault-encrypted volume. The `mmls` command provides the sector offset
    of the volume, which needs to be converted to bytes:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用libfvde工具之前，你需要计算FileVault加密卷的正确字节偏移量。`mmls`命令提供了该卷的扇区偏移量，需要将其转换为字节：
- en: '[PRE49]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: Multiplying the sector offset by the sector size using simple Bash math expansion
    provides a byte offset of 209735680, which you can use for the fvdeinfo and fvdemount
    tools.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 使用简单的Bash数学扩展将扇区偏移量乘以扇区大小可以得到一个字节偏移量209735680，可以用来进行fvdeinfo和fvdemount工具的操作。
- en: 'The fvdeinfo tool provides an overview of the FileVault-encrypted volume:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: fvdeinfo工具提供了一个FileVault加密卷的概览：
- en: '[PRE50]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'To decrypt the FileVault volume, you need to recover the *EncryptedRoot.plist.wipekey*
    file and provide either a user password or recovery key. You can find and extract
    the *wipekey* file using Sleuth Kit tools, as shown here:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 要解密FileVault卷，你需要恢复*EncryptedRoot.plist.wipekey*文件并提供用户密码或恢复密钥。你可以使用Sleuth Kit工具查找并提取*wipekey*文件，如下所示：
- en: '[PRE51]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: The recursive fls output of the Recovery HD partition uses the sector offset
    found with mmls. The output is grepped for the *EncryptedRoot.plist.wipekey* file.
    After it’s found, the icat tool is used to extract it (using the inode, which
    is 1036 in this example). Notice how a sector offset was used with fls and icat,
    and not a byte offset.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 恢复HD分区的递归fls输出使用了通过mmls找到的扇区偏移量。输出通过grep查找*EncryptedRoot.plist.wipekey*文件。找到后，使用icat工具提取该文件（使用inode，在这个例子中是1036）。注意fls和icat使用的是扇区偏移，而不是字节偏移。
- en: 'The 24-character recovery key is used with the `-r` flag and the now-recovered
    *EncryptedRoot.plist.wipekey* file. You can then use this key to create a FUSE
    mount of a decrypted representation of the volume, as shown here (the recovery
    key has been shortened):'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`-r`标志和现在恢复的*EncryptedRoot.plist.wipekey*文件，24字符的恢复密钥被使用。然后，你可以使用这个密钥创建一个解密的卷的FUSE挂载，如下所示（恢复密钥已被简化）：
- en: '[PRE52]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'You can provide a user password (`-p`) instead of a recovery key (`-r`), and
    also using the *EncryptedRoot.plist.wipekey* file, you can access the resulting
    volume image with regular forensic tools. An example using Sleuthkit’s fsstat
    on the decrypted volume is shown here:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以提供用户密码（`-p`）代替恢复密钥（`-r`），并且通过使用*EncryptedRoot.plist.wipekey*文件，你可以使用常规取证工具访问结果卷镜像。下面展示了一个使用Sleuthkit的fsstat工具在解密卷上的示例：
- en: '[PRE53]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'You can also mount this decrypted volume as a regular filesystem for browsing,
    as follows:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以将这个解密后的卷作为常规文件系统挂载进行浏览，如下所示：
- en: '[PRE54]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'When the analysis work is complete, you’ll need to do some cleanup:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 当分析工作完成后，你需要进行一些清理工作：
- en: '[PRE55]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'Note that the preceding examples were done with root privileges to reduce complexity
    and make them easier to understand. Most of the commands can be done as non-root
    with a few exceptions. Examples in which a command is different when run by a
    nonprivileged user are shown here:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，前面的示例是在root权限下完成的，以减少复杂性并使其更容易理解。大多数命令可以在非root用户下运行，但有一些例外情况。下面展示了在非特权用户下运行时命令有所不同的示例：
- en: '[PRE56]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: The `-X allow_root` string in the `fvdemount` command allows root to access
    the FUSE mounted directory. The `sudo` command is needed to mount and unmount
    the hfsplus filesystem. When you’re browsing the filesystem, you might also need
    the `sudo` command if filesystem permissions restrict access to files or directories.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: '`fvdemount`命令中的`-X allow_root`字符串允许root访问FUSE挂载目录。`sudo`命令是挂载和卸载hfsplus文件系统所需的。当浏览文件系统时，如果文件系统权限限制了对文件或目录的访问，你可能也需要使用`sudo`命令。'
- en: Several other notable open source tools exist for operating on File-Vault images.
    The VFDecrypt tool also provides decryption of FileVault images. Originally written
    by Ralf-Philipp Weinmann, David Hulton, and Jacob Appelbaum, it is now maintained
    by Drake Allegrini. You’ll find it at *[https://github.com/andyvand/VFDecrypt/](https://github.com/andyvand/VFDecrypt/)*.
    It can decrypt an image into an unencrypted volume image.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一些其他著名的开源工具可以用于操作FileVault镜像。VFDecrypt工具也提供FileVault镜像的解密。最初由Ralf-Philipp
    Weinmann、David Hulton和Jacob Appelbaum编写，现在由Drake Allegrini维护。你可以在* [https://github.com/andyvand/VFDecrypt/](https://github.com/andyvand/VFDecrypt/)*找到它。它可以将镜像解密为未加密的卷镜像。
- en: FileVault Cracking software was created by some of the same authors as VFDecrypt;
    you’ll find it at *[http://openciphers.sourceforge.net/oc/vfcrack.php](http://openciphers.sourceforge.net/oc/vfcrack.php)*.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: FileVault破解软件是由与VFDecrypt相同的一些作者创建的，你可以在* [http://openciphers.sourceforge.net/oc/vfcrack.php](http://openciphers.sourceforge.net/oc/vfcrack.php)*找到它。
- en: '***Linux LUKS***'
  id: totrans-189
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***Linux LUKS***'
- en: A number of file encryption systems are available in the open source world.
    Some, like eCryptfs or encfs, are directory based. Others, like GPG and various
    crypt tools, operate on individual files.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 开源世界中有许多文件加密系统。像eCryptfs或encfs这样的系统是基于目录的，而像GPG和各种加密工具则是针对单个文件操作的。
- en: In this section, I mainly focus on the LUKS encryption system, but I’ll also
    touch on plain dm-crypt and loop-AES. Using the cryptsetup tool, you can set up
    all three. (You can also use the cryptsetup tool to manage True-Crypt volumes,
    which I’ll describe in the following section.)
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 本节主要关注LUKS加密系统，但也会简要介绍纯dm-crypt和loop-AES。使用cryptsetup工具，您可以设置这三者。（您还可以使用cryptsetup工具管理True-Crypt卷，我将在接下来的部分中描述。）
- en: The examples that follow operate on a forensically acquired image with a LUKS-encrypted
    filesystem. We’ll create a block device representing the decrypted content of
    an encrypted filesystem and show methods to safely mount the filesystem structure
    for browsing with regular tools. The three goals are to get information about
    the encryption, create a device that can be accessed with forensic tools, and
    safely mount the filesystem for regular browsing.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例操作的是一个具有LUKS加密文件系统的取证获取映像。我们将创建一个块设备，表示加密文件系统的解密内容，并展示如何安全地挂载文件系统结构，以便使用常规工具浏览。三个目标是获取加密信息、创建一个可以用取证工具访问的设备，并安全地挂载文件系统以供常规浏览。
- en: 'The first step requires the byte offset of the LUKS-encrypted partition. The
    sector offset is shown by Sleuth Kit’s `mmls` of the image file. The byte offset
    is the sector offset multiplied by the sector size, which is calculated to be
    1048576 using simple Bash math expansion:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 第一步需要获取LUKS加密分区的字节偏移量。扇区偏移量可以通过Sleuth Kit的`mmls`命令获取映像文件的偏移信息。字节偏移量是扇区偏移量与扇区大小的乘积，使用简单的Bash数学扩展计算得到1048576：
- en: '[PRE57]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'You can use the byte offset to create a loop device of the encrypted partition
    by employing `losetup` as follows:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用字节偏移量通过`losetup`命令创建一个加密分区的loop设备，如下所示：
- en: '[PRE58]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'The LUKS-encrypted partition is now accessible as a block device, which the
    cryptsetup tool can use. You can find information about the encrypted partition
    using cryptsetup’s `luksDump` command:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: LUKS加密分区现在作为块设备可以访问，cryptsetup工具可以使用它。您可以使用cryptsetup的`luksDump`命令查找有关加密分区的信息：
- en: '[PRE59]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: The key slots can be of interest from a forensics perspective. A LUKS volume
    can have up to eight keys, meaning there are potentially eight different passwords
    where you can attempt recovery.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 从取证角度来看，密钥槽可能会引起关注。一个LUKS卷最多可以有八个密钥，意味着有可能有八个不同的密码可以尝试恢复。
- en: 'With the password to the LUKS-encrypted filesystem, you can use cryptsetup’s
    `open` command on the loop0 device to create a mapper device. This device provides
    a decrypted representation of the encrypted image. The mapper device is named
    *clear* in this example:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 使用LUKS加密文件系统的密码后，您可以使用cryptsetup的`open`命令在loop0设备上创建一个映射设备。该设备提供了加密映像的解密表示。在此示例中，映射设备命名为*clear*：
- en: '[PRE60]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'The encrypted loop device is opened with the `--readonly` flag. The verbose
    (`-v`) flag is also given to provide more information about the success of the
    decryption key. After a successful key has been entered, a new (decrypted) partition
    device will appear in the */dev/mapper* directory and can be operated on using
    standard forensic tools. For example, you can run the Sleuth Kit fsstat tool:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`--readonly`标志打开加密的loop设备。还可以提供详细（`-v`）标志，以提供有关解密密钥成功的更多信息。输入成功的密钥后，将在*/dev/mapper*目录中出现一个新的（解密的）分区设备，并可以使用标准的取证工具进行操作。例如，您可以运行Sleuth
    Kit的fsstat工具：
- en: '[PRE61]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'You can also mount this partition device on the local machine for regular browsing:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以将该分区设备挂载到本地机器上进行常规浏览：
- en: '[PRE62]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'Once the examination work is complete, the cleanup process can take place.
    Each step is done in reverse:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦检查工作完成，可以进行清理过程。每个步骤都按逆向顺序进行：
- en: '[PRE63]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: Note that this is a simplified example of a single partition on a single non-bootable
    data disk. A LUKS-encrypted disk with an bootable OS may have an additional Logical
    Volume Manager (LVM) layer. Such disks may have additional devices that appear
    in the */dev/mapper* directory (root, swap, and so on). You can access or mount
    each of these devices individually. During the cleanup process, you need to remove
    the partition devices with dmsetup before closing the LVM device with cryptsetup.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，这是一个简化的示例，展示了单个非启动数据磁盘上的单个分区。带有可启动操作系统的LUKS加密磁盘可能会有一个额外的逻辑卷管理器（LVM）层。这类磁盘可能会在*/dev/mapper*目录中显示其他设备（如root、swap等）。您可以单独访问或挂载这些设备。在清理过程中，您需要在关闭LVM设备之前，使用dmsetup删除分区设备。
- en: For simplicity, the steps shown in this section were performed as a root user.
    To run the examples as a non-root user, `losetup`, `cryptsetup`, `mount`, and
    `umount` need `sudo` to execute, as do any tools that access the */dev/mapper*
    partition device. Depending on the filesystem mounted, additional user options
    may be useful (`uid=holmes` for example).
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 为了简便起见，本节所示的步骤是以root用户身份执行的。要以非root用户运行示例，`losetup`、`cryptsetup`、`mount`和`umount`命令需要使用`sudo`执行，任何访问*/dev/mapper*分区设备的工具也是如此。根据挂载的文件系统，可能需要其他用户选项（例如`uid=holmes`）。
- en: 'Images encrypted with plain dm-crypt and loop-AES can also be decrypted using
    the cryptstetup tool. These follow a similar process as the preceding LUKS example.
    The cryptsetup `open` command needs to have either `plain` or `loopaes` specified
    using the `--type` flag. For example:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 使用纯dm-crypt和loop-AES加密的镜像也可以使用cryptsetup工具解密。这些解密过程与前面的LUKS示例类似。cryptsetup的`open`命令需要通过`--type`标志指定`plain`或`loopaes`。例如：
- en: '[PRE64]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: Using `--type loopaes` will also require a key file. Specifying `--type luks`
    is also possible, but unnecessary, because it’s the default.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`--type loopaes`也需要一个密钥文件。指定`--type luks`也是可能的，但不必要，因为它是默认选项。
- en: You’ll find more information about cryptsetup and LUKS at *[https://gitlab.com/cryptsetup/cryptsetup/wikis/home/](https://gitlab.com/cryptsetup/cryptsetup/wikis/home/)*.
    And you’ll find a compatible Windows implementation at *[https://github.com/t-d-k/librecrypt/](https://github.com/t-d-k/librecrypt/)*.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在*[https://gitlab.com/cryptsetup/cryptsetup/wikis/home/](https://gitlab.com/cryptsetup/cryptsetup/wikis/home/)*上找到更多关于cryptsetup和LUKS的信息。您还可以在*[https://github.com/t-d-k/librecrypt/](https://github.com/t-d-k/librecrypt/)*找到兼容的Windows实现。
- en: '***TrueCrypt and VeraCrypt***'
  id: totrans-214
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***TrueCrypt和VeraCrypt***'
- en: After development of TrueCrypt was stopped, several forks emerged. The dominating
    fork at the moment is VeraCrypt. It offers backward compatibility as well as new
    extensions.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 在TrueCrypt停止开发后，出现了多个分支。目前主流的分支是VeraCrypt。它提供了向后兼容性以及新的扩展功能。
- en: The two examples of VeraCrypt I’ll provide are a normal encrypted container
    and a hidden container. I used the standard command line version of VeraCrypt
    in conjunction with familiar tools to make the containers available for further
    analysis.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 我将提供的VeraCrypt示例有两个：一个是普通加密容器，另一个是隐藏容器。我使用了标准的VeraCrypt命令行版本，并结合常用工具使这些容器可供进一步分析。
- en: 'The first example shows a simple encrypted TrueCrypt or VeraCrypt container
    file. The `--file-system=none` flag is important because it prevents VeraCrypt
    from mounting any filesystems:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个示例展示了一个简单的加密TrueCrypt或VeraCrypt容器文件。`--file-system=none`标志非常重要，因为它防止VeraCrypt挂载任何文件系统：
- en: '[PRE65]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'Using the `-l` flag, you can list all the decrypted containers on the host
    system by slot number. The slot number is an important identifier to use in subsequent
    commands. In this example, the slot number is `1` and the familiar `/dev/mapper/*`
    directory is used:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`-l`标志，您可以按插槽编号列出主机系统上所有已解密的容器。插槽编号是后续命令中使用的重要标识符。在此示例中，插槽编号为`1`，并使用了熟悉的`/dev/mapper/*`目录：
- en: '[PRE66]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'After providing the correct credentials, you can request more information about
    the container by specifying the slot number, as shown here:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 提供正确的凭据后，您可以通过指定插槽编号请求容器的更多信息，如下所示：
- en: '[PRE67]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'Two devices have been created. The device */dev/loop0* is encrypted as a raw
    image (the same as the file on the filesystem). The device shown in the volume
    properties, */dev/mapper/veracrypt1*, is the decrypted volume, which you can operate
    on directly using forensic tools. Here is an example of Sleuth Kit examining the
    filesystem:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 已创建两个设备。设备*/dev/loop0*作为原始镜像进行了加密（与文件系统上的文件相同）。在卷属性中显示的设备*/dev/mapper/veracrypt1*是解密后的卷，您可以直接使用取证工具对其进行操作。以下是Sleuth
    Kit检查文件系统的示例：
- en: '[PRE68]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'You can also mount the mapper device on the local machine and browse the filesystem
    with regular tools, like this:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以在本地机器上挂载映射设备，并使用常规工具浏览文件系统，如下所示：
- en: '[PRE69]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: Obviously, deleted files will not be visible in the user-mounted area; they
    will only be visible when you use forensic tools via the */dev/mapper/veracrypt1*
    device.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，已删除的文件在用户挂载区不会显示；它们只会在你通过 */dev/mapper/veracrypt1* 设备使用取证工具时才会显示。
- en: 'Again, the cleanup process is the reverse of the setup process:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 清理过程是设置过程的逆过程：
- en: '[PRE70]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: The second VeraCrypt example I’ll provide shows how to access a hidden volume.
    One feature of TrueCrypt and VeraCrypt is that it’s possible to have two passwords
    that reveal two separate volumes. The use of both passwords is compared in the
    two command outputs below.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 我将提供的第二个 VeraCrypt 示例演示了如何访问隐藏卷。TrueCrypt 和 VeraCrypt 的一个特点是可以有两个密码，分别揭示两个独立的卷。下面两个命令输出对比了同时使用这两个密码的效果。
- en: 'Here, *hidden.raw* is a VeraCrypt drive containing a hidden volume. Providing
    the first password produces a functioning standard TrueCrypt container with files,
    claiming the full 1GB capacity of the drive and showing `Type: Normal`:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: '在这里，*hidden.raw* 是一个包含隐藏卷的 VeraCrypt 驱动器。提供第一个密码会生成一个功能正常的标准 TrueCrypt 容器，容器里有文件，占用了整个
    1GB 的驱动器容量，并显示 `Type: Normal`：'
- en: '[PRE71]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'If the volume is dismounted and then mounted again using the hidden volume’s
    password, you’ll see a completely different set of files. The time needed to mount
    the volume is also different. With the container in the preceding example, 3.5
    seconds was needed to unlock it, whereas unlocking the hidden container in the
    same file needed 29 seconds. This is because the standard volume decryption is
    attempted first (with all supported algorithms), and upon failing, the decryption
    of a hidden volume is finally tried. In the volume properties, the real size is
    now shown together with `Type: Hidden`, as shown here:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: '如果卷被卸载后再使用隐藏卷的密码重新挂载，你会看到完全不同的一组文件。挂载卷所需的时间也不同。以之前示例中的容器为例，解锁它需要 3.5 秒，而解锁同一文件中的隐藏容器需要
    29 秒。这是因为首先尝试标准卷的解密（使用所有支持的算法），如果失败，才尝试解密隐藏卷。在卷属性中，实际大小现在显示，并且 `Type: Hidden`
    被标注，如下所示：'
- en: '[PRE72]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: The mapped device of a hidden volume produces a filesystem that you can directly
    analyze with forensic tools.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 隐藏卷的映射设备生成一个文件系统，你可以使用取证工具直接分析它。
- en: TrueCrypt and VeraCrypt volumes can also be managed by newer versions of cryptsetup
    (version 1.6.7 and later), providing you with similar mounting possibilities.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: TrueCrypt 和 VeraCrypt 卷也可以通过较新的 cryptsetup 版本（1.6.7 及以后的版本）进行管理，为你提供类似的挂载功能。
- en: There are commercial and open source cracking tools for TrueCrypt/VeraCrypt
    containers, but their use is beyond the scope of this book.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 有商业和开源的破解工具可以破解 TrueCrypt/VeraCrypt 容器，但它们的使用超出了本书的范围。
- en: '**Closing Thoughts**'
  id: totrans-238
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**总结思考**'
- en: In this chapter, you learned to make acquired image files available as block
    devices, create partition devices, and safely make them available for use with
    regular filesystem tools. You also learned to use loop devices and became more
    familiar with */dev/mapper* devices. I showed tips for booting up suspect images
    and demonstrated methods for accessing VM images from various VM formats. Finally,
    you learned how to make a variety of encrypted filesystems available for access
    in decrypted form.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你学会了将获取的映像文件作为块设备进行使用，创建分区设备，并安全地将它们提供给常规文件系统工具使用。你还学会了使用环回设备，并更熟悉了 */dev/mapper*
    设备。我展示了启动可疑映像的技巧，并演示了从各种虚拟机格式中访问虚拟机映像的方法。最后，你学会了如何将各种加密文件系统以解密形式提供访问。
