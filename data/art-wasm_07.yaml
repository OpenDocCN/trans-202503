- en: '7'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '7'
- en: Web Applications
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 网页应用程序
- en: '![](Images/chapterart.png)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/chapterart.png)'
- en: This chapter will help you understand how WebAssembly interacts with the DOM
    through JavaScript. Although it might seem cumbersome, it’s a necessary evil to
    understand WebAssembly and its strengths and weaknesses. If you’re using a WebAssembly
    toolchain, you need to know how much additional code that toolchain will generate
    as JavaScript glue code. From this point forward, most of the examples will run
    from a web page instead of using `node` from the command line.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将帮助你理解 WebAssembly 如何通过 JavaScript 与 DOM 交互。虽然这看起来可能有些繁琐，但这是理解 WebAssembly
    及其优缺点的必要之恶。如果你正在使用 WebAssembly 工具链，你需要了解该工具链将生成多少额外的 JavaScript 胶水代码。从这一点开始，大多数示例将通过网页运行，而不是通过命令行使用
    `node`。
- en: We’ll begin by creating a simple static web server using Node.js. WebAssembly
    web applications cannot be loaded directly from the filesystem in a web browser;
    instead, they require you to run a web server. Node.js provides all the tools
    we need to create a web server. We’ll then write our first WebAssembly web application.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从使用 Node.js 创建一个简单的静态网页服务器开始。WebAssembly 网页应用程序不能直接从文件系统在网页浏览器中加载；相反，它们需要你运行一个网页服务器。Node.js
    提供了我们创建网页服务器所需的所有工具。然后，我们将编写我们的第一个 WebAssembly 网页应用程序。
- en: The second web application we’ll write reuses functions we wrote in Chapter
    5 to take in a number from an input element in the HTML and pass it into WebAssembly,
    which converts the number into a decimal, hexadecimal, and binary string.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将编写的第二个网页应用程序重用了我们在第 5 章中编写的函数，这些函数从 HTML 的输入元素获取一个数字，并将其传递给 WebAssembly，WebAssembly
    将这个数字转换为十进制、十六进制和二进制字符串。
- en: By the end of this chapter, you’ll understand the basics of writing a web application
    that loads and instantiates a WebAssembly module and then calls functions from
    within that module. The applications will also write data from those modules to
    DOM elements. The examples in this chapter aren’t representative of the types
    of applications you would typically write with WebAssembly. They only demonstrate
    how a web page can load, instantiate, and interact with WebAssembly modules.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 本章结束时，你将了解编写一个加载并实例化 WebAssembly 模块的网页应用程序的基础知识，然后从该模块内调用函数。应用程序还将把来自这些模块的数据写入
    DOM 元素。本章中的示例并不代表你通常会使用 WebAssembly 编写的应用程序类型，它们只是演示了一个网页如何加载、实例化并与 WebAssembly
    模块进行交互。
- en: The DOM
  id: totrans-7
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: DOM
- en: Modern web-based applications are so sophisticated it’s easy to forget that
    an HTML page, at its core, is a simple document. The web was conceived as a means
    to share documents and information, but it soon became apparent that we needed
    a standard method for dynamically updating those documents using a language like
    JavaScript or Java. The DOM was designed as a language-independent interface for
    manipulating HTML and XML documents. Because an HTML document is a tree structure,
    the DOM represents a document as a logical tree. The DOM is how JavaScript and
    other languages modify the HTML in a web application.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 现代基于网页的应用程序非常复杂，容易让人忘记，HTML 页面本质上只是一个简单的文档。网络最初是为了共享文档和信息而构思的，但很快就显现出我们需要一种标准的方法，使用像
    JavaScript 或 Java 这样的语言来动态更新这些文档。DOM 被设计为一个与语言无关的接口，用于操作 HTML 和 XML 文档。由于 HTML
    文档是一个树状结构，DOM 将文档表示为一个逻辑树。DOM 是 JavaScript 和其他语言修改网页应用程序中 HTML 的方式。
- en: The WebAssembly 1.0 release has no means of directly manipulating the DOM, so
    the JavaScript must make all modifications to the HTML document. If you’re using
    a toolchain, such as Rust or Emscripten, manipulation of the DOM is usually done
    from JavaScript glue code. As a general rule, the WebAssembly portion of a web
    application should focus on working with numeric data, but with the DOM most of
    the data processing will likely be string manipulation. The performance of string
    manipulation from within WebAssembly is entirely dependent on the library you
    use for the task. For this reason, DOM heavy work is usually best kept in the
    JavaScript portion of the app.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: WebAssembly 1.0 版本没有直接操作 DOM 的手段，因此 JavaScript 必须对 HTML 文档进行所有修改。如果你使用的是一个工具链，如
    Rust 或 Emscripten，DOM 的操作通常是通过 JavaScript 胶水代码来完成的。通常，WebAssembly 在网页应用程序中的部分应该专注于处理数字数据，但对于
    DOM，大多数数据处理可能是字符串操作。WebAssembly 中字符串操作的性能完全取决于你用于该任务的库。因此，DOM 重的工作通常最好保留在应用程序的
    JavaScript 部分。
- en: Setting Up a Simple Node Server
  id: totrans-10
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 设置一个简单的 Node 服务器
- en: To set up a static web server with Node.js, create a folder for your project
    and open it in VS Code or your choice of IDE. We need to install two packages
    using `npm`. Install the first package, `connect`, using the command in [Listing
    7-1](#listing7-1).
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 要设置一个静态网页服务器，首先为你的项目创建一个文件夹，并在 VS Code 或你选择的 IDE 中打开它。我们需要使用 `npm` 安装两个包。使用
    [清单 7-1](#listing7-1) 中的命令安装第一个包 `connect`。
- en: '[PRE0]'
  id: totrans-12
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Listing 7-1: Use `npm` to install the connect package.'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 清单 7-1：使用 `npm` 安装 connect 包。
- en: Install the second package, `serve-static`, using the command in [Listing 7-2](#listing7-2).
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 [清单 7-2](#listing7-2) 中的命令安装第二个包 `serve-static`。
- en: '[PRE1]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Listing 7-2: Use `npm` to install `serve-static`.'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 清单 7-2：使用 `npm` 安装 `serve-static`。
- en: With the packages installed, create a file named *server.js* and enter the code
    in [Listing 7-3](#listing7-3) to define a static web server.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 安装完包后，创建一个名为 *server.js* 的文件，并输入 [清单 7-3](#listing7-3) 中的代码，定义一个静态网页服务器。
- en: '**server.js**'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: '**server.js**'
- en: '[PRE2]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Listing 7-3: Node.js http server code'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 清单 7-3：Node.js http 服务器代码
- en: We’ve created a static server that serves files from the current directory,
    but we don’t yet have any files to serve. Use VS Code to create a file named *index.html*
    and enter some HTML,something like the code in [Listing 7-4](#listing7-4).
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经创建了一个静态服务器，它可以提供当前目录中的文件，但我们还没有任何文件可以提供。使用 VS Code 创建一个名为 *index.html* 的文件，并输入一些
    HTML，类似于 [清单 7-4](#listing7-4) 中的代码。
- en: '**index.html**'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: '**index.html**'
- en: '[PRE3]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Listing 7-4: A simple web page'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 清单 7-4：一个简单的网页
- en: 'Now you can run your Node.js web server using the following command:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你可以使用以下命令运行你的 Node.js 网络服务器：
- en: '[PRE4]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: A web server starts running on port 8080\. Test this by entering *localhost:8080*
    into your browser; you should see something like [Figure 7-1](#figure7-1).
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 一个网络服务器开始在端口 8080 上运行。通过在浏览器中输入 *localhost:8080* 来测试；你应该会看到类似 [图 7-1](#figure7-1)
    的内容。
- en: '![f07001](Images/f07001.png)'
  id: totrans-28
  prefs: []
  type: TYPE_IMG
  zh: '![f07001](Images/f07001.png)'
- en: 'Figure 7-1: Testing our simple static server'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7-1：测试我们的简单静态服务器
- en: Now that we have a working Node.js web server, let’s create our first WebAssembly
    web app.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经有了一个工作的 Node.js 网络服务器，让我们创建我们的第一个 WebAssembly 网页应用。
- en: Our First WebAssembly Web Application
  id: totrans-31
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 我们的第一个 WebAssembly 网络应用
- en: We’ll begin with a simple web app that takes two number inputs, adds them together,
    and then displays those values. The final version of this app is available at
    [https://wasmbook.com/add_message.html](https://wasmbook.com/add_message.html).
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从一个简单的网页应用开始，它接受两个数字输入，将它们相加，然后显示这些值。该应用的最终版本可以在 [https://wasmbook.com/add_message.html](https://wasmbook.com/add_message.html)
    访问。
- en: This app demonstrates how WebAssembly interacts with the DOM. You’ll find that
    we don’t change the way the WebAssembly module works, but instead change the embedding
    environment while the WebAssembly remains none the wiser.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 这个应用展示了 WebAssembly 如何与 DOM 交互。你会发现，我们并没有改变 WebAssembly 模块的工作方式，而是改变了嵌入的环境，而
    WebAssembly 本身对此毫不知情。
- en: To create a web app, we must run a web server, write an HTML page with JavaScript
    that will interact with the DOM, and load the WebAssembly module using the `instantiateStreaming`
    function (instead of using `instantiate` as we did in previous chapters). We’ll
    define a WebAssembly module that adds two integers together and an HTML file that
    loads and runs that WebAssembly module. In Listing 1-8, JavaScript ran the `AddInt`
    function using Node.js to load and execute the WebAssembly module. In this app,
    the HTML file will contain that JavaScript, and a browser will be required to
    run the app.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建一个网页应用，我们必须运行一个网页服务器，编写一个包含与 DOM 交互的 JavaScript 的 HTML 页面，并使用 `instantiateStreaming`
    函数加载 WebAssembly 模块（而不是像前面章节中那样使用 `instantiate`）。我们将定义一个将两个整数相加的 WebAssembly 模块，以及一个加载并运行该
    WebAssembly 模块的 HTML 文件。在清单 1-8 中，JavaScript 使用 Node.js 加载并执行 WebAssembly 模块，调用了
    `AddInt` 函数。在这个应用中，HTML 文件将包含该 JavaScript，并且需要一个浏览器来运行该应用。
- en: '[Listing 7-5](#listing7-5) shows the WAT module with the adding functionality.
    Create the file *add_message.wat* and add the code in [Listing 7-5](#listing7-5).'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: '[清单 7-5](#listing7-5) 显示了具有加法功能的 WAT 模块。创建一个名为 *add_message.wat* 的文件，并在其中添加
    [清单 7-5](#listing7-5) 中的代码。'
- en: '**add_message.wat**'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: '**add_message.wat**'
- en: '[PRE5]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Listing 7-5: The *add_message.wat* file adds two numbers and calls a JavaScript
    log function.'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 清单 7-5：*add_message.wat* 文件将两个数字相加并调用一个 JavaScript 日志函数。
- en: This WAT module should look very familiar at this point. It imports `log_add_message`
    1 from the JavaScript and defines the function `add_message` 2 that will be exported
    to the embedding environment. It also takes two `i32` parameters 3. These two
    parameters are added 4 together and stored in a local variable `$sum`. It then
    calls the JavaScript function `log_add_message` 5, passing in the `$a` and `$b`
    parameters, as well as `$sum` 6, the sum of those two parameters.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 这个 WAT 模块此时应该很熟悉了。它从 JavaScript 中导入了 `log_add_message` 1，并定义了一个将导出到嵌入环境中的函数
    `add_message` 2。它还接收两个 `i32` 类型的参数 3。这两个参数相加 4 并存储在一个局部变量 `$sum` 中。接着，它调用 JavaScript
    函数 `log_add_message` 5，传入 `$a` 和 `$b` 参数，以及 `$sum` 6，这两个参数的和。
- en: At this point, you might be wondering how the WebAssembly interacts with the
    DOM. The unfortunate truth is that WebAssembly 1.0 doesn’t directly interact with
    the DOM. It must rely on the embedding environment (JavaScript) to perform all
    the interaction. All the differences between calling a WebAssembly module from
    Node.js and a web page will be in the embedding environment. The WebAssembly module
    can only make function calls to the embedding environment. We’ll create JavaScript
    functions inside the HTML page. The WebAssembly module will call these JavaScript
    functions, which will update the DOM. Compile *add_message.wat* using `wat2wasm`.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 此时，你可能会想知道 WebAssembly 如何与 DOM 交互。遗憾的事实是，WebAssembly 1.0 无法直接与 DOM 交互。它必须依赖于嵌入环境（JavaScript）来执行所有交互。调用
    WebAssembly 模块时与在 Node.js 和网页之间的区别，完全是在嵌入环境中。WebAssembly 模块只能调用嵌入环境中的函数。我们将在 HTML
    页面中创建 JavaScript 函数。WebAssembly 模块将调用这些 JavaScript 函数，这些函数将更新 DOM。使用 `wat2wasm`
    编译 *add_message.wat*。
- en: Defining the HTML Header
  id: totrans-41
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 定义 HTML 头部
- en: Now we’ll create our HTML page. When we’ve previously used Node.js as our embedding
    environment, we could work in pure JavaScript, but for a static website, you need
    an HTML page. A web browser doesn’t execute JavaScript directly in the same way
    as Node.js. Web browsers load HTML pages, which embed JavaScript inside `<script``>`
    tags. I’ll assume you have some familiarity with the basics of HTML, but this
    example should be fairly easy to follow if not. Create a new file *add_message.html*
    and add the code in [Listing 7-6](#listing7-6).
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将创建我们的 HTML 页面。当我们以前使用 Node.js 作为嵌入环境时，可以直接使用纯 JavaScript，但对于静态网站，你需要一个
    HTML 页面。网页浏览器不会像 Node.js 一样直接执行 JavaScript。网页浏览器加载 HTML 页面，其中嵌入 JavaScript 代码在
    `<script>` 标签内。假设你对 HTML 基础有一定了解，但如果没有，这个示例应该也能很容易跟上。创建一个新的文件 *add_message.html*
    并添加 [列表 7-6](#listing7-6) 中的代码。
- en: '**add_message.html (part 1 of 3)**'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: '**add_message.html（第 1 部分，共 3 部分）**'
- en: '[PRE6]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Listing 7-6: The HTML header for the *add_message* app is mostly HTML boilerplate.'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 7-6：*add_message* 应用的 HTML 头部主要是 HTML 基本模板。
- en: This is the HTML opening tag and header information. It simply sets some font
    configuration and displays the app name, `Add Message`, as the title.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 这是 HTML 开始标签和头部信息。它仅设置一些字体配置，并将应用程序名称 `Add Message` 显示为标题。
- en: The JavaScript
  id: totrans-47
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: JavaScript
- en: Before ending the head element, we include a `script` tag for the JavaScript.
    Similar to when we used Node.js, JavaScript code is required to instantiate and
    execute functions in the WebAssembly module. An HTML page uses a `script` tag
    to contain this JavaScript, as shown in [Listing 7-7](#listing7-7).
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 在结束 head 元素之前，我们包含了一个 `script` 标签来写入 JavaScript。与我们使用 Node.js 时类似，JavaScript
    代码是实例化和执行 WebAssembly 模块中函数所必需的。HTML 页面使用 `script` 标签来包含这段 JavaScript，如 [列表 7-7](#listing7-7)
    中所示。
- en: '**add_message.html (part 2 of 3)**'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: '**add_message.html（第 2 部分，共 3 部分）**'
- en: '[PRE7]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Listing 7-7: The JavaScript that loads a WebAssembly module is inside a `script`
    tag.'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 7-7：加载 WebAssembly 模块的 JavaScript 代码位于 `script` 标签内。
- en: When building a web page, we need to be aware of when all the web page elements
    have completed loading and the time it takes to stream and instantiate our WebAssembly
    module.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 在构建网页时，我们需要注意所有网页元素何时加载完成，以及流式加载和实例化 WebAssembly 模块所需的时间。
- en: This application writes messages to the paragraph tag `output`. The output paragraph
    hasn’t yet loaded when the JavaScript executes, because it’s further down the
    HTML page. The WebAssembly module will be streamed and loaded asynchronously,
    so you can’t be sure whether the WebAssembly module is instantiated before or
    after the page load completes.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 这个应用将消息写入段落标签 `output`。在 JavaScript 执行时，输出段落尚未加载，因为它位于 HTML 页面更下方。WebAssembly
    模块将异步流式加载，因此你无法确定 WebAssembly 模块是在页面加载完成之前还是之后实例化的。
- en: To test that this function works no matter what order these events occur, we
    create a `sleep` 1 function at the beginning to force the JavaScript to wait.
    This function is commented out here. To test load order, uncomment `sleep` here
    as well as inside the IIFE or the `onPageLoad` function.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 为了测试无论这些事件按何种顺序发生该函数是否都能正常工作，我们在开头创建了一个 `sleep` 1 函数来强制 JavaScript 等待。此函数在这里被注释掉。为了测试加载顺序，请取消注释此处的
    `sleep`，以及 IIFE 内部或 `onPageLoad` 函数中的 `sleep`。
- en: We create the `add_message_function` variable as a placeholder that will change
    to point to the `add_message` function inside our WebAssembly module as soon as
    the module is instantiated.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建了 `add_message_function` 变量，作为占位符，当 WebAssembly 模块实例化后，它将指向 `add_message`
    函数。
- en: Next, we define `log_add_message` 2, which contains an arrow function that checks
    whether `output` is set to something other than `null`. The default value for
    `output` is `null`, but as soon as the page is loaded, `output` is set to the
    paragraph element with an `id` of `output`; so this function will log a message
    if the function runs before the page has finished loading. The `log_add_message`
    4 function is imported by and called from the WebAssembly module, which passes
    to `log_add_message` the two parameters to add and the sum of those parameters.
    This function then writes those values to the `output` 3 HTML paragraph tag from
    [Listing 7-8](#listing7-8).
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们定义了 `log_add_message` 2，其中包含一个箭头函数，用于检查 `output` 是否被设置为非 `null` 的值。`output`
    的默认值为 `null`，但一旦页面加载完成，`output` 将被设置为具有 `id` 为 `output` 的段落元素；因此，如果在页面加载完成之前函数运行，该函数将记录一条信息。`log_add_message`
    4 函数由 WebAssembly 模块导入并调用，该模块将两个要添加的参数和它们的和传递给 `log_add_message`。该函数随后将这些值写入[列表
    7-8](#listing7-8)中的 `output` 3 HTML 段落标签。
- en: In the IIFE, the `sleep` 5 function is commented out, but you can restore it
    for testing. However, when loading a WebAssembly module from a web page, you use
    `WebAssembly.instantiateStreaming` 6 combined with a call to `fetch` to retrieve
    the module. Once the module is instantiated, the `add_message_button` 7 element
    is retrieved from the DOM and made visible when we set its `style.display` attribute
    to `block`. The user will now be able to click this button to run the WebAssembly
    function.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 在 IIFE 中，`sleep` 5 函数被注释掉了，但你可以恢复它进行测试。然而，在从网页加载 WebAssembly 模块时，您需要使用 `WebAssembly.instantiateStreaming`
    6 结合 `fetch` 调用来检索该模块。一旦模块实例化，`add_message_button` 7 元素就会从 DOM 中获取，并通过将其 `style.display`
    属性设置为 `block` 使其可见。此时，用户就可以点击这个按钮来运行 WebAssembly 函数。
- en: Additionally, we define the `onPageLoad` 8 function, which executes when the
    HTML `body` is finished loading. This function sets the `output` a variable defined
    near the top of [Listing 7-7](#listing7-7) to the paragraph tag with an `id` of
    `output`. Prior to the page loading, the output variable has a value of `null`.
    If a function that requires the `output` tag executes before the page has finished
    loading, it can check for `null` before using it. This prevents the code from
    trying to use the paragraph tag before it has loaded. We included an optional
    `sleep` 9 function, which can be used to delay setting the `output` variable.
    That allows us to simulate what happens when the page takes longer than expected
    to finish loading.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们定义了 `onPageLoad` 8 函数，该函数在 HTML `body` 加载完成时执行。该函数将[列表 7-7](#listing7-7)中顶部定义的
    `output` 变量设置为具有 `id` 为 `output` 的段落标签。在页面加载之前，`output` 变量的值为 `null`。如果需要 `output`
    标签的函数在页面加载完成之前执行，它可以在使用之前检查是否为 `null`。这样可以防止代码在段落标签加载之前尝试使用它。我们还包含了一个可选的 `sleep`
    9 函数，可以用来延迟设置 `output` 变量，这使我们能够模拟当页面加载时间比预期更长时的情况。
- en: The HTML Body
  id: totrans-59
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: HTML Body
- en: The HTML `body` tag contains the DOM elements that will be displayed on our
    web page. Add the code in [Listing 7-8](#listing7-8) inside *add_message.html*
    below the `script` tag.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: HTML 的 `body` 标签包含将在网页上显示的 DOM 元素。请将[列表 7-8](#listing7-8)中的代码添加到 *add_message.html*
    文件中，放在 `script` 标签下方。
- en: '**add_message.html (part 3 of 3)**'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: '**add_message.html（第 3 部分，共 3 部分）**'
- en: '[PRE8]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Listing 7-8: The DOM elements in the HTML `body` tag'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 7-8：HTML `body` 标签中的 DOM 元素
- en: The `body` 1 tag includes an `onload` attribute that calls the JavaScript `onPageLoad`
    function. This ensures that the `output` variable in our JavaScript isn’t set
    until the `output` paragraph tag exists.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: '`body` 1 标签包含一个 `onload` 属性，该属性调用 JavaScript 的 `onPageLoad` 函数。这确保了我们的 JavaScript
    中的 `output` 变量在 `output` 段落标签存在之前不会被设置。'
- en: Then we have two `input` elements with the `id` inputs `a_val` 2 and `b_val`
    3. The values in these inputs are passed to the WebAssembly when the `button`
    4 element is clicked. The button attribute `onclick` 5 is set to call the `add_message_function`,
    which calls the `add_message` function in the WebAssembly module once the module
    is instantiated. The `add_message` function is called, passing in the values in
    the two input fields (`a_val` and `b_val`) above the `button`. In addition, we
    have a paragraph tag with an `id` of `output` 6 that we’ll populate with values
    from the WebAssembly module.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们有两个`input`元素，其`id`分别为`a_val` 2 和 `b_val` 3。这些输入框中的值在点击`button` 4元素时会传递给
    WebAssembly。当模块实例化后，`onclick`属性被设置为调用`add_message_function`，该函数会调用 WebAssembly
    模块中的`add_message`函数。调用`add_message`函数时，会将两个输入框中的值（`a_val` 和 `b_val`）传递给它。此外，我们还有一个`id`为`output`
    6的段落标签，用于显示来自 WebAssembly 模块的值。
- en: Our Completed Web App
  id: totrans-66
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 我们的完整 Web 应用程序
- en: We should now be able to run our web application. As mentioned earlier, we must
    serve the web page from a web server, so first make sure the web server in [Listing
    7-3](#listing7-3) is running by using the command in [Listing 7-9](#listing7-9).
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们应该能够运行我们的 web 应用程序。如前所述，我们必须通过 web 服务器来提供网页，因此首先确保[清单 7-3](#listing7-3)中的
    web 服务器正在运行，方法是使用[清单 7-9](#listing7-9)中的命令。
- en: '[PRE9]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Listing 7-9: Run the simple web server.'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 清单 7-9：运行简单的 web 服务器。
- en: If you receive the error in [Listing 7-10](#listing7-10), you already have a
    web server running on that port.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在[清单 7-10](#listing7-10)中遇到错误，说明该端口上已经运行着一个 web 服务器。
- en: '[PRE10]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Listing 7-10: The web server error if the port is already in use'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 清单 7-10：端口已被占用时的 web 服务器错误
- en: 'Getting this error likely means you’re running *server.js* from a different
    command line. With your web server running, open the following URL in a browser:
    [http://localhost:8080/add_message.html](http://localhost:8080/add_message.html).'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 出现此错误可能意味着你是在不同的命令行中运行*server.js*。确保 web 服务器正在运行后，在浏览器中打开以下 URL：[http://localhost:8080/add_message.html](http://localhost:8080/add_message.html)。
- en: You should see something like the screen in [Figure 7-2](#figure7-2).
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该会看到类似[图 7-2](#figure7-2)的屏幕。
- en: '![f07002](Images/f07002.png)'
  id: totrans-75
  prefs: []
  type: TYPE_IMG
  zh: '![f07002](Images/f07002.png)'
- en: 'Figure 7-2: The *add_message.html* web app'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7-2：*add_message.html* Web 应用程序
- en: Set values in the two number fields, and click **Add Values** to see the results
    of that addition ([Figure 7-3](#figure7-3)).
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 在两个数字字段中设置值，然后点击**添加值**查看加法结果（[图 7-3](#figure7-3)）。
- en: '![f07003](Images/f07003.png)'
  id: totrans-78
  prefs: []
  type: TYPE_IMG
  zh: '![f07003](Images/f07003.png)'
- en: 'Figure 7-3: Two addition messages added with the app'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7-3：通过应用程序添加的两个加法消息
- en: Notice that the WebAssembly module called JavaScript functions, as was done
    in other chapters. You didn’t have to learn any new commands in WAT in this chapter.
    Because working directly with the DOM isn’t possible from within Wasm 1.0, we
    made all our changes to the DOM inside the JavaScript. Even though this was the
    first time we used an HTML page, it didn’t affect what WebAssembly does. WebAssembly
    1.0 is fairly limited and is most useful for increasing performance for math-heavy
    applications. This characteristic will change with later WebAssembly releases
    as more features are added. But for now, you need to keep these limitations in
    mind as you decide which applications are best suited for this new technology.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，WebAssembly 模块调用了 JavaScript 函数，就像在其他章节中一样。在本章中，你无需学习 WAT 中的任何新命令。由于 WebAssembly
    1.0 无法直接与 DOM 交互，我们所有的 DOM 更改都在 JavaScript 中进行。尽管这是我们第一次使用 HTML 页面，但它并未影响 WebAssembly
    的工作。WebAssembly 1.0 还是相当有限的，它对于增加计算密集型应用的性能非常有用。随着更多功能的添加，后续的 WebAssembly 版本将会有所改变。但目前，在决定哪些应用最适合使用这一新技术时，你需要牢记这些限制。
- en: Hex and Binary Strings
  id: totrans-81
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 十六进制和二进制字符串
- en: We’ll continue and create a second app that uses our functions from Chapter
    5 to convert numeric data into decimal, hexadecimal, and binary strings, and display
    them to a web page. See the final app at [https://wasmbook.com/hex_and_binary.html](https://wasmbook.com/hex_and_binary.html)*.*
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将继续创建第二个应用程序，该应用程序使用第 5 章中的函数将数字数据转换为十进制、十六进制和二进制字符串，并将它们显示在网页上。可以在[https://wasmbook.com/hex_and_binary.html](https://wasmbook.com/hex_and_binary.html)查看最终的应用程序。
- en: The HTML
  id: totrans-83
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: HTML
- en: The HTML is pretty much the same as [Listing 7-6](#listing7-6) but with different
    `title`contents. Create a file named *hex_and_binary.html* and add the code in
    [Listing 7-11](#listing7-11).
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: HTML基本与[清单 7-6](#listing7-6)相同，但`title`内容不同。创建一个名为*hex_and_binary.html*的文件，并添加[清单
    7-11](#listing7-11)中的代码。
- en: '**hex_and_binary.html (part 1 of 3)**'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: '**hex_and_binary.html（第 1 部分，共 3 部分）**'
- en: '[PRE11]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Listing 7-11: The boilerplate at the beginning of *hex_and_binary.html*'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 7-11：*hex_and_binary.html* 文件开头的模板代码
- en: The `title`tag here contains `Hex` `and Binary` 1. Next, in [Listing 7-12](#listing7-12),
    we add the `script` tag and the JavaScript code that will instantiate and call
    the WebAssembly module.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的 `title` 标签包含 `Hex` 和 `Binary` 1。接下来，在 [列表 7-12](#listing7-12) 中，我们添加 `script`
    标签和 JavaScript 代码，这些代码将实例化并调用 WebAssembly 模块。
- en: '**hex_and_binary.html (part 2 of 3)**'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: '**hex_and_binary.html（第 2 部分，共 3 部分）**'
- en: '[PRE12]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Listing 7-12: JavaScript for the *hex_and_binary.html* file'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 7-12：*hex_and_binary.html* 文件的 JavaScript 代码
- en: The `script` tag first creates the variable `setOutput` 1 and sets it to an
    arrow function that logs `"function not available"` 2 to the console. This message
    will display if the user clicks the **Set Numbers** button before the WebAssembly
    module has finished loading.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: '`script` 标签首先创建变量 `setOutput` 1，并将其设置为一个箭头函数，该函数将 `"function not available"`
    2 输出到控制台。如果用户在 WebAssembly 模块加载完成之前点击 **设置数字** 按钮，则会显示此消息。'
- en: Next, we define the `setNumbers` 3 function that will be called when the user
    clicks the **Set Numbers** button. If the page load hasn’t finished, the `output`
    is still `null` 4 at the button click, and we return from this function. The `setNumbers`
    function then calls `setOutput` 5 in the WebAssembly module, which creates an
    HTML string from the number passed in and returns the length of that string, which
    we’ll use to retrieve the string from linear memory. We take the `bytes` that
    will be used to create the display string from the linear memory `buffer` 6.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们定义了 `setNumbers` 3 函数，当用户点击 **设置数字** 按钮时会调用该函数。如果页面加载尚未完成，则在按钮点击时 `output`
    仍为 `null` 4，我们将从该函数返回。然后，`setNumbers` 函数调用 WebAssembly 模块中的 `setOutput` 5，该函数从传入的数字创建一个
    HTML 字符串，并返回该字符串的长度，我们将使用它从线性内存中检索字符串。我们从线性内存的 `buffer` 6 中获取用于创建显示字符串的 `bytes`。
- en: Then the `output` tag’s `innerHTML` 7 attribute is set to the display string
    generated from those `bytes` using a `TextDecoder` object, which displays the
    string in the web page.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，`output` 标签的 `innerHTML` 7 属性被设置为从这些 `bytes` 生成的显示字符串，该字符串使用 `TextDecoder`
    对象显示在网页中。
- en: We define the `onPageLoad` 8 function, which the `body` tag executes once it
    has finished loading. That function sets the `output` 9 variable used to display
    the output string from the WebAssembly module. It also instantiates the WebAssembly
    module and sets the `setOutput` a variable to the `setOutput` function in the
    WebAssembly module, so we can call `setOutput` from the JavaScript.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 我们定义了 `onPageLoad` 8 函数，该函数在 `body` 标签加载完成后执行。该函数设置了 `output` 9 变量，用于显示 WebAssembly
    模块输出的字符串。它还实例化了 WebAssembly 模块，并将 `setOutput` 变量设置为 WebAssembly 模块中的 `setOutput`
    函数，这样我们就可以从 JavaScript 中调用 `setOutput`。
- en: Finally, we need the `body` tag, which contains an `output` tag to display the
    output from the WebAssembly function call, a number `input` to take in the user
    input, and a `button` to click that will call the `setNumbers` function. [Listing
    7-13](#listing7-13) shows that code.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们需要 `body` 标签，其中包含一个 `output` 标签，用于显示 WebAssembly 函数调用的输出，一个数字 `input` 用于接收用户输入，以及一个
    `button`，点击后将调用 `setNumbers` 函数。[列表 7-13](#listing7-13) 显示了该代码。
- en: '**hex_and_binary.html (part 3 of 3)**'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: '**hex_and_binary.html（第 3 部分，共 3 部分）**'
- en: '[PRE13]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Listing 7-13: The UI elements of the HTML page'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 7-13：HTML 页面中的 UI 元素
- en: The `onload` 1 attribute tells the browser to execute `onPageLoad` when the
    `body` has completed loading. The tag 2 `<div` `id``="output">` is where the output
    from the WebAssembly module will be displayed. The number `input` tag 3, `<input`
    `type="number" id="val"` `value="0">` is where the user enters the number to convert
    to hexadecimal and binary. The `button` 4 calls the WebAssembly module when it’s
    clicked using the `onclick` 5 attribute. Now that we have our HTML page, we can
    create the WAT file for this application.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: '`onload` 1 属性告诉浏览器在 `body` 标签加载完成时执行 `onPageLoad` 函数。标签 2 `<div id="output">`
    是 WebAssembly 模块输出显示的位置。数字 `input` 标签 3，`<input type="number" id="val" value="0">`
    是用户输入要转换为十六进制和二进制的数字的地方。`button` 4 在点击时使用 `onclick` 5 属性调用 WebAssembly 模块。现在我们已经有了
    HTML 页面，可以为此应用程序创建 WAT 文件。'
- en: The WAT
  id: totrans-101
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: WAT
- en: There’s a lot of WAT code in this app, so we’ll break it into four sections.
    Also, you’ll need to copy several functions from Chapter 5. Create a file named
    *hex_and_binary.wat* and add the code in [Listing 7-14](#listing7-14).
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 该应用程序中有大量的 WAT 代码，因此我们将其分为四个部分。同时，你需要从第 5 章复制几个函数。创建一个名为 *hex_and_binary.wat*
    的文件，并将 [列表 7-14](#listing7-14) 中的代码添加进去。
- en: '**hex_and_binary.wat (part 1 of 4)**'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: '**hex_and_binary.wat（第 1 部分，共 4 部分）**'
- en: '[PRE14]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Listing 7-14: String data definitions at the beginning of the module'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 7-14：模块开头的字符串数据定义
- en: We define a series of data sections, pointers, and data lengths that will be
    used to assemble decimal, hexadecimal, and binary strings from integer data. The
    `$digit_ptr` 1 global variable is a pointer to the data segment that contains
    the 16 hexadecimal digits 0 to F defined at linear memory location `128`. This
    data is used for all three conversions from integer to string. We also have a
    length and pointer global variable, as well as a data segment for our decimal
    2, hexadecimal 3, and binary 4 string. Much of the code we’ll use is taken from
    sections in Chapter 5.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 我们定义了一系列数据段、指针和数据长度，用于从整数数据中组装十进制、十六进制和二进制字符串。`$digit_ptr` 1 全局变量是指向包含 16 个十六进制数字
    0 到 F 的数据段的指针，该数据段定义在线性内存位置 `128`。这段数据将用于三种整数到字符串的转换。我们还定义了长度和指针的全局变量，以及用于十进制
    2、十六进制 3 和二进制 4 字符串的数据段。我们将使用的代码大部分来自第 5 章的部分内容。
- en: Next, we have several strings that represent HTML tags. There are opening 5
    and closing 6 `H1` tag pointers, length and data segments, as well as opening
    7 and closing 8 data for `H4` tags. These strings will be used to assemble our
    HTML output string that will be stored in the linear memory position `1024` 9,
    which I chose because it was unused.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们有几个表示 HTML 标签的字符串。包含 5 个开标签和 6 个闭标签的 `H1` 标签指针、长度和数据段，以及 7 个开标签和 8 个闭标签的
    `H4` 标签数据。这些字符串将用于组合我们的 HTML 输出字符串，并存储在线性内存位置 `1024` 9，我选择这个位置是因为它未被使用。
- en: As we copy string data to the output string, we’ll need to keep track of the
    new length of this string and pass that value to the JavaScript; so we use the
    global variable `$out_str_len` to keep track of the output string length. Instead
    of including the code for the original functions from Chapter 5, I include an
    ellipsis (…) and a comment indicating the listing number that has the function
    code to copy. Copy and paste the function code from the original listing for all
    six of the functions in [Listing 7-15](#listing7-15).
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们将字符串数据复制到输出字符串时，我们需要跟踪该字符串的新长度，并将该值传递给 JavaScript；因此，我们使用全局变量 `$out_str_len`
    来跟踪输出字符串的长度。为了避免重复包含第 5 章中原始函数的代码，我使用省略号 (…) 和注释来指示包含复制函数代码的清单号。请从原始清单中复制并粘贴所有六个函数的代码，清单编号为
    [清单 7-15](#listing7-15)。
- en: '**hex_and_binary.wat (part 2 of 4)**'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: '**hex_and_binary.wat（第 2 部分，共 4 部分）**'
- en: '[PRE15]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Listing 7-15: Functions reused from Chapter 5'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 清单 7-15：来自第 5 章的重用函数
- en: First are the number-to-string conversion functions. The `$set_bin_string` 1
    function converts a number into a binary string. As parameters it takes an `i32
    $num` to be converted into a binary string and `$string_len` as the length of
    the output string, which includes nibble padding with spaces (Listing 5-35). Next
    is `$set_hex_string` 2, which converts the number and length to a hexadecimal
    string prefixed with a `0x` to indicate that the string represents a hexadecimal
    number (Listing 5-30). Then `$set_dec_string` 3 converts a number to a decimal
    string (Listing 5-24).
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 首先是数字转字符串的转换函数。`$set_bin_string` 1 函数将数字转换为二进制字符串。它的参数包括需要转换为二进制字符串的 `i32 $num`
    和输出字符串的长度 `$string_len`，该长度包括通过空格填充的半字节（见清单 5-35）。接下来是 `$set_hex_string` 2 函数，它将数字和长度转换为以
    `0x` 前缀表示十六进制数字的十六进制字符串（见清单 5-30）。然后，`$set_dec_string` 3 函数将数字转换为十进制字符串（见清单 5-24）。
- en: 'Next are the three copy functions that copy a byte at a time, eight bytes at
    a time, and strings. Each takes three parameters: the `$source` parameter is the
    string that we’re copying from, the `$dest` parameter is the string we’re copying
    to, and `$len` is the length of the string. First is the `$byte_copy` 4 function,
    which copies data one byte at a time (Listing 5-17). The `$byte_copy_i64` 5 function
    copies eight bytes at a time (Listing 5-18). The `$string_copy` 6 function copies
    bytes eight at a time using `$byte_copy_i64` until there are less than eight bytes
    remaining and then copies the remaining bytes one by one using `$byte_copy` (Listing
    5-17).'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来是三个复制函数，分别用于按字节、每次复制八个字节和复制字符串。每个函数都接收三个参数：`$source` 参数是我们要复制的源字符串，`$dest`
    参数是我们要复制到的目标字符串，`$len` 是字符串的长度。首先是 `$byte_copy` 4 函数，它每次复制一个字节（见清单 5-17）。`$byte_copy_i64`
    5 函数每次复制八个字节（见清单 5-18）。`$string_copy` 6 函数使用 `$byte_copy_i64` 每次复制八个字节，直到剩余少于八个字节时，再使用
    `$byte_copy` 函数一个字节一个字节地复制剩余的字节（见清单 5-17）。
- en: There is one final copy command not in [Listing 7-15](#listing7-15). This is
    the `$append_out` function that will always append a given source string to the
    output string by copying it to the end of the current output string. Add the code
    in [Listing 7-16](#listing7-16) to *hex_and_binary.wat*.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 有一个最终的复制命令不在 [列表 7-15](#listing7-15) 中。它是 `$append_out` 函数，该函数始终通过将给定的源字符串复制到当前输出字符串的末尾来附加字符串。将
    [列表 7-16](#listing7-16) 中的代码添加到 *hex_and_binary.wat*。
- en: '**hex_and_binary.wat (part 3 of 4)**'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: '**hex_and_binary.wat（第 3 部分，共 4 部分）**'
- en: '[PRE16]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Listing 7-16: The `$append_out` function appends to the output string.'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 7-16：`$append_out` 函数将内容附加到输出字符串。
- en: The `$append_out` 1 function appends the source string to the end of the output
    string using `$string_copy` 2 and then adds the length of the string just appended
    to the `$out_str_len` 3, which represents the output string length.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: '`$append_out` 1 函数使用 `$string_copy` 2 将源字符串附加到输出字符串的末尾，然后将刚刚附加的字符串的长度加到 `$out_str_len`
    3 中，该变量表示输出字符串的长度。'
- en: The final function in this module is `setOutput`, which creates the string we
    use to set the `output` `div` tag. This is exported so it can be called from JavaScript.
    Add the code in [Listing 7-17](#listing7-17) to the end of the WAT file.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 本模块的最终函数是 `setOutput`，它创建我们用来设置 `output` `div` 标签的字符串。它已被导出，以便可以从 JavaScript
    中调用。将 [列表 7-17](#listing7-17) 中的代码添加到 WAT 文件的末尾。
- en: '**hex_and_binary.wat (part 4 of 4)**'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: '**hex_and_binary.wat（第 4 部分，共 4 部分）**'
- en: '[PRE17]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Listing 7-17: The `setOutput` function exported to be called from JavaScript'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 7-17：`setOutput` 函数已导出，可供 JavaScript 调用
- en: The first three calls made by the `set_output` function in [Listing 7-17](#listing7-17)
    are to `$set_dec_string` 1, `$set_hex_string` 2, and `$set_bin_string` 3. These
    functions take the number passed into `setOutput` and convert it into a decimal
    string, a hexadecimal string, and a binary string in linear memory. Once these
    strings are set, the global variable `$out_str_len` 4 is set to `0`, which resets
    the output string so that appending to the output string writes over the string
    currently in memory. After we reset the value, we can begin to append to the output
    string.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: '[列表 7-17](#listing7-17) 中 `set_output` 函数的前三个调用分别是 `$set_dec_string` 1、`$set_hex_string`
    2 和 `$set_bin_string` 3。这些函数将传递给 `setOutput` 的数字转换为十进制字符串、十六进制字符串和二进制字符串，并存储在线性内存中。一旦这些字符串被设置，全局变量
    `$out_str_len` 4 会被重置为 `0`，从而重置输出字符串，使得附加到输出字符串时会覆盖当前内存中的字符串。重置值后，我们可以开始将内容附加到输出字符串。'
- en: Next are nine calls to `$append_out`, grouped into three blocks. The first three
    calls append an opening and closing `H1` tag with the decimal 5 string inside
    it. This creates the HTML string to display the decimal numeric value in our web
    page. The next block of three appends the hexadecimal 6 string inside an `H4`
    element, and then the binary 7 string is appended inside an `H4` element. Finally,
    the length of the output string is loaded on the stack using a call to `global.get`
    `$out_str_len` 8, which returns it to the calling JavaScript.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来是九次调用 `$append_out`，分为三组。前三次调用会附加一个开闭的 `H1` 标签，并将十进制 5 字符串放在其中。这将创建一个 HTML
    字符串，在网页中显示十进制数值。接下来的三次调用将十六进制 6 字符串放入 `H4` 元素中，然后将二进制 7 字符串放入另一个 `H4` 元素中。最后，使用对
    `global.get` `$out_str_len` 8 的调用将输出字符串的长度加载到栈中，并将其返回给调用的 JavaScript。
- en: Compile and Run
  id: totrans-125
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 编译并运行
- en: The WAT module is complete, so use `wat2wasm` to compile your *hex_and_binary.wasm*
    file, as shown in [Listing 7-18](#listing7-18).
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: WAT 模块已完成，因此使用 `wat2wasm` 编译你的 *hex_and_binary.wasm* 文件，如 [列表 7-18](#listing7-18)
    所示。
- en: '[PRE18]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Listing 7-18: Compiling *hex_and_binary.wat* using `wat2wasm`'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 7-18：使用 `wat2wasm` 编译 *hex_and_binary.wat*
- en: Verify that you’re running your *server.js*, and open *hex_and_binary.html*
    in a browser using the address *http://localhost:8080/hex_and_binary.html*.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 验证你是否在运行 *server.js*，并使用地址 *http://localhost:8080/hex_and_binary.html* 在浏览器中打开
    *hex_and_binary.html*。
- en: '[Figure 7-4](#figure7-4) shows something similar to what you should see onscreen.'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 7-4](#figure7-4) 显示了你应在屏幕上看到的类似内容。'
- en: '![f07004](Images/f07004.png)'
  id: totrans-131
  prefs: []
  type: TYPE_IMG
  zh: '![f07004](Images/f07004.png)'
- en: 'Figure 7-4: Converting decimal to hexadecimal and binary'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7-4：将十进制转换为十六进制和二进制
- en: Enter a number and give it a go. For example, in [Figure 7-5](#figure7-5), I
    entered the number 1025 and clicked Set Numbers.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 输入一个数字并试试吧。例如，在 [图 7-5](#figure7-5) 中，我输入了数字 1025 并点击了设置数字。
- en: '![f07005](Images/f07005.png)'
  id: totrans-134
  prefs: []
  type: TYPE_IMG
  zh: '![f07005](Images/f07005.png)'
- en: 'Figure 7-5: Convert 1025 to hexadecimal and binary'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7-5：将 1025 转换为十六进制和二进制
- en: This application used several WebAssembly functions we created in Chapter 5
    to convert a decimal number to hexadecimal and binary strings. We added some additional
    functionality that created HTML tags in the WebAssembly module so we could pass
    HTML to the JavaScript and display it on the web page. As you can tell, working
    with strings and manipulating the DOM from WAT is rather cumbersome. If you’re
    working with a toolchain, much of this hard work is done for you. Some of this
    functionality might compile into JavaScript glue code.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 这个应用程序使用了我们在第 5 章中创建的几个 WebAssembly 函数，将十进制数字转换为十六进制和二进制字符串。我们添加了一些额外的功能，在 WebAssembly
    模块中创建了 HTML 标签，以便我们可以将 HTML 传递给 JavaScript 并在网页上显示。正如你所看到的，从 WAT 操作字符串和操作 DOM
    是相当繁琐的。如果你正在使用工具链，很多繁重的工作将为你完成。这些功能中的一部分可能会编译成 JavaScript 附加代码。
- en: Summary
  id: totrans-137
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 总结
- en: WebAssembly 1.0 doesn’t directly work with user interfaces. Its sweet spot is
    math-intensive applications. When interacting with the DOM from a web application
    built on top of WebAssembly, manipulating the DOM is primarily a task for the
    JavaScript portion. Working with strings from within WebAssembly entirely depends
    on the implementation. WebAssembly is still an excellent choice for many web applications,
    especially graphical applications, such as games. But in its current state, it’s
    not designed to work directly with the DOM.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: WebAssembly 1.0 并不直接与用户界面交互。它的最佳应用场景是数学密集型应用。在基于 WebAssembly 构建的 Web 应用程序中与
    DOM 交互时，操作 DOM 主要是 JavaScript 部分的任务。从 WebAssembly 中操作字符串完全取决于实现。尽管如此，WebAssembly
    仍然是许多 Web 应用程序，特别是图形应用程序（如游戏）的绝佳选择。但在当前状态下，它并不设计为直接与 DOM 一起使用。
- en: We began this chapter by creating a simple JavaScript web server to run using
    Node.js. You can’t load a WebAssembly web app from the filesystem but instead
    must serve your page using a web server. We wrote our first WebAssembly web application,
    which added two numbers together and then logged those numbers to the DOM in a
    paragraph tag called `output`.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 本章开始时，我们创建了一个简单的 JavaScript Web 服务器，并使用 Node.js 运行。你不能从文件系统加载 WebAssembly Web
    应用程序，而是必须通过 Web 服务器来提供页面。我们编写了我们的第一个 WebAssembly Web 应用程序，它将两个数字相加，然后将这些数字记录到名为
    `output` 的段落标签中。
- en: The primary difference between web applications and Node.js applications is
    in the embedding environment. Node.js command line apps are written entirely in
    JavaScript, where the web application has its JavaScript inside an HTML web page.
    Node.js can load the WebAssembly module directly from the filesystem, whereas
    the web application uses `instantiateStreaming` and `fetch` to instantiate a WebAssembly
    module streaming it from a web server. A Node.js application would have logged
    its output to the console, whereas the HTML page updated the `innerHTML` of a
    DOM element.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: Web 应用程序和 Node.js 应用程序之间的主要区别在于嵌入环境。Node.js 命令行应用程序完全用 JavaScript 编写，而 Web 应用程序将其
    JavaScript 嵌入在 HTML 页面中。Node.js 可以直接从文件系统加载 WebAssembly 模块，而 Web 应用程序使用 `instantiateStreaming`
    和 `fetch` 从 Web 服务器流式传输 WebAssembly 模块并实例化它。Node.js 应用程序将其输出记录到控制台，而 HTML 页面则更新了
    DOM 元素的 `innerHTML`。
- en: The second application we wrote displayed the decimal, hexadecimal, and binary
    representations of a number passed into the WebAssembly module. This was done
    by assembling a string containing the HTML elements to be displayed in the application.
    This application reused several functions created in Chapter 5 for string manipulation.
    The JavaScript in this application wrote the string to the `innerHTML` of a `div`
    tag on our web page.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 我们编写的第二个应用程序显示了传入 WebAssembly 模块的数字的十进制、十六进制和二进制表示。这是通过组装一个包含要在应用程序中显示的 HTML
    元素的字符串来完成的。该应用程序重用了第 5 章中为字符串操作创建的几个函数。此应用程序中的 JavaScript 将字符串写入我们网页中一个 `div`
    标签的 `innerHTML`。
- en: Neither of the applications we wrote is a particularly good use case for WebAssembly.
    My goal in this chapter was to create our first few WebAssembly web apps, not
    necessarily to make web applications that made sense to create using WebAssembly.
    In the next chapter, we’ll render to the HTML canvas and examine collision detection
    between a large number of objects on that canvas. These tasks, commonly found
    in web games, better represent what WebAssembly 1.0 can do to improve your web
    application’s performance.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 我们编写的这两个应用程序都不是 WebAssembly 的特别理想用例。我在本章的目标是创建我们第一个 WebAssembly Web 应用程序，而不一定是要创建那些确实适合使用
    WebAssembly 的 Web 应用程序。在下一章中，我们将渲染到 HTML 画布并检查该画布上大量物体之间的碰撞检测。这些任务，通常出现在 Web 游戏中，更好地代表了
    WebAssembly 1.0 能够提升你的 Web 应用程序性能的功能。
