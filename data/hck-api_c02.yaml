- en: '2'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '2'
- en: The Anatomy of Web APIs
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: Web API的解剖
- en: '![](image_fi/book_art/chapterart.png)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![](image_fi/book_art/chapterart.png)'
- en: Most of what the average user knows about a web application comes from what
    they can see and click in the graphical user interface (GUI) of their web browser.
    Under the hood, APIs perform much of the work. In particular, web APIs provide
    a way for applications to use the functionality and data of other applications
    over HTTP to feed a web application GUI with images, text, and videos.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数普通用户对Web应用程序的了解来自于他们在Web浏览器的图形用户界面（GUI）中能看到和点击的内容。在幕后，API执行大部分工作。特别是，Web
    API提供了一种应用程序可以通过HTTP使用其他应用程序的功能和数据，以便将图像、文本和视频传递到Web应用程序GUI的方式。
- en: 'This chapter covers common API terminology, types, data interchange formats,
    and authentication methods and then ties this information together with an example:
    observing the requests and responses exchanged during interactions with Twitter’s
    API.'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖常见的API术语、类型、数据交换格式和认证方法，并通过示例将这些信息联系在一起：观察与Twitter API交互期间交换的请求和响应。
- en: How Web APIs Work
  id: totrans-5
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Web API的工作原理
- en: Like web applications, web APIs rely on HTTP to facilitate a client/server relationship
    between the host of the API (the *provider*) and the system or person making an
    API request (the *consumer*).
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 与Web应用程序类似，Web API依赖于HTTP，在API的主机（*提供者*）与发出API请求的系统或个人（*消费者*）之间建立客户端/服务器关系。
- en: 'An API consumer can request resources from an *API endpoint*, which is a URL
    for interacting with part of the API. Each of the following examples is a different
    API endpoint:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: API消费者可以从*API端点*请求资源，这是与API的某一部分进行交互的URL。以下每个示例都是不同的API端点：
- en: '*https://example.com/api/v3/users/*'
  id: totrans-8
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '*https://example.com/api/v3/users/*'
- en: '*https://example.com/api/v3/customers/*'
  id: totrans-9
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '*https://example.com/api/v3/customers/*'
- en: '*https://example.com/api/updated_on/*'
  id: totrans-10
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '*https://example.com/api/updated_on/*'
- en: '*https://example.com/api/state/1/*'
  id: totrans-11
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '*https://example.com/api/state/1/*'
- en: '*Resources* are the data being requested. A *singleton* resource is a unique
    object, such as */api/user/{user_id}*. A *collection* is a group of resources,
    such as */api/profiles/users*. A *subcollection* refers to a collection within
    a particular resource. For example, */api/user/{user_id}/settings* is the endpoint
    to access the *settings* subcollection of a specific (singleton) user.'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: '*资源*是被请求的数据。*单例*资源是一个唯一的对象，例如*/api/user/{user_id}*。*集合*是一组资源，例如*/api/profiles/users*。*子集合*指的是特定资源内的集合。例如，*/api/user/{user_id}/settings*
    是访问特定（单例）用户的*设置*子集合的端点。'
- en: When a consumer requests a resource from a provider, the request passes through
    an *API gateway*, which is an API management component that acts as an entry point
    to a web application. For example, as shown in [Figure 2-1](#figure2-1), end users
    can access an application’s services using a plethora of devices, which are all
    filtered through an API gateway. The API gateway then distributes the requests
    to whichever microservice is needed to fulfill each request.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 当消费者从提供者请求资源时，请求会经过一个*API网关*，这是一个作为Web应用入口点的API管理组件。例如，如图 [Figure 2-1](#figure2-1)
    所示，最终用户可以使用众多设备访问应用程序的服务，所有这些设备都经过API网关过滤。然后，API网关将请求分发到需要满足每个请求的微服务。
- en: The API gateway filters bad requests, monitors incoming traffic, and routes
    each request to the proper service or microservice. The API gateway can also handle
    security controls such as authentication, authorization, encryption in transit
    using SSL, rate limiting, and load balancing.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: API网关会过滤错误请求，监控传入流量，并将每个请求路由到适当的服务或微服务。API网关还可以处理诸如身份验证、授权、传输中的SSL加密、速率限制和负载平衡等安全控制。
- en: '![Diagram showing an API gateway in the center, apps on the left-hand side,
    and microservices on the right-hand side. Arrows travel from the mobile app, web
    app, and IoT app to the API gateway, and from the API gateway to Microservice
    1, Microservice 2, and Microservice 3.](image_fi/502444c02/F02001.png)'
  id: totrans-15
  prefs: []
  type: TYPE_IMG
  zh: '![显示API网关在中心，左侧是应用程序，右侧是微服务的图示。箭头从移动应用程序、Web应用程序和IoT应用程序指向API网关，从API网关指向微服务1、微服务2和微服务3。](image_fi/502444c02/F02001.png)'
- en: 'Figure 2-1: A sample microservices architecture and API gateway'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 'Figure 2-1: 一个示例微服务架构和API网关'
- en: 'A *microservice* is a modular piece of a web app that handles a specific function.
    Microservices use APIs to transfer data and trigger actions. For example, a web
    application with a payment gateway may have several different features on a single
    web page: a billing feature, a feature that logs customer account information,
    and one that emails receipts upon purchase. The application’s backend design could
    be monolithic, meaning all the services exist within a single application, or
    it could have a microservice architecture, where each service functions as its
    own standalone application.'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: '*微服务*是一个Web应用程序的模块化部分，处理特定的功能。微服务使用API来传输数据并触发操作。例如，一个带有支付网关的Web应用程序可能在一个单独的网页上具有几个不同的功能：账单功能、记录客户账户信息的功能以及在购买后发送电子邮件收据的功能。该应用程序的后端设计可以是单体架构，意味着所有服务都存在于一个单一的应用程序中，或者它可以有一个微服务架构，其中每个服务作为独立的应用程序运行。'
- en: The API consumer does not see the backend design, only the endpoints they can
    interact with and the resources they can access. These are spelled out in the
    API *contract*, which is human-readable documentation that describes how to use
    the API and how you can expect it to behave. API documentation differs from one
    organization to another but often includes a description of authentication requirements,
    user permission levels, API endpoints, and the required request parameters. It
    might also include usage examples. From an API hacker’s perspective, the documentation
    can reveal which endpoints to call for customer data, which API keys you need
    in order to become an administrator, and even business logic flaws.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: API使用者无法看到后端设计，他们只能看到可以交互的端点和可以访问的资源。这些内容在API的*契约*中列出，契约是人类可读的文档，描述了如何使用API以及你可以期望它的行为。API文档在不同的组织之间有所不同，但通常包括认证要求、用户权限级别、API端点和所需的请求参数的描述。它可能还包括使用示例。从API黑客的角度来看，文档可以揭示调用客户数据的端点，成为管理员所需的API密钥，甚至业务逻辑的缺陷。
- en: In the following box, the GitHub API documentation for the */applications/{client_id}/grants/{access_token}*
    endpoint, taken from [https://docs.github.com/en/rest/reference/apps](https://docs.github.com/en/rest/reference/apps),
    is an example of quality documentation.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下框中，来自[https://docs.github.com/en/rest/reference/apps](https://docs.github.com/en/rest/reference/apps)的GitHub
    API文档，针对*/applications/{client_id}/grants/{access_token}*端点，是优质文档的示例。
- en: The documentation for this endpoint includes the description of the purpose
    of the API request, the HTTP request method to use when interacting with the API
    endpoint, and the endpoint itself, */applications*, followed by variables.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 该端点的文档包括API请求的目的描述、与API端点交互时使用的HTTP请求方法，以及端点本身，*/applications*，后面跟随变量。
- en: The acronym *CRUD*, which stands for *Create, Read, Update, Delete*, describes
    the primary actions and methods used to interact with APIs. *Create* is the process
    of making new records, accomplished through a POST request. *Read* is data retrieval,
    done through a GET request. *Update* is how currently existing records are modified
    without being overwritten and is accomplished with POST or PUT requests. *Delete*
    is the process of erasing records, which can be done with POST or DELETE, as shown
    in this example. Note that CRUD is a best practice only, and developers may implement
    their APIs in other ways. Therefore, when you learn to hack APIs later on, we’ll
    test beyond the CRUD methods.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 缩写*CRUD*，即*创建、读取、更新、删除*，描述了与API交互时使用的主要操作和方法。*创建*是通过POST请求来创建新记录的过程。*读取*是数据检索，通过GET请求完成。*更新*是修改当前已存在记录而不覆盖的过程，通过POST或PUT请求完成。*删除*是删除记录的过程，可以通过POST或DELETE请求实现，如示例所示。请注意，CRUD仅仅是最佳实践，开发人员可能会以其他方式实现他们的API。因此，当你以后学习如何破解API时，我们将测试超越CRUD方法的内容。
- en: By convention, curly brackets mean that a given variable is necessary within
    the path parameters. The *{client_id}* variable must be replaced with an actual
    client’s ID, and the *{access_token}* variable must be replaced with your own
    access token. Tokens are what API providers use to identify and authorize requests
    to approved API consumers. Other API documentation might use a colon or square
    brackets to signify a variable (for example, */api/v2/:customers/* or */api/:collection/:client_id*).
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 按惯例，大括号表示在路径参数中需要一个特定的变量。*{client_id}* 变量必须替换为实际的客户端 ID，*{access_token}* 变量必须替换为你自己的访问令牌。令牌是
    API 提供者用来识别和授权对已批准的 API 消费者的请求的工具。其他 API 文档可能使用冒号或方括号来表示变量（例如，*/api/v2/:customers/*
    或 */api/:collection/:client_id*）。
- en: The “Parameters” section lays out the authentication and authorization requirements
    to perform the described actions, including the name of each parameter value,
    the type of data to provide, where to include the data, and a description of the
    parameter value.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: “参数”部分列出了执行所述操作所需的身份验证和授权要求，包括每个参数值的名称、提供的数据类型、数据的包含位置以及对参数值的描述。
- en: Standard Web API Types
  id: totrans-24
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 标准 Web API 类型
- en: APIs come in standard types, each of which varies in its rules, functions, and
    purpose. Typically, a given API will use only one type, but you may encounter
    endpoints that don’t match the format and structure of the others or don’t match
    a standard type at all. Being able to recognize typical and atypical APIs will
    help you know what to expect and test for as an API hacker. Remember, most public
    APIs are designed to be self-service, so a given API provider will often let you
    know the type of API you’ll be interacting with.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: API 有标准类型，每种类型在规则、功能和目的上有所不同。通常，给定的 API 将只使用一种类型，但你可能会遇到与其他 API 格式和结构不匹配的端点，或者根本不匹配任何标准类型。能够识别典型和非典型
    API 将帮助你了解作为 API 黑客需要期待什么并进行测试。记住，大多数公共 API 都是自助服务设计的，因此 API 提供者通常会告知你将与哪种类型的
    API 进行交互。
- en: 'This section describes the two primary API types we’ll focus on throughout
    this book: RESTful APIs and GraphQL. Later parts of the book, as well as the book’s
    labs, cover attacks against RESTful APIs and GraphQL only.'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 本节描述了本书将重点讨论的两种主要 API 类型：RESTful API 和 GraphQL。书中的后续部分以及实验部分将专门讨论对 RESTful API
    和 GraphQL 的攻击。
- en: RESTful APIs
  id: totrans-27
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: RESTful API
- en: '*Representational State Transfer (REST)* is a set of architectural constraints
    for applications that communicate using HTTP methods. APIs that use REST constraints
    are called *RESTful* (or just REST) APIs.'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: '*表现层状态转移（REST）* 是一组用于使用 HTTP 方法进行通信的应用程序架构约束。使用 REST 约束的 API 被称为 *RESTful*（或简称
    REST）API。'
- en: REST was designed to improve upon many of the inefficiencies of other older
    APIs, such as Simple Object Access Protocol (SOAP). For example, it relies entirely
    on the use of HTTP, which makes it much more approachable to end users. REST APIs
    primarily use the HTTP methods GET, POST, PUT, and DELETE to accomplish CRUD (as
    described in the section “How Web APIs Work”).
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: REST 旨在改进其他较老的 API（如简单对象访问协议 SOAP）的许多低效之处。例如，它完全依赖于使用 HTTP，这使得它对最终用户更为友好。REST
    API 主要使用 HTTP 方法 GET、POST、PUT 和 DELETE 来实现 CRUD（如“Web API 工作原理”一节所述）。
- en: 'RESTful design depends on six constraints. These constraints are “shoulds”
    instead of “musts,” reflecting the fact that REST is essentially a set of guidelines
    for an HTTP resource-based architecture:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: RESTful 设计依赖于六个约束条件。这些约束是“应该”而不是“必须”，反映了 REST 本质上是一套基于 HTTP 资源架构的指南：
- en: '**Uniform interface:** REST APIs should have a uniform interface. In other
    words, the requesting client device should not matter; a mobile device, an IoT
    (internet of things) device, and a laptop must all be able to access a server
    in the same way.'
  id: totrans-31
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**统一接口：**REST API 应该具有统一的接口。换句话说，客户端设备不应成为问题；无论是移动设备、物联网（IoT）设备还是笔记本电脑，都必须能够以相同的方式访问服务器。'
- en: '**Client/server:** REST APIs should have a client/server architecture. Clients
    are the consumers requesting information, and servers are the providers of that
    information.'
  id: totrans-32
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**客户端/服务器：**REST API 应该具有客户端/服务器架构。客户端是请求信息的消费者，服务器是提供信息的提供者。'
- en: '**Stateless:** REST APIs should not require stateful communications. REST APIs
    do not maintain state during communication; it is as though each request is the
    first one received by the server. The consumer will therefore need to supply everything
    the provider will need in order to act upon the request. This has the benefit
    of saving the provider from having to remember the consumer from one request to
    another. Consumers often provide tokens to create a state-like experience.'
  id: totrans-33
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**无状态：** REST API 不应要求有状态的通信。REST API 在通信过程中不维护状态；每次请求就像是服务器接收到的第一个请求。因此，消费者需要提供服务器执行请求所需的所有信息。这种方式的好处是，服务器无需记住每个请求之间的消费者信息。消费者通常会提供令牌来创建类似状态的体验。'
- en: '**Cacheable:** The response from the REST API provider should indicate whether
    the response is cacheable. *Caching* is a method of increasing request throughput
    by storing commonly requested data on the client side or in a server cache. When
    a request is made, the client will first check its local storage for the requested
    information. If it doesn’t find the information, it passes the request to the
    server, which checks its local storage for the requested information. If the data
    is not there either, the request could be passed to other servers, such as database
    servers, where the data can be retrieved.'
  id: totrans-34
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**可缓存：** REST API 提供者的响应应该指示该响应是否可以缓存。*缓存*是一种通过将常请求的数据存储在客户端或服务器缓存中来提高请求吞吐量的方法。当请求被发出时，客户端首先会检查本地存储是否有请求的信息。如果找不到，它会将请求传递给服务器，服务器再检查自己的本地存储。如果数据仍然找不到，请求可能会被传递给其他服务器，如数据库服务器，去检索数据。'
- en: As you might imagine, if the data is stored on the client, the client can immediately
    retrieve the requested data at little to no processing cost to the server. This
    also applies if the server has cached a request. The further down the chain a
    request has to go to retrieve data, the higher the resource cost and the longer
    it takes. Making REST APIs cacheable by default is a way to improve overall REST
    performance and scalability by decreasing response times and server processing
    power. APIs usually manage caching with the use of headers that explain when the
    requested information will expire from the cache.
  id: totrans-35
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 正如你所想象的，如果数据存储在客户端，客户端可以立即在几乎没有服务器处理成本的情况下检索请求的数据。如果服务器已经缓存了某个请求的结果，这同样适用。请求获取数据的链条越长，资源消耗越高，所需时间也越长。通过默认使
    REST API 可缓存，是提高整体 REST 性能和可扩展性的一种方式，能减少响应时间和服务器处理能力的消耗。API 通常使用头部信息来管理缓存，解释何时请求的信息会从缓存中过期。
- en: '**Layered system:** The client should be able to request data from an endpoint
    without knowing about the underlying server architecture.'
  id: totrans-36
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**分层系统：** 客户端应该能够从端点请求数据，而无需了解底层服务器架构。'
- en: '**Code on demand (optional):** Allows for code to be sent to the client for
    execution.'
  id: totrans-37
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**按需代码（可选）：** 允许将代码发送到客户端执行。'
- en: REST is a style rather than a protocol, so each RESTful API may be different.
    It may have methods enabled beyond CRUD, its own sets of authentication requirements,
    subdomains instead of paths for endpoints, different rate-limit requirements,
    and so on. Furthermore, developers or an organization may call their API “RESTful”
    without adhering to the standard, which means you can’t expect every API you come
    across to meet all the REST constraints.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: REST 是一种风格，而不是协议，因此每个 RESTful API 可能会有所不同。它可能启用了 CRUD 之外的方法，拥有自己的一套认证要求，使用子域名而非路径来定义端点，具有不同的速率限制要求，等等。此外，开发者或组织可能会将他们的
    API 称为“RESTful”，但并未遵循标准，这意味着你不能期望每个遇到的 API 都符合所有的 REST 限制。
- en: '[Listing 2-1](#listing2-1) shows a fairly typical REST API GET request used
    to find out how many pillows are in a store’s inventory. [Listing 2-2](#listing2-2)
    shows the provider’s response.'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: '[列表 2-1](#listing2-1) 显示了一个典型的 REST API GET 请求，用于查找商店库存中有多少个枕头。[列表 2-2](#listing2-2)
    显示了提供者的响应。'
- en: '[PRE0]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Listing 2-1: A sample RESTful API request'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 2-1：一个示例的 RESTful API 请求
- en: '[PRE1]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Listing 2-2: A sample RESTful API response'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 2-2：一个示例的 RESTful API 响应
- en: This REST API request is just an HTTP GET request to the specified URL. In this
    case, the request queries the store’s inventory for pillows. The provider responds
    with JSON indicating the item’s ID, name, and quantity of items in stock. If there
    was an error in the request, the provider would respond with an HTTP error code
    in the 400 range indicating what went wrong.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 这个 REST API 请求仅是一个 HTTP GET 请求，指向指定的 URL。在这个例子中，请求查询商店的枕头库存。提供者以 JSON 格式响应，显示该商品的
    ID、名称和库存数量。如果请求出错，提供者会以 400 范围的 HTTP 错误代码回应，指示问题所在。
- en: 'One thing to note: the *rest-shop.com* store provided all the information it
    had about the resource “pillow” in its response. If the consumer’s application
    only needed the name and value of the pillow, the consumer would need to filter
    out the additional information. The amount of information sent back to a consumer
    completely depends on how the API provider has programmed its API.'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 有一点需要注意：*rest-shop.com* 商店在其响应中提供了有关资源“枕头”的所有信息。如果消费者的应用程序只需要枕头的名称和值，消费者则需要过滤掉额外的信息。返回给消费者的信息量完全取决于
    API 提供者如何编程其 API。
- en: REST APIs have some common headers you should become familiar with. These are
    identical to HTTP headers but are more commonly seen in REST API requests than
    in other API types, so they can help you identify REST APIs. (Headers, naming
    conventions, and the data interchange format used are normally the best indicators
    of an API’s type.) The following subsections detail some of the common REST API
    headers you will come across.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: REST APIs 有一些常见的头，你应该熟悉它们。这些头与 HTTP 头是一样的，但在 REST API 请求中比在其他 API 类型中更常见，因此它们可以帮助你识别
    REST APIs。（头部、命名约定和数据交换格式通常是 API 类型的最佳指示器。）以下小节详细介绍了一些你会遇到的常见 REST API 头。
- en: Authorization
  id: totrans-47
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 授权
- en: '`Authorization` headers are used to pass a token or credentials to the API
    provider. The format of these headers is `Authorization: <type> <token/credentials>`.
    For example, take a look at the following authorization header:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: '`Authorization` 头用于将令牌或凭证传递给 API 提供者。这些头的格式是 `Authorization: <type> <token/credentials>`。例如，看看下面的授权头：'
- en: '[PRE2]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: There are different authorization types*.* `Basic` uses base64-encoded credentials.`Bearer`uses
    an API token. Finally,`AWS-HMAC-SHA256` is an AWS authorization type that uses
    an access key and a secret key.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 有不同的授权类型*.* `Basic` 使用 base64 编码的凭证，`Bearer` 使用 API 令牌，最后，`AWS-HMAC-SHA256`
    是一种 AWS 授权类型，使用访问密钥和密钥。
- en: Content Type
  id: totrans-51
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 内容类型
- en: '`Content-Type` headers are used to indicate the type of media being transferred.
    These headers differ from `Accept` headers, which state the media type you want
    to receive; `Content-Type` headers describe the media you’re sending.'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: '`Content-Type` 头用于指示正在传输的媒体类型。这些头与 `Accept` 头不同，后者表示你希望接收的媒体类型；`Content-Type`
    头描述你正在发送的媒体类型。'
- en: 'Here are some common `Content-Type`headers for REST APIs:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一些常见的 `Content-Type` 头用于 REST APIs：
- en: '`application/json` Used to specify JavaScript Object Notation (JSON) as a media
    type. JSON is the most common media type for REST APIs.'
  id: totrans-54
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`application/json` 用于指定 JavaScript 对象表示法（JSON）作为媒体类型。JSON 是 REST APIs 中最常见的媒体类型。'
- en: '`application/xml` Used to specify XML as a media type.'
  id: totrans-55
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`application/xml` 用于指定 XML 作为媒体类型。'
- en: '`application/x-www-form-``urlencoded` A format in which the values being sent
    are encoded and separated by an ampersand (`&`), and an equal sign (`=`) is used
    between key/value pairs.'
  id: totrans-56
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`application/x-www-form-``urlencoded` 一种格式，其中发送的值被编码并用一个和号 (`&`) 分隔，键值对之间使用等号
    (`=`)。'
- en: Middleware (X) Headers
  id: totrans-57
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 中间件 (X) 头
- en: '`X-<anything>` headers are known as *middleware headers* and can serve all
    sorts of purposes. They are fairly common outside of API requests as well. `X-Response-Time`
    can be used as an API response to indicate how long a response took to process.
    `X-API-Key` can be used as an authorization header for API keys. `X-Powered-By`
    can be used to provide additional information about backend services. `X-Rate-Limit`
    can be used to tell the consumer how many requests they can make within a given
    time frame. `X-RateLimit-Remaining` can tell a consumer how many requests remain
    before they violate rate-limit enforcement. (There are many more, but you get
    the idea.) `X-<anything>` middleware headers can provide a lot of useful information
    to API consumers and hackers alike.'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: '`X-<anything>` 头部被称为 *中间件头部*，可以用于各种目的。它们在 API 请求之外也相当常见。`X-Response-Time` 可作为
    API 响应，用于指示响应处理所花费的时间。`X-API-Key` 可作为 API 密钥的授权头部。`X-Powered-By` 可提供有关后端服务的附加信息。`X-Rate-Limit`
    可告知消费者在给定时间内可以发出多少请求。`X-RateLimit-Remaining` 可告知消费者在违反速率限制之前还能发出多少个请求。（还有许多其他的，但你明白这个意思。）`X-<anything>`
    中间件头部可以为 API 消费者和黑客提供大量有用信息。'
- en: GraphQL
  id: totrans-59
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: GraphQL
- en: Short for *Graph Query Language*, *GraphQL* is a specification for APIs that
    allow clients to define the structure of the data they want to request from the
    server. GraphQL is RESTful, as it follows the six constraints of REST APIs. However,
    GraphQL also takes the approach of being *query-centric*, because it is structured
    to function similarly to a database query language like Structured Query Language
    (SQL).
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: '*Graph Query Language*（图查询语言）的简称，*GraphQL* 是一种 API 规范，允许客户端定义它们希望从服务器请求的数据结构。GraphQL
    是 RESTful 的，因为它遵循 REST API 的六个约束。然而，GraphQL 也采用了 *查询中心* 的方法，因为它的结构类似于像结构化查询语言（SQL）这样的数据库查询语言。'
- en: 'As you might gather from the specification’s name, GraphQL stores the resources
    in a graph data structure. To access a GraphQL API, you’ll typically access the
    URL where it is hosted and submit an authorized request that contains query parameters
    as the body of a POST request, similar to the following:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你从规范的名称中可能得出的结论，GraphQL 将资源存储在图数据结构中。要访问 GraphQL API，通常需要访问其托管的 URL，并提交一个包含查询参数的授权请求作为
    POST 请求的主体，类似于以下内容：
- en: '[PRE3]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'In the right context, this query would provide you with the usernames, IDs,
    and emails of the requested resources. A GraphQL response to this query would
    look like the following:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 在正确的上下文中，这个查询将为你提供所请求资源的用户名、ID 和电子邮件。对这个查询的 GraphQL 响应将如下所示：
- en: '[PRE4]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: GraphQL improves on typical REST APIs in several ways. Since REST APIs are resource
    based, there will likely be instances when a consumer needs to make several requests
    in order to get all the data they need. On the other hand, if a consumer only
    needs a specific value from the API provider, the consumer will need to filter
    out the excess data. With GraphQL, a consumer can use a single request to get
    the exact data they want. That’s because, unlike REST APIs, where clients receive
    whatever data the server is programmed to return from an endpoint, including the
    data they don’t need, GraphQL APIs let clients request specific fields from a
    resource.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: GraphQL 在多个方面改进了典型的 REST API。由于 REST API 是基于资源的，消费者可能需要发出多个请求才能获取他们需要的所有数据。另一方面，如果消费者只需要来自
    API 提供者的特定值，消费者则需要筛选掉多余的数据。而 GraphQL 允许消费者通过单个请求获得他们想要的确切数据。这是因为与 REST API 不同，在
    REST API 中，客户端会接收到服务器程序设置的返回数据，其中包括他们不需要的数据，而 GraphQL API 允许客户端从资源中请求特定字段。
- en: GraphQL also uses HTTP, but it typically depends on a single entry point (URL)
    using the POST method. In a GraphQL request, the body of the POST request is what
    the provider processes. For example, take a look at the GraphQL request in [Listing
    2-3](#listing2-3) and the response in [Listing 2-4](#listing2-4), depicting a
    request to check a store’s inventory for graphics cards.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: GraphQL 也使用 HTTP，但通常依赖于一个使用 POST 方法的单一入口点（URL）。在一个 GraphQL 请求中，POST 请求的主体是服务提供者处理的内容。例如，查看
    [列表 2-3](#listing2-3) 中的 GraphQL 请求和 [列表 2-4](#listing2-4) 中的响应，展示了一个检查商店显卡库存的请求。
- en: '[PRE5]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Listing 2-3: An example GraphQL request'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 2-3：一个 GraphQL 请求示例
- en: '[PRE6]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Listing 2-4: An example GraphQL response'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 2-4：一个 GraphQL 响应示例
- en: As you can see, a query payload in the body specifies the information needed.
    The GraphQL request body begins with the query operation ❶, which is the equivalent
    of a GET request and used to obtain information from the API. The GraphQL node
    we are querying for, `"inventory"` ❷, is also known as the root query type. Nodes,
    similar to objects, are made up of fields ❸, similar to key/value pairs in REST.
    The main difference here is that we can specify the exact fields we are looking
    for. In this example, we are looking for the “price” and “quantity” fields. Finally,
    you can see that the GraphQL response only provided the requested fields for the
    specified graphics card ❹. Instead of getting the item ID, item name, and other
    superfluous information, the query resolved with only the fields that were needed.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，请求负载在主体中指定了所需的信息。GraphQL 请求体以查询操作 ❶ 开头，等同于 GET 请求，用于从 API 获取信息。我们正在查询的
    GraphQL 节点 `"inventory"` ❷ 也被称为根查询类型。节点类似于对象，由字段 ❸ 组成，类似于 REST 中的键值对。这里的主要区别在于我们可以指定具体的字段。在这个例子中，我们查询的是“价格”和“数量”字段。最后，你可以看到
    GraphQL 响应只提供了所请求的显卡的字段 ❹。没有获取商品 ID、商品名称和其他冗余信息，查询只返回了所需的字段。
- en: If this had been a REST API, it might have been necessary to send requests to
    different endpoints to get the quantity and then the brand of the graphics card,
    but with GraphQL you can build out a query for the specific information you are
    looking for from a single endpoint.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 如果这是一个 REST API，可能需要向不同的端点发送请求，先获取显卡的数量，再获取品牌，但使用 GraphQL，你可以从一个端点构建查询，获取所需的具体信息。
- en: 'GraphQL still functions using CRUD, which may sound confusing at first since
    it relies on POST requests. However, GraphQL uses three operations within the
    POST request to interact with GraphQL APIs: query, mutation, and subscription.
    *Query* is an operation to retrieve data (read). *Mutation* is an operation used
    to submit and write data (create, update, and delete). *Subscription* is an operation
    used to send data (read) when an event occurs. Subscription is a way for GraphQL
    clients to listen to live updates from the server.'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: GraphQL 仍然使用 CRUD 操作，刚开始可能会让人困惑，因为它依赖于 POST 请求。然而，GraphQL 在 POST 请求中使用三种操作与
    GraphQL API 交互：查询（query）、变更（mutation）和订阅（subscription）。*查询*是用于检索数据（读取）。*变更*是用于提交和写入数据（创建、更新和删除）。*订阅*是用于在事件发生时发送数据（读取）。订阅是
    GraphQL 客户端监听服务器实时更新的一种方式。
- en: GraphQL uses *schemas*, which are collections of the data that can be queried
    with the given service. Having access to the GraphQL schema is similar to having
    access to a REST API collection. A GraphQL schema will provide you with the information
    you’ll need in order to query the API.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: GraphQL 使用 *架构*，即可以通过给定服务查询的数据集合。访问 GraphQL 架构类似于访问 REST API 集合。GraphQL 架构将为你提供查询
    API 所需的信息。
- en: You can interact with GraphQL using a browser if there is a GraphQL IDE, like
    GraphiQL, in place (see [Figure 2-2](#figure2-2)).
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 如果有 GraphQL IDE（如 GraphiQL），你可以通过浏览器与 GraphQL 进行交互（见 [图 2-2](#figure2-2)）。
- en: Otherwise, you’ll need a GraphQL client such as Postman, Apollo-Client, GraphQL-Request,
    GraphQL-CLI, or GraphQL-Compose. In later chapters, we’ll use Postman as our GraphQL
    client.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 否则，你需要使用 GraphQL 客户端，如 Postman、Apollo-Client、GraphQL-Request、GraphQL-CLI 或 GraphQL-Compose。在后面的章节中，我们将使用
    Postman 作为 GraphQL 客户端。
- en: '![Screenshot of an interface with two windows: a left-hand window in which
    you can type GraphQL queries, and a right-hand window that populates with information
    about the GraphQL schema](image_fi/502444c02/F02002.png)'
  id: totrans-77
  prefs: []
  type: TYPE_IMG
  zh: '![接口截图，左侧窗口可以输入 GraphQL 查询，右侧窗口显示与 GraphQL 架构相关的信息](image_fi/502444c02/F02002.png)'
- en: 'Figure 2-2: The GraphiQL interface for GitHub'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2-2：GitHub 的 GraphiQL 接口
- en: REST API Specifications
  id: totrans-79
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: REST API 规范
- en: The variety of REST APIs has left room for other tools and standardizations
    to fill in some of the gaps. *API specifications*, or description languages, are
    frameworks that help organizations design their APIs, automatically create consistent
    human-readable documentation, and therefore help developers and users know what
    to expect regarding the API’s functionality and results. Without specifications,
    there would be little to no consistency between APIs. Consumers would have to
    learn how each API’s documentation was formatted and adjust their application
    to interact with each API.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: REST API 的多样性为其他工具和标准化留下了填补一些空白的空间。*API 规范*或描述语言是帮助组织设计其 API 的框架，自动创建一致的人类可读文档，并帮助开发者和用户了解
    API 功能和结果预期的工具。没有规范，API 之间的一致性将很少甚至没有。消费者必须了解每个 API 的文档格式，并调整其应用程序以与每个 API 交互。
- en: Instead, a consumer can program their application to ingest different specifications
    and then easily interact with any API using that given specification. In other
    words, you can think of specifications as the home electric sockets of APIs. Instead
    of having a unique electric socket for every home appliance, the use of a single
    consistent format throughout a home allows you to buy a toaster and plug it into
    a socket on any wall without any hassle.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，消费者可以编写其应用程序以接受不同的规范，然后轻松地与使用给定规范的任何 API 交互。换句话说，您可以将规范视为 API 的家庭电源插座。与为每个家用电器设计唯一的电源插座不同，贯穿整个家庭使用统一的格式使您能够在任何墙壁上的插座上购买烤面包机并插入，而无需任何麻烦。
- en: '*OpenAPI Specification 3.0 (OAS)*, previously known as Swagger, is one of the
    leading specifications for RESTful APIs. OAS helps organize and manage APIs by
    allowing developers to describe endpoints, resources, operations, and authentication
    and authorization requirements. They can then create human- and machine-readable
    API documentation, formatted as JSON or YAML. Consistent API documentation is
    good for developers and users.'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: '*OpenAPI Specification 3.0 (OAS)*，之前称为 Swagger，是 RESTful API 的主要规范之一。OAS 通过允许开发者描述端点、资源、操作以及认证和授权需求来帮助组织和管理
    API。开发者可以创建人类和机器可读的 API 文档，格式可以是 JSON 或 YAML。一致的 API 文档对开发者和用户都是有利的。'
- en: The *RESTful API Modeling Language (RAML)* is another way to consistently generate
    API documentation. RAML is an open specification that works exclusively with YAML
    for document formatting. Similar to OAS, RAML was designed to document, design,
    build, and test REST APIs. For more information about RAML, check out the raml-spec
    GitHub repo ([https://github.com/raml-org/raml-spec](https://github.com/raml-org/raml-spec)).
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: '*RESTful API 建模语言 (RAML)* 是另一种一致生成 API 文档的方法。RAML 是一种专门用于文档格式化的开放规范，完全采用 YAML。与
    OAS 类似，RAML 旨在文档化、设计、构建和测试 REST API。有关 RAML 的更多信息，请访问 raml-spec GitHub 仓库（[https://github.com/raml-org/raml-spec](https://github.com/raml-org/raml-spec)）。'
- en: In later chapters, we will use an API client called Postman to import specifications
    and get instant access to the capabilities of an organization’s APIs.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 在后续章节中，我们将使用一个名为 Postman 的 API 客户端来导入规范，并即时访问组织 API 的功能。
- en: API Data Interchange Formats
  id: totrans-85
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: API 数据交换格式
- en: 'APIs use several formats to facilitate the exchange of data. Additionally,
    specifications use these formats to document APIs. Some APIs, like SOAP, require
    a specific format, whereas others allow the client to specify the format to use
    in the request and response body. This section introduces three common formats:
    JSON, XML, and YAML. Familiarity with data interchange formats will help you recognize
    API types, what the APIs are doing, and how they handle data.'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: API 使用多种格式促进数据交换。此外，规范使用这些格式来记录 API。某些 API（如 SOAP）要求特定格式，而其他 API 允许客户端在请求和响应体中指定使用的格式。本节介绍三种常见的格式：JSON、XML
    和 YAML。熟悉数据交换格式将帮助您识别 API 类型、API 的功能及其如何处理数据。
- en: JSON
  id: totrans-87
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: JSON
- en: '*JavaScript Object Notation (JSON)* is the primary data interchange format
    we’ll use throughout this book, as it is widely used for APIs. It organizes data
    in a way that is both human-readable and easily parsable by applications; many
    programming languages can turn JSON into data types they can use.'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: '*JavaScript Object Notation (JSON)* 是本书中主要使用的数据交换格式，因为它广泛用于 API。JSON 以一种既可读又易于应用程序解析的方式组织数据；许多编程语言可以将
    JSON 转换为它们可以使用的数据类型。'
- en: 'JSON represents objects as key/value pairs separated by commas, within a pair
    of curly brackets, as follows:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: JSON 将对象表示为由逗号分隔的键/值对，位于一对大括号内，如下所示：
- en: '[PRE7]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Everything between the first curly bracket and the last is considered an object.
    Within the object are several key/value pairs, such as `"firstName": "James"`,
    `"lastName": "Lovell"`, and `"tripsToTheMoon": 2`. The first entry of the key/value
    pair (on the left) is the *key*, a string that describes the value pair, and the
    second is the *value* (on the right), which is some sort of data represented by
    one of the acceptable data types (strings, numbers, Boolean values, null, an array,
    or another object). For example, notice the Boolean value `false` for `"walkedOnMoon"`
    or the `"spacecrafts"` array surrounded by square brackets. Finally, the nested
    object `"book"` contains its own set of key/value pairs. [Table 2-1](#table2-1)
    describes JSON types in more detail.'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: '从第一个花括号到最后一个花括号之间的所有内容都被认为是一个对象。在该对象中，有几个键值对，例如 `"firstName": "James"`，`"lastName":
    "Lovell"`，和 `"tripsToTheMoon": 2`。键值对的第一个条目（左边）是 *键*，一个描述值对的字符串，第二个条目是 *值*（右边），它是某种类型的数据，表示为可接受的数据类型之一（字符串、数字、布尔值、null、数组或另一个对象）。例如，注意到
    `"walkedOnMoon"` 的布尔值为 `false`，或 `"spacecrafts"` 数组被方括号包围。最后，嵌套的对象 `"book"` 包含它自己的键值对集合。[表
    2-1](#table2-1) 更详细地描述了 JSON 类型。'
- en: 'JSON does not allow inline comments, so any sort of comment-like communications
    must take place as a key/value pair like `"comment" : "This is a comment"`. Alternatively,
    you can find comments in the API documentation or HTTP response.'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 'JSON 不允许内联注释，因此任何类似注释的内容必须作为键值对存在，例如 `"comment" : "这是一个注释"`。或者，你可以在 API 文档或
    HTTP 响应中找到注释。'
- en: 'Table 2-1: JSON Types'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 表 2-1：JSON 类型
- en: '| **Type** | **Description** | **Example** |'
  id: totrans-94
  prefs: []
  type: TYPE_TB
  zh: '| **类型** | **描述** | **示例** |'
- en: '| --- | --- | --- |'
  id: totrans-95
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| Strings | Any combination of characters within double quotes. | `{` `"Motto":"Hack
    the planet",`'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: '| 字符串 | 双引号内的任意字符组合。 | `{` `"Motto":"Hack the planet",`'
- en: '`"Drink":"Jolt",`'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: '`"Drink":"Jolt",`'
- en: '`"User”:"Razor"`'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: '`"User”:"Razor"`'
- en: '`}` |'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: '`}` |'
- en: '| Numbers | Basic integers, fractions, negative numbers, and exponents. Notice
    that the multiple items are comma-separated. | `{` `"number_1" : 101,`'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: '| 数字 | 基本整数、分数、负数和指数。请注意，多个项目之间用逗号分隔。 | `{` `"number_1" : 101,`'
- en: '`"number_2" : -102,`'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: '`"number_2" : -102,`'
- en: '`"number_3" : 1.03,`'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: '`"number_3" : 1.03,`'
- en: '`"number_4" : 1.0E+4`'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: '`"number_4" : 1.0E+4`'
- en: '`}` |'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: '`}` |'
- en: '| Boolean values | Either `true` or `false`. | `{` `"admin" : false,`'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: '| 布尔值 | `true` 或 `false`。 | `{` `"admin" : false,`'
- en: '`"privesc" : true`'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: '`"privesc" : true`'
- en: '`}` |'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: '`}` |'
- en: '| Null | No value. | `{` `"value" : null`'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: '| Null | 没有值。 | `{` `"value" : null`'
- en: '`}` |'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: '`}` |'
- en: '| Arrays | An ordered collection of values. Collections of values are surrounded
    by brackets (`[]`) and the values are comma-separated. | `{` `"uid" : ["1","2","3"]`'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: '| 数组 | 有序的值集合。值集合由括号（`[]`）括起来，且值之间用逗号分隔。 | `{` `"uid" : ["1","2","3"]`'
- en: '`}` |'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: '`}` |'
- en: '| Objects | An unordered set of value pairs inserted between curly brackets
    (`{}`). An object can contain multiple key/value pairs. | `{` `"admin" : false,`'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: '| 对象 | 无序的值对集合，插入在花括号（`{}`）之间。一个对象可以包含多个键值对。 | `{` `"admin" : false,`'
- en: '`"key" : "value",`'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: '`"key" : "value",`'
- en: '`"privesc" : true,`'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: '`"privesc" : true,`'
- en: '`"uid" : 101,`'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: '`"uid" : 101,`'
- en: '`"vulnerabilities" : "galore"`'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: '`"vulnerabilities" : "众多漏洞"`'
- en: '`}` |'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: '`}` |'
- en: 'To illustrate these types, take a look at the following key/value pairs in
    the JSON data found in a Twitter API response:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 为了说明这些类型，看看以下在 Twitter API 响应中找到的 JSON 数据中的键值对：
- en: '[PRE8]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: In this example, you should be able to identify the number `1278533978970976256`
    ❶, strings like those for the keys `"id_str"` and `"full_text"` ❷, and the Boolean
    value ❸ for `"truncated"`.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，你应该能够识别数字 `1278533978970976256` ❶，像 `"id_str"` 和 `"full_text"` 这样的字符串
    ❷，以及 `"truncated"` 的布尔值 ❸。
- en: XML
  id: totrans-121
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: XML
- en: The *Extensible Markup Language (XML)* format has been around for a while, and
    you’ll probably recognize it. XML is characterized by the descriptive tags it
    uses to wrap data. Although REST APIs can use XML, it is most commonly associated
    with SOAP APIs. SOAP APIs can only use XML as the data interchange.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: '*扩展标记语言 (XML)* 格式已经存在一段时间了，你可能会认识它。XML 的特点是使用描述性标签来包装数据。尽管 REST API 可以使用 XML，但它通常与
    SOAP API 相关联。SOAP API 只能使用 XML 作为数据交换格式。'
- en: 'The Twitter JSON you just saw would look like the following if converted to
    XML:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 你刚刚看到的 Twitter JSON，如果转换成 XML 会是如下所示：
- en: '[PRE9]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: XML always begins with a *prolog*, which contains information about the XML
    version and encoding used ❶.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: XML 总是以 *前导部分* 开始，包含有关所使用的 XML 版本和编码的信息 ❶。
- en: 'Next, *elements* are the most basic parts of XML. An element is any XML tag
    or information surrounded by tags. In the previous example, `<id>1278533978970976300</id>`,
    `<id_str>1278533978</id_str>`, `<full_text>`, `</full_text>`, and `<truncated>false</truncated>`
    are all elements. XML must have a root element and can contain child elements.
    In the example, the root element is `<root>` ❷. The child elements are XML attributes.
    An example of a child element is the `<BookGenre>` element within the following
    example:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，*元素* 是 XML 中最基本的部分。元素是任何 XML 标签或被标签包围的信息。在之前的示例中，`<id>1278533978970976300</id>`，`<id_str>1278533978</id_str>`，`<full_text>`，`</full_text>`，和
    `<truncated>false</truncated>` 都是元素。XML 必须有一个根元素，并且可以包含子元素。在这个示例中，根元素是 `<root>`
    ❷。子元素是 XML 属性。以下示例中，`<BookGenre>` 元素就是一个子元素的例子：
- en: '[PRE10]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Comments in XML are surrounded by two dashes, like this: `<!--XML comment example-->`.'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: XML 中的注释由两个破折号包围，如下所示：`<!--XML 注释示例-->`。
- en: 'The key differences between XML and JSON are JSON’s descriptive tags, character
    encoding, and length: the XML takes much longer to convey the same information,
    a whopping 565 bytes.'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: XML 和 JSON 之间的主要区别是 JSON 的描述性标签、字符编码和长度：XML 需要更长时间来传达相同的信息，足足需要 565 字节。
- en: YAML
  id: totrans-130
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: YAML
- en: Another lightweight form of data exchange used in APIs, *YAML* is a recursive
    acronym that stands for *YAML Ain’t Markup Language*. It was created as a more
    human- and computer-readable format for data exchange.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种轻量级的数据交换形式用于 API，*YAML* 是一个递归缩写，代表 *YAML Ain’t Markup Language*。它被创建为一种更易于人类和计算机阅读的数据交换格式。
- en: 'Like JSON, YAML documents contain key/value pairs. The value may be any of
    the YAML data types, which include numbers, strings, Booleans, null values, and
    sequences. For example, take a look at the following YAML data:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 与 JSON 类似，YAML 文档包含键/值对。值可以是任何 YAML 数据类型，包括数字、字符串、布尔值、空值和序列。例如，查看以下 YAML 数据：
- en: '[PRE11]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: You’ll notice that YAML is much more readable than JSON. YAML documents begin
    with
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 你会注意到 YAML 比 JSON 更易读。YAML 文档以
- en: '[PRE12]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: and end with
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 并以此结束
- en: '[PRE13]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: instead of with curly brackets. Also, quotes around strings are optional. Additionally,
    URLs don’t need to be encoded with backslashes. Finally, YAML uses indentation
    instead of curly brackets to represent nesting and allows for comments beginning
    with `#`.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 而不是使用花括号。此外，字符串周围的引号是可选的。此外，URLs 不需要使用反斜杠进行编码。最后，YAML 使用缩进代替花括号表示嵌套，并允许以 `#`
    开头的注释。
- en: API specifications will often be formatted as JSON or YAML, because these formats
    are easy for humans to digest. With only a few basic concepts in mind, we can
    look at either of these formats and understand what is going on; likewise, machines
    can easily parse the information.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: API 规范通常以 JSON 或 YAML 格式呈现，因为这些格式易于人类理解。只要掌握几个基本概念，我们就可以查看这两种格式并理解其内容；同样，机器也能轻松解析这些信息。
- en: If you’d like to see more YAML in action, visit [https://yaml.org](https://yaml.org).
    The entire website is presented in YAML format. YAML is recursive all the way
    down.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想查看更多 YAML 的应用示例，请访问 [https://yaml.org](https://yaml.org)。整个网站以 YAML 格式呈现，YAML
    是递归的，一直到最深处。
- en: API Authentication
  id: totrans-141
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: API 身份验证
- en: 'APIs may allow public access to consumers without authentication, but when
    an API allows access to proprietary or sensitive data, it will use some form of
    authentication and authorization. An API’s authentication process should validate
    that users are who they claim to be, and the authorization process should grant
    them the ability to access the data they are allowed to access. This section covers
    a variety of API authentication and authorization methods. These methods vary
    in complexity and security, but they all operate on a common principle: the consumer
    must send some kind of information to the provider when making a request, and
    the provider must link that information to a user before granting or denying access
    to a resource.'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: API 可能允许消费者在没有身份验证的情况下公开访问，但当 API 允许访问专有或敏感数据时，它将使用某种形式的身份验证和授权。API 的身份验证过程应该验证用户是否为其声称的身份，而授权过程应该授予他们访问所允许数据的权限。本节涵盖了多种
    API 身份验证和授权方法。这些方法在复杂性和安全性上有所不同，但它们都有一个共同的原则：消费者在发起请求时必须向提供方发送某种信息，提供方必须将该信息与用户关联，然后才能授予或拒绝对资源的访问。
- en: Before jumping into API authentication, it is important to understand what authentication
    is. Authentication is the process of proving and verifying an identity. In a web
    application, authentication is the way you prove to the web server that you are
    a valid user of said web app. Typically, this is done through the use of credentials,
    which consist of a unique ID (such as a username or email) and password. After
    a client sends credentials, the web server compares what was sent to the credentials
    it has stored. If the credentials provided match the credentials stored, the web
    server will create a user session and issue a cookie to the client.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 在深入了解 API 认证之前，了解认证的含义非常重要。认证是验证身份的过程。在 Web 应用中，认证是你向 Web 服务器证明你是该 Web 应用的有效用户的方式。通常，这是通过使用凭据完成的，凭据包括唯一的
    ID（如用户名或电子邮件）和密码。客户端在发送凭据后，Web 服务器会将其与存储的凭据进行比对。如果提供的凭据与存储的凭据匹配，Web 服务器会创建一个用户会话并向客户端发放
    cookie。
- en: When the session ends between the web app and user, the web server will destroy
    the session and remove the associated client cookies.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 当 Web 应用与用户之间的会话结束时，Web 服务器会销毁会话并移除相关的客户端 cookie。
- en: As described earlier in this chapter, REST and GraphQL APIs are stateless, so
    when a consumer authenticates to these APIs, no session is created between the
    client and server. Instead, the API consumer must prove their identity within
    every request sent to the API provider’s web server.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 如本章早些时候所述，REST 和 GraphQL API 是无状态的，因此当消费者对这些 API 进行认证时，客户端和服务器之间不会创建会话。相反，API
    消费者必须在每个发送到 API 提供者 Web 服务器的请求中证明自己的身份。
- en: Basic Authentication
  id: totrans-146
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 基本认证
- en: The simplest form of API authentication is *HTTP basic authentication*, in which
    the consumer includes their username and password in a header or the body of a
    request. The API could either pass the username and password to the provider in
    plaintext, like `username:password`, or it could encode the credentials using
    something like base64 to save space (for example, as `dXNlcm5hbWU6cGFzc3dvcmQK`).
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 最简单的 API 认证形式是 *HTTP 基本认证*，消费者将用户名和密码包含在请求的头部或正文中。API 可以将用户名和密码以明文形式传递给提供者，如
    `username:password`，或者它可以使用类似 base64 的方式编码凭据来节省空间（例如，编码为 `dXNlcm5hbWU6cGFzc3dvcmQK`）。
- en: 'Encoding is not encryption, and if base64-encoded data is captured, it can
    easily be decoded. For example, you can use the Linux command line to base64-encode
    `username:password` and then decode the encoded result:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 编码并不是加密，如果 base64 编码的数据被捕获，它可以很容易地被解码。例如，你可以使用 Linux 命令行对 `username:password`
    进行 base64 编码，然后解码编码结果：
- en: '[PRE14]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: As you can see, basic authentication has no inherent security and completely
    depends on other security controls. An attacker can compromise basic authentication
    by capturing HTTP traffic, performing a man-in-the-middle attack, tricking the
    user into providing their credentials through social engineering tactics, or performing
    a brute-force attack in which they attempt various usernames and passwords until
    they find some that work.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，基本认证本身没有内在的安全性，完全依赖于其他安全控制措施。攻击者可以通过捕获 HTTP 流量、执行中间人攻击、通过社交工程手段诱使用户提供凭据，或者进行暴力破解攻击，尝试不同的用户名和密码直到找到有效的凭据，从而突破基本认证。
- en: Since APIs are often stateless, those using only basic authentication require
    the consumer to provide credentials in every request. It is common for an API
    provider to instead use basic authentication once, for the first request, and
    then issue an API key or some other token for all other requests.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 API 通常是无状态的，只有基本认证的 API 需要消费者在每次请求中提供凭据。通常，API 提供者会在首次请求时使用基本认证，并随后发放 API
    密钥或其他令牌用于所有其他请求。
- en: API Keys
  id: totrans-152
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: API 密钥
- en: '*API keys* are unique strings that API providers generate and grant to authorize
    access for approved consumers. Once an API consumer has a key, they can include
    it in requests whenever specified by the provider. The provider will typically
    require that the consumer pass the key in query string parameters, request headers,
    body data, or as a cookie when they make a request.'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: '*API 密钥*是由 API 提供者生成并授予的唯一字符串，用于授权批准的消费者访问。一旦 API 消费者拥有密钥，他们可以在每次按提供者要求的请求中包含它。提供者通常要求消费者在查询字符串参数、请求头、正文数据或作为
    cookie 时传递该密钥。'
- en: 'API keys typically look like semi-random or random strings of numbers and letters.
    For example, take a look at the API key included in the query string of the following
    URL:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: API 密钥通常看起来像是半随机或随机的数字和字母字符串。例如，查看以下 URL 查询字符串中包含的 API 密钥：
- en: '[PRE15]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'The following is an API key included as a header:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是作为头部包含的API密钥：
- en: '[PRE16]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Finally, here is an API key passed in as a cookie:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，这里是作为cookie传递的API密钥：
- en: '[PRE17]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: The process of acquiring an API key depends on the provider. The NASA API, for
    example, requires the consumer to register for the API with a name, email address,
    and optional application URL (if the user is programming an application to use
    the API), as shown in [Figure 2-3](#figure2-3).
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 获取API密钥的过程取决于提供者。例如，NASA的API要求消费者注册API，提供姓名、电子邮件地址和可选的应用程序URL（如果用户正在编写一个使用API的应用程序），如[图2-3](#figure2-3)所示。
- en: '![Screenshot of an online form for Generating an API key. Includes fields for
    First Name, Last Name, Email, and Application URL.](image_fi/502444c02/F02003.png)'
  id: totrans-161
  prefs: []
  type: TYPE_IMG
  zh: '![生成API密钥的在线表单截图。包括姓名、姓氏、电子邮件和应用程序URL字段。](image_fi/502444c02/F02003.png)'
- en: 'Figure 2-3: NASA’s form to generate an API key'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 图2-3：NASA生成API密钥的表单
- en: 'The resulting key will look something like this:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 生成的密钥将类似于以下内容：
- en: '`roS6SmRjLdxZzrNSAkxjCdb6WodSda2G9zc2Q7sK`'
  id: totrans-164
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`roS6SmRjLdxZzrNSAkxjCdb6WodSda2G9zc2Q7sK`'
- en: 'It must be passed as a URL parameter in each API request, as follows:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 它必须作为每个API请求中的URL参数传递，格式如下：
- en: '*api.nasa.gov/planetary/apod?api_key=roS6SmRjLdxZzrNSAkxjCdb6WodSda2G9zc2Q7sK*'
  id: totrans-166
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '*api.nasa.gov/planetary/apod?api_key=roS6SmRjLdxZzrNSAkxjCdb6WodSda2G9zc2Q7sK*'
- en: API keys can be more secure than basic authentication for several reasons. When
    keys are sufficiently long, complex, and randomly generated, they can be exceedingly
    difficult for an attacker to guess or brute-force. Additionally, providers can
    set expiration dates to limit the length of time for which the keys are valid.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: API密钥在多种原因下比基本身份验证更安全。当密钥足够长、复杂且随机生成时，攻击者猜测或暴力破解它们会变得极为困难。此外，提供商可以设置过期日期来限制密钥的有效时间长度。
- en: However, API keys have several associated risks that we will take advantage
    of later in this book. Since each API provider may have their own system for generating
    API keys, you’ll find instances in which the API key is generated based on user
    data. In these cases, API hackers may guess or forge API keys by learning about
    the API consumers. API keys may also be exposed to the internet in online repositories,
    left in code comments, intercepted when transferred over unencrypted connections,
    or stolen through phishing.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，API密钥存在一些相关的风险，我们将在本书后面利用这些风险。由于每个API提供商可能有自己的生成API密钥的系统，因此你会发现一些情况，其中API密钥是基于用户数据生成的。在这些情况下，API黑客可能通过了解API消费者来猜测或伪造API密钥。API密钥还可能暴露在互联网上的在线代码库中，留在代码注释中，或者在未加密的连接上传输时被拦截，甚至通过钓鱼攻击被盗。
- en: JSON Web Tokens
  id: totrans-169
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: JSON Web Tokens
- en: 'A *JSON Web Token (JWT)* is a type of token commonly used in API token-based
    authentication. It’s used like this: The API consumer authenticates to the API
    provider with a username and password. The provider generates a JWT and sends
    it back to the consumer. The consumer adds the provided JWT to the `Authorization`
    header in all API requests.'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: '*JSON Web Token (JWT)* 是一种常用于API基于令牌的身份验证的令牌。它的使用方式是：API消费者使用用户名和密码向API提供商进行身份验证。提供商生成JWT并将其发送回消费者。消费者将提供的JWT添加到所有API请求的`Authorization`头部。'
- en: 'JWTs consist of three parts, all of which are base64-encoded and separated
    by periods: the header, the payload, and the signature. The *header* includes
    information about the algorithm used to sign the payload. The *payload* is the
    data included within the token, such as a username, timestamp, and issuer. The
    *signature* is the encoded and encrypted message used to validate the token.'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: JWT由三部分组成，所有部分都是base64编码并通过句点分隔：头部、负载和签名。*头部*包含有关用于签名负载的算法的信息。*负载*是包含在令牌中的数据，例如用户名、时间戳和发行者。*签名*是用于验证令牌的编码和加密消息。
- en: '[Table 2-2](#table2-2) shows an example of these parts, unencoded for readability,
    as well as the final token.'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: '[表2-2](#table2-2)展示了这些部分的示例，未编码以便于阅读，以及最终的令牌。'
- en: 'Table 2-2: JWT Components'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 表2-2：JWT组件
- en: '| **Component** | **Content** |'
  id: totrans-174
  prefs: []
  type: TYPE_TB
  zh: '| **Component** | **Content** |'
- en: '| --- | --- |'
  id: totrans-175
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| Header | `{` `"alg": "HS512",`'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: '| Header | `{` `"alg": "HS512",`'
- en: '`"typ": "JWT"`'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: '`"typ": "JWT"`'
- en: '`}` |'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: '`}` |'
- en: '| Payload | `{` `"sub": "1234567890",`'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: '| Payload | `{` `"sub": "1234567890",`'
- en: '`"name": "hAPI Hacker",`'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: '`"name": "hAPI Hacker",`'
- en: '`"iat": 1516239022`'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: '`"iat": 1516239022`'
- en: '`}` |'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: '`}` |'
- en: '| Signature | `HMACSHA512(` `base64UrlEncode(header) + "." +`'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: '| Signature | `HMACSHA512(` `base64UrlEncode(header) + "." +`'
- en: '`base64UrlEncode(payload),`'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: '`base64UrlEncode(payload),`'
- en: '`SuperSecretPassword`'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: '`SuperSecretPassword`'
- en: '`)` |'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: '`)` |'
- en: '| JWT | `eyJhbGciOiJIUzUxMiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6ImhBUEkgSGFja2VyIiwiaWF0IjoxNTE2MjM5MDIyfQ.zsUjGDbBjqI-bJbaUmvUdKaGSEvROKfNjy9K6TckK55sd97AMdPDLxUZwsneff4O1ZWQikhgPm7HHlXYn4jm0Q`
    |'
  id: totrans-187
  prefs: []
  type: TYPE_TB
  zh: '| JWT | `eyJhbGciOiJIUzUxMiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6ImhBUEkgSGFja2VyIiwiaWF0IjoxNTE2MjM5MDIyfQ.zsUjGDbBjqI-bJbaUmvUdKaGSEvROKfNjy9K6TckK55sd97AMdPDLxUZwsneff4O1ZWQikhgPm7HHlXYn4jm0Q`
    |'
- en: JWTs are generally secure but can be implemented in ways that will compromise
    that security. API providers can implement JWTs that do not use encryption, which
    means you would be one base64 decode away from being able to see what is inside
    the token. An API hacker could decode such a token, tamper with the contents,
    and send it back to the provider to gain access, as you will see in Chapter 10.
    The JWT secret key may also be stolen or guessed by brute force.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: JWT通常是安全的，但如果实现不当，可能会危及其安全性。API提供者可以实现不使用加密的JWT，这意味着你只需要进行一次base64解码就可以看到令牌内部的内容。API黑客可能会解码这样的令牌，篡改内容后再将其发送回提供者，从而获得访问权限，正如你将在第10章看到的那样。JWT的密钥也可能被盗或通过暴力破解猜到。
- en: HMAC
  id: totrans-189
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: HMAC
- en: A *hash-based message authentication code (HMAC)* is the primary API authentication
    method used by Amazon Web Services (AWS). When using HMAC, the provider creates
    a secret key and shares it with consumer. When a consumer interacts with the API,
    an HMAC hash function is applied to the consumer’s API request data and secret
    key. The resulting hash (also called a *message digest*) is added to the request
    and sent to the provider. The provider calculates the HMAC, just as the consumer
    did, by running the message and key through the hash function, and then compares
    the output hash value to the value provided by the client. If the provider’s hash
    value matches the consumer’s hash value, the consumer is authorized to make the
    request. If the values do not match, either the client’s secret key is incorrect
    or the message has been tampered with.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: '*基于哈希的消息认证码（HMAC）*是Amazon Web Services（AWS）使用的主要API认证方法。当使用HMAC时，提供者会创建一个密钥并与消费者共享。当消费者与API交互时，HMAC哈希函数会应用于消费者的API请求数据和密钥。生成的哈希（也称为*消息摘要*）会添加到请求中并发送给提供者。提供者像消费者一样，通过将消息和密钥输入哈希函数来计算HMAC，并将输出的哈希值与客户端提供的哈希值进行比较。如果提供者的哈希值与消费者的哈希值匹配，则消费者被授权发起请求。如果值不匹配，则可能是客户端的密钥不正确或消息被篡改。'
- en: The security of the message digest depends on the cryptographic strength of
    the hash function and secret key. Stronger hash mechanisms typically produce longer
    hashes. [Table 2-3](#table2-3) shows the same message and key hashed by different
    HMAC algorithms.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 消息摘要的安全性取决于哈希函数和密钥的加密强度。更强的哈希机制通常会生成更长的哈希值。[表 2-3](#table2-3)显示了使用不同HMAC算法对相同的消息和密钥进行哈希后的结果。
- en: 'Table 2-3: HMAC Algorithms'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 表 2-3：HMAC算法
- en: '| **Algorithm** | **Hash output** |'
  id: totrans-193
  prefs: []
  type: TYPE_TB
  zh: '| **算法** | **哈希输出** |'
- en: '| --- | --- |'
  id: totrans-194
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| HMAC-MD5 | f37438341e3d22aa11b4b2e838120dcf |'
  id: totrans-195
  prefs: []
  type: TYPE_TB
  zh: '| HMAC-MD5 | f37438341e3d22aa11b4b2e838120dcf |'
- en: '| HMAC-SHA1 | 4c2de361ba8958558de3d049ed1fb5c115656e65 |'
  id: totrans-196
  prefs: []
  type: TYPE_TB
  zh: '| HMAC-SHA1 | 4c2de361ba8958558de3d049ed1fb5c115656e65 |'
- en: '| HMAC-SHA256 | be8e73ffbd9a953f2ec892f06f9a5e91e6551023d1942ec7994fa1a78a5ae6bc
    |'
  id: totrans-197
  prefs: []
  type: TYPE_TB
  zh: '| HMAC-SHA256 | be8e73ffbd9a953f2ec892f06f9a5e91e6551023d1942ec7994fa1a78a5ae6bc
    |'
- en: '| HMAC-SHA512 | 6434a354a730f888865bc5755d9f498126d8f67d73f32ccd2b775c47c91ce26b66dfa59c25aed7f4a6bcb4786d3a3c6130f63ae08367822af3f967d3a7469e1b
    |'
  id: totrans-198
  prefs: []
  type: TYPE_TB
  zh: '| HMAC-SHA512 | 6434a354a730f888865bc5755d9f498126d8f67d73f32ccd2b775c47c91ce26b66dfa59c25aed7f4a6bcb4786d3a3c6130f63ae08367822af3f967d3a7469e1b
    |'
- en: You may have some red flags regarding the use of SHA1 or MD5\. As of the writing
    of this book, there are currently no known vulnerabilities affecting HMAC-SHA1
    and HMAC-MD5, but these functions are cryptographically weaker than SHA-256 and
    SHA-512\. However, the more secure functions are also slower. The choice of which
    hash function to use comes down to prioritizing either performance or security.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会对使用SHA1或MD5有所担忧。截至本书写作时，目前尚未发现影响HMAC-SHA1和HMAC-MD5的已知漏洞，但这些函数的加密强度低于SHA-256和SHA-512。然而，更安全的函数也更慢。选择使用哪种哈希函数取决于优先考虑性能还是安全性。
- en: As with the previous authentication methods covered, the security of HMAC depends
    on the consumer and provider keeping the secret key private. If a secret key is
    compromised, an attacker could impersonate the victim and gain unauthorized access
    to the API.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 与之前介绍的认证方法一样，HMAC的安全性取决于消费者和提供者保持密钥的私密性。如果密钥被泄露，攻击者可能冒充受害者，获得未授权的API访问权限。
- en: OAuth 2.0
  id: totrans-201
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: OAuth 2.0
- en: '*OAuth 2.0*, or just *OAuth*, is an authorization standard that allows different
    services to access each other’s data, often using APIs to facilitate the service-to-service
    communications.'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: '*OAuth 2.0*，或简称*OAuth*，是一种授权标准，允许不同的服务访问彼此的数据，通常使用API来促进服务之间的通信。'
- en: Let’s say you want to automatically share your Twitter tweets on LinkedIn. In
    OAuth’s model, we would consider Twitter to be the service provider and LinkedIn
    to be the application or client. In order to post your tweets, LinkedIn will need
    authorization to access your Twitter information. Since both Twitter and LinkedIn
    have implemented OAuth, instead of providing your credentials to the service provider
    and consumer every time you want to share this information across platforms, you
    can simply go into your LinkedIn settings and authorize Twitter. Doing so will
    send you to *api.twitter.com* to authorize LinkedIn to access your Twitter account
    (see [Figure 2-4](#figure2-4)).
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你希望自动将你的Twitter推文分享到LinkedIn。在OAuth模型中，我们会将Twitter视为服务提供商，将LinkedIn视为应用程序或客户端。为了发布你的推文，LinkedIn需要授权访问你的Twitter信息。由于Twitter和LinkedIn都已经实现了OAuth，与你每次希望跨平台共享信息时都提供凭证不同，你可以简单地进入LinkedIn设置并授权Twitter。这样做会将你引导到*api.twitter.com*，授权LinkedIn访问你的Twitter帐户（见[图2-4](#figure2-4)）。
- en: '![Screenshot of a Twitter web page asking if you want to authorize LinkedIn
    to access your account. Includes Authorize app and Cancel buttons.](image_fi/502444c02/F02004.png)'
  id: totrans-204
  prefs: []
  type: TYPE_IMG
  zh: '![截图显示Twitter网页询问是否授权LinkedIn访问你的帐户。包含授权应用和取消按钮。](image_fi/502444c02/F02004.png)'
- en: 'Figure 2-4: LinkedIn–Twitter OAuth authorization request'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 图2-4：LinkedIn–Twitter OAuth授权请求
- en: When you authorize LinkedIn to access your Twitter posts, Twitter generates
    a limited, time-based access token for LinkedIn. LinkedIn then provides that token
    to Twitter to post on your behalf, and you don’t have to give LinkedIn your Twitter
    credentials.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 当你授权LinkedIn访问你的Twitter帖子时，Twitter会为LinkedIn生成一个有限的、基于时间的访问令牌。LinkedIn随后将该令牌提供给Twitter以代表你发布内容，你无需向LinkedIn提供你的Twitter凭证。
- en: '[Figure 2-5](#figure2-5) shows the general OAuth process. The user (*resource
    owner*) grants an application (the *client*) access to a service (the *authorization
    server*), the service creates a token, and then the application uses the token
    to exchange data with the service (also the *resource server*).'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: '[图2-5](#figure2-5)展示了OAuth的一般过程。用户（*资源所有者*）授予应用程序（*客户端*）访问某个服务（*授权服务器*），服务创建一个令牌，然后应用程序使用该令牌与服务（也是*资源服务器*）交换数据。'
- en: In the LinkedIn–Twitter example, you are the resource owner, LinkedIn is the
    application/client, and Twitter is the authorization server and resource server.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 在LinkedIn–Twitter示例中，你是资源所有者，LinkedIn是应用程序/客户端，Twitter是授权服务器和资源服务器。
- en: '![Diagram showing the communications between LinkedIn and Twitter during the
    OAuth authorization process. Includes the following steps: 1) Authorization request
    (from LinkedIn to the user), 2) Authorization grant (from the user to LinkedIn),
    3) Authorization grant (from LinkedIn to the user), 4) Access token (from the
    authorization server to LinkedIn), 5) Access token (from LinkedIn to the resource
    server), and 6) Protected resource (from the resource server to LinkedIn).](image_fi/502444c02/F02005.png)'
  id: totrans-209
  prefs: []
  type: TYPE_IMG
  zh: '![图示显示了LinkedIn和Twitter在OAuth授权过程中之间的通信。包括以下步骤：1）授权请求（从LinkedIn到用户），2）授权许可（从用户到LinkedIn），3）授权许可（从LinkedIn到用户），4）访问令牌（从授权服务器到LinkedIn），5）访问令牌（从LinkedIn到资源服务器），以及6）受保护资源（从资源服务器到LinkedIn）。](image_fi/502444c02/F02005.png)'
- en: 'Figure 2-5: An illustration of the OAuth process'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 图2-5：OAuth过程示意图
- en: OAuth is one of the most trusted forms of API authorization. However, while
    it adds security to the authorization process, it also expands the potential attack
    surface—although flaws often have more to do with how the API provider implements
    OAuth than with OAuth itself. API providers that poorly implement OAuth can expose
    themselves to a variety of attacks such as token injection, authorization code
    reuse, cross-site request forgery, invalid redirection, and phishing.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: OAuth是最受信任的API授权方式之一。然而，虽然它为授权过程增加了安全性，但也扩大了潜在的攻击面——尽管漏洞通常更多是与API提供商如何实现OAuth有关，而不是OAuth本身。实现OAuth不当的API提供商可能会暴露于各种攻击，如令牌注入、授权码重用、跨站请求伪造、无效重定向和钓鱼攻击。
- en: No Authentication
  id: totrans-212
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 无认证
- en: As in web applications generally, there are plenty of instances where it is
    valid for an API to have no authentication at all. If an API does not handle sensitive
    data and only provides public information, the provider could make the case that
    no authentication is necessary.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 与一般的网页应用程序一样，API 没有任何认证的情况也是有效的。如果一个 API 不处理敏感数据且只提供公共信息，提供方可以认为不需要认证。
- en: 'APIs in Action: Exploring Twitter’s API'
  id: totrans-214
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实际中的 API：探索 Twitter 的 API
- en: After reading this and the previous chapter, you should understand the various
    components running beneath the GUI of a web application. Let’s now make these
    concepts more concrete by taking a close look at Twitter’s API. If you open a
    web browser and visit the URL [https://twitter.com](https://twitter.com), the
    initial request triggers a series of communications between the client and the
    server. Your browser automatically orchestrates these data transfers, but by using
    a web proxy like Burp Suite, which we’ll set up in Chapter 4, you can see all
    the requests and responses in action.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 阅读完本章和上一章后，你应该能理解运行在网页应用程序 GUI 下的各种组件。接下来，我们通过仔细查看 Twitter 的 API，使这些概念更加具体。如果你打开浏览器并访问网址
    [https://twitter.com](https://twitter.com)，初始请求会触发客户端和服务器之间的一系列通信。你的浏览器会自动协调这些数据传输，但通过使用像
    Burp Suite 这样的 Web 代理（我们将在第 4 章中设置），你可以看到所有请求和响应的实际情况。
- en: 'The communications begin with the typical kind of HTTP traffic described in
    Chapter 1:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 通信从第 1 章中描述的典型 HTTP 流量开始：
- en: 'Once you’ve entered a URL into your browser, the browser automatically submits
    an HTTP GET request to the web server at *twitter.com*:'
  id: totrans-217
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦你在浏览器中输入了 URL，浏览器会自动向 *twitter.com* 的 Web 服务器提交一个 HTTP GET 请求：
- en: '[PRE18]'
  id: totrans-218
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'The Twitter web application server receives the request and responds to the
    GET request by issuing a successful 200 OK response:'
  id: totrans-219
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Twitter Web 应用程序服务器收到请求后，通过发出成功的 200 OK 响应来回应 GET 请求：
- en: '[PRE19]'
  id: totrans-220
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: This response header contains the status of the HTTP connection, client instructions,
    middleware information, and cookie-related information. *Client instructions*
    tell the browser how to handle the requested information, such as caching data,
    the content security policy, and instructions about the type of content that was
    sent. The actual payload begins just below `x-response-time`; it provides the
    browser with the HTML needed to render the web page.
  id: totrans-221
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 此响应头包含 HTTP 连接的状态、客户端指令、中间件信息和与 cookie 相关的信息。*客户端指令* 告诉浏览器如何处理请求的信息，例如缓存数据、内容安全策略以及有关发送内容类型的指令。实际的有效载荷从
    `x-response-time` 下方开始，它为浏览器提供渲染网页所需的 HTML。
- en: Now imagine that the user looks up “hacking” using Twitter’s search bar. This
    kicks off a POST request to Twitter’s API, as shown next. Twitter is able to leverage
    APIs to distribute requests and seamlessly provide requested resources to many
    users.
  id: totrans-222
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 现在假设用户通过 Twitter 的搜索框查找 “hacking” 这个词。这将触发一个 POST 请求到 Twitter 的 API，如下所示。Twitter
    能够利用 API 分发请求，并无缝地将请求的资源提供给多个用户。
- en: '[PRE20]'
  id: totrans-223
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'This POST request is an example of the Twitter API querying the web service
    at *api.twitter.com* for the search term “hacking.” The Twitter API responds with
    JSON containing the search results, which includes tweets and information about
    each tweet such as user mentions, hashtags, and post times:'
  id: totrans-224
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这个 POST 请求是 Twitter API 查询 *api.twitter.com* 网络服务的一个例子，搜索词为 “hacking”。Twitter
    API 使用 JSON 格式的搜索结果回应，结果包括推文和有关每条推文的信息，如用户提及、标签和发布时间：
- en: '[PRE21]'
  id: totrans-225
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: The fact that the Twitter API seems to adhere to CRUD, API naming conventions,
    tokens for authorization, *application/x-www-form-urlencoded*, and JSON as a data
    interchange makes it pretty clear that this API is a RESTful API.
  id: totrans-226
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: Twitter API 遵循 CRUD、API 命名规范、授权令牌、*application/x-www-form-urlencoded* 和 JSON
    数据交换格式这一事实，清楚表明这个 API 是一个 RESTful API。
- en: Although the response body is formatted in a legible way, it’s meant to be processed
    by the browser to be displayed as a human-readable web page. The browser renders
    the search results using the string from the API request. The provider’s response
    then populates the page with search results, images, and social media–related
    information such as likes, retweets, comments (see [Figure 2-6](#figure2-6)).
  id: totrans-227
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 尽管响应体格式化为可读的方式，但它是供浏览器处理并显示为人类可读的网页。浏览器使用来自 API 请求的字符串渲染搜索结果。提供者的响应随后将页面填充为搜索结果、图像以及社交媒体相关信息，如喜欢、转发、评论（见
    [图 2-6](#figure2-6)）。
- en: '![Screenshot of a Twitter search for the word “hacking”](image_fi/502444c02/F02006.png)'
  id: totrans-228
  prefs: []
  type: TYPE_IMG
  zh: '![Screenshot of a Twitter search for the word “hacking”](image_fi/502444c02/F02006.png)'
- en: 'Figure 2-6: The rendered result from the Twitter API search request'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 图2-6：来自Twitter API搜索请求的渲染结果
- en: 'From the end user’s perspective, the whole interaction appears seamless: you
    click the search bar, type in a query, and receive the results.'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 从终端用户的角度来看，整个互动过程显得无缝衔接：你点击搜索框，输入查询内容，随后收到结果。
- en: Summary
  id: totrans-231
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we covered the terminology, parts, types, and supporting architecture
    of APIs. You learned that APIs are interfaces for interacting with web applications.
    Different types of APIs have different rules, functions, and purposes, but they
    all use some kind of format for exchanging data between applications. They often
    use authentication and authorization schemes to make sure consumers can access
    only the resources they’re supposed to.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一章中，我们介绍了API的术语、组成部分、类型以及支持架构。你了解到API是与Web应用程序交互的接口。不同类型的API有不同的规则、功能和目的，但它们都使用某种格式在应用程序之间交换数据。它们通常使用身份验证和授权机制，以确保消费者只能访问他们应该访问的资源。
- en: Understanding these concepts will prepare you to confidently strike at the components
    that make up APIs. As you continue to read, refer to this chapter if you encounter
    API concepts that confuse you.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 理解这些概念将帮助你自信地深入了解构成API的各个组件。当你继续阅读时，如果遇到令你困惑的API概念，可以参考本章内容。
