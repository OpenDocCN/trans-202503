- en: '20'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '20'
- en: Single-Sign-On Security Issues
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 单点登录安全问题
- en: '![](image_fi/book_art/chapterart.png)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![](image_fi/book_art/chapterart.png)'
- en: '*Single sign-on (**SSO)* is a feature that allows users to access multiple
    services belonging to the same organization without logging in multiple times.
    Once you’ve logged into a website that uses SSO, you won’t have to enter your
    credentials again when accessing another service or resource belonging to the
    same company. For example, if you’re logged into *facebook.com*, you won’t have
    to reenter your credentials to use *messenger.com*, a Facebook service.'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: '*单点登录（**SSO**）*是一种允许用户在不需要多次登录的情况下访问属于同一组织的多个服务的功能。一旦你登录了一个使用SSO的网站，在访问属于同一公司其他服务或资源时，就无需再次输入凭证。例如，如果你已经登录了*facebook.com*，就无需重新输入凭证来使用*messenger.com*，这是Facebook的一个服务。'
- en: This practice is convenient for companies with many web services, because they
    can manage a centralized source of user credentials instead of keeping track of
    a different set of users for each site. Users can save time as well, since they
    won’t need to log in multiple times when using the different services provided
    by the same company. Since it makes things so much easier for both companies and
    users, SSO has become common practice on the internet.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 这种做法对拥有许多Web服务的公司来说非常方便，因为他们可以管理集中式的用户凭证源，而不必为每个网站追踪一套不同的用户。用户也能节省时间，因为在使用同一公司提供的不同服务时无需多次登录。由于它大大简化了公司和用户的操作，SSO已成为互联网的常见做法。
- en: But new vulnerabilities that threaten SSO systems have also emerged. In this
    chapter, we’ll talk about three methods developers use to implement SSO, as well
    as some vulnerabilities related to each approach.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，也出现了威胁SSO系统的新漏洞。在本章中，我们将讨论开发人员用于实现SSO的三种方法，以及与每种方法相关的一些漏洞。
- en: Mechanisms
  id: totrans-6
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 机制
- en: Cookie sharing, SAML, and OAuth are the three most common ways of implementing
    SSO. Each mechanism has unique strengths and weaknesses, and developers choose
    different approaches depending on their needs.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: Cookie共享、SAML和OAuth是实现SSO的三种最常见方式。每种机制都有其独特的优点和缺点，开发者会根据需求选择不同的方式。
- en: Cooking Sharing
  id: totrans-8
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 烹饪共享
- en: The implementation of SSO is quite easy if the services that need to share authentication
    are located under the same parent domain, as is the case with the web and mobile
    versions of Facebook at *www.facebook.com* and *m.facebook.com*. In these situations,
    applications can share cookies across subdomains.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 如果需要共享认证的服务位于同一父域名下，实现SSO非常简单，就像*www.facebook.com*和*m.facebook.com*的Web和移动版本一样。在这种情况下，应用程序可以在子域名之间共享Cookie。
- en: How Cookie Sharing Works
  id: totrans-10
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: Cookie共享如何工作
- en: 'Modern browsers allow sites to share their cookies across subdomains if the
    cookie’s `Domain` flag is set to a common parent domain. For example, if the server
    sets a cookie like the following, the cookie will be sent to all subdomains of
    *facebook.com*:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 现代浏览器允许站点在子域名之间共享Cookie，只要Cookie的`Domain`标志设置为共同的父域名。例如，如果服务器设置一个如下所示的Cookie，该Cookie将被发送到*facebook.com*的所有子域名：
- en: '[PRE0]'
  id: totrans-12
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: However, not all applications can use this approach, because cookies can’t be
    shared this way across different domains. For instance, *facebook.com* and *messenger.com*
    can’t share cookies, because they don’t share a common parent domain.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，并非所有应用程序都可以使用这种方法，因为在不同的域名之间不能这样共享Cookie。例如，*facebook.com*和*messenger.com*无法共享Cookie，因为它们没有共同的父域名。
- en: Moreover, this simple SSO setup comes with unique vulnerabilities. First, because
    the session cookie is shared across all subdomains, attackers can take over the
    accounts of all websites under the same parent domain by stealing a single cookie
    from the user. Usually, attackers can steal the session cookies by finding a vulnerability
    like cross-site scripting.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，这种简单的SSO设置也存在独特的安全漏洞。首先，由于会话Cookie在所有子域名之间共享，攻击者可以通过窃取用户的一个Cookie，接管所有属于同一父域名下网站的账户。通常，攻击者可以通过找到像跨站脚本攻击（XSS）这样的漏洞来窃取会话Cookie。
- en: Another common method used to compromise shared-session SSO is with a subdomain
    takeover vulnerability.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种常见的通过共享会话SSO进行攻击的方法是利用子域名接管漏洞。
- en: Subdomain Takeovers
  id: totrans-16
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 子域名接管
- en: Put simply, *subdomain takeovers* occur when an attacker takes control over
    a company’s unused subdomain.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 简而言之，*子域名接管*发生在攻击者接管了公司未使用的子域名时。
- en: Let’s say a company hosts its subdomain on a third-party service, such as AWS
    or GitHub Pages. The company can use a DNS CNAME record to point the subdomain
    to another URL on the third-party site. This way, whenever users request the official
    subdomain, they’ll be redirected to the third-party web page.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 假设一家公司将其子域名托管在第三方服务上，如 AWS 或 GitHub Pages。公司可以使用 DNS CNAME 记录将子域名指向第三方站点的另一个
    URL。这样，每当用户请求该官方子域名时，他们会被重定向到第三方网页。
- en: For example, say an organization wants to host its subdomain, *abc.example.com*,
    on the GitHub page *abc_example.github.io*. The organization can use a DNS CNAME
    record to point *abc.example.com* to *abc_example.github.io* so that users who
    try to access *abc.example.com* will be redirected to the GitHub-hosted page.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，假设一个组织想要将其子域名 *abc.example.com* 托管在 GitHub 页面 *abc_example.github.io* 上。该组织可以使用
    DNS CNAME 记录将 *abc.example.com* 指向 *abc_example.github.io*，这样尝试访问 *abc.example.com*
    的用户就会被重定向到 GitHub 托管的页面。
- en: But if this third-party site is deleted, the CNAME record that points from the
    company’s subdomain to that third-party site will remain unless someone remembers
    to remove it. We call these abandoned CNAME records *dangling CNAMEs*. Since the
    third-party page is now unclaimed, anyone who registers that site on the third-party
    service can gain control of the company’s subdomain.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，如果这个第三方站点被删除，指向该第三方站点的 CNAME 记录将继续存在，除非有人记得删除它。我们将这些被遗弃的 CNAME 记录称为 *悬空 CNAME*。由于第三方页面现在没有被认领，任何人只要在第三方服务上注册该站点，就能控制该公司的子域名。
- en: Let’s say the company in our example later decides to delete the GitHub page
    but forgets to remove the CNAME record pointing to *abc_example.github.io*. Because
    *abc_example.github.io* is now unclaimed, anyone can register a GitHub account
    and create a GitHub page at *abc_example.github.io*. Since *abc.example.com* still
    points to *abc_example.github.io*, the owner of *abc_example.github.io* now has
    full control over *abc.example.com*.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们示例中的公司后来决定删除 GitHub 页面，但忘记删除指向 *abc_example.github.io* 的 CNAME 记录。由于 *abc_example.github.io*
    现在没有被认领，任何人都可以注册一个 GitHub 账户并在 *abc_example.github.io* 上创建一个 GitHub 页面。由于 *abc.example.com*
    仍然指向 *abc_example.github.io*，因此 *abc_example.github.io* 的所有者现在可以完全控制 *abc.example.com*。
- en: Subdomain takeovers allow attackers to launch sophisticated phishing campaigns.
    Users sometimes check that the domain name of a page they’re visiting is legit,
    and subdomain takeovers allow attackers to host malicious pages using legitimate
    domain names. For example, the attacker who took over *abc.example.com* can host
    a page that looks like *example.com* on the GitHub page to trick users into providing
    their credentials.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 子域名接管允许攻击者发起复杂的钓鱼攻击。用户有时会检查他们访问页面的域名是否合法，而子域名接管让攻击者可以利用合法的域名托管恶意页面。例如，控制了 *abc.example.com*
    的攻击者可以在 GitHub 页面上托管一个看起来像 *example.com* 的页面，诱骗用户提供他们的凭证。
- en: But subdomain takeovers can become even more dangerous if the organization uses
    cookie sharing. Imagine that *example.com* implements a shared-session-based SSO
    system. Its cookies will be sent to any subdomain of *example.com*, including
    *abc.example.com*. Now the attacker who took over *abc.example.com* can host a
    malicious script there to steal session cookies. They can trick users into accessing
    *abc.example.com*, maybe by hosting it as a fake image or sending the link over
    to the user. As long as the victim has already logged into *example.com*’s SSO
    system once, the victim’s browser will send their cookie to the attacker’s site.
    The attacker can steal the victim’s shared session cookie and log in as the victim
    to all services that share the same session cookie.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 但如果该组织使用了 cookie 共享，子域名接管可能变得更加危险。想象一下，*example.com* 实现了基于共享会话的 SSO 系统。它的 cookies
    将会发送到 *example.com* 的任何子域名，包括 *abc.example.com*。现在，控制了 *abc.example.com* 的攻击者可以在那里托管恶意脚本来窃取会话
    cookies。他们可以诱使用户访问 *abc.example.com*，比如将其作为假图片托管，或将链接发送给用户。只要受害者已经登录过 *example.com*
    的 SSO 系统，受害者的浏览器就会把他们的 cookie 发送到攻击者的网站。攻击者可以窃取受害者的共享会话 cookie，并以受害者的身份登录所有共享同一会话
    cookie 的服务。
- en: If the attacker can steal the shared session cookie by taking control of a single
    subdomain, all *example.com* sites will be at risk. Because the compromise of
    a single subdomain can mean a total compromise of the entire SSO system, using
    shared cookies as an SSO mechanism greatly widens the attack surface for each
    service.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 如果攻击者能够通过接管一个子域名来窃取共享会话 cookie，那么所有 *example.com* 的站点都会面临风险。因为单个子域名的泄露可能意味着整个
    SSO 系统的完全泄露，所以将共享 cookie 作为 SSO 机制会大大增加每个服务的攻击面。
- en: Security Assertion Markup Language
  id: totrans-25
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 安全声明标记语言
- en: '*Security Assertion Markup Language (**SAML)* is an XML-based markup language
    used to facilitate SSO on larger-scale applications. SAML enables SSO by facilitating
    information exchange among three parties: the user, the identity provider, and
    the service provider.'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: '*安全声明标记语言 (**SAML)** 是一种基于XML的标记语言，用于在大规模应用程序中促进单点登录（SSO）。SAML通过促进用户、身份提供者和服务提供者之间的信息交换来实现单点登录。'
- en: How SAML Works
  id: totrans-27
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: SAML 工作原理
- en: In SAML systems, the user obtains an identity assertion from the identity provider
    and uses that to authenticate to the service provider. The *identity* provider
    is a server in charge of authenticating the user and passing on user information
    to the service provider. The *service provider* is the actual site that the user
    intends to access.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 在SAML系统中，用户从身份提供者获得身份声明，并用它向服务提供者进行身份验证。*身份*提供者是负责验证用户身份并将用户信息传递给服务提供者的服务器。*服务提供者*是用户打算访问的实际站点。
- en: '[Figure 20-1](#figure20-1) illustrates how the process works.'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 20-1](#figure20-1)说明了这个过程是如何工作的。'
- en: '![f20001](image_fi/501546c20/f20001.png)'
  id: totrans-30
  prefs: []
  type: TYPE_IMG
  zh: '![f20001](image_fi/501546c20/f20001.png)'
- en: 'Figure 20-1: A simplified view of the SAML authentication process'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 图 20-1：SAML身份验证过程的简化视图
- en: 'First, you try to access a resource from the service provider. Since you aren’t
    logged in, the service provider makes you send a SAML request to the identity
    provider. Once you’ve provided your credentials, the identity provider will send
    you a SAML response, which you can use to authenticate to the service provider.
    The SAML response contains an identity assertion that communicates your identity
    to the service provider. These are usually uniquely identifiable pieces of information
    such as your username, email address, or user ID. For instance, take a look at
    the following SAML identity assertion. It communicates the user’s identity via
    the user’s username:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，你尝试从服务提供者访问资源。由于你没有登录，服务提供者会要求你向身份提供者发送一个SAML请求。一旦你提供了凭证，身份提供者将向你发送一个SAML响应，你可以用它来向服务提供者进行身份验证。SAML响应包含一个身份声明，用于向服务提供者传达你的身份。这些通常是唯一可识别的信息，例如你的用户名、电子邮件地址或用户ID。例如，看看以下SAML身份声明，它通过用户的用户名传达了用户的身份：
- en: '[PRE1]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: SAML Vulnerabilities
  id: totrans-34
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: SAML漏洞
- en: As you can see in [Figure 20-1](#figure20-1), the key to accessing resources
    held by the service provider is in the SAML response. An attacker who can control
    the SAML response passed to the service provider can authenticate as someone else.
    Therefore, applications need to protect the integrity of their SAML messages,
    which they usually accomplish by using a signature to sign the message.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 如你在[图 20-1](#figure20-1)中看到的，访问服务提供者持有的资源的关键在于SAML响应。能够控制传递给服务提供者的SAML响应的攻击者可以冒充他人进行身份验证。因此，应用程序需要保护其SAML消息的完整性，通常是通过使用签名来签署消息来实现这一点。
- en: SAML can be secure if the SAML signature is implemented correctly. However,
    its security breaks apart if attackers can find a way to bypass the signature
    validation and forge the identity assertion to assume the identity of others.
    For example, if the attacker can change the embedded username in a SAML assertion,
    they can log in as another user.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 如果SAML签名正确实现，SAML可以是安全的。然而，如果攻击者找到绕过签名验证并伪造身份声明以冒充他人身份的方法，其安全性就会崩溃。例如，如果攻击者能够更改SAML声明中嵌入的用户名，他们就可以作为另一个用户登录。
- en: 'The digital signature that most applications apply to SAML messages ensures
    that no one can tamper with them. If a SAML message has the wrong signature, it
    won’t be accepted:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数应用程序应用于SAML消息的数字签名确保没有人能够篡改它们。如果SAML消息的签名错误，它将不会被接受：
- en: '[PRE2]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Unfortunately, SAML security mechanisms aren’t always well implemented. Sometimes
    the SAML signature isn’t implemented or verified at all! If this is the case,
    attackers can forge the identity information in the SAML response at will. Other
    times, developers make the mistake of verifying signatures only if they exist.
    Attackers can then empty the signature field or remove the field completely to
    bypass the security measure.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，SAML的安全机制并不总是得到很好的实现。有时，SAML签名根本没有被实现或验证！如果是这种情况，攻击者可以随意伪造SAML响应中的身份信息。其他时候，开发人员犯了一个错误，只在签名存在时才验证签名。这样，攻击者可以清空签名字段或完全删除该字段，从而绕过安全措施。
- en: 'Lastly, if the signing mechanism used to generate the signature is weak or
    predictable, attackers can forge signatures. If you take a closer look at the
    previous signed SAML message, you’ll notice that the signature, `dXNlcjE=`, is
    just the base64 encoding of `user1`. We can deduce that the signature mechanism
    used is `base64(``username``)`. To forge a valid identity assertion for `victim_user`,
    we can change the signature field to `base64("``victim_user")`, which is `dmljdGltX3VzZXI=`,
    and obtain a valid session as `victim_user`:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，如果用于生成签名的签名机制很弱或可预测，攻击者可以伪造签名。如果仔细查看之前签名的SAML消息，你会发现签名`dXNlcjE=`实际上是`user1`的base64编码。我们可以推测使用的签名机制是`base64(``username``)`。为了伪造`victim_user`的有效身份断言，我们可以将签名字段改为`base64("``victim_user")`，即`dmljdGltX3VzZXI=`，从而获得作为`victim_user`的有效会话：
- en: '[PRE3]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Another common mistake developers make is trusting that encryption alone will
    provide adequate security for the SAML messages. Encryption protects a message’s
    confidentiality, not its integrity. If a SAML response is encrypted but not signed,
    or signed with a weak signature, attackers can attempt to tamper with the encrypted
    message to mess with the outcome of the identity assertion.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 开发者常犯的另一个错误是认为仅靠加密就能为SAML消息提供足够的安全性。加密保护的是消息的机密性，而不是完整性。如果SAML响应被加密但未签名，或者使用了弱签名，攻击者可以尝试篡改加密消息，从而干扰身份断言的结果。
- en: There are many interesting ways of tampering with encrypted messages without
    having to break the encryption. The details of such techniques are beyond the
    scope of this book, but I encourage you to look them up on the internet. To learn
    more about encryption attacks, visit Wikipedia at [https://en.wikipedia.org/wiki/Encryption#Attacks_and_countermeasures](https://en.wikipedia.org/wiki/Encryption#Attacks_and_countermeasures).
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 有许多有趣的方式可以在不破解加密的情况下篡改加密消息。这些技术的细节超出了本书的范围，但我鼓励你在互联网上查找相关资料。要了解更多关于加密攻击的信息，请访问维基百科：[https://en.wikipedia.org/wiki/Encryption#Attacks_and_countermeasures](https://en.wikipedia.org/wiki/Encryption#Attacks_and_countermeasures)。
- en: SAML messages are also a common source of sensitive data leaks. If a SAML message
    contains sensitive user information, like passwords, and isn’t encrypted, an attacker
    who intercepts the victim’s traffic might be able to steal those pieces of information.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: SAML消息也是敏感数据泄露的常见来源。如果SAML消息包含敏感的用户信息，比如密码，且未加密，那么截获受害者流量的攻击者可能能够窃取这些信息。
- en: Finally, attackers can use SAML as a vector for smuggling malicious input onto
    the site. For example, if a field in a SAML message is passed into a database,
    attackers might be able to pollute that field to achieve SQL injection. Depending
    on how the SAML message is used server-side, attackers might also be able to perform
    XSS, XXE, and a whole host of other nasty web attacks.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，攻击者可以利用SAML作为将恶意输入传送到站点的载体。例如，如果SAML消息中的某个字段传递到数据库，攻击者可能会污染该字段以实现SQL注入。根据SAML消息在服务器端的使用方式，攻击者还可能执行XSS、XXE及一系列其他恶意Web攻击。
- en: These SAML vulnerabilities all stem from a failure to protect SAML messages
    by using signatures and encryption. Applications should use strong encryption
    and signature algorithms and protect their secret keys from theft. Additionally,
    sensitive user information such as passwords shouldn’t be transported in unencrypted
    SAML messages. Finally, as with all user input, SAML messages should be sanitized
    and checked for malicious user input before being used.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些SAML漏洞都源于未通过使用签名和加密来保护SAML消息。应用程序应该使用强加密和签名算法，并保护其密钥免受盗窃。此外，敏感的用户信息，如密码，不应通过未加密的SAML消息传输。最后，和所有用户输入一样，SAML消息应该在使用之前进行清理，并检查是否存在恶意用户输入。
- en: OAuth
  id: totrans-47
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: OAuth
- en: The final way of implementing SSO that we’ll discuss is OAuth. *OAuth* is essentially
    a way for users to grant scope-specific access tokens to service providers through
    an identity provider. The identity provider manages credentials and user information
    in a single place, and allows users to log in by supplying service providers with
    information about the user’s identity.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将讨论的最终SSO实现方式是OAuth。*OAuth*本质上是一种让用户通过身份提供者向服务提供商授予特定范围访问令牌的方式。身份提供者在一个地方管理凭证和用户信息，并允许用户通过向服务提供商提供有关用户身份的信息来进行登录。
- en: How OAuth Works
  id: totrans-49
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: OAuth的工作原理
- en: When you log in to an application using OAuth, the service provider requests
    access to your information from the identity provider. These resources might include
    your email address, contacts, birthdate, and anything else it needs to determine
    who you are. These permissions and pieces of data are called the *scope*. The
    identity provider will then create a unique `access_token` that the service provider
    can use to obtain the resources defined by the scope.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 当你使用 OAuth 登录到应用程序时，服务提供者会请求从身份提供者那里获取你的信息。这些资源可能包括你的电子邮件地址、联系人、出生日期以及其他任何有助于确定你身份的数据。这些权限和数据被称为*范围（scope）*。身份提供者随后会创建一个唯一的`access_token`，服务提供者可以用它来获取范围内定义的资源。
- en: 'Let’s break things down further. When you log in to the service provider via
    OAuth, the first request that the service provider will send to the identity provider
    is the request for an `authorization`. This request will include the service provider’s
    `client_id` used to identify the service provider, a `redirect_uri` used to redirect
    the authentication flow, a `scope` listing the requested permissions, and a `state`
    parameter, which is essentially a CSRF token:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们进一步解析。当你通过 OAuth 登录到服务提供者时，服务提供者发送给身份提供者的第一个请求是请求`授权`。该请求将包括服务提供者的`client_id`，用于标识服务提供者的客户端
    ID，一个用于重定向身份验证流程的`redirect_uri`，一个列出请求权限的`scope`，以及一个`state`参数，基本上是一个 CSRF 令牌：
- en: '[PRE4]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Then, the identity provider will ask the user to grant access to the service
    provider, typically via a pop-up window. [Figure 20-2](#figure20-2) shows the
    pop-up window that Facebook uses to ask for your consent to send information to
    *spotify.com* if you choose to log in to Spotify via Facebook.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，身份提供者将要求用户授予服务提供者访问权限，通常通过弹窗的方式。[图 20-2](#figure20-2)展示了 Facebook 用来请求你的同意，以便在你选择通过
    Facebook 登录 Spotify 时，将信息发送到*spotify.com*。
- en: '![f20002](image_fi/501546c20/f20002.png)'
  id: totrans-54
  prefs: []
  type: TYPE_IMG
  zh: '![f20002](image_fi/501546c20/f20002.png)'
- en: 'Figure 20-2: The consent pop-up seen during a typical OAuth flow'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 图 20-2：在典型 OAuth 流程中看到的同意弹窗
- en: 'After the user agrees to the permissions the service provider asks for, the
    identity provider will send the `redirect_uri` an authorization code:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 在用户同意服务提供者请求的权限后，身份提供者将通过`redirect_uri`发送一个授权码：
- en: '[PRE5]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The service provider can then obtain an `access_token` from the identity provider
    by using the authorization code, along with their client ID and secret. Client
    IDs and client secrets authenticate the service provider to the identity provider:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 服务提供者可以通过使用授权码、以及他们的客户端 ID 和密钥，从身份提供者获取`access_token`。客户端 ID 和客户端密钥用于认证服务提供者身份：
- en: '[PRE6]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The identity provider will send back the `access_token`, which can be used
    to access the user’s information:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 身份提供者将返回`access_token`，该令牌可以用来访问用户的信息：
- en: '[PRE7]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: A service provider might, for instance, initiate a request to the identity provider
    for an access token to access the user’s email. Then it could use the email retrieved
    from the identity provider as proof of the user’s identity to log the user in
    to the account registered with the same email address.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，服务提供者可能会向身份提供者发起请求，获取访问用户电子邮件的访问令牌。然后，它可以使用从身份提供者获取的电子邮件作为证明用户身份的方式，登录到与该电子邮件地址注册的账户。
- en: OAuth Vulnerabilities
  id: totrans-63
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: OAuth 漏洞
- en: Sometimes attackers can bypass OAuth authentication by stealing critical OAuth
    tokens through open redirects. Attackers do this by manipulating the `redirect_uri`
    parameter to steal the `access_token` from the victim’s account.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 有时攻击者可以通过窃取关键的 OAuth 令牌绕过 OAuth 身份验证，方法是利用开放重定向漏洞。攻击者通过篡改`redirect_uri`参数，从受害者账户中窃取`access_token`。
- en: 'The `redirect_uri` determines where the identity provider sends critical pieces
    of information like the `access_token`. Most major identity providers, therefore,
    require service providers to specify an allowlist of URLs to use as the `redirect_uri`.
    If the `redirect_uri` provided in a request isn’t on the allowlist, the identity
    provider will reject the request. The following request, for example, will be
    rejected if only *example.com* subdomains are allowed:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: '`redirect_uri`决定了身份提供者将如何发送关键信息，如`access_token`。因此，大多数主要的身份提供者要求服务提供者指定一个允许列表的
    URL 来用作`redirect_uri`。如果请求中提供的`redirect_uri`不在允许列表中，身份提供者将拒绝该请求。例如，如果只允许*example.com*的子域，以下请求将被拒绝：'
- en: '[PRE8]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: But what if an open redirect vulnerability exists within one of the allowlisted
    `redirect_uri` URLs? Often, `access_token`s are communicated via a URL fragment,
    which survives all cross-domain redirects. If an attacker can make the OAuth flow
    redirect to the attacker’s domain in the end, they can steal the `access_token`
    from the URL fragment and gain access to the user’s account.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 但如果某个允许的 `redirect_uri` URL 内存在开放重定向漏洞怎么办？通常，`access_token` 是通过 URL 片段传递的，该片段在所有跨域重定向中都能保持。如果攻击者能够使
    OAuth 流程最终重定向到攻击者的域名，他们就可以从 URL 片段中窃取 `access_token`，并获取用户的账户访问权限。
- en: One way of redirecting the OAuth flow is through a URL-parameter-based open
    redirect. For example, using the following URL as the `redirect_uri`
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 重定向 OAuth 流程的一种方式是通过基于 URL 参数的开放重定向。例如，使用以下 URL 作为 `redirect_uri`
- en: '[PRE9]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: will cause the flow to redirect to the callback URL first
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 将首先导致流程重定向到回调 URL
- en: '[PRE10]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'and then to the attacker’s domain:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 然后重定向到攻击者的域名：
- en: '[PRE11]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'The attacker can send the victim a crafted URL that will initiate the OAuth
    flow, and then run a listener on their server to harvest the leaked tokens:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 攻击者可以向受害者发送一个精心构造的 URL，这将启动 OAuth 流程，然后在他们的服务器上运行一个监听器来收集泄露的令牌：
- en: '[PRE12]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Another way of redirecting the OAuth flow is through a referer-based open redirect.
    In this case, the attacker would have to set up the referer header by initiating
    the OAuth flow from their domain:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 重定向 OAuth 流程的另一种方式是通过基于 referer 的开放重定向。在这种情况下，攻击者必须通过从他们的域名发起 OAuth 流程来设置 referer
    头：
- en: '[PRE13]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'This will cause the flow to redirect to the callback URL first:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 这将导致流程首先重定向到回调 URL：
- en: '[PRE14]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Then it would redirect to the attacker’s domain via the referer:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，它将通过 referer 重定向到攻击者的域名：
- en: '[PRE15]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Even when attackers can’t find an open redirect on the OAuth endpoint itself,
    they can still smuggle the tokens offsite if they can find an *open redirect chain*.
    For example, let’s say the `redirect_uri` parameter permits only further redirects
    to URLs that are under the *example.com* domain. If attackers can find an open
    redirect within that domain, they can still steal OAuth tokens via redirects.
    Let’s say an unfixed open redirect is on the logout endpoint of *example.com*:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 即使攻击者无法在 OAuth 端点本身找到开放重定向，他们仍然可以通过找到一个*开放重定向链*来窃取令牌并将其带离站点。例如，假设 `redirect_uri`
    参数仅允许进一步重定向到*example.com* 域名下的 URL。如果攻击者能在该域名内找到开放重定向，他们仍然可以通过重定向窃取 OAuth 令牌。假设在
    *example.com* 的登出端点存在未修复的开放重定向：
- en: '[PRE16]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'By taking advantage of this open redirect, the attacker can form a chain of
    redirects to eventually smuggle the token offsite, starting with the following:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 通过利用这个开放重定向，攻击者可以形成一条重定向链，最终将令牌带离站点，流程开始于以下内容：
- en: '[PRE17]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'This `redirect_uri` will first cause the flow to redirect to the callback URL:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 这个 `redirect_uri` 将首先导致流程重定向到回调 URL：
- en: '[PRE18]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Then to the logout URL vulnerable to open redirect:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 然后重定向到容易受到开放重定向攻击的登出 URL：
- en: '[PRE19]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Then it will redirect to the attacker’s domain. The attacker can harvest the
    access token via their server logs, and access the user’s resources via the stolen
    token:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 然后它将重定向到攻击者的域名。攻击者可以通过他们的服务器日志收集访问令牌，并通过窃取的令牌访问用户的资源：
- en: '[PRE20]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Besides stealing access tokens via an open redirect, long-lived tokens that
    don’t expire are also a major OAuth vulnerability. Sometimes tokens aren’t invalidated
    periodically and can be used by attackers long after they are stolen, and remain
    valid even after password reset. You can test for these issues by using the same
    access tokens after logout and after password reset.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 除了通过开放重定向窃取访问令牌外，长期有效且不会过期的令牌也是一个主要的 OAuth 漏洞。有时候，令牌不会定期失效，攻击者在令牌被盗后很长时间仍然可以使用它们，并且即使密码重置后也保持有效。你可以通过在登出后和密码重置后使用相同的访问令牌来测试这些问题。
- en: Hunting for Subdomain Takeovers
  id: totrans-93
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 寻找子域接管漏洞
- en: Let’s start your hunt for SSO vulnerabilities by finding some subdomain takeovers.
    The best way to reliably discover subdomain takeovers is to build a system that
    monitors a company’s subdomains for takeovers. But before you do that, let’s look
    at how you can search for subdomain takeovers manually.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从寻找 SSO 漏洞开始，通过寻找一些子域接管漏洞。可靠发现子域接管的最佳方法是构建一个系统，监控公司子域的接管情况。但在你这样做之前，让我们看看如何手动搜索子域接管漏洞。
- en: 'Step 1: List the Target’s Subdomains'
  id: totrans-95
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 第 1 步：列出目标的子域
- en: First, you need to build a list of all the known subdomains of your target.
    This can be done using tools mentioned in Chapter 5. Next, use a screenshot application
    like EyeWitness or Snapper to see what is hosted on each subdomain.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，你需要构建一个目标的所有已知子域名列表。这可以通过使用第5章中提到的工具来完成。接下来，使用截图工具如 EyeWitness 或 Snapper
    来查看每个子域名上托管的内容。
- en: 'Step 2: Find Unregistered Pages'
  id: totrans-97
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 第 2 步：查找未注册的页面
- en: Look for third-party pages indicating that the page isn’t registered. For example,
    if the third-party page is hosted on GitHub Pages, you should see something like
    [Figure 20-3](#figure20-3) on the subdomain.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 寻找第三方页面，表明该页面未被注册。例如，如果该第三方页面托管在 GitHub Pages 上，你应该在子域名上看到类似[图 20-3](#figure20-3)的内容。
- en: Even if you’ve found a dangling CNAME, not all third-party hosting providers
    are vulnerable to takeovers. Some providers employ measures to verify the identity
    of users, to prevent people from registering pages associated with CNAME records.
    Currently, pages hosted on AWS, Bitbucket, and GitHub are vulnerable, whereas
    pages on Squarespace and Google Cloud are not. You can find a full list of which
    third-party sites are vulnerable on EdOverflow’s page on the topic ([https://github.com/EdOverflow/can-i-take-over-xyz/](https://github.com/EdOverflow/can-i-take-over-xyz/)).
    You can find a list of page signatures that indicate an unregistered page there
    too.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 即使你发现了悬挂的 CNAME，并非所有的第三方托管服务提供商都易受接管攻击。一些服务提供商采用措施验证用户身份，以防止他人注册与 CNAME 记录相关联的页面。目前，托管在
    AWS、Bitbucket 和 GitHub 上的页面是易受攻击的，而 Squarespace 和 Google Cloud 上的页面则不是。你可以在 EdOverflow
    的页面上找到哪些第三方网站易受攻击的完整列表（[https://github.com/EdOverflow/can-i-take-over-xyz/](https://github.com/EdOverflow/can-i-take-over-xyz/)）。你也可以在那里找到表明页面未注册的页面签名列表。
- en: '![f20003](image_fi/501546c20/f20003.png)'
  id: totrans-100
  prefs: []
  type: TYPE_IMG
  zh: '![f20003](image_fi/501546c20/f20003.png)'
- en: 'Figure 20-3: An indicator that this page hosted on GitHub Pages is unclaimed'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 图 20-3：指示该页面托管在 GitHub Pages 上且未被注册的标识
- en: 'Step 3: Register the Page'
  id: totrans-102
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 第 3 步：注册页面
- en: 'Once you’ve determined that the page is vulnerable to takeovers, you should
    try to register it on the third-party site to confirm the vulnerability. To register
    a page, go to the third-party site and claim the page as yours; the actual steps
    required vary by third-party provider. Host a harmless proof-of-concept page there
    to prove the subdomain takeover, such as a simple HTML page like this one:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你确定该页面易受接管攻击，你应该尝试在第三方网站上注册该页面，以确认该漏洞。注册页面时，前往第三方网站并声明该页面归你所有；实际步骤根据第三方服务提供商的不同而有所不同。在该页面上托管一个无害的概念验证页面，证明子域名接管漏洞，例如一个简单的
    HTML 页面：
- en: '[PRE21]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Make sure to keep the site registered until the company mitigates the vulnerability
    by either removing the dangling DNS CNAME or by reclaiming the page on the third-party
    service. If you don’t, a malicious attacker might be able to take over the subdomain
    while the bug report is being processed.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 确保在公司通过删除悬挂的 DNS CNAME 或重新声明第三方服务上的页面来缓解漏洞之前，保持该网站已注册。如果你不这样做，恶意攻击者可能会在漏洞报告处理期间接管该子域名。
- en: 'You might be able to steal cookies with the subdomain takeover if the site
    uses cookie-sharing SSO. Look for cookies that can be sent to multiple subdomains
    in the server’s responses. Shared cookies are sent with the `Domain` attribute
    specifying the parents of subdomains that can access the cookie:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 如果该站点使用共享 cookie 的单点登录（SSO），你可能能够通过子域名接管窃取 cookies。寻找在服务器响应中能够发送到多个子域名的 cookie。共享
    cookie 会带有 `Domain` 属性，指定可以访问该 cookie 的子域名父级：
- en: '[PRE22]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Then, you can log in to the legitimate site, and visit your site in the same
    browser. You can monitor the logs of your newly registered site to determine whether
    your cookies were sent to it. If the logs of your newly registered site receive
    your cookies, you have found a subdomain takeover that can be used to steal cookies!
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，你可以登录合法站点，并在同一个浏览器中访问你的网站。你可以监控你新注册站点的日志，以确定是否将你的 cookies 发送给了它。如果你新注册站点的日志收到你的
    cookies，那么你发现了一个可以用来窃取 cookies 的子域名接管漏洞！
- en: Even if the subdomain takeover you’ve found cannot be used to steal shared-session
    cookies, it is still considered a vulnerability. Subdomain takeovers can be used
    to launch phishing attacks on a site’s users, so you should still report them
    to the organization!
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 即使你发现的子域名接管无法用来窃取共享会话 cookie，它仍然被视为一个漏洞。子域名接管可用于对网站用户发起钓鱼攻击，因此你仍然应该将其报告给相关组织！
- en: Monitoring for Subdomain Takeovers
  id: totrans-110
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 监控子域名接管
- en: Instead of manually hunting for subdomain takeovers, many hackers build a monitoring
    system to continuously scan for them. This is useful because sites update their
    DNS entries and remove pages from third-party sites all the time. You never know
    when a site is going to be taken down and when a new dangling CNAME will be introduced
    into your target’s assets. If these changes lead to a subdomain takeover, you
    can find it before others do by routinely scanning for takeovers.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 许多黑客会构建一个监控系统，持续扫描子域名接管，而不是手动寻找。这是非常有用的，因为网站经常更新其 DNS 记录并删除第三方网站上的页面。你永远无法知道网站什么时候会被下线，何时会有新的悬空
    CNAME 引入目标资产中。如果这些变化导致了子域名接管，你可以通过定期扫描接管情况，在别人之前发现它。
- en: 'To create a continuous monitoring system for subdomain takeovers, you’ll simply
    need to automate the process I described for finding them manually. In this section,
    I’ll introduce some automation strategies and leave the actual implementation
    up to you:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建一个持续监控子域名接管的系统，你只需要自动化我之前描述的手动寻找方法。在这一部分，我将介绍一些自动化策略，具体的实现交给你：
- en: '****Compile a list of subdomains that belong to the target organization****'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: '****编制目标组织所属子域名的列表****'
- en: Scan the target for new subdomains once in a while to monitor for new subdomains.
    Whenever you discover a new service, add it to this list of monitored subdomains.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 定期扫描目标以监控新的子域名。每当发现新的服务时，将其添加到这个监控的子域名列表中。
- en: '****Scan for subdomains on the list with CNAME entries that point to pages
    hosted on a vulnerable third-party service****'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: '****扫描列表中的子域名，查看其 CNAME 记录是否指向托管在易受攻击的第三方服务上的页面****'
- en: To do this, you’ll need to resolve the base DNS domain of the subdomain and
    determine if it’s hosted on a third-party provider based on keywords in the URL.
    For example, a subdomain that points to a URL that contains the string *github.io*
    is hosted on GitHub Pages. Also determine whether the third-party services you’ve
    found are vulnerable to takeovers.If the target’s sites are exclusively hosted
    on services that aren’t vulnerable to subdomain takeovers, you don’t have to scan
    them for potential takeovers.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 为此，你需要解析子域名的基础 DNS 域名，并根据 URL 中的关键词判断它是否托管在第三方提供商上。例如，指向包含字符串*github.io*的 URL
    的子域名托管在 GitHub Pages 上。还需要确定你找到的第三方服务是否容易受到接管攻击。如果目标网站仅托管在不易受到子域名接管的服务上，那么就无需扫描它们是否存在潜在的接管风险。
- en: '****Determine the signature of an unregistered page for each external service****'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: '****确定每个外部服务的未注册页面的标志性特征****'
- en: Most services will have a custom 404 Not Found page that indicates the page
    isn’t registered. You can use these pages to detect a potential takeover. For
    example, a page that is hosted on GitHub pages is vulnerable if the string `There
    isn't a GitHub Pages site here` is returned in the HTTP response. Make a request
    to the third-party hosted subdomains and scan the response for these signature
    strings. If one of the signatures is detected, the page might be vulnerable to
    takeover.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数服务会有一个自定义的404未找到页面，表示该页面未注册。你可以利用这些页面来检测潜在的接管。例如，如果返回的HTTP响应中包含字符串`There
    isn't a GitHub Pages site here`，那么托管在GitHub Pages上的页面就容易受到攻击。对第三方托管的子域名发出请求，并扫描响应以查找这些标志性字符串。如果发现其中一个标志，说明该页面可能容易受到接管。
- en: 'One way of making this hunting process even more efficient is to let your automation
    solution run in the background, notifying you only after it finds a suspected
    takeover. You can set up a cron job to run the script you’ve created regularly.
    It can alert you only if the monitoring system detects something fishy:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 提高这个寻找过程效率的一种方式是让你的自动化解决方案在后台运行，仅在找到疑似接管时通知你。你可以设置一个定时任务，定期运行你创建的脚本。只有在监控系统检测到可疑情况时，它才会提醒你：
- en: '[PRE23]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: After the script notifies you of a potential subdomain takeover, you can verify
    the vulnerability by registering the page on the external service.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 在脚本通知你潜在的子域名接管后，你可以通过在外部服务上注册该页面来验证该漏洞。
- en: Hunting for SAML Vulnerabilities
  id: totrans-122
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 寻找 SAML 漏洞
- en: Now let’s discuss how you can find faulty SAML implementations and use them
    to bypass your target’s SSO access controls. Before you dive in, be sure to confirm
    that the website is indeed using SAML. You can figure this out by intercepting
    the traffic used for authenticating to a site and looking for XML-like messages
    or the keyword `saml`. Note that SAML messages aren’t always passed in plain XML
    format. They might be encoded in base64 or other encoding schemes.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们讨论如何找到存在缺陷的 SAML 实现并利用它们绕过目标的 SSO 访问控制。在开始之前，确保确认该网站确实使用 SAML。你可以通过拦截用于身份验证的流量并查找类似
    XML 的消息或关键字 `saml` 来确定这一点。请注意，SAML 消息并不总是以纯 XML 格式传递。它们可能被编码为 base64 或其他编码方案。
- en: 'Step 1: Locate the SAML Response'
  id: totrans-124
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 第一步：定位 SAML 响应
- en: First and foremost, you need to locate the SAML response. You can usually do
    this by intercepting the requests going between the browser and the service provider
    using a proxy. The SAML response will be sent when the user’s browser is logging
    into a new session for that particular service provider.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，你需要定位 SAML 响应。通常可以通过拦截浏览器和服务提供商之间的请求来做到这一点。SAML 响应将在用户的浏览器为该特定服务提供商登录新会话时发送。
- en: 'Step 2: Analyze the Response Fields'
  id: totrans-126
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 第二步：分析响应字段
- en: Once you’ve located the SAML response, you can analyze its content to see which
    fields the service provider uses for determining the identity of the user. Since
    the SAML response is used to relay authentication data to the service provider,
    it must contain fields that communicate that information. For example, look for
    field names like `username`, `email address`, `userID`, and so on. Try tampering
    with these fields in your proxy. If the SAML message lacks a signature, or if
    the signature of the SAML response isn’t verified at all, tampering with the message
    is all you need to do to authenticate as someone else!
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你定位了 SAML 响应，你可以分析其内容，查看服务提供商使用哪些字段来确定用户身份。由于 SAML 响应用于将身份验证数据传递给服务提供商，它必须包含传递这些信息的字段。例如，查找像
    `username`、`email address`、`userID` 等字段名称。尝试在代理中篡改这些字段。如果 SAML 消息没有签名，或者 SAML
    响应的签名根本没有经过验证，篡改消息就是你需要做的唯一操作来冒充其他人进行身份验证！
- en: 'Step 3: Bypass the Signature'
  id: totrans-128
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 第三步：绕过签名
- en: If the SAML message you’re tampering with does have a signature, you can try
    a few strategies to bypass it.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你正在篡改的 SAML 消息确实有签名，你可以尝试几种策略来绕过它。
- en: 'If the signatures are verified only when they exist, you could try removing
    the signature value from the SAML response. Sometimes this is the only action
    required to bypass security checks. You can do this in two ways. First, you can
    empty the signature field:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 如果签名仅在存在时进行验证，你可以尝试从 SAML 响应中移除签名值。有时这可能是绕过安全检查所需的唯一操作。你可以通过两种方式做到这一点。首先，你可以清空签名字段：
- en: '[PRE24]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Or you can try removing the field entirely:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 或者你也可以尝试完全移除该字段：
- en: '[PRE25]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: If the SAML response signature used by the application is predictable, like
    the base64 example we discussed earlier, you can simply recalculate the signature
    and forge a valid SAML response.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 如果应用程序使用的 SAML 响应签名是可预测的，比如我们之前讨论的 base64 示例，你可以简单地重新计算签名并伪造一个有效的 SAML 响应。
- en: 'Step 4: Re-encode the Message'
  id: totrans-135
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 第四步：重新编码消息
- en: After tampering with the SAML response, re-encode the message into its original
    form and send it back to the service provider. The service provider will use that
    information to authenticate you to the service. If you’re successful, you can
    obtain a valid session that belongs to the victim’s account. SAML Raider is a
    Burp Suite extension that can help you with editing and re-encoding SAML messages.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 在篡改 SAML 响应后，重新编码消息为其原始形式并将其发送回服务提供商。服务提供商将使用该信息来验证你的身份。如果成功，你将获得属于受害者帐户的有效会话。SAML
    Raider 是一个 Burp Suite 扩展，可以帮助你编辑和重新编码 SAML 消息。
- en: Hunting for OAuth Token Theft
  id: totrans-137
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 寻找 OAuth 令牌盗窃
- en: Before you dive into hunting for OAuth open redirect issues, you should first
    determine whether the website is using OAuth. You can figure this out by intercepting
    the requests to complete authentication on the website and look for the `oauth`
    keyword in the HTTP messages.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 在开始寻找 OAuth 开放重定向问题之前，你应该首先确定网站是否使用 OAuth。你可以通过拦截网站上的身份验证请求并在 HTTP 消息中查找 `oauth`
    关键字来确定这一点。
- en: Then start looking for open redirect vulnerabilities. You can find details on
    how to find open redirects in Chapter 7. Finally, see if you can smuggle the OAuth
    tokens offsite by using one of the open redirects that you’ve found.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 然后开始寻找开放重定向漏洞。你可以在第七章找到关于如何寻找开放重定向的详细信息。最后，看看你能否通过你找到的开放重定向将OAuth令牌泄露到站外。
- en: Escalating the Attack
  id: totrans-140
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 升级攻击
- en: SSO bypass usually means that attackers can take over the accounts of others.
    Therefore, these vulnerabilities are of high severity before any escalation attempts.
    But you can escalate SSO bypass vulnerabilities by attempting to take over accounts
    with high privileges, such as admin accounts.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: SSO绕过通常意味着攻击者能够接管他人的账户。因此，在任何升级尝试之前，这些漏洞的严重性较高。但你可以通过尝试接管具有高权限的账户（如管理员账户）来升级SSO绕过漏洞。
- en: Also, after you’ve taken over the user’s account on one site, you can try to
    access the victim’s account on other sites by using the same OAuth credentials.
    For instance, if you can leak an employee’s cookies via subdomain takeover, see
    if you can access their company’s internal services such as admin panels, business
    intelligence systems, and HR applications with the same credentials.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，在你接管了某个网站用户的账户后，可以尝试使用相同的OAuth凭证访问受害者在其他网站上的账户。例如，如果你通过子域接管泄露了某个员工的cookies，试着用相同的凭证访问他们公司内部的服务，如管理员面板、商业智能系统和人力资源应用程序。
- en: You can also escalate account takeovers by writing a script to automate the
    takeover of large numbers of accounts. Finally, you can try to leak data, execute
    sensitive actions, or take over the application by using the accounts that you
    have taken over. For example, if you can bypass the SSO on a banking site, can
    you read private information or transfer funds illegally? If you can take over
    an admin account, can you change application settings or execute scripts as the
    admin? Again, proceed with caution and never test anything unless you have obtained
    permission.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以通过编写脚本来自动化接管大量账户，从而提升账户接管的规模。最后，你可以尝试泄露数据、执行敏感操作或利用已经接管的账户接管应用程序。例如，如果你能够绕过银行网站的SSO，你能否读取私人信息或非法转账？如果你接管了一个管理员账户，能否更改应用程序设置或以管理员身份执行脚本？再次提醒，务必谨慎行事，除非已获得授权，否则不要进行任何测试。
- en: Finding Your First SSO Bypass!
  id: totrans-144
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 寻找你的第一个SSO绕过漏洞！
- en: 'Now that you are familiar with a few SSO bypass techniques, try to find your
    first SSO bypass bug:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经熟悉了一些SSO绕过技巧，尝试找到你的第一个SSO绕过漏洞：
- en: If the target application is using single sign-on, determine the SSO mechanism
    in use.
  id: totrans-146
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果目标应用程序使用单点登录（SSO），确定正在使用的SSO机制。
- en: If the application is using shared session cookies, try to steal session cookies
    by using subdomain takeovers.
  id: totrans-147
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果应用程序使用共享会话cookie，尝试通过子域接管来窃取会话cookie。
- en: If the application uses a SAML-based SSO scheme, test whether the server is
    verifying SAML signatures properly.
  id: totrans-148
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果应用程序使用基于SAML的SSO方案，测试服务器是否正确验证SAML签名。
- en: If the application uses OAuth, try to steal OAuth tokens by using open redirects.
  id: totrans-149
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果应用程序使用OAuth，尝试通过开放重定向窃取OAuth令牌。
- en: Submit your report about SSO bypass to the bug bounty program!
  id: totrans-150
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将你关于SSO绕过的报告提交给漏洞赏金计划！
