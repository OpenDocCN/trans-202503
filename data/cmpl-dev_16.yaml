- en: <hgroup>
  id: totrans-0
  prefs: []
  type: TYPE_NORMAL
  zh: <hgroup>
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">14</samp> <samp class="SANS_Dogma_OT_Bold_B_11">BUILDING
    THE FRONTEND</samp>
  id: totrans-1
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">14</samp> <samp class="SANS_Dogma_OT_Bold_B_11">构建前端</samp>
- en: </hgroup>
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: </hgroup>
- en: '![](../images/Drop-image.jpg)'
  id: totrans-3
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/Drop-image.jpg)'
- en: In this chapter, you’ll build the frontend using React components and Next.js
    pages, discussed in [Chapters 4](chapter4.xhtml) and [5](chapter5.xhtml). By the
    end, you’ll have an initial version of the app to which you can add OAuth authentication.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，您将使用React组件和Next.js页面构建前端，这些内容将在[第4章](chapter4.xhtml)和[第5章](chapter5.xhtml)中讨论。到最后，您将拥有一个初始版本的应用程序，可以在其中添加OAuth认证。
- en: <samp class="SANS_Futura_Std_Bold_B_11">Overview of the User Interface</samp>
  id: totrans-5
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">用户界面概览</samp>
- en: 'Our application will consist of three Next.js pages. The *start page* will
    show the list of locations retrieved from the database. Each item in the list
    will link to its respective *location detail page*, whose URL we’ll construct
    using the location’s ID, like this: */location/:location_id*. The third page is
    the user’s *wish list page*. It resembles the start page and follows the same
    dynamic URL pattern as the location detail page, except it supplies the user’s
    ID instead of the location’s. This page shows only the locations already added
    to the wish list.'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的应用程序将由三个Next.js页面组成。*启动页面*将显示从数据库中获取的地点列表。列表中的每个项目将链接到各自的*地点详情页面*，其URL将通过地点的ID构建，如：*/location/:location_id*。第三个页面是用户的*愿望清单页面*。它与启动页面相似，并遵循与地点详情页面相同的动态URL模式，只不过它提供的是用户的ID，而不是地点的ID。该页面仅显示已经添加到愿望清单中的地点。
- en: We must also consider what rendering strategy to use for each page. Because
    the content of the start page never changes, we’ll use static site generation
    (SSG) to render the HTML on build time. Because the detail page and wish list
    page will change based on the user’s actions, we’ll use static site rendering
    (SSR) to regenerate them upon every request.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还必须考虑每个页面使用哪种渲染策略。由于启动页面的内容永远不会改变，我们将使用静态站点生成（SSG）在构建时渲染HTML。由于详情页面和愿望清单页面将根据用户的操作发生变化，我们将使用静态站点渲染（SSR）在每次请求时重新生成它们。
- en: Lastly, all three pages should have headers containing the logo and a link to
    the start page. When we add the OAuth data in the next chapter, we’ll show the
    user’s name, a link to the user’s wish list, and the sign-in/sign-out button in
    the header as well.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，所有三个页面应具有包含徽标和指向启动页面链接的头部。当我们在下一章添加OAuth数据时，我们将在头部显示用户的姓名、指向用户愿望清单的链接以及登录/注销按钮。
- en: 'To achieve this, we need to create the following React components:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 为了实现这一点，我们需要创建以下React组件：
- en: The locations list component, which will use the locations list item component
    to render the list of locations on the start page. Later, we’ll use these same
    components to implement the list of locations on a user’s wish list page.
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 位置列表组件，它将使用位置列表项组件来渲染启动页面上的位置列表。稍后，我们将使用这些相同的组件来实现用户愿望清单页面上的位置列表。
- en: The overall layout component, header component, and logo component, which define
    the global layout of each page.
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 整体布局组件、头部组件和徽标组件，它们定义了每个页面的全局布局。
- en: The authentication element component, which lets users log in or out in the
    header.
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 身份验证元素组件，允许用户在头部登录或注销。
- en: A universal button component we’ll use for different tasks.
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个我们将用于不同任务的通用按钮组件。
- en: Let’s begin with the components necessary for the start page.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从启动页面所需的组件开始。
- en: <samp class="SANS_Futura_Std_Bold_B_11">The Start Page</samp>
  id: totrans-15
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">启动页面</samp>
- en: We’ll begin by crafting the smallest parts of the user interface and then use
    these to build the more complex components and pages. On the start page, we need
    the layout component, the locations list component, and the locations list item
    component, which is the smallest building block, so we’ll start there.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从构建用户界面中最小的部分开始，然后使用这些部分构建更复杂的组件和页面。在启动页面上，我们需要布局组件、位置列表组件和位置列表项组件，位置列表项是最小的构建块，因此我们将从这里开始。
- en: Create the *components* folder in the application’s root directory, next to
    the *middleware* folder. This is where we’ll place all our React components, in
    their own folders.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 在应用程序的根目录中创建*components*文件夹，放在*middleware*文件夹旁边。这是我们将所有React组件放在各自文件夹中的地方。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">The List Item</samp>
  id: totrans-18
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">列表项</samp>
- en: The locations list item component represents a single item in a list of locations.
    Create the *locations-list-item* folder and add two files, *index.tsx* and *index.module.css*,
    following the pattern we discussed in [Chapter 5](chapter5.xhtml). Then add the
    code in [Listing 14-1](chapter14.xhtml#Lis14-1) to *index.module.css*. We’ll use
    this CSS to style the component.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 位置列表项组件表示位置列表中的单个项。创建 *locations-list-item* 文件夹，并根据我们在 [第5章](chapter5.xhtml)
    中讨论的模式添加两个文件，*index.tsx* 和 *index.module.css*。然后，将 [Listing 14-1](chapter14.xhtml#Lis14-1)
    中的代码添加到 *index.module.css* 文件中。我们将使用此CSS样式来设计该组件。
- en: '[PRE0]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Listing 14-1: The components/locations-list-item/index.module.css file'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 'Listing 14-1: The components/locations-list-item/index.module.css 文件'
- en: The CSS module uses dark letters on a white background. In addition, it adds
    a simple hover effect, causing the background to turn blue and the font color
    white when a user hovers over it. We remove the list marker and set the margin
    and padding accordingly.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: CSS模块使用白色背景上的深色文字。此外，它添加了一个简单的悬停效果，使得当用户将鼠标悬停时，背景变为蓝色，字体颜色变为白色。我们去除了列表标记并相应地设置了边距和内边距。
- en: Now add the code from [Listing 14-2](chapter14.xhtml#Lis14-2) to the *index.tsx*
    file.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 现在将 [Listing 14-2](chapter14.xhtml#Lis14-2) 中的代码添加到 *index.tsx* 文件中。
- en: '[PRE1]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Listing 14-2: The components/locations-list-item/index.tsx file'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 'Listing 14-2: The components/locations-list-item/index.tsx 文件'
- en: You should be familiar with this file’s structure from [Chapter 5](chapter5.xhtml).
    First we import the *next/link* component, which we need to create a link to the
    detail page, the styles we just added, and the <samp class="SANS_TheSansMonoCd_W5Regular_11">LocationType</samp>
    from the Mongoose schema.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该对这个文件的结构已经非常熟悉，来自 [第5章](chapter5.xhtml)。首先，我们导入 *next/link* 组件，它是我们创建指向详细页面链接所必需的，接着导入我们刚刚添加的样式，以及来自Mongoose模式的
    <samp class="SANS_TheSansMonoCd_W5Regular_11">LocationType</samp>。
- en: We then define the <samp class="SANS_TheSansMonoCd_W5Regular_11">PropsInterface</samp>,
    a private interface used for the component’s properties object. The component
    has the usual <samp class="SANS_TheSansMonoCd_W5Regular_11">props</samp> parameter
    whose structure defines the <samp class="SANS_TheSansMonoCd_W5Regular_11">PropsInterface</samp>
    and returns a JSX element. These props hold the data in the <samp class="SANS_TheSansMonoCd_W5Regular_11">location</samp>
    property, which we pass to the component through its <samp class="SANS_TheSansMonoCd_W5Regular_11">location</samp>
    attribute. Finally, we define the <samp class="SANS_TheSansMonoCd_W5Regular_11">LocationsListItem</samp>
    component and store it in a constant that we export at the end of the file.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们定义了 <samp class="SANS_TheSansMonoCd_W5Regular_11">PropsInterface</samp>，这是一个私有接口，用于组件的属性对象。组件具有常规的
    <samp class="SANS_TheSansMonoCd_W5Regular_11">props</samp> 参数，其结构定义了 <samp class="SANS_TheSansMonoCd_W5Regular_11">PropsInterface</samp>，并返回一个JSX元素。这些props包含
    <samp class="SANS_TheSansMonoCd_W5Regular_11">location</samp> 属性中的数据，我们通过其 <samp
    class="SANS_TheSansMonoCd_W5Regular_11">location</samp> 属性将其传递给组件。最后，我们定义了 <samp
    class="SANS_TheSansMonoCd_W5Regular_11">LocationsListItem</samp> 组件，并将其存储在一个常量中，最后将其导出到文件的末尾。
- en: In the component itself, we have a list item that contains a Next.js <samp class="SANS_TheSansMonoCd_W5Regular_11">Link</samp>
    element linking to the location’s detail page. These links use a dynamic URL pattern
    that incorporates the respective location’s ID, so we create the link target to
    match */location/:location_id*. In addition, we render the location’s <samp class="SANS_TheSansMonoCd_W5Regular_11">name</samp>,
    <samp class="SANS_TheSansMonoCd_W5Regular_11">cuisine</samp>, and <samp class="SANS_TheSansMonoCd_W5Regular_11">borough</samp>
    values to the component. Keep in mind that until we create the page for the route
    */location/:location_id*, clicking those links will result in a *404* error page.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 在组件本身，我们有一个包含Next.js <samp class="SANS_TheSansMonoCd_W5Regular_11">Link</samp>
    元素的列表项，该元素链接到位置的详细页面。这些链接使用动态URL模式，其中包含相应位置的ID，因此我们创建链接目标以匹配 */location/:location_id*。此外，我们将位置的
    <samp class="SANS_TheSansMonoCd_W5Regular_11">name</samp>、<samp class="SANS_TheSansMonoCd_W5Regular_11">cuisine</samp>
    和 <samp class="SANS_TheSansMonoCd_W5Regular_11">borough</samp> 值渲染到组件中。请记住，直到我们为路由
    */location/:location_id* 创建页面之前，点击这些链接将会导致 *404* 错误页面。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">The Locations List</samp>
  id: totrans-29
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">位置列表</samp>
- en: Using the list item component, we’ll build the locations list. This component
    will loop through an array of locations and display them on the start page and
    wish list page. Create the *components/locations-list* folder and then add the
    files *index.tsx* and *index.module.css* to them. Copy the code in [Listing 14-3](chapter14.xhtml#Lis14-3)
    to the *index.module.css* file.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 使用列表项组件，我们将构建地点列表。这个组件会循环遍历地点数组，并在启动页面和愿望清单页面上显示这些地点。创建 *components/locations-list*
    文件夹，并将文件 *index.tsx* 和 *index.module.css* 添加进去。将 [列表 14-3](chapter14.xhtml#Lis14-3)
    中的代码复制到 *index.module.css* 文件。
- en: '[PRE2]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Listing 14-3: The components/locations-list/index.module.css file'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 14-3：components/locations-list/index.module.css 文件
- en: The styles for the locations list component are simple; we remove the margin
    and padding from the component’s root element. We create the component itself
    in [Listing 14-4](chapter14.xhtml#Lis14-4), which you should copy to *index.tsx*.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 地点列表组件的样式很简单；我们从组件的根元素中移除边距和内边距。我们在 [列表 14-4](chapter14.xhtml#Lis14-4) 中创建了该组件，你应当将其复制到
    *index.tsx* 文件中。
- en: '[PRE3]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Listing 14-4: The components/locations-list/index.tsx file'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 14-4：components/locations-list/index.tsx 文件
- en: We import the <samp class="SANS_TheSansMonoCd_W5Regular_11">LocationsListItem</samp>
    we just implemented, along with the module’s styles and the <samp class="SANS_TheSansMonoCd_W5Regular_11">LocationType</samp>
    from Mongoose’s schema. We then define the component’s <samp class="SANS_TheSansMonoCd_W5Regular_11">PropsInterface</samp>
    to describe the component’s <samp class="SANS_TheSansMonoCd_W5Regular_11">props</samp>
    object. In the <samp class="SANS_TheSansMonoCd_W5Regular_11">LocationsList</samp>
    component, we use the array <samp class="SANS_TheSansMonoCd_W5Regular_11">map</samp>
    function to iterate over the <samp class="SANS_TheSansMonoCd_W5Regular_11">location</samp>
    objects, rendering a <samp class="SANS_TheSansMonoCd_W5Regular_11">LocationsListItem</samp>
    component for each array item and using the <samp class="SANS_TheSansMonoCd_W5Regular_11">location</samp>
    attribute to pass the location details to the components. React requires that
    each item rendered in a loop have a unique ID. We use the location IDs for this
    purpose.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 我们导入刚刚实现的 <samp class="SANS_TheSansMonoCd_W5Regular_11">LocationsListItem</samp>，以及模块的样式和
    Mongoose 模式中的 <samp class="SANS_TheSansMonoCd_W5Regular_11">LocationType</samp>。然后，我们定义组件的
    <samp class="SANS_TheSansMonoCd_W5Regular_11">PropsInterface</samp> 来描述组件的 <samp
    class="SANS_TheSansMonoCd_W5Regular_11">props</samp> 对象。在 <samp class="SANS_TheSansMonoCd_W5Regular_11">LocationsList</samp>
    组件中，我们使用数组的 <samp class="SANS_TheSansMonoCd_W5Regular_11">map</samp> 函数遍历 <samp
    class="SANS_TheSansMonoCd_W5Regular_11">location</samp> 对象，为每个数组项渲染一个 <samp class="SANS_TheSansMonoCd_W5Regular_11">LocationsListItem</samp>
    组件，并使用 <samp class="SANS_TheSansMonoCd_W5Regular_11">location</samp> 属性将地点详情传递给组件。React
    要求在循环中渲染的每一项都具有唯一的 ID。我们使用地点 ID 来实现这个目的。
- en: We can now create the start page and pass all available locations to this component.
    Later, we’ll use the same component for the wish list page to return the locations
    on the user’s wish list.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以创建启动页面，并将所有可用的地点传递给该组件。稍后，我们将使用相同的组件来显示用户愿望清单页面上的地点。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">The Page</samp>
  id: totrans-38
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">页面</samp>
- en: At this point, we have the components we need for the start page, which is a
    basic Next.js page. Save this page’s global styles in *styles/globals.css* and
    its code in *pages/index.tsx*. [Listing 14-5](chapter14.xhtml#Lis14-5) contains
    the styles. Delete all other files from the *styles* directory. Those are default
    styles we don’t need for the application.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 此时，我们已经具备了启动页面所需的组件，这个页面是一个基本的 Next.js 页面。将该页面的全局样式保存在 *styles/globals.css*
    文件中，代码保存在 *pages/index.tsx* 文件中。[列表 14-5](chapter14.xhtml#Lis14-5) 包含了样式。删除 *styles*
    目录中的其他文件，这些是我们应用程序不需要的默认样式。
- en: '[PRE4]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Listing 14-5: The styles/globals.css file'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 14-5：styles/globals.css 文件
- en: We set a few global styles, such as the default font family, and change the
    box model to the more intuitive <samp class="SANS_TheSansMonoCd_W5Regular_11">border-box</samp>
    for all elements. By using a <samp class="SANS_TheSansMonoCd_W5Regular_11">border-box</samp>
    instead of a <samp class="SANS_TheSansMonoCd_W5Regular_11">content-box</samp>,
    an element adopts whatever width we assign to it with the <samp class="SANS_TheSansMonoCd_W5Regular_11">width</samp>
    property. Otherwise, the <samp class="SANS_TheSansMonoCd_W5Regular_11">width</samp>
    property would define only the width of the content, and we’d need to add the
    border and padding to calculate the actual dimensions of the element on the page.
    We set the font families to the defaults for each operating system to ensure readability.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 我们设置了一些全局样式，例如默认字体，并将盒子模型更改为所有元素更直观的 <samp class="SANS_TheSansMonoCd_W5Regular_11">border-box</samp>。通过使用
    <samp class="SANS_TheSansMonoCd_W5Regular_11">border-box</samp> 代替 <samp class="SANS_TheSansMonoCd_W5Regular_11">content-box</samp>，元素会采用我们用
    <samp class="SANS_TheSansMonoCd_W5Regular_11">width</samp> 属性指定的宽度。否则，<samp class="SANS_TheSansMonoCd_W5Regular_11">width</samp>
    属性只会定义内容的宽度，我们还需要加上边框和内边距，才能计算元素在页面上的实际尺寸。我们将字体设置为每个操作系统的默认值，以确保可读性。
- en: Now replace the existing content of the *pages/index.tsx* file with the code
    in [Listing 14-6](chapter14.xhtml#Lis14-6).
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，用[列表14-6](chapter14.xhtml#Lis14-6)中的代码替换现有的 *pages/index.tsx* 文件内容。
- en: '[PRE5]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Listing 14-6: The pages/index.tsx file'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 14-6：`pages/index.tsx` 文件
- en: We implemented the Next.js page, similar to the structure discussed in [Chapter
    5](chapter5.xhtml). First we import all dependencies; then we create the <samp
    class="SANS_TheSansMonoCd_W5Regular_11">NextPage</samp> and store it in a constant
    that we export at the end of the file ❶.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 我们实现了 Next.js 页面，结构类似于[第5章](chapter5.xhtml)中讨论的内容。首先，我们导入所有依赖项；然后，我们创建 <samp
    class="SANS_TheSansMonoCd_W5Regular_11">NextPage</samp>，并将其存储在常量中，最终在文件末尾导出 ❶。
- en: The Next.js page’s <samp class="SANS_TheSansMonoCd_W5Regular_11">props</samp>
    object, the page properties, contains the data we return from the <samp class="SANS_TheSansMonoCd_W5Regular_11">getStaticProps</samp>
    function ❺, discussed in [Chapter 5](chapter5.xhtml). In this asynchronous function,
    we connect to the database ❸. As soon as the connection is ready, we call the
    service method to retrieve all locations ❹ and then pass them as a JSON string
    to the <samp class="SANS_TheSansMonoCd_W5Regular_11">NextPage</samp> in the <samp
    class="SANS_TheSansMonoCd_W5Regular_11">data.locations</samp> property of the
    <samp class="SANS_TheSansMonoCd_W5Regular_11">props</samp> object. Next.js calls
    the <samp class="SANS_TheSansMonoCd_W5Regular_11">getStaticProps</samp> function
    on build time and generates the HTML for this page only once. We can use this
    rendering method because the list of available locations never changes; it is
    static.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: Next.js 页面中的 <samp class="SANS_TheSansMonoCd_W5Regular_11">props</samp> 对象，即页面属性，包含我们从
    <samp class="SANS_TheSansMonoCd_W5Regular_11">getStaticProps</samp> 函数 ❺ 返回的数据，详见[第5章](chapter5.xhtml)。在这个异步函数中，我们连接到数据库
    ❸。一旦连接准备就绪，我们调用服务方法来获取所有位置 ❹，然后将它们作为 JSON 字符串传递给 <samp class="SANS_TheSansMonoCd_W5Regular_11">NextPage</samp>，并作为
    <samp class="SANS_TheSansMonoCd_W5Regular_11">props</samp> 对象中的 <samp class="SANS_TheSansMonoCd_W5Regular_11">data.locations</samp>
    属性。Next.js 在构建时调用 <samp class="SANS_TheSansMonoCd_W5Regular_11">getStaticProps</samp>
    函数，并只生成一次该页面的 HTML。我们可以使用这种渲染方式，因为可用位置的列表是静态的，永远不会改变。
- en: Then we retrieve the locations from the page properties ❷, parse the JSON string
    back to an array, and store the page title in a variable. We type the <samp class="SANS_TheSansMonoCd_W5Regular_11">locations</samp>
    constant explicitly because TSC cannot easily infer the type. Then we construct
    the JSX. In the first step, we use the <samp class="SANS_TheSansMonoCd_W5Regular_11">next/head</samp>
    component to set the page-specific metadata. Then we call the <samp class="SANS_TheSansMonoCd_W5Regular_11">LocationList</samp>
    component we previously implemented with the <samp class="SANS_TheSansMonoCd_W5Regular_11">locations</samp>
    array in the <samp class="SANS_TheSansMonoCd_W5Regular_11">locations</samp> attribute.
    By doing so, the <samp class="SANS_TheSansMonoCd_W5Regular_11">LocationList</samp>
    component renders all locations as an overview list.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们从页面属性 ❷ 中获取位置数据，解析 JSON 字符串为数组，并将页面标题存储在一个变量中。我们显式地输入 <samp class="SANS_TheSansMonoCd_W5Regular_11">locations</samp>
    常量，因为 TSC 无法轻易推断其类型。接着我们构建 JSX。在第一步中，我们使用 <samp class="SANS_TheSansMonoCd_W5Regular_11">next/head</samp>
    组件设置页面特定的元数据。然后，我们调用之前实现的 <samp class="SANS_TheSansMonoCd_W5Regular_11">LocationList</samp>
    组件，并将 <samp class="SANS_TheSansMonoCd_W5Regular_11">locations</samp> 数组作为 <samp
    class="SANS_TheSansMonoCd_W5Regular_11">locations</samp> 属性传入。通过这样做，<samp class="SANS_TheSansMonoCd_W5Regular_11">LocationList</samp>
    组件将所有位置呈现为概览列表。
- en: As soon as you save the file, you should see, in the Docker command line, that
    Next.js recompiles the application. Open the web application at *http://localhost:3000*
    in your browser to see a list of locations similar to [Figure 14-1](chapter14.xhtml#fig14-1).
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你保存文件，你应该能够在 Docker 命令行中看到 Next.js 正在重新编译应用程序。打开浏览器中的网页应用程序 *http://localhost:3000*，你会看到类似于
    [图 14-1](chapter14.xhtml#fig14-1) 的位置列表。
- en: '![](../images/Figure14-1.jpg)'
  id: totrans-50
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/Figure14-1.jpg)'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_BI_11">Figure 14-1: The start page
    showing all available locations</samp>'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_BI_11">图 14-1：显示所有可用位置的开始页面</samp>
- en: Now we’ll move on to styling the frontend and adding basic global components,
    such as the application’s header with the Food Finder logo.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来我们将开始为前端进行样式设计，并添加一些基础的全局组件，比如带有 Food Finder 标志的应用程序头部。
- en: <samp class="SANS_Futura_Std_Bold_B_11">The Global Layout Components</samp>
  id: totrans-53
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">全局布局组件</samp>
- en: Now it’s time to create the three global components. These include the overall
    layout component, which we’ll use to format the start and wish list page content,
    a *sticky* header (which is always visible, “sticking” to the browser’s upper
    edge), and the Food Finder logo to go in the header. Again, we’ll start with the
    smallest units and then use those as building blocks for the overall components.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是时候创建三个全局组件了。这些组件包括整体布局组件，我们将用它来格式化开始页和愿望清单页的内容，一个 *粘性* 头部（它始终可见，“粘”在浏览器的顶部边缘），以及放在头部的
    Food Finder 标志。我们将从最小的单元开始，然后使用这些单元作为整体组件的构建模块。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">The Logo</samp>
  id: totrans-55
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">标志</samp>
- en: The smallest component, the logo, is nothing more than a <samp class="SANS_TheSansMonoCd_W5Regular_11">next/image</samp>
    component wrapped in a <samp class="SANS_TheSansMonoCd_W5Regular_11">next/link</samp>
    element; when users click the logo image, they’ll be redirected to the start page.
    Add a *header* folder to the *components* folder, then add a *logo* folder to
    the *header* folder and create two files there, *index.tsx* and *index.module.css*,
    into which you should paste the code in [Listing 14-7](chapter14.xhtml#Lis14-7).
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 最小的组件，标志，只不过是一个 <samp class="SANS_TheSansMonoCd_W5Regular_11">next/image</samp>
    组件，外面包裹着一个 <samp class="SANS_TheSansMonoCd_W5Regular_11">next/link</samp> 元素；当用户点击标志图像时，他们将被重定向到开始页面。添加一个
    *header* 文件夹到 *components* 文件夹中，然后在 *header* 文件夹里添加一个 *logo* 文件夹，并在其中创建两个文件，*index.tsx*
    和 *index.module.css*，将 [清单 14-7](chapter14.xhtml#Lis14-7) 中的代码粘贴到这两个文件中。
- en: '[PRE6]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Listing 14-7: The components/header/logo/index.module.css file'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 清单 14-7：components/header/logo/index.module.css 文件
- en: These basic styles for the component’s <samp class="SANS_TheSansMonoCd_W5Regular_11">root</samp>
    element set the image’s dimensions. We use a *mobile-first design pattern* by
    initially defining the styles to use on smaller screens and then, using a standard
    CSS media query, modifying them for screens bigger than 600px. We’ll use a bigger
    image on bigger screens.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 这些基本样式用于组件的 <samp class="SANS_TheSansMonoCd_W5Regular_11">根</samp> 元素，设置图像的尺寸。我们使用
    *移动优先设计模式*，首先定义用于小屏幕的样式，然后通过标准的 CSS 媒体查询，修改大于 600px 屏幕的样式。我们将在更大的屏幕上使用更大的图像。
- en: Now let’s create the logo component. Create an *assets* subfolder in the Next.js
    *public* folder and place the *logo.svg* file extracted from *assets.zip* into
    it. Then add the code in [Listing 14-8](chapter14.xhtml#Lis14-8) to the logo’s
    *index.tsx* file.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们创建 logo 组件。在 Next.js *public* 文件夹中创建一个 *assets* 子文件夹，并将从 *assets.zip*
    中提取的 *logo.svg* 文件放入其中。然后将 [列表14-8](chapter14.xhtml#Lis14-8) 中的代码添加到 logo 的 *index.tsx*
    文件中。
- en: '[PRE7]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Listing 14-8: The components/header/logo/index.tsx file'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 列表14-8：components/header/logo/index.tsx 文件
- en: As usual, we import the dependencies and then create an exported constant that
    contains the JSX code. We don’t pass any data to it through attributes or child
    elements; hence, we don’t need to define the component’s <samp class="SANS_TheSansMonoCd_W5Regular_11">props</samp>
    object here.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 和往常一样，我们导入依赖项，然后创建一个导出的常量，包含 JSX 代码。我们没有通过属性或子元素传递任何数据给它；因此，我们不需要在此处定义组件的 <samp
    class="SANS_TheSansMonoCd_W5Regular_11">props</samp> 对象。
- en: We use a basic <samp class="SANS_TheSansMonoCd_W5Regular_11">next/image</samp>
    inside a <samp class="SANS_TheSansMonoCd_W5Regular_11">next/link</samp> element
    to link back to the start page and set the <samp class="SANS_TheSansMonoCd_W5Regular_11">next/image</samp>’s
    attributes to fill the available space defined in the CSS file.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在 <samp class="SANS_TheSansMonoCd_W5Regular_11">next/image</samp> 中使用了一个基本的
    <samp class="SANS_TheSansMonoCd_W5Regular_11">next/link</samp> 元素来链接回起始页面，并将 <samp
    class="SANS_TheSansMonoCd_W5Regular_11">next/image</samp> 的属性设置为填充在 CSS 文件中定义的可用空间。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">The Header</samp>
  id: totrans-65
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">头部</samp>
- en: The header component will wrap the logo component we just created. Create the
    *index.tsx* file and *index.module.css* file in the *header* folder, then add
    the code in [Listing 14-9](chapter14.xhtml#Lis14-9) to the CSS file.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 头部组件将包裹我们刚刚创建的 logo 组件。在 *header* 文件夹中创建 *index.tsx* 文件和 *index.module.css*
    文件，然后将 [列表14-9](chapter14.xhtml#Lis14-9) 中的代码添加到 CSS 文件中。
- en: '[PRE8]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Listing 14-9: The components/header/index.module.css file'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 列表14-9：components/header/index.module.css 文件
- en: 'We use the CSS definitions <samp class="SANS_TheSansMonoCd_W5Regular_11">position:
    sticky</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">top: 0</samp>
    to stick the header to the upper edge of the browser. Now the header will automatically
    stay there even when users scroll down the page; the page’s content should scroll
    below the header because we set the header’s <samp class="SANS_TheSansMonoCd_W5Regular_11">z-index</samp>,
    placing the header in front of the other elements. You can think of the <samp
    class="SANS_TheSansMonoCd_W5Regular_11">z-index</samp> as determining which floor
    of a building an element is on.'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: '我们使用 CSS 定义 <samp class="SANS_TheSansMonoCd_W5Regular_11">position: sticky</samp>
    和 <samp class="SANS_TheSansMonoCd_W5Regular_11">top: 0</samp> 将头部固定在浏览器的上边缘。现在，即使用户向下滚动页面，头部也会自动停留在那里；页面的内容应该在头部下方滚动，因为我们设置了头部的
    <samp class="SANS_TheSansMonoCd_W5Regular_11">z-index</samp>，将头部置于其他元素前面。你可以把
    <samp class="SANS_TheSansMonoCd_W5Regular_11">z-index</samp> 想象成决定一个元素所在楼层的方式。'
- en: '[Listing 14-10](chapter14.xhtml#Lis14-10) shows the code for the header component.
    Copy it into the component’s *index.tsx* file.'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: '[列表14-10](chapter14.xhtml#Lis14-10) 显示了头部组件的代码。将它复制到组件的 *index.tsx* 文件中。'
- en: '[PRE9]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Listing 14-10: The components/header/index.tsx file'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 列表14-10：components/header/index.tsx 文件
- en: We define a basic component that displays the logo. Then we wrap the imported
    <samp class="SANS_TheSansMonoCd_W5Regular_11">Logo</samp> component in an element
    with a global <samp class="SANS_TheSansMonoCd_W5Regular_11">layout-grid</samp>
    class, which we’ll define in the next section.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 我们定义了一个基本组件来显示 logo。然后，我们将导入的 <samp class="SANS_TheSansMonoCd_W5Regular_11">Logo</samp>
    组件包裹在一个具有全局 <samp class="SANS_TheSansMonoCd_W5Regular_11">layout-grid</samp> 类的元素中，接下来我们将在下一节定义这个类。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">The Layout</samp>
  id: totrans-74
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">布局</samp>
- en: Currently, we have one Next.js page (the start page) and a header component.
    The easiest way to add the header to the page would be to import it into the Next.js
    page and place it directly into the JSX. However, we’ll add two more pages to
    the app, the wish list page and the location detail page, so we want to avoid
    importing the header three times.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，我们有一个 Next.js 页面（起始页面）和一个头部组件。将头部添加到页面的最简单方法是将其导入到 Next.js 页面并直接放入 JSX 中。然而，我们还将向应用程序中添加两个页面，愿望清单页面和位置详情页面，所以我们希望避免将头部导入三次。
- en: To streamline the overall app design, Next.js provides the concept of a *layout*,
    which is really just another component, and we can use it to add the header component
    as a sibling element to a page’s content. Let’s create a new layout component.
    First, to create this component’s CSS file, add *layout.css* to the *styles* folder
    and paste the code in [Listing 14-11](chapter14.xhtml#Lis14-11) into it.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 为了简化整个应用程序的设计，Next.js 提供了 *layout* 的概念，实际上这只是另一个组件，我们可以用它将头部组件添加为页面内容的兄弟元素。让我们创建一个新的布局组件。首先，为了创建该组件的
    CSS 文件，将 *layout.css* 添加到 *styles* 文件夹，并将 [Listing 14-11](chapter14.xhtml#Lis14-11)
    中的代码粘贴到其中。
- en: '[PRE10]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Listing 14-11: The styles/layout.css file'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 'Listing 14-11: The styles/layout.css file'
- en: We use the mobile-first pattern once again to define a basic grid wrapper, setting
    the global padding and maximum width for the content area. We set the wrapper’s
    left and right <samp class="SANS_TheSansMonoCd_W5Regular_11">margin</samp>s to
    <samp class="SANS_TheSansMonoCd_W5Regular_11">auto</samp>, which centers the container,
    because the margins take up all available space between the fixed-width wrapper
    and the window’s edges.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 我们再次使用移动优先模式来定义一个基本的网格包装器，设置内容区域的全局内边距和最大宽度。我们将包装器的左右 <samp class="SANS_TheSansMonoCd_W5Regular_11">margin</samp>
    设置为 <samp class="SANS_TheSansMonoCd_W5Regular_11">auto</samp>，这样可以使容器居中，因为边距会占用固定宽度的包装器和窗口边缘之间的所有可用空间。
- en: We use <samp class="SANS_TheSansMonoCd_W5Regular_11">flexbox</samp> to set the
    direction of the wrapper’s direct child elements to <samp class="SANS_TheSansMonoCd_W5Regular_11">column</samp>,
    displaying them one on top of the next. Because the logo and all other upcoming
    header elements are direct children of an element with the <samp class="SANS_TheSansMonoCd_W5Regular_11">layout-grid</samp>
    class, they are affected by the <samp class="SANS_TheSansMonoCd_W5Regular_11">flexbox</samp>
    layout. In contrast, the location items aren’t direct siblings. Hence, they won’t
    change their direction when switching between screen sizes.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用 <samp class="SANS_TheSansMonoCd_W5Regular_11">flexbox</samp> 设置包装器的直接子元素的排列方向为
    <samp class="SANS_TheSansMonoCd_W5Regular_11">column</samp>，使它们一个接一个地垂直排列。由于 logo
    和所有接下来的头部元素都是带有 <samp class="SANS_TheSansMonoCd_W5Regular_11">layout-grid</samp>
    类的元素的直接子元素，因此它们会受到 <samp class="SANS_TheSansMonoCd_W5Regular_11">flexbox</samp>
    布局的影响。相反，位置项不是直接的兄弟元素，因此它们在切换屏幕尺寸时不会改变方向。
- en: Then we use a media query to adjust the styles for screens whose width is greater
    than 600px. Here we increase the padding and change the layout order of the direct
    child elements. Instead of using <samp class="SANS_TheSansMonoCd_W5Regular_11">column</samp>,
    we set it to <samp class="SANS_TheSansMonoCd_W5Regular_11">row</samp>, and immediately
    we display the elements next to one another.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们使用媒体查询来调整宽度大于 600px 的屏幕的样式。在这里，我们增加了内边距，并改变了直接子元素的布局顺序。我们不再使用 <samp class="SANS_TheSansMonoCd_W5Regular_11">column</samp>，而是将其设置为
    <samp class="SANS_TheSansMonoCd_W5Regular_11">row</samp>，这样就能立即将元素并排显示。
- en: Because this is a global styles file and not a CSS module, Next.js won’t automatically
    scope the class names. Hence, we prefix them with <samp class="SANS_TheSansMonoCd_W5Regular_11">layout-</samp>
    and don’t import the styles into the component before using them.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这是一个全局样式文件，而不是 CSS 模块，Next.js 不会自动作用域类名。因此，我们为类名前添加了 <samp class="SANS_TheSansMonoCd_W5Regular_11">layout-</samp>
    前缀，并且在使用这些样式之前不会将它们导入到组件中。
- en: Now create a *layout* folder inside the *components* folder and add the *index.tsx*
    file to it with the component code in [Listing 14-12](chapter14.xhtml#Lis14-12).
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 现在在 *components* 文件夹内创建一个 *layout* 文件夹，并添加 *index.tsx* 文件，将 [Listing 14-12](chapter14.xhtml#Lis14-12)
    中的组件代码粘贴到其中。
- en: '[PRE11]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Listing 14-12: The components/layout/index.tsx file'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 'Listing 14-12: The components/layout/index.tsx file'
- en: In the layout component, we define a private interface and the component with
    the usual structure. Inside the component, we add the <samp class="SANS_TheSansMonoCd_W5Regular_11">Header</samp>
    and the <samp class="SANS_TheSansMonoCd_W5Regular_11">main</samp> element that
    uses the global layout styles and acts as a wrapper for the <samp class="SANS_TheSansMonoCd_W5Regular_11">children</samp>
    elements we’ll pass to this component in the *_app.tsx* file.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 在布局组件中，我们定义了一个私有接口和一个具有常规结构的组件。在组件内部，我们添加了 <samp class="SANS_TheSansMonoCd_W5Regular_11">Header</samp>
    和使用全局布局样式的 <samp class="SANS_TheSansMonoCd_W5Regular_11">main</samp> 元素，它作为包装器，包含了我们将在
    *_app.tsx* 文件中传递给该组件的 <samp class="SANS_TheSansMonoCd_W5Regular_11">children</samp>
    元素。
- en: Open the *_app.tsx* file and modify it as shown in [Listing 14-13](chapter14.xhtml#Lis14-13).
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 打开 *_app.tsx* 文件并按 [Listing 14-13](chapter14.xhtml#Lis14-13) 中所示进行修改。
- en: '[PRE12]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Listing 14-13: The pages/_app.tsx file'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 'Listing 14-13: The pages/_app.tsx file'
- en: First we add *layout.css* as a global style. As for the layout, we have only
    one <samp class="SANS_TheSansMonoCd_W5Regular_11">layout</samp> component we’ll
    use for all pages, and we import it here. Then we wrap our application, the pages,
    with the layout and pass the current page in the component’s <samp class="SANS_TheSansMonoCd_W5Regular_11">children</samp>
    property.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们添加 *layout.css* 作为全局样式。至于布局，我们只有一个 <samp class="SANS_TheSansMonoCd_W5Regular_11">layout</samp>
    组件，将用于所有页面，并在此处导入。然后，我们将应用程序的页面包裹在布局中，并将当前页面传递给组件的 <samp class="SANS_TheSansMonoCd_W5Regular_11">children</samp>
    属性。
- en: 'Now all our Next.js pages will follow the same structure: they’ll have the
    <samp class="SANS_TheSansMonoCd_W5Regular_11">Header</samp> component next to
    the <samp class="SANS_TheSansMonoCd_W5Regular_11">main</samp> element containing
    the page’s content. One advantage of following this pattern is that the component’s
    state will be preserved across page changes and React component re-rendering.'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，所有我们的 Next.js 页面都将遵循相同的结构：它们将在 <samp class="SANS_TheSansMonoCd_W5Regular_11">Header</samp>
    组件旁边，包含页面内容的 <samp class="SANS_TheSansMonoCd_W5Regular_11">main</samp> 元素。遵循这种模式的一个好处是，组件的状态将在页面变化和
    React 组件重新渲染之间保持不变。
- en: Once Next.js has recompiled the application, try reloading the application at
    *http://localhost:3000* in your browser. It should look like [Figure 14-2](chapter14.xhtml#fig14-2).
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦 Next.js 重新编译应用程序，请尝试在浏览器中重新加载应用程序 *http://localhost:3000*。它应该看起来像 [图 14-2](chapter14.xhtml#fig14-2)。
- en: '![](../images/Figure14-2.jpg)'
  id: totrans-93
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/Figure14-2.jpg)'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_BI_11">Figure 14-2: The start page
    with the header and layout component</samp>'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: '<samp class="SANS_Futura_Std_Book_Oblique_BI_11">图 14-2: 带有标题和布局组件的起始页面</samp>'
- en: You should now see the header, and the new layout component centers the content.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你应该能看到标题，而新的布局组件使内容居中。
- en: <samp class="SANS_Futura_Std_Bold_B_11">The Location Details Page</samp>
  id: totrans-96
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">位置详情页面</samp>
- en: Our application now has a start page with a header and a list of all available
    locations. The list items link to their particular location’s detail page because
    we added a <samp class="SANS_TheSansMonoCd_W5Regular_11">next/link</samp> component
    to them, but those pages don’t exist yet. If you click one of the links, you’ll
    get a *404* error. To display the location details pages, we first need to implement
    the component that lists a particular location’s details and then create a new
    Next.js page.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的应用程序现在有一个带有标题的起始页面，并列出所有可用的位置。列表项链接到其特定位置的详情页，因为我们在它们中添加了 <samp class="SANS_TheSansMonoCd_W5Regular_11">next/link</samp>
    组件，但这些页面还不存在。如果点击其中一个链接，你将遇到 *404* 错误。为了显示位置详情页面，我们首先需要实现列出特定位置详情的组件，然后创建一个新的
    Next.js 页面。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">The Component</samp>
  id: totrans-98
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">组件</samp>
- en: Let’s start with the details component. Create the *location-details* folder
    in the *components* directory and add the *index.module.css* and *index.tsx* files
    to it. Then add the code from [Listing 14-14](chapter14.xhtml#Lis14-14) to the
    CSS module.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从详情组件开始。在 *components* 目录中创建 *location-details* 文件夹，并向其中添加 *index.module.css*
    和 *index.tsx* 文件。然后将 [列表 14-14](chapter14.xhtml#Lis14-14) 中的代码添加到 CSS 模块中。
- en: '[PRE13]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Listing 14-14: The components/locations-details/index.module.css file'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: '列表 14-14: components/locations-details/index.module.css 文件'
- en: The styles for the component are basic. We remove the default margin and padding,
    as well as the list styles, and then add a custom margin at the end of each list
    item and root element.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 该组件的样式比较基础。我们去掉了默认的边距和填充以及列表样式，然后在每个列表项和根元素的末尾添加了自定义边距。
- en: To implement the location details component, add the code from [Listing 14-15](chapter14.xhtml#Lis14-15)
    to the *index.tsx* file in the *components/locations-details* folder.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 要实现位置详情组件，将 [列表 14-15](chapter14.xhtml#Lis14-15) 中的代码添加到 *components/locations-details*
    文件夹中的 *index.tsx* 文件。
- en: '[PRE14]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Listing 14-15: The components/locations-details/index.tsx file'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: '列表 14-15: components/locations-details/index.tsx 文件'
- en: The locations detail component is structurally similar to the locations list
    item. Both take an object containing the location’s data and add a specific set
    of properties to the returned JSX element. The main difference is in the JSX structure
    we create. Otherwise, we follow the known pattern, importing the required styles
    and type, defining the component’s <samp class="SANS_TheSansMonoCd_W5Regular_11">props</samp>
    interface using the <samp class="SANS_TheSansMonoCd_W5Regular_11">LocationType</samp>,
    and then returning a JSX element with the location details.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 位置详情组件在结构上与位置列表项类似。两者都接收一个包含位置数据的对象，并为返回的JSX元素添加一组特定的属性。主要的区别在于我们创建的JSX结构。除此之外，我们遵循已知的模式，导入所需的样式和类型，使用<samp
    class="SANS_TheSansMonoCd_W5Regular_11">LocationType</samp>定义组件的<samp class="SANS_TheSansMonoCd_W5Regular_11">props</samp>接口，然后返回一个包含位置详情的JSX元素。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">The Page</samp>
  id: totrans-107
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">页面</samp>
- en: We mentioned in “Overview of the User Interface” on page 215 that a location’s
    detail page should be available at the dynamic URL *location/:location"ePub-I">location*
    folder in the *pages* directory and add the *[locationId].tsx* file containing
    the code in [Listing 14-16](chapter14.xhtml#Lis14-16).
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在第215页的“用户界面概述”中提到，位置的详情页面应位于动态URL*location/:location"ePub-I">location*文件夹下，位于*pages*目录中，并添加包含[列表14-16](chapter14.xhtml#Lis14-16)代码的*[locationId].tsx*文件。
- en: '[PRE15]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Listing 14-16: The pages/location/[locationId].tsx file'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 列表14-16：pages/location/[locationId].tsx文件
- en: The start page and location detail page look fairly similar. The only visual
    difference is the page’s title, which we construct with the location’s name ❶,
    and instead of the <samp class="SANS_TheSansMonoCd_W5Regular_11">LocationsList</samp>
    component, we use the <samp class="SANS_TheSansMonoCd_W5Regular_11">LocationDetail</samp>
    component with a single location object ❷.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 起始页面和位置详情页面看起来非常相似。唯一的视觉差异是页面的标题，它是通过位置名称构建的❶，并且我们不再使用<samp class="SANS_TheSansMonoCd_W5Regular_11">LocationsList</samp>组件，而是使用带有单个位置对象的<samp
    class="SANS_TheSansMonoCd_W5Regular_11">LocationDetail</samp>组件❷。
- en: From a functional perspective, however, the pages are not similar. Unlike the
    start page, which uses SSG, the location detail page uses SSR with <samp class="SANS_TheSansMonoCd_W5Regular_11">getServerSideProp</samp>
    ❸. This is because as soon as we add the wish list functionality and implement
    the Add To/Remove button, the page’s content should change along with a user’s
    action. Hence, we need to regenerate the HTML on each request. We discussed the
    differences between SSR and SSG in depth in [Chapter 5](chapter5.xhtml).
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，从功能角度来看，两个页面并不相似。与使用SSG的起始页面不同，位置详情页面使用SSR，并配合使用<samp class="SANS_TheSansMonoCd_W5Regular_11">getServerSideProp</samp>
    ❸。这是因为一旦我们添加了愿望清单功能并实现了添加/移除按钮，页面的内容应该随着用户的操作而变化。因此，我们需要在每次请求时重新生成HTML。我们在[第5章](chapter5.xhtml)中深入讨论了SSR与SSG的区别。
- en: We use the page’s <samp class="SANS_TheSansMonoCd_W5Regular_11">context</samp>
    and its <samp class="SANS_TheSansMonoCd_W5Regular_11">query</samp> property to
    get the location ID from the dynamic URL ❹. Then we use the ID to get the matching
    location from the database. As before, we use the service directly instead of
    calling the publicly exposed API, as Next.js runs both <samp class="SANS_TheSansMonoCd_W5Regular_11">get...Prop</samp>
    functions on the server side and can directly access the services in our application’s
    middleware.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用页面的<samp class="SANS_TheSansMonoCd_W5Regular_11">context</samp>及其<samp class="SANS_TheSansMonoCd_W5Regular_11">query</samp>属性，从动态URL中获取位置ID❹。然后，我们使用该ID从数据库中获取匹配的位置。如前所述，我们直接使用服务，而不是调用公开的API，因为Next.js在服务器端运行<samp
    class="SANS_TheSansMonoCd_W5Regular_11">get...Prop</samp>函数，并且可以直接访问我们应用程序中间件中的服务。
- en: We also implement two exit scenarios. First, if there is no result, we throw
    an error to step into the <samp class="SANS_TheSansMonoCd_W5Regular_11">catch</samp>
    block ❺, and by doing so, redirect the user to the *404 Not Found* error page.
    Otherwise, we store the first location from the results in the location property
    ❻ and pass it to the Next.js page function we export in the last line.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还实现了两种退出场景。首先，如果没有结果，我们会抛出一个错误，进入<samp class="SANS_TheSansMonoCd_W5Regular_11">catch</samp>块❺，这样会将用户重定向到*404
    未找到*错误页面。否则，我们将从结果中存储第一个位置到location属性❻，并将其传递给我们在最后一行导出的Next.js页面函数。
- en: <samp class="SANS_Futura_Std_Bold_B_11">Summary</samp>
  id: totrans-115
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">总结</samp>
- en: We’ve successfully built the frontend for the Food Finder application. At this
    point, you’ve implemented a full-stack web application that reads data from a
    MongoDB database and renders the results as React user interface components in
    Next.js. Next, we’ll add an OAuth authentication flow with GitHub so that users
    can log in with their GitHub account and store a personalized wish list.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经成功构建了Food Finder应用程序的前端。到目前为止，你已经实现了一个全栈网页应用，它从MongoDB数据库读取数据，并在Next.js中以React用户界面组件的形式渲染结果。接下来，我们将添加一个GitHub的OAuth认证流程，以便用户可以使用GitHub账户登录并保存个性化的愿望清单。
