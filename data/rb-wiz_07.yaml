- en: Chapter 8. Everything Is an Object (Almost)
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第八章 一切都是对象（几乎）
- en: The Subject of Our Story Is an Object
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 我们故事的主题是一个对象
- en: Scarlet ran to the Computing Contraption. “Do you know the name of that directory
    of everyone in the kingdom?” she called to the King. “It’s a hash that associates
    everyone’s name with his or her address.”
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 斯嘉丽跑到计算装置前。“你知道那个王国中每个人的目录名吗？”她对国王喊道。“它是一个哈希表，将每个人的名字和地址关联起来。”
- en: “Let’s see,” said the King. “Ah, yes! I’m pretty sure it’s called `citizens`.”
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: “让我们看看，”国王说。“啊，是的！我很确定它叫做`citizens`。”
- en: 'Scarlet nodded and began typing into IRB. When she pressed ENTER, this is what
    she saw:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 斯嘉丽点点头，开始在IRB中输入。当她按下回车键时，她看到的是：
- en: '[PRE0]'
  id: totrans-5
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The King peered over her shoulder. “That’s it!” he said. “But whoa! There must
    be a bajillion people in the kingdom! How will we find Wherefore?”
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 国王从她肩膀上探头看。“就是它！”他说。“不过哇！王国里肯定有成千上万的人！我们怎么找到Wherefore？”
- en: 'Scarlet typed some more:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 斯嘉丽继续敲打键盘：
- en: '[PRE1]'
  id: totrans-8
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: “Yeah, the hash is definitely too big to go through by hand,” Scarlet said,
    “but I bet we can write our own method to find him!”
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: “是的，哈希表肯定太大，不能手动查找，”斯嘉丽说，“不过我敢打赌我们可以写一个方法来找到他！”
- en: Ruben studied the `citizens` hash for a minute. “Remember how we could get the
    value of a hash key by typing the hash name, then the key in square brackets?”
    he asked.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 鲁本仔细研究了`citizens`哈希表。“记得我们可以通过输入哈希名，然后在方括号里加上键，来获取哈希值吗？”他问。
- en: “Yep,” Scarlet said.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: “是的，”斯嘉丽说。
- en: “Well,” Ruben said, “what if we just write a method that takes a person’s name
    and the `citizens` hash, then tries to find that name in the hash?”
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: “嗯，”鲁本说，“如果我们写一个方法，传入一个人的名字和`citizens`哈希表，然后试图在哈希表中查找这个名字，怎么样？”
- en: '“Ruben, you’re a genius!” Scarlet said. She quickly typed:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: “鲁本，你真是个天才！”斯嘉丽说。她迅速打字：
- en: '[PRE2]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '“Hang on, hang on. What’s all this?” the King asked. “Just a quick method I
    whipped up,” Scarlet said. “See? It’s called `find_person`, and it takes a person’s
    `name` as a symbol and a hash of `people` as parameters. If it finds the name
    in the hash, it prints it out; otherwise, it says the name’s not found!” She typed:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: “等等，等等。这是什么？”国王问。“只是我随便写的一个方法，”斯嘉丽说。“看吧？它叫做`find_person`，它接受一个人的`name`作为符号和一个`people`的哈希表作为参数。如果它在哈希表中找到了名字，就打印出来；否则，它就说名字没找到！”她继续输入：
- en: '[PRE3]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: “There it is!” Scarlet said. “It found the `:wherefore` key in the `citizens`
    hash.”
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: “找到了！”斯嘉丽说。“它在`citizens`哈希表中找到了`:wherefore`键。”
- en: “One half mile due east!” said the Off-White Knight. “That should only take
    a few minutes, and east is that way. Let’s go!”
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: “往东走半英里！”褪色骑士说。“应该只要几分钟，东边就在那儿。走吧！”
- en: The Dagron rose to her full height, blotting out the sun for an instant. “I’ll
    come as well,” she said. “Wherefore and I are old friends, and we haven’t spoken
    in some time. It will be good to see him again.”
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 达格龙挺直了身子，瞬间遮住了太阳。“我也去，”她说，“我和Wherefore是老朋友，我们已经有一段时间没见面了。能再次见到他真好。”
- en: “Well, then,” said the King, “lead the way!”
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: “那好，”国王说，“带路吧！”
- en: The Off-White Knight and the Dagron turned and headed toward the late morning
    sun, and the King, Scarlet, and Ruben followed. The trees became taller and closer
    together as they walked, and after a few minutes, the sun could only be seen as
    a warm red light through the tops of the Carmine Pines.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 褪色骑士和达格龙转身，朝着上午晚些时候的太阳走去，国王、斯嘉丽和鲁本紧随其后。他们走着走着，树木越来越高，彼此也越来越密集，几分钟后，太阳只从卡尔梅松松树的树梢间透出一抹温暖的红光。
- en: “Hold on a second,” Ruben said, stopping and turning his head to one side. “Do
    you hear that?”
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: “等一下，”鲁本说，他停下脚步，转过头去。“你听到了吗？”
- en: They all paused. The King cupped his hand to his ear, shook his head, wiggled
    his little finger around in his ear, then cupped his hand to it again. “I don’t
    hear anything,” he said.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 他们都停了下来。国王捂住耳朵，摇了摇头，把小指头插进耳朵里转了转，然后又捂住耳朵。“我什么也听不见，”他说。
- en: “I think I hear it too,” said the Dagron. “It’s—”
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: “我也听到了，”达格龙说。“是——”
- en: “Music!” cried Ruben. “It’s coming from over there!” He pointed a little to
    the right of where they’d been headed.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: “音乐！”鲁本喊道，“它是从那边传来的！”他指向他们之前前进方向的右侧。
- en: “Let’s go!” said Scarlet, and the group pressed on into the Pines.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: “走吧！”斯嘉丽说道，大家继续向松树林走去。
- en: The music grew louder, and after walking through a particularly dense thicket
    of trees, the group found themselves on the edge of a small meadow. In the very
    center, perched on a wide tree stump, was a man in a scarlet tunic and archer’s
    cap with a long white feather in it. He was playing a pink mandolin and occasionally
    stopping to furiously scribble on a long roll of parchment with a quill pen, which
    sported the same type of long white feather as his cap.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 音乐声渐渐增大，在穿过一片特别密集的树林后，大家发现自己站在一片小草地的边缘。在草地中央，树桩上坐着一个身穿红色长袍、戴着带有长白羽毛的弓箭手帽的男人。他正在弹奏一把粉色的曼陀林，偶尔停下来用羽毛笔在一卷长纸上急促地涂写，而这支羽毛笔与他帽子上的白羽毛一模一样。
- en: “Wherefore!” boomed the Dagron.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: “为什么！”达格龙轰然回应。
- en: The man on the stump stopped scribbling and looked up. A wide grin broke out
    across his face. “The Dagron!” he called. “Wonderful to see you! Come in, come
    in, come in.”
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 站在树桩上的男人停下了涂鸦，抬起头来看。他的脸上露出了灿烂的笑容。“达格龙！”他喊道，“真高兴见到你！进来，进来，进来。”
- en: '![image with no caption](../Images/httpatomoreillycomsourcenostarchimages2160029.png.jpg)'
  id: totrans-30
  prefs: []
  type: TYPE_IMG
  zh: '![没有标题的图片](../Images/httpatomoreillycomsourcenostarchimages2160029.png.jpg)'
- en: Led by the Dagron, the group crossed the meadow and circled around Wherefore.
    Wherefore leapt nimbly from his stump, removed his cap, and bowed deeply.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 在达格龙的带领下，大家穿过草地，围绕着为什么转了一圈。为什么灵活地跳下树桩，脱下帽子，深深地鞠了一躬。
- en: “Friends,” he said, “welcome to my forest stronghold!” He gestured to the stump.
    “It’s not much to look at now, but I’ve always had a weak spot for a fixer-upper.
    And I,” he said, “am your humble host, Wherefore the Wand’ring Minstrel.” Wherefore
    replaced his cap on his head. “I know, of course, the Dagron, and I’ve met the
    Off-White Knight before.” He looked at the King and pressed his palms together.
    “Your Majesty,” he said. “I’ve not had the pleasure of meeting you before, but
    it *is* a pleasure.”
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: “朋友们，”他说，“欢迎来到我的森林根据地！”他指着树桩。“现在看起来不怎么样，但我一直对修缮旧物有一种情结。而我，”他说，“是你们谦卑的主人，流浪的吟游诗人为什么。”为什么把帽子戴回了头上。“我当然认识达格龙，我之前也见过那位灰白骑士。”他看着国王，双手合十。“陛下，”他说，“我之前没有荣幸见过您，但现在*确实*是荣幸。”
- en: “Likewise,” said the King. “We’ve heard much about you!”
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: “同样的，”国王说道，“我们听说过很多关于你的事情！”
- en: Wherefore turned to Ruben and Scarlet. “Which leaves you fine rapscallions.
    What do you call yourselves?”
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么转向鲁本和斯卡利特。“那就剩下你们这些可爱的无赖了。你们叫什么名字？”
- en: “I’m Scarlet,” said Scarlet, “and this is Ruben.”
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: “我是斯卡利特，”斯卡利特说道，“这是鲁本。”
- en: “Hi!” said Ruben.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: “嗨！”鲁本说道。
- en: “Hello and hello!” said Wherefore. “Wonderful to meet you. I’m afraid you’ve
    caught me at a bit of a bad time, though.” He sighed. “I’ve spent all morning
    writing a ballad, and it’s hardly half done. I’ve got to get back to it immediately
    if I’m going to finish it before nightfall.”
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: “你好，你好！”为什么说道，“很高兴见到你。不过恐怕你们来得不是时候。”他叹了口气。“我整个上午都在写一首民谣，但才写了一半。如果晚上之前想写完，我得立刻回去继续。”
- en: “A ballad?” said Scarlet.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: “一首民谣？”斯卡利特说道。
- en: “Oh, yes,” Wherefore said, “you see, I’m something of a businessman. I operate
    a small-time ballad delivery service with dozens of customers. The only catch
    is,” he said, “that this means I do in fact have *dozens* of customers, and each
    ballad takes me hours to write. I can hardly keep up!” He pulled a handkerchief
    from his tunic pocket and mopped his brow.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: “哦，是的，”为什么说道，“你看，我算是个商人。我经营一个小型的民谣配送服务，拥有几十个客户。唯一的难题是，”他说，“这意味着我确实有*几十*个客户，而每首民谣都需要我花上好几个小时才能完成。我简直忙不过来了！”他从长袍口袋里拿出一条手帕，擦了擦额头上的汗水。
- en: The Dagron hummed thoughtfully, exhaling little puffs of smoke. “You know,”
    she said, “I think I can be of service.” She looked around the nearly empty meadow.
    “But I’ll need a little Ruby magic. Do you happen to have a Computing Contraption
    nearby?”
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 达格龙若有所思地哼着，吐出几缕烟雾。“你知道，”她说道，“我想我可以帮上忙。”她环顾四周，几乎空旷的草地。“不过我需要一点鲁比魔法。你们附近有计算装置吗？”
- en: Wherefore laughed. “*Do* I have a Computing Contraption!” he said, and he stepped
    on the largest root of the tree stump. The stump shuddered, then rose a few feet
    out of the ground. It rotated slowly as it emerged, revealing the familiar glow
    of a Computing Contraption screen!
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么笑了。“*我*有计算装置！”他说着，踩上了树桩上最大的根部。树桩震动了一下，然后从地面上升起几英尺。它缓慢旋转着升起，露出了熟悉的计算装置屏幕的光芒！
- en: Classes and Objects
  id: totrans-42
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 类与对象
- en: “Wonderful,” said the Dagron, coiling herself around the stump and leaning in
    close to the screen. “Now then! Every object in your Ruby program has a unique
    ID number,” she said. “You’ll find that objects you create usually have much higher
    numbers than objects Ruby creates. See?” She touched the screen of the Computing
    Contraption with her claw and said, “Ruby has a few objects that are very familiar,
    like `0` or `true`. Each object in Ruby has its very own ID number, and that’s
    how Ruby keeps track of them all. Have a look!”
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: “太好了，”Dagron说着，绕过树墩，紧挨着屏幕靠了过去。“那么！你Ruby程序中的每个对象都有一个唯一的ID号，”她说。“你会发现，你创建的对象通常比Ruby创建的对象有更高的ID号。看？”她用爪子触摸了计算设备的屏幕，说道：“Ruby有一些非常熟悉的对象，比如`0`或`true`。Ruby中的每个对象都有自己的ID号，这就是Ruby用来追踪它们的方式。看看！”
- en: '[PRE4]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '“Built-in Ruby objects like these get ID numbers from Ruby automatically when
    IRB starts or the script loads,” the Dagron continued. “Ruby also gives IDs to
    Ruby objects we create in our programs, but they’re very high numbers. This is
    because Ruby comes with so many built-in objects for us!” She touched the Computing
    Contraption again, and more text appeared:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: “像这样的内建Ruby对象在IRB启动或脚本加载时，Ruby会自动分配ID号，”Dagron继续说道。“Ruby也会给我们在程序中创建的Ruby对象分配ID号，但这些ID号通常是非常高的。这是因为Ruby为我们提供了很多内建对象！”她再次触摸计算设备，屏幕上出现了更多文字：
- en: '[PRE5]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: “How did she do that?” Ruben whispered to the Off-White Knight. “She didn’t
    even type anything!”
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: “她是怎么做到的？”Ruben悄声对Off-White骑士说道。“她甚至什么都没打！”
- en: “She doesn’t need to,” the knight whispered back. “Dragons are magical creatures,
    and the Dagron is one of the most magical of all.”
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: “她不需要，”骑士低声回应。“龙是神奇的生物，而Dagron是所有龙中最具魔力的一个。”
- en: “But where do all these objects come from?” the Dagron asked. Wherefore sat
    cross-legged on the ground and looked up expectantly at her.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: “但是这些对象都来自哪里？”Dagron问道。Wherefore盘腿坐在地上，期待地仰望着她。
- en: '“From *classes*,” the Dagron said, answering her own question. “You can think
    of Ruby classes as little machines that make objects of a certain type, and each
    object in Ruby knows what class it belongs to. We can use the `class` method to
    ask objects what their classes are. To start, Ruby numbers are from the `Fixnum`
    class. Behold!” she said, and more code appeared on the screen:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: “来自*类*，”Dagron说，回答了她自己提的问题。“你可以把Ruby类看作是制造特定类型对象的小机器，每个Ruby对象都知道自己属于哪个类。我们可以使用`class`方法来询问对象属于哪个类。首先，Ruby的数字来自`Fixnum`类。看！”她说着，屏幕上出现了更多代码：
- en: '[PRE6]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '“A string’s class is naturally . . . `String`!” she continued:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: “一个字符串的类自然是……`String`！”她继续说道：
- en: '[PRE7]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: “That’s nice to know,” interrupted the King, “but what *good* does it do us?”
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: “知道这些很不错，”国王插话道，“但是这对我们有什么*好处*呢？”
- en: '“I was just getting to that,” said the Dagron. “When you know what class a
    Ruby object is, you can use the `new` method to make a new object of that class.
    You’ve seen this before, yes?” She gestured at new code on the screen:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: “我正要说这个，”Dagron说道。“当你知道一个Ruby对象属于哪个类时，你可以使用`new`方法来创建该类的一个新对象。你以前见过这个，对吧？”她指着屏幕上的新代码说道：
- en: '[PRE8]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: “Yup!” said Ruben.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: “是的！”Ruben说道。
- en: “Well, now you can do *this*!” said the Dagron, touching the Computing Contraption
    once more.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: “好吧，现在你可以做*这个*！”Dagron说着，再次触摸了计算设备。
- en: '[PRE9]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: “You see?” said the Dagron, folding her claws. “Every object in Ruby has a class,
    which we can find with the `class` method. Not only that, but every object is
    created by a class with the `new` method, and it’s the class’s job to produce
    objects of a particular type!”
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: “你看到了吗？”Dagron说，折叠起她的爪子。“Ruby中的每个对象都有一个类，我们可以用`class`方法找到它。更重要的是，每个对象都是通过类的`new`方法创建的，类的工作就是生成特定类型的对象！”
- en: “So the class is like a cookie cutter, stamping out particular kinds of cookies,”
    said Wherefore, hitting his palm with his closed fist in a stamping motion. “Gingerbread
    men, chocolate chip cookies, sugar cookies shaped like snowflakes. And the objects
    are the cookies!”
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: “所以这个类就像一个饼干模具，压制出特定种类的饼干，”Wherefore说着，用闭拳拍打着掌心做出压制的动作。“姜饼人、巧克力碎片饼干、雪花形状的糖饼干。而对象就是这些饼干！”
- en: “That’s a very good way of thinking about it,” said the Dagron.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: “这是一个非常好的思考方式，”Dagron说。
- en: “When’s lunch?” asked Wherefore.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: “什么时候吃午餐？”Wherefore问道。
- en: '![image with no caption](../Images/httpatomoreillycomsourcenostarchimages2160031.png.jpg)'
  id: totrans-64
  prefs: []
  type: TYPE_IMG
  zh: '![没有标题的图片](../Images/httpatomoreillycomsourcenostarchimages2160031.png.jpg)'
- en: “I’m afraid I still don’t quite understand,” the King interrupted. “And I’m
    still a bit mystified as to what makes classes so important.”
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: “恐怕我还是不太明白，”国王打断道。“我仍然有点困惑，类到底有什么重要的？”
- en: “I think I can help with that one,” said Scarlet. “When we’re dealing with numbers
    or strings, the helpful things classes do might not be obvious. But if we’re creating
    our *own* objects with their *own* new classes, classes become a way of creating
    a bunch of objects from a template. For example, if we have a `Minstrel` class,
    we can make a bunch of minstrels!”
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: “我想我可以帮忙解释这个，”斯嘉丽说道。“当我们处理数字或字符串时，类所做的有用事情可能不太明显。但是如果我们要创建我们*自己的*对象，并且有*自己的*新类，类就成了从模板创建一堆对象的方式。例如，如果我们有一个`Minstrel`类，我们就可以创造一堆吟游诗人！”
- en: “How?” asked the King.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: “怎么做？”国王问道。
- en: Creating Our First Class, Minstrel
  id: totrans-68
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建我们的第一个类：Minstrel
- en: “I’m glad you asked! Let’s give it a try,” said the Dagron. She touched the
    Computing Contraption, and more code filled the screen.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: “很高兴你问了！我们来试试吧，”达格龙说。她触摸了计算装置，更多代码出现在屏幕上。
- en: Note
  id: totrans-70
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注
- en: '*For some of these longer code examples, we’ll write Ruby scripts! Whenever
    you see a filename in italics above the code, like* minstrel.rb *for the next
    example, that means you can type the code into your text editor and save it as
    a file with the given name.*'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: '*对于这些较长的代码示例，我们将编写Ruby脚本！每当你看到代码上方的文件名以斜体显示时，比如接下来例子中的* minstrel.rb *，这意味着你可以将代码输入到文本编辑器中，并将其保存为给定名称的文件。*'
- en: minstrel.rb
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: minstrel.rb
- en: '[PRE10]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: “Now then,” the Dagron said, clearing her throat, “let’s have a look. The `class`
    keyword tells Ruby you’d like to make a new class,” she said. “Just like you use
    `def` and `end` to tell Ruby you’re defining a new method, you use `class` and
    `end` to tell Ruby you’d like to create a new class.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: “那么，”达格龙清了清嗓子，说道，“我们来看看。`class`关键字告诉Ruby你想创建一个新类，”她说。“就像你使用`def`和`end`告诉Ruby你在定义一个新方法一样，你使用`class`和`end`告诉Ruby你想创建一个新类。”
- en: “After `class`, you type the name of the class, which can be whatever you like,”
    the Dagron explained. “Class names, however, *always* begin with a capital letter,
    like `Minstrel`.” Wherefore had turned his parchment over and was taking notes
    as quickly as he could on the back of his ballad. “We’re creating the `Minstrel`
    class, so we can make lots of new minstrels.”
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: “在`class`之后，你输入类的名称，可以是你喜欢的任何名字，”达格龙解释道。“不过，类名*总是*以大写字母开头，比如`Minstrel`。”Wherefore已经把羊皮纸翻过来，正在尽快地在他的歌谣背面做笔记。“我们正在创建`Minstrel`类，这样我们就可以创建很多新的吟游诗人。”
- en: '“Between `class` and that final `end`, you can add any methods you wish, just
    as you would define them outside a class,” the Dagron continued. “In the `Minstrel`
    class, I defined three: `initialize`, `introduce`, and `sing`.”'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: “在`class`和最后的`end`之间，你可以添加任何你想要的方法，就像在类外定义方法一样，”达格龙继续说道。“在`Minstrel`类中，我定义了三个方法：`initialize`、`introduce`和`sing`。”
- en: Ruben leaned in close to the Computing Contraption’s screen. “Why does that
    `@name` variable have an `@` in front of it?” he asked.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 鲁本凑近计算装置的屏幕。“为什么那个`@name`变量前面有一个`@`呢？”他问。
- en: “All in good time,” said the Dagron.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: “一切都在合适的时候，”达格龙说道。
- en: Note
  id: totrans-79
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注
- en: '*To follow along with the Dagron, we’ll need to load her script into IRB. When
    we want to use code in IRB from a file we’ve written, we just start IRB while
    we’re in the folder that contains our Ruby script, then use the `load` command
    to load the file. Load* minstrel.rb *like this:*'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: '*为了跟随达格龙，我们需要将她的脚本加载到IRB中。当我们想从文件中在IRB中使用代码时，只需在包含Ruby脚本的文件夹中启动IRB，然后使用`load`命令加载文件。像这样加载*
    minstrel.rb *：*'
- en: '[PRE11]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '*Now let’s give the Dagron’s code a try!*'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: '*现在让我们试试达格龙的代码！*'
- en: “First, let’s look at the `Minstrel` class’s `initialize` method. This gets
    called whenever we make a new instance of the class with the `new` method. Have
    a look!” The Dagron added more code to the screen.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: “首先，让我们看看`Minstrel`类的`initialize`方法。每当我们使用`new`方法创建类的新实例时，这个方法就会被调用。看看！”达格龙在屏幕上添加了更多代码。
- en: '[PRE12]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: “When we call `Minstrel.new`, we make a new minstrel. Because `initialize` takes
    a single parameter, `name`, we pass in a name when we call the `new` method. See
    the `@name="Wherefore"` bit there? It means `wherefore`’s name is `'Wherefore'!`”
    The Dagron puffed thoughtfully for a second. “So if there’s any code you want
    to run as soon as a new instance of your class is created, you put it in the definition
    of your class’s `initialize` method.”
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: “当我们调用`Minstrel.new`时，我们创建了一个新的吟游诗人。因为`initialize`方法只接受一个参数`name`，所以我们在调用`new`方法时传入了一个名字。你看到`@name="Wherefore"`那部分了吗？这意味着`wherefore`的名字是`'Wherefore'！`”达格龙深思了一下，“所以如果你想在创建类的新实例时立刻执行某些代码，就把它放在类的`initialize`方法定义中。”
- en: “Got it,” said the King.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: “明白了，”国王说。
- en: “Now all that `Proc.new` stuff makes way more sense!” said Ruben. “We were just
    making new procs whenever we called `new`!”
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: “现在所有的 `Proc.new` 相关内容更有意义了！”Ruben 说道。“我们只是每次调用 `new` 时创建新的 proc！”
- en: '“That’s right!” said the Off-White Knight. “`Proc` is a built-in Ruby class,
    and whenever we call `new`, we create a new one. We basically have a little factory
    that generates new procs whenever we want. And that’s all classes are: little
    factories that make objects!”'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: “没错！”Off-White Knight 说道。“`Proc` 是一个内置的 Ruby 类，每当我们调用 `new` 时，就会创建一个新的实例。我们基本上有一个小工厂，每当我们想要时就生成新的
    proc。类就是这个：小工厂，生产对象！”
- en: “Precisely,” puffed the Dagron, and she almost seemed to smile.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: “正是如此，”Dagron 喘着气说，她几乎露出了笑容。
- en: “What about the other two methods you added?” Scarlet asked.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: “你添加的另外两个方法怎么样？”Scarlet 问道。
- en: “Ah, yes,” said the Dagron. “Our `wherefore` is a `Minstrel`, so he has access
    to those methods automatically.”
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: “啊，是的，”Dagron 说道。“我们的 `wherefore` 是一个 `Minstrel`，因此他可以自动访问那些方法。”
- en: '[PRE13]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: “You see?” she said. “The `introduce` method prints a string with the minstrel’s
    name in it, which in this case is Wherefore. And not only can he introduce himself,
    he can also sing!”
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: “看到了吗？”她说。“`introduce` 方法打印一个包含乐师名字的字符串，在这个例子中是 Wherefore。而且他不仅可以自我介绍，还能唱歌！”
- en: '[PRE14]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '“We’ve talked about how classes make objects of a certain type,” said the Dagron,
    “but we haven’t really mentioned what an object *is*. It’s quite simple: objects
    are just little collections of values! You can think of them as buckets of information—a
    thing that might have a name, or a size, or a color. Each object gets methods
    from its class that let us talk about its name or size or color, and that’s what
    makes up our Ruby code.”'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: “我们已经讨论过类是如何生成某种类型的对象的，”Dagron 说道，“但我们其实还没有真正提到对象*是什么*。其实很简单：对象就是一小堆值！你可以把它们想象成信息的容器——可能包含一个名字、一个大小，或者一个颜色。每个对象从它的类那里继承方法，允许我们访问它的名字、大小或颜色，这就构成了我们的
    Ruby 代码。”
- en: '“All right,” said the King, “I think I understand why classes are so important
    now: they let you reuse your code for many objects without having to rewrite all
    the information and methods each time, and Ruby code is made up of objects. But
    let’s go back to Ruben’s question—what was that kooky spiral we saw on `wherefore`’s
    `@name`?”'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: “好的，”国王说道，“现在我明白为什么类如此重要了：它们让你可以重用代码来处理多个对象，而不需要每次都重写所有的信息和方法，Ruby 代码就是由对象组成的。但让我们回到
    Ruben 的问题——我们看到的那个奇怪的螺旋形图案在 `wherefore` 的 `@name` 上是怎么回事？”
- en: “The at sign (`@`) just shows Ruby that it’s a special kind of variable—the
    kind that talks about an object’s value, like its name or size or color! I’ll
    explain that a little more. Let’s try out an example using weezards,” said Wherefore.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: “@符号 (`@`) 只是告诉 Ruby 这是一个特殊类型的变量——一种描述对象值的变量，像是对象的名称、大小或颜色！我稍后会详细解释一下。让我们通过使用巫师（weezards）来试试这个例子，”Wherefore
    说道。
- en: “You mean wizards,” said Scarlet.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: “你是说巫师，”Scarlet 说道。
- en: “No, weezards,” said Wherefore. “Short wizards. Wee things. Weezards.”
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: “不，是 weezards，”Wherefore 说道。“短巫师。小巫师。Wee 的东西。Weezards。”
- en: '![image with no caption](../Images/httpatomoreillycomsourcenostarchimages2160033.png.jpg)'
  id: totrans-100
  prefs: []
  type: TYPE_IMG
  zh: '![无标题图片](../Images/httpatomoreillycomsourcenostarchimages2160033.png.jpg)'
- en: “Very well,” said the Dagron. “But to get there, I’ll need to explain the four
    different kinds of Ruby variables.”
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: “很好，”Dagron 说道。“但为了讲明白这个问题，我需要解释一下 Ruby 中四种不同类型的变量。”
- en: “Four kinds!” exclaimed the King. “I thought there was only one!”
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: “四种！”国王惊呼道。“我以为只有一种！”
- en: “The variables you’re used to seeing are called *local variables*,” said the
    Dagron. “They’re very good for creating a variable that you’re going to use quickly.
    But once we start writing our own methods and classes, we’ll need to create variables
    that can be defined inside those method and class definitions but are used much
    later—for example, when we finally call a method or create an instance of a class.”
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: “你通常看到的变量叫做*局部变量*，”Dagron 说道。“它们非常适合创建你很快就会用到的变量。但一旦我们开始编写自己的方法和类时，就需要创建一些可以在这些方法和类的定义内定义，但会在稍后使用的变量——例如，当我们最终调用一个方法或创建一个类的实例时。”
- en: “The other three kinds of variables,” the Dagron continued, “are *global variables*,
    *class variables*, and *instance variables*. It may seem confusing that we use
    different kinds of variables in different places, but once you get the hang of
    it, it’s very easy.”
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: “另外三种变量，”Dagron 接着说，“分别是*全局变量*、*类变量*和*实例变量*。虽然在不同地方使用不同类型的变量可能让人感到困惑，但一旦你掌握了其中的规律，就会发现其实非常简单。”
- en: “What do you mean by different places?” Scarlet asked.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: “你说的不同地方是什么意思？”Scarlet 问道。
- en: “*Scopes*,” said the Dagron.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: “*作用域*，”Dagron 说道。
- en: Variable Scope
  id: totrans-107
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 变量作用域
- en: Oh man, this is getting good. We’re getting into the real meat of the language!
    *Scope* is a very important idea in Ruby, and I got so excited, well, I just couldn’t
    contain myself. I hope it’s okay if I take a second to explain scope to you while
    the Dagron explains it to our intrepid heroes. It’ll take but a minute.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 哇哦，这越来越有意思了。我们正在进入语言的真正核心！*作用域*是 Ruby 中一个非常重要的概念，我激动得不行，简直无法抑制自己的兴奋。我希望你不介意我在
    Dagron 向我们的勇敢英雄们解释作用域时，借此机会也给你简单解释一下作用域。只需要一分钟。
- en: This might come as a surprise to you, but not all variables are available for
    you to use willy-nilly at any point in a Ruby program. There are times in your
    program where even though you’ve defined a variable, if you try to use it, Ruby
    will complain and say it doesn’t exist! What could this mean?
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 这可能让你感到惊讶，但并不是所有变量都可以在 Ruby 程序中的任何时候随便使用。在程序中，有时候即使你定义了一个变量，如果你尝试使用它，Ruby 会抱怨并表示它不存在！这可能意味着什么呢？
- en: 'What it means is this: at any given point in your program, only *some* of the
    variables and methods you’ve defined can be seen. The collection of variables
    and methods that can be seen at any given time in your program defines the current
    scope; you can use anything that’s in scope, and you can’t use anything that’s
    out of scope.'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着什么呢：在程序的任何给定时刻，只有*某些*你定义的变量和方法可以被访问。程序中任何时刻可以访问的变量和方法集合定义了当前的作用域；你可以使用作用域内的任何内容，而无法使用作用域外的任何东西。
- en: 'What determines your variable’s scope in Ruby? For now, here’s a good rule
    of thumb: new scopes are created inside a method definition, inside a class definition,
    and inside a block. So if you’re using the run-of-the-mill local variables we’ve
    been using, this will work perfectly:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，是什么决定了 Ruby 中变量的作用域呢？目前，这里有一个很好的经验法则：新的作用域是在方法定义、类定义和代码块内部创建的。所以，如果你使用的是我们一直在使用的普通局部变量，这样做完全没问题：
- en: '[PRE15]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: We’re just setting a `regular_old_variable` to the string `'Hello!'`. Pretty
    standard stuff.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 我们只是将一个`regular_old_variable`设置为字符串`'Hello!'`。这很标准。
- en: 'Next, we’ll define a variable within a method:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将在方法内部定义一个变量：
- en: '[PRE16]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Here, we’re defining the variable named `greeting` inside a method named `fancy_greeting`.
    You’ve seen method definitions before, so there’s nothing new here, either!
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们在名为 `fancy_greeting` 的方法内部定义了一个名为 `greeting` 的变量。你之前已经见过方法定义，所以这里也没有什么新鲜的东西！
- en: 'Next, we’ll revisit blocks:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将重新回顾代码块：
- en: '[PRE17]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'You’re a block expert by this point, so you’ve got this too: we’re calling
    the `times` method on the number `3` and passing it a block. Inside the block,
    we use the variable `number` to keep track of which number we’re on, and we print
    out each number from 0 to 2 in turn. (Don’t forget that computers start counting
    things at 0, not 1.)'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 到这个阶段，你已经是一个块的专家了，所以你也掌握了这一点：我们在数字 `3` 上调用了 `times` 方法，并传递了一个代码块。在块内部，我们使用变量
    `number` 来跟踪当前数字，并依次打印出 0 到 2 的每个数字。（别忘了，计算机从 0 开始计数，而不是从 1。）
- en: These Variable Errors Will Shock and Surprise You!
  id: totrans-120
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 这些变量错误将会让你震惊和惊讶！
- en: What might surprise you, though, is that some of this stuff will cause Ruby
    to throw an error! Let’s look at these one by one. In the following code, we start
    by defining a variable. But that `regular_old_variable` exists outside the class
    definition of `FancyThings` (in the outer *scope*), so it *doesn’t* exist inside
    the class definition!
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 不过，可能让你感到惊讶的是，这些代码中的某些部分会导致 Ruby 抛出错误！让我们一一看看。在下面的代码中，我们从定义一个变量开始。但这个`regular_old_variable`存在于
    `FancyThings` 类定义之外（在外部*作用域*中），因此它在类定义内部*不存在*！
- en: '[PRE18]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Inside class definitions, you get a brand-new set of local variables (the kinds
    of variables you’ve seen all along so far), so Ruby rightfully tells you that
    inside the class, you don’t have anything called `regular_old_variable` yet.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 在类定义内部，你会获得一组全新的局部变量（你一直以来看到的那种变量），因此 Ruby 正确地告诉你，在类内部，你还没有一个叫做 `regular_old_variable`
    的变量。
- en: 'The same goes for method definitions: they get their own sets of local variables,
    too, so when you define `regular_old_variable` within a method, it doesn’t exist
    outside the method definition:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 方法定义也是如此：它们也会获得自己的局部变量集，因此当你在方法内部定义 `regular_old_variable` 时，它在方法外部是不存在的：
- en: '[PRE19]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Another error!
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 又一个错误！
- en: And, as you might have already guessed, the `number` variable in our block example
    is *local* to the block. It stops existing as soon as the block is over, so if
    we try to use it again after the block is finished, we get an error!
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 而且，正如你可能已经猜到的那样，我们在块示例中的 `number` 变量是*局部的*，它在块结束后立即停止存在，所以如果我们在块结束后再次尝试使用它，就会出现错误！
- en: '[PRE20]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Here, for each number from 0 to 3, Ruby `puts` the `number` passed into the
    block. Now, here’s where blocks get interesting: just as with methods or classes,
    a variable defined in a block stops existing when the block is finished. *Unlike*
    methods and classes, though, blocks can access variables and information that
    are outside them! In this case, our block knows about the number 3 and so knows
    that the variable `number` should take on each number between 0 and 3\. Once the
    block is finished, though, Ruby no longer cares about `number`, so it causes an
    error if we try to use it again.'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，对于从0到3的每个数字，Ruby `puts`将传入块的`number`打印出来。现在，块变得有趣了：就像方法或类一样，在块中定义的变量在块结束时会停止存在。不过，*不同于*方法和类，块可以访问它们外部的变量和信息！在这种情况下，我们的块知道数字3，因此知道变量`number`应该取0到3之间的每个数字。然而，一旦块结束，Ruby就不再关心`number`，所以如果我们试图再次使用它，就会导致错误。
- en: 'When I first learned that Ruby could see variables in some parts of a program
    and not others, I scratched my head for a good while, and I’m sure you’re asking
    yourself the exact same thing I asked myself then: “If that’s true, how on Earth
    can I use variables that I make inside classes or methods elsewhere in my program?”
    Well, as luck would have it, the Dagron’s about to tell us!'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 当我第一次了解到Ruby可以在程序的某些部分看到变量，而在其他部分看不到时，我好好挠了挠头，我相信你现在一定在问自己我当时问自己的一样问题：“如果是真的，那我到底怎么才能在程序的其他地方使用我在类或方法中创建的变量呢？”好吧，幸运的是，Dagron就要告诉我们答案了！
- en: Global Variables
  id: totrans-131
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 全局变量
- en: '“Let’s start with *global variables*, which can be seen from anywhere in the
    program. An example might help,” said the Dagron, and she touched the Computing
    Contraption’s screen with her claw:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: “让我们从*全局变量*开始，它可以在程序的任何地方被访问。举个例子可能会有帮助，”Dagron说，她用爪子触碰了计算装置的屏幕：
- en: '[PRE21]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: “Here,” said the Dagron, “we create a variable called `$location` that’s equal
    to the string `'The Carmine Pines!'`. Then we create a method, `where_are_we?`,
    that tries to access `$location`. Normally, this wouldn’t work, but because `$location`
    is a global variable, we get `'The Carmine Pines!'` when we call the `where_are_we?`
    method!”
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: “这里，”Dagron说，“我们创建了一个名为`$location`的变量，它的值是字符串`'The Carmine Pines!'`。然后我们创建了一个方法，`where_are_we?`，它尝试访问`$location`。通常情况下，这不会起作用，但因为`$location`是一个全局变量，我们在调用`where_are_we?`方法时会得到`'The
    Carmine Pines!'`！”
- en: “Aha! I’ve seen this kind of variable before,” said the Off-White Knight. “I
    recognize it by the dollar sign it starts with! Global variables can be useful,
    since they can be seen anywhere in a Ruby program. You can define a global variable
    outside a method, inside a method, in a class, anywhere you want, and if you try
    to use it anywhere else in your program, it will just work. But,” she said, holding
    up one finger, “if the variable can be seen anywhere in the program, it can also
    be *changed* anywhere in the program, and it’s not always clear when or how that
    change happened.”
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: “啊哈！我以前见过这种变量，”Off-White Knight说。“我能通过它前面的美元符号认出来！全局变量可以很有用，因为它们可以在Ruby程序的任何地方被访问。你可以在方法外定义全局变量，在方法内定义，在类中定义，随便你想在哪里定义，而且如果你在程序的其他地方使用它，它也能正常工作。但，”她举起一根手指说，“如果变量可以在程序的任何地方被访问，它也可以在程序的任何地方被*更改*，而且你不总是能明确知道何时或者如何发生了这种变化。”
- en: Scarlet nodded. “That’s right!” she said. “Remember when we found out that something
    was altering the variables in the Flowmatic Something-or-Other? Imagine how bad
    it would be if all our variables could be changed anywhere in our programs at
    any time!”
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: Scarlet点点头。“没错！”她说。“记得我们发现有东西正在改变Flowmatic Something-or-Other中的变量吗？想象一下，如果我们所有的变量都能在程序的任何地方随时被更改，那会有多糟糕！”
- en: “Perish the thought!” said the King, shuddering. “We certainly don’t want *that*.
    All right, so we won’t use global variables if we can help it! What are the other
    sorts of variables we can use?”
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: “想都别想！”国王打了个冷战说。“我们当然不想要*那个*。好吧，那如果可以避免，我们就不使用全局变量！那我们可以使用其他类型的变量吗？”
- en: Class Variables
  id: totrans-138
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 类变量
- en: '“A wise choice, Your Majesty,” said the Dagron. “Another type of variable we
    can use is a *class variable*, which is useful if we want a class to save some
    information about itself. Just as all global variables start with `$`, all class
    variables start with `@@`, and a class can have as many class variables as it
    wants. A class variable can be seen from inside the class and by any instances
    of the class; all instances share the same class variable. Now, Wherefore, we’ll
    use your weezard example.” She blew a smoke ring at the Computing Contraption,
    and this code filled the screen:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: “明智的选择，陛下，”达格龙说道。“我们还可以使用另一种类型的变量，那就是*类变量*，它非常有用，特别是当我们希望一个类保存一些关于自己的信息时。就像所有全局变量都以`$`开头一样，所有类变量都以`@@`开头，且一个类可以有任意多个类变量。类变量可以被类内部和类的任何实例访问；所有实例共享同一个类变量。现在，韦尔福，我们来用你的巫师例子。”她对着计算装置吹了个烟圈，屏幕上出现了这段代码：
- en: weezard.rb
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: weezard.rb
- en: '[PRE22]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: '“We’ve defined a `Weezard` class with a class variable called `@@spells`,”
    said the Dagron, “as well as two methods: `initialize`, which sets up the name
    and power for a particular weezard, and `cast_spell`, which any weezard can use.
    Let’s go ahead and use `new` to create two new weezards with some special powers.
    Don’t forget to `load` the code you just wrote first!”'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: “我们定义了一个`Weezard`类，其中有一个类变量`@@spells`，”达格龙说道，“还有两个方法：`initialize`，它为特定的巫师设置名字和能力；`cast_spell`，任何巫师都可以使用。现在，我们使用`new`来创建两个具有特殊能力的新巫师。别忘了先`load`你刚刚写的代码！”
- en: '[PRE23]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: “Here’s the interesting thing about our weezards,” the Dagron continued. “Even
    though `Merlin` and `Fumblesnore` have different powers, they’re interacting with
    the same variable, `@@spells`! Each time they use `cast_spell`, the spell variable
    decreases by one. Take a look.”
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: “这就是我们这些巫师有趣的地方，”达格龙继续说道。“即便是`Merlin`和`Fumblesnore`有不同的能力，它们却在操作同一个变量`@@spells`！每当它们使用`cast_spell`时，法术变量就会减少一。看看这个。”
- en: '[PRE24]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: “So when you create a class variable, there’s just one copy for the whole class,
    and any instances you create all share that one class variable?” Ruben asked.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: “所以当你创建一个类变量时，整个类只有一个副本，而你创建的所有实例都共享这个类变量？”鲁本问道。
- en: “That’s right,” said the Dagron.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: “没错，”达格龙说道。
- en: “It’s kind of weird that all weezards share a fixed group of spells, isn’t it?”
    asked Wherefore. “Wouldn’t it make sense for each weezard to have his own set
    of spells?”
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: “所有巫师共享固定的法术组，听起来有点奇怪，不是吗？”韦尔福问道。“是不是每个巫师都有自己的一套法术更合理？”
- en: Instance Variables
  id: totrans-149
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实例变量
- en: The Dagron nodded. “Sometimes it makes sense for the class that creates objects
    to keep track of certain information, but not all that often,” she said. “For
    that reason, we don’t end up using a lot of class variables in Ruby; it’s mostly
    *instance* and *local* variables. In fact, with instance variables, we can give
    each weezard her own set of spells,” the Dagron continued, and more code appeared
    on the screen. “An instance variable can be seen from inside the class and by
    any instance of the class, just like class variables. The big difference is that
    each instance gets its very own copy of the variable!”
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 达格龙点了点头。“有时候，创建对象的类需要跟踪某些信息，但并不是每次都这样，”她说。“因此，我们在Ruby中并不常使用类变量；我们更多使用的是*实例*变量和*局部*变量。事实上，通过实例变量，我们可以为每个巫师提供她自己的法术集，”达格龙继续说道，屏幕上出现了更多代码。“实例变量可以被类内部以及类的任何实例访问，就像类变量一样。大区别在于，每个实例都有自己独立的变量副本！”
- en: weezard_2.rb
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: weezard_2.rb
- en: '[PRE25]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: “See how we’ve moved the `@@spells` variable from a variable that belongs to
    the class to a `@spells` instance variable inside the `initialize` method?” asked
    the Dagron. “Variables that start with `@` are *instance variables*. They’re called
    instance variables because each *instance*, which is what Ruby calls an object
    created by a class, has its own copy.”
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: “看看我们是如何将`@@spells`变量从一个属于类的变量移到`initialize`方法中的`@spells`实例变量的吗？”达格龙问道。“以`@`开头的变量是*实例变量*。之所以称为实例变量，是因为每个*实例*，也就是Ruby中由类创建的对象，都有自己的副本。”
- en: “So when we create instances of the `Weezard` class with the `new` method, each
    instance will get assigned its own `@spells` variable?” Scarlet asked.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: “所以当我们用`new`方法创建`Weezard`类的实例时，每个实例都会分配到自己的`@spells`变量吗？”斯嘉丽问道。
- en: “Precisely,” said the Dagron. “In fact, let’s do that now. We’ll create our
    weezards, just as we did before.”
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: “正是如此，”达格龙说道。“事实上，我们现在就来做这个。我们将像之前一样创建我们的巫师。”
- en: '[PRE26]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: “This looks just like it did the last time we created weezards!” grumped the
    King.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: “这看起来就像上次我们创建巫师时的样子！”国王抱怨道。
- en: “It’s very similar,” admitted the Dagron, “but there *is* one important difference.
    Look what happens when each weezard casts a spell!”
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: “非常相似，”达格龙承认，“但*确实*有一个重要的区别。看看每个巫师施法时发生了什么！”
- en: '[PRE27]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: “They each have their own `@spells` variable!” said Scarlet. “That’s why `fumblesnore`’s
    spell count wasn’t affected when `merlin` cast a spell.”
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: “它们每个都有自己的`@spells`变量！”斯嘉丽说。“这就是为什么`fumblesnore`的法术次数在`merlin`施法时没有受到影响。”
- en: “Exactly right,” said the Dagron. “Even though their `@spells` variables have
    the same names, each instance gets its own copy, so they don’t conflict with each
    other. Not only that, but because instances of classes can always access their
    instance variables, any instance variables we define in our classes’ `initialize`
    method can be used by the newly created objects.”
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: “完全正确，”达格龙说。“尽管它们的`@spells`变量有相同的名字，每个实例都有自己的一份，所以它们不会互相冲突。不仅如此，因为类的实例总是可以访问它们的实例变量，所以我们在类的`initialize`方法中定义的任何实例变量都可以被新创建的对象使用。”
- en: “That’s why we do things like `@name = name` in our `initialize` method definitions,”
    said the Off-White Knight. “It makes sure that when we pass in the `name` argument,
    each instance saves a copy in `@name`.”
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: “这就是为什么我们在`initialize`方法定义中做像`@name = name`这样的事，”象牙白骑士说。“它确保当我们传入`name`参数时，每个实例都会在`@name`中保存一份。”
- en: Local Variables
  id: totrans-163
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 局部变量
- en: “Speaking of local variables,” said the Dagron, “let’s have a look at those,
    shall we? They should be quite familiar, but they’re worth a second look. A *local
    variable* can be seen only in its current scope, which means it can be seen only
    in the method or class where it’s defined.”
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: “说到局部变量，”达格龙说，“我们来看看这些吧，好吗？它们应该很熟悉，但值得再看一眼。*局部变量*只能在它当前的作用域内看到，这意味着它只能在定义它的方法或类内看到。”
- en: 'New code appeared on the Computing Contraption’s screen:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 计算机装置屏幕上出现了新的代码：
- en: '[PRE28]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: “So really, local variables can be seen only inside the methods or classes where
    they’re defined, or we can use them outside *all* class and method definitions,”
    Scarlet said.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: “所以实际上，局部变量只能在它们定义的类或方法内部看到，或者我们可以在*所有*类和方法定义之外使用它们，”斯嘉丽说道。
- en: “That’s right,” said the Dagron. “There is a special scope in Ruby called the
    *top-level scope*, so if you define local variables outside *any* method or class
    definition, Ruby can see them. Have a look!”
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: “没错，”达格龙说。“Ruby中有一个特殊的作用域，叫做*顶级作用域*，所以如果你在*任何*方法或类定义之外定义局部变量，Ruby就能看到它们。看看这个！”
- en: '[PRE29]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: “You see?” said the Dagron. “Local variables can even have the exact same variable
    names, as long as they’re in different scopes! Ruby knows that the method definition
    gets its own set of local variables, so it doesn’t complain that there are two
    with the same name.”
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: “你看到了吗？”达格龙说。“局部变量甚至可以有完全相同的变量名，只要它们在不同的作用域中！Ruby知道方法定义会有自己的一组局部变量，所以它不会抱怨有两个同名的变量。”
- en: “So local variables can be seen only in the classes or methods where we define
    them, or in this special top-level scope that’s outside any class or method,”
    said the King. “But global variables can be seen anywhere, and if we create an
    instance of a class, the instance can see any instance variables we created when
    we defined the class.”
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: “所以局部变量只能在我们定义它们的类或方法中，或者在这个特殊的顶级作用域中看到，”国王说。“但全局变量可以在任何地方看到，而且如果我们创建了一个类的实例，实例可以看到我们在定义类时创建的任何实例变量。”
- en: “Precisely,” said the Dagron.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: “正是如此，”达格龙说。
- en: “And the class can see its own class variables,” the King continued.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: “而类可以看到它自己的类变量，”国王继续说道。
- en: “Correct!” said the Dagron. “In fact, it’s not just instances that can have
    methods like `initialize`, `introduce`, and `sing`; even *classes* can have their
    own methods!”
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: “正确！”达格龙说。“事实上，不仅实例可以有像`initialize`、`introduce`和`sing`这样的的方法；*类*也可以有它们自己的方法！”
- en: “Just when I was starting to get this!” moaned the King. “How is that possible?”
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: “就在我开始理解的时候！”国王抱怨道。“这是怎么可能的？”
- en: “Because,” replied the Dagron, “Ruby classes *are also objects*!”
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: “因为，”达格龙回答道，“Ruby类*也是对象*！”
- en: “I need to sit down,” said the King.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: “我需要坐下了，”国王说道。
- en: “You *are* sitting down,” said Wherefore.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: “你*确实*坐下了，”在场的问道。
- en: “So I am,” said the King, who was sitting cross-legged between the Off-White
    Knight and the Wand’ring Minstrel. “Go on, Madame Dagron,” he said. “How can we
    add a method directly to a class itself, and not just an instance of a class?”
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: “是的，”国王说道，他盘腿坐在象牙白骑士和漫游歌手之间。“继续吧，达格龙女士，”他说。“我们如何能直接将一个方法添加到类本身，而不仅仅是类的一个实例呢？”
- en: Objects and self
  id: totrans-180
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 对象和self
- en: “Well,” said the Dagron, “Ruby keeps a special built-in variable named `self`
    around at all times, and `self` refers to whatever Ruby object we’re currently
    talking about.” She was talking quickly now, and small sparks leapt from her mouth
    as she continued. “So all we need to do is use `self` to define a method inside
    our class, and instead of adding that method to the instance, we add it to the
    class itself.”
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: “嗯，”达格龙说道，“Ruby始终保持一个名为`self`的特殊内置变量，而`self`指代的是我们当前谈论的Ruby对象。”她开始快速讲解，嘴里冒出小小的火花。“所以我们所需要做的就是使用`self`来定义类中的方法，而不是将该方法添加到实例上，而是将它添加到类本身。”
- en: '“Perhaps an example would make things clearer,” said the Off-White Knight.
    She reached over and typed into the Computing Contraption:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: “也许举个例子会更清楚些，”白色骑士说。她伸手过去，开始在计算机装置上打字：
- en: monkey.rb
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: monkey.rb
- en: '[PRE30]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: “Here I’ve created a `Monkey` class,” said the knight. “It has a `@@number_of_monkeys`
    class variable that will keep track of how many monkey instances we create, as
    well as the `initialize` method we’ve seen in classes before. When we call `new`
    on `Monkey` to create a new monkey, it will add 1 to the `@@number_of_monkeys`.”
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: “这里我创建了一个`Monkey`类，”骑士说道。“它有一个`@@number_of_monkeys`类变量，用来跟踪我们创建了多少个猴子实例，还有我们在之前的类中看到的`initialize`方法。当我们对`Monkey`调用`new`来创建一个新猴子时，它会把`@@number_of_monkeys`加1。”
- en: “What about that `self.number_of_monkeys` method?” asked Ruben.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: “那那个`self.number_of_monkeys`方法呢？”鲁本问道。
- en: “That’s a class method!” said the knight. “It’s a method of the `Monkey` class
    itself, and when we call it, it will return the `@@number_of_monkeys`. Let’s have
    a look! First, we’ll load that script, and then we’ll create a few monkeys.”
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: “那是一个类方法！”骑士说道。“这是`Monkey`类本身的方法，当我们调用它时，它将返回`@@number_of_monkeys`。我们来看看吧！首先，我们加载那个脚本，然后创建几个猴子。”
- en: '[PRE31]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: '“Good!” said the Off-White Knight. “Now that we have some monkeys, let’s ask
    the `Monkey` class how many monkeys there are.” She typed into the Computing Contraption:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: “很好！”白色骑士说。“现在我们有了猴子，让我们问问`Monkey`类有多少只猴子。”她在计算机装置上打字：
- en: '[PRE32]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: “Amazing!” said Wherefore. “But why not ask an individual monkey how many monkeys
    there are?”
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: “太棒了！”Wherefore说道。“但是为什么不直接问一个猴子有多少只猴子呢？”
- en: '“Well,” said the knight, “first, it doesn’t quite make sense to ask a monkey
    instance how many other instances there are—that’s the class’s business, not the
    instance’s! But more importantly, because we used `self` when we defined the `number_of_monkeys`
    method, it’s only a method of the class, not its instances! See?” She typed some
    more:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: “嗯，”骑士说道，“首先，问一个猴子实例有多少其他实例是没有意义的——那是类的事情，而不是实例的！但更重要的是，因为我们在定义`number_of_monkeys`方法时用了`self`，它仅仅是类的方法，而不是实例的方法！看见了吗？”她继续打字：
- en: '[PRE33]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: “There we are,” said the Dagron. “The `Monkey` class has its very own `number_of_monkeys`
    method now, but it’s only on the class itself; the monkey instances themselves
    don’t have that method.”
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: “看！现在`Monkey`类有了自己的`number_of_monkeys`方法，但它只属于类本身；猴子实例没有这个方法。”
- en: '![image with no caption](../Images/httpatomoreillycomsourcenostarchimages2160035.png.jpg)'
  id: totrans-195
  prefs: []
  type: TYPE_IMG
  zh: '![没有标题的图片](../Images/httpatomoreillycomsourcenostarchimages2160035.png.jpg)'
- en: '“In fact,” said the knight, “adding methods onto classes is common enough that
    Ruby has its own shorter syntax for it. It looks like this!” And she typed some
    more:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: “事实上，”骑士说道，“向类添加方法是很常见的，Ruby为此提供了更简洁的语法。它看起来像这样！”她继续打字：
- en: monkey_2.rb
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: monkey_2.rb
- en: '[PRE34]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: '“See that?” she asked. “Instead of defining the `number_of_monkeys` method
    on the class with `self.number_of_monkeys`, I used `class << self` to tell Ruby:
    ‘Hey! Every method I define until I say `end` is a method for the class, not its
    instances.’ Look what happens when I call the method on `Monkey` without creating
    any instances.”'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: “看到吗？”她问道。“我没有在类中通过`self.number_of_monkeys`来定义`number_of_monkeys`方法，而是使用了`class
    << self`来告诉Ruby：‘嘿！我定义的每个方法，直到我说`end`为止，都是类的方法，而不是实例的方法。’看看当我在`Monkey`上调用这个方法而没有创建任何实例时会发生什么。”
- en: '[PRE35]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: “Now look what happens if I create an instance and call the method again,” said
    the knight.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: “现在看看，如果我创建一个实例并再次调用这个方法会发生什么，”骑士说道。
- en: '[PRE36]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: “See? It’s just like using `self.number_of_monkeys`,” the Off-White Knight said,
    beaming.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: “看到了吗？这就像使用`self.number_of_monkeys`一样，”白色骑士说，露出灿烂的笑容。
- en: “Very interesting,” said the Dagron. “I’d never seen `class << self` before.”
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: “真有趣，”达格龙说道。“我从没见过`class << self`。”
- en: “Really?” asked Wherefore.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: “真的？”Wherefore问道。
- en: “No one knows everything,” said the Dagron. “Not even me!”
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: “没人知道所有的事情，”达格龙说。“连我也不行！”
- en: “Many people find the `def self.method_name` syntax easier to understand,” said
    the knight, “so it’s perfectly fine to use that whenever you need to add a method
    to a class.”
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: “许多人觉得`def self.method_name`语法更容易理解，”骑士说道，“所以每当你需要为一个类添加方法时，使用这个语法是完全没问题的。”
- en: “Of course,” said Scarlet, “and now `self` makes so much more sense to me! It
    just refers to whatever the Ruby program is ‘talking about.’ And in this case,
    `self` is the class we’re inside!”
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: “当然，”斯嘉丽说，“现在`self`对我来说好多了！它只是指Ruby程序‘正在谈论’的对象。而在这种情况下，`self`就是我们所在的类！”
- en: Methods and Instance Variables
  id: totrans-209
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 方法和实例变量
- en: '“Precisely,” said the Dagron. “And with that, I have but one more trick to
    show you. You see, while it’s very easy to create instance variables for our instances,
    it’s not always so easy to get at them. See what I mean?” she said, and as she
    spoke, new code began to fill the screen:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: “完全正确，”达格龙说道。“有了这个，我还有一个技巧要展示给你们。你们看，虽然为我们的实例创建实例变量非常容易，但想要访问它们并不总是那么简单。明白我的意思了吗？”她说道，在她说话时，新的代码开始填满屏幕：
- en: '[PRE37]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: “I’ve re-created our `Minstrel` class from before, but with only an `initialize`
    method,” said the Dagron. “No `introduce` or `sing` methods! Let’s create an instance,
    like we did earlier.”
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: “我重新创建了我们之前的`Minstrel`类，但只包含一个`initialize`方法，”达格龙说道。“没有`introduce`或`sing`方法！让我们像之前一样创建一个实例。”
- en: '[PRE38]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: “Now,” said the Dagron, “see how our minstrel instance has the name ‘Wherefore’?
    (You can tell by the `@name="Wherefore"` bit.) Let’s try to get to it.”
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: “现在，”达格龙说道，“看我们的吟游诗人实例是如何拥有‘Wherefore’这个名字的？（你可以通过`@name="Wherefore"`这一部分看出来。）让我们试着去访问它。”
- en: '[PRE39]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: “You see,” said the Dagron, “while `wherefore` has a `@name` instance variable,
    it doesn’t have a `name` *method*. And when it comes to Ruby, all that matters
    are methods. In order to make `wherefore.name` actually work, we need to write
    a method to reach the `@name` instance variable.”
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: “你看，”达格龙说道，“虽然`wherefore`有一个`@name`实例变量，但它没有`name`*方法*。在Ruby中，所有重要的是方法。为了让`wherefore.name`真正起作用，我们需要写一个方法来访问`@name`实例变量。”
- en: “Does that mean we’ll need to define a method in the `Minstrel` class called
    `name`?” Scarlet asked.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: “那是不是意味着我们需要在`Minstrel`类中定义一个叫做`name`的方法？”斯嘉丽问。
- en: '“That’s exactly right,” said the Dagron, and the code on the screen changed
    under her claw:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: “完全正确，”达格龙说道，屏幕上的代码在她的爪子下发生了变化：
- en: another_minstrel.rb
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: another_minstrel.rb
- en: '[PRE40]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: “Now we have a `name` method that returns the `@name` instance variable,” said
    the Dagron. “Let’s see what happens when we create a new minstrel with this `name`
    method and try to use it!”
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: “现在我们有了一个返回`@name`实例变量的`name`方法，”达格龙说道。“让我们看看当我们创建一个带有这个`name`方法的新吟游诗人并尝试使用它时会发生什么！”
- en: '[PRE41]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: “Huzzah!” cried the King. “We’ve done it! We’ve changed the minstrel’s name
    with the `name` method.”
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: “万岁！”国王喊道。“我们成功了！我们通过`name`方法改变了吟游诗人的名字。”
- en: “Truly wonderful,” said Wherefore, “but what if we want to change the minstrel’s
    name to something else?”
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: “真是太棒了，”Wherefore说道，“但是如果我们想把吟游诗人的名字改成别的呢？”
- en: '“Well,” said the Dagron, “let’s see if we can do that with the code we have
    now.” She added more code to the Computing Contraption’s glowing screen:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: “好吧，”达格龙说道，“让我们看看能不能用现在的代码做到这一点。”她在计算装置的发光屏幕上添加了更多代码：
- en: '[PRE42]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: “We can *get* the name,” said the Dagron, “but we can’t *change* it; Ruby’s
    complaining that our instance has no method that changes names. It’s looking for
    a method we haven’t written yet!”
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: “我们可以*获取*名字，”达格龙说道，“但我们不能*改变*它；Ruby抱怨我们的实例没有方法可以改变名字。它在寻找一个我们还没写的方法！”
- en: Ruben studied the screen. “It’s that `NoMethodError` again,” he said. “It looks
    like Ruby wants the `Minstrel` class to have a method called `name=`!”
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 鲁本仔细研究了屏幕。“又是那个`NoMethodError`，”他说。“看起来Ruby想让`Minstrel`类有一个叫做`name=`的方法！”
- en: 'The Dagron nodded. “If we want to *change* the `@name`, we have to write a
    special method called `name=` to do it,” she said. “If you write the name of a
    method with an equal sign at the end, Ruby understands it to mean: ‘I want this
    method to change the value of something.’ So to change the `@name`,” she finished,
    “we’d add a bit more code.”'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 达格龙点了点头。“如果我们想要*改变*`@name`，我们需要写一个名为`name=`的特殊方法，”她说。“如果你在方法名后面加上等号，Ruby会理解为：‘我想让这个方法改变某个东西的值。’所以为了改变`@name`，”她补充道，“我们需要添加一些额外的代码。”
- en: 'She added the `name=` method to the rest of the code for all of them to see:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 她将`name=`方法添加到剩余的代码中，大家都看到了：
- en: another_minstrel_2.rb
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: another_minstrel_2.rb
- en: '[PRE43]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: “Now we have a new method, `name=`, that takes a single parameter, the `new_name`,”
    said the Dagron. “This should tell Ruby to let us change the name simply by calling
    `wherefore.name = '`*`some new name`*`'`! Let’s give it a try. First, we’ll create
    a new minstrel.”
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: “现在我们有了一个新的方法，`name=`，它接受一个参数，`new_name`，”达戈龙说道。“这应该告诉Ruby，允许我们通过调用`wherefore.name
    = '`*`some new name`*`'`来更改名字！我们来试试。首先，我们创建一个新的吟游诗人。”
- en: '[PRE44]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: “Next, we’ll try to change its name.”
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: “接下来，我们将尝试更改它的名字。”
- en: '[PRE45]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: “That’s amazing!” said Ruben. “But writing all these methods to get and set
    instance variables sure is hard work. Is there any faster way to do it?”
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: “太棒了！”鲁本说道。“不过写这些方法来获取和设置实例变量真是辛苦。有没有更快的方法呢？”
- en: 'The Dagron nodded. “As it turns out, there is,” she said. “There are three
    built-in shortcut methods for reading and writing instance variables: `attr_reader`,
    `attr_writer`, and `attr_accessor`. Here’s how they work.” She touched the Computing
    Contraption with her claw, and these words appeared:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 达戈龙点了点头。“其实是有的，”她说。“有三种内置的快捷方法来读取和写入实例变量：`attr_reader`、`attr_writer`和`attr_accessor`。它们是这样工作的。”她用爪子触碰了计算装置，出现了这些文字：
- en: another_minstrel_3.rb
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: another_minstrel_3.rb
- en: '[PRE46]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: “For example, if you pass the symbol `:name` to `attr_reader`, it will automatically
    create a method called `name` that will read the instance variable `@name`. `attr_writer`
    will automatically create a method called `name=` that will change the value of
    `@name`, and `attr_accessor` will create both the `name` and `name=` methods.”
    The Dagron clicked her claws. “In this case, I’ve called `attr_accessor` with
    `:name` and `attr_reader` with `:ballad`, which should mean I can both get and
    change the minstrel’s name, but can only read his ballad without changing it.
    Let’s create a new minstrel to test out.”
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: “举个例子，如果你将符号`:name`传递给`attr_reader`，它会自动创建一个叫做`name`的方法，用来读取实例变量`@name`。`attr_writer`会自动创建一个叫做`name=`的方法，用来改变`@name`的值，而`attr_accessor`则会同时创建`name`和`name=`这两个方法。”达戈龙点击了她的爪子。“在这个例子中，我用`:name`调用了`attr_accessor`，用`:ballad`调用了`attr_reader`，这意味着我可以既获取又更改吟游诗人的名字，但只能读取他的`ballad`，而不能修改它。让我们创建一个新的吟游诗人来测试一下。”
- en: '[PRE47]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: “Perfect,” said the Dagron. “Let’s see if `attr_accessor` lets us get and change
    the minstrel’s `name`, like we could before.”
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: “太完美了，”达戈龙说道。“让我们看看`attr_accessor`能不能让我们像之前一样获取和更改那位吟游诗人的`name`。”
- en: '[PRE48]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: '“Now let’s see if we can read the minstrel’s `ballad`, but not change it; that’s
    what `attr_reader` is supposed to do,” said the Dagron. She filled in more code
    on the Computing Contraption:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: “现在让我们看看是否能读取吟游诗人的`ballad`，但不改变它；这就是`attr_reader`应该做的事情，”达戈龙说道。她在计算装置上填入了更多代码：
- en: '[PRE49]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: Wherefore shook his head in amazement. “Extraordinary!” he said. “With these
    Ruby tools, I’ll be able to write ballads in no time at all.”
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: Wherefore震惊地摇了摇头。“太不可思议了！”他说。“有了这些Ruby工具，我马上就能写出歌曲来。”
- en: “This is one of the most amazing parts of Ruby,” said the Off-White Knight.
    “When we design programs around objects, we’re doing something called *object-oriented
    programming*, and it lets us write programs that describe real-life things like
    minstrels and ballads. Everything becomes a thousand times easier!”
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: “这是Ruby中最神奇的部分之一，”Off-White骑士说道。“当我们围绕对象设计程序时，我们就在做一种叫做*面向对象编程*的事情，它让我们能够编写描述现实世界事物（如吟游诗人和歌曲）的程序。一切都变得轻松了千倍！”
- en: “This is marvelous, truly marvelous,” said Wherefore. “I can’t thank you enough.
    How can I possibly repay you?”
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: “这太棒了，真是太棒了，”Wherefore说道。“我真是不知道该怎么感谢你们。怎么才能报答你们呢？”
- en: “Well,” Scarlet said, “actually, we were looking for you to ask whether you’d
    seen anything unusual happening in the kingdom. Ruby systems all over the kingdom
    have been breaking all day, and we’re starting to think none of the problems is
    an accident.”
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: “嗯，”斯嘉丽说，“其实，我们是来找你问问，是否注意到王国里发生了什么异常的事情。王国各地的Ruby系统整整一天都在崩溃，我们开始觉得这些问题可能不是偶然的。”
- en: “Show him the scale!” Ruben said.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: “把鳞片给他看！”鲁本说。
- en: “Oh, yeah!” Scarlet said, and she pulled the glittering green scale from her
    pocket. “Have you ever seen anything like this? We thought at first it might have
    belonged to the Dagron, but we checked and she isn’t missing a one.”
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: “哦，太棒了！”斯嘉丽说着，从口袋里拿出了那片闪闪发光的绿色鳞片。“你见过这样的东西吗？我们一开始以为它可能属于达戈龙，但我们检查过了，她并没有少一片。”
- en: “Hmm,” said Wherefore. “Quite the quandary. No, I don’t think I’ve seen any
    creature with scales like this, but I *did* see something strange out here in
    the Pines not an hour ago.”
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: “嗯，”Wherefore说，“真是个难题。不，我想我从没见过有什么生物有像这样的鳞片，但我*确实*在一小时前看到过一些奇怪的东西，在松树林里。”
- en: The King, Ruben, and Scarlet exchanged startled looks.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 国王、鲁本和斯卡利特交换了吃惊的眼神。
- en: “What was it?” Scarlet asked.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: “是什么？”斯卡利特问。
- en: “Well,” said Wherefore, “I only caught a snippet of conversation, but it was
    a few voices, talking in low tones behind that thicket yonder. I went to see what
    was going on, but they ran when I got near—three, maybe four of them,” he said.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: “嗯，”威尔福说，“我只听到了一小段对话，不过是几个人低声在那片灌木丛后说话。我去看看发生了什么，但当我靠近时，他们就跑了——三个人，可能四个，”他说道。
- en: '![image with no caption](../Images/httpatomoreillycomsourcenostarchimages2160037.png.jpg)'
  id: totrans-257
  prefs: []
  type: TYPE_IMG
  zh: '![image with no caption](../Images/httpatomoreillycomsourcenostarchimages2160037.png.jpg)'
- en: “Who were they?” asked the King.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: “他们是谁？”国王问。
- en: “I didn’t see,” said Wherefore, “but the part I overheard was dastardly indeed.
    They said something about not having made a big enough impact, and how they were
    going to see the Queen about whatever it is they were doing. I’ll bet my hat that
    when they fled, they were heading straight for the castle!”
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: “我没看清，”威尔福说，“但我听到的那部分确实相当卑鄙。他们说什么没造成足够的影响，打算去找王后谈谈他们正在做的事情。我敢打赌，当他们逃跑时，肯定是直奔城堡去了！”
- en: “The castle! The Queen!” cried the King. “Oh my biscuits, oh my gravy! If these
    are our saboteurs, the Queen could be in terrible danger!”
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: “城堡！王后！”国王喊道。“天哪，天哪！如果这些就是我们的破坏者，王后可能处于极大的危险之中！”
- en: “We’ve got to get back there, and fast!” said Scarlet. “Off-White Knight, Dagron,
    can you help us?”
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: “我们必须尽快回去！”斯卡利特说道。“白骑士，达格龙，你们能帮我们吗？”
- en: The knight frowned thoughtfully. “I’m honor bound to stay in the Pines and to
    help anyone who wanders through,” she said. “But my duties are also to the King
    and Queen. I can spread the word as quickly as possible that trouble’s afoot and
    send as many friends to the castle as I can!”
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 骑士若有所思地皱起了眉头。“我有责任留在松林中，帮助任何迷路的人，”她说，“但我的职责同样属于国王和王后。我可以尽快传达消息，告诉大家麻烦已经出现，并派遣尽可能多的朋友去城堡！”
- en: “Please do!” said Scarlet. “What about you, Dagron?”
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: “请说！”斯卡利特说道，“那你呢，达格龙？”
- en: The Dagron shook her head. “Magic and wisdom come at a price,” she said. “I’m
    not able to leave the Carmine Pines. However, there *is* a shortcut back to the
    castle.”
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 达格龙摇了摇头。“魔法和智慧都有代价，”她说，“我不能离开红松林。但是，*有*一条通往城堡的捷径。”
- en: “Where?” asked Ruben.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: “哪里？”鲁本问。
- en: “The underground passage!” said Wherefore. “Yes, I know it. Follow me, I’ll
    take you there!”
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: “地下通道！”威尔福说。“是的，我知道。跟我来，我带你们去！”
- en: The King, Scarlet, and Ruben thanked the Off-White Knight and the Dagron and,
    waving goodbye, hurried to catch up with Wherefore, who was already halfway across
    the meadow. They all plunged headlong along a twisty path of roots and knotted
    tree trunks, and after a few minutes of breathless running, they arrived at an
    enormous red pine tree, bigger than all the ones around it as far as they could
    see.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 国王、斯卡利特和鲁本感谢了白骑士和达格龙，挥手告别后急忙赶上已经走到草地半程的威尔福。它们都飞快地沿着一条弯曲的小路冲过去，路旁是树根和交织的树干，几分钟气喘吁吁的奔跑后，他们来到了那棵巨大的红松树，比周围的任何一棵都大，远远望去一眼难见尽头。
- en: “Going down!” cried Wherefore, and knocked on the trunk three times. With a
    pleasant *ding*, a door slid open in the side of the trunk, revealing a cramped
    elevator car.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: “下去了！”威尔福喊道，并且在树干上敲了三下。随着一声愉快的*叮*，一扇门在树干侧面打开，露出了一个狭小的电梯厢。
- en: “Take the elevator to the sub-sub-basement,” he said, stuffing the three of
    them inside. “You’ll find a long, narrow passage that heads off to the west. Take
    that as far as you can, then look for a large black pipe. There’ll be words written
    on it that say—”
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: “乘电梯下到次次地下室，”他说着，把他们三个塞了进去。“你会看到一条狭长的通道，通向西方。走到尽头后，找一个大黑管子。上面会写着——”
- en: “—*the Mysterious Pipe!*” cried Ruben and Scarlet together. “We saw Haldo disappear
    down into the lower levels of the castle earlier today; this passage must connect
    to the same place!”
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: “—*神秘的管道!*”鲁本和斯卡利特异口同声地喊道。“我们今天早些时候看到哈尔多消失在城堡的下层，这条通道肯定是通向同一个地方！”
- en: “Then you know your way!” said Wherefore. “Goodbye and good luck—in the meantime,
    I’ll help the Off-White Knight and the Dagron send help your way.” And with that,
    the elevator doors slid shut, and the King, Scarlet, and Ruben began to descend
    deep into the earth.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: “那你就知道路了！”威尔福说。“再见，祝好运——同时，我会帮白骑士和达格龙尽快把援助送到你们那儿。”话音刚落，电梯门紧闭，国王、斯卡利特和鲁本开始向地下深处下降。
- en: Dial-a-Ballad, or the Minstrel’s Delivery Service
  id: totrans-272
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 《拨打旋律》，或者说是“吟游诗人的快递服务”
- en: Now that we’ve taught Wherefore the Wand’ring Minstrel all about Ruby objects
    and classes, it’s time to help him create his very own `Ballad`! Otherwise, he
    won’t be much of a minstrel. Don’t worry, though—now that you know all about classes
    and how they work, creating a simple class to help Wherefore write faster, better
    ballads will be a breeze.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经向《四处流浪的歌手》讲解了 Ruby 中的对象和类，是时候帮助他创建他自己的`Ballad`（歌曲）了！否则，他就不算是一个真正的歌手了。不过别担心——既然你已经了解了类及其工作原理，创建一个简单的类来帮助《四处流浪的歌手》创作更快、更好的歌曲将不再是难题。
- en: Let’s begin by making a new file called ballad.rb and typing the following code.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从创建一个新的文件ballad.rb并输入以下代码开始。
- en: ballad.rb
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: ballad.rb
- en: '[PRE50]'
  id: totrans-276
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'It’s hard to believe, but you now know so much Ruby that there’s actually nothing
    new here! You’ve seen all this stuff before: creating classes and instances of
    classes, using `attr_accessor`, using class and instance variables, adding methods
    to classes and instances, the whole shebang. Let’s step through it line by line
    and have a look at the output.'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 难以置信的是，现在你已经学会了这么多 Ruby，实际上这里没有什么新内容！你以前见过这些东西：创建类和类的实例，使用`attr_accessor`，使用类和实例变量，给类和实例添加方法，所有这些。让我们逐行查看并看看输出。
- en: First, we create a `Ballad` class at ➊ with a `title` and `lyrics` we can both
    read and change (thanks to `attr_accessor`).
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们在 ➊ 创建一个`Ballad`类，拥有一个`title`（标题）和`lyrics`（歌词），我们可以读取并修改它们（感谢`attr_accessor`）。
- en: Next, at ➋, we set up a class variable, `@@number_of_ballads`, to track the
    number of ballads our class creates, and our `initialize` method at ➌ both sets
    the name and lyrics of the ballad and adds 1 to the `@@number_of_ballads`.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，在 ➋，我们设置了一个类变量`@@number_of_ballads`，用来跟踪我们的类创建了多少首歌曲，而我们的`initialize`方法在
    ➌ 同时设置歌曲的名称和歌词，并将`@@number_of_ballads`加1。
- en: For the last part of our class definition, we add a `number_of_ballads` method
    at ➍ on the `Ballad` class itself; that will let us get the `@@number_of_ballads`
    later.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 对于类定义的最后部分，我们在 ➍ 为`Ballad`类本身添加了一个`number_of_ballads`方法，这将让我们稍后访问`@@number_of_ballads`。
- en: Finally, we create a new ballad with `Ballad.new` at ➎, then print out some
    interesting facts about our ballad at ➏.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们在 ➎ 使用`Ballad.new`创建一首新的歌曲，然后在 ➏ 打印出一些关于我们歌曲的有趣事实。
- en: You can run the code in your file by using the terminal to go to the folder
    where you saved *ballad.rb*, then typing **`ruby ballad.rb`** on the command line.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过使用终端进入保存*ballad.rb*文件的文件夹，然后在命令行输入**`ruby ballad.rb`**来运行文件中的代码。
- en: 'Your object IDs will be slightly different from mine, but you should see something
    like this:'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 你的对象 ID 会和我的稍微不同，但你应该能看到类似这样的内容：
- en: '[PRE51]'
  id: totrans-284
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: We’ve just proved that our `self.number_of_ballads` method works, that our object
    ID doesn’t change once we create an object, and that we can get to all of the
    information we’ve stored in our ballad with the magic of `attr_accessor`.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 我们刚刚证明了`self.number_of_ballads`方法有效，我们的对象 ID 在创建对象后不会改变，并且通过`attr_accessor`的魔力，我们可以访问我们在歌曲中存储的所有信息。
- en: All that’s well and good, but the *really* interesting part is how you take
    it further! For example, you can start small by writing code to change the title
    of a ballad you create or to update its lyrics after it’s created. (Do you think
    this will change the object ID?)
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 这些都没问题，但*真正*有趣的部分是如何进一步拓展它！例如，你可以从小处开始，编写代码来修改你创建的歌曲的标题，或者在创建后更新其歌词。（你觉得这会改变对象
    ID 吗？）
- en: You could also add more `attr_reader`s, `attr_writer`s, or `attr_accessor`s.
    You could add more methods (what about a `playing_time` method to return how many
    minutes long the ballad is?). You could add class methods or create additional
    ballads.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以添加更多的`attr_reader`、`attr_writer`或`attr_accessor`。你可以添加更多的方法（比如创建一个`playing_time`方法来返回歌曲的时长是多少分钟？）。你还可以添加类方法或创建额外的歌曲。
- en: 'You could even take on the greatest challenge of all: actually writing the
    lyrics to “The Ballad of Chucky Jim”! The world is your oyster. (If you don’t
    like oysters, then the world is your cupcake.)'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 你甚至可以迎接最大的挑战：实际写出《查基·吉姆的歌》！世界是你的牡蛎。（如果你不喜欢牡蛎，那世界就是你的杯子蛋糕。）
- en: You Know This!
  id: totrans-289
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 你知道这些！
- en: You learned a fair amount in this chapter, but nowhere near as much as you crammed
    into your noggin with methods! Learning about objects and classes was practically
    a vacation! Even so, let’s take the time to go over it all one more time, just
    to make sure you’ve got it all.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 你在这一章学到了不少内容，但远远不及你在学习方法时那样充实！了解对象和类几乎就像度假一样轻松！即便如此，我们还是花点时间再回顾一遍，确保你已经完全掌握了。
- en: Objects and Classes
  id: totrans-291
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 对象和类
- en: 'You already knew that just about everything in Ruby is an object, but in this
    chapter, you learned more about objects and took a closer look at object IDs.
    An object’s ID number is like a fingerprint: every object has its very own, and
    no two objects have exactly the same one. As a general rule, objects created by
    Ruby have lower object ID numbers than objects you create:'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 你已经知道几乎所有的东西在Ruby中都是对象，但在这一章中，你学习了更多关于对象的内容，并仔细查看了对象ID。对象的ID号就像指纹：每个对象都有自己独一无二的ID，两个对象不会有完全相同的ID。一般来说，Ruby创建的对象ID号比你创建的对象ID号要低：
- en: '[PRE52]'
  id: totrans-293
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'We also saw that *classes* are how we can create a whole bunch of objects with
    similar characteristics. We create classes with the `class` keyword, like so:'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还看到，*类*是我们创建一堆具有相似特征的对象的方式。我们通过`class`关键字创建类，如下所示：
- en: '[PRE53]'
  id: totrans-295
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'Creating classes is all well and good, but classes don’t really do much for
    us until we *instantiate* (create) an object from that class. You can think of
    classes as cookie cutters and the objects they create as cookies: the cookie cutter
    (class) makes a bunch of things that are all very similar, but the thing we’re
    most interested in is the cookie itself (the object).'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 创建类本身很好，但类在我们*实例化*（创建）该类的对象之前，并不会为我们做太多事情。你可以把类想象成饼干模具，把它们创建的对象想象成饼干：饼干模具（类）做了一堆非常相似的东西，但我们最感兴趣的其实是饼干本身（对象）。
- en: 'For instance, we can define a `Monkey` class with our `class` keyword, and
    we instantiate it—that is, we make a *particular* monkey from our `Monkey` class
    cookie cutter—by calling `Monkey.new`:'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 比如，我们可以用`class`关键字定义一个`Monkey`类，然后通过调用`Monkey.new`来实例化它——也就是从我们的`Monkey`类饼干模具中做出一个*特定*的猴子：
- en: monkey_review.rb
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: monkey_review.rb
- en: '[PRE54]'
  id: totrans-299
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: Great! So far we’ve got a `Monkey` class with two methods and a class variable.
    The class variable `@@bananas` keeps track of how many bananas there are for *all*
    monkey instances, the `initialize` method sets the monkey’s name when `Monkey.new`
    is called, and `eat_banana` decreases `@@bananas` by 1.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 很好！到目前为止，我们已经有了一个`Monkey`类，里面有两个方法和一个类变量。类变量`@@bananas`跟踪所有猴子实例的香蕉数量，`initialize`方法在调用`Monkey.new`时设置猴子的名字，`eat_banana`方法将`@@bananas`减少1。
- en: 'Next, let’s create a couple of monkeys:'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们创建几只猴子：
- en: '[PRE55]'
  id: totrans-302
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'Now we can have each monkey eat a banana and see what happens:'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以让每只猴子吃个香蕉，看看会发生什么：
- en: '[PRE56]'
  id: totrans-304
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: Did you notice how our `Monkey` class’s `@@bananas` class variable was reduced
    every time *any* monkey instance ate a banana? Remember, that’s because class
    variables are shared by all instances of that class.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 你注意到每次*任何*猴子实例吃香蕉时，我们的`Monkey`类的`@@bananas`类变量都会减少吗？记住，这是因为类变量是该类所有实例共享的。
- en: 'We can assign any combination of local, instance, class, and global variables
    in combination with our classes, as shown here:'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在类中结合使用局部变量、实例变量、类变量和全局变量，如下所示：
- en: monkey_review_2.rb
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: monkey_review_2.rb
- en: '[PRE57]'
  id: totrans-308
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: Here, we’ve changed our `Monkey` class to have a global `$home` variable (`'the
    jungle'`), a `@@number_of_monkeys` class variable that keeps track of how many
    instances the `Monkey` class has created, and a `@type` instance variable that
    lets each individual monkey be of a different type.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们已经把`Monkey`类修改为拥有一个全局的`$home`变量（`'the jungle'`），一个`@@number_of_monkeys`类变量，用来跟踪`Monkey`类创建了多少个实例，还有一个`@type`实例变量，让每只猴子都有不同的类型。
- en: '[PRE58]'
  id: totrans-310
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: See how each `@type` is unique to each monkey, but they all change the same
    `@@number_of_monkeys` variable?
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 看看每个`@type`是如何对每只猴子独一无二的，但它们都在改变同一个`@@number_of_monkeys`变量吗？
- en: 'Finally, every part of the program also has access to the `$home` variable,
    since it’s global:'
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，由于`$home`是全局变量，程序的每个部分也都可以访问它：
- en: '[PRE59]'
  id: totrans-313
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: Variables and Scope
  id: totrans-314
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 变量和作用域
- en: This can all be a bit tricky to keep straight, so I’ve created the following
    handy-dandy table to help you remember the differences between local, global,
    instance, and class variables.
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 这一切可能有点难以理清楚，所以我创建了下面这张方便的表格来帮助你记住局部、全局、实例和类变量之间的区别。
- en: '| Variable type | Looks like | Where can it be seen? |'
  id: totrans-316
  prefs: []
  type: TYPE_TB
  zh: '| 变量类型 | 形式 | 能在哪里看到？ |'
- en: '| --- | --- | --- |'
  id: totrans-317
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| Local | `odelay` | Inside the top-level scope, method, or class where it’s
    defined. |'
  id: totrans-318
  prefs: []
  type: TYPE_TB
  zh: '| 局部 | `odelay` | 在定义它的顶级作用域、方法或类内部。 |'
- en: '| Global | `$odelay` | Anywhere! |'
  id: totrans-319
  prefs: []
  type: TYPE_TB
  zh: '| 全局 | `$odelay` | 任何地方！ |'
- en: '| Instance | `@odelay` | Inside the class where it’s defined or in any instance
    of the class. Each instance gets its own copy. |'
  id: totrans-320
  prefs: []
  type: TYPE_TB
  zh: '| 实例 | `@odelay` | 在定义它的类内部或该类的任何实例中。每个实例都有自己的副本。 |'
- en: '| Class | `@@odelay` | Inside the class where it’s defined or in any instance
    of the class. Each instance shares the same class variable with all other instances.
    |'
  id: totrans-321
  prefs: []
  type: TYPE_TB
  zh: '| 类别 | `@@odelay` | 在类内部或者类的任何实例中。每个实例与所有其他实例共享相同的类变量。 |'
- en: Remember, it’s usually not a good idea to use global variables, because not
    only are they visible everywhere in our program but they can also be *changed*
    from anywhere in our program. When things can be changed from a bunch of places,
    it can be hard to figure out what part of our program made the change if something
    unexpected happens. I’m showing you global variables so you know what they are
    and how they work, but in almost every situation, they’re much more trouble than
    they’re worth.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，通常不建议使用全局变量，因为它们不仅在程序中的任何地方都是可见的，而且还可以在程序中的任何地方被*修改*。当变量可以在许多地方被修改时，若发生意外情况，可能很难弄清楚是程序中的哪个部分做出了修改。我展示给你全局变量，是为了让你了解它们是什么以及如何工作，但在几乎所有情况下，它们带来的麻烦远大于它们的价值。
- en: 'As you saw in the last example, we could reach the `$home` variable from outside
    the class definition because it was defined as global (global variables start
    with a `$`). We can only ever get at a variable if it’s in the proper scope. Let’s
    review some examples from earlier in the chapter:'
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你在上一个示例中看到的，我们可以从类定义外部访问`$home`变量，因为它被定义为全局变量（全局变量以`$`开头）。我们只有在变量处于正确的作用域中时，才能访问它。让我们回顾一下本章早些时候的一些示例：
- en: '[PRE60]'
  id: totrans-324
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'Our `local_variable` exists in this outer scope, but it doesn’t exist inside
    the class definition:'
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的`local_variable`存在于这个外部作用域中，但它在类定义内部并不存在：
- en: '[PRE61]'
  id: totrans-326
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: The `local_variable` doesn’t exist inside the method definition, either!
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: '`local_variable`在方法定义内部也不存在！'
- en: '[PRE62]'
  id: totrans-328
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'Our variable `number` exists inside the block, but it’s gone as soon as the
    block’s code is finished:'
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的变量`number`存在于块内，但一旦块的代码执行完，它就消失了：
- en: '[PRE63]'
  id: totrans-330
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'We discovered that Ruby has a built-in variable, `self`, that refers to whatever
    object the method will be called on, and we can use `self` to add methods directly
    to classes (instead of just the objects they create), as shown here:'
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 我们发现Ruby有一个内建变量`self`，它指代方法将要调用的对象，我们可以使用`self`直接向类中添加方法（而不仅仅是向它们创建的对象添加方法），如下所示：
- en: monkey_review_3.rb
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: monkey_review_3.rb
- en: '[PRE64]'
  id: totrans-333
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'You’ve seen this before! It’s our `Monkey` class with a `@@number_of_monkeys`
    class variable, an `initialize` method that increases that variable every time
    we make a new monkey, and a `self.number_of_monkeys` method that means that we
    can call `Monkey.number_of_monkeys` to find out how many we’ve created so far:'
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 你之前见过这个！这是我们的`Monkey`类，它有一个`@@number_of_monkeys`类变量，一个`initialize`方法，每次我们创建一个新的猴子时都会增加这个变量，还有一个`self.number_of_monkeys`方法，这意味着我们可以调用`Monkey.number_of_monkeys`来查看我们到目前为止创建了多少个猴子：
- en: '[PRE65]'
  id: totrans-335
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: It’s `0` right now, but if we create a monkey, we’ll see that number go up!
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 它现在是`0`，但是如果我们创建一个猴子，我们会看到这个数字上升！
- en: '[PRE66]'
  id: totrans-337
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: If you’re ever unsure of the value of `self` in a particular part of your program,
    you can always `puts self` to see what it is.
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你不确定程序中特定部分的`self`值是什么，你可以随时使用`puts self`来查看它是什么。
- en: 'We also learned that if an object has an instance variable that we want to
    see or change, we have to write methods to do it. We *can* write these methods
    ourselves as follows:'
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还学到，如果一个对象有一个实例变量，我们想查看或修改它，我们必须编写方法来实现。我们*可以*像下面这样自己编写这些方法：
- en: minstrel_review.rb
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: minstrel_review.rb
- en: '[PRE67]'
  id: totrans-341
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: Here, we’ve set a `@name` in our `initialize` method, which means that any time
    we call `Minstrel.new`, we pass in a name for that minstrel. The `name` method
    gets that `@name` variable for us, and the `name=` method allows us to assign
    a `new_name` to the minstrel . . .
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们在`initialize`方法中设置了`@name`，这意味着每次我们调用`Minstrel.new`时，我们都会传入该游吟诗人的名字。`name`方法会获取这个`@name`变量，而`name=`方法允许我们为游吟诗人分配一个`new_name`
    . . .
- en: '. . . but we can also use the shortcuts `attr_reader` (to read an instance
    variable), `attr_writer` (to change an instance variable), and `attr_accessor`
    (to do both). All we do is pass the instance variable name as a symbol, like so:'
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: . . . 但我们也可以使用快捷方式`attr_reader`（用于读取实例变量）、`attr_writer`（用于修改实例变量）和`attr_accessor`（同时做两者）。我们所做的就是将实例变量名作为符号传递，例如：
- en: minstrel_review_2.rb
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: minstrel_review_2.rb
- en: '[PRE68]'
  id: totrans-345
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: Here, we’ve used `attr_accessor` and passed it a `:name` symbol to have it automatically
    create `name` and `name=` methods for us; we called `attr_reader` with `:ballad`,
    so we only get a `ballad` method to read the `@ballad` instance variable. Check
    out what happens if we try to change our ballad!
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们使用了`attr_accessor`并传入`:name`符号，它会自动为我们创建`name`和`name=`方法；我们用`attr_reader`和`:ballad`调用，所以我们只会得到一个读取`@ballad`实例变量的`ballad`方法。看看如果我们尝试更改我们的歌谣会发生什么！
- en: '[PRE69]'
  id: totrans-347
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: Object-Oriented Programming
  id: totrans-348
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 面向对象编程
- en: 'Finally, we learned that writing programs that revolve around classes and objects
    is called *object-oriented programming* (*OOP*). Our `minstrel` is a good example
    of an object: a piece of code that acts just like something in the real world!
    It has attributes (facts about itself) as well as behavior, which is just a way
    of talking about the methods the object knows how to use. We can define the behavior
    of any minstrel with a `Minstrel` class, as follows.'
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们学到，编写围绕类和对象展开的程序叫做*面向对象编程*（*OOP*）。我们的`minstrel`是一个很好的对象示例：一段行为像现实世界中的某个东西的代码！它有属性（关于它自己的事实）以及行为，后者就是指对象知道如何使用的方法。我们可以用`Minstrel`类来定义任何吟游诗人的行为，如下所示。
- en: minstrel_review_3.rb
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: minstrel_review_3.rb
- en: '[PRE70]'
  id: totrans-351
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: Our class has an `attr_reader` for `:name` (meaning we can read the name, but
    not change it), as well as a `@@number_of_minstrels` class variable that keeps
    track of how many instances we’ve created and an `initialize` method that gives
    our minstrel a name and increases the `@@number_of_minstrels`.
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的类有一个`attr_reader`，用于`：name`（这意味着我们可以读取名称，但不能修改它），还有一个`@@number_of_minstrels`类变量，用于跟踪我们创建了多少实例，以及一个`initialize`方法，给我们的吟游诗人起名字并增加`@@number_of_minstrels`。
- en: 'It also has two methods: one, `sing`, is a method of minstrel instances and
    sings a little song, and the other, `self.number_of_minstrels`, is a method of
    the `Minstrel` class and tells us how many minstrels we’ve created so far.'
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 它还有两个方法：一个是`sing`，是一个吟游诗人实例的方法，演唱一首小歌；另一个是`self.number_of_minstrels`，是`Minstrel`类的方法，告诉我们到目前为止我们创建了多少个吟游诗人。
- en: Let’s see them in action!
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看它们的实际应用吧！
- en: '[PRE71]'
  id: totrans-355
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: Voilà! We can create a new minstrel, call `Minstrel.number_of_minstrels` to
    see that we’ve created one, and then call our minstrel instance (`wherefore`)’s
    `sing` method to hear his ballad “A Tail of Two Foxes.”
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 看！我们可以创建一个新的吟游诗人，调用`Minstrel.number_of_minstrels`查看我们创建了一个，然后调用我们的吟游诗人实例（`wherefore`）的`sing`方法，听他唱他的“狐狸的故事”。
- en: Things are starting to get a bit suspenseful around here, so I’m gonna go grab
    a bag of popcorn—be right with you. In the meantime, go on ahead to see what the
    King, Scarlet, and Ruben find when they get back to the castle, and get ready
    for even more object-oriented Ruby magic!
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 事情开始变得有些悬疑了，所以我要去拿一包爆米花—马上回来。与此同时，去看看国王、Scarlet和Ruben回到城堡后会发现什么，并准备好迎接更多面向对象的Ruby魔法！
