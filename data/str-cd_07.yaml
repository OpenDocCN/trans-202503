- en: '5'
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '5'
- en: SNOBOL
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: SNOBOL
- en: '![Image](Images/common01.jpg)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Images/common01.jpg)'
- en: SNOBOL is a text pattern matching language developed in the 1960s. Modern programmers
    might find its syntax quaint, and maybe even a tad frustrating, but I suspect
    the power of the language will shine through in the end as we explore its features,
    some of which are still with us in modern languages like Python.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: SNOBOL 是一种文本模式匹配语言，开发于 1960 年代。现代程序员可能会觉得它的语法有些过时，甚至可能略感沮丧，但我怀疑随着我们探索其特性，语言的强大力量最终会展现出来，其中一些特性至今仍出现在现代语言中，如
    Python。
- en: SNOBOL, like Forth, is a denizen of the later Paleozoic. SNOBOL and Forth are
    of similar vintage, but they are extremely different. Forth is minimal and low
    level. SNOBOL is abstract and surprisingly powerful, though quirky.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: SNOBOL，像 Forth 一样，是晚期古生代的产物。SNOBOL 和 Forth 同样属于同一时代，但它们非常不同。Forth 是极简的低级语言，而
    SNOBOL 是抽象的，且出奇地强大，尽管有些怪异。
- en: 'In this chapter, we’ll explore SNOBOL, specifically SNOBOL4, the latest dialect
    of the language. SNOBOL is known for its pattern matching and string processing
    abilities, but it is a general-purpose language. As we’ll see, SNOBOL’s data handling
    facilities are surprisingly sophisticated and include an atypical level of flexibility.
    As Michael Shafto put it in 1982, “SNOBOL4 is the Alice’s Restaurant of programming
    languages: you can get anything you want” (see “Artificial Intelligence Programming
    in SNOBOL4,” available on this book’s GitHub site).'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将探讨 SNOBOL，特别是 SNOBOL4，这是该语言的最新方言。SNOBOL 以其模式匹配和字符串处理能力而闻名，但它也是一种通用语言。正如我们将看到的，SNOBOL
    的数据处理功能出奇地复杂，且具有非同寻常的灵活性。正如迈克尔·沙夫托在 1982 年所说：“SNOBOL4 是编程语言中的 Alice's Restaurant：你想要的任何东西都可以得到”（参见《SNOBOL4
    中的人工智能编程》，该书的 GitHub 网站上可用）。
- en: Let’s explore SNOBOL by reviewing the structure of the language and the interesting
    abilities it provides. We’ll walk through its features, look at examples, and
    finish by building a simple machine learning classifier to link our explorations
    with the hopes of at least some computer scientists from the 1980s. As before,
    we’ll end with some closing thoughts.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过回顾语言的结构和它所提供的有趣能力来探索 SNOBOL。我们将逐步介绍其特性，查看示例，最后通过构建一个简单的机器学习分类器来将我们的探索与
    1980 年代的计算机科学家们的希望相连接。像以前一样，我们将以一些总结性思考结束。
- en: '**Installation**'
  id: totrans-7
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**安装**'
- en: 'To install SNOBOL, download it from *[http://ftp.ultimate.com/snobol4/](http://ftp.ultimate.com/snobol4/)*
    by grabbing *snobol4-2.3.1.tar.gz*, or any later version you see on that site.
    Save the file in a subdirectory called *SNOBOL*. Once you have the file, expand
    it and build the SNOBOL executable as follows:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 要安装 SNOBOL，请从 *[http://ftp.ultimate.com/snobol4/](http://ftp.ultimate.com/snobol4/)*
    下载 *snobol4-2.3.1.tar.gz*，或者从该网站上下载任何更新的版本。将文件保存在名为 *SNOBOL* 的子目录中。下载文件后，解压并按照以下步骤构建
    SNOBOL 可执行文件：
- en: '[PRE0]'
  id: totrans-9
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The commands above generate a lot of output. Some are from the C compiler, including
    a few warnings we can safely ignore. The rest are from SNOBOL test scripts. When
    all is said and done, if you see a message about sending timing info to `timing@snobol4.org`,
    you’ll know that SNOBOL was successfully built and is running correctly.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 上述命令会生成大量输出。其中一些来自 C 编译器，包括一些我们可以安全忽略的警告。其余的来自 SNOBOL 测试脚本。最终，如果你看到一条关于将时间信息发送到
    `timing@snobol4.org` 的消息，就意味着 SNOBOL 已成功构建并且运行正常。
- en: '**Origins and Philosophy**'
  id: totrans-11
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**起源与哲学**'
- en: SNOBOL (“StriNg Oriented and symBOlic Language”) was developed during the 1960s
    at AT&T Bell Laboratories by David Farber, Ralph Griswold, and Ivan Polonsky.
    The name *SNOBOL* is a backronym, meaning the developers began with the acronym
    they wanted and worked backward to ensure they got it.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: SNOBOL（“StriNg Oriented and symBOlic Language”）是由大卫·法伯、拉尔夫·格里斯沃尔德和伊万·波隆斯基在 1960
    年代于 AT&T 贝尔实验室开发的。*SNOBOL* 这个名字是一个回文首字母缩略词，意味着开发人员从他们想要的首字母缩略词开始，然后倒推确保达成目标。
- en: According to Farber, the original name for the language was “Symbolic EXpression
    Interpreter,” or SEXI. In the 1960s, running a computer program meant walking
    to the machine room with a stack of punch cards. Typically, the program name and
    username were marked on the deck. So Farber handed the young woman running the
    programs a stack labeled “SEXI Farber.” She read the name and laughingly said,
    “That’s what you think.” Clearly, a new name was needed. After much frustration,
    someone complained that they didn’t have a snowball’s chance in hell of coming
    up with a name; thus “SNOBOL” was born. The spelling pays homage to other similarly
    named languages of the time like COBOL and ALGOL. (Farber posted this story to
    his Interesting-People mailing list in December 2008.)
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 根据 Farber 的说法，这种语言的最初名字是“符号表达式解释器”（Symbolic EXpression Interpreter），简称 SEXI。在
    1960 年代，运行一个计算机程序意味着带着一堆打孔卡走到机器房。通常，程序名称和用户名会标记在卡片组上。所以 Farber 把一堆标有“SEXI Farber”的卡片交给了那个年轻的女性程序员，她读了这个名字后，笑着说：“你是这么想的。”显然，需要一个新名字。在经历了很多挫折之后，有人抱怨他们根本不可能想到一个名字；于是“SNOBOL”就诞生了。这个拼写方式向当时其他类似命名的语言如
    COBOL 和 ALGOL 致敬。（Farber 于 2008 年 12 月在他的 Interesting-People 邮件列表中发布了这个故事。）
- en: SNOBOL’s claim to fame is its powerful pattern-matching abilities. Current programming
    languages often rely on regular expressions, which have a separate history from
    SNOBOL, but SNOBOL’s matching skills were perfectly suited to the sort of highly
    structured data processing that was the focus of most computer mainframe use at
    the time. We’ll explore pattern matching throughout the chapter.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: SNOBOL 的名声来自于其强大的模式匹配能力。当前的编程语言通常依赖于正则表达式，这与 SNOBOL 有着不同的历史背景，但 SNOBOL 的匹配技能非常适合当时计算机主机使用中处理高度结构化数据的需求。我们将在本章中探讨模式匹配。
- en: SNOBOL’s philosophy might best be summed up as “all the world’s a string.” Strings
    are almost everything in SNOBOL. Data in the 1960s was typically textual, like
    records with fixed sizes and fields. SNOBOL’s pattern matching made processing
    such data (relatively) straightforward.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: SNOBOL 的哲学可以用一句话总结：“整个世界都是一个字符串。”字符串几乎是 SNOBOL 中的一切。1960 年代的数据通常是文本型的，比如具有固定大小和字段的记录。SNOBOL
    的模式匹配使得处理这类数据（相对而言）变得简单。
- en: Even though SNOBOL manipulated structured text data, it did not itself make
    use of structured programming. Thus, there are no `for` or `while` loops in SNOBOL.
    For that matter, SNOBOL lacks even basic `if-then` constructs. The only way to
    control program flow is by using what amounts to a `goto` statement. However,
    in SNOBOL, gotos are rather flexible. One of SNOBOL’s unique concepts is that
    every line of code either succeeds or fails and where the program goes next depends
    on that fact. We’ll see this in action as we work through the examples. In SNOBOL,
    failure is definitely an option. In fact, it’s a requirement.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管 SNOBOL 操作的是结构化的文本数据，但它本身并没有使用结构化编程。因此，SNOBOL 中没有 `for` 或 `while` 循环。更进一步，SNOBOL
    甚至没有基本的 `if-then` 结构。控制程序流的唯一方法是使用类似 `goto` 的语句。然而，在 SNOBOL 中，`goto` 语句非常灵活。SNOBOL
    的一个独特概念是，每行代码要么成功，要么失败，程序接下来会去哪里取决于这一点。我们将在接下来的示例中看到这一点。在 SNOBOL 中，失败绝对是一个选项。事实上，它是一个必要条件。
- en: SNOBOL is dynamically typed and able to create new variables and data structures
    on the fly. SNOBOL can even create new code on the fly, though we won’t be so
    ambitious here. SNOBOL supports powerful arrays and tables, the latter of which
    are much like Python dictionaries. User-defined data structures are also available.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: SNOBOL 是动态类型的，能够即时创建新变量和数据结构。SNOBOL 甚至可以即时创建新代码，尽管我们在这里不会如此雄心勃勃。SNOBOL 支持强大的数组和表格，后者与
    Python 字典类似。也可以使用用户定义的数据结构。
- en: The best way to learn SNOBOL is to use SNOBOL. It really must be seen to be
    believed. So without further ado, let’s take a walk in the snow.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 学习 SNOBOL 最好的方法就是使用 SNOBOL。你真得亲眼看过才会相信。所以，不再拖延，让我们走进这场雪中漫步吧。
- en: '**The Language**'
  id: totrans-19
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**语言**'
- en: We’ll begin by learning how to get SNOBOL to do basic things like print “Hello,
    world!” Once we’ve figured that out, we’ll move to variables and user-defined
    data types. Next come arrays and tables, SNOBOL’s intrinsic data structures. Patterns
    follow, though some pattern use will already have snuck in. Patterns are the traditional
    reason for using SNOBOL, and are perhaps the one part of the language that best
    distinguishes it from most other languages.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从学习如何让SNOBOL做一些基本的事情开始，例如打印“Hello, world!” 一旦我们弄明白这一点，我们将继续学习变量和用户定义的数据类型。接下来是数组和表格，这是SNOBOL的内建数据结构。然后是模式，尽管一些模式的使用可能已经悄悄出现在之前的内容中。模式是使用SNOBOL的传统原因，或许也是最能将SNOBOL与大多数其他语言区分开的语言特性。
- en: SNOBOL allows user-defined functions. We’ll see how to define them and learn
    why the process is, to be blunt, ugly. Then we’ll close with disk files and command
    line arguments. We’ll learn how to control a SNOBOL program’s flow as we work
    through the examples, as that’s the best way to learn it. All the files mentioned
    in the following sections are in the *examples* directory under *SNOBOL*.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: SNOBOL允许用户定义函数。我们将看到如何定义它们，并学习为什么这个过程，直言不讳地说，非常繁琐。然后我们将结束于磁盘文件和命令行参数的学习。通过操作示例，我们将学会如何控制SNOBOL程序的流程，因为这是学习它的最佳方式。以下章节中提到的所有文件都位于*examples*目录下的*SNOBOL*文件夹中。
- en: '***Running SNOBOL***'
  id: totrans-22
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***运行SNOBOL***'
- en: SNOBOL runs interactively if started without a filename. This mode is available
    for quick calculations and testing ideas, but SNOBOL was meant to run code from
    a file or, originally, a stack of punch cards.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 如果没有提供文件名启动，SNOBOL将以交互模式运行。此模式适用于快速计算和测试想法，但SNOBOL本应从文件中运行代码，或最初是从打孔卡堆栈中运行代码。
- en: '[Listing 5-1](ch05.xhtml#ch05list1) gets us started with *hello.sno*.'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 5-1](ch05.xhtml#ch05list1)为我们展示了如何开始使用*hello.sno*。'
- en: '[PRE1]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '*Listing 5-1: A SNOBOL greeting*'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: '*示例 5-1：一个SNOBOL问候程序*'
- en: This short program already has much to say about SNOBOL. First, comment lines
    begin with an asterisk (`*`). However, unlike in other languages, the asterisk
    *must* be in column 1\. Either the entire line is a comment, or none of it is.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 这个简短的程序已经向我们介绍了SNOBOL。首先，注释行以星号（`*`）开始。然而，与其他语言不同，星号*必须*位于第1列。整个行要么是注释，要么都不是注释。
- en: To print something in SNOBOL, we assign it to the special variable `output`.
    SNOBOL is not case sensitive, so `output` and `OUTPUT` are treated the same. The
    thing assigned to `output` is a string or something SNOBOL will implicitly convert
    into a string, like a number.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 在SNOBOL中打印内容，我们将其赋值给特殊变量`output`。SNOBOL不区分大小写，因此`output`和`OUTPUT`是等同的。赋给`output`的内容是一个字符串，或者是SNOBOL会隐式转换成字符串的内容，如数字。
- en: Concatenation is such a common operation in SNOBOL that space is used as the
    operator. So the first `output` statement in [Listing 5-1](ch05.xhtml#ch05list1)
    assigns a string enclosed in single quotes while the second concatenates two strings
    together. Note the use of double quotes. Like Python, SNOBOL allows both kinds.
    As you can see from the next line, SNOBOL implicitly converts numbers, which may
    be integers or floating point, into strings. Lastly, to output a blank line, assign
    nothing. Assigning nothing is also the SNOBOL way of removing things from a string.
    We’ll see that in action when using patterns.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 字符串连接是SNOBOL中非常常见的操作，因此空格被用作运算符。因此，[示例 5-1](ch05.xhtml#ch05list1)中的第一个`output`语句分配了一个用单引号括起来的字符串，而第二个则将两个字符串连接在一起。请注意双引号的使用。像Python一样，SNOBOL允许两种类型的引号。正如从下一行可以看到的，SNOBOL会隐式地将数字（无论是整数还是浮点数）转换为字符串。最后，要输出一个空行，只需赋值为空。赋值为空也是SNOBOL移除字符串中内容的方式。我们将在使用模式时看到这一点。
- en: All SNOBOL programs end with `end`. Note that `end` is in column 1 and all the
    `output` statements are indented. SNOBOL doesn’t care how far statements are indented,
    only that they don’t begin in column 1\. The only things allowed in column 1 are
    `*` for comments, `+` for line continuation (which is seldom used now), and labels,
    including `end`.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 所有SNOBOL程序都以`end`结尾。请注意，`end`位于第1列，所有的`output`语句都需要缩进。SNOBOL不关心语句缩进的多少，只要语句不在第1列开始即可。第1列仅允许包含`*`用于注释，`+`用于行续接（现在很少使用）和标签，包括`end`。
- en: You can run *hello.sno* like you’d run a Python script.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以像运行Python脚本一样运行*hello.sno*。
- en: '[PRE2]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'This should give you the following output:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 这应该会给你以下输出：
- en: '[PRE3]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The output of [Listing 5-1](ch05.xhtml#ch05list1) implies that SNOBOL always
    prints the string assigned to `output` on a line. There is no easy way to output
    a partial line followed by more text before ending the line. SNOBOL is line oriented,
    both for output and input. Thus, it is up to the programmer to build the entire
    line first before assigning it to `output`.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: '[清单 5-1](ch05.xhtml#ch05list1)的输出表明，SNOBOL总是打印分配给`output`的字符串。没有简单的方法可以在一行上输出部分内容，然后在结束行之前继续输出更多文本。SNOBOL是基于行的，无论是输出还是输入。因此，程序员必须先构建完整的行，然后将其赋值给`output`。'
- en: Now run [Listing 5-2](ch05.xhtml#ch05list2), *hello2.sno*.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 现在运行[清单 5-2](ch05.xhtml#ch05list2)，*hello2.sno*。
- en: '[PRE4]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '*Listing 5-2: Hello, hello, hello*'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 5-2：你好，你好，你好*'
- en: When you get bored, use CTRL-C to interrupt the program. This is our first SNOBOL
    loop. In SNOBOL, every line has the opportunity to execute a goto. The first part
    of the line, in column 1, is a label, `loop`. Labels are the targets SNOBOL uses
    when the goto portion of a line is executed. Labels, and other identifiers, must
    start with a letter. After that, letters, numbers, and underscores are allowed.
    Note that labels are global. That is, they must be unique across the entire program.
    Also, SNOBOL lines get rather lengthy and full of spaces, so we’ll remove extra
    spaces present in the source code files to save space in the text.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 当你感到无聊时，使用CTRL-C中断程序。这是我们的第一个SNOBOL循环。在SNOBOL中，每一行都有机会执行一个goto。行的第一部分，在第一列，是一个标签`loop`。标签是SNOBOL在执行行的goto部分时使用的目标。标签和其他标识符必须以字母开头。之后，可以使用字母、数字和下划线。请注意，标签是全局的。也就是说，它们必须在整个程序中唯一。此外，SNOBOL行通常较长且包含许多空格，因此我们会去掉源代码文件中的多余空格，以节省文本中的空间。
- en: The goto portion of a SNOBOL line comes at the end. The number of spaces before
    the goto can vary, but no code comes after the goto. The colon (`:`) begins the
    goto. Target labels are enclosed in parentheses. We’ll encounter more sophisticated
    gotos as we proceed. Note that if there is no goto, control proceeds to the next
    line of code as in most programming languages.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: SNOBOL行中的goto部分位于行尾。goto前面的空格数量可以变化，但goto后面没有其他代码。冒号（`:`）开始goto。目标标签被括号括起来。随着我们继续前进，我们会遇到更复杂的goto语句。请注意，如果没有goto，控制将按照大多数编程语言的方式继续执行下一行代码。
- en: One more item is worth noting here. The goto in [Listing 5-2](ch05.xhtml#ch05list2)
    always executes whether the line succeeds or fails. Granted, this line will never
    fail, but we’ll see other lines that do and that indeed must fail. It’s part of
    how the language works. Forgetting to distinguish between success and failure
    and using a goto that always executes can lead to strange behavior. Of course,
    the potential dangers of `goto` statements are well known—see Edsger Dijkstra’s
    famous 1968 paper “Go To Statement Considered Harmful” (*[https://homepages.cwi.nl/~storm/teaching/reader/Dijkstra68.pdf](https://homepages.cwi.nl/~storm/teaching/reader/Dijkstra68.pdf)*).
    However, with SNOBOL, it’s all we have to work with.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 这里还有一点值得注意。在[清单 5-2](ch05.xhtml#ch05list2)中，goto无论行是否成功都会执行。虽然这行代码永远不会失败，但我们会看到其他会失败并且必须失败的行。这是语言工作方式的一部分。如果忘记区分成功与失败，并使用一个始终执行的goto，可能会导致奇怪的行为。当然，`goto`语句的潜在危险早已为人们所熟知——参见Edsger
    Dijkstra 1968年发表的著名论文《Go To语句被认为有害》（*[https://homepages.cwi.nl/~storm/teaching/reader/Dijkstra68.pdf](https://homepages.cwi.nl/~storm/teaching/reader/Dijkstra68.pdf)*）。然而，在SNOBOL中，这是我们唯一能使用的工具。
- en: '[Listing 5-3](ch05.xhtml#ch05list3) introduces a few new SNOBOL concepts.'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: '[清单 5-3](ch05.xhtml#ch05list3)引入了一些新的SNOBOL概念。'
- en: '[PRE5]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '*Listing 5-3: A bit of interaction*'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 5-3：一点交互*'
- en: The first new concept is showing how to get input from the keyboard by referencing
    `input`; it returns a string that is assigned to the variable `name`. Notice that
    the variable `name` was not declared. Like Python, SNOBOL is dynamically typed,
    meaning that variables are created on demand and can hold whatever data is assigned
    to them.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个新概念是如何通过引用`input`从键盘获取输入；它返回一个字符串并将其赋值给变量`name`。请注意，变量`name`并没有声明。像Python一样，SNOBOL是动态类型的，这意味着变量是在需要时创建的，并可以存储任何被赋值的数据。
- en: The next line needs parsing. It’s an assignment to `output`, so it will ultimately
    print something on the screen. We see a constant string followed by `name`. There
    is space between them, so we expect the two to become a string using the name
    entered by the user. But what’s this `differ` thing? And the goto section is new,
    too.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 下一行需要解析。这是对`output`的赋值，因此它最终会在屏幕上打印某些内容。我们看到一个常量字符串，后面跟着`name`。它们之间有空格，所以我们预计这两个将结合成一个字符串，使用用户输入的名称。但这个`differ`是什么？goto部分也很新颖。
- en: Let’s start with the goto. It’s `:f(again)`. The colon begins the goto. The
    `f` stands for failure. If the line fails, goto `again`, the line that asks for
    the user’s name. Okay, this seems reasonable; if the user’s input isn’t valid,
    ask again.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从goto开始。它是`:f(again)`。冒号表示开始一个goto。`f`代表失败。如果这一行失败，程序跳转到`again`，也就是请求用户输入名字的那一行。好吧，这看起来很合理；如果用户的输入无效，就再问一次。
- en: 'Now for the `differ` part: `differ` is a SNOBOL predicate. Like all predicates,
    its purpose is to determine whether something is true or false. However, unlike
    in any other programming language I’ve ever encountered, SNOBOL predicates don’t
    return true or false. If the predicate is false, the function *fails*, and if
    any portion of a SNOBOL line fails, the entire line fails. If a line fails and
    there is a goto for a failure condition, that goto is then executed. So if `differ`
    fails, the line fails, and flow continues with the line labeled `again`.'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 现在来看`differ`部分：`differ`是一个SNOBOL谓词。像所有谓词一样，它的目的是确定某事是否为真或假。然而，不像我遇到过的任何其他编程语言，SNOBOL谓词不会返回真或假。如果谓词为假，函数*失败*，而如果SNOBOL中的任何一行失败，则整行都会失败。如果一行失败并且有goto语句处理失败条件，则会执行该goto。所以如果`differ`失败，这一行就会失败，程序流会继续到标记为`again`的行。
- en: Truth in SNOBOL is the null string. I’m sure there’s a deep, philosophical implication
    to truth being null and empty, but we’ll stick with computer programming and avoid
    the headache. SNOBOL predicates that are true return the null string. So `differ`
    takes two objects and asks if they are not the same. Here the objects are whatever
    was assigned to `name` and SNOBOL’s constant for an empty string, `null`.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 在SNOBOL中，真值是空字符串。我相信，真值为空和空的深刻哲学含义肯定有很多，但我们还是专注于计算机编程，避免头痛。SNOBOL中为真的谓词返回空字符串。所以，`differ`接受两个对象并检查它们是否不同。在这里，两个对象是分配给`name`的内容和SNOBOL表示空字符串的常量`null`。
- en: 'This line, then, is checking to see if the user pressed ENTER without typing
    anything. If so, `differ` fails and program flow returns to `again`. If the user
    enters some text, `differ` succeeds and returns the empty string, which, because
    it’s separated from the string constant by a space, is concatenated with the string
    and the name. Concatenating a null string doesn’t change anything. It’s like adding
    zero. So the line succeeds and `output` is assigned. The trick of using a predicate
    that concatenates a null string to a line is a common one in SNOBOL. However,
    the predicate doesn’t need to be used that way; it can be on a line by itself.
    For example, the following code works just as well:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 这一行是在检查用户是否按下了ENTER键而没有输入任何内容。如果是这样，`differ`失败，程序流将返回到`again`。如果用户输入了一些文本，`differ`成功并返回空字符串，因为空字符串与常量字符串之间有一个空格，所以会与字符串和名称连接起来。连接一个空字符串不会改变任何东西，就像加零一样。因此，这一行成功，`output`被赋值。使用一个将空字符串连接到一行的谓词是SNOBOL中常见的技巧。然而，谓词不一定非要以这种方式使用，它也可以单独出现在一行中。例如，以下代码同样有效：
- en: '[PRE6]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: If the `differ` is false, it fails, and the loop happens. If `differ` is true,
    the null string has no effect and the `output` proceeds.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`differ`为假，它会失败，循环会发生。如果`differ`为真，空字符串不会产生任何影响，`output`会继续。
- en: We have figured out how to print strings and get user input and store it in
    a variable. We were also introduced to the overall structure of a SNOBOL program
    and learned a bit about gotos. Let’s continue our exploration by concentrating
    on variables and data types.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经弄清楚了如何打印字符串，获取用户输入并将其存储在变量中。我们还了解了SNOBOL程序的整体结构，并学习了一些关于goto的知识。让我们继续探索，集中关注变量和数据类型。
- en: '***Variables and Data Types***'
  id: totrans-54
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***变量和数据类型***'
- en: As we’ve already seen, SNOBOL variables are created on demand and can hold any
    value. Strings, integers, and floats are SNOBOL’s primitive data types. In this
    section, we’ll work with these primitives and then go beyond them to create custom
    data types. This is the SNOBOL equivalent of structures in other languages like
    C.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们已经看到的，SNOBOL变量是按需创建的，可以保存任何值。字符串、整数和浮点数是SNOBOL的基本数据类型。在这一部分，我们将使用这些基本数据类型，然后进一步创建自定义数据类型。这是SNOBOL中类似于其他语言（如C语言）结构体的概念。
- en: '**Integers and Floats**'
  id: totrans-56
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**整数和浮点数**'
- en: '[Listing 5-4](ch05.xhtml#ch05list4) presents *temperature.sno*, a simple menu-driven
    program to convert between Fahrenheit and Celsius temperatures.'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: '[列出5-4](ch05.xhtml#ch05list4)展示了*temperature.sno*，这是一个简单的菜单驱动程序，用于在华氏温度和摄氏温度之间进行转换。'
- en: '[PRE7]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '*Listing 5-4: Temperature conversion*'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: '*列出5-4：温度转换*'
- en: The menu asks for the type of conversion or `q` to quit. The variable `menu`
    holds the user’s selection. Next comes a new predicate, `ident`. As you likely
    surmised from the name, `ident` is the opposite of `differ`; it’s true when the
    arguments are identical. Notice that `menu` is compared to the string constant
    `'2'` and not just 2\. This is one place where SNOBOL’s permissive automatic string
    conversion is not applied. The value returned by `input` is always a string, so
    we must use a string with `ident`. If we did use 2 and not `'2'`, there would
    be no error, but the predicate would fail, and because there is no fail goto defined,
    SNOBOL would proceed to the next line instead.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 菜单会询问转换类型或输入 `q` 退出。变量 `menu` 保存用户的选择。接下来是一个新的谓词 `ident`。正如你从名字中可能推测的那样，`ident`
    是 `differ` 的反义词；当参数相同时它为真。注意，`menu` 是与字符串常量 `'2'` 进行比较，而不仅仅是 2。这是 SNOBOL 的一种地方性特性，不应用
    SNOBOL 的自动字符串转换。`input` 返回的值始终是一个字符串，因此我们必须在 `ident` 中使用字符串。如果我们使用 2 而不是 `'2'`，不会报错，但谓词会失败，因为没有定义失败的
    goto，SNOBOL 将继续执行下一行。
- en: The `ident` line shows us a new form of goto, `:s(CtoF)`. The `s` means success,
    and tells SNOBOL where to go if the line does not fail. In this case, not failing
    means the user selected option two. Thus, the program jumps to the label `CtoF`
    to convert Celsius to Fahrenheit. Likewise, the following line jumps to the end
    if the user entered a `q`. If the user entered neither `2` nor `q`, execution
    falls through to the code marked `F to C`.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: '`ident` 行展示了一个新的 goto 形式，`:s(CtoF)`。`s` 表示成功，告诉 SNOBOL 如果该行没有失败则跳转到哪里。在这种情况下，不失败意味着用户选择了选项二。因此，程序跳转到标签
    `CtoF` 进行摄氏度转华氏度的转换。同样，接下来的行如果用户输入了 `q`，则跳转到末尾。如果用户既没有输入 `2` 也没有输入 `q`，执行将继续到标记为
    `F to C` 的代码。'
- en: The conversions ask the user for a temperature, perform the proper conversion,
    report the result, and then jump back to `menu`. The conversions also do something
    subtle behind the scenes. The requested temperature is assigned to either `F`
    or `C`, which are then used in the conversion equation. In this case, SNOBOL does
    automatically convert the input to a number. Unless the user explicitly enters
    a decimal point or uses scientific notation, the resulting number is an integer;
    otherwise, it’s a float. This means the programmer is responsible for ensuring
    that expressions perform the proper conversion as to type. To make the input an
    integer, multiply by 1\. To make the input a float, multiply by 1.0 or use the
    `convert` function, which shows up later in this chapter.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 转换程序会要求用户输入一个温度，进行相应的转换，报告结果，然后跳转回 `menu`。转换背后还做了一些细微的工作。请求的温度被赋值给 `F` 或 `C`，然后用于转换公式。在这种情况下，SNOBOL
    会自动将输入转换为数字。除非用户明确输入小数点或使用科学计数法，否则结果是一个整数；否则，它就是一个浮点数。这意味着程序员有责任确保表达式执行正确的类型转换。为了将输入转换为整数，可以乘以
    1。为了将输入转换为浮点数，可以乘以 1.0 或使用后面本章会提到的 `convert` 函数。
- en: There is more to notice in [Listing 5-4](ch05.xhtml#ch05list4). Look carefully
    at how we’ve written the conversion formulas. First, we use decimal points to
    force floating-point computation. Without them, the division operation would use
    integer math, though the expected promotion from integer to float happens if there
    is a float in the expression. However, be careful because each subexpression needs
    a float as well. In that case, `(9 / 5) * 100.0 + 32.0` would be `132` rather
    than `212` because the fraction is pure integer math returning 1 instead of 1.8.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 在[清单 5-4](ch05.xhtml#ch05list4)中有更多需要注意的地方。仔细观察我们编写的转换公式。首先，我们使用小数点来强制进行浮点数计算。如果没有小数点，除法操作将使用整数数学，尽管如果表达式中有浮点数，整数到浮点数的提升会发生。然而，要小心，因为每个子表达式也需要一个浮点数。在这种情况下，`(9
    / 5) * 100.0 + 32.0` 将会是 `132` 而不是 `212`，因为分数是纯整数数学，返回 1 而不是 1.8。
- en: Notice that there are spaces around each of the operators in the conversions.
    These are not just for readability; SNOBOL requires them. Forgetting a space before
    or after an operator is an error, as SNOBOL will happily point out to you. Lastly,
    SNOBOL lacks the format specifiers found in languages like C and Python. SNOBOL
    expects the programmer to convert the number to a string with appropriate spacing
    and justification to format output. You’re on your own when formatting output
    in SNOBOL.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，转换中的每个运算符周围都有空格。这不仅仅是为了提高可读性；SNOBOL 需要这些空格。如果忘记在运算符前后加上空格，将会出错，SNOBOL 会很高兴地指出这一点。最后，SNOBOL
    缺乏像 C 和 Python 语言中那样的格式说明符。SNOBOL 期望程序员将数字转换为带有适当间距和对齐的字符串，以格式化输出。在 SNOBOL 中格式化输出时，你将完全依赖自己的能力。
- en: '[Listing 5-4](ch05.xhtml#ch05list4) implemented a simple menu by checking the
    user’s input with `ident`. SNOBOL also allows *computed gotos*. A computed goto
    uses an expression to determine the target label. [Listing 5-5](ch05.xhtml#ch05list5)
    shows *menu.sno*, which implements a simple menu with a computed goto.'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: '[列表 5-4](ch05.xhtml#ch05list4)通过使用`ident`检查用户输入实现了一个简单的菜单。SNOBOL还支持*计算的goto*。计算的goto使用一个表达式来确定目标标签。[列表
    5-5](ch05.xhtml#ch05list5)展示了*menu.sno*，它实现了一个带有计算goto的简单菜单。'
- en: '[PRE8]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '*Listing 5-5: Using a computed goto*'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 5-5：使用计算的goto*'
- en: 'The menu loop asks the user to select an entrée, then outputs the name of the
    selected entrée. Not a particularly useful program, but it does have one interesting
    feature: `($(''menu'' menu))`.'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 菜单循环会询问用户选择主菜，然后输出所选主菜的名称。这个程序并不特别有用，但它确实有一个有趣的特性：`($('menu' menu))`。
- en: The label matching the string formed by the expression inside `$(...)` is the
    goto’s target. The `$(...)` syntax is a form of indirection that tells SNOBOL
    to build the target label on the fly using the expression inside the parentheses.
    The expression is `'menu' menu`, which concatenates the word *menu* with the user’s
    number. Naturally, an actual application would validate the user’s input first.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 与`$(...)`内表达式匹配的标签是goto语句的目标。`$(...)`语法是一种间接引用，告诉SNOBOL动态地构建目标标签，使用括号内的表达式。表达式是`'menu'
    menu`，它将单词*menu*与用户输入的数字连接起来。当然，实际应用中首先需要验证用户的输入。
- en: Jumping to the proper label updates `order` and the desired entrée is displayed
    before jumping back to `loop`. If the user selects option four, the program jumps
    to label `menu4`, which falls through to `end` to exit the program.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 跳转到正确的标签更新`order`，并显示所需的主菜，之后跳回到`loop`。如果用户选择了选项四，程序会跳转到标签`menu4`，然后继续执行到`end`标签以退出程序。
- en: '**Indirection**'
  id: totrans-71
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**间接引用**'
- en: Consider the following sequence of SNOBOL instructions from an interactive session.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 请参考以下一段来自交互式会话的SNOBOL指令序列。
- en: '[PRE9]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The first line assigns `123` to `a`. The second uses the *name operator* (`.`)
    to assign the name of `a` to `b`. In SNOBOL, the name of a variable is similar
    to the address of a variable in languages like C. The third line sets `c` to the
    string `'a'`. Then come a series of `output` statements.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 第一行将`123`赋值给`a`。第二行使用*名称操作符*（`.`）将`a`的名称赋值给`b`。在SNOBOL中，变量的名称类似于C语言等语言中变量的地址。第三行将`c`设置为字符串`'a'`。接下来是一系列的`output`语句。
- en: The first displays `a` returning `123`, as expected. The second outputs `b`,
    which returns the name of `a`, `A`. SNOBOL is case insensitive, so the name of
    a variable is shown in all caps. The third `output` prints the string `'a'`, again,
    as expected.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个输出`a`，返回`123`，符合预期。第二个输出`b`，返回`a`的名称`A`。SNOBOL是大小写不敏感的，因此变量的名称以大写显示。第三个`output`输出字符串`'a'`，再次符合预期。
- en: The last three `output` statements are more interesting. They all use indirect
    references (`$`) to output not the value of the variable, but the value of the
    variable whose name is in the first variable. The variable `b` was assigned to
    the name of `a`, meaning it is the string `'A'`. So the indirect reference looks
    to `b` to get the string `'A'` and then looks for a variable called `A`, finds
    it, and returns *its* value. So the output of `$b` is `123`, the value of `a`.
    Using a string with the variable name works as well, which is why the output of
    `$c` is also the value of `a`. Lastly, the name operator and indirect reference
    are inverses of each other, so `$.a` means “name of `a` indirectly referenced
    back to `a`,” resulting in the value of `a`.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 最后三个`output`语句更为有趣。它们都使用间接引用（`$`）输出的不是变量的值，而是第一个变量中名称所指向的变量的值。变量`b`被赋值为`a`的名称，这意味着它是字符串`'A'`。因此，间接引用会查找`b`，得到字符串`'A'`，然后寻找名为`A`的变量，找到后返回*它*的值。因此，`$b`的输出是`123`，即`a`的值。使用包含变量名的字符串同样有效，这就是为什么`$c`的输出也是`a`的值。最后，名称操作符和间接引用是互为逆运算的，因此`$.a`意味着“间接引用回`a`的`a`的名称”，最终得到`a`的值。
- en: '[Listing 5-6](ch05.xhtml#ch05list6) shows another indirection example, that
    of the file *indirect.sno*.'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: '[列表 5-6](ch05.xhtml#ch05list6)展示了另一个间接引用的例子，即文件*indirect.sno*。'
- en: '[PRE10]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '*Listing 5-6: Another indirection example*'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 5-6：另一个间接引用例子*'
- en: Take a look at the listing before reading further to see if you can guess what
    the output will be. Notice that the `output` statements use string concatenation
    to output two variables on one line with a single space between them. Read on
    when ready to see what SNOBOL says the output should be.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 在继续阅读之前，先看看清单，看看你能否猜到输出是什么。请注意，`output` 语句使用字符串连接将两个变量输出到同一行，并且它们之间有一个空格。当准备好时继续阅读，看看
    SNOBOL 会怎么说输出应该是什么。
- en: 'SNOBOL reports the following as the output of [Listing 5-6](ch05.xhtml#ch05list6):'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: SNOBOL 报告如下内容作为 [清单 5-6](ch05.xhtml#ch05list6) 的输出：
- en: '[PRE11]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The first line of [Listing 5-6](ch05.xhtml#ch05list6) shouldn’t be mysterious.
    It’s normal variable output; `cosa1` and `cosa2` are the literal strings `'thing1'`
    and `'thing2'`.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: '[清单 5-6](ch05.xhtml#ch05list6)的第一行不应是神秘的。它是正常的变量输出；`cosa1` 和 `cosa2` 是字面字符串
    `''thing1''` 和 `''thing2''`。'
- en: At first glance, the second output line is a bit of a surprise. The code assigns
    variables `thing1` and `thing2` to `output`, but those variables are not explicitly
    defined in the code. The lines that create them are
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 初看之下，第二行输出有些让人吃惊。代码将变量 `thing1` 和 `thing2` 赋值给 `output`，但这些变量在代码中并未显式定义。创建它们的代码行是
- en: '[PRE12]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: where the indirect reference is used to assign not to `cosa1` and `cosa2`, but
    to the variables created by the current value of `cosa1` and `cosa2`, which are
    `'thing1'` and `'thing2'`. Therefore, `thing1` equals `'mea1'` and `thing2` equals
    `'mea2'`.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，间接引用用来将值赋给的不是 `cosa1` 和 `cosa2`，而是由当前 `cosa1` 和 `cosa2` 的值创建的变量，即 `'thing1'`
    和 `'thing2'`。因此，`thing1` 等于 `'mea1'`，`thing2` 等于 `'mea2'`。
- en: The next pair of lines in [Listing 5-6](ch05.xhtml#ch05list6) are similar.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: '[清单 5-6](ch05.xhtml#ch05list6) 中的下一对行是类似的。'
- en: '[PRE13]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: To create two new variables, `mea1` and `mea2` assigned `'kitu1'` and `'kitu2'`,
    respectively. This explains why the third line of output is `kitu1 kitu2`. The
    indirect reference on `thing1`, containing `'mea1'`, returns the value of `mea1`,
    which is `'kitu1'`, and likewise for `thing2`. Because they were created by assigning
    to `$thing1` and `$thing2`, the next output line makes sense, too.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 创建两个新变量 `mea1` 和 `mea2`，分别赋值为 `'kitu1'` 和 `'kitu2'`。这也解释了为什么第三行输出是 `kitu1 kitu2`。对
    `thing1` 的间接引用包含 `'mea1'`，返回 `mea1` 的值，即 `'kitu1'`，同理 `thing2` 也是如此。因为它们是通过赋值给
    `$thing1` 和 `$thing2` 创建的，所以下一行输出也能解释得通。
- en: The final assignment uses indirection twice on `cosa1`. The first indirection,
    that is, the rightmost `$`, returns `thing1`. The second indirection on `thing1`
    returns `mea1`’s value, which is `'kitu1'`. The same is true for `$$cosa2`.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 最终的赋值操作对 `cosa1` 使用了两次间接引用。第一次间接引用，即最右侧的 `$`，返回 `thing1`。第二次对 `thing1` 的间接引用返回
    `mea1` 的值，即 `'kitu1'`。对 `$$cosa2` 也同理。
- en: SNOBOL’s indirection and dynamic creation of variables during runtime are quite
    powerful and equally confusing if not used carefully. For the curious, *cosa*
    means “thing” in Spanish. Likewise, *mea* is Hawaiian for “thing” and *kitu* is
    Swahili for, you guessed it, “thing.”
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: SNOBOL 在运行时的间接引用和动态变量创建功能非常强大，但如果使用不当也容易令人困惑。对于好奇的人，*cosa* 在西班牙语中是“事物”的意思。同样，*mea*
    在夏威夷语中是“事物”，*kitu* 在斯瓦希里语中是，没错，“事物”。
- en: '**User-Defined Data Types**'
  id: totrans-92
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**用户定义的数据类型**'
- en: User-defined data types are created with the function `data`, which accepts
    a *string* as its argument. The string defines the name of the new type and the
    names of the elements of the type. SNOBOL creates a function to generate new instances
    of the type and functions with the names of the type elements. The latter functions
    are used to access elements of the type when it is used.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 用户定义的数据类型是通过函数 `data` 创建的，该函数接受一个 *字符串* 作为参数。这个字符串定义了新类型的名称以及类型元素的名称。SNOBOL
    创建一个函数来生成该类型的新实例，并为类型元素创建函数。后者函数用于在使用该类型时访问元素。
- en: 'For example, consider the following instructions:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，考虑以下指令：
- en: '[PRE14]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'The first line defines a new data type, `complex`, which has two elements `real`
    and `imag`. We can use this data type to hold a complex number. A complex number
    has two parts: a real part and an imaginary part. The real part is a floating-point
    number corresponding to a number on the number line. The imaginary part is also
    a floating-point number which is multiplied, conceptually, by the square root
    of *–*1\. The square root of *–*1 doesn’t exist. No number multiplied by itself
    is negative, so it’s “imaginary.” Even though complex numbers don’t correspond
    to anything in the physical world, their properties are such that they make certain
    calculations vastly simpler. For our purposes, all we care about is that this
    new complex data type has two elements. Notice that the definition of `complex`
    is given as a string. Because of this, SNOBOL can create new data types on the
    fly at runtime, perhaps in response to user input or data read from a file. Also,
    and this is important, the data type string *must not* contain spaces. Thus, `''complex(real,imag)''`
    works, but `''complex(real, imag)''` generates an error.'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 第一行定义了一个新的数据类型 `complex`，它包含两个元素 `real` 和 `imag`。我们可以使用这个数据类型来表示复数。复数有两个部分：实部和虚部。实部是一个浮点数，对应于数轴上的一个数字。虚部也是一个浮点数，概念上是乘以
    *–*1 的平方根。*–*1 的平方根不存在。没有任何数字与自己相乘会是负数，因此它是“虚数”。尽管复数与物理世界中的任何事物不对应，但它们的性质使得某些计算变得极其简单。对我们来说，最关心的只是这个新的复数数据类型有两个元素。注意，`complex`
    的定义是以字符串形式给出的。由于这个原因，SNOBOL 可以在运行时动态创建新的数据类型，可能是响应用户输入或从文件读取的数据。此外，且非常重要的是，数据类型字符串*不能*包含空格。因此，`'complex(real,imag)'`
    可行，但 `'complex(real, imag)'` 会产生错误。
- en: After defining `complex`, we immediately create two instances of it, `a` and
    `b`. To create an instance, use the name of the data type and supply a value for
    all the elements. Next are four `output` statements, the first two of which use
    `a` and `b`. In this case, SNOBOL prints the name of the data type, `COMPLEX`.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 定义了 `complex` 之后，我们立即创建了两个实例，`a` 和 `b`。要创建一个实例，使用数据类型的名称，并为所有元素提供一个值。接下来是四个
    `output` 语句，其中前两个使用 `a` 和 `b`。在这种情况下，SNOBOL 打印了数据类型的名称，`COMPLEX`。
- en: The final two `output` statements use the `real` and `imag` functions SNOBOL
    created for us when `complex` was defined. We’ll learn how to create user-defined
    functions below. Here, SNOBOL does us a favor by making functions automatically.
    The functions return the respective elements of the `complex` variables passed
    to them. We’ll revisit the `complex` data type when we explore user-defined functions
    below.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 最后两个 `output` 语句使用了 SNOBOL 为我们创建的 `real` 和 `imag` 函数，这些函数是在定义 `complex` 时自动生成的。我们将在下面学习如何创建用户定义的函数。在这里，SNOBOL
    通过自动生成函数来为我们节省了很多麻烦。这些函数返回传递给它们的 `complex` 变量的相应元素。我们将在后面探索用户定义的函数时重新审视 `complex`
    数据类型。
- en: '***Arrays and Tables***'
  id: totrans-99
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***数组与表格***'
- en: SNOBOL supports multidimensional arrays with flexible indexing. Array elements
    are not typed and any data can be stored in an array element, including another
    array. This means SNOBOL supports nested arrays—arrays within arrays. Few languages
    have such flexibility with arrays.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: SNOBOL 支持具有灵活索引的多维数组。数组元素没有类型限制，任何数据都可以存储在数组元素中，包括另一个数组。这意味着 SNOBOL 支持嵌套数组——数组中的数组。很少有编程语言在数组方面具有如此的灵活性。
- en: SNOBOL also supports associative arrays—or, to use modern terminology, dictionaries—though
    in SNOBOL they are called *tables*, a collection of key-value pairs. Like arrays,
    tables are not restricted in terms of the data they contain. However, unlike arrays,
    tables are not fixed in size and may grow as needed to accommodate more entries.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: SNOBOL 也支持关联数组——或者用现代术语来说，支持字典——不过在 SNOBOL 中它们被称为*表格*，是键值对的集合。像数组一样，表格在存储的数据类型上没有限制。然而，与数组不同的是，表格的大小不是固定的，可以根据需要动态增长以容纳更多的条目。
- en: '**Arrays**'
  id: totrans-102
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**数组**'
- en: SNOBOL arrays are created with the `array` function. The function’s argument
    determines the number of dimensions, the range of the indices for each dimension,
    and a default value for each element. Let’s examine different arrays to understand
    how they are defined and accessed. There are many small examples, so each will
    be presented as a code snippet and the resulting value of the element accessed.
    Most of the examples are in *array.sno*.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: SNOBOL 数组是通过 `array` 函数创建的。该函数的参数决定了维度的数量、每个维度的索引范围以及每个元素的默认值。让我们通过不同的数组示例来理解它们是如何定义和访问的。有很多小示例，因此每个示例将以代码片段的形式展示，并展示访问的元素的结果值。大多数示例都在
    *array.sno* 文件中。
- en: 'The following declarations create different versions of the array `A`:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 以下声明创建了不同版本的数组 `A`：
- en: '[PRE15]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The first is a 1D array with 10 elements indexed from [1, 10]. Like FORTRAN,
    SNOBOL indexes arrays from 1 unless told otherwise. The second is also a 10-element
    vector with indices in [0, 9]. Notice that the array specification is a string.
    This is required to specify nonstandard index ranges. The third line defines a
    3D array. The indices of the first dimension are in [0, 7]. The second dimension
    uses the defaults, [1, 20]. Lastly, the third dimension uses *–*1, 0, and 1 as
    indices. The final line defines a 2D array with indices in [1, 128], specified
    as a string, with each element initialized to 0.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个是一个包含 10 个元素的 1D 数组，索引范围从 [1, 10]。与 FORTRAN 类似，SNOBOL 默认将数组索引从 1 开始，除非另有说明。第二个也是一个包含
    10 个元素的数组，索引范围为 [0, 9]。注意，数组的规格是一个字符串，这对于指定非标准的索引范围是必要的。第三行定义了一个 3D 数组。第一个维度的索引范围为
    [0, 7]，第二个维度使用默认值 [1, 20]。最后，第三个维度使用 *–*1、0 和 1 作为索引。最后一行定义了一个 2D 数组，索引范围为 [1,
    128]，它被指定为字符串格式，每个元素初始化为 0。
- en: SNOBOL manages memory independently, meaning that this sequence of array declarations
    is allowed as a sequence of SNOBOL statements. Each new array declaration destroys
    the previous, automatically freeing its memory. If you try allocating a large
    array and get the `Insufficient storage to continue` error, the `-d` command line
    option tells SNOBOL to reserve more memory.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: SNOBOL 独立管理内存，这意味着这一系列数组声明作为 SNOBOL 语句的序列是允许的。每个新的数组声明都会销毁前一个声明，自动释放其内存。如果尝试分配一个大数组并出现
    `Insufficient storage to continue` 错误，可以使用 `-d` 命令行选项来告诉 SNOBOL 保留更多内存。
- en: '[PRE16]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Here, the argument `10m` allocates 10MB worth of *descriptors*, each of which
    uses 16 bytes. On my system, `-d 300m` took about 15 seconds to initiate an interactive
    session and used about 4.8GB of system memory. The price paid for SNOBOL’s array
    flexibility is speed and memory use compared to standard fixed-data type arrays.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，参数 `10m` 分配了 10MB 的 *描述符*，每个描述符使用 16 字节。在我的系统上，`-d 300m` 大约花费了 15 秒来启动交互式会话，并使用了大约
    4.8GB 的系统内存。SNOBOL 数组的灵活性带来了速度和内存使用上的代价，相较于标准的固定数据类型数组。
- en: Let’s see a SNOBOL array in action ([Listing 5-7](ch05.xhtml#ch05list7)).
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看一个 SNOBOL 数组的实际应用 ([列表 5-7](ch05.xhtml#ch05list7))。
- en: '[PRE17]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: '*Listing 5-7: A 1D array*'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 5-7：一个 1D 数组*'
- en: '[Listing 5-7](ch05.xhtml#ch05list7) defines a 1D array of 10 elements with
    indices in [0, 9]. The next three lines assign the array’s elements, first to
    a string, then a float, and lastly, an integer. The next line assigns `A[3]` to
    an array of six elements with indices in [1, 6]. This is a nested array because
    it is part of the larger 10-element array, `A`. To assign elements of the nested
    array requires first selecting the nested array with `A[3]` and then selecting
    the desired element of the nested array, here the first: `A[3][1] = ''nested''`.'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: '[列表 5-7](ch05.xhtml#ch05list7) 定义了一个包含 10 个元素的 1D 数组，索引范围为 [0, 9]。接下来的三行将数组的元素依次赋值为字符串、浮点数和整数。接下来一行将
    `A[3]` 赋值为一个包含 6 个元素的数组，索引范围为 [1, 6]。这是一个嵌套数组，因为它是更大 10 元素数组 `A` 的一部分。要为嵌套数组赋值，首先需要通过
    `A[3]` 选择嵌套数组，然后选择嵌套数组中需要的元素，这里是第一个：`A[3][1] = ''nested''`。'
- en: The five `output` statements display the assigned values. There is something
    new here, the `convert` function, which changes a variable’s type. The `output`
    statement is concatenating a string with the value of the array element. However,
    `A[3]` is not something automatically converted into a string. Therefore, `convert`
    is used to represent it as a string. The first argument to `convert` is the object
    to be converted and the second argument is a string naming the target type, in
    this case a string. We’ll use `convert` again later to change between arrays and
    tables.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 五个 `output` 语句展示了被赋值的内容。这里有一个新概念，即 `convert` 函数，它用于改变变量的类型。`output` 语句将一个字符串与数组元素的值连接在一起。然而，`A[3]`
    并不是一个自动转换为字符串的内容。因此，使用 `convert` 将其表示为字符串。`convert` 的第一个参数是要转换的对象，第二个参数是一个字符串，指定目标类型，这里是字符串。稍后我们将再次使用
    `convert` 来在数组和表格之间转换。
- en: Now consider [Listing 5-8](ch05.xhtml#ch05list8).
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 现在请看一下 [列表 5-8](ch05.xhtml#ch05list8)。
- en: '[PRE18]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: '*Listing 5-8: A 2D array*'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 5-8：一个 2D 数组*'
- en: The array `B` is 2D with both indices in [1, 128] and all elements are initialized
    to 0\. Assignments follow using both indices. Note that SNOBOL has no limit on
    the number of dimensions an array may use. Element `B[12,45]` has been assigned
    a nested 11×11 array. The assignment to `B[12,45]<5,6>` seems unusual, but it
    isn’t. SNOBOL allows `<` and `>` in place of square brackets for indexing arrays.
    Consider them a relic of the 1960s.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 数组 `B` 是二维的，两个索引范围都在 [1, 128] 之间，所有元素都初始化为 0。随后通过两个索引进行赋值。请注意，SNOBOL 对数组维度没有限制。元素
    `B[12,45]` 被赋值为一个嵌套的 11×11 数组。赋值 `B[12,45]<5,6>` 看起来不寻常，但其实并不。SNOBOL 允许用 `<` 和
    `>` 来替代方括号进行数组索引。可以将它们视为 1960 年代的遗留物。
- en: The following two lines define the complex data type we saw above and then use
    it to store a complex number in `B[12,45][1,2]`. The `output` statement displays
    the complex number using the `real` and `imag` functions to extract the real and
    imaginary parts before piecing them together as `3+0.141592i`, which is the usual
    way imaginary numbers are displayed.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 以下两行定义了我们上面看到的复合数据类型，然后使用它来存储复数 `B[12,45][1,2]`。`output` 语句通过 `real` 和 `imag`
    函数提取实部和虚部，并将它们组合成 `3+0.141592i` 的形式，这也是虚数通常的显示方式。
- en: '**NOTE**'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*Some languages, like Python, use `j` in place of `i` to indicate a complex
    number. Engineers do this because `i` usually refers to electric current in their
    world. Mathematicians prefer `i` because electric current doesn’t exist in *their*
    world.*'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: '*一些语言，如 Python，使用 `j` 代替 `i` 来表示复数。工程师这样做是因为在他们的领域中，`i` 通常指的是电流。数学家更喜欢使用 `i`，因为在*他们*的世界里没有电流。*'
- en: Now consider [Listing 5-9](ch05.xhtml#ch05list9) with two blocks of code.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 现在考虑 [Listing 5-9](ch05.xhtml#ch05list9)，其中有两个代码块。
- en: '[PRE19]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: '*Listing 5-9: Array references and copying*'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: '*Listing 5-9: 数组引用与复制*'
- en: 'The first block defines `A` and sets `A[0]` to the string `''xyzzy''`. Next,
    it creates `D` by assigning `A`, after which it immediately sets `D[0]` to `12345`.
    The question is: what does the following `output` statement display? The answer
    is:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个代码块定义了 `A` 并将 `A[0]` 设置为字符串 `'xyzzy'`。接下来，它通过赋值 `A` 来创建 `D`，然后立即将 `D[0]`
    设置为 `12345`。问题是：接下来的 `output` 语句会显示什么？答案是：
- en: '[PRE20]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: This is because simple assignment of an array does not copy it; it only makes
    `D` refer to the same object as `A`. This behavior is typical of most programming
    languages. As arrays might occupy a significant portion of memory, it is best
    to copy them only when essential.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 这是因为简单的数组赋值并不会复制数组，它只是让 `D` 引用与 `A` 相同的对象。这种行为是大多数编程语言的典型特征。由于数组可能占用大量内存，因此最好只有在必要时才复制它们。
- en: Now consider the second code block of [Listing 5-9](ch05.xhtml#ch05list9). It
    restores the original value of `A[0]` and creates `E` using the `copy` function
    before assigning `E[0]` the string `'plugh'`. Then come two `output` statements.
    We might guess the output at this point.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 现在考虑 [Listing 5-9](ch05.xhtml#ch05list9) 的第二个代码块。它恢复了 `A[0]` 的原始值，并使用 `copy`
    函数创建 `E`，然后将 `E[0]` 赋值为字符串 `'plugh'`。接着是两个 `output` 语句。我们此时可以猜测输出。
- en: '[PRE21]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: The `copy` function duplicated `A`, so updating `E[0]` did not alter the original
    array. However, be aware that `copy` makes only *shallow* copies. In a shallow
    copy, nested arrays are not copied, only referenced.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: '`copy` 函数复制了 `A`，因此更新 `E[0]` 并没有改变原始数组。不过，请注意，`copy` 只做*浅*拷贝。在浅拷贝中，嵌套的数组不会被复制，只会被引用。'
- en: '**Tables**'
  id: totrans-131
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**表格**'
- en: SNOBOL tables are like Python dictionaries. They associate a key with a value,
    which can also be any type of data. A few examples should suffice to illustrate
    their use (see [Listing 5-10](ch05.xhtml#ch05list10)).
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: SNOBOL 表格类似于 Python 字典。它们将一个键与一个值关联，值也可以是任何类型的数据。通过一些示例就足以说明它们的使用（见 [Listing
    5-10](ch05.xhtml#ch05list10)）。
- en: '[PRE22]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: '*Listing 5-10: Using a table*'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: '*Listing 5-10: 使用表格*'
- en: '[Listing 5-10](ch05.xhtml#ch05list10) shows almost all that is needed to understand
    a table. It first defines the now familiar `complex` data type, followed by a
    table, `t`. Four assignments to `t` follow, each with a different data type as
    the key. The four `output` statements produce'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: '[Listing 5-10](ch05.xhtml#ch05list10) 显示了理解表格所需的几乎所有内容。它首先定义了现在熟悉的 `complex`
    数据类型，然后是一个表格 `t`。接下来进行了四次赋值，每次赋值的键使用不同的数据类型。这四个 `output` 语句生成了'
- en: '[PRE23]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: This might not match your expectations, as there is no `three` in the output.
    To recover the value for a key, the key used must match exactly. The key for `three`
    was `complex(2,3)`. That’s a perfectly valid key, but passing another instance
    of `complex(2,3)` will not find its value because the two do not evaluate to the
    same object in memory. Using `c` as a key does allow `four` to be recovered because
    `c` references the same data structure in memory. The last lesson from [Listing
    5-10](ch05.xhtml#ch05list10) is that referencing a key that doesn’t exist returns
    `null` but is not an error. To check whether a key is in the table, use the `ne`
    predicate to check the value returned against `null`.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 这可能与您的预期不符，因为输出中没有 `three`。要恢复一个键的值，必须使用完全匹配的键。`three` 的键是 `complex(2,3)`。这是一个完全有效的键，但传入另一个
    `complex(2,3)` 实例将找不到其值，因为这两个对象在内存中的评估结果并不相同。使用 `c` 作为键可以恢复 `four`，因为 `c` 引用了内存中的相同数据结构。来自[列表
    5-10](ch05.xhtml#ch05list10)的最后一课是，引用一个不存在的键会返回 `null`，但并不算错误。要检查某个键是否在表格中，可以使用
    `ne` 谓词来检查返回的值是否与 `null` 相等。
- en: The `table` declaration accepts up to two arguments. The first is the table’s
    initial size, the number of entries for which memory has already been allocated.
    Tables are dynamic, meaning they grow as needed. The second argument is the number
    of entries to grow by whenever the table must grow. If no arguments are given,
    `table()` is equivalent to `table(10,10)`. If you know the table will be large
    but mostly fixed when established, use a large first argument and a smaller second
    argument. Conversely, if you don’t know how large the table will be but expect
    that many entries will be added, use a small initial size and a larger second
    argument.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: '`table` 声明接受最多两个参数。第一个是表格的初始大小，即已经分配内存的条目数量。表格是动态的，意味着它会根据需要增长。第二个参数是每当表格需要增长时增加的条目数。如果没有给定参数，`table()`
    等同于 `table(10,10)`。如果您知道表格在建立时会很大，但大部分是固定的，可以使用一个较大的第一个参数和一个较小的第二个参数。相反，如果您不知道表格的大小，但预计会添加许多条目，可以使用一个较小的初始大小和一个较大的第二个参数。'
- en: '[Listing 5-11](ch05.xhtml#ch05list11) defines a table with initial room for
    100 entries, `z`.'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: '[列表 5-11](ch05.xhtml#ch05list11) 定义了一个初始容量为 100 条目的表格 `z`。'
- en: '[PRE24]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: '*Listing 5-11: Another table example*'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 5-11：另一个表格示例*'
- en: 'The first four assignments to `z` are straightforward, though recalling the
    value of *π* to eight decimals so it can be used as a key to remember the string
    `''pi''` is admittedly rather silly. The example gets worse. We define an array,
    `a` ➊, and assign the table, `z`, to its seventh element ➋. Then, in the next
    line, we put `a` in the table ➌. We’ve have an odd situation: the table we just
    placed `a` into is referenced by `a` itself.'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 对 `z` 的前四次赋值很简单，尽管为了记住字符串 `'pi'`，要回想 *π* 的八位小数并将其用作键，确实显得有些愚蠢。这个例子变得更糟。我们定义了一个数组
    `a` ➊，并将表格 `z` 赋值给其第七个元素 ➋。然后，在下一行中，我们将 `a` 放入表格 ➌。我们遇到了一个奇怪的情况：我们刚刚放入 `a` 的表格现在又被
    `a` 自身引用。
- en: The `output` statements generate
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: '`output` 语句生成'
- en: '[PRE25]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: We get the integer `2`, the array `a`, the name `pi` from its floating-point
    value to eight decimals, and then the final output, also `pi`. The final output
    was generated by ➍. Because `a` is in `z`, and `z` is in `a`, we can use an arbitrary
    number of pairs of references, first `[a]` to return the array followed by `[7]`
    to get `z` from the array, to finally arrive again at `z` and recover `pi`. Of
    course, this is a ludicrous thing to do, but SNOBOL doesn’t judge.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 我们得到了整数 `2`、数组 `a`、浮点值到八位小数的名字 `pi`，然后是最终的输出，也是 `pi`。最终的输出是由 ➍ 生成的。因为 `a` 在
    `z` 中，而 `z` 又在 `a` 中，我们可以使用任意数量的引用对，首先是 `[a]` 返回数组，再加上 `[7]` 从数组中获取 `z`，最后再次到达
    `z` 并恢复 `pi`。当然，这是个荒谬的做法，但 SNOBOL 不会评判。
- en: How can we know what keys a SNOBOL table has? In Python, we can use the `keys`
    method. In SNOBOL, we convert the table to an array to get at the keys. Likewise,
    we can convert a properly structured array into a table. [Listing 5-12](ch05.xhtml#ch05list12)
    illustrates an example of each.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 我们如何知道 SNOBOL 表格中有哪些键？在 Python 中，我们可以使用 `keys` 方法。在 SNOBOL 中，我们将表格转换为数组以获取键。同样，我们也可以将正确结构的数组转换为表格。[列表
    5-12](ch05.xhtml#ch05list12) 展示了每种情况的示例。
- en: '[PRE26]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: '*Listing 5-12: Converting tables to arrays and arrays to tables*'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 5-12：将表格转换为数组，并将数组转换为表格*'
- en: We first create a table ➊ and add three entries. Next, we call `convert` to
    change the table into an array, `x`. The array has *n* × 2 dimensions if there
    are *n* entries in the table. The first column is the key and the second column
    is the value. The keys and values are printed using a simple loop ➌. Notice that
    the loop ends when accessing the array fails because the index, `i`, is too large.
    In SNOBOL, you code for failure.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先创建一个表格 ➊，并添加三条条目。接着，我们调用 `convert` 将表格转换为数组 `x`。如果表格中有 *n* 条条目，则数组的维度为 *n*
    × 2。第一列是键，第二列是值。使用简单的循环 ➌ 打印键和值。请注意，当访问数组失败时，循环结束，因为索引 `i` 太大。在 SNOBOL 中，你需要为失败编写代码。
- en: To go the other way and convert an array into a table, consider ➍. A 2D array
    is created with the first column as the key and the second column as the value.
    Another call to `convert` makes the properly structured array a table ➎.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 如果要反过来将数组转换为表格，可以考虑 ➍。创建一个二维数组，其中第一列是键，第二列是值。另一次调用 `convert` 会将正确结构化的数组转换为表格
    ➎。
- en: SNOBOL arrays and tables are flexible and more advanced than many other languages
    of the time.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: SNOBOL 的数组和表格比当时许多其他语言更加灵活和先进。
- en: And now for something completely different.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来是一些完全不同的内容。
- en: '***A Blizzard of Patterns***'
  id: totrans-153
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***模式的风暴***'
- en: In this section, we’ll introduce patterns, though a thorough understanding of
    patterns is beyond what we can hope to cover in a single chapter. There are two
    types of pattern statements in SNOBOL. The first applies a pattern to a string.
    The second applies a pattern to a string and updates the portion of the string
    that matched the pattern. We’ll learn about patterns in B. F. Skinner fashion,
    a little bit at a time, with examples.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将介绍模式，尽管对模式的透彻理解超出了我们在单一章节中能够覆盖的范围。SNOBOL 中有两种模式声明。第一种是将模式应用于字符串。第二种是将模式应用于字符串，并更新与模式匹配的字符串部分。我们将以
    B. F. Skinner 的方式一点一点地学习模式，并通过示例来进行讲解。
- en: '**A First Example**'
  id: totrans-155
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**第一个示例**'
- en: Consider [Listing 5-13](ch05.xhtml#ch05list13), which presents a simple program
    accepting lines of text from the user until the string `'hello'` appears in one
    of the lines.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 请参考 [列表 5-13](ch05.xhtml#ch05list13)，其中展示了一个简单的程序，该程序接受用户输入的文本行，直到某一行中出现字符串
    `'hello'`。
- en: '[PRE27]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: '*Listing 5-13: A simple pattern example*'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 5-13：一个简单的模式示例*'
- en: The first line of the program calls `input` to return a string. The second string,
    which at first might appear to be concatenated because of the space, is a pattern,
    with the pattern matching a constant string. If the text returned by `input` has
    `'hello'` anywhere within it, the pattern match succeeds. If not, it fails, and
    the goto for failure asks the user for another string.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 程序的第一行调用 `input` 来返回一个字符串。第二个字符串，起初可能因为空格而看起来像是拼接的，实际上是一个模式，该模式匹配一个常量字符串。如果
    `input` 返回的文本中包含 `'hello'`，则模式匹配成功。如果没有匹配到，匹配失败，失败的 `goto` 会提示用户输入另一个字符串。
- en: '[Listing 5-13](ch05.xhtml#ch05list13) is an example of the first type of pattern
    matching statement: a *text pattern*. In a pattern, success or failure of the
    match decides what happens next; however, as we’ll see, a pattern can generate
    new variables that hold pieces of the matched pattern. This means that many pattern
    matching statements are assigning data even if they don’t have explicit gotos.'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: '[列表 5-13](ch05.xhtml#ch05list13) 是第一个类型的模式匹配声明的示例：一个 *文本模式*。在模式中，匹配的成功或失败决定接下来发生的事情；然而，正如我们将看到的，模式可以生成新的变量来保存匹配到的模式的片段。这意味着许多模式匹配声明实际上是在赋值，即使它们没有显式的
    `goto`。'
- en: The pattern matches only an explicit string of characters. If we want to check
    for other options, we use alternation, `|` (with spaces!). Therefore, to accept
    either `'hello'` or `'aloha'`, use `'hello' | 'aloha'` as the pattern.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 模式只匹配显式的字符字符串。如果我们想要检查其他选项，可以使用交替，`|`（带空格！）。因此，要接受 `'hello'` 或 `'aloha'`，可以使用
    `'hello' | 'aloha'` 作为模式。
- en: As you might expect, SNOBOL has many bits and pieces for matching various patterns.
    The ones we’ll examine are `len`, `span`, `pos`, `any`, and `break`.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所预期的，SNOBOL 有许多小工具可以用来匹配各种模式。我们将要检查的有 `len`、`span`、`pos`、`any` 和 `break`。
- en: '**Matching and Updating Strings**'
  id: totrans-163
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**匹配和更新字符串**'
- en: The second pattern statement matches a pattern and updates the text matched
    with new text. See [Listing 5-14](ch05.xhtml#ch05list14).
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个模式声明匹配一个模式，并用新文本更新匹配到的文本。请参见 [列表 5-14](ch05.xhtml#ch05list14)。
- en: '[PRE28]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: '*Listing 5-14: Matching and updating a string*'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 5-14：匹配和更新字符串*'
- en: The output of this program is `how now blue giraffe?`, where `color` matched
    to change `brown` to `blue`, and `animal` matched to change `cow` to `giraffe`.
    If the match fails, the string is not updated. Note that a match succeeds when
    the first success happens. Therefore,
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 该程序的输出是`how now blue giraffe?`，其中`color`匹配了将`brown`更改为`blue`，`animal`匹配了将`cow`更改为`giraffe`。如果匹配失败，字符串不会更新。请注意，匹配成功是指第一次成功发生时。因此，
- en: '[PRE29]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: produces `The black bear approached the brown car`. To update all matches, use
    a loop.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 生成了`The black bear approached the brown car`。要更新所有匹配项，请使用循环。
- en: '[PRE30]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: This example loops for as long as the pattern `'brown'` is found, replacing
    it with `'black'` each time. The output is now `The black bear approached the
    black car`.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子会一直循环，直到找到模式`'brown'`，每次都将其替换为`'black'`。输出现在是`The black bear approached
    the black car`。
- en: '**Extracting Information from a String**'
  id: totrans-172
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**从字符串中提取信息**'
- en: What if we want to extract the matched text? When used in a pattern, the name
    operator (`.`) extracts the matched text to a variable. See [Listing 5-15](ch05.xhtml#ch05list15).
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想提取匹配的文本怎么办？当在模式中使用时，名称操作符（`.`）会将匹配的文本提取到变量中。参见[清单 5-15](ch05.xhtml#ch05list15)。
- en: '[PRE31]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: '*Listing 5-15: Capturing the matched text*'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 5-15：捕获匹配的文本*'
- en: Several new things are happening in [Listing 5-15](ch05.xhtml#ch05list15), so
    let’s go through it carefully. Structurally, the program consists of four pattern
    definitions, which are the variables ending in `pat`. This is followed by a piece
    of example text with a first name, last name, and address. Our goal is to break
    this text apart into its individual fields. The pattern matching line comes next,
    followed by an `output` statement to print the data in a new format.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 在[清单 5-15](ch05.xhtml#ch05list15)中发生了几件新事情，让我们仔细研究一下。结构上，该程序由四个模式定义组成，这些变量以`pat`结尾。接下来是一段包含名字、姓氏和地址的示例文本。我们的目标是将这段文本拆分成各个字段。接下来是模式匹配行，随后是一个`output`语句，用于以新格式打印数据。
- en: Let’s explain what’s happening, line by line. First, we define `dpat` ➊. This
    is a pattern to match one or more instances of a comma, colon, or space. That’s
    what `span` does; it matches the longest possible sequence consisting of nothing
    but the characters in its argument.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们逐行解释发生了什么。首先，我们定义了`dpat` ➊。这是一个匹配一个或多个逗号、冒号或空格的模式。这就是`span`的作用；它匹配最长的可能序列，且该序列仅由其参数中的字符组成。
- en: Next comes `lpat` ➋. This pattern matches characters up to, but not including,
    the first occurrence of a comma or colon. That’s what `break` does. If the string
    is `abcde:f`, then `break(',:')` matches the string `abcde`, but not the colon.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来是`lpat` ➋。此模式匹配直到第一个逗号或冒号出现之前的字符，但不包括逗号或冒号。这就是`break`的作用。如果字符串是`abcde:f`，那么`break(',:')`将匹配字符串`abcde`，但不包括冒号。
- en: The `break` is next to the name operator, followed by `last`, with the entire
    expression surrounded by parentheses. The expression matches characters up to,
    but not including, the first comma or colon, and stores them in the variable `last`.
    Looking at line ➎ makes it clear that `lpat` matches the last name.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: '`break`紧跟在名称操作符后面，后面是`last`，整个表达式被括号括起来。该表达式匹配直到第一个逗号或冒号出现之前的字符，并将其存储在变量`last`中。从第➎行可以清楚地看到，`lpat`匹配的是姓氏。'
- en: However, ➋ has a `dpat` hanging at the end. It’s there to match the comma or
    colon that ended the `break`. As SNOBOL attempts to match a pattern, internally,
    it’s moving a *cursor* over the string, character by character, forward and sometimes
    backward to try other options. When the `break` of `lpat` matches, the cursor
    is looking at the comma or colon that ended the `break`. So we use `dpat` to skip
    it.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，➋的末尾有一个`dpat`。它用于匹配结束`break`的逗号或冒号。当SNOBOL尝试匹配一个模式时，内部会将*游标*逐个字符地向前（有时向后）移动，尝试其他选项。当`lpat`的`break`匹配时，游标正看着结束`break`的逗号或冒号。因此，我们使用`dpat`跳过它。
- en: The definition of `fpat` ➌ is nearly identical to ➋; however, the matched text
    is stored in `first`. That is, `fpat` matches the first name. As before, a `dpat`
    at the end of the pattern consumes the comma or colon that ended the `*break*`.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: '`fpat` ➌的定义与➋几乎相同；然而，匹配的文本存储在`first`中。也就是说，`fpat`匹配的是名字。如前所述，模式末尾的`dpat`会消耗结束`*break*`的逗号或冒号。'
- en: The internal cursor has now matched the last name and first name. The remaining
    pattern, `apat`, uses the special pattern, `rem`, to match the remainder of the
    line and assign it to `address` ➍.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 内部游标现在已经匹配了姓氏和名字。剩余的模式`apat`使用特殊模式`rem`来匹配该行的其余部分，并将其分配给`address` ➍。
- en: To test the patterns, we define `text` to be a string with a last name, first
    name, and address using a comma and a colon as delimiters along with some extra
    spaces ➎.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 为了测试这些模式，我们将`text`定义为一个包含姓氏、名字和地址的字符串，使用逗号和冒号作为分隔符，并加上一些额外的空格 ➎。
- en: Lastly, we apply the patterns to `text` ➏. Notice that, at first glance, ➏ is
    just a sequence of four variables in a row. However, SNOBOL knows to parse this
    as a string followed by a pattern. The string is `text`; therefore, the remaining
    variables form the pattern. The overall pattern is built by concatenating `lpat`,
    `fpat`, and `apat`. We might, for clarity, put parentheses around the three pattern
    variables. If we wanted to concatenate two or more text strings and then apply
    a pattern, the parentheses would be placed around those variables.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将模式应用于`text` ➏。注意，乍一看，➏只是四个变量连续排列。然而，SNOBOL知道要将其解析为一个字符串，后面跟着一个模式。字符串是`text`；因此，其余的变量形成模式。整体模式是通过连接`lpat`、`fpat`和`apat`来构建的。为了清晰起见，我们可能会在这三个模式变量周围加上括号。如果我们想将两个或更多的文本字符串连接在一起再应用模式，括号应该放在这些变量周围。
- en: 'When ➏ executes, the last name, first name, and address are extracted. To prove
    this, ➐ dumps the same information rearranged to be first name, then last name,
    followed by the address. Notice that `address` is passed to `trim`, the SNOBOL
    function to remove trailing spaces from a string. The output of [Listing 5-15](ch05.xhtml#ch05list15)
    is `''Julius Caesar, address: 1313 Mockingbird Ln''`.'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: '当 ➏ 执行时，提取出姓氏、名字和地址。为证明这一点，➐将相同的信息重新排列为先名字，再姓氏，最后是地址。注意，`address`被传递给`trim`，SNOBOL的一个函数，用于去除字符串末尾的空格。[列表
    5-15](ch05.xhtml#ch05list15)的输出是`''Julius Caesar, address: 1313 Mockingbird Ln''`。'
- en: '**More Elaborate Pattern Matching**'
  id: totrans-186
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**更复杂的模式匹配**'
- en: Let’s look at three more quick pattern matching examples. The first two manipulate
    a file of dates. The last one updates Lewis Carroll’s *Alice’s Adventures in Wonderland*
    to give “Bob” a chance to put himself in the story.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看三个快速的模式匹配示例。前两个示例处理一个日期文件。最后一个示例更新刘易斯·卡罗尔的*《爱丽丝梦游仙境》*，让“Bob”有机会将自己融入到故事中。
- en: '[Listing 5-16](ch05.xhtml#ch05list16) maps numeric dates in North American
    format (month, day, year) to European-style dates (day, month, year).'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: '[列表 5-16](ch05.xhtml#ch05list16)将北美格式的数字日期（月份、日期、年份）映射为欧洲风格的日期（日期、月份、年份）。'
- en: '[PRE32]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: '*Listing 5-16: Manipulating dates with patterns, take one*'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 5-16：使用模式处理日期，第一部分*'
- en: The pattern, `pat`, uses `len` to match the specified number of characters,
    regardless of what they are. The first two characters are assigned to `month`,
    followed by a slash or dash; then the next two characters are put in `day`, followed
    by another slash or dash and a four-character year.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 该模式`pat`使用`len`来匹配指定数量的字符，无论它们是什么。前两个字符分配给`month`，后跟斜杠或破折号；接下来两个字符放入`day`，再跟另一个斜杠或破折号，最后是四位数的年份。
- en: '[Listing 5-15](ch05.xhtml#ch05list15) is in the file *dates.sno*. There is
    another file in the same directory called *dates.txt* that contains a set of numeric
    dates. For example, the first few lines of the file are'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: '[列表 5-15](ch05.xhtml#ch05list15)在文件*dates.sno*中。该目录下还有另一个文件*dates.txt*，其中包含一组数字日期。例如，文件的前几行是：'
- en: '[PRE33]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: with some dates using slashes and some using dashes. A few even use a mix. [Listing
    5-15](ch05.xhtml#ch05list15) uses a `loop` to read the file, line by line. Each
    line is read with `input` using command line redirection and placed into `text`.
    If there is nothing left to read, the `input` command fails and SNOBOL jumps to
    the end.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 日期中有些使用斜杠，有些使用破折号，还有一些混合使用了这两者。[列表 5-15](ch05.xhtml#ch05list15)使用一个`loop`逐行读取文件。每一行都通过`input`命令行重定向读取并存入`text`中。如果没有内容可以读取，`input`命令失败，SNOBOL跳转到结尾。
- en: If the read succeeds, the pattern is applied to `text`, but this time in the
    form `string pattern = update`, where the text matched by `pattern` is replaced
    by the text in `update`. Here, the replacement text is constructed from the day,
    month, and year matched by `pat`, using slashes between elements ➋.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 如果读取成功，模式将应用于`text`，但这次是以`string pattern = update`的形式，其中由`pattern`匹配到的文本将被`update`中的文本替换。在这里，替换文本是由`pat`匹配到的日期、月份和年份构成的，元素之间用斜杠分隔
    ➋。
- en: Notice that ➋ has a goto for failure. If the pattern doesn’t match, the input
    string is not a valid date format, so the program jumps to `bad` to output `unknown
    format` before jumping back to the loop to process the next input. If the pattern
    match doesn’t fail, `text` has been updated so it’s `output` before jumping to
    `loop` to read the next date.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，➋有一个失败的跳转。如果模式匹配失败，说明输入字符串不是有效的日期格式，因此程序会跳转到`bad`输出`unknown format`，然后再跳回循环处理下一个输入。如果模式匹配成功，`text`已被更新，因此在跳转到`loop`读取下一个日期之前会输出。
- en: Run *dates.sno* with
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 *dates.sno* 运行
- en: '[PRE34]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: to produce
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 生成
- en: '[PRE35]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: The final `unknown format` line corresponds to an input of `AVCDe-224*`, which
    is clearly not a valid date.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一行`unknown format`对应一个`AVCDe-224*`的输入，这显然不是一个有效的日期格式。
- en: The next example uses `dates.txt`, but produces full dates instead of numeric
    dates. See [Listing 5-17](ch05.xhtml#ch05list17).
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个示例使用`dates.txt`，但生成的是完整日期，而非数字日期。参见[Listing 5-17](ch05.xhtml#ch05list17)。
- en: '[PRE36]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: '*Listing 5-17: Manipulating dates with patterns, take two*'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: '*Listing 5-17: 使用模式操作日期，第二部分*'
- en: The pattern, `pat`, is the same as in [Listing 5-16](ch05.xhtml#ch05list16).
    Additionally, we define `m`, an array holding the names of the months.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 模式`pat`与[Listing 5-16](ch05.xhtml#ch05list16)中的相同。此外，我们定义了`m`，这是一个数组，存储了月份的名称。
- en: 'The code runs in the same way as [Listing 5-16](ch05.xhtml#ch05list16) but
    outputs a full date using the number of the month as the index into the array
    of names. Also, notice that both `day` and `year` are multiplied by 1\. The text
    matched is a string. To output the day and year without leading 0s, as there are
    a few three-digit years in `dates.txt`, we convert the strings to integers. [Listing
    5-17](ch05.xhtml#ch05list17) is in the file *dates2.sno*. Run it to produce this
    output:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 代码的运行方式与[Listing 5-16](ch05.xhtml#ch05list16)相同，但输出的是完整日期，使用月份的数字作为索引，查找月份名称的数组。同时请注意，`day`和`year`都乘以1。匹配到的文本是一个字符串。为了输出没有前导零的日期和年份（因为`dates.txt`中有一些三位数年份），我们将字符串转换为整数。[Listing
    5-17](ch05.xhtml#ch05list17)在文件*dates2.sno*中。运行它以生成以下输出：
- en: '[PRE37]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: For our final pattern example, with apologies to Lewis Carroll, we’ll update
    the first part of *Alice’s Adventures in Wonderland* to be *Bob’s Adventures in
    Wonderland.* The text we’ll work with is in the file *alice.txt*, and consists
    of the beginning part of [Chapter 1](ch01.xhtml#ch01).
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们的最后一个模式示例，抱歉借用路易斯·卡罗尔的名字，我们将更新《爱丽丝梦游仙境》的第一部分，将其改为《鲍勃的仙境历险记》。我们将处理的文本位于文件*alice.txt*中，包含[第1章](ch01.xhtml#ch01)的开头部分。
- en: The code we need is in *alice.sno* and [Listing 5-18](ch05.xhtml#ch05list18).
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要的代码在*alice.sno*中，参见[Listing 5-18](ch05.xhtml#ch05list18)。
- en: '[PRE38]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: '*Listing 5-18: Making Bob’s Adventures in Wonderland*'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: '*Listing 5-18: 制作《鲍勃的仙境历险记》*'
- en: '[Listing 5-18](ch05.xhtml#ch05list18) begins by defining two patterns, `p`
    and `s`. The first uses alternation to match nothing (`null`) or `any` single
    character that is a space, period, comma, question mark, exclamation point, or
    right parenthesis. The second pattern uses `pos` to match cursor position zero,
    that is, the beginning of a line, a space, or a left parenthesis.'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: '[Listing 5-18](ch05.xhtml#ch05list18)首先定义了两个模式，`p`和`s`。第一个模式使用交替匹配空白字符（`null`）或任何单个字符，如空格、句点、逗号、问号、感叹号或右括号。第二个模式使用`pos`匹配光标位置零，即行的开头、空格或左括号。'
- en: The remainder of the program is a loop from `input` to `output` via `loop`.
    Between the input and the output there are seven lines, `s0` through `s6`. Each
    of these lines is a loop (notice the success gotos) and has a similar format.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 程序的其余部分是一个从`input`到`output`的循环，通过`loop`。在输入和输出之间有七行，`s0`到`s6`。这些行每一行都是一个循环（注意成功的跳转），并且格式相似。
- en: '[PRE39]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: The first part is the text read from the input file, `text`. The rest of the
    line up to the equals sign is a pattern. The pattern looks for a match to a word,
    such as the name `'Alice'`, storing the character before the word in `a` and the
    character after in `c`.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 第一部分是从输入文件`text`中读取的文本。等号之前的部分是一个模式。该模式用于匹配一个单词，如`'Alice'`，将该单词前的字符存储在`a`中，后面的字符存储在`c`中。
- en: The matched text, if any, is replaced by the same leading and trailing character
    with the matched word updated. Thus, “Alice” is replaced with “Bob,” “her” is
    replaced with “his,” and so on. Recall that a match is successful after the first
    one is found, so if there are multiple occurrences of “Alice” in the line, only
    the first will be replaced with “Bob.” So we must loop until the match fails to
    replace all occurrences.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 匹配的文本（如果有的话）将被相同的前导和尾随字符替换，且匹配的单词会被更新。因此，“Alice”会被替换为“Bob”，“her”会被替换为“his”，依此类推。回忆一下，匹配在找到第一个时就算成功，因此如果一行中有多个“Alice”的出现，只有第一个会被替换为“Bob”。所以我们必须循环，直到匹配失败，才能替换所有出现的词。
- en: After all seven patterns are tested and matched as much as possible, the updated
    `text` is `output` and the loop begins again until there is no input left.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 在测试并尽可能匹配所有七个模式后，更新后的 `text` 会作为 `output` 输出，然后循环会再次开始，直到没有输入为止。
- en: The first paragraph of *alice.txt* is
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: '*alice.txt* 的第一段是'
- en: '[PRE40]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: The same paragraph after the “Bob” conversion is
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: “Bob”转换后的相同段落是
- en: '[PRE41]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: The conversion isn’t foolproof, but that isn’t SNOBOL’s fault. There are cases
    in English where the word “her” should be changed to “his” and cases where it
    should become “him.” The code of [Listing 5-18](ch05.xhtml#ch05list18) knows nothing
    of the context, so it always uses “his.”
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 这个转换并不是万无一失的，但这不是 SNOBOL 的错。英语中有一些情况下，“her”应该改成“his”，而有些情况下则应该变成“him”。[列表 5-18](ch05.xhtml#ch05list18)
    中的代码并不理解上下文，因此它总是使用“his”。
- en: There is much more to discover concerning SNOBOL patterns. An excellent place
    to learn more is [Chapter 2](ch02.xhtml#ch02) of Griswold, Poage, and Polonsky’s
    *The SNOBOL4 Programming Language* (Prentice Hall, 1971). Versions of the second
    edition are floating around the internet if you care to take a look.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 关于 SNOBOL 模式还有更多内容值得探索。了解更多的一个极好的地方是 [第二章](ch02.xhtml#ch02) 取自 Griswold、Poage
    和 Polonsky 的 *The SNOBOL4 Programming Language*（普伦蒂斯霍尔，1971 年）。第二版的版本可以在网上找到，如果你有兴趣，可以去看看。
- en: Let’s move on to SNOBOL’s user-defined functions, perhaps the least elegant
    part of the language (aside from relying solely on goto for flow control).
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们继续讨论 SNOBOL 的用户定义函数，也许这是语言中最不优雅的部分（除了完全依赖 `goto` 进行流程控制之外）。
- en: '***Functions***'
  id: totrans-225
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***函数***'
- en: SNOBOL would be a weak language indeed if it had no facility for users to define
    functions. Thankfully, it does, though the syntax is a bit strange. In this section,
    we’ll learn how to define and use functions.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 SNOBOL 没有允许用户定义函数的功能，它将确实是一个较弱的语言。幸运的是，它有这个功能，尽管语法有点奇怪。在这一部分中，我们将学习如何定义和使用函数。
- en: We’ll jump right in with [Listing 5-19](ch05.xhtml#ch05list19). This program,
    in the file *poly.sno*, defines a function to implement arbitrary polynomials
    of the form
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将直接进入 [列表 5-19](ch05.xhtml#ch05list19)。这个程序位于文件 *poly.sno* 中，定义了一个函数来实现任意多项式，形式为
- en: '*y* = *a**x*² + *b**x* + *c*'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: '*y* = *a**x*² + *b**x* + *c*'
- en: which we use to output (*x*, *y*) pairs for plotting the function.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用这个公式输出 (*x*, *y*) 对，用于绘制函数图像。
- en: '[PRE42]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: '*Listing 5-19: A user-defined function*'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 5-19：用户定义的函数*'
- en: SNOBOL functions begin with a `define` statement ➊. There are a couple of important
    things to notice about ➊. First, the function declaration is a string. It begins
    with the name of the function (`poly`), followed by an opening parenthesis, the
    list of arguments, and a closing parenthesis. If the function uses local variables,
    they are listed next, separated by commas, as part of the string. Note that the
    string portion of the `define` statement *must not* include spaces. No spaces
    between the arguments, no spaces in the list of local variables, no spaces anywhere.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: SNOBOL 函数以 `define` 语句开始 ➊。关于 ➊，有几点需要注意。首先，函数声明是一个字符串。它以函数名（`poly`）开始，后跟一个左括号、参数列表，再到右括号。如果函数使用局部变量，它们接着会列出，并以逗号分隔，作为字符串的一部分。请注意，`define`
    语句的字符串部分*不能*包含空格。参数之间没有空格，局部变量列表中没有空格，任何地方都不能有空格。
- en: The next thing to notice is that the `define` statement ends with a goto (`epoly`).
    This label must jump to just beyond the end of the function’s body, that is, it
    must not include any code that is part of the function. The function’s body is
    the code between the `define` statement and the ending label, which here is `epoly`.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 下一点需要注意的是，`define` 语句以 `goto`（`epoly`）结束。这个标签必须跳到函数体的末尾，即，它必须不包含任何属于函数的代码。函数体是从
    `define` 语句到结束标签之间的代码，这里是 `epoly`。
- en: The function body begins with a label matching the function’s name, which is
    `poly` in this case. The body of the function is free to use the arguments, any
    local variables, and any global variables. The value returned by the function
    is assigned to a variable of the same name, as is sometimes done in other programming
    languages. In [Listing 5-19](ch05.xhtml#ch05list19), the variable `poly` is assigned
    the value of the quadratic.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 函数体以与函数名称相匹配的标签开始，在本例中是 `poly`。函数体可以自由使用参数、任何局部变量以及任何全局变量。函数返回的值会赋给一个相同名称的变量，就像在其他编程语言中有时会做的那样。在
    [Listing 5-19](ch05.xhtml#ch05list19) 中，变量 `poly` 被赋值为二次方程的结果。
- en: 'To exit the function, SNOBOL defines two special goto labels: `return` and
    `freturn`. Use the former if the function was successful and the latter if not.
    The function `poly` always succeeds, so we use `return` to exit.'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 要退出函数，SNOBOL 定义了两个特殊的跳转标签：`return` 和 `freturn`。如果函数执行成功，使用前者；如果没有成功，使用后者。函数
    `poly` 总是成功的，所以我们使用 `return` 来退出。
- en: SNOBOL allows recursion, as shown in [Listing 5-20](ch05.xhtml#ch05list20),
    which implements the factorial function. The factorial of an integer, *n*, is
    *n*! = *n*(*n –* 1)(*n –* 2)*…* 1\. For example, 5! = 5 × 4 × 3 × 2 × 1 = 120.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: SNOBOL 允许递归，如在 [Listing 5-20](ch05.xhtml#ch05list20) 中所示，该代码实现了阶乘函数。一个整数 *n*
    的阶乘是 *n*! = *n*(*n –* 1)(*n –* 2)*…* 1。例如，5! = 5 × 4 × 3 × 2 × 1 = 120。
- en: Another way to think about the factorial of *n* is that it’s *n* times the factorial
    of *n –* 1, which is itself *n –* 1 times the factorial of *n –* 2, and so on
    down to 1\. That’s the recursive version. In Python, we might write this process
    as
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种思考 *n* 阶乘的方法是：它等于 *n* 乘以 *n –* 1 的阶乘，而 *n –* 1 的阶乘又等于 *n –* 1 乘以 *n –* 2
    的阶乘，依此类推，直到 1。这就是递归版本。在 Python 中，我们可能会写出如下过程
- en: '[PRE43]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: where `fact` calls itself to solve the simpler problem. All recursive functions
    need a base case, something that stops the recursion. In this case, it’s checking
    if *n* is less than 1\. This catches the edge case of 0! = 1.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`fact` 调用自身来解决更简单的问题。所有递归函数都需要一个基准情况，它可以停止递归。在本例中，它检查 *n* 是否小于 1。这样就可以处理
    0! = 1 的边界情况。
- en: Translating the recursive formula into SNOBOL leads to [Listing 5-20](ch05.xhtml#ch05list20).
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 将递归公式翻译成 SNOBOL 代码，得到了 [Listing 5-20](ch05.xhtml#ch05list20)。
- en: '[PRE44]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: '*Listing 5-20: A recursive factorial function*'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: '*Listing 5-20：递归阶乘函数*'
- en: The definition accepts *n*. The first line of the body implements the base case.
    If *n* > 0, then `eq(n,0)` fails, so `fact` is not assigned and the next line
    is executed. If *n* = 0, `eq(n,0)` succeeds, so we return from the function via
    `s(return)`.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 该定义接受 *n*。函数体的第一行实现了基准情况。如果 *n* > 0，则 `eq(n,0)` 失败，`fact` 不会被赋值，接着执行下一行。如果 *n*
    = 0，`eq(n,0)` 成功，所以我们通过 `s(return)` 从函数返回。
- en: The second line of `fact` implements the recursion. It assigns `fact` to `n`
    times whatever `fact(n - 1)` returns and then it returns via `(return)`.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: '`fact` 的第二行实现了递归。它将 `fact` 赋值为 `n` 乘以 `fact(n - 1)` 返回的值，然后通过 `(return)` 返回。'
- en: The main code asks the user for a number and returns the factorial. Run it and
    enter integers in [0,20]. Beyond 20, integers overflow; however, if you enter
    a floating-point number, you can estimate larger factorials. Also, notice the
    use of `convert` to force `n` to be an integer for display purposes.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 主程序要求用户输入一个数字并返回其阶乘。运行程序并输入 [0,20] 范围内的整数。超过 20 时，整数会溢出；但是，如果输入浮点数，你可以估算更大的阶乘。此外，注意使用
    `convert` 强制将 `n` 转换为整数以便显示。
- en: Let’s write a function to swap the value of two variables. This should be easy.
    Our first attempt is
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们编写一个函数来交换两个变量的值。这应该很简单。我们的第一次尝试是
- en: '[PRE45]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: which defines `swap`. The value of `x` is kept in `t`, then `y` is assigned
    to `x` and `t` is assigned to `y`, followed by a return. The main body of the
    program sets *a* = 3 and *b* = 5, outputs their values, calls `swap`, and then
    outputs them again. Running the code produces
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 该定义了 `swap`。首先将 `x` 的值保存在 `t` 中，然后将 `y` 赋值给 `x`，再将 `t` 赋值给 `y`，最后返回。程序的主体部分将
    *a* = 3 和 *b* = 5，输出它们的值，调用 `swap`，然后再次输出它们。运行代码后，产生了
- en: '[PRE46]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: This is clearly incorrect. The values haven’t changed. Why? The algorithm in
    `swap` is correct, so why didn’t the values change?
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 这显然是错误的。值没有发生变化。为什么？`swap` 中的算法是正确的，那为什么值没有变化呢？
- en: SNOBOL passes simple variables by *value*, meaning the value of `a` is assigned
    to `x`. So when `x` is updated in the body of `swap`, `a` is not affected. To
    update the variables, we need to pass the data by *reference* so `x` is really
    a synonym for `a`. After that, updates to `x` will affect `a`. Note that SNOBOL
    passes arrays and tables by reference.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: SNOBOL按*值*传递简单变量，意味着`a`的值被赋给了`x`。因此，当`x`在`swap`函数体内更新时，`a`并未受到影响。为了更新变量，我们需要按*引用*传递数据，这样`x`实际上是`a`的同义词。之后，对`x`的更新将影响到`a`。需要注意的是，SNOBOL按引用传递数组和表格。
- en: The code above is wrong. I don’t want you to use it. However, the code in [Listing
    5-21](ch05.xhtml#ch05list21) does work correctly.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 上面的代码是错误的。我不希望你使用它。然而，[列表 5-21](ch05.xhtml#ch05list21)中的代码是正确的。
- en: '[PRE47]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: '*Listing 5-21: Passing variables by reference*'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 5-21：通过引用传递变量*'
- en: Let’s focus on `swap`. It looks much like the wrong version, but it uses the
    indirection operator (`$`) before each argument, `$x`. Recall that indirection
    means “not this variable, but the variable named by this variable.” Think of indirection
    as dereferencing a pointer in other languages. The `swap` function is now working
    directly with names passed to it rather than copies of the variables.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们专注于`swap`。它看起来与错误的版本很像，但它在每个参数前都使用了间接操作符（`$`），如`$x`。回想一下，间接操作符意味着“不是这个变量，而是这个变量命名的变量”。可以把间接操作符理解为在其他语言中取消引用指针。现在，`swap`函数直接操作传递给它的名称，而不是变量的副本。
- en: The main body of [Listing 5-21](ch05.xhtml#ch05list21) will clarify. The first
    call to `swap` passes `a` and `b` ➊. The second call uses the name operator to
    pass the names of `a` and `b` ➋. The last call passes the literal strings `'a'`
    and `'b'`.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: '[列表 5-21](ch05.xhtml#ch05list21)的主体将进一步澄清。第一次调用`swap`时传递了`a`和`b` ➊。第二次调用使用名称操作符传递`a`和`b`的名称
    ➋。最后一次调用传递了字面字符串`''a''`和`''b''`。'
- en: Running [Listing 5-21](ch05.xhtml#ch05list21) produces
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 运行[列表 5-21](ch05.xhtml#ch05list21)会产生
- en: '[PRE48]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: The first output line shows us the original values of `a` and `b`. The second
    output line shows the effect of ➊ in [Listing 5-21](ch05.xhtml#ch05list21). There
    is no effect. The variables are unchanged because we passed their values rather
    than their names, so the indirection operator failed.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 第一行输出展示了`a`和`b`的原始值。第二行输出展示了[列表 5-21](ch05.xhtml#ch05list21)中➊的效果。没有任何效果。变量没有变化，因为我们传递的是它们的值，而不是它们的名称，因此间接操作符未能生效。
- en: The third output line shows the effect of ➋. Now `swap` is working. The name
    operator passed the strings `'a'` and `'b'`, which the indirection operator can
    interpret to mean that `a` and `b` are swapped.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 第三行输出显示了➋的效果。现在`swap`正在工作。名称操作符传递了字符串`'a'`和`'b'`，间接操作符可以解释为`a`和`b`被交换了。
- en: The final output line shows the effect of ➌. Here we pass the literal strings
    naming `a` and `b`. This is really what the name operator is doing, so `swap`
    works and swaps `a` and `b` again to restore them to their original values.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一行输出显示了➌的效果。在这里，我们传递了字面字符串`a`和`b`的名称。这实际上就是名称操作符所做的，所以`swap`再次工作，交换`a`和`b`，恢复它们的原始值。
- en: To sum up, SNOBOL passes simple variables by value, requiring the use of indirection
    to update them. However, arrays and tables are always passed by reference.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 总结一下，SNOBOL按值传递简单变量，要求使用间接操作符来更新它们。然而，数组和表格总是按引用传递。
- en: We know how to set up SNOBOL programs and how to create custom functions and
    data types. Now, let’s take a quick look at disk files.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经知道如何设置SNOBOL程序，如何创建自定义函数和数据类型。现在，让我们快速了解一下磁盘文件。
- en: '***Input and Output***'
  id: totrans-264
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***输入与输出***'
- en: We’ve seen `input` and `output` many times already. In this section, we’ll see
    how they work with disk files.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经多次见过`input`和`output`。在这一节中，我们将看到它们如何与磁盘文件一起工作。
- en: '[Listing 5-22](ch05.xhtml#ch05list22) presents code to make an uppercase copy
    of a text file.'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: '[列表 5-22](ch05.xhtml#ch05list22)展示了用于创建文本文件大写副本的代码。'
- en: '[PRE49]'
  id: totrans-267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: '*Listing 5-22: Uppercasing a disk file*'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 5-22：将磁盘文件内容转为大写*'
- en: There’s a lot here, so let’s walk through the code line by line. First, open
    the source text file by supplying arguments to `input`. The first argument is
    not the name of the file. Instead, it’s the name of a variable SNOBOL associates
    with the file. It’s what we use to read data from the file, so let’s call it `read`.
    The next argument is a unit number. This is a throwback to old-style programming
    where unit numbers were associated with operating system devices. The unit number
    needs to be unique for each open file. Use numbers of at least 10 or higher. Think
    of the unit number as a file reference.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有很多内容，所以让我们逐行分析代码。首先，通过将参数提供给`input`来打开源文本文件。第一个参数不是文件的名称，而是SNOBOL与文件关联的变量名称。我们用它来从文件中读取数据，所以我们称之为`read`。下一个参数是单元号。这是早期编程风格的回顾，其中单元号与操作系统设备相关联。每个打开的文件需要一个唯一的单元号。使用至少10或更高的数字。可以将单元号视为文件引用。
- en: After the unit number comes the maximum line length. Input lines longer than
    this are truncated. Remember, this is a text file, and SNOBOL works with lines
    of text. The final argument is the name of the disk file. We’re using `host(2,2)`,
    which is specific to our version of SNOBOL. This is a link to the actual operating
    system. The first argument, `2`, refers to command line arguments. The second
    number refers to items on the command line. The second item is the first argument
    after the script name. Therefore, `host(2,2)` gives us the name of the first file.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 单元号后面是最大行长度。长于此长度的输入行将被截断。记住，这是一个文本文件，而SNOBOL是基于文本行来工作的。最后一个参数是磁盘文件的名称。我们使用的是`host(2,2)`，这是我们版本的SNOBOL特有的。这是与操作系统的实际连接。第一个参数`2`表示命令行参数。第二个数字表示命令行上的项。第二项是脚本名称之后的第一个参数。因此，`host(2,2)`给我们提供了第一个文件的名称。
- en: To open the output file, we use `output`. As with `input`, the first argument
    is the name of a variable to which we will assign the output. We use unit `11`
    for output. The third argument is `'W'` to write a text file. Use `'A'` to append
    a file. The last argument is the name of the output file, here `host(2,3)`, which
    uses the second argument passed to the SNOBOL program.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 要打开输出文件，我们使用`output`。与`input`一样，第一个参数是我们将分配给输出的变量名称。我们使用单元`11`进行输出。第三个参数是`'W'`，表示写入文本文件。使用`'A'`可以追加文件。最后一个参数是输出文件的名称，这里是`host(2,3)`，它使用传递给SNOBOL程序的第二个参数。
- en: The files are now open, so let’s read lines from the input, uppercase them,
    and write them to the output. At ➊ we use `read`, tied to the input file, to get
    a line in `text`. If the read fails, the input file is exhausted, so we jump to
    `close`. Otherwise, proceed to apply the intrinsic `replace` to the text to uppercase
    the line; `replace` updates all occurrences of characters in the second argument
    by the corresponding character in the third argument. To save typing, we use the
    predefined strings of lowercase and uppercase letters. SNOBOL variables beginning
    with `&` are system-supplied variables. The output of this line uppercases `text`.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 文件现在已经打开，所以让我们从输入中读取行，将其转换为大写，并将其写入输出文件。在➊处，我们使用与输入文件相关联的`read`来获取一行`text`。如果读取失败，表示输入文件已用尽，因此我们跳转到`close`。否则，继续应用内建的`replace`函数将文本转为大写；`replace`会将第二个参数中的所有字符替换为第三个参数中对应的字符。为了节省输入，我们使用预定义的小写和大写字母字符串。以`&`开头的SNOBOL变量是系统提供的变量。这一行的输出将`text`转换为大写。
- en: To dump the text to the output file, assign it to `write`, which is the variable
    associated with the output file ➋. After dumping the newly uppercased text, we
    jump back to `loop` to continue.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 为了将文本转储到输出文件中，将其赋值给`write`，这是与输出文件关联的变量 ➋。将新转换为大写的文本转储后，我们跳回`loop`继续。
- en: Lastly, we need to close the input and output files before using `endfile` to
    exit.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们需要在使用`endfile`退出之前关闭输入和输出文件。
- en: '[Listing 5-22](ch05.xhtml#ch05list22) is in the file *uppercase.sno*. Let’s
    run it on the *Alice’s Adventures in Wonderland* text to uppercase it.'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: '[Listing 5-22](ch05.xhtml#ch05list22) 位于文件*uppercase.sno*中。让我们在*爱丽丝梦游仙境*的文本上运行它，以将其转换为大写。'
- en: '[PRE50]'
  id: totrans-276
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: The file *uppercase.txt* now contains `ALICE` in all caps.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 文件*uppercase.txt*现在包含全大写的`ALICE`。
- en: The example above worked with a text file. SNOBOL can also work with binary
    data. Let’s write a simple file copy program to read and write binary data. [Listing
    5-23](ch05.xhtml#ch05list23) shows *copy.sno*.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 上面的示例处理了一个文本文件。SNOBOL也可以处理二进制数据。让我们编写一个简单的文件复制程序来读取和写入二进制数据。[Listing 5-23](ch05.xhtml#ch05list23)
    显示了*copy.sno*。
- en: '[PRE51]'
  id: totrans-279
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: '*Listing 5-23: Copying a file*'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: '*Listing 5-23: 复制文件*'
- en: '[Listing 5-23](ch05.xhtml#ch05list23) is quite similar to [Listing 5-22](ch05.xhtml#ch05list22),
    but the input and output files are opened in binary mode. For `input`, where before
    we supplied the maximum line length, we now have `''B,4096''`. This specifies
    binary mode, meaning no line endings are interpreted, and a buffer of 4096 bytes.
    This means the source file will be read in 4096-byte chunks, or fewer if there
    aren’t at least 4096 bytes left to read. For output, use `''B''` to indicate binary
    mode.'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: '[清单 5-23](ch05.xhtml#ch05list23)与[清单 5-22](ch05.xhtml#ch05list22)非常相似，但输入和输出文件以二进制模式打开。对于`input`，之前我们指定了最大行长度，现在我们使用`''B,4096''`。这指定了二进制模式，意味着不会解释行结束符，并且缓冲区为4096字节。这意味着源文件将以4096字节为单位进行读取，如果剩余字节不足4096个，则读取较少字节。对于输出，使用`''B''`表示二进制模式。'
- en: The loop, in this case, is a one-liner ➊. Read a 4096-byte chunk of the input
    and immediately assign it to `write` to write it to the output file. When `read`
    fails, jump to close the files. Otherwise, jump back to this same line of code
    to continue the loop.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，循环是一个单行命令 ➊。读取4096字节的输入块，并立即将其分配给`write`，以写入输出文件。当`read`失败时，跳转到关闭文件。否则，跳转回同一行代码，继续执行循环。
- en: 'To test *copy.sno*, try the following:'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 要测试*copy.sno*，请尝试以下操作：
- en: '[PRE52]'
  id: totrans-284
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: This should copy the given *src.png* image to *dst.png*. The image is of a young
    raccoon and is taken from the open source SciPy toolkit.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 这应该会将给定的*src.png*图像复制到*dst.png*。该图像展示了一只年轻的浣熊，来自开源SciPy工具包。
- en: '**Machine Learning with SNOBOL**'
  id: totrans-286
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**使用SNOBOL进行机器学习**'
- en: Let’s work through a little SNOBOL project to implement a simple machine learning
    classifier. Modern artificial intelligence is far removed from what computer scientists
    had in mind back when SNOBOL was new. Machine learning existed then, but the term
    “artificial intelligence” was not used to describe it for the most part.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过一个简单的SNOBOL项目来实现一个简单的机器学习分类器。现代人工智能与计算机科学家当时构想的、SNOBOL刚出现时的情形相去甚远。那时机器学习就已经存在，但“人工智能”这个术语在大多数情况下并没有用来描述它。
- en: '*Artificial intelligence* now most often refers to that part of machine learning
    known as deep learning, that is, advanced neural networks, often with millions
    to billions of connections between the nodes (neurons). SNOBOL is not a good choice
    for such models. However, classical machine learning includes basic algorithms
    that are sometimes quite straightforward to implement and that sometimes perform
    quite well despite their simplicity.'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: '*人工智能*现在通常指的是机器学习中的深度学习部分，即高级神经网络，通常节点（神经元）之间有数百万到数十亿个连接。SNOBOL并不是一个适合这种模型的好选择。然而，经典的机器学习包括一些基础算法，这些算法有时非常简单，尽管如此，它们有时仍然能表现得相当出色。'
- en: Therefore, the goal of this section is to build a complete SNOBOL application
    to classify datasets using a simple machine learning technique—a *nearest neighbor*
    classifier.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，本节的目标是构建一个完整的SNOBOL应用程序，使用简单的机器学习技术——*最近邻*分类器来对数据集进行分类。
- en: '***Machine Learning 101***'
  id: totrans-290
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***机器学习入门***'
- en: Machine learning maps feature vectors to class labels. A *feature vector* is
    a collection of numeric values called *features*; that’s our input. We take this
    input and try to assign it a *class label*, that is, a category or class. For
    example, one of the datasets we’ll work with relates to iris flowers. This dataset
    is perhaps the oldest in machine learning and one of the easiest to work with.
    It consists of 150 measurements of three different species of iris flowers.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 机器学习将特征向量映射到类别标签。*特征向量*是一组数值称为*特征*；这就是我们的输入。我们获取这个输入并尝试为其分配一个*类别标签*，即一个类别或种类。例如，我们将要使用的一个数据集与鸢尾花相关。这个数据集可能是机器学习中最古老的之一，也是最容易处理的之一。它包含了三种不同品种的鸢尾花的150个测量值。
- en: 'There are four measurements per flower: two measuring the petal length and
    width and two measuring the sepal length in width. These four measurements are
    the features and the three different species are the classes.'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 每朵花有四个测量值：两个测量花瓣的长度和宽度，两个测量萼片的长度和宽度。这四个测量值是特征，三种不同的品种是类别。
- en: Machine learning models must be trained so they can place an unknown sample
    into the correct class. *Training* involves learning the parameters of the model
    using a training set, a collection of feature vectors (*x*) and corresponding
    class labels (*y*). This is what the iris dataset gives us. The training set has
    50 examples of each class, that is, each species of flower. We’ll use 100 of these
    150 examples to train the classifier and the remaining 50 to test the model to
    see how well it learned to distinguish between iris species.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 机器学习模型必须经过训练，才能将未知样本归入正确的类别。*训练*包括使用训练集来学习模型的参数，训练集是由特征向量（*x*）和相应的类别标签（*y*）组成的集合。这就是鸢尾花数据集提供的内容。训练集包含每个类别的50个样本，也就是每个花卉物种的样本。我们将使用这150个样本中的100个来训练分类器，其余50个用来测试模型，看看它学习区分鸢尾花物种的效果如何。
- en: We hope that when given a set of features for a new flower the trained model
    will be able to place the new flower into the correct class (in other words, correctly
    identify the species). The nearest neighbor classifier treats the feature vector
    as a point in a multidimensional space, in this case a 4D space for the iris dataset,
    as there are four features per sample. The idea is to find the training set sample
    whose feature vector is the closest to the feature vector of the unknown input
    and then assign the unknown input to the training sample class. In this case,
    closest means the training sample with the smallest *distance* to the unknown
    input.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望当给定一组新的花卉特征时，训练好的模型能够将新花卉归入正确的类别（换句话说，正确识别物种）。最近邻分类器将特征向量视为多维空间中的一个点，在鸢尾花数据集的情况下，这是一个4维空间，因为每个样本有四个特征。其思路是找到训练集中最接近未知输入特征向量的训练样本，然后将未知输入归入该训练样本的类别。在这种情况下，最接近意味着训练样本与未知输入之间的*距离*最小。
- en: There are many concept words in the paragraphs above, so let’s make sure we
    know what they mean. Once we do, the operation of the classifier will become apparent
    or even obvious. [Table 5-1](ch05.xhtml#ch05tab1) presents a brief machine learning
    glossary.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 上述段落中有许多概念词汇，让我们确保理解它们的含义。一旦理解了这些，分类器的操作就会变得显而易见，甚至是显而易懂的。[表 5-1](ch05.xhtml#ch05tab1)
    提供了简明的机器学习词汇表。
- en: '**Table 5-1:** A Brief Machine Learning Glossary'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: '**表 5-1：** 简明机器学习词汇表'
- en: '| **Term** | **Meaning** |'
  id: totrans-297
  prefs: []
  type: TYPE_TB
  zh: '| **术语** | **含义** |'
- en: '| --- | --- |'
  id: totrans-298
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| Feature | A measurement or characteristic of the data |'
  id: totrans-299
  prefs: []
  type: TYPE_TB
  zh: '| 特征 | 数据的测量或特性 |'
- en: '| Feature vector | A collection of features describing an instance |'
  id: totrans-300
  prefs: []
  type: TYPE_TB
  zh: '| 特征向量 | 描述实例的特征集合 |'
- en: '| Class | The label, or group, the instance belongs to |'
  id: totrans-301
  prefs: []
  type: TYPE_TB
  zh: '| 类别 | 实例所属的标签或组 |'
- en: '| Model | A means for mapping feature vectors to class labels |'
  id: totrans-302
  prefs: []
  type: TYPE_TB
  zh: '| 模型 | 将特征向量映射到类别标签的手段 |'
- en: '| Training | Using known feature vectors to teach the model |'
  id: totrans-303
  prefs: []
  type: TYPE_TB
  zh: '| 训练 | 使用已知特征向量来教模型 |'
- en: '| Distance | The straight-line distance between two points |'
  id: totrans-304
  prefs: []
  type: TYPE_TB
  zh: '| 距离 | 两点之间的直线距离 |'
- en: 'All machine learning models implement two phases: training and inference. During
    training, the training set, that is, the collection of feature vectors and their
    known class labels, is used to adjust the model’s parameters to the task at hand.
    Once trained, the model can be used for inference to assign class labels to new,
    unknown feature vectors. For the nearest neighbor classifier, training is so trivial
    as to be nonexistent: we use the training set as it is, as there are no parameters
    to learn.'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 所有机器学习模型都实现两个阶段：训练和推断。在训练阶段，使用训练集，即特征向量和已知类别标签的集合，来调整模型的参数以适应当前任务。一旦训练完成，模型就可以用于推断，将类别标签分配给新的未知特征向量。对于最近邻分类器来说，训练几乎是不存在的：我们直接使用训练集，因为没有需要学习的参数。
- en: To classify feature vectors, we scan through the training set to calculate the
    distance between the unknown feature vector and each of the training samples to
    find the closest training sample. We use that training sample’s class label as
    the class label for the unknown feature vector.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 为了分类特征向量，我们扫描训练集，计算未知特征向量与每个训练样本之间的距离，以找到最接近的训练样本。然后，我们使用该训练样本的类别标签作为未知特征向量的类别标签。
- en: For example, if we have a new set of measurements for an iris flower but don’t
    know its species, the nearest neighbor classifier searches the list of training
    set feature vectors for the sample closest to the unknown feature vector. It then
    declares the unknown input to be of the same class.
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果我们有一组新的鸢尾花测量数据，但不知道它的物种，最近邻分类器会在训练集的特征向量列表中搜索与未知特征向量最接近的样本。然后，它会将未知输入声明为与该样本属于相同类别。
- en: The word *distance* has been mentioned a few times now. Let’s put a formula
    to the word, so we have a way to measure the distance between two feature vectors.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 词语 *distance* 已经提到过几次了。让我们给这个词加一个公式，这样我们就有了一种衡量两个特征向量之间距离的方法。
- en: There are different types of distances, but the one we’ll use here is the *Euclidean
    distance*, which is a generalization of the Pythagorean theorem. For example,
    in 4D, the distance between two points, (*x*[0], *y*[0], *a*[0], *b*[0]) and (*x*[1],
    *y*[1], *a*[1], *b*[1]), is
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 有不同类型的距离度量，但我们在这里使用的是 *欧几里得距离*，它是勾股定理的推广。例如，在4D空间中，两个点之间的距离，(*x*[0]，*y*[0]，*a*[0]，*b*[0])
    和 (*x*[1]，*y*[1]，*a*[1]，*b*[1])，是
- en: '![Image](Images/f0153-01.jpg)'
  id: totrans-310
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/f0153-01.jpg)'
- en: If we have 3D feature vectors, the distance between two points, (*x*[0], *y*[0],
    *z*[0]) and (*x*[1], *y*[1], *z*[1]), is
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们有3D特征向量，则两个点之间的距离，(*x*[0]，*y*[0]，*z*[0]) 和 (*x*[1]，*y*[1]，*z*[1])，是
- en: '![Image](Images/f0153-02.jpg)'
  id: totrans-312
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/f0153-02.jpg)'
- en: For *n*-dimensional feature vectors, the distance is
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 *n* 维特征向量，距离是
- en: '![Image](Images/f0153-03.jpg)'
  id: totrans-314
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/f0153-03.jpg)'
- en: for two feature vectors, *x* and *y*. In the equation above, *i* is an index
    into the components of the vector. When we implement the Euclidean distance in
    code, *i* will be an index into an array.
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 对于两个特征向量，*x* 和 *y*。在上述公式中，*i* 是向量组件的索引。当我们在代码中实现欧几里得距离时，*i* 将是数组的索引。
- en: The training set and the Euclidean distance are all we need to implement the
    nearest neighbor classifier, but how will we know if it’s working? For that, we
    need test data. This is another dataset like the training set, but one that wasn’t
    used to train the model.
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 训练集和欧几里得距离是实现最近邻分类器所需的一切，但我们怎么知道它是否有效呢？为此，我们需要测试数据集。这是另一个像训练集一样的数据集，但没有用于训练模型。
- en: We know the feature vectors and the correct class label for the test set. We’ll
    run each test set feature vector through the model, comparing the classifier’s
    predicted label with the correct class label. There are many ways to characterize
    the performance of a machine learning model, but in this case, all we need to
    measure is the model’s accuracy.
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 我们知道特征向量和测试集的正确类标签。我们将把每个测试集的特征向量输入模型，比较分类器预测的标签与正确的类标签。有许多方法可以描述机器学习模型的性能，但在这种情况下，我们只需要衡量模型的准确性。
- en: '![Image](Images/f0153-04.jpg)'
  id: totrans-318
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/f0153-04.jpg)'
- en: A classifier that randomly guesses class labels will only be correct, on average,
    one time in *c*, where *c* is the number of classes in the dataset. There are
    three classes for the iris flowers, so we’d expect, if guessing, to be correct
    one time out of three, or about 33 percent of the time, meaning the accuracy is
    0.3333\. A perfect classifier makes no mistakes and has an accuracy of 1.0 or
    100 percent.
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 一个随机猜测类标签的分类器平均每次只会猜对一次，猜对的概率为 *c*，其中 *c* 是数据集中的类别数。鸢尾花有三种类别，因此我们期望在随机猜测的情况下，每三次中有一次猜对，或者大约33%的时间猜对，这意味着准确率为0.3333。一个完美的分类器不会犯错，准确率为1.0或100%。
- en: We now have enough background to get started. We have a model and we know how
    to train it and test it. Let’s write some code.
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在有足够的背景知识来开始了。我们有一个模型，知道如何训练它和测试它。让我们编写一些代码。
- en: '***Implementing the Classifier***'
  id: totrans-321
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***实现分类器***'
- en: 'Let’s implement the classifier. Here’s our plan of attack:'
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们实现分类器。以下是我们的攻击计划：
- en: Load the training and test datasets into SNOBOL arrays.
  id: totrans-323
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将训练集和测试集加载到 SNOBOL 数组中。
- en: For each test sample, assign the class label of the closest training set sample.
  id: totrans-324
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于每个测试样本，分配最接近训练集样本的类标签。
- en: Compare the assigned labels to the known test labels.
  id: totrans-325
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 比较分配的标签和已知的测试标签。
- en: Report the classifier’s accuracy.
  id: totrans-326
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 报告分类器的准确率。
- en: The code that follows is in the file *classify.sno*.
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码位于文件 *classify.sno* 中。
- en: '**Loading the Data**'
  id: totrans-328
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**加载数据**'
- en: This book’s GitHub site contains several datasets. Let’s walk through an example
    using the iris dataset. We’ll classify the others later.
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 本书的 GitHub 网站包含了几个数据集。让我们通过一个使用鸢尾花数据集的示例来进行演示。我们稍后会分类其他数据集。
- en: 'The iris dataset is in four text files in the *datasets* directory:'
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 鸢尾花数据集位于 *datasets* 目录中的四个文本文件中：
- en: '[PRE53]'
  id: totrans-331
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: The first two contain training data and the associated class labels. The second
    two hold test data.
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 前两个文件包含训练数据和相关的类标签。后两个文件包含测试数据。
- en: For example, the training datafile begins with
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，训练数据文件以
- en: '[PRE54]'
  id: totrans-334
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: with the associated class labels
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 和相关的类标签一起开始
- en: '[PRE55]'
  id: totrans-336
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: meaning the first feature vector is a class 1 instance, whereas the second feature
    vector is an instance of class 0, and so on. The test dataset files are structured
    similarly.
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 意味着第一个特征向量是类别1的实例，而第二个特征向量是类别0的实例，以此类推。测试数据集文件的结构也类似。
- en: We need SNOBOL code to load these text files. We’ll develop generic code, a
    SNOBOL function to load any datafile arranged such that each row represents a
    sample and each column represents a feature. Most machine learning datasets are
    structured this way.
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要SNOBOL代码来加载这些文本文件。我们将开发通用代码，一个SNOBOL函数来加载任何数据文件，要求每一行代表一个样本，每一列代表一个特征。大多数机器学习数据集都是以这种方式结构化的。
- en: The iris training data results in a 2D array with 100 rows and four columns
    because there are four features per sample and 100 samples in the training set.
    The training labels will become a 2D array as well, with 100 rows and one column.
    This simplifies the implementation.
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 鸢尾花训练数据生成一个二维数组，包含100行和四列，因为每个样本有四个特征，训练集中有100个样本。训练标签也会变成一个二维数组，包含100行和一列。这简化了实现。
- en: '[Listing 5-24](ch05.xhtml#ch05list24) shows a function to load datafiles. It’s
    the most complex piece of code we need to develop, so it’s best to start with
    the worst, knowing that things will get easier later.'
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: '[列表 5-24](ch05.xhtml#ch05list24)显示了一个加载数据文件的函数。这是我们需要开发的最复杂的代码，因此最好从最难的部分开始，知道接下来会变得更简单。'
- en: '[PRE56]'
  id: totrans-341
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: '*Listing 5-24: Loading a datafile*'
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 5-24：加载数据文件*'
- en: The function accepts the name of the text file to load ➊. Notice the list of
    local variables. This prevents hard-to-detect errors whereby the function might
    alter a global variable. The function itself consists of two loops. The first
    loop, from label `loadfile` through label `load_l00`, reads a line of text from
    the input file and parses it to count the number of features per sample. When
    the program reaches label `load_l00`, the number of rows in the file is in `r`
    and the number of columns is in `c`.
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 该函数接受要加载的文本文件名 ➊。请注意本地变量的列表。这可以防止难以检测的错误，例如函数可能会更改全局变量。函数本身由两个循环组成。第一个循环，从标签`loadfile`到标签`load_l00`，从输入文件中读取一行文本，并解析它以计算每个样本的特征数。当程序到达标签`load_l00`时，文件中的行数存储在`r`中，列数存储在`c`中。
- en: To extract a number from the current line, we do two things. First, we add a
    blank space to the input line (see label `load_l02`). Next, we perform a pattern
    match and update (see label `load_l03`). The pattern ➋ uses `break` to match all
    text up to the first blank, storing it in `v`, and then matches any number of
    blanks with `span`. The net effect of `pat` is to grab the text representing a
    feature value and end with the cursor at the beginning of the next feature. Label
    `load_l03` assigns nothing to the matched text, thereby removing it from `text`.
    This process repeats, with `c` incremented until the line is empty and the match
    fails to cause a jump to label `load_l01` to increment `r` and advance to the
    next line of the input file. When the input file is exhausted, control moves to
    label `load_l00` to close the file.
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 从当前行提取数字时，我们做了两件事。首先，我们在输入行中添加一个空格（参见标签`load_l02`）。接下来，我们执行模式匹配并更新（参见标签`load_l03`）。模式
    ➋ 使用`break`匹配直到第一个空格的所有文本，将其存储在`v`中，然后用`span`匹配任何数量的空格。`pat`的最终效果是抓取表示特征值的文本，并将光标停留在下一个特征的开头。标签`load_l03`不会将匹配的文本赋值，因此会将其从`text`中移除。这个过程会重复，`c`逐渐增加，直到行为空，匹配失败时跳转到标签`load_l01`，递增`r`并进入输入文件的下一行。当输入文件读取完毕，控制转到标签`load_l00`关闭文件。
- en: The purpose of the first loop is to learn the file’s dimensionality; it’s in
    `r` and `c`. The return value of the function is defined as an array of the appropriate
    size ➌.
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个循环的目的是了解文件的维度；它存储在`r`和`c`中。函数的返回值被定义为一个适当大小的数组 ➌。
- en: The input file is opened a second time, and the same read process happens again.
    This time, each matched feature value in `v` is placed into the array as a floating-point
    number ➍. When the input file is again empty, the function returns.
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 输入文件再次被打开，相同的读取过程再次发生。这一次，`v`中的每个匹配的特征值会作为浮点数 ➍ 被放入数组。当输入文件再次为空时，函数返回。
- en: '**Calculating the Distance**'
  id: totrans-347
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**计算距离**'
- en: Classifying an unknown sample requires computing the distance between pairs
    of feature vectors. The code to do this is in `dist`. See [Listing 5-25](ch05.xhtml#ch05list25).
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 对未知样本进行分类需要计算特征向量对之间的距离。执行此操作的代码在`dist`中。参见[列表 5-25](ch05.xhtml#ch05list25)。
- en: '[PRE57]'
  id: totrans-349
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: '*Listing 5-25: Calculating the Euclidean distance*'
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 5-25：计算欧几里得距离*'
- en: The arguments to `dist` are the two datasets, `x` and `y`, which are 2D, and
    the rows to work with, `i` and `j`. The distance is the sum of the differences
    of each feature for the given rows. These are the columns of the arrays that we
    index with `k`.
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: '`dist` 的参数是两个数据集，`x` 和 `y`，它们是二维的，以及要处理的行，`i` 和 `j`。距离是给定行每个特征差异的总和。这些是我们用
    `k` 索引的数组的列。'
- en: The label `dist_l00` does all the work. It adds the square of the difference
    between the *k*th columns of `x` and `y` for the given rows to the existing sum.
    The loop fails when `k` exceeds the array’s bounds. The return value is the square
    root of this sum (the label `dist_l01`).
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 标签 `dist_l00` 完成了所有的工作。它将 `x` 和 `y` 在给定行的 *k* 列之间的差异的平方加到现有的总和中。当 `k` 超过数组边界时，循环会停止。返回值是这个总和的平方根（标签
    `dist_l01`）。
- en: Some readers might be a bit confused by [Listing 5-25](ch05.xhtml#ch05list25),
    as `sum` is updated without being initialized. There is no error. SNOBOL treats
    undefined variables as null and adding a number to null returns the number, so
    there is no need to initialize `sum` explicitly.
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 一些读者可能会对 [列表 5-25](ch05.xhtml#ch05list25) 感到有些困惑，因为 `sum` 在没有初始化的情况下被更新。其实没有错误。SNOBOL
    会将未定义的变量视为 null，将一个数字加到 null 上会返回这个数字，因此不需要显式初始化 `sum`。
- en: '**Finding the Nearest Training Sample**'
  id: totrans-354
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**寻找最近的训练样本**'
- en: We need to find the training sample that is closest to a given test sample.
    For that, we use the function `nearest`. See [Listing 5-26](ch05.xhtml#ch05list26).
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要找到与给定测试样本最接近的训练样本。为此，我们使用函数 `nearest`。参见 [列表 5-26](ch05.xhtml#ch05list26)。
- en: '[PRE58]'
  id: totrans-356
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: '*Listing 5-26: Finding the nearest training sample*'
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 5-26：寻找最近的训练样本*'
- en: '[Listing 5-26](ch05.xhtml#ch05list26) actually defines two functions, `nearest`
    and `samples` (which is used by `nearest`). Let’s start with `samples`. It returns
    the number of rows in a 2D array. Given how we organize the data, that’s a sample,
    a feature vector.'
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: '[列表 5-26](ch05.xhtml#ch05list26) 实际上定义了两个函数，`nearest` 和 `samples`（`nearest`
    使用了 `samples`）。我们先从 `samples` 开始。它返回一个二维数组中的行数。根据我们组织数据的方式，这就是一个样本，一个特征向量。'
- en: The `samples` function defines a pattern (`pat`), matching text up to the first
    comma and storing it in the function name (`samples`). It then applies this pattern
    to whatever is returned by the SNOBOL `prototype` function. This function returns
    a string specifying the dimensionality of an array. Recall that arrays are declared
    using a string to specify the number and size of the dimensions. Our arrays are
    2D, so `prototype` returns a string like `'100,4'`. The pattern extracts the first
    number. We won’t use it, but *classify.sno* also defines `features`, which is
    a function to return the number of features, the second number returned by `prototype`.
    Do take a look.
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: '`samples` 函数定义了一个模式（`pat`），匹配文本直到第一个逗号，并将其存储在函数名（`samples`）中。然后它将这个模式应用到 SNOBOL
    的 `prototype` 函数返回的内容。该函数返回一个字符串，指定数组的维度。回想一下，数组是使用一个字符串声明的，该字符串指定了维度的数量和大小。我们的数组是二维的，所以
    `prototype` 返回一个类似 `''100,4''` 的字符串。该模式提取第一个数字。我们不会使用它，但 *classify.sno* 还定义了 `features`，这是一个返回特征数量的函数，即
    `prototype` 返回的第二个数字。请务必查看一下。'
- en: The algorithm for `nearest` scans through the training data, calculating the
    distance between the current training sample and the specified test sample. If
    that distance is smaller than the smallest found so far, it keeps track of the
    distance and the training sample’s class label. When the algorithm completes its
    pass through the training data, it returns the class label of the smallest distance;
    `nearest` classifies a given test set sample.
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: '`nearest` 算法扫描训练数据，计算当前训练样本与指定测试样本之间的距离。如果这个距离小于迄今为止找到的最小值，它会记录下这个距离和训练样本的类别标签。当算法完成对训练数据的遍历时，它返回最小距离对应的类别标签；`nearest`
    对给定的测试集样本进行分类。'
- en: The long list of parameters to `nearest` passes the training set, both data
    (`xtrn`) and labels (`ytrn`), along with the test set data and labels, and `idx`,
    which is the current test set sample to classify.
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: '`nearest` 的长参数列表传递了训练集，包括数据（`xtrn`）和标签（`ytrn`），以及测试集的数据和标签，还有 `idx`，即当前要分类的测试集样本。'
- en: The loop over the training set tracks `md`, which is the smallest distance found
    so far, storing the associated class label in `nearest`, the function value. The
    loop ends when `le(i,s)` fails where `i` is the row index and `s` is the number
    of samples in the training set. If `lt(d,md)` succeeds, the algorithm updates
    `md` and `nearest`.
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: 对训练集的循环跟踪 `md`，即迄今为止找到的最小距离，并将关联的类标签存储在 `nearest` 中，该函数值也存在其中。当 `le(i,s)` 失败时，循环结束，其中
    `i` 是行索引，`s` 是训练集中的样本数。如果 `lt(d,md)` 成功，算法会更新 `md` 和 `nearest`。
- en: '**The Main Code**'
  id: totrans-363
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**主代码**'
- en: The sections above describe the functions implementing each phase of the classification
    task. The main code, at the bottom of *classify.sno*, pulls these pieces together
    (see [Listing 5-27](ch05.xhtml#ch05list27)).
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: 上述各节描述了实现分类任务每个阶段的函数。底部的主代码（见 [列表 5-27](ch05.xhtml#ch05list27)）将这些部分结合在一起。
- en: '[PRE59]'
  id: totrans-365
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: '*Listing 5-27: Putting the classifier together*'
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 5-27：将分类器组合在一起*'
- en: '[Listing 5-27](ch05.xhtml#ch05list27) first loads the training and test data.
    The feature vectors are in `x_train` and `x_test`, respectively. The associated
    class labels are in `y_train` and `y_test`. The filenames are passed on the command
    line, after *classify.sno*, with the training data and labels first, followed
    by test data and labels.'
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: '[列表 5-27](ch05.xhtml#ch05list27) 首先加载训练和测试数据。特征向量分别存储在 `x_train` 和 `x_test`
    中。关联的类标签分别存储在 `y_train` 和 `y_test` 中。文件名通过命令行传递，在 *classify.sno* 后面，首先是训练数据和标签，然后是测试数据和标签。'
- en: The following code is a loop that runs through each test sample. The call to
    `nearest` returns the assigned class label for test sample `i`. If the classification
    is correct, it increments the number correct counter, `nc` ➊. Note that the SNOBOL
    construct of using the `eq` predicate in the same update statement. If the classification
    is wrong, `eq` fails, and the rest of the statement is skipped. There is no failure
    label, so execution continues with the next line. When all test samples have been
    classified, the overall accuracy is displayed before exiting.
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码是一个循环，遍历每个测试样本。对 `nearest` 的调用返回测试样本 `i` 的分配类标签。如果分类正确，它会增加正确计数器 `nc` ➊。注意
    SNOBOL 语法中使用 `eq` 谓词的构造，这在同一个更新语句中完成。如果分类错误，`eq` 失败，语句的其余部分被跳过。没有失败标签，所以执行会继续到下一行。当所有测试样本都被分类后，整体准确度会显示出来，然后退出。
- en: 'The implementation is complete. Now the million-dollar question: does it work?
    Let’s see.'
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: 实现已完成。现在，百万美元的问题是：它有效吗？我们来看看。
- en: '***Using the Classifier***'
  id: totrans-370
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***使用分类器***'
- en: Let’s run *classify.sno* against the examples in the *datasets* directory. These
    datasets can be found on the UCI Machine Learning Repository website (*[https://archive.ics.uci.edu/ml/index.php](https://archive.ics.uci.edu/ml/index.php)*).
    I downloaded the datasets and processed them to be in the form expected by *classify.sno*.
    The full dataset was randomly partitioned into training and test datasets using
    an 80/20 split. Feature vectors are in the “data” files, with the class labels,
    matching line for line, in the “labels” files.
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们运行 *classify.sno* 来处理 *datasets* 目录中的示例。这些数据集可以在 UCI 机器学习库网站上找到（*[https://archive.ics.uci.edu/ml/index.php](https://archive.ics.uci.edu/ml/index.php)*）。我下载了数据集并进行了处理，使其符合
    *classify.sno* 期望的格式。整个数据集被随机划分为训练数据集和测试数据集，采用 80/20 的比例。特征向量存储在“data”文件中，类标签按行与“labels”文件中的数据一一对应。
- en: The available datasets include those shown in [Table 5-2](ch05.xhtml#ch05tab2).
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: 可用的数据集包括 [表 5-2](ch05.xhtml#ch05tab2) 中显示的那些。
- en: '**Table 5-2:** Available Datasets'
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: '**表 5-2：** 可用数据集'
- en: '| **Dataset** | **Features** | **Classes** | **Description** |'
  id: totrans-374
  prefs: []
  type: TYPE_TB
  zh: '| **数据集** | **特征** | **类别** | **描述** |'
- en: '| --- | --- | --- | --- |'
  id: totrans-375
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- |'
- en: '| banknote | 4 | 2 | Real or counterfeit notes |'
  id: totrans-376
  prefs: []
  type: TYPE_TB
  zh: '| 银行票据 | 4 | 2 | 真假钞票 |'
- en: '| cancer | 10 | 2 | Breast cancer histology slide features |'
  id: totrans-377
  prefs: []
  type: TYPE_TB
  zh: '| 癌症 | 10 | 2 | 乳腺癌组织切片特征 |'
- en: '| ecoli | 7 | 8 | Characterizing *E. coli* bacteria |'
  id: totrans-378
  prefs: []
  type: TYPE_TB
  zh: '| 大肠杆菌 | 7 | 8 | 描述 *大肠杆菌* |'
- en: '| haberman | 3 | 2 | Five year breast cancer survival |'
  id: totrans-379
  prefs: []
  type: TYPE_TB
  zh: '| 哈伯曼 | 3 | 2 | 五年乳腺癌生存率 |'
- en: '| iris | 4 | 3 | Types of irises |'
  id: totrans-380
  prefs: []
  type: TYPE_TB
  zh: '| 鸢尾花 | 4 | 3 | 鸢尾花种类 |'
- en: '| seeds | 7 | 3 | Types of seeds |'
  id: totrans-381
  prefs: []
  type: TYPE_TB
  zh: '| 种子 | 7 | 3 | 种子类型 |'
- en: '| wine | 13 | 3 | Wine origin |'
  id: totrans-382
  prefs: []
  type: TYPE_TB
  zh: '| 葡萄酒 | 13 | 3 | 葡萄酒来源 |'
- en: 'Let start with the irises. To run the classifier, use the following command
    line:'
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: 从鸢尾花开始。要运行分类器，请使用以下命令行：
- en: '[PRE60]'
  id: totrans-384
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: The output begins with
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: 输出从以下内容开始：
- en: '[PRE61]'
  id: totrans-386
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: and ends with
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: 并以此结束：
- en: '[PRE62]'
  id: totrans-388
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: There are 50 test samples and the assigned and actual class labels are displayed
    for each sample. If the classifier made a mistake, the output is followed by `**`
    to mark it.
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: 有50个测试样本，并显示每个样本的分配类别和实际类别标签。如果分类器出错，输出后会跟随`**`标记。
- en: The overall accuracy was 96 percent, with only two mistakes. For such a simple
    classifier, this is not too shabby. Note that both errors were confusing between
    class 1 and class 2\. For the iris dataset, class 0 is easily distinguished from
    the other two, but class 1 and class 2 are relatively similar, so they are more
    likely to be confused.
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: 总体准确率为96%，仅有两次错误。对于这样一个简单的分类器来说，表现相当不错。需要注意的是，两个错误都是在类别1和类别2之间的混淆。对于iris数据集，类别0与其他两个类别容易区分，但类别1和类别2相对相似，因此更容易混淆。
- en: Run the other example datasets in the same way. [Table 5-3](ch05.xhtml#ch05tab3)
    shows the statistics, including the accuracy, number correctly classified, number
    tested, and the size of the training set.
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: 以相同的方式运行其他示例数据集。[表 5-3](ch05.xhtml#ch05tab3)展示了统计数据，包括准确率、正确分类的数量、测试数量和训练集的大小。
- en: '**Table 5-3:** Nearest Neighbor Classifier Accuracies by Dataset'
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
  zh: '**表 5-3：** 最近邻分类器在不同数据集上的准确率'
- en: '| **Dataset** | **Accuracy (%)** | **Correct** | **Test** | **Train** |'
  id: totrans-393
  prefs: []
  type: TYPE_TB
  zh: '| **数据集** | **准确率（%）** | **正确** | **测试** | **训练** |'
- en: '| --- | --- | --- | --- | --- |'
  id: totrans-394
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- | --- |'
- en: '| banknote | 100.0 | 275 | 275 | 1097 |'
  id: totrans-395
  prefs: []
  type: TYPE_TB
  zh: '| banknote | 100.0 | 275 | 275 | 1097 |'
- en: '| cancer | 94.2 | 129 | 137 | 546 |'
  id: totrans-396
  prefs: []
  type: TYPE_TB
  zh: '| cancer | 94.2 | 129 | 137 | 546 |'
- en: '| ecoli | 86.8 | 59 | 68 | 268 |'
  id: totrans-397
  prefs: []
  type: TYPE_TB
  zh: '| ecoli | 86.8 | 59 | 68 | 268 |'
- en: '| haberman | 67.2 | 41 | 61 | 245 |'
  id: totrans-398
  prefs: []
  type: TYPE_TB
  zh: '| haberman | 67.2 | 41 | 61 | 245 |'
- en: '| iris | 96.0 | 48 | 50 | 100 |'
  id: totrans-399
  prefs: []
  type: TYPE_TB
  zh: '| iris | 96.0 | 48 | 50 | 100 |'
- en: '| seeds | 92.9 | 39 | 42 | 168 |'
  id: totrans-400
  prefs: []
  type: TYPE_TB
  zh: '| seeds | 92.9 | 39 | 42 | 168 |'
- en: '| wine | 83.3 | 30 | 36 | 142 |'
  id: totrans-401
  prefs: []
  type: TYPE_TB
  zh: '| wine | 83.3 | 30 | 36 | 142 |'
- en: The results range from perfection (banknotes) to a low of 67 percent (haberman).
    However, all things considered, this simple classifier performed quite well on
    these datasets.
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
  zh: 结果从完美（钞票）到最低的67%（haberman）。然而，综合来看，这个简单的分类器在这些数据集上表现得相当不错。
- en: 'There is another name for the nearest neighbor classifier: 1-nearest neighbor,
    where the *1* means only the nearest training sample is considered. This classifier
    can be generalized to consider the *k*-nearest neighbors where *k* > 1 and is
    odd. For a *k*-nearest neighbor classifier, the *k*-nearest neighbors are located.
    The assigned class is the result of voting among the *k*-nearest neighbors. In
    the event of a tie, select one of the neighbors at random. Although nearest neighbor
    classifiers are seldom used, *k*-nearest neighbor classifiers are still an active
    research area in machine learning. I leave it as an exercise for the reader to
    convert *classify.sno* into a *k*-nearest neighbor classifier.'
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
  zh: 最近邻分类器还有另一个名字：1-最近邻，其中*1*表示只考虑最接近的训练样本。这个分类器可以推广到考虑*k*个最近邻，其中*k* > 1且是奇数。对于*k*最近邻分类器，会定位到*k*个最近的邻居。分配的类别是基于*k*个最近邻的投票结果。如果发生平局，则随机选择一个邻居。虽然最近邻分类器很少使用，但*k*最近邻分类器仍然是机器学习中的一个活跃研究领域。我将此作为练习留给读者，要求将*classify.sno*转化为*k*最近邻分类器。
- en: '**NOTE**'
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
  zh: '**备注**'
- en: '*The world of machine learning offers much more than the tiny bit we’ve explored
    here. Witness the rapidly expanding world of deep learning, which has already
    greatly affected our daily lives and will continue to do so for years to come.
    If your interest has been piqued, please take a look at my deep learning books*
    Practical Deep Learning: A Python-Based Introduction (2021) *and* Math for Deep
    Learning: What You Need to Know to Understand Neural Networks *(2021). Both are
    available from No Starch Press.*'
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
  zh: '*机器学习的世界远不止我们在这里探讨的这些。看看快速发展的深度学习领域，它已经极大地影响了我们的日常生活，并将在未来几年继续产生影响。如果你对此感兴趣，欢迎阅读我的深度学习书籍*
    《实用深度学习：基于 Python 的入门》 (2021) *和* 《深度学习数学：理解神经网络所需的知识》 *(2021)。这两本书均由 No Starch
    Press 出版。*'
- en: '**Discussion**'
  id: totrans-406
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**讨论**'
- en: What should we make of SNOBOL? I’ll admit, I like the language. The flexibility
    of its arrays and the table data structure are surprisingly “modern.” I also like
    its pattern-matching abilities, dynamic data typing, and automatic memory management.
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
  zh: 我们该如何看待 SNOBOL？我承认，我喜欢这门语言。它的数组和表格数据结构的灵活性出乎意料地“现代”。我还喜欢它的模式匹配功能、动态数据类型和自动内存管理。
- en: But SNOBOL’s complete lack of structured programming abilities hurts. The only
    way to directly control program flow is with a goto. There are no structured control
    statements like `for` or `while`.
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
  zh: 但 SNOBOL 完全缺乏结构化编程能力是个问题。直接控制程序流的唯一方式是使用 goto。没有像 `for` 或 `while` 这样的结构化控制语句。
- en: Forth gets a bad rap for being a write-only programming language, but Forth
    uses structured programming, which is not even an option in SNOBOL. Using the
    success or failure of a statement as an essential element of program flow control
    is novel and intellectually engaging, but it ultimately makes working with the
    language difficult. However, I suspect much of that difficulty would fade with
    practice. The fact that SNOBOL labels are global is especially painful. Even some
    assemblers for old 8-bit microprocessors support local labels, something that
    would greatly benefit SNOBOL.
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
  zh: Forth 因为被认为是只能写入的编程语言而名声不好，但 Forth 使用结构化编程，而这在 SNOBOL 中根本不是一个选项。将语句的成功或失败作为程序流控制的关键元素是一种新颖且富有挑战性的思维方式，但最终使得使用该语言变得困难。然而，我怀疑这些困难通过练习会逐渐消失。SNOBOL
    的标签是全局的这一点尤其令人痛苦。即便是一些老式 8 位微处理器的汇编语言也支持局部标签，这对 SNOBOL 的帮助将是巨大的。
- en: Historically, SNOBOL had a reputation for being slow. Thus, a simple timing
    test comparing SNOBOL and Python seems in order.
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
  zh: 历史上，SNOBOL 有个慢的声誉。因此，进行一个简单的计时测试，比较 SNOBOL 和 Python 的性能，似乎是合适的。
- en: '[Listing 5-28](ch05.xhtml#ch05list28) shows two equivalent programs to initialize
    a 1,000,000-element array/list 20 times, first in Python and then in SNOBOL.'
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
  zh: '[列表 5-28](ch05.xhtml#ch05list28) 显示了两个等效程序，用于初始化一个包含 1,000,000 个元素的数组/列表 20
    次，首先在 Python 中，然后在 SNOBOL 中。'
- en: '[PRE63]'
  id: totrans-412
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: '*Listing 5-28: Comparing SNOBOL and Python*'
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 5-28：比较 SNOBOL 和 Python*'
- en: The median runtime on my machine over 10 runs each is 2.363 seconds for Python
    and 3.548 seconds for SNOBOL. So yes, SNOBOL is slower, but not dramatically so.
    Note that to run the SNOBOL code, use -d 1m on the command line to reserve enough
    memory for the array.
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
  zh: 在我的机器上，运行 10 次的中位运行时间分别为 Python 2.363 秒，SNOBOL 3.548 秒。所以，确实，SNOBOL 更慢，但并没有显著慢多少。请注意，要运行
    SNOBOL 代码，请在命令行上使用 -d 1m 来为数组保留足够的内存。
- en: In what ways does SNOBOL help us expand our conception of what it means to code?
    Several come to mind. SNOBOL uses global labels and is unstructured. This requires
    programmers to think clearly about the *entire* scope of the project, or at least
    to implement a disciplined approach to coding, one that is not enforced by the
    language itself as in other, newer programming languages. Without a global conception
    of the program, label confusion or spaghetti code is inevitable. Thus, clarity
    of thought is essential.
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
  zh: SNOBOL 如何帮助我们扩展对编程意义的理解？有几个方面我想到了。SNOBOL 使用全局标签并且没有结构化。这要求程序员清晰地思考项目的*整体*范围，或者至少实施一种有纪律的编码方法，这种方法在其他更新的编程语言中并不会像
    SNOBOL 那样由语言本身强制执行。如果没有对程序的全局概念，标签混乱或“意大利面条代码”是不可避免的。因此，清晰的思维是至关重要的。
- en: SNOBOL’s robust pattern matching and string update abilities enable a novel
    approach to string manipulation. As a result, some of the burden incumbent on
    the programmer regarding string manipulation in languages like C++, Python, or
    Java is alleviated. This means thinking in terms of strings and their evolution
    becomes a new paradigm for implementing algorithms.
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
  zh: SNOBOL 强大的模式匹配和字符串更新能力提供了一种新的字符串操作方式。因此，一些在 C++、Python 或 Java 等语言中，程序员需要处理的字符串操作负担被减轻了。这意味着在实现算法时，以字符串及其演变为思维方式，成为了一种新的范式。
- en: Lastly, SNOBOL requires thinking in terms of statement success *and* statement
    failure. Typically, coding is for success, as we don’t want failures to happen.
    Error control in SNOBOL is fine grained, which is both helpful and perhaps a bit
    dangerous.
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，SNOBOL 需要从语句成功*和*语句失败的角度来思考。通常，编程是为了成功，因为我们不希望失败发生。SNOBOL 中的错误控制非常精细，这既有帮助，也可能有点危险。
- en: All in all, SNOBOL is a surprisingly “modern” programming language. In many
    ways, it was well ahead of its time. SNOBOL itself evolved into Icon, also by
    Griswold, which uses structured programming constructs. Icon never caught on,
    but readers who are so inclined can learn more at *[https://www2.cs.arizona.edu/icon/](https://www2.cs.arizona.edu/icon/)*.
    Regardless, SNOBOL is worth a bit of continued effort on our part. Indeed, we’ll
    see SNOBOL again in [Chapter 10](ch10.xhtml#ch10) when we use it to implement
    Brainfuck.
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
  zh: 总的来说，SNOBOL是一种令人惊讶的“现代”编程语言。在许多方面，它远远领先于其时代。SNOBOL本身发展成了Icon，也是由Griswold开发的，后者采用了结构化编程构造。虽然Icon并没有流行起来，但有兴趣的读者可以在*
    [https://www2.cs.arizona.edu/icon/](https://www2.cs.arizona.edu/icon/)* 网站上了解更多内容。不管怎样，SNOBOL仍然值得我们付出一些持续的努力。事实上，我们将在[第10章](ch10.xhtml#ch10)中再次看到SNOBOL，并用它来实现Brainfuck。
- en: '**Summary**'
  id: totrans-419
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**总结**'
- en: This chapter introduced us to SNOBOL, a quirky pattern matching programming
    language from the 1960s. We worked through the language from its overall structure
    to specifics of its key features, with numerous examples. We learned about its
    unique approach to flow control and saw a tiny portion of its powerful text pattern
    matching abilities.
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
  zh: 本章向我们介绍了SNOBOL，这是一种源自1960年代的奇特模式匹配编程语言。我们从语言的整体结构到其关键特性的具体内容，逐步探讨了这个语言，并通过大量示例进行了说明。我们了解了它独特的流程控制方式，并见识了其强大的文本模式匹配能力的一小部分。
- en: We implemented a simple machine learning classifier in SNOBOL as an exercise
    and saw that it performed well against some small-scale machine learning datasets.
  id: totrans-421
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在SNOBOL中实现了一个简单的机器学习分类器作为练习，并发现它在一些小规模的机器学习数据集上表现良好。
- en: We ended the chapter by discussing the language, what we liked about it, and
    what we were less enthused about. Our ultimate conclusion was that SNOBOL well
    deserves of a place at our table as a novel language that can help us learn to
    think differently about coding.
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
  zh: 本章最后，我们讨论了这门语言，谈到了我们喜欢它的地方和不那么热衷的地方。我们的最终结论是，SNOBOL完全值得我们在编程语言的桌子上为它腾出一席之地，它是一种能够帮助我们以不同的方式思考编码的创新语言。
- en: Let’s leave SNOBOL, with its successes and failures, and jump forward to the
    latter Mesozoic so we can experience the awe and mystery of CLIPS, a language
    designed for expert system development.
  id: totrans-423
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们离开SNOBOL，带着它的成功和失败，跳跃到中生代后期，去体验CLIPS的敬畏与神秘，CLIPS是一种专为专家系统开发而设计的语言。
