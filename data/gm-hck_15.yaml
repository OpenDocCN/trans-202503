- en: '**11**'
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '**11**'
- en: '**PUTTING IT ALL TOGETHER: WRITING AUTONOMOUS BOTS**'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: '**将所有内容整合：编写自动化机器人**'
- en: '![image](../images/common.jpg)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/common.jpg)'
- en: The end goal of game hacking is to make a full-fledged automated bot capable
    of playing a game for hours on end. Such bots can heal, drink potions, farm monsters,
    loot corpses, walk around, sell loot, buy supplies, and more. Making bots this
    powerful requires you to combine your hooks and memory reads with concepts like
    control theory, state machines, and search algorithms, which are all covered in
    this chapter.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 游戏黑客的最终目标是制作一个功能完善的自动化机器人，能够连续数小时玩游戏。这些机器人可以治疗、喝药水、打怪、掠夺尸体、四处走动、出售战利品、购买补给等等。要制作出如此强大的机器人，需要将你的挂钩和内存读取与控制理论、状态机和搜索算法等概念结合，这些内容在本章中都有涉及。
- en: 'Throughout the lessons here, you’ll also learn about common automated hacks
    and how they should behave at a high level. After covering the theory and code
    behind automated hacks, I’ll give you a high-level look at two types of bots that
    rely on such code: *cavebots*, which can explore caves and bring home the loot,
    and *warbots*, which can fight enemies for you. By the end of the chapter, you
    should be ready to bust out your tools, fire up your development environment,
    and start making some really awesome bots.'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里的课程中，你还将学习常见的自动化黑客以及它们在高层次上应该如何表现。在讲解了自动化黑客背后的理论和代码后，我将从高层次上向你展示两种依赖于此类代码的机器人类型：*洞穴机器人*，它们可以探索洞穴并带回战利品；*战争机器人*，它们可以为你与敌人作战。到本章结束时，你应该准备好拿出你的工具，启动开发环境，开始制作一些非常酷的机器人。
- en: '**Control Theory and Game Hacking**'
  id: totrans-5
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**控制理论与游戏黑客**'
- en: '*Control theory* is a branch of engineering that provides a way to control
    the behavior of dynamic systems. Control theory determines the state of a *system*
    using *sensors*, after which a *controller* determines the set of actions needed
    to bring the system’s current state to some other desired state. After the controller
    executes the first action in the set, the entire process—known as a *feedback
    loop*—repeats (see [Figure 11-1](ch11.xhtml#ch11fig1)).'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: '*控制理论* 是一门工程学科，提供了一种控制动态系统行为的方法。控制理论使用*传感器*确定*系统*的状态，然后由*控制器*确定一组行动，来将系统的当前状态转变为另一个期望的状态。在控制器执行该行动集合中的第一个动作后，整个过程—称为*反馈回路*—会重复（参见[图
    11-1](ch11.xhtml#ch11fig1)）。'
- en: '![image](../images/f11-01.jpg)'
  id: totrans-7
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f11-01.jpg)'
- en: '*Figure 11-1: A control theory feedback loop*'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 11-1：控制理论反馈回路*'
- en: Let’s apply this feedback loop to game hacking. To automate play within a game
    (the system), a bot implements some algorithms (the controller) that understand
    how to play the game in any state observed by the memory reads, network hooks,
    and so on (the sensors). The controller typically has some human inputs, like
    the path to walk, creatures to attack, and loot to pick up. Thus, to reach the
    desired state, the controller must perform some subset of these inputs that are
    possible given the current state.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们将这个反馈回路应用到游戏黑客中。为了在游戏（系统）中实现自动化玩法，机器人实现一些算法（控制器），它们能够理解如何在内存读取、网络挂钩等所观察到的任何状态下进行游戏（传感器）。控制器通常有一些人类输入，比如行走的路径、攻击的生物和要拾取的战利品。因此，为了达到期望的状态，控制器必须执行一些子集的输入，这些输入在当前状态下是可能的。
- en: For instance, if there are no creatures onscreen and no corpses to loot, the
    desired state may be for the player to reach the next location (called a *waypoint*)
    in the predefined path. In this case, the controller moves the player one step
    closer to the waypoint on each iteration. If the player encounters a creature,
    the controller might decide to attack the creature in the first frame and, in
    the following frames, switch between running from the creature (known as *kiting*)
    and shooting spells at it. Once the creature dies, the controller executes a set
    of actions to loot the body and continue to the next waypoint.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果屏幕上没有生物，也没有尸体可以掠夺，那么期望的状态可能是玩家到达下一个位置（称为*路径点*）。在这种情况下，控制器会在每次迭代中将玩家向路径点推进一步。如果玩家遇到一个生物，控制器可能会在第一帧决定攻击这个生物，接下来的帧中则在逃跑（称为*拉扯*）和向其施放法术之间切换。一旦生物死亡，控制器会执行一系列操作来掠夺尸体并继续前往下一个路径点。
- en: Given this example of how a feedback loop might operate, it might seem overwhelming
    to code such a system. Luckily, there are a few design patterns that make the
    task much easier than it sounds.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 鉴于反馈回路可能如何运作的这个例子，编写这样一个系统可能看起来令人不知所措。幸运的是，有一些设计模式使得这项任务比听起来要容易得多。
- en: '**State Machines**'
  id: totrans-12
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**状态机**'
- en: '*State machines* are mathematical models of computation that describe how a
    system behaves based on input. [Figure 11-2](ch11.xhtml#ch11fig2) shows a simple
    state machine that reads a list of binary digits. The machine starts with an initial
    state of *S*[1]. As it iterates over the digits in the input, it changes its state
    accordingly. In this case, states *S*[1] and *S*[2] repeat themselves when the
    machine encounters a 1 and activate one another when it encounters a 0\. For example,
    for the binary digits 11000111, the state transitions would be *S*[1], *S*[1],
    *S*[2], *S*[1], *S*[2], *S*[2], *S*[2], and finally *S*[2].'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: '*状态机*是计算的数学模型，用来描述系统如何基于输入行为。[图11-2](ch11.xhtml#ch11fig2)展示了一个简单的状态机，它读取一组二进制数字。机器从初始状态*S*[1]开始。在遍历输入中的数字时，它会相应地改变自己的状态。在这种情况下，当机器遇到1时，状态*S*[1]和*S*[2]会自我重复，并且当遇到0时，它们会彼此激活。例如，对于二进制数字11000111，状态转换将是*S*[1]、*S*[1]、*S*[2]、*S*[1]、*S*[2]、*S*[2]、*S*[2]，最后是*S*[2]。'
- en: '![image](../images/f11-02.jpg)'
  id: totrans-14
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f11-02.jpg)'
- en: '*Figure 11-2: A simple state machine*'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: '*图11-2：一个简单的状态机*'
- en: With a small spin on the classical state machine theory, a state machine can
    be the controller in a control theory feedback loop. This tweaked version of a
    state machine comprises a list of states, the conditions signifying each state,
    and the actions that must happen to reach each state.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 通过对经典状态机理论稍作修改，状态机可以作为控制理论反馈回路中的控制器。这个修改后的状态机包括一组状态、每个状态的标志条件，以及为了到达每个状态而必须执行的动作。
- en: '**STATE MACHINES AND GAME HACKING**'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: '**状态机与游戏黑客**'
- en: A game-hacking state machine not only must keep an internal state but also must
    respond to (or *actuate*) the game environment based on that state. The overall
    game state can change based on your bot’s actuation, the behavior of other players,
    and other unpredictable occurrences in the game environment. For this reason,
    trying to persistently walk a state machine based on the observed game environment
    is futile; it’s nearly impossible to create a set of transitions for each state
    to account for every possible observation that can be made between iterations.
    It makes more sense for the state machine to reevaluate the game environment as
    a fresh slate each time it considers the input. To do this, the state machine
    must use the game environment itself as the mechanism for transitioning between
    states—that is, the machine’s actuation on the environment should have enough
    of an effect on the next iterations that it activates a new state. Classical state
    machines can be devised that are capable of working like this, but we’re going
    to flatten them out and use them in a much simpler, yet still very powerful, way.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 游戏黑客状态机不仅必须保持内部状态，还必须根据该状态响应（或*激活*）游戏环境。整体游戏状态可以根据你的机器人动作、其他玩家的行为以及游戏环境中其他不可预测的事件发生变化。因此，试图基于观察到的游戏环境持久地遍历一个状态机是徒劳的；几乎不可能为每个状态创建一组转换来应对每次迭代中可能发生的每个观察结果。更合理的做法是，让状态机每次在考虑输入时重新评估游戏环境，就像一个全新的起点。为了做到这一点，状态机必须使用游戏环境本身作为状态之间转换的机制——也就是说，机器对环境的激活应对下一次迭代产生足够的影响，从而激活新的状态。可以设计出能够像这样工作的经典状态机，但我们将简化它们，以更简单但仍然非常强大的方式使用它们。
- en: If you’re familiar with classical state machines, this may not seem intuitive,
    but in the coming sections you’ll see how state machines can be mutated and paired
    with control theory to achieve what we want.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你熟悉经典状态机，可能觉得这不太直观，但在接下来的章节中，你将看到状态机如何变异并与控制理论结合，以实现我们想要的效果。
- en: 'The major difference is that instead of one state merely activating another,
    for each state in a game automation state machine, a bot will perform in-game
    actions that change the overall state of the game and, thus, the state that is
    detected on the next iteration of the feedback loop. In code, an object to represent
    a state in this machine might look like this:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 主要的区别在于，游戏自动化状态机中的每个状态并不是简单地激活另一个状态，而是机器人将在游戏中执行改变游戏整体状态的动作，从而改变下次反馈回路迭代时检测到的状态。在代码中，表示这个状态机中某个状态的对象可能看起来像这样：
- en: '[PRE0]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'You can assemble `StateDefinition` objects into a state machine with a simple
    `std::vector` definition, like this:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以将`StateDefinition`对象通过一个简单的`std::vector`定义组装成一个状态机，像这样：
- en: '[PRE1]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: And presto, you have the skeleton of a state machine, ready to receive any `StateDefinition`
    objects you create. In conjunction with a feedback loop, this state machine can
    be used to define the flow of automation.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 于是，状态机的骨架就完成了，准备好接收你创建的任何`StateDefinition`对象。配合反馈循环，这个状态机可以用来定义自动化的流程。
- en: First, you can create a list of definitions that model your bot’s desired behavior,
    ordered in the vector by importance. Each `StateDefinition` object can use information
    from your sensors as input, passing that data to the `condition()` function to
    determine whether or not the state should be activated. Then, you can create a
    controller that loops over the list of states, calling the `reach()` function
    of the first state whose `condition()` function returns `false`. Finally, you
    can wrap the controller in a feedback loop. If you don’t see how this feedback
    loop would work yet, don’t worry; I’ll show you how to code it now.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，你可以创建一个定义列表，模型化你的机器人期望的行为，并按照重要性顺序排列。在该列表中的每个`StateDefinition`对象都可以使用来自传感器的信息作为输入，将这些数据传递给`condition()`函数，以判断是否应激活该状态。然后，你可以创建一个控制器，遍历状态列表，调用第一个`condition()`函数返回`false`的状态的`reach()`函数。最后，你可以将控制器包裹在反馈循环中。如果你还不明白这个反馈循环是如何工作的，别担心；我现在会向你展示如何编码实现。
- en: '**NOTE**'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*You can think of the statement in your* `condition()` *function as a requirement
    for the machine to transition to the next state. If the statement is true, it
    means no actuation must happen before the next state in the list can be evaluated
    and the loop can continue iterating. If the statement is false, it means some
    actuator must occur before the transition can happen.*'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: '*你可以将`condition()`* *函数中的语句看作是机器转移到下一个状态的条件。如果该语句为真，则意味着在评估列表中的下一个状态并继续迭代循环之前，不需要执行任何激励。如果该语句为假，则意味着必须执行某些激励，才能发生状态转移。*'
- en: You’ll find all of the example code for the following section and “[Error Correction](ch11.xhtml#ch00lev1sec226)”
    on [page 230](ch11.xhtml#page_230) in the *GameHackingExamples/Chapter11_ StateMachines*
    directory of this book’s source files. The included projects can be compiled with
    Visual Studio 2010, but they should also work with any other C++ compiler. Download
    them at *[https://www.nostarch.com/gamehacking/](https://www.nostarch.com/gamehacking/)*
    and compile them if you want to follow along.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 你将在本书源文件的*GameHackingExamples/Chapter11_ StateMachines*目录中找到以下部分以及“[错误修正](ch11.xhtml#ch00lev1sec226)”的所有示例代码，代码位于[第230页](ch11.xhtml#page_230)。所包含的项目可以使用Visual
    Studio 2010编译，但它们也应该能在任何其他C++编译器上运行。如果你想跟着一起做，可以从* [https://www.nostarch.com/gamehacking/](https://www.nostarch.com/gamehacking/)*下载并编译它们。
- en: '**Combining Control Theory and State Machines**'
  id: totrans-29
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**结合控制理论与状态机**'
- en: 'To tie states together with a feedback loop, first you have to provide each
    `StateDefinition` object with a generic way to access the sensors and actuators
    that you’ve implemented. The `StateDefinition` class then becomes the following:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 要将状态通过反馈循环连接起来，首先你需要为每个`StateDefinition`对象提供一种通用的方式来访问你实现的传感器和执行器。`StateDefinition`类随后变成以下形式：
- en: '[PRE2]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: This change simply modifies the `condition()` and `reach()` functions to accept
    instances of the classes `GameSensors` and `GameActuators` as arguments. `GameSensors`
    and `GameActuators` are classes you need to define; `GameSensors` will contain
    the results of memory reads, network hooks, and other data sources your bot intercepts
    from the game, while `GameActuators` will be a collection of actor functions capable
    of performing actions inside the game.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 这个变化只是简单地修改了`condition()`和`reach()`函数，使其能够接受`GameSensors`和`GameActuators`类的实例作为参数。`GameSensors`和`GameActuators`是你需要定义的类；`GameSensors`将包含从游戏中拦截的内存读取、网络挂钩和其他数据源的结果，而`GameActuators`将是一个包含可执行游戏内动作的函数集合。
- en: Next, you need a generic way to define each individual state. You could abstract
    the definition of each state to its own class that inherits `StateDefinition`
    and implements `condition()` and `reach()` as virtual functions. Alternatively,
    if the source code needs to fit in a small space (like a book, *wink wink*), you
    could keep a single class to represent each definition and use `std::function`
    to implement the `condition()` and `reach()` functions outside the class definition.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，你需要一种通用的方式来定义每个独立的状态。你可以将每个状态的定义抽象为一个继承自`StateDefinition`并实现`condition()`和`reach()`虚函数的类。或者，如果源代码需要适应有限空间（比如书籍，*眨眼*），你可以保持使用单一类来表示每个定义，并使用`std::function`在类定义外部实现`condition()`和`reach()`函数。
- en: 'Following that alternative method, the final version of `StateDefinition` would
    look like this:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 根据那个替代方法，`StateDefinition`的最终版本会如下所示：
- en: '[PRE3]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: With this version of the `StateDefinition` class, you could define a new state
    by creating an instance of the class and assigning `condition()` and `reach()`
    to functions that correspond with the intended behavior.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这个版本的`StateDefinition`类，你可以通过创建该类的实例并将`condition()`和`reach()`分别赋值为与预期行为相对应的函数来定义一个新的状态。
- en: '***A Basic Healer State Machine***'
  id: totrans-37
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***一个基础治疗状态机***'
- en: 'The next step is defining the bot’s actual behavior. To keep the example code
    simple, let’s say you’re implementing an automatic healer. This healer has two
    healing methods: it uses strong healing if the player is at or below 50 percent
    health and weak healing if the player is between 51 and 70 percent health.'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来的步骤是定义机器人的实际行为。为了保持示例代码的简洁，假设你正在实现一个自动治疗机器人。这个治疗机器人有两种治疗方法：当玩家的血量低于或等于50%时使用强治愈，当玩家的血量在51%到70%之间时使用弱治愈。
- en: 'A state machine representing this behavior needs two states, one for strong
    healing and one for weak healing. To start, you need to define the state machine
    as a vector with two `StateDefinition` objects:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 一个表示这种行为的状态机需要两个状态，一个用于强治愈，另一个用于弱治愈。首先，你需要将状态机定义为一个包含两个`StateDefinition`对象的向量：
- en: '[PRE4]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: This code creates a state machine called `stateMachine` and initializes it with
    two empty `StateDefinition` objects. Next, you define the `condition()` and `reach()`
    functions for these state definitions. The strong healing state is the most important
    because it keeps the character from dying, so it should come first in the vector,
    as shown in [Listing 11-1](ch11.xhtml#ch11exe1).
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码创建了一个名为`stateMachine`的状态机，并使用两个空的`StateDefinition`对象初始化它。接下来，你为这些状态定义了`condition()`和`reach()`函数。强治愈状态是最重要的，因为它防止角色死亡，因此应该在向量中排在第一位，正如[列表
    11-1](ch11.xhtml#ch11exe1)所示。
- en: '[PRE5]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '*Listing 11-1: Code for a strong healing state*'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 11-1：强治愈状态的代码*'
- en: This code first creates an iterator called `curDef` that points to the first
    `StateDefinition` object in the `stateMachine` vector. The object’s `condition()`
    function is then defined ➊; in English, this definition says, “The state is met
    if the player’s health percent is greater than 50.” If the state isn’t met, then
    the object’s `reach()` function calls the `strongHeal()` actor function ➋ so that
    strong healing can be performed.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码首先创建了一个名为`curDef`的迭代器，指向`stateMachine`向量中的第一个`StateDefinition`对象。然后定义该对象的`condition()`函数➊；用英文表达就是，“如果玩家的血量百分比大于50%，则满足该状态。”如果状态没有满足，则该对象的`reach()`函数调用`strongHeal()`角色函数➋，以便执行强治愈。
- en: With the strong healing state defined, next you define the weak healing state,
    as shown in [Listing 11-2](ch11.xhtml#ch11exe2).
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 定义了强治愈状态后，接下来你定义弱治愈状态，正如[列表 11-2](ch11.xhtml#ch11exe2)所示。
- en: '[PRE6]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '*Listing 11-2: Code for weak healing*'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 11-2：弱治愈的代码*'
- en: After incrementing `curDef` so it points to the second `StateDefinition` object
    in the `stateMachine` vector, this code defines the object’s `condition()` function
    ➊ as, “The state is met if the player’s health percent is greater than 70.” It
    also defines the object’s `reach()` function as an `actuators->weakHeal()` call
    ➋.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 在将`curDef`递增，使其指向`stateMachine`向量中的第二个`StateDefinition`对象之后，这段代码定义了该对象的`condition()`函数➊为：“如果玩家的血量百分比大于70%，则满足该状态。”它还定义了该对象的`reach()`函数为`actuators->weakHeal()`调用➋。
- en: 'Once you’ve finished defining the state machine, you must implement the controller.
    Since the actual behavior of the controller is contained in the state machine,
    you only need to add a simple loop to complete it:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦完成了状态机的定义，你必须实现控制器。由于控制器的实际行为包含在状态机中，你只需添加一个简单的循环来完成它：
- en: '[PRE7]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: This controller loop iterates over the state machine, executes the `reach()`
    function of the first state whose `condition()` function returns `false` ➊, and
    breaks out if any `reach()` function is called. The final step is to implement
    the feedback loop and plop the controller loop inside it, as shown in [Listing
    11-3](ch11.xhtml#ch11exe3).
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 这个控制器循环遍历状态机，执行第一个`condition()`函数返回`false`的状态的`reach()`函数➊，如果任何`reach()`函数被调用，就会跳出循环。最后一步是实现反馈循环，并将控制器循环放入其中，正如[列表
    11-3](ch11.xhtml#ch11exe3)所示。
- en: '[PRE8]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '*Listing 11-3: Final healing state machine and feedback loop*'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 11-3：最终的治愈状态机和反馈循环*'
- en: This loop continuously executes the controller loop and sleeps for `FEEDBACK_LOOP_TIMEOUT`
    milliseconds between each execution. The `Sleep()` call allows the game server
    to receive and process any actuation from the previous iteration and allows the
    game client to receive any results of the actuation from the server before executing
    the next controller loop.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 这个循环持续执行控制器循环，并在每次执行之间暂停 `FEEDBACK_LOOP_TIMEOUT` 毫秒。`Sleep()` 调用允许游戏服务器接收并处理上一次迭代的任何操作，并允许游戏客户端在执行下一个控制器循环之前接收来自服务器的操作结果。
- en: If you’re still a bit confused about what I just showed you, check out [Figure
    11-3](ch11.xhtml#ch11fig3), which shows how the infinitely looping code in [Listing
    11-3](ch11.xhtml#ch11exe3) works. First, it checks whether the strong healing
    condition is `true`, and if it is, the weak healing condition is checked. If the
    strong healing condition is `false`, then the player’s health must be at or below
    50 percent, so a strong healing method gets called. If the weak healing condition
    check is `false`, then the player’s health must be between 51 and 70 percent,
    so the weak healing method is executed.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你对我刚才展示的内容还有点困惑，可以查看[图 11-3](ch11.xhtml#ch11fig3)，它展示了[清单 11-3](ch11.xhtml#ch11exe3)中无限循环的代码如何工作。首先，它检查强治疗条件是否为
    `true`，如果是，则检查弱治疗条件。如果强治疗条件为 `false`，那么玩家的健康必须处于或低于 50%，于是调用强治疗方法。如果弱治疗条件检查为 `false`，则玩家的健康必须在
    51% 到 70% 之间，于是执行弱治疗方法。
- en: '![image](../images/f11-03.jpg)'
  id: totrans-56
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f11-03.jpg)'
- en: '*Figure 11-3: Flowchart of the healing state machine and feedback loop*'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 11-3：治疗状态机和反馈循环的流程图*'
- en: After either method, the machine sleeps. If both condition checks are `true`,
    then the player needs no healing. The machine does nothing to change the state
    and sleeps before starting again at the top of the `while` loop.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 在任一方法后，机器会进入休眠状态。如果两个条件检查都为 `true`，则玩家无需治疗。机器不会更改状态，进入休眠状态后再次从 `while` 循环的顶部开始。
- en: '***A Complex Hypothetical State Machine***'
  id: totrans-59
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***一个复杂的假设状态机***'
- en: 'The behavior implemented in the healing state machine is simple, so rolling
    it into this kind of control structure may seem like overkill, but it’s useful
    if you want to expand the controller. If, for example, you wanted to combine the
    healing state machine with the “walk, attack, loot” behavior that I discussed
    in “[Control Theory and Game Hacking](ch11.xhtml#ch00lev1sec221)” on [page 222](ch11.xhtml#page_222),
    the control structure would be much more complex. Let’s take a high-level look
    at the states you’d need:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 治疗状态机中实现的行为很简单，因此将其融入这种控制结构可能显得有些过度，但如果你想扩展控制器，它是非常有用的。例如，如果你想将治疗状态机与我在《[控制理论与游戏黑客](ch11.xhtml#ch00lev1sec221)》中讨论的“走路、攻击、拾取战利品”行为结合起来（见[第
    222 页](ch11.xhtml#page_222)），控制结构将会复杂得多。我们来高层次地看看你需要的状态：
- en: '**Strong healing** Condition met if health is over 50 percent. Reach by casting
    strong healing spell.'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: '**强治疗** 如果健康值超过 50%，则满足条件。通过施放强治疗法术来达到。'
- en: '**Weak healing** Condition met if health is over 70 percent. Reach by casting
    weak healing spell.'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: '**弱治疗** 如果健康值超过 70%，则满足条件。通过施放弱治疗法术来达到。'
- en: '**Attack spell** Condition met if no target is available or if attack spell
    is on cooldown. Reach by casting attack spell on target.'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: '**攻击法术** 如果没有目标可用，或者攻击法术正在冷却，则满足条件。通过向目标施放攻击法术来达到。'
- en: '**Kite monster** Condition met if no target is available or if distance from
    target is adequate. (The definition of “adequate” depends on how far away you
    want to be from enemies when kiting.) Reach by taking a step away from target.'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: '**牵制怪物** 如果没有目标可用，或者与目标的距离足够，则满足条件。（“足够”的定义取决于你在牵制敌人时希望与敌人的距离有多远。）通过远离目标迈步来达到。'
- en: '**Target monster** Condition met if there’s no creature to attack. Reach by
    attacking a creature.'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: '**目标怪物** 如果没有可攻击的生物，则满足条件。通过攻击一个生物来达到。'
- en: '**Loot item** Condition met if there’s no corpse open or if open corpse has
    nothing to loot. Reach by taking an item from open corpse.'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: '**拾取战利品** 如果没有打开的尸体，或者打开的尸体没有任何可以拾取的物品，则满足条件。通过从打开的尸体中取出物品来达到。'
- en: '**Approach corpse** Condition met if there are no corpses to open or if adjacent
    to a corpse. Reach by taking a step toward a corpse that will be opened.'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: '**接近尸体** 如果没有可以打开的尸体或接近一个尸体，则满足条件。通过向将要被打开的尸体迈步来达到。'
- en: '**Open corpse** Condition met if the character is not adjacent to a corpse
    that can be opened. Reach by opening adjacent corpse.'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: '**打开尸体** 如果角色没有接触到一个可以打开的尸体，则满足条件。通过打开相邻的尸体来达到。'
- en: '**Follow path** Condition met if the character is unable to move to current
    waypoint or if standing on current waypoint. Reach by taking a step toward current
    waypoint.'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: '**跟随路径** 如果角色无法移动到当前航点，或者站在当前航点上，则满足该条件。通过向当前航点迈步来到达。'
- en: '**Advance waypoint** Condition met if there are no waypoints left to follow.
    Reach by updating the current waypoint to the next waypoint in the list. If the
    character can’t reach the current waypoint for some reason (say, if the character
    is stuck), then the Advance Waypoint state keeps it from being stuck. If the character
    has reached the current waypoint, Advance Waypoint selects the next waypoint to
    keep things moving along.'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: '**前进航点** 如果没有剩余的航点可供跟随，则满足该条件。通过将当前航点更新为列表中的下一个航点来到达。如果角色由于某些原因（例如卡住）无法到达当前航点，则前进航点状态可以防止其卡住。如果角色已经到达当前航点，前进航点会选择下一个航点，确保进度继续推进。'
- en: This state machine is quite a bit more complex than the healing-only state machine.
    If I diagrammed this state machine, there would be 23 objects in the diagram,
    with arrows going over 33 control paths. Compare that to [Figure 11-3](ch11.xhtml#ch11fig3),
    which has only 7 objects and 9 control paths.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 这个状态机比仅用于治疗的状态机复杂得多。如果我画出这个状态机的图表，图表中将有23个对象，箭头连接33条控制路径。相比之下，[图11-3](ch11.xhtml#ch11fig3)只有7个对象和9条控制路径。
- en: You could code the healer behavior without using a state machine or feedback
    loop, but I can’t imagine how to easily do the same for this full-fledged bot.
    Each of these 10 states relies on not only its own condition but also the condition
    of every state preceding it. Moreover, hardcoding the logic would either require
    a ton of nested `if()` statements or a bunch of stacked `if()`/`return()` statements—and,
    either way, it would just behave exactly like the state machine but with no runtime
    flexibility.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在不使用状态机或反馈循环的情况下编写治疗者行为，但我无法想象如何轻松地对这个完整功能的机器人做同样的事情。这些10个状态不仅依赖于各自的条件，还依赖于前面每个状态的条件。此外，硬编码逻辑将需要大量嵌套的`if()`语句或一堆堆叠的`if()`/`return()`语句——无论哪种方式，它都将像状态机一样工作，但没有运行时的灵活性。
- en: '*Runtime flexibility* refers to a state machine’s ability to mutate. Unlike
    hardcoded condition checks, state definitions in a state machine can be moved,
    removed, and added dynamically. The state machine method allows you to plug and
    play different behaviors and features depending on user input.'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: '*运行时灵活性* 指的是状态机的变异能力。与硬编码条件检查不同，状态机中的状态定义可以动态移动、移除和添加。状态机方法使你能够根据用户输入，灵活地插拔不同的行为和功能。'
- en: To take this concept a step further, you could expose your sensors and actuators
    to a Lua environment, create Lua functions capable of adding and removing states
    from the state machine, and modify the `StateDefinition` so that its `condition()`
    and `reach()` functions can call Lua functions exposed by the Lua environment.
    Writing a control system this way would allow you to code the core of your bot
    (hooks, memory reading, actuation) in C++ while making Lua (a high-level, dynamic
    language) available to you for automation.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 更进一步，你可以将传感器和执行器暴露给Lua环境，创建能够添加和移除状态的Lua函数，并修改`StateDefinition`，使其`condition()`和`reach()`函数能够调用Lua环境暴露的Lua函数。通过这种方式编写控制系统，可以让你在C++中编写机器人的核心部分（钩子、内存读取、执行），同时让Lua（作为一种高级动态语言）为你提供自动化功能。
- en: '**NOTE**'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*You can embed Lua in your own programs by including a few headers and linking
    against the Lua library. This process is not difficult, but it’s outside the scope
    of this book, so I encourage you to check out Chapter 24 of* Programming in Lua
    *by Roberto Ierusalimschy* ([http://www.lua.org/pil/24.html](http://www.lua.org/pil/24.html))
    *for more information.*'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: '*你可以通过包含一些头文件并链接Lua库，将Lua嵌入到你自己的程序中。这个过程并不困难，但超出了本书的范围，所以我鼓励你查看*《Lua程序设计》*（作者：Roberto
    Ierusalimschy）第24章* ([http://www.lua.org/pil/24.html](http://www.lua.org/pil/24.html))
    *以获取更多信息。*'
- en: '***Error Correction***'
  id: totrans-77
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***错误修正***'
- en: Another piece of control theory that’s useful for game hacking is *error correction*.
    An error correction mechanism in a controller observes the outcome of actuation,
    compares the outcome to an expected result, and adjusts future calculations to
    bring later outcomes closer to the expected one. Error correction can come in
    handy when you’re working with *stochastic systems*, where the output generated
    from a given input is not fully predictable.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种对游戏黑客有用的控制理论是*错误修正*。控制器中的错误修正机制观察执行结果，将结果与预期结果进行比较，并调整未来的计算，以使后续结果更接近预期结果。错误修正对于处理*随机系统*时非常有用，在这些系统中，给定输入生成的输出无法完全预测。
- en: Games as a whole are stochastic, but, luckily for game hackers, the results
    of actions are mostly deterministic. Take the healing controller, for example.
    In most games, you can calculate exactly how much health you can heal with a given
    spell, and, thus, you know exactly when to heal. But imagine you’re writing a
    healer for the small spectrum of situations where your healing is impossible to
    calculate; for instance, maybe the bot is supposed to work on a variety of characters
    spanning many levels without user input.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 游戏整体是随机的，但幸运的是，对于游戏黑客来说，动作的结果大多是确定的。以治疗控制器为例。在大多数游戏中，你可以准确计算出通过给定法术能够恢复多少生命值，从而知道何时进行治疗。但试想一下，你正在编写一个治疗器，用于处理一些无法计算的治疗情况；例如，可能机器人需要在没有用户输入的情况下，适应各种不同级别的角色。
- en: Error correction could enable your bot to learn how to best heal the players.
    In this scenario, there are two ways you can implement error correction, each
    of which depends on how the healing system works.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 错误修正可以让你的机器人学会如何最好地治疗玩家。在这种情况下，你可以实现错误修正的方式有两种，每一种都取决于治疗系统的工作原理。
- en: '**Adjusting for a Constant Ratio**'
  id: totrans-81
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**调整恒定比例**'
- en: 'If you heal for a constant ratio of health, you’ll only need to adjust your
    controller after the first heal. Assuming that your sensors can detect how much
    you’ve healed, this adds only a few lines of code. You could easily modify the
    weak healing state in [Listing 11-2](ch11.xhtml#ch11exe2) to something like this:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你以恒定的比例进行治疗，你只需要在第一次治疗后调整你的控制器。假设你的传感器能够检测你恢复了多少生命值，这只需要几行代码。你可以轻松地将[Listing
    11-2](ch11.xhtml#ch11exe2)中的微弱治疗状态修改成像这样的代码：
- en: '[PRE9]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Instead of hardcoding `70` as the threshold for weak healing, this code moves
    the threshold to a static variable called `healAt`. It also adds another static
    variable called `hasLearned` so that the code knows when learning is complete.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 与其硬编码`70`作为微弱治疗的阈值，不如将阈值移动到一个名为`healAt`的静态变量中。它还添加了另一个静态变量`hasLearned`，这样代码就能知道何时学习完成。
- en: 'On each invocation of this `condition()` function, the code checks two conditions:
    whether `hasLearned` is `false` and whether the sensors detected a weak healing
    event. When this check passes, the code sets `hasLearned` to `true` and updates
    `healAt` to heal at or below the perfect percentage; that is, if your weak healing
    mustered up a 20 percent increase in health, `healAt` would be set to 80 percent
    health instead of 70 percent, so each heal would bring the player back up to 100
    percent health.'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 每次调用此`condition()`函数时，代码会检查两个条件：`hasLearned`是否为`false`，以及传感器是否检测到微弱的治疗事件。当这个检查通过时，代码会将`hasLearned`设置为`true`，并更新`healAt`以在完美百分比处或以下进行治疗；也就是说，如果你的微弱治疗使生命值增加了20%，那么`healAt`将被设置为80%而不是70%，这样每次治疗都会将玩家的生命值恢复到100%。
- en: '**Implementing Adaptable Error Correction**'
  id: totrans-86
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**实现可调节的错误修正**'
- en: But what if your healing power increases? If a character can gain levels, apply
    skill points, or increase maximum health, the amount of health it can heal may
    change accordingly. For example, if you start a bot on a level-10 character and
    let it run until the character is level 40, your healing code will need to adapt.
    A level-40 character healing like it did at level 10 would either immensely overheal
    or die quickly against on-level game enemies.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 但如果你的治疗能力增加了呢？如果一个角色可以升级、分配技能点或者增加最大生命值，那么他能恢复的生命值也可能相应变化。例如，如果你让一个10级的角色作为机器人的起始角色，并让它运行到40级，你的治疗代码就需要适应变化。一个40级的角色如果按照10级的治疗方式来治疗，将会造成极度过度治疗，或者在与同级敌人作战时快速死亡。
- en: To handle this scenario, a bot needs to constantly update its healing threshold
    to reflect the observed healing amount. [Listing 11-4](ch11.xhtml#ch11exe4) shows
    how you can modify the strong healing condition function in [Listing 11-1](ch11.xhtml#ch11exe1)
    to do this.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 为了处理这种情况，机器人需要不断更新其治疗阈值，以反映观察到的治疗量。[清单 11-4](ch11.xhtml#ch11exe4)展示了如何修改[清单
    11-1](ch11.xhtml#ch11exe1)中的强治疗条件函数来实现这一点。
- en: '[PRE10]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '*Listing 11-4: Tweaking the strong healing condition code*'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 11-4：调整强治疗条件代码*'
- en: As in the modified weak healing function, the healing threshold has been moved
    to a static variable called `healAt`, but this time, the logic is a bit different.
    Since learning must happen continually, there’s no variable to track whether the
    bot has already learned its true healing capacity. Instead, the code just checks
    whether the sensors have seen a strong healing event since its last invocation
    ➊. If so, the code replaces `healAt` with the average of `healAt` and `newHealAt`
    and calls a function to clear the sensors of information related to strong healing
    ➌.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 和修改后的弱治疗函数一样，治疗阈值已被移到一个名为`healAt`的静态变量中，但这次逻辑稍有不同。由于学习必须不断进行，因此没有变量来跟踪机器人是否已经学习到其真实的治疗能力。相反，代码只是检查自上次调用以来，传感器是否已经检测到过一次强治疗事件
    ➊。如果是，代码将`healAt`替换为`healAt`和`newHealAt`的平均值，并调用一个函数清除与强治疗相关的传感器信息 ➌。
- en: 'Clearing the sensors is actually very important, because it keeps the code
    from constantly updating `healAt` against feedback from the same strong healing
    cast. Notice, too, that this function doesn’t update `healAt` to a perfect value
    but instead slides it toward the observed optimal value. This behavior makes the
    new function ideal for situations where there is some amount of randomness in
    how much you can actually heal. If your bot needs to slide toward the new value
    faster, you might change the line at ➋ to something like this:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 清除传感器实际上非常重要，因为这可以防止代码因相同的强治疗技能反馈而不断更新`healAt`。还需要注意的是，这个函数并不会将`healAt`更新为一个完美值，而是将其滑向观察到的最佳值。这种行为使得新函数非常适合在治疗量有一定随机性的情况下使用。如果你的机器人需要更快地滑向新值，你可能需要将➋处的代码改成如下形式：
- en: '[PRE11]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: This code to update `healAt` uses an average weighted toward the `newHealAt`
    value. There are a few points to consider when using this approach, however. First,
    what happens when you overheal? In some games, when you heal to full health, your
    sensors might be able to detect only how much you actually healed. In other games,
    your sensors may be able to detect the actual amount healed. Put another way,
    if you cast a 30 percent strong heal from 85 percent health, do your sensors see
    a heal of 30 percent or 15 percent? If the answer is 30 percent, you’re set. If
    the answer is 15 percent, your code needs a way to adjust downward.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 这段更新`healAt`的代码使用了一个加权平均值，偏向于`newHealAt`值。然而，使用这种方法时有几点需要注意。首先，当你治疗过度时会发生什么？在一些游戏中，当你治疗到满血时，传感器可能只能检测到你实际治疗了多少。在其他游戏中，传感器可能能够检测到实际治疗的量。换句话说，如果你从85%的血量施放了一个30%的强治疗，你的传感器看到的是30%还是15%的治疗量？如果答案是30%，那么你已经准备好了。如果答案是15%，你的代码需要有办法进行调整。
- en: 'One way to adjust accordingly is to decrement `healAt` when your sensors see
    a heal that brings you to full health, like this:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 调整的方法之一是，当你的传感器检测到治疗使你恢复到满血时，减少`healAt`，像这样：
- en: '[PRE12]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: This code is almost the same as [Listing 11-4](ch11.xhtml#ch11exe4), but it
    adds an `if()` clause to decrement `healAt` if a max heal is detected ➊. Otherwise,
    the function should behave like [Listing 11-4](ch11.xhtml#ch11exe4).
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码与[清单 11-4](ch11.xhtml#ch11exe4)几乎相同，但它增加了一个`if()`语句，用于在检测到最大治疗时减少`healAt`
    ➊。否则，函数应该像[清单 11-4](ch11.xhtml#ch11exe4)那样运行。
- en: Healing is a simple case, but this code shows a great example of how you can
    use error correction to dynamically improve your bots’ behavior. One more advanced
    use case is adjusting skillshots to account for enemy movement patterns. Every
    player has patterns in how they avoid skillshots, so if your sensors are able
    to measure the direction and distance an enemy moves when dodging a skillshot,
    your controller code can adjust the location where the bot initially shoots the
    skillshot. In this same scenario, learning would also help the bot account for
    differences in game server latency, character movement speed, and so on.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 治愈是一个简单的案例，但这段代码展示了如何使用错误修正动态改进机器人行为的一个很好的例子。另一个更高级的用例是调整技能射击以考虑敌人的移动模式。每个玩家在躲避技能射击时都有一定的模式，因此，如果你的传感器能够测量敌人在躲避技能射击时的方向和距离，你的控制代码可以调整机器人最初发射技能射击的位置。在同样的场景中，学习也能帮助机器人考虑游戏服务器延迟、角色移动速度等差异。
- en: When using error correction, note that your code will be cleaner and more portable
    if your state definitions have some form of internal bookkeeping other than static
    variables. Moreover, to avoid cluttering your state definitions, I suggest encapsulating
    the error correction logic in some external modules that are easily invoked when
    needed.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用错误修正时，请注意，如果你的状态定义除了静态变量之外有一些内部账务管理，你的代码将更加简洁和便于移植。此外，为了避免状态定义中杂乱无章，我建议将错误修正逻辑封装在一些外部模块中，方便在需要时调用。
- en: '**Pathfinding with Search Algorithms**'
  id: totrans-100
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**使用搜索算法进行路径规划**'
- en: One common challenge you’ll face when writing an autonomous bot is calculating
    a path for a character to follow from one location to another. Aside from the
    sheer reverse engineering challenge of creating sensors to read which coordinates
    on the game map are blocking forward movement or not, there’s also the algorithmic
    challenge of calculating a path within that map. Calculating a path is called
    *pathfinding*, and game hackers often use a *search algorithm* to tackle it.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 在编写自主机器人时，你常常会面临一个挑战，即计算一个角色从一个位置到另一个位置的路径。除了逆向工程的挑战——创建传感器来读取游戏地图上哪些坐标阻止前进之外，还有计算路径的算法挑战。计算路径叫做
    *路径规划*，游戏黑客通常使用 *搜索算法* 来解决这个问题。
- en: '***Two Common Search Techniques***'
  id: totrans-102
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***两种常见的搜索技术***'
- en: Given a grid of tiles, a starting location *a*, and an ending location *b*,
    a search algorithm calculates a path from *a* to *b*. The algorithm does this
    by creating a *node* at *a*, adding nodes adjacent to *a* to a list of tiles to
    be explored (called the *frontier*), updating the node to the best tile in the
    frontier, and repeating the process until the node reaches *b*. Different search
    algorithms select the best node differently, using either a *cost*, a *heuristic*,
    or both.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 给定一个瓦片网格、一个起始位置 *a* 和一个结束位置 *b*，搜索算法计算从 *a* 到 *b* 的路径。该算法通过在 *a* 创建一个 *节点*，将与
    *a* 邻近的节点添加到待探索的瓦片列表（称为 *前沿*）中，更新节点为前沿中最佳的瓦片，并重复此过程，直到节点到达 *b*。不同的搜索算法通过不同的方式选择最佳节点，使用
    *成本*、*启发式* 或两者结合。
- en: '*Dijkstra’s algorithm*, for example, calculates the cost of a tile based on
    its distance from the *a* node and selects the tile with the lowest cost. Imagine
    an empty two-dimensional grid with *a* in the middle. In a search following Dijkstra’s
    algorithm, the frontier will expand in a circular pattern around *a* until *b*
    lies on the edge of the circle, as seen in [Figure 11-4](ch11.xhtml#ch11fig4).'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: '*Dijkstra 算法* 例如，根据瓦片到 *a* 节点的距离计算瓦片的成本，并选择成本最低的瓦片。想象一个空的二维网格，*a* 位于中间。在遵循
    Dijkstra 算法的搜索中，前沿将以围绕 *a* 的圆形模式扩展，直到 *b* 位于圆的边缘，如[图 11-4](ch11.xhtml#ch11fig4)所示。'
- en: The *greedy best-first search* algorithm, instead of prioritizing nodes by their
    distance from the starting point, uses a heuristic to estimate the distance from
    a node in the frontier to *b.* The algorithm then selects the node with the shortest
    estimated distance. Imagine this algorithm in the same grid as before; the frontier
    would be a line going almost directly from *a* to *b*, as seen in [Figure 11-5](ch11.xhtml#ch11fig5).
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: '*贪心最佳优先搜索* 算法并不通过节点到起点的距离来优先排序，而是使用启发式方法来估算前沿中某个节点到 *b* 的距离。然后，算法会选择估算距离最短的节点。想象一下这个算法在之前的网格中运行；前沿几乎会直接从
    *a* 到 *b*，如[图 11-5](ch11.xhtml#ch11fig5)所示。'
- en: '![image](../images/f11-04.jpg)'
  id: totrans-106
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f11-04.jpg)'
- en: '*Figure 11-4: The frontier of Dijkstra’s algorithm. Lighter tiles are higher
    cost.*'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 11-4：Dijkstra 算法的前沿。较浅的瓦片表示更高的成本。*'
- en: '![image](../images/f11-05.jpg)'
  id: totrans-108
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f11-05.jpg)'
- en: '*Figure 11-5: The frontier of the greedy best-first search algorithm. Lighter
    tiles are higher cost.*'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 11-5：贪心的最佳优先搜索算法的边界。较浅的格子表示较高的代价。*'
- en: '***How Obstacles Disrupt Searches***'
  id: totrans-110
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***障碍如何干扰搜索***'
- en: 'The difference in how these algorithms behave becomes clearer once obstacles
    are added to the grid. If, for instance, a wall separates *a* and *b*, Dijkstra’s
    algorithm will always find the quickest path, but with a huge consequence. The
    radius of the circular frontier around *a* will be equal to the length of the
    final path; let’s call that radius *r*. If no grid boundaries clip the frontier,
    you can roughly calculate the number of nodes opened by taking the area of a circle
    with radius *r*. If the path around the wall is 50 tiles, the algorithm will open
    roughly 7,854 tiles, as shown in this equation:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦向网格中添加障碍物，这些算法的行为差异变得更加明显。例如，如果一堵墙把 *a* 和 *b* 分隔开，Dijkstra 算法总是会找到最快的路径，但代价也很大。围绕
    *a* 的圆形边界的半径将等于最终路径的长度；我们把这个半径叫做 *r*。如果没有网格边界限制该边界的扩展，你可以通过计算半径为 *r* 的圆的面积来粗略估算打开的节点数。如果绕过墙的路径是
    50 个格子，算法将大约打开 7,854 个格子，计算公式如下：
- en: π × 50² = 7,854
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: π × 50² = 7,854
- en: In the same scenario, greedy best-first search will calculate a less-than-optimal
    path but open substantially fewer tiles. It’s not as easy to visualize how the
    frontier will expand, and it’s not important right now, so I won’t go into it
    here. At the end of the day, neither of these algorithms really fits the pathfinding
    problem well. The optimal path is slow, and the fast path isn’t optimal.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 在相同的场景下，贪心的最佳优先搜索会计算出一个次优路径，但打开的格子数会少得多。它的边界扩展过程不容易可视化，而且现在这个问题不重要，因此我不会在这里详细讨论。最终，这两种算法都不完全适合路径寻找问题。最优路径虽然准确，但较慢；而快速路径却不是最优的。
- en: To quickly calculate an optimal path, you need to fuse Dijkstra’s algorithm
    with greedy best-first search. Luckily, someone has already done this, and the
    resulting algorithm is a monster known as *A-star search* (often just called *A**).
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 为了快速计算最优路径，你需要将 Dijkstra 算法和贪心的最佳优先搜索结合起来。幸运的是，已经有人做过这件事， resulting 算法就是著名的
    *A-star 搜索*（通常简称为 *A**）。
- en: A* uses the sum of a cost, called *g*, and a heuristic, called *h*, to select
    nodes. These resulting sum is called the *score*. Put simply, score = *g* + *h*.
    Like Dijkstra’s algorithm, A* can calculate the most optimal path from *a* to
    *b*, and like greedy best-first search, it can do so relatively quickly.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: A* 算法通过将一个代价（*g*）和一个启发式函数（*h*）相加来选择节点。这两个值的和称为*得分*。简单来说，得分 = *g* + *h*。像 Dijkstra
    算法一样，A* 可以计算从 *a* 到 *b* 的最优路径；而像贪心的最佳优先搜索一样，A* 也能相对快速地完成这一任务。
- en: '***An A* Search Algorithm***'
  id: totrans-116
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***A* 搜索算法***'
- en: Now that you know the fundamentals, let’s write code to implement the A* algorithm.
    This implementation will work in a two-dimensional grid. It won’t allow diagonal
    movement at first, but I’ll discuss in a bit how you can modify the code to work
    with diagonal movement, too.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经了解了基础知识，让我们编写代码实现 A* 算法。这个实现将应用于二维网格。最初它不会允许对角线移动，但稍后我会讨论如何修改代码以支持对角线移动。
- en: All of the example code for this section is in the *GameHackingExamples/Chapter11_SearchAlgorithms*
    directory of this book’s source files. The included projects can be compiled with
    Visual Studio 2010, but they should also work with any other C++ compiler. Download
    them at *[https://www.nostarch.com/gamehacking/](https://www.nostarch.com/gamehacking/)*
    and compile them to follow along. If you execute *Chapter11_ SearchAlgorithms.exe*,
    you’ll be able to define your own 20×20 grid and watch the algorithm calculate
    a search path.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 本节的所有示例代码都位于本书源文件中的 *GameHackingExamples/Chapter11_SearchAlgorithms* 目录下。包含的项目可以使用
    Visual Studio 2010 编译，但它们也应该适用于任何其他 C++ 编译器。你可以在 *[https://www.nostarch.com/gamehacking/](https://www.nostarch.com/gamehacking/)*
    下载它们并进行编译，跟着一起操作。如果你执行 *Chapter11_ SearchAlgorithms.exe*，你将能够定义自己的 20×20 网格，并观看算法计算搜索路径。
- en: '**Creating an A* Node**'
  id: totrans-119
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**创建 A* 节点**'
- en: 'To start, define an empty `AStarNode` class as follows:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，定义一个空的 `AStarNode` 类，如下所示：
- en: '[PRE13]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'This code defines the `AStarNode` class and a `std::shared_ptr` type definition
    called `AStarNodePtr` to make it easier to create safe pointers to the class.
    Next, within the public scope of this class, declare member variables for the
    node’s x-position, y-position, cost, and node’s score:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码定义了 `AStarNode` 类和一个名为 `AStarNodePtr` 的 `std::shared_ptr` 类型定义，以便更方便地创建指向该类的安全指针。接下来，在这个类的公共范围内，声明节点的
    x 坐标、y 坐标、代价和节点得分等成员变量：
- en: '[PRE14]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Additionally, you need a public member of type `AStarNodePtr` that references
    the parent node:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，你需要一个类型为`AStarNodePtr`的公共成员，用于引用父节点：
- en: '[PRE15]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'After declaring all member variables, declare a public constructor that initializes
    them upon instance creation, as follows:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 在声明所有成员变量后，声明一个公共构造函数，在实例创建时初始化这些成员，代码如下：
- en: '[PRE16]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Now, to make creating safe pointers easier, add a static helper function like
    this:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，为了简化安全指针的创建，添加一个像这样的静态辅助函数：
- en: '[PRE17]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: This `makePtr()` function creates a new instance of `AStarNode` and returns
    the instance wrapped inside of an `AstarNodePtr`.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 这个`makePtr()`函数创建一个新的`AStarNode`实例，并返回被`AStarNodePtr`包装的实例。
- en: Let’s recap. The `AStarNode` class has member variables `x`, `y`, `g`, `score`,
    and `parent`. When the class is constructed, all of these members are initialized
    from values passed to the constructor, with the exception of `score`, which is
    optional (because you use it only when making copies of an `AStarNode` instance)
    and set to `0` if not provided.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们总结一下。`AStarNode`类有成员变量`x`、`y`、`g`、`score`和`parent`。当类被构造时，所有这些成员会根据传递给构造函数的值进行初始化，`score`是可选的（因为它仅在创建`AStarNode`实例的副本时使用），如果没有提供则默认为`0`。
- en: 'Next, define a public member function to calculate the heuristic when given
    the destination coordinates:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，定义一个公共成员函数，用于在给定目标坐标时计算启发式值：
- en: '[PRE18]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'This function returns the *Manhattan distance heuristic* ➊, a distance calculation
    designed for grids where diagonal movement is not possible:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数返回*曼哈顿距离启发式*➊，它是一种适用于没有对角线移动的网格的距离计算方法：
- en: '|Δ*x*| + |Δ*y*|'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: '|Δ*x*| + |Δ*y*|'
- en: 'To calculate a path that allows diagonal movement, you’d need to modify this
    function to use the *Euclidean distance heuristic*, which looks like this:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 要计算允许对角线移动的路径，你需要修改这个函数，使用*欧几里得距离启发式*，其形式如下：
- en: '![image](../images/f0236-01.jpg)'
  id: totrans-137
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f0236-01.jpg)'
- en: 'The class also needs a function to update `score`. You add that function to
    the public scope as follows:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 该类还需要一个更新`score`的函数。你可以将这个函数添加到公共作用域，代码如下：
- en: '[PRE19]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Now, `score` should change to `g + h` when given destination coordinates to
    calculate `h`.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，当给定目标坐标以计算`h`时，`score`应该变为`g + h`。
- en: 'To wrap up, the node class also needs a function that can calculate all of
    its child nodes. The function could do this by creating new nodes for each tile
    adjacent to the current node. Each new node refers to the current node as its
    parent, so the class needs to be able to create an `AStarNodePtr` to a copy of
    the current node as well. Here’s how all that works:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 总结一下，节点类还需要一个可以计算其所有子节点的函数。这个函数可以通过为每个与当前节点相邻的瓦片创建新节点来实现。每个新节点将当前节点作为它的父节点，因此该类还需要能够创建指向当前节点副本的`AStarNodePtr`。以下是具体的实现方式：
- en: '[PRE20]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: This function creates child nodes at (x – 1, y) ➊, (x, y – 1) ➋, (x + 1, y)
    ➌, and (x, y + 1) ➍. Their `parent` is the node that called `getChildren`, and
    their `g` is the parent’s `g` plus `TILE_COST`.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数在（x – 1, y）➊、（x, y – 1）➋、（x + 1, y）➌和（x, y + 1）➍位置创建子节点。它们的`parent`是调用`getChildren`的节点，`g`值是父节点的`g`加上`TILE_COST`。
- en: 'To allow for diagonal movement, this function needs to add children at (x –
    1, y – 1), (x + 1, y – 1), (x + 1, y + 1), and (x – 1, y + 1). Additionally, if
    moving diagonally would cost more—that is, if the character requires more time
    to do it—you’d also need to do the following:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 为了支持对角线移动，函数需要在（x – 1, y – 1）、（x + 1, y – 1）、（x + 1, y + 1）和（x – 1, y + 1）位置添加子节点。此外，如果对角线移动的成本更高——即角色执行此操作所需的时间更多——你还需要做如下处理：
- en: Change `TILE_COST` to `10`.
  id: totrans-145
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`TILE_COST`改为`10`。
- en: Define a constant `DIAG_TILE_COST` as `TILE_COST` multiplied by the time increase.
    If a diagonal step takes 1.5 times as long, `DIAG_TILE_COST` would be `15`.
  id: totrans-146
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义一个常量`DIAG_TILE_COST`，其值为`TILE_COST`乘以时间增加的倍数。如果对角线步骤需要1.5倍的时间，`DIAG_TILE_COST`的值将是`15`。
- en: Give diagonal children a `g` of the parent’s `g` plus `DIAG_TILE_COST`.
  id: totrans-147
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 给对角线子节点的`g`值设为父节点的`g`加上`DIAG_TILE_COST`。
- en: 'To finish off `AStarNode`, declare operators for comparing the priority and
    equality of two nodes. You could place these declarations outside the class in
    global scope like this:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 为了完成`AStarNode`，声明用于比较两个节点优先级和相等性的运算符。你可以像这样将这些声明放在类外部的全局作用域：
- en: '[PRE21]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: These operators allow `std::priority_queue` to sort nodes by `score` ➊ and `std::find`
    to determine node equality by location ➋.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 这些运算符允许`std::priority_queue`通过`score`➊对节点进行排序，并且`std::find`通过位置➋来判断节点是否相等。
- en: '**Writing the A* Search Function**'
  id: totrans-151
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**编写A*搜索函数**'
- en: 'Now that you’ve completed the `AStarNode` class, you can code the actual search
    function. Start by defining the function prototype:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经完成了`AStarNode`类的编写，可以开始编写实际的搜索函数。首先定义函数原型：
- en: '[PRE22]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: The prototype accepts the game map’s width and height, as well as the value
    that signifies a blocking tile on the map, as template parameters. The `doAStarSearch()`
    function also takes the map itself (`map`), the starting coordinates (`startx`
    and `starty`), the destination coordinates (`endx` and `endy`), and a blank map
    (`path`) where it can fill the calculated path when it finishes.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 原型接受游戏地图的宽度和高度，以及表示地图上阻塞块的值作为模板参数。`doAStarSearch()`函数还接受地图本身（`map`）、起始坐标（`startx`和`starty`）、目标坐标（`endx`和`endy`）以及一个空白地图（`path`），在计算路径完成时填充计算出的路径。
- en: '**NOTE**'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*The first three parameters are template parameters, so you can pass them as
    compiletime constants. I’ve done this for the example code to allow explicit array
    size declarations for the* `map` *and* `path` *parameters and to allow a definite
    value to signify blocking tiles on the map. In practice, the map you read from
    a game will have a dynamic size, and you’ll probably need a more robust way to
    pass this data.*'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: '*前三个参数是模板参数，因此你可以将它们作为编译时常量传递。我在示例代码中这样做，以允许显式声明`map`和`path`参数的数组大小，并允许通过一个明确的值来标识地图上的阻塞块。在实际应用中，你从游戏中读取的地图将具有动态大小，你可能需要更强大的方式来传递这些数据。*'
- en: 'Next, the `doAStarSearch()` function needs a sorted list to hold the frontier
    and a container to track all created notes so you can update the score and parent
    of an existing node if it’s opened as a child of a different parent. You can create
    these as follows:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，`doAStarSearch()`函数需要一个排序好的列表来保存frontier，并需要一个容器来追踪所有创建的节点，以便在打开某个节点作为不同父节点的子节点时，可以更新已有节点的分数和父节点。你可以按如下方式创建这些容器：
- en: '[PRE23]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: The `frontier` is defined with `std::priority_queue` since it can automatically
    sort the nodes based on their score. The node container, `allNodes`, is defined
    as a `std::vector`.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: '`frontier`使用`std::priority_queue`定义，因为它可以根据分数自动排序节点。节点容器`allNodes`定义为`std::vector`。'
- en: 'Now, let’s create the first node:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们创建第一个节点：
- en: '[PRE24]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: The first node is a no-cost orphan node at the position (`startx`, `starty`).
    The node is given a score based on what the `updateScore()` function returns,
    and then it’s added to the `allNodes` container.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个节点是一个无成本的孤立节点，位置为（`startx`，`starty`）。该节点根据`updateScore()`函数返回的值来赋予一个分数，然后被添加到`allNodes`容器中。
- en: 'With a node in the container, it’s time to write the meat of the A* algorithm,
    starting with a simple loop:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 有了容器中的节点后，接下来编写A*算法的核心部分，从一个简单的循环开始：
- en: '[PRE25]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Until otherwise specified, the rest of the code in this section will appear
    inside of this loop, in the order shown.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 在没有其他说明之前，本节中的其余代码将按顺序出现在这个循环中。
- en: 'From here, the first step is to check the *goal state*. In this case, the goal
    is to find a path for the player to follow to the next waypoint, which happens
    when the `node` object’s position is (`endx`, `endy`). Thus, to check the goal
    state, the program needs to check whether `node` has reached those coordinates
    or not. Here’s how that check should look:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 从这里开始，第一步是检查*目标状态*。在这种情况下，目标是为玩家找到一条路径，通往下一个航点，这发生在`node`对象的位置为（`endx`，`endy`）时。因此，要检查目标状态，程序需要检查`node`是否已经到达这些坐标。以下是该检查的代码：
- en: '[PRE26]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'When the goal state is met, the program reports `true` back to the caller and
    fills `path` with the final path. For now, assume a function called `makeList()`
    can fill in `path` for you; I’ll show you this function shortly. If the goal state
    isn’t met, you need to expand the children of `node`, which is actually a pretty
    complicated process:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 当达到目标状态时，程序会向调用者报告`true`并填充`path`为最终路径。现在，假设有一个名为`makeList()`的函数可以为你填充`path`；稍后我会展示这个函数。如果目标状态没有达到，你需要扩展`node`的子节点，这实际上是一个相当复杂的过程：
- en: '[PRE27]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: After calling `node->getChildren` to generate a list of nodes that can be added
    to the frontier, the code iterates over each child and ignores any that are on
    blocking tiles ➊. Next, for each child, the code checks whether a node has already
    been opened at the same coordinates ➋. If so, and if the `score` of the existing
    node is greater than the `score` of the new child, the existing node is updated
    to the `parent`, `cost`, and `score` of the new child by the `if()` statement
    at ➌. If the new child doesn’t have a brother-from-another-mother, it will be
    added as is to the frontier ➍ and the node list ➎.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 在调用 `node->getChildren` 生成可以添加到前沿的节点列表后，代码会遍历每个子节点，忽略掉位于阻塞地块上的子节点➊。接着，对于每个子节点，代码会检查是否已经有一个节点在相同的坐标上被打开➋。如果有，并且现有节点的
    `score` 大于新子节点的 `score`，则通过 ➌ 处的 `if()` 语句将现有节点更新为新子节点的 `parent`、`cost` 和 `score`。如果新子节点没有“异母兄弟”，它将直接被添加到前沿
    ➍ 和节点列表 ➎ 中。
- en: Also notice that `std::find` uses the reverse begin and reverse end iterators
    of `allNodes` instead of the regular iterators ➊. The example does this because
    new nodes are appended to the end of the vector and duplicate nodes will be close
    together, so duplicates will usually be closer to the end of the vector. (This
    step could also be done directly against the frontier, but `std::priority_queue`
    doesn’t allow iteration over nodes and writing the sort in place would make the
    code too large for print.)
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 还要注意，`std::find`使用的是`allNodes`的反向开始迭代器和反向结束迭代器，而不是常规的迭代器➊。这个例子之所以这么做，是因为新的节点会被追加到向量的末尾，重复的节点通常会靠在一起，因此重复的节点通常会更接近向量的末端。（这一步也可以直接针对前沿进行处理，但`std::priority_queue`不允许对节点进行迭代，而且将排序写到内存中会使代码变得过于庞大，不适合打印。）
- en: 'Eventually, the function will run out of new children to add to the frontier;
    the following `if()` statement handles that situation:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 最终，函数将没有新的子节点可以添加到前沿；以下的 `if()` 语句处理这种情况：
- en: '[PRE28]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: This code points `node` to the cheapest node from the frontier ➊, removes it
    from the frontier ➋, and lets the loop repeat. If the frontier ends up empty,
    the function reports `false` back to the caller, since there’s nothing left to
    search.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码将 `node` 指向前沿中最便宜的节点 ➊，然后将其从前沿中移除 ➋，并让循环继续。如果前沿为空，函数会向调用者返回 `false`，因为没有剩余的节点可以搜索。
- en: '**Creating the Path List**'
  id: totrans-175
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**创建路径列表**'
- en: 'Finally, it’s time to implement the `makeList()` function:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，到了实现 `makeList()` 函数的时候：
- en: '[PRE29]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: This function updates `path` with both a list of closed nodes ➊ and the calculated
    path ➋. For this example, the value `2` represents the closed nodes and `1` represents
    the path nodes. The program calculates nodes in the path by following parent nodes
    from the goal node until it reaches the starting node, which is an orphan with
    `nullptr` as a parent.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数通过更新 `path` 来包含已关闭节点的列表➊和计算出的路径➋。对于这个例子，值 `2` 代表已关闭的节点，`1` 代表路径节点。程序通过从目标节点开始，沿着父节点一路回溯，直到到达起始节点，来计算路径中的节点，起始节点是一个孤立节点，父节点是
    `nullptr`。
- en: '***When A* Searches Are Particularly Useful***'
  id: totrans-179
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***A* 搜索特别有用的情况***'
- en: Make sure to play with the example code and executable for the previous section,
    because that’s the only way you’ll really get acquainted with the behavior of
    A* searches. In most newer games, you should be able to just send a packet with
    the destination or even emulate a click on the map at the desired spot, but when
    you come across a situation where you need to calculate a path, you’ll be glad
    you learned A*.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 确保尝试上一节的示例代码和可执行文件，因为这是你真正了解 A* 搜索行为的唯一方式。在大多数新游戏中，你应该能够直接发送包含目标的包，甚至在地图上模拟点击目标位置，但当你遇到需要计算路径的情况时，你会很高兴自己学过
    A*。
- en: 'There are actually many situations where calculating a path can be useful:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，有很多情况下计算路径是非常有用的：
- en: '**Selecting targets**'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: '**选择目标**'
- en: When your bot is selecting targets to attack, you may want to check whether
    your character can actually reach them. Otherwise, if an enemy is isolated in
    an unreachable room, you might get stuck in place trying to target them forever!
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 当你的机器人在选择攻击目标时，你可能需要检查角色是否能真正到达这些目标。否则，如果敌人被困在一个无法到达的房间里，你可能会永远停在原地，尝试攻击他们！
- en: '**Selecting corpses**'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: '**选择尸体**'
- en: As your looting state(s) determine which corpses to open, you can optimize by
    always trying to loot the closest corpse first.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 当你的抢夺状态决定了要打开哪些尸体时，你可以通过总是优先抢夺最靠近的尸体来进行优化。
- en: '**Emulating mouse movements**'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: '**模拟鼠标移动**'
- en: Very rarely, some heavily protected games actually correlate in-game actions
    with mouse movements to ensure that there’s no bot running. In this case, you
    might need to emulate the mouse. Using a modified version of A* where the screen
    is the map, there are no blocking tiles, and node costs are slightly randomized,
    you can calculate human-like paths for your mouse to follow when you simulate
    movement.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 很少情况下，一些防护严密的游戏实际上会将游戏内的动作与鼠标移动进行关联，以确保没有机器人在运行。在这种情况下，你可能需要模拟鼠标。通过修改版的 A* 算法，其中屏幕就是地图，没有阻挡的方块，并且节点成本稍作随机化，你可以计算出类似人类的路径，让你的鼠标在模拟移动时跟随这些路径。
- en: '**Kiting monsters**'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: '**引导怪物**'
- en: If you ever need to write code to kite monsters, you can implement A* with a
    goal state of being *N* units away from all creatures. Using the same cost mechanism
    shown in this chapter, play with the heuristic to give a higher cost to nodes
    that are closer to creatures. Kiting isn’t exactly a conventional use case, and
    the heuristic will require a bunch of tweaking, but it works amazingly once you’ve
    got it going. Some implementations can kite any number of monsters better than
    a human!
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你需要编写代码来引导怪物，你可以实现 A* 算法，目标状态是让所有生物距离你 *N* 单位远。使用本章所示的相同成本机制，调整启发式函数，给接近生物的节点更高的成本。引导怪物并不是一个常见的使用案例，启发式函数需要大量调整，但一旦成功，它的效果非常惊人。有些实现甚至能比人类更好地引导任意数量的怪物！
- en: '**Predicting enemy movements**'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: '**预测敌人的移动**'
- en: If you’re writing a bot that fights other players, you can use A* to predict
    their movements and act accordingly. For instance, if your enemy starts running
    away, your bot can assume they are running to their base, calculate their route,
    and use a spell to block their path or even teleport to a location where it expects
    them to be.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你正在编写一个与其他玩家对战的机器人，你可以使用 A* 来预测他们的移动并作出相应的反应。例如，如果你的敌人开始逃跑，你的机器人可以推测他们正在跑向他们的基地，计算他们的路线，并使用法术阻挡他们的路径，甚至传送到他们预计会出现的位置。
- en: These are just a few use cases for A* searches, and you’ll definitely find many
    more as you improve your bots. For the rest of the chapter, I’ll describe some
    popular automated hacks that you can implement using the techniques described
    in this book.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 这些只是 A* 搜索的一些使用案例，随着你提升机器人的能力，你肯定会发现更多用例。在本章的剩余部分，我将描述一些流行的自动化作弊手段，这些方法可以通过本书中描述的技术来实现。
- en: '**OTHER USES FOR A* SEARCH**'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: '**A* 搜索的其他用途**'
- en: A* isn’t just for calculating paths. With abstractions on top of the `AStarNode`
    class, you can adapt the same algorithm to any search problem. Realistically,
    A* is just a weighted iteration over a multidimensional data set that iterates
    until some goal object is found, and, thus, it can solve any problem that can
    be represented as a multidimensional data set. More advanced applications for
    A* include playing chess and checkers, and—when it’s paired with a three-dimensional
    Manhattan distance heuristic and a depth-first search implementation—even solving
    a Rubik’s cube. Sadly, I’m not going to go into these use cases; if you want to
    get really good with search algorithms, I encourage you to research more online.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: A* 不仅仅是用来计算路径的。通过在 `AStarNode` 类上进行抽象，你可以将同样的算法应用于任何搜索问题。实际上，A* 算法只是在多维数据集上进行加权迭代，直到找到某个目标对象，因此它可以解决任何可以表示为多维数据集的问题。A*
    的更高级应用包括下棋和跳棋，甚至在与三维曼哈顿距离启发式函数和深度优先搜索结合时，可以解决魔方问题。遗憾的是，我不会详细介绍这些用例；如果你想深入学习搜索算法，我鼓励你在线上进行更多研究。
- en: '**Common and Cool Automated Hacks**'
  id: totrans-195
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**常见且酷炫的自动化作弊**'
- en: Now that you’ve seen the design patterns and algorithms needed to create efficient,
    self-teaching bots, it’s time to learn about some popular automated hacks that
    go beyond simple healing and pathfinding. Let’s fly up to 10,000 feet to explore
    two types of bots at a high level.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经了解了创建高效、自学习机器人的设计模式和算法，是时候了解一些流行的自动化作弊方法，这些方法超出了简单的治疗和路径规划。让我们从高空 10,000
    英尺的高度，深入探讨两种类型的机器人。
- en: '***Looting with Cavebots***'
  id: totrans-197
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***使用洞窟机器人进行掠夺***'
- en: While discussing control theory, state machines, and search algorithms, I touched
    on the idea of a cavebot that kills creatures, grabs loot, and walks around caves.
    The abilities of cavebots can vary greatly.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 在讨论控制理论、状态机和搜索算法时，我提到了一个洞窟机器人，它可以杀死生物、拾取战利品并在洞窟中行走。洞窟机器人的能力差异非常大。
- en: '**Depositing Gold and Restocking Supplies**'
  id: totrans-199
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**存储金币与补充物资**'
- en: 'If you want to leave a character botting for days on end, you’ll need a *depositor*
    and a *refiller*. A depositor can deposit loot in your bank or vault, while a
    refiller refills your potions, runes, and other supplies. These features can be
    described with six basic states:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你希望让角色连续数天进行挂机，你需要一个*存款器*和一个*补充器*。存款器可以将战利品存入你的银行或保险库，而补充器则负责补充你的药水、符文和其他物资。这些功能可以用六个基本状态来描述：
- en: '**Leave spawn** Condition met if the character is in the spawn area or cave,
    if it has nothing to deposit, and if it has enough supplies. Reach this state
    by exiting the spawn area or cave.'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: '**离开刷怪区** 如果角色处于刷怪区或洞穴，且没有任何物品需要存款，且有足够的物资，则满足此条件。通过离开刷怪区或洞穴来达到此状态。'
- en: '**Walk to town** Condition met if the character is in the spawn area or cave.
    Reach this state by walking from the spawn or cave to town.'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: '**前往城镇** 如果角色处于刷怪区或洞穴，则满足此条件。通过从刷怪区或洞穴走到城镇来达到此状态。'
- en: '**Deposit** Condition met if the character is in the spawn area or cave, or
    if the character is in town and has nothing to deposit. Reach this state by putting
    loot in the bank or vault.'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: '**存款** 如果角色处于刷怪区或洞穴，或者角色在城镇中且没有任何物品需要存款，则满足此条件。通过将战利品存入银行或保险库来达到此状态。'
- en: '**Withdraw cash** Condition met if the character is in the spawn area or cave,
    is in town with no supplies to purchase, or has enough gold to purchase supplies.
    Reach this state by withdrawing gold from the bank or vault.'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: '**取款** 如果角色处于刷怪区或洞穴，或者角色在城镇中且没有物资需要购买，或者角色有足够的金币购买物资，则满足此条件。通过从银行或保险库取款来达到此状态。'
- en: '**Purchase supplies** Condition met if the character is in the spawn area or
    cave or if the character has enough supplies to start hunting. Reach by buying
    supplies.'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: '**购买物资** 如果角色处于刷怪区或洞穴，或者角色有足够的物资开始狩猎，则满足此条件。通过购买物资来达到此状态。'
- en: '**Enter spawn** Condition met if the character is in the spawn area or cave.
    Reach this state by walking to the spawn area or cave.'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: '**进入刷怪区** 如果角色处于刷怪区或洞穴，则满足此条件。通过走到刷怪区或洞穴来达到此状态。'
- en: These states would come before the states related to following waypoints (I
    describe a couple of those states in “[A Complex Hypothetical State Machine](ch11.xhtml#ch00lev1sec225)”
    on [page 228](ch11.xhtml#page_228)) in the vector of `StateDefinition` objects.
    Placing them first gives them priority over remaining in the cave, while still
    allowing the character to target, kill, and loot monsters on the way back to town.
    Depending on where you’re hunting and how you want the bot to behave, you may
    also tell your targeting states not to attack creatures if the character isn’t
    in the spawn area or cave, and you might add an extra state before walk to town
    that attacks only creatures that block the character’s path to town. Specifying
    that extra state increases the bot’s efficiency, since trips to and from town
    will be much quicker if the monsters on the way aren’t worth killing.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 这些状态应该位于与跟随路径点相关的状态之前（我在《[复杂的假设状态机](ch11.xhtml#ch00lev1sec225)》一书的[第228页](ch11.xhtml#page_228)中描述了其中的一些状态）。将它们放在前面可以优先于待在洞穴中的状态，同时仍然允许角色在返回城镇的路上击杀和掠夺怪物。根据你狩猎的位置以及你希望机器人如何表现，你还可以告诉你的目标状态在角色不在刷怪区或洞穴时不要攻击生物，或者你可以在“前往城镇”状态之前增加一个额外的状态，只攻击那些阻挡角色前进道路的怪物。指定这个额外的状态可以提高机器人的效率，因为如果途中遇到的怪物不值得击杀，前往和返回城镇的行程将会更快。
- en: '**Using the Character as Bait**'
  id: totrans-208
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**使用角色作为诱饵**'
- en: Two other cavebot features that can make your bot awesome are *lure mode* and
    *dynamic lure*. You wouldn’t implement these two features as actual states in
    a complex bot; rather, you’d have them inform the bot’s targeting and walking
    states to help the bot make decisions.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 另外两个能让你的机器人变得强大的洞穴机器人功能是*诱饵模式*和*动态诱饵*。你不会将这两个功能实现为复杂机器人的实际状态；相反，你会让它们影响机器人的目标选择和行走状态，从而帮助机器人做出决策。
- en: You can control lure mode with special waypoints in your path, and its code
    will tell your targeting states to attack creatures only if the bot is stuck,
    similar to the mechanism discussed for walking to or from town. The difference
    is that lure mode can be switched on and off at different areas in the cave, allowing
    you to lure multiple mobs of monsters to certain locations before attacking them.
    This can make your bot much more efficient, as certain types of characters may
    excel at killing many monsters at once.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过路径中的特殊路径点来控制引怪模式，它的代码会告诉你的目标状态只在机器人卡住时才攻击生物，类似于我们之前讨论的从城镇到城镇的行走机制。不同之处在于，引怪模式可以在洞窟中的不同区域打开和关闭，使你可以在攻击怪物之前，将多个怪物群引到特定的位置。这可以使你的机器人更加高效，因为某些类型的角色可能擅长一次性击杀大量怪物。
- en: Dynamic lure is similar, but instead of turning it on and off at definite locations
    via waypoints, you can automatically turn lure mode on when there aren’t enough
    monsters. For example, a bot with the dynamic lure feature might tell the targeting
    states not to attack any creature until five monsters are on screen. The targeting
    states would resume attacking and kiting until all five monsters are dead, and
    the bot would snap back into lure mode until a suitably sized mob appears again.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 动态引怪与此相似，但它不是通过路径点在特定位置开启或关闭，而是在怪物不足时自动开启引怪模式。例如，具有动态引怪功能的机器人可能会告诉目标状态，在屏幕上没有五个怪物时，不要攻击任何生物。目标状态将恢复攻击并引导，直到所有五个怪物被击败，然后机器人会切换回引怪模式，直到出现适当数量的怪物群。
- en: If your character is quick enough to outrun monsters, though, you’ll need to
    modify your bot’s walking states to walk slowly when lure mode is on and creatures
    are present. Otherwise, your character will leave mobs behind without killing
    them. You can slow down a character by adding a state before the follow path state
    in your state machine definition that delays movement slightly when lure mode
    is on and any creatures are too far away.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果你的角色足够快，能够跑得过怪物，你需要修改机器人的行走状态，在引怪模式开启并且有生物存在时，走得慢一些。否则，角色会把怪物落在身后而不去击杀它们。你可以通过在状态机定义中添加一个状态，延迟在引怪模式开启且任何生物离得太远时的移动，从而减慢角色的速度。
- en: '**Allowing Players to Script Custom Behaviors**'
  id: totrans-213
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**允许玩家编写自定义行为脚本**'
- en: Nearly every cavebot includes a scripting interface that allows players to add
    their own behaviors. You could implement this interface as a way to specify custom
    waypoints to follow, spells to use, or items to loot. In more advanced bots, you
    might make your targeting, looting, walking, and luring systems as dynamic as
    possible so players can add unique features. If you implement your automation
    in Lua, third parties could easily improve and expand your bot’s abilities.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 几乎每个洞窟机器人都包括一个脚本接口，允许玩家添加自己的行为。你可以实现这个接口来指定自定义的路径点、使用的法术或拾取的物品。在更高级的机器人中，你可能会让目标、拾取、行走和引怪系统尽可能地动态化，这样玩家就可以添加独特的功能。如果你使用
    Lua 实现自动化，第三方可以轻松改进和扩展你机器人的功能。
- en: Making your bot easy to write scripts for takes a lot of work off your shoulders,
    since other programmers who play the game might release scripts to add support
    for new hunting spots and improve your automation. Such scripting services are
    common in botting communities, and players often create and sell professional-grade
    scripts that integrate with bots.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 使你的机器人易于编写脚本可以减轻你的工作负担，因为其他玩游戏的程序员可能会发布脚本，以支持新的狩猎点并改进你的自动化功能。这类脚本服务在机器人社区中很常见，玩家经常创建并出售与机器人兼容的专业级脚本。
- en: '***Automating Combat with Warbots***'
  id: totrans-216
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***使用战斗机器人自动化战斗***'
- en: Another class of automated bots is used for *player versus player (PvP)* combat.
    These warbots, or *PvP bots*, have many features categorized as responsive or
    ESP hacks, since the bots focus on responding to incoming damage or spells, revealing
    hidden enemies, and giving the player an information advantage.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 另一类自动化机器人用于*玩家对战玩家（PvP）*战斗。这些战斗机器人，或*PvP 机器人*，拥有许多被归类为响应式或ESP（外部感知）作弊的功能，因为这些机器人专注于响应敌人伤害或法术、揭示隐藏敌人，并为玩家提供信息上的优势。
- en: Fully automated warbots are rare, but I’ve already lightly discussed how you
    can use some automation techniques to make smarter healers, teach bots to land
    more accurate skillshots, and predict players’ paths to stop them in their tracks.
    Let’s explore a few other cool hacks that fall on the fringe of responsive, ESP,
    and automated.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 完全自动化的战争机器人很少见，但我已经简要讨论了如何使用一些自动化技术来制造更智能的治疗机器人，教机器人如何命中更精准的技能射击，并预测玩家的路径以将其阻止。接下来，让我们探讨一些其他有趣的黑科技，它们处于响应式、ESP和自动化的边缘。
- en: '**NOTE**'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*In games that are completely PvP based, such as battlegrounds or real-time
    strategy games, some players might also just call these* bots*, since war or PvP
    is the bot’s only purpose.*'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: '*在完全基于PvP的游戏中，例如战场或实时策略游戏，某些玩家可能会称这些为*机器人*，因为战争或PvP是机器人的唯一目的。*'
- en: '**Autowall Bots**'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: '**自动墙壁机器人**'
- en: If your character has a spell to create a temporary wall, you can code a bot
    that automatically blocks enemy players when they enter small corridors. Using
    error correction, the bot could learn how far ahead of the enemy to place the
    wall. With some really creative engineering, the bot could even learn which enemies
    can jump over walls by checking whether each enemy manages to get past the wall
    before it disappears.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你的角色有一个创建临时墙壁的技能，你可以编写一个机器人，在敌人进入小走廊时自动阻挡他们。通过错误修正，机器人可以学习在敌人之前多远的地方放置墙壁。通过一些非常有创意的工程设计，机器人甚至可以通过检查每个敌人是否在墙壁消失之前成功越过墙壁，来学习哪些敌人能跳过墙壁。
- en: '**Autosnipe Bots**'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: '**自动狙击机器人**'
- en: For characters with a long-range skillshot or global execution spell, you can
    use automation to detect when an enemy across the map has low health and cast
    your spell to kill them. You can also use error correction to more accurately
    guess where to shoot a long-range skillshot. If you’re unable to calculate exact
    damage amounts, error correction can also help a bot determine how much damage
    a spell does and tweak the casting threshold accordingly.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 对于拥有远程技能或全球执行技能的角色，你可以使用自动化来检测地图对面的敌人何时血量低，并施放技能将其击杀。你还可以使用错误修正，更准确地猜测该如何射击远程技能。如果你无法精确计算伤害数值，错误修正也能帮助机器人判断技能造成的伤害，并相应地调整施法阈值。
- en: '**Autokite Bots**'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: '**自动风筝机器人**'
- en: If you’re playing a carry character that does most of its damage by attacking
    at a short distance, you might implement a bot to automatically kite enemies.
    Using a set of states similar to the ones a cavebot might use to kite monsters,
    you can make a bot that automatically kites enemy characters when you attack them.
    When you stop targeting the enemy, the bot can stop kiting. Using A* search, you
    can improve the kiting mechanism to avoid multiple enemies, or, if you want to
    escape while attacking, guide the kiting mechanism back to a safe place, such
    as your team’s base or a neutral location.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你玩的是一个通过近战攻击造成大部分伤害的输出型角色，你可以实现一个机器人，自动风筝敌人。通过使用一组与洞窟机器人类似的状态，你可以制作一个在你攻击敌人时自动风筝敌人。当你停止锁定敌人时，机器人可以停止风筝。利用A*搜索，你可以改进风筝机制，避免多个敌人，或者如果你想在攻击时逃跑，可以引导风筝机制回到安全地点，比如你队伍的基地或一个中立位置。
- en: '**Closing Thoughts**'
  id: totrans-227
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**结语**'
- en: By this point, you should be ready to go out and make some pretty awesome bots.
    Don’t worry if you’re still not completely comfortable with the techniques in
    this chapter; the best way to learn is to just dive in and start hacking. Use
    the thousands of lines of example code provided for this book to get started without
    working from scratch, and most of all, have fun!
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 到了这个时候，你应该已经准备好开始制作一些相当酷的机器人了。如果你对本章中的技术仍然不完全熟悉，不要担心；最好的学习方法就是直接动手开始编写。利用本书提供的成千上万行示例代码，你可以不用从零开始就能入门，最重要的是，享受其中的乐趣！
- en: In the next chapter, I’ll discuss ways that bots can hide from anti-cheat mechanisms,
    which are pieces of software that games use to detect and stop botters.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章，我将讨论机器人如何隐藏自己，以避开反作弊机制，这些是游戏用来检测和阻止机器人的软件。
