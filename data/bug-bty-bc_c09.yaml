- en: '9'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '9'
- en: Cross-Site Request Forgery
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 跨站请求伪造
- en: '![](image_fi/book_art/chapterart.png)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![](image_fi/book_art/chapterart.png)'
- en: '*Cross-site request forgery (**CSRF)* is a client-side technique used to attack
    other users of a web application. Using CSRF, attackers can send HTTP requests
    that pretend to come from the victim, carrying out unwanted actions on a victim’s
    behalf. For example, an attacker could change your password or transfer money
    from your bank account without your permission.'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: '*跨站请求伪造（**CSRF**）* 是一种客户端技术，用于攻击 Web 应用的其他用户。通过 CSRF，攻击者可以发送伪装成受害者请求的 HTTP
    请求，代表受害者执行不希望发生的操作。例如，攻击者可以在没有你许可的情况下更改你的密码或从你的银行账户转账。'
- en: CSRF attacks specifically target state-changing requests, like sending tweets
    and modifying user settings, instead of requests that reveal sensitive user info.
    This is because attackers won’t be able to read the response to the forged requests
    sent during a CSRF attack. Let’s get into how this attack works.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: CSRF 攻击专门针对那些改变状态的请求，如发送推文和修改用户设置，而不是暴露敏感用户信息的请求。这是因为攻击者无法读取在 CSRF 攻击中伪造请求的响应。让我们深入了解这种攻击是如何工作的。
- en: Mechanisms
  id: totrans-5
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 机制
- en: 'Remember from Chapter 3 that most modern web applications authenticate their
    users and manage user sessions by using session cookies. When you first log in
    to a website, the web server establishes a new session: it sends your browser
    a session cookie associated with the session, and this cookie proves your identity
    to the server. Your browser stores the session cookies associated with that website
    and sends them along with every subsequent request you send to the site. This
    all happens automatically, without the user’s involvement.'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 记住在第三章提到的，大多数现代 Web 应用通过使用会话 cookie 来验证用户并管理用户会话。当你首次登录网站时，Web 服务器会建立一个新会话：它将一个与该会话关联的会话
    cookie 发送给你的浏览器，而这个 cookie 向服务器证明了你的身份。你的浏览器会存储与该网站相关的会话 cookie，并在你发送的每个后续请求中都将其一同发送。所有这些都是自动进行的，无需用户的干预。
- en: 'For example, when you log into Twitter, the Twitter server sends your browser
    the session cookie via an HTTP response header called `Set-Cookie`:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，当你登录 Twitter 时，Twitter 服务器通过名为 `Set-Cookie` 的 HTTP 响应头将会话 cookie 发送给你的浏览器：
- en: '[PRE0]'
  id: totrans-8
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Your browser receives the session cookie, stores it, and sends it along via
    the `Cookie` HTTP request header in every one of your requests to Twitter. This
    is how the server knows your requests are legit:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 你的浏览器接收会话 cookie，将其存储，并在你每次向 Twitter 发送请求时通过 `Cookie` HTTP 请求头将其发送。这就是服务器如何知道你的请求是合法的：
- en: '[PRE1]'
  id: totrans-10
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Armed with your session cookie, you can carry out authenticated actions like
    accessing confidential information, changing your password, or sending a private
    message without reentering your password. To get ahold of your own session cookies,
    intercept the requests your browsers send to the site after you’ve logged in.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 拥有会话 cookie 后，你可以执行认证过的操作，例如访问机密信息、更改密码或发送私人消息，而无需重新输入密码。要获取你自己的会话 cookie，可以拦截你登录后浏览器发送到网站的请求。
- en: Now let’s say there’s a Send a Tweet HTML form on Twitter’s web page. Users
    can enter their tweets by using this form and clicking the Submit button to send
    them ([Figure 9-1](#figure9-1)).
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 假设 Twitter 网页上有一个“发送推文”HTML 表单。用户可以通过这个表单输入推文，并点击提交按钮发送它们（见[图 9-1](#figure9-1)）。
- en: '![f09001](image_fi/501546c09/f09001.png)'
  id: totrans-13
  prefs: []
  type: TYPE_IMG
  zh: '![f09001](image_fi/501546c09/f09001.png)'
- en: 'Figure 9-1: An example HTML form that allows users to send a tweet'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9-1：一个示例 HTML 表单，允许用户发送推文
- en: 'Note that Twitter doesn’t really use this form (and Twitter’s actual Send a
    Tweet functionality isn’t vulnerable to CSRF attacks). The source code of the
    example HTML form looks like this:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，Twitter 实际上并没有使用这个表单（且 Twitter 的实际“发送推文”功能并不容易受到 CSRF 攻击）。示例 HTML 表单的源代码如下：
- en: '[PRE2]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The `<h1>` tags denote a first-level HTML heading 1, whereas the `<form>` tags
    define the beginning and end of an HTML form 2. The form has the method attribute
    `POST` and the action attribute `https://twitter.com/send_a_tweet`. This means
    that the form will submit a POST request to the *https://twitter.com/send_a_tweet*
    endpoint when the user clicks Submit. Next, an `<input>` tag defines a text input
    with the default value of `Hello world!`. When the form is submitted, any user
    input in this field will be sent as a POST parameter named `tweet_content` 3.
    A second input tag defines the `Submit` button 4. When users click this button,
    the form will be submitted.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: '`<h1>`标签表示一级HTML标题1，而`<form>`标签定义了HTML表单的开始和结束2。表单的`method`属性是`POST`，`action`属性是`https://twitter.com/send_a_tweet`。这意味着当用户点击提交时，表单将向*https://twitter.com/send_a_tweet*端点提交一个POST请求。接下来，一个`<input>`标签定义了一个文本输入框，默认值为`Hello
    world!`。当表单被提交时，任何用户在此字段中的输入将作为名为`tweet_content` 3的POST参数发送。第二个输入标签定义了`Submit`按钮4。当用户点击此按钮时，表单将被提交。'
- en: 'When you click the Submit button on the page, your browser will send a POST
    request to *https://twitter.com/send_a_tweet*. The browser will include your Twitter
    session cookie with the request. You could see the request generated by the form
    in your proxy. It should look something like this:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 当你点击页面上的提交按钮时，浏览器将向*https://twitter.com/send_a_tweet*发送一个POST请求。浏览器会在请求中包含你的Twitter会话cookie。你可以在代理中看到由表单生成的请求。它应该类似于以下内容：
- en: '[PRE3]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'This functionality has a vulnerability: any site, and not just Twitter, can
    initiate this request. Imagine that an attacker hosts their own website that displays
    an HTML form like [Figure 9-2](#figure9-2).'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 这个功能存在一个漏洞：任何网站，而不仅仅是Twitter，都可以发起这个请求。假设一个攻击者托管了自己的网页，显示了一个像[图9-2](#figure9-2)这样的HTML表单。
- en: '![f09002](image_fi/501546c09/f09002.png)'
  id: totrans-21
  prefs: []
  type: TYPE_IMG
  zh: '![f09002](image_fi/501546c09/f09002.png)'
- en: 'Figure 9-2: An example HTML form that an attacker uses to exploit a CSRF vulnerability'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 图9-2：攻击者利用CSRF漏洞的HTML表单示例
- en: 'The page’s source code is the following:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 该页面的源代码如下：
- en: '[PRE4]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'When you click the Submit button on this page, your browser will send a POST
    request. Because the browser automatically includes your Twitter session cookies
    in requests to Twitter, Twitter will treat the request as valid, causing your
    account to tweet `Follow @vickieli7 on Twitter!` Here’s the corresponding request:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 当你点击此页面上的提交按钮时，浏览器将发送一个POST请求。由于浏览器会自动在请求中包含你的Twitter会话cookie，Twitter会将请求视为有效，导致你的账户发送推文`Follow
    @vickieli7 on Twitter!`。以下是相应的请求：
- en: '[PRE5]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Even though this request doesn’t come from Twitter, Twitter will recognize it
    as valid because it includes your real Twitter session cookie. This attack would
    make you send the tweet every time you click Submit on the malicious page.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 即使这个请求不是来自Twitter，Twitter仍然会将其识别为有效，因为它包含了你的真实Twitter会话cookie。每次点击恶意页面上的提交按钮时，这个攻击都会导致你发送推文。
- en: 'It’s true that this attack page isn’t very useful: it requires the victim to
    click a button, which most users probably won’t do. How can attackers make the
    exploit more reliable? Realistically, a malicious CSRF page would look more like
    this:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 的确，这个攻击页面并不非常有用：它需要受害者点击按钮，而大多数用户可能不会这么做。攻击者如何使这个漏洞更加可靠呢？实际上，一个恶意的CSRF页面可能更像这样：
- en: '[PRE6]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: This HTML places the form in an invisible iframe to hide it from the user’s
    view. Remember from Chapter 8 that an *iframe* is an HTML element that embeds
    another document within the current HTML document. This particular iframe’s style
    is set to `display:none`, meaning it won’t be displayed on the page, making the
    form invisible 1. Then, JavaScript code between the script tags 3 will submit
    the form with the ID `csrf-form` 2 without the need for user interaction. The
    code fetches the HTML form by referring to it by its ID, `csrf-form`. Then the
    code submits the form by calling the `submit()` method on it. With this new attack
    page, any victim who visits the malicious site will be forced to tweet.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 这段HTML将表单放在一个不可见的iframe中，以便将其隐藏在用户的视野之外。记得在第8章提到过，*iframe*是一个HTML元素，它将另一个文档嵌入到当前的HTML文档中。这个特定的iframe的样式设置为`display:none`，意味着它不会显示在页面上，从而使表单变得不可见。然后，脚本标签中的JavaScript代码3将在没有用户交互的情况下提交ID为`csrf-form`
    2的表单。代码通过引用ID `csrf-form`来获取HTML表单。接着，代码调用`submit()`方法来提交表单。通过这个新的攻击页面，任何访问恶意网站的受害者都会被迫发送推文。
- en: What attackers can actually accomplish with a real CSRF vulnerability depends
    on where the vulnerability is found. For example, let’s say a request that empties
    a user’s online shopping cart has a CSRF vulnerability. When exploited in the
    wild, this vulnerability can at most cause annoyance to the site users. It doesn’t
    have the potential to cause any major financial harm or identity theft.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 攻击者实际能够利用真实的CSRF漏洞做什么，取决于漏洞出现的位置。例如，假设一个请求清空用户在线购物车的请求存在CSRF漏洞。在实际攻击中，这个漏洞最多会给网站用户带来一些困扰。它不会造成重大经济损失或身份盗用。
- en: On the other hand, some CSRFs can lead to much bigger issues. If a CSRF vulnerability
    is present on requests used to change a user’s password, for example, an attacker
    can change other users’ passwords against their will and take over their entire
    accounts! And when a CSRF appears in functionalities that handle user finances,
    like account balance transfers, attackers can potentially cause unauthorized balance
    transfers out of the victim’s bank account. You can also use CSRFs to trigger
    injection vulnerabilities such as XSS and command injections.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，一些CSRF攻击可能导致更严重的问题。例如，如果在更改用户密码的请求中存在CSRF漏洞，攻击者可以在用户不知情的情况下更改其他用户的密码，并接管他们的整个账户！而且，当CSRF漏洞出现在处理用户财务功能的地方，比如账户余额转账时，攻击者可能会在受害者的银行账户中进行未经授权的余额转账。你也可以利用CSRF攻击来触发注入漏洞，如XSS和命令注入。
- en: Prevention
  id: totrans-33
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 防护
- en: The best way to prevent CSRFs is to use *CSRF tokens*. Applications can embed
    these random and unpredictable strings in every form on their website, and browsers
    will send this string along with every state-changing request. When the request
    reaches the server, the server can validate the token to make sure the request
    indeed originated from its website. This CSRF token should be unique for each
    session and/or HTML form so attackers can’t guess the token’s value and embed
    it on their websites. Tokens should have sufficient entropy so that they cannot
    be deduced by analyzing tokens across sessions.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 防止CSRF攻击的最佳方法是使用*CSRF令牌*。应用程序可以在网站的每个表单中嵌入这些随机且不可预测的字符串，浏览器会在每个改变状态的请求中发送这些字符串。当请求到达服务器时，服务器可以验证令牌，以确保请求确实来自其网站。这个CSRF令牌应当对每个会话和/或HTML表单唯一，这样攻击者就无法猜测令牌的值并将其嵌入到他们的网站上。令牌应该具有足够的熵，以便不能通过分析不同会话的令牌来推导出来。
- en: 'The server generates random CSRF tokens and embeds correct CSRF tokens in forms
    on the legitimate site. Notice the new input field used to specify a CSRF token:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 服务器生成随机的CSRF令牌，并将正确的CSRF令牌嵌入到合法网站的表单中。注意，用于指定CSRF令牌的新输入字段：
- en: '[PRE7]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Twitter’s server can require that the browser send the correct value of the
    `csrf_token` POST parameter along with the request for it to be successful. If
    the value of `csrf_token` is missing or incorrect, the server should see the request
    as fake and reject it.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: Twitter的服务器可能要求浏览器在发送请求时提供正确的`csrf_token` POST参数值，才能确保请求成功。如果`csrf_token`的值缺失或不正确，服务器会认为请求是伪造的并拒绝它。
- en: 'Here is the resulting POST request:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是生成的POST请求：
- en: '[PRE8]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Many frameworks have CSRF tokens built in, so often you can simply use your
    framework’s implementation.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 许多框架都内置了CSRF令牌，因此通常你可以直接使用框架的实现。
- en: 'Besides implementing CSRF tokens to ensure the authenticity of requests, another
    way of protecting against CSRF is with `SameSite` cookies. The `Set-Cookie` header
    allows you to use several optional flags to protect your users’ cookies, one of
    which is the `SameSite` flag. When the `SameSite` flag on a cookie is set to `Strict`,
    the client’s browser won’t send the cookie during cross-site requests:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 除了实现CSRF令牌以确保请求的真实性外，另一种防护CSRF攻击的方法是使用`SameSite` Cookies。`Set-Cookie`头允许你使用多个可选标志来保护用户的Cookies，其中之一就是`SameSite`标志。当一个Cookie的`SameSite`标志被设置为`Strict`时，客户端浏览器不会在跨站请求中发送该Cookie：
- en: '[PRE9]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Another possible setting for the `SameSite` flag is `Lax`, which tells the
    client’s browser to send a cookie only in requests that cause top-level navigation
    (when users actively click a link and navigate to the site). This setting ensures
    that users still have access to the resources on your site if the cross-site request
    is intentional. For example, if you navigate to Facebook from a third-party site,
    your Facebook logins will be sent. But if a third-party site initiates a POST
    request to Facebook or tries to embed the contents of Facebook within an iframe,
    cookies won’t be sent:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: '`SameSite`标志的另一个可能设置是`Lax`，它告诉客户端浏览器仅在导致顶级导航的请求中发送Cookie（当用户主动点击链接并导航到站点时）。此设置确保当跨站点请求是有意的时，用户仍然能够访问你站点上的资源。例如，如果你从第三方网站导航到Facebook，你的Facebook登录信息将被发送。但如果第三方网站发起POST请求到Facebook或试图将Facebook内容嵌入iframe中，则不会发送Cookies：'
- en: '[PRE10]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Specifying the `SameSite` attribute is good protection against CSRF because
    both the `Strict` and `Lax` settings will prevent browsers from sending cookies
    on cross-site form POST or AJAX requests, and within iframes and image tags. This
    renders the classic CSRF hidden-form attack useless.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 指定`SameSite`属性对CSRF有很好的防护作用，因为`Strict`和`Lax`设置都会阻止浏览器在跨站点表单POST请求、AJAX请求、iframe和图片标签中发送Cookies。这使得经典的CSRF隐形表单攻击变得无效。
- en: In 2020, Chrome and a few other browsers made `SameSite=Lax` the default cookie
    setting if it’s not explicitly set by the web application. Therefore, even if
    a web application doesn’t implement CSRF protection, attackers won’t be able to
    attack a victim who uses Chrome with POST CSRF. The efficacy of a classic CSRF
    attack will likely be greatly reduced, since Chrome has the largest web browser
    market share. On Firefox, the `SameSite` default setting is a feature that needs
    to be enabled. You can enable it by going to `about:config` and setting `network.cookie.sameSite.laxByDefault`
    to `true`.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 在2020年，Chrome和其他几个浏览器将`SameSite=Lax`作为默认Cookie设置，如果Web应用程序没有显式设置它。因此，即使Web应用程序没有实施CSRF保护，攻击者也无法通过POST
    CSRF攻击使用Chrome攻击受害者。经典CSRF攻击的有效性可能会大大降低，因为Chrome拥有最大的Web浏览器市场份额。在Firefox中，`SameSite`的默认设置是一个需要启用的功能。你可以通过进入`about:config`并将`network.cookie.sameSite.laxByDefault`设置为`true`来启用它。
- en: 'Even when browsers adopt the `SameSite-`by-default policy, CSRFs are still
    possible under some conditions. First, if the site allows state-changing requests
    with the GET HTTP method, third-party sites can attack users by creating CSRF
    with a GET request. For example, if the site allows you to change a password with
    a GET request, you could post a link like this to trick users into clicking it:
    *https://email.example.com/password_change?new_password=abc123*.'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 即使浏览器采用`SameSite-`默认策略，某些情况下仍然可能发生CSRF攻击。首先，如果站点允许使用GET HTTP方法进行更改状态的请求，第三方网站可以通过创建带有GET请求的CSRF攻击用户。例如，如果站点允许你通过GET请求更改密码，你可以发布一个类似这样的链接，诱使用户点击：*https://email.example.com/password_change?new_password=abc123*。
- en: 'Since clicking this link will cause top-level navigation, the user’s session
    cookies will be included in the GET request, and the CSRF attack will succeed:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 因为点击这个链接会导致顶级导航，用户的会话Cookie将包含在GET请求中，CSRF攻击将成功：
- en: '[PRE11]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: In another scenario, sites manually set the `SameSite` attribute of a cookie
    to `None`. Some web applications have features that require third-party sites
    to send cross-site authenticated requests. In that case, you might explicitly
    set `SameSite` on a session cookie to `None`, allowing the sending of the cookie
    across origins, so traditional CSRF attacks would still work. Finally, if the
    victim is using a browser that doesn’t set the `SameSite` attribute to `Lax` by
    default (including Firefox, Internet Explorer, and Safari), traditional CSRF attacks
    will still work if the target application doesn’t implement diligent CSRF protection.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 在另一种情况下，站点手动将Cookie的`SameSite`属性设置为`None`。一些Web应用程序需要第三方网站发送跨站点的身份验证请求。在这种情况下，你可能会显式地将会话Cookie的`SameSite`设置为`None`，允许跨源发送Cookie，这样传统的CSRF攻击仍然有效。最后，如果受害者使用的浏览器默认没有将`SameSite`属性设置为`Lax`（包括Firefox、Internet
    Explorer和Safari），那么如果目标应用没有实施严格的CSRF保护，传统的CSRF攻击仍然有效。
- en: 'We’ll explore other ways of bypassing CSRF protection later in this chapter.
    For now, just remember: when websites don’t implement `SameSite` cookies or other
    CSRF protection for every state-changing request, the request becomes vulnerable
    to CSRF if the user is not using a `SameSite`-by-default browser. CSRF protection
    is still the responsibility of the website despite the adoption of `SameSite`-by-default.'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 本章后面我们会探讨绕过 CSRF 保护的其他方法。现在，只需记住：当网站没有为每个状态变化请求实施 `SameSite` cookies 或其他 CSRF
    保护机制时，如果用户没有使用 `SameSite`-by-default 浏览器，该请求就容易受到 CSRF 攻击。尽管采用了 `SameSite`-by-default
    浏览器，网站仍需负责实施 CSRF 保护。
- en: Hunting for CSRFs
  id: totrans-52
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 寻找 CSRF 攻击
- en: CSRFs are common and easy to exploit. To look for them, start by discovering
    state-changing requests that aren’t shielded by CSRF protections. Here’s a three-step
    process for doing so. Remember that because browsers like Chrome offer automatic
    CSRF protection, you need to test with another browser, such as Firefox.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: CSRF 攻击很常见且容易利用。要寻找它们，首先要发现没有被 CSRF 保护机制屏蔽的状态变化请求。以下是一个三步流程来实现这一目标。请记住，由于像 Chrome
    这样的浏览器提供自动的 CSRF 保护，因此需要使用其他浏览器进行测试，比如 Firefox。
- en: 'Step 1: Spot State-Changing Actions'
  id: totrans-54
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 第一步：发现状态变化的操作
- en: Actions that alter the users’ data are called *state-changing actions*. For
    example, sending tweets and modifying user settings are both state-changing. The
    first step of spotting CSRFs is to log in to your target site and browse through
    it in search of any activity that alters data.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 改变用户数据的操作称为*状态变化操作*。例如，发送推文和修改用户设置都是状态变化操作。发现 CSRF 攻击的第一步是登录到目标网站并浏览，寻找任何会改变数据的活动。
- en: For example, let’s say you’re testing *email.example.com*, a subdomain of *example.com*
    that handles email. Go through all the app’s functionalities, clicking all the
    links. Intercept the generated requests with a proxy like Burp and write down
    their URL endpoints.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，假设你正在测试 *email.example.com*，它是 *example.com* 的一个子域名，用于处理电子邮件。浏览应用程序的所有功能，点击所有链接。使用像
    Burp 这样的代理拦截生成的请求，并记录它们的 URL 端点。
- en: 'Record these endpoints one by one, in a list like the following, so you can
    revisit and test them later:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 一一记录下这些端点，按如下列表的方式，以便稍后回访和测试：
- en: '**State-changing requests on ***email.example.com*****'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: '**状态变化请求在***email.example.com*****'
- en: 'Change password: *email.example.com/password_change*'
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 更改密码：*email.example.com/password_change*
- en: POST request
  id: totrans-60
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: POST 请求
- en: 'Request parameters: `new_password`'
  id: totrans-61
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 请求参数：`new_password`
- en: 'Send email: *email.example.com/send_email*'
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 发送电子邮件：*email.example.com/send_email*
- en: POST request
  id: totrans-63
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: POST 请求
- en: 'Request parameters: `draft_id`, `recipient_id`'
  id: totrans-64
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 请求参数：`draft_id`, `recipient_id`
- en: 'Delete email: *email.example.com/delete_email*'
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 删除电子邮件：*email.example.com/delete_email*
- en: POST request
  id: totrans-66
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: POST 请求
- en: 'Request parameters: `email_id`'
  id: totrans-67
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 请求参数：`email_id`
- en: 'Step 2: Look for a Lack of CSRF Protections'
  id: totrans-68
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 第二步：寻找缺乏 CSRF 保护的地方
- en: Now visit these endpoints to test them for CSRFs. First, open up Burp Suite
    and start intercepting all the requests to your target site in the Proxy tab.
    Toggle the **Intercept** button until it reads **Intercept is on** ([Figure 9-3](#figure9-3)).
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 现在访问这些端点，测试它们是否存在 CSRF 漏洞。首先，打开 Burp Suite，并在 Proxy 标签页中开始拦截所有请求。切换**拦截**按钮，直到它显示**拦截已开启**（[图
    9-3](#figure9-3)）。
- en: '![f09003](image_fi/501546c09/f09003.png)'
  id: totrans-70
  prefs: []
  type: TYPE_IMG
  zh: '![f09003](image_fi/501546c09/f09003.png)'
- en: 'Figure 9-3: Set to Intercept is on to capture your browser’s traffic. Click
    the ***Forward*** button to forward the current request to the server.'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9-3：设置为“拦截已开启”，以捕捉浏览器流量。点击***转发***按钮将当前请求转发到服务器。
- en: 'Let Burp run in the background to record other traffic related to your target
    site while you’re actively hunting for CSRFs. Keep clicking the **Forward** button
    until you encounter the request associated with the state-changing action. For
    example, let’s say you’re testing whether the password-change function you discovered
    is vulnerable to CSRFs. You’ve intercepted the request in your Burp proxy:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 让 Burp 在后台运行，记录与目标网站相关的其他流量，同时你主动寻找 CSRF 攻击。继续点击**转发**按钮，直到你遇到与状态变化操作相关的请求。例如，假设你正在测试你发现的密码更改功能是否容易受到
    CSRF 攻击。你已经在 Burp 代理中截取了请求：
- en: '[PRE12]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'In the intercepted request, look for signs of CSRF protection mechanisms. Use
    the search bar at the bottom of the window to look for the string `"csrf"` or
    `"state"`. CSRF tokens can come in many forms besides POST body parameters; they
    sometimes show up in request headers, cookies, and URL parameters as well. For
    example, they might show up like the cookie here:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 在拦截的请求中，寻找 CSRF 保护机制的迹象。使用窗口底部的搜索栏，查找 `"csrf"` 或 `"state"` 字符串。CSRF 令牌除了作为 POST
    请求体参数外，还可能出现在请求头、cookie 或 URL 参数中。例如，它们可能出现在像这样的 cookie 中：
- en: '[PRE13]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: But even if you find a CSRF protection present on the endpoint, you could try
    a variety of protection-bypass techniques. I’ll talk about them later in the chapter.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 即使你在端点发现了 CSRF 保护，你仍然可以尝试各种绕过保护的技巧。我将在本章后面讨论这些技巧。
- en: 'Step 3: Confirm the Vulnerability'
  id: totrans-77
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 第 3 步：确认漏洞
- en: After you’ve found a potentially vulnerable endpoint, you’ll need to confirm
    the vulnerability. You can do this by crafting a malicious HTML form that imitates
    the request sent by the legitimate site.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 找到可能存在漏洞的端点后，你需要确认这个漏洞。你可以通过制作一个恶意的 HTML 表单来模仿合法站点发送的请求，从而完成这一确认。
- en: 'Craft an HTML page like this in your text editor. Make sure to save it with
    an *.html* extension! This way, your computer will open the file with a browser
    by default:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 在文本编辑器中制作一个这样的 HTML 页面。确保将文件保存为 *.html* 扩展名！这样，默认情况下，你的计算机会用浏览器打开该文件：
- en: '[PRE14]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The `<form>` tag specifies that you’re defining an HTML form. An HTML form’s
    `method` attribute specifies the HTML method of the request generated by the form,
    and the `action` attribute specifies where the request will be sent to 1. The
    form generates a POST request to the endpoint *https://email.example.com/password_change*.
    Next are two input tags. The first one defines a POST parameter with the name
    `new_password` and the value `abc123` 2. The second one specifies a `Submit` button
    3. Finally, the `<script>` tag at the bottom of the page contains JavaScript code
    that submits the form automatically 4.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: '`<form>` 标签指定你正在定义一个 HTML 表单。HTML 表单的 `method` 属性指定了由表单生成的请求的 HTML 方法，`action`
    属性指定了请求将被发送到的位置 1。该表单会生成一个 POST 请求，目标地址是 *https://email.example.com/password_change*。接下来是两个输入标签。第一个定义了一个名为
    `new_password`，值为 `abc123` 的 POST 参数 2。第二个指定了一个 `Submit` 按钮 3。最后，页面底部的 `<script>`
    标签包含了提交表单的 JavaScript 代码 4。'
- en: 'Open the HTML page in the browser that is signed into your target site. This
    form will generate a request like this:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 在浏览器中打开 HTML 页面，并确保已登录到目标站点。这个表单将生成类似下面的请求：
- en: '[PRE15]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Check if your password on *email.example.com* has been changed to `abc123`.
    In other words, check if the target server has accepted the request generated
    by your HTML page. The goal is to prove that a foreign site can carry out state-changing
    actions on a user’s behalf.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 检查你的密码是否已在 *email.example.com* 上更改为 `abc123`。换句话说，检查目标服务器是否已接受由你的 HTML 页面生成的请求。目的是证明一个外部网站可以代表用户执行改变状态的操作。
- en: Finally, some websites might be missing CSRF tokens but still protect against
    CSRF attacks by checking if the referer header of the request matches a legitimate
    URL. Checking the referer header protects against CSRF, because these headers
    help servers filter out requests that have originated from foreign sites. Confirming
    a CSRF vulnerability like this can help you rule out endpoints that have referer-based
    CSRF protection.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，一些网站可能没有 CSRF 令牌，但通过检查请求的 referer 头信息是否与合法 URL 匹配，仍然能防止 CSRF 攻击。检查 referer
    头有助于防止 CSRF 攻击，因为这些头信息帮助服务器过滤掉来自外部网站的请求。通过这种方式确认 CSRF 漏洞，可以帮助你排除那些基于 referer 的
    CSRF 保护的端点。
- en: However, it’s important for developers to remember that referer headers can
    be manipulated by attackers and aren’t a foolproof mitigation solution. Developers
    should implement a combination of CSRF tokens and `SameSite` session cookies for
    the best protection.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，开发人员必须记住，referer 头信息可以被攻击者篡改，并且并非万无一失的缓解解决方案。开发人员应该实现 CSRF 令牌和 `SameSite`
    会话 cookie 的组合，以获得最佳保护。
- en: Bypassing CSRF Protection
  id: totrans-87
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 绕过 CSRF 保护
- en: Modern websites are becoming more secure. These days, when you examine requests
    that deal with sensitive actions, they’ll often have some form of CSRF protection.
    However, the existence of protections doesn’t mean that the protection is comprehensive,
    well implemented, and impossible to bypass. If the protection is incomplete or
    faulty, you might still be able to achieve a CSRF attack with a few modifications
    to your payload. Let’s talk about techniques you can use to bypass CSRF protection
    implemented on websites.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 现代网站变得越来越安全。如今，当你检查涉及敏感操作的请求时，它们通常会有某种形式的CSRF保护。然而，保护的存在并不意味着保护是全面的、正确实现的，也不代表它无法绕过。如果保护措施不完整或有缺陷，你仍然可以通过对有效负载做一些修改来实现CSRF攻击。让我们来谈谈你可以用来绕过网站上实现的CSRF保护的技巧。
- en: Exploit Clickjacking
  id: totrans-89
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 利用点击劫持
- en: If the endpoint uses CSRF tokens but the page itself is vulnerable to clickjacking,
    an attack discussed in Chapter 8, you can exploit clickjacking to achieve the
    same results as a CSRF.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 如果该端点使用CSRF令牌，但页面本身容易受到点击劫持（这种攻击在第8章中讨论过），你可以利用点击劫持来实现与CSRF相同的效果。
- en: This is because, in a clickjacking attack, an attacker uses an iframe to frame
    the page in a malicious site while having the state-changing request originate
    from the legitimate site. If the page where the vulnerable endpoint is located
    is vulnerable to clickjacking, you’ll be able to achieve the same results as a
    CSRF attack on the endpoint, albeit with a bit more effort and CSS skills.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 这是因为，在点击劫持攻击中，攻击者使用iframe将页面嵌入恶意站点，同时让更改状态的请求从合法站点发起。如果包含漏洞端点的页面容易受到点击劫持攻击，你就可以通过更多的努力和CSS技巧，达到类似于CSRF攻击的效果。
- en: 'Check a page for clickjacking by using an HTML page like the following one.
    You can place a page in an iframe by specifying its URL as the `src` attribute
    of an `<iframe>` tag. Then, render the HTML page in your browser. If the page
    that the state-changing function is located in appears in your iframe, the page
    is vulnerable to clickjacking:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用类似以下的HTML页面，检查页面是否存在点击劫持。你可以通过将其URL指定为`src`属性，嵌入一个iframe中。然后，在浏览器中渲染该HTML页面。如果更改状态的功能所在的页面出现在你的iframe中，那么该页面就容易受到点击劫持攻击：
- en: '[PRE16]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Then you could use clickjacking to trick users into executing the state-changing
    action. Refer to Chapter 8 to learn how this attack works.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，你可以利用点击劫持诱使用户执行更改状态的操作。有关这种攻击的工作原理，请参阅第8章。
- en: Change the Request Method
  id: totrans-95
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 更改请求方法
- en: Another trick you can use to bypass CSRF protections is changing the request
    method. Sometimes sites will accept multiple request methods for the same endpoint,
    but protection might not be in place for each of those methods. By changing the
    request method, you might be able to get the action executed without encountering
    CSRF protection.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用的另一个绕过CSRF保护的技巧是更改请求方法。有时网站会接受同一接口的多种请求方法，但可能并没有为每种方法设置保护。通过更改请求方法，你可能能够在不遇到CSRF保护的情况下执行操作。
- en: 'For example, say the POST request of the password-change endpoint is protected
    by a CSRF token, like this:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，假设密码更改接口的POST请求受CSRF令牌保护，像这样：
- en: '[PRE17]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'You can try to send the same request as a GET request and see if you can get
    away with not providing a CSRF token:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以尝试将相同的请求作为GET请求发送，看看是否能在不提供CSRF令牌的情况下绕过保护：
- en: '[PRE18]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'In this case, your malicious HTML page could simply look like this:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，你的恶意HTML页面可以简单地像这样：
- en: '[PRE19]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: The HTML `<img>` tag loads images from external sources. It will send a GET
    request to the URL specified in its `src` attribute.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: HTML的`<img>`标签从外部源加载图像。它将向其`src`属性中指定的URL发送一个GET请求。
- en: If the password change occurs after you load this HTML page, you can confirm
    that the endpoint is vulnerable to CSRF via a GET request. On the other hand,
    if the original action normally uses a GET request, you can try converting it
    into a POST request instead.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在加载该HTML页面后发生密码更改，你可以确认该端点通过GET请求存在CSRF漏洞。另一方面，如果原始操作通常使用GET请求，你可以尝试将其转换为POST请求。
- en: Bypass CSRF Tokens Stored on the Server
  id: totrans-105
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 绕过存储在服务器上的CSRF令牌
- en: But what if neither clickjacking nor changing the request method works? If the
    site implements CSRF protection via tokens, here are a few more things that you
    can try.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，如果点击劫持和更改请求方法都不起作用怎么办？如果网站通过令牌实现CSRF保护，以下是你可以尝试的几个方法。
- en: Just because a site uses CSRF tokens doesn’t mean it is validating them properly.
    If the site isn’t validating CSRF tokens in the right way, you can still achieve
    CSRF with a few modifications of your malicious HTML page.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 仅仅因为网站使用了 CSRF 令牌，并不意味着它正确地验证了这些令牌。如果网站没有以正确的方式验证 CSRF 令牌，你仍然可以通过对恶意 HTML 页面进行一些修改来实现
    CSRF 攻击。
- en: 'First, try deleting the token parameter or sending a blank token parameter.
    For example, this will send the request without a `csrf_token` parameter:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，尝试删除令牌参数或发送空的令牌参数。例如，以下将发送一个没有`csrf_token`参数的请求：
- en: '[PRE20]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'You can generate this request with an HTML form like this:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用如下的 HTML 表单来生成这个请求：
- en: '[PRE21]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'This next request will send a blank `csrf_token` parameter:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个请求将发送一个空的`csrf_token`参数：
- en: '[PRE22]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'You can generate a payload like this by using an HTML form like the following:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过使用以下 HTML 表单来生成这样的有效载荷：
- en: '[PRE23]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Deleting the token parameter or sending a blank token often works because of
    a common application logic mistake. Applications sometimes check the validity
    of the token only *if* the token exists, or if the token parameter is not blank.
    The code for an insecure application’s validation mechanism might look roughly
    like this:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 删除令牌参数或发送空令牌参数通常有效，因为常见的应用程序逻辑错误。应用程序有时只会在令牌存在时，或者令牌参数不为空时检查令牌的有效性。不安全的应用程序验证机制的代码可能大致如下所示：
- en: '[PRE24]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: This fragment of Python code first checks whether the CSRF token exists 1. If
    it exists, the code will proceed to validate the token. If the token is valid,
    the code will continue. If the token is invalid, the code will stop the execution
    and produce an error 2. On the other hand, if the token does not exist, the code
    will skip validation and jump to executing the action right away 3. In this case,
    sending a request without the token, or a blank value as the token, may mean the
    server won’t attempt to validate the token at all.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 这段 Python 代码首先检查 CSRF 令牌是否存在 1。如果存在，代码将继续验证令牌。如果令牌有效，代码将继续执行。如果令牌无效，代码将停止执行并产生错误
    2。另一方面，如果令牌不存在，代码将跳过验证，直接执行操作 3。在这种情况下，发送没有令牌的请求或将令牌设置为空值，可能意味着服务器根本不会尝试验证令牌。
- en: 'You can also try submitting the request with another session’s CSRF token.
    This works because some applications might check only whether the token is valid,
    without confirming that it belongs to the current user. Let’s say the victim’s
    token is `871caef0757a4ac9691aceb9aad8b65b`, and yours is `YOUR_TOKEN`. Even though
    it’s hard to get the victim’s token, you can obtain your own token easily, so
    try providing your own token in the place of the legitimate token. You can also
    create another test account to generate tokens if you don’t want to use your own
    tokens. For example, your exploit code might look like this:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以尝试使用另一个会话的 CSRF 令牌提交请求。之所以有效，是因为一些应用程序可能只检查令牌是否有效，而不确认它是否属于当前用户。假设受害者的令牌是`871caef0757a4ac9691aceb9aad8b65b`，而你的令牌是`YOUR_TOKEN`。尽管很难获得受害者的令牌，但你可以轻松获得自己的令牌，所以可以尝试用自己的令牌替换合法的令牌。如果你不想使用自己的令牌，还可以创建另一个测试账户来生成令牌。例如，你的利用代码可能如下所示：
- en: '[PRE25]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'The faulty application logic might look something like this:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 错误的应用程序逻辑可能如下所示：
- en: '[PRE26]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: The Python code here first validates the CSRF token. If the token is in a list
    of current valid tokens 1, execution continues and the state-changing action is
    executed 2. Otherwise, an error is generated and execution halts. If this is the
    case, you can insert your own CSRF token into the malicious request!
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 这段 Python 代码首先验证 CSRF 令牌。如果令牌在当前有效令牌列表中 1，执行将继续，并执行改变状态的操作 2。否则，将产生错误并停止执行。如果是这种情况，你可以将自己的
    CSRF 令牌插入到恶意请求中！
- en: Bypass Double-Submit CSRF Tokens
  id: totrans-124
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 绕过双重提交 CSRF 令牌
- en: 'Sites also commonly use a *double-submit cookie* as a defense against CSRF.
    In this technique, the state-changing request contains the same random token as
    both a cookie and a request parameter, and the server checks whether the two values
    are equal. If the values match, the request is seen as legitimate. Otherwise,
    the application rejects it. For example, this request would be deemed valid, because
    the `csrf_token` in the user’s cookies matches the `csrf_token` in the POST request
    parameter:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 网站通常使用*双重提交 cookie*作为防范 CSRF 的手段。在这种技术中，改变状态的请求包含与 cookie 和请求参数中相同的随机令牌，服务器检查这两个值是否相等。如果值匹配，请求被视为合法请求。否则，应用程序将拒绝该请求。例如，以下请求被认为是有效的，因为用户的
    cookie 中的`csrf_token`与 POST 请求参数中的`csrf_token`匹配：
- en: '[PRE27]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'And the following one would fail. Notice that the `csrf_token` in the user’s
    cookies is different from the `csrf_token` in the POST request parameter. In a
    double-submit token validation system, it does not matter whether the tokens themselves
    are valid. The server checks only whether the token in the cookies is the same
    as the token in the request parameters:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例会失败。请注意，用户 cookies 中的 `csrf_token` 与 POST 请求参数中的 `csrf_token` 不同。在双重提交令牌验证系统中，令牌本身是否有效并不重要。服务器只检查
    cookies 中的令牌是否与请求参数中的令牌相同：
- en: '[PRE28]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: If the application uses double-submit cookies as its CSRF defense mechanism,
    it’s probably not keeping records of the valid token server-side. If the server
    were keeping records of the CSRF token server-side, it could simply validate the
    token when it was sent over, and the application would not need to use double-submit
    cookies in the first place.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 如果应用程序使用双重提交 cookie 作为其 CSRF 防御机制，那么它可能没有在服务器端记录有效令牌。如果服务器在服务器端记录了 CSRF 令牌，它就可以在令牌发送过来时进行验证，应用程序就不需要使用双重提交
    cookie 了。
- en: 'The server has no way of knowing if any token it receives is actually legitimate;
    it’s merely checking that the token in the cookie and the token in the request
    body is the same. In other words, this request, which enters the same bogus value
    as both the cookie and request parameter, would also be seen as legitimate:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 服务器无法知道它接收到的任何令牌是否真正合法；它只是检查 cookie 中的令牌和请求体中的令牌是否相同。换句话说，这个请求，假如同时在 cookie
    和请求参数中都传入相同的虚假值，也会被认为是合法的：
- en: '[PRE29]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Generally, you shouldn’t have the power to change another user’s cookies. But
    if you can find a way to make the victim’s browser send along a fake cookie, you’ll
    be able to execute the CSRF.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，你不应该有权限修改其他用户的 cookies。但如果你能找到一种方法让受害者的浏览器发送一个伪造的 cookie，你就能执行 CSRF 攻击。
- en: 'The attack would then consist of two steps: first, you’d use a session-fixation
    technique to make the victim’s browser store whatever value you choose as the
    CSRF token cookie. *Session fixation* is an attack that allows attackers to select
    the session cookies of the victim. We do not cover session fixations in this book,
    but you can read about them on Wikipedia ([https://en.wikipedia.org/wiki/Session_fixation](https://en.wikipedia.org/wiki/Session_fixation)).
    Then, you’d execute the CSRF with the same CSRF token that you chose as the cookie.'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 该攻击将包括两个步骤：首先，你会使用会话固定技术使受害者的浏览器将你选择的任意值作为 CSRF 令牌 cookie 存储。*会话固定* 是一种允许攻击者选择受害者会话
    cookie 的攻击方式。本书中不涉及会话固定攻击，但你可以在 Wikipedia 上阅读相关内容（[https://en.wikipedia.org/wiki/Session_fixation](https://en.wikipedia.org/wiki/Session_fixation)）。然后，你会使用相同的
    CSRF 令牌执行 CSRF 攻击，该令牌就是你之前选择作为 cookie 的那个。
- en: Bypass CSRF Referer Header Check
  id: totrans-134
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 绕过 CSRF Referer 头检查
- en: What if your target site isn’t using CSRF tokens but checking the referer header
    instead? The server might verify that the referer header sent with the state-changing
    request is a part of the website’s allowlisted domains. If it is, the site would
    execute the request. Otherwise, it would deem the request to be fake and reject
    it. What can you do to bypass this type of protection?
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你的目标站点没有使用 CSRF 令牌，而是检查 referer 头怎么办？服务器可能会验证随状态改变请求一起发送的 referer 头是否是网站允许的域名的一部分。如果是，网站就会执行该请求。否则，它会认为请求是伪造的并拒绝它。你可以做什么来绕过这种保护？
- en: 'First, you can try to remove the referer header. Like sending a blank token,
    sometimes all you need to do to bypass a referer check is to not send a referer
    at all. To remove the referer header, add a `<meta>` tag to the page hosting your
    request form:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，你可以尝试去除 referer 头。就像发送一个空的令牌一样，有时绕过 referer 检查所需要做的就是根本不发送 referer 头。要移除
    referer 头，只需在承载你请求表单的页面中添加一个 `<meta>` 标签：
- en: '[PRE30]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: This particular `<meta>` tag tells the browser to not include a referer header
    in the resulting HTTP request.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 这个特定的 `<meta>` 标签告诉浏览器在生成的 HTTP 请求中不要包含 referer 头。
- en: 'The faulty application logic might look like this:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 错误的应用逻辑可能如下所示：
- en: '[PRE31]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Since the application validates the referer header only if it exists, you’ve
    successfully bypassed the website’s CSRF protection just by making the victim’s
    browser omit the referer header!
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 由于应用程序只在 referer 头存在时验证它，你仅仅通过让受害者的浏览器省略 referer 头，就成功绕过了网站的 CSRF 保护！
- en: 'You can also try to bypass the logic check used to validate the referer URL.
    Let’s say the application looks for the string `"example.com"` in the referer
    URL, and if the referer URL contains that string, the application treats the request
    as legitimate. Otherwise, it rejects the request:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以尝试绕过用于验证 referer URL 的逻辑检查。假设应用程序在 referer URL 中查找字符串 `"example.com"`，如果
    referer URL 包含该字符串，应用程序会将请求视为合法请求，否则拒绝该请求：
- en: '[PRE32]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'In this case, you can bypass the referer check by placing the victim domain
    name in the referer URL as a subdomain. You can achieve this by creating a subdomain
    named after the victim’s domain, and then hosting the malicious HTML on that subdomain.
    Your request would look like this:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，你可以通过将受害者的域名作为子域名放入 referer URL 来绕过 referer 校验。你可以通过创建一个与受害者域名同名的子域，然后将恶意
    HTML 托管在该子域上来实现。你的请求看起来像这样：
- en: '[PRE33]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'You can also try placing the victim domain name in the referer URL as a pathname.
    You can do so by creating a file with the name of the target’s domain and hosting
    your HTML page there:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以尝试将受害者域名放在 referer URL 的路径名中。你可以通过创建一个与目标域名同名的文件，并将 HTML 页面托管在该文件中来实现：
- en: '[PRE34]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: After you’ve uploaded your HTML page at the correct location, load that page
    and see if the state-changing action was executed.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 在你将 HTML 页面上传到正确位置后，加载该页面并查看状态更改操作是否执行。
- en: Bypass CSRF Protection by Using XSS
  id: totrans-149
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 通过使用 XSS 绕过 CSRF 保护
- en: In addition, as I mentioned in Chapter 6, any XSS vulnerability will defeat
    CSRF protections, because XSS will allow attackers to steal the legitimate CSRF
    token and then craft forged requests by using `XMLHttpRequest`. Often, attackers
    will find XSS as the starting point to launch CSRFs to take over admin accounts.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，正如我在第六章中提到的，任何 XSS 漏洞都会使 CSRF 保护失效，因为 XSS 允许攻击者窃取合法的 CSRF token，然后通过使用`XMLHttpRequest`伪造请求。攻击者通常会以
    XSS 作为启动点，发起 CSRF 攻击，接管管理员账户。
- en: Escalating the Attack
  id: totrans-151
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 升级攻击
- en: After you’ve found a CSRF vulnerability, don’t just report it right away! Here
    are a few ways you can escalate CSRFs into severe security issues to maximize
    the impact of your report. Often, you need to use a combination of CSRF and other
    minor design flaws to discover these.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦发现了 CSRF 漏洞，不要马上报告！这里有一些方法，可以将 CSRF 漏洞升级为严重的安全问题，最大化报告的影响。通常，你需要结合 CSRF 和其他一些小设计缺陷来发现这些漏洞。
- en: Leak User Information by Using CSRF
  id: totrans-153
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 通过使用 CSRF 泄漏用户信息
- en: CSRF can sometimes cause information leaks as a side effect. Applications often
    send or disclose information according to user preferences. If you can change
    these settings via CSRF, you can pave the way for sensitive information disclosures.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: CSRF 有时会导致信息泄漏作为副作用。应用程序通常会根据用户偏好发送或披露信息。如果你能通过 CSRF 修改这些设置，就可以为敏感信息泄露铺平道路。
- en: 'For example, let’s say the *example.com* web application sends monthly billing
    emails to a user-designated email address. These emails contain the users’ billing
    information, including street addresses, phone numbers, and credit card information.
    The email address to which these billing emails are sent can be changed via the
    following request:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，假设 *example.com* 网站每月会向用户指定的电子邮件地址发送账单邮件。这些邮件包含用户的账单信息，包括街道地址、电话号码和信用卡信息。可以通过以下请求来更改发送账单邮件的电子邮件地址：
- en: '[PRE35]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Unfortunately, the CSRF validation on this endpoint is broken, and the server
    accepts a blank token. The request would succeed even if the `csrf_token` field
    is left empty:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，这个端点的 CSRF 校验已经破坏，服务器接受空白的 token。即使`csrf_token`字段为空，请求也会成功：
- en: '[PRE36]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'An attacker could make a victim user send this request via CSRF to change the
    destination of their billing emails:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 攻击者可以让受害者通过 CSRF 发送此请求，改变他们账单邮件的接收地址：
- en: '[PRE37]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: All future billing emails would then be sent to the attacker’s email address
    until the victim notices the unauthorized change. Once the billing email is sent
    to the attacker’s email address, the attacker can collect sensitive information,
    such as street addresses, phone numbers, and credit card information associated
    with the account.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 此后，所有未来的账单邮件将会发送到攻击者的电子邮件地址，直到受害者注意到未经授权的更改。一旦账单邮件发送到攻击者的邮箱，攻击者就可以收集敏感信息，如街道地址、电话号码和与账户关联的信用卡信息。
- en: Create Stored Self-XSS by Using CSRF
  id: totrans-162
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 通过使用 CSRF 创建存储型自我 XSS
- en: Remember from Chapter 6 that self-XSS is a kind of XSS attack that requires
    the victim to input the XSS payload. These vulnerabilities are almost always considered
    a nonissue because they’re too difficult to exploit; doing so requires a lot of
    action from the victim’s part, and thus you’re unlikely to succeed. However, when
    you combine CSRF with self-XSS, you can often turn the self-XSS into stored XSS.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，在第六章中提到过，自XSS是一种需要受害者输入XSS有效载荷的XSS攻击。这些漏洞几乎总是被认为不是问题，因为它们太难利用；要成功攻击需要受害者采取大量行动，因此攻击者不太可能成功。然而，当你将CSRF与自XSS结合时，你通常可以将自XSS转变为存储型XSS。
- en: 'For example, let’s say that *example.com*’s financial subdomain, *finance.example.com*,
    gives users the ability to create nicknames for each of their linked bank accounts.
    The account nickname field is vulnerable to self-XSS: there is no sanitization,
    validation, or escaping for user input on the field. However, only the user can
    edit and see this field, so there is no way for an attacker to trigger the XSS
    directly.'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，假设*example.com*的财务子域名*finance.example.com*允许用户为每个关联的银行账户创建昵称。账户昵称字段容易受到自XSS攻击：该字段没有对用户输入进行清理、验证或转义。然而，只有用户自己可以编辑和查看此字段，因此攻击者无法直接触发XSS。
- en: 'However, the endpoint used to change the account nicknames is vulnerable to
    CSRF. The application doesn’t properly validate the existence of the CSRF token,
    so simply omitting the token parameter in the request will bypass CSRF protection.
    For example, this request would fail, because it contains the wrong token:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，用于更改账户昵称的端点容易受到CSRF攻击。该应用程序没有正确验证CSRF令牌的存在，因此仅仅在请求中省略令牌参数就可以绕过CSRF保护。例如，这个请求会失败，因为它包含错误的令牌：
- en: '[PRE38]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'But this request, with no token at all, would succeed:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 但是这个没有令牌的请求会成功：
- en: '[PRE39]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: This request will change the user’s account nickname and store the XSS payload
    there. The next time a user logs into the account and views their dashboard, they’ll
    trigger the XSS.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 这个请求将改变用户的账户昵称，并在那里存储XSS有效载荷。下次用户登录账户并查看他们的仪表板时，他们会触发XSS。
- en: Take Over User Accounts by Using CSRF
  id: totrans-170
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 通过使用CSRF接管用户账户
- en: Sometimes CSRF can even lead to account takeover. These situations aren’t uncommon,
    either; account takeover issues occur when a CSRF vulnerability exists in critical
    functionality, like the code that creates a password, changes the password, changes
    the email address, or resets the password.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 有时候，CSRF甚至可能导致账户接管。这种情况也并不罕见；当CSRF漏洞存在于关键功能中，如创建密码、修改密码、更改电子邮件地址或重置密码的代码时，就会发生账户接管问题。
- en: 'For example, let’s say that in addition to signing up by using an email address
    and password, *example.com* also allows users to sign up via their social media
    accounts. If a user chooses this option, they’re not required to create a password,
    as they can simply log in via their linked account. But to give users another
    option, those who’ve signed up via social media can set a new password via the
    following request:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，假设除了使用电子邮件地址和密码注册外，*example.com*还允许用户通过社交媒体账户注册。如果用户选择此选项，他们不需要创建密码，因为他们可以直接通过关联的账户登录。但为了给用户提供更多选择，已通过社交媒体注册的用户可以通过以下请求设置新密码：
- en: '[PRE40]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Since the user signed up via their social media account, they don’t need to
    provide an old password to set the new password, so if CSRF protection fails on
    this endpoint, an attacker would have the ability to set a password for anyone
    who signed up via their social media account and hasn’t yet done so.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 由于用户是通过社交媒体账户注册的，他们不需要提供旧密码即可设置新密码，因此，如果此端点的CSRF保护失败，攻击者将能够为任何通过社交媒体账户注册且尚未设置密码的用户设置密码。
- en: 'Let’s say the application doesn’t validate the CSRF token properly and accepts
    an empty value. The following request will set a password for anyone who doesn’t
    already have one set:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 假设应用程序没有正确验证CSRF令牌，并接受空值。以下请求将为任何尚未设置密码的用户设置密码：
- en: '[PRE41]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Now all an attacker has to do is to post a link to this HTML page on pages
    frequented by users of the site, and they can automatically assign the password
    of any user who visits the malicious page:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 现在攻击者所需要做的只是将这个HTML页面的链接发布到网站用户常访问的页面上，任何访问该恶意页面的用户都会自动被分配密码：
- en: '[PRE42]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: After that, the attacker is free to log in as any of the affected victims with
    the newly assigned password `this_account_is_now_mine`.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 此后，攻击者可以自由地以任何受影响的受害者身份登录，使用新分配的密码`this_account_is_now_mine`。
- en: While the majority of CSRFs that I have encountered were low-severity issues,
    sometimes a CSRF on a critical endpoint can lead to severe consequences.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管我遇到的大多数 CSRF 都是低严重性问题，但有时关键端点上的 CSRF 可能导致严重后果。
- en: Delivering the CSRF Payload
  id: totrans-181
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 交付 CSRF 载荷
- en: Quite often in bug bounty reports, you’ll need to show companies that attackers
    can reliably deliver a CSRF payload. What options do attackers have to do so?
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 在漏洞悬赏报告中，你经常需要向公司展示攻击者可以可靠地交付 CSRF 载荷。攻击者有哪些选项可以做到这一点呢？
- en: 'The first and simplest option of delivering a CSRF payload is to trick users
    into visiting an external malicious site. For example, let’s say *example.com*
    has a forum that users frequent. In this case, attackers can post a link like
    this on the forum to encourage users to visit their page:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 交付 CSRF 载荷的第一个也是最简单的方式是通过诱使用户访问一个外部恶意网站。例如，假设 *example.com* 有一个用户经常访问的论坛。在这种情况下，攻击者可以在论坛上发布类似这样的链接，鼓励用户访问他们的页面：
- en: 'Visit this page to get a discount on your *example.com* subscription: *https://example.attacker.com*'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 访问此页面，获取你在 *example.com* 订阅的折扣： *https://example.attacker.com*
- en: 'And on *example.attacker.com*, the attacker can host an auto-submitting form
    to execute the CSRF:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 而在 *example.attacker.com* 上，攻击者可以托管一个自动提交的表单来执行 CSRF：
- en: '[PRE43]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'For CSRFs that you could execute via a GET request, attackers can often embed
    the request as an image directly—for example, as an image posted to a forum. This
    way, any user who views the forum page would be affected:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 对于可以通过 GET 请求执行的 CSRF，攻击者通常可以将请求作为图片直接嵌入——例如，作为发布到论坛的图片。这样，任何查看该论坛页面的用户都会受到影响：
- en: '[PRE44]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Finally, attackers can deliver a CSRF payload to a large audience by exploiting
    stored XSS. If the forum comment field suffers from this vulnerability, an attacker
    can submit a stored-XSS payload there to make any forum visitor execute the attacker’s
    malicious script. In the malicious script, the attacker can include code that
    sends the CSRF payload:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，攻击者可以通过利用存储型 XSS 向大量受众交付 CSRF 载荷。如果论坛评论字段存在此漏洞，攻击者可以在其中提交一个存储型 XSS 载荷，使任何论坛访问者执行攻击者的恶意脚本。在恶意脚本中，攻击者可以包含发送
    CSRF 载荷的代码：
- en: '[PRE45]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: This piece of JavaScript code adds our exploit form to the user’s current page
    and then auto-submits that form.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 这段 JavaScript 代码将我们的利用表单添加到用户的当前页面，并自动提交该表单。
- en: Using these delivery methods, you can show companies how attackers can realistically
    attack many users and demonstrate the maximum impact of your CSRF vulnerability.
    If you have Burp Suite Pro, or use the ZAP proxy, you can also take advantage
    of their CSRF POC-generation functionality. For more information, search the tools’
    documentation for *CSRF POC generation*. You can also keep a POC script you wrote
    yourself and insert a target site’s URLs into the script every time you test a
    new target.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这些交付方式，你可以向公司展示攻击者如何现实地攻击多个用户，并演示你 CSRF 漏洞的最大影响。如果你有 Burp Suite Pro，或者使用 ZAP
    代理，你也可以利用它们的 CSRF POC 生成功能。有关更多信息，请在工具的文档中查找 *CSRF POC generation*。你也可以保留你自己编写的
    POC 脚本，并在每次测试新目标时将目标网站的 URL 插入脚本中。
- en: Finding Your First CSRF!
  id: totrans-193
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 找到你的第一个 CSRF！
- en: 'Armed with this knowledge about CSRF bugs, bypassing CSRF protection, and escalating
    CSRF vulnerabilities, you’re now ready to look for your first CSRF vulnerability!
    Hop on a bug bounty program and find your first CSRF by following the steps covered
    in this chapter:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 掌握了有关 CSRF 漏洞、绕过 CSRF 保护和提升 CSRF 漏洞的知识后，你现在已经准备好寻找你的第一个 CSRF 漏洞！加入一个漏洞悬赏计划，并按照本章中涵盖的步骤找到你的第一个
    CSRF：
- en: Spot the state-changing actions on the application and keep a note on their
    locations and functionality.
  id: totrans-195
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 找出应用程序中的状态更改操作，并记录它们的位置和功能。
- en: Check these functionalities for CSRF protection. If you can’t spot any protections,
    you might have found a vulnerability!
  id: totrans-196
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 检查这些功能是否有 CSRF 保护。如果你没有发现任何保护，你可能已经找到了一个漏洞！
- en: If any CSRF protection mechanisms are present, try to bypass the protection
    by using the protection-bypass techniques mentioned in this chapter.
  id: totrans-197
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果存在任何 CSRF 保护机制，尝试通过使用本章中提到的保护绕过技术来绕过保护。
- en: Confirm the vulnerability by crafting a malicious HTML page and visiting that
    page to see if the action has executed.
  id: totrans-198
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过制作一个恶意的 HTML 页面并访问该页面，确认漏洞是否存在，看看操作是否已执行。
- en: Think of strategies for delivering your payload to end users.
  id: totrans-199
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 思考将载荷交付给最终用户的策略。
- en: Draft your first CSRF report!
  id: totrans-200
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 草拟你的第一个 CSRF 报告！
