- en: '2'
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '2'
- en: THE ELF FORMAT
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: ELF 格式
- en: Now that you have a high-level idea of what binaries look like and how they
    work, you’re ready to dive into a real binary format. In this chapter, you’ll
    investigate the Executable and Linkable Format (ELF), which is the default binary
    format on Linux-based systems and the one you’ll be working with in this book.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你对二进制文件的外观和工作原理有了一个大致的了解，你可以开始深入研究真正的二进制格式了。在本章中，你将探讨可执行与可链接格式（ELF），这是基于 Linux
    的系统上的默认二进制格式，也是你在本书中将要处理的格式。
- en: ELF is used for executable files, object files, shared libraries, and core dumps.
    I’ll focus on ELF executables here, but the same concepts apply to other ELF file
    types. Because you will deal mostly with 64-bit binaries in this book, I’ll center
    the discussion around 64-bit ELF files. However, the 32-bit format is similar,
    differing mainly in the size and order of certain header fields and other data
    structures. You shouldn’t have any trouble generalizing the concepts discussed
    here to 32-bit ELF binaries.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: ELF 用于可执行文件、目标文件、共享库和核心转储。在这里我将专注于 ELF 可执行文件，但相同的概念也适用于其他 ELF 文件类型。由于你在本书中主要处理的是
    64 位二进制文件，所以我将围绕 64 位 ELF 文件进行讨论。然而，32 位格式相似，主要的区别在于某些头字段和其他数据结构的大小和顺序。你不应该在将这里讨论的概念推广到
    32 位 ELF 二进制文件时遇到任何问题。
- en: '[Figure 2-1](ch02.xhtml#ch02fig1) illustrates the format and contents of a
    typical 64-bit ELF executable. When you first start analyzing ELF binaries in
    detail, all the intricacies involved may seem overwhelming. But in essence, ELF
    binaries really consist of only four types of components: an *executable header*,
    a series of (optional) *program headers*, a number of *sections*, and a series
    of (optional) *section headers*, one per section. I’ll discuss each of these components
    next.'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 2-1](ch02.xhtml#ch02fig1)展示了一个典型的 64 位 ELF 可执行文件的格式和内容。当你第一次开始详细分析 ELF 二进制文件时，所有涉及的复杂性可能会让人感到不知所措。但从本质上讲，ELF
    二进制文件实际上只由四种类型的组件组成：*可执行文件头*、一系列（可选的）*程序头*、若干个*节*，以及一系列（可选的）*节头*，每个节一个头。接下来我会逐一讨论这些组件。'
- en: '![image](Images/f032-01.jpg)'
  id: totrans-5
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/f032-01.jpg)'
- en: '*Figure 2-1: A 64-bit ELF binary at a glance*'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 2-1：一眼看出 64 位 ELF 二进制文件*'
- en: As you can see in [Figure 2-1](ch02.xhtml#ch02fig1), the executable header comes
    first in standard ELF binaries, the program headers come next, and the sections
    and section headers come last. To make the following discussion easier to follow,
    I’ll use a slightly different order and discuss sections and section headers before
    program headers. Let’s start with the executable header.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你在 [图 2-1](ch02.xhtml#ch02fig1) 中看到的，标准 ELF 二进制文件首先是可执行文件头，其次是程序头，最后是节和节头。为了使接下来的讨论更容易理解，我将使用稍微不同的顺序，在讨论程序头之前先讨论节和节头。让我们从可执行文件头开始。
- en: 2.1 The Executable Header
  id: totrans-8
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.1 可执行文件头
- en: Every ELF file starts with an *executable header*, which is just a structured
    series of bytes telling you that it’s an ELF file, what kind of ELF file it is,
    and where in the file to find all the other contents. To find out what the format
    of the executable header is, you can look up its type definition (and the definitions
    of other ELF-related types and constants) in */usr/include/elf.h* or in the ELF
    specification.^([1](footnote.xhtml#ch02fn_1)) [Listing 2-1](ch02.xhtml#ch02list1)
    shows the type definition for the 64-bit ELF executable header.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 每个 ELF 文件都以一个 *可执行文件头* 开始，它只是一个结构化的字节序列，告诉你它是一个 ELF 文件，是什么类型的 ELF 文件，并且指示在文件中在哪里可以找到其他所有内容。要了解可执行文件头的格式，你可以查找其类型定义（以及其他与
    ELF 相关的类型和常量的定义）在 */usr/include/elf.h* 或 ELF 规范中。^([1](footnote.xhtml#ch02fn_1))
    [列表 2-1](ch02.xhtml#ch02list1) 显示了 64 位 ELF 可执行文件头的类型定义。
- en: '*Listing 2-1: Definition of* ELF64_Ehdr *in* /usr/include/elf.h'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 2-1：在* /usr/include/elf.h *中的 ELF64_Ehdr 定义*'
- en: '[PRE0]'
  id: totrans-11
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The executable header is represented here as a C `struct` called `Elf64 _Ehdr`.
    If you look it up in */usr/include/elf.h*, you may notice that the `struct` definition
    given there contains types such as `Elf64_Half` and `Elf64_Word`. These are just
    `typedef`s for integer types such as `uint16_t` and `uint32_t`. For simplicity,
    I’ve expanded all the `typedef`s in [Figure 2-1](ch02.xhtml#ch02fig1) and [Listing
    2-1](ch02.xhtml#ch02list1).
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 可执行文件头在这里表示为一个 C `struct`，叫做 `Elf64_Ehdr`。如果你在 */usr/include/elf.h* 中查找它，你可能会注意到，那里给出的
    `struct` 定义包含了像 `Elf64_Half` 和 `Elf64_Word` 这样的类型。这些只是整数类型的 `typedef`，例如 `uint16_t`
    和 `uint32_t`。为了简便起见，我已经在 [图 2-1](ch02.xhtml#ch02fig1) 和 [列表 2-1](ch02.xhtml#ch02list1)
    中展开了所有的 `typedef`。
- en: '*2.1.1 The e_ident Array*'
  id: totrans-13
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '*2.1.1 e_ident 数组*'
- en: The executable header (and the ELF file) starts with a 16-byte array called
    `e_ident`. The `e_ident` array always starts with a 4-byte “magic value” identifying
    the file as an ELF binary. The magic value consists of the hexadecimal number
    `0x7f`, followed by the ASCII character codes for the letters *E*, *L*, and *F*.
    Having these bytes right at the start is convenient because it allows tools such
    as `file`, as well as specialized tools such as the binary loader, to quickly
    discover that they’re dealing with an ELF file.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 可执行文件头（以及ELF文件）从一个16字节的数组`e_ident`开始。`e_ident`数组总是以一个4字节的“魔术值”开头，用于标识该文件为ELF二进制文件。魔术值由十六进制数`0x7f`组成，后跟字母*E*、*L*和*F*的ASCII字符代码。将这些字节放在文件的开始位置非常方便，因为它允许诸如`file`工具以及二进制加载器等专用工具迅速识别出这是一个ELF文件。
- en: Following the magic value, there are a number of bytes that give more detailed
    information about the specifics of the type of ELF file. In *elf.h*, the indexes
    for these bytes (indexes 4 through 15 in the `e_ident` array) are symbolically
    referred to as `EI_CLASS`, `EI_DATA`, `EI_VERSION`, `EI_OSABI`, `EI_ABIVERSION`,
    and `EI_PAD`, respectively. [Figure 2-1](ch02.xhtml#ch02fig1) shows a visual representation
    of them.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 紧跟在魔术值之后的是一些字节，它们提供了关于ELF文件类型的更多详细信息。在*elf.h*中，这些字节的索引（`e_ident`数组中的第4至第15个索引）被符号化地称为`EI_CLASS`、`EI_DATA`、`EI_VERSION`、`EI_OSABI`、`EI_ABIVERSION`和`EI_PAD`，分别对应。图2-1（[Figure
    2-1](ch02.xhtml#ch02fig1)）展示了它们的视觉表示。
- en: The `EI_PAD` field actually contains multiple bytes, namely, indexes 9 through
    15 in `e_ident`. All of these bytes are currently designated as padding; they
    are reserved for possible future use but currently set to zero.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: '`EI_PAD`字段实际上包含多个字节，即`e_ident`中的第9至第15个索引位置。所有这些字节目前都被指定为填充字节；它们保留供将来可能使用，但目前都设置为零。'
- en: The `EI_CLASS` byte denotes what the ELF specification refers to as the binary’s
    “class.” This is a bit of a misnomer since the word *class* is so generic, it
    could mean almost anything. What the byte really denotes is whether the binary
    is for a 32-bit or 64-bit architecture. In the former case, the `EI_CLASS` byte
    is set to the constant `ELFCLASS32` (which is equal to 1), while in the latter
    case, it’s set to `ELFCLASS64` (equal to 2).
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: '`EI_CLASS`字节表示ELF规范所称的二进制文件的“类别”。这个词其实是个误称，因为“类别”这个词太过泛化，几乎可以表示任何东西。这个字节实际表示的是二进制文件是针对32位架构还是64位架构的。在前一种情况下，`EI_CLASS`字节设置为常量`ELFCLASS32`（值为1），而在后一种情况下，设置为`ELFCLASS64`（值为2）。'
- en: Related to the architecture’s bit width is the *endianness* of the architecture.
    In other words, are multibyte values (such as integers) ordered in memory with
    the least significant byte first (*little-endian*) or the most significant byte
    first (*big-endian*)? The `EI_DATA` byte indicates the endianness of the binary.
    A value of `ELFDATA2LSB` (equal to 1) indicates little-endian, while `ELFDATA2MSB`
    (equal to 2) means big-endian.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 与架构的位宽相关的是架构的*字节序*。换句话说，多字节值（如整数）在内存中的存储顺序是先存储最低有效字节（*小端字节序*）还是先存储最高有效字节（*大端字节序*）？`EI_DATA`字节指示二进制文件的字节序。`ELFDATA2LSB`（值为1）表示小端字节序，而`ELFDATA2MSB`（值为2）表示大端字节序。
- en: The next byte, called `EI_VERSION`, indicates the version of the ELF specification
    used when creating the binary. Currently, the only valid value is `EV_CURRENT`,
    which is defined to be equal to 1.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个字节叫做`EI_VERSION`，它表示在创建二进制文件时使用的ELF规范的版本。目前，唯一有效的值是`EV_CURRENT`，其定义等于1。
- en: Finally, the `EI_OSABI` and `EI_ABIVERSION` bytes denote information regarding
    the application binary interface (ABI) and operating system (OS) for which the
    binary was compiled. If the `EI_OSABI` byte is set to nonzero, it means that some
    ABI- or OS-specific extensions are used in the ELF file; this can change the meaning
    of some other fields in the binary or can signal the presence of nonstandard sections.
    The default value of zero indicates that the binary targets the UNIX System V
    ABI. The `EI_ABIVERSION` byte denotes the specific version of the ABI indicated
    in the `EI_OSABI` byte that the binary targets. You’ll usually see this set to
    zero because it’s not necessary to specify any version information when the default
    `EI_OSABI` is used.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，`EI_OSABI`和`EI_ABIVERSION`字节表示与应用程序二进制接口（ABI）和操作系统（OS）相关的信息，这些信息用于标识二进制文件的编译环境。如果`EI_OSABI`字节被设置为非零值，表示ELF文件中使用了某些特定于ABI或操作系统的扩展；这可能会改变二进制文件中其他字段的含义，或指示存在非标准部分。零值表示二进制文件是针对UNIX系统V
    ABI编译的。`EI_ABIVERSION`字节表示二进制文件目标所使用的`EI_OSABI`字节所指示的ABI的具体版本。通常你会看到它被设置为零，因为当使用默认的`EI_OSABI`时，不需要指定版本信息。
- en: You can inspect the `e_ident` array of any ELF binary by using `readelf` to
    view the binary’s header. For instance, [Listing 2-2](ch02.xhtml#ch02list2) shows
    the output for the `compilation_example` binary from [Chapter 1](ch01.xhtml#ch01)
    (I’ll also refer to this output when discussing the other fields in the executable
    header).
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过使用`readelf`查看二进制文件的头部，检查任何ELF二进制文件的`e_ident`数组。例如，[列表2-2](ch02.xhtml#ch02list2)显示了[第1章](ch01.xhtml#ch01)中的`compilation_example`二进制文件的输出（在讨论可执行头部的其他字段时，我还会引用此输出）。
- en: '*Listing 2-2: Executable header as shown by* readelf'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表2-2：由* readelf 显示的可执行头部'
- en: '[PRE1]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: In [Listing 2-2](ch02.xhtml#ch02list2), the `e_ident` array is shown on the
    line marked `Magic` ➊. It starts with the familiar four magic bytes, followed
    by a value of 2 (indicating `ELFCLASS64`), then a 1 (`ELFDATA2LSB`), and finally
    another 1 (`EV_CURRENT`). The remaining bytes are all zeroed out since the `EI_OSABI`
    and `EI_ABIVERSION` bytes are at their default values; the padding bytes are all
    set to zero as well. The information contained in some of the bytes is explicitly
    repeated on dedicated lines, marked `Class`, `Data`, `Version`, `OS/ABI`, and
    `ABI Version`, respectively ➋.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 在[列表2-2](ch02.xhtml#ch02list2)中，`e_ident`数组显示在标记为`Magic`的行上 ➊。它以熟悉的四个魔术字节开始，接着是一个值2（表示`ELFCLASS64`），然后是1（`ELFDATA2LSB`），最后是另一个1（`EV_CURRENT`）。其余字节均为零，因为`EI_OSABI`和`EI_ABIVERSION`字节保持其默认值；填充字节也都设置为零。某些字节中包含的信息在专门的行中被显式地重复，分别标记为`Class`、`Data`、`Version`、`OS/ABI`和`ABI
    Version` ➋。
- en: '*2.1.2 The e_type, e_machine, and e_version Fields*'
  id: totrans-25
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '*2.1.2 e_type, e_machine 和 e_version 字段*'
- en: 'After the `e_ident` array comes a series of multibyte integer fields. The first
    of these, called `e_type`, specifies the type of the binary. The most common values
    you’ll encounter here are `ET_REL` (indicating a relocatable object file), `ET_EXEC`
    (an executable binary), and `ET_DYN` (a dynamic library, also called a shared
    object file). In the `readelf` output for the example binary, you can see you’re
    dealing with an executable file (`Type: EXEC` ➌ in [Listing 2-2](ch02.xhtml#ch02list2)).'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: '在`e_ident`数组之后，紧跟着一系列多字节整数字段。其中第一个字段是`e_type`，它指定了二进制文件的类型。你最常见的值包括`ET_REL`（表示可重定位目标文件）、`ET_EXEC`（可执行二进制文件）和`ET_DYN`（动态库，也称为共享目标文件）。在示例二进制文件的`readelf`输出中，你可以看到这是一个可执行文件（在[列表2-2](ch02.xhtml#ch02list2)中的`Type:
    EXEC` ➌）。'
- en: Next comes the `e_machine` field, which denotes the architecture that the binary
    is intended to run on ➍. For this book, this will usually be set to `EM_X86_64`
    (as it is in the `readelf` output) since you will mostly be working on 64-bit
    x86 binaries. Other values you’re likely to encounter include `EM_386` (32-bit
    x86) and `EM_ARM` (for ARM binaries).
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来是`e_machine`字段，它表示二进制文件的目标架构 ➍。在本书中，通常会将其设置为`EM_X86_64`（正如`readelf`输出中所示），因为你主要将处理64位x86二进制文件。你可能遇到的其他值包括`EM_386`（32位x86）和`EM_ARM`（用于ARM二进制文件）。
- en: The `e_version` field serves the same role as the `EI_VERSION` byte in the `e_ident`
    array; specifically, it indicates the version of the ELF specification that was
    used when creating the binary. As this field is 32 bits wide, you might think
    there are numerous possible values, but in reality, the only possible value is
    1 (`EV_CURRENT`) to indicate version 1 of the specification ➎.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: '`e_version`字段的作用与`e_ident`数组中的`EI_VERSION`字节相同；具体来说，它指示创建二进制文件时使用的ELF规范版本。由于该字段是32位宽的，你可能会认为有许多可能的值，但实际上，唯一的可能值是1（`EV_CURRENT`），表示该规范的版本为1
    ➎。'
- en: '*2.1.3 The e_entry Field*'
  id: totrans-29
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '*2.1.3 e_entry 字段*'
- en: The `e_entry` field denotes the *entry point* of the binary; this is the virtual
    address at which execution should start (see also [Section 1.4](ch01.xhtml#ch01_4)).
    For the example binary, execution starts at address `0x400430` (marked ➏ in the
    `readelf` output in [Listing 2-2](ch02.xhtml#ch02list2)). This is where the interpreter
    (typically *ld-linux.so*) will transfer control after it finishes loading the
    binary into virtual memory. The entry point is also a useful starting point for
    recursive disassembly, as I’ll discuss in [Chapter 6](ch06.xhtml#ch06).
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: '`e_entry`字段表示二进制文件的*入口点*；这是执行开始的虚拟地址（详见[第1.4节](ch01.xhtml#ch01_4)）。对于示例二进制文件，执行从地址`0x400430`开始（在[列表2-2](ch02.xhtml#ch02list2)中的`readelf`输出中标记为
    ➏）。这是解释器（通常是*ld-linux.so*）在加载二进制文件到虚拟内存后将控制权转交的地方。入口点也是递归反汇编的有用起点，正如我在[第6章](ch06.xhtml#ch06)中将要讨论的。'
- en: '*2.1.4 The e_phoff and e_shoff Fields*'
  id: totrans-31
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '*2.1.4 e_phoff 和 e_shoff 字段*'
- en: As shown in [Figure 2-1](ch02.xhtml#ch02fig1), ELF binaries contain tables of
    program headers and section headers, among other things. I’ll revisit the meaning
    of these header types after I finish discussing the executable header, but one
    thing I can already reveal is that the program header and section header tables
    need not be located at any particular offset in the binary file. The only data
    structure that can be assumed to be at a fixed location in an ELF binary is the
    executable header, which is always at the beginning.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 如 [图 2-1](ch02.xhtml#ch02fig1) 所示，ELF 二进制文件包含程序头表和节头表等数据结构。等我完成对可执行文件头的讨论后，我会重新讲解这些头部类型的含义，不过我现在可以透露的一点是，程序头表和节头表不需要位于二进制文件中的特定偏移量位置。唯一可以假定始终位于
    ELF 二进制文件中固定位置的数据结构是可执行文件头，它始终位于文件的开头。
- en: How can you know where to find the program headers and section headers? For
    this, the executable header contains two dedicated fields, called `e_phoff` and
    `e_shoff`, that indicate the file offsets to the beginning of the program header
    table and the section header table. For the example binary, the offsets are 64
    and 6632 bytes, respectively (the two lines at ➐ in [Listing 2-2](ch02.xhtml#ch02list2)).
    The offsets can also be set to zero to indicate that the file does not contain
    a program header or section header table. It’s important to note here that these
    fields are *file offsets*, meaning the number of bytes you should read into the
    file to get to the headers. In other words, in contrast to the `e_entry` field
    discussed earlier, `e_phoff` and `e_shoff` are *not* virtual addresses.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 如何知道程序头和节头的位置？为此，可执行文件头包含两个专门的字段，分别为 `e_phoff` 和 `e_shoff`，它们指示程序头表和节头表的文件偏移量。对于示例二进制文件，偏移量分别为
    64 字节和 6632 字节（见 [清单 2-2](ch02.xhtml#ch02list2) 中的 ➐ 两行）。这些偏移量也可以设置为零，表示文件中不包含程序头或节头表。需要特别注意的是，这些字段是
    *文件偏移量*，即表示需要读取多少字节才能到达头部。换句话说，与之前讨论的 `e_entry` 字段不同，`e_phoff` 和 `e_shoff` 不是
    *虚拟地址*。
- en: '*2.1.5 The e_flags Field*'
  id: totrans-34
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '*2.1.5 e_flags 字段*'
- en: The `e_flags` field provides room for flags specific to the architecture for
    which the binary is compiled. For instance, ARM binaries intended to run on embedded
    platforms can set ARM-specific flags in the `e_flags` field to indicate additional
    details about the interface they expect from the embedded operating system (file
    format conventions, stack organization, and so on). For x86 binaries, `e_flags`
    is typically set to zero and thus not of interest.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: '`e_flags` 字段为特定架构的标志提供空间，这些标志与二进制文件所编译的架构相关。例如，旨在嵌入式平台上运行的 ARM 二进制文件可以在 `e_flags`
    字段中设置 ARM 特定的标志，以指示它们期望嵌入式操作系统提供的接口的额外细节（如文件格式约定、栈组织等）。对于 x86 二进制文件，`e_flags`
    通常设置为零，因此不予关注。'
- en: '*2.1.6 The e_ehsize Field*'
  id: totrans-36
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '*2.1.6 e_ehsize 字段*'
- en: The `e_ehsize` field specifies the size of the executable header, in bytes.
    For 64-bit x86 binaries, the executable header size is always 64 bytes, as you
    can see in the `readelf` output, while it’s 52 bytes for 32-bit x86 binaries (see
    ➑ in [Listing 2-2](ch02.xhtml#ch02list2)).
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: '`e_ehsize` 字段指定可执行文件头的大小（以字节为单位）。对于 64 位 x86 二进制文件，可执行文件头的大小始终为 64 字节，正如你在
    `readelf` 输出中看到的那样，而对于 32 位 x86 二进制文件，其大小为 52 字节（见 [清单 2-2](ch02.xhtml#ch02list2)
    中的 ➑）。'
- en: '*2.1.7 The e_*entsize and e_*num Fields*'
  id: totrans-38
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '*2.1.7 e_*entsize 和 e_*num 字段*'
- en: As you now know, the `e_phoff` and `e_shoff` fields point to the file offsets
    where the program header and section header tables begin. But for the linker or
    loader (or another program handling an ELF binary) to actually traverse these
    tables, additional information is needed. Specifically, they need to know the
    size of the individual program or section headers in the tables, as well as the
    number of headers in each table. This information is provided by the `e_phentsize`
    and `e_phnum` fields for the program header table and by the `e_shentsize` and
    `e_shnum` fields for the section header table. In the example binary in [Listing
    2-2](ch02.xhtml#ch02list2), there are nine program headers of 56 bytes each, and
    there are 31 section headers of 64 bytes each ➒.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所知，`e_phoff` 和 `e_shoff` 字段指向程序头和节头表开始的文件偏移量。但是，为了让链接器、加载器（或其他处理 ELF 二进制文件的程序）能够实际遍历这些表格，仍然需要额外的信息。具体来说，它们需要知道每个程序头或节头在表格中的大小，以及每个表格中的头部数量。这些信息由
    `e_phentsize` 和 `e_phnum` 字段提供，用于程序头表；由 `e_shentsize` 和 `e_shnum` 字段提供，用于节头表。在
    [清单 2-2](ch02.xhtml#ch02list2) 中的示例二进制文件中，共有 9 个程序头，每个头大小为 56 字节，且有 31 个节头，每个节头大小为
    64 字节 ➒。
- en: '*2.1.8 The e_shstrndx Field*'
  id: totrans-40
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '*2.1.8 e_shstrndx 字段*'
- en: The `e_shstrndx` field contains the index (in the section header table) of the
    header associated with a special *string table* section, called `.shstrtab`. This
    is a dedicated section that contains a table of null-terminated ASCII strings,
    which store the names of all the sections in the binary. It is used by ELF processing
    tools such as `readelf` to correctly show the names of sections. I’ll describe
    `.shstrtab` (and other sections) later in this chapter.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: '`e_shstrndx` 字段包含与一个特殊 *字符串表* 节（名为 `.shstrtab`）相关联的头部在节头表中的索引。这个节是一个专用节，包含一个以空字符结尾的
    ASCII 字符串表，存储着二进制文件中所有节的名称。ELF 处理工具（如 `readelf`）会使用这个节来正确显示节的名称。我将在本章稍后介绍 `.shstrtab`（以及其他节）。'
- en: In the example binary in [Listing 2-2](ch02.xhtml#ch02list2), the section header
    for `.shstrtab` has index 28 ➓. You can view the contents of the `.shstrtab` section
    (as a hexadecimal dump) using `readelf`, as shown in [Listing 2-3](ch02.xhtml#ch02list3).
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [Listing 2-2](ch02.xhtml#ch02list2) 中的示例二进制文件中，`.shstrtab` 的节头索引为 28 ➓。你可以使用
    `readelf` 查看 `.shstrtab` 节的内容（以十六进制转储的形式），如 [Listing 2-3](ch02.xhtml#ch02list3)
    所示。
- en: '*Listing 2-3: The* .shstrtab *section as shown by* readelf'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: '*Listing 2-3：* `readelf` 显示的 *`.shstrtab`* 节'
- en: '[PRE2]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: You can see the section names (such as `.symtab`, `.strtab`, and so on) contained
    in the string table at the right side of [Listing 2-3](ch02.xhtml#ch02list3) ➊.
    Now that you’re familiar with the format and contents of the ELF executable header,
    let’s move on to the section headers.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在 [Listing 2-3](ch02.xhtml#ch02list3) ➊ 的右侧看到字符串表中包含的节名称（如 `.symtab`、`.strtab`
    等）。现在你已经熟悉了 ELF 可执行文件头部的格式和内容，接下来让我们继续讨论节头。
- en: 2.2 Section Headers
  id: totrans-46
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.2 节头
- en: The code and data in an ELF binary are logically divided into contiguous nonoverlapping
    chunks called *sections*. Sections don’t have any predetermined structure; instead,
    the structure of each section varies depending on the contents. In fact, a section
    may not even have any particular structure at all; often a section is nothing
    more than an unstructured blob of code or data. Every section is described by
    a *section header*, which denotes the properties of the section and allows you
    to locate the bytes belonging to the section. The section headers for all sections
    in the binary are contained in the *section header table*.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: ELF 二进制文件中的代码和数据逻辑上被划分为连续的、不重叠的块，称为 *节*。节没有预定的结构；每个节的结构根据其内容不同而不同。实际上，一个节甚至可能没有任何特定的结构；许多时候，节不过是一个没有结构的代码或数据块。每个节都有一个
    *节头*，它描述了节的属性并允许你定位属于该节的字节。二进制文件中所有节的节头都包含在 *节头表* 中。
- en: Strictly speaking, the division into sections is intended to provide a convenient
    organization for use by the linker (of course, sections can also be parsed by
    other tools, such as static binary analysis tools). This means that not every
    section is actually needed when setting up a process and virtual memory to execute
    the binary. Some sections contain data that isn’t needed for execution at all,
    such as symbolic or relocation information.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 严格来说，节的划分旨在为链接器提供方便的组织方式（当然，节也可以被其他工具解析，比如静态二进制分析工具）。这意味着，并非每个节在设置进程和虚拟内存以执行二进制文件时都是必须的。有些节包含的数据根本不需要执行，例如符号信息或重定位信息。
- en: Because sections are intended to provide a view for the linker only, the section
    header table is an optional part of the ELF format. ELF files that don’t need
    linking aren’t required to have a section header table. If no section header table
    is present, the `e_shoff` field in the executable header is set to zero.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 由于节的目的仅仅是为链接器提供视图，因此节头表是 ELF 格式的一个可选部分。那些不需要链接的 ELF 文件不必包含节头表。如果没有节头表，执行文件头中的
    `e_shoff` 字段将被设置为零。
- en: To load and execute a binary in a process, you need a different organization
    of the code and data in the binary. For this reason, ELF executables specify another
    logical organization, called *segments*, which are used at execution time (as
    opposed to sections, which are used at link time). I’ll cover segments later in
    this chapter when I talk about program headers. For now, let’s focus on sections,
    but keep in mind that the logical organization I discuss here exists only at link
    time (or when used by a static analysis tool) and not at runtime.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 为了加载和执行二进制文件到一个进程中，二进制文件的代码和数据需要以不同的方式组织。因此，ELF可执行文件指定了另一种逻辑组织方式，称为*段*，它们在执行时使用（与在链接时使用的节不同）。稍后我会在本章中讨论程序头时覆盖段的内容。现在，让我们聚焦于节，但请记住，我在这里讨论的逻辑组织仅在链接时（或当静态分析工具使用时）存在，而不是在运行时。
- en: Let’s begin by discussing the format of the section headers. After that, we’ll
    take a look at the contents of the sections. [Listing 2-4](ch02.xhtml#ch02list4)
    shows the format of an ELF section header as specified in */usr/include/elf.h*.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从讨论节头的格式开始。之后，我们将查看节的内容。[清单2-4](ch02.xhtml#ch02list4)展示了按*/usr/include/elf.h*中规定的格式定义的ELF节头。
- en: '*Listing 2-4: Definition of* Elf64_Shdr *in* /usr/include/elf.h'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单2-4：在*/usr/include/elf.h*中定义的Elf64_Shdr*'
- en: '[PRE3]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '*2.2.1 The sh_name Field*'
  id: totrans-54
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '*2.2.1 sh_name字段*'
- en: As you can see in [Listing 2-4](ch02.xhtml#ch02list4), the first field in a
    section header is called `sh_name`. If set, it contains an index into the *string
    table*. If the index is zero, it means the section doesn’t have a name.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 如[清单2-4](ch02.xhtml#ch02list4)所示，节头的第一个字段被称为`sh_name`。如果设置了，它包含指向*字符串表*的索引。如果索引为零，则表示该节没有名称。
- en: In [Section 2.1](ch02.xhtml#ch02_1), I discussed a special section called `.shstrtab`,
    which contains an array of `NULL`-terminated strings, one for every section name.
    The index of the section header describing the string table is given in the `e_shstrndx`
    field of the executable header. This allows tools like `readelf` to easily find
    the `.shstrtab` section and then index it with the `sh_name` field of every section
    header (including the header of `.shstrtab`) to find the string describing the
    name of the section in question. This allows a human analyst to easily identify
    the purpose of each section.^([2](footnote.xhtml#ch02fn_2))
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第2.1节](ch02.xhtml#ch02_1)中，我讨论了一个名为`.shstrtab`的特殊节，它包含一个以`NULL`终止的字符串数组，每个节名称都有一个字符串。描述字符串表的节头索引存储在可执行文件头的`e_shstrndx`字段中。这使得像`readelf`这样的工具能够轻松找到`.shstrtab`节，并通过每个节头的`sh_name`字段（包括`.shstrtab`的头）索引它，以找到描述该节名称的字符串。这使得人工分析人员能够轻松识别每个节的用途。^([2](footnote.xhtml#ch02fn_2))
- en: '*2.2.2 The sh_type Field*'
  id: totrans-57
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '*2.2.2 sh_type字段*'
- en: Every section has a type, indicated by an integer field called `sh_type`, that
    tells the linker something about the structure of a section’s contents. [Figure
    2-1](ch02.xhtml#ch02fig1) shows the most important section types for our purposes.
    I’ll discuss each of the important section types in turn.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 每个节都有一个类型，通过一个名为`sh_type`的整数字段来表示，该字段告诉链接器有关节内容结构的信息。[图2-1](ch02.xhtml#ch02fig1)展示了我们目的下最重要的节类型。我将逐一讨论每种重要的节类型。
- en: Sections with type `SHT_PROGBITS` contain program data, such as machine instructions
    or constants. These sections have no particular structure for the linker to parse.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 类型为`SHT_PROGBITS`的节包含程序数据，例如机器指令或常量。这些节没有特定的结构供链接器解析。
- en: There are also special section types for symbol tables (`SHT_SYMTAB` for static
    symbol tables and `SHT_DYNSYM` for symbol tables used by the dynamic linker) and
    string tables (`SHT_STRTAB`). Symbol tables contain symbols in a well-defined
    format (`struct Elf64_Sym` in *elf.h* if you’re interested), which describes the
    symbolic name and type for particular file offsets or addresses,among other things.
    The static symbol table may not be present if the binary is stripped, for example.
    String tables, as discussed, simply contain an array of `NULL`-terminated strings,
    with the first byte in the string table set to `NULL` by convention.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一些特殊的节类型用于符号表（`SHT_SYMTAB`表示静态符号表，`SHT_DYNSYM`表示动态链接器使用的符号表）和字符串表（`SHT_STRTAB`）。符号表以一种定义明确的格式（如果你有兴趣的话，可以查看*elf.h*中的`struct
    Elf64_Sym`）存储符号，其中描述了特定文件偏移量或地址的符号名称和类型等信息。如果二进制文件被剥离，静态符号表可能不存在。字符串表，如前所述，仅包含一个以`NULL`终止的字符串数组，字符串表的第一个字节按照约定设置为`NULL`。
- en: Sections with type `SHT_REL` or `SHT_RELA` are particularly important for the
    linker because they contain relocation entries in a well-defined format (`struct
    Elf64_Rel` and `struct Elf64_Rela` in *elf.h*), which the linker can parse to
    perform the necessary relocations in other sections. Each relocation entry tells
    the linker about a particular location in the binary where a relocation is needed
    and which symbol the relocation should be resolved to. The actual relocation process
    is quite involved, and I won’t go into the details right now. The important takeaway
    is that the `SHT_REL` and `SHT_RELA` sections are used for static linking purposes.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 类型为 `SHT_REL` 或 `SHT_RELA` 的节对于链接器特别重要，因为它们包含了按照明确格式（在 *elf.h* 中的 `struct Elf64_Rel`
    和 `struct Elf64_Rela`）定义的重定位条目，链接器可以解析这些条目来执行其他节中的必要重定位。每个重定位条目都告诉链接器在二进制文件中某个位置需要进行重定位，以及应该解析到哪个符号。实际的重定位过程相当复杂，我现在不打算深入讨论。重要的结论是，`SHT_REL`
    和 `SHT_RELA` 节用于静态链接。
- en: Sections of type `SHT_DYNAMIC` contain information needed for dynamic linking.
    This information is formatted using `struct Elf64_Dyn` as specified in *elf.h*.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 类型为 `SHT_DYNAMIC` 的节包含了动态链接所需的信息。该信息的格式使用 `struct Elf64_Dyn`，如 *elf.h* 中所指定。
- en: '*2.2.3 The sh_flags Field*'
  id: totrans-63
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '*2.2.3 sh_flags 字段*'
- en: Section flags (specified in the `sh_flags` field) describe additional information
    about a section. The most important flags for the purposes here are `SHF_WRITE`,
    `SHF_ALLOC`, and `SHF_EXECINSTR`.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 节标志（在 `sh_flags` 字段中指定）描述了节的附加信息。这里最重要的标志是 `SHF_WRITE`、`SHF_ALLOC` 和 `SHF_EXECINSTR`。
- en: '`SHF_WRITE` indicates that the section is writable at runtime. This makes it
    easy to distinguish between sections that contain static data (such as constants)
    and those that contain variables. The `SHF_ALLOC` flag indicates that the contents
    of the section are to be loaded into virtual memory when executing the binary
    (though the actual loading happens using the segment view of the binary, not the
    section view). Finally, `SHF_EXECINSTR` tells you that the section contains executable
    instructions, which is useful to know when disassembling a binary.'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: '`SHF_WRITE` 表示该节在运行时是可写的。这使得我们可以很容易地区分包含静态数据（如常量）和包含变量的节。`SHF_ALLOC` 标志表示该节的内容在执行二进制文件时会被加载到虚拟内存中（尽管实际加载是通过二进制文件的段视图进行的，而不是节视图）。最后，`SHF_EXECINSTR`
    告诉你该节包含可执行指令，这在反汇编二进制文件时非常有用。'
- en: '*2.2.4 The sh_addr, sh_offset, and sh_size Fields*'
  id: totrans-66
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '*2.2.4 sh_addr、sh_offset 和 sh_size 字段*'
- en: The `sh_addr`, `sh_offset`, and `sh_size` fields describe the virtual address,
    file offset (in bytes from the start of the file), and size (in bytes) of the
    section, respectively. At first glance, a field describing the virtual address
    of a section, like `sh_addr`, may seem out of place here; after all, I said that
    sections are used only for linking, not for creating and executing a process.
    While this is still true, the linker sometimes needs to know at which addresses
    particular pieces of code and data will end up at runtime to do relocations. The
    `sh_addr` field provides this information. Sections that aren’t intended to be
    loaded into virtual memory when setting up the process have an `sh_addr` value
    of zero.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: '`sh_addr`、`sh_offset` 和 `sh_size` 字段分别描述了节的虚拟地址、文件偏移量（从文件开始算起的字节数）和节的大小（以字节为单位）。乍一看，像
    `sh_addr` 这样描述节虚拟地址的字段可能显得不合适；毕竟，我曾说过节只用于链接，而不是用于创建和执行进程。尽管这仍然成立，但链接器有时需要知道特定的代码和数据在运行时会位于哪些地址，以便进行重定位。`sh_addr`
    字段提供了这些信息。那些在进程设置时不打算加载到虚拟内存中的节，其 `sh_addr` 值为零。'
- en: '*2.2.5 The sh_link Field*'
  id: totrans-68
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '*2.2.5 sh_link 字段*'
- en: Sometimes there are relationships between sections that the linker needs to
    know about. For instance, an `SHT_SYMTAB`, `SHT_DYNSYM`, or `SHT_DYNAMIC` has
    an associated string table section, which contains the symbolic names for the
    symbols in question. Similarly, relocation sections (type `SHT_REL` or `SHT_RELA`)
    are associated with a symbol table describing the symbols involved in the relocations.
    The `sh_link` field makes these relationships explicit by denoting the index (in
    the section header table) of the related section.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 有时候，节与节之间存在一些链接器需要知道的关系。例如，`SHT_SYMTAB`、`SHT_DYNSYM` 或 `SHT_DYNAMIC` 都有一个关联的字符串表节，里面包含了相关符号的符号名称。类似地，重定位节（类型为
    `SHT_REL` 或 `SHT_RELA`）与一个符号表相关联，该符号表描述了重定位中涉及的符号。`sh_link` 字段通过表示相关节在节头表中的索引，明确了这些关系。
- en: '*2.2.6 The sh_info Field*'
  id: totrans-70
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '*2.2.6 sh_info 字段*'
- en: The `sh_info` field contains additional information about the section. The meaning
    of the additional information varies depending on the section type. For instance,
    for relocation sections, `sh_info` denotes the index of the section to which the
    relocations are to be applied.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: '`sh_info` 字段包含有关段的附加信息。附加信息的含义取决于段的类型。例如，对于重定位段，`sh_info` 表示将要应用重定位的段的索引。'
- en: '*2.2.7 The sh_addralign Field*'
  id: totrans-72
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '*2.2.7 sh_addralign 字段*'
- en: Some sections may need to be aligned in memory in a particular way for efficiency
    of memory accesses. For example, a section may need to be loaded at some address
    that is a multiple of 8 bytes or 16 bytes. These alignment requirements are specified
    in the `sh_addralign` field. For instance, if this field is set to 16, it means
    the base address of the section (as chosen by the linker) must be some multiple
    of 16\. The values 0 and 1 are reserved to indicate no special alignment needs.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 某些段可能需要以特定方式在内存中对齐，以提高内存访问效率。例如，一个段可能需要加载到某个地址，这个地址是 8 字节或 16 字节的倍数。这些对齐要求在
    `sh_addralign` 字段中指定。例如，如果该字段设置为 16，则表示该段的基地址（由链接器选择）必须是 16 的倍数。值 0 和 1 被保留，表示没有特殊的对齐需求。
- en: '*2.2.8 The sh_entsize Field*'
  id: totrans-74
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '*2.2.8 sh_entsize 字段*'
- en: Some sections, such as symbol tables or relocation tables, contain a table of
    well-defined data structures (such as `Elf64_Sym` or `Elf64_Rela`). For such sections,
    the `sh_entsize` field indicates the size in bytes of each entry in the table.
    When the field is unused, it is set to zero.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 一些段，例如符号表或重定位表，包含一组定义明确的数据结构（例如 `Elf64_Sym` 或 `Elf64_Rela`）。对于这些段，`sh_entsize`
    字段表示表中每个条目的字节大小。当该字段未使用时，它的值为零。
- en: 2.3 Sections
  id: totrans-76
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.3 段
- en: Now that you are familiar with the structure of a section header, let’s look
    at some specific sections found in an ELF binary. Typical ELF files that you’ll
    find on a GNU/Linux system are organized into a series of standard (or de facto
    standard) sections. [Listing 2-5](ch02.xhtml#ch02list5) shows the `readelf` output
    with the sections in the example binary.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经熟悉了段头的结构，接下来让我们看看 ELF 二进制文件中一些具体的段。你在 GNU/Linux 系统上找到的典型 ELF 文件是按一系列标准（或事实上的标准）段组织的。[列表
    2-5](ch02.xhtml#ch02list5) 显示了使用 `readelf` 命令查看示例二进制文件的输出，其中列出了段。
- en: '*Listing 2-5: A listing of sections in the example binary*'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 2-5：示例二进制文件中的段列表*'
- en: '[PRE4]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: For each section, `readelf` shows the relevant basic information, including
    the index (in the section header table), name, and type of the section. Moreover,
    you can also see the virtual address, file offset, and size in bytes of the section.
    For sections containing a table (such as symbol tables and relocation tables),
    there’s also a column showing the size of each table entry. Finally, `readelf`
    also shows the relevant flags for each section, as well as the index of the linked
    section (if any), additional information (specific to the section type), and alignment
    requirements.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 对于每个段，`readelf` 显示相关的基本信息，包括索引（在段头表中）、段的名称和类型。此外，你还可以看到段的虚拟地址、文件偏移量和字节大小。对于包含表的段（例如符号表和重定位表），还有一列显示每个表条目的大小。最后，`readelf`
    还显示每个段的相关标志，以及链接的段的索引（如果有的话）、附加信息（特定于段类型）和对齐要求。
- en: As you can see, the output conforms closely to the structure of a section header.
    The first entry in the section header table of every ELF file is defined by the
    ELF standard to be a `NULL` entry. The type of the entry is `SHT_NULL` ➊, and
    all fields in the section header are zeroed out. This means it has no name and
    no associated bytes (in other words, it is a section header without an actual
    section). Let’s now delve a bit deeper into the contents and purpose of the most
    interesting remaining sections that you’re likely to see in your binary analysis
    endeavors.^([3](footnote.xhtml#ch02fn_3))
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，输出内容与段头的结构非常接近。每个 ELF 文件的段头表中的第一个条目是由 ELF 标准定义的 `NULL` 条目。该条目的类型为 `SHT_NULL`
    ➊，且段头的所有字段都被清零。这意味着该段没有名称且没有关联的字节（换句话说，它是一个没有实际段的段头）。接下来，让我们深入了解你在二进制分析过程中可能会遇到的其他一些最有趣的段的内容和目的。^([3](footnote.xhtml#ch02fn_3))
- en: '*2.3.1 The .init and .fini Sections*'
  id: totrans-82
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '*2.3.1 .init 和 .fini 段*'
- en: The `.init` section (index 11 in [Listing 2-5](ch02.xhtml#ch02list5)) contains
    executable code that performs initialization tasks and needs to run before any
    other code in the binary is executed. You can tell that it contains executable
    code by the `SHF_EXECINSTR` flag, denoted as an `X` by `readelf` (in the `Flg`
    column) ➋. The system executes the code in the `.init` section before transferring
    control to the main entry point of the binary. Thus, if you’re familiar with object-oriented
    programming, you can think of this section as a constructor. The `.fini` section
    (index 15) is analogous to the `.init` section, except that it runs after the
    main program completes, essentially functioning as a kind of destructor.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: '`.init` 段（在 [清单 2-5](ch02.xhtml#ch02list5) 中的索引 11）包含执行初始化任务的可执行代码，且需要在二进制文件中的其他代码执行之前运行。你可以通过
    `readelf` 中的 `SHF_EXECINSTR` 标志（在 `Flg` 列中以 `X` 表示） ➋ 知道它包含可执行代码。系统在将控制权转交给二进制文件的主入口点之前，会先执行
    `.init` 段中的代码。因此，如果你熟悉面向对象编程，可以将此段视为构造函数。`.fini` 段（索引 15）与 `.init` 段类似，只是它在主程序完成后执行，基本上充当了一种析构函数的角色。'
- en: '*2.3.2 The .text Section*'
  id: totrans-84
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '*2.3.2 .text 段*'
- en: The `.text` section (index 14) is where the main code of the program resides,
    so it will frequently be the main focus of your binary analysis or reverse engineering
    efforts. As you can see in the `readelf` output in [Listing 2-5](ch02.xhtml#ch02list5),
    the `.text` section has type `SHT_PROGBITS` ➌ because it contains user-defined
    code. Also note the section flags, which indicate that the section is executable
    but not writable ➍. In general, executable sections should almost never be writable
    (and vice versa) because that would make it easy for an attacker exploiting a
    vulnerability to modify the behavior of the program by directly overwriting the
    code.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: '`.text` 段（索引 14）是程序主代码所在的地方，因此它将经常成为你进行二进制分析或逆向工程时的主要关注点。如你在 [清单 2-5](ch02.xhtml#ch02list5)
    中的 `readelf` 输出所见，`.text` 段的类型是 `SHT_PROGBITS` ➌，因为它包含用户定义的代码。还要注意该段的标志，表示该段是可执行的但不可写的
    ➍。一般来说，可执行的段几乎不应是可写的（反之亦然），因为这将使得攻击者通过利用漏洞直接覆盖代码来修改程序行为变得容易。'
- en: Besides the application-specific code compiled from the program’s source, the
    `.text` section of a typical binary compiled by `gcc` contains a number of standard
    functions that perform initialization and finalization tasks, such as `_start`,
    `register_tm_clones`, and `frame_dummy`. For now, the `_start` function is the
    most important of these standard functions for you. [Listing 2-6](ch02.xhtml#ch02list6)
    shows why (don’t worry about understanding all of the assembly code in the listing;
    I’ll point out the important parts next).
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 除了从程序源代码编译而来的特定应用程序代码之外，使用 `gcc` 编译的典型二进制文件的 `.text` 段包含了许多执行初始化和清理任务的标准函数，如
    `_start`、`register_tm_clones` 和 `frame_dummy`。目前，`_start` 函数是这些标准函数中对你最为重要的一个。[清单
    2-6](ch02.xhtml#ch02list6) 展示了原因（不必担心理解清单中的所有汇编代码；接下来我会指出重要部分）。
- en: '*Listing 2-6: Disassembly of the standard* _start *function*'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 2-6：标准* _start *函数的反汇编*'
- en: '[PRE5]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: When you write a C program, there’s always a `main` function where your program
    begins. But if you inspect the entry point of the binary, you’ll find that it
    *doesn’t* point to `main` at address `0x400526` ➍. Instead, it points to address
    `0x400430`, the beginning of `_start` ➊.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 当你编写 C 程序时，总会有一个 `main` 函数，这是程序开始的地方。但如果你检查二进制文件的入口点，你会发现它*并不是*指向地址 `0x400526`
    处的 `main` ➍。相反，它指向地址 `0x400430`，即 `_start` 的起始位置 ➊。
- en: So, how does execution eventually reach `main`? If you look closely, you can
    see that `_start` contains an instruction at address `0x40044d` that moves the
    address of `main` into the `rdi` register ➋, which is one of the registers used
    to pass parameters for function calls on the x64 platform. Then, `_start` calls
    a function called `__libc_start_main` ➌. It resides in the `.plt` section, which
    means the function is part of a shared library (I’ll cover this in more detail
    in [Section 2.3.4](ch02.xhtml#ch02_3_4)).
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，程序执行是如何最终到达 `main` 的呢？仔细观察，你会发现 `_start` 在地址 `0x40044d` 处有一条指令，将 `main` 的地址移动到
    `rdi` 寄存器 ➋，这是 x64 平台上用于传递函数调用参数的寄存器之一。接着，`_start` 调用一个名为 `__libc_start_main`
    的函数 ➌。这个函数位于 `.plt` 段，意味着它是共享库的一部分（我将在[2.3.4节](ch02.xhtml#ch02_3_4)中详细介绍这个内容）。
- en: As its name implies, `__libc_start_main` finally calls to the address of `main`
    to begin execution of the user-defined code.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 正如其名称所示，`__libc_start_main` 最终会调用 `main` 的地址，以开始执行用户定义的代码。
- en: '*2.3.3 The .bss, .data, and .rodata Sections*'
  id: totrans-92
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '*2.3.3 .bss、.data 和 .rodata 段*'
- en: Because code sections are generally not writable, variables are kept in one
    or more dedicated sections, which are writable. Constant data is usually also
    kept in its own section to keep the binary neatly organized, though compilers
    *do* sometimes output constant data in code sections. (Modern versions of `gcc`
    and `clang` generally don’t mix code and data, but Visual Studio sometimes does.)
    As you’ll see in [Chapter 6](ch06.xhtml#ch06), this can make disassembly considerably
    more difficult because it’s not always clear which bytes represent instructions
    and which represent data.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 由于代码节通常是不可写的，变量通常被保存在一个或多个专用的可写节中。常量数据通常也会保存在单独的节中，以便保持二进制文件的整洁，尽管编译器*确实*有时会将常量数据输出到代码节中。（现代版本的`gcc`和`clang`通常不会混合代码和数据，但Visual
    Studio有时会这样做。）正如你在[第6章](ch06.xhtml#ch06)中将看到的，这会使得反汇编变得更加困难，因为并不总是能清楚区分哪些字节是指令，哪些是数据。
- en: The `.rodata` section, which stands for “read-only data,” is dedicated to storing
    constant values. Because it stores constant values, `.rodata` is not writable.
    The default values of initialized variables are stored in the `.data` section,
    which *is* marked as writable since the values of variables may change at runtime.
    Finally, the `.bss` section reserves space for uninitialized variables. The name
    historically stands for “block started by symbol,” referring to the reserving
    of blocks of memory for (symbolic) variables.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: '`.rodata`节（即“只读数据”）用于存储常量值。由于它存储的是常量值，`.rodata`是不可写的。已初始化变量的默认值存储在`.data`节中，`.data`节*是*可写的，因为变量的值可能会在运行时改变。最后，`.bss`节为未初始化变量保留空间。该名称历史上代表“由符号启动的块”，指的是为（符号）变量保留内存块。'
- en: Unlike `.rodata` and `.data`, which have type `SHT_PROGBITS`, the `.bss` section
    has type `SHT_NOBITS`. This is because `.bss` doesn’t occupy any bytes in the
    binary as it exists on disk—it’s simply a directive to allocate a properly sized
    block of memory for uninitialized variables when setting up an execution environment
    for the binary. Typically, variables that live in `.bss` are zero initialized,
    and the section is marked as writable.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 与`.rodata`和`.data`（类型为`SHT_PROGBITS`）不同，`.bss`节的类型是`SHT_NOBITS`。这是因为`.bss`在二进制文件中不占用任何字节，它仅仅是一个指令，用于在为二进制文件设置执行环境时为未初始化的变量分配合适大小的内存块。通常，位于`.bss`中的变量会被初始化为零，并且该节被标记为可写。
- en: '*2.3.4 Lazy Binding and the .plt, .got, and .got.plt Sections*'
  id: totrans-96
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '*2.3.4 延迟绑定与 .plt、.got 和 .got.plt 节*'
- en: In [Chapter 1](ch01.xhtml#ch01), we discussed that when a binary is loaded into
    a process for execution, the dynamic linker performs last-minute relocations.
    For instance, it resolves references to functions located in shared libraries,
    where the load address is not yet known at compile time. I also briefly mentioned
    that, in reality, many of the relocations are typically not done right away when
    the binary is loaded but are deferred until the first reference to the unresolved
    location is actually made. This is known as *lazy binding*.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第1章](ch01.xhtml#ch01)中，我们讨论了当二进制文件被加载到进程中执行时，动态链接器会进行最后的重定位。例如，它会解析对位于共享库中的函数的引用，而共享库的加载地址在编译时尚未知道。我还简要提到，实际上，许多重定位通常不会在二进制文件加载时立即执行，而是会推迟到首次引用未解析位置时才执行。这被称为*延迟绑定*。
- en: '**Lazy Binding and the PLT**'
  id: totrans-98
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**延迟绑定与PLT**'
- en: Lazy binding ensures that the dynamic linker never needlessly wastes time on
    relocations; it only performs those relocations that are truly needed at runtime.
    On Linux, lazy binding is the default behavior of the dynamic linker. It’s possible
    to force the linker to perform all relocations right away by exporting an environment
    variable called `LD_BIND_NOW`,^([4](footnote.xhtml#ch02fn_4)) but this is usually
    not done unless the application calls for real-time performance guarantees.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 延迟绑定确保动态链接器不会在不必要的时候浪费时间进行重定位，它只会在运行时真正需要时才执行这些重定位。在Linux中，延迟绑定是动态链接器的默认行为。你可以通过导出名为`LD_BIND_NOW`的环境变量强制链接器立即执行所有重定位^([4](footnote.xhtml#ch02fn_4))，但通常只有在应用程序要求实时性能保证时才会这样做。
- en: Lazy binding in Linux ELF binaries is implemented with the help of two special
    sections, called the *Procedure Linkage Table* (`.plt`) and the *Global Offset
    Table* (`.got`). Though the following discussion focuses on lazy binding, the
    GOT is actually used for more than just that. ELF binaries often contain a separate
    GOT section called `.got.plt` for use in conjunction with `.plt` in the lazy binding
    process. The `.got.plt` section is analogous to the regular `.got`, and for your
    purposes here, you can consider them to be the same (in fact, historically, they
    were).^([5](footnote.xhtml#ch02fn_5)) [Figure 2-2](ch02.xhtml#ch02fig2) illustrates
    the lazy binding process and the role of the PLT and GOT.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: Linux ELF 二进制文件中的懒绑定是通过两个特殊段来实现的，分别是*过程连接表*（` .plt`）和*全局偏移表*（` .got`）。尽管以下讨论主要集中在懒绑定上，GOT
    实际上用于的不仅仅是懒绑定。ELF 二进制文件通常包含一个单独的 GOT 段，称为`.got.plt`，用于与`.plt`一起在懒绑定过程中使用。`.got.plt`段与常规的`.got`段类似，你可以认为它们是一样的（实际上，它们在历史上是一样的）。^([5](footnote.xhtml#ch02fn_5))
    [图 2-2](ch02.xhtml#ch02fig2)展示了懒绑定过程及 PLT 和 GOT 的作用。
- en: '![image](Images/f046-01.jpg)'
  id: totrans-101
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/f046-01.jpg)'
- en: '*Figure 2-2: Calling a shared library function via the PLT*'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 2-2：通过 PLT 调用共享库函数*'
- en: As the figure and the `readelf` output in [Listing 2-5](ch02.xhtml#ch02list5)
    show, `.plt` is a code section that contains executable code, just like `.text`,
    while `.got.plt` is a data section.^([6](footnote.xhtml#ch02fn_6)) The PLT consists
    entirely of stubs of a well-defined format, dedicated to directing calls from
    the `.text` section to the appropriate library location. To explore the format
    of the PLT, let’s look at a disassembly of the `.plt` section from the example
    binary, as shown in [Listing 2-7](ch02.xhtml#ch02list7). (The instruction opcodes
    have been omitted for brevity.)
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 正如图示和[列表 2-5](ch02.xhtml#ch02list5)中`readelf`的输出所示，`.plt`是一个包含可执行代码的代码段，就像`.text`一样，而`.got.plt`是一个数据段。^([6](footnote.xhtml#ch02fn_6))
    PLT 完全由格式明确的存根构成，专门用于将来自`.text`段的调用指令导向适当的库位置。为了探讨 PLT 的格式，我们来看一下示例二进制文件中`.plt`段的反汇编，如[列表
    2-7](ch02.xhtml#ch02list7)所示。（为简洁起见，指令操作码已省略。）
- en: '*Listing 2-7: Disassembly of a* .plt *section*'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 2-7：* .plt *节的反汇编*'
- en: '[PRE6]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The format of the PLT is as follows: First, there is a default stub ➊, which
    I’ll talk about in a second. After that comes a series of function stubs ➋➍, one
    per library function, all following the same pattern. Also note that for each
    consecutive function stub, the value pushed onto the stack is incremented ➌➎.
    This value is an identifier, the use of which I’ll cover shortly. Now let’s explore
    how PLT stubs like those shown in [Listing 2-7](ch02.xhtml#ch02list7) allow you
    to call a shared library function, as illustrated in [Figure 2-2](ch02.xhtml#ch02fig2),
    and how this aids the lazy binding process.'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: PLT 的格式如下：首先是一个默认的存根 ➊，稍后我会讲解。接下来是一系列函数存根 ➋➍，每个库函数一个，所有存根遵循相同的模式。还要注意，对于每个连续的函数存根，压入栈中的值会递增
    ➌➎。这个值是一个标识符，稍后我会解释它的作用。现在让我们探讨一下如[列表 2-7](ch02.xhtml#ch02list7)所示的 PLT 存根是如何让你调用共享库函数的，如[图
    2-2](ch02.xhtml#ch02fig2)所示，并且这如何有助于懒绑定过程。
- en: Dynamically Resolving a Library Function Using the PLT
  id: totrans-107
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用 PLT 动态解析库函数
- en: Let’s say you want to call the `puts` function, which is part of the well-known
    `libc` library. Instead of calling it directly (which isn’t possible for the aforementioned
    reasons), you can make a call to the corresponding PLT stub, `puts@plt` (step
    ➊ in [Figure 2-2](ch02.xhtml#ch02fig2)).
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你想要调用`puts`函数，它是著名的`libc`库的一部分。你不能直接调用它（由于上述原因，这是不可能的），但是你可以调用对应的 PLT 存根`puts@plt`（如[图
    2-2](ch02.xhtml#ch02fig2)中的步骤 ➊）。
- en: The PLT stub begins with an indirect jump instruction, which jumps to an address
    stored in the `.got.plt` section (step ➋ in [Figure 2-2](ch02.xhtml#ch02fig2)).
    Initially, before the lazy binding has happened, this address is simply the address
    of the next instruction in the function stub, which is a `push` instruction. Thus,
    the indirect jump simply transfers control to the instruction directly after it
    (step ➌ in [Figure 2-2](ch02.xhtml#ch02fig2))! That’s a rather roundabout way
    of getting to the next instruction, but there’s a good reason for doing it this
    way, as you’ll now see.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: PLT 存根以一条间接跳转指令开始，该指令跳转到存储在`.got.plt`段中的地址（如[图 2-2](ch02.xhtml#ch02fig2)中的步骤
    ➋）。最初，在懒绑定发生之前，这个地址只是函数存根中下一条指令的地址，这是一条`push`指令。因此，间接跳转只是将控制权转移到它后面的指令（如[图 2-2](ch02.xhtml#ch02fig2)中的步骤
    ➌）！这是一种相当间接的方式来跳转到下一条指令，但这样做是有充分理由的，接下来你会看到为什么。
- en: The `push` instruction pushes an integer (in this case, `0x0`) onto the stack.
    As mentioned, this integer serves as an identifier for the PLT stub in question.
    Subsequently, the next instruction jumps to the common default stub shared among
    all PLT function stubs (step ➍ in [Figure 2-2](ch02.xhtml#ch02fig2)). The default
    stub pushes another identifier (taken from the GOT), identifying the executable
    itself, and then jumps (indirectly, again through the GOT) to the dynamic linker
    (step ➎ in [Figure 2-2](ch02.xhtml#ch02fig2)).
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: '`push`指令将一个整数（在此情况下为`0x0`）压入栈中。如前所述，这个整数作为对应PLT存根的标识符。接下来，下一条指令跳转到所有PLT函数存根共享的公共默认存根（图2-2中的步骤➍）。默认存根推送另一个标识符（来自GOT），标识可执行文件本身，然后跳转（再次通过GOT间接跳转）到动态链接器（图2-2中的步骤➎）。'
- en: Using the identifiers pushed by the PLT stubs, the dynamic linker figures out
    that it should resolve the address of `puts` and should do so on behalf of the
    main executable loaded into the process. This last bit is important because there
    may be multiple libraries loaded in the same process as well, each with their
    own PLT and GOT. The dynamic linker then looks up the address at which the `puts`
    function is located and plugs the address of that function into the GOT entry
    associated with `puts@plt`. Thus, the GOT entry no longer points back into the
    PLT stub, as it did initially, but now points to the actual address of `puts`.
    At this point, the lazy binding process is complete.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 利用PLT存根推送的标识符，动态链接器可以确定它应该解析`puts`的地址，并且应该代表加载到进程中的主可执行文件进行此操作。最后这一点很重要，因为同一个进程中可能还加载了多个库，每个库都有自己的PLT和GOT。动态链接器接着查找`puts`函数所在的地址，并将该函数的地址插入到与`puts@plt`相关联的GOT条目中。于是，GOT条目不再像最初那样指向PLT存根，而是现在指向`puts`的实际地址。此时，延迟绑定过程完成。
- en: Finally, the dynamic linker satisfies the original intention of calling `puts`
    by transferring control to it. For any subsequent calls to `puts@plt`, the GOT
    entry already contains the appropriate (patched) address of `puts` so that the
    jump at the start of the PLT stub goes directly to `puts` without involving the
    dynamic linker (step ➏ in the figure).
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 最终，动态链接器通过将控制转移到`puts`来满足调用`puts`的最初目的。对于任何后续调用`puts@plt`，GOT条目已经包含了`puts`的适当（修补过的）地址，使得PLT存根开始时的跳转直接到`puts`，而无需涉及动态链接器（图中的步骤➏）。
- en: Why Use a GOT?
  id: totrans-113
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 为什么使用GOT？
- en: At this point, you may wonder why the GOT is needed at all. For example, wouldn’t
    it be simpler to just patch the resolved library address directly into the code
    of the PLT stubs? One of the main reasons things don’t work that way essentially
    boils down to security. If there’s a vulnerability in the binary somewhere (which,
    for any nontrivial binary, there surely is), it would be all too easy for an attacker
    to modify the code of the binary if executable sections like `.text` and `.plt`
    were writable. But because the GOT is a data section and it’s okay for it to be
    writable, it makes sense to have the additional layer of indirection through the
    GOT. In other words, this extra layer of indirection allows you to avoid creating
    writable code sections. While an attacker may still succeed in changing the addresses
    in the GOT, this attack model is a lot less powerful than the ability to inject
    arbitrary code.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一点上，你可能会想，为什么需要GOT呢？例如，直接将解析后的库地址直接修补到PLT存根的代码中不是更简单吗？事情不能那样做的主要原因归结为安全性。如果二进制文件的某个地方存在漏洞（对于任何非平凡的二进制文件，肯定会有），攻击者就可以轻松修改二进制文件的代码，如果像`.text`和`.plt`这样的可执行部分是可写的。但由于GOT是数据段，并且它是允许被写入的，因此通过GOT进行额外的间接访问是合理的。换句话说，这一额外的间接层使得你能够避免创建可写的代码段。虽然攻击者仍可能成功修改GOT中的地址，但这种攻击模式远不如能够注入任意代码那样强大。
- en: The other reason has to do with code shareability in shared libraries. As discussed,
    modern operating systems save (physical) memory by sharing the code of libraries
    among all processes using them. That way, instead of having to load a separate
    copy of every library for each process using it, the operating system has to load
    only a single copy of each library. However, even though there is only a single
    *physical* copy of each library, the same library will likely be mapped to a completely
    different *virtual* address for each process. The implication is that you can’t
    patch addresses resolved on behalf of a library directly into the code because
    the address would work only in the context of one process and break the others.
    Patching them into the GOT instead does work because each process has its own
    private copy of the GOT.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个原因与共享库中的代码共享性有关。如前所述，现代操作系统通过在所有使用共享库的进程之间共享库的代码来节省（物理）内存。这样，操作系统只需加载每个库的单一副本，而不是每个使用该库的进程都加载一份独立副本。然而，尽管每个库只有一个*物理*副本，但同一库可能会为每个进程映射到完全不同的*虚拟*地址。这意味着，不能将为库解析的地址直接打补丁到代码中，因为该地址只在某一个进程的上下文中有效，其他进程则无法使用。相反，将它们打补丁到
    GOT 中是可行的，因为每个进程都有自己的私有 GOT 副本。
- en: 'As you may have already guessed, references from the code to relocatable data
    symbols (such as variables and constants exported from shared libraries) also
    need to be redirected via the GOT to avoid patching data addresses directly into
    the code. The difference is that data references go directly through the GOT,
    without the intermediate step of the PLT. This also clarifies the distinction
    between the `.got` and `.got.plt` sections: `.got` is for references to data items,
    while `.got.plt` is dedicated to storing resolved addresses for library functions
    accessed via the PLT.'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你可能已经猜到的，代码对可重定位数据符号（如从共享库导出的变量和常量）的引用也需要通过 GOT 进行重定向，以避免将数据地址直接打补丁到代码中。不同之处在于，数据引用直接通过
    GOT，而没有经过 PLT 的中间步骤。这也澄清了 `.got` 和 `.got.plt` 段之间的区别：`.got` 用于数据项的引用，而 `.got.plt`
    专门用于存储通过 PLT 访问的库函数的解析地址。
- en: '*2.3.5 The .rel.* and .rela.* Sections*'
  id: totrans-117
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '*2.3.5 .rel.* 和 .rela.* 段*'
- en: As you can see in the `readelf` dump of the example binary’s section headers,
    there are several sections with names of the form `rela.*`. These sections are
    of type `SHT_RELA`, meaning that they contain information used by the linker for
    performing relocations. Essentially, each section of type `SHT_RELA` is a table
    of relocation entries, with each entry detailing a particular address where a
    relocation needs to be applied, as well as instructions on how to resolve the
    particular value that needs to be plugged in at this address. [Listing 2-8](ch02.xhtml#ch02list8)
    shows the contents of the relocation sections in the example binary. As you’ll
    see, only the dynamic relocations (to be performed by the dynamic linker) remain,
    as all the static relocations that existed in the object file have already been
    resolved during static linking. In any real-world binary (as opposed to this simple
    example), there would of course be many more dynamic relocations.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 如你在示例二进制文件的 `readelf` 转储中看到的节头所示，有几个段的名称为 `rela.*`。这些段的类型是 `SHT_RELA`，意味着它们包含了链接器用于执行重定位的信息。本质上，所有
    `SHT_RELA` 类型的段都是一个重定位项表，每个项都详细描述了一个需要应用重定位的特定地址，以及如何解析该地址需要插入的特定值。[清单 2-8](ch02.xhtml#ch02list8)
    显示了示例二进制文件中重定位段的内容。如你所见，只有动态重定位（由动态链接器执行）仍然存在，因为所有在目标文件中存在的静态重定位已经在静态链接时被解决了。在任何实际的二进制文件中（与这个简单的示例不同），当然会有更多的动态重定位。
- en: '*Listing 2-8: The relocation sections in the example binary*'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 2-8：示例二进制文件中的重定位段*'
- en: '[PRE7]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: There are two types of relocations here, called `R_X86_64_GLOB_DAT` and `R_X86_64_JUMP_SLO`.
    While you may encounter many more types in the wild, these are some of the most
    common and important ones. What all relocation types have in common is that they
    specify an offset at which to apply the relocation. The details of how to compute
    the value to plug in at that offset differ per relocation type and are sometimes
    rather involved. You can find all these specifics in the ELF specification, though
    for normal binary analysis tasks you don’t need to know them.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有两种类型的重定位，分别叫做`R_X86_64_GLOB_DAT`和`R_X86_64_JUMP_SLO`。虽然在实际使用中你可能会遇到更多的类型，但这些是最常见和最重要的几种。所有重定位类型的共同点是它们指定了一个偏移量，用于应用重定位。如何计算在该偏移量插入的值在不同的重定位类型中有所不同，有时甚至相当复杂。你可以在ELF规范中找到所有这些细节，然而对于普通的二进制分析任务，你不需要了解它们。
- en: The first relocation shown in [Listing 2-8](ch02.xhtml#ch02list8), of type `R_X86_64_GLOB_DAT`,
    has its offset in the `.got` section ➊, as you can tell by comparing the offset
    to the `.got` base address shown in the `readelf` output in [Listing 2-5](ch02.xhtml#ch02list5).
    Generally, this type of relocation is used to compute the address of a data symbol
    and plug it into the correct offset in `.got`.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 在[Listing 2-8](ch02.xhtml#ch02list8)中显示的第一个重定位，类型为`R_X86_64_GLOB_DAT`，其偏移量位于`.got`节中➊，你可以通过将偏移量与`readelf`输出中显示的`.got`基地址进行比较来判断。通常，这种类型的重定位用于计算数据符号的地址，并将其插入`.got`中的正确偏移位置。
- en: 'The `R_X86_64_JUMP_SLO` entries are called *jump slots*➋➌; they have their
    offset in the `.got.plt` section and represent slots where the addresses of library
    functions can be plugged in. If you look back at the dump of the PLT of the example
    binary in [Listing 2-7](ch02.xhtml#ch02list7), you can see that each of these
    slots is used by one of the PLT stubs to retrieve its indirect jump target. The
    addresses of the jump slots (computed from the relative offset to the `rip` register)
    appear on the right side of the output in [Listing 2-7](ch02.xhtml#ch02list7),
    just after the # symbol.'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: '`R_X86_64_JUMP_SLO`条目被称为*跳转槽*➋➌；它们的偏移量位于`.got.plt`节中，表示可以插入库函数地址的槽。如果你回顾一下在[Listing
    2-7](ch02.xhtml#ch02list7)中示例二进制的PLT转储，你会发现每个跳转槽都被PLT存根用于获取其间接跳转目标。跳转槽的地址（通过相对偏移计算得到`rip`寄存器的地址）出现在[Listing
    2-7](ch02.xhtml#ch02list7)输出的右侧，紧跟在#符号之后。'
- en: '*2.3.6 The .dynamic Section*'
  id: totrans-124
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '*2.3.6 .dynamic节*'
- en: The `.dynamic` section functions as a “road map” for the operating system and
    dynamic linker when loading and setting up an ELF binary for execution. If you’ve
    forgotten how the loading process works, you may want to refer to [Section 1.4](ch01.xhtml#ch01_4).
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: '`.dynamic`节充当操作系统和动态链接器在加载和设置ELF二进制文件执行时的“路线图”。如果你忘记了加载过程是如何工作的，可能需要参考[Section
    1.4](ch01.xhtml#ch01_4)。'
- en: The `.dynamic` section contains a table of `Elf64_Dyn` structures (as specified
    in */usr/include/elf.h*), also referred to as *tags*. There are different types
    of tags, each of which comes with an associated value. As an example, let’s take
    a look at the contents of `.dynamic` in the example binary, shown in [Listing
    2-9](ch02.xhtml#ch02list9).
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: '`.dynamic`节包含一个`Elf64_Dyn`结构体的表（如*/usr/include/elf.h*中所指定），也称为*标签*。这些标签有不同的类型，每个类型都有一个相关的值。举个例子，来看一下示例二进制中`.dynamic`的内容，如[Listing
    2-9](ch02.xhtml#ch02list9)所示。'
- en: '*Listing 2-9: Contents of the* .dynamic *section*'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: '*Listing 2-9：.dynamic节的内容*'
- en: '[PRE8]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: As you can see, the type of each tag in the `.dynamic` section is shown in the
    second output column. Tags of type `DT_NEEDED` inform the dynamic linker about
    dependencies of the executable. For instance, the binary uses the `puts` function
    from the *libc.so.6* shared library ➊, so it needs to be loaded when executing
    the binary. The `DT_VERNEED` ➋ and `DT_VERNEEDNUM` ➌ tags specify the starting
    address and number of entries of the *version dependency table*, which indicates
    the expected version of the various dependencies of the executable.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，`.dynamic`节中每个标签的类型显示在第二列输出中。`DT_NEEDED`类型的标签告知动态链接器可执行文件的依赖关系。例如，二进制文件使用来自*libc.so.6*共享库的`puts`函数➊，因此在执行二进制文件时需要加载它。`DT_VERNEED`➋和`DT_VERNEEDNUM`➌标签指定了*版本依赖表*的起始地址和条目数，该表表示可执行文件各个依赖项的预期版本。
- en: In addition to listing dependencies, the `.dynamic` section also contains pointers
    to other important information required by the dynamic linker (for instance, the
    dynamic string table, dynamic symbol table, `.got.plt` section, and dynamic relocation
    section pointed to by tags of type `DT_STRTAB`, `DT_SYMTAB`, `DT_PLTGOT`, and
    `DT_RELA`, respectively).
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 除了列出依赖关系之外，`.dynamic` 节还包含指向动态链接器所需的其他重要信息的指针（例如，动态字符串表、动态符号表、`.got.plt` 节，以及通过
    `DT_STRTAB`、`DT_SYMTAB`、`DT_PLTGOT` 和 `DT_RELA` 类型标签指向的动态重定位节）。
- en: '*2.3.7 The .init_array and .fini_array Sections*'
  id: totrans-131
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '*2.3.7 .init_array 和 .fini_array 节*'
- en: The `.init_array` section contains an array of pointers to functions to use
    as constructors. Each of these functions is called in turn when the binary is
    initialized, before `main` is called. While the aforementioned `.init` section
    contains a single startup function that performs some crucial initialization needed
    to start the executable, `.init_array` is a data section that can contain as many
    function pointers as you want, including pointers to your own custom constructors.
    In `gcc`, you can mark functions in your C source files as constructors by decorating
    them with `__attribute__((constructor))`.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: '`.init_array` 节包含一个指向函数的指针数组，用作构造函数。当二进制文件被初始化时，这些函数会依次被调用，在调用 `main` 之前。前面提到的
    `.init` 节包含一个启动函数，该函数执行一些启动可执行文件所需的关键初始化，而 `.init_array` 是一个数据节，可以包含任意数量的函数指针，包括指向你自定义构造函数的指针。在
    `gcc` 中，你可以通过 `__attribute__((constructor))` 修饰符将 C 源文件中的函数标记为构造函数。'
- en: In the example binary, `.init_array` contains only a single entry. It’s a pointer
    to another default initialization function, called `frame_dummy`, as you can see
    in the `objdump` output shown in [Listing 2-10](ch02.xhtml#ch02list10).
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 在示例二进制文件中，`.init_array` 只包含一个条目。它是指向另一个默认初始化函数的指针，名为 `frame_dummy`，如 [Listing
    2-10](ch02.xhtml#ch02list10) 中的 `objdump` 输出所示。
- en: '*Listing 2-10: Contents of the* .init_array *section*'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: '*Listing 2-10: .init_array 节的内容*'
- en: '[PRE9]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The first `objdump` invocation shows the contents of `.init_array` ➊. As you
    can see, there’s a single function pointer (shaded in the output) that contains
    the bytes `00 05 40 00 00 00 00 00` ➋. This is just little-endian-speak for the
    address `0x400500` (obtained by reversing the byte order and stripping off the
    leading zeros). The second call to `objdump` shows that this is indeed the starting
    address of the `frame_dummy` function ➌.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 第一次调用 `objdump` 显示了 `.init_array` 的内容 ➊。正如你所见，输出中有一个单一的函数指针（以阴影显示），其中包含字节 `00
    05 40 00 00 00 00 00` ➋。这实际上是小端表示的地址 `0x400500`（通过反转字节顺序并去掉前导零得到）。第二次调用 `objdump`
    显示，这确实是 `frame_dummy` 函数的起始地址 ➌。
- en: As you may have guessed by now, `.fini_array` is analogous to `.init_array`,
    except that `.fini_array` contains pointers to destructors rather than constructors.
    The pointers contained in `.init_array` and `.fini_array` are easy to change,
    making them convenient places to insert hooks that add initialization or finalization
    code to the binary to modify its behavior. Note that binaries produced by older
    `gcc` versions may contain sections called `.ctors` and `.dtors` instead of `.init_array`
    and `.fini_array`.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你现在可能已经猜到的，`.fini_array` 类似于 `.init_array`，只是 `.fini_array` 包含的是析构函数的指针，而不是构造函数的指针。`.init_array`
    和 `.fini_array` 中包含的指针是容易修改的，这使得它们成为插入钩子（例如添加初始化或清理代码来修改二进制行为）的方便位置。需要注意的是，旧版本的
    `gcc` 生成的二进制文件可能包含 `.ctors` 和 `.dtors` 节，而不是 `.init_array` 和 `.fini_array`。
- en: '*2.3.8 The .shstrtab, .symtab, .strtab, .dynsym, and .dynstr Sections*'
  id: totrans-138
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '*2.3.8 .shstrtab, .symtab, .strtab, .dynsym 和 .dynstr 节*'
- en: As mentioned during the discussion of section headers, the `.shstrtab` section
    is simply an array of `NULL`-terminated strings that contain the names of all
    the sections in the binary. It’s indexed by the section headers to allow tools
    like `readelf` to find out the names of the sections.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 正如在讨论节头时提到的，`.shstrtab` 节只是一个包含二进制文件中所有节名称的以 `NULL` 结尾的字符串数组。它通过节头进行索引，使得像 `readelf`
    这样的工具能够找出节的名称。
- en: The `.symtab` section contains a symbol table, which is a table of `Elf64_Sym`
    structures, each of which associates a symbolic name with a piece of code or data
    elsewhere in the binary, such as a function or variable. The actual strings containing
    the symbolic names are located in the `.strtab` section. These strings are pointed
    to by the `Elf64_Sym` structures. In practice, the binaries you’ll encounter during
    binary analysis will often be stripped, which means that the `.symtab` and `.strtab`
    tables are removed.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: '`.symtab` 节包含一个符号表，这是一个 `Elf64_Sym` 结构的表，每个结构将一个符号名称与二进制文件中其他地方的代码或数据（如函数或变量）关联起来。实际包含符号名称的字符串位于
    `.strtab` 节。这些字符串由 `Elf64_Sym` 结构指向。在实际操作中，您在二进制分析过程中遇到的二进制文件通常已经被剥离，这意味着 `.symtab`
    和 `.strtab` 表会被移除。'
- en: The `.dynsym` and `.dynstr` sections are analogous to `.symtab` and `.strtab`,
    except that they contain symbols and strings needed for dynamic linking rather
    than static linking. Because the information in these sections is needed during
    dynamic linking, they cannot be stripped.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: '`.dynsym` 和 `.dynstr` 部分类似于 `.symtab` 和 `.strtab`，不同之处在于它们包含的是动态链接所需的符号和字符串，而不是静态链接所需的。由于这些信息在动态链接过程中是必需的，因此它们不能被剥离。'
- en: Note that the static symbol table has section type `SHT_SYMTAB`, while the dynamic
    symbol table has type `SHT_DYNSYM`. This makes it easy for tools like `strip`
    to recognize which symbol tables can be safely removed when stripping a binary
    and which cannot.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，静态符号表的节类型是 `SHT_SYMTAB`，而动态符号表的节类型是 `SHT_DYNSYM`。这使得像 `strip` 这样的工具能够轻松识别哪些符号表可以在剥离二进制文件时安全移除，哪些不能。
- en: 2.4 Program Headers
  id: totrans-143
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.4 程序头
- en: The *program header table* provides a *segment view* of the binary, as opposed
    to the *section view* provided by the section header table. The section view of
    an ELF binary, which I discussed earlier, is meant for static linking purposes
    only. In contrast, the segment view, which I’ll discuss next, is used by the operating
    system and dynamic linker when loading an ELF into a process for execution to
    locate the relevant code and data and decide what to load into virtual memory.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: '*程序头表* 提供了二进制文件的 *段视图*，与节头表提供的 *节视图* 相对。ELF 二进制文件的节视图，我之前已经讨论过，仅用于静态链接。而接下来我将讨论的段视图，则在操作系统和动态链接器加载
    ELF 文件到进程中执行时使用，用于定位相关的代码和数据并决定将哪些内容加载到虚拟内存中。'
- en: An ELF segment encompasses zero or more sections, essentially bundling these
    into a single chunk. Since segments provide an execution view, they are needed
    only for executable ELF files and not for nonexecutable files such as relocatable
    objects. The program header table encodes the segment view using program headers
    of type `struct Elf64_Phdr`. Each program header contains the fields shown in
    [Listing 2-11](ch02.xhtml#ch02list11).
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 一个 ELF 段包含零个或多个节，本质上将这些节捆绑成一个单独的块。由于段提供了执行视图，因此它们仅在可执行 ELF 文件中需要，而对于不可执行文件（如可重定位对象文件）则不需要。程序头表使用
    `struct Elf64_Phdr` 类型的程序头来编码段视图。每个程序头包含[列表 2-11](ch02.xhtml#ch02list11)中所示的字段。
- en: '*Listing 2-11: Definition of* Elf64_Phdr *in* /usr/include/elf.h'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 2-11：* `/usr/include/elf.h` 中 *Elf64_Phdr 的定义*'
- en: '[PRE10]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: I’ll describe each of these fields in the next few sections. [Listing 2-12](ch02.xhtml#ch02list12)
    shows the program header table for the example binary, as displayed by `readelf`.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 我将在接下来的几个部分中描述这些字段。[列表 2-12](ch02.xhtml#ch02list12) 显示了通过 `readelf` 展示的示例二进制文件的程序头表。
- en: '*Listing 2-12: A typical program header as shown by* readelf'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 2-12：通过* readelf *显示的典型程序头*'
- en: '[PRE11]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Note the section-to-segment mapping at the bottom of the `readelf` output, which
    clearly illustrates that segments are simply a bunch of sections bundled together
    ➊. This specific section-to-segment mapping is typical for most ELF binaries you’ll
    encounter. In the rest of this section, I’ll discuss the program header fields
    shown in [Listing 2-11](ch02.xhtml#ch02list11).
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意 `readelf` 输出底部的节到段映射，它清楚地说明了段实际上只是将多个节捆绑在一起➊。这种特定的节到段映射是大多数 ELF 二进制文件的典型特征。在本节的其余部分，我将讨论[列表
    2-11](ch02.xhtml#ch02list11)中所示的程序头字段。
- en: '*2.4.1 The p_type Field*'
  id: totrans-152
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '*2.4.1 p_type 字段*'
- en: The `p_type` field identifies the type of the segment. Important values for
    this field include `PT_LOAD`, `PT_DYNAMIC`, and `PT_INTERP`.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: '`p_type` 字段标识段的类型。该字段的重要值包括 `PT_LOAD`、`PT_DYNAMIC` 和 `PT_INTERP`。'
- en: Segments of type `PT_LOAD`, as the name implies, are intended to be loaded into
    memory when setting up the process. The size of the loadable chunk and the address
    to load it at are described in the rest of the program header. As you can see
    in the `readelf` output, there are usually at least two `PT_LOAD` segments—one
    encompassing the nonwritable sections and one containing the writable data sections.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: '`PT_LOAD`类型的段，顾名思义，在设置进程时应该加载到内存中。可加载块的大小和加载地址在其余的程序头中描述。正如你在`readelf`输出中看到的，通常至少有两个`PT_LOAD`段——一个包含不可写的部分，另一个包含可写的数据部分。'
- en: The `PT_INTERP` segment contains the `.interp` section, which provides the name
    of the interpreter that is to be used to load the binary. In turn, the `PT_DYNAMIC`
    segment contains the `.dynamic` section, which tells the interpreter how to parse
    and prepare the binary for execution. It’s also worth mentioning the `PT_PHDR`
    segment, which encompasses the program header table.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: '`PT_INTERP`段包含`.interp`部分，该部分提供了用于加载二进制文件的解释器名称。相应地，`PT_DYNAMIC`段包含`.dynamic`部分，告诉解释器如何解析并准备二进制文件以供执行。还值得一提的是`PT_PHDR`段，它包含程序头表。'
- en: '*2.4.2 The p_flags Field*'
  id: totrans-156
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '*2.4.2 p_flags字段*'
- en: 'The flags specify the runtime access permissions for the segment. Three important
    types of flags exist: `PF_X`, `PF_W`, and `PF_R`. The `PF_X` flag indicates that
    the segment is executable and is set for code segments (`readelf` displays it
    as an `E` rather than an `X` in the `Flg` column in [Listing 2-12](ch02.xhtml#ch02list12)).
    The `PF_W` flag means that the segment is writable, and it is normally set only
    for writable data segments, never for code segments. Finally, `PF_R` means that
    the segment is readable, as is normally the case for both code and data segments.'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 标志指定段的运行时访问权限。共有三种重要的标志：`PF_X`、`PF_W`和`PF_R`。`PF_X`标志表示该段是可执行的，通常设置在代码段上（`readelf`在[Listing
    2-12](ch02.xhtml#ch02list12)中的`Flg`列会将其显示为`E`，而非`X`）。`PF_W`标志意味着该段是可写的，通常仅在可写数据段上设置，代码段不会设置此标志。最后，`PF_R`意味着该段是可读的，这通常适用于代码段和数据段。
- en: '*2.4.3 The p_offset, p_vaddr, p_paddr, p_filesz, and p_memsz Fields*'
  id: totrans-158
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '*2.4.3 p_offset、p_vaddr、p_paddr、p_filesz和p_memsz字段*'
- en: The `p_offset`, `p_vaddr`, and `p_filesz` fields in [Listing 2-11](ch02.xhtml#ch02list11)
    are analogous to the `sh_offset`, `sh_addr`, and `sh_size` fields in a section
    header. They specify the file offset at which the segment starts, the virtual
    address at which it is to be loaded, and the file size of the segment, respectively.
    For loadable segments, `p_vaddr` must be equal to `p_offset`, modulo the page
    size (which is typically 4,096 bytes).
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 在[Listing 2-11](ch02.xhtml#ch02list11)中，`p_offset`、`p_vaddr`和`p_filesz`字段类似于节头中的`sh_offset`、`sh_addr`和`sh_size`字段。它们分别指定段开始的文件偏移量、加载到的虚拟地址以及段的文件大小。对于可加载段，`p_vaddr`必须等于`p_offset`，其值模页面大小（通常为4,096字节）。
- en: On some systems, it’s possible to use the `p_paddr` field to specify at which
    address in physical memory to load the segment. On modern operating systems such
    as Linux, this field is unused and set to zero since they execute all binaries
    in virtual memory.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些系统中，可以使用`p_paddr`字段指定段在物理内存中的加载地址。在现代操作系统（如Linux）中，此字段未使用，且值为零，因为它们将所有二进制文件加载到虚拟内存中执行。
- en: At first glance, it may not be obvious why there are distinct fields for the
    file size of the segment (`p_filesz`) and the size in memory (`p_memsz`). To understand
    this, recall that some sections only indicate the need to allocate some bytes
    in memory but don’t actually occupy these bytes in the binary file. For instance,
    the `.bss` section contains zero-initialized data. Since all data in this section
    is known to be zero anyway, there’s no need to actually include all these zeros
    in the binary. However, when loading the segment containing `.bss` into virtual
    memory, all the bytes in `.bss` *should* be allocated. Thus, it’s possible for
    `p_memsz` to be larger than `p_filesz`. When this happens, the loader adds the
    extra bytes at the end of the segment when loading the binary and initializes
    them to zero.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 初看起来，为什么段的文件大小（`p_filesz`）和内存中的大小（`p_memsz`）需要分别定义，可能不太明显。为了理解这一点，回想一下，有些段只表示需要在内存中分配一些字节，但实际上并不占用二进制文件中的这些字节。例如，`.bss`段包含零初始化的数据。由于该段中的所有数据已知本身就是零，因此不需要在二进制文件中实际包含这些零。然而，当将包含`.bss`的段加载到虚拟内存时，所有`.bss`中的字节*应该*被分配。因此，`p_memsz`有可能大于`p_filesz`。发生这种情况时，加载器在加载二进制文件时会在段的末尾添加额外的字节，并将它们初始化为零。
- en: '*2.4.4 The p_align Field*'
  id: totrans-162
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '*2.4.4 p_align字段*'
- en: The `p_align` field is analogous to the `sh_addralign` field in a section header.
    It indicates the required memory alignment (in bytes) for the segment. Just as
    with `sh_addralign`, an alignment value of 0 or 1 indicates that no particular
    alignment is required. If `p_align` isn’t set to 0 or 1, then its value must be
    a power of 2, and `p_vaddr` must be equal to `p_offset`, modulo `p_align`.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: '`p_align`字段类似于节头中的`sh_addralign`字段。它表示段所需的内存对齐（以字节为单位）。就像`sh_addralign`一样，值为0或1表示不需要特定的对齐。如果`p_align`没有设置为0或1，则其值必须是2的幂，且`p_vaddr`必须等于`p_offset`，模`p_align`。'
- en: 2.5 Summary
  id: totrans-164
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.5 总结
- en: In this chapter, you learned all the intricacies of the ELF format. I covered
    the format of the executable header, the section header and program header tables,
    and the contents of sections. That was quite an endeavor! It was worth it because
    now that you’re familiar with the innards of ELF binaries, you have a great foundation
    for learning more about binary analysis. In the next chapter, you’ll take a detailed
    look at the PE format, which is a binary format used in Windows-based systems.
    If you’re interested only in analyzing ELF binaries, you can skip the next chapter
    and move straight to [Chapter 4](ch04.xhtml#ch04).
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你了解了ELF格式的所有细节。我讲解了可执行文件头部格式、节头和程序头表格的格式，以及节的内容。这是一次相当大的挑战！但这是值得的，因为现在你已经熟悉了ELF二进制文件的内部结构，你有了一个很好的基础，能够进一步学习二进制分析。在下一章中，你将详细了解PE格式，这是Windows系统中使用的二进制格式。如果你只对分析ELF二进制文件感兴趣，可以跳过下一章，直接进入[第4章](ch04.xhtml#ch04)。
- en: Exercises
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 练习
- en: 1\. Manual Header Inspection
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 1\. 手动检查头部
- en: Use a hex viewer such as `xxd` to view the bytes in an ELF binary in hexadecimal
    format. For example, you can use the command `xxd /bin/ls | head -n 30` to view
    the first 30 lines of bytes for the */bin/ls* program. Can you identify the bytes
    representing the ELF header? Try to find all of the ELF header fields in the `xxd`
    output and see whether the contents of those fields make sense to you.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 使用类似`xxd`的十六进制查看器以十六进制格式查看ELF二进制文件中的字节。例如，你可以使用命令`xxd /bin/ls | head -n 30`来查看*/bin/ls*程序的前30行字节。你能识别出表示ELF头部的字节吗？试着在`xxd`的输出中找到所有ELF头部字段，并看看这些字段的内容是否对你有意义。
- en: 2\. Sections and Segments
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 2\. 节与段
- en: Use `readelf` to view the sections and segments in an ELF binary. How are the
    sections mapped into segments? Make an illustration of the binary’s on-disk representation
    versus its representation in memory. What are the major differences?
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`readelf`查看ELF二进制文件中的节和段。节是如何映射到段中的？请制作二进制文件的磁盘表示与内存表示的插图。它们之间有哪些主要差异？
- en: 3\. C and C++ Binaries
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 3\. C和C++二进制文件
- en: Use `readelf` to disassemble two binaries, namely a binary produced from C source
    and one produced from C++ source. What differences are there?
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`readelf`反汇编两个二进制文件，一个是从C源代码编译而成，另一个是从C++源代码编译而成。它们之间有什么区别？
- en: 4\. Lazy Binding
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 4\. 延迟绑定
- en: Use `objdump` to disassemble the PLT section of an ELF binary. Which GOT entries
    do the PLT stubs use? Now view the contents of those GOT entries (again with `objdump`)
    and analyze their relationship with the PLT.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`objdump`反汇编ELF二进制文件的PLT段。PLT存根使用了哪些GOT条目？现在查看这些GOT条目的内容（再次使用`objdump`），并分析它们与PLT的关系。
