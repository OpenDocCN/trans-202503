- en: '**5'
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '**5'
- en: OPERATING SYSTEM BOOT PROCESS ESSENTIALS**
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: '**操作系统引导过程要点**'
- en: '![Image](../images/common.jpg)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/common.jpg)'
- en: This chapter introduces you to the most important bootkit-related aspects of
    the Microsoft Windows boot process. Because the goal of the bootkit is to hide
    on a target system at a very low level, it needs to tamper with the OS boot components.
    So, before we can dive into how bootkits are built and how they behave, you’ll
    need to understand how the boot process works.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将介绍 Microsoft Windows 引导过程中的一些与引导木马（bootkit）相关的最重要的方面。由于引导木马的目标是在目标系统的低级别隐藏，它需要篡改操作系统的引导组件。因此，在我们深入了解引导木马的构建和行为之前，你需要了解引导过程是如何工作的。
- en: '**NOTE**'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*The information in this chapter applies to Microsoft Windows Vista and later
    versions; the boot process for earlier versions of Windows differs, as explained
    in* “[*The* bootmgr *Module and Boot Configuration Data*](ch05.xhtml#ch05lev2sec4)”
    *on [page 64](ch05.xhtml#page_64).*'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: '*本章中的信息适用于 Microsoft Windows Vista 及其后续版本；早期版本的 Windows 引导过程有所不同，具体内容请参见* “[*bootmgr
    模块和引导配置数据*](ch05.xhtml#ch05lev2sec4)” *在 [第64页](ch05.xhtml#page_64)中的内容。*'
- en: The boot process is one of the most important yet least understood phases of
    operating system operation. Although the general concept is universally familiar,
    few programmers—including systems programmers—understand it in detail, and most
    lack the tools to do so. This makes the boot process fertile ground for attackers
    to leverage the knowledge they’ve gleaned from reverse engineering and experimentation,
    while programmers must often rely on documentation that’s incomplete or outdated.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 引导过程是操作系统运行中最重要但却最难理解的阶段之一。尽管这个概念在普遍情况下大家都很熟悉，但很少有程序员——包括系统程序员——能深入理解它，而且大多数人缺乏相关工具。正因如此，引导过程成为攻击者利用反向工程和实验所得知识的温床，而程序员通常不得不依赖那些不完整或过时的文档。
- en: From a security point of view, the boot process is responsible for starting
    the system and bringing it to a trustworthy state. The logical facilities that
    defensive code uses to check the state of a system are also created during this
    process, so the earlier an attacker manages to compromise a system, the easier
    it is to hide from a defender’s checks.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 从安全角度来看，引导过程负责启动系统并将其引导到一个可信的状态。防御代码用来检查系统状态的逻辑设施也在这一过程中创建，因此攻击者越早能够攻破系统，就越容易躲避防御者的检查。
- en: In this chapter, we review the basics of the boot process in Windows systems
    running on machines with legacy firmware. The boot process for machines running
    UEFI firmware, introduced in Windows 7 x64 SP1, is significantly different from
    legacy-based machines, so we’ll discuss that process separately in [Chapter 14](ch14.xhtml#ch14).
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中，我们回顾了在运行传统固件的 Windows 系统中的引导过程基础。运行 UEFI 固件的机器，其引导过程与基于传统固件的机器有显著不同，后者自
    Windows 7 x64 SP1 起引入，因此我们将在 [第14章](ch14.xhtml#ch14)中单独讨论该过程。
- en: Throughout this chapter, we approach the boot process from the attacker’s point
    of view. Although nothing prevents attackers from targeting a specific chipset
    or peripheral—and indeed some do—these kinds of attacks do not scale well and
    are hard to develop reliably. It’s in the attacker’s best interest, therefore,
    to target interfaces that are relatively generic, yet not so generic that defensive
    programmers could easily understand and analyze the attacks.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们从攻击者的角度出发，探讨引导过程。尽管攻击者可以针对特定的芯片组或外设发起攻击——事实上，确实有些攻击者这么做——但这种类型的攻击通常不具备良好的扩展性，且很难可靠地开发。因此，攻击者最好选择那些相对通用，但又不至于通用到防御程序员能够轻松理解和分析的接口。
- en: 'As always, offensive research pushes the envelope, digging deeper into the
    system as advances become public and transparent. The organization of this chapter
    underscores this point: we’ll begin with a general overview but progress to undocumented
    (at the time of this writing) data structures and a logic flow that can be gleaned
    only from disassembling the system—exactly the route that both bootkit researchers
    and malware creators follow.'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 一如既往，进攻性研究不断推动技术的边界，随着技术的进步，更多系统内部的细节被公开并透明化。本章的结构也凸显了这一点：我们将从一般概述开始，但逐步深入到未文档化（在本文写作时）的数据结构和逻辑流程，这些内容只能通过反汇编系统获得——这正是引导木马研究人员和恶意软件创作者所走的路线。**
- en: '**High-Level Overview of the Windows Boot Process**'
  id: totrans-11
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**Windows 引导过程的高级概述**'
- en: '[Figure 5-1](ch05.xhtml#ch05fig01) shows the general flow of the modern boot
    process. Almost any part of the process can be attacked by a bootkit, but the
    most common targets are the Basic Input/Output System (BIOS) initialization, the
    Master Boot Record (MBR), and the operating system bootloader.'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 5-1](ch05.xhtml#ch05fig01) 显示了现代启动过程的一般流程。几乎任何启动过程的部分都可以被启动工具包攻击，但最常见的目标是基本输入/输出系统（BIOS）初始化、主引导记录（MBR）和操作系统引导加载程序。'
- en: '![image](../images/05fig01.jpg)'
  id: totrans-13
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/05fig01.jpg)'
- en: '*Figure 5-1: The flow of the system boot process*'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 5-1：系统启动过程的流程图*'
- en: '**NOTE**'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*Secure Boot technology, which we’ll discuss in [Chapter 17](ch17.xhtml#ch17),
    aims to protect the modern boot process, including its complex and versatile UEFI
    parts.*'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: '*安全启动技术，我们将在[第 17 章](ch17.xhtml#ch17)中讨论，旨在保护现代启动过程，包括其复杂且多功能的 UEFI 部分。*'
- en: As the boot process progresses, the execution environment becomes more complex,
    offering the defender richer and more familiar programming models. However, it’s
    the lower-level code that creates and supports these abstracted models, so by
    targeting that code, attackers can manipulate the models to intercept the flow
    of the boot process and interfere with the higher-level system state. In this
    way, more abstract and powerful models can be crippled, which is exactly the point
    of a bootkit.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 随着启动过程的推进，执行环境变得更加复杂，防御者可以获得更丰富且更熟悉的编程模型。然而，正是低级代码创建并支持这些抽象模型，因此，通过攻击这些低级代码，攻击者可以操纵这些模型，拦截启动过程的流程并干扰更高级别的系统状态。通过这种方式，更多的抽象和强大的模型可能会被削弱，这正是启动工具包的目的所在。
- en: '**The Legacy Boot Process**'
  id: totrans-18
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**传统启动过程**'
- en: 'To understand a technology, it is helpful to review its previous iterations.
    Here’s a basic summary of the boot process as it was normally executed in the
    heyday of boot sector viruses (1980s–2000s), such as Brain (discussed in [Chapter
    4](ch04.xhtml#ch04)):'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 要理解一项技术，回顾其早期版本是有帮助的。这里是启动过程的基本概述，它通常在启动扇区病毒的鼎盛时期（1980 年代至 2000 年代）执行，如 Brain（在[第
    4 章](ch04.xhtml#ch04)中讨论）：
- en: Power on (a cold boot)
  id: totrans-20
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 开机（冷启动）
- en: Power supply self-test
  id: totrans-21
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 电源自检
- en: ROM BIOS execution
  id: totrans-22
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: ROM BIOS 执行
- en: ROM BIOS test of hardware
  id: totrans-23
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: ROM BIOS 硬件测试
- en: Video test
  id: totrans-24
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 视频测试
- en: Memory test
  id: totrans-25
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 内存测试
- en: Power-On Self-Test (POST), a full hardware check (this step can be skipped when
    the boot process is a *warm* or *soft boot*—that is, a boot from a state that
    isn’t completely off)
  id: totrans-26
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 开机自检（POST），进行全面硬件检查（当启动过程为*热启动*或*软启动*时，即从非完全关机状态启动，此步骤可跳过）
- en: Test for the MBR at the first sector of the default boot drive, as specified
    in the BIOS setup
  id: totrans-27
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在默认启动驱动器的第一个扇区测试 MBR，如 BIOS 设置中所指定
- en: MBR execution
  id: totrans-28
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: MBR 执行
- en: Operating system file initialization
  id: totrans-29
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 操作系统文件初始化
- en: Base device driver initializations
  id: totrans-30
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 基础设备驱动程序初始化
- en: Device status check
  id: totrans-31
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 设备状态检查
- en: Configuration file reading
  id: totrans-32
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 配置文件读取
- en: Command shell loading
  id: totrans-33
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 命令行 shell 加载
- en: Shell’s startup command file execution
  id: totrans-34
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: shell 启动命令文件执行
- en: Notice that the early boot process begins by testing and initializing the hardware.
    This is often still the case, though many hardware and firmware technologies have
    moved on since Brain and its immediate successors. The boot processes described
    later in this book differ from earlier iterations in terminology and complexity,
    but the overall principles are similar.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，早期的启动过程通过测试和初始化硬件开始。尽管许多硬件和固件技术自 Brain 及其直接继任者以来已有所发展，但这一点仍然适用。本文书后续描述的启动过程在术语和复杂性上有所不同，但总体原理相似。
- en: '**The Windows Boot Process**'
  id: totrans-36
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**Windows 启动过程**'
- en: '[Figure 5-2](ch05.xhtml#ch05fig02) shows a high-level picture of the Windows
    boot process and the components involved, applicable to Windows versions Vista
    and higher. Each block in the figure represents modules that are executed and
    given control during the boot process, in order from top to bottom. As you can
    see, it’s quite similar to the iterations of the legacy boot process. However,
    as the components of modern Windows operating systems have increased in complexity,
    so too have the modules involved in the boot process.'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 5-2](ch05.xhtml#ch05fig02) 显示了 Windows 启动过程和涉及的组件的高级视图，适用于 Windows Vista
    及更高版本。图中的每个模块代表在启动过程中执行并获得控制的模块，按从上到下的顺序排列。如你所见，它与传统启动过程的迭代非常相似。然而，随着现代 Windows
    操作系统组件的复杂性增加，启动过程涉及的模块也相应增多。'
- en: '![image](../images/05fig02.jpg)'
  id: totrans-38
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/05fig02.jpg)'
- en: '*Figure 5-2: A high-level view of the Windows boot process*'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 5-2：Windows 启动过程的高级视图*'
- en: Over the next few sections, we’ll refer to this figure as we walk through this
    boot process in more detail. As [Figure 5-2](ch05.xhtml#ch05fig02) shows, when
    a computer is first powered on, the BIOS boot code receives control. This is the
    start of the boot process as the software sees it; other logic is involved at
    the hardware/firmware level (for example, during chipset initialization) but is
    not visible to software during the boot process.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的几节中，我们将引用此图，详细讲解启动过程。如[图 5-2](ch05.xhtml#ch05fig02)所示，当计算机首次开机时，BIOS 引导代码获取控制权。这是软件所见的启动过程的开始；硬件/固件层也涉及其他逻辑（例如，在芯片组初始化期间），但在启动过程中软件是不可见的。
- en: '***BIOS and the Preboot Environment***'
  id: totrans-41
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***BIOS 和预引导环境***'
- en: The BIOS performs basic system initialization and a POST to ensure that the
    critical system hardware is working properly. The BIOS also provides a specialized
    environment that includes the basic services needed to communicate with system
    devices. This simplified I/O interface first becomes available in the preboot
    environment, and is later replaced by different operating system abstractions
    for the majority of Windows uses. The most interesting of these services in terms
    of bootkit analysis is the *disk service*, which exposes a number of entry points
    used to perform disk I/O operations. The disk service is accessible through a
    special handler known as the *interrupt 13h handler*, or simply INT 13h. Bootkits
    will often target the disk service by tampering with its INT 13h; they do this
    in an effort to disable or circumvent OS protections by modifying operating system
    and boot components that are read from the hard drive during system startup.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: BIOS 执行基本的系统初始化和自检（POST），以确保关键系统硬件正常工作。BIOS 还提供了一个专门的环境，其中包含与系统设备通信所需的基本服务。这个简化的
    I/O 接口首先在预引导环境中可用，稍后被不同的操作系统抽象所替代，供大多数 Windows 用户使用。在启动木马分析中，最有趣的服务是 *磁盘服务*，它暴露了用于执行磁盘
    I/O 操作的多个入口点。磁盘服务可以通过一个特殊的处理程序访问，这个处理程序被称为 *中断 13h 处理程序*，简称 INT 13h。启动木马通常会通过篡改
    INT 13h 来攻击磁盘服务；它们这样做是为了通过修改系统启动时从硬盘读取的操作系统和引导组件来禁用或规避操作系统的保护。
- en: Next, the BIOS looks for the bootable disk drive, which hosts the instance of
    the operating system to be loaded. This may be a hard drive, a USB drive, or a
    CD drive. Once the bootable device has been identified, the BIOS boot code loads
    the MBR, as [Figure 5-2](ch05.xhtml#ch05fig02) shows.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，BIOS 查找可引导的磁盘驱动器，该驱动器托管要加载的操作系统实例。它可能是硬盘、USB 驱动器或 CD 驱动器。一旦识别出可引导设备，BIOS
    引导代码加载 MBR，如[图 5-2](ch05.xhtml#ch05fig02)所示。
- en: '***The Master Boot Record***'
  id: totrans-44
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***主引导记录（MBR）***'
- en: The MBR is a data structure containing information on hard drive partitions
    and the boot code. Its main task is to determine the active partition of the bootable
    hard drive, which contains the instance of the OS to load. Once it has identified
    the active partition, the MBR reads and executes its boot code. [Listing 5-1](ch05.xhtml#ch05list01)
    shows the structure of the MBR.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: MBR 是一种数据结构，包含硬盘分区信息和引导代码。它的主要任务是确定可引导硬盘的活动分区，该分区包含要加载的操作系统实例。一旦识别出活动分区，MBR
    将读取并执行其引导代码。[列表 5-1](ch05.xhtml#ch05list01) 展示了 MBR 的结构。
- en: '[PRE0]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '*Listing 5-1: The structure of the MBR*'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 5-1：MBR 的结构*'
- en: As you can see, the MBR boot code ➊ is restricted to just 446 bytes (0x1BE in
    hexadecimal, a familiar value to reverse engineers of boot code), so it can implement
    only basic functionality. Next, the MBR parses the partition table, shown at ➋,
    in order to locate the active partition; reads the Volume Boot Record (VBR) in
    its first sector; and transfers control to it.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，MBR 引导代码 ➊ 仅限于 446 字节（在十六进制中为 0x1BE，这是反向工程引导代码人员熟悉的值），因此它只能实现基本功能。接下来，MBR
    解析分区表，图示在 ➋，以定位活动分区；读取该分区的第一个扇区中的卷引导记录（VBR）；并将控制权转交给它。
- en: '**Partition Table**'
  id: totrans-49
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**分区表**'
- en: The partition table in the MBR is an array of four elements, each of which is
    described by the `MBR_PARTITION_TABLE_ENTRY` structure shown in [Listing 5-2](ch05.xhtml#ch05list02).
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: MBR 中的分区表是一个包含四个元素的数组，每个元素都由 `MBR_PARTITION_TABLE_ENTRY` 结构描述，如[列表 5-2](ch05.xhtml#ch05list02)所示。
- en: '[PRE1]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '*Listing 5-2: The structure of the partition table entry*'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 5-2：分区表条目的结构*'
- en: The first byte ➊ of the `MBR_PARTITION_TABLE_ENTRY`, the `status` field, signifies
    whether the partition is active. Only one partition at any time may be marked
    as active, a status indicated with a value of 128 (0x80 in hexadecimal).
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: '`MBR_PARTITION_TABLE_ENTRY` 的第一个字节 ➊，即 `status` 字段，表示分区是否为活动分区。任何时候只能有一个分区被标记为活动分区，其状态由值
    128（十六进制为 0x80）表示。'
- en: 'The `type` field ➋ lists the partition type. The most common types are:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: '`type` 字段 ➋ 列出了分区类型。最常见的类型有：'
- en: EXTENDED MBR partition type
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 扩展 MBR 分区类型
- en: FAT12 filesystem
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: FAT12 文件系统
- en: FAT16 filesystem
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: FAT16 文件系统
- en: FAT32 filesystem
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: FAT32 文件系统
- en: IFS (Installable File System used for the installation process)
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: IFS（用于安装过程的可安装文件系统）
- en: LDM (Logical Disk Manager for Microsoft Windows NT)
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: LDM（Microsoft Windows NT 的逻辑磁盘管理器）
- en: NTFS (the primary Windows filesystem)
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: NTFS（主要的 Windows 文件系统）
- en: A type of `0` means *unused*. The fields `lbaStart` and `size` ➌ define the
    location of the partition on disk, expressed in sectors. The `lbaStart` field
    contains the offset of the partition from the beginning of the hard drive, and
    the `size` field contains the size of the partition.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 类型为 `0` 表示 *未使用*。字段 `lbaStart` 和 `size` ➌ 定义了分区在磁盘上的位置，单位为扇区。`lbaStart` 字段包含分区相对于硬盘起始位置的偏移量，`size`
    字段包含分区的大小。
- en: '**Microsoft Windows Drive Layout**'
  id: totrans-63
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**Microsoft Windows 驱动器布局**'
- en: '[Figure 5-3](ch05.xhtml#ch05fig03) shows the typical bootable hard drive layout
    of a Microsoft Windows system with two partitions.'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 5-3](ch05.xhtml#ch05fig03) 显示了一个典型的 Microsoft Windows 系统的可启动硬盘布局，包含两个分区。'
- en: The Bootmgr partition contains the *bootmgr* module and some other OS boot components,
    while the OS partition contains a volume that hosts the OS and user data. The
    *bootmgr* module’s main purpose is to determine which particular instance of the
    OS to load. If multiple operating systems are installed on the computer, *bootmgr*
    displays a dialog prompting the user to choose one. The *bootmgr* module also
    provides parameters that determine how the OS is loaded (whether it should be
    in safe mode, using the last-known good configuration, with driver signature enforcement
    disabled, and so on).
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: Bootmgr 分区包含 *bootmgr* 模块和一些其他的操作系统启动组件，而操作系统分区则包含一个主机操作系统和用户数据的卷。*bootmgr*
    模块的主要作用是决定加载哪个特定的操作系统实例。如果计算机上安装了多个操作系统，*bootmgr* 会显示一个对话框提示用户选择其中一个。*bootmgr*
    模块还提供了一些参数，用以决定操作系统如何加载（例如是否以安全模式启动、使用最后一次良好配置、禁用驱动程序签名强制等）。
- en: '![image](../images/05fig03.jpg)'
  id: totrans-66
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/05fig03.jpg)'
- en: '*Figure 5-3: The typical bootable hard drive layout*'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 5-3：典型的可启动硬盘布局*'
- en: '***The Volume Boot Record and Initial Program Loader***'
  id: totrans-68
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***卷引导记录和初始程序加载器***'
- en: The hard drive may contain several partitions hosting multiple instances of
    different operating systems, but only one partition should normally be marked
    as active. The MBR does not contain the code to parse the particular filesystem
    used on the active partition, so it reads and executes the first sector of the
    partition, the VBR, shown in the third layer of [Figure 5-2](ch05.xhtml#ch05fig02).
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 硬盘可能包含多个分区，主机上有多个不同操作系统实例，但通常只有一个分区应该标记为活动分区。MBR 不包含解析活动分区上特定文件系统的代码，因此它读取并执行分区的第一个扇区，即
    VBR，见 [图 5-2](ch05.xhtml#ch05fig02)。
- en: The VBR contains partition layout information, which specifies the type of filesystem
    in use and its parameters, and code that reads the Initial Program Loader (IPL)
    module from the active partition. The IPL module implements filesystem-parsing
    functionality in order to be able to read files from the partition’s filesystem.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: VBR 包含分区布局信息，指定正在使用的文件系统类型及其参数，并包含从活动分区读取初始程序加载器（IPL）模块的代码。IPL 模块实现文件系统解析功能，以便能够从分区的文件系统中读取文件。
- en: '[Listing 5-3](ch05.xhtml#ch05list03) shows the layout of the VBR, which is
    composed of `BIOS_PARAMETER_BLOCK_NTFS` and `BOOTSTRAP_CODE` structures. The layout
    of the `BIOS_PARAMETER_BLOCK` (BPB) structure is specific to the volume’s filesystem.
    The `BIOS_PARAMETER_BLOCK_NTFS` and `VOLUME_BOOT_RECORD` structures correspond
    to the NTFS volume.'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: '[清单 5-3](ch05.xhtml#ch05list03) 显示了 VBR 的布局，由 `BIOS_PARAMETER_BLOCK_NTFS` 和
    `BOOTSTRAP_CODE` 结构组成。`BIOS_PARAMETER_BLOCK`（BPB）结构的布局特定于卷的文件系统。`BIOS_PARAMETER_BLOCK_NTFS`
    和 `VOLUME_BOOT_RECORD` 结构对应于 NTFS 卷。'
- en: '[PRE2]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '*Listing 5-3: VBR layout*'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 5-3：VBR 布局*'
- en: Notice that the VBR starts with a `jmp` instruction ➋, which transfers control
    of the system to the VBR code. The VBR code in turn reads and executes the IPL
    from the partition, the location of which is specified by the `HiddenSectors`
    field ➊. The IPL reports its offset (in sectors) from the beginning of the hard
    drive. The layout of the VBR is summarized in [Figure 5-4](ch05.xhtml#ch05fig04).
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，VBR 以一个`jmp`指令 ➋ 开始，该指令将系统控制转交给 VBR 代码。VBR 代码又读取并执行来自分区的 IPL，分区的位置由`HiddenSectors`字段
    ➊ 指定。IPL 报告其从硬盘开始的偏移量（以扇区为单位）。VBR 的布局总结在[图 5-4](ch05.xhtml#ch05fig04)中。
- en: '![image](../images/05fig04.jpg)'
  id: totrans-75
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/05fig04.jpg)'
- en: '*Figure 5-4: The structure of the VBR*'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 5-4：VBR 的结构*'
- en: 'As you can see, the VBR essentially consists of the following components:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，VBR 基本上由以下组件组成：
- en: The VBR code responsible for loading the IPL
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 负责加载 IPL 的 VBR 代码
- en: The BIOS parameter block (a data structure that stores the volume parameters)
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: BIOS 参数块（一个存储卷参数的数据结构）
- en: Text strings displayed to a user if an error occurs
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果发生错误，显示给用户的文本字符串
- en: 0xAA55, a 2-byte signature of the VBR
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 0xAA55，VBR 的 2 字节签名
- en: The IPL usually occupies 15 consecutive sectors of 512 bytes each and is located
    right after the VBR. It implements just enough code to parse the partition’s filesystem
    and continue loading the *bootmgr* module. The IPL and VBR are used together because
    the VBR can occupy only one sector and cannot implement sufficient functionality
    to parse the volume’s filesystem with so little space available to it.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: IPL 通常占用 15 个连续的 512 字节的扇区，并位于 VBR 之后。它实现了足够的代码来解析分区的文件系统并继续加载*bootmgr*模块。IPL
    和 VBR 一起使用，因为 VBR 只能占用一个扇区，并且由于空间有限，无法实现足够的功能来解析卷的文件系统。
- en: '***The bootmgr Module and Boot Configuration Data***'
  id: totrans-83
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***bootmgr 模块与引导配置数据***'
- en: The IPL reads and loads the OS boot manager’s *bootmgr* module from the filesystem,
    shown in the fourth layer of [Figure 5-2](ch05.xhtml#ch05fig02). Once the IPL
    runs, *bootmgr* takes over the boot process.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: IPL 从文件系统中读取并加载操作系统引导管理器的*bootmgr*模块，如[图 5-2](ch05.xhtml#ch05fig02)的第四层所示。一旦IPL运行，*bootmgr*便接管了引导过程。
- en: The *bootmgr* module reads from the Boot Configuration Data (BCD), which contains
    several important system parameters, including those that affect security policies
    such as the Kernel-Mode Code Signing Policy, covered in [Chapter 6](ch06.xhtml#ch06).
    Bootkits often attempt to bypass *bootmgr*’s implementation of code integrity
    verification.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: '*bootmgr*模块从引导配置数据（BCD）中读取，这些数据包含多个重要的系统参数，包括那些影响安全策略的参数，如内核模式代码签名策略，详细内容请见[第
    6 章](ch06.xhtml#ch06)。引导木马通常试图绕过*bootmgr*的代码完整性验证实现。'
- en: '**ORIGINS OF THE BOOTMGR MODULE**'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: '**bootmgr 模块的起源**'
- en: 'The *bootmgr* module was introduced in Windows Vista to replace the `ntldr`
    bootloader found in previous NT-derived versions of Windows. Microsoft’s idea
    was to create an additional layer of abstraction in the boot chain in order to
    isolate the preboot environment from the OS kernel layer. Isolation of the boot
    modules from the OS kernel brought improvements in boot management and security
    to Windows, making it easier to enforce security policies imposed on the kernel-mode
    modules (such as the Kernel-Mode Code Signing Policy). The legacy `ntldr` was
    split into two modules: *bootmgr* and *winload.exe* (or *winresume.exe* if the
    OS is loaded from the hibernation). Each module implements distinct functionality.'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: '*bootmgr*模块是在 Windows Vista 中引入的，旨在替代以前 NT 衍生版本中找到的`ntldr`引导加载程序。微软的想法是，在引导链中创建一个额外的抽象层，以便将预引导环境与操作系统内核层隔离开来。将引导模块与操作系统内核隔离，改善了
    Windows 的引导管理和安全性，使得在内核模式模块上强制执行安全策略（如内核模式代码签名策略）变得更加容易。遗留的`ntldr`被分为两个模块：*bootmgr*和*winload.exe*（如果操作系统从休眠加载，则是*winresume.exe*）。每个模块实现了不同的功能。'
- en: The *bootmgr* module manages the boot process until the user chooses a boot
    option (as shown in [Figure 5-5](ch05.xhtml#ch05fig05) for Windows 10). The program
    *winload.exe* (or *winresume.exe*) loads the kernel, boot-start drivers, and some
    system registry data once the user makes a choice.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: '*bootmgr*模块管理引导过程，直到用户选择引导选项（如[图 5-5](ch05.xhtml#ch05fig05)所示的 Windows 10）。一旦用户做出选择，程序*winload.exe*（或*winresume.exe*）会加载内核、引导启动驱动程序以及一些系统注册表数据。'
- en: '![image](../images/05fig05.jpg)'
  id: totrans-89
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/05fig05.jpg)'
- en: '*Figure 5-5: The* bootmgr *boot menu in Windows 10*'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 5-5：Windows 10 中的*bootmgr*引导菜单*'
- en: '**Real Mode vs. Protected Mode**'
  id: totrans-91
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**实模式与保护模式**'
- en: 'When a computer is first powered on, the CPU operates in *real mode*, a legacy
    execution mode that uses a 16-bit memory model in which each byte in RAM is addressed
    by a pointer consisting of two words (2 bytes): *segment_start*:*segment_offset*.
    This mode corresponds to the *segment memory model*, where the address space is
    divided into segments. The address of every target byte is described by the address
    of the segment and the offset of the target byte within the segment. Here, *segment_start*
    specifies the target segment, and *segment_offset* is the offset of the referenced
    byte in the target segment.'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 当计算机第一次开机时，CPU以*实模式*运行，这是一种使用16位内存模型的传统执行模式，其中RAM中的每个字节由一个包含两个字（2字节）的指针表示：*段起始*:*段偏移*。该模式对应于*段内存模型*，其中地址空间被划分为多个段。每个目标字节的地址通过段的地址和该字节在段内的偏移量来描述。在这里，*段起始*指定目标段，*段偏移*是目标段内参考字节的偏移量。
- en: The real-mode addressing scheme allows the use of only a small amount of the
    available system RAM. Specifically, the real (physical) address in the memory
    is computed as the largest address, represented as ffff:ffff, which is only 1,114,095
    bytes (65,535 × 16 + 65,535), meaning the address space in real mode is limited
    to around 1 MB—obviously not sufficient for modern operating systems and applications.
    To circumvent this limitation and get access to all available memory, *bootmgr*
    and *winload.exe* switch the processor into *protected mode* (called *long mode*
    on 64-bit systems) once *bootmgr* takes over.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 实模式寻址方案只允许使用系统RAM中的一小部分。具体来说，内存中的实际（物理）地址计算为最大的地址，表示为ffff:ffff，这仅为1,114,095字节（65,535
    × 16 + 65,535），意味着实模式下的地址空间仅限于大约1MB——显然不足以支持现代操作系统和应用程序。为了绕过这一限制并访问所有可用内存，*bootmgr*和*winload.exe*在*bootmgr*接管控制后将处理器切换到*保护模式*（在64位系统上称为*长模式*）。
- en: The *bootmgr* module consists of 16-bit real-mode code and a compressed PE image,
    which, when uncompressed, is executed in protected mode. The 16-bit code extracts
    and uncompresses the PE from the *bootmgr* image, switches the processor into
    protected mode, and passes control to the uncompressed module.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: '*bootmgr*模块由16位实模式代码和一个压缩的PE镜像组成，解压后在保护模式下执行。16位代码从*bootmgr*镜像中提取并解压PE，切换处理器到保护模式，然后将控制权交给解压后的模块。'
- en: '**NOTE**'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*Bootkits must properly handle the processor execution mode switch in order
    to maintain control of the boot code execution. After the switch, the whole memory
    layout is changed, and parts of the code previously located at one contiguous
    set of memory addresses may be moved to different memory segments. Bootkits must
    implement rather sophisticated functionality to get around this and keep control
    of the boot process.*'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: '*引导工具包必须正确处理处理器执行模式的切换，以便维持对启动代码执行的控制。切换后，整个内存布局会发生变化，之前位于连续内存地址集合中的部分代码可能会被移动到不同的内存段。引导工具包必须实现相当复杂的功能来绕过这一点，并保持对启动过程的控制。*'
- en: '**BCD Boot Variables**'
  id: totrans-97
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**BCD 启动变量**'
- en: Once the *bootmgr* initializes protected mode, the uncompressed image receives
    control and loads boot configuration information from the BCD. When stored on
    the hard drive, the BCD has the same layout as a registry hive. (To browse its
    contents, use `regedit` and navigate to the key *HKEY_LOCAL_MACHINE\BCD000000*.)
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦*bootmgr*初始化了保护模式，未压缩的镜像便接管控制并从BCD中加载启动配置数据。当BCD存储在硬盘上时，它的布局与注册表蜂巢相同。（要浏览其内容，可以使用`regedit`并导航到键
    *HKEY_LOCAL_MACHINE\BCD000000*。）
- en: '**NOTE**'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*To read from the hard drive,* bootmgr, *operating in protected mode, uses
    the INT 13h disk service, which is intended to be run in real mode. To do so,*
    bootmgr *saves the execution context of the processor in temporary variables,
    temporarily switches to real mode, executes the INT 13h handler, and then returns
    to protected mode, restoring the saved context.*'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: '*为了从硬盘读取数据，*bootmgr*在保护模式下使用INT 13h磁盘服务，而该服务原本是为实模式设计的。为了做到这一点，*bootmgr*将处理器的执行上下文保存到临时变量中，暂时切换到实模式，执行INT
    13h处理程序，然后返回保护模式，恢复保存的上下文。*'
- en: The BCD store contains all the information *bootmgr* needs in order to load
    the OS, including the path to the partition containing the OS instance to load,
    available boot applications, code integrity options, and parameters instructing
    the OS to load in preinstallation mode, safe mode, and so on.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: BCD存储包含*bootmgr*加载操作系统所需的所有信息，包括指向包含要加载操作系统实例的分区的路径、可用的启动应用程序、代码完整性选项以及指示操作系统加载预安装模式、安全模式等的参数。
- en: '[Table 5-1](ch05.xhtml#ch05tab01) shows the parameters in the BCD of greatest
    interest to bootkit authors.'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: '[表 5-1](ch05.xhtml#ch05tab01)显示了在BCD中最受bootkit作者关注的参数。'
- en: '**Table 5-1:** BCD Boot Variables'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: '**表 5-1:** BCD启动变量'
- en: '| **Variable name** | **Description** | **Parameter type** | **Parameter ID**
    |'
  id: totrans-104
  prefs: []
  type: TYPE_TB
  zh: '| **变量名称** | **描述** | **参数类型** | **参数ID** |'
- en: '| --- | --- | --- | --- |'
  id: totrans-105
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- |'
- en: '| `BcdLibraryBoolean_DisableIntegrityCheck` | Disables kernel-mode code integrity
    checks | `Boolean` | `0x16000048` |'
  id: totrans-106
  prefs: []
  type: TYPE_TB
  zh: '| `BcdLibraryBoolean_DisableIntegrityCheck` | 禁用内核模式代码完整性检查 | `Boolean` | `0x16000048`
    |'
- en: '| `BcdOSLoaderBoolean_WinPEMode` | Tells the kernel to load in preinstallation
    mode, disabling kernel-mode code integrity checks as a byproduct | `Boolean` |
    `0x26000022` |'
  id: totrans-107
  prefs: []
  type: TYPE_TB
  zh: '| `BcdOSLoaderBoolean_WinPEMode` | 告诉内核以预安装模式加载，并作为副作用禁用内核模式代码完整性检查 | `Boolean`
    | `0x26000022` |'
- en: '| `BcdLibraryBoolean_AllowPrereleaseSignatures` | Enables test signing (TESTSIGNING)
    | `Boolean` | `0x1600004` |'
  id: totrans-108
  prefs: []
  type: TYPE_TB
  zh: '| `BcdLibraryBoolean_AllowPrereleaseSignatures` | 启用测试签名（TESTSIGNING） | `Boolean`
    | `0x1600004` |'
- en: The variable `BcdLibraryBoolean_DisableIntegrityCheck` is used to disable integrity
    checks and allow the loading of unsigned kernel-mode drivers. This option is ignored
    in Windows 7 and higher and cannot be set if Secure Boot (discussed in [Chapter
    17](ch17.xhtml#ch17)) is enabled.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 变量`BcdLibraryBoolean_DisableIntegrityCheck`用于禁用完整性检查并允许加载未签名的内核模式驱动程序。此选项在Windows
    7及更高版本中被忽略，如果启用了安全启动（参见[第17章](ch17.xhtml#ch17)），则无法设置此选项。
- en: The variable `BcdOSLoaderBoolean_WinPEMode` indicates that the system should
    be started in Windows Preinstallation Environment Mode, which is essentially a
    minimal Win32 operating system with limited services that is primarily used to
    prepare a computer for Windows installation. This mode also disables kernel integrity
    checks, including the Kernel-Mode Code Signing Policy mandatory on 64-bit systems.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 变量`BcdOSLoaderBoolean_WinPEMode`表示系统应以Windows预安装环境模式启动，这本质上是一个最小化的Win32操作系统，提供有限的服务，主要用于为Windows安装准备计算机。此模式还会禁用内核完整性检查，包括在64位系统上强制执行的内核模式代码签名策略。
- en: The variable `BcdLibraryBoolean_AllowPrereleaseSignatures` uses test code-signing
    certificates to load kernel-mode drivers for testing purposes. These certificates
    can be generated through tools included in the Windows Driver Kit. (The *Necurs*
    rootkit uses this process to install a malicious kernel-mode driver onto a system,
    signed with a custom certificate.)
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 变量`BcdLibraryBoolean_AllowPrereleaseSignatures`使用测试代码签名证书加载内核模式驱动程序用于测试目的。这些证书可以通过包含在Windows驱动程序工具包中的工具生成。（*Necurs*根套件利用此过程将恶意的内核模式驱动程序安装到系统中，该驱动程序由自定义证书签名。）
- en: After retrieving boot options, the *bootmgr* performs self-integrity verification.
    If the check fails, the *bootmgr* stops booting the system and displays an error
    message. However, the *bootmgr* doesn’t perform the self-integrity check if either
    `BcdLibraryBoolean_DisableIntegrityCheck` or `BcdOSLoaderBoolean_WinPEMode` is
    set to `TRUE` in the BCD. Thus, if either variable is `TRUE`, the *bootmgr* won’t
    notice if it has been tampered with by malicious code.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 在检索到启动选项后，*bootmgr*执行自完整性验证。如果验证失败，*bootmgr*会停止启动系统并显示错误信息。然而，如果`BcdLibraryBoolean_DisableIntegrityCheck`或`BcdOSLoaderBoolean_WinPEMode`在BCD中被设置为`TRUE`，*bootmgr*则不会执行自完整性检查。因此，如果任一变量为`TRUE`，*bootmgr*将不会注意到其是否已被恶意代码篡改。
- en: Once all the necessary BCD parameters have been loaded and self-integrity verification
    has been passed, the *bootmgr* chooses the boot application to load. When loading
    the OS afresh from the hard drive, the *bootmgr* chooses *winload.exe*; when resuming
    from hibernation, the *bootmgr* chooses *winresume.exe*. These respective PE modules
    are responsible for loading and initializing OS kernel modules. The *bootmgr*
    checks the integrity of the boot application in the same way, again skipping verification
    if either `BcdLibraryBoolean_DisableIntegrityCheck` or `BcdOSLoaderBoolean_WinPEMode`
    is `TRUE`.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦所有必要的BCD参数已加载且自完整性验证通过，*bootmgr*会选择要加载的启动应用程序。当从硬盘重新加载操作系统时，*bootmgr*选择*winload.exe*；当从休眠状态恢复时，*bootmgr*选择*winresume.exe*。这些各自的PE模块负责加载和初始化操作系统内核模块。*bootmgr*以相同的方式检查启动应用程序的完整性，如果`BcdLibraryBoolean_DisableIntegrityCheck`或`BcdOSLoaderBoolean_WinPEMode`为`TRUE`，则再次跳过验证。
- en: In the final step of the boot process, once the user has chosen a particular
    instance of the OS to load, the *bootmgr* loads *winload.exe*. Once all modules
    are properly initialized, *winload.exe* (layer 5 in [Figure 5-2](ch05.xhtml#ch05fig02))
    passes control to the OS kernel, which continues the boot process (layer 6). Like
    *bootmgr*, *winload.exe* checks the integrity of all modules it is responsible
    for. Many bootkits attempt to circumvent these checks in order to inject a malicious
    module into the operating system kernel-mode address space.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 在引导过程的最后一步，一旦用户选择了要加载的操作系统实例，*bootmgr* 会加载 *winload.exe*。一旦所有模块都正确初始化，*winload.exe*（[图5-2](ch05.xhtml#ch05fig02)中的第5层）将控制权传递给操作系统内核，后者继续引导过程（第6层）。与*bootmgr*一样，*winload.exe*
    会检查它所负责的所有模块的完整性。许多引导程序会试图绕过这些检查，以便将恶意模块注入操作系统内核模式地址空间。
- en: 'When *winload.exe* receives control of the operating system boot, it enables
    paging in protected mode and then loads the OS kernel image and its dependencies,
    including these modules:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 当 *winload.exe* 接管操作系统引导时，它会启用受保护模式中的分页，然后加载操作系统内核镜像及其依赖项，包括以下模块：
- en: '***bootvid.dll*** A library for video VGA support at boot time'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: '***bootvid.dll*** 引导时的视频 VGA 支持库'
- en: '***ci.dll*** The code integrity library'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: '***ci.dll*** 代码完整性库'
- en: '***clfs.dll*** The common logging filesystem driver'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: '***clfs.dll*** 通用日志文件系统驱动程序'
- en: '***hal.dll*** The hardware abstraction layer library'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: '***hal.dll*** 硬件抽象层库'
- en: '***kdcom.dll*** The kernel debugger protocol communications library'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: '***kdcom.dll*** 内核调试器协议通信库'
- en: '***pshed.dll*** The platform-specific hardware error driver'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: '***pshed.dll*** 特定平台硬件错误驱动程序'
- en: In addition to these modules, *winload.exe* loads boot-start drivers, including
    storage device drivers, Early Launch Anti-Malware (ELAM) modules (explained in
    [Chapter 6](ch06.xhtml#ch06)), and the system registry hive.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 除了这些模块，*winload.exe* 还加载引导启动驱动程序，包括存储设备驱动程序、早期启动反恶意软件（ELAM）模块（在[第6章](ch06.xhtml#ch06)中解释）和系统注册表配置单元。
- en: '**NOTE**'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*In order to read all the components from the hard drive,* winload.exe *uses
    the interface provided by* bootmgr. *This interface relies on the BIOS INT 13h
    disk service. Therefore, if the INT 13h handler is hooked by a bootkit, the malware
    can spoof all data read by* winload.exe.'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: '*为了从硬盘读取所有组件，* winload.exe *使用由* bootmgr 提供的接口。* 该接口依赖于 BIOS INT 13h 磁盘服务。因此，如果
    INT 13h 处理程序被引导程序钩住，恶意软件可以伪造所有* winload.exe*读取的数据。'
- en: When loading the executables, *winload.exe* verifies their integrity according
    to the system’s code integrity policy. Once all modules are loaded, *winload.exe*
    transfers control to the OS kernel image to initialize them, as discussed in the
    following chapters.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 在加载可执行文件时，*winload.exe* 会根据系统的代码完整性策略验证其完整性。一旦所有模块加载完成，*winload.exe* 会将控制权交给操作系统内核镜像以初始化它们，如接下来的章节中所讨论的那样。
- en: '**Conclusion**'
  id: totrans-126
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**结论**'
- en: In this chapter, you learned about the MBR and VBR in the early boot stages,
    as well as important boot components such as *bootmgr* and *winload.exe*, from
    the point of view of bootkit threats.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一章中，你了解了早期引导阶段中的 MBR 和 VBR，以及从引导程序威胁角度来看，*bootmgr* 和 *winload.exe* 等重要引导组件。
- en: As you’ve seen, transferring control between the phases of the boot process
    is not as simple as jumping directly to the next stage. Instead, several components
    that are related through various data structures—such as the MBR partition table,
    the VBR BIOS parameter block, and the BCD—determine execution flow in the preboot
    environment. This nontrivial relationship is one reason why bootkits are so complex
    and why they make so many modifications to boot components in order to transfer
    control from the original boot code to their own (and occasionally back and forth,
    to carry out essential tasks).
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，控制权在引导过程各个阶段之间的转移，并不像直接跳到下一个阶段那么简单。相反，通过各种数据结构（如 MBR 分区表、VBR BIOS 参数块和
    BCD）关联的多个组件决定了预引导环境中的执行流程。这个复杂的关系是引导程序如此复杂的原因之一，也是它们通过修改引导组件，旨在将控制权从原始引导代码转移到自己的代码（并且有时来回切换，以执行必要任务）的原因。
- en: In the next chapter, we look at boot process security, focusing on the ELAM
    and the Microsoft Kernel-Mode Code Signing Policy, which defeated the methods
    of early rootkits.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将研究引导过程的安全性，重点讨论 ELAM 和微软内核模式代码签名策略，这些策略成功地击败了早期 rootkit 的方法。
