- en: <hgroup>
  id: totrans-0
  prefs: []
  type: TYPE_NORMAL
  zh: <hgroup>
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">14</samp> <samp class="SANS_Dogma_OT_Bold_B_11">NEO-NAZIS
    AND THEIR CHATROOMS</samp>
  id: totrans-1
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">14</samp> <samp class="SANS_Dogma_OT_Bold_B_11">新纳粹分子及其聊天室</samp>
- en: </hgroup>
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: </hgroup>
- en: In early August 2017, hundreds of white supremacists assembled in the city of
    Charlottesville, Virginia, for the Unite the Right rally. The protesters—hailing
    from groups like Vanguard America, Identity Evropa, League of the South, and the
    Ku Klux Klan—flew Nazi and Confederate battle flags, wore red “Make America Great
    Again” hats, and chanted slogans like “Jews will not replace us!”
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 2017年8月初，数百名白人至上主义者在弗吉尼亚州夏洛茨维尔市集结，参加“团结右派”集会。抗议者们来自先锋美国、身份欧洲（Identity Evropa）、南方联盟（League
    of the South）和三K党等团体，举着纳粹和南方邦联战旗，戴着红色的“让美国再次伟大”帽子，喊着“犹太人不会取代我们！”等口号。
- en: On August 12, James Alex Fields Jr., described by his high school history teacher
    as “deeply into Adolf Hitler and white supremacy,” drove a car into a group of
    counterprotesters, murdering 32-year-old Heather Heyer and injuring 19 other people.
    Earlier in the event, Fields was seen marching with a Vanguard America shield.
    That same day, a group of six white men followed 20-year-old Black special ed
    assistant teacher DeAndre Harris into a parking garage and beat him with poles
    and metal pipes, an attack that was caught on film and posted to the internet.
    In response to the racist violence, Trump famously said that there were “very
    fine people on both sides.”
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 2017年8月12日，詹姆斯·亚历克斯·菲尔兹（James Alex Fields Jr.）被他的高中历史老师形容为“对阿道夫·希特勒和白人至上主义深感兴趣”，他驾车冲入一群反对抗议者中，造成32岁的赫瑟·海耶（Heather
    Heyer）死亡，19人受伤。在事件发生之前，菲尔兹曾被看到拿着先锋美国的盾牌参加游行。就在那天，一群六个白人男子跟随20岁的黑人特殊教育助理教师德安德烈·哈里斯（DeAndre
    Harris）进入一个停车库，用棍棒和金属管殴打他，这一袭击被拍成视频并上传到互联网。面对这种种族主义暴力，特朗普曾著名地表示，“双方都有非常优秀的人。”
- en: The Unite the Right rally, like much of the American fascist movement’s activism
    during the 2017–2021 Trump presidency, was largely organized online using Discord,
    a group chat platform designed for gamers. In Discord, users join *servers*, a
    group of chatrooms, or a *channel*, a single chatroom. Each channel covers different
    topics. Fascists created Discord servers for their regional hate groups, as well
    as for projects like organizing Unite the Right.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: “团结右派”集会，像2017至2021年特朗普总统任期内美国法西斯主义运动的许多活动一样，主要是在网上组织的，使用的是Discord平台——一个为游戏玩家设计的群聊平台。在Discord中，用户加入*服务器*（一组聊天室）或*频道*（单个聊天室）。每个频道讨论不同的主题。法西斯分子为他们的地方仇恨团体创建了Discord服务器，也用于像组织“团结右派”这样的项目。
- en: An antifascist infiltrator gained access to the server used to organize Unite
    the Right, called Charlottesville 2.0, as well as many other servers used by fascists
    at the time. They then leaked the chat logs to Chris Schiano and Dan Feidt, journalists
    working with the independent nonprofit news collective Unicorn Riot. The leak
    took the form of screenshots from the Discord app, large JSON files containing
    thousands of messages, and audio recordings from voice meetings.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 一名反法西斯渗透者获得了用于组织“团结右派”集会的服务器访问权限，这个服务器名为Charlottesville 2.0，此外还访问了当时法西斯分子使用的许多其他服务器。随后，他们将聊天日志泄露给了Chris
    Schiano和Dan Feidt，这两位记者与独立非营利新闻团体Unicorn Riot合作。此次泄露以Discord应用的截图、包含数千条信息的大型JSON文件和语音会议的录音形式呈现。
- en: In this chapter, I describe how the JSON chat log files were structured and
    how I went about analyzing them, using techniques covered in [Chapter 11](chapter11.xhtml).
    I’ll describe the custom app that I wrote to investigate this dataset and explain
    how I used it to investigate a Discord server called Pony Power, whose members
    doxed their political enemies. You’ll also learn the inside story of DiscordLeaks,
    Unicorn Riot’s public searchable archive based on my app, which contains millions
    of chat messages from far-right Discord servers. Finally, I discuss a major hack
    of the American neo-Nazi organization Patriot Front that took place four and a
    half years after the Charlottesville rally. This hack included chat logs from
    RocketChat, a self-hosted system that Unicorn Riot also hosts in DiscordLeaks.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我将描述JSON聊天日志文件的结构，以及我如何分析这些文件，使用的技术涵盖在[第11章](chapter11.xhtml)中。我会介绍我编写的自定义应用程序，用于调查这个数据集，并解释我如何使用它调查一个名为Pony
    Power的Discord服务器，其成员曾揭露他们的政治敌人。你还将了解DiscordLeaks的内幕故事，这是Unicorn Riot基于我的应用程序创建的公共可搜索档案，包含来自极右翼Discord服务器的数百万条聊天消息。最后，我将讨论发生在“夏洛茨维尔集会”四年半后，美国新纳粹组织Patriot
    Front的一次重大黑客事件。此次黑客攻击包括来自RocketChat的聊天日志，RocketChat是一个自托管系统，Unicorn Riot也将其托管在DiscordLeaks中。
- en: Like my reporting on the AFLDS dataset, this case study is an example of journalism
    with real-world impact. My work, along with that of Unicorn Riot, antifascist
    infiltrators, and other anonymous developers, helped lead to a court settlement
    against the most notorious American white supremacist leaders and organizations,
    resulting in over $25 million worth of damages. I hope that this case study will
    inspire your own work on datasets of structured chat logs, should you obtain them
    in the future. With the rise of remote work and the increasing popularity of chat
    platforms like Discord, Slack, and RocketChat, this type of leak is only getting
    more common.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 就像我对 AFLDS 数据集的报道一样，这个案例研究是具有现实世界影响的新闻报道。我的工作，连同 Unicorn Riot、反法西斯渗透者和其他匿名开发者的努力，帮助导致了针对美国最臭名昭著的白人至上主义领导人和组织的庭外和解，结果造成超过
    2500 万美元的赔偿。我希望这个案例研究能够激励你在未来获得结构化聊天记录数据集时，也能开展自己的工作。随着远程工作的兴起，以及 Discord、Slack
    和 RocketChat 等聊天平台的日益流行，这类泄露事件变得愈发常见。
- en: I’ll start with a brief description of how these chat logs were leaked.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 我将从简要描述这些聊天记录是如何泄露的开始。
- en: <samp class="SANS_Futura_Std_Bold_B_11">How Antifascists Infiltrated Neo-Nazi
    Discord Servers</samp>
  id: totrans-10
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">反法西斯分子如何渗透新纳粹 Discord 服务器</samp>
- en: Unicorn Riot reporters covered the Unite the Right gathering on the ground in
    Charlottesville. In the following days, the collective announced that it had received
    anonymously leaked chat logs from the far-right groups that took part in the rally,
    and particularly from the Charlottesville 2.0 Discord server. It began publishing
    articles based on these leaks, showing evidence of premeditated plans for violence,
    memes about hitting protesters with cars, and posts made after the event celebrating
    Heather Heyer’s murder. It also published ZIP files containing thousands of screenshots
    from the infiltrated Discord servers. Researchers, both amateur and professional,
    immediately began correlating breadcrumbs from these chat logs with photos and
    videos of the event that were posted to social media to identify specific fascist
    activists.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: Unicorn Riot 的记者们在 Charlottesville 地面上报道了 Unite the Right 集会。随后几天，这个组织宣布它收到了来自参与集会的极右翼团体，特别是
    Charlottesville 2.0 Discord 服务器的匿名泄露聊天记录。它开始根据这些泄露内容发布文章，展示了有关暴力预谋的证据、关于用车撞击抗议者的恶搞图片，以及集会后庆祝
    Heather Heyer 谋杀的帖子。它还发布了包含成千上万张来自渗透 Discord 服务器的截图的 ZIP 文件。研究人员，包括业余和专业人士，立刻开始将这些聊天记录中的线索与社交媒体上发布的事件照片和视频进行关联，以识别具体的法西斯活动分子。
- en: 'Alongside Charlottesville 2.0, other leaked fascist Discord servers had names
    like Vibrant Diversity, Ethnoserver, Safe Space 3, and 4th Reich. Some servers
    only had a few dozen users, while others had over a thousand. The most active
    server at the time, Vibrant Diversity, included a channel called #problematic_oven,
    where users shared racist memes. The 4th Reich server included a #rare_hitlers
    channel, where users shared vintage propaganda from Nazi Germany.'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: '除了 Charlottesville 2.0，其他泄露的法西斯 Discord 服务器的名称还包括 Vibrant Diversity、Ethnoserver、Safe
    Space 3 和 4th Reich。一些服务器只有几十个用户，而其他服务器的用户数超过了千人。那个时候最活跃的服务器 Vibrant Diversity
    有一个名为 #problematic_oven 的频道，用户们在这里分享种族主义的恶搞图片。4th Reich 服务器有一个名为 #rare_hitlers
    的频道，用户们分享来自纳粹德国的复古宣传资料。'
- en: Once the reporting of Unicorn Riot and others had made it clear to Discord that
    Nazis were relying on its service, the chat platform shut down many far-right
    chat servers and accounts. “Discord’s mission is to bring people together around
    gaming. We’re about positivity and inclusivity. Not hate. Not violence,” the company
    said in a statement. “We will continue to take action against white supremacy,
    nazi ideology, and all forms of hate.” Shutting down individual servers and accounts
    didn’t work, though; fascists simply created new accounts and set up new chat
    servers. Just as quickly, antifascists infiltrated those new servers and continued
    to leak chat logs to Unicorn Riot.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦 Unicorn Riot 和其他媒体的报道让 Discord 意识到纳粹分子正在依赖它的服务，聊天平台关闭了许多极右翼的聊天服务器和账号。公司在一份声明中表示：“Discord
    的使命是围绕游戏将人们聚集在一起。我们倡导积极性和包容性，不容忍仇恨，不容忍暴力。” “我们将继续采取行动，反对白人至上主义、纳粹意识形态以及所有形式的仇恨。”然而，关闭个别服务器和账号并没有奏效；法西斯分子很快就创建了新的账号，设立了新的聊天服务器。反法西斯分子也同样迅速渗透这些新服务器，并继续将聊天记录泄露给
    Unicorn Riot。
- en: 'Fascists started spreading conspiracy theories that there were no infiltrators
    but that Discord itself was selling their chat logs to the Southern Poverty Law
    Center, a nonprofit that monitors hate groups. “The Charlottesville planning server
    was leaked, even though it was highly secure and no one could figure out who could
    have leaked it,” Andrew Anglin, founder of the notorious neo-Nazi website the
    Daily Stormer, wrote in an April 2018 blog post. “Since then, servers have been
    repeatedly leaked. People have been doxed without being able to figure out how
    they were doxed. Repeatedly and consistently, I have been given reason to believe
    that these are not Discord ‘leaks,’ but data being bought by our enemies.” This
    wasn’t true, of course. Anglin provided no evidence for the claim, Discord’s privacy
    policy promises that it doesn’t sell user data, and we know exactly how the data
    was leaked: antifascists were invited into the group by pretending to be racists.'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 法西斯分子开始传播阴谋论，声称没有渗透者，实际上是 Discord 自己将他们的聊天记录出售给了南方贫困法律中心（Southern Poverty Law
    Center），这个非营利组织专门监控仇恨团体。臭名昭著的纳粹网站《每日风暴》（The Daily Stormer）创始人安德鲁·安格林（Andrew Anglin）在
    2018 年 4 月的一篇博客文章中写道：“即使‘夏洛茨维尔策划服务器’是高度安全的，没人能弄明白是谁泄露了它，它仍然被泄露了。”他继续说道，“从那时起，服务器屡次被泄露，人们在无法弄清楚如何被泄露的情况下被人肉搜索。我反复且持续地得到理由相信，这些并不是
    Discord ‘泄露’，而是我们的敌人购买的数据。” 当然，这不是真的。安格林没有提供任何证据，Discord 的隐私政策承诺不出售用户数据，而我们确切知道数据是如何泄露的：反法西斯分子通过假装是种族主义者被邀请进入群组。
- en: A few weeks after Unite the Right, I got a hold of some of these chat logs myself
    and began to analyze them.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在“联合极右”（Unite the Right）事件发生几周后，我自己也获得了一些这些聊天记录，并开始分析它们。
- en: <samp class="SANS_Futura_Std_Bold_B_11">Analyzing Leaked Chat Logs</samp>
  id: totrans-16
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">分析泄露的聊天记录</samp>
- en: In late August of 2017, after Unicorn Riot had started publishing articles based
    on leaked chats, someone from the collective asked me if I’d like to cover the
    fascist chat logs for The Intercept. While journalism can be competitive, with
    each newsroom racing to publish breaking news first without getting scooped, the
    opposite is often true when it comes to complicated datasets. When it’s clear
    that there’s no way that a single newsroom has the resources to discover all of
    the revelations in a dataset, it only makes sense to bring in other newsrooms
    and share access to the data. This sort of collaboration helps everyone because
    different newsrooms have different audiences, and it makes real-world impact from
    the reporting more likely.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 在 2017 年 8 月下旬，Unicorn Riot 开始根据泄露的聊天记录发布文章时，集体中的某个人问我是否愿意为《拦截报》（The Intercept）报道法西斯聊天记录。虽然新闻行业的竞争激烈，每个新闻机构都在争抢率先发布新闻而不被抢先报道，但当涉及复杂的数据集时，情况往往正好相反。当显然没有单一新闻机构拥有足够资源来发现数据集中的所有重要信息时，邀请其他新闻机构并共享数据访问权限显得很有意义。这种合作有助于每个人，因为不同的新闻机构有不同的受众，并且这样可以增加报道对现实世界产生影响的可能性。
- en: My Unicorn Riot contact sent me a ZIP file full of JSON files and screenshots
    of Discord chats that covered several Discord servers. The JSON files contained
    more complete logs of everything posted to these chatrooms, while the screenshots
    captured only specific conversations. While screenshots are initially simpler
    to use because you don’t need to write any code or use special tools to read them,
    having the chat logs in a structured data format like JSON is much more useful
    in the long run. The best way to peruse screenshots of chats is to open individual
    images, read them one at a time, take note of the filenames that contain interesting
    content, and refer back to them as needed. This quickly becomes unwieldy when
    you’re dealing with thousands of screenshots.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 我的 Unicorn Riot 联系人发给我一个 ZIP 文件，里面包含了多个 Discord 服务器的 JSON 文件和 Discord 聊天截图。JSON
    文件包含了这些聊天室中所有发布内容的完整日志，而截图仅捕捉了特定的对话。虽然截图最初使用起来更简单，因为你不需要编写任何代码或使用特殊工具来查看它们，但将聊天记录存储在像
    JSON 这样的结构化数据格式中，从长远来看要有用得多。浏览聊天截图的最佳方式是打开单个图片，一次阅读一个，记下包含有趣内容的文件名，并根据需要回看它们。当你处理成千上万张截图时，这种方法很快就变得难以管理。
- en: I started digging into the JSON files to see what I was dealing with. Specifically,
    I used the handy command line tool <samp class="SANS_TheSansMonoCd_W5Regular_11">jq</samp>
    to figure out exactly how this data was structured in order to find the lists
    of users and channels and read the messages in each channel.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 我开始深入研究这些 JSON 文件，看看我到底在处理什么。具体来说，我使用了方便的命令行工具<samp class="SANS_TheSansMonoCd_W5Regular_11">jq</samp>，以便准确了解这些数据的结构，从而找到用户和频道的列表，并读取每个频道中的消息。
- en: <samp class="SANS_Dogma_OT_Bold_B_21">NOTE</samp>
  id: totrans-20
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: <samp class="SANS_Dogma_OT_Bold_B_21">注意</samp>
- en: '*Besides manually reading screenshots and taking notes, another option would
    have been to index the screenshots in software like Aleph, which you used in [Chapter
    5](chapter5.xhtml). Aleph would then perform OCR on the images, extracting their
    text and enabling me to search them for keywords. This might be helpful in locating
    specific messages, but in the end, it’s still not as useful as structured data.
    If I were dealing with this data today and only had screenshots without access
    to JSON data, I would definitely rely on Aleph.*'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: '*除了手动阅读截图并做笔记外，另一个选择是使用像 Aleph 这样的软件对截图进行索引，这在[第 5 章](chapter5.xhtml)中提到过。Aleph
    然后会对图片进行 OCR 处理，提取文本并使我能够在其中搜索关键字。这有助于定位特定消息，但最终它仍然不如结构化数据有用。如果今天我只拥有截图而没有 JSON
    数据，我一定会依赖 Aleph。*'
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Making JSON Files
    Readable</samp>
  id: totrans-22
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">使 JSON 文件可读</samp>
- en: Each JSON file within the ZIP file sent by my source contained the entire archive
    of chat logs from a given Discord server. For example, one 29MB JSON file was
    called *VibrantDiversityComplete-Sept5at327PM*. For the purposes of this book,
    I’ve renamed it *VibrantDiversity.json* to make the following examples easier
    to read.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 我的源发送的 ZIP 文件中的每个 JSON 文件都包含了一个给定 Discord 服务器的完整聊天记录归档。例如，一个 29MB 的 JSON 文件名为
    *VibrantDiversityComplete-Sept5at327PM*。为了本书的示例更易阅读，我将其重命名为 *VibrantDiversity.json*。
- en: 'When I opened this file in a text editor, its contents looked like this:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 当我在文本编辑器中打开这个文件时，它的内容如下：
- en: '[PRE0]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'This block of data is not very human-readable. As you learned in [Chapter 11](chapter11.xhtml),
    it’s much easier to read JSON data that’s been reformatted using line breaks,
    indentation, and syntax highlighting. Using the <samp class="SANS_TheSansMonoCd_W5Regular_11">jq</samp>
    command, I formatted it and added syntax highlighting in my terminal like so:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 这块数据对人类来说不太容易阅读。正如你在[第 11 章](chapter11.xhtml)中学到的，重新格式化后的 JSON 数据更容易阅读，使用换行、缩进和语法高亮。通过
    <samp class="SANS_TheSansMonoCd_W5Regular_11">jq</samp> 命令，我在终端中对其进行了格式化并添加了语法高亮，结果如下：
- en: '[PRE1]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Running this command added formatting and syntax highlighting to the file’s
    contents, but still resulted in 29MB of text madly scrolling through my terminal.
    To understand the data better, I needed to run more specific commands that would
    reveal its overall structure.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 运行这个命令为文件内容添加了格式化和语法高亮，但仍然导致 29MB 的文本在我的终端中疯狂滚动。为了更好地理解数据，我需要运行更具体的命令来揭示它的整体结构。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Exploring Objects,
    Keys, and Values with jq</samp>
  id: totrans-29
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">使用 jq 探索对象、键和值</samp>
- en: 'I could tell by looking at the beginning of the JSON data that the whole file
    was one large JSON object, and one of that object’s keys was <samp class="SANS_TheSansMonoCd_W5Regular_11">meta</samp>.
    I ran the following <samp class="SANS_TheSansMonoCd_W5Regular_11">jq</samp> command
    to see what other keys there were:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 我可以通过查看 JSON 数据的开头，判断整个文件是一个大的 JSON 对象，而该对象的一个键是 <samp class="SANS_TheSansMonoCd_W5Regular_11">meta</samp>。我运行了以下
    <samp class="SANS_TheSansMonoCd_W5Regular_11">jq</samp> 命令来查看还有哪些其他的键：
- en: '[PRE2]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The output told me that the data for each Discord server includes two parts,
    <samp class="SANS_TheSansMonoCd_W5Regular_11">data</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">meta</samp>:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 输出告诉我，每个 Discord 服务器的数据包括两部分：<samp class="SANS_TheSansMonoCd_W5Regular_11">data</samp>
    和 <samp class="SANS_TheSansMonoCd_W5Regular_11">meta</samp>：
- en: '[PRE3]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Guessing that <samp class="SANS_TheSansMonoCd_W5Regular_11">meta</samp> included
    the metadata for the server, I ran the following command to determine the keys
    of the <samp class="SANS_TheSansMonoCd_W5Regular_11">meta</samp> object:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 猜测 <samp class="SANS_TheSansMonoCd_W5Regular_11">meta</samp> 包含了服务器的元数据，我运行了以下命令来确定
    <samp class="SANS_TheSansMonoCd_W5Regular_11">meta</samp> 对象的键：
- en: '[PRE4]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: This command piped the output of <samp class="SANS_TheSansMonoCd_W5Regular_11">cat
    VibrantDiversity.json</samp> as input into the <samp class="SANS_TheSansMonoCd_W5Regular_11">jq
    '.meta | keys'</samp> command. It looks like there’s a second pipe there, but
    there’s not. The string <samp class="SANS_TheSansMonoCd_W5Regular_11">'.meta |
    keys'</samp> is actually just a single argument into <samp class="SANS_TheSansMonoCd_W5Regular_11">jq</samp>.
    The pipe character is how you chain multiple <samp class="SANS_TheSansMonoCd_W5Regular_11">jq</samp>
    filters together so that the output of one gets piped into the output of the next;
    in this case, <samp class="SANS_TheSansMonoCd_W5Regular_11">.meta</samp> outputs
    the value of the <samp class="SANS_TheSansMonoCd_W5Regular_11">meta</samp> key
    and pipes it into <samp class="SANS_TheSansMonoCd_W5Regular_11">keys</samp>, which
    outputs the keys from that value.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 该命令将<samp class="SANS_TheSansMonoCd_W5Regular_11">cat VibrantDiversity.json</samp>的输出作为输入传递给<samp
    class="SANS_TheSansMonoCd_W5Regular_11">jq '.meta | keys'</samp>命令。看起来像是有第二个管道符号，其实没有。字符串<samp
    class="SANS_TheSansMonoCd_W5Regular_11">'.meta | keys'</samp>实际上只是传递给<samp class="SANS_TheSansMonoCd_W5Regular_11">jq</samp>的一个单独参数。管道符号用于将多个<samp
    class="SANS_TheSansMonoCd_W5Regular_11">jq</samp>过滤器链在一起，使得一个过滤器的输出被传递给下一个过滤器的输入；在这种情况下，<samp
    class="SANS_TheSansMonoCd_W5Regular_11">.meta</samp>输出<meta>键的值，并将其传递给< samp class="SANS_TheSansMonoCd_W5Regular_11">keys</samp>，从中输出该值的所有键。
- en: 'The output showed me that the metadata included information about channels,
    servers, and users:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 输出显示，元数据中包含了关于频道、服务器和用户的信息：
- en: '[PRE5]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'So far, I had only looked at the keys of JSON objects. It was time to look
    at some of the content, starting with the servers. By running <samp class="SANS_TheSansMonoCd_W5Regular_11">jq
    ''.meta .servers''</samp>, I could look at the value of the <samp class="SANS_TheSansMonoCd_W5Regular_11">servers</samp>
    key inside the <samp class="SANS_TheSansMonoCd_W5Regular_11">meta</samp> object:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我只看过JSON对象的键值。现在是时候查看一些内容了，从服务器开始。通过运行<samp class="SANS_TheSansMonoCd_W5Regular_11">jq
    '.meta .servers'</samp>，我可以查看<meta>对象内< samp class="SANS_TheSansMonoCd_W5Regular_11">servers</samp>键的值：
- en: '[PRE6]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The output in [Listing 14-1](#list14-1) showed that *VibrantDiversity.json*
    lists a single server in the metadata sections, Vibrant Diversity, just as I expected.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: '[清单14-1](#list14-1)中的输出显示，*VibrantDiversity.json*在元数据部分列出了一个服务器，Vibrant Diversity，正如我所预期的。'
- en: '[PRE7]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 14-1: The list of servers
    in</samp> <samp class="SANS_Futura_Std_Book_11">VibrantDiversity.json</samp>'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">清单14-1：VibrantDiversity.json中的服务器列表</samp>
- en: I could tell that this output was an array, since it was a list of items surrounded
    by brackets ([and]).
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 我能看出这个输出是一个数组，因为它是一个由方括号([和])包围的项目列表。
- en: 'Next, I wanted to see what channels this server had, so I ran the following
    command to view the value of the <samp class="SANS_TheSansMonoCd_W5Regular_11">channels</samp>
    key in the <samp class="SANS_TheSansMonoCd_W5Regular_11">meta</samp> object:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我想查看这个服务器有哪些频道，于是我运行了以下命令来查看<meta>对象中< samp class="SANS_TheSansMonoCd_W5Regular_11">channels</samp>键的值：
- en: '[PRE8]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '[Listing 14-2](#list14-2) shows the output of this command.'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: '[清单14-2](#list14-2)显示了这个命令的输出。'
- en: '[PRE9]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 14-2: The list of channels
    in the Vibrant Diversity server</samp>'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">清单14-2：Vibrant Diversity服务器中的频道列表</samp>
- en: Whereas the output in [Listing 14-1](#list14-1) was an array, the output for
    <samp class="SANS_TheSansMonoCd_W5Regular_11">.meta.channels</samp> was a JSON
    object, as indicated by the braces (<samp class="SANS_TheSansMonoCd_W5Regular_11">{</samp>and})
    surrounding it.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 与[清单14-1](#list14-1)中的输出是一个数组不同，<samp class="SANS_TheSansMonoCd_W5Regular_11">.meta.channels</samp>的输出是一个JSON对象，正如其周围被大括号（<samp
    class="SANS_TheSansMonoCd_W5Regular_11">{</samp>和<sam class="SANS_TheSansMonoCd_W5Regular_11">}）包围所示。
- en: 'The keys for this object are long numbers, presumably the ID of the channel,
    and their values are objects that contain the <samp class="SANS_TheSansMonoCd_W5Regular_11">server</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">name</samp> keys. For example,
    the channel with key <samp class="SANS_TheSansMonoCd_W5Regular_11">288508006990348299</samp>
    has the value <samp class="SANS_TheSansMonoCd_W5Regular_11">{"server": 0, "name":
    "problematic_oven"}</samp>. The <samp class="SANS_TheSansMonoCd_W5Regular_11">server</samp>
    value for all of these channels is <samp class="SANS_TheSansMonoCd_W5Regular_11">0</samp>.
    I guessed that this was the index of the servers array from [Listing 14-1](#list14-1).
    Since there was only one server in this JSON file, the index for all of the channels
    is the first item in the list, <samp class="SANS_TheSansMonoCd_W5Regular_11">0</samp>.
    The <samp class="SANS_TheSansMonoCd_W5Regular_11">name</samp> value was <samp
    class="SANS_TheSansMonoCd_W5Regular_11">problematic_oven</samp>. When I later
    read the chats in this channel, it was full of antisemitic posts and Nazi memes,
    and the word *oven* was clearly a reference to the Holocaust. This was definitely
    a neo-Nazi chat server.'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: '这个对象的键是长数字，可能是频道的 ID，而它们的值是包含 <samp class="SANS_TheSansMonoCd_W5Regular_11">server</samp>
    和 <samp class="SANS_TheSansMonoCd_W5Regular_11">name</samp> 键的对象。例如，键为 <samp class="SANS_TheSansMonoCd_W5Regular_11">288508006990348299</samp>
    的频道，其值为 <samp class="SANS_TheSansMonoCd_W5Regular_11">{"server": 0, "name": "problematic_oven"}</samp>。这些频道的
    <samp class="SANS_TheSansMonoCd_W5Regular_11">server</samp> 值都是 <samp class="SANS_TheSansMonoCd_W5Regular_11">0</samp>。我猜测这是来自
    [清单 14-1](#list14-1) 中服务器数组的索引。由于这个 JSON 文件中只有一个服务器，所以所有频道的索引都是列表中的第一个项，<samp
    class="SANS_TheSansMonoCd_W5Regular_11">0</samp>。<samp class="SANS_TheSansMonoCd_W5Regular_11">name</samp>
    值为 <samp class="SANS_TheSansMonoCd_W5Regular_11">problematic_oven</samp>。当我稍后阅读该频道的聊天记录时，发现充满了反犹太言论和纳粹表情包，*oven*
    这个词显然是对大屠杀的暗示。这无疑是一个新纳粹的聊天服务器。'
- en: 'I wanted to see a list of this server’s users, so I ran the following command
    to view the value of the <samp class="SANS_TheSansMonoCd_W5Regular_11">users</samp>
    key in the <samp class="SANS_TheSansMonoCd_W5Regular_11">meta</samp> object:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 我想查看这个服务器的用户列表，因此我运行了以下命令来查看 <samp class="SANS_TheSansMonoCd_W5Regular_11">users</samp>
    键在 <samp class="SANS_TheSansMonoCd_W5Regular_11">meta</samp> 对象中的值：
- en: '[PRE10]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '[Listing 14-3](#list14-3) shows my output.'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: '[清单 14-3](#list14-3) 显示了我的输出。'
- en: '[PRE11]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 14-3: The list of users
    in the Vibrant Diversity server</samp>'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">清单 14-3：Vibrant Diversity 服务器中的用户列表</samp>
- en: Just like the list of channels in [Listing 14-2](#list14-2), the output for
    <samp class="SANS_TheSansMonoCd_W5Regular_11">.meta.users</samp> in [Listing 14-3](#list14-3)
    is a JSON object. The keys are long numbers, presumably the ID of the user, and
    the values are objects with just a single key, the user’s name.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 就像 [清单 14-2](#list14-2) 中的频道列表一样，[清单 14-3](#list14-3) 中的 <samp class="SANS_TheSansMonoCd_W5Regular_11">.meta.users</samp>
    输出是一个 JSON 对象。键是长数字，可能是用户的 ID，而值是只有一个键的对象——用户的名字。
- en: 'So far, I had explored the metadata keys <samp class="SANS_TheSansMonoCd_W5Regular_11">channels</samp>,
    <samp class="SANS_TheSansMonoCd_W5Regular_11">servers</samp>, and <samp class="SANS_TheSansMonoCd_W5Regular_11">users</samp>,
    but there was one left: the <samp class="SANS_TheSansMonoCd_W5Regular_11">userindex</samp>
    key. I ran the following command to view the <samp class="SANS_TheSansMonoCd_W5Regular_11">userindex</samp>
    key’s value:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我已经探索了元数据键 <samp class="SANS_TheSansMonoCd_W5Regular_11">channels</samp>、<samp
    class="SANS_TheSansMonoCd_W5Regular_11">servers</samp> 和 <samp class="SANS_TheSansMonoCd_W5Regular_11">users</samp>，但还有一个没有查看：<samp
    class="SANS_TheSansMonoCd_W5Regular_11">userindex</samp> 键。我运行了以下命令来查看 <samp class="SANS_TheSansMonoCd_W5Regular_11">userindex</samp>
    键的值：
- en: '[PRE12]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '[Listing 14-4](#list14-4) shows my output.'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: '[清单 14-4](#list14-4) 显示了我的输出。'
- en: '[PRE13]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 14-4: The list of user
    IDs for each user in the Vibrant Diversity server</samp>'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">清单 14-4：Vibrant Diversity 服务器中每个用户的用户
    ID 列表</samp>
- en: The output for the <samp class="SANS_TheSansMonoCd_W5Regular_11">.meta.userlist</samp>
    command was a JSON array rather than an object, and each item in the array was
    a string that looks like a Discord ID. Sure enough, the first item, <samp class="SANS_TheSansMonoCd_W5Regular_11">231148326249037824</samp>,
    turned out to be the ID of the first user from [Listing 14-3](#list14-3), D’Marcus
    Liebowitz. At this point I didn’t fully understand the purpose of <samp class="SANS_TheSansMonoCd_W5Regular_11">userlist</samp>,
    but it soon became clear, as you’ll see later in this section.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W5Regular_11">.meta.userlist</samp> 命令的输出是一个
    JSON 数组，而不是一个对象，数组中的每一项都是看起来像是 Discord ID 的字符串。果然，第一个项 <samp class="SANS_TheSansMonoCd_W5Regular_11">231148326249037824</samp>，就是[清单
    14-3](#list14-3)中的第一个用户，D’Marcus Liebowitz 的 ID。此时我还不完全理解 <samp class="SANS_TheSansMonoCd_W5Regular_11">userlist</samp>
    的用途，但很快就清楚了，正如你将在本节后面看到的那样。
- en: 'Armed with a basic understanding of the server’s metadata, I ran the following
    command to find the keys for the <samp class="SANS_TheSansMonoCd_W5Regular_11">data</samp>
    object:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 在对服务器的元数据有了基本了解之后，我运行了以下命令以查找 <samp class="SANS_TheSansMonoCd_W5Regular_11">data</samp>
    对象的键：
- en: '[PRE14]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '[Listing 14-5](#list14-5) shows my output.'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: '[清单 14-5](#list14-5) 显示了我的输出。'
- en: '[PRE15]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 14-5: The keys to the
    <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">data</samp> object in the
    Vibrant Diversity server</samp>'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">清单 14-5：Vibrant Diversity 服务器中
    <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">data</samp> 对象的键</samp>
- en: 'These keys are the same channel IDs from [Listing 14-2](#list14-2), so I guessed
    that the values of each key contained the actual messages in those chat channels.
    Because I needed to start somewhere, I decided to view the chat messages from
    the #problematic_oven channel, so I ran the following command:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: '这些键与[清单 14-2](#list14-2)中的相同频道 ID，因此我猜测每个键的值包含了这些聊天频道中的实际消息。因为我需要从某个地方开始，所以我决定查看
    #problematic_oven 频道中的聊天消息，于是我运行了以下命令：'
- en: '[PRE16]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'The full argument for this <samp class="SANS_TheSansMonoCd_W5Regular_11">jq</samp>
    command is surrounded by single quotes. The <samp class="SANS_TheSansMonoCd_W5Regular_11">.data</samp>
    part of the filter looks in the key <samp class="SANS_TheSansMonoCd_W5Regular_11">data</samp>,
    and the <samp class="SANS_TheSansMonoCd_W5Regular_11">."288508006990348299"</samp>
    part of the filter looks in the key <samp class="SANS_TheSansMonoCd_W5Regular_11">288508006990348299</samp>,
    which is the ID of the #problematic_oven channel. I put the ID in quotes so that
    <samp class="SANS_TheSansMonoCd_W5Regular_11">jq</samp> would know that this key
    was a string and not a number.'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: '这个 <samp class="SANS_TheSansMonoCd_W5Regular_11">jq</samp> 命令的完整参数被单引号包围。过滤器的
    <samp class="SANS_TheSansMonoCd_W5Regular_11">.data</samp> 部分查看键 <samp class="SANS_TheSansMonoCd_W5Regular_11">data</samp>，而
    <samp class="SANS_TheSansMonoCd_W5Regular_11">."288508006990348299"</samp> 部分查看键
    <samp class="SANS_TheSansMonoCd_W5Regular_11">288508006990348299</samp>，这个键是 #problematic_oven
    频道的 ID。我将 ID 用引号括起来，以便 <samp class="SANS_TheSansMonoCd_W5Regular_11">jq</samp>
    知道这个键是字符串而不是数字。'
- en: As with the first time I used <samp class="SANS_TheSansMonoCd_W5Regular_11">jq</samp>
    to read this JSON file, the output of this command scrolled through a large block
    of text, though considerably less than before. In this case, the output showed
    chat messages from only a single channel, rather than showing all of the data
    in the JSON file. [Listing 14-6](#list14-6) shows just a few chat messages from
    the middle of the output.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 和第一次使用 <samp class="SANS_TheSansMonoCd_W5Regular_11">jq</samp> 读取这个 JSON 文件一样，这个命令的输出滚动过一大块文本，虽然比之前少了很多。在这种情况下，输出只显示了来自一个频道的聊天消息，而不是显示
    JSON 文件中的所有数据。[清单 14-6](#list14-6) 显示了输出中的几条聊天消息。
- en: '[PRE17]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 14-6: Chat messages
    from the #problematic_oven channel in the Vibrant Diversity server</samp>'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">清单 14-6：Vibrant Diversity 服务器中
    #problematic_oven 频道的聊天消息</samp>'
- en: Just like the channels in [Listing 14-2](#list14-2), this output is a JSON object
    with keys that contain long numbers. In this case, these keys appeared to be message
    IDs, and the values appeared to be details about that specific chat message. In
    each message, the <samp class="SANS_TheSansMonoCd_W5Regular_11">u</samp> field
    represented the user and the <samp class="SANS_TheSansMonoCd_W5Regular_11">m</samp>
    field contained the message content. The <samp class="SANS_TheSansMonoCd_W5Regular_11">t</samp>
    field was a Unix timestamp, the number of seconds or sometimes milliseconds since
    January 1, 1970, a common way to represent specific dates and times in computer
    science. These particular timestamps were in milliseconds.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 就像在[列表 14-2](#list14-2)中的频道一样，这个输出是一个包含长数字的键的 JSON 对象。在这种情况下，这些键看起来像是消息 ID，而值则包含该特定聊天消息的详细信息。在每条消息中，<samp
    class="SANS_TheSansMonoCd_W5Regular_11">u</samp>字段代表用户，<samp class="SANS_TheSansMonoCd_W5Regular_11">m</samp>字段包含消息内容。<samp
    class="SANS_TheSansMonoCd_W5Regular_11">t</samp>字段是 Unix 时间戳，它表示自 1970 年 1 月 1
    日以来的秒数，有时是毫秒数，这是计算机科学中常用的表示特定日期和时间的方式。这些特定的时间戳是毫秒级的。
- en: At this point, I knew that I was looking at a conversation between two neo-Nazis.
    The top two messages in [Listing 14-6](#list14-6) are from a user with the ID
    of <samp class="SANS_TheSansMonoCd_W5Regular_11">4</samp>, and the bottom two
    messages are from a user with the ID of <samp class="SANS_TheSansMonoCd_W5Regular_11">1</samp>.
    Because the value of <samp class="SANS_TheSansMonoCd_W5Regular_11">t</samp> gets
    bigger with each message, these appear to be displayed in chronological order.
    I decided to take a closer look at the message <samp class="SANS_TheSansMonoCd_W5Regular_11">352992512752746496</samp>,
    from user <samp class="SANS_TheSansMonoCd_W5Regular_11">4</samp>, with the timestamp
    <samp class="SANS_TheSansMonoCd_W5Regular_11">1504230373324</samp>.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 到这个时刻，我知道我正在查看两名新纳粹分子之间的对话。[列表 14-6](#list14-6)中的前两条消息来自 ID 为 <samp class="SANS_TheSansMonoCd_W5Regular_11">4</samp>
    的用户，后两条消息来自 ID 为 <samp class="SANS_TheSansMonoCd_W5Regular_11">1</samp> 的用户。由于
    <samp class="SANS_TheSansMonoCd_W5Regular_11">t</samp> 的值随着每条消息的发送而增大，所以这些消息似乎是按时间顺序显示的。我决定仔细查看用户
    <samp class="SANS_TheSansMonoCd_W5Regular_11">4</samp> 发送的消息 <samp class="SANS_TheSansMonoCd_W5Regular_11">352992512752746496</samp>，其时间戳为
    <samp class="SANS_TheSansMonoCd_W5Regular_11">1504230373324</samp>。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Converting Timestamps</samp>
  id: totrans-77
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">转换时间戳</samp>
- en: Unix timestamps are a useful way for computers to store an entire date—the year,
    month, day, and time of day—in a single number. I needed to convert the timestamp
    associated with that message into human-readable format to find out the date and
    time when the message was posted.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: Unix 时间戳是计算机以单一数字存储完整日期——年份、月份、日期和时间——的有用方式。我需要将与该消息关联的时间戳转换为人类可读的格式，以找出消息发布的日期和时间。
- en: 'I used the following lines of code in the Python interpreter to convert the
    <samp class="SANS_TheSansMonoCd_W5Regular_11">1504230373324</samp> timestamp into
    a more human-readable Python <samp class="SANS_TheSansMonoCd_W5Regular_11">datetime</samp>
    object:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 我在 Python 解释器中使用了以下几行代码，将 <samp class="SANS_TheSansMonoCd_W5Regular_11">1504230373324</samp>
    时间戳转换为更易于人类理解的 Python <samp class="SANS_TheSansMonoCd_W5Regular_11">datetime</samp>
    对象：
- en: '[PRE18]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: The syntax in this code is similar to the code you used to import modules in
    [Chapter 8](chapter8.xhtml). Rather than <samp class="SANS_TheSansMonoCd_W5Regular_11">import</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">module</samp>, this code
    takes the syntax <samp class="SANS_TheSansMonoCd_W5Regular_11">from</samp> <samp
    class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">module</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">import</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">resource_name</samp>, loading
    a single <samp class="SANS_TheSansMonoCd_W5Regular_11">datetime</samp> resource
    from the <samp class="SANS_TheSansMonoCd_W5Regular_11">datetime</samp> module.
    Next, the code defines a variable called <samp class="SANS_TheSansMonoCd_W5Regular_11">timestamp</samp>
    and sets its value to the return value of the <samp class="SANS_TheSansMonoCd_W5Regular_11">datetime.fromtimestamp()</samp>
    function. This function takes the number of seconds since January 1, 1970, as
    an argument. Because the Discord logs are in milliseconds rather than seconds,
    this code first divides the Discord timestamp by 1,000 to convert it to seconds
    before passing it into the function. The function returns a Python <samp class="SANS_TheSansMonoCd_W5Regular_11">datetime</samp>
    object.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码的语法与 [第 8 章](chapter8.xhtml) 中用于导入模块的语法相似。不同的是，这段代码使用的语法是 <samp class="SANS_TheSansMonoCd_W5Regular_11">from</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">module</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">import</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">resource_name</samp>，从
    <samp class="SANS_TheSansMonoCd_W5Regular_11">datetime</samp> 模块中加载一个 <samp class="SANS_TheSansMonoCd_W5Regular_11">datetime</samp>
    资源。接下来，代码定义了一个名为 <samp class="SANS_TheSansMonoCd_W5Regular_11">timestamp</samp>
    的变量，并将其值设置为 <samp class="SANS_TheSansMonoCd_W5Regular_11">datetime.fromtimestamp()</samp>
    函数的返回值。该函数接受自 1970 年 1 月 1 日以来的秒数作为参数。由于 Discord 日志以毫秒为单位，而不是秒，因此这段代码首先将 Discord
    时间戳除以 1000，将其转换为秒，然后再将其传递给该函数。该函数返回一个 Python 的 <samp class="SANS_TheSansMonoCd_W5Regular_11">datetime</samp>
    对象。
- en: 'When I displayed the <samp class="SANS_TheSansMonoCd_W5Regular_11">datetime</samp>
    object with <samp class="SANS_TheSansMonoCd_W5Regular_11">print(timestamp)</samp>,
    I could see that this chat message was posted on August 31, 2017, at 6:46 PM:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 当我通过 <samp class="SANS_TheSansMonoCd_W5Regular_11">print(timestamp)</samp> 显示
    <samp class="SANS_TheSansMonoCd_W5Regular_11">datetime</samp> 对象时，我可以看到这条聊天消息是在
    2017 年 8 月 31 日下午 6:46 发布的：
- en: '[PRE19]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: I now had an idea of the timeframe in which this chat exchange took place. Next,
    I wanted to see which users were involved.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我对这次聊天交流发生的时间范围有了大致的了解。接下来，我想查看参与的用户。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Finding Usernames</samp>
  id: totrans-85
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">查找用户名</samp>
- en: I wanted to find the username for person who’d posted the <samp class="SANS_TheSansMonoCd_W5Regular_11">352992512752746496</samp>
    message in [Listing 14-6](#list14-6). The <samp class="SANS_TheSansMonoCd_W5Regular_11">u</samp>
    value for this message was <samp class="SANS_TheSansMonoCd_W5Regular_11">4</samp>,
    so I checked to see if <samp class="SANS_TheSansMonoCd_W5Regular_11">4</samp>
    was a valid user ID from the output in [Listing 14-3](#list14-3) but found that
    it wasn’t there; all of the user IDs in that JSON object are 18 digits long. I
    turned to the output in [Listing 14-4](#list14-4) that shows the value of <samp
    class="SANS_TheSansMonoCd_W5Regular_11">userindex</samp> in the <samp class="SANS_TheSansMonoCd_W5Regular_11">meta</samp>
    object. The value of <samp class="SANS_TheSansMonoCd_W5Regular_11">userindex</samp>
    is an array of strings, each an 18-digit user ID.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 我想找到在 [Listing 14-6](#list14-6) 中发布了 <samp class="SANS_TheSansMonoCd_W5Regular_11">352992512752746496</samp>
    消息的人的用户名。该消息的 <samp class="SANS_TheSansMonoCd_W5Regular_11">u</samp> 值是 <samp
    class="SANS_TheSansMonoCd_W5Regular_11">4</samp>，于是我检查了 [Listing 14-3](#list14-3)
    中的输出，查看 <samp class="SANS_TheSansMonoCd_W5Regular_11">4</samp> 是否是一个有效的用户 ID，但发现它不在那里；该
    JSON 对象中的所有用户 ID 都是 18 位数字。我转而查看了 [Listing 14-4](#list14-4) 中的输出，查看 <samp class="SANS_TheSansMonoCd_W5Regular_11">meta</samp>
    对象中 <samp class="SANS_TheSansMonoCd_W5Regular_11">userindex</samp> 的值。<samp class="SANS_TheSansMonoCd_W5Regular_11">userindex</samp>
    的值是一个字符串数组，每个元素都是一个 18 位的用户 ID。
- en: As described in [Chapter 11](chapter11.xhtml), JSON arrays are lists of items
    in a specific order. Objects, on the other hand, don’t have any order. You select
    values from arrays using their numerical indices, starting from index 0 for the
    first item. Because objects don’t have numerical indices, there’s no concept of
    the first, second, or third item in the object; you could edit a JSON file to
    rearrange the object’s items, and it would still be the same object. For this
    reason, I guessed that the <samp class="SANS_TheSansMonoCd_W5Regular_11">u</samp>
    value was actually an index of the <samp class="SANS_TheSansMonoCd_W5Regular_11">userindex</samp>
    array.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 如[第 11 章](chapter11.xhtml)所述，JSON 数组是按特定顺序排列的项目列表。另一方面，对象没有任何顺序。你通过它们的数字索引来选择数组中的值，索引从第一个项目的
    0 开始。由于对象没有数字索引，因此在对象中没有第一、第二或第三个项目的概念；你可以编辑 JSON 文件来重新排列对象中的项目，结果仍然是同一个对象。因此，我猜测
    <samp class="SANS_TheSansMonoCd_W5Regular_11">u</samp> 值实际上是 <samp class="SANS_TheSansMonoCd_W5Regular_11">userindex</samp>
    数组的一个索引。
- en: 'To determine which user ID corresponded to the user whose <samp class="SANS_TheSansMonoCd_W5Regular_11">u</samp>
    value was <samp class="SANS_TheSansMonoCd_W5Regular_11">4</samp>, I looked for
    the value of <samp class="SANS_TheSansMonoCd_W5Regular_11">userindex</samp> at
    index <samp class="SANS_TheSansMonoCd_W5Regular_11">4</samp> by running the following
    command:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 为了确定哪个用户 ID 对应于其 <samp class="SANS_TheSansMonoCd_W5Regular_11">u</samp> 值为 <samp
    class="SANS_TheSansMonoCd_W5Regular_11">4</samp> 的用户，我通过运行以下命令查找了 <samp class="SANS_TheSansMonoCd_W5Regular_11">userindex</samp>
    在索引 <samp class="SANS_TheSansMonoCd_W5Regular_11">4</samp> 处的值：
- en: '[PRE20]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'This command is similar to the one in [Listing 14-4](#list14-4), but because
    it uses <samp class="SANS_TheSansMonoCd_W5Regular_11">.meta.userindex[4]</samp>,
    it selects the value at index <samp class="SANS_TheSansMonoCd_W5Regular_11">4</samp>
    of the <samp class="SANS_TheSansMonoCd_W5Regular_11">.meta.userindex</samp> array
    and just displays that result. My output showed that this value was the string
    <samp class="SANS_TheSansMonoCd_W5Regular_11">289851780521787392</samp>, an 18-digit
    user ID:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 这个命令类似于[列表 14-4](#list14-4)中的命令，但因为它使用了 <samp class="SANS_TheSansMonoCd_W5Regular_11">.meta.userindex[4]</samp>，它选择了
    <samp class="SANS_TheSansMonoCd_W5Regular_11">.meta.userindex</samp> 数组中索引为 <samp
    class="SANS_TheSansMonoCd_W5Regular_11">4</samp> 的值，并且只显示那个结果。我的输出显示这个值是字符串 <samp
    class="SANS_TheSansMonoCd_W5Regular_11">289851780521787392</samp>，一个 18 位的用户 ID：
- en: '[PRE21]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Now that I had a user ID, I used it in the following command to find the matching
    username:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我有了一个用户 ID，我在以下命令中使用它来找到匹配的用户名：
- en: '[PRE22]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Like the previous command, this command selects just one value to output. In
    this case, it selects the <samp class="SANS_TheSansMonoCd_W5Regular_11">meta</samp>
    key, then the <samp class="SANS_TheSansMonoCd_W5Regular_11">users</samp> key,
    then the <samp class="SANS_TheSansMonoCd_W5Regular_11">289851780521787392</samp>
    key. The result is an object that includes a <samp class="SANS_TheSansMonoCd_W5Regular_11">name</samp>
    key:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 与前面的命令类似，这个命令只选择一个值进行输出。在这个例子中，它选择了 <samp class="SANS_TheSansMonoCd_W5Regular_11">meta</samp>
    键，然后是 <samp class="SANS_TheSansMonoCd_W5Regular_11">users</samp> 键，再是 <samp class="SANS_TheSansMonoCd_W5Regular_11">289851780521787392</samp>
    键。结果是一个包含 <samp class="SANS_TheSansMonoCd_W5Regular_11">name</samp> 键的对象：
- en: '[PRE23]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: The name *badtanman* was the username I was looking for.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: '*badtanman* 是我正在寻找的用户名。'
- en: 'In the chat logs quoted in [Listing 14-6](#list14-6), the user *badtanman*
    is talking to someone with the <samp class="SANS_TheSansMonoCd_W5Regular_11">u</samp>
    value of <samp class="SANS_TheSansMonoCd_W5Regular_11">1</samp>. To find that
    person’s username, I ran the same commands, substituting the appropriate ID numbers:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 在[列表 14-6](#list14-6)中引用的聊天记录中，用户 *badtanman* 正在与 <samp class="SANS_TheSansMonoCd_W5Regular_11">u</samp>
    值为 <samp class="SANS_TheSansMonoCd_W5Regular_11">1</samp> 的人交谈。为了找到那个人的用户名，我运行了相同的命令，并替换了相应的
    ID 数字：
- en: '[PRE24]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: I’d found that the snippet of chat messages in [Listing 14-6](#list14-6) was
    a conversation between *badtanman* and *northern_confederate* on the night of
    August 31, 2017.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 我发现，[列表 14-6](#list14-6) 中的聊天记录片段是 *badtanman* 和 *northern_confederate* 于 2017
    年 8 月 31 日晚上的对话。
- en: Running all of these <samp class="SANS_TheSansMonoCd_W5Regular_11">jq</samp>
    commands, along with running code in the Python interpreter to convert timestamps,
    is tedious. If confronted with a large volume of chat logs, you don’t want to
    research every group of messages this way. But when you’re exploring an unfamiliar
    dataset for the first time, you need to manually explore it like this until you
    better understand how the data is structured. After doing this preliminary analysis,
    I could use my new understanding of the chat logs to write Python scripts or even
    a full custom app (like I ended up developing for this dataset) to aid my research.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 执行所有这些 <samp class="SANS_TheSansMonoCd_W5Regular_11">jq</samp> 命令，并在 Python
    解释器中运行代码以转换时间戳，确实很繁琐。如果面对大量的聊天记录，你不会想通过这种方式逐一研究每一组消息。但当你首次探索一个陌生的数据集时，你需要像这样手动探索，直到更好地理解数据的结构。在做完这个初步分析后，我就可以利用对聊天记录的新理解编写
    Python 脚本，甚至开发一个完整的自定义应用程序（就像我最终为这个数据集开发的那样）来辅助我的研究。
- en: Before I actually started writing Python code to more easily parse these chat
    logs, though, I noticed a file that I’d missed before in the Unicorn Riot ZIP
    file that might make researching this dataset a lot easier.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在我真正开始编写 Python 代码以更轻松地解析这些聊天记录之前，我注意到在 Unicorn Riot ZIP 文件中有一个我之前错过的文件，它可能会让研究这个数据集变得更加轻松。
- en: <samp class="SANS_Futura_Std_Bold_B_11">The Discord History Tracker</samp>
  id: totrans-102
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">Discord 历史跟踪器</samp>
- en: The ZIP file from my Unicorn Riot contact had dozens of files in it, most of
    them JSON files and PNG screenshots, along with a few folders containing other
    JSON files. I’d immediately zeroed in on the JSON files to analyze their data
    structure, but until now I hadn’t noticed the file *logviewer.html*. This was
    an HTML and JavaScript file that, when opened in a web browser, would allow me
    to load JSON chat log files and read through them.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 我从 Unicorn Riot 联系人处获得的 ZIP 文件中有几十个文件，其中大多数是 JSON 文件和 PNG 截图，还有一些文件夹包含其他 JSON
    文件。我立即将注意力集中在 JSON 文件上，分析它们的数据结构，但直到现在，我才注意到 *logviewer.html* 文件。这是一个 HTML 和 JavaScript
    文件，当在网页浏览器中打开时，它可以让我加载 JSON 聊天记录文件并阅读其中的内容。
- en: After talking with my Unicorn Riot contact, I learned that this local HTML file
    is part of a piece of open source software called Discord History Tracker. This
    software, not affiliated with Discord, lets users save an offline copy of everything
    they have access to in a given Discord server in JSON format. Antifascist activists
    used this software to exfiltrate chat logs from Vibrant Diversity, Charlottesville
    2.0, and other fascist-run Discord servers.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 与我的 Unicorn Riot 联系人交谈后，我了解到这个本地 HTML 文件是一个名为 Discord History Tracker 的开源软件的一部分。这个软件与
    Discord 没有任何关联，它允许用户以 JSON 格式保存他们在特定 Discord 服务器中可以访问的所有内容的离线副本。反法西斯活动家使用这个软件从
    Vibrant Diversity、Charlottesville 2.0 以及其他法西斯主导的 Discord 服务器中提取聊天记录。
- en: Discord History Tracker included two components. The main component was in charge
    of actually creating a backup of a Discord server. The user would load the Discord
    server in their web browser, open their developer tools, and copy and paste the
    Discord History Tracker JavaScript code into their browser’s console. This would
    then scrape all of the data in the Discord server and save a backup file in JSON
    format. The second component of Discord History Tracker was the *logviewer.html*
    file, which contained offline HTML software for viewing those backup files.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: Discord 历史跟踪器包括两个组件。主要组件负责实际创建 Discord 服务器的备份。用户需要在他们的网页浏览器中加载 Discord 服务器，打开开发者工具，并将
    Discord 历史跟踪器的 JavaScript 代码复制并粘贴到浏览器控制台中。这样就会抓取 Discord 服务器中的所有数据，并保存为 JSON 格式的备份文件。Discord
    历史跟踪器的第二个组件是 *logviewer.html* 文件，它包含了查看这些备份文件的离线 HTML 软件。
- en: '[Figure 14-1](#fig14-1) shows *logviewer.html* loaded in a web browser. In
    the screenshot, I’ve scrolled to the aforementioned messages between *badtanman*
    and *northern_confederate* from the #problematic_oven channel.'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 14-1](#fig14-1) 显示了在网页浏览器中加载的 *logviewer.html*。在截图中，我已经滚动到了 #problematic_oven
    频道中 *badtanman* 和 *northern_confederate* 之间的上述消息。'
- en: <samp class="SANS_Dogma_OT_Bold_B_21">NOTE</samp>
  id: totrans-107
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: <samp class="SANS_Dogma_OT_Bold_B_21">注意</samp>
- en: '*The screenshot in [Figure 14-1](#fig14-1) shows software from 2017\. The Discord
    History Tracker interface has changed considerably since then. Among other changes,
    it now saves the data in SQLite databases, rather than as JSON files, and you
    can view the logs in a desktop app instead of using the* logviewer.html *file.
    You can learn more about the software at* [https://dht.chylex.com](https://dht.chylex.com)*.*'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: '*[图14-1](#fig14-1)中的截图展示的是2017年的软件界面。自那时以来，Discord历史跟踪器的界面有了很大变化。除了其他变化，它现在将数据保存在SQLite数据库中，而不是JSON文件中，并且你可以在桌面应用程序中查看日志，而不再需要使用*
    logviewer.html *文件。你可以在* [https://dht.chylex.com](https://dht.chylex.com) *了解更多关于该软件的信息。*'
- en: '![A screenshot of the Discord log viewer web application, showing the chat
    logs from the #problematic_oven channel in the Vibrant Diversity Discord server.](Images/Figure14-1.png)'
  id: totrans-109
  prefs: []
  type: TYPE_IMG
  zh: '![Discord日志查看器网页应用程序的截图，显示来自Vibrant Diversity Discord服务器中的#problematic_oven频道的聊天记录。](Images/Figure14-1.png)'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 14-1: The August 31,
    2017, chat between</samp> <samp class="SANS_Futura_Std_Book_11">badtanman</samp>
    <samp class="SANS_Futura_Std_Book_Oblique_I_11">and</samp> <samp class="SANS_Futura_Std_Book_11">northern_confederate</samp><samp
    class="SANS_Futura_Std_Book_Oblique_I_11">, viewed in the Discord Offline History
    web app</samp>'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">图14-1：2017年8月31日，</samp> <samp
    class="SANS_Futura_Std_Book_11">badtanman</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">与</samp>
    <samp class="SANS_Futura_Std_Book_11">northern_confederate</samp><samp class="SANS_Futura_Std_Book_Oblique_I_11">的聊天记录，查看自Discord离线历史网页应用程序</samp>
- en: 'This offline HTML viewer software made it considerably easier to navigate and
    read the contents of the JSON files. I could click through the channels on the
    left, and then read through a page of chats at a time. However, it also lacked
    some features that would be important for my ongoing investigation:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 这个离线HTML查看器软件使得浏览和阅读JSON文件的内容变得更容易。我可以点击左侧的频道，然后一次性阅读一页聊天记录。然而，它也缺少一些对我持续调查很重要的功能：
- en: 'There was no simple way to search for individual messages. For example, suppose
    I wanted to search for mentions of Berkeley, the city I lived in at the time.
    I would have to click a channel like #general, use my web browser’s search feature
    to search for *Berkeley*, and then find which messages appeared in the #general
    channel. I would also need to change the settings to display all messages per
    page so I could search them all at once, rather than displaying just 1,000 messages
    at a time, as shown in [Figure 14-1](#fig14-1). I would then have to replicate
    this search for every other channel in the server, and if I wanted to search other
    Discord servers as well, I’d have to replicate it for each channel in each server.'
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 没有简单的方法来搜索单个消息。例如，假设我想搜索提到**伯克利**（我当时居住的城市）的消息。我必须点击像#general这样的频道，使用我浏览器的搜索功能搜索*Berkeley*，然后找出出现在#general频道中的哪些消息。我还需要更改设置，将每页显示的消息数量改为显示所有消息，这样我就能一次性搜索所有消息，而不是像[图14-1](#fig14-1)中所示，每次仅显示1,000条消息。然后，我还需要为服务器中的其他每个频道重复这个搜索，如果我还想搜索其他Discord服务器的消息，我就必须为每个服务器中的每个频道重复此操作。
- en: The offline viewer only supported looking at one server at a time, but I wanted
    to be able to search multiple servers at once and also track a single user’s messages
    across different servers.
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 离线查看器仅支持一次查看一个服务器，但我希望能够同时搜索多个服务器，并且能够追踪一个用户在不同服务器中的消息。
- en: There was no way to generate hyperlinks leading to individual messages. When
    you’re taking notes for a story based on chat logs like this, it’s helpful to
    track the messages of interest. Without links, you’ll regularly have to go back
    and search for specific messages all over again.
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 没有办法生成指向单个消息的超链接。当你根据聊天记录为故事做笔记时，能够追踪感兴趣的消息是非常有用的。如果没有链接，你就必须不断地回去重新搜索特定的消息。
- en: I decided to build my own web application to add these missing features. I already
    had all of the chat logs in a structured format, which is by far the biggest requirement
    to build a custom app, as you learned in [Chapter 10](chapter10.xhtml)’s discussion
    of BlueLeaks Explorer. If I’d had only screenshots of the Discord servers, a custom
    app with these features wouldn’t have been possible. Screenshots aren’t structured
    data, and there’s no easy way to write software that allows you to browse the
    chat messages they contain.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 我决定构建自己的Web应用程序，添加这些缺失的功能。我已经将所有的聊天记录按结构化格式整理好了，这也是构建自定义应用程序的最大前提条件，就像你在[第10章](chapter10.xhtml)中讨论BlueLeaks
    Explorer时学到的那样。如果我只有Discord服务器的截图，拥有这些功能的自定义应用程序将是不可能的。截图不是结构化数据，且没有简便的方式编写软件，让你浏览其中包含的聊天消息。
- en: <samp class="SANS_Futura_Std_Bold_B_11">A Script to Search the JSON Files</samp>
  id: totrans-116
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">一个用于搜索JSON文件的脚本</samp>
- en: As you’ve learned throughout this book, understanding how the data is structured
    is a prerequisite to writing code that works with it. Therefore, I decided to
    use the knowledge I’d gained from manually investigating the JSON files with <samp
    class="SANS_TheSansMonoCd_W5Regular_11">jq</samp> to build a simple Python script
    that let me search one of the JSON files for keywords. Initially I thought I might
    be able to use this script to do all of the analysis I needed, but that turned
    out to be wrong; I ended up writing a complete custom app to investigate this
    dataset as well. Even so, this first (considerably simpler) script allowed me
    to use Python code to express the structure of the dataset that I’d already gleaned,
    which simplified the process of programming the full web app. In this section
    I go over exactly how my initial Discord JSON search script worked.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你在本书中学到的，理解数据的结构是编写能够与其交互的代码的前提。因此，我决定利用通过手动调查JSON文件获得的知识，使用<samp class="SANS_TheSansMonoCd_W5Regular_11">jq</samp>构建一个简单的Python脚本，允许我在其中一个JSON文件中搜索关键词。最初我认为这个脚本可以完成我所有需要的分析工作，但结果证明这是错误的；我最终还是写了一个完整的自定义应用程序来调查这个数据集。尽管如此，这个初始的（相对简单的）脚本使我能够使用Python代码表达我已经掌握的数据集结构，从而简化了编写完整Web应用程序的过程。在这一部分，我将详细介绍我的初始Discord
    JSON搜索脚本是如何工作的。
- en: 'For example, I knew my script needed to be able to display chat messages based
    on what I searched for. Let’s say I wanted my code to display the following chat
    message from [Listing 14-6](#list14-6):'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，我知道我的脚本需要能够根据我搜索的内容显示聊天消息。假设我希望我的代码显示来自[Listing 14-6](#list14-6)的以下聊天消息：
- en: '[PRE25]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'The value of the <samp class="SANS_TheSansMonoCd_W5Regular_11">u</samp> key
    is <samp class="SANS_TheSansMonoCd_W5Regular_11">4</samp>, but now I knew how
    to find the actual username of the person who posted this message. First, my code
    needed to look in the JSON’s <samp class="SANS_TheSansMonoCd_W5Regular_11">meta</samp>
    object and select the fourth item in the <samp class="SANS_TheSansMonoCd_W5Regular_11">userindex</samp>
    array, which is the user ID <samp class="SANS_TheSansMonoCd_W5Regular_11">289851780521787392</samp>.
    My code then would look again in the JSON’s <samp class="SANS_TheSansMonoCd_W5Regular_11">meta</samp>
    object, this time for the <samp class="SANS_TheSansMonoCd_W5Regular_11">users</samp>
    key, and use that user ID as the key to get this user object:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W5Regular_11">u</samp>键的值是<samp class="SANS_TheSansMonoCd_W5Regular_11">4</samp>，但现在我知道如何找到发布此消息的人的实际用户名。首先，我的代码需要在JSON的<samp
    class="SANS_TheSansMonoCd_W5Regular_11">meta</samp>对象中查找，并选择<samp class="SANS_TheSansMonoCd_W5Regular_11">userindex</samp>数组中的第四个项，这是用户ID
    <samp class="SANS_TheSansMonoCd_W5Regular_11">289851780521787392</samp>。然后，我的代码会再次查找JSON中的<samp
    class="SANS_TheSansMonoCd_W5Regular_11">meta</samp>对象，这次查找<samp class="SANS_TheSansMonoCd_W5Regular_11">users</samp>键，并使用该用户ID作为键来获取该用户对象：
- en: '[PRE26]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: My code would select the <samp class="SANS_TheSansMonoCd_W5Regular_11">name</samp>
    string from that object to get the username of the message poster, <samp class="SANS_TheSansMonoCd_W5Regular_11">badtanman</samp>,
    and then replicate the whole process to display the correct username for every
    message.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 我的代码会从该对象中选择<samp class="SANS_TheSansMonoCd_W5Regular_11">name</samp>字符串，获取消息发布者的用户名<samp
    class="SANS_TheSansMonoCd_W5Regular_11">badtanman</samp>，然后复制整个过程，显示每条消息的正确用户名。
- en: 'I opened my text editor and started writing a Python script, *discord-json
    -search.py*, to search one of the JSON files for keywords. Here’s my completed
    source code (you can also find it at [*https://<wbr>github<wbr>.com<wbr>/micahflee<wbr>/hacks<wbr>-leaks<wbr>-and<wbr>-revelations<wbr>/blob<wbr>/main<wbr>/chapter<wbr>-14<wbr>/discord<wbr>-analysis<wbr>/discord<wbr>-json<wbr>-search<wbr>.py*](https://github.com/micahflee/hacks-leaks-and-revelations/blob/main/chapter-14/discord-analysis/discord-json-search.py)):'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 我打开了文本编辑器，并开始编写一个Python脚本，*discord-json -search.py*，用于在其中一个JSON文件中搜索关键词。以下是我完成的源代码（你也可以在[*https://<wbr>github<wbr>.com<wbr>/micahflee<wbr>/hacks<wbr>-leaks<wbr>-and<wbr>-revelations<wbr>/blob<wbr>/main<wbr>/chapter<wbr>-14<wbr>/discord<wbr>-analysis<wbr>/discord<wbr>-json<wbr>-search<wbr>.py*](https://github.com/micahflee/hacks-leaks-and-revelations/blob/main/chapter-14/discord-analysis/discord-json-search.py)中找到它）：
- en: '[PRE27]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'It’s simplest to explain how this script worked from bottom to top, since that’s
    how it executed and also how I programmed it. The <samp class="SANS_TheSansMonoCd_W5Regular_11">main()</samp>
    function ❽ is a Click command that takes two arguments: the filename for a JSON
    file with Discord chat logs called <samp class="SANS_TheSansMonoCd_W5Regular_11">filename</samp>,
    and a search term called <samp class="SANS_TheSansMonoCd_W5Regular_11">query</samp>.
    The code opened the filename that was passed in and parsed it using <samp class="SANS_TheSansMonoCd_W5Regular_11">json.loads()</samp>
    to turn it into a JSON object. Then it called the <samp class="SANS_TheSansMonoCd_W5Regular_11">search()</samp>
    function, passing in the data from the JSON file and the search query.'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 从下到上解释这个脚本是最简单的，因为它就是这样执行的，也是我编写它的方式。<samp class="SANS_TheSansMonoCd_W5Regular_11">main()</samp>
    函数 ❽ 是一个Click命令，接受两个参数：一个名为 <samp class="SANS_TheSansMonoCd_W5Regular_11">filename</samp>
    的JSON文件，包含Discord聊天记录；另一个是名为 <samp class="SANS_TheSansMonoCd_W5Regular_11">query</samp>
    的搜索词。代码打开传入的文件名，并使用 <samp class="SANS_TheSansMonoCd_W5Regular_11">json.loads()</samp>
    解析它，将其转换为JSON对象。然后它调用 <samp class="SANS_TheSansMonoCd_W5Regular_11">search()</samp>
    函数，传入来自JSON文件的数据和搜索查询。
- en: 'The <samp class="SANS_TheSansMonoCd_W5Regular_11">search()</samp> function
    ❸ is where all the magic happened. I knew from my previous analysis that these
    Discord JSON objects had two keys: the <samp class="SANS_TheSansMonoCd_W5Regular_11">data</samp>
    key, which contained the messages in each channel, and the <samp class="SANS_TheSansMonoCd_W5Regular_11">meta</samp>
    key, which contained metadata about these messages. My script started by looping
    through every channel in <samp class="SANS_TheSansMonoCd_W5Regular_11">data[''data'']</samp>
    ❹, then using its <samp class="SANS_TheSansMonoCd_W5Regular_11">channel_id</samp>
    to look up that channel’s name and server in the metadata ❺. It then looped through
    every message in that channel ❻ and stored the message’s username, timestamp,
    and the message itself in variables.'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W5Regular_11">search()</samp> 函数 ❸ 是所有“魔法”发生的地方。从我之前的分析中，我知道这些Discord
    JSON对象有两个键：<samp class="SANS_TheSansMonoCd_W5Regular_11">data</samp> 键，它包含每个频道的消息，以及
    <samp class="SANS_TheSansMonoCd_W5Regular_11">meta</samp> 键，它包含这些消息的元数据。我的脚本首先通过循环遍历
    <samp class="SANS_TheSansMonoCd_W5Regular_11">data['data']</samp> ❹ 中的每个频道，然后使用它的
    <samp class="SANS_TheSansMonoCd_W5Regular_11">channel_id</samp> 查找该频道的名称和服务器的元数据
    ❺。接着，它遍历该频道中的每一条消息 ❻，并将消息的用户名、时间戳和消息内容存储在变量中。
- en: The code then checked to see if the search query that was passed into the script
    as a CLI argument (stored in <samp class="SANS_TheSansMonoCd_W5Regular_11">query</samp>)
    existed in the message (stored in <samp class="SANS_TheSansMonoCd_W5Regular_11">message</samp>)
    ❼. As described in [Chapter 7](chapter7.xhtml), it converted both strings to lowercase
    using the <samp class="SANS_TheSansMonoCd_W5Regular_11">lower()</samp> method
    to make the search case insensitive. If the lowercase version of the message contained
    the lowercase version of the search term, the script then passed all of the relevant
    variables into the <samp class="SANS_TheSansMonoCd_W5Regular_11">display()</samp>
    function to display the message in the terminal.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，代码检查传递给脚本的搜索查询（存储在 <samp class="SANS_TheSansMonoCd_W5Regular_11">query</samp>
    中）是否存在于消息（存储在 <samp class="SANS_TheSansMonoCd_W5Regular_11">message</samp> 中）
    ❼。正如在[第7章](chapter7.xhtml)中所述，它使用 <samp class="SANS_TheSansMonoCd_W5Regular_11">lower()</samp>
    方法将两个字符串转换为小写，从而使搜索不区分大小写。如果消息的小写版本包含搜索词的小写版本，脚本就会将所有相关变量传递给 <samp class="SANS_TheSansMonoCd_W5Regular_11">display()</samp>
    函数，以在终端显示该消息。
- en: The <samp class="SANS_TheSansMonoCd_W5Regular_11">display()</samp> function
    ❷ took arguments for metadata about a message, the message text itself, and the
    search term and used those to display the message. This code used <samp class="SANS_TheSansMonoCd_W5Regular_11">click.echo()</samp>
    instead of <samp class="SANS_TheSansMonoCd_W5Regular_11">print()</samp> to display
    text to the terminal, and it used <samp class="SANS_TheSansMonoCd_W5Regular_11">click.style()</samp>
    to apply different colors and formatting. (You could do all of this just with
    the <samp class="SANS_TheSansMonoCd_W5Regular_11">print()</samp> function, but
    the <samp class="SANS_TheSansMonoCd_W5Regular_11">click</samp> module makes it
    simpler to style terminal output.) After displaying two lines of metadata for
    the message, the script then displayed the output of the <samp class="SANS_TheSansMonoCd_W5Regular_11">highlight()</samp>
    function, which returned the message itself in color with the search term underlined.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: '`<samp class="SANS_TheSansMonoCd_W5Regular_11">display()</samp>` 函数 ❷ 接受关于消息的元数据、消息文本本身和搜索词的参数，并利用这些参数显示消息。此代码使用
    `<samp class="SANS_TheSansMonoCd_W5Regular_11">click.echo()</samp>` 替代 `<samp
    class="SANS_TheSansMonoCd_W5Regular_11">print()</samp>` 来显示终端文本，并使用 `<samp class="SANS_TheSansMonoCd_W5Regular_11">click.style()</samp>`
    来应用不同的颜色和格式。 (你也可以仅使用 `<samp class="SANS_TheSansMonoCd_W5Regular_11">print()</samp>`
    函数来实现这一点，但 `<samp class="SANS_TheSansMonoCd_W5Regular_11">click</samp>` 模块使得终端输出的样式更为简便。)
    在显示了消息的两行元数据后，脚本接着显示了 `<samp class="SANS_TheSansMonoCd_W5Regular_11">highlight()</samp>`
    函数的输出，该函数将消息以带颜色的形式返回，并将搜索词加下划线。'
- en: The <samp class="SANS_TheSansMonoCd_W5Regular_11">highlight()</samp> function
    ❶ created an empty string called <samp class="SANS_TheSansMonoCd_W5Regular_11">new_message</samp>
    and then made it a copy of <samp class="SANS_TheSansMonoCd_W5Regular_11">message</samp>,
    the original message it displayed, except with all instances of the search term
    underlined using <samp class="SANS_TheSansMonoCd_W5Regular_11">click.style()</samp>.
    It then returned <samp class="SANS_TheSansMonoCd_W5Regular_11">new_message</samp>
    and displayed it to the terminal in the <samp class="SANS_TheSansMonoCd_W5Regular_11">display()</samp>
    function.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: '`<samp class="SANS_TheSansMonoCd_W5Regular_11">highlight()</samp>` 函数 ❶ 创建了一个名为
    `<samp class="SANS_TheSansMonoCd_W5Regular_11">new_message</samp>` 的空字符串，然后将它设置为
    `<samp class="SANS_TheSansMonoCd_W5Regular_11">message</samp>` 的副本，显示的原始消息，除了搜索词的所有实例都使用
    `<samp class="SANS_TheSansMonoCd_W5Regular_11">click.style()</samp>` 被加上了下划线。然后它返回
    `<samp class="SANS_TheSansMonoCd_W5Regular_11">new_message</samp>` 并在 `<samp class="SANS_TheSansMonoCd_W5Regular_11">display()</samp>`
    函数中显示给终端。'
- en: 'For example, if I wanted to search *VibrantDiversity.json* for the term *berkeley*,
    I could run:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果我想在 *VibrantDiversity.json* 中搜索 *berkeley*，我可以运行：
- en: '[PRE28]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'The output listed over a hundred chat messages that mentioned Berkeley. Each
    message showed the name of the channel, the name of the Discord server, the user
    who posted it and when, and the content of the message. Here’s the first snippet
    of output, which highlighted the search term in the message with an underline:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 输出列出了上百条提到 Berkeley 的聊天消息。每条消息显示了频道的名称、Discord 服务器的名称、发布者的用户名和时间，以及消息的内容。以下是第一段输出，它在消息中将搜索词加了下划线：
- en: '[PRE29]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'The first message that mentioned Berkeley was a post from the user *Hector*
    in the #general channel on September 3, 2017\. This user was complaining about
    the relatively small number of fascists that showed up to their rallies in Boston
    and Berkeley, compared to the “antifa” counterprotesters.'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: '第一条提到 Berkeley 的消息是 2017 年 9 月 3 日 *Hector* 用户在 #general 频道中的一条帖子。该用户抱怨与“antifa”反对抗议者相比，波士顿和
    Berkeley 的集会中出现的法西斯主义者人数相对较少。'
- en: 'This script allowed me to search a full Discord server for keywords, but it
    still lacked several of the features that I wanted: it could work with only one
    Discord leak at a time, and there was no easy way to browse through and read the
    data sequentially or to save links to specific interesting messages. I started
    building out a web application to help me perform these missing tasks.'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 这个脚本让我能够在整个 Discord 服务器中搜索关键词，但它仍然缺乏我想要的几个功能：它一次只能处理一个 Discord 泄漏，并且没有简便的方法浏览和按顺序阅读数据，或者保存特定有趣消息的链接。我开始构建一个
    web 应用程序，帮助我完成这些缺失的任务。
- en: <samp class="SANS_Futura_Std_Bold_B_11">My Discord Analysis Code</samp>
  id: totrans-136
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">我的 Discord 分析代码</samp>
- en: I’ve found that after obtaining a large dataset full of structured data, building
    a custom web application to explore it, as I did with BlueLeaks Explorer, makes
    it much easier to find its hidden revelations. After writing *discord-json -search.py*,
    I spent about a week creating Discord Analysis, a custom web app to analyze leaked
    Discord chat logs.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 我发现，在获得一个包含大量结构化数据的数据集后，像我在BlueLeaks Explorer中做的那样，构建一个自定义网页应用来探索数据，能更轻松地发现其中隐藏的启示。在编写*discord-json
    -search.py*后，我花了大约一周时间创建了Discord分析工具，一个自定义网页应用，用于分析泄露的Discord聊天记录。
- en: Since I wanted to be able to search multiple Discord servers at once, I decided
    that the best solution would be to convert all of the data from JSON files into
    a SQL database. I used a Python tech stack that I was already familiar with, Flask
    (discussed briefly in [Chapter 10](chapter10.xhtml)), for the web app and SQLAlchemy
    for communicating with the SQL database.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我希望能够同时搜索多个Discord服务器，我决定最好的解决方案是将所有数据从JSON文件转换成SQL数据库。我使用了自己已经熟悉的Python技术栈，Flask（在[第10章](chapter10.xhtml)中简要讨论）用于网页应用，SQLAlchemy用于与SQL数据库通信。
- en: SQLAlchemy is an *Object Relational Mapping (ORM)* Python module that’s useful
    for making code that works with SQL databases simpler to write and more secure.
    ORMs allow you to work with SQL databases in such a way that you don’t have to
    directly write any SQL code yourself, which means your projects won’t be vulnerable
    to SQL injection. This web app used Flask-SQLAlchemy, a Flask extension that adds
    SQLAlchemy support to Flask apps.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: SQLAlchemy是一个*对象关系映射（ORM）*的Python模块，能够简化编写与SQL数据库交互的代码，并提高安全性。ORM允许你以无需直接编写SQL代码的方式与SQL数据库交互，这意味着你的项目不会容易受到SQL注入攻击。这个网页应用使用了Flask-SQLAlchemy，这是一个将SQLAlchemy支持添加到Flask应用中的Flask扩展。
- en: 'While developing my Discord Analysis web app, I was actively using it to research
    the leaked neo-Nazi chat logs. If I had new questions about the data (like what
    other messages a user posted) or found that I needed new features (like limiting
    my search to a single server), I would program them in as I went along. This is
    typically how I build research tools: I start using them long before they’re complete,
    and I let the direction of my research guide which features I add next.'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 在开发我的Discord分析网页应用时，我积极使用它来研究泄露的neo-Nazi聊天记录。如果我对数据有了新的问题（比如某个用户发布了哪些其他消息），或者发现需要新的功能（比如将搜索限制在单个服务器内），我就会在过程中直接编写相应的功能。这通常是我构建研究工具的方式：在工具还未完成之前，我就开始使用它，并让我的研究方向指导我接下来添加的功能。
- en: 'In this section, I explain how I went about developing the different components
    of the app: designing a SQL database, importing chat logs from the Discord JSON
    files into that database, and building the web interface to research the chat
    logs. You’ll learn how I used SQLAlchemy to define database tables, insert rows
    into them, and select rows from them. You’ll also learn how I used Flask to build
    this web app, including how to make Jinja templates and how to define routes—skills
    you’ll need if you build your own Flask web apps in the future.'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我将解释如何开发应用的不同组件：设计SQL数据库、将Discord JSON文件中的聊天记录导入到数据库中，以及构建网页界面来研究这些聊天记录。你将学习如何使用SQLAlchemy定义数据库表，向表中插入行，并从表中选择行。你还将学习如何使用Flask构建这个网页应用，包括如何制作Jinja模板以及如何定义路由——这些技能对你未来构建自己的Flask网页应用非常重要。
- en: <samp class="SANS_Dogma_OT_Bold_B_21">NOTE</samp>
  id: totrans-142
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: <samp class="SANS_Dogma_OT_Bold_B_21">注意</samp>
- en: '*Fully explaining how to build a Flask and SQLAlchemy web app is outside the
    scope of this book. Instead, I go over how I went about building this app in broad
    strokes, which should still be useful if you ever decide to build a similar one
    yourself. The best way to learn how to make your own Flask app is by exploring
    Flask’s excellent documentation at* [https://flask.palletsprojects.com](https://flask.palletsprojects.com)*;*
    *that’s how I learned. The Flask documentation includes a tutorial that walks
    you through every step of developing* *a simple web app. The Python skills you’ve
    learned from [Chapters 7](chapter7.xhtml) and [8](chapter8.xhtml) are more than
    enough for you to follow along with the tutorial. You can also find docs for SQLAlchemy
    at* [https://<wbr>www<wbr>.sqlalchemy<wbr>.org](https://www.sqlalchemy.org) *and
    for Flask’s SQLAlchemy extension at* [https://flask-sqlalchemy.palletsprojects.com](https://flask-sqlalchemy.palletsprojects.com)*.*'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: '*完全解释如何构建一个 Flask 和 SQLAlchemy 的 web 应用程序超出了本书的范围。相反，我将大致讲述我如何构建这个应用程序的过程，这对你如果将来决定构建类似的应用程序依然会有帮助。学习如何制作自己的
    Flask 应用程序的最佳方式是通过探索 Flask 的优秀文档，* [https://flask.palletsprojects.com](https://flask.palletsprojects.com)*；*
    *那就是我学习的方式。Flask 文档包括一个教程，带你逐步开发一个简单的 web 应用程序。你在 [第7章](chapter7.xhtml) 和 [第8章](chapter8.xhtml)
    学到的 Python 技能足以让你跟随教程的步骤。你还可以在* [https://<wbr>www<wbr>.sqlalchemy<wbr>.org](https://www.sqlalchemy.org)
    *找到 SQLAlchemy 的文档，并在* [https://flask-sqlalchemy.palletsprojects.com](https://flask-sqlalchemy.palletsprojects.com)*
    找到 Flask 的 SQLAlchemy 扩展的文档。*'
- en: The code for Discord Analysis, which has quietly been public on my GitHub account
    for years, hasn’t been updated much since 2017, with the exception of some small
    changes I made when preparing it for this book. I don’t plan on maintaining it.
    Still, you should be able to get it running locally if you’d like to explore it
    further, and you can use it as inspiration for your own future projects that use
    a similar tech stack. Read through this section to see how it works, and then
    if you’re curious, try getting it running locally yourself.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: Discord 分析的代码已经悄悄地在我的 GitHub 账户上公开多年，自2017年以来没有太多更新，除了我为本书做准备时进行的一些小改动。我并不打算继续维护它。不过，如果你想深入探索，它应该能在本地运行，并且你可以将它作为你自己未来使用类似技术栈的项目的灵感来源。阅读这一节，了解它是如何工作的，如果你感兴趣，可以尝试自己在本地运行它。
- en: As I explain the app, I’ll quote sections of the source code. It’s too long
    to include all of it here, but you can find the full code online in the book’s
    GitHub repository at [*https://<wbr>github<wbr>.com<wbr>/micahflee<wbr>/hacks<wbr>-leaks<wbr>-and<wbr>-revelations<wbr>/tree<wbr>/main<wbr>/chapter<wbr>-14<wbr>/discord<wbr>-analysis*](https://github.com/micahflee/hacks-leaks-and-revelations/tree/main/chapter-14/discord-analysis).
    I recommend that you pull up the full source code for each file as I describe
    how it works.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 在解释应用程序时，我会引用一些源代码片段。源代码太长，不能在这里全部展示，但你可以在本书的 GitHub 仓库中找到完整的代码，地址是 [*https://<wbr>github<wbr>.com<wbr>/micahflee<wbr>/hacks<wbr>-leaks<wbr>-and<wbr>-revelations<wbr>/tree<wbr>/main<wbr>/chapter<wbr>-14<wbr>/discord<wbr>-analysis*](https://github.com/micahflee/hacks-leaks-and-revelations/tree/main/chapter-14/discord-analysis)。我建议你在我描述代码如何工作时，查看每个文件的完整源代码。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Designing the SQL
    Database</samp>
  id: totrans-146
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">设计 SQL 数据库</samp>
- en: 'I started my web app with a Python script called *app.py*. You can find the
    full source code for this file at [*https://<wbr>github<wbr>.com<wbr>/micahflee<wbr>/hacks<wbr>-leaks<wbr>-and<wbr>-revelations<wbr>/blob<wbr>/main<wbr>/chapter<wbr>-14<wbr>/discord<wbr>-analysis<wbr>/app<wbr>.py*](https://github.com/micahflee/hacks-leaks-and-revelations/blob/main/chapter-14/discord-analysis/app.py).
    First, my code imported the appropriate Flask and SQLAlchemy modules, created
    a new Flask app object called <samp class="SANS_TheSansMonoCd_W5Regular_11">app</samp>,
    and created a new Flask-SQLAlchemy object called <samp class="SANS_TheSansMonoCd_W5Regular_11">db</samp>:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 我从一个名为 *app.py* 的 Python 脚本开始构建我的 web 应用程序。你可以在 [*https://<wbr>github<wbr>.com<wbr>/micahflee<wbr>/hacks<wbr>-leaks<wbr>-and<wbr>-revelations<wbr>/blob<wbr>/main<wbr>/chapter<wbr>-14<wbr>/discord<wbr>-analysis<wbr>/app<wbr>.py*](https://github.com/micahflee/hacks-leaks-and-revelations/blob/main/chapter-14/discord-analysis/app.py)
    找到该文件的完整源代码。首先，我的代码导入了适当的 Flask 和 SQLAlchemy 模块，创建了一个新的 Flask 应用程序对象，命名为 <samp
    class="SANS_TheSansMonoCd_W5Regular_11">app</samp>，并创建了一个新的 Flask-SQLAlchemy 对象，命名为
    <samp class="SANS_TheSansMonoCd_W5Regular_11">db</samp>：
- en: '[PRE30]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: I started by importing several items from the <samp class="SANS_TheSansMonoCd_W5Regular_11">flask</samp>
    module, like <samp class="SANS_TheSansMonoCd_W5Regular_11">Flask</samp> and <samp
    class="SANS_TheSansMonoCd_W5Regular_11">render_template</samp>, that I knew I’d
    need later in the program. In the next line, I also imported <samp class="SANS_TheSansMonoCd_W5Regular_11">SQLAlchemy</samp>
    from the <samp class="SANS_TheSansMonoCd_W5Regular_11">flask_sqlalchemy</samp>
    module.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 我首先从<samp class="SANS_TheSansMonoCd_W5Regular_11">flask</samp>模块中导入了几个我知道以后会用到的项目，例如<samp
    class="SANS_TheSansMonoCd_W5Regular_11">Flask</samp>和<samp class="SANS_TheSansMonoCd_W5Regular_11">render_template</samp>。在接下来的代码行中，我还从<samp
    class="SANS_TheSansMonoCd_W5Regular_11">flask_sqlalchemy</samp>模块中导入了<samp class="SANS_TheSansMonoCd_W5Regular_11">SQLAlchemy</samp>。
- en: Using the newly imported <samp class="SANS_TheSansMonoCd_W5Regular_11">Flask</samp>,
    I then created a Flask object called <samp class="SANS_TheSansMonoCd_W5Regular_11">app</samp>.
    Every Flask web app includes such an object (and usually by that name) to define
    exactly how the app will work. I modified the <samp class="SANS_TheSansMonoCd_W5Regular_11">app.config</samp>
    dict to set some configuration settings, telling it that I wanted to use a SQLite3
    database stored in the file *database.sqlite3*, and I wanted to turn debug mode
    on, which is useful while you’re actively developing a web app. Finally, I created
    the SQLAlchemy object called <samp class="SANS_TheSansMonoCd_W5Regular_11">db</samp>,
    passing in <samp class="SANS_TheSansMonoCd_W5Regular_11">app</samp>.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 使用新导入的<samp class="SANS_TheSansMonoCd_W5Regular_11">Flask</samp>，我创建了一个名为<samp
    class="SANS_TheSansMonoCd_W5Regular_11">app</samp>的Flask对象。每个Flask web应用都会包含这样一个对象（通常是这个名字），用来准确地定义应用如何工作。我修改了<samp
    class="SANS_TheSansMonoCd_W5Regular_11">app.config</samp>字典，设置了一些配置项，告诉它我要使用存储在文件*database.sqlite3*中的SQLite3数据库，并且希望开启调试模式，这在开发web应用时非常有用。最后，我创建了一个名为<samp
    class="SANS_TheSansMonoCd_W5Regular_11">db</samp>的SQLAlchemy对象，并将<samp class="SANS_TheSansMonoCd_W5Regular_11">app</samp>传入其中。
- en: 'For the next bit of code, I’ll introduce you to a new Python concept that I
    didn’t explicitly cover in [Part III](part3.xhtml) but that you’ve technically
    been using all along: classes. In Python, a *class* is a template for creating
    new objects that can store data (using variables called *attributes*) and perform
    actions (using functions called *methods*). For example, strings are technically
    classes. When you run the code <samp class="SANS_TheSansMonoCd_W5Regular_11">s</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">=</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">"example"</samp>,
    the variable <samp class="SANS_TheSansMonoCd_W5Regular_11">s</samp> is an instance
    of the string class, the data it stores is the string <samp class="SANS_TheSansMonoCd_W5Regular_11">example</samp>,
    and it has a bunch of methods you can call on it, such as <samp class="SANS_TheSansMonoCd_W5Regular_11">s.upper()</samp>,
    which returns an uppercase version of the string. When you write SQLAlchemy code,
    you define a class for each database table. This way, you can write code that
    works with Python objects without needing to write the SQL queries yourself.'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的代码部分，我将向你介绍一个新的Python概念，虽然我在[第三部分](part3.xhtml)中没有明确讲解，但你实际上一直在使用：类。在Python中，*类*是创建新对象的模板，这些对象可以存储数据（使用称为*属性*的变量）并执行操作（使用称为*方法*的函数）。例如，字符串本质上是类。当你运行代码<samp
    class="SANS_TheSansMonoCd_W5Regular_11">s</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">=</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">"example"</samp>时，变量<samp class="SANS_TheSansMonoCd_W5Regular_11">s</samp>是字符串类的一个实例，它存储的数据是字符串<samp
    class="SANS_TheSansMonoCd_W5Regular_11">example</samp>，并且它有很多可以调用的方法，比如<samp class="SANS_TheSansMonoCd_W5Regular_11">s.upper()</samp>，它会返回字符串的大写版本。当你编写SQLAlchemy代码时，你会为每个数据库表定义一个类。通过这种方式，你可以编写与Python对象交互的代码，而无需自己编写SQL查询。
- en: 'I started writing code to define the SQL tables that would store Discord data
    for servers, users, channels, and messages. For example, the following code defines
    the <samp class="SANS_TheSansMonoCd_W5Regular_11">Server</samp> class, which represents
    the SQL table to store data about servers:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 我开始编写代码，定义存储Discord数据的SQL表，这些数据包括服务器、用户、频道和消息。例如，以下代码定义了<samp class="SANS_TheSansMonoCd_W5Regular_11">Server</samp>类，它代表了存储服务器数据的SQL表：
- en: '[PRE31]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Using SQLAlchemy requires that you define your own classes. You can think of
    this <samp class="SANS_TheSansMonoCd_W5Regular_11">Server</samp> class as a description
    of a new type of Python object that represents a row in the server SQL table.
    Because I defined it as <samp class="SANS_TheSansMonoCd_W5Regular_11">Server(db
    .Model)</samp>, this class inherited all of the functionality of the <samp class="SANS_TheSansMonoCd_W5Regular_11">db.Model</samp>
    class, which is part of SQLAlchemy. Inside the class definition, I defined the
    table’s columns: <samp class="SANS_TheSansMonoCd_W5Regular_11">id</samp> (an auto-incrementing
    number) and <samp class="SANS_TheSansMonoCd_W5Regular_11">name</samp> (a string).
    Next, I defined this table’s relationships to other tables, in this case relating
    <samp class="SANS_TheSansMonoCd_W5Regular_11">servers</samp> to <samp class="SANS_TheSansMonoCd_W5Regular_11">channels</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">messages</samp>—both the <samp
    class="SANS_TheSansMonoCd_W5Regular_11">Channel</samp> table and the <samp class="SANS_TheSansMonoCd_W5Regular_11">Message</samp>
    table have a <samp class="SANS_TheSansMonoCd_W5Regular_11">server_id</samp> column.'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 使用SQLAlchemy要求你定义自己的类。你可以将这个<samp class="SANS_TheSansMonoCd_W5Regular_11">Server</samp>类看作是一个描述新类型Python对象的定义，该对象代表服务器SQL表中的一行。因为我将其定义为<samp
    class="SANS_TheSansMonoCd_W5Regular_11">Server(db.Model)</samp>，所以这个类继承了SQLAlchemy中<samp
    class="SANS_TheSansMonoCd_W5Regular_11">db.Model</samp>类的所有功能。在类定义内部，我定义了表的列：<samp
    class="SANS_TheSansMonoCd_W5Regular_11">id</samp>（一个自动递增的数字）和<samp class="SANS_TheSansMonoCd_W5Regular_11">name</samp>（一个字符串）。接下来，我定义了该表与其他表的关系，在这种情况下将<samp
    class="SANS_TheSansMonoCd_W5Regular_11">servers</samp>与<samp class="SANS_TheSansMonoCd_W5Regular_11">channels</samp>和<samp
    class="SANS_TheSansMonoCd_W5Regular_11">messages</samp>关联——<samp class="SANS_TheSansMonoCd_W5Regular_11">Channel</samp>表和<samp
    class="SANS_TheSansMonoCd_W5Regular_11">Message</samp>表都包含一个<samp class="SANS_TheSansMonoCd_W5Regular_11">server_id</samp>列。
- en: Finally, I defined the <samp class="SANS_TheSansMonoCd_W5Regular_11">__init__()</samp>
    method. When you define a class, you must call the first argument of every method
    <samp class="SANS_TheSansMonoCd_W5Regular_11">self</samp> to represent this Python
    object itself. You can optionally include other arguments, too. The <samp class="SANS_TheSansMonoCd_W5Regular_11">__init__()</samp>
    method is a type of method called a *constructor*, which runs as soon as you create
    the object. This constructor sets the value of the object’s <samp class="SANS_TheSansMonoCd_W5Regular_11">name</samp>
    attribute (which you access within the class as <samp class="SANS_TheSansMonoCd_W5Regular_11">self.name</samp>)
    to the value of <samp class="SANS_TheSansMonoCd_W5Regular_11">name</samp>, which
    is a variable passed into the <samp class="SANS_TheSansMonoCd_W5Regular_11">__init__()</samp>
    method as an argument.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我定义了<samp class="SANS_TheSansMonoCd_W5Regular_11">__init__()</samp>方法。当你定义一个类时，必须调用每个方法的第一个参数<samp
    class="SANS_TheSansMonoCd_W5Regular_11">self</samp>，以表示这个Python对象本身。你也可以选择性地包含其他参数。<samp
    class="SANS_TheSansMonoCd_W5Regular_11">__init__()</samp>方法是一种被称为*构造函数*的方法，它在你创建对象时立即运行。这个构造函数将对象的<samp
    class="SANS_TheSansMonoCd_W5Regular_11">name</samp>属性的值（你可以在类内部通过<samp class="SANS_TheSansMonoCd_W5Regular_11">self.name</samp>访问）设置为传入<samp
    class="SANS_TheSansMonoCd_W5Regular_11">__init__()</samp>方法的参数<samp class="SANS_TheSansMonoCd_W5Regular_11">name</samp>的值。
- en: For example, to add a row to the <samp class="SANS_TheSansMonoCd_W5Regular_11">Server</samp>
    table in the SQL database for the Vibrant Diversity Discord server, I could run
    the code in [Listing 14-7](#list14-7). (My Discord Analysis app doesn’t actually
    use this code—it loads the servers from the JSON data—but I’m including this example
    to help you understand how to use SQLAlchemy classes to interact with databases
    without needing to write SQL queries.)
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，要向Vibrant Diversity Discord服务器的SQL数据库中的<samp class="SANS_TheSansMonoCd_W5Regular_11">Server</samp>表添加一行，我可以运行[列表
    14-7](#list14-7)中的代码。（我的Discord分析应用实际上并没有使用这段代码——它是从JSON数据加载服务器的——但我包含这个示例是为了帮助你理解如何使用SQLAlchemy类与数据库交互，而无需编写SQL查询。）
- en: '[PRE32]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 14-7: Using SQLAlchemy
    to insert data into a SQL database</samp>'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">列表 14-7：使用SQLAlchemy将数据插入SQL数据库</samp>
- en: The first line of code creates a <samp class="SANS_TheSansMonoCd_W5Regular_11">Server</samp>
    object by running <samp class="SANS_TheSansMonoCd_W5Regular_11">Server("Vibrant
    Diversity")</samp>. This would run the constructor method, passing in the string
    <samp class="SANS_TheSansMonoCd_W5Regular_11">Vibrant Diversity</samp> as <samp
    class="SANS_TheSansMonoCd_W5Regular_11">name</samp>. The constructor would then
    set the value of its <samp class="SANS_TheSansMonoCd_W5Regular_11">name</samp>
    attribute to the name that was passed in. When the constructor finishes running,
    the code would save this newly created Python object in the <samp class="SANS_TheSansMonoCd_W5Regular_11">server</samp>
    variable. The next two lines of code use the SQLAlchemy object <samp class="SANS_TheSansMonoCd_W5Regular_11">db</samp>
    to run the <samp class="SANS_TheSansMonoCd_W5Regular_11">INSERT</samp> query in
    the SQL database and insert this row. The <samp class="SANS_TheSansMonoCd_W5Regular_11">db.session
    .add()</samp> method collects a list of SQL queries, and the <samp class="SANS_TheSansMonoCd_W5Regular_11">db.session.commit()</samp>
    method runs those SQL queries on the database. In SQL, sometimes it’s more efficient
    to run several queries and then commit them all at once rather than one at a time.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 第一行代码通过运行<samp class="SANS_TheSansMonoCd_W5Regular_11">Server("Vibrant Diversity")</samp>来创建一个<samp
    class="SANS_TheSansMonoCd_W5Regular_11">Server</samp>对象。这将执行构造方法，并将字符串<samp class="SANS_TheSansMonoCd_W5Regular_11">Vibrant
    Diversity</samp>作为<samp class="SANS_TheSansMonoCd_W5Regular_11">name</samp>传入。构造方法随后会将其<samp
    class="SANS_TheSansMonoCd_W5Regular_11">name</samp>属性的值设置为传入的名称。当构造方法执行完成后，代码将把这个新创建的Python对象保存在<samp
    class="SANS_TheSansMonoCd_W5Regular_11">server</samp>变量中。接下来的两行代码使用SQLAlchemy对象<samp
    class="SANS_TheSansMonoCd_W5Regular_11">db</samp>执行SQL数据库中的<samp class="SANS_TheSansMonoCd_W5Regular_11">INSERT</samp>查询并插入这一行数据。<samp
    class="SANS_TheSansMonoCd_W5Regular_11">db.session.add()</samp>方法收集一系列SQL查询，而<samp
    class="SANS_TheSansMonoCd_W5Regular_11">db.session.commit()</samp>方法则会在数据库上执行这些SQL查询。在SQL中，有时一次性执行多个查询并提交比一个一个执行更高效。
- en: In other words, the code in [Listing 14-7](#list14-7) is basically the same
    as running the SQL query <samp class="SANS_TheSansMonoCd_W5Regular_11">INSERT
    INTO server SET name='Vibrant Diversity';</samp>, except this way all you need
    to do is interact with Python objects, not write any SQL yourself. After creating
    the server object, I could then access that object’s ID attribute with <samp class="SANS_TheSansMonoCd_W5Regular_11">server.id</samp>
    or the object’s name attribute with <samp class="SANS_TheSansMonoCd_W5Regular_11">server.name</samp>.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 换句话说，[清单14-7](#list14-7)中的代码基本上等同于执行SQL查询<samp class="SANS_TheSansMonoCd_W5Regular_11">INSERT
    INTO server SET name='Vibrant Diversity';</samp>，只不过这种方式，你只需要与Python对象进行交互，而不需要自己编写SQL。创建完server对象后，我可以通过<samp
    class="SANS_TheSansMonoCd_W5Regular_11">server.id</samp>访问该对象的ID属性，或通过<samp class="SANS_TheSansMonoCd_W5Regular_11">server.name</samp>访问该对象的name属性。
- en: 'In addition to the <samp class="SANS_TheSansMonoCd_W5Regular_11">Server</samp>
    table I just described, I also created the following tables, which you can view
    in detail in the *app.py* file at [*https://<wbr>github<wbr>.com<wbr>/micahflee<wbr>/hacks<wbr>-leaks<wbr>-and<wbr>-revelations<wbr>/blob<wbr>/main<wbr>/chapter<wbr>-14<wbr>/discord<wbr>-analysis<wbr>/app<wbr>.py*](https://github.com/micahflee/hacks-leaks-and-revelations/blob/main/chapter-14/discord-analysis/app.py):'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 除了我刚才描述的<sam class="SANS_TheSansMonoCd_W5Regular_11">Server</samp>表格，我还创建了以下表格，您可以在[*app.py*文件中详细查看](https://github.com/micahflee/hacks-leaks-and-revelations/blob/main/chapter-14/discord-analysis/app.py)：
- en: <samp class="SANS_TheSansMonoCd_W7Bold_B_11">User</samp> A Discord user. I included
    the columns <samp class="SANS_TheSansMonoCd_W5Regular_11">id</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">discord_id</samp>,
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">name</samp>. The <samp class="SANS_TheSansMonoCd_W5Regular_11">id</samp>
    column is an auto-incrementing number, and <samp class="SANS_TheSansMonoCd_W5Regular_11">discord_id</samp>
    is the original ID that Discord itself used. This is useful for identifying the
    same user across servers.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W7Bold_B_11">用户</samp> 一个Discord用户。我包括了列<samp
    class="SANS_TheSansMonoCd_W5Regular_11">id</samp>、<samp class="SANS_TheSansMonoCd_W5Regular_11">discord_id</samp>和<samp
    class="SANS_TheSansMonoCd_W5Regular_11">name</samp>。<samp class="SANS_TheSansMonoCd_W5Regular_11">id</samp>列是一个自动递增的数字，而<samp
    class="SANS_TheSansMonoCd_W5Regular_11">discord_id</samp>是Discord本身使用的原始ID。这对于在不同服务器间识别相同的用户非常有用。
- en: <samp class="SANS_TheSansMonoCd_W7Bold_B_11">Channel</samp> A channel in a Discord
    server. The columns are <samp class="SANS_TheSansMonoCd_W5Regular_11">id</samp>,
    <samp class="SANS_TheSansMonoCd_W5Regular_11">discord_id</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">name</samp>,
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">server_id</samp>. The <samp
    class="SANS_TheSansMonoCd_W5Regular_11">server_id</samp> column forms a relationship
    with the <samp class="SANS_TheSansMonoCd_W5Regular_11">Server</samp> table, since
    each server has a set of channels. Every Discord server JSON file contains a list
    of channels. Adding this relationship means that the SQL database I was designing
    would match the data structure in the JSON files.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W7Bold_B_11">频道</samp> Discord 服务器中的一个频道。列包括
    <samp class="SANS_TheSansMonoCd_W5Regular_11">id</samp>、<samp class="SANS_TheSansMonoCd_W5Regular_11">discord_id</samp>、<samp
    class="SANS_TheSansMonoCd_W5Regular_11">名称</samp> 和 <samp class="SANS_TheSansMonoCd_W5Regular_11">server_id</samp>。<samp
    class="SANS_TheSansMonoCd_W5Regular_11">server_id</samp> 列与 <samp class="SANS_TheSansMonoCd_W5Regular_11">Server</samp>
    表格形成关系，因为每个服务器都有一组频道。每个 Discord 服务器的 JSON 文件都包含一个频道列表。添加此关系意味着我设计的 SQL 数据库将与 JSON
    文件中的数据结构匹配。
- en: <samp class="SANS_TheSansMonoCd_W7Bold_B_11">Message</samp> A Discord message.
    The columns are <samp class="SANS_TheSansMonoCd_W5Regular_11">id</samp>, <samp
    class="SANS_TheSansMonoCd_W5Regular_11">discord_id</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">timestamp</samp>,
    <samp class="SANS_TheSansMonoCd_W5Regular_11">message</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">attachments_json</samp>,
    <samp class="SANS_TheSansMonoCd_W5Regular_11">user_id</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">channel_id</samp>,
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">server_id</samp>. The <samp
    class="SANS_TheSansMonoCd_W5Regular_11">attachments _json</samp> column contains
    extra data from messages with attachments, like when someone posts an image to
    Discord. The <samp class="SANS_TheSansMonoCd_W5Regular_11">user_id</samp>, <samp
    class="SANS_TheSansMonoCd_W5Regular_11">channel_id</samp>, and <samp class="SANS_TheSansMonoCd_W5Regular_11">server_id</samp>
    columns form relationships with the <samp class="SANS_TheSansMonoCd_W5Regular_11">User</samp>,
    <samp class="SANS_TheSansMonoCd_W5Regular_11">Channel</samp>, and <samp class="SANS_TheSansMonoCd_W5Regular_11">Server</samp>
    tables. These also would match the structure found in the JSON files.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W7Bold_B_11">消息</samp> 一个 Discord 消息。列包括 <samp
    class="SANS_TheSansMonoCd_W5Regular_11">id</samp>、<samp class="SANS_TheSansMonoCd_W5Regular_11">discord_id</samp>、<samp
    class="SANS_TheSansMonoCd_W5Regular_11">时间戳</samp>、<samp class="SANS_TheSansMonoCd_W5Regular_11">消息内容</samp>、<samp
    class="SANS_TheSansMonoCd_W5Regular_11">附件_json</samp>、<samp class="SANS_TheSansMonoCd_W5Regular_11">user_id</samp>、<samp
    class="SANS_TheSansMonoCd_W5Regular_11">channel_id</samp> 和 <samp class="SANS_TheSansMonoCd_W5Regular_11">server_id</samp>。<samp
    class="SANS_TheSansMonoCd_W5Regular_11">附件_json</samp> 列包含带有附件的消息的额外数据，比如当有人向
    Discord 发布图片时。<samp class="SANS_TheSansMonoCd_W5Regular_11">user_id</samp>、<samp
    class="SANS_TheSansMonoCd_W5Regular_11">channel_id</samp> 和 <samp class="SANS_TheSansMonoCd_W5Regular_11">server_id</samp>
    列与 <samp class="SANS_TheSansMonoCd_W5Regular_11">User</samp>、<samp class="SANS_TheSansMonoCd_W5Regular_11">Channel</samp>
    和 <samp class="SANS_TheSansMonoCd_W5Regular_11">Server</samp> 表格形成关系。这些列的结构也与
    JSON 文件中的结构匹配。
- en: '[Figure 14-2](#fig14-2) shows the relationship between these four tables. The
    <samp class="SANS_TheSansMonoCd_W5Regular_11">Channel</samp> table includes a
    <samp class="SANS_TheSansMonoCd_W5Regular_11">server_id</samp> column, so it’s
    related to the <samp class="SANS_TheSansMonoCd_W5Regular_11">Server</samp> table.
    The <samp class="SANS_TheSansMonoCd_W5Regular_11">Message</samp> table includes
    columns for <samp class="SANS_TheSansMonoCd_W5Regular_11">channel_id</samp>, <samp
    class="SANS_TheSansMonoCd_W5Regular_11">server_id</samp>, and <samp class="SANS_TheSansMonoCd_W5Regular_11">user_id</samp>,
    so it’s related to the <samp class="SANS_TheSansMonoCd_W5Regular_11">Channel</samp>,
    <samp class="SANS_TheSansMonoCd_W5Regular_11">Server</samp>, and <samp class="SANS_TheSansMonoCd_W5Regular_11">User</samp>
    tables.'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 14-2](#fig14-2) 显示了这四个表之间的关系。<samp class="SANS_TheSansMonoCd_W5Regular_11">Channel</samp>
    表包含一个 <samp class="SANS_TheSansMonoCd_W5Regular_11">server_id</samp> 列，因此它与 <samp
    class="SANS_TheSansMonoCd_W5Regular_11">Server</samp> 表相关联。<samp class="SANS_TheSansMonoCd_W5Regular_11">Message</samp>
    表包含 <samp class="SANS_TheSansMonoCd_W5Regular_11">channel_id</samp>、<samp class="SANS_TheSansMonoCd_W5Regular_11">server_id</samp>
    和 <samp class="SANS_TheSansMonoCd_W5Regular_11">user_id</samp> 列，因此它与 <samp class="SANS_TheSansMonoCd_W5Regular_11">Channel</samp>、<samp
    class="SANS_TheSansMonoCd_W5Regular_11">Server</samp> 和 <samp class="SANS_TheSansMonoCd_W5Regular_11">User</samp>
    表相关联。'
- en: '![A chart showing four table names, clockwise from top left: Server, User,
    Message, and Channel. Channel points to Server, and Message points to Channel,
    Server, and User.](Images/Figure14-2.png)'
  id: totrans-166
  prefs: []
  type: TYPE_IMG
  zh: '![一张图表，显示四个表名，从左上角顺时针方向：服务器、用户、消息和频道。频道指向服务器，消息指向频道、服务器和用户。](Images/Figure14-2.png)'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 14-2: Relationships
    between the SQL tables in the Discord Analysis app</samp>'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">图 14-2：Discord 分析应用中的 SQL 表之间的关系</samp>
- en: My goal for this web app would be to build an interface that allows me to explore
    the data stored in these SQL tables. I wanted to be able to search all of the
    messages at once, including from multiple servers, to see which users posted in
    multiple servers and to be able to generate links to individual messages that
    I could store in my notes. Before building the web interface, though, I needed
    to load the database with data from the JSON files.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 我为这个网页应用的目标是构建一个界面，让我能够浏览存储在这些 SQL 表中的数据。我希望能够一次性搜索所有消息，包括来自多个服务器的消息，以便查看哪些用户在多个服务器中发布了消息，并且能够生成指向单个消息的链接，方便我在笔记中保存。不过，在构建网页界面之前，我需要先将
    JSON 文件中的数据加载到数据库中。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Importing Chat Logs
    into the SQL Database</samp>
  id: totrans-169
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">将聊天记录导入 SQL 数据库</samp>
- en: I wrote a separate script, *admin.py*, that I used to import data into the SQL
    database. This script took a command as its first argument. If I passed in <samp
    class="SANS_TheSansMonoCd_W5Regular_11">create-db</samp>, it would use SQLAlchemy
    to create the SQL tables that I had defined in *app.py*. When I passed in <samp
    class="SANS_TheSansMonoCd_W5Regular_11">import-json</samp>, followed by the filename
    of a JSON file, the code would import Discord data from that JSON file into the
    SQL database. I also eventually added the <samp class="SANS_TheSansMonoCd_W5Regular_11">user-stats</samp>
    command, which displayed how many messages each user in the whole database posted,
    and on which servers.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 我编写了一个单独的脚本 *admin.py*，用于将数据导入 SQL 数据库。这个脚本将命令作为第一个参数。如果我传入 <samp class="SANS_TheSansMonoCd_W5Regular_11">create-db</samp>，它将使用
    SQLAlchemy 创建我在 *app.py* 中定义的 SQL 表。如果我传入 <samp class="SANS_TheSansMonoCd_W5Regular_11">import-json</samp>，并跟上
    JSON 文件的文件名，代码将把该 JSON 文件中的 Discord 数据导入 SQL 数据库。最终，我还添加了 <samp class="SANS_TheSansMonoCd_W5Regular_11">user-stats</samp>
    命令，它显示了数据库中每个用户发布的消息数量，以及发布的服务器。
- en: This *admin,py* file is too long to include in this chapter in its entirety,
    but as with *app.py*, you can find a copy of the complete code in the book’s GitHub
    repo at [*https://<wbr>github<wbr>.com<wbr>/micahflee<wbr>/hacks<wbr>-leaks<wbr>-and<wbr>-revelations<wbr>/blob<wbr>/main<wbr>/chapter<wbr>-14<wbr>/discord<wbr>-analysis<wbr>/admin<wbr>.py*](https://github.com/micahflee/hacks-leaks-and-revelations/blob/main/chapter-14/discord-analysis/admin.py).
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 这个 *admin.py* 文件太长，无法在本章中完整展示，但与 *app.py* 一样，你可以在本书的 GitHub 仓库中找到完整代码的副本，网址是
    [*https://<wbr>github<wbr>.com<wbr>/micahflee<wbr>/hacks<wbr>-leaks<wbr>-and<wbr>-revelations<wbr>/blob<wbr>/main<wbr>/chapter<wbr>-14<wbr>/discord<wbr>-analysis<wbr>/admin<wbr>.py*](https://github.com/micahflee/hacks-leaks-and-revelations/blob/main/chapter-14/discord-analysis/admin.py)。
- en: In this section, I’ll explain how I built the <samp class="SANS_TheSansMonoCd_W5Regular_11">import-json</samp>
    command (specifically, the <samp class="SANS_TheSansMonoCd_W5Regular_11">import_json()</samp>
    function, which is what gets called when you run <samp class="SANS_TheSansMonoCd_W5Regular_11">import-json</samp>),
    the most interesting part of the script. This is the code that opens up the JSON
    files containing Discord server leaks, loops through all the data, and then inserts
    it into the SQL database. As with the *discord-json -search.py* script, I relied
    on my previous manual analysis of the Discord JSON files to write this code. Basically,
    this is the part that requires an understanding of the structure of the original
    data.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一部分，我将解释我如何构建 <samp class="SANS_TheSansMonoCd_W5Regular_11">import-json</samp>
    命令（具体来说，是 <samp class="SANS_TheSansMonoCd_W5Regular_11">import_json()</samp> 函数，它是在运行
    <samp class="SANS_TheSansMonoCd_W5Regular_11">import-json</samp> 时被调用的），这是脚本中最有趣的部分。这段代码打开包含
    Discord 服务器泄露数据的 JSON 文件，遍历所有数据，然后将其插入 SQL 数据库中。与 *discord-json -search.py* 脚本一样，我依赖之前对
    Discord JSON 文件的手动分析来编写这段代码。基本上，这部分需要理解原始数据的结构。
- en: The <samp class="SANS_TheSansMonoCd_W5Regular_11">import_json()</samp> function
    is too long to display it all here, so instead I’ll display snippets that explain
    the general idea of how it works. The function takes the filename for a JSON file
    containing Discord leaks as an argument. It opens this file, loads it into a variable
    called <samp class="SANS_TheSansMonoCd_W5Regular_11">data</samp>, and then uses
    the information in <samp class="SANS_TheSansMonoCd_W5Regular_11">data</samp> to
    add servers, users, channels, and messages to the SQL database. I’ll show the
    code that adds users, channels, and messages soon, but first, [Listing 14-8](#list14-8)
    shows the code that adds servers.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W5Regular_11">import_json()</samp> 函数过长，无法在此处全部展示，因此我将展示一些代码片段，解释它的基本工作原理。该函数接受一个包含
    Discord 泄露数据的 JSON 文件的文件名作为参数。它打开这个文件，将其加载到名为 <samp class="SANS_TheSansMonoCd_W5Regular_11">data</samp>
    的变量中，然后使用 <samp class="SANS_TheSansMonoCd_W5Regular_11">data</samp> 中的信息将服务器、用户、频道和消息添加到
    SQL 数据库中。我将很快展示添加用户、频道和消息的代码，但首先，[列表 14-8](#list14-8) 展示了添加服务器的代码。
- en: '[PRE33]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 14-8: Code from</samp>
    <samp class="SANS_Futura_Std_Book_11">admin.py</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">to
    add servers to the database</samp>'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">列表 14-8：来自</samp> <samp class="SANS_Futura_Std_Book_11">admin.py</samp>
    <samp class="SANS_Futura_Std_Book_Oblique_I_11">的代码，用于将服务器添加到数据库</samp>
- en: This code looped through all of the servers it found in <samp class="SANS_TheSansMonoCd_W5Regular_11">data["meta"]["servers"]</samp>,
    adding a row to the database for each server that it found. For example, in [Listing
    14-1](#list14-1), I used <samp class="SANS_TheSansMonoCd_W5Regular_11">jq</samp>
    to view this list of servers for *VibrantDiversity.json* and found that it contained
    only a single server. [Listing 14-8](#list14-8) uses Python code to find that
    same list of servers from the same part of the target leaked JSON file.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码循环遍历它在 <samp class="SANS_TheSansMonoCd_W5Regular_11">data["meta"]["servers"]</samp>
    中找到的所有服务器，为每个找到的服务器在数据库中添加一行。例如，在[列表 14-1](#list14-1)中，我使用 <samp class="SANS_TheSansMonoCd_W5Regular_11">jq</samp>
    查看 *VibrantDiversity.json* 中的服务器列表，发现它只包含一个服务器。[列表 14-8](#list14-8) 使用 Python
    代码从目标泄露的 JSON 文件中的相同部分查找相同的服务器列表。
- en: For each server it found, the code stored the server’s name in the <samp class="SANS_TheSansMonoCd_W5Regular_11">name</samp>
    variable, then tried to add that server to the database. This code used Python
    exception handling, which you learned about in [Chapter 7](chapter7.xhtml). In
    the <samp class="SANS_TheSansMonoCd_W5Regular_11">try</samp> block, the code created
    a new <samp class="SANS_TheSansMonoCd_W5Regular_11">Server</samp> object (this
    represents a row in the <samp class="SANS_TheSansMonoCd_W5Regular_11">Server</samp>
    table in SQLAlchemy), added that row to the database using <samp class="SANS_TheSansMonoCd_W5Regular_11">db.session</samp><samp
    class="SANS_TheSansMonoCd_W5Regular_11">.add(server)</samp>, and finally committed
    the database changes with <samp class="SANS_TheSansMonoCd_W5Regular_11">db.session.commit()</samp>,
    just like in the SQLAlchemy code in [Listing 14-7](#list14-7). After the server
    was successfully inserted into the database, the program displayed a plus sign
    (<samp class="SANS_TheSansMonoCd_W5Regular_11">+</samp>) and moved on to the next
    loop.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 对于它找到的每个服务器，代码将服务器的名称存储在 <samp class="SANS_TheSansMonoCd_W5Regular_11">name</samp>
    变量中，然后尝试将该服务器添加到数据库中。此代码使用了 Python 异常处理，你在[第 7 章](chapter7.xhtml)中学到过。 在 <samp
    class="SANS_TheSansMonoCd_W5Regular_11">try</samp> 块中，代码创建了一个新的 <samp class="SANS_TheSansMonoCd_W5Regular_11">Server</samp>
    对象（这代表了 SQLAlchemy 中的 <samp class="SANS_TheSansMonoCd_W5Regular_11">Server</samp>
    表中的一行），使用 <samp class="SANS_TheSansMonoCd_W5Regular_11">db.session</samp><samp
    class="SANS_TheSansMonoCd_W5Regular_11">.add(server)</samp> 将该行添加到数据库中，并最终通过 <samp
    class="SANS_TheSansMonoCd_W5Regular_11">db.session.commit()</samp> 提交数据库更改，就像在[列表
    14-7](#list14-7)中的 SQLAlchemy 代码一样。服务器成功插入数据库后，程序显示一个加号符号（<samp class="SANS_TheSansMonoCd_W5Regular_11">+</samp>），然后进入下一个循环。
- en: When I defined the <samp class="SANS_TheSansMonoCd_W5Regular_11">Server</samp>
    table in *app.py*, I specified that the <samp class="SANS_TheSansMonoCd_W5Regular_11">name</samp>
    column should be unique, meaning that there could be no two rows with the same
    <samp class="SANS_TheSansMonoCd_W5Regular_11">name</samp> column. If SQLAlchemy
    threw the <samp class="SANS_TheSansMonoCd_W5Regular_11">sqlalchemy.exc.IntegrityError</samp>
    exception while the script was trying to add the row to the database, that meant
    a server with that name already existed in the database, and the <samp class="SANS_TheSansMonoCd_W5Regular_11">except</samp>
    block should run instead. If this happened, then the code rolled back the change
    that it was about to make and displayed a dot (<samp class="SANS_TheSansMonoCd_W5Regular_11">.</samp>)
    instead of a plus sign.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 当我在 *app.py* 中定义 <samp class="SANS_TheSansMonoCd_W5Regular_11">Server</samp>
    表时，我指定了 <samp class="SANS_TheSansMonoCd_W5Regular_11">name</samp> 列应该是唯一的，意味着不允许有两行具有相同的
    <samp class="SANS_TheSansMonoCd_W5Regular_11">name</samp> 列。如果 SQLAlchemy 在脚本尝试向数据库添加行时抛出
    <samp class="SANS_TheSansMonoCd_W5Regular_11">sqlalchemy.exc.IntegrityError</samp>
    异常，意味着数据库中已经存在具有该名称的服务器，应该运行 <samp class="SANS_TheSansMonoCd_W5Regular_11">except</samp>
    块。如果发生这种情况，代码将回滚它即将做出的更改，并显示一个点（<samp class="SANS_TheSansMonoCd_W5Regular_11">.</samp>），而不是加号（+）。
- en: Why did I worry about catching these exceptions to begin with instead of just
    adding rows to the database? As with the programming exercises that you completed
    in previous chapters, I didn’t write the whole script perfectly the first time
    and then run it. Instead, I wrote small bits of code at a time and ran them to
    make sure my script was working so far. This exception handling allowed me to
    rerun an import on the same JSON file over and over while starting where I left
    off. If my script showed a plus sign, I knew it had added a new row to the database.
    If it showed a dot, that meant the row already existed and the script moved on.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么我一开始要担心捕获这些异常，而不是直接向数据库添加行？就像你在前几章完成的编程练习一样，我并不是第一次写好整个脚本然后运行它。相反，我是一次写一些小段代码并运行它们，以确保脚本到目前为止能正常工作。这种异常处理让我能够在每次导入相同的
    JSON 文件时从中断的地方重新开始。如果我的脚本显示加号（+），那意味着它已经向数据库添加了一行。如果它显示的是点（.），则表示该行已经存在，脚本继续执行下去。
- en: 'You might also notice that the familiar <samp class="SANS_TheSansMonoCd_W5Regular_11">print()</samp>
    function calls look odd in [Listing 14-8](#list14-8): my code passed in the <samp
    class="SANS_TheSansMonoCd_W5Regular_11">end=""</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">flush=True</samp>
    keyword arguments. By default, <samp class="SANS_TheSansMonoCd_W5Regular_11">print()</samp>
    displays the string the user passes in as an argument, then adds a newline character
    (<samp class="SANS_TheSansMonoCd_W5Regular_11">\n</samp>) to the end. The <samp
    class="SANS_TheSansMonoCd_W5Regular_11">end</samp> argument replaces that newline
    with something else (in this case, an empty string). In other words, this is how
    I could print a string without moving on to the next line. The <samp class="SANS_TheSansMonoCd_W5Regular_11">flush=True</samp>
    argument makes sure that the output gets displayed to the screen immediately;
    without it, the output would still get displayed, but not right after the function
    call. This allowed me to watch the progress of an import.'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能还注意到，在[列表 14-8](#list14-8)中，熟悉的 <samp class="SANS_TheSansMonoCd_W5Regular_11">print()</samp>
    函数调用看起来有些奇怪：我的代码传入了 <samp class="SANS_TheSansMonoCd_W5Regular_11">end=""</samp>
    和 <samp class="SANS_TheSansMonoCd_W5Regular_11">flush=True</samp> 这两个关键字参数。默认情况下，<samp
    class="SANS_TheSansMonoCd_W5Regular_11">print()</samp> 会显示用户传入的字符串作为参数，然后在末尾添加一个换行符
    (<samp class="SANS_TheSansMonoCd_W5Regular_11">\n</samp>)。<samp class="SANS_TheSansMonoCd_W5Regular_11">end</samp>
    参数替代了换行符（在这种情况下是一个空字符串）。换句话说，这就是我如何在不换行的情况下打印字符串。<samp class="SANS_TheSansMonoCd_W5Regular_11">flush=True</samp>
    参数确保输出会立即显示在屏幕上；没有它，输出仍然会显示，但不会在函数调用之后立即显示。这让我能够实时监控导入进度。
- en: After adding servers, the script added users, as shown in [Listing 14-9](#list14-9).
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 添加服务器后，脚本添加了用户，如[列表 14-9](#list14-9)所示。
- en: '[PRE34]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 14-9: Code from</samp>
    <samp class="SANS_Futura_Std_Book_11">admin.py</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">to
    add users to the database</samp>'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">列表 14-9：来自</samp> <samp class="SANS_Futura_Std_Book_11">admin.py</samp>
    <samp class="SANS_Futura_Std_Book_Oblique_I_11">的代码，用于向数据库添加用户</samp>
- en: This code is very similar to [Listing 14-8](#list14-8), but instead of looping
    through the list <samp class="SANS_TheSansMonoCd_W5Regular_11">data["meta"]["servers"]</samp>,
    it looped through the dictionary <samp class="SANS_TheSansMonoCd_W5Regular_11">data["meta"]["users"]</samp>.
    [Listing 14-3](#list14-3) shows this JSON object of users from *VibrantDiversity
    .json*. As described in [Chapter 8](chapter8.xhtml), when you loop through a dictionary,
    you’re actually looping through the dictionary’s keys. In this case, the script
    stored each key in the <samp class="SANS_TheSansMonoCd_W5Regular_11">user_discord_id</samp>
    variable. Armed with the user’s Discord ID, it then looked up that user’s name
    in the metadata.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码与 [第14-8节](#list14-8) 非常相似，但它不是循环遍历列表 <samp class="SANS_TheSansMonoCd_W5Regular_11">data["meta"]["servers"]</samp>，而是循环遍历字典
    <samp class="SANS_TheSansMonoCd_W5Regular_11">data["meta"]["users"]</samp>。 [第14-3节](#list14-3)
    展示了来自 *VibrantDiversity.json* 的用户 JSON 对象。如同在 [第8章](chapter8.xhtml) 中所描述，当你循环遍历字典时，实际上是在循环遍历字典的键。在这种情况下，脚本将每个键存储在
    <samp class="SANS_TheSansMonoCd_W5Regular_11">user_discord_id</samp> 变量中。获取了用户的Discord
    ID后，它接着在元数据中查找该用户的姓名。
- en: 'In the <samp class="SANS_TheSansMonoCd_W5Regular_11">try</samp> block, the
    script then created a new <samp class="SANS_TheSansMonoCd_W5Regular_11">User</samp>
    object, this time with both the user’s Discord ID and name, and tried adding it
    to the database. When I defined the <samp class="SANS_TheSansMonoCd_W5Regular_11">User</samp>
    table in *app.py*, I specified that <samp class="SANS_TheSansMonoCd_W5Regular_11">user_discord_id</samp>
    should be unique in order to prevent duplicate users. Like [Listing 14-8](#list14-8),
    the code displayed a plus sign when adding the user to the database and a dot
    if it hit an error. This error-handling code would be important when I started
    importing multiple servers: if a Discord user was already in the database because
    they were a member of a previous server, the code wouldn’t create a duplicate
    user for them.'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 在 <samp class="SANS_TheSansMonoCd_W5Regular_11">try</samp> 块中，脚本接着创建了一个新的 <samp
    class="SANS_TheSansMonoCd_W5Regular_11">User</samp> 对象，这次包含了用户的Discord ID和姓名，并尝试将其添加到数据库。当我在
    *app.py* 中定义 <samp class="SANS_TheSansMonoCd_W5Regular_11">User</samp> 表时，我指定
    <samp class="SANS_TheSansMonoCd_W5Regular_11">user_discord_id</samp> 应该是唯一的，以防止用户重复。像
    [第14-8节](#list14-8) 中一样，代码在将用户添加到数据库时显示了一个加号，若发生错误则显示一个点。这个错误处理代码在我开始导入多个服务器时非常重要：如果一个Discord用户已经在数据库中，因为他们是某个先前服务器的成员，代码就不会为他们创建重复的用户。
- en: After adding servers and users, the script then added channels, using the code
    in [Listing 14-10](#list14-10).
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 在添加完服务器和用户后，脚本接着添加频道，使用了 [第14-10节](#list14-10) 中的代码。
- en: '[PRE35]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 14-10: Code from</samp>
    <samp class="SANS_Futura_Std_Book_11">admin.py</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">to
    add channels to the database</samp>'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">第14-10节：来自</samp> <samp class="SANS_Futura_Std_Book_11">admin.py</samp>
    <samp class="SANS_Futura_Std_Book_Oblique_I_11">的代码，用于将频道添加到数据库</samp>
- en: This code is also similar to Listings 14-8 and 14-9\. This time however, it
    looped through the keys of the <samp class="SANS_TheSansMonoCd_W5Regular_11">data["meta"]["channels"]</samp>
    dictionary, storing each key as <samp class="SANS_TheSansMonoCd_W5Regular_11">channel_discord_id</samp>.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码与第14-8节和第14-9节也非常相似。不过，这次它循环遍历了 <samp class="SANS_TheSansMonoCd_W5Regular_11">data["meta"]["channels"]</samp>
    字典的键，将每个键存储为 <samp class="SANS_TheSansMonoCd_W5Regular_11">channel_discord_id</samp>。
- en: '[Listing 14-2](#list14-2) showed this JSON object of channels from *VibrantDiversity
    .json*, which you can revisit to remind yourself what this dictionary looks like.
    For each channel, the code in [Listing 14-8](#list14-8) stored the name of the
    channel in <samp class="SANS_TheSansMonoCd_W5Regular_11">name</samp> and that
    channel’s server index in <samp class="SANS_TheSansMonoCd_W5Regular_11">server_id</samp>.
    It then queried the SQL database itself to get the server row in [Listing 14-10](#list14-10)
    ❶, which should have been added earlier by the code in [Listing 14-9](#list14-9),
    and stored this value in <samp class="SANS_TheSansMonoCd_W5Regular_11">server</samp>.
    The SQL query that the <samp class="SANS_TheSansMonoCd_W5Regular_11">Server.query.filter_by()</samp>
    function call ran was similar to <samp class="SANS_TheSansMonoCd_W5Regular_11">SELECT
    * FROM servers WHERE name=''</samp><samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">name</samp><samp
    class="SANS_TheSansMonoCd_W5Regular_11">'';</samp>, where <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">name</samp>
    is the server name.'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: '[列表 14-2](#list14-2)展示了来自*VibrantDiversity .json*的频道 JSON 对象，你可以回顾它来提醒自己这个字典的样子。对于每个频道，[列表
    14-8](#list14-8)中的代码将频道名称存储在<samp class="SANS_TheSansMonoCd_W5Regular_11">name</samp>中，并将该频道的服务器索引存储在<samp
    class="SANS_TheSansMonoCd_W5Regular_11">server_id</samp>中。然后，代码查询 SQL 数据库本身，以获取[列表
    14-10](#list14-10)中的服务器行 ❶，该行应该已经被[列表 14-9](#list14-9)中的代码提前添加，并将该值存储在<samp class="SANS_TheSansMonoCd_W5Regular_11">server</samp>中。<samp
    class="SANS_TheSansMonoCd_W5Regular_11">Server.query.filter_by()</samp>函数调用运行的
    SQL 查询类似于<samp class="SANS_TheSansMonoCd_W5Regular_11">SELECT * FROM servers WHERE
    name=''</samp><samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">name</samp><samp
    class="SANS_TheSansMonoCd_W5Regular_11">'';</samp>，其中<samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">name</samp>是服务器名称。'
- en: In the <samp class="SANS_TheSansMonoCd_W5Regular_11">try</samp> block, the code
    then created a new <samp class="SANS_TheSansMonoCd_W5Regular_11">Channel</samp>
    object, this time telling it the server, the channel’s Discord ID, and the channel
    name. As with the previous listings, it tried adding this channel to the database,
    displaying a plus sign on success and a dot if the channel already existed.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 在<samp class="SANS_TheSansMonoCd_W5Regular_11">try</samp>代码块中，代码创建了一个新的<samp
    class="SANS_TheSansMonoCd_W5Regular_11">Channel</samp>对象，这次告诉它服务器、频道的 Discord
    ID 和频道名称。与之前的列表一样，它尝试将此频道添加到数据库中，成功时显示加号，若频道已存在则显示一个点。
- en: Finally, after adding servers, users, and channels, the code added all of the
    messages, as shown in [Listing 14-11](#list14-11).
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，在添加服务器、用户和频道后，代码将所有消息添加到数据库中，如[列表 14-11](#list14-11)所示。
- en: '[PRE36]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 14-11: Code from</samp>
    <samp class="SANS_Futura_Std_Book_11">admin.py</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">to
    add messages to the database</samp>'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">列表 14-11：来自</samp> <samp class="SANS_Futura_Std_Book_11">admin.py</samp>
    <samp class="SANS_Futura_Std_Book_Oblique_I_11">的代码，用于将消息添加到数据库中</samp>
- en: This time, this code looped through all of the keys of the <samp class="SANS_TheSansMonoCd_W5Regular_11">data["data"]</samp>
    dictionary. As you learned in [Listing 14-5](#list14-5), this dictionary’s keys
    are the Discord IDs of channels. My code stored each ID in the variable <samp
    class="SANS_TheSansMonoCd_W5Regular_11">channel _discord_id</samp>. I then used
    SQLAlchemy to query the database to load this actual channel row ❶ (the SQL query
    that this command ran was similar to <samp class="SANS_TheSansMonoCd_W5Regular_11">SELECT
    * FROM channel WHERE channel_discord_id=</samp><samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">channel_discord_id</samp>,
    where <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">channel_discord_id</samp>
    is the channel ID). After learning what channel it was dealing with, the code
    then looped through all of that channel’s messages to add them to the database,
    storing each message’s Discord ID as <samp class="SANS_TheSansMonoCd_W5Regular_11">message_discord_id</samp>.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 这次，代码遍历了<samp class="SANS_TheSansMonoCd_W5Regular_11">data["data"]</samp>字典的所有键。正如你在[列表
    14-5](#list14-5)中学到的，这个字典的键是频道的 Discord ID。我的代码将每个 ID 存储在变量<samp class="SANS_TheSansMonoCd_W5Regular_11">channel_discord_id</samp>中。然后，我使用
    SQLAlchemy 查询数据库，以加载该实际频道的行 ❶（此命令运行的 SQL 查询类似于<samp class="SANS_TheSansMonoCd_W5Regular_11">SELECT
    * FROM channel WHERE channel_discord_id=</samp><samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">channel_discord_id</samp>，其中<samp
    class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">channel_discord_id</samp>是频道
    ID）。在了解了正在处理的是哪个频道之后，代码遍历了该频道的所有消息，并将它们添加到数据库中，将每条消息的 Discord ID 存储为<samp class="SANS_TheSansMonoCd_W5Regular_11">message_discord_id</samp>。
- en: The rest of the code in [Listing 14-11](#list14-11) is also similar to Listings
    14-8 through 14-10\. In the <samp class="SANS_TheSansMonoCd_W5Regular_11">try</samp>
    block, for each message, the code stored the timestamp and message in the <samp
    class="SANS_TheSansMonoCd_W5Regular_11">timestamp</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">message</samp>
    variables. It then looked up the user Discord ID from the metadata and queried
    the SQL database for the <samp class="SANS_TheSansMonoCd_W5Regular_11">User</samp>
    object ❷, and, if the message included an attachment, it also created a string
    called <samp class="SANS_TheSansMonoCd_W5Regular_11">attachments_json</samp>.
    Finally, it created a <samp class="SANS_TheSansMonoCd_W5Regular_11">Message</samp>
    object and inserted this message into the database. As before, the code displayed
    a plus sign if it successfully inserted a message or a dot if that message was
    already in the database.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: '[清单 14-11](#list14-11)中的其余代码也类似于清单 14-8 到 14-10。在<samp class="SANS_TheSansMonoCd_W5Regular_11">try</samp>块中，对于每条消息，代码将时间戳和消息存储在<samp
    class="SANS_TheSansMonoCd_W5Regular_11">timestamp</samp>和<samp class="SANS_TheSansMonoCd_W5Regular_11">message</samp>变量中。然后，它从元数据中查找用户的Discord
    ID，并查询SQL数据库中的<samp class="SANS_TheSansMonoCd_W5Regular_11">User</samp>对象❷；如果消息包含附件，它还会创建一个名为<samp
    class="SANS_TheSansMonoCd_W5Regular_11">attachments_json</samp>的字符串。最后，它创建一个<samp
    class="SANS_TheSansMonoCd_W5Regular_11">Message</samp>对象，并将此消息插入数据库。如前所述，如果成功插入消息，代码会显示一个加号；如果该消息已经在数据库中，则显示一个点。'
- en: Since exception handling ensured *admin.py* wouldn’t import duplicate rows,
    I could use this script to import newer versions of JSON files from the same Discord
    server. For example, if Unicorn Riot’s infiltrator used Discord History Tracker
    to save another offline copy of everything in Vibrant Diversity a month later,
    and I imported that new JSON file, it would import only the new messages.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 由于异常处理确保了*admin.py*不会导入重复的行，我可以使用此脚本导入来自同一Discord服务器的更新版JSON文件。例如，如果Unicorn
    Riot的渗透者在一个月后使用Discord History Tracker保存了Vibrant Diversity中所有内容的另一份离线副本，并且我导入了这个新的JSON文件，它只会导入新的消息。
- en: 'Once this code was written, I used it to import all of the JSON Discord files
    that I had received from Unicorn Riot. To import data from the Vibrant Diversity
    channel, I would run this command:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦编写了这段代码，我便用它来导入我从Unicorn Riot接收到的所有Discord JSON文件。要导入Vibrant Diversity频道的数据，我会运行以下命令：
- en: '[PRE37]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'And here is the output:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 这是输出：
- en: '[PRE38]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Each plus sign in this output represents a different row of data inserted into
    the database. The *VibrantDiversity.json* file added 1 server, 530 users, 9 channels,
    and a total of 255,349 messages, importing a message at a time.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 输出中的每个加号代表插入到数据库中的不同数据行。*VibrantDiversity.json*文件添加了1个服务器，530个用户，9个频道，和总共255,349条消息，每次导入一条消息。
- en: 'I then used *admin.py* to import the rest of the Discord JSON files I had,
    including chat logs from Anticom, 4th Reich, Ethnoserver, and other leaked servers.
    For example, next I imported one of the smaller servers called Pony Power, which
    I’ll discuss further later in this chapter, like so:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我使用*admin.py*导入了我拥有的其余Discord JSON文件，包括来自Anticom、4th Reich、Ethnoserver和其他泄露服务器的聊天记录。例如，接下来我导入了一个名为Pony
    Power的小型服务器，我将在本章后面进一步讨论，具体如下：
- en: '[PRE39]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'And here is the output from that command (in this case, I’d already imported
    the Vibrant Diversity data, and these two Discord channels had some overlapping
    users, so my script skipped importing some of the users):'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 这是该命令的输出（在这种情况下，我已经导入了Vibrant Diversity数据，并且这两个Discord频道有一些重叠的用户，所以我的脚本跳过了一些用户的导入）：
- en: '[PRE40]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: This JSON file included 50 users. The code skipped 17 of them (displaying dots
    instead of plus signs) because they were already in the database from Vibrant
    Diversity, and it added 33 new users.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 这个JSON文件包含了50个用户。代码跳过了其中17个用户（显示点而非加号），因为他们已经在Vibrant Diversity数据库中，并添加了33个新用户。
- en: My database was now full of neo-Nazi chat logs, preparing me to build a web
    interface to explore them. When you’re building a web app to investigate data,
    you need some data to explore to make sure your app is actually working as intended.
    If I hadn’t imported the actual data first, I would have had to make up and import
    some test data so I’d have something to troubleshoot with while building the web
    app. But I decided to import the real data first because I knew I’d need to write
    that code eventually anyway.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 我的数据库现在充满了新纳粹的聊天记录，这让我准备好构建一个Web界面来浏览它们。当你在构建Web应用以调查数据时，你需要一些数据来探索，以确保你的应用实际上按照预期工作。如果我没有首先导入实际的数据，我就得虚构一些测试数据并导入，以便在构建Web应用时能有一些数据用于调试。但我决定首先导入真实数据，因为我知道最终我无论如何都需要编写那段代码。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Building the Web
    Interface</samp>
  id: totrans-209
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">构建Web界面</samp>
- en: When you build web apps, it’s often useful to split your web pages into reusable
    components, like headers, footers, and sidebars. Individual pages may have their
    own reusable components, too. For example, the page that lists chat messages might
    repeat the same message component for each message on the page. You define these
    components in *templates*, HTML files that can contain variables and logic, like
    <samp class="SANS_TheSansMonoCd_W5Regular_11">if</samp> statements or <samp class="SANS_TheSansMonoCd_W5Regular_11">for</samp>
    loops. You can render a template (convert it into HTML) by passing the template
    file along with variables into a *templating engine*, or code that converts a
    template into HTML.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 在构建Web应用时，通常会将Web页面拆分为可重用的组件，比如页眉、页脚和侧边栏。每个页面也可以有自己的可重用组件。例如，列出聊天消息的页面可能会为页面上的每条消息重复相同的消息组件。你可以在*模板*中定义这些组件，模板是包含变量和逻辑（如<samp
    class="SANS_TheSansMonoCd_W5Regular_11">if</samp>语句或<samp class="SANS_TheSansMonoCd_W5Regular_11">for</samp>循环）的HTML文件。你可以通过将模板文件和变量一起传递给*模板引擎*，即将模板转换为HTML的代码，来渲染模板（将其转换为HTML）。
- en: Flask comes with a popular templating engine called Jinja. To build the web
    interface to explore the chat logs I’d just imported, I started by creating the
    layout template in Jinja. In short, I wrote the HTML code that would make up the
    layout of all of the pages in my web app, but also included Python variables and
    loops. [Listing 14-12](#list14-12) shows the code for *layout.html*, my layout
    template.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: Flask附带了一个流行的模板引擎，叫做Jinja。为了构建用于浏览我刚导入的聊天记录的Web界面，我首先在Jinja中创建了布局模板。简而言之，我编写了构成我Web应用所有页面布局的HTML代码，但也包括了Python变量和循环。[清单14-12](#list14-12)展示了我的布局模板*layout.html*的代码。
- en: '[PRE41]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 14-12: The</samp> <samp
    class="SANS_Futura_Std_Book_11">layout.html</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">layout
    template</samp>'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">清单14-12: </samp><samp class="SANS_Futura_Std_Book_11">layout.html</samp><samp
    class="SANS_Futura_Std_Book_Oblique_I_11">布局模板</samp>'
- en: The code in [Listing 14-12](#list14-12) looks like HTML at a glance, but if
    you look closely you’ll see that it’s actually a Jinja template. For example,
    look at the code that adds the *CSS (Cascading Style Sheets)* file—which defines
    the page’s style—to the page ❶. The HTML syntax for adding a stylesheet is
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: '[清单14-12](#list14-12)中的代码乍一看像HTML，但如果仔细观察，你会发现它实际上是一个Jinja模板。例如，看看那段将*CSS（层叠样式表）*文件——定义页面样式——添加到页面的代码❶。添加样式表的HTML语法是'
- en: '[PRE42]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'where <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">style.css</samp>
    is the path or URL of a CSS file. Instead of an actual filename, the code in [Listing
    14-12](#list14-12) uses this:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 其中，<samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">style.css</samp>是CSS文件的路径或URL。与实际的文件名不同，[清单14-12](#list14-12)中的代码使用了以下内容：
- en: '[PRE43]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: In a Jinja template, putting a Python expression between <samp class="SANS_TheSansMonoCd_W5Regular_11">{{</samp>and}<samp
    class="SANS_TheSansMonoCd_W5Regular_11">}</samp> means Python will evaluate this
    expression when the template is rendered. In this case, [Listing 14-12](#list14-12)
    rendered that line as <samp class="SANS_TheSansMonoCd_W5Regular_11"><link rel=stylesheet
    type=text/css href="/static/style.css"></samp> because the <samp class="SANS_TheSansMonoCd_W5Regular_11">url_for()</samp>
    function, which is part of Flask, returned the <samp class="SANS_TheSansMonoCd_W5Regular_11">/static/style.css</samp>
    string.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 在Jinja模板中，将一个Python表达式放在<samp class="SANS_TheSansMonoCd_W5Regular_11">{{</samp>和<samp
    class="SANS_TheSansMonoCd_W5Regular_11">}</samp>之间，意味着Python会在渲染模板时计算这个表达式。在这个例子中，[清单
    14-12](#list14-12)将该行渲染为<samp class="SANS_TheSansMonoCd_W5Regular_11"><link rel=stylesheet
    type=text/css href="/static/style.css"></samp>，因为Flask中的<samp class="SANS_TheSansMonoCd_W5Regular_11">url_for()</samp>函数返回了<samp
    class="SANS_TheSansMonoCd_W5Regular_11">/static/style.css</samp>字符串。
- en: The template in [Listing 14-12](#list14-12) also included some <samp class="SANS_TheSansMonoCd_W5Regular_11">for</samp>
    loops. In Jinja, you start a <samp class="SANS_TheSansMonoCd_W5Regular_11">for</samp>
    loop with the code <samp class="SANS_TheSansMonoCd_W5Regular_11">{% for</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">item</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">in</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">list</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">%}</samp>
    and end it with <samp class="SANS_TheSansMonoCd_W5Regular_11">{% endfor %}</samp>.
    In the left sidebar of the layout, the template listed all of the Discord servers
    in the databases ❷, looping through the items in the <samp class="SANS_TheSansMonoCd_W5Regular_11">servers</samp>
    list one at a time. (For this template to render properly, I’d need to make sure
    to pass <samp class="SANS_TheSansMonoCd_W5Regular_11">servers</samp> into the
    template as a variable when I render it in the Flask code.) For each server, after
    displaying the server name, it looped through all of the channels in that server
    ❸, getting the list of channels from <samp class="SANS_TheSansMonoCd_W5Regular_11">server.channels</samp>.
    For each channel, the code displayed a link to view messages in that channel followed
    by the number of messages it contains.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: '[清单 14-12](#list14-12)中的模板还包含了一些<samp class="SANS_TheSansMonoCd_W5Regular_11">for</samp>循环。在Jinja中，你可以通过代码<samp
    class="SANS_TheSansMonoCd_W5Regular_11">{% for</samp> <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">item</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">in</samp> <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">list</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">%}</samp>来开始一个<samp class="SANS_TheSansMonoCd_W5Regular_11">for</samp>循环，并通过<samp
    class="SANS_TheSansMonoCd_W5Regular_11">{% endfor %}</samp>来结束它。在布局的左侧边栏中，模板列出了数据库中的所有Discord服务器❷，并依次循环遍历<samp
    class="SANS_TheSansMonoCd_W5Regular_11">servers</samp>列表中的项目。（为了使这个模板正确渲染，我需要确保在Flask代码中渲染模板时将<samp
    class="SANS_TheSansMonoCd_W5Regular_11">servers</samp>作为变量传递给模板。）对于每个服务器，在显示服务器名称后，模板会循环遍历该服务器中的所有频道❸，从<samp
    class="SANS_TheSansMonoCd_W5Regular_11">server.channels</samp>获取频道列表。对于每个频道，代码会显示一个链接，点击后可以查看该频道的消息，并显示该频道包含的消息数量。'
- en: The template also included a search bar at the top of the page ❹, as well as
    a drop-down menu with options to search a specific server or to search them all
    ❺. It also included a list of notification messages ❻ I could use if I wanted
    to display an error message—for example, if I tried loading a link to view messages
    in a channel that didn’t exist in the database. Finally, the template displayed
    the content block for that particular page ❼. While all pages shared this template,
    the content block differed for each page.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 模板还在页面顶部包含了一个搜索框❹，以及一个下拉菜单，用户可以选择搜索特定服务器或搜索所有服务器❺。它还包含了一些通知消息❻，如果我想显示错误消息时可以使用——例如，如果我尝试加载一个链接来查看一个在数据库中不存在的频道的消息。最后，模板显示了该页面特定内容块❼。虽然所有页面都共享这个模板，但每个页面的内容块各不相同。
- en: After starting on my templates, I wrote code for a handful of *routes*, which
    let the web app know which page the user’s web browser was trying to view. In
    web development, you can think of a route as a path for a web page, except it
    can include placeholders. For example, if the web app is hosted at *http://<wbr>localhost:5000*,
    and the Python code defines the route <samp class="SANS_TheSansMonoCd_W5Regular_11">/search</samp>
    for the search page, users can view that route with the URL *http://<wbr>localhost:5000<wbr>/search*.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 在开始编写模板后，我写了几个 *路由* 的代码，这些路由告诉 web 应用程序用户的浏览器正在尝试查看哪个页面。在 web 开发中，你可以将路由视为一个网页的路径，但它可以包含占位符。例如，如果
    web 应用托管在 *http://<wbr>localhost:5000* 上，且 Python 代码为搜索页面定义了 <samp class="SANS_TheSansMonoCd_W5Regular_11">/search</samp>
    路由，那么用户可以通过 URL *http://<wbr>localhost:5000<wbr>/search* 查看该路由。
- en: The home page route (<samp class="SANS_TheSansMonoCd_W5Regular_11">/</samp>),
    shown in [Listing 14-13](#list14-13), was by far the simplest one in my web app.
    This page displayed the message “This is a web app that will let you research
    the alt-right chatroom leak, published by Unicorn Riot.”
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 主页路由（<samp class="SANS_TheSansMonoCd_W5Regular_11">/</samp>），如 [列表 14-13](#list14-13)
    中所示，是我 web 应用中最简单的一个。此页面显示了消息：“这是一个 web 应用，允许你研究由 Unicorn Riot 发布的 Alt-right 聊天室泄露事件。”
- en: '[PRE44]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 14-13: The home page
    route (</samp><samp class="SANS_Futura_Std_Book_Oblique_I_11">/)</samp>'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">列表 14-13: 主页路由 (</samp><samp
    class="SANS_Futura_Std_Book_Oblique_I_11">/)</samp>'
- en: In Flask, each route is a function that returns the HTML for that web page.
    The <samp class="SANS_TheSansMonoCd_W5Regular_11">index()</samp> function starts
    with the <samp class="SANS_TheSansMonoCd_W5Regular_11">@app.route("/")</samp>
    decorator, which is how Flask knows that the <samp class="SANS_TheSansMonoCd_W5Regular_11">/</samp>
    route should call this function. This function first runs a SQL query to get all
    of the servers in the database, stored in the variable <samp class="SANS_TheSansMonoCd_W5Regular_11">servers</samp>.
    It then calls the <samp class="SANS_TheSansMonoCd_W5Regular_11">render_template()</samp>
    function, rendering the *index.html* template, passing the <samp class="SANS_TheSansMonoCd_W5Regular_11">servers</samp>
    variable into the template, and returning the HTML it receives.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Flask 中，每个路由都是一个返回该网页 HTML 的函数。<samp class="SANS_TheSansMonoCd_W5Regular_11">index()</samp>
    函数以 <samp class="SANS_TheSansMonoCd_W5Regular_11">@app.route("/")</samp> 装饰器开始，这就是
    Flask 知道 <samp class="SANS_TheSansMonoCd_W5Regular_11">/</samp> 路由应该调用这个函数的方式。这个函数首先运行一个
    SQL 查询，从数据库中获取所有服务器，结果存储在变量 <samp class="SANS_TheSansMonoCd_W5Regular_11">servers</samp>
    中。然后，它调用 <samp class="SANS_TheSansMonoCd_W5Regular_11">render_template()</samp>
    函数，渲染 *index.html* 模板，将 <samp class="SANS_TheSansMonoCd_W5Regular_11">servers</samp>
    变量传递给模板，并返回它收到的 HTML。
- en: '[Listing 14-14](#list14-14) shows the code for the *index.html* Jinja template
    that was rendered.'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: '[列表 14-14](#list14-14) 显示了渲染的 *index.html* Jinja 模板的代码。'
- en: '[PRE45]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 14-14: The</samp> <samp
    class="SANS_Futura_Std_Book_11">index.html</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">template</samp>'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">列表 14-14: The</samp> <samp
    class="SANS_Futura_Std_Book_11">index.html</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">模板</samp>'
- en: The first line of code in this template means that Jinja should render the *layout.html*
    template but replace <samp class="SANS_TheSansMonoCd_W5Regular_11">{% block content
    %}{% endblock %}</samp> with the content block defined here—some text that says,
    “Alt-right chatroom research” and a brief description of the web app. Also notice
    that in [Listing 14-13](#list14-13), I passed the <samp class="SANS_TheSansMonoCd_W5Regular_11">servers</samp>
    variable into the template; the *layout.html* template in [Listing 14-11](#list14-11)
    used this variable to make the list of servers in the sidebar.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 这个模板中的第一行代码意味着 Jinja 应该渲染 *layout.html* 模板，但将 <samp class="SANS_TheSansMonoCd_W5Regular_11">{%
    block content %}{% endblock %}</samp> 替换为此处定义的内容块——一些文本，内容是“Alt-right 聊天室研究”，以及对
    web 应用的简要描述。还需要注意的是，在 [列表 14-13](#list14-13) 中，我将 <samp class="SANS_TheSansMonoCd_W5Regular_11">servers</samp>
    变量传递给了模板；在 [列表 14-11](#list14-11) 中的 *layout.html* 模板使用了这个变量来在侧边栏中列出服务器。
- en: '[Figure 14-3](#fig14-3) shows what the app’s home page looked like at this
    point, with the home page text as defined in *index.html* and with the servers
    on the left and the search bar at the top as defined in *layout.html*.'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 14-3](#fig14-3) 显示了此时应用程序主页的样子，主页文本来自于 *index.html*，左侧是服务器，顶部是搜索栏，这些都在 *layout.html*
    中定义。'
- en: '![A screenshot of my Discord Analysis web app with the header “Alt-right chatroom
    research.” The sidebar lists all of the Discord servers and channels imported
    in the database.](Images/Figure14-3.png)'
  id: totrans-231
  prefs: []
  type: TYPE_IMG
  zh: '![我的 Discord 分析 Web 应用程序的截图，标题为“极右聊天室研究”。侧边栏列出了所有导入数据库的 Discord 服务器和频道。](Images/Figure14-3.png)'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 14-3: The home page
    of my Discord Analysis web app</samp>'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">图 14-3：我的 Discord 分析 Web 应用的主页</samp>
- en: 'Let’s look at one more route that does a bit more than the <samp class="SANS_TheSansMonoCd_W5Regular_11">/</samp>
    route, the <samp class="SANS_TheSansMonoCd_W5Regular_11">/search</samp> route,
    which will help explain how one of the web app’s core features—searching the chat
    logs—works. Here’s the Python code:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们再看一个比 <samp class="SANS_TheSansMonoCd_W5Regular_11">/</samp> 路由做得更多的路由——<samp
    class="SANS_TheSansMonoCd_W5Regular_11">/search</samp> 路由，它将帮助解释我们 Web 应用的核心功能之一——搜索聊天记录是如何工作的。下面是
    Python 代码：
- en: '[PRE46]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: The <samp class="SANS_TheSansMonoCd_W5Regular_11">search()</samp> function starts
    with the decorator <samp class="SANS_TheSansMonoCd_W5Regular_11">@app.route("/search")</samp>,
    so Flask knows that the <samp class="SANS_TheSansMonoCd_W5Regular_11">/search</samp>
    route should call this function. At the beginning of the function, I defined the
    <samp class="SANS_TheSansMonoCd_W5Regular_11">q</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">s</samp>,
    <samp class="SANS_TheSansMonoCd_W5Regular_11">page</samp>, and <samp class="SANS_TheSansMonoCd_W5Regular_11">per_page</samp>
    variables as the values from the URL’s query string. For example, if the URL ends
    in */search?q*=*berkeley*, then this code would set the value of <samp class="SANS_TheSansMonoCd_W5Regular_11">q</samp>
    to the <samp class="SANS_TheSansMonoCd_W5Regular_11">berkeley</samp>.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W5Regular_11">search()</samp> 函数以装饰器 <samp class="SANS_TheSansMonoCd_W5Regular_11">@app.route("/search")</samp>
    开始，这样 Flask 就知道 <samp class="SANS_TheSansMonoCd_W5Regular_11">/search</samp> 路由应该调用这个函数。在函数的开头，我将
    <samp class="SANS_TheSansMonoCd_W5Regular_11">q</samp>、<samp class="SANS_TheSansMonoCd_W5Regular_11">s</samp>、<samp
    class="SANS_TheSansMonoCd_W5Regular_11">page</samp> 和 <samp class="SANS_TheSansMonoCd_W5Regular_11">per_page</samp>
    变量定义为 URL 查询字符串中的值。例如，如果 URL 以 */search?q*=*berkeley* 结尾，那么这段代码会将 <samp class="SANS_TheSansMonoCd_W5Regular_11">q</samp>
    的值设置为 <samp class="SANS_TheSansMonoCd_W5Regular_11">berkeley</samp>。
- en: I got this query string information from the Flask variable <samp class="SANS_TheSansMonoCd_W5Regular_11">request.args</samp>,
    which is a dictionary containing all of the values after the <samp class="SANS_TheSansMonoCd_W5Regular_11">?</samp>
    in the URL. The code got the value of the <samp class="SANS_TheSansMonoCd_W5Regular_11">q</samp>
    key in this dictionary by evaluating <samp class="SANS_TheSansMonoCd_W5Regular_11">request.args.get("q")</samp>,
    but <samp class="SANS_TheSansMonoCd_W5Regular_11">request.args["q"]</samp> would
    work just the same. When using the <samp class="SANS_TheSansMonoCd_W5Regular_11">.get()</samp>
    method on dictionaries, you can choose default values, as I did in the following
    line. The expression <samp class="SANS_TheSansMonoCd_W5Regular_11">request.args.get("s",
    0)</samp> looks through <samp class="SANS_TheSansMonoCd_W5Regular_11">request.args</samp>
    for the key <samp class="SANS_TheSansMonoCd_W5Regular_11">s</samp> and returns
    it if it finds it. If the expression doesn’t find <samp class="SANS_TheSansMonoCd_W5Regular_11">s</samp>,
    it returns <samp class="SANS_TheSansMonoCd_W5Regular_11">0</samp>.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 我从 Flask 变量 <samp class="SANS_TheSansMonoCd_W5Regular_11">request.args</samp>
    中获取了这个查询字符串信息，它是一个字典，包含了 URL 中 <samp class="SANS_TheSansMonoCd_W5Regular_11">?</samp>
    后的所有值。代码通过评估 <samp class="SANS_TheSansMonoCd_W5Regular_11">request.args.get("q")</samp>
    获取了这个字典中 <samp class="SANS_TheSansMonoCd_W5Regular_11">q</samp> 键的值，但 <samp class="SANS_TheSansMonoCd_W5Regular_11">request.args["q"]</samp>
    也能正常工作。使用字典的 <samp class="SANS_TheSansMonoCd_W5Regular_11">.get()</samp> 方法时，你可以选择默认值，正如我在下面的代码行中所做的那样。表达式
    <samp class="SANS_TheSansMonoCd_W5Regular_11">request.args.get("s", 0)</samp>
    会在 <samp class="SANS_TheSansMonoCd_W5Regular_11">request.args</samp> 中查找 <samp
    class="SANS_TheSansMonoCd_W5Regular_11">s</samp> 键，并在找到时返回它。如果没有找到 <samp class="SANS_TheSansMonoCd_W5Regular_11">s</samp>，则返回
    <samp class="SANS_TheSansMonoCd_W5Regular_11">0</samp>。
- en: On the search page, <samp class="SANS_TheSansMonoCd_W5Regular_11">q</samp> is
    the search query and <samp class="SANS_TheSansMonoCd_W5Regular_11">s</samp> is
    the ID of the server to search (if <samp class="SANS_TheSansMonoCd_W5Regular_11">s</samp>
    is <samp class="SANS_TheSansMonoCd_W5Regular_11">0</samp>, this means I want to
    search all servers). The <samp class="SANS_TheSansMonoCd_W5Regular_11">page</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">per_page</samp> variables are
    used for *pagination*, which determines how an app displays a limited number of
    results per page. The <samp class="SANS_TheSansMonoCd_W5Regular_11">page</samp>
    variable is the page number, and <samp class="SANS_TheSansMonoCd_W5Regular_11">per_page</samp>
    is the number of results per page.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 在搜索页面中，<samp class="SANS_TheSansMonoCd_W5Regular_11">q</samp> 是搜索查询，<samp class="SANS_TheSansMonoCd_W5Regular_11">s</samp>
    是要搜索的服务器 ID（如果 <samp class="SANS_TheSansMonoCd_W5Regular_11">s</samp> 为 <samp
    class="SANS_TheSansMonoCd_W5Regular_11">0</samp>，则表示我想搜索所有服务器）。<samp class="SANS_TheSansMonoCd_W5Regular_11">page</samp>
    和 <samp class="SANS_TheSansMonoCd_W5Regular_11">per_page</samp> 变量用于 *分页*，它决定了应用每页显示多少个结果。<samp
    class="SANS_TheSansMonoCd_W5Regular_11">page</samp> 变量表示页码，<samp class="SANS_TheSansMonoCd_W5Regular_11">per_page</samp>
    表示每页的结果数量。
- en: Since three of the routes in my app used pagination (<samp class="SANS_TheSansMonoCd_W5Regular_11">/search</samp>,
    <samp class="SANS_TheSansMonoCd_W5Regular_11">/channel</samp>, and <samp class="SANS_TheSansMonoCd_W5Regular_11">/user</samp>),
    I wrote the code to find the <samp class="SANS_TheSansMonoCd_W5Regular_11">page</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">per_page</samp> query strings
    in the function <samp class="SANS_TheSansMonoCd_W5Regular_11">get_pagination_args()</samp>,
    which allowed me to just call that function instead of repeating the same code
    in multiple places.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我的应用中有三个路由使用了分页（<samp class="SANS_TheSansMonoCd_W5Regular_11">/search</samp>、<samp
    class="SANS_TheSansMonoCd_W5Regular_11">/channel</samp> 和 <samp class="SANS_TheSansMonoCd_W5Regular_11">/user</samp>），我编写了代码来查找函数
    <samp class="SANS_TheSansMonoCd_W5Regular_11">get_pagination_args()</samp> 中的
    <samp class="SANS_TheSansMonoCd_W5Regular_11">page</samp> 和 <samp class="SANS_TheSansMonoCd_W5Regular_11">per_page</samp>
    查询字符串，这样我就可以直接调用该函数，而无需在多个地方重复相同的代码。
- en: I then queried the SQL database for the server with the ID stored in <samp class="SANS_TheSansMonoCd_W5Regular_11">s</samp>,
    saving the result as <samp class="SANS_TheSansMonoCd_W5Regular_11">server</samp>.
    The <samp class="SANS_TheSansMonoCd_W5Regular_11">server</samp> variable is used
    to optionally search a single Discord server, rather than all of them. If the
    SQL database doesn’t have any servers with that ID, then <samp class="SANS_TheSansMonoCd_W5Regular_11">server</samp>
    is set to <samp class="SANS_TheSansMonoCd_W5Regular_11">None</samp>, which means
    the app should search all servers. I then started building the SQL query to search
    for all of the messages, storing the results in the variable <samp class="SANS_TheSansMonoCd_W5Regular_11">messages</samp>.
    If this search was limited to a specific server (that is, if there’s a value for
    <samp class="SANS_TheSansMonoCd_W5Regular_11">s</samp>), the code modified <samp
    class="SANS_TheSansMonoCd_W5Regular_11">messages</samp> to filter just by messages
    from that server. Finally, I used the SQLAlchemy pagination feature to run the
    SQL query, making sure to select the correct page of results, storing the search
    results in the variable <samp class="SANS_TheSansMonoCd_W5Regular_11">pagination</samp>.
    Part of the SQLAlchemy query included <samp class="SANS_TheSansMonoCd_W5Regular_11">Message.message.like(f"%{q}%")</samp>
    to ultimately run a SQL query that used SQL’s <samp class="SANS_TheSansMonoCd_W5Regular_11">LIKE</samp>
    operator, which did a case-insensitive search for any messages containing the
    string <samp class="SANS_TheSansMonoCd_W5Regular_11">q</samp>, as described in
    [Chapter 12](chapter12.xhtml).
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我查询了 SQL 数据库，查找存储在 <samp class="SANS_TheSansMonoCd_W5Regular_11">s</samp>
    中的服务器 ID，并将结果保存在 <samp class="SANS_TheSansMonoCd_W5Regular_11">server</samp> 变量中。<samp
    class="SANS_TheSansMonoCd_W5Regular_11">server</samp> 变量可用于选择性地搜索单个 Discord 服务器，而不是所有服务器。如果
    SQL 数据库中没有该 ID 的服务器，则 <samp class="SANS_TheSansMonoCd_W5Regular_11">server</samp>
    被设置为 <samp class="SANS_TheSansMonoCd_W5Regular_11">None</samp>，这意味着应用程序将搜索所有服务器。接着，我开始构建
    SQL 查询，搜索所有消息，将结果存储在 <samp class="SANS_TheSansMonoCd_W5Regular_11">messages</samp>
    变量中。如果此次搜索限定在特定服务器（也就是说，如果 <samp class="SANS_TheSansMonoCd_W5Regular_11">s</samp>
    有值），代码会修改 <samp class="SANS_TheSansMonoCd_W5Regular_11">messages</samp>，仅筛选该服务器的消息。最后，我使用
    SQLAlchemy 分页功能执行 SQL 查询，确保选择正确的结果页，并将搜索结果存储在 <samp class="SANS_TheSansMonoCd_W5Regular_11">pagination</samp>
    变量中。SQLAlchemy 查询的一部分包括 <samp class="SANS_TheSansMonoCd_W5Regular_11">Message.message.like(f"%{q}%")</samp>，最终执行使用
    SQL 的 <samp class="SANS_TheSansMonoCd_W5Regular_11">LIKE</samp> 运算符的 SQL 查询，进行不区分大小写的搜索，查找任何包含字符串
    <samp class="SANS_TheSansMonoCd_W5Regular_11">q</samp> 的消息，正如 [第12章](chapter12.xhtml)
    中所描述的。
- en: In the following <samp class="SANS_TheSansMonoCd_W5Regular_11">if</samp> statement,
    my code defined the <samp class="SANS_TheSansMonoCd_W5Regular_11">description</samp>
    variable as a description of the search, showing either just the search query
    or both it and the name of the server being searched. It then loaded all of the
    servers with <samp class="SANS_TheSansMonoCd_W5Regular_11">servers</samp> <samp
    class="SANS_TheSansMonoCd_W5Regular_11">=</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">Server.query.all()</samp>,
    which the *layout.html* layout template needs to render the sidebar. Finally,
    the code rendered the *results.html* Jinja template, passing in all of the appropriate
    variables, resulting in the search results page.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下的 <samp class="SANS_TheSansMonoCd_W5Regular_11">if</samp> 语句中，我的代码将 <samp
    class="SANS_TheSansMonoCd_W5Regular_11">description</samp> 变量定义为搜索的描述，显示搜索查询的内容，或者同时显示搜索查询和正在搜索的服务器名称。接着，它加载了所有服务器，代码为
    <samp class="SANS_TheSansMonoCd_W5Regular_11">servers</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">=</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">Server.query.all()</samp>，这是 *layout.html*
    布局模板渲染侧边栏所需的。最后，代码渲染了 *results.html* Jinja 模板，传递了所有适当的变量，从而生成了搜索结果页面。
- en: 'In addition to the home page route (<samp class="SANS_TheSansMonoCd_W5Regular_11">/</samp>)
    and the search route (<samp class="SANS_TheSansMonoCd_W5Regular_11">/search</samp>),
    I created these other routes for my web app:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 除了首页路由（<samp class="SANS_TheSansMonoCd_W5Regular_11">/</samp>）和搜索路由（<samp class="SANS_TheSansMonoCd_W5Regular_11">/search</samp>），我为我的
    Web 应用创建了以下其他路由：
- en: <samp class="SANS_TheSansMonoCd_W7Bold_B_11">/view/</samp><samp class="SANS_TheSansMonoCd_W7Bold_Italic_BI_11">message_id</samp> The
    hyperlink to a specific Discord message
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W7Bold_B_11">/view/</samp><samp class="SANS_TheSansMonoCd_W7Bold_Italic_BI_11">message_id</samp> 指向特定
    Discord 消息的超链接
- en: <samp class="SANS_TheSansMonoCd_W7Bold_B_11">/channel/</samp><samp class="SANS_TheSansMonoCd_W7Bold_Italic_BI_11">channel_id</samp> The
    hyperlink to a specific channel in a Discord server
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W7Bold_B_11">/channel/</samp><samp class="SANS_TheSansMonoCd_W7Bold_Italic_BI_11">channel_id</samp> 指向Discord服务器中特定频道的超链接
- en: <samp class="SANS_TheSansMonoCd_W7Bold_B_11">/users</samp> A page that listed
    all Discord users in the database, along with how many messages each has posted
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W7Bold_B_11">/users</samp> 列出了数据库中所有Discord用户的页面，并显示每个用户发布了多少条消息
- en: <samp class="SANS_TheSansMonoCd_W7Bold_B_11">/users/</samp><samp class="SANS_TheSansMonoCd_W7Bold_Italic_BI_11">user_id</samp> A
    page that listed the messages that each Discord user has posted, spanned across
    all servers and channels that they posted in
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W7Bold_B_11">/users/</samp><samp class="SANS_TheSansMonoCd_W7Bold_Italic_BI_11">user_id</samp> 列出每个Discord用户在所有服务器和频道中发布的消息的页面
- en: As you can see in [Figure 14-3](#fig14-3), the Discord servers that I imported
    while developing the app are all listed in the left sidebar, along with each server’s
    channels. To start my research, I could search for keywords (using the <samp class="SANS_TheSansMonoCd_W5Regular_11">/search</samp>
    route), or I could click a channel name on the left and read its chat logs (using
    the <samp class="SANS_TheSansMonoCd_W5Regular_11">/channel/</samp><samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">channel_id</samp>
    route).
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 如你在[图14-3](#fig14-3)中看到的，我在开发应用程序时导入的Discord服务器都列在左侧边栏中，并且每个服务器的频道也一并列出。为了开始我的研究，我可以搜索关键字（使用<samp
    class="SANS_TheSansMonoCd_W5Regular_11">/search</samp>路由），或者我也可以点击左侧的频道名称，查看其聊天记录（使用<samp
    class="SANS_TheSansMonoCd_W5Regular_11">/channel/</samp><samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">channel_id</samp>路由）。
- en: You can view the code for all of these routes in *app.py* at [*https://<wbr>github<wbr>.com<wbr>/micahflee<wbr>/hacks<wbr>-leaks<wbr>-and<wbr>-revelations<wbr>/blob<wbr>/main<wbr>/chapter<wbr>-14<wbr>/discord<wbr>-analysis<wbr>/app<wbr>.py*](https://github.com/micahflee/hacks-leaks-and-revelations/blob/main/chapter-14/discord-analysis/app.py).
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在[*https://<wbr>github<wbr>.com<wbr>/micahflee<wbr>/hacks<wbr>-leaks<wbr>-and<wbr>-revelations<wbr>/blob<wbr>/main<wbr>/chapter<wbr>-14<wbr>/discord<wbr>-analysis<wbr>/app<wbr>.py*](https://github.com/micahflee/hacks-leaks-and-revelations/blob/main/chapter-14/discord-analysis/app.py)查看所有这些路由的代码，代码位于*app.py*中。
- en: Now that you know how the Discord Analysis web app works, let’s look at how
    I went about using it to analyze the Discord leaks.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经了解了Discord分析Web应用程序的工作原理，让我们来看看我如何使用它来分析Discord泄漏数据。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Using Discord Analysis
    to Find Revelations</samp>
  id: totrans-249
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">使用Discord分析工具查找揭示信息</samp>
- en: After I had built enough of the Discord Analysis web app that I could start
    using it for actual research, I started by reading a cross section of all of the
    Discord leaks I had imported and taking notes on what might make good articles—all
    the while fixing bugs as I discovered them, and adding features as I felt I needed
    them. I went one Discord server at a time, trying to understand the gist of what
    was discussed in each channel. I searched for terms like *WikiLeaks* to see what
    the fascists were saying about it, since it had recently played a role in Trump’s
    2016 election victory. I stumbled upon various conversations about digital security
    advice and which encrypted messaging apps to trust, all of it mixed up with numerous
    conspiracy theories, racist diatribes, and selfies of people holding guns.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 当我构建好足够的Discord分析Web应用程序，能够开始实际研究时，我首先开始阅读我导入的所有Discord泄漏数据的交叉部分，并记录下哪些内容可能成为好的文章——在此过程中，我不断修复发现的bug，并根据需要添加功能。我逐一查看Discord服务器，尝试理解每个频道中讨论的要点。我搜索了像*WikiLeaks*这样的术语，看看法西斯分子在说些什么，因为它在特朗普2016年竞选胜利中起了作用。我偶然发现了各种关于数字安全建议的对话，以及信任哪些加密通讯应用的讨论，所有这些都与众多阴谋论、种族主义言论和持枪自拍混杂在一起。
- en: 'Here’s how the process of using Discord Analysis on my computer actually worked.
    When I wanted to run my web app to test it during development or to start researching
    neo-Nazi chats, I’d run <samp class="SANS_TheSansMonoCd_W5Regular_11">python3
    app.py</samp>. It showed this output, which is the typical output you see every
    time you start a Flask web app:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是我在电脑上使用Discord分析工具的实际过程。当我想在开发过程中运行我的Web应用程序进行测试，或者开始研究新纳粹聊天时，我会运行<samp class="SANS_TheSansMonoCd_W5Regular_11">python3
    app.py</samp>。它会显示这种输出，这也是你每次启动Flask Web应用程序时看到的典型输出：
- en: '[PRE47]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'The output said that the Flask web server started and was running at the URL
    *http://<wbr>127<wbr>.0<wbr>.0<wbr>.1:5000*. The web server continued to run until
    I was ready to quit it by pressing CTRL-C. I loaded that URL in my web browser
    to view the web app. As I made web requests, my terminal output showed me web
    service logs. For example, when I loaded the home page, my app produced these
    logs:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 输出显示Flask Web服务器已启动，并在URL *http://<wbr>127<wbr>.0<wbr>.0<wbr>.1:5000* 运行。Web服务器将一直运行，直到我通过按CTRL-C准备退出它。我在浏览器中加载了该URL以查看Web应用程序。当我发起Web请求时，我的终端输出显示了Web服务日志。例如，当我加载主页时，我的应用程序生成了这些日志：
- en: '[PRE48]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: The left column is the IP address (<samp class="SANS_TheSansMonoCd_W5Regular_11">127.0.0.1</samp>)
    of the web browser that loaded each route; in this case, I loaded routes from
    my own computer. It also shows the timestamp the route was loaded, which route
    was loaded, and other information. The first route that I loaded was the home
    page (you can tell because the first log line says <samp class="SANS_TheSansMonoCd_W5Regular_11">GET
    /</samp>), and it responded with the HTTP code <samp class="SANS_TheSansMonoCd_W5Regular_11">200</samp>,
    which means it loaded successfully. Immediately after that, my browser loaded
    the CSS stylesheet at <samp class="SANS_TheSansMonoCd_W5Regular_11">/static/style.css</samp>,
    which successfully loaded too, and tried to load the favicon (the icon in the
    corner of a web browser tab) at <samp class="SANS_TheSansMonoCd_W5Regular_11">/favicon.ico</samp>.
    However, the server replied with the HTTP code <samp class="SANS_TheSansMonoCd_W5Regular_11">404</samp>,
    “File not found,” because I hadn’t bothered creating a favicon for my app.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 左侧列显示了加载每个路由的网页浏览器的IP地址（<samp class="SANS_TheSansMonoCd_W5Regular_11">127.0.0.1</samp>）；在这个例子中，我是从我自己的计算机加载路由的。它还显示了路由加载的时间戳、加载了哪个路由以及其他信息。我加载的第一个路由是主页（你可以从第一行日志中看出来，日志上写着<samp
    class="SANS_TheSansMonoCd_W5Regular_11">GET /</samp>），并且响应了HTTP代码<samp class="SANS_TheSansMonoCd_W5Regular_11">200</samp>，意味着加载成功。紧接着，我的浏览器加载了CSS样式表<samp
    class="SANS_TheSansMonoCd_W5Regular_11">/static/style.css</samp>，并且也加载成功了，还尝试加载了位于<samp
    class="SANS_TheSansMonoCd_W5Regular_11">/favicon.ico</samp>的favicon（浏览器标签页角落的图标）。然而，服务器返回了HTTP代码<samp
    class="SANS_TheSansMonoCd_W5Regular_11">404</samp>，表示“文件未找到”，因为我没有为我的应用程序创建favicon。
- en: 'At the top of each page in the web app was a search bar, next to which was
    the drop-down menu that let me choose to search all servers or just one. For example,
    I tried searching all Discord servers from which I had imported data for the string
    <samp class="SANS_TheSansMonoCd_W5Regular_11">berkeley</samp>. Back in my terminal,
    I could see that my browser had loaded the <samp class="SANS_TheSansMonoCd_W5Regular_11">/search?q=berkeley&s=</samp>
    route:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 在Web应用程序的每个页面顶部都有一个搜索框，旁边是一个下拉菜单，允许我选择搜索所有服务器或仅搜索某一个。例如，我尝试在所有我导入数据的Discord服务器中搜索字符串<samp
    class="SANS_TheSansMonoCd_W5Regular_11">berkeley</samp>。在我的终端中，我可以看到浏览器加载了<samp
    class="SANS_TheSansMonoCd_W5Regular_11">/search?q=berkeley&s=</samp>路由：
- en: '[PRE49]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: The search page loaded the CSS stylesheet at <samp class="SANS_TheSansMonoCd_W5Regular_11">/static/style.css</samp>
    as well, but this time it returned with the HTTP code <samp class="SANS_TheSansMonoCd_W5Regular_11">304</samp>,
    which means that the stylesheet hadn’t been modified since the last time my browser
    made that request.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 搜索页面也加载了CSS样式表<samp class="SANS_TheSansMonoCd_W5Regular_11">/static/style.css</samp>，但这次返回了HTTP代码<samp
    class="SANS_TheSansMonoCd_W5Regular_11">304</samp>，意味着自上次浏览器发起请求以来，样式表没有被修改。
- en: '[Figure 14-4](#fig14-4) shows the Discord Analysis web app showing these search
    results. You can see that the page has the URL *http://127.0.0.1:5000/search?q*=*berkeley&s*=
    and lists search results from all servers for the string <samp class="SANS_TheSansMonoCd_W5Regular_11">berkeley</samp>.'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: '[图14-4](#fig14-4)显示了Discord分析Web应用程序显示这些搜索结果。你可以看到页面的URL是*http://127.0.0.1:5000/search?q*=*berkeley&s*=，并列出了所有服务器中包含字符串<samp
    class="SANS_TheSansMonoCd_W5Regular_11">berkeley</samp>的搜索结果。'
- en: '![A screenshot of my Discord Analysis web app showing search results for the
    search term “berkeley.” The sidebar lists all of the Discord servers and channels
    imported in the database. There are 417 messages that include the word “berkeley,”
    and these messages are displayed with the search term highlighted.](Images/Figure14-4.png)'
  id: totrans-260
  prefs: []
  type: TYPE_IMG
  zh: '![我的Discord分析Web应用程序的截图，显示了搜索词“berkeley”的搜索结果。侧边栏列出了数据库中导入的所有Discord服务器和频道。共有417条包含“berkeley”一词的消息，这些消息显示出来时，搜索词被高亮显示。](Images/Figure14-4.png)'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 14-4: Searching for
    the string berkeley in my Discord Analysis web app</samp>'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">图14-4：在我的Discord分析Web应用程序中搜索字符串berkeley</samp>
- en: My search found 417 messages that contained the string <samp class="SANS_TheSansMonoCd_W5Regular_11">berkeley</samp>,
    along with information on who posted each message, in what channel, in what server,
    at what time, and the content of the message, with the search term itself highlighted.
    If I clicked on the user’s name, which linked to the <samp class="SANS_TheSansMonoCd_W5Regular_11">/users/</samp><samp
    class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">user_id</samp> route, I’d see
    all of the posts from that user, including those on multiple Discord servers.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 我的搜索找到了417条包含字符串<samp class="SANS_TheSansMonoCd_W5Regular_11">berkeley</samp>的消息，并且显示了每条消息的发布者、所在频道、所在服务器、发布时间以及消息内容，搜索词本身被高亮显示。如果我点击用户的名字，它会链接到<samp
    class="SANS_TheSansMonoCd_W5Regular_11">/users/</samp><samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">user_id</samp>路由，我将看到该用户的所有帖子，包括在多个Discord服务器上的帖子。
- en: Each message also had a view link, which led to the <samp class="SANS_TheSansMonoCd_W5Regular_11">/view/</samp><samp
    class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">message_id</samp> route and pulled
    up a page displaying that individual message. This allowed me to store links to
    individual messages in my notes. When I clicked on a view link I’d saved, the
    web app would show me not only that message but also the 20 messages before and
    after it, so I could easily see the rest of the conversation.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 每条消息还提供了一个查看链接，链接到<samp class="SANS_TheSansMonoCd_W5Regular_11">/view/</samp><samp
    class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">message_id</samp>路由，显示该条消息的页面。这让我能够将单独消息的链接保存在我的笔记中。当我点击保存的查看链接时，Web应用程序不仅会显示该条消息，还会显示它前后各20条消息，方便我轻松查看整个对话。
- en: 'The app also allowed me to explore the leaked chats by manually reading through
    each channel. I could select individual channels by clicking the links in the
    left sidebar. For example, [Figure 14-5](#fig14-5) shows the #general channel
    in the Pony Power server. In this case, the URL was *http://<wbr>127<wbr>.0<wbr>.0<wbr>.1:5000<wbr>/channel<wbr>/10*,
    meaning the <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">channel_id</samp>
    in the <samp class="SANS_TheSansMonoCd_W5Regular_11">/channel/</samp><samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">channel_id</samp>
    route was <samp class="SANS_TheSansMonoCd_W5Regular_11">10</samp>. The ID field
    in the <samp class="SANS_TheSansMonoCd_W5Regular_11">Channel</samp> table auto-increments,
    so the first row starts at 1, then 2, then 3, and so on. I imported the Vibrant
    Diversity JSON file first, which created channels with IDs 1 through 9, then imported
    the Pony Power JSON file, which created channels with IDs 10 through 13.'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 该应用程序还允许我通过手动浏览每个频道来探索泄漏的聊天记录。我可以通过点击左侧边栏中的链接选择单独的频道。例如，[图14-5](#fig14-5)显示了Pony
    Power服务器中的#general频道。在这种情况下，URL是*http://<wbr>127<wbr>.0<wbr>.0<wbr>.1:5000<wbr>/channel<wbr>/10*，这意味着在<samp
    class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">channel_id</samp>的<samp class="SANS_TheSansMonoCd_W5Regular_11">/channel/</samp><samp
    class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">channel_id</samp>路由中，<samp class="SANS_TheSansMonoCd_W5Regular_11">channel_id</samp>为10。<samp
    class="SANS_TheSansMonoCd_W5Regular_11">Channel</samp>表中的ID字段会自动递增，所以第一行从1开始，然后是2、3，依此类推。我首先导入了Vibrant
    Diversity JSON文件，这创建了ID为1到9的频道，然后导入了Pony Power JSON文件，这创建了ID为10到13的频道。
- en: '![A screenshot of my Discord Analysis web app. The #general-chat channel in
    the Pony Power server is highlighted on the left, and you can see the messages
    in this server themselves on the right.](Images/Figure14-5.png)'
  id: totrans-265
  prefs: []
  type: TYPE_IMG
  zh: '![我的Discord分析Web应用程序的截图。左侧高亮显示了Pony Power服务器中的#general-chat频道，右侧显示了该服务器中的消息。](Images/Figure14-5.png)'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 14-5: Viewing chat logs
    for the #general-chat channel in the Pony Power server in my Discord Analysis
    web app</samp>'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">图14-5：在我的Discord分析Web应用程序中查看Pony
    Power服务器的#general-chat频道的聊天记录</samp>
- en: With this case study as inspiration, I hope that you’ll feel confident building
    similar custom apps for your future investigations when you get your hands on
    large structured datasets like these.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 以这个案例研究为灵感，我希望当你在未来的调查中接触到类似这样的大型结构化数据集时，能够自信地构建类似的自定义应用程序。
- en: After spending a few days splitting my time between writing code and reading
    some of the worst stuff on the internet, I ultimately decided to write about Pony
    Power, a server set up for the sole purpose of harassing and doxing people.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 在花了几天时间在编写代码和阅读互联网上一些最恶心的内容之间分配时间后，我最终决定写关于Pony Power的报道——这是一个专门用来骚扰和曝光他人的服务器。
- en: <samp class="SANS_Futura_Std_Bold_B_11">The Pony Power Discord Server</samp>
  id: totrans-269
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">Pony Power Discord 服务器</samp>
- en: Pony Power was one of the smaller servers, with only 50 users and just over
    1,000 messages posted over the course of just 10 days. More than any other server,
    it was full of PII for perceived members of antifa. I decided to focus my reporting
    on this server because this harassment campaign was clearly newsworthy, and because
    the server was small enough that I could read through all of the messages and
    write about the highlights. As a single reporter, it would have taken me considerably
    longer to do the same for larger servers, like Vibrant Diversity.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: Pony Power是一个较小的服务器，只有50个用户，且在仅仅10天内发布了1000多条消息。与其他服务器相比，它充满了对反法西斯成员的个人识别信息（PII）。我决定将报道重点放在这个服务器上，因为这一骚扰活动显然具有新闻价值，而且该服务器足够小，我能够浏览所有的消息并撰写亮点。作为一名独立记者，如果是更大的服务器，比如Vibrant
    Diversity，完成同样的工作将需要花费更多时间。
- en: 'In the Pony Power chat logs, I found private data from over 50 people from
    14 states across the country, from California to Florida. The information often
    included users’ photographs, social media profiles, home addresses, phone numbers,
    email addresses, dates of birth, driver’s license numbers, vehicle information,
    places of employment, and in one instance, a Social Security number. As I read
    through the Pony Power chat logs, from the beginning to the end, I built up a
    spreadsheet listing each person who was doxed to help me keep track of them, as
    well as Discord Analysis links to the messages where the doxing happened. The
    server’s #faces-of-rainbow-ponies channel contained nearly all of the PII.'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 在Pony Power聊天记录中，我发现了来自全国14个州、超过50人的私人数据，涵盖了从加利福尼亚到佛罗里达的各地。信息通常包括用户的照片、社交媒体资料、家庭住址、电话号码、电子邮件地址、出生日期、驾驶证号、车辆信息、工作地点，以及在一个案例中，社会保障号码。在阅读Pony
    Power聊天记录的过程中，从头到尾，我建立了一个电子表格，列出每个被曝光的人，以帮助我追踪他们，同时也提供了Discord分析链接，指向曝光发生的消息。服务器的#faces-of-rainbow-ponies频道几乎包含了所有的个人识别信息（PII）。
- en: The Pony Power fascists weren’t very selective about their targets. Anyone they
    considered to be a member of antifa or an antifa sympathizer was fair game, as
    were journalists they disagreed with, professors from liberal universities, or
    anyone who spoke out against racism.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: Pony Power的法西斯分子对他们的目标并不挑剔。任何他们认为是反法西斯（antifa）成员或反法西斯同情者的人都可以成为攻击对象，包括他们意见不合的记者、来自自由主义大学的教授，或者任何反对种族主义的人。
- en: Eight times in 2017, fascists traveled to Berkeley to hold protests. They came
    prepared with racist and antisemitic signs and armed with weapons for street fighting.
    One of these protests, a Say No to Marxism rally, was scheduled for late August.
    In response, antifascists began preparing a counterprotest. “So who is going to
    be there to stand up against Antifa? This is a good chance to dox them so we can
    have an idea who they are,” one of the Pony Power members posted in the chat.
    “We should go onto their [Facebook] page if they have an active one and dox all
    the ones who plan on being there and who liked the post.”
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 2017年，法西斯分子八次前往伯克利举行抗议活动。他们带着种族主义和反犹太的标语，武装着武器准备进行街头斗争。其中一次抗议活动——反马克思主义集会——定于8月下旬举行。对此，反法西斯分子开始准备反抗议活动。“那么，谁会站出来反对反法西斯？这是个很好的机会来曝光他们，了解他们到底是谁，”一名Pony
    Power成员在聊天中发布道。“我们应该去他们的[Facebook]页面，如果他们有活跃的页面，曝光所有计划到场并点赞此帖的人。”
- en: Another Pony Power user posted a link to a website for “white people striving
    to be allies in the fight for Black Liberation” and said, “These white allies
    need doxing.” Another wanted to dox members of the Democratic Socialists of America
    and the Southern Poverty Law Center. Some members of the group disagreed about
    the strategy of doxing everyone they didn’t like, though. “Fuck these random ass
    people to be honest,” another user posted. “We need to dox journalists and leadership
    of activist groups.” A person going by the name *Klaus Albricht* suggested, “It’s
    time we start mapping out the liberal teachers of universities.”
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 另一位Pony Power用户发布了一个网站链接，内容是“白人努力成为黑人解放斗争的盟友”，并表示：“这些白人盟友需要被曝光。”另一位用户则表示要曝光美国民主社会主义者和南方贫困法律中心的成员。有些小组成员对曝光所有他们不喜欢的人这一策略表示异议。“老实说，去他妈的这些随机的人，”另一位用户发帖说。“我们需要曝光记者和激进团体的领导。”一位名为*Klaus
    Albricht*的人建议：“是时候开始列出大学的自由派教师了。”
- en: '*Albricht* decided to dox a 22-year-old college student because her Facebook
    cover photo showed her wearing a shirt reading “Punch more Nazis,” a reference
    to Richard Spencer, a white supremacist best known for the viral video in which
    he is punched in the face while being interviewed. *Albricht* outlined a plan
    to trick her into clicking a malicious link so he could learn her IP address.
    He also said that he would dox people who liked her shirt. Less than 20 minutes
    later, he posted her home address, what she was studying at college, and links
    to all her social media accounts.'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: '*Albricht*决定曝光一位22岁的大学生，因为她的Facebook封面照片显示她穿着印有“打更多纳粹”字样的T恤，这是一句指代理查德·斯宾塞的口号，斯宾塞是一位白人至上主义者，以一段他在接受采访时被打脸的病毒视频而广为人知。*Albricht*制定了一个计划，想通过一个恶意链接来骗她点击，以便他可以获取她的IP地址。他还表示，他会曝光喜欢她T恤的人。不到20分钟后，他就发布了她的家庭地址、她在大学学习的专业以及她所有社交媒体账号的链接。'
- en: While writing my story, I reached out to the woman who was doxed. She told me,
    “I never clicked the link because it seemed hella sketch.” She also said that
    she hadn’t gone out to protest fascists and that she was annoyed that they had
    doxed her just because she hurt their feelings. She was “terrified” that they
    had her address because “it’s not just myself who’s at risk, but now also my parents
    who live here as well.”
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 在写故事的过程中，我联系了这位被曝光的女性。她告诉我：“我从来没有点击那个链接，因为看起来实在太可疑了。”她还表示，她并没有出去抗议法西斯分子，她很生气他们仅仅因为她伤害了他们的感情就曝光了她。她“非常害怕”他们有她的地址，因为“现在不仅是我自己有风险，我的父母也住在这里，他们也受到了威胁。”
- en: In the 10 days’ worth of Pony Power chat logs I had at my disposal, I also found
    the fascists doxing Emily Gorcenski, an antifascist data scientist from Charlottesville
    who had witnessed Fields’s car plow into protesters. She’s a trans woman, and
    the fascists posted her deadname (the name she went by before she transitioned)
    and her home address. She has since moved to Germany.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 在我手头的10天Pony Power聊天记录中，我还发现法西斯分子曝光了Emily Gorcenski的个人信息。Emily是一位来自夏洛茨维尔的反法西斯数据科学家，她曾亲眼目睹Fields的汽车冲撞抗议者。她是一名跨性别女性，法西斯分子发布了她的“死名”（她在过渡前使用的名字）和家庭地址。她后来搬到了德国。
- en: Fascists also doxed 10 alleged members of an antifa group from Gainesville,
    Florida. A user who went by the name *adolphus (not hitler)* posted, “I lost my
    job because of these [homophobic slur]s,” later posting again that he lost his
    job because he attended the Unite the Right rally in Charlottesville, so “I’ve
    got some scores to settle with my local antifa.” I searched the internet for terms
    like *Gainesville Charlottesville fired* and quickly found news articles about
    a Gainesville man who was fired from his job after marching in Charlottesville
    with neo-Nazis. He was a member of the pro-slavery hate group League of the South,
    and he had gotten arrested in Charlottesville for carrying a concealed handgun.
    I tracked down a court document related to his arrest and found one that included
    his phone number. Because I decided to name him in the article, I called him to
    give him a chance to provide his side of the story, per the journalistic practices
    described in [Chapter 1](chapter1.xhtml). To keep my actual phone number private
    from him and the League of the South, I used a new virtual phone number I had
    created just for this purpose (today, I have a public phone number that I use
    solely for communicating with sources like this). I left messages, but he never
    responded.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 法西斯分子还曝光了来自佛罗里达州盖恩斯维尔的一个反法西斯团体的10名成员。一个使用*adolphus (not hitler)*这个名字的用户发布了：“我因为这些[同性恋侮辱词]失去了工作。”后来他再次发帖表示，他因为参加了夏洛茨维尔的“联合右翼”集会而失去了工作，所以“我得和我当地的反法西斯分子算账。”我在网上搜索了*Gainesville
    Charlottesville fired*等关键词，很快就找到了关于一个盖恩斯维尔男子的新闻报道，他因为和新纳粹分子一起在夏洛茨维尔游行而被解雇。他是亲奴隶制仇恨团体“南方联盟”的成员，并且因携带隐藏手枪在夏洛茨维尔被逮捕。我追踪到了一份与他被捕相关的法院文件，并找到了其中包含他电话号码的一份文件。因为我决定在文章中提到他的名字，所以我给他打了电话，按照[第1章](chapter1.xhtml)中描述的新闻实践，给他一个机会提供自己的看法。为了保护我的实际电话号码不被他和南方联盟得知，我使用了一个为此目的专门创建的虚拟电话号码（如今，我有一个公开电话号码，仅用于与像他这样的消息来源沟通）。我留下了信息，但他从未回应。
- en: 'Pony Power members also went after Michael Novick, at the time a 70-year-old
    retired teacher from Los Angeles who had been an antifascist activist for over
    50 years. In the late 1980s, Novick helped found a group called Anti-Racist Action,
    and he’s been dealing with threats from neo-Nazis ever since. Because Novick’s
    name appeared on antiracist websites, Pony Power users decided that he must be
    an antifa leader. “Michael is behind what we know as the power structure,” *Albricht*
    posted. The Pony Power users then hit what they believed to be a gold mine: they
    discovered a video of Novick speaking at the 2011 Los Angeles Housing & Hunger
    Crisis Conference in which he said, “I’m of Jewish descent.” “HE ADMITS HE IS
    JEWISH! I KNEW IT!” *Albricht* exclaimed. “We have our link. Antifa is a Jewish
    organization!” He added, “Now let’s tear these [antisemitic slur]s apart!” and
    began inventing an antifa organization chart that placed Novick on top. “This
    man we know for a fact is the leader of Antifa. […] All other branches report
    to him.”'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: “马力小队”的成员们也针对了迈克尔·诺维克，当时他是一个70岁的洛杉矶退休教师，已经有超过50年的反法西斯活动经验。在80年代末，诺维克帮助创立了一个名为“反种族主义行动”的组织，之后他一直面临着新纳粹分子的威胁。由于诺维克的名字出现在反种族主义网站上，“马力小队”的用户们认为他一定是一个反法西斯领导人。“迈克尔就是我们所知道的权力结构背后的人，”*阿尔布里赫特*发布道。然后，“马力小队”的用户们发现了他们认为的“金矿”：他们找到了诺维克在2011年洛杉矶住房与饥饿危机大会上发言的视频，其中他说：“我是犹太血统。”
    “他承认自己是犹太人！我就知道！”*阿尔布里赫特*兴奋地说道。“我们找到了我们的线索，反法西斯是一个犹太组织！”他补充道：“现在我们要把这些[反犹太侮辱词]撕个粉碎！”并开始编造一个反法西斯组织结构图，把诺维克放在最上面。“我们知道这个人肯定是反法西斯的领袖。
    […] 所有其他分支都向他报告。”
- en: Novick told me it’s no secret that he’s Jewish. “My father came to the US in
    the early ’30s as a teenager from Poland, and most of his family (many aunts,
    uncles, and cousins) were wiped out by the Nazis either in Bialystok during a
    ghetto rebellion or in the camps,” he said. He also told me that there’s no antifa
    “command structure” or “organization chart.” He added, “Some antifa are Jewish.
    Hardly surprising, given the level of antisemitism displayed by the fascists and
    neo-Nazis.”
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 诺维克告诉我，他是犹太人这一点并不是什么秘密。“我父亲在30年代初期作为青少年从波兰来到美国，他的很多家人（包括许多姑姑、叔叔和表亲）都在比亚韦斯托克的贫民区暴动中或在集中营里被纳粹屠杀，”他说。他还告诉我，反法西斯阵营没有“指挥结构”或“组织架构图”。他补充道：“一些反法西斯分子是犹太人。考虑到法西斯分子和新纳粹分子表现出的反犹太主义，这一点并不令人惊讶。”
- en: According to a story by Unicorn Riot reporter Chris Schiano, the Pony Power
    server was started by Dan Kleve. At the time, Kleve was a biochemistry major at
    the University of Nebraska–Lincoln and a member of the neo-Nazi group Vanguard
    America. After Klein was outed as one of the fascists who marched in Charlottesville,
    people began calling the head of his department to demand that he be expelled.
    Schiano wrote that Kleve created the Pony Power server, in apparent retaliation
    against those demanding his expulsion, “to seek revenge by maliciously publishing
    the personal information of alleged antifascists and encouraging others to harass
    them and bring them harm.”
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 根据Unicorn Riot记者Chris Schiano的报道，Pony Power服务器是由Dan Kleve创建的。当时，Kleve是内布拉斯加大学林肯分校的生物化学专业学生，也是新纳粹团体Vanguard
    America的成员。在Kleve被曝光为参加夏洛茨维尔游行的法西斯分子之一后，很多人开始打电话给他的系主任，要求将他开除。Schiano写道，Kleve创建了Pony
    Power服务器，显然是为了报复那些要求他开除的人，“通过恶意发布所谓反法西斯分子的个人信息，并鼓励他人骚扰他们，给他们带来伤害，从而寻求复仇。”
- en: You can read my full reporting on the Pony Power Discord chat logs at [*https://<wbr>theintercept<wbr>.com<wbr>/2017<wbr>/09<wbr>/06<wbr>/how<wbr>-right<wbr>-wing<wbr>-extremists<wbr>-stalk<wbr>-dox<wbr>-and<wbr>-harass<wbr>-their<wbr>-enemies<wbr>/*](https://theintercept.com/2017/09/06/how-right-wing-extremists-stalk-dox-and-harass-their-enemies/).
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以阅读我在Pony Power Discord聊天记录上的完整报告，链接在此：[*https://<wbr>theintercept<wbr>.com<wbr>/2017<wbr>/09<wbr>/06<wbr>/how<wbr>-right<wbr>-wing<wbr>-extremists<wbr>-stalk<wbr>-dox<wbr>-and<wbr>-harass<wbr>-their<wbr>-enemies<wbr>/*](https://theintercept.com/2017/09/06/how-right-wing-extremists-stalk-dox-and-harass-their-enemies/)。
- en: <samp class="SANS_Futura_Std_Bold_B_11">The Launch of DiscordLeaks</samp>
  id: totrans-283
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">DiscordLeaks的发布</samp>
- en: After publishing my Pony Power article, I was sure that there were many more
    revelations spread throughout the hundreds of thousands of messages in the leaked
    chat logs, but I decided I needed a break from Nazis. I wanted to make it possible
    for others to analyze the rest of the Discord servers, though, and I knew from
    my own experience with these datasets that there were technical challenges to
    analyzing them, which is why I developed Discord Analysis to begin with. I spoke
    with the journalists from Unicorn Riot and showed them the Discord Analysis web
    app I had used to write my article. We decided that Unicorn Riot would run a public
    version of this app for researchers, journalists, and members of the public to
    use. This is how DiscordLeaks was born.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 在发布我的Pony Power文章后，我确信在泄露的聊天记录中有更多的揭露散布在成千上万条消息中，但我决定暂时休息一下，远离纳粹。我希望能让其他人也能分析这些Discord服务器，但我知道从我自己处理这些数据集的经验来看，分析它们存在技术挑战，这也是我最初开发Discord
    Analysis的原因。我与Unicorn Riot的记者们进行了交谈，并向他们展示了我用来撰写文章的Discord Analysis网页应用程序。我们决定由Unicorn
    Riot为研究人员、记者和公众运行该应用的公共版本。这就是DiscordLeaks诞生的过程。
- en: DiscordLeaks ([*https://<wbr>discordleaks<wbr>.unicornriot<wbr>.ninja*](https://discordleaks.unicornriot.ninja))
    is a searchable public database designed to make it easy for anyone to access
    the massive corpus of fascist chat logs from hundreds of Discord servers infiltrated
    by antifascists. I and a small team of anonymous developers worked in our spare
    time to add new features to the app and handle the scaling issues that come with
    hosting a public website that gets lots of traffic. We kept the modified source
    code for DiscordLeaks private, but it’s based on the Discord Analysis source code
    that I just described. By late 2017, DiscordLeaks was live, and by early 2018
    it was full of chat logs from several Discord servers uploaded by Unicorn Riot
    journalists, including the one used to organize Unite the Right. The only redactions
    to the chat logs on DiscordLeaks are the PII for victims of doxing and harassment
    by far-right extremists; the rest of the data is fully public.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: DiscordLeaks（[*https://<wbr>discordleaks<wbr>.unicornriot<wbr>.ninja*](https://discordleaks.unicornriot.ninja)）是一个可搜索的公共数据库，旨在方便任何人访问由反法西斯分子渗透的数百个Discord服务器中的庞大法西斯聊天记录。我和一小组匿名开发者在业余时间工作，给这个应用程序增加新功能，并处理托管高流量公共网站时出现的扩展问题。我们将修改后的DiscordLeaks源代码保密，但它基于我刚才描述的Discord
    Analysis源代码。到2017年底，DiscordLeaks已经上线，到了2018年初，它充满了由Unicorn Riot记者上传的多个Discord服务器的聊天记录，其中包括用于组织“团结右翼”活动的服务器。DiscordLeaks上的聊天记录唯一被删减的部分是受到极右翼分子恶意揭露和骚扰的受害者的个人身份信息（PII）；其余数据都是完全公开的。
- en: 'Over the years, Unicorn Riot has obtained a steady stream of leaked Discord
    chat logs from fascist groups and continued to index them into DiscordLeaks. I
    eventually stopped contributing to the project myself. In the time I’ve been away,
    it’s matured: the infrastructure is now running in Docker containers, and the
    speed of search has greatly improved thanks to the addition of an Elasticsearch
    database (both technologies were discussed in [Chapter 5](chapter5.xhtml)). Today,
    DiscordLeaks contains millions of messages from nearly 300 Discord servers used
    by the far right, available for the public to research. It also contains chat
    logs from RocketChat servers, which I discuss in the next section.'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 多年来，Unicorn Riot不断获取来自法西斯团体的Discord聊天记录，并将其继续编入DiscordLeaks。我最终停止了对该项目的贡献。在我离开的这段时间里，它逐渐成熟：现在基础设施已经运行在Docker容器中，得益于加入了Elasticsearch数据库，搜索速度有了大幅提升（这两项技术在[第五章](chapter5.xhtml)中讨论过）。如今，DiscordLeaks包含了来自近300个极右翼Discord服务器的数百万条消息，供公众进行研究。它还包含了来自RocketChat服务器的聊天记录，这部分内容将在下一节中讨论。
- en: <samp class="SANS_Futura_Std_Bold_B_11">The Aftermath</samp>
  id: totrans-287
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">后果</samp>
- en: By 2019, I had stopped writing code for DiscordLeaks myself, but I still kept
    in touch with the developers and promoted the website. I was proud of my role
    in developing this important tool for extremism research, but at the time I still
    had no idea how much positive impact it would ultimately have.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 到2019年，我已不再亲自为DiscordLeaks编写代码，但我仍与开发者保持联系，并继续宣传该网站。我为自己在开发这个重要的极端主义研究工具中所扮演的角色感到自豪，但那时我仍然不知道它最终会产生多大的积极影响。
- en: 'In this section I’ll discuss two major developments in the DiscordLeaks project
    since I wrote the initial code back in 2017\. In 2021, survivors of the Charlottesville
    terrorist attack won a $25 million settlement against the organizers of Unite
    the Right in a lawsuit made possible, in part, by evidence published on DiscordLeaks.
    DiscordLeaks continues to be a vital tool for extremism researchers: in 2022,
    DiscordLeaks’ anonymous developers updated it to include another major leak of
    neo-Nazi chat logs, this time from the group Patriot Front.'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我将讨论自2017年我编写初始代码以来，DiscordLeaks项目的两大发展。2021年，夏洛茨维尔恐怖袭击的幸存者通过DiscordLeaks发布的证据，在一场诉讼中赢得了2500万美元的和解金。这场诉讼在一定程度上得益于DiscordLeaks上的证据。DiscordLeaks仍然是极端主义研究人员的重要工具：2022年，DiscordLeaks的匿名开发者更新了该工具，增加了另一起来自新纳粹组织“爱国阵线”（Patriot
    Front）的聊天记录泄露。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">The Lawsuit Against
    Unite the Right</samp>
  id: totrans-290
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">对“联合右翼”组织的诉讼</samp>
- en: In 1871, in response to the wave of racist terrorism against Black people that
    swept the South after the end of the Civil War, the US Congress passed the Ku
    Klux Klan Act. This law allows victims of racist violence to sue the perpetrators
    in civil court. If the victims can prove there was a conspiracy to deprive them
    of their civil rights, they can force the racists to pay monetary damages. This
    is exactly what nine survivors from Charlottesville did.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 1871年，为回应南北战争结束后席卷南方的对黑人种族主义恐怖主义浪潮，美国国会通过了《三K党法案》。该法案允许种族暴力的受害者在民事法院起诉施暴者。如果受害者能够证明存在剥夺他们民权的阴谋，他们可以迫使这些种族主义者支付经济赔偿。这正是夏洛茨维尔的九名幸存者所做的。
- en: The plaintiffs in these cases were all Charlottesville residents, some of whom
    were severely injured that day—one suffered a fractured skull, another a broken
    leg and ankle. They filed the Sines v. Kessler lawsuit in October 2017 against
    14 individuals and 10 organizations, with the goal of bankrupting the American
    fascist movement. The individual defendants included Jason Kessler, the primary
    organizer of Unite the Right; James Alex Fields Jr., the neo-Nazi terrorist serving
    a prison sentence for Heather Heyer’s murder; Richard Spencer; and leaders of
    the fascist groups that organized Unite the Right. Defendants also included fascist
    groups themselves like Vanguard America, Traditionalist Worker Party, various
    branches of the Ku Klux Klan, and the National Socialist Movement.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 这些案件的原告都是夏洛茨维尔居民，其中一些人在那天受了重伤——有一个人头骨骨折，另一个人腿部和脚踝骨折。他们在2017年10月提起了“Sines诉Kessler”诉讼，起诉14名个人和10个组织，目标是使美国法西斯运动破产。个人被告包括“联合右翼”主要组织者Jason
    Kessler；新纳粹恐怖分子James Alex Fields Jr.（因谋杀Heather Heyer而服刑）；Richard Spencer；以及组织“联合右翼”的法西斯团体领导人。被告还包括一些法西斯团体本身，如先锋美国（Vanguard
    America）、传统主义工人党（Traditionalist Worker Party）、三K党各分支和国家社会主义运动。
- en: The Charlottesville survivors’ lawsuit was organized and funded by a legal nonprofit
    called Integrity First for America (IFA). The mission of the organization, founded
    in response to the violence of Unite the Right, was “defending democratic norms
    and ensuring equal rights for every American.” Using over 5TB of evidence in the
    form of phone records, text messages, videos from Unite the Right, email messages,
    social media posts, and private messages and chat logs, the plaintiffs successfully
    made their case. IFA made all of the evidence used in the lawsuit available to
    the public at [*https://<wbr>www<wbr>.integrityfirstforamerica<wbr>.org<wbr>/exhibits*](https://www.integrityfirstforamerica.org/exhibits).
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 查尔茨维尔幸存者的诉讼由一个名为Integrity First for America (IFA)的法律非营利组织组织和资助。该组织成立于响应“联合右翼”的暴力事件，其使命是“捍卫民主规范并确保每位美国人的平等权利。”通过使用超过5TB的证据，包括电话记录、短信、来自“联合右翼”的视频、电子邮件、社交媒体帖子以及私人消息和聊天记录，原告成功地陈述了案件。IFA将诉讼中使用的所有证据公开提供，网址为[*https://<wbr>www<wbr>.integrityfirstforamerica<wbr>.org<wbr>/exhibits*](https://www.integrityfirstforamerica.org/exhibits)。
- en: On its blog, IFA explained that while its lawyers did eventually get copies
    of the neo-Nazi chat logs directly from Discord as part of the lawsuit’s discovery
    process, DiscordLeaks provided “an immense amount” of detail before the lawsuit
    was filed. In the chat logs published by Unicorn Riot, Unite the Right attendees
    discussed whether they could hit protesters with cars and then claim self-defense,
    which is what happened. This evidence “provided crucial early information that
    made the speed and breadth of the initial complaint possible.”
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 在其博客中，IFA解释道，虽然其律师最终从Discord直接获得了新纳粹聊天记录的副本，这作为诉讼发现过程的一部分，但DiscordLeaks在诉讼提出之前提供了“大量”细节。在Unicorn
    Riot发布的聊天记录中，“联合右翼”活动的与会者讨论是否可以用车撞击抗议者，然后主张自卫，而这正是发生的事情。这个证据“提供了至关重要的早期信息，使得最初投诉的速度和广度成为可能。”
- en: In November 2021, the court found the fascist organizers guilty and ordered
    them to pay over $25 million in damages. In late 2022, IFA wound down its operations.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 2021年11月，法院裁定这些法西斯组织者有罪，并命令他们支付超过2500万美元的赔偿金。2022年底，IFA结束了其运营。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">The Patriot Front
    Chat Logs</samp>
  id: totrans-296
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">爱国者阵线聊天记录</samp>
- en: In the aftermath of the violent Unite the Right protests in Charlottesville,
    one of the neo-Nazi groups in attendance, Vanguard America, broke apart due to
    infighting. Out of the ashes of Vanguard America, a new fascist group called Patriot
    Front was born. Patriot Front, based out of Texas, is known for requiring members
    to do weekly “activism” involving vandalizing property with racist messages and
    posting Patriot Front propaganda, like stickers, all over the place. According
    to the Anti-Defamation League, Patriot Front was responsible for 82 percent of
    all reported incidents in 2021 involving the distribution of racist, antisemitic,
    and other hateful propaganda in the US.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 在查尔茨维尔“联合右翼”暴力抗议事件之后，出席的一个新纳粹团体——先锋美国因内讧而解散。先锋美国的废墟中，诞生了一个新的法西斯组织——爱国者阵线。爱国者阵线总部位于德州，以要求成员每周进行“激进活动”而闻名，这些活动包括用带有种族主义信息的涂鸦破坏财产，并到处张贴爱国者阵线的宣传材料，比如贴纸。根据反诽谤联盟的统计，爱国者阵线在2021年负责了所有报道事件的82%，这些事件涉及在美国分发种族主义、反犹太主义和其他仇恨宣传。
- en: In January 2022, someone hacked Patriot Front and leaked 400GB of data to Unicorn
    Riot, including thousands of messages posted to the group’s internal RocketChat
    server, an open source chat platform that anyone can host themselves. Unicorn
    Riot collaborated with DDoSecrets to publish the 400GB Patriot Front dataset,
    which you can find at [*https://<wbr>ddosecrets<wbr>.com<wbr>/wiki<wbr>/Patriot<wbr>_Front*](https://ddosecrets.com/wiki/Patriot_Front).
    In response to this leak, the DiscordLeaks developers also updated the app to
    include support for RocketChat, and they imported over 12,000 new messages into
    it from two Patriot Front chat servers. You can find Patriot Front’s chat logs
    at [*https://<wbr>discordleaks<wbr>.unicornriot<wbr>.ninja<wbr>/rocket<wbr>-chat<wbr>/*](https://discordleaks.unicornriot.ninja/rocket-chat/).
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 2022年1月，有人黑客入侵了爱国阵线并将400GB的数据泄露给Unicorn Riot，其中包括成千上万条发布到该组织内部RocketChat服务器的消息，RocketChat是一个开源聊天平台，任何人都可以自行托管。Unicorn
    Riot与DDoSecrets合作，发布了这份400GB的爱国阵线数据集，你可以在[*https://<wbr>ddosecrets<wbr>.com<wbr>/wiki<wbr>/Patriot<wbr>_Front*](https://ddosecrets.com/wiki/Patriot_Front)找到它。作为对此泄露事件的回应，DiscordLeaks的开发者们还更新了应用程序，增加了对RocketChat的支持，并从两个爱国阵线聊天服务器中导入了超过12,000条新消息。你可以在[*https://<wbr>discordleaks<wbr>.unicornriot<wbr>.ninja<wbr>/rocket<wbr>-chat<wbr>/*](https://discordleaks.unicornriot.ninja/rocket-chat/)找到爱国阵线的聊天记录。
- en: '[Figure 14-6](#fig14-6) shows a still from a video in the Patriot Front dataset
    of members reading their manifesto and chanting “Life, liberty, victory!” The
    video includes a few seconds at the end where one of the neo-Nazis, apparently
    thinking the recording was over, yells, “Seig fucking Heil!”'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 14-6](#fig14-6)显示了来自爱国阵线数据集中一段视频的静帧，视频中成员正在阅读他们的宣言并高喊“生命、自由、胜利！”视频的结尾有几秒钟的画面，一名新纳粹分子显然以为录制已结束，大喊：“塞格他妈的海尔！”'
- en: '![A screenshot from a Patriot Front video. It shows five men wearing identical
    uniforms that include hats, sunglasses, and face masks. Four of the men are standing
    in front of fascist flags, and one is sitting at a table reading a statement.](Images/Figure14-6.jpg)'
  id: totrans-300
  prefs: []
  type: TYPE_IMG
  zh: '![来自爱国阵线视频的截图，图中显示五名男子穿着相同的制服，包括帽子、太阳镜和面罩。四人站在法西斯旗帜前，一人坐在桌旁阅读声明。](Images/Figure14-6.jpg)'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 14-6: Patriot Front
    members, from a video in the hacked dataset</samp>'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">图 14-6：来自被黑客入侵数据集的视频中的爱国阵线成员</samp>
- en: Unfortunately, the American fascist movement has steadily grown since the election
    of Donald Trump in 2016\. But there’s a wealth of public datasets about this movement,
    just waiting for researchers like you to dig in and expose it.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，自从2016年唐纳德·特朗普当选总统以来，美国的法西斯主义运动稳步增长。然而，关于这一运动有大量公开数据集，等待像你这样的研究人员深入挖掘并揭露。
- en: <samp class="SANS_Futura_Std_Bold_B_11">Summary</samp>
  id: totrans-303
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">总结</samp>
- en: In this chapter, you’ve learned how antifascists infiltrated the Discord servers
    used by the American fascist movement, including organizers of the deadly Unite
    the Right rally in 2017, and leaked millions of chat logs to Unicorn Riot in JSON
    format. You saw how I went about analyzing these JSON files to understand their
    structure, how the custom Flask and SQLAlchemy web app I built worked under the
    hood, and how the app ultimately became DiscordLeaks. I also described my own
    investigation into the Pony Power server that fascists used to dox their enemies.
    Finally, you read about the amazing results from the Sines v. Kessler lawsuit
    and the continued success of DiscordLeaks tools.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你了解到反法西斯分子如何渗透到美国法西斯主义运动使用的Discord服务器，包括2017年致命的“团结右派”集会的组织者，并将数百万条聊天记录以JSON格式泄露给Unicorn
    Riot。你看到了我如何分析这些JSON文件以理解其结构，了解我构建的定制Flask和SQLAlchemy Web应用程序如何在后台工作，以及该应用程序最终如何成为DiscordLeaks。我还描述了我自己对法西斯分子用来曝光敌人的Pony
    Power服务器的调查。最后，你了解了Sines诉Kessler诉讼的惊人结果，以及DiscordLeaks工具的持续成功。
