- en: Chapter 5. Displaying Timelines
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第 5 章：显示时间线
- en: The most compelling visualizations often succeed because they tell a story;
    they extract a narrative from data and reveal that narrative to their users. And
    as with any narrative, time is a critical component. If the data consists solely
    of numbers, a standard bar or line chart can easily show its evolution over time.
    If the data is not numerical, however, standard charts probably won’t work. This
    chapter considers several alternatives for time-based visualizations.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 最具吸引力的可视化通常之所以成功，是因为它们讲述了一个故事；它们从数据中提取出一个叙事，并向用户展示这个故事。与任何叙事一样，时间是一个关键组成部分。如果数据仅由数字组成，标准的条形图或折线图可以轻松地展示其随时间的演变。然而，如果数据不是数值型的，标准图表可能就无法奏效。本章将考虑几种基于时间的可视化替代方案。
- en: 'All are based on some variation of a timeline; one linear dimension represents
    time, and events are places along that dimension based on when they occurred.
    In all of the examples, we’ll consider the same underlying data: a possible chronology
    of the plays of William Shakespeare (*[http://en.wikipedia.org/wiki/Chronology_of_Shakespeare%27s_plays](http://en.wikipedia.org/wiki/Chronology_of_Shakespeare%27s_plays)*).'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些都是基于某种形式的时间线；其中一个线性维度表示时间，事件根据发生的时间在该维度上标出。在所有示例中，我们将考虑相同的基础数据：威廉·莎士比亚戏剧的可能年表
    (*[http://en.wikipedia.org/wiki/Chronology_of_Shakespeare%27s_plays](http://en.wikipedia.org/wiki/Chronology_of_Shakespeare%27s_plays)*).
- en: 'We’ll look at three very different approaches for adding timelines to web pages.
    One option relies on a JavaScript library, and it follows a process similar to
    many other visualizations in the book. The other two techniques, however, offer
    a different perspective. In one, we won’t use a visualization library at all.
    Instead, we’ll build a timeline with basic JavaScript, HTML, and CSS, and we’ll
    see how to do that both with and without jQuery. The final example shows the other
    extreme. It relies on a full-featured web component available from an external
    website. In short, we’ll look at the following:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将展示三种非常不同的方法来向网页添加时间线。一种方法依赖于一个 JavaScript 库，并且它的过程与本书中的许多其他可视化方法相似。然而，另外两种技术则提供了不同的视角。其中一种方法，我们完全不使用可视化库。相反，我们将使用基础的
    JavaScript、HTML 和 CSS 来构建时间线，我们还将展示如何在有和没有 jQuery 的情况下实现。最后一个示例展示了另一种极端方法，它依赖于来自外部网站的一个功能完整的
    Web 组件。简而言之，我们将研究以下内容：
- en: How to use a library to create timelines
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何使用库创建时间线
- en: How to create timelines without a library using only JavaScript, HTML, and CSS
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何仅使用 JavaScript、HTML 和 CSS 创建时间线而不依赖库
- en: How to integrate a timeline component in a web page
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何在网页中集成时间线组件
- en: Building Timelines with a Library
  id: totrans-7
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用库构建时间线
- en: First, we’ll build the timeline using the Chronoline.js library (*[http://stoicloofah.github.io/chronoline.js/](http://stoicloofah.github.io/chronoline.js/)*),
    which works a lot like most of the other JavaScript libraries we’ve used in the
    book. You include the library in your page, define your data, and let the library
    create the visualization.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将使用 Chronoline.js 库来构建时间线 (*[http://stoicloofah.github.io/chronoline.js/](http://stoicloofah.github.io/chronoline.js/)*)，它的工作方式与本书中我们使用的其他大多数
    JavaScript 库类似。你需要在页面中包含该库，定义数据，然后让库来创建可视化。
- en: 'Step 1: Include the Required Libraries'
  id: totrans-9
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 步骤 1：包含所需的库
- en: The Chronoline.js library itself depends on a few other libraries, and we’ll
    need to include all of them in our pages.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: Chronoline.js 库本身依赖于一些其他库，我们需要在页面中包含它们。
- en: jQuery (*[http://jquery.com/](http://jquery.com/)*)
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: jQuery (*[http://jquery.com/](http://jquery.com/)*)
- en: qTip2, including its style sheet (*[http://qtip2.com/](http://qtip2.com/)*)
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: qTip2，包括其样式表 (*[http://qtip2.com/](http://qtip2.com/)*)
- en: Raphaël (*[http://raphaeljs.com/](http://raphaeljs.com/)*)
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Raphaël (*[http://raphaeljs.com/](http://raphaeljs.com/)*)
- en: All of these libraries are popular enough for public content distribution networks
    to support, so we’ll use CloudFlare’s CDN in the following markup. We’ll have
    to use our own resources, however, to host Chronoline.js itself. That library
    also defines its own style sheet.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些库都足够流行，以至于公共内容分发网络能够支持，因此我们将在以下标记中使用 CloudFlare 的 CDN。然而，我们需要使用我们自己的资源来托管
    Chronoline.js 库。该库还定义了自己的样式表。
- en: '[PRE0]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: As you can see at ➊, we’ve set aside a `<div>` to hold our timeline. We’ve also
    included the JavaScript libraries as the last part of the `<body>` element, as
    that provides the best browser performance.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 如你在 ➊ 所见，我们已预留了一个 `<div>` 元素来容纳我们的时间线。我们还将 JavaScript 库放在 `<body>` 元素的最后部分，因为这样能提供最佳的浏览器性能。
- en: 'Step 2: Prepare the Data'
  id: totrans-17
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 步骤 2：准备数据
- en: 'The data for our timeline comes from Wikipedia (*[http://en.wikipedia.org/wiki/Chronology_of_Shakespeare%27s_plays](http://en.wikipedia.org/wiki/Chronology_of_Shakespeare%27s_plays)*).
    As a JavaScript object, that data might be structured like the following excerpt:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的时间线数据来自 Wikipedia（*[http://en.wikipedia.org/wiki/Chronology_of_Shakespeare%27s_plays](http://en.wikipedia.org/wiki/Chronology_of_Shakespeare%27s_plays)*）。作为一个
    JavaScript 对象，这些数据可能像以下摘录那样结构化：
- en: '[PRE1]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: You can see the complete data set in the book’s source code (*[http://jsDataV.is/source/](http://jsDataV.is/source/)*).
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在书籍的源代码中看到完整的数据集（*[http://jsDataV.is/source/](http://jsDataV.is/source/)*）。
- en: 'Before we can use Chronoline.js, we have to convert the raw data into the format
    the library expects. Since we have jQuery available, we can take advantage of
    its `.map()` function for the conversion. (For details on `.map()`, see Step 7
    of [Selecting Chart Content](ch02.html#selecting_chart_content "Selecting Chart
    Content") in [Step 7: Determine Chart Data Based on the Interaction State](ch02.html#step_7_determine_chart_data_based_on_the
    "Step 7: Determine Chart Data Based on the Interaction State").)'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: '在使用 Chronoline.js 之前，我们必须将原始数据转换为库所期望的格式。由于我们可以使用 jQuery，我们可以利用其 `.map()` 函数进行转换。（有关
    `.map()` 的详细信息，请参见 [选择图表内容](ch02.html#selecting_chart_content "Selecting Chart
    Content") 中的第七步：[根据交互状态确定图表数据](ch02.html#step_7_determine_chart_data_based_on_the
    "Step 7: Determine Chart Data Based on the Interaction State")。）'
- en: '[PRE2]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: As you can see from our data set, some of the plays have a single year as their
    date, while others have a range of years (two dates separated by a dash). To set
    the date range for Chronoline.js, we check for a dash at ➊. If one is present,
    we split the date string at that dash and set a multiyear range at ➋. Otherwise,
    we set the range to a single year at ➌.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 如你从我们的数据集中看到的，一些戏剧的日期只有一个年份，而另一些则有一段年份范围（由破折号分隔的两个日期）。为了设置 Chronoline.js 的日期范围，我们在➊检查是否有破折号。如果有，我们将在破折号处拆分日期字符串，并在➋设置多年的范围。否则，我们将在➌设置单一年份范围。
- en: Note
  id: totrans-24
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '**Recall that the JavaScript `Date` object numbers months from `0` rather than
    `1`.**'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: '**请记住，JavaScript 中的 `Date` 对象是从 `0` 开始计算月份，而不是从 `1`。**'
- en: 'Step 3: Draw the Timeline'
  id: totrans-26
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 第三步：绘制时间线
- en: To draw the timeline, we create a new `Chronoline` object, passing it the HTML
    container element, our event data, and any options. The HTML container element
    should be a native element, not a jQuery selection. To convert from a selection
    to a native element, we use the `get()` method. In this case, we want the first
    element, so we use the parameter `0`.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 要绘制时间线，我们创建一个新的 `Chronoline` 对象，传入 HTML 容器元素、事件数据以及任何选项。HTML 容器元素应该是原生元素，而不是
    jQuery 选择器。为了将选择器转换为原生元素，我们使用 `get()` 方法。在这种情况下，我们需要第一个元素，因此使用参数 `0`。
- en: '[PRE3]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: If we try to use the default options of Chronoline.js with our data, however,
    the result is quite disappointing. (In fact, it’s illegible and not worth reproducing
    at this point.) We can fix that in the next step with some additional options.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果我们尝试使用 Chronoline.js 的默认选项来处理我们的数据，结果会相当令人失望。（实际上，它是难以阅读的，现阶段不值得再呈现。）我们可以在下一步通过一些额外的选项来修复这个问题。
- en: 'Step 4: Set Chronoline.js Options for the Data'
  id: totrans-30
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 第四步：为数据设置 Chronoline.js 选项
- en: The Chronoline.js library has default options that are well suited for its original
    application, but they don’t work so well for Shakespeare’s plays. Fortunately,
    we can change the options from the default values. As of this writing, Chronoline.js
    doesn’t have much documentation on its options; to see the full set, you would
    normally have to examine the source code. We’ll cover the most important options
    here, though.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: Chronoline.js 库有适合其原始应用的默认选项，但对于莎士比亚的戏剧来说并不太合适。幸运的是，我们可以更改这些选项的默认值。截止本文编写时，Chronoline.js
    并没有太多关于其选项的文档；要查看完整的选项集，通常需要检查源代码。不过，我们将在这里介绍最重要的几个选项。
- en: 'One of the most obvious problems with the Chonoline.js defaults is the date
    shown in the initial view. Chronoline.js starts by displaying the current date
    by default. Since our timeline ends in 1613, the user would have to scroll backward
    for a long time to see anything meaningful. We can change this view by giving
    Chronoline.js a different start date for the initial view:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: Chronoline.js 默认设置中最明显的问题之一是初始视图中显示的日期。Chronoline.js 默认从当前日期开始显示。由于我们的时间线结束于
    1613 年，用户必须向后滚动很长时间才能看到有意义的内容。我们可以通过为 Chronoline.js 提供一个不同的起始日期来改变这个视图：
- en: '[PRE4]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'As long as we’re setting the timeline to start somewhere near Shakespeare’s
    lifetime, there’s no need for Chronoline.js to add a special mark for the current
    date, so we use this simple option to tell it not to bother:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 只要我们设置时间线的起点接近莎士比亚的生平，就不需要 Chronoline.js 为当前日期添加特殊标记，因此我们使用这个简单的选项告诉它不要打扰：
- en: '[PRE5]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The next major problem to address is the labeling. By default, Chronoline.js
    tries to label every day on the timeline. As our events span 24 years, we don’t
    need that granularity. Instead, we can tell Chronoline.js just to label the years.
    For the same reason, we also need to change the checkmarks. Instead of every day,
    we need checkmarks only for every month.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来需要解决的主要问题是标签。默认情况下，Chronoline.js 尝试为时间线上的每一天添加标签。由于我们的事件跨越了24年，我们不需要那么精细的粒度。相反，我们可以告诉
    Chronoline.js 只标记年份。出于同样的原因，我们还需要更改勾选标记。我们不需要每天都标记，而是只在每个月标记一次。
- en: To change both of these options, we supply Chronoline.js with a pair of functions
    to call.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 要更改这两个选项，我们为 Chronoline.js 提供了一对需要调用的函数。
- en: '[PRE6]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Chronoline.js passes each of these functions a date object, and the functions
    return `true` or `false` depending on whether the date merits a checkmark or label.
    For checkmarks, we return `true` only on the first day of the month. We return
    `true` for labels only on January 1.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: Chronoline.js 将每个这些函数传递一个日期对象，函数根据日期是否值得标记或标签返回 `true` 或 `false`。对于勾选标记，我们只在每个月的第一天返回
    `true`。对于标签，我们只在每年的1月1日返回 `true`。
- en: By default, Chronoline.js will try to show a full date for each label. Since
    we only want to label each year, we’ll change the label format to just show the
    year. The details for the format specification are based on a standard C++ library
    (*[http://www.cplusplus.com/reference/ctime/strftime/](http://www.cplusplus.com/reference/ctime/strftime/)*).
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，Chronoline.js 会尝试为每个标签显示完整的日期。由于我们只想标记每个年份，我们将标签格式更改为只显示年份。格式规范的详细信息基于标准
    C++ 库（* [http://www.cplusplus.com/reference/ctime/strftime/](http://www.cplusplus.com/reference/ctime/strftime/)*）。
- en: '[PRE7]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: For our last adjustments to the labeling, we remove the “sublabels” and “sub-sublabels”
    that Chronoline.js adds by default. Those labels don’t provide any value in our
    case.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 对于标签的最后一些调整，我们移除了 Chronoline.js 默认添加的“子标签”和“子子标签”。这些标签在我们的情况下没有任何价值。
- en: '[PRE8]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: We also want to change the span of time that Chronoline.js displays in the timeline.
    For our data, showing a span of five years at a time seems good.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还希望改变 Chronoline.js 在时间线中显示的时间跨度。对于我们的数据，一次显示五年的跨度似乎很合适。
- en: '[PRE9]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Note that the variable `DAY_IN_MILLISECONDS` is defined by Chronoline.js itself.
    We’re free to use it in this or any other option setting.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，变量 `DAY_IN_MILLISECONDS` 是由 Chronoline.js 本身定义的。我们可以在此或任何其他选项设置中自由使用它。
- en: Now we can address the timeline scrolling. Chronoline.js normally advances the
    timeline by a single day with each click. That would result in some rather tedious
    scrolling for our users. Instead of the default behavior, we’ll have Chronoline.js
    advance by a full year. As with the labels, we change this behavior by supplying
    Chronoline.js with a function. That function is passed a date object, and it should
    return a new date object to which Chronoline.js should scroll. In our case, we
    simply add or subtract one from the year value.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以处理时间线滚动的问题。Chronoline.js 通常每次点击时推进时间线一天。这样会导致我们的用户滚动时感到非常繁琐。我们将不使用默认行为，而是让
    Chronoline.js 每次推进一年。与标签一样，我们通过为 Chronoline.js 提供一个函数来改变这个行为。这个函数接收一个日期对象，并应返回一个新的日期对象，Chronoline.js
    应该滚动到该日期。在我们的案例中，我们仅仅是将年份值加或减去1。
- en: '[PRE10]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The last few adjustments clean up the appearance and behavior of Chronoline.js.
    Adding some extra space (in our case, three months) before the start and after
    the end of the timeline gives the data a bit of room.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 最后的几个调整清理了 Chronoline.js 的外观和行为。在时间线的开始和结束之前添加一些额外的空间（在我们的案例中是三个月）给数据留出一点空间。
- en: '[PRE11]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: We can also make the scrolling animate smoothly instead of jumping, enable users
    to drag the timeline right or left, and improve the default browser tool tips.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以让滚动平滑地动画化，而不是跳跃，让用户能够左右拖动时间线，并改善默认的浏览器工具提示。
- en: '[PRE12]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'For the final tweaks, we can change the appearance of the timeline. To change
    the color and size of the events, we use the following options:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 对于最后的调整，我们可以改变时间线的外观。要改变事件的颜色和大小，我们使用以下选项：
- en: '[PRE13]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: To change the color of the scroll buttons, we have to modify the *chronoline.css*
    style sheet. The property to change is `background-color`.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 要改变滚动按钮的颜色，我们必须修改 *chronoline.css* 样式表。需要更改的属性是 `background-color`。
- en: '[PRE14]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: With those changes, we finally have a timeline of Shakespeare’s plays, as shown
    in [Figure 5-1](ch05.html#chronolinedotjs_library_creates_a_simple "Figure 5-1. The
    Chronoline.js library creates a simple, interactive timeline.").
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这些更改，我们最终得到了莎士比亚剧作的时间线，如 [图 5-1](ch05.html#chronolinedotjs_library_creates_a_simple
    "图 5-1. Chronoline.js 库创建了一个简单的互动时间线。") 所示。
- en: '![The Chronoline.js library creates a simple, interactive timeline.](figs/web/05fig01.png.jpg)Figure 5-1. The
    Chronoline.js library creates a simple, interactive timeline.'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: '![Chronoline.js 库创建了一个简单的互动时间线。](figs/web/05fig01.png.jpg)图 5-1. Chronoline.js
    库创建了一个简单的互动时间线。'
- en: The resulting timeline looks pretty good, but the limitations of the library
    make it difficult to customize and enhance the timeline further. Next, we’ll build
    a new timeline from scratch without the library so we have complete control.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 结果时间线看起来相当不错，但库的局限性使得进一步自定义和增强时间线变得困难。接下来，我们将从零开始构建一个新的时间线，而不使用库，以便完全控制。
- en: Building Timelines with JavaScript
  id: totrans-60
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 JavaScript 构建时间线
- en: If you followed the example in the previous section, you might not be completely
    satisfied with the results. We did end up with an accurate timeline of Shakespeare’s
    plays, but the resulting visualization may not be communicating what you want.
    For example, the timeline doesn’t show the names of the plays unless the user
    hovers a mouse over that section of the graph. Perhaps we’d rather have the plays’
    titles always visible. That kind of problem is a limitation of third-party libraries.
    The author of Chronoline.js didn’t see the need for displaying titles, so he didn’t
    offer the option. And unless we’re willing to take on the potentially daunting
    task of modifying the library’s source code, we can’t make the library do exactly
    what we want.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你跟随上一节中的示例，你可能对结果不完全满意。我们确实得到了一个准确的莎士比亚剧作时间线，但生成的可视化效果可能没有传达出你想要的内容。例如，时间线不会显示剧作的名称，除非用户将鼠标悬停在图表的该部分。或许我们更希望剧作的标题始终可见。这类问题是第三方库的局限性。Chronoline.js
    的作者没有看到显示标题的必要，因此没有提供这个选项。除非我们愿意承担修改库源代码的艰巨任务，否则我们无法让库完全按照我们的需求工作。
- en: Fortunately, particularly in the case of timelines, we can take a completely
    different approach. We can create visualizations without using any third-party
    library at all, which will give us total control over the result. Timelines are
    especially amenable to this technique because they can be created with nothing
    more than text and styling. All it takes is a basic understanding of HTML and
    CSS, plus enough JavaScript to set things up and perhaps provide simple interactions.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，尤其在时间线的情况下，我们可以采用完全不同的方法。我们可以在完全不使用任何第三方库的情况下创建可视化效果，这将让我们对结果拥有完全的控制权。时间线尤其适合这种方法，因为它们只需要文本和样式就能创建。只需基本了解
    HTML 和 CSS，加上一些 JavaScript 来设置和可能提供简单的交互。
- en: That’s exactly what we’ll do in this example. We’ll start with the same data
    set as before. Instead of feeding that data into a third-party library, however,
    we’ll use plain old JavaScript (with an optional dose of jQuery) to construct
    a pure HTML representation of the data. Then we’ll use CSS to set the appearance
    of the timeline.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 这正是我们在这个示例中要做的事情。我们将从之前相同的数据集开始。但与将数据输入到第三方库中不同，我们将使用纯 JavaScript（加上可选的 jQuery）来构建数据的纯
    HTML 表示。然后，我们将使用 CSS 来设置时间线的外观。
- en: 'Step 1: Prepare the HTML Skeleton'
  id: totrans-64
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 步骤 1：准备 HTML 骨架
- en: Without any required libraries, the HTML page for our timeline is pretty simple.
    All we need is a containing `<div>` with a unique `id` attribute.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 在没有任何必需库的情况下，我们的时间线 HTML 页面非常简单。我们只需要一个包含唯一 `id` 属性的 `<div>` 元素。
- en: '[PRE15]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Step 2: Start JavaScript Execution'
  id: totrans-67
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 步骤 2：开始 JavaScript 执行
- en: As soon as the browser has finished loading our page, we can start processing
    the data. As before, we’ll start with our data formatted as a JavaScript array.
    You can see the complete data set in the book’s source code (*[http://jsDataV.is/source/](http://jsDataV.is/source/)*).
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦浏览器完成加载我们的页面，我们就可以开始处理数据。和之前一样，我们将从格式化为 JavaScript 数组的数据开始。你可以在书本的源代码中看到完整的数据集
    (*[http://jsDataV.is/source/](http://jsDataV.is/source/)*).
- en: '[PRE16]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Step 3: Create the Timeline in Semantic HTML'
  id: totrans-70
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 步骤 3：使用语义化 HTML 创建时间线
- en: To create the timeline in HTML, we first need to decide how to represent it.
    If you’re used to working with arbitrary `<div>` and `<span>` elements, you might
    think that’s the best approach here as well. Instead of jumping right to these
    generic elements, however, we should consider other HTML structures that more
    accurately convey the content. HTML that more closely reflects the meaning of
    the underlying content is known as *semantic markup*, and it’s usually preferred
    over generic `<div>` and `<span>` tags. Semantic markup exposes the meaning of
    your content to computers such as search engines and screen readers for users
    with visual impairments, and it can improve your site’s search rank and accessibility.
    If we think about a timeline in the context of semantic markup, it’s easy to see
    that the time-line is really just a list. In fact, it’s a list with a specific
    order. We should build our HTML timeline, therefore, as an ordered list (`<ol>`)
    element. While we’re creating the `<ol>`, we can also give it a class name for
    CSS style rules we’ll be adding later.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 要在HTML中创建时间轴，我们首先需要决定如何表示它。如果你习惯使用任意的 `<div>` 和 `<span>` 元素，你可能认为这也是最好的方法。然而，实际上我们应该考虑其他HTML结构，它们能够更准确地传达内容。更贴近内容含义的HTML被称为
    *语义化标记*，通常优于通用的 `<div>` 和 `<span>` 标签。语义化标记能够将内容的含义传递给计算机，比如搜索引擎和为视力障碍用户提供服务的屏幕阅读器，并且能够提高网站的搜索排名和可访问性。如果我们从语义化标记的角度考虑时间轴，很容易发现时间轴其实就是一个列表。事实上，它是一个有特定顺序的列表。因此，我们应该将HTML时间轴构建为有序列表（`<ol>`）元素。在创建
    `<ol>` 时，我们还可以为它添加一个类名，以便稍后为其添加CSS样式规则。
- en: '[PRE17]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Next we can iterate through the plays, creating an individual list item, `<li>`,
    for each one. For now, we’ll just insert the date and title as text.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来我们可以遍历这些剧本，为每个剧本创建一个单独的列表项 `<li>`。目前，我们只需将日期和标题作为文本插入。
- en: '[PRE18]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: '[Figure 5-2](ch05.html#pure_html_timeline_can_start_out_as_a_si "Figure 5-2. A
    pure HTML timeline can start out as a simple ordered list.") shows a truncated
    version of the resulting list. It may not look like much (yet), but it has the
    essential data and structure.'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 5-2](ch05.html#pure_html_timeline_can_start_out_as_a_si "图 5-2. 纯HTML时间轴可以从一个简单的有序列表开始。")显示了结果列表的简化版本。它看起来可能不算什么（目前），但它包含了必要的数据和结构。'
- en: '![A pure HTML timeline can start out as a simple ordered list.](figs/web/05fig02.png.jpg)Figure 5-2. A
    pure HTML timeline can start out as a simple ordered list.'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: '![纯HTML时间轴可以从一个简单的有序列表开始。](figs/web/05fig02.png.jpg) 图 5-2. 纯HTML时间轴可以从一个简单的有序列表开始。'
- en: 'If you look at the resulting HTML that underlies that list, it’s pretty simple:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你查看支撑该列表的HTML代码，你会发现它相当简单：
- en: '[PRE19]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'In the spirit of semantic HTML, we should stop and consider whether that markup
    can be improved. Since it appears first in our list items, let’s consider the
    date or date range for a play. Although there has been some controversy around
    the decision, HTML5 has defined support for a `<time>` element to contain dates
    and times. Using that element as a wrapper will make our dates more semantic.
    The second part of each list item is the title of the play. As it happens, HTML5’s
    `<cite>` element is perfect for that content. To quote the current standard (*[http://html.spec.whatwg.org](http://html.spec.whatwg.org)*):'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 本着语义化HTML的精神，我们应该停下来考虑一下是否可以改进这些标记。由于它首先出现在我们的列表项中，我们考虑一下剧本的日期或日期范围。尽管这个决策引起了一些争议，但HTML5已定义了支持
    `<time>` 元素来包含日期和时间。使用这个元素作为包装器将使我们的日期更具语义性。每个列表项的第二部分是剧本的标题。恰好，HTML5的 `<cite>`
    元素非常适合这个内容。引用当前标准（*[http://html.spec.whatwg.org](http://html.spec.whatwg.org)*）：
- en: The `<cite>` element represents the title of a work (e.g., a book, . . . **a
    play**, [emphasis added] . . . etc). This can be a work that is being quoted or
    referenced in detail (i.e., a citation), or it can just be a work that is mentioned
    in passing.
  id: totrans-80
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`<cite>` 元素表示作品的标题（例如，一本书，… **一部剧本**，[已强调] …等）。这可以是被引用或详细参考的作品（即引用），也可以是仅仅在旁提及的作品。'
- en: To add those elements to our code, we’ll have to distinguish between dates that
    are single years and those that are ranges. Looking for a dash (`-`) in the data
    will tell us which we have.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 为了将这些元素添加到我们的代码中，我们需要区分单一年份的日期和范围日期。通过在数据中查找破折号（`-`），我们可以知道是哪一种。
- en: '[PRE20]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Notice how we handle date ranges (➊ through ➋). Since a range has a start and
    end time, we create two distinct `<time>` elements. We don’t need to add any punctuation
    between the dates at this point.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 注意我们如何处理日期范围（➊到➋）。由于范围有开始和结束时间，我们创建了两个不同的 `<time>` 元素。此时，我们不需要在日期之间添加任何标点符号。
- en: Because we’re no longer including the punctuation, the resulting output (shown
    in [Figure 5-3](ch05.html#semantic_markup_simplifies_the_required "Figure 5-3. Semantic
    markup simplifies the required HTML, but it may require special styling.")) might
    look a little worse than before. Don’t worry, though; we’ll fix it soon.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 因为我们不再包含标点符号，生成的输出（如[图5-3](ch05.html#semantic_markup_simplifies_the_required
    "图5-3. 语义化标记简化了所需的HTML，但可能需要特殊样式")所示）可能看起来比以前差一些。不过，不用担心，我们很快就会修复它。
- en: '![Semantic markup simplifies the required HTML, but it may require special
    styling.](figs/web/05fig03.png.jpg)Figure 5-3. Semantic markup simplifies the
    required HTML, but it may require special styling.'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: '![语义化标记简化了所需的HTML，但可能需要特殊样式。](figs/web/05fig03.png.jpg)图5-3. 语义化标记简化了所需的HTML，但可能需要特殊样式。'
- en: 'What *is* much improved is the underlying HTML. The markup clearly identifies
    the type of content it contains: an ordered list of dates and citations.'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: '*改进*的部分是底层的HTML。该标记清楚地标识了它包含的内容类型：一个按日期和引用排序的有序列表。'
- en: '[PRE21]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Step 4: Include the Supporting Content'
  id: totrans-88
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 第4步：包含辅助内容
- en: When we created a timeline using the Chronoline.js library, we weren’t able
    to include the supporting content from Wikipedia, because the library did not
    offer that option. In this example, though, we have complete control over the
    content, so let’s include that information in our timeline. For most plays, our
    data includes its first official record, its first publication, its first performance,
    and a discussion of the evidence. This type of content is perfectly matched to
    the HTML *description list* (`<dl>`), so that’s how we’ll add it to our page.
    It can follow the `<cite>` of the play’s title.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们使用Chronoline.js库创建时间轴时，我们无法包含来自Wikipedia的辅助内容，因为该库没有提供这个选项。然而，在这个例子中，我们可以完全控制内容，因此让我们将这些信息包含在时间轴中。对于大多数剧本，我们的数据包括其首次官方记录、首次出版、首次演出以及证据的讨论。这类内容与HTML的*描述列表*（`<dl>`）完美匹配，因此我们将以这种方式将其添加到页面中。它可以紧跟在剧本标题的`<cite>`标签后。
- en: '[PRE22]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: We can define a mapping array to help add the individual terms to each play.
    That array maps the property name in our data set to the label we want to use
    in the content.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以定义一个映射数组来帮助将每个术语添加到每个播放中。该数组将我们数据集中的属性名称映射到我们希望在内容中使用的标签。
- en: '[PRE23]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: With that array we can quickly add the descriptions to our content. We iterate
    over the array using `.forEach()`.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这个数组，我们可以快速地将描述添加到我们的内容中。我们使用`.forEach()`方法遍历数组。
- en: '[PRE24]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: At each iteration, we make sure that the data has content (➊) before creating
    the description item. A description item contains the term(s) being described
    in one `<dt>` tag and the description itself in a `<dd>` tag.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 在每次迭代时，我们确保数据中有内容（➊），然后再创建描述项。描述项包含一个或多个术语，在一个`<dt>`标签中描述，并在`<dd>`标签中给出描述。
- en: Our timeline is still lacking a bit of visual appeal, but it has a much richer
    set of content, as you can see in [Figure 5-4](ch05.html#html_makes_it_easy_to_add_extra_content
    "Figure 5-4. HTML makes it easy to add extra content to the list."). In fact,
    even without any styling at all, it still communicates the essential data quite
    well.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的时间轴仍然缺乏一些视觉吸引力，但如[图5-4](ch05.html#html_makes_it_easy_to_add_extra_content
    "图5-4. HTML使得将额外内容添加到列表变得容易")所示，它已经拥有了更丰富的内容。事实上，即使没有任何样式，它仍然能很好地传达基本数据。
- en: 'Here’s the resulting markup (truncated for brevity):'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是生成的标记（为了简洁起见已略去部分内容）：
- en: '[PRE25]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: '![HTML makes it easy to add extra content to the list.](figs/web/05fig04.png.jpg)Figure 5-4. HTML
    makes it easy to add extra content to the list.'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: '![HTML使得将额外内容添加到列表变得容易。](figs/web/05fig04.png.jpg)图5-4. HTML使得将额外内容添加到列表变得容易。'
- en: 'Step 5: Optionally Take Advantage of jQuery'
  id: totrans-100
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 第5步：可选地利用jQuery
- en: Our code so far has used nothing but plain JavaScript. If you’re using jQuery
    on your web pages, you can shorten the code a bit by taking advantage of some
    jQuery features. If your web pages aren’t using jQuery already, the minor enhancements
    in this step don’t justify adding it, but if you’d like to see a more concise
    version, check out the book’s source code for an alternative.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们的代码只使用了纯JavaScript。如果你在网页中使用了jQuery，你可以通过利用一些jQuery特性稍微缩短代码。如果你的网页尚未使用jQuery，这一步的微小增强不足以证明添加它的必要性，但如果你想看到更简洁的版本，可以查看本书的源代码以获取替代方案。
- en: 'Step 6: Fix Timeline Problems with CSS'
  id: totrans-102
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 第6步：使用CSS修复时间轴问题
- en: Now that we’ve built our timeline’s content in HTML, it’s time to define the
    styles that determine its appearance. Throughout this example, we’ll focus on
    the functional aspects of styling rather than pure visual elements such as fonts
    and colors, since you’ll probably want those visual styles to be specific to your
    own website.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我们已经在HTML中构建了时间轴的内容，现在是时候定义决定其外观的样式了。在这个例子中，我们将重点关注样式的功能性方面，而不是纯粹的视觉元素（如字体和颜色），因为你可能希望这些视觉样式专门针对你自己的网站。
- en: 'The first step is a simple one. We want to get rid of the numbering (1, 2,
    3 . . . ) that browsers normally add to ordered list items. A single rule banishes
    them from our timeline: by setting the `list-style-type` to `none`, we tell the
    browser not to add any special characters to our list items.'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 第一步是简单的。我们要去除浏览器通常添加到有序列表项中的编号（1、2、3……）。一个规则就能将它们从我们的时间轴中清除：通过将`list-style-type`设置为`none`，我们告诉浏览器不要向列表项添加任何特殊字符。
- en: '[PRE26]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: We can also use CSS rules to add some punctuation to our semantic HTML. First
    we look for places where two `<time>` elements appear right after each other,
    while skipping isolated `<time>` tags.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以使用CSS规则为我们的语义化HTML添加一些标点符号。首先我们寻找两个`<time>`元素紧接在一起出现的地方，同时跳过孤立的`<time>`标签。
- en: '[PRE27]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: The trick to finding `<time>` pairs is the CSS adjacent selector `+`. A rule
    with `time + time` specifies a `<time>` element that immediately follows a `<time>`
    element. To add the punctuation, we use the `:before` pseudoselector to specify
    what we want to happen *before* this second `<time>` tag, and we set the `content`
    property to indicate the content we want inserted.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 找到`<time>`配对的诀窍是使用CSS相邻选择器`+`。带有`time + time`的规则指定了一个紧接着另一个`<time>`元素的`<time>`元素。为了添加标点，我们使用`:before`伪选择器指定我们希望发生的操作*在*这个第二个`<time>`标签之前，并将`content`属性设置为指示我们想要插入的内容。
- en: If you haven’t seen the `>` before in a CSS rule, it’s the *direct descendant
    selector*. In this example, it means that the `<time>` element must be an immediate
    child of the `<li>` element. We’re using this selector so our rules won’t inadvertently
    apply to other `<time>` elements that may be nested deeper within the list item’s
    content.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你之前没有见过CSS规则中的 `>`，那它是 *直接子代选择器*。在这个例子中，它意味着`<time>`元素必须是`<li>`元素的直接子元素。我们使用这个选择器是为了确保我们的规则不会不小心应用到嵌套在列表项内容中更深位置的其他`<time>`元素。
- en: To finish up the punctuation, let’s add a colon and space after the last of
    the `<time>` elements in each list item.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 为了完成标点符号，我们将在每个列表项中的最后一个`<time>`元素后添加一个冒号和空格。
- en: '[PRE28]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: We use two pseudoselectors for this rule. The `:last-of-type` selector targets
    the last `<time>` element in the list item. That’s the first `<time>` if there’s
    only one, and the second `<time>` if both are present. Then we add the `:after`
    pseudoselector to insert content after that `<time>` element.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 我们为此规则使用了两个伪选择器。`:last-of-type` 选择器针对列表项中的最后一个`<time>`元素。如果只有一个`<time>`元素，它就是第一个；如果两个都存在，它就是第二个。然后我们添加
    `:after` 伪选择器，在该 `<time>` 元素之后插入内容。
- en: With these changes, we’ve cleaned up all of the obvious problems with our timeline
    (see [Figure 5-5](ch05.html#css_styles_make_the_timeline_easier_to_r "Figure 5-5. CSS
    styles make the timeline easier to read without changing the markup.")).
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这些更改，我们清除了时间轴中所有明显的问题（见[图5-5](ch05.html#css_styles_make_the_timeline_easier_to_r
    "图5-5. CSS样式让时间轴更易读，而无需更改标记。")）。
- en: '![CSS styles make the timeline easier to read without changing the markup.](figs/web/05fig05.png.jpg)Figure 5-5. CSS
    styles make the timeline easier to read without changing the markup.'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: '![CSS样式让时间轴更易读，而无需更改标记。](figs/web/05fig05.png.jpg)图5-5. CSS样式让时间轴更易读，而无需更改标记。'
- en: Now we can add a little flair to the visualization.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以为可视化增添一些亮点了。
- en: 'Step 7: Add Styles to Visually Structure the Timeline'
  id: totrans-116
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 第7步：为时间轴添加样式以进行视觉结构化
- en: The next set of CSS styles will improve the visual structure of the timeline.
    First among those improvements will be making the timeline look more like, well,
    a *line.* To do that, we can add a border to the left side of the `<li>` elements.
    At the same time, we’ll also want to make sure that those `<li>` elements don’t
    have any margins, as margins would introduce gaps in the border and break the
    continuity of the line.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来的CSS样式将改善时间轴的视觉结构。首先的改进将使时间轴看起来更像一条*线*。为此，我们可以在`<li>`元素的左侧添加边框。同时，我们还需要确保这些`<li>`元素没有任何外边距，因为外边距会在边框中引入空隙，破坏线条的连续性。
- en: '[PRE29]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: These styles add a nice vertical line on the left side of our entire timeline.
    Now that we have that line, we can shift the dates over to the left side of it.
    The shift requires rules for the parent `<li>` as well as the `<time>` elements.
    For the parent `<li>` elements, we want their `position` specified as `relative`.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 这些样式在我们的整个时间线左侧添加了一条漂亮的竖线。现在我们有了这条竖线，可以将日期移到它的左侧。这个偏移需要为父 `<li>` 元素以及 `<time>`
    元素分别设置规则。对于父 `<li>` 元素，我们希望它们的 `position` 设置为 `relative`。
- en: '[PRE30]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'By itself, this rule doesn’t actually change our timeline. It does, however,
    establish a *positioning context* for any elements that are children of the `<li>`.
    Those children include the `<time>` elements that we want to move. With the `<li>`
    set to `position: relative`, we can now set the `<time>` children to `position:
    absolute`. This rule lets us specify exactly where the browser should place the
    time elements, *relative* to the parent `<li>`. We want to move all `<time>` elements
    to the left, and we want to move the second `<time>` element down.'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: '单独使用这个规则实际上并不会改变我们的时间线。然而，它为任何 `<li>` 元素的子元素建立了一个*定位上下文*。这些子元素包括我们想要移动的 `<time>`
    元素。通过将 `<li>` 设置为 `position: relative`，我们可以将 `<time>` 子元素设置为 `position: absolute`。这个规则允许我们精确指定浏览器应该将时间元素放置在哪里，*相对于*父元素
    `<li>`。我们希望将所有 `<time>` 元素移到左侧，并且希望将第二个 `<time>` 元素向下移动。'
- en: '[PRE31]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: In the previous code, the first selector targets both of our `<time>` tags,
    while the second selector, using the same `time + time` trick described earlier,
    targets only the second of two `<time>` tags.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，第一个选择器选择了我们两个 `<time>` 标签，而第二个选择器使用之前提到的 `time + time` 技巧，仅选择了两个 `<time>`
    标签中的第二个。
- en: By using `em` units rather than `px` (pixel) units for this shift, we define
    the shift to be relative to the current font size, regardless of what it is. That
    gives us the freedom to change the font size without having to go back and tweak
    any pixel positioning.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用 `em` 单位而不是 `px`（像素）单位来进行位置偏移，我们使得偏移相对于当前的字体大小，而不管它具体是多少。这使我们能够在不需要重新调整任何像素位置的情况下自由更改字体大小。
- en: The specific values for the position shift may need adjustment depending on
    the specific font face, but, in general, we use a negative `left` position to
    shift content farther to the left than it would normally appear, and a positive
    `top` position to move the content down the page.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 位置偏移的具体值可能需要根据特定的字体样式进行调整，但一般来说，我们使用负的 `left` 位置将内容向左移动，超出正常位置，使用正的 `top` 位置将内容向页面下方移动。
- en: After moving the dates to the left of the vertical line, we’ll also want to
    shift the main content a bit to the right so it doesn’t crowd up against the line.
    The `padding-left` property takes care of that. And while we’re adjusting the
    left padding, we can also add a bit of padding on the bottom to separate each
    play from the other.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 在将日期移到竖线的左侧后，我们还需要将主要内容稍微向右移动，以免它与竖线挤在一起。`padding-left` 属性可以解决这个问题。同时，在调整左侧内边距时，我们还可以在底部添加一点内边距，以便将每个播放项分开。
- en: '[PRE32]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: With the dates and the main content on opposite sides of our vertical line,
    we no longer need any punctuation after the date, so we’ll remove the style that
    adds a colon after the last `<time>` element.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 由于日期和主要内容已经位于竖线的两侧，我们不再需要在日期后面添加标点符号，因此我们将移除为最后一个 `<time>` 元素添加冒号的样式。
- en: '[PRE33]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: The fact that we’re able to make this change highlights one of the reasons for
    using CSS to add the colon in the first place. If we had included the punctuation
    explicitly in the markup (by, for example, generating it in the JavaScript code),
    then our markup would be more tightly coupled to our styles. If a style modification
    changed whether the colon was appropriate, we would have to go back and change
    the JavaScript as well. With the approach that we’re using here, however, styles
    and markup are much more independent. Any style changes are isolated to our CSS
    rules; no modifications to the JavaScript are required.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 我们能够进行这一更改突出了使用 CSS 添加冒号的其中一个原因。如果我们在标记中显式包含了标点符号（例如，通过 JavaScript 代码生成它），那么我们的标记就会与样式紧密耦合。如果样式修改导致冒号不再合适，我们还需要返回修改
    JavaScript。然而，使用我们当前方法的好处在于，样式和标记之间更加独立。任何样式的更改都局限于我们的 CSS 规则，不需要修改 JavaScript。
- en: To further improve its visual styling, we can make a few other changes to our
    timeline. We can increase the font size for each play’s title to make that information
    more prominent. At the same time, we can add some extra spacing below the title
    and indent the description list a bit.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 为了进一步改善视觉样式，我们可以对时间轴进行一些其他更改。我们可以增加每部戏剧标题的字体大小，以使这些信息更加突出。同时，我们还可以在标题下方增加一些额外的空白，并稍微缩进描述列表。
- en: '[PRE34]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: For a last bit of polish, let’s add a bullet right on the vertical line to mark
    each play and tie the title more closely to the dates. We use a large bullet (several
    times the normal size) and position it right over the line.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，为了更加完善，让我们在垂直线上添加一个项目符号，用来标记每个戏剧，并将标题与日期更紧密地联系起来。我们使用一个大号项目符号（比正常大小大好几倍），并将其定位在直线上方。
- en: '[PRE35]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: As you can see, the Unicode character for a bullet can be represented as `"\2022"`.
    The exact position values will depend on the specific font, but a bit of trial
    and error can perfect the adjustments.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，Unicode 字符表示项目符号可以表示为 `"\2022"`。确切的位置值将取决于特定的字体，但通过一点试验和调整，能够完善这些调整。
- en: Now our timeline is starting to look like an actual timeline (as shown in [Figure 5-6](ch05.html#additional_styles_clarify_the_structure
    "Figure 5-6. Additional styles clarify the structure of the timeline elements.")).
    In your own pages, you could include additional styles to define fonts, colors,
    and so on, but even without those decorations the visualization is effective.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们的时间轴开始看起来像一个实际的时间轴（如图 [5-6](ch05.html#additional_styles_clarify_the_structure
    "图 5-6. 额外的样式澄清了时间轴元素的结构.") 所示）。在你的页面中，你可以包含额外的样式来定义字体、颜色等，但即使没有这些装饰，可视化效果依然有效。
- en: '![Additional styles clarify the structure of the timeline elements.](figs/web/05fig06.png.jpg)Figure 5-6. Additional
    styles clarify the structure of the timeline elements.'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: '![额外的样式澄清了时间轴元素的结构。](figs/web/05fig06.png.jpg)图 5-6. 额外的样式澄清了时间轴元素的结构。'
- en: 'Step 8: Add Interactivity'
  id: totrans-138
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 第 8 步：添加交互性
- en: The full details on all 40 of Shakespeare’s plays might be a little overwhelming
    for a first view of our timeline. The visualization would be more effective if
    it showed only the play titles at first, but let users reveal more details through
    interactions. Because we’re building this visualization ourselves, we have all
    the control necessary to make that happen.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 莎士比亚的 40 部戏剧的完整细节对于首次查看我们的时间轴来说可能会显得有些压倒性。如果最初只显示戏剧标题，用户通过交互揭示更多细节，效果会更好。因为我们是在自己构建这个可视化，所以我们拥有所有必要的控制权来实现这一目标。
- en: First we’ll set up a few additional styles. There are several ways to hide the
    play details with CSS, the most obvious being the `display:none` property. As
    we’ll see a little later, though, a better choice for our timeline is setting
    the `max-height` to `0`. If the maximum height of an element is 0, then, in theory,
    it should be invisible. In practice, we also have to set the `overflow` property
    to `hidden`. Otherwise, even though the `<dl>` element itself has no height, the
    browser will display the content that overflows from it. Since we want our description
    lists to start out hidden, we can set that property as the default.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将设置一些额外的样式。使用 CSS 隐藏播放详情有多种方法，其中最明显的是使用 `display:none` 属性。不过，正如我们稍后将看到的，对于我们的时间轴，设置
    `max-height` 为 `0` 会是一个更好的选择。如果元素的最大高度为 0，那么理论上它应该是不可见的。在实践中，我们还必须将 `overflow`
    属性设置为 `hidden`。否则，即使 `<dl>` 元素本身没有高度，浏览器仍然会显示溢出的内容。由于我们希望我们的描述列表初始时是隐藏的，因此可以将该属性设置为默认值。
- en: '[PRE36]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: To reveal a play’s details, users click on the play’s title in the `<cite>`
    element. To indicate to users that they can click on the title, we’ll change the
    mouse cursor from the normal arrow to the “clickable” hand. We can also change
    the `display` property from the default `inline` to `block`. That change gives
    users a larger and more consistent area to click.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 要显示戏剧的详情，用户点击 `<cite>` 元素中的戏剧标题。为了提示用户可以点击标题，我们将鼠标光标从默认的箭头改为“可点击”的手形光标。我们还可以将
    `display` 属性从默认的 `inline` 改为 `block`。这个变化使得用户点击的区域更大且更一致。
- en: '[PRE37]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Finally, we need a way to reveal a play’s details. We’ll do that by adding a
    class of `"expanded"` to the `<li>` for the play. When that class is present,
    our styles should override the `max-height` of `0`.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们需要一种方式来显示戏剧的详情。我们通过向该戏剧的 `<li>` 元素添加一个 `"expanded"` 类来实现。当这个类存在时，我们的样式应该覆盖
    `max-height` 为 0 的设置。
- en: '[PRE38]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: The exact value for the expanded `max-height` will depend on the content. In
    general, though, it should be large enough to reveal the full details for the
    item. It’s okay to make it a little larger than necessary “just in case.” Don’t
    go overboard, however, and make it unreasonably large. (We’ll see why at the end
    of this step.)
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 展开后的 `max-height` 的具体值将取决于内容。不过，通常来说，它应该足够大，以显示该项目的完整细节。当然，可以适当加大一点以防万一。但请注意，不要过度加大，使其不合理地变得非常大。（我们将在这一步的最后解释为什么。）
- en: With these styles in place, we can add a bit of JavaScript to control them.
    It won’t take much. The first step is writing an event handler that will be called
    when users click.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这些样式后，我们可以添加一点 JavaScript 来控制它们。这并不会花费太多时间。第一步是编写一个事件处理程序，当用户点击时会被调用。
- en: '[PRE39]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: This function takes a single parameter, specifically an `Event` object, with
    details about the click. One of those details is the `.target` property, which
    will contain a reference to the specific element of the page on which the user
    clicked. We care only about clicks on the `<cite>` elements.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数接受一个单一的参数，具体来说是一个 `Event` 对象，包含关于点击的详细信息。其中一个细节是 `.target` 属性，它将包含对页面上用户点击的特定元素的引用。我们只关心点击
    `<cite>` 元素。
- en: Once we know that a `<cite>` was clicked, we find its parent `<li>` element.
    We can then check to see if the `<li>` has the `"expanded"` class. If it doesn’t,
    we add it. If the class is already present, we remove it.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们知道某个 `<cite>` 被点击，我们就找到它的父元素 `<li>`。然后我们可以检查 `<li>` 是否有 `"expanded"` 类。如果没有，我们添加它。如果该类已经存在，我们移除它。
- en: '[PRE40]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Our approach is a bit primitive because it allows only one class to be defined
    for the `<li>`. That’s all we need for this example, though, so we’ll stick with
    it.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的方法有点原始，因为它只允许为 `<li>` 定义一个类。但对于本例来说，这已经足够了，因此我们将继续使用这个方法。
- en: Note
  id: totrans-153
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '**Modern browsers have a more sophisticated interface for controlling the class
    attributes of elements. That interface is the `classList`, and it easily supports
    multiple classes per element, as well as toggling the class on and off with a
    single function. Older browsers (namely Ie9 and earlier) don’t support that interface,
    however. Since we don’t need the extra functionality, the older `className` is
    sufficient for this example.**'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: '**现代浏览器拥有更为复杂的接口来控制元素的类属性。这个接口就是`classList`，它轻松支持每个元素多个类，并且能够通过一个函数轻松地切换类的开关。然而，旧版浏览器（即
    Ie9 及更早版本）不支持这个接口。由于我们不需要额外的功能，旧版的`className`对于本例来说已经足够了。**'
- en: With our event handling function defined, we can associate it with clicks anywhere
    on the timeline. The standard `addEventListener` method creates the association
    for any element.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 在定义了我们的事件处理函数后，我们可以将它与时间线上的任何点击关联起来。标准的 `addEventListener` 方法会为任何元素创建这个关联。
- en: '[PRE41]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: You might be curious as to why we’re associating an event listener with the
    entire timeline visualization instead of, for example, adding individual event
    listeners to each `<cite>`. That alternative would eliminate the need to check
    the event target in the handler; however, it turns out that it’s much less efficient
    than the approach we’re taking. Event listeners can consume a fair bit of JavaScript
    resources, and our page will perform better if we keep them to a minimum.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会好奇，为什么我们将事件监听器关联到整个时间线的可视化，而不是单独为每个 `<cite>` 添加事件监听器。那种替代方法会消除在处理程序中检查事件目标的需要；然而，事实证明，这比我们现在的做法效率要低得多。事件监听器会消耗相当多的
    JavaScript 资源，若我们将它们保持在最低限度，我们的页面性能会更好。
- en: 'If you’re using jQuery, the required code is even simpler:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你使用的是 jQuery，所需的代码甚至更简单：
- en: '[PRE42]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: We’re almost ready to show our new and improved timeline to the world, but there’s
    one final refinement we can make. Our current version shows or hides a play’s
    details all at once. This transition can be abrupt to users, as content appears
    or disappears instantly. We can provide a better experience by gracefully transitioning
    between the two states, and a natural transition for this timeline is animating
    the height of the content. When the details are hidden, they have a height of
    0\. And when we want to show them, we will gradually animate the height to its
    natural value.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 我们几乎准备好向全世界展示我们新改进的时间线了，但还有一个最终的细节可以完善。我们当前的版本会一下子显示或隐藏一个播放项的详情。这种过渡对用户来说可能会很突兀，因为内容会瞬间出现或消失。我们可以通过平滑过渡两种状态来提供更好的用户体验，而对于这个时间线来说，自然的过渡方式是动画效果调整内容的高度。当详情被隐藏时，它们的高度是
    0。而当我们想要显示它们时，我们会逐渐将高度动画到其自然值。
- en: It’s possible to add these animations using JavaScript. The jQuery library,
    in fact, has a fairly extensive set of animation functions. In modern browsers,
    however, it is much better to animate content using CSS transitions. Web browsers
    are optimized for CSS, often offloading the computations to special high-performance
    graphics coprocessors. In those cases, CSS-based animations can perform several
    orders of magnitude better than JavaScript. The only disadvantage to using CSS
    for animations is a lack of support in older browsers. But animation isn’t usually
    *critical* to most web pages. Sure, it’s nice, but if a user with an older browser
    misses out on the graceful transitions, it isn’t the end of the world. The web
    page will still *function* just fine.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 使用JavaScript也可以添加这些动画。事实上，jQuery库提供了相当广泛的动画功能。然而，在现代浏览器中，使用CSS过渡来动画化内容要好得多。Web浏览器已经针对CSS进行了优化，通常将计算任务卸载到专用的高性能图形协处理器上。在这些情况下，基于CSS的动画性能通常比JavaScript高出几个数量级。使用CSS进行动画的唯一缺点是老旧浏览器不支持。但动画通常对大多数网页来说并不是*关键*。当然，动画效果很好，但如果使用较旧浏览器的用户错过了流畅的过渡效果，那也不是世界末日。网页仍然会*正常运行*。
- en: 'The CSS `transition` property is the simplest way to define a CSS animation.
    It specifies the actual property to animate, the duration of the animation, and
    the *easing function* to follow. Here’s a rule we could use in our example:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: CSS的`transition`属性是定义CSS动画最简单的方式。它指定了要动画化的实际属性、动画的持续时间以及要遵循的*缓动函数*。这是我们在示例中可以使用的规则：
- en: '[PRE43]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: This rule defines a transition for the timeline’s `<dl>` elements. It specifies
    that the property to animate is `max-height`, so the transition will take effect
    whenever an element’s `max-height` property changes (and that’s precisely the
    property we modify when the `"expanded"` class is added or removed). The transition
    rule also specifies that the animation should take 500 milliseconds, and that
    it should “ease in” and “ease out.” This last property indicates that the animation
    should start slowly, speed up, and then slow down again before finishing. That
    behavior usually looks more natural than animating at a constant speed.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 该规则定义了时间轴的`<dl>`元素的过渡效果。它指定要动画化的属性是`max-height`，因此每当元素的`max-height`属性发生变化时（而这正是我们在添加或移除`"expanded"`类时所修改的属性），过渡效果将生效。过渡规则还指定动画应持续500毫秒，并且应“缓慢开始”并“缓慢结束”。这个属性表示动画应当从慢速开始，逐渐加速，然后在结束前再慢下来。通常这种行为比以恒定速度动画化更自然。
- en: CSS transitions can animate many CSS properties, but there is one important
    constraint. Both the starting and ending values must be explicit. That constraint
    explains why we’re animating `max-height` instead of `height`, even though it’s
    really just `height` that we want to change. Unfortunately, we can’t animate `height`,
    because it has no explicit value when the description list is expanded. Every
    `<dl>` will have its own height based on its content, and there’s no way we can
    predict those values in our CSS. The `max-height` property, on the other hand,
    gives us explicit values for both states—`0` and `40em` in this example—so CSS
    can animate its transitions. We just have to be sure that no `<dl>` has content
    more than `40em` high. Otherwise, the extra content will be cut off. This doesn’t
    mean, however, that we should set the `max-height` for expanded `<dl>` elements
    to an astronomical value. To see why, consider what would happen if we transitioned
    `max-height` to `1000em` for a `<dl>` that needed only `10em` of height. Ignoring
    (for simplicity) the complications of easing, it would take only 1/100 of the
    full transition time before the full content of the element was visible. The animation
    that we had planned to take 500 milliseconds is over in 5 milliseconds instead.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: CSS过渡可以动画化许多CSS属性，但有一个重要的限制。起始值和结束值必须是明确的。这个限制解释了为什么我们要动画化`max-height`而不是`height`，即使实际上我们只是想改变`height`。不幸的是，我们不能动画化`height`，因为在描述列表展开时它没有明确的值。每个`<dl>`的高度都会根据其内容有所不同，且我们无法在CSS中预测这些值。另一方面，`max-height`属性为两种状态提供了明确的值——在这个例子中是`0`和`40em`——因此CSS可以动画化其过渡效果。我们只需确保没有任何`<dl>`的内容超过`40em`的高度。否则，超出的内容将被截断。然而，这并不意味着我们应该将展开的`<dl>`元素的`max-height`设置为一个天文数字。为了理解为什么，请考虑如果我们将`max-height`过渡到`1000em`，而某个`<dl>`只需要`10em`的高度会发生什么情况。忽略（为了简化）缓动的复杂性，它将只需要完整过渡时间的1/100就能显示该元素的全部内容。原本我们计划持续500毫秒的动画将在5毫秒内结束。
- en: There is one final complication with CSS transitions. Most browsers implemented
    the functionality before the official standard was finalized. To make sure their
    implementations wouldn’t conflict with potential changes in the official standards,
    browser vendors initially implemented transitions using a proprietary syntax.
    That syntax adds a prefix (`-webkit-` for Safari and Chrome, `-moz-` for Firefox,
    and `-o-` for Opera) to the property name. To cover all the major browsers, we
    must include a rule with each prefix.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一个与 CSS 过渡相关的最后一个复杂问题。大多数浏览器在官方标准最终确定之前就实现了该功能。为了确保它们的实现不会与未来可能的官方标准变更冲突，浏览器供应商最初使用专有语法实现了过渡效果。该语法会在属性名称前添加一个前缀（`-webkit-`
    用于 Safari 和 Chrome，`-moz-` 用于 Firefox，`-o-` 用于 Opera）。为了覆盖所有主要浏览器，我们必须为每个前缀包含一个规则。
- en: '[PRE44]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: Note
  id: totrans-168
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '**Internet Explorer doesn’t need a prefix, because Microsoft didn’t implement
    transitions until the standard was stable. Also, there’s no harm in specifying
    multiple prefixes, since browsers simply ignore properties they don’t understand.**'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: '**Internet Explorer 不需要前缀，因为微软直到标准稳定后才实现了过渡效果。而且，指定多个前缀没有坏处，因为浏览器会忽略它们不理解的属性。**'
- en: Now our handcrafted timeline responds perfectly to user interactions. [Figure 5-7](ch05.html#fully_interactive_timeline_requires_only
    "Figure 5-7. A fully interactive timeline requires only HTML, CSS, and a little
    JavaScript.") shows the complete visualization.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们手工制作的时间线能够完美响应用户互动。[图 5-7](ch05.html#fully_interactive_timeline_requires_only
    "图 5-7. 一个完全交互式的时间线只需要 HTML、CSS 和一些 JavaScript。") 展示了完整的可视化效果。
- en: '![A fully interactive timeline requires only HTML, CSS, and a little JavaScript.](figs/web/05fig07.png.jpg)Figure 5-7. A
    fully interactive timeline requires only HTML, CSS, and a little JavaScript.'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: '![一个完全交互式的时间线只需要 HTML、CSS 和一些 JavaScript。](figs/web/05fig07.png.jpg)图 5-7.
    一个完全交互式的时间线只需要 HTML、CSS 和一些 JavaScript。'
- en: Using a Web Component
  id: totrans-172
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 Web 组件
- en: 'In this example, we’ll look at another alternative approach; instead of building
    a timeline from scratch using low-level JavaScript, we’ll integrate a full-featured
    timeline component: TimelineJS (*[http://timeline.knightlab.com/](http://timeline.knightlab.com/)*).
    In many ways this approach is the exact opposite of low-level JavaScript. At its
    most basic, it requires no coding at all; it can be as easy as embedding a YouTube
    video in a blog post. That method sacrifices a lot of control over the resulting
    visualization, however, so we’ll also look at ways to regain some of that control.'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们将查看另一种替代方法；我们将不再使用低级 JavaScript 从头构建时间线，而是集成一个功能齐全的时间线组件：TimelineJS
    (*[http://timeline.knightlab.com/](http://timeline.knightlab.com/)*）。在很多方面，这种方法与低级
    JavaScript 完全相反。最基本的形式下，它根本不需要编程；它可以像在博客文章中嵌入 YouTube 视频一样简单。然而，这种方法牺牲了对最终可视化效果的许多控制，因此我们也将查看如何重新获得一些控制权。
- en: 'Step 1: Preview the Standard Component'
  id: totrans-174
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 步骤 1：预览标准组件
- en: 'Before we spend too much time customizing the visualization, it’s worthwhile
    to check out the component in its most basic form. Fortunately, TimelineJS makes
    this process very simple. The website (*[http://timeline.knightlab.com/](http://timeline.knightlab.com/)*)
    will walk you through the steps in detail, but in a nutshell, they are as follows:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们花费太多时间定制可视化效果之前，值得先看看组件的最基本形式。幸运的是，TimelineJS 使这个过程变得非常简单。网站 (*[http://timeline.knightlab.com/](http://timeline.knightlab.com/)*）会详细带你完成步骤，但简单来说，步骤如下：
- en: Create a Google Docs spreadsheet (*[http://docs.google.com/](http://docs.google.com/)*)
    with data for the timeline.
  id: totrans-176
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个 Google Docs 表格 (*[http://docs.google.com/](http://docs.google.com/)*）以提供时间线的数据。
- en: Publish that spreadsheet for web access, which will create a URL for it.
  id: totrans-177
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 发布该表格以供网络访问，这将创建一个网址。
- en: Enter that URL into a form on the TimelineJS website, which will generate an
    HTML snippet.
  id: totrans-178
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 TimelineJS 网站的表单中输入该网址，这将生成一个 HTML 代码片段。
- en: Copy and paste the snippet into your web page.
  id: totrans-179
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将代码片段复制并粘贴到您的网页中。
- en: '[Figure 5-8](ch05.html#timelinejs_component_can_get_its_data_fr "Figure 5-8. The
    TimelineJS component can get its data from a Google Docs spreadsheet.") shows
    what the spreadsheet (*[https://docs.google.com/spreadsheet/ccc?key=0An4ME25ELRdYdDk4WmRacmxjaDM0V0tDTk9vMnQxU1E#gid=0](https://docs.google.com/spreadsheet/ccc?key=0An4ME25ELRdYdDk4WmRacmxjaDM0V0tDTk9vMnQxU1E#gid=0)*)
    looks like for Shakespeare’s plays.'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 5-8](ch05.html#timelinejs_component_can_get_its_data_fr "图 5-8. TimelineJS
    组件可以从 Google Docs 表格获取数据。") 展示了莎士比亚剧本的表格是怎样的 (*[https://docs.google.com/spreadsheet/ccc?key=0An4ME25ELRdYdDk4WmRacmxjaDM0V0tDTk9vMnQxU1E#gid=0](https://docs.google.com/spreadsheet/ccc?key=0An4ME25ELRdYdDk4WmRacmxjaDM0V0tDTk9vMnQxU1E#gid=0)*)。'
- en: '![The TimelineJS component can get its data from a Google Docs spreadsheet.](figs/web/05fig08.png.jpg)Figure 5-8. The
    TimelineJS component can get its data from a Google Docs spreadsheet.'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: '![TimelineJS 组件可以从 Google Docs 表格获取数据。](figs/web/05fig08.png.jpg)图5-8. TimelineJS
    组件可以从 Google Docs 表格获取数据。'
- en: 'The HTML snippet that TimelineJS creates for this timeline is as follows:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: TimelineJS 为这个时间轴创建的 HTML 代码片段如下：
- en: '[PRE45]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: When included in a page, that snippet results in fully interactive timeline
    for the chronology, as shown in [Figure 5-9](ch05.html#timelinejs_builds_a_complete_timeline_co
    "Figure 5-9. TimelineJS builds a complete timeline component within an <iframe>.").
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 当被包含在页面中时，该代码片段会呈现一个完全互动的时间轴，如 [图5-9](ch05.html#timelinejs_builds_a_complete_timeline_co
    "图5-9. TimelineJS 在 `<iframe>` 中构建一个完整的时间轴组件。")所示。
- en: '![TimelineJS builds a complete timeline component within an <iframe>.](figs/web/05fig09.png.jpg)Figure 5-9. TimelineJS
    builds a complete timeline component within an `<iframe>`.'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: '![TimelineJS 在 `<iframe>` 中构建一个完整的时间轴组件。](figs/web/05fig09.png.jpg)图5-9. TimelineJS
    在 `<iframe>` 中构建一个完整的时间轴组件。'
- en: 'If the result meets the needs of your visualization, you may not have to go
    any further. Many web pages that use TimelineJS do so in exactly this manner.
    There are some potential problems with the simplest approach, however:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 如果结果满足你的可视化需求，你可能无需进一步操作。许多使用 TimelineJS 的网页就是以这种方式进行的。然而，最简单的做法也存在一些潜在的问题：
- en: The data for the visualization must be available in a public Google Docs spreadsheet,
    so the approach may not be appropriate for confidential data.
  id: totrans-187
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可视化所需的数据必须公开在一个 Google Docs 表格中，因此这种方法可能不适用于机密数据。
- en: The data source is a spreadsheet, so it may be difficult to update it often
    or show more real-time events. This problem doesn’t really affect our Shakespeare
    chronology, but if the timeline you’re creating shows real-time data such as trending
    topics on a social network, a static spreadsheet won’t be practical.
  id: totrans-188
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数据源是一个电子表格，因此频繁更新或显示更多实时事件可能会变得困难。这个问题实际上并不会影响我们的莎士比亚时间轴，但如果你创建的时间轴显示的是像社交网络上的热门话题这样的实时数据，静态的电子表格就不太实用了。
- en: The embedded component has few styling options. Although the default styles
    and options that TimelineJS offers are quite attractive, they are very limited
    and may not be appropriate for your web page.
  id: totrans-189
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 嵌入的组件样式选项很少。虽然 TimelineJS 提供的默认样式和选项非常吸引人，但它们非常有限，可能不适合你的网页。
- en: The timeline is embedded as an `<iframe>`, which gives TimelineJS complete control
    over what is displayed in that section of your page. While there is *absolutely
    no indication* that the organizations supporting TimelineJS would do so, *in theory*
    they could alter the content (for example, by including ads) in ways that your
    site might not find appropriate.
  id: totrans-190
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 时间轴作为 `<iframe>` 嵌入，这使得 TimelineJS 完全控制页面中该部分显示的内容。虽然*绝对没有迹象表明*支持 TimelineJS
    的组织会这么做，*理论上*它们可能会以你的网站不希望的方式更改内容（例如，插入广告）。
- en: Fortunately, none of these possible concerns need prevent us from adding beautiful
    TimelineJS visualizations to our web pages. The folks behind TimelineJS make all
    of the software available as open source, giving us the flexibility to address
    all of the aforementioned issues. We’ll see how in the rest of this example.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，这些潜在的担忧不会妨碍我们将漂亮的 TimelineJS 可视化效果添加到我们的网页中。TimelineJS 的开发者将所有软件作为开源提供，使我们能够灵活解决上述问题。在本示例的其余部分中，我们将看到如何解决这些问题。
- en: 'Step 2: Include the Required Components'
  id: totrans-192
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 第2步：包含所需的组件
- en: To use TimelineJS, our web pages must include CSS style sheets and JavaScript
    code. For now we’ll stick with the default styles, so we need only a single additional
    style sheet. The main JavaScript is contained in timeline.js.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用 TimelineJS，我们的网页必须包含 CSS 样式表和 JavaScript 代码。目前我们将坚持使用默认样式，因此只需要一个额外的样式表。主要的
    JavaScript 代码包含在 timeline.js 中。
- en: It’s not obvious, but TimelineJS also requires jQuery. When you embed a TimelineJS
    `<iframe>`, your main web page doesn’t have to include jQuery, because the `<iframe>`
    will include it. To integrate the timeline directly in our page, though, we have
    to include jQuery explicitly. We can, however, use a content distribution network
    instead of hosting it ourselves. (See [Chapter 2](ch02.html "Chapter 2. Making
    Charts Interactive") for more details on the advantages and disadvantages of content
    distribution networks.)
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然不明显，但 TimelineJS 还需要 jQuery。当你嵌入 TimelineJS 的 `<iframe>` 时，你的主网页不需要包含 jQuery，因为
    `<iframe>` 会包含它。然而，要将时间轴直接集成到页面中，我们必须显式地包含 jQuery。不过，我们可以使用内容分发网络（CDN），而不是自己托管它。（有关内容分发网络的优缺点，请参见
    [第 2 章](ch02.html "第 2 章：使图表具有互动性)。
- en: '[PRE46]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: The HTML at this point doesn’t include the element in which we’ll place the
    timeline. There are some special constraints on that element, which we’ll consider
    when we add it to the page.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 此时的 HTML 并不包括我们放置时间轴的元素。该元素有一些特殊的约束，我们将在将其添加到页面时考虑这些约束。
- en: 'Step 3: Prepare the Data'
  id: totrans-197
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 第 3 步：准备数据
- en: 'Because TimelineJS supports several features that we haven’t used in the earlier
    examples, we’ll add a few additional properties to our data set. The overall format,
    though, looks the same as before:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 因为 TimelineJS 支持我们在前面的示例中没有使用的一些功能，我们将向数据集添加一些额外的属性。不过，整体格式看起来与之前相同：
- en: '[PRE47]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: As you can see, we’ve added genre information to the plays, as well as optional
    multimedia links, and text for credits and captions. With that starting point,
    we can rearrange the data to match what TimelineJS expects. The basic structure
    of that object, shown next, includes some overall properties (such as the headline),
    and an array of events. We can initialize it to an empty array.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，我们已向戏剧中添加了类别信息、可选的多媒体链接以及用于字幕和说明的文本。以此为起点，我们可以重新排列数据，以匹配 TimelineJS 的预期格式。接下来显示的对象的基本结构包括一些总体属性（如标题），以及一个事件数组。我们可以将其初始化为空数组。
- en: '[PRE48]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: Note that the `type` property is required and should be set to `"default"`.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，`type` 属性是必需的，应该设置为 `"default"`。
- en: Now we iterate through the data set, adding events to `timelineData`. For the
    following code, we’ll use `forEach` for this iteration, but there are plenty of
    alternatives we could use here (including `for` loops, array `.map()` methods,
    or jQuery’s `$.each()` and `$.map()` functions).
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们遍历数据集，将事件添加到 `timelineData` 中。对于以下代码，我们将使用 `forEach` 进行此遍历，但这里有很多替代方法可以使用（包括
    `for` 循环、数组的 `.map()` 方法，或 jQuery 的 `$.each()` 和 `$.map()` 函数）。
- en: '[PRE49]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'The first step in each iteration is parsing the date information. It can take
    one of two forms: either a single year (`"1591"`) or a range of years (`"1589-1591"`).
    Our code assumes a single date and makes adjustments if it finds two.'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 每次迭代的第一步是解析日期信息。它可以有两种形式：单一年份（`"1591"`）或年份范围（`"1589-1591"`）。我们的代码假设为单一日期，并在找到两个日期时进行调整。
- en: Now we can provide the full entry for the event in TimelineJS format by pushing
    the new object into the `timelineData.date` array.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以通过将新对象推送到 `timelineData.date` 数组中，提供事件的完整条目，格式为 TimelineJS 格式。
- en: '[PRE50]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'Step 4: Create a Default Timeline'
  id: totrans-208
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 第 4 步：创建默认时间轴
- en: With our HTML set up and our data set prepared, we can now call TimelineJS to
    create its default visualization. Figuring out exactly how to do that, however,
    isn’t quite as simple as looking in the documentation. That’s because TimelineJS
    assumes that it will be used primarily as an embedded and isolated component rather
    than an integrated part of a page. The documentation, therefore, describes how
    to use TimelineJS using the *storyjs_embed.js* wrapper for embedded content. That
    wrapper loads all the TimelineJS resources (style sheets, JavaScript, fonts, and
    so on), and if we use it as intended, we’ll end up with most of the same problems
    as if we had simply embedded an `<iframe>`.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 在设置好 HTML 和准备好数据集后，我们现在可以调用 TimelineJS 来创建其默认的可视化效果。然而，弄清楚如何做到这一点并不像查看文档那么简单。这是因为
    TimelineJS 假设它主要作为嵌入式和独立组件使用，而不是作为页面的一部分。因此，文档描述了如何使用 *storyjs_embed.js* 封装器来嵌入内容。该封装器加载所有
    TimelineJS 资源（样式表、JavaScript、字体等），如果我们按照预期使用它，我们将遇到大部分与简单嵌入 `<iframe>` 相同的问题。
- en: 'Fortunately, it’s not too difficult to skip all the embedding and simply access
    the JavaScript code directly. It requires only three steps:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，跳过所有嵌入内容，直接访问 JavaScript 代码并不困难。这仅需要三步：
- en: Set up the configuration object.
  id: totrans-211
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 设置配置对象。
- en: Create a TimelineJS object.
  id: totrans-212
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个 TimelineJS 对象。
- en: Initialize the object using the configuration object.
  id: totrans-213
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用配置对象初始化该对象。
- en: 'Here’s what these steps will look like in our JavaScript, with the details
    omitted for now:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 这些步骤在我们的JavaScript中将会是这样的，暂时省略了细节：
- en: '[PRE51]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'We still need to fill in the exact configuration object and the parameters
    for the `VMM.Timeline` constructor. The configuration object is documented in
    the TimelineJS source (*[https://github.com/NUKnightLab/TimelineJS#config-options](https://github.com/NUKnightLab/TimelineJS#config-options)*).
    We must provide a `type` (equal to `"timeline"`), dimensions, the data source,
    and the `id` of the HTML element into which the timeline should be placed. For
    example, we could use this:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 我们仍然需要填写完整的配置对象以及`VMM.Timeline`构造函数的参数。配置对象在TimelineJS源码中有文档说明（* [https://github.com/NUKnightLab/TimelineJS#config-options](https://github.com/NUKnightLab/TimelineJS#config-options)
    *）。我们必须提供一个`type`（等于`"timeline"`）、尺寸、数据源以及将要放置时间轴的HTML元素的`id`。例如，我们可以使用如下内容：
- en: '[PRE52]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: We have to pass many of those same parameters to the constructor. In particular,
    we provide the container’s `id` and the dimensions.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要将这些相同的参数传递给构造函数。特别地，我们提供容器的`id`和尺寸。
- en: '[PRE53]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: Finally, we have to build our HTML markup with care. TimelineJS styles its HTML
    appropriately for an embedded `<iframe>`, but those styles aren’t as compatible
    with a timeline that’s integrated in the page. In particular, it positions the
    time-line absolutely and sets its `z-index`. If we don’t compensate, the timeline
    will float out of the flow of the page content, which is almost certainly not
    desirable. There are several ways to adjust for this issue, and we’ll use a simple
    one in this example. Instead of a single `<div>`, we use two nested `<div>` elements.
    The inner `<div>` will contain the timeline, and the outer `<div>` establishes
    both a positioning context and size for the timeline.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们必须小心地构建我们的HTML标记。TimelineJS会为嵌入的`<iframe>`适当设置其HTML样式，但这些样式与直接嵌入页面中的时间轴并不完全兼容。特别是，它会绝对定位时间轴并设置其`z-index`。如果我们不进行补偿，时间轴将会脱离页面内容的流，几乎肯定这是不希望出现的情况。解决这个问题的方法有很多种，我们将在这个例子中使用一种简单的方法。我们不使用单一的`<div>`，而是使用两个嵌套的`<div>`元素。内层的`<div>`将包含时间轴，外层的`<div>`则为时间轴建立了定位上下文和尺寸。
- en: '[PRE54]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: Now when our JavaScript executes, it produces the integrated timeline shown
    in [Figure 5-10](ch05.html#with_a_little_extra_workcomma_we_can_emb "Figure 5-10. With
    a little extra work, we can embed a TimelineJS timeline directly in the page without
    an <iframe>.") with the default TimelineJS styling.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，当我们的JavaScript执行时，它会生成集成的时间轴，如[图5-10](ch05.html#with_a_little_extra_workcomma_we_can_emb
    "图5-10. 只需稍加工作，我们可以在页面中直接嵌入TimelineJS时间轴，而无需使用<iframe>")所示，并使用默认的TimelineJS样式。
- en: Before we leave this step, it’s worth considering how we’ve reached this point.
    We’ve taken a complete web component with explicit instructions for its use, and
    ignored those instructions. Instead, we’ve included only part of the component
    (albeit a major part). Figuring out how to use an isolated part of a web component
    (in a way that it isn’t necessarily intended for) can involve some guesswork and
    trial and error, and there is clearly some risk in this approach. Even if you
    manage to get it working now, a future update might invalidate your implementation.
    If you adopt this approach with your website, it’s a good idea to test the implementation
    thoroughly and to take extra care with any updates.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们完成这一步之前，值得考虑一下我们是如何到达这一点的。我们使用了一个完整的Web组件，并有明确的使用说明，但我们忽略了这些说明。相反，我们只包含了该组件的一部分（虽然是一个重要部分）。弄清楚如何使用一个孤立的Web组件部分（以一种它并不一定意图的方式）可能涉及一些猜测和反复试验，显然这种方法存在一定风险。即使你现在设法让它工作，将来的更新可能会使你的实现失效。如果你在你的网站上采用这种方法，最好彻底测试实现并在更新时格外小心。
- en: '![With a little extra work, we can embed a TimelineJS timeline directly in
    the page without an <iframe>.](figs/web/05fig10.png.jpg)Figure 5-10. With a little
    extra work, we can embed a TimelineJS timeline directly in the page without an
    `<iframe>`.'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: '![只需稍加工作，我们可以在页面中直接嵌入TimelineJS时间轴，而无需使用<iframe>](figs/web/05fig10.png.jpg)图5-10.
    只需稍加工作，我们可以在页面中直接嵌入TimelineJS时间轴，而无需使用`<iframe>`。'
- en: 'Step 5: Adjust the Timeline Styles'
  id: totrans-225
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 第5步：调整时间轴样式
- en: Now that we’ve addressed the issues that an `<iframe>` can cause, we can turn
    our attention to the timeline’s appearance. The *timeline.css* stylesheet determines
    that appearance, and there are several alternatives for adjusting it.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经解决了`<iframe>`可能引起的问题，我们可以将注意力转向时间轴的外观。*timeline.css*样式表决定了这个外观，并且有几种方法可以调整它。
- en: '****Modify *timeline.css* directly****. Although this approach might seem the
    most obvious, it’s probably not what we should do. If you look at the file, you’ll
    notice that it’s compressed CSS that’s difficult to read and understand. Making
    the appropriate modifications will be challenging. Furthermore, if we later update
    to a new version of TimelineJS, that new version may well have a new *timeline.css*
    file, and we’d have to start all over again.'
  id: totrans-227
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '****直接修改 *timeline.css*****。尽管这种方法看起来是最直接的，但它可能不是我们应该采用的方式。如果你查看文件，会发现它是压缩后的
    CSS，难以阅读和理解。进行适当的修改将是一个挑战。此外，如果我们以后更新到 TimelineJS 的新版本，新版本可能会包含一个新的 *timeline.css*
    文件，而我们将不得不从头开始。'
- en: '****Work with the source code****. TimelineJS authors its styles using the
    LESS (*[http://lesscss.org/](http://lesscss.org/)*) CSS preprocessor. If you’re
    comfortable using a CSS preprocessor, you could modify the source and build your
    own custom version of *timeline.css*. LESS has support for variables and mixins
    that make it easier to accommodate updates in the future. There are many applications
    that compile LESS into CSS; TimelineJS uses CodeKit (*[https://incident57.com/codekit/](https://incident57.com/codekit/)*),
    which is available only for Apple’s Mac OS X, and the source code includes all
    of the appropriate application settings.'
  id: totrans-228
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '****使用源代码****。TimelineJS 使用 LESS (*[http://lesscss.org/](http://lesscss.org/)*
    ) CSS 预处理器编写样式。如果你习惯使用 CSS 预处理器，你可以修改源代码并构建自己定制版本的 *timeline.css*。LESS 支持变量和混合宏，使得未来更新更容易适应。许多应用程序都可以将
    LESS 编译为 CSS；TimelineJS 使用的是 CodeKit (*[https://incident57.com/codekit/](https://incident57.com/codekit/)*
    )，它仅适用于苹果的 Mac OS X 系统，并且源代码包括所有适当的应用程序设置。'
- en: '****Supersede *timeline.css* styles****. Instead of changing the TimelineJS
    style sheet, leave it *as is* and add custom styles with a higher priority than
    the default styles. This approach takes advantage of the *cascade* in Cascading
    Style Sheets.'
  id: totrans-229
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '****替代 *timeline.css* 样式****。 与其更改 TimelineJS 样式表，不如保持 *原样*，并添加具有更高优先级的自定义样式。这个方法利用了层叠样式表中的*级联*特性。'
- en: For this example, we’ll use the last approach. We’ll identify the *timeline.css*
    styles that we want to change and add new rules to our style sheet to take precedence
    over those styles. When CSS finds that multiple, conflicting rules apply to an
    element, it resolves the conflict by considering the specificity of the rules
    and their order in the document. We can give our rules priority by making them
    more specific than the *timeline.css* rules, or by making them equally specific
    but including them after *timeline.css*.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个例子，我们将使用最后一种方法。我们将识别出需要更改的*timeline.css*样式，并在我们的样式表中添加新的规则，以使这些规则优先于原有样式。当
    CSS 发现多个冲突的规则应用于某个元素时，它会通过考虑规则的特定性以及它们在文档中的顺序来解决冲突。我们可以通过使规则比*timeline.css*中的规则更具体，或者通过使它们同样具体但放在*timeline.css*之后来优先应用我们的规则。
- en: 'First we’ll tackle the fonts that TimelineJS uses. There’s nothing wrong with
    the default or optional fonts, but they may not match the style of our web page.
    In addition, downloading extra fonts will slow the performance of the page. The
    quickest way to find the styles that affect fonts is to look at one of the optional
    font selections that TimelineJS offers on its website. For example, if you select
    the “Merriweather & News Cycle” option, you’ll see that TimelineJS adds an additional
    style sheet to the visualization, *NewsCycle-Merriweather.css*, which defines
    all the font rules for this option:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将处理 TimelineJS 使用的字体。默认字体或可选字体没有问题，但它们可能与我们网页的风格不符。此外，下载额外的字体会减慢页面的性能。找到影响字体的样式的最快方法是查看
    TimelineJS 在其网站上提供的可选字体之一。例如，如果你选择“Merriweather & News Cycle”选项，你会看到 TimelineJS
    为可视化添加了一个额外的样式表，*NewsCycle-Merriweather.css*，该样式表定义了这个选项的所有字体规则：
- en: '[PRE55]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: To use our own fonts, all we need to do is copy that file and replace `"News
    Cycle"` and `"Merriweather"` with our own choice—in this case, Avenir.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用我们自己的字体，我们只需要复制该文件，并将 `"News Cycle"` 和 `"Merriweather"` 替换为我们自己的选择——在这种情况下是
    Avenir。
- en: '[PRE56]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: Customizing other aspects of the TimelineJS visualization is more challenging
    but not impossible. These customizations are rather fragile, however, as even
    the slightest change in the TimelineJS implementation could render them ineffective.
    If it’s important for your page, though, it can be done.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 定制 TimelineJS 可视化的其他方面更具挑战性，但并非不可能。然而，这些定制比较脆弱，因为 TimelineJS 实现的任何细微变化都可能使它们失效。如果你的页面需要这类定制，它是可以实现的。
- en: 'For our example, we’ll change the blue color that TimelineJS uses in the bottom
    section of the visualization. It uses that color to highlight the active item,
    to show the timeline marker, and for the event line. Finding the specific rules
    to override takes a bit of detective work with your browser’s developer tools,
    but here’s how to change the color from blue to green:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们的示例，我们将更改TimelineJS在可视化底部部分使用的蓝色。它使用这种颜色来突出显示活动项、显示时间轴标记以及事件线。要找到需要覆盖的具体规则，需要通过浏览器的开发者工具进行一些侦查，但这里是如何将颜色从蓝色更改为绿色的方法：
- en: '[PRE57]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: Combining font changes with the alternative color scheme helps the visualization
    integrate more seamlessly in an overall web page, as [Figure 5-11](ch05.html#adjusting_the_css_for_timelinejs_can_hel
    "Figure 5-11. Adjusting the CSS for TimelineJS can help match its styles with
    the rest of the web page.") shows.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 将字体变化与替代的配色方案结合，可以帮助可视化效果更好地融入整个网页，如[图5-11](ch05.html#adjusting_the_css_for_timelinejs_can_hel
    "图5-11。调整TimelineJS的CSS可以帮助将其样式与网页的其余部分相匹配。")所示。
- en: '![Adjusting the CSS for TimelineJS can help match its styles with the rest
    of the web page.](figs/web/05fig11.png.jpg)Figure 5-11. Adjusting the CSS for
    TimelineJS can help match its styles with the rest of the web page.'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: '![调整TimelineJS的CSS可以帮助将其样式与网页的其余部分相匹配。](figs/web/05fig11.png.jpg)图5-11。调整TimelineJS的CSS可以帮助将其样式与网页的其余部分相匹配。'
- en: Summing Up
  id: totrans-240
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we’ve looked at a wide range of approaches for creating timeline
    visualizations. The most familiar approach relies on an open source library, but
    we also considered two other options. In one, we developed the code for a timeline
    from scratch, which gave us complete control over its appearance and behavior.
    For the other extreme, we examined a popular open source web component. Pages
    normally use that component by embedding `<iframe>` elements in the page, but
    we also saw that it’s possible to take the open source code and integrate it more
    seamlessly in our pages, even altering the visual styles if necessary.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们探讨了多种创建时间轴可视化的方法。最常见的方法依赖于一个开源库，但我们还考虑了另外两种选择。在其中一种方法中，我们从头开始开发了时间轴的代码，这使我们对其外观和行为有完全的控制。对于另一种极端方法，我们研究了一个流行的开源网页组件。通常，页面通过嵌入`<iframe>`元素来使用该组件，但我们也看到，完全可以将开源代码提取并更加无缝地集成到我们的页面中，甚至在必要时改变视觉样式。
