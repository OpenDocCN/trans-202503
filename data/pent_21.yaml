- en: Chapter 16. A Stack-Based Buffer Overflow in Linux
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第16章. Linux中的基于栈的缓冲区溢出
- en: So far we’ve used tools such as Metasploit and public exploit code on the Internet
    to exploit our target systems. But you may find a vulnerability in your pentesting
    career that has no such exploit code, or you may discover a new security issue
    and want to write your own exploit code for it. In this chapter and the next three,
    we will look at the basics of writing our own exploits. We won’t cover everything
    through the latest and greatest iPhone jailbreak, but we will look at some real-world
    examples of vulnerable programs and learn how to write working exploits for them
    by hand.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经使用了诸如Metasploit和互联网公开的漏洞利用代码来攻击我们的目标系统。但在渗透测试过程中，你可能会遇到没有现成漏洞利用代码的漏洞，或者你可能发现了一个新的安全问题，想为其编写自己的漏洞利用代码。在本章和接下来的三章中，我们将学习如何编写自己的漏洞利用代码。我们不会覆盖所有最新的iPhone越狱方法，但我们会通过一些真实世界中的易受攻击程序来学习如何手动编写有效的漏洞利用代码。
- en: We’ll begin with a simple vulnerable program on our Linux target and make the
    program do something its developer never intended.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从一个简单的易受攻击的程序开始，在我们的Linux目标上让程序做一些开发者未曾预期的事情。
- en: Note
  id: totrans-3
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: All of the examples in [Chapter 16](ch16.xhtml "Chapter 16. A Stack-Based Buffer
    Overflow in Linux") through [Chapter 19](ch19.xhtml "Chapter 19. Fuzzing, Porting
    Exploits, and Metasploit Modules") use x86 architecture.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 本章及[第16章](ch16.xhtml "第16章. Linux中的基于栈的缓冲区溢出")到[第19章](ch19.xhtml "第19章. 模糊测试、漏洞利用移植与Metasploit模块")中的所有示例都使用x86架构。
- en: Memory Theory
  id: totrans-5
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 内存理论
- en: Before we dive into writing our own exploits, we need to get a handle on the
    basics of how memory works. Our goal is to manipulate memory and trick the CPU
    into executing instructions on our behalf. We’ll use a technique called a *stack-based
    buffer overflow*, which involves overfilling a variable on the program’s memory
    stack and overwriting adjacent memory locations. But first, we need to know a
    little bit about how a program’s memory is laid out, as shown in [Figure 16-1](ch16.xhtml#memory_visualization
    "Figure 16-1. Memory visualization").
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始编写自己的漏洞利用代码之前，我们需要掌握一些内存工作的基本概念。我们的目标是操作内存并诱使CPU代替我们执行指令。我们将使用一种称为*基于栈的缓冲区溢出*的技术，它涉及到在程序的内存栈上填充超出变量大小的内容，从而覆盖相邻的内存位置。但首先，我们需要了解一下程序内存的布局，如[图16-1](ch16.xhtml#memory_visualization
    "图16-1. 内存可视化")所示。
- en: '![Memory visualization](httpatomoreillycomsourcenostarchimages2030502.png)Figure 16-1. Memory
    visualization'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: '![内存可视化](httpatomoreillycomsourcenostarchimages2030502.png)图16-1. 内存可视化'
- en: The *text* segment contains the program code to be executed, while the *data*
    segment contains global information for the program. At higher addresses, we have
    a portion shared by the stack and heap, which are allocated at runtime. The *stack*
    is fixed in size and is used to store function arguments, local variables, and
    so on. The *heap* holds dynamic variables. The stack consumption increases as
    more functions or subroutines are called, and the top of the stack points at lower
    memory addresses as more data is stored on the stack.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: '*text* 段包含要执行的程序代码，而 *data* 段包含程序的全局信息。在更高的地址上，我们有一部分是栈和堆共享的，它们在运行时被分配。*stack*
    是固定大小的，用于存储函数参数、局部变量等。*heap* 用于存放动态变量。随着更多的函数或子程序被调用，栈的消耗增加，并且栈顶指向较低的内存地址，因为更多的数据被存储在栈上。'
- en: 'Our Intel-based CPU has general-purpose registers where it can store data for
    future use. These include:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的Intel处理器具有通用寄存器，用于存储未来可能使用的数据。这些寄存器包括：
- en: '| **EIP** | instruction pointer |'
  id: totrans-10
  prefs: []
  type: TYPE_TB
  zh: '| **EIP** | 指令指针 |'
- en: '| **ESP** | stack pointer |'
  id: totrans-11
  prefs: []
  type: TYPE_TB
  zh: '| **ESP** | 栈指针 |'
- en: '| **EBP** | base pointer |'
  id: totrans-12
  prefs: []
  type: TYPE_TB
  zh: '| **EBP** | 基址指针 |'
- en: '| **ESI** | source index |'
  id: totrans-13
  prefs: []
  type: TYPE_TB
  zh: '| **ESI** | 源索引 |'
- en: '| **EDI** | destination index |'
  id: totrans-14
  prefs: []
  type: TYPE_TB
  zh: '| **EDI** | 目标索引 |'
- en: '| **EAX** | accumulator |'
  id: totrans-15
  prefs: []
  type: TYPE_TB
  zh: '| **EAX** | 累加器 |'
- en: '| **EBX** | base |'
  id: totrans-16
  prefs: []
  type: TYPE_TB
  zh: '| **EBX** | 基址 |'
- en: '| **ECX** | counter |'
  id: totrans-17
  prefs: []
  type: TYPE_TB
  zh: '| **ECX** | 计数器 |'
- en: '| **EDX** | data |'
  id: totrans-18
  prefs: []
  type: TYPE_TB
  zh: '| **EDX** | 数据 |'
- en: ESP, EBP, and EIP are particularly interesting to us. ESP and EBP together keep
    track of the stack frame of the currently executing function.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: ESP、EBP和EIP对我们特别重要。ESP和EBP一起跟踪当前执行函数的栈帧。
- en: As shown in [Figure 16-2](ch16.xhtml#stack_frame "Figure 16-2. Stack frame"),
    ESP points to the top of the stack frame at its lowest memory address, and likewise,
    EBP points to the highest memory address at the bottom of the stack frame. EIP
    holds the memory address of the next instruction to be executed. Because our goal
    is to hijack execution and make the target machine execute what we want, EIP seems
    like a prime target for compromise. But how do we get our instructions to EIP?
    EIP is read only, so we can’t just put a memory address to be executed in this
    register; we will need to be a bit cleverer.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 如[图16-2](ch16.xhtml#stack_frame "图16-2. 栈帧")所示，ESP指向栈帧的顶部，即它的最低内存地址，而EBP指向栈帧底部的最高内存地址。EIP保存着下一条将要执行的指令的内存地址。因为我们的目标是劫持执行并让目标机器执行我们想要的指令，EIP看起来是一个理想的攻击目标。但我们如何将我们的指令送到EIP呢？EIP是只读的，所以我们不能直接将一个内存地址放入这个寄存器；我们需要更加巧妙一些。
- en: '![Stack frame](httpatomoreillycomsourcenostarchimages2030504.png.jpg)Figure 16-2. Stack
    frame'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: '![栈帧](httpatomoreillycomsourcenostarchimages2030504.png.jpg)图16-2. 栈帧'
- en: The stack is a last-in, first-out data structure. You can think of it like a
    stack of lunch trays at a cafeteria. The last tray that is added to the stack
    is the first tray that is taken off when one is needed. To add data to the stack,
    a `PUSH` instruction is used. Likewise, to remove data from the stack, we use
    a `POP` instruction. (Remember that the stack consumption increases to lower memory
    addresses, so when data is pushed onto the current stack frame, ESP moves to a
    lower address in memory.)
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 栈是一个先进后出（LIFO）的数据结构。你可以把它想象成食堂里的一堆托盘。最后放上去的托盘是第一个被取走的。要向栈中添加数据，使用`PUSH`指令。同样，要从栈中移除数据，我们使用`POP`指令。（记住，栈的消耗是向着更低的内存地址增加的，因此当数据被压入当前栈帧时，ESP会移动到内存中的更低地址。）
- en: When a program function is executed, a stack frame for its information (such
    as local variables) is pushed onto the stack. Once the function finishes executing,
    the entire stack frame is unwound, ESP and EBP point back to the caller function’s
    stack frame, and execution continues in the caller function where it left off.
    However, the CPU must know where in memory to continue from, and it obtains that
    information from the *return address*, which is pushed onto the stack when a function
    is called.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 当程序函数被执行时，它的信息（如局部变量）会被压入栈帧。函数执行完毕后，整个栈帧会被展开，ESP和EBP会指向调用函数的栈帧，执行将继续从调用函数的上次执行位置开始。然而，CPU必须知道从内存中的哪个位置继续执行，它通过*返回地址*获取这一信息，而返回地址在调用函数时会被压入栈中。
- en: Say, for instance, that we are running a C program. Naturally, the function
    `main` is called when the program begins, and a stack frame is allocated for it.
    `main` then calls another function, `function1`. Before pushing a stack frame
    for `function1` onto the stack and handing over execution, `main` notes where
    execution will need to continue when `function1` returns (typically the line of
    code directly after the call to `function1`) by pushing this value—its return
    address—onto the stack. [Figure 16-3](ch16.xhtml#stack_after_call_to_function1
    "Figure 16-3. Stack after call to function1") shows the stack after `main`’s call
    to `function1`.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 比如，假设我们正在运行一个C程序。通常，当程序开始时，`main`函数会被调用，并为其分配一个栈帧。然后，`main`调用另一个函数`function1`。在将`function1`的栈帧压入栈中并交出执行之前，`main`会记录在`function1`返回时需要继续执行的位置（通常是调用`function1`后面的一行代码），通过将这个值——它的返回地址——压入栈中。[图16-3](ch16.xhtml#stack_after_call_to_function1
    "图16-3. 调用function1后的栈")展示了`main`调用`function1`后的栈状态。
- en: '![Stack after call to function1](httpatomoreillycomsourcenostarchimages2030506.png.jpg)Figure 16-3. Stack
    after call to `function1`'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: '![调用function1后的栈](httpatomoreillycomsourcenostarchimages2030506.png.jpg)图16-3.
    调用`function1`后的栈'
- en: After `function1` finishes, it returns, its stack frame is unwound, and the
    stored return address is loaded into the EIP register to restore execution to
    `main`. If we can control that return address, we can dictate which instructions
    are executed when `function1` returns. In the next section, we’ll look at a simple
    stack-based buffer overflow example to illustrate this point.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 在`function1`执行完毕后，它返回，栈帧被展开，存储的返回地址被加载到EIP寄存器中，以恢复到`main`函数的执行。如果我们能够控制这个返回地址，我们就可以在`function1`返回时决定执行哪些指令。在下一节中，我们将通过一个简单的基于栈的缓冲区溢出示例来说明这一点。
- en: Keep in mind a couple more things before we continue. In the examples in this
    book, we’re using older operating systems to get around some advanced antiexploitation
    techniques found on the most modern versions of both Windows and Linux. Particularly,
    we’ll take advantage of the lack of *data execution prevention (DEP)* and *address
    space layout randomization (ASLR)*, because both of them would make it difficult
    to learn the basics of exploitation. DEP sets specific memory sections as nonexecutable,
    which stops us from filling our stack with shellcode and pointing EIP to it for
    execution (as you’ll see in the Windows buffer overflow example in [Chapter 17](ch17.xhtml
    "Chapter 17. A Stack-Based Buffer Overflow in Windows")). ASLR randomizes where
    our libraries are loaded in memory. In our examples, we’ll hardcode the return
    address to where we would like to go in memory, but in the post-ASLR exploit world,
    finding the correct place to send execution can be a bit trickier. We’ll touch
    on more advanced exploit-writing techniques in [Chapter 19](ch19.xhtml "Chapter 19. Fuzzing,
    Porting Exploits, and Metasploit Modules"), but for now let’s get comfortable
    with the basics of how stack-based buffer overflows work.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 在继续之前，请记住几点。在本书中的示例中，我们使用较旧的操作系统来规避现代 Windows 和 Linux 系统中的一些高级反利用技术。特别是，我们将利用
    *数据执行防护（DEP）* 和 *地址空间布局随机化（ASLR）* 的缺乏，因为这两者都会使我们很难学习利用的基础知识。DEP 会将特定内存区域标记为不可执行，这阻止了我们在栈上填充
    shellcode 并将 EIP 指向该代码以执行（正如你将在 [第 17 章](ch17.xhtml "第 17 章. Windows 中的基于栈的缓冲区溢出")
    中看到的 Windows 缓冲区溢出示例）。ASLR 会随机化我们库文件在内存中的加载位置。在我们的示例中，我们将硬编码返回地址，指向我们希望在内存中跳转的位置，但在启用
    ASLR 的攻击环境下，找到正确的执行跳转地址会变得更加复杂。我们将在 [第 19 章](ch19.xhtml "第 19 章. 模糊测试、漏洞移植与 Metasploit
    模块") 中介绍更多高级的漏洞编写技巧，但现在我们先从栈溢出攻击的基础开始，先熟悉一下基本原理。
- en: Linux Buffer Overflow
  id: totrans-28
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Linux 缓冲区溢出
- en: Now that we’re done with the mind-numbing theory, let’s see a basic example
    of a buffer overflow exploit in action on our Linux target. First, let’s make
    sure the target is set up correctly for a basic buffer overflow. Modern operating
    systems have checks in place to prevent these attacks, but while we are learning,
    we need to turn them off. If you’re using the Linux target image provided with
    this book, it’s already set up correctly, but to make sure, check that `randomize_va_space`
    is set to 0 as shown here.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经完成了令人头疼的理论部分，接下来让我们看一个简单的缓冲区溢出漏洞在 Linux 目标系统上的实际应用示例。首先，确保目标系统已正确配置以进行基本的缓冲区溢出测试。现代操作系统都内置了防护机制来防止这些攻击，但在学习过程中，我们需要关闭这些保护。若你使用的是本书提供的
    Linux 目标镜像，系统已经配置正确，但为了确保无误，请检查 `randomize_va_space` 是否设置为 0，如下所示。
- en: '[PRE0]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '`randomize_va_space`, when set to 1 or 2, turns on ASLR on our target system.
    By default, randomization is turned on in Ubuntu, but we need this feature off
    for our example. If the file includes the value 0, we’re all set. If not, change
    the file contents to 0 and save it.'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: '`randomize_va_space`，当设置为 1 或 2 时，会在我们的目标系统上启用 ASLR。默认情况下，Ubuntu 会开启随机化，但为了我们的示例需要关闭此功能。如果文件中包含值
    0，那么一切就绪。如果没有，请将文件内容更改为 0 并保存。'
- en: A Vulnerable Program
  id: totrans-32
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 一个易受攻击的程序
- en: Let’s write a simple C program called *overflowtest.c* that is vulnerable to
    a stack-based buffer overflow, as shown in [Example 16-1](ch16.xhtml#simple_exploitable_c_program
    "Example 16-1. Simple exploitable C program").
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们编写一个简单的 C 程序，命名为 *overflowtest.c*，它易受基于栈的缓冲区溢出攻击，示例见 [示例 16-1](ch16.xhtml#simple_exploitable_c_program
    "示例 16-1. 易受攻击的简单 C 程序")。
- en: Note
  id: totrans-34
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: This file is in *georgia’s* home directory on the Ubuntu target included in
    the book’s downloads.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 这个文件位于 *georgia* 的家目录下，存放在本书下载的 Ubuntu 目标镜像中。
- en: Example 16-1. Simple exploitable C program
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 16-1. 易受攻击的简单 C 程序
- en: '[PRE1]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Our simple C program doesn’t do very much. It starts off by including two C
    libraries, `stdio.h` and `string.h`. These allow us to use the standard input/output
    and string constructors in C without having to build them from scratch. We’ll
    want to use strings and output text to the console in our program.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的简单 C 程序并没有做太多事情。它首先包含了两个 C 库，`stdio.h` 和 `string.h`。这使得我们可以在不需要从头开始编写的情况下，使用
    C 语言中的标准输入/输出和字符串构造函数。在程序中，我们将使用字符串并输出文本到控制台。
- en: 'Next we have three functions: `overflowed`, `function1`, and `main`. If `overflowed`
    ❶ is called, it prints the text “Execution Hijacked” to the console and then returns.
    If `function1` ❷ is called, it declares a local variable, a five-character string
    called `buffer`, and copies the contents of a variable passed to `function1` into
    `buffer`. Called by default when the program starts, `main` ❸ calls `function1`
    and passes it the first command line argument the program received. After `function1`
    returns, `main` prints the text “Executed normally” to the console, and the program
    exits.'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们有三个函数：`overflowed`、`function1` 和 `main`。如果调用 `overflowed` ❶，它会将文本“执行劫持”打印到控制台，然后返回。如果调用
    `function1` ❷，它声明一个本地变量，一个五个字符的字符串 `buffer`，并将传递给 `function1` 的变量内容复制到 `buffer`
    中。`main` ❸ 是程序启动时默认调用的函数，它调用 `function1` 并传递给它程序接收到的第一个命令行参数。在 `function1` 返回后，`main`
    将“正常执行”打印到控制台，程序然后退出。
- en: Notice that under normal circumstances, `overflowed` is never called, so “Execution
    Hijacked” should never appear in the console. (You’ll learn why it’s in the program
    at all when we overflow the buffer and hijack control of the program.)
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，在正常情况下，`overflowed` 从未被调用，因此“执行劫持”不应出现在控制台中。（当我们溢出缓冲区并劫持程序控制时，你将了解为什么程序中会有这个函数。）
- en: Now we compile our program as shown here.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们编译程序，如此处所示。
- en: '[PRE2]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: To compile our C code as shown above, we use GCC, the GNU Compiler Collection,
    which is built into Ubuntu by default. The `-g` option tells GCC to add extra
    debugging information for GDB, the GNU debugger. We use the `-fno-stack-protector`
    flag to turn off GCC’s stack-protection mechanism, which would attempt to prevent
    buffer overflows if we left it turned on. The `-z execstack` compiler option makes
    the stack executable, disabling another buffer overflow prevention method. We
    tell GCC to compile `overflowtest.c` into an executable called `overflowtest`
    with the `-o` option.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 要编译我们上面展示的 C 代码，我们使用 GCC（GNU 编译器集合），它默认内置在 Ubuntu 中。`-g` 选项告诉 GCC 为 GDB（GNU
    调试器）添加额外的调试信息。我们使用 `-fno-stack-protector` 标志关闭 GCC 的堆栈保护机制，如果启用它，它会试图防止缓冲区溢出。`-z
    execstack` 编译器选项使堆栈可执行，从而禁用另一种缓冲区溢出防护方法。我们通过 `-o` 选项告诉 GCC 将 `overflowtest.c`
    编译为名为 `overflowtest` 的可执行文件。
- en: Recall that `main` takes the first command line argument to the program and
    feeds it to `function1`, which copies the value into a five-character local variable.
    Let’s run the program with the command line argument `AAAA`, as shown here. Make
    `overflowtest` executable with `chmod` if necessary. We use four *A*s instead
    of five because a string ends with a null byte. Technically, if we used five *A*s,
    we would already be overflowing the buffer, albeit by just one character.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 回想一下，`main` 获取程序的第一个命令行参数并将其传递给 `function1`，后者将该值复制到一个五个字符的本地变量中。让我们运行程序并传递命令行参数
    `AAAA`，如图所示。必要时，通过 `chmod` 使 `overflowtest` 可执行。我们使用四个 *A* 而不是五个，因为字符串以一个空字节结尾。从技术上讲，如果我们使用五个
    *A*，我们就已经在溢出缓冲区了，尽管只是溢出一个字符。
- en: '[PRE3]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'As shown, the program does what we expected: `main` calls `function1`, `function1`
    copies `AAAA` into `buffer`, `function1` returns execution to `main`, and `main`
    prints “Executed normally” to the console before the program exits. Maybe if we
    give `overflowtest` some unexpected input, we can force it to behave in a way
    that will help us cause a buffer overflow.'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 如图所示，程序按我们预期的方式运行：`main` 调用 `function1`，`function1` 将 `AAAA` 复制到 `buffer` 中，`function1`
    将执行控制权交还给 `main`，然后 `main` 在程序退出之前将“正常执行”打印到控制台。也许，如果我们给 `overflowtest` 输入一些意外的内容，我们可以强迫它以某种方式运行，从而帮助我们造成缓冲区溢出。
- en: Causing a Crash
  id: totrans-47
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 造成崩溃
- en: Now let’s try giving the program a long string of *A*s as an argument, as shown
    here.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们尝试给程序传递一个很长的 *A* 字符串作为参数，如此处所示。
- en: '[PRE4]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: This time, the program crashes with a segmentation fault. Our program’s problem
    lies with the implementation of `strcpy`, which we use in `function1`. The `strcpy`
    function takes one string and copies it into another, but it does not do any bounds
    checking to make sure the supplied argument will fit into the destination string
    variable. The `strcpy` function will attempt to copy three, five, or even hundreds
    of characters into our five-character destination string. If our string is five
    characters long and we copy in 100 characters, the other 95 will end up overwriting
    data at adjacent memory addresses in the stack.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 这次，程序因段错误而崩溃。我们程序的问题出在 `strcpy` 的实现上，它在 `function1` 中被使用。`strcpy` 函数接受一个字符串并将其复制到另一个字符串中，但它没有进行任何边界检查，以确保提供的参数能够适应目标字符串变量。`strcpy`
    函数会尝试将三、五甚至数百个字符复制到我们五字符的目标字符串中。如果我们的字符串长度为五个字符，而我们复制了 100 个字符，其他 95 个字符将覆盖栈中相邻内存地址的数据。
- en: We could potentially overwrite the rest of `function1`’s stack frame and even
    higher memory. Remember what’s at the memory address immediately after the base
    of that stack frame? Before the frame was pushed on the stack, `main` pushed its
    return address onto the stack to designate where execution should continue once
    `function1` returns. If the string we copy into `buffer` is long enough, we’ll
    overwrite memory from `buffer` straight through to EBP, over the return address,
    and even into `main`’s stack frame.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可能会覆盖掉 `function1` 栈帧的其余部分，甚至更高的内存。还记得在那个栈帧的基址后面的内存地址存储了什么吗？在栈帧被压入栈之前，`main`
    将它的返回地址压入栈中，以指定 `function1` 返回后程序应继续执行的位置。如果我们复制到 `buffer` 的字符串足够长，我们将从 `buffer`
    覆盖内存，一直覆盖到 EBP，覆盖返回地址，甚至进入 `main` 的栈帧。
- en: Once `strcpy` places the first argument from `overflowtest` into `buffer`, `func``tion1`
    returns back to `main`. Its stack frame is popped off the stack, and the CPU tries
    to execute the instruction at the memory location in the return address. Because
    we’ve overwritten the return address with a long string of *A*s, as shown in [Figure 16-4](ch16.xhtml#memory_after_strcpy_is_executed
    "Figure 16-4. Memory after strcpy is executed"), the CPU will try to execute the
    instructions at the memory address `41414141` (the hexadecimal representation
    of four *A*s).
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦 `strcpy` 将 `overflowtest` 的第一个参数放入 `buffer` 中，`function1` 就会返回到 `main`。它的栈帧被从栈中弹出，CPU
    尝试在返回地址的内存位置执行指令。由于我们已用一串长长的 *A* 字符覆盖了返回地址，如[图 16-4](ch16.xhtml#memory_after_strcpy_is_executed
    "图 16-4. 执行 strcpy 后的内存")所示，CPU 将尝试在内存地址 `41414141`（四个 *A* 的十六进制表示）执行指令。
- en: '![Memory after strcpy is executed](httpatomoreillycomsourcenostarchimages2030508.png.jpg)Figure 16-4. Memory
    after `strcpy` is executed'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: '![执行 strcpy 后的内存](httpatomoreillycomsourcenostarchimages2030508.png.jpg)图 16-4.
    执行 `strcpy` 后的内存'
- en: However, our program can’t read, write, or execute from anywhere it likes in
    memory because that would cause utter chaos. The memory address `41414141` is
    out of bounds for our program, and it crashes with the segmentation fault we saw
    at the beginning of this section.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，我们的程序不能从内存中的任何位置读取、写入或执行操作，因为那样会导致彻底的混乱。内存地址 `41414141` 对我们的程序来说越界，因此程序会像本节开始时所见那样因段错误而崩溃。
- en: In the next section, we’ll take a closer look behind the scenes when the program
    crashes. In GDB, discussed next, you can use the command `maintenance info sections`
    to see which memory regions are mapped to the process.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将深入分析程序崩溃时的幕后情况。在接下来的 GDB 讨论中，你可以使用命令`maintenance info sections`来查看哪些内存区域被映射到进程中。
- en: Running GDB
  id: totrans-56
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 运行 GDB
- en: We can see exactly what’s happening in memory by running our program in a debugger.
    Our Ubuntu machine comes with GDB, so let’s open the program in the debugger,
    as shown here, and watch what happens in memory if we overflow our five-character
    buffer.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过在调试器中运行程序，精确地查看内存中发生了什么。我们的 Ubuntu 机器自带 GDB，所以让我们如图所示，打开程序并在调试器中观察，如果我们溢出五字符缓冲区，内存中会发生什么。
- en: '[PRE5]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Before we run the program, we’ll set some *breakpoints* to pause execution at
    certain points in the program and allow us to view the state of memory at those
    times. Because we compiled the program with the `-g` flag, we can view the source
    code directly, as shown in [Example 16-2](ch16.xhtml#viewing_source_code_in_gdb
    "Example 16-2. Viewing source code in GDB"), and set breakpoints at the lines
    where we would like to pause.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 在运行程序之前，我们会设置一些*断点*，以便在程序的特定位置暂停执行，允许我们查看这些时刻的内存状态。因为我们使用`-g`标志编译了程序，所以可以直接查看源代码，如[示例16-2](ch16.xhtml#viewing_source_code_in_gdb
    "示例16-2. 在GDB中查看源代码")所示，并可以在我们希望暂停的行设置断点。
- en: Example 16-2. Viewing source code in GDB
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 示例16-2. 在GDB中查看源代码
- en: '[PRE6]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: First, let’s pause the program right before `main` calls `function1` at ❸, just
    before the instruction is executed. We’ll also set two more breakpoints, inside
    `function1`, right before `strcpy` is executed at ❶, and directly afterward, at
    ❷.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们在`main`调用`function1`之前的❸处暂停程序，紧接着在指令执行之前。我们还将在`function1`内部设置两个断点，一个在`strcpy`执行之前的❶处，另一个在`strcpy`执行之后的❷处。
- en: Setting breakpoints in GDB is shown in [Example 16-3](ch16.xhtml#setting_breakpoints_in_gdb
    "Example 16-3. Setting breakpoints in GDB"). Set breakpoints at lines 14, 10,
    and 11 by using the GDB command `break`.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 在[示例16-3](ch16.xhtml#setting_breakpoints_in_gdb "示例16-3. 在GDB中设置断点")中展示了如何在GDB中设置断点。使用GDB命令`break`，在第14行、第10行和第11行设置断点。
- en: Example 16-3. Setting breakpoints in GDB
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 示例16-3. 在GDB中设置断点
- en: '[PRE7]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Before we overflow `buffer` and cause the program to crash, let’s run it with
    just four *A*s, as shown here, and watch memory as the program executes normally.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们溢出`buffer`并导致程序崩溃之前，让我们先使用四个*A*字符运行程序，如下所示，并观察程序正常执行时的内存情况。
- en: '[PRE8]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: We use the GDB command `run` followed by arguments to start the program in the
    debugger. Here we run the program with four *A*s as an argument. We hit our first
    breakpoint just before `function1` is called, at which time we can examine the
    program’s memory using the GDB command `x`.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用GDB命令`run`，后跟参数，来启动调试器中的程序。在这里，我们用四个*A*字符作为参数运行程序。程序在调用`function1`之前停在第一个断点处，这时我们可以使用GDB命令`x`检查程序的内存。
- en: GDB needs to know which part of memory we want to see and how it should be displayed.
    Memory contents can be displayed in octal, hexadecimal, decimal, or binary format.
    We’ll see a lot of hexadecimal in our journey through exploit development, so
    let’s use the `x` flag to tell GDB to display our memory in hexadecimal format.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: GDB需要知道我们希望查看内存的哪一部分，以及如何显示它。内存内容可以以八进制、十六进制、十进制或二进制格式显示。在我们的漏洞开发旅程中，会看到大量的十六进制格式数据，因此我们使用`x`标志告诉GDB以十六进制格式显示内存。
- en: We can also output memory in increments of one byte, a two-byte halfword, a
    four-byte word, and an eight-byte giant. Let’s look at 16 hexadecimal format words
    starting at the ESP register with the command `x/16xw $esp`, as shown in [Example 16-4](ch16.xhtml#examining_the_contents_of_memory
    "Example 16-4. Examining the contents of memory").
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以按字节、二字节半字、四字节字和八字节巨型数据的增量输出内存。让我们查看从ESP寄存器开始的16个十六进制格式的字，使用命令`x/16xw $esp`，如[示例16-4](ch16.xhtml#examining_the_contents_of_memory
    "示例16-4. 查看内存内容")所示。
- en: Example 16-4. Examining the contents of memory
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 示例16-4. 查看内存内容
- en: '[PRE9]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The `x/16xw $esp` command prints out 16 four-byte words in hexadecimal format,
    starting with ESP. Recall from earlier in the chapter that ESP marks the lowest
    memory address in our stack. Because our first breakpoint paused execution right
    before the call to `function1`, ESP is at the top of `main`’s stack frame.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: '`x/16xw $esp`命令会以十六进制格式打印出从ESP开始的16个四字节字。回想一下本章之前提到的内容，ESP标记了栈中最低的内存地址。由于我们在调用`function1`之前就已触发了第一个断点，因此此时ESP位于`main`的栈帧顶部。'
- en: The output of memory in GDB in [Example 16-4](ch16.xhtml#examining_the_contents_of_memory
    "Example 16-4. Examining the contents of memory") might be a bit confusing at
    first, so let’s break it down. On the far left, we have our memory addresses in
    16-byte increments, followed by the contents of memory at those addresses. In
    this case, the first four bytes will be the contents of ESP followed by additional
    memory, starting at ESP and continuing down the stack.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 在GDB中查看内存的输出，如[示例16-4](ch16.xhtml#examining_the_contents_of_memory "示例16-4.
    查看内存内容")所示，可能一开始会有些混乱，所以让我们分解一下。最左边是以16字节为增量的内存地址，接着是这些地址处的内存内容。在本例中，前四个字节将是ESP的内容，接着是从ESP开始并继续向下栈展开的额外内存。
- en: We can find EBP, which points at the bottom (or highest address) of `main`’s
    stack frame, by examining EBP as shown here with the command `x/1xw $ebp`.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过检查 EBP 来找到指向 `main` 栈帧底部（或最高地址）的 EBP，如此处所示，使用命令 `x/1xw $ebp`。
- en: '[PRE10]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'This command allows us to examine one hexadecimal word from EBP to find the
    memory location and contents of the EBP register. Based on the output, `main`’s
    stack frame looks like this:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 这个命令允许我们检查从 EBP 开始的一个十六进制字，以便找到 EBP 寄存器的内存位置和内容。根据输出，`main`的栈帧如下所示：
- en: '[PRE11]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: As you can see, there’s not much to it, but then again, all `main` does is call
    another function and then print a line of text to the screen; there’s no heavy-duty
    processing required.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，这并没有什么复杂的，但话说回来，`main` 只是调用了另一个函数，然后打印了一行文本到屏幕；不需要做繁重的处理。
- en: Based on what we know about the stack, we can expect that when we let the program
    continue and `function1` is called, the return address for `main` and a stack
    frame for `function1` will be pushed onto the stack. Remember that the stack grows
    to lower memory addresses, so the top of the stack will be at a lower memory address
    when we hit our next breakpoint inside of `function1`. Recall that our next breakpoint
    is inside `function1` right before the `strcpy` command is executed. Use the command
    `continue` to let the program run until the next breakpoint, as shown in [Example 16-5](ch16.xhtml#breakpoint_before_the_strcpy_command
    "Example 16-5. Breakpoint before the strcpy command").
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 根据我们对栈的了解，我们可以预期，当我们让程序继续运行并调用 `function1` 时，`main` 的返回地址和 `function1` 的栈帧将被压入栈中。记住，栈是向低地址增长的，所以当我们在
    `function1` 内部的下一个断点时，栈顶会位于一个更低的内存地址。回想一下，我们的下一个断点位于 `function1` 内部，即 `strcpy`
    指令执行之前。使用 `continue` 命令让程序运行直到下一个断点，如[示例 16-5](ch16.xhtml#breakpoint_before_the_strcpy_command
    "示例 16-5. `strcpy` 指令之前的断点")所示。
- en: Example 16-5. Breakpoint before the `strcpy` command
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 16-5. `strcpy` 指令之前的断点
- en: '[PRE12]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: After using the `continue` command to run the program until the next breakpoint,
    examine ESP at ❶ and EBP at ❷ to see the contents of `function1`’s stack frame.
    `function1`’s stack frame is shown here.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `continue` 命令运行程序直到下一个断点后，检查 ❶ 处的 ESP 和 ❷ 处的 EBP，以查看 `function1` 栈帧的内容。`function1`
    的栈帧如下所示。
- en: '[PRE13]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The stack frame for `function1` is a bit larger than `main`’s. There’s some
    memory allocated for the local variable `buffer`, along with a little extra space
    for `strcpy` to work with, but there’s certainly not enough room for 30 or 40
    *A*s. Recall from the last breakpoint that `main`’s stack frame began at memory
    address `0xbffff540`. Based on our knowledge of the stack, `0x08048443`, the four-byte
    memory address between `function1`’s stack frame and `main`’s stack frame, should
    be our return address for `main`. Let’s disassemble `main` with the `disass` command,
    as shown in [Example 16-6](ch16.xhtml#disassembled_main_function "Example 16-6. Disassembled
    main function"), to see where `0x08048443` comes in.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: '`function1` 的栈帧比 `main` 的栈帧大一些。为局部变量 `buffer` 分配了一些内存，同时为 `strcpy` 提供了一些额外空间，但肯定没有足够的空间容纳
    30 或 40 个 *A* 字符。回想上一个断点时，`main` 的栈帧从内存地址 `0xbffff540` 开始。根据我们对栈的了解，`0x08048443`，即
    `function1` 栈帧和 `main` 栈帧之间的四字节内存地址，应该是 `main` 的返回地址。我们可以使用 `disass` 命令反汇编 `main`，如[示例
    16-6](ch16.xhtml#disassembled_main_function "示例 16-6. `main` 函数的反汇编")所示，来查看 `0x08048443`
    是如何出现的。'
- en: Example 16-6. Disassembled `main` function
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 16-6. `main` 函数的反汇编
- en: '[PRE14]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'If you aren’t fluent in assembly code, don’t worry. The instruction we’re looking
    for jumps out at us in plain English: At `0x0804843e` ❶, `main` calls the memory
    address of `function1`. It stands to reason that the next instruction to be executed
    when `function1` exits (and thus our return address) will be the next instruction
    in the list. And sure enough, the next line at ❷ shows the return address we found
    on the stack. Everything looks just like the theory says it should.'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你不熟悉汇编代码，也不用担心。我们要找的指令以简单的英语呈现出来：在 `0x0804843e` ❶ 处，`main` 调用了 `function1`
    的内存地址。因此可以推断，当 `function1` 执行完毕后（也就是我们的返回地址），下一个执行的指令将是列表中的下一条指令。果然，❷ 处的下一行显示了我们在栈上找到的返回地址。一切都像理论中说的那样。
- en: Let’s allow the program to continue and see what happens in memory when our
    four *A*s are copied into buffer. After the program pauses at the third breakpoint,
    examine memory in the usual way, as shown in [Example 16-7](ch16.xhtml#examining_memory_at_breakpoint_3
    "Example 16-7. Examining memory at breakpoint 3").
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们让程序继续运行，看看当我们的四个*A*字符被复制到缓冲区时内存发生了什么。在程序在第三个断点处暂停后，以通常的方式检查内存，正如[示例16-7](ch16.xhtml#examining_memory_at_breakpoint_3
    "示例16-7. 在断点3处检查内存")中所示。
- en: Example 16-7. Examining memory at breakpoint 3
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 示例16-7. 在断点3处检查内存
- en: '[PRE15]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: As shown, we’re still inside `function1`, so our stack frame location is the
    same. Inside `function1`’s stack frame, we can see our four *A*s ❶ represented
    in hexadecimal as 41 followed by 00 for the ending null byte. They fit nicely
    in our five-character buffer, so our return address is still intact, and everything
    works as expected when we let the program continue, as shown in [Example 16-8](ch16.xhtml#program_finishes_normallydot
    "Example 16-8. The program finishes normally.").
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 如图所示，我们仍然在`function1`内部，所以我们的栈帧位置没有变化。在`function1`的栈帧中，我们可以看到四个*A*字符 ❶，以十六进制表示为41，后面跟着结束的空字节00。它们恰好适应我们的五字符缓冲区，因此我们的返回地址仍然完好无损，当我们继续让程序运行时，一切都按预期工作，正如[示例16-8](ch16.xhtml#program_finishes_normallydot
    "示例16-8. 程序正常结束")所示。
- en: Example 16-8. The program finishes normally.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 示例16-8. 程序正常结束。
- en: '[PRE16]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Sure enough, “Executed normally” prints to the screen.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 果然，“程序正常执行”打印到屏幕上。
- en: Now, let’s run the program again, this time overflowing our buffer with too
    many characters, and watch what happens in memory.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们重新运行程序，这次使用过多的字符溢出缓冲区，看看内存中发生了什么。
- en: Crashing the Program in GDB
  id: totrans-97
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 在GDB中使程序崩溃
- en: We could enter a long string of *A*s, or we could let the Perl scripting language
    generate that string for us, as shown in [Example 16-9](ch16.xhtml#running_the_program_with_30_as_as_an_arg
    "Example 16-9. Running the program with 30 As as an argument"). (Perl will come
    in handy later when we try to hijack execution with an actual memory address rather
    than crash the program.)
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以输入一串长长的*A*字符，或者让Perl脚本语言为我们生成这串字符，正如[示例16-9](ch16.xhtml#running_the_program_with_30_as_as_an_arg
    "示例16-9. 以30个A作为参数运行程序")中所示。（当我们尝试通过一个实际的内存地址劫持程序执行时，Perl将非常有用，而不是让程序崩溃。）
- en: Example 16-9. Running the program with 30 As as an argument
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 示例16-9. 以30个A作为参数运行程序
- en: '[PRE17]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Here we tell Perl to execute the command `print` to make a string of 30 *A*s
    and feed the results in as the argument to `overflowtest` ❶. When `strcpy` tries
    to place such a long string into our five-character buffer, we can expect to see
    parts of our stack get overwritten with *A*s. When we hit our first breakpoint,
    we’re still in `main`, and everything looks normal so far. The trouble shouldn’t
    start until our third breakpoint, after `strcpy` is executed with too many *A*s.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们告诉Perl执行`print`命令生成一串30个*A*字符，并将结果作为参数传递给`overflowtest` ❶。当`strcpy`尝试将这么长的字符串放入我们五字符的缓冲区时，我们可以预期看到栈的部分内容被*A*字符覆盖。当我们到达第一个断点时，我们仍然在`main`中，一切看起来都正常。问题应该要等到第三个断点，`strcpy`执行时传入了过多的*A*字符。
- en: Note
  id: totrans-102
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '`main`’s stack frame is still 12 bytes long, though it has moved 32 bytes up
    the stack. This is due to changes in the length of the command line argument,
    and so on. The size of the stack frame will be consistent throughout.'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: '`main`的栈帧仍然是12个字节长，尽管它已经向栈上方移动了32个字节。这是由于命令行参数长度等的变化。因此，栈帧的大小会保持一致。'
- en: Let’s note one thing at the second breakpoint in [Example 16-10](ch16.xhtml#examining_memory_at_breakpoint_2
    "Example 16-10. Examining memory at breakpoint 2") before we move on to the really
    interesting part.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们进入真正有趣的部分之前，让我们在[示例16-10](ch16.xhtml#examining_memory_at_breakpoint_2 "示例16-10.
    在断点2处检查内存")的第二个断点处注意一件事。
- en: Example 16-10. Examining memory at breakpoint 2
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 示例16-10. 在断点2处检查内存
- en: '[PRE18]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: You can see here that `function1`’s stack frame has also moved up 32 bytes.
    Also note that our return address still holds the memory address `0x08048443`
    ❶. Though our stack frame has moved around a bit, the instructions in memory to
    be executed are in the same place.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以看到这里`function1`的栈帧也上移了32个字节。还要注意，我们的返回地址仍然保存着内存地址`0x08048443` ❶。尽管我们的栈帧有些变化，但内存中待执行的指令依然保持在原来的位置。
- en: Use the `continue` command again to move on to the third breakpoint. This is
    where things get interesting, as shown in [Example 16-11](ch16.xhtml#return_address_overwritten_by_as
    "Example 16-11. Return address overwritten by As").
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 再次使用`continue`命令，继续到第三个断点。这是事情变得有趣的地方，参见[示例 16-11](ch16.xhtml#return_address_overwritten_by_as
    "示例 16-11：返回地址被*A*覆盖")。
- en: Example 16-11. Return address overwritten by As
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 16-11：返回地址被*A*覆盖
- en: '[PRE19]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Let’s examine the memory again at our third breakpoint, directly after `strcpy`
    but before `function1` returns to `main`. This time, not only is the return address
    overwritten by *A*s at ❶ but part of `main`’s stack frame is overwritten as well.
    At this point, there is no hope for the program to recover.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在第三个断点后再次查看内存，紧接着`strcpy`之后，但在`function1`返回`main`之前。这次，返回地址被*A*覆盖的位置在❶，而`main`的栈帧部分也被覆盖了。此时，程序已经没有恢复的希望了。
- en: When `function1` returns, the program attempts to execute the instructions at
    the return address for `main`, but the return address has been overwritten with
    our *A*s, causing the expected segmentation fault when trying to execute the instruction
    at the memory address `41414141`. (In the coming sections, we’ll discuss replacing
    the return address with something that redirects the program to code of our own
    instead of crashing it.)
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 当`function1`返回时，程序尝试执行`main`的返回地址处的指令，但返回地址已被我们的*A*覆盖，导致程序在尝试执行内存地址`41414141`处的指令时发生预期的段错误。（在接下来的章节中，我们将讨论如何用其他内容替换返回地址，使程序跳转到我们自己的代码，而不是崩溃。）
- en: Controlling EIP
  id: totrans-113
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 控制EIP
- en: Making the program crash is interesting in and of itself, but as exploit developers,
    our goal is to hijack execution if possible and get the target CPU to execute
    code on our behalf. Perhaps by manipulating the crash, we can execute other instructions
    that the developer never intended.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 让程序崩溃本身很有意思，但作为漏洞开发者，我们的目标是，如果可能的话，劫持执行并让目标CPU代我们执行代码。也许通过操控崩溃，我们可以执行开发者本不打算执行的其他指令。
- en: Currently, our program crashes when it tries to execute the instructions at
    the memory address `41414141`, which is out of bounds. We need to change our argument
    string to include a valid memory address that our program can access. If we can
    replace the return address with another valid memory location, we should be able
    to hijack execution when `function1` returns. Perhaps the developer even left
    some debugging code in the program that we can use to illustrate this purpose.
    (But I’m getting a bit ahead of myself here.)
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，当我们的程序尝试执行位于内存地址`41414141`的指令时，程序崩溃，因为该地址超出了范围。我们需要更改参数字符串，包含一个程序可以访问的有效内存地址。如果我们能将返回地址替换为另一个有效的内存位置，当`function1`返回时，我们应该能够劫持执行。也许开发者甚至在程序中留下了一些调试代码，我们可以用它来说明这个目的。（但我有点跑题了。）
- en: To redirect execution, we first need to determine where the return address is
    overwritten by our long string of *A*s. Let’s look back at what our stack looked
    like when we ran our program normally with only four characters for our argument,
    as shown here.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 为了重定向执行，我们首先需要确定返回地址被我们一长串* A *替换的位置。让我们回顾一下，当我们用四个字符的参数正常运行程序时，栈的情况，如下所示。
- en: '[PRE20]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: We can see where the four *A*s ❶ were copied into the local variable, `buffer`.
    Now, recall that the four bytes directly after EBP ❷ contain the return address
    `0x08048443` ❸. We can see that after the four *A*s, there are five more bytes
    in `function1`’s stack frame, which come before the return address.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到四个*A* ❶是如何被复制到局部变量`buffer`中的。现在，回想一下，EBP ❷之后的四个字节包含了返回地址`0x08048443` ❸。我们可以看到，在四个*A*之后，`function1`的栈帧中还有五个字节，这些字节位于返回地址之前。
- en: Looking at memory, it stands to reason that if we give our program an argument
    that is 5 + 4 + 4 bytes long, the last four bytes will overwrite the return address.
    We can test this by sending our program an argument of nine *A*s followed by four
    *B*s. If our program crashes when trying to execute the instruction at memory
    address `42424242` (the hexadecimal representation of *B*), we’ll know we have
    calculated our offset correctly.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 从内存来看，合乎逻辑的是，如果我们给程序传递一个长度为5 + 4 + 4字节的参数，最后四个字节将覆盖返回地址。我们可以通过向程序传递九个*A*后跟四个*B*的参数来测试。如果程序在尝试执行内存地址`42424242`（*B*的十六进制表示）处的指令时崩溃，我们就知道我们正确地计算了偏移量。
- en: We can use Perl again to help us create our argument string, as shown in [Example 16-12](ch16.xhtml#starting_the_program_with_a_new_attack_s
    "Example 16-12. Starting the program with a new attack string").
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以再次使用Perl来帮助我们创建攻击字符串，如[示例 16-12](ch16.xhtml#starting_the_program_with_a_new_attack_s
    "示例 16-12. 使用新的攻击字符串启动程序")所示。
- en: Example 16-12. Starting the program with a new attack string
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 16-12. 使用新的攻击字符串启动程序
- en: '[PRE21]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Before we run the program with this new argument, `delete` the first two breakpoints
    because the state of memory won’t change in an interesting way until our third
    breakpoint, after `strcpy` is executed.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们使用这个新参数运行程序之前，`delete`掉前两个断点，因为直到执行`strcpy`之后，我们的第三个断点才会让内存状态发生有趣的变化。
- en: Start the program using Perl, with nine *A*s followed by four *B*s as the attack
    string. Because the program crashed on its last run, you will be asked if you
    would like to start from the beginning. Enter **`y`** for yes. When we examine
    memory at our only remaining breakpoint, everything looks as predicted, as shown
    in [Example 16-13](ch16.xhtml#overwriting_the_return_address_with_bs "Example 16-13. Overwriting
    the return address with Bs").
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Perl启动程序，攻击字符串为九个*A*后跟四个*B*。由于程序在上次运行时崩溃，系统会询问是否从头开始。输入**`y`**表示是。当我们检查唯一剩下的断点时，内存状态如预期所示，如[示例
    16-13](ch16.xhtml#overwriting_the_return_address_with_bs "示例 16-13. 用Bs覆盖返回地址")所示。
- en: Example 16-13. Overwriting the return address with Bs
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 16-13. 用Bs覆盖返回地址
- en: '[PRE22]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Where we previously saw our return address (`0x08048443`), we now have `0x42424242`.
    If we let the program continue, we can see that it crashes while trying to execute
    the memory address of four *B*s ❶. This is once again out of bounds, but at least
    now we know where to place the address of the code we want to execute.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们之前看到的返回地址（`0x08048443`）的位置，现在变成了`0x42424242`。如果我们让程序继续运行，就会看到它在尝试执行四个*B*的内存地址时崩溃❶。这再次越界了，但至少现在我们知道该把我们想执行的代码的地址放在哪里。
- en: We have now pinpointed which four bytes in our attack string overwrite the return
    address. Remember that the return address is loaded into EIP when `function1`
    returns. Now we just need to find somewhere more interesting to send execution
    than `41414141` or `42424242`.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在已经确定了攻击字符串中哪些四个字节覆盖了返回地址。记住，返回地址是在`function1`返回时加载到EIP寄存器中的。现在，我们只需找到一个比`41414141`或`42424242`更有趣的地方来发送执行。
- en: Hijacking Execution
  id: totrans-129
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 劫持执行
- en: We’ve determined where to overwrite the return address in our argument string,
    but we still need something to put there. (This example may seem a bit contrived
    compared to the rest of the exploit development examples we’ll cover, but it illustrates
    the underlying concepts well.) We’ve managed to manipulate an issue with the `strcpy`
    function used by the program to break out of the `buffer` variable and overwrite
    additional memory addresses, including the return address.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经确定了要在攻击字符串中覆盖返回地址的位置，但我们仍然需要放置一些内容。（这个例子相较于我们接下来会讨论的其他漏洞开发例子可能显得有些牵强，但它很好地说明了底层概念。）我们成功地利用程序中使用的`strcpy`函数来操控`buffer`变量，从而覆盖了其他内存地址，包括返回地址。
- en: Looking back at our source code for *overflowtest.c*, recall the program contains
    another function in addition to `main` and `function1`. The first function in
    the program, called `overflowed`, prints “Execution Hijacked” out to the console
    and then returns. This extra function is never called when the program runs normally,
    but as its output implies, we can use it to hijack execution.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 回顾我们源代码中的*overflowtest.c*，记得程序除了`main`和`function1`外，还包含了另一个函数。程序中的第一个函数，叫做`overflowed`，会向控制台打印“Execution
    Hijacked”，然后返回。当程序正常运行时，这个额外的函数从未被调用，但正如它的输出所暗示的那样，我们可以利用它来劫持执行。
- en: Returning to our debugger, if we can find the start of `overflowed` in memory,
    we should be able to replace our four *B*s with that memory address, overwrite
    the return address, and force the program to execute instructions the developers
    didn’t intend it to. We have the source code and know the function name we are
    looking for, so this task is trivial. Let’s just disassemble `overflowed` and
    find out where it is loaded in memory, as shown in [Example 16-14](ch16.xhtml#disassembling_overflowed
    "Example 16-14. Disassembling overflowed").
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 回到调试器，如果我们能找到`overflowed`在内存中的起始位置，就应该能够将四个*B*替换为该内存地址，覆盖返回地址，并迫使程序执行开发者未曾预料到的指令。我们有源代码并且知道我们要找的函数名，所以这个任务很简单。我们只需反汇编`overflowed`并找出它在内存中的加载位置，如[示例
    16-14](ch16.xhtml#disassembling_overflowed "示例 16-14. 反汇编overflowed")所示。
- en: Example 16-14. Disassembling `overflowed`
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 示例16-14. 反汇编 `overflowed`
- en: '[PRE23]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: As you can see, the memory address `0x80483f4` ❶ holds the first instruction
    of `overflowed`. If we redirect our program here, it will execute all the instructions
    in that function.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，内存地址 `0x80483f4` ❶ 保存着 `overflowed` 中的第一条指令。如果我们将程序重定向到这里，它将执行该函数中的所有指令。
- en: Note
  id: totrans-136
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: This won’t give us a reverse shell or join the target to a botnet; it will only
    print out “Execution Hijacked” to the screen. We will look at more exciting execution
    hijacks in the exploit development examples in the next three chapters.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 这不会给我们带来反向 shell 或将目标加入僵尸网络；它只会将“执行劫持”打印到屏幕上。我们将在接下来的三个章节的漏洞开发示例中，看到更刺激的执行劫持攻击。
- en: We can use Perl to help us create our argument string, which will include hexadecimal
    bytes for the memory address we want to use to overwrite the return address, as
    shown here.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用 Perl 来帮助我们创建参数字符串，其中包含我们想要使用的内存地址的十六进制字节，以覆盖返回地址，如下所示。
- en: '[PRE24]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: This time, we replace our four *B*s with `\x08\x04\x83\xf4`, which should redirect
    execution to the beginning of `overflowed`. But things don’t work out as planned,
    as shown in [Example 16-15](ch16.xhtml#return_address_bytes_are_flippeddot "Example 16-15. The
    return address bytes are flipped.").
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 这次，我们将四个 *B* 替换为 `\x08\x04\x83\xf4`，这应该会将执行流程重定向到 `overflowed` 的开头。但事情并没有按计划进行，如[示例16-15](ch16.xhtml#return_address_bytes_are_flippeddot
    "示例16-15. 返回地址字节被翻转")所示。
- en: Example 16-15. The return address bytes are flipped.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 示例16-15. 返回地址字节被翻转
- en: '[PRE25]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: As you can see, we hit our breakpoint as expected, but when we examine memory,
    we seem to have a little problem. The memory address of the first instruction
    in `overflowed` is `0x80483f4`, but the return address on our stack is `0xf4830408`
    ❶. The digits aren’t entirely reversed, but the bytes are in the wrong order.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，我们按预期达到了断点，但当我们检查内存时，似乎遇到了一些问题。`overflowed` 中第一条指令的内存地址是 `0x80483f4`，但我们栈上的返回地址却是
    `0xf4830408` ❶。数字没有完全被反转，但字节顺序却是错误的。
- en: Recall that two hexadecimal digits make up one byte. When we let the program
    continue, we receive another access violation for trying to execute data at `0xf4830408`.
    We know that the program crashes because the new return address is wrong, so let’s
    look at how those bytes wound up out of order in the first place so we can fix
    the problem.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 回想一下，两个十六进制数字构成一个字节。当我们让程序继续运行时，收到另一个访问违规错误，因为它尝试在 `0xf4830408` 执行数据。我们知道程序崩溃是因为新的返回地址是错误的，所以让我们来看看这些字节到底是如何乱序的，以便修复这个问题。
- en: Endianness
  id: totrans-145
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 字节序
- en: When I was first learning basic exploit development, I spent many hours scratching
    my head and wondering what could possibly be keeping my exploit from working.
    I had run into this same problem, and unfortunately, I hadn’t been paying attention
    in operating systems class when we covered *endianness*.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 当我第一次学习基本的漏洞开发时，我花了很多时间抓耳挠腮，想不通是什么原因让我的漏洞无法成功。我曾经遇到过这个问题，不幸的是，我在操作系统课上学到字节序时并没有认真听讲。
- en: In the 1726 novel *Gulliver’s Travels*, Jonathan Swift’s titular character is
    shipwrecked on the island of Lilliput. Lilliput is currently on bad terms with
    neighboring Blefuscu because of a dispute about how to properly crack an egg.
    In Lilliput, eggs are cracked at the little end, and in Blefuscu, eggs are cracked
    at the big end. We have a similar dispute in computer science regarding byte order.
    Big endians believe that the most significant byte should be stored first, whereas
    little endians store the least significant byte first. Our Ubuntu virtual machine
    has an Intel architecture, which is *little endian*. To account for little-endian
    architecture, we need to flip the bytes of our memory address around, as shown
    here.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 在1726年出版的小说《格列佛游记》中，乔纳森·斯威夫特的主人公格列佛在海上遭遇沉船事故，漂流到小人国岛。小人国与邻国布莱福斯库的关系紧张，原因是关于如何正确地打开鸡蛋的争执。在小人国，鸡蛋从小的一端裂开，而在布莱福斯库，鸡蛋从大的一端裂开。在计算机科学中，我们也有类似的争论，涉及字节顺序问题。大端序认为最重要的字节应当首先存储，而小端序则首先存储最不重要的字节。我们的Ubuntu虚拟机采用的是英特尔架构，属于*小端序*。为了适应小端架构，我们需要翻转内存地址中的字节顺序，如下所示。
- en: '[PRE26]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Using the return address `\xf4\x83\x04\x08` with the byte order flipped for
    our Intel architecture fixes our problem, as shown in [Example 16-16](ch16.xhtml#successfully_hijacking_execution
    "Example 16-16. Successfully hijacking execution").
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 使用返回地址 `\xf4\x83\x04\x08`，并翻转字节顺序以适应我们的英特尔架构，修复了我们的问题，如[示例16-16](ch16.xhtml#successfully_hijacking_execution
    "示例16-16. 成功劫持执行")所示。
- en: Example 16-16. Successfully hijacking execution
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 示例16-16. 成功劫持执行
- en: '[PRE27]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: This time when we hit the breakpoint, our return address looks correct. Sure
    enough, when we let the program continue, “Execution Hijacked” is printed to the
    console at ❶, meaning we have successfully hijacked execution and exploited a
    buffer overflow vulnerability.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 这次当我们触发断点时，我们的返回地址看起来是正确的。果然，当我们让程序继续执行时，控制台在❶处打印出“Execution Hijacked”，这意味着我们成功劫持了程序的执行并利用了缓冲区溢出漏洞。
- en: To see the results outside the debugger, we run `overflowtest` from the command
    line with an argument that includes the new return address, as shown here.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 为了在调试器外查看结果，我们从命令行运行`overflowtest`并传递一个包含新返回地址的参数，如下所示。
- en: '[PRE28]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Note that after `overflowed` returns, the program crashes with a segmentation
    fault when executing the memory address `bffff700`. This address is the same as
    the next four bytes on the stack after our return address. And thinking back to
    how memory works, this makes sense, but our “malicious” code was fully executed
    prior to the crash. After the stack frame for `overflowed` is popped off the stack,
    `bffff700` appears to be in the place of the return address. We sent execution
    straight to `overflowed` without normal function-calling things like saving a
    return address. When `overflowed`’s stack frame is unwound from the stack, the
    next memory address of the stack is assumed to be the return address, but this
    is just part of `main`’s stack frame, so we crash.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，在`overflowed`函数返回后，当执行内存地址`bffff700`时，程序会因段错误崩溃。这个地址与返回地址后的栈上接下来的四个字节相同。回想一下内存是如何工作的，这就能解释了，但我们的“恶意”代码在崩溃前已经完全执行。在`overflowed`的栈帧从栈中弹出后，`bffff700`似乎取代了返回地址。我们直接将执行流转向`overflowed`，而没有进行正常的函数调用操作，比如保存返回地址。当`overflowed`的栈帧从栈中被卸载时，栈上的下一个内存地址被认为是返回地址，但这实际上只是`main`函数的栈帧的一部分，所以程序崩溃了。
- en: 'How might you augment your attack string to fix this? You guessed it: You could
    add another four bytes to our attack string, sending execution back to the original
    return address in `main`. Because we have corrupted `main`’s stack frame, we may
    still run into trouble down the line, but we can meet our goal of tricking the
    program into executing code on our behalf.'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 你会如何增强攻击字符串以修复这个问题呢？没错，你可以在我们的攻击字符串中再添加四个字节，将执行流送回`main`中的原始返回地址。因为我们已经破坏了`main`的栈帧，可能仍然会遇到后续的问题，但我们可以实现我们的目标，让程序执行我们的代码。
- en: Summary
  id: totrans-157
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter we looked at a simple C program with a buffer overflow vulnerability
    (namely the use of the insecure `strcpy` function) that does not check its array
    boundaries, which allows us to write to adjacent memory. We exploited this issue
    by writing a longer string to the command line than the program expected. We hijacked
    the program’s execution by overwriting a function’s return address with our own
    value. We sent execution to another function included in the original program.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中，我们查看了一个简单的C程序，该程序存在缓冲区溢出漏洞（即使用了不安全的`strcpy`函数），并且没有检查数组边界，这使得我们可以写入相邻的内存。我们通过向命令行写入比程序预期更长的字符串来利用这个问题。我们通过覆盖一个函数的返回地址，用我们自己的值劫持了程序的执行。我们将执行流转到原程序中包含的另一个函数。
- en: Now that you’ve seen a basic example of a stack-based overflow, let’s move on
    to something a bit more complex. In the next chapter, our example will focus on
    a Windows-based target and a real-world target program.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经看到了一个基于栈的溢出漏洞的基本示例，接下来我们将探讨一些更复杂的内容。在下一章中，我们的示例将集中在一个基于Windows的目标和一个实际的目标程序上。
