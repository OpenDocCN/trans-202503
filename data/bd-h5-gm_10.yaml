- en: Chapter 8. Next Steps in HTML5
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第 8 章：HTML5 的下一步
- en: In addition to graphical advances, HTML5 has a host of other features that make
    it a powerful game development environment. In this chapter, I’ll discuss a few
    of them so you’re aware of what features are available, and I’ll point you to
    some useful resources for further reading. Some of these features, such as WebGL,
    are subjects worthy of their own books, whereas others will be useful only for
    certain types of games. For these reasons, I’ll only introduce the concepts here
    and leave more thorough exploration up to you.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 除了图形方面的进步外，HTML5 还有许多其他特性，使其成为一个强大的游戏开发环境。在本章中，我将讨论其中的一些特性，帮助你了解可用的功能，并为进一步阅读提供一些有用的资源。其中一些特性，例如
    WebGL，是值得单独成书的主题，而另一些则只对某些类型的游戏有用。因此，我这里只介绍这些概念，具体的深入探索留给你自己去做。
- en: Saving and Retrieving Data
  id: totrans-2
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 保存和检索数据
- en: People play games like *Bubble Shooter* in short sessions with little or no
    persistent data; in fact, our game saves only the high score from one session
    to the next. At present, the high score is stored in Web Storage, so it’s unique
    to the browser the game is played on. To save a global high score and display
    a high score table, we’d need to write a server-side component that sends the
    score to a server and retrieves a list of high scores.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 人们像玩 *Bubble Shooter* 这样的游戏时，通常是在短时间内进行的，并且几乎没有或没有持久数据；实际上，我们的游戏只保存从一次会话到下一次会话的最高分。目前，最高分是存储在
    Web Storage 中，因此它对游戏所在的浏览器是唯一的。为了保存一个全局的最高分并显示最高分表，我们需要编写一个服务器端组件，将分数发送到服务器并检索一个最高分列表。
- en: 'Games with more complex states should have server-side access, too. When you
    store state on the server, players can return to the same game from multiple devices.
    For our purposes, we’ll use two main ways to save and retrieve data on a server:
    AJAX and WebSockets.'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 更复杂状态的游戏也应该有服务器端访问。当你将状态存储在服务器上时，玩家可以从多个设备返回到相同的游戏。为了我们的目的，我们将使用两种主要方式在服务器上保存和检索数据：AJAX
    和 WebSockets。
- en: AJAX
  id: totrans-5
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: AJAX
- en: '*AJAX (Asynchronous JavaScript and XML)* provides a technique for sending a
    request to a server and receiving a response. AJAX is not a single technology
    but rather a method by which a number of tried-and-tested browser features are
    combined to make server-side calls and manage the responses. All of the major
    browsers have supported AJAX for a number of years.'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: '*AJAX（异步 JavaScript 和 XML）* 提供了一种向服务器发送请求并接收响应的技术。AJAX 不是单一的技术，而是一种将多种经过验证的浏览器功能结合起来，以进行服务器端调用和管理响应的方法。所有主流浏览器已经支持
    AJAX 多年。'
- en: 'Although the *X* stands for XML, you can use AJAX to retrieve HTML data, string
    data, and JSON strings that can be parsed and interpreted. The code for making
    AJAX calls is well documented, and multiple libraries are available so you don’t
    have to handcraft the calls. For example, here’s how you’d send an AJAX request
    to a server with the `$.ajax` call in jQuery:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管 *X* 代表 XML，但你可以使用 AJAX 检索 HTML 数据、字符串数据和可以解析和解释的 JSON 字符串。AJAX 调用的代码有详细的文档，并且有多个库可以使用，因此你不必手动编写调用代码。例如，以下是如何使用
    jQuery 中的 `$.ajax` 调用向服务器发送 AJAX 请求的方式：
- en: '[PRE0]'
  id: totrans-8
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: This `$.ajax` call makes a `POST` request to the relative URL *save_data.php*,
    sends the value contained in `highScore` to the server under the name `high_score`,
    and logs the server’s response to the console. I set the URL target for the request
    ➊, the data to send ➋, the type of request ➌, and a function to run after the
    request completes ➍, but you can set many other properties, including functions
    to run in case of an error, timeout settings, and so on. These are listed in the
    jQuery documentation at *[http://api.jquery.com/](http://api.jquery.com/)*.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 这个 `$.ajax` 调用向相对 URL *save_data.php* 发起一个 `POST` 请求，将 `highScore` 中的值以 `high_score`
    为名称发送到服务器，并将服务器的响应记录到控制台。我设置了请求的目标 URL ➊，发送的数据 ➋，请求类型 ➌，以及请求完成后运行的函数 ➍，但你可以设置许多其他属性，包括在出现错误时运行的函数、超时设置等。这些属性在
    jQuery 文档中的 *[http://api.jquery.com/](http://api.jquery.com/)* 有列出。
- en: Note
  id: totrans-10
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '*The* A *in AJAX stands for* asynchronous*, because other JavaScript operations
    will continue while the server deals with the data and sends the response. That
    means you can’t be sure when the `complete` function will run: it’ll happen whenever
    the response comes back, but the user interface will remain responsive while it
    happens. It’s possible to make synchronous calls, but because this effectively
    freezes the entire page until the request is complete, the user experience is
    generally so poor that doing so is considered bad practice.*'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: '*AJAX 中的 A 代表* 异步 *，因为在服务器处理数据并发送响应时，其他 JavaScript 操作将继续进行。这意味着你无法确定 `complete`
    函数何时运行：它会在响应返回时执行，但在此过程中，用户界面仍会保持响应。虽然可以进行同步调用，但由于这样会在请求完成之前冻结整个页面，因此用户体验通常很差，所以这种做法通常被认为是不推荐的。*'
- en: WebSockets
  id: totrans-12
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: WebSockets
- en: Most modern browsers also have WebSockets available to make client to server
    calls. WebSockets are a relatively new technology incorporated into the HTML5
    specification. If you want to learn how they work at a lower level than I describe
    here, a good place to start is with the Mozilla Developer Network documentation
    at *[https://developer.mozilla.org/en/docs/WebSockets/](https://developer.mozilla.org/en/docs/WebSockets/)*.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数现代浏览器也支持 WebSockets 用于客户端与服务器之间的调用。WebSockets 是一种相对较新的技术，已被纳入 HTML5 规范。如果你想了解它们如何工作，超越我在此描述的内容，可以从
    Mozilla 开发者网络的文档开始，网址是 *[https://developer.mozilla.org/en/docs/WebSockets/](https://developer.mozilla.org/en/docs/WebSockets/)*。
- en: WebSockets are similar to AJAX, but whereas AJAX sets up a call-and-response
    relationship between the client and server, a WebSocket maintains a persistent
    connection between them. The client deals with responses as they come in, and
    the JavaScript code can listen continuously for further responses. The server
    also constantly listens while the socket is open; therefore, WebSockets are much
    better than AJAX when conversations between the client and server involve lots
    of small data transactions.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: WebSockets 类似于 AJAX，但不同的是，AJAX 在客户端和服务器之间建立了一个请求-响应的关系，而 WebSocket 在它们之间保持持久的连接。客户端处理响应时会立刻处理，并且
    JavaScript 代码可以持续监听后续的响应。服务器也会在套接字连接保持打开时持续监听；因此，当客户端和服务器之间涉及大量小数据交换时，WebSockets
    比 AJAX 要好得多。
- en: A persistent connection is especially useful in multiplayer gaming environments.
    Before WebSockets, the main way to update game state elements shared by multiple
    clients, such as player avatars within an environment, was to continuously poll
    the server with AJAX and check for updates. This would be coded to happen every
    few seconds, which obviously isn’t sufficient for a real-time game. People tried
    various hacks—such as a technique called *long-polling*, which effectively tricks
    the client into maintaining a connection to the server—to improve the process,
    but these were often inefficient in terms of server resources. Now, you can just
    leave a WebSocket open, and whenever one client updates the game state, the server
    can immediately update all of the other clients’ information without waiting for
    the next update cycle.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 持久连接在多人游戏环境中尤其有用。在 WebSockets 出现之前，更新多个客户端共享的游戏状态元素（例如玩家角色在环境中的状态）的主要方式是通过 AJAX
    不断轮询服务器并检查是否有更新。这通常会被编写成每隔几秒钟执行一次，显然这对于实时游戏来说并不足够。人们尝试了各种技巧，例如 *长轮询*，它有效地欺骗客户端保持与服务器的连接，以改善这一过程，但这些方法通常在服务器资源方面效率不高。现在，你只需保持
    WebSocket 连接打开，每当某个客户端更新游戏状态时，服务器就能立即更新所有其他客户端的信息，而不需要等待下一个更新周期。
- en: Mainstream browsers have ever-improving support for WebSockets, and as with
    AJAX, I recommend using a library to eliminate some of the nitty-gritty of opening
    connections, sending and listening for data, and handling errors. Libraries will
    also often have a fallback to AJAX or other server communication methods for cases
    in which WebSockets aren’t supported; however, the fallbacks may not replicate
    the performance features that you’re using WebSockets for in the first place,
    so be aware that they’re not a magic solution.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 主流浏览器对 WebSockets 的支持不断提升，和 AJAX 一样，我推荐使用库来消除打开连接、发送和监听数据、以及处理错误的繁琐细节。库还通常会为
    WebSockets 不被支持的情况提供回退机制，回退机制可能会使用 AJAX 或其他服务器通信方法；然而，回退机制可能无法复制你最初使用 WebSockets
    所希望达到的性能特性，因此要注意它们并不是万能的解决方案。
- en: 'Socket.IO (*[http://socket.io/](http://socket.io/)*) is one of the most popular
    WebSocket libraries. Here’s how you can use it to make a call:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: Socket.IO (*[http://socket.io/](http://socket.io/)*) 是最流行的 WebSocket 库之一。以下是如何使用它进行调用：
- en: '[PRE1]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: This code uses a call to the library with `io.connect` to open a new WebSocket
    and then `socket.emit` sends the `highScore` value as an event named `new_high_score`.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码使用 `io.connect` 调用库打开一个新的 WebSocket，然后 `socket.emit` 将 `highScore` 值作为名为
    `new_high_score` 的事件发送。
- en: WebSockets and libraries such as Socket.IO have much greater capabilities than
    AJAX, but the libraries that make them easy to use often assume a specific server-side
    environment. If you plan to use WebSockets, check that the library you plan to
    use has a backend component that matches your server environment. Libraries for
    most platforms are readily available, whether you’re using Node.js, .NET, or Java.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: WebSocket 和像 Socket.IO 这样的库比 AJAX 更具功能性，但使它们易于使用的库通常假设一个特定的服务器端环境。如果你打算使用 WebSocket，检查你计划使用的库是否有与你的服务器环境匹配的后端组件。大多数平台的库都可以轻松找到，无论你使用的是
    Node.js、.NET 还是 Java。
- en: Along with sending and receiving data to and from the server, you might also
    want to process certain data outside your main game program. That’s where Web
    Workers will come in handy.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 除了与服务器发送和接收数据外，你可能还想在主游戏程序之外处理某些数据。这时，Web Worker 将会派上用场。
- en: Web Workers
  id: totrans-22
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Web Worker
- en: JavaScript in a browser is generally considered a *single-threaded* environment,
    meaning that only one script can run at a time. This won’t cause problems most
    of the time but can be an issue if a particularly large computational process
    blocks the processor from animating, responding to user input, and performing
    other important tasks.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 浏览器中的 JavaScript 通常被认为是 *单线程* 环境，这意味着一次只能运行一个脚本。大多数时候这不会引起问题，但如果一个特别大的计算过程阻塞了处理器，导致动画无法播放、用户输入无法响应以及其他重要任务无法执行时，就可能成为问题。
- en: For example, let’s say processing game-level data takes the browser 1 or 2 seconds,
    and this happens every 30 seconds or so. The overall load may not be high, but
    you can’t pause the game every 30 seconds! In this situation, consider using a
    Web Worker.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 比如，假设处理游戏级别数据需要浏览器花费 1 到 2 秒，每隔大约 30 秒就会发生一次。整体负载可能不高，但你不能每隔 30 秒就暂停游戏！在这种情况下，可以考虑使用
    Web Worker。
- en: Web Workers (*[https://developer.mozilla.org/en/docs/Web/API/Worker/](https://developer.mozilla.org/en/docs/Web/API/Worker/)*)
    allow you to run code in a separate thread without blocking your main JavaScript
    operations. They’re called “workers” because you can essentially hand them a task
    and tell them to report back when they’re finished. The browser will determine
    how much CPU time to give them so as not to interfere unduly with other processes.
    Workers can be dedicated or shared, but you’ll generally find dedicated workers
    most useful, especially while support for Web Workers is being developed across
    browsers.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: Web Worker (*[https://developer.mozilla.org/en/docs/Web/API/Worker/](https://developer.mozilla.org/en/docs/Web/API/Worker/)*）允许你在独立的线程中运行代码，而不会阻塞你的主
    JavaScript 操作。它们之所以被称为“Worker”，是因为你基本上可以把一个任务交给它们，让它们在完成后报告结果。浏览器将决定给它们多少 CPU
    时间，以避免对其他进程造成不必要的干扰。Worker 可以是专用的或共享的，但通常你会发现专用的 Worker 更加有用，尤其是在 Web Worker 跨浏览器支持逐步完善的过程中。
- en: Web Workers follow a couple of rules that differentiate them from regular JavaScript.
    Most important, they have no access to the DOM, the browser document, or the browser
    window. Workers also operate within their own scope, so you’ll need to pass data
    explicitly and then retrieve the result when complete. I’ll illustrate how they
    work with the following example.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: Web Worker 有几个规则，使它们与常规 JavaScript 区别开来。最重要的是，它们无法访问 DOM、浏览器文档或浏览器窗口。Worker
    也在自己的作用域内运行，因此你需要显式传递数据，然后在完成时获取结果。我将通过以下示例来说明它们是如何工作的。
- en: 'Workers are initialized by passing the name of a script to load to the `new
    Worker` command:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: Worker 通过将要加载的脚本名称传递给 `new Worker` 命令来初始化：
- en: '[PRE2]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: This will start a new worker, and that worker will run the script inside *work.js*.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 这将启动一个新的 Worker，Worker 将在 *work.js* 中运行脚本。
- en: 'A worker runs when you send it a message via `postMessage`:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 当你通过 `postMessage` 发送消息时，Worker 会开始运行：
- en: '[PRE3]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The `postMessage` command can contain a JavaScript object or be empty.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: '`postMessage` 命令可以包含一个 JavaScript 对象，也可以为空。'
- en: 'You can handle responses—values a worker returns when it completes a task—by
    adding event listeners to the worker within the calling script:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过向调用脚本中的 Worker 添加事件监听器来处理响应——当 Worker 完成任务时返回的值：
- en: '[PRE4]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Here, `e` contains the data that `worker` sent back. The event to listen to,
    labeled `"message"`, is any valid string. Therefore, a `worker` could send back
    different responses in different circumstances, or it could just keep working
    and sending messages.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`e` 包含了 `worker` 返回的数据。需要监听的事件是标记为 `"message"` 的任何有效字符串。因此，`worker` 可以根据不同的情况发送不同的响应，或者它可以继续工作并发送消息。
- en: 'Inside the worker, the model of event listeners is similar, with the `worker`
    referring to itself as `this` or `self`. As an example, *work.js* could contain
    the following to return the message:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 在 worker 内部，事件监听器的模型类似，`worker` 自我指代为 `this` 或 `self`。举个例子，*work.js* 可能包含如下内容来返回消息：
- en: '[PRE5]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: This code listens for an event marked `"message"`, and on receipt, it immediately
    posts a response in the form of an object.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码监听标记为 `"message"` 的事件，并在收到事件后立即以对象的形式发布响应。
- en: At present, not all the major browsers support Web Workers well enough to make
    it reliable. Polyfills do exist for Web Workers, but these will often negatively
    affect your user’s experience if a long-running process that you assumed would
    be nonblocking suddenly freezes the game for a few seconds. However, the situation
    is constantly improving, and hopefully, Web Workers will soon be considered a
    core part of the HTML5 game developer’s arsenal.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，并非所有主流浏览器都足够好地支持 Web Workers 以使其可靠。确实存在 Web Workers 的 Polyfills，但如果一个原本认为是非阻塞的长期运行过程突然使游戏冻结几秒钟，这些
    Polyfills 往往会对用户体验产生负面影响。然而，情况正在不断改善，希望 Web Workers 很快会成为 HTML5 游戏开发者工具箱的核心部分。
- en: But managing your data more effectively is just a start to making your game
    more fun. Appearance matters, too, and for a graphics upgrade, you can go 3D with
    WebGL or even use it to beef up your rendering power for 2D games.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 更有效地管理你的数据只是让游戏更有趣的开始。外观也很重要，若要进行图形升级，你可以使用 WebGL 实现 3D，或者甚至利用它提升 2D 游戏的渲染能力。
- en: WebGL
  id: totrans-41
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: WebGL
- en: For the canvas version of *Bubble Shooter*, we used the 2D rendering context,
    accessed with calls along the lines of
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 *Bubble Shooter* 的 canvas 版本，我们使用了 2D 渲染上下文，通过类似以下的调用方式来访问：
- en: '[PRE6]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'As I touched upon in [Chapter 6](ch06.html "Chapter 6. Rendering Canvas Sprites"),
    the specification of `"2d"` implies that other options are available, and sometimes,
    depending on browser support, that’s true. The third dimension is accessed through
    WebGL, an API that provides a set of 3D manipulation functions for creating scenes,
    adding lighting and textures, positioning cameras, and so on, taking advantage
    of the acceleration that modern graphics cards provide. (Visit *[https://www.khronos.org/registry/webgl/specs/1.0/](https://www.khronos.org/registry/webgl/specs/1.0/)*
    to learn about WebGL in more detail.) To start using WebGL, we first instantiate
    a 3D context with the following:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我在[第6章](ch06.html "第6章 渲染 Canvas 精灵")中提到的，`"2d"`的规范意味着还可以使用其他选项，有时根据浏览器支持情况，确实如此。第三维度通过
    WebGL 访问，WebGL 是一个 API，提供了一组 3D 操作函数，用于创建场景、添加光照和纹理、定位相机等，利用现代显卡提供的加速功能。（访问 *[https://www.khronos.org/registry/webgl/specs/1.0/](https://www.khronos.org/registry/webgl/specs/1.0/)*
    了解更多关于 WebGL 的详细信息。）要开始使用 WebGL，我们首先通过以下方式实例化一个 3D 上下文：
- en: '[PRE7]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'This is sometimes retrieved as `"experimental-webgl"`, so the most compatible
    call is this:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 这有时会以 `"experimental-webgl"` 的形式返回，因此最兼容的调用是：
- en: '[PRE8]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Accelerated WebGL is powerful enough to display fully rendered 3D scenes rivaling
    those of native games. The downside is that working in three dimensions and manipulating
    and creating scenes requires a lot of math and a lot of low-level code that involves
    writing programs directly to the graphics processor. The concepts are the same
    as when creating 3D games in native code, such as C++, and require low-level knowledge
    of 3D modeling to describe the shape of an object; textures to define surface
    patterns; and shaders, which describe how to render a surface when light hits
    it. As such, I highly recommend working with existing libraries to handle model
    rendering, any physics requirements, and basically any features you can get off
    the shelf. Babylon.js (*[http://www.babylonjs.com/](http://www.babylonjs.com/)*)
    and PlayCanvas (*[https://playcanvas.com/](https://playcanvas.com/)*) are two
    libraries that make working with WebGL in the browser much simpler.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 加速的 WebGL 足够强大，可以显示完全渲染的 3D 场景，与原生游戏的场景相媲美。缺点是，工作在三维空间中，操作和创建场景需要大量的数学运算，以及大量低级代码，需要直接向图形处理器编写程序。其概念与在原生代码（如
    C++）中创建 3D 游戏相同，并且需要具有 3D 建模的低级知识，以描述物体的形状；纹理来定义表面图案；以及着色器，用于描述当光线照射到表面时如何渲染它。因此，我强烈推荐使用现有的库来处理模型渲染、任何物理需求，以及基本上你能从现成工具中获得的任何功能。Babylon.js
    (*[http://www.babylonjs.com/](http://www.babylonjs.com/)*) 和 PlayCanvas (*[https://playcanvas.com/](https://playcanvas.com/)*)
    是两个可以大大简化在浏览器中使用 WebGL 的库。
- en: Using WebGL also brings up the question of how to import objects and textures
    into 3D scenes. Typically, you create models in modeling software, such as 3D
    Studio or Maya, and then export to a commonly supported format. WebGL libraries
    generally won’t work with those formats, so you’ll usually need to convert from
    the original 3D modeling file format to JSON using another set of tools, such
    as the 3DS Max-to-Babylon.js exporter (*[https://github.com/BabylonJS/Babylon.js/tree/master/Exporters/3ds%20Max](https://github.com/BabylonJS/Babylon.js/tree/master/Exporters/3ds%20Max)*),
    which exports from Autodesk’s 3D Studio product into Babylon.js.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 WebGL 还引出了如何将对象和纹理导入 3D 场景的问题。通常，你会在建模软件中创建模型，如 3D Studio 或 Maya，然后导出为常见支持的格式。WebGL
    库通常不支持这些格式，因此你通常需要使用其他工具集将原始 3D 建模文件格式转换为 JSON，例如 3DS Max 到 Babylon.js 的导出工具 (*[https://github.com/BabylonJS/Babylon.js/tree/master/Exporters/3ds%20Max](https://github.com/BabylonJS/Babylon.js/tree/master/Exporters/3ds%20Max)*)，它可以将
    Autodesk 的 3D Studio 产品导出为 Babylon.js 格式。
- en: Creating and converting 3D models is a large enough task that WebGL game development
    quickly becomes a project for teams of developers and designers rather than for
    a sole developer; however, many very impressive demos have been made entirely
    solo, and the Babylon.js website has a great set of showcases.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 创建和转换 3D 模型是一个庞大的任务，以至于 WebGL 游戏开发很快就成为了开发者和设计师团队的项目，而非单个开发者的任务；然而，许多非常令人印象深刻的演示是完全由单人完成的，Babylon.js
    网站上有一组很棒的展示。
- en: A secondary advantage of the WebGL context is that you can use it to render
    2D scenes, which can then take advantage of the huge speed available through GPU
    acceleration. Particle effects and rendering large numbers of onscreen elements
    in accelerated WebGL far outperform the same tasks in the canvas.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: WebGL 上下文的一个次要优势是，你可以使用它来渲染 2D 场景，这样就能利用 GPU 加速带来的巨大速度。粒子效果和在加速的 WebGL 中渲染大量屏幕元素的表现，远远超过了
    canvas 中执行相同任务的效果。
- en: I recommend that you look for off-the-shelf libraries that enable 2D rendering
    in WebGL. One such library is Pixi.js (*[http://www.pixijs.com/](http://www.pixijs.com/)*),
    which also provides a fallback to the canvas.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 我推荐你寻找能够在 WebGL 中启用 2D 渲染的现成库。一个这样的库是 Pixi.js (*[http://www.pixijs.com/](http://www.pixijs.com/)*)，它还提供了对
    canvas 的回退支持。
- en: Browser support for WebGL is growing and includes the latest versions of Chrome,
    Firefox, and Internet Explorer, although older versions of Internet Explorer are
    incompatible at the time of this writing. For this reason, WebGL isn’t considered
    ready for mass-market development, but this situation continues to improve.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 浏览器对 WebGL 的支持正在增长，包括最新版本的 Chrome、Firefox 和 Internet Explorer，尽管在写这篇文章时，旧版本的
    Internet Explorer 不兼容。因此，WebGL 目前不被认为适合大规模市场开发，但这种情况正在持续改善。
- en: Building a slick game is all well and good, but a game is nothing without players.
    To reach players, you need to deploy your game somewhere publicly accessible.
    Depending on where you deploy, you should consider some changes to improve the
    player’s experience.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一款精美的游戏固然很好，但没有玩家，游戏就没有意义。要让玩家访问，你需要将游戏部署到一个公开可访问的地方。根据部署的位置，你应该考虑做出一些改变，以提升玩家的体验。
- en: Deploying HTML5 Games
  id: totrans-55
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 部署 HTML5 游戏
- en: In this section, I’ll give a brief overview of the process behind deploying
    a game running inside desktop and mobile browsers, and I’ll explain how you’d
    wrap up an HTML5 application as a native mobile application.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我将简要概述在桌面和移动浏览器中运行游戏的部署过程，并解释如何将 HTML5 应用程序封装为本地移动应用程序。
- en: Running Fullscreen in a Desktop Browser
  id: totrans-57
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在桌面浏览器中运行全屏
- en: 'One way to deploy an HTML5 game is to just create a website and upload it.
    In fact, just upload *Bubble Shooter* to the Web to make it accessible to anyone
    who accesses the *index.html* file. Deploying an HTML5 game to the Web is no different
    from deploying any other website; however, players often complain about a lack
    of immersion when they are running games in a browser, because it’s easy to become
    distracted by tabs showing notifications from Facebook, email, instant messages,
    and so on. The HTML5 arsenal has a trick to fix these interruptions: the Fullscreen
    API.'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 部署 HTML5 游戏的一种方式是创建一个网站并上传它。事实上，只需将*泡泡射手*上传到 Web，就能让任何访问 *index.html* 文件的人都能玩这个游戏。将
    HTML5 游戏部署到 Web 与部署任何其他网站没有什么不同；然而，玩家常常抱怨在浏览器中玩游戏时缺乏沉浸感，因为很容易被显示 Facebook、电子邮件、即时消息等通知的标签页所打扰。HTML5
    提供了一个解决这些中断的技巧：全屏 API。
- en: Where supported, the Fullscreen API lets a web page fill the entire width and
    height of the screen, removing the address bar and other browser frame elements.
    You can implement fullscreen capabilities by running the following JavaScript
    code. For security reasons, you need to run this code inside a user-generated
    event handler; that is, you will usually make a button for the player to click
    or specify a key for them to press to activate fullscreen mode.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 在支持的环境下，全屏 API 允许网页填满整个屏幕的宽度和高度，去除地址栏和其他浏览器框架元素。你可以通过运行以下 JavaScript 代码来实现全屏功能。出于安全原因，你需要在用户生成的事件处理程序内运行此代码；也就是说，通常你会为玩家创建一个按钮，或指定一个按键来激活全屏模式。
- en: '[PRE9]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Note the use of vendor prefixes while the `requestFullScreen` API is being implemented
    (`mozRequestFullScreen` for Firefox, `webkitRequestFullScreen` for Chrome, and
    so on). When you call `requestFullScreen`, the user should see a dialog from the
    browser asking whether to allow or deny your game’s request to go fullscreen.
    If the player allows fullscreen, pressing the ESC key should return them to the
    regular view.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意在实现 `requestFullScreen` API 时使用了供应商前缀（Firefox 使用 `mozRequestFullScreen`，Chrome
    使用 `webkitRequestFullScreen`，等等）。当你调用 `requestFullScreen` 时，用户应该会看到浏览器弹出对话框，询问是否允许或拒绝游戏请求进入全屏。如果玩家允许全屏，按下
    ESC 键应该会将他们返回到常规视图。
- en: 'You can also apply fullscreen mode to a single element inside the DOM. You
    might want to do this if you have a game running within a website with navigation
    to other pages, for example. Then, players can go into fullscreen mode to remove
    the distractions of navigation bars and other page clutter. You could even apply
    fullscreen mode to *Bubble Shooter*. Just add a new toolbar button that runs the
    following code when a player clicks the button:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以将全屏模式应用于 DOM 中的单个元素。如果你的网站中有运行中的游戏，并且包含导航到其他页面的功能，你可能想这样做。这样，玩家可以进入全屏模式，去除导航栏和其他页面杂物的干扰。你甚至可以将全屏模式应用于*泡泡射手*。只需添加一个新的工具栏按钮，当玩家点击该按钮时运行以下代码：
- en: '[PRE10]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: I’ll leave this as an exercise for you to implement, and I suggest you add it
    to *ui.js* to keep it with the other user interface code. But if you’d rather
    not deploy to your own website, try a hosting service. You could set up an application
    on Facebook or upload a game to a dedicated game website, such as Kongregate.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 我将把这部分留给你自己实现，并建议你将其添加到*ui.js*中，以便与其他用户界面代码一起管理。但如果你不想将其部署到你自己的网站，可以尝试使用托管服务。你可以在
    Facebook 上设置一个应用程序，或者将游戏上传到专门的游戏网站，例如 Kongregate。
- en: Of course, the promise of cross-platform development and deployment is one of
    the biggest attractions of HTML5, and because most desktop browser features have
    been ported to mobile browsers, *Bubble Shooter* should work just as well on both.
    However, the behaviors aren’t quite identical between platforms, and I’ll discuss
    those differences next.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，跨平台开发和部署的承诺是HTML5最吸引人的特点之一，而且因为大多数桌面浏览器的功能已经移植到移动浏览器，*泡泡射手*应该能够在两者上都顺利运行。然而，不同平台之间的行为并不完全相同，接下来我将讨论这些差异。
- en: Running in a Mobile Browser
  id: totrans-66
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在移动浏览器中运行
- en: Even if you’re still running *Bubble Shooter* on a local or development web
    server, you should be able to load the game in a mobile browser and play it. It
    should function just as well as it does on a desktop browser. Congratulations,
    you’ve just made your first mobile game!
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 即使你仍然在本地或开发Web服务器上运行*泡泡射手*，你也应该能够在移动浏览器中加载并玩这个游戏。它的表现应该与在桌面浏览器上一样好。恭喜你，你刚刚制作了第一个移动游戏！
- en: Note
  id: totrans-68
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '*In case you haven’t deployed the game yet, you can also play it at* [http://buildanhtml5game.com/bubbleshooter/](http://buildanhtml5game.com/bubbleshooter/)*.*'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: '*如果你还没有发布游戏，你也可以在* [http://buildanhtml5game.com/bubbleshooter/](http://buildanhtml5game.com/bubbleshooter/)
    *上玩它。*'
- en: When developing games for mobile devices, it’s more likely you’ll need to make
    usability and interface changes than technical ones, but that’s not to say you
    can ignore implementation changes completely. You’ll benefit from knowing the
    subtle differences in behavior and how to optimize the experience for mobile users,
    so let’s get started.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 在为移动设备开发游戏时，你更有可能需要做的是可用性和界面方面的调整，而不是技术上的修改，但这并不意味着你可以完全忽视实现上的变化。你将从了解这些细微的行为差异和如何优化移动用户体验中受益，所以让我们开始吧。
- en: Touch Events
  id: totrans-71
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 触摸事件
- en: First, touchscreen-specific events are implemented by browsers on touchscreen
    devices. Two of those events are `touchstart` and `touchend`, which are roughly
    equivalent to `mousedown` and `mouseup`, respectively. However, the `click` event
    differs slightly in a touchscreen environment. Mobile browsers wait a few hundred
    milliseconds to determine whether the user double-taps, which is a zoom operation,
    to make absolutely sure that the user intends a single `click`. This won’t make
    much difference in *Bubble Shooter*, but for rapid-reaction games, those few hundred
    milliseconds will be noticeable to the player.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，触摸屏设备上的浏览器实现了特定的触摸事件。这些事件中有两个是`touchstart`和`touchend`，它们大致等同于`mousedown`和`mouseup`。然而，`click`事件在触摸屏环境中略有不同。移动浏览器会等待几百毫秒，以确定用户是否进行双击（即放大操作），以确保用户确实打算进行单次`click`。在*泡泡射手*中，这不会有太大区别，但在快速反应类游戏中，这几百毫秒的延迟对于玩家来说是可以察觉的。
- en: 'You can use mobile-specific events, and they’ll be ignored on desktop devices
    without a touchscreen, although for the most part, using `mousedown` will have
    the same effect as `touchstart` and `mouseup` will be equivalent to `touchend`.
    For example, in *Bubble Shooter*, we could use `mousedown` instead of `click`
    to detect when the player wants to fire a bubble, which would turn this line from
    *game.js*:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用移动设备特有的事件，这些事件在没有触摸屏的桌面设备上会被忽略，尽管大多数情况下，使用`mousedown`将与`touchstart`效果相同，`mouseup`则等同于`touchend`。例如，在*泡泡射手*中，我们可以使用`mousedown`代替`click`来检测玩家何时想要发射泡泡，这样会将*game.js*中的这一行变成：
- en: '[PRE11]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'into this line of code instead:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 改为以下这行代码：
- en: '[PRE12]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The only effect would be that the bubble will fire when the user clicks the
    mouse button down or touches the screen rather than waiting for the mouse button
    to be released or the finger removed from the screen.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 唯一的效果是，玩家点击鼠标按钮或触摸屏幕时，泡泡会立即发射，而不是等待鼠标按钮释放或手指离开屏幕。
- en: Note
  id: totrans-78
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '*Using only the mouse and touch events will remove keyboard accessibility if
    you have a game that could conceivably be controlled by the keyboard. In some
    games, you might want to continue using the click event so a player could still,
    for example, navigate a menu system using the keyboard or other input device.*'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: '*如果只使用鼠标和触摸事件，将会移除键盘的可访问性，特别是如果你的游戏本来可以用键盘控制的话。在某些游戏中，你可能仍然希望使用点击事件，以便玩家仍然可以使用键盘或其他输入设备导航菜单系统。*'
- en: 'If you know that your game will be played only on a mobile device, you could
    also use `touchstart`:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你知道你的游戏只会在移动设备上玩，你也可以使用`touchstart`：
- en: '[PRE13]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: This should work the same way as `mousedown`.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 这应该与`mousedown`的效果相同。
- en: You may be wondering, then, why `touchstart` and `touchend` exist at all if
    they’re virtually equivalent to `mousedown` and `mouseup`. The answer is that
    in most cases you can treat them as conceptually equivalent, but touch events
    can be useful if you want to detect more than one touch point simultaneously.
    The user will (usually) have only one mouse pointer, but it’s possible to make
    contact with a touchscreen in multiple places. If you’re building a game that
    requires this kind of input, touch events are the ones to use, and you’ll have
    to find a way to make them work in a mouse environment.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 那么你可能会想，既然 `touchstart` 和 `touchend` 与 `mousedown` 和 `mouseup` 几乎等价，那它们存在的意义是什么？答案是，在大多数情况下，你可以将它们视为概念上的等价物，但触摸事件在你需要同时检测多个触摸点时非常有用。用户通常只有一个鼠标指针，但在触摸屏上，可以在多个位置进行触碰。如果你正在构建一个需要这种输入的游戏，触摸事件是你要使用的，而你也需要找到方法在鼠标环境中使它们生效。
- en: Scaling
  id: totrans-84
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 缩放
- en: 'Another interaction difference comes into play with zooming. You probably don’t
    want players zooming into the game area at all, whether they double-tap or not.
    Fortunately, you can restrict this by adding `<meta>` tags to the HTML head:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个交互差异出现在缩放操作上。你可能不希望玩家在游戏区域进行缩放，无论他们是否双击。幸运的是，你可以通过向 HTML 头部添加 `<meta>` 标签来限制这一点：
- en: '[PRE14]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: This example tells the browser to render the page at a scale of 1:1 and set
    the viewport width to the default for the device. The content of the `<meta>`
    tag specifies the size of the display and restricts (or allows) zooming. Apple
    originally introduced this `<meta>` tag, and other browsers use it as a basis
    for their own behavior. Hence, Apple’s own documentation (*[https://developer.apple.com/library/ios/documentation/AppleApplications/Reference/SafariWebContent/UsingtheViewport/UsingtheViewport.html](https://developer.apple.com/library/ios/documentation/AppleApplications/Reference/SafariWebContent/UsingtheViewport/UsingtheViewport.html)*)
    is the best place to look for a description of the various options. However, using
    this tag is very much a case of looking up what’s expected to happen in any particular
    mobile browser and then testing it to see how it works in practice. Work is underway
    to standardize viewport sizing using CSS (*[http://www.w3.org/TR/css-device-adapt/](http://www.w3.org/TR/css-device-adapt/)*),
    although it has minimal browser support at present.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 这个示例告诉浏览器将页面按 1:1 的比例渲染，并将视口宽度设置为设备的默认值。`<meta>` 标签的内容指定了显示的大小，并限制（或允许）缩放。这个
    `<meta>` 标签最初是由 Apple 引入的，其他浏览器也以它为基础实现自己的行为。因此，Apple 自己的文档 (*[https://developer.apple.com/library/ios/documentation/AppleApplications/Reference/SafariWebContent/UsingtheViewport/UsingtheViewport.html](https://developer.apple.com/library/ios/documentation/AppleApplications/Reference/SafariWebContent/UsingtheViewport/UsingtheViewport.html)*)
    是查看各种选项描述的最佳地方。然而，使用这个标签实际上就是查找任何特定移动浏览器的预期行为，然后测试它在实际中的效果。目前，CSS 正在进行视口大小的标准化工作
    (*[http://www.w3.org/TR/css-device-adapt/](http://www.w3.org/TR/css-device-adapt/)*)，但目前浏览器支持有限。
- en: 'The most common option you’ll use in the `<meta>` tag is `user-scalable=no`,
    which simply prevents the user from zooming. But changing the other values in
    the `<meta>` tag can greatly affect how the browser displays your game, too. The
    settings in the `<meta>` tag are as follows:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `<meta>` 标签中，你最常用的选项是 `user-scalable=no`，它简单地防止用户进行缩放。但改变 `<meta>` 标签中的其他值也会极大地影响浏览器如何显示你的游戏。`<meta>`
    标签中的设置如下：
- en: '****`user-scalable`****. Can be yes or no. Allows or disables zooming.'
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '****`user-scalable`****。可以是 yes 或 no。允许或禁用缩放。'
- en: '****`initial-scale`****. A decimal number specifying the zoom factor at which
    to draw the viewport.'
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '****`initial-scale`****。一个小数，指定绘制视口时的缩放因子。'
- en: '****`maximum-scale`****. A decimal representing the maximum zoomable scale
    to allow the user to zoom to.'
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '****`maximum-scale`****。一个表示允许用户缩放到的最大缩放比例的小数。'
- en: '****`minimum-scale`****. A decimal representing the minimum zoomable scale
    to allow the user to zoom to.'
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '****`minimum-scale`****。一个表示允许用户缩放到的最小缩放比例的小数。'
- en: '****`width`****. Specify this in pixels, or use `device-width`.'
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '****`width`****。指定为像素值，或者使用 `device-width`。'
- en: '****`height`****. Specify this in pixels, or use `device-height`.'
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '****`height`****。指定为像素值，或者使用 `device-height`。'
- en: If the game is designed with a width of, say, 760 pixels, you could set `width`
    to 760, and the browser would keep the page at that width and eliminate any extra
    pixels of spacing on either side. Unfortunately, by scaling the viewport, you’ll
    almost certainly have to solve problems with image scaling and aspect ratio; trying
    to draw 760 pixels on a screen that’s made up of 1024 pixels means some aliasing
    will need to occur.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 如果游戏的设计宽度为760像素，例如，你可以将`width`设置为760，浏览器将保持该宽度，并去除两侧多余的空白像素。不幸的是，通过缩放视口，你几乎肯定会遇到图像缩放和纵横比的问题；尝试在1024像素的屏幕上绘制760像素意味着需要进行一些锯齿化处理。
- en: Aspect ratios also vary much more between mobile devices than desktop screens.
    For example, the iPad 1 and 2 have a resolution of 1024×768, the iPad 3 is 2048×1536,
    the iPhone 6 is 750×1334, the iPhone 6 Plus is 1080×1920, and there are almost
    as many Android resolutions as there are devices. Unfortunately, no simple solution
    exists. Be sure to test continually on a wide range of devices, and experiment
    with a combination of `<meta>` properties and CSS layouts to ensure your game
    looks good on a variety of screen sizes and aspect ratios.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 移动设备之间的纵横比变化比桌面屏幕要大得多。例如，iPad 1和2的分辨率是1024×768，iPad 3是2048×1536，iPhone 6是750×1334，iPhone
    6 Plus是1080×1920，而Android设备的分辨率几乎与设备数量一样多。不幸的是，没有简单的解决方案。确保在各种设备上不断测试，并尝试结合使用`<meta>`属性和CSS布局，以确保你的游戏在不同的屏幕尺寸和纵横比上都能良好显示。
- en: Of course, even after you solve the aspect ratio problem, if users are still
    playing your game through a mobile browser, they may not be able to play while
    offline. To really get an HTML5 game onto the device, you need to wrap up the
    code in a native package. When your game is a native application, the user should
    be able to play it whether online or offline, unless your game requires an Internet
    connection anyway. Let’s look at using a wrapper service next.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，即使你解决了纵横比问题，如果用户仍通过手机浏览器玩你的游戏，他们可能无法在离线状态下玩游戏。要真正将HTML5游戏部署到设备上，你需要将代码打包成原生应用程序。当你的游戏是原生应用时，用户应该能够在线或离线玩游戏，除非你的游戏本身就需要互联网连接。接下来我们来看看如何使用封装器服务。
- en: Deploying as a Native Application
  id: totrans-98
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 部署为原生应用程序
- en: You have two main ways to deploy your HTML5 game as a native web application.
    You can write a wrapper using Objective-C, Java, or whichever language the target
    platform requires, or you can use an existing wrapper service. Unless you’re very
    proficient with native mobile coding, I highly recommend that you look at a wrapper
    service.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 你有两种主要方式将HTML5游戏部署为原生Web应用程序。你可以使用Objective-C、Java或目标平台要求的其他语言编写封装器，或者使用现有的封装器服务。除非你对原生移动编码非常熟练，否则我强烈建议你使用封装器服务。
- en: Wrapper services, such as PhoneGap/Cordova (*[http://cordova.apache.org/](http://cordova.apache.org/)*)
    and Ludei (*[https://www.ludei.com/](https://www.ludei.com/)*), give you less
    control, but they often provide access to native features, such as accelerometers
    and in-app purchases. Sometimes they even offer accelerated graphics capabilities
    and bespoke APIs. They require less time and effort, too, making them an excellent
    way to build test deployments so you can quickly see your game running on a device.
    I’d advise using a service unless you have a very good reason not to.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 封装器服务，如PhoneGap/Cordova (*[http://cordova.apache.org/](http://cordova.apache.org/)*
    ) 和 Ludei (*[https://www.ludei.com/](https://www.ludei.com/)* )，虽然提供的控制较少，但通常可以访问原生功能，如加速计和应用内购买。有时它们甚至提供加速的图形功能和定制的API。它们也需要更少的时间和精力，是构建测试部署的绝佳方式，这样你可以快速看到游戏在设备上运行的效果。除非你有非常充分的理由，否则我建议使用这些服务。
- en: Using a third-party wrapper often involves uploading your HTML5 code through
    an online service and downloading a compiled version for each device. These services
    effectively do the same work as custom wrappers, but they’ve been optimized over
    iterations, usually for multiple platforms. They also continue to add support
    for newer handsets and operating systems, which is very time consuming to keep
    on top of yourself. In addition, a community is usually writing plug-ins to provide
    extra functionality, such as offering in-app purchases or accessing the device’s
    camera.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 使用第三方封装器通常涉及通过在线服务上传你的HTML5代码，并为每个设备下载编译后的版本。这些服务实际上完成了与自定义封装器相同的工作，但经过多次迭代优化，通常支持多个平台。它们还不断为更新的手机和操作系统添加支持，而这些内容如果自己跟进是非常耗时的。此外，社区通常会编写插件提供额外的功能，例如提供应用内购买或访问设备的相机。
- en: Just remember that no matter how you decide to wrap your HTML5 application,
    the files will all be running in a local environment; that is, your game won’t
    need to download assets over the Web or from a server. As a result, your game
    will be playable even when no web connection is available. If you’re developing
    a multiplayer game, it will need an Internet connection to be active, but even
    then your game will benefit from faster startup times and (if your game is a hit)
    it will save on bandwidth costs. As always, perform constant iterative testing
    to intercept problems before they become major issues.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 只需记住，无论你决定如何包装你的 HTML5 应用程序，文件都会在本地环境中运行；也就是说，你的游戏不需要通过网络或服务器下载资源。因此，即使没有网络连接，你的游戏仍然可以运行。如果你正在开发一款多人游戏，它需要活跃的互联网连接，但即便如此，你的游戏也将受益于更快的启动时间，并且（如果你的游戏很受欢迎）还能节省带宽费用。像往常一样，进行持续的迭代测试，以便在问题变成重大问题之前就加以发现。
- en: That’s the end of my mobile tour, but on a desktop browser, *Bubble Shooter*
    is simple enough that unless you’re playing on a very low-powered machine, you
    shouldn’t run into performance problems. But at some point, as you develop more
    complex games, you’ll find that some piece of code runs slower than intended,
    and then you’ll want to optimize that code.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是我关于移动设备的部分内容，但在桌面浏览器上，*Bubble Shooter* 足够简单，除非你在非常低配的机器上玩，否则你应该不会遇到性能问题。但在某个阶段，随着你开发更复杂的游戏，你会发现某些代码比预期运行得更慢，届时你就需要优化这部分代码。
- en: Optimization
  id: totrans-104
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 优化
- en: Two main areas to look at when you’re optimizing a game are memory management
    and speed. In particular, you should ensure your game doesn’t consume increasing
    amounts of system resources the longer it runs, and you’ll want to make the most
    of available hardware and coding tricks for speed.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 当你在优化游戏时，主要要关注的两个方面是内存管理和速度。特别是，你应该确保游戏在运行时间越长时，不会消耗越来越多的系统资源，同时你还需要充分利用现有的硬件和编程技巧来提升速度。
- en: Whether or not you encounter visible problems, such as slowing animation, continually
    checking your game’s performance is good practice. You’ll likely only need to
    optimize for speed as a result of a specific problem, but keeping an eye on memory
    utilization is good practice in all cases. For example, a game may run fine when
    you play for five minutes, but if you leave it open in a browser tab for hours
    on end, you may return to find your nice animation loop eating up tens or hundreds
    of megabytes of memory because of a leak. For less powerful mobile devices, this
    can be a real problem.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 无论你是否遇到明显的问题，比如动画变慢，定期检查游戏的性能都是一个好习惯。通常，只有在遇到特定问题时，你才需要进行速度优化，但无论如何，保持对内存使用情况的关注始终是一个好习惯。例如，一个游戏在你玩五分钟时可能运行得很顺利，但如果你让它在浏览器标签页中保持开着几个小时，你可能会发现回到游戏时，漂亮的动画循环因为内存泄漏已经消耗了几十或几百兆字节的内存。对于较弱的移动设备来说，这可能是一个真正的问题。
- en: Fortunately, browser tools can help identify and diagnose problems, and you
    can implement coding techniques to fix those problems or minimize the risk of
    them happening. Good memory management is particularly important, so we’ll look
    at that before we move on to speed optimization.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，浏览器工具可以帮助识别和诊断问题，你也可以实现一些编码技巧来修复这些问题或尽量减少问题发生的风险。良好的内存管理尤为重要，因此在我们继续进行速度优化之前，我们先来看一下这方面的内容。
- en: Memory Management
  id: totrans-108
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 内存管理
- en: You might not expect a small JavaScript game to run into memory issues on systems
    that happily run massive 3D games, but memory management is actually a pressing
    concern for HTML5 game developers. The problem is less about running out of memory
    (although it is possible, with some effort, to use up a vast amount of memory)
    and more about the way JavaScript allocates memory and frees it up later. Rather
    than constantly allocating and freeing memory, browsers run through periodic sweeps
    to clear memory, which can cause jittery animations, unresponsive interfaces,
    and general interruption of game flow.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能不会期望一个小型的 JavaScript 游戏会在能够顺利运行大型 3D 游戏的系统上遇到内存问题，但内存管理实际上是 HTML5 游戏开发者面临的一个紧迫问题。问题不在于内存用完（尽管通过一些努力，确实有可能耗尽大量内存），而在于
    JavaScript 分配和释放内存的方式。浏览器不会不断地分配和释放内存，而是定期进行清理操作，这可能会导致动画卡顿、界面无响应以及游戏流程中断等问题。
- en: Writing JavaScript in ways that minimize memory usage is a large subject, and
    browser vendors often publish papers on how to get the best out of their systems.
    For example, check out Mozilla’s documentation on memory management at *[https://developer.mozilla.org/en-US/docs/Web/JavaScript/Memory_Management/](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Memory_Management/)*.
    You can also read an excellent introduction to memory-efficient JavaScript, written
    by one of the Chrome engineers, Addy Osmani, at *[http://www.smashingmagazine.com/2012/11/05/writing-fast-memory-efficient-javascript/](http://www.smashingmagazine.com/2012/11/05/writing-fast-memory-efficient-javascript/)*.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 以节省内存的方式编写 JavaScript 是一个庞大的话题，浏览器厂商经常发布关于如何充分利用其系统的论文。例如，查看 Mozilla 关于内存管理的文档，链接为
    *[https://developer.mozilla.org/en-US/docs/Web/JavaScript/Memory_Management/](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Memory_Management/)*。你还可以阅读由
    Chrome 工程师 Addy Osmani 编写的关于内存高效 JavaScript 的优秀介绍，链接为 *[http://www.smashingmagazine.com/2012/11/05/writing-fast-memory-efficient-javascript/](http://www.smashingmagazine.com/2012/11/05/writing-fast-memory-efficient-javascript/)*。
- en: The key to dealing with memory issues is identifying them in the first place.
    You may suspect you have a problem, but you need to know where it is. The main
    desktop browsers have tools to help. Those tools are constantly evolving, so I
    won’t discuss them in depth. But a search through the documentation for each browser
    should bring up relevant documents and tutorials, such as the one for Chrome at
    *[https://developer.chrome.com/devtools/docs/javascript-memory-profiling/](https://developer.chrome.com/devtools/docs/javascript-memory-profiling/)*.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 处理内存问题的关键是首先识别问题。你可能怀疑自己遇到了问题，但你需要知道问题出在哪里。主要的桌面浏览器都有帮助的工具。这些工具在不断发展，所以我不会深入讨论它们。但通过浏览每个浏览器的文档，应该能找到相关的文档和教程，比如
    Chrome 的文档，链接为 *[https://developer.chrome.com/devtools/docs/javascript-memory-profiling/](https://developer.chrome.com/devtools/docs/javascript-memory-profiling/)*。
- en: 'Here’s where to start in the three major browsers:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是三大浏览器中的操作步骤：
- en: In Chrome, open Developer Tools and click **Profiles**. Select **Take Heap Snapshot**
    and click **Take Snapshot** to examine objects in memory, including DOM elements.
    [Figure 8-1](ch08.html#snapshot_of_bubble_shooter_in_memorycomm "Figure 8-1. A
    snapshot of Bubble Shooter in memory, as displayed by the Chrome browser tools")
    shows how this looks for *Bubble Shooter*.
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 Chrome 中，打开开发者工具并点击**Profiles**。选择**Take Heap Snapshot**，然后点击**Take Snapshot**以检查内存中的对象，包括
    DOM 元素。[图 8-1](ch08.html#snapshot_of_bubble_shooter_in_memorycomm "图 8-1. 通过 Chrome
    浏览器工具显示的 Bubble Shooter 内存快照")展示了 *Bubble Shooter* 的内存快照。
- en: In Firefox, you can use Firebug and other plug-ins to examine objects in memory.
    You can also type **`about:memory`** into the address bar for a snapshot of what’s
    currently in the browser’s memory.
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 Firefox 中，你可以使用 Firebug 和其他插件来检查内存中的对象。你也可以在地址栏输入 **`about:memory`** 来查看当前浏览器内存的快照。
- en: In Internet Explorer 11, open the Developer Tools and select the **Memory**
    tool.
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 Internet Explorer 11 中，打开开发者工具并选择**Memory**工具。
- en: '![A snapshot of Bubble Shooter in memory, as displayed by the Chrome browser
    tools](httpatomoreillycomsourcenostarchimages2184543.png.jpg)'
  id: totrans-116
  prefs: []
  type: TYPE_IMG
  zh: '![通过 Chrome 浏览器工具显示的 Bubble Shooter 内存快照](httpatomoreillycomsourcenostarchimages2184543.png.jpg)'
- en: Figure 8-1. A snapshot of *Bubble Shooter* in memory, as displayed by the Chrome
    browser tools
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8-1. 通过 Chrome 浏览器工具显示的 *Bubble Shooter* 内存快照
- en: Another useful tool is to visualize when garbage collection is occurring. This
    takes the form of a graph across time, and you can see what range of memory your
    game is occupying. [Figure 8-2](ch08.html#memory_usage_by_bubble_shooter "Figure 8-2. Memory
    usage by Bubble Shooter") shows *Bubble Shooter*’s memory usage over time.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个有用的工具是可视化垃圾回收发生的时刻。它以一条时间轴上的图形形式呈现，你可以看到你的游戏占用了多少内存。[图 8-2](ch08.html#memory_usage_by_bubble_shooter
    "图 8-2. Bubble Shooter 的内存使用情况")展示了 *Bubble Shooter* 随时间的内存使用情况。
- en: The sawtooth line represents memory used when objects are created. The line
    rises, and then it sharply drops when garbage collection occurs. Although we’re
    not creating and destroying many objects, there’s a definite sign that if we saw
    problems with animations not running smoothly, we could look at using more object
    pools.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 锯齿形的线代表在创建对象时使用的内存。当对象被创建时，线条上升，而在垃圾回收发生时，线条会急剧下降。尽管我们没有创建和销毁许多对象，但如果我们看到动画运行不流畅的问题，明显的迹象是我们可以考虑使用更多的对象池。
- en: The key to maintaining fast animations is to test and iterate. This is especially
    true when developing for mobile devices, where debugging tools are usually slightly
    harder to access and where memory and processing power are also usually less abundant.
    If you notice intermittent slowdowns and animation freezes that are difficult
    to reproduce, it’s likely that you have a memory issue to identify and address.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 保持快速动画的关键是进行测试和迭代。这对于移动设备开发尤其重要，因为移动设备上的调试工具通常更难访问，而且内存和处理能力通常也更有限。如果你注意到间歇性的减速和动画冻结，且这些问题难以重现，那很可能是你遇到了内存问题，需要进行排查和解决。
- en: '![Memory usage by Bubble Shooter](httpatomoreillycomsourcenostarchimages2184545.png.jpg)'
  id: totrans-121
  prefs: []
  type: TYPE_IMG
  zh: '![Bubble Shooter 的内存使用情况](httpatomoreillycomsourcenostarchimages2184545.png.jpg)'
- en: Figure 8-2. Memory usage by *Bubble Shooter*
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8-2. *Bubble Shooter* 的内存使用情况
- en: Optimizing for Speed
  id: totrans-123
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 优化速度
- en: Memory may or may not be an issue, depending on your game’s needs, and memory
    fixes occasionally require coding techniques somewhat at odds with writing readable,
    reusable code. However, optimizing for speed is more achievable as a side effect
    of following general best practices.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 内存是否成为问题，取决于你游戏的需求，而内存优化有时需要使用一些与编写可读、可复用代码相冲突的编码技巧。然而，通过遵循一般的最佳实践，优化速度通常会作为副作用自然实现。
- en: JavaScript engines are improving in speed all the time and so are browsers’
    rendering engines (especially with the addition of WebGL). But, as with garbage
    collection, you should still be aware of the pain points. The browser vendors
    won’t solve all your performance problems for you. In reality, JavaScript interpreters
    are becoming so fast that speed problems are more likely to occur while rendering
    than anywhere else; however, coding techniques can make the translation between
    JavaScript and machine code more efficient and speed up operations, such as passing
    image data to the rendering engine.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript 引擎的速度一直在不断提升，浏览器的渲染引擎也是如此（尤其是在添加了 WebGL 之后）。但是，与垃圾回收一样，你仍然需要意识到性能瓶颈。浏览器厂商不会为你解决所有的性能问题。实际上，JavaScript
    解释器变得如此快速，以至于性能问题更可能出现在渲染过程中，而不是其他地方；然而，编码技巧可以使 JavaScript 与机器码之间的转换更高效，从而加速操作，例如将图像数据传递给渲染引擎。
- en: Each time you add or change an element in the DOM, the browser has to work out
    what to draw and where to draw it. HTML documents were originally designed as
    flowing, text-based documents, and the browser will assume the content you send
    it is meant to be laid out like any other web page.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 每次你在 DOM 中添加或更改一个元素时，浏览器都需要计算出需要绘制什么内容以及绘制的位置。HTML 文档最初是作为流式的、基于文本的文档设计的，浏览器会假设你发送给它的内容应该像任何其他网页一样进行布局。
- en: But actions that cause the browser to repaint the display, such as adding new
    elements to the screen or changing an element’s coordinates, are very common in
    games. In *Bubble Shooter*, we can get away with adding and removing elements
    as we want because relatively few elements are onscreen. Multiply the number of
    items onscreen by 10 or 100, and you’ll start to see problems. Remember that the
    garbage collector needs to sweep away any element deleted from the scene, and
    DOM elements tend to be complex.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，导致浏览器重新绘制显示的操作，如向屏幕添加新元素或更改元素的坐标，在游戏中是非常常见的。在 *Bubble Shooter* 中，我们可以随意添加和移除元素，因为屏幕上的元素相对较少。当屏幕上的元素数量增加
    10 倍或 100 倍时，你会开始看到问题。记住，垃圾回收器需要清除任何从场景中删除的元素，而 DOM 元素通常是复杂的。
- en: By contrast, the canvas copes with graphical additions without an expensive
    paint operation because no reflowing occurs inside a `canvas` element. The browser
    considers `canvas` elements to be images, which are just streams of pixels that
    go from memory to screen.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 相比之下，`canvas` 元素在处理图形添加时没有昂贵的绘制操作，因为 `canvas` 内部不会发生重排。浏览器将 `canvas` 元素视为图像，这些图像只是从内存到屏幕的像素流。
- en: Note
  id: totrans-129
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '*Changing properties of the `canvas` element, such as its position or transparency,
    rather than pixels within it, is just as expensive as changing any other DOM element.*'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: '*更改 `canvas` 元素的属性，例如其位置或透明度，而不是其内部的像素，与更改其他 DOM 元素的代价相同。*'
- en: You can see how much time the browser spends painting a scene by loading *Bubble
    Shooter* in the Chrome desktop browser, pressing F12 to open Developer Tools,
    and navigating to the Timeline tab. Click **Record** in the bottom control bar,
    reload the game, and then click the **Events** bar at the top to see a view like
    [Figure 8-3](ch08.html#browser_events_involved_in_playing_bubbl "Figure 8-3. The
    browser events involved in playing Bubble Shooter in Chrome").
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过在 Chrome 桌面浏览器中加载 *Bubble Shooter*，按 F12 打开开发者工具，然后导航到时间轴标签页，来查看浏览器绘制场景所花费的时间。点击底部控制栏中的
    **记录**，重新加载游戏，然后点击顶部的 **事件** 栏，查看类似[图 8-3](ch08.html#browser_events_involved_in_playing_bubbl
    "图 8-3. 在 Chrome 中玩 Bubble Shooter 时涉及的浏览器事件")的视图。
- en: '![The browser events involved in playing Bubble Shooter in Chrome](httpatomoreillycomsourcenostarchimages2184547.png.jpg)'
  id: totrans-132
  prefs: []
  type: TYPE_IMG
  zh: '![在 Chrome 中玩 Bubble Shooter 的浏览器事件](httpatomoreillycomsourcenostarchimages2184547.png.jpg)'
- en: Figure 8-3. The browser events involved in playing *Bubble Shooter* in Chrome
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8-3. 在 Chrome 中玩 *Bubble Shooter* 时涉及的浏览器事件
- en: All of the paint events ➊, like those in [Figure 8-3](ch08.html#browser_events_involved_in_playing_bubbl
    "Figure 8-3. The browser events involved in playing Bubble Shooter in Chrome"),
    should be highlighted in green on your screen. In the canvas version of the game,
    a few paint calls occur once a level has been loaded, whereas in the CSS version,
    such calls occur constantly.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 所有的绘制事件 ➊，例如[图 8-3](ch08.html#browser_events_involved_in_playing_bubbl "图 8-3.
    在 Chrome 中玩 Bubble Shooter 时涉及的浏览器事件")中的那些，应该在屏幕上用绿色突出显示。在游戏的画布版本中，只有在加载完关卡后才会发生几次绘制调用，而在
    CSS 版本中，这些调用会不断发生。
- en: You can use the Timeline tool to identify when paint events happen and minimize
    them to speed up your game’s rendering. Just remember that different browsers
    may repaint the scene at different times. As always, use the tools available,
    but also test on your target platforms and devices as the main guide to performance.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用时间轴工具来识别绘制事件发生的时刻，并将其最小化以加速游戏的渲染。只需要记住，不同浏览器可能在不同的时间重新绘制场景。像往常一样，使用可用的工具，但也要在目标平台和设备上进行测试，将其作为性能的主要指导。
- en: In general, minimizing DOM manipulation is the key to minimizing paint operations.
    Search for articles on minimizing browser reflow and browser paint operations
    for more detailed and up-to-date information on the inner workings of rendering
    engines.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 一般来说，最小化 DOM 操作是减少绘制操作的关键。查找有关最小化浏览器重排和浏览器绘制操作的文章，获取有关渲染引擎内部工作原理的更详细和最新的信息。
- en: Security
  id: totrans-137
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 安全性
- en: 'If your game has any kind of scoring or progression system, someone will try
    to cheat it. But the key is to assess the ramifications of having cheats slip
    through the system and decide whether or not those ramifications are critical.
    For *Bubble Shooter*, this isn’t an issue: if someone wants to set a high score
    on their local machine, that’s up to them. However, for games with an online competitive
    element or where buying power-ups is a revenue stream, you need to ensure that
    cheating is difficult to impossible.'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你的游戏有任何类型的得分或进度系统，某人就会尝试作弊。但关键是评估作弊被系统突破的后果，并决定这些后果是否严重。对于 *Bubble Shooter*
    来说，这不是问题：如果有人想在他们本地的机器上设置一个高分，那是他们的事。然而，对于有在线竞争元素或购买增强道具作为收入来源的游戏，你需要确保作弊变得极其困难甚至不可能。
- en: We can try to address security in HTML5 games in a few ways.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过几种方式来解决 HTML5 游戏中的安全问题。
- en: Trust No One
  id: totrans-140
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 不信任任何人
- en: The simplistic approach to security in any games that run on the client, whether
    they’re built with HTML5, Flash, or even native code, is to not trust anything
    that the client sends to the server. A POST back to the server with, say, a high
    score value (as we used in the examples on AJAX and Web-Sockets) is easily forged.
    The score may be valid, the POST may be forged, or someone may even use a debugging
    tool to change the high score while the game runs. The server only sees the data
    as it’s received and can’t differentiate between a genuine and a cheat POST.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 任何在客户端运行的游戏，无论是使用 HTML5、Flash 还是原生代码构建的，其简化的安全处理方式就是不信任客户端发送给服务器的任何数据。例如，使用
    AJAX 和 Web-Sockets 示例中的高分值进行 POST 请求时，很容易被伪造。分数可能是有效的，但 POST 请求可能是伪造的，或者某人甚至可能使用调试工具在游戏运行时更改高分。服务器只看到接收到的数据，无法区分真实的请求和作弊请求。
- en: 'Unfortunately, not trusting the client is often the correct approach: there’s
    no way to completely guarantee the security of code running on the client. The
    only way to make a game secure is to have all game logic processed by the server.
    To completely secure *Bubble Shooter*, we’d pass mouse clicks to the server, have
    the collision and popping logic run on the server, and then pass the results back
    to the client to animate. This is more difficult to develop and test, and the
    user would need a constant (and fast) Internet connection to even play the game.'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，不信任客户端通常是正确的方法：没有办法完全保证在客户端运行的代码的安全性。确保游戏安全的唯一方法是让所有游戏逻辑都由服务器处理。为了完全保护*Bubble
    Shooter*，我们将鼠标点击传递给服务器，让碰撞和爆炸逻辑在服务器上运行，然后将结果传回客户端进行动画处理。这种方法开发和测试起来更为困难，并且用户需要一个持续（且快速）的互联网连接才能玩游戏。
- en: Obfuscation
  id: totrans-143
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 混淆
- en: The server-side approach is essential when a game includes financial transactions,
    but for many games, obfuscation is good enough. The idea behind obfuscation is
    to make cheating as difficult as possible, essentially making the effort involved
    greater than the reward. For example, if a high score is posted to the server
    as an encoded value, passed with a checksum, and takes hours of reading through
    code to decipher how it was created, cheaters are unlikely to go through all of
    that effort just to get to the top of a high score table.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 当游戏包含金融交易时，服务器端方法是必不可少的，但对于许多游戏来说，混淆已经足够好。混淆的理念是使作弊变得尽可能困难，基本上是让付出的努力超过得到的回报。例如，如果一个高分被作为编码值传送到服务器，附带一个校验和，并且需要花费数小时阅读代码才能破译它是如何生成的，作弊者不太可能付出所有的努力，仅仅是为了登上高分榜的顶部。
- en: Of course, obfuscation usually comes at the price of readability for you as
    well as hackers. But there are a number of ways to make code difficult to read,
    and you can even apply some as a post-build process.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，混淆通常会以牺牲可读性为代价，既对你，也对黑客来说。但有很多方法可以让代码变得难以阅读，你甚至可以在构建后处理过程中应用其中一些方法。
- en: 'The simplest option is running your code through a *minifier* before you package
    it for a live environment. Minifiers shorten all long variable names in your code
    and eliminate whitespace. For example, code such as this:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 最简单的选项是在你将代码打包到生产环境之前，使用一个*压缩工具*来处理代码。压缩工具会缩短代码中所有长变量名并去除空白符。例如，像这样的代码：
- en: '[PRE15]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'becomes something like this after minifying:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 压缩后变成类似这样的：
- en: '[PRE16]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Effectively, minifying removes the whitespace and puts everything onto one
    line. Such minified code quickly becomes difficult to read. You can easily un-minify
    the line breaks. Many minifiers will also rename variables inside functions. For
    example, this function:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 本质上，压缩会去除空白符并将所有内容放到一行上。压缩后的代码很快变得难以阅读。你可以轻松地将行 breaks 还原。许多压缩工具还会重命名函数内部的变量。例如，这个函数：
- en: '[PRE17]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'could become much smaller:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 可能会变得更小：
- en: '[PRE18]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: The property that you’ve been calling `highScore` in your code becomes much
    harder to find if it’s now called `a` instead!
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在代码中一直调用的 `highScore` 属性现在被叫做 `a`，那么它将变得更难以找到！
- en: Note
  id: totrans-155
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '*Minifying code also has the added advantage of creating smaller code that
    should therefore load faster, which is an important consideration when deploying
    in a web environment. In fact, you should consider minifying your JavaScript code
    in all web applications.*'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: '*压缩代码的额外好处是生成更小的代码，因此可以更快加载，这是在 Web 环境中部署时需要考虑的一个重要因素。实际上，你应该在所有 Web 应用程序中考虑压缩你的
    JavaScript 代码。*'
- en: Google released a tool called the Closure Compiler, which acts as a minifier
    along with providing a number of other benefits. It attempts to optimize code,
    even rewriting it in places, and outputs smaller and sometimes even faster code
    than the original version. The compiler generates JavaScript, analyzes your code,
    and raises errors. Declaring variables, keeping track of scope, and maintaining
    other good practices pay off when you use a minifier such as the Closure Compiler,
    because the compiler provides greater benefits the clearer and simpler your coding
    structure is.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: Google 发布了一个名为 Closure Compiler 的工具，它不仅作为一个压缩器，还提供了许多其他好处。它会尝试优化代码，甚至在某些地方重写代码，并输出比原始版本更小，有时甚至更快的代码。该编译器生成
    JavaScript，分析你的代码并抛出错误。在使用像 Closure Compiler 这样的压缩工具时，声明变量、跟踪作用域并保持其他良好实践会有所回报，因为代码结构越清晰简洁，编译器提供的好处就越大。
- en: You can use the Closure Compiler online or download and run the Java application
    from *[https://developers.google.com/closure/compiler/](https://developers.google.com/closure/compiler/)*.
    Once you have access to it, paste the Closure Compiler in the JavaScript code
    that you want to compile and then copy the output. It’s recommended that you keep
    a copy of your original code, because the compiler output is far too difficult
    to work with if you need to make further changes.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在线使用Closure Compiler，或者下载并运行来自*[https://developers.google.com/closure/compiler/](https://developers.google.com/closure/compiler/)*的Java应用程序。一旦你能够访问它，粘贴你想要编译的JavaScript代码，然后复制输出结果。建议你保留原始代码的副本，因为如果你需要进行进一步修改，编译器输出将非常难以处理。
- en: Using Private Variables
  id: totrans-159
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用私有变量
- en: 'Along with post-build processes, you can also code in ways that make it harder
    for cheaters to follow through code and change it on the fly. For example, private
    variables make manipulating internal values on the console more difficult. The
    following has a private variable for `highScore`:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 除了构建后处理之外，你还可以以更难让作弊者跟踪代码并即时更改它的方式进行编码。例如，私有变量使得在控制台上操纵内部值变得更加困难。以下代码使用了一个私有的`highScore`变量：
- en: '[PRE19]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'The variable is considered private because it only exists inside the scope
    of a `Game` object. We could have made the variable public as follows:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 该变量被视为私有的，因为它只存在于`Game`对象的作用域内。我们本可以将该变量公开，如下所示：
- en: '[PRE20]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: This would allow the value of `highScore` to be changed on a `Game` object just
    by changing the value of its `highScore` property. However, in the private version,
    there’s no way to access the value of `highScore` from outside the object.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 这样就可以通过仅更改`highScore`属性的值来改变`Game`对象中`highScore`的值。然而，在私有版本中，无法从外部访问`highScore`的值。
- en: If `highScore` is private, cheaters will have difficulty changing its value
    without using a program like Firebug to add a breakpoint within the object. They’ll
    have even more trouble if the code is minified and obfuscated. `highScore` is
    actually labeled `"a"`, and it’s difficult to even find where the high score is
    updated in the first place.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`highScore`是私有的，作弊者将很难在不使用Firebug等程序添加断点的情况下更改其值。如果代码被压缩和混淆，他们就会更难做到。`highScore`实际上被标记为`"a"`，而且很难找到第一次更新高分的地方。
- en: With a couple of relatively simple steps (making some variables private and
    minifying our code), we’ve already narrowed down the potential cheaters from those
    who know a small amount of JavaScript to those who know it quite well and are
    willing to take the time to reverse engineer our code. Now, let’s look at one
    more way to prevent cheating.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 通过几个相对简单的步骤（使一些变量私有并压缩我们的代码），我们已经将潜在的作弊者范围缩小到那些仅懂一些JavaScript的玩家与那些对JavaScript非常熟悉并愿意花时间逆向工程我们的代码的人之间。现在，让我们再看一种防止作弊的方法。
- en: Validating with Checksums
  id: totrans-167
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 验证校验和
- en: 'You can also secure information passed to the server by using checksums to
    validate the variable passed. The simplest techniques just encode a value so there
    is at least some check that the number is correct. This won’t eliminate cheating,
    and checksums don’t need to be very complicated, but it will ensure that anyone
    who wants to cheat needs to read and understand your JavaScript code first. For
    example, if we passed `highScore` to the server, we could POST something like
    this:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以通过使用校验和来验证传递给服务器的变量，从而保护信息。最简单的技术是对值进行编码，以便至少进行某些检查，确保数字是正确的。这不会消除作弊，校验和也不需要太复杂，但它会确保任何想作弊的人都需要先阅读并理解你的JavaScript代码。例如，如果我们将`highScore`传递给服务器，我们可能会POST类似这样的内容：
- en: '[PRE21]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: The value 21 is 9,825 modulus 129 (or `highScore%129` in code), where 129 is
    a number I chose as being big enough to create a range of check values but also
    being a factor smaller than likely high scores. This almost trivial check actually
    increases the level of security because now the barrier to posting a fake high
    score is not only knowing how to POST but also being able to follow through the
    code to the point where the `check` value is created. A seasoned JavaScript programmer
    might find those steps simple, but the average meddling game player probably won’t.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 数值21是9,825对129取模的结果（或在代码中表示为`highScore%129`），其中129是我选择的一个数字，足够大以创建一系列校验值，同时也小于可能的高分。这种几乎微不足道的检查实际上增加了安全性，因为现在发布虚假高分的障碍不仅是知道如何发布，还需要能够追踪代码，直到`check`值被创建。一个经验丰富的JavaScript程序员可能会觉得这些步骤很简单，但普通的游戏玩家可能就不那么容易了。
- en: The preceding example may be too trivial for your liking, and you can use any
    process you like for generating a checksum. Common approaches include using hash
    functions such as MD5, SHA, or CRC32, although the disadvantage of these is that
    programmers will often recognize the structure well enough to know they are looking
    at a standard hashing function.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的例子可能对你来说过于简单，你可以使用任何你喜欢的过程来生成校验和。常见的方法包括使用哈希函数，如MD5、SHA或CRC32，尽管这些方法的缺点是，程序员通常能很好地识别其结构，知道他们正在查看的是标准的哈希函数。
- en: In principle, any process you create that can generate a range of check values
    will significantly slow down, and possibly discourage, a large number of potential
    cheaters.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 原则上，你创建的任何可以生成一系列校验值的过程都会显著减慢速度，并可能劝阻大量潜在的作弊者。
- en: Of course, you may still get a few cheaters whatever you do, because some hackers
    enjoy the challenge of beating the programmer more than the challenge of beating
    the game. You can obfuscate as much as you like, and you may end up with code
    that’s almost impossible to read. But remember that you can never guarantee security
    in client-side code and never fully trust the information passed from the client
    to the server.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，不管你做什么，仍然可能会遇到一些作弊者，因为有些黑客喜欢击败程序员的挑战，胜过击败游戏的挑战。你可以尽可能地混淆代码，可能最终会得到几乎无法阅读的代码。但请记住，你永远无法保证客户端代码的安全性，也永远不要完全相信从客户端传递到服务器的信息。
- en: Summary
  id: totrans-174
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: As you may have gathered from this chapter, browser support for HTML5 is an
    ever-changing landscape. The good news is that browsers are generally converging
    on the same standard rather than adding their own features. Also, support for
    HTML5 is improving all the time.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你从本章中可能已经了解到的那样，浏览器对HTML5的支持是一个不断变化的领域。好消息是，浏览器通常趋向于统一标准，而不是增加自己的功能。同时，HTML5的支持也在不断改善。
- en: With the rate of change, it’s important to keep up-to-date on which browser
    features are ready for mainstream usage as well as what’s on the horizon. Whether
    in terms of improved performance, memory management, sound, or 3D features, the
    capabilities of HTML5 games are constantly advancing.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 随着变化速度的加快，保持对哪些浏览器功能已准备好进入主流使用以及未来可能出现的新功能的关注非常重要。无论是性能提升、内存管理、声音，还是3D功能，HTML5游戏的能力在不断进步。
- en: Further Practice
  id: totrans-177
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步练习
- en: Add fullscreen capability to *Bubble Shooter* in a desktop browser. To make
    the switch as easy as possible, add a button to the top bar that is visible only
    if fullscreen mode is supported. Also, change the CSS so that when the page is
    displayed fullscreen, the game is centered.
  id: totrans-178
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在桌面浏览器中为*Bubble Shooter*添加全屏功能。为了让切换尽可能简单，添加一个按钮到顶部栏，该按钮仅在支持全屏模式时才会显示。此外，修改CSS，使得页面在全屏显示时，游戏居中。
- en: Write a routine to post the player’s score to a fictional server address using
    jQuery’s `ajax` method. Post the score at the end of each level and write a checksum
    function to add basic security using your method of choice.
  id: totrans-179
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写一个例程，使用jQuery的`ajax`方法将玩家的分数发布到一个虚拟服务器地址。在每一关结束时发布分数，并编写一个校验和函数，使用你选择的方法增加基本的安全性。
- en: Find and test some online minifier and obfuscation services. Compare the file
    size of the output code to the size of the original source.
  id: totrans-180
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 查找并测试一些在线的压缩和混淆服务。比较输出代码的文件大小与原始源代码的大小。
