- en: '**14**'
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '**14**'
- en: '**MOBILE PRIVACY CONCERNS**'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: '**移动隐私问题**'
- en: People tend to carry location-aware mobile devices wherever they go, and they
    store tons of personal data on these devices, making privacy a constant concern
    in mobile security. Modern iOS devices allow applications (upon request) to read
    people’s location data, use the microphone, read contacts, access the M7 motion
    processor, and much more. Using these APIs responsibly not only is important to
    users but also can help reduce liability and increase the chances of the application
    being gracefully accepted into the App Store.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 人们往往随身携带具有定位功能的移动设备，并在这些设备上存储大量个人数据，这使得隐私成为移动安全中的一个持续关注点。现代 iOS 设备允许应用程序（经请求）读取用户的位置信息、使用麦克风、读取联系人、访问
    M7 运动处理器等。负责任地使用这些 API 对用户来说非常重要，也有助于减少责任风险，并增加应用被顺利接受进入 App Store 的可能性。
- en: I discussed a fair bit of privacy-related content in [Chapter 10](ch10.html#ch10);
    this was largely in regard to accidental data leakage. In this chapter, I’ll cover
    privacy issues that affect both users and app authors when intentionally gathering
    and monitoring user data, as well as mitigations for some potential pitfalls.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 我在[第十章](ch10.html#ch10)中讨论了很多与隐私相关的内容；这主要是关于意外的数据泄露。在本章中，我将讨论在故意收集和监控用户数据时，影响用户和应用作者的隐私问题，以及一些潜在陷阱的应对措施。
- en: '**Dangers of Unique Device Identifiers**'
  id: totrans-4
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**唯一设备标识符的危险**'
- en: iOS’s *unique device identifiers (UDIDs)* stand as something of a cautionary
    tale. For most of iOS’s history, the UDID was used to uniquely identify an individual
    iOS device, which many applications then used to track user activity or associate
    a user ID with particular hardware. Some companies used these identifiers as access
    tokens to remote services, which turned out to be a spectacularly bad idea.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: iOS 的 *唯一设备标识符 (UDID)* 是一个警示性的例子。在 iOS 的大多数历史时期，UDID 被用来唯一标识一台 iOS 设备，许多应用程序随后使用该标识符来追踪用户活动或将用户
    ID 与特定硬件关联。许多公司将这些标识符用作远程服务的访问令牌，结果证明这是一个极其糟糕的想法。
- en: Because many organizations were in possession of a device’s UDID and because
    UDIDs weren’t considered sensitive, companies that did use the UDID effectively
    as an authenticator were suddenly in a situation where thousands of third parties
    had their users’ credentials. Software developers also widely assumed that the
    UDID was immutable, but tools had long been available to spoof UDIDs, either globally
    or to a specific application.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 由于许多组织拥有设备的 UDID，而 UDID 又不被认为是敏感信息，因此那些确实将 UDID 用作身份验证工具的公司，突然间面临一个局面——数千个第三方拥有了其用户的凭证。软件开发者还普遍认为
    UDID 是不可变的，但早已有工具能够伪造 UDID，无论是全局伪造还是针对特定应用。
- en: '***Solutions from Apple***'
  id: totrans-7
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***来自苹果的解决方案***'
- en: As a result of those issues, Apple now rejects newly submitted applications
    that use the `uniqueIdentifier` API, directing developers to instead use the `identifierForVendor`
    API. This API returns an instance of the `NSUUID` class. The `identifierForVendor`
    mechanism should return the same UUID for all applications written by the same
    vendor on an iOS device, and that UUID will be backed up and restored via iTunes.
    It is not immutable, however, and can be reset by the user.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这些问题，苹果现在拒绝新提交的使用 `uniqueIdentifier` API 的应用，并建议开发者改用 `identifierForVendor`
    API。该 API 返回一个 `NSUUID` 类的实例。`identifierForVendor` 机制应当为同一 iOS 设备上的同一供应商开发的所有应用返回相同的
    UUID，且该 UUID 将通过 iTunes 进行备份和恢复。然而，它并非不可变的，用户可以重置它。
- en: Older applications in the App Store that use `uniqueIdentifier` are returned
    a string starting with `FFFFFFFF`, followed by the string normally returned by
    `identifierForVendor`. Similarly, applications using `gethostuuid` are now rejected
    from the App Store, and existing apps receive the `identifierForVendor` value
    when calling this function.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 在 App Store 中，使用 `uniqueIdentifier` 的旧版应用会返回以 `FFFFFFFF` 开头的字符串，后跟通常由 `identifierForVendor`
    返回的字符串。同样，使用 `gethostuuid` 的应用现在会被拒绝上架 App Store，现有应用在调用此功能时会返回 `identifierForVendor`
    值。
- en: Applications that use the `NET_RT_IFLIST` sysctl or the `SIOCGIFCONF` ioctl
    to read the device’s MAC address now receive `02:00:00:00:00:00` instead. Of course,
    using a MAC address as any kind of token or authenticator has always been a terrible
    idea; MAC addresses leak over every network you connect to, and they’re easy to
    change. The nonspecific return value appropriately punishes developers who have
    taken this approach.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`NET_RT_IFLIST` sysctl或`SIOCGIFCONF` ioctl读取设备MAC地址的应用程序现在会收到`02:00:00:00:00:00`。当然，使用MAC地址作为任何类型的令牌或认证器一直是个糟糕的主意；MAC地址会在你连接的每个网络中泄露，而且它们很容易被更改。这种不具体的返回值适当地惩罚了那些采取这种方法的开发人员。
- en: For advertising and tracking purposes, Apple introduced the property `advertisingIdentifier`
    of the `ASIdentifierManager` class. This property returns an NSUUID that is available
    to all application vendors, but like `uniqueIdentifier`, that NSUUID can be wiped
    or changed (as shown in [Figure 14-1](ch14.html#ch14fig1)).
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 为了进行广告和追踪，苹果引入了`ASIdentifierManager`类的`advertisingIdentifier`属性。该属性返回一个NSUUID，所有应用程序开发者都可以使用，但像`uniqueIdentifier`一样，这个NSUUID可以被擦除或更改（如[图14-1](ch14.html#ch14fig1)所示）。
- en: '![image](graphics/f14-01.jpg)'
  id: totrans-12
  prefs: []
  type: TYPE_IMG
  zh: '![image](graphics/f14-01.jpg)'
- en: '*Figure 14-1: The user interface for indicating that the* `advertisingIdentifier`
    *should be used for limited purposes*'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: '*图14-1：指示* `advertisingIdentifier` *仅应用于有限目的的用户界面*'
- en: The difference between this system and the original `uniqueIdentifier` API is
    that `advertisingIdentifier` is explicitly
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 这个系统与原始的`uniqueIdentifier` API的区别在于，`advertisingIdentifier`是显式的。
- en: • only for advertising and tracking;
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: • 仅用于广告和追踪；
- en: • not immutable; and
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: • 不是不可变的；并且
- en: • subject to user preferences.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: • 受用户偏好设置的影响。
- en: These aspects of `advertisingIdentifier` ostensibly give the user control over
    what tracking advertisers are allowed to use the mechanism for. Apple states that
    an application must check the value of `advertisingTrackingEnabled`, and if set
    to `NO`, the identifier can be used only for “frequency capping, conversion events,
    estimating the number of unique users, security and fraud detection, and debugging.”^([1](footnote.html#fn119))
    Unfortunately, that list could encompass pretty much anything advertisers want
    to do with the `advertisingIdentifier`.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: '`advertisingIdentifier`的这些方面表面上赋予了用户对广告商使用该机制的跟踪控制权。苹果表示，应用程序必须检查`advertisingTrackingEnabled`的值，如果设置为`NO`，该标识符只能用于“频率限制、转化事件、估算唯一用户数量、安全和欺诈检测以及调试。”^([1](footnote.html#fn119))
    不幸的是，这个列表几乎可以涵盖广告商希望对`advertisingIdentifier`做的任何事情。'
- en: You can determine the value of `advertisingTrackingEnabled` as shown in [Listing
    14-1](ch14.html#ch14ex1).
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过[列表14-1](ch14.html#ch14ex1)中的方式来确定`advertisingTrackingEnabled`的值。
- en: '[PRE0]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '*Listing 14-1: Determining whether limited ad tracking is enabled and fetching
    the* `advertisingIdentifier`'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表14-1：确定是否启用了有限广告追踪并获取* `advertisingIdentifier`'
- en: The call to `advertisingTrackingEnabled` at ➊ reads the user preference for
    the advertising tracking ID before reading the `advertisingIdentifier` itself
    at ➋.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 在➊调用`advertisingTrackingEnabled`时，它会读取用户的广告追踪ID的偏好设置，然后在➋读取`advertisingIdentifier`本身。
- en: '***Rules for Working with Unique Identifiers***'
  id: totrans-23
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***处理唯一标识符的规则***'
- en: There are a few general rules to follow when working with unique identifiers
    of any type. First, never assume identifiers are immutable. Any identifier supplied
    by the device can be changed by someone in physical possession of the device.
    Second, never assume a 1:1 relationship between devices and identifiers. Identifiers
    can be moved from one device to another and as such cannot be trusted to uniquely
    identify a single device. Because identifiers can change, aren’t unique, and may
    be widely distributed, you also shouldn’t use them to authenticate users. Finally,
    keep identifiers as anonymous as possible. They might be useful for tracking general
    trends in user behavior, but don’t tie an identifier to a user identity unless
    there’s a compelling need to do so.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 在处理任何类型的唯一标识符时，有几个基本规则需要遵循。首先，永远不要假设标识符是不可变的。任何设备提供的标识符都可以被持有设备的人更改。其次，永远不要假设设备和标识符之间有1:1的关系。标识符可以从一个设备转移到另一个设备，因此不能依赖它们唯一地标识单个设备。因为标识符可能会更改、并非唯一且可能被广泛分发，所以你也不应该使用它们来认证用户。最后，尽可能保持标识符的匿名性。它们可能对追踪用户行为的总体趋势有用，但除非有充分的理由，否则不要将标识符与用户身份绑定。
- en: '**Mobile Safari and the Do Not Track Header**'
  id: totrans-25
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**移动Safari和“请勿追踪”头部**'
- en: Starting with iOS 6, Mobile Safari includes the option to enable the Do Not
    Track mechanism,^([2](footnote.html#fn120)) which tells the remote server that
    the user wants to opt out of being tracked by certain parties. This option is
    expressed with the `HTTP_DNT` header. When set to 1, the header indicates that
    the user consents to being tracked only by the site that is currently being visited.
    When set to 0, it indicates that the user doesn’t want to be tracked by any party.
    Users can enable this mode in the Safari settings ([Figure 14-2](ch14.html#ch14fig2)).
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 从 iOS 6 开始，Mobile Safari 包含启用 Do Not Track 机制的选项，^([2](footnote.html#fn120))
    该选项通知远程服务器用户希望选择退出某些方的跟踪。该选项通过 `HTTP_DNT` 头部表示。当设置为 1 时，表示用户同意仅被当前访问的网站跟踪；当设置为
    0 时，表示用户不希望任何方进行跟踪。用户可以在 Safari 设置中启用此模式（[图 14-2](ch14.html#ch14fig2)）。
- en: '![image](graphics/f14-02.jpg)'
  id: totrans-27
  prefs: []
  type: TYPE_IMG
  zh: '![image](graphics/f14-02.jpg)'
- en: '*Figure 14-2: The user interface for enabling Do Not Track*'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 14-2：启用 Do Not Track 的用户界面*'
- en: At a minimum, it makes sense to assume that users want to protect details of
    their activity from third-party advertisers or analytics firms. This is the behavior
    specified by an `HTTP_DNT` value of 1, which is the header that iOS sends by default.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 至少可以合理假设，用户希望保护其活动细节，免受第三方广告商或分析公司的侵犯。这是由 `HTTP_DNT` 值为 1 指定的行为，即 iOS 默认发送的头部。
- en: 'But the definition of tracking varies. The specification for the Do Not Track
    mechanism itself notes the following:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，跟踪的定义各不相同。Do Not Track 机制本身的规范指出了以下内容：
- en: The WG has not come to consensus regarding the definition of tracking and the
    scope of DNT. As such, a site cannot actually say with any confidence whether
    or not it is tracking, let alone describe the finer details in a tracking status
    resource.^([3](footnote.html#fn121))
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 工作组尚未就跟踪的定义和 DNT 的范围达成共识。因此，一个站点实际上无法自信地说是否在进行跟踪，更不用说描述跟踪状态资源中的详细内容了。^([3](footnote.html#fn121))
- en: According to the specification, websites can prompt the user to opt into specific
    tracking scenarios using the `storeSiteSpecificTrackingException` JavaScript API,
    but this functionality is not widely implemented at the time of this writing.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 根据规范，网站可以使用 `storeSiteSpecificTrackingException` JavaScript API 提示用户选择参与特定的跟踪场景，但在本文撰写时，这一功能尚未广泛实现。
- en: '**Cookie Acceptance Policy**'
  id: totrans-33
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**Cookie 接受政策**'
- en: Cookies on iOS are managed via the `NSHTTPCookieStorage` API. The method `sharedHTTPCookieStorage`
    returns the cookie store, but despite the method’s name, iOS cookie storage is
    specific to each application. Cookies actually live in a database under the application
    main bundle directory.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: iOS 上的 cookies 通过 `NSHTTPCookieStorage` API 进行管理。`sharedHTTPCookieStorage` 方法返回
    cookie 存储，但尽管该方法的名称如此，iOS 的 cookie 存储是针对每个应用特定的。cookies 实际存储在应用程序主包目录下的一个数据库中。
- en: '**NOTE**'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*The name* `*sharedHTTPCookieStorage*` *originates from OS X, where the OS
    uses a global cookie store shared among all applications.*'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: '*名称* `*sharedHTTPCookieStorage*` *源自 OS X，操作系统使用一个全局 cookie 存储库，所有应用都可以共享。*'
- en: 'Cookies used by the URL loading system are accepted according to a systemwide
    shared `cookieAcceptPolicy`, which any application can specify. This policy can
    be set to any of the following:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: URL 加载系统使用的 cookies 会根据系统范围内共享的 `cookieAcceptPolicy` 来接受，任何应用都可以指定此政策。此政策可以设置为以下任意一种：
- en: '`**NSHTTPCookieAcceptPolicyAlways**` Accept and store all received cookies.
    This is the default.'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: '`**NSHTTPCookieAcceptPolicyAlways**` 接受并存储所有接收到的 cookie。这是默认设置。'
- en: '`**NSHTTPCookieAcceptPolicyOnlyFromMainDocumentDomain**` Accept only first-party
    cookies.'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: '`**NSHTTPCookieAcceptPolicyOnlyFromMainDocumentDomain**` 仅接受第一方 cookies。'
- en: '`**NSHTTPCookieAcceptPolicyNever**` Never accept cookies.'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: '`**NSHTTPCookieAcceptPolicyNever**` 永不接受 cookies。'
- en: Note that on devices running anything older than iOS 7, the cookie acceptance
    policy is shared among applications, which could cause problems for your application.
    On such devices, when another running application changes its acceptance policy,
    your app’s policy changes as well. For example, an application that relies on
    third-party cookies for advertising revenue might repeatedly set its cookie policy
    to `NSHTTPCookieAcceptPolicyAlways`, changing yours to the same policy in the
    process.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，在运行任何低于 iOS 7 的设备上，cookie 接受政策是应用之间共享的，这可能会导致您的应用出现问题。在这些设备上，当另一个正在运行的应用改变其接受政策时，您的应用的政策也会随之改变。例如，依赖第三方
    cookie 进行广告收入的应用，可能会反复将其 cookie 政策设置为`NSHTTPCookieAcceptPolicyAlways`，并在此过程中将您的政策更改为相同的政策。
- en: Fortunately, you can specify your preferred `cookieAcceptPolicy` using events
    such as `didFinishLaunchingWithOptions`, and you can monitor for changes to the
    cookie acceptance policy while your program is running, as shown in [Listing 14-2](ch14.html#ch14ex2).
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，你可以使用像 `didFinishLaunchingWithOptions` 这样的事件来指定首选的 `cookieAcceptPolicy`，并在程序运行时监控
    cookie 接受政策的变化，如[列表 14-2](ch14.html#ch14ex2)所示。
- en: '[PRE1]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '*Listing 14-2: Registering to receive notifications when the cookie acceptance
    policy changes*'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 14-2：注册接收当 cookie 接受政策变化时的通知*'
- en: '[Listing 14-2](ch14.html#ch14ex2) registers an `NSNotificationCenter` at ➊,
    which listens for `NSHTTPCookieManagerAcceptPolicyChangedNotification`. If the
    policy changes, the selector identified at ➊, `cookieNotificationHandler`, will
    be called. In the `cookieNotificationHandler`, you set the policy to `NSHTTPCookieAcceptPolicyOnlyFromMainDocumentDomain`
    at ➋.'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: '[列表 14-2](ch14.html#ch14ex2)在 ➊ 注册一个 `NSNotificationCenter`，它监听 `NSHTTPCookieManagerAcceptPolicyChangedNotification`。如果政策发生变化，在
    ➊ 中标识的选择器 `cookieNotificationHandler` 将被调用。在 `cookieNotificationHandler` 中，你将在
    ➋ 设置政策为 `NSHTTPCookieAcceptPolicyOnlyFromMainDocumentDomain`。'
- en: In iOS 7 and later, changes in cookie management policy affect only the running
    application. Applications can also specify different cookie management policies
    for different HTTP sessions via `NSURLSession`. For more on this, see “[Using
    NSURLSession](ch07.html#ch07lev1sec02)” on [page 117](ch07.html#page_117).
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 在 iOS 7 及更高版本中，cookie 管理政策的变化只影响正在运行的应用程序。应用程序还可以通过 `NSURLSession` 为不同的 HTTP
    会话指定不同的 cookie 管理政策。有关更多信息，请参见 [“使用 NSURLSession”](ch07.html#ch07lev1sec02)，见[第
    117 页](ch07.html#page_117)。
- en: '**Monitoring Location and Movement**'
  id: totrans-47
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**监控位置和运动**'
- en: One of the most useful features of mobile platforms is their ability to make
    information and functionality relevant to a user’s current physical location and
    method of movement. iOS devices primarily determine location based on Wi-Fi and
    GPS, and they monitor body movement with the M7 motion processor.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 移动平台的最有用的功能之一是能够根据用户当前的物理位置和运动方式提供相关的信息和功能。iOS 设备主要通过 Wi-Fi 和 GPS 确定位置，并通过 M7
    运动处理器监控身体运动。
- en: Gathering location and movement data has dangers, however. In this section,
    I’ll discuss how gathering both types of data works and why you should take care
    when storing such information.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 获取位置和运动数据是有风险的。不过，在这一部分，我将讨论获取这两种数据是如何运作的，以及为什么你在存储此类信息时需要小心。
- en: '***How Geolocation Works***'
  id: totrans-50
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***地理定位如何工作***'
- en: Wi-Fi geolocation scans for available wireless access points and queries a database
    that has a record of access points and their GPS coordinates. These databases
    are built by third parties that effectively wardrive entire cities and note the
    coordinates of each discovered access point. Of course, this can result in inaccurate
    results in some circumstances. For example, if someone travels with network equipment,
    or relocates it, the location data may not get updated for some time.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: Wi-Fi 地理定位扫描可用的无线接入点，并查询一个包含接入点及其 GPS 坐标的数据库。这些数据库由第三方构建，第三方有效地进行“驾车探测”整个城市，并记录每个发现的接入点的坐标。当然，在某些情况下，这可能会导致不准确的结果。例如，如果有人携带网络设备旅行或重新安置设备，位置数据可能一段时间内没有更新。
- en: GPS can provide more specific navigation information, as well as motion information,
    to track users in transit. This requires the ability to contact GPS satellites,
    which is not always possible, so GPS is often used as a fallback or when a high
    degree of accuracy is required. GPS is also required to determine information
    such as speed or altitude.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: GPS 能够提供更具体的导航信息，以及运动信息，以追踪用户的移动。这需要能够与 GPS 卫星进行联系，但并非总是可行，因此 GPS 经常作为备用，或者在需要高精度时使用。GPS
    还被用于确定速度或海拔等信息。
- en: '***The Risks of Storing Location Data***'
  id: totrans-53
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***存储位置数据的风险***'
- en: 'Few aspects of mobile privacy have generated as much negative press as tracking
    users via geolocation data. While useful for an array of location-aware services,
    a number of issues arise when location data is recorded and stored over time.
    Most obvious are privacy concerns: users may object to their location data being
    stored long-term and correlated with other personal information.^([4](footnote.html#fn122))
    Aside from PR concerns, some European countries have strict privacy and data protection
    laws, which must be taken into account.'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 在移动隐私方面，极少有问题像通过定位数据追踪用户一样引发如此多的负面报道。虽然地理位置数据对于各种位置感知服务非常有用，但当定位数据被记录和存储一段时间后，许多问题会随之而来。最明显的就是隐私问题：用户可能会反对他们的定位数据被长期存储并与其他个人信息关联。^([4](footnote.html#fn122))
    除了公关问题外，一些欧洲国家有严格的隐私和数据保护法律，必须考虑到这些法律。
- en: A less obvious problem is that storing location data linked to specific users
    could leave you legally vulnerable. When you store location data along with data
    that links it to a specific individual, that data could be subpoenaed by law enforcement
    or litigators. This often occurs in divorce cases, where lawyers attempt to demonstrate
    infidelity by showing the physical comings and goings of one of the parties in
    the course of a relationship; toll authorities that use electronic tracking have
    had to respond to these inquiries for years.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 一个不太明显的问题是，存储与特定用户关联的定位数据可能会使你在法律上处于不利地位。当你将定位数据与可以将其链接到特定个人的数据存储在一起时，这些数据可能会被执法机关或诉讼方传唤。这种情况经常出现在离婚案件中，律师们试图通过展示某一方在关系中的身体出入来证明不忠；长期以来，使用电子追踪的收费公路管理部门不得不应对这些调查。
- en: '***Restricting Location Accuracy***'
  id: totrans-56
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***限制定位精度***'
- en: 'Because precise historical location data raises such privacy and liability
    concerns, it’s important to use the least degree of accuracy necessary for your
    intended purpose. For example, if your application is designed to determine what
    city or neighborhood a user is in for the purpose of making a dinner reservation,
    you’ll only need to get a user’s location within a kilometer or so. If your purpose
    is to find the nearest ATM to a user, you’ll want to use something significantly
    narrower. The following are the geolocation accuracy constants available via the
    Core Location API:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 由于精确的历史定位数据会引发隐私和法律责任的担忧，因此重要的是只使用满足目的的最低精度。例如，如果你的应用程序旨在确定用户所在的城市或社区，以便进行晚餐预订，你只需要获得用户大约一公里范围内的位置。如果你的目的是找到离用户最近的ATM机，你将需要使用更窄的范围。以下是通过Core
    Location API提供的定位精度常量：
- en: • `kCLLocationAccuracyBestForNavigation`
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: • `kCLLocationAccuracyBestForNavigation`
- en: • `kCLLocationAccuracyBest`
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: • `kCLLocationAccuracyBest`
- en: • `kCLLocationAccuracyNearestTenMeters`
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: • `kCLLocationAccuracyNearestTenMeters`
- en: • `kCLLocationAccuracyHundredMeters`
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: • `kCLLocationAccuracyHundredMeters`
- en: • `kCLLocationAccuracyKilometer`
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: • `kCLLocationAccuracyKilometer`
- en: • `kCLLocationAccuracyThreeKilometers`
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: • `kCLLocationAccuracyThreeKilometers`
- en: Restricting location accuracy to the least degree necessary is not only a best
    practice for privacy and legal reasons but also reduces power consumption. This
    is because less accurate methods use the rather quick Wi-Fi detection mechanisms
    and update less frequently, while the highest accuracy settings will often use
    GPS and update frequently.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 将定位精度限制在必要的最小程度不仅是出于隐私和法律原因的最佳实践，而且还可以减少电池消耗。这是因为较低精度的方法使用相对快速的Wi-Fi检测机制，并且更新频率较低，而最高精度设置通常会使用GPS并频繁更新。
- en: If you do need to store multiple instances of a user’s location over time, ensure
    that procedures are in place to prune this data eventually. For instance, if you
    need to reference only a month’s worth of location data at a time, ensure that
    older data is properly sanitized or erased. If you’re using location data for
    analytics that don’t require linking to a specific user, omit or remove any data
    that uniquely identifies the user.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 如果确实需要随着时间存储用户的多次定位数据，确保有适当的程序来最终修剪这些数据。例如，如果你只需要参考一个月的定位数据，确保旧数据已被妥善清理或删除。如果你使用定位数据进行分析，而这些分析不需要与特定用户关联，应该省略或删除任何唯一标识用户的数据。
- en: '***Requesting Location Data***'
  id: totrans-66
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***请求定位数据***'
- en: Permission data is requested using `CLLocationManager`, which specifies an accuracy
    constant as well as whether your app needs location data when it’s backgrounded.
    [Listing 14-3](ch14.html#ch14ex3) shows an example invocation.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 定位数据的请求是通过`CLLocationManager`来完成的，该工具指定了精度常量，并且可以设置当应用程序处于后台时是否需要定位数据。[示例 14-3](ch14.html#ch14ex3)展示了一个调用示例。
- en: '[PRE2]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '*Listing 14-3: Requesting location data permissions*'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 14-3：请求位置数据权限*'
- en: Here, a `CLLocationManager` is allocated ➊ and its delegate is set to `self`
    ➋. Then the desired accuracy of about 100 meters is set at ➌. At ➍, the permission
    request is sent, which will cause the authorization prompt to appear to the user.
    Finally, at ➎, there’s a request for the manager to start monitoring the user’s
    location.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，首先分配一个 `CLLocationManager` ➊，并将其代理设置为 `self` ➋。然后设置约 100 米的期望精度 ➌。接着在 ➍
    发送权限请求，这会导致向用户显示授权提示。最后，在 ➎，请求管理器开始监控用户的位置。
- en: Note that as of iOS 8, the location manager won’t actually start unless you
    have a description of why you need location data. This is specified in your *Info.plist*
    file, using either `NSLocationWhenInUseUsageDescription` if you need to access
    location data only when the app is in use or `NSLocationAlwaysUsageDescription`
    if you’ll also need to get location information from the background. Add one of
    these to your plist file, along with a concise but specific rationale to be displayed
    to the user when they’re prompted to grant permission to location data.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，从 iOS 8 开始，位置管理器实际上不会启动，除非你提供为什么需要位置数据的描述。这个描述在你的 *Info.plist* 文件中指定，如果你只需要在应用程序使用时访问位置数据，则使用
    `NSLocationWhenInUseUsageDescription`，如果你还需要从后台获取位置信息，则使用 `NSLocationAlwaysUsageDescription`。将其中之一添加到你的
    plist 文件中，并提供简明但具体的理由，以便在提示用户授予位置数据权限时显示给他们。
- en: '**Managing Health and Motion Information**'
  id: totrans-72
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**管理健康和运动信息**'
- en: Some of the most sensitive information that applications can handle is health
    information about the user. On iOS, this data can be retrieved using the HealthKit
    API and the APIs provided by the device’s M7 motion processor, if it has one.
    You’ll take a brief look at how to read and write this data and how to request
    the minimum privileges necessary for an app to function.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序可以处理的最敏感信息之一就是用户的健康信息。在 iOS 上，可以使用 HealthKit API 和设备的 M7 运动处理器提供的 API（如果有的话）来检索这些数据。你将简要了解如何读取和写入这些数据，以及如何请求应用程序正常运行所需的最小权限。
- en: '**NOTE**'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*As of iOS 9, HealthKit is available only on iPhones, not on iPads.*'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: '*从 iOS 9 开始，HealthKit 仅在 iPhone 上可用，iPad 上不可用。*'
- en: '***Reading and Writing Data from HealthKit***'
  id: totrans-76
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***从 HealthKit 读取和写入数据***'
- en: HealthKit information can be requested either for reading or for both reading
    and writing (somewhat confusingly called *sharing* by Apple). In keeping with
    requesting only the permissions that are absolutely necessary, request read-only
    access if possible. [Listing 14-4](ch14.html#ch14ex4) shows how permissions for
    specific health data are requested.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 可以请求 HealthKit 信息用于读取或同时用于读取和写入（Apple 称之为*共享*，有些令人困惑）。根据只请求绝对必要的权限的原则，如果可能的话，请请求只读访问权限。[清单
    14-4](ch14.html#ch14ex4) 显示了如何请求特定健康数据的权限。
- en: '[PRE3]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '*Listing 14-4: Requesting health data permissions*'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 14-4：请求健康数据权限*'
- en: At ➊ and ➋, you specify two types of data that you’d like to access, namely,
    heart rate and date of birth. At ➌, you request authorization to access these,
    with a `completion` block to handle success or failure. Note that the `requestAuthorizationToShareTypes`
    is requesting read/write access, presumably because this application is intended
    to track and record the user’s heart rate. The `readTypes` parameter specifies
    that you want to monitor the user’s heart rate but not write to it. In this case,
    you’re requesting the user’s date of birth (something rather unlikely to change)
    to infer their age. Finally, to allow you to distribute the application, you’ll
    need to enable the HealthKit entitlement in Xcode, as shown in [Figure 14-3](ch14.html#ch14fig3).
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 在 ➊ 和 ➋，你指定了两种你希望访问的数据类型，即心率和出生日期。 在 ➌，你请求授权访问这些数据，并提供一个 `completion` 块来处理成功或失败。请注意，`requestAuthorizationToShareTypes`
    正在请求读写访问权限，推测这是因为该应用程序旨在跟踪和记录用户的心率。`readTypes` 参数指定你希望监控用户的心率，但不进行写入操作。在这种情况下，你请求用户的出生日期（这通常不太可能改变）来推断他们的年龄。最后，为了让你能够分发该应用程序，你需要在
    Xcode 中启用 HealthKit 权限，如 [图 14-3](ch14.html#ch14fig3) 所示。
- en: While HealthKit shows how to record steps, but there are more detailed ways
    to get motion data to help guess exactly what kind of activity the user is engaged
    in. This more detailed data can be retrieved using the M7 motion tracker.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然 HealthKit 展示了如何记录步数，但还有更详细的方法可以获取运动数据，以帮助猜测用户到底在进行哪种活动。这些更详细的数据可以通过 M7 运动追踪器来获取。
- en: '![image](graphics/f14-03.jpg)'
  id: totrans-82
  prefs: []
  type: TYPE_IMG
  zh: '![image](graphics/f14-03.jpg)'
- en: '*Figure 14-3: Enabling the HealthKit entitlement in Xcode*'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 14-3：在 Xcode 中启用 HealthKit 权限*'
- en: '***The M7 Motion Processor***'
  id: totrans-84
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***M7 运动处理器***'
- en: 'The iPhone 5s introduced the M7 motion-tracking processor, which allows for
    the recording of detailed information about small movements while reducing the
    battery drain that this has incurred in the past. Fitness applications could use
    this data to determine the type of physical activity the user is currently engaging
    in and how many steps they’ve taken. Applications that monitor sleep quality could
    also take advantage of this to determine how deep the user is sleeping based upon
    slight movements. Obviously, the ability to determine when a user is asleep and
    what they’re doing outside of using the phone is a significant responsibility.
    Apple details the degree to which users can be tracked via the M7 as follows:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: iPhone 5s 引入了 M7 运动追踪处理器，可以记录关于微小运动的详细信息，同时减少了过去所造成的电池消耗。健身应用可以利用这些数据来确定用户当前进行的运动类型以及他们走了多少步。监控睡眠质量的应用也可以利用这些数据，基于细微的运动判断用户的睡眠深度。显然，能够判断用户何时入睡以及他们在使用手机之外的活动是一项重大责任。Apple
    详细说明了 M7 在跟踪用户时的程度如下：
- en: M7 knows when you’re walking, running, or even driving. For example, Maps switches
    from driving to walking turn-by-turn navigation if, say, you park and continue
    on foot. Since M7 can tell when you’re in a moving vehicle, iPhone 5s won’t ask
    you to join Wi-Fi networks you pass by. And if your phone hasn’t moved for a while,
    like when you’re asleep, M7 reduces network pinging to spare your battery.^([5](footnote.html#fn123))
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: M7 知道你何时在走路、跑步，甚至是开车。例如，当你停车并继续步行时，地图会自动从驾驶模式切换到步行的逐向导航。由于 M7 能够识别你是否在移动的车辆中，iPhone
    5s 不会要求你连接经过的 Wi-Fi 网络。如果你的手机长时间未移动，例如当你在睡觉时，M7 会减少网络请求以节省电池。^([5](footnote.html#fn123))
- en: 'Use of the M7 processor is granted in a manner similar to basic geolocation
    permissions. But M7 has a quirk not present in other geolocation data access:
    applications have access to data that was recorded before they were granted permission
    to access location data. If you’re going to use this historic data, inform the
    user in your permissions message and, ideally, give them a choice as to whether
    to use or disregard this data.'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: M7 处理器的使用方式与基本的地理位置权限相似。但 M7 有一个其他地理位置数据访问中不存在的特殊情况：应用在被授权访问位置信息之前，仍然可以访问已经记录的数据。如果你打算使用这些历史数据，请在权限提示中告知用户，并最好让他们选择是否使用或忽略这些数据。
- en: '**Requesting Permission to Collect Data**'
  id: totrans-88
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**请求数据收集权限**'
- en: When attempting to access sensitive data such as a user’s contacts, calendar,
    reminders, microphone, or motion data, the user will be prompted with an alert
    to grant or deny this access. To ensure that the user is presented with useful
    information as to why you need this access, define strings to be delivered to
    the user as part of the access prompt. Make these explanations simple but descriptive,
    as in [Figure 14-4](ch14.html#ch14fig4).
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 当尝试访问敏感数据，如用户的联系人、日历、提醒事项、麦克风或运动数据时，用户将会收到一个提示，要求授予或拒绝此访问权限。为了确保用户了解你需要这些访问权限的原因，请定义一段文字，在访问提示中向用户展示。确保这些解释简洁而描述性，如[图
    14-4](ch14.html#ch14fig4)所示。
- en: '![image](graphics/f14-04.jpg)'
  id: totrans-90
  prefs: []
  type: TYPE_IMG
  zh: '![image](graphics/f14-04.jpg)'
- en: '*Figure 14-4: Delivering the request to the user*'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 14-4：向用户发送请求*'
- en: You can set those messages in your app’s *Info.plist* file through Xcode, shown
    in [Figure 14-5](ch14.html#ch14fig5).
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过 Xcode 在应用的 *Info.plist* 文件中设置这些消息，如[图 14-5](ch14.html#ch14fig5)所示。
- en: '![image](graphics/f14-05.jpg)'
  id: totrans-93
  prefs: []
  type: TYPE_IMG
  zh: '![image](graphics/f14-05.jpg)'
- en: '*Figure 14-5: Describing needs for various kinds of access in an* Info.plist'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 14-5：描述在 Info.plist 中请求不同类型访问权限*'
- en: Additionally, ensure that your application handles the refusal of these permissions
    gracefully. Unlike Android, where permission granting is an all-or-nothing affair,
    iOS applications are expected by Apple to be able to handle having some permissions
    granted and others refused.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，确保你的应用能够优雅地处理拒绝这些权限的情况。与 Android 不同，Android 的权限授予是全有或全无的，而 Apple 期望 iOS 应用能够处理某些权限被授予而其他权限被拒绝的情况。
- en: '**Proximity Tracking with iBeacons**'
  id: totrans-96
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**使用 iBeacons 进行定位追踪**'
- en: Apple’s iBeacons are designed to measure your proximity to hardware and take
    certain actions when you’re within range. For example, an app could use the beacons
    to track your movements through a mall or store, or indicate that the car that
    just pulled up next to you is the Uber car you requested. iBeacon functionality
    is part of the Core Location API, which uses Bluetooth Low Energy (BTLE) on compatible
    devices to manage proximity monitoring.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: Apple 的 iBeacons 旨在衡量您与硬件的距离，并在您处于有效范围内时执行某些操作。例如，应用程序可以使用信标来跟踪您在商场或商店中的移动，或指示刚刚停在您旁边的汽车是您请求的
    Uber 车。iBeacon 功能是 Core Location API 的一部分，该 API 在兼容设备上使用低功耗蓝牙（BTLE）来管理接近度监控。
- en: In this section, I’ll first discuss how some applications check for iBeacons
    and how iOS devices can become iBeacons. I’ll end on privacy issues you should
    consider when using iBeacons in your own apps.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我将首先讨论一些应用程序如何检测 iBeacons，以及 iOS 设备如何成为 iBeacons。最后，我将讨论使用 iBeacons 时需要考虑的隐私问题。
- en: '***Monitoring for iBeacons***'
  id: totrans-99
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***监测 iBeacons***'
- en: Monitoring for iBeacons is accomplished by instantiating a Core Location `CLLocationManager`
    and passing a `CLBeaconRegion` to the manager’s `startMonitoringForRegion` method,
    as in [Listing 14-5](ch14.html#ch14ex5).
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 通过实例化 Core Location `CLLocationManager` 并将 `CLBeaconRegion` 传递给管理器的 `startMonitoringForRegion`
    方法来实现对 iBeacons 的监控，参考 [示例 14-5](ch14.html#ch14ex5)。
- en: '[PRE4]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '*Listing 14-5: Initiating monitoring for a specific region defined by a UUID*'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: '*示例 14-5：启动对特定区域（由 UUID 定义）的监控*'
- en: The NSUUID generated at ➊ is assigned to a `CLBeaconRegion` ➋ and will be used
    to uniquely identify that beacon. The identifier ➌ will specify the symbolic name
    for the beacon. Note you can register to monitor for multiple regions with the
    same `CLLocationManager`.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 在 ➊ 生成的 NSUUID 被分配给 `CLBeaconRegion` ➋，并将用于唯一标识该信标。标识符 ➌ 将指定信标的符号名称。请注意，您可以注册以监控多个具有相同
    `CLLocationManager` 的区域。
- en: '**NOTE**'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*You can use the* `*uuidgen(1)*` *command in the terminal to generate a unique
    UUID to use as a beacon identifier.*'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: '*您可以在终端中使用* `*uuidgen(1)*` *命令生成一个唯一的 UUID，作为信标标识符。*'
- en: You’ll also need to implement a `locationManager` delegate method, as in [Listing
    14-6](ch14.html#ch14ex6), to handle location updates.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 您还需要实现一个 `locationManager` 委托方法，如 [示例 14-6](ch14.html#ch14ex6)，以处理位置更新。
- en: '[PRE5]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '*Listing 14-6: An example* `locationManager` *delegate method*'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: '*示例 14-6：一个示例的* `locationManager` *委托方法*'
- en: This method will be called whenever a device running your application enters
    an iBeacon’s registered region; your app can then perform whatever logic is appropriate
    upon entering that region. Once the application gets the notification that the
    device has entered the range of a beacon, it can start *ranging*, or measuring
    the distance between the device and the beacon.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 每当运行您的应用程序的设备进入 iBeacon 注册区域时，此方法将被调用；然后，您的应用可以在进入该区域后执行相应的逻辑。应用程序一旦收到设备已进入信标范围的通知，就可以开始进行*范围测量*，即测量设备与信标之间的距离。
- en: After an application has begun ranging a beacon, the `locationManager:didRangeBeacons:inRegion`
    delegate method ([Listing 14-7](ch14.html#ch14ex7)) will be called periodically,
    allowing the application to make decisions based on the proximity of the beacon.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 在应用程序开始对信标进行范围测量后，`locationManager:didRangeBeacons:inRegion` 委托方法（[示例 14-7](ch14.html#ch14ex7)）将定期被调用，允许应用程序根据信标的接近度做出决策。
- en: '[PRE6]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '*Listing 14-7: The* `locationManager` *callback for examining beacons*'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: '*示例 14-7：* `locationManager` *回调用于检查信标*'
- en: 'There are four constants representing proximity: `CLProximityImmediate`, `CLProximityNear`,
    `CLProximityFar`, and `CLProximityUnknown`. See [Table 14-1](ch14.html#ch14tab1)
    for the meanings of these values.'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 有四个常量表示接近度：`CLProximityImmediate`、`CLProximityNear`、`CLProximityFar` 和 `CLProximityUnknown`。请参见
    [表 14-1](ch14.html#ch14tab1) 了解这些值的含义。
- en: '**Table 14-1:** Region Proximity (Range) Measurements'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: '**表 14-1：** 区域接近度（范围）测量'
- en: '| **Item class** | **Meaning** |'
  id: totrans-115
  prefs: []
  type: TYPE_TB
  zh: '| **项目类** | **含义** |'
- en: '| --- | --- |'
  id: totrans-116
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `CLProximityUnknown` | The range is undetermined. |'
  id: totrans-117
  prefs: []
  type: TYPE_TB
  zh: '| `CLProximityUnknown` | 范围未确定。 |'
- en: '| `CLProximityImmediate` | The device is right next to the beacon. |'
  id: totrans-118
  prefs: []
  type: TYPE_TB
  zh: '| `CLProximityImmediate` | 设备紧挨信标。 |'
- en: '| `CLProximityNear` | The device is within a few meters of the beacon. |'
  id: totrans-119
  prefs: []
  type: TYPE_TB
  zh: '| `CLProximityNear` | 设备位于信标的几米范围内。 |'
- en: '| `CLProximityFar` | The device is within range but near the edge of the region.
    |'
  id: totrans-120
  prefs: []
  type: TYPE_TB
  zh: '| `CLProximityFar` | 设备在范围内，但接近区域的边缘。 |'
- en: '***Turning an iOS Device into an iBeacon***'
  id: totrans-121
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***将 iOS 设备变成 iBeacon***'
- en: BTLE iOS devices can also act as iBeacons, broadcasting their presence to the
    outside world, which can be used to detect and measure proximity between iOS devices.
    This is done via the CoreBluetooth framework, using a `CBPeripheralManager` instance
    and giving it a `CLBeaconRegion` with a chosen UUID ([Listing 14-8](ch14.html#ch14ex8)).
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: BTLE iOS设备也可以充当iBeacons，向外界广播它们的存在，这可以用来检测和衡量iOS设备之间的距离。通过CoreBluetooth框架来完成这一操作，使用`CBPeripheralManager`实例并给它一个包含选择的UUID的`CLBeaconRegion`（[Listing
    14-8](ch14.html#ch14ex8)）。
- en: '[PRE7]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '*Listing 14-8: Turning your application into an iBeacon*'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: '*Listing 14-8: 将你的应用程序变成iBeacon*'
- en: The code generates a UUID at ➊ and a symbolic name at ➋, and then defines a
    region at ➌. At ➍, the `peripheralDataWithMeasuredPower` method returns a dictionary
    with the information needed to advertise the beacon (the `nil` parameter just
    tells the code to use the default signal strength parameters for the device).
    At ➎, an instance of `CBPeripheralManager` is instantiated and finally the `peripheralData`
    ➏ is passed to the manager so it can begin advertising.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 代码在➊处生成UUID，在➋处生成符号名称，然后在➌处定义一个区域。在➍处，`peripheralDataWithMeasuredPower`方法返回一个字典，其中包含广告信标所需的信息（`nil`参数仅告诉代码使用设备的默认信号强度参数）。在➎处，实例化`CBPeripheralManager`，最后将`peripheralData`
    ➏传递给管理器，以便它可以开始广播。
- en: Now that you’ve taken a look at how iBeacons are managed, let’s look at some
    of the privacy implications of implementing them.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经了解了如何管理iBeacons，让我们看看实现它们的一些隐私影响。
- en: '***iBeacon Considerations***'
  id: totrans-127
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***iBeacon 注意事项***'
- en: Obviously, iBeacons provide extremely detailed information about a user’s whereabouts.
    Beacons don’t have to be dumb transmitters; they can also be programmable devices
    or other iOS devices that can record location updates and deliver them to central
    servers. Users are likely to object to this data being tracked over the long term,
    so as with other geolocation data, avoid keeping any beacon logs for any longer
    than they’re specifically needed. Also, don’t tie the time and beacon information
    in such a way that they can be correlated with a specific user in the long term.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，iBeacons提供了关于用户位置的极为详细的信息。信标不必只是简单的发射器；它们也可以是可编程设备或其他iOS设备，能够记录位置更新并将其发送到中央服务器。用户可能会反对长期追踪这些数据，因此，像其他地理定位数据一样，避免将任何信标日志保存超过必要的时间。另外，不要将时间和信标信息关联在一起，以便它们可以长期与特定用户相关联。
- en: Your app should turn the device it’s installed on into a beacon sparingly. Becoming
    a beacon makes the device discoverable, so be sure to inform the user of your
    intentions in a manner that communicates that fact. If possible, perform Bluetooth
    advertising for only a limited time window, ceasing it once necessary data has
    been exchanged.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 你的应用应该谨慎地将其安装的设备转变为一个信标。成为信标使设备变得可被发现，因此务必以一种能够传达这一事实的方式告知用户你的意图。如果可能，限制蓝牙广告的时间窗口，在必要的数据交换完成后停止广告。
- en: Now that you’ve looked at some of the many ways apps gather information about
    users, let’s look at some of the policy guidelines that will dictate how those
    apps handle personal data.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经了解了应用如何收集用户信息的多种方式，让我们看看一些政策指南，这些指南将决定应用如何处理个人数据。
- en: '**Establishing Privacy Policies**'
  id: totrans-131
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**建立隐私政策**'
- en: For your own protection, always explicitly state a privacy policy in your application.
    If your app is set to Made for Kids, a privacy policy is both an App Store requirement
    and a legal one, as required by the Children’s Online Privacy Protection Act (COPPA).
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 为了自身的保护，始终在你的应用中明确声明隐私政策。如果你的应用是为儿童设计的，那么隐私政策不仅是App Store的要求，也是法律上的要求，依据《儿童在线隐私保护法》（COPPA）。
- en: 'I’m no lawyer, so of course, I can’t give specific legal advice on how your
    policy should be implemented. However, I would advise you to include the following
    in your privacy policy:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 我不是律师，所以当然不能为你提供具体的法律建议关于你的政策应如何实施。然而，我建议你在隐私政策中包括以下内容：
- en: • The information your app gathers and whether it is identifying or non-identifying
    (that is, whether it can be tied back to a specific user)
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: • 你的应用收集的信息，以及这些信息是否具有身份识别性（即，是否可以追溯到特定用户）
- en: • The mechanisms by which information is gathered
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: • 信息收集的机制
- en: • The reasons for gathering each type of data
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: • 收集每种数据的原因
- en: • How that data is processed and stored
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: • 这些数据是如何处理和存储的
- en: • The retention policy of the data (that is, how long data is stored)
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: • 数据的保留政策（即，数据存储多久）
- en: • If and how the information you gather is shared with third parties
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: • 你收集的信息是否以及如何与第三方共享
- en: • How users can change data collection settings if desired
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: • 用户如何更改数据收集设置（如果需要）
- en: • Security mechanisms in place to protect user data
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: • 用于保护用户数据的安全机制
- en: • A history of changes to the privacy policy
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: • 隐私政策更改的历史记录
- en: The Electronic Frontier Foundation (EFF) provides a good template for developing
    an effective and informative privacy policy, which you can find at *[https://www.eff.org/policy](https://www.eff.org/policy)*.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 电子前沿基金会（EFF）提供了一个很好的模板，用于制定有效且富有信息性的隐私政策，你可以在*[https://www.eff.org/policy](https://www.eff.org/policy)*找到。
- en: Do note that Apple has some specific requirements for how to implement privacy
    policies in the application and how they should be made available. Specifically,
    all applications that offer autorenewed or free subscriptions and apps that are
    categorized as Made for Kids must include a URL to a privacy policy. If the application
    is set to Made for Kids, the policy needs to be localized for each localization
    within the application.^([6](footnote.html#fn124))
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，苹果公司对如何在应用程序中实施隐私政策以及如何提供该政策有一些特定要求。特别是，所有提供自动续订或免费订阅的应用程序，以及被分类为“为儿童设计”的应用程序，都必须包含隐私政策的URL。如果应用程序设置为“为儿童设计”，则该政策需要根据应用程序内的每种本地化进行本地化。^([6](footnote.html#fn124))
- en: '**Closing Thoughts**'
  id: totrans-145
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**结束语**'
- en: In light of disclosures about massive government surveillance in the United
    States and abroad, consumer awareness and concern about companies gathering and
    correlating their personal information and habits is likely to increase. It’s
    also become clear that the more information you gather on your users, the greater
    your company risks exposure. Companies with the most detailed information on their
    users are those most attractive to government intrusion, either by subpoena, monitoring,
    or active hacking by intelligence agencies.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 鉴于关于美国及海外大规模政府监控的披露，消费者对公司收集并关联其个人信息和习惯的关注和担忧可能会增加。同时也越来越清楚，收集的用户信息越多，公司暴露的风险就越大。那些掌握用户最详细信息的公司，也是最容易受到政府干预的目标，无论是通过传票、监控，还是通过情报机构的黑客攻击。
- en: In summary, always clearly define your intentions and minimize data gathered
    to limit your exposure and to build and maintain trust with consumers.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 总结来说，始终清晰地定义你的意图，并尽量减少收集的数据，以限制暴露风险，并与消费者建立和维持信任。
