- en: Chapter 9. Enterprise Security
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第 9 章. 企业安全
- en: Initial Android versions were mostly consumer-oriented, with limited enterprise
    features. However, as the platform has grown in popularity, Android devices have
    entered the workplace and are increasingly used to access corporate email, customer
    information, and other company data. As a result of this trend, the need for increased
    platform security and tools that allow effective management of employee devices
    has steadily grown. While Android’s primary focus remains general-purpose consumer
    devices, recent versions have introduced numerous enterprise features and Android
    will likely become even more enterprise-friendly as it develops.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 最初的 Android 版本主要面向消费者，企业功能有限。然而，随着该平台的普及，Android 设备已进入职场，并越来越多地用于访问公司电子邮件、客户信息及其他公司数据。由于这一趋势，平台安全性需求以及允许有效管理员工设备的工具也稳步增长。虽然
    Android 的主要焦点仍是通用消费类设备，但最近的版本已引入了许多企业功能，随着发展，Android 很可能会变得更加适合企业使用。
- en: In this chapter, we discuss Android’s major enterprise-oriented features and
    demonstrate how they can be used to both increase device security and provide
    centralized device policy management. We’ll begin with device administration,
    and show how it can be integrated into third-party applications. We then look
    into Android’s VPN support and describe the APIs that allow new VPN solutions
    to be developed as third-party, user-installed applications. Next we show how
    Android implements different authentication methods supported by the EAP authentication
    framework and describe how it manages credentials. Finally, we demonstrate how
    to add an EAP profile programmatically using the extended Wi-Fi management APIs
    added in Android 4.3.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将讨论 Android 的主要企业导向功能，并展示如何使用它们来提高设备安全性并提供集中式设备策略管理。我们将从设备管理开始，展示如何将其集成到第三方应用程序中。然后，我们将探讨
    Android 对 VPN 的支持，并描述允许开发新的 VPN 解决方案作为第三方用户安装应用程序的 API。接着，我们展示 Android 如何实现 EAP
    认证框架支持的不同认证方法，并描述它是如何管理凭证的。最后，我们将演示如何使用 Android 4.3 中新增的扩展 Wi-Fi 管理 API 编程添加 EAP
    配置文件。
- en: Device Administration
  id: totrans-3
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设备管理
- en: Android 2.2 introduced support for a Device Administration API, which makes
    it possible to develop applications that can both enforce a systemwide security
    policy and dynamically adapt their features based on the device’s current security
    level. Such applications are called *device administrators*. Device administrators
    must be explicitly enabled in the device’s security settings and cannot be uninstalled
    if they are active. When enabled, they’re granted special privileges that allow
    them to lock the device, change the lockscreen password, and even wipe the device
    (delete all user data). Device administrators are often coupled with a specific
    type of enterprise account (such as a Microsoft Exchange or Google Apps account),
    which allows enterprise administrators to control access to corporate data by
    allowing access only to devices that conform to the required security policy.
    Security policies can be static and built into the device administrator application,
    or they can be configured on the server side and sent to the device as part of
    a provisioning or synchronization protocol.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: Android 2.2 引入了设备管理 API，允许开发可以执行系统范围安全策略并根据设备当前的安全级别动态调整其功能的应用程序。这类应用程序称为*设备管理员*。设备管理员必须在设备的安全设置中显式启用，并且如果它们处于活动状态，无法卸载。启用后，它们将获得特殊权限，允许它们锁定设备、修改锁屏密码，甚至清除设备（删除所有用户数据）。设备管理员通常与特定类型的企业账户（如
    Microsoft Exchange 或 Google Apps 账户）配合使用，允许企业管理员通过仅允许符合所需安全策略的设备访问企业数据，从而控制对公司数据的访问。安全策略可以是静态的，内置在设备管理员应用程序中，或者可以在服务器端配置，并作为配置或同步协议的一部分发送到设备。
- en: As of version 4.4, Android supports the policy types listed in [Table 9-1](ch09.html#supported_device_administration_policies
    "Table 9-1. Supported Device Administration Policies"). The policy constants are
    defined in the `DeviceAdminInfo` class.^([[87](#ftn.ch09fn01)])
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 从版本 4.4 开始，Android 支持在[表 9-1](ch09.html#supported_device_administration_policies
    "Table 9-1. Supported Device Administration Policies")中列出的策略类型。策略常量在`DeviceAdminInfo`类中定义。^([[87](#ftn.ch09fn01)])
- en: Table 9-1. Supported Device Administration Policies
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 表 9-1. 支持的设备管理策略
- en: '| Policy Constant/XML Tag | Value (bit to set) | Description | API Level |'
  id: totrans-7
  prefs: []
  type: TYPE_TB
  zh: '| 策略常量/XML 标签 | 值（设置位） | 描述 | API 级别 |'
- en: '| --- | --- | --- | --- |'
  id: totrans-8
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- |'
- en: '| `USES_POLICY_LIMIT_PASSWORD <limit-password>` | 0 | Limit the passwords that
    the user can select by setting a minimum length or complexity. | 8 |'
  id: totrans-9
  prefs: []
  type: TYPE_TB
  zh: '| `USES_POLICY_LIMIT_PASSWORD <limit-password>` | 0 | 通过设置最小长度或复杂度来限制用户可选择的密码。
    | 8 |'
- en: '| `USES_POLICY_WATCH_LOGIN <watch-login>` | 1 | Watch login attempts by a user.
    | 8 |'
  id: totrans-10
  prefs: []
  type: TYPE_TB
  zh: '| `USES_POLICY_WATCH_LOGIN <watch-login>` | 1 | 监视用户的登录尝试。 | 8 |'
- en: '| `USES_POLICY_RESET_PASSWORD <reset-password>` | 2 | Reset a user’s password.
    | 8 |'
  id: totrans-11
  prefs: []
  type: TYPE_TB
  zh: '| `USES_POLICY_RESET_PASSWORD <reset-password>` | 2 | 重置用户的密码。 | 8 |'
- en: '| `USES_POLICY_FORCE_LOCK <force-lock>` | 3 | Force the device to lock, or
    limit the maximum lock timeout. | 8 |'
  id: totrans-12
  prefs: []
  type: TYPE_TB
  zh: '| `USES_POLICY_FORCE_LOCK <force-lock>` | 3 | 强制设备锁定，或限制最大锁定超时。 | 8 |'
- en: '| `USES_POLICY_WIPE_DATA <wipe-data>` | 4 | Factory reset the device, erasing
    all user data. | 8 |'
  id: totrans-13
  prefs: []
  type: TYPE_TB
  zh: '| `USES_POLICY_WIPE_DATA <wipe-data>` | 4 | 恢复出厂设置，擦除所有用户数据。 | 8 |'
- en: '| `USES_POLICY_SETS_GLOBAL_PROXY <set-global-proxy>` | 5 | Specify the device
    global proxy. (This is hidden from SDK applications.) | 9 |'
  id: totrans-14
  prefs: []
  type: TYPE_TB
  zh: '| `USES_POLICY_SETS_GLOBAL_PROXY <set-global-proxy>` | 5 | 指定设备的全局代理。（此项对 SDK
    应用隐藏。） | 9 |'
- en: '| `USES_POLICY_EXPIRE_PASSWORD <expire-password>` | 6 | Force the user to change
    their password after an administrator-defined time limit. | 11 |'
  id: totrans-15
  prefs: []
  type: TYPE_TB
  zh: '| `USES_POLICY_EXPIRE_PASSWORD <expire-password>` | 6 | 强制用户在管理员定义的时间限制后更改密码。
    | 11 |'
- en: '| `USES_ENCRYPTED_STORAGE <encrypted-storage>` | 7 | Require stored data to
    be encrypted. | 11 |'
  id: totrans-16
  prefs: []
  type: TYPE_TB
  zh: '| `USES_ENCRYPTED_STORAGE <encrypted-storage>` | 7 | 要求存储的数据进行加密。 | 11 |'
- en: '| `USES_POLICY_DISABLE_CAMERA <disable-camera>` | 8 | Disable the use of all
    device cameras. | 14 |'
  id: totrans-17
  prefs: []
  type: TYPE_TB
  zh: '| `USES_POLICY_DISABLE_CAMERA <disable-camera>` | 8 | 禁用所有设备相机的使用。 | 14 |'
- en: '| `USES_POLICY_DISABLE_KEYGUARD_FEATURES <disable-keyguard-features>` | 9 |
    Disable the use of keyguard features such as lockscreen widgets or camera support.
    | 17 |'
  id: totrans-18
  prefs: []
  type: TYPE_TB
  zh: '| `USES_POLICY_DISABLE_KEYGUARD_FEATURES <disable-keyguard-features>` | 9 |
    禁用锁屏功能，例如锁屏小部件或相机支持。 | 17 |'
- en: Each device administration application must list the policies it intends to
    use in a metadata file (see “[Privilege Management](ch09.html#privilege_management
    "Privilege Management")” for details). The list of supported policies is displayed
    to the user when they activate the administrator app, as shown in [Figure 9-1](ch09.html#device_administrator_activation_screen
    "Figure 9-1. Device administrator activation screen").
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 每个设备管理应用必须在元数据文件中列出其打算使用的策略（有关详细信息，请参见“[权限管理](ch09.html#privilege_management
    "权限管理")”）。当用户激活管理员应用时，支持的策略列表将显示给用户，如[图 9-1](ch09.html#device_administrator_activation_screen
    "图 9-1. 设备管理员激活屏幕")所示。
- en: Implementation
  id: totrans-20
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实现
- en: Now that we know which policies can be enforced with the Device Administration
    API, let’s look at the internal implementation. Like most public Android APIs,
    a manager class called `DevicePolicyManager`^([[88](#ftn.ch09fn02)]) exposes part
    of the functionality of the underlying system service, `DevicePolicyManagerService`.
    However, because the `DevicePolicyManager` facade class defines constants and
    translates service exceptions to return codes but otherwise adds little functionality,
    we’ll focus on the `DevicePolicyManagerService` class.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们知道哪些策略可以通过设备管理 API 强制执行，接下来让我们看看内部实现。像大多数公共 Android API 一样，一个名为`DevicePolicyManager`^([[88](#ftn.ch09fn02)])的管理类暴露了底层系统服务`DevicePolicyManagerService`的一部分功能。然而，由于`DevicePolicyManager`外观类定义了常量并将服务异常转换为返回码，但除此之外增加的功能不多，因此我们将重点关注`DevicePolicyManagerService`类。
- en: '![Device administrator activation screen](figs/web/09fig01.png.jpg)'
  id: totrans-22
  prefs: []
  type: TYPE_IMG
  zh: '![设备管理员激活屏幕](figs/web/09fig01.png.jpg)'
- en: Figure 9-1. Device administrator activation screen
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9-1. 设备管理员激活屏幕
- en: Like most system services, `DevicePolicyManagerService` is started by and runs
    within the *system_server* process as the *system* user, and thus can execute
    almost all Android privileged actions. Unlike most system services, it can grant
    access to certain privileged actions (such as changing the lockscreen password)
    to third-party applications, which do not need to hold any special system permissions.
    This makes it possible for users to enable and disable device administrators on
    demand, and guarantees that device administrators can only enforce policies that
    they have explicitly declared. However, this level of flexibility cannot be easily
    implemented with standard Android permissions that are only granted at install
    time and cannot be revoked (with some exceptions, as discussed in [Chapter 2](ch02.html
    "Chapter 2. Permissions")). Therefore, `DevicePolicyManagerService` employs a
    different method for privilege management.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 和大多数系统服务一样，`DevicePolicyManagerService`由*system_server*进程启动并运行，且以*system*用户身份运行，因此可以执行几乎所有Android特权操作。与大多数系统服务不同，它可以将某些特权操作（例如更改锁屏密码）的访问权限授予第三方应用程序，而这些应用程序无需持有任何特殊的系统权限。这使得用户能够按需启用和禁用设备管理员，并保证设备管理员只能执行他们明确声明的策略。然而，这种灵活性无法通过标准的Android权限轻松实现，因为这些权限仅在安装时授予，且无法撤销（有些例外，详见[第2章](ch02.html
    "第2章. 权限")）。因此，`DevicePolicyManagerService`采用了一种不同的特权管理方法。
- en: Another interesting aspect of Android’s device administration implementation
    relates to how policies are managed and enforced. We describe device administrator
    privilege management and policy enforcement in detail next.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: Android设备管理实现的另一个有趣方面与策略的管理和执行有关。接下来，我们将详细描述设备管理员特权管理和策略执行。
- en: Privilege Management
  id: totrans-26
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 特权管理
- en: At runtime, the `DevicePolicyManagerService` keeps an internal, on-memory list
    of policy structures for each device user. (Policies are also persisted on disk
    in an XML file, as described in the next section.)
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 在运行时，`DevicePolicyManagerService`会为每个设备用户保持一个内部的、内存中的策略结构列表。（策略也会保存在磁盘上的XML文件中，具体细节见下一节。）
- en: Each policy structure contains the currently effective policy for a certain
    user and a list of metadata about each active device administrator. Because each
    user can enable more than one application with device administrator functionality,
    the currently active policy is calculated by selecting the strictest defined policy
    among all administrators. The metadata about each active device administrator
    contains information about the declaring application, and a list of declared policies
    (represented by a bitmask).
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 每个策略结构包含当前某个用户的有效策略和关于每个活动设备管理员的元数据列表。由于每个用户可以启用多个具有设备管理员功能的应用程序，因此当前的活动策略是通过在所有管理员中选择定义最严格的策略来计算的。关于每个活动设备管理员的元数据包含有关声明应用程序的信息，以及声明的策略列表（由位掩码表示）。
- en: 'The `DevicePolicyManagerService` decides whether to grant access to privileged
    operations to a calling application based on its internal list of active policies:
    if the calling application is currently an active device administrator, and it
    has requested the policy that corresponds to the current request (API call), only
    then is the request granted and the operation executed. In order to confirm that
    an active administrator component really belongs to the calling application, `DevicePolicyManagerService`
    compares the UID of the calling process (returned by `Binder.getCallingUid()`)
    with the UID associated with the target administrator component. For example,
    an application that calls the `resetPassword()` needs to be an active device administrator,
    have the same UID as the registered administrator component, and have requested
    the `USES_POLICY_RESET_PASSWORD` policy in order for the call to succeed.'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: '`DevicePolicyManagerService`根据其内部活动策略列表来决定是否授予调用应用程序特权操作的访问权限：只有当调用应用程序当前是一个活动设备管理员，且请求的策略与当前请求（API调用）相对应时，请求才会被授予，操作才会执行。为了确认一个活动管理员组件确实属于调用应用程序，`DevicePolicyManagerService`将调用进程的UID（由`Binder.getCallingUid()`返回）与目标管理员组件的UID进行比较。例如，调用`resetPassword()`的应用程序需要是一个活动设备管理员，且其UID与注册的管理员组件相同，并已请求`USES_POLICY_RESET_PASSWORD`策略，才能使调用成功。'
- en: Policies are requested by adding an XML resource file that lists all policies
    that a device administrator application wants to use as children of the `<uses-policies>`
    tag. Before a device administrator is activated, the system parses the XML file
    and displays a dialog similar to the one in [Figure 9-1](ch09.html#device_administrator_activation_screen
    "Figure 9-1. Device administrator activation screen"), allowing the user to review
    the requested policies before enabling the administrator. Much like Android permissions,
    administrator policies are granted on an all-or-nothing basis, and there is no
    way to selectively enable only certain policies. A resource file that requests
    all policies might look like [Example 9-1](ch09.html#declaring_policies_in_a_device_administr
    "Example 9-1. Declaring policies in a device administrator application") (for
    the policy corresponding to each tag, see the first column of [Table 9-1](ch09.html#supported_device_administration_policies
    "Table 9-1. Supported Device Administration Policies")). You can find more details
    about adding this file to a device administrator application in “[Adding a Device
    Administrator](ch09.html#adding_a_device_administrator "Adding a Device Administrator")”.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 通过添加一个列出设备管理员应用希望使用的所有策略的 XML 资源文件，并将其作为`<uses-policies>`标签的子项，来请求策略。在激活设备管理员之前，系统会解析
    XML 文件并显示一个类似于[图 9-1](ch09.html#device_administrator_activation_screen "图 9-1.
    设备管理员激活屏幕")的对话框，允许用户在启用管理员之前审查请求的策略。与 Android 权限类似，管理员策略是全选或全不选的，无法选择性地启用某些策略。请求所有策略的资源文件可能类似于[示例
    9-1](ch09.html#declaring_policies_in_a_device_administr "示例 9-1. 在设备管理员应用中声明策略")（每个标签对应的策略，请参见[表
    9-1](ch09.html#supported_device_administration_policies "表 9-1. 支持的设备管理策略")的第一列）。你可以在“[添加设备管理员](ch09.html#adding_a_device_administrator
    "添加设备管理员")”中找到更多关于将此文件添加到设备管理员应用的详细信息。
- en: Example 9-1. Declaring policies in a device administrator application
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 9-1. 在设备管理员应用中声明策略
- en: '[PRE0]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: In order to be notified about policy-related system events and to be allowed
    access to the Device Administration API, device administrators must be activated
    first. This is achieved by calling the `setActiveAdmin()` method of the `DevicePolicyManagerService`.
    Because this method requires the `MANAGE_DEVICE_ADMINS` permission, which is a
    system signature permission, only system applications can add a device administrator
    without user interaction.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 为了接收与策略相关的系统事件通知，并允许访问设备管理 API，设备管理员必须首先被激活。这是通过调用`DevicePolicyManagerService`的`setActiveAdmin()`方法实现的。由于此方法需要`MANAGE_DEVICE_ADMINS`权限，而该权限是系统签名权限，因此只有系统应用可以在没有用户交互的情况下添加设备管理员。
- en: User-installed device administrator applications can only request to be activated
    by starting the `ACTION_ADD_DEVICE_ADMIN` implicit intent with code similar to
    [Example 9-2](ch09.html#requesting_device_administrator_activati "Example 9-2. Requesting
    device administrator activation"). The only handler for this intent is the system
    Settings application, which holds the `MANAGE_DEVICE_ADMINS` permission. Upon
    receiving the intent, the Settings applications checks whether the requesting
    application is a valid device administrator, extracts the requested policies,
    and builds the confirmation dialog shown in [Figure 9-1](ch09.html#device_administrator_activation_screen
    "Figure 9-1. Device administrator activation screen"). The user pressing the Activate
    button calls the `setActiveAdmin()` method, which adds the application to the
    list of active administrators for the current device user.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 用户安装的设备管理员应用只能通过启动`ACTION_ADD_DEVICE_ADMIN`隐式意图来请求激活，代码类似于[示例 9-2](ch09.html#requesting_device_administrator_activati
    "示例 9-2. 请求设备管理员激活")。唯一处理此意图的应用是系统设置应用，它拥有`MANAGE_DEVICE_ADMINS`权限。在接收到意图后，设置应用检查请求的应用是否是有效的设备管理员，提取请求的策略，并构建[图
    9-1](ch09.html#device_administrator_activation_screen "图 9-1. 设备管理员激活屏幕")中显示的确认对话框。用户点击激活按钮后，调用`setActiveAdmin()`方法，将该应用添加到当前设备用户的活动管理员列表中。
- en: Example 9-2. Requesting device administrator activation
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 9-2. 请求设备管理员激活
- en: '[PRE1]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Policy Persistence
  id: totrans-37
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 策略持久化
- en: When a device administrator is activated, deactivated, or its policies are updated,
    changes are written to the *device_policies.xml* file for the target user. For
    the owner user, that file is stored under */data/system/*, and for all other users
    it’s written to the user’s system directory (*/data/users/<user-ID>/*). The file
    is owned by and only modifiable by the *system* user (file permissions 0600).
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 当设备管理员被激活、停用或其策略更新时，变更会被写入目标用户的 *device_policies.xml* 文件。对于所有者用户，该文件存储在 */data/system/*
    下，对于其他用户，则写入到该用户的系统目录（*/data/users/<user-ID>/*）。该文件由 *system* 用户拥有，并且只能由 *system*
    用户修改（文件权限为 0600）。
- en: The *device_policies.xml* file contains information about each active administrator
    and its policies, as well some global information about the current lockscreen
    password. The file might look like [Example 9-3](ch09.html#contents_of_the_devicesunderscorepolicie
    "Example 9-3. Contents of the devices_policies.xml file").
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: '*device_policies.xml* 文件包含有关每个活动管理员及其策略的信息，以及有关当前锁屏密码的一些全局信息。该文件可能类似于 [示例 9-3](ch09.html#contents_of_the_devicesunderscorepolicie
    "示例 9-3. devices_policies.xml 文件内容")。'
- en: Example 9-3. Contents of the devices_policies.xml file
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 9-3. devices_policies.xml 文件内容
- en: '[PRE2]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: This example has three active device administrators, each represented by an
    `<admin>` element (➊, ➋, and ➎). The policies of each administrator app are stored
    in the `flags` attribute of the `<policies>` tag ➌.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 这个示例有三个活动设备管理员，每个管理员都由一个 `<admin>` 元素表示（➊、➋ 和 ➎）。每个管理员应用程序的策略存储在 `<policies>`
    标签的 `flags` 属性中 ➌。
- en: A policy is considered enabled if its corresponding bit is set (see the Value
    column of [Table 9-1](ch09.html#supported_device_administration_policies "Table 9-1. Supported
    Device Administration Policies")). For example, because the *DeviceAdminSample*
    application has requested all currently available policies, its `flags` attribute
    has the value 1023 (0x3FF, or 1111111111 in binary).
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 如果相应的位被设置，则认为该策略已启用（参见 [表 9-1](ch09.html#supported_device_administration_policies
    "表 9-1. 支持的设备管理策略") 的值列）。例如，由于 *DeviceAdminSample* 应用程序请求了所有当前可用的策略，其 `flags`
    属性的值为 1023 (0x3FF，或 1111111111 的二进制表示)。
- en: If the administrator defines password quality restrictions (for example, alphanumeric
    or complex), they are persisted as the `value` attribute of the `<password-quality>`
    tag ➍. In this example, the value 327680 (0x50000) corresponds to `PASSWORD_QUALITY_ALPHANUMERIC`.
    (Password quality constants are defined in the `DevicePolicyManager` class.)
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 如果管理员定义了密码质量限制（例如，字母数字或复杂），它们会作为 `<password-quality>` 标签的 `value` 属性被保存 ➍。在此示例中，值
    327680 (0x50000) 对应于 `PASSWORD_QUALITY_ALPHANUMERIC`。（密码质量常量在 `DevicePolicyManager`
    类中定义。）
- en: The values of other policy requirements, such as password length and device
    encryption, are also stored as children of each `<admin>` element. If the password
    has been set programmatically by using the `resetPassword()` method, *device_policies.xml*
    contains a `<password-owner>` tag that stores the UID of the application that
    sets the password in its `value` attribute ➏. Finally, the `<active-password>`
    tag contains details about the complexity of the current password ➐.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 其他策略要求的值，如密码长度和设备加密，也作为每个 `<admin>` 元素的子元素进行存储。如果密码是通过使用 `resetPassword()` 方法编程设置的，*device_policies.xml*
    会包含一个 `<password-owner>` 标签，其 `value` 属性存储设置密码的应用程序的 UID ➏。最后，`<active-password>`
    标签包含有关当前密码复杂性的详细信息 ➐。
- en: Policy Enforcement
  id: totrans-46
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 策略强制执行
- en: Device administrator policies have different granularity and can be enforced
    either for the current user or for all users on a device. Some policies are not
    enforced by the system at all—the system only notifies the declaring administration
    application, which is then responsible for taking an appropriate action. In this
    section, we describe how each type of policy is implemented and enforced.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 设备管理员策略具有不同的粒度，可以对当前用户或设备上的所有用户强制执行。有些策略根本没有被系统强制执行——系统只会通知声明的管理应用程序，由其负责采取适当的行动。在本节中，我们将描述每种类型的策略是如何实现和强制执行的。
- en: '**`USES_POLICY_LIMIT_PASSWORD`**'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: '**`USES_POLICY_LIMIT_PASSWORD`**'
- en: After one or more password restrictions have been set, users cannot enter a
    password that does not fulfill the current policy. However, the system does not
    require passwords to be changed immediately, so the current password remains in
    effect until changed. Administrator applications can prompt the user for a new
    password by starting an implicit intent with the `DevicePolicyManager.ACTION_SET_NEW_PASSWORD`
    action.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 设置一个或多个密码限制后，用户不能输入不符合当前策略的密码。然而，系统并不要求立即更改密码，因此当前密码将在更改之前继续有效。管理员应用程序可以通过启动一个隐式意图，并使用`DevicePolicyManager.ACTION_SET_NEW_PASSWORD`操作来提示用户设置新密码。
- en: Because each device user has a separate unlock password, password quality policies
    are applied per-user. When password quality is set, unlock methods that do not
    allow for a password of the desired quality are disabled. For example, setting
    password quality to `PASSWORD_ QUALITY_ALPHANUMERIC` disables the Pattern and
    PIN unlock methods, as shown in [Figure 9-2](ch09.html#setting_a_password_quality_policy_disabl
    "Figure 9-2. Setting a password quality policy disables incompatible unlock methods").
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 因为每个设备用户都有单独的解锁密码，密码质量策略是按用户应用的。当设置密码质量时，不允许设置所需密码质量的解锁方法将被禁用。例如，将密码质量设置为`PASSWORD_QUALITY_ALPHANUMERIC`会禁用图案和PIN解锁方法，如[图
    9-2](ch09.html#setting_a_password_quality_policy_disabl "图 9-2. 设置密码质量策略禁用不兼容的解锁方法")所示。
- en: '![Setting a password quality policy disables incompatible unlock methods](figs/web/09fig02.png.jpg)'
  id: totrans-51
  prefs: []
  type: TYPE_IMG
  zh: '![设置密码质量策略禁用不兼容的解锁方法](figs/web/09fig02.png.jpg)'
- en: Figure 9-2. Setting a password quality policy disables incompatible unlock methods
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9-2. 设置密码质量策略禁用不兼容的解锁方法
- en: '**`USES_POLICY_WATCH_LOGIN`**'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: '**`USES_POLICY_WATCH_LOGIN`**'
- en: This policy enables device administrators to receive notifications about the
    outcome of login attempts. Notifications are sent with the `ACTION_PASSWORD_FAILED`
    and `ACTION_PASSWORD_SUCCEEDED` broadcasts. Broadcast receivers that derive from
    `DeviceAdminReceiver` are automatically notified via the `onPasswordFailed()`
    and `onPasswordSucceeded()` methods.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 此策略允许设备管理员接收关于登录尝试结果的通知。通知通过`ACTION_PASSWORD_FAILED`和`ACTION_PASSWORD_SUCCEEDED`广播发送。继承自`DeviceAdminReceiver`的广播接收器会通过`onPasswordFailed()`和`onPasswordSucceeded()`方法自动接收通知。
- en: '**`USES_POLICY_RESET_PASSWORD`**'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: '**`USES_POLICY_RESET_PASSWORD`**'
- en: This policy enables administrator applications to set the current user’s password
    via the `resetPassword()` API. The specified password must satisfy the current
    password quality requirements and takes effect immediately. Note that if the device
    is encrypted, setting the lockscreen password for the owner user also changes
    the device encryption password. ([Chapter 10](ch10.html "Chapter 10. Device Security")
    provides more detail on device encryption.)
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 此策略允许管理员应用程序通过`resetPassword()` API 设置当前用户的密码。指定的密码必须满足当前密码质量要求，并立即生效。请注意，如果设备已加密，为拥有者用户设置锁屏密码时也会更改设备加密密码。（[第10章](ch10.html
    "第10章. 设备安全")提供了关于设备加密的更多详细信息。）
- en: '**`USES_POLICY_FORCE_LOCK`**'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: '**`USES_POLICY_FORCE_LOCK`**'
- en: This policy allows administrators to lock the device immediately by calling
    the `lockNow()` method, or to specify the maximum time for user inactivity until
    the device locks automatically via `setMaximumTimeToLock()`. Setting the maximum
    time to lock takes effect immediately and limits the inactivity sleep time that
    users can set via the system Display settings.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 此策略允许管理员通过调用`lockNow()`方法立即锁定设备，或通过`setMaximumTimeToLock()`指定用户不活动的最大时间，直到设备自动锁定。设置最大锁定时间立即生效，并限制用户可以通过系统显示设置调整的不活动睡眠时间。
- en: '**`USES_POLICY_WIPE_DATA`**'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: '**`USES_POLICY_WIPE_DATA`**'
- en: This policy allows device administrators to wipe user data by calling the `wipeData()`
    API. Applications that also request the `USES_POLICY_WATCH_LOGIN` policy can set
    the number of failed login attempts before the device is wiped automatically via
    the `setMaximumFailedPasswordsForWipe()` API. When the number of failed passwords
    is set to a value greater than zero, the lockscreen implementation notifies the
    `DevicePolicyManagerService` and displays a warning dialog after each failed attempt,
    and triggers a data wipe once the threshold is reached. If the wipe is triggered
    by an unsuccessful login attempt by the owner user, a full device wipe is performed.
    If, on the other hand, the wipe is triggered by a secondary user, only that user
    (and any associated data) is deleted and the device switches to the owner user.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 该政策允许设备管理员通过调用`wipeData()` API来擦除用户数据。申请了`USES_POLICY_WATCH_LOGIN`政策的应用程序可以通过`setMaximumFailedPasswordsForWipe()`
    API设置设备在自动擦除数据前允许的最大登录失败次数。当设置的登录失败次数大于零时，锁屏实现会在每次登录失败后通知`DevicePolicyManagerService`并显示警告对话框，一旦达到阈值就触发数据擦除。如果擦除是由于所有者用户的登录失败触发的，则会执行完全擦除。如果擦除是由次要用户的登录失败触发的，则只会删除该用户及其相关数据，设备会切换回所有者用户。
- en: Note
  id: totrans-61
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注
- en: '*Full device wipe is not immediate, but is implemented by writing a `wipe_data`
    command in the* cache *partition and rebooting into recovery mode. The recovery
    OS is responsible for executing the actual device wipe. Therefore, if the device
    has a custom recovery image that ignores the wipe command, or if the user manages
    to boot into a custom recovery and delete or modify the command file, the device
    wipe might not be executed. ([Chapter 10](ch10.html "Chapter 10. Device Security")
    and [Chapter 13](ch13.html "Chapter 13. System Updates and Root Access") discuss
    recovery images in more detail.)*'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: '*完全擦除设备数据并非即时进行，而是通过在* 缓存 *分区写入`wipe_data`命令并重启进入恢复模式来实现的。恢复操作系统负责执行实际的设备数据擦除。因此，如果设备有一个自定义恢复镜像忽略了擦除命令，或者用户设法进入自定义恢复模式并删除或修改了命令文件，设备擦除可能不会执行。（[第10章](ch10.html
    "第10章. 设备安全")和[第13章](ch13.html "第13章. 系统更新与root访问")更详细地讨论了恢复镜像。）*'
- en: '**`USES_POLICY_SETS_GLOBAL_PROXY`**'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: '**`USES_POLICY_SETS_GLOBAL_PROXY`**'
- en: As of Android 4.4, this policy is not available to third-party applications.
    It allows device administrators to set the global proxy server host (`Settings.Global.GLOBAL_HTTP_PROXY_HOST`),
    port (`GLOBAL_HTTP_PROXY_PORT`), and the list of excluded hosts (`GLOBAL_HTTP_PROXY_EXCLUSION_LIST`)
    by writing to the global system settings provider. Only the device owner is allowed
    to set global proxy settings.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 从Android 4.4开始，这项政策不适用于第三方应用程序。它允许设备管理员通过写入全局系统设置提供者来设置全局代理服务器主机（`Settings.Global.GLOBAL_HTTP_PROXY_HOST`）、端口（`GLOBAL_HTTP_PROXY_PORT`）和排除的主机列表（`GLOBAL_HTTP_PROXY_EXCLUSION_LIST`）。只有设备所有者才能设置全局代理设置。
- en: '**`USES_POLICY_EXPIRE_PASSWORD`**'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: '**`USES_POLICY_EXPIRE_PASSWORD`**'
- en: This policy allows administrators to set the password expiration timeout via
    the `setPasswordExpirationTimeout()` API. If an expiration timeout is set, the
    system registers a daily alarm that checks for password expiration. If the password
    has already expired, `DevicePolicyManagerService` posts daily password change
    notifications until it is changed. Device administrators are notified about password
    expiration status via the `Dev iceAdminReceiver.onPasswordExpiring()` method.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 该政策允许管理员通过`setPasswordExpirationTimeout()` API设置密码过期超时。如果设置了过期超时，系统会注册一个每日闹钟以检查密码是否过期。如果密码已经过期，`DevicePolicyManagerService`会每天发布密码更改通知，直到密码被更改。设备管理员会通过`DeviceAdminReceiver.onPasswordExpiring()`方法收到密码过期状态的通知。
- en: '**`USES_ENCRYPTED_STORAGE`**'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: '**`USES_ENCRYPTED_STORAGE`**'
- en: This policy allows administrators to request that device storage be encrypted
    via the `setStorageEncryption()` API. Only the owner user can request storage
    encryption. Requesting storage encryption does not automatically start the device
    encryption process if the device is not encrypted; device administrators must
    check the current storage status by using the `getStorageEncryptionStatus()` API
    (which checks the *ro.crypto.state* read-only system property), and start the
    encryption process. Device encryption can be kicked off by starting the associated
    system activity with the `ACTION_START_ENCRYPTION` implicit intent.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 此政策允许管理员请求通过`setStorageEncryption()` API加密设备存储。只有所有者用户才能请求存储加密。如果设备尚未加密，请求存储加密不会自动启动设备加密过程；设备管理员必须使用`getStorageEncryptionStatus()`
    API（该API检查*ro.crypto.state*只读系统属性）检查当前存储状态，并启动加密过程。可以通过启动相关的系统活动并带上`ACTION_START_ENCRYPTION`隐式意图来启动设备加密。
- en: '**`USES_POLICY_DISABLE_CAMERA`**'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: '**`USES_POLICY_DISABLE_CAMERA`**'
- en: This policy allows device administrators to disable all cameras on the device
    via the `setCameraDisabled()` API. Camera is disabled by setting the *sys.secpolicy.camera.disabled*
    system property to 1\. The native system `CameraService` checks this property
    and disallows all connections if it is set to 1, effectively disabling the camera
    for all users of the device.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 此政策允许设备管理员通过`setCameraDisabled()` API禁用设备上的所有摄像头。通过将*sys.secpolicy.camera.disabled*系统属性设置为1来禁用摄像头。原生系统`CameraService`会检查此属性，并在其值为1时禁止所有连接，从而有效地禁用设备上所有用户的摄像头。
- en: '**`USES_POLICY_DISABLE_KEYGUARD_FEATURES`**'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: '**`USES_POLICY_DISABLE_KEYGUARD_FEATURES`**'
- en: This policy allows administrators to disable keyguard customizations such as
    lockscreen widgets by calling the `setKeyguardDisabledFeatures()` method. The
    system keyguard implementation checks if this policy is in effect and disables
    the corresponding features for the target user.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 此政策允许管理员通过调用`setKeyguardDisabledFeatures()`方法禁用锁屏小部件等键盘保护定制功能。系统键盘保护实现会检查此政策是否生效，并为目标用户禁用相应功能。
- en: Adding a Device Administrator
  id: totrans-73
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 添加设备管理员
- en: As with other applications, device administrators can either be included in
    the system image or they can be installed by users. If an administrator is part
    of the system image, it can be set as the *device owner app* in Android 4.4 and
    later, which is a special kind of device admin that cannot be disabled by the
    user and cannot be uninstalled. In this section, we’ll show how to implement a
    device admin app and then demonstrate how a system app can be set as the device
    owner.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 与其他应用一样，设备管理员可以包含在系统镜像中，也可以由用户安装。如果管理员是系统镜像的一部分，它可以在Android 4.4及更高版本中设置为*设备所有者应用*，这是一种特殊的设备管理员，用户无法禁用且无法卸载。在本节中，我们将展示如何实现一个设备管理员应用，并演示如何将系统应用设置为设备所有者。
- en: Implementing a Device Administrator
  id: totrans-75
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 实现设备管理员
- en: A device administrator application needs to declare a broadcast receiver that
    requires the `BIND_DEVICE_ADMIN` permission (➊ in [Example 9-4](ch09.html#device_administrator_broadcast_receiver
    "Example 9-4. Device administrator broadcast receiver declaration")), declares
    an XML resource file that lists the policies it uses ➋, and responds to the `ACTION_DEVICE_ADMIN_ENABLED`
    intent ➌. [Example 9-1](ch09.html#declaring_policies_in_a_device_administr "Example 9-1. Declaring
    policies in a device administrator application") shows a sample policy declaration.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 设备管理员应用需要声明一个广播接收器，并要求`BIND_DEVICE_ADMIN`权限（➊ 在[示例 9-4](ch09.html#device_administrator_broadcast_receiver
    "示例 9-4. 设备管理员广播接收器声明")中），声明一个列出其使用的政策的XML资源文件 ➋，并响应`ACTION_DEVICE_ADMIN_ENABLED`意图
    ➌。[示例 9-1](ch09.html#declaring_policies_in_a_device_administr "示例 9-1. 在设备管理员应用中声明政策")展示了一个示例政策声明。
- en: Example 9-4. Device administrator broadcast receiver declaration
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 9-4. 设备管理员广播接收器声明
- en: '[PRE3]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The Android SDK provides a base class that you can derive your receiver from,
    namely `android.app.admin.DeviceAdminReceiver`. This class defines a number of
    callback methods that you can override in order to handle the device policy-related
    broadcasts sent by the system. The default implementations are empty, but at a
    minimum you should override the `onEnabled()` and `onDisabled()` methods in order
    to be notified when the administrator is enabled or disabled. Device administrators
    cannot use any privileged APIs before `onEnabled()` is called or after `onDisabled()`
    is called.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: Android SDK 提供了一个基类，你可以从中派生你的接收器，即 `android.app.admin.DeviceAdminReceiver`。这个类定义了多个回调方法，你可以重写这些方法来处理系统发送的与设备策略相关的广播。默认实现为空，但至少你应该重写
    `onEnabled()` 和 `onDisabled()` 方法，以便在管理员启用或禁用时收到通知。在调用 `onEnabled()` 之前或调用 `onDisabled()`
    之后，设备管理员不能使用任何特权 API。
- en: You can use the `isAdminActive()` API at any time to see if an application is
    currently an active device administrator. As mentioned in “[Privilege Management](ch09.html#privilege_management
    "Privilege Management")”, an administrator cannot activate itself automatically,
    but must start a system activity to prompt for user confirmation with code similar
    to [Example 9-2](ch09.html#requesting_device_administrator_activati "Example 9-2. Requesting
    device administrator activation"). However, when already active, an administrator
    can deactivate itself by calling the `removeActiveAdmin()` method.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以随时使用 `isAdminActive()` API 来查看应用程序当前是否是一个活跃的设备管理员。如在 “[权限管理](ch09.html#privilege_management
    "权限管理”)” 中提到，管理员不能自动激活自己，而必须启动系统活动以提示用户确认，代码类似于 [示例 9-2](ch09.html#requesting_device_administrator_activati
    "示例 9-2. 请求设备管理员激活")。然而，当管理员已经激活时，可以通过调用 `removeActiveAdmin()` 方法来禁用自己。
- en: Note
  id: totrans-81
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '*See the official Device Administration API guide*^([[89](#ftn.ch09fn03)])
    *for more details and a full working example application.*'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: '*请参阅官方的设备管理 API 指南*^([[89](#ftn.ch09fn03)]) *获取更多细节和完整的示例应用。*'
- en: Setting the Device Owner
  id: totrans-83
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 设置设备所有者
- en: A device administrator application that’s part of the system image (that is,
    its APK file is installed on the *system* partition) can be set as the device
    owner by calling the `setDeviceOwner(String packageName, String ownerName)` method
    (not visible in the public SDK API). The first parameter in this method specifies
    the package name of the target application, and the second specifies the name
    of the owner to be displayed in the UI. While this method requires no special
    permissions, it can only be called before a device is provisioned (that is, if
    the global setting `Settings.Global.DEVICE_PROVISIONED` is set to 0), which means
    that it can only be called by system applications that execute as part of device
    initialization.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 系统镜像中的设备管理员应用程序（即其 APK 文件安装在 *系统* 分区中）可以通过调用 `setDeviceOwner(String packageName,
    String ownerName)` 方法来设置为设备所有者（在公共 SDK API 中不可见）。该方法的第一个参数指定目标应用程序的包名，第二个参数指定要在
    UI 中显示的所有者名称。虽然此方法不需要特殊权限，但只能在设备配置之前调用（即，如果全局设置 `Settings.Global.DEVICE_PROVISIONED`
    被设置为 0），这意味着它只能由作为设备初始化一部分执行的系统应用程序调用。
- en: A successful call to this method writes a *device_owner.xml* file (like the
    one in [Example 9-5](ch09.html#contents_of_the_deviceunderscoreownerdot "Example 9-5. Contents
    of the device_owner.xml file")) to */data/system/*. Information about the current
    device owner can be obtained using the `getDeviceOwner()`, `isDeviceOwner()` (which
    is exposed as `isDeviceOwnerApp()` in the Android SDK API) and `getDeviceOwnerName()`
    methods.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 成功调用此方法会将一个 *device_owner.xml* 文件（如 [示例 9-5](ch09.html#contents_of_the_deviceunderscoreownerdot
    "示例 9-5. device_owner.xml 文件的内容") 中的文件）写入到 */data/system/* 目录中。关于当前设备所有者的信息可以通过
    `getDeviceOwner()`、`isDeviceOwner()`（在 Android SDK API 中暴露为 `isDeviceOwnerApp()`）和
    `getDeviceOwnerName()` 方法获取。
- en: Example 9-5. Contents of the device_owner.xml file
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 9-5. device_owner.xml 文件的内容
- en: '[PRE4]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: When a device owner is activated, either as part of the provisioning process
    or by the user, it cannot be disabled and uninstalled, as shown in [Figure 9-3](ch09.html#device_owner_administrator_cannot_be_dis
    "Figure 9-3. A device owner administrator cannot be disabled.").
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 当设备所有者被激活时，无论是作为配置过程的一部分还是由用户手动激活，都无法禁用或卸载，如 [图 9-3](ch09.html#device_owner_administrator_cannot_be_dis
    "图 9-3. 设备所有者管理员无法被禁用。") 所示。
- en: '![A device owner administrator cannot be disabled.](figs/web/09fig03.png.jpg)'
  id: totrans-89
  prefs: []
  type: TYPE_IMG
  zh: '![设备所有者管理员无法被禁用。](figs/web/09fig03.png.jpg)'
- en: Figure 9-3. A device owner administrator cannot be disabled.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9-3. 设备所有者管理员无法被禁用。
- en: Managed Devices
  id: totrans-91
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 管理设备
- en: A device with an owner administrator installed is called a *managed device*,
    and it reacts differently to configuration changes that affect device security
    than unmanaged devices. As discussed in [Chapter 6](ch06.html "Chapter 6. Network
    Security and PKI") and [Chapter 7](ch07.html "Chapter 7. Credential Storage"),
    Android allows users to install certificates in the system trust store either
    via the system Settings application, or by using third-party applications that
    call the `KeyChain` API. If there are user-installed certificates in the system
    trust store, as of version 4.4 Android shows a warning (see [Figure 6-6](ch06.html#network_monitoring_warning_in_android_4d
    "Figure 6-6. Network monitoring warning in Android 4.4")) notifying users that
    their communications can be monitored.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 安装了所有者管理员的设备称为*受管设备*，与未受管设备相比，它对影响设备安全性的配置更改反应不同。如在[第 6 章](ch06.html "Chapter
    6. 网络安全与 PKI")和[第 7 章](ch07.html "Chapter 7. 凭证存储")中所述，Android 允许用户通过系统设置应用或使用调用
    `KeyChain` API 的第三方应用将证书安装到系统信任存储中。如果系统信任存储中有用户安装的证书，从 Android 4.4 版本开始，Android
    会显示警告（见[图 6-6](ch06.html#network_monitoring_warning_in_android_4d "Figure 6-6.
    网络监控警告在 Android 4.4")），提醒用户他们的通信可能被监控。
- en: Enterprise networks often require trusted certificates (for example, the root
    certificate of a corporate PKI) to be installed in order to access enterprise
    services. Such certificates can be silently installed or removed by device administrators
    that hold the `MANAGE_CA_ CERTIFICATES` system permissions via the `installCaCert()`
    and `uninstallCaCert()` methods of the `DevicePolicyManager` class (these methods
    are reserved for system applications and aren’t visible in the public SDK API).
    If an additional trusted certificate is installed on a managed device, the network
    monitoring warning changes to a less scary information message, as shown in [Figure 9-4](ch09.html#network_monitoring_information_message_s
    "Figure 9-4. Network monitoring information message shown on managed devices").
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 企业网络通常要求安装受信证书（例如，企业 PKI 的根证书），才能访问企业服务。设备管理员可以通过 `DevicePolicyManager` 类的 `installCaCert()`
    和 `uninstallCaCert()` 方法（这些方法保留给系统应用，且在公开 SDK API 中不可见）静默安装或删除此类证书。若在受管设备上安装了额外的受信证书，则网络监控警告将变为较不令人担忧的信息消息，如[图
    9-4](ch09.html#network_monitoring_information_message_s "Figure 9-4. 受管设备上显示的网络监控信息消息")所示。
- en: Enterprise Account Integration
  id: totrans-94
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 企业账户集成
- en: 'As mentioned in “[Device Administration](ch09.html#device_administration "Device
    Administration")”, device administrator applications are often coupled with enterprise
    accounts, in order to allow some control over devices that access company data.
    In this section, we’ll discuss two such implementations: one in the stock Email
    application, which works with Microsoft Exchange ActiveSync accounts, and the
    other in the dedicated Google Apps Device Policy application, which works with
    corporate Google accounts.'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 如在“[设备管理](ch09.html#device_administration "Device Administration")”中所述，设备管理员应用程序通常与企业账户配合使用，以便对访问公司数据的设备进行一定的控制。在本节中，我们将讨论两种这样的实现：一种是在内置的电子邮件应用中，它与
    Microsoft Exchange ActiveSync 账户配合使用，另一种是在专用的 Google Apps 设备策略应用中，它与公司 Google
    账户配合使用。
- en: '![Network monitoring information message shown on managed devices](figs/web/09fig04.png.jpg)'
  id: totrans-96
  prefs: []
  type: TYPE_IMG
  zh: '![受管设备上显示的网络监控信息消息](figs/web/09fig04.png.jpg)'
- en: Figure 9-4. Network monitoring information message shown on managed devices
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9-4. 受管设备上显示的网络监控信息消息
- en: Microsoft Exchange ActiveSync
  id: totrans-98
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Microsoft Exchange ActiveSync
- en: '*Microsoft Exchange ActiveSync* (usually abbreviated as *EAS*) is a protocol
    that supports email, contacts, calendar, and task synchronization from a groupware
    server to a mobile device. It’s supported both by Microsoft’s own Exchange Server,
    and by most competing products, including Google Apps.'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: '*Microsoft Exchange ActiveSync*（通常缩写为 *EAS*）是一种协议，支持从组件服务器到移动设备的电子邮件、联系人、日历和任务同步。它不仅支持
    Microsoft 自家的 Exchange Server，还支持大多数竞争产品，包括 Google Apps。'
- en: The Email application included in Android supports ActiveSync accounts and data
    synchronization via dedicated account authenticators (see [Chapter 8](ch08.html
    "Chapter 8. Online Account Management")) and sync adapters. In order to allow
    enterprise administrators to enforce a security policy on devices that access
    email and other corporate data, the Email application doesn’t allow synchronization
    until the built-in device administrator is enabled by the user. The administrator
    can set lockscreen password rules, erase all data, require storage encryption,
    and disable device cameras, as shown in [Figure 9-5](ch09.html#device_administrator_policies_required_f
    "Figure 9-5. Device administrator policies required for using an EAS account").
    However, the policies are not built into the app but fetched from the service
    using the EAS Provision protocol.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: Android中包含的电子邮件应用程序支持ActiveSync账户和通过专用账户认证器（见[第8章](ch08.html "第8章. 在线账户管理")）和同步适配器的数据同步。为了允许企业管理员对访问电子邮件和其他公司数据的设备执行安全策略，电子邮件应用程序在用户启用内置设备管理员之前，不允许进行同步。管理员可以设置锁屏密码规则、擦除所有数据、要求存储加密以及禁用设备摄像头，如[图9-5](ch09.html#device_administrator_policies_required_f
    "图9-5. 使用EAS账户所需的设备管理员策略")所示。然而，这些策略并非内置于应用程序中，而是通过EAS Provision协议从服务中获取。
- en: '![Device administrator policies required for using an EAS account](figs/web/09fig05.png.jpg)'
  id: totrans-101
  prefs: []
  type: TYPE_IMG
  zh: '![使用EAS账户所需的设备管理员策略](figs/web/09fig05.png.jpg)'
- en: Figure 9-5. Device administrator policies required for using an EAS account
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 图9-5. 使用EAS账户所需的设备管理员策略
- en: Google Apps
  id: totrans-103
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Google Apps
- en: The corporate version of Google’s Gmail service, Google Apps, also supports
    setting mobile device security policies. If the feature is enabled by the domain
    administrator, Google Apps account holders can also remotely locate, ring, lock,
    or wipe their Android devices. Domain administrators can also selectively delete
    a Google Apps account and all of its associated content from a managed device,
    without performing a full wipe. Both security policy enforcement and remote device
    management are implemented in the dedicated Google Apps Device Policy application
    (see ➎ in [Example 9-3](ch09.html#contents_of_the_devicesunderscorepolicie "Example 9-3. Contents
    of the devices_policies.xml file")).
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: Google的企业版Gmail服务——Google Apps，也支持设置移动设备的安全策略。如果域管理员启用了此功能，Google Apps账户持有者还可以远程定位、响铃、锁定或擦除其Android设备。域管理员还可以选择性地删除Google
    Apps账户及其所有关联内容，而无需执行完全擦除。安全策略执行和远程设备管理都通过专用的Google Apps设备策略应用实现（见[示例9-3](ch09.html#contents_of_the_devicesunderscorepolicie
    "示例9-3. devices_policies.xml文件内容")中的➎）。
- en: When first started, the application requests that the user enable the built-in
    device administrator and displays the current domain policy settings as shown
    in [Figure 9-6](ch09.html#policy_enforcement_confirmation_in_the_g "Figure 9-6. Policy
    enforcement confirmation in the Google Apps Device Policy application").
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 应用首次启动时，会请求用户启用内置的设备管理员，并显示当前的域策略设置，如[图9-6](ch09.html#policy_enforcement_confirmation_in_the_g
    "图9-6. Google Apps设备策略应用中的策略执行确认")所示。
- en: Domain administrators define policies in the Google Apps admin console (see
    [Figure 9-7](ch09.html#google_apps_device_policy_management_ui "Figure 9-7. Google
    Apps device policy management UI")), and policy settings are pushed to devices
    using Google’s proprietary sync protocol.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 域管理员在Google Apps管理员控制台中定义策略（见[图9-7](ch09.html#google_apps_device_policy_management_ui
    "图9-7. Google Apps设备策略管理UI")），并通过Google的专有同步协议将策略设置推送到设备。
- en: While free Google accounts do not support setting a device policy, Google experience
    devices can use the basic device administrator built into Google Play Services
    (see ➊ in [Example 9-3](ch09.html#contents_of_the_devicesunderscorepolicie "Example 9-3. Contents
    of the devices_policies.xml file")). This administrator allows Google account
    holders to remotely locate or wipe their devices using the Android Device Manager
    website or the associated Android application.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然免费的Google账户不支持设置设备策略，但Google体验设备可以使用内置在Google Play服务中的基本设备管理员（见[示例9-3](ch09.html#contents_of_the_devicesunderscorepolicie
    "示例9-3. devices_policies.xml文件内容")中的➊）。该管理员允许Google账户持有者通过Android设备管理器网站或关联的Android应用程序远程定位或擦除设备。
- en: '![Policy enforcement confirmation in the Google Apps Device Policy application](figs/web/09fig06.png.jpg)'
  id: totrans-108
  prefs: []
  type: TYPE_IMG
  zh: '![Google Apps设备策略应用中的策略执行确认](figs/web/09fig06.png.jpg)'
- en: Figure 9-6. Policy enforcement confirmation in the Google Apps Device Policy
    application
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 图9-6. Google Apps设备策略应用中的策略执行确认
- en: '![Google Apps device policy management UI](figs/web/09fig07.png.jpg)'
  id: totrans-110
  prefs: []
  type: TYPE_IMG
  zh: '![Google应用设备策略管理界面](figs/web/09fig07.png.jpg)'
- en: Figure 9-7. Google Apps device policy management UI
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 图9-7. Google应用设备策略管理界面
- en: VPN Support
  id: totrans-112
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: VPN支持
- en: A *Virtual Private Network (VPN)* allows a private network to be extended across
    a public network without requiring a dedicated physical connection, thus enabling
    all connected devices to send and receive data as if colocated and physically
    connected to the same private network. When a VPN is used to allow individual
    devices to connect to a target private network, it’s referred to as a *remote
    access VPN*, and when used to connect two remote networks, as a *site-to-site
    VPN*.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: '*虚拟专用网络（VPN）*允许将私有网络扩展到公共网络，而无需专用的物理连接，从而使所有连接的设备可以像位于同一私有网络并物理连接一样发送和接收数据。当VPN用于允许单个设备连接到目标私有网络时，称为*远程访问VPN*，而用于连接两个远程网络时，称为*站点对站点VPN*。'
- en: Remote-access VPNs can connect fixed devices with a static IP address, such
    as a computer in a remote office, but configurations where mobile clients use
    variable network connections and dynamic addresses are much more common. Such
    a configuration is often called a *road warrior* configuration and is the configuration
    most commonly used with Android VPN clients.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 远程访问VPN可以连接具有静态IP地址的固定设备，例如远程办公室中的计算机，但移动客户端使用可变网络连接和动态地址的配置更为常见。这种配置通常被称为*路上战士*配置，也是Android
    VPN客户端最常使用的配置。
- en: In order to ensure that data transmitted over a VPN remains private, VPNs typically
    authenticate remote clients and provide data confidentiality and integrity by
    using a secure tunneling protocol. VPN protocols are complex because they work
    at multiple network layers simultaneously and often involve multiple levels of
    encapsulation in order to be compatible with various network configurations. A
    thorough discussion of them is beyond the scope of his book, but in the following
    sections you’ll find a brief overview of the major types of VPN protocols, with
    a focus on the ones available on Android.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 为了确保通过VPN传输的数据保持私密，VPN通常会对远程客户端进行身份验证，并通过使用安全隧道协议提供数据的机密性和完整性。VPN协议非常复杂，因为它们同时在多个网络层上工作，并且通常涉及多个级别的封装，以便与各种网络配置兼容。对它们的详细讨论超出了本书的范围，但在接下来的章节中，你将看到主要VPN协议类型的简要概述，重点介绍适用于Android的协议。
- en: PPTP
  id: totrans-116
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: PPTP
- en: The *Point-to-Point Tunneling Protocol (PPTP)* uses a TCP control channel to
    establish connections and the Generic Routing Encapsulation (GRE) tunneling protocol
    to encapsulate Point-to-Point Protocol (PPP) packets. Several authentication methods
    such as Password Authentication Protocol (PAP), Challenge-Handshake Authentication
    Protocol (CHAP), and its Microsoft extension MS-CHAP v1/v2, as well as EAP-TLS,
    are supported, but only EAP-TLS is currently considered secure.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: '*点对点隧道协议（PPTP）*使用TCP控制通道来建立连接，并使用通用路由封装（GRE）隧道协议来封装点对点协议（PPP）数据包。支持多种认证方法，如密码认证协议（PAP）、挑战握手认证协议（CHAP）、其Microsoft扩展MS-CHAP
    v1/v2，以及EAP-TLS，但目前只有EAP-TLS被认为是安全的。'
- en: The PPP payload can be encrypted using the Microsoft Point-to-Point Encryption
    (MPPE) protocol, which uses the RC4 stream cipher. Because MPPE does not employ
    any form of ciphertext authentication, it is vulnerable to bit-flipping attacks.
    In addition, multiple problems with the RC4 cipher have been uncovered in recent
    years, which further reduces the security of MMPE and PPTP.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: PPP有效负载可以使用Microsoft点对点加密（MPPE）协议进行加密，该协议使用RC4流密码。由于MPPE不使用任何形式的密文认证，它容易受到位翻转攻击。此外，近年来已经揭示出多个RC4密码的漏洞，这进一步降低了MMPE和PPTP的安全性。
- en: L2TP/IPSec
  id: totrans-119
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: L2TP/IPSec
- en: The *Layer 2 Tunneling Protocol (L2TP)* is similar to PPTP and exists at the
    data link layer (Layer 2 in the OSI model). Because L2TP provides no encryption
    or confidentiality of its own (it relies on the tunneled protocol to implement
    these features), an L2TP VPN is typically implemented using a combination of L2TP
    and the Internet Protocol Security (IPSec) protocol suite, which adds authentication,
    confidentiality, and integrity.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: '*第二层隧道协议（L2TP）*类似于PPTP，并位于数据链路层（OSI模型中的第二层）。由于L2TP本身不提供加密或机密性（它依赖于隧道协议来实现这些功能），因此L2TP
    VPN通常使用L2TP和互联网协议安全（IPSec）协议套件的组合来实现，这样可以添加认证、机密性和完整性。'
- en: In an L2TP/IPSec configuration, a secure channel is first established using
    IPSec, and an L2TP tunnel is then established over the secure channel. L2TP packets
    are always wrapped inside IPSec packets and are therefore secure. An IPSec connection
    requires establishing a *Security Association (SA)*, which is a combination of
    cryptographic algorithm and mode, encryption key, and other parameters required
    to establish a secure channel.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 在 L2TP/IPSec 配置中，首先通过 IPSec 建立一个安全通道，然后在该安全通道上建立 L2TP 隧道。L2TP 数据包始终被封装在 IPSec
    数据包中，因此是安全的。IPSec 连接需要建立一个 *安全关联（SA）*，它是加密算法和模式、加密密钥以及建立安全通道所需的其他参数的组合。
- en: SAs are established using the Internet Security Association and Key Management
    Protocol (ISAKMP). ISAKMP does not define a particular key exchange method and
    is typically implemented either by manual configuration of pre-shared secrets,
    or by using the Internet Key Exchange (IKE and IKEv2) protocol. IKE uses X.509
    certificates for peer authentication (much like SSL), and a Diffie-Hellman key
    exchange in order to establish a shared secret, which is used to derive the actual
    session encryption keys.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 安全关联（SA）是通过互联网安全关联与密钥管理协议（ISAKMP）建立的。ISAKMP 并不定义特定的密钥交换方法，通常是通过手动配置预共享密钥，或者通过使用互联网密钥交换（IKE
    和 IKEv2）协议来实现。IKE 使用 X.509 证书进行对等身份验证（类似于 SSL），并使用 Diffie-Hellman 密钥交换来建立共享密钥，该共享密钥用于派生实际的会话加密密钥。
- en: IPSec Xauth
  id: totrans-123
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: IPSec Xauth
- en: '*IPSec Extended Authentication (Xauth)* extends IKE to include additional user
    authentication exchanges. This allows an existing user database or a RADIUS infrastructure
    to be used to authenticate remote access clients, and makes it possible to integrate
    two-factor authentication.'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: '*IPSec 扩展认证（Xauth）* 扩展了 IKE，增加了额外的用户认证交换。这使得现有的用户数据库或 RADIUS 基础设施可以用于认证远程访问客户端，并且能够集成双因素认证。'
- en: '*Mode-configuration (Modecfg)* is another IPSec extension that is often used
    in a remote access scenario. Modecfg allows VPN servers to push network configuration
    information such as the private IP address and DNS server addresses to clients.
    When used in combination, Xauth and Modecfg make it possible to create a pure-IPSec
    VPN solution, which doesn’t rely on additional protocols for authentication and
    tunneling.'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: '*模式配置（Modecfg）* 是另一个 IPSec 扩展，通常在远程访问场景中使用。Modecfg 允许 VPN 服务器将网络配置信息（如私有 IP
    地址和 DNS 服务器地址）推送给客户端。当 Xauth 和 Modecfg 结合使用时，可以创建一个纯粹的 IPSec VPN 解决方案，该方案不依赖于额外的协议进行认证和隧道化。'
- en: SSL-Based VPNs
  id: totrans-126
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 基于 SSL 的 VPN
- en: SSL-based VPNs use SSL or TLS (see [Chapter 6](ch06.html "Chapter 6. Network
    Security and PKI")) to establish a secure connection and tunnel network traffic.
    No single standard defines SSL-based VPNs, and different implementations use different
    strategies in order to establish a secure channel and encapsulate packets.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 基于 SSL 的 VPN 使用 SSL 或 TLS（见[第 6 章](ch06.html "第 6 章. 网络安全与公钥基础设施")）来建立安全连接并隧道网络流量。没有单一的标准定义基于
    SSL 的 VPN，不同的实现使用不同的策略来建立安全通道并封装数据包。
- en: OpenVPN is a popular open source application that uses SSL for authentication
    and key exchange (preconfigured shared static keys are also supported), and a
    custom encryption protocol^([[90](#ftn.ch09fn04)]) to encrypt and authenticate
    packets. OpenVPN multiplexes the SSL session used for authentication and key exchange,
    and the encrypted packets stream over a single UDP (or TCP) port. The multiplexing
    protocol provides a reliable transport layer for SSL on top of UDP, but it tunnels
    encrypted IP packets over UDP without adding reliability. Reliability is provided
    by the tunneled protocol itself, which is usually TCP.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: OpenVPN 是一个流行的开源应用程序，使用 SSL 进行身份验证和密钥交换（也支持预配置的共享静态密钥），并使用自定义加密协议^([[90](#ftn.ch09fn04)])来加密和认证数据包。OpenVPN
    复用用于身份验证和密钥交换的 SSL 会话，且加密数据包通过单一的 UDP（或 TCP）端口流动。复用协议为 SSL 提供了基于 UDP 的可靠传输层，但它通过
    UDP 隧道加密的 IP 数据包时不增加可靠性。可靠性由隧道协议本身提供，通常是 TCP。
- en: The main advantages of OpenVPN over IPSec are that it is much simpler and can
    be implemented entirely in userspace. IPSec, on the other hand, requires kernel-level
    support and implementation of multiple interoperating protocols. Additionally,
    it’s easier to get OpenVPN traffic through firewalls, NAT, and proxies because
    it uses the common network protocols TCP and UDP and can multiplex tunneled traffic
    over a single port.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: OpenVPN 相对于 IPSec 的主要优点在于它更简单，且可以完全在用户空间实现。另一方面，IPSec 需要内核级支持并实现多个相互操作的协议。此外，OpenVPN
    更容易通过防火墙、NAT 和代理，因为它使用常见的网络协议 TCP 和 UDP，并且可以通过单个端口复用隧道流量。
- en: The following sections examine Android’s built-in VPN support and the APIs it
    provides for applications that want to implement additional VPN solutions. We’ll
    also review the components that make up Android’s VPN infrastructure and show
    how it protects VPN credentials.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 以下章节将探讨 Android 的内建 VPN 支持及其为希望实现额外 VPN 解决方案的应用程序提供的 API。我们还将回顾构成 Android VPN
    基础设施的组件，并展示它是如何保护 VPN 凭证的。
- en: Legacy VPN
  id: totrans-131
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 传统 VPN
- en: Prior to Android 4.0, VPN support was entirely built into the platform and wasn’t
    extensible. Support for new VPN types could only be added as part of platform
    updates. To distinguish it from application-based implementations, built-in VPN
    support is referred to as *legacy VPN*.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Android 4.0 之前，VPN 支持完全内建在平台中，无法扩展。新增的 VPN 类型只能作为平台更新的一部分添加。为了与基于应用的实现区分，内建的
    VPN 支持被称为 *传统 VPN*。
- en: Early Android versions supported different VPN configurations based on PPTP
    and L2TP/IPsec, with support for “pure-IPSec” VPNs using IPSec Xauth added in
    version 4.0\. In addition to new built-in VPN configurations, Android 4.0 also
    introduced application-based VPNs by supplying the base platform class `VpnService`,
    which applications could extend in order to implement a new VPN solution.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 早期的 Android 版本支持基于 PPTP 和 L2TP/IPsec 的不同 VPN 配置，并且在 4.0 版本中增加了对“纯-IPSec” VPN
    的支持，通过 IPSec Xauth 实现。此外，Android 4.0 还通过提供基础平台类 `VpnService`，引入了基于应用的 VPN，使应用程序能够扩展这一类，以实现新的
    VPN 解决方案。
- en: Legacy VPN is controlled via the system Settings application and is only available
    to the owner (also called the primary user) on multi-user devices. [Figure 9-8](ch09.html#legacy_vpn_profile_definition_dialog
    "Figure 9-8. Legacy VPN profile definition dialog") shows the dialog for adding
    a new IPSec legacy VPN profile.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 传统 VPN 通过系统设置应用程序进行控制，仅对多用户设备中的所有者（也称为主用户）可用。[图 9-8](ch09.html#legacy_vpn_profile_definition_dialog
    "图 9-8. 传统 VPN 配置文件定义对话框") 显示了添加新 IPSec 传统 VPN 配置文件的对话框。
- en: Implementation
  id: totrans-135
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 实现
- en: '![Legacy VPN profile definition dialog](figs/web/09fig08.png.jpg)'
  id: totrans-136
  prefs: []
  type: TYPE_IMG
  zh: '![传统 VPN 配置文件定义对话框](figs/web/09fig08.png.jpg)'
- en: Figure 9-8. Legacy VPN profile definition dialog
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9-8. 传统 VPN 配置文件定义对话框
- en: Legacy VPNs are implemented using a combination of kernel drivers as well as
    native daemons, commands, and system services. The lower-level implementation
    of PPTP and L2TP tunneling uses an Android-specific PPP daemon called *mtpd* and
    the PPPoPNS and PPPoLAC (only available in Android kernels) kernel drivers.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 传统 VPN 是通过组合内核驱动程序以及原生守护进程、命令和系统服务实现的。PPTP 和 L2TP 隧道的底层实现使用了一种 Android 特有的 PPP
    守护进程，名为 *mtpd*，以及 PPPoPNS 和 PPPoLAC（仅在 Android 内核中可用）内核驱动程序。
- en: Because legacy VPNs support only a single VPN connection per device, *mtpd*
    can create only a single session. IPSec VPNs leverage the built-in kernel support
    for IPSec and a modified *racoon* IKE key management daemon (part of the IPSec-Tools^([[91](#ftn.ch09fn05)])
    utilities package that complements the Linux kernel IPSec implementation; *racoon*
    supports only IKEv1). [Example 9-6](ch09.html#racoon_and_mtpd_definition_in_initdotrc
    "Example 9-6. racoon and mtpd definition in init.rc") shows how these two daemons
    are defined in *init.rc*.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 因为传统 VPN 每个设备只支持一个 VPN 连接，*mtpd* 只能创建一个会话。IPSec VPN 利用内建的内核支持和修改过的 *racoon*
    IKE 密钥管理守护进程（这是 IPSec-Tools^([[91](#ftn.ch09fn05)]) 工具包的一部分，补充了 Linux 内核的 IPSec
    实现；*racoon* 仅支持 IKEv1）。[示例 9-6](ch09.html#racoon_and_mtpd_definition_in_initdotrc
    "示例 9-6. racoon 和 mtpd 在 init.rc 中的定义") 显示了这两个守护进程在 *init.rc* 中的定义方式。
- en: Example 9-6. racoon and mtpd definition in init.rc
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 9-6. racoon 和 mtpd 在 init.rc 中的定义
- en: '[PRE5]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Both *racoon* ➊ and *mtpd* ➍ create control sockets (➋ and ➎), which are only
    accessible by the *system* user and are not started by default. Both daemons have
    *vpn*, *net_admin* (mapped by the kernel to the `CAP_NET_ADMIN` Linux capability),
    and *inet* added to their supplementary groups (➌ and ➏), which allow them to
    create sockets and control network interface devices. The *mtpd* daemon also receives
    the *net_raw* group (mapped to the `CAP_NET_RAW` Linux capability), which allows
    it to create GRE sockets (used by PPTP).
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: '*racoon* ➊ 和 *mtpd* ➍ 都会创建控制套接字（➋ 和 ➎），这些套接字仅限 *system* 用户访问，并且默认情况下不会启动。两个守护进程都将
    *vpn*、*net_admin*（由内核映射到 `CAP_NET_ADMIN` Linux 能力）和 *inet* 添加到它们的附加组（➌ 和 ➏），这允许它们创建套接字并控制网络接口设备。*mtpd*
    守护进程还接收 *net_raw* 组（映射到 `CAP_NET_RAW` Linux 能力），这使它能够创建 GRE 套接字（PPTP 使用的套接字）。'
- en: When a VPN is started via the system Settings app, Android starts the *racoon*
    and *mtpd* daemons and sends them control commands via their local sockets in
    order to establish the configured connection. The daemons create the requested
    VPN tunnel, and then create and configure a tunnel network interface with the
    received IP address and network mask. While *mtpd* performs interface configuration
    internally, *racoon* uses the helper command `ip-up-vpn` to bring up the tunnel
    interface, which is usually *tun0*.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 当通过系统设置应用启动 VPN 时，Android 启动 *racoon* 和 *mtpd* 守护进程，并通过它们的本地套接字发送控制命令，以建立配置的连接。守护进程创建请求的
    VPN 隧道，然后使用接收到的 IP 地址和网络掩码创建并配置隧道网络接口。虽然 *mtpd* 在内部执行接口配置，但 *racoon* 使用辅助命令 `ip-up-vpn`
    来启动隧道接口，通常是 *tun0*。
- en: In order to communicate connection parameters back to the framework, VPN daemons
    write a *state* file in */data/misc/vpn/* as shown in [Example 9-7](ch09.html#contents_of_the_vpn_state_file
    "Example 9-7. Contents of the VPN state file").
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 为了将连接参数传回框架，VPN 守护进程在 */data/misc/vpn/* 路径下写入 *state* 文件，如 [示例 9-7](ch09.html#contents_of_the_vpn_state_file
    "示例 9-7. VPN 状态文件内容") 所示。
- en: Example 9-7. Contents of the VPN state file
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 9-7. VPN 状态文件内容
- en: '[PRE6]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The file contains the tunnel interface name ➊, its IP address and mask ➋, configured
    routes ➌, DNS servers ➍, and search domains ➎, with each on a new line.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 文件包含隧道接口名称 ➊、其 IP 地址和掩码 ➋、配置的路由 ➌、DNS 服务器 ➍ 和搜索域 ➎，每个项都占一行。
- en: After the VPN daemons start running, the framework parses the *state* file and
    calls the system `ConnectivityService` in order to configure routing, DNS servers,
    and search domains for the newly established VPN connection. In turn, `ConnectivityService`
    sends control commands via the local control socket of the *netd* daemon, which
    can modify the kernel’s packet filtering and routing tables because it runs as
    root. Traffic from all applications started by the owner user and restricted profiles
    is routed through the VPN interface by adding a firewall rule that matches the
    application UID and corresponding routing rules. (We discuss per-application traffic
    routing and multi-user support in detail in “[Multi-User Support](ch09.html#multi-user_support-id00019
    "Multi-User Support")”).
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 在 VPN 守护进程启动后，框架解析 *state* 文件，并调用系统 `ConnectivityService` 来配置新建立的 VPN 连接的路由、DNS
    服务器和搜索域。随后，`ConnectivityService` 通过 *netd* 守护进程的本地控制套接字发送控制命令，因其以 root 身份运行，可以修改内核的包过滤和路由表。来自所有由所有者用户和受限配置文件启动的应用程序的流量，通过添加匹配应用程序
    UID 和相应路由规则的防火墙规则，路由到 VPN 接口。（我们在 “[Multi-User Support](ch09.html#multi-user_support-id00019
    "Multi-User Support")” 中详细讨论了每个应用程序流量路由和多用户支持。）
- en: Profile and Credential Storage
  id: totrans-149
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 配置文件和凭证存储
- en: Each VPN configuration created via the Settings app is called a *VPN profile*
    and is saved on disk in encrypted form. Encryption is performed by the Android
    credential storage daemon *keystore*, with a device-specific key. (See [Chapter 7](ch07.html
    "Chapter 7. Credential Storage") for more on credential storage implementation.)
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 通过设置应用创建的每个 VPN 配置称为 *VPN 配置文件*，并以加密形式保存在磁盘上。加密由 Android 凭证存储守护进程 *keystore*
    执行，并使用设备特定的密钥。（有关凭证存储实现的更多信息，请参见 [第 7 章](ch07.html "第 7 章. 凭证存储")）。
- en: 'VPN profiles are serialized by concatenating all configured properties, which
    are delimited by a *NUL* character (*\0*) in a single profile string that is saved
    to the system keystore as a binary blob. VPN profile filenames are generated by
    appending the current time in milliseconds (in hexadecimal format) to the *VPN_*
    prefix. For example, [Example 9-8](ch09.html#contents_of_the_keystore_directory_when
    "Example 9-8. Contents of the keystore directory when VPN profiles are configured")
    shows the *keystore* directory of a user with three configured VPN profiles (file
    timestamps omitted):'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: VPN 配置文件是通过将所有配置属性串联起来序列化的，这些属性由 *NUL* 字符（*\0*）分隔，并保存在系统密钥库中作为二进制大对象。VPN 配置文件的文件名是通过将当前时间的毫秒数（以十六进制格式）附加到
    *VPN_* 前缀来生成的。例如，[示例 9-8](ch09.html#contents_of_the_keystore_directory_when "示例
    9-8. 配置 VPN 配置文件时的密钥库目录内容") 展示了一个用户的 *keystore* 目录，其中有三个已配置的 VPN 配置文件（文件时间戳已省略）：
- en: Example 9-8. Contents of the `keystore` directory when VPN profiles are configured
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 9-8. 配置 VPN 配置文件时的 `keystore` 目录内容
- en: '[PRE7]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The three VPN profiles are stored in the *1000_VPN_144965b85a6* ➎, *1000_VPN_145635c88c8*
    ➏, and *1000_VPN_14569512c80* ➐ files. The *1000_* prefix represents the owner
    user, which is *system* (UID 1000). Because VPN profiles are owned by the *system*
    user, only system applications can retrieve and decrypt profile contents.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 这三个 VPN 配置文件分别存储在 *1000_VPN_144965b85a6* ➎、*1000_VPN_145635c88c8* ➏ 和 *1000_VPN_14569512c80*
    ➐ 文件中。*1000_* 前缀表示拥有者用户为 *system*（UID 1000）。由于 VPN 配置文件归 *system* 用户所有，只有系统应用程序可以检索和解密配置文件内容。
- en: '[Example 9-9](ch09.html#contents_of_vpn_profile_files "Example 9-9. Contents
    of VPN profile files") shows the decrypted contents of the three VPN profile files.
    (The *NUL* character has been replaced with vertical bar [`|`] for readability.)'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 9-9](ch09.html#contents_of_vpn_profile_files "示例 9-9. VPN 配置文件的内容") 展示了三个
    VPN 配置文件的解密内容。（*NUL* 字符已被竖线 [`|`] 替换以提高可读性。）'
- en: Example 9-9. Contents of VPN profile files
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 9-9. VPN 配置文件的内容
- en: '[PRE8]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The profile files contain all fields shown in the VPN profile edit dialog (see
    [Figure 9-8](ch09.html#legacy_vpn_profile_definition_dialog "Figure 9-8. Legacy
    VPN profile definition dialog")), with missing properties represented by an empty
    string. The first five fields represent the name of the VPN, the type of VPN,
    the VPN gateway host, the username, and the password, respectively. In [Example 9-9](ch09.html#contents_of_vpn_profile_files
    "Example 9-9. Contents of VPN profile files"), the first VPN profile ➊ is for
    an L2TP/IPsec VPN with pre-shared key (type 1); the second profile ➋ is for a
    PPTP VPN (type 0), and the last one ➌ is for a IPSec VPN that uses certificates
    and Xauth authentication (type 4).
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 配置文件包含在 VPN 配置文件编辑对话框中显示的所有字段（见[图 9-8](ch09.html#legacy_vpn_profile_definition_dialog
    "图 9-8. 旧版 VPN 配置文件定义对话框")），缺失的属性用空字符串表示。前五个字段分别表示 VPN 的名称、VPN 类型、VPN 网关主机、用户名和密码。在[示例
    9-9](ch09.html#contents_of_vpn_profile_files "示例 9-9. VPN 配置文件的内容")中，第一个 VPN 配置文件
    ➊ 是用于 L2TP/IPsec VPN 的预共享密钥（类型 1）；第二个配置文件 ➋ 是用于 PPTP VPN 的（类型 0），最后一个配置文件 ➌ 是用于使用证书和
    Xauth 身份验证的 IPSec VPN（类型 4）。
- en: In addition to the username and password, VPN profile files also contain all
    other credentials required to connect to the VPN. In the case of the first VPN
    profile ➊ in [Example 9-9](ch09.html#contents_of_vpn_profile_files "Example 9-9. Contents
    of VPN profile files"), the additional credential is the pre-shared key required
    to establish an IPSec secure connection (represented by the *PSK* string in this
    example). In the case of the third profile ➌, the additional credentials are the
    user’s private key and certificate. However, as you can see in the listing, the
    full key and certificate are not included; instead, the profile contains only
    the alias (*vpnclient*) of the key and certificate (both share a common alias).
    The private key and certificate are stored in the system credential store, and
    the alias included in the VPN profile serves only as an identifier, which is used
    to access or retrieve the key and certificate.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 除了用户名和密码外，VPN 配置文件还包含连接到 VPN 所需的所有其他凭据。在[示例 9-9](ch09.html#contents_of_vpn_profile_files
    "示例 9-9. VPN 配置文件的内容")中的第一个 VPN 配置文件 ➊ 中，额外的凭据是用于建立 IPSec 安全连接的预共享密钥（在本示例中由 *PSK*
    字符串表示）。在第三个配置文件 ➌ 中，额外的凭据是用户的私钥和证书。然而，正如你在列表中看到的，完整的密钥和证书并未包含在内；相反，配置文件仅包含密钥和证书的别名（*vpnclient*）（二者共享相同的别名）。私钥和证书存储在系统凭据库中，VPN
    配置文件中包含的别名仅作为标识符，用于访问或检索密钥和证书。
- en: Accessing Credentials
  id: totrans-160
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 访问凭据
- en: The *racoon* daemon, which originally used keys and certificates stored in PEM
    files, was modified to use Android’s *keystore* OpenSSL engine. As discussed in
    [Chapter 7](ch07.html "Chapter 7. Credential Storage"), the *keystore* engine
    is a gateway to the system credential store, which can take advantage of hardware-backed
    credential store implementations when available. When passed a key alias, it uses
    the corresponding private key to sign authentication packets, without extracting
    the key from the keystore.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: '*racoon* 守护进程最初使用存储在 PEM 文件中的密钥和证书，后来修改为使用 Android 的 *keystore* OpenSSL 引擎。如[第
    7 章](ch07.html "第 7 章. 凭证存储")所讨论，*keystore* 引擎是系统凭证存储的网关，当有硬件支持的凭证存储实现时，它可以利用这些硬件支持的实现。当传递一个密钥别名时，它使用相应的私钥来签名认证数据包，而无需从密钥库中提取密钥。'
- en: The VPN profile ➌ in [Example 9-9](ch09.html#contents_of_vpn_profile_files "Example 9-9. Contents
    of VPN profile files") also contains the alias of the CA certificate (*cacert*),
    which is used as a trust anchor when validating the server’s certificate. At runtime,
    the framework retrieves the client certificate (➌ in [Example 9-8](ch09.html#contents_of_the_keystore_directory_when
    "Example 9-8. Contents of the keystore directory when VPN profiles are configured"))
    and the CA certificate (➊ in [Example 9-8](ch09.html#contents_of_the_keystore_directory_when
    "Example 9-8. Contents of the keystore directory when VPN profiles are configured"))
    from the system keystore and passes them to *racoon* via the control socket, along
    with other connection parameters. The private key blob (➍ in [Example 9-8](ch09.html#contents_of_the_keystore_directory_when
    "Example 9-8. Contents of the keystore directory when VPN profiles are configured"))
    is never directly passed to the *racoon* daemon, only its alias (*vpnclient*).
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 在[示例 9-9](ch09.html#contents_of_vpn_profile_files "示例 9-9. VPN 配置文件内容")中的 VPN
    配置文件 ➌ 还包含了 CA 证书的别名 (*cacert*)，该别名用于在验证服务器证书时作为信任锚点。在运行时，框架从系统密钥库中检索客户端证书（➌ 在
    [示例 9-8](ch09.html#contents_of_the_keystore_directory_when "示例 9-8. 当配置 VPN 配置文件时密钥库目录的内容")中）和
    CA 证书（➊ 在 [示例 9-8](ch09.html#contents_of_the_keystore_directory_when "示例 9-8.
    当配置 VPN 配置文件时密钥库目录的内容")中），并将它们与其他连接参数一起通过控制套接字传递给 *racoon*。私钥 Blob（➍ 在 [示例 9-8](ch09.html#contents_of_the_keystore_directory_when
    "示例 9-8. 当配置 VPN 配置文件时密钥库目录的内容")中）从未直接传递给 *racoon* 守护进程，只有其别名 (*vpnclient*) 被传递。
- en: Note
  id: totrans-163
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '*While private keys are protected by hardware on devices with a hardware-backed
    keystore, pre-shared keys or passwords stored in a VPN profile content are not.
    The reason for this is that as of this writing, Android doesn’t support importing
    symmetric keys in the hardware-backed keystore; it only supports asymmetric keys
    (RSA, DSA, and EC). As a result, credentials for VPNs that use pre-shared keys
    are stored in the VPN profile in plaintext form and can be extracted from devices
    that allow root access after the profile is decrypted on memory.*'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: '*虽然私钥在具有硬件支持的密钥库的设备上受到硬件保护，但存储在 VPN 配置文件中的预共享密钥或密码并不受到保护。原因在于，直到目前为止，Android
    并不支持在硬件支持的密钥库中导入对称密钥；它仅支持非对称密钥（RSA、DSA 和 EC）。因此，使用预共享密钥的 VPN 凭证以明文形式存储在 VPN 配置文件中，并且可以在配置文件解密后，从允许
    root 权限的设备中提取。*'
- en: Always-On VPN
  id: totrans-165
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 始终开启 VPN
- en: Android 4.2 and later supports an *always-on* VPN configuration, which blocks
    all network connections from applications until a connection to the specified
    VPN profile is established. This prevents applications from sending data across
    insecure channels, such as public Wi-Fi networks.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: Android 4.2 及更高版本支持 *始终开启* VPN 配置，这会阻止应用程序的所有网络连接，直到与指定的 VPN 配置文件建立连接为止。这可以防止应用程序通过不安全的通道（例如公共
    Wi-Fi 网络）发送数据。
- en: Setting up an always-on VPN requires setting up a VPN profile that specifies
    the VPN gateway as an IP address, and specifies an explicit DNS server IP address.
    This explicit configuration is required in order to make sure that DNS traffic
    isn’t sent to the locally configured DNS server, which is blocked when an always-on
    VPN is in effect. The VPN profile selection dialog is shown in [Figure 9-9](ch09.html#always-on_vpn_profile_selection_dialog
    "Figure 9-9. Always-on VPN profile selection dialog").
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 设置始终开启的 VPN 需要设置一个 VPN 配置文件，指定 VPN 网关的 IP 地址，并指定一个明确的 DNS 服务器 IP 地址。此明确配置是为了确保
    DNS 流量不会发送到本地配置的 DNS 服务器，因为在始终开启的 VPN 生效时，DNS 请求会被阻止。VPN 配置文件选择对话框显示在[图 9-9](ch09.html#always-on_vpn_profile_selection_dialog
    "图 9-9. 始终开启的 VPN 配置文件选择对话框")中。
- en: The profile selection is saved with other VPN profiles in the encrypted file
    *LOCKDOWN_VPN* (➋ in [Example 9-8](ch09.html#contents_of_the_keystore_directory_when
    "Example 9-8. Contents of the keystore directory when VPN profiles are configured"))
    which contains only the name of the selected profile; in our example, *144965b85a6*.
    If the *LOCKDOWN_VPN* file is present, the system automatically connects to the
    specified VPN when the device boots. If the underlying network connection reconnects
    or changes (for example, when switching Wi-Fi hotspots), the VPN is automatically
    restarted.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 配置文件选择与其他 VPN 配置文件一起保存在加密文件 *LOCKDOWN_VPN* 中（[示例 9-8](ch09.html#contents_of_the_keystore_directory_when
    "示例 9-8. 配置 VPN 配置文件时密钥存储目录的内容") 中的 ➋），该文件仅包含所选配置文件的名称；在我们的示例中是 *144965b85a6*。如果
    *LOCKDOWN_VPN* 文件存在，系统在设备启动时会自动连接到指定的 VPN。如果底层网络连接重新连接或发生更改（例如切换 Wi-Fi 热点），VPN
    会自动重新启动。
- en: '![Always-on VPN profile selection dialog](figs/web/09fig09.png.jpg)'
  id: totrans-169
  prefs: []
  type: TYPE_IMG
  zh: '![始终开启 VPN 配置文件选择对话框](figs/web/09fig09.png.jpg)'
- en: Figure 9-9. Always-on VPN profile selection dialog
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9-9. 始终开启 VPN 配置文件选择对话框
- en: An always-on VPN guarantees that all traffic goes through the VPN by installing
    firewall rules that block all packets except those which go through the VPN interface.
    The rules are installed by the `LockdownVpnTracker` class (always-on VPN is referred
    to as *lockdown VPN* in Android source code), which monitors VPN state and adjusts
    the current firewall state by sending commands to the *netd* daemon, which in
    turn executes the `iptables` utility in order to modify the kernels packet filtering
    tables. For example, when an always-on L2TP/IPSec VPN has connected to a VPN server
    with IP address 11.22.33.44 and has created a tunnel interface *tun0* with IP
    address 10.1.1.1, the installed firewall rules (as reported by `iptables`; some
    columns have been omitted for brevity) might look like [Example 9-10](ch09.html#always-on_vpn_firewall_rules
    "Example 9-10. Always-on VPN firewall rules").
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 始终开启的 VPN 通过安装防火墙规则，确保所有流量都通过 VPN。这些规则会阻止所有数据包，除了那些通过 VPN 接口的。规则由 `LockdownVpnTracker`
    类安装（在 Android 源代码中，始终开启的 VPN 称为 *lockdown VPN*），该类监控 VPN 状态，并通过向 *netd* 守护进程发送命令来调整当前的防火墙状态，后者执行
    `iptables` 工具，以修改内核的包过滤表。例如，当一个始终开启的 L2TP/IPSec VPN 连接到 IP 地址为 11.22.33.44 的 VPN
    服务器，并且创建了一个 IP 地址为 10.1.1.1 的隧道接口 *tun0* 时，安装的防火墙规则（由 `iptables` 报告；为了简洁，某些列已省略）可能如下所示：[示例
    9-10](ch09.html#always-on_vpn_firewall_rules "示例 9-10. 始终开启的 VPN 防火墙规则")。
- en: Example 9-10. Always-on VPN firewall rules
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 9-10. 始终开启 VPN 防火墙规则
- en: '[PRE9]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: As you can see in the listing, all traffic to and from the VPN network is allowed
    (➊ and ➎), as is all traffic on the tunnel interface (➋ and ➏). Traffic to and
    from the VPN server (➌ and ➐) is allowed only on the ports used by IPSec (500
    and 4500) and L2TP (1701). All other incoming traffic is dropped ➍, and all other
    outgoing traffic is rejected ➑.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 如您在列表中看到的，所有来自 VPN 网络的流量（➊ 和 ➎）和隧道接口上的所有流量（➋ 和 ➏）都是允许的。仅允许通过 IPSec（500 和 4500）和
    L2TP（1701）端口的 VPN 服务器流量（➌ 和 ➐）。所有其他传入流量会被丢弃 ➍，所有其他传出流量会被拒绝 ➑。
- en: Application-Based VPNs
  id: totrans-175
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 基于应用程序的 VPN
- en: Android 4.0 added a `VpnService` public API^([[92](#ftn.ch09fn06)]) that third-party
    applications can use to build VPN solutions that are neither built into the OS
    nor require system-level permissions. The `VpnService` and associated `Builder`
    class let applications specify network parameters such as interface IP address
    and routes, which the system uses to create and configure a virtual network interface.
    Applications receive a file descriptor associated with that network interface
    and can tunnel network traffic by reading from or writing to the file descriptor
    of the interface.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: Android 4.0 添加了 `VpnService` 公共 API^([[92](#ftn.ch09fn06)])，第三方应用程序可以利用该 API
    构建既不是操作系统内建的，也不需要系统级权限的 VPN 解决方案。`VpnService` 及其关联的 `Builder` 类允许应用程序指定网络参数，如接口
    IP 地址和路由，系统使用这些参数来创建和配置虚拟网络接口。应用程序会接收到与该网络接口关联的文件描述符，并且可以通过读取或写入接口的文件描述符来进行网络流量隧道传输。
- en: Each read retrieves an outgoing IP packet, and each write injects an incoming
    IP packet. Because raw access to network packets effectively lets applications
    intercept and modify network traffic, application-based VPNs cannot be started
    automatically and always require user interaction. Additionally, an ongoing notification
    is shown while a VPN is connected. The connection warning dialog for an application-based
    VPN might look like [Figure 9-10](ch09.html#application-based_vpn_connection_warning
    "Figure 9-10. Application-based VPN connection warning dialog").
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 每次读取时会检索一个外发的IP数据包，每次写入时会注入一个入站的IP数据包。由于对网络数据包的原始访问实际上允许应用拦截和修改网络流量，因此基于应用的VPN不能自动启动，并始终需要用户交互。此外，在VPN连接时，会显示一个持续的通知。基于应用的VPN连接警告对话框可能如[图
    9-10](ch09.html#application-based_vpn_connection_warning "图 9-10. 基于应用的VPN连接警告对话框")所示。
- en: '![Application-based VPN connection warning dialog](figs/web/09fig10.png.jpg)'
  id: totrans-178
  prefs: []
  type: TYPE_IMG
  zh: '![基于应用的VPN连接警告对话框](figs/web/09fig10.png.jpg)'
- en: Figure 9-10. Application-based VPN connection warning dialog
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9-10. 基于应用的VPN连接警告对话框
- en: Declaring a VPN
  id: totrans-180
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 声明一个VPN
- en: An application-based VPN is implemented by creating a service component that
    extends the `VpnService` base class and registering it in the application manifest,
    as shown in [Example 9-11](ch09.html#registering_a_vpn_service_in_the_applica
    "Example 9-11. Registering a VPN service in the application manifest").
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 基于应用的VPN通过创建一个扩展`VpnService`基类的服务组件并在应用清单中注册来实现，如[示例 9-11](ch09.html#registering_a_vpn_service_in_the_applica
    "示例 9-11. 在应用清单中注册VPN服务")所示。
- en: Example 9-11. Registering a VPN service in the application manifest
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 9-11. 在应用清单中注册VPN服务
- en: '[PRE10]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The service must have an intent filter that matches the *android.net.VpnService*
    intent action ➋ so that the system can bind to the service and control it. In
    addition, the service must require the `BIND_VPN_SERVICE` system signature permission
    ➊, which guarantees that only system applications can bind to it.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 该服务必须具有一个意图过滤器，能够匹配*android.net.VpnService*意图操作➋，以便系统能够绑定到该服务并控制它。此外，该服务必须要求`BIND_VPN_SERVICE`系统签名权限➊，这确保只有系统应用能够绑定到该服务。
- en: Preparing the VPN
  id: totrans-185
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 准备VPN
- en: To register a new VPN connection with the system, the application first calls
    `VpnService.prepare()` in order to be granted permission to run, and then calls
    the `establish()` method in order to create a network tunnel (discussed in the
    next section). The `prepare()` method returns an intent that’s used to start the
    warning dialog shown in [Figure 9-10](ch09.html#application-based_vpn_connection_warning
    "Figure 9-10. Application-based VPN connection warning dialog"). The dialog serves
    to obtain the user’s permission and ensure that only one VPN connection per user
    is running at any time. If `prepare()` is called while a VPN connection created
    by another application is running, that connection is terminated. The `prepare()`
    method saves the package name of the calling application, and only that application
    is allowed to start a VPN connection until the method is called again, or the
    system tears down the VPN connection (for example, if the VPN app’s process crashes).
    When a VPN connection is deactivated for any reason, the system calls the `onRevoke()`
    method of the current VPN application’s `VpnService` implementation.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 要将新的VPN连接注册到系统中，应用首先调用`VpnService.prepare()`以获得运行权限，然后调用`establish()`方法来创建一个网络隧道（在下一节中讨论）。`prepare()`方法返回一个意图，用于启动[图
    9-10](ch09.html#application-based_vpn_connection_warning "图 9-10. 基于应用的VPN连接警告对话框")中显示的警告对话框。该对话框用于获得用户的许可，并确保每个用户始终只能运行一个VPN连接。如果在另一个应用创建的VPN连接正在运行时调用`prepare()`，该连接将被终止。`prepare()`方法保存调用应用的包名，并且只有该应用被允许启动VPN连接，直到该方法再次被调用或系统关闭VPN连接（例如，如果VPN应用的进程崩溃）。当VPN连接因任何原因被停用时，系统会调用当前VPN应用的`VpnService`实现中的`onRevoke()`方法。
- en: Establishing a VPN Connection
  id: totrans-187
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 建立VPN连接
- en: After a VPN application has been prepared and granted permission to run, it
    can start its `VpnService` component, which would then typically create a tunnel
    to the VPN gateway and negotiate the network parameters for the VPN connection.
    Next, it sets up the `VpnService.Builder` class using those parameters and calls
    `VpnService.establish()` in order to receive a file descriptor to read and write
    packets. The `establish()` method first ensures that it’s being called by the
    application currently granted permission to establish a VPN connection by comparing
    the UID of the caller to the granted application’s UID. `establish()` then checks
    whether the current Android user is allowed to create VPN connections, and verifies
    that the service requires the `BIND_VPN_SERVICE` permission; if the service doesn’t
    require that permission, it’s considered insecure and a `SecurityException` is
    thrown. Next, the `establish()` method creates and configures a tunnel interface
    using native code, and sets up routing and DNS servers.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 在准备好 VPN 应用并授予其运行权限后，应用程序可以启动其 `VpnService` 组件，通常会创建一个隧道连接到 VPN 网关，并协商 VPN 连接的网络参数。接下来，应用程序使用这些参数设置
    `VpnService.Builder` 类，并调用 `VpnService.establish()` 来接收一个文件描述符，以便读写数据包。`establish()`
    方法首先确保它是由当前获得建立 VPN 连接权限的应用程序调用，通过比较调用者的 UID 和授权应用程序的 UID 来进行验证。然后，`establish()`
    检查当前 Android 用户是否被允许创建 VPN 连接，并验证该服务是否需要 `BIND_VPN_SERVICE` 权限；如果该服务不需要该权限，则被认为是不安全的，并抛出
    `SecurityException` 异常。接下来，`establish()` 方法使用本地代码创建并配置隧道接口，并设置路由和 DNS 服务器。
- en: Notifying the User About the VPN Connection
  id: totrans-189
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 通知用户 VPN 连接
- en: The last step in establishing a VPN connection is to show an ongoing notification
    that tells the user that network traffic is been tunneled through a VPN, which
    allows them to monitor and control the connection via the associated control dialog.
    The dialog for the OpenVPN for Android application is shown in [Figure 9-11](ch09.html#application-based_vpn_management_dialog
    "Figure 9-11. Application-based VPN management dialog").
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 建立 VPN 连接的最后一步是显示一个持续的通知，告知用户网络流量正在通过 VPN 隧道传输，这使得用户能够通过关联的控制对话框监控和控制连接。Android
    版 OpenVPN 应用的对话框如[图 9-11](ch09.html#application-based_vpn_management_dialog "图
    9-11. 基于应用的 VPN 管理对话框")所示。
- en: This dialog is part of the dedicated package `com.android.vpndialogs`, which
    is the only package explicitly allowed to manage application-based VPN connections,
    other than the *system* user. This ensures that a VPN connection can only be started
    and managed via the system-mandated UI.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 该对话框是专用包 `com.android.vpndialogs` 的一部分，这是唯一一个被明确允许管理基于应用的 VPN 连接的包，除了 *系统* 用户。这确保了
    VPN 连接只能通过系统强制的用户界面启动和管理。
- en: Using the application-based VPN framework, applications are free to implement
    network tunneling, with any required authentication and encryption methods. Because
    all packets the device sends or receives pass through the VPN application, it
    can be used not only for tunneling but also for traffic logging, filtering, or
    modification (such as removing advertisements).
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 使用基于应用的 VPN 框架，应用程序可以自由实现网络隧道功能，并根据需要进行身份验证和加密方法的设置。由于设备发送或接收的所有数据包都经过 VPN 应用，因此它不仅可以用于隧道传输，还可以用于流量日志记录、过滤或修改（例如移除广告）。
- en: Note
  id: totrans-193
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '*For a full-featured implementation of an application-based VPN that takes
    advantage of Android’s credential store to manage authentication keys and certificates,
    see the source code for OpenVPN for Android.*^([[93](#ftn.ch09fn07)]) *This application
    implements an SSL VPN client that is fully compatible with the OpenVPN server.*'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: '*要实现一个功能完整的基于应用的 VPN，利用 Android 的凭证存储来管理身份验证密钥和证书，请参阅 OpenVPN for Android 的源代码。*^([[93](#ftn.ch09fn07)])
    *该应用实现了一个完全兼容 OpenVPN 服务器的 SSL VPN 客户端。*'
- en: Multi-User Support
  id: totrans-195
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 多用户支持
- en: As mentioned earlier, on multi-user devices, legacy VPNs can be controlled only
    by the owner user. However, with its introduction of multi-user support, Android
    4.2 and higher allows all secondary users (with the exception of restricted profiles,
    which must share the primary user’s VPN connection) to start application-based
    VPNs. While this change technically allowed each user to start their own VPN,
    because only one application-based VPN could be activated at a time, traffic for
    all device users was routed through the currently active VPN regardless of who
    started it. Android 4.4 finally brought full multi-user VPN support by introducing
    *per-user VPN*, which allows traffic from any user to be routed through their
    VPN, thus isolating it from other users’ traffic.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，在多用户设备上，传统的 VPN 只能由拥有者用户控制。然而，通过引入多用户支持，Android 4.2 及更高版本允许所有次级用户（限制型用户除外，这些用户必须共享主用户的
    VPN 连接）启动基于应用的 VPN。虽然这一变化从技术上讲允许每个用户启动自己的 VPN，但由于每次只能激活一个基于应用的 VPN，因此所有设备用户的流量都会通过当前激活的
    VPN 路由，而不管是哪个用户启动的。Android 4.4 最终通过引入 *每用户 VPN* 完全支持多用户 VPN，该功能允许来自任何用户的流量通过其个人的
    VPN 路由，从而将其与其他用户的流量隔离开。
- en: Linux Advanced Routing
  id: totrans-197
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Linux 高级路由
- en: '![Application-based VPN management dialog](figs/web/09fig11.png.jpg)'
  id: totrans-198
  prefs: []
  type: TYPE_IMG
  zh: '![基于应用的 VPN 管理对话框](figs/web/09fig11.png.jpg)'
- en: Figure 9-11. Application-based VPN management dialog
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9-11. 基于应用的 VPN 管理对话框
- en: Android uses several advanced packet filtering and routing features of the Linux
    kernel in order to implement per-user VPNs. These features (implemented by the
    *netfilter* kernel framework) include the *owner* module of the Linux *iptables*
    tool, which allows matching of locally generated packets based on the UID, GID,
    or PID of the process that created them. For example, the command shown at ➊ in
    [Example 9-12](ch09.html#using_owner_matching_and_packet_marking "Example 9-12. Using
    owner matching and packet marking with iptables") creates a packet-filtering rule
    that drops all outgoing packets generated by the user with UID 1234.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: Android 使用 Linux 内核的几个高级数据包过滤和路由特性来实现每用户 VPN。这些特性（由 *netfilter* 内核框架实现）包括 Linux
    *iptables* 工具的 *owner* 模块，该模块允许根据创建数据包的进程的 UID、GID 或 PID 来匹配本地生成的数据包。例如，[示例 9-12](ch09.html#using_owner_matching_and_packet_marking
    "示例 9-12. 使用所有者匹配和数据包标记的 iptables") 中显示的命令创建了一个数据包过滤规则，丢弃所有由 UID 为 1234 的用户生成的外发数据包。
- en: Example 9-12. Using owner matching and packet marking with iptables
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 9-12. 使用所有者匹配和数据包标记的 iptables
- en: '[PRE11]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Another important netfilter feature is the ability to mark packets that match
    a certain selector with a specified number (called a *mark*). For example, the
    rule at ➋ marks all packets destined for port 80 (which is typically used by a
    web server) with the mark 0x1\. This mark can then be matched in later filtering
    or routing rules in order to, for example, send marked packets through a particular
    interface by adding a routing rule that sends marked packets to a predefined routing
    table, which is *web* in our example ➌. Finally, a route that sends packets matching
    the *web* table to the *em3* interface can be added with the command shown at
    ➍.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个重要的 netfilter 特性是能够标记匹配特定选择器的包，并为其指定一个数字（称为 *标记*）。例如，➋ 处的规则将所有目标端口为 80 的数据包（通常由
    Web 服务器使用）标记为 0x1\。然后，可以在后续的过滤或路由规则中匹配此标记，例如，通过添加路由规则，将标记的数据包发送到预定义的路由表，从而将标记的数据包通过特定接口转发，在我们的示例
    ➌ 中是 *web*。最后，可以通过在 ➍ 处显示的命令，添加一个路由规则，将匹配 *web* 表的数据包发送到 *em3* 接口。
- en: Multi-User VPN Implementation
  id: totrans-204
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 多用户 VPN 实现
- en: Android uses these packet filtering and routing features to mark packets originating
    from all apps of a particular Android user and send them through the tunneling
    interface created by the VPN app started by that user. When the owner user starts
    a VPN, that VPN is shared with any restricted profiles on the device that cannot
    start their own VPNs by matching all packets originating from restricted profiles
    and routing them through the owner’s VPN tunnel.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: Android 使用这些数据包过滤和路由功能，将来自特定 Android 用户所有应用的包标记，并通过该用户启动的 VPN 应用所创建的隧道接口进行转发。当拥有者用户启动
    VPN 时，该 VPN 会与设备上无法启动自己 VPN 的任何限制型用户共享，通过匹配所有来自限制型用户的数据包并将它们路由通过拥有者的 VPN 隧道来实现。
- en: This split-routing is implemented at the framework level by the `NetworkManagementService`,
    which provides APIs to manage package matching and routing by UID or UID range.
    `NetworkManagementService` implements those APIs by sending commands to the native
    *netd* daemon which runs as root, and thus can modify the kernel’s packet filtering
    and routing tables. *netd* manipulates the kernel’s filtering and routing configuration
    by calling the *iptables* and *ip* userland utilities.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 这种拆分路由在框架级别通过`NetworkManagementService`实现，该服务提供API来按UID或UID范围管理数据包匹配和路由。`NetworkManagementService`通过向本地的*netd*守护进程发送命令来实现这些API，而*netd*以root身份运行，因此可以修改内核的数据包过滤和路由表。*netd*通过调用*iptables*和*ip*用户态工具来操控内核的过滤和路由配置。
- en: Let’s illustrate Android’s per-user VPN routing with an example as shown in
    [Example 9-13](ch09.html#packet_matching_rules_for_vpns_started_b "Example 9-13. Packet
    matching rules for VPNs started by two different device users"). The primary user
    (user ID 0) and the first secondary user (user ID 10) have each started an application-based
    VPN. The owner user’s VPN is assigned the *tun0* tunneling interface, and the
    secondary user’s VPN is assigned the *tun1* interface. The device also has a restricted
    profile with user ID 13\. [Example 9-13](ch09.html#packet_matching_rules_for_vpns_started_b
    "Example 9-13. Packet matching rules for VPNs started by two different device
    users") shows the state of the kernel’s packet filtering tables when both VPNs
    are connected (with some details omitted).
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过一个示例来说明Android的每个用户VPN路由，如[示例9-13](ch09.html#packet_matching_rules_for_vpns_started_b
    "示例9-13。由两个不同设备用户启动的VPN的数据包匹配规则")所示。主用户（用户ID 0）和第一个次级用户（用户ID 10）分别启动了基于应用的VPN。主用户的VPN分配了*tun0*隧道接口，次级用户的VPN分配了*tun1*接口。设备上还存在一个带有用户ID
    13的受限配置文件。[示例9-13](ch09.html#packet_matching_rules_for_vpns_started_b "示例9-13。由两个不同设备用户启动的VPN的数据包匹配规则")显示了内核的数据包过滤表状态，当两个VPN都连接时（一些细节被省略）。
- en: Example 9-13. Packet matching rules for VPNs started by two different device
    users
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 示例9-13。由两个不同设备用户启动的VPN的数据包匹配规则
- en: '[PRE12]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Outgoing packets are first sent to the *st_mangle_OUTPUT* chain, which is responsible
    for matching and marking packets. Packets exempt from peruser routing (those already
    marked with 0x1 ➊), and packets originating from legacy VPNs (UID 1016 ➋, assigned
    to the built-in *vpn* user, which both *mtd* and *racoon* run as) pass without
    modification.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 外发数据包首先发送到*st_mangle_OUTPUT*链，该链负责匹配和标记数据包。免于每个用户路由的数据包（那些已经被标记为0x1 ➊）和来自传统VPN的数据包（UID
    1016 ➋，分配给内置的*vpn*用户，该用户同时运行*mtd*和*racoon*）无需修改即可通过。
- en: 'Next, packets created by processes running with UIDs between 0 and 99999 (the
    range of UIDs assigned to apps started by the primary user, as discussed in [Chapter 4](ch04.html
    "Chapter 4. User Management")) are matched and sent to the *st_mangle_tun0_ OUTPUT*
    chain ➌. Packets originating from UIDs 1300000–1399999, the range assigned to
    our restricted profile (user ID 13), are sent to the same chain ➍. Thus, traffic
    originating from the owner user and the restricted profile is treated the same
    way. Packets originating from the first secondary user (user ID 10, UID range
    1000000-1099999) are, however, sent to a different chain, *st_mangle_tun1_OUTPUT*
    ➎. The target chains themselves are simple: *st_mangle_tun0_OUTPUT* first clears
    the packet mark and then marks them with *0x3c* ➏; *st_mangle_tun1_OUTPUT* does
    the same but uses the mark *0x3d* ➐. After packets have been marked, the marks
    are used to implement and match different routing rules, as shown in [Example 9-14](ch09.html#routing_rules_for_vpns_started_by_two_di
    "Example 9-14. Routing rules for VPNs started by two different device users").'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，由UID介于0到99999之间的进程创建的数据包（这些UID范围分配给由主用户启动的应用，如[第4章](ch04.html "第4章。用户管理")所讨论）会被匹配并发送到*st_mangle_tun0_OUTPUT*链
    ➌。来自UID 1300000–1399999的数据包，即分配给我们受限配置文件（用户ID 13）的UID范围，会被发送到相同的链 ➍。因此，来自主用户和受限配置文件的流量将以相同的方式处理。然而，来自第一个次级用户（用户ID
    10，UID范围1000000-1099999）的数据包将被发送到另一个链——*st_mangle_tun1_OUTPUT* ➎。目标链本身很简单：*st_mangle_tun0_OUTPUT*首先清除数据包标记，然后用*0x3c*标记它们
    ➏；*st_mangle_tun1_OUTPUT*做相同的事情，但使用标记*0x3d* ➐。数据包被标记后，标记会用于实现并匹配不同的路由规则，如[示例9-14](ch09.html#routing_rules_for_vpns_started_by_two_di
    "示例9-14。由两个不同设备用户启动的VPN的路由规则")所示。
- en: Example 9-14. Routing rules for VPNs started by two different device users
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 示例9-14。由两个不同设备用户启动的VPN的路由规则
- en: '[PRE13]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Notice that two rules that match each mark have been created, and that they’re
    associated with different routing tables. Packets marked with *0x3c* go to routing
    table 60 (0x3c in hexadecimal ➊), while those marked with *0x3d* go to table 61
    (0x3d in hexadecimal ➋). Table 60 routes everything through the *tun0* tunneling
    interface ➌, which was created by the owner user, and table 61 routes everything
    through the *tun1* interface ➍, created by the secondary user.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，已创建了两个匹配每个标记的规则，并且它们与不同的路由表相关联。标记为*0x3c*的数据包进入路由表60（16进制中的0x3c ➊），而标记为*0x3d*的数据包进入路由表61（16进制中的0x3d
    ➋）。表60将所有流量通过由拥有者用户创建的*tun0*隧道接口路由 ➌，而表61将所有流量通过由次要用户创建的*tun1*接口路由 ➍。
- en: Note
  id: totrans-215
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '*While the VPN traffic routing method introduced in Android 4.4 offers greater
    flexibility and allows user VPN traffic to be isolated, as of this writing the
    implementation appears to have some problems, especially related to switching
    between different physical networks (for example, mobile to Wi-Fi or vice versa).
    Those problems should be addressed in future versions, possibly by modifying how
    packet filtering chains are associated with interfaces, but the basic implementation
    strategy is likely to remain the same.*'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: '*尽管Android 4.4中引入的VPN流量路由方法提供了更大的灵活性，并允许用户的VPN流量隔离，但截至目前，实施似乎存在一些问题，尤其是与在不同物理网络之间切换（例如，从移动网络到Wi-Fi或反之）相关的问题。这些问题应在未来的版本中解决，可能通过修改数据包过滤链与接口的关联方式，但基本的实施策略可能会保持不变。*'
- en: Wi-Fi EAP
  id: totrans-217
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Wi-Fi EAP
- en: Android supports different wireless network protocols, including Wi-Fi Protected
    Access (WPA) and Wi-Fi Protected Access II (WPA2), which are currently deployed
    on most wireless devices. Both protocols support a simple *pre-shared key (PSK)*
    mode, also referred to as *Personal mode*, in which all devices that access the
    network must be configured with the same 256-bit authentication key.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: Android支持不同的无线网络协议，包括Wi-Fi保护访问（WPA）和Wi-Fi保护访问II（WPA2），这两种协议目前在大多数无线设备上都有部署。两种协议都支持一种简单的*预共享密钥（PSK）*模式，也称为*个人模式*，在这种模式下，所有访问网络的设备必须配置相同的256位认证密钥。
- en: Devices can be configured either with the raw key bytes or with an ASCII passphrase
    that’s used to derive the authentication key using the PBKDF2 key derivation algorithm.
    While the PSK mode is simple, it doesn’t scale as the number of network users
    increases. If access for a certain user needs to be revoked, for example, the
    only way to cancel their network credentials is to change the shared passphrase,
    which would force all other users to reconfigure their devices. Additionally,
    as there is no practical way to distinguish users and devices, it is difficult
    to implement flexible access rules or accounting.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 设备可以通过原始密钥字节或使用ASCII密码短语来配置，后者用于通过PBKDF2密钥派生算法派生认证密钥。虽然PSK模式简单，但随着网络用户数量的增加，它无法扩展。如果需要撤销某个用户的访问权限，例如，取消其网络凭证的唯一方法是更改共享密码短语，这将迫使所有其他用户重新配置其设备。此外，由于没有实际的方法来区分用户和设备，因此很难实施灵活的访问规则或记账。
- en: To address this problem, both WPA and WPA2 support the IEEE 802.1X network access
    control standard, which offers an encapsulation of the Extensible Authentication
    Protocol (EAP). Authentication in a wireless network that uses 802.1X and involves
    a supplicant, an authenticator, and an authentication server is shown in [Figure 9-12](ch09.html#eight02dot1x_authentication_participants
    "Figure 9-12. 802.1X authentication participants").
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解决这个问题，WPA和WPA2都支持IEEE 802.1X网络访问控制标准，该标准封装了可扩展认证协议（EAP）。使用802.1X并涉及客户端、认证者和认证服务器的无线网络认证如[图9-12](ch09.html#eight02dot1x_authentication_participants
    "图9-12. 802.1X认证参与者")所示。
- en: '![802.1X authentication participants](figs/web/09fig12.png.jpg)'
  id: totrans-221
  prefs: []
  type: TYPE_IMG
  zh: '![802.1X认证参与者](figs/web/09fig12.png.jpg)'
- en: Figure 9-12. 802.1X authentication participants
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 图9-12. 802.1X认证参与者
- en: The *supplicant* is a wireless device such as an Android phone that wants to
    connect to the network, and the *authenticator* is the gateway to the network
    that validates the supplicant’s identity and provides authorization. In a typical
    Wi-Fi configuration, the authenticator is the wireless access point (AP). The
    *authentication server*, typically a RADIUS server, verifies client credentials
    and decides whether they should be granted access based on a preconfigured access
    policy.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: '*客户端*是希望连接到网络的无线设备，如Android手机，*认证器*是网络的网关，用于验证客户端的身份并提供授权。在典型的Wi-Fi配置中，认证器是无线接入点（AP）。*认证服务器*，通常是RADIUS服务器，验证客户端凭据并根据预配置的访问策略决定是否授予访问权限。'
- en: 'Authentication is implemented by exchanging EAP messages between the three
    nodes. These are encapsulated in a format suitable for the medium connecting each
    two nodes: EAP over LAN (EAPOL) between the supplicant and the authenticator,
    and RADIUS between the authenticator and the authentication server.'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 通过在三个节点之间交换EAP消息来实现身份验证。这些消息被封装成适合连接每两个节点的介质的格式：客户端与认证器之间使用局域网（EAPOL），认证器与认证服务器之间使用RADIUS。
- en: Because EAP is an authentication framework that supports different concrete
    authentication types and not a concrete authentication mechanism, the supplicant
    and authentication server (with the help of the authenticator) need to negotiate
    a commonly supported authentication method before authentication can be performed.
    There are various standard and proprietary EAP authentication methods, and current
    Android versions support most of the methods used in wireless networks.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 由于EAP是一种支持不同具体身份验证类型的身份验证框架，而不是一种具体的身份验证机制，因此客户端（与认证器的帮助下）需要在执行身份验证之前协商一个共同支持的身份验证方法。存在多种标准和专有的EAP身份验证方法，当前的Android版本支持大多数用于无线网络中的方法。
- en: The sections below offer a brief overview of the EAP authentication methods
    that Android supports, and show how it protects credentials for each method. We’ll
    also demonstrate how to configure access to a Wi-Fi network that uses EAP for
    authentication using Android’s wireless network management APIs.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 以下部分简要概述了Android支持的EAP身份验证方法，并展示了它如何保护每种方法的凭据。我们还将演示如何使用Android的无线网络管理API配置使用EAP进行身份验证的Wi-Fi网络的访问。
- en: EAP Authentication Methods
  id: totrans-227
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: EAP身份验证方法
- en: As of version 4.4, Android supports the PEAP, EAP-TLS, EAP-TTLS, and EAP-PWD
    authentication methods. Before exploring how Android stores credentials for each
    authentication method, let’s briefly discuss how each one works.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 从4.4版本开始，Android支持PEAP、EAP-TLS、EAP-TTLS和EAP-PWD身份验证方法。在探索Android如何存储每种身份验证方法的凭据之前，让我们简要讨论每种方法的工作原理。
- en: '**PEAP**'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: '**PEAP**'
- en: The Protected Extensible Authentication Protocol (PEAP) transmits EAP messages
    through an SSL connection in order to provide confidentiality and integrity. It
    uses PKI and a server certificate to authenticate the server and establish an
    SSL connection (Phase 1), but does not mandate how clients are authenticated.
    Clients are authenticated using a second, inner (Phase 2) authentication method,
    which is transmitted inside the SSL tunnel. Android supports the MSCHAPv2 (specified
    in PEAPv0^([[94](#ftn.ch09fn08)])) and Generic Token Card (GTC, specified in PEAPv2^([[95](#ftn.ch09fn09)]))
    methods for Phase 2 authentication.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 保护扩展认证协议（PEAP）通过SSL连接传输EAP消息，以提供机密性和完整性。它使用公钥基础设施（PKI）和服务器证书来验证服务器并建立SSL连接（阶段1），但不要求指定客户端的身份验证方式。客户端使用第二种内层（阶段2）身份验证方法进行身份验证，该方法在SSL隧道内传输。Android支持用于阶段2身份验证的MSCHAPv2（在PEAPv0中指定^([[94](#ftn.ch09fn08)]))和通用令牌卡（GTC，在PEAPv2中指定^([[95](#ftn.ch09fn09)]))方法。
- en: '**EAP-TLS**'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: '**EAP-TLS**'
- en: The EAP-Transport Layer Security (EAP-TLS) method^([[96](#ftn.ch09fn10)]) uses
    TLS for mutual authentication and was formerly the only EAP method certified for
    use with WPA Enterprise. EAP-TLS uses both a server certificate to authenticate
    the server to supplicants, and a client certificate that the authentication server
    verifies in order to establish supplicant identity. Granting network access requires
    issuing and distributing X.509 client certificates, and thus maintaining a public
    key infrastructure. Existing clients can be blocked from accessing the network
    by revoking their supplicant certificates. Android supports EAP-TLS and manages
    client keys and certificates using the system credential store.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: EAP-传输层安全性（EAP-TLS）方法^([[96](#ftn.ch09fn10)])使用 TLS 进行相互身份验证，曾是唯一经过认证可以与 WPA
    企业版一起使用的 EAP 方法。EAP-TLS 使用服务器证书来验证服务器的身份，并使用客户端证书来验证身份验证服务器以建立请求者身份。授予网络访问权限需要发布和分发
    X.509 客户端证书，从而维护公钥基础设施。可以通过吊销请求者证书来阻止现有客户端访问网络。Android 支持 EAP-TLS，并使用系统凭据存储管理客户端密钥和证书。
- en: '**EAP-TTLS**'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: '**EAP-TTLS**'
- en: Like EAP-TLS, the EAP-Tunneled Transport Layer Security (EAP-TTLS) protocol^([[97](#ftn.ch09fn11)])
    is based on TLS. However, EAP-TTLS does not require client authentication using
    X.509 certificates. Clients can be authenticated either using a certificate during
    the handshake phase (Phase 1), or with another protocol during the tunnel phase
    (Phase 2). Android does not support authentication during Phase 1, but supports
    the PAP, MSCHAP, MSCHAPv2, and GTC protocols for Phase 2.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 与 EAP-TLS 类似，EAP 隧道传输层安全性（EAP-TTLS）协议^([[97](#ftn.ch09fn11)]) 基于 TLS。然而，EAP-TTLS
    不需要使用 X.509 证书进行客户端身份验证。客户端可以在握手阶段（阶段 1）使用证书进行身份验证，或者在隧道阶段（阶段 2）使用另一种协议进行身份验证。Android
    不支持在阶段 1 进行身份验证，但支持在阶段 2 使用 PAP、MSCHAP、MSCHAPv2 和 GTC 协议进行身份验证。
- en: '**EAP-PWD**'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: '**EAP-PWD**'
- en: The EAP-PWD authentication method^([[98](#ftn.ch09fn12)]) uses a shared password
    for authentication. Unlike legacy schemes that rely on a simple challenge-response
    mechanism, EAP-PWD is designed to be resistant to passive attacks, active attacks,
    and dictionary attacks. The protocol also provides forward secrecy and guarantees
    that even if a password is compromised, earlier sessions cannot be decrypted.
    EAP-PWD is based on discrete logarithm cryptography and can be implemented using
    either finite fields or elliptic curves.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: EAP-PWD 身份验证方法^([[98](#ftn.ch09fn12)])使用共享密码进行身份验证。与依赖简单的挑战-响应机制的传统方案不同，EAP-PWD
    旨在防御被动攻击、主动攻击和字典攻击。该协议还提供前向保密性，保证即使密码被泄露，之前的会话也无法被解密。EAP-PWD 基于离散对数密码学，可以使用有限域或椭圆曲线来实现。
- en: Android Wi-Fi Architecture
  id: totrans-237
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Android Wi-Fi 架构
- en: Like most hardware support in Android, Android’s Wi-Fi architecture consists
    of a kernel layer (WLAN adapter driver modules), native daemon (*wpa_supplicant*),
    a Hardware Abstraction Layer (HAL), system services, and a system UI. Wi-Fi adapter
    kernel drivers are usually specific to the system on a chip (SoC) that an Android
    device is built upon, and are typically closed source and loaded as kernel modules.
    The *wpa_supplicant*^([[99](#ftn.ch09fn13)]) is a WPA supplicant daemon that implements
    key negotiation with a WPA authenticator and controls 802.1X association of the
    WLAN driver. However, Android devices rarely include the original *wpa_supplicant*
    code; the included implementation is often modified for better compatibility with
    the underlying SoC.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 像大多数 Android 硬件支持一样，Android 的 Wi-Fi 架构由内核层（WLAN 适配器驱动模块）、本地守护进程（*wpa_supplicant*）、硬件抽象层（HAL）、系统服务和系统
    UI 组成。Wi-Fi 适配器内核驱动通常是特定于 Android 设备所依赖的系统芯片（SoC）的，通常是闭源的并作为内核模块加载。*wpa_supplicant*^([[99](#ftn.ch09fn13)])
    是一个 WPA 请求者守护进程，实现与 WPA 身份验证器的密钥协商，并控制 WLAN 驱动的 802.1X 关联。然而，Android 设备很少包含原始的
    *wpa_supplicant* 代码；包含的实现通常会针对底层 SoC 进行修改，以提高兼容性。
- en: The HAL is implemented in the *libharware_legacy* native library and is responsible
    for relaying commands from the framework to *wpa_supplicant* via its control socket.
    The system service that controls Wi-Fi connectivity is `WifiService`, which offers
    a public interface via the `WifiManager` facade class. The `WifiService` delegates
    Wi-Fi state management to a rather complex `WifiStateMachine` class, which can
    go through more than a dozen states while connecting to a wireless network.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: HAL 实现于 *libharware_legacy* 本地库，并负责通过其控制套接字将框架中的命令传递给 *wpa_supplicant*。控制 Wi-Fi
    连接的系统服务是 `WifiService`，它通过 `WifiManager` 外观类提供公共接口。`WifiService` 将 Wi-Fi 状态管理委托给一个相当复杂的
    `WifiStateMachine` 类，在连接无线网络时，该类可能经历十多个状态。
- en: WLAN connectivity is controlled via the Wi-Fi screen of the system Settings
    app, and connectivity status is displayed in the status bar and Quick Settings,
    both of which are part of the SystemUI package.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: WLAN 连接通过系统设置应用程序中的 Wi-Fi 屏幕进行控制，连接状态显示在状态栏和快速设置中，二者都是 SystemUI 包的一部分。
- en: Android stores Wi-Fi-related configuration files in the */data/misc/wifi/* directory
    because wireless connectivity daemons persist configuration changes directly to
    disk and thus need a writable directory. The directory is owned by the *wifi*
    user (UID 1010), which is also the user that the *wpa_supplicant* runs as. Configurations
    files, including *wpa_supplicant.conf*, have permissions set to 0660 and are owned
    by the *system* user, and their group is set to *wifi*. This ensures that both
    system applications and the supplicant daemon can read and modify configurations
    files, but they are not accessible to other applications. The *wpa_supplicant.conf*
    file contains configuration parameters formatted as key-value pairs, both global
    and specific to a particular network. Network-specific parameters are enclosed
    in network blocks, which may look like [Example 9-15](ch09.html#psk_network_configuration_block_in_wpaun
    "Example 9-15. PSK network configuration block in wpa_supplicant.conf") for a
    PSK configuration.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: Android 将与 Wi-Fi 相关的配置文件存储在 */data/misc/wifi/* 目录下，因为无线连接守护进程会将配置更改直接写入磁盘，因此需要一个可写的目录。该目录属于
    *wifi* 用户（UID 1010），它也是 *wpa_supplicant* 运行的用户。包括 *wpa_supplicant.conf* 在内的配置文件的权限设置为
    0660，文件的所有者是 *system* 用户，组设置为 *wifi*。这确保了系统应用程序和 supplicant 守护进程可以读取和修改配置文件，但其他应用程序无法访问。*wpa_supplicant.conf*
    文件包含格式为键值对的配置参数，包括全局参数和特定于某个网络的参数。特定于网络的参数被包含在网络块中，可能类似于 [示例 9-15](ch09.html#psk_network_configuration_block_in_wpaun
    "示例 9-15. wpa_supplicant.conf 中的 PSK 网络配置块") 中的 PSK 配置。
- en: Example 9-15. PSK network configuration block in wpa_supplicant.conf
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 9-15. wpa_supplicant.conf 中的 PSK 网络配置块
- en: '[PRE14]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: As you can see, the `network` block specifies the network SSID ➊, authentication
    key management protocol ➋, the pre-shared key itself ➌, and a priority value ➍.
    The PSK is saved in plaintext, and while the *wpa_supplicant.conf* access bits
    disallow non-system applications from accessing it, it can be easily extracted
    from devices that allow root access.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，`network` 块指定了网络的 SSID ➊、认证密钥管理协议 ➋、预共享密钥本身 ➌ 以及优先级值 ➍。PSK 以明文形式保存，虽然 *wpa_supplicant.conf*
    的访问位禁止非系统应用程序访问它，但它可以从允许 root 访问的设备中轻松提取。
- en: EAP Credentials Management
  id: totrans-245
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: EAP 凭据管理
- en: In this section, we’ll examine how Android manages Wi-Fi credentials for each
    of the supported EAP authentication methods and discuss the Android-specific *wpa_supplicant*
    changes that allow the supplicant daemon to take advantage of Android’s system
    credential store.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将探讨 Android 如何管理每种支持的 EAP 认证方法的 Wi-Fi 凭据，并讨论允许 supplicant 守护进程利用 Android
    系统凭据存储的 Android 特定 *wpa_supplicant* 更改。
- en: '[Example 9-16](ch09.html#peap_network_configuration_block_in_wpau "Example 9-16. PEAP
    network configuration block in wpa_supplicant.conf") shows the network block in
    *wpa_supplicant.conf* for a network configured to use PEAP.'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 9-16](ch09.html#peap_network_configuration_block_in_wpau "示例 9-16. wpa_supplicant.conf
    中的 PEAP 网络配置块") 显示了配置为使用 PEAP 的网络在 *wpa_supplicant.conf* 中的网络块。'
- en: Example 9-16. PEAP network configuration block in wpa_supplicant.conf
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 9-16. wpa_supplicant.conf 中的 PEAP 网络配置块
- en: '[PRE15]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Here, the key management mode is set to *WPA-EAP IEEE8021X* ➊, the EAP method
    to *PEAP* ➋, and Phase 2 authentication to MSCHAPv2 ➏. Credentials, namely the
    identity ➌ and password ➍, are stored in plaintext in the configuration file,
    as they are in PSK mode.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，密钥管理模式设置为 *WPA-EAP IEEE8021X* ➊，EAP 方法设置为 *PEAP* ➋，Phase 2 认证设置为 MSCHAPv2
    ➏。凭据，即身份 ➌ 和密码 ➍，以明文存储在配置文件中，就像 PSK 模式一样。
- en: One notable difference from a general-purpose *wpa_supplicant.conf* is the format
    of the CA certificate path ➎. The CA certificate path (*ca_cert*) is used when
    validating the server certificate, and in Android *ca_cert* is in a URI-like format
    with the *keystore* scheme. This Android-specific extension allows the *wpa_supplicant*
    daemon to retrieve certificates from the system credential store. When the daemon
    encounters a certificate path that starts with *keystore://*, it connects to the
    `IKeystoreService` remote interface of the native *keystore* service and retrieves
    the certificate bytes using the URI path as the key.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 与通用的 *wpa_supplicant.conf* 的一个显著不同之处是 CA 证书路径 ➎ 的格式。CA 证书路径（*ca_cert*）在验证服务器证书时使用，在
    Android 中，*ca_cert* 采用类似 URI 的格式，使用 *keystore* 方案。这一 Android 特有的扩展允许 *wpa_supplicant*
    守护进程从系统凭证存储中检索证书。当守护进程遇到以 *keystore://* 开头的证书路径时，它会连接到本地 *keystore* 服务的 `IKeystoreService`
    远程接口，并使用 URI 路径作为密钥检索证书字节。
- en: EAP-TLS configuration is similar to the PEAP one, as shown in [Example 9-17](ch09.html#eap-tls_network_configuration_block_in_w
    "Example 9-17. EAP-TLS network configuration block in wpa_supplicant.conf").
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: EAP-TLS 配置与 PEAP 配置类似，如 [示例 9-17](ch09.html#eap-tls_network_configuration_block_in_w
    "示例 9-17. wpa_supplicant.conf 中的 EAP-TLS 网络配置块") 所示。
- en: Example 9-17. EAP-TLS network configuration block in wpa_supplicant.conf
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 9-17. wpa_supplicant.conf 中的 EAP-TLS 网络配置块
- en: '[PRE16]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: New here is the addition of a client certificate URI ➊, an engine ID ➋, and
    a key ID ➌. The client certificate is retrieved from the system credential store,
    just like the CA certificate. The engine ID refers to the OpenSSL engine that
    should be used for cryptographic operations when connecting to the SSID configured
    in the `network` block. The *wpa_supplicant* has native support for configurable
    OpenSSL engines, and is often used with an PKCS#11 engine in order to use keys
    stored in a smart card or other hardware device.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 新增了客户端证书 URI ➊、引擎 ID ➋ 和密钥 ID ➌。客户端证书从系统凭证存储中获取，类似于 CA 证书。引擎 ID 指的是在连接到 `network`
    块中配置的 SSID 时应使用的 OpenSSL 引擎。*wpa_supplicant* 原生支持可配置的 OpenSSL 引擎，通常与 PKCS#11 引擎一起使用，以便使用存储在智能卡或其他硬件设备中的密钥。
- en: As discussed in [Chapter 7](ch07.html "Chapter 7. Credential Storage"), Android’s
    *keystore* engine uses keys stored in the system credential store. If a device
    supports hardware-backed credential storage, the *keystore* engine can transparently
    take advantage of it by virtue of the intermediate *keymaster* HAL module. The
    key ID in [Example 9-17](ch09.html#eap-tls_network_configuration_block_in_w "Example 9-17. EAP-TLS
    network configuration block in wpa_supplicant.conf") references the alias of the
    private key to use for authentication.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 如 [第 7 章](ch07.html "第 7 章. 凭证存储") 中所述，Android 的 *keystore* 引擎使用存储在系统凭证存储中的密钥。如果设备支持硬件支持的凭证存储，*keystore*
    引擎可以通过中间的 *keymaster* HAL 模块透明地利用它。 [示例 9-17](ch09.html#eap-tls_network_configuration_block_in_w
    "示例 9-17. wpa_supplicant.conf 中的 EAP-TLS 网络配置块") 中的密钥 ID 引用用于身份验证的私钥别名。
- en: As of version 4.3, Android allows you to select the owner of private keys and
    certificates when importing them. Previously, all imported keys were owned by
    the *system* user, but if you set the Credential use parameter to Wi-Fi in the
    import dialog (see [Figure 9-13](ch09.html#setting_the_credential_owner_to_wi-fi_in
    "Figure 9-13. Setting the credential owner to Wi-Fi in the PKCS#12 import dialog")),
    the key owner is set to the *wifi* user (UID 1010), and the key can only be accessed
    by system components that run as the *wifi* user, like *wpa_supplicant*.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 从版本 4.3 开始，Android 允许在导入私钥和证书时选择其所有者。之前，所有导入的密钥都归 *system* 用户所有，但如果你在导入对话框中将凭证使用参数设置为
    Wi-Fi（参见 [图 9-13](ch09.html#setting_the_credential_owner_to_wi-fi_in "图 9-13.
    在 PKCS#12 导入对话框中设置凭证所有者为 Wi-Fi")），密钥所有者将设置为 *wifi* 用户（UID 1010），且该密钥只能由以 *wifi*
    用户身份运行的系统组件访问，比如 *wpa_supplicant*。
- en: '![Setting the credential owner to Wi-Fi in the PKCS#12 import dialog](figs/web/09fig13.png.jpg)'
  id: totrans-258
  prefs: []
  type: TYPE_IMG
  zh: '![在 PKCS#12 导入对话框中设置凭证所有者为 Wi-Fi](figs/web/09fig13.png.jpg)'
- en: Figure 9-13. Setting the credential owner to Wi-Fi in the PKCS#12 import dialog
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9-13. 在 PKCS#12 导入对话框中设置凭证所有者为 Wi-Fi
- en: Because Android does not support client authentication when using the EAP-TTLS
    authentication method, the configuration only contains a CA certificate reference
    ➋, as shown in [Example 9-18](ch09.html#eap-ttls_network_configuration_block_in
    "Example 9-18. EAP-TTLS network configuration block in wpa_supplicant.conf").
    The password ➊ is stored in plaintext.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 Android 不支持在使用 EAP-TTLS 身份验证方法时进行客户端身份验证，因此该配置仅包含 CA 证书引用 ➋，如 [示例 9-18](ch09.html#eap-ttls_network_configuration_block_in
    "示例 9-18. EAP-TTLS 网络配置块在 wpa_supplicant.conf 中") 所示。密码 ➊ 以明文形式存储。
- en: Example 9-18. EAP-TTLS network configuration block in wpa_supplicant.conf
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 9-18. 在 wpa_supplicant.conf 中的 EAP-TTLS 网络配置块
- en: '[PRE17]'
  id: totrans-262
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: The EAP-PWD method does not depend on TLS to establish a secure channel and
    thus requires no certificate configuration, as shown in [Example 9-19](ch09.html#eap-pwd_network_configuration_block_in_w
    "Example 9-19. EAP-PWD network configuration block in wpa_supplicant.conf"). Credentials
    are stored in plaintext (➊ and ➋), as with other configurations that use passwords.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: EAP-PWD 方法不依赖于 TLS 来建立安全通道，因此不需要证书配置，如 [示例 9-19](ch09.html#eap-pwd_network_configuration_block_in_w
    "示例 9-19. EAP-PWD 网络配置块在 wpa_supplicant.conf 中") 所示。凭证以明文存储（➊ 和 ➋），与其他使用密码的配置相同。
- en: Example 9-19. EAP-PWD network configuration block in wpa_supplicant.conf
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 9-19. 在 wpa_supplicant.conf 中的 EAP-PWD 网络配置块
- en: '[PRE18]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: To sum up, configurations for all EAP methods that use a password for authentication
    store credential information in plaintext in the *wpa_supplicant.conf* file. When
    using EAP-TLS, which relies on client authentication, the client key is stored
    in the system keystore, and thus offers the highest level of credential protection.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 总结来说，所有使用密码进行身份验证的 EAP 方法的配置，都将凭证信息以明文形式存储在 *wpa_supplicant.conf* 文件中。而使用 EAP-TLS
    的情况下，由于依赖于客户端身份验证，客户端密钥被存储在系统密钥库中，因此提供了最高级别的凭证保护。
- en: Adding an EAP Network with WifiManager
  id: totrans-267
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 WifiManager 添加 EAP 网络
- en: While Android supports a number of WPA Enterprise authentication methods, setting
    them up properly might challenge some users because of the number of parameters
    that need to be configured and the need to install and select authentication certificates.
    Because Android’s official API for managing Wi-Fi networks, called `WifiManager`,
    did not support EAP configurations prior to Android 4.3, the only way to set up
    an EAP network was to add it via the system Settings app and configure it manually.
    Android 4.3 (API level 18) extended the `WifiManager` API to allow for programmatic
    EAP configuration, thus enabling automatic network provisioning in enterprise
    environments. In this section, we’ll show how to use `WifiManager` to add an EAP-TLS
    network and discuss the underlying implementation.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然 Android 支持多种 WPA 企业身份验证方法，但由于需要配置的参数较多，并且需要安装和选择身份验证证书，正确设置这些方法可能会对部分用户构成挑战。由于
    Android 在 4.3 版本之前的官方 API `WifiManager` 不支持 EAP 配置，设置 EAP 网络的唯一方法是通过系统设置应用手动添加并配置它。Android
    4.3（API 级别 18）扩展了 `WifiManager` API，允许程序化配置 EAP，从而支持企业环境中的自动网络配置。在本节中，我们将展示如何使用
    `WifiManager` 添加 EAP-TLS 网络，并讨论其底层实现。
- en: '`WifiManager` allows an app that holds the `CHANGE_WIFI_STATE` permission (protection
    level *dangerous*) to add a Wi-Fi network by initializing a `WifiConfiguration`
    instance with the network’s SSID, authentication algorithms, and credentials,
    and pass it to the `addNetwork()` method of `WifiManager`. Android 4.3 extends
    this API by adding an `enterpriseConfig` field of type `WifiEnterpriseConfig`
    to the `WifiConfiguration` class, which allows you to configure the EAP authentication
    method to use, client and CA certificates, the Phase 2 authentication method (if
    any), and additional credentials such as username and password. [Example 9-20](ch09.html#adding_an_eap-tls_network_using_wifimana
    "Example 9-20. Adding an EAP-TLS network using WifiManager") shows how to use
    this API to add a network that uses EAP-TLS for authentication.'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: '`WifiManager` 允许持有 `CHANGE_WIFI_STATE` 权限（保护级别 *dangerous*）的应用程序通过初始化一个 `WifiConfiguration`
    实例，并设置网络的 SSID、身份验证算法和凭证，然后将其传递给 `WifiManager` 的 `addNetwork()` 方法，从而添加 Wi-Fi
    网络。Android 4.3 扩展了此 API，通过在 `WifiConfiguration` 类中新增一个类型为 `WifiEnterpriseConfig`
    的 `enterpriseConfig` 字段，允许您配置要使用的 EAP 身份验证方法、客户端和 CA 证书、Phase 2 身份验证方法（如果有的话），以及其他凭证，如用户名和密码。[示例
    9-20](ch09.html#adding_an_eap-tls_network_using_wifimana "示例 9-20. 使用 WifiManager
    添加 EAP-TLS 网络") 展示了如何使用此 API 添加一个使用 EAP-TLS 进行身份验证的网络。'
- en: Example 9-20. Adding an EAP-TLS network using `WifiManager`
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 9-20. 使用 `WifiManager` 添加 EAP-TLS 网络
- en: '[PRE19]'
  id: totrans-271
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: In order to set up EAP-TLS authentication, we first need to obtain the CA certificate
    used to verify the server’s identity, and the client’s private key and certificate.
    Because these are typically distributed as a PKCS#12 file, we can use a `KeyStore`
    of type *PKCS12* to extract them (not shown). (Android will automatically import
    the specified keys and certificates into the system keystore when you add an EAP
    profile that uses them, so you don’t need to import the PKCS#12 file.) After we
    have the CA certificate and client credentials, we set them to our `WifiEnterpriseConfig`
    instance using the `setCaCertificate()` ➊ and `setClientKeyEntry()` ➋ methods.
    We then set the EAP method to `Eap.TLS` ➌ and the Phase 2 method to `NONE` ➍,
    as EAP-TLS authenticates users as part of establishing an SSL connection (Phase
    1). Android also requires us to set the identity ➎ even though it might not be
    used by the authentication server. After we’ve configured the `WifiEnterpriseConfig`
    object, we can add it to the main `WifiConfiguration` instance ➏. The set of key
    management protocols also needs to be configured (➐ and ➑) because it defaults
    to WPA PSK. Finally, we can add the network ➒ and save the configuration ➓, which
    updates the *wpa_supplicant.conf* file to include the newly configured network.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 为了设置 EAP-TLS 认证，我们首先需要获取用于验证服务器身份的 CA 证书，以及客户端的私钥和证书。由于这些通常作为 PKCS#12 文件分发，我们可以使用类型为
    *PKCS12* 的 `KeyStore` 来提取它们（未展示）。(当你添加使用这些证书的 EAP 配置文件时，Android 会自动将指定的密钥和证书导入系统密钥库，因此无需手动导入
    PKCS#12 文件。）获得 CA 证书和客户端凭证后，我们通过 `setCaCertificate()` ➊ 和 `setClientKeyEntry()`
    ➋ 方法将它们设置到 `WifiEnterpriseConfig` 实例中。然后，我们将 EAP 方法设置为 `Eap.TLS` ➌，并将第二阶段方法设置为
    `NONE` ➍，因为 EAP-TLS 在建立 SSL 连接（第一阶段）时进行用户认证。虽然认证服务器可能不会使用，但 Android 仍然要求我们设置身份
    ➎。配置好 `WifiEnterpriseConfig` 对象后，我们可以将其添加到主 `WifiConfiguration` 实例 ➏。密钥管理协议集也需要进行配置（➐
    和 ➑），因为默认情况下它是 WPA PSK。最后，我们可以添加网络 ➒ 并保存配置 ➓，这将更新 *wpa_supplicant.conf* 文件，包含新配置的网络。
- en: Android automatically generates aliases for the configured private key and certificates,
    and then imports the PKI credentials into the system keystore. The aliases are
    based on the AP name, key management scheme, and EAP authentication method. A
    programmatically configured network is automatically shown in the Wi-Fi screen
    of the system Settings application, and might look like [Figure 9-14](ch09.html#eap-tls_network_added_using_wifimanager
    "Figure 9-14. An EAP-TLS network added using WifiManager") for the example shown
    in [Example 9-20](ch09.html#adding_an_eap-tls_network_using_wifimana "Example 9-20. Adding
    an EAP-TLS network using WifiManager").
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: Android 会自动为配置的私钥和证书生成别名，然后将 PKI 凭证导入系统密钥库。别名基于 AP 名称、密钥管理方案和 EAP 认证方法。通过编程配置的网络会自动显示在系统设置应用的
    Wi-Fi 屏幕中，可能如下图所示 [图 9-14](ch09.html#eap-tls_network_added_using_wifimanager "图
    9-14. 使用 WifiManager 添加的 EAP-TLS 网络")，与 [示例 9-20](ch09.html#adding_an_eap-tls_network_using_wifimana
    "示例 9-20. 使用 WifiManager 添加 EAP-TLS 网络") 中的示例相同。
- en: '![An EAP-TLS network added using WifiManager](figs/web/09fig14.png.jpg)'
  id: totrans-274
  prefs: []
  type: TYPE_IMG
  zh: '![使用 WifiManager 添加的 EAP-TLS 网络](figs/web/09fig14.png.jpg)'
- en: Figure 9-14. An EAP-TLS network added using `WifiManager`
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9-14. 使用 `WifiManager` 添加的 EAP-TLS 网络
- en: Summary
  id: totrans-276
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 概述
- en: Android supports a Device Administration API that allows device administration
    apps to configure a security policy, which can include requirements for lockscreen
    password complexity, device encryption, and camera usage. Device administrators
    are often used with corporate accounts, such as those for Microsoft Exchange and
    Google Apps, in order to limit access to corporate data based on the policy and
    device settings. The Device Administration API also provides features that enable
    remote device locking and data wipe.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: Android 支持设备管理 API，允许设备管理应用配置安全策略，其中包括锁屏密码复杂度、设备加密和相机使用等要求。设备管理员通常与企业账户一起使用，如
    Microsoft Exchange 和 Google Apps，以根据策略和设备设置限制对公司数据的访问。设备管理 API 还提供了启用远程设备锁定和数据擦除的功能。
- en: Android devices can connect to various types of VPNs, including PPTP, L2TP/IPSec,
    and SSL-based VPNs. Support for PPTP and L2TP/IPSec is built into the platform
    and can only be extended through OS updates. Android 4.0 adds support for application-based
    VPNs, which allows third-party applications to implement custom VPN solutions.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: Android 设备可以连接到各种类型的 VPN，包括 PPTP、L2TP/IPSec 和基于 SSL 的 VPN。PPTP 和 L2TP/IPSec
    的支持内置于平台中，且只能通过操作系统更新来扩展。Android 4.0 增加了对基于应用的 VPN 的支持，使得第三方应用可以实现自定义的 VPN 解决方案。
- en: In addition to the widely used pre-shared key Wi-Fi authentication mode, Android
    supports various WPA Enterprise configurations, namely PEAP, EAP-TLS, EAP-TTLS,
    and EAP-PWD. Certificates and private keys for EAP authentication methods that
    use SSL to establish a secure channel or authenticate users are stored in the
    system keystore and can use hardware protection when available. Wi-Fi networks
    that use EAP for authentication can be automatically provisioned using the `WifiManager`
    API in recent Android versions, beginning with Android 4.3.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 除了广泛使用的预共享密钥 Wi-Fi 认证模式外，Android 还支持各种 WPA 企业配置，即 PEAP、EAP-TLS、EAP-TTLS 和 EAP-PWD。使用
    SSL 建立安全通道或认证用户的 EAP 认证方法的证书和私钥存储在系统密钥库中，并且在可用时可以使用硬件保护。使用 EAP 进行认证的 Wi-Fi 网络可以通过最近版本的
    Android（从 Android 4.3 开始）中的 `WifiManager` API 自动配置。
- en: '* * *'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: ^([[87](#ch09fn01)]) Google, *Android APIs Reference*, “DeviceAdminInfo,” *[https://developer.android.com/reference/android/app/admin/DeviceAdminInfo.html](https://developer.android.com/reference/android/app/admin/DeviceAdminInfo.html)*
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: ^([[87](#ch09fn01)]) Google，*Android APIs 参考资料*，“DeviceAdminInfo，” *[https://developer.android.com/reference/android/app/admin/DeviceAdminInfo.html](https://developer.android.com/reference/android/app/admin/DeviceAdminInfo.html)*
- en: ^([[88](#ch09fn02)]) Google, *Android APIs Reference*, “DevicePolicyManager,”
    *[https://developer.android.com/reference/android/app/admin/DevicePolicyManager.html](https://developer.android.com/reference/android/app/admin/DevicePolicyManager.html)*
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: ^([[88](#ch09fn02)]) Google，*Android APIs 参考资料*，“DevicePolicyManager，” *[https://developer.android.com/reference/android/app/admin/DevicePolicyManager.html](https://developer.android.com/reference/android/app/admin/DevicePolicyManager.html)*
- en: ^([[89](#ch09fn03)]) Google, *API Guides*, “Device Administration,” *[https://developer.android.com/guide/topics/admin/device-admin.html](https://developer.android.com/guide/topics/admin/device-admin.html)*
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: ^([[89](#ch09fn03)]) Google，*API 指南*，“设备管理，” *[https://developer.android.com/guide/topics/admin/device-admin.html](https://developer.android.com/guide/topics/admin/device-admin.html)*
- en: ^([[90](#ch09fn04)]) OpenVPN Technologies, Inc, “OpenVPN Security Overview,”
    *[http://openvpn.net/index.php/open-source/documentation/security-overview.html](http://openvpn.net/index.php/open-source/documentation/security-overview.html)*
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: ^([[90](#ch09fn04)]) OpenVPN Technologies, Inc，“OpenVPN 安全概述，” *[http://openvpn.net/index.php/open-source/documentation/security-overview.html](http://openvpn.net/index.php/open-source/documentation/security-overview.html)*
- en: ^([[91](#ch09fn05)]) IPSec-Tools, *[http://ipsec-tools.sourceforge.net/](http://ipsec-tools.sourceforge.net/)*
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: ^([[91](#ch09fn05)]) IPSec-Tools， *[http://ipsec-tools.sourceforge.net/](http://ipsec-tools.sourceforge.net/)*
- en: ^([[92](#ch09fn06)]) Google, *Android APIs Reference*, “VpnService,” *[https://developer.android.com/reference/android/net/VpnService.html](https://developer.android.com/reference/android/net/VpnService.html)*
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: ^([[92](#ch09fn06)]) Google，*Android APIs 参考资料*，“VpnService，” *[https://developer.android.com/reference/android/net/VpnService.html](https://developer.android.com/reference/android/net/VpnService.html)*
- en: ^([[93](#ch09fn07)]) Arne Schwabe, “Openvpn for Android 4.0+,” *[https://code.google.com/p/ics-openvpn/](https://code.google.com/p/ics-openvpn/)*
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: ^([[93](#ch09fn07)]) Arne Schwabe，“适用于 Android 4.0+ 的 Openvpn，” *[https://code.google.com/p/ics-openvpn/](https://code.google.com/p/ics-openvpn/)*
- en: ^([[94](#ch09fn08)]) Vivek Kamath, Ashwin Palekar, and Mark Woodrich, *Microsoft’s
    PEAP version 0 (Implementation in Windows XP SP1)*, *[https://tools.ietf.org/html/draft-kamath-pppext-peapv0-00/](https://tools.ietf.org/html/draft-kamath-pppext-peapv0-00/)*
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: ^([[94](#ch09fn08)]) Vivek Kamath，Ashwin Palekar 和 Mark Woodrich，*微软的 PEAP 版本
    0（Windows XP SP1 实现）*， *[https://tools.ietf.org/html/draft-kamath-pppext-peapv0-00/](https://tools.ietf.org/html/draft-kamath-pppext-peapv0-00/)*
- en: ^([[95](#ch09fn09)]) Ashwin Palekar et al., *Protected EAP Protocol (PEAP) Version
    2*, *[https://tools.ietf.org/html/draft-josefsson-pppext-eap-tls-eap-10/](https://tools.ietf.org/html/draft-josefsson-pppext-eap-tls-eap-10/)*
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: ^([[95](#ch09fn09)]) Ashwin Palekar 等人，*受保护的 EAP 协议（PEAP）版本 2*， *[https://tools.ietf.org/html/draft-josefsson-pppext-eap-tls-eap-10/](https://tools.ietf.org/html/draft-josefsson-pppext-eap-tls-eap-10/)*
- en: ^([[96](#ch09fn10)]) D. Simon, B. Aboba, and R. Hurst, *The EAP-TLS Authentication
    Protocol, [http://tools.ietf.org/html/rfc5216/](http://tools.ietf.org/html/rfc5216/)*
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: ^([[96](#ch09fn10)]) D. Simon，B. Aboba 和 R. Hurst，*EAP-TLS 认证协议，* [http://tools.ietf.org/html/rfc5216/](http://tools.ietf.org/html/rfc5216/)
- en: ^([[97](#ch09fn11)]) P. Funk and S. Blake-Wilson, *Extensible Authentication
    Protocol Tunneled Transport Layer Security Authenticated Protocol Version 0 (EAP-TTLSv0)*,
    *[https://tools.ietf.org/html/rfc5281/](https://tools.ietf.org/html/rfc5281/)*
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: ^([[97](#ch09fn11)]) P. Funk 和 S. Blake-Wilson，*扩展认证协议隧道传输层安全认证协议版本 0（EAP-TTLSv0）*，
    *[https://tools.ietf.org/html/rfc5281/](https://tools.ietf.org/html/rfc5281/)*
- en: ^([[98](#ch09fn12)]) D. Harkins and G. Zorn, *Extensible Authentication Protocol
    (EAP) Authentication Using Only a Password*, *[https://tools.ietf.org/html/rfc5931/](https://tools.ietf.org/html/rfc5931/)*
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: ^([[98](#ch09fn12)]) D. Harkins 和 G. Zorn，*仅使用密码的可扩展认证协议（EAP）认证*，*[https://tools.ietf.org/html/rfc5931/](https://tools.ietf.org/html/rfc5931/)*
- en: ^([[99](#ch09fn13)]) Jouni Malinen, *Linux WPA/WPA2/IEEE 802.1X Supplicant*,
    *[http://hostap.epitest.fi/wpa_supplicant/](http://hostap.epitest.fi/wpa_supplicant/)*
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: ^([[99](#ch09fn13)]) Jouni Malinen，*Linux WPA/WPA2/IEEE 802.1X 客户端*，*[http://hostap.epitest.fi/wpa_supplicant/](http://hostap.epitest.fi/wpa_supplicant/)*
