- en: <hgroup>
  id: totrans-0
  prefs: []
  type: TYPE_NORMAL
  zh: <hgroup>
- en: F ANSWERS TO QUESTIONS
  id: totrans-1
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: F 问题的答案
- en: </hgroup>
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: </hgroup>
- en: F.1 Chapter 1
  id: totrans-3
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: F.1 第一章
- en: 1.  *as*
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 1.  *作为*
- en: 2.  address, data, and control
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 2.  地址、数据和控制
- en: 3.  The PSTATE register
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 3.  PSTATE 寄存器
- en: 4.  (a) 4, (b) 8, (c) 16, (d) 8
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 4.  (a) 4, (b) 8, (c) 16, (d) 8
- en: 5.  64 bits
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 5.  64 位
- en: 6.  bl
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 6.  bl
- en: 7.  ret
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 7.  ret
- en: 8.  Application binary interface
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 8.  应用程序二进制接口
- en: 9.  (a) LO byte of W0, (b) LO hword of W0, (c) W0, (d) X0, (e) X0
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 9.  (a) W0 的低字节, (b) W0 的低半字, (c) W0, (d) X0, (e) X0
- en: 10.  X0, X1, X2, and X3 registers (respectively)
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 10.  X0, X1, X2, 和 X3 寄存器（分别）
- en: F.2 Chapter 2
  id: totrans-14
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: F.2 第二章
- en: 1.  9 × 10³ + 3 × 10² + 8 × 10¹ + 4 × 10⁰ + 5 × 10 ^(–1) + 7 × 10^(–2) + 6 ×
    10^(–3)
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 1.  9 × 10³ + 3 × 10² + 8 × 10¹ + 4 × 10⁰ + 5 × 10 ^(–1) + 7 × 10^(–2) + 6 ×
    10^(–3)
- en: 2.  (a) 10, (b) 12, (c) 7, (d) 9, (e) 3, (f) 15
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 2.  (a) 10, (b) 12, (c) 7, (d) 9, (e) 3, (f) 15
- en: 3.  (a) A, (b) E, (c) B, (d) D, (e) 2, (f) C, (g) CF, (h) 98D1
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 3.  (a) A, (b) E, (c) B, (d) D, (e) 2, (f) C, (g) CF, (h) 98D1
- en: 4.  (a) 0001_0010_1010_1111
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 4.  (a) 0001_0010_1010_1111
- en: (b)  1001_1011_1110_0111
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: (b)  1001_1011_1110_0111
- en: (c)  0100_1010
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: (c)  0100_1010
- en: (d)  0001_0011_0111_1111
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: (d)  0001_0011_0111_1111
- en: (e)  1111_0000_0000_1101
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: (e)  1111_0000_0000_1101
- en: (f)  1011_1110_1010_1101
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: (f)  1011_1110_1010_1101
- en: (g)  0100_1001_0011_1000
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: (g)  0100_1001_0011_1000
- en: 5.  (a) 10, (b) 11, (c) 15, (d) 13, (e) 14, (f) 12
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 5.  (a) 10, (b) 11, (c) 15, (d) 13, (e) 14, (f) 12
- en: 6.  (a) 32, (b) 128, (c) 16, (d) 64, (e) 4, (f) 8, (g) 4
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 6.  (a) 32, (b) 128, (c) 16, (d) 64, (e) 4, (f) 8, (g) 4
- en: 7.  (a) 4, (b) 8, (c) 16, (d) 2
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 7.  (a) 4, (b) 8, (c) 16, (d) 2
- en: 8.  (a) 16, (b) 256, (c) 65,536, (d) 2
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 8.  (a) 16, (b) 256, (c) 65,536, (d) 2
- en: 9.  4
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 9.  4
- en: 10.  0 through 7
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 10.  0 到 7
- en: 11.  Bit 0
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 11.  位 0
- en: 12.  Bit 63
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 12.  位 63
- en: 13.  (a) 0, (b) 0, (c) 0, (d) 1
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 13.  (a) 0, (b) 0, (c) 0, (d) 1
- en: 14.  (a) 0, (b) 1, (c) 1, (d) 1
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 14.  (a) 0, (b) 1, (c) 1, (d) 1
- en: 15.  (a) 0, (b) 1, (c) 1, (d), 0
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 15.  (a) 0, (b) 1, (c) 1, (d) 0
- en: 16.  XORing with 1 (bitwise, all 1 bits in a register)
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 16.  与 1 做异或（按位操作，寄存器中所有 1 位）
- en: 17.  AND
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 17.  与
- en: 18.  OR
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 18.  或
- en: 19.  NOT (XOR with all 1 bits too)
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 19.  非（XOR 也与所有 1 位进行异或）
- en: 20.  XOR
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 20.  异或
- en: 21.  not (eor with all 1 bits too)
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 21.  非（eor 也与所有 1 位进行异或）
- en: 22.  1111_1011
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 22.  1111_1011
- en: 23.  0000_0010
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 23.  0000_0010
- en: 24.  (a) 1111_1111b, (c) 1000_0000b, (e) 1000_0001b
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 24.  (a) 1111_1111b, (c) 1000_0000b, (e) 1000_0001b
- en: 25.  The neg instruction
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 25.  neg 指令
- en: 26.  (a) 1111_1111_1111_1111
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 26.  (a) 1111_1111_1111_1111
- en: (c)  000_0000_0000_0001
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: (c)  000_0000_0000_0001
- en: (d)  1111_1111_1111_0000
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: (d)  1111_1111_1111_0000
- en: 27.  b (b.al)
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 27.  b (b.al)
- en: '28.  label:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 28.  标签：
- en: 29.  Negative/sign (N), zero (Z), carry (C), and overflow (V)
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 29.  负标志（N），零标志（Z），进位标志（C），溢出标志（V）
- en: 30.  Z = 1
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 30.  Z = 1
- en: 31.  C = 0 and Z = 0
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 31.  C = 0 和 Z = 0
- en: 32.  bhi, bhs, bls, blo, beq, and bne conditional jump instructions
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 32.  bhi, bhs, bls, blo, beq, 和 bne 条件跳转指令
- en: 33.  bgt, bge, blt, ble, beq, and bne conditional jump instructions
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 33.  bgt, bge, blt, ble, beq, 和 bne 条件跳转指令
- en: 34.  The lsl instruction does not affect the zero flag.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 34.  lsl 指令不会影响零标志位。
- en: 35.  A multiplication by 2
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 35.  乘以 2
- en: 36.  A division by 2
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 36.  除以 2
- en: 37.  Multiplication and division
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 37.  乘法和除法
- en: 38.  A normalized floating-point value has a 1 bit in the HO mantissa position.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 38.  规范化的浮点值在高阶尾数位置有一个 1 位。
- en: 39.  7 bits
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 39.  7 位
- en: 40.  0x30 through 0x39
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 40.  0x30 到 0x39
- en: 41.  The apostrophe (or single quotation mark) character
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 41.  撇号（或单引号）字符
- en: F.3 Chapter 3
  id: totrans-64
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: F.3 第三章
- en: 1.  The PC 64-bit register
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 1.  PC 64 位寄存器
- en: 2.  Operation code, the numeric encoding for a machine instruction
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 2.  操作码，机器指令的数字编码
- en: 3.  Static/scalar variables and memory-based constants
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 3.  静态/标量变量和基于内存的常量
- en: 4.  About ±1 MB, with the ldr and str instructions
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 4.  大约 ±1 MB，使用 ldr 和 str 指令
- en: 5.  The address of the memory location to access
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 5.  访问内存位置的地址
- en: 6.  (b) X0 and (d) SP
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 6.  (b) X0 和 (d) SP
- en: 7.  The lea macro (or adr and adrp instructions)
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 7.  lea 宏（或 adr 和 adrp 指令）
- en: 8.  The final address obtained after all addressing mode calculations are completed
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 8.  完成所有寻址模式计算后得到的最终地址
- en: 9.  Use the .align 3 directive to align a variable in the .data section to an
    8-byte boundary.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 9.  使用 .align 3 指令将变量在 .data 区段对齐到 8 字节边界。
- en: 10.  Memory management unit
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 10.  内存管理单元
- en: 11.  An arithmetic expression that computes the (static) runtime address of
    a memory object
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 11.  计算内存对象（静态）运行时地址的算术表达式
- en: 12.  A big-endian value stores high-order portions of the value in lower memory
    addresses, while a little-endian value stores the low-order portions of the value
    in lower memory addresses.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 12.  大端值将值的高位部分存储在较低的内存地址中，而小端值将值的低位部分存储在较低的内存地址中。
- en: 13.  The rev32 instruction
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 13.  rev32 指令
- en: 14.  The rev16 instruction
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 14.  rev16 指令
- en: 15.  The rev instruction
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 15.  rev 指令
- en: 16.  Subtract 16 from SP, then store the value in X0 at the memory address pointed
    at by SP.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 16.  从 SP 减去 16，然后将值存储到 X0 中，存储位置由 SP 指向。
- en: 17.  Load X0 from the address pointed at by SP, then add 16 to the SP register.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 17.  从 SP 指向的地址加载 X0，然后将 16 加到 SP 寄存器。
- en: 18.  Reverse
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 18.  反转
- en: 19.  Last-in, first-out
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 19.  后进先出
- en: '## F.4 Chapter 4'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: '## F.4 第4章'
- en: 1.  A symbolic name for a constant that the assembler (or preprocessor) will
    replace with the numeric equivalent of that constant during assembly
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 1.  一个常量的符号名称，汇编程序（或预处理器）将在汇编过程中用该常量的数值等效值替换
- en: '2.  Use the .equ, .set, and = directives. You can also use the C preprocessor
    (CPP) #define directive if your source file’s name ends with *.S*.'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 2.  使用 `.equ`、`.set` 和 `=` 指令。如果你的源文件名以 *.S* 结尾，你还可以使用 C 预处理器（CPP）的 `#define`
    指令。
- en: 3.  A constant expression is an arithmetic expression that Gas can compute during
    assembly. You determine the number of data elements in the operand field of a
    byte directive by counting the expressions separated by commas.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 3.  常量表达式是一个算术表达式，Gas 可以在汇编过程中计算出该表达式的值。你通过计算由逗号分隔的表达式数量来确定字节指令操作数字段中的数据元素数量。
- en: 4.  The current offset into a section (such as .data or .text)
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 4.  当前在某个段中的偏移量（如 `.data` 或 `.text`）
- en: 5.  The period operator (.)
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 5.  句点操作符（.）
- en: 6.  Subtract the label of the second declaration from the label of the first
    (for example, second - first).
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 6.  将第二个声明的标签减去第一个声明的标签（例如，第二 - 第一）。
- en: 7.  A 64-bit memory variable containing the address of another memory object;
    you would use a .dword directive to allocate storage for a pointer (or other mechanism
    to reserve 64 bits).
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 7.  一个64位内存变量，包含另一个内存对象的地址；你可以使用 `.dword` 指令为指针分配存储空间（或使用其他机制保留64位空间）。
- en: 8.  Load that pointer into a 64-bit register and use the register-indirect addressing
    mode to access memory.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 8.  将指针加载到一个64位寄存器中，并使用寄存器间接寻址模式访问内存。
- en: 9.  Use the .dword directive.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 9.  使用 `.dword` 指令。
- en: 10.  Using an uninitialized pointer; using a pointer that contains an illegal
    value; continuing to use allocated data after it has been freed (a *dangling pointer*);
    failing to free memory after you are done using it (a *memory leak*); accessing
    indirect data by using the wrong data type
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 10.  使用未初始化的指针；使用包含非法值的指针；继续使用已释放的已分配数据（*悬空指针*）；使用完内存后没有释放它（*内存泄漏*）；使用错误的数据类型访问间接数据
- en: 11.  A pointer to allocated memory that has already been freed
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 11.  指向已分配内存的指针，但该内存已经被释放
- en: 12.  A memory leak occurs when a program allocates memory (using malloc()) but
    fails to free that storage when it is done using it.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 12.  内存泄漏发生在程序分配内存（使用 `malloc()`）但在使用完毕后没有释放该存储空间时。
- en: 13.  An object composed of (made up from) a collection of other data types
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 13.  一个由其他数据类型集合构成的对象
- en: 14.  A sequence of characters delimited by a zero value (typically a byte)
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 14.  一个由零值（通常是字节）分隔的字符序列
- en: 15.  A sequence of characters beginning with a length value (typically a byte,
    but it could also be a half word, word, or other type)
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 15.  一个以长度值开始的字符序列（通常是字节，但也可以是半字、字或其他类型）
- en: 16.  A structure that describes a string object, typically containing length
    information and a pointer to the string
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 16.  描述字符串对象的结构，通常包含长度信息和指向字符串的指针
- en: 17.  A sequence of objects (all the same type) appearing in consecutive memory
    locations
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 17.  在连续内存位置中出现的相同类型的对象序列
- en: 18.  The address of the first element, typically at the lowest address of the
    array in memory
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 18.  第一个元素的地址，通常是数组在内存中最低地址的位置
- en: '19.  Here is a typical array declaration using Gas:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 19.  这是一个使用 Gas 的典型数组声明：
- en: '[PRE0]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '20.  You will typically use a directive such as .word with a list of the initial
    element values; here’s an example:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 20.  你通常会使用像 `.word` 这样的指令，并列出初始元素值；这是一个示例：
- en: '[PRE1]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: You could also use the .space directive if you have an array of bytes and every
    byte is initialized with the same value.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你有一个字节数组，并且每个字节都用相同的值初始化，你也可以使用 `.space` 指令。
- en: 21.  (a) Multiply the index by 8 and add the base address of A to this product;
    (b) To access W[i, j], use address = base(W) + (i * 8 + j) * 4; (c) To access
    R[i, j, k], use address = base(R) + ((i * 4) + j) * 6 + k) * 4.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 21.  (a) 将索引乘以8并将数组A的基地址加到这个乘积中；(b) 要访问 `W[i, j]`，使用地址 = base(W) + (i * 8 +
    j) * 4；(c) 要访问 `R[i, j, k]`，使用地址 = base(R) + ((i * 4) + j) * 6 + k) * 4。
- en: 22.  A mechanism for storing arrays in memory, where elements from each row
    appear in consecutive memory locations and the rows appear in consecutive blocks
    of memory
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 22.  存储数组的内存机制，其中每行的元素出现在连续的内存位置中，行本身则出现在连续的内存块中
- en: 23.  A mechanism for storing arrays in memory, where elements from each column
    appear in consecutive memory locations and the columns appear in consecutive blocks
    of memory
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 23.  在内存中存储数组的机制，其中每一列的元素出现在连续的内存位置中，而列出现在连续的内存块中
- en: '24.  A typical two-dimensional array declaration for word array W[4,8] would
    take this form: W: .space 4 * 8 * 4, 0.'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: '24.  一个典型的二维数组声明，例如字数组 W[4,8]，形式如下：W: .space 4 * 8 * 4, 0。'
- en: 25.  A composite data type whose elements (fields) need not all be the same
    type
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 25.  一种复合数据类型，其元素（字段）不必都具有相同类型
- en: '26.  Use statements like the following:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 26.  使用如下语句：
- en: '[PRE2]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 27.  Add the offset of a particular field to the base address of the structure.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 27.  将特定字段的偏移量加到结构的基地址上。
- en: 28.  A type of structure in which all fields occupy the same memory locations
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 28.  一种结构，其中所有字段占用相同的内存位置
- en: 29.  For structs, each field is allocated a unique block of memory (according
    to its size), whereas for a union, all fields are allocated the same memory locations.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 29.  对于结构体，每个字段分配一个独立的内存块（根据其大小），而对于共用体，所有字段分配相同的内存位置。
- en: F.5 Chapter 5
  id: totrans-118
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: F.5 第5章
- en: 1.  The bl instruction copies the address of the next instruction into LR, then
    transfers control to the target address specified by the operand.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 1.  bl 指令将下一条指令的地址复制到 LR 寄存器中，然后将控制转移到操作数指定的目标地址。
- en: 2.  The ret instruction copies the value from the LR into the program counter.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 2.  ret 指令将 LR 中的值复制到程序计数器。
- en: 3.  The biggest problem with caller preservation is that it is hard to maintain.
    It also generates bigger object code files.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 3.  调用者保存的最大问题是难以维护。它还会生成更大的目标代码文件。
- en: 4.  It saves registers, taking valuable CPU cycles, even if the caller doesn’t
    require those registers to be saved.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 4.  它保存寄存器，占用了宝贵的 CPU 周期，即使调用者不要求保存这些寄存器。
- en: 5.  Storage space in the stack, where a procedure maintains parameters, return
    addresses, saved register values, local variables, and possibly other data
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 5.  栈中的存储空间，过程在其中维护参数、返回地址、保存的寄存器值、本地变量以及可能的其他数据
- en: 6.  The FP register (X29)
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 6.  FP 寄存器（X29）
- en: '7.  The standard entry sequence is as follows:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 7.  标准入口序列如下：
- en: '[PRE3]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '8.  The standard exit sequence is shown here:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 8.  标准退出序列如下所示：
- en: '[PRE4]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 9.  A variable that a procedure automatically allocates and deallocates storage
    for in an activation record
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 9.  过程在激活记录中自动分配和释放存储的变量
- en: 10.  Upon entry into a procedure
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 10.  进入过程时
- en: 11.  The parameter’s value
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 11.  参数的值
- en: 12.  The parameter’s address
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 12.  参数的地址
- en: 13.  X0, X1, X2, and X3
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 13.  X0, X1, X2 和 X3
- en: 14.  All parameters beyond the eighth parameter get passed on the stack.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 14.  超过第八个参数的所有参数通过栈传递。
- en: 15.  Volatile registers can be used by an ARM procedure without preserving their
    values; nonvolatile registers’ values must be preserved across a procedure call.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 15.  ARM 过程可以使用易失性寄存器而不保存其值；非易失性寄存器的值必须在过程调用间保持。
- en: 16.  Registers X0, X1, ..., X15
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 16.  寄存器 X0, X1, ..., X15
- en: 17.  Registers X16 through X31 (SP)
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 17.  寄存器 X16 到 X31（SP）
- en: 18.  A procedure accesses parameters passed in the code stream via the address
    passed in the LR register.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 18.  过程通过 LR 寄存器中传递的地址访问传递的参数。
- en: 19.  Large parameters (such as arrays and records) should be passed by reference,
    since the procedure is faster and shorter when using reference arguments.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 19.  大型参数（如数组和记录）应通过引用传递，因为使用引用参数时，过程运行更快且更简短。
- en: 20.  The X0 register (X8 can contain a pointer to a large function return result)
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 20.  X0 寄存器（X8 可以包含指向大型函数返回结果的指针）
- en: 21.  The address of a procedure to call, passed as an argument to a procedure
    or function
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 21.  传递给过程或函数的调用程序地址，作为参数传递
- en: 22.  Call procedural parameters (as well as any procedure via a pointer) by
    using the br instruction.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 22.  使用 br 指令调用过程参数（以及通过指针调用任何过程）。
- en: '23.  Set aside local storage for the registers and preserve those values in
    the local storage.  ## F.6 Chapter 6'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: '23.  为寄存器预留本地存储空间，并在本地存储中保存这些值。  ## F.6 第6章'
- en: 1.  The cmp instruction sets the zero flag if the two operands are equal.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 1.  cmp 指令会在两个操作数相等时设置零标志。
- en: 2.  The cmp instruction sets the carry flag if one unsigned operand (left) is
    greater than or equal to the other unsigned operand (right).
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 2.  cmp 指令会在一个无符号操作数（左边）大于或等于另一个无符号操作数（右边）时设置进位标志。
- en: 3.  The cmp instruction sets negative and overflow flags to opposite values
    if the left signed operand is less than the signed right operand; they are set
    to the same value if the left signed operand is greater than or equal to the right
    signed operand.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 3.  cmp指令会在左操作数小于右操作数时将负标志和溢出标志设置为相反的值；当左操作数大于或等于右操作数时，它们将被设置为相同的值。
- en: '4.  x = x + y:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: '4.  x = x + y:'
- en: '[PRE5]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'x = y - z:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 'x = y - z:'
- en: '[PRE6]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'x = y * z:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 'x = y * z:'
- en: '[PRE7]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'x = y + z * t:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 'x = y + z * t:'
- en: '[PRE8]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'x = (y + z) * t:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 'x = (y + z) * t:'
- en: '[PRE9]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'x = -((x * y) / z):'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 'x = -((x * y) / z):'
- en: '[PRE10]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'x = (y == z) && (t != 0):'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 'x = (y == z) && (t != 0):'
- en: '[PRE11]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '5.  x = x * 2:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: '5.  x = x * 2:'
- en: '[PRE12]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'x = y * 5:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 'x = y * 5:'
- en: '[PRE13]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'x = y * 8:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 'x = y * 8:'
- en: '[PRE14]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '6.  x = x / 2:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: '6.  x = x / 2:'
- en: '[PRE15]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'x = y / 8:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 'x = y / 8:'
- en: '[PRE16]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'x = z / 10:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 'x = z / 10:'
- en: '[PRE17]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: '7.  x = x + y:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: '7.  x = x + y:'
- en: '[PRE18]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'x = y - z:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 'x = y - z:'
- en: '[PRE19]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'x = y * z:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 'x = y * z:'
- en: '[PRE20]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'x = y + z * t:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 'x = y + z * t:'
- en: '[PRE21]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'x = (y + z) * t:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 'x = (y + z) * t:'
- en: '[PRE22]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'x = -((x * y) / z):'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 'x = -((x * y) / z):'
- en: '[PRE23]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: '8.  bb = x < y:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: '8.  bb = x < y:'
- en: '[PRE24]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'bb = x >= y && x < z:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 'bb = x >= y && x < z:'
- en: '[PRE25]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: F.7 Chapter 7
  id: totrans-189
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: F.7 第7章
- en: 1.  Use the lea macro to obtain the address of a symbol in the program.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 1.  使用lea宏来获取程序中符号的地址。
- en: 2.  br reg64
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 2.  br reg64
- en: 3.  A piece of code that keeps track of its execution history by entering and
    leaving certain states
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 3.  一段通过进入和离开某些状态来跟踪执行历史的代码
- en: 4.  A mechanism for extending the range of a branch instruction
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 4.  扩展分支指令范围的机制
- en: 5.  Short-circuit Boolean evaluation might not execute code for all the conditions
    in an expression if it determines the result to be true or false without executing
    any additional code. Complete Boolean evaluation evaluates the entire expression,
    even if the result is known after a partial evaluation of the expression.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 5.  短路布尔运算可能不会执行表达式中的所有条件代码，如果它确定结果为真或假而不执行任何额外代码。完全的布尔运算会评估整个表达式，即使在部分评估之后已知结果。
- en: '6.'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: '6.'
- en: a.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: a.
- en: '[PRE26]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: b.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: b.
- en: '[PRE27]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: '7.'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: '7.'
- en: a.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: a.
- en: '[PRE28]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: b.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: b.
- en: '[PRE29]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: '8.  The following switch statements (assume all variables are unsigned 32-bit
    integers) become the assembly language code:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 8.  以下switch语句（假设所有变量都是无符号32位整数）将转换为汇编语言代码：
- en: a.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: a.
- en: '[PRE30]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: b.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: b.
- en: '[PRE31]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: '9.  The following while loops get converted to the corresponding assembly code
    (assuming all variables are signed 32-bit integers):'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 9.  以下while循环将转换为相应的汇编代码（假设所有变量为有符号32位整数）：
- en: a.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: a.
- en: '[PRE32]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: b.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: b.
- en: '[PRE33]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: c.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: c.
- en: '[PRE34]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: F.8 Chapter 8
  id: totrans-217
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: F.8 第8章
- en: '1.'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: '1.'
- en: a.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: a.
- en: '[PRE35]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: b.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: b.
- en: '[PRE36]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: c.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: c.
- en: '[PRE37]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: '2.'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: '2.'
- en: a.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: a.
- en: '[PRE38]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: b.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: b.
- en: '[PRE39]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: '3.'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: '3.'
- en: '[PRE40]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: '4.  The conversions are as follows:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 4.  转换如下：
- en: a.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: a.
- en: '[PRE41]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: b.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: b.
- en: '[PRE42]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: c.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: c.
- en: '[PRE43]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: d.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: d.
- en: '[PRE44]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: '5.  The conversions are as follows:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 5.  转换如下：
- en: a.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: a.
- en: '[PRE45]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: b.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: b.
- en: '[PRE46]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: '6.  The conversions are as follows:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 6.  转换如下：
- en: a.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: a.
- en: '[PRE47]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: b.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: b.
- en: '[PRE48]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: c.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: c.
- en: '[PRE49]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: d.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: d.
- en: '[PRE50]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: e.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: e.
- en: '[PRE51]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: f.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: f.
- en: '[PRE52]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: '7.'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: '7.'
- en: '[PRE53]'
  id: totrans-260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: '8.'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: '8.'
- en: '[PRE54]'
  id: totrans-262
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: '## F.9 Chapter 9'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: '## F.9 第9章'
- en: 1.  Four output digits
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 1.  四位输出数字
- en: 2.  Call qToStr twice, the first time passing in the HO dword, the second time
    passing in the LO dword.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 2.  调用qToStr两次，第一次传入高字节（HO），第二次传入低字节（LO）。
- en: 3.  Take the input value and see if it is negative. If so, emit a dash (-) character
    and negate the value. Whether the number is negative or nonnegative, call the
    unsigned conversion function to do the rest of the work.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 3.  获取输入值并检查是否为负数。如果是，输出一个减号(-)字符并将值取反。无论数值是负数还是非负数，调用无符号转换函数处理其余部分。
- en: 4.  The u64toSizeStr function expects a pointer to the destination buffer in
    X0, the value to convert to a string in X1, and the minimum field width in X3.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 4.  u64toSizeStr函数期望X0中传递指向目标缓冲区的指针，X1中传递要转换为字符串的值，X3中传递最小字段宽度。
- en: 5.  The function will output however many characters are necessary to correctly
    represent the value.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 5.  该函数将输出足够的字符以正确表示值。
- en: 6.  The r64ToStr function expects the floating-point value to convert in D0,
    a pointer to the buffer in X0, the field width in X1, the number of digits after
    the decimal point in X2, the padding character in the LO byte of X3, and the maximum
    string length in X4.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 6.  r64ToStr函数期望D0中传递要转换的浮点值，X0中传递缓冲区指针，X1中传递字段宽度，X2中传递小数点后的位数，X3的低字节中传递填充字符，X4中传递最大字符串长度。
- en: '7.  A string fWidth characters long, containing the # character if it cannot
    properly format the output'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 7.  一个包含#字符的fWidth长度的字符串，如果无法正确格式化输出
- en: 8.  D0 contains the value to convert; X0 contains the address of the output
    buffer; X1 contains the field width; X2 is the padding character; X3 contains
    the number of exponent digits; X4 is the maximum string width.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 8.  D0包含要转换的值；X0包含输出缓冲区的地址；X1包含字段宽度；X2为填充字符；X3包含指数数字的个数；X4为最大字符串宽度。
- en: 9.  A character used to begin, end, and separate input values
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 9.  一个用于开始、结束和分隔输入值的字符
- en: 10.  Overflow and illegal input characters
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 10.  溢出和非法输入字符
- en: F.10 Chapter 10
  id: totrans-274
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: F.10 第10章
- en: 1.  The set of legal input values
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 1.  合法输入值的集合
- en: 2.  The set of possible output values
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 2.  可能输出值的集合
- en: '3.'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: '3.'
- en: a.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: a.
- en: '[PRE55]'
  id: totrans-279
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: b.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: b.
- en: '[PRE56]'
  id: totrans-281
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: c.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: c.
- en: '[PRE57]'
  id: totrans-283
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: d.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: d.
- en: '[PRE58]'
  id: totrans-285
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 4.  The process of adjusting the input value to a function so that the minimum
    and maximum values are limited, in order to allow the use of smaller tables
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 4.  调整函数输入值的过程，使最小值和最大值受到限制，以便能够使用更小的表格
- en: 5.  Because memory access is so slow relative to computational performance
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 5.  因为内存访问相较于计算性能非常缓慢
- en: F.11 Chapter 11
  id: totrans-288
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: F.11 第11章
- en: 1.  A lane is an element of a byte, half-word, word, or dword array held within
    a vector register. When operating on a pair of vector registers, lanes are corresponding
    elements within the two vectors.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 1.  通道是向量寄存器中一个字节、半字、字或双字数组的元素。当对一对向量寄存器进行操作时，通道是两个向量中的对应元素。
- en: 2.  A scalar instruction operates on a single piece of data, while a vector
    instruction operates on multiple lanes (pieces of data) within a vector register.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 2.  标量指令对单个数据项进行操作，而向量指令对向量寄存器中的多个数据项（通道）进行操作。
- en: 3.  The fmov Sd, Ws instruction
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 3.  fmov Sd, Ws 指令
- en: 4.  The fmov Dd, Xs instruction
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 4.  fmov Dd, Xs 指令
- en: 5.  The tbl or tbx instruction
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 5.  tbl 或 tbx 指令
- en: 6.  The mov Vd.t[index], Rs instruction (Rn = Xn or Wn)
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 6.  mov Vd.t[index], Rs 指令（Rn = Xn 或 Wn）
- en: '7.  The shl Vd.2D, Vs.2D, #n instruction'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: '7.  shl Vd.2D, Vs.2D, #n 指令'
- en: 8.  A vertical addition adds the corresponding lanes from two vector registers
    together, while a horizontal addition adds adjacent lanes in a single vector register
    together.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 8.  垂直加法将两个向量寄存器中的对应通道相加，而水平加法将一个向量寄存器中的相邻通道相加。
- en: '9.  Use the movi v0.16B, #0 instruction.'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: '9.  使用 movi v0.16B, #0 指令。'
- en: '10.  Use the movi v0.16B, #0xff instruction.'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: '10.  使用 movi v0.16B, #0xff 指令。'
- en: F.12 Chapter 12
  id: totrans-299
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: F.12 第12章
- en: 1.  The and and bic instructions
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 1.  and 和 bic 指令
- en: 2.  The bic instruction
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 2.  bic 指令
- en: 3.  The orr instruction
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 3.  orr 指令
- en: 4.  The eor instruction
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 4.  eor 指令
- en: 5.  The tst instruction
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 5.  tst 指令
- en: 6.  The bfxil (or bfm) instruction
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 6.  bfxil（或 bfm）指令
- en: 7.  The bfi (or bfm) instruction
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 7.  bfi（或 bfm）指令
- en: 8.  The clz instruction
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 8.  clz 指令
- en: 9.  You could reverse the bits in the register, invert all the bits, and then
    use the clz instruction to find the first nonzero bit.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 9.  你可以反转寄存器中的位，反转所有位，然后使用 clz 指令找到第一个非零位。
- en: 10.  The cnt instruction
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 10.  cnt 指令
- en: F.13 Chapter 13
  id: totrans-310
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: F.13 第13章
- en: 1.  Compile-time language
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 1.  编译时语言
- en: 2.  During assembly (compilation)
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 2.  在汇编过程中（编译时）
- en: 3.  #warning
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 3.  #warning
- en: 4..warning
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 4..warning
- en: 5.  #error
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 5.  #error
- en: 6..error
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 6..error
- en: 7.  #define
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 7.  #define
- en: 8..equ, .set, and =
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 8..equ、.set 和 =
- en: '9.  #ifdef, #ifndef, #if, #elif, #else, and #endif'
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: '9.  #ifdef, #ifndef, #if, #elif, #else 和 #endif'
- en: 10.  The main Gas conditional assembly directives are .if, .elseif, .else, and
    .endif. The secondary assembly directives are .ifdef, .ifb, .ifc, .ifeq, .ifeqs,
    .ifge, .ifgt, .ifile, .iflt, .ifnb, .ifnc, .ifndef/.ifnotdef, .ifne, .ifnc, and
    .ifnes.
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 10.  主要的 Gas 条件汇编指令是 .if、.elseif、.else 和 .endif。次要的汇编指令有 .ifdef、.ifb、.ifc、.ifeq、.ifeqs、.ifge、.ifgt、.ifile、.iflt、.ifnb、.ifnc、.ifndef/.ifnotdef、.ifne、.ifnc
    和 .ifnes。
- en: 11.  The CPP map macro
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 11.  CPP 映射宏
- en: 12..rept, .irp, .irpc, and .endr
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 12..rept、.irp、.irpc 和 .endr
- en: 13..irpc
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 13..irpc
- en: 14.  #define
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 14.  #define
- en: 15..macro and .endm
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 15..宏和 .endm
- en: 16.  Specify the macro name at the place in the file where an instruction mnemonic
    is expected.
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 16.  在文件中指令助记符应出现的地方指定宏名称。
- en: '17.  Use functional notation. For example: mymacro(p1, p2).'
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 17.  使用函数符号。例如：mymacro(p1, p2)。
- en: '18.  Specify Gas macro parameters as operands in the instruction operand field.
    For example: lea x0, label (x0 and label are the parameters to the lea macro).'
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 18.  在指令操作数字段中指定 Gas 宏参数作为操作数。例如：lea x0, label（x0 和 label 是 lea 宏的参数）。
- en: 19.  Put :req after the parameter in the macro declaration.
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 19.  在宏声明中将 :req 放在参数后面。
- en: 20.  Specify the parameter name in the macro declaration without a suffix (:req,
    :varargs, or =expression). By default, Gas macro parameters are optional.
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 20.  在宏声明中指定参数名称，不带后缀（:req、:varargs 或 =expression）。默认情况下，Gas 宏参数是可选的。
- en: '21.  Use ... as the last (or only) argument in a #define macro definition.'
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: '21.  在 #define 宏定义中，将 ... 用作最后（或唯一）一个参数。'
- en: 22.  Put :varargs after the last (or only) argument in a Gas macro definition.
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 22.  在 Gas 宏定义中，将 :varargs 放在最后（或唯一）一个参数后面。
- en: 23.  Use the .ifb (if blank) conditional assembly directive.
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 23.  使用 .ifb (if blank) 条件汇编指令。
- en: 24..exitm
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 24..exitm
- en: '## F.14 Chapter 14'
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: '## F.14 第14章'
- en: 1.  A sequence of zero or more characters in memory ending with a byte containing
    0
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 1.  内存中以一个包含 0 的字节结尾的零个或多个字符序列
- en: 2.  Because the program must often scan the entire string to determine its length
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 2.  因为程序通常必须扫描整个字符串以确定其长度
- en: 3.  Because this string assembly language type (a) encodes the string’s length
    as part of the data type, (b) aligns the string data on a 16-byte boundary, and
    (c) guarantees that the storage for the string is a multiple of 16 bytes long.
    This allows algorithms to fetch additional data beyond the end of the string,
    as long as all the data fits within a block of 16 bytes aligned on a 16-byte boundary.
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 3.  因为这种字符串汇编语言类型（a）将字符串的长度作为数据类型的一部分进行编码，（b）将字符串数据对齐到16字节边界，并且（c）保证字符串的存储空间是16字节的倍数。这允许算法获取字符串末尾之外的额外数据，只要所有数据都适合在对齐到16字节边界的16字节块内。
- en: 4.  Because the starting index argument can be any value
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 4.  因为起始索引参数可以是任何值
- en: 5.  Because they must deal with variable-length characters
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 5.  因为它们必须处理可变长度的字符
- en: F.15 Chapter 15
  id: totrans-341
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: F.15 第15章
- en: 1.  #ifndef or .ifndef
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 1.  #ifndef 或 .ifndef
- en: 2.  The assembly of a source file plus any files it directly or indirectly includes
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 2.  一个源文件的汇编加上它直接或间接包含的任何文件
- en: 3..global
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 3..global
- en: 4..extern. Technically, using this directive is optional, as Gas assumes all
    undefined symbols are external.
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 4..extern。严格来说，使用这个指令是可选的，因为 Gas 假设所有未定义的符号都是外部符号。
- en: '5.'
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: '5.'
- en: '[PRE59]'
  id: totrans-347
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 6.  A makefile-dependent file is a file that must be built or updated in order
    to properly build the current file (that is, the current file depends on the makefile-dependent
    file in order to be built).
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 6.  一个依赖于 makefile 的文件是必须构建或更新的文件，以便正确构建当前文件（也就是说，当前文件依赖于该 makefile 依赖的文件才能被构建）。
- en: 7.  Delete all executable and object-code files produced by a make operation.
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 7.  删除通过 make 操作生成的所有可执行文件和目标代码文件。
- en: 8.  A collection of object modules that the linker can use to extract (only)
    those object modules it needs
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 8.  链接器可以使用的对象模块集合，以便仅提取它所需要的对象模块
- en: F.16 Chapter 16
  id: totrans-351
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: F.16 第16章
- en: 1.  The operating system typically uses svc to call an OS API function.
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 1.  操作系统通常使用 svc 调用操作系统的 API 函数。
- en: 2.  #0
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 2.  #0
- en: 3.  #0x80
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 3.  #0x80
