- en: '![](../images/pg612.jpg)'
  id: totrans-0
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/pg612.jpg)'
- en: <samp class="SANS_Futura_Std_Book_Oblique_I_11">[Description](description-63.xhtml)</samp>
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">[描述](description-63.xhtml)</samp>
- en: <hgroup>
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: <hgroup>
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">20</samp> <samp class="SANS_Dogma_OT_Bold_B_11">REGISTER
    ALLOCATION</samp>
  id: totrans-3
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">20</samp> <samp class="SANS_Dogma_OT_Bold_B_11">寄存器分配</samp>
- en: </hgroup>
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: </hgroup>
- en: '![](../images/opener-img.jpg)'
  id: totrans-5
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/opener-img.jpg)'
- en: Up until now, you’ve allocated space for every pseudoregister on the stack.
    This strategy is simple but painfully inefficient. Because instructions can’t
    always operate on values in memory directly, you sometimes need to generate extra
    instructions to copy values between these stack locations and registers. Even
    worse, the assembly code you generate has to access memory constantly, even though
    registers are faster. Now you’ll solve those problems. You’ll finish up your compiler
    by adding a *register allocation* pass, bolded in the diagram at the start of
    the chapter, to assign pseudoregisters to hard registers instead of locations
    in memory. You’ll use graph coloring, a classic register allocation technique,
    to come up with this assignment.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，你已经为每个伪寄存器在堆栈上分配了空间。这种策略很简单，但效率低下。由于指令无法总是直接操作内存中的值，因此有时你需要生成额外的指令来在这些堆栈位置和寄存器之间复制值。更糟糕的是，你生成的汇编代码必须不断访问内存，尽管寄存器的访问速度更快。现在你将解决这些问题。你将通过在本章开头的图示中添加一个
    *寄存器分配* 过程，来完成你的编译器，将伪寄存器分配给硬寄存器，而不是分配给内存中的位置。你将使用图着色技术，这是一种经典的寄存器分配方法，来完成这一分配。
- en: 'Once the initial version of the register allocator is up and running, you’ll
    give it one more job: to clean up some of the unnecessary <samp class="SANS_TheSansMonoCd_W5Regular_11">mov</samp>
    instructions produced during assembly generation. The final version of your allocator
    will perform *register coalescing* before assigning pseudoregisters to hard registers.
    The register coalescing step will look for <samp class="SANS_TheSansMonoCd_W5Regular_11">mov</samp>
    instructions whose source and destination can be merged, or coalesced, into a
    single operand, which allows you to delete the instruction.'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦寄存器分配器的初始版本启动并运行，你将给它安排另一个任务：清理在汇编生成过程中产生的一些不必要的 <samp class="SANS_TheSansMonoCd_W5Regular_11">mov</samp>
    指令。最终版本的寄存器分配器将在分配伪寄存器到硬寄存器之前执行 *寄存器合并*。寄存器合并步骤将查找那些源和目标可以合并成一个操作数的 <samp class="SANS_TheSansMonoCd_W5Regular_11">mov</samp>
    指令，这样就可以删除该指令。
- en: 'Register allocation has a little bit of everything: high-level theory, low-level
    details, brand-new concepts, and familiar techniques from earlier chapters. And
    the payoff is very satisfying: at the end of the chapter, you’ll be generating
    dramatically more efficient code. I think it’s a good note to end the book on.'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 寄存器分配涉及很多内容：高层次的理论、低层次的细节、全新的概念，以及来自前几章的熟悉技术。而且结果非常令人满意：在本章结束时，你将生成显著更高效的代码。我认为这是结束本书的一个好时机。
- en: To get started, let’s look at an example that illustrates why register allocation
    is such a powerful optimization.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 为了开始，我们来看一个例子，说明为什么寄存器分配是如此强大的优化手段。
- en: <samp class="SANS_Futura_Std_Bold_B_11">Register Allocation in Action</samp>
  id: totrans-10
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">寄存器分配实践</samp>
- en: Consider the tiny C function in [Listing 20-1](chapter20.xhtml#list20-1).
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 请查看 [Listing 20-1](chapter20.xhtml#list20-1) 中的简单 C 函数。
- en: '[PRE0]'
  id: totrans-12
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 20-1: A tiny C function</samp>'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 20-1：一个简单的 C 函数</samp>
- en: First, our compiler will turn this into the tiny TACKY function in [Listing
    20-2](chapter20.xhtml#list20-2).
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们的编译器将把它转化为 [Listing 20-2](chapter20.xhtml#list20-2) 中的简单 TACKY 函数。
- en: '[PRE1]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 20-2: The TACKY code
    for [Listing 20-1](chapter20.xhtml#list20-1)</samp>'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 20-2：针对 [Listing 20-1](chapter20.xhtml#list20-1)
    的 TACKY 代码</samp>
- en: This listing gives the definition of <samp class="SANS_TheSansMonoCd_W5Regular_11">f</samp>
    after the optimization stage. (In particular, we’ve optimized out the extra <samp
    class="SANS_TheSansMonoCd_W5Regular_11">Return(0)</samp> that we add to the end
    of each TACKY function as a backstop for missing <samp class="SANS_TheSansMonoCd_W5Regular_11">return</samp>
    statements.)
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 本清单给出了优化阶段后 <samp class="SANS_TheSansMonoCd_W5Regular_11">f</samp> 的定义。（特别是，我们已经优化掉了每个
    TACKY 函数末尾的额外 <samp class="SANS_TheSansMonoCd_W5Regular_11">Return(0)</samp>，这作为缺失
    <samp class="SANS_TheSansMonoCd_W5Regular_11">return</samp> 语句的备用）
- en: Next, we’ll convert [Listing 20-2](chapter20.xhtml#list20-2) to the assembly
    code in [Listing 20-3](chapter20.xhtml#list20-3).
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将把[清单 20-2](chapter20.xhtml#list20-2)转换为[清单 20-3](chapter20.xhtml#list20-3)中的汇编代码。
- en: '[PRE2]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 20-3: The assembly
    code for [Listing 20-2](chapter20.xhtml#list20-2)</samp>'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">清单 20-3： [清单 20-2](chapter20.xhtml#list20-2)
    的汇编代码</samp>
- en: We set up the function’s parameters ❶, then we calculate <samp class="SANS_TheSansMonoCd_W5Regular_11">tmp0</samp>,
    <samp class="SANS_TheSansMonoCd_W5Regular_11">tmp1</samp>, and <samp class="SANS_TheSansMonoCd_W5Regular_11">tmp2</samp>
    ❷. Finally, we return <samp class="SANS_TheSansMonoCd_W5Regular_11">tmp2</samp>
    ❸. The operands <samp class="SANS_TheSansMonoCd_W5Regular_11">%x</samp>, <samp
    class="SANS_TheSansMonoCd_W5Regular_11">%y</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">%tmp0</samp>,
    <samp class="SANS_TheSansMonoCd_W5Regular_11">%tmp1</samp>, and <samp class="SANS_TheSansMonoCd_W5Regular_11">%tmp2</samp>
    in this listing refer to the corresponding pseudoregisters; I’ll use this notation
    throughout the chapter.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 我们设置函数的参数 ❶，然后计算 <samp class="SANS_TheSansMonoCd_W5Regular_11">tmp0</samp>、<samp
    class="SANS_TheSansMonoCd_W5Regular_11">tmp1</samp> 和 <samp class="SANS_TheSansMonoCd_W5Regular_11">tmp2</samp>
    ❷。最后，我们返回 <samp class="SANS_TheSansMonoCd_W5Regular_11">tmp2</samp> ❸。此清单中的操作数
    <samp class="SANS_TheSansMonoCd_W5Regular_11">%x</samp>、<samp class="SANS_TheSansMonoCd_W5Regular_11">%y</samp>、<samp
    class="SANS_TheSansMonoCd_W5Regular_11">%tmp0</samp>、<samp class="SANS_TheSansMonoCd_W5Regular_11">%tmp1</samp>
    和 <samp class="SANS_TheSansMonoCd_W5Regular_11">%tmp2</samp> 指的是相应的伪寄存器；我将在整个章节中使用此表示法。
- en: 'Now we’ll walk through three approaches to replacing these pseudoregisters
    with real operands. First, we’ll replace them with stack addresses, which is what
    our compiler does right now. On our next attempt, we’ll replace them with hard
    registers, without performing register coalescing first; this is what the initial
    version of our register allocator will do. The third time around, we’ll perform
    register coalescing before replacing the pseudoregisters with hard registers.
    That’s how our finished allocator will handle this program. (A quick note on terminology:
    throughout this chapter, I’ll use the word *register* to refer to pseudoregisters
    and hard registers collectively.)'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将通过三种方法来将这些伪寄存器替换为真实操作数。首先，我们将它们替换为栈地址，这正是我们当前编译器所做的。在下一个尝试中，我们将它们替换为硬件寄存器，而不先进行寄存器合并；这是我们寄存器分配器初始版本将执行的操作。第三次，我们将在替换伪寄存器为硬件寄存器之前执行寄存器合并。这就是我们完成的分配器将如何处理该程序。（关于术语的小提示：在本章中，我将使用*寄存器*一词来指代伪寄存器和硬件寄存器的统称。）
- en: '<samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Take One: Put Everything
    on the Stack</samp>'
  id: totrans-23
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">方法一：将所有内容放入栈中</samp>
- en: In its current form, our compiler will replace each pseudoregister with a stack
    slot according to [Table 20-1](chapter20.xhtml#tab20-1).
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 在当前形式下，我们的编译器会根据[表 20-1](chapter20.xhtml#tab20-1)将每个伪寄存器替换为栈槽。
- en: <samp class="SANS_Futura_Std_Heavy_B_11">Table 20-1:</samp> <samp class="SANS_Futura_Std_Book_11">Replacing
    Pseudoregisters with Stack Addresses</samp>
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Heavy_B_11">表 20-1:</samp> <samp class="SANS_Futura_Std_Book_11">用栈地址替换伪寄存器</samp>
- en: '| <samp class="SANS_Futura_Std_Heavy_B_11">Pseudoregister</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">Real
    location</samp> |'
  id: totrans-26
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_Futura_Std_Heavy_B_11">伪寄存器</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">真实位置</samp>
    |'
- en: '| --- | --- |'
  id: totrans-27
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">-4(%rbp)</samp>
    |'
  id: totrans-28
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">-4(%rbp)</samp>
    |'
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">y</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">-8(%rbp)</samp>
    |'
  id: totrans-29
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">y</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">-8(%rbp)</samp>
    |'
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">tmp0</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">-12(%rbp)</samp>
    |'
  id: totrans-30
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">tmp0</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">-12(%rbp)</samp>
    |'
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">tmp1</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">-16(%rbp)</samp>
    |'
  id: totrans-31
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">tmp1</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">-16(%rbp)</samp>
    |'
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">tmp2</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">-20(%rbp)</samp>
    |'
  id: totrans-32
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">tmp2</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">-20(%rbp)</samp>
    |'
- en: This will give us the assembly code in [Listing 20-4](chapter20.xhtml#list20-4).
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 这将给我们[清单 20-4](chapter20.xhtml#list20-4)中的汇编代码。
- en: '[PRE3]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 20-4: [Listing 20-3](chapter20.xhtml#list20-3)
    after replacing pseudoregisters with stack addresses</samp>'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">清单 20-4：将伪寄存器替换为栈地址后的[清单 20-3](chapter20.xhtml#list20-3)</samp>
- en: Once we replace every pseudoregister with a memory address, instructions ❶,
    ❷, ❸, and ❹ are invalid, so the instruction fix-up pass will need to repair them.
    It will insert an extra instruction before ❶ to load its destination into a hard
    register, and it will add another to store the result back to <samp class="SANS_TheSansMonoCd_W5Regular_11">-12(%rbp)</samp>
    afterward. It will also insert instructions to load the source operands of ❷,
    ❸, and ❹ into hard registers. In the context of register allocation, we say a
    pseudoregister is *spilled* to memory if we store its contents on the stack instead
    of in a hard register. The extra instructions we insert to move spilled values
    between registers and memory are called *spill code*.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们将每个伪寄存器替换为内存地址，指令 ❶、❷、❸ 和 ❹ 将无效，因此指令修正过程需要修复它们。它会在❶之前插入一条额外的指令，将目标加载到硬寄存器中，并在之后插入另一条指令将结果存储回<
    sampa class="SANS_TheSansMonoCd_W5Regular_11">-12(%rbp)</sampa>。它还会插入指令，将❷、❸ 和
    ❹ 的源操作数加载到硬寄存器中。在寄存器分配的上下文中，我们说一个伪寄存器如果将其内容存储在栈上而不是硬寄存器中，它就被*溢出*到内存。我们插入的额外指令用于在寄存器和内存之间移动溢出的值，这些指令被称为*溢出代码*。
- en: We’ll ultimately end up with the assembly code in [Listing 20-5](chapter20.xhtml#list20-5).
    I’ve bolded the spill code to make it easier to spot. (I’ve also snipped out the
    instructions to set up and tear down the stack frame, which aren’t relevant here.
    These are snipped out of assembly programs later in the chapter too.)
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 最终，我们将得到[清单 20-5](chapter20.xhtml#list20-5)中的汇编代码。我已经将溢出代码加粗，以便更容易找到。（我还删去了设置和拆卸栈帧的指令，这些与此无关。这些指令在本章后面的汇编程序中也会被删去。）
- en: '[PRE4]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 20-5: [Listing 20-4](chapter20.xhtml#list20-4)
    with spill code</samp>'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">清单 20-5：[清单 20-4](chapter20.xhtml#list20-4)包含溢出代码</samp>
- en: This code is incredibly inefficient. Almost every instruction accesses memory,
    and we waste a huge amount of time copying data from one place to another. To
    take one particularly egregious example, we store the result of <samp class="SANS_TheSansMonoCd_W5Regular_11">3
    * y</samp> in <samp class="SANS_TheSansMonoCd_W5Regular_11">-12(%rbp)</samp>,
    then immediately copy it into <samp class="SANS_TheSansMonoCd_W5Regular_11">-16(%rbp)</samp>—which
    takes two <samp class="SANS_TheSansMonoCd_W5Regular_11">mov</samp> instructions—and
    never use <samp class="SANS_TheSansMonoCd_W5Regular_11">-12(%rbp)</samp> again.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码非常低效。几乎每条指令都访问内存，我们浪费了大量时间将数据从一个地方复制到另一个地方。举一个特别明显的例子，我们将< sampa class="SANS_TheSansMonoCd_W5Regular_11">3
    * y</samp>的结果存储在< sampa class="SANS_TheSansMonoCd_W5Regular_11">-12(%rbp)</samp>，然后立即将其复制到<
    sampa class="SANS_TheSansMonoCd_W5Regular_11">-16(%rbp)</samp>—这需要两条< sampa class="SANS_TheSansMonoCd_W5Regular_11">mov</sampa>指令—之后再也不使用<
    sampa class="SANS_TheSansMonoCd_W5Regular_11">-12(%rbp)</samp>了。
- en: '<samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Take Two: Register
    Allocation</samp>'
  id: totrans-41
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">第二次尝试：寄存器分配</samp>
- en: Let’s try a more reasonable strategy. This time, we’ll replace each pseudoregister
    with a hard register instead of a stack address, as shown in [Table 20-2](chapter20.xhtml#tab20-2).
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们尝试一个更合理的策略。这次，我们将每个伪寄存器替换为硬寄存器，而不是栈地址，如[表 20-2](chapter20.xhtml#tab20-2)所示。
- en: <samp class="SANS_Futura_Std_Heavy_B_11">Table 20-2:</samp> <samp class="SANS_Futura_Std_Book_11">Replacing
    Pseudoregisters with Hard Registers</samp>
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Heavy_B_11">表 20-2：</samp> <samp class="SANS_Futura_Std_Book_11">用硬寄存器替换伪寄存器</samp>
- en: '| <samp class="SANS_Futura_Std_Heavy_B_11">Pseudoregister</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">Real
    location</samp> |'
  id: totrans-44
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_Futura_Std_Heavy_B_11">伪寄存器</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">真实位置</samp>
    |'
- en: '| --- | --- |'
  id: totrans-45
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">%edx</samp>
    |'
  id: totrans-46
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">%edx</samp>
    |'
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">y</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">%ecx</samp>
    |'
  id: totrans-47
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">y</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">%ecx</samp>
    |'
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">tmp0</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">%r8d</samp>
    |'
  id: totrans-48
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">tmp0</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">%r8d</samp>
    |'
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">tmp1</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">%r9d</samp>
    |'
  id: totrans-49
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">tmp1</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">%r9d</samp>
    |'
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">tmp2</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">%edi</samp>
    |'
  id: totrans-50
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">tmp2</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">%edi</samp>
    |'
- en: We’ll replace <samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp>, <samp
    class="SANS_TheSansMonoCd_W5Regular_11">y</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">tmp0</samp>,
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">tmp1</samp> with registers that
    don’t appear at all in the original assembly program. We’ll replace <samp class="SANS_TheSansMonoCd_W5Regular_11">tmp2</samp>
    with EDI, which *is* used in the original program. This is fine, since we use
    <samp class="SANS_TheSansMonoCd_W5Regular_11">tmp2</samp> only once we’re done
    using EDI for anything else. Later in the chapter, we’ll see how to reason more
    systematically about which mappings from pseudoregisters to hard registers are
    safe and which ones might cause conflicts.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将把 <samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp>、<samp class="SANS_TheSansMonoCd_W5Regular_11">y</samp>、<samp
    class="SANS_TheSansMonoCd_W5Regular_11">tmp0</samp> 和 <samp class="SANS_TheSansMonoCd_W5Regular_11">tmp1</samp>
    替换为在原始汇编程序中根本没有出现的寄存器。我们将把 <samp class="SANS_TheSansMonoCd_W5Regular_11">tmp2</samp>
    替换为 EDI，这在原始程序中是有使用的。这是可以的，因为我们只在完成其他 EDI 操作后使用 <samp class="SANS_TheSansMonoCd_W5Regular_11">tmp2</samp>。在本章后面，我们将看到如何更系统地推理哪些伪寄存器到硬寄存器的映射是安全的，哪些可能会引发冲突。
- en: There’s no spill code this time, so I won’t include separate listings from before
    and after the instruction fix-up pass. Instead, we’ll skip right to the final
    assembly code, shown in [Listing 20-6](chapter20.xhtml#list20-6).
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 这次没有溢出代码，因此我不会提供指令修复前后单独的清单。相反，我们直接跳到最终的汇编代码，如[清单 20-6](chapter20.xhtml#list20-6)所示。
- en: '[PRE5]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 20-6: The final assembly
    code for [Listing 20-3](chapter20.xhtml#list20-3) after register allocation</samp>'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">清单 20-6：经过寄存器分配后的[清单 20-3](chapter20.xhtml#list20-3)的最终汇编代码</samp>
- en: 'This is a major improvement; we don’t access memory, and we have fewer instructions
    overall. If we wanted to, we could even omit the instructions to set up and tear
    down the stack frame, since we never use the stack. But we’re still moving data
    around more than we need to. For instance, we copy our function parameters from
    EDI and ESI to new locations, instead of leaving them where they are. We also
    copy <samp class="SANS_TheSansMonoCd_W5Regular_11">tmp0</samp> (now in <samp class="SANS_TheSansMonoCd_W5Regular_11">%r8d</samp>)
    to <samp class="SANS_TheSansMonoCd_W5Regular_11">tmp1</samp> (now in <samp class="SANS_TheSansMonoCd_W5Regular_11">%r9d</samp>),
    when we could just as easily use <samp class="SANS_TheSansMonoCd_W5Regular_11">tmp0</samp>
    for two calculations in a row. This isn’t the register allocator’s fault; it’s
    just that we generated inefficient TACKY and assembly code in earlier passes.
    But if we’re thoughtful about how we allocate registers, we can clean up after
    those earlier passes. That’s why our register allocator will include one more
    step: register coalescing.'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个重要的改进；我们不再访问内存，而且总体的指令数量减少了。如果我们愿意的话，甚至可以省略设置和拆除栈帧的指令，因为我们从未使用栈。但是，我们仍然在做不必要的数据移动。例如，我们将函数参数从
    EDI 和 ESI 复制到新的位置，而不是将它们保留在原地。我们还将 <samp class="SANS_TheSansMonoCd_W5Regular_11">tmp0</samp>（现在在
    <samp class="SANS_TheSansMonoCd_W5Regular_11">%r8d</samp> 中）复制到 <samp class="SANS_TheSansMonoCd_W5Regular_11">tmp1</samp>（现在在
    <samp class="SANS_TheSansMonoCd_W5Regular_11">%r9d</samp> 中），其实我们完全可以连续两次使用 <samp
    class="SANS_TheSansMonoCd_W5Regular_11">tmp0</samp> 来进行计算。这并不是寄存器分配器的错误；问题在于我们在早期的步骤中生成了低效的
    TACKY 和汇编代码。但是，如果我们仔细考虑寄存器分配的方法，就可以清理早期步骤中的问题。这就是为什么我们的寄存器分配器将增加一步：寄存器合并。
- en: '#### <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Take Three:
    Register Allocation with Coalescing</samp>'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: '#### <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">第三步：带合并的寄存器分配</samp>'
- en: 'Our last approach has two steps. First, we’ll coalesce registers: we’ll look
    at each <samp class="SANS_TheSansMonoCd_W5Regular_11">mov</samp> instruction in
    the function and decide whether its operands can be merged together. Then, we’ll
    replace any remaining pseudoregisters with hard registers, like we did in our
    previous attempt.'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的最后一种方法包含两个步骤。首先，我们将合并寄存器：我们会检查函数中的每一条 <samp class="SANS_TheSansMonoCd_W5Regular_11">mov</samp>
    指令，决定其操作数是否可以合并。接着，我们将像在之前的尝试中那样，把任何剩余的伪寄存器替换为硬寄存器。
- en: 'Let’s take another look at the original assembly program from [Listing 20-3](chapter20.xhtml#list20-3).
    This program includes four <samp class="SANS_TheSansMonoCd_W5Regular_11">mov</samp>
    instructions whose source and destination are both registers, which are bolded
    here:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们再看一下原始的汇编程序，来自[示例 20-3](chapter20.xhtml#list20-3)。这个程序包含了四个源和目标都为寄存器的 <samp
    class="SANS_TheSansMonoCd_W5Regular_11">mov</samp> 指令，下面我们将加粗显示这些寄存器：
- en: '[PRE6]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Sometimes, copying values from one register to another is genuinely necessary.
    For example, we might need to copy <samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp>
    out of EDI if we were going to pass another function argument in EDI later. But
    in this case, it’s safe to merge <samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp>
    into EDI, since we don’t need EDI for anything else after that first <samp class="SANS_TheSansMonoCd_W5Regular_11">mov</samp>
    instruction. The same logic applies to each of the other three <samp class="SANS_TheSansMonoCd_W5Regular_11">mov</samp>
    instructions. We won’t need to store different values in the source and destination
    operands at the same time, so it’s safe to merge them together. We’ll merge <samp
    class="SANS_TheSansMonoCd_W5Regular_11">x</samp> into EDI, <samp class="SANS_TheSansMonoCd_W5Regular_11">y</samp>
    into ESI, <samp class="SANS_TheSansMonoCd_W5Regular_11">tmp1</samp> into <samp
    class="SANS_TheSansMonoCd_W5Regular_11">tmp0</samp>, and <samp class="SANS_TheSansMonoCd_W5Regular_11">tmp2</samp>
    into EAX.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，从一个寄存器复制值到另一个寄存器确实是必要的。例如，如果我们后来要将另一个函数参数传递到 EDI 寄存器，我们可能需要将 <samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp>
    从 EDI 中复制出来。但在这个案例中，将 <samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp> 合并到
    EDI 中是安全的，因为在第一次 <samp class="SANS_TheSansMonoCd_W5Regular_11">mov</samp> 指令之后，我们不再需要
    EDI 寄存器。相同的逻辑适用于其他三个 <samp class="SANS_TheSansMonoCd_W5Regular_11">mov</samp>
    指令。我们不需要在源操作数和目标操作数中同时存储不同的值，因此将它们合并是安全的。我们将 <samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp>
    合并到 EDI 中，<samp class="SANS_TheSansMonoCd_W5Regular_11">y</samp> 合并到 ESI 中，<samp
    class="SANS_TheSansMonoCd_W5Regular_11">tmp1</samp> 合并到 <samp class="SANS_TheSansMonoCd_W5Regular_11">tmp0</samp>
    中，<samp class="SANS_TheSansMonoCd_W5Regular_11">tmp2</samp> 合并到 EAX 中。
- en: '[Table 20-3](chapter20.xhtml#tab20-3) summarizes which pairs of registers we’ll
    coalesce and shows which member of each pair will remain in the program.'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: '[表 20-3](chapter20.xhtml#tab20-3) 总结了我们将合并的寄存器对，并显示了每对寄存器中将保留的成员。'
- en: <samp class="SANS_Futura_Std_Heavy_B_11">Table 20-3:</samp> <samp class="SANS_Futura_Std_Book_11">Coalescing
    Registers</samp>
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Heavy_B_11">表 20-3:</samp> <samp class="SANS_Futura_Std_Book_11">寄存器合并</samp>
- en: '| <samp class="SANS_Futura_Std_Heavy_B_11">Coalesced pair</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">Remaining
    register</samp> |'
  id: totrans-63
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_Futura_Std_Heavy_B_11">合并后的寄存器对</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">剩余寄存器</samp>
    |'
- en: '| --- | --- |'
  id: totrans-64
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">%edi, %x</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">%edi</samp>
    |'
  id: totrans-65
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">%edi, %x</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">%edi</samp>
    |'
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">%esi, %y</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">%esi</samp>
    |'
  id: totrans-66
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">%esi, %y</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">%esi</samp>
    |'
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">%tmp0, %tmp1</samp> | <samp
    class="SANS_TheSansMonoCd_W5Regular_11">%tmp0</samp> |'
  id: totrans-67
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">%tmp0, %tmp1</samp> | <samp
    class="SANS_TheSansMonoCd_W5Regular_11">%tmp0</samp> |'
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">%tmp2, %eax</samp> | <samp
    class="SANS_TheSansMonoCd_W5Regular_11">%eax</samp> |'
  id: totrans-68
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">%tmp2, %eax</samp> | <samp
    class="SANS_TheSansMonoCd_W5Regular_11">%eax</samp> |'
- en: We’ll also delete all four <samp class="SANS_TheSansMonoCd_W5Regular_11">mov</samp>
    instructions, since they no longer serve any purpose. [Listing 20-7](chapter20.xhtml#list20-7)
    gives the resulting assembly code, with the updated operands bolded.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将删除所有四条 <samp class="SANS_TheSansMonoCd_W5Regular_11">mov</samp> 指令，因为它们已经没有任何作用。[示例
    20-7](chapter20.xhtml#list20-7) 给出了合并后的汇编代码，并加粗显示了更新后的操作数。
- en: '[PRE7]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 20-7: [Listing 20-3](chapter20.xhtml#list20-3)
    after register coalescing</samp>'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">示例 20-7: [示例 20-3](chapter20.xhtml#list20-3)
    合并寄存器后的代码</samp>'
- en: This looks a lot more reasonable! We leave <samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">y</samp> in EDI and ESI, where
    they were passed to begin with, instead of copying them to new locations. When
    we calculate the return value, we store the result in EAX right away, instead
    of copying it into EAX after we’ve calculated it. And we no longer use two separate
    temporary registers to calculate the intermediate and final results in <samp class="SANS_TheSansMonoCd_W5Regular_11">3
    * y</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">+</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp>;
    we stick with <samp class="SANS_TheSansMonoCd_W5Regular_11">tmp0</samp> the whole
    time.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 这样看起来更合理了！我们将 <samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp> 和 <samp
    class="SANS_TheSansMonoCd_W5Regular_11">y</samp> 保持在 EDI 和 ESI 中，正如它们最初传递到这些寄存器一样，而不是将它们复制到新位置。当我们计算返回值时，我们直接将结果存储在
    EAX 中，而不是在计算后再将它复制到 EAX 中。我们也不再使用两个独立的临时寄存器来计算 <samp class="SANS_TheSansMonoCd_W5Regular_11">3
    * y</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">+</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp>
    的中间结果和最终结果；我们始终使用 <samp class="SANS_TheSansMonoCd_W5Regular_11">tmp0</samp>。
- en: We’re not quite done; we still need to replace <samp class="SANS_TheSansMonoCd_W5Regular_11">tmp0</samp>
    with a hard register. Any register besides ESI, EDI, or EAX will do—let’s go with
    ECX. [Listing 20-8](chapter20.xhtml#list20-8) shows the assembly code we’ll ultimately
    wind up with.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还没有完全完成；我们仍然需要将 <samp class="SANS_TheSansMonoCd_W5Regular_11">tmp0</samp>
    替换为一个硬寄存器。除了 ESI、EDI 或 EAX，任何寄存器都可以——我们选用 ECX。<samp class="SANS_Futura_Std_Book_Oblique_I_11">[清单
    20-8](chapter20.xhtml#list20-8)</samp> 显示了我们最终会得到的汇编代码。
- en: '[PRE8]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 20-8: The final assembly
    code for [Listing 20-3](chapter20.xhtml#list20-3) after register allocation with
    coalescing</samp>'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">清单 20-8：应用寄存器合并后，[清单 20-3](chapter20.xhtml#list20-3)的最终汇编代码</samp>
- en: 'Register allocation without coalescing improved our code in two ways: it reduced
    the number of memory accesses and the amount of spill code in our program. With
    register coalescing, we improve our code even further by removing the many unnecessary
    <samp class="SANS_TheSansMonoCd_W5Regular_11">mov</samp> instructions generated
    by earlier passes.'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 不进行寄存器合并的寄存器分配在两个方面改进了我们的代码：它减少了内存访问次数和程序中的溢出代码量。通过寄存器合并，我们通过去除之前步骤生成的许多不必要的
    <samp class="SANS_TheSansMonoCd_W5Regular_11">mov</samp> 指令，进一步优化了代码。
- en: Now that we have a sense of what we want to accomplish, let’s look at how register
    allocation fits into the whole compiler pipeline.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们对要实现的目标有所了解，让我们来看看寄存器分配如何融入整个编译器流水线。
- en: <samp class="SANS_Futura_Std_Bold_B_11">Updating the Compiler Pipeline</samp>
  id: totrans-78
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">更新编译器流水线</samp>
- en: 'Register allocators work best when there are lots of hard registers available,
    so the very first thing we’ll do is add every remaining hard register to the assembly
    AST, including the callee-saved registers that we’ve avoided so far. We’ll also
    make one small change to the conversion from TACKY to assembly: during this pass,
    we’ll store extra information in the backend symbol table about which hard registers
    each function uses to pass parameters and return values.'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 寄存器分配器在有大量硬寄存器可用时效果最佳，因此我们要做的第一件事是将所有剩余的硬寄存器添加到汇编抽象语法树（AST）中，包括我们至今为止避免使用的调用者保存寄存器。我们还将对从
    TACKY 转换到汇编的过程做一个小改动：在这一过程中，我们将把额外的信息存储在后端符号表中，记录每个函数用于传递参数和返回值的硬寄存器。
- en: Next, we’ll implement the register allocator itself. The register allocator
    will run just after we convert the program from TACKY to assembly, before any
    of the other backend compiler passes. Much like the optimizations we implemented
    in [Chapter 19](chapter19.xhtml), this pass will process each assembly function
    independently.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将实现寄存器分配器本身。寄存器分配器将在我们将程序从 TACKY 转换为汇编后运行，在其他后端编译器步骤之前。就像我们在[第 19 章](chapter19.xhtml)中实现的优化一样，这一步将独立处理每个汇编函数。
- en: Even after register allocation, there may still be some pseudoregisters left
    in the program. This could happen for a couple of reasons. First, if a function
    uses lots of pseudoregisters at once, there might not be enough hard registers
    to accommodate all of them. When that happens, we’ll have to spill some pseudoregisters
    to memory. Our register allocator won’t replace spilled pseudoregisters; it will
    just leave them in the program for the next pass to deal with. Second, some pseudoregisters
    represent variables with static storage duration. These must live in memory instead
    of registers. If you completed [Part II](part2.xhtml), you’ll encounter a few
    other objects that must live in memory, including aliased variables, structures,
    and arrays. The register allocator won’t touch these either.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 即使在寄存器分配之后，程序中可能仍然存在一些伪寄存器。这可能是由于几个原因。首先，如果一个函数同时使用了大量伪寄存器，可能没有足够的硬寄存器来容纳它们。发生这种情况时，我们将不得不将一些伪寄存器溢出到内存中。我们的寄存器分配器不会替换已溢出的伪寄存器；它只会将它们保留在程序中，供下一轮处理。其次，一些伪寄存器代表具有静态存储持续时间的变量。这些变量必须存放在内存中，而不是寄存器中。如果你完成了[第二部分](part2.xhtml)，你还会遇到一些必须存放在内存中的对象，包括别名变量、结构体和数组。寄存器分配器也不会修改这些。
- en: To deal with all these stragglers, we’ll run our old pseudo-operand replacement
    pass immediately after the register allocator. We won’t make any changes to this
    pass. It will handle any pseudo-operands it finds exactly the same way it did
    before; it will just find a lot fewer of them.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 为了处理所有这些滞留的操作数，我们将在寄存器分配器之后立即运行旧的伪操作数替换过程。我们不会对这个过程做任何改动。它会以与之前完全相同的方式处理它找到的任何伪操作数；只不过它找到的数量会少很多。
- en: Next, we’ll update the instruction fix-up pass to take care of saving and restoring
    callee-saved registers. All our existing rewrite rules—including the rules to
    generate spill code—will stay the same. Since we still replace some pseudoregisters
    with locations in memory, we’ll still have to generate spill code some of the
    time.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将更新指令修正过程，处理保存和恢复被调用者保存的寄存器。我们现有的所有重写规则——包括生成溢出代码的规则——将保持不变。由于我们仍然会将一些伪寄存器替换为内存中的位置，我们仍然需要在某些情况下生成溢出代码。
- en: Finally, we’ll extend the code emission stage to support the new hard registers
    we introduce in this chapter. You might want to stub out the new register allocation
    stage at this point. Then, we’ll update the assembly AST one last time.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将扩展代码生成阶段，以支持本章引入的新硬寄存器。此时，你可能想要简单地先跳过新的寄存器分配阶段。然后，我们将最后一次更新汇编 AST。
- en: <samp class="SANS_Futura_Std_Bold_B_11">Extending the Assembly AST</samp>
  id: totrans-85
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">扩展汇编 AST</samp>
- en: 'So far, the assembly AST has included only the registers that we used for a
    particular purpose, such as passing parameters or rewriting instructions. It doesn’t
    include any of the callee-saved registers: RBX, R12, R13, R14, and R15\. Now we’ll
    add these five registers so the register allocator can use them. We’ll also add
    the <samp class="SANS_TheSansMonoCd_W5Regular_11">pop</samp> instruction, which
    we’ll use to restore callee-saved registers at the end of a function. If you completed
    [Part II](part2.xhtml), you should also add the remaining XMM registers, XMM8
    through XMM13\. These registers are not callee-saved.'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，汇编 AST 只包含我们为特定目的使用的寄存器，如传递参数或重写指令。它不包括任何被调用者保存的寄存器：RBX、R12、R13、R14 和
    R15。现在，我们将添加这五个寄存器，以便寄存器分配器可以使用它们。我们还将添加 <samp class="SANS_TheSansMonoCd_W5Regular_11">pop</samp>
    指令，用于在函数结束时恢复被调用者保存的寄存器。如果你完成了[第二部分](part2.xhtml)，你还应该添加其余的 XMM 寄存器，即 XMM8 到 XMM13。这些寄存器不是被调用者保存的寄存器。
- en: '[Listing 20-9](chapter20.xhtml#list20-9) shows the complete assembly AST that
    includes everything we covered in [Parts I](part1.xhtml), [II](part2.xhtml), and
    [III](part3.xhtml), with this chapter’s additions bolded.'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: '[清单 20-9](chapter20.xhtml#list20-9) 显示了完整的汇编 AST，包括我们在[第一部分](part1.xhtml)、[第二部分](part2.xhtml)和[第三部分](part3.xhtml)中覆盖的所有内容，本章的新增内容已加粗显示。'
- en: '[PRE9]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 20-9: The complete
    assembly AST with the</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">pop</samp>
    <samp class="SANS_Futura_Std_Book_Oblique_I_11">instruction and additional registers</samp>'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">清单 20-9：包含</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">pop</samp>
    <samp class="SANS_Futura_Std_Book_Oblique_I_11">指令和额外寄存器的完整汇编 AST</samp>
- en: Note that <samp class="SANS_TheSansMonoCd_W5Regular_11">pop</samp> accepts only
    registers, not other operands. Now that we’ve updated the AST, let’s move on to
    the conversion from TACKY to assembly.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，<samp class="SANS_TheSansMonoCd_W5Regular_11">pop</samp> 仅接受寄存器，而不是其他操作数。现在我们已经更新了抽象语法树（AST），接下来让我们继续从TACKY到汇编的转换。
- en: <samp class="SANS_Futura_Std_Bold_B_11">Converting TACKY to Assembly</samp>
  id: totrans-91
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">从TACKY到汇编的转换</samp>
- en: We’ll make just one change to this pass. We aren’t changing what assembly we
    generate; we’re just recording extra information in the backend symbol table.
    Specifically, we’ll record which registers are used to pass each function’s parameters.
    As you’ll see in the next section, the register allocator needs this information
    to figure out which hard registers and pseudoregisters conflict.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 我们对这个过程只做一个修改。我们不会改变生成的汇编内容；我们只是会在后端符号表中记录额外的信息。具体来说，我们将记录哪些寄存器用于传递每个函数的参数。如您将在下一节中看到的，寄存器分配器需要这些信息来确定哪些硬寄存器和伪寄存器存在冲突。
- en: 'Suppose we have the following function declaration:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们有以下的函数声明：
- en: '[PRE10]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: We’ll record that <samp class="SANS_TheSansMonoCd_W5Regular_11">foo</samp>’s
    parameters are passed in the first two parameter passing registers, RDI and RSI.
    We’ll track this information even if <samp class="SANS_TheSansMonoCd_W5Regular_11">foo</samp>
    is defined in a different translation unit, because we’ll need it to allocate
    registers in functions that call <samp class="SANS_TheSansMonoCd_W5Regular_11">foo</samp>.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将记录<sup><samp class="SANS_TheSansMonoCd_W5Regular_11">foo</samp></sup>的参数是通过前两个参数传递寄存器RDI和RSI传递的。即使<sup><samp
    class="SANS_TheSansMonoCd_W5Regular_11">foo</samp></sup>在不同的翻译单元中定义，我们也会跟踪这些信息，因为我们需要它来为调用<sup><samp
    class="SANS_TheSansMonoCd_W5Regular_11">foo</samp></sup>的函数分配寄存器。
- en: If you completed [Part II](part2.xhtml), you should also track which registers
    are used to pass each function’s return value. Given the function declaration
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您完成了[第二部分](part2.xhtml)，那么您应该也跟踪哪些寄存器被用来传递每个函数的返回值。考虑到以下函数声明：
- en: '[PRE11]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: we’ll record that <samp class="SANS_TheSansMonoCd_W5Regular_11">foo</samp>’s
    parameters are passed in RDI and XMM0 and that its return value is also passed
    in XMM0\. To figure out which registers a function uses to pass parameters and
    return values, we’ll use the same logic we implemented in the <samp class="SANS_TheSansMonoCd_W5Regular_11">classify_parameters</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">classify_return_value</samp>
    helper functions in [Chapter 18](chapter18.xhtml). Note that we might run into
    function declarations with incomplete return types or parameter types. It doesn’t
    matter what information we record about these functions, since it would be illegal
    to either define or call them in the current translation unit; we just need to
    handle them without crashing. It’s easiest to simply record that they don’t pass
    any values in registers.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将记录<sup><samp class="SANS_TheSansMonoCd_W5Regular_11">foo</samp></sup>的参数通过RDI和XMM0传递，并且它的返回值也通过XMM0传递。为了找出一个函数使用哪些寄存器来传递参数和返回值，我们将使用在[第18章](chapter18.xhtml)中实现的<sup><samp
    class="SANS_TheSansMonoCd_W5Regular_11">classify_parameters</samp></sup>和<sup><samp
    class="SANS_TheSansMonoCd_W5Regular_11">classify_return_value</samp></sup>辅助函数中实现的相同逻辑。请注意，我们可能会遇到具有不完整返回类型或参数类型的函数声明。无论我们记录什么关于这些函数的信息都没有关系，因为在当前翻译单元中定义或调用它们都是非法的；我们只需要在不崩溃的情况下处理它们。最简单的做法是直接记录它们没有通过寄存器传递任何值。
- en: Next, we’ll build the register allocator itself.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将构建寄存器分配器本身。
- en: <samp class="SANS_Futura_Std_Bold_B_11">Register Allocation by Graph Coloring</samp>
  id: totrans-100
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">通过图着色进行寄存器分配</samp>
- en: Our compiler will model register allocation as a *graph coloring* problem. Coloring
    a graph means assigning every node a label (traditionally called a “color”) so
    that each node has a different color from all its neighbors. A graph is *k-colorable*
    if you can color it with *k* or fewer colors. [Figure 20-1](#fig20-1) illustrates
    a 3-colored graph.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的编译器将把寄存器分配建模为一个*图着色*问题。着色一个图意味着为每个节点分配一个标签（传统上称为“颜色”），使得每个节点与其所有邻居的颜色都不同。如果一个图可以用*k*种或更少的颜色进行着色，那么它就是*k-可着色*的。[图20-1](#fig20-1)展示了一个3色图。
- en: '![](../images/fig20-1.jpg)'
  id: totrans-102
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/fig20-1.jpg)'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 20-1: A 3-colored graph
    [Description](description-64.xhtml)</samp>'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">图20-1：一个3色图 [描述](description-64.xhtml)</samp>
- en: 'Graph coloring is an important area of research in its own right; mathematicians
    have been investigating how to color graphs since the 19th century! It’s relevant
    to register allocation because it captures two fundamental constraints on how
    we can assign pseudoregisters to hard registers: we have a limited number of hard
    registers to work with, and some registers will *interfere* with each other, meaning
    they can’t occupy the same physical location. If two pseudoregisters interfere,
    we need to assign them to two different hard registers. A pseudoregister might
    also interfere with a hard register, which means we can’t assign it to that hard
    register.'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 图着色本身就是一个重要的研究领域；自19世纪以来，数学家们一直在研究如何为图着色！它与寄存器分配相关，因为它捕捉了我们在将伪寄存器分配到硬件寄存器时的两个基本约束：我们有有限数量的硬件寄存器可以使用，并且一些寄存器之间会*相互干扰*，这意味着它们不能占用相同的物理位置。如果两个伪寄存器发生干扰，我们需要将它们分配到两个不同的硬件寄存器上。一个伪寄存器也可能与硬件寄存器发生干扰，这意味着我们不能将它分配到那个硬件寄存器上。
- en: Graph coloring lets us express both kinds of interference and handle them in
    a uniform way. To turn register allocation into a graph coloring problem, we’ll
    first build a *register interference graph* with nodes representing pseudoregisters
    and hard registers and with edges between any registers that interfere. Then,
    we’ll color the graph, using one color per hard register. Finally, we’ll assign
    each pseudoregister to a hard register according to its color. Because each register
    gets a different color from all of its neighbors, we’ll never assign two pseudoregisters
    that interfere to the same hard register or assign a pseudoregister to a hard
    register that it interferes with.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 图着色使我们能够表达两种类型的干扰，并以统一的方式处理它们。为了将寄存器分配问题转化为图着色问题，我们首先将构建一个*寄存器干扰图*，其中节点表示伪寄存器和硬件寄存器，边表示任意互相干扰的寄存器之间的关系。然后，我们将对图进行着色，为每个硬件寄存器分配一种颜色。最后，我们根据颜色将每个伪寄存器分配给一个硬件寄存器。因为每个寄存器的颜色都与它的邻居不同，所以我们永远不会将互相干扰的两个伪寄存器分配到同一个硬件寄存器，也不会将一个伪寄存器分配给它与之干扰的硬件寄存器。
- en: Let’s try out this technique on the assembly function in [Listing 20-10](chapter20.xhtml#list20-10).
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在[清单20-10](chapter20.xhtml#list20-10)中的汇编函数上试用这个技巧。
- en: '[PRE12]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 20-10: A small assembly
    function</samp>'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">清单20-10：一个小型汇编函数</samp>
- en: 'This function takes two parameters, which it copies into the pseudoregisters
    <samp class="SANS_TheSansMonoCd_W5Regular_11">a</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">b</samp>.
    It calculates <samp class="SANS_TheSansMonoCd_W5Regular_11">a / b - b</samp> and
    stores the result in <samp class="SANS_TheSansMonoCd_W5Regular_11">tmp</samp>.
    Finally, it returns the value of <samp class="SANS_TheSansMonoCd_W5Regular_11">tmp</samp>
    in EAX. We need to figure out which registers in this function interfere so we
    can build the interference graph. To start off, it’s easy to see that <samp class="SANS_TheSansMonoCd_W5Regular_11">a</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">b</samp> interfere. If we map
    them to the same hard register, we’ll clobber <samp class="SANS_TheSansMonoCd_W5Regular_11">a</samp>
    when we define <samp class="SANS_TheSansMonoCd_W5Regular_11">b</samp> ❷. This
    is a problem because <samp class="SANS_TheSansMonoCd_W5Regular_11">a</samp> is
    still live at this point. You learned in [Chapter 19](chapter19.xhtml) that a
    variable is live if its current value might be used later in the program, and
    otherwise it’s dead. This definition applies to registers too. When a register
    is live, we need to preserve its value, so we can’t store a different value in
    the same location. When it’s dead, we’re free to overwrite its value with something
    else. This gives us an easy rule for detecting interference: two registers interfere
    if we update one while the other is live.'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数接受两个参数，将它们复制到伪寄存器 <samp class="SANS_TheSansMonoCd_W5Regular_11">a</samp>
    和 <samp class="SANS_TheSansMonoCd_W5Regular_11">b</samp> 中。它计算 <samp class="SANS_TheSansMonoCd_W5Regular_11">a
    / b - b</samp> 并将结果存储在 <samp class="SANS_TheSansMonoCd_W5Regular_11">tmp</samp>
    中。最后，它将 <samp class="SANS_TheSansMonoCd_W5Regular_11">tmp</samp> 的值返回在 EAX 中。我们需要找出这个函数中哪些寄存器会发生冲突，以便构建冲突图。首先，很容易看出
    <samp class="SANS_TheSansMonoCd_W5Regular_11">a</samp> 和 <samp class="SANS_TheSansMonoCd_W5Regular_11">b</samp>
    会发生冲突。如果将它们映射到同一个硬件寄存器，当我们定义 <samp class="SANS_TheSansMonoCd_W5Regular_11">b</samp>
    ❷ 时，<samp class="SANS_TheSansMonoCd_W5Regular_11">a</samp> 会被覆盖。这是一个问题，因为 <samp
    class="SANS_TheSansMonoCd_W5Regular_11">a</samp> 在此时仍然是活跃的。你在 [第19章](chapter19.xhtml)
    中学到，变量是活跃的，如果它的当前值可能会在程序中后续使用，否则它就是死的。这一定义同样适用于寄存器。当一个寄存器是活跃的时，我们需要保留它的值，因此不能在同一位置存储不同的值。当它是死的时，我们可以随意覆盖它的值。这给了我们一个简单的规则来检测冲突：两个寄存器如果在一个寄存器活跃时更新另一个寄存器，就会发生冲突。
- en: This rule also tells us that <samp class="SANS_TheSansMonoCd_W5Regular_11">b</samp>
    interferes with <samp class="SANS_TheSansMonoCd_W5Regular_11">tmp</samp>, since
    <samp class="SANS_TheSansMonoCd_W5Regular_11">b</samp> is live when we define
    <samp class="SANS_TheSansMonoCd_W5Regular_11">tmp</samp> ❹. But <samp class="SANS_TheSansMonoCd_W5Regular_11">a</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">tmp</samp> don’t interfere;
    <samp class="SANS_TheSansMonoCd_W5Regular_11">a</samp> is already dead by the
    time we define <samp class="SANS_TheSansMonoCd_W5Regular_11">tmp</samp>, so it’s
    fine to map them to the same hard register.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 这个规则还告诉我们，<samp class="SANS_TheSansMonoCd_W5Regular_11">b</samp> 与 <samp class="SANS_TheSansMonoCd_W5Regular_11">tmp</samp>
    存在冲突，因为在我们定义 <samp class="SANS_TheSansMonoCd_W5Regular_11">tmp</samp> ❹ 时，<samp
    class="SANS_TheSansMonoCd_W5Regular_11">b</samp> 仍然是活跃的。但 <samp class="SANS_TheSansMonoCd_W5Regular_11">a</samp>
    和 <samp class="SANS_TheSansMonoCd_W5Regular_11">tmp</samp> 不会发生冲突；因为在我们定义 <samp
    class="SANS_TheSansMonoCd_W5Regular_11">tmp</samp> 时，<samp class="SANS_TheSansMonoCd_W5Regular_11">a</samp>
    已经是死的，所以可以将它们映射到同一个硬件寄存器。
- en: Now let’s think through which hard registers interfere with pseudoregisters.
    ESI interferes with <samp class="SANS_TheSansMonoCd_W5Regular_11">a</samp> because
    ESI is live when we define <samp class="SANS_TheSansMonoCd_W5Regular_11">a</samp>
    ❶. If we mapped <samp class="SANS_TheSansMonoCd_W5Regular_11">a</samp> to ESI,
    we’d clobber the function’s second parameter before we had a chance to copy it
    to <samp class="SANS_TheSansMonoCd_W5Regular_11">b</samp>. EAX interferes with
    <samp class="SANS_TheSansMonoCd_W5Regular_11">b</samp> because <samp class="SANS_TheSansMonoCd_W5Regular_11">b</samp>
    is live when we copy <samp class="SANS_TheSansMonoCd_W5Regular_11">a</samp> to
    EAX to prepare for division. The last source of interference is less obvious.
    Remember that the <samp class="SANS_TheSansMonoCd_W5Regular_11">cdq</samp> instruction
    sign extends the value from EAX into EDX ❸. Because <samp class="SANS_TheSansMonoCd_W5Regular_11">cdq</samp>
    implicitly updates EDX while <samp class="SANS_TheSansMonoCd_W5Regular_11">b</samp>
    is live, it makes EDX interfere with <samp class="SANS_TheSansMonoCd_W5Regular_11">b</samp>;
    if we mapped <samp class="SANS_TheSansMonoCd_W5Regular_11">b</samp> to EDX, this
    instruction would clobber it. (Similarly, the <samp class="SANS_TheSansMonoCd_W5Regular_11">idiv</samp>
    instruction updates EAX and EDX implicitly, so it would make both of these registers
    interfere with <samp class="SANS_TheSansMonoCd_W5Regular_11">b</samp> if they
    didn’t already.)
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们思考一下哪些硬寄存器会与伪寄存器干扰。ESI 与 <samp class="SANS_TheSansMonoCd_W5Regular_11">a</samp>
    干扰，因为当我们定义 <samp class="SANS_TheSansMonoCd_W5Regular_11">a</samp> 时 ESI 是活跃的 ❶。如果我们将
    <samp class="SANS_TheSansMonoCd_W5Regular_11">a</samp> 映射到 ESI，我们将在有机会将其复制到 <samp
    class="SANS_TheSansMonoCd_W5Regular_11">b</samp> 之前覆盖函数的第二个参数。EAX 与 <samp class="SANS_TheSansMonoCd_W5Regular_11">b</samp>
    干扰，因为当我们将 <samp class="SANS_TheSansMonoCd_W5Regular_11">a</samp> 复制到 EAX 准备进行除法时，<samp
    class="SANS_TheSansMonoCd_W5Regular_11">b</samp> 是活跃的。最后一个干扰源则不太明显。请记住，<samp class="SANS_TheSansMonoCd_W5Regular_11">cdq</samp>
    指令会将 EAX 中的值符号扩展到 EDX ❸。因为 <samp class="SANS_TheSansMonoCd_W5Regular_11">cdq</samp>
    在 <samp class="SANS_TheSansMonoCd_W5Regular_11">b</samp> 活跃时隐式更新 EDX，它使得 EDX 与
    <samp class="SANS_TheSansMonoCd_W5Regular_11">b</samp> 干扰；如果我们将 <samp class="SANS_TheSansMonoCd_W5Regular_11">b</samp>
    映射到 EDX，这条指令将覆盖它。（同样，<samp class="SANS_TheSansMonoCd_W5Regular_11">idiv</samp>
    指令隐式更新 EAX 和 EDX，因此如果它们尚未干扰 <samp class="SANS_TheSansMonoCd_W5Regular_11">b</samp>，它们也会使这两个寄存器与
    <samp class="SANS_TheSansMonoCd_W5Regular_11">b</samp> 干扰。）
- en: Finally, the hard registers all interfere with each other. This is sort of tautological;
    they can’t occupy the same physical location because they represent different
    physical locations to begin with. Still, we need to capture this in the interference
    graph to make sure that each hard register gets its own color.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，所有硬寄存器都会相互干扰。这有点自明；它们不能占据相同的物理位置，因为它们一开始就代表不同的物理位置。不过，我们需要在干扰图中捕捉这一点，以确保每个硬寄存器都有自己的颜色。
- en: Now that we’ve figured out which registers interfere, we’ll construct the graph.
    To keep this graph relatively small and readable, we’ll pretend that the only
    hard registers are EDI, ESI, EAX, and EDX. Our real register interference graphs
    will include every hard register we can assign pseudoregisters to, even if the
    assembly program doesn’t use them. However, they’ll exclude RSP, RBP, and the
    scratch registers that we use during instruction fix-up.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经弄清楚了哪些寄存器相互干扰，接下来我们将构建干扰图。为了保持图的相对简洁和可读性，我们假设唯一的硬寄存器是 EDI、ESI、EAX 和 EDX。我们真实的寄存器干扰图将包括所有可以分配伪寄存器的硬寄存器，即使汇编程序没有使用它们。然而，它们将排除
    RSP、RBP 以及我们在指令修正期间使用的临时寄存器。
- en: '[Figure 20-2](#fig20-2) illustrates the interference graph for the function
    in [Listing 20-10](chapter20.xhtml#list20-10).'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 20-2](#fig20-2) 展示了 [清单 20-10](chapter20.xhtml#list20-10) 中函数的干扰图。'
- en: '![](../images/fig20-2.jpg)'
  id: totrans-115
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/fig20-2.jpg)'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 20-2: The register interference
    graph for divide_and_subtract [Description](description-65.xhtml)</samp>'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">图 20-2：divide_and_subtract 的寄存器干扰图
    [描述](description-65.xhtml)</samp>
- en: 'This graph encodes all the interferences we just identified: <samp class="SANS_TheSansMonoCd_W5Regular_11">a</samp>
    interferes with ESI and <samp class="SANS_TheSansMonoCd_W5Regular_11">b</samp>;
    <samp class="SANS_TheSansMonoCd_W5Regular_11">b</samp> interferes with <samp class="SANS_TheSansMonoCd_W5Regular_11">tmp</samp>,
    EAX, and EDX as well as <samp class="SANS_TheSansMonoCd_W5Regular_11">a</samp>;
    and all four hard registers interfere with each other.'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 这个图表示了我们刚刚识别出的所有干扰：<samp class="SANS_TheSansMonoCd_W5Regular_11">a</samp>与ESI和<samp
    class="SANS_TheSansMonoCd_W5Regular_11">b</samp>产生干扰；<samp class="SANS_TheSansMonoCd_W5Regular_11">b</samp>与<samp
    class="SANS_TheSansMonoCd_W5Regular_11">tmp</samp>、EAX和EDX产生干扰，并且与<samp class="SANS_TheSansMonoCd_W5Regular_11">a</samp>产生干扰；所有四个硬寄存器之间都会相互干扰。
- en: Now we’ll try to *k*-color this graph, where *k* is the number of hard registers
    in the graph. In this small example, *k* is 4\. There are several possible 4-colorings
    of [Figure 20-2](#fig20-2). [Figure 20-3](#fig20-3) shows a few of them.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将尝试对这个图进行*k*着色，其中*k*是图中硬寄存器的数量。在这个小示例中，*k*是4。图[20-2](#fig20-2)中有几种可能的4种着色。图[20-3](#fig20-3)展示了其中一些。
- en: '![](../images/fig20-3.jpg)'
  id: totrans-119
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/fig20-3.jpg)'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 20-3: Three valid 4-colorings
    of the register interference graph for divide_and_subtract [Description](description-66.xhtml)</samp>'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">图20-3：为divide_and_subtract的寄存器干扰图提供的三种有效4种着色[描述](description-66.xhtml)</samp>
- en: Any one of these colorings—or any other 4-coloring we can come up with—will
    give us a valid register assignment. Each register will receive a different color
    from any of its neighbors. And because the *k* hard registers all interfere with
    each other, we’ll assign each color to exactly one hard register, which creates
    a 1:1 mapping from colors to hard registers.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 这些着色中的任何一种，或者我们能想到的任何其他4种着色，都会给我们一个有效的寄存器分配。每个寄存器都会从它的邻居那里接收到不同的颜色。因为所有的*k*个硬寄存器相互之间都会产生干扰，所以我们会将每种颜色分配给恰好一个硬寄存器，从而创建一个颜色与硬寄存器之间的1:1映射。
- en: After we color the graph, we’ll replace each pseudoregister with the hard register
    that received the same color. If we use the first coloring from [Figure 20-3](#fig20-3),
    we’ll replace <samp class="SANS_TheSansMonoCd_W5Regular_11">a</samp> with EDX,
    <samp class="SANS_TheSansMonoCd_W5Regular_11">b</samp> with EDI, and <samp class="SANS_TheSansMonoCd_W5Regular_11">tmp</samp>
    with EAX, which gives us the assembly code in [Listing 20-11](chapter20.xhtml#list20-11).
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们给图着色之后，我们将用接收到相同颜色的硬寄存器替换每个伪寄存器。如果我们使用[图20-3](#fig20-3)中的第一个着色，我们将把<samp
    class="SANS_TheSansMonoCd_W5Regular_11">a</samp>替换为EDX，<samp class="SANS_TheSansMonoCd_W5Regular_11">b</samp>替换为EDI，<samp
    class="SANS_TheSansMonoCd_W5Regular_11">tmp</samp>替换为EAX，这将给我们[清单20-11](chapter20.xhtml#list20-11)中的汇编代码。
- en: '[PRE13]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 20-11: Replacing registers
    in</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">divide_and_subtract</samp>
    <samp class="SANS_Futura_Std_Book_Oblique_I_11">based on the first coloring in
    [Figure 20-3](#fig20-3)</samp>'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">清单20-11：根据[图20-3](#fig20-3)中的第一个着色替换divide_and_subtract中的寄存器</samp>
- en: If you like, you can work through this listing and confirm that it produces
    the same result as the original code for <samp class="SANS_TheSansMonoCd_W5Regular_11">divide_and_subtract</samp>
    in [Listing 20-10](chapter20.xhtml#list20-10). You can also try this out with
    the other colorings in [Figure 20-3](#fig20-3).
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你愿意，你可以通过这个列表进行操作，确认它产生的结果与[清单20-10](chapter20.xhtml#list20-10)中`divide_and_subtract`的原始代码是相同的。你还可以尝试[图20-3](#fig20-3)中的其他着色。
- en: 'Note that coloring the graph produces two different mappings: one from all
    registers to colors and one from colors to hard registers. Conceptually, each
    color represents a hard register, but we don’t know *which* hard register until
    after we’ve colored the graph. If instead we used the names of the hard registers
    themselves as colors, or associated each hard register with a color ahead of time,
    then we would have to *precolor* each hard register with the corresponding color
    before we tried to color the rest of the graph. Precoloring adds more constraints
    to the graph coloring problem, which makes it harder to find a valid coloring.
    Some graph coloring implementations require precolored nodes; luckily, ours isn’t
    one of them.'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，给图形上色会产生两种不同的映射：一种是从所有寄存器到颜色，另一种是从颜色到硬寄存器。概念上，每种颜色代表一个硬寄存器，但我们在为图形着色之前并不知道*哪一个*硬寄存器。如果我们将硬寄存器的名字本身用作颜色，或者提前将每个硬寄存器与颜色关联，那么我们必须在尝试为其余图形着色之前对每个硬寄存器进行*预着色*。预着色会给图着色问题添加更多约束，导致更难找到有效的着色方案。一些图着色实现要求预着色节点；幸运的是，我们的实现不需要。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Detecting Interference</samp>
  id: totrans-127
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">干扰检测</samp>
- en: Earlier, I said that two registers interfered if we updated one while the other
    was live. We used this rule to figure out which registers interfered in <samp
    class="SANS_TheSansMonoCd_W5Regular_11">divide _and_subtract</samp>; it helped
    us identify both interference between pseudoregisters and interference between
    pseudoregisters and hard registers. But there are a couple of important points
    about this rule that we still need to cover.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 之前，我说过只有在一个寄存器活跃时更新另一个寄存器，它们才会发生干扰。我们利用这个规则来确定在 <samp class="SANS_TheSansMonoCd_W5Regular_11">divide
    _and_subtract</samp> 中哪些寄存器发生了干扰；它帮助我们识别了伪寄存器之间的干扰，以及伪寄存器与硬寄存器之间的干扰。但关于这个规则，还有一些重要的内容需要补充说明。
- en: 'The first point is that two registers interfere only if one is live *immediately
    after* we update the other. Here’s a short example:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 第一点是，只有在更新了一个寄存器后，另一个寄存器**立即活跃**时，它们才会发生干扰。这里有一个简短的例子：
- en: '[PRE14]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: In this code snippet, RDI holds some memory address—presumably the address of
    a structure or array. The first instruction in this snippet takes the value stored
    in memory at RDI + 4 and copies it into <samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp>.
    Before this instruction, RDI is live; afterward, it’s dead. RDI and <samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp>
    don’t interfere. If we map <samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp>
    to RDI, the first <samp class="SANS_TheSansMonoCd_W5Regular_11">mov</samp> instruction
    will overwrite the address in RDI. But that’s okay, because we won’t use that
    address again.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 在这段代码片段中，RDI 存储着某个内存地址——假设是结构体或数组的地址。该片段中的第一条指令从 RDI + 4 所指向的内存位置获取值，并将其复制到
    <samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp> 中。在此指令之前，RDI 是活跃的；之后，它变为不活跃。RDI
    和 <samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp> 不会发生干扰。如果我们将 <samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp>
    映射到 RDI，那么第一条 <samp class="SANS_TheSansMonoCd_W5Regular_11">mov</samp> 指令将覆盖 RDI
    中的地址。但这没关系，因为我们之后不会再使用这个地址。
- en: The second point is that two registers interfere only if they have different
    values. Concretely, this means the instruction <samp class="SANS_TheSansMonoCd_W5Regular_11">mov
    src, dst</samp> won’t make <samp class="SANS_TheSansMonoCd_W5Regular_11">src</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">dst</samp> interfere, even if
    <samp class="SANS_TheSansMonoCd_W5Regular_11">src</samp> is still live afterward.
    In [Listing 20-12](chapter20.xhtml#list20-12), for example, <samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">y</samp> don’t interfere.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 第二点是，只有当两个寄存器的值不同，它们才会发生干扰。具体来说，这意味着 <samp class="SANS_TheSansMonoCd_W5Regular_11">mov
    src, dst</samp> 指令即使在 <samp class="SANS_TheSansMonoCd_W5Regular_11">src</samp>
    之后仍然活跃，也不会导致 <samp class="SANS_TheSansMonoCd_W5Regular_11">src</samp> 和 <samp
    class="SANS_TheSansMonoCd_W5Regular_11">dst</samp> 发生干扰。例如，在 [Listing 20-12](chapter20.xhtml#list20-12)
    中，<samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp> 和 <samp class="SANS_TheSansMonoCd_W5Regular_11">y</samp>
    不会发生干扰。
- en: '[PRE15]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 20-12: A snippet of
    assembly where the source operand of a</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">mov</samp>
    <samp class="SANS_Futura_Std_Book_Oblique_I_11">instruction is still live after
    that instruction</samp>'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 20-12：一段汇编代码，展示了在该指令之后源操作数仍然活跃的情况</samp>
- en: If we assign <samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp> and <samp
    class="SANS_TheSansMonoCd_W5Regular_11">y</samp> to the same hard register, the
    second <samp class="SANS_TheSansMonoCd_W5Regular_11">mov</samp> instruction won’t
    clobber <samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp> with a new value.
    Instead, it will have no effect at all. When we perform register coalescing, we’ll
    even go out of our way to put <samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">y</samp> in the same register
    so that we can delete this instruction entirely.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们将 <samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp> 和 <samp class="SANS_TheSansMonoCd_W5Regular_11">y</samp>
    分配到相同的硬件寄存器，那么第二条 <samp class="SANS_TheSansMonoCd_W5Regular_11">mov</samp> 指令就不会覆盖
    <samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp> 的新值，而是完全没有效果。当我们进行寄存器合并时，我们甚至会特意将
    <samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp> 和 <samp class="SANS_TheSansMonoCd_W5Regular_11">y</samp>
    放入相同的寄存器，以便我们可以完全删除这条指令。
- en: Two registers connected by a <samp class="SANS_TheSansMonoCd_W5Regular_11">mov</samp>
    instruction could still interfere for other reasons, as [Listing 20-13](chapter20.xhtml#list20-13)
    demonstrates.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 两个寄存器通过一个 <samp class="SANS_TheSansMonoCd_W5Regular_11">mov</samp> 指令连接，但仍然可能由于其他原因发生干扰，正如
    [清单 20-13](chapter20.xhtml#list20-13) 所展示的那样。
- en: '[PRE16]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 20-13: A snippet of
    assembly where a later instruction makes the operands of a</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">mov</samp>
    <samp class="SANS_Futura_Std_Book_Oblique_I_11">instruction interfere</samp>'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">清单 20-13：一段汇编代码，其中后续指令使得 `mov`
    指令的操作数发生干扰</samp>
- en: In this snippet, the second <samp class="SANS_TheSansMonoCd_W5Regular_11">mov</samp>
    instruction doesn’t make <samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">y</samp> interfere, but the
    subsequent <samp class="SANS_TheSansMonoCd_W5Regular_11">add</samp> instruction
    does, because it updates <samp class="SANS_TheSansMonoCd_W5Regular_11">y</samp>
    while <samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp> is live. In this
    case, putting <samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp> and <samp
    class="SANS_TheSansMonoCd_W5Regular_11">y</samp> in the same register would be
    unsafe.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个代码片段中，第二条 <samp class="SANS_TheSansMonoCd_W5Regular_11">mov</samp> 指令没有造成
    <samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp> 和 <samp class="SANS_TheSansMonoCd_W5Regular_11">y</samp>
    的干扰，但随后的 <samp class="SANS_TheSansMonoCd_W5Regular_11">add</samp> 指令会，因为它在 <samp
    class="SANS_TheSansMonoCd_W5Regular_11">x</samp> 仍然有效时更新了 <samp class="SANS_TheSansMonoCd_W5Regular_11">y</samp>。在这种情况下，将
    <samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp> 和 <samp class="SANS_TheSansMonoCd_W5Regular_11">y</samp>
    放入同一个寄存器是不安全的。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Spilling Registers</samp>
  id: totrans-140
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">溢出寄存器</samp>
- en: We can’t always *k*-color the interference graph. Consider the assembly function
    in [Listing 20-14](chapter20.xhtml#list20-14), which calculates <samp class="SANS_TheSansMonoCd_W5Regular_11">10
    / arg1</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">+</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">arg1
    / arg2</samp>.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不能总是 *k* 着色干扰图。考虑 [清单 20-14](chapter20.xhtml#list20-14) 中的汇编函数，它计算 <samp class="SANS_TheSansMonoCd_W5Regular_11">10
    / arg1</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">+</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">arg1
    / arg2</samp>。
- en: '[PRE17]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 20-14: Calculating</samp>
    <samp class="SANS_Futura_Std_Book_Oblique_I_11">10 / arg1 + arg1 / arg2</samp>'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">清单 20-14：计算</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">10
    / arg1 + arg1 / arg2</samp>
- en: 'For the purpose of this example, we’ll pretend that we have four hardware registers:
    ESI, EDI, EDX, and EAX. [Figure 20-4](#fig20-4) shows the interference graph for
    the listing. I won’t walk you through how to construct the graph, but you can
    verify it on your own if you like.'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 为了说明这个例子，我们假设有四个硬件寄存器：ESI、EDI、EDX 和 EAX。[图 20-4](#fig20-4) 显示了该清单的干扰图。我不会一一说明如何构建这个图，但如果你愿意，可以自己验证。
- en: '![](../images/fig20-4.jpg)'
  id: totrans-145
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/fig20-4.jpg)'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 20-4: The interference
    graph for [Listing 20-14](chapter20.xhtml#list20-14) [Description](description-67.xhtml)</samp>'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">图 20-4：干扰图，来自 [清单 20-14](chapter20.xhtml#list20-14)
    [描述](description-67.xhtml)</samp>
- en: It’s impossible to 4-color this graph. Note that EAX, EDX, <samp class="SANS_TheSansMonoCd_W5Regular_11">arg1</samp>,
    <samp class="SANS_TheSansMonoCd_W5Regular_11">arg2</samp>, and <samp class="SANS_TheSansMonoCd_W5Regular_11">tmp</samp>
    all interfere with each other. That means each of them must receive a different
    color than the other four, which would require five distinct colors. We’ll solve
    this problem by spilling a register—in other words, removing it from the graph
    instead of coloring it. Spilling any one of <samp class="SANS_TheSansMonoCd_W5Regular_11">arg1</samp>,
    <samp class="SANS_TheSansMonoCd_W5Regular_11">arg2</samp>, or <samp class="SANS_TheSansMonoCd_W5Regular_11">tmp</samp>
    will make the graph colorable. If we spill <samp class="SANS_TheSansMonoCd_W5Regular_11">tmp</samp>,
    for example, we can use the coloring shown in [Figure 20-5](#fig20-5).
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 这个图无法进行 4 着色。注意到 EAX、EDX、<samp class="SANS_TheSansMonoCd_W5Regular_11">arg1</samp>、<samp
    class="SANS_TheSansMonoCd_W5Regular_11">arg2</samp> 和 <samp class="SANS_TheSansMonoCd_W5Regular_11">tmp</samp>
    彼此之间都存在干扰。这意味着它们每一个都必须与其他四个寄存器分配不同的颜色，这将需要五种不同的颜色。我们将通过溢出一个寄存器来解决这个问题——换句话说，就是将其从图中移除，而不是着色。溢出
    <samp class="SANS_TheSansMonoCd_W5Regular_11">arg1</samp>、<samp class="SANS_TheSansMonoCd_W5Regular_11">arg2</samp>
    或 <samp class="SANS_TheSansMonoCd_W5Regular_11">tmp</samp> 中的任意一个，都会使得图可以着色。如果我们溢出
    <samp class="SANS_TheSansMonoCd_W5Regular_11">tmp</samp>，例如，我们可以使用[图 20-5](#fig20-5)所示的着色方式。
- en: '![](../images/fig20-5.jpg)'
  id: totrans-148
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/fig20-5.jpg)'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 20-5: Coloring the interference
    graph after spilling tmp [Description](description-68.xhtml)</samp>'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">图 20-5：在溢出 tmp 后为干扰图着色 [描述](description-68.xhtml)</samp>
- en: Now we can replace the two pseudoregisters that we colored, but not <samp class="SANS_TheSansMonoCd_W5Regular_11">tmp</samp>.
    [Listing 20-15](chapter20.xhtml#list20-15) gives the resulting assembly code,
    with changes from [Listing 20-14](chapter20.xhtml#list20-14) bolded.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以替换掉我们之前标记的两个伪寄存器，但不会替换<samp class="SANS_TheSansMonoCd_W5Regular_11">tmp</samp>。[清单
    20-15](chapter20.xhtml#list20-15)展示了替换后的汇编代码，来自[清单 20-14](chapter20.xhtml#list20-14)的更改已加粗。
- en: '[PRE18]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 20-15: The</samp> <samp
    class="SANS_Futura_Std_Book_Oblique_I_11">uncolorable</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">function
    after register allocation</samp>'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">清单 20-15：寄存器分配后的</samp> <samp
    class="SANS_Futura_Std_Book_Oblique_I_11">无法着色</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">函数</samp>
- en: Note that we’ve made the first two instructions in this listing redundant. We
    could optimize the code further by deleting them, but we won’t worry about this
    optimization for now.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们已经将此清单中的前两条指令做了冗余处理。我们本可以通过删除它们进一步优化代码，但暂时不考虑这个优化。
- en: After the register allocator has assigned <samp class="SANS_TheSansMonoCd_W5Regular_11">arg1</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">arg2</samp> to hard registers,
    the pseudo-operand replacement pass will put <samp class="SANS_TheSansMonoCd_W5Regular_11">tmp</samp>
    on the stack. [Listing 20-16](chapter20.xhtml#list20-16) gives the final assembly
    code for this function, with the changes from [Listing 20-15](chapter20.xhtml#list20-15)
    bolded.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 在寄存器分配器将 <samp class="SANS_TheSansMonoCd_W5Regular_11">arg1</samp> 和 <samp class="SANS_TheSansMonoCd_W5Regular_11">arg2</samp>
    分配到硬寄存器后，伪操作数替换过程将把 <samp class="SANS_TheSansMonoCd_W5Regular_11">tmp</samp> 放到栈上。[清单
    20-16](chapter20.xhtml#list20-16)展示了该函数的最终汇编代码，其中来自[清单 20-15](chapter20.xhtml#list20-15)的更改已加粗。
- en: '[PRE19]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 20-16: The final assembly
    code for</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">uncolorable</samp>'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">清单 20-16：最终的汇编代码，适用于</samp>
    <samp class="SANS_Futura_Std_Book_Oblique_I_11">无法着色</samp>
- en: Spilling one pseudoregister made it possible to replace all the others with
    hard registers. But *which* registers we decide to spill matters a lot! As a general
    rule, the more frequently a pseudoregister is accessed, the more it will hurt
    performance to spill that pseudoregister. Our allocator will calculate a *spill
    cost* for each register in the interference graph. This is an estimate of how
    much spilling that register will hurt performance. Then, when we color the graph,
    we’ll use that information to minimize the overall performance impact of spills.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 溢出一个伪寄存器使得我们能够用硬寄存器替换掉其他所有寄存器。但我们决定溢出*哪个*寄存器非常重要！通常，伪寄存器的访问频率越高，溢出该寄存器对性能的影响就越大。我们的分配器会为干扰图中的每个寄存器计算一个*溢出成本*。这是估算溢出该寄存器对性能的影响程度。然后，当我们对图进行着色时，会使用这些信息来最小化溢出的整体性能影响。
- en: <samp class="SANS_Futura_Std_Bold_B_11">The Basic Register Allocator</samp>
  id: totrans-158
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">基本寄存器分配器</samp>
- en: Now that we have some idea of how our register allocator will work, let’s implement
    it! [Listing 20-17](chapter20.xhtml#list20-17) describes how to allocate registers
    for a single function.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们对寄存器分配器的工作方式有了一些了解，接下来让我们实现它吧！[清单 20-17](chapter20.xhtml#list20-17)描述了如何为单个函数分配寄存器。
- en: '[PRE20]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 20-17: The top-level
    register allocation algorithm</samp>'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">清单 20-17：顶层寄存器分配算法</samp>
- en: We start by building the interference graph. Then, we calculate a spill cost
    for each register based on how frequently it’s used and annotate the graph with
    that information. Next, we color the graph, annotating each node with its color.
    If we can’t color every node, we’ll use the spill costs we calculated in the previous
    step to decide what to spill. To spill a node, we’ll just leave it uncolored.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先构建干扰图。然后，我们根据每个寄存器的使用频率计算溢出代价，并在图中注释这些信息。接下来，我们对图进行着色，为每个节点注释它的颜色。如果我们不能为每个节点着色，我们将使用在前一步计算的溢出代价来决定溢出哪个寄存器。要溢出一个节点，我们只需将其保持为无色。
- en: The last step is replacing all the pseudoregisters we colored. In <samp class="SANS_TheSansMonoCd_W5Regular_11">create
    _register_map</samp>, we construct a map from colored pseudoregisters to hard
    registers with the same color. Finally, we rewrite the body of the function, replacing
    each pseudoregister with the corresponding hard register from the map.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一步是替换我们标记的所有伪寄存器。在 <samp class="SANS_TheSansMonoCd_W5Regular_11">create _register_map</samp>
    中，我们构建了一个从有颜色的伪寄存器到相同颜色的硬寄存器的映射。最后，我们重写函数体，将每个伪寄存器替换为映射中相应的硬寄存器。
- en: Go ahead and stub out <samp class="SANS_TheSansMonoCd_W5Regular_11">allocate_registers</samp>.
    Then, we’ll walk through how to implement each of these steps.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 继续并创建 <samp class="SANS_TheSansMonoCd_W5Regular_11">allocate_registers</samp>
    的存根。然后，我们将一步步实现这些步骤。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Handling Multiple
    Types During Register Allocation</samp>
  id: totrans-165
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">处理寄存器分配中的多种类型</samp>
- en: 'If you completed [Part II](part2.xhtml), then you’ll need to run the whole
    algorithm in [Listing 20-17](chapter20.xhtml#list20-17) twice: once to allocate
    general-purpose registers and once to allocate XMM registers. On each run, you’ll
    include only registers of the appropriate type in the interference graph. The
    new features we added in [Part II](part2.xhtml) will change a few other details
    about how we build the interference graph too. We’ll take a closer look at these
    changes when we implement <samp class="SANS_TheSansMonoCd_W5Regular_11">build_graph</samp>.'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你完成了[第二部分](part2.xhtml)，你将需要运行整个算法两次：[清单 20-17](chapter20.xhtml#list20-17)一次分配通用寄存器，一次分配XMM寄存器。在每次运行时，你只会在干扰图中包含适当类型的寄存器。我们在[第二部分](part2.xhtml)中添加的新功能也会改变构建干扰图的一些细节。当我们实现
    <samp class="SANS_TheSansMonoCd_W5Regular_11">build_graph</samp> 时，我们将更详细地查看这些变化。
- en: The individual steps after building the interference graph—including calculating
    spill costs, coloring the graph, and replacing pseudoregisters—look exactly the
    same whether we’re dealing with floating-point or general-purpose registers. The
    other features we added in [Part II](part2.xhtml) won’t impact these steps either.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 在构建干扰图后的单独步骤——包括计算溢出代价、着色图以及替换伪寄存器——无论我们处理的是浮点寄存器还是通用寄存器，步骤都完全相同。[第二部分](part2.xhtml)中添加的其他功能也不会影响这些步骤。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Defining the Interference
    Graph</samp>
  id: totrans-168
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">定义干扰图</samp>
- en: To get started, we’ll define the data structure for the interference graph.
    [Listing 20-18](chapter20.xhtml#list20-18) presents one possible representation.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 为了开始，我们将定义干扰图的数据结构。[清单 20-18](chapter20.xhtml#list20-18)展示了一种可能的表示方式。
- en: '[PRE21]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 20-18: The definition
    of the register interference graph</samp>'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">清单 20-18：寄存器干扰图的定义</samp>
- en: Each node in the graph corresponds to a <samp class="SANS_TheSansMonoCd_W5Regular_11">Pseudo</samp>
    or <samp class="SANS_TheSansMonoCd_W5Regular_11">Register</samp> operand from
    the assembly AST. We’ll track each node’s neighbors, spill cost, and color. We’ll
    represent colors with the integers <samp class="SANS_TheSansMonoCd_W5Regular_11">1</samp>
    through <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">k</samp>, where
    *k* is the number of available hard registers. The <samp class="SANS_TheSansMonoCd_W5Regular_11">color</samp>
    field is optional because we may not be able to color every node. We’ll use the
    <samp class="SANS_TheSansMonoCd_W5Regular_11">pruned</samp> flag when we color
    the graph; you can ignore it until then. When you create a new node, you should
    initialize <samp class="SANS_TheSansMonoCd_W5Regular_11">spill_cost</samp> to
    <samp class="SANS_TheSansMonoCd_W5Regular_11">0.0</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">color</samp>
    to <samp class="SANS_TheSansMonoCd_W5Regular_11">null</samp>, and <samp class="SANS_TheSansMonoCd_W5Regular_11">pruned</samp>
    to <samp class="SANS_TheSansMonoCd_W5Regular_11">False</samp>.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 图中的每个节点对应于汇编AST中的一个<samp class="SANS_TheSansMonoCd_W5Regular_11">Pseudo</samp>或<samp
    class="SANS_TheSansMonoCd_W5Regular_11">Register</samp>操作数。我们将跟踪每个节点的邻居、溢出代价和颜色。我们将使用整数<samp
    class="SANS_TheSansMonoCd_W5Regular_11">1</samp>到<samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">k</samp>来表示颜色，其中*k*是可用硬件寄存器的数量。<samp
    class="SANS_TheSansMonoCd_W5Regular_11">color</samp>字段是可选的，因为我们可能无法为每个节点上色。我们将在上色图时使用<samp
    class="SANS_TheSansMonoCd_W5Regular_11">pruned</samp>标志；你可以在那之前忽略它。创建新节点时，应该将<samp
    class="SANS_TheSansMonoCd_W5Regular_11">spill_cost</samp>初始化为<samp class="SANS_TheSansMonoCd_W5Regular_11">0.0</samp>，将<samp
    class="SANS_TheSansMonoCd_W5Regular_11">color</samp>初始化为<samp class="SANS_TheSansMonoCd_W5Regular_11">null</samp>，并将<samp
    class="SANS_TheSansMonoCd_W5Regular_11">pruned</samp>初始化为<samp class="SANS_TheSansMonoCd_W5Regular_11">False</samp>。
- en: This definition of <samp class="SANS_TheSansMonoCd_W5Regular_11">node</samp>
    is a bit more permissive than it needs to be; the <samp class="SANS_TheSansMonoCd_W5Regular_11">operand</samp>
    type includes constants and memory locations, which we’ll never add to the interference
    graph. Alternatively, you could replace <samp class="SANS_TheSansMonoCd_W5Regular_11">operand</samp>
    with a dedicated <samp class="SANS_TheSansMonoCd_W5Regular_11">node_id</samp>
    type that can represent only registers. I’m using a more permissive definition
    so that we don’t have to constantly convert back and forth between <samp class="SANS_TheSansMonoCd_W5Regular_11">operand</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">node_id</samp> throughout the
    allocator.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 这个<samp class="SANS_TheSansMonoCd_W5Regular_11">node</samp>的定义比实际需要的要宽松一些；<samp
    class="SANS_TheSansMonoCd_W5Regular_11">operand</samp>类型包括常量和内存位置，而我们永远不会将它们添加到干扰图中。或者，你可以用一个专门的<samp
    class="SANS_TheSansMonoCd_W5Regular_11">node_id</samp>类型来替代<samp class="SANS_TheSansMonoCd_W5Regular_11">operand</samp>，该类型只表示寄存器。我使用更宽松的定义，以便我们不必在整个分配器中不断地在<samp
    class="SANS_TheSansMonoCd_W5Regular_11">operand</samp>和<samp class="SANS_TheSansMonoCd_W5Regular_11">node_id</samp>之间来回转换。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Building the Interference
    Graph</samp>
  id: totrans-174
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">构建干扰图</samp>
- en: We’re finally ready to build the interference graph! First, we’ll walk through
    an implementation of <samp class="SANS_TheSansMonoCd_W5Regular_11">build_graph</samp>
    that supports the assembly AST from [Part I](part1.xhtml). Then, we’ll discuss
    how to modify it to support the assembly AST from [Part II](part2.xhtml).
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 我们终于准备好构建干扰图了！首先，我们将通过实现一个支持来自[第一部分](part1.xhtml)的汇编AST的<samp class="SANS_TheSansMonoCd_W5Regular_11">build_graph</samp>来演示。然后，我们将讨论如何修改它以支持来自[第二部分](part2.xhtml)的汇编AST。
- en: Since building this graph is a fairly involved process, we’ll break it down
    into several steps. [Listing 20-19](chapter20.xhtml#list20-19) illustrates these
    steps in pseudocode.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 由于构建这个图是一个相当复杂的过程，我们将它分解为几个步骤。[清单20-19](chapter20.xhtml#list20-19)在伪代码中展示了这些步骤。
- en: '[PRE22]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 20-19: Building the
    interference graph</samp>'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">清单20-19：构建干扰图</samp>
- en: We’ll start with a graph that includes every hard register ❶. (As far as I know,
    there’s no standard term for this graph, so I’ll call it the *base graph*.) Next,
    we’ll insert a node for each pseudoregister that appears in the function ❷. Finally,
    we’ll figure out which registers interfere with each other. Since this depends
    on which registers are live at each point, we’ll need to run liveness analysis
    on our assembly code. Just like in [Chapter 19](chapter19.xhtml), this analysis
    will take a control-flow graph (which is different from the interference graph!)
    and annotate it with liveness information ❸. Finally, we’ll use that information
    to figure out which edges to add to the interference graph ❹. Let’s take a closer
    look at each of these steps.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从一个包含所有硬件寄存器的图开始 ❶。（据我所知，这个图没有标准术语，所以我将它称为*基础图*。）接下来，我们将为函数中出现的每个伪寄存器插入一个节点
    ❷。最后，我们将找出哪些寄存器相互干扰。由于这取决于每个点上哪些寄存器是活动的，我们需要在汇编代码上运行活跃性分析。就像在[第19章](chapter19.xhtml)中一样，这项分析将采用控制流图（它与干扰图不同！）并用活跃性信息对其进行注释
    ❸。最后，我们将使用这些信息来确定要向干扰图中添加哪些边 ❹。让我们仔细看看每个步骤。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">The Base Graph</samp>
  id: totrans-180
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">基础图</samp>
- en: 'The base graph, shown in [Figure 20-6](#fig20-6), includes 12 registers: RAX,
    RBX, RCX, RDX, RDI, RSI, R8, R9, R12, R13, R14, and R15.'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 基础图，如[图20-6](#fig20-6)所示，包含12个寄存器：RAX、RBX、RCX、RDX、RDI、RSI、R8、R9、R12、R13、R14和R15。
- en: '![](../images/fig20-6.jpg)'
  id: totrans-182
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/fig20-6.jpg)'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 20-6: The base register
    interference graph [Description](description-69.xhtml)</samp>'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">图20-6：基础寄存器干扰图 [描述](description-69.xhtml)</samp>
- en: We won’t include RSP or RBP in the graph because we’re already using them to
    manage the stack frame, and we won’t include R10 or R11 because we’ll need them
    in the instruction fix-up pass. Since the hard registers all interfere with each
    other, the base graph includes an edge between each pair of nodes. In graph theory
    jargon, this makes the base graph a *complete graph*.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不会在图中包含RSP或RBP，因为我们已经在使用它们来管理堆栈帧，也不会包含R10或R11，因为我们将在指令修正过程中需要它们。由于所有硬寄存器彼此之间都会发生干扰，基础图中包含了每对节点之间的边。在图论术语中，这使得基础图成为一个*完全图*。
- en: <samp class="SANS_Dogma_OT_Bold_B_39">NOTE</samp>
  id: totrans-185
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: <samp class="SANS_Dogma_OT_Bold_B_39">注意</samp>
- en: '*Because the example programs in this chapter deal with 4-byte pseudoregisters,
    most of the diagrams of interference graphs use 4-byte aliases for hard registers.
    I’ve used 8-byte aliases in [Figure 20-6](#fig20-6), since it represents the base
    graph you’ll use for all programs rather than the interference graph for any specific
    program. The interference graphs we actually construct will represent hard registers
    using reg assembly AST nodes, which don’t specify a size.*'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: '*由于本章的示例程序处理的是4字节的伪寄存器，大多数干扰图的示意图使用4字节的硬寄存器别名。我在[图20-6](#fig20-6)中使用了8字节的别名，因为它表示的是您将用于所有程序的基础图，而不是任何特定程序的干扰图。我们实际构建的干扰图将使用reg汇编AST节点来表示硬寄存器，而这些节点并不指定大小。*'
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">Adding Pseudoregisters to
    the Graph</samp>
  id: totrans-187
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">将伪寄存器添加到图中</samp>
- en: 'This bit is straightforward: we just loop over every operand in every instruction
    and decide whether to add it to the graph. Every pseudoregister that appears in
    the assembly function should go in the graph, unless it has static storage duration.
    I’ll skip the pseudocode for <samp class="SANS_TheSansMonoCd_W5Regular_11">add_pseudoregisters</samp>
    because there’s not a lot to it.'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 这部分很简单：我们只需遍历每条指令中的每个操作数，并决定是否将其添加到图中。每个出现在汇编函数中的伪寄存器都应该加入图中，除非它具有静态存储期。我会跳过<sup
    class="SANS_TheSansMonoCd_W5Regular_11">add_pseudoregisters</sup>的伪代码，因为它并没有太多内容。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">Liveness Analysis</samp>
  id: totrans-189
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">活跃性分析</samp>
- en: We already know how liveness analysis works, since we implemented it back in
    [Chapter 19](chapter19.xhtml). Now we’ll need a new implementation that analyzes
    assembly instead of TACKY and tracks registers instead of variables. Luckily,
    the basic logic is the same. We can even reuse some of our existing code.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经知道活跃性分析是如何工作的，因为我们在[第19章](chapter19.xhtml)中实现过它。现在我们需要一个新的实现，来分析汇编代码而不是TACKY，并跟踪寄存器而不是变量。幸运的是，基本逻辑是相同的。我们甚至可以重用一些现有的代码。
- en: 'First, we’ll construct a control-flow graph. This works just like building
    a control-flow graph from a TACKY function; only the specific instructions at
    the boundaries between basic blocks are different. Instead of looking for TACKY
    control-flow instructions like <samp class="SANS_TheSansMonoCd_W5Regular_11">Label</samp>,
    <samp class="SANS_TheSansMonoCd_W5Regular_11">Return</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">Jump</samp>,
    <samp class="SANS_TheSansMonoCd_W5Regular_11">JumpIfZero</samp>, and <samp class="SANS_TheSansMonoCd_W5Regular_11">JumpIfNotZero</samp>,
    we’ll look for their assembly equivalents: the assembly <samp class="SANS_TheSansMonoCd_W5Regular_11">Label</samp>
    instruction, <samp class="SANS_TheSansMonoCd_W5Regular_11">Ret</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">Jmp</samp>,
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">JmpCC</samp>. You’ve already
    written code to convert TACKY into a control-flow graph; ideally, you’ll be able
    to refactor it to handle assembly too.'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将构建一个控制流图。这个过程与从TACKY函数构建控制流图一样，只不过基本块之间边界的具体指令不同。我们不会寻找像<samp class="SANS_TheSansMonoCd_W5Regular_11">Label</samp>、<samp
    class="SANS_TheSansMonoCd_W5Regular_11">Return</samp>、<samp class="SANS_TheSansMonoCd_W5Regular_11">Jump</samp>、<samp
    class="SANS_TheSansMonoCd_W5Regular_11">JumpIfZero</samp>和<samp class="SANS_TheSansMonoCd_W5Regular_11">JumpIfNotZero</samp>这样的TACKY控制流指令，而是寻找它们的汇编等价指令：汇编中的<samp
    class="SANS_TheSansMonoCd_W5Regular_11">Label</samp>指令、<samp class="SANS_TheSansMonoCd_W5Regular_11">Ret</samp>、<samp
    class="SANS_TheSansMonoCd_W5Regular_11">Jmp</samp>和<samp class="SANS_TheSansMonoCd_W5Regular_11">JmpCC</samp>。你已经编写了将TACKY转换为控制流图的代码；理想情况下，你应该能够重构它以同时处理汇编。
- en: 'Next, we’ll look at the three components of liveness analysis itself: the iterative
    algorithm, the meet operator, and the transfer function. The iterative algorithm
    is exactly the same as in [Chapter 19](chapter19.xhtml), so you should be able
    to use the implementation of this algorithm that you already wrote.'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将研究活跃度分析本身的三个组成部分：迭代算法、合并运算符和传输函数。迭代算法与[第19章](chapter19.xhtml)中完全相同，因此你应该能够使用你已经编写的该算法的实现。
- en: 'We’ll use set union as our meet operator, just like we did before. However,
    we’ll handle the <samp class="SANS_TheSansMonoCd_W5Regular_11">EXIT</samp> node
    in the control-flow graph differently. Our original meet operator assumed that
    static variables were live when a function exited. Now we don’t care about static
    variables, because they’re not in the interference graph. Instead, we have to
    worry about hard registers: specifically EAX, which holds the function’s return
    value. [Listing 20-20](chapter20.xhtml#list20-20) defines our new meet operator,
    with the one change from the original meet operator defined in [Listing 19-24](chapter19.xhtml#list19-24)
    in bold.'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用集合并集作为我们的合并运算符，就像之前一样。然而，我们将在控制流图中的<samp class="SANS_TheSansMonoCd_W5Regular_11">EXIT</samp>节点上进行不同的处理。我们原来的合并运算符假设在函数退出时静态变量是活跃的。现在我们不关心静态变量，因为它们不在干扰图中。相反，我们必须关心硬寄存器，特别是EAX寄存器，它保存函数的返回值。[清单20-20](chapter20.xhtml#list20-20)定义了我们新的合并运算符，并在原始合并运算符（定义在[清单19-24](chapter19.xhtml#list19-24)中）上做出了一个改动，这个改动已用粗体标出。
- en: '[PRE23]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 20-20: The meet operator
    for liveness analysis of assembly code</samp>'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">清单20-20：汇编代码的活跃度分析合并运算符</samp>
- en: We’re ignoring the fact that the callee-saved registers are *also* live at <samp
    class="SANS_TheSansMonoCd_W5Regular_11">EXIT</samp>. We can get away with this
    because the instruction fix-up pass will spill these registers if we end up using
    them; that is, it will save their values onto the stack at the start of the function
    and restore them before we return. Assuming that these registers are dead at <samp
    class="SANS_TheSansMonoCd_W5Regular_11">EXIT</samp> makes it possible to actually
    use them. If we added them to the set of live registers here, we’d conclude that
    they were live throughout the whole function and interfered with every single
    pseudoregister.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 我们忽略了被调用者保存的寄存器在<samp class="SANS_TheSansMonoCd_W5Regular_11">EXIT</samp>时*也*处于活跃状态这一事实。我们之所以能够这么做，是因为指令修正阶段如果使用到这些寄存器，它会将其溢出：也就是说，它会在函数开始时将它们的值保存到栈中，并在返回之前恢复它们。假设这些寄存器在<samp
    class="SANS_TheSansMonoCd_W5Regular_11">EXIT</samp>时是死的，使得我们实际上可以使用它们。如果我们将它们添加到活跃寄存器集合中，我们会得出它们在整个函数中都处于活跃状态的结论，并且与每一个伪寄存器发生干扰。
- en: 'The transfer function is the one part of liveness analysis that differs significantly
    from the previous chapter. The basic idea is the same: we add registers to the
    live set when they’re used and remove them when they’re updated. But the specifics
    are different because we’re working with a different set of instructions than
    we were before.'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 传输函数是活跃分析中与上一章显著不同的部分。基本思路是一样的：当寄存器被使用时，我们将其添加到活跃集合中，而当它们被更新时，我们将其移除。但具体细节有所不同，因为我们使用的是一组与之前不同的指令。
- en: First, let’s write a helper function, <samp class="SANS_TheSansMonoCd_W5Regular_11">find_used_and_updated</samp>,
    that tells us which operands each instruction uses and updates. Both the transfer
    function and the <samp class="SANS_TheSansMonoCd_W5Regular_11">add_edges</samp>
    function that we’ll implement next will use this helper function. [Listing 20-21](chapter20.xhtml#list20-21)
    gives the pseudocode for <samp class="SANS_TheSansMonoCd_W5Regular_11">find_used_and_updated</samp>.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们编写一个辅助函数，<samp class="SANS_TheSansMonoCd_W5Regular_11">find_used_and_updated</samp>，它告诉我们每条指令使用和更新了哪些操作数。接下来我们要实现的传输函数和
    <samp class="SANS_TheSansMonoCd_W5Regular_11">add_edges</samp> 函数都将使用这个辅助函数。[清单
    20-21](chapter20.xhtml#list20-21) 给出了 <samp class="SANS_TheSansMonoCd_W5Regular_11">find_used_and_updated</samp>
    的伪代码。
- en: '[PRE24]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 20-21: Identifying
    the operands used and updated by each instruction</samp>'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">清单 20-21：识别每条指令使用和更新的操作数</samp>
- en: 'Keep in mind that this listing covers only the assembly instructions from [Part
    I](part1.xhtml). <samp class="SANS_TheSansMonoCd_W5Regular_11">Mov</samp> is the
    most straightforward case: it uses its source and updates its destination ❶. A
    binary instruction like <samp class="SANS_TheSansMonoCd_W5Regular_11">add src,
    dst</samp> uses its source and destination and updates its destination ❷. It’s
    also easy to see which operands the <samp class="SANS_TheSansMonoCd_W5Regular_11">Unary</samp>,
    <samp class="SANS_TheSansMonoCd_W5Regular_11">Cmp</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">SetCC</samp>,
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">Push</samp> instructions read
    and update.'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，这份清单仅涵盖了[第一部分](part1.xhtml)的汇编指令。<samp class="SANS_TheSansMonoCd_W5Regular_11">Mov</samp>
    是最直接的例子：它使用源操作数并更新其目标操作数 ❶。像 <samp class="SANS_TheSansMonoCd_W5Regular_11">add
    src, dst</samp> 这样的二进制指令使用源操作数和目标操作数，并更新目标操作数 ❷。同样也很容易看出 <samp class="SANS_TheSansMonoCd_W5Regular_11">Unary</samp>、<samp
    class="SANS_TheSansMonoCd_W5Regular_11">Cmp</samp>、<samp class="SANS_TheSansMonoCd_W5Regular_11">SetCC</samp>
    和 <samp class="SANS_TheSansMonoCd_W5Regular_11">Push</samp> 指令读取并更新了哪些操作数。
- en: Some instructions use registers that they don’t mention explicitly. <samp class="SANS_TheSansMonoCd_W5Regular_11">Idiv</samp>
    divides the value stored in the EAX and EDX registers by its source operand, so
    it uses all three values. It stores its results in EAX and EDX, so it updates
    those two registers. <samp class="SANS_TheSansMonoCd_W5Regular_11">Cdq</samp>
    sign extends EAX into EDX, which means it uses EAX and updates EDX.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 一些指令使用它们未明确提到的寄存器。<samp class="SANS_TheSansMonoCd_W5Regular_11">Idiv</samp>
    将存储在 EAX 和 EDX 寄存器中的值除以其源操作数，因此它使用了这三个值。它将结果存储在 EAX 和 EDX 中，所以它更新了这两个寄存器。<samp
    class="SANS_TheSansMonoCd_W5Regular_11">Cdq</samp> 将 EAX 的符号扩展到 EDX，这意味着它使用 EAX
    并更新 EDX。
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">Call</samp> uses the registers
    that hold the callee’s parameters; we can look these up in the backend symbol
    table, where we recorded them during the assembly generation pass ❸. It updates
    all the caller-saved registers—whether we’re passing the callee’s parameters in
    them or not—since these may be clobbered by the callee. This makes all the caller-saved
    registers interfere with any pseudoregisters that are live when we call this function,
    so our graph coloring algorithm will assign these pseudoregisters to callee-saved
    registers instead.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W5Regular_11">Call</samp> 使用存储被调用者参数的寄存器；我们可以在后端符号表中查找这些寄存器，我们在汇编生成过程中记录了它们
    ❸。它更新所有调用者保存的寄存器——无论我们是否通过这些寄存器传递被调用者的参数——因为这些寄存器可能会被被调用者破坏。这使得所有调用者保存的寄存器会干扰任何在调用此函数时仍然活跃的伪寄存器，因此我们的图着色算法会将这些伪寄存器分配给被调用者保存的寄存器。
- en: If an instruction both uses and updates the same register—like a <samp class="SANS_TheSansMonoCd_W5Regular_11">Binary</samp>
    instruction both uses and updates its destination, for example—it’s important
    to include that register in both the <samp class="SANS_TheSansMonoCd_W5Regular_11">used</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">updated</samp> lists. In the
    transfer function, we’ll only care that the register is used, since that will
    make it live. But when we use this helper function again in <samp class="SANS_TheSansMonoCd_W5Regular_11">add_edges</samp>,
    we’ll only care that the register is updated, since that will make it interfere
    with any other registers that are live at the same time.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一条指令既使用又更新相同的寄存器——例如，<samp class="SANS_TheSansMonoCd_W5Regular_11">二进制</samp>指令既使用又更新它的目标寄存器——那么将该寄存器同时加入到
    <samp class="SANS_TheSansMonoCd_W5Regular_11">使用过的</samp> 和 <samp class="SANS_TheSansMonoCd_W5Regular_11">更新过的</samp>
    列表中是很重要的。在传输函数中，我们只关心寄存器的使用情况，因为这会使它变得活跃。但是，当我们在 <samp class="SANS_TheSansMonoCd_W5Regular_11">add_edges</samp>
    中再次使用这个辅助函数时，我们只关心寄存器的更新情况，因为这会使它与任何同时活跃的其他寄存器产生干扰。
- en: Now we can write the transfer function, which is defined in [Listing 20-22](chapter20.xhtml#list20-22).
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以编写传输函数，它定义在[列表 20-22](chapter20.xhtml#list20-22)中。
- en: '[PRE25]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 20-22: The transfer
    function for liveness analysis in assembly</samp>'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">列表 20-22：汇编中的活动性分析传输函数</samp>
- en: Since this is a backward analysis, we analyze the assembly instructions in reverse
    order. To process an instruction, we first record which registers are live immediately
    after it ❶. Then, we calculate which registers are live just before it. We call
    the helper function we just wrote to figure out what operands it uses and updates
    ❷. We then remove any registers it updates from the set of current live registers,
    and we add any registers it uses. (If an instruction uses and updates the same
    register, we’ll remove that register from the set of live registers and then immediately
    add it again.) Once we’ve processed every instruction, we record which registers
    are live at the start of the block ❸.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这是一个反向分析，我们按逆序分析汇编指令。处理一条指令时，我们首先记录指令执行后哪些寄存器是活跃的 ❶。然后，我们计算出指令执行前哪些寄存器是活跃的。我们调用刚才编写的辅助函数来确定它使用和更新了哪些操作数
    ❷。接着，我们将它更新的任何寄存器从当前活跃寄存器集合中移除，并将它使用的寄存器添加进来。（如果一条指令使用并更新同一寄存器，我们将先将该寄存器从活跃寄存器集合中移除，再立刻将其添加回去。）一旦处理完每条指令，我们记录下该块开始时哪些寄存器是活跃的
    ❸。
- en: We won’t track constants and memory operands, but our set of live registers
    might still include some operands that we don’t care about (specifically, pseudoregisters
    with static storage duration). There’s no harm in including them in our liveness
    results; we’ll just ignore them when we use those results in the next step.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不会跟踪常量和内存操作数，但我们的活动寄存器集合可能仍然包括一些我们不关心的操作数（特别是具有静态存储持续时间的伪寄存器）。将它们包括在我们的活动性结果中不会造成任何
    harm；当我们在下一步中使用这些结果时，我们会忽略它们。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">Adding Edges</samp>
  id: totrans-210
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">添加边</samp>
- en: With liveness information in hand, we can finally figure out which edges to
    add to the graph. [Listing 20-23](chapter20.xhtml#list20-23) gives the pseudocode
    for this step.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 拿到活动性信息后，我们终于可以弄清楚要向图中添加哪些边。[列表 20-23](chapter20.xhtml#list20-23) 给出了这一步的伪代码。
- en: '[PRE26]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 20-23: Adding edges
    to the interference graph</samp>'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">列表 20-23：向干扰图中添加边</samp>
- en: We learned earlier that two registers interfere if one is updated while the
    other is live. Now we’ll look at each instruction and figure out which interferences
    it creates. To process a single instruction, we’ll first call <samp class="SANS_TheSansMonoCd_W5Regular_11">find_used_and_updated</samp>
    to look up what operands it updates. (We’ll ignore the first list this function
    returns, <samp class="SANS_TheSansMonoCd_W5Regular_11">used</samp>, because don’t
    care what operands the instruction uses.) Next, we’ll look up which registers
    are live immediately after the instruction ❶.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 我们之前学到，当一个寄存器在另一个寄存器活跃时被更新时，这两个寄存器会产生干扰。现在我们将查看每条指令并弄清楚它创建了哪些干扰。处理单条指令时，我们首先调用
    <samp class="SANS_TheSansMonoCd_W5Regular_11">find_used_and_updated</samp> 来查找它更新了哪些操作数。（我们会忽略该函数返回的第一个列表
    <samp class="SANS_TheSansMonoCd_W5Regular_11">used</samp>，因为我们不关心指令使用了哪些操作数。）接下来，我们查找指令执行后哪些寄存器是活跃的
    ❶。
- en: We then add an edge between each register in <samp class="SANS_TheSansMonoCd_W5Regular_11">live_registers</samp>
    and each register in <samp class="SANS_TheSansMonoCd_W5Regular_11">updated</samp>.
    The <samp class="SANS_TheSansMonoCd_W5Regular_11">Mov</samp> instruction is a
    special case. If the current instruction is a <samp class="SANS_TheSansMonoCd_W5Regular_11">Mov</samp>,
    we’ll skip over its source as we iterate over the set of live registers so that
    we don’t add an edge between its source and destination ❷.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们在<_samp class="SANS_TheSansMonoCd_W5Regular_11">live_registers</samp>中的每个寄存器和<sam>p
    class="SANS_TheSansMonoCd_W5Regular_11">updated</samp>中的每个寄存器之间添加一条边。<samp class="SANS_TheSansMonoCd_W5Regular_11">Mov</samp>指令是一个特殊的情况。如果当前指令是<samp
    class="SANS_TheSansMonoCd_W5Regular_11">Mov</samp>，我们将在遍历活动寄存器集合时跳过其源寄存器，这样我们就不会在源寄存器和目标寄存器之间添加一条边
    ❷。
- en: Before we add an edge between two nodes, we’ll make sure that both nodes are
    already in the interference graph. We’ll also make sure that they’re different,
    since we don’t want to add an edge from a node to itself ❸.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们为两个节点之间添加一条边之前，我们会确保这两个节点已经存在于干扰图中。我们还会确保它们是不同的，因为我们不想添加一条从一个节点指向它自身的边 ❸。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">Handling Other Types While
    Constructing the Graph</samp>
  id: totrans-217
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">构建图时处理其他类型</samp>
- en: 'Now we’ll deal with all the features we added in [Part II](part2.xhtml). Since
    we allocate XMM and general-purpose registers separately, we’ll build two interference
    graphs. We’ll start with a separate base graph for each register class. The base
    graph for XMM registers should have 14 nodes; it will include XMM0 through XMM13,
    but not the scratch registers XMM14 and XMM15\. In <samp class="SANS_TheSansMonoCd_W5Regular_11">add_pseudoregisters</samp>,
    we’ll check that a pseudoregister has the correct type before adding it to the
    graph. When we allocate XMM registers, we’ll add only pseudoregisters of <samp
    class="SANS_TheSansMonoCd_W5Regular_11">Double</samp> type to the graph. When
    we allocate general-purpose registers, we’ll exclude <samp class="SANS_TheSansMonoCd_W5Regular_11">Double</samp>
    pseudoregisters and include all the other scalar types: <samp class="SANS_TheSansMonoCd_W5Regular_11">Longword</samp>,
    <samp class="SANS_TheSansMonoCd_W5Regular_11">Quadword</samp>, and <samp class="SANS_TheSansMonoCd_W5Regular_11">Byte</samp>.'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将处理在[第 II 部分](part2.xhtml)中添加的所有功能。由于我们分别分配 XMM 和通用寄存器，因此我们将构建两个干扰图。我们将从每个寄存器类别的单独基本图开始。XMM寄存器的基本图应包含14个节点；它将包括XMM0到XMM13，但不包括临时寄存器XMM14和XMM15。在<samp
    class="SANS_TheSansMonoCd_W5Regular_11">add_pseudoregisters</samp>中，我们会检查伪寄存器是否具有正确的类型，然后再将其添加到图中。当我们分配XMM寄存器时，我们只会将<sam>p
    class="SANS_TheSansMonoCd_W5Regular_11">Double</samp>类型的伪寄存器添加到图中。当我们分配通用寄存器时，我们将排除<sam>p
    class="SANS_TheSansMonoCd_W5Regular_11">Double</samp>伪寄存器，并包括所有其他标量类型：<samp class="SANS_TheSansMonoCd_W5Regular_11">Longword</samp>、<samp
    class="SANS_TheSansMonoCd_W5Regular_11">Quadword</samp>和<samp class="SANS_TheSansMonoCd_W5Regular_11">Byte</samp>。
- en: Floating-point registers aside, there are a few other details we need to change.
    We’ll exclude aliased pseudoregisters from the graph, since they shouldn’t be
    assigned to registers. You can reuse the previous chapter’s address-taken analysis
    here; just rerun the analysis immediately before converting the program from TACKY
    to assembly. If a variable was aliased in the TACKY program, it will still be
    aliased in assembly.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 除了浮点寄存器外，还有一些其他细节我们需要更改。我们将排除别名化的伪寄存器，因为它们不应该分配给寄存器。你可以在这里重用上一章的地址分析；只需在将程序从TACKY转换为汇编语言之前重新运行分析。如果在TACKY程序中某个变量被别名化，它在汇编程序中仍然会被别名化。
- en: Liveness analysis should reflect the new calling conventions we implemented
    in [Part II](part2.xhtml). The <samp class="SANS_TheSansMonoCd_W5Regular_11">meet</samp>
    function can’t assume that EAX is live when the function exits; it should check
    the backend symbol table to learn which registers the function uses to pass its
    return value. These registers will all be live at <samp class="SANS_TheSansMonoCd_W5Regular_11">EXIT</samp>.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 活跃度分析应反映我们在[第 II 部分](part2.xhtml)中实现的新调用约定。<samp class="SANS_TheSansMonoCd_W5Regular_11">meet</samp>函数不能假定当函数退出时EAX仍然是活动的；它应该检查后端符号表，了解函数使用哪些寄存器来传递返回值。这些寄存器在<samp
    class="SANS_TheSansMonoCd_W5Regular_11">EXIT</samp>时都会是活动的。
- en: We’ll also update the <samp class="SANS_TheSansMonoCd_W5Regular_11">find_used_and_updated</samp>
    helper function. First, this function needs to handle the <samp class="SANS_TheSansMonoCd_W5Regular_11">Memory</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">Indexed</samp> operands correctly.
    These operands designate locations in memory, but they use registers in their
    address calculations. When we use one of these operands, we *read* any registers
    it refers to, even if we *write* to the memory location it designates. For example,
    the instruction <samp class="SANS_TheSansMonoCd_W5Regular_11">movl $1, 4(%rax)</samp>
    uses RAX instead of updating it, and the instruction <samp class="SANS_TheSansMonoCd_W5Regular_11">leaq
    (%rax, %rcx, 4), %rdi</samp> uses both RAX and RCX but updates RDI. Second, <samp
    class="SANS_TheSansMonoCd_W5Regular_11">find_used_and_updated</samp> must recognize
    that all the XMM registers are caller-saved and therefore updated by <samp class="SANS_TheSansMonoCd_W5Regular_11">Call</samp>
    instructions. Finally, this function will need to handle all the new assembly
    instructions we added in [Part II](part2.xhtml), but there’s nothing particularly
    tricky about them.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将更新 <samp class="SANS_TheSansMonoCd_W5Regular_11">find_used_and_updated</samp>
    辅助函数。首先，这个函数需要正确处理 <samp class="SANS_TheSansMonoCd_W5Regular_11">Memory</samp>
    和 <samp class="SANS_TheSansMonoCd_W5Regular_11">Indexed</samp> 操作数。这些操作数指定了内存中的位置，但它们在地址计算中使用了寄存器。当我们使用这些操作数时，即使我们是*写*入它指定的内存位置，我们也需要*读取*它所指向的任何寄存器。例如，指令
    <samp class="SANS_TheSansMonoCd_W5Regular_11">movl $1, 4(%rax)</samp> 使用 RAX 而不是更新它，而指令
    <samp class="SANS_TheSansMonoCd_W5Regular_11">leaq (%rax, %rcx, 4), %rdi</samp>
    使用了 RAX 和 RCX，但更新了 RDI。其次，<samp class="SANS_TheSansMonoCd_W5Regular_11">find_used_and_updated</samp>
    必须识别出所有 XMM 寄存器都是调用者保存的，因此会被 <samp class="SANS_TheSansMonoCd_W5Regular_11">Call</samp>
    指令更新。最后，这个函数还需要处理我们在[第二部分](part2.xhtml)中添加的所有新汇编指令，但它们没有什么特别复杂的。
- en: '#### <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Calculating
    Spill Costs</samp>'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: '#### <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">计算溢出代价</samp>'
- en: After constructing the graph, we annotate each register with a spill cost. If
    we can’t color every node in the graph, these costs will help us decide which
    node (or nodes) to spill. We’ll try to color the graph in a way that minimizes
    the total cost of all spilled nodes.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 在构建图之后，我们会给每个寄存器标注溢出代价。如果我们无法为图中的每个节点上色，这些代价将帮助我们决定应该溢出哪个节点（或哪些节点）。我们会尽量以最小化所有溢出节点的总代价的方式为图上色。
- en: Since we can’t spill hard registers, we assign each of them an infinite spill
    cost. To estimate the spill cost of each pseudoregister, we just count up the
    number of times it appears in our assembly code. For example, if we encounter
    the instruction <samp class="SANS_TheSansMonoCd_W5Regular_11">movl $1, %x</samp>,
    we increase <samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp>’s spill cost
    by one. If we see the instruction <samp class="SANS_TheSansMonoCd_W5Regular_11">addl
    %x, %x</samp>, we increase <samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp>’s
    spill cost by two. The rationale here is that the more often a pseudoregister
    is used, the more memory accesses and new instructions we’ll introduce if we spill
    it.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们不能溢出硬寄存器，因此我们为每个硬寄存器分配一个无限的溢出代价。为了估算每个伪寄存器的溢出代价，我们只需计算它在汇编代码中出现的次数。例如，如果我们遇到指令
    <samp class="SANS_TheSansMonoCd_W5Regular_11">movl $1, %x</samp>，我们就将 <samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp>
    的溢出代价增加一。如果我们看到指令 <samp class="SANS_TheSansMonoCd_W5Regular_11">addl %x, %x</samp>，我们就将
    <samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp> 的溢出代价增加二。其背后的原理是，伪寄存器使用得越频繁，如果我们溢出它，就会引入更多的内存访问和新的指令。
- en: Frankly, this is a lousy way to calculate spill cost. It ignores the basic fact
    that some instructions are executed more frequently than others. Clearly, using
    a pseudoregister inside a loop that executes a million times should increase its
    spill cost a lot more than using it in an instruction that runs just once. It’s
    hard to predict exactly how many times a particular instruction will execute,
    but one approach is to use loop nesting depth as a rough proxy for execution frequency.
    When compilers that take this approach calculate spill costs, they give more weight
    to instructions in more deeply nested loops.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 坦白说，这是一个糟糕的计算溢出代价的方法。它忽视了一个基本事实，即某些指令的执行频率比其他指令更高。显然，在执行一百万次的循环中使用伪寄存器，应该比在只执行一次的指令中使用它，增加更多的溢出代价。很难准确预测一个特定指令会执行多少次，但一种方法是将循环的嵌套深度作为执行频率的粗略代理。当采用这种方法的编译器计算溢出代价时，它们会给更深层嵌套的循环中的指令更多权重。
- en: Unfortunately, we have no idea where the loops in our program are. Discovering
    loops would require us to implement a whole new type of analysis, and this chapter
    is long enough. I’ve included a couple of references about identifying loops in
    “Additional Resources” on [page 669](#pg_669) in case you want to implement this
    analysis on your own.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，我们不知道程序中循环的位置。发现循环需要我们实现一种全新的分析方法，而本章内容已经够长了。如果你想自己实现这个分析方法，我在[第669页](#pg_669)的“附加资源”部分中列出了一些关于识别循环的参考资料。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Coloring the Interference
    Graph</samp>
  id: totrans-227
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">着色干扰图</samp>
- en: It’s time to color the graph! Our goal is to minimize the total spill cost of
    the nodes we leave uncolored (ideally by coloring every node so that the total
    spill cost is zero). But exact graph coloring algorithms, which find the best
    possible coloring, are too slow to use in practice. Instead, we’ll use an approximate
    algorithm. This algorithm may not find the best coloring, but it can usually find
    a pretty good one.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是时候给图着色了！我们的目标是最小化我们留白节点的总溢出成本（理想情况下通过着色每个节点，使得总溢出成本为零）。但是，精确的图着色算法能够找到最佳着色方案，但在实际中速度太慢。因此，我们将使用一种近似算法。这个算法可能无法找到最优着色，但通常能找到一个相当不错的着色方案。
- en: 'Our graph coloring algorithm is based on a simple observation: you can always
    color a node with fewer than *k* neighbors, because there’s always at least one
    color that none of its neighbors uses. This observation is called the *degree
    <* k *rule*. (The number of neighbors a node has is called its *degree*; we say
    that a node has *significant degree* if it has *k* or more neighbors.) The degree
    < *k* rule gives us a way to break down the problem. First, we’ll temporarily
    remove any node with fewer than *k* neighbors. This is called *pruning* the graph.
    Then, we’ll color the rest of the graph somehow (we won’t worry about how to do
    this just yet). Finally, we’ll put back the nodes that we pruned, one at a time.
    When we put back a node, we’ll assign it some color that doesn’t conflict with
    any neighbors that we’ve already colored. There will always be at least one available
    color, since each node has fewer than *k* neighbors.'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的图着色算法基于一个简单的观察：你总是可以给一个邻居少于*k*的节点着色，因为总会有一种颜色是它的邻居没有使用的。这个观察叫做*度数 <* k *规则*。（一个节点的邻居数量称为它的*度数*；如果一个节点有*k*个或更多邻居，我们称它具有*显著度数*。）度数
    < *k* 规则为我们提供了一种分解问题的方法。首先，我们将临时移除任何邻居少于*k*的节点，这叫做*修剪*图。然后，我们将以某种方式着色图的其余部分（我们暂时不关心如何做）。最后，我们会一个一个地将修剪掉的节点放回图中。当我们放回一个节点时，我们将为它分配一种与我们已经着色的邻居不冲突的颜色。由于每个节点的邻居少于*k*，总会有至少一种可用颜色。
- en: Let’s try to 3-color the graph shown in [Figure 20-7](#fig20-7) using this approach
    and see how far we get.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们尝试使用这种方法为[图20-7](#fig20-7)中的图进行三色着色，看看能达到什么程度。
- en: '![](../images/fig20-7.jpg)'
  id: totrans-231
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/fig20-7.jpg)'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 20-7: A graph that hasn’t
    been colored yet [Description](description-70.xhtml)</samp>'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">图20-7：尚未着色的图 [描述](description-70.xhtml)</samp>
- en: 'This graph has four nodes with fewer than three neighbors: *B*, *C*, *F*, and
    *H*. We’ll prune these nodes from the graph and then figure out how to color the
    smaller graph. We’ll also define a stack to keep track of the pruned nodes that
    we’ll eventually need to put back in the graph. [Figure 20-8](#fig20-8) shows
    the pruned graph and the stack.'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 这个图有四个邻居少于三个的节点：*B*、*C*、*F* 和 *H*。我们将从图中修剪这些节点，然后弄清楚如何着色这个较小的图。我们还将定义一个栈来跟踪被修剪的节点，这些节点最终需要重新放回图中。[图20-8](#fig20-8)显示了修剪后的图和栈。
- en: '![](../images/fig20-8.jpg)'
  id: totrans-234
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/fig20-8.jpg)'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 20-8: The graph from
    [Figure 20-7](#fig20-7) with low-degree nodes removed [Description](description-71.xhtml)</samp>'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">图20-8：从[图20-7](#fig20-7)中移除低度数节点后的图
    [描述](description-71.xhtml)</samp>
- en: In this pruned graph, *A* and *G* both have fewer than three neighbors. That
    means we can apply the same trick to prune the graph again! We’ll push *A* and
    *G* onto the top of the stack; later on, we’ll pop them off and color them before
    we color *B*, *C*, *F*, and *H*. When we pop *A* and *G* off the stack and put
    them back in the graph, they’ll have the same degree they do now, so we know we’ll
    be able to find a color for each of them.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个修剪后的图中，*A* 和 *G* 都有少于三个邻居。这意味着我们可以应用相同的技巧再次修剪图形！我们将把 *A* 和 *G* 推到栈顶；然后，我们将弹出它们并为它们上色，再为
    *B*、*C*、*F* 和 *H* 上色。当我们弹出 *A* 和 *G* 并将它们放回图中时，它们将保持当前的度数，所以我们知道我们可以为它们找到颜色。
- en: '[Figure 20-9](#fig20-9) shows how the graph and stack look after we prune *A*
    and *G*.'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 20-9](#fig20-9)展示了修剪 *A* 和 *G* 后图形和栈的状态。'
- en: '![](../images/fig20-9.jpg)'
  id: totrans-238
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/fig20-9.jpg)'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 20-9: The graph from
    [Figure 20-7](#fig20-7) after two rounds of pruning [Description](description-72.xhtml)</samp>'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">图 20-9：从[图 20-7](#fig20-7)修剪两轮后的图
    [描述](description-72.xhtml)</samp>
- en: 'Our two remaining nodes each have fewer than three neighbors, so we could just
    color them. But we’ll take a slightly different approach to accomplish the same
    thing: we’ll prune them from the graph, then put them back. After we prune them,
    the graph is empty. [Figure 20-10](#fig20-10) shows how things look after we’ve
    pruned every node.'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 我们剩下的两个节点每个的邻居少于三个，因此我们可以直接为它们上色。但是，我们会采取稍微不同的方法来完成同样的任务：我们将从图中修剪它们，然后再把它们放回去。修剪后，图形为空。[图
    20-10](#fig20-10)展示了修剪每个节点后的图形状态。
- en: '![](../images/fig20-10.jpg)'
  id: totrans-241
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/fig20-10.jpg)'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 20-10: The graph from
    [Figure 20-7](#fig20-7) after pruning every node [Description](description-73.xhtml)</samp>'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">图 20-10：从[图 20-7](#fig20-7)修剪每个节点后的图
    [描述](description-73.xhtml)</samp>
- en: 'Our original plan was to prune the graph, color the remaining nodes, then put
    back the nodes we had pruned. Now that we’re done pruning, we don’t have to do
    anything for the second step: there are no nodes left to color! We won’t get this
    lucky with every graph; sometimes we’ll end up with nodes we can’t prune. We’ll
    talk about how to handle that situation in a moment. For now, let’s finish coloring
    this graph.'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的原计划是修剪图形，为剩下的节点上色，然后把修剪的节点放回。现在，修剪工作已经完成，我们不需要做第二步：没有剩下的节点需要上色！我们并不是每次都能这么幸运；有时我们会遇到无法修剪的节点。稍后我们会讨论如何处理这种情况。现在，让我们完成图形的上色。
- en: As the last step in our plan, we’ll take each of the nodes we pruned earlier,
    assign it a color, and put it back in the graph. We’ll start with the last node
    we removed, which is at the top of the stack, then repeat this process until the
    stack is empty. The sequence of diagrams in [Figure 20-11](#fig20-11) illustrates
    how we’ll rebuild the graph in this example.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 作为我们计划的最后一步，我们将取回之前修剪的每个节点，为它分配颜色，然后将它放回图中。我们从最后一个被移除的节点开始，它在栈顶，然后重复此过程直到栈为空。[图
    20-11](#fig20-11)中的图示展示了我们在这个例子中如何重建图形。
- en: '![](../images/fig20-11.jpg)'
  id: totrans-245
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/fig20-11.jpg)'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 20-11: Adding nodes
    back to the graph and assigning colors [Description](description-74.xhtml)</samp>'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">图 20-11：将节点添加回图中并分配颜色 [描述](description-74.xhtml)</samp>
- en: When we add *E* back to the graph, it has no neighbors, so we can assign it
    any color. Let’s color it white. Then, when we add *D*, its only neighbor is *E*,
    so we can assign it either black or gray. When we add *G*, we find that it has
    a white neighbor and a gray neighbor, so we must color it black. We continue until
    the stack is empty and every node in the graph has been assigned a color.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们将 *E* 加回图中时，它没有邻居，因此我们可以为它分配任何颜色。我们将它涂成白色。然后，当我们添加 *D* 时，它唯一的邻居是 *E*，所以我们可以为它分配黑色或灰色。当我们添加
    *G* 时，我们发现它有一个白色邻居和一个灰色邻居，因此我们必须将它涂成黑色。我们继续这个过程，直到栈为空，图中的每个节点都被分配了颜色。
- en: '##### <samp class="SANS_Futura_Std_Bold_Condensed_B_11">Dealing with Spills</samp>'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: '##### <samp class="SANS_Futura_Std_Bold_Condensed_B_11">处理溢出</samp>'
- en: 'For many interference graphs, we can prune every node using the approach we
    took in the previous section. We can color those graphs without any spills. But
    there are other graphs where we’ll get stuck: we’ll hit a point where every node
    has *k* or more neighbors. Suppose we want to 3-color the graph shown in [Figure
    20-12](#fig20-12).'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 对于许多干扰图，我们可以使用上一节中的方法修剪每个节点。我们可以为这些图着色而不发生溢出。但也有其他图，我们会陷入困境：我们会遇到一个每个节点都有*k*个或更多邻居的情况。假设我们想为[图20-12](#fig20-12)着色。
- en: '![](../images/fig20-12.jpg)'
  id: totrans-250
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/fig20-12.jpg)'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 20-12: A graph where
    every node has three or more neighbors [Description](description-75.xhtml)</samp>'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">图20-12：每个节点有三个或更多邻居的图 [描述](description-75.xhtml)</samp>
- en: 'If we try to prune this graph, we’ll immediately get stuck: every node has
    at least three neighbors! To get unstuck, we’ll choose a node to prune anyway.
    We’ll put this node on the stack, then continue with the algorithm as usual. This
    node is a *spill candidate* because we might not be able to color it when we put
    it back in the graph. If we’re lucky, its neighbors won’t use up every color,
    so we’ll be able to color it. If we’re unlucky, its neighbors will use all *k*
    colors, so we’ll have to spill it.'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们尝试修剪这个图，我们将立即陷入困境：每个节点至少有三个邻居！为了摆脱困境，我们无论如何都会选择一个节点进行修剪。我们将把这个节点放入堆栈中，然后照常继续算法。这个节点是一个*溢出候选项*，因为当我们将它重新加入图中时，可能无法为它着色。如果运气好，它的邻居不会用尽所有颜色，那么我们就能为它着色。如果运气不好，它的邻居会用尽所有*k*种颜色，那么我们就不得不溢出它。
- en: We want to choose a spill candidate with a low spill cost. But we also want
    to choose a spill candidate with lots of neighbors that haven’t been pruned yet,
    because pruning our spill candidate lowers its neighbors’ degrees and helps us
    avoid spilling them later on. To balance these two priorities, we’ll choose the
    node with the smallest value of *spill cost / degree*, where degree is the number
    of neighbors that haven’t been pruned yet.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望选择一个溢出成本较低的溢出候选项。但我们也希望选择一个邻居较多且尚未被修剪的溢出候选项，因为修剪我们的溢出候选项会降低其邻居的度数，并帮助我们避免稍后溢出它们。为了平衡这两者的优先级，我们将选择*溢出成本
    / 度数*值最小的节点，其中度数是尚未被修剪的邻居的数量。
- en: Note that we’ll never choose a hard register as a spill candidate, because *spill
    cost / degree* for each of these registers is always infinity. If there are any
    pseudoregisters left in the graph, we’ll always choose one of them as a spill
    candidate instead of choosing a hard register. If there are no pseudoregisters
    left, the total number of registers must be *k* or fewer, so we’ll be able to
    prune every register.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们永远不会选择硬寄存器作为溢出候选项，因为这些寄存器的*溢出成本 / 度数*总是无限大。如果图中还有伪寄存器，我们将始终选择其中一个作为溢出候选项，而不是选择硬寄存器。如果没有剩余的伪寄存器，寄存器的总数必须是*k*个或更少，因此我们将能够修剪每个寄存器。
- en: Some graphs have no valid *k*-colorings, which makes spilling unavoidable. For
    other graphs, a valid coloring exists, but whether we find it is a matter of chance;
    it depends on the exact order in which we remove nodes from the graph and how
    we happen to color them when we put them back.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 有些图没有有效的*k*着色，这使得溢出成为不可避免的。对于其他图，存在有效的着色，但我们是否能找到它取决于运气；它取决于我们从图中删除节点的精确顺序，以及我们在将它们重新加入时如何着色它们。
- en: 'To illustrate the element of chance in this approach, we’ll make a couple of
    attempts to color the graph in [Figure 20-12](#fig20-12). This graph is 3-colorable,
    but only one of our attempts will find a spill-free coloring. In both cases, we’ll
    choose *C* as our spill candidate, then prune *A* and *B*, leaving *D*, *E*, and
    *F*. And in both cases, we’ll use the same strategy to color nodes as we add them
    back into the graph: we’ll choose the first available color from the list *[white,
    gray, black]*. The only difference will be the order in which we prune the remaining
    three nodes. In the first case, we’ll prune *D*, then *E*, then *F*. [Figure 20-13](#fig20-13)
    shows what will happen when we try to add the nodes back in.'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 为了说明这种方法中的偶然性，我们将尝试几次为[图20-12](#fig20-12)着色。这个图是可以进行3着色的，但我们只有一次尝试会找到一个无溢出的着色。在这两种情况下，我们都将选择*C*作为溢出候选项，然后修剪*A*和*B*，留下*D*、*E*和*F*。在这两种情况下，我们都将使用相同的策略为节点着色，当我们将它们重新加入图中时：我们将从颜色列表*[白色、灰色、黑色]*中选择第一个可用的颜色。唯一的区别是我们修剪其余三个节点的顺序。在第一种情况下，我们将先修剪*D*，然后是*E*，最后是*F*。[图20-13](#fig20-13)显示了当我们尝试将节点重新加入时会发生什么。
- en: '![](../images/fig20-13.jpg)'
  id: totrans-257
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/fig20-13.jpg)'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 20-13: A first attempt
    to color [Figure 20-12](#fig20-12) [Description](description-76.xhtml)</samp>'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">图 20-13：第一次尝试为[图 20-12](#fig20-12)上色
    [描述](description-76.xhtml)</samp>
- en: When we reach *C*, we’ll see that its neighbors are already using all three
    colors, so we’ll be forced to spill it.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们到达*C*时，我们会发现它的邻居已经使用了所有三种颜色，因此我们将被迫进行溢出。
- en: Now let’s repeat this process; on this attempt, we’ll prune *F*, then *E*, then
    *D*. [Figure 20-14](#fig20-14) shows what will happen when we put the nodes back
    in the graph this time around.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们重复这个过程；这次我们将修剪*F*，然后是*E*，再然后是*D*。[图 20-14](#fig20-14)展示了当我们将节点重新放回图中时会发生什么。
- en: '![](../images/fig20-14.jpg)'
  id: totrans-261
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/fig20-14.jpg)'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 20-14: A more successful
    attempt to color [Figure 20-12](#fig20-12) [Description](description-77.xhtml)</samp>'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">图 20-14：第二次尝试为[图 20-12](#fig20-12)上色
    [描述](description-77.xhtml)</samp>
- en: This time, we assigned *A* and *E* the same color, which allowed us to assign
    *C* a color instead of spilling it. In a small example like this one, it’s easy
    to see that assigning these nodes the same color is the better choice. But there’s
    no general rule that lets us avoid unnecessary spills like the one in [Figure
    20-13](#fig20-13); that’s what makes this algorithm approximate. We *could* avoid
    unnecessary spills if we used an exact algorithm instead, but as I mentioned earlier,
    exact algorithms are too expensive to be practical.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 这次，我们给*A*和*E*分配了相同的颜色，这使我们能够为*C*分配颜色，而不是溢出它。在像这样的简单例子中，我们很容易看到给这些节点分配相同颜色是更好的选择。但没有通用的规则可以让我们避免像[图
    20-13](#fig20-13)中那样不必要的溢出；这就是这个算法近似的原因。如果我们使用精确算法，我们*可以*避免不必要的溢出，但正如我之前提到的，精确算法的成本太高，无法实际应用。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">Implementing the Graph Coloring
    Algorithm</samp>
  id: totrans-264
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">实现图着色算法</samp>
- en: Now that we’ve worked through a few examples using this algorithm, let’s look
    at the pseudocode, which is shown in [Listing 20-24](chapter20.xhtml#list20-24).
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经通过一些例子使用了这个算法，接下来让我们看一下伪代码，伪代码显示在[列表 20-24](chapter20.xhtml#list20-24)中。
- en: '[PRE27]'
  id: totrans-266
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 20-24: The graph coloring
    algorithm</samp>'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">列表 20-24：图着色算法</samp>
- en: We’ll color the graph recursively. At each step, we’ll prune a node, then make
    a recursive call to color the rest of the graph, then put the node back and assign
    it a color. In the base case, we’ve already pruned every node, so we have nothing
    left to do ❶.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将递归地为图着色。在每一步中，我们将修剪一个节点，然后递归调用着色剩余的图，再把该节点放回并为其分配一个颜色。在基本情况下，我们已经修剪了所有节点，因此没有任何事情可做❶。
- en: In the recursive case, we’ll start by choosing a node to prune, which this listing
    calls <samp class="SANS_TheSansMonoCd_W5Regular_11">chosen_node</samp>. We’ll
    pick the first node we find with fewer than *k* unpruned neighbors ❷. (If you’re
    allocating general-purpose registers, *k* is 12; if you’re allocating XMM registers,
    it’s 14.) If that search comes up empty, we’ll pick the node with the minimum
    value of *spill cost / degree* ❸. To prune a node, we’ll just set its <samp class="SANS_TheSansMonoCd_W5Regular_11">pruned</samp>
    attribute to <samp class="SANS_TheSansMonoCd_W5Regular_11">True</samp>. Then,
    we’ll call <samp class="SANS_TheSansMonoCd_W5Regular_11">color_graph</samp> recursively
    to color the remaining nodes in the graph ❹.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 在递归情况下，我们首先选择一个节点进行修剪，这个列表中将其称为<samp class="SANS_TheSansMonoCd_W5Regular_11">chosen_node</samp>。我们将选择第一个找到的、未修剪邻居数量少于*k*的节点❷。（如果你分配的是通用寄存器，*k*是12；如果分配的是XMM寄存器，*k*是14。）如果搜索结果为空，我们将选择具有最小*溢出成本/度数*值的节点❸。要修剪一个节点，我们只需要将它的<samp
    class="SANS_TheSansMonoCd_W5Regular_11">pruned</samp>属性设置为<samp class="SANS_TheSansMonoCd_W5Regular_11">True</samp>。然后，我们将递归调用<samp
    class="SANS_TheSansMonoCd_W5Regular_11">color_graph</samp>来给图中的剩余节点着色❹。
- en: After we return from this recursive call, we’ll try to assign <samp class="SANS_TheSansMonoCd_W5Regular_11">chosen_node</samp>
    a color. We’ll take the list of integers <samp class="SANS_TheSansMonoCd_W5Regular_11">1</samp>
    through <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">k</samp>, which
    represent every possible color, and remove any color that we’ve already assigned
    to one of <samp class="SANS_TheSansMonoCd_W5Regular_11">chosen _node</samp>’s
    neighbors. Some of <samp class="SANS_TheSansMonoCd_W5Regular_11">chosen_node</samp>’s
    neighbors may not have a color, either because we spilled them or because we pruned
    them before <samp class="SANS_TheSansMonoCd_W5Regular_11">chosen _node</samp>
    and will therefore color them later. We can simply ignore these nodes.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 在从递归调用返回后，我们将尝试为<samp class="SANS_TheSansMonoCd_W5Regular_11">chosen_node</samp>分配颜色。我们将取出整数列表<samp
    class="SANS_TheSansMonoCd_W5Regular_11">1</samp>到<samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">k</samp>，它们表示所有可能的颜色，并移除我们已经分配给<samp
    class="SANS_TheSansMonoCd_W5Regular_11">chosen_node</samp>的邻居节点的颜色。<samp class="SANS_TheSansMonoCd_W5Regular_11">chosen_node</samp>的某些邻居可能没有颜色，要么是因为我们将它们溢出，要么是因为在<samp
    class="SANS_TheSansMonoCd_W5Regular_11">chosen_node</samp>之前我们就已经修剪了它们，因此我们将稍后为它们着色。我们可以忽略这些节点。
- en: 'If there are any colors left in the list, we’ll assign one of them to <samp
    class="SANS_TheSansMonoCd_W5Regular_11">chosen _node</samp> ❺. If there’s more
    than one color available, the algorithm isn’t fussy about which one we choose.
    Although the color we choose here might impact how many nodes we ultimately spill,
    the effect is unpredictable; there’s no color selection strategy that minimizes
    spills across the board. So, we’ll choose a color with a different goal in mind:
    assigning pseudoregisters to caller-saved rather than callee-saved hard registers.
    (We’d like to use as few callee-saved registers as possible, to avoid the cost
    of saving and restoring them.) When <samp class="SANS_TheSansMonoCd_W5Regular_11">chosen_node</samp>
    represents a callee-saved hard register, we’ll assign it the available color with
    the highest number. Otherwise, we assign it the lowest-numbered available color.
    Using this strategy, the coloring algorithm will tend to assign higher-numbered
    colors to callee-saved registers and lower-numbered colors to caller-saved registers
    and pseudoregisters. A pseudoregister will end up with a higher-numbered color
    only when there are no lower-numbered colors available (for example, because it
    conflicts with every caller-saved register). Once we’ve picked a color, we set
    the <samp class="SANS_TheSansMonoCd_W5Regular_11">pruned</samp> attribute back
    to <samp class="SANS_TheSansMonoCd_W5Regular_11">False</samp>. This isn’t strictly
    necessary, because we won’t use this attribute again, but it marks that we’ve
    put the node back in the graph.'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 如果列表中还有剩余的颜色，我们将为<samp class="SANS_TheSansMonoCd_W5Regular_11">chosen_node</samp>
    ❺分配其中一种颜色。如果有多种颜色可用，算法并不挑剔我们选择哪一种。尽管我们选择的颜色可能会影响最终溢出的节点数量，但这种影响是不可预测的；没有一种颜色选择策略能够在所有情况下最小化溢出。因此，我们将选择一种具有不同目标的颜色：将伪寄存器分配给调用者保存的硬寄存器，而不是被调用者保存的硬寄存器。（我们希望尽量少使用被调用者保存的寄存器，以避免保存和恢复它们的成本。）当<samp
    class="SANS_TheSansMonoCd_W5Regular_11">chosen_node</samp>代表一个被调用者保存的硬寄存器时，我们将为它分配可用的最高编号的颜色。否则，我们将为它分配最低编号的可用颜色。通过这种策略，着色算法倾向于将更高编号的颜色分配给被调用者保存的寄存器，将较低编号的颜色分配给调用者保存的寄存器和伪寄存器。只有当没有较低编号的颜色可用时（例如，因与每个调用者保存的寄存器冲突），伪寄存器才会得到更高编号的颜色。一旦我们选择了颜色，就将<samp
    class="SANS_TheSansMonoCd_W5Regular_11">pruned</samp>属性设置回<samp class="SANS_TheSansMonoCd_W5Regular_11">False</samp>。虽然这不是绝对必要的，因为我们之后不会再使用这个属性，但它标记着我们已经将节点重新放回了图中。
- en: If there are no colors left in the list, we’ll have to spill <samp class="SANS_TheSansMonoCd_W5Regular_11">chosen_node</samp>.
    Concretely, this just means we won’t assign it a color. We also won’t update its
    <samp class="SANS_TheSansMonoCd_W5Regular_11">pruned</samp> attribute, since we
    aren’t putting this node back in the graph. Note that we don’t explicitly push
    nodes onto a stack or pop them off afterward. Our recursive algorithm naturally
    colors nodes in the correct order, starting with the last node we pruned.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 如果列表中没有剩余的颜色，我们就得溢出<samp class="SANS_TheSansMonoCd_W5Regular_11">chosen_node</samp>。具体来说，这意味着我们不会为它分配颜色。我们也不会更新它的<samp
    class="SANS_TheSansMonoCd_W5Regular_11">pruned</samp>属性，因为我们不会把这个节点重新放回图中。请注意，我们并不会显式地将节点推入栈中或之后弹出它们。我们的递归算法自然地按照正确的顺序为节点着色，从我们修剪的最后一个节点开始。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Building the Register
    Map and Rewriting the Function Body</samp>
  id: totrans-273
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">构建寄存器映射并重写函数体</samp>
- en: Once we’ve colored the graph, the rest of the register allocator is pretty simple.
    We’ll build a map from pseudoregisters to hard registers, which we’ll use to replace
    the pseudoregisters in our assembly code. As we build this map, we’ll also keep
    track of which callee-saved registers we’ve allocated so that we can save and
    restore them in the instruction fix-up pass. [Listing 20-25](chapter20.xhtml#list20-25)
    demonstrates how to construct the map.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们给图着色，剩下的寄存器分配过程就相对简单了。我们将构建一个从伪寄存器到硬寄存器的映射，利用这个映射来替换汇编代码中的伪寄存器。在构建这个映射的过程中，我们还将追踪已分配的被调用者保存寄存器，以便在指令修正阶段保存和恢复它们。[Listing
    20-25](chapter20.xhtml#list20-25)展示了如何构建这个映射。
- en: '[PRE28]'
  id: totrans-275
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 20-25: Building a map
    from pseudoregisters to hard registers</samp>'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 20-25: 从伪寄存器到硬寄存器构建映射</samp>'
- en: First, we’ll iterate through the hard registers in the graph, building up a
    map from colors to hard registers. Remember that we’ll have a 1:1 mapping between
    colors and hard registers because each of the *k* hard registers must be assigned
    a different one of the *k* possible colors. Next, we’ll iterate through all the
    pseudoregisters. If a pseudoregister was assigned a color, we’ll map it to the
    hard register with the same color, which we can find in <samp class="SANS_TheSansMonoCd_W5Regular_11">color_map</samp>
    ❶. If a pseudoregister wasn’t assigned a color, we won’t add it to the map.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将遍历图中的硬寄存器，构建一个从颜色到硬寄存器的映射。请记住，我们将实现颜色和硬寄存器之间的1:1映射，因为每个*k*硬寄存器必须分配给*k*个可能颜色中的一个。接下来，我们将遍历所有的伪寄存器。如果一个伪寄存器被分配了颜色，我们将把它映射到与该颜色相同的硬寄存器，这可以在<samp
    class="SANS_TheSansMonoCd_W5Regular_11">color_map</samp>中找到❶。如果一个伪寄存器没有被分配颜色，我们将不会将其添加到映射中。
- en: As we build up <samp class="SANS_TheSansMonoCd_W5Regular_11">register_map</samp>,
    we also track the set of callee-saved registers this function will use. Whenever
    we add a mapping from a pseudoregister to a callee-saved hard register, we’ll
    add the hard register to this set ❷. We’ll record each function’s <samp class="SANS_TheSansMonoCd_W5Regular_11">callee_saved_regs</samp>
    set so that we can pass that information on to the instruction fix-up phase ❸.
    (This listing doesn’t specify *where* to record that information; you can add
    it to the function definition itself, the backend symbol table, or some other
    data structure, depending on what’s most convenient.) We can skip this step when
    we allocate XMM registers, because none of the XMM registers are callee-saved.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 在构建<samp class="SANS_TheSansMonoCd_W5Regular_11">register_map</samp>的同时，我们还会跟踪该函数将使用的被调用者保存寄存器的集合。每当我们添加一个从伪寄存器到被调用者保存硬寄存器的映射时，我们就会将该硬寄存器添加到这个集合中❷。我们会记录每个函数的<samp
    class="SANS_TheSansMonoCd_W5Regular_11">callee_saved_regs</samp>集合，以便将这些信息传递给指令修正阶段❸。（这个列表没有指定*在哪*记录这些信息；你可以将其添加到函数定义本身、后端符号表或其他数据结构中，具体取决于最方便的方式。）当我们分配XMM寄存器时可以跳过此步骤，因为XMM寄存器没有被调用者保存。
- en: Finally, we’ll rewrite the assembly code. We’ll replace each pseudoregister
    in each instruction with the corresponding hard register from the register map.
    If a pseudoregister is missing from the map, we won’t replace it. While we’re
    at it, we’ll remove any <samp class="SANS_TheSansMonoCd_W5Regular_11">mov</samp>
    instruction whose source and destination ended up in the same hard register. For
    instance, if we’ve mapped both <samp class="SANS_TheSansMonoCd_W5Regular_11">tmp1</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">tmp2</samp> to EAX, we can rewrite
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将重写汇编代码。我们将用寄存器映射中的相应硬寄存器替换每条指令中的每个伪寄存器。如果某个伪寄存器不在映射中，我们将不替换它。同时，我们将删除任何源和目标寄存器相同的<samp
    class="SANS_TheSansMonoCd_W5Regular_11">mov</samp>指令。例如，如果我们已经将<samp class="SANS_TheSansMonoCd_W5Regular_11">tmp1</samp>和<samp
    class="SANS_TheSansMonoCd_W5Regular_11">tmp2</samp>都映射到EAX，我们可以重写
- en: '[PRE29]'
  id: totrans-280
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'as:'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 如下所示：
- en: '[PRE30]'
  id: totrans-282
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Both ❶ and ❷ would be rewritten as <samp class="SANS_TheSansMonoCd_W5Regular_11">movl
    %eax, %eax</samp>, which doesn’t do anything, so we can drop them both from the
    final assembly program.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: ❶和❷都将被重写为<samp class="SANS_TheSansMonoCd_W5Regular_11">movl %eax, %eax</samp>，这并不会做任何事情，因此我们可以将它们从最终的汇编程序中删除。
- en: This bit of cleanup where we delete unnecessary <samp class="SANS_TheSansMonoCd_W5Regular_11">mov</samp>
    instructions is related to register coalescing, which we’ll implement later in
    this chapter. But there are some important differences. The register coalescing
    step will deliberately merge together registers connected by a <samp class="SANS_TheSansMonoCd_W5Regular_11">mov</samp>,
    like <samp class="SANS_TheSansMonoCd_W5Regular_11">tmp1</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">tmp2</samp>,
    then delete the <samp class="SANS_TheSansMonoCd_W5Regular_11">mov</samp> instructions
    between them. This whole process will happen before we color the rest of the graph.
    What we’re doing here is much simpler; we’re not trying to merge registers, but
    if we happen to assign both operands of a <samp class="SANS_TheSansMonoCd_W5Regular_11">mov</samp>
    instruction the same color, we’ll take advantage of it.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 这个清理步骤是删除不必要的<code>mov</code>指令，它与寄存器合并相关，我们将在本章后面实现。但有一些重要的不同之处。寄存器合并步骤会故意合并通过<code>mov</code>连接的寄存器，例如<code>tmp1</code>和<code>tmp2</code>，然后删除它们之间的<code>mov</code>指令。这个过程会在我们着色图形之前完成。而我们在这里做的要简单得多；我们并不是试图合并寄存器，而是如果我们恰好将<code>mov</code>指令的两个操作数分配了相同的颜色，我们会利用这一点。
- en: Even once we implement register coalescing, this post-coloring cleanup will
    still be useful. As we’ll see, the register coalescing pass isn’t perfect; sometimes
    it will miss a pair of registers that it would have been helpful to coalesce.
    If we get lucky and assign that pair of registers the same color, this final step
    will still be able to delete <samp class="SANS_TheSansMonoCd_W5Regular_11">mov</samp>
    instructions between them.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 即使我们实现了寄存器合并，这个着色后清理步骤仍然是有用的。正如我们将看到的，寄存器合并过程并不完美；有时它会遗漏一对寄存器，这对寄存器如果合并的话会非常有帮助。如果我们足够幸运，给那对寄存器分配相同的颜色，那么这个最后的步骤仍然能够删除它们之间的<code>mov</code>指令。
- en: At this point, we have a working register allocator! We just need to update
    the instruction fix-up and code emission passes before we test it out.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 到此为止，我们已经有了一个工作的寄存器分配器！我们只需要更新指令修复和代码生成过程，然后就可以进行测试。
- en: <samp class="SANS_Futura_Std_Bold_B_11">Instruction Fix-Up with Callee-Saved
    Registers</samp>
  id: totrans-287
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <b>使用被调用者保存的寄存器修复指令</b>
- en: 'If a function uses any callee-saved registers, we need to save their values
    at the start of the function and restore them at the end. We’ll save them by pushing
    them onto the stack on top of the rest of the current stack frame. For example,
    if a function needs 16 bytes of stack space for local variables and uses R12 and
    R13, we’ll insert the following three instructions at the very beginning of the
    function body:'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一个函数使用了任何被调用者保存的寄存器，我们需要在函数开始时保存它们的值，并在结束时恢复它们。我们通过将它们推入栈中，放在当前栈帧的其余部分之上来保存它们。例如，如果一个函数需要16个字节的栈空间用于局部变量，并且使用了R12和R13寄存器，我们将在函数体的最开始插入以下三条指令：
- en: '[PRE31]'
  id: totrans-289
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: The initial <samp class="SANS_TheSansMonoCd_W5Regular_11">Sub</samp> instruction
    allocates the current stack frame, just like in earlier chapters. The new <samp
    class="SANS_TheSansMonoCd_W5Regular_11">Push</samp> instructions come immediately
    after it. (If you skipped [Part II](part2.xhtml), the first instruction will be
    <samp class="SANS_TheSansMonoCd_W5Regular_11">AllocateStack</samp> rather than
    <samp class="SANS_TheSansMonoCd_W5Regular_11">Sub</samp>.)
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 初始的<code>Sub</code>指令分配当前的栈帧，就像前面的章节中一样。新的<code>Push</code>指令紧接在其后。（如果你跳过了[第二部分](part2.xhtml)，第一条指令将是<code>AllocateStack</code>，而不是<code>Sub</code>。）
- en: 'Before we return, we’ll restore the values of these registers by popping them
    off the stack. That is, we’ll rewrite each <samp class="SANS_TheSansMonoCd_W5Regular_11">Ret</samp>
    instruction in this function as:'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们返回之前，我们通过将这些寄存器的值从栈中弹出，恢复它们的值。也就是说，我们会将此函数中的每条<code>Ret</code>指令重写为：
- en: '[PRE32]'
  id: totrans-292
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'We can push callee-saved registers onto the stack in any order, but we’ll always
    need to pop them back off in the reverse order so that each register ends up with
    its original value. Since we add the rest of the function epilogue during code
    emission, we’ll end up deallocating the stack frame just after restoring the callee-saved
    registers:'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将被调用方保存的寄存器以任意顺序压入栈中，但我们始终需要以相反的顺序将其弹出，以确保每个寄存器恢复到其原始值。由于我们在代码生成过程中会添加函数尾部，我们将在恢复被调用方保存的寄存器后立即解除栈帧的分配：
- en: '[PRE33]'
  id: totrans-294
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'We also need to ensure that the entire stack frame, including the values of
    any callee-saved registers that we save to the stack, is 16-byte aligned. Suppose
    the pseudo-operand replacement pass has allocated 20 bytes of stack space to store
    local variables in a particular function. We’d normally subtract 32 bytes from
    RSP to maintain the proper stack alignment. But if the function uses a single
    callee-saved register, we should initially subtract 24 bytes instead:'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要确保整个栈帧，包括我们保存到栈中的任何被调用方保存的寄存器的值，都保持16字节对齐。假设伪操作数替换阶段为特定函数分配了20字节的栈空间以存储局部变量。我们通常会从RSP减去32字节来保持正确的栈对齐。但是，如果该函数使用了单个被调用方保存的寄存器，我们应当首先从RSP减去24字节：
- en: '[PRE34]'
  id: totrans-296
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: If we subtract 24 bytes from RSP explicitly and subtract another 8 bytes by
    pushing RBX, we still end up subtracting a total of 32 bytes, so the stack will
    be properly aligned. [Listing 20-26](chapter20.xhtml#list20-26) demonstrates one
    way to perform this tricky calculation.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们明确地从RSP减去24字节，再通过推送RBX再减去8字节，我们最终会总共减去32字节，因此栈会保持正确对齐。[清单20-26](chapter20.xhtml#list20-26)演示了执行此复杂计算的一种方法。
- en: '[PRE35]'
  id: totrans-298
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 20-26: The stack space
    calculation that accounts for callee-saved registers</samp>'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">清单20-26：考虑到被调用方保存寄存器的栈空间计算</samp>
- en: In this listing, <samp class="SANS_TheSansMonoCd_W5Regular_11">bytes_for_locals</samp>
    is the number of bytes of stack space we allocated during pseudo-operand replacement,
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">callee_saved_count</samp> is
    the number of callee-saved registers the function uses. We start by calculating
    how many bytes the callee-saved values will occupy. Then, we add this to <samp
    class="SANS_TheSansMonoCd_W5Regular_11">bytes_for_locals</samp> and round up to
    the nearest multiple of 16 to get the total size of the stack frame ❶. Working
    backward from this value, we subtract the number of bytes the callee-saved values
    will occupy to find the number of bytes we need to explicitly subtract from RSP
    ❷.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 在此清单中，<samp class="SANS_TheSansMonoCd_W5Regular_11">bytes_for_locals</samp>是我们在伪操作数替换过程中分配的栈空间字节数，<samp
    class="SANS_TheSansMonoCd_W5Regular_11">callee_saved_count</samp>是该函数使用的被调用方保存寄存器的数量。我们首先计算被调用方保存的值占用的字节数。然后，我们将这个值加到<samp
    class="SANS_TheSansMonoCd_W5Regular_11">bytes_for_locals</samp>中，并四舍五入到最接近的16字节的倍数，以获得栈帧的总大小❶。从这个值向回计算，我们减去被调用方保存的值占用的字节数，从而得出我们需要明确从RSP中减去的字节数❷。
- en: <samp class="SANS_Futura_Std_Bold_B_11">Code Emission</samp>
  id: totrans-301
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">代码生成</samp>
- en: 'Finally, we’ll update the code emission pass to handle the <samp class="SANS_TheSansMonoCd_W5Regular_11">pop</samp>
    instruction and all the new registers we added in this chapter. Like <samp class="SANS_TheSansMonoCd_W5Regular_11">push</samp>,
    <samp class="SANS_TheSansMonoCd_W5Regular_11">pop</samp> will always use the 8-byte
    names for registers. [Tables 20-4](chapter20.xhtml#tab20-4) and [20-5](chapter20.xhtml#tab20-5)
    describe how to print out these constructs. (I haven’t bolded new and changed
    constructs like I did in most code emission tables in earlier chapters, because
    all of these constructs are new.) For a summary of the complete code emission
    pass at the end of this chapter, see [Appendix B](appendix-B.xhtml), which includes
    two sets of code emission tables for [Part III](part3.xhtml): one with the features
    from [Part II](part2.xhtml) and one without them.'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将更新代码生成阶段，以处理<sam class="SANS_TheSansMonoCd_W5Regular_11">pop</samp>指令和我们在本章中添加的所有新寄存器。像<samp
    class="SANS_TheSansMonoCd_W5Regular_11">push</samp>一样，<samp class="SANS_TheSansMonoCd_W5Regular_11">pop</samp>将始终使用8字节名称来表示寄存器。[表20-4](chapter20.xhtml#tab20-4)和[表20-5](chapter20.xhtml#tab20-5)描述了如何输出这些结构。（与早期章节中的大多数代码生成表格不同，我没有加粗新添加和改变的结构，因为这些结构都是新的。）有关本章末尾完整代码生成过程的总结，请参见[附录B](appendix-B.xhtml)，其中包括两组代码生成表格，用于[第三部分](part3.xhtml)：一组包含[第二部分](part2.xhtml)的特性，另一组则不包含。
- en: <samp class="SANS_Futura_Std_Heavy_B_11">Table 20-4:</samp> <samp class="SANS_Futura_Std_Book_11">Formatting
    Assembly Instructions</samp>
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Heavy_B_11">表格 20-4：</samp> <samp class="SANS_Futura_Std_Book_11">格式化汇编指令</samp>
- en: '| <samp class="SANS_Futura_Std_Heavy_B_11">Assembly instruction</samp> | <samp
    class="SANS_Futura_Std_Heavy_B_11">Output</samp> |'
  id: totrans-304
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_Futura_Std_Heavy_B_11">汇编指令</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">输出</samp>
    |'
- en: '| --- | --- |'
  id: totrans-305
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">Pop(reg)</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">popq</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11"><reg></samp> |'
  id: totrans-306
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">弹出(寄存器)</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">popq</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11"><reg></samp> |'
- en: <samp class="SANS_Futura_Std_Heavy_B_11">Table 20-5:</samp> <samp class="SANS_Futura_Std_Book_11">Formatting
    Assembly Operands</samp>
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Heavy_B_11">表格 20-5：</samp> <samp class="SANS_Futura_Std_Book_11">格式化汇编操作数</samp>
- en: '| <samp class="SANS_Futura_Std_Heavy_B_11">Assembly operand</samp> |  | <samp
    class="SANS_Futura_Std_Heavy_B_11">Output</samp> |'
  id: totrans-308
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_Futura_Std_Heavy_B_11">汇编操作数</samp> |  | <samp class="SANS_Futura_Std_Heavy_B_11">输出</samp>
    |'
- en: '| --- | --- | --- |'
  id: totrans-309
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">Reg(BX)</samp> | <samp class="SANS_Futura_Std_Book_11">8-byte</samp>
    | <samp class="SANS_TheSansMonoCd_W5Regular_11">%rbx</samp> |'
  id: totrans-310
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">寄存器(BX)</samp> | <samp class="SANS_Futura_Std_Book_11">8字节</samp>
    | <samp class="SANS_TheSansMonoCd_W5Regular_11">%rbx</samp> |'
- en: '| <samp class="SANS_Futura_Std_Book_11">4-byte</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">%ebx</samp>
    |'
  id: totrans-311
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_Futura_Std_Book_11">4字节</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">%ebx</samp>
    |'
- en: '| <samp class="SANS_Futura_Std_Book_11">1-byte</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">%bl</samp>
    |'
  id: totrans-312
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_Futura_Std_Book_11">1字节</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">%bl</samp>
    |'
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">Reg(R12)</samp> | <samp class="SANS_Futura_Std_Book_11">8-byte</samp>
    | <samp class="SANS_TheSansMonoCd_W5Regular_11">%r12</samp> |'
  id: totrans-313
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">寄存器(R12)</samp> | <samp class="SANS_Futura_Std_Book_11">8字节</samp>
    | <samp class="SANS_TheSansMonoCd_W5Regular_11">%r12</samp> |'
- en: '| <samp class="SANS_Futura_Std_Book_11">4-byte</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">%r12d</samp>
    |'
  id: totrans-314
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_Futura_Std_Book_11">4字节</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">%r12d</samp>
    |'
- en: '| <samp class="SANS_Futura_Std_Book_11">1-byte</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">%r12b</samp>
    |'
  id: totrans-315
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_Futura_Std_Book_11">1字节</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">%r12b</samp>
    |'
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">Reg(R13)</samp> | <samp class="SANS_Futura_Std_Book_11">8-byte</samp>
    | <samp class="SANS_TheSansMonoCd_W5Regular_11">%r13</samp> |'
  id: totrans-316
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">寄存器(R13)</samp> | <samp class="SANS_Futura_Std_Book_11">8字节</samp>
    | <samp class="SANS_TheSansMonoCd_W5Regular_11">%r13</samp> |'
- en: '| <samp class="SANS_Futura_Std_Book_11">4-byte</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">%r13d</samp>
    |'
  id: totrans-317
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_Futura_Std_Book_11">4字节</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">%r13d</samp>
    |'
- en: '| <samp class="SANS_Futura_Std_Book_11">1-byte</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">%r13b</samp>
    |'
  id: totrans-318
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_Futura_Std_Book_11">1字节</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">%r13b</samp>
    |'
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">Reg(R14)</samp> | <samp class="SANS_Futura_Std_Book_11">8-byte</samp>
    | <samp class="SANS_TheSansMonoCd_W5Regular_11">%r14</samp> |'
  id: totrans-319
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">寄存器(R14)</samp> | <samp class="SANS_Futura_Std_Book_11">8字节</samp>
    | <samp class="SANS_TheSansMonoCd_W5Regular_11">%r14</samp> |'
- en: '| <samp class="SANS_Futura_Std_Book_11">4-byte</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">%r14d</samp>
    |'
  id: totrans-320
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_Futura_Std_Book_11">4字节</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">%r14d</samp>
    |'
- en: '| <samp class="SANS_Futura_Std_Book_11">1-byte</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">%r14b</samp>
    |'
  id: totrans-321
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_Futura_Std_Book_11">1字节</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">%r14b</samp>
    |'
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">Reg(R15)</samp> | <samp class="SANS_Futura_Std_Book_11">8-byte</samp>
    | <samp class="SANS_TheSansMonoCd_W5Regular_11">%r15</samp> |'
  id: totrans-322
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">寄存器(R15)</samp> | <samp class="SANS_Futura_Std_Book_11">8字节</samp>
    | <samp class="SANS_TheSansMonoCd_W5Regular_11">%r15</samp> |'
- en: '| <samp class="SANS_Futura_Std_Book_11">4-byte</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">%r15d</samp>
    |'
  id: totrans-323
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_Futura_Std_Book_11">4字节</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">%r15d</samp>
    |'
- en: '| <samp class="SANS_Futura_Std_Book_11">1-byte</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">%r15b</samp>
    |'
  id: totrans-324
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_Futura_Std_Book_11">1字节</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">%r15b</samp>
    |'
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">Reg(XMM8)</samp> |  | <samp
    class="SANS_TheSansMonoCd_W5Regular_11">%xmm8</samp> |'
  id: totrans-325
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">寄存器(XMM8)</samp> |  | <samp
    class="SANS_TheSansMonoCd_W5Regular_11">%xmm8</samp> |'
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">Reg(XMM9)</samp> |  | <samp
    class="SANS_TheSansMonoCd_W5Regular_11">%xmm9</samp> |'
  id: totrans-326
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">Reg(XMM9)</samp> |  | <samp
    class="SANS_TheSansMonoCd_W5Regular_11">%xmm9</samp> |'
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">Reg(XMM10)</samp> |  | <samp
    class="SANS_TheSansMonoCd_W5Regular_11">%xmm10</samp> |'
  id: totrans-327
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">Reg(XMM10)</samp> |  | <samp
    class="SANS_TheSansMonoCd_W5Regular_11">%xmm10</samp> |'
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">Reg(XMM11)</samp> |  | <samp
    class="SANS_TheSansMonoCd_W5Regular_11">%xmm11</samp> |'
  id: totrans-328
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">Reg(XMM11)</samp> |  | <samp
    class="SANS_TheSansMonoCd_W5Regular_11">%xmm11</samp> |'
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">Reg(XMM12)</samp> |  | <samp
    class="SANS_TheSansMonoCd_W5Regular_11">%xmm12</samp> |'
  id: totrans-329
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">Reg(XMM12)</samp> |  | <samp
    class="SANS_TheSansMonoCd_W5Regular_11">%xmm12</samp> |'
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">Reg(XMM13)</samp> |  | <samp
    class="SANS_TheSansMonoCd_W5Regular_11">%xmm13</samp> |'
  id: totrans-330
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">Reg(XMM13)</samp> |  | <samp
    class="SANS_TheSansMonoCd_W5Regular_11">%xmm13</samp> |'
- en: Now you’re ready to try out your register allocator on some real programs!
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你可以尝试在一些实际程序中使用你的寄存器分配器了！
- en: <samp class="SANS_Futura_Std_Bold_B_11">Register Coalescing</samp>
  id: totrans-332
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">寄存器合并</samp>
- en: 'Our register allocator already works correctly. But as we saw in the example
    at the start of the chapter, it will produce even more efficient code if we include
    a coalescing step. That early example also gave us a general sense of how this
    process works: we look at each <samp class="SANS_TheSansMonoCd_W5Regular_11">mov</samp>
    instruction that copies a value from one register to another and decide whether
    to coalesce its source and destination. Once we’ve made these decisions, we rewrite
    the assembly code, replacing the registers we coalesced and deleting any <samp
    class="SANS_TheSansMonoCd_W5Regular_11">mov</samp> instructions that we no longer
    need.'
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的寄存器分配器已经能正确工作。但正如我们在章节开始时的例子中看到的，如果我们加上一个合并步骤，它将生成更高效的代码。那个早期的例子还给我们提供了一个关于这个过程如何工作的总体印象：我们查看每条
    <samp class="SANS_TheSansMonoCd_W5Regular_11">mov</samp> 指令，该指令将一个值从一个寄存器复制到另一个寄存器，并决定是否合并源寄存器和目标寄存器。一旦做出这些决定，我们会重写汇编代码，替换掉合并后的寄存器，并删除那些不再需要的
    <samp class="SANS_TheSansMonoCd_W5Regular_11">mov</samp> 指令。
- en: 'To decide which registers to coalesce, we’ll consult the interference graph.
    We’ll coalesce a pair of registers when two conditions are met. The first condition
    is obvious: the registers can’t interfere with each other. The example from [Listing
    20-13](chapter20.xhtml#list20-13), reproduced here, illustrates why this condition
    is necessary:'
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 为了决定合并哪些寄存器，我们将参考干扰图。当满足两个条件时，我们将合并一对寄存器。第一个条件很明显：寄存器之间不能互相干扰。下面的 [清单 20-13](chapter20.xhtml#list20-13)
    例子再现了这个条件为何是必要的：
- en: '[PRE36]'
  id: totrans-335
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Since we update <samp class="SANS_TheSansMonoCd_W5Regular_11">y</samp> while
    <samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp> is live, these two registers
    interfere. If we coalesced them, the first <samp class="SANS_TheSansMonoCd_W5Regular_11">add</samp>
    instruction would clobber <samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp>,
    and we’d end up calculating 2 + 2 instead of 1 + 2.
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们在 <samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp> 寄存器活跃时更新 <samp
    class="SANS_TheSansMonoCd_W5Regular_11">y</samp>，这两个寄存器之间存在干扰。如果我们将它们合并，第一个 <samp
    class="SANS_TheSansMonoCd_W5Regular_11">add</samp> 指令将覆盖 <samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp>，我们最终将计算出
    2 + 2，而不是 1 + 2。
- en: 'The second condition is subtler: we’ll coalesce a pair of registers only if
    that won’t force us to spill more registers. To understand why coalescing can
    lead to spills, let’s look at [Listing 20-27](chapter20.xhtml#list20-27).'
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个条件更微妙：只有在不会迫使我们溢出更多寄存器的情况下，我们才会合并一对寄存器。为了理解为什么合并可能导致溢出，让我们看一下 [清单 20-27](chapter20.xhtml#list20-27)。
- en: '[PRE37]'
  id: totrans-338
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 20-27: An assembly
    function where coalescing would cause a spill</samp>'
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">清单 20-27：一个合并寄存器会导致溢出的汇编函数</samp>
- en: This assembly function calculates <samp class="SANS_TheSansMonoCd_W5Regular_11">10
    - (arg</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">+</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">1)
    * arg</samp>. For this example, we’ll pretend that EDI and EAX are the only available
    hard registers, so *k* is 2\. [Figure 20-15](#fig20-15) shows this listing’s interference
    graph, which is clearly 2-colorable.
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 这个汇编函数计算 <samp class="SANS_TheSansMonoCd_W5Regular_11">10 - (arg</samp> <samp
    class="SANS_TheSansMonoCd_W5Regular_11">+</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">1)
    * arg</samp>。在这个例子中，我们假设只有 EDI 和 EAX 是可用的硬件寄存器，所以 *k* 是 2。 [图 20-15](#fig20-15)
    展示了此清单的干扰图，这个图显然是可以用 2 种颜色着色的。
- en: '![](../images/fig20-15.jpg)'
  id: totrans-341
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/fig20-15.jpg)'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 20-15: The interference
    graph for [Listing 20-27](chapter20.xhtml#list20-27) [Description](description-78.xhtml)</samp>'
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">图 20-15: [清单 20-27](chapter20.xhtml#list20-27)
    的干扰图 [描述](description-78.xhtml)</samp>'
- en: The first <samp class="SANS_TheSansMonoCd_W5Regular_11">mov</samp> instruction
    in [Listing 20-27](chapter20.xhtml#list20-27) looks like a possible candidate
    for coalescing. (The second instruction isn’t, since <samp class="SANS_TheSansMonoCd_W5Regular_11">arg</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">tmp</samp> interfere.) But if
    we try to coalesce <samp class="SANS_TheSansMonoCd_W5Regular_11">arg</samp> into
    EDI, we’ll run into trouble. We’ll end up with the assembly code in [Listing 20-28](chapter20.xhtml#list20-28).
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 在[清单 20-27](chapter20.xhtml#list20-27)中的第一个 <samp class="SANS_TheSansMonoCd_W5Regular_11">mov</samp>
    指令看起来是一个合并的候选项。（第二条指令不是，因为 <samp class="SANS_TheSansMonoCd_W5Regular_11">arg</samp>
    和 <samp class="SANS_TheSansMonoCd_W5Regular_11">tmp</samp> 发生干扰。）但如果我们尝试将 <samp
    class="SANS_TheSansMonoCd_W5Regular_11">arg</samp> 合并到 EDI 中，我们就会遇到问题。最终我们会得到[清单
    20-28](chapter20.xhtml#list20-28)中的汇编代码。
- en: '[PRE38]'
  id: totrans-344
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 20-28: [Listing 20-27](chapter20.xhtml#list20-27)
    after coalescing</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">arg</samp>
    <samp class="SANS_Futura_Std_Book_Oblique_I_11">into EDI</samp>'
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">清单 20-28: [清单 20-27](chapter20.xhtml#list20-27)
    合并 <samp class="SANS_Futura_Std_Book_Oblique_I_11">arg</samp> 到 EDI 后的代码</samp>'
- en: '[Figure 20-16](#fig20-16) shows the interference graph for this coalesced code.'
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 20-16](#fig20-16) 显示了这个合并代码的干扰图。'
- en: '![](../images/fig20-16.jpg)'
  id: totrans-347
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/fig20-16.jpg)'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 20-16: The interference
    graph for [Listing 20-28](chapter20.xhtml#list20-28) [Description](description-79.xhtml)</samp>'
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">图 20-16: [清单 20-28](chapter20.xhtml#list20-28)
    的干扰图 [描述](description-79.xhtml)</samp>'
- en: 'Now we can’t 2-color the graph anymore. Since <samp class="SANS_TheSansMonoCd_W5Regular_11">tmp</samp>
    interferes with both hard registers, we’ll have to spill it. Instead of improving
    performance, we’ve made it worse! The cost of spilling <samp class="SANS_TheSansMonoCd_W5Regular_11">tmp</samp>
    to memory outweighs the benefit of removing a single <samp class="SANS_TheSansMonoCd_W5Regular_11">mov</samp>
    instruction. To avoid this situation, we’ll use a strategy called *conservative
    coalescing*: we’ll coalesce two registers only when we can tell in advance that
    it won’t make the interference graph harder to color. But before we dig into conservative
    coalescing, we need to learn how to keep the graph up to date.'
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们无法再对这个图进行二色着色了。由于 <samp class="SANS_TheSansMonoCd_W5Regular_11">tmp</samp>
    与两个硬件寄存器发生干扰，我们必须将其溢出到内存中。我们没有提高性能，反而让情况更糟！将 <samp class="SANS_TheSansMonoCd_W5Regular_11">tmp</samp>
    溢出到内存的代价大于去除一条 <samp class="SANS_TheSansMonoCd_W5Regular_11">mov</samp> 指令的好处。为了避免这种情况，我们将使用一种叫做
    *保守合并* 的策略：只有在我们能提前知道不会使干扰图着色更困难的情况下，才会合并两个寄存器。但在深入讨论保守合并之前，我们需要先学习如何保持干扰图的更新。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Updating the Interference
    Graph</samp>
  id: totrans-350
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">更新干扰图</samp>
- en: Whenever we decide to coalesce a pair of registers, we need to update the interference
    graph. Otherwise, we’ll make later coalescing decisions based on bad information.
    There are two ways to perform this update. The first is to rewrite the assembly
    code immediately and rebuild the graph from scratch. The problem with this approach
    is that building the interference graph is slow. We might coalesce dozens or even
    hundreds of <samp class="SANS_TheSansMonoCd_W5Regular_11">mov</samp> instructions
    in a single function, but we can’t afford to rebuild the interference graph hundreds
    of times.
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 每当我们决定合并一对寄存器时，都需要更新干扰图。否则，我们会基于错误的信息做出后续的合并决策。更新干扰图有两种方式。第一种是立即重写汇编代码，并从头开始重建干扰图。这个方法的问题在于，构建干扰图非常慢。我们可能在一个函数中合并几十个甚至上百个
    <samp class="SANS_TheSansMonoCd_W5Regular_11">mov</samp> 指令，但我们无法承受每次都重建干扰图。
- en: A much quicker approach is to merge the two nodes together in the existing interference
    graph, without referring back to the assembly code. In [Figure 20-17](#fig20-17),
    we use this approach to coalesce the pseudoregister <samp class="SANS_TheSansMonoCd_W5Regular_11">tmp2</samp>
    into EAX.
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 更快的方法是直接在现有的干扰图中合并这两个节点，而不需要重新查看汇编代码。在[图 20-17](#fig20-17)中，我们使用这种方法将伪寄存器 <samp
    class="SANS_TheSansMonoCd_W5Regular_11">tmp2</samp> 合并到 EAX 寄存器中。
- en: '![](../images/fig20-17.jpg)'
  id: totrans-353
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/fig20-17.jpg)'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 20-17: Updating the
    interference graph to reflect coalescing decisions [Description](description-80.xhtml)</samp>'
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">图 20-17：更新干扰图以反映合并决策 [描述](description-80.xhtml)</samp>
- en: We’ll assume that any register that originally interfered with <samp class="SANS_TheSansMonoCd_W5Regular_11">tmp2</samp>
    now interferes with EAX. To make the interference graph reflect this change, we
    just add an edge from each of <samp class="SANS_TheSansMonoCd_W5Regular_11">tmp2</samp>’s
    neighbors to EAX and then remove <samp class="SANS_TheSansMonoCd_W5Regular_11">tmp2</samp>.
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 我们假设原本与 <samp class="SANS_TheSansMonoCd_W5Regular_11">tmp2</samp> 发生冲突的任何寄存器现在与
    EAX 发生冲突。为了使干扰图反映这种变化，我们只需从每个 <samp class="SANS_TheSansMonoCd_W5Regular_11">tmp2</samp>
    的邻居添加一条边到 EAX，然后移除 <samp class="SANS_TheSansMonoCd_W5Regular_11">tmp2</samp>。
- en: 'But this way of updating the graph has a problem too: it’s not always accurate!
    It might include some extra edges between registers that don’t really interfere.
    [Listing 20-29](chapter20.xhtml#list20-29) gives a slightly contrived example.'
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，这种更新图形的方法也存在问题：它并不总是准确的！它可能会在不发生实际冲突的寄存器之间包含一些多余的边。[列表 20-29](chapter20.xhtml#list20-29)
    给出了一个稍显牵强的例子。
- en: '[PRE39]'
  id: totrans-357
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 20-29: A function that
    copies its first argument into two different pseudoregisters</samp>'
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">列表 20-29：一个将其第一个参数复制到两个不同伪寄存器中的函数</samp>
- en: 'Note that <samp class="SANS_TheSansMonoCd_W5Regular_11">tmp1</samp> and <samp
    class="SANS_TheSansMonoCd_W5Regular_11">tmp2</samp> interfere: the second <samp
    class="SANS_TheSansMonoCd_W5Regular_11">mov</samp> instruction updates <samp class="SANS_TheSansMonoCd_W5Regular_11">tmp2</samp>
    while <samp class="SANS_TheSansMonoCd_W5Regular_11">tmp1</samp> is still live.
    Let’s try to coalesce <samp class="SANS_TheSansMonoCd_W5Regular_11">tmp1</samp>
    into EDI and use our speedy, simple method to update the graph accordingly. [Figure
    20-18](#fig20-18) shows how the graph will change.'
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，<samp class="SANS_TheSansMonoCd_W5Regular_11">tmp1</samp> 和 <samp class="SANS_TheSansMonoCd_W5Regular_11">tmp2</samp>
    发生了冲突：第二条 <samp class="SANS_TheSansMonoCd_W5Regular_11">mov</samp> 指令在 <samp class="SANS_TheSansMonoCd_W5Regular_11">tmp1</samp>
    仍然处于活动状态时更新了 <samp class="SANS_TheSansMonoCd_W5Regular_11">tmp2</samp>。让我们尝试将
    <samp class="SANS_TheSansMonoCd_W5Regular_11">tmp1</samp> 合并到 EDI 中，并使用我们快速、简便的方法相应地更新图形。[图
    20-18](#fig20-18) 显示了图形将如何变化。
- en: '![](../images/fig20-18.jpg)'
  id: totrans-360
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/fig20-18.jpg)'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 20-18: Updating the
    interference graph for [Listing 20-29](chapter20.xhtml#list20-29) [Description](description-81.xhtml)</samp>'
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">图 20-18：更新干扰图以反映 [列表 20-29](chapter20.xhtml#list20-29)
    [描述](description-81.xhtml)</samp>
- en: But when we actually replace <samp class="SANS_TheSansMonoCd_W5Regular_11">tmp1</samp>
    with EDI, we’ll find that the interference with <samp class="SANS_TheSansMonoCd_W5Regular_11">tmp2</samp>
    goes away! [Listing 20-30](chapter20.xhtml#list20-30) shows the updated assembly
    code.
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，当我们实际用 EDI 替换 <samp class="SANS_TheSansMonoCd_W5Regular_11">tmp1</samp> 时，我们会发现与
    <samp class="SANS_TheSansMonoCd_W5Regular_11">tmp2</samp> 的冲突消失了！[列表 20-30](chapter20.xhtml#list20-30)
    显示了更新后的汇编代码。
- en: '[PRE40]'
  id: totrans-363
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 20-30: [Listing 20-29](chapter20.xhtml#list20-29)
    after coalescing</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">tmp1</samp>
    <samp class="SANS_Futura_Std_Book_Oblique_I_11">into EDI</samp>'
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">列表 20-30：[列表 20-29](chapter20.xhtml#list20-29)
    合并后</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">tmp1</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">合并到
    EDI</samp>
- en: We learned earlier that the instruction <samp class="SANS_TheSansMonoCd_W5Regular_11">mov
    src, dst</samp> will never make <samp class="SANS_TheSansMonoCd_W5Regular_11">src</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">dst</samp> interfere. Initially,
    the instruction <samp class="SANS_TheSansMonoCd_W5Regular_11">movl %edi, %tmp2</samp>
    caused an interference between <samp class="SANS_TheSansMonoCd_W5Regular_11">tmp1</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">tmp2</samp>. Now that we’ve
    merged <samp class="SANS_TheSansMonoCd_W5Regular_11">tmp1</samp> into EDI, it
    doesn’t cause an interference anymore.
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: 我们之前学到，指令 <samp class="SANS_TheSansMonoCd_W5Regular_11">mov src, dst</samp>
    永远不会使 <samp class="SANS_TheSansMonoCd_W5Regular_11">src</samp> 和 <samp class="SANS_TheSansMonoCd_W5Regular_11">dst</samp>
    发生冲突。最初，指令 <samp class="SANS_TheSansMonoCd_W5Regular_11">movl %edi, %tmp2</samp>
    导致了 <samp class="SANS_TheSansMonoCd_W5Regular_11">tmp1</samp> 和 <samp class="SANS_TheSansMonoCd_W5Regular_11">tmp2</samp>
    之间的冲突。现在，我们将 <samp class="SANS_TheSansMonoCd_W5Regular_11">tmp1</samp> 合并到 EDI
    中，它不再引起冲突。
- en: Even though it isn’t completely accurate, our quick update method is still useful.
    It produces a conservative approximation of the true interference graph; it has
    all the nodes and edges that should be in the graph, but it might have a few extra
    edges too. If this graph tells us that two registers are safe to coalesce, we
    can be sure they really are. But if we rely solely on this method, we’ll leave
    some coalescing opportunities on the table. If, for instance, we only look at
    the graph in [Figure 20-18](#fig20-18), we won’t realize that we can coalesce
    <samp class="SANS_TheSansMonoCd_W5Regular_11">tmp2</samp> into EDI. Worse, if
    we attempted to color this graph, we might end up spilling registers unnecessarily.
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管它不完全准确，我们的快速更新方法仍然很有用。它产生了一个保守的真实干扰图近似；它包含了图中应该有的所有节点和边，但可能也有一些额外的边。如果这个图告诉我们两个寄存器可以安全合并，我们可以确信它们确实可以。但如果我们仅仅依赖这个方法，我们就会错过一些合并机会。例如，如果我们只查看[图
    20-18](#fig20-18)中的图，我们就不会意识到可以将 `<samp class="SANS_TheSansMonoCd_W5Regular_11">tmp2</samp>`
    合并到 EDI 中。更糟糕的是，如果我们尝试为这个图着色，我们可能会不必要地溢出寄存器。
- en: So, we’ll use *both* approaches to update the graph. Each time we decide to
    coalesce a pair of registers, we’ll perform a quick update by merging their nodes
    together. Then, after we’ve looked at every <samp class="SANS_TheSansMonoCd_W5Regular_11">mov</samp>
    instruction and rewritten the assembly code, we’ll rebuild the graph from scratch.
    We’ll repeat this build-coalesce loop until we can’t find any more registers to
    coalesce. Combining a speedy, approximate inner loop with a slow, precise outer
    loop gives us the best of both worlds. We’ll catch every coalescing opportunity
    and send an accurate interference graph on to the coloring stage, but we won’t
    waste time rebuilding the graph after every single coalescing decision.
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，我们将使用*两种*方法来更新图形。每次决定合并一对寄存器时，我们将通过合并它们的节点来快速更新。然后，在查看完每条 `<samp class="SANS_TheSansMonoCd_W5Regular_11">mov</samp>`
    指令并重写汇编代码之后，我们将从头重建图形。我们将重复这个构建-合并循环，直到找不到更多可以合并的寄存器。将一个快速、近似的内循环与一个缓慢、精确的外循环结合，使我们得到了两全其美的效果。我们将抓住每个合并机会，并将准确的干扰图传递到着色阶段，但我们不会在每次合并决策后都浪费时间重建图形。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Conservative Coalescing</samp>
  id: totrans-368
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">保守合并</samp>
- en: Now that we understand how coalescing changes the graph, we can reason about
    when it might lead to spills. The basic issue is that when we coalesce two nodes,
    the merged node will have a higher degree than either of them, which could make
    it more difficult to prune. It’s also likely to have a higher spill cost than
    either of the original nodes, since it’s used more frequently.
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经理解了合并如何改变图形，我们可以推测它何时可能导致溢出。基本问题是，当我们合并两个节点时，合并后的节点将比原来任何一个节点的度数都高，这可能使得剪枝变得更加困难。它还可能比原来的任何节点都有更高的溢出成本，因为它被使用得更频繁。
- en: We’ll use two conservative coalescing tests to ensure that a merged node doesn’t
    cause problems when we color the graph. The *Briggs test* guarantees that we won’t
    spill the merged node. The *George test* guarantees that we won’t spill any other
    nodes unless they were already potential spill candidates in the original graph.
    We’ll only coalesce two pseudoregisters if they pass the Briggs test. We’ll coalesce
    a pseudoregister into a hard register if the two registers pass either test; we
    can be more permissive in this case because we already know that the hard register
    won’t spill. Both tests are named after the people who invented them; you can
    find links to the papers that first proposed them in “Additional Resources” on
    [page 669](#pg_669).
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用两个保守的合并测试，以确保合并后的节点在给图着色时不会造成问题。*Briggs 测试*保证我们不会溢出合并后的节点。*George 测试*保证我们不会溢出任何其他节点，除非它们在原始图中已经是潜在的溢出候选节点。只有当它们通过
    Briggs 测试时，我们才会合并两个伪寄存器。如果两个寄存器通过任意一个测试，我们会将伪寄存器合并到硬寄存器中；在这种情况下我们可以更加宽松，因为我们已经知道硬寄存器不会溢出。两个测试都以发明它们的人的名字命名；你可以在[第
    669 页](#pg_669)的“附加资源”中找到首次提出这些测试的论文链接。
- en: It’s worth clarifying exactly what the conservative coalescing tests guarantee,
    because it’s a little unintuitive. If you could completely prune the original
    graph without ever having to choose a spill candidate, these tests guarantee that
    the same will be true for the coalesced graph. In this case, we can say for sure
    that coalescing won’t cause any spills.
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: 值得明确的是，保守的合并测试保证的内容，因为这个结果有点反直觉。如果你能够在不选择任何溢出候选节点的情况下完全修剪原始图，那么这些测试保证合并后的图也将保持相同的情况。在这种情况下，我们可以确定，合并不会导致任何溢出。
- en: But if you couldn’t totally prune the original graph, it’s harder to predict
    the impact of coalescing, because a lot of what happens after you pick a spill
    candidate comes down to chance. We saw an example of this earlier in the chapter,
    when we tried to color the graph in [Figure 20-12](#fig20-12); pruning nodes in
    a different order made the difference between being able to color a spill candidate
    and actually spilling it. Coalescing registers can have similar ripple effects.
    If we’re unlucky, these effects might lead to a spill that we otherwise would
    have avoided.
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: 但如果你无法完全修剪原始图，那么预测合并的影响就变得更加困难，因为选择溢出候选节点之后发生的很多事情都取决于运气。我们在本章早些时候看到过一个例子，当时我们尝试着为
    [图 20-12](#fig20-12) 着色；以不同的顺序修剪节点，决定了是否能够着色一个溢出候选节点，或者最终会导致溢出。合并寄存器也可能产生类似的连锁反应。如果我们不幸，这些效应可能导致一个原本可以避免的溢出。
- en: In other words, if coloring the original graph required us to choose a spill
    candidate, coloring the coalesced graph might too—and at that point, it’s impossible
    to say with any certainty what’s going to happen. In this case, the conservative
    coalescing tests still give us two valuable guarantees. First, the coalesced node
    itself won’t spill. Second, at the point where we get stuck and have to choose
    our first spill candidate, every node’s degree will be the same or lower than
    it would have been when we got stuck if we hadn’t performed coalescing. This means
    that, on balance, we’re likely to successfully prune more nodes and spill fewer
    than we would have without coalescing.
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: 换句话说，如果给原始图着色时需要我们选择一个溢出候选节点，那么在合并图时也可能需要这样做——而在那时，我们无法确定将会发生什么。在这种情况下，保守的合并测试仍然给我们提供了两个有价值的保证。首先，合并后的节点本身不会发生溢出。其次，在我们遇到困境并必须选择第一个溢出候选节点时，每个节点的度数都将与如果我们没有进行合并时遇到困境时的度数相同或更低。这意味着，从总体上看，我们可能成功地剪枝更多的节点，并且溢出较少的节点，而不进行合并的话，情况可能正好相反。
- en: Now we’ll take a closer look at the Briggs and George tests. We’ll define both
    of them and walk through some examples that demonstrate why they work.
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将更深入地研究布里格斯和乔治测试。我们将定义这两个测试，并通过一些例子来展示它们为什么有效。
- en: '##### <samp class="SANS_Futura_Std_Bold_Condensed_B_11">The Briggs Test</samp>'
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: '##### <samp class="SANS_Futura_Std_Bold_Condensed_B_11">布里格斯测试</samp>'
- en: Remember that a node has significant degree if it has *k* or more neighbors.
    The Briggs test allows us to merge two nodes if the merged node will have fewer
    than *k* neighbors with significant degree. When we color the graph, we’ll be
    able to prune every neighbor with insignificant degree. The merged node itself
    will then have insignificant degree—it will have fewer than *k* neighbors left—so
    we’ll be able to prune that node too.
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，如果一个节点有 *k* 个或更多邻居，那么它的度数就被认为是显著的。布里格斯测试允许我们合并两个节点，只要合并后的节点具有的显著度数少于 *k*
    个邻居。当我们为图着色时，我们将能够修剪每个度数不显著的邻居。合并后的节点本身将拥有不显著的度数——它将剩下少于 *k* 个邻居——因此我们也可以修剪该节点。
- en: Let’s look at an example. Consider the interference graph in [Figure 20-19](#fig20-19).
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一个例子。考虑 [图 20-19](#fig20-19) 中的干扰图。
- en: '![](../images/fig20-19.jpg)'
  id: totrans-378
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/fig20-19.jpg)'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 20-19: An interference
    graph before coalescing [Description](description-82.xhtml)</samp>'
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">图 20-19：合并前的干扰图 [描述](description-82.xhtml)</samp>
- en: Our coloring algorithm can prune this entire graph without any difficulty. Now
    let’s apply the Briggs test to see if we can coalesce <samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp>
    into <samp class="SANS_TheSansMonoCd_W5Regular_11">y</samp>. [Figure 20-20](#fig20-20)
    shows how the graph will look once we merge these two nodes together.
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的着色算法可以毫不费力地修剪整个图。现在让我们应用布里格斯测试，看看能否将 <samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp>
    合并到 <samp class="SANS_TheSansMonoCd_W5Regular_11">y</samp> 中。[图 20-20](#fig20-20)
    展示了当我们合并这两个节点时图的样子。
- en: '![](../images/fig20-20.jpg)'
  id: totrans-381
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/fig20-20.jpg)'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 20-20: The graph in
    [Figure 20-19](#fig20-19) after merging x into y [Description](description-83.xhtml)</samp>'
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">图 20-20：[图 20-19](#fig20-19)
    中的图，合并 x 到 y 后的结果 [描述](description-83.xhtml)</samp>
- en: 'After coalescing, <samp class="SANS_TheSansMonoCd_W5Regular_11">y</samp> will
    have four neighbors: <samp class="SANS_TheSansMonoCd_W5Regular_11">a</samp>, <samp
    class="SANS_TheSansMonoCd_W5Regular_11">z</samp>, ESI, and EDI. Only two of these
    nodes, ESI and EDI, have significant degree. Since *k* is 3, this example passes
    the Briggs test. And in fact, we’ll be able to prune <samp class="SANS_TheSansMonoCd_W5Regular_11">y</samp>
    after we’ve pruned <samp class="SANS_TheSansMonoCd_W5Regular_11">a</samp> and
    <samp class="SANS_TheSansMonoCd_W5Regular_11">z</samp>, then finish pruning the
    rest of the graph like we did before.'
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: 合并后，<samp class="SANS_TheSansMonoCd_W5Regular_11">y</samp>将有四个邻居：<samp class="SANS_TheSansMonoCd_W5Regular_11">a</samp>、<samp
    class="SANS_TheSansMonoCd_W5Regular_11">z</samp>、ESI 和 EDI。这些节点中只有两个，ESI 和 EDI，具有显著的度数。由于
    *k* 为 3，这个例子通过了 Briggs 测试。实际上，在我们修剪了 <samp class="SANS_TheSansMonoCd_W5Regular_11">a</samp>
    和 <samp class="SANS_TheSansMonoCd_W5Regular_11">z</samp> 后，我们将能够修剪 <samp class="SANS_TheSansMonoCd_W5Regular_11">y</samp>，然后像之前那样完成图的其余部分的修剪。
- en: Next, let’s look at a case that fails the Briggs test. The graph in [Figure
    20-21](#fig20-21) is almost identical to the one in [Figure 20-19](#fig20-19),
    except for an extra edge from <samp class="SANS_TheSansMonoCd_W5Regular_11">a</samp>
    to EDI.
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们看看一个不符合 Briggs 测试的案例。[图 20-21](#fig20-21)中的图几乎与[图 20-19](#fig20-19)中的图完全相同，唯一的不同是从
    <samp class="SANS_TheSansMonoCd_W5Regular_11">a</samp> 到 EDI 的额外边。
- en: '![](../images/fig20-21.jpg)'
  id: totrans-385
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/fig20-21.jpg)'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 20-21: A variation on
    the graph in [Figure 20-19](#fig20-19) where x and y can no longer be coalesced
    [Description](description-84.xhtml)</samp>'
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">图 20-21：[图 20-19](#fig20-19)
    中的图，x 和 y 无法再合并 [描述](description-84.xhtml)</samp>
- en: Even with this extra edge, our coloring algorithm can still prune the whole
    graph. But [Figure 20-22](#fig20-22) shows what happens when we coalesce <samp
    class="SANS_TheSansMonoCd_W5Regular_11">x</samp> into <samp class="SANS_TheSansMonoCd_W5Regular_11">y</samp>
    this time around.
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: 即使有了这条额外的边，我们的着色算法仍然可以修剪整个图。但是[图 20-22](#fig20-22)展示了当我们将 <samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp>
    合并到 <samp class="SANS_TheSansMonoCd_W5Regular_11">y</samp> 时会发生什么。
- en: '![](../images/fig20-22.jpg)'
  id: totrans-388
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/fig20-22.jpg)'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 20-22: The graph in
    [Figure 20-21](#fig20-21) after merging x</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">into
    y [Description](description-85.xhtml)</samp>'
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">图 20-22：[图 20-21](#fig20-21)
    中的图，合并 x 到 y 后的结果 [描述](description-85.xhtml)</samp>
- en: 'Now <samp class="SANS_TheSansMonoCd_W5Regular_11">y</samp> has three neighbors
    with significant degree: ESI, EDI, and <samp class="SANS_TheSansMonoCd_W5Regular_11">a</samp>.
    This example fails the Briggs test, and <samp class="SANS_TheSansMonoCd_W5Regular_11">y</samp>
    really is impossible to prune. After we prune <samp class="SANS_TheSansMonoCd_W5Regular_11">z</samp>
    and EAX we’ll get stuck, and we’ll be forced to choose <samp class="SANS_TheSansMonoCd_W5Regular_11">y</samp>
    or <samp class="SANS_TheSansMonoCd_W5Regular_11">a</samp> as a spill candidate.'
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，<samp class="SANS_TheSansMonoCd_W5Regular_11">y</samp>有三个邻居，它们的度数很大：ESI、EDI
    和 <samp class="SANS_TheSansMonoCd_W5Regular_11">a</samp>。这个例子不符合 Briggs 测试，<samp
    class="SANS_TheSansMonoCd_W5Regular_11">y</samp>确实无法修剪。在我们修剪了 <samp class="SANS_TheSansMonoCd_W5Regular_11">z</samp>
    和 EAX 后，我们会卡住，并且被迫选择 <samp class="SANS_TheSansMonoCd_W5Regular_11">y</samp> 或
    <samp class="SANS_TheSansMonoCd_W5Regular_11">a</samp> 作为溢出候选节点。
- en: 'As these examples show us, the Briggs test stops us from transforming a colorable
    graph into an uncolorable one. It also gives us another guarantee: we’ll never
    coalesce two nodes if the resulting node might spill. Take a look at [Figure 20-23](#fig20-23).'
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: 正如这些例子所示，Briggs 测试阻止我们将一个可着色图转换为不可着色图。它还给我们提供了另一项保证：我们永远不会将两个节点合并在一起，如果合并后的节点可能会溢出。看看[图
    20-23](#fig20-23)。
- en: '![](../images/fig20-23.jpg)'
  id: totrans-392
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/fig20-23.jpg)'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 20-23: An interference
    graph where we can’t coalesce tmp1 and tmp2 [Description](description-86.xhtml)</samp>'
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">图 20-23：一个干扰图，我们无法将 tmp1 和 tmp2
    合并 [描述](description-86.xhtml)</samp>
- en: Suppose we want to coalesce <samp class="SANS_TheSansMonoCd_W5Regular_11">tmp2</samp>
    into <samp class="SANS_TheSansMonoCd_W5Regular_11">tmp1</samp>. This clearly won’t
    make the graph harder to color; it will have the same effect on the interference
    graph as removing <samp class="SANS_TheSansMonoCd_W5Regular_11">tmp2</samp> entirely.
    But coalescing these nodes is a bad idea for another reason. We won’t be able
    to color <samp class="SANS_TheSansMonoCd_W5Regular_11">tmp1</samp> whether we
    coalesce it with <samp class="SANS_TheSansMonoCd_W5Regular_11">tmp2</samp> or
    not, so coalescing will just make things worse by increasing <samp class="SANS_TheSansMonoCd_W5Regular_11">tmp1</samp>’s
    spill cost.
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们想将 <samp class="SANS_TheSansMonoCd_W5Regular_11">tmp2</samp> 合并到 <samp class="SANS_TheSansMonoCd_W5Regular_11">tmp1</samp>
    中。这显然不会让图变得更难着色；它对干扰图的影响与完全移除 <samp class="SANS_TheSansMonoCd_W5Regular_11">tmp2</samp>
    相同。但是合并这些节点有一个不好的原因。无论我们是否将其与 <samp class="SANS_TheSansMonoCd_W5Regular_11">tmp2</samp>
    合并，我们都无法给 <samp class="SANS_TheSansMonoCd_W5Regular_11">tmp1</samp> 着色，所以合并只会通过增加
    <samp class="SANS_TheSansMonoCd_W5Regular_11">tmp1</samp> 的溢出成本来使事情变得更糟。
- en: This example fails the Briggs test, since <samp class="SANS_TheSansMonoCd_W5Regular_11">tmp1</samp>
    will have three neighbors with significant degree after coalescing (just like
    it did before coalescing). If we might not be able to color it, the Briggs test
    won’t let us coalesce it.
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子未通过布里格斯测试，因为合并后 <samp class="SANS_TheSansMonoCd_W5Regular_11">tmp1</samp>
    会有三个重要度较高的邻居（就像合并前一样）。如果我们可能无法给它着色，布里格斯测试将不允许我们进行合并。
- en: 'Finally, let’s tweak this example to illustrate one of the limits of the Briggs
    test. Imagine that we want to coalesce <samp class="SANS_TheSansMonoCd_W5Regular_11">tmp2</samp>
    into EDI instead of <samp class="SANS_TheSansMonoCd_W5Regular_11">tmp1</samp>.
    Like in our previous example, this won’t make the graph harder to color. And this
    also fails the Briggs test, because EDI will have three neighbors with significant
    degree. But there’s one important difference: as a hard register, EDI can’t spill.
    This means that there’s no downside to coalescing <samp class="SANS_TheSansMonoCd_W5Regular_11">tmp2</samp>
    into EDI; it won’t force us to spill EDI, and it won’t make other nodes harder
    to color either. In cases like this, we’ll use the George test to find coalescing
    opportunities that the Briggs test misses.'
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，让我们调整这个例子，说明布里格斯测试的一个局限性。假设我们想将 <samp class="SANS_TheSansMonoCd_W5Regular_11">tmp2</samp>
    合并到 EDI，而不是 <samp class="SANS_TheSansMonoCd_W5Regular_11">tmp1</samp>。像我们之前的例子一样，这不会让图变得更难着色。这个例子也未通过布里格斯测试，因为
    EDI 会有三个重要度较高的邻居。但有一个重要的区别：作为硬寄存器，EDI 不能溢出。这意味着将 <samp class="SANS_TheSansMonoCd_W5Regular_11">tmp2</samp>
    合并到 EDI 没有什么坏处；它不会迫使我们溢出 EDI，也不会使其他节点变得更难着色。在这种情况下，我们将使用乔治测试来找到布里格斯测试忽略的合并机会。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">The George Test</samp>
  id: totrans-397
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">乔治测试</samp>
- en: 'When we coalesce a pseudoregister with a hard register, we know the coalesced
    register can’t spill. Instead, we’re worried about a slightly different outcome:
    if the hard register becomes more difficult to prune, its neighbors could become
    harder to prune too. Ultimately, this change could force us to spill nodes that
    we were able to color before. In cases that involve a hard register, we’ll use
    both the Briggs test and the George test to identify as many coalescing opportunities
    as possible. The Briggs test proves that we can prune the merged node, so it won’t
    interfere with attempts to color other nodes. The George test proves that we won’t
    make the merged node’s neighbors harder to prune (and therefore won’t make those
    nodes or the rest of the graph more difficult to color), even if we can’t prune
    the merged node itself. We can coalesce a pair of nodes that passes either of
    these tests.'
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们将伪寄存器与硬寄存器合并时，我们知道合并后的寄存器不能溢出。相反，我们担心的是稍微不同的结果：如果硬寄存器变得更难修剪，它的邻居也可能变得更难修剪。最终，这种变化可能会迫使我们溢出那些之前能够着色的节点。在涉及硬寄存器的情况下，我们将同时使用布里格斯测试和乔治测试，以尽可能多地识别合并机会。布里格斯测试证明我们可以修剪合并后的节点，因此它不会干扰着色其他节点的尝试。乔治测试证明即使我们无法修剪合并后的节点，我们也不会使合并节点的邻居变得更难修剪（因此不会使这些节点或图的其余部分变得更难着色）。我们可以合并通过这两个测试中的任意一个测试的节点对。
- en: 'The George test says that you can coalesce a pseudoregister *p* into a hard
    register *h* if each of *p*’s neighbors meets either of two conditions:'
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
  zh: 乔治测试表示，如果 *p* 的每个邻居都满足以下两个条件中的任意一个，那么你可以将伪寄存器 *p* 合并到硬寄存器 *h* 中：
- en: It has fewer than *k* neighbors.
  id: totrans-400
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 它的邻居少于 *k* 个。
- en: It already interferes with *h*.
  id: totrans-401
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 它已经与 *h* 有干扰。
- en: If a neighbor meets the first condition, we’ll definitely be able to prune it
    when we color the graph. If it meets the second condition, it will have exactly
    the same neighbors as before (except for *p*) after coalescing, so we won’t have
    made it any harder to prune; if anything, we might have made it easier.
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一个邻居满足第一个条件，那么在我们为图着色时，肯定能对其进行修剪。如果它满足第二个条件，在合并后它的邻居将和之前完全一样（除了*p*），因此我们并没有让修剪变得更难；如果有的话，反而可能会让修剪变得更容易。
- en: Coalescing *h* and *p* won’t make any of *h*’s neighbors harder to prune, either.
    The only way it could do that would be by preventing us from pruning *h* itself,
    but any new neighbors that *h* acquires through coalescing will have insignificant
    degree, so they won’t affect our ability to prune it.
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
  zh: 合并*h*和*p*也不会让*h*的邻居变得更难修剪。唯一可能会这样做的方式是阻止我们修剪*h*本身，但任何通过合并得到的*h*的新邻居都将具有微不足道的度，因此不会影响我们修剪它的能力。
- en: 'Let’s take another look at the graph from [Figure 20-23](#fig20-23) to see
    why this works:'
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们再看一遍[图20-23](#fig20-23)中的图表，看看为什么这样做有效：
- en: '![](../images/pg660-1.jpg)'
  id: totrans-405
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/pg660-1.jpg)'
- en: Earlier, we decided that coalescing <samp class="SANS_TheSansMonoCd_W5Regular_11">tmp2</samp>
    into EDI was safe, because EDI couldn’t spill and this change wouldn’t make any
    of the other nodes harder to color. But we also saw that this case failed the
    Briggs test, since EDI would then have three neighbors with significant degree.
    Now we’ll try the George test instead. This test will pass, since both neighbors
    of <samp class="SANS_TheSansMonoCd_W5Regular_11">tmp2</samp> already interfere
    with EDI. Our allocator will coalesce <samp class="SANS_TheSansMonoCd_W5Regular_11">tmp2</samp>
    into EDI, since it coalesces moves that pass either of our two tests.
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
  zh: 之前，我们决定将<samp class="SANS_TheSansMonoCd_W5Regular_11">tmp2</samp>合并到EDI是安全的，因为EDI无法溢出，并且这个变化不会让其他节点变得更难着色。但我们也看到这个情况没有通过布里格斯测试，因为EDI那时将有三个具有显著度的邻居。现在我们将改用乔治测试。这个测试会通过，因为<samp
    class="SANS_TheSansMonoCd_W5Regular_11">tmp2</samp>的两个邻居已经与EDI发生干扰。我们的分配器将把<samp
    class="SANS_TheSansMonoCd_W5Regular_11">tmp2</samp>合并到EDI，因为它合并通过我们两个测试的所有移动操作。
- en: 'For our last example, let’s revisit the graph from [Figure 20-15](#fig20-15):'
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们的最后一个例子，让我们重新审视[图20-15](#fig20-15)中的图表：
- en: '![](../images/pg660-2.jpg)'
  id: totrans-408
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/pg660-2.jpg)'
- en: The last time we looked at this graph, we were considering whether to coalesce
    <samp class="SANS_TheSansMonoCd_W5Regular_11">arg</samp> into EDI. Now we know
    that we shouldn’t coalesce them, because this case doesn’t pass either of our
    two tests. It fails the Briggs test because the coalesced node would have two
    neighbors with significant degree, <samp class="SANS_TheSansMonoCd_W5Regular_11">tmp</samp>
    and EAX. It also fails the George test; <samp class="SANS_TheSansMonoCd_W5Regular_11">arg</samp>’s
    one neighbor, <samp class="SANS_TheSansMonoCd_W5Regular_11">tmp</samp>, has significant
    degree and doesn’t interfere with EDI. The George test tells us that <samp class="SANS_TheSansMonoCd_W5Regular_11">tmp</samp>
    *might* become harder to color if we made this change; we’d be making it interfere
    with an additional register, and we don’t know what impact that would have. In
    this small example, we can tell by looking at the graph that <samp class="SANS_TheSansMonoCd_W5Regular_11">tmp</samp>
    actually would be harder to color if we coalesced <samp class="SANS_TheSansMonoCd_W5Regular_11">arg</samp>
    into EDI, since it would interfere with both hard registers.
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
  zh: 上次我们查看这个图表时，我们在考虑是否将<samp class="SANS_TheSansMonoCd_W5Regular_11">arg</samp>合并到EDI中。现在我们知道我们不应该合并它们，因为这个情况没有通过我们的两个测试。它没有通过布里格斯测试，因为合并后的节点将有两个具有显著度的邻居，<samp
    class="SANS_TheSansMonoCd_W5Regular_11">tmp</samp>和EAX。它也没有通过乔治测试；<samp class="SANS_TheSansMonoCd_W5Regular_11">arg</samp>的一个邻居，<samp
    class="SANS_TheSansMonoCd_W5Regular_11">tmp</samp>，具有显著度，并且不会干扰EDI。乔治测试告诉我们，如果我们进行这个变化，<samp
    class="SANS_TheSansMonoCd_W5Regular_11">tmp</samp>*可能*会变得更难着色；我们会让它干扰到另一个寄存器，而我们无法预知这样会产生什么影响。在这个小例子中，通过查看图表，我们可以看出，如果我们将<samp
    class="SANS_TheSansMonoCd_W5Regular_11">arg</samp>合并到EDI中，<samp class="SANS_TheSansMonoCd_W5Regular_11">tmp</samp>实际上会变得更难着色，因为它会干扰到两个硬寄存器。
- en: There’s one ugly detail about the George test that I want to mention. Remember
    that we’re using a quick, approximate method to update the graph after each coalescing
    decision. This approximate method might leave edges in the graph between registers
    that do not, in fact, interfere. As a result, when applying the George test to
    registers *p* and *h*, we might think that some neighbor *n* of *p* also interferes
    with *h* when it actually doesn’t. We might then incorrectly conclude that *p*
    and *h* pass the George test and coalesce them.
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
  zh: 关于乔治测试，有一个不太美观的细节我想提一下。记得我们在每次合并决策后使用一种快速的近似方法来更新图形吗？这种近似方法可能会在寄存器之间留下实际上并不干扰的边。因此，当我们将乔治测试应用于寄存器*p*和*h*时，我们可能会误以为*p*的某个邻居*n*也与*h*干扰，尽管实际上并没有。接着我们可能会错误地得出结论，认为*p*和*h*通过了乔治测试并将它们合并。
- en: That sounds pretty bad, but it only slightly weakens the guarantee that the
    George test provides. Earlier, I claimed that the George test guarantees that
    we won’t make the merged node’s neighbors harder to prune. It actually guarantees
    that we won’t make them harder to prune than they were *before we started the
    current round of coalescing*—that is, the last time we rebuilt the interference
    graph from scratch.
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
  zh: 听起来很糟糕，但它仅稍微削弱了乔治测试提供的保证。之前我提到过，乔治测试保证我们不会让合并节点的邻居变得更难修剪。实际上，它保证我们不会让它们比*我们开始当前合并轮次之前*更难修剪——也就是说，最后一次我们从头重建干扰图时的状态。
- en: This weaker guarantee still holds because our approximate graph will include
    an edge between *n* and *h* only if *n* did interfere with *h* when we built the
    interference graph, but some earlier coalescing decision removed that interference.
    Essentially, if an earlier coalescing decision made *n* or *h* easier to prune
    by removing the edge between them, we might accidentally make them more difficult
    to prune again by putting that edge back. However, we’ll never make things worse
    than they were before the current round of coalescing. (It’s also worth keeping
    in mind that the purpose of the Briggs and George tests is to improve performance,
    *not* to guarantee correctness; even a “bad” coalescing decision that fails both
    tests won’t change the program’s observable behavior.)
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
  zh: 这个较弱的保证依然成立，因为我们的近似图会在*n*和*h*之间仅包含一条边，当且仅当*n*在我们构建干扰图时确实与*h*干扰，但某个早期的合并决策移除了这种干扰。本质上，如果某个早期的合并决策通过移除它们之间的边使得*n*或*h*更容易修剪，我们可能会因为再次添加这条边而意外地使它们更难修剪。然而，我们永远不会让事情变得比当前合并轮次之前更糟。（还值得记住的是，布里格斯和乔治测试的目的是提高性能，而*不是*保证正确性；即使是一个失败了这两个测试的“不好”合并决策，也不会改变程序的可观察行为。）
- en: We’ve looked at both conservative coalescing tests, what guarantees they provide,
    and why they work. Now we just have to implement them.
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看过了两种保守的合并测试，它们提供了哪些保证，以及它们为何有效。现在我们只需要实现它们。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Implementing Register
    Coalescing</samp>
  id: totrans-414
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">实现寄存器合并</samp>
- en: Our first task is to add the build-coalesce loop to the top-level register allocation
    algorithm. [Listing 20-31](chapter20.xhtml#list20-31) gives the updated algorithm,
    with this addition bolded.
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的第一步是将构建合并循环添加到顶层寄存器分配算法中。[列表 20-31](chapter20.xhtml#list20-31)给出了更新后的算法，新增部分以粗体标出。
- en: '[PRE41]'
  id: totrans-416
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 20-31: Adding register
    coalescing to the top-level register allocation algorithm</samp>'
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">列表 20-31：将寄存器合并添加到顶层寄存器分配算法中</samp>
- en: Within this loop, we build the interference graph, then look for registers to
    coalesce. If we find any, we rewrite the assembly code and start the whole process
    again. Otherwise, we exit the loop and run the rest of the allocator as usual.
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个循环中，我们构建干扰图，然后寻找需要合并的寄存器。如果找到，我们会重写汇编代码并重新开始整个过程。否则，我们退出循环，按照正常方式运行分配器的其余部分。
- en: We record which registers we’ve coalesced together in <samp class="SANS_TheSansMonoCd_W5Regular_11">coalesced_regs</samp>,
    which is a *disjoint-set* data structure. Let’s write a simple implementation
    of this data structure; then we’ll define the <samp class="SANS_TheSansMonoCd_W5Regular_11">coalesce</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">rewrite_coalesced</samp> functions.
  id: totrans-419
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在<samp class="SANS_TheSansMonoCd_W5Regular_11">coalesced_regs</samp>中记录了我们已经合并在一起的寄存器，这是一种*不相交集合*数据结构。让我们编写一个简单的实现，然后定义<
    samp class="SANS_TheSansMonoCd_W5Regular_11">coalesce</samp>和<samp class="SANS_TheSansMonoCd_W5Regular_11">rewrite_coalesced</samp>函数。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">Disjoint Sets</samp>
  id: totrans-420
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">不相交集合</samp>
- en: 'As the name suggests, a disjoint-set data structure represents multiple disjoint
    sets of values. Each set is identified by one representative member. Disjoint
    sets support two operations: <samp class="SANS_TheSansMonoCd_W5Regular_11">union</samp>
    merges two sets, and <samp class="SANS_TheSansMonoCd_W5Regular_11">find</samp>
    looks up the representative member of a set. In our case, the values in each set
    are <samp class="SANS_TheSansMonoCd_W5Regular_11">Reg</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">Pseudo</samp>
    operands. Initially, each register is in a set by itself. As we coalesce registers,
    we’ll use the <samp class="SANS_TheSansMonoCd_W5Regular_11">union</samp> operation
    to merge these sets together. When we rewrite the assembly code, we’ll use <samp
    class="SANS_TheSansMonoCd_W5Regular_11">find</samp> to replace each register with
    the representative member of its set.'
  id: totrans-421
  prefs: []
  type: TYPE_NORMAL
  zh: 顾名思义，不相交集合数据结构表示多个不相交的值集合。每个集合由一个代表元素标识。不相交集合支持两个操作：<samp class="SANS_TheSansMonoCd_W5Regular_11">union</samp>
    合并两个集合，<samp class="SANS_TheSansMonoCd_W5Regular_11">find</samp> 查找集合的代表元素。在我们的案例中，每个集合中的值是
    <samp class="SANS_TheSansMonoCd_W5Regular_11">Reg</samp> 和 <samp class="SANS_TheSansMonoCd_W5Regular_11">Pseudo</samp>
    操作数。最初，每个寄存器都在自己的集合中。当我们合并寄存器时，我们将使用 <samp class="SANS_TheSansMonoCd_W5Regular_11">union</samp>
    操作将这些集合合并在一起。当我们重写汇编代码时，我们将使用 <samp class="SANS_TheSansMonoCd_W5Regular_11">find</samp>
    将每个寄存器替换为其集合的代表元素。
- en: There are a few different ways to implement disjoint sets. We’ll use a simple
    implementation that’s easy to understand. [Listing 20-32](chapter20.xhtml#list20-32)
    defines our implementation.
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
  zh: 实现不相交集合有几种不同的方法。我们将使用一种简单的实现，易于理解。[清单 20-32](chapter20.xhtml#list20-32) 定义了我们的实现。
- en: '[PRE42]'
  id: totrans-423
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 20-32: A basic implementation
    of disjoint sets</samp>'
  id: totrans-424
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">清单 20-32：不相交集合的基本实现</samp>
- en: We use a map to track which sets have been merged together. At first, this map
    is empty ❶. To merge two sets whose representative members are <samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">y</samp>, the <samp class="SANS_TheSansMonoCd_W5Regular_11">union</samp>
    operation inserts a mapping from <samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp>
    to <samp class="SANS_TheSansMonoCd_W5Regular_11">y</samp> ❷. This makes <samp
    class="SANS_TheSansMonoCd_W5Regular_11">y</samp> the representative member of
    the new set. When we coalesce a pseudoregister into a hard register, it’s important
    to make the hard register the set’s representative member; we don’t want to replace
    hard registers with pseudoregisters when we rewrite the code later on.
  id: totrans-425
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用一个映射来跟踪哪些集合已经合并在一起。最初，这个映射是空的 ❶。为了合并两个代表元素分别为 <samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp>
    和 <samp class="SANS_TheSansMonoCd_W5Regular_11">y</samp> 的集合，<samp class="SANS_TheSansMonoCd_W5Regular_11">union</samp>
    操作将从 <samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp> 到 <samp class="SANS_TheSansMonoCd_W5Regular_11">y</samp>
    插入一个映射 ❷。这使得 <samp class="SANS_TheSansMonoCd_W5Regular_11">y</samp> 成为新集合的代表元素。当我们将伪寄存器合并到硬寄存器时，重要的是要使硬寄存器成为集合的代表元素；我们不希望在稍后重写代码时将硬寄存器替换为伪寄存器。
- en: To look up the representative member of the set that contains the register <samp
    class="SANS_TheSansMonoCd_W5Regular_11">r</samp>, the <samp class="SANS_TheSansMonoCd_W5Regular_11">find</samp>
    operation first checks whether <samp class="SANS_TheSansMonoCd_W5Regular_11">r</samp>
    maps to some other register ❸. If it doesn’t, <samp class="SANS_TheSansMonoCd_W5Regular_11">r</samp>
    itself is the representative member of its set, so we return it. Otherwise, looking
    it up in the map will give us <samp class="SANS_TheSansMonoCd_W5Regular_11">result</samp>,
    which is the register we merged <samp class="SANS_TheSansMonoCd_W5Regular_11">r</samp>
    into previously. We then call <samp class="SANS_TheSansMonoCd_W5Regular_11">find</samp>
    recursively ❹, which leads us up the chain of mappings from <samp class="SANS_TheSansMonoCd_W5Regular_11">r</samp>
    to its representative member. For example, if we’ve merged <samp class="SANS_TheSansMonoCd_W5Regular_11">a</samp>
    into <samp class="SANS_TheSansMonoCd_W5Regular_11">b</samp> and then merged <samp
    class="SANS_TheSansMonoCd_W5Regular_11">b</samp> into <samp class="SANS_TheSansMonoCd_W5Regular_11">c</samp>,
    we’ll follow the mappings from <samp class="SANS_TheSansMonoCd_W5Regular_11">a</samp>
    to <samp class="SANS_TheSansMonoCd_W5Regular_11">b</samp> to <samp class="SANS_TheSansMonoCd_W5Regular_11">c</samp>
    to determine that <samp class="SANS_TheSansMonoCd_W5Regular_11">c</samp> is the
    representative member for <samp class="SANS_TheSansMonoCd_W5Regular_11">a</samp>.
  id: totrans-426
  prefs: []
  type: TYPE_NORMAL
  zh: 为了查找包含寄存器 <samp class="SANS_TheSansMonoCd_W5Regular_11">r</samp> 的集合的代表成员，<samp
    class="SANS_TheSansMonoCd_W5Regular_11">find</samp> 操作首先检查 <samp class="SANS_TheSansMonoCd_W5Regular_11">r</samp>
    是否映射到其他寄存器 ❸。如果没有，<samp class="SANS_TheSansMonoCd_W5Regular_11">r</samp> 本身就是其集合的代表成员，我们就返回它。否则，查找映射会得到
    <samp class="SANS_TheSansMonoCd_W5Regular_11">result</samp>，这就是我们之前合并 <samp class="SANS_TheSansMonoCd_W5Regular_11">r</samp>
    到的寄存器。然后我们递归地调用 <samp class="SANS_TheSansMonoCd_W5Regular_11">find</samp> ❹，这将引导我们沿着从
    <samp class="SANS_TheSansMonoCd_W5Regular_11">r</samp> 到其代表成员的映射链。例如，如果我们将 <samp
    class="SANS_TheSansMonoCd_W5Regular_11">a</samp> 合并到 <samp class="SANS_TheSansMonoCd_W5Regular_11">b</samp>，然后将
    <samp class="SANS_TheSansMonoCd_W5Regular_11">b</samp> 合并到 <samp class="SANS_TheSansMonoCd_W5Regular_11">c</samp>，我们将按照
    <samp class="SANS_TheSansMonoCd_W5Regular_11">a</samp> 到 <samp class="SANS_TheSansMonoCd_W5Regular_11">b</samp>
    到 <samp class="SANS_TheSansMonoCd_W5Regular_11">c</samp> 的映射关系，确定 <samp class="SANS_TheSansMonoCd_W5Regular_11">c</samp>
    是 <samp class="SANS_TheSansMonoCd_W5Regular_11">a</samp> 的代表成员。
- en: The last operation we define in this listing is <samp class="SANS_TheSansMonoCd_W5Regular_11">nothing_was_coalesced</samp>,
    which just checks whether the map is empty ❺.
  id: totrans-427
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个列表中我们定义的最后一个操作是 <samp class="SANS_TheSansMonoCd_W5Regular_11">nothing_was_coalesced</samp>，它只是检查映射是否为空
    ❺。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">The coalesce Function</samp>
  id: totrans-428
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">coalesce 函数</samp>
- en: The <samp class="SANS_TheSansMonoCd_W5Regular_11">coalesce</samp> function will
    look at each <samp class="SANS_TheSansMonoCd_W5Regular_11">mov</samp> instruction
    in the assembly code, deciding which registers to coalesce and keeping track of
    those decisions in the disjoint-set structure we just defined. Let’s walk through
    [Listing 20-33](chapter20.xhtml#list20-33), which gives the pseudocode for this
    function.
  id: totrans-429
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W5Regular_11">coalesce</samp> 函数将检查汇编代码中的每条
    <samp class="SANS_TheSansMonoCd_W5Regular_11">mov</samp> 指令，决定哪些寄存器需要合并，并在我们刚刚定义的不相交集合结构中跟踪这些决策。让我们通过
    [Listing 20-33](chapter20.xhtml#list20-33) 来逐步了解，这个列表给出了该函数的伪代码。
- en: '[PRE43]'
  id: totrans-430
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 20-33: Deciding which
    registers to coalesce</samp>'
  id: totrans-431
  prefs: []
  type: TYPE_NORMAL
  zh: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 20-33: 决定哪些寄存器需要合并</samp>'
- en: We start by initializing a new disjoint-set structure, <samp class="SANS_TheSansMonoCd_W5Regular_11">coalesced_regs</samp>,
    to track which registers we’ve coalesced. Then, we iterate through the instruction
    list. When we hit a <samp class="SANS_TheSansMonoCd_W5Regular_11">Mov</samp> instruction,
    we use <samp class="SANS_TheSansMonoCd_W5Regular_11">find</samp> to look up its
    current source and destination ❶, since we might have coalesced <samp class="SANS_TheSansMonoCd_W5Regular_11">src</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">dst</samp> into other registers
    already. Note that these operands might be constants or memory addresses instead
    of registers. This is fine; if there’s no mapping for <samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp>
    in <samp class="SANS_TheSansMonoCd_W5Regular_11">coalesced_regs</samp>, <samp
    class="SANS_TheSansMonoCd_W5Regular_11">find(x, coalesced_regs)</samp> just returns
    <samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp>, regardless of whether
    <samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp> is a register or some other
    kind of operand.
  id: totrans-432
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先初始化一个新的不相交集结构<samp class="SANS_TheSansMonoCd_W5Regular_11">coalesced_regs</samp>，用于跟踪我们已经合并的寄存器。然后，我们遍历指令列表。当我们遇到一个<samp
    class="SANS_TheSansMonoCd_W5Regular_11">Mov</samp>指令时，我们使用<samp class="SANS_TheSansMonoCd_W5Regular_11">find</samp>查找它当前的源操作数和目标操作数❶，因为我们可能已经将<samp
    class="SANS_TheSansMonoCd_W5Regular_11">src</samp>和<samp class="SANS_TheSansMonoCd_W5Regular_11">dst</samp>合并到了其他寄存器。请注意，这些操作数可能是常量或内存地址，而不是寄存器。这样是可以的；如果<samp
    class="SANS_TheSansMonoCd_W5Regular_11">x</samp>在<samp class="SANS_TheSansMonoCd_W5Regular_11">coalesced_regs</samp>中没有映射，<samp
    class="SANS_TheSansMonoCd_W5Regular_11">find(x, coalesced_regs)</samp>将直接返回<samp
    class="SANS_TheSansMonoCd_W5Regular_11">x</samp>，无论<x>是否是寄存器或其他类型的操作数。
- en: 'Next, we decide whether to coalesce the instruction’s source and destination
    ❷. First, we check whether they’re both in the interference graph. (This stops
    us from trying to coalesce constants or memory operands.) We then make sure they’re
    two different registers, since there’s no reason to coalesce a register with itself.
    If these checks pass, we test the two conditions we learned about earlier: <samp
    class="SANS_TheSansMonoCd_W5Regular_11">src</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">dst</samp>
    must not interfere ❸, and coalescing them must not make the graph harder to color
    ❹. We check the second of these conditions with the <samp class="SANS_TheSansMonoCd_W5Regular_11">conservative_coalesceable</samp>
    function, which we’ll come back to in a moment.'
  id: totrans-433
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们决定是否将指令的源操作数和目标操作数合并❷。首先，我们检查它们是否都在干扰图中。（这可以防止我们尝试合并常量或内存操作数。）然后，我们确保它们是两个不同的寄存器，因为没有理由将寄存器与自身合并。如果这些检查通过，我们将测试之前学习的两个条件：<samp
    class="SANS_TheSansMonoCd_W5Regular_11">src</samp>和<samp class="SANS_TheSansMonoCd_W5Regular_11">dst</samp>必须没有干扰❸，并且合并它们不能使图的着色变得更加困难❹。我们用<samp
    class="SANS_TheSansMonoCd_W5Regular_11">conservative_coalesceable</samp>函数来检查第二个条件，稍后我们会详细介绍这个函数。
- en: If <samp class="SANS_TheSansMonoCd_W5Regular_11">src</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">dst</samp>
    meet all these conditions, we’ll coalesce them! Now we have to figure out which
    one to keep in the assembly code and which one to replace. If either operand is
    a hard register, we’ll keep that one and replace the other one. If they’re both
    pseudoregisters, we’ll arbitrarily choose to keep <samp class="SANS_TheSansMonoCd_W5Regular_11">dst</samp>.
    We call <samp class="SANS_TheSansMonoCd_W5Regular_11">union</samp> to actually
    coalesce these registers ❺, then we update the interference graph. [Listing 20-34](chapter20.xhtml#list20-34)
    defines the function that performs this update.
  id: totrans-434
  prefs: []
  type: TYPE_NORMAL
  zh: 如果<samp class="SANS_TheSansMonoCd_W5Regular_11">src</samp>和<samp class="SANS_TheSansMonoCd_W5Regular_11">dst</samp>满足所有这些条件，我们将合并它们！现在我们需要决定在汇编代码中保留哪一个，替换哪一个。如果其中一个操作数是硬寄存器，我们将保留那个并替换另一个。如果它们都是伪寄存器，我们将任意选择保留<samp
    class="SANS_TheSansMonoCd_W5Regular_11">dst</samp>。我们调用<samp class="SANS_TheSansMonoCd_W5Regular_11">union</samp>来实际合并这些寄存器❺，然后更新干扰图。[列表
    20-34](chapter20.xhtml#list20-34)定义了执行此更新的函数。
- en: '[PRE44]'
  id: totrans-435
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 20-34: Updating the
    interference graph</samp>'
  id: totrans-436
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">列表 20-34：更新干扰图</samp>
- en: This function takes each of <samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp>’s
    neighbors, removes its edge to <samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp>,
    and adds an edge to <samp class="SANS_TheSansMonoCd_W5Regular_11">y</samp> instead.
    Then, it removes <samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp> from the
    graph.
  id: totrans-437
  prefs: []
  type: TYPE_NORMAL
  zh: 该函数处理每个 <samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp> 的邻居，移除它与 <samp
    class="SANS_TheSansMonoCd_W5Regular_11">x</samp> 之间的边，并添加一条连接到 <samp class="SANS_TheSansMonoCd_W5Regular_11">y</samp>
    的边。然后，它会从图中移除 <samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp>。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">The conservative_coalesceable
    Function</samp>
  id: totrans-438
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">conservative_coalesceable
    函数</samp>
- en: Now that the rest of <samp class="SANS_TheSansMonoCd_W5Regular_11">coalesce</samp>
    is in place, let’s take a look at [Listing 20-35](chapter20.xhtml#list20-35),
    which defines the conservative coalescing tests.
  id: totrans-439
  prefs: []
  type: TYPE_NORMAL
  zh: 现在其余的 <samp class="SANS_TheSansMonoCd_W5Regular_11">coalesce</samp> 已经就位，让我们来看一下
    [清单 20-35](chapter20.xhtml#list20-35)，它定义了保守合并测试。
- en: '[PRE45]'
  id: totrans-440
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 20-35: The conservative
    coalescing tests</samp>'
  id: totrans-441
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">清单 20-35：保守合并测试</samp>
- en: In <samp class="SANS_TheSansMonoCd_W5Regular_11">conservative_coalesceable</samp>,
    we try the Briggs test first ❶. Then, if the Briggs test fails and either <samp
    class="SANS_TheSansMonoCd_W5Regular_11">src</samp> or <samp class="SANS_TheSansMonoCd_W5Regular_11">dst</samp>
    is a hard register, we try the George test ❷. When we use the George test, we’ll
    make sure to pass the hard register as its first argument and the pseudoregister
    as its second, since it doesn’t treat these registers interchangeably.
  id: totrans-442
  prefs: []
  type: TYPE_NORMAL
  zh: 在 <samp class="SANS_TheSansMonoCd_W5Regular_11">conservative_coalesceable</samp>
    中，我们首先尝试布里格斯测试 ❶。然后，如果布里格斯测试失败，并且 <samp class="SANS_TheSansMonoCd_W5Regular_11">src</samp>
    或 <samp class="SANS_TheSansMonoCd_W5Regular_11">dst</samp> 是硬寄存器，我们就尝试乔治测试 ❷。当我们使用乔治测试时，我们将确保将硬寄存器作为第一个参数传递，将伪寄存器作为第二个参数，因为该测试不会把这些寄存器视为可以互换的。
- en: To apply the Briggs test, we first construct <samp class="SANS_TheSansMonoCd_W5Regular_11">combined_neighbors</samp>,
    which is the set of nodes that interfere with either <samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp>
    or <samp class="SANS_TheSansMonoCd_W5Regular_11">y</samp>. We then iterate through
    this set, looking up each neighbor’s degree ❸. If a node interferes with both
    of them, coalescing <samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp> and
    <samp class="SANS_TheSansMonoCd_W5Regular_11">y</samp> would decrease its degree
    by one, so we adjust <samp class="SANS_TheSansMonoCd_W5Regular_11">degree</samp>
    accordingly ❹. We’ll return <samp class="SANS_TheSansMonoCd_W5Regular_11">True</samp>
    if fewer than *k* of the nodes in <samp class="SANS_TheSansMonoCd_W5Regular_11">combined_neighbors</samp>
    have significant degree ❺.
  id: totrans-443
  prefs: []
  type: TYPE_NORMAL
  zh: 为了应用布里格斯测试，我们首先构造 <samp class="SANS_TheSansMonoCd_W5Regular_11">combined_neighbors</samp>，它是与
    <samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp> 或 <samp class="SANS_TheSansMonoCd_W5Regular_11">y</samp>
    发生冲突的节点集合。然后，我们遍历这个集合，查找每个邻居的度数 ❸。如果某个节点与它们两个都有冲突，那么合并 <samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp>
    和 <samp class="SANS_TheSansMonoCd_W5Regular_11">y</samp> 会使该节点的度数减少 1，因此我们会相应地调整
    <samp class="SANS_TheSansMonoCd_W5Regular_11">degree</samp> ❹。如果 <samp class="SANS_TheSansMonoCd_W5Regular_11">combined_neighbors</samp>
    中少于 *k* 个节点具有显著的度数 ❺，我们将返回 <samp class="SANS_TheSansMonoCd_W5Regular_11">True</samp>。
- en: To apply the George test, we iterate through the pseudoregister’s neighbors,
    making sure each one either interferes with the hard register ❻ or has insignificant
    degree ❼. If we find a neighbor that doesn’t satisfy either condition, we’ll return
    <samp class="SANS_TheSansMonoCd_W5Regular_11">False</samp>. If every neighbor
    meets both conditions, we’ll return <samp class="SANS_TheSansMonoCd_W5Regular_11">True</samp>.
  id: totrans-444
  prefs: []
  type: TYPE_NORMAL
  zh: 为了应用乔治测试，我们遍历伪寄存器的邻居，确保每个邻居要么与硬寄存器有冲突 ❻，要么具有微不足道的度数 ❼。如果我们找到一个不满足任何条件的邻居，我们将返回
    <samp class="SANS_TheSansMonoCd_W5Regular_11">False</samp>。如果每个邻居都满足这两个条件，我们将返回
    <samp class="SANS_TheSansMonoCd_W5Regular_11">True</samp>。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">The rewrite_coalesced Function</samp>
  id: totrans-445
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">rewrite_coalesced 函数</samp>
- en: We’ll wrap up by rewriting the assembly code. [Listing 20-36](chapter20.xhtml#list20-36)
    gives the pseudocode for this step.
  id: totrans-446
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将通过重写汇编代码来结束。 [清单 20-36](chapter20.xhtml#list20-36) 给出了这一步骤的伪代码。
- en: '[PRE46]'
  id: totrans-447
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 20-36: Rewriting instructions
    after deciding which registers to coalesce</samp>'
  id: totrans-448
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">清单 20-36：在决定合并哪些寄存器后重写指令</samp>
- en: We use the <samp class="SANS_TheSansMonoCd_W5Regular_11">find</samp> operation
    to replace each operand in each instruction. (Here, like in <samp class="SANS_TheSansMonoCd_W5Regular_11">coalesce</samp>,
    we rely on <samp class="SANS_TheSansMonoCd_W5Regular_11">find</samp> to handle
    non-registers correctly.) If a <samp class="SANS_TheSansMonoCd_W5Regular_11">Mov</samp>
    instruction’s updated source and destination are the same, we’ll omit the instruction
    from the rewritten code ❶. As a side benefit, this will also remove any <samp
    class="SANS_TheSansMonoCd_W5Regular_11">Mov</samp> instructions that were redundant
    before we coalesced registers.
  id: totrans-449
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用<samp class="SANS_TheSansMonoCd_W5Regular_11">find</samp>操作来替换每条指令中的每个操作数。（在这里，像在<samp
    class="SANS_TheSansMonoCd_W5Regular_11">coalesce</samp>中一样，我们依赖<samp class="SANS_TheSansMonoCd_W5Regular_11">find</samp>来正确处理非寄存器。）如果一个<samp
    class="SANS_TheSansMonoCd_W5Regular_11">Mov</samp>指令的更新源和目标相同，我们将从重写的代码中省略该指令❶。作为副作用，这也会移除那些在寄存器合并前就已经冗余的<samp
    class="SANS_TheSansMonoCd_W5Regular_11">Mov</samp>指令。
- en: And with that, you’ve finished your register allocator! We don’t need to change
    any other passes, so you can go ahead and test it out.
  id: totrans-450
  prefs: []
  type: TYPE_NORMAL
  zh: 就这样，你完成了你的寄存器分配器！我们不需要更改其他阶段，所以你可以开始测试它了。
- en: <samp class="SANS_Futura_Std_Bold_B_11">Summary</samp>
  id: totrans-451
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">总结</samp>
- en: In this chapter, you built a register allocator. You used everything you’d already
    learned about liveness analysis to build an interference graph, and then you implemented
    a classic graph coloring algorithm to color it. You introduced callee-saved registers
    and learned how to save and restore them. Then, you used register coalescing to
    clean up the mess that earlier stages of the compiler left behind. You’ve written
    your last optimization and completed the project!
  id: totrans-452
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你构建了一个寄存器分配器。你使用了你已经学到的关于生存性分析的知识，构建了一个干扰图，然后实现了一个经典的图着色算法来对其着色。你引入了被调用保存寄存器，并学会了如何保存和恢复它们。接着，你使用寄存器合并清理了编译器早期阶段留下的杂乱。你已经写完了最后的优化，并完成了这个项目！
- en: 'Over the course of this book, you’ve built an impressive piece of software:
    an optimizing compiler for a substantial chunk of the C language. You’ve covered
    a lot of ground, from the intricacies of the C standard to the gory details of
    the System V calling convention to the fundamentals of data-flow analysis. But
    if you want to push your compiler even further, you have plenty of options. I’ll
    close out this part of the book with a few ideas for what to work on next.'
  id: totrans-453
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书的过程中，你已经构建了一款令人印象深刻的软件：一个优化编译器，能够处理C语言的一个重要部分。你已经涵盖了大量内容，从C标准的复杂性到System
    V调用约定的细节，再到数据流分析的基础知识。但如果你想进一步提升你的编译器，你有很多选择。我将以一些关于接下来可以进行的工作的建议来结束本书的这一部分。
- en: <samp class="SANS_Futura_Std_Bold_B_11">Additional Resources</samp>
  id: totrans-454
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">附加资源</samp>
- en: The register allocator you built in this chapter uses a simplified version of
    the classic *Chaitin-Briggs algorithm*. This section tells you where to find the
    original papers about this algorithm, a couple of textbook chapters that present
    them in a more approachable way, and some other useful references on more specific
    topics.
  id: totrans-455
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中你构建的寄存器分配器使用了经典的*Chaitin-Briggs算法*的简化版本。本节告诉你在哪里可以找到有关该算法的原始论文，几章以更易理解的方式呈现这些内容的教科书章节，以及一些关于更具体主题的其他有用参考资料。
- en: '**Key papers**'
  id: totrans-456
  prefs: []
  type: TYPE_NORMAL
  zh: '**关键论文**'
- en: “Register Allocation via Coloring,” a 1981 paper by Gregory Chaitin et al.,
    described the original graph coloring register allocator (*[https://<wbr>doi<wbr>.org<wbr>/10<wbr>.1016<wbr>/0096<wbr>-0551(81)90048<wbr>-5](https://doi.org/10.1016/0096-0551(81)90048-5)*).
    It introduced most of the fundamental concepts in this chapter, including how
    to build and color an interference graph.
  id: totrans-457
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: “通过着色进行寄存器分配”，是Gregory Chaitin等人在1981年发表的论文，描述了原始的图着色寄存器分配器(*[https://<wbr>doi<wbr>.org<wbr>/10<wbr>.1016<wbr>/0096<wbr>-0551(81)90048<wbr>-5](https://doi.org/10.1016/0096-0551(81)90048-5)*)。它介绍了本章中的大部分基本概念，包括如何构建和着色干扰图。
- en: Chaitin published an updated description of the same allocator, “Register Allocation
    & Spilling via Graph Coloring,” in 1982 (*[https://<wbr>doi<wbr>.org<wbr>/10<wbr>.1145<wbr>/872726<wbr>.806984](https://doi.org/10.1145/872726.806984)*).
  id: totrans-458
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Chaitin于1982年发布了对同一分配器的更新描述，“通过图着色进行寄存器分配与溢出”(*[https://<wbr>doi<wbr>.org<wbr>/10<wbr>.1145<wbr>/872726<wbr>.806984](https://doi.org/10.1145/872726.806984)*)。
- en: “Improvements to Graph Coloring Register Allocation,” a 1994 paper by Preston
    Briggs, Keith Cooper, and Linda Torczon, describes an improved version of Chaitin’s
    design (*[https://<wbr>doi<wbr>.org<wbr>/10<wbr>.1145<wbr>/177492<wbr>.177575](https://doi.org/10.1145/177492.177575)*).
    The name *Chaitin-Briggs* refers to this improved algorithm. This paper presented
    the technique of putting spill candidates on the stack and trying to color them
    later instead of spilling them immediately. (Briggs et al. call this technique
    *optimistic coloring*.) It also introduced the Briggs test and the general concept
    of conservative coalescing; Chaitin’s original design coalesced aggressively,
    even when it made the graph harder to color. This paper described some techniques
    that we didn’t cover in this chapter, like rematerialization, as well.
  id: totrans-459
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: “图着色寄存器分配的改进”是Preston Briggs、Keith Cooper和Linda Torczon于1994年发表的一篇论文，描述了Chaitin设计的改进版本
    (*[https://doi.org/10.1145/177492.177575](https://doi.org/10.1145/177492.177575)*)。*Chaitin-Briggs*
    这个名字指的就是这种改进后的算法。本文提出了一种将溢出候选项放到栈上并尝试稍后着色，而不是立即溢出的技术。（Briggs等人称这种技术为*乐观着色*。）它还引入了Briggs测试和保守合并的概念；Chaitin的原始设计即使在使图变得更难着色时也会进行激进的合并。本文还描述了一些我们在这一章中没有涉及的技术，比如重新材料化技术。
- en: '**Textbook chapters**'
  id: totrans-460
  prefs: []
  type: TYPE_NORMAL
  zh: '**教科书章节**'
- en: '[Chapter 16](chapter16.xhtml) of Steven Muchnick’s *Advanced Compiler Design
    and Implementation* (Morgan Kaufmann, 1997) presents a register allocator that
    uses an algorithm similar to Chaitin-Briggs. The most notable difference is that
    it doesn’t use conservative coalescing; like Chaitin’s original allocator, it
    coalesces aggressively. I found Muchnick’s explanations of how to include hard
    registers in the interference graph, how to detect interference, and the overall
    structure of the allocator especially useful.'
  id: totrans-461
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Steven Muchnick的《*高级编译器设计与实现*》第16章（Morgan Kaufmann，1997年）介绍了一种类似于Chaitin-Briggs的寄存器分配器。最显著的区别在于它没有使用保守合并；与Chaitin的原始分配器一样，它进行了激进的合并。我发现Muchnick关于如何在干扰图中包含硬寄存器、如何检测干扰以及分配器的整体结构的解释尤其有用。
- en: '[Chapter 13](chapter13.xhtml) of Keith Cooper and Linda Torczon’s *Engineering
    a Compiler*, 2nd edition (Morgan Kaufmann, 2011), provides an excellent overview
    of a wide range of approaches to register allocation, including the Chaitin-Briggs
    algorithm and several others that we didn’t discuss here. I’ve drawn on their
    definition of interference and their discussion of how to update the interference
    graph while coalescing; they provide a particularly helpful explanation of why
    both fast, imprecise updates and slow, complete updates are needed. (You can also
    consult the third edition of this book, published in 2022.)'
  id: totrans-462
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Keith Cooper和Linda Torczon的《*工程化编译器*》第13章（第二版，Morgan Kaufmann，2011年）对多种寄存器分配方法进行了出色的概述，其中包括Chaitin-Briggs算法以及一些我们在这里未讨论的其他方法。我参考了他们对干扰的定义，以及他们讨论的在合并过程中如何更新干扰图的内容；他们特别清楚地解释了为何需要同时进行快速但不精确的更新和缓慢但完全的更新。（你也可以参考该书的第三版，2022年出版。）
- en: <samp class="SANS_Dogma_OT_Bold_B_39">NOTE</samp>
  id: totrans-463
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: <samp class="SANS_Dogma_OT_Bold_B_39">注</samp>
- en: '*These are both good resources if you want to implement the parts of Chaitin-Briggs
    that we skipped. The chapter by Muchnick is particularly useful if you want to
    integrate spill code generation into your register allocator. Both books discuss
    how to use live ranges (which Muchnick calls* webs*) instead of pseudoregisters
    as the nodes in your interference graph, and both provide better spill cost metrics
    than the one we used.*'
  id: totrans-464
  prefs: []
  type: TYPE_NORMAL
  zh: '*如果你想实现我们跳过的Chaitin-Briggs部分，这两本资源都非常有用。如果你想将溢出代码生成集成到你的寄存器分配器中，Muchnick的章节尤其有用。这两本书都讨论了如何使用活动区间（Muchnick称之为*webs*）而不是伪寄存器作为干扰图中的节点，并且它们提供了比我们使用的溢出成本度量更好的方法。*'
- en: '**Conservative coalescing**'
  id: totrans-465
  prefs: []
  type: TYPE_NORMAL
  zh: '**保守合并**'
- en: The George test comes from “Iterated Register Coalescing,” by Lal George and
    Andrew Appel (*[https://<wbr>doi<wbr>.org<wbr>/10<wbr>.1145<wbr>/229542<wbr>.229546](https://doi.org/10.1145/229542.229546)*).
    The main point of the paper is that you can coalesce more registers if you alternate
    between coalescing and pruning; the George test is presented as a minor implementation
    detail.
  id: totrans-466
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: George测试来源于Lal George和Andrew Appel的论文“迭代寄存器合并”（*[https://doi.org/10.1145/229542.229546](https://doi.org/10.1145/229542.229546)*)。论文的主要观点是，如果你在合并和修剪之间交替进行，就能合并更多的寄存器；George测试作为一个次要的实现细节进行了介绍。
- en: For an informal discussion of the George and Briggs tests with lots of examples,
    see the slides from Phillip Gibbons’s course on compiler optimizations at Carnegie
    Mellon (*[https://<wbr>www<wbr>.cs<wbr>.cmu<wbr>.edu<wbr>/afs<wbr>/cs<wbr>/academic<wbr>/class<wbr>/15745<wbr>-s19<wbr>/www<wbr>/lectures<wbr>/L23<wbr>-Register<wbr>-Coalescing<wbr>.pdf](https://www.cs.cmu.edu/afs/cs/academic/class/15745-s19/www/lectures/L23-Register-Coalescing.pdf)*).
  id: totrans-467
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 关于George和Briggs测试的非正式讨论以及大量实例，见Phillip Gibbons在卡内基梅隆大学编译优化课程中的幻灯片 (*[https://www.cs.cmu.edu/afs/cs/academic/class/15745-s19/www/lectures/L23-Register-Coalescing.pdf](https://www.cs.cmu.edu/afs/cs/academic/class/15745-s19/www/lectures/L23-Register-Coalescing.pdf)*)。
- en: “Comparing Conservative Coalescing Criteria” by Max Hailperin rigorously defines
    what the Briggs and George tests actually prove, which is something that the authors
    of the original papers never bothered to do (*[https://<wbr>doi<wbr>.org<wbr>/10<wbr>.1145<wbr>/1065887<wbr>.1065894](https://doi.org/10.1145/1065887.1065894)*).
    My discussion of what these tests guarantee at the start of “Conservative Coalescing”
    on [page 656](#pg_656) relies heavily on Hailperin’s paper. Note that some of
    his claims don’t apply to our graph coloring implementation because he uses precoloring
    and we don’t.
  id: totrans-468
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Max Hailperin的《比较保守合并标准》严谨地定义了Briggs和George测试实际证明了什么，而这是原始论文的作者们从未费心做过的事情 (*[https://doi.org/10.1145/1065887.1065894](https://doi.org/10.1145/1065887.1065894)*)。我在《保守合并》一文开头关于这些测试所保证内容的讨论，主要依赖于Hailperin的论文。请注意，他的某些主张不适用于我们的图着色实现，因为他使用了预着色，而我们没有。
- en: '**Identifying loops**'
  id: totrans-469
  prefs: []
  type: TYPE_NORMAL
  zh: '**识别循环**'
- en: 'To calculate more accurate spill costs, you need to detect the loops in your
    program. These resources talk about how to identify loops:'
  id: totrans-470
  prefs: []
  type: TYPE_NORMAL
  zh: 要计算更准确的溢出成本，你需要检测程序中的循环。这些资源讲述了如何识别循环：
- en: '[Chapter 9](chapter9.xhtml), section 6, of *Compilers: Principles, Techniques,
    and Tools*, 2nd edition, by Alfred Aho et al. (Addison-Wesley, 2006).'
  id: totrans-471
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*编译器：原理、技术与工具*（第2版），Alfred Aho等人著，章节9，第6节（Addison-Wesley，2006年）。'
- en: Phillip Gibbons’s lecture slides on induction variable optimizations, from his
    Carnegie Mellon compiler optimizations course (*[https://<wbr>www<wbr>.cs<wbr>.cmu<wbr>.edu<wbr>/afs<wbr>/cs<wbr>/academic<wbr>/class<wbr>/15745<wbr>-s19<wbr>/www<wbr>/lectures<wbr>/L8<wbr>-Induction<wbr>-Variables<wbr>.pdf](https://www.cs.cmu.edu/afs/cs/academic/class/15745-s19/www/lectures/L8-Induction-Variables.pdf)*).
    This is a great starting point, but the slides aren’t detailed enough to use as
    a stand-alone guide to loop analysis. You might want to use them alongside the
    previous reference or another textbook.
  id: totrans-472
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Phillip Gibbons关于归纳变量优化的讲座幻灯片，来自他在卡内基梅隆大学的编译优化课程 (*[https://www.cs.cmu.edu/afs/cs/academic/class/15745-s19/www/lectures/L8-Induction-Variables.pdf](https://www.cs.cmu.edu/afs/cs/academic/class/15745-s19/www/lectures/L8-Induction-Variables.pdf)*)。这是一个很好的起点，但这些幻灯片的细节不够丰富，无法单独作为循环分析的指南。你可能需要将它们与前述参考资料或其他教科书一起使用。
