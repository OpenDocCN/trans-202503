- en: <hgroup>
  id: totrans-0
  prefs: []
  type: TYPE_NORMAL
  zh: <hgroup>
- en: 12 CREATING FUNCTIONS AND PACKAGES
  id: totrans-1
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 12 创建函数和包
- en: </hgroup>
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: </hgroup>
- en: '![](../images/chapter.jpg)'
  id: totrans-3
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/chapter.jpg)'
- en: In this chapter, you will learn how to define your own R functions, including
    the parameters they should accept. Then, you’ll create a package to distribute
    those functions, add your code and dependencies to it, write its documentation,
    and choose the license under which to release it.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你将学习如何定义你自己的 R 函数，包括它们应该接受的参数。然后，你将创建一个包来分发这些函数，添加你的代码和依赖项，编写文档，并选择发布时的许可证。
- en: Saving your code as custom functions and then distributing them in packages
    can have numerous benefits. First, packages make your code easier for others to
    use. For example, when researchers at the Moffitt Cancer Center needed to access
    code from a database, data scientists Travis Gerke and Garrick Aden-Buie used
    to write R code for each researcher, but they quickly realized they were reusing
    the same code over and over. Instead, they made a package with functions for accessing
    databases. Now researchers no longer had to ask for help; they could simply install
    the package Gerke and Aden-Buie had made and use its functions themselves.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 将代码保存为自定义函数，然后将其分发到包中，可以带来许多好处。首先，包可以使你的代码更容易供他人使用。例如，当莫菲特癌症中心的研究人员需要从数据库访问代码时，数据科学家
    Travis Gerke 和 Garrick Aden-Buie 以前会为每个研究人员编写 R 代码，但他们很快意识到自己不断重复相同的代码。于是，他们制作了一个包含数据库访问功能的包。现在，研究人员不再需要寻求帮助；他们只需安装
    Gerke 和 Aden-Buie 创建的包并自行使用其中的函数。
- en: What’s more, developing packages allows you to shape how others work. Say you
    make a ggplot theme that follows the principles of high-quality data visualization
    discussed in [Chapter 3](chapter3.xhtml). If you put this theme in a package,
    you can give others an easy way to follow these design principles. In short, functions
    and packages help you work with others using shared code.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 更重要的是，开发包可以让你塑造他人的工作方式。假设你创建了一个遵循[第 3 章](chapter3.xhtml)中讨论的高质量数据可视化原则的 ggplot
    主题。如果你将这个主题放入包中，你就能为他人提供一种简便的方式来遵循这些设计原则。简而言之，函数和包帮助你通过共享代码与他人合作。
- en: Creating Your Own Functions
  id: totrans-7
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建你自己的函数
- en: 'Hadley Wickham, developer of the tidyverse set of packages, recommends creating
    a function once you’ve copied some code three times. Functions have three pieces:
    a name, a body, and arguments.'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: tidyverse 包的开发者 Hadley Wickham 推荐，当你复制某段代码三次后，就应该考虑将其封装为函数。函数由三个部分组成：名称、主体和参数。
- en: Writing a Simple Function
  id: totrans-9
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 编写一个简单的函数
- en: 'You’ll begin by writing an example of a relatively simple function. This function,
    called show_in_excel_penguins(), opens the penguin data from [Chapter 7](chapter7.xhtml)
    in Microsoft Excel:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 你将首先编写一个相对简单的函数示例。这个名为 `show_in_excel_penguins()` 的函数会在 Microsoft Excel 中打开[第
    7 章](chapter7.xhtml)中的企鹅数据：
- en: '[PRE0]'
  id: totrans-11
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: This code first loads the tidyverse and fs packages. You’ll use tidyverse to
    create a filename for the CSV file and save it, and fs to open the CSV file in
    Excel (or whichever program your computer uses to open CSV files by default).
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码首先加载 tidyverse 和 fs 包。你将使用 tidyverse 来为 CSV 文件创建文件名并保存它，使用 fs 来在 Excel 中打开
    CSV 文件（或你的计算机默认用来打开 CSV 文件的程序）。
- en: 'Next, the read_csv() function imports the penguin data and names the data frame
    penguins ❶. Then it creates the new show_in_excel_penguins function, using the
    assignment operator (<-) and function() to specify that show_in_excel_penguins
    isn’t a variable name but a function name ❷. The open curly bracket ({) at the
    end of the line indicates the start of the function body, where the “meat” of
    the function can be found. In this case, the body does three things:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，`read_csv()` 函数导入企鹅数据，并将数据框命名为 penguins ❶。然后，它创建了新的 `show_in_excel_penguins`
    函数，使用赋值操作符 (<-) 和 `function()` 来指定 `show_in_excel_penguins` 不是变量名，而是函数名 ❷。行尾的左花括号（{）表示函数体的开始，函数的“核心”部分就在其中。在这个例子中，函数体完成了三件事：
- en: Creates a location for a CSV file to be saved using the str_glue() function
    combined with the tempfile() function. This creates a file at a temporary location
    with the *.csv* extension and saves it as csv_file.
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `str_glue()` 函数与 `tempfile()` 函数结合，创建一个保存 CSV 文件的位置。这会在临时位置创建一个 *.csv* 扩展名的文件，并将其保存为
    csv_file。
- en: Writes penguins to the location set in csv_file. The x argument in write _csv()
    refers to the data frame to be saved. It also specifies that all NA values should
    show up as blanks. (By default, they would display the text *NA*.)
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将企鹅数据写入在 csv_file 中设置的位置。`write_csv()` 中的 x 参数指代要保存的数据框。它还指定所有的 NA 值应该显示为空白。（默认情况下，它们会显示为
    *NA*。）
- en: Uses the file_show() function from the fs package to open the temporary CSV
    file in Excel.
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 fs 包中的 file_show() 函数在 Excel 中打开临时的 CSV 文件。
- en: To use the show_in_excel_penguins() function, highlight the lines that define
    the function and then press COMMAND-ENTER on macOS or CTRL-ENTER on Windows. You
    should now see the function in your global environment, as shown in [Figure 12-1](chapter12.xhtml#fig12-1).
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用 show_in_excel_penguins() 函数，选中定义函数的代码行，然后在 macOS 上按 COMMAND-ENTER，或在 Windows
    上按 CTRL-ENTER。现在你应该能在全局环境中看到这个函数，如 [图 12-1](chapter12.xhtml#fig12-1) 所示。
- en: '![](../images/fig12-1.jpg)'
  id: totrans-18
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/fig12-1.jpg)'
- en: 'Figure 12-1: The new function in the global environment'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 图 12-1：全局环境中的新函数
- en: From now on, any time you run the code show_in_excel_penguins(), R will open
    the penguins data frame in Excel.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 从现在开始，每次你运行 show_in_excel_penguins() 代码时，R 都会在 Excel 中打开企鹅数据框。
- en: Adding Arguments
  id: totrans-21
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 添加参数
- en: You’re probably thinking that this function doesn’t seem very useful. All it
    does is open the penguins data frame. Why would you want to keep doing that? A
    more practical function would let you open *any* data in Excel so you can use
    it in a variety of contexts.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会觉得这个函数似乎没什么用。它做的只是打开企鹅数据框。为什么要一直这样做呢？一个更实用的函数是能让你在 Excel 中打开*任何*数据，这样你可以在各种场景下使用它。
- en: 'The show_in_excel() function does just that: it takes any data frame from R,
    saves it as a CSV file, and opens the CSV file in Excel. Bruno Rodrigues, head
    of the Department of Statistics and Data Strategy at the Ministry of Higher Education
    and Research in Luxembourg, wrote show_in_excel() to easily share data with his
    non-R-user colleagues. Whenever he needed data in a CSV file, he could run this
    function.'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: show_in_excel() 函数正是做这个：它接受 R 中的任何数据框，将其保存为 CSV 文件，并在 Excel 中打开该 CSV 文件。卢森堡高等教育与研究部统计与数据策略部主任
    Bruno Rodrigues 编写了 show_in_excel()，以便轻松与不使用 R 的同事共享数据。每当他需要将数据保存为 CSV 文件时，他就可以运行这个函数。
- en: 'Replace your show_in_excel_penguins() function definition with this slightly
    simplified version of the code that Rodrigues used:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 用 Rodrigues 使用的这个稍微简化版的代码替换你的 show_in_excel_penguins() 函数定义：
- en: '[PRE1]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: This code looks the same as show_in_excel_penguins(), with two exceptions. Notice
    that the first line now says function(data). Items listed within the parentheses
    of the function definition are arguments. If you look farther down, you’ll see
    the second change. Within write_csv(), instead of x = penguins, it now says x
    = data. This allows you to use the function with any data, not just penguins.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码与 show_in_excel_penguins() 完全相同，只有两个例外。注意第一行现在写的是 function(data)。函数定义中的括号内列出的项目是参数。如果往下看，你会看到第二个变化。在
    write_csv() 中，原来的 x = penguins 现在改成了 x = data。这使得你可以使用该函数处理任何数据，而不仅仅是企鹅数据。
- en: 'To use this function, you simply tell show_in_excel() what data to use, and
    the function opens the data in Excel. For example, tell it to open the penguins
    data frame as follows:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用这个函数，你只需告诉 show_in_excel() 要使用哪些数据，函数就会在 Excel 中打开这些数据。例如，告诉它打开企鹅数据框，如下所示：
- en: '[PRE2]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Having created the function with the data argument, now you can run it with
    any data you want to. This code, for example, imports the COVID case data from
    [Chapter 10](chapter10.xhtml) and opens it in Excel:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 创建了带有数据参数的函数后，现在你可以使用任何你想要的数据来运行它。例如，这段代码导入 [第 10 章](chapter10.xhtml) 的 COVID
    病例数据，并在 Excel 中打开：
- en: '[PRE3]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'You can also use show_in_excel() at the end of a pipeline. This code filters
    the covid_data data frame to include only data from California before opening
    it in Excel:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以在管道的末尾使用 show_in_excel()。这段代码将 covid_data 数据框过滤，仅包含来自加利福尼亚的数据，然后在 Excel
    中打开：
- en: '[PRE4]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Rodrigues could have copied the code within the show_in_excel() function and
    rerun it every time he wanted to view his data in Excel. But, by creating a function,
    he was able to write the code just once and then run it as many times as necessary.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: Rodrigues 本可以复制 show_in_excel() 函数中的代码，并在每次想查看数据时重新运行。但通过创建一个函数，他只需编写一次代码，之后可以根据需要多次运行它。
- en: Creating a Function to Format Race and Ethnicity Data
  id: totrans-34
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 创建一个格式化种族和族裔数据的函数
- en: Hopefully now you better understand how functions work, so let’s walk through
    an example function you could use to simplify some of the activities from previous
    chapters.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 希望现在你能更好地理解函数是如何工作的，接下来我们将通过一个示例函数，帮助你简化一些前面章节中的操作。
- en: In [Chapter 11](chapter11.xhtml), when you used the tidycensus package to automatically
    import data from the US Census Bureau, you learned that the census data has many
    variables with nonintuitive names. Say you regularly want to access data about
    race and ethnicity from the American Community Survey, but you can never remember
    which variables enable you to do so. To make your task more efficient, you’ll
    create a get_acs_race_ethnicity() function step-by-step in this section, learning
    some important concepts about custom functions along the way.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第11章](chapter11.xhtml)中，当你使用 tidycensus 包从美国人口普查局自动导入数据时，你了解到人口普查数据有许多变量，其名称不直观。假设你经常需要访问来自美国社区调查的种族和族裔数据，但你总是记不住哪些变量可以提供这些数据。为了提高效率，你将在本节中一步步创建一个
    get_acs_race_ethnicity() 函数，并在此过程中学习一些关于自定义函数的重要概念。
- en: 'A first version of the get_acs_race_ethnicity() function might look like this:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: get_acs_race_ethnicity() 函数的第一个版本可能如下所示：
- en: '[PRE5]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Within the function body, this code calls the get_acs() function from tidycensus
    to retrieve population data at the state level. But instead of returning the function’s
    default output, it updates the hard-to-remember variable names to human-readable
    names, such as White and Black/African American, and saves them as an object called
    race_ethnicity_data. The code then uses the race_ethnicity_data object to return
    that data when the get_acs_race_ethnicity() function is run.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 在函数体内，这段代码调用了 tidycensus 中的 get_acs() 函数，从州级别检索人口数据。但与返回函数的默认输出不同，它将难以记住的变量名更新为易于理解的名称，例如
    White 和 Black/African American，并将其保存为名为 race_ethnicity_data 的对象。然后，代码使用 race_ethnicity_data
    对象来返回 get_acs_race_ethnicity() 函数运行时的数据。
- en: 'To run this function, enter the following:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 要运行这个函数，输入以下内容：
- en: '[PRE6]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Doing so should return data with easy-to-read race and ethnicity group names:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 这样做应该返回易于阅读的种族和族裔组名：
- en: '[PRE7]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'You could improve this function in a few ways. You might want the resulting
    variable names to follow a consistent syntax, for example, so you could use the
    clean_names() function from the janitor package to format them in *snake case*
    (in which all words are lowercase and separated by underscores). However, you
    might also want to have the option of keeping the original variable names. To
    accomplish this, add the clean_variable_names argument to the function definition
    as follows:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过一些方法来改进这个函数。例如，你可能希望结果变量名遵循一致的语法格式，因此可以使用 janitor 包中的 clean_names() 函数将其格式化为
    *snake case*（即所有单词小写，并用下划线分隔）。不过，你也可能希望保留原始的变量名。为此，你可以按以下方式将 clean_variable_names
    参数添加到函数定义中：
- en: '[PRE8]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: This code adds the clean_variable_names argument to get_acs_race _ethnicity()
    and specifies that its value should be FALSE by default. Then, in the function
    body, an if statement says that if the argument is TRUE, the variable names should
    be overwritten by versions formatted in snake case ❶. If the argument is FALSE,
    the variable names remain unchanged.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码将 clean_variable_names 参数添加到 get_acs_race_ethnicity() 中，并指定其默认值为 FALSE。然后，在函数体内，一个
    if 语句表示如果参数为 TRUE，则变量名应被覆盖为 snake case 格式 ❶。如果参数为 FALSE，变量名将保持不变。
- en: 'If you run the function now, nothing should change, because the new argument
    is set to FALSE by default. Try setting clean_variable_names to TRUE as follows:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你现在运行该函数，什么也不会改变，因为新参数默认设置为 FALSE。尝试将 clean_variable_names 设置为 TRUE，如下所示：
- en: '[PRE9]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'This function call should return data with consistent variable names:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数调用应该返回具有一致变量名的数据：
- en: '[PRE10]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Notice that GEOID and NAME now appear as geoid and name.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，GEOID 和 NAME 现在显示为 geoid 和 name。
- en: Now that you’ve seen how to add arguments to two separate functions, you’ll
    learn how to pass arguments from one function to another.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经了解了如何为两个独立的函数添加参数，接下来你将学习如何将参数从一个函数传递到另一个函数。
- en: Using ... to Pass Arguments to Another Function
  id: totrans-53
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 使用 … 将参数传递给另一个函数
- en: The get_acs_race_ethnicity() function you’ve created retrieves population data
    at the state level by passing the geography = "state" argument to the get_acs()
    function. But what if you wanted to obtain county-level or census tract data?
    You could do so using get_acs(), but get_acs_race_ethnicity() isn’t currently
    written in a way that would allow this. How could you modify the function to make
    it more flexible?
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 你创建的 get_acs_race_ethnicity() 函数通过将 geography = "state" 参数传递给 get_acs() 函数来获取州级别的人口数据。但是，如果你想获取县级或普查区的数据呢？你可以使用
    get_acs() 来实现，但当前的 get_acs_race_ethnicity() 并没有以允许这种操作的方式编写。你可以如何修改这个函数，使其更加灵活？
- en: 'Your first idea might be to add a new argument for the level of data to retrieve.
    You could edit the first two lines of the function as follows to add a my_geography
    argument and then use it in the get_acs() function like so:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 您的第一个想法可能是为要检索的数据级别添加一个新参数。您可以如下编辑函数的前两行，以添加一个 my_geography 参数，然后在 `get_acs()`
    函数中使用它，如下所示：
- en: '[PRE11]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: But what if you also want to select the year for which to retrieve data? Well,
    you could add an argument for that as well. However, as you saw in [Chapter 11](chapter11.xhtml),
    the get_acs() function has many arguments, and repeating them all in your code
    would quickly become cumbersome.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，如果您还想选择要检索数据的年份怎么办？那么，您也可以为此添加一个参数。但是，正如您在[第 11 章](chapter11.xhtml)中看到的那样，`get_acs()`
    函数有很多参数，并且在您的代码中重复所有这些参数将很快变得繁琐。
- en: 'The ... syntax gives you a more efficient option. Placing ... in the get_acs_race_ethnicity()
    function allows you to automatically pass any of its arguments to get_acs() by
    including ... in that function as well:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: '... 语法为您提供了一个更有效的选项。将 ... 放置在 `get_acs_race_ethnicity()` 函数中，您可以通过在函数中包含 ...，自动将其任何参数传递给
    `get_acs()`：'
- en: '[PRE12]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Try running your function by passing it the geography argument set to "state":'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试通过传递设置为 "state" 的 geography 参数来运行您的函数：
- en: '[PRE13]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'This should return the following:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 这应该返回以下内容：
- en: '[PRE14]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: You’ll see that the GEOID and NAME variables are uppercase because the clean_variable_names
    argument is set to FALSE by default, and we didn’t change it when using the get_acs_race_ethnicity()
    function.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 您会看到 GEOID 和 NAME 变量是大写的，因为默认情况下 `clean_variable_names` 参数设置为 FALSE，并且我们在使用
    `get_acs_race_ethnicity()` 函数时没有更改它。
- en: 'Alternatively, you could change the value of the argument to get data by county:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，您可以更改参数的值以按县获取数据：
- en: '[PRE15]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'You could also run the function with the geometry = TRUE argument to return
    geospatial data alongside demographic data:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以使用 `geometry = TRUE` 参数运行该函数，以返回地理空间数据以及人口统计数据：
- en: '[PRE16]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'The function should return data like the following:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 该函数应返回如下数据：
- en: '[PRE17]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: The ... syntax allows you to create your own function and pass arguments from
    it to another function without repeating all of that function’s arguments in your
    own code. This approach gives you flexibility while keeping your code concise.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: '... 语法允许您创建自己的函数，并将参数从该函数传递到另一个函数，而无需在您自己的代码中重复该函数的所有参数。这种方法在保持代码简洁的同时，为您提供了灵活性。'
- en: Now let’s look at how to put your custom functions into a package.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们看看如何将您的自定义函数放入一个包中。
- en: Creating a Package
  id: totrans-73
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建一个包
- en: Packages bundle your functions so you can use them in multiple projects. If
    you find yourself copying functions from one project to another, or from a *functions.R*
    file into each new project, that’s a good indication that you should make a package.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 包捆绑您的函数，以便您可以在多个项目中使用它们。如果您发现自己将函数从一个项目复制到另一个项目，或者从 *functions.R* 文件复制到每个新项目中，那么这是一个很好的迹象，表明您应该创建一个包。
- en: While you can run the functions from a *functions.R* file in your own environment,
    this code might not work on someone else’s computer. Other users may not have
    the necessary packages installed, or they may be confused about how your functions’
    arguments work and not know where to go for help. Putting your functions in a
    package makes them more likely to work for everyone, as they include the necessary
    dependencies as well as built-in documentation to help others use the functions
    on their own.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然您可以在自己的环境中从 *functions.R* 文件运行这些函数，但此代码可能无法在其他人的计算机上运行。其他用户可能没有安装必要的包，或者他们可能对您的函数的参数如何工作感到困惑，并且不知道去哪里寻求帮助。将您的函数放入一个包中，可以使它们更有可能为每个人工作，因为它们包括必要的依赖项以及内置的文档，以帮助其他人自己使用这些函数。
- en: Starting the Package
  id: totrans-76
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 启动包
- en: To create a package in RStudio, go to **File****New Project****New Directory**.
    Select **R Package** from the list of options and give your package a name. In
    [Figure 12-2](chapter12.xhtml#fig12-2), I’ve called mine dk. Also decide where
    you want your package to live on your computer. You can leave everything else
    as is.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 要在 RStudio 中创建一个包，请转到 **File****New Project****New Directory**。从选项列表中选择 **R
    Package** 并为您的包命名。在[图 12-2](chapter12.xhtml#fig12-2)中，我将其命名为 dk。同时确定您希望将您的包存储在计算机上的哪个位置。您可以将其他所有内容保持原样。
- en: '![](../images/fig12-2.jpg)'
  id: totrans-78
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/fig12-2.jpg)'
- en: 'Figure 12-2: The RStudio menu for creating your own package'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 图 12-2：用于创建您自己的包的 RStudio 菜单
- en: RStudio will now create and open the package. It should already contain a few
    files, including *hello.R*, which has a prebuilt function called hello() that,
    when run, prints the text Hello, world! in the console. You’ll get rid of this
    and a few other default files so you can start with a clean slate. Delete *hello.R*,
    *NAMESPACE*, and *hello.Rd* in the *man* directory.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: RStudio 现在会创建并打开包。包应该已经包含一些文件，其中包括 *hello.R*，该文件包含一个名为 hello() 的预构建函数，当运行时，会在控制台中打印
    "Hello, world!"。你将删除这个文件和其他一些默认文件，以便从零开始。删除 *hello.R*、*NAMESPACE* 和 *hello.Rd*
    文件（位于 *man* 目录中）。
- en: Adding Functions with use_r()
  id: totrans-81
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 使用 use_r() 添加函数
- en: 'All of the functions in a package should go in separate files in the *R* folder.
    To add these files to the package automatically and test that they work correctly,
    you’ll use the usethis and devtools packages. Install them using install.packages()
    like so:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 包中的所有函数应该放在 *R* 文件夹中的单独文件里。为了自动将这些文件添加到包中并测试它们是否正常工作，你将使用 usethis 和 devtools
    包。可以通过如下方式使用 install.packages() 安装它们：
- en: '[PRE18]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'To add a function to the package, run the use_r() function from the usethis
    package in the console:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 要向包中添加一个函数，可以在控制台中运行 usethis 包中的 use_r() 函数：
- en: '[PRE19]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: The package::function() syntax allows you to use a function without loading
    the associated package. The use_r() function should create a file in the *R* directory
    with the argument name you provide—in this case, the file is called *acs.R*. The
    name itself doesn’t really matter, but it’s a good practice to choose something
    that gives an indication of the functions the file contains. Now you can open
    the file and add code to it. Copy the get_acs_race_ethnicity() function to the
    package.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: package::function() 语法允许你在不加载关联包的情况下使用函数。use_r() 函数应该在 *R* 目录中创建一个文件，文件名为你提供的参数名称——在这种情况下，文件名是
    *acs.R*。文件名本身并不重要，但选择一个能指示文件中包含函数的名称是一种好习惯。现在，你可以打开该文件并添加代码。将 get_acs_race_ethnicity()
    函数复制到包中。
- en: Checking the Package with devtools
  id: totrans-87
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 使用 devtools 检查包
- en: 'You need to change the get_acs_race_ethnicity() function in a few ways to make
    it work in a package. The easiest way to figure out what changes you need to make
    is to use built-in tools to check that your package is built correctly. Run the
    function devtools::check() in the console to perform what is known as an R CMD
    check, a command that runs under the hood to ensure others can install your package
    on their system. Running R CMD check on the dk package outputs this long message:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 你需要以几种方式修改 get_acs_race_ethnicity() 函数，以使其在包中正常工作。弄清楚需要做哪些修改的最简单方法是使用内置工具检查你的包是否构建正确。在控制台中运行
    devtools::check() 函数，执行 R CMD check 这个命令，它在幕后运行，以确保其他人能够在他们的系统上安装你的包。运行 R CMD
    check 对 dk 包进行检查时，会输出这条长消息：
- en: '[PRE20]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: The last part is the most important, so let’s review the output from bottom
    to top. The line 0 errors  | 2 warnings ｘ | 1 note ｘ highlights three levels
    of issues identified in the package. Errors are the most severe, as they mean
    others won’t be able to install your package, while warnings and notes may cause
    problems for others. It’s best practice to eliminate all errors, warnings, and
    notes.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 最后部分是最重要的，因此我们从下到上回顾输出内容。行 0 错误  | 2 警告 ｘ | 1 提示 ｘ 突出了包中识别出的三种问题级别。错误是最严重的，因为它们意味着其他人无法安装你的包，而警告和提示可能会导致其他问题。最佳实践是消除所有的错误、警告和提示。
- en: We’ll start by addressing the note at ❶. To help you understand what R CMD check
    is saying here, I need to explain a bit about how packages work. When you install
    a package using the install.packages() function, it often takes a while. That’s
    because the package you’re telling R to install likely uses functions from other
    packages. To access these functions, R must install these packages (known as *dependencies*)
    for you; after all, it would be a pain if you had to manually install a whole
    set of dependencies every time you installed a new package. But to make sure that
    the appropriate packages are installed for any user of the dk package, you still
    have to make a few changes.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从处理 ❶ 处的提示开始。为了帮助你理解 R CMD check 在这里的提示内容，我需要解释一下包是如何工作的。当你使用 install.packages()
    函数安装包时，这通常需要一些时间。这是因为你告诉 R 安装的包很可能使用了其他包中的函数。为了访问这些函数，R 必须为你安装这些包（被称为 *依赖项*）；毕竟，如果每次安装新包时你都需要手动安装一整套依赖包，那会很麻烦。不过，为了确保
    dk 包的任何用户都能安装适当的包，你仍然需要做一些修改。
- en: R CMD check is saying this package includes several “undefined global functions
    or variables” and “no visible global function definition” for various functions.
    This is because you’re trying to use functions from the tidycensus and janitor
    packages, but you haven’t specified where these functions come from. I can run
    this code in my environment because I have tidycensus and janitor installed, but
    you can’t assume the same of everyone.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: R CMD check 提示该包包含几个“未定义的全局函数或变量”以及多个“无可见的全局函数定义”。这是因为你在尝试使用 tidycensus 和 janitor
    包中的函数，但没有指定这些函数的来源。我可以在我的环境中运行这些代码，因为我已经安装了 tidycensus 和 janitor 包，但不能假设所有人都有相同的环境。
- en: Adding Dependency Packages
  id: totrans-93
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 添加依赖包
- en: 'To ensure the package’s code will work, you need to install tidycensus and
    janitor for users when they install the dk package. To do this, run the use_package()
    function from the usethis package in the console, first specifying "tidycensus"
    for the package argument:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 为了确保包的代码能够正常工作，你需要在用户安装 dk 包时，为他们安装 tidycensus 和 janitor 包。为此，可以在控制台中运行 `use_package()`
    函数，首先指定 "tidycensus" 作为包参数：
- en: '[PRE21]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'You should get the following message:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该看到以下信息：
- en: '[PRE22]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: The Setting active project... line indicates that you’re working in the dk project.
    The second line indicates that the *DESCRIPTION* file has been edited. This file
    provides metadata about the package you’re developing.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: “Setting active project...” 这一行表示你正在工作于 dk 项目中。第二行表示 *DESCRIPTION* 文件已被编辑。此文件提供了关于你正在开发的包的元数据。
- en: Next, add the janitor package the same way you added tidyverse
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，像添加 tidyverse 包一样添加 janitor 包。
- en: '[PRE23]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'which should give you the following output:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 这应该会给你以下输出：
- en: '[PRE24]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'If you open the *DESCRIPTION* file in the root directory of your project, you
    should see the following:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你打开项目根目录下的 *DESCRIPTION* 文件，你应该看到如下内容：
- en: '[PRE25]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: The Imports section at the bottom of the file indicates that when a user installs
    the dk package, the tidycensus and janitor packages will also be imported.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 文件底部的 Imports 部分表明，当用户安装 dk 包时，tidycensus 和 janitor 包也会被导入。
- en: Referring to Functions Correctly
  id: totrans-106
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 正确引用函数
- en: The output from running usethis::use_package(package = "janitor") also included
    the line Refer to functions with tidycensus::fun() (where fun() stands for function
    name). This tells you that in order to use functions from other packages in the
    dk package, you need to specify both the package name and the function name to
    ensure that the correct function is used at all times. On rare occasions, you’ll
    find functions with identical names used across multiple packages, and this syntax
    avoids ambiguity. Remember this line from the R CMD check?
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 运行 `usethis::use_package(package = "janitor")` 后的输出还包括了这一行：Refer to functions
    with tidycensus::fun()（其中 fun() 代表函数名）。这告诉你，为了在 dk 包中使用其他包的函数，你需要同时指定包名和函数名，以确保始终使用正确的函数。在少数情况下，你会发现不同包中有相同名称的函数，这种语法避免了歧义。记得
    R CMD check 中的这一行吗？
- en: '[PRE26]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'It appeared because you were using functions without saying what package they
    came from. The clean_names() function comes from the janitor package, and get_acs()
    comes from tidycensus, so you will need to add these package names before each
    function:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 这个警告出现是因为你在使用函数时没有指定它们来自哪个包。`clean_names()` 函数来自 janitor 包，而 `get_acs()` 来自
    tidycensus 包，因此你需要在每个函数前添加这些包的名称：
- en: '[PRE27]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Now you can run devtools::check() again, and you should see that the notes
    have gone away:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你可以再次运行 `devtools::check()`，应该可以看到这些警告已经消失：
- en: '[PRE28]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: However, there are still two warnings to deal with. You’ll do that next.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，仍然有两个警告需要处理。接下来你将处理这些警告。
- en: Creating Documentation with Roxygen
  id: totrans-114
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 使用 Roxygen 创建文档
- en: The checking for missing documentation entries warning indicates that you need
    to document your get_acs_race_ethnicity() function. One of the benefits of creating
    a package is that you can add documentation to help others use your code. In the
    same way that users can enter ?get_acs() and see documentation about that function,
    you want them to be able to enter ?get_acs_race_ethnicity() to learn how your
    function works.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 缺少文档条目的警告表示你需要为 `get_acs_race_ethnicity()` 函数添加文档。创建包的一个好处是你可以添加文档，帮助他人使用你的代码。就像用户可以输入
    `?get_acs()` 查看该函数的文档一样，你希望他们能够输入 `?get_acs_race_ethnicity()` 来了解你的函数是如何工作的。
- en: 'To create documentation for get_acs_race_ethnicity(), you’ll use Roxygen, a
    documentation tool that uses a package called roxygen2. To get started, place
    your cursor anywhere in your function. Then, in RStudio go to **Code** **Insert
    Roxygen Skeleton**. This should add the following text before the get _acs_race_ethnicity()
    function:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 要为 get_acs_race_ethnicity() 创建文档，你将使用 Roxygen 这一文档工具，该工具使用了名为 roxygen2 的包。开始时，将光标放置在你的函数中的任何位置。然后，在
    RStudio 中，点击 **Code** **Insert Roxygen Skeleton**。这将会在 get_acs_race_ethnicity()
    函数之前添加以下文本：
- en: '[PRE29]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'This text is the documentation’s skeleton. Each line starts with the special
    characters #'', which indicate that you’re working with Roxygen. Now you can edit
    the text to create your documentation. Begin by replacing Title with a sentence
    that describes the function:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: '这段文本是文档的骨架。每一行都以特殊字符 #'' 开头，表示你正在使用 Roxygen。现在，你可以编辑这些文本来创建文档。从用一句话描述该函数来替换
    Title 开始：'
- en: '[PRE30]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Next, turn your attention to the lines beginning with @param. Roxygen automatically
    creates one of these lines for each function argument, but it’s up to you to fill
    them in with a description. Begin by describing what the clean_variable_names
    argument does. Next, specify that the ... will pass additional arguments to the
    tidycensus::get_acs() function:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，关注以 @param 开头的行。Roxygen 会为每个函数参数自动创建一行，但你需要填写每一行的描述。首先描述 clean_variable_names
    参数的作用。接着，指定 ... 将会把额外的参数传递给 tidycensus::get_acs() 函数：
- en: '[PRE31]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'The @return line should tell the user what the get_acs_race_ethnicity() function
    returns. In this case, it returns data, which you document as follows:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: '@return 行应告知用户 get_acs_race_ethnicity() 函数返回的内容。在本例中，它返回数据，你可以按照以下方式进行文档说明：'
- en: '[PRE32]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: After @return is @export. You don’t need to change anything here. Most functions
    in a package are known as *exported functions*, meaning they’re available to users
    of the package. In contrast, internal functions, which are used only by the package
    developers, don’t have @export in the Roxygen skeleton.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 在 @return 之后是 @export。你无需在此做任何更改。包中的大多数函数被称为*导出函数*，意味着它们对包的用户可用。相比之下，内部函数仅供包开发者使用，在
    Roxygen 骨架中没有 @export。
- en: The last section is @examples. This is where you can give examples of code that
    users can run to learn how the function works. Doing this introduces some complexity
    and isn’t required, so you can skip it here and delete the line with @examples
    on it.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一部分是 @examples。在这里，你可以提供用户可以运行的代码示例，以便了解该函数的工作原理。由于这增加了复杂性，因此不是必须的，你可以跳过它并删除包含
    @examples 的那一行。
- en: NOTE
  id: totrans-126
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 注意
- en: '*If you want to learn more about adding examples to your documentation, the
    second edition of Hadley Wickham and Jenny Bryan’s book* R Packages *is a great
    resource.*'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: '*如果你想了解更多关于如何为文档添加示例的内容，Hadley Wickham 和 Jenny Bryan 的第二版《R Packages》一书是一个很好的资源。*'
- en: Now that you’ve added documentation with Roxygen, run devtools::document() in
    the console. This should create a *get_acs_race_ethnicity.Rd* documentation file
    in the *man* directory using the very specific format that R packages require.
    You’re welcome to look at it, but you can’t change it; it’s read-only.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经使用 Roxygen 添加了文档，请在控制台中运行 devtools::document()。这应该会在 *man* 目录中创建一个 *get_acs_race_ethnicity.Rd*
    文档文件，采用 R 包所要求的非常特定的格式。你可以查看它，但不能更改它；它是只读的。
- en: 'Running the function should also create a *NAMESPACE* file, which lists the
    functions that your package makes available to users. It should look like this:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 运行该函数时还应创建一个*NAMESPACE* 文件，该文件列出你包中可供用户使用的函数。它应该像这样：
- en: '[PRE33]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Your get_acs_race_ethnicity() function is now almost ready for users.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 你的 get_acs_race_ethnicity() 函数现在几乎已经可以供用户使用了。
- en: Adding a License and Metadata
  id: totrans-132
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 添加许可证和元数据
- en: 'Run devtools::check() again to see if you’ve fixed the issues that led to the
    warnings. The warning about missing documentation should no longer be there. However,
    you do still get one warning:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 再次运行 devtools::check() 来检查是否修复了导致警告的问题。关于缺失文档的警告应该不再出现。然而，你仍然会看到一个警告：
- en: '[PRE34]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: This warning reminds you that you have not given your package a license. If
    you plan to make your package publicly available, choosing a license is important
    because it tells other people what they can and cannot do with your code. For
    information about how to choose the right license for your package, see *[https://choosealicense.com](https://choosealicense.com)*.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 这个警告提醒你，你还没有为你的包指定许可。如果你计划公开发布你的包，选择一个许可证非常重要，因为它告诉其他人他们可以做什么和不能做什么。有关如何为你的包选择合适的许可证，请参阅*[https://choosealicense.com](https://choosealicense.com)*。
- en: 'In this example, you’ll use the MIT license, which allows users to do essentially
    whatever they want with your code, by running usethis::use_mit_license(). The
    usethis package has similar functions for other common licenses. You should get
    the following output:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 在本例中，你将使用 MIT 许可证，通过运行 usethis::use_mit_license()，该许可证允许用户基本上随意使用你的代码。usethis
    包有类似的函数可以用于其他常见许可证。你应该会看到如下输出：
- en: '[PRE35]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'The use_mit_license() function handles a lot of the tedious parts of adding
    a license to your package. Most importantly for our purposes, it specifies the
    license in the *DESCRIPTION* file. If you open it, you should see this confirmation
    that you’ve added the MIT license:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: use_mit_license() 函数处理了将许可证添加到包中的许多繁琐部分。对我们来说，最重要的是，它在 *DESCRIPTION* 文件中指定了许可证。如果你打开它，应该会看到你已经添加了
    MIT 许可证的确认信息：
- en: '[PRE36]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'In addition to the license, the *DESCRIPTION* file contains metadata about
    the package. You can make a few changes to identify its title and add an author,
    a maintainer, and a description. The final *DESCRIPTION* file might look something
    like this:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 除了许可证，*DESCRIPTION* 文件还包含关于包的元数据。你可以进行一些更改，以标识其标题，并添加作者、维护者和描述。最终的 *DESCRIPTION*
    文件可能如下所示：
- en: '[PRE37]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Having made these changes, run devtools::check() one more time to make sure
    everything is in order:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 做完这些更改后，再次运行 devtools::check()，确保一切正常：
- en: '[PRE38]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: This is exactly what you want to see!
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 这正是你想要看到的！
- en: Writing Additional Functions
  id: totrans-145
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 编写附加函数
- en: 'You’ve now got a package with one working function in it. If you wanted to
    add more functions, you would follow the same procedure:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经有了一个包含一个可用函数的包。如果你想添加更多的函数，可以遵循相同的步骤：
- en: 1.  Create a new *.R* file with usethis::use_r() or copy another function to
    the existing *.R* file.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 1.  使用 usethis::use_r() 创建一个新的 *.R* 文件，或将另一个函数复制到现有的 *.R* 文件中。
- en: 2.  Develop your function using the package::function() syntax to refer to functions
    from other packages.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 2.  使用 package::function() 语法开发你的函数，引用其他包中的函数。
- en: 3.  Add any dependency packages with use_package().
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 3.  使用 use_package() 添加任何依赖包。
- en: 4.  Add documentation for your function.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 4.  为你的函数添加文档。
- en: 5.  Run devtools::check() to make sure you did everything correctly.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 5.  运行 devtools::check() 确保你做的一切都正确。
- en: Your package can contain a single function, like dk, or as many functions as
    you want.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 你的包可以包含一个函数，比如 dk，也可以包含任意数量的函数。
- en: Installing the Package
  id: totrans-153
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 安装包
- en: Now you’re ready to install and use the new package. When you’re developing
    your own package, installing it for your own use is relatively straightforward.
    Simply run devtools::install(), and the package will be ready for you to use in
    any project.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经准备好安装并使用新的包。当你在开发自己的包时，为自己安装它是相对简单的。只需运行 devtools::install()，包就会准备好在任何项目中使用。
- en: Of course, if you’re developing a package, you’re likely doing it not just for
    yourself but for others as well. The most common way to make your package available
    to others is with the code-sharing website GitHub. The details of how to put your
    code on GitHub are beyond what I can cover here, but the book *Happy Git and GitHub
    for the useR* by Jenny Bryan (self-published at *[https://happygitwithr.com](https://happygitwithr.com)*)
    is a great place to start.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，如果你在开发一个包，你可能不仅是为了自己，而是为了其他人。将你的包提供给他人最常见的方式是使用代码共享网站 GitHub。如何将代码上传到 GitHub
    的细节超出了我在这里能涉及的范围，但 Jenny Bryan 自出版的书 *Happy Git and GitHub for the useR*（网址 *[https://happygitwithr.com](https://happygitwithr.com)*)
    是一个很好的入门书籍。
- en: I’ve pushed the dk package to GitHub, and you can find it at *[https://github.com/dgkeyes/dk](https://github.com/dgkeyes/dk)*.
    If you’d like to install it, first make sure you have the remotes package installed,
    then run the code remotes::install_github("dgkeyes/dk") in the console.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 我已经将 dk 包推送到 GitHub，你可以在 *[https://github.com/dgkeyes/dk](https://github.com/dgkeyes/dk)*
    找到它。如果你想安装它，首先确保安装了 remotes 包，然后在控制台中运行代码 remotes::install_github("dgkeyes/dk")。
- en: Summary
  id: totrans-157
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 总结
- en: 'In this chapter, you saw that packages are useful because they let you bundle
    several elements needed to reliably run your code: a set of functions, instructions
    to automatically install dependency packages, and code documentation.'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你看到包非常有用，因为它们让你将多个元素打包在一起，确保代码能够可靠运行：一组函数、自动安装依赖包的指令以及代码文档。
- en: Creating your own R package is especially beneficial when you’re working for
    an organization, as packages can allow advanced R users to help colleagues with
    less experience. When Travis Gerke and Garrick Aden-Buie provided researchers
    at the Moffitt Cancer Center with a package that contained functions for easily
    accessing their databases, the researchers began to use R more creatively.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 创建你自己的R包在你为一个组织工作时尤其有益，因为包可以让高级R用户帮助经验较少的同事。当Travis Gerke和Garrick Aden-Buie为莫菲特癌症中心的研究人员提供了一个包含易于访问其数据库功能的包时，这些研究人员开始更加富有创意地使用R。
- en: If you create a package, you can also guide people to use R in the way you think
    is best. Packages are a way to ensure that others follow best practices (without
    even being aware they are doing so). They make it easy to reuse functions across
    projects, help others, and adhere to a consistent style.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你创建了一个包，你还可以引导他人按照你认为最好的方式使用R语言。包是一种确保他人遵循最佳实践的方式（即使他们未意识到这一点）。它们使得跨项目重用函数变得容易，能够帮助他人，并保持一致的风格。
- en: Additional Resources
  id: totrans-161
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 额外资源
- en: Malcolm Barrett, “Package Development with R,” online course, accessed December
    2, 2023, *[https://rfortherestofus.com/courses/package-development](https://rfortherestofus.com/courses/package-development)*.
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Malcolm Barrett, “使用R进行包开发”，在线课程，访问日期：2023年12月2日，*[https://rfortherestofus.com/courses/package-development](https://rfortherestofus.com/courses/package-development)*。
- en: 'Hadley Wickham and Jennifer Bryan, *R Packages*, 2nd ed. (Sebastopol, CA: O’Reilly
    Media, 2023), *[https://r-pkgs.org](https://r-pkgs.org)*.'
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Hadley Wickham和Jennifer Bryan, *R Packages*, 第2版（加利福尼亚州塞巴斯托波尔：O'Reilly Media，2023年），*[https://r-pkgs.org](https://r-pkgs.org)*。
- en: Wrapping Up
  id: totrans-164
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 总结
- en: R was invented in 1993 as a tool for statistics, and in the years since, it
    has been used for plenty of statistical analysis. But over the last three decades,
    R has also become a tool that can do much more than statistics.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: R语言于1993年作为一款统计工具诞生，至今它已经被广泛应用于各种统计分析。但在过去三十年里，R语言也成为了一个可以做远超统计分析的工具。
- en: As you’ve seen in this book, R is great for making visualizations. You can use
    it to create high-quality graphics and maps, make your own theme to keep your
    visuals consistent and on-brand, and generate tables that look good and communicate
    well. Using R Markdown or Quarto, you can create reports, presentations, and websites.
    And best of all, these documents are all reproducible, meaning that updating them
    is as easy as rerunning your code. Finally, you’ve seen that R can help you automate
    how you access data, as well as assist you in collaborating with others through
    the functions and packages you create.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你在本书中看到的，R语言非常适合制作可视化图表。你可以用它来创建高质量的图形和地图，制作自己的主题以保持视觉效果的一致性并符合品牌形象，还能生成既美观又有效传达信息的表格。使用R
    Markdown或Quarto，你可以创建报告、演示文稿和网站。最棒的是，这些文档都是可重复的，这意味着更新它们就像重新运行你的代码一样简单。最后，你也看到R能够帮助你自动化数据访问，并通过你创建的函数和包来促进与他人的协作。
- en: If R was new to you when you started this book, I hope you now feel inspired
    to use it. If you’re an experienced R user, I hope this book has shown you some
    ways to use R that you hadn’t previously considered. No matter your background,
    my hope is that you now understand how to use R like a pro. Because it isn’t just
    a tool for statisticians—R is a tool for the rest of us too.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 如果当你开始阅读这本书时R对你来说是全新的，我希望现在你已经有了使用它的灵感。如果你是一个经验丰富的R用户，我希望这本书能够展示一些你之前未曾考虑过的R使用方式。无论你的背景如何，我希望你现在能够像专业人士一样使用R。因为它不仅仅是统计学家的工具——R也是我们所有人的工具。
