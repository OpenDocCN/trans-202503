- en: Chapter 6. Network Security and PKI
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第 6 章 网络安全与 PKI
- en: 'As discussed in the previous chapter, Android includes various cryptographic
    providers that implement most modern cryptographic primitives: hashing, symmetric
    and asymmetric encryption, and message authentication codes. Those primitives
    can be combined to implement secure communication, but even a subtle mistake can
    result in serious vulnerabilities, so the preferred way to implement secure communication
    is to use standard protocols that are designed to protect the privacy and integrity
    of data transferred across a network.'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 如前一章所述，Android 包括各种加密提供程序，这些提供程序实现了大多数现代加密原语：哈希、对称和非对称加密以及消息认证码。这些原语可以结合使用以实现安全通信，但即使是微小的错误也可能导致严重的漏洞，因此实现安全通信的首选方式是使用设计用于保护跨网络传输的数据的隐私和完整性的标准协议。
- en: The most widely used secure protocols are Secure Sockets Layer (SSL) and Transport
    Layer Security (TLS). Android supports these protocols by providing an implementation
    of the standard Java Secure Socket Extension (JSSE). In this chapter, we’ll briefly
    discuss the JSSE architecture and then provide some details about Android’s JSSE
    implementation. Our description of Android’s SSL stack is focused on certificate
    validation and trust anchor management, which are tightly integrated into the
    platform and are one of the biggest differences that set it apart from other JSSE
    implementations.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 最广泛使用的安全协议是安全套接字层（SSL）和传输层安全（TLS）。Android 通过提供标准的 Java 安全套接字扩展（JSSE）实现来支持这些协议。在本章中，我们将简要讨论
    JSSE 架构，然后提供一些关于 Android 的 JSSE 实现的细节。我们对 Android SSL 堆栈的描述重点是证书验证和信任锚管理，这些是与平台紧密集成的，并且是将其与其他
    JSSE 实现区分开的最大特点之一。
- en: Note
  id: totrans-3
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '*While TLS and SSL are technically different protocols, we will usually use
    the more common term* SSL *to refer to both, and will only distinguish between
    SSL and TLS when discussing protocol differences.*'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: '*虽然 TLS 和 SSL 在技术上是不同的协议，但我们通常使用更常见的术语* SSL *来指代两者，并且仅在讨论协议差异时才区分 SSL 和 TLS。*'
- en: PKI and SSL Overview
  id: totrans-5
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: PKI 和 SSL 概述
- en: TLS^([[58](#ftn.ch06fn01)]) and SSL^([[59](#ftn.ch06fn02)]) (its predecessor)
    are secure point-to-point communication protocols designed to provide (optional)
    authentication, message confidentiality, and message integrity between two parties
    communicating over TCP/IP. They use a combination of symmetric and asymmetric
    encryption to implement message confidentiality and integrity, and rely heavily
    on public key certificates to implement authentication.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: TLS^([[58](#ftn.ch06fn01)]) 和 SSL^([[59](#ftn.ch06fn02)])（其前身）是安全的点对点通信协议，旨在提供（可选的）认证、消息机密性和消息完整性，供通过
    TCP/IP 通信的双方使用。它们结合使用对称加密和非对称加密来实现消息的机密性和完整性，并在很大程度上依赖公钥证书来实现身份验证。
- en: To start a secure SSL channel, a client contacts a server and sends the SSL
    protocol version it supports, as well as a list of suggested cipher suites. A
    *cipher suite* is a set of algorithms and key sizes used for authentication, key
    agreement, encryption, and integrity. In order to establish a secure channel,
    the server and client negotiate a commonly supported cipher suite, and then verify
    each other’s identity based on their certificates. Finally, the communicating
    parties agree on a symmetric encryption algorithm and compute a shared symmetric
    key that is used to encrypt all subsequent communication. Typically, only the
    server’s identity is verified (*server authentication*) and not the client’s.
    The SSL protocol supports verifying client identity as well (*client authentication*),
    but it is used much more rarely.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 要启动安全的 SSL 通道，客户端首先联系服务器并发送其支持的 SSL 协议版本，以及建议的加密套件列表。*加密套件*是一组用于身份验证、密钥协商、加密和完整性的算法和密钥大小。为了建立安全通道，服务器和客户端协商一个共同支持的加密套件，然后根据各自的证书验证对方的身份。最后，通信双方商定一个对称加密算法，并计算出一个共享的对称密钥，用于加密所有后续的通信。通常，只验证服务器的身份（*服务器认证*），而不是客户端的身份。SSL
    协议也支持验证客户端身份（*客户端认证*），但它的使用较为罕见。
- en: Note
  id: totrans-8
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '*While anonymous (unauthenticated) cipher suites such as* TLS_DH_anon_WITH_AES_128_CBC_SHA
    *are defined in SSL specifications, they are vulnerable to manin-the-middle (MITM)
    attacks and are typically only employed when SSL is used as part of a more complex
    protocol that has other means to ensure authentication.*'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: '*虽然像* TLS_DH_anon_WITH_AES_128_CBC_SHA *这样的匿名（未经认证）加密套件在 SSL 规范中有定义，但它们容易受到中间人攻击（MITM），通常仅在
    SSL 作为更复杂协议的一部分时使用，该协议有其他方法来确保认证。*'
- en: Public Key Certificates
  id: totrans-10
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 公钥证书
- en: As mentioned in the previous section, SSL relies on public key certificates
    to implement authentication. A public key certificate is a construct that binds
    an identity to a public key. For *X.509 certificates*, which are used in SSL communication,
    the “identity” is a set of attributes typically including a common name (CN),
    organization, and location that form the entity’s distinguished name (DN). Other
    major attributes of X.509 certificates are the issuer DN, validity period, and
    a set of extensions, which may be additional entity attributes or pertain to the
    certificate itself (for example, intended key usage).
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 如前节所述，SSL 依赖公钥证书来实现身份验证。公钥证书是一种将身份与公钥绑定的构造。对于用于 SSL 通信的 *X.509 证书*，“身份”是一组通常包括常用名称（CN）、组织和位置的属性，形成实体的区分名称（DN）。X.509
    证书的其他主要属性包括颁发者 DN、有效期以及一组扩展字段，这些扩展可能是附加的实体属性，或与证书本身相关（例如，预期的密钥使用）。
- en: The binding is formed by applying a digital signature over the entity’s public
    key and all additional attributes to produce a digital certificate. The signing
    key used may be the certified entity’s own private key, in which case the certificate
    is referred to as *self-signed*, or it may belong to a trusted third party called
    a *certificate authority (CA)*.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 绑定是通过对实体的公钥及所有附加属性应用数字签名来生成数字证书的。所使用的签名密钥可以是认证实体自身的私钥，在这种情况下，证书被称为*自签名*证书，或者它可能属于一个称为*证书颁发机构（CA）*的受信任第三方。
- en: The contents of a typical X.509 server certificate as parsed by the OpenSSL
    `x509` command are shown in [Example 6-1](ch06.html#xdot509_certificate_contentscomma_as_par
    "Example 6-1. X.509 certificate contents, as parsed by OpenSSL"). This particular
    certificate binds the *C=US, ST=California, L=Mountain View, O=Google Inc, CN=*.googlecode.com*
    DN ➋ and a set of alternative DNS names ➍ to the server’s 2048-bit RSA key ➌ and
    is signed with the private key of the Google Internet Authority G2 CA ➊.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: OpenSSL `x509` 命令解析的典型 X.509 服务器证书的内容见[示例 6-1](ch06.html#xdot509_certificate_contentscomma_as_par
    "示例 6-1. 由 OpenSSL 解析的 X.509 证书内容")。这个特定的证书将 *C=US, ST=California, L=Mountain
    View, O=Google Inc, CN=*.googlecode.com* DN ➋ 和一组备用的 DNS 名称 ➍ 绑定到服务器的 2048 位 RSA
    密钥 ➌，并由 Google Internet Authority G2 CA ➊ 的私钥签名。
- en: Example 6-1. X.509 certificate contents, as parsed by OpenSSL
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 6-1. 由 OpenSSL 解析的 X.509 证书内容
- en: '[PRE0]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Direct Trust and Private CAs
  id: totrans-16
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 直接信任和私有 CA
- en: If an SSL client communicates with a limited number of servers, it can be preconfigured
    with a set of server certificates that it trusts (called *trust anchors*), and
    deciding whether to trust a remote party becomes simply a matter of checking whether
    its certificate is in that set. This model allows for fine-grained control over
    whom clients trust, but makes it harder to rotate or upgrade server keys, which
    requires issuing a new self-signed certificate.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一个 SSL 客户端与有限数量的服务器进行通信，它可以预先配置一组它信任的服务器证书（称为*信任锚*），此时决定是否信任远程方就变得非常简单，只需检查其证书是否在该信任集内即可。这个模型允许对客户端信任的对象进行细粒度控制，但也使得更换或升级服务器密钥变得更加困难，因为这需要颁发一个新的自签名证书。
- en: This problem can be solved by using a *private CA* and configuring both clients
    and servers to use it as the single trust anchor. In this model, SSL parties do
    not check for a particular entity certificate, but trust any certificate issued
    by the private CA. This allows for transparent key and certificate upgrades, without
    the need to upgrade SSL clients and servers as long as the CA certificate is still
    valid. The downside is that at the same time, this single-CA model creates a single
    point of failure; if the CA key is compromised, whoever has obtained access to
    it can issue fraudulent certificates that all clients will trust (as we will see
    later, this is not limited to private CAs). Recovering from this situation requires
    updating all clients and replacing the CA certificate.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 这个问题可以通过使用*私有 CA*来解决，并配置客户端和服务器都使用它作为唯一的信任锚。在这种模型中，SSL 双方不会检查特定的实体证书，而是信任任何由私有
    CA 颁发的证书。这允许透明地进行密钥和证书的升级，而无需升级 SSL 客户端和服务器，只要 CA 证书仍然有效。缺点是，这种单一 CA 模型会创建一个单点故障；如果
    CA 密钥被泄露，任何获得密钥的人都可以颁发所有客户端都会信任的伪造证书（正如我们稍后将看到的，这不仅仅限于私有 CA）。从这种情况恢复需要更新所有客户端并替换
    CA 证书。
- en: Another problem with this model is that it cannot be used for clients that do
    not know in advance what servers they will need to connect to— usually generic
    Internet clients such as web browsers, email applications, and messaging or VoIP
    clients. Such generic clients are typically configured with a set of trust anchors
    that includes well-known issuers, which we call *public CAs*. While certain guidelines
    and requirements exist, the process of selecting public CAs to include as default
    trust anchors varies widely between browsers and OSes. For example, in order to
    include a CA certificate as a trust anchor in its products, Mozilla requires that
    the CA has a public *Certificate Policy and Certification Practice Statement (CP/CPS)*
    document, enforces multi-factor authentication for operator accounts, and that
    the CA certificate does not issue end-entity certificates directly.^([[60](#ftn.ch06fn03)])
    Other vendors can have less stringent requirements. Current versions of most OSes
    and browsers ship with more than 100 CA certificates included as trust anchors.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 这个模型的另一个问题是，它无法用于那些无法预先知道需要连接到哪些服务器的客户端——通常是通用的互联网客户端，如网页浏览器、电子邮件应用程序和消息或VoIP客户端。此类通用客户端通常配置有一组信任锚点，其中包括知名发行者，我们称之为*公共CA*。尽管存在某些指导原则和要求，选择公共CA作为默认信任锚点的过程在不同浏览器和操作系统之间差异很大。例如，为了将CA证书作为信任锚点包含在其产品中，Mozilla要求该CA必须有公开的*证书政策和认证实践声明（CP/CPS）*文件，要求操作员账户实施多因素认证，并且该CA证书不得直接颁发终端实体证书。^([[60](#ftn.ch06fn03)])其他供应商可能有较宽松的要求。目前，大多数操作系统和浏览器的最新版本都包含超过100个作为信任锚点的CA证书。
- en: Public Key Infrastructure
  id: totrans-20
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 公钥基础设施
- en: When certificates are issued by public CAs, some sort of identity verification
    is performed before issuing the certificate. The verification process varies vastly
    between CAs and types of certificates issued, ranging from accepting automatic
    email address confirmation (for cheap server certificates) to requiring multiple
    forms of government-issued ID and company registration documents (for Extended
    Validation, or EV, certificates).
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 当证书由公共CA颁发时，通常会在颁发证书之前进行某种形式的身份验证。验证过程在不同CA和所颁发证书的类型之间差异很大，从接受自动电子邮件地址确认（用于廉价的服务器证书）到要求多个政府颁发的身份证明和公司注册文件（用于扩展验证（EV）证书）。
- en: Public CAs depend on multiple people, systems, procedures, and policies in order
    to perform entity verification and to create, manage, and distribute certificates.
    The set of those parties and systems is referred to as a *Public Key Infrastructure
    (PKI)*. PKIs can be infinitely complex, but in the context of secure communication,
    and SSL in particular, the most important pieces are the CA certificates, which
    act as trust anchors and are used when validating the identity of communication
    parties. Therefore, managing trust anchors will be one of the key points in our
    discussion of Android’s SSL and PKI implementation. [Figure 6-1](ch06.html#pki_entities
    "Figure 6-1. PKI entities") shows a simplified representation of a typical PKI.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 公共证书授权机构（CA）依赖于多个人员、系统、程序和政策来执行实体验证，以及创建、管理和分发证书。这些参与方和系统的集合被称为*公钥基础设施（PKI）*。PKI可以是无限复杂的，但在安全通信的上下文中，特别是在SSL的应用中，最重要的部分是CA证书，它们充当信任锚点，并在验证通信方身份时使用。因此，管理信任锚点将是我们讨论Android
    SSL和PKI实现的关键点之一。[图 6-1](ch06.html#pki_entities "图 6-1. PKI 实体")展示了一个典型PKI的简化表示。
- en: '![PKI entities](figs/web/06fig01.png.jpg)'
  id: totrans-23
  prefs: []
  type: TYPE_IMG
  zh: '![PKI 实体](figs/web/06fig01.png.jpg)'
- en: Figure 6-1. PKI entities
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6-1. PKI 实体
- en: Here, a person or server that holds a certificate is referred to as an *end
    entity (EE)*. To obtain a certificate, an end entity sends a certificate request
    to a registration authority (RA). The RA obtains some proof of identity from the
    EE and verifies its identity according to the CA’s policy requirements. After
    the RA has established the identity of the EE, it checks that it matches the contents
    of the certificate request, and if so, forwards the request to the issuing CA.
    An issuing CA signs the EE certificate request in order to generate EE certificates
    and maintains revocation information (discussed in the next section) about the
    issued certificates. On the other hand, a root CA does not sign EE certificates
    directly but only signs certificates for issuing CAs and revocation information
    concerning issuing CAs. A root CA is used very rarely and is usually kept offline
    in order to increase the security of its keys.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，持有证书的人员或服务器被称为*终端实体（EE）*。为了获得证书，终端实体向注册机构（RA）发送证书请求。RA 从 EE 获取一些身份验证信息，并根据
    CA 的政策要求验证其身份。在 RA 确认 EE 的身份后，RA 检查该身份是否与证书请求的内容匹配，如果匹配，则将请求转发给颁发 CA。颁发 CA 对 EE
    证书请求进行签名，从而生成 EE 证书，并维护有关已颁发证书的吊销信息（将在下一节讨论）。另一方面，根 CA 不直接签署 EE 证书，而只签署颁发 CA 的证书以及关于颁发
    CA 的吊销信息。根 CA 的使用非常少，通常保持离线状态，以提高其密钥的安全性。
- en: 'For the PKI sketched in [Figure 6-1](ch06.html#pki_entities "Figure 6-1. PKI
    entities"), an EE certificate is associated with two CA certificates: the issuing
    CA’s certificate, which signed it, and the root CA’s certificate, which signed
    the issuing CA’s certificate. The three certificates form a certificate chain
    (also called a certification path). The chain begins with the EE certificate and
    terminates with the root CA certificate. In order for an EE certificate to be
    trusted, its certification path needs to lead to a certificate the system trusts
    implicitly (trust anchor). While intermediate certificates can be used as trust
    anchors, this role is usually performed by root CA certificates.'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 在[图 6-1](ch06.html#pki_entities "图 6-1. PKI 实体")中描述的 PKI 中，EE 证书与两个 CA 证书相关联：签署该证书的颁发
    CA 的证书和签署颁发 CA 证书的根 CA 的证书。这三个证书形成一个证书链（也称为认证路径）。链条以 EE 证书开始，以根 CA 证书结束。为了让 EE
    证书被信任，它的认证路径需要指向系统隐式信任的证书（信任锚）。虽然中间证书可以用作信任锚，但通常由根 CA 证书执行此角色。
- en: Certificate Revocation
  id: totrans-27
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 证书吊销
- en: In addition to issuing certificates, CAs can mark a certificate as invalid by
    revoking it. *Revoking* involves adding the certificate serial number and a revocation
    reason to a certificate revocation list (CRL) that the CA signs and periodically
    publishes. Entities validating a certificate can then check to see if it has been
    revoked by searching for its serial number (which is unique within a given CA)
    in the issuing CA’s current CRL. [Example 6-2](ch06.html#crl_file_contents "Example 6-2. CRL
    file contents") shows the contents of a sample CRL file, issued by the Google
    Internet Authority G2\. In this example, certificates with the serial numbers
    `40BF8571DD53E3BB` ➊ and `0A9F21196A442E45` ➋ have been revoked.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 除了颁发证书外，CA 还可以通过吊销证书来标记证书为无效。*吊销*涉及将证书序列号和吊销原因添加到 CA 签名并定期发布的证书吊销列表（CRL）中。验证证书的实体可以通过搜索其序列号（在给定的
    CA 中是唯一的）来检查证书是否已被吊销，查看它是否出现在颁发 CA 当前的 CRL 中。[示例 6-2](ch06.html#crl_file_contents
    "示例 6-2. CRL 文件内容")展示了由 Google Internet Authority G2 颁发的示例 CRL 文件内容。在这个例子中，序列号为
    `40BF8571DD53E3BB` ➊ 和 `0A9F21196A442E45` ➋ 的证书已被吊销。
- en: Example 6-2. CRL file contents
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 6-2. CRL 文件内容
- en: '[PRE1]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Revocation status can also be checked without fetching the full list of all
    revoked certificates by using the Online Certificate Status Protocol (OCSP).^([[61](#ftn.ch06fn04)])
    CRL and OCSP URIs are often included as extensions in certificates so that verifying
    parties do not need to know their location in advance. All public CAs maintain
    revocation information, but in practice a lot of SSL clients either do not check
    revocation at all or allow connections (possibly with a warning) even if the remote
    party’s certificate is revoked. The main reasons for this lenient behavior of
    SSL clients are the overhead associated with fetching current revocation information,
    and ensuring connectivity. While delta CRLs (CRLs that only contain the difference,
    or *delta*, from the previous CRL version) and local caching alleviate the problem
    to some extent, CRLs for major CAs are typically huge and need to be downloaded
    before an SSL connection is established, which adds user-visible latency. OCSP
    improves this situation but still requires a connection to a different server,
    which again adds latency.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用在线证书状态协议（OCSP），可以在不获取所有被吊销证书的完整列表的情况下检查吊销状态。^([[61](#ftn.ch06fn04)]) CRL
    和 OCSP URI 通常作为扩展包含在证书中，以便验证方无需提前知道其位置。所有公共 CA 都维护吊销信息，但实际上，很多 SSL 客户端要么根本不检查吊销，要么即使远程方的证书被吊销，也允许连接（可能带有警告）。这种
    SSL 客户端宽松行为的主要原因是获取当前吊销信息所需的开销以及确保连接的可用性。虽然增量 CRL（仅包含与上一个 CRL 版本的差异或 *增量*）和本地缓存在某种程度上缓解了这个问题，但主要
    CA 的 CRL 通常非常庞大，必须在建立 SSL 连接之前下载，这会增加用户可见的延迟。OCSP 改善了这种情况，但仍然需要连接到另一台服务器，这再次增加了延迟。
- en: In either case, revocation information may simply be unavailable, due to a network
    or configuration problem in a CA’s infrastructure. For a major CA, a revocation
    database outage could disable a large number of secure sites, which translates
    directly to financial loss for their operators. Lastly, nobody likes connection
    errors and when faced with a revocation error, most users will simply find another,
    less strict SSL client that simply “works.”
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 无论哪种情况，由于 CA 基础设施中的网络或配置问题，吊销信息可能根本不可用。对于一个主要的 CA，吊销数据库故障可能会使大量安全站点瘫痪，这直接转化为其运营者的经济损失。最后，没有人喜欢连接错误，面对吊销错误时，大多数用户只会找到另一个更宽松的
    SSL 客户端，它能“正常工作”。
- en: JSSE Introduction
  id: totrans-33
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: JSSE 介绍
- en: We’ll briefly introduce the architecture and main components of JSSE here. (For
    complete coverage, see the official *JSSE Reference Guide*.^([[62](#ftn.ch06fn05)]))
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在这里简要介绍 JSSE 的架构和主要组件。（要全面了解，请参见官方的 *JSSE参考指南*。^([[62](#ftn.ch06fn05)]))
- en: 'The JSSE API lives in the `javax.net` and `javax.net.ssl` packages and provides
    classes that represent the following features:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: JSSE API 位于 `javax.net` 和 `javax.net.ssl` 包中，提供表示以下功能的类：
- en: SSL client and server sockets
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: SSL 客户端和服务器套接字
- en: An engine for producing and consuming SSL streams (`SSLEngine`)
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个用于生成和消费 SSL 流的引擎（`SSLEngine`）
- en: Factories for creating sockets
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建套接字的工厂
- en: A secure socket context class (`SSLContext`) that creates secure socket factories
    and engines
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个创建安全套接字工厂和引擎的安全套接字上下文类（`SSLContext`）
- en: PKI-based key and trust managers and factories to create them
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基于 PKI 的密钥和信任管理器以及用于创建它们的工厂
- en: A class for HTTPS (HTTP over TLS, specified in *RFC 2818*^([[63](#ftn.ch06fn06)]))
    URL connections (`HttpsURLConnection`)
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个用于 HTTPS（TLS 上的 HTTP，指定于 *RFC 2818*^([[63](#ftn.ch06fn06)])) URL 连接的类（`HttpsURLConnection`）
- en: Just as with JCA cryptographic service providers, a JSSE provider supplies implementations
    for the engine classes defined in the API. Those implementation classes are responsible
    for creating the underlying sockets, and key and trust managers required to establish
    a connection, but JSSE API users never directly interact with them, only with
    the respective engine classes. Let’s briefly review the key classes and interfaces
    in the JSSE API, as well as how they relate to each other.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 就像 JCA 加密服务提供者一样，JSSE 提供者为 API 中定义的引擎类提供实现。这些实现类负责创建底层套接字以及建立连接所需的密钥和信任管理器，但
    JSSE API 用户从不直接与它们互动，而是仅与相应的引擎类交互。让我们简要回顾 JSSE API 中的关键类和接口，以及它们之间的关系。
- en: Secure Sockets
  id: totrans-43
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 安全套接字
- en: JSSE supports both stream-based, blocking I/O using sockets and NIO (New I/O)
    channel-based, nonblocking I/O. The central class for stream-based communication
    is `javax.net.ssl.SSLSocket`, which is created either by an `SSLSocketFactory`
    or by calling the `accept()` method of the `SSLServerSocket` class. In turn, `SSLSocketFactory`
    and `SSLServerSocketFactory` instances are created by calling the appropriate
    factory methods of the `SSLContext` class. SSL socket factories encapsulate the
    details of creating and configuring SSL sockets, including authentication keys,
    peer certificate validation strategies, and enabled cipher suites. Those details
    are typically common for all SSL sockets that an application uses and are configured
    when initializing the application’s `SSLContext`. They are then passed to all
    SSL socket factories created by the shared `SSLContext` instance. If an `SSLContext`
    is not explicitly configured, it uses the system defaults for all SSL parameters.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: JSSE 支持基于流的阻塞 I/O 使用套接字和基于 NIO（新 I/O）通道的非阻塞 I/O。基于流的通信的核心类是 `javax.net.ssl.SSLSocket`，它可以通过
    `SSLSocketFactory` 创建，或者通过调用 `SSLServerSocket` 类的 `accept()` 方法创建。反过来，`SSLSocketFactory`
    和 `SSLServerSocketFactory` 实例是通过调用 `SSLContext` 类的适当工厂方法创建的。SSL 套接字工厂封装了创建和配置
    SSL 套接字的细节，包括身份验证密钥、对等证书验证策略和启用的密码套件。这些细节通常对于应用程序使用的所有 SSL 套接字都是通用的，并且在初始化应用程序的
    `SSLContext` 时进行配置。然后，它们会传递给由共享 `SSLContext` 实例创建的所有 SSL 套接字工厂。如果未显式配置 `SSLContext`，则会为所有
    SSL 参数使用系统默认值。
- en: Nonblocking SSL I/O is implemented in the `javax.net.ssl.SSLEngine` class. This
    class encapsulates an SSL state machine and operates on byte buffers supplied
    by its clients. While `SSLSocket` hides much of the complexity of SSL, in order
    to offer greater flexibility, `SSLEngine` leaves I/O and threading to the calling
    application. Therefore, `SSLEngine` clients are expected to have some understanding
    of the SSL protocol. `SSLEngine` instances are created directly from an `SSLContext`
    and inherit its SSL configuration, just like SSL socket factories.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 非阻塞 SSL I/O 在 `javax.net.ssl.SSLEngine` 类中实现。该类封装了一个 SSL 状态机，并对其客户端提供的字节缓冲区进行操作。虽然
    `SSLSocket` 隐藏了 SSL 的复杂性，但为了提供更大的灵活性，`SSLEngine` 将 I/O 和线程处理交给调用的应用程序。因此，`SSLEngine`
    的客户端需要对 SSL 协议有一定了解。`SSLEngine` 实例是直接从 `SSLContext` 创建的，并继承其 SSL 配置，就像 SSL 套接字工厂一样。
- en: Peer Authentication
  id: totrans-46
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 对等身份验证
- en: Peer authentication is an integral part of the SSL protocol and relies on the
    availability of a set of trust anchors and authentication keys. In JSSE, peer
    authentication configuration is provided with the help of the `KeyStore`, `KeyManagerFactory`,
    and `TrustManagerFactory` engine classes. A `KeyStore` represents a storage facility
    for cryptographic keys and certificates and can be used to store both trust anchors
    certificates, and end entity keys along with their associated certificates. `KeyManagerFactory`
    and `TrustManagerFactory` create `KeyManager`s or `TrustManager`s, respectively,
    based on a specified authentication algorithm. While implementations based on
    different authentication strategies are possible, in practice SSL uses only a
    X.509-based PKI (PKIX)^([[64](#ftn.ch06fn07)]) for authentication, and the only
    algorithm supported by those factory classes is *PKIX* (aliased to *X.509*). An
    `SSLContext` can be initialized with a set of `KeyManager` and `TrustManager`
    instances by calling the following method. All parameters are optional, and if
    `null` is specified, the system default is used (see [Example 6-3](ch06.html#sslcontext_initialization_method
    "Example 6-3. SSLContext initialization method")).
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 对等身份验证是 SSL 协议的一个重要组成部分，依赖于一组信任锚和身份验证密钥的可用性。在 JSSE 中，对等身份验证配置是通过 `KeyStore`、`KeyManagerFactory`
    和 `TrustManagerFactory` 引擎类来提供的。`KeyStore` 代表一个存储加密密钥和证书的设施，可以用来存储信任锚证书以及终端实体的密钥和相关证书。`KeyManagerFactory`
    和 `TrustManagerFactory` 分别基于指定的身份验证算法创建 `KeyManager` 或 `TrustManager`。虽然基于不同身份验证策略的实现是可能的，但实际上，SSL
    仅使用基于 X.509 的 PKI（PKIX）进行身份验证，并且这些工厂类支持的唯一算法是 *PKIX*（别名为 *X.509*）。通过调用以下方法，可以使用一组
    `KeyManager` 和 `TrustManager` 实例初始化 `SSLContext`。所有参数都是可选的，如果指定为 `null`，则使用系统默认值（参见
    [示例 6-3](ch06.html#sslcontext_initialization_method "示例 6-3. SSLContext 初始化方法")）。
- en: Example 6-3. `SSLContext` initialization method
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 6-3. `SSLContext` 初始化方法
- en: '[PRE2]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'A `TrustManager` determines whether the presented peer authentication credentials
    should be trusted. If they are, the connection is established; if not, the connection
    is terminated. In the context of PKIX, this translates to validating the certificate
    chain of the presented peer certificate based on the configured trust anchors.
    This is also reflected in the `X509TrustManager` interface JSSE uses (see [Example 6-4](ch06.html#x509trustmanager_interface_methods
    "Example 6-4. X509TrustManager interface methods")):'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: '`TrustManager` 决定是否信任呈现的对等身份验证凭据。如果信任，则建立连接；如果不信任，则终止连接。在 PKIX 的上下文中，这意味着基于配置的信任锚来验证呈现的对等证书的证书链。这也体现在
    JSSE 使用的 `X509TrustManager` 接口中（参见 [示例 6-4](ch06.html#x509trustmanager_interface_methods
    "示例 6-4. X509TrustManager 接口方法")）：'
- en: Example 6-4. `X509TrustManager` interface methods
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 6-4. `X509TrustManager` 接口方法
- en: '[PRE3]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Certificate chain validation is performed using the system Java Certification
    Path API (or CertPath API) implementation,^([[65](#ftn.ch06fn08)]) which is responsible
    for building and validating certificate chains. While the API has a somewhat algorithm-independent
    interface, in practice it’s closely related to PKIX and implements the chain building
    and validation algorithms defined in PKIX standards. The default PKIX `TrustManagerFactory`
    implementation can create an `X509TrustManager` instance that preconfigures the
    underlying CertPath API classes with the trust anchors stored in a `KeyStore`
    object.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 证书链验证是通过系统的 Java 认证路径 API（或 CertPath API）实现执行的，^([[65](#ftn.ch06fn08)]) 该实现负责构建和验证证书链。尽管该
    API 具有某种与算法无关的接口，但在实践中它与 PKIX 密切相关，并实现了 PKIX 标准中定义的链构建和验证算法。默认的 PKIX `TrustManagerFactory`
    实现可以创建一个 `X509TrustManager` 实例，该实例使用 `KeyStore` 对象中存储的信任锚来预配置底层的 CertPath API
    类。
- en: The `KeyStore` object is typically initialized from a system keystore file referred
    to as a *trust store*. When more fine-grained configuration is required, a `CertPathTrustManagerParameters`
    instance that contains detailed CertPath API parameters can be used to initialize
    the `TrustManagerFactory` as well. When the system `X509TrustManager` implementation
    cannot be configured as required using the provided APIs, a custom instance can
    be created by implementing the interface directly, possibly delegating base cases
    to the default implementation.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: '`KeyStore` 对象通常是从一个称为*信任库*的系统密钥库文件中初始化的。当需要更细粒度的配置时，可以使用包含详细 CertPath API 参数的
    `CertPathTrustManagerParameters` 实例来初始化 `TrustManagerFactory`。当系统 `X509TrustManager`
    实现无法通过提供的 API 按要求配置时，可以通过直接实现接口来创建自定义实例，可能会将基础案例委托给默认实现。'
- en: A `KeyManager` determines which authentication credentials to send to the remote
    host. In the context of PKIX, this means selecting the client authentication certificate
    to send to an SSL server. The default `KeyManagerFactory` can create a `KeyManager`
    instance that uses a `KeyStore` to search for client authentication keys and related
    certificates. Just as with `TrustManager`s, the concrete interfaces, `X509KeyManager`
    (shown in [Example 6-5](ch06.html#x509keymanager_interface "Example 6-5. X509KeyManager
    interface")) and `X509ExtendedKeyManager` (which allows for connection-specific
    key selection), are PKIX-specific and select a client certificate based on the
    list of trusted issuers that the server has provided. If the default `KeyStore`
    -backed implementation is not sufficiently flexible, a custom implementation can
    be provided by extending the abstract `X509ExtendedKeyManager` class.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: '`KeyManager` 决定将哪些身份验证凭据发送到远程主机。在 PKIX 的上下文中，这意味着选择发送到 SSL 服务器的客户端身份验证证书。默认的
    `KeyManagerFactory` 可以创建一个 `KeyManager` 实例，使用 `KeyStore` 来搜索客户端身份验证密钥和相关证书。与 `TrustManager`
    一样，具体的接口 `X509KeyManager`（参见 [示例 6-5](ch06.html#x509keymanager_interface "示例 6-5.
    X509KeyManager 接口")）和 `X509ExtendedKeyManager`（允许进行连接特定的密钥选择）是 PKIX 特定的，并根据服务器提供的受信任颁发者列表选择客户端证书。如果默认的
    `KeyStore` 支持的实现不够灵活，可以通过扩展抽象的 `X509ExtendedKeyManager` 类来提供自定义实现。'
- en: Example 6-5. `X509KeyManager` interface
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 6-5. `X509KeyManager` 接口
- en: '[PRE4]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: In addition to support for “raw” SSL sockets, JSSE also provides support for
    HTTPS with the `HttpsURLConnection` class. `HttpsURLConnection` uses the default
    `SSLSocketFactory` to create secure sockets when opening a connection to a web
    server. If additional SSL configuration such as specifying app-private trust anchors
    or authentication keys is required, the default `SSLSocketFactory` can be replaced
    for all `HttpsURLConnection` instances by calling the static `setDefaultSSLSocketFactory()`
    method. Alternatively, you can configure the socket factory for a particular instance
    by calling its `setSSLSocketFactory()` method.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 除了支持“原始”SSL套接字外，JSSE 还提供了通过 `HttpsURLConnection` 类支持 HTTPS。`HttpsURLConnection`
    使用默认的 `SSLSocketFactory` 来创建安全套接字，在与 Web 服务器建立连接时。如果需要额外的 SSL 配置，例如指定应用私有的信任锚或身份验证密钥，则可以通过调用静态方法
    `setDefaultSSLSocketFactory()` 来为所有 `HttpsURLConnection` 实例替换默认的 `SSLSocketFactory`。或者，您可以通过调用其
    `setSSLSocketFactory()` 方法为特定实例配置套接字工厂。
- en: Hostname Verification
  id: totrans-59
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 主机名验证
- en: While SSL verifies server identity by checking its certificate, the protocol
    does not mandate any hostname verification, and when using raw SSL sockets, the
    certificate subject is not matched against the server hostname. The HTTPS standard
    does mandate such a check however, and `HttpsURLConnection` performs one internally.
    The default hostname verification algorithm can be overridden by assigning a `HostnameVerifier`
    instance to the class or on a per-instance basis. The `verify()` callback it needs
    to implement is shown in [Example 6-6](ch06.html#hostnameverifier_hostname_verification_c
    "Example 6-6. HostnameVerifier hostname verification callback"). The `SSLSession`
    class used in the callback encapsulates details about the current SSL connection,
    including selected protocol and cipher suite, local and peer certificate chains,
    and peer hostname and connection port number.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然 SSL 通过检查服务器证书来验证服务器身份，但协议并未强制要求任何主机名验证，且在使用原始 SSL 套接字时，证书主题不会与服务器主机名匹配。然而，HTTPS
    标准确实要求进行这样的检查，`HttpsURLConnection` 在内部执行此操作。默认的主机名验证算法可以通过将 `HostnameVerifier`
    实例分配给类或单个实例来覆盖。它需要实现的 `verify()` 回调在[示例 6-6](ch06.html#hostnameverifier_hostname_verification_c
    "示例 6-6. HostnameVerifier 主机名验证回调")中显示。回调中使用的 `SSLSession` 类封装了当前 SSL 连接的详细信息，包括选定的协议和密码套件、本地和对等证书链、对等主机名和连接端口号。
- en: Example 6-6. `HostnameVerifier` hostname verification callback
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 6-6. `HostnameVerifier` 主机名验证回调
- en: '[PRE5]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: We have discussed the major classes and interfaces that form the JSSE API and
    introduced how they related to each other. Their relationships can be visualized
    as shown in [Figure 6-2](ch06.html#jsse_classes_and_their_relationships "Figure 6-2. JSSE
    classes and their relationships").
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经讨论了构成 JSSE API 的主要类和接口，并介绍了它们之间的关系。它们的关系可以通过[图 6-2](ch06.html#jsse_classes_and_their_relationships
    "图 6-2. JSSE 类及其关系")来可视化。
- en: '![JSSE classes and their relationships](figs/web/06fig02.png.jpg)'
  id: totrans-64
  prefs: []
  type: TYPE_IMG
  zh: '![JSSE 类及其关系](figs/web/06fig02.png.jpg)'
- en: Figure 6-2. JSSE classes and their relationships
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6-2. JSSE 类及其关系
- en: Android JSSE Implementation
  id: totrans-66
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Android JSSE 实现
- en: 'Android comes with two JSSE providers: the Java-based HarmonyJSSE and the AndroidOpenSSL
    provider, which is implemented largely in native code bridged to the public Java
    API using JNI. HarmonyJSSE builds on Java sockets and JCA classes in order to
    implement SSL, while AndroidOpenSSL implements most of its functionality by using
    OpenSSL library calls. As discussed in [Chapter 5](ch05.html "Chapter 5. Cryptographic
    Providers"), AndroidOpenSSL is the preferred JCA provider in Android, and it also
    provides the default `SSLSocketFactory` and `SSLServerSocketFactory` implementations
    that are returned by `SSLSocketFactory.getDefault()` and `SSLServerSocketFactory.getDefault()`,
    respectively.'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: Android 配备了两个 JSSE 提供者：基于 Java 的 HarmonyJSSE 和 AndroidOpenSSL 提供者，后者主要通过 JNI
    桥接到公共 Java API 实现为本地代码。HarmonyJSSE 基于 Java 套接字和 JCA 类来实现 SSL，而 AndroidOpenSSL
    通过使用 OpenSSL 库调用来实现其大部分功能。如[第 5 章](ch05.html "第 5 章. 加密提供者")中所述，AndroidOpenSSL
    是 Android 中首选的 JCA 提供者，它还提供了默认的 `SSLSocketFactory` 和 `SSLServerSocketFactory`
    实现，分别由 `SSLSocketFactory.getDefault()` 和 `SSLServerSocketFactory.getDefault()`
    返回。
- en: Both JSSE providers are part of the core Java library (found in `core.jar` and
    `libjavacore.so`), and the native part of the AndroidOpenSSL provider is compiled
    into `libjavacrypto.so`. HarmonyJSSE provides only SSLv3.0 and TLSv1.0 support,
    while AndroidOpenSSL supports TLSv1.1 and TLSv1.2 as well. While the SSL socket
    implementation is different, both providers share the same `TrustManager` and
    `KeyManager` code.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 两个 JSSE 提供者都属于核心 Java 库的一部分（分别位于 `core.jar` 和 `libjavacore.so`），而 AndroidOpenSSL
    提供者的原生部分被编译到 `libjavacrypto.so` 中。HarmonyJSSE 仅支持 SSLv3.0 和 TLSv1.0，而 AndroidOpenSSL
    则支持 TLSv1.1 和 TLSv1.2。虽然 SSL 套接字实现不同，但两个提供者共享相同的 `TrustManager` 和 `KeyManager`
    代码。
- en: Note
  id: totrans-69
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '*The HarmonyJSSE provider is still available in Android 4.4, but it is considered
    deprecated and is not actively maintained. It may be removed in future Android
    versions.*'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: '*HarmonyJSSE 提供者仍然可以在 Android 4.4 中使用，但已被视为弃用且不再积极维护。它可能会在未来的 Android 版本中被移除。*'
- en: In addition to current TLS protocol versions, the OpenSSL-based provider supports
    the *Server Name Indication (SNI)* TLS extension (defined in *RFC 3546*^([[66](#ftn.ch06fn09)])),
    which allows SSL clients to specify the intended hostname when connecting to servers
    hosting multiple virtual hosts. SNI is used by default when establishing a connection
    using the `HttpsURLConnection` class in Android 3.0 and later versions (version
    2.3 has partial SNI support). However, SNI is not supported when using the Apache
    HTTP client library bundled with Android (in the `org.apache.http` package).
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 除了当前的 TLS 协议版本外，基于 OpenSSL 的提供者还支持 *服务器名称指示（SNI）* TLS 扩展（在 *RFC 3546*^([[66](#ftn.ch06fn09)])
    中定义），它允许 SSL 客户端在连接到托管多个虚拟主机的服务器时指定目标主机名。在 Android 3.0 及之后版本中，建立连接时默认使用 SNI（版本
    2.3 对 SNI 的支持有限）。然而，使用 Android 自带的 Apache HTTP 客户端库（位于 `org.apache.http` 包中）时，SNI
    是不支持的。
- en: Before Android 4.2, the HTTP stack in Android’s core Java library, including
    `HttpsURLConnection`, was based on Apache Harmony code. In Android 4.2 and later,
    the original implementation is replaced with Square’s HTTP & SPDY client library,
    *OkHttp*.^([[67](#ftn.ch06fn10)])
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Android 4.2 之前，Android 核心 Java 库中的 HTTP 栈，包括 `HttpsURLConnection`，是基于 Apache
    Harmony 代码实现的。在 Android 4.2 及之后的版本中，原始实现被 Square 的 HTTP 和 SPDY 客户端库 *OkHttp* 替代。^([[67](#ftn.ch06fn10)])
- en: Certificate Management and Validation
  id: totrans-73
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 证书管理与验证
- en: Android’s JSSE implementations mostly conform to the JSSE API specification,
    but there are some notable differences as well. The biggest one is how Android
    handles the system trust store. In Java SE JSSE implementations, the system trust
    store is a single keystore file (typically called *cacerts*) whose location can
    be set with the `javax.net.ssl.trustStore` system property, but Android follows
    a different strategy. Recent versions of Android also provide modern certificate
    validation features such as blacklisting and pinning that are not specified in
    the original JSSE architecture document. We will discuss Android’s trust store
    implementation and advanced certificate validation features in the next sections.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: Android 的 JSSE 实现大多符合 JSSE API 规范，但也有一些显著的区别。最大的一点是 Android 如何处理系统信任存储。在 Java
    SE 的 JSSE 实现中，系统信任存储是一个单独的密钥存储文件（通常称为*cacerts*），其位置可以通过 `javax.net.ssl.trustStore`
    系统属性设置，但 Android 采用了不同的策略。Android 的最新版本还提供了现代证书验证功能，如黑名单和固定证书，这些在原始的 JSSE 架构文档中并未指定。我们将在接下来的章节中讨论
    Android 的信任存储实现和高级证书验证功能。
- en: System Trust Stores
  id: totrans-75
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 系统信任存储
- en: As discussed in “[Peer Authentication](ch06.html#peer_authentication "Peer Authentication")”,
    JSSE implementations use a trust store to authenticate connection peers. While
    SSL does support encryption-only, non-authenticated connections, in practice raw
    SSL clients usually perform server authentication and it is mandatory for HTTPS.
    When a per-application trust store is not explicitly provided, JSSE uses the system
    trust store to perform SSL peer authentication. The system trust store is especially
    important for generic Internet clients such as browsers, because they typically
    do not manage their own trust store on mobile devices (desktop versions of Mozilla
    clients do maintain private credential and certificate stores, but not on Android).
    Because system trust stores are central to the security of all applications that
    use JSSE, we will look into their implementation in detail.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 如在“[对等身份验证](ch06.html#peer_authentication "对等身份验证")”中讨论的那样，JSSE 实现使用信任存储来验证连接对等方。虽然
    SSL 确实支持仅加密、不进行身份验证的连接，但在实际操作中，原生的 SSL 客户端通常会执行服务器身份验证，并且 HTTPS 中对此是强制要求的。当没有明确提供每个应用的信任存储时，JSSE
    会使用系统信任存储来进行 SSL 对等身份验证。系统信任存储对于像浏览器这样的通用 Internet 客户端尤为重要，因为它们通常不会在移动设备上管理自己的信任存储（Mozilla
    客户端的桌面版本确实会维护私有的凭证和证书存储，但在 Android 上没有）。由于系统信任存储对所有使用 JSSE 的应用程序的安全性至关重要，我们将详细研究它们的实现。
- en: Until Android 4.0, the OS trust store was hardwired into the system and users
    had no control over it whatsoever. Certificates bundled in the store were chosen
    solely by the device manufacturer or carrier. The only way to make changes was
    to root your device, repackage the trusted certificates file, and replace the
    original one—a procedure that’s obviously not too practical, and a major obstacle
    to using Android in enterprise PKIs. In the wake of the compromise of multiple
    major CAs, third-party tools that could change the system-trusted certificates
    were developed, but using them still required a rooted phone. Fortunately, Android
    4.0 made managing the trust store much more flexible, and gave the much-needed
    control over who to trust to the user.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Android 4.0 之前，操作系统的信任存储是硬编码到系统中的，用户对此完全无法控制。存储中的证书是由设备制造商或运营商单独选择的。唯一能做出更改的方式是对设备进行
    root 操作，重新打包信任证书文件，并替换原始文件——这个过程显然不太实际，也是 Android 在企业 PKI 中使用的一大障碍。在多个主要 CA 被攻破之后，第三方工具应运而生，能够更改系统信任证书，但使用这些工具仍然需要一个已
    root 的手机。幸运的是，Android 4.0 使得信任存储的管理变得更加灵活，并将控制谁可以信任的权力交给了用户。
- en: Android 4.x System Trust Store
  id: totrans-78
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Android 4.x 系统信任存储
- en: 'Prior to Android 4.0, the system trust store was a single file: */system/etc/
    security/cacerts.bks*, a Bouncy Castle (one of the cryptographic providers used
    in Android; see [Chapter 5](ch05.html "Chapter 5. Cryptographic Providers") for
    details) native keystore file. It contained all the CA certificates that Android
    trusts and was used both by system apps such as the email client and browser,
    and third-party apps. Because it resided on the read-only *system* partition,
    it could not be changed even by system applications.'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Android 4.0 之前，系统信任存储是一个单独的文件：*/system/etc/security/cacerts.bks*，这是一个 Bouncy
    Castle（Android 使用的加密提供者之一；详见[第 5 章](ch05.html "第 5 章. 加密提供者")）的原生密钥存储文件。它包含了 Android
    所信任的所有 CA 证书，并被系统应用程序（如电子邮件客户端和浏览器）以及第三方应用程序使用。因为它位于只读的 *system* 分区上，所以即使是系统应用程序也无法更改它。
- en: 'Android 4.0 introduced a new, more flexible `TrustedCertificateStore` class
    that allows for maintaining built-in trust anchors and adding new ones. It still
    reads system-trusted certificates from */system/etc/security/*, but adds two new,
    mutable locations to store CA certificates in */data/misc/ keychain/*: the *cacerts-added/*
    and *cacerts-removed/* directories. [Example 6-7](ch06.html#contents_of_the_cacerts-addedsolidus_and
    "Example 6-7. Contents of the cacerts-added/ and cacerts-removed/ directories")
    shows what their contents looks like:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: Android 4.0 引入了一个新的、更灵活的 `TrustedCertificateStore` 类，它允许维护内置的信任锚并添加新的信任锚。它仍然从
    */system/etc/security/* 读取系统信任的证书，但增加了两个新的可变位置，用于存储 CA 证书，这些位置位于 */data/misc/keychain/*
    下：*cacerts-added/* 和 *cacerts-removed/* 目录。[示例 6-7](ch06.html#contents_of_the_cacerts-addedsolidus_and
    "示例 6-7. cacerts-added/ 和 cacerts-removed/ 目录的内容") 显示了它们的内容：
- en: Example 6-7. Contents of the cacerts-added/ and cacerts-removed/ directories
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 6-7. cacerts-added/ 和 cacerts-removed/ 目录的内容
- en: '[PRE6]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Each file in these directories contains one CA certificate. The file names
    may look familiar: they are based on the MD5 hashes of the CA subject names (computed
    using OpenSSL’s `X509_NAME_hash_old()` function), as used in *mod_ssl* and other
    cryptographic software implemented using OpenSSL. This makes it easy to quickly
    find certificates without scanning the entire store by directly converting the
    DN to a filename.'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 这些目录中的每个文件包含一个 CA 证书。文件名可能看起来很熟悉：它们是基于 CA 主题名称的 MD5 哈希值（使用 OpenSSL 的`X509_NAME_hash_old()`函数计算），如同在*mod_ssl*和其他使用
    OpenSSL 实现的加密软件中使用的那样。这使得通过直接将 DN 转换为文件名，可以快速找到证书，而不需要扫描整个存储。
- en: 'Also note the permissions of the directories: *0775 system system* guarantees
    that only the *system* user is able to add or remove certificates, but anyone
    can read them. As expected, adding trusted CA certificates is implemented by storing
    the certificate in the *cacerts-added/* directory under the appropriate file name.
    The certificate stored in the *30ef493b.0* file (➊ in [Example 6-7](ch06.html#contents_of_the_cacerts-addedsolidus_and
    "Example 6-7. Contents of the cacerts-added/ and cacerts-removed/ directories"))
    will also be displayed in the User tab of the Trusted credentials system application
    (**Settings**▸**Security**▸**Trusted credentials**).'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 还要注意目录的权限：*0775 system system*确保只有*system*用户可以添加或移除证书，但任何人都可以读取它们。如预期所示，添加受信任的
    CA 证书是通过将证书存储在适当文件名的*cacerts-added/*目录下实现的。存储在*30ef493b.0*文件中的证书（➊在[示例 6-7](ch06.html#contents_of_the_cacerts-addedsolidus_and
    "示例 6-7. cacerts-added/和cacerts-removed/目录的内容")中）也将在受信任的证书系统应用程序的用户标签中显示（**设置**▸**安全**▸**受信任的证书**）。
- en: But how are OS-trusted certificates disabled? Because preinstalled CA certificates
    are still stored in */system/etc/ security/* (which is mounted read-only), a CA
    is marked as not trusted by placing a copy of its certificate in the *cacerts-removed/*
    directory. Re-enabling is performed by simply removing the file. In this particular
    case, *00673b5b.0* (➋ in [Example 6-7](ch06.html#contents_of_the_cacerts-addedsolidus_and
    "Example 6-7. Contents of the cacerts-added/ and cacerts-removed/ directories"))
    is the *thawte Primary Root CA*, shown as disabled in the System tab (see [Figure 6-3](ch06.html#preinstalled_ca_certificate_marked_as_un
    "Figure 6-3. Preinstalled CA certificate marked as untrusted")).
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，操作系统信任的证书是如何被禁用的呢？因为预安装的 CA 证书仍然存储在*/system/etc/security/*（该目录为只读挂载）中，通过将其证书的副本放置在*cacerts-removed/*目录下，可以将
    CA 标记为不受信任。重新启用通过简单地删除该文件来实现。在这个特殊的例子中，*00673b5b.0*（➋在[示例 6-7](ch06.html#contents_of_the_cacerts-addedsolidus_and
    "示例 6-7. cacerts-added/和cacerts-removed/目录的内容")中）是*thawte Primary Root CA*，在系统标签中显示为禁用（参见[图
    6-3](ch06.html#preinstalled_ca_certificate_marked_as_un "图 6-3. 标记为不受信任的预安装 CA
    证书")）。
- en: Using the System Trust Store
  id: totrans-86
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用系统信任存储
- en: '`TrustedCertificateStore` is not part of the Android SDK, but it has a wrapper
    (`TrustedCertificateKeyStoreSpi`) accessible via the standard JCA `KeyStore` API
    that applications can use (see [Example 6-8](ch06.html#listing_trusted_certificates_using_andro
    "Example 6-8. Listing trusted certificates using AndroidCAStore")).'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: '`TrustedCertificateStore` 不是 Android SDK 的一部分，但它有一个包装器（`TrustedCertificateKeyStoreSpi`），可以通过标准的
    JCA `KeyStore` API 访问，供应用程序使用（请参见[示例 6-8](ch06.html#listing_trusted_certificates_using_andro
    "示例 6-8. 使用 AndroidCAStore 列出受信任的证书")）。'
- en: Example 6-8. Listing trusted certificates using AndroidCAStore
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 6-8。 使用 AndroidCAStore 列出受信任的证书
- en: '[PRE7]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '![Preinstalled CA certificate marked as untrusted](figs/web/06fig03.png.jpg)'
  id: totrans-90
  prefs: []
  type: TYPE_IMG
  zh: '![标记为不受信任的预安装 CA 证书](figs/web/06fig03.png.jpg)'
- en: Figure 6-3. Preinstalled CA certificate marked as untrusted
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6-3。标记为不受信任的预安装 CA 证书
- en: 'To get a list of the current trusted certificates, we:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 要获取当前受信任证书的列表，我们：
- en: Create a `KeyStore` instance by specifying *AndroidCAStore* as the `type` parameter
    ➊.
  id: totrans-93
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过指定*AndroidCAStore*作为`type`参数来创建一个`KeyStore`实例 ➊。
- en: Call its `load()` method and pass `null` for both parameters ➋.
  id: totrans-94
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 调用其`load()`方法并将`null`传递给两个参数 ➋。
- en: Get a list of certificate aliases with the `aliases()` method ➌.
  id: totrans-95
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`aliases()`方法获取证书别名的列表 ➌。
- en: Pass each alias to the `getCertificate()` method to get the actual certificate
    object ➍.
  id: totrans-96
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将每个别名传递给`getCertificate()`方法以获取实际的证书对象 ➍。
- en: When you examine the output of this code, you’ll notice that certificate aliases
    start with either the *user:* (for user-installed certificates) or *system:* (for
    preinstalled ones) prefix, followed by the subject’s hash value.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 当你检查这段代码的输出时，你会注意到证书别名以*user:*（表示用户安装的证书）或*system:*（表示预安装的证书）为前缀，后面跟着主题的哈希值。
- en: The *AndroidCAStore* `KeyStore` implementation lets us easily access the OS’s
    trusted certificates, but a real-world application would be more interested in
    whether it should trust a particular server certificate, not what the current
    trust anchors are. Android makes this very easy by integrating the `TrustedCertificateKeyStoreSpi`
    with its JSSE implementation. The default `TrustManagerFactory` uses it to get
    a list of trust anchors, and thus automatically validates server certificates
    against the system’s currently trusted certificates. Higher-level code that uses
    `HttpsURLConnection` or `HttpClient` (both built on top of JSSE) should thus work
    without needing to worry about creating and initializing a custom `SSLSocketFactory`.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: '*AndroidCAStore* `KeyStore` 实现使我们能够轻松访问操作系统的受信任证书，但在实际应用中，更关注的是是否应该信任某个特定的服务器证书，而不是当前的信任锚是什么。Android
    通过将 `TrustedCertificateKeyStoreSpi` 与其 JSSE 实现集成，使这一过程变得非常简单。默认的 `TrustManagerFactory`
    使用它来获取信任锚列表，从而自动将服务器证书与系统当前受信任的证书进行验证。因此，使用 `HttpsURLConnection` 或 `HttpClient`（都建立在
    JSSE 之上）的高层代码应当能够正常工作，而无需担心创建和初始化自定义的 `SSLSocketFactory`。'
- en: In order to install our own CA certificate (such as one from a private enterprise
    CA) into the system trust store, we need to convert it to DER (binary) format
    and copy it to the device. On versions prior to Android 4.4.1, the certificate
    file needs to be copied to the root of external storage with a *.crt* or *.cer*
    extension. Android 4.4.1 and later uses the storage access framework introduced
    in Android 4.4 and allow you to select a certificate file from any storage backend
    that the device can access, including integrated cloud providers like Google Drive.
    We can then import the certificate using the system Settings app by selecting
    **Settings**▸**Personal**▸**Security**▸**Credential storage**▸**Install from storage**.
    A list of available certificate files is displayed and tapping on a filename brings
    up the import dialog, as shown in [Figure 6-4](ch06.html#ca_certificate_import_dialog
    "Figure 6-4. CA certificate import dialog").
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 为了将我们自己的 CA 证书（例如来自私有企业 CA 的证书）安装到系统信任库中，我们需要将其转换为 DER（二进制）格式并复制到设备上。在 Android
    4.4.1 之前的版本中，证书文件需要复制到外部存储的根目录，并且扩展名为 *.crt* 或 *.cer*。Android 4.4.1 及之后版本使用了 Android
    4.4 引入的存储访问框架，允许从设备可以访问的任何存储后端选择证书文件，包括像 Google Drive 这样的集成云服务提供商。然后，我们可以通过选择
    **设置**▸**个人**▸**安全性**▸**凭据存储**▸**从存储安装** 来导入证书。会显示可用证书文件的列表，点击文件名即可打开导入对话框，如[图
    6-4](ch06.html#ca_certificate_import_dialog "图 6-4. CA 证书导入对话框")所示。
- en: The imported certificate will be displayed in the User tab of the Trusted credentials
    screen (see [Figure 6-5](ch06.html#user-imported_ca_certificates "Figure 6-5. User-imported
    CA certificates")). You can view certificate details by tapping the list entry,
    and remove it by scrolling down to the bottom of the details screen and tapping
    the Remove button.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 导入的证书将在受信任的凭据屏幕的用户标签页中显示（见[图 6-5](ch06.html#user-imported_ca_certificates "图
    6-5. 用户导入的 CA 证书")）。你可以通过点击列表项查看证书详情，并通过向下滚动到详情页面底部并点击移除按钮来删除它。
- en: Note
  id: totrans-101
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '*If the certificate is successfully imported, the certificate file in external
    storage file will be deleted on versions prior to Android 4.4.1.*'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: '*如果证书成功导入，在 Android 4.4.1 之前的版本中，外部存储中的证书文件将被删除。*'
- en: '![CA certificate import dialog](figs/web/06fig04.png.jpg)'
  id: totrans-103
  prefs: []
  type: TYPE_IMG
  zh: '![CA 证书导入对话框](figs/web/06fig04.png.jpg)'
- en: Figure 6-4. CA certificate import dialog
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6-4. CA 证书导入对话框
- en: '![User-imported CA certificates](figs/web/06fig05.png.jpg)'
  id: totrans-105
  prefs: []
  type: TYPE_IMG
  zh: '![用户导入的 CA 证书](figs/web/06fig05.png.jpg)'
- en: Figure 6-5. User-imported CA certificates
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6-5. 用户导入的 CA 证书
- en: Beginning with Android 4.4, the system displays a notification that warns the
    user that network activity could be monitored if there are any user-installed
    trusted certificates. SSL connection monitoring can be accomplished by using an
    intercepting proxy server that returns automatically generated certificates for
    the sites that the user is trying to access. As long as those certificates are
    issued by a CA that Android trusts (such as the one manually installed in the
    trust store), most applications would not know the difference between a connection
    to the original host and the intercepting proxy (unless they are have pinned the
    target host; see “[Certificate Pinning](ch06.html#certificate_pinning "Certificate
    Pinning")” for details). A warning icon is shown in Quick Settings and next to
    the *Security* preference entry in the system Settings. When tapped, the notification
    displays the warning message shown in [Figure 6-6](ch06.html#network_monitoring_warning_in_android_4d
    "Figure 6-6. Network monitoring warning in Android 4.4").
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 从Android 4.4开始，如果用户安装了任何受信任的证书，系统将显示一个通知，警告用户网络活动可能会被监控。SSL连接监控可以通过使用拦截代理服务器来完成，该服务器为用户尝试访问的站点返回自动生成的证书。只要这些证书是由Android信任的CA颁发的（例如手动安装到信任存储中的证书），大多数应用无法分辨与原始主机和拦截代理之间的连接差异（除非它们已将目标主机固定；有关详细信息，请参见“[证书固定](ch06.html#certificate_pinning
    "证书固定")”）。在快捷设置和系统设置中的*安全性*首选项旁边会显示一个警告图标。点击该图标时，通知会显示[图6-6](ch06.html#network_monitoring_warning_in_android_4d
    "图6-6。Android 4.4中的网络监控警告")中显示的警告信息。
- en: '![Network monitoring warning in Android 4.4](figs/web/06fig06.png.jpg)'
  id: totrans-108
  prefs: []
  type: TYPE_IMG
  zh: '![Android 4.4中的网络监控警告](figs/web/06fig06.png.jpg)'
- en: Figure 6-6. Network monitoring warning in Android 4.4
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 图6-6。Android 4.4中的网络监控警告
- en: System Trust Store APIs
  id: totrans-110
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 系统信任存储API
- en: Third-party applications can prompt the user to import a needed certificate
    into the system trust store by using the `KeyChain` API, introduced in Android
    4.0 as well. (We’ll discuss the `KeyChain` API in [Chapter 7](ch07.html "Chapter 7. Credential
    Storage").) Beginning with Android 4.4, device administrator applications can
    silently install CA certificates in the system trust store if they hold the *MANAGE_CA_CERTIFICATES*
    system permission. (We’ll introduce device administration and related APIs in
    [Chapter 9](ch09.html "Chapter 9. Enterprise Security").)
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 第三方应用可以通过使用`KeyChain` API提示用户将所需证书导入系统信任存储，该API也在Android 4.0中引入。（我们将在[第7章](ch07.html
    "第7章。凭证存储")讨论`KeyChain` API。）从Android 4.4开始，设备管理员应用可以在拥有*MANAGE_CA_CERTIFICATES*系统权限的情况下，悄无声息地将CA证书安装到系统信任存储中。（我们将在[第9章](ch09.html
    "第9章。企业安全")介绍设备管理和相关API。）
- en: Once a CA certificate is imported into the system trust store, we can use it
    to validate certificates using the JSSE `TrustManager` API as shown in [Example 6-9](ch06.html#initializing_a_trustmanager_with_system
    "Example 6-9. Initializing a TrustManager with system trust anchors and validating
    a certificate").
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦CA证书导入系统信任存储，我们可以使用它来验证证书，使用JSSE `TrustManager` API，如[示例6-9](ch06.html#initializing_a_trustmanager_with_system
    "示例6-9。使用系统信任锚初始化TrustManager并验证证书")所示。
- en: Example 6-9. Initializing a `TrustManager` with system trust anchors and validating
    a certificate
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 示例6-9。使用系统信任锚初始化`TrustManager`并验证证书
- en: '[PRE8]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: To do so, we first get the system PKIX (aliased to *X509*) `TrustManagerFactory`
    (➊ in [Example 6-9](ch06.html#initializing_a_trustmanager_with_system "Example 6-9. Initializing
    a TrustManager with system trust anchors and validating a certificate")); initialize
    it using the system trust store by passing `null` to its `init(KeyStore ks)` method
    ➋; then get the first `TrustManager` implementation for the specified algorithm
    (there is usually only one, but do check in production code) and cast it to the
    validation algorithm-specific `X509TrustManager` interface ➌. Finally, we pass
    the certificate chain and the key exchange algorithm used (*RSA*, *DHE_DSS*, and
    so on) to the `checkServerTrusted()` method ➍. If a chain leading to a trusted
    CA certificate can be built, validation passes and the method returns. If any
    of the certificates in the chain is expired or invalid, or if the chain does not
    lead to a system trust anchor, the method will throw a `java.security.cert.CertificateException`
    (or one of its subclasses). Connections established with `SSLSocket` and `HttpsURLConnection`
    perform similar validation automatically.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 为此，我们首先获取系统的 PKIX（别名为*X509*）`TrustManagerFactory`（见 [示例 6-9](ch06.html#initializing_a_trustmanager_with_system
    "示例 6-9. 使用系统信任锚初始化 TrustManager 并验证证书") 中的 ➊）；通过向其 `init(KeyStore ks)` 方法传递 `null`
    来使用系统信任库初始化它 ➋；然后获取指定算法的第一个 `TrustManager` 实现（通常只有一个，但在生产代码中请务必确认）并将其强制转换为与验证算法相关的
    `X509TrustManager` 接口 ➌。最后，我们将证书链和所使用的密钥交换算法（如*RSA*、*DHE_DSS*等）传递给 `checkServerTrusted()`
    方法 ➍。如果能够构建出一个指向受信 CA 证书的链，则验证通过，方法返回。如果链中的任何证书已过期或无效，或者链无法指向系统信任锚，则该方法将抛出 `java.security.cert.CertificateException`（或其子类中的一种）。使用
    `SSLSocket` 和 `HttpsURLConnection` 建立的连接会自动执行类似的验证。
- en: 'This works pretty well, but there is one major problem with this code: it does
    not check revocation. Android’s default `TrustManager` explicitly turns off revocation
    when validating the certificate chain. So even if the certificate had a CRL Distribution
    Point (CDP) extension, pointing to a valid CRL, or the OCSP responder URI was
    included in the Authority Information Access (AIA) extension, and the certificate
    was actually revoked, it would still validate in Android. What’s missing here
    is *online revocation checking*: the ability to dynamically fetch, cache, and
    update revocation information as needed, based on information available in certificate
    extensions.'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码效果还不错，但有一个主要问题：它没有检查证书的吊销情况。Android 默认的 `TrustManager` 在验证证书链时明确关闭了吊销检查。因此，即使证书具有
    CRL 分发点（CDP）扩展，指向有效的 CRL，或者在授权信息访问（AIA）扩展中包含了 OCSP 响应者 URI，并且证书实际上已经被吊销，它仍然会在
    Android 中验证通过。这里缺少的功能是*在线吊销检查*：能够动态地获取、缓存并根据证书扩展中的信息更新吊销信息。
- en: Certificate Blacklisting
  id: totrans-117
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 证书黑名单
- en: Instead of using online revocation checks, Android relies on CA and end entity
    certificate blacklisting, which we will discuss in this section. *Certificate
    blacklisting* refers to the explicit blocking of certain certificates by verifiers,
    regardless of their state in the PKI’s repository. Blacklisting is not part of
    the original PKI philosophy and is not defined in any of the related standards.
    So why is it necessary in practice?
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 与其使用在线吊销检查，Android 倚赖于 CA 和终端实体证书黑名单机制，接下来我们将讨论这个问题。*证书黑名单*指的是验证者明确阻止某些证书的使用，而不考虑它们在
    PKI 仓库中的状态。黑名单机制并不是原始 PKI 哲学的一部分，也没有在任何相关标准中定义。那么，为什么在实际应用中它是必要的呢？
- en: 'In a perfect world, a working PKI takes care of issuing, distributing, and
    revoking certificates as necessary. All that a system needs to verify the identities
    of previously unknown machines and users are a few trust anchor certificates:
    any end entity certificates encountered will be issued by one of the trusted CAs,
    or one of their subordinate issuing CAs (sub-CA). In practice, though, there are
    a number of issues, mostly related to handling compromised keys. End entity certificates
    have a relatively short validity period (usually one year), which limits the time
    a compromised key can be exploited. However, CA certificates have very long validity
    (20 or more years is typical) and because CAs are implicitly trusted, a key compromise
    may go undetected for quite some time. Recent breaches in top-level CAs have shown
    that CA key compromise is not a theoretical problem, and the consequences of a
    CA breach can be quite far-reaching.'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 在一个理想的世界中，一个正常运作的PKI（公钥基础设施）会负责根据需要发布、分发和撤销证书。系统只需要几个信任锚证书，就可以验证先前未知的机器和用户的身份：任何遇到的端实体证书都会由其中一个受信任的CA颁发，或者由它们的下级颁发机构（子CA）颁发。然而，在实际中，存在许多问题，主要与处理密钥泄露相关。端实体证书的有效期相对较短（通常为一年），这限制了被泄露密钥的利用时间。然而，CA证书的有效期非常长（通常为20年或更长），并且因为CA是隐式信任的，密钥泄露可能会长时间未被发现。最近一些顶级CA的安全漏洞表明，CA密钥泄露并非理论问题，CA泄露的后果可能非常广泛。
- en: Handling CA Key Compromises
  id: totrans-120
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 处理CA密钥泄露
- en: 'Probably the biggest PKI issue is that revocation of root certificates is not
    really supported. Most OSes and browsers come with a preconfigured set of trusted
    CA certificates (dozens of them!) and when a CA certificate is compromised, there
    are two main ways to handle it: tell users to remove it from the trust store,
    or issue an emergency update that removes the affected certificate. Expecting
    users to handle this is obviously unrealistic, so that leaves the second option.'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 可能最大的PKI问题是根证书的撤销并不真正得到支持。大多数操作系统和浏览器都预配置了一套受信任的CA证书（数量通常为几十个！），当CA证书被泄露时，有两种主要的处理方法：让用户从信任存储中移除它，或发布紧急更新以移除受影响的证书。显然，指望用户自己处理这个问题是不现实的，因此只能选择第二种方法。
- en: Windows modifies OS trust anchors by distributing patches via Windows Update,
    and browser vendors simply release a new patch version. However, even if an update
    removes a CA certificate from the system trust store, a user can still install
    it again, especially when presented with a “do this, or you can’t access this
    site” ultimatum.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: Windows通过Windows更新分发补丁来修改操作系统的信任锚，而浏览器厂商则只是发布新的补丁版本。然而，即使更新从系统信任存储中移除了CA证书，用户仍然可以重新安装它，尤其是在遇到“做这个，否则你将无法访问该站点”的最后通牒时。
- en: To make sure removed trust anchors are not brought back, the hashes of their
    public keys are added to a blacklist and the OS or browser rejects them even if
    they are in the user trust store. This approach effectively revokes CA certificates
    (within the scope of the OS or browser, of course) and addresses PKI’s inability
    to handle compromised trust anchors. However, it is not exactly ideal because
    even an emergency update takes some time to prepare, and after it’s released,
    some users won’t update right away no matter how often they’re nagged about it.
    (Fortunately, CA compromises are relatively rare and widely publicized, so it
    seems to work well in practice— for now, at least.) Other approaches have been
    proposed as well, but most are not widely used. We discuss some of the proposed
    solutions in “[Radical Solutions](ch06.html#radical_solutions "Radical Solutions")”.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 为了确保被移除的信任锚不被恢复，它们的公钥哈希会被添加到黑名单中，操作系统或浏览器即使在用户的信任存储中也会拒绝它们。这种方法有效地撤销了CA证书（当然是在操作系统或浏览器的范围内），并解决了PKI无法处理泄露的信任锚的问题。然而，这并不完全理想，因为即使是紧急更新也需要一些时间来准备，而发布后，一些用户可能不会立即更新，无论他们被催促多少次。（幸运的是，CA泄露事件相对较少，并且广泛宣传，因此在实践中似乎有效——至少目前如此。）也有提出过其他方法，但大多数并未得到广泛应用。我们将在“[激进解决方案](ch06.html#radical_solutions
    "Radical Solutions")”中讨论一些提议的解决方案。
- en: Handling End Entity Key Compromises
  id: totrans-124
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 处理端实体密钥泄露
- en: While CA breaches are fairly uncommon, end entity (EE) key compromise occurs
    much more often. Whether due to a server breach, stolen laptop, or a lost smart
    card, these compromises occur daily. Fortunately, modern PKI systems are designed
    with this in mind and CAs can revoke certificates and publish revocation information
    in the form of CRLs, or provide online revocation status using OCSP.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然证书颁发机构（CA）泄露事件相对少见，但最终实体（EE）密钥泄露的情况发生得要频繁得多。无论是由于服务器泄露、笔记本被盗，还是智能卡丢失，这些泄露事件每天都在发生。幸运的是，现代公钥基础设施（PKI）系统在设计时已经考虑到了这一点，CA
    可以撤销证书，并以证书撤销列表（CRLs）的形式发布撤销信息，或者通过在线证书状态协议（OCSP）提供在线撤销状态。
- en: Unfortunately, this doesn’t work too well in the real world. Revocation checking
    generally requires network access to a machine different from the one we are trying
    to connect to, and as such has a fairly high failure rate. To mitigate this, most
    browsers try to fetch fresh revocation information, but if that effort fails for
    some reason, they simply ignore the error (soft-fail), or at best show some visual
    indication that revocation information is not available.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，这在实际应用中并不太有效。撤销检查通常需要访问与我们尝试连接的机器不同的网络机器，因此失败率相对较高。为了缓解这一问题，大多数浏览器会尝试获取最新的撤销信息，但如果由于某种原因失败，它们会简单地忽略错误（软失败），或者在最好情况下，显示一些视觉提示，表明撤销信息不可用。
- en: Note
  id: totrans-127
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注
- en: '*To address this problem, Google Chrome disables online revocation checks*^([[68](#ftn.ch06fn11)])
    *altogether, and now uses its update mechanism to proactively push revocation
    information to browsers, without requiring an application update or restart.*^([[69](#ftn.ch06fn12)])
    *Thus Chrome can have an up-to-date local cache of revocation information, which
    makes certificate validation both faster and more reliable. This is can be considered
    yet another blacklist (Chrome calls it a* CRL set*), this time based on information
    published by each CA. The browser vendor effectively managing revocation data
    on the user’s behalf is quite novel; not everyone thinks it’s a good idea, but
    it has worked well so far.*'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: '*为了解决这个问题，Google Chrome 完全禁用了在线撤销检查*^([[68](#ftn.ch06fn11)])，*并且现在使用其更新机制主动将撤销信息推送到浏览器，而无需应用程序更新或重启。*^([[69](#ftn.ch06fn12)])
    *因此，Chrome 可以拥有一个最新的本地撤销信息缓存，这使得证书验证更加快速且可靠。这可以被视为另一个黑名单（Chrome 称之为*CRL 集*），这次基于每个
    CA 发布的信息。浏览器厂商有效地代表用户管理撤销数据是一个相当新颖的做法；虽然并不是每个人都认为这是个好主意，但到目前为止它表现得非常好。*'
- en: An alternative to directly pushing revocation information as part of browser
    updates is *OCSP stapling*, formerly known as the TLS *Certificate Status Request*
    extension.^([[70](#ftn.ch06fn13)]) Instead of requiring clients to issue an OCSP
    request for the server certificate, the relevant response is included (“stapled”)
    with the SSL handshake via the Certificate Status Request extension response.
    Because the response is signed by the CA, the client can trust it just as if it
    had fetched it directly from the CA’s OCSP server. If the server did not include
    an OCSP response in the SSL handshake, the client is expected to fetch one itself.
    OCSP stapling is supported by all major HTTP servers, but browser support is still
    patchy, especially on mobile versions where latency is an issue.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 直接将撤销信息作为浏览器更新的一部分推送的替代方案是*OCSP stapling*，以前称为 TLS *证书状态请求* 扩展。^([[70](#ftn.ch06fn13)])
    与其要求客户端向服务器证书发出 OCSP 请求，不如将相关响应（“钉住”）在 SSL 握手过程中通过证书状态请求扩展响应一起包含。由于响应由 CA 签名，客户端可以像直接从
    CA 的 OCSP 服务器获取它一样信任这个响应。如果服务器没有在 SSL 握手中包含 OCSP 响应，客户端则需要自行获取一个。OCSP stapling
    已被所有主流 HTTP 服务器支持，但浏览器支持仍然不稳定，尤其是在移动版本中，由于延迟问题。
- en: Android Certificate Blacklisting
  id: totrans-130
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Android证书黑名单
- en: 'As we learned in “[Android 4.x System Trust Store](ch06.html#android_4dotx_system_trust_store
    "Android 4.x System Trust Store")”, Android 4.0 added a management UI, as well
    as an SDK API, that allows for adding and removing trust anchors to the system
    trust store. This didn’t quite solve PKI’s number one problem, though: aside from
    the user manually disabling a compromised trust anchor, an OS update was still
    required to remove a compromised CA certificate. Additionally, because Android
    does not perform online revocation checks when validating certificate chains,
    there was no way to detect compromised end entity certificates, even if they have
    been revoked.'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在“[Android 4.x 系统信任库](ch06.html#android_4dotx_system_trust_store "Android
    4.x 系统信任库")”中所学，Android 4.0添加了管理UI，以及一个SDK API，允许将信任锚添加到系统信任库或移除它们。然而，这并没有完全解决PKI的首要问题：除了用户手动禁用受损的信任锚外，仍然需要操作系统更新才能移除受损的CA证书。此外，由于Android在验证证书链时不执行在线吊销检查，因此即使端实体证书已经被吊销，也无法检测到受损的证书。
- en: 'To solve this problem, Android 4.1 introduced certificate blacklists that can
    be modified without requiring an OS update. There are now two system blacklists:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解决这个问题，Android 4.1引入了证书黑名单，可以在不需要操作系统更新的情况下进行修改。目前有两个系统黑名单：
- en: A public key hash blacklist (to handle compromised CAs)
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 公钥哈希黑名单（用于处理受损的CA）
- en: A serial number blacklist (to handle compromised EE certificates)
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 序列号黑名单（用于处理受损的EE证书）
- en: The certificate chain validator component takes those two lists into consideration
    when verifying websites or user certificates. Let’s look at how this is implemented
    in a bit more detail.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 证书链验证器组件在验证网站或用户证书时会考虑这两个黑名单。让我们更详细地看一下如何实现这一点。
- en: 'Android uses a content provider to store OS settings in a system database.
    Some of those settings can be modified by third-party apps holding the necessary
    permissions, while some are reserved for the system and can only be changed in
    the system Settings, or by another system application. The settings reserved for
    the system are known as *secure settings*. Android 4.1 adds two new secure settings
    under the following URIs:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: Android使用内容提供者将操作系统设置存储在系统数据库中。一些设置可以由持有必要权限的第三方应用修改，而一些则保留给系统，仅能在系统设置中更改，或通过其他系统应用更改。保留给系统的设置被称为*安全设置*。Android
    4.1在以下URI下新增了两个安全设置：
- en: '*content://settings/secure/pubkey_blacklist*'
  id: totrans-137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*content://settings/secure/pubkey_blacklist*'
- en: '*content://settings/secure/serial_blacklist*'
  id: totrans-138
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*content://settings/secure/serial_blacklist*'
- en: 'As the names imply, the first one stores public key hashes of compromised CAs
    and the second one a list of EE certificate serial numbers. Additionally, the
    system server now starts a `CertBlacklister` component that registers itself as
    a `ContentObserver` for the two blacklist URIs. Whenever a new value is written
    to any of the blacklist secure settings, the `CertBlacklister` is notified and
    writes the value to a file on disk. The files are comprised of a comma-delimited
    list of hex-encoded public key hashes or certificate serial numbers. The files
    are:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 正如名字所示，第一个黑名单存储受损CA的公钥哈希，第二个黑名单则存储EE证书的序列号列表。此外，系统服务器现在启动了一个`CertBlacklister`组件，该组件注册为这两个黑名单URI的`ContentObserver`。每当写入任何黑名单安全设置的新值时，`CertBlacklister`会收到通知并将该值写入磁盘上的文件。文件包含一个由逗号分隔的十六进制编码公钥哈希或证书序列号的列表。文件为：
- en: 'Certificate blacklist: */data/misc/keychain/pubkey_blacklist.txt*'
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 证书黑名单：*/data/misc/keychain/pubkey_blacklist.txt*
- en: 'Serial number blacklist: */data/misc/keychain/serial_blacklist.txt*'
  id: totrans-141
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 序列号黑名单：*/data/misc/keychain/serial_blacklist.txt*
- en: 'Why write the files to disk when they are already available in the settings
    database? Because the component that actually uses the blacklists is a standard
    Java CertPath API class that doesn’t know anything about Android and its system
    databases. The certificate path validator class, `PKIXCertPathValidatorSpi`, is
    part of the Bouncy Castle JCA provider modified to handle certificate blacklists,
    which are an Android-specific feature and not defined in the standard CertPath
    API. The PKIX certificate validation algorithm that the class implements is rather
    complex, but what Android 4.1 adds is fairly straightforward:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么要将文件写入磁盘，而它们已经可以在设置数据库中找到？因为实际使用黑名单的组件是一个标准的Java CertPath API类，它对Android及其系统数据库一无所知。证书路径验证器类`PKIXCertPathValidatorSpi`是Bouncy
    Castle JCA提供程序的一部分，经过修改以处理证书黑名单，这是Android特有的功能，标准的CertPath API中没有定义。该类实现的PKIX证书验证算法相当复杂，但Android
    4.1所添加的功能相对简单：
- en: When verifying an EE (leaf) certificate, check to see if its serial number is
    in the serial number blacklist. If so, return the same error (exception) as if
    the certificate has been revoked.
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在验证 EE（叶子）证书时，检查其序列号是否在序列号黑名单中。如果在，则返回与证书已被吊销相同的错误（异常）。
- en: When verifying a CA certificate, check to see if the hash of its public key
    is in the public key blacklist. If so, return the same error as if the certificate
    has been revoked.
  id: totrans-144
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在验证 CA 证书时，检查其公钥的哈希值是否在公钥黑名单中。如果在，则返回与证书已被吊销相同的错误。
- en: Note
  id: totrans-145
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '*Using the unqualified serial number to index blacklisted EE certificates could
    be a problem if two or more certificates from different CAs happen to have the
    same serial number. In this case, blacklisting just one of the certificates will
    effectively blacklist all others with the same serial number. In practice, though,
    most public CAs use long and randomly generated serial numbers so the probability
    of collision is quite low.*'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: '*如果使用不合格的序列号来索引被列入黑名单的 EE 证书，可能会出现问题，如果两个或更多来自不同 CA 的证书恰好具有相同的序列号。在这种情况下，仅列入黑名单其中一张证书将有效地将所有具有相同序列号的证书都列入黑名单。然而在实际中，大多数公共
    CA 使用长且随机生成的序列号，因此碰撞的概率非常低。*'
- en: The certificate path validator component is used throughout the whole system,
    so blacklists affect applications that use HTTP client classes, as well as the
    native Android browser and `WebView`. As mentioned above, modifying the blacklists
    requires system permissions, so only core system apps can change it. There are
    no apps in the AOSP source that actually call those APIs, but a good candidate
    to manage blacklists are the Google services components, available on “Google
    Experience” devices (that is, devices with the Play Store client preinstalled).
    These manage Google accounts and access to Google services, and provide push-style
    notifications via Google Client Messaging (GCM). Because GCM allows for real-time
    server-initiated push notifications, it’s a safe bet that those will be used to
    trigger certificate blacklist updates.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 证书路径验证器组件在整个系统中都被使用，因此黑名单会影响使用 HTTP 客户端类的应用程序，以及原生 Android 浏览器和 `WebView`。如上所述，修改黑名单需要系统权限，因此只有核心系统应用程序才能进行修改。AOSP
    源代码中没有实际调用这些 API 的应用程序，但一个管理黑名单的好候选者是 Google 服务组件，这些组件可以在“Google Experience”设备上找到（即预安装了
    Play Store 客户端的设备）。这些组件管理 Google 帐户和 Google 服务的访问，并通过 Google 客户端消息传递（GCM）提供推送式通知。由于
    GCM 允许实时服务器发起的推送通知，因此可以放心地认为这些推送将用于触发证书黑名单更新。
- en: Reexamining the PKI Trust Model
  id: totrans-148
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 重新审视 PKI 信任模型
- en: 'Android has taken steps to make its trust store more flexible by allowing on-demand
    modification of both trust anchors and certificate blacklists without requiring
    a system update. While certificate blacklisting does make Android more resilient
    to some PKI-related attacks and vulnerabilities, it doesn’t quite solve all problems
    related to using certificates issued by public CAs. We present some of those problems
    and the proposed solutions next. We then conclude our discussion of PKI and SSL
    with a description of Android’s implementation of one of those solutions: certificate
    pinning.'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: Android 已采取措施，使其信任库更加灵活，允许按需修改信任锚点和证书黑名单，而无需系统更新。尽管证书黑名单确实使 Android 更加抵抗某些与公钥基础设施（PKI）相关的攻击和漏洞，但它并不能完全解决所有与使用公共
    CA 签发的证书相关的问题。接下来我们将介绍一些这些问题以及提出的解决方案。然后，我们将通过描述 Android 实现其中一种解决方案——证书钉扎来结束我们对
    PKI 和 SSL 的讨论。
- en: Trust Problems in Today’s PKI
  id: totrans-150
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 当今 PKI 中的信任问题
- en: In the highly unlikely case that you haven’t heard about it, the trustworthiness
    of the existing public CA model has been severely compromised in recent years.
    It has been suspect for a while, but recent high profile CA security breaches
    have brought this problem into the spotlight. Attackers have managed to issue
    certificates for a wide range of sites, including Windows Update servers and Gmail.
    Although not all were used (or at least they were not detected) in real attacks,
    the incidents have shown just how much of current Internet technology depends
    on certificates.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 在极不可能的情况下，如果你还没听说过，现有公共 CA 模型的可信度近年来遭到严重破坏。它已经存在一些问题，但最近一些高调的 CA 安全漏洞将这个问题推到了风口浪尖。攻击者成功地为许多网站签发了证书，包括
    Windows 更新服务器和 Gmail。尽管并非所有这些证书都在实际攻击中被使用（或至少没有被检测到），但这些事件展示了当前互联网技术在多大程度上依赖于证书。
- en: Fraudulent certificates can be used for anything from installing malware to
    spying on Internet communication, all while fooling users into thinking that they
    are using a secure channel or installing a trusted executable. Unfortunately,
    better security for CAs is not a solution because major CAs have willingly issued
    hundreds of certificates for unqualified names such as *localhost*, *webmail*,
    and *exchange*.^([[71](#ftn.ch06fn14)]) Certificates issued for unqualified host
    names can be used to launch a MITM attack against clients that accesses internal
    servers using their unqualified name, thus making it easy to eavesdrop on internal
    corporate traffic. And, of course, there is also the matter of compelled certificate
    creation, where a government agency could compel a CA to issue a false certificate
    to be used for intercepting secure traffic.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 欺诈性证书可以用于从安装恶意软件到监视互联网通信的一切活动，同时欺骗用户认为他们正在使用安全的通道或安装受信的可执行文件。不幸的是，仅仅提高 CA 的安全性并不是解决方案，因为一些主要的
    CA 乐意为像*localhost*、*webmail*和*exchange*这样不合格的名称颁发数百个证书^([[71](#ftn.ch06fn14)])。为不合格主机名颁发的证书可以用来对访问内部服务器时使用不合格名称的客户端发动中间人（MITM）攻击，从而轻松监听内部企业流量。当然，还有被强制颁发证书的问题，政府机构可以强迫
    CA 颁发虚假证书，用于拦截安全通信流量。
- en: Clearly the current PKI system, which is largely based on a preselected set
    of trusted CAs (whose certificates are preinstalled as trust anchors), is problematic,
    but what are some of the actual problems? There are different takes on this, but
    for starters, there are too many public CAs. The Electronic Frontier Foundation’s
    SSL Observatory project^([[72](#ftn.ch06fn15)]) has shown that more than 650 public
    CAs are trusted by major browsers. Recent Android versions ship with more than
    100 trusted CA certificates and until version 4.0, the only way to remove a trusted
    certificate was through a vendor-initiated OS update.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，当前的 PKI 系统主要基于一组预选的受信 CA（其证书作为信任锚预先安装），这系统存在问题，但到底有哪些实际问题呢？对此有不同的看法，但首先，有太多的公共
    CA。电子前沿基金会的 SSL 天文台项目^([[72](#ftn.ch06fn15)]) 显示，主流浏览器信任超过 650 个公共 CA。最近的安卓版本预装了超过
    100 个受信 CA 证书，且直到 4.0 版本之前，移除信任证书的唯一方式是通过厂商发布的操作系统更新。
- en: Additionally, there is generally no technical restriction on which certificates
    CAs can issue. As the Comodo and DigiNotar attacks, as well as the recent ANNSI^([[73](#ftn.ch06fn16)])
    intermediate CA incident, have shown, anyone can issue a certificate for **.google.com*
    (name constraints don’t apply to root CAs and don’t really work for a public CA).
    Furthermore, because CAs don’t publicize the certificates they have issued, there
    is no way for site operators (in this case, Google) to know when someone issues
    a new, possibly fraudulent certificate for one of their sites and take appropriate
    action (certificate transparency standards^([[74](#ftn.ch06fn17)]) aim to address
    this). In short, with the current system, if any of the built-in trust anchors
    are compromised, an attacker could issue a certificate for any site, and neither
    users accessing it nor the site’s owner would notice.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，通常没有技术性限制，规定 CA 可以颁发哪些证书。正如 Comodo 和 DigiNotar 攻击事件，以及最近的 ANNSI^([[73](#ftn.ch06fn16)])
    中间 CA 事件所示，任何人都可以为 **.google.com**（根 CA 不适用名称限制，并且对公共 CA 也没有太大作用）颁发证书。此外，由于 CA
    不会公开他们已颁发的证书，网站运营商（在这种情况下是 Google）无法知道有人为他们的网站颁发了新的、可能是欺诈性的证书，并采取适当的措施（证书透明度标准^([[74](#ftn.ch06fn17)])
    旨在解决这个问题）。简而言之，在当前的系统下，如果任何内置的信任锚被攻破，攻击者就可以为任何网站颁发证书，而访问该网站的用户和网站所有者都不会察觉。
- en: Radical Solutions
  id: totrans-155
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 激进的解决方案
- en: Proposed solutions range from radical—scrap the whole PKI idea altogether and
    replace it with something new and better (DNSSEC is a usual favorite); to moderate—use
    the current infrastructure but do not implicitly trust CAs; to evolutionary—maintain
    compatibility with the current system but extend it in ways that limit the damage
    of CA compromise.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 提出的解决方案从激进到温和不等——激进的方案是完全抛弃现有的公钥基础设施（PKI）概念，替换成一种全新的、更好的方法（DNSSEC 通常是一个常见的选择）；温和的方案是利用现有的基础设施，但不对证书颁发机构（CA）进行隐性信任；进化性的方案则是保持与现有系统的兼容性，但通过扩展其功能来限制
    CA 被攻破的损害。
- en: Unfortunately, DNSSEC is still not universally deployed, although the key TLD
    domains have already been signed. Additionally, it is inherently hierarchical—with
    country top-level domains controlled by the respective countries—and actually
    more rigid than PKI, so it doesn’t really fit the bill too well. Improving the
    current PKI situation is an area of active research, and other viable radical
    solutions have yet to emerge.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，DNSSEC 仍未普遍部署，尽管关键的顶级域名（TLD）域已经签名。此外，它本质上是层级化的——国家顶级域名由各自的国家控制——实际上比 PKI
    更为僵化，因此并不完全适用。改善当前 PKI 状况是一个活跃的研究领域，其他可行的激进解决方案尚未出现。
- en: Moving toward the moderate side, the SSH model has also been suggested (sometimes
    called *Trust on First Use*, or *TOFU*). In this model, no sites or CAs are initially
    trusted, and users decide which site to trust on first access. Unlike SSH however,
    the number of sites that you access directly or indirectly (via CDNs, embedded
    content, and so on) is virtually unlimited, and user-managed trust is quite unrealistic.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 向中庸方向发展，SSH 模型也被提出（有时称为*首次使用时信任*，或*TOFU*）。在这种模型中，最初没有任何网站或证书颁发机构（CA）被信任，用户决定首次访问时信任哪个网站。然而，与
    SSH 不同，你直接或间接（通过 CDN、嵌入式内容等）访问的网站数量几乎是无限的，用户管理信任显得非常不现实。
- en: Convergence and Trust Agility
  id: totrans-159
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Convergence 和信任灵活性
- en: In a similar vein but much more practical is Convergence.^([[75](#ftn.ch06fn18)])
    *Convergence* is a system based on the idea of *trust agility*, defined as “the
    ability to easily choose who you trust and to revise that decision at any time.”
    It both abolishes the browser (or OS) preselected trust anchor set, and recognizes
    that users cannot be relied on to independently make trust decisions about all
    the sites they visit. Trust decisions are delegated to a set of notaries that
    can vouch for a site by confirming that the certificate you receive from a site
    is one they have seen before. If multiple notaries point out that the same certificate
    as correct, users can be reasonably sure that it is genuine and therefore trustworthy.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 与此类似，但更为实用的是 Convergence。^([[75](#ftn.ch06fn18)])*Convergence* 是一个基于 *信任灵活性*
    理念的系统，信任灵活性定义为“能够轻松选择你信任的人，并随时修订该决定。”它既废除了浏览器（或操作系统）预选的信任锚集，又认识到用户无法独立做出关于他们访问的所有网站的信任决策。信任决策被委托给一组公证人，这些公证人可以通过确认你从网站收到的证书是否是他们之前见过的来为网站背书。如果多个公证人指出同一个证书是正确的，用户可以合理地确信它是真实的，因此是值得信任的。
- en: Convergence is not a formal standard, but a working implementation has been
    released, including a Firefox plugin (client) and server-side notary software.
    While this system is promising, the number of available notaries is currently
    limited, and Google has publicly stated that it won’t add it to Chrome. Additionally,
    it cannot currently be implemented as a browser extension, because Chrome does
    not allow third-party extensions to override the default certificate validation
    module.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: Convergence 并不是一个正式标准，但已经发布了一个工作实现，包括 Firefox 插件（客户端）和服务器端公证软件。虽然这个系统很有前景，但目前可用的公证人数量有限，谷歌已经公开表示不会将其添加到
    Chrome 中。此外，由于 Chrome 不允许第三方扩展覆盖默认的证书验证模块，因此目前无法作为浏览器扩展实现。
- en: Certificate Pinning
  id: totrans-162
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 证书钉扎
- en: That leads us to the current evolutionary solutions, which have been deployed
    to a fairly large user base, mostly courtesy of the Chrome browser. One is certificate
    blacklisting, which we already discussed, and the other is certificate pinning.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 这就引出了当前的演化解决方案，这些方案已经部署给了相当大范围的用户，主要得益于 Chrome 浏览器。其中一个是证书黑名单，我们已经讨论过了，另一个是证书钉扎。
- en: '*Certificate pinning* (or more accurately, *public key pinning*) takes a converse
    to the blacklisting approach: it whitelists the keys that are trusted to sign
    certificates for a particular site. Pinning was introduced in Google Chrome version
    13 in order to limit the CAs that can issue certificates for Google properties.
    It is implemented by maintaining a list of public keys that are trusted to issue
    certificates for a particular DNS name. The list is consulted when validating
    the certificate chain for a host, and if the chain doesn’t include at least one
    of the whitelisted keys, validation fails. In practice, the browser keeps a list
    of SHA-1 hashes of the `SubjectPublicKeyInfo` (SPKI) field of trusted certificates.
    Pinning the public keys instead of the actual certificates allows for updating
    host certificates without breaking validation and requiring pinning information
    updates.'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: '*证书固定*（更准确地说，是 *公钥固定*）采取了与黑名单方法相反的做法：它将被信任的用于签发特定站点证书的密钥列入白名单。固定功能最初是在 Google
    Chrome 版本 13 中引入的，目的是限制可以为 Google 属性签发证书的 CA。它通过维护一份受信任的公钥列表来实现，这些公钥被信任用于签发特定
    DNS 名称的证书。验证主机的证书链时，会查阅该列表，如果链中没有至少一个白名单中的密钥，验证就会失败。实际上，浏览器会保留受信任证书的 `SubjectPublicKeyInfo`（SPKI）字段的
    SHA-1 哈希列表。将公钥固定而不是固定实际的证书，允许更新主机证书而不会破坏验证，也不需要更新固定信息。'
- en: 'However, a hardcoded pin list doesn’t really scale and a couple of new Internet
    standards have been proposed to help solve this scalability problem: Public Key
    Pinning Extension for HTTP (PKPE)^([[76](#ftn.ch06fn19)]) by Google and Trust
    Assertions for Certificate Keys (TACK)^([[77](#ftn.ch06fn20)]) by Moxie Marlinspike.
    The first one is simpler and proposes a new HTTP header (`Public-Key-Pin`, or
    *PKP*) that holds pinning information about a host’s certificate. The header value
    can include public key hashes, pin lifetime, and a flag that specifies whether
    pinning should be applied to subdomains of the current host. Pinning information
    (or simply *pins*) is cached by the browser and used when making trust decisions
    until it expires. Pins are required to be delivered over a secure (SSL) connection,
    and the first connection that includes a PKP header is implicitly trusted (or
    optionally validated against pins built into the client). The protocol also supports
    an endpoint to report failed validations via the `report-uri` directive and allows
    for a non-enforcing mode (specified with the `Public-Key-Pins-Report-Only` header),
    where validation failures are reported but connections are still allowed. This
    makes it possible to notify host administrators about possible MITM attacks against
    their sites, so that they can take appropriate action.'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，硬编码的固定列表并不能真正扩展，因此已经提出了几个新的互联网标准来帮助解决这一可扩展性问题：Google 提出的 HTTP 公钥固定扩展（PKPE）^([[76](#ftn.ch06fn19)])
    和 Moxie Marlinspike 提出的证书密钥信任断言（TACK）^([[77](#ftn.ch06fn20)])。第一个较为简单，提出了一个新的
    HTTP 头部（`Public-Key-Pin`，或 *PKP*），用于保存主机证书的固定信息。该头部值可以包括公钥哈希、固定的有效期以及一个标志，用于指定是否将固定应用于当前主机的子域。固定信息（或简单地称为
    *固定项*）由浏览器缓存，并在做出信任决策时使用，直到它过期。固定项需要通过安全（SSL）连接传输，并且第一个包含 PKP 头部的连接被隐式信任（或可以选择验证客户端中内置的固定项）。该协议还支持通过
    `report-uri` 指令报告验证失败的端点，并允许非强制模式（通过 `Public-Key-Pins-Report-Only` 头部指定），在该模式下，验证失败会被报告，但连接仍然允许。这使得可以通知主机管理员他们站点可能遭遇的
    MITM 攻击，以便他们采取适当的措施。
- en: The TACK proposal, on the other hand, is somewhat more complex and defines a
    new TLS extension (also called TACK) that carries pinning information signed with
    a dedicated *TACK key*. TLS connections to a pinned hostname require the server
    to present a “tack” containing the pinned key and a corresponding signature over
    the TLS server’s public key. Thus, both pinning information exchange and validation
    are carried out at the TLS layer. In contrast, PKPE uses the HTTP layer (over
    TLS) to send pinning information to clients, but also requires validation to be
    performed at the TLS layer, dropping the connection if validation against the
    pins fails.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，TACK 提案则稍微复杂一些，它定义了一个新的 TLS 扩展（也叫 TACK），用于携带用专用*TACK 密钥*签名的固定信息。连接到固定主机名的
    TLS 连接要求服务器提供一个包含固定密钥和相应签名的“tack”，这个签名是对 TLS 服务器公钥的签名。因此，固定信息的交换和验证都是在 TLS 层进行的。相比之下，PKPE
    使用 HTTP 层（通过 TLS）向客户端发送固定信息，但也要求在 TLS 层进行验证，如果验证失败，则断开连接。
- en: Now that we have an idea how pinning works, let’s see how it’s implemented on
    Android.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经了解了固定功能的工作原理，接下来我们看看它在 Android 上是如何实现的。
- en: Certificate Pinning in Android
  id: totrans-168
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Android中的证书固定
- en: 'Pinning is one of the many security enhancements introduced in Android 4.2\.
    The OS doesn’t come with any built-in pins, but instead reads them from a file
    in the */data/misc/keychain/* directory (where user-added certificates and blacklists
    are stored). The file is simply called *pins* and is in the following format (see
    [Example 6-10](ch06.html#system_pins_file_format "Example 6-10. System pins file
    format")):'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 证书固定是Android 4.2中引入的众多安全增强功能之一。操作系统本身并不带有任何内置的固定项，而是从*/data/misc/keychain/*目录中的文件读取它们（该目录存储了用户添加的证书和黑名单）。该文件名为*pins*，其格式如下所示（参见[示例6-10](ch06.html#system_pins_file_format
    "示例6-10. 系统固定文件格式")）：
- en: Example 6-10. System pins file format
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 示例6-10. 系统固定文件格式
- en: '[PRE9]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Here, `enforcing` is either `true` or `false` and is followed by a list of SPKI
    SHA-512 hashes separated by commas. Note that there is no validity period, so
    pins are valid until deleted. The file is used not only by the browser, but system-wide
    by virtue of pinning being integrated in *libcore*. In practice, this means that
    the default (and only) system `X509TrustManager` implementation (`TrustManagerImpl`)
    consults the pin list when validating certificate chains.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`enforcing`的值为`true`或`false`，后面跟着一个由逗号分隔的SPKI SHA-512哈希列表。请注意，固定项没有有效期，因此它们在被删除之前是有效的。该文件不仅由浏览器使用，还被系统广泛使用，因为固定功能已集成在*libcore*中。实际上，这意味着默认（也是唯一的）系统`X509TrustManager`实现（`TrustManagerImpl`）在验证证书链时会查询固定列表。
- en: 'But there’s a twist: the standard `checkServerTrusted()` method doesn’t consult
    the pin list. Thus, any legacy libraries that do not know about certificate pinning
    would continue to function exactly as before, regardless of the contents of the
    pin list. This has probably been done for compatibility reasons and is something
    to be aware of: running on Android 4.2 or above doesn’t necessarily mean that
    you get the benefit of system-level certificate pins. The pinning functionality
    is exposed to third-party libraries and apps via the new `X509TrustManagerExtensions`
    SDK class. It has a single method, `checkServerTrusted()` (full signature shown
    in [Example 6-11](ch06.html#x509trustmanagerextensions_certificate_v "Example 6-11. X509TrustManagerExtensions
    certificate validation method")) that returns a validated chain on success or
    throws a `CertificateException` if validation fails.'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 但有一个变化：标准的`checkServerTrusted()`方法并不会查询固定列表。因此，任何不支持证书固定的旧版库仍然会按照原来的方式运行，无论固定列表的内容如何。这可能是出于兼容性考虑，因此需要注意：在Android
    4.2或以上版本运行并不意味着你可以享受到系统级证书固定的好处。固定功能通过新的`X509TrustManagerExtensions` SDK类暴露给第三方库和应用程序。该类有一个方法，`checkServerTrusted()`（完整签名请参见[示例6-11](ch06.html#x509trustmanagerextensions_certificate_v
    "示例6-11. X509TrustManagerExtensions证书验证方法")），成功时返回验证后的链，若验证失败则抛出`CertificateException`。
- en: Example 6-11. `X509TrustManagerExtensions` certificate validation method
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 示例6-11. `X509TrustManagerExtensions`证书验证方法
- en: '[PRE10]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The last parameter, `host`, is what the underlying implementation (`TrustManagerImpl`)
    uses to search the pin list for matching pins. If one is found, the public keys
    in the chain being validated will be checked against the hashes in the pin entry
    for that host. If none matches, validation will fail and you will get a `CertificateException`.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一个参数`host`是底层实现（`TrustManagerImpl`）用来在固定列表中查找匹配固定项的依据。如果找到匹配项，将会检查验证中的公钥是否与该主机的固定项哈希匹配。如果没有匹配项，验证将失败，且会抛出`CertificateException`。
- en: What part of the system uses the new pinning functionality then? The default
    SSL engine (JSSE provider), namely the client handshake (`ClientHandshakeImpl`),
    and SSL socket (`OpenSSLSocketImpl`) implementations check their underlying `X509TrustManager`
    and if it supports pinning, they perform additional validation against the pin
    list. If validation fails, the connection won’t be established, thus implementing
    pin validation on the TLS layer as required by the standards discussed in the
    previous section.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 那么系统的哪个部分使用了新的固定功能呢？默认的SSL引擎（JSSE提供者），即客户端握手（`ClientHandshakeImpl`）和SSL套接字（`OpenSSLSocketImpl`）实现会检查其底层的`X509TrustManager`，如果它支持固定功能，则会对固定列表进行额外验证。如果验证失败，连接将无法建立，从而在TLS层实现证书固定验证，符合前面章节讨论的标准要求。
- en: The *pins* file is not written directly by the OS. Its updates are triggered
    by a broadcast (`android.intent.action.UPDATE_PINS`) that contains the new pins
    in its extras. The extras contain the path to the new pins file, its new version
    (stored in */data/misc/keychain/metadata/version/*), a hash of the current pins,
    and a *SHA512withRSA* signature over all the above. The receiver of the broadcast
    (`CertPinInstallReceiver`) then verifies the version, hash, and signature, and
    if valid, atomically replaces the current pins file with new content (the same
    procedure is used for updating the premium SMS numbers list). Signing the new
    pins ensures that they can only by updated by whoever controls the private signing
    key. The corresponding public key used for validation is stored as a system secure
    setting under the *config_update_certificate* key (usually in the secure table
    of the */data/data/com.android.providers.settings/ databases/settings.db*). (As
    of this writing, the *pins* file on Nexus devices contains more than 40 pin entries,
    which cover most Google properties, including Gmail, YouTube, and Play Store servers.)
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: '*pins* 文件并不是由操作系统直接写入的。它的更新是由一个广播触发的（`android.intent.action.UPDATE_PINS`），该广播在其附加信息中包含了新的
    pins。附加信息包括新 pins 文件的路径、其新版本（存储在 */data/misc/keychain/metadata/version/*）、当前 pins
    的哈希值以及对上述所有内容的 *SHA512withRSA* 签名。广播的接收者（`CertPinInstallReceiver`）随后验证版本、哈希值和签名，如果有效，原子性地将当前
    pins 文件替换为新的内容（更新付费短信号码列表时也使用相同的过程）。签署新的 pins 确保它们只能由控制私钥签名的人进行更新。用于验证的公钥存储为系统安全设置，位于
    *config_update_certificate* 键下（通常在 */data/data/com.android.providers.settings/
    数据库/settings.db* 的安全表中）。 （截至本文撰写时，Nexus 设备上的 *pins* 文件包含超过 40 条 pin 记录，涵盖了大多数
    Google 服务，包括 Gmail、YouTube 和 Play Store 服务器。）'
- en: Summary
  id: totrans-179
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: Android builds on standard Java APIs such as JSSE and CertPath to implement
    SSL connections and the required authentication mechanisms. Most of the secure
    sockets functionality is provided by the largely native, OpenSSL-based JSSE implementation,
    while certificate validation and trust store management are implemented in Java.
    Android provides a shared system trust store that can be managed via the Settings
    UI or the `KeyStore` API. All applications that use SSL or certificate validation
    APIs inherit the system trust anchors, unless an app-specific trust store is explicitly
    specified. Certificate validation in Android does not use online revocation checking
    but relies on the system certificate blacklist to detect compromised CA or end
    entity certificates. Finally, recent versions of Android support system-level
    certificate pinning in order to be able to constrain the set of certificates that
    are allowed to issue a server certificate for a particular host.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: Android 基于标准的 Java API，如 JSSE 和 CertPath，来实现 SSL 连接和所需的认证机制。大多数安全套接字功能是通过主要基于
    OpenSSL 的本地 JSSE 实现提供的，而证书验证和信任存储管理则是用 Java 实现的。Android 提供了一个共享的系统信任存储，可以通过设置界面或
    `KeyStore` API 来管理。所有使用 SSL 或证书验证 API 的应用程序都会继承系统的信任锚，除非明确指定了特定应用的信任存储。Android
    中的证书验证不使用在线吊销检查，而是依赖系统证书黑名单来检测被破坏的 CA 或终端实体证书。最后，Android 的最新版本支持系统级证书钉扎，以便能够限制哪些证书可以为特定主机颁发服务器证书。
- en: '* * *'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: ^([[58](#ch06fn01)]) T. Dierks and E. Rescorla, *The Transport Layer Security
    (TLS) Protocol Version 1.2*, August 2008, *[http://tools.ietf.org/html/rfc5246](http://tools.ietf.org/html/rfc5246)*
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: ^([[58](#ch06fn01)]) T. Dierks 和 E. Rescorla，*传输层安全协议（TLS）版本 1.2*，2008 年 8 月，*[http://tools.ietf.org/html/rfc5246](http://tools.ietf.org/html/rfc5246)*
- en: ^([[59](#ch06fn02)]) A. Freier, P. Karlton, and P. Kocher, *The Secure Sockets
    Layer (SSL) Protocol Version 3.0*, August 2011, *[http://tools.ietf.org/html/rfc6101](http://tools.ietf.org/html/rfc6101)*
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: ^([[59](#ch06fn02)]) A. Freier, P. Karlton 和 P. Kocher，*安全套接字层（SSL）协议版本 3.0*，2011
    年 8 月，*[http://tools.ietf.org/html/rfc6101](http://tools.ietf.org/html/rfc6101)*
- en: ^([[60](#ch06fn03)]) Mozilla, *Mozilla CA Certificate Inclusion Policy (Version
    2.2)*, *[https://www.mozilla.org/en-US/about/governance/policies/security-group/certs/policy/inclusion/](https://www.mozilla.org/en-US/about/governance/policies/security-group/certs/policy/inclusion/)*
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: ^([[60](#ch06fn03)]) Mozilla，*Mozilla CA 证书包含政策（版本 2.2）*，*[https://www.mozilla.org/en-US/about/governance/policies/security-group/certs/policy/inclusion/](https://www.mozilla.org/en-US/about/governance/policies/security-group/certs/policy/inclusion/)*
- en: ^([[61](#ch06fn04)]) S. Santesson et al., *X.509 Internet Public Key Infrastructure
    Online Certificate Status Protocol -OCSP*, June 2013, *[http://tools.ietf.org/html/rfc6960](http://tools.ietf.org/html/rfc6960)*
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: ^([[61](#ch06fn04)]) S. Santesson 等人，*X.509互联网公共密钥基础设施在线证书状态协议 - OCSP*，2013年6月，*[http://tools.ietf.org/html/rfc6960](http://tools.ietf.org/html/rfc6960)*
- en: ^([[62](#ch06fn05)]) Oracle, *Java™ Secure Socket Extension (JSSE) Reference
    Guide*, *[http://docs.oracle.com/javase/7/docs/technotes/guides/security/jsse/JSSERefGuide.html](http://docs.oracle.com/javase/7/docs/technotes/guides/security/jsse/JSSERefGuide.html)*
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: ^([[62](#ch06fn05)]) Oracle，*Java™安全套接字扩展（JSSE）参考指南*，*[http://docs.oracle.com/javase/7/docs/technotes/guides/security/jsse/JSSERefGuide.html](http://docs.oracle.com/javase/7/docs/technotes/guides/security/jsse/JSSERefGuide.html)*
- en: ^([[63](#ch06fn06)]) E. Rescorla, *HTTP Over TLS*, May 2000, *[http://tools.ietf.org/html/rfc2818](http://tools.ietf.org/html/rfc2818)*
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: ^([[63](#ch06fn06)]) E. Rescorla，*通过TLS的HTTP*，2000年5月，*[http://tools.ietf.org/html/rfc2818](http://tools.ietf.org/html/rfc2818)*
- en: ^([[64](#ch06fn07)]) D. Cooper et al., *Internet X.509 Public Key Infrastructure
    Certificate and Certificate Revocation List (CRL) Profile*, May 2008, *[http://tools.ietf.org/html/rfc5280](http://tools.ietf.org/html/rfc5280)*
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: ^([[64](#ch06fn07)]) D. Cooper 等人，*互联网X.509公共密钥基础设施证书和证书吊销列表（CRL）配置文件*，2008年5月，*[http://tools.ietf.org/html/rfc5280](http://tools.ietf.org/html/rfc5280)*
- en: ^([[65](#ch06fn08)]) Oracle, *Java™ PKI Programmer’s Guide, [http://docs.oracle.com/javase/7/docs/technotes/guides/security/certpath/CertPathProgGuide.html](http://docs.oracle.com/javase/7/docs/technotes/guides/security/certpath/CertPathProgGuide.html)*
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: ^([[65](#ch06fn08)]) Oracle，*Java™ PKI程序员指南*，*[http://docs.oracle.com/javase/7/docs/technotes/guides/security/certpath/CertPathProgGuide.html](http://docs.oracle.com/javase/7/docs/technotes/guides/security/certpath/CertPathProgGuide.html)*
- en: ^([[66](#ch06fn09)]) S. Blake-Wilson et al., *Transport Layer Security (TLS)
    Extensions*, June 2003, *[http://tools.ietf.org/html/rfc3546](http://tools.ietf.org/html/rfc3546)*
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: ^([[66](#ch06fn09)]) S. Blake-Wilson 等人，*传输层安全性（TLS）扩展*，2003年6月，*[http://tools.ietf.org/html/rfc3546](http://tools.ietf.org/html/rfc3546)*
- en: '^([[67](#ch06fn10)]) Square, Inc., *OkHttp: An HTTP & SPDY client for Android
    and Java applications*, *[http://square.github.io/okhttp/](http://square.github.io/okhttp/)*'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: ^([[67](#ch06fn10)]) Square, Inc.，*OkHttp：Android和Java应用程序的HTTP & SPDY客户端*，*[http://square.github.io/okhttp/](http://square.github.io/okhttp/)*
- en: ^([[68](#ch06fn11)]) Adam Langley, *Revocation checking and Chrome’s CRL*, Feb
    2012, *[https://www.imperialviolet.org/2012/02/05/crlsets.html](https://www.imperialviolet.org/2012/02/05/crlsets.html)*
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: ^([[68](#ch06fn11)]) Adam Langley，*吊销检查与Chrome的CRL*，2012年2月，*[https://www.imperialviolet.org/2012/02/05/crlsets.html](https://www.imperialviolet.org/2012/02/05/crlsets.html)*
- en: ^([[69](#ch06fn12)]) Online revocation checks can still be enabled by setting
    the *EnableOnlineRevocationChecks* option to *true* (default is *false*).
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: ^([[69](#ch06fn12)]) 通过设置*EnableOnlineRevocationChecks*选项为*true*（默认为*false*），仍然可以启用在线吊销检查。
- en: '^([[70](#ch06fn13)]) D. Eastlake 3rd, *Transport Layer Security (TLS) Extensions:
    Extension Definitions*, Section 8, January 2011, *[http://tools.ietf.org/html/rfc6066#section-8](http://tools.ietf.org/html/rfc6066#section-8)*'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: ^([[70](#ch06fn13)]) D. Eastlake 3rd, *传输层安全性（TLS）扩展：扩展定义*，第8节，2011年1月，*[http://tools.ietf.org/html/rfc6066#section-8](http://tools.ietf.org/html/rfc6066#section-8)*
- en: ^([[71](#ch06fn14)]) Electronic Frontier Foundation, *Unqualified Names in the
    SSL Observatory*, April 2011, *[https://www.eff.org/deeplinks/2011/04/unqualified-names-ssl-observatory](https://www.eff.org/deeplinks/2011/04/unqualified-names-ssl-observatory)*
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: ^([[71](#ch06fn14)]) 电子前沿基金会，*SSL观测站中的非限定名称*，2011年4月，*[https://www.eff.org/deeplinks/2011/04/unqualified-names-ssl-observatory](https://www.eff.org/deeplinks/2011/04/unqualified-names-ssl-observatory)*
- en: ^([[72](#ch06fn15)]) Electronic Frontier Foundation, *The EFF SSL Observatory*,
    *[https://www.eff.org/observatory](https://www.eff.org/observatory)*
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: ^([[72](#ch06fn15)]) 电子前沿基金会，*EFF SSL观测站*，*[https://www.eff.org/observatory](https://www.eff.org/observatory)*
- en: ^([[73](#ch06fn16)]) *Agence nationale de la sécurité des systèmes d’information*,
    French Network and Information Security Agency
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: ^([[73](#ch06fn16)]) *信息系统安全国家局*，法国网络与信息安全局
- en: ^([[74](#ch06fn17)]) B. Laurie, A. Langley, and E. Kasper, *Certificate Transparency*,
    June 2013, *[http://tools.ietf.org/html/rfc6962](http://tools.ietf.org/html/rfc6962)*
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: ^([[74](#ch06fn17)]) B. Laurie, A. Langley 和 E. Kasper，*证书透明性*，2013年6月，*[http://tools.ietf.org/html/rfc6962](http://tools.ietf.org/html/rfc6962)*
- en: ^([[75](#ch06fn18)]) Thoughtcrime Labs, *Convergence*, *[http://convergence.io/](http://convergence.io/)*
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: ^([[75](#ch06fn18)]) Thoughtcrime Labs，*Convergence*，*[http://convergence.io/](http://convergence.io/)*
- en: ^([[76](#ch06fn19)]) C. Evans, C. Palmer, and R. Sleevi, *Public Key Pinning
    Extension for HTTP*, August 7, 2014, *[http://tools.ietf.org/html/draft-ietf-websec-key-pinning-20](http://tools.ietf.org/html/draft-ietf-websec-key-pinning-20)*
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: ^([[76](#ch06fn19)]) C. Evans, C. Palmer 和 R. Sleevi，*HTTP的公钥钉扎扩展*，2014年8月7日，*[http://tools.ietf.org/html/draft-ietf-websec-key-pinning-20](http://tools.ietf.org/html/draft-ietf-websec-key-pinning-20)*
- en: ^([[77](#ch06fn20)]) M. Marlinspike, *Trust Assertions for Certificate Keys*,
    January 7, 2013, *[http://tack.io/draft.html](http://tack.io/draft.html)*
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: ^([[77](#ch06fn20)]) M. Marlinspike, *证书密钥的信任声明*，2013年1月7日，*[http://tack.io/draft.html](http://tack.io/draft.html)*
