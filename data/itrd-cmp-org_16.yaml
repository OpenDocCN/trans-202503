- en: '**16'
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '**16'
- en: BITWISE LOGIC, MULTIPLICATION, AND DIVISION INSTRUCTIONS**
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 位运算、乘法和除法指令**
- en: '![Image](../images/pg297_Image_276.jpg)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/pg297_Image_276.jpg)'
- en: Now that you’ve learned about program organization, let’s turn our attention
    to computation. I’ll start by explaining the logic operators, which can be used
    to change individual bits in a value using a technique called *masking*.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经了解了程序的组织结构，让我们把注意力转向计算。我将从解释逻辑运算符开始，这些运算符可以通过一种叫做*掩码*的技术来改变值中的单个位。
- en: Then I’ll move on to shift operations, which provide a way to multiply or divide
    by powers of two. In the last two sections of this chapter, I’ll cover arithmetic
    multiplication and division of integers.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我将继续讲解移位操作，这提供了一种通过2的幂进行乘法或除法的方法。在本章的最后两个小节中，我将介绍整数的算术乘法和除法。
- en: '**Bitmasking**'
  id: totrans-5
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**位掩码**'
- en: It’s often better to think of data items as patterns of bits rather than numerical
    entities. For example, if you look back at [Table 2-5](ch02.xhtml#ch2tab5) in
    [Chapter 2](ch02.xhtml), you’ll see that the only difference between uppercase
    and lowercase alphabetic characters in ASCII is bit number 5, which is `1` for
    lowercase and `0` for upper-case. The ASCII code for `m`, for instance, is `0x6d`,
    and for `M`, it’s `0x4d`. If you wanted to write a function that changed the case
    of a string of alphabetic characters from lowercase to uppercase, you could view
    this as a numerical difference of 32\. You would need to determine the current
    case of the character and then decide whether to change it by subtracting 32.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，将数据项看作是位模式而不是数值实体会更为合适。例如，如果你回顾一下[第2-5表](ch02.xhtml#ch2tab5)中在[第2章](ch02.xhtml)的内容，你会看到，ASCII中大写字母和小写字母之间的唯一区别是第5位比特，大写字母为`0`，小写字母为`1`。例如，字符`m`的ASCII码是`0x6d`，而`M`是`0x4d`。如果你想编写一个函数，将一个字母字符串从小写转为大写，你可以将其视为数值差异32。你需要确定字符的当前大小写，并决定是否通过减去32来改变它。
- en: But there’s a faster way. We can change bit patterns by using logical bitwise
    operations and a mask, or bitmask. A *mask* is a specific pattern of bits that
    can be used to make specified bits in a variable either `1` or `0`, or to invert
    them. For example, to make sure an alphabetic character is uppercase, we need
    to ensure its bit number 5 is `0`, giving the mask `11011111` = `0xdf`. Then,
    using the previous example of `m`, `0x6d`*∧* `0xdf` = `0x4d`, which is `M`. If
    the character is already uppercase, then `0x4d`*∧* `0xdf` = `0x4d`, leaving it
    as uppercase. This solution avoids checking for the case before the conversion.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 但还有一种更快的方法。我们可以通过使用逻辑按位运算和掩码（位掩码）来改变位模式。*掩码*是一种特定的位模式，可以用来将变量中的指定位设置为`1`或`0`，或者反转它们。例如，为了确保一个字母字符是大写，我们需要确保其第5位为`0`，掩码为`11011111`
    = `0xdf`。然后，使用前面提到的`m`，`0x6d`*∧* `0xdf` = `0x4d`，即`M`。如果字符已经是大写，那么`0x4d`*∧* `0xdf`
    = `0x4d`，保持大写。这个解决方案避免了在转换前检查字符的大小写。
- en: We can use similar logic for other operations. To make a bit `1`, place a `1`
    in the appropriate bit position in the mask and use the bitwise OR operation.
    To produce a `0` in a bit position, place a `0` in that position and a `1` in
    each of the other bit positions in the mask and then use the bitwise AND operation.
    You can invert bits by placing a `1` in each bit position you want to invert and
    a `0` in all other positions and using the bitwise XOR operation.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以对其他操作使用类似的逻辑。为了将某一位设为`1`，需要在掩码中将适当的位位置设置为`1`，然后使用按位或操作。为了将某一位设置为`0`，则需要在该位置放置`0`，并在掩码中的其他位位置放置`1`，然后使用按位与操作。你可以通过将`1`放置在你想反转的每个位上，并在所有其他位置放置`0`，然后使用按位异或操作来反转位。
- en: '***Bitmasking in C***'
  id: totrans-9
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***C语言中的位掩码***'
- en: The program in [Listings 16-1](ch16.xhtml#ch16list1) to [16-3](ch16.xhtml#ch16list3)
    shows how to use a mask to convert all lowercase alphabetic characters in a text
    string to uppercase.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: '[列表16-1](ch16.xhtml#ch16list1)到[16-3](ch16.xhtml#ch16list3)中的程序展示了如何使用掩码将文本字符串中的所有小写字母字符转换为大写。'
- en: '*uppercase.c*'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: '*uppercase.c*'
- en: '[PRE0]'
  id: totrans-12
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '*Listing 16-1: A program to make an alphabetic text string uppercase*'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表16-1：将字母文本字符串转换为大写的程序*'
- en: '**NOTE**'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*This program, and many that follow in the book, uses the* read_str , write_char
    *, and* write_str *functions that you were asked to write in “Your Turn” [exercise
    14.4](ch14.xhtml#ch14exe4) on [page 293](ch14.xhtml#ch14you1). If you want to,
    you can instead use the* gets , putchar *, and* puts *functions, respectively,
    in the C standard library, but you’ll need to make the appropriate changes in
    the book’s functions that call them because their behavior is a little different.*'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: '*本程序，以及书中随后的许多程序，使用了* read_str、write_char *和* write_str *函数，这些函数是你在“轮到你”[练习
    14.4](ch14.xhtml#ch14exe4)中编写的，位于[第293页](ch14.xhtml#ch14you1)。如果你愿意，也可以改用C标准库中的*
    gets、putchar *和* puts *函数，但你需要在调用它们的书中函数中做出适当的更改，因为它们的行为略有不同。*'
- en: In [Listing 16-1](ch16.xhtml#ch16list1), we use `#define` to give a symbolic
    name to the maximum number of characters allowed ❶. The `char` array needs to
    have one more element to allow for the terminating `NUL` character ❷. The two
    instances of `#define` allow us to easily change the length in one place and make
    sure that the `char` array is the correct length and the correct value gets passed
    to the `read_str` function.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 在[清单 16-1](ch16.xhtml#ch16list1)中，我们使用`#define`为允许的最大字符数赋予一个符号名称❶。`char`数组需要多一个元素，以便存放终止的`NUL`字符❷。这两个`#define`的实例使得我们可以在一个地方轻松修改长度，确保`char`数组的长度正确，并将正确的值传递给`read_str`函数。
- en: You learned in [Chapter 14](ch14.xhtml) that when an argument’s name is used
    to pass a variable to a function, it’s passed by value; a copy of the variable’s
    value is passed to the called function. If we wanted to pass the address of the
    variable, we would need to use the `&` (address of) operator. C treats array names
    differently. When the name of an argument is an array, C uses pass by pointer;
    the address of the beginning of the array is passed to the function instead of
    a copy of all the values in the array. So, we *do not* use the `&` operator when
    passing an array as an argument to a function ❸. You’ll learn more about how arrays
    are implemented in [Chapter 17](ch17.xhtml).
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 你在[第14章](ch14.xhtml)中学到，当使用一个参数的名称来将变量传递给函数时，它是按值传递的；一个变量值的副本被传递给被调用的函数。如果我们想传递变量的地址，需要使用`&`（地址操作符）。C语言对数组名称的处理不同。当参数的名称是数组时，C使用指针传递；数组起始地址会被传递给函数，而不是数组中所有值的副本。因此，我们在将数组作为参数传递给函数时*不*使用`&`操作符❸。你将在[第17章](ch17.xhtml)中学到更多关于数组实现的知识。
- en: Nothing else is new in this `main` function, so we’ll move on to the `to_upper`
    subfunction. [Listing 16-2](ch16.xhtml#ch16list2) shows the header file for this
    function.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 这个`main`函数没有其他新内容，我们接着看`to_upper`子函数。[清单 16-2](ch16.xhtml#ch16list2)展示了这个函数的头文件。
- en: '*to_upper.h*'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: '*to_upper.h*'
- en: '[PRE1]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '*Listing 16-2: The header file for the* to_upper *function*'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 16-2：to_upper函数的头文件*'
- en: The first argument, `src_ptr`, is the address of the text string to be converted,
    and the second argument, `dest_ptr`, is the address where the result of the conversion
    will be stored. In [Listing 16-1](ch16.xhtml#ch16list1), we passed the same array
    as both the source and destination arrays, so `to_upper` will replace the characters
    stored in the array with the new values.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个参数`src_ptr`是要转换的文本字符串的地址，第二个参数`dest_ptr`是存放转换结果的地址。在[清单 16-1](ch16.xhtml#ch16list1)中，我们将相同的数组作为源数组和目标数组传递，因此`to_upper`将用新值替换数组中存储的字符。
- en: '[Listing 16-3](ch16.xhtml#ch16list3) gives the definition of `to_upper`.'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: '[清单 16-3](ch16.xhtml#ch16list3)给出了`to_upper`的定义。'
- en: '*to_upper.c*'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: '*to_upper.c*'
- en: '[PRE2]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '*Listing 16-3: A function to convert lowercase alphabetic characters to uppercase*'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 16-3：一个将小写字母字符转换为大写的函数*'
- en: To make sure bit 5 is `0`, we use a mask that has a `0` in bit position 5 and
    `1`s elsewhere ❶. While the current character is not the `NUL` character, we perform
    a bitwise AND with the character in the source array, which masks out bit 5 and
    allows all the other bits to remain the same in the result ❷. The result of this
    AND operation is stored in the destination array. Don’t forget to include the
    `NUL` character from the input text string ❸! Forgetting to do so is a programming
    error that won’t show up in testing if the byte in memory following where the
    output is stored happens to be `0x00` (the `NUL` character). If you change the
    length of the input text string, the next byte in memory may not be `0x00`. This
    error might therefore show up in a seemingly random way.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 为了确保第5位为`0`，我们使用一个在第5位为`0`，其他位为`1`的掩码❶。当当前字符不是`NUL`字符时，我们执行按位与操作，将源数组中的字符与掩码进行按位与运算，这样就会将第5位屏蔽，其他位在结果中保持不变❷。这个AND操作的结果存储在目标数组中。不要忘记包括输入文本字符串中的`NUL`字符❸！如果忘记这样做，这将是一个编程错误，并且在测试中不会显示出来，前提是输出存储位置后面的内存字节恰好是`0x00`（`NUL`字符）。如果你改变了输入文本字符串的长度，内存中的下一个字节可能就不是`0x00`了。这个错误因此可能会以一种看似随机的方式出现。
- en: Although this function returns a count of the number of characters processed,
    our `main` function does nothing with the value. A calling function doesn’t need
    to use a returned value, but I usually include a counting algorithm in functions
    like this for debugging purposes.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管这个函数返回处理的字符数，但我们的`main`函数并没有使用返回值。调用函数不需要使用返回值，但我通常会在类似的函数中包含一个计数算法，用于调试目的。
- en: '[Listing 16-4](ch16.xhtml#ch16list4) shows the assembly language the compiler
    generates for the `to_upper` function.'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: '[Listing 16-4](ch16.xhtml#ch16list4)显示了编译器为`to_upper`函数生成的汇编语言代码。'
- en: '*to_upper.s*'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: '*to_upper.s*'
- en: '[PRE3]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '*Listing 16-4: The compiler-generated assembly language for the function in
    [Listing 16-3](ch16.xhtml#ch16list3)*'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: '*Listing 16-4：编译器生成的[Listing 16-3](ch16.xhtml#ch16list3)函数的汇编语言*'
- en: You might notice that our compiler structures `while` loops such that it is
    unnecessary to copy the `NUL` character after the loop terminates ❷. But we still
    need to write correct C code, because another compiler might use a different structure
    for `while` loops.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会注意到，我们的编译器将`while`循环结构化，以至于在循环终止后不需要复制`NUL`字符❷。但我们仍然需要编写正确的C代码，因为另一个编译器可能会对`while`循环使用不同的结构。
- en: After loading the current character from the source `char` array, the first
    `and` instruction masks the word in `w0` with `-33` = `0xffffffdf`, which leaves
    bit 5 equal to `0`, thus making sure the character is uppercase ❶. The second
    `and` instruction uses the `0x000000ff` mask to leave us with an 8-bit `char`
    in `w0`.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 在从源`char`数组加载当前字符后，第一个`and`指令使用`-33` = `0xffffffdf`掩码对`w0`中的字进行掩码操作，这样第5位就变为`0`，从而确保字符为大写❶。第二个`and`指令使用`0x000000ff`掩码，确保我们得到一个8位的`char`值并存储在`w0`中。
- en: Treating the characters as bit patterns rather than as numerical values allows
    us to convert lowercase characters to uppercase while leaving upper-case characters
    unchanged, without using an `if` statement to first test the case of the character.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 将字符视为位模式而不是数值，可以让我们在不使用`if`语句先测试字符的大小写的情况下，将小写字符转换为大写，同时不改变大写字符。
- en: You might be wondering why the compiler used two `and` instructions instead
    of simply using `0xdf` as the mask with one `and` instruction. To answer this
    question, let’s look at the basic logic instructions in more detail.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会想知道为什么编译器使用了两个`and`指令，而不是仅仅使用`0xdf`作为掩码并用一个`and`指令来完成。为了回答这个问题，让我们更详细地看一下基本的逻辑指令。
- en: '***Basic Logic Instructions***'
  id: totrans-37
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***基本逻辑指令***'
- en: '*Logic instructions* work bitwise—that is, they operate on the individual bits
    in the corresponding bit positions of the two operands. The three basic logic
    instructions are for the AND, OR, or XOR operations. The A64 instruction set includes
    two versions for each operation. The shifted register versions allow you to shift
    one of the source operands before applying the operation. The immediate data versions
    allow only certain bit patterns, which I’ll explain after describing the instructions:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: '*逻辑指令*按位操作——即它们在两个操作数的对应位位置上逐位操作。这三种基本的逻辑指令分别用于AND、OR或XOR操作。A64指令集为每种操作提供了两种版本。移位寄存器版本允许在应用操作之前对源操作数之一进行移位。立即数版本仅允许某些特定位模式，稍后我会在描述指令后解释：'
- en: and**—AND shifted register**
  id: totrans-39
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: and**—AND移位寄存器**
- en: '`and w`d `, w`s1 `, w`s2 `{,` shft amnt `}` performs a bitwise AND between
    the values in `w`s1 and `w`s2 and stores the result in `w`d. The value from `w`s2
    can be shifted 0 to 31 bits before the AND operation using the shft amnt option.'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: '`and w`d `, w`s1 `, w`s2 `{,` shft amnt `}` 执行位与操作，将 `w`s1 和 `w`s2 中的值进行位与操作，并将结果存储在
    `w`d 中。使用 shft amnt 选项，可以在 AND 操作前将 `w`s2 中的值左移 0 到 31 位。'
- en: '`and x`d `, x`s1 `, x`s2 `{,` shft amnt `}` performs a bitwise AND between
    the values in `x`s1 and `x`s2 and stores the result in `x`d. The value from `x`s2
    can be shifted 0 to 63 bits before the AND operation using the shft amnt option.'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: '`and x`d `, x`s1 `, x`s2 `{,` shft amnt `}` 执行位与操作，将 `x`s1 和 `x`s2 中的值进行位与操作，并将结果存储在
    `x`d 中。使用 shft amnt 选项，可以在 AND 操作前将 `x`s2 中的值左移 0 到 63 位。'
- en: and**—AND immediate**
  id: totrans-42
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: and**—与立即数**
- en: '`and w`d `, w`s `,` imm performs a bitwise AND between the 32-bit pattern of
    imm and the value in `w`s and stores the result in `w`d.'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: '`and w`d `, w`s `,` imm 执行位与操作，将 imm 的 32 位模式和 `w`s 中的值进行位与操作，并将结果存储在 `w`d
    中。'
- en: '`and x`d `, x`s `,` imm performs a bitwise AND between the 64-bit pattern of
    imm and the value in `x`s and stores the result in `x`d.'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: '`and x`d `, x`s `,` imm 执行位与操作，将 imm 的 64 位模式和 `x`s 中的值进行位与操作，并将结果存储在 `x`d
    中。'
- en: orr**—Inclusive OR shifted register**
  id: totrans-45
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: orr**—包含或移位寄存器**
- en: '`orr w`d `, w`s1 `, w`s2 `{,` shft amnt `}` performs a bitwise OR between the
    values in `w`s1 and `w`s2 and stores the result in `w`d. The value from `w`s2
    can be shifted 0 to 31 bits before the OR operation using the shft amnt option.'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: '`orr w`d `, w`s1 `, w`s2 `{,` shft amnt `}` 执行位或操作，将 `w`s1 和 `w`s2 中的值进行位或操作，并将结果存储在
    `w`d 中。使用 shft amnt 选项，可以在 OR 操作前将 `w`s2 中的值左移 0 到 31 位。'
- en: '`orr x`d `, x`s1 `, x`s2 `{,` shft amnt `}` performs a bitwise OR between the
    values in `x`s1 and `x`s2 and stores the result in `x`d. The value from `x`s2
    can be shifted 0 to 63 bits before the OR operation using the shft amnt option.'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: '`orr x`d `, x`s1 `, x`s2 `{,` shft amnt `}` 执行位或操作，将 `x`s1 和 `x`s2 中的值进行位或操作，并将结果存储在
    `x`d 中。使用 shft amnt 选项，可以在 OR 操作前将 `x`s2 中的值左移 0 到 63 位。'
- en: orr**—Inclusive OR immediate**
  id: totrans-48
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: orr**—包含或立即数**
- en: '`orr w`d `, w`s `,` imm performs a bitwise OR between the 32-bit pattern of
    imm and the value in `w`s and stores the result in `w`d.'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: '`orr w`d `, w`s `,` imm 执行位或操作，将 imm 的 32 位模式和 `w`s 中的值进行位或操作，并将结果存储在 `w`d
    中。'
- en: '`orr x`d `, x`s `,` imm performs a bitwise OR between the 64-bit pattern of
    imm and the value in `x`s and stores the result in `x`d.'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: '`orr x`d `, x`s `,` imm 执行位或操作，将 imm 的 64 位模式和 `x`s 中的值进行位或操作，并将结果存储在 `x`d
    中。'
- en: eor**—Exclusive OR shifted register**
  id: totrans-51
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: eor**—排他或移位寄存器**
- en: '`eor w`d `, w`s1 `, w`s2 `{,` shft amnt `}` performs a bitwise XOR between
    the values in `w`s1 and `w`s2 and stores the result in `w`d. The value from `w`s2
    can be shifted 0 to 31 bits before the XOR operation using the shft amnt option.'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: '`eor w`d `, w`s1 `, w`s2 `{,` shft amnt `}` 执行位异或操作，将 `w`s1 和 `w`s2 中的值进行位异或操作，并将结果存储在
    `w`d 中。使用 shft amnt 选项，可以在 XOR 操作前将 `w`s2 中的值左移 0 到 31 位。'
- en: '`eor x`d `, x`s1 `, x`s2 `{,` shft amnt `}` performs a bitwise XOR between
    the values in `x`s1 and `x`s2 and stores the result in `x`d. The value from `x`s2
    can be shifted 0 to 63 bits before the XOR operation using the shft amnt option.'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: '`eor x`d `, x`s1 `, x`s2 `{,` shft amnt `}` 执行位异或操作，将 `x`s1 和 `x`s2 中的值进行位异或操作，并将结果存储在
    `x`d 中。使用 shft amnt 选项，可以在 XOR 操作前将 `x`s2 中的值左移 0 到 63 位。'
- en: eor**—Exclusive OR immediate**
  id: totrans-54
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: eor**—排他或立即数**
- en: '`eor w`d `, w`s `,` imm performs a bitwise XOR between the 32-bit pattern of
    imm and the value in `w`s and stores the result in `w`d.'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: '`eor w`d `, w`s `,` imm 执行位异或操作，将 imm 的 32 位模式和 `w`s 中的值进行位异或操作，并将结果存储在 `w`d
    中。'
- en: '`eor x`d `, x`s `,` imm performs a bitwise XOR between the 64-bit pattern of
    imm and the value in `x`s and stores the result in `x`d.'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: '`eor x`d `, x`s `,` imm 执行位异或操作，将 imm 的 64 位模式和 `x`s 中的值进行位异或操作，并将结果存储在 `x`d
    中。'
- en: '[Table 16-1](ch16.xhtml#ch16tab1) lists the allowable values for the shft option.'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: '[表 16-1](ch16.xhtml#ch16tab1) 列出了 shft 选项的允许值。'
- en: '**Table 16-1:** Allowable Values for shft in Shifted Register Logic Instructions'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: '**表 16-1：** 移位寄存器逻辑指令中允许的 shft 值'
- en: '| shft | **Effect** |'
  id: totrans-59
  prefs: []
  type: TYPE_TB
  zh: '| shft | **效果** |'
- en: '| --- | --- |'
  id: totrans-60
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `lsl` | Logical shift left |'
  id: totrans-61
  prefs: []
  type: TYPE_TB
  zh: '| `lsl` | 逻辑左移 |'
- en: '| `lsr` | Logical shift right |'
  id: totrans-62
  prefs: []
  type: TYPE_TB
  zh: '| `lsr` | 逻辑右移 |'
- en: '| `asr` | Arithmetic shift right |'
  id: totrans-63
  prefs: []
  type: TYPE_TB
  zh: '| `asr` | 算术右移 |'
- en: '| `ror` | Rotate right |'
  id: totrans-64
  prefs: []
  type: TYPE_TB
  zh: '| `ror` | 右旋转 |'
- en: A logical shift fills the vacated bits with `0`s. An arithmetic shift fills
    the vacated bits with copies of the high-order bit of the value being shifted.
    A right rotation shifts all the bits to the right, moving the low-order bits to
    the high-order positions. The 32-bit versions of these logic instructions do not
    change the 32 high-order bits in the destination register, so a shift or rotation
    of a `w`s register applies only to the low-order 32 bits of the corresponding
    `x`s register.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 逻辑移位将空出的位填充为 `0`。算术移位将空出的位填充为被移位值的高位副本。右旋转将所有位向右移，将低位移到高位位置。这些逻辑指令的 32 位版本不会改变目标寄存器中的
    32 位高位，因此对 `w` 寄存器的移位或旋转仅应用于相应 `x` 寄存器的低 32 位。
- en: You learned in [Chapter 12](ch12.xhtml) that the imm values in these logic instructions
    cannot be 32 or 64 bits. To see how these three instructions encode the imm value,
    let’s take a look at the machine code for the first `and` instruction in [Listing
    16-4](ch16.xhtml#ch16list4), shown in [Figure 16-1](ch16.xhtml#ch16fig1).
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 你在[第12章](ch12.xhtml)中学到，这些逻辑指令中的 imm 值不能是 32 位或 64 位。为了查看这三条指令如何编码 imm 值，让我们看看[第16-4节](ch16.xhtml#ch16list4)中第一个
    `and` 指令的机器代码，如[图16-1](ch16.xhtml#ch16fig1)所示。
- en: '![Image](../images/pg357_Image_283.jpg)'
  id: totrans-67
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/pg357_Image_283.jpg)'
- en: '*Figure 16-1: The machine code for the* and w0, w0, -33 *instruction in [Listing
    16-4](ch16.xhtml#ch16list4)*'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: '*图16-1：* 和 w0, w0, -33 *指令的机器代码，在[第16-4节](ch16.xhtml#ch16list4)中*'
- en: The `0` in the `N` field specifies a 32-bit operation. A `1` would specify a
    64-bit operation.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: '`N` 字段中的 `0` 表示32位操作。`1` 表示64位操作。'
- en: 'The `imms` field specifies two numbers: the number of bits in a repeating pattern
    and the number of consecutive `1`s in the pattern. I’ll use [Table 16-2](ch16.xhtml#ch16tab2)
    to explain how this works.'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: '`imms` 字段指定两个数字：重复模式中的位数和模式中连续 `1` 的数量。我将使用[表16-2](ch16.xhtml#ch16tab2)来解释这个过程。'
- en: '**Table 16-2:** Encoding `imms` Values in Immediate Logic Instructions'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: '**表16-2：** 立即数逻辑指令中 `imms` 值的编码'
- en: '| N | imms | **Pattern size (bits)** | **Number of 1s** |'
  id: totrans-72
  prefs: []
  type: TYPE_TB
  zh: '| N | imms | **模式大小（位）** | **1 的数量** |'
- en: '| --- | --- | --- | --- |'
  id: totrans-73
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- |'
- en: '| `0` | `11110x` | 2 | 1 |'
  id: totrans-74
  prefs: []
  type: TYPE_TB
  zh: '| `0` | `11110x` | 2 | 1 |'
- en: '| `0` | `1110xx` | 4 | 1–3 |'
  id: totrans-75
  prefs: []
  type: TYPE_TB
  zh: '| `0` | `1110xx` | 4 | 1–3 |'
- en: '| `0` | `110xxx` | 8 | 1–7 |'
  id: totrans-76
  prefs: []
  type: TYPE_TB
  zh: '| `0` | `110xxx` | 8 | 1–7 |'
- en: '| `0` | `10xxxx` | 16 | 1–15 |'
  id: totrans-77
  prefs: []
  type: TYPE_TB
  zh: '| `0` | `10xxxx` | 16 | 1–15 |'
- en: '| `0` | `0xxxxx` | 32 | 1–31 |'
  id: totrans-78
  prefs: []
  type: TYPE_TB
  zh: '| `0` | `0xxxxx` | 32 | 1–31 |'
- en: '| `1` | `xxxxxx` | 64 | 1–63 |'
  id: totrans-79
  prefs: []
  type: TYPE_TB
  zh: '| `1` | `xxxxxx` | 64 | 1–63 |'
- en: For the rows with `0` in the `N` column, the location of the first `0` in the
    `imms` column (reading from the left) specifies the number of bits in the pattern.
    The `1` in the `N` column specifies a 64-bit pattern.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 `N` 列中为 `0` 的行，`imms` 列中第一个 `0` 的位置（从左侧读取）指定模式中的位数。`N` 列中的 `1` 指定 64 位模式。
- en: In each row, the binary number in the `x` positions plus 1 specifies the number
    of consecutive `1`s in the pattern, starting from the right-hand side. For example,
    if `N` is `0` and `imms` is `110010`, this specifies an 8-bit pattern with three
    consecutive `1`s. This would result in the 32-bit mask `0x07070707`.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 每一行中，`x` 位置上的二进制数字加 1 指定从右侧开始的连续 `1` 的数量。例如，如果 `N` 是 `0` 且 `imms` 是 `110010`，则指定一个具有三个连续
    `1` 的 8 位模式。这将产生 32 位的掩码 `0x07070707`。
- en: The 6-bit number in the `immr` field of the `and` instruction that’s shown in
    [Figure 16-1](ch16.xhtml#ch16fig1) specifies the number of right rotations to
    be applied to the mask before the logical operation.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 在[图16-1](ch16.xhtml#ch16fig1)中显示的 `and` 指令的 `immr` 字段中的6位数字指定在逻辑操作之前要应用于掩码的右移位数。
- en: The mask specified in this instruction starts with a 32-bit pattern with 31
    consecutive `1`s, `0x7fffffff`, that occurs only once. This pattern then gets
    rotated 26 bits to the right to give `0xffffffdf` for the mask that is used in
    the AND operation.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 此指令中指定的掩码从一个包含 31 个连续 `1` 的 32 位模式 `0x7fffffff` 开始，该模式仅出现一次。然后，这个模式被右旋转 26 位，得到用于
    AND 操作的掩码 `0xffffffdf`。
- en: Next, I’ll show you a way to write this program directly in assembly language.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我将向你展示如何直接在汇编语言中编写这个程序。
- en: '***Bitmasking in Assembly Language***'
  id: totrans-85
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***汇编语言中的位掩码***'
- en: We’ll use the same masking algorithm in our assembly language version, but we’ll
    use identifiers that make it easier to see what’s going on. [Listing 16-5](ch16.xhtml#ch16list5)
    shows the `main` function written in assembly language.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在汇编语言版本中使用相同的掩码算法，但我们将使用更易于理解的标识符。汇编语言版本的 `main` 函数如[第16-5节](ch16.xhtml#ch16list5)所示。
- en: '*uppercase.s*'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: '*uppercase.s*'
- en: '[PRE4]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '*Listing 16-5: A program to make a text string uppercase*'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单16-5：将文本字符串转换为大写的程序*'
- en: We have allocated 50 bytes on the stack for our character array. Adding 16 bytes
    to save `sp` and `fp` takes us to a frame size of at least 66 bytes. To keep the
    stack pointer properly aligned on a 16-byte boundary, we allocate 80 bytes for
    the stack frame ❶.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在堆栈上为字符数组分配了50字节。再加上16字节用于保存`sp`和`fp`，这使得帧的大小至少为66字节。为了保持堆栈指针在16字节边界上正确对齐，我们为堆栈帧分配了80字节❶。
- en: We pass the address of our `char` array to the `to_upper` function as both the
    source and the destination, so it will replace the original values in the array
    with the new ones ❷.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将`char`数组的地址传递给`to_upper`函数，作为源和目标，这样它就会用新的值替换数组中的原始值❷。
- en: I’ll use the same masking algorithm as the compiler to write `to_upper` in assembly
    language, but I’ll structure the function differently. [Listing 16-6](ch16.xhtml#ch16list6)
    shows the code.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 我将使用与编译器相同的掩码算法来编写`to_upper`的汇编代码，但我将以不同的方式构建该函数。[清单16-6](ch16.xhtml#ch16list6)展示了代码。
- en: '*to_upper.s*'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: '*to_upper.s*'
- en: '[PRE5]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '*Listing 16-6: A program to convert text to uppercase*'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单16-6：将文本转换为大写的程序*'
- en: We’re using registers `w2`, `w3`, and `w4` for our local variables instead of
    placing them in our stack frame. The standard says we don’t need to save the contents
    of these registers for the calling function.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用寄存器`w2`、`w3`和`w4`来存储局部变量，而不是将它们放在堆栈帧中。标准规定我们不需要为调用函数保存这些寄存器的内容。
- en: 'The `ldrb` instruction loads a character into a `w` register ❷. We need to
    use a 32-bit mask to match the width of the register. The correct mask for this
    algorithm is `0x000000df` ❶. The compiler uses two masks to achieve the correct
    result:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: '`ldrb`指令将字符加载到`w`寄存器中❷。我们需要使用32位的掩码，以匹配寄存器的宽度。该算法的正确掩码是`0x000000df`❶。编译器使用两个掩码来实现正确的结果：'
- en: '[PRE6]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The `ldrb` instruction zeros the 24 high-order bits in the register, so we could
    use only the first instruction. But this might confuse a person maintaining this
    code, since the algorithm works with bit patterns, not integers, and writing the
    instruction as
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: '`ldrb`指令将寄存器中的24个高位清零，因此我们只需使用第一条指令。但这可能会让维护此代码的人感到困惑，因为该算法处理的是位模式，而不是整数。将指令写成这样'
- en: '[PRE7]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: could be even more confusing.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 可能会更加混淆。
- en: Our use of the `movz` instruction to load the correct mask into a register clearly
    shows our intent ❸. Then, we use the register form of the `and` instruction to
    mask out the lowercase bit in the character. In the next section, I’ll show you
    ways to shift bits to multiply or divide a value by powers of two.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用`movz`指令将正确的掩码加载到寄存器中，这清晰地表明了我们的意图❸。然后，我们使用`and`指令的寄存器形式来掩码出字符中的小写位。在下一节中，我将向你展示如何通过移位操作将值乘以或除以二的幂。
- en: '**YOUR TURN**'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: '**你的回合**'
- en: 16.1     Write a program in assembly language that converts all alphabetic characters
    to lowercase.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 16.1     编写一个汇编语言程序，将所有字母字符转换为小写。
- en: 16.2     Write a program in assembly language that changes the case of all alphabetic
    characters to the opposite case.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 16.2     编写一个汇编语言程序，将所有字母字符的大小写转换为相反的大小写。
- en: 16.3     Write a program in assembly language that converts all alphabetic characters
    to uppercase and to lowercase. Your program should also show the user’s original
    input string after displaying both the upper-case and lowercase conversions.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 16.3     编写一个汇编语言程序，将所有字母字符转换为大写和小写。你的程序还应该在显示了大写和小写转换后，展示用户的原始输入字符串。
- en: '**Shifting Bits**'
  id: totrans-107
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**移位操作**'
- en: It’s sometimes useful to be able to shift all the bits in a variable to the
    left or to the right. If the variable is an integer, shifting all the bits one
    position to the left effectively multiplies the integer by two, and shifting them
    one position to the right effectively divides it by two. Using left/right shifts
    to do multiplication/division by powers of two is very efficient.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 有时候，能够将变量中的所有位向左或向右移位是很有用的。如果变量是整数，将所有位左移一个位置实际上是将整数乘以二，而将它们右移一个位置则实际上是将其除以二。通过使用左右移位来进行乘法/除法运算，是非常高效的，尤其是对二的幂的乘除运算。
- en: '***In C***'
  id: totrans-109
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***在C语言中***'
- en: 'I’ll cover shifts by showing you a program that reads an integer entered in
    hexadecimal from the keyboard and stores it as a `long int`. The program reads
    up to eight hexadecimal characters, `0`, `1`, . . . , `f`, each in 8-bit ASCII
    code and representing a 4-bit integer: 0, 1, . . . , 15.'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 我将通过展示一个程序来讲解移位操作，该程序从键盘读取以十六进制输入的整数并将其存储为`long int`。该程序最多读取八个十六进制字符，`0`、`1`、...、`f`，每个字符为8位ASCII码，表示一个4位整数：0、1、...、15。
- en: '[Listing 16-7](ch16.xhtml#ch16list7) shows the `main` function for this program.'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: '[清单 16-7](ch16.xhtml#ch16list7)显示了该程序的`main`函数。'
- en: '*convert_hex.c*'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: '*convert_hex.c*'
- en: '[PRE8]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '*Listing 16-7: A program to convert hexadecimal input to an* int'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 16-7：一个将十六进制输入转换为* int *的程序*'
- en: In “Your Turn” [exercise 14.4](ch14.xhtml#ch14exe4) on [page 293](ch14.xhtml#ch14you1),
    you designed the `read_str` function to limit the number of characters it will
    store in the `char` array passed to it. If the user enters more than eight characters,
    `read_str` will terminate the string with a `NUL` character and discard the excess
    characters.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 在“轮到你了”[练习 14.4](ch14.xhtml#ch14exe4)中，你设计了`read_str`函数来限制它在传递给它的`char`数组中存储的字符数。如果用户输入超过八个字符，`read_str`将用`NUL`字符终止字符串，并丢弃多余的字符。
- en: '[Listing 16-8](ch16.xhtml#ch16list8) shows the header file for the `hex_to_int`
    function.'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: '[清单 16-8](ch16.xhtml#ch16list8)显示了`hex_to_int`函数的头文件。'
- en: '*hex_to_int.h*'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: '*hex_to_int.h*'
- en: '[PRE9]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '*Listing 16-8: The header file for the* hex_to_int *function*'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 16-8：* hex_to_int *函数的头文件*'
- en: The header file declares the `hex_to_int` function, which takes two pointers.
    The `char` pointer is the input, and the `long int` pointer is the location for
    the primary output. The `hex_to_int` function also returns an `int` that gives
    the number of characters it converted.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 头文件声明了`hex_to_int`函数，该函数接受两个指针。`char`指针作为输入，`long int`指针作为主输出的位置。`hex_to_int`函数还返回一个`int`值，表示它转换的字符数量。
- en: '[Listing 16-9](ch16.xhtml#ch16list9) shows the definition of the `hex_to_int`
    function.'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: '[清单 16-9](ch16.xhtml#ch16list9)显示了`hex_to_int`函数的定义。'
- en: '*hex_to_int.c*'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: '*hex_to_int.c*'
- en: '[PRE10]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '*Listing 16-9: The* hex_to_int *function in C*'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 16-9：C语言中的* hex_to_int *函数*'
- en: Our program first sets the 32-bit output to `0` ❶. Then, starting with the most
    significant hexadecimal character (the first one entered by the user), the program
    converts each 8-bit ASCII code to its corresponding 4-bit integer.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的程序首先将32位输出设置为`0`❶。然后，从最重要的十六进制字符（用户输入的第一个字符）开始，程序将每个8位的ASCII码转换为对应的4位整数。
- en: Looking at [Tables 2-4](ch02.xhtml#ch2tab4) and [2-5](ch02.xhtml#ch2tab5) in
    [Chapter 2](ch02.xhtml), we see that the ASCII codes for the numeric characters
    range from `0x30` to `0x39`, and for the lowercase alphabetic characters, they
    range from `0x61` to `0x66`. Subtracting this `0x27` gap from the alphabetic characters
    gives us the bit patterns `0x30`, `0x31`, . . . , `0x39`, `0x3a`, . . . , `0x3f`
    for the characters entered ❷. Of course, the user may enter uppercase alphabetic
    characters, which range from `0x41` to `0x46`. Subtracting `0x27` then gives us
    `0x30`, `0x31`, . . . , `0x39`, `0x1a`, . . . , `0x1f`. Each hexadecimal character
    represents 4 bits, and if we look at the low-order 4 bits after subtracting `0x27`,
    they are the same whether the user enters lowercase or uppercase alphabetic characters.
    We can convert the character code to a 4-bit integer by masking off the upper
    4 bits with the bit pattern `0x0f` using `&`, the C bitwise AND operator ❸.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 查看[表格 2-4](ch02.xhtml#ch2tab4)和[2-5](ch02.xhtml#ch2tab5)以及[第2章](ch02.xhtml)，我们可以看到数字字符的ASCII码范围是`0x30`到`0x39`，小写字母字符的范围是`0x61`到`0x66`。从字母字符中减去`0x27`的差值，得到的位模式是`0x30`、`0x31`、...、`0x39`、`0x3a`、...、`0x3f`，这些是输入字符的位模式❷。当然，用户也可以输入大写字母字符，其范围是`0x41`到`0x46`。减去`0x27`后，得到的位模式是`0x30`、`0x31`、...、`0x39`、`0x1a`、...、`0x1f`。每个十六进制字符代表4位，如果我们观察减去`0x27`后低4位的值，无论用户输入小写字母还是大写字母，其值是相同的。我们可以通过使用`&`（C语言中的按位与运算符）和`0x0f`掩码将字符码转换为4位整数❸。
- en: Next, we shift all the bits in the accumulated value 4 bits to the left to make
    room for the next 4 bits represented by the hexadecimal character ❹. The left
    shift leaves `0`s in the four least significant bit positions, so we can copy
    the 4 bits in `current` into these positions using `|`, the bitwise OR operator
    ❺.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将累积值中的所有位左移4位，为下一个由十六进制字符表示的4个位腾出空间❹。左移操作会在四个最低有效位位置留下`0`，因此我们可以使用`|`（按位或运算符）将`current`中的4个位复制到这些位置❺。
- en: The type of the `current` variable is `char`, and the type of `result` is `int`.
    In C, the width of a narrower value will automatically be extended to match the
    width of a wider value for arithmetic and logic operations ❺.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: '`current`变量的类型是`char`，`result`的类型是`int`。在C语言中，对于算术和逻辑运算，较窄值的宽度会自动扩展，以匹配较宽值的宽度❺。'
- en: Let’s look at the assembly language the compiler generates for the `hex_to_int`
    function, shown in [Listing 16-10](ch16.xhtml#ch16list10).
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看编译器为`hex_to_int`函数生成的汇编语言，见[清单 16-10](ch16.xhtml#ch16list10)。
- en: '*hex_to_int.s*'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: '*hex_to_int.s*'
- en: '[PRE11]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '*Listing 16-10: The compiler-generated assembly language for the C function
    in [Listing 16-9](ch16.xhtml#ch16list9)*'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 16-10：编译器生成的汇编语言，用于 [列表 16-9](ch16.xhtml#ch16list9) 中的 C 函数*'
- en: The compiler uses the `ldrb` instruction to load characters into a `w` register
    ❶. This sets bits 8 through 31 to `0`, effectively typecasting the 8-bit `char`
    to a 32-bit `int`. This would have occurred even without our explicit type-casting
    in the C code in [Listing 16-9](ch16.xhtml#ch16list9), but the explicit typecasting
    more clearly shows our intent and doesn’t affect the efficiency of our code.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 编译器使用 `ldrb` 指令将字符加载到 `w` 寄存器中 ❶。这会将第 8 位到第 31 位设置为 `0`，有效地将 8 位的 `char` 类型转换为
    32 位的 `int` 类型。即使在 [列表 16-9](ch16.xhtml#ch16list9) 中没有显式的类型转换，编译器也会执行这样的转换，但显式的类型转换更清晰地表达了我们的意图，而且不会影响代码的效率。
- en: The mask in this algorithm is four sequential `1`s, so the immediate data form
    of the `and` instruction can be used ❷.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 该算法中的掩码是四个连续的 `1`，因此可以使用 `and` 指令的立即数形式 ❷。
- en: 'We see a new instruction here, `lsl` ❸. As you can probably guess, this instruction
    shifts the value in `x0` 4 bits to the left and loads the result into `x1`. Let’s
    look at some common shift instructions:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里看到了一条新指令，`lsl` ❸。正如你可能猜到的，这条指令将 `x0` 中的值左移 4 位，并将结果加载到 `x1` 中。让我们来看一些常见的移位指令：
- en: lsl**—Logically shift left immediate**
  id: totrans-136
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: lsl**—逻辑左移立即数**
- en: '`lsl w`d `, w`s `,` amnt shifts the value in `w`s by amnt bits to the left,
    with `0`s in the vacated bits, and loads the result into `w`d.'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: '`lsl w`d `, w`s `,` amnt 将 `w`s 中的值按 amnt 位左移，腾出的位用 `0` 填充，并将结果加载到 `w`d 中。'
- en: '`lsl x`d `, x`s `,` amnt shifts the value in `x`s by amnt bits to the left,
    with `0`s in the vacated bits, and loads the result into `x`d.'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: '`lsl x`d `, x`s `,` amnt 将 `x`s 中的值按 amnt 位左移，腾出的位用 `0` 填充，并将结果加载到 `x`d 中。'
- en: lsr**—Logically shift right immediate**
  id: totrans-139
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: lsr**—逻辑右移立即数**
- en: '`lsr w`d `, w`s `,` amnt shifts the value in `w`s by amnt bits to the right,
    with `0`s in the vacated bits, and loads the result into `w`d.'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: '`lsr w`d `, w`s `,` amnt 将 `w`s 中的值按 amnt 位右移，腾出的位用 `0` 填充，并将结果加载到 `w`d 中。'
- en: '`lsr x`d `, x`s `,` amnt shifts the value in `x`s by amnt bits to the right,
    with `0`s in the vacated bits, and loads the result into `x`d.'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: '`lsr x`d `, x`s `,` amnt 将 `x`s 中的值按 amnt 位右移，腾出的位用 `0` 填充，并将结果加载到 `x`d 中。'
- en: asr**—Arithmetic shift right immediate**
  id: totrans-142
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: asr**—算术右移立即数**
- en: '`asr w`d `, w`s `,` amnt shifts the value in `w`s by amnt bits to the right,
    copying the highest-order bit into the vacated bits, and loads the result into
    `w`d.'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: '`asr w`d `, w`s `,` amnt 将 `w`s 中的值按 amnt 位右移，将最高位复制到腾出的位，并将结果加载到 `w`d 中。'
- en: '`asr x`d `, x`s `,` amnt shifts the value in `x`s by amnt bits to the right,
    copying the highest-order bit into the vacated bits, and loads the result into
    `x`d.'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: '`asr x`d `, x`s `,` amnt 将 `x`s 中的值按 amnt 位右移，将最高位复制到腾出的位，并将结果加载到 `x`d 中。'
- en: ror**—Rotate right immediate**
  id: totrans-145
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: ror**—立即数右旋**
- en: '`ror w`d `, w`s `,` amnt shifts the value in `w`s by amnt bits to the right,
    copying the low-order bits into the vacated high-order bits, and loads the result
    into `w`d.'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: '`ror w`d `, w`s `,` amnt 将 `w`s 中的值按 amnt 位右移，将低位的值复制到腾出的高位，并将结果加载到 `w`d 中。'
- en: '`ror x`d `, x`s `,` amnt shifts the value in `x`s by amnt bits to the right,
    copying the low-order bits into the vacated high-order bits, and loads the result
    into `x`d.'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: '`ror x`d `, x`s `,` amnt 将 `x`s 中的值按 amnt 位右移，将低位的值复制到腾出的高位，并将结果加载到 `x`d 中。'
- en: Next, I’ll take a similar approach to writing the hexadecimal-to-integer conversion
    program in assembly language as I did for the earlier case conversion C program.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我将采用与之前的大小写转换 C 程序相似的方法编写十六进制到整数的汇编语言转换程序。
- en: '***In Assembly Language***'
  id: totrans-149
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***在汇编语言中***'
- en: I’ll start the design for our `convert_hex` program with a diagram of the stack
    frame for the `main` function, shown in [Figure 16-2](ch16.xhtml#ch16fig2).
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 我将从 `main` 函数的堆栈框架图开始设计我们的 `convert_hex` 程序，如 [图 16-2](ch16.xhtml#ch16fig2)
    所示。
- en: '![Image](../images/pg366_Image_284.jpg)'
  id: totrans-151
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/pg366_Image_284.jpg)'
- en: '*Figure 16-2: The stack frame for the* convert_hex *program*'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 16-2：* convert_hex *程序的堆栈框架*'
- en: With this diagram, the assembly language design of the `main` function is straightforward,
    as shown in [Listing 16-11](ch16.xhtml#ch16list11).
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这个图示，`main` 函数的汇编语言设计变得非常直观，如 [列表 16-11](ch16.xhtml#ch16list11) 所示。
- en: '*convert_hex.s*'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: '*convert_hex.s*'
- en: '[PRE12]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '*Listing 16-11: The assembly language* main *function for converting a hex
    value to an* int'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 16-11：用于将十六进制值转换为* int *的* main *函数汇编语言*'
- en: There is nothing new in this `main` function. In addition to the 16 bytes for
    saving the `fp` and `lr` registers and 4 bytes for the `int`, we need to allocate
    9 bytes in our stack frame for the hexadecimal text string, giving a frame size
    of at least 29 bytes. The frame size must be a multiple of 16 to keep the stack
    pointer properly aligned, so we use 32 ❶.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: '`main` 函数中没有什么新内容。除了保存 `fp` 和 `lr` 寄存器的16字节，以及用于 `int` 的4字节外，我们还需要在堆栈帧中为十六进制文本字符串分配9字节，堆栈帧的大小至少为29字节。由于帧大小必须是16的倍数以保持栈指针正确对齐，因此我们使用32字节
    ❶。'
- en: We’ll use registers for the variables in our assembly language version of `hex_to_int`.
    Our stack frame will be simple, so we won’t need a diagram to design it. Figure
    16-12 shows our function.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将为汇编语言版本的 `hex_to_int` 使用寄存器来存储变量。我们的堆栈帧将非常简单，因此我们不需要图表来设计它。图16-12显示了我们的函数。
- en: '*hex_to_int.s*'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: '*hex_to_int.s*'
- en: '[PRE13]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '*Listing 16-12: The assembly language version of the* hex_to_int *function*'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单16-12：* hex_to_int *函数的汇编语言版本*'
- en: Shifts are good for multiplying and dividing by powers of two, but we also need
    to be able to multiply and divide by other numbers. We’ll look at multiplying
    and dividing by arbitrary integers in the next two sections, deferring consideration
    of fractional and floating-point values until [Chapter 19](ch19.xhtml).
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 移位操作适用于乘以和除以 2 的幂，但我们也需要能够乘以和除以其他数字。在接下来的两节中，我们将讨论乘以和除以任意整数，并将浮动和小数值的考虑推迟到[第19章](ch19.xhtml)。
- en: '**YOUR TURN**'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: '**你的回合**'
- en: 16.4     Modify the C `main` function in [Listing 16-7](ch16.xhtml#ch16list7)
    so it displays the number of hexadecimal characters converted. Use the assembly
    language `hex_to_int` function in [Listing 16-12](ch16.xhtml#ch16list12) for the
    conversion.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 16.4     修改[清单16-7](ch16.xhtml#ch16list7)中的 C `main` 函数，使其显示转换的十六进制字符的数量。使用[清单16-12](ch16.xhtml#ch16list12)中的汇编语言
    `hex_to_int` 函数进行转换。
- en: 16.5     Write a program in assembly language that converts octal input to a
    `long int`.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 16.5     编写一个汇编语言程序，将八进制输入转换为 `long int`。
- en: '**Multiplication**'
  id: totrans-166
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**乘法**'
- en: In this section, I’ll cover multiplication by integers that are not powers of
    two. It can be done using loops, but most general-purpose CPUs include multiply
    instructions.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我将讨论乘以不是2的幂的整数。这可以通过循环实现，但大多数通用CPU都包含乘法指令。
- en: '***In C***'
  id: totrans-168
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***在C语言中***'
- en: Let’s modify the C program in [Listings 16-7](ch16.xhtml#ch16list7) to [16-9](ch16.xhtml#ch16list9)
    to convert decimal number text strings into unsigned integers. When converting
    from hexadecimal text strings, we shifted the accumulated value 4 bits to the
    left, thus multiplying it by 16\. We’ll use the same algorithm for converting
    decimal text strings, but this time we’ll multiply by 10 instead of 16.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们修改[清单16-7](ch16.xhtml#ch16list7)至[16-9](ch16.xhtml#ch16list9)中的 C 程序，将十进制数字文本字符串转换为无符号整数。当从十六进制文本字符串转换时，我们将累积值左移了4位，从而将其乘以16。我们将使用相同的算法来转换十进制文本字符串，但这次我们将乘以10而不是16。
- en: '[Listings 16-13](ch16.xhtml#ch16list13) to [16-15](ch16.xhtml#ch16list15) show
    the C program.'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: '[清单16-13](ch16.xhtml#ch16list13) 至 [16-15](ch16.xhtml#ch16list15) 显示了 C 程序。'
- en: '*convert_dec.c*'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: '*convert_dec.c*'
- en: '[PRE14]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '*Listing 16-13: A program to convert decimal input to an* int'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单16-13：将十进制输入转换为* int *的程序*'
- en: This `main` function is very similar to the one for converting hexadecimal input
    to an `int`, but the maximum number of characters in an `int` is 10\. We need
    to set `MAX` to 11 characters to allow for the possible + or – sign preceding
    the integer ❶.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 这个 `main` 函数与将十六进制输入转换为 `int` 的函数非常相似，但 `int` 中的最大字符数为10。我们需要将 `MAX` 设置为11个字符，以便允许整数前面有可能的正负号
    ❶。
- en: '[Listing 16-14](ch16.xhtml#ch16list14) shows the header file for the `dec_to_int`
    function.'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: '[清单16-14](ch16.xhtml#ch16list14) 显示了 `dec_to_int` 函数的头文件。'
- en: '*hex_to_int.h*'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: '*hex_to_int.h*'
- en: '[PRE15]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '*Listing 16-14: The header file for the* dec_to_int *function*'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单16-14：* dec_to_int *函数的头文件*'
- en: 'The header file declares the `dec_to_int` function, which takes two pointers:
    the `char` pointer is the input, and the `int` pointer is the location for the
    primary output. The `dec_to_int` function also returns an `int` that gives the
    number of characters it converted.'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 头文件声明了 `dec_to_int` 函数，该函数接受两个指针：`char` 指针作为输入，`int` 指针作为主要输出的位置。`dec_to_int`
    函数还返回一个 `int`，表示它转换的字符数。
- en: '[Listing 16-15](ch16.xhtml#ch16list15) shows the definition of the `dec_to_int`
    function.'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: '[清单16-15](ch16.xhtml#ch16list15) 显示了 `dec_to_int` 函数的定义。'
- en: '*dec_to_int.c*'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: '*dec_to_int.c*'
- en: '[PRE16]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: '*Listing 16-15: The* dec_to_int *function in C*'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单16-15：C语言中的* dec_to_int *函数*'
- en: The first thing we need to do is check for a possible + or – sign preceding
    the number. If there’s a – sign, we set the `negative` flag to `true` ❷. It’s
    typical for users to enter positive numbers without a + sign, but we still need
    to increment the pointer to the first numerical character in the string if there
    is one ❸.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要做的第一件事是检查数字前面是否有+号或–号。如果是–号，我们将`negative`标志设置为`true`❷。用户输入正数时通常不会加+号，但如果有+号，我们仍然需要将指针递增到字符串中的第一个数字字符❸。
- en: The `RADIX` constant is not a power of two, so we can’t do multiplication with
    a simple left shift ❹.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: '`RADIX`常量不是2的幂，因此我们不能通过简单的左移来进行乘法运算❹。'
- en: The `string_ptr` variable points to a `char` ❶. The `char` is being masked and
    added to `result`, which is an `int`. Most compilers will promote a `char` value
    when it’s assigned to an `int` variable, but I prefer to explicitly typecast the
    value ❺.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: '`string_ptr`变量指向一个`char`❶。这个`char`被掩码并加到`result`中，`result`是一个`int`。大多数编译器会在将`char`值赋给`int`变量时提升其类型，但我更倾向于显式地将其强制转换为所需类型❺。'
- en: Let’s look at how the compiler does the multiplication by 10\. This is shown
    in [Listing 16-16](ch16.xhtml#ch16list16).
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看编译器如何执行乘以10的操作。它在[清单16-16](ch16.xhtml#ch16list16)中展示。
- en: '*dec_to_int.s*'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: '*dec_to_int.s*'
- en: '[PRE17]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: '*Listing 16-16: The compiler-generated assembly language for the* dec_to_int
    *function in [Listing 16-15](ch16.xhtml#ch16list15)*'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单16-16：由编译器生成的* dec_to_int *函数的汇编语言，在[清单16-15](ch16.xhtml#ch16list15)中展示*'
- en: 'The multiplication instruction usually takes longer for the CPU to execute,
    so the compiler used a combination of shifting and adding to multiply `result`
    by 10 ❶. This four-instruction sequence is equivalent to the following C statement:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 乘法指令通常需要更长时间来执行，因此编译器使用了移位和加法的组合来将`result`乘以10❶。这一四条指令序列等同于以下的C语句：
- en: '[PRE18]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: The two multiplications in this statement are by powers of two, so they are
    done by simple left shifts.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 这条语句中的两次乘法是按2的幂进行的，因此它们通过简单的左移来完成。
- en: Notice that the arithmetic in this conversion algorithm is unsigned. We checked
    for a – sign at the beginning of the number string, and we negate the converted
    result at the end if there was a – sign ❷.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，这个转换算法中的算术运算是无符号的。我们在数字字符串的开头检查了–号，如果有–号，在转换结果的末尾我们会对结果取反❷。
- en: Using shifts and adds to multiply is limited. To see how the multiplication
    instructions work, we’ll use one to rewrite our decimal conversion program in
    assembly language.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 使用移位和加法进行乘法运算是有限制的。为了了解乘法指令的工作方式，我们将使用其中一种来改写我们的十进制转换程序的汇编语言版本。
- en: '***In Assembly Language***'
  id: totrans-196
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***在汇编语言中***'
- en: The A64 architecture has over a dozen variations of multiply instructions. I’ll
    show you only a few of them in this book; you can read about the others in the
    manual.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: A64架构有十多种不同的乘法指令。在本书中，我只会展示其中的一些；你可以在手册中阅读更多的指令。
- en: '[Figure 16-3](ch16.xhtml#ch16fig3) shows the stack frame design for our assembly
    language version of the `main` function of the program to convert a decimal text
    string to an `int`.'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: '[图16-3](ch16.xhtml#ch16fig3)显示了我们程序中将十进制文本字符串转换为`int`类型的`main`函数的汇编语言版本的堆栈帧设计。'
- en: '![Image](../images/pg373_Image_285.jpg)'
  id: totrans-199
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/pg373_Image_285.jpg)'
- en: '*Figure 16-3: The stack frame for the* convert_dec *program*'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: '*图16-3：* convert_dec *程序的堆栈帧*'
- en: Our assembly language version of the `main` function is similar to the C version;
    it’s shown in [Listing 16-17](ch16.xhtml#ch16list17).
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的`main`函数的汇编语言版本与C版本类似，展示在[清单16-17](ch16.xhtml#ch16list17)中。
- en: '*convert_dec.s*'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: '*convert_dec.s*'
- en: '[PRE19]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: '*Listing 16-17: A program to convert decimal values to* int *s in assembly
    language*'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单16-17：一个将十进制值转换为* int *类型的汇编语言程序*'
- en: '[Listing 16-18](ch16.xhtml#ch16list18) shows our assembly language version
    of `dec_to_int`.'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: '[清单16-18](ch16.xhtml#ch16list18)显示了我们`dec_to_int`的汇编语言版本。'
- en: '*dec_to_int.s*'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: '*dec_to_int.s*'
- en: '[PRE20]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: '*Listing 16-18: The* dec_to_int *function in assembly language*'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单16-18：汇编语言中的* dec_to_int *函数*'
- en: 'Instead of using a shift-and-add algorithm to multiply by 10, we’re using the
    `mul` instruction ❶. Let’s look at some variations of this instruction:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不再使用移位加法算法来乘以10，而是使用`mul`指令❶。我们来看看这种指令的几种变体：
- en: mul**—Multiply register**
  id: totrans-210
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: mul**—乘法寄存器**
- en: '`mul w`d `, w`s1 `, w`s2 multiplies the values in `w`s1 and `w`s2 and stores
    the result in `w`d.'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: '`mul w`d `, w`s1 `, w`s2`将`w`s1和`w`s2中的值相乘，并将结果存储在`w`d中。'
- en: '`mul x`d `, x`s1 `, x`s2 multiplies the values in `x`s1 and `x`s2 and stores
    the result in `x`d.'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: '`mul x`d `, x`s1 `, x`s2`将`x`s1和`x`s2中的值相乘，并将结果存储在`x`d中。'
- en: When multiplying two *n*-bit integers, the product can be up to 2*n* bits wide.
    Without offering a formal proof here, you can probably be convinced by considering
    the largest 3-bit number, `111`. Add `1` to get `1000`. From `1000 * 1000 = 1000000`,
    we can conclude that `111 * 111 <= 111111`. More precisely, `111 * 111 = 110001`.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 当乘以两个*n*位整数时，结果的宽度可以达到2*n*位。这里不提供正式证明，但你可能会被这样一个例子说服：考虑最大的3位数`111`，加上`1`得到`1000`。从`1000
    * 1000 = 1000000`，我们可以得出结论`111 * 111 <= 111111`。更准确地，`111 * 111 = 110001`。
- en: If the result of the `mul` instruction exceeds the width of the destination
    register, the high-order bits are lost. For example, if `w2` contains `0xcccccccc`
    and `w1` contains `0x00000002`, then `mul w0, w1, w2` will give `0x0000000099999998`
    in the `x0` register. The correct result is `0x0000000199999998` if we’re treating
    these values as unsigned integers and `0xffffffff99999998` if we’re treating these
    values as signed. But when an instruction writes to the `w` portion of a register,
    the high-order 32 bits of that register are set to `0`. Thus, the `mul` instruction
    yields an incorrect result if the product of two 32-bit integers is not within
    the range 0*≤ product≤* 4,294,967,295 if we’re using unsigned integers and –2,147,483,648*≤
    product≤* +2,147,483,647 if we’re using signed integers.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`mul`指令的结果超出了目标寄存器的位宽，那么高位会丢失。例如，如果`w2`包含`0xcccccccc`，而`w1`包含`0x00000002`，那么`mul
    w0, w1, w2`将在`x0`寄存器中得到`0x0000000099999998`。如果我们将这些值视为无符号整数，正确的结果应该是`0x0000000199999998`，如果将其视为有符号整数，则结果应该是`0xffffffff99999998`。但是当指令写入寄存器的`w`部分时，该寄存器的高32位会被设置为`0`。因此，当两个32位整数的乘积不在0*≤乘积≤*
    4,294,967,295（无符号整数）或–2,147,483,648*≤乘积≤* +2,147,483,647（有符号整数）范围内时，`mul`指令将产生错误结果。
- en: 'To deal with this size problem, the A64 architecture includes two multiplication
    instructions that use a 64-bit destination register for the case when the result
    of multiplying two 32-bit numbers exceeds the range of 32 bits:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 为了处理这个尺寸问题，A64架构包括了两条乘法指令，它们使用64位的目标寄存器来处理两个32位数相乘超过32位范围的情况：
- en: umull**—Unsigned multiply long**
  id: totrans-216
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: umull**—无符号长整型乘法**
- en: '`umull x`d `, w`s1 `, w`s2 multiplies the values in `w`s1 and `w`s2 and loads
    the result in `x`d. If the magnitude of the result doesn’t take up the full 64
    bits of `x`d, the unoccupied high-order bits are filled with `0`s.'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: '`umull x`d `, w`s1 `, w`s2`将`w`s1和`w`s2`中的值相乘，并将结果加载到`x`d中。如果结果的大小没有占满`x`d的全部64位，那么未占满的高位将填充为`0`。'
- en: smull**—Signed multiply long**
  id: totrans-218
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: smull**—带符号长整型乘法**
- en: '`smull x`d `, w`s1 `, w`s2 multiplies the values in `w`s1 and `w`s2 and loads
    the result in `x`d. If the magnitude of the result doesn’t take up the full 64
    bits of `x`d, the unoccupied high-order bits are each filled with a copy of the
    highest-order bit of the result, thus providing sign extension.'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: '`smull x`d `, w`s1 `, w`s2`将`w`s1和`w`s2`中的值相乘，并将结果加载到`x`d中。如果结果的大小没有占满`x`d的全部64位，那么未占满的高位将用结果的最高位进行填充，从而实现符号扩展。'
- en: Continuing with our example, if `w2` contains `0xcccccccc` and `w1` contains
    `0x00000002`, then `umull x0, w1, w2` will give `0x0000000199999998` in `x0` and
    `smull x0, w1, w2` will give `0xffffffff99999998`.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 继续我们之前的例子，如果`w2`包含`0xcccccccc`，而`w1`包含`0x00000002`，那么`umull x0, w1, w2`将在`x0`中得到`0x0000000199999998`，而`smull
    x0, w1, w2`将在`x0`中得到`0xffffffff99999998`。
- en: 'If we’re using 64-bit `long int`s and cannot prove that the result of the multiplication
    can never exceed 64 bits, the A64 architecture includes two multiplication instructions
    that will give the high-order 64 bits when multiplying two 64-bit numbers:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们使用64位的`long int`类型，且无法证明乘法结果永远不会超过64位，那么A64架构包含了两条乘法指令，在乘两个64位数时，能够提供高64位的结果：
- en: umulh**—Unsigned multiply high**
  id: totrans-222
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: umulh**—无符号高位乘法**
- en: '`umulh x`d `, x`s1 `, x`s2 multiplies the values in `x`s1 and `x`s2 and loads
    the high-order 64 bits of the result into `x`d with zero extension.'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: '`umulh x`d `, x`s1 `, x`s2`将`x`s1和`x`s2`中的值相乘，并将结果的高64位加载到`x`d中，且高位扩展为零。'
- en: smulh**—Signed multiply high**
  id: totrans-224
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: smulh**—带符号高位乘法**
- en: '`smulh x`d `, x`s1 `, x`s2 multiplies the values in `x`s1 and `x`s2 and loads
    the high-order 64 bits of the result into `x`d with sign extension.'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: '`smulh x`d `, x`s1 `, x`s2`将`x`s1和`x`s2`中的值相乘，并将结果的高64位加载到`x`d中，且高位扩展为符号位。'
- en: 'Thus, the multiplication of two 64-bit integers requires two instructions.
    We would use the following two instructions if we were treating two integers in
    `x0` and `x1` as unsigned:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，乘两个64位整数需要两条指令。如果我们将`x0`和`x1`中的两个整数视为无符号整数，我们将使用以下两条指令：
- en: '[PRE21]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'And we would use the following two instructions if we were treating two integers
    in `x0` and `x1` as signed:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们将`x0`和`x1`中的两个整数视为有符号数，我们将使用以下两条指令：
- en: '[PRE22]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: In both cases, the result is a 128-bit integer with the high-order 64 bits in
    register `x2` and the low-order 64 bits in `x3`.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 在这两种情况下，结果是一个128位的整数，高位64位存储在寄存器`x2`中，低位64位存储在`x3`中。
- en: The multiply instructions don’t affect the condition flags in the `nzcv` register.
    We need to carefully analyze our algorithms for all possible values and use the
    appropriate instructions.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 乘法指令不会影响`nzcv`寄存器中的条件标志。我们需要仔细分析我们的算法，以适应所有可能的值，并使用适当的指令。
- en: Next, I’ll cover division, the inverse of multiplication.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我将介绍除法，它是乘法的逆运算。
- en: '**YOUR TURN**'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: '**你的回合**'
- en: 16.6     Write a `dec_to_uint` function in assembly language that converts an
    unsigned decimal number from its text string format to its `unsigned int` format.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 16.6     编写一个`dec_to_uint`汇编语言函数，将一个无符号十进制数从文本字符串格式转换为`unsigned int`格式。
- en: 16.7     I asserted that the C statement `result = 2 * ((4 * result) + result);`
    is equivalent to the `result = RADIX * result`; statement in [Listing 16-15](ch16.xhtml#ch16list15).
    Make that change in [Listing 16-15](ch16.xhtml#ch16list15) and compare the compiler-generated
    assembly language with that in [Listing 16-16](ch16.xhtml#ch16list16).
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 16.7     我断言C语句`result = 2 * ((4 * result) + result);`等价于[清单 16-15](ch16.xhtml#ch16list15)中的`result
    = RADIX * result;`语句。请在[清单 16-15](ch16.xhtml#ch16list15)中做出该更改，并将编译器生成的汇编语言与[清单
    16-16](ch16.xhtml#ch16list16)中的进行比较。
- en: '**Division**'
  id: totrans-236
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**除法**'
- en: When multiplying two *n*-bit numbers, we were concerned about the result being
    2*n* bits wide. In division, the quotient will never be wider than the dividend,
    but division takes much longer than multiplication. In this section, you’ll learn
    about an algorithm that can speed up division when the divisor is a constant.
    Integer division can give a remainder, which may also need to be computed.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 在乘法中，当我们相乘两个*n*位的数字时，我们担心结果会是2*n*位宽。而在除法中，商的宽度不会超过被除数，但除法的速度比乘法慢得多。在这一部分，你将学习一种可以加速除法的算法，特别是当除数是常量时。整数除法可能会有余数，这个余数也可能需要计算。
- en: I’ll start with a C function that converts an `int` to the numerical text string
    it represents, the inverse of the earlier `dec_to_int` function.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 我将从一个C函数开始，该函数将一个`int`转换为它所表示的数字文本字符串，这是之前`dec_to_int`函数的逆操作。
- en: '***In C***'
  id: totrans-239
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***在C语言中***'
- en: Our `main` function will read an integer from the user, subtract 123 from it,
    and show the result. Our subfunction, `int_to_dec`, will use a division algorithm
    to convert a 32-bit `int` to the text string that represents it so that the `main`
    function can display the result. [Listings 16-19](ch16.xhtml#ch16list19) through
    [16-21](ch16.xhtml#ch16list21) show the complete program.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的`main`函数将从用户读取一个整数，减去123并显示结果。我们的子函数`int_to_dec`将使用除法算法将一个32位的`int`转换为表示它的文本字符串，这样`main`函数就可以显示结果。[清单
    16-19](ch16.xhtml#ch16list19)至[16-21](ch16.xhtml#ch16list21)展示了完整的程序。
- en: '*sub_123.c*'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: '*sub_123.c*'
- en: '[PRE23]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: '*Listing 16-19: A program to subtract 123 from an* int'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 16-19：一个从int中减去123的程序*'
- en: The `main` function for this program is quite simple. We use the assembly language
    version of `dec_to_int` in [Listing 16-18](ch16.xhtml#ch16list18) to convert the
    user’s input to an `int`. We then subtract 123 from the `int`, convert the resulting
    number to its text string representation, and display the result.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 这个程序的`main`函数非常简单。我们使用[清单 16-18](ch16.xhtml#ch16list18)中的`dec_to_int`汇编语言版本将用户输入转换为`int`。然后，我们从`int`中减去123，将结果转换为文本字符串表示，并显示结果。
- en: '[Listing 16-20](ch16.xhtml#ch16list20) shows the header file for the `int_to_dec`
    function.'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: '[清单 16-20](ch16.xhtml#ch16list20)展示了`int_to_dec`函数的头文件。'
- en: '*int_to_dec.h*'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: '*int_to_dec.h*'
- en: '[PRE24]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: '*Listing 16-20: The header file for the* int_to_dec *function*'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 16-20：*int_to_dec*函数的头文件*'
- en: The header file declares the `int_to_dec` function. The `int` is the input,
    and the `char` pointer is the location for the primary output. The `int_to_dec`
    function also returns an `int` that gives the number of characters in the output
    string.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 头文件声明了`int_to_dec`函数。`int`是输入，`char`指针是主要输出的存储位置。`int_to_dec`函数还返回一个`int`，表示输出字符串中的字符数。
- en: '[Listing 16-21](ch16.xhtml#ch16list21) shows the definition of the `int_to_dec`
    function.'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: '[清单 16-21](ch16.xhtml#ch16list21)展示了`int_to_dec`函数的定义。'
- en: '*int_to_dec.c*'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: '*int_to_dec.c*'
- en: '[PRE25]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: '*Listing 16-21: The* int_to_dec *function in C*'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 16-21：C语言中的*int_to_dec*函数*'
- en: The algorithm we’re using to find the characters that represent the `int` in
    decimal involves the repeated integer division of the `int` by 10\. The `%` operator
    computes the remainder from the division ❹. For positive integers, the remainder
    will be a 32-bit `int` in the range 0 through 9, or `0x00000000` through `0x00000009`,
    which is the value of the lowest-order decimal digit.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 我们用于查找表示`int`十进制字符的算法涉及将`int`反复除以10。`%`操作符计算除法的余数❹。对于正整数，余数将是一个32位的`int`，范围从0到9，或者`0x00000000`到`0x00000009`，即最低位十进制数字的值。
- en: However, for negative integers, the remainder will be an `int` in the range
    0 through –9, or `0x00000000` through `0xfffffff7`. The negative values in this
    range require a different algorithm to convert them to their corresponding ASCII
    numeric character. The solution we’re using here is to negate an input negative
    integer, prepend the resulting text string with a – sign, and convert the positive
    result ❶.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，对于负整数，余数将是一个`int`，范围从0到-9，或者`0x00000000`到`0xfffffff7`。该范围内的负值需要使用不同的算法将它们转换为相应的ASCII数字字符。我们这里使用的解决方案是取负输入整数的相反数，结果文本前加上“-”符号，并转换为正结果❶。
- en: 'This works for all but one 32-bit negative number: –2,147,483,648\. There is
    no 32-bit +2,147,483,648 in two’s complement format; negating –2,147,483,648 gives
    –2,147,483,648\. Our solution is to convert the negated `int` to an `unsigned
    int` ❸. This doesn’t change the bit pattern of the value, `0x80000000`, but it
    tells the compiler to use unsigned `%` and `/` operations. So, for 2,147,483,648,
    the `working % RADIX` operation will give us `0x00000008`.'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 该算法适用于所有32位负数，除了一个：-2,147,483,648。二进制补码格式中没有32位的+2,147,483,648；取-2,147,483,648的相反数仍然是-2,147,483,648。我们的解决方案是将取负后的`int`转换为`unsigned
    int`❸。这不会改变值`0x80000000`的位模式，但它告诉编译器使用无符号的`%`和`/`操作。因此，对于2,147,483,648，`working
    % RADIX`操作将给我们`0x00000008`。
- en: We convert the `unsigned int` from the `%` operation to a `char` with `(char)`,
    the *cast operator* ❹. The parentheses are part of the syntax for a cast operator.
    Then, we use a bitwise OR operation to convert the `char` to its corresponding
    numeric character in ASCII code.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将`unsigned int`从`%`操作转换为`char`，使用`(char)`，即*类型转换操作符*❹。括号是类型转换操作符的语法部分。然后，我们使用按位或操作符将`char`转换为其对应的ASCII码数字字符。
- en: '**NOTE**'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*Be careful when using a cast operator to convert the type of a value. We’re
    converting from a 32-bit value to an 8-bit one, which may cause a loss of information.
    In this case, we know the information will be encoded in 4 bits, so the conversion
    is safe.*'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: '*在使用类型转换操作符转换值的类型时要小心。我们正在将一个32位的值转换为8位值，这可能会导致信息丢失。在这种情况下，我们知道信息将以4位进行编码，因此转换是安全的。*'
- en: Since this algorithm works from right to left, the characters are stored in
    reverse order. So, we need to reverse the order of the text string for the calling
    function ❺. Storing the `NUL` character first ❷ provides a way to know when the
    entire text string has been completely copied in reverse order ❻.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 由于该算法是从右到左工作的，因此字符以反向顺序存储。因此，我们需要反转文本字符串的顺序，以供调用函数使用❺。首先存储`NUL`字符❷提供了一种方法，能够知道整个文本字符串是否已完全反向复制❻。
- en: Next, we’ll look at the assembly language generated by the compiler, shown in
    [Listing 16-22](ch16.xhtml#ch16list22).
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将查看编译器生成的汇编语言，如[清单 16-22](ch16.xhtml#ch16list22)所示。
- en: '*int_to_dec.s*'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: '*int_to_dec.s*'
- en: '[PRE26]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: '*Listing 16-22: The compiler-generated assembly language for the* int_to_dec
    *function in [Listing 16-21](ch16.xhtml#ch16list21)*'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 16-22：编译器生成的用于* int_to_dec *函数的汇编语言，如[清单 16-21](ch16.xhtml#ch16list21)所示*'
- en: 'The C algorithm involves division by 10, but the compiler uses a `umull` instruction
    to perform the remainder (`%`) operation ❷. This is because division takes much
    more time than multiplication. Since we’re dividing by a constant, the compiler
    uses the following arithmetic:'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: C算法涉及除以10，但编译器使用`umull`指令执行余数（`%`）操作❷。这是因为除法比乘法耗时要多。由于我们除的是常数，编译器使用以下算术运算：
- en: '![Image](../images/pg382_Image_286.jpg)'
  id: totrans-266
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/pg382_Image_286.jpg)'
- en: The compiler uses *n* = 35, giving the constant 2^(35)/10 = 3,435,973,836.8\.
    Rounding this to the nearest integer gives 3,435,973,837 = `0xcccccccd` ❶. After
    multiplying the `working` integer by this constant, the algorithm shifts the result
    35 bits to the right to divide by 2^(35).
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 编译器使用*n* = 35，得到常数2^(35)/10 = 3,435,973,836.8。将其四舍五入到最接近的整数得到3,435,973,837 =
    `0xcccccccd`❶。在将`working`整数乘以此常数后，算法将结果右移35位以除以2^(35)。
- en: The compiler then uses the shift-and-add algorithm to multiply this quotient
    by 10 ❸. Subtracting the result from the original dividend leaves us with the
    remainder ❹, which is converted to the corresponding ASCII character ❺.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 编译器然后使用移位加法算法将这个商乘以10 ❸。从原始被除数中减去结果后，我们得到余数❹，该余数转换为相应的ASCII字符❺。
- en: The compiler implements the `/` operation with the same multiply-and-shift algorithm
    that it used for the `%` operation ❻.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 编译器使用与处理`%`操作相同的乘法和移位算法来实现`/`操作❻。
- en: Using multiplication and shifts to divide is limited. To see how the division
    instructions work, we’ll use a divide instruction for our assembly language version
    of the `int_to_dec` function.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 使用乘法和移位进行除法是有限制的。为了查看除法指令如何工作，我们将在`int_to_dec`函数的汇编语言版本中使用除法指令。
- en: '***In Assembly Language***'
  id: totrans-271
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***在汇编语言中***'
- en: We didn’t look at the compiler-generated assembly language for the `main` function
    in the C version of our `sub_123` program ([Listing 16-19](ch16.xhtml#ch16list19)).
    It’s similar to our assembly language version, which is shown in [Listing 16-23](ch16.xhtml#ch16list23).
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 我们没有查看C版本的`sub_123`程序中`main`函数的编译器生成的汇编语言（[Listing 16-19](ch16.xhtml#ch16list19)）。它与我们的汇编语言版本相似，后者显示在[Listing
    16-23](ch16.xhtml#ch16list23)中。
- en: '*sub_123.s*'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: '*sub_123.s*'
- en: '[PRE27]'
  id: totrans-274
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: '*Listing 16-23: The assembly language version of the* main *function for the*
    sub_123 *program*'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: '*Listing 16-23：*sub_123*程序的* main *函数的汇编语言版本*'
- en: There isn’t anything new in the `main` function; we can use the same stack frame
    design from [Figure 16-3](ch16.xhtml#ch16fig3) ❶.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: '`main`函数中没有新的内容；我们可以使用[Figure 16-3](ch16.xhtml#ch16fig3)中的相同栈帧设计❶。'
- en: '[Listing 16-24](ch16.xhtml#ch16list24) shows our assembly language version
    of the `int_to_dec` function.'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: '[Listing 16-24](ch16.xhtml#ch16list24)显示了我们`int_to_dec`函数的汇编语言版本。'
- en: '*int_to_dec.s*'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: '*int_to_dec.s*'
- en: '[PRE28]'
  id: totrans-279
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: '*Listing 16-24: The assembly language version of the* int_to_dec *function*'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: '*Listing 16-24：*int_to_dec*函数的汇编语言版本*'
- en: Since this is a leaf function, we don’t need a frame record, but we do need
    space on the stack for storing the text string locally as we generate it in reverse
    order ❶.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这是一个叶子函数，我们不需要帧记录，但我们确实需要在栈上为存储生成的文本字符串留出空间，以便按逆序生成它❶。
- en: Rather than using a multiply-and-shift algorithm like the compiler did, we use
    the `udiv` instruction to divide by 10 ❷. This gives us the quotient in the `w4`
    register. Then, we use the `msub` instruction to multiply the quotient (register
    `w4`) by RADIX (register `w2`) and subtract that product from the dividend (register
    `w1`), leaving the remainder in register `w5` ❸. Since we already have the quotient
    in register `w4`, we can use that for the next iteration of this loop ❹.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 我们没有像编译器那样使用乘法和移位算法，而是使用`udiv`指令将数字除以10 ❷。这将商存储在`w4`寄存器中。然后，我们使用`msub`指令将商（`w4`寄存器）乘以基数（`w2`寄存器），并从被除数（`w1`寄存器）中减去该乘积，将余数保留在`w5`寄存器中❸。由于我们已经在`w4`寄存器中得到了商，我们可以使用它进行该循环的下一次迭代❹。
- en: 'In [Listing 16-24](ch16.xhtml#ch16list24), we see two new instructions: `msub`
    and `udiv`. I’ll also describe `sdiv` here:'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 在[Listing 16-24](ch16.xhtml#ch16list24)中，我们看到两个新的指令：`msub`和`udiv`。我还将在此描述`sdiv`：
- en: msub**—Multiply and subtract**
  id: totrans-284
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: msub**—乘法与减法**
- en: '`msub w`d `, w`s1 `, w`s2 `, w`s3 multiplies `w`s1 by `w`s2, subtracts the
    value in `w`s3 from the product, and loads the result in `w`d.'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: '`msub w`d `, w`s1 `, w`s2 `, w`s3将`w`s1乘以`w`s2，然后从乘积中减去`w`s3的值，并将结果加载到`w`d中。'
- en: '`msub x`d `, x`s1 `, x`s2 `, x`s3 multiplies `x`s1 by `x`s2, subtracts the
    value in `x`s3 from the product, and loads the result in `x`d.'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: '`msub x`d `, x`s1 `, x`s2 `, x`s3将`x`s1乘以`x`s2，然后从乘积中减去`x`s3的值，并将结果加载到`x`d中。'
- en: udiv**—Unsigned divide**
  id: totrans-287
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: udiv**—无符号除法**
- en: '`udiv w`d `, w`s1 `, w`s2 divides `w`s1 by `w`s2 and stores the result in `w`d.
    It treats all values as unsigned numbers.'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: '`udiv w`d `, w`s1 `, w`s2将`w`s1`除以`w`s2并将结果存储在`w`d中。它将所有值视为无符号数字。'
- en: '`udiv x`d `, x`s1 `, x`s2 divides `x`s1 by `x`s2 and stores the result in `x`d.
    It treats all values as unsigned numbers.'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: '`udiv x`d `, x`s1 `, x`s2将`x`s1`除以`x`s2并将结果存储在`x`d中。它将所有值视为无符号数字。'
- en: sdiv**—Signed divide**
  id: totrans-290
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: sdiv**—有符号除法**
- en: '`sdiv w`d `, w`s1 `, w`s2 divides `w`s1 by `w`s2 and stores the result in `w`d.
    If `w`s1 and `w`s2 are of the same sign, the value in `w`d will be positive. If
    they are of opposite signs, the value in `w`d will be negative.'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: '`sdiv w`d `, w`s1 `, w`s2将`w`s1`除以`w`s2并将结果存储在`w`d中。如果`w`s1和`w`s2符号相同，则`w`d中的值为正；如果它们符号相反，则`w`d中的值为负。'
- en: '`sdiv x`d `, x`s1 `, x`s2 divides `x`s1 by `x`s2 and stores the result in `x`d.
    If `x`s1 and `x`s2 are of the same sign, the value in `x`d will be positive. If
    they are of opposite signs, the value in `x`d will be negative.'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: '`sdiv x`d `, x`s1 `, x`s2`将`x`s1除以`x`s2，并将结果存储到`x`d中。如果`x`s1和`x`s2符号相同，`x`d中的值将为正；如果它们符号相反，`x`d中的值将为负。'
- en: The divide instructions don’t affect the condition flags in the `nzcv` register.
    They don’t even give an error if you divide by zero; they load 0 into the destination
    register. You need to carefully analyze your algorithms for all possible values
    to make sure you never divide by zero.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 除法指令不会影响`nzcv`寄存器中的条件标志。如果除数为零，它们甚至不会报错；它们会将0加载到目标寄存器中。你需要仔细分析算法的所有可能值，以确保永远不会除以零。
- en: '**YOUR TURN**'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: '**轮到你了**'
- en: 16.8     Write the two functions `put_int` and `get_int` in assembly language.
    The `put_int` function takes one argument, a 32-bit signed integer, and displays
    it on the screen. The `get_int` function returns a 32-bit signed integer, which
    it reads from keyboard input. Write a `main` function in C to test `put_int` and
    `get_int`. We’ll be using `put_int` and `get_int` in subsequent chapters for displaying
    and reading integers.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 16.8     编写两个汇编语言函数`put_int`和`get_int`。`put_int`函数接受一个参数，一个32位有符号整数，并将其显示在屏幕上。`get_int`函数返回一个32位有符号整数，读取自键盘输入。编写一个`main`函数进行C语言测试`put_int`和`get_int`。我们将在后续章节中使用`put_int`和`get_int`来显示和读取整数。
- en: 16.9     Write the two functions `put_uint` and `get_uint` in assembly language.
    The `put_uint` function takes one argument, a 32-bit unsigned integer, and displays
    it on the screen. The `get_uint` function returns a 32-bit unsigned integer, which
    it reads from keyboard input. Use the `dec_to_uint` function from [exercise 16.6](ch16.xhtml#ch16exe6)
    on [page 348](ch16.xhtml#ch16you1), and write the function `uint_to_dec`. Write
    a `main` function in C to test `put_uint` and `get_uint`. We’ll be using `put_uint`
    and `get_uint` in subsequent chapters for displaying and reading integers.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 16.9     编写两个汇编语言函数`put_uint`和`get_uint`。`put_uint`函数接受一个参数，一个32位无符号整数，并将其显示在屏幕上。`get_uint`函数返回一个32位无符号整数，读取自键盘输入。使用[练习16.6](ch16.xhtml#ch16exe6)中的`dec_to_uint`函数，[第348页](ch16.xhtml#ch16you1)，并编写`uint_to_dec`函数。编写一个`main`函数进行C语言测试`put_uint`和`get_uint`。我们将在后续章节中使用`put_uint`和`get_uint`来显示和读取整数。
- en: 16.10   Write a program in assembly language that allows a user to enter two
    signed decimal integers. The program will add, subtract, multiply, and divide
    the two integers. It will display the sum, difference, product, quotient, and
    remainder resulting from these operations.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 16.10   编写一个汇编语言程序，允许用户输入两个有符号的十进制整数。程序将对这两个整数进行加、减、乘、除运算，并显示结果的和、差、积、商和余数。
- en: '**What You’ve Learned**'
  id: totrans-298
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**你学到了什么**'
- en: '**Bitmasking** We can use bitwise logic instructions to directly change bit
    patterns in variables.'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: '**位掩码** 我们可以使用按位逻辑指令直接改变变量中的位模式。'
- en: '**Bit shifting** Bits in variables can be shifted left or right, effectively
    multiplying or dividing by multiples of 2.'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: '**位移** 变量中的位可以向左或向右移动，实际上是通过2的倍数进行乘法或除法运算。'
- en: '**Multiplication** The multiply instructions allow us to perform signed or
    unsigned multiplication. Multiplying large 64-bit values requires two instructions
    for the 128-bit result.'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: '**乘法** 乘法指令允许我们执行有符号或无符号的乘法。乘以较大的64位值需要两条指令来处理128位的结果。'
- en: '**Faster multiplication** When multiplying by a constant, a combination of
    adding and shifting can be faster than a multiply instruction.'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: '**更快的乘法** 当乘以常数时，使用加法和移位的组合可能比乘法指令更快。'
- en: '**Division** The divide instructions allow us to perform signed or unsigned
    division.'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: '**除法** 除法指令允许我们执行有符号或无符号的除法运算。'
- en: '**Faster division** When dividing by a constant, a combination of multiplying
    and shifting can be faster than a divide instruction.'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: '**更快的除法** 当除以常数时，乘法和移位的组合可能比除法指令更快。'
- en: '**Converting numbers between binary storage and character display** Arithmetic
    operations are easier when numbers are stored in the binary system, but keyboard
    input and screen display use the corresponding character format.'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: '**在二进制存储和字符显示之间转换数字** 当数字以二进制形式存储时，算术运算会更简单，但键盘输入和屏幕显示使用的是相应的字符格式。'
- en: 'We’ve now covered ways to organize program flow and perform arithmetic or logic
    operations on data items. In the next chapter, we’ll explore two of the most fundamental
    ways to organize data: arrays and records.'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在已经介绍了如何组织程序流程以及如何对数据项执行算术或逻辑操作。在下一章中，我们将探讨两种最基本的数据组织方式：数组和记录。
