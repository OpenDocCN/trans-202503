- en: '5'
  id: totrans-0
  prefs: []
  type: TYPE_NORMAL
  zh: '5'
- en: AUTOMATING NESSUS
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 自动化Nessus
- en: '![](images/00010.jpg)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![](images/00010.jpg)'
- en: Nessus is a popular and powerful vulnerability scanner that uses a database
    of known vulnerabilities to assess whether a given system on a network is missing
    any patches or is vulnerable to known exploits. In this chapter, I’ll show you
    how to write classes to interact with the Nessus API to automate, configure, and
    run a vulnerability scan.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: Nessus是一个流行且强大的漏洞扫描器，它使用已知漏洞的数据库来评估网络中给定系统是否缺少任何补丁，或者是否易受已知漏洞的攻击。在本章中，我将向你展示如何编写类与Nessus
    API交互，以自动化、配置和执行漏洞扫描。
- en: Nessus was first developed as an open source vulnerability scanner, but it became
    closed source in 2005 after being purchased by Tenable Network Security. As of
    this writing, Tenable offers a seven-day trial of Nessus Professional and a limited
    version called Nessus Home. The biggest difference between the two is that Nessus
    Home allows you to scan only 16 IP addresses at once, but Home should be sufficient
    for you to run the examples in this chapter and become familiar with the program.
    Nessus is particularly popular with professionals who help scan and manage other
    companies’ networks. Follow the instructions on the Tenable site [https://www.tenable.com/products/nessus-home/](https://www.tenable.com/products/nessus-home/)
    to install and configure Nessus Home.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: Nessus最初作为一个开源漏洞扫描器开发，但在2005年被Tenable Network Security收购后变为闭源。截至本文写作时，Tenable提供了一个为期七天的Nessus
    Professional试用版，并且还有一个叫Nessus Home的有限版。两者之间最大的区别是，Nessus Home一次最多只能扫描16个IP地址，但Home版本足以让你运行本章中的示例并熟悉该程序。Nessus在帮助扫描和管理其他公司网络的专业人士中尤其受欢迎。请按照Tenable网站上的说明[https://www.tenable.com/products/nessus-home/](https://www.tenable.com/products/nessus-home/)安装和配置Nessus
    Home。
- en: Many organizations require regular vulnerability and patch scanning in order
    to manage and identify risks on their network, as well as for compliance purposes.
    We’ll use Nessus to accomplish these goals by building classes to help us perform
    unauthenticated vulnerability scans against hosts on a network.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 许多组织要求定期进行漏洞和补丁扫描，以便管理和识别其网络上的风险，并满足合规性要求。我们将使用Nessus来实现这些目标，通过构建类来帮助我们对网络上的主机执行无认证的漏洞扫描。
- en: REST and the Nessus API
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: REST与Nessus API
- en: The advent of web applications and APIs has given rise to an architecture of
    APIs called REST APIs. REST (representational state transfer) is a way of accessing
    and interacting with resources (such as user accounts or vulnerability scans)
    on the server, usually over HTTP, using a variety of HTTP methods (GET, POST,
    DELETE, and PUT). HTTP methods describe our intent in making the HTTP request
    (for example, do we want to create a resource or modify a resource?), kind of
    like CRUD (Create, Read, Update, Delete) operations in databases.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: Web应用程序和API的出现催生了一种叫做REST API的架构。REST（表述性状态转移）是一种通过HTTP等协议访问和交互资源（如用户账户或漏洞扫描）的方法，通常使用多种HTTP方法（GET、POST、DELETE和PUT）。HTTP方法描述了我们发起HTTP请求时的意图（例如，我们是想创建资源还是修改资源？），有点像数据库中的CRUD（创建、读取、更新、删除）操作。
- en: 'For instance, take a look at the following simple GET HTTP request, which is
    like a read operation for a database (like SELECT * FROM users WHERE id = 1):
    GET /users/➊1 HTTP/1.0'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，看看以下简单的GET HTTP请求，它类似于数据库的读取操作（如SELECT * FROM users WHERE id = 1）：GET /users/➊1
    HTTP/1.0
- en: 'Host: 192.168.0.11'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 主机：192.168.0.11
- en: In this example, we’re requesting information for the user with an ID of 1\.
    To get the information for another user’s ID, you could replace the 1 ➊ at the
    end of the URI with that user’s ID.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们请求ID为1的用户信息。如果要获取其他用户ID的信息，可以将URI末尾的1 ➊替换为该用户的ID。
- en: 'To update the information for the first user, the HTTP request might look like
    this: POST /users/1 HTTP/1.0'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 要更新第一个用户的信息，HTTP请求可能如下所示：POST /users/1 HTTP/1.0
- en: 'Host: 192.168.0.11'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 主机：192.168.0.11
- en: 'Content-Type: application/json'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 内容类型：application/json
- en: 'Content-Length: 24'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 内容长度：24
- en: '{"name": "Brandon Perry"}'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: '{"name": "Brandon Perry"}'
- en: In our hypothetical RESTful API, the preceding POST request would update the
    first user’s name to Brandon Perry. Commonly, POST requests are used to update
    a resource on the web server.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们假设的RESTful API中，上面的POST请求会将第一个用户的名称更新为Brandon Perry。通常，POST请求用于更新Web服务器上的资源。
- en: 'To delete the account entirely, use DELETE, like so: DELETE /users/1 HTTP/1.0'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 要完全删除账户，可以使用DELETE，例如：DELETE /users/1 HTTP/1.0
- en: 'Host: 192.168.0.11'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 主机：192.168.0.11
- en: The Nessus API will behave similarly. When consuming the API, we’ll send JSON
    to and receive JSON from the server, as in these examples. The classes we’ll write
    in this chapter are designed to handle the ways that we communicate and interact
    with the REST API.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: Nessus API的行为也类似。在使用API时，我们将向服务器发送JSON并从服务器接收JSON，如这些示例所示。本章中我们将编写的类旨在处理与REST
    API交互的方式。
- en: Once you have Nessus installed, you can find the Nessus REST API documentation
    at https://<IP address>:8834/api. We’ll cover only a few of the core API calls
    used to drive Nessus to perform vulnerability scans.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你安装了Nessus，你可以在https://<IP地址>:8834/api找到Nessus REST API文档。我们将仅讨论一些用于驱动Nessus进行漏洞扫描的核心API调用。
- en: The NessusSession Class
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: NessusSession类
- en: To automate sending commands and receiving responses from Nessus, we’ll create
    a session with the NessusSession class and execute API commands, as shown in [Listing
    5-1](#filepos426644).
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 为了自动化发送命令并接收来自Nessus的响应，我们将使用NessusSession类创建会话并执行API命令，如[清单5-1](#filepos426644)所示。
- en: 'public class NessusSession : ➊IDisposable'
  id: totrans-23
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 'public class NessusSession : ➊IDisposable'
- en: '{'
  id: totrans-24
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '{'
- en: public ➋NessusSession(string host, string username, string password)
  id: totrans-25
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: public ➋NessusSession(string host, string username, string password)
- en: '{'
  id: totrans-26
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '{'
- en: ''
  id: totrans-27
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ServicePointManager.ServerCertificateValidationCallback =
  id: totrans-28
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ServicePointManager.ServerCertificateValidationCallback =
- en: (Object obj, X509Certificate certificate, X509Chain chain, SslPolicyErrors errors)
    => true;
  id: totrans-29
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: (Object obj, X509Certificate certificate, X509Chain chain, SslPolicyErrors errors)
    => true;
- en: ''
  id: totrans-30
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: this.Host = ➌host;
  id: totrans-31
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: this.Host = ➌host;
- en: ''
  id: totrans-32
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: if (➍!Authenticate(username, password))
  id: totrans-33
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: if (➍!Authenticate(username, password))
- en: throw new Exception("Authentication failed");
  id: totrans-34
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: throw new Exception("身份验证失败");
- en: '}'
  id: totrans-35
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '}'
- en: ''
  id: totrans-36
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: public bool ➎Authenticate(string username, string password)
  id: totrans-37
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: public bool ➎Authenticate(string username, string password)
- en: '{'
  id: totrans-38
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '{'
- en: JObject obj = ➏new JObject();
  id: totrans-39
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: JObject obj = ➏new JObject();
- en: obj["username"] = username;
  id: totrans-40
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: obj["username"] = username;
- en: obj["password"] = password;
  id: totrans-41
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: obj["password"] = password;
- en: ''
  id: totrans-42
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: JObject ret = ➐MakeRequest(WebRequestMethods.Http.Post, "/session", obj);
  id: totrans-43
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: JObject ret = ➐MakeRequest(WebRequestMethods.Http.Post, "/session", obj);
- en: ''
  id: totrans-44
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: if (ret ["token"] == null)
  id: totrans-45
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: if (ret ["token"] == null)
- en: return false;
  id: totrans-46
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: return false;
- en: ''
  id: totrans-47
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: this.➑Token = ret["token"].Value<string>();
  id: totrans-48
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: this.➑Token = ret["token"].Value<string>();
- en: this.Authenticated = true;
  id: totrans-49
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: this.Authenticated = true;
- en: ''
  id: totrans-50
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: return true;
  id: totrans-51
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: return true;
- en: '}'
  id: totrans-52
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '}'
- en: 'Listing 5-1: The beginning of the  NessusSession  class showing the constructor
    and  Authenticate()  method'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 清单5-1：NessusSession类的开头，显示了构造函数和Authenticate()方法
- en: As you can see in [Listing 5-1](#filepos426644), this class implements the IDisposable
    interface ➊ so that we can use the NessusSession class within a using statement.
    As you may recall from earlier chapters, the IDisposable interface allows us to
    automatically clean up our session with Nessus by calling Dispose(), which we’ll
    implement shortly, when the currently instantiated class in the using statement
    is disposed during garbage collection.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 如[清单5-1](#filepos426644)所示，这个类实现了IDisposable接口➊，以便我们可以在using语句中使用NessusSession类。正如你在前面的章节中可能记得的，IDisposable接口允许我们通过调用Dispose()方法在垃圾回收时自动清理与Nessus的会话，我们将在稍后实现该方法。
- en: At ➌, we assign the Host property to the value of the host parameter passed
    to the NessusSession constructor ➋, and then we try to authenticate ➍ since any
    subsequent API calls will require an authenticated session. If authentication
    fails, we throw an exception and print the alert "Authentication failed". If authentication
    succeeds, we store the API key for later use.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 在➌处，我们将Host属性赋值为传递给NessusSession构造函数➋的host参数的值，然后我们尝试进行身份验证➍，因为后续的所有API调用都需要已认证的会话。如果身份验证失败，我们将抛出异常并打印警告“身份验证失败”。如果身份验证成功，我们将存储API密钥以备后用。
- en: In the Authenticate() method ➎, we create a JObject ➏ to hold the credentials
    passed in as arguments. We’ll use these to attempt to authenticate, and then we’ll
    call the MakeRequest() method ➐ (discussed next) and pass the HTTP method, the
    URI of the target host, and the JObject. If authentication succeeds, MakeRequest()
    should return a JObject with an authentication token; if authentication fails,
    it should return an empty JObject.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 在Authenticate()方法➎中，我们创建了一个JObject➏来保存作为参数传入的凭证。我们将使用这些凭证尝试进行身份验证，然后调用MakeRequest()方法➐（接下来讨论）并传递HTTP方法、目标主机的URI和JObject。如果身份验证成功，MakeRequest()应该返回一个包含身份验证令牌的JObject；如果身份验证失败，则返回一个空的JObject。
- en: When we receive the authentication token, we assign its value to the Token property
    ➑, assign the Authenticated property to true, and return true to the caller method
    to tell the programmer that authentication succeeded. If authentication fails,
    we return false.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们收到认证令牌时，我们将其值赋给 Token 属性 ➑，将 Authenticated 属性设置为 true，并返回 true 给调用方法，告诉程序员认证成功。如果认证失败，我们返回
    false。
- en: Making the HTTP Requests
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 发起 HTTP 请求
- en: The MakeRequest() method makes the actual HTTP requests and then returns the
    responses, as shown in [Listing 5-2](#filepos431563).
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: MakeRequest() 方法执行实际的 HTTP 请求，并返回响应，如 [列表 5-2](#filepos431563) 所示。
- en: public JObject MakeRequest(string method, string uri, ➊JObject data = null,
    string token = null)
  id: totrans-60
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: public JObject MakeRequest(string method, string uri, ➊JObject data = null,
    string token = null)
- en: '{'
  id: totrans-61
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '{'
- en: string url = ➋"https://" + this.Host + ":8834" + uri;
  id: totrans-62
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: string url = ➋"https://" + this.Host + ":8834" + uri;
- en: HttpWebRequest request = (HttpWebRequest)WebRequest.Create(url);
  id: totrans-63
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: HttpWebRequest request = (HttpWebRequest)WebRequest.Create(url);
- en: request.➌Method = method;
  id: totrans-64
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: request.➌Method = method;
- en: ''
  id: totrans-65
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: if (!string.IsNullOrEmpty(token))
  id: totrans-66
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 如果 (!string.IsNullOrEmpty(token))
- en: request.Headers ["X-Cookie"] = ➍"token=" + token;
  id: totrans-67
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: request.Headers ["X-Cookie"] = ➍"token=" + token;
- en: ''
  id: totrans-68
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: request.➎ContentType = "application/json";
  id: totrans-69
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: request.➎ContentType = "application/json";
- en: ''
  id: totrans-70
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: if (data != null)
  id: totrans-71
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 如果 (data != null)
- en: '{'
  id: totrans-72
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '{'
- en: byte[] bytes = System.Text.Encoding.ASCII.➏GetBytes(data.ToString());
  id: totrans-73
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: byte[] bytes = System.Text.Encoding.ASCII.➏GetBytes(data.ToString());
- en: request.ContentLength = bytes.Length;
  id: totrans-74
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: request.ContentLength = bytes.Length;
- en: using (Stream requestStream = request.GetRequestStream())
  id: totrans-75
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 使用 (Stream requestStream = request.GetRequestStream())
- en: requestStream.➐Write(bytes, 0, bytes.Length);
  id: totrans-76
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: requestStream.➐Write(bytes, 0, bytes.Length);
- en: '}'
  id: totrans-77
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '}'
- en: else
  id: totrans-78
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 否则
- en: request.ContentLength = 0;
  id: totrans-79
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: request.ContentLength = 0;
- en: ''
  id: totrans-80
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: string response = string.Empty;
  id: totrans-81
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: string response = string.Empty;
- en: try ➑
  id: totrans-82
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 尝试 ➑
- en: '{'
  id: totrans-83
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '{'
- en: using (StreamReader reader = new ➒StreamReader(request.GetResponse().GetResponseStream()))
  id: totrans-84
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 使用 (StreamReader reader = new ➒StreamReader(request.GetResponse().GetResponseStream()))
- en: response = reader.ReadToEnd();
  id: totrans-85
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: response = reader.ReadToEnd();
- en: '}'
  id: totrans-86
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '}'
- en: catch
  id: totrans-87
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 捕获
- en: '{'
  id: totrans-88
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '{'
- en: return new JObject();
  id: totrans-89
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 返回新的 JObject();
- en: '}'
  id: totrans-90
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '}'
- en: ''
  id: totrans-91
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: if (string.IsNullOrEmpty(response))
  id: totrans-92
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 如果 (string.IsNullOrEmpty(response))
- en: return new JObject();
  id: totrans-93
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 返回新的 JObject();
- en: return JObject.➓Parse(response);
  id: totrans-94
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 返回 JObject.➓Parse(response);
- en: '}'
  id: totrans-95
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '}'
- en: 'Listing 5-2: The  MakeRequest()  method from the  NessusSession  class'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 5-2：来自 NessusSession 类的 MakeRequest() 方法
- en: The MakeRequest() method has two required parameters (HTTP and URI) and two
    optional ones (the JObject and the authentication token). The default value for
    each is null.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: MakeRequest() 方法有两个必需的参数（HTTP 和 URI）和两个可选参数（JObject 和认证令牌）。每个参数的默认值为 null。
- en: To create MakeRequest(), we first create the base URL for the API calls ➋ by
    combining the host and URI parameters and passing in the result as the second
    argument; then we use HttpWebRequest to build the HTTP request and set the property
    of HttpWebRequest Method ➌ to the value of the method variable passed into MakeRequest()
    method. Next, we test whether the user supplied an authentication token in JObject.
    If so, we assign the HTTP request header X-Cookie to the value of the token parameter
    ➍, which Nessus will look for when we authenticate. We set the ContentType property
    ➎ of the HTTP request to application/json to ensure that the API server knows
    how to deal with the data we are sending in the body of the request (otherwise,
    it will refuse to accept the request).
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 为了创建 MakeRequest() 方法，我们首先通过将主机和 URI 参数结合起来并将结果作为第二个参数传递来创建 API 调用的基本 URL ➋；然后我们使用
    HttpWebRequest 构建 HTTP 请求，并将 HttpWebRequest 的 Method 属性 ➌ 设置为传递给 MakeRequest()
    方法的 method 变量的值。接下来，我们测试用户是否在 JObject 中提供了认证令牌。如果提供了，我们将 HTTP 请求头 X-Cookie 设置为
    token 参数的值 ➍，这是 Nessus 在认证时会查找的内容。我们将 HTTP 请求的 ContentType 属性 ➎ 设置为 application/json，以确保
    API 服务器知道如何处理我们在请求体中发送的数据（否则，它将拒绝接受请求）。
- en: If a JObject is passed to MakeRequest() in the third argument ➊, we convert
    it to a byte array using GetBytes() ➏, because the Write() method can only write
    bytes. We assign the ContentLength property to the size of the array and then
    use Write() ➐ to write the JSON to the request stream. If the JObject passed to
    MakeRequest() is null, we simply assign the value 0 to ContentLength and move
    on, since we will not be putting any data in the request body.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一个 JObject 被传递给 MakeRequest() 作为第三个参数 ➊，我们会使用 GetBytes() ➏ 将其转换为字节数组，因为 Write()
    方法只能写入字节。我们将 ContentLength 属性设置为数组的大小，然后使用 Write() ➐ 将 JSON 写入请求流。如果传递给 MakeRequest()
    的 JObject 为 null，我们仅将 ContentLength 设置为 0，然后继续，因为我们不会在请求体中放入任何数据。
- en: Having declared an empty string to hold the response from the server, we begin
    a try/catch block at ➑ to receive the response. Within a using statement, we create
    a StreamReader ➒ to read the HTTP response by passing the server’s HTTP response
    stream to the StreamReader constructor; then we call ReadToEnd() to read the full
    response body into our empty string. If reading the response causes an exception,
    we can expect that the response body is empty, so we catch the exception and return
    an empty JObject to ReadToEnd(). Otherwise, we pass the response to Parse() ➓
    and return the resulting JObject.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 在声明了一个空字符串来保存服务器的响应后，我们在 ➑ 处开始一个 try/catch 块来接收响应。在 using 语句中，我们创建一个 StreamReader
    ➒ 来读取 HTTP 响应，通过将服务器的 HTTP 响应流传递给 StreamReader 构造函数；然后我们调用 ReadToEnd() 来读取完整的响应体到我们的空字符串中。如果读取响应时发生异常，我们可以预期响应体为空，因此我们捕获异常并返回一个空的
    JObject 到 ReadToEnd()。否则，我们将响应传递给 Parse() ➓ 并返回结果 JObject。
- en: Logging Out and Cleaning Up
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 注销并清理
- en: To finish the NessusSession class, we’ll create LogOut() to log us out of the
    server and Dispose() to implement the IDisposable interface, as shown in [Listing
    5-3](#filepos436162).
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 为了完成 NessusSession 类，我们将创建 LogOut() 方法以注销服务器，并创建 Dispose() 方法来实现 IDisposable
    接口，如 [Listing 5-3](#filepos436162) 所示。
- en: public void ➊LogOut()
  id: totrans-103
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: public void ➊LogOut()
- en: '{'
  id: totrans-104
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '{'
- en: if (this.Authenticated)
  id: totrans-105
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: if (this.Authenticated)
- en: '{'
  id: totrans-106
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '{'
- en: MakeRequest("DELETE", "/session", null, this.Token);
  id: totrans-107
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: MakeRequest("DELETE", "/session", null, this.Token);
- en: this.Authenticated = false;
  id: totrans-108
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: this.Authenticated = false;
- en: '}'
  id: totrans-109
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '}'
- en: '}'
  id: totrans-110
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '}'
- en: public void ➋Dispose()
  id: totrans-111
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: public void ➋Dispose()
- en: '{'
  id: totrans-112
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '{'
- en: if (this.Authenticated)
  id: totrans-113
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: if (this.Authenticated)
- en: this.LogOut();
  id: totrans-114
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: this.LogOut();
- en: '}'
  id: totrans-115
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '}'
- en: ''
  id: totrans-116
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: public string Host { get; set; }
  id: totrans-117
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: public string Host { get; set; }
- en: public bool Authenticated { get; private set; }
  id: totrans-118
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: public bool Authenticated { get; private set; }
- en: public string Token { get; private set; }
  id: totrans-119
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: public string Token { get; private set; }
- en: '}'
  id: totrans-120
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '}'
- en: 'Listing 5-3: The last two methods of the  NessusSession  class, as well as
    the  Host, Authenticated, and  Token  properties'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: Listing 5-3：NessusSession 类的最后两个方法，以及 Host、Authenticated 和 Token 属性
- en: The LogOut() method ➊ tests whether we’re authenticated with the Nessus server.
    If so, we call MakeRequest() by passing DELETE as the HTTP method; /session as
    the URI; and the authentication token, which sends a DELETE HTTP request to the
    Nessus server, effectively logging us out. Once the request is complete, we set
    the Authenticated property to false. In order to implement the IDisposable interface,
    we create Dispose() ➋ to log us out if we are authenticated.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: LogOut() 方法 ➊ 会检查我们是否已通过 Nessus 服务器认证。如果已认证，我们调用 MakeRequest()，并将 DELETE 作为
    HTTP 方法；/session 作为 URI；以及认证令牌，这会向 Nessus 服务器发送 DELETE HTTP 请求，从而有效地注销我们。一旦请求完成，我们将
    Authenticated 属性设置为 false。为了实现 IDisposable 接口，我们创建 Dispose() ➋ 方法，如果已认证，则注销我们。
- en: Testing the NessusSession Class
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 测试 NessusSession 类
- en: We can easily test the NessusSession class with a small Main() method, as shown
    in [Listing 5-4](#filepos438162).
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过一个小的 Main() 方法轻松测试 NessusSession 类，如 [Listing 5-4](#filepos438162) 中所示。
- en: public static void ➊Main(string[] args)
  id: totrans-125
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: public static void ➊Main(string[] args)
- en: '{'
  id: totrans-126
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '{'
- en: ➋using (NessusSession session = new ➌NessusSession("192.168.1.14", "admin",
    "password"))
  id: totrans-127
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ➋using (NessusSession session = new ➌NessusSession("192.168.1.14", "admin",
    "password"))
- en: '{'
  id: totrans-128
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '{'
- en: 'Console.➍WriteLine("Your authentication token is: " + session.Token);'
  id: totrans-129
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: Console.➍WriteLine("您的认证令牌是：" + session.Token);
- en: '}'
  id: totrans-130
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '}'
- en: '}'
  id: totrans-131
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '}'
- en: 'Listing 5-4: Testing the  NessusSession  class to authenticate with  NessusManager'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: Listing 5-4：测试 NessusSession 类以便与 NessusManager 进行认证
- en: In the Main() method ➊, we create a new NessusSession ➌ and pass the IP address
    of the Nessus host, the username, and the Nessus password as the arguments. With
    the authenticated session, we print the authentication token ➍ Nessus gave us
    on successful authentication and then exit.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Main() 方法 ➊ 中，我们创建一个新的 NessusSession ➌ 并传递 Nessus 主机的 IP 地址、用户名和 Nessus 密码作为参数。通过认证的会话，我们打印出
    Nessus 成功认证时给我们的认证令牌 ➍，然后退出。
- en: NOTE
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: The NessusSession is created in the context of a using statement ➋, so the Dispose()
    method we implemented in the NessusSession class will be automatically called
    when the using block ends. This logs out the NessusSession, invalidating the authentication
    token we were given by Nessus.
  id: totrans-135
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: NessusSession 是在使用语句 ➋的上下文中创建的，因此我们在 NessusSession 类中实现的 Dispose() 方法将在 using
    块结束时自动调用。这会注销 NessusSession，失效我们从 Nessus 获取的认证令牌。
- en: Running this code should print an authentication token similar to the one in
    [Listing 5-5](#filepos440028).
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 运行此代码应该会打印出一个类似于 [Listing 5-5](#filepos440028) 中的认证令牌。
- en: $ mono ./ch5_automating_nessus.exe
  id: totrans-137
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: $ mono ./ch5_automating_nessus.exe
- en: 'Your authentication token is: 19daad2f2fca99b2a2d48febb2424966a99727c19252966a'
  id: totrans-138
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 您的认证令牌是：19daad2f2fca99b2a2d48febb2424966a99727c19252966a
- en: $
  id: totrans-139
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: $
- en: 'Listing 5-5: Running the  NessusSession  test code to print the authentication
    token'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 'Listing 5-5: 运行NessusSession测试代码以打印认证令牌'
- en: The NessusManager Class
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: NessusManager类
- en: '[Listing 5-6](#filepos442874) shows the methods we need to implement in the
    NessusManager class, which will wrap common API calls and functionality for Nessus
    in easy-to-use methods we can call later.'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: '[Listing 5-6](#filepos442874)展示了我们需要在NessusManager类中实现的方法，这些方法将为Nessus的常见API调用和功能提供易于使用的方法，我们稍后可以调用它们。'
- en: 'public class NessusManager : ➊IDisposable'
  id: totrans-143
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 'public class NessusManager : ➊IDisposable'
- en: '{'
  id: totrans-144
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '{'
- en: NessusSession _session;
  id: totrans-145
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: NessusSession _session;
- en: public NessusManager(NessusSession session)
  id: totrans-146
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: public NessusManager(NessusSession session)
- en: '{'
  id: totrans-147
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '{'
- en: _session = ➋session;
  id: totrans-148
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: _session = ➋session;
- en: '}'
  id: totrans-149
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '}'
- en: ''
  id: totrans-150
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: public JObject GetScanPolicies()
  id: totrans-151
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: public JObject GetScanPolicies()
- en: '{'
  id: totrans-152
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '{'
- en: return _session.➌MakeRequest("GET", "/editor/policy/templates", null, _session.Token);
  id: totrans-153
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: return _session.➌MakeRequest("GET", "/editor/policy/templates", null, _session.Token);
- en: '}'
  id: totrans-154
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '}'
- en: ''
  id: totrans-155
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: public JObject CreateScan(string policyID, string cidr, string name, string
    description)
  id: totrans-156
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: public JObject CreateScan(string policyID, string cidr, string name, string
    description)
- en: '{'
  id: totrans-157
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '{'
- en: JObject data = ➍new JObject();
  id: totrans-158
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: JObject data = ➍new JObject();
- en: data["uuid"] = policyID;
  id: totrans-159
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: data["uuid"] = policyID;
- en: data["settings"] = new JObject();
  id: totrans-160
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: data["settings"] = new JObject();
- en: data["settings"]["name"] = name;
  id: totrans-161
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: data["settings"]["name"] = name;
- en: data["settings"]["text_targets"] = cidr;
  id: totrans-162
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: data["settings"]["text_targets"] = cidr;
- en: data["settings"]["description"] = description;
  id: totrans-163
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: data["settings"]["description"] = description;
- en: ''
  id: totrans-164
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: return _session.➎MakeRequest("POST", "/scans", data, _session.Token);
  id: totrans-165
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: return _session.➎MakeRequest("POST", "/scans", data, _session.Token);
- en: '}'
  id: totrans-166
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '}'
- en: ''
  id: totrans-167
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: public JObject StartScan(int scanID)
  id: totrans-168
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: public JObject StartScan(int scanID)
- en: '{'
  id: totrans-169
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '{'
- en: return _session.MakeRequest("POST", "/scans/" + scanID + "/launch", null, _session.Token);
  id: totrans-170
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: return _session.MakeRequest("POST", "/scans/" + scanID + "/launch", null, _session.Token);
- en: '}'
  id: totrans-171
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '}'
- en: ''
  id: totrans-172
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: public JObject ➏GetScan(int scanID)
  id: totrans-173
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: public JObject ➏GetScan(int scanID)
- en: '{'
  id: totrans-174
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '{'
- en: return _session.MakeRequest("GET", "/scans/" + scanID, null, _session.Token);
  id: totrans-175
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: return _session.MakeRequest("GET", "/scans/" + scanID, null, _session.Token);
- en: '}'
  id: totrans-176
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '}'
- en: ''
  id: totrans-177
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: public void Dispose()
  id: totrans-178
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: public void Dispose()
- en: '{'
  id: totrans-179
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '{'
- en: if (_session.Authenticated)
  id: totrans-180
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: if (_session.Authenticated)
- en: _session.➐LogOut();
  id: totrans-181
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: _session.➐LogOut();
- en: _session = null;
  id: totrans-182
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: _session = null;
- en: '}'
  id: totrans-183
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '}'
- en: '}'
  id: totrans-184
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '}'
- en: 'Listing 5-6: The  NessusManager  class'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 'Listing 5-6: NessusManager类'
- en: The NessusManager class implements IDisposable ➊ so that we can use NessusSession
    to interact with the Nessus API and log out automatically if necessary. The NessusManager
    constructor takes one argument, a NessusSession, and assigns it to the private
    _session variable ➋, which any method in NessusManager can access.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: NessusManager类实现了IDisposable ➊，这样我们就可以使用NessusSession与Nessus API进行交互，并在必要时自动注销。NessusManager的构造函数接受一个参数——一个NessusSession，并将其分配给私有的_session变量
    ➋，NessusManager中的任何方法都可以访问该变量。
- en: Nessus is preconfigured with a few different scan policies. We’ll sort through
    these policies using GetScanPolicies() and MakeRequest() ➌ to retrieve a list
    of policies and their IDs from the /editor/policy/templates URI. The first argument
    to CreateScan() is the scan policy ID, and the second is the CIDR range to scan.
    (You can also enter a newline-delimited string of IP addresses in this argument.)
    The third and fourth arguments can be used to hold a name and description of the
    scan, respectively. We’ll use a unique Guid (globally unique ID, long strings
    of unique letters and numbers) for each names since our scan is only for testing
    purposes, but as you build more sophisticated automation, you may want to adopt
    a system of naming scans in order to make them easier to track. We use the arguments
    passed to CreateScan() to create a new JObject ➍ containing the settings for the
    scan to create. We then pass this JObject to MakeRequest() ➎, which will send
    a POST request to the /scans URI and return all relevant information about the
    particular scan, showing that we successfully created (but did not start!) a scan.
    We can use the scan ID to report the status of a scan.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: Nessus预配置了几种不同的扫描策略。我们将使用GetScanPolicies()和MakeRequest() ➌来从/editor/policy/templates
    URI中检索策略及其ID的列表。CreateScan()的第一个参数是扫描策略ID，第二个参数是要扫描的CIDR范围。（你也可以在此参数中输入一个以换行符分隔的IP地址字符串。）第三个和第四个参数可以分别用于存储扫描的名称和描述。由于我们的扫描仅用于测试目的，我们将为每个名称使用唯一的Guid（全球唯一标识符，长串唯一的字母和数字），但随着你构建更复杂的自动化流程，可能需要采用一种命名扫描的系统，以便更容易跟踪它们。我们使用传递给CreateScan()的参数创建一个新的JObject
    ➍，该对象包含要创建的扫描的设置。然后我们将这个JObject传递给MakeRequest() ➎，它将向/scans URI发送一个POST请求，并返回关于特定扫描的所有相关信息，显示我们成功创建了（但并未启动！）一个扫描。我们可以使用扫描ID来报告扫描的状态。
- en: Once we’ve created the scan with CreateScan(), we’ll pass its ID to the StartScan()
    method, which will create a POST request to the /scans/<scanID>/launch URI and
    return the JSON response telling us whether the scan was launched. We can use
    GetScan() ➏ to monitor the scan.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们使用CreateScan()创建了扫描，我们将把它的ID传递给StartScan()方法，该方法会创建一个POST请求到/scans/<scanID>/launch
    URI，并返回JSON响应，告诉我们扫描是否已启动。我们可以使用GetScan() ➏来监控扫描。
- en: To complete NessusManager, we implement Dispose() to log out of the session
    ➐ and then clean up by setting the _session variable to null.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 为了完成NessusManager的实现，我们实现Dispose()方法以注销会话 ➐，然后通过将_session变量设置为null来清理资源。
- en: Performing a Nessus Scan
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 执行Nessus扫描
- en: '[Listing 5-7](#filepos447170) shows how to begin using NessusSession and NessusManager
    to run a scan and print the results.'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: '[Listing 5-7](#filepos447170) 显示了如何开始使用NessusSession和NessusManager来运行扫描并打印结果。'
- en: public static void Main(string[] args)
  id: totrans-192
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: public static void Main(string[] args)
- en: '{'
  id: totrans-193
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '{'
- en: ServicePointManager.➊ServerCertificateValidationCallback =
  id: totrans-194
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ServicePointManager.➊ServerCertificateValidationCallback =
- en: (Object obj, X509Certificate certificate, X509Chain chain, SslPolicyErrors errors)
    => true;
  id: totrans-195
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: (Object obj, X509Certificate certificate, X509Chain chain, SslPolicyErrors errors)
    => true;
- en: ''
  id: totrans-196
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: using (NessusSession session = ➋new NessusSession("192.168.1.14", "admin", "password"))
  id: totrans-197
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: using (NessusSession session = ➋new NessusSession("192.168.1.14", "admin", "password"))
- en: '{'
  id: totrans-198
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '{'
- en: using (NessusManager manager = new NessusManager(session))
  id: totrans-199
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: using (NessusManager manager = new NessusManager(session))
- en: '{'
  id: totrans-200
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '{'
- en: JObject policies = manager.➌GetScanPolicies();
  id: totrans-201
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: JObject policies = manager.➌GetScanPolicies();
- en: string discoveryPolicyID = string.Empty;
  id: totrans-202
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: string discoveryPolicyID = string.Empty;
- en: foreach (JObject template in policies["templates"])
  id: totrans-203
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: foreach (JObject template in policies["templates"])
- en: '{'
  id: totrans-204
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '{'
- en: if (template ["name"].Value<string>() == ➍"basic")
  id: totrans-205
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: if (template ["name"].Value<string>() == ➍"basic")
- en: discoveryPolicyID = template ["uuid"].Value<string>();
  id: totrans-206
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: discoveryPolicyID = template ["uuid"].Value<string>();
- en: '}'
  id: totrans-207
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '}'
- en: 'Listing 5-7: Retrieving the list of scan policies so we can start a scan with
    the correct scan policy'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 'Listing 5-7: 获取扫描策略列表，以便我们使用正确的扫描策略开始扫描'
- en: We begin our automation by first disabling SSL certificate verification (because
    the Nessus server’s SSL keys are self-signed, they will fail verification) by
    assigning an anonymous method that only returns true to the ServerCertificateValidationCallback
    ➊. This callback is used by the HTTP networking libraries to verify an SSL certificate.
    Simply returning true causes any SSL certificate to be accepted. Next, we create
    a NessusSession ➋ and pass it the IP address of the Nessus server as well as the
    username and password for the Nessus API. If authentication succeeds, we pass
    the new session to another NessusManager.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过首先禁用SSL证书验证来开始自动化（因为Nessus服务器的SSL密钥是自签名的，所以它们会验证失败），方法是将一个仅返回true的匿名方法分配给ServerCertificateValidationCallback
    ➊。此回调由HTTP网络库用于验证SSL证书。仅返回true会导致接受任何SSL证书。接下来，我们创建一个NessusSession ➋并传入Nessus服务器的IP地址以及Nessus
    API的用户名和密码。如果认证成功，我们将新的会话传递给另一个NessusManager。
- en: Once we have an authenticated session and a manager, we can begin interacting
    with the Nessus server. We first get a list of the scan policies available with
    GetScanPolicies() ➌ and then create an empty string with string.Empty to hold
    the scan policy ID for the basic scan policy and iterate over the scan policy
    templates. As we iterate over the scan policies, we check whether the name of
    the current scan policy equals the string basic ➍; this is a good starting point
    for a scan policy that allows us to perform a small set of unauthenticated checks
    against hosts on the network. We store the ID for the basic scan policy for later
    use.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们获得了认证会话和管理器，就可以开始与Nessus服务器进行交互。我们首先通过GetScanPolicies() ➌获取可用的扫描策略列表，然后使用string.Empty创建一个空字符串来存储基础扫描策略的扫描策略ID，并遍历扫描策略模板。在遍历扫描策略时，我们检查当前扫描策略的名称是否等于字符串basic
    ➍；这是一个很好的起点，用于执行一组小规模的未认证检查，针对网络中的主机。我们将基础扫描策略的ID存储起来，以便稍后使用。
- en: Now to create and start the scan with the basic scan policy ID, as shown in
    [Listing 5-8](#filepos450210).
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，使用基础扫描策略ID创建并启动扫描，如[Listing 5-8](#filepos450210)所示。
- en: JObject scan = manager.➊CreateScan(discoveryPolicyID, "192.168.1.31",
  id: totrans-212
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: JObject scan = manager.➊CreateScan(discoveryPolicyID, "192.168.1.31",
- en: '"Network Scan", "A simple scan of a single IP address.");'
  id: totrans-213
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '"Network Scan", "对单个IP地址进行简单扫描。");'
- en: int scanID = ➋scan["scan"]["id"].Value<int>();
  id: totrans-214
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: int scanID = ➋scan["scan"]["id"].Value<int>();
- en: manager.➌StartScan(scanID);
  id: totrans-215
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: manager.➌StartScan(scanID);
- en: JObject scanStatus = manager.GetScan(scanID);
  id: totrans-216
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: JObject scanStatus = manager.GetScan(scanID);
- en: ''
  id: totrans-217
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: while (scanStatus["info"]["status"].Value<string>() != ➍"completed")
  id: totrans-218
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: while (scanStatus["info"]["status"].Value<string>() != ➍"completed")
- en: '{'
  id: totrans-219
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '{'
- en: 'Console.WriteLine("Scan status: " + scanStatus["info"]'
  id: totrans-220
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: Console.WriteLine("扫描状态： " + scanStatus["info"]
- en: '["status"].Value<string>());'
  id: totrans-221
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '["status"].Value<string>());'
- en: Thread.Sleep(5000);
  id: totrans-222
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: Thread.Sleep(5000);
- en: scanStatus = manager.➎GetScan(scanID);
  id: totrans-223
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: scanStatus = manager.➎GetScan(scanID);
- en: '}'
  id: totrans-224
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '}'
- en: ''
  id: totrans-225
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: foreach (JObject vuln in scanStatus["vulnerabilities"])
  id: totrans-226
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: foreach (JObject vuln in scanStatus["vulnerabilities"])
- en: Console.WriteLine(vuln.ToString());
  id: totrans-227
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: Console.WriteLine(vuln.ToString());
- en: '}'
  id: totrans-228
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '}'
- en: '}'
  id: totrans-229
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '}'
- en: 'Listing 5-8: The second half of the Nessus automation  Main()  method'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 清单 5-8：Nessus 自动化 Main() 方法的后半部分
- en: At ➊, we call CreateScan(), passing in a policy ID, IP address, name, and description
    of the method, and we store its response in a JObject. We then pull the scan ID
    out of the JObject ➋ so that we can pass the scan ID to StartScan() ➌ to start
    the scan.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 在 ➊ 处，我们调用 CreateScan()，传入策略 ID、IP 地址、名称和方法描述，并将其响应存储在 JObject 中。然后，我们从 JObject
    中提取扫描 ID ➋，以便将扫描 ID 传递给 StartScan() ➌ 开始扫描。
- en: We use GetScan() to monitor the scan by passing it the scan ID, storing the
    result in a JObject and using a while loop to continually check whether the current
    scan status has completed ➍. If the scan has not completed, we print its status,
    sleep for five seconds, and call GetScan() ➎ again. The loop repeats until the
    scan reports completed, at which point we iterate over and print each vulnerability
    returned by GetScan() in a foreach loop, which may look something like [Listing
    5-9](#filepos453341). A scan might take several minutes to complete, depending
    on your computer and network speed.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用 GetScan() 来监控扫描，传入扫描 ID，将结果存储在 JObject 中，并使用 while 循环不断检查当前扫描状态是否已完成 ➍。如果扫描未完成，我们打印其状态，等待五秒钟，然后再次调用
    GetScan() ➎。该循环将重复，直到扫描报告完成，此时我们会遍历并打印 GetScan() 返回的每个漏洞，使用 foreach 循环，这可能类似于
    [清单 5-9](#filepos453341)。根据你的计算机和网络速度，扫描可能需要几分钟才能完成。
- en: $ mono ch5_automating_nessus.exe
  id: totrans-233
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: $ mono ch5_automating_nessus.exe
- en: 'Scan status: running'
  id: totrans-234
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 扫描状态：运行中
- en: 'Scan status: running'
  id: totrans-235
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 扫描状态：运行中
- en: 'Scan status: running'
  id: totrans-236
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 扫描状态：运行中
- en: --snip--
  id: totrans-237
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: --省略--
- en: '{'
  id: totrans-238
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '{'
- en: '"count": 1,'
  id: totrans-239
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '"count": 1,'
- en: '"plugin_name": ➊"SSL Version 2 and 3 Protocol Detection",'
  id: totrans-240
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '"plugin_name": ➊"SSL 版本 2 和 3 协议检测",'
- en: '"vuln_index": 62,'
  id: totrans-241
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '"vuln_index": 62,'
- en: '"severity": 2,'
  id: totrans-242
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '"severity": 2,'
- en: '"plugin_id": 20007,'
  id: totrans-243
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '"plugin_id": 20007,'
- en: '"severity_index": 30,'
  id: totrans-244
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '"severity_index": 30,'
- en: '"plugin_family": "Service detection"'
  id: totrans-245
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '"plugin_family": "服务检测"'
- en: '}'
  id: totrans-246
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '}'
- en: '{'
  id: totrans-247
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '{'
- en: '"count": 1,'
  id: totrans-248
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '"count": 1,'
- en: '"plugin_name": ➋"SSL Self-Signed Certificate",'
  id: totrans-249
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '"plugin_name": ➋"SSL 自签名证书",'
- en: '"vuln_index": 61,'
  id: totrans-250
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '"vuln_index": 61,'
- en: '"severity": 2,'
  id: totrans-251
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '"severity": 2,'
- en: '"plugin_id": 57582,'
  id: totrans-252
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '"plugin_id": 57582,'
- en: '"severity_index": 31,'
  id: totrans-253
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '"severity_index": 31,'
- en: '"plugin_family": "General"'
  id: totrans-254
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '"plugin_family": "通用"'
- en: '}'
  id: totrans-255
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '}'
- en: '{'
  id: totrans-256
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '{'
- en: '"count": 1,'
  id: totrans-257
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '"count": 1,'
- en: '"plugin_name": "SSL Certificate Cannot Be Trusted",'
  id: totrans-258
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '"plugin_name": "SSL 证书无法信任",'
- en: '"vuln_index": 56,'
  id: totrans-259
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '"vuln_index": 56,'
- en: '"severity": 2,'
  id: totrans-260
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '"severity": 2,'
- en: '"plugin_id": 51192,'
  id: totrans-261
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '"plugin_id": 51192,'
- en: '"severity_index": 32,'
  id: totrans-262
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '"severity_index": 32,'
- en: '"plugin_family": "General"'
  id: totrans-263
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '"plugin_family": "通用"'
- en: '}'
  id: totrans-264
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '}'
- en: 'Listing 5-9: Partial output from an automated scan using the Nessus vulnerability
    scanner'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 清单 5-9：使用 Nessus 漏洞扫描器进行自动化扫描的部分输出
- en: The scan results tell us that the target is using weak SSL modes (protocols
    2 and 3) ➊ and a self-signed SSL certificate on an open port ➋. We can now ensure
    that the server’s SSL configurations are using fully up-to-date SSL modes and
    then disable the weak modes (or disable the service altogether). Once finished,
    we can rerun our automated scan to ensure that Nessus no longer reports any weak
    SSL modes in use.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 扫描结果告诉我们，目标使用了弱的 SSL 模式（协议 2 和 3） ➊，以及在开放端口上使用了自签名的 SSL 证书 ➋。我们现在可以确保服务器的 SSL
    配置使用了完全最新的 SSL 模式，然后禁用弱模式（或完全禁用该服务）。完成后，我们可以重新运行自动化扫描，确保 Nessus 不再报告使用任何弱 SSL
    模式。
- en: Conclusion
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 结论
- en: This chapter has shown you how to automate various aspects of the Nessus API
    in order to complete an unauthenticated scan of a network-attached device. In
    order to achieve this, we needed to be able to send API requests to the Nessus
    HTTP server. To do so, we created the NessusSession class; then, once we were
    able to authenticate with Nessus, we created the NessusManager class to create,
    run, and report the results of a scan. We wrapped everything with code that used
    these classes to drive the Nessus API automatically based on user-provided information.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 本章向你展示了如何自动化 Nessus API 的各个方面，以完成对网络连接设备的无认证扫描。为了实现这一点，我们需要能够向 Nessus HTTP 服务器发送
    API 请求。为此，我们创建了 NessusSession 类；然后，一旦能够与 Nessus 进行认证，我们创建了 NessusManager 类来创建、运行并报告扫描结果。我们用代码封装了一切，使用这些类基于用户提供的信息自动驱动
    Nessus API。
- en: This isn’t the extent of the features Nessus provides, and you’ll find more
    detail in the Nessus API documentation. Many organizations require performing
    authenticated scans against hosts on the network in order to get full patch listings
    to determine host health, and upgrading our automation to handle this would be
    a good exercise.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 这并不是Nessus所提供功能的全部，你可以在Nessus API文档中找到更多详细信息。许多组织需要对网络上的主机执行认证扫描，以获取完整的补丁列表，从而判断主机的健康状况，升级我们的自动化以处理这一需求将是一个很好的练习。
