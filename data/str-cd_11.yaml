- en: '8'
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '8'
- en: FRACTRAN
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: FRACTRAN
- en: '![Image](Images/common01.jpg)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Images/common01.jpg)'
- en: 'John Conway (1937–2020) was a British mathematician, most famous to the general
    public for his Game of Life (see *[https://playgameoflife.com/](https://playgameoflife.com/)*),
    but equally famous to his fellow mathematicians for his many contributions to
    a wide variety of mathematical disciplines. In this chapter, we’ll examine another
    of Conway’s contributions, one that isn’t as well known as his Game of Life, but
    is perfect for our purposes: FRACTRAN. We’ll start with the specification of FRACTRAN,
    build it, and, lastly, use it to implement basic programs for addition, subtraction,
    and multiplication, among other tasks. After that, we’ll end with a discussion,
    like always.'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 约翰·康威（John Conway，1937–2020）是英国数学家，对公众最著名的是他的《生命游戏》（见* [https://playgameoflife.com/](https://playgameoflife.com/)*），但在数学界，他因对广泛的数学学科做出许多贡献而同样享有盛誉。在本章中，我们将探讨康威的另一个贡献，尽管这个贡献不像《生命游戏》那样为人所知，但它非常适合我们的目的：FRACTRAN。我们将从FRACTRAN的规格开始，构建它，最后使用它来实现加法、减法和乘法等基本程序。之后，我们将像往常一样以讨论结束。
- en: Be warned that there’s math ahead, at the level of fractions, prime numbers,
    and big integers. FRACTRAN is the most mathematical esolang we’ll encounter. If
    you wish, skip this chapter and move on to the remaining esolangs. However, if
    you do, please don’t forget to come back. FRACTRAN is worth the struggle.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，接下来将涉及数学内容，涵盖分数、素数和大整数等知识。FRACTRAN是我们遇到的最具数学性的esolang。如果你愿意，可以跳过本章，继续阅读剩下的esolang。然而，如果你这么做，请不要忘记回来看。FRACTRAN是值得我们努力学习的。
- en: '**The FRACTRAN Specification**'
  id: totrans-5
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**FRACTRAN规格**'
- en: 'FRACTRAN’s specification is straightforward. In fact, it’s almost as straightforward
    as ABC’s. Here’s the full specification for FRACTRAN:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: FRACTRAN的规格很简单。事实上，它几乎和ABC的简单程度一样。以下是FRACTRAN的完整规格：
- en: '[PRE0]'
  id: totrans-7
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: FRACTRAN programs are a sequence of integers and nothing more. An initial integer
    is tested against each fraction in the program, in order. If the product of the
    integer and the fraction is itself an integer, that product becomes the new integer
    and the program loops from the beginning. If the program ever reaches the state
    where no product results in a new integer, the program ends. That’s it.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: FRACTRAN程序是一个整数序列，仅此而已。一个初始整数按顺序与程序中的每个分数进行测试。如果该整数与分数的积本身是一个整数，那么这个积将成为新的整数，程序将从头开始循环。如果程序进入一种状态，其中没有任何积能得到一个新整数，程序就结束了。就是这么简单。
- en: As the specification is simple, so are the implementations. Let’s write two
    FRACTRAN interpreters because it’s fun and it will expose us to another programming
    language, one that is well suited to this particular task.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 由于规格简单，实现也同样简单。让我们写两个FRACTRAN解释器，因为这很有趣，而且它会让我们接触到另一种编程语言，一种非常适合这个特定任务的语言。
- en: '**A Tale of Two Implementations**'
  id: totrans-10
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**两种实现的故事**'
- en: The specification above includes the phrase *arbitrary precision*. A FRACTRAN
    implementation must use fractions where the numerator and denominator are integers
    of any size, even if that size has thousands of digits.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 上面的规格包括了*任意精度*这一短语。一个FRACTRAN实现必须使用分数，其中分子和分母是任意大小的整数，即使这个大小有数千位数字。
- en: Most programming languages don’t natively support arbitrary-precision integers,
    let alone fractions (rationals). However, Scheme does. Scheme is a dialect of
    Lisp, which we first mentioned in [Chapter 1](ch01.xhtml#ch01). Not only does
    Scheme support arbitrary-precision integers, it also natively supports rationals.
    Therefore, Scheme is ideally suited to implementing FRACTRAN.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数编程语言并不原生支持任意精度整数，更不用说分数（有理数）了。然而，Scheme支持。Scheme是Lisp的一种方言，我们在[第1章](ch01.xhtml#ch01)中首次提到过它。Scheme不仅支持任意精度整数，还原生支持有理数。因此，Scheme非常适合实现FRACTRAN。
- en: We’ve used Python fairly often throughout the book. Python also supports arbitrary-precision
    integers natively and has a rational arithmetic library module. So we’ll implement
    FRACTRAN in Python as well. The juxtaposition between the two implementations
    will be illustrative, and allow us to test each against the other to ensure our
    implementations are correct.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 在整本书中，我们已经相当频繁地使用了Python。Python也原生支持任意精度整数，并且有一个有理数算术库模块。因此，我们也将在Python中实现FRACTRAN。两种实现方式的对比将具有启发性，并使我们能够相互测试它们，以确保我们的实现是正确的。
- en: '***A Scheme Implementation***'
  id: totrans-14
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***Scheme实现***'
- en: 'The version of Scheme we’ll use is called Racket (*[https://racket-lang.org/](https://racket-lang.org/)*).
    It’s easy to install on Linux:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用的Scheme版本叫做Racket（*[https://racket-lang.org/](https://racket-lang.org/)*）。它在Linux上很容易安装：
- en: '[PRE1]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'See the Racket website to install macOS and Windows versions. Once installed,
    run Racket by entering racket at the command line:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 请访问 Racket 网站安装 macOS 和 Windows 版本。安装完成后，通过在命令行中输入 racket 来运行 Racket：
- en: '[PRE2]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Your version should be at least 6.11 or greater. Like Python and Forth, Racket
    enters an interactive mode if no file is given to it. For now, just quit by entering
    (exit); note that the parentheses are required.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 你的版本应该至少是 6.11 或更高版本。像 Python 和 Forth 一样，如果没有给它提供文件，Racket 会进入交互模式。目前，只需通过输入
    (exit) 退出；注意，括号是必须的。
- en: We certainly don’t have the space here to give even a short tutorial on Scheme
    (Racket). The genuinely motivated will find all they need on the Racket website.
    Instead, we’ll walk through our implementation. [Listing 8-1](ch08.xhtml#ch08list1)
    shows the code.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 我们这里确实没有足够的空间来提供一个简短的 Scheme（Racket）教程。真正有兴趣的人可以在 Racket 网站上找到所有需要的信息。相反，我们将走一遍我们的实现过程。[列表
    8-1](ch08.xhtml#ch08list1) 显示了代码。
- en: '[PRE3]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '*Listing 8-1: FRACTRAN in Racket*'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 8-1：Racket 中的 FRACTRAN*'
- en: The Racket implementation of FRACTRAN is compact. The first four lines do nothing
    more than parse the command line. In Racket, `define` assigns a value. We use
    `argv` to avoid duplicating the call to `current-command-line` `-arguments`. Racket
    returns the command line arguments as a vector, so `(vector` `-ref argv 0)` is
    equivalent to `argv[0]` in other languages. Racket is a prefix language, meaning
    that function names come first, followed by the arguments with parentheses around
    everything. We’ll see below how FRACTRAN code is stored. We chose a format friendly
    to Racket so we can add comments easily. The `file->list` function reads the code
    and returns a list of the fractions. The next argument is the starting integer,
    which Racket puts in `num`. The last argument, `trace`, is a 0 or 1 flag indicating
    whether to output only the final integer or all intermediate integers. We’ll learn
    what that means in a bit.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: Racket 实现的 FRACTRAN 非常简洁。前四行只是解析命令行。在 Racket 中，`define` 用于赋值。我们使用 `argv` 来避免重复调用
    `current-command-line` `-arguments`。Racket 将命令行参数返回为一个向量，因此 `(vector -ref argv
    0)` 相当于其他语言中的 `argv[0]`。Racket 是一种前缀语言，这意味着函数名在前，后面跟着带括号的参数。下面我们将看到 FRACTRAN 代码是如何存储的。我们选择了一种对
    Racket 友好的格式，这样我们可以轻松添加注释。`file->list` 函数读取代码并返回一个包含分数的列表。下一个参数是起始整数，Racket 将其放入
    `num`。最后一个参数 `trace` 是一个 0 或 1 的标志，指示是否仅输出最终整数或所有中间整数。稍后我们将了解它的含义。
- en: All of FRACTRAN is a single function that takes no arguments ➊. It consists
    of a `do` loop, which is similar to a `for` loop in other languages, but is configured
    to run forever ➋. The loop counter is `i`, which we use to get the `i`th fraction
    from `prog`.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: FRACTRAN 完整代码是一个不接受任何参数的单一函数 ➊。它由一个 `do` 循环组成，类似于其他语言中的 `for` 循环，但它被配置为无限运行
    ➋。循环计数器是 `i`，我们用它来从 `prog` 中获取第 `i` 个分数。
- en: 'The body of the `do` loop has two main parts: a `when` function ➌ and a `let`
    function ➍. A `when` function checks whether a given condition is true, and if
    so, executes all the code in the body. This `when` checks to see if the loop counter
    matches the length of the program, that is, the number of fractions. If so, the
    program ends, outputting the final value of `num` if `trace` is 0.'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: '`do` 循环的主体有两个主要部分：一个 `when` 函数 ➌ 和一个 `let` 函数 ➍。`when` 函数检查给定条件是否为真，如果为真，则执行主体中的所有代码。这个
    `when` 检查循环计数器是否与程序的长度匹配，也就是分数的数量。如果匹配，程序结束，并且如果 `trace` 为 0，输出 `num` 的最终值。'
- en: 'The `let` function creates a local environment assigning `(* num (list-ref`
    `prog i))` to `n`. What is `(* num (list-ref prog i))`? It’s the current integer
    times the current fraction: `num*prog[i]`. The body of `let` is a single `when`
    ➎ function. The function `exact-integer?` is true when its argument, `n`, is an
    integer rather than a rational or a float. Recall that the fractions in `prog`
    are native Racket rational numbers. This is the condition we need to check. If
    true, we have a new integer, so the body of the `when` destructively sets `num`
    to the new value in `n` and modifies the loop counter by setting it to *–*1 so
    that the next iteration of the `do` begins again with 0\. Additionally, if `trace`
    is 1, the new integer is output. The program starts by calling `FRACTRAN` ➏.'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: '`let` 函数创建一个局部环境，将 `(* num (list-ref prog i))` 赋值给 `n`。`(* num (list-ref prog
    i))` 是什么？它是当前整数乘以当前分数：`num*prog[i]`。`let` 的主体是一个单一的 `when` ➎ 函数。函数 `exact-integer?`
    当其参数 `n` 是整数而非有理数或浮点数时返回 true。回想一下，`prog` 中的分数是原生的 Racket 有理数。这就是我们需要检查的条件。如果条件为真，我们就得到了一个新的整数，因此
    `when` 的主体会破坏性地将 `num` 设置为 `n` 的新值，并通过将循环计数器设置为 *–*1 来修改它，以便 `do` 的下一次迭代从 0 开始。另外，如果
    `trace` 为 1，新整数将被输出。程序通过调用 `FRACTRAN` ➏ 开始执行。'
- en: Now, let’s implement FRACTRAN in Python.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们用 Python 实现 FRACTRAN。
- en: '***A Python Implementation***'
  id: totrans-28
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***一个 Python 实现***'
- en: The Racket version of FRACTRAN was straightforward, at least after learning
    to interpret Racket’s prefix approach to everything. Our Python implementation
    is longer, but it’s likely more familiar. Racket gave us arbitrary-precision integers,
    and Python gives us those, too. Racket also gave us rational arithmetic, which
    is something Python does not have out of the box, but does support via the `fractions`
    library module.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: FRACTRAN 的 Racket 版本很简单，至少在学会理解 Racket 所有内容的前缀方法之后。我们的 Python 实现更长，但可能更熟悉。Racket
    给我们提供了任意精度的整数，而 Python 也给我们提供了这些。Racket 还提供了有理数算术，这是 Python 默认没有的，但通过 `fractions`
    库模块可以支持。
- en: Our Python implementation mimics the Racket code in [Listing 8-1](ch08.xhtml#ch08list1).
    The code we’ll use is shown in [Listing 8-2](ch08.xhtml#ch08list2).
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的 Python 实现模仿了 [清单 8-1](ch08.xhtml#ch08list1) 中的 Racket 代码。我们将使用的代码展示在 [清单
    8-2](ch08.xhtml#ch08list2) 中。
- en: '[PRE4]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '*Listing 8-2: FRACTRAN in Python*'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 8-2: Python 中的 FRACTRAN*'
- en: '[Listing 8-2](ch08.xhtml#ch08list2) shows the body of `main`. *FRACTRAN.py*
    uses the expected Python convention of running from `main` if not imported.'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: '[清单 8-2](ch08.xhtml#ch08list2) 显示了 `main` 函数的主体。*FRACTRAN.py* 使用了预期的 Python
    规范：如果没有被导入，程序从 `main` 函数开始执行。'
- en: 'FRACTRAN in Python expects the same arguments as the Racket version: the name
    of the FRACTRAN program, the initial integer value, and whether to output every
    integer change. Unlike the Racket version, the final argument is optional and
    defaults to 0 if not present.'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: Python 版本的 FRACTRAN 期望与 Racket 版本相同的参数：FRACTRAN 程序的名称、初始整数值以及是否输出每次整数变化。与 Racket
    版本不同的是，最后一个参数是可选的，如果没有提供则默认为 0。
- en: The code operates like the Racket version. The command line is parsed to set
    the initial integer as a rational ➊, followed by loading the FRACTRAN code via
    `LoadProgram` ➋. We won’t show `LoadProgram` here, but it loads the file and returns
    the fractions as a list of `Fraction` objects. Do read through it.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 代码的运行方式与 Racket 版本相似。命令行会被解析，首先设置初始整数为一个有理数 ➊，然后通过 `LoadProgram` 加载 FRACTRAN
    代码 ➋。我们这里不展示 `LoadProgram`，但它会加载文件并将分数作为 `Fraction` 对象的列表返回。一定要阅读它。
- en: The `while` loop runs until all fractions in `p` are exhausted ➌. The current
    integer (`n`) is multiplied by the current fraction (`p[k]`) ➍. If the result
    is an integer, meaning the denominator is 1, we have a new `n`. Thus, `n` is updated
    and printed if `m = 1`. Lastly, as in the Racket version, the loop counter is
    reset so the fractions are scanned from the beginning again (`k = -1`). When the
    loop ends, the final value of `n` is printed if it has not already been printed
    above.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: '`while` 循环会一直执行，直到 `p` 中的所有分数都被耗尽 ➌。当前整数（`n`）会与当前分数（`p[k]`）相乘 ➍。如果结果是整数，意味着分母是
    1，我们就得到了一个新的 `n`。因此，`n` 会被更新，并且如果 `m = 1`，会被打印出来。最后，与 Racket 版本一样，循环计数器会被重置，以便从头开始扫描分数（`k
    = -1`）。当循环结束时，`n` 的最终值如果还没有被打印出来，则会被打印。'
- en: We now have two implementations of FRACTRAN ready to go. Why two? To illustrate
    that different programming languages require different thought processes to arrive
    at the same endpoint. This is a book on programming languages, after all. Now,
    lets put them through their paces.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们已经准备好两个 FRACTRAN 实现。为什么是两个？为了说明不同的编程语言需要不同的思维方式才能达到相同的目标。毕竟这是一本关于编程语言的书。现在，让我们开始测试它们的表现。
- en: '**Using FRACTRAN**'
  id: totrans-38
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**使用 FRACTRAN**'
- en: 'The simplest FRACTRAN program is the single fraction, 3/2\. It’s in the file
    *add.frac*. Let’s run it. We won’t understand the output just yet, but it will
    make sense eventually. Try the following:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 最简单的 FRACTRAN 程序是单一的分数 3/2，它在文件 *add.frac* 中。让我们运行它。我们暂时还不会理解输出，但最终会明白的。试试以下内容：
- en: '[PRE5]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'To test the Racket version, create a shell script named *FRACTRAN* with the
    following line, which wraps the command line Racket expects:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 要测试 Racket 版本，创建一个名为 *FRACTRAN* 的 shell 脚本，并在其中添加以下行，包装 Racket 所期望的命令行：
- en: '[PRE6]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Lastly, make *FRACTRAN* executable by typing chmod a+x FRACTRAN. Let’s test
    the Racket version using *add.frac*. The output should match the Python version
    just shown.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，通过输入 `chmod a+x FRACTRAN` 来使 *FRACTRAN* 可执行。让我们使用 *add.frac* 测试 Racket 版本。输出应该与刚才显示的
    Python 版本一致。
- en: '[PRE7]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The output matches the Python version, so our FRACTRAN implementations are working;
    however, we don’t yet understand what the output means. Let’s remedy that situation.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 输出与 Python 版本一致，所以我们的 FRACTRAN 实现是有效的；然而，我们还不明白输出的含义。让我们来解决这个问题。
- en: '**Understanding FRACTRAN**'
  id: totrans-46
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**理解 FRACTRAN**'
- en: 'FRACTRAN is perhaps the most elegant of all esolangs. It’s subtle, brilliant,
    strangely beautiful, and difficult. In this section, we’ll finally dive into the
    operation of FRACTRAN. We’ll start with *add.frac*, the version included with
    the book’s code. That version contains the following:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: FRACTRAN 可能是所有 esolang 中最优雅的语言。它微妙、 brilliant、奇异美丽且难以掌握。在这一部分，我们将深入探讨 FRACTRAN
    的运作方式。我们将从 *add.frac* 开始，这是书中代码版本中包含的一个示例。该版本包含以下内容：
- en: '[PRE8]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: It appears that *add.frac* adds two integers. Before learning how, we must make
    sense of the input and output comments. To do that, we must understand how FRACTRAN
    represents state.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 看起来 *add.frac* 是在进行两整数相加。在学习如何操作之前，我们必须理解输入和输出的注释。为此，我们必须理解 FRACTRAN 如何表示状态。
- en: FRACTRAN is a *register machine*, which is a hypothetical machine that manipulates
    an infinite set of registers. FRACTRAN uses Gödel numbering to represent its state,
    the value of the registers. So to understand FRACTRAN, we first must understand
    Gödel numbering.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: FRACTRAN 是一种 *寄存器机*，这是一种假设的机器，它操作一个无限的寄存器集合。FRACTRAN 使用哥德尔编号来表示其状态，即寄存器的值。因此，要理解
    FRACTRAN，我们首先必须理解哥德尔编号。
- en: Kurt Gödel was a German-Austrian-American mathematician most famous for his
    *incompleteness theorem*, by which he proved that in any system of axioms capable
    of describing mathematics with natural numbers, there are true statements that
    cannot be proved from the axioms. The incompleteness theorem sounded the death
    knell of early 20th-century attempts to put all of mathematics on rigorous footing.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 库尔特·哥德尔是德国-奥地利-美国的数学家，以其 *不完备性定理* 最为著名，凭此定理他证明了在任何能够用自然数描述数学的公理系统中，存在无法从公理中证明的真实命题。不完备性定理为20世纪初将整个数学体系放在严谨基础上的尝试敲响了丧钟。
- en: 'As part of his incompleteness theorem, Gödel made use of *Gödel numbering*,
    which itself makes use of the fact that all integers can be expressed as the product
    of a unique set of prime numbers: *prime factorization*. For example, the prime
    factorization of 88 is 2³11¹, whereas the prime factorization of 68,600 is 2³5²7³.'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 作为其不完备性定理的一部分，哥德尔使用了 *哥德尔编号*，这本身利用了所有整数都可以表示为一组唯一质数的乘积这一事实：*质因数分解*。例如，88 的质因数分解是
    2³11¹，而 68,600 的质因数分解是 2³5²7³。
- en: Gödel used his numbering scheme to represent the expressions and theorems of
    mathematics. FRACTRAN uses Gödel numbering to represent its state—the value of
    all registers—which must be positive or 0\. For example, if the state is 88 =
    2³11¹, the v2 register is 3, the v11 register is 1, and all other registers are
    0\. It’s customary to refer to the registers by their associated primes. Similarly,
    the state 68,600 = 2³5²7³ means v2 = 3, v5 = 2, and v7 = 3\. As there are an infinite
    number of primes, there are an infinite number of FRACTRAN registers with all
    possible states representable by a single integer. This single integer is the
    integer multiplied by each fraction.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 哥德尔使用他的编号方案来表示数学中的表达式和定理。FRACTRAN 使用哥德尔编号来表示其状态——即所有寄存器的值——这些值必须为正数或 0。例如，如果状态为
    88 = 2³11¹，那么 v2 寄存器的值为 3，v11 寄存器的值为 1，而所有其他寄存器的值为 0。通常，我们通过它们关联的质数来引用寄存器。类似地，状态
    68,600 = 2³5²7³ 表示 v2 = 3，v5 = 2，v7 = 3。由于质数是无限的，因此 FRACTRAN 寄存器也是无限的，每个可能的状态都可以通过单个整数来表示。这个单一整数就是与每个分数相乘的整数。
- en: Let’s review a bit before proceeding. We must follow the link between the integer
    FRACTRAN manipulates, prime factorization of a number, and state represented by
    registers holding specific values.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 在继续之前，让我们稍微回顾一下。我们必须理解整数 FRACTRAN 操作所涉及的链接，包括数字的质因数分解和由寄存器持有特定值表示的状态。
- en: 'Let’s start with registers holding values. At some point in a program, we may
    want register v17 to hold the value 12, that is, v17 = 12\. Again, registers are
    identified by their prime, and 17 is a prime. In FRACTRAN, setting v17 to 12 means
    raising 17 to the 12th power: 17¹2\. Likewise, if we want v3 = 7, we use 3⁷. So
    to set a FRACTRAN register to a value, we raise the corresponding prime to that
    power.'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从寄存器的值开始讲解。在程序的某个时刻，我们可能希望寄存器 v17 存储值 12，也就是 v17 = 12。再说一次，寄存器是通过它们的质数来标识的，17
    是一个质数。在 FRACTRAN 中，将 v17 设置为 12 意味着将 17 提升到 12 次方：17¹²。同样，如果我们希望 v3 = 7，我们使用 3⁷。因此，要设置
    FRACTRAN 寄存器的值，我们将相应的质数提升到那个幂次。
- en: The state of a FRACTRAN program is the current value of all of its registers.
    This is because FRACTRAN can manipulate only register values. To continue the
    example above, if v3 and v17 are the only nonzero registers, then the entire state
    of the FRACTRAN program is the product of 3⁷ and 17¹2, which is 3⁷17¹2 = 1,274,194,832,821,487,307\.
    This number is the integer FRACTRAN implementations use to represent the state.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: FRACTRAN程序的状态是其所有寄存器的当前值。这是因为FRACTRAN只能操作寄存器值。继续上面的例子，如果v3和v17是唯一非零寄存器，那么FRACTRAN程序的整个状态是3⁷和17¹²的乘积，即3⁷17¹²
    = 1,274,194,832,821,487,307\. 这个数字是FRACTRAN实现用来表示状态的整数。
- en: Conway’s insight was that all positive integers can be written as the product
    of a series of primes in only one way, that is, prime factorization. Therefore,
    the large integer in the previous paragraph represents the state where v3 = 7
    and v17 = 12 and all other registers are 0, and that is the *only* integer representing
    that state.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 康威的洞察是所有正整数只能以一种方式写成质因数的积，即质因数分解。因此，前一段中的大整数表示的状态是v3 = 7，v17 = 12，且所有其他寄存器为0，而这就是表示该状态的*唯一*整数。
- en: 'The fractions of a FRACTRAN program attempt to alter the state in two ways:
    by decrementing register values via canceling with the denominator and by incrementing
    register values via multiplying by the numerator. Only fractions where the denominator
    cancels completely “fire” are allowed to alter the program state.'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: FRACTRAN程序中的分数试图通过两种方式改变状态：通过与分母取消来递减寄存器值，和通过与分子相乘来递增寄存器值。只有分母完全取消的分数“触发”才允许改变程序状态。
- en: We’re now able to understand the input and output comments from *add.frac*.
    The expected input sets register v2 = *a* and v3 = *b*. When the program ends,
    register v3 = *a* + *b*. Therefore, if we want to add *a* + *b* = 3 + 2, the input
    given to FRACTRAN is
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在能够理解来自*add.frac*的输入和输出注释。期望的输入将寄存器v2设为*a*，将v3设为*b*。当程序结束时，寄存器v3 = *a* +
    *b*。因此，如果我们想要计算*a* + *b* = 3 + 2，给FRACTRAN的输入是
- en: 2*^a*3*^b* = 2³3² = 8(9) = 72
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 2*^a*3*^b* = 2³3² = 8(9) = 72
- en: which is the first test input above. If the input is 2³3², then the output is,
    according to the comments in *add.frac*, 3^(*a*+*b*) = 3^(3+2) = 3⁵ = 243, which
    is the first test output.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 这是上面的第一个测试输入。如果输入是2³3²，那么根据*add.frac*中的注释，输出是3^(*a*+*b*) = 3^(3+2) = 3⁵ = 243，这就是第一个测试输出。
- en: Let’s work through *add.frac* for the input 2³3² = 72 to see each step leading
    to the output. First, let’s run the code with trace on.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过*add.frac*来处理输入2³3² = 72，查看每个步骤如何得到输出。首先，让我们在启用trace的情况下运行代码。
- en: '[PRE9]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Trace tells us the program looped three times, changing the state from 72 →
    108 → 162 → 243\. Stepping through by hand gives
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: Trace告诉我们程序循环了三次，状态从72 → 108 → 162 → 243发生了变化。手动逐步执行得到
- en: '![Image](Images/f0224-01.jpg)'
  id: totrans-65
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Images/f0224-01.jpg)'
- en: 'Or, tracking the state: 2³3² → 2²3³ → 2¹3⁴ → 2⁰3⁵ = 3⁵.'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，追踪状态：2³3² → 2²3³ → 2¹3⁴ → 2⁰3⁵ = 3⁵。
- en: 'Following how the state changes, especially when writing the prime factorization
    of the state, shows us what FRACTRAN is doing. The add program is a single instruction:
    3/2\. Every time the state is multiplied by 3/2, the 2 in the denominator decrements
    v2, and the 3 in the numerator increments v3\. This is a general rule: the denominators
    are gatekeepers, so they decide whether the fraction “fires” or not. If the current
    integer contains factors of each prime factor of the denominator, to at least
    the power specified by the factor, then the denominator will be completely canceled
    and a new integer will be the result. This is what is meant by a fraction “firing.”
    When a fraction fires, it also decrements register values. Numerators, on the
    other hand, increment register values because they multiply the state integer.
    A FRACTRAN program is a sequence of operations applied to the state of the register
    machine.'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 跟踪状态的变化，尤其是在写出状态的质因数分解时，可以显示FRACTRAN在做什么。加法程序是一个单一指令：3/2\. 每次状态乘以3/2时，分母中的2会递减v2，分子中的3会递增v3\.
    这是一个通用规则：分母是门控器，它们决定分数是否“触发”。如果当前整数包含每个质因数的因子，并且至少达到因数指定的幂次，那么分母将被完全消除，结果将是一个新的整数。这就是所谓的分数“触发”。当分数触发时，它还会递减寄存器值。而分子则会递增寄存器值，因为它们乘以状态整数。FRACTRAN程序是应用于寄存器机状态的一系列操作。
- en: For addition, every multiplication of the state by 3/2 increments v3 and decrements
    v2 until v2 = 0, making the state no longer evenly divisible by 2\. According
    to the processing rule, the state should be multiplied by the next fraction in
    the list; however, there is no next fraction, so the program halts and outputs
    its state.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 对于加法，每次将状态乘以 3/2 时，都会使 v3 增加并使 v2 减少，直到 v2 = 0，使状态不再能被 2 整除。根据处理规则，状态应该乘以列表中的下一个分数；然而，列表中没有下一个分数，所以程序终止并输出其状态。
- en: It’s clever enough to realize that repeated multiplications by 3/2 when an integer
    has the form 2^(*a*)3^(*b*) will result in 3^(*a*+*b*), thereby adding *a* and
    *b*, but realizing that this is a general form of computation is brilliant. We’ll
    explore other FRACTRAN programs, but before we do, notice that 3/2 isn’t the only
    add program in FRACTRAN—2/3 works as well. Instead of decrementing v2 and incrementing
    v3, 2/3 decrements v3 and increments v2, leaving the sum in v2\. Let’s see that
    this is so.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 它足够聪明，能够意识到，当一个整数具有形式 2^(*a*)3^(*b*) 时，通过反复乘以 3/2，最终会得到 3^(*a*+*b*)，从而将 *a*
    和 *b* 相加，但意识到这是一个通用的计算形式是非常聪明的。我们将探索其他 FRACTRAN 程序，但在此之前，注意到 3/2 并不是 FRACTRAN
    中唯一的加法程序——2/3 也能起作用。与递减 v2 和递增 v3 不同，2/3 递减 v3 并递增 v2，将和保存在 v2 中。我们来看看这个是否成立。
- en: '[PRE10]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The file *add2.frac* contains `2/3`. The input is 2³3² = 72 as before. The state
    transitions are
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 文件*add2.frac*包含`2/3`。输入为之前的 2³3² = 72。状态转换如下：
- en: 2³3² = 72 → 2⁴3¹ = 48 → 2⁵3⁰ = 32 → end → 2⁵ = 32
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 2³3² = 72 → 2⁴3¹ = 48 → 2⁵3⁰ = 32 → 结束 → 2⁵ = 32
- en: proving that the sum is in v2.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 证明和显示和的结果在 v2 中。
- en: Let’s make sure we follow how FRACTRAN manipulates state. These examples are
    not full programs, but they show the way fractions operate on the state. For example,
    see Equations 8.1 through 8.5.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们确保跟随 FRACTRAN 如何操作状态。这些示例不是完整的程序，但它们展示了分数如何作用于状态。例如，参见方程 8.1 到 8.5。
- en: '![Image](Images/08eqa01.jpg)![Image](Images/08eqa02.jpg)![Image](Images/08eqa03.jpg)![Image](Images/08eqa04.jpg)![Image](Images/08eqa05.jpg)'
  id: totrans-75
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/08eqa01.jpg)![图片](Images/08eqa02.jpg)![图片](Images/08eqa03.jpg)![图片](Images/08eqa04.jpg)![图片](Images/08eqa05.jpg)'
- en: 'Equation 8.1 fires because the denominator contains v5 and v17, which are also
    present in the state. Notice that several things happen when the fraction fires:
    v5 goes down by 4, v17 goes down by o1ne, v7 goes up by 2 (from 0), and v11 goes
    up by 1\. Thus, the new state is v2 = 3, v5 = 3, v7 = 2, v11 = 1, and v17 = 1.'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 方程 8.1 被触发，因为分母包含 v5 和 v17，而这两个值也存在于状态中。注意，当分数被触发时会发生几件事：v5 减少 4，v17 减少 1，v7
    增加 2（从 0 开始），v11 增加 1。因此，新状态是 v2 = 3, v5 = 3, v7 = 2, v11 = 1, v17 = 1。
- en: For Equation 8.2, there is no factor of 13 in the state (v13 = 0), so the result
    of multiplying the state by the fraction is not an integer. Therefore, the fraction
    does not fire, and FRACTRAN proceeds to the next fraction in the list.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 对于方程 8.2，状态中没有 13 的因子（v13 = 0），因此将状态与分数相乘的结果不是整数。因此，分数不会触发，FRACTRAN 继续执行列表中的下一个分数。
- en: Equation 8.3 fires and sets v2 = 0 without changing v5 or v17.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 方程 8.3 被触发，并将 v2 设置为 0，而不改变 v5 或 v17。
- en: Equation 8.4 does not fire, because even though v2 = 3, attempting to subtract
    five from its state would make v2 negative, which is not allowed. The rules of
    FRACTRAN account for this by requiring the product of the state and a fraction
    to be an integer. The denominator of the fraction must be canceled completely
    by the prime factors of the state.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 方程 8.4 不会触发，因为即使 v2 = 3，试图从其状态中减去 5 会使 v2 为负，这在 FRACTRAN 中是不允许的。FRACTRAN 的规则通过要求状态与分数相乘的结果必须是整数来考虑这一点。分数的分母必须被状态的质因子完全抵消。
- en: The addition example manipulated v2 and v3\. These are often used because they
    are the smallest primes, but there is no reason they must be used. Any two primes
    will work. For example, 8,675,309 and 8,675,311 are both prime. To show they work
    just as well, create *add3.frac*, containing
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 加法示例操作了 v2 和 v3。这些通常被使用，因为它们是最小的质数，但并不意味着一定要使用它们。任何两个质数都可以。例如，8,675,309 和 8,675,311
    都是质数。为了证明它们同样有效，可以创建 *add3.frac*，其中包含：
- en: '[PRE11]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Then add 3 and 2 as before using v8675309 and v8675311 to set the initial state:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 然后像之前一样使用 v8675309 和 v8675311 来设置初始状态，添加 3 和 2：
- en: 8675309³8675311² = 49138847138949979077348022181175509
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 8675309³8675311² = 49138847138949979077348022181175509
- en: Run it to get
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 运行它以获得
- en: '[PRE12]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: which is 8675311⁵.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 这是 8675311⁵。
- en: '[PRE13]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: This proves once again that 3 + 2 = 5 and that any pair of FRACTRAN registers
    work.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 这再次证明了 3 + 2 = 5，并且任何一对 FRACTRAN 寄存器都有效。
- en: '**More FRACTRAN Examples**'
  id: totrans-89
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**更多 FRACTRAN 示例**'
- en: Let’s examine more FRACTRAN examples. Specifically, let’s work through subtraction,
    the maximum of two values, duplicating registers, and multiplication. We’ll conclude
    by exploring Conway’s prime number example, PRIMEGAME, and the Collatz conjecture.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看更多的 FRACTRAN 示例。具体来说，我们来进行减法、两个值的最大值、复制寄存器和乘法的操作。最后，我们将探索 Conway 的素数游戏（PRIMEGAME）和
    Collatz 猜想。
- en: '***Subtraction***'
  id: totrans-91
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***减法***'
- en: Addition in FRACTRAN is a single fraction, and it turns out that subtraction
    is as well (see *sub.frac*).
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 在 FRACTRAN 中，加法是一个单一的分数，结果显示减法也是如此（参见 *sub.frac*）。
- en: '[PRE14]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Let’s run a test to work out 17 *–* 4 = 13\. The input is 2^(17)3⁴ = 10,616,832,
    with intermediate values corresponding to states:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们进行一个测试，计算 17 *–* 4 = 13\. 输入为 2^(17)3⁴ = 10,616,832，过程中间值对应的状态为：
- en: 2^(16)3³ → 2^(15)3² → 2^(14)3¹ → 2^(13)
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 2^(16)3³ → 2^(15)3² → 2^(14)3¹ → 2^(13)
- en: '[PRE15]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The fraction 1/6 = 1/(2¹3¹), so every multiplication decrements both v2 and
    v3 by 1.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 分数 1/6 = 1/(2¹3¹)，因此每次乘法都会使 v2 和 v3 都减少 1。
- en: '![Image](Images/f0227-01.jpg)'
  id: totrans-98
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Images/f0227-01.jpg)'
- en: It decrements both v2 and v3 by 1 until v3 = 0 and multiplication by 1/6 no
    longer produces an integer, causing the program to stop. By assumption, the input
    is of the form 2*^a*3*^b*, *a* > *b*, so continually decrementing v2 and v3 together
    until v3 is 0 will necessarily leave the difference in v2\. If *b* > *a*, *sub.frac*
    still works, but the difference is in v3, not v2.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 它会同时减少 v2 和 v3 直到 v3 = 0，且乘以 1/6 不再产生整数，导致程序停止。根据假设，输入是 2*^a*3*^b* 的形式，*a* >
    *b*，因此不断减少 v2 和 v3，直到 v3 为 0，必然会剩下 v2 的差值。如果 *b* > *a*，*sub.frac* 仍然有效，但差值会在 v3
    中，而不是 v2 中。
- en: '***Maximum of Two Integers***'
  id: totrans-100
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***两个整数的最大值***'
- en: FRACTRAN adds and subtracts using single fractions, but to do anything more
    requires additional fractions. The file *max.frac* contains
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: FRACTRAN 通过单一分数进行加法和减法，但要进行更多操作则需要额外的分数。文件 *max.frac* 包含
- en: '[PRE16]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'This is our first FRACTRAN program to use more than one fraction. The claim
    is that *max.frac* finds the largest of two integers, *a* and *b*. The input state
    looks familiar: register v2 = *a* and v3 = *b* with v5 holding the larger of the
    two when the program ends. Let’s try it and see.'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们第一个使用多个分数的 FRACTRAN 程序。其声明是 *max.frac* 找到两个整数 *a* 和 *b* 中的最大值。输入状态看起来很熟悉：寄存器
    v2 = *a*，v3 = *b*，程序结束时 v5 保存较大的那个整数。我们来试试看。
- en: '[PRE17]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: '*Listing 8-3: Finding the maximum of two integers*'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 8-3：寻找两个整数的最大值*'
- en: The input state is 2⁹3⁸ = 3,359,232 and the output state is 5⁹ = 1,953,125,
    which is correct, as 9 > 8\. Let’s follow the state step by step.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 输入状态是 2⁹3⁸ = 3,359,232，输出状态是 5⁹ = 1,953,125，这个结果是正确的，因为 9 > 8。我们一步步跟踪这个状态变化。
- en: 2⁹3⁸ → 2⁸3⁷5¹ → 2⁷3⁶5² → 2⁶3⁵5³ → 2⁵3⁴5⁴ →
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 2⁹3⁸ → 2⁸3⁷5¹ → 2⁷3⁶5² → 2⁶3⁵5³ → 2⁵3⁴5⁴ →
- en: → 2⁴3³5⁵ → 2³3²5⁶ → 2²3¹5⁷ → 2¹3⁰5⁸ → 5⁹
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: → 2⁴3³5⁵ → 2³3²5⁶ → 2²3¹5⁷ → 2¹3⁰5⁸ → 5⁹
- en: Each state is the prime factorization of the sequence of integers shown in [Listing
    8-3](ch08.xhtml#ch08list3).
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 每个状态是[列表 8-3](ch08.xhtml#ch08list3)中所示整数序列的质因数分解。
- en: The state sequence shows us how the program progresses, but as we have multiple
    fractions, it doesn’t show us exactly what is happening. Therefore, let’s trace
    the program’s actual execution.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 状态序列向我们展示了程序的进展，但由于我们有多个分数，它并没有完全显示发生了什么。因此，让我们跟踪程序的实际执行。
- en: '![Image](Images/f0228-01.jpg)'
  id: totrans-111
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Images/f0228-01.jpg)'
- en: Note that 5/6 is written as 5/(2¹3¹) to make it clear that 5/6 decrements v2
    and v3 when both are greater than 0, and 0 exponents are used to emphasize that
    a particular register has 0 value.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，5/6 被写作 5/(2¹3¹)，以明确表示当 v2 和 v3 都大于 0 时，5/6 会同时减少这两个寄存器的值，并且 0 次方用于强调某个寄存器的值为
    0。
- en: From the sequence of steps, we see that 5/6 starts a loop, decrementing v2 and
    v3 for as long as both of them are greater than 0\. At the same time, the loop
    increments v5\. Once v2 or v3 are 0, 5/6 does not fire, so the next fraction,
    5/2, is tested. In this case, v3 = 0 and v2 > 0, so 5/2 fires, incrementing v5
    and decrementing v2\. Then, and this is important, as there is a new state, the
    program loops *from the beginning* so both 5/6 and 5/2 are tested again. As v3
    is 0, 5/6 doesn’t fire. Additionally, v2 is now 0, so 5/2 doesn’t fire, either.
    That leaves 5/3, but v3 is 0 already, so 5/3 does not fire. There are no more
    fractions, so the program ends with v2 = 0, v3 = 0, and v5 = 9, as it should in
    this case. If the program were run with v2=8 and v3 = 9, then after 5/6 stops
    firing, 5/2 would not fire, but 5/3 would count v3 to 0 while still incrementing
    v5.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 从步骤序列中，我们可以看到 5/6 开始一个循环，递减 v2 和 v3，直到它们都大于 0。同时，循环递增 v5。一旦 v2 或 v3 为 0，5/6
    就不再触发，因此会测试下一个分数 5/2。在这种情况下，v3 = 0 且 v2 > 0，于是 5/2 触发，递增 v5 并递减 v2。然后，重要的是，程序会在状态发生变化后
    *从头开始* 循环，因此 5/6 和 5/2 会再次被测试。由于 v3 为 0，5/6 不会触发。此外，v2 现在为 0，因此 5/2 也不会触发。接下来是
    5/3，但 v3 已经为 0，因此 5/3 不会触发。没有更多的分数，因此程序在 v2 = 0、v3 = 0 和 v5 = 9 时结束，正如该情况下应有的那样。如果程序以
    v2=8 和 v3=9 运行，那么在 5/6 停止触发后，5/2 不会触发，但 5/3 会将 v3 计数至 0，同时继续递增 v5。
- en: Let’s write *max.frac* in a more familiar way. [Listing 8-4](ch08.xhtml#ch08list4)
    presents a Python implementation of the algorithm implied by *max.frac* using
    register names (see *max.py*).
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们以更常见的方式编写 *max.frac*。[Listing 8-4](ch08.xhtml#ch08list4) 展示了使用寄存器名称实现 *max.frac*
    算法的 Python 代码（见 *max.py*）。
- en: '[PRE18]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: '*Listing 8-4: The FRACTRAN max program in Python*'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: '*Listing 8-4: Python 中的 FRACTRAN 最大程序*'
- en: The outer `while` loop runs until both v2 and v3 are 0\. This is equivalent
    to restarting the scan of fractions from the beginning every time the state changes.
    The first `if` acts like 5/6, looping for as long as both v2 and v3 are greater
    than 0\. Notice that because of the `continue`, the following `if` statements
    are not even considered until at least one of v2 or v3 are 0.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 外层的 `while` 循环会一直执行，直到 v2 和 v3 都为 0。这相当于每当状态变化时，都会从头开始重新扫描分数。第一个 `if` 像 5/6
    一样循环，直到 v2 和 v3 都大于 0。注意，由于 `continue`，后续的 `if` 语句在 v2 或 v3 至少有一个为 0 之前不会被考虑。
- en: The second `if` acts like 5/2\. It loops if v3 is 0 but v2 is not. The `continue`
    here starts the outer `while` loop again, meaning the first `if` is evaluated
    yet again; however, as v3 must be 0 for the second `if` to fire, the first `if`
    does not execute.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个 `if` 像 5/2 一样工作。它在 v3 为 0 且 v2 不为 0 时循环。此处的 `continue` 会重新启动外层的 `while`
    循环，这意味着第一个 `if` 会再次被评估；然而，由于第二个 `if` 必须在 v3 为 0 时触发，因此第一个 `if` 不会执行。
- en: Lastly, if v2 is decremented to 0 first by the first `if`, then the last `if`
    fires to decrement v3 until 0\. Notice that each `if` statement increments v5
    every time it fires.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，如果 v2 首先被第一个 `if` 递减为 0，那么最后一个 `if` 会触发，继续递减 v3 直到 0。注意，每当 `if` 语句触发时，v5
    都会递增。
- en: The first `if` decrements both v2 and v3 while incrementing v5\. This removes
    the value in common between v2 and v3\. The following two `if` statements provide
    clean up. One or the other will fire until whichever register that isn’t yet 0,
    either v2 or v3, becomes 0\. As v5 is always incremented regardless of which `if`
    fires, v5 will ultimately contain v2 or v3, whichever is larger. Note also that
    this program is destructive; both v2 and v3 will be lost.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个 `if` 同时递减 v2 和 v3，同时递增 v5。这会移除 v2 和 v3 之间的共同值。接下来的两个 `if` 语句用于清理。它们中的一个会触发，直到尚未为
    0 的寄存器（v2 或 v3）变为 0。由于无论哪个 `if` 触发，v5 总是会递增，因此 v5 最终会包含 v2 或 v3 中较大的那个。还要注意，程序是破坏性的；v2
    和 v3 都会被丢失。
- en: '***Copying a Register***'
  id: totrans-121
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***复制寄存器***'
- en: FRACTRAN fractions fire when all of the prime factors of the denominator, to
    at least the power present in the denominator, are likewise present in the current
    state. In other words, the registers corresponding to the prime factors of the
    fraction’s denominator must have a value at least as large as the exponent of
    the denominator’s prime factors. Additionally, the act of firing necessarily decrements
    a register’s value. This is exactly how 3/2 operates in *add.frac*.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: FRACTRAN 分数在分母的所有素因子（至少是分母中的指数）的素因子都出现在当前状态时才会触发。换句话说，分数的分母对应的寄存器的值必须至少与分母素因子的指数一样大。此外，触发操作会导致寄存器的值递减。这正是
    3/2 在 *add.frac* 中的运作方式。
- en: Therefore, to move the value of register v2 to, say, v7, we need a single fraction,
    7/2\. This is because every time it fires, v2 is decremented and v7 is incremented
    until v2 is 0\. The value of v2 is now in v7 and is no longer in v2\. What if
    instead we want to copy the value in v2 to v7 while leaving it in v2? Learning
    how to do this in FRACTRAN will teach us what we need to know to understand our
    next example, multiplication.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，要将寄存器 v2 的值移到 v7，例如，我们需要一个分数，7/2。这是因为每次触发时，v2 会递减，v7 会递增，直到 v2 为 0。现在，v2
    的值已经在 v7 中，并且不再在 v2 中。如果我们想将 v2 中的值复制到 v7 同时保留在 v2 中怎么办？学习如何在 FRACTRAN 中做到这一点将帮助我们理解下一个例子——乘法。
- en: Our copying-a-register code is based on an example found on Chris Lomont’s blog
    (see *[http://lomont.org/posts/2017/fractran/](http://lomont.org/posts/2017/fractran/)*).
    In this example, he not only gives detailed descriptions of various FRACTRAN programs,
    but presents a FRACTRAN interpreter written in FRACTRAN. Do take a look.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的寄存器复制代码基于 Chris Lomont 的博客中的一个示例（请参阅 *[http://lomont.org/posts/2017/fractran/](http://lomont.org/posts/2017/fractran/)*）。在这个示例中，他不仅详细描述了各种
    FRACTRAN 程序，还呈现了用 FRACTRAN 编写的 FRACTRAN 解释器。一定要看一看。
- en: 'There is no getting around decrementing our source register, as that’s the
    only way we’ll get the fraction to fire. The trick, according to Chris, is to
    move the register’s value to *two* other registers: the desired target register
    and an auxiliary register. Then, when the move is complete, copy the auxiliary
    register back to the source.'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 不得不递减我们的源寄存器，因为这是触发分数的唯一方法。根据 Chris 的说法，诀窍是将寄存器的值移到 *两个* 其他寄存器：所需的目标寄存器和一个辅助寄存器。然后，当移动完成时，将辅助寄存器的值复制回源寄存器。
- en: '[Listing 8-5](ch08.xhtml#ch08list5) shows *copy.frac*, which copies the contents
    of v2 to v3.'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: '[Listing 8-5](ch08.xhtml#ch08list5) 显示了 *copy.frac*，它将 v2 的内容复制到 v3。'
- en: '[PRE19]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: '*Listing 8-5: Copying v2 to v3*'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: '*Listing 8-5: 复制 v2 到 v3*'
- en: Our plan of attack is to define what each register will do, show the code again
    using prime factors, and, lastly, walk through the steps to copy v2 = 3 to v3.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的攻击计划是定义每个寄存器的作用，重新显示代码，使用质因数，并最终通过步骤将 v2 = 3 复制到 v3。
- en: 'To copy v2 to v3, we clearly need at least those two registers. The source
    is v2 and the target is v3\. We’ll use v5 as the second copy of v2\. The copy
    algorithm is as follows:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 要将 v2 复制到 v3，我们显然需要至少这两个寄存器。源寄存器是 v2，目标寄存器是 v3。我们将使用 v5 作为 v2 的第二份副本。复制算法如下：
- en: Decrement v2; increment v3 and v5.
  id: totrans-131
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 递减 v2；递增 v3 和 v5。
- en: Repeat Step 1 until v2 is 0.
  id: totrans-132
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 重复步骤 1，直到 v2 为 0。
- en: Decrement v5; increment v2.
  id: totrans-133
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 递减 v5；递增 v2。
- en: Repeat Step 3 until v5 is 0.
  id: totrans-134
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 重复步骤 3，直到 v5 为 0。
- en: We need two loops, one to increment v3 and v5 running v2 times and another incrementing
    v2 running v5 times. FRACTRAN always scans fractions from the first onward, so
    loops are implemented by flags triggering the next scan of the code. Two loops
    imply that we need two additional registers to act as flags. However, to fire
    a fraction, we must always decrement at least one register, so using a single
    register to cause a loop destroys the flag value. Two registers are needed—one
    to trigger the loop and another to restore the flag after it was decremented.
    We’ll use v7 and v11 as flags for the first loop. Registers v13 and v17 will handle
    the second loop.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要两个循环，一个循环在 v2 次数内递增 v3 和 v5，另一个循环在 v5 次数内递增 v2。FRACTRAN 总是从第一个分数开始扫描，所以循环是通过标志触发代码的下一个扫描来实现的。两个循环意味着我们需要两个附加的寄存器作为标志。然而，要触发一个分数，我们必须始终递减至少一个寄存器，因此使用一个寄存器来执行循环会破坏标志值。需要两个寄存器—一个用于触发循环，另一个在递减后恢复标志。我们将使用
    v7 和 v11 作为第一个循环的标志，寄存器 v13 和 v17 将处理第二个循环。
- en: We now have our registers. Let’s review the code again, but this time using
    prime factors with labels and comments.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在有了寄存器。让我们再次回顾一下代码，但这次使用带标签和注释的质因数。
- en: '| **Label** | **Fraction** | **Comment** |'
  id: totrans-137
  prefs: []
  type: TYPE_TB
  zh: '| **标签** | **分数** | **注释** |'
- en: '| --- | --- | --- |'
  id: totrans-138
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| A | ![Image](Images/f0231-03.jpg) | Inc v3,v5; Dec v2,v7 |'
  id: totrans-139
  prefs: []
  type: TYPE_TB
  zh: '| A | ![Image](Images/f0231-03.jpg) | 递增 v3，v5；递减 v2，v7 |'
- en: '| B | ![Image](Images/f0231-04.jpg) | Reset v7 |'
  id: totrans-140
  prefs: []
  type: TYPE_TB
  zh: '| B | ![Image](Images/f0231-04.jpg) | 重置 v7 |'
- en: '| C | ![Image](Images/f0231-05.jpg) | Clear v7; Set v13 |'
  id: totrans-141
  prefs: []
  type: TYPE_TB
  zh: '| C | ![Image](Images/f0231-05.jpg) | 清除 v7；设置 v13 |'
- en: '| D | ![Image](Images/f0231-06.jpg) | Inc v2; Dec v5 |'
  id: totrans-142
  prefs: []
  type: TYPE_TB
  zh: '| D | ![Image](Images/f0231-06.jpg) | Inc v2；Dec v5 |'
- en: '| E | ![Image](Images/f0231-07.jpg) | Reset v13 |'
  id: totrans-143
  prefs: []
  type: TYPE_TB
  zh: '| E | ![Image](Images/f0231-07.jpg) | 重置 v13 |'
- en: '| F | ![Image](Images/f0231-08.jpg) | Clear v13 |'
  id: totrans-144
  prefs: []
  type: TYPE_TB
  zh: '| F | ![Image](Images/f0231-08.jpg) | 清除 v13 |'
- en: 'Let’s take a walk through the code. We set the initial state to 2³7 = 56 to
    set v2 = 3 and v7, the flag for the first loop. The program then runs like so:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过代码来走一遍。我们将初始状态设置为2³7 = 56，以设置v2 = 3和v7，作为第一个循环的标志。程序接下来这样运行：
- en: '![Image](Images/f0231-02.jpg)'
  id: totrans-146
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Images/f0231-02.jpg)'
- en: 'The numbers represent the state after each fraction fires. The label above
    the arrow shows which fraction fired. The loops are evident: fractions A and B
    repeat three times. This decrements v2 and increments v3 and v5\. Then fraction
    C fires to clear v7 and set v13\. Doing this initiates the second loop. The second
    loop runs three times, with fractions D and E firing to decrement v5 and increment
    v2, thereby restoring its initial value. The very last fraction, F, then fires
    to clear v13\. After this, no other fractions fire, so the program ends with v2
    = v3 = 3, as intended.'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 这些数字表示每个分数触发后的状态。箭头上方的标签显示了哪个分数触发了。循环结构很明显：分数A和B各重复三次。这会递减v2并递增v3和v5。然后分数C触发，清除v7并设置v13。这样就启动了第二个循环。第二个循环运行三次，分数D和E触发，递减v5并递增v2，从而恢复其初始值。最后，分数F触发，清除v13。之后，没有其他分数触发，程序以v2
    = v3 = 3结束，达到了预期的结果。
- en: 'Let’s look a bit more closely at the paired flags. The program begins with
    v7 set. Fraction A fires because both v2 and v7 are greater than 0\. Register
    v2 is decremented along with v7\. The numerator of fraction A increments v3 and
    v5 and sets v11\. To continue the loop, we must set v7 again. That’s what fraction
    B does: it fires when v11 is set (>0) and resets v7\. The loop then continues
    firing fraction A again because v2 and v7 are both greater than 0, that is, the
    state contains factors of 2 and 7\. When v2 is drained, v3 and v5 are both set
    to what v2 was initially. Fraction C then fires to clear v7 and set v13 to begin
    the second loop to move v5 back to v2 using fractions D and E. To end the program
    with no flags set, fraction F clears v13.'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们再仔细看看配对的标志。程序开始时设置了v7。分数A触发，因为v2和v7都大于0。寄存器v2和v7一起递减。分数A的分子递增v3和v5，并设置v11。为了继续循环，我们必须重新设置v7。这就是分数B的作用：当v11被设置（>0）时触发，并重置v7。循环继续执行，分数A再次触发，因为v2和v7都大于0，也就是说，状态中包含2和7的因子。当v2耗尽时，v3和v5都被设置为v2最初的值。然后，分数C触发，清除v7并设置v13，开始第二个循环，使用分数D和E将v5移回v2。为了在没有设置标志的情况下结束程序，分数F清除v13。
- en: Now, let’s see how this double-move loop structure can be used to implement
    multiplication.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看如何使用这个双重循环结构来实现乘法。
- en: '***Multiplication***'
  id: totrans-150
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***乘法***'
- en: Multiplication of two integers is repeated addition. To find the product of
    *a* × *b*, we either add *a* to itself *b* times or add *b* to itself *a* times.
    This is likely the origin of using the word *times* for multiplication. The copy
    example given earlier showed us how to use flags to set up independent loops and
    how to increment a register a set number of times while preserving the source
    register’s value. Let’s use repeated addition along with copying to implement
    multiplication.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 两个整数的乘法是重复加法。要找到 *a* × *b* 的积，我们可以将 *a* 加到自身 *b* 次，或者将 *b* 加到自身 *a* 次。这很可能是使用“*times*”（次）这个词来表示乘法的来源。前面给出的复制示例展示了如何使用标志来设置独立的循环，并且在保持源寄存器值的同时将寄存器递增指定次数。让我们结合重复加法和复制来实现乘法。
- en: 'Specifically, we want a FRACTRAN program that takes an input state of 2^(*a*)3^(*b*)
    and generates a final state of 5^(*ab*) by adding v2 to v5 v3 times. We’ll implement
    the following algorithm:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 具体来说，我们需要一个FRACTRAN程序，它接受一个输入状态2^(*a*)3^(*b*)，并通过将v2加到v5上v3次来生成最终状态5^(*ab*)。我们将实现以下算法：
- en: While v2 > 0, increment v5 and v7.
  id: totrans-153
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当v2 > 0时，递增v5和v7。
- en: While v7 > 0, increment v2.
  id: totrans-154
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当v7 > 0时，递增v2。
- en: While v3 > 0, repeat from Step 1.
  id: totrans-155
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当v3 > 0时，从第1步开始重复。
- en: The first loop is Step 1, which decrements v2 while incrementing v5 and v7\.
    Register v5 holds the product, so we’ll only increment it. Register v7 is used
    to hold v2 as v2 is drained while adding it to v5\. Step 2 restores v2 by moving
    v7 back to v2 just as we did in *copy.frac*. Steps 1 and 2 repeat until v3 is
    0, thereby adding v2 to v5 v3 times.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个循环是第1步，它递减v2并递增v5和v7。寄存器v5保存积，因此我们只需递增它。寄存器v7用来保存v2，因为v2在加入v5时被耗尽。第2步通过将v7的值移回v2来恢复v2，就像我们在*copy.frac*中做的那样。第1步和第2步会重复，直到v3为0，从而将v2加到v5上v3次。
- en: There are three loops, but we can combine Steps 2 and 3 into a single loop.
    For Step 1, we need a pair of registers for the flag; we’ll use v11 and v13\.
    The initial version of this program added v17 for the other loop, but that would
    only be necessary if there were code after the multiplication.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 有三个循环，但我们可以将步骤 2 和 3 合并为一个循环。在步骤 1 中，我们需要一对寄存器作为标志；我们将使用 v11 和 v13。该程序的初始版本为另一个循环添加了
    v17，但只有在乘法后面有代码时才需要使用它。
- en: '[Listing 8-6](ch08.xhtml#ch08list6) shows the end result (see *mult.frac*).'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: '[列表 8-6](ch08.xhtml#ch08list6) 显示了最终结果（参见 *mult.frac*）。'
- en: '[PRE20]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: '*Listing 8-6: Multiplication by repeated addition*'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 8-6: 通过重复加法进行乘法*'
- en: 'Let’s label the fractions A through F as we did earlier. Doing this gives us:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们像之前一样给这些分数标上 A 到 F 的标签。这样做会得到：
- en: '| **Label** | **Fraction** | **Comment** |'
  id: totrans-162
  prefs: []
  type: TYPE_TB
  zh: '| **标签** | **分数** | **注释** |'
- en: '| --- | --- | --- |'
  id: totrans-163
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| A | ![Image](Images/f0233-03.jpg) | Inc v5, v7; Set v13; Dec v2; Clear v11
    |'
  id: totrans-164
  prefs: []
  type: TYPE_TB
  zh: '| A | ![Image](Images/f0233-03.jpg) | 增加 v5, v7；设置 v13；递减 v2；清除 v11 |'
- en: '| B | ![Image](Images/f0233-04.jpg) | Reset v11 |'
  id: totrans-165
  prefs: []
  type: TYPE_TB
  zh: '| B | ![Image](Images/f0233-04.jpg) | 重置 v11 |'
- en: '| C | ![Image](Images/f0233-05.jpg) | Clear v11 |'
  id: totrans-166
  prefs: []
  type: TYPE_TB
  zh: '| C | ![Image](Images/f0233-05.jpg) | 清除 v11 |'
- en: '| D | ![Image](Images/f0233-06.jpg) | Inc v2; Dec v7 |'
  id: totrans-167
  prefs: []
  type: TYPE_TB
  zh: '| D | ![Image](Images/f0233-06.jpg) | 增加 v2；递减 v7 |'
- en: '| E | ![Image](Images/f0233-07.jpg) | Dec v3; Set v11 |'
  id: totrans-168
  prefs: []
  type: TYPE_TB
  zh: '| E | ![Image](Images/f0233-07.jpg) | 递减 v3；设置 v11 |'
- en: '| F | ![Image](Images/f0233-08.jpg) | Dec v2 |'
  id: totrans-169
  prefs: []
  type: TYPE_TB
  zh: '| F | ![Image](Images/f0233-08.jpg) | 递减 v2 |'
- en: 'With this table, we can walk through a trace of 3 × 2 = 6\. The input state
    is 2³3² = 72 and the expected output state is 5⁶ = 15625\. First, let’s see that
    *mult.frac* actually works:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 使用此表，我们可以通过追踪 3 × 2 = 6 来演示。输入状态为 2³3² = 72，预期输出状态为 5⁶ = 15625。首先，让我们看看 *mult.frac*
    实际上是如何工作的：
- en: '[PRE21]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'The output is as expected. Now, let’s trace the evolution of the state:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如预期那样。现在，让我们跟踪状态的演变：
- en: '![Image](Images/f0233-09.jpg)'
  id: totrans-173
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Images/f0233-09.jpg)'
- en: The first fraction to fire is E, which decrements v3 and sets v11 to cause the
    add-v2-to-v5 loop to execute. The add loop, fractions A and B, repeats three times
    to increment v5 and v7\. After the third iteration, there is no longer a factor
    of 2 in the state (v2 = 0), so fraction C fires next to clear v11 and begin the
    outer loop.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个被触发的分数是 E，它递减 v3 并设置 v11 以启动加 v2 到 v5 的循环。加法循环，分数 A 和 B，会重复三次以递增 v5 和 v7。经过第三次迭代后，状态中不再有
    2 的因子（v2 = 0），因此接下来触发分数 C 来清除 v11 并开始外层循环。
- en: The first part of the outer loop uses D to decrement v7 and increment v2, thereby
    restoring v2 to its original value. After the third time through that loop, v7
    is 0 and 7 is no longer a factor of the state, so fraction E fires to decrement
    v3 and set v11 to add v2 to v5 again.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 外层循环的第一部分使用 D 来递减 v7 并递增 v2，从而恢复 v2 到其原始值。经过第三次循环后，v7 为 0，7 不再是状态的因子，因此分数 E
    被触发，递减 v3 并设置 v11，将 v2 再次加到 v5 中。
- en: The add loop of fractions A and B runs another three times. At this point, we
    have our answer in v5, and v2 and v3 are both 0, but fraction C fires again because
    v7 is not 0\. Fraction C fires three times to make v7 0 and v2 = 3\. However,
    v3 is now 0, so v11 is never set. Register v7 is now also 0 and the state is only
    v2 = 3 and v5 = 6\. Therefore, no fraction fires until F, which fires three times
    to decrement v2 to 0\. Lastly, the state is only v5 = 6, and no fraction has a
    factor of 5 in its denominator, so no fractions fire and the program ends. [Listing
    8-6](ch08.xhtml#ch08list6) multiplies, but cleaning up after calculating the answer
    requires many additional operations.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 分数 A 和 B 的加法循环再运行三次。此时，我们在 v5 中得到了答案，v2 和 v3 都为 0，但分数 C 会再次触发，因为 v7 不是 0。分数
    C 会触发三次，将 v7 设为 0，v2 = 3。但此时 v3 已经是 0，因此 v11 永远不会被设置。寄存器 v7 现在也为 0，状态仅为 v2 = 3
    和 v5 = 6。因此，直到 F 被触发，F 会触发三次将 v2 递减为 0。最后，状态只有 v5 = 6，且没有任何分数的分母中包含 5，因此没有分数被触发，程序结束。[列表
    8-6](ch08.xhtml#ch08list6) 进行乘法运算，但在计算答案之后需要执行许多额外的操作来清理。
- en: 'Let’s change gears now and explore the first FRACTRAN program Conway presented:
    PRIMEGAME.'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们换个思路，探讨康威最早展示的第一个 FRACTRAN 程序：PRIMEGAME。
- en: '***Conway’s PRIMEGAME***'
  id: totrans-178
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***康威的 PRIMEGAME***'
- en: When Conway first presented PRIMEGAME, he did so by writing the fractions in
    [Listing 8-7](ch08.xhtml#ch08list7) and claiming that not only does every power
    of two generated by the program have a prime exponent, the primes are in order.
    Let’s explore in this section what he meant.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 当康威首次展示 PRIMEGAME 时，他通过编写 [列表 8-7](ch08.xhtml#ch08list7) 中的分数来说明，不仅程序生成的每一个二的幂都具有素数指数，而且素数的顺序是有规律的。让我们在这一节中探讨他是什么意思。
- en: '[PRE22]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: '*Listing 8-7: Conway’s PRIMEGAME*'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 8-7: 康威的 PRIMEGAME*'
- en: Unlike the copy and multiply examples above, we won’t step through [Listing
    8-7](ch08.xhtml#ch08list7). Conway does so in lectures available on the internet
    (for example, see *[https://www.youtube.com/watch?v=548BH-YFT1E/](https://www.youtube.com/watch?v=548BH-YFT1E/)*).
    Instead, we’ll capture the output of [Listing 8-7](ch08.xhtml#ch08list7) to see,
    empirically, that Conway’s claim is true. I leave it as an exercise for the motivated
    reader to work through the operation of [Listing 8-7](ch08.xhtml#ch08list7).
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 与上述复制和乘法示例不同，我们不会逐步解析[清单 8-7](ch08.xhtml#ch08list7)。Conway在互联网上的讲座中有详细介绍（例如，见*[https://www.youtube.com/watch?v=548BH-YFT1E/](https://www.youtube.com/watch?v=548BH-YFT1E/)*）。相反，我们将捕获[清单
    8-7](ch08.xhtml#ch08list7)的输出，实证验证Conway的说法是否正确。我留给有兴趣的读者作为练习，去研究[清单 8-7](ch08.xhtml#ch08list7)的操作过程。
- en: The primes program never halts, so we need to tell the interpreter to display
    every new state. If you run *primes.frac* with an initial state of 2
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 质数程序永不停止，因此我们需要告诉解释器显示每个新状态。如果你使用初始状态2运行*primes.frac*
- en: '[PRE23]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: your screen would immediately fill with large numbers. Some of these numbers
    are powers of two. Those are the numbers we want to display. We could modify *FRACTRAN.py*
    to display only the powers of two, but why alter the code for the interpreter
    when we can instead feed the output of *primes.frac* to the input of a second
    program that takes the output and, if it is a power of two, displays it?
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 你的屏幕将立即填满大数字。其中一些数字是2的幂。这些就是我们想要显示的数字。我们本可以修改*FRACTRAN.py*，让它只显示2的幂，但为什么要改变解释器的代码呢，既然我们可以将*primes.frac*的输出传递给第二个程序的输入，后者将检查输出是否为2的幂，如果是，则显示出来？
- en: The script *power_of_two.py* does what we want. It uses `input` to read the
    number FRACTRAN displays and checks whether it is a power of two. [Listing 8-8](ch08.xhtml#ch08list8)
    contains the code.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 脚本*power_of_two.py*实现了我们想要的功能。它使用`input`读取FRACTRAN显示的数字，并检查该数字是否是2的幂。[清单 8-8](ch08.xhtml#ch08list8)包含了代码。
- en: '[PRE24]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: '*Listing 8-8: A Python script to check for powers of two*'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 8-8：检查2的幂的Python脚本*'
- en: The script accepts the input from FRACTRAN as an integer ➌, passes it to `isPowerOfTwo`,
    which returns `True` if the input (`d`) is a power of two and then prints it along
    with the exponent (`p`). This process repeats forever because of the `while` loop
    ➋.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 该脚本接受来自FRACTRAN的输入作为整数➌，将其传递给`isPowerOfTwo`，如果输入（`d`）是2的幂，则返回`True`，然后打印该值及其指数（`p`）。由于`while`循环➋，该过程会无限重复。
- en: The function `isPowerOfTwo` ➊ must check whether its argument is a power of
    two. We could call a log base-2 function here, but we’ll quickly encounter integers
    too large for any function expecting a floating-point argument. If an integer
    is a power of two, that means there is only one digit in its binary representation
    that is a 1\. So `d` is converted to binary and stored as a string in `s`. Then
    we set `n` to the number of 1s by using `count`. If `d` is a power of two, the
    exponent is the number of digits in `d` minus one (`p`). Lastly, any power of
    two is displayed along with its exponent.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 函数`isPowerOfTwo` ➊必须检查其参数是否为2的幂。我们可以在这里调用一个以2为底的对数函数，但很快就会遇到一些整数太大，无法适应任何期望浮动参数的函数。如果一个整数是2的幂，那么它的二进制表示中只有一个1。所以`d`会被转换成二进制并作为字符串存储在`s`中。然后，我们通过使用`count`计算1的数量来设置`n`。如果`d`是2的幂，指数是`d`中数字的数量减一（`p`）。最后，任何2的幂都会连同其指数一起显示。
- en: 'To link the output of FRACTRAN to the input expected by [Listing 8-8](ch08.xhtml#ch08list8),
    we use a Unix pipe character, `|`:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 为了将FRACTRAN的输出与[清单 8-8](ch08.xhtml#ch08list8)所期望的输入链接起来，我们使用Unix管道字符`|`：
- en: '[PRE25]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'which feeds the output of FRACTRAN to the input of *power_of_two.py* to display
    powers of two. For example, the output begins as follows:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 它将FRACTRAN的输出传递给*power_of_two.py*的输入，以显示2的幂。例如，输出如下所示：
- en: '[PRE26]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Here the exponents are all primes and, more than that, primes in the correct
    order with no gaps, just like Conway promised. The rate at which new primes are
    generated slows as the primes get larger. For example, the file *powers_of_two.txt*
    contains the output generated by letting the code run over-night. The largest
    prime found was 953.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，指数都是质数，而且更重要的是，这些质数按正确的顺序排列，没有任何间隙，就像Conway所承诺的那样。随着质数增大，新质数生成的速度会变慢。例如，文件*powers_of_two.txt*包含了让代码过夜运行时生成的输出。找到的最大质数是953。
- en: Devin Kilminster made a nine fraction version of PRIMEGAME that outputs the
    primes as powers of 10 instead of two. See [Listing 8-9](ch08.xhtml#ch08list9)
    (*prime10.frac*).
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: Devin Kilminster制作了一个九分数版本的PRIMEGAME，该版本将质数作为10的幂而不是2的幂输出。见[清单 8-9](ch08.xhtml#ch08list9)（*prime10.frac*）。
- en: '[PRE27]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: '*Listing 8-9: Kilminster’s primes*'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 8-9：Kilminster的质数*'
- en: Run *prime10.frac* with *power_of_ten.py* as we did for Conway’s game above.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 跟我们上面为 Conway 的游戏所做的那样，使用 *power_of_ten.py* 运行 *prime10.frac*。
- en: '[PRE28]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: The output sequence using powers of 10 generates the primes, in order.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 10 的幂生成的输出序列会按顺序生成素数。
- en: We might wonder which prime generator is faster. I modified *power_of* *_two.py*
    and *power_of_ten.py* to stop after the 100th prime, 541, and timed how long each
    program took using the Racket version of the FRACTRAN interpreter.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可能会想知道哪个素数生成器更快。我修改了 *power_of* *_two.py* 和 *power_of_ten.py*，使它们在生成第 100
    个素数 541 后停止，并使用 Racket 版本的 FRACTRAN 解释器测量了每个程序所用的时间。
- en: '| Program | Runtime(s) |'
  id: totrans-203
  prefs: []
  type: TYPE_TB
  zh: '| 程序 | 运行时间（秒） |'
- en: '| --- | --- |'
  id: totrans-204
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| Conway | 3317 |'
  id: totrans-205
  prefs: []
  type: TYPE_TB
  zh: '| Conway | 3317 |'
- en: '| Kilminster | 783 |'
  id: totrans-206
  prefs: []
  type: TYPE_TB
  zh: '| Kilminster | 783 |'
- en: Not only is Kilminster’s program shorter than Conway’s original PRIMEGAME, it’s
    also significantly faster.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: Kilminster 的程序不仅比 Conway 的原始 PRIMEGAME 更短，而且速度也快得多。
- en: Our next example generates the Collatz sequence for an integer. Don’t worry,
    I’ll explain what that means.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的下一个例子会生成一个整数的科拉茨序列。别担心，我会解释这是什么意思。
- en: '***The Collatz Conjecture***'
  id: totrans-209
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***科拉茨猜想***'
- en: 'Lothar Collatz was a German mathematician. In 1937, he speculated that the
    following sequence, for any initial integer, *x*[0] = *n*, will always end with
    1 (see Equation 8.6):'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 洛塔尔·科拉茨是德国数学家。1937年，他推测，对于任何初始整数 *x*[0] = *n*，以下序列总会以 1 结束（见公式 8.6）：
- en: '![Image](Images/08eqa06.jpg)'
  id: totrans-211
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/08eqa06.jpg)'
- en: For example, the sequence for *n* = 10 is
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，*n* = 10 的序列是
- en: 10 → 5 → 16 → 8 → 4 → 2 → 1
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 10 → 5 → 16 → 8 → 4 → 2 → 1
- en: Once the output is 4, the sequence 4 → 2 → 1 will repeat forever because 3(1)
    + 1 = 4.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦输出为 4，序列 4 → 2 → 1 将永远重复，因为 3(1) + 1 = 4。
- en: To date, no one has succeeded in proving the Collatz conjecture, and all empirical
    tests have always ended in 1\. There is a deep connection between FRACTRAN and
    the Collatz conjecture that we’ll get to in the discussion below. For now, let’s
    run Conway’s FRACTRAN program to generate the Collatz sequence for any integer,
    *n*. (It’s highly likely Conway wrote this code, but solid proof has not been
    forthcoming.) The code is in *collatz.frac* and [Listing 8-10](ch08.xhtml#ch08list10).
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 至今，没有人成功证明科拉茨猜想，所有的经验测试都最终以 1 结束。FRACTRAN 和科拉茨猜想之间有着深刻的联系，我们将在下面的讨论中深入探讨。现在，让我们运行
    Conway 的 FRACTRAN 程序，生成任何整数 *n* 的科拉茨序列。（很可能是 Conway 写了这段代码，但至今没有确凿的证据。）代码在 *collatz.frac*
    中，见[清单 8-10](ch08.xhtml#ch08list10)。
- en: '[PRE29]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: '*Listing 8-10: FRACTRAN code to generate the Collatz sequence*'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 8-10：生成科拉茨序列的 FRACTRAN 代码*'
- en: The input is 2^(*n*) and the final output is 2¹. All states that are powers
    of two represent a number in the Collatz sequence. So we must filter the output
    using *power_of_two.py* as we did for PRIMEGAME above. Let’s try a few runs beginning
    with *n* = 128.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 输入是 2^(*n*)，最终输出是 2¹。所有是 2 的幂的状态表示科拉茨序列中的一个数字。所以，我们必须像上面对 PRIMEGAME 所做的那样，使用
    *power_of_two.py* 过滤输出。让我们尝试几次运行，从 *n* = 128 开始。
- en: '[PRE30]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: The large starting state is 2^(128). The Collatz sequence ends after seven steps.
    Not all sequences are so short. For example, changing from *n* = 128 to *n* =
    129 generates
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 起始状态很大，为 2^(128)。科拉茨序列在七步后结束。并不是所有序列都这么短。例如，从 *n* = 128 变为 *n* = 129 会生成
- en: '[PRE31]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: for a total of 121 steps. As with PRIMEGAME, parsing the algorithm in *collatz.frac*
    is left as an exercise for the ambitious reader.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 总共 121 步。与 PRIMEGAME 一样，解析 *collatz.frac* 中的算法留给有抱负的读者作为练习。
- en: Note that the sequence for 129 included values as large as 9,232\. This means
    the state contained a factor of 2^(9232), a number with 2,780 digits. Although
    *collatz.frac* will work for any integer, the intermediate values become quite
    large. Play around with *collatz.frac* or, if you are impatient, the much faster
    Python version, *collatz.py*. Do you notice anything interesting about the largest
    value in each sequence for *n* from 5 to 200?
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，129 的序列中包含的值最大达 9,232。这意味着该状态包含了一个 2^(9232) 的因子，这是一个有 2,780 位的数字。虽然 *collatz.frac*
    对任何整数都能工作，但其中间值会变得非常大。你可以尝试使用 *collatz.frac* 或者，如果你不耐烦的话，使用更快的 Python 版本 *collatz.py*。你注意到从
    *n* = 5 到 200 的每个序列中的最大值有什么有趣的地方吗？
- en: '***A FRACTRAN Greeting***'
  id: totrans-224
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***一个 FRACTRAN 问候***'
- en: 'We’ll end with an example more cute than it is useful. However, it does one
    interesting thing: the program’s goal is not a specific set of register values,
    per se, but the decimal value of the single integer representing the final state.
    The code is in *hello.frac* and [Listing 8-11](ch08.xhtml#ch08list11).'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将以一个比实用更可爱的例子结束。不过，它做了一件有趣的事情：程序的目标不是一组特定的寄存器值，而是表示最终状态的单个整数的十进制值。代码在 *hello.frac*
    中，见[清单 8-11](ch08.xhtml#ch08list11)。
- en: '[PRE32]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: '*Listing 8-11: A FRACTRAN greeting*'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 8-11：一个 FRACTRAN 问候*'
- en: First, run the program to verify that it produces the claimed output.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，运行程序以验证它是否生成了声明的输出。
- en: '[PRE33]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Next, pipe the output to *hello.py*.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，将输出管道传递给 *hello.py*。
- en: '[PRE34]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: The *hello.py* script is
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: '*hello.py* 脚本是'
- en: '[PRE35]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: This reads the FRACTRAN output as a string, breaking it up into pairs of digits
    and outputting the ASCII character corresponding to that pair of digits.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 这会将 FRACTRAN 的输出作为字符串读取，将其分解为一对对数字，并输出与该对数字对应的 ASCII 字符。
- en: Let’s walk through *hello.frac*. The starting state is 2³5¹7¹11¹. The denominators
    of the fractions are also 2, 5, 7, and 11\. Therefore, the initial state will
    match each fraction, but the fractions’ order means it matches 3/2 first. The
    product of the state and 3/2 decrements v2 and increments v3, then starts again
    from the beginning, matching 3/2 a second time. Now v2 = 1 and v3 = 2\. Looping
    again sets v2 to 0 and v3 to 3\. Now the state has no factor of 2, so 3/2 does
    not fire, and FRACTRAN moves to 41/5\. The state is 3³5¹7¹11¹, which does have
    a factor of 5, so v5 is decremented, v41 is incremented, and the program loops.
    There are only factors of 7 and 11 left to match fractions. First, the fraction
    with a denominator of 7 matches and fires followed by the fraction with a denominator
    of 11.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们逐步分析 *hello.frac*。初始状态是 2³5¹7¹11¹。分数的分母也是 2、5、7 和 11。因此，初始状态会与每个分数匹配，但分数的顺序意味着它首先匹配
    3/2。状态和 3/2 的乘积将 v2 减少并增加 v3，然后从头开始，再次匹配 3/2。此时 v2 = 1 且 v3 = 2。再循环一次将 v2 设置为
    0，v3 设置为 3。现在状态中没有 2 的因子，因此 3/2 不会触发，FRACTRAN 移动到 41/5。此时状态是 3³5¹7¹11¹，它确实有 5
    的因子，因此 v5 被递减，v41 被递增，程序继续循环。剩下的只有 7 和 11 的因子与分数匹配。首先，分母为 7 的分数匹配并触发，接着是分母为 11
    的分数。
- en: The final state of the system is
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 系统的最终状态是
- en: 3³41¹6701021¹9800132160937639¹ = 72697676794432877982766833
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 3³41¹6701021¹9800132160937639¹ = 72697676794432877982766833
- en: 'which is precisely what we want it to be: a string of ASCII character codes.'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 这正是我们希望它成为的样子：一串 ASCII 字符代码。
- en: 'We wanted *hello.frac* to produce the integer corresponding to the sentence
    `HELLO, WORLD!`. That determined the printed output. The prime factorization of
    that output determined the final registers and their values. The included *primeFactors.py*
    searches for prime factors, but it is too slow to factor a large integer like
    the output of *hello.frac*. For that, I used WolframAlpha (see *[https://www.wolframalpha.com/](https://www.wolframalpha.com/)*).
    Prime factors in hand, the program itself was straightforward: set the initial
    state to v2 = 3, v5 = 1, v7 = 1, and v11 = 1\. Then, use the prime factors as
    the numerators to increment v3, v41, and so on for the necessary number of times:
    3, 1, 1, and 1.'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望 *hello.frac* 输出与句子 `HELLO, WORLD!` 对应的整数。这决定了打印的输出。该输出的质因数分解确定了最终的寄存器及其值。包含的
    *primeFactors.py* 搜索质因数，但它对于像 *hello.frac* 输出这样的大整数来说太慢了。为此，我使用了 WolframAlpha（见
    *[https://www.wolframalpha.com/](https://www.wolframalpha.com/)*）。得到了质因数后，程序本身就很简单：将初始状态设置为
    v2 = 3, v5 = 1, v7 = 1, 和 v11 = 1。然后，使用质因数作为分子来递增 v3、v41 等，直到达到所需次数：3、1、1 和 1。
- en: Of course, we could initialize the program with the desired output state and,
    using a fraction with no factor in the denominator matching the state, produce
    the desired output immediately, but that would be boring.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，我们可以使用所需的输出状态初始化程序，并使用一个分母中没有与状态匹配的因子的分数，立即产生所需的输出，但那样会很无聊。
- en: '**Discussion**'
  id: totrans-241
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**讨论**'
- en: 'Let’s discuss two aspects of FRACTRAN: Turing completeness and its relation
    to the Collatz conjecture. After that, we’ll conclude with some final thoughts.'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们讨论 FRACTRAN 的两个方面：图灵完备性以及它与 Collatz 猜想的关系。之后，我们将以一些最终的思考作结。
- en: '***Is FRACTRAN Turing Complete?***'
  id: totrans-243
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***FRACTRAN 是图灵完备的吗？***'
- en: Is FRACTRAN Turing complete? Yes, it is. FRACTRAN has looping and an infinite
    number of registers as there are an infinite number of primes. Additionally, FRACTRAN
    can implement FRACTRAN, as Chris Lomont’s blog post mentioned previously demonstrates.
    Also, FRACTRAN is a Minsky-style register machine, a machine that has been proven
    to be Turing complete, so FRACTRAN is also Turing complete.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: FRACTRAN 是图灵完备的吗？是的，它是。FRACTRAN 具有循环结构和无限数量的寄存器，因为质数是无限的。此外，FRACTRAN 可以实现 FRACTRAN，正如
    Chris Lomont 的博客文章之前所提到的那样。FRACTRAN 还是一种 Minsky 风格的寄存器机，这种机器已经被证明是图灵完备的，因此 FRACTRAN
    也是图灵完备的。
- en: 'Conway himself included a universal FRACTRAN program in his description of
    FRACTRAN: POLYGAME. See “FRACTRAN: A Simple Universal Programming Language for
    Arithmetic” in *Open Problems in Communication and Computation* (Springer, 1987).'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: Conway本人在他的FRACTRAN描述中包含了一个通用FRACTRAN程序：POLYGAME。请参阅《FRACTRAN：一种简单的通用算术编程语言》一文，载于《Open
    Problems in Communication and Computation》（Springer，1987年）。
- en: 'POLYGAME is a FRACTRAN program capable of computing any function when given
    the proper “catalogue number” as Conway called it. We’ll use the British spelling
    henceforth. Here is POLYGAME:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: POLYGAME是一个FRACTRAN程序，可以在给定适当的“目录号”（Conway所称）时计算任何函数。从此我们将使用英国拼写。以下是POLYGAME：
- en: '![Image](Images/f0239-01.jpg)'
  id: totrans-247
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Images/f0239-01.jpg)'
- en: The input is *c*2^(2^(*n*)), with *n* the argument and *c* the catalogue number.
    The output is 2^(2^m) to implement *f*[*c*](*n*) = *m*. For example, the increment
    function *n* →*n* + 1 has catalogue number 2,268,945\. Therefore, to increment
    4, the input to FRACTRAN is
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 输入是*c*2^(2^(*n*))，其中*n*是参数，*c*是目录号。输出是2^(2^m)，以实现*f*[*c*](*n*) = *m*。例如，增量函数*n*
    → *n* + 1的目录号是2,268,945。因此，要增加4，FRACTRAN的输入为
- en: (2,268,945)2^(2⁴) = 148,697,579,520
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: (2,268,945)2^(2⁴) = 148,697,579,520
- en: to produce the output
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 以产生输出
- en: 2^(2⁵) = 4,294,967,296
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 2^(2⁵) = 4,294,967,296
- en: which is exactly what we get if we run POLYGAME.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 这正是我们运行POLYGAME所得到的结果。
- en: '[PRE36]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'POLYGAME can implement *all* functions given the proper *c*. Another example
    is *c* = 255, the identity function: *n* → *n*. The most interesting example Conway
    gives is *c*[*π*]. It’s an integer, but good luck calculating'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: POLYGAME可以实现*所有*的函数，只要给定正确的*c*。另一个例子是*c* = 255，即恒等函数：*n* → *n*。Conway给出的最有趣的例子是*c*[*π*]。这是一个整数，但计算它的过程将是极为困难的。
- en: '![Image](Images/f0270-1.jpg)'
  id: totrans-255
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Images/f0270-1.jpg)'
- en: Yes, that is a 5 raised to the power of two raised to the factorial of 101\.
    Given the insane size of *c*[*π*], we’ll take Conway’s word for it that *c*[*π*]
    is the catalogue number for a function, *π*(*n*), returning the *n*th digit of
    *π*.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 是的，这个数是5的平方再乘以101的阶乘的幂。鉴于*c*[*π*]的庞大规模，我们就相信Conway的话，认为*c*[*π*]是一个函数的目录号，*π*(*n*)返回*π*的第*n*位数字。
- en: '***FRACTRAN and the Collatz Conjecture***'
  id: totrans-257
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***FRACTRAN和Collatz猜想***'
- en: Equation 8.6 defined the Collatz sequence for an integer, *n*. The equation
    describes how to generate the next number in the sequence based on whether the
    current number is even or odd. Another way to formulate Equation 8.6 is shown
    in Equation 8.7.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 方程8.6定义了一个整数*n*的Collatz序列。该方程描述了如何根据当前数值是偶数还是奇数来生成序列中的下一个数字。方程8.6的另一种表述形式见方程8.7。
- en: '![Image](Images/08eqa07.jpg)'
  id: totrans-259
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Images/08eqa07.jpg)'
- en: meaning *x*[*i*+1] = *x*[*i*]/2 if *x*[*i*]/2 is an integer; otherwise, *x*[*i*+1]
    = 3*x*[*i*] + 1, which is always an integer.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 意味着*x*[*i*+1] = *x*[*i*]/2（如果*x*[*i*]/2是整数）；否则，*x*[*i*+1] = 3*x*[*i*] + 1，这始终是一个整数。
- en: The Collatz sequence is what Conway terms a *bipartite linear function*, meaning
    a function that can be written as
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: Collatz序列是Conway所称的*二分线性函数*，意味着一个可以写作如下的函数
- en: '*g*(*n*) = *g*[1](*n*) *|* *g*[2](*n*)'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: '*g*(*n*) = *g*[1](*n*) *|* *g*[2](*n*)'
- en: with *g*(*n*) returning whichever of *g*[1](*n*) or *g*[2](*n*) returns an integer
    first when evaluating left to right. Each *g*[*i*](*n*) is of the form
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 通过*g*(*n*)返回* g*[1](*n*)或*g*[2](*n*)中先返回整数的那个，按从左到右的顺序进行评估。每个*g*[*i*](*n*)的形式为
- en: '*g**[i]*(*n*) = *a**[i]**n* + *b**[i]*'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: '*g**[i]*(*n*) = *a**[i]**n* + *b**[i]*'
- en: which is a linear function (a line). For the Collatz sequence, *a*[1] = 1/2
    and *b*[1] = 0\. Similarly, *a*[2] = 3 and *b*[2] = 1.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个线性函数（一条直线）。对于Collatz序列，*a*[1] = 1/2，*b*[1] = 0。同样，*a*[2] = 3，*b*[2] = 1。
- en: There is no reason why *g*(*n*) should be limited to only two parts. A *k*-partite
    linear function is
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 没有理由为什么*g*(*n*)只能限于两个部分。一个*k*部分的线性函数是
- en: '*g*(*n*) = *g*[1](*n*) *|* *g*[2](*n*) *|* *g*[3](*n*) *|* … *|* *g**[k]*(*n*)'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: '*g*(*n*) = *g*[1](*n*) *|* *g*[2](*n*) *|* *g*[3](*n*) *|* … *|* *g**[k]*(*n*)'
- en: Conway calls *k*-partite functions with *g*[*i*](*n*) = *a*[*i*]*n* + *b*[*i*]
    *Collatzian games*. The rule for evaluating *g*(*n*) is to calculate *g*[1](*n*)
    followed by *g*[2](*n*) and so on until one of them returns an integer. If none
    of them return an integer, or if the integer returned is some specified value,
    like 1, stop.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: Conway将具有*g*[*i*](*n*) = *a*[*i*]*n* + *b*[*i*]形式的*k*部分函数称为Collatzian游戏。评估*g*(*n*)的规则是首先计算*g*[1](*n*)，然后是*g*[2](*n*)，依此类推，直到其中一个返回整数。如果它们都不返回整数，或者返回的整数是某个指定值（如1），则停止。
- en: This rule sounds familiar. If we set all the *b*[*i*]s to 0 and all the *a*[*i*]s
    to rationals, then *g*(*n*) is a FRACTRAN program. Therefore, FRACTRAN programs
    are Collatzian games. However, note that the Collatz conjecture is not a FRACTRAN
    program, as *b*[2] = 1.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 这个规则听起来很熟悉。如果我们将所有的*b*[*i*]设为0，将所有的*a*[*i*]设为有理数，那么*g*(*n*)就是一个FRACTRAN程序。因此，FRACTRAN程序是Collatzian游戏。然而，注意Collatz猜想不是一个FRACTRAN程序，因为*b*[2]
    = 1。
- en: Gödel’s incompleteness theorem states that arithmetic contains true statements
    it cannot prove using the axioms of arithmetic. Alan Turing translated this concept
    into the *halting problem*, which states that it is impossible to find an algorithm
    that will correctly decide in all cases whether a program (a Turing machine) with
    a finite input will eventually stop or run forever. The term to describe these
    cases is *undecidable*. An undecidable problem has been *proven* to be so; there
    is no algorithm that will correctly decide in all cases.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 哥德尔不完备定理指出，算术包含一些真实的命题，但不能通过算术公理加以证明。艾伦·图灵将这一概念转化为*停机问题*，该问题表明，无法找到一个算法，能够在所有情况下正确决定一个程序（图灵机）在有限输入下是否最终会停止或永远运行。用来描述这些情况的术语是*不可判定的*。不可判定的问题已经被*证明*是这样的；不存在一个能够在所有情况下正确判断的算法。
- en: FRACTRAN programs are undecidable, and FRACTRAN programs are a type of Collatzian
    game. Therefore, there are Collatzian games that are undecidable, games for which
    it is impossible to prove that the game ends as desired for all inputs, *n*. This
    fact does not solve the question of the Collatz conjecture, as the conjecture
    applies to a Collatzian game that is not a FRACTRAN program. However, showing
    there are undecidable Collatzian games is an important result all the same. It
    may be that the Collatz conjecture is undecidable, too.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: FRACTRAN程序是不可判定的，且FRACTRAN程序是一种Collatzian游戏。因此，存在一些不可判定的Collatzian游戏，对于这些游戏，无法证明对于所有输入*n*，游戏是否按照预期结束。这个事实并没有解决Collatz猜想的问题，因为猜想适用于一种不是FRACTRAN程序的Collatzian游戏。然而，展示不可判定的Collatzian游戏仍然是一个重要的结果。也许Collatz猜想本身也是不可判定的。
- en: '***Final Thoughts on FRACTRAN***'
  id: totrans-272
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***FRACTRAN的最终思考***'
- en: When first encountered, FRACTRAN might appear to be a cute but useless esolang,
    much like the original form of ABC from [Chapter 7](ch07.xhtml#ch07). The trick
    of using Gödel numbering to hold the state of the program makes FRACTRAN more
    interesting, but still, it’s just another esolang, though now a clever one.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 初次接触时，FRACTRAN可能看起来像是一个可爱但无用的编程语言，就像[第七章](ch07.xhtml#ch07)中ABC的原始形式一样。使用哥德尔编号来保存程序状态的技巧使FRACTRAN变得更加有趣，但它仍然只是另一种编程语言，尽管现在是一个聪明的语言。
- en: The universality of FRACTRAN adds to its intellectual attractiveness. However,
    the fact that FRACTRAN links Gödel’s incompleteness theorem with Turing’s halting
    problem and Conway’s Collatzian games is brilliant. FRACTRAN is set apart from
    the other languages we’ll explore. I hope it causes you to ponder deeper issues
    related to programming, computation, what can and cannot be known, and what it
    even means to know that you cannot know.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: FRACTRAN的普遍性增加了它的智力吸引力。然而，FRACTRAN将哥德尔不完备定理与图灵停机问题和康威的Collatzian游戏联系起来的这一点非常聪明。FRACTRAN使其与我们将要探讨的其他语言区分开来。我希望它能让你思考编程、计算、可知与不可知的问题，以及“知道无法知道”到底意味着什么。
- en: '**Summary**'
  id: totrans-275
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**总结**'
- en: In this chapter, we explored FRACTRAN, an esolang that at first glance seems
    like nothing more than a clever game. After implementing the language in both
    Racket and Python, we tested it and struggled to understand how it worked. Next,
    we explored multiple examples of FRACTRAN programs to help build our intuition
    about what coding in FRACTRAN entails. Along the way, we learned about the Collatz
    conjecture, itself an interesting intellectual exercise.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一章中，我们探讨了FRACTRAN，一种乍一看似乎只是一个聪明游戏的编程语言。在Racket和Python中实现该语言后，我们对其工作原理进行了测试，并努力理解它是如何运作的。接下来，我们探索了多个FRACTRAN程序示例，以帮助建立对FRACTRAN编程内容的直觉。在此过程中，我们了解了Collatz猜想，它本身也是一个有趣的智力练习。
- en: We closed the chapter by discussing the connections between FRACTRAN, Gödel’s
    incompleteness theorem, Turing’s halting problem, and Collatzian games, all of
    which provide much food for thought.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过讨论FRACTRAN、哥德尔不完备定理、图灵停机问题和Collatzian游戏之间的联系结束了本章，所有这些都提供了丰富的思考素材。
- en: FRACTRAN forced us to think mathematically. Now, let’s mix things up with Piet,
    a language that forces us to think visually.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: FRACTRAN迫使我们从数学的角度思考。现在，让我们用Piet来调剂一下，这是一种迫使我们从视觉角度思考的编程语言。
