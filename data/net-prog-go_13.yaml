- en: '10'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '10'
- en: 'Caddy: A Contemporary Web Server'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: Caddy：一个现代化的Web服务器
- en: '![](image_fi/book_art/chapterart.png)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![](image_fi/book_art/chapterart.png)'
- en: Chapter 9 focused on the web service building blocks available to you in Go’s
    standard library. You learned how to create a simple web server with relatively
    little code by using handlers, middleware, and multiplexers. Although you can
    build a capable web server with those tools alone, writing your own server from
    scratch may not always be the quickest approach. Adding support for logging, metrics,
    authentication, access control, and encryption, to name a few features, can be
    daunting and hard to get right. Instead, you may find it more convenient to use
    an existing, comprehensive web server to host your web services.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 第九章重点介绍了Go标准库中可用于构建Web服务的基础模块。你学习了如何通过使用处理器、中间件和复用器，以相对较少的代码创建一个简单的Web服务器。虽然仅凭这些工具你可以构建一个功能强大的Web服务器，但从头开始编写自己的服务器可能并不是最快捷的方法。添加日志记录、指标、认证、访问控制和加密等功能，举几个例子，这些可能会让人感到困难且难以实现正确。相反，你可能会觉得使用现有的、全面的Web服务器来托管你的Web服务会更方便。
- en: This chapter will introduce you to the Caddy web server and show you how to
    focus your time on writing web services while relying on Caddy to serve your application.
    You’ll get Caddy up and running and then take a dive into its real-time configuration
    API. Next, you’ll learn how to extend Caddy’s functionality by using custom modules
    and configuration adapters. You’ll then use Caddy to serve your application’s
    static files and proxy requests to your web services. Finally, you’ll learn about
    Caddy’s automatic TLS support by using free certificates from Let’s Encrypt and
    automated key management.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将介绍Caddy Web服务器，并展示如何将精力集中在编写Web服务上，而依赖Caddy来托管你的应用程序。你将快速启动Caddy并深入了解其实时配置API。接着，你将学习如何通过使用自定义模块和配置适配器来扩展Caddy的功能。然后，你将使用Caddy来托管应用程序的静态文件并代理请求到你的Web服务。最后，你将了解Caddy的自动TLS支持，通过使用Let’s
    Encrypt提供的免费证书和自动化密钥管理。
- en: 'After reading this chapter, you should feel comfortable choosing the best solution
    for your web applications: either a simple `net/http`-based web server or a comprehensive
    solution like Caddy.'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 阅读完本章后，你应该能够自如地选择适合你的Web应用程序的最佳解决方案：要么是一个基于`net/http`的简单Web服务器，要么是像Caddy这样的全面解决方案。
- en: What Is Caddy?
  id: totrans-6
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 什么是Caddy？
- en: '*Caddy* is a contemporary web server that focuses on security, performance,
    and ease of use. Among its hallmark features, it offers automatic TLS certificate
    management, allowing you to easily implement HTTPS. Caddy also takes advantage
    of Go’s concurrency primitives to serve a considerable amount of all web traffic.
    It’s one of the few open source projects with enterprise-grade support.'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: '*Caddy*是一个现代化的Web服务器，专注于安全性、性能和易用性。作为其标志性特性之一，它提供了自动化TLS证书管理，使你能够轻松实现HTTPS。Caddy还利用Go的并发原语来处理大量Web流量。它是少数几个提供企业级支持的开源项目之一。'
- en: Let’s Encrypt Integration
  id: totrans-8
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Let’s Encrypt集成
- en: '*Let’s Encrypt* is a nonprofit certificate authority that supplies digital
    certificates free of charge for the public to facilitate HTTPS communication.
    Let’s Encrypt certificates run on more than half of all websites on the internet,
    and they’re trusted by all popular web browsers. You can retrieve certificates
    for your website by using Let’s Encrypt’s automated issuance and renewal protocol,
    known as *Automated Certificate Management Environment (ACME)*.'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: '*Let’s Encrypt*是一个非营利性的证书颁发机构，免费为公众提供数字证书，方便进行HTTPS通信。Let’s Encrypt的证书在互联网上超过一半的网站上运行，并且被所有流行的Web浏览器信任。你可以通过使用Let’s
    Encrypt的自动颁发和续订协议，称为*自动证书管理环境（ACME）*，来为你的网站获取证书。'
- en: 'Typically, getting a certificate requires three steps: a certificate request,
    domain validation, and certificate issuance. First, you request a certificate
    for your domain from Let’s Encrypt. Let’s Encrypt then confirms your domain to
    make sure you administer it. Once Let’s Encrypt has ensured that you’re the domain’s
    rightful owner, it issues you a certificate, which your web server can use for
    HTTPS support. Each certificate is good for 90 days, though you should renew it
    every 60 days to prevent service interruption.'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，获取证书需要三个步骤：证书请求、域名验证和证书颁发。首先，你需要向Let’s Encrypt请求你域名的证书。然后，Let’s Encrypt确认你的域名，确保你是该域名的管理员。一旦Let’s
    Encrypt确保你是该域名的合法拥有者，它会为你颁发证书，供你的Web服务器用于HTTPS支持。每个证书有效期为90天，但你应该每60天续订一次，以防止服务中断。
- en: Caddy has inherent support for the ACME protocol and will automatically request,
    validate, and install Let’s Encrypt certificates if Caddy can properly derive
    the domain names it hosts. We’ll discuss how best to do this in “Adding Automatic
    HTTPS” on page 237. Caddy also handles automatic renewals, eliminating the need
    for you to keep track of certificate expiration dates.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: Caddy 原生支持 ACME 协议，如果 Caddy 能正确推导出它托管的域名，它将自动请求、验证并安装 Let’s Encrypt 证书。我们将在第
    237 页的“添加自动 HTTPS”部分讨论如何最佳地实现这一点。Caddy 还处理自动续期，消除了你跟踪证书过期日期的需要。
- en: How Does Caddy Fit into the Equation?
  id: totrans-12
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Caddy 在这个方程中如何适应？
- en: Caddy works just like other popular web servers, such as NGINX and Apache. It’s
    best positioned on the edge of your network, between web clients and your web
    services, as shown in [Figure 10-1](#figure10-1).
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: Caddy的工作方式与其他流行的 web 服务器，如 NGINX 和 Apache 相似。它最适合部署在网络的边缘，位于 web 客户端和 web 服务之间，如[图
    10-1](#figure10-1)所示。
- en: '![f10001](image_fi/500884c10/f10001.png)'
  id: totrans-14
  prefs: []
  type: TYPE_IMG
  zh: '![f10001](image_fi/500884c10/f10001.png)'
- en: 'Figure 10-1: Caddy reverse-proxying client requests to web services'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10-1：Caddy 反向代理客户端请求到 web 服务
- en: Caddy can serve static files and forward requests between clients and backend
    services, a process known as *reverse proxying*. In this example, you can see
    Caddy serving a WordPress blog through PHP’s FastCGI Process Manager (PHP-FPM),
    static files, and a Go-based web service. We’ll replicate a similar setup later
    in the chapter, sans WordPress blog.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: Caddy 可以提供静态文件服务，并在客户端和后端服务之间转发请求，这个过程称为 *反向代理*。在这个例子中，你可以看到 Caddy 通过 PHP 的
    FastCGI 进程管理器（PHP-FPM）、静态文件和基于 Go 的 web 服务提供 WordPress 博客服务。我们将在本章后面复制一个类似的设置，但不包括
    WordPress 博客。
- en: Caddy helps abstract web services from clients in much the same way we use abstraction
    in our code. If you use Caddy’s automatic TLS, static file server, data compression,
    access control, and logging features, you won’t have to add that functionality
    to each web service. In addition, using Caddy has the benefit of allowing you
    to abstract your network topography from clients. As the services increase in
    popularity and the capacity on web services starts to negatively affect clients,
    you can add web services to Caddy and instruct Caddy to balance the load among
    them all, without interruption to your clients.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: Caddy 通过抽象 web 服务与客户端之间的关系，类似于我们在代码中使用抽象的方式。如果你使用 Caddy 的自动 TLS、静态文件服务器、数据压缩、访问控制和日志记录功能，你就不需要在每个
    web 服务中添加这些功能。此外，使用 Caddy 还有一个好处，那就是能够将你的网络拓扑从客户端中抽象出来。随着服务的流行增加，web 服务的容量开始对客户端产生负面影响，你可以将
    web 服务添加到 Caddy 中，并指示 Caddy 在它们之间平衡负载，而不会对客户端造成中断。
- en: Retrieving Caddy
  id: totrans-18
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 获取 Caddy
- en: In this chapter, we’ll use version 2 of Caddy. You have a few options for installation,
    described in this section.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将使用 Caddy 的版本 2。你有几种安装选项，本节将进行说明。
- en: Downloading Caddy
  id: totrans-20
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 下载 Caddy
- en: You can install Caddy by using a static binary, built by the Caddy team. This
    binary is available through the download link at [https://caddyserver.com/](https://caddyserver.com/)*.*
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过使用 Caddy 团队构建的静态二进制文件来安装 Caddy。这个二进制文件可以通过[https://caddyserver.com/](https://caddyserver.com/)上的下载链接获得。*。
- en: Caddy is also available as a Docker image; a DigitalOcean droplet; an Advanced
    Package Tool (APT) source for Debian derivatives; and in the Fedora Copr build
    system for use in Fedora, CentOS, or Red Hat Enterprise Linux. You can find details
    in the Install documentation at [https://caddyserver.com/docs/download](https://caddyserver.com/docs/download).
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: Caddy 还可以作为 Docker 镜像、DigitalOcean 虚拟机、Debian 衍生版的高级包管理工具（APT）源以及 Fedora 的 Copr
    构建系统中的工具来使用，适用于 Fedora、CentOS 或 Red Hat Enterprise Linux。你可以在[https://caddyserver.com/docs/download](https://caddyserver.com/docs/download)的安装文档中找到详细信息。
- en: Building Caddy from Source Code
  id: totrans-23
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 从源代码构建 Caddy
- en: If you do not find a suitable static binary for your operating system and architecture,
    or if you wish to customize Caddy, you can also compile Caddy from source code.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你找不到适合你操作系统和架构的静态二进制文件，或者你希望定制 Caddy，你也可以从源代码编译 Caddy。
- en: 'Caddy relies heavily on Go’s support for modules. Therefore, you need to use
    at least Go 1.14 before running the following commands:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: Caddy 强烈依赖 Go 对模块的支持。因此，在运行以下命令之前，你需要至少使用 Go 1.14：
- en: '[PRE0]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Clone the Caddy Git repository and change to the *caddy/cmd/caddy* subdirectory,
    where you’ll find the `main` package. Run `go build` to create a binary named
    *caddy* in the current directory for your operating system and architecture. To
    simplify commands, the rest of this chapter assumes that the *caddy* binary is
    in your `PATH`.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 克隆 Caddy Git 仓库并切换到 *caddy/cmd/caddy* 子目录，在这里你会找到 `main` 包。运行 `go build` 在当前目录为你的操作系统和架构创建一个名为
    *caddy* 的二进制文件。为了简化命令，本章其余部分假设 *caddy* 二进制文件已添加到你的 `PATH` 中。
- en: While you’re in this subdirectory, make note of the *main.go* file. You’ll revisit
    it later in this chapter when you learn how to customize Caddy by adding modules.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个子目录中，注意 *main.go* 文件。你将在本章稍后学习如何通过添加模块来自定义 Caddy 时再次查看它。
- en: Running and Configuring Caddy
  id: totrans-29
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 运行和配置 Caddy
- en: For configuration purposes, Caddy exposes an administration endpoint on TCP
    port 2019, over which you can interact with Caddy’s configuration in real time.
    You can configure Caddy by posting JSON to this endpoint, and you can read the
    configuration with a `GET` request. Caddy’s full JSON API documentation is available
    at [https://caddyserver.com/docs/json/](https://caddyserver.com/docs/json/).
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 为了配置，Caddy 在 TCP 2019 端口上暴露了一个管理端点，通过这个端点，你可以实时与 Caddy 的配置进行交互。你可以通过向该端点发布 JSON
    来配置 Caddy，也可以通过 `GET` 请求读取配置。Caddy 的完整 JSON API 文档可以在 [https://caddyserver.com/docs/json/](https://caddyserver.com/docs/json/)
    找到。
- en: 'Before you can configure Caddy, you need to start it. Running this command
    starts Caddy as a background process:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 在你配置 Caddy 之前，你需要先启动它。运行此命令将 Caddy 作为后台进程启动：
- en: '[PRE1]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: You’ll see log entries showing that the admin endpoint started and Caddy is
    using the initial configuration. You’ll also see log entries printed to standard
    output as you interact with the admin endpoint.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 你会看到日志条目，显示管理员端点已启动，Caddy 正在使用初始配置。你还会看到日志条目在与管理员端点交互时打印到标准输出。
- en: Caddy’s configuration is empty by default. Let’s send meaningful configuration
    data to Caddy. [Listing 10-1](#listing10-1) uses the `curl` command to post JSON
    to the `load` resource on Caddy’s admin endpoint.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: Caddy 的配置默认是空的。让我们发送有意义的配置数据到 Caddy。[列表 10-1](#listing10-1) 使用 `curl` 命令将 JSON
    发布到 Caddy 管理员端点上的 `load` 资源。
- en: '[PRE2]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Listing 10-1: Posting configuration to Caddy’s admin endpoint'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 10-1：将配置发布到 Caddy 的管理员端点
- en: You send a `POST` request containing JSON in the request body 1 to the `load`
    resource of the Caddy instance listening on port 2019\. The top-level `apps` namespace
    lists the applications Caddy will load at runtime. In this case, you’re telling
    Caddy to load the `http` application. The `http` application configuration consists
    of one or more servers. This example sets up a single server named `hello` listening
    on localhost port 2020\. Feel free to name your server whatever you’d like.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 你向 Caddy 实例监听的 2019 端口的 `load` 资源发送一个包含 JSON 请求体的 `POST` 请求 1。顶级的 `apps` 命名空间列出了
    Caddy 在运行时将加载的应用程序。在本例中，你告诉 Caddy 加载 `http` 应用程序。`http` 应用程序的配置由一个或多个服务器组成。此示例设置了一个名为
    `hello` 的服务器，监听 localhost 的 2020 端口。你可以自由地为你的服务器命名。
- en: Since the `listen` value is an array of addresses, you can configure this server
    to listen to more than one socket address. Caddy passes these address values to
    `net.Listen`, just as you did in Chapter 3. You also have the option of specifying
    a port range, such as *localhost:2020-2025*. Caddy will recognize that you used
    a range and properly extrapolate the range into separate socket addresses. Caddy
    allows you to restrict listeners to specific network types by prefixing the socket
    address. For example, *udp/localhost:2020* tells the server to bind to UDP port
    2020 on localhost. The forward slash is not part of the address but rather a separator.
    If you want the server to bind to a Unix socket */tmp/caddy.sock*, specify the
    address *unix//tmp/caddy.sock*.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 `listen` 值是一个地址数组，你可以配置该服务器监听多个套接字地址。Caddy 会将这些地址值传递给 `net.Listen`，就像你在第
    3 章中所做的那样。你还可以选择指定一个端口范围，例如 *localhost:2020-2025*。Caddy 会识别你使用了一个范围，并正确地将该范围扩展为单独的套接字地址。Caddy
    允许你通过在套接字地址前缀添加特定的网络类型来限制监听器。例如，*udp/localhost:2020* 告诉服务器绑定到 localhost 上的 UDP
    2020 端口。斜杠不是地址的一部分，而是一个分隔符。如果你希望服务器绑定到 Unix 套接字 */tmp/caddy.sock*，可以指定地址 *unix//tmp/caddy.sock*。
- en: The `hello` server’s `routes` value 2 is an array of routes, like the multiplexer
    from the preceding chapter, which dictates how the server will handle incoming
    requests. If a route matches the request, Caddy passes the request onto each handler
    in the `handle` array. Since `handle` is an array, you can specify more than one
    handler per route. Caddy will pass the request to each successive handler in the
    same way you chained middleware together in the preceding chapter. In this example,
    you specify a single route to match all requests and add a single handler to this
    route. You’re using the built-in `static_response` handler 3, which will write
    the value of the `body` (`Hello, world!` in this example) in the response body.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: '`hello`服务器的`routes`值是一个路由数组，类似于前一章中的多路复用器，它规定了服务器如何处理传入的请求。如果某个路由匹配请求，Caddy
    会将请求传递给`handle`数组中的每个处理器。由于`handle`是一个数组，你可以为每个路由指定多个处理器。Caddy 会将请求传递给每个后续处理器，方式就像你在前一章中将中间件连接起来一样。在这个例子中，你为所有请求指定了一个路由，并为这个路由添加了一个处理器。你使用的是内置的`static_response`处理器，它将在响应体中写入`body`的值（在这个例子中是`Hello,
    world!`）。'
- en: 'Provided there are no errors in the configuration, Caddy will at once start
    using the new configuration. Let’s confirm Caddy is now listening on both the
    administrative port 2019 and your `hello` server port 2020:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 只要配置没有错误，Caddy 会立即开始使用新配置。让我们确认 Caddy 现在同时在管理端口2019和你的`hello`服务器端口2020上监听：
- en: '[PRE3]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Looks good. This command won’t work on Windows. Instead, you can see similar
    output by running the `netstat -b` command in an Administrator command prompt.
    Now, you can ask Caddy for its configuration by sending a `GET` request:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 看起来不错。这个命令在 Windows 上无法使用。相反，你可以通过在管理员命令提示符下运行`netstat -b`命令，查看类似的输出。现在，你可以通过发送`GET`请求来请求
    Caddy 的配置：
- en: '[PRE4]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Caddy returns its JSON-formatted configuration in the response body. Note that
    you need to write the trailing slash on the `/config/` resource, because `/config/`
    is the resource prefix under which Caddy exposes its configuration. You are asking
    Caddy for all resources found under the /`config/` prefix. If you accidentally
    omit the trailing slash, Caddy thinks you’re asking for an absolute resource named
    `/config`, which doesn’t exist in Caddy’s admin API on port 2019.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: Caddy 在响应体中返回其 JSON 格式的配置。请注意，你需要在`/config/`资源后写上斜杠，因为`/config/`是 Caddy 暴露其配置的资源前缀。你是在请求所有位于`/config/`前缀下的资源。如果你不小心省略了尾部斜杠，Caddy
    会认为你在请求名为`/config`的绝对资源，但该资源在 Caddy 的管理 API 上并不存在（端口2019）。
- en: 'Caddy supports *configuration traversal*. Configuration traversal lets you
    request a subset of the configuration by treating each JSON key in the configuration
    data as a resource address. For example, you can request the `listen` value for
    the `hello` server from our example configuration by issuing a `GET` request,
    like this:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: Caddy 支持*配置遍历*。配置遍历允许你通过将配置数据中的每个 JSON 键视为资源地址，来请求配置的一个子集。例如，你可以通过发送一个`GET`请求来请求我们示例配置中`hello`服务器的`listen`值，方式如下：
- en: '[PRE5]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Caddy returns a JSON array containing *localhost:2020*, just as you’d expect.
    Let’s send a `GET` request to this socket address:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: Caddy 返回一个包含*localhost:2020*的 JSON 数组，正如你所期望的那样。让我们向这个套接字地址发送一个`GET`请求：
- en: '[PRE6]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: You see the `Hello, world!` string returned from the `static_response` handler.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 你看到从`static_response`处理器返回的`Hello, world!`字符串。
- en: Modifying Caddy’s Configuration in Real Time
  id: totrans-50
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 实时修改 Caddy 的配置
- en: You can use the other HTTP verbs you learned in Chapter 8 to modify your server’s
    configuration. Any changes you make will take immediate effect, so long as Caddy
    can parse the JSON you send. If Caddy fails to parse the JSON, or if a fundamental
    error exists in the new configuration, Caddy will log an error with an explanation
    of what went wrong and continue to use its existing configuration.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用第8章中学到的其他HTTP方法来修改服务器的配置。只要 Caddy 能解析你发送的 JSON，任何修改都会立即生效。如果 Caddy 无法解析
    JSON，或者新配置中存在基础错误，Caddy 会记录错误并解释出错的原因，继续使用现有配置。
- en: 'Let’s say you want to make your `hello` server listen on port 2021 as well.
    You can append another `listen` value by using a `POST` request and immediately
    check that the change took effect:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你想让你的`hello`服务器也监听2021端口。你可以通过发送一个`POST`请求来附加另一个`listen`值，并立即检查修改是否生效：
- en: '[PRE7]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: You can see that Caddy is now listening on port 2021 1 in addition to ports
    2019 and 2020\.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以看到，除了2019和2020端口，Caddy现在还在监听2021端口。
- en: 'Suppose you want to replace the listening addresses and use a range instead.
    For that, you can send a `PATCH` request with the new `listen` array value you
    want Caddy to use:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你想替换监听地址并改用范围。在这种情况下，你可以发送一个`PATCH`请求，包含你希望Caddy使用的新`listen`数组值：
- en: '[PRE8]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: In addition to the admin port 2019, Caddy is now listening on ports 2020 1 through
    2025 2.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 除了管理员端口2019，Caddy现在还在端口2020至2025之间监听。
- en: Although you may not find yourself changing Caddy’s configuration on the fly
    very often, it’s a handy feature for development, because it lets you quickly
    spin up a new server to add functionality. Let’s add a new server to Caddy while
    it’s running. You’ll name this new server `test` and configure it to listen on
    port 2030\. [Listing 10-2](#listing10-2) adds the new `test` server to Caddy in
    real time.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管你可能不会经常需要在运行时更改Caddy的配置，但它是开发中一个非常有用的功能，因为它允许你快速启动一个新服务器来添加功能。让我们在Caddy运行时添加一个新服务器。你将为这个新服务器命名为`test`，并将其配置为监听2030端口。[列表10-2](#listing10-2)在实时中将新的`test`服务器添加到Caddy。
- en: '[PRE9]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Listing 10-2: Adding a new server to Caddy in real time'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 列表10-2：实时向Caddy添加新服务器
- en: 'The name of the new server, `test`, is part of the resource you `POST` to.
    You can think of `test` as the key and the JSON in the request body as the value,
    if you defined this server in the original configuration from [Listing 10-1](#listing10-1).
    At this point, Caddy has two servers: `hello` listening on ports 2020 to 2025
    and `test` listening on port 2030\. To confirm Caddy is serving `test`, you can
    check the new endpoint on port 2030:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 新服务器的名称`test`是你通过`POST`请求的资源的一部分。如果你在[列表10-1](#listing10-1)的原始配置中定义了这个服务器，你可以把`test`看作是键，请求正文中的JSON看作是值。此时，Caddy有两个服务器：`hello`监听2020至2025端口，`test`监听2030端口。要确认Caddy正在服务`test`，你可以检查2030端口上的新端点：
- en: '[PRE10]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'The `static_response` handler properly responds with the expected message.
    If you want to remove the `test` server, it’s as simple as issuing a `DELETE`
    request:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: '`static_response`处理器正确地响应了预期的消息。如果你想移除`test`服务器，只需发出一个`DELETE`请求：'
- en: '[PRE11]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Here again, you specify the `test` server in the resource. Caddy is no longer
    listening on localhost port 2030, and the test server no longer exists. You were
    able to stand up a new server to handle entirely different requests without interrupting
    the functionality of your `hello` server. Changing the configuration in real time
    opens possibilities. Do you want a server or route to be accessible only certain
    times of the day? No problem. Do you want to temporarily redirect traffic without
    having to bounce your entire web server, interrupting existing web traffic? Sure,
    go ahead.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，你再次在资源中指定了`test`服务器。Caddy不再在localhost的2030端口上监听，且`test`服务器不再存在。你能够启动一个新的服务器来处理完全不同的请求，而不会中断`hello`服务器的功能。实时更改配置为你打开了更多的可能性。你是否希望服务器或路由仅在某些时间段内可访问？没问题。你是否希望临时重定向流量，而无需重新启动整个Web服务器，避免中断现有Web流量？当然，去做吧。
- en: Storing the Configuration in a File
  id: totrans-66
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 将配置存储在文件中
- en: 'We typically provide Caddy with its configuration as part of the startup process.
    Write the JSON configuration from [Listing 10-1](#listing10-1) to a file named
    *caddy.json*. Then start Caddy by using the following command:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通常会在启动过程中向Caddy提供配置。将[列表10-1](#listing10-1)中的JSON配置写入名为*caddy.json*的文件。然后使用以下命令启动Caddy：
- en: '[PRE12]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Caddy starts in the background, as in [Listing 10-1](#listing10-1)—but this
    time, it populates its configuration from the *caddy.json* file during initialization.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: Caddy像[列表10-1](#listing10-1)中那样在后台启动——但这次，它在初始化期间从*caddy.json*文件中加载配置。
- en: Extending Caddy with Modules and Adapters
  id: totrans-70
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 通过模块和适配器扩展Caddy
- en: Caddy uses a modular architecture to organize its functionality. This modular
    approach allows you to extend Caddy’s capabilities by writing your own modules
    and configuration adapters. In this section, we’ll walk through the process of
    writing a configuration adapter that will allow you to store your Caddy configuration
    in a Tom’s Obvious, Minimal Language (TOML) file. We’ll also replicate the `restrict_prefix`
    middleware from the preceding chapter in a proper Caddy module.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: Caddy采用模块化架构来组织其功能。这种模块化方法允许你通过编写自己的模块和配置适配器来扩展Caddy的功能。在本节中，我们将介绍编写一个配置适配器的过程，该适配器将允许你将Caddy的配置存储在Tom's
    Obvious Minimal Language（TOML）文件中。我们还将在适当的Caddy模块中复制前一章的`restrict_prefix`中间件。
- en: Writing a Configuration Adapter
  id: totrans-72
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 编写配置适配器
- en: Although JSON is a perfectly good format for configuration files, it isn’t as
    well suited for human consumption as other formats. JSON lacks support for comments
    and multiline strings, two characteristics that make configuration files easier
    for people to read. Caddy supports the use of *configuration adapters* that adapt
    one format, such as TOML, to Caddy’s native JSON format. TOML is a configuration
    file format that is easy for humans to read. It supports both comments and multiline
    strings. You can find more details at [https://github.com/toml-lang/toml/tree/v0.5.0/](https://github.com/toml-lang/toml/tree/v0.5.0/).
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然 JSON 是一种非常适合配置文件的格式，但它不像其他格式那样适合人类阅读。JSON 不支持注释和多行字符串，而这两者恰恰是让配置文件更易于人类阅读的特性。Caddy
    支持使用 *配置适配器*，将一种格式（如 TOML）适配为 Caddy 的本地 JSON 格式。TOML 是一种易于人类阅读的配置文件格式，支持注释和多行字符串。你可以在[https://github.com/toml-lang/toml/tree/v0.5.0/](https://github.com/toml-lang/toml/tree/v0.5.0/)找到更多细节。
- en: 'Caddy version 1 supported a custom configuration file format named *Caddyfile*,
    which was also the name of the configuration file by convention. If you want to
    use Caddyfile with Caddy v2, you must rely on a configuration adapter so Caddy
    can ingest it. Caddy is smart enough to know it needs to use the `caddyfile` adapter
    when you specify a filename that starts with *Caddyfile*. But to specify an adapter
    from the command line, you explicitly tell Caddy which adapter to use:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: Caddy 版本 1 支持一种名为 *Caddyfile* 的自定义配置文件格式，按照约定，配置文件也通常使用这个名字。如果你希望在 Caddy v2
    中使用 Caddyfile，必须依赖配置适配器，以便 Caddy 可以读取它。当你指定一个以 *Caddyfile* 开头的文件名时，Caddy 足够聪明，知道需要使用
    `caddyfile` 适配器。但如果你想从命令行指定适配器，你需要明确告诉 Caddy 使用哪个适配器：
- en: '[PRE13]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The `adapter` flag tells Caddy which adapter it should use. Caddy will invoke
    the adapter to adapt the configuration file to JSON and then parse the JSON returned
    by the adapter as if you had presented the configuration in JSON format in the
    first place.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: '`adapter` 标志告诉 Caddy 应该使用哪个适配器。Caddy 会调用适配器将配置文件适配成 JSON 格式，然后像处理原本以 JSON 格式提供的配置一样，解析适配器返回的
    JSON。'
- en: 'But Caddy doesn’t ship with an official configuration adapter for TOML, so
    let’s take a crack at writing one. You need to first create a Go module for your
    TOML configuration adapter:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 但 Caddy 并没有附带一个官方的 TOML 配置适配器，所以让我们尝试编写一个。你需要先为 TOML 配置适配器创建一个 Go 模块：
- en: '[PRE14]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: You should use a fully qualified module name 1 different from the one used here.
    I created this module on GitHub under my *awoodbeck* account. The fully qualified
    name for your module will differ depending on where, and under what account, it’s
    hosted.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该使用一个完全限定的模块名 1，与此处使用的不同。我是在 GitHub 上通过我的 *awoodbeck* 账户创建了这个模块。你的模块的完全限定名称将根据其托管的位置和账户不同而有所不同。
- en: Now that you’ve created a module, you can write the code. Create a file in the
    current directory named *toml.go* and add the code in [Listing 10-3](#listing10-3).
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经创建了一个模块，可以开始编写代码了。在当前目录下创建一个名为 *toml.go* 的文件，并将代码添加到[清单 10-3](#listing10-3)中。
- en: '[PRE15]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Listing 10-3: Creating a TOML configuration adapter and registering it with
    Caddy'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 清单 10-3：创建一个 TOML 配置适配器并将其注册到 Caddy
- en: You use Thomas Pelletier’s *go-toml* library to parse the configuration file
    contents 3. This saves a considerable amount of code. You then convert the parsed
    TOML into a map 4 and marshal the map to JSON.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 你使用 Thomas Pelletier 的 *go-toml* 库来解析配置文件内容 3。这可以节省大量的代码。然后你将解析后的 TOML 转换成一个映射
    4，并将这个映射序列化为 JSON。
- en: The last bit of accounting is to register your configuration adapter with Caddy.
    For this, you include a call to `caddyconfig.RegisterAdapter` in the `init` function
    and pass it the adapter’s type 1 and an `Adapter` object 2 implementing the `caddyconfig.Adapter`
    interface. When you import this module from Caddy’s *main.go* file, the configuration
    adapter registers itself with Caddy, adding support for parsing the TOML configuration
    file. You’ll look at a concrete example of importing this module from Caddy in
    “Injecting Your Module into Caddy” on page 231.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一步是将你的配置适配器注册到 Caddy。为此，你需要在 `init` 函数中调用 `caddyconfig.RegisterAdapter` 并传入适配器的类型
    1 和一个实现 `caddyconfig.Adapter` 接口的 `Adapter` 对象 2。当你从 Caddy 的 *main.go* 文件中导入这个模块时，配置适配器会自动注册到
    Caddy 中，为解析 TOML 配置文件提供支持。在第 231 页的“将模块注入 Caddy”部分，你将看到如何从 Caddy 中导入这个模块的具体示例。
- en: 'Now that you’ve created the *toml.go* file, tidy up the module:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经创建了 *toml.go* 文件，可以整理一下模块：
- en: '[PRE16]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: This command adds the Caddy dependency to the *go.mod* file. All that’s left
    to do is to publish your module to GitHub, as in this example, or another suitable
    version-control system supported by `go get`.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 该命令将 Caddy 依赖项添加到*go.mod*文件中。剩下的工作就是像这个示例一样将你的模块发布到 GitHub，或者其他支持`go get`的合适版本控制系统。
- en: Writing a Restrict Prefix Middleware Module
  id: totrans-88
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 编写 Restrict Prefix 中间件模块
- en: Chapter 9 introduced the concept of middleware, a design pattern that allows
    your code to manipulate a request and a response and to perform ancillary tasks
    when the server receives a request, such as logging request details. Let’s explore
    how to use middleware with Caddy.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 第 9 章介绍了中间件的概念，这是一种设计模式，它允许你的代码在服务器接收请求时操作请求和响应，并执行辅助任务，例如记录请求详情。让我们探讨如何在 Caddy
    中使用中间件。
- en: 'In Go, middleware is a function that accepts an `http.Handler` and returns
    an `http.Handler`:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Go 中，中间件是一个接受`http.Handler`并返回`http.Handler`的函数：
- en: '[PRE17]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'An `http.Handler` describes an object with a `ServeHTTP` method that accepts
    an `http.RequestWriter` and an `http.Request`:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: '`http.Handler`描述了一个具有`ServeHTTP`方法的对象，该方法接受`http.RequestWriter`和`http.Request`：'
- en: '[PRE18]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: The handler reads from the request and writes to the response. Assuming `myHandler`
    is an object that implements the `http.Handler` interface, and `middleware1`,
    `middleware2`, and `middleware3` all accept an `http.Handler` and return an `http.Handler`,
    you can apply the middleware functions to `myHandler` in [Listing 10-4](#listing10-4).
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 处理器从请求中读取并写入响应。假设`myHandler`是一个实现了`http.Handler`接口的对象，并且`middleware1`、`middleware2`和`middleware3`都接受一个`http.Handler`并返回一个`http.Handler`，你可以在[示例
    10-4](#listing10-4)中将中间件函数应用到`myHandler`上。
- en: '[PRE19]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Listing 10-4: Multiple middleware functions wrapping a handler'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 10-4：多个中间件函数包装一个处理器
- en: You can replace any of the middleware functions with the `RestrictPrefix` middleware
    you wrote in the preceding chapter, since it’s a function that accepts an `http.Handler`
    and returns an `http.Handler`.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以用你在前一章中编写的`RestrictPrefix`中间件替换任何一个中间件函数，因为它是一个接受`http.Handler`并返回`http.Handler`的函数。
- en: 'Unfortunately for us, Caddy’s middleware does not use this design pattern,
    so it cannot use `RestrictPrefix`. Caddy includes interfaces for both handlers
    and middleware, unlike `net/http`, which describes only handlers. Caddy’s equivalent
    of the `http.Handler` interface is `caddyhttp.Handler`:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，Caddy 的中间件并未使用这种设计模式，因此不能使用`RestrictPrefix`。Caddy 包含了处理器和中间件的接口，这与`net/http`不同，后者仅描述处理器。Caddy
    中与`http.Handler`接口等效的是`caddyhttp.Handler`：
- en: '[PRE20]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: The only difference between `caddyhttp.Handler` and `http.Handler` is that the
    former’s `ServeHTTP` method returns an `error` interface.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: '`caddyhttp.Handler`和`http.Handler`之间唯一的区别是前者的`ServeHTTP`方法返回一个`error`接口。'
- en: 'Caddy middleware is a special type of handler that implements the `caddyhttp.MiddlewareHandler`
    interface:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: Caddy 中间件是一种特殊类型的处理器，它实现了`caddyhttp.MiddlewareHandler`接口：
- en: '[PRE21]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Like `caddyhttp.Handler`, Caddy’s middleware accepts both an `http.ResponseWriter`
    and an `http.Request`, and it returns an `error` interface. But it accepts an
    additional argument: the `caddyhttp.Handler`, downstream from the middleware in
    the same way that `myHandler` is downstream from `middleware3` in [Listing 10-4](#listing10-4).
    Instead of accepting an `http.Handler` and returning an `http.Handler`, Caddy
    expects its middleware to act as handlers, with access to the `caddyhttp.Handler`
    that should receive the request and response after the middleware is done with
    them.'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 与`caddyhttp.Handler`类似，Caddy 的中间件同时接受`http.ResponseWriter`和`http.Request`，并返回一个`error`接口。但它接受一个额外的参数：`caddyhttp.Handler`，这个处理器位于中间件之后，类似于`myHandler`位于`middleware3`之后的方式，在[示例
    10-4](#listing10-4)中。Caddy 中间件并不接受一个`http.Handler`并返回一个`http.Handler`，而是期望它充当处理器，并且在中间件处理完请求和响应之后，可以访问`caddyhttp.Handler`。
- en: 'Let’s create a new Caddy module that replicates the functionality of your `RestrictPrefix`
    middleware:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一个新的 Caddy 模块，复制你的`RestrictPrefix`中间件的功能：
- en: '[PRE22]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: As before, your fully qualified module name will differ from mine. Create a
    new file named *restrict_prefix.go* and add the code from [Listing 10-5](#listing10-5)
    to the file.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，你的完全限定模块名会与你的不同。创建一个名为*restrict_prefix.go*的新文件，并将[示例 10-5](#listing10-5)中的代码添加到该文件中。
- en: '[PRE23]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Listing 10-5: Defining and registering a new Caddy module'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 10-5：定义并注册一个新的 Caddy 模块
- en: The `RestrictPrefix` middleware implementation from the preceding chapter expected
    the prefix of a URL path as a string. Here, you’re storing the prefix in the `RestrictPrefix`
    struct 2 and assigning it a struct tag to use the `json.Unmarshal` behavior of
    matching incoming keys to struct tags. The struct tag tells `json.Unmarshal` which
    JSON key corresponds to this field. In this example, you’re telling `json.Unmarshal`
    that it should take the value associated with the `prefix` key in the JSON configuration
    and assign it to the struct’s `Prefix` field. The `RestrictPrefix` struct also
    has a `logger` field 3 so you can log events, as necessary.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 来自上一章的`RestrictPrefix`中间件实现预期URL路径的前缀是一个字符串。在这里，你将前缀存储在`RestrictPrefix`结构体中，并为其分配一个结构体标签，以使用`json.Unmarshal`行为，将传入的键与结构体标签进行匹配。结构体标签告诉`json.Unmarshal`哪个JSON键对应此字段。在这个示例中，你告诉`json.Unmarshal`应该取JSON配置中与`prefix`键相关联的值，并将其赋给结构体的`Prefix`字段。`RestrictPrefix`结构体还有一个`logger`字段，3
    这样你就可以根据需要记录事件。
- en: Your module needs to register itself with Caddy upon initialization 1. The `caddy.RegisterModule`
    function accepts any object that implements the `caddy.Module` interface. For
    that, you add the `CaddyModule` method 4 to return information to Caddy about
    your module. Caddy requires an ID 5 for each module. Since you’re creating an
    HTTP middleware handler, you’ll use the ID `http.handler.restrict_prefix`, where
    `restrict_prefix` is the unique name of your module. Caddy also expects a function
    6 that can create a new instance of your module.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 你的模块需要在初始化时向Caddy注册1。`caddy.RegisterModule`函数接受任何实现了`caddy.Module`接口的对象。为此，你添加了`CaddyModule`方法4来返回有关你的模块的信息给Caddy。Caddy要求每个模块都有一个ID5。由于你正在创建一个HTTP中间件处理程序，你将使用ID`http.handler.restrict_prefix`，其中`restrict_prefix`是你模块的唯一名称。Caddy还期望一个函数6，用来创建你模块的新实例。
- en: Now that you can register your module with Caddy, let’s add more functionality
    so you can retrieve the logger from Caddy and validate your module’s settings.
    [Listing 10-6](#listing10-6) picks up where we left off.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你可以将模块注册到Caddy，让我们添加更多功能，以便你可以从Caddy检索日志记录器并验证模块的设置。[列表10-6](#listing10-6)接着我们之前的内容。
- en: '[PRE24]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Listing 10-6: Implementing various Caddy interfaces'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 列表10-6：实现各种Caddy接口
- en: You add the `Provision` method 1 to your struct. Caddy will recognize that your
    module implements the `caddy.Provisioner` interface and call this method. You
    can then retrieve the logger from the given `caddy.Context`2. Likewise, Caddy
    will call your module’s `Validate` method 3 since it implements the `caddy.Validator`
    interface. You can use this method to make sure all required settings have been
    unmarshaled from the configuration into your module. If anything goes wrong, you
    can return an error and Caddy will complain on your behalf. In this example, you’re
    using this method to set the default prefix if one was not provided in the configuration.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 你向结构体中添加了`Provision`方法1。Caddy会识别到你的模块实现了`caddy.Provisioner`接口，并调用该方法。然后，你可以从给定的`caddy.Context`2中获取日志记录器。同样，Caddy会调用你模块的`Validate`方法3，因为它实现了`caddy.Validator`接口。你可以使用此方法确保所有必需的设置都已从配置中反序列化到模块中。如果出现问题，你可以返回错误，Caddy会代表你发出警告。在这个示例中，你使用此方法来设置默认的前缀，如果配置中没有提供前缀的话。
- en: You’re almost done. The last piece of the puzzle is the middleware implementation
    itself. [Listing 10-7](#listing10-7) rounds out your module’s implementation by
    adding support for the `caddyhttp.MiddlewareHandler` interface.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 你快完成了。最后一步是实现中间件本身。[列表10-7](#listing10-7)通过添加对`caddyhttp.MiddlewareHandler`接口的支持，完成了你的模块实现。
- en: '[PRE25]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Listing 10-7: Implementing the `MiddlewareHandler` interface'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 列表10-7：实现`MiddlewareHandler`接口
- en: The logic is almost identical to the middleware from the preceding chapter.
    You loop through the URL path components, checking each one for the prefix 1.
    If you find a match, you respond with a 404 Not Found status 2 and log the occurrence
    for debugging purposes 3. If everything checks out, you pass control onto the
    next handler in the chain 4.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 逻辑几乎与上一章的中间件完全相同。你遍历URL路径组件，检查每个路径是否有前缀1。如果找到匹配项，你会返回404 Not Found状态2，并记录该事件以便调试3。如果一切检查通过，你将控制权传递给链中的下一个处理程序4。
- en: It’s a good practice to guard against interface changes by explicitly making
    sure your module implements the expected interfaces 5. If one of these interfaces
    happens to change in the future (for example, if you add a new method), these
    interface guards will cause compilation to fail, giving you an early warning that
    you need to adapt your code.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 做好防范接口变更的措施是一种好习惯，明确确保你的模块实现了预期的接口 5。如果将来其中一个接口发生变化（例如，添加了新方法），这些接口保护将导致编译失败，提前警告你需要调整代码。
- en: 'The final steps are to tidy up your module’s dependencies and publish it:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 最后的步骤是整理你的模块依赖并发布它：
- en: '[PRE26]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Publish your module to GitHub or a similar version-control system supported
    by `go get`.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 将你的模块发布到 GitHub 或类似的版本控制系统，以便通过 `go get` 使用。
- en: Injecting Your Module into Caddy
  id: totrans-123
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 将你的模块注入 Caddy
- en: 'The module and adapter you wrote are both self-registering. All you need to
    do to include their functionality in Caddy is to import them at build time. To
    do that, you need to compile Caddy from source. Start by making a directory for
    your build:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 你编写的模块和适配器都是自注册的。要在 Caddy 中包含它们的功能，你需要在构建时导入它们。为此，你需要从源代码编译 Caddy。首先为你的构建创建一个目录：
- en: '[PRE27]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Building Caddy from source code requires a small amount of boilerplate code,
    to which you’ll include your modules. Your modules register themselves with Caddy
    as a side effect of the import. Create a new file named *main.go* and add the
    code from [Listing 10-8](#listing10-8) into it.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 从源代码构建 Caddy 需要一些基础代码，你将把你的模块包含在其中。你的模块会在导入时自动注册到 Caddy 中。创建一个新的文件，命名为 *main.go*，并将
    [清单 10-8](#listing10-8) 中的代码添加到其中。
- en: '[PRE28]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Listing 10-8: Injecting custom modules into Caddy'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 清单 10-8：将自定义模块注入 Caddy
- en: First, you import the Caddy command module 1 into your build. This has the `Main`
    function that starts the caddy server. Then, you import the standard modules 2
    that you’ll find in Caddy’s binary distribution. Finally, you include your restrict
    prefix module 3 and your TOML configuration adapter 4.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，你将 Caddy 命令模块 1 导入到构建中。这个模块包含启动 Caddy 服务器的 `Main` 函数。然后，你导入 Caddy 二进制分发包中找到的标准模块
    2。最后，你包含了你的限制前缀模块 3 和 TOML 配置适配器 4。
- en: 'All that’s left to do now is initialize the `caddy` module and build it:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 现在剩下的工作就是初始化 `caddy` 模块并进行构建：
- en: '[PRE29]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'At this point, you should have a binary named `caddy` in the current directory.
    You can verify that it has your custom imports by looking for them in the `caddy`
    binary’s list of modules. The following command is specific to Linux and macOS:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 此时，你应该在当前目录中有一个名为 `caddy` 的二进制文件。你可以通过查看 `caddy` 二进制文件中的模块列表来验证它是否包含你的自定义导入。以下命令适用于
    Linux 和 macOS：
- en: '[PRE30]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'For my Windows friends, run this command instead:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我的 Windows 用户，改为运行以下命令：
- en: '[PRE31]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: The `caddy` binary you built can read its configuration from TOML files and
    deny clients access to resources whose path includes a given prefix.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 你构建的 `caddy` 二进制文件可以从 TOML 文件中读取配置，并拒绝客户端访问包含给定前缀的路径中的资源。
- en: Reverse-Proxying Requests to a Backend Web Service
  id: totrans-137
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 反向代理请求到后台 Web 服务
- en: You now have all the building blocks to create something meaningful in Caddy.
    Let’s put everything you’ve learned together by configuring Caddy to reverse-proxy
    requests to a backend web service and serve up static files on behalf of the backend
    web service. You’ll create two endpoints in Caddy. The first endpoint will serve
    up only static content from Caddy’s file server, showing Caddy’s static file-serving
    abilities. The second endpoint will reverse-proxy requests to a backend web service.
    This backend service will send the client HTML that will prompt the client to
    retrieve static files from Caddy, which will show how your web services can lean
    on Caddy to serve static content on their behalf.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你已经具备了在 Caddy 中创建有意义功能所需的所有构建块。让我们通过配置 Caddy，将其设置为反向代理请求到后台 Web 服务，并代表后台
    Web 服务提供静态文件，从而将你学到的所有知识结合起来。你将在 Caddy 中创建两个端点。第一个端点只会从 Caddy 的文件服务器提供静态内容，展示
    Caddy 的静态文件服务功能。第二个端点会反向代理请求到后台 Web 服务。这个后台服务将向客户端发送 HTML，并提示客户端从 Caddy 获取静态文件，这将展示你的
    Web 服务如何依赖 Caddy 来代表它们提供静态内容。
- en: 'Before you start building, you need to set up the proper directory structure.
    If you’re following along, you’re currently in the *caddy* directory, which has
    a `caddy` binary built from the code in [Listing 10-8](#listing10-8). Create two
    subdirectories, *files* and *backend*:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 在开始构建之前，你需要设置正确的目录结构。如果你在跟随教程，你现在应该在 *caddy* 目录下，该目录中包含从 [清单 10-8](#listing10-8)
    中的代码构建的 `caddy` 二进制文件。创建两个子目录，分别为 *files* 和 *backend*：
- en: '[PRE32]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: You can retrieve the contents of the *files* subdirectory from [https://github.com/awoodbeck/gnp/tree/master/ch10/files/](https://github.com/awoodbeck/gnp/tree/master/ch10/files/).
    The *backend* subdirectory will store a simple backend service created in the
    next section.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以从 [https://github.com/awoodbeck/gnp/tree/master/ch10/files/](https://github.com/awoodbeck/gnp/tree/master/ch10/files/)
    获取 *files* 子目录的内容。*backend* 子目录将存储在下一部分创建的简单后端服务。
- en: Creating a Simple Backend Web Service
  id: totrans-142
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建一个简单的后端 Web 服务
- en: You need a backend web service for Caddy to reverse-proxy requests to, as illustrated
    in [Figure 10-1](#figure10-1). This service will respond to all requests with
    an HTML document that includes the static files Caddy serves on the service’s
    behalf.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 你需要一个后端 Web 服务，以便 Caddy 将请求反向代理到它，如 [图 10-1](#figure10-1) 所示。该服务将以 HTML 文档响应所有请求，并包含
    Caddy 代表该服务提供的静态文件。
- en: '[Listing 10-9](#listing10-9) is the initial code for the backend web service.'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: '[清单 10-9](#listing10-9) 是后端 Web 服务的初始代码。'
- en: '[PRE33]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Listing 10-9: Creating a backend service (*backend/main.go*)'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 清单 10-9：创建后端服务 (*backend/main.go*)
- en: This bit of code should be familiar since it’s a simplified version of what
    you wrote in the preceding chapter. You’re setting up a web service that listens
    on port 8080 of localhost 1. Caddy will direct requests to this socket address.
    [Listing 10-10](#listing10-10) implements the `run` function 2.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码应该很熟悉，因为它是你在上一章中写的代码的简化版。你正在设置一个监听本地主机 8080 端口的 Web 服务 1。Caddy 将把请求导向这个套接字地址。[清单
    10-10](#listing10-10) 实现了 `run` 函数 2。
- en: '[PRE34]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Listing 10-10: The main logic of the backend service (*backend/main.go*)'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 清单 10-10：后端服务的主要逻辑 (*backend/main.go*)
- en: The web service receives all requests from Caddy, no matter which client originated
    the request. Likewise, it sends all responses back to Caddy, which then routes
    the response to the right client. Conveniently, Caddy adds an `X-Forwarded-For`
    header 1 to each request with the originating client’s IP address. Although you
    don’t do anything other than log this information, your backend service could
    use this IP address to differentiate between client requests. The service could
    deny requests based on client IP address, for example.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: Web 服务接收来自 Caddy 的所有请求，无论哪个客户端发起了请求。同样，它将所有响应发送回 Caddy，后者再将响应路由到正确的客户端。方便的是，Caddy
    会在每个请求中添加一个 `X-Forwarded-For` 头 1，包含发起客户端的 IP 地址。虽然你不会做任何处理，仅仅记录此信息，但你的后端服务可以利用这个
    IP 地址来区分客户端请求。例如，服务可以基于客户端 IP 地址拒绝请求。
- en: The handler writes a slice of bytes 2 to the response that has HTML defined
    in [Listing 10-11](#listing10-11).
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 处理程序将一个字节切片 2 写入响应，这个字节切片包含在 [清单 10-11](#listing10-11) 中定义的 HTML。
- en: '[PRE35]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Listing 10-11: The index HTML served by the backend service (*backend/main.go*)'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 清单 10-11：由后端服务提供的索引 HTML (*backend/main.go*)
- en: The `/style.css`1 and `/hiking.svg`2 resources do not include a full URL (such
    as [http://localhost:2020/style.css](http://localhost:2020/style.css)) because
    the backend web service does not know anything about Caddy or how clients access
    Caddy. When you exclude the scheme, hostname, and port number in the resource
    address, the client’s web browser should encounter `/style.css` in the HTML and
    prepend the scheme, hostname, and port number it used for the initial request
    before sending the request to Caddy. For that all to work, you need to configure
    Caddy in the next section to send some requests to the backend web service and
    serve static files for the rest of the requests.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: '`/style.css`1 和 `/hiking.svg`2 资源没有包含完整的 URL（例如 [http://localhost:2020/style.css](http://localhost:2020/style.css)），因为后端
    Web 服务不了解 Caddy，也不知道客户端如何访问 Caddy。当你在资源地址中省略方案、主机名和端口号时，客户端的 Web 浏览器应该在 HTML 中遇到
    `/style.css` 并将其所使用的方案、主机名和端口号附加到请求中，然后将请求发送给 Caddy。为了使这一切正常工作，你需要在下一部分配置 Caddy，将某些请求转发到后端
    Web 服务，其余的请求则由 Caddy 提供静态文件。'
- en: Setting Up Caddy’s Configuration
  id: totrans-155
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 配置 Caddy
- en: As mentioned earlier in the chapter, Caddy uses JSON as its native configuration
    format. You could certainly write your configuration in JSON, but you’ve already
    written a perfectly good configuration adapter that allows you to use TOML, so
    you’ll implement that instead.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 正如本章前面提到的，Caddy 使用 JSON 作为其原生配置格式。你当然可以使用 JSON 来编写配置，但你已经编写了一个完美的配置适配器，允许你使用
    TOML，因此你将实现 TOML 配置。
- en: 'You want to configure Caddy to reverse-proxy requests to your backend web service
    and serve static files from the *files* subdirectory. You’ll need two routes:
    one to the backend web service and one for static files. Let’s start by defining
    your server configuration in a file named *caddy.toml* ([Listing 10-12](#listing10-12)).'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 您希望配置 Caddy 将请求反向代理到您的后端 Web 服务，并从 *files* 子目录提供静态文件服务。您需要两个路由：一个指向后端 Web 服务，另一个用于静态文件。让我们从在名为
    *caddy.toml* 的文件中定义服务器配置开始（[列表 10-12](#listing10-12)）。
- en: '[PRE36]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Listing 10-12: Caddy test server configuration (*caddy.toml*)'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: '列表 10-12: Caddy 测试服务器配置（*caddy.toml*）'
- en: Your TOML adapter directly converts TOML to JSON. Therefore, you need to make
    sure you’re using the same namespaces Caddy expects. The namespace for your server
    is `apps.http.servers.test_server`1. (For simplicity, you’ll refer to this namespace
    simply as `test_server` from here on out.) It listens for incoming connections
    on port 2020 of localhost.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 您的 TOML 适配器将 TOML 直接转换为 JSON。因此，您需要确保使用的是 Caddy 所期望的相同命名空间。您的服务器的命名空间是 `apps.http.servers.test_server`1。（为了简便，接下来的讨论中，您可以简称此命名空间为
    `test_server`。）它在本地主机的 2020 端口监听传入的连接。
- en: Adding a Reverse-Proxy to Your Service
  id: totrans-161
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 将反向代理添加到您的服务
- en: Caddy includes a powerful reverse-proxy handler that makes quick work of sending
    incoming requests to your backend web service. Just as in the server implementation
    in the preceding chapter, Caddy matches an incoming request to a route and then
    passes the request onto the associated handler.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: Caddy 包含一个强大的反向代理处理器，可以快速将传入的请求转发到您的后端 Web 服务。就像在前一章中的服务器实现一样，Caddy 会将传入请求与路由匹配，然后将请求传递给相关的处理器。
- en: '[Listing 10-13](#listing10-13) adds a route and a reverse-proxy handler to
    the *caddy.toml* file.'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: '[列表 10-13](#listing10-13) 向 *caddy.toml* 文件中添加了一个路由和一个反向代理处理器。'
- en: '[PRE37]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Listing 10-13: Adding a reverse proxy to the backend service (*caddy.toml*)'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: '列表 10-13: 向后端服务添加反向代理（*caddy.toml*）'
- en: The `test_server` configuration includes a `routes` array 1, and each route
    in the array has zero or more matchers 2. A *matcher* is a special module that
    allows you to specify matching criteria for incoming requests, like the `http.ServeMux.Handle`
    method’s pattern matching discussed in the preceding chapter. Caddy includes matcher
    modules that allow you to consider each part of a request.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: '`test_server` 配置包括一个 `routes` 数组 1，每个数组中的路由可以有零个或多个匹配器 2。*匹配器* 是一个特殊模块，它允许您为传入请求指定匹配条件，就像前一章中讨论的
    `http.ServeMux.Handle` 方法的模式匹配一样。Caddy 包括了允许您考虑请求的各个部分的匹配器模块。'
- en: For this route, you add a single matcher that matches any request for the absolute
    path */backend* or any path starting with */backend/*3. The *** character is a
    wildcard that tells Caddy you want to match on the */backend/* prefix. For example,
    a request for the resource */backend/this/is/a/test* will also match.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个路由，您添加了一个匹配器，它可以匹配任何请求的绝对路径为 */backend* 或任何以 */backend/* 开头的路径3。*** 字符是一个通配符，告诉
    Caddy 您希望匹配 */backend/* 前缀。例如，请求资源 */backend/this/is/a/test* 也会匹配。
- en: The route may have one or more handlers 4. Here, you tell Caddy you want to
    send all matching requests to the reverse-proxy handler. The reverse-proxy handler
    needs to know where to send the requests. You specify an upstream entry 5 with
    its dial property set to the backend server’s socket address 6.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 路由可以有一个或多个处理器 4。在这里，您告诉 Caddy，您希望将所有匹配的请求发送到反向代理处理器。反向代理处理器需要知道将请求发送到哪里。您需要通过其
    dial 属性指定一个上游条目 5，该属性设置为后端服务器的套接字地址 6。
- en: Serving Static Files
  id: totrans-169
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提供静态文件
- en: You relied on the `http.FileServer` to serve static files for you in the preceding
    chapter. Caddy exposes similar functionality with its `file_server` handler. [Listing
    10-14](#listing10-14) adds a second route to your *caddy.toml* file for serving
    static files.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 在前一章中，您依赖于`http.FileServer`为您提供静态文件服务。Caddy 提供了类似的功能，通过其 `file_server` 处理器。[列表
    10-14](#listing10-14) 向您的 *caddy.toml* 文件添加了第二个路由，用于提供静态文件服务。
- en: '[PRE38]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Listing 10-14: Adding a default route to serve static files (*caddy.toml*)'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: '列表 10-14: 向默认路由添加静态文件服务（*caddy.toml*）'
- en: Unlike the route you added in [Listing 10-13](#listing10-13), this route 1 does
    not include any matchers. As such, Caddy would send every request to this route’s
    handler if the request didn’t match previous routes. In other words, this route
    is your default route, and so its position in the file matters. If you moved this
    route before the reverse-proxy route, all requests would match it, and no requests
    would ever make their way to the reverse proxy. Whenever you specify a route with
    no matches, make sure you put it at the end of your routes array, as you do here.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 与在 [Listing 10-13](#listing10-13) 中添加的路由不同，这个路由 1 不包含任何匹配器。因此，如果请求没有匹配之前的路由，Caddy
    会将每个请求都发送到这个路由的处理器。换句话说，这个路由是你的默认路由，所以它在文件中的位置很重要。如果你将这个路由移到反向代理路由之前，所有请求都会匹配它，且没有请求会进入反向代理。每当你指定一个没有匹配器的路由时，确保把它放在路由数组的末尾，就像这里一样。
- en: As with the file server in the preceding chapter, you want to protect against
    accidentally serving sensitive files prefixed with a period. Therefore, you include
    your `restrict_prefix` middleware 2 in the array of handlers before the `file_server`
    handler 3. You add more configuration options to serve files found in the *files*
    subdirectory 4 and return the *index.html* file 5 if the request didn’t specify
    a file.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 与前一章的文件服务器一样，你需要防止不小心服务带有点前缀的敏感文件。因此，你应将 `restrict_prefix` 中间件 2 包含到处理器数组中，放在
    `file_server` 处理器 3 之前。你可以添加更多配置选项，以便提供 *files* 子目录 4 中的文件，并且当请求未指定文件时，返回 *index.html*
    文件 5。
- en: Checking Your Work
  id: totrans-175
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 检查你的工作
- en: Everything is in place. Start Caddy and verify that your configuration works
    as expected. Since some of the static files are images, I recommend you use a
    web browser to interact with Caddy while it runs on your computer.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 一切就绪。启动 Caddy 并验证配置是否按预期工作。由于一些静态文件是图片，我建议你在 Caddy 运行时使用网页浏览器与其交互。
- en: 'Start Caddy by using the *caddy.toml* file and the *toml* adapter:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 *caddy.toml* 文件和 *toml* 适配器启动 Caddy：
- en: '[PRE39]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'On Windows, the command looks like this:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Windows 上，命令如下所示：
- en: '[PRE40]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Now, run the backend web service:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，运行后台 web 服务：
- en: '[PRE41]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: Open your web browser and visit [http://localhost:2020/](http://localhost:2020/).
    Caddy will send your request to the file server handler, which in turn will respond
    with the *index.html* file, since you didn’t indicate a specific file in the request.
    Your browser then asks Caddy for the *style.css* and *sage.svg* files to finish
    rendering the page. If everything succeeds, you should now be looking at a sage
    gopher.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 打开你的网页浏览器并访问 [http://localhost:2020/](http://localhost:2020/)。Caddy 会将你的请求发送到文件服务器处理器，然后它会响应
    *index.html* 文件，因为你没有在请求中指定特定文件。然后，浏览器会请求 Caddy 获取 *style.css* 和 *sage.svg* 文件，以完成页面的渲染。如果一切顺利，你现在应该看到一个智慧的登山獾。
- en: Now, let’s test the reverse proxy to the backend web service. Visit [http://localhost:2020/backend](http://localhost:2020/backend).
    This request matches the reverse-proxy route’s matcher, so the reverse-proxy handler
    should handle it, sending the request onto the backend service. The backend web
    service responds with HTML that instructs your browser to retrieve the *style.css*
    and *hiking.svg* files from Caddy, where the file server handler happily serves
    them up. You should now be looking at a hiking gopher rendered using HTML from
    the backend web service and static files from Caddy.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们测试反向代理到后台 web 服务。访问 [http://localhost:2020/backend](http://localhost:2020/backend)。这个请求与反向代理路由的匹配器相匹配，因此反向代理处理器应处理它，将请求发送到后台服务。后台
    web 服务响应 HTML，指示你的浏览器从 Caddy 获取 *style.css* 和 *hiking.svg* 文件，文件服务器处理器会愉快地提供这些文件。你现在应该看到一个通过后台
    web 服务生成的登山獾，使用的是从 Caddy 提供的静态文件。
- en: If you copied the *files* subdirectory from this book’s source code repository,
    it should contain *./files/.secret* and *./files/.dir/secret* files. Your middleware
    should block access to both files. In other words, both [http://localhost:2020/files/.secret](http://localhost:2020/files/.secret)
    and [http://localhost:2020/files/.dir/secret](http://localhost:2020/files/.dir/secret)
    will return a 404 Not Found status if you try to request them.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你从本书的源码仓库复制了 *files* 子目录，它应该包含 *./files/.secret* 和 *./files/.dir/secret* 文件。你的中间件应阻止访问这两个文件。换句话说，如果你尝试请求
    [http://localhost:2020/files/.secret](http://localhost:2020/files/.secret) 或 [http://localhost:2020/files/.dir/secret](http://localhost:2020/files/.dir/secret)，它们将返回
    404 未找到状态。
- en: Adding Automatic HTTPS
  id: totrans-186
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 添加自动 HTTPS
- en: 'Now let’s add Caddy’s key feature to your web server: automatic HTTPS.'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们将 Caddy 的关键特性添加到你的 web 服务器中：自动 HTTPS。
- en: I once used Caddy to stand up a website with full HTTPS support, using certificates
    trusted by all contemporary web browsers, in a matter of minutes. The server has
    been rock-solid ever since, happily rotating Let’s Encrypt keys every few months
    with no intervention on my part. This isn’t to say I couldn’t replicate this functionality
    in my own Go-based web server; my time was simply best spent building services
    and leaving the web serving to Caddy. If Caddy lacked any functionality, I could
    add it as a module.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 我曾使用 Caddy 搭建过一个完整支持 HTTPS 的网站，使用所有现代 Web 浏览器信任的证书，整个过程只花了几分钟。此后，服务器一直稳定运行，每隔几个月
    Caddy 会自动旋转 Let’s Encrypt 的密钥，我无需干预。这并不是说我不能在我自己的基于 Go 的 Web 服务器中复制这种功能；我只是认为我的时间更应该用来构建服务，而将
    Web 服务交给 Caddy。如果 Caddy 缺少某些功能，我可以通过模块来添加。
- en: Caddy automatically enables TLS when it can determine what domain names you’ve
    configured it to serve. The *caddy.toml* configuration created in this chapter
    didn’t give Caddy enough information to determine which domain it was serving.
    Therefore, Caddy didn’t enable HTTPS for you. You told Caddy to bind to localhost,
    but that tells Caddy only what it’s listening to, not what domains it’s serving.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 当 Caddy 能够确定您配置的域名时，它会自动启用 TLS。本章中创建的 *caddy.toml* 配置文件没有提供足够的信息，让 Caddy 确定它正在为哪个域名提供服务。因此，Caddy
    没有为您启用 HTTPS。您告诉 Caddy 绑定到 localhost，但这只告诉 Caddy 它正在监听什么，并没有告诉它正在为哪些域名提供服务。
- en: 'The most common way to enable automatic HTTPS is by adding a host matcher to
    one of Caddy’s routes. Here’s an example matcher:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 启用自动 HTTPS 的最常见方法是向 Caddy 的某个路由添加主机匹配器。以下是一个匹配器示例：
- en: '[PRE42]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: This host matcher supplies enough information for Caddy to determine that it
    is serving the *example.com* domain. If Caddy doesn’t already have a valid certificate
    for *example.com* to enable HTTPS, it will go through the process of validating
    the domain with Let’s Encrypt and retrieving a certificate. Caddy will manage
    your certificate, automatically renewing it, as necessary.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 这个主机匹配器提供了足够的信息，供 Caddy 确定它正在为 *example.com* 域名提供服务。如果 Caddy 尚未为 *example.com*
    配置有效证书以启用 HTTPS，它将通过与 Let’s Encrypt 验证该域名并获取证书的过程。Caddy 会管理您的证书，并在必要时自动续期。
- en: Caddy’s `file-server` subcommand tells Caddy you want it to exclusively serve
    files over HTTP. The `file-server`’s `--domain` flag is enough information for
    Caddy to invoke its automatic HTTPS and allow you to serve files over HTTPS as
    well.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: Caddy 的 `file-server` 子命令告诉 Caddy 您希望它仅通过 HTTP 提供文件服务。`file-server` 的 `--domain`
    标志提供了足够的信息，供 Caddy 启用自动 HTTPS，使您能够通过 HTTPS 提供文件服务。
- en: Caddy’s `reverse-proxy` subcommand allows you to put Caddy into a reverse-proxy-only
    mode, where it will send all incoming requests onto the socket address specified
    by the `--to` flag. Caddy will retrieve a TLS certificate and enable automatic
    HTTPS if you specify a hostname with the `--from` flag.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: Caddy 的 `reverse-proxy` 子命令允许您将 Caddy 设置为仅反向代理模式，它会将所有传入请求转发到 `--to` 标志指定的套接字地址。如果您使用
    `--from` 标志指定主机名，Caddy 会检索 TLS 证书并启用自动 HTTPS。
- en: I encourage you to read more about Caddy’s automatic HTTPS in production environments
    at [https://caddyserver.com/docs/automatic-https](https://caddyserver.com/docs/automatic-https).
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 我鼓励您阅读更多关于 Caddy 在生产环境中自动启用 HTTPS 的内容，请访问 [https://caddyserver.com/docs/automatic-https](https://caddyserver.com/docs/automatic-https)。
- en: What You’ve Learned
  id: totrans-196
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 您所学的内容
- en: Caddy is a contemporary web server written in Go that offers security, performance,
    and extensibility through modules and configuration adapters. Caddy can automatically
    use HTTPS through its integration with Let’s Encrypt, a nonprofit certificate
    authority that supplies free digital certificates. Together, Caddy and Let’s Encrypt
    allow you to stand up a web server with seamless HTTPS support.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: Caddy 是一款用 Go 语言编写的现代 Web 服务器，通过模块和配置适配器提供安全性、性能和可扩展性。Caddy 可以通过与 Let’s Encrypt（一个提供免费数字证书的非营利证书机构）的集成，自动启用
    HTTPS。Caddy 和 Let’s Encrypt 配合使用，能够让您轻松搭建具有无缝 HTTPS 支持的 Web 服务器。
- en: Caddy uses JSON as its native configuration format, and it exposes an API on
    localhost port 2019 that allows you to post JSON to change its configuration.
    The configuration changes take immediate effect. But since JSON isn’t an ideal
    configuration format, Caddy makes use of configuration adapters. Configuration
    adapters translate configuration files from more configuration-friendly formats,
    like TOML, to JSON. If you don’t want to use JSON for your Caddy configuration
    or if you don’t find a configuration adapter that meets your needs, you can also
    write your own, as you did in this chapter.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: Caddy 使用 JSON 作为其原生配置格式，并在本地主机的 2019 端口上公开了一个 API，允许你发布 JSON 来更改其配置。配置更改会立即生效。但由于
    JSON 并不是理想的配置格式，Caddy 采用了配置适配器。配置适配器将更适合配置的格式（如 TOML）转化为 JSON。如果你不想使用 JSON 作为
    Caddy 配置，或者找不到符合你需求的配置适配器，你还可以像本章所示，自己编写一个适配器。
- en: You can also extend Caddy’s functionality with the use of modules. This chapter
    shows how to write a middleware module, compile it into Caddy, configure the module,
    and put it to effective use.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以通过使用模块扩展 Caddy 的功能。本章将展示如何编写一个中间件模块，将其编译进 Caddy，配置模块，并使其有效运作。
- en: Finally, this chapter showed you how to integrate Caddy into your network architecture.
    You’ll often make Caddy the first server in your network, using it to receive
    client requests before sending the requests onto their final destinations. In
    this chapter, you configured an instance of Caddy to reverse-proxy client requests
    to your backend web service and serve static files on behalf of the backend web
    service. As a result, you kept your backend web service as simple as possible
    and saved it from having to manage its static content. Your backend web service
    can use Caddy for HTTPS support, caching, and file serving.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，本章向你展示了如何将 Caddy 集成到你的网络架构中。你会经常将 Caddy 作为你网络中的第一个服务器，使用它接收客户端请求，然后将请求转发到最终目的地。在本章中，你配置了一个
    Caddy 实例，将客户端请求反向代理到你的后端 Web 服务，并代表后端 Web 服务提供静态文件。因此，你保持了后端 Web 服务的简洁，并避免了它需要管理静态内容。你的后端
    Web 服务可以使用 Caddy 提供 HTTPS 支持、缓存和文件服务。
- en: Now that you have some experience with Caddy, you should be able to determine
    whether your web services would do better when served by a comprehensive web server
    solution or a comparatively minimal `net/http` web server implementation. If you
    expect to make your web service available to the public, using a proven web server
    like Caddy at the edge of your application will free up time you can better spend
    on your backend web service.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经有了一些使用 Caddy 的经验，你应该能够判断，当你的 Web 服务由一个全面的 Web 服务器解决方案提供时，还是由一个相对简洁的 `net/http`
    Web 服务器实现提供时，效果更好。如果你打算将你的 Web 服务公开，使用像 Caddy 这样的成熟 Web 服务器作为应用程序的边缘服务器，将能节省出更多时间，让你将精力集中在后端
    Web 服务的优化上。
