- en: <hgroup>
  id: totrans-0
  prefs: []
  type: TYPE_NORMAL
  zh: <hgroup>
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">6</samp> <samp class="SANS_Dogma_OT_Bold_B_11">CLASSES</samp>
  id: totrans-1
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">6</samp> <samp class="SANS_Dogma_OT_Bold_B_11">类</samp>
- en: </hgroup>
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: </hgroup>
- en: '![](../images/opener.png)'
  id: totrans-3
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/opener.png)'
- en: '*Classes* are a powerful programming tool for generating multiple objects with
    shared characteristics and behaviors. They’re a core part of *object-oriented
    programming*, a style of coding that revolves around creating objects that contain
    both data and functions for manipulating that data. In an object-oriented multiplayer
    game, for example, you might represent each player as an object of a Player class,
    and each enemy as an object of an Enemy class. The classes would establish what
    kind of data a player or enemy should have and would include functions to make
    the player or enemy do things, like move around or attack.'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: '*类*是一个强大的编程工具，用于生成具有共享特征和行为的多个对象。它们是*面向对象编程*的核心部分，面向对象编程是一种围绕创建包含数据和操作这些数据的函数的对象的编码风格。例如，在一个面向对象的多人游戏中，你可以将每个玩家表示为一个Player类的对象，将每个敌人表示为一个Enemy类的对象。类将确定玩家或敌人应具备什么样的数据，并包含使玩家或敌人执行动作（如移动或攻击）的函数。'
- en: In this chapter, you’ll learn how to create JavaScript classes, and how to use
    those classes to create individual objects. You’ll also learn how to leverage
    *inheritance* to share behavior between different classes. Using classes and object-oriented
    programming in this way gives your code structure and can make it easier to read,
    write, and understand, especially if your program involves lots of entities with
    common behaviors.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你将学习如何创建JavaScript类，并如何使用这些类创建单个对象。你还将学习如何利用*继承*在不同类之间共享行为。以这种方式使用类和面向对象编程可以为你的代码提供结构，并使其更易于阅读、编写和理解，特别是当你的程序涉及大量具有共同行为的实体时。
- en: <samp class="SANS_Futura_Std_Bold_B_11">Creating Classes and Instances</samp>
  id: totrans-6
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">创建类和实例</samp>
- en: A *class* is like template for making standardized objects. In [Chapter 3](chapter3.xhtml)
    we discussed how an object is a compound data type consisting of key-value pairs,
    and you saw how to create objects by manually writing out object literals. Classes
    automate that process, allowing you to instead create objects using a syntax similar
    to calling a function.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: '*类*就像是一个用于创建标准化对象的模板。在[第3章](chapter3.xhtml)中，我们讨论了对象如何是由键值对组成的复合数据类型，并展示了如何通过手动编写对象字面量来创建对象。类将这个过程自动化，允许你通过类似调用函数的语法来创建对象。'
- en: 'A class lays out two main things:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 一个类定义了两件主要的事情：
- en: 1.  What properties each object of that class should have. (Remember that *property*
    is another term for a key-value pair in an object.)
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 1.  该类的每个对象应该具有什么属性。（记住，*属性*是对象中键值对的另一种说法。）
- en: 2.  What functions the object should have access to. (When they’re defined and
    called as part of a class, functions are called *methods*.)
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 2.  对象应该具有什么功能。（当这些功能作为类的一部分定义并调用时，这些功能被称为*方法*。）
- en: The Player class in a game, for example, might include properties such as the
    player’s name, health level, position in the environment, and so on. It might
    have methods for moving, firing a weapon, picking up an item, and more. The class
    could be used to create multiple different players.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 游戏中的Player类可能包括玩家的名字、健康值、在环境中的位置等属性。它可能具有移动、射击、拾取物品等方法。该类可以用来创建多个不同的玩家。
- en: Objects created from a class are known as *instances* of that class. Each player’s
    character in the game would be an instance of the Player class, for example. Each
    instance fills in the generic template of the class with its own details. A specific
    Player instance would have its own name, health level, and position, distinct
    from those of other Player instances. All instances can use the class’s methods,
    however.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 从类创建的对象被称为该类的*实例*。例如，游戏中每个玩家的角色将是Player类的一个实例。每个实例用自己的详细信息填充类的通用模板。一个特定的Player实例将具有自己的名字、健康值和位置，这些与其他Player实例的不同。然而，所有实例都可以使用该类的方法。
- en: 'To see how this works, we’ll create a simple Player class for a hypothetical
    2D game. For now, we’ll just give the player a position, defined by a set of x-
    and y-coordinates, and a method for moving that changes those coordinates. Enter
    the following in the JavaScript console to declare the class:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 为了了解这如何工作，我们将为一个假设的2D游戏创建一个简单的Player类。现在，我们只为玩家定义一个位置，通过一组x和y坐标来表示，并提供一个改变这些坐标的移动方法。输入以下内容在JavaScript控制台中声明该类：
- en: '[PRE0]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: We start with the class keyword to indicate we’re declaring a new class, followed
    by the class’s name, Player. It’s customary for class names to start with an uppercase
    letter. Next comes the class body, enclosed in braces, just like a function body.
    Inside the body we define two methods, constructor ❶ and move ❷. Declaring a class
    method is like declaring a function, but we don’t use the function keyword.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 我们以 `class` 关键字开始，表示我们正在声明一个新类，接着是类的名称 `Player`。类名通常以大写字母开头。然后是类体，它被大括号包围，就像函数体一样。在类体内部，我们定义了两个方法，`constructor
    ❶` 和 `move ❷`。声明类方法就像声明函数一样，但我们不使用 `function` 关键字。
- en: If a class has a method called constructor, as our Player class does, that method
    will be called automatically anytime you create an instance of the class. The
    constructor performs any necessary setup for the object being created, including
    receiving any parameters that define the instance and laying out what properties
    the object should have. In this case, our Player class’s constructor takes in
    two parameters, startX and startY, and assigns them to the new instance’s x and
    y properties, which together keep track of the player’s position in the 2D game.
    The this keyword refers to the current instance being created, so this.x = startX
    means “take the value of startX and assign it to the new Player object’s x property.”
    Notice that we’re using the same dot notation we’ve used elsewhere to access the
    properties of an object; the only difference here is that this serves as a placeholder
    for the new object’s name.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一个类有一个名为 `constructor` 的方法，就像我们的 `Player` 类那样，每当你创建该类的实例时，这个方法会被自动调用。构造方法会为正在创建的对象执行任何必要的设置工作，包括接收定义实例的任何参数，并确定对象应具备的属性。在这种情况下，我们的
    `Player` 类的构造方法接收两个参数，`startX` 和 `startY`，并将它们赋值给新实例的 `x` 和 `y` 属性，这两个属性一起跟踪玩家在
    2D 游戏中的位置。`this` 关键字指的是当前正在创建的实例，因此 `this.x = startX` 意味着“取 `startX` 的值并将其赋给新的
    `Player` 对象的 `x` 属性。”注意，我们在这里使用的点表示法与之前访问对象属性时使用的相同；唯一的区别是，`this` 作为新对象名称的占位符。
- en: The move method updates the player’s position by changing the x and y properties
    based on the provided dx and dy parameters. The *d* in dx and dy is short for
    the Greek letter *delta*, which often refers to the amount something changes,
    as in “change in the x value” and “change in the y value.”
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: '`move` 方法通过根据提供的 `dx` 和 `dy` 参数来更新玩家的位置，从而改变 `x` 和 `y` 属性。`dx` 和 `dy` 中的 *d*
    是希腊字母 *delta* 的缩写，通常用来表示某物的变化量，比如“x 值的变化”和“y 值的变化”。'
- en: 'Now that we’ve declared the Player class, we can make instances of it. For
    example:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经声明了 `Player` 类，可以创建它的实例。例如：
- en: '[PRE1]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: We create a new instance of the Player class using the new keyword followed
    by the class name. After the class name, we write a set of parentheses, much as
    we would when calling a function. The parentheses contain any arguments that need
    to be passed to the class’s constructor method.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用 `new` 关键字后跟类名来创建 `Player` 类的新实例。在类名后，我们写一对括号，就像调用函数时一样。括号中包含需要传递给类的构造方法的参数。
- en: When you create a new instance of a class with new, some magic happens. First,
    a new, empty object is created. Then a hidden link from this object to the class
    is created, which is how JavaScript is able to tell which class created the object
    and what methods the object should therefore have access to. Next, the class’s
    constructor method is called automatically. Inside the constructor, the new object
    being created is available via the keyword this, allowing you to set properties
    on the object. Any arguments you provide in the parentheses after the class name
    are passed to the constructor method’s parameters. After the constructor method
    has been called, the new object is returned.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 当你使用 `new` 创建一个类的新实例时，一些神奇的事情发生了。首先，会创建一个新的空对象。然后，这个对象与类之间会创建一个隐藏的链接，这样 JavaScript
    就能够知道是哪个类创建了这个对象，以及该对象应当具有哪些方法。接下来，类的构造方法会被自动调用。在构造方法内部，通过关键字 `this` 可以访问正在创建的新对象，从而允许你为该对象设置属性。你在类名后括号中的任何参数都会被传递给构造方法的参数。构造方法调用完成后，新对象就会被返回。
- en: In our example, when we enter let player1 = new Player(0, 0);, JavaScript creates
    a new object and gives it a hidden link to the Player class. It then calls the
    class’s constructor method, passing the arguments 0 and 0 to the constructor’s
    startX and startY parameters. The constructor takes these parameters and uses
    this.x and this.y to set the new object’s x and y properties to 0. Finally, the
    new object is returned and assigned to the player1 variable.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的示例中，当我们输入`let player1 = new Player(0, 0);`时，JavaScript会创建一个新对象并给它一个与Player类的隐式链接。然后，它调用类的构造方法，将参数0和0传递给构造函数的startX和startY参数。构造函数使用这些参数并通过`this.x`和`this.y`将新对象的x和y属性设置为0。最后，返回新对象并将其赋值给`player1`变量。
- en: 'We can now interact with the new object. Here, for example, we look up its
    position, tell it to move, then look up its position again to confirm the move
    method worked:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以与新对象进行交互。例如，在这里，我们查看它的位置，告诉它移动，然后再次查看它的位置以确认move方法是否起作用：
- en: '[PRE2]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: We access the object’s x and y properties using player1.x and player1.y, respectively.
    They both show the value 0, since that’s what we passed to the constructor. Next,
    we call the move method, which we defined in the Player class. Because instances
    have a hidden link to the class that created them, they’re able to call methods
    defined on that class. We use dot notation to call the method, just like calling
    the built-in methods associated with strings or arrays.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过`player1.x`和`player1.y`分别访问对象的x和y属性。它们的值都是0，因为我们将0传递给了构造函数。接下来，我们调用了在Player类中定义的move方法。由于实例与创建它们的类之间有一个隐式链接，它们能够调用类中定义的方法。我们使用点符号来调用方法，就像调用与字符串或数组相关的内置方法一样。
- en: 'When you call a method on an object, the this keyword inside the method definition
    is set to the current object (the receiver). When we call player1.move(3, 4),
    for example, this inside the body of the move method is bound to the player1 object.
    That’s how one method is able to be shared by multiple objects: this becomes whatever
    object is receiving the method call at any given time.'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 当你在对象上调用一个方法时，方法定义中的`this`关键字会指向当前对象（接收者）。例如，当我们调用`player1.move(3, 4)`时，`this`在move方法的内部绑定到`player1`对象。这就是为什么一个方法可以被多个对象共享的原因：`this`会变成任何在某一时刻接收方法调用的对象。
- en: 'The move method updates the object’s x and y properties by adding dx and dy
    to their current values. For example, when we call player1.move(3, 4) we’re setting
    x to 0 + 3 and y to 0 + 4. When we again look up the object’s x and y properties,
    we can see that this worked: player1.x has become 3 and player1.y has become 4.
    If we then made another call to move, for example, player1.move(2, 2), x would
    become 5 and y would become 6.'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: move方法通过将dx和dy加到当前的x和y值上来更新对象的x和y属性。例如，当我们调用`player1.move(3, 4)`时，我们将x设置为0 +
    3，y设置为0 + 4。当我们再次查看对象的x和y属性时，可以看到操作成功：`player1.x`变成了3，`player1.y`变成了4。如果我们再调用一次move方法，例如`player1.move(2,
    2)`，x将变为5，y将变为6。
- en: <samp class="SANS_Futura_Std_Bold_B_11">Inheritance</samp>
  id: totrans-28
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">继承</samp>
- en: '*Inheritance* is a mechanism in object-oriented programming for defining relationships
    between different classes. Just as a child inherits genes from its parents, a
    “child” class inherits properties and methods from a “parent” class, taking on
    the parent’s properties and methods. This is useful when you have multiple classes
    that should share a general set of behaviors, in addition to each class having
    some unique behaviors of its own. You can define the general behaviors as part
    of a parent class, also called a *superclass*. Then you can define the child classes,
    also called *subclasses*, to inherit these behaviors and augment them with other,
    specialized behaviors. This saves you from having to repeat the general code when
    you define each subclass.'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: '*继承*是面向对象编程中定义不同类之间关系的一种机制。就像孩子从父母那里继承基因一样，“子”类继承“父”类的属性和方法，获得父类的属性和方法。当你有多个类需要共享一组通用行为，并且每个类又有一些独特行为时，这非常有用。你可以将通用行为定义为父类的一部分，也叫做*超类*。然后，你可以定义子类，也叫做*子类*，来继承这些行为并使用其他专门的行为来扩展它们。这可以避免在定义每个子类时重复编写通用代码。'
- en: To illustrate, in our 2D game, human-controlled players and computer-controlled
    enemies probably have a lot in common. They both need x and y properties representing
    their position, for example, and they both need a move method to change their
    position. However, they also have some differences. Perhaps enemies have the ability
    to attack a player if the player comes too close, but not the other way around—the
    goal of the game is for players to avoid, not kill, the enemies.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 举个例子，在我们的 2D 游戏中，人类控制的玩家和计算机控制的敌人可能有很多相似之处。例如，它们都需要 x 和 y 属性来表示其位置，并且它们都需要一个
    `move` 方法来改变自己的位置。然而，它们也有一些不同之处。也许敌人有能力攻击靠得太近的玩家，而玩家则不能攻击敌人——游戏的目标是玩家避免敌人，而不是击杀敌人。
- en: We can use inheritance to realize this scheme with minimal code. We’ll create
    a new class called Actor representing *any* participant in the game. It will hold
    the general code both players and enemies should have, such as the move method.
    We’ll then define Player and Enemy as subclasses of Actor. They’ll each inherit
    the general code from the Actor superclass, while also adding their own code particular
    to just players or enemies.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以利用继承以最小的代码量实现这个方案。我们将创建一个新的类 Actor，表示游戏中的 *任何* 参与者。它将包含玩家和敌人都应该拥有的一般代码，例如
    `move` 方法。然后我们将定义 Player 和 Enemy 作为 Actor 的子类。它们将继承 Actor 超类中的一般代码，同时也会添加只针对玩家或敌人的特定代码。
- en: 'First, here’s the definition of the Actor class. It’s mostly a copy of our
    previous Player class, but with a new name. We’re also adding another method,
    called distanceTo, that calculates the distance between two participants in the
    game:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，这是 Actor 类的定义。它基本上是我们之前的 Player 类的复制品，但名字不同。我们还添加了一个新的方法，叫做 `distanceTo`，用于计算游戏中两个参与者之间的距离：
- en: '[PRE3]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The distanceTo method takes another Actor (or any object with an x- and y-coordinate)
    as a parameter and returns the distance to that object. It’s quite common for
    objects to be passed to other objects’ methods in this way. The distance is determined
    by calculating the horizontal distance (otherActor.x - this.x) and the vertical
    distance (otherActor.y - this.y), and then using the built-in Math.hypot method
    to find the length of the hypotenuse of the triangle formed by the two distances.
    This is the standard mathematical technique, based on the Pythagorean theorem,
    for finding the distance between two points on a 2D plane.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: '`distanceTo` 方法接收另一个 Actor（或任何具有 x 和 y 坐标的对象）作为参数，并返回到该对象的距离。将对象传递给其他对象的方法是非常常见的做法。距离是通过计算水平距离（`otherActor.x
    - this.x`）和垂直距离（`otherActor.y - this.y`），然后使用内置的 `Math.hypot` 方法来找到由这两个距离形成的直角三角形的斜边长度来确定的。这是基于毕达哥拉斯定理的标准数学技巧，用来计算二维平面上两点之间的距离。'
- en: Although it’s technically possible to create an instance of the Actor class,
    it’s not really meant to be instantiated. Classes like Actor that are just meant
    to be extended by subclasses are sometimes known as *abstract classes*, because
    they represent an abstract concept, like a generic entity in a game. Meanwhile,
    classes that are meant to be instantiated, such as the Player and Enemy classes
    we’ll define momentarily, are sometimes known as *concrete classes*, because they
    represent something solid, such as actual players or enemies.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管从技术上讲，可以创建 Actor 类的实例，但它并不真正打算被实例化。像 Actor 这样的类，主要是供子类扩展的，有时被称为 *抽象类*，因为它们代表了一种抽象的概念，例如游戏中的通用实体。与此同时，像
    Player 和 Enemy 这样的类，它们打算被实例化，通常被称为 *具体类*，因为它们代表了一些具体的事物，比如实际的玩家或敌人。
- en: 'Next, we’ll redefine the Player class to inherit from Actor. We’ll add a new
    property specific to players called hp (for *hit points*), representing the player’s
    health level—the Enemy class doesn’t need this property, since only players, not
    enemies, can be attacked:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将重新定义 Player 类，让它继承自 Actor。我们将添加一个新属性，专门用于玩家，叫做 `hp`（即 *生命值*），表示玩家的健康水平——Enemy
    类不需要这个属性，因为只有玩家可以被攻击，而敌人不能：
- en: '[PRE4]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: This time we declare the class with the extends keyword to establish Player
    as a subclass of Actor. We have to write only the class’s constructor method,
    since it inherits the move and distanceTo methods from Actor. The constructor
    takes startX and startY parameters, just as before.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 这次我们使用 `extends` 关键字声明类，将 Player 作为 Actor 的子类。我们只需要编写类的构造方法，因为它继承了 Actor 的 `move`
    和 `distanceTo` 方法。构造方法接收 `startX` 和 `startY` 参数，就像之前一样。
- en: The first thing we do in the constructor is call super(startX, startY). Inside
    a subclass’s constructor method, the super keyword refers to the constructor from
    the superclass—in this case, the Actor class’s constructor. As a result, when
    we create a new instance of Player, the Player constructor is called automatically,
    which in turn calls the Actor constructor (via super). We pass startX and startY
    to the Actor constructor, which uses these values to set the Player object’s x
    and y properties. Then, back in the Player class’s constructor, we set the new
    Player instance’s hp property to 100 ❶. This way each new player will start with
    100 hit points (full health).
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 在构造函数中，我们首先调用super(startX, startY)。在子类的构造函数中，super关键字指代的是父类的构造函数——在这种情况下是Actor类的构造函数。因此，当我们创建一个新的Player实例时，Player构造函数会自动调用，从而间接调用Actor构造函数（通过super）。我们将startX和startY传递给Actor构造函数，Actor使用这些值来设置Player对象的x和y属性。然后，在Player类的构造函数中，我们将新的Player实例的hp属性设置为100
    ❶。这样，每个新玩家的初始生命值为100（满血）。
- en: 'Next, we’ll create our Enemy class. It, too, will inherit from the Actor class,
    extending it with an attack method for attacking players (the Player class doesn’t
    need this method, since only enemies can attack):'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将创建我们的Enemy类。它同样会继承Actor类，并通过添加攻击方法来扩展它，用于攻击玩家（Player类不需要这个方法，因为只有敌人可以攻击）：
- en: '[PRE5]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: We declare the Enemy class to extend Actor, just like the Player class. Unlike
    with Player, however, the Enemy class doesn’t have any extra properties (such
    as hp) that need to be set in the constructor. As such, the class doesn’t have
    its own constructor method. When a subclass doesn’t define a constructor, its
    parent class’s constructor is called automatically when a new instance of the
    subclass is created. Thus, new Enemy instances will still be given an initial
    position thanks to the Actor superclass’s constructor method, but we don’t need
    to show this explicitly in the Enemy class declaration.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 我们声明Enemy类继承自Actor，就像Player类一样。然而，与Player不同，Enemy类没有任何需要在构造函数中设置的额外属性（如hp）。因此，Enemy类没有自己的构造函数方法。当子类没有定义构造函数时，父类的构造函数会在创建子类新实例时自动调用。因此，新的Enemy实例仍然会通过Actor父类的构造函数方法获得初始位置，但我们不需要在Enemy类声明中明确显示这一点。
- en: Without a constructor, the Enemy class’s only unique method is attack. It takes
    in a Player object as a parameter and checks the distance to that object, using
    the distanceTo method inherited from the Actor class. (Notice that we call the
    method using this.distanceTo, again using the this keyword to reference the current
    instance of the Enemy class.) If the distance is less than 4, the enemy can attack,
    reducing the player’s hp value by 10. We return true to indicate that this was
    a successful attack. If the attack fails because the player is too far away, we
    return false instead.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 没有构造函数，Enemy类唯一独特的方法是attack。它接收一个Player对象作为参数，并检查与该对象的距离，使用从Actor类继承的distanceTo方法。（注意，我们通过this.distanceTo调用该方法，再次使用this关键字来引用当前的Enemy实例。）如果距离小于4，敌人就可以攻击，将玩家的hp值减少10。我们返回true以表示这是一次成功的攻击。如果攻击失败，因为玩家太远，我们则返回false。
- en: 'Now that we have our Player and Enemy classes, we can see how they interact.
    Let’s create an instance of each class, move them around, and have the enemy attack
    the player:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经有了Player和Enemy类，可以看看它们是如何交互的。让我们创建每个类的实例，移动它们，并让敌人攻击玩家：
- en: '[PRE6]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: First we create an instance of each class, at the positions (1, 2) and (3, 4).
    The Player object starts out at full health, as player.hp demonstrates. The two
    objects are about 2.8 units apart, which we confirm by calling enemy .distanceTo(player).
    At this point, the enemy is close enough to successfully attack the player, so
    we call its attack method using enemy.attack(player). The method returns true,
    indicating a hit, and checking player.hp shows the attack has reduced the player’s
    health to 90. Next, we move the player by 5 units in the x and y directions. The
    move puts the player out of range of the enemy, so the enemy’s second attack is
    unsuccessful, returning false. A last check of player.hp shows the player’s health
    remains at 90.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们创建每个类的实例，位置分别为(1, 2)和(3, 4)。Player对象初始时满血，正如player.hp所示。这两个对象相距大约2.8个单位，我们通过调用enemy.distanceTo(player)来确认这一点。此时，敌人足够接近，可以成功攻击玩家，因此我们使用enemy.attack(player)调用敌人的攻击方法。该方法返回true，表示命中，检查player.hp后发现攻击将玩家的生命值降低到90。接下来，我们将玩家在x和y方向上各移动5个单位。这个移动将玩家置于敌人攻击范围之外，因此敌人的第二次攻击失败，返回false。最后检查player.hp，发现玩家的生命值仍然为90。
- en: 'Notice in this code that we’ve called the distanceTo method on an Enemy object
    and the move method on a Player object. These were both methods defined on the
    Actor class, but they’re available on the Enemy and Player classes as well, proving
    the subclasses successfully inherited from their superclass. We can also verify
    this using the instanceof keyword, which tests whether an object is an instance
    of a particular class. Here, for example, we try it out with the player object:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，在这段代码中，我们调用了Enemy对象上的distanceTo方法，以及Player对象上的move方法。这些方法都是在Actor类中定义的，但它们也可以在Enemy和Player类中使用，这证明了子类成功地从超类继承了方法。我们还可以使用`instanceof`关键字来验证这一点，它用于测试一个对象是否是特定类的实例。例如，在这里我们用player对象进行测试：
- en: '[PRE7]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: As you may expect, player is an instance of Player. What might be surprising
    is that player is also an instance of Actor. When a subclass like Player inherits
    from a superclass like Actor, instances of the subclass are also considered to
    be instances of the superclass. On the other hand, player is not an instance of
    Enemy, even though the Player and Enemy classes share a common superclass.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你可能预期的那样，player是Player的一个实例。令人惊讶的是，player也是Actor的一个实例。当像Player这样的子类继承自像Actor这样的超类时，子类的实例也被认为是超类的实例。另一方面，player不是Enemy的实例，尽管Player和Enemy类共享一个共同的超类。
- en: 'In this example, we’ve used a single level of inheritance: an Actor superclass
    with Player and Enemy subclasses. A more sophisticated game might use multiple
    levels of inheritance to create different subtypes of players and enemies. For
    example, there might be Witch, Elf, and Centaur classes, all subclasses of Player
    (which in turn is a subclass of Actor). These subclasses would share some common
    abilities, defined on the Player superclass (as well as any methods defined on
    Actor), while also having their own specialized abilities defined on the individual
    subclasses. Likewise, Enemy might have subclasses such as Troll, Demon, and Harpy.'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们使用了单一的继承层级：一个Actor超类与Player和Enemy子类。一个更复杂的游戏可能会使用多个继承层级来创建不同类型的玩家和敌人。例如，可能会有Witch、Elf和Centaur类，它们都是Player（而Player又是Actor的子类）的子类。这些子类将共享一些在Player超类中定义的共同能力（以及在Actor中定义的任何方法），同时也会有自己在个别子类中定义的专门能力。同样，Enemy可能会有像Troll、Demon和Harpy这样的子类。
- en: <samp class="SANS_Futura_Std_Bold_B_11">Prototype-Based Inheritance</samp>
  id: totrans-51
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">基于原型的继承</samp>
- en: 'When JavaScript was first created, there were no classes, but it was still
    possible to share behaviors between objects using *prototype-based inheritance*.
    This older system, which still works today alongside the class system, relies
    on two mechanisms:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 当JavaScript最初创建时，还没有类，但仍然可以使用*基于原型的继承*在对象之间共享行为。这个旧系统，今天仍然与类系统一起使用，依赖于两个机制：
- en: 1.  A *constructor* function that creates and returns new objects. In this context,
    a constructor is just a regular, standalone function (not a function defined within
    a class), but it’s called using the new keyword.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 1.  一个*构造函数*，用于创建并返回新对象。在这种情况下，构造函数只是一个普通的独立函数（不是定义在类中的函数），但它是通过`new`关键字调用的。
- en: 2.  A *prototype*, an example object that the constructor uses as a model for
    the objects it creates. The newly created objects inherit methods and properties
    from the prototype object.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 2.  一个*原型*，是构造函数用作它所创建的对象模型的示例对象。新创建的对象会从原型对象继承方法和属性。
- en: JavaScript was one of the only mainstream languages to use prototype-based inheritance
    rather than classes. Recognizing this, the committee that develops the language
    eventually decided to add support for classes, in order to make JavaScript more
    palatable to newcomers with a background in other modern programming languages.
    When they added classes, however, they built the new feature on top of the existing
    support for prototype-based inheritance. In other words, JavaScript’s class-based
    inheritance is essentially an alternative syntax for prototype-based inheritance.
    (This is sometimes known as *syntactic sugar*, because it makes the syntax more
    palatable.)
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript是少数使用基于原型的继承而非类的主流语言之一。认识到这一点，开发该语言的委员会最终决定增加对类的支持，以使JavaScript对有其他现代编程语言背景的新手更具吸引力。然而，当他们添加类时，他们是在现有的基于原型的继承支持上构建这一新特性。换句话说，JavaScript的基于类的继承本质上是基于原型继承的另一种语法。（这有时被称为*语法糖*，因为它使语法更易接受。）
- en: If you’re comfortable using classes, it isn’t essential that you learn about
    prototype-based inheritance. However, since classes are a relatively new JavaScript
    feature, it’s still common to encounter prototype-based inheritance in older code,
    so it’s worth being able to recognize how it works. Exploring prototype-based
    inheritance also illuminates some of JavaScript’s inner workings, including the
    significance of the mysterious [[Prototype]] property you’ve been seeing in the
    Chrome console. Even if you don’t end up programming with prototype-based inheritance,
    understanding some of these underlying details can make it easier to use classes.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你已经熟悉使用类，那么学习基于原型的继承并非必需。然而，由于类是 JavaScript 的相对较新特性，在旧代码中仍然常常会遇到基于原型的继承，因此了解其工作原理是值得的。探索基于原型的继承还可以帮助我们理解
    JavaScript 的一些内部机制，包括你在 Chrome 控制台中看到的神秘[[Prototype]]属性的意义。即使你最终不使用基于原型的继承，了解一些这些底层的细节也能让你更轻松地使用类。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Using Constructors
    and Prototypes</samp>
  id: totrans-57
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">使用构造函数和原型</samp>
- en: 'As I mentioned, prototype-based inheritance involves a constructor function
    that creates instances of objects, and a prototype object that the instances inherit
    methods and properties from. This works because JavaScript creates links between
    the constructor, the prototype, and the new instance being created. Let’s take
    a look at this in action. We’ll create a new constructor function called Cat,
    and add a method called sayHello to its prototype. This will allow us to create
    Cat objects that have access to the sayHello method:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我提到的，基于原型的继承涉及一个构造函数，它创建对象实例，以及一个原型对象，实例从中继承方法和属性。这之所以可行，是因为 JavaScript 在构造函数、原型和正在创建的新实例之间建立了链接。让我们看看这一过程是如何进行的。我们将创建一个名为
    Cat 的新构造函数，并向其原型添加一个名为 sayHello 的方法。这将使我们能够创建 Cat 对象，这些对象可以访问 sayHello 方法：
- en: '[PRE8]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: We first create a constructor function called Cat with a name parameter. Constructor
    functions, like class names, usually start with a capital letter. The constructor’s
    body uses this.name = name to set the new object’s name property to the value
    of the provided name parameter. As with classes, the this keyword in a constructor
    refers to the object being produced.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先创建一个名为 Cat 的构造函数，并使用 name 参数。构造函数就像类名一样，通常以大写字母开头。构造函数的主体通过 this.name =
    name 来将新对象的 name 属性设置为提供的 name 参数的值。与类一样，构造函数中的 this 关键字指代正在被创建的对象。
- en: When the Cat constructor function is created, it’s automatically given a property
    called prototype. It might sound weird that functions can have properties, but
    a JavaScript function is actually a kind of object; the Cat function can have
    a prototype property just like a person object can have name and age properties.
    This property is accessible as Cat.prototype, using the same dot notation we’d
    use to access a property of any other object.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 当创建 Cat 构造函数时，它会自动获得一个名为 prototype 的属性。虽然函数有属性听起来有些奇怪，但 JavaScript 函数实际上是一种对象；Cat
    函数可以像 person 对象可以拥有 name 和 age 属性一样，拥有一个 prototype 属性。我们可以通过 Cat.prototype 来访问这个属性，使用与访问任何其他对象属性相同的点表示法。
- en: The value of Cat.prototype is itself an object, the prototype that Cat instances
    should be modeled after. By adding methods to this prototype object, we can control
    what methods any Cat instances will inherit. In this case, we use Cat.prototype.sayHello
    to add a sayHello method to the prototype. The method logs a greeting that includes
    the value of this.name to the console. When sayHello is called as a method on
    a particular instance, this in the method definition refers to that instance—just
    as it would in a method defined on a class—so this.name refers to the value of
    the instance’s name property.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: Cat.prototype 的值本身是一个对象，Cat 实例应该基于这个原型进行构建。通过向这个原型对象添加方法，我们可以控制任何 Cat 实例将继承哪些方法。在这个例子中，我们使用
    Cat.prototype.sayHello 将一个 sayHello 方法添加到原型中。该方法会将一个包含 this.name 值的问候语输出到控制台。当
    sayHello 被作为某个实例的方法调用时，方法定义中的 this 指代该实例——就像在类中定义的方法一样——因此 this.name 指代该实例的 name
    属性值。
- en: <samp class="SANS_Dogma_OT_Bold_B_21">NOTE</samp>
  id: totrans-63
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: <samp class="SANS_Dogma_OT_Bold_B_21">注意</samp>
- en: '*Notice that Cat.prototype.sayHello chains multiple dot notations together:
    Cat .prototype refers to the object stored in the Cat function’s prototype property,
    and .sayHello refers to the sayHello property of that object. That property doesn’t
    exist yet, so here we’re adding it to the object and setting its value to a function
    expression.*'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: '*注意，Cat.prototype.sayHello将多个点符号连接在一起：Cat.prototype指向存储在Cat函数的prototype属性中的对象，而.sayHello指向该对象的sayHello属性。这个属性还不存在，所以在这里我们将它添加到对象中，并将其值设置为一个函数表达式。*'
- en: 'We’ve created a Cat constructor and added a method to its prototype. Now let’s
    use the constructor to create a new instance that will inherit from the prototype:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经创建了一个Cat构造函数并将一个方法添加到它的原型中。现在让我们使用该构造函数创建一个新的实例，该实例将继承自原型：
- en: '[PRE9]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Here we create a new object from the Cat constructor by calling it with the
    new keyword, passing "Kiki" as an argument for the constructor’s name parameter.
    We store the resulting object in the kiki variable. Notice that if we’d declared
    Cat as a class rather than a constructor function, the syntax for creating an
    object would be exactly the same: new Cat("Kiki"). The only difference is whether
    we’re thinking of Cat as the name of a function or the name of a class.'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们通过使用new关键字调用Cat构造函数来创建一个新对象，并将"Kiki"作为构造函数的name参数传递。我们将结果对象存储在kiki变量中。请注意，如果我们把Cat声明为一个类而不是构造函数，创建对象的语法将完全相同：new
    Cat("Kiki")。唯一的区别是我们是将Cat视为函数的名称，还是类的名称。
- en: Next, we call the sayHello method on the new instance. Because kiki was created
    using the Cat constructor, it has a hidden link to Cat.prototype, which JavaScript
    uses to locate the sayHello definition. Since sayHello was called as a method
    on the kiki object, the this keyword in sayHello is set to kiki.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们在新的实例上调用sayHello方法。由于kiki是通过Cat构造函数创建的，它有一个指向Cat.prototype的隐藏链接，JavaScript使用这个链接来查找sayHello的定义。由于sayHello作为kiki对象的方法被调用，因此sayHello中的this关键字被设置为kiki。
- en: 'Although I’m calling the link between instance and prototype “hidden,” the
    Chrome console lets you inspect it via the special [[Prototype]] property. Let’s
    see what we can find out about kiki. Enter kiki; into the console and click the
    arrow at the side to inspect it:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管我把实例和原型之间的链接称为“隐藏的”，但是Chrome控制台允许你通过特殊的[[Prototype]]属性检查它。让我们看看能从kiki中发现什么。在控制台中输入kiki;，然后点击旁边的箭头查看其内容：
- en: '[PRE10]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'The first line of the output tells us that kiki was created with the Cat constructor.
    Next, we see that kiki has a name property with a value of "Kiki" (this was assigned
    when the constructor was called). We also see that kiki has a [[Prototype]] property
    whose value is an object. This is the “hidden” link I’ve been talking about to
    the prototype that this instance inherited from. It’s the same object referenced
    by Cat.prototype (the prototype property of the Cat constructor function). Click
    the arrow to expand [[Prototype]] and see what’s inside:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 输出的第一行告诉我们kiki是通过Cat构造函数创建的。接下来，我们看到kiki有一个名为"name"的属性，值为"Kiki"（这是在调用构造函数时分配的）。我们还看到kiki有一个[[Prototype]]属性，它的值是一个对象。这就是我所说的“隐藏的”链接，指向这个实例继承的原型。它是Cat.prototype（Cat构造函数的原型属性）引用的相同对象。点击箭头展开[[Prototype]]，看看里面有什么：
- en: '[PRE11]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: We can see that the prototype object has three properties. The first, sayHello,
    has a value that’s a function, as the f () indicates. This is the sayHello method
    we added to the prototype. The second, constructor, refers to the Cat constructor
    function. This cements the link between the constructor function and the prototype
    the constructor uses to create new instances. Finally, the prototype itself has
    its own [[Prototype]] property ❶, which we’ll explore shortly.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到原型对象有三个属性。第一个sayHello，它的值是一个函数，如f()所示。这是我们添加到原型中的sayHello方法。第二个constructor，指向Cat构造函数。这巩固了构造函数和它用来创建新实例的原型之间的联系。最后，原型本身有一个自己的[[Prototype]]属性❶，我们稍后会探索。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Comparing Constructors
    and Classes</samp>
  id: totrans-74
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">比较构造函数和类</samp>
- en: 'In prototype-based inheritance, the chain of references from an instance to
    its prototype and a prototype to its constructor is how JavaScript knows where
    to find the methods and properties for that instance. It turns out classes use
    these same techniques. To demonstrate, let’s create a Dog class that mirrors the
    functionality of our Cat constructor:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 在原型链继承中，从实例到其原型，再从原型到其构造函数的引用链是 JavaScript 知道在哪里找到该实例的方法和属性的方式。事实证明，类也使用了这些相同的技术。为了演示，我们创建一个
    Dog 类，它的功能与我们的 Cat 构造函数相似：
- en: '[PRE12]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'The constructor method here is equivalent to the Cat constructor function,
    and the sayHello method is equivalent to Cat.prototype.sayHello. Now let’s make
    a Dog instance and compare it to the kiki instance by expanding the [[Prototype]]
    properties:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的构造函数方法相当于 Cat 构造函数函数，而 sayHello 方法相当于 Cat.prototype.sayHello。现在，让我们创建一个 Dog
    实例，并通过扩展 [[Prototype]] 属性，将其与 kiki 实例进行比较：
- en: '[PRE13]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: As you can see, in both cases the sayHello method is found via the [[Prototype]]
    link. There are just some minor differences. For example, with kiki the constructor
    points at a function, whereas for felix it points at a class. Also, the sayHello
    method on felix has a name, whereas for kiki it doesn’t (because we defined sayHello
    using an anonymous function).
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，在这两种情况下，sayHello 方法都是通过 [[Prototype]] 链接找到的。只不过有一些小差异。例如，对于 kiki，构造函数指向一个函数，而对于
    felix，它指向一个类。此外，felix 上的 sayHello 方法有名字，而 kiki 上的则没有（因为我们使用匿名函数定义了 sayHello）。
- en: 'Note that if you want to access an object’s [[Prototype]] property directly
    in code, it’s available through the name __proto__:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，如果你想在代码中直接访问对象的 [[Prototype]] 属性，可以通过 __proto__ 来访问：
- en: '[PRE14]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Even though the property is technically called __proto__, we’ll continue to
    call it the [[Prototype]] property, as that’s how it shows up in the Chrome console.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 即使这个属性技术上叫做 __proto__，我们仍然称之为 [[Prototype]] 属性，因为它在 Chrome 控制台中是以这种方式显示的。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Exploring Object.prototype</samp>
  id: totrans-83
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">探索 Object.prototype</samp>
- en: Any object that isn’t created with an explicit constructor function is instead
    implicitly created with JavaScript’s built-in Object constructor function. The
    prototype this constructor references, available as Object.prototype, contains
    basic methods that all objects should inherit. This prototype object marks the
    end of the line in the chain of prototype references. All objects eventually trace
    their origin back to Object.prototype.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 任何不是通过显式构造函数创建的对象，都会隐式地使用 JavaScript 内置的 Object 构造函数创建。这个构造函数所引用的原型，通过 Object.prototype
    可用，包含了所有对象应该继承的基本方法。这个原型对象标志着原型链引用的终点。所有对象最终都会追溯到 Object.prototype。
- en: 'For example, while our kiki object was created with the Cat constructor, its
    prototype, Cat.prototype, was never explicitly created with a constructor. Instead,
    JavaScript implicitly created this object using the Object constructor, so its
    prototype is Object.prototype. This is what the inner [[Prototype]] property within
    our view of kiki in the previous code listing is telling us. We can expand that
    inner [[Prototype]] property to examine Object.prototype:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，尽管我们的 kiki 对象是使用 Cat 构造函数创建的，但它的原型，Cat.prototype，并没有显式地通过构造函数创建。相反，JavaScript
    隐式地使用 Object 构造函数创建了这个对象，因此它的原型是 Object.prototype。这就是我们在前面的代码示例中看到的 kiki 对象内部
    [[Prototype]] 属性所告诉我们的内容。我们可以扩展这个内部的 [[Prototype]] 属性来查看 Object.prototype：
- en: '[PRE15]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Notably, this inner prototype object has a constructor property whose value
    is the Object function ❶, showing that it’s the prototype property of JavaScript’s
    built-in Object constructor. The remaining properties correspond to the many default
    methods that all objects inherit. For example, hasOwnProperty is a method that
    checks if an object has a property defined on itself, rather than on its prototype,
    and toString is a method that returns a string representation of the object.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 值得注意的是，这个内部的原型对象有一个 constructor 属性，它的值是 Object 函数 ❶，这表明它是 JavaScript 内置 Object
    构造函数的原型属性。剩下的属性对应于所有对象继承的许多默认方法。例如，hasOwnProperty 是一个检查对象是否拥有自己定义的属性的方法，而不是从其原型继承的属性；toString
    是一个返回对象字符串表示的方法。
- en: 'When you create an object with an object literal, you aren’t creating it with
    an explicit constructor function, so it, too, is created implicitly with the Object
    constructor and gets Object.prototype for its prototype. When we were inspecting
    objects in the console in [Chapter 3](chapter3.xhtml) and saw they had a [[Prototype]]
    property, that’s what we were seeing. Let’s take another look at one now:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 当你使用对象字面量创建一个对象时，你并没有使用显式的构造函数来创建它，因此，它也是通过 Object 构造函数隐式创建的，并且其原型是 Object.prototype。当我们在[第3章](chapter3.xhtml)的控制台中检查对象时，看到它们有一个
    [[Prototype]] 属性，那就是我们所看到的内容。我们现在再来看一下：
- en: '[PRE16]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Here we declare a basic person object using an object literal, meaning it’s
    created behind the scenes with the default Object constructor. Inspecting the
    object in the console, we can see that the contents of its [[Prototype]] property
    are exactly the same as the innermost [[Prototype]] of the kiki object. Both objects
    trace their roots to Object.prototype, kiki indirectly through its own prototype
    (Cat.prototype) and person directly.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们使用对象字面量声明了一个基本的 person 对象，这意味着它背后通过默认的 Object 构造函数创建。通过在控制台中检查这个对象，我们可以看到它的
    [[Prototype]] 属性的内容与 kiki 对象的最内层 [[Prototype]] 完全相同。两个对象都追溯到 Object.prototype，kiki
    通过它自己的原型（Cat.prototype）间接追溯，而 person 直接追溯。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Walking the Prototype
    Chain</samp>
  id: totrans-91
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">原型链遍历</samp>
- en: 'When you ask for a property or method from an object, JavaScript first looks
    on the object itself. If it can’t find the property there, it looks on the object’s
    prototype. If JavaScript still can’t find the property, it then checks the prototype’s
    prototype, and so on, until it hits Object.prototype. This process is known as
    *walking the prototype chain*. Let’s look up some properties and methods that
    will walk the prototype chain of our kiki object:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 当你请求一个对象的属性或方法时，JavaScript 会首先在对象本身上查找。如果在对象中找不到这个属性，它会继续在对象的原型上查找。如果 JavaScript
    仍然找不到该属性，它将检查原型的原型，以此类推，直到查找到 Object.prototype。这个过程被称为*原型链遍历*。让我们查找一些属性和方法，它们将遍历我们
    kiki 对象的原型链：
- en: '[PRE17]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: First, we access the name property, which is set directly on kiki itself. Second,
    we call the sayHello method, which is found on the kiki object’s prototype. To
    call this method, JavaScript first checks on kiki and then, not finding it, checks
    on its prototype. Third, we call hasOwnProperty, a method from Object.prototype,
    which is the kiki object’s prototype’s prototype. (The method returns true, since
    the name property is set directly on kiki.) Finally, we call madeUpMethodName,
    a nonexistent method. After walking the entire prototype chain, from kiki to Cat.prototype
    to Object.prototype, JavaScript determines that the method can’t be found and
    throws an error.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们访问直接设置在 kiki 上的 name 属性。其次，我们调用 sayHello 方法，该方法位于 kiki 对象的原型上。为了调用这个方法，JavaScript
    会先检查 kiki，然后在找不到后，检查它的原型。第三，我们调用 hasOwnProperty，这是来自 Object.prototype 的方法，也就是
    kiki 对象的原型的原型。（该方法返回 true，因为 name 属性是直接在 kiki 上设置的。）最后，我们调用一个不存在的方法 madeUpMethodName。经过整个原型链的遍历，从
    kiki 到 Cat.prototype 再到 Object.prototype，JavaScript 确定找不到该方法，并抛出一个错误。
- en: '[Figure 6-1](chapter6.xhtml#fig6-1) shows a visual representation of the kiki
    object’s prototype chain and the associated constructor functions, Cat and Object.'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 6-1](chapter6.xhtml#fig6-1) 展示了 kiki 对象的原型链的视觉表示，以及相关的构造函数 Cat 和 Object。'
- en: '![](../images/Figure_6-1.png)'
  id: totrans-96
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/Figure_6-1.png)'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 6-1: The prototype chain
    for kiki</samp>'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">图 6-1：kiki 的原型链</samp>
- en: Each box in the diagram represents an object, with the object’s name as a heading.
    The left column of each box shows the names of the object’s properties, and the
    right column shows the values of those properties. For example, the kiki object’s
    name property has a value of "Kiki", and the Cat .prototype object’s sayHello
    property is a function, denoted by f () (remember that a method is just a function
    that’s a property of an object).
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 图中的每个框代表一个对象，框的标题是对象的名称。每个框的左列显示对象属性的名称，右列显示这些属性的值。例如，kiki 对象的 name 属性的值是 "Kiki"，而
    Cat.prototype 对象的 sayHello 属性是一个函数，用 f() 表示（记住，方法只是对象的一个属性，且这个属性是一个函数）。
- en: Some of the property values point at, or refer to, other objects. For example,
    all constructor functions have a prototype field that points to the object that
    will be used as the prototype for instances created with that constructor. Thus,
    the Cat constructor’s prototype field points to Cat.prototype. Likewise, objects
    have a link to their prototype through their [[Prototype]] property. For example,
    the [[Prototype]] property of kiki links to Cat.prototype, since kiki was created
    with the Cat constructor. All prototype objects have a constructor field that
    links back to the constructor they belong to. As you can see, the constructor
    field for Cat.prototype connects back to Cat, and the constructor field for Object.prototype
    connects to Object. Instances like kiki don’t have a constructor field defined
    directly on them. Instead, the constructor is looked up on the instance’s prototype
    by walking the prototype chain.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 一些属性值指向或引用其他对象。例如，所有构造函数都有一个指向该构造函数创建的实例所使用的原型的prototype字段。因此，Cat构造函数的prototype字段指向Cat.prototype。同样，对象通过它们的[[Prototype]]属性与它们的原型链接。例如，kiki的[[Prototype]]属性链接到Cat.prototype，因为kiki是通过Cat构造函数创建的。所有原型对象都有一个constructor字段，指向它们所属的构造函数。如你所见，Cat.prototype的constructor字段指向Cat，而Object.prototype的constructor字段指向Object。像kiki这样的实例没有直接定义constructor字段。相反，构造函数会通过实例的原型链进行查找。
- en: As we saw in the Dog example, classes use the same prototype mechanism under
    the hood, so this technique of walking the prototype chain is also how properties
    and methods are looked up on instances of classes.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在Dog示例中看到的，类在底层使用相同的原型机制，因此这种遍历原型链的技术也是查找类实例上属性和方法的方式。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Overriding a Method</samp>
  id: totrans-101
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">覆盖方法</samp>
- en: Understanding how JavaScript walks the prototype chain to locate an object’s
    methods is important because it allows us to *override* the definition of a method
    that an object would otherwise inherit from its prototype. This technique is useful
    when we want an object to inherit most of its behavior from a prototype, but we
    want to give it some unique behavior as well. When you call a method, JavaScript
    uses the first definition it finds for that method as it walks the prototype chain,
    so if we define a method directly on an object, and that method has the same name
    as a method defined on the object’s prototype, the method on the object itself
    takes precedence.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 理解JavaScript如何遍历原型链以查找对象的方法非常重要，因为这使我们能够*覆盖*一个方法的定义，而这个方法本来会从原型继承。这个技术在我们希望一个对象大部分行为继承自原型，但又希望它具有一些独特行为时非常有用。当你调用一个方法时，JavaScript会在遍历原型链时使用它找到的第一个定义，因此，如果我们在对象上直接定义一个方法，并且这个方法与对象原型上定义的方法同名，那么对象本身上的方法会优先。
- en: 'For example, say you want a new Cat object that says hello in a different way
    from the method defined on Cat.prototype. You could set a separate sayHello method
    directly on that new cat, like so:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，假设你想要一个新的Cat对象，它的问候方式与在Cat.prototype上定义的不同。你可以直接在这个新cat上设置一个单独的sayHello方法，像这样：
- en: '[PRE18]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Here, we define a new instance with the Cat constructor and name it moona. Then
    we define a sayHello method on moona itself that logs a greeting in all caps.
    When we then call moona.sayHello(), we can see in the output that the sayHello
    definition set directly on moona takes precedence over the sayHello definition
    on Cat.prototype ❶. This is also known as *shadowing*, because the local method
    casts a kind of shadow over the prototype’s method. Notice, however, that the
    original sayHello method on Cat.prototype remains intact, as you can see from
    the output when we call it on kiki ❷.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们使用Cat构造函数定义一个新实例，并命名为moona。然后，我们在moona本身上定义一个sayHello方法，该方法会打印全大写的问候语。当我们调用moona.sayHello()时，可以在输出中看到直接在moona上定义的sayHello方法优先于在Cat.prototype上的sayHello定义❶。这也被称为*遮蔽*，因为本地方法在某种程度上会“遮蔽”原型上的方法。然而，请注意，原始的sayHello方法仍然保持不变，正如我们在对kiki调用时看到的输出所示❷。
- en: <samp class="SANS_Futura_Std_Bold_B_11">Summary</samp>
  id: totrans-106
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">总结</samp>
- en: In this chapter you learned about classes, which help you organize your code
    by sharing functionality between multiple objects. You learned how to create classes,
    how to use them to create instances, and how to extend classes by creating a hierarchy
    of subclasses and superclasses. You also learned about prototype-based inheritance,
    JavaScript’s original system for allowing objects to inherit properties and methods.
    You explored how prototype-based inheritance compares to the newer class system,
    and you saw how to trace an object’s chain of inheritance through the [[Prototype]]
    property in the console.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你学习了类的概念，类帮助你通过在多个对象之间共享功能来组织代码。你学习了如何创建类，如何使用它们来创建实例，以及如何通过创建子类和父类的层次结构来扩展类。你还了解了基于原型的继承，这是
    JavaScript 允许对象继承属性和方法的原始系统。你探讨了基于原型的继承与更新后的类系统之间的比较，并了解了如何通过控制台中的[[Prototype]]属性追踪对象的继承链。
