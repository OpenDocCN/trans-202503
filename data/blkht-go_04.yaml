- en: '4'
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '4'
- en: HTTP SERVERS, ROUTING, AND MIDDLEWARE
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: HTTP 服务器、路由和中间件
- en: '![Image](Images/common.jpg)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Images/common.jpg)'
- en: If you know how to write HTTP servers from scratch, you can create customized
    logic for social engineering, command-and-control (C2) transports, or APIs and
    frontends for your own tools, among other things. Luckily, Go has a brilliant
    standard package—`net/http`—for building HTTP servers; it’s really all you need
    to effectively write not only simple servers, but also complex, full-featured
    web applications.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您知道如何从头编写 HTTP 服务器，您可以为社交工程、命令与控制（C2）传输、API 和前端工具等创建定制化的逻辑。幸运的是，Go 提供了一个出色的标准包——`net/http`——用于构建
    HTTP 服务器；它几乎是您编写不仅是简单服务器，还是复杂、功能完备的 Web 应用程序所需的一切。
- en: In addition to the standard package, you can leverage third-party packages to
    speed up development and remove some of the tedious processes, such as pattern
    matching. These packages will assist you with routing, building middleware, validating
    requests, and other tasks.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 除了标准包外，您还可以利用第三方包来加速开发，去除一些繁琐的过程，如模式匹配。这些包将帮助您进行路由、构建中间件、验证请求以及其他任务。
- en: In this chapter, you’ll first explore many of the techniques needed to build
    HTTP servers using simple applications. Then you’ll deploy these techniques to
    create two social engineering applications—a credential-harvesting server and
    a keylogging server—and multiplex C2 channels.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，您将首先探索构建 HTTP 服务器所需的许多技术，并通过简单的应用程序进行实践。接着，您将使用这些技术创建两个社交工程应用程序——凭证收集服务器和键盘记录服务器，并多路复用
    C2 通道。
- en: HTTP Server Basics
  id: totrans-6
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: HTTP 服务器基础
- en: In this section, you’ll explore the `net/http` package and useful third-party
    packages by building simple servers, routers, and middleware. We’ll expand on
    these basics to cover more nefarious examples later in the chapter.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，您将通过构建简单的服务器、路由器和中间件，探索 `net/http` 包及一些有用的第三方包。我们将在本章后续内容中扩展这些基础知识，涵盖更多恶意示例。
- en: Building a Simple Server
  id: totrans-8
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 构建一个简单的服务器
- en: The code in [Listing 4-1](ch04.xhtml#ch4list1) starts a server that handles
    requests to a single path. (All the code listings at the root location of / exist
    under the provided github repo *[https://github.com/blackhat-go/bhg/](https://github.com/blackhat-go/bhg/)*.)
    The server should locate the `name` URL parameter containing a user’s name and
    respond with a customized greeting.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: '[列表 4-1](ch04.xhtml#ch4list1) 中的代码启动了一个处理单一路径请求的服务器。（所有位于根目录 / 的代码清单都可以在提供的
    GitHub 仓库 *[https://github.com/blackhat-go/bhg/](https://github.com/blackhat-go/bhg/)*
    中找到。）服务器应该获取包含用户名称的 `name` URL 参数，并返回自定义的问候语。'
- en: '[PRE0]'
  id: totrans-10
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '*Listing 4-1: A Hello World server (*[/ch-4/hello_world/main.go](https://github.com/blackhat-go/bhg/blob/master/ch-4/hello_world/main.go)*)*'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 4-1：一个 Hello World 服务器 (*[/ch-4/hello_world/main.go](https://github.com/blackhat-go/bhg/blob/master/ch-4/hello_world/main.go)*)*'
- en: 'This simple example exposes a resource at `/hello`. The resource grabs the
    parameter and echoes its value back to the client. Within the `main()` function,
    `http.HandleFunc()` ❶ takes two arguments: a string, which is a URL path pattern
    you’re instructing your server to look for, and a function, which will actually
    handle the request. You could provide the function definition as an anonymous
    inline function, if you want. In this example, you pass in the function named
    `hello()` that you defined earlier.'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 这个简单的例子暴露了一个 `/hello` 资源。该资源抓取参数并将其值回显给客户端。在 `main()` 函数中，`http.HandleFunc()`
    ❶ 接受两个参数：一个字符串，它是您指示服务器查找的 URL 路径模式；另一个是一个函数，实际处理请求。如果您愿意，可以将函数定义作为匿名内联函数提供。在这个例子中，您传入的是之前定义的名为
    `hello()` 的函数。
- en: The `hello()` function handles requests and returns a hello message to the client.
    It takes two arguments itself. The first is `http.ResponseWriter`, which is used
    to write responses to the request. The second argument is a pointer to `http.Request`,
    which will allow you to read information from the incoming request. Note that
    you aren’t calling your `hello()` function from `main()`. You’re simply telling
    your HTTP server that any requests for `/hello` should be handled by a function
    named `hello()`.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: '`hello()` 函数处理请求并返回一条问候消息给客户端。它自身接受两个参数。第一个是 `http.ResponseWriter`，用于写入响应内容。第二个参数是指向
    `http.Request` 的指针，它允许您从传入的请求中读取信息。请注意，您并不是从 `main()` 调用 `hello()` 函数。您只是告诉 HTTP
    服务器，任何指向 `/hello` 的请求应该由名为 `hello()` 的函数来处理。'
- en: Under the covers, what does `http.HandleFunc()` actually do? The Go documentation
    will tell you that it places the handler on the `DefaultServerMux`. A `ServerMux`
    is short for a *server multiplexer*, which is just a fancy way to say that the
    underlying code can handle multiple HTTP requests for patterns and functions.
    It does this using goroutines, with one goroutine per incoming request. Importing
    the `net/http` package creates a `ServerMux` and attaches it to that package’s
    namespace; this is the `DefaultServerMux`.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在背后，`http.HandleFunc()` 实际上是做什么的呢？Go 文档告诉你，它将处理程序放置在 `DefaultServerMux` 上。`ServerMux`
    是 *服务器多路复用器*（server multiplexer）的缩写，这只是一个花哨的说法，表示底层代码能够处理多个 HTTP 请求，匹配不同的模式和功能。它通过使用
    goroutines 来实现，每个传入请求都有一个 goroutine。导入 `net/http` 包会创建一个 `ServerMux` 并将其附加到该包的命名空间中；这就是
    `DefaultServerMux`。
- en: The next line is a call to `http.ListenAndServe()` ❷, which takes a string and
    an `http.Handler` as arguments. This starts an HTTP server by using the first
    argument as the address. In this case, that’s `:8000`, which means the server
    should listen on port 8000 across all interfaces. For the second argument, the
    `http.Handler`, you pass in `nil`. As a result, the package uses `DefaultServerMux`
    as the underlying handler. Soon, you’ll be implementing your own `http.Handler`
    and will pass that in, but for now you’ll just use the default. You could also
    use `http.ListenAndServeTLS()`, which will start a server using HTTPS and TLS,
    as the name describes, but requires additional parameters.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 下一行是对 `http.ListenAndServe()` ❷ 的调用，它接受一个字符串和一个 `http.Handler` 作为参数。这会通过使用第一个参数作为地址来启动
    HTTP 服务器。在这个例子中，是 `:8000`，意味着服务器应该在所有接口上监听端口 8000。对于第二个参数，即 `http.Handler`，你传递
    `nil`。结果是该包使用 `DefaultServerMux` 作为底层处理程序。很快，你将实现自己的 `http.Handler` 并传入它，但现在你只会使用默认的。你也可以使用
    `http.ListenAndServeTLS()`，它将启动一个使用 HTTPS 和 TLS 的服务器，正如其名称所示，但需要额外的参数。
- en: 'Implementing the `http.Handler` interface requires a single method: `ServeHTTP(http.ResponseWriter,
    *http.Request)`. This is great because it simplifies the creation of your own
    custom HTTP servers. You’ll find numerous third-party implementations that extend
    the `net/http` functionality to add features such as middleware, authentication,
    response encoding, and more.'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 实现 `http.Handler` 接口需要一个方法：`ServeHTTP(http.ResponseWriter, *http.Request)`。这非常棒，因为它简化了创建自定义
    HTTP 服务器的过程。你会发现许多第三方实现扩展了 `net/http` 功能，增加了中间件、认证、响应编码等功能。
- en: 'You can test this server by using `curl`:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用 `curl` 来测试这个服务器：
- en: '[PRE1]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Excellent! The server you built reads the `name` URL parameter and replies with
    a greeting.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 太好了！你构建的服务器可以读取 `name` URL 参数并回复问候信息。
- en: Building a Simple Router
  id: totrans-20
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 构建一个简单的路由器
- en: Next you’ll build a simple router, shown in [Listing 4-2](ch04.xhtml#ch4list2),
    that demonstrates how to dynamically handle inbound requests by inspecting the
    URL path. Depending on whether the URL contains the path `/a`, `/b`, or `/c`,
    you’ll print either the message `Executing /a`, `Executing /b`, or `Executing
    /c`. You’ll print a `404 Not Found` error for everything else.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，你将构建一个简单的路由器，见 [清单 4-2](ch04.xhtml#ch4list2)，它演示了如何通过检查 URL 路径动态处理传入请求。根据
    URL 是否包含路径 `/a`、`/b` 或 `/c`，你将分别打印 `Executing /a`、`Executing /b` 或 `Executing
    /c`。对于其他情况，你将打印 `404 Not Found` 错误。
- en: '[PRE2]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '*Listing 4-2: A simple router (*[/ch-4/simple_router/main.go](https://github.com/blackhat-go/bhg/blob/master/ch-4/simple_router/main.go)*)*'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 4-2：一个简单的路由器 (*[/ch-4/simple_router/main.go](https://github.com/blackhat-go/bhg/blob/master/ch-4/simple_router/main.go)*)*'
- en: First, you define a new type named `router` without any fields ❶. You’ll use
    this to implement the `http.Handler` interface. To do this, you must define the
    `ServeHTTP()` method ❷. The method uses a `switch` statement on the request’s
    URL path ❸, executing different logic depending on the path. It uses a default
    `404 Not Found` response action. In `main()`, you create a new `router` and pass
    its respective pointer to `http.ListenAndServe()` ❹.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，你定义一个名为 `router` 的新类型，且不带任何字段 ❶。你将使用这个类型来实现 `http.Handler` 接口。为此，你必须定义 `ServeHTTP()`
    方法 ❷。该方法使用一个 `switch` 语句来判断请求的 URL 路径 ❸，根据路径执行不同的逻辑。它使用默认的 `404 Not Found` 响应行为。在
    `main()` 中，你创建一个新的 `router`，并将其指针传递给 `http.ListenAndServe()` ❹。
- en: 'Let’s take this for a spin in the ole terminal:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在终端中试试这个：
- en: '[PRE3]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Everything works as expected; the program returns the message `Executing` `/a`
    for a URL that contains the `/a` path, and it returns a 404 response on a path
    that doesn’t exist. This is a trivial example. The third-party routers that you’ll
    use will have much more complex logic, but this should give you a basic idea of
    how they work.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 一切按预期工作；对于包含`/a`路径的URL，程序返回消息`Executing` `/a`，对于不存在的路径则返回404响应。这是一个简单的示例。你将使用的第三方路由器将具有更复杂的逻辑，但这应该能给你一个基本的理解，帮助你了解它们是如何工作的。
- en: Building Simple Middleware
  id: totrans-28
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 构建简单的中间件
- en: Now let’s build *middleware*, which is a sort of wrapper that will execute on
    all incoming requests regardless of the destination function. In the example in
    [Listing 4-3](ch04.xhtml#ch4list3), you’ll create a logger that displays the request’s
    processing start and stop time.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们构建*中间件*，这是一种包装器，将在所有传入请求上执行，无论目标函数是什么。在[列表 4-3](ch04.xhtml#ch4list3)中的示例中，你将创建一个日志记录器，显示请求的处理开始和结束时间。
- en: '[PRE4]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '*Listing 4-3: Simple middleware (*[/ch-4/simple_middleware/main.go](https://github.com/blackhat-go/bhg/blob/master/ch-4/simple_middleware/main.go)*)*'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 4-3：简单中间件 (*[/ch-4/simple_middleware/main.go](https://github.com/blackhat-go/bhg/blob/master/ch-4/simple_middleware/main.go)*)*'
- en: What you’re essentially doing is creating an outer handler that, on every request,
    logs some information on the server and calls your `hello()` function. You wrap
    this logging logic around your function.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 本质上，你所做的是创建一个外部处理程序，在每个请求中，记录服务器上的一些信息并调用你的`hello()`函数。你将这个日志记录逻辑包裹在你的函数周围。
- en: As with the routing example, you define a new type named `logger`, but this
    time you have a field, `Inner`, which is an `http.Handler` itself ❶. In your `ServeHTTP()`
    definition ❷, you use `log()` to print the start and finish times of the request,
    calling the inner handler’s `ServeHTTP()` method in between ❸. To the client,
    the request will finish inside the inner handler. Inside `main()`, you use `http.HandlerFunc()`
    to create an `http.Handler` out of a function ❹. You create the `logger`, setting
    `Inner` to your newly created handler ❺. Finally, you start the server by using
    a pointer to a `logger` instance ❻.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 与路由示例一样，你定义了一个名为`logger`的新类型，但这一次你有一个字段`Inner`，它本身是一个`http.Handler` ❶。在你的`ServeHTTP()`定义中
    ❷，你使用`log()`打印请求的开始和结束时间，并在中间调用内部处理程序的`ServeHTTP()`方法 ❸。对于客户端来说，请求将在内部处理程序中完成。在`main()`中，你使用`http.HandlerFunc()`将函数转换为`http.Handler`
    ❹。你创建了`logger`，将`Inner`设置为你新创建的处理程序 ❺。最后，你使用指向`logger`实例的指针启动服务器 ❻。
- en: 'Running this and issuing a request outputs two messages containing the start
    and finish times of the request:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 运行此程序并发出请求将输出两条消息，包含请求的开始和结束时间：
- en: '[PRE5]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: In the following sections, we’ll dig deeper into middleware and routing and
    use some of our favorite third-party packages, which let you create more dynamic
    routes and execute middleware inside a chain. We’ll also discuss some use cases
    for middleware that move into more complex scenarios.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的章节中，我们将深入探讨中间件和路由，并使用一些我们最喜欢的第三方包，这些包让你能够创建更动态的路由并在链内执行中间件。我们还将讨论一些中间件的用例，这些用例涉及更复杂的场景。
- en: Routing with the gorilla/mux Package
  id: totrans-37
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 使用gorilla/mux包进行路由
- en: 'As shown in [Listing 4-2](ch04.xhtml#ch4list2), you can use routing to match
    a request’s path to a function. But you can also use it to match other properties—such
    as the HTTP verb or host header—to a function. Several third-party routers are
    available in the Go ecosystem. Here, we’ll introduce you to one of them: the `gorilla/mux`
    package. But just as with everything, we encourage you to expand your knowledge
    by researching additional packages as you encounter them.'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 如[列表 4-2](ch04.xhtml#ch4list2)所示，你可以使用路由来将请求路径匹配到函数。但你也可以用它来匹配其他属性——如HTTP动词或主机头——到一个函数。在Go生态系统中有几个第三方路由器可以使用。在这里，我们将介绍其中一个：`gorilla/mux`包。但就像任何事情一样，我们鼓励你通过在遇到其他包时进行研究，来扩展你的知识。
- en: The `gorilla/mux` package is a mature, third-party routing package that allows
    you to route based on both simple and complex patterns. It includes regular expressions,
    parameter matching, verb matching, and sub routing, among other features.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: '`gorilla/mux`包是一个成熟的第三方路由包，它允许你根据简单和复杂的模式进行路由。它包括正则表达式、参数匹配、动词匹配和子路由等功能。'
- en: Let’s go over a few examples of how you might use the router. There is no need
    to run these, as you’ll be using them in a real program soon, but please feel
    free to play around and experiment.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看几个使用路由器的示例。没有必要运行这些示例，因为你很快就会在实际程序中使用它们，但请随意玩耍和实验。
- en: 'Before you can use `gorilla/mux`, you must `go get` it:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 在你可以使用`gorilla/mux`之前，你必须先执行`go get`命令：
- en: '[PRE6]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Now, you can start routing. Create your router by using `mux.NewRouter()`:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你可以开始路由了。使用`mux.NewRouter()`来创建你的路由器：
- en: '[PRE7]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'The returned type implements `http.Handler` but has a host of other associated
    methods as well. The one you’ll use most often is `HandleFunc()`. For example,
    if you wanted to define a new route to handle GET requests to the pattern `/foo`,
    you could use this:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 返回的类型实现了`http.Handler`，但还有许多其他相关方法。你最常用的是`HandleFunc()`。例如，如果你想定义一个新的路由来处理GET请求，模式为`/foo`，你可以这样写：
- en: '[PRE8]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Now, because of the call to `Methods()` ❶, only GET requests will match this
    route. All other methods will return a 404 response. You can chain other qualifiers
    on top of this, such as `Host(string)`, which matches a particular host header
    value. For example, the following will match only requests whose host header is
    set to *www.foo.com*:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，由于调用了`Methods()` ❶，只有GET请求会匹配这个路由。所有其他方法将返回404响应。你可以在此基础上链接其他限定条件，例如`Host(string)`，它匹配特定的主机头值。例如，以下将仅匹配主机头设置为*www.foo.com*的请求：
- en: '[PRE9]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Sometimes it’s helpful to match and pass in parameters within the request path
    (for example, when implementing a RESTful API). This is simple with `gorilla/mux`.
    The following will print out anything following `/users/` in the request’s path:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 有时在请求路径中匹配并传递参数是有帮助的（例如，在实现RESTful API时）。使用`gorilla/mux`这很简单。以下内容将打印出请求路径中`/users/`后的任何内容：
- en: '[PRE10]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'In the path definition, you use braces to define a request parameter. Think
    of this as a named placeholder. Then, inside the handler function, you call `mux.Vars()`,
    passing it the request object, which returns a `map[string]``string`—a map of
    request parameter names to their respective values. You provide the named placeholder
    `user` as the key. So, a request to `/users/bob` should produce a greeting for
    Bob:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 在路径定义中，你使用花括号来定义请求参数。把它当作一个命名的占位符。然后，在处理函数中，你调用`mux.Vars()`，并将请求对象传递给它，这样就会返回一个`map[string]string`——一个请求参数名称及其相应值的映射。你提供命名占位符`user`作为键。因此，访问`/users/bob`的请求应该会为Bob提供一个问候：
- en: '[PRE11]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'You can take this a step further and use a regular expression to qualify the
    patterns passed. For example, you can specify that the `user` parameter must be
    lowercase letters:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以更进一步，使用正则表达式来限定传递的模式。例如，你可以指定`user`参数必须是小写字母：
- en: '[PRE12]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Any requests that don’t match this pattern will now return a 404 response:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，任何不匹配该模式的请求将返回404响应：
- en: '[PRE13]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: In the next section, we’ll expand on routing to include some middleware implementations
    using other libraries. This will give you increased flexibility with handling
    HTTP requests.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将扩展路由功能，加入一些中间件实现，使用其他库。这将增加你处理HTTP请求的灵活性。
- en: Building Middleware with Negroni
  id: totrans-58
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 使用Negroni构建中间件
- en: The simple middleware we showed earlier logged the start and end times of the
    handling of the request and returned the response. Middleware doesn’t have to
    operate on every incoming request, but most of the time that will be the case.
    There are many reasons to use middleware, including logging requests, authenticating
    and authorizing users, and mapping resources.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 我们之前展示的简单中间件记录了请求处理的开始和结束时间，并返回了响应。中间件不必作用于每一个传入的请求，但大多数时候是这样的。使用中间件的原因有很多，包括记录请求、身份验证和授权用户、映射资源等。
- en: For example, you could write middleware for performing basic authentication.
    It could parse an authorization header for each request, validate the username
    and password provided, and return a 401 response if the credentials are invalid.
    You could also chain multiple middleware functions together in such a way that
    after one is executed, the next one defined is run.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，你可以为执行基本身份验证编写中间件。它可以解析每个请求的授权头，验证提供的用户名和密码，并在凭据无效时返回401响应。你还可以将多个中间件函数连接在一起，按顺序执行，第一个执行后下一个定义的函数会被运行。
- en: 'For the logging middleware you created earlier in this chapter, you wrapped
    only a single function. In practice, this is not very useful, because you’ll want
    to use more than one, and to do this, you must have logic that can execute them
    in a chain, one after another. Writing this from scratch is not incredibly difficult,
    but let’s not re-create the wheel. Here, you’ll use a mature package that is already
    able to do this: `negroni`.'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 对于本章前面创建的日志中间件，你只包装了一个单一的函数。实际上，这样做并不太有用，因为你会想使用多个中间件，而要做到这一点，你必须有能将它们按顺序执行的逻辑。从头编写这个并不特别困难，但我们不必重新发明轮子。在这里，你将使用一个已经能够做到这一点的成熟包：`negroni`。
- en: 'The `negroni` package, which you can find at [*https://github.com/urfave/negroni/*](https://github.com/urfave/negroni/),
    is great because it doesn’t tie you into a larger framework. You can easily bolt
    it onto other frameworks, and it provides a lot of flexibility. It also comes
    with default middleware that is useful for many applications. Before you hop in,
    you need to `go get negroni`:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: '`negroni`包，你可以在[*https://github.com/urfave/negroni/*](https://github.com/urfave/negroni/)找到，它非常棒，因为它不把你绑在一个更大的框架中。你可以很容易地将它与其他框架结合使用，并且它提供了很大的灵活性。它还自带许多应用中很有用的默认中间件。在开始之前，你需要运行`go
    get negroni`：'
- en: '[PRE14]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: While you technically could use `negroni` for all application logic, doing this
    is far from ideal because it’s purpose-built to act as middleware and doesn’t
    include a router. Instead, it’s best to use `negroni` in combination with another
    package, such as `gorilla/mux` or `net/http`. Let’s use `gorilla/mux` to build
    a program that will get you acquainted with `negroni` and allow you to visualize
    the order of operations as they traverse the middleware chain.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然从技术上讲，你可以使用`negroni`来处理所有应用逻辑，但这样做远非理想，因为它是专门为中间件而设计的，并不包含路由器。因此，最好的做法是将`negroni`与另一个包结合使用，例如`gorilla/mux`或`net/http`。我们将使用`gorilla/mux`来构建一个程序，这样你就能熟悉`negroni`并看到它在中间件链中按顺序遍历时的操作顺序。
- en: Start by creating a new file called *main.go* within a directory namespace,
    such as *[github.com/blackhat-go/bhg/ch-4/negroni_example/](http://github.com/blackhat-go/bhg/ch-4/negroni_example/)*.
    (This namespace will already be created in the event you cloned the BHG Github
    repository.) Now modify your *main.go* file to include the following code.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 从创建一个名为*main.go*的新文件开始，放置在某个目录命名空间中，例如* [github.com/blackhat-go/bhg/ch-4/negroni_example/](http://github.com/blackhat-go/bhg/ch-4/negroni_example/)*。(如果你已经克隆了BHG的GitHub仓库，这个命名空间将已经创建。)现在，修改你的*main.go*文件，加入以下代码。
- en: '[PRE15]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '*Listing 4-4: Negroni example (*[/ch-4/negroni_example/main.go](https://github.com/blackhat-go/bhg/blob/master/ch-4/negroni_example/main.go)*)*'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: '*Listing 4-4: Negroni示例 (*[/ch-4/negroni_example/main.go](https://github.com/blackhat-go/bhg/blob/master/ch-4/negroni_example/main.go)*)*'
- en: 'First, you create a router as you did earlier in this chapter by calling `mux.NewRouter()`
    ❶. Next comes your first interaction with the `negroni` package: you make a call
    to `negroni.Classic()` ❷. This creates a new pointer to a `Negroni` instance.'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，通过调用`mux.NewRouter()` ❶，像本章前面那样创建一个路由器。接下来，你将首次与`negroni`包进行交互：调用`negroni.Classic()`
    ❷。这会创建一个指向`Negroni`实例的新指针。
- en: There are different ways to do this. You can either use `negroni.Classic()`
    or call `negroni.New()`. The first, `negroni.Classic()`, sets up default middleware,
    including a request logger, recovery middleware that will intercept and recover
    from panics, and middleware that will serve files from the public folder in the
    same directory. The `negroni.New()` function doesn’t create any default middleware.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 这样做有不同的方式。你可以使用`negroni.Classic()`，也可以调用`negroni.New()`。前者`negroni.Classic()`会设置默认的中间件，包括请求日志记录器、能够拦截并从panic中恢复的恢复中间件，以及提供同一目录中public文件夹中文件的中间件。而`negroni.New()`函数则不会创建任何默认中间件。
- en: 'Each type of middleware is available in the `negroni` package. For example,
    you can use the recovery package by doing the following:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 每种类型的中间件都可以在`negroni`包中找到。例如，你可以通过以下方式使用恢复包：
- en: '[PRE16]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Next, you add your router to the middleware stack by calling `n.Use``Handler(r)`
    ❸. As you continue to plan and build out your middleware, consider the order of
    execution. For example, you’ll want your authentication-checking middleware to
    run prior to the handler functions that require authentication. Any middleware
    mounted before the router will execute prior to your handler functions; any middleware
    mounted after the router will execute after your handler functions. Order matters.
    In this case, you haven’t defined any custom middleware, but you will soon.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，你通过调用`n.Use``Handler(r)` ❸将路由器添加到中间件堆栈中。在继续规划和构建中间件时，要考虑执行顺序。例如，你希望在需要身份验证的处理函数之前运行身份验证检查中间件。任何在路由器之前挂载的中间件都会在你的处理函数之前执行；任何在路由器之后挂载的中间件都会在你的处理函数之后执行。顺序很重要。在这种情况下，你还没有定义任何自定义中间件，但你很快会这样做。
- en: 'Go ahead and build the server you created in [Listing 4-4](ch04.xhtml#ch4list4),
    and then execute it. Then issue web requests to the server at *http://localhost:8000*.
    You should see the `negroni` logging middleware print information to stdout, as
    shown next. The output shows the timestamp, response code, processing time, host,
    and HTTP method:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 继续构建你在[清单 4-4](ch04.xhtml#ch4list4)中创建的服务器，并执行它。然后向服务器发送Web请求，访问 *http://localhost:8000*。你应该能看到`negroni`的日志中间件将信息打印到stdout，如下所示。输出会显示时间戳、响应代码、处理时间、主机和HTTP方法：
- en: '[PRE17]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Having default middleware is great and all, but the real power comes when you
    create your own. With `negroni`, you can use a few methods to add middleware to
    the stack. Take a look at the following code. It creates trivial middleware that
    prints a message and passes execution to the next middleware in the chain:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 拥有默认中间件是很好的，但真正的力量在于你创建自己的中间件。使用`negroni`，你可以使用几种方法将中间件添加到堆栈中。看看下面的代码。它创建了一个简单的中间件，打印一条信息并将执行传递给链中的下一个中间件：
- en: '[PRE18]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'This implementation is slightly different from previous examples. Before, you
    were implementing the `http.Handler` interface, which expected a `ServeHTTP()`
    method that accepted two parameters: `http.ResponseWriter` and `*http.Request`.
    In this new example, instead of the `http.Handler` interface, you’re implementing
    the `negroni.Handler` interface.'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 这个实现与之前的示例略有不同。之前，你是实现了`http.Handler`接口，该接口期望有一个`ServeHTTP()`方法，该方法接受两个参数：`http.ResponseWriter`和`*http.Request`。在这个新的示例中，你不是实现`http.Handler`接口，而是实现了`negroni.Handler`接口。
- en: 'The slight difference is that the `negroni.Handler` interface expects you to
    implement a `ServeHTTP()` method that accepts not two, but three, parameters:
    `http.ResponseWriter`, `*http.Request`, and `http.HandlerFunc` ❶. The `http.HandlerFunc`
    parameter represents the next middleware function in the chain. For your purposes,
    you name it `next`. You do your processing within `ServeHTTP()`, and then call
    `next()` ❷, passing it the `http.ResponseWriter` and `*http.Request` values you
    originally received. This effectively transfers execution down the chain.'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 轻微的不同在于，`negroni.Handler`接口期望你实现一个`ServeHTTP()`方法，该方法接受三个参数，而不是两个：`http.ResponseWriter`、`*http.Request`和`http.HandlerFunc`
    ❶。`http.HandlerFunc`参数表示链中下一个中间件函数。为了你的目的，你可以将它命名为`next`。你在`ServeHTTP()`中进行处理，然后调用`next()`
    ❷，将最初接收到的`http.ResponseWriter`和`*http.Request`值传递给它。这有效地将执行权传递到链中的下一个中间件。
- en: 'But you still have to tell `negroni` to use your implementation as part of
    the middleware chain. You can do this by calling `negroni`’s `Use` method and
    passing an instance of your `negroni.Handler` implementation to it:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 但你仍然需要告诉`negroni`使用你的实现作为中间件链的一部分。你可以通过调用`negroni`的`Use`方法，并将你的`negroni.Handler`实现的实例传递给它来实现这一点：
- en: '[PRE19]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Writing your middleware by using this method is convenient because you can
    easily pass execution to the next middleware. There is one drawback: anything
    you write must use `negroni`. For example, if you were writing a middleware package
    that writes security headers to a response, you would want it to implement `http.Handler`,
    so you could use it in other application stacks, since most stacks won’t expect
    a `negroni.Handler`. The point is, regardless of your middleware’s purpose, compatibility
    issues may arise when trying to use `negroni` middleware in a non-`negroni` stack,
    and vice versa.'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这种方法编写中间件非常方便，因为你可以轻松地将执行权传递给下一个中间件。唯一的缺点是：你编写的任何内容都必须使用`negroni`。例如，如果你正在编写一个中间件包，它将安全头信息写入响应中，你可能希望它实现`http.Handler`，这样就可以在其他应用程序堆栈中使用它，因为大多数堆栈不会期望`negroni.Handler`。重点是，不论你的中间件目的是什么，在非`negroni`堆栈中使用`negroni`中间件时可能会出现兼容性问题，反之亦然。
- en: There are two other ways to tell `negroni` to use your middleware. `UseHandler``(handler
    http.Handler)`, which you’re already familiar with, is the first. The second way
    is to call `UseHandleFunc(handlerFunc func(w http.ResponseWriter,` `r *http.Request))`.
    The latter is not something you’ll want to use often, since it doesn’t let you
    forgo execution of the next middleware in the chain. For example, if you were
    writing middleware to perform authentication, you would want to return a 401 response
    and stop execution if any credentials or session information were invalid; with
    this method, there’s no way to do that.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 还有两种方式可以告诉`negroni`使用你的中间件。第一种是你已经熟悉的`UseHandler(handler http.Handler)`。第二种方式是调用`UseHandleFunc(handlerFunc
    func(w http.ResponseWriter, r *http.Request))`。后者不建议频繁使用，因为它不允许你跳过执行链中下一个中间件。例如，如果你编写一个进行身份验证的中间件，当凭证或会话信息无效时，你可能想返回401响应并停止执行；使用这种方法无法实现这一点。
- en: Adding Authentication with Negroni
  id: totrans-83
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 使用Negroni添加身份验证
- en: Before moving on, let’s modify our example from the previous section to demonstrate
    the use of `context`, which can easily pass variables between functions. The example
    in [Listing 4-5](ch04.xhtml#ch4list5) uses `negroni` to add authentication middleware.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 在继续之前，让我们修改上一节的示例，演示如何使用`context`，它可以轻松地在函数之间传递变量。 [列表 4-5](ch04.xhtml#ch4list5)中的示例使用`negroni`添加了身份验证中间件。
- en: '[PRE20]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: '*Listing 4-5: Using context in handlers (*/[ch-4/negroni_example/main.go](https://github.com/blackhat-go/bhg/blob/master/ch-4/negroni_example/main.go)*)*'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 4-5：在处理程序中使用上下文（*/[ch-4/negroni_example/main.go](https://github.com/blackhat-go/bhg/blob/master/ch-4/negroni_example/main.go)*)*'
- en: You’ve added new middleware, `badAuth`, that is going to simulate authentication,
    purely for demonstration purposes ❶. This new type has two fields, `Username`
    and `Password`, and implements `negroni.Handler`, since it defines the three-parameter
    version of the `ServeHTTP()` method ❷ we discussed previously. Inside the `ServeHTTP()`
    method, you first grab the username and password from the request ❸, and then
    compare them to the fields you have. If the username and password are incorrect,
    execution is stopped, and a 401 response is written to the requester.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 你已添加了新的中间件`badAuth`，它将模拟身份验证，仅用于演示目的❶。这个新类型有两个字段，`Username`和`Password`，并实现了`negroni.Handler`，因为它定义了我们之前讨论过的三参数版本的`ServeHTTP()`方法❷。在`ServeHTTP()`方法内部，你首先从请求中获取用户名和密码❸，然后将其与已有字段进行比较。如果用户名和密码不正确，执行将停止，并向请求方写入401响应。
- en: Notice that you return ❹ before calling `next()`. This prevents the remainder
    of the middleware chain from executing. If the credentials are correct, you go
    through a rather verbose routine of adding the username to the request context.
    You first call `context.WithValue()` to initialize the context from the request,
    setting a variable named `username` on that context ❺. You then make sure the
    request uses your new context by calling `r.WithContext(ctx)` ❻. If you plan on
    writing web applications with Go, you’ll want to become familiar with this pattern,
    as you’ll be using it a lot.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，在调用`next()`之前你先返回❹。这可以防止中间件链的其余部分继续执行。如果凭证正确，你将通过一个相当冗长的例程将用户名添加到请求上下文中。你首先调用`context.WithValue()`初始化请求上下文，并在该上下文中设置一个名为`username`的变量❺。然后，你通过调用`r.WithContext(ctx)`来确保请求使用你的新上下文❻。如果你打算使用Go编写Web应用程序，你需要熟悉这种模式，因为你会频繁使用它。
- en: In the `hello()` function, you get the username from the request context by
    using the `Context().Value(interface{})` function, which itself returns an `interface{}`.
    Because you know it’s a string, you can use a type assertion here ❼. If you can’t
    guarantee the type, or you can’t guarantee that the value will exist in the context,
    use a `switch` routine for conversion.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 在`hello()`函数中，你通过使用`Context().Value(interface{})`函数从请求上下文中获取用户名，该函数本身返回一个`interface{}`。因为你知道它是一个字符串，所以可以在这里使用类型断言❼。如果你不能保证类型，或者不能确保该值在上下文中存在，请使用`switch`语句进行转换。
- en: 'Build and execute the code from [Listing 4-5](ch04.xhtml#ch4list5) and send
    a few requests to the server. Send some with both correct and incorrect credentials.
    You should see the following output:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 构建并执行[列表 4-5](ch04.xhtml#ch4list5)中的代码，向服务器发送几个请求。发送一些包含正确和错误凭证的请求。你应该能看到以下输出：
- en: '[PRE21]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Making a request without credentials results in your middleware returning a
    401 Unauthorized error. Sending the same request with a valid set of credentials
    produces a super-secret greeting message accessible only to authenticated users.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 在没有凭证的情况下发出请求将导致你的中间件返回 401 Unauthorized 错误。使用有效凭证发送相同的请求将返回一个只有经过身份验证的用户才能访问的超级机密问候消息。
- en: That was an awful lot to digest. Up to this point, your handler functions have
    solely used `fmt.FPrintf()` to write your response to the `http.ResponseWriter`
    instance. In the next section, you’ll look at a more dynamic way of returning
    HTML by using Go’s templating package.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 这真是太多内容需要消化了。到目前为止，你的处理函数仅仅使用了`fmt.FPrintf()`来将响应写入`http.ResponseWriter`实例。在接下来的部分，你将会了解使用
    Go 的模板包以一种更动态的方式返回 HTML。
- en: Using Templates to Produce HTML Responses
  id: totrans-94
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 使用模板生成 HTML 响应
- en: '*Templates* allow you to dynamically generate content, including HTML, with
    variables from Go programs. Many languages have third-party packages that allow
    you to generate templates. Go has two templating packages, `text/template` and
    `html/template`. In this chapter, you’ll use the HTML package, because it provides
    the contextual encoding you need.'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: '*模板*允许你动态生成内容，包括 HTML，并且可以通过 Go 程序中的变量进行控制。许多语言都有第三方包支持生成模板。Go 有两个模板包，`text/template`
    和 `html/template`。在本章中，你将使用 HTML 包，因为它提供了你所需的上下文编码。'
- en: 'One of the fantastic things about Go’s package is that it’s contextually aware:
    it will encode your variable differently depending on where the variable is placed
    in the template. For example, if you were to supply a string as a URL to an `href`
    attribute, the string would be URL encoded, but the same string would be HTML
    encoded if it rendered within an HTML element.'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: Go 包的一个精彩之处在于它具有上下文感知能力：它会根据变量在模板中的位置以不同的方式编码你的变量。例如，如果你将一个字符串作为 URL 提供给 `href`
    属性，这个字符串将被 URL 编码；但如果它在 HTML 元素内渲染，则同样的字符串将会被 HTML 编码。
- en: To create and use templates, you first define your template, which contains
    a placeholder to denote the dynamic contextual data to render. Its syntax should
    look familiar to readers who have used Jinja with Python. When you render the
    template, you pass to it a variable that’ll be used as this context. The variable
    can be a complex structure with several fields, or it can be a primitive variable.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建和使用模板，你首先需要定义模板，其中包含一个占位符，用以表示要渲染的动态上下文数据。其语法应该对那些使用过 Python 中 Jinja 的读者来说很熟悉。当你渲染模板时，你会将一个变量传递给它，作为此上下文使用。这个变量可以是一个包含多个字段的复杂结构，也可以是一个简单的原始变量。
- en: Let’s work through a sample, shown in [Listing 4-6](ch04.xhtml#ch4list6), that
    creates a simple template and populates a placeholder with JavaScript. This is
    a contrived example that shows how to dynamically populate content returned to
    the browser.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过一个示例来说明，如 [清单 4-6](ch04.xhtml#ch4list6) 所示，创建一个简单的模板并用 JavaScript 填充占位符。这是一个人为设计的示例，展示了如何动态地填充返回给浏览器的内容。
- en: '[PRE22]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: '*Listing 4-6: HTML templating (*[/ch-4/template_example/main.go](https://github.com/blackhat-go/bhg/blob/master/ch-4/template_example/main.go)*)*'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 4-6：HTML 模板 (*[/ch-4/template_example/main.go](https://github.com/blackhat-go/bhg/blob/master/ch-4/template_example/main.go)*)*'
- en: The first thing you do is create a variable, named `x`, to store your HTML template
    ❶. Here you’re using a string embedded in your code to define your template, but
    most of the time you’ll want to store your templates as separate files. Notice
    that the template is nothing more than a simple HTML page. Inside the template,
    you define placeholders by using the `{{`variable-name`}}` convention, where variable-name
    is the data element within your contextual data that you’ll want to render ❷.
    Recall that this can be a struct or another primitive. In this case, you’re using
    a single period, which tells the package that you want to render the entire context
    here. Since you’ll be working with a single string, this is fine, but if you had
    a larger and more complex data structure, such as a struct, you could get only
    the fields you want by calling past this period. For example, if you passed a
    struct with a `Username` field to the template, you could render the field by
    using `{{.Username}}`.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，你创建一个名为`x`的变量，用来存储你的HTML模板 ❶。在这里，你将代码中的字符串嵌入作为模板，但大多数时候你会希望将模板存储为单独的文件。注意，模板不过是一个简单的HTML页面。在模板内部，你通过使用`{{`变量名`}}`约定来定义占位符，其中变量名是你希望渲染的上下文数据中的数据元素
    ❷。回想一下，这可以是一个结构体或其他原始数据类型。在这个例子中，你使用的是单个句点，这表示包会渲染整个上下文。由于你将处理单一字符串，这没有问题，但如果你有一个更大且更复杂的数据结构，例如结构体，你可以通过访问句点后面的字段来获取你需要的字段。例如，如果你将一个包含`Username`字段的结构体传递给模板，你可以使用`{{.Username}}`来渲染该字段。
- en: Next, in your `main()` function, you create a new template by calling `template.New(`string`)`
    ❸. Then you call `Parse(`string`)` to ensure that the template is properly formatted
    and to parse it. Together, these two functions return a new pointer to a `Template`.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，在你的`main()`函数中，你通过调用`template.New(`string`)` ❸来创建一个新的模板。然后，你调用`Parse(`string`)`以确保模板格式正确并进行解析。这两个函数一起返回一个指向`Template`的新指针。
- en: While this example uses only a single template, it’s possible to embed templates
    in other templates. When using multiple templates, it’s important that you name
    them in order to be able to call them. Finally, you call `Execute(`io.Writer`,`
    interface`{})` ❹, which processes the template by using the variable passed as
    the second argument and writes it to the provided `io.Writer`. For demonstration
    purposes, you’ll use `os.Stdout`. The second variable you pass into the `Execute()`
    method is the context that’ll be used for rendering the template.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这个示例只使用了一个模板，但你可以在其他模板中嵌入模板。当使用多个模板时，重要的是要为它们命名，以便能够调用它们。最后，你调用`Execute(`io.Writer`,`
    interface`{})` ❹，该方法通过使用作为第二个参数传入的变量来处理模板，并将结果写入提供的`io.Writer`。为了演示，你将使用`os.Stdout`。传入`Execute()`方法的第二个变量是用于渲染模板的上下文。
- en: Running this produces HTML, and you should notice that the script tags and other
    nefarious characters that were provided as part of your context are properly encoded.
    Neat-o!
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 运行此代码会生成HTML，你应该注意到作为上下文一部分提供的脚本标签和其他恶意字符已被正确编码。真酷！
- en: '[PRE23]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: We could say a lot more about templates. You can use logical operators with
    them; you can use them with loops and other control structures. You can call built-in
    functions, and you can even define and expose arbitrary helper functions to greatly
    expand the templating capabilities. Double neat-o! We recommend you dive in and
    research these possibilities. They’re beyond the scope of this book, but are powerful.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 我们本可以说更多关于模板的内容。你可以与它们一起使用逻辑运算符；你可以将它们与循环和其他控制结构一起使用。你可以调用内置函数，甚至可以定义和公开任意的辅助函数，以大大扩展模板的能力。双倍的酷！我们建议你深入研究并探索这些可能性。它们超出了本书的范围，但非常强大。
- en: How about you step away from the basics of creating servers and handling requests
    and instead focus on something more nefarious. Let’s create a credential harvester!
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 怎么样，暂时离开创建服务器和处理请求的基础知识，转而关注一些更为险恶的东西吧。让我们来创建一个凭证收集器！
- en: Credential Harvesting
  id: totrans-108
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 凭证收集
- en: One of the staples of social engineering is the *credential-harvesting attack*.
    This type of attack captures users’ login information to specific websites by
    getting them to enter their credentials in a cloned version of the original site.
    The attack is useful against organizations that expose a single-factor authentication
    interface to the internet. Once you have a user’s credentials, you can use them
    to access their account on the actual site. This often leads to an initial breach
    of the organization’s perimeter network.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 社会工程学的一个常见攻击手段是 *凭证收集攻击*。这种攻击通过让用户在克隆的原始网站版本中输入凭证，来捕获用户登录某些网站的信息。该攻击对暴露单一身份验证接口的组织尤其有效。一旦你获得了用户的凭证，就可以用它们访问该用户在原始网站上的账户。这通常会导致组织外围网络的首次入侵。
- en: Go provides a great platform for this type of attack, because it’s quick to
    stand up new servers, and because it makes it easy to configure routing and to
    parse user-supplied input. You could add many customizations and features to a
    credential-harvesting server, but for this example, let’s stick to the basics.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: Go 为这种类型的攻击提供了一个出色的平台，因为它可以快速启动新的服务器，并且使配置路由和解析用户提供的输入变得容易。你可以为凭证收集服务器添加许多自定义和功能，但在这个示例中，我们还是先从基础部分开始。
- en: To begin, you need to clone a site that has a login form. There are a lot of
    possibilities here. In practice, you’d probably want to clone a site in use by
    the target. For this example, though, you’ll clone a Roundcube site. *Roundcube*
    is an open source webmail client that’s not used as often as commercial software,
    such as Microsoft Exchange, but will allow us to illustrate the concepts just
    as well. You’ll use Docker to run Roundcube, because it makes the process easier.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，你需要克隆一个有登录表单的站点。这里有很多选择。实际上，你可能会想克隆一个目标正在使用的站点。不过在这个例子中，你将克隆一个 Roundcube
    站点。*Roundcube* 是一个开源的网页邮箱客户端，虽然不像微软 Exchange 等商业软件那样常用，但仍能很好地帮助我们说明这些概念。你将使用 Docker
    来运行 Roundcube，因为它使得这个过程变得更加简便。
- en: 'You can start a Roundcube server of your own by executing the following. If
    you don’t want to run a Roundcube server, then no worries; the exercise source
    code has a clone of the site. Still, we’re including this for completeness:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过执行以下命令启动一个属于自己的 Roundcube 服务器。如果你不想运行 Roundcube 服务器，也不用担心；练习源代码中已经有该站点的克隆版本。不过，为了完整性，我们还是包括了这个部分：
- en: '[PRE24]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: The command starts a Roundcube Docker instance. If you navigate to *http://127.0.0.1:80*,
    you’ll be presented with a login form. Normally, you’d use `wget` to clone a site
    and all its requisite files, but Roundcube has JavaScript awesomeness that prevents
    this from working. Instead, you’ll use Google Chrome to save it. In the exercise
    folder, you should see a directory structure that looks like [Listing 4-7](ch04.xhtml#ch4list7).
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 该命令启动了一个 Roundcube Docker 实例。如果你访问 *http://127.0.0.1:80*，你将看到一个登录表单。通常，你会使用
    `wget` 克隆一个站点及其所有必要的文件，但 Roundcube 具有 JavaScript 强大功能，阻止了这种方法的使用。相反，你将使用 Google
    Chrome 来保存该站点。在练习文件夹中，你应该能看到一个类似于 [列表 4-7](ch04.xhtml#ch4list7) 的目录结构。
- en: '[PRE25]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: '*Listing 4-7: Directory listing for* [/ch-4/credential_harvester/](https://github.com/blackhat-go/bhg/blob/master/ch-4/credential_harvester/)'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 4-7：* [/ch-4/credential_harvester/](https://github.com/blackhat-go/bhg/blob/master/ch-4/credential_harvester/)
    的目录列表'
- en: 'The files in the *public* directory represent the unaltered cloned login site.
    You’ll need to modify the original login form to redirect the entered credentials,
    sending them to yourself instead of the legitimate server. To begin, open *public/index.html*
    and find the form element used to POST the login request. It should look something
    like the following:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: '*public* 目录中的文件代表着未更改的克隆登录站点。你需要修改原始登录表单，以便将输入的凭证重定向并发送到你自己，而不是合法的服务器。首先，打开
    *public/index.html* 并找到用于提交登录请求的表单元素。它应该类似于以下内容：'
- en: '[PRE26]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'You need to modify the `action` attribute of this tag and point it to your
    server. Change `action` to `/login`. Don’t forget to save it. The line should
    now look like the following:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 你需要修改这个标签的 `action` 属性，并将其指向你的服务器。将 `action` 改为 `/login`。别忘了保存。该行现在应该如下所示：
- en: '[PRE27]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: To render the login form correctly and capture a username and password, you’ll
    first need to serve the files in the *public* directory. Then you’ll need to write
    a `HandleFunc` for `/login` to capture the username and password. You’ll also
    want to store the captured credentials in a file with some verbose logging.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 为了正确呈现登录表单并捕获用户名和密码，你首先需要提供 *public* 目录中的文件。然后你需要为 `/login` 编写一个 `HandleFunc`
    来捕获用户名和密码。你还希望将捕获到的凭证存储在文件中，并进行详细日志记录。
- en: You can handle all of this in just a few dozen lines of code. [Listing 4-8](ch04.xhtml#ch4list8)
    shows the program in its entirety.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 你只需要几十行代码就可以处理这一切。[Listing 4-8](ch04.xhtml#ch4list8)展示了完整的程序。
- en: '[PRE28]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: '*Listing 4-8: Credential-harvesting server (*[/ch-4/credential_harvester/main.go](https://github.com/blackhat-go/bhg/blob/master/ch-4/credential_harvester/main.go)*)*'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: '*Listing 4-8: 凭证收集服务器 (*[/ch-4/credential_harvester/main.go](https://github.com/blackhat-go/bhg/blob/master/ch-4/credential_harvester/main.go)*)*'
- en: The first thing worth noting is you import `github.com/Sirupsen/logrus` ❶. This
    is a structured logging package that we prefer to use instead of the standard
    Go `log` package. It provides more configurable logging options for better error
    handling. To use this package, you’ll need to make sure you ran `go get` beforehand.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 首先需要注意的是，你导入了`github.com/Sirupsen/logrus` ❶。这是一个结构化日志包，我们推荐使用它，而不是标准的Go `log`包。它提供了更多可配置的日志选项，便于更好的错误处理。要使用此包，你需要确保在之前运行了`go
    get`。
- en: Next, you define the `login()` handler function. Hopefully, this pattern looks
    familiar. Inside this function, you use `log.WithFields()` to write out your captured
    data ❷. You display the current time, the user-agent, and IP address of the requester.
    You also call `FormValue(`string`)` to capture both the username (`_user`) ❸ and
    password (`_pass`) ❹ values that were submitted. You get these values from *index.html*
    and by locating the form input elements for each username and password. Your server
    needs to explicitly align with the names of the fields as they exist in the login
    form.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，你定义了`login()`处理函数。希望这个模式看起来很熟悉。在这个函数内，你使用`log.WithFields()`来记录你捕获的数据❷。你会显示当前时间、用户代理和请求者的IP地址。你还会调用`FormValue(`string`)`来捕获提交的用户名(`_user`)❸和密码(`_pass`)❹值。你从*index.html*中获取这些值，并通过查找每个用户名和密码的表单输入元素来定位它们。你的服务器需要明确与登录表单中的字段名称对齐。
- en: 'The following snippet, extracted from *index.html*, shows the relevant input
    items, with the element names in bold for clarity:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码片段提取自*index.html*，展示了相关的输入项，元素名称加粗以便于理解：
- en: '[PRE29]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: In your `main()` function, you begin by opening a file that’ll be used to store
    your captured data ❺. Then, you use `log.SetOutput(`io.Writer`)`, passing it the
    file handle you just created, to configure the logging package so that it’ll write
    its output to that file ❻. Next, you create a new router and mount the `login()`
    handler function ❼.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 在你的`main()`函数中，你首先打开一个文件，用来存储你捕获的数据❺。然后，你使用`log.SetOutput(`io.Writer`)`，并传入你刚创建的文件句柄，来配置日志包，使其将输出写入该文件❻。接着，你创建一个新的路由器，并挂载`login()`处理函数❼。
- en: 'Prior to starting the server, you do one more thing that may look unfamiliar:
    you tell your router to serve static files from a directory ❽. That way, your
    Go server explicitly knows where your static files—images, JavaScript, HTML—live.
    Go makes this easy, and provides protections against directory traversal attacks.
    Starting from the inside out, you use `http.Dir(`string`)` to define the directory
    from which you wish to serve the files. The result of this is passed as input
    to `http.FileServer(`FileSystem`)`, which creates an `http.Handler` for your directory.
    You’ll mount this to your router by using `PathPrefix(`string`)`. Using `/` as
    a path prefix will match any request that hasn’t already found a match. Note that,
    by default, the handler returned from `FileServer` does support directory indexing.
    This could leak some information. It’s possible to disable this, but we won’t
    cover that here.'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 在启动服务器之前，你需要做一件可能看起来不熟悉的事情：你告诉路由器从目录❽中提供静态文件。这样，你的Go服务器就能明确知道静态文件——如图片、JavaScript、HTML——存放的位置。Go让这一切变得简单，并且提供了防止目录遍历攻击的保护措施。从内到外，你使用`http.Dir(`string`)`来定义你希望提供文件的目录。这个结果将作为输入传递给`http.FileServer(`FileSystem`)`，后者会为你的目录创建一个`http.Handler`。你将通过使用`PathPrefix(`string`)`将其挂载到路由器上。使用`/`作为路径前缀将匹配任何未找到匹配项的请求。注意，默认情况下，`FileServer`返回的处理器支持目录索引。这可能会泄漏一些信息。可以禁用此功能，但我们这里不做讨论。
- en: 'Finally, as you have before, you start the server. Once you’ve built and executed
    the code in [Listing 4-8](ch04.xhtml#ch4list8), open your web browser and navigate
    to *http://localhost:8080*. Try submitting a username and password to the form.
    Then head back to the terminal, exit the program, and view the *credentials.txt*
    file, shown here:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，像之前一样，你启动了服务器。构建并执行了[Listing 4-8](ch04.xhtml#ch4list8)中的代码后，打开你的网页浏览器并导航到*http://localhost:8080*。尝试提交一个用户名和密码到表单。然后返回终端，退出程序，查看显示在此处的*credentials.txt*文件：
- en: '[PRE30]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Look at those logs! You can see that you submitted the username of `bob` and
    the password of `p@ssw0rd1!`. Your malicious server successfully handled the form
    POST request, captured the entered credentials, and saved them to a file for offline
    viewing. As an attacker, you could then attempt to use these credentials against
    the target organization and proceed with further compromise.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 看这些日志！你可以看到你提交了用户名 `bob` 和密码 `p@ssw0rd1!`。你的恶意服务器成功处理了表单的 POST 请求，捕获了输入的凭证，并将其保存到文件中以供离线查看。作为攻击者，你可以尝试使用这些凭证对目标组织进行攻击，进一步展开破坏行为。
- en: In the next section, you’ll work through a variation of this credential-harvesting
    technique. Instead of waiting for form submission, you’ll create a keylogger to
    capture keystrokes in real time.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，你将通过一种变体的凭证收集技巧进行实践。你将不再等待表单提交，而是创建一个键盘记录器来实时捕获按键。
- en: Keylogging with the WebSocket API
  id: totrans-135
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用 WebSocket API 进行键盘记录
- en: The *WebSocket API (WebSockets)*, a full duplex protocol, has increased in popularity
    over the years and many browsers now support it. It provides a way for web application
    servers and clients to efficiently communicate with each other. Most importantly,
    it allows the server to send messages to a client without the need for polling.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: '*WebSocket API (WebSockets)* 是一种全双工协议，近年来越来越受欢迎，许多浏览器现在都支持它。它提供了一种高效的方式，允许
    web 应用程序服务器与客户端之间进行通信。最重要的是，它允许服务器在不需要轮询的情况下向客户端发送消息。'
- en: WebSockets are useful for building “real-time” applications, such as chat and
    games, but you can use them for nefarious purposes as well, such as injecting
    a keylogger into an application to capture every key a user presses. To begin,
    imagine you’ve identified an application that is vulnerable to *cross-site scripting*
    (a flaw through which a third party can run arbitrary JavaScript in a victim’s
    browser) or you’ve compromised a web server, allowing you to modify the application
    source code. Either scenario should let you include a remote JavaScript file.
    You’ll build the server infrastructure to handle a WebSocket connection from a
    client and handle incoming keystrokes.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: WebSocket 非常适合构建“实时”应用程序，如聊天和游戏，但你也可以将其用于恶意目的，例如将键盘记录器注入应用程序，捕获用户按下的每一个键。首先，假设你已识别出一个存在*跨站脚本*（即第三方可以在受害者浏览器中运行任意
    JavaScript 的漏洞）漏洞的应用程序，或者你已经攻破了一个 web 服务器，可以修改应用程序的源代码。这两种情况都应该允许你包含一个远程 JavaScript
    文件。接下来，你将构建服务器基础设施来处理来自客户端的 WebSocket 连接，并处理传入的按键信息。
- en: 'For demonstration purposes, you’ll use JS Bin (*[http://jsbin.com](http://jsbin.com)*)
    to test your payload. JS Bin is an online playground where developers can test
    their HTML and JavaScript code. Navigate to JS Bin in your web browser and paste
    the following HTML into the column on the left, completely replacing the default
    code:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 为了演示，你将使用 JS Bin (*[http://jsbin.com](http://jsbin.com)*) 来测试你的有效载荷。JS Bin 是一个在线工具，开发者可以在其中测试他们的
    HTML 和 JavaScript 代码。用浏览器打开 JS Bin，粘贴以下 HTML 到左侧的代码框中，完全替换默认代码：
- en: '[PRE31]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: On the right side of the screen, you’ll see the rendered form. As you may have
    noticed, you’ve included a `script` tag with the `src` attribute set to `http://localhost:8080/k.js`.
    This is going to be the JavaScript code that will create the WebSocket connection
    and send user input to the server.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 在屏幕右侧，你将看到渲染后的表单。如你所见，你已添加了一个 `script` 标签，并将 `src` 属性设置为 `http://localhost:8080/k.js`。这将是创建
    WebSocket 连接并将用户输入发送到服务器的 JavaScript 代码。
- en: 'Your server is going to need to do two things: handle the WebSocket and serve
    the JavaScript file. First, let’s get the JavaScript out of the way, since after
    all, this book is about Go, not JavaScript. (Check out *[https://github.com/gopherjs/gopherjs/](https://github.com/gopherjs/gopherjs/)*
    for instructions on writing JavaScript with Go.) The JavaScript code is shown
    here:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 你的服务器需要做两件事：处理 WebSocket 连接并提供 JavaScript 文件。首先，让我们把 JavaScript 的部分处理掉，因为毕竟本书是关于
    Go 的，而不是 JavaScript。（可以查看 *[https://github.com/gopherjs/gopherjs/](https://github.com/gopherjs/gopherjs/)*，了解如何使用
    Go 编写 JavaScript。）下面是 JavaScript 代码：
- en: '[PRE32]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: The JavaScript code handles keypress events. Each time a key is pressed, the
    code sends the keystrokes over a WebSocket to a resource at `ws://{{.}}/ws`. Recall
    that the `{{.}}` value is a Go template placeholder representing the current context.
    This resource represents a WebSocket URL that will populate the server location
    information based on a string you’ll pass to the template. We’ll get to that in
    a minute. For this example, you’ll save the JavaScript in a file named *logger.js*.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript代码处理按键事件。每次按下一个键时，代码会通过WebSocket将按键发送到`ws://{{.}}/ws`上的资源。请回忆一下，`{{.}}`值是Go模板占位符，表示当前的上下文。这个资源代表一个WebSocket
    URL，它会根据你传递给模板的字符串来填充服务器位置的信息。稍后我们会讲到。对于这个例子，你将把JavaScript保存到名为*logger.js*的文件中。
- en: But wait, you say, we said we were serving it as *k.js*! The HTML we showed
    previously also explicitly uses *k.js*. What gives? Well, *logger.js* is a Go
    template, not an actual JavaScript file. You’ll use *k.js* as your pattern to
    match against in your router. When it matches, your server will render the template
    stored in the *logger.js* file, complete with contextual data that represents
    the host to which your WebSocket connects. You can see how this works by looking
    at the server code, shown in [Listing 4-9](ch04.xhtml#ch4list9).
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 等等，你可能会说，我们之前说过我们是以*k.js*来提供服务的！我们之前展示的HTML也明确使用了*k.js*。怎么回事呢？其实，*logger.js*是一个Go模板，而不是一个实际的JavaScript文件。你将在路由器中使用*k.js*作为匹配模式。当匹配时，服务器将渲染存储在*logger.js*文件中的模板，并且会包含表示WebSocket连接的主机的上下文数据。你可以通过查看服务器代码来了解它是如何工作的，代码展示在[清单4-9](ch04.xhtml#ch4list9)中。
- en: '[PRE33]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: '*Listing 4-9: Keylogging server (*[/ch-4/websocket_keylogger/main.go](https://github.com/blackhat-go/bhg/blob/master/ch-4/websocket_keylogger/main.go)*)*'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单4-9：按键记录服务器 (*[/ch-4/websocket_keylogger/main.go](https://github.com/blackhat-go/bhg/blob/master/ch-4/websocket_keylogger/main.go)*)*'
- en: We have a lot to cover here. First, note that you’re using another third-party
    package, `gorilla/websocket`, to handle your WebSocket communications ❶. This
    is a full-featured, powerful package that simplifies your development process,
    like the `gorilla/mux` router you used earlier in this chapter. Don’t forget to
    run go get github.com/gorilla/websocket from your terminal first.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有很多内容需要讨论。首先，请注意你使用了另一个第三方包`gorilla/websocket`来处理你的WebSocket通信❶。这是一个功能齐全、强大的包，它简化了你的开发过程，就像你在本章早些时候使用的`gorilla/mux`路由器一样。别忘了先在终端中运行`go
    get github.com/gorilla/websocket`。
- en: You then define several variables. You create a `websocket.Upgrader` instance
    that’ll essentially whitelist every origin ❷. It’s typically bad security practice
    to allow all origins, but in this case, we’ll roll with it since this is a test
    instance we’ll run on our local workstations. For use in an actual malicious deployment,
    you’d likely want to limit the origin to an explicit value.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 然后你定义了几个变量。你创建了一个`websocket.Upgrader`实例，它将基本上将所有来源列入白名单❷。通常，允许所有来源的做法是不安全的，但在这种情况下，由于这是我们在本地工作站上运行的测试实例，我们可以这样做。如果是在实际的恶意部署中，你可能会想将来源限制为特定值。
- en: Within your `init()` function, which executes automatically before `main()`,
    you define your command line arguments and attempt to parse your Go template stored
    in the *logger.js* file. Notice that you’re calling `template.ParseFiles("logger.js")`
    ❸. You check the response to make sure the file parsed correctly. If all is successful,
    you have your parsed template stored in a variable named `jsTemplate`.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 在`init()`函数中，它会在`main()`之前自动执行，你在其中定义了命令行参数，并尝试解析存储在*logger.js*文件中的Go模板。请注意，你调用了`template.ParseFiles("logger.js")`❸。你检查响应，确保文件正确解析。如果一切成功，你会将解析后的模板存储在名为`jsTemplate`的变量中。
- en: At this point, you haven’t provided any contextual data to your template or
    executed it. That’ll happen shortly. First, however, you define a function named
    `serveWS()` that you’ll use to handle your WebSocket communications. You create
    a new `websocket.Conn` instance by calling `upgrader.Upgrade(http.ResponseWriter,
    *http.Request, http.Header)` ❹. The `Upgrade()` method upgrades the HTTP connection
    to use the WebSocket protocol. That means that any request handled by this function
    will be upgraded to use WebSockets. You interact with the connection within an
    infinite `for` loop, calling `conn.ReadMessage()` to read incoming messages ❺.
    If your JavaScript works appropriately, these messages should consist of captured
    keystrokes. You write these messages and the client’s remote IP address to stdout
    ❻.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，你还没有为模板提供任何上下文数据或执行它。这将在稍后完成。然而，首先，你定义了一个名为`serveWS()`的函数，用于处理WebSocket通信。你通过调用`upgrader.Upgrade(http.ResponseWriter,
    *http.Request, http.Header)` ❹来创建一个新的`websocket.Conn`实例。`Upgrade()`方法将HTTP连接升级为WebSocket协议。这意味着由该函数处理的任何请求都会升级为使用WebSocket。你在一个无限的`for`循环内与连接进行交互，调用`conn.ReadMessage()`来读取传入的消息
    ❺。如果你的JavaScript正常工作，这些消息应该是捕获的按键记录。你将这些消息以及客户端的远程IP地址写入标准输出 ❻。
- en: You’ve tackled arguably the hardest piece of the puzzle in creating your WebSocket
    handler. Next, you create another handler function named `serveFile()`. This function
    will retrieve and return the contents of your JavaScript template, complete with
    contextual data included. To do this, you set the `Content-Type` header as `application/javascript`
    ❼. This will tell connecting browsers that the contents of the HTTP response body
    should be treated as JavaScript. In the second and last line of the handler function,
    you call `jsTemplate.Execute(w, wsAddr)` ❽. Remember how you parsed *logger.js*
    while you were bootstrapping your server in the `init()` function? You stored
    the result within the variable named `jsTemplate`. This line of code processes
    that template. You pass to it an `io.Writer` (in this case, you’re using `w`,
    an `http.ResponseWriter`) and your contextual data of type `interface{}`. The
    `interface{}` type means that you can pass any type of variable, whether they’re
    strings, structs, or something else. In this case, you’re passing a string variable
    named `wsAddr`. If you jump back up to the `init()` function, you’ll see that
    this variable contains the address of your WebSocket server and is set via a command
    line argument. In short, it populates the template with data and writes it as
    an HTTP response. Pretty slick!
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 你已经完成了创建WebSocket处理函数中可能最困难的部分。接下来，你创建了另一个名为`serveFile()`的处理函数。此函数将检索并返回你的JavaScript模板的内容，同时包括上下文数据。为此，你将`Content-Type`头设置为`application/javascript`
    ❼。这将告诉连接的浏览器，HTTP响应体的内容应当被当作JavaScript来处理。在处理函数的第二行也是最后一行中，你调用`jsTemplate.Execute(w,
    wsAddr)` ❽。还记得你在`init()`函数中引导服务器时是如何解析*logger.js*的吗？你将结果存储在名为`jsTemplate`的变量中。这行代码处理该模板。你将一个`io.Writer`传递给它（在这个例子中，你使用的是`w`，一个`http.ResponseWriter`），以及你的上下文数据类型`interface{}`。`interface{}`类型意味着你可以传递任何类型的变量，无论是字符串、结构体还是其他类型。在这个例子中，你传递了一个名为`wsAddr`的字符串变量。如果你回到`init()`函数，你会看到这个变量包含了你的WebSocket服务器的地址，并通过命令行参数设置。简而言之，它用数据填充模板，并将其作为HTTP响应写出。相当巧妙！
- en: You’ve implemented your handler functions, `serveFile()` and `serveWS()`. Now,
    you just need to configure your router to perform pattern matching so that you
    can pass execution to the appropriate handler. You do this, much as you have previously,
    in your `main()` function. The first of your two handler functions matches the
    `/ws` URL pattern, executing your `serveWS()` function to upgrade and handle WebSocket
    connections ❾. The second route matches the pattern `/k.js`, executing the `serveFile()`
    function as a result ❿. This is how your server pushes a rendered JavaScript template
    to the client.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 你已经实现了处理函数`serveFile()`和`serveWS()`。现在，你只需要配置路由器以执行模式匹配，这样就可以将执行传递给适当的处理函数。你像以前一样，在`main()`函数中执行这一步。你的两个处理函数中的第一个匹配`/ws`
    URL模式，执行`serveWS()`函数以升级并处理WebSocket连接 ❾。第二个路由匹配`/k.js`模式，执行`serveFile()`函数 ❿。这就是你的服务器如何将渲染后的JavaScript模板推送到客户端的方式。
- en: 'Let’s fire up the server. If you open the HTML file, you should see a message
    that reads `connection established`. This is logged because your JavaScript file
    has been rendered in the browser and requested a WebSocket connection. If you
    enter credentials into the form elements, you should see them printed to stdout
    on the server:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 启动服务器。如果你打开 HTML 文件，你应该看到一条消息显示`connection established`。这是因为你的 JavaScript 文件已经在浏览器中渲染并请求了
    WebSocket 连接。如果你在表单元素中输入凭据，你应该会看到它们被打印到服务器的 stdout 上：
- en: '[PRE34]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: You did it! It works! Your output lists each individual keystroke that was pressed
    when filling out the login form. In this case, it’s a set of user credentials.
    If you’re having issues, make sure you’re supplying accurate addresses as command
    line arguments. Also, the HTML file itself may need tweaking if you’re attempting
    to call *k.js* from a server other than `localhost:8080`.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 你做到了！它工作了！你的输出列出了填写登录表单时按下的每一个单独的按键。在这种情况下，它是一组用户凭据。如果你遇到问题，请确保你提供了准确的地址作为命令行参数。此外，如果你尝试从
    `localhost:8080` 以外的服务器调用 *k.js*，可能需要调整 HTML 文件本身。
- en: You could improve this code in several ways. For one, you might want to log
    the output to a file or other persistent storage, rather than to your terminal.
    This would make you less likely to lose your data if the terminal window closes
    or the server reboots. Also, if your keylogger logs the keystrokes of multiple
    clients simultaneously, the output will mix the data, making it potentially difficult
    to piece together a specific user’s credentials. You could avoid this by finding
    a better presentation format that, for example, groups keystrokes by unique client/port
    source.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过几种方式改进这段代码。例如，你可能希望将输出日志记录到文件或其他持久存储中，而不是记录到终端中。这样，如果终端窗口关闭或服务器重启，你就不太可能丢失数据。另外，如果你的键盘记录器同时记录多个客户端的按键，输出会混合数据，这可能使得分辨特定用户的凭据信息变得困难。你可以通过找到更好的展示格式来避免这种情况，例如，将按键按唯一客户端/端口来源分组。
- en: Your journey through credential harvesting is complete. We’ll end this chapter
    by presenting multiplexing HTTP command-and-control connections.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 你的凭据收集之旅已经结束。我们将通过介绍 HTTP 命令与控制连接的多路复用来结束这一章。
- en: Multiplexing Command-and-Control
  id: totrans-158
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 命令与控制的多路复用
- en: You’ve arrived at the last section of the chapter on HTTP servers. Here, you’ll
    look at how to multiplex Meterpreter HTTP connections to different backend control
    servers. *Meterpreter* is a popular, flexible command-and-control (C2) suite within
    the Metasploit exploitation framework. We won’t go into too many details about
    Metasploit or Meterpreter. If you’re new to it, we recommend reading through one
    of the many tutorial or documentation sites.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 你已经到达了本章关于 HTTP 服务器的最后一节。在这里，你将了解如何将 Meterpreter HTTP 连接多路复用到不同的后台控制服务器。*Meterpreter*
    是一个流行的、灵活的命令与控制（C2）套件，属于 Metasploit 漏洞利用框架的一部分。我们不会深入讨论 Metasploit 或 Meterpreter。如果你是新手，我们建议你阅读一些教程或文档网站。
- en: In this section, we’ll walk through creating a reverse HTTP proxy in Go so that
    you can dynamically route your incoming Meterpreter sessions based on the `Host`
    HTTP header, which is how virtual website hosting works. However, instead of serving
    different local files and directories, you’ll proxy the connection to different
    Meterpreter listeners. This is an interesting use case for a few reasons.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一节中，我们将演示如何用 Go 创建一个反向 HTTP 代理，这样你就可以根据 `Host` HTTP 头动态路由你的 Meterpreter 会话，这与虚拟主机的工作方式相同。然而，不同的是，你将代理连接到不同的
    Meterpreter 监听器，而不是提供不同的本地文件和目录。这是一个有趣的用例，原因有很多。
- en: First, your proxy acts as a redirector, allowing you to expose only that domain
    name and IP address without exposing your Metasploit listeners. If the redirector
    ever gets blacklisted, you can simply move it without having to move your C2 server.
    Second, you can extend the concepts here to perform *domain fronting*, a technique
    for leveraging trusted third-party domains (often from cloud providers) to bypass
    restrictive egress controls. We won’t go into a full-fledged example here, but
    we highly recommend you dig into it, as it can be pretty powerful, allowing you
    to egress restricted networks. Lastly, the use case demonstrates how you can share
    a single host/port combination among a team of allies potentially attacking different
    target organizations. Since ports 80 and 443 are the most likely allowed egress
    ports, you can use your proxy to listen on those ports and intelligently route
    the connections to the correct listener.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，你的代理充当重定向器，允许你仅公开该域名和 IP 地址，而不暴露你的 Metasploit 监听器。如果重定向器被列入黑名单，你可以简单地将它移走，而无需移动
    C2 服务器。其次，你可以扩展这里的概念来执行 *域名伪装*，这是一种利用受信任的第三方域名（通常来自云服务提供商）绕过限制性出站控制的技术。我们在这里不会深入展示完整的例子，但我们强烈推荐你深入了解它，因为它非常强大，可以帮助你突破受限的网络。最后，使用案例展示了你如何与一组可能针对不同目标组织的盟友共享一个主机/端口组合。由于端口
    80 和 443 是最可能被允许的出站端口，你可以使用你的代理监听这些端口，并智能地将连接路由到正确的监听器。
- en: Here’s the plan. You’ll set up two separate Meterpreter reverse HTTP listeners.
    In this example, these will reside on a virtual machine with an IP address of
    10.0.1.20, but they could very well exist on separate hosts. You’ll bind your
    listeners to ports 10080 and 20080, respectively. In a real situation, these listeners
    can be running anywhere so long as the proxy can reach those ports. Make sure
    you have Metasploit installed (it comes pre-installed on Kali Linux); then start
    your listeners.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 计划是这样的。你将设置两个独立的 Meterpreter 反向 HTTP 监听器。在这个例子中，它们将驻留在一个 IP 地址为 10.0.1.20 的虚拟机上，但它们也可以存在于不同的主机上。你将分别将监听器绑定到端口
    10080 和 20080。在实际情况中，这些监听器可以运行在任何地方，只要代理能够访问这些端口。确保你已经安装了 Metasploit（它在 Kali Linux
    中预装），然后启动你的监听器。
- en: '[PRE35]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: When you start your listener, you supply the proxy data as the `LHOST` and `LPORT`
    values ❶. However, you set the advanced options `ReverseListenerBindAddress` and
    `ReverseListenerBindPort` to the actual IP and port on which you want the listener
    to start ❷. This gives you some flexibility in port usage while allowing you to
    explicitly identify the proxy host—which may be a hostname, for example, if you
    were setting up domain fronting.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 启动监听器时，你将代理数据作为 `LHOST` 和 `LPORT` 值 ❶ 提供。然而，你将高级选项 `ReverseListenerBindAddress`
    和 `ReverseListenerBindPort` 设置为你希望监听器启动的实际 IP 和端口 ❷。这样，你可以在使用端口时具有一些灵活性，同时显式地识别代理主机——如果你设置了域名伪装，这个主机名可能就是一个域名。
- en: 'On a second instance of Metasploit, you’ll do something similar to start an
    additional listener on port 20080\. The only real difference here is that you’re
    binding to a different port:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 在第二个 Metasploit 实例中，你将做类似的操作，启动一个在端口 20080 上的额外监听器。唯一的实际区别是你将绑定到不同的端口：
- en: '[PRE36]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Now, let’s create your reverse proxy. [Listing 4-10](ch04.xhtml#ch4list10) shows
    the code in its entirety.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们创建你的反向代理。[清单 4-10](ch04.xhtml#ch4list10) 显示了完整的代码。
- en: '[PRE37]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: '*Listing 4-10: Multiplexing Meterpreter (*[/ch-4/multiplexer/main.go](https://github.com/blackhat-go/bhg/blob/master/ch-4/multiplexer/main.go)*)*'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 4-10：复用 Meterpreter (*[/ch-4/multiplexer/main.go](https://github.com/blackhat-go/bhg/blob/master/ch-4/multiplexer/main.go)*)*'
- en: First off, you’ll notice that you’re importing the `net/http/httputil` package
    ❶, which contains functionality to assist with creating a reverse proxy. It’ll
    save you from having to create one from scratch.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，你会注意到你正在导入 `net/http/httputil` 包 ❶，该包包含辅助创建反向代理的功能。它将免去你从头开始创建一个的麻烦。
- en: After you import your packages, you define a pair of variables ❷. Both variables
    are maps. You’ll use the first, `hostProxy`, to map hostnames to the URL of the
    Metasploit listener to which you’ll want that hostname to route. Remember, you’ll
    be routing based on the `Host` header that your proxy receives in the HTTP request.
    Maintaining this mapping is a simple way to determine destinations.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 在导入包之后，定义一对变量 ❷。两个变量都是映射（map）。你将使用第一个变量 `hostProxy`，它将主机名映射到你希望该主机名路由到的 Metasploit
    监听器的 URL。记住，你将基于代理接收到的 HTTP 请求中的 `Host` 头来进行路由。保持这个映射是确定目标的简单方法。
- en: The second variable you define, `proxies`, will also use hostnames as its key
    values. However, their corresponding values in the map are `*httputil.ReverseProxy`
    instances. That is, the values will be actual proxy instances to which you can
    route, rather than string representations of the destination.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 你定义的第二个变量`proxies`也将使用主机名作为键值。然而，它们在映射中的对应值是`*httputil.ReverseProxy`实例。也就是说，这些值将是实际的代理实例，你可以将流量路由到它们，而不是目标的字符串表示。
- en: Notice that you’re hardcoding this information, which isn’t the most elegant
    way to manage your configuration and proxy data. A better implementation would
    store this information in an external configuration file instead. We’ll leave
    that as an exercise for you.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，你正在硬编码这些信息，这并不是管理配置和代理数据的最优雅方式。更好的实现方法是将这些信息存储在外部配置文件中。我们把这个作为练习留给你。
- en: You use an `init()` function to define the mappings between domain names and
    destination Metasploit instances ❸. In this case, you’ll route any request with
    a `Host` header value of `attacker1.com` to `http://10.0.1.20:10080` and anything
    with a `Host` header value of `attacker2.com` to `http://10.0.1.20:20080`. Of
    course, you aren’t actually doing the routing yet; you’re just creating your rudimentary
    configuration. Notice that the destinations correspond to the `ReverseListenerBindAddress`
    and `ReverseListenerBindPort` values you used for your Meterpreter listeners earlier.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 你使用`init()`函数来定义域名和目标Metasploit实例之间的映射❸。在这种情况下，你将任何`Host`头值为`attacker1.com`的请求路由到`http://10.0.1.20:10080`，将任何`Host`头值为`attacker2.com`的请求路由到`http://10.0.1.20:20080`。当然，你现在还没有真正进行路由；你只是在创建一个初步的配置。请注意，这些目标与之前为Meterpreter监听器使用的`ReverseListenerBindAddress`和`ReverseListenerBindPort`值相对应。
- en: Next, still within your `init()` function, you loop over your `hostProxy` map,
    parsing the destination addresses to create `net.URL` instances ❹. You use the
    result of this as input into a call to `httputil.NewSingleHostReverseProxy(net.URL)`
    ❺, which is a helper function that creates a reverse proxy from a URL. Even better,
    the `httputil.ReverseProxy` type satisfies the `http.Handler` interface, which
    means you can use the created proxy instances as handlers for your router. You
    do this within your `main()` function. You create a router and then loop over
    all of your proxy instances. Recall that the key is the hostname, and the value
    is of type `httputil.ReverseProxy`. For each key/value pair in your map, you add
    a matching function onto your router ❻. The Gorilla MUX toolkit’s `Route` type
    contains a matching function named `Host` that accepts a hostname to match `Host`
    header values in incoming requests against. For each hostname you want to inspect,
    you tell the router to use the corresponding proxy. It’s a surprisingly easy solution
    to what could otherwise be a complicated problem.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，仍然在你的`init()`函数中，你遍历`hostProxy`映射，解析目标地址来创建`net.URL`实例❹。你将结果作为输入传递给`httputil.NewSingleHostReverseProxy(net.URL)`❺，这是一个从URL创建反向代理的辅助函数。更棒的是，`httputil.ReverseProxy`类型实现了`http.Handler`接口，这意味着你可以将创建的代理实例作为路由器的处理器。在你的`main()`函数中，你这样做：创建一个路由器，然后遍历所有的代理实例。记住，键是主机名，值是`httputil.ReverseProxy`类型。对于映射中的每个键值对，你将把一个匹配函数添加到路由器中❻。Gorilla
    MUX工具包中的`Route`类型包含一个名为`Host`的匹配函数，它接受一个主机名来匹配传入请求中的`Host`头值。对于你要检查的每个主机名，你会告诉路由器使用相应的代理。这是一个出乎意料的简单解决方案，能够应对本来可能是复杂的问题。
- en: Your program finishes by starting the server, binding it to port 80\. Save and
    run the program. You’ll need to do so as a privileged user since you’re binding
    to a privileged port.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 你的程序通过启动服务器并将其绑定到端口80来结束。保存并运行程序。你需要以特权用户身份运行，因为你正在绑定到特权端口。
- en: 'At this point, you have two Meterpreter reverse HTTP listeners running, and
    you should have a reverse proxy running now as well. The last step is to generate
    test payloads to check that your proxy works. Let’s use `msfvenom`, a payload
    generation tool that ships with Metasploit, to generate a pair of Windows executable
    files:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，你已经运行了两个Meterpreter反向HTTP监听器，并且现在应该也已经启动了反向代理。最后一步是生成测试有效载荷，检查你的代理是否正常工作。我们使用`msfvenom`，一个随Metasploit一起提供的有效载荷生成工具，来生成一对Windows可执行文件：
- en: '[PRE38]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'This generates two output files named *payload1.exe* and *payload2.exe*. Notice
    that the only difference between the two, besides the output filename, is the
    `HttpHostHeader` values. This ensures that the resulting payload sends its HTTP
    requests with a specific `Host` header value. Also of note is that the `LHOST`
    and `LPORT` values correspond to your reverse proxy information and not your Meterpreter
    listeners. Transfer the resulting executables to a Windows system or virtual machine.
    When you execute the files, you should see two new sessions established: one on
    the listener bound to port 10080, and one on the listener bound to port 20080\.
    They should look something like this:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 这会生成两个输出文件，分别命名为 *payload1.exe* 和 *payload2.exe*。请注意，除了输出文件名外，它们之间唯一的区别是 `HttpHostHeader`
    值。这确保了生成的有效载荷发送 HTTP 请求时，带有特定的 `Host` 头部值。另请注意，`LHOST` 和 `LPORT` 值对应的是你的反向代理信息，而不是你的
    Meterpreter 监听器。将生成的可执行文件传输到 Windows 系统或虚拟机中。当你执行这些文件时，你应该看到两个新的会话被建立：一个绑定到 10080
    端口的监听器，另一个绑定到 20080 端口的监听器。它们应该类似于下面的样子：
- en: '[PRE39]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: If you use tcpdump or Wireshark to inspect network traffic destined for port
    10080 or 20080, you should see that your reverse proxy is the only host communicating
    with the Metasploit listener. You can also confirm that the `Host` header is set
    appropriately to `attacker1.com` (for the listener on port 10080) and `attacker2.com`
    (for the listener on port 20080).
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你使用 tcpdump 或 Wireshark 来检查目标为 10080 或 20080 端口的网络流量，你应该会看到你的反向代理是唯一与 Metasploit
    监听器通信的主机。你还可以确认 `Host` 头部被正确地设置为 `attacker1.com`（对于 10080 端口的监听器）和 `attacker2.com`（对于
    20080 端口的监听器）。
- en: That’s it. You’ve done it! Now, take it up a notch. As an exercise for you,
    we recommend you update the code to use a staged payload. This likely comes with
    additional challenges, as you’ll need to ensure that both stages are properly
    routed through the proxy. Further, try to implement it by using HTTPS instead
    of cleartext HTTP. This will further your understanding and effectiveness at proxying
    traffic in useful, nefarious ways.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 就这样，你完成了！现在，可以更进一步了。作为一个练习，我们建议你更新代码，使用分阶段的有效载荷。这可能带来额外的挑战，因为你需要确保两个阶段都能通过代理正确地路由。此外，尝试使用
    HTTPS 而不是明文 HTTP 来实现。这将进一步加深你对代理流量的理解，并提高你在实际、恶意的场景中利用代理的能力。
- en: Summary
  id: totrans-183
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 总结
- en: You’ve completed your journey of HTTP, working through both client and server
    implementations over the last two chapters. In the next chapter, you’ll focus
    on DNS, an equally useful protocol for security practitioners. In fact, you’ll
    come close to replicating this HTTP multiplexing example using DNS.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 你已经完成了 HTTP 的学习旅程，在过去的两章中，你已经处理了客户端和服务器的实现。在下一章中，你将重点学习 DNS，这是一个同样对安全从业者非常有用的协议。事实上，你将接近通过
    DNS 来复制这个 HTTP 多路复用的例子。
