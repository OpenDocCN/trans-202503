- en: '**6'
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '**6'
- en: UML CLASS DIAGRAMS**
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: UML 类图**
- en: '![Image](Images/com.jpg)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Images/com.jpg)'
- en: This chapter describes *class diagrams*, one of the more important diagramming
    tools in UML. Class diagrams are the basis for defining data types, data structures,
    and operations on that data in programs. In turn, they’re the basis for *object-oriented
    analysis (OOA)* and *object-oriented design (OOD)*.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章介绍了*类图*，这是 UML 中一个非常重要的图示工具。类图是定义程序中数据类型、数据结构和对数据进行操作的基础。反过来，它们也是*面向对象分析 (OOA)*
    和*面向对象设计 (OOD)*的基础。
- en: '**6.1 Object-Oriented Analysis and Design in UML**'
  id: totrans-4
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**6.1 UML中的面向对象分析与设计**'
- en: The creators of UML wanted a formal system for designing object-oriented software
    to replace the structured programming formalisms available at the time (1990s).
    Here we’ll discuss how to represent classes (data types) and objects (instance
    variables of data types) in UML.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: UML 的创建者希望有一个正式的系统来设计面向对象的软件，以取代当时（1990年代）可用的结构化编程形式。在这里，我们将讨论如何在 UML 中表示类（数据类型）和对象（数据类型的实例变量）。
- en: The most complete form of a class diagram in UML is shown in [Figure 6-1](ch06.xhtml#ch6fig1).
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: UML 中最完整的类图形式见[图 6-1](ch06.xhtml#ch6fig1)。
- en: '![image](Images/fig6-1.jpg)'
  id: totrans-7
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/fig6-1.jpg)'
- en: '*Figure 6-1: A complete class diagram*'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 6-1：完整的类图*'
- en: '*Attributes* correspond to data field members of a class (that is, variables
    and constants); they represent information internal to the class.'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: '*属性* 对应于类的数据字段成员（即变量和常量）；它们代表类内部的信息。'
- en: '*Operations* correspond to the activities that represent the class’s behavior.
    Operations include methods, functions, procedures, and other things we normally
    identify as code.'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: '*操作* 对应于表示类行为的活动。操作包括方法、函数、过程以及我们通常认作代码的其他内容。'
- en: Sometimes, you don’t need to list all the attributes and operations when referencing
    a class diagram (or there might not even be any attributes or operations). In
    such situations, you can instead draw a partial class diagram, shown in [Figure
    6-2](ch06.xhtml#ch6fig2).
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，引用类图时不需要列出所有的属性和操作（或者根本没有属性和操作）。在这种情况下，你可以绘制部分类图，如[图 6-2](ch06.xhtml#ch6fig2)所示。
- en: '![image](Images/fig6-2.jpg)'
  id: totrans-12
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/fig6-2.jpg)'
- en: '*Figure 6-2: Partial class diagrams*'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 6-2：部分类图*'
- en: The fact that attributes or operations are missing from a partial class diagram
    doesn’t imply that they don’t exist; it just means that it’s not necessary in
    the current context to add them to the diagram. The designer might be leaving
    it up to the coder to fill them in during coding; or perhaps the complete class
    diagram appears elsewhere, and the current diagram contains only information of
    interest.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 部分类图中缺少属性或操作并不意味着它们不存在；这只是表示在当前上下文中没有必要将它们添加到图中。设计者可能会让编码者在编码时自行补充这些内容；或者可能完整的类图在其他地方出现，而当前图中只包含感兴趣的信息。
- en: In its simplest form, UML represents classes with a simple rectangle containing
    the name of the class, as shown in [Figure 6-3](ch06.xhtml#ch6fig3).
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在最简单的形式中，UML 使用一个简单的矩形表示类，矩形内包含类的名称，如[图 6-3](ch06.xhtml#ch6fig3)所示。
- en: '![image](Images/fig6-3.jpg)'
  id: totrans-16
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/fig6-3.jpg)'
- en: '*Figure 6-3: A simple class diagram*'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 6-3：一个简单的类图*'
- en: Again, this doesn’t imply that the class contains no attributes or operations
    (which wouldn’t make sense); it just means that those items are not of interest
    in the current diagram.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 再次强调，这并不意味着该类没有属性或操作（那样的话就没有意义）；这只是表示这些项目在当前图中不重要。
- en: '**6.2 Visibility in a Class Diagram**'
  id: totrans-19
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**6.2 类图中的可见性**'
- en: 'UML defines four types of class member *visibility* (all taken from C++ and
    Java, although other languages, such as Swift, also support them): public, private,
    protected, and package. We’ll discuss each in turn.'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: UML 定义了四种类成员的*可见性*（这些都来自 C++ 和 Java，尽管其他语言，如 Swift，也支持它们）：public（公共）、private（私有）、protected（受保护）和
    package（包）。我们将逐一讨论每种可见性。
- en: '***6.2.1 Public Class Visibility***'
  id: totrans-21
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***6.2.1 公共类可见性***'
- en: 'A public class member is visible to all classes and code, inside and outside
    the class containing the public item. In well-designed object-oriented systems,
    public items are almost always operations (methods, functions, procedures, and
    so forth) and form the class’s interface to the world outside the class. Although
    you can also make attributes public, doing so often defeats one of the primary
    benefits of object-oriented programming: *encapsulation*, or the ability to hide
    values and activities inside a class from the outside world.'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 公有类成员对所有类和代码都是可见的，既可以在包含该公有项的类内部访问，也可以在外部访问。在设计良好的面向对象系统中，公有项几乎总是操作（方法、函数、过程等），并构成类对外部世界的接口。尽管你也可以将属性设置为公有，但这样做往往会破坏面向对象编程的主要好处之一：*封装性*，即能够将类内部的值和活动隐藏起来，防止外界访问。
- en: In UML we preface public attributes and operations with the plus sign (`+`),
    as shown in [Figure 6-4](ch06.xhtml#ch6fig4). The set of public attributes and
    operations provides the class’s *public interface*.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 在UML中，我们使用加号（`+`）作为公有属性和操作的前缀，如[图6-4](ch06.xhtml#ch6fig4)所示。公有属性和操作的集合提供了类的*公有接口*。
- en: '![image](Images/fig6-4.jpg)'
  id: totrans-24
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/fig6-4.jpg)'
- en: '*Figure 6-4: Public attributes and operations*'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: '*图6-4：公有属性和操作*'
- en: 'This figure has a single public attribute, `maxSalinity_c`. The `_c` suffix
    is a convention I use to indicate that the field is a *constant* rather than a
    variable.^([1](ch19_footnote.xhtml#ch06fn1)) In good designs constants are usually
    the only public attributes in a class, because external code cannot change the
    value of a constant: it’s still visible (that is, not hidden or encapsulated),
    but it’s unchangeable. One of the main reasons for encapsulation is to prevent
    side effects that can occur when some external code changes an internal class
    attribute. Because external code cannot change a constant’s value, this immutability
    achieves the same result as encapsulation; therefore, object-oriented designers
    are willing to make certain class constants visible.^([2](ch19_footnote.xhtml#ch06fn2))'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 该图包含一个公有属性，`maxSalinity_c`。`_c`后缀是我用来表示该字段是*常量*而非变量的约定。^([1](ch19_footnote.xhtml#ch06fn1))
    在良好的设计中，常量通常是类中唯一的公有属性，因为外部代码不能更改常量的值：它仍然可见（即没有被隐藏或封装），但不可更改。封装的主要原因之一是防止外部代码更改内部类属性时产生副作用。由于外部代码不能更改常量的值，这种不可变性实现了与封装相同的效果；因此，面向对象的设计者愿意使某些类常量可见。^([2](ch19_footnote.xhtml#ch06fn2))
- en: 6.2.2 Private Class Visibility
  id: totrans-27
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 6.2.2 私有类可见性
- en: 'At the other end of the spectrum lies private visibility. Private attributes
    and operations are accessible only within that class: they’re hidden from other
    classes and code. Private attributes and operations are the embodiment of encapsulation.'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 在另一端是私有可见性。私有属性和操作仅在该类内部可访问：它们对其他类和代码隐藏。私有属性和操作是封装性的体现。
- en: We use the minus sign (`-`) to denote private entities within a class diagram,
    as shown in [Figure 6-5](ch06.xhtml#ch6fig5).
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用减号（`-`）表示类图中的私有实体，如[图6-5](ch06.xhtml#ch6fig5)所示。
- en: '![image](Images/fig6-5.jpg)'
  id: totrans-30
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/fig6-5.jpg)'
- en: '*Figure 6-5: Private attributes and operations*'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: '*图6-5：私有属性和操作*'
- en: You should use private visibility for any attribute or operation that doesn’t
    absolutely require some other form of visibility, and strive to ensure that all
    attributes (data fields in the class) are private members of the class. If outside
    code needs to access a data field, you can use public *accessor* functions (getters
    and setters) to provide access to the private class member. A *getter* function
    returns the value of a private field. A *setter* function stores a value into
    a private field.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该对任何不绝对需要其他可见性形式的属性或操作使用私有可见性，并力求确保所有属性（类中的数据字段）都是类的私有成员。如果外部代码需要访问数据字段，你可以使用公有的*访问器*函数（获取器和设置器）来提供对私有类成员的访问。*获取器*函数返回私有字段的值。*设置器*函数将一个值存储到私有字段中。
- en: 'If you’re wondering why you should even bother using accessor functions (after
    all, it’s a whole lot easier to simply access the data field directly^([3](ch19_footnote.xhtml#ch06fn3))),
    consider this: a setter function can check the value you’re storing in an attribute
    to ensure it’s within range. Also, not all fields are independent of all other
    attributes in a class. For example, in a saltwater pool, the salinity, chlorine,
    and pH levels aren’t completely independent of one another: the pool contains
    an electrolysis cell that converts water and sodium chloride (salt) into sodium
    hydroxide and chlorine. This conversion reduces the salinity and increases the
    chlorine and pH levels. So rather than allowing some external code to arbitrarily
    change the salinity level, you might want to pass the change through a setter
    function that can decide whether to adjust other levels at the same time.'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在想，为什么还要使用访问器函数（毕竟，直接访问数据字段不是更简单吗？^([3](ch19_footnote.xhtml#ch06fn3))），请考虑以下情况：setter
    函数可以检查你存储在属性中的值，确保它在范围内。另外，并非所有字段都独立于类中的其他属性。例如，在盐水游泳池中，盐度、氯含量和 pH 值并不是完全独立的：泳池中有一个电解池，将水和氯化钠（盐）转化为氢氧化钠和氯气。这一转化过程会降低盐度，同时提高氯含量和
    pH 值。因此，与其让外部代码任意修改盐度值，你可能希望通过 setter 函数传递该修改，以便它可以决定是否同时调整其他水平。
- en: '***6.2.3 Protected Class Visibility***'
  id: totrans-34
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***6.2.3 受保护类可见性***'
- en: 'Although public and private visibility covers a large percentage of the visibility
    requirements, in some special situations, like inheritance, you’ll need to use
    something in between: protected visibility.'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管公有和私有可见性涵盖了大部分可见性需求，但在某些特殊情况下，如继承，你需要使用介于两者之间的可见性：受保护可见性。
- en: Inheritance, along with encapsulation and polymorphism, is one of the “big three”
    features of object-oriented programming. Inheritance allows one class to receive
    all the features from another class.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 继承与封装和多态一起，是面向对象编程的“三大特性”之一。继承允许一个类接收另一个类的所有特性。
- en: One problem with private visibility is that *you cannot access private fields
    within classes that inherit them*. Protected visibility, however, relaxes these
    restrictions to allow access by inheriting classes, but it doesn’t allow access
    to private fields outside the original class or its inheriting classes.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 私有可见性的问题在于*你不能在继承它们的类中访问私有字段*。然而，受保护可见性放宽了这些限制，允许继承类访问，但不允许类外部或其继承类访问私有字段。
- en: UML notation uses the hash symbol (`#`) to denote protected visibility, as shown
    in [Figure 6-6](ch06.xhtml#ch6fig6).
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: UML 注记使用井号（`#`）来表示受保护的可见性，如[图 6-6](ch06.xhtml#ch6fig6)所示。
- en: '![image](Images/fig6-6.jpg)'
  id: totrans-39
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/fig6-6.jpg)'
- en: '*Figure 6-6: Protected attributes and operations*'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 6-6：受保护的属性和操作*'
- en: '***6.2.4 Package Class Visibility***'
  id: totrans-41
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***6.2.4 包类可见性***'
- en: Package visibility sits between private and protected and is largely a Java
    concept. Other languages have something similar, including Swift, C++, and C#,
    in which you can use namespaces to simulate package visibility, although the semantics
    aren’t quite the same.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 包可见性位于私有和受保护之间，主要是 Java 的概念。其他语言也有类似的东西，包括 Swift、C++ 和 C#，你可以使用命名空间来模拟包可见性，尽管语义上并不完全相同。
- en: Package-protected fields are visible among all classes in the same package.
    Classes outside the package (even if they inherit from the class containing the
    package-protected fields) cannot access items with package visibility.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 包保护字段在同一包中的所有类之间是可见的。包外的类（即使它们继承了包含包保护字段的类）不能访问具有包可见性的项。
- en: We use the tilde (`~`) to denote package visibility, as shown in [Figure 6-7](ch06.xhtml#ch6fig7).
    [Chapter 8](ch08.xhtml) discusses UML package notation (that is, how to place
    several classes in the same package).
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用波浪号（`~`）来表示包可见性，如[图 6-7](ch06.xhtml#ch6fig7)所示。[第 8 章](ch08.xhtml)讨论了 UML
    包注记（即如何将多个类放置在同一个包中）。
- en: '![image](Images/fig6-7.jpg)'
  id: totrans-45
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/fig6-7.jpg)'
- en: '*Figure 6-7: Package attributes and operations*'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 6-7：包属性和操作*'
- en: '***6.2.5 Unsupported Visibility Types***'
  id: totrans-47
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***6.2.5 不支持的可见性类型***'
- en: What happens if your programming language of choice doesn’t support the same
    visibility types that UML specifies? Well, the good news is that UML visibility
    is largely a spectrum, as shown in [Figure 6-8](ch06.xhtml#ch6fig8).^([4](ch19_footnote.xhtml#ch06fn4))
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你选择的编程语言不支持 UML 指定的相同可见性类型，会发生什么呢？好消息是，UML 可见性在很大程度上是一个范围，如[图 6-8](ch06.xhtml#ch6fig8)所示。^([4](ch19_footnote.xhtml#ch06fn4))
- en: '![image](Images/fig6-8.jpg)'
  id: totrans-49
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/fig6-8.jpg)'
- en: '*Figure 6-8: Visibility spectrum*'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 6-8：可见性范围*'
- en: You can always substitute a more public visibility for a more private visibility
    if your programming language doesn’t support a specific visibility. For example,
    the High-Level Assembly (HLA) language supports only public fields; C++ only partially
    supports package visibility (using `friend` declarations or *namespaces*); and
    Swift supports an offshoot of package visibility—all private fields within an
    object are automatically visible to all classes declared in the same source file.
    One way to avoid abusing the extra visibility is to add some sort of visibility
    notation to the attribute or operation’s name in the class—for example, by prefacing
    protected names with `prot_` and then declaring them as public objects, as shown
    in [Figure 6-9](ch06.xhtml#ch6fig9).
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你的编程语言不支持特定的可见性，你总可以将更私有的可见性替换为更公开的可见性。例如，高级汇编（HLA）语言仅支持公共字段；C++仅部分支持包可见性（通过`friend`声明或*命名空间*）；Swift支持包可见性的一个分支——对象内的所有私有字段会自动对同一源文件中声明的所有类可见。一种避免滥用额外可见性的方法是为属性或操作的名称添加某种可见性标注——例如，通过在受保护的名称前加上`prot_`，然后将其声明为公共对象，如[图
    6-9](ch06.xhtml#ch6fig9)所示。
- en: '![image](Images/fig6-9.jpg)'
  id: totrans-52
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/fig6-9.jpg)'
- en: '*Figure 6-9: Faking visibility restriction*'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 6-9：伪造可见性限制*'
- en: '**6.3 Class Attributes**'
  id: totrans-54
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**6.3 类属性**'
- en: Attributes in a UML class (also known as *data fields* or simply *fields*) hold
    the data associated with an object. An attribute has a visibility and a name;
    it can also have a data type and an initial value, as shown in [Figure 6-10](ch06.xhtml#ch6fig10).
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: UML 类中的属性（也称为*数据字段*或简单地称为*字段*）包含与对象关联的数据。属性有可见性和名称；它还可以有数据类型和初始值，如[图 6-10](ch06.xhtml#ch6fig10)所示。
- en: '![image](Images/fig6-10.jpg)'
  id: totrans-56
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/fig6-10.jpg)'
- en: '*Figure 6-10: Attributes*'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 6-10：属性*'
- en: '***6.3.1 Attribute Visibility***'
  id: totrans-58
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***6.3.1 属性可见性***'
- en: As discussed earlier, you specify the visibility of an attribute by prefixing
    its name with the `+`, `-`, `#`, or `~` symbols, which specify public, private,
    protected, and package visibility, respectively. See “[Visibility in a Class Diagram](ch06.xhtml#lev-6.2)”
    on [page 105](ch06.xhtml#page_105) for more details.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，你通过在属性名称前加上`+`、`-`、`#`或`~`符号来指定属性的可见性，分别表示公共、私有、受保护和包可见性。有关更多细节，请参见“[类图中的可见性](ch06.xhtml#lev-6.2)”在[第
    105 页](ch06.xhtml#page_105)。
- en: '***6.3.2 Attribute Derived Values***'
  id: totrans-60
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***6.3.2 属性派生值***'
- en: Most of the time, a class stores the value of an attribute as a variable or
    constant data field (a *base* value). However, some fields contain *derived* values
    rather than base values. The class calculates a derived value whenever some expression
    references that attribute. Some languages, like Swift, provide syntax for directly
    defining declared values; in other languages (such as C++), you’ll typically write
    getter and setter accessor functions to implement a derived value.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数情况下，类将属性值存储为变量或常量数据字段（即*基础*值）。然而，一些字段包含*派生*值，而不是基础值。每当某个表达式引用该属性时，类会计算派生值。一些语言（如
    Swift）提供了直接定义声明值的语法；而在其他语言（如 C++）中，你通常需要编写 getter 和 setter 访问器函数来实现派生值。
- en: To create a derived attribute in UML, you immediately precede the attribute
    name (after the visibility symbol) with a forward slash (`/`), as shown in [Figure
    6-11](ch06.xhtml#ch6fig11).
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 在 UML 中创建派生属性时，立即在属性名称前（可见性符号之后）加上斜杠(`/`)，如[图 6-11](ch06.xhtml#ch6fig11)所示。
- en: '![image](Images/fig6-11.jpg)'
  id: totrans-63
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/fig6-11.jpg)'
- en: '*Figure 6-11: A derived attribute*'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 6-11：派生属性*'
- en: Whenever you use a derived attribute, somewhere you must define how to calculate
    it. [Figure 6-11](ch06.xhtml#ch6fig11) uses a comment for this purpose, although
    you could also use a *property string* (see “[Property Strings](ch06.xhtml#lev-6.3.8)”
    on [page 112](ch06.xhtml#page_112)).
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 每当你使用派生属性时，必须在某处定义如何计算它。[图 6-11](ch06.xhtml#ch6fig11)为此目的使用了注释，尽管你也可以使用*属性字符串*（参见“[属性字符串](ch06.xhtml#lev-6.3.8)”在[第
    112 页](ch06.xhtml#page_112)）。
- en: '***6.3.3 Attribute Names***'
  id: totrans-66
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***6.3.3 属性名称***'
- en: 'The attribute name should work in whichever programming language(s) you use
    to implement the design. As much as possible, you should refrain from naming syntax
    or conventions that are specific to a programming language unless you’re requiring
    implementation in that language. As a general rule, the following conventions
    work well for UML attribute names:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 属性名称应该适用于你用来实现设计的任何编程语言。尽量避免使用特定编程语言的语法或约定，除非要求使用该语言来实现。通常，以下约定适用于UML属性名称：
- en: All names should begin with an (ASCII) alphabetic character (a–z or A–Z).
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 所有名称应以一个（ASCII）字母字符（a–z或A–Z）开头。
- en: After the first character, names should contain only ASCII alphabetic characters
    (a–z, A–Z), numeric digits (0–9), or underscores (_).
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在第一个字符之后，名称应仅包含ASCII字母字符（a–z, A–Z）、数字（0–9）或下划线（_）。
- en: All names should be unique within the first six to eight characters (some compilers
    allow arbitrary-length names but keep only a prefix of them in the internal symbol
    table during compilation).
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 所有名称的前六到八个字符应当是唯一的（某些编译器允许任意长度的名称，但在编译过程中仅在内部符号表中保留其前缀）。
- en: Names should be shorter than some arbitrary length (we’ll use 32 characters
    here).
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 名称应该短于某个任意长度（这里我们使用32个字符）。
- en: All names should be *case neutral*; that is, two separate names must contain
    at least one distinct character rather than just a difference in case. Also, all
    occurrences of a given name should be consistent with respect to alphabetic case.^([5](ch19_footnote.xhtml#ch06fn5))
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 所有名称应当是*不区分大小写*的；也就是说，两个不同的名称必须包含至少一个不同的字符，而不仅仅是大小写的差异。此外，给定名称的所有出现应该在字母大小写方面保持一致。^([5](ch19_footnote.xhtml#ch06fn5))
- en: '*6.3.4 Attribute Data Types*'
  id: totrans-73
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '*6.3.4 属性数据类型*'
- en: A UML object can optionally have an associated data type (see the examples in
    [Figure 6-10](ch06.xhtml#ch6fig10)). UML doesn’t require you to explicitly state
    the data type; if it’s absent, the assumption is that the reader can infer it
    from the attribute’s name or usage, or that the programmer will decide on a type
    while implementing the design.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: UML对象可以选择性地关联一个数据类型（参见[图6-10](ch06.xhtml#ch6fig10)中的示例）。UML并不要求你明确声明数据类型；如果缺少数据类型，假设读者可以从属性的名称或用法中推断出数据类型，或者程序员在实现设计时决定数据类型。
- en: 'You can use any type names you want for primitive data types and leave it up
    to the programmer to choose the appropriate or closest matching data type when
    writing the code. That being said, when working with generic data types most people
    choose C++ or Java type names (which makes sense, because UML’s design was largely
    based on these two languages). Common data types you’ll find attached to UML attributes
    include:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以为原始数据类型使用任何类型名称，并让程序员在编写代码时选择适当的或最匹配的数据类型。也就是说，在使用通用数据类型时，大多数人选择C++或Java的类型名称（这很有道理，因为UML的设计在很大程度上是基于这两种语言的）。你会在UML属性中看到的常见数据类型包括：
- en: '`int`, `long`, `unsigned`, `unsigned long`, `short`, `unsigned short`'
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`int`, `long`, `unsigned`, `unsigned long`, `short`, `unsigned short`'
- en: '`float`, `double`'
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`float`, `double`'
- en: '`char`, `wchar`'
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`char`, `wchar`'
- en: '`string`, `wstring`'
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`string`, `wstring`'
- en: Of course, any user-defined type names are perfectly valid as well. For example,
    if you’ve defined `uint16_t` to mean the same thing as `unsigned short` in your
    design, then using `uint16_t` as an attribute type is perfectly acceptable. In
    addition, any class objects you define in UML also make perfectly good data type
    names.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，任何用户定义的类型名称也是完全有效的。例如，如果你在设计中将`uint16_t`定义为与`unsigned short`相同的含义，那么将`uint16_t`作为属性类型是完全可以接受的。此外，你在UML中定义的任何类对象也都可以作为有效的数据类型名称。
- en: '***6.3.5 Operation Data Types (Return Values)***'
  id: totrans-81
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***6.3.5 操作数据类型（返回值）***'
- en: You can also associate a data type with an operation. Functions, for example,
    can return a value having some data type. To specify a return data type, follow
    the operation name (and parameter list) with a colon and the data type, as shown
    in [Figure 6-12](ch06.xhtml#ch6fig12).
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以将数据类型与操作关联。例如，函数可以返回某种数据类型的值。为了指定返回数据类型，可以在操作名称（和参数列表）后跟一个冒号和数据类型，如[图6-12](ch06.xhtml#ch6fig12)所示。
- en: '![image](Images/fig6-12.jpg)'
  id: totrans-83
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/fig6-12.jpg)'
- en: '*Figure 6-12: Return types*'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: '*图6-12：返回类型*'
- en: We’ll discuss operations more in “Class Operations” on [page 112](ch06.xhtml#page_112).
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在“类操作”一节中进一步讨论操作，[第112页](ch06.xhtml#page_112)。
- en: '***6.3.6 Attribute Multiplicity***'
  id: totrans-86
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***6.3.6 属性多重性***'
- en: Some attributes could contain a collection (array or list) of data objects.
    In UML we denote multiplicity using square brackets `[]`, similar to array declarations
    in many high-level languages; see [Figure 6-13](ch06.xhtml#ch6fig13).
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 一些属性可能包含数据对象的集合（数组或列表）。在UML中，我们使用方括号`[]`表示基数，类似于许多高级语言中的数组声明；见[图6-13](ch06.xhtml#ch6fig13)。
- en: '![image](Images/fig6-13.jpg)'
  id: totrans-88
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/fig6-13.jpg)'
- en: '*Figure 6-13: Multiplicity*'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: '*图6-13：基数*'
- en: 'Within the brackets, you specify an expression, which can be any of the following:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 在方括号内，您可以指定一个表达式，可以是以下任意内容：
- en: A numeric value (for example, `5`) indicating the number of elements in the
    collection
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个数字值（例如，`5`）表示集合中元素的数量
- en: A numeric range (for example, `1..5` or `0..7`) indicating the number of elements
    and valid suffix range for the collection of elements
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个数字范围（例如，`1..5`或`0..7`），表示集合元素的数量和有效的后缀范围
- en: An asterisk (`*`) representing an arbitrary number of elements
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个星号（`*`）表示任意数量的元素
- en: An asterisk-terminated range (for example, `0..*` or `1..*`) indicating an open-ended
    range of array elements
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个星号终止的范围（例如，`0..*`或`1..*`），表示一个开放的数组元素范围
- en: If this notation is absent, the multiplicity defaults to `[1]` (that is, a single
    data object).
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 如果没有这个符号，基数默认为`[1]`（即单个数据对象）。
- en: '***6.3.7 Default Attribute Values***'
  id: totrans-96
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***6.3.7 默认属性值***'
- en: To specify an initial value for an attribute, you use an equal sign (`=`) followed
    by an expression (with a type appropriate for the attribute). This typically follows
    the attribute’s multiplicity (if present) and/or type. But if the type can be
    inferred from the initial value, you can omit both it and the multiplicity. If
    the multiplicity is something other than `1`, you enclose a comma-separated list
    of initial values, one for each element, within a pair of braces. See [Figure
    6-14](ch06.xhtml#ch6fig14).
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 要为属性指定初始值，使用等号（`=`）后跟一个表达式（类型应适合该属性）。这通常跟随属性的基数（如果存在）和/或类型。但如果类型可以从初始值推断出来，则可以省略类型和基数。如果基数不是`1`，则在大括号内包含一个逗号分隔的初始值列表，每个元素一个。见[图6-14](ch06.xhtml#ch6fig14)。
- en: '![image](Images/fig6-14.jpg)'
  id: totrans-98
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/fig6-14.jpg)'
- en: '*Figure 6-14: Initial values*'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: '*图6-14：初始值*'
- en: In this example, the `numTempSensors` attribute is an `integer` type (which
    can be inferred by the initial value `2`), and `tempSensorSpan` is an array of
    `double`s with two elements (inferred by the number and types of values in the
    braces).
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，`numTempSensors`属性是`integer`类型（可以从初始值`2`推断出来），而`tempSensorSpan`是一个包含两个元素的`double`数组（通过大括号中的数量和类型的值来推断）。
- en: '***6.3.8 Property Strings***'
  id: totrans-101
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***6.3.8 属性字符串***'
- en: UML’s attribute syntax probably doesn’t cover every possible case for your attributes.
    UML provides the *property string* to handle outlier situations. To create a property
    string, you add text within braces at the end of the attribute that describes
    it, as shown in [Figure 6-15](ch06.xhtml#ch6fig15).
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: UML的属性语法可能无法覆盖所有可能的属性情况。UML提供了*属性字符串*来处理特殊情况。要创建一个属性字符串，您需要在属性末尾添加描述它的文本，并将其放在大括号内，如[图6-15](ch06.xhtml#ch6fig15)所示。
- en: '![image](Images/fig6-15.jpg)'
  id: totrans-103
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/fig6-15.jpg)'
- en: '*Figure 6-15: Property strings*'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: '*图6-15：属性字符串*'
- en: You can also use property strings to define other property types. Common examples
    include `{readOnly}`, `{unique}`, and `{static}`.^([6](ch19_footnote.xhtml#ch06fn6))
    Keep in mind that a property string is a catch-all field in the attribute. You
    can define any syntax you want inside the braces.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以使用属性字符串来定义其他属性类型。常见的例子包括`{readOnly}`、`{unique}`和`{static}`。^([6](ch19_footnote.xhtml#ch06fn6))
    请记住，属性字符串是属性中的一个通用字段。您可以在大括号内定义任何语法。
- en: '***6.3.9 Attribute Syntax***'
  id: totrans-106
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***6.3.9 属性语法***'
- en: 'The formal syntax for an attribute looks as follows (note that optional items
    appear in braces, except quoted braces, which represent literal brace characters):'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 属性的正式语法如下所示（注意，选项项出现在大括号中，除了引用的大括号，它们表示字面上的大括号字符）：
- en: '[PRE0]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '**6.4 Class Operations**'
  id: totrans-109
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**6.4 类操作**'
- en: Class operations are items within a class that perform actions. Generally, the
    operations represent the code in a class (but there can also be code associated
    with derived attributes, so having code is not exclusive to operations in a UML
    class).
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 类操作是类中的项目，执行某些操作。通常，操作代表类中的代码（但也可能有与派生属性相关联的代码，因此代码不仅限于UML类中的操作）。
- en: 'UML class diagrams place attributes and operations into separate rectangles,
    though this is not what differentiates one from the other. (Consider [Figure 6-2](ch06.xhtml#ch6fig2):
    the partial class diagrams are ambiguous with respect to which class diagram contains
    only attributes and which contains only operations.) In UML we explicitly specify
    operations within a class diagram by following the operation’s name with a (possibly
    empty) parameter list surrounded by parentheses (refer to [Figure 6-4](ch06.xhtml#ch6fig4)
    for an example).'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: UML 类图将属性和操作放入不同的矩形中，尽管这并不是区分它们的标准。（考虑[图 6-2](ch06.xhtml#ch6fig2)：部分类图在区分哪些类图只包含属性，哪些类图只包含操作方面存在歧义。）在
    UML 中，我们通过在操作名称后加上（可能为空的）参数列表并用括号括起来来明确指定操作（参考[图 6-4](ch06.xhtml#ch6fig4)查看示例）。
- en: As noted in “Operation Data Types (Return Values)” on [page 110](ch06.xhtml#page_110),
    you can also specify a return type for an operation by following the parameter
    list with a colon and a data type name. If the type is present, you definitely
    have a function; if it’s absent, you likely have a procedure (a *void function*).
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 如“操作数据类型（返回值）”一节中所述，在[第 110 页](ch06.xhtml#page_110)你还可以通过在参数列表后加上冒号和数据类型名称来为操作指定返回类型。如果存在类型，则表示你有一个函数；如果缺少类型，则你可能有一个过程（*空函数*）。
- en: What’s been missing in all the operation examples thus far is parameters. To
    specify parameters, you insert a comma-separated list of attributes within the
    parentheses immediately following the operation name, as shown in [Figure 6-16](ch06.xhtml#ch6fig16).
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，所有操作示例中缺少的都是参数。要指定参数，可以在操作名称后面的括号内插入以逗号分隔的属性列表，如[图 6-16](ch06.xhtml#ch6fig16)所示。
- en: '![image](Images/fig6-16.jpg)'
  id: totrans-114
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/fig6-16.jpg)'
- en: '*Figure 6-16: Operation parameters*'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 6-16：操作参数*'
- en: By default, parameters in a UML operation are *value* parameters, meaning they’re
    passed to the operation as an argument, and changes an operation makes to a value
    parameter do not affect the actual parameter the caller passes to the function.
    A value parameter is an *input parameter*.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，UML 操作中的参数是 *值* 参数，这意味着它们作为参数传递给操作，且操作对值参数所做的更改不会影响调用者传递给函数的实际参数。值参数是
    *输入参数*。
- en: 'UML also supports *output* parameters and *input/output* parameters. As their
    names suggest, output parameters return information from the operation to the
    calling code; input/output parameters pass information to and return data from
    an operation. UML uses the following syntax to denote input, output, and input/output
    parameters:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: UML 还支持 *输出* 参数和 *输入/输出* 参数。顾名思义，输出参数将信息从操作返回到调用代码；输入/输出参数则将信息传递给操作并返回数据。UML
    使用以下语法表示输入、输出和输入/输出参数：
- en: 'Input parameters: `in` *paramName*`:`*paramType*'
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 输入参数：`in` *paramName*`:`*paramType*
- en: 'Output parameters: `out` *paramName*`:`*paramType*'
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 输出参数：`out` *paramName*`:`*paramType*
- en: 'Input/output parameters: `inout` *paramName*`:`*paramType*'
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 输入/输出参数：`inout` *paramName*`:`*paramType*
- en: The default parameter-passing mechanism is input. If there’s nothing specified
    before the parameter name, UML assumes that it is an `in` parameter. [Figure 6-17](ch06.xhtml#ch6fig17)
    shows a simple example of an `inout` parameter.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 默认的参数传递机制是输入。如果参数名前没有任何说明，UML 假设它是一个 `in` 参数。[图 6-17](ch06.xhtml#ch6fig17)展示了一个简单的
    `inout` 参数示例。
- en: '![image](Images/fig6-17.jpg)'
  id: totrans-122
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/fig6-17.jpg)'
- en: '*Figure 6-17: Parameter inout example*'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 6-17：参数输入输出示例*'
- en: In this figure, the list of items to sort is an input *and* an output parameter.
    On input, the `items` array contains the data to be sorted; on output, it contains
    the sorted items (an in-place sort).
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 在这张图中，待排序项的列表是一个输入 *和* 输出参数。在输入时，`items` 数组包含待排序的数据；在输出时，它包含排序后的项（就地排序）。
- en: UML tries to be as generic as possible. The `in`, `out`, and `inout` parameter-passing
    specifiers don’t necessarily imply pass by value or pass by reference. This implementation
    detail is left to, well, the actual implementation. From a design point of view,
    UML is specifying only the direction in which, not how, the data is transferred.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: UML 尽量做到尽可能通用。`in`、`out` 和 `inout` 参数传递说明符并不一定意味着按值传递或按引用传递。这个实现细节留给实际的实现者来决定。从设计角度来看，UML
    只指定数据传输的方向，而不是数据如何被传输。
- en: '**6.5 UML Class Relationships**'
  id: totrans-126
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**6.5 UML 类关系**'
- en: 'In this section, we’ll explore five different types of relationships between
    classes: dependency, association, aggregation, composition, and inheritance.'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将探讨类之间的五种不同关系：依赖关系、关联关系、聚合关系、组合关系和继承关系。
- en: Like visibility, class relationships fall along a spectrum (see [Figure 6-18](ch06.xhtml#ch6fig18)).
    This range is based on their *strength*, or the level and type of intercommunication
    between two classes.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 类似于可见性，类之间的关系沿着一个光谱分布（见[图6-18](ch06.xhtml#ch6fig18)）。这个范围是基于它们的*强度*，即两个类之间的相互通信的级别和类型。
- en: '![image](Images/fig6-18.jpg)'
  id: totrans-129
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/fig6-18.jpg)'
- en: '*Figure 6-18: Class relationship spectrum*'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: '*图6-18：类关系光谱*'
- en: Strength ranges from *loosely coupled* to *tightly coupled*. When two classes
    are tightly coupled, any modifications to one class will likely affect the state
    of the other class. Loosely coupled classes are mostly independent of each other;
    changes to one are unlikely to affect the other.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 强度范围从*松散耦合*到*紧密耦合*。当两个类是紧密耦合时，对一个类的任何修改很可能会影响到另一个类的状态。松散耦合的类通常相互独立；对一个类的修改不太可能影响到另一个类。
- en: We’ll discuss each type of class relationship in turn, from weakest to strongest.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将依次讨论每种类型的类关系，从最弱到最强。
- en: '***6.5.1 Class Dependency Relationships***'
  id: totrans-133
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***6.5.1 类依赖关系***'
- en: Two classes are dependent on each other when objects of one class need to *briefly*
    work with objects of another class. In UML we use a dashed open-ended arrow to
    denote a dependency relationship, as shown in [Figure 6-19](ch06.xhtml#ch6fig19).
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个类的对象需要与另一个类的对象*短暂*合作时，这两个类就形成了依赖关系。在UML中，我们使用一个虚线开口箭头来表示依赖关系，如[图6-19](ch06.xhtml#ch6fig19)所示。
- en: '![image](Images/fig6-19.jpg)'
  id: totrans-135
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/fig6-19.jpg)'
- en: '*Figure 6-19: Dependency relationship*'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: '*图6-19：依赖关系*'
- en: In this example, the `userInterface` and `poolMonitor` classes work together
    whenever a `userInterface` object wants to retrieve data to display (for example,
    when you pass a `poolMonitor` object to a `userInterface` method as a parameter).
    Other than that, the two classes (and objects of those classes) operate independently
    of each other.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，每当`userInterface`对象想要检索数据进行显示时（例如，当你将`poolMonitor`对象作为参数传递给`userInterface`方法时），`userInterface`和`poolMonitor`类就会协同工作。除此之外，两个类（以及这些类的对象）相互独立操作。
- en: '***6.5.2 Class Association Relationships***'
  id: totrans-138
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***6.5.2 类关联关系***'
- en: 'An association relationship occurs when one class contains an attribute whose
    type is a second class. There are two ways to draw an association relationship
    in UML: inline attributes and association links. You’ve already seen inline attributes—they’re
    the normal attribute definitions you saw in “Attribute Syntax” on [page 112](ch06.xhtml#page_112)).
    The only requirement is that the type name must be some other class.'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 关联关系发生在一个类包含一个属性，而该属性的类型是另一个类时。UML中有两种表示关联关系的方式：内联属性和关联链接。你已经见过内联属性——它们是你在[第112页](ch06.xhtml#page_112)的“属性语法”中看到的常规属性定义。唯一的要求是类型名称必须是其他类。
- en: The second way to specify a class association relationship is with an association
    *line* or *link*, as shown in [Figure 6-20](ch06.xhtml#ch6fig20).
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 指定类关联关系的第二种方式是通过关联*线*或*链接*，如[图6-20](ch06.xhtml#ch6fig20)所示。
- en: '![image](Images/fig6-20.jpg)'
  id: totrans-141
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/fig6-20.jpg)'
- en: '*Figure 6-20: Association relationship*'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: '*图6-20：关联关系*'
- en: The *association name* is typically a verb phrase that describes the association,
    such as *has*, *owns*, *controls*, *is owned by*, and *is controlled by* (see
    [Figure 6-21](ch06.xhtml#ch6fig21)).
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: '*关联名称*通常是一个动词短语，描述关联关系，如*拥有*、*控制*、*由…拥有*、*由…控制*（见[图6-21](ch06.xhtml#ch6fig21)）。'
- en: '![image](Images/fig6-21.jpg)'
  id: totrans-144
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/fig6-21.jpg)'
- en: '*Figure 6-21: Association names*'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: '*图6-21：关联名称*'
- en: How can we tell from an association diagram which class is an attribute of the
    other? Notice the arrowhead immediately to the left or right of the association
    name. This provides the direction of the association; here, it shows that the
    `poolMonitor` has a `phClass`, rather than the reverse.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 我们如何从关联图中判断哪个类是另一个类的属性呢？注意关联名称左侧或右侧的箭头头部。这指示了关联的方向；在这里，它表明`poolMonitor`有一个`phClass`，而不是反过来。
- en: But while a meaningful association name and arrowhead verb phrase can give you
    a clue, there’s no guarantee that your intuition will be correct. Although it
    might seem counterintuitive, `pumpClass` in [Figure 6-21](ch06.xhtml#ch6fig21)
    could contain the `poolMonitor` object as an attribute, even though the `poolMonitor`
    class controls the `pumpClass` object. The UML solution is to apply *navigability*
    (see “[Navigability](ch06.xhtml#lev-6.5.5.9)” on [page 123](ch06.xhtml#page_123))
    by placing an open-ended arrow pointing at the class that is an attribute of the
    other class, as shown in [Figure 6-22](ch06.xhtml#ch6fig22).
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管一个有意义的关联名称和箭头动词短语可以给你一个线索，但无法保证你的直觉是正确的。虽然这看起来可能违反直觉，但在[图6-21](ch06.xhtml#ch6fig21)中，`pumpClass`可能包含`poolMonitor`对象作为一个属性，即使`poolMonitor`类控制着`pumpClass`对象。UML的解决方案是通过应用*可导航性*（参见“[可导航性](ch06.xhtml#lev-6.5.5.9)”在[第123页](ch06.xhtml#page_123)）来处理，通过在指向作为其他类属性的类上放置一个开口箭头，如[图6-22](ch06.xhtml#ch6fig22)所示。
- en: '![image](Images/fig6-22.jpg)'
  id: totrans-148
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/fig6-22.jpg)'
- en: '*Figure 6-22: Association navigability*'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: '*图6-22：关联的可导航性*'
- en: '***6.5.3 Class Aggregation Relationships***'
  id: totrans-150
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***6.5.3 类聚合关系***'
- en: An aggregation, a slightly more tightly coupled version of association, exists
    as a class that could be stand-alone but is part of a larger class. Most of the
    time, an aggregation relationship is a *controls* relationship; that is, a controlling
    class (the *aggregate* or *whole* class) controls a set of subservient objects
    or attributes (the *parts* classes). The aggregate class cannot exist without
    the parts classes; however, the parts classes can exist outside the context of
    the aggregate class (for example, a parts class could be associated with both
    the aggregate class and an additional class).
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 聚合是关联的一个稍微紧密耦合的版本，存在于一个可能是独立存在的类，但又是一个更大类的一部分。大多数时候，聚合关系是一种*控制*关系；也就是说，一个控制类（*聚合类*或*整体类*）控制一组从属对象或属性（*部分类*）。聚合类不能在没有部分类的情况下存在；然而，部分类可以在聚合类的上下文之外存在（例如，一个部分类可以与聚合类和另一个类建立关联）。
- en: Aggregates act as *gatekeepers* to their parts attributes, ensuring that the
    parts’ methods are being called with appropriate (for example, range-checked)
    parameters and that the operating environment for those parts is consistent. The
    aggregate class can also check return values for consistency and handle exceptions
    and other issues raised by the parts.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 聚合作为*门控*器，负责其部分属性，确保部分方法以适当的参数（例如，范围检查）被调用，并且这些部分的操作环境是一致的。聚合类还可以检查返回值的一致性，处理部分类引发的异常和其他问题。
- en: 'For example, you could have a `pHSensor` class that works well with a stand-alone
    pH meter and a `salinitySensor` class that works well with a stand-alone salinity
    (or conductivity) sensor. The `poolMonitor` class is not a stand-alone class:
    it needs both of these classes to do its job, even though they don’t need `poolMonitor`
    to do theirs. We model this relationship using an empty diamond symbol on the
    aggregate class (`poolMonitor`) and an association line leading to the parts classes
    (`pHSensor` and `salinitySensor`), as shown in [Figure 6-23](ch06.xhtml#ch6fig23).'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，你可以有一个`pHSensor`类，它与独立的pH计配合得很好，一个`salinitySensor`类，它与独立的盐度（或电导率）传感器配合得很好。`poolMonitor`类不是一个独立的类：它需要这两个类来完成它的工作，尽管它们不需要`poolMonitor`来完成它们的工作。我们通过在聚合类（`poolMonitor`）上使用空心菱形符号，并通过一条关联线连接到部分类（`pHSensor`和`salinitySensor`）来建模这种关系，如[图6-23](ch06.xhtml#ch6fig23)所示。
- en: '![image](Images/fig6-23.jpg)'
  id: totrans-154
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/fig6-23.jpg)'
- en: '*Figure 6-23: Aggregation relationship*'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: '*图6-23：聚合关系*'
- en: The class with the open diamond end of the association line (that is, the aggregated
    class) always contains the attribute-associated class (the parts class) at the
    other end of the line.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 关联线的开口菱形端（即聚合类）总是包含关联线另一端的属性类（部分类）。
- en: The lifetimes of an aggregate object and its associated parts objects are not
    necessarily the same. You could create several parts objects and then attach them
    to an aggregate object. When the aggregate object finishes its task, it can be
    deallocated while the parts objects continue to solve other problems. In other
    words, from a low-level programming perspective, the system stores pointers to
    the parts objects in the aggregate object. When the system deallocates the storage
    for the aggregate object, the pointers might go away, but the objects they reference
    might persist (and could be pointed at by other aggregate objects in the system).
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 聚合对象及其关联部分对象的生命周期不一定相同。你可以创建多个部分对象，然后将它们附加到聚合对象上。当聚合对象完成任务后，它可以被销毁，而部分对象则可以继续解决其他问题。换句话说，从低级编程的角度来看，系统在聚合对象中存储指向部分对象的指针。当系统销毁聚合对象的存储时，指针可能会消失，但它们所引用的对象可能会继续存在（并且可能会被系统中的其他聚合对象指向）。
- en: Why use an aggregate diagram? The code produced for an association and an aggregation
    will be identical. The difference is one of intent. In an aggregation diagram,
    the designer is saying that the parts objects or classes are under the control
    of the aggregate class or object. To return to our `poolMonitor` example, in the
    aggregation relationship, the `poolMonitor` is in complete charge—the `salinitySensor`
    and `pHSensor` objects are being controlled by it, and never the other way around.
    In an association relationship, however, the associated classes are *peers* rather
    than having a master/slave relationship; that is, both the `pHSensor` and `salinitySensor`
    could operate independently of the `poolMonitor`—and vice versa—sharing information
    only as necessary.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么使用聚合图？对于关联和聚合生成的代码是相同的。区别在于意图。在聚合图中，设计师表示部分对象或类由聚合类或对象控制。以我们的`poolMonitor`示例为例，在聚合关系中，`poolMonitor`完全掌控——`salinitySensor`和`pHSensor`对象由它控制，绝不是反过来。而在关联关系中，相关类是*平等*的，而不是主从关系；也就是说，`pHSensor`和`salinitySensor`可以独立于`poolMonitor`操作——反之亦然——仅在必要时共享信息。
- en: '***6.5.4 Class Composition Relationships***'
  id: totrans-159
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***6.5.4 类的组合关系***'
- en: 'In composition relationships, the smaller classes contained by the larger class
    are not stand-alone classes: they exist strictly to support the containing, or
    *composing*, class. Unlike with aggregates, composition parts can belong only
    to a single composition.'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 在组合关系中，较小的类是由较大的类包含的，这些小类不是独立的类：它们仅存在于支持包含它们的*组合*类。与聚合不同，组合部分只能属于单一的组合。
- en: The lifetimes of the composing object and the parts objects are the same. When
    you destroy the composing object, you also destroy the parts objects it contains.
    The composing object is responsible for allocating and deallocating storage associated
    with the parts.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 组合对象和部分对象的生命周期是相同的。当你销毁组合对象时，包含的部分对象也会被销毁。组合对象负责分配和回收与部分对象相关的存储空间。
- en: We use a solid diamond to denote a composition relationship, as shown in [Figure
    6-24](ch06.xhtml#ch6fig24).
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用实心菱形来表示组合关系，如[图 6-24](ch06.xhtml#ch6fig24)所示。
- en: '![image](Images/fig6-24.jpg)'
  id: totrans-163
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/fig6-24.jpg)'
- en: '*Figure 6-24: Composition relationship*'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 6-24：组合关系*'
- en: '***6.5.5 Relationship Features***'
  id: totrans-165
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***6.5.5 关系特性***'
- en: 'For dependency, association, aggregation, and composition relationships, UML
    supports these 10 features, some of which you’ve already seen:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 对于依赖、关联、聚合和组合关系，UML支持这10个特性，其中一些你已经见过：
- en: Attribute names
  id: totrans-167
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 属性名称
- en: Roles
  id: totrans-168
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 角色
- en: Interface specifiers
  id: totrans-169
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 接口说明符
- en: Visibility
  id: totrans-170
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可见性
- en: Multiplicity
  id: totrans-171
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 多重性
- en: Ordering
  id: totrans-172
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 顺序
- en: Constraints
  id: totrans-173
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 约束
- en: Qualifiers
  id: totrans-174
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 限定符
- en: Navigability
  id: totrans-175
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可导航性
- en: Changeability
  id: totrans-176
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可变性
- en: These features don’t apply to the inheritance relationship, which is why I haven’t
    yet described it. We’ll get to inheritance shortly in the section “[Class Inheritance
    Relationships](ch06.xhtml#lev-6.5.6)” on [page 125](ch06.xhtml#page_125), but
    first we’ll cover each of these relationship features.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 这些特性不适用于继承关系，这就是为什么我还没有描述它。我们将在后面的“[类继承关系](ch06.xhtml#lev-6.5.6)”部分中讨论继承内容，具体见[第125页](ch06.xhtml#page_125)，但首先我们会讲解这些关系特性。
- en: '**NOTE**'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*For simplicity’s sake I use* association *to discuss each feature, but* dependency,
    aggregate, *and* composition *all equally apply.*'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: '*为了简化，我使用*关联*来讨论每个特性，但*依赖*、聚合*和*组合*都同样适用。'
- en: '**6.5.5.1 Association and Attribute Names**'
  id: totrans-180
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**6.5.5.1 关联和属性名称**'
- en: The association name attached to a link can tell you the type or ownership of
    the interaction, but it doesn’t tell you how the two classes refer to each other.
    The association link only provides a connection between the two class objects.
    Classes refer to each other using attribute and operation fields in the class
    definition.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 附加到链接上的关联名称可以告诉你交互的类型或所有权，但它并没有说明这两个类是如何相互引用的。关联链接仅提供两个类对象之间的连接。类通过类定义中的属性和操作字段来相互引用。
- en: As you read in “Class Association Relationships” on [page 115](ch06.xhtml#page_115),
    the association diagram is effectively an alternative to the inline syntax for
    incorporating an attribute or operation name within a class. The two diagrams
    in [Figure 6-25](ch06.xhtml#ch6fig25) are equivalent.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你在“类关联关系”部分中阅读到的，关联图实际上是将属性或操作名称嵌入类中的内联语法的替代方案。[图6-25](ch06.xhtml#ch6fig25)中的两个图示是等效的。
- en: '![image](Images/fig6-25.jpg)'
  id: totrans-183
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/fig6-25.jpg)'
- en: '*Figure 6-25: Shorthand (top) and longhand (bottom) association relationship
    diagrams*'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: '*图6-25：简写（上）和长写（下）关联关系图*'
- en: In [Figure 6-25](ch06.xhtml#ch6fig25), the shorthand version is missing the
    attribute or operation name (`pHSensor` in this example) and the visibility (`-`,
    or private), but you can supply these missing pieces by attaching the attribute
    name to the association link nearest the object that will hold the object reference
    data field, as shown in [Figure 6-26](ch06.xhtml#ch6fig26).
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 在[图6-25](ch06.xhtml#ch6fig25)中，简写版本缺少了属性或操作名称（在此示例中为`pHSensor`）以及可见性（`-`，或私有），但你可以通过将属性名称附加到离对象最近的关联链接上，来补充这些缺失的部分，如[图6-26](ch06.xhtml#ch6fig26)所示。
- en: Like the inline syntax, an attribute name consists of an attribute or operation
    name with a visibility symbol prefix (`-`, `~`, `#`, or `+`). The visibility symbol
    must be present because it differentiates an attribute name from a role (described
    next).
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 与内联语法一样，属性名称由属性或操作名称和可见性符号前缀（`-`，`~`，`#`，或`+`）组成。可见性符号必须存在，因为它区分了属性名称和角色（接下来将描述）。
- en: '![image](Images/fig6-26.jpg)'
  id: totrans-187
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/fig6-26.jpg)'
- en: '*Figure 6-26: Attribute name*'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: '*图6-26：属性名称*'
- en: Another option is to combine the association and attribute names, as shown in
    [Figure 6-27](ch06.xhtml#ch6fig27).
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种选择是将关联和属性名称结合在一起，如[图6-27](ch06.xhtml#ch6fig27)所示。
- en: '![image](Images/fig6-27.jpg)'
  id: totrans-190
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/fig6-27.jpg)'
- en: '*Figure 6-27: Combining association and attribute names*'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: '*图6-27：组合关联和属性名称*'
- en: '**6.5.5.2 Roles**'
  id: totrans-192
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**6.5.5.2 角色**'
- en: In [Figure 6-27](ch06.xhtml#ch6fig27), it isn’t entirely clear what the two
    classes are doing. The `poolMonitor` class has a `pHSensor` field that connects
    to the `pHClass`, but otherwise the diagram doesn’t explain what’s going on. *Roles*,
    which typically appear at both ends of the association link, provide this missing
    description.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 在[图6-27](ch06.xhtml#ch6fig27)中，两个类的作用并不完全清晰。`poolMonitor`类有一个连接到`pHClass`的`pHSensor`字段，但图示并未解释发生了什么。通常出现在关联链接两端的*角色*，提供了缺失的描述。
- en: In this example, the `poolMonitor` class or object generally reads the pH value
    from a pH sensor device (encapsulated in `pHClass`). Conversely, the `pHClass`
    class or object can supply pH readings. You can describe these two activities
    (reading pH and supplying a pH value) using roles in UML. [Figure 6-28](ch06.xhtml#ch6fig28)
    shows an example of these roles.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 在此示例中，`poolMonitor`类或对象通常从pH传感器设备（封装在`pHClass`中）读取pH值。反之，`pHClass`类或对象可以提供pH读数。你可以使用UML中的角色来描述这两个活动（读取pH和提供pH值）。[图6-28](ch06.xhtml#ch6fig28)展示了这些角色的示例。
- en: '![image](Images/fig6-28.jpg)'
  id: totrans-195
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/fig6-28.jpg)'
- en: '*Figure 6-28: Roles*'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: '*图6-28：角色*'
- en: '**6.5.5.3 Interface Specifiers**'
  id: totrans-197
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**6.5.5.3 接口说明符**'
- en: An *interface* is a set of operations expected from certain classes. It’s similar
    to a class except there are no objects instantiated from it. Classes that adhere
    to an interface are guaranteed to provide all the operations present in it (and
    provide methods for those operations). If you’re a C++ programmer, you can think
    of an interface as an abstract base class containing only abstract member functions.
    Java, C#, and Swift have their own special syntax for defining interfaces (also
    known as *protocols*).
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: '*接口*是一组预期由某些类提供的操作。它类似于类，但不会实例化对象。遵循接口的类确保提供接口中所有存在的操作（并为这些操作提供方法）。如果你是C++程序员，你可以把接口看作是一个只包含抽象成员函数的抽象基类。Java、C#和Swift都有各自的定义接口（也称为*协议*）的特殊语法。'
- en: '**NOTE**'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*Interface specifiers are supported in UML 1.*x *but have been dropped from
    UML 2.0\. I describe them in this chapter because you might encounter them, but
    you shouldn’t use them in new UML documents because they’re deprecated.*'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: '*接口说明符在 UML 1.x 中受支持，但已从 UML 2.0 中删除。我在本章中描述它们，因为你可能会遇到它们，但你不应该在新的 UML 文档中使用它们，因为它们已被弃用。*'
- en: If a class implements an interface, it’s effectively inheriting all the operations
    from that interface. That is, if an interface provides operations A, B, and C,
    and some class implements that interface, that class must also provide operations
    A, B, and C (and provide concrete implementations of these operations). There
    are two distinct ways to specify an interface—with *stereotype* or *ball* notation,
    as shown in [Figure 6-29](ch06.xhtml#ch6fig29).
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一个类实现了一个接口，它实际上是继承了该接口的所有操作。也就是说，如果一个接口提供了操作 A、B 和 C，而某个类实现了该接口，那么这个类也必须提供操作
    A、B 和 C（并提供这些操作的具体实现）。有两种不同的方式来指定一个接口——使用 *立体符号* 或 *球体符号*，如 [图 6-29](ch06.xhtml#ch6fig29)
    所示。
- en: '![image](Images/fig6-29.jpg)'
  id: totrans-202
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/fig6-29.jpg)'
- en: '*Figure 6-29: Interface syntax: stereotype (top) and ball (bottom) notation*'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 6-29：接口语法：立体符号（顶部）和球体符号（底部）*'
- en: To show that a class implements a given interface, you draw a dashed line with
    a hollow arrowhead from the class to the interface diagram, as shown in [Figure
    6-30](ch06.xhtml#ch6fig30).
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 为了表示一个类实现了某个接口，你需要从类到接口图绘制一条带有空心箭头的虚线，如 [图 6-30](ch06.xhtml#ch6fig30) 所示。
- en: '![image](Images/fig6-30.jpg)'
  id: totrans-205
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/fig6-30.jpg)'
- en: '*Figure 6-30: Interface implementation diagram*'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 6-30：接口实现图*'
- en: '**6.5.5.4 Visibility**'
  id: totrans-207
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**6.5.5.4 可见性**'
- en: Visibility applies to attribute names in an association link. As noted earlier,
    all attribute names must be prefixed with a symbol (`-`, `~`, `#`, or `+`) that
    specifies their visibility (private, package, protected, or public, respectively).
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 可见性适用于关联链接中的属性名。如前所述，所有属性名必须以符号（`-`、`~`、`#` 或 `+`）作为前缀，用来指定它们的可见性（分别为私有、包内、受保护或公共）。
- en: '**6.5.5.5 Multiplicity**'
  id: totrans-209
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**6.5.5.5 多重性**'
- en: The section “[Attribute Multiplicity](ch06.xhtml#lev-6.3.6)” on [page 111](ch06.xhtml#page_111)
    described multiplicity for inline attributes. You can also include multiplicity
    in association diagrams by specifying multiplicity values at either or both ends
    of an association link (see [Figure 6-31](ch06.xhtml#ch6fig31)). Place multiplicity
    values above or below the link and closest to the class or object to which they
    apply. If a multiplicity value is not provided, it defaults to `1`.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: “[属性多重性](ch06.xhtml#lev-6.3.6)”部分在 [第 111 页](ch06.xhtml#page_111) 介绍了内联属性的多重性。你还可以通过在关联链接的两端或其中一端指定多重性值，将多重性包含在关联图中（参见
    [图 6-31](ch06.xhtml#ch6fig31)）。将多重性值放在链接的上方或下方，且尽可能靠近它所适用的类或对象。如果没有提供多重性值，则默认值为
    `1`。
- en: '![image](Images/fig6-31.jpg)'
  id: totrans-211
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/fig6-31.jpg)'
- en: '*Figure 6-31: Multiplicity on an association link*'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 6-31：关联链接上的多重性*'
- en: '[Figure 6-31](ch06.xhtml#ch6fig31) indicates that there is a single `poolMonitor`
    object, and it can have one or more associated `pHSensor`s (there could be, for
    example, separate pH sensors in the spa and in the swimming pool proper).'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 6-31](ch06.xhtml#ch6fig31) 表明存在一个 `poolMonitor` 对象，它可以有一个或多个关联的 `pHSensor`（例如，水疗池和游泳池中可能分别有不同的
    pH 传感器）。'
- en: This example shows a *one-to-many* relationship. It’s also possible to have
    *many-to-one* and even *many-to-many* relationships in these diagrams. For example,
    [Figure 6-32](ch06.xhtml#ch6fig32) shows a many-to-many relationship between `poolMonitor`
    and `pHClass` classes or objects (if you’re having a hard time visualizing how
    this would work, consider a water park that has multiple pools with multiple pH
    meters).
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 这个示例展示了一个 *一对多* 的关系。图中也可以有 *多对一* 甚至 *多对多* 的关系。例如，[图 6-32](ch06.xhtml#ch6fig32)
    显示了 `poolMonitor` 和 `pHClass` 类或对象之间的多对多关系（如果你很难想象这种关系如何运作，可以考虑一个有多个泳池和多个 pH 测量仪的水上乐园）。
- en: '![image](Images/fig6-32.jpg)'
  id: totrans-215
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/fig6-32.jpg)'
- en: '*Figure 6-32: Many-to-many relationship*'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 6-32：多对多关系*'
- en: '**6.5.5.6 Ordering**'
  id: totrans-217
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**6.5.5.6 排序**'
- en: UML provides the `{ordered}` constraint, which you can attach to any association
    that has a multiplicity other than `1` (see [Figure 6-33](ch06.xhtml#ch6fig33)).
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: UML 提供了 `{ordered}` 约束，你可以将其附加到任何多重性不是 `1` 的关联上（参见 [图 6-33](ch06.xhtml#ch6fig33)）。
- en: '![image](Images/fig6-33.jpg)'
  id: totrans-219
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/fig6-33.jpg)'
- en: '*Figure 6-33: An ordered association*'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 6-33：有序关联*'
- en: When appearing by itself, the `{ordered}` constraint doesn’t specify how to
    order the list of items, only that they *are* ordered. The type of ordering must
    be handled by the implementation.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 当单独出现时，`{ordered}` 约束并未指定如何排序项目列表，只说明它们*是*有序的。排序的方式必须由实现来处理。
- en: '**6.5.5.7 Constraints**'
  id: totrans-222
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**6.5.5.7 约束**'
- en: A constraint is application-specific text within braces that you attach to an
    association link. Although UML has some predefined constraints (like the `{ordered}`
    constraint just mentioned), you usually create your own to provide some application-defined
    control over the association link. You can even specify multiple constraints by
    separating them with commas within the braces. For example, the singular `{ordered}`
    constraint in [Figure 6-33](ch06.xhtml#ch6fig33) doesn’t describe how to sort
    the temperature history information. You can specify the ordering by adding another
    constraint to the diagram, such as `sorted by date/time`, as shown in [Figure
    6-34](ch06.xhtml#ch6fig34).
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 约束是应用程序特定的文本，它放在大括号内并附加到关联链接上。尽管 UML 有一些预定义的约束（如刚刚提到的 `{ordered}` 约束），通常你会创建自己的约束来对关联链接提供应用程序定义的控制。你甚至可以通过在大括号内用逗号分隔来指定多个约束。例如，[图
    6-33](ch06.xhtml#ch6fig33) 中的单一 `{ordered}` 约束并未描述如何对温度历史信息进行排序。你可以通过向图示中添加另一个约束（如
    `按日期/时间排序`）来指定排序方式，如 [图 6-34](ch06.xhtml#ch6fig34) 所示。
- en: '![image](Images/fig6-34.jpg)'
  id: totrans-224
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/fig6-34.jpg)'
- en: '*Figure 6-34: A custom constraint*'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 6-34：一个自定义约束*'
- en: '**6.5.5.8 Qualifiers**'
  id: totrans-226
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**6.5.5.8 限定符**'
- en: A qualifier informs the implementer that a specified association requires fast
    access, typically using a key or index value. For example, suppose the temperature
    recording mechanism in [Figure 6-34](ch06.xhtml#ch6fig34) records the pool temperature
    every minute. Over the span of a week, the history object will accumulate 10,080
    readings; over a year, it will accumulate more than 3.6 million readings. To extract
    one reading per day (say, the temperature at noon) over the past year, you have
    to scan through nearly 4 million readings to produce 365 or 366 readings. That
    could be computationally intensive and create some performance issues, particularly
    for real-time systems (which the pool monitor system is likely to be). We could
    instead give each reading a unique index value so we can extract only those we
    need.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 限定符告知实现者，指定的关联需要快速访问，通常是通过键或索引值。例如，假设 [图 6-34](ch06.xhtml#ch6fig34) 中的温度记录机制每分钟记录一次游泳池温度。在一周的时间里，历史对象将积累
    10,080 次读取；一年内，它将积累超过 360 万次读取。为了提取过去一年中每天（比如中午）的读取，你必须扫描近 400 万次读取，才能得出 365 或
    366 次读取。这可能需要大量的计算资源，并且可能会带来性能问题，特别是对于实时系统（如游泳池监测系统）。我们可以为每次读取分配一个唯一的索引值，这样就只提取我们需要的读取。
- en: To create a UML qualifier, you place some qualification (usually an attribute
    name in the qualifying class or object) in a rectangle at one end of the association
    link, as shown in [Figure 6-35](ch06.xhtml#ch6fig35).
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建 UML 限定符，你需要将一些限定信息（通常是限定类或对象中的属性名称）放置在关联链接的一端的矩形框内，如 [图 6-35](ch06.xhtml#ch6fig35)
    所示。
- en: '![image](Images/fig6-35.jpg)'
  id: totrans-229
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/fig6-35.jpg)'
- en: '*Figure 6-35: A qualifier example*'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 6-35：一个限定符示例*'
- en: The unique qualifier requires all `tempHistoryClass` objects to have unique
    dates and times; that is, no two readings can have the same date and time value.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 唯一的限定符要求所有 `tempHistoryClass` 对象具有唯一的日期和时间；也就是说，不能有两个读取记录具有相同的日期和时间值。
- en: '[Figure 6-35](ch06.xhtml#ch6fig35) suggests that the system will maintain a
    special mechanism that lets us directly select a single `tempHistoryClass` object
    based on its `date_time` value. This is similar to a key in a database table.^([7](ch19_footnote.xhtml#ch06fn7))'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 6-35](ch06.xhtml#ch6fig35) 表明系统将维护一个特殊机制，让我们可以基于 `date_time` 值直接选择一个 `tempHistoryClass`
    对象。这类似于数据库表中的键。^([7](ch19_footnote.xhtml#ch06fn7))'
- en: In this example, the multiplicity values are both `1` because the dates and
    times are all unique, and the `date_time` qualifier will pick a specific date,
    for which there can be only one associated record. (Technically, there could be
    zero matches; however, the diagram doesn’t allow for that, so there must be a
    matching object.)
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 在此示例中，乘法值均为 `1`，因为日期和时间都是唯一的，`date_time` 限定符将选择一个特定的日期，因此只能有一个关联记录。（从技术上讲，可能没有匹配项；然而，图示中并未考虑这种情况，因此必须有匹配对象。）
- en: The multiplicity could be something other than `1` if the `date_time` key is
    not unique among the history objects. For example, if you want to generate a report
    with all the temperatures recorded at noon, you could specify that as shown in
    [Figure 6-36](ch06.xhtml#ch6fig36).
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`date_time`键在历史对象中不是唯一的，那么多重性可能是除`1`以外的其他值。例如，如果你想生成一份记录了正午所有温度的报告，你可以按如下方式指定，如[图6-36](ch06.xhtml#ch6fig36)所示。
- en: '![image](Images/fig6-36.jpg)'
  id: totrans-235
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/fig6-36.jpg)'
- en: '*Figure 6-36: A qualifier set example*'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: '*图6-36：一个限定符集示例*'
- en: Assuming you have a year’s worth of readings in the `tempHistoryClass` object,
    you’ll get a set of 365/366 readings, all on different dates but at the same time
    (noon in this example).
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你有一年份的`tempHistoryClass`对象读数，你将得到365/366条不同日期但相同时间（在此示例中为正午）的读数。
- en: One detail to keep in mind is that you can have multiple association diagrams
    that describe variants of the same association. For example, it’s not unreasonable
    to find [Figures 6-34](ch06.xhtml#ch6fig34), [6-35](ch06.xhtml#ch6fig35), and
    [6-36](ch06.xhtml#ch6fig36) in the same set of UML documents. [Figure 6-34](ch06.xhtml#ch6fig34)
    describes the generic association between the `poolMonitor` class or object and
    the `tempHistoryClass` object. [Figure 6-35](ch06.xhtml#ch6fig35) might describe
    a search operation where you’re searching for a specific temperature; this operation
    might be so common that you want to generate some sort of associative array (that
    is, a hash table) to improve its performance. Likewise, [Figure 6-36](ch06.xhtml#ch6fig36)
    suggests that you want another fast lookup table to speed up collecting a set
    of readings recorded at noon. Each diagram exists in its own context; they don’t
    conflict with one another.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 需要记住的一点是，你可以有多个关联图来描述同一关联的不同变体。例如，在同一套UML文档中看到[图6-34](ch06.xhtml#ch6fig34)、[6-35](ch06.xhtml#ch6fig35)和[6-36](ch06.xhtml#ch6fig36)是合理的。[图6-34](ch06.xhtml#ch6fig34)描述了`poolMonitor`类或对象与`tempHistoryClass`对象之间的通用关联。[图6-35](ch06.xhtml#ch6fig35)可能描述了一个搜索操作，在这个操作中，你正在查找特定的温度；这个操作可能非常常见，以至于你想生成某种关联数组（即哈希表）来提高其性能。同样，[图6-36](ch06.xhtml#ch6fig36)建议你希望拥有另一个快速查找表，以加速收集正午时录得的一组读数。每个图表都有其自己的上下文，它们并不相互冲突。
- en: '**6.5.5.9 Navigability**'
  id: totrans-239
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**6.5.5.9 可导航性**'
- en: In “Attribute Names” on [page 109](ch06.xhtml#page_109), I introduced the concept
    of adding attribute names to an association link. The suggestion was to place
    the name close to the class or object that contains the attribute (that is, that
    refers to the other class or object at the end of the association link). Although
    implicitly specifying the communication direction and attribute ownership this
    way works well for most simple diagrams, it can become confusing as your UML diagrams
    become more complex. The UML navigability feature remedies this problem.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第109页](ch06.xhtml#page_109)的“属性名称”中，我介绍了将属性名称添加到关联链接中的概念。建议将名称放置在包含该属性的类或对象附近（即，在关联链接的另一端引用其他类或对象）。尽管这种隐式指定通信方向和属性所有权的方式对于大多数简单图表非常有效，但随着UML图表变得更加复杂，这种方式可能会变得令人困惑。UML可导航性功能解决了这个问题。
- en: Navigability specifies the direction of information flow in a diagram (that
    is, how the data navigates through the system). By default, association links
    are navigable in both directions. This means that a class/object at one end of
    the link can access data fields or methods at the other end. It’s possible, however,
    to specify that information flows in only one direction along the association
    link.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 可导航性指定图表中信息流的方向（即数据如何在系统中流动）。默认情况下，关联链接是双向可导航的。这意味着链接一端的类/对象可以访问另一端的数据字段或方法。然而，也可以指定信息只在关联链接的一个方向上流动。
- en: 'To indicate navigability, place an arrowhead at the end of an association link
    to specify the direction of communication flow (you don’t need to place arrowheads
    on both ends of an association link to specify bidirectional communication). For
    example, in [Figure 6-37](ch06.xhtml#ch6fig37), the communication flows from the
    `poolMonitor` class or object to the `pHClass` class or object. This direction
    tells you two things: the `pHSensor` attribute is a member of the `poolMonitor`
    class or object, and the `pHClass` has no attributes that let it reference anything
    inside `poolMonitor`.'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 为了指示可导航性，可以在关联链接的末端放置箭头，以指定通信流的方向（你不需要在关联链接的两端都放置箭头来指定双向通信）。例如，在[图 6-37](ch06.xhtml#ch6fig37)中，通信流从`poolMonitor`类或对象流向`pHClass`类或对象。这个方向告诉你两件事：`pHSensor`属性是`poolMonitor`类或对象的成员，且`pHClass`没有属性可以引用`poolMonitor`内部的任何内容。
- en: '![image](Images/fig6-37.jpg)'
  id: totrans-243
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/fig6-37.jpg)'
- en: '*Figure 6-37: Navigability*'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 6-37：可导航性*'
- en: 'UML 2.*x* added a new symbol to explicitly indicate that communication doesn’t
    occur in a given direction: you place a small × on the association link near the
    side forbidding communication (see [Figure 6-38](ch06.xhtml#ch6fig38)).'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: UML 2.*x*新增了一个符号，用来明确表示某个方向上不发生通信：你可以在禁止通信的一侧的关联链接上放置一个小×（参见[图 6-38](ch06.xhtml#ch6fig38)）。
- en: '![image](Images/fig6-38.jpg)'
  id: totrans-246
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/fig6-38.jpg)'
- en: '*Figure 6-38: Explicit non-navigability*'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 6-38：显式非可导航性*'
- en: I think this clutters the diagram and makes it harder to read, so I stick with
    the default specification. You can decide for yourself which option to use.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 我认为这会使图表显得杂乱，阅读起来更困难，所以我坚持使用默认规范。你可以自行决定使用哪种选项。
- en: '**6.5.5.10 Changeability**'
  id: totrans-249
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**6.5.5.10 可变性**'
- en: The UML changeability feature allows you to specify whether a particular data
    set can be modified after its creation. In the history recording example from
    [Figure 6-34](ch06.xhtml#ch6fig34), once a temperature is recorded in the history
    database, you don’t want the system or a user to edit or delete that value. You
    can achieve this by adding the `{frozen}` constraint to the association link,
    as shown in [Figure 6-39](ch06.xhtml#ch6fig39).
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: UML的可变性特性允许你指定某个数据集在创建后是否可以修改。在[图 6-34](ch06.xhtml#ch6fig34)中的历史记录示例中，一旦温度值被记录在历史数据库中，你不希望系统或用户编辑或删除该值。你可以通过在关联链接上添加`{frozen}`约束来实现，如[图
    6-39](ch06.xhtml#ch6fig39)所示。
- en: '![image](Images/fig6-39.jpg)'
  id: totrans-251
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/fig6-39.jpg)'
- en: '*Figure 6-39: A {frozen} example*'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 6-39：一个{frozen}示例*'
- en: 'Now that you have a better understanding of the features of the first four
    relationship types, let’s turn to the final type: inheritance.'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经更好地理解了前四种关系类型的特点，让我们转向最后一种类型：继承。
- en: '***6.5.6 Class Inheritance Relationships***'
  id: totrans-254
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***6.5.6 类继承关系***'
- en: The inheritance relationship (also known as the *generalization relationship*
    in UML) is the strongest, or most tightly coupled, form of class relationships.
    Any change you make to a base class’s fields will have an immediate and dramatic
    effect on the child (inheriting) classes or objects.^([8](ch19_footnote.xhtml#ch06fn8))
    Inheritance is a considerably different relationship than dependency, association,
    aggregation, or composition. These other relationships describe how one class
    or object uses another class or object; inheritance describes how one class *includes*
    everything from another class.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 继承关系（在UML中也称为*泛化关系*）是最强的或最紧密耦合的类关系形式。你对基类字段所做的任何更改都会对子类（继承类）或对象产生直接且显著的影响。^([8](ch19_footnote.xhtml#ch06fn8))
    继承是一种与依赖、关联、聚合或组合不同的关系。这些其他关系描述了一个类或对象如何使用另一个类或对象；而继承描述了一个类如何*包含*另一个类的所有内容。
- en: For inheritance we use a line with a hollow arrowhead at one end. The arrowhead
    points at the base class (the general item), and the other end of the line connects
    to the inheriting (derived) class, as shown in [Figure 6-40](ch06.xhtml#ch6fig40).
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 对于继承关系，我们使用一条线，其中一端带有空心箭头。箭头指向基类（通用项），而线的另一端连接到继承类（派生类），如[图 6-40](ch06.xhtml#ch6fig40)所示。
- en: '![image](Images/fig6-40.jpg)'
  id: totrans-257
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/fig6-40.jpg)'
- en: '*Figure 6-40: Inheritance*'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 6-40：继承*'
- en: In this example, `spaMonitor` and `mainPoolMonitor` are *derived classes* that
    inherit all the fields of the base (ancestor) class `poolMonitor` (likely, these
    derived classes add new attributes and operations as well).
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，`spaMonitor`和`mainPoolMonitor`是*派生类*，继承了基类（祖先类）`poolMonitor`的所有字段（这些派生类很可能还会添加新的属性和操作）。
- en: The inheritance relationship is not like dependency, association, aggregation,
    or composition in that features such as multiplicity, roles, and navigability
    don’t apply.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 继承关系不同于依赖、关联、聚合或组合，因为像多重性、角色和可导航性这样的特征不适用。
- en: '**6.6 Objects**'
  id: totrans-261
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**6.6 对象**'
- en: 'You’ve seen two types of participants in all the diagrams thus far: *actors*
    and *classes*. Specifically, most items have been classes. However, from an object-oriented
    programming point of view, classes are merely data types, not actual data items
    that software can manipulate. An object is an instantiation of a class—the actual
    data object that maintains state within an application. In UML, you represent
    an object using a rectangle, just as you represent classes. The difference is
    that you specify an object name with its associated class name, and you underline
    the pair in the object diagram, as shown in [Figure 6-41](ch06.xhtml#ch6fig41).'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，你在所有的图示中看到了两种类型的参与者：*角色* 和 *类*。具体来说，大多数项目是类。然而，从面向对象编程的角度来看，类只是数据类型，并不是软件可以操作的实际数据项。对象是类的实例——在应用程序中维护状态的实际数据对象。在
    UML 中，你使用矩形表示一个对象，就像表示类一样。不同之处在于，你需要指定一个对象名称以及它关联的类名称，并在对象图中将这对名称下划线，如[图 6-41](ch06.xhtml#ch6fig41)所示。
- en: '![image](Images/fig6-41.jpg)'
  id: totrans-263
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/fig6-41.jpg)'
- en: '*Figure 6-41: An object*'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 6-41：一个对象*'
- en: '**6.7 For More Information**'
  id: totrans-265
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**6.7 更多信息**'
- en: 'Bremer, Michael. *The User Manual Manual: How to Research, Write, Test, Edit,
    and Produce a Software Manual*. Grass Valley, CA: UnTechnical Press, 1999\. A
    sample chapter is available at *[http://www.untechnicalpress.com/Downloads/UMM%20sample%20doc.pdf](http://www.untechnicalpress.com/Downloads/UMM%20sample%20doc.pdf)*.'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 'Bremer, Michael. *The User Manual Manual: How to Research, Write, Test, Edit,
    and Produce a Software Manual*. Grass Valley, CA: UnTechnical Press, 1999。可在 *[http://www.untechnicalpress.com/Downloads/UMM%20sample%20doc.pdf](http://www.untechnicalpress.com/Downloads/UMM%20sample%20doc.pdf)*
    获取样本章节。'
- en: 'Larman, Craig. *Applying UML and Patterns: An Introduction to Object-Oriented
    Analysis and Design and Iterative Development*. 3rd ed. Upper Saddle River, NJ:
    Prentice Hall, 2004.'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 'Larman, Craig. *Applying UML and Patterns: An Introduction to Object-Oriented
    Analysis and Design and Iterative Development*. 第3版. Upper Saddle River, NJ: Prentice
    Hall, 2004.'
- en: 'Miles, Russ, and Kim Hamilton. *Learning UML 2.0: A Pragmatic Introduction
    to UML*. Sebastopol, CA: O’Reilly Media, 2003.'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 'Miles, Russ, 和 Kim Hamilton. *Learning UML 2.0: A Pragmatic Introduction to
    UML*. Sebastopol, CA: O’Reilly Media, 2003.'
- en: 'Pender, Tom. *UML Bible*. Indianapolis: Wiley, 2003.'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 'Pender, Tom. *UML Bible*. Indianapolis: Wiley, 2003.'
- en: 'Pilone, Dan, and Neil Pitman. *UML 2.0 in a Nutshell: A Desktop Quick Reference*.
    2nd ed. Sebastopol, CA: O’Reilly Media, 2005.'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 'Pilone, Dan, 和 Neil Pitman. *UML 2.0 in a Nutshell: A Desktop Quick Reference*.
    第2版. Sebastopol, CA: O’Reilly Media, 2005.'
- en: 'Roff, Jason T. *UML: A Beginner’s Guide*. Berkeley, CA: McGraw-Hill Education,
    2003.'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 'Roff, Jason T. *UML: A Beginner’s Guide*. Berkeley, CA: McGraw-Hill Education,
    2003.'
- en: Tutorials Point. “UML Tutorial.” *[https://www.tutorialspoint.com/uml/](https://www.tutorialspoint.com/uml/)*.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: Tutorials Point. “UML教程。” *[https://www.tutorialspoint.com/uml/](https://www.tutorialspoint.com/uml/)*.
