- en: '**13'
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '**13'
- en: CONTAINERS**
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: '**容器**'
- en: '*Fixing bugs in `std::vector` is equal parts delight (it is the bestest data
    structure) and terror (if I mess it up, the world explodes).'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: '*修复`std::vector`中的bug既是喜悦（它是最棒的数据结构）又是恐惧（如果我搞砸了，世界就爆炸）。*'
- en: —Stephan T. Lavavej (Principal Developer, Visual C++ Libraries). Tweet dated
    3:11 am on August 22, 2016.*
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: —Stephan T. Lavavej（Visual C++库的首席开发人员）。2016年8月22日凌晨3:11的推文*
- en: '![Image](../images/common.jpg)'
  id: totrans-4
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/common.jpg)'
- en: The *standard template library* (*STL*) is the portion of the stdlib that provides
    containers and the algorithms to manipulate them, with iterators serving as the
    interface between the two. In the next three chapters, you’ll learn more about
    each of these components.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: '*标准模板库*（*STL*）是stdlib的一部分，提供容器以及操作容器的算法，迭代器作为两者之间的接口。在接下来的三章中，你将进一步了解这些组件的更多信息。'
- en: 'A *container* is a special data structure that stores objects in an organized
    way that follows specific access rules. There are three kinds of containers:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: '*容器*是一种特殊的数据结构，它以有序的方式存储对象，并遵循特定的访问规则。容器有三种类型：'
- en: Sequence containers store elements consecutively, as in an array.
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 序列容器按顺序存储元素，就像数组一样。
- en: Associative containers store sorted elements.
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 关联容器存储排序后的元素。
- en: Unordered associative containers store hashed objects.
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 无序关联容器存储哈希化对象。
- en: Associative and unordered associative containers offer rapid search for individual
    elements. All containers are RAII wrappers around their contained objects, so
    they manage the storage durations and lifetimes of the elements they own. Additionally,
    each container provides some set of member functions that perform various operations
    on the object collection.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 关联容器和无序关联容器提供快速的单个元素查找。所有容器都是RAII包装器，围绕它们包含的对象，因此它们管理元素的存储期限和生命周期。此外，每个容器都提供一些成员函数，用于对对象集合执行各种操作。
- en: Modern C++ programs use containers all the time. Which container you choose
    for a particular application depends on the required operations, the contained
    objects’ characteristics, and efficiencies under particular access patterns. This
    chapter surveys the vast container landscape covered between the STL and Boost.
    Because there are so many containers in these libraries, you’ll explore the most
    popular ones.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 现代C++程序总是使用容器。你为特定应用选择哪个容器取决于所需的操作、包含对象的特性以及在特定访问模式下的效率。本章将概述STL和Boost之间所涵盖的广泛容器领域。由于这些库中有如此多的容器，你将重点探索其中最流行的几种。
- en: '**Sequence Containers**'
  id: totrans-12
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**序列容器**'
- en: '*Sequence containers* are STL containers that allow sequential member access.
    That is, you can start from one end of the container and iterate through to the
    other end. But except for this commonality, sequence containers are a varied and
    motley crew. Some containers have a fixed length; others can shrink and grow as
    program needs dictate. Some allow indexing directly into the container, whereas
    you can only access others sequentially. Additionally, each sequence container
    has unique performance characteristics that make it desirable in some situations
    and undesirable in others.'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: '*序列容器*是STL容器，允许顺序访问成员。也就是说，你可以从容器的一端开始，迭代到另一端。但除了这一共同点，序列容器是一个多样化且形态各异的队伍。有些容器具有固定长度；而有些容器可以根据程序需求缩小或增大。有些容器允许直接索引进入容器，而其他容器只能顺序访问。此外，每个序列容器具有独特的性能特征，使得它在某些情况下具有优势，而在其他情况下则可能不适用。'
- en: Working with sequence containers should feel intuitive because you’ve been acquainted
    with a primitive one since “Arrays” on [page 42](ch02.xhtml#page_42), where you
    saw the built-in or “C-style” array `T[]`. You’ll begin the survey of sequence
    containers by looking at the built-in array’s more sophisticated, cooler younger
    brother `std::array`.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 使用序列容器应该是直观的，因为你自从在[第42页](ch02.xhtml#page_42)上看到内建的或“C风格”的数组`T[]`后，就已经接触过一个基本的容器。你将从更复杂、更酷的“弟弟”`std::array`开始探索序列容器。
- en: '***Arrays***'
  id: totrans-15
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***数组***'
- en: The STL provides `std::array` in the `<array>` header. An `array` is a sequential
    container that holds a fixed-size, contiguous series of elements. It combines
    the sheer performance and efficiency of built-in arrays with the modern conveniences
    of supporting copy/move construction/assignment, knowing its own size, providing
    bounds-checked member access, and other advanced features.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: STL 在 `<array>` 头文件中提供了 `std::array`。`array` 是一个顺序容器，包含固定大小的连续元素序列。它结合了内置数组的极高性能和效率，同时支持复制/移动构造/赋值，知道自身大小，提供边界检查成员访问等现代功能。
- en: You should use `array` instead of built-in arrays in virtually all situations.
    It supports almost all the same usage patterns as `operator[]` to access elements,
    so there aren’t many situations in which you’ll need a built-in array instead.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 在几乎所有情况下，你都应该使用 `array` 而不是内置数组。它支持与 `operator[]` 类似的几乎所有使用模式来访问元素，因此没有很多需要使用内置数组的情况。
- en: '**NOTE**'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*Boost also offers a `boost::array` in Boost Array’s `<boost/array.hpp>`. You
    shouldn’t need to use the Boost version unless you have a very old C++ tool chain.*'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: '*Boost 还在 Boost Array 的 `<boost/array.hpp>` 中提供了一个 `boost::array`。除非你使用的是非常旧的
    C++ 工具链，否则不需要使用 Boost 版本。*'
- en: '**Constructing**'
  id: totrans-20
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**构造**'
- en: 'The `array<`T, S > class template takes two template parameters:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: '`array<`T, S > 类模板接受两个模板参数：'
- en: The contained type T
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 包含的类型 T
- en: The fixed size of the array S
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数组 S 的固定大小
- en: You can construct an `array` and built-in arrays using the same rules. To summarize
    these rules from “Arrays” on [page 42](ch02.xhtml#page_42), the preferred method
    is to use braced initialization to construct an `array`. Braced initialization
    fills the `array` with the values contained in the braces and fills the remaining
    elements with zeros. If you omit initialization braces, the `array` contains uninitialized
    values depending on its storage duration. [Listing 13-1](ch13.xhtml#ch13ex01)
    illustrates braced initialization with several `array` declarations.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用相同的规则来构造 `array` 和内置数组。总结《数组》章节中[第 42 页](ch02.xhtml#page_42)的规则，推荐的方法是使用大括号初始化来构造
    `array`。大括号初始化将数组填充为大括号内的值，并将其余元素填充为零。如果省略初始化大括号，`array` 将根据其存储持续时间包含未初始化的值。[清单
    13-1](ch13.xhtml#ch13ex01)展示了几种 `array` 声明的大括号初始化示例。
- en: '[PRE0]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '*Listing 13-1: Initializing a `std::array`. You might get compiler warnings
    from `REQUIRE(local_array[0] != 0);` ➍, since `local_array` has uninitialized
    elements.*'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 13-1：初始化一个 `std::array`。你可能会收到来自 `REQUIRE(local_array[0] != 0);` ➍ 的编译器警告，因为
    `local_array` 包含未初始化的元素。*'
- en: You declare an `array` of 10 `int` objects called `static_array` with static
    storage duration ➊. You haven’t used braced initialization, but its elements initialize
    to zero anyway ➋, thanks to the initialization rules covered in “Arrays” on [page
    42](ch02.xhtml#page_42).
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 你声明了一个名为 `static_array` 的包含 10 个 `int` 对象的 `array`，它使用静态存储持续时间 ➊。你没有使用大括号初始化，但根据《数组》章节中[第
    42 页](ch02.xhtml#page_42)的初始化规则，它的元素仍然被初始化为零 ➋。
- en: Next, you try declaring another `array` of 10 `int` objects, this time with
    automatic storage duration ➌. Because you haven’t used braced initialization,
    `local_array` contains uninitialized elements (that have an extremely low probability
    of equaling zero ➍).
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，你尝试声明另一个包含 10 个 `int` 对象的 `array`，这次使用自动存储持续时间 ➌。因为你没有使用大括号初始化，`local_array`
    包含未初始化的元素（这些元素等于零的概率极低 ➍）。
- en: Finally, you use braced initialization to declare another `array` and to fill
    the first four elements ➎. All remaining elements get set to zero ➏.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，你使用大括号初始化声明另一个 `array` 并填充前四个元素 ➎。其余所有元素都被设置为零 ➏。
- en: '**Element Access**'
  id: totrans-30
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**元素访问**'
- en: 'The three main methods by which you can access arbitrary `array` elements are:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过三种主要方法访问任意的 `array` 元素：
- en: '`operator[]`'
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`operator[]`'
- en: '`at`'
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`at`'
- en: '`get`'
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`get`'
- en: 'The `operator[]` and `at` methods take a single `size_t` argument corresponding
    to the index of the desired element. The difference between these two lies in
    bounds checking: if the index argument is out of bounds, `at` will throw a `std::out_of_range`
    exception, whereas `operator[]` will cause undefined behavior. The function template
    `get` takes a template parameter of the same specification. Because it’s a template,
    the index must be known at compile time.'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: '`operator[]` 和 `at` 方法接受一个 `size_t` 类型的参数，表示所需元素的索引。这两者的区别在于边界检查：如果索引参数超出范围，`at`
    会抛出一个 `std::out_of_range` 异常，而 `operator[]` 会导致未定义行为。函数模板 `get` 接受一个与之规格相同的模板参数。由于它是一个模板，索引必须在编译时已知。'
- en: '**NOTE**'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*Recall from “The `size_t` Type” on [page 41](ch02.xhtml#page_41) that a `size_t`
    object guarantees that its maximum value is sufficient to represent the maximum
    size in bytes of all objects. It is for this reason that `operator[]` and `at`
    take a `size_t` rather than an `int`, which makes no such guarantee.*'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: '*回想一下在《`size_t`类型》一节中，位于[第41页](ch02.xhtml#page_41)的内容，`size_t`对象保证其最大值足以表示所有对象的最大字节大小。正因为如此，`operator[]`和`at`方法使用`size_t`而非`int`，后者并不做出此类保证。*'
- en: A major bonus of using `get` is that you get compile-time bounds checking, as
    illustrated in [Listing 13-2](ch13.xhtml#ch13ex02).
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`get`的一个重要优势是，你可以获得编译时的边界检查，正如[列表13-2](ch13.xhtml#ch13ex02)所示。
- en: '[PRE1]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '*Listing 13-2: Accessing elements of an `array`. Uncommenting `// fib[4] =
    5;`* ➍ *will cause undefined behavior, whereas uncommenting `// std::get<4>(fib);`*
    ➓ *will cause compilation failure.*'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表13-2：访问`array`元素。取消注释`// fib[4] = 5;`* ➍ *将导致未定义行为，而取消注释`// std::get<4>(fib);`*
    ➓ *将导致编译失败。*'
- en: You declare an array of length 4 called `fib` ➊. Using `operator[]` ➋ you can
    set elements and retrieve them ➌. The out of bounds write you’ve commented out
    would cause undefined behavior; there is no bounds checking with `operator[]`
    ➍.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 你声明了一个长度为4的数组`fib` ➊。使用`operator[]` ➋你可以设置元素并检索它们 ➌。你注释掉的越界写入将导致未定义行为；`operator[]`没有边界检查
    ➍。
- en: You can use `at` for the same read ➎ and write ➏ operations, and you can safely
    perform an out-of-bounds operation thanks to bounds checking ➐.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用`at`进行相同的读取 ➎ 和写入 ➏ 操作，并且可以安全地执行越界操作，因为有边界检查 ➐。
- en: Finally, you can use `std::get` to `set` ➑ and `get` ➒ elements. The `get` element
    also performs bounds checking, so `// std::get<4>(fib);` ➓ will fail to compile
    if uncommented.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，你可以使用`std::get`来`设置` ➑ 和`获取` ➒ 元素。`get`元素还会进行边界检查，因此如果取消注释，`// std::get<4>(fib);`
    ➓ 将无法编译。
- en: You’ve also have a `front` and a `back` method, which return references to the
    first and last elements of the array. You’ll get undefined behavior if you call
    one of these methods if the array has zero length, as [Listing 13-3](ch13.xhtml#ch13ex03)
    illustrates.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 你还有`front`和`back`方法，它们分别返回数组的第一个和最后一个元素的引用。如果数组长度为零，调用这些方法将导致未定义行为，正如[列表13-3](ch13.xhtml#ch13ex03)所示。
- en: '[PRE2]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '*Listing 13-3: Using the convenience methods `front` and `back` on a `std::array`*'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表13-3：在`std::array`上使用便捷方法`front`和`back`*'
- en: You can use the `front` and `back` methods to set ➊➍ and get ➋➎ the first and
    last elements of an `array`. Of course, `fib[0]` is identical to `fib.front()`
    ➌, and `fib[3]` is identical to `fib.back()` ➏. The `front()` and `back()` methods
    are simply convenience methods. Additionally, if you’re writing generic code,
    some containers will offer `front` and `back` but not `operator[]`, so it’s best
    to use the `front` and `back` methods.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用`front`和`back`方法来设置 ➊➍ 和获取 ➋➎ `array`的第一个和最后一个元素。当然，`fib[0]`与`fib.front()`
    ➌ 完全相同，`fib[3]`与`fib.back()` ➏ 完全相同。`front()`和`back()`方法只是便捷方法。此外，如果你在编写通用代码时，某些容器可能提供`front`和`back`，但不提供`operator[]`，因此最好使用`front`和`back`方法。
- en: '**Storage Model**'
  id: totrans-48
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**存储模型**'
- en: An `array` doesn’t make allocations; rather, like a built-in array, it contains
    all of its elements. This means copies will generally be expensive, because each
    constituent element needs to be copied. Moves can be expensive, depending on whether
    the underlying type of the `array` also has move construction and move assignment,
    which are relatively inexpensive.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: '`array`不进行内存分配；相反，它像内建数组一样，包含其所有元素。这意味着复制通常会很昂贵，因为每个组成元素都需要复制。移动可能会很昂贵，具体取决于`array`的底层类型是否也支持移动构造和移动赋值，而这些操作相对便宜。'
- en: 'Each `array` is just a built-in array underneath. In fact, you can extract
    a pointer to the first element of an `array` using four distinct methods:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 每个`array`底层其实就是一个内建数组。实际上，你可以通过四种不同的方法提取指向`array`第一个元素的指针：
- en: The go-to method is to use the `data` method. As advertised, this returns a
    pointer to the first element.
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 常用的方法是使用`data`方法。正如其宣传所说，它返回指向第一个元素的指针。
- en: The other three methods involve using the address-of operator `&` on the first
    element, which you can obtain using `operator[]`, `at`, and `front`.
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 其他三种方法涉及使用取地址操作符`&`在第一个元素上，这些元素可以通过`operator[]`、`at`和`front`获得。
- en: You should use `data`. If the `array` is empty, the address-of-based approaches
    will return undefined behavior.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该使用`data`。如果`array`为空，基于取地址操作的方法将返回未定义行为。
- en: '[Listing 13-4](ch13.xhtml#ch13ex04) illustrates how to obtain a pointer using
    these four methods.'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: '[列表13-4](ch13.xhtml#ch13ex04)展示了如何通过这四种方法获得指针。'
- en: '[PRE3]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '*Listing 13-4: Obtaining a pointer to the first element of a `std::array`*'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: '*代码清单 13-4：获取`std::array`第一个元素的指针*'
- en: After initializing the `array color`, you obtain a pointer to the first element,
    the letter `o`, using the `data` method ➊. When you dereference the resulting
    `color_ptr`, you obtain the letter `o` as expected ➋. This pointer is identical
    to the pointer obtained from the `address-of-`plus-`front` ➌, -`at` ➍, and -`operator[]`
    ➎ approaches.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 初始化`array color`后，你可以通过`data`方法 ➊ 获取指向第一个元素的指针，即字母`o`。当你解引用得到的`color_ptr`时，你会如预期得到字母`o`
    ➋。这个指针与通过`address-of-`加`front` ➌、`at` ➍ 和`operator[]` ➎ 方法获得的指针是相同的。
- en: To conclude arrays, you can query the size of an `array` using either the `size`
    or `max_size` methods. (These are identical for an `array`.) Because an `array`
    has a fixed size, these method’s values are static and known at compile time.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 总结数组时，你可以使用`size`或`max_size`方法查询`array`的大小。（这两个方法对于`array`来说是相同的。）因为`array`的大小是固定的，这些方法的值在编译时就已经确定。
- en: '**A Crash Course in Iterators**'
  id: totrans-59
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**迭代器速成课程**'
- en: The interface between containers and algorithms is the iterator. An iterator
    is a type that knows the internal structure of a container and exposes simple,
    pointer-like operations to a container’s elements. [Chapter 14](ch14.xhtml#ch14)
    is dedicated entirely to iterators, but you need to know the very basics here
    so you can explore how to use iterators to manipulate containers and how containers
    expose iterators to users.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 容器与算法之间的接口就是迭代器。迭代器是一种知道容器内部结构的类型，并向容器元素暴露类似指针的简单操作。[第14章](ch14.xhtml#ch14)专门讲解迭代器，但你在这里需要了解一些基本知识，以便你能够探索如何使用迭代器操作容器，以及容器如何向用户暴露迭代器。
- en: 'Iterators come in various flavors, but they all support at least the following
    operations:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 迭代器有不同的种类，但它们都至少支持以下操作：
- en: Get the current element (`operator*`)
  id: totrans-62
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 获取当前元素（`operator*`）
- en: Go to the next element (`operator++`)
  id: totrans-63
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 转到下一个元素（`operator++`）
- en: Assign an iterator equal to another iterator (`operator=`)
  id: totrans-64
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将一个迭代器赋值给另一个迭代器（`operator=`）
- en: You can extract iterators from all STL containers (including `array`) using
    their `begin` and `end` methods. The `begin` method returns an iterator pointing
    to the first element, and the `end` method returns a pointer to one element past
    the last element. [Figure 13-1](ch13.xhtml#ch13fig01) illustrates where the `begin`
    and `end` iterators point in an array of three elements.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过所有STL容器（包括`array`）的`begin`和`end`方法提取迭代器。`begin`方法返回一个指向第一个元素的迭代器，而`end`方法返回指向最后一个元素之后的元素的指针。[图
    13-1](ch13.xhtml#ch13fig01)展示了`begin`和`end`迭代器在一个包含三个元素的数组中的指向位置。
- en: '![image](../images/fig13_1.jpg)'
  id: totrans-66
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/fig13_1.jpg)'
- en: '*Figure 13-1: A half-open range over an `array` of three elements*'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 13-1：一个包含三个元素的`array`的半开区间*'
- en: The arrangement in [Figure 13-1](ch13.xhtml#ch13fig01), where `end()` points
    after the last element, is called a *half-open range*. It might seem counterintuitive
    at first—why not have a closed range where `end()` points to the last element—but
    a half-open range has some advantages. For example, if a container is empty, `begin()`
    will return the same value as `end()`. This allows you to know that, regardless
    of whether the container is empty, if the iterator equals `end()`, you’ve traversed
    the container.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 在[图 13-1](ch13.xhtml#ch13fig01)中的排列，其中`end()`指向最后一个元素之后的位置，称为*半开区间*。这可能一开始看起来不太直观——为什么不使用闭区间，让`end()`指向最后一个元素——但半开区间有其优势。例如，如果一个容器为空，`begin()`会返回与`end()`相同的值。这让你能够知道，无论容器是否为空，只要迭代器等于`end()`，就表示你已经遍历了容器。
- en: '[Listing 13-5](ch13.xhtml#ch13ex05) illustrates what happens with half-open
    range iterators and empty containers.'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: '[代码清单 13-5](ch13.xhtml#ch13ex05)展示了半开区间迭代器和空容器的行为。'
- en: '[PRE4]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '*Listing 13-5: With an empty `array`, the `begin` iterator equals the `end`
    iterator.*'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: '*代码清单 13-5：对于一个空的`array`，`begin`迭代器等于`end`迭代器。*'
- en: Here, you construct an empty array `e` ➊, and the `begin` ➋ and `end` ➌ iterators
    are equal.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，你构造了一个空数组`e` ➊，并且`begin` ➋ 和`end` ➌ 迭代器是相等的。
- en: '[Listing 13-6](ch13.xhtml#ch13ex06) examines how to use iterators to perform
    pointer-like operations over a non-empty `array`.'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: '[代码清单 13-6](ch13.xhtml#ch13ex06)展示了如何使用迭代器在一个非空的`array`上执行类似指针的操作。'
- en: '[PRE5]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '*Listing 13-6: Basic `array` iterator operations*'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: '*代码清单 13-6：基本的`array`迭代器操作*'
- en: The `array easy_as` contains the elements 1, 2, and 3 ➊. You invoke `begin`
    on `easy_as` to obtain an iterator `iter` pointing to the first element ➋. The
    dereference operator yields the first element 1, because this is the first element
    in the `array` ➌. Next, you increment `iter` so it points to the next element
    ➍. You continue in this fashion until you reach the last element ➎. Incrementing
    the pointer one last time puts you 1 past the last element ➏, so `iter` equals
    `easy_as.end()`, indicating that you’ve traversed the `array` ➐.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: '`array easy_as` 包含元素 1、2 和 3 ➊。你在 `easy_as` 上调用 `begin` 来获取指向第一个元素的迭代器 `iter`
    ➋。解引用操作符返回第一个元素 1，因为这是 `array` 中的第一个元素 ➌。接下来，你递增 `iter`，使其指向下一个元素 ➍。你继续以这种方式进行，直到到达最后一个元素
    ➎。最后一次递增指针会让你超出最后一个元素 ➏，因此 `iter` 等于 `easy_as.end()`，表示你已经遍历了整个 `array` ➐。'
- en: Recall from “Range Expressions” on [page 235](ch08.xhtml#page_235) that you
    can build your own types for use in range expressions by exposing a `begin` and
    an `end` method, as implemented in the `FibonacciIterator` in [Listing 8-29](ch08.xhtml#ch08ex29).
    Well, containers already do all this work for you, meaning you can use any STL
    container as a range expression. [Listing 13-7](ch13.xhtml#ch13ex07) illustrates
    by iterating over an `array`.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 回忆一下在《范围表达式》章节中提到的内容（见 [第 235 页](ch08.xhtml#page_235)），你可以通过暴露 `begin` 和 `end`
    方法来构建自定义类型以用于范围表达式，就像在[列表 8-29](ch08.xhtml#ch08ex29)中的 `FibonacciIterator` 一样。实际上，容器已经为你做了所有这些工作，这意味着你可以将任何
    STL 容器作为范围表达式使用。[列表 13-7](ch13.xhtml#ch13ex07)通过遍历一个 `array` 来展示这一点。
- en: '[PRE6]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '*Listing 13-7: Range-based `for` loops and `array`s*'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 13-7：基于范围的 `for` 循环和 `array`s*'
- en: You initialize an `array` ➊ and a `sum` variable ➋. Because `array` is a valid
    range, you can use it in a ranged-based `for` loop ➌. This enables you to accumulate
    the `sum` of each `element` ➍.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 你初始化了一个 `array` ➊ 和一个 `sum` 变量 ➋。因为 `array` 是一个有效的范围，你可以在基于范围的 `for` 循环中使用它
    ➌。这使你能够累加每个 `element` 的 `sum` ➍。
- en: '**A Partial List of Supported Operations**'
  id: totrans-81
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**支持的部分操作列表**'
- en: '[Table 13-1](ch13.xhtml#ch13tab01) provides a partial list of `array` operations.
    In this table, `a`, `a1`, and `a2` are of type `std::array<T, S>`, `t` is of type
    `T`, `S` is the fixed length of the array, and `i` is of type `size_t`.'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: '[表 13-1](ch13.xhtml#ch13tab01)提供了部分`array`操作的列表。在此表中，`a`、`a1`和`a2`的类型为`std::array<T,
    S>`，`t`的类型为`T`，`S`是数组的固定长度，`i`的类型为`size_t`。'
- en: '**Table 13-1:** A Partial List of `std::array` Operations'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: '**表 13-1：** `std::array` 操作的部分列表'
- en: '| **Operation** | **Notes** |'
  id: totrans-84
  prefs: []
  type: TYPE_TB
  zh: '| **操作** | **说明** |'
- en: '| `array<`T`,` S`>{` ... `}` | Performs braced initialization of a newly constructed
    array. |'
  id: totrans-85
  prefs: []
  type: TYPE_TB
  zh: '| `array<`T`,` S`>{` ... `}` | 执行新构建数组的花括号初始化。 |'
- en: '| `~array` | Destructs all elements contained by the array. |'
  id: totrans-86
  prefs: []
  type: TYPE_TB
  zh: '| `~array` | 析构数组包含的所有元素。 |'
- en: '| a1 `=` a2 | Copy-assigns all the members of a1 with the members of a2. |'
  id: totrans-87
  prefs: []
  type: TYPE_TB
  zh: '| a1 `=` a2 | 将 a2 的所有成员复制赋值给 a1 的成员。 |'
- en: '| a.`at`(i) | Returns a reference to element i of a. Throws `std::out_of_range`
    if out of bounds. |'
  id: totrans-88
  prefs: []
  type: TYPE_TB
  zh: '| a.`at`(i) | 返回 a 的第 i 个元素的引用。如果越界，则抛出`std::out_of_range`。 |'
- en: '| a`[`i`]` | Returns a reference to element i of a. Undefined behavior if out
    of bounds. |'
  id: totrans-89
  prefs: []
  type: TYPE_TB
  zh: '| a`[`i`]` | 返回 a 的第 i 个元素的引用。如果越界，行为未定义。 |'
- en: '| `get<`i`>``(`a`)` | Returns a reference to element i of a. Fails to compile
    if out of bounds. |'
  id: totrans-90
  prefs: []
  type: TYPE_TB
  zh: '| `get<`i`>``(`a`)` | 返回 a 的第 i 个元素的引用。如果越界，编译失败。 |'
- en: '| a`.front()` | Returns a reference to first element. |'
  id: totrans-91
  prefs: []
  type: TYPE_TB
  zh: '| a`.front()` | 返回对第一个元素的引用。 |'
- en: '| a`.back()` | Returns a reference to last element. |'
  id: totrans-92
  prefs: []
  type: TYPE_TB
  zh: '| a`.back()` | 返回对最后一个元素的引用。 |'
- en: '| a`.data()` | Returns a raw pointer to the first element if the array is non-empty.
    For empty arrays, returns a valid but non-dereferencable pointer. |'
  id: totrans-93
  prefs: []
  type: TYPE_TB
  zh: '| a`.data()` | 返回指向第一个元素的原始指针，如果数组非空。对于空数组，返回一个有效但不可解引用的指针。 |'
- en: '| a`.empty()` | Returns `true` if the array’s size is zero; otherwise `false`.
    |'
  id: totrans-94
  prefs: []
  type: TYPE_TB
  zh: '| a`.empty()` | 如果数组的大小为零，则返回`true`；否则返回`false`。 |'
- en: '| a.`size()` | Returns the size of the array. |'
  id: totrans-95
  prefs: []
  type: TYPE_TB
  zh: '| a.`size()` | 返回数组的大小。 |'
- en: '| a`.max_size()` | Identical to a`.size()`. |'
  id: totrans-96
  prefs: []
  type: TYPE_TB
  zh: '| a`.max_size()` | 与 a`.size()` 相同。 |'
- en: '| a.`fill(`t`)` | Copy-assigns t to every element of a. |'
  id: totrans-97
  prefs: []
  type: TYPE_TB
  zh: '| a.`fill(`t`)` | 将 t 复制赋值给 a 的每个元素。 |'
- en: '| a1`.swap(`a2`)``swap(`a1`,` a2`)` | Exchanges each element of a1 with those
    of a2. |'
  id: totrans-98
  prefs: []
  type: TYPE_TB
  zh: '| a1`.swap(`a2`)``swap(`a1`,` a2`)` | 交换 a1 和 a2 中的每个元素。 |'
- en: '| a`.begin()` | Returns an iterator pointing to the first element. |'
  id: totrans-99
  prefs: []
  type: TYPE_TB
  zh: '| a`.begin()` | 返回指向第一个元素的迭代器。 |'
- en: '| a`.cbegin()` | Returns a `const` iterator pointing to the first element.
    |'
  id: totrans-100
  prefs: []
  type: TYPE_TB
  zh: '| a`.cbegin()` | 返回指向第一个元素的`const`迭代器。 |'
- en: '| a`.end()` | Returns an iterator pointing to 1 past the last element. |'
  id: totrans-101
  prefs: []
  type: TYPE_TB
  zh: '| a`.end()` | 返回指向最后一个元素后一个位置的迭代器。 |'
- en: '| a`.cend()` | Returns a `const` iterator pointing to 1 past the last element.
    |'
  id: totrans-102
  prefs: []
  type: TYPE_TB
  zh: '| a`.cend()` | 返回指向最后一个元素之后的 `const` 迭代器。 |'
- en: '| a1 `==` a2a1 `!=` a2a1 `>` a2a1 `>=` a2a1 `<` a2a1 `<=` a2 | Equal if all
    elements are equal.Greater than/less than comparisons proceed from first element
    to last. |'
  id: totrans-103
  prefs: []
  type: TYPE_TB
  zh: '| a1 `==` a2a1 `!=` a2a1 `>` a2a1 `>=` a2a1 `<` a2a1 `<=` a2 | 如果所有元素相等，则相等。大于/小于比较从第一个元素到最后一个元素进行。
    |'
- en: '**NOTE**'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*The partial operations in [Table 13-1](ch13.xhtml#ch13tab01) function as quick,
    reasonably comprehensive references. For gritty details, refer to the freely available
    online references [https://cppreference.com/](https://cppreference.com/) and [http://cplusplus.com/](http://cplusplus.com/),
    as well as Chapter 31 of The C++ Programming Language, 4th Edition, by Bjarne
    Stroustrup and [Chapters 7](ch07.xhtml#ch07), [8](ch08.xhtml#ch08), and [12](ch12.xhtml#ch12)
    of The C++ Standard Library, 2nd Edition, by Nicolai M. Josuttis.*'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: '*[Table 13-1](ch13.xhtml#ch13tab01) 中的部分操作可以作为快速且合理全面的参考。有关详细信息，请参考免费在线文献 [https://cppreference.com/](https://cppreference.com/)
    和 [http://cplusplus.com/](http://cplusplus.com/)，以及 Bjarne Stroustrup 的《C++ 程序设计语言》第
    4 版的第 31 章，以及 Nicolai M. Josuttis 的《C++ 标准库》第二版中的第 7 章](ch07.xhtml#ch07)，[8](ch08.xhtml#ch08)
    和 [12](ch12.xhtml#ch12) 。*'
- en: '***Vectors***'
  id: totrans-106
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***Vectors***'
- en: The `std::vector` available in the STL’s `<vector>` header is a sequential container
    that holds a dynamically sized, contiguous series of elements. A `vector` manages
    its storage dynamically, requiring no outside help from the programmer.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 在 STL 的 `<vector>` 头文件中，`std::vector` 是一个顺序容器，存储着一个动态大小的、连续的元素序列。`vector` 动态管理其存储，不需要程序员的外部帮助。
- en: The `vector` is the workhorse of the sequential-data-structure stable. For a
    very modest overhead, you gain substantial flexibility over the `array`. Plus,
    `vector` supports almost all of the same operations as an `array` and adds a slew
    of others. If you have a fixed number of elements on hand, you should strongly
    consider an `array` because you’ll get some small reductions in overhead versus
    a `vector`. In all other situations, your go-to sequential container is the `vector`.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: '`vector` 是顺序数据结构中的工作马。仅有少量开销，你就能获得比 `array` 更多的灵活性。而且，`vector` 支持几乎与 `array`
    相同的所有操作，并且增加了许多其他功能。如果你手头有固定数量的元素，你应该强烈考虑使用 `array`，因为它相对于 `vector` 会有一些小的开销减少。在所有其他情况下，你的首选顺序容器是
    `vector`。'
- en: '**NOTE**'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*The Boost Container library also contains a `boost::container::vector` in
    the `<boost/container/vector.hpp>` header.*'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: '*Boost 容器库还包含了一个位于 `<boost/container/vector.hpp>` 头文件中的 `boost::container::vector`。*'
- en: '**Constructing**'
  id: totrans-111
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**构造**'
- en: The class template `std::vector<T, Allocator>` takes two template parameters.
    The first is the contained type `T`, and the second is the allocator type `Allocator`,
    which is optional and defaults to `std::allocator<T>`.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 类模板 `std::vector<T, Allocator>` 接受两个模板参数。第一个是元素类型 `T`，第二个是分配器类型 `Allocator`，这是可选的，默认值为
    `std::allocator<T>`。
- en: You have much more flexibility in constructing `vector`s than you do with arrays.
    A `vector` supports user-defined allocators because vectors need to allocate dynamic
    memory. You can default construct a `vector` so it contains no elements. You might
    want to construct an empty vector so you can fill it with a variable number of
    elements depending on what happens during runtime. [Listing 13-8](ch13.xhtml#ch13ex08)
    illustrates default constructing a `vector` and checking that it contains no elements.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 相比数组，你在构造 `vector` 时具有更大的灵活性。`vector` 支持用户定义的分配器，因为 `vector` 需要动态分配内存。你可以默认构造一个不包含任何元素的
    `vector`。你可能想构造一个空的 `vector`，以便根据运行时的情况填充一个可变数量的元素。[Listing 13-8](ch13.xhtml#ch13ex08)
    展示了默认构造一个 `vector` 并检查它是否包含元素。
- en: '[PRE7]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '*Listing 13-8: A `vector` supports default construction.*'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: '*Listing 13-8：`vector` 支持默认构造。*'
- en: You declare a `vector` containing elements of type `const char*` ➊ called `vec`.
    Because it’s been default constructed ➋, the `vector` contains no elements, and
    the `empty` method returns `true` ➌.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 你声明了一个包含 `const char*` 类型元素的 `vector` ➊，名为 `vec`。由于它是默认构造的 ➋，因此 `vector` 不包含任何元素，`empty`
    方法返回 `true` ➌。
- en: You can use braced initialization with a `vector`. Similar to how you brace
    initialize an array, this fills the vector with the specified elements, as [Listing
    13-9](ch13.xhtml#ch13ex09) illustrates.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用花括号初始化来初始化 `vector`。类似于如何用花括号初始化数组，这种方式会用指定的元素填充 `vector`，如 [Listing 13-9](ch13.xhtml#ch13ex09)
    所示。
- en: '[PRE8]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '*Listing 13-9: A `vector` supports braced initializers.*'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: '*Listing 13-9：`vector` 支持花括号初始化。*'
- en: Here, you construct a `vector` called `fib` and use braced initializers ➊. After
    initialization, the `vector` contains the five elements 1, 1, 2, 3, and 5 ➋.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，你构造了一个名为`fib`的`vector`并使用大括号初始化器 ➊。初始化后，`vector`包含五个元素1、1、2、3和5 ➋。
- en: If you want to populate a `vector` with many identical values, you can use one
    of the *fill constructors*. To fill construct a `vector`, you first pass a `size_t`
    corresponding to the number of elements you want to fill. Optionally, you can
    pass a `const` reference to an object to copy. Sometimes you want to initialize
    all your elements to the same value, for example, to keep track of counts related
    to particular indices. You might also have a `vector` of some user-defined type
    that keeps track of program state, and you might need to keep track of such state
    by index.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想用许多相同的值来填充一个`vector`，你可以使用其中一个*填充构造函数*。要进行填充构造`vector`，你首先传入一个`size_t`值，表示你要填充的元素数量。你还可以选择传入一个`const`引用对象，以便进行复制。有时，你可能希望将所有元素初始化为相同的值，例如跟踪与特定索引相关的计数。你可能还有一个用于跟踪程序状态的某个用户定义类型的`vector`，你可能需要通过索引来追踪这些状态。
- en: Unfortunately, the general rule to use braced initialization to construct objects
    breaks down here. With `vector`, you must use parentheses to invoke these constructors.
    To the compiler, `std::vector<int>{ 99, 100 }` specifies an initialization list
    with the elements 99 and 100, which will construct a vector with the two elements
    99 and 100\. What if you want a vector with 99 copies of the number 100?
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，使用大括号初始化构造对象的通用规则在这里失效了。对于`vector`，你必须使用圆括号来调用这些构造函数。对于编译器来说，`std::vector<int>{
    99, 100 }`指定了一个包含99和100两个元素的初始化列表，这将构造一个包含99和100两个元素的`vector`。如果你想要一个包含99个100的副本的`vector`，该怎么办呢？
- en: In general, the compiler will try very hard to treat the initializer list as
    elements to fill the vector with. You can try to memorize the rules (refer to
    Item 7 of *Effective Modern C++* by Scott Meyers) or just commit to using parentheses
    for stdlib container constructors.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，编译器会尽力将初始化列表视为用于填充`vector`的元素。你可以尝试记住这些规则（参考Scott Meyers的《*Effective Modern
    C++*》第7条）或者干脆决定在使用标准库容器构造函数时总是使用圆括号。
- en: '[Listing 13-10](ch13.xhtml#ch13ex10) highlights the initializer list/braced
    initialization general rule for STL containers.'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: '[清单 13-10](ch13.xhtml#ch13ex10)展示了STL容器的一般初始化列表/大括号初始化规则。'
- en: '[PRE9]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '*Listing 13-10: A `vector` supports braced initializers and fill constructors.*'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 13-10：一个`vector`支持大括号初始化器和填充构造函数。*'
- en: 'The first example uses braced initialization to construct a vector with two
    elements ➊: 5 at index 0 ➋ and 9 at index 1 ➌. The second example uses parentheses
    to invoke the fill constructor ➍, which fills the vector with five copies of the
    number 9, so the first ➎ and last ➏ elements are both 9.'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个示例使用大括号初始化构造了一个包含两个元素的`vector` ➊：索引0处的5 ➋ 和索引1处的9 ➌。第二个示例使用圆括号调用填充构造函数 ➍，该构造函数将`vector`填充为五个9的副本，因此第一个
    ➎ 和最后一个 ➏ 元素都是9。
- en: '**NOTE**'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*This notational clash is unfortunate and isn’t the result of some well-thought-out
    trade-off. The reasons are purely historical and related to backward compatibility.*'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: '*这种符号冲突是不幸的，并非经过深思熟虑的权衡结果。其原因纯粹是历史原因，并与向后兼容性相关。*'
- en: You can also construct `vector`s from a half-open range by passing in the `begin`
    and `end` iterators of the range you want to copy. In various programming contexts,
    you might want to splice out a subset of some range and copy it into a `vector`
    for further processing. For example, you could construct a `vector` that copies
    all the elements contained by an `array`, as in [Listing 13-11](ch13.xhtml#ch13ex11).
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以通过传入目标范围的`begin`和`end`迭代器来从半开区间构造`vector`。在各种编程上下文中，你可能希望从某个范围中提取出一部分子集并将其复制到`vector`中以进行进一步处理。例如，你可以构造一个`vector`，复制一个`array`中包含的所有元素，就像在[清单
    13-11](ch13.xhtml#ch13ex11)中展示的那样。
- en: '[PRE10]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '*Listing 13-11: Constructing a `vector` from a range*'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 13-11：从范围构造一个`vector`*'
- en: You construct the array `fib_arr` with five elements ➊. To construct the vector
    `fib_vec` with the elements contained in `fib_arr`, you invoke the `begin` and
    `end` methods on `fib_arr` ➋. The resulting `vector` has copies of the `array`’s
    elements ➌ and has the same `size` ➍.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 你使用五个元素构造了数组`fib_arr` ➊。要使用`fib_arr`中的元素构造`fib_vec`，你需要调用`fib_arr`的`begin`和`end`方法
    ➋。结果是，构造的`vector`包含了`array`的元素副本 ➌，并且具有相同的`size` ➍。
- en: At a high level, you can think of this constructor as taking pointers to the
    beginning and the end of some target sequence. It will then copy that target sequence.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 从高层次来看，你可以把这个构造函数理解为接受指向某个目标序列的开始和结束的指针。它将会复制这个目标序列。
- en: '**Move and Copy Semantics**'
  id: totrans-135
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**移动和复制语义**'
- en: With `vector`s, you have full copy/move construction/assignment support. Any
    `vector` copy operation is potentially very expensive, because these are element-wise
    or deep copies. Move operations, on the other hand, are usually very fast, because
    the contained elements reside in dynamic memory and the moved-from `vector` can
    simply pass ownership to the moved-into `vector`; there’s no need to move the
    contained elements.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`vector`时，你可以完全支持复制/移动构造和赋值。任何`vector`的复制操作可能非常昂贵，因为这些是逐元素的或深度复制。而移动操作通常非常快速，因为包含的元素位于动态内存中，移动前的`vector`可以简单地将所有权转移到移动后的`vector`；不需要移动包含的元素。
- en: '**Element Access**'
  id: totrans-137
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**元素访问**'
- en: 'A `vector` supports most of the same element access operations as `array`:
    `at`, `operator[]`, `front`, `back`, and `data`.'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: '`vector`支持与`array`相同的大多数元素访问操作：`at`、`operator[]`、`front`、`back`和`data`。'
- en: As with an `array`, you can query the number of contained elements in a `vector`
    using the `size` method. This method’s return value can vary at runtime. You can
    also determine whether a `vector` contains any elements with the `empty` method,
    which returns `true` if the `vector` contains no elements; otherwise, it returns
    `false`.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 与`array`一样，你可以使用`size`方法查询`vector`中包含的元素数量。该方法的返回值可能在运行时发生变化。你还可以使用`empty`方法来确定`vector`是否包含任何元素，如果`vector`不包含元素，它返回`true`；否则返回`false`。
- en: '**Adding Elements**'
  id: totrans-140
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**添加元素**'
- en: You can use various methods to insert elements into a `vector`. If you want
    to replace all the elements in a `vector`, you can use the `assign` method, which
    takes an initialization list and replaces all the existing elements. If needed,
    the `vector` will resize to accommodate a larger list of elements, as [Listing
    13-12](ch13.xhtml#ch13ex12) illustrates.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用各种方法向`vector`中插入元素。如果你想替换`vector`中的所有元素，可以使用`assign`方法，该方法接受一个初始化列表并替换所有现有元素。如果需要，`vector`将调整大小以容纳更多的元素，如[示例
    13-12](ch13.xhtml#ch13ex12)所示。
- en: '[PRE11]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '*Listing 13-12: The `assign` method of a `vector`*'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: '*示例 13-12：`vector`的`assign`方法*'
- en: Here, you construct a `vector` ➊ with seven elements ➋. When you assign a new,
    smaller initializer list ➌, all the elements get replaced ➍, and the vector’s
    `size` updates to reflect the new contents ➎.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，你构造了一个包含七个元素的`vector` ➊。当你赋值一个新的、更小的初始化列表 ➌时，所有元素都会被替换 ➍，并且`vector`的`size`会更新，以反映新的内容
    ➎。
- en: 'If you want to insert a single new element into a vector, you can use the `insert`
    method, which expects two arguments: an iterator and an element to insert. It
    will insert a copy of the given element just before the existing element pointed
    to by the iterator, as shown in [Listing 13-13](ch13.xhtml#ch13ex13).'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想向`vector`中插入一个单一的新元素，可以使用`insert`方法，该方法需要两个参数：一个迭代器和一个要插入的元素。它会在迭代器指向的现有元素之前插入给定元素的副本，如[示例
    13-13](ch13.xhtml#ch13ex13)所示。
- en: '[PRE12]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '*Listing 13-13: The `insert` method of a `vector`*'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: '*示例 13-13：`vector`的`insert`方法*'
- en: You initialize a vector with three zeros ➊ and generate an iterator pointing
    to the third element of `zeros` ➋. Next, you insert the value 10 immediately before
    the third element by passing the iterator and the value 10 ➌. The third element
    of `zeros` is now 10 ➍. The `zeros` vector now contains four elements ➎.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 你用三个零初始化了一个`vector` ➊，并生成了一个指向`zeros`第三个元素的迭代器 ➋。接下来，你通过传递迭代器和值10来将值10插入到第三个元素之前
    ➌。现在，`zeros`的第三个元素是10 ➍。`zeros`向量现在包含四个元素 ➎。
- en: 'Any time you use `insert`, existing iterators become invalid. For example,
    in [Listing 13-13](ch13.xhtml#ch13ex13) you must not reuse `third_element`: the
    vector could have resized and relocated in memory, leaving the old iterator dangling
    in garbage memory.'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 每次使用`insert`时，现有的迭代器都会变得无效。例如，在[示例 13-13](ch13.xhtml#ch13ex13)中，你不能重新使用`third_element`：`vector`可能已经重新调整大小并在内存中重新定位，导致旧的迭代器悬挂在垃圾内存中。
- en: To insert an element to the end of a `vector`, you use the `push_back` method.
    Unlike `insert`, `push_back` doesn’t require an iterator argument. You simply
    provide the element to copy into the `vector`, as shown in [Listing 13-14](ch13.xhtml#ch13ex14).
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 要将一个元素插入到`vector`的末尾，可以使用`push_back`方法。与`insert`不同，`push_back`不需要迭代器作为参数。只需提供要复制到`vector`中的元素，如[示例
    13-14](ch13.xhtml#ch13ex14)所示。
- en: '[PRE13]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '*Listing 13-14: The `push_back` method of a `vector`*'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: '*示例 13-14：`vector`的`push_back`方法*'
- en: Again, you initialize a `vector` with three zeros ➊, but this time you insert
    the element 10 to the back of the `vector` using the `push_back` method ➋. The
    `vector` now contains four elements, the last of which equals 10 ➌.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 再次地，你初始化了一个包含三个零的`vector` ➊，但这次你使用`push_back`方法将元素10插入到`vector`的末尾 ➋。`vector`现在包含四个元素，最后一个元素是10
    ➌。
- en: You can construct new elements in place using the `emplace` and `emplace_back`
    methods. The `emplace` method is a variadic template that, like `insert`, accepts
    an iterator as its first argument. The remaining arguments get forwarded to the
    appropriate constructor. The `emplace_back` method is also a variadic template,
    but like `push_back`, it doesn’t require an iterator. It accepts any number of
    arguments and forwards those to the appropriate constructor. [Listing 13-15](ch13.xhtml#ch13ex15)
    illustrates these two methods by emplacing a few `pair`s into a `vector`.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用`emplace`和`emplace_back`方法在原地构造新元素。`emplace`方法是一个变参模板，像`insert`一样，它将一个迭代器作为第一个参数。其余的参数将被转发到适当的构造函数。`emplace_back`方法也是一个变参模板，但像`push_back`一样，它不需要迭代器。它接受任意数量的参数，并将这些参数转发到适当的构造函数。[列表13-15](ch13.xhtml#ch13ex15)通过将一些`pair`添加到`vector`中来展示这两种方法。
- en: '[PRE14]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '*Listing 13-15: The `emplace_back` and `emplace` methods of a `vector`*'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表13-15：`vector`的`emplace_back`和`emplace`方法*'
- en: 'Here, you default construct a `vector` containing `pair`s of `int`s ➊. Using
    the `emplace_back` method, you push three pairs onto the vector: 2, 30 ➋; 3, 20
    ➌; and 4, 15 ➍. These values get forwarded directly to the constructor of `pair`,
    which gets constructed in place. Next, you use `emplace` to insert a new `pair`
    at the beginning of the vector by passing the result of `factors.begin()` as the
    first argument ➎. This causes all the elements in the vector to shift down to
    make room for the new `pair` (1 ➏, 60 ➐).'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，你默认构造了一个包含`int`类型`pair`的`vector` ➊。使用`emplace_back`方法，你将三个`pair`推入`vector`中：2，30
    ➋；3，20 ➌；以及4，15 ➍。这些值直接传递给`pair`的构造函数，从而在原地构造了`pair`。接着，你使用`emplace`方法通过传递`factors.begin()`的结果作为第一个参数，向`vector`的开头插入一个新的`pair`
    ➎。这会导致`vector`中的所有元素向下移动，为新的`pair`腾出空间（1 ➏，60 ➐）。
- en: '**NOTE**'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*There’s absolutely nothing special about a `std::vector<std::pair<int, int>>`.
    It’s just like any other `vector`. The individual elements in this sequential
    container just happen to be a `pair`. Because `pair` has a constructor that accepts
    two arguments, one for `first` and one for `second`, `emplace_back` can add a
    new element by simply passing the two values it should write into the newly created
    `pair`.*'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: '*`std::vector<std::pair<int, int>>`其实没有什么特别的。它和其他的`vector`一样。这个顺序容器中的每个元素恰好是一个`pair`。由于`pair`有一个接受两个参数的构造函数，一个用于`first`，一个用于`second`，`emplace_back`可以通过直接传递这两个值来将一个新元素添加到`pair`中。*'
- en: Because the emplacement methods can construct elements in place, it seems they
    should be more efficient than the insertion methods. This intuition is often correct,
    but for complicated and unsatisfying reasons it’s not always faster. As a general
    rule, use the emplacement methods. If you determine a performance bottleneck,
    also try the insertion methods. See Item 42 of *Effective Modern C++* by Scott
    Meyers for a treatise.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 由于`emplace`方法可以原地构造元素，因此它们似乎应该比插入方法更高效。这种直觉通常是正确的，但由于复杂且令人不满意的原因，它并不总是更快。一般来说，使用`emplace`方法。如果你发现性能瓶颈，也可以尝试插入方法。有关详细讨论，请参阅Scott
    Meyers的《*Effective Modern C++*》第42条。
- en: '**Storage Model**'
  id: totrans-161
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**存储模型**'
- en: Although `vector` elements are contiguous in memory, like an `array`, the similarities
    stop there. A `vector` has dynamic size, so it must be able to resize. The allocator
    of a `vector` manages the dynamic memory underpinning the `vector`.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管`vector`的元素在内存中是连续的，像`array`一样，但相似之处仅此而已。`vector`的大小是动态的，因此它必须能够调整大小。`vector`的分配器管理着支撑`vector`的动态内存。
- en: Because allocations are expensive, a `vector` will request more memory than
    it needs to contain the current number of elements. Once it can no longer add
    any more elements, it will request additional memory. The memory for a `vector`
    is always contiguous, so if there isn’t enough space at the end of the existing
    vector, it will allocate a whole new region of memory and move all the elements
    of the `vector` into the new region. The number of elements a `vector` holds is
    called its *size*, and the number of elements it could theoretically hold before
    having to resize is called its *capacity*. [Figure 13-2](ch13.xhtml#ch13fig02)
    illustrates a `vector` containing three elements with additional capacity for
    three more.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 由于内存分配开销较大，`vector`会请求比实际需要的元素数量更多的内存空间。一旦它无法再添加更多元素，它会请求额外的内存。`vector`的内存总是连续的，因此如果现有`vector`的末尾没有足够的空间，它会分配一个全新的内存区域，并将所有元素移动到新区域中。`vector`所包含的元素数量称为它的*大小*，而它在不需要重新调整大小之前理论上能容纳的元素数量称为它的*容量*。[图13-2](ch13.xhtml#ch13fig02)展示了一个包含三元素的`vector`，并且额外有三元素的容量。
- en: '![image](../images/fig13_2.jpg)'
  id: totrans-164
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/fig13_2.jpg)'
- en: '*Figure 13-2: The `vector` storage model*'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: '*图13-2：`vector`存储模型*'
- en: 'As [Figure 13-2](ch13.xhtml#ch13fig02) shows, the `vector` continues past the
    last element. The capacity determines how many elements the `vector` could hold
    in this space. In this figure, the size is three and the capacity is six. You
    can think of the memory in a `vector` as an auditorium: it might have a capacity
    of 500 but a crowd size of only 250.'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 如[图13-2](ch13.xhtml#ch13fig02)所示，`vector`在最后一个元素之后继续存在。容量决定了`vector`在这块空间中能容纳多少元素。在此图中，大小是三，容量是六。你可以把`vector`中的内存想象成一个礼堂：它可能有500的容量，但观众人数只有250。
- en: The upshot of this design is that inserting at the end of a `vector` is extremely
    fast (unless the `vector` needs to resize). Inserting anywhere else incurs additional
    cost, because the `vector` needs to move elements around to make room.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 这种设计的结果是，向`vector`末尾插入元素非常快速（除非`vector`需要重新调整大小）。在其他位置插入则会增加额外的开销，因为`vector`需要移动元素以腾出空间。
- en: You can obtain the vector’s current capacity via the `capacity` method, and
    you can obtain the absolute maximum capacity that a `vector` could resize to with
    the `max_size` method.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过`capacity`方法获取`vector`当前的容量，也可以通过`max_size`方法获取`vector`理论上能扩展到的最大容量。
- en: If you know ahead of time that you’ll need a certain capacity, you can use the
    `reserve` method, which takes a single `size_t` argument corresponding to the
    number of elements you want capacity for. On the other hand, if you’ve just removed
    several elements and want to return memory to the allocator, you can use the `shrink_to_fit`
    method, which declares that you have excess capacity. The allocator can decide
    to reduce capacity or not (it’s a non-binding call).
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你提前知道自己需要某个容量，可以使用`reserve`方法，它接受一个`size_t`类型的参数，表示你希望为多少个元素预留空间。另一方面，如果你刚刚删除了几个元素，并希望将内存归还给分配器，你可以使用`shrink_to_fit`方法，表示你有多余的容量。分配器可以决定是否减少容量（这是一个非强制性的调用）。
- en: Additionally, you can delete all the elements in a vector and set its size to
    zero using the `clear` method.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，你可以使用`clear`方法删除`vector`中的所有元素，并将其大小设置为零。
- en: '[Listing 13-16](ch13.xhtml#ch13ex16) demonstrates all these storage-related
    methods in a cohesive story: you create an empty vector, reserve a bunch of space,
    add some elements, release excess capacity, and finally empty the vector.'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: '[代码清单13-16](ch13.xhtml#ch13ex16)展示了所有这些与存储相关的方法，呈现了一个连贯的故事：你创建一个空的`vector`，预留一大块空间，添加一些元素，释放多余的容量，最后清空`vector`。'
- en: '[PRE15]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '*Listing 13-16: The storage management functions of a `vector`. (Strictly speaking,
    `kb_store.capacity() >= 3` ➏ ➑ is not guaranteed because the call is non-binding.)*'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: '*代码清单13-16：`vector`的存储管理功能。（严格来说，`kb_store.capacity() >= 3` ➏ ➑不是保证的，因为这个调用是非强制性的。）*'
- en: You construct a `vector` of `array` objects called `kb_store`, which stores
    1 KiB chunks ➊. Unless you’re using a peculiar platform with no dynamic memory,
    `kb_store.max_size()` will be greater than zero; because you default initialize
    the `vector`, it’s empty ➋.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 你构建了一个名为`kb_store`的`vector`数组对象，用于存储1 KiB的块➊。除非你使用的是没有动态内存的特殊平台，否则`kb_store.max_size()`的值会大于零；因为你对`vector`进行了默认初始化，它是空的➋。
- en: Next, you reserve 1,024 elements ➌, which doesn’t change the vector’s empty
    status but increases its capacity to match ➍. The `vector` now has 1,024 × 1 KiB
    = 1 MiB of contiguous space reserved. After reserving space, you emplace three
    arrays and check that `kb_store.size()` increased accordingly ➎.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，你为1,024个元素保留空间 ➌，这并不会改变vector的空状态，但它会增加容量以匹配 ➍。此时，`vector` 已预留了 1,024 ×
    1 KiB = 1 MiB 的连续空间。保留空间后，你插入了三个数组，并检查`kb_store.size()`是否按预期增加 ➎。
- en: You’ve reserved space for 1,024 elements. To release the 1,024 – 3 = 1,021 elements
    you aren’t using back to the allocator, you call `shrink_to_fit`, which reduces
    the capacity to 3 ➏.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 你已经为1,024个元素保留了空间。为了将1,024 - 3 = 1,021个未使用的元素释放回分配器，你调用了`shrink_to_fit`，它将容量减少为3
    ➏。
- en: Finally, you invoke `clear` on the `vector` ➐, which destructs all elements
    and reduces its size to zero. However, the capacity remains unchanged because
    you haven’t made another call to `shrink_to_fit` ➑. This is significant because
    the vector doesn’t want to do extra work if you’re going to add elements again.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，你在`vector` ➐上调用了`clear`，它销毁了所有元素并将其大小减少为零。然而，容量保持不变，因为你没有再次调用`shrink_to_fit`
    ➑。这很重要，因为如果你以后再添加元素，vector 不希望做额外的工作。
- en: '**A Partial List of Supported Operations**'
  id: totrans-178
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**支持操作的部分列表**'
- en: '[Table 13-2](ch13.xhtml#ch13tab02) provides a partial list of `vector` operations.
    In this table, `v`, `v1`, and `v2` are of type `std::vector<T>`, `t` is of type
    `T`, `alc` is an appropriate allocator, and `itr` is an iterator. An asterisk
    (*) indicates that this operation invalidates raw pointers and iterators to `v`’s
    elements in at least some circumstances.'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: '[表13-2](ch13.xhtml#ch13tab02)提供了`vector`操作的部分列表。在此表中，`v`、`v1`和`v2`是`std::vector<T>`类型，`t`是`T`类型，`alc`是合适的分配器，`itr`是迭代器。星号(*)表示在某些情况下，该操作会使指向`v`元素的原始指针和迭代器失效。'
- en: '**Table 13-2:** A Partial List of `std::vector` Operations'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: '**表13-2：** `std::vector`操作的部分列表'
- en: '| **Operation** | **Notes** |'
  id: totrans-181
  prefs: []
  type: TYPE_TB
  zh: '| **操作** | **备注** |'
- en: '| `vector<`T`>{ ...,` [alc]} | Performs braced initialization of a newly constructed
    vector. Uses alc`=std::allocator<`T`>` by default. |'
  id: totrans-182
  prefs: []
  type: TYPE_TB
  zh: '| `vector<`T`>{ ...,` [alc]} | 执行新构造的vector的花括号初始化。默认使用alc`=std::allocator<`T`>`。
    |'
- en: '| `vector<`T`>(`s`,[`t`], [`alc`])` | Fills the newly constructed vector with
    s number of copies of t. If no t is provided, default constructs T instances.
    |'
  id: totrans-183
  prefs: []
  type: TYPE_TB
  zh: '| `vector<`T`>(`s`,[`t`], [`alc`])` | 用t的s个副本填充新构造的vector。如果没有提供t，则默认构造T的实例。
    |'
- en: '| `vector<`T`>(`v`)` | Deep copy of v; allocates new memory. |'
  id: totrans-184
  prefs: []
  type: TYPE_TB
  zh: '| `vector<`T`>(`v`)` | 对v进行深度复制；分配新内存。 |'
- en: '| `vector<`T`>(move(`v`))` | Takes ownership of memory, elements in v. No allocations.
    |'
  id: totrans-185
  prefs: []
  type: TYPE_TB
  zh: '| `vector<`T`>(move(`v`))` | 获取v中元素的内存所有权，不会重新分配内存。 |'
- en: '| `~vector` | Destructs all elements contained by the vector and releases dynamic
    memory. |'
  id: totrans-186
  prefs: []
  type: TYPE_TB
  zh: '| `~vector` | 销毁vector包含的所有元素并释放动态内存。 |'
- en: '| v`.begin()` | Returns an iterator pointing to the first element. |'
  id: totrans-187
  prefs: []
  type: TYPE_TB
  zh: '| v`.begin()` | 返回指向第一个元素的迭代器。 |'
- en: '| v`.cbegin()` | Returns a `const` iterator pointing to the first element.
    |'
  id: totrans-188
  prefs: []
  type: TYPE_TB
  zh: '| v`.cbegin()` | 返回指向第一个元素的`const`迭代器。 |'
- en: '| v`.end()` | Returns an iterator pointing to 1 past the last element. |'
  id: totrans-189
  prefs: []
  type: TYPE_TB
  zh: '| v`.end()` | 返回指向最后一个元素之后位置的迭代器。 |'
- en: '| v`.cend()` | Returns a `const` iterator pointing to 1 past the last element.
    |'
  id: totrans-190
  prefs: []
  type: TYPE_TB
  zh: '| v`.cend()` | 返回指向最后一个元素之后位置的`const`迭代器。 |'
- en: '| v1 `=` v2 | v1 destructs its elements; copies each v2 element. Only allocates
    if it needs to resize to fit v2’s elements.* |'
  id: totrans-191
  prefs: []
  type: TYPE_TB
  zh: '| v1 `=` v2 | v1销毁其元素；复制每个v2元素。只有在需要调整大小以适应v2的元素时才会分配内存。* |'
- en: '| v1 `=` `move(`v2`)` | v1 destructs its elements; moves each v2 element. Only
    allocates if it needs to resize to fit v2’s elements.* |'
  id: totrans-192
  prefs: []
  type: TYPE_TB
  zh: '| v1 `=` `move(`v2`)` | v1销毁其元素；移动每个v2元素。只有在需要调整大小以适应v2的元素时才会分配内存。* |'
- en: '| v`.at(`0`)` | Accesses element 0 of v. Throws `std::out_of_range` if out
    of bounds. |'
  id: totrans-193
  prefs: []
  type: TYPE_TB
  zh: '| v`.at(`0`)` | 访问v的第0个元素。如果越界，抛出`std::out_of_range`异常。 |'
- en: '| v`[`0`]` | Accesses element 0 of v. Undefined behavior if out of bounds.
    |'
  id: totrans-194
  prefs: []
  type: TYPE_TB
  zh: '| v`[`0`]` | 访问v的第0个元素。如果越界，行为未定义。 |'
- en: '| v`.front()` | Accesses first element. |'
  id: totrans-195
  prefs: []
  type: TYPE_TB
  zh: '| v`.front()` | 访问第一个元素。 |'
- en: '| v`.back()` | Accesses last element. |'
  id: totrans-196
  prefs: []
  type: TYPE_TB
  zh: '| v`.back()` | 访问最后一个元素。 |'
- en: '| v`.data()` | Returns a raw pointer to the first element if array is non-empty.
    For empty arrays, returns a valid but non-dereferencable pointer. |'
  id: totrans-197
  prefs: []
  type: TYPE_TB
  zh: '| v`.data()` | 返回指向第一个元素的原始指针（如果数组非空）。对于空数组，返回一个有效但不可解引用的指针。 |'
- en: '| v`.assign({` ... `})` | Replaces the contents of v with the elements ....*
    |'
  id: totrans-198
  prefs: []
  type: TYPE_TB
  zh: '| v`.assign({` ... `})` | 用元素替换v的内容 ....* |'
- en: '| v`.assign(`s`,` t`)` | Replaces the contents of v with s number of copies
    of t.* |'
  id: totrans-199
  prefs: []
  type: TYPE_TB
  zh: '| v`.assign(`s`,` t`)` | 用s个t的副本替换v的内容。* |'
- en: '| v`.empty()` | Returns `true` if vector’s size is zero; otherwise `false`.
    |'
  id: totrans-200
  prefs: []
  type: TYPE_TB
  zh: '| v`.empty()` | 如果 vector 的大小为零，则返回 `true`；否则返回 `false`。 |'
- en: '| v`.size()` | Returns the number of elements in the vector. |'
  id: totrans-201
  prefs: []
  type: TYPE_TB
  zh: '| v`.size()` | 返回 vector 中元素的数量。 |'
- en: '| v`.capacity()` | Returns the maximum number of elements the vector could
    hold without having to resize. |'
  id: totrans-202
  prefs: []
  type: TYPE_TB
  zh: '| v`.capacity()` | 返回 vector 可以容纳的最大元素数量，而无需调整大小。 |'
- en: '| v`.shrink_to_fit()` | Might reduce the vector’s storage so `capacity()` equals
    `size()`.* |'
  id: totrans-203
  prefs: []
  type: TYPE_TB
  zh: '| v`.shrink_to_fit()` | 可能会减少 vector 的存储，使 `capacity()` 等于 `size()`。* |'
- en: '| v`.resize(`s`, [`t`])` | Resizes v to contain s elements. If this shrinks
    v, destructs elements at the end. If this grows v, inserts default constructed
    Ts or copies of t if provided.* |'
  id: totrans-204
  prefs: []
  type: TYPE_TB
  zh: '| v`.resize(`s`, [`t`])` | 调整 v 的大小为 s 个元素。如果缩小 v，会销毁末尾的元素。如果扩展 v，则插入默认构造的
    T 元素，或者如果提供了 t，则插入 t 的副本。* |'
- en: '| v`.reserve(`s`)` | Increases the vector’s storage so it can contain at least
    s elements.* |'
  id: totrans-205
  prefs: []
  type: TYPE_TB
  zh: '| v`.reserve(`s`)` | 增加 vector 的存储，以便它至少能够容纳 s 个元素。* |'
- en: '| v`.max_size()` | Returns the maximum possible size the vector can resize
    to. |'
  id: totrans-206
  prefs: []
  type: TYPE_TB
  zh: '| v`.max_size()` | 返回 vector 可以扩展到的最大可能大小。 |'
- en: '| v`.clear()` | Removes all elements in v, but capacity remains.* |'
  id: totrans-207
  prefs: []
  type: TYPE_TB
  zh: '| v`.clear()` | 删除 v 中的所有元素，但容量保持不变。* |'
- en: '| v`.insert(`itr`,` t`)` | Inserts a copy of t just before the element pointed
    to by itr; v’s range must contain itr.* |'
  id: totrans-208
  prefs: []
  type: TYPE_TB
  zh: '| v`.insert(`itr`,` t`)` | 在由 itr 指向的元素之前插入 t 的副本；v 的范围必须包含 itr。* |'
- en: '| v`.push_back(`t`)` | Inserts a copy of t at the end of v.* |'
  id: totrans-209
  prefs: []
  type: TYPE_TB
  zh: '| v`.push_back(`t`)` | 在 v 的末尾插入 t 的副本。* |'
- en: '| v`.emplace(`itr`,` ...`)` | Constructs a T in place by forwarding the arguments
    ... to the appropriate constructor. Element inserted just before the element pointed
    to by itr.* |'
  id: totrans-210
  prefs: []
  type: TYPE_TB
  zh: '| v`.emplace(`itr`,` ...`)` | 通过将参数 ... 转发给适当的构造函数，在 itr 指向的元素之前就地构造一个 T 元素。*
    |'
- en: '| v`.emplace_back(`...`)` | Constructs a T in place by forwarding the arguments
    ... to the appropriate constructor. Element inserted at the end of v.* |'
  id: totrans-211
  prefs: []
  type: TYPE_TB
  zh: '| v`.emplace_back(`...`)` | 通过将参数 ... 转发给适当的构造函数，在 v 的末尾就地构造一个 T 元素。* |'
- en: '| v1`.swap(`v2`)``swap(`v1`,` v2`)` | Exchanges each element of v1 with those
    of v2.* |'
  id: totrans-212
  prefs: []
  type: TYPE_TB
  zh: '| v1`.swap(`v2`)``swap(`v1`,` v2`)` | 交换 v1 和 v2 的每个元素。* |'
- en: '| v1 `==` v2v1 `!=` v2v1 `>` v2v1 `>=` v2v1 `<` v2v1 `<=` v2 | Equal if all
    elements are equal.Greater than/less than comparisons proceed from first element
    to last. |'
  id: totrans-213
  prefs: []
  type: TYPE_TB
  zh: '| v1 `==` v2v1 `!=` v2v1 `>` v2v1 `>=` v2v1 `<` v2v1 `<=` v2 | 如果所有元素相等，则为相等。大于/小于的比较从第一个元素到最后一个元素进行。
    |'
- en: '***Niche Sequential Containers***'
  id: totrans-214
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***小众顺序容器***'
- en: The `vector` and `array` containers are the clear choice in most situations
    in which you need a sequential data structure. If you know the number of elements
    you’ll need ahead of time, use an `array`. If you don’t, use a `vector`.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 在大多数需要顺序数据结构的情况下，`vector` 和 `array` 容器是首选。如果你事先知道所需的元素数量，使用 `array`。如果不知道，使用
    `vector`。
- en: You might find yourself in a niche situation where `vector` and `array` don’t
    have the performance characteristics you desire. This section highlights a number
    of alternative sequential containers that might offer superior performance characteristics
    in such a situation.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会遇到一个特殊的情况，在这种情况下，`vector` 和 `array` 无法提供你所需的性能特性。本节重点介绍了一些可能在这种情况下提供更高性能特性的替代顺序容器。
- en: '**Deque**'
  id: totrans-217
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**双端队列**'
- en: A *deque* (pronounced “deck”) is a sequential container with fast insert and
    remove operations from the front and back. Deque is a portmanteau of **d**ouble*-***e**nded
    **que**ue. The STL implementation `std::deque` is available from the `<deque>`
    header.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: '*deque*（发音为“deck”）是一个顺序容器，具有快速的插入和删除操作，支持从前端和后端进行操作。Deque 是 **d**ouble*-***e**nded
    **que**ue 的合成词。STL 实现的 `std::deque` 可通过 `<deque>` 头文件使用。'
- en: '**NOTE**'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*The Boost Container library also contains a `boost::container::deque` in the
    `<boost/container/deque.hpp>` header.*'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: '*Boost 容器库还包含了一个 `boost::container::deque`，定义在 `<boost/container/deque.hpp>`
    头文件中。*'
- en: A `vector` and a `deque` have very similar interfaces, but internally their
    storage models are totally different. A `vector` guarantees that all elements
    are sequential in memory, whereas a `deque`’s memory is usually scattered about,
    like a hybrid between a `vector` and a `list`. This makes large resizing operations
    more efficient and enables fast element insertion/deletion at the container’s
    front.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: '`vector` 和 `deque` 有非常相似的接口，但它们的内部存储模型完全不同。`vector` 保证所有元素在内存中是连续的，而 `deque`
    的内存通常是分散的，类似于 `vector` 和 `list` 的混合体。这使得大规模调整大小操作更加高效，并且支持在容器的前端快速插入/删除元素。'
- en: Constructing and accessing members are identical operations for `vector`s and
    `deque`s.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 构造和访问成员对 `vector` 和 `deque` 来说是相同的操作。
- en: Because the internal structure of `deque` is complex, it doesn’t expose a `data`
    method. In exchange, you gain access to `push_front` and `emplace_front`, which
    mirror the `push_back` and `emplace_back` that you’re familiar with from `vector`.
    [Listing 13-17](ch13.xhtml#ch13ex17) illustrates how to use `push_back` and `push_front`
    to insert values into a `deque` of `char`s.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 `deque` 的内部结构复杂，它没有暴露 `data` 方法。作为交换，你可以访问 `push_front` 和 `emplace_front`，它们与
    `vector` 中你熟悉的 `push_back` 和 `emplace_back` 相对应。[Listing 13-17](ch13.xhtml#ch13ex17)
    展示了如何使用 `push_back` 和 `push_front` 向 `deque` 中插入 `char` 类型的值。
- en: '[PRE16]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: '*Listing 13-17: A `deque` supports `push_front` and `push_back`.*'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: '*Listing 13-17：`deque` 支持 `push_front` 和 `push_back`。*'
- en: After constructing an empty `deque`, you push alternating letters to the front
    ➊ and back ➋ of the `deque` so it contains the elements `c`, `a`, `i`, and `n`
    ➌.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 在构造一个空的 `deque` 后，你将交替的字母推送到 `deque` 的前端 ➊ 和后端 ➋，使其包含元素 `c`、`a`、`i` 和 `n` ➌。
- en: '**NOTE**'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*It would be a very bad idea to attempt to extract a string here, for example,
    `&deckard[0]`, because `deque` makes no guarantees about internal layout.*'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: '*例如，尝试提取一个字符串，如 `&deckard[0]`，将是一个非常糟糕的主意，因为 `deque` 对内部布局没有任何保证。*'
- en: 'The `vector` methods not implemented by `deque`, along with an explanation
    for their absence, are as follows:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: '`deque` 没有实现的 `vector` 方法及其缺失的解释如下：'
- en: '**`capacity`, `reserve`** Because the internal structure is complicated, it
    might not be efficient to compute capacity. Also, `deque` allocations are relatively
    fast because a `deque` doesn’t relocate existing elements, so reserving memory
    ahead of time is unnecessary.'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: '**`capacity`, `reserve`** 由于内部结构复杂，计算容量可能效率不高。而且，`deque` 的分配相对较快，因为 `deque`
    不会重新定位现有元素，因此不需要提前预留内存。'
- en: '**`data`** The elements of `deque` are not contiguous.'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: '**`data`** `deque` 的元素不是连续存储的。'
- en: '[Table 13-3](ch13.xhtml#ch13tab03) summarizes the additional operators offered
    by a `deque` but not by a `vector`. In this table, `d` is of type `std::deque<T>`
    and `t` is of type `T`. An asterisk (*) indicates that this operation invalidates
    iterators to `v`’s elements in at least some circumstances. (Pointers to existing
    elements remain valid.)'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: '[表 13-3](ch13.xhtml#ch13tab03) 总结了 `deque` 提供的额外运算符，而 `vector` 没有。在该表中，`d`
    的类型是 `std::deque<T>`，`t` 的类型是 `T`。星号（*）表示在某些情况下，此操作会使迭代器失效，指向 `v` 元素的迭代器失效。（指向现有元素的指针保持有效。）'
- en: '**Table 13-3:** A Partial List of `std::deque` Operations'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: '**表 13-3：** `std::deque` 操作的部分列表'
- en: '| **Operation** | **Notes** |'
  id: totrans-234
  prefs: []
  type: TYPE_TB
  zh: '| **操作** | **备注** |'
- en: '| d`.emplace_front(`...`)` | Constructs an element in place at the front of
    the d by forwarding all arguments to the appropriate constructor.* |'
  id: totrans-235
  prefs: []
  type: TYPE_TB
  zh: '| d`.emplace_front(`...`)` | 通过将所有参数转发给适当的构造函数，在 d 的前端原地构造一个元素。* |'
- en: '| d`.push_front(`t`)` | Constructs an element in place at the front of the
    d by copying t.* |'
  id: totrans-236
  prefs: []
  type: TYPE_TB
  zh: '| d`.push_front(`t`)` | 通过复制 t 在 d 的前端原地构造一个元素。* |'
- en: '| d`.pop_front()` | Removes the element at the front of d.* |'
  id: totrans-237
  prefs: []
  type: TYPE_TB
  zh: '| d`.pop_front()` | 移除 d 的前端元素。* |'
- en: '**List**'
  id: totrans-238
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**List**'
- en: A *list* is a sequence container with fast insert/remove operations everywhere
    but with no random element access. The STL implementation `std::list` is available
    from the `<list>` header.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: '*list* 是一种序列容器，具有快速的插入/删除操作，但不支持随机访问元素。STL 实现的 `std::list` 可以通过 `<list>` 头文件使用。'
- en: '**NOTE**'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*The Boost Container library also contains a `boost::container::list` in the
    `<boost/container/list.hpp>` header.*'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: '*Boost 容器库还包含了 `<boost/container/list.hpp>` 头文件中的 `boost::container::list`。*'
- en: The `list` is implemented as a doubly linked list, a data structure composed
    of *nodes*. Each node contains an element, a forward link (“flink”), and a backward
    link (“blink”). This is completely different from a `vector`, which stores elements
    in contiguous memory. As a result, you cannot use `operator[]` or `at` to access
    arbitrary elements in a `list`, because such operations would be very inefficient.
    (These methods are simply not available in `list` because of their horrible performance
    characteristics.) The trade-off is that inserting and removing elements in a `list`
    is much faster. All you need to update are the flinks and blinks of an element’s
    neighbors rather than shuffling potentially large, contiguous element ranges.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: '`list` 实现为双向链表，这是一种由 *节点* 组成的数据结构。每个节点包含一个元素、一个前向链接（“flink”）和一个后向链接（“blink”）。这与
    `vector` 完全不同，后者将元素存储在连续的内存中。因此，你不能使用 `operator[]` 或 `at` 来访问 `list` 中的任意元素，因为这些操作效率非常低。（这些方法在
    `list` 中根本不可用，因为它们的性能表现非常差。）其权衡是，在 `list` 中插入和移除元素的速度要快得多。你只需要更新元素邻居的 flinks 和
    blinks，而不需要移动可能很大的连续元素范围。'
- en: The `list` container supports the same constructor patterns as `vector`.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: '`list` 容器支持与 `vector` 相同的构造函数模式。 |'
- en: You can perform special operations on lists, such as splicing elements from
    one list into another using the `splice` method, removing consecutive duplicate
    elements using the `unique` method, and even sorting the elements of a container
    using the `sort` method. Consider, for example, the `remove_if` method. The `remove_if`
    method accepts a function object as a parameter, and it traverses the `list` while
    invoking the function object on each element. If the result is `true`, `remove_if`
    removes the element. [Listing 13-18](ch13.xhtml#ch13ex18) illustrates how to use
    the `remove_if` method to eliminate all the even numbers of a `list` with a lambda
    predicate.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以对列表执行特殊操作，例如使用 `splice` 方法将元素从一个列表拼接到另一个列表，使用 `unique` 方法移除连续的重复元素，甚至使用 `sort`
    方法对容器中的元素进行排序。例如，考虑 `remove_if` 方法。`remove_if` 方法接受一个函数对象作为参数，并在遍历 `list` 时对每个元素调用该函数对象。如果返回
    `true`，`remove_if` 就会移除该元素。[Listing 13-18](ch13.xhtml#ch13ex18) 说明了如何使用 `remove_if`
    方法通过 lambda 谓词删除 `list` 中的所有偶数。
- en: '[PRE17]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: '*Listing 13-18: A `list` supports `remove_if`.*'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: '*Listing 13-18：`list` 支持 `remove_if`。*'
- en: Here, you use braced initialization to fill a `list` of `int` objects ➊. Next,
    you use the `remove_if` method to remove all the even numbers ➋. Because only
    even numbers modulo 2 equal zero, this lambda tests whether a number is even.
    To establish that `remove_if` has extracted the even elements 22 and 44, you create
    an iterator pointing at the beginning of the list ➌, check its value ➍, and increment
    ➎ until you reach the end of the list ➏.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 在此，你使用大括号初始化填充 `int` 类型对象的 `list` ➊。接下来，你使用 `remove_if` 方法移除所有偶数 ➋。因为只有偶数对 2
    取余为零，所以这个 lambda 表达式用来测试一个数字是否是偶数。为了验证 `remove_if` 已经移除偶数元素 22 和 44，你创建一个指向列表开头的迭代器
    ➌，检查其值 ➍，并递增 ➎，直到达到列表末尾 ➏。
- en: 'All the `vector` methods not implemented by `list`, along with an explanation
    for their absence, are as follows:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 所有 `vector` 方法在 `list` 中没有实现，以及它们未实现的解释如下： |
- en: '**`capacity`, `reserve`, `shrink_to_fit`** Because `list` acquires memory incrementally,
    it doesn’t require periodic resizing.'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: '**`capacity`, `reserve`, `shrink_to_fit`** 由于 `list` 是增量地分配内存，因此不需要定期调整大小。
    |'
- en: '**`operator[]`, `at`** Random element access is prohibitively expensive on
    `list`s.'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: '**`operator[]`, `at`** 在 `list` 上随机访问元素代价昂贵。 |'
- en: '**`data`** Unneeded because `list` elements are not contiguous.'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: '**`data`** 不需要，因为 `list` 元素不是连续存储的。 |'
- en: '[Table 13-4](ch13.xhtml#ch13tab04) summarizes the additional operators offered
    by a `list` but not by a `vector`. In this table, `lst`, `lst1`, and `lst2` are
    of type `std::list<T>`, and `t` is of type `T`. The arguments `itr1`, `itr2a`,
    and `itr2b` are `list` iterators. An asterisk (*) indicates that the operation
    invalidates iterators to `v`’s elements in at least some circumstances. (Pointers
    to existing elements remain valid.)'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: '[表 13-4](ch13.xhtml#ch13tab04) 总结了 `list` 提供但 `vector` 不提供的额外操作符。在此表中，`lst`、`lst1`
    和 `lst2` 是 `std::list<T>` 类型，`t` 是 `T` 类型。`itr1`、`itr2a` 和 `itr2b` 是 `list` 迭代器。星号
    (*) 表示在某些情况下，该操作会使指向 `v` 元素的迭代器无效。（指向现有元素的指针仍然有效。） |'
- en: '**Table 13-4:** A Partial List of `std::list` Operations'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: '**表 13-4：** `std::list` 操作的部分列表 |'
- en: '| **Operation** | **Notes** |'
  id: totrans-254
  prefs: []
  type: TYPE_TB
  zh: '| **操作** | **备注** |'
- en: '| lst`.emplace_front(`...`)` | Constructs an element in place at the front
    of the `d` by forwarding all arguments to the appropriate constructor. |'
  id: totrans-255
  prefs: []
  type: TYPE_TB
  zh: '| lst`.emplace_front(`...`)` | 通过将所有参数转发给相应的构造函数，在 `d` 的前端构造一个元素。 |'
- en: '| lst`.push_front(`t`)` | Constructs an element in place at the front of d
    by copying t. |'
  id: totrans-256
  prefs: []
  type: TYPE_TB
  zh: '| lst`.push_front(`t`)` | 通过复制 t 在 d 的前端构造一个元素。 |'
- en: '| lst`.pop_front()` | Removes the element at the front of d. |'
  id: totrans-257
  prefs: []
  type: TYPE_TB
  zh: '| lst`.pop_front()` | 移除 d 中位于前端的元素。 |'
- en: '| lst`.push_back(`t`)` | Constructs an element in place at the back of d by
    copying t. |'
  id: totrans-258
  prefs: []
  type: TYPE_TB
  zh: '| lst`.push_back(`t`)` | 通过复制 t 在 d 的末尾构造一个元素。 |'
- en: '| lst`.pop_back()` | Removes the element at the back of d. |'
  id: totrans-259
  prefs: []
  type: TYPE_TB
  zh: '| lst`.pop_back()` | 移除 d 中位于末尾的元素。 |'
- en: '| lst1`.splice(`itr1`,`lst2`,` [itr2a]`,` [itr2b]`)` | Transfers items from
    lst2 into lst1 at position itr1. Optionally, only transfer the element at itr2a
    or the elements within the half-open range itr2a to itr2b. |'
  id: totrans-260
  prefs: []
  type: TYPE_TB
  zh: '| lst1`.splice(`itr1`,`lst2`,` [itr2a]`,` [itr2b]`)` | 将 lst2 中的元素转移到 lst1
    中的 itr1 位置。可选地，只转移 itr2a 处的元素或从 itr2a 到 itr2b 半开区间内的元素。 |'
- en: '|  lst`.remove(`t`)`  | Removes all elements in lst equal to t. |'
  id: totrans-261
  prefs: []
  type: TYPE_TB
  zh: '| lst`.remove(`t`)` | 移除 lst 中所有等于 t 的元素。 |'
- en: '| lst`.remove_if(`pred`)` | Eliminates elements in lst where pred returns true;
    pred accepts a single T argument. |'
  id: totrans-262
  prefs: []
  type: TYPE_TB
  zh: '| lst`.remove_if(`pred`)` | 删除 lst 中符合 pred 条件的元素；pred 接受一个类型为 T 的单一参数。 |'
- en: '| lst`.unique(`pred`)` | Eliminates duplicate consecutive elements in lst according
    to the function object pred, which accepts two T arguments and returns t1 `==`
    t2. |'
  id: totrans-263
  prefs: []
  type: TYPE_TB
  zh: '| lst`.unique(`pred`)` | 根据函数对象pred消除lst中相邻重复的元素，pred接受两个T类型参数并返回t1 `==` t2。
    |'
- en: '| lst1`.merge(`lst2`,` comp`)` | Merges lst1 and lst2 according to the function
    object comp, which accepts two T arguments and returns t1 `<` t2. |'
  id: totrans-264
  prefs: []
  type: TYPE_TB
  zh: '| lst1`.merge(`lst2`,` comp`)` | 根据函数对象comp将lst1和lst2合并，comp接受两个T类型参数并返回t1
    `<` t2。 |'
- en: '| lst`.sort(`comp`)` | Sorts lst according to the function object comp. |'
  id: totrans-265
  prefs: []
  type: TYPE_TB
  zh: '| lst`.sort(`comp`)` | 根据函数对象comp对lst进行排序。 |'
- en: '| lst`.reverse()` | Reverses the order of lst’s elements (mutates lst). |'
  id: totrans-266
  prefs: []
  type: TYPE_TB
  zh: '| lst`.reverse()` | 反转lst中元素的顺序（会改变lst）。 |'
- en: '**NOTE**'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*The STL also offers a `std::forward_list` in the `<forward_list>` header,
    which is a singly linked list that only allows iteration in one direction. The
    `forward_list` is slightly more efficient than `list`, and it’s optimized for
    situations in which you need to store very few (or no) elements.*'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: '*STL还在`<forward_list>`头文件中提供了`std::forward_list`，它是一个单向链表，只允许朝一个方向遍历。`forward_list`比`list`稍微高效，且在需要存储极少量（或没有）元素的情况下进行了优化。*'
- en: '**Stacks**'
  id: totrans-269
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**栈**'
- en: The STL provides three *container adapters* that encapsulate other STL containers
    and expose special interfaces for tailored situations. The adapters are the stack,
    the queue, and the priority queue.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: STL提供了三种*容器适配器*，它们封装了其他STL容器，并为特定情况暴露了特殊接口。这些适配器分别是栈（stack）、队列（queue）和优先队列（priority
    queue）。
- en: 'A *stack* is a data structure with two fundamental operations: push and pop.
    When you *push* an element onto a stack, you insert the element onto the stack’s
    end. When you *pop* an element off a stack, you remove the element from the stack’s
    end. This arrangement is called *last-in*, *first-out*: the last element to be
    pushed onto a stack is the first to be popped off.'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: '*栈*（stack）是一种具有两种基本操作的数据结构：压栈（push）和弹栈（pop）。当你将一个元素压入栈中时，你将该元素插入到栈的末端。当你从栈中弹出一个元素时，你将元素从栈的末端移除。这个排列方式叫做*后进先出*（last-in,
    first-out）：最后被压入栈的元素是第一个被弹出的元素。'
- en: The STL offers the `std::stack` in the `<stack>` header. The class template
    `stack` takes two template parameters. The first is the underlying type of the
    wrapped container, such as `int`, and the second is the type of the wrapped container,
    such as `deque` or `vector`. This second argument is optional and defaults to
    `deque`.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: STL在`<stack>`头文件中提供了`std::stack`。类模板`stack`有两个模板参数，第一个是被封装容器的底层类型，例如`int`，第二个是被封装容器的类型，例如`deque`或`vector`。第二个参数是可选的，默认值为`deque`。
- en: To construct a `stack`, you can pass a reference to a `deque`, a `vector`, or
    a `list` to encapsulate. This way, the `stack` translates its operations, such
    as `push` and `pop`, into methods that the underlying container understands, like
    `push_back` and `pop_back`. If you provide no constructor argument, the `stack`
    uses a `deque` by default. The second template parameter must match this container’s
    type.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 要构造一个`stack`，你可以传递一个`deque`、`vector`或`list`的引用来封装。这样，`stack`会将其操作，如`push`和`pop`，转换为底层容器能够理解的方法，比如`push_back`和`pop_back`。如果没有提供构造函数参数，`stack`默认使用`deque`。第二个模板参数必须与此容器的类型匹配。
- en: To obtain a reference to the element on top of a `stack`, you use the `top`
    method.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 要获取`stack`顶部元素的引用，可以使用`top`方法。
- en: '[Listing 13-19](ch13.xhtml#ch13ex19) illustrates how to use a `stack` to wrap
    a `vector`.'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: '[清单 13-19](ch13.xhtml#ch13ex19)演示了如何使用`stack`来封装`vector`。'
- en: '[PRE18]'
  id: totrans-276
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: '*Listing 13-19: Using a `stack` to wrap a `vector`*'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 13-19：使用`stack`封装`vector`*'
- en: You construct a `vector` of `int`s called `vec` containing the elements 1 and
    3 ➊. Next, you pass `vec` into the constructor of a new `stack`, making sure to
    supply the second template parameter `decltype(vec)` ➋. The top element in `stack`
    is now 3, because this is the last element in `vec` ➌. After the first `pop` ➍,
    you push a new element 2 onto the `stack` ➎. Now, the `top` element is 2 ➏. After
    another `pop`-`top`-`pop` series, the `stack` is empty ➐.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 你构造一个名为`vec`的`int`类型的`vector`，其中包含元素1和3 ➊。接着，你将`vec`传入新`stack`的构造函数，并确保提供第二个模板参数`decltype(vec)`
    ➋。`stack`中的顶部元素现在是3，因为这是`vec`中的最后一个元素 ➌。在第一次`pop`之后 ➍，你将新元素2压入`stack` ➎。此时，`top`元素是2
    ➏。经过另一次`pop`-`top`-`pop`的操作后，`stack`为空 ➐。
- en: '[Table 13-5](ch13.xhtml#ch13tab05) summarizes the operations of `stack`. In
    this table, `s`, `s1`, and `s2` are of type `std::stack<T>`; `t` is of type `T`;
    and `ctr` is a container of type `ctr_type<T>`.'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: '[表格 13-5](ch13.xhtml#ch13tab05)总结了`stack`的操作。在此表中，`s`、`s1`和`s2`的类型为`std::stack<T>`；`t`的类型为`T`；`ctr`是类型为`ctr_type<T>`的容器。'
- en: '**Table 13-5:** A Summary of `std::stack` Operations'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: '**表 13-5：** `std::stack`操作概述'
- en: '| **Operation** | **Notes** |'
  id: totrans-281
  prefs: []
  type: TYPE_TB
  zh: '| **操作** | **备注** |'
- en: '| `stack<`T, `[`ctr_type<T>`]>([`ctr`])` | Constructs a stack of Ts using ctr
    as its internal container reference. If no container is provided, constructs an
    empty deque. |'
  id: totrans-282
  prefs: []
  type: TYPE_TB
  zh: '| `stack<`T, `[`ctr_type<T>`]>([`ctr`])` | 使用ctr作为内部容器引用构造T类型的栈。如果没有提供容器，则构造一个空的deque。
    |'
- en: '| s`.empty()` | Returns `true` if container is empty. |'
  id: totrans-283
  prefs: []
  type: TYPE_TB
  zh: '| s`.empty()` | 如果容器为空，返回`true`。 |'
- en: '| s`.size()` | Returns number of elements in container. |'
  id: totrans-284
  prefs: []
  type: TYPE_TB
  zh: '| s`.size()` | 返回容器中元素的数量。 |'
- en: '| s`.top()` | Returns a reference to the element on top of the `stack`. |'
  id: totrans-285
  prefs: []
  type: TYPE_TB
  zh: '| s`.top()` | 返回`stack`顶部元素的引用。 |'
- en: '| s`.push(t)` | Puts a copy of t onto the end of the container. |'
  id: totrans-286
  prefs: []
  type: TYPE_TB
  zh: '| s`.push(t)` | 将t的副本放入容器末尾。 |'
- en: '| s`.emplace(`...`)` | Constructs a T in place by forwarding ... to the appropriate
    constructor. |'
  id: totrans-287
  prefs: []
  type: TYPE_TB
  zh: '| s`.emplace(`...`)` | 通过转发...到适当的构造函数，在原地构造一个T。 |'
- en: '| s`.pop()` | Removes the element at the end of the container. |'
  id: totrans-288
  prefs: []
  type: TYPE_TB
  zh: '| s`.pop()` | 移除容器末尾的元素。 |'
- en: '| s1`.swap(`s2`)``swap(`s1`,` s2`)` | Exchanges the contents of s2 with s1.
    |'
  id: totrans-289
  prefs: []
  type: TYPE_TB
  zh: '| s1`.swap(`s2`)``swap(`s1`,`s2`)` | 交换s1和s2的内容。 |'
- en: '**Queues**'
  id: totrans-290
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**队列**'
- en: A *queue* is a data structure that, like a stack, has push and pop as its fundamental
    operations. Unlike a stack, a queue is *first-in*, *first-out*. When you push
    an element into a queue, you insert onto the queue’s end. When you pop an element
    off the queue, you remove from the queue’s beginning. This way, the element that
    has been in the queue the longest is the one to get popped off.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: '*队列*是一种数据结构，像栈一样，它的基本操作是推入（push）和弹出（pop）。与栈不同，队列是*先进先出*（first-in, first-out）。当你将一个元素推入队列时，你是将元素插入队列的末尾。当你弹出一个元素时，你是从队列的开头移除元素。这样，在队列中待得最久的元素就是最先被弹出的元素。'
- en: The STL offers the `std::queue` in the `<queue>` header. Like `stack`, `queue`
    takes two template parameters. The first parameter is the underlying type of the
    wrapped container, and the optional second parameter is the type of the wrapped
    container, which also defaults to `deque`.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: STL提供了`std::queue`，它位于`<queue>`头文件中。像`stack`一样，`queue`接受两个模板参数。第一个参数是被包装容器的底层类型，第二个参数是被包装容器的类型，默认为`deque`。
- en: Among STL containers, you can only use `deque` or `list` as the underlying container
    for a `queue`, because pushing and popping from the front of a `vector` is inefficient.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 在STL容器中，你只能使用`deque`或`list`作为`queue`的底层容器，因为从`vector`的前端推入和弹出元素效率较低。
- en: You can access the element at the front or back of a queue using the `front`
    and `back` methods.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用`front`和`back`方法访问队列前端或后端的元素。
- en: '[Listing 13-20](ch13.xhtml#ch13ex20) shows how to use a `queue` to wrap a `deque`.'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: '[列表 13-20](ch13.xhtml#ch13ex20)展示了如何使用`queue`来包装`deque`。'
- en: '[PRE19]'
  id: totrans-296
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: '*Listing 13-20: Using a `queue` to wrap a `deque`*'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 13-20: 使用`queue`包装`deque`*'
- en: You start with a `deque` containing the elements 1 and 2 ➊, which you pass into
    a queue called `easy_as` ➋. Using the `front` and `back` methods, you can validate
    that the queue begins with a 1 ➌ and ends with a 2 ➍. When you `pop` the first
    element, 1, you’re left with a queue containing just the single element 2 ➎. You
    then `push` 3 ➏, so the method `front` yields 2 ➐ and `back` yields 3 ➑. After
    two more iterations of `pop`-`front`, you’re left with an empty `queue` ➒.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 你从一个包含元素1和2的`deque`开始 ➊，并将其传入一个名为`easy_as`的队列 ➋。使用`front`和`back`方法，你可以验证队列的开头是1
    ➌，结尾是2 ➍。当你弹出第一个元素1时，队列中只剩下单一元素2 ➎。然后你将3推入队列 ➏，此时`front`方法返回2 ➐，`back`方法返回3 ➑。再进行两次`pop`-`front`操作后，队列为空
    ➒。
- en: '[Table 13-6](ch13.xhtml#ch13tab06) summarizes the operations of `queue`. In
    this table, `q`, `q1`, and `q2` are of type `std::queue<T>`; `t` is of type `T`;
    and `ctr` is a container of type `ctr_type<T>`.'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: '[表 13-6](ch13.xhtml#ch13tab06)总结了`queue`的操作。在这张表中，`q`、`q1`和`q2`是`std::queue<T>`类型；`t`是`T`类型；`ctr`是`ctr_type<T>`类型的容器。'
- en: '**Table 13-6:** A Summary of `std::queue` Operations'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: '**表 13-6：** `std::queue`操作概述'
- en: '| **Operation** | **Notes** |'
  id: totrans-301
  prefs: []
  type: TYPE_TB
  zh: '| **操作** | **备注** |'
- en: '| `queue<`T`, [`ctr_type<T>`]>([`ctr`])` | Constructs a queue of Ts using ctr
    as its internal container. If no container is provided, constructs an empty `deque`.
    |'
  id: totrans-302
  prefs: []
  type: TYPE_TB
  zh: '| `queue<`T`, [`ctr_type<T>`]>([`ctr`])` | 使用ctr作为内部容器构造T类型的队列。如果没有提供容器，则构造一个空的`deque`。
    |'
- en: '| q`.empty()` | Returns `true` if container is empty. |'
  id: totrans-303
  prefs: []
  type: TYPE_TB
  zh: '| q`.empty()` | 如果容器为空，返回`true`。 |'
- en: '| q`.size()` | Returns number of elements in container. |'
  id: totrans-304
  prefs: []
  type: TYPE_TB
  zh: '| q`.size()` | 返回容器中元素的数量。 |'
- en: '|  q`.front()`  | Returns a reference to the element in front of the `queue`.
    |'
  id: totrans-305
  prefs: []
  type: TYPE_TB
  zh: '|  q`.front()`  | 返回队列前端元素的引用。 |'
- en: '| q`.back()` | Returns a reference to the element in back of the `queue`. |'
  id: totrans-306
  prefs: []
  type: TYPE_TB
  zh: '| q`.back()` | 返回 `queue` 中最后一个元素的引用。 |'
- en: '| q`.push(`t`)` | Puts a copy of t onto the end of the container. |'
  id: totrans-307
  prefs: []
  type: TYPE_TB
  zh: '| q`.push(`t`)` | 将 t 的副本放到容器的末尾。 |'
- en: '| q`.emplace(`...`)` | Constructs a T in place by forwarding ... to the appropriate
    constructor. |'
  id: totrans-308
  prefs: []
  type: TYPE_TB
  zh: '| q`.emplace(`...`)` | 通过转发 ... 到适当的构造函数，原地构造一个 T。 |'
- en: '| q`.pop()` | Removes the element at the front of the container. |'
  id: totrans-309
  prefs: []
  type: TYPE_TB
  zh: '| q`.pop()` | 移除容器中前面的元素。 |'
- en: '| q1`.swap(`q2`)` `swap(`q1`,` q2`)` | Exchanges the contents of q2 with q1.
    |'
  id: totrans-310
  prefs: []
  type: TYPE_TB
  zh: '| q1`.swap(`q2`)` `swap(`q1`,` q2`)` | 交换 q2 和 q1 的内容。 |'
- en: '**Priority Queues (Heaps)**'
  id: totrans-311
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**优先队列（堆）**'
- en: A *priority queue* (also called a heap) is a data structure that supports `push`
    and `pop` operations and keeps elements sorted according to some user-specified
    *comparator object*. The comparator object is a function object invokable with
    two parameters, returning `true` if the first argument is less than the second.
    When you `pop` an element from a priority queue, you remove the element that is
    greatest, according to the comparator object.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: '*优先队列*（也叫堆）是一种支持 `push` 和 `pop` 操作的数据结构，它根据某个用户指定的 *比较器对象* 对元素进行排序。比较器对象是一个函数对象，接受两个参数，并在第一个参数小于第二个参数时返回
    `true`。当你从优先队列中 `pop` 一个元素时，你会移除根据比较器对象确定的最大元素。'
- en: 'The STL offers the `std::priority_queue` in the `<queue>` header. A `priority_queue`
    has three template parameters:'
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: STL 提供了 `<queue>` 头文件中的 `std::priority_queue`。`priority_queue` 有三个模板参数：
- en: The underlying type of the wrapped container
  id: totrans-314
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 包装容器的底层类型
- en: The type of the wrapped container
  id: totrans-315
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 包装容器的类型
- en: The type of the comparator object
  id: totrans-316
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 比较器对象的类型
- en: Only the underlying type is mandatory. The wrapped container type defaults to
    `vector` (probably because it’s the most widely used sequential container), and
    the comparator object type defaults to `std::less`.
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 只有底层类型是必需的。包装容器类型默认为 `vector`（可能因为它是最常用的顺序容器），比较器对象类型默认为 `std::less`。
- en: '**NOTE**'
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*The `std::less` class template is available from the `<functional>` header,
    and it returns `true` if the first argument is less than the second.*'
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: '*`std::less` 类模板可在 `<functional>` 头文件中找到，如果第一个参数小于第二个参数，则返回 `true`。*'
- en: The `priority_queue` has an identical interface to a `stack`. The only difference
    is that stacks `pop` elements according to the last-in, first-out arrangement,
    whereas priority queues `pop` elements according to the comparator object criteria.
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: '`priority_queue` 的接口与 `stack` 相同。唯一的区别是栈按照后进先出的顺序 `pop` 元素，而优先队列则根据比较器对象的标准来
    `pop` 元素。'
- en: '[Listing 13-21](ch13.xhtml#ch13ex21) illustrates the basic usage of `priority_queue`.'
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: '[清单 13-21](ch13.xhtml#ch13ex21) 展示了 `priority_queue` 的基本用法。'
- en: '[PRE20]'
  id: totrans-322
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: '*Listing 13-21: Basic `priority_queue` usage*'
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 13-21：`priority_queue` 的基本用法*'
- en: Here, you default construct a `priority_queue` ➊, which internally initializes
    an empty `vector` to hold its elements. You push the elements 1.0, 2.0, and 1.5
    into the `priority_queue`, which sorts the elements in descending order so the
    container represents them in the order 2.0 1.5 1.0.
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，你默认构造一个 `priority_queue` ➊，它内部初始化一个空的 `vector` 来存储元素。你将元素 1.0、2.0 和 1.5
    推入 `priority_queue`，它会按降序对元素进行排序，因此容器中的元素顺序是 2.0 1.5 1.0。
- en: You assert that `top` yields 2.0 ➋, pop this element off the `priority_queue`,
    and then invoke `push` with the new element 1.0\. The container now represents
    them in the order 1.5 ➌ 1.0 ➍ 1.0 ➎, which you verify with a series of `top`-`pop`
    operations until the container is empty ➏.
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 你确认 `top` 返回的是 2.0 ➋，然后从 `priority_queue` 中移除该元素，再用新元素 1.0 调用 `push`。此时容器中的元素顺序变为
    1.5 ➌ 1.0 ➍ 1.0 ➎，你通过一系列的 `top` 和 `pop` 操作验证这一点，直到容器为空 ➏。
- en: '**NOTE**'
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*A `priority_queue` holds its elements in a tree structure, so if you peered
    into its underlying container, the memory ordering wouldn’t match the orders implied
    by [Listing 13-21](ch13.xhtml#ch13ex21).*'
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: '*`priority_queue` 将其元素存储在树结构中，因此如果你查看其底层容器，内存顺序将与 [清单 13-21](ch13.xhtml#ch13ex21)
    所示的顺序不匹配。*'
- en: '[Table 13-7](ch13.xhtml#ch13tab07) summarizes the operations of `priority_queue`.
    In this table, `pq`, `pq1`, and `pq2` are of type `std::priority_queue<T>`; `t`
    is of type `T`; `ctr` is a container of type `ctr_type<T>`; and `srt` is a container
    of type `srt_type<T>`.'
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: '[表 13-7](ch13.xhtml#ch13tab07) 总结了 `priority_queue` 的操作。在此表中，`pq`、`pq1` 和 `pq2`
    的类型是 `std::priority_queue<T>`；`t` 的类型是 `T`；`ctr` 是类型为 `ctr_type<T>` 的容器；`srt`
    是类型为 `srt_type<T>` 的容器。'
- en: '**Table 13-7:** A Summary of `std::priority_queue` Operations'
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: '**表 13-7：** `std::priority_queue` 操作总结'
- en: '| **Operation** | **Notes** |'
  id: totrans-330
  prefs: []
  type: TYPE_TB
  zh: '| **操作** | **说明** |'
- en: '| `priority_queue <`T`,` `[`ctr_type<T>`],` `[`cmp_type`]>([`cmp`], [`ctr`])`
    | Constructs a `priority_queue` of Ts using ctr as its internal container and
    srt as its comparator object. If no container is provided, constructs an empty
    `deque`. Uses `std::less` as default sorter. |'
  id: totrans-331
  prefs: []
  type: TYPE_TB
  zh: '| `priority_queue <`T`,` `[`ctr_type<T>`],` `[`cmp_type`]>([`cmp`], [`ctr`])`
    | 使用`ctr`作为内部容器，`srt`作为比较器对象，构造一个`priority_queue`。如果没有提供容器，则构造一个空的`deque`，并默认使用`std::less`作为排序器。
    |'
- en: '| pq`.empty()` | Returns `true` if container is empty. |'
  id: totrans-332
  prefs: []
  type: TYPE_TB
  zh: '| pq`.empty()` | 如果容器为空，返回`true`。 |'
- en: '| pq`.size()` | Returns number of elements in container. |'
  id: totrans-333
  prefs: []
  type: TYPE_TB
  zh: '| pq`.size()` | 返回容器中的元素数量。 |'
- en: '| pq`.top()` | Returns a reference to the greatest element in the container.
    |'
  id: totrans-334
  prefs: []
  type: TYPE_TB
  zh: '| pq`.top()` | 返回容器中最大元素的引用。 |'
- en: '| pq`.push(`t`)` | Puts a copy of t onto the end of the container. |'
  id: totrans-335
  prefs: []
  type: TYPE_TB
  zh: '| pq`.push(`t`)` | 将t的副本放到容器的末尾。 |'
- en: '| pq`.emplace(`...`)` | Constructs a T in place by forwarding ... to the appropriate
    constructor. |'
  id: totrans-336
  prefs: []
  type: TYPE_TB
  zh: '| pq`.emplace(`...`)` | 通过转发...到适当的构造函数来原地构造一个T。 |'
- en: '| pq`.pop()` | Removes the element at the end of the container. |'
  id: totrans-337
  prefs: []
  type: TYPE_TB
  zh: '| pq`.pop()` | 移除容器末尾的元素。 |'
- en: '| pq1`.swap(`pq2`) swap(`pq1`,` pq2`)` | Exchanges the contents of s2 with
    s1. |'
  id: totrans-338
  prefs: []
  type: TYPE_TB
  zh: '| pq1`.swap(`pq2`) swap(`pq1`,` pq2`)` | 交换s2和s1的内容。 |'
- en: '**Bitsets**'
  id: totrans-339
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**Bitsets**'
- en: A *bitset* is a data structure that stores a fixed-size bit sequence. You can
    manipulate each bit.
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: '*bitset*是一种存储固定大小位序列的数据结构。你可以操作每一位。'
- en: The STL offers the `std::bitset` in the `<bitset>` header. The class template
    `bitset` takes a single template parameter corresponding to the desired size.
    You could achieve similar functionality using a `bool array`, but `bitset` is
    optimized for space efficiency and provides some special convenience operations.
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: STL提供了`std::bitset`，位于`<bitset>`头文件中。类模板`bitset`接受一个对应所需大小的单一模板参数。你也可以使用`bool数组`实现类似的功能，但`bitset`在空间效率上进行了优化，并提供了一些特殊的便捷操作。
- en: '**NOTE**'
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*The STL specializes `std::vector<bool>`, so it might benefit from the same
    space efficiencies as `bitset`. (Recall from “Template Specialization” on [page
    178](ch06.xhtml#page_178) that template specialization is the process of making
    certain kinds of template instantiations more efficient.) Boost offers `boost::dynamic_bitset`,
    which provides dynamic sizing at runtime.*'
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: '*STL专门化了`std::vector<bool>`，因此它可能像`bitset`一样从相同的空间效率中受益。（回想一下在[第178页](ch06.xhtml#page_178)的“模板特化”中提到的，模板特化是使某些类型的模板实例化更加高效的过程。）Boost提供了`boost::dynamic_bitset`，它在运行时提供动态大小。*'
- en: A default constructed `bitset` contains all zero (false) bits. To initialize
    bitsets with other contents, you can provide an `unsigned long long` value. This
    integer’s bitwise representation sets the value of `bitset`. You can access individual
    bits in the `bitset` using `operator[]`. [Listing 13-22](ch13.xhtml#ch13ex22)
    demonstrates how to initialize a `bitset` with an integer literal and extract
    its elements.
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 默认构造的`bitset`包含所有零（假）位。要初始化具有其他内容的`bitset`，你可以提供一个`unsigned long long`值。该整数的按位表示设置`bitset`的值。你可以使用`operator[]`访问`bitset`中的单个位。[列表13-22](ch13.xhtml#ch13ex22)展示了如何用整数字面量初始化`bitset`并提取其元素。
- en: '[PRE21]'
  id: totrans-345
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: '*Listing 13-22: Initializing a `bitset` with an integer*'
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表13-22：使用整数初始化`bitset`*'
- en: You initialize a `bitset` with the 4-bit *nybble* `0101` ➊. So, the first ➋
    and third ➍ elements are zero, and the second ➌ and fourth ➎ elements are 1.
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 你用4位*nybble* `0101` ➊初始化一个`bitset`。因此，第一 ➋ 和第三 ➍ 个元素为零，第二 ➌ 和第四 ➎ 个元素为1。
- en: You can also provide a string representation of the desired `bitset`, as shown
    in [Listing 13-23](ch13.xhtml#ch13ex23).
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以提供一个字符串表示所需的`bitset`，如[列表13-23](ch13.xhtml#ch13ex23)所示。
- en: '[PRE22]'
  id: totrans-349
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: '*Listing 13-23: Initializing a `bitset` with a string*'
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表13-23：使用字符串初始化`bitset`*'
- en: Here, you construct a `bitset` called `bs1` using the same integer nybble `0b0110`
    ➊ and another `bitset` called `bs2` using the string literal `0110` ➋. Both of
    these initialization approaches produce identical `bitset` objects ➌.
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，你使用相同的整数nybble `0b0110` ➊构造一个名为`bs1`的`bitset`，并使用字符串字面量`0110` ➋构造另一个名为`bs2`的`bitset`。这两种初始化方式生成相同的`bitset`对象
    ➌。
- en: '[Table 13-8](ch13.xhtml#ch13tab08) summarizes the operations of `bitset`. In
    this table, `bs`, `bs 1`, and `bs 2` are of type `std::bitset<N>`, and `i` is
    a `size_t`.'
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: '[表13-8](ch13.xhtml#ch13tab08)总结了`bitset`的操作。在此表中，`bs`、`bs 1`和`bs 2`的类型为`std::bitset<N>`，而`i`是一个`size_t`。'
- en: '**Table 13-8:** A Summary of `std::bitset` Operations'
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: '**表13-8：** `std::bitset`操作总结'
- en: '| **Operation** | **Notes** |'
  id: totrans-354
  prefs: []
  type: TYPE_TB
  zh: '| **操作** | **说明** |'
- en: '| `bitset<`N`>([`val`])` | Constructs a `bitset` with initial value val, which
    can be either a string of 0s and 1s or an `unsigned long long`. Default constructor
    initializes all bits to zero. |'
  id: totrans-355
  prefs: []
  type: TYPE_TB
  zh: '| `bitset<`N`>([`val`])` | 构造一个初始值为val的`bitset`，其中val可以是由0和1组成的字符串或`unsigned
    long long`。默认构造函数将所有位初始化为零。 |'
- en: '| bs`[`i`]` | Returns the value of the i-th bit: 1 returns true; 0 returns
    false. |'
  id: totrans-356
  prefs: []
  type: TYPE_TB
  zh: '| bs`[`i`]` | 返回第i位的值：1返回true；0返回false。 |'
- en: '| bs`.test(`i`)` | Returns the value of the i-th bit: 1 returns true; 0 returns
    false. Performs bounds checking; throws `std::out_of_range`. |'
  id: totrans-357
  prefs: []
  type: TYPE_TB
  zh: '| bs`.test(`i`)` | 返回第i位的值：1返回true；0返回false。执行边界检查；抛出`std::out_of_range`异常。
    |'
- en: '| bs`.set()` | Sets all bits to 1. |'
  id: totrans-358
  prefs: []
  type: TYPE_TB
  zh: '| bs`.set()` | 将所有位设置为1。 |'
- en: '| bs`.set(`i`,` val`)` | Sets the i-th bit to val. Performs bounds checking;
    throws `std::out_of_range`. |'
  id: totrans-359
  prefs: []
  type: TYPE_TB
  zh: '| bs`.set(`i`,` val`)` | 将第i位设置为val。执行边界检查；抛出`std::out_of_range`异常。 |'
- en: '| bs`.reset()` | Sets all bits to 0. |'
  id: totrans-360
  prefs: []
  type: TYPE_TB
  zh: '| bs`.reset()` | 将所有位设置为0。 |'
- en: '| bs`.reset(`i`)` | Sets the i-th bit to zero. Performs bounds checking; throws
    `std::out_of_range`. |'
  id: totrans-361
  prefs: []
  type: TYPE_TB
  zh: '| bs`.reset(`i`)` | 将第i位设置为零。执行边界检查；抛出`std::out_of_range`异常。 |'
- en: '| bs`.flip()` | Flips all the bits: (0 becomes 1; 1 becomes 0). |'
  id: totrans-362
  prefs: []
  type: TYPE_TB
  zh: '| bs`.flip()` | 翻转所有位：(0变为1；1变为0)。 |'
- en: '| bs`.flip(`i`)` | Flips the i-th bit. Performs bounds checking; throws `std::out_of_range`.
    |'
  id: totrans-363
  prefs: []
  type: TYPE_TB
  zh: '| bs`.flip(`i`)` | 翻转第i位。执行边界检查；抛出`std::out_of_range`异常。 |'
- en: '| bs`.count()` | Returns the number of bits set to 1. |'
  id: totrans-364
  prefs: []
  type: TYPE_TB
  zh: '| bs`.count()` | 返回设置为1的位数。 |'
- en: '| bs`.size()` | Returns the size N of the bitset. |'
  id: totrans-365
  prefs: []
  type: TYPE_TB
  zh: '| bs`.size()` | 返回`bitset`的大小N。 |'
- en: '| bs`.any()` | Returns `true` if any bits are set to 1. |'
  id: totrans-366
  prefs: []
  type: TYPE_TB
  zh: '| bs`.any()` | 如果任何位都设置为1，返回`true`。 |'
- en: '| bs`.none()` | Returns `true` if all bits are set to 0. |'
  id: totrans-367
  prefs: []
  type: TYPE_TB
  zh: '| bs`.none()` | 如果所有位都设置为0，返回`true`。 |'
- en: '| bs`.all()` | Returns `true` if all bits are set to 1. |'
  id: totrans-368
  prefs: []
  type: TYPE_TB
  zh: '| bs`.all()` | 如果所有位都设置为1，返回`true`。 |'
- en: '| bs`.to_string()` | Returns the `string` representation of the bitset. |'
  id: totrans-369
  prefs: []
  type: TYPE_TB
  zh: '| bs`.to_string()` | 返回`bitset`的`string`表示形式。 |'
- en: '| bs`.to_ulong()` | Returns the `unsigned long` representation of the bitset.
    |'
  id: totrans-370
  prefs: []
  type: TYPE_TB
  zh: '| bs`.to_ulong()` | 返回`bitset`的`unsigned long`表示形式。 |'
- en: '| bs`.to_ullong()` | Returns the `unsigned long long` representation of the
    bitset. |'
  id: totrans-371
  prefs: []
  type: TYPE_TB
  zh: '| bs`.to_ullong()` | 返回`bitset`的`unsigned long long`表示形式。 |'
- en: '**Special Sequential Boost Containers**'
  id: totrans-372
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**特殊顺序Boost容器**'
- en: Boost provides an abundance of special containers, and there simply isn’t enough
    room to explore all their features here. [Table 13-9](ch13.xhtml#ch13tab09) provides
    the names, headers, and brief descriptions of a number of them.
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: Boost提供了大量的特殊容器，这里没有足够的空间来探讨它们的所有特性。[表13-9](ch13.xhtml#ch13tab09)提供了其中一些容器的名称、头文件和简要描述。
    |
- en: '**NOTE**'
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*Refer to the Boost Container documentation for more information.*'
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: '*请参考Boost容器文档获取更多信息。*'
- en: '**Table 13-9:** Special Boost Containers'
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: '**表13-9：** 特殊Boost容器'
- en: '| **Class/Header** | **Description** |'
  id: totrans-377
  prefs: []
  type: TYPE_TB
  zh: '| **类/头文件** | **描述** |'
- en: '| `boost::intrusive::*``<boost/intrusive/*.hpp>` | Intrusive containers impose
    requirements on the elements they contain (such as inheriting from a particular
    base class). In exchange, they offer substantial performance gains. |'
  id: totrans-378
  prefs: []
  type: TYPE_TB
  zh: '| `boost::intrusive::*``<boost/intrusive/*.hpp>` | 入侵式容器对它们所包含的元素有要求（例如，元素必须继承自某个基类）。作为交换，它们提供了显著的性能提升。
    |'
- en: '| `boost::container::stable_vector``<boost/container/stable_vector.hpp>` |
    A vector without contiguous elements but guarantees that iterators and references
    to elements remain valid as long as the element isn’t erased (as with `list`).
    |'
  id: totrans-379
  prefs: []
  type: TYPE_TB
  zh: '| `boost::container::stable_vector``<boost/container/stable_vector.hpp>` |
    一个没有连续元素的向量，但保证只要元素未被删除（如同`list`一样），迭代器和对元素的引用将保持有效。 |'
- en: '| `boost::container::slist``<boost/container/slist.hpp>` | A `forward_list`
    with a fast `size` method. |'
  id: totrans-380
  prefs: []
  type: TYPE_TB
  zh: '| `boost::container::slist``<boost/container/slist.hpp>` | 一个带有快速`size`方法的`forward_list`。
    |'
- en: '| `boost::container::static_vector``<boost/container/static_vector.hpp>` |
    A hybrid between array and vector that stores a dynamic number of elements up
    to a fixed size. Elements are stored within the memory of `stable_vector`, like
    an `array`. |'
  id: totrans-381
  prefs: []
  type: TYPE_TB
  zh: '| `boost::container::static_vector``<boost/container/static_vector.hpp>` |
    介于数组和向量之间的混合容器，存储动态数量的元素，最多到固定大小。元素像`array`一样存储在`stable_vector`的内存中。 |'
- en: '| `boost::container::small_vector``<boost/container/small_vector.hpp>` | A
    `vector`-like container optimized for holding a small number of elements. Contains
    some preallocated space, avoiding dynamic allocation. |'
  id: totrans-382
  prefs: []
  type: TYPE_TB
  zh: '| `boost::container::small_vector``<boost/container/small_vector.hpp>` | 一种类似于`vector`的容器，优化用于存储少量元素。包含一些预分配的空间，避免动态分配。
    |'
- en: '| `boost::circular_buffer``<boost/circular_buffer.hpp>` | A fixed-capacity,
    queue-like container that fills elements in a circular fashion; a new element
    overwrites the oldest element once capacity is reached. |'
  id: totrans-383
  prefs: []
  type: TYPE_TB
  zh: '| `boost::circular_buffer``<boost/circular_buffer.hpp>` | 一种固定容量、类似队列的容器，以循环方式填充元素；一旦达到容量，新的元素会覆盖最旧的元素。
    |'
- en: '| `boost::multi_array``<boost/multi_array.hpp>` | An array-like container that
    accepts multiple dimensions. Rather than having, for example, an array of arrays
    of arrays, you can specify a three-dimensional `multi_array` x that allows element
    access, such as x`[5][1][2]`. |'
  id: totrans-384
  prefs: []
  type: TYPE_TB
  zh: '| `boost::multi_array``<boost/multi_array.hpp>` | 一种类似数组的容器，接受多维度。你可以指定一个三维的
    `multi_array` x，而不是例如多个数组的数组，从而允许元素访问，如 x`[5][1][2]`。 |'
- en: '| `boost::ptr_vector``boost::ptr_list``<boost/ptr_container/*.hpp>` | Having
    a collection of smart pointers can be suboptimal. Pointer vectors manage a collection
    of dynamic objects in a more efficient and user-friendly way. |'
  id: totrans-385
  prefs: []
  type: TYPE_TB
  zh: '| `boost::ptr_vector``boost::ptr_list``<boost/ptr_container/*.hpp>` | 拥有智能指针集合可能不是最优的选择。指针向量以更高效和用户友好的方式管理动态对象集合。
    |'
- en: '**NOTE**'
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*Boost Intrusive also contains some specialized containers that provide performance
    benefits in certain situations. These are primarily useful for library implementers.*'
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: '*Boost Intrusive 还包含一些专用的容器，在某些情况下提供性能优势。这些容器主要对于库的实现者有用。*'
- en: '**Associative Containers**'
  id: totrans-388
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**关联容器**'
- en: '*Associative containers* allow for very fast element search. Sequential containers
    have some natural ordering that allows you to iterate from the beginning of the
    container to the end in a well-specified order. Associative containers are a bit
    different. This container family splits along three axes:'
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: '*关联容器* 允许非常快速的元素搜索。顺序容器具有某种自然顺序，允许你从容器的开始迭代到结束，并按照特定顺序进行遍历。关联容器略有不同，这个容器家族沿着三个轴进行划分：'
- en: Whether elements contain keys (a set) or key-value pairs (a map)
  id: totrans-390
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 元素是否包含键（一个集合）或键值对（一个映射）
- en: Whether elements are ordered
  id: totrans-391
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 元素是否有序
- en: Whether keys are *unique*
  id: totrans-392
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 键是否是 *唯一* 的
- en: '***Sets***'
  id: totrans-393
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***集合***'
- en: The `std::set` available in the STL’s `<set>` header is an associative container
    that contains sorted, unique elements called *keys*. Because `set` stores sorted
    elements, you can insert, remove, and search efficiently. In addition, `set` supports
    sorted iteration over its elements, and you have complete control over how keys
    sort using comparator objects.
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: STL 中 `<set>` 头文件提供的 `std::set` 是一个关联容器，包含已排序的唯一元素，称为 *键*。因为 `set` 存储的是排序元素，你可以高效地进行插入、删除和查找操作。此外，`set`
    支持对其元素进行有序迭代，并且你可以通过比较器对象完全控制键的排序方式。
- en: '**NOTE**'
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*Boost also provides a `boost::container::set` in the `<boost/container/set.hpp>`
    header.*'
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
  zh: '*Boost 还提供了 `<boost/container/set.hpp>` 头文件中的 `boost::container::set`。*'
- en: '**Constructing**'
  id: totrans-397
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**构造**'
- en: 'The class template `set<T, Comparator, Allocator>` takes three template parameters:'
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
  zh: 类模板 `set<T, Comparator, Allocator>` 接受三个模板参数：
- en: The key type `T`
  id: totrans-399
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 键类型 `T`
- en: The comparator type that defaults to `std::less`
  id: totrans-400
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 比较器类型默认为 `std::less`
- en: The allocator type that defaults to `std::allocator<T>`
  id: totrans-401
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 分配器类型默认为 `std::allocator<T>`
- en: 'You have a lot of flexibility when constructing `set`s. Each of the following
    constructors accepts an optional comparator and allocator (whose types must match
    their corresponding template parameters):'
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
  zh: 构造 `set` 时你有很大的灵活性。以下每个构造函数都接受一个可选的比较器和分配器（其类型必须与相应的模板参数匹配）：
- en: A default constructor that initializes an empty `set`
  id: totrans-403
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个默认构造函数，初始化一个空的 `set`
- en: Move and copy constructors with the usual behavior
  id: totrans-404
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 移动和复制构造函数具有常见的行为
- en: A range constructor that copies the elements from the range into the set
  id: totrans-405
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个范围构造函数，将范围内的元素复制到集合中
- en: A braced initializer
  id: totrans-406
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个大括号初始化器
- en: '[Listing 13-24](ch13.xhtml#ch13ex24) showcases each of these constructors.'
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
  zh: '[列表 13-24](ch13.xhtml#ch13ex24) 展示了这些构造函数的每一个。'
- en: '[PRE23]'
  id: totrans-408
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: '*Listing 13-24: The constructors of a `set`*'
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 13-24：`set` 的构造函数*'
- en: You default construct ➊ and brace initialize ➋ two different `set`s. The default
    constructed `set` called `emp` is empty ➌, and the braced initialized `set` called
    `fib` has four elements ➍. You include five elements in the braced initializer,
    so why only four elements? Recall that `set` elements are unique, so the 1 enters
    only once.
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以默认构造 ➊ 和大括号初始化 ➋ 两个不同的 `set`。默认构造的 `set` 叫做 `emp`，是空的 ➌，而大括号初始化的 `set` 叫做
    `fib`，包含四个元素 ➍。你在大括号初始化器中包括了五个元素，那为什么只有四个元素？回想一下，`set` 的元素是唯一的，因此 1 只会出现一次。
- en: Next, you copy construct `fib`, which results in two `set`s with size 4 ➎ ➏.
    On the other hand, the move constructor empties the moved-from set ➐ and transfers
    the elements to the new `set` ➑.
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，你复制构造了 `fib`，这将导致两个 `set`，其大小为 4 ➎ ➏。另一方面，移动构造函数会清空被移动的 `set` ➐ 并将元素转移到新的
    `set` ➑。
- en: Then you can initialize a `set` from a range. You construct an `array` with
    five elements and then pass it as a range to a `set` constructor using the `cbegin`
    and `cend` methods. As with the braced initialization earlier in the code, the
    `set` contains only four elements because duplicates are discarded ➒.
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，你可以从一个区间初始化一个 `set`。你构造了一个包含五个元素的 `array`，然后将其作为区间传递给 `set` 构造函数，使用 `cbegin`
    和 `cend` 方法。与之前代码中的花括号初始化一样，`set` 只包含四个元素，因为重复的元素会被丢弃 ➒。
- en: '**Move and Copy Semantics**'
  id: totrans-413
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**移动与复制语义**'
- en: In addition to move/copy constructors, move/copy assignment operators are also
    available. As with other container copy operations, `set` copies are potentially
    very slow because each element needs to get copied, and move operations are usually
    fast because elements reside in dynamic memory. A `set` can simply pass ownership
    without disturbing the elements.
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
  zh: 除了移动/复制构造函数外，还提供了移动/复制赋值操作符。与其他容器的复制操作一样，`set` 的复制操作可能非常慢，因为每个元素都需要被复制，而移动操作通常很快，因为元素存储在动态内存中。`set`
    可以简单地传递所有权，而不干扰元素。
- en: '**Element Access**'
  id: totrans-415
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**元素访问**'
- en: You have several options for extracting elements from a `set`. The basic method
    is `find`, which takes a `const` reference to a key and returns an iterator. If
    the `set` contains an element-matching key, `find` will return an iterator pointing
    to the found element. If the `set` does not, it will return an iterator pointing
    to `end`. The `lower_bound` method returns an iterator to the first element *not
    less than* the key argument, whereas the `upper_bound` method returns the first
    element *greater than* the given key.
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
  zh: 你有几种方法可以从 `set` 中提取元素。基本方法是 `find`，它接受一个键的 `const` 引用并返回一个迭代器。如果 `set` 包含与键匹配的元素，`find`
    将返回一个指向找到元素的迭代器。如果 `set` 中没有该元素，它将返回指向 `end` 的迭代器。`lower_bound` 方法返回一个指向第一个*不小于*键参数的元素的迭代器，而
    `upper_bound` 方法返回第一个*大于*给定键的元素。
- en: 'The `set` class supports two additional lookup methods, mainly for compatibility
    of non-unique associative containers:'
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
  zh: '`set` 类支持两种额外的查找方法，主要是为了兼容非唯一的关联容器：'
- en: The `count` method returns the number of elements matching the key. Because
    `set` elements are unique, `count` returns either 0 or 1.
  id: totrans-418
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`count` 方法返回与键匹配的元素的数量。由于 `set` 中的元素是唯一的，`count` 要么返回 0，要么返回 1。'
- en: The `equal_range` method returns a half-open range containing all the elements
    matching the given key. The range returns a `std::pair` of iterators with `first`
    pointing to the matching element and `second` pointing to the element after `first`.
    If `equal_range` finds no matching element, `first` and `second` both point to
    the first element greater than the given key. In other words, the pair returned
    by `equal_range` is equivalent to a `pair` of `lower_bound` as `first` and `upper_bound`
    as `second`.
  id: totrans-419
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`equal_range` 方法返回一个半开区间，其中包含所有与给定键匹配的元素。该区间返回一个 `std::pair` 迭代器，`first` 指向匹配的元素，`second`
    指向 `first` 之后的元素。如果 `equal_range` 没有找到匹配的元素，`first` 和 `second` 都会指向第一个大于给定键的元素。换句话说，`equal_range`
    返回的 `pair` 等价于 `lower_bound` 的 `first` 和 `upper_bound` 的 `second`。'
- en: '[Listing 13-25](ch13.xhtml#ch13ex25) illustrates these two access methods.'
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
  zh: '[列表 13-25](ch13.xhtml#ch13ex25) 演示了这两种访问方法。'
- en: '[PRE24]'
  id: totrans-421
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: '*Listing 13-25: A `set` member access*'
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 13-25：`set` 成员访问*'
- en: First, you construct a `set` with the four elements 1 2 3 5 ➊. Using `find`,
    you can extract an iterator to the element 3\. You can also determine that 8 isn’t
    in the `set`, because `find` returns an iterator pointing to `end` ➋. You can
    determine similar information with `count`, which returns 1 when you give the
    key 3 and 0 when you give the key 8 ➌. When you pass 3 to the `lower_bound` method,
    it returns an iterator pointing to 3 because this is the first element that’s
    not less than the argument ➍. When you pass this to `upper_bound`, on the other
    hand, you obtain a pointer to the element 5, because this is the first element
    greater than the argument ➎. Finally, when you pass 3 to the `equal_range` method,
    you obtain a `pair` of iterators. The `first` iterator points to 3, and the `second`
    iterator points to 5, the element just after 3 ➏.
  id: totrans-423
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，你构造一个包含四个元素1、2、3、5的`set` ➊。使用`find`，你可以获取指向元素3的迭代器。你也可以确定8不在`set`中，因为`find`返回一个指向`end`的迭代器
    ➋。你可以使用`count`获取类似的信息，当你传入键3时返回1，当你传入键8时返回0 ➌。当你将3传递给`lower_bound`方法时，它返回指向3的迭代器，因为这是第一个不小于给定参数的元素
    ➍。另一方面，当你将其传递给`upper_bound`时，你得到指向元素5的指针，因为这是第一个大于给定参数的元素 ➎。最后，当你将3传递给`equal_range`方法时，你得到一对迭代器。`first`迭代器指向3，`second`迭代器指向5，即紧跟在3后面的元素
    ➏。
- en: A `set` also exposes iterators through its `begin` and `end` methods, so you
    can use range-based `for` loops to iterate through the `set` from least element
    to greatest.
  id: totrans-424
  prefs: []
  type: TYPE_NORMAL
  zh: '`set`还通过其`begin`和`end`方法暴露迭代器，因此你可以使用基于范围的`for`循环从最小元素到最大元素遍历`set`。'
- en: '**Adding Elements**'
  id: totrans-425
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**添加元素**'
- en: 'You have three options when adding elements to a `set`:'
  id: totrans-426
  prefs: []
  type: TYPE_NORMAL
  zh: 当向`set`中添加元素时，你有三种选择：
- en: '`insert` to copy an existing element into the `set`'
  id: totrans-427
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`insert`：将一个现有元素复制到`set`中'
- en: '`emplace` to in-place construct a new element into the `set`'
  id: totrans-428
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`emplace`：在`set`中原地构造一个新元素'
- en: '`emplace_hint` to in-place construct a new element, just like `emplace` (because
    adding an element requires sorting). The difference is the `emplace_hint` method
    takes an iterator as its first argument. This iterator is the search’s starting
    point (a hint). If the iterator is close to the correct position for the newly
    inserted element, this can provide a substantial speedup.'
  id: totrans-429
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`emplace_hint`：像`emplace`一样原地构造一个新元素（因为添加元素需要排序）。不同之处在于，`emplace_hint`方法将一个迭代器作为第一个参数。这个迭代器是搜索的起点（提示）。如果迭代器接近新插入元素的正确位置，这可以显著提高效率。'
- en: '[Listing 13-26](ch13.xhtml#ch13ex26) illustrates the several ways to insert
    elements into a `set`.'
  id: totrans-430
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '[Listing 13-26](ch13.xhtml#ch13ex26)展示了将元素插入到`set`中的几种方式。'
- en: '[PRE25]'
  id: totrans-431
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: '*Listing 13-26: Inserting into a `set`*'
  id: totrans-432
  prefs: []
  type: TYPE_NORMAL
  zh: '*Listing 13-26: 向`set`中插入元素*'
- en: Both `insert` ➊ and `emplace` ➋ add the element 8 into `fib`, so when you invoke
    `find` with 8, you get an iterator pointing to the new element. You can achieve
    the same effect a bit more efficiently with `emplace_hint` ➌. Because you know
    ahead of time that the new element 8 is greater than all the other elements in
    the `set`, you can use `end` as the hint.
  id: totrans-433
  prefs: []
  type: TYPE_NORMAL
  zh: '`insert` ➊和`emplace` ➋都会将元素8添加到`fib`中，因此当你用8调用`find`时，你会得到一个指向新元素的迭代器。你可以用`emplace_hint`
    ➌以更高效的方式实现相同的效果。因为你预先知道新元素8大于`set`中的所有其他元素，所以你可以使用`end`作为提示。'
- en: If you attempt to `insert`, `emplace`, or `emplace_hint` a key that’s already
    present in the `set`, the operation has no effect. All three of these methods
    return a `std::pair<Iterator, bool>` where the `second` element indicates whether
    the operation resulted in insertion (`true`) or not (`false`). The iterator at
    `first` points to either the newly inserted element or the existing element that
    prevented insertion.
  id: totrans-434
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你尝试将一个已经存在于`set`中的键通过`insert`、`emplace`或`emplace_hint`插入，那么操作将没有任何效果。这三种方法都会返回一个`std::pair<Iterator,
    bool>`，其中`second`元素表示操作是否导致了插入（`true`）或没有插入（`false`）。`first`指向的迭代器指向的是新插入的元素，或者是阻止插入的现有元素。
- en: '**Removing Elements**'
  id: totrans-435
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**移除元素**'
- en: You can remove elements from a set using `erase`, which is overloaded to accept
    a key, an iterator, or a half-open range, as shown in [Listing 13-27](ch13.xhtml#ch13ex27).
  id: totrans-436
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用`erase`方法从`set`中移除元素，`erase`被重载以接受一个键、一个迭代器或一个半开区间，如[Listing 13-27](ch13.xhtml#ch13ex27)所示。
- en: '[PRE26]'
  id: totrans-437
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: '*Listing 13-27: Removing from a `set`*'
  id: totrans-438
  prefs: []
  type: TYPE_NORMAL
  zh: '*Listing 13-27: 从`set`中移除元素*'
- en: In the first test, you call `erase` with the key 3, which removes the corresponding
    element from the `set`. When you invoke `find` on 3, you get an iterator pointing
    to the `end`, indicating that no matching element was found ➊. In the second test,
    you invoke `clear`, which eliminates all the elements from the `set` ➋.
  id: totrans-439
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一个测试中，你使用键值 3 调用 `erase`，这将从 `set` 中移除相应的元素。当你在 3 上调用 `find` 时，返回一个指向 `end`
    的迭代器，表示没有找到匹配的元素 ➊。在第二个测试中，你调用 `clear`，这会从 `set` 中删除所有元素 ➋。
- en: '**Storage Model**'
  id: totrans-440
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**存储模型**'
- en: Set operations are fast because sets are typically implemented as *red-black
    trees*. These structures treat each element as a node. Each node has one parent
    and up to two children, its left and right legs. Each node’s children are sorted
    so all children to the left are less than the children to the right. This way,
    you can perform searches much quicker than with linear iteration, as long as a
    tree’s branches are roughly balanced (equal in length). Red-black trees have additional
    facilities for rebalancing branches after insertions and deletions.
  id: totrans-441
  prefs: []
  type: TYPE_NORMAL
  zh: 集合操作速度很快，因为集合通常是通过 *红黑树* 实现的。这些结构将每个元素当作一个节点。每个节点有一个父节点和最多两个子节点，分别是左子节点和右子节点。每个节点的子节点按顺序排序，所有左子节点都小于右子节点。这样，只要树的分支大致平衡（长度相等），就能比线性遍历更快地进行搜索。红黑树在插入和删除后具有重新平衡分支的附加功能。
- en: '**NOTE**'
  id: totrans-442
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*For details on red-black trees, refer to *Data Structures and Algorithms in
    C++* by Adam Drozdek.*'
  id: totrans-443
  prefs: []
  type: TYPE_NORMAL
  zh: '*有关红黑树的详细信息，请参考 Adam Drozdek 的《C++ 数据结构与算法》。*'
- en: '**A Partial List of Supported Operations**'
  id: totrans-444
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**部分支持的操作列表**'
- en: "[Table 13-10](ch13.xhtml#ch13tab10) summarizes the operations of `set`. Operations\
    \ `s`, `s1`, and `s2` are of type `std::set<T,[cmp_type<T>]>`. `T` is the contained\
    \ element/key type, and `itr`, `beg`, and `end` are `set` iterators. The variable\
    \ `t` is a `T`. A dagger (\x86)denotes a method that returns a `std::pair<Iterator,\
    \ bool>`, where the iterator points to the resulting element and the `bool` equals\
    \ `true` if the method inserted an element and `false` if the element already\
    \ existed."
  id: totrans-445
  prefs: []
  type: TYPE_NORMAL
  zh: "[表 13-10](ch13.xhtml#ch13tab10) 总结了 `set` 的操作。操作 `s`、`s1` 和 `s2` 的类型是 `std::set<T,[cmp_type<T>]>`。`T`\
    \ 是包含的元素/键类型，`itr`、`beg` 和 `end` 是 `set` 的迭代器。变量 `t` 是一个 `T`。一个十字标记 (\x86) 表示返回\
    \ `std::pair<Iterator, bool>` 的方法，其中迭代器指向结果元素，且 `bool` 等于 `true` 表示方法插入了元素，`false`\
    \ 表示元素已存在。"
- en: '**Table 13-10:** A Summary of `std::set`'
  id: totrans-446
  prefs: []
  type: TYPE_NORMAL
  zh: '**表 13-10：** `std::set` 操作总结'
- en: '| **Operation** | **Notes** |'
  id: totrans-447
  prefs: []
  type: TYPE_TB
  zh: '| **操作** | **备注** |'
- en: '| `set<`T`>{` ...`, [`cmp`], [`alc`] }` | Performs braced initialization of
    a newly constructed set. Uses cmp`=std::less<`T`>` and alc`=std::allocator<`T`>`
    by default. |'
  id: totrans-448
  prefs: []
  type: TYPE_TB
  zh: '| `set<`T`>{` ...`, [`cmp`], [`alc`] }` | 对新构造的 set 执行大括号初始化。默认使用 cmp`=std::less<`T`>`
    和 alc`=std::allocator<`T`>`。 |'
- en: '| `set<`T`>{` beg`,` end`,` `[`cmp`], [`alc`] }` | Range constructor that copies
    elements from the half-open range beg to end. Uses cmp`=std::less<`T`>` and alc`=std::allocator<`T`>`
    by default. |'
  id: totrans-449
  prefs: []
  type: TYPE_TB
  zh: '| `set<`T`>{` beg`,` end`,` `[`cmp`], [`alc`] }` | 范围构造函数，复制从半开区间 beg 到 end
    的元素。默认使用 cmp`=std::less<`T`>` 和 alc`=std::allocator<`T`>`。 |'
- en: '| `set``<`T`>(`s`)` | Deep copy of s; allocates new memory. |'
  id: totrans-450
  prefs: []
  type: TYPE_TB
  zh: '| `set<`T`>(`s`)` | 深拷贝 s；分配新内存。 |'
- en: '| `set<`T`>(move(`s`))` | Takes ownership of memory; elements in s. No allocations.
    |'
  id: totrans-451
  prefs: []
  type: TYPE_TB
  zh: '| `set<`T`>(move(`s`))` | 接管内存所有权；元素来自 s。没有分配内存。 |'
- en: '| `~set` | Destructs all elements contained by the set and releases dynamic
    memory. |'
  id: totrans-452
  prefs: []
  type: TYPE_TB
  zh: '| `~set` | 析构 set 中包含的所有元素并释放动态内存。 |'
- en: '| s1 `=` s2 | s1 destructs its elements; copies each s2 element. Only allocates
    if it needs to resize to fit s2’s elements. |'
  id: totrans-453
  prefs: []
  type: TYPE_TB
  zh: '| s1 `=` s2 | s1 析构其元素；复制每个 s2 元素。只有在需要调整大小以适应 s2 元素时才会分配内存。 |'
- en: '| s1 `= move(`s2`)` | s1 destructs its elements; moves each s2 element. Only
    allocates if it needs to resize to fit s2’s elements. |'
  id: totrans-454
  prefs: []
  type: TYPE_TB
  zh: '| s1 `= move(`s2`)` | s1 析构其元素；移动每个 s2 元素。只有在需要调整大小以适应 s2 元素时才会分配内存。 |'
- en: '| s`.begin()` | Returns an iterator pointing to the first element. |'
  id: totrans-455
  prefs: []
  type: TYPE_TB
  zh: '| s`.begin()` | 返回指向第一个元素的迭代器。 |'
- en: '| s`.cbegin()` | Returns a `const` iterator pointing to the first element.
    |'
  id: totrans-456
  prefs: []
  type: TYPE_TB
  zh: '| s`.cbegin()` | 返回指向第一个元素的 `const` 迭代器。 |'
- en: '| s`.end()` | Returns an iterator pointing to 1 past the last element. |'
  id: totrans-457
  prefs: []
  type: TYPE_TB
  zh: '| s`.end()` | 返回指向最后一个元素之后的迭代器。 |'
- en: '| s`.cend()` | Returns a `const` iterator pointing to 1 past the last element.
    |'
  id: totrans-458
  prefs: []
  type: TYPE_TB
  zh: '| s`.cend()` | 返回指向最后一个元素之后的 `const` 迭代器。 |'
- en: '| s`.find(`t`)` | Returns an iterator pointing to the element matching t or
    s.`end()` if no such element exists. |'
  id: totrans-459
  prefs: []
  type: TYPE_TB
  zh: '| s`.find(`t`)` | 返回指向匹配 t 的元素的迭代器，如果没有这样的元素则返回 s.`end()`。 |'
- en: '| s`.count(`t`)` | Returns 1 if set contains t; otherwise 0. |'
  id: totrans-460
  prefs: []
  type: TYPE_TB
  zh: '| s`.count(`t`)` | 如果 set 中包含 t，则返回 1；否则返回 0。 |'
- en: '| s`.equal_range(`t`)` | Returns a `pair` of iterators corresponding to the
    half-open range of elements matching t. |'
  id: totrans-461
  prefs: []
  type: TYPE_TB
  zh: '| s`.equal_range(`t`)` | 返回一个`pair`类型的迭代器，表示与`t`匹配的半开区间的元素。 |'
- en: '| s`.lower_bound(`t`)` | Returns an iterator pointing to the first element
    not less than t or s.`end()` if no such element exists. |'
  id: totrans-462
  prefs: []
  type: TYPE_TB
  zh: '| s`.lower_bound(`t`)` | 返回一个迭代器，指向第一个不小于`t`的元素，如果没有此类元素，则返回`s.end()`。 |'
- en: '| s`.upper_bound(`t`)` | Returns an iterator pointing to the first element
    greater than t or s.`end()` if no such element exists. |'
  id: totrans-463
  prefs: []
  type: TYPE_TB
  zh: '| s`.upper_bound(`t`)` | 返回一个迭代器，指向第一个大于`t`的元素，如果没有此类元素，则返回`s.end()`。 |'
- en: '| s`.clear()` | Removes all elements from the set. |'
  id: totrans-464
  prefs: []
  type: TYPE_TB
  zh: '| s`.clear()` | 删除集合中的所有元素。 |'
- en: '| s`.erase(`t`)` | Removes the element equal to t. |'
  id: totrans-465
  prefs: []
  type: TYPE_TB
  zh: '| s`.erase(`t`)` | 删除与`t`相等的元素。 |'
- en: '| s`.erase(`itr`)` | Removes the element pointed to by itr. |'
  id: totrans-466
  prefs: []
  type: TYPE_TB
  zh: '| s`.erase(`itr`)` | 删除`itr`指向的元素。 |'
- en: '| s`.erase(`beg`,` end`)` | Removes all elements on the half-open range from
    beg to end. |'
  id: totrans-467
  prefs: []
  type: TYPE_TB
  zh: '| s`.erase(`beg`,` end`)` | 删除从beg到end的半开区间内的所有元素。 |'
- en: "| s`.insert(`t`)` | Inserts a copy of t into the set.\x86 |"
  id: totrans-468
  prefs: []
  type: TYPE_TB
  zh: '| s`.insert(`t`)` | 将`t`的副本插入集合中。 |'
- en: "| s`.emplace(`...`)` | Constructs a T in place by forwarding the arguments\
    \ ....\x86 |"
  id: totrans-469
  prefs: []
  type: TYPE_TB
  zh: '| s`.emplace(`...`)` | 通过转发参数构造一个T。 |'
- en: "| s`.emplace_hint(`itr`,` ...`)` | Constructs a T in place by forwarding the\
    \ arguments .... Uses itr as a hint for where to insert the new element.\x86 |"
  id: totrans-470
  prefs: []
  type: TYPE_TB
  zh: '| s`.emplace_hint(`itr`,` ...`)` | 通过转发参数构造一个T，并使用`itr`作为提示，指示插入新元素的位置。 |'
- en: '| s`.empty()` | Returns `true` if set’s size is zero; otherwise `false`. |'
  id: totrans-471
  prefs: []
  type: TYPE_TB
  zh: '| s`.empty()` | 如果集合的大小为零，返回`true`；否则返回`false`。 |'
- en: '| s`.size()` | Returns the number of elements in the set. |'
  id: totrans-472
  prefs: []
  type: TYPE_TB
  zh: '| s`.size()` | 返回集合中的元素数量。 |'
- en: '| s`.max_size()` | Returns the maximum number of elements in the set. |'
  id: totrans-473
  prefs: []
  type: TYPE_TB
  zh: '| s`.max_size()` | 返回集合中元素的最大数量。 |'
- en: '| s`.extract(`t`)`s`.extract(`itr`)` | Obtains a node handle that owns the
    element matching t or pointed to by itr. (This is the only way to remove a move-only
    element.) |'
  id: totrans-474
  prefs: []
  type: TYPE_TB
  zh: '| s`.extract(`t`)`s`.extract(`itr`)` | 获取一个节点句柄，拥有匹配`t`或由`itr`指向的元素。（这是移除仅能移动的元素的唯一方法。）
    |'
- en: '| s1`.merge(`s2`)`s1`.merge(move(`s2`))` | Splices each element of s2 into
    s1. If argument is an rvalue, will move the elements into s1. |'
  id: totrans-475
  prefs: []
  type: TYPE_TB
  zh: '| s1`.merge(`s2`)`s1`.merge(move(`s2`))` | 将`s2`中的每个元素合并到`s1`中。如果参数是右值，则将元素移动到`s1`中。
    |'
- en: '| s1`.swap(`s2`)``swap(`s1`,` s2`)` | Exchanges each element of s1 with those
    of s2. |'
  id: totrans-476
  prefs: []
  type: TYPE_TB
  zh: '| s1`.swap(`s2`)` `swap(`s1`,` s2`)` | 交换`s1`和`s2`中的每个元素。 |'
- en: '**Multisets**'
  id: totrans-477
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**多重集合（Multisets）**'
- en: 'The `std::multiset` available in the STL’s `<set>` header is an associative
    container that contains sorted, *non-unique* keys. A `multiset` supports the same
    operations as a `set`, but it will store redundant elements. This has important
    ramifications for two methods:'
  id: totrans-478
  prefs: []
  type: TYPE_NORMAL
  zh: STL的`<set>`头文件中提供的`std::multiset`是一个关联容器，包含排序的、*非唯一*的键。`multiset`支持与`set`相同的操作，但它会存储冗余的元素。这对以下两种方法有重要影响：
- en: The method `count` can return values other than 0 or 1\. The `count` method
    of `multiset` will tell you how many elements matched the given key.
  id: totrans-479
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 方法`count`可以返回0以外的值。`multiset`的`count`方法会告诉你有多少个元素匹配给定的键。
- en: The method `equal_range` can return half-open ranges containing more than one
    element. The `equal_range` method of `multiset` will return a range containing
    all the elements matching the given key.
  id: totrans-480
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 方法`equal_range`可以返回包含多个元素的半开区间。`multiset`的`equal_range`方法将返回一个包含所有匹配给定键的元素的区间。
- en: You might want to use a `multiset` rather than a `set` if it’s important that
    you store multiple elements with the same key. For example, you could store all
    of an address’s occupants by treating the address as a key and each member of
    the house as an element. If you used a `set`, you’d be stuck having only a single
    occupant.
  id: totrans-481
  prefs: []
  type: TYPE_NORMAL
  zh: 如果需要存储多个相同键的元素，可能希望使用`multiset`而非`set`。例如，可以通过将地址作为键，并将每个住户作为元素，来存储一个地址的所有居民。如果使用`set`，则只能存储一个居民。
- en: '[Listing 13-28](ch13.xhtml#ch13ex28) illustrates using a `multiset`.'
  id: totrans-482
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 13-28](ch13.xhtml#ch13ex28)展示了如何使用`multiset`。'
- en: '[PRE27]'
  id: totrans-483
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: '*Listing 13-28: Accessing `multiset` elements*'
  id: totrans-484
  prefs: []
  type: TYPE_NORMAL
  zh: '*示例 13-28：访问`multiset`元素*'
- en: Unlike `set` in [Listing 13-24](ch13.xhtml#ch13ex24), `multiset` permits multiple
    1s, so size returns 5, the number of elements you provided in the braced initializers
    ➊. When you count the number of 1s, you get 2 ➋. You can use `equal_range` to
    iterate over these elements. Using structured binding syntax, you obtain a `begin`
    and `end` iterator ➌. You iterate over the two 1s ➍ ➎ and arrive at the end of
    the half-open range ➏.
  id: totrans-485
  prefs: []
  type: TYPE_NORMAL
  zh: 与 [Listing 13-24](ch13.xhtml#ch13ex24) 中的 `set` 不同，`multiset` 允许多个 1，因此 size
    返回 5，即你在大括号初始化器中提供的元素数量 ➊。当你计算 1 的数量时，你会得到 2 ➋。你可以使用 `equal_range` 来遍历这些元素。使用结构化绑定语法，你可以获得
    `begin` 和 `end` 迭代器 ➌。你遍历这两个 1 ➎，然后到达半开区间的结束位置 ➏。
- en: Every operation in [Table 13-10](ch13.xhtml#ch13tab10) works for `multiset`.
  id: totrans-486
  prefs: []
  type: TYPE_NORMAL
  zh: '[表 13-10](ch13.xhtml#ch13tab10) 中的每个操作都适用于 `multiset`。'
- en: '**NOTE**'
  id: totrans-487
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*Boost also provides a `boost::container::multiset` in the `<boost/container/set.hpp>`
    header.*'
  id: totrans-488
  prefs: []
  type: TYPE_NORMAL
  zh: '*Boost 还在 `<boost/container/set.hpp>` 头文件中提供了一个 `boost::container::multiset`。*'
- en: '***Unordered Sets***'
  id: totrans-489
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***无序集合***'
- en: The `std::unordered_set` available in the STL’s `<unordered_set>` header is
    an associative container that contains *unsorted*, unique keys. The `unordered_set`
    supports most of the same operations as `set` and `multiset`, but its internal
    storage model is completely different.
  id: totrans-490
  prefs: []
  type: TYPE_NORMAL
  zh: STL 中 `<unordered_set>` 头文件提供的 `std::unordered_set` 是一个关联容器，包含 *无序*、唯一的键。`unordered_set`
    支持与 `set` 和 `multiset` 相同的大多数操作，但其内部存储模型完全不同。
- en: '**NOTE**'
  id: totrans-491
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*Boost also provides a `boost::unordered_set` in the `<boost/unordered_set.hpp>`
    header.*'
  id: totrans-492
  prefs: []
  type: TYPE_NORMAL
  zh: '*Boost 还在 `<boost/unordered_set.hpp>` 头文件中提供了一个 `boost::unordered_set`。*'
- en: Rather than using a comparator to sort elements into a red-black tree, an `unordered_set`
    is usually implemented as a hash table. You might want to use an `unordered_set`
    in a situation in which there is no natural ordering among the keys and you don’t
    need to iterate through the collection in such an order. You might find that in
    many situations, you could use either a `set` or an `unordered_set`. Although
    they appear quite similar, their internal representations are fundamentally different,
    so they’ll have different performance characteristics. If performance is an issue,
    measure how both perform and use the one that’s more appropriate.
  id: totrans-493
  prefs: []
  type: TYPE_NORMAL
  zh: 与使用比较器将元素排序到红黑树中不同，`unordered_set` 通常实现为哈希表。在没有自然顺序的键，并且不需要按照特定顺序遍历集合的情况下，你可能会希望使用
    `unordered_set`。你可能会发现，在许多情况下，你可以使用 `set` 或 `unordered_set`。尽管它们看起来非常相似，但它们的内部表示方式是根本不同的，因此它们的性能特点也会有所不同。如果性能是一个问题，测量两者的表现，并使用更合适的那一个。
- en: '**Storage Model: Hash Tables**'
  id: totrans-494
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**存储模型：哈希表**'
- en: A hash function, or a *hasher*, is a function that accepts a key and returns
    a unique `size_t` value called a hash code. The `unordered_set` organizes its
    elements into a hash table, which associates a hash code with a collection of
    one or more elements called a *bucket*. To find an element, an `unordered_set`
    computes its hash code and then searches through the corresponding bucket in the
    hash table.
  id: totrans-495
  prefs: []
  type: TYPE_NORMAL
  zh: 哈希函数，或称为 *哈希器*，是一个接受键并返回一个唯一的 `size_t` 值，称为哈希码的函数。`unordered_set` 将其元素组织成一个哈希表，哈希表将哈希码与一个或多个元素的集合（称为
    *桶*）关联起来。为了查找元素，`unordered_set` 会计算它的哈希码，然后在哈希表中搜索对应的桶。
- en: If you’ve never seen a hash table before, this information might be a lot to
    take in, so let’s look at an example. Imagine you had a large group of people
    that you needed to sort into some kind of sensible groups to find an individual
    easily. You could group people by birthday, which would give you 365 groups (well,
    366 if you count February 29 for leap years). The birthday is like a hash function
    that returns one of 365 values for each person. Each value forms a bucket, and
    all people in the same bucket have the same birthday. In this example, to find
    a person, you first determine their birthday, which gives you the correct bucket.
    Then you can search through the bucket to find the person you’re looking for.
  id: totrans-496
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你从未见过哈希表，可能会觉得这信息有些难以理解，那么我们来看一个例子。假设你有一大群人，需要将他们分成一些有意义的组，以便更容易地找到某个人。你可以按照生日将人分组，这样你会得到
    365 个组（如果你算上闰年的 2 月 29 日，就有 366 个组）。生日就像是一个哈希函数，为每个人返回 365 个值中的一个。每个值形成一个桶，所有在同一个桶中的人有着相同的生日。在这个例子中，要找到某个人，你首先确定他的生日，这样就能找到正确的桶。然后，你可以在桶中搜索，找到你要找的人。
- en: 'As long as the hash function is quick and there aren’t too many elements per
    bucket, `unordered_set`s have even more impressive performance than their ordered
    counterparts: the contained element count doesn’t increase insertion, search,
    and deletion times. When two different keys have the same hash code, it’s called
    a *hash collision*. When you have a hash collision, it means that the two keys
    will reside in the same bucket. In the preceding birthday example, many people
    will have the same birthday, so there will be a lot of hash collisions. The more
    hash collisions there are, the larger the buckets will be, and the more time you’ll
    spend searching through a bucket for the correct element.'
  id: totrans-497
  prefs: []
  type: TYPE_NORMAL
  zh: 只要哈希函数足够快速，并且每个桶中的元素数量不太多，`unordered_set` 的性能比它们有序的对等物更为出色：包含的元素数不会增加插入、搜索和删除的时间。当两个不同的键有相同的哈希值时，称为
    *哈希冲突*。当发生哈希冲突时，意味着这两个键会在同一个桶中。在前面的生日例子中，许多人会有相同的生日，因此会发生很多哈希冲突。哈希冲突越多，桶的大小越大，查找正确元素时在桶中花费的时间就越多。
- en: 'A hash function has several requirements:'
  id: totrans-498
  prefs: []
  type: TYPE_NORMAL
  zh: 哈希函数有几个要求：
- en: It accepts a `Key` and returns a `size_t` hash code.
  id: totrans-499
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它接受一个 `Key` 类型并返回一个 `size_t` 的哈希值。
- en: It doesn’t throw exceptions.
  id: totrans-500
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它不会抛出异常。
- en: Equal keys yield equal hash codes.
  id: totrans-501
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 相等的键值会产生相等的哈希值。
- en: Unequal keys yield unequal hash codes with high probability. (There is a low
    probability of a hash collision.)
  id: totrans-502
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不相等的键值通常会产生不相等的哈希值。（哈希冲突的概率很低。）
- en: The STL provides the hasher class template `std::hash<T>` in the `<functional>`
    header, which contains specializations for fundamental types, enumeration types,
    pointer types, `optional`, `variant`, smart pointers, and more. As an example,
    [Listing 13-29](ch13.xhtml#ch13ex29) illustrates how `std::hash<long>` meets the
    equivalence criteria.
  id: totrans-503
  prefs: []
  type: TYPE_NORMAL
  zh: STL 在 `<functional>` 头文件中提供了哈希器类模板 `std::hash<T>`，其中包含了基础类型、枚举类型、指针类型、`optional`、`variant`、智能指针等的特化。例如，[Listing
    13-29](ch13.xhtml#ch13ex29) 说明了 `std::hash<long>` 如何满足等价性标准。
- en: '[PRE28]'
  id: totrans-504
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: '*Listing 13-29: The `std::hash<long>` returns equal hash codes for equal keys
    and unequal hash codes for unequal keys.*'
  id: totrans-505
  prefs: []
  type: TYPE_NORMAL
  zh: '*Listing 13-29: `std::hash<long>` 为相等的键返回相等的哈希值，为不相等的键返回不相等的哈希值。*'
- en: You construct a hasher of type `std::hash<long>` ➊ and use it to compute the
    hash code of 42, storing the result into `size_t hash_code_42` ➋. When you invoke
    `hasher` with 42 again, you obtain the same value ➌. When you invoke hasher with
    `43` instead, you obtain a different value ➍.
  id: totrans-506
  prefs: []
  type: TYPE_NORMAL
  zh: 你构造了一个类型为 `std::hash<long>` 的哈希器 ➊，并用它计算了 42 的哈希值，将结果存储在 `size_t hash_code_42`
    中 ➋。当你再次使用 `hasher` 计算 42 的哈希值时，得到相同的结果 ➌。当你用 `43` 调用哈希器时，得到不同的值 ➍。
- en: Once an `unordered_set` hashes a key, it can obtain a bucket. Because the bucket
    is a list of possible matching elements, you need a function object that determines
    equality between a key and a bucket element. The STL provides the class template
    `std::equal_to<T>` in the `<functional>` header, which simply invokes `operator==`
    on its arguments, as [Listing 13-30](ch13.xhtml#ch13ex30) illustrates.
  id: totrans-507
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦 `unordered_set` 对一个键进行哈希，它就可以获得一个桶。由于桶是一个可能匹配的元素列表，你需要一个函数对象来确定键与桶元素之间的相等性。STL
    在 `<functional>` 头文件中提供了类模板 `std::equal_to<T>`，它简单地调用参数的 `operator==`，正如 [Listing
    13-30](ch13.xhtml#ch13ex30) 所示。
- en: '[PRE29]'
  id: totrans-508
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: '*Listing 13-30: The `std::equal_to<long>` calls `operator==` on its arguments
    to determine equality.*'
  id: totrans-509
  prefs: []
  type: TYPE_NORMAL
  zh: '*Listing 13-30: `std::equal_to<long>` 调用其参数的 `operator==` 来判断相等性。*'
- en: Here, you’ve initialized an `equal_to<long>` called `long_equal_to` ➊. When
    you invoke `long_equal_to` with equal arguments, it returns `true` ➋. When you
    invoke it with unequal arguments, it returns `false` ➌.
  id: totrans-510
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，你初始化了一个名为 `long_equal_to` 的 `equal_to<long>` ➊。当你用相等的参数调用 `long_equal_to`
    时，它返回 `true` ➋。当你用不相等的参数调用时，它返回 `false` ➌。
- en: '**NOTE**'
  id: totrans-511
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*For brevity, this chapter won’t cover implementing your own hashing and equivalence
    functions, which you’ll need if you want to construct unordered containers given
    user-defined key types. See [Chapter 7](ch07.xhtml#ch07) of *The C++ Standard
    Library*, 2nd Edition, by Nicolai Josuttis.*'
  id: totrans-512
  prefs: []
  type: TYPE_NORMAL
  zh: '*为了简洁，本章不讨论如何实现你自己的哈希和相等性函数，如果你想根据用户定义的键类型构造无序容器，你将需要这些函数。请参阅《C++标准库》第2版（Nicolai
    Josuttis 著）第7章。*'
- en: '**Constructing**'
  id: totrans-513
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**构造**'
- en: 'The class template `std::unordered_set<T, Hash, KeyEqual, Allocator>` takes
    four template parameters:'
  id: totrans-514
  prefs: []
  type: TYPE_NORMAL
  zh: 类模板 `std::unordered_set<T, Hash, KeyEqual, Allocator` 需要四个模板参数：
- en: Key type `T`
  id: totrans-515
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 键类型 `T`
- en: The `Hash` hash function type, which defaults to `std::hash<T>`
  id: totrans-516
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Hash` 哈希函数类型，默认值为 `std::hash<T>`'
- en: The `KeyEqual` equality function type, which defaults to `std::equal_to<T>`
  id: totrans-517
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`KeyEqual` 相等性函数类型，默认值为 `std::equal_to<T>`'
- en: The `Allocator` allocator type, which defaults to `std::allocator<T>`
  id: totrans-518
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Allocator` 分配器类型，默认为 `std::allocator<T>`'
- en: An `unordered_set` supports equivalent constructors to `set` with adjustments
    for the different template parameters (`set` needs a `Comparator`, whereas `unordered_set`
    needs a `Hash` and a `KeyEqual`). For example, you can use `unordered_set` as
    a drop-in replacement for `set` in [Listing 13-24](ch13.xhtml#ch13ex24), because
    `unordered_set` has range constructors and copy/move constructors and supports
    braced initialization.
  id: totrans-519
  prefs: []
  type: TYPE_NORMAL
  zh: '`unordered_set` 支持与 `set` 相等的构造函数，只是针对不同的模板参数做了调整（`set` 需要一个 `Comparator`，而
    `unordered_set` 需要一个 `Hash` 和 `KeyEqual`）。例如，你可以在[示例 13-24](ch13.xhtml#ch13ex24)中将
    `unordered_set` 作为 `set` 的替代品，因为 `unordered_set` 具有范围构造函数和复制/移动构造函数，并且支持花括号初始化。'
- en: '**Supported set Operations**'
  id: totrans-520
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**支持的集合操作**'
- en: An `unordered_set` supports all `set` operations in [Table 13-10](ch13.xhtml#ch13tab10)
    except for `lower_bound` and `upper_bound`, because `unordered_set` doesn’t sort
    its elements.
  id: totrans-521
  prefs: []
  type: TYPE_NORMAL
  zh: '`unordered_set` 支持[表 13-10](ch13.xhtml#ch13tab10)中列出的所有 `set` 操作，除了 `lower_bound`
    和 `upper_bound`，因为 `unordered_set` 不对其元素进行排序。'
- en: '**Bucket Management**'
  id: totrans-522
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**桶管理**'
- en: 'Generally, the reason you reach for an `unordered_set` is its high performance.
    Unfortunately, this performance comes at a cost: `unordered_set` objects have
    a somewhat complicated interior structure. You have various knobs and dials you
    can use to inspect and modify this internal structure at runtime.'
  id: totrans-523
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，你选择 `unordered_set` 的原因是其高性能。不幸的是，这种性能是有代价的：`unordered_set` 对象具有一些复杂的内部结构。你可以使用各种控制项和旋钮来检查和修改该内部结构的运行时状态。
- en: The first control measure you have is to customize the bucket count of the `unordered_set`
    (that is, the number of buckets, not the number of elements in a particular bucket).
    Each `unordered_set` constructor takes a `size_t bucket_count` as its first argument,
    which defaults to some implementation-defined value. [Table 13-11](ch13.xhtml#ch13tab11)
    lists the main `unordered_set` constructors.
  id: totrans-524
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过自定义 `unordered_set` 的桶数量来进行第一步控制（即桶的数量，而不是特定桶中元素的数量）。每个 `unordered_set`
    构造函数将 `size_t bucket_count` 作为第一个参数，默认为一些实现定义的值。[表 13-11](ch13.xhtml#ch13tab11)列出了主要的
    `unordered_set` 构造函数。
- en: '**Table 13-11:** The `unordered_set` Constructors'
  id: totrans-525
  prefs: []
  type: TYPE_NORMAL
  zh: '**表 13-11：** `unordered_set` 构造函数'
- en: '| **Operation** | **Notes** |'
  id: totrans-526
  prefs: []
  type: TYPE_TB
  zh: '| **操作** | **备注** |'
- en: '| `unordered_set<`T`>(``[`bck`], [`hsh`], [`keq`], [`alc`])` | Bucket size
    bck has an implementation-defined default value. Uses hsh`=std::hash<`T`>`, keq`=std::equal_to<`T`>`,
    and alc`=std::allocator<`T`>` by default. |'
  id: totrans-527
  prefs: []
  type: TYPE_TB
  zh: '| `unordered_set<`T`>(``[`bck`], [`hsh`], [`keq`], [`alc`])` | 桶大小 bck 有一个实现定义的默认值。默认使用
    hsh`=std::hash<`T`>`、keq`=std::equal_to<`T`>` 和 alc`=std::allocator<`T`>`。 |'
- en: '| `unordered_set<`T`>(`...`,` `[`bck`], [`hsh`], [`keq`], [`alc`])` | Performs
    braced initialization of a newly constructed unordered set. |'
  id: totrans-528
  prefs: []
  type: TYPE_TB
  zh: '| `unordered_set<`T`>(`...`,` `[`bck`], [`hsh`], [`keq`], [`alc`])` | 执行新构造的无序集合的花括号初始化。
    |'
- en: '| `unordered_set<`T`>(`beg`,` end `[`bck`],` `[`hsh`], [`keq`], [`alc`])` |
    Constructs an unordered set with the elements on the half-open range from beg
    to end. |'
  id: totrans-529
  prefs: []
  type: TYPE_TB
  zh: '| `unordered_set<`T`>(`beg`,` end `[`bck`],` `[`hsh`], [`keq`], [`alc`])` |
    构造一个无序集合，元素范围为从 beg 到 end 的半开区间。 |'
- en: '| `unordered_set<`T`>(`s`)` | Deep copy of s; allocates new memory. |'
  id: totrans-530
  prefs: []
  type: TYPE_TB
  zh: '| `unordered_set<`T`>(`s`)` | `s` 的深拷贝；分配新内存。 |'
- en: '| `unordered_set<`T`>(move(`s`))` | Takes ownership of memory; elements in
    s. No allocations. |'
  id: totrans-531
  prefs: []
  type: TYPE_TB
  zh: '| `unordered_set<`T`>(move(`s`))` | 获取内存所有权；`s` 中的元素。没有分配。 |'
- en: You can inspect the number of buckets in an `unordered_set` using the `bucket_count`
    method. You can also obtain the maximum bucket count using the `max_bucket_count`
    method.
  id: totrans-532
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用 `bucket_count` 方法检查 `unordered_set` 中桶的数量。你还可以使用 `max_bucket_count` 方法获取最大桶数量。
- en: An important concept in the runtime performance of `unordered_set` is its *load
    factor*, the average number of elements per bucket. You can obtain the load factor
    of an `unordered_set` using the `load_factor` method, which is equivalent to `size()`
    divided by `bucket_count()`. Each `unordered_set` has a maximum load factor, which
    triggers an increase in the bucket count and a potentially expensive rehashing
    of all the contained elements. A *rehashing* is an operation where elements get
    reorganized into new buckets. This requires that you generate new hashes for each
    element, which can be a relatively computationally expensive operation.
  id: totrans-533
  prefs: []
  type: TYPE_NORMAL
  zh: '`unordered_set`在运行时性能中的一个重要概念是其*负载因子*，即每个桶中元素的平均数量。你可以使用`load_factor`方法获取`unordered_set`的负载因子，它等价于`size()`除以`bucket_count()`。每个`unordered_set`都有一个最大负载因子，这会触发桶数量的增加，并可能导致所有包含元素的昂贵重新哈希。*重新哈希*是一个操作，其中元素会被重新组织到新的桶中。这需要为每个元素生成新的哈希值，这可能是一个相对计算昂贵的操作。'
- en: You can obtain the maximum load factor using the `max_load_factor`, which is
    overloaded, so you can set a new maximum load factor (it defaults to 1.0).
  id: totrans-534
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过`max_load_factor`获取最大负载因子，它是重载的，因此你可以设置一个新的最大负载因子（默认值为1.0）。
- en: To avoid expensive rehashing at inopportune times, you can manually trigger
    a rehashing using the `rehash` method, which accepts a `size_t` argument for the
    desired bucket count. You can also use the `reserve` method, which instead accepts
    a `size_t` argument for the desired *element* count.
  id: totrans-535
  prefs: []
  type: TYPE_NORMAL
  zh: 为了避免在不合适的时机发生昂贵的重新哈希操作，你可以通过使用`rehash`方法手动触发重新哈希，`rehash`方法接受一个`size_t`类型的参数来指定所需的桶数量。你还可以使用`reserve`方法，该方法接受一个`size_t`类型的参数来指定所需的*元素*数量。
- en: '[Listing 13-31](ch13.xhtml#ch13ex31) illustrates some of these basic bucket
    management operations.'
  id: totrans-536
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 13-31](ch13.xhtml#ch13ex31)展示了这些基本的桶管理操作。'
- en: '[PRE30]'
  id: totrans-537
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: '*Listing 13-31: The `unordered_set` bucket management*'
  id: totrans-538
  prefs: []
  type: TYPE_NORMAL
  zh: '*示例 13-31：`unordered_set`桶管理*'
- en: You construct an `unordered_set` and specify a bucket count of 100 ➊. This results
    in a `bucket_count` of at least 100 ➋, which must be less than or equal to the
    `max_bucket_count` ➌. By default, the `max_load_factor` is 1.0 ➍.
  id: totrans-539
  prefs: []
  type: TYPE_NORMAL
  zh: 你构造了一个`unordered_set`并指定了100的桶数量➊。这样会导致`bucket_count`至少为100➋，并且必须小于或等于`max_bucket_count`➌。默认情况下，`max_load_factor`为1.0
    ➍。
- en: In the next test, you invoke `reserve` with enough space for a hundred thousand
    elements ➎. After inserting an element, the `load_factor` should be less than
    or equal to one one-hundred-thousandth (0.00001) ➏ because you’ve reserved enough
    space for a hundred thousand elements. As long as you stay below this threshold,
    you won’t need a rehashing. After inserting a hundred thousand elements ➐, the
    `load_factor` should still be less than or equal to 1 ➑. This demonstrates that
    you needed no rehashing, thanks to `reserve`.
  id: totrans-540
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一个测试中，你调用`reserve`方法为十万个元素预留足够的空间➎。插入一个元素后，`load_factor`应该小于或等于百万分之一（0.00001）➏，因为你已经为十万个元素预留了足够的空间。只要低于这个阈值，就不需要重新哈希。插入十万个元素后➐，`load_factor`仍应小于或等于1
    ➑。这表明，由于使用了`reserve`，你不需要重新哈希。
- en: '**Unordered Multisets**'
  id: totrans-541
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**无序多重集合**'
- en: 'The `std::unordered_multiset` available in the STL’s `<unordered_set>` header
    is an associative container that contains unsorted, *non-unique* keys. An `unordered_multiset`
    supports all the same constructors and operations as an `unordered_set`, but it
    will store redundant elements. This relationship is analogous to `unordered_set`s
    and `set`s: both `equal_range` and `count` have slightly different behavior to
    account for the non-uniqueness of keys.'
  id: totrans-542
  prefs: []
  type: TYPE_NORMAL
  zh: STL的`<unordered_set>`头文件中的`std::unordered_multiset`是一个关联容器，包含无序的、*非唯一*的键。`unordered_multiset`支持与`unordered_set`相同的所有构造函数和操作，但它会存储重复的元素。这个关系类似于`unordered_set`与`set`：`equal_range`和`count`的行为有所不同，以考虑键的非唯一性。
- en: '**NOTE**'
  id: totrans-543
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*Boost also provides a `boost::unordered_multiset` in the `<boost/unordered_set.hpp>`
    header.*'
  id: totrans-544
  prefs: []
  type: TYPE_NORMAL
  zh: '*Boost还提供了一个`boost::unordered_multiset`，位于`<boost/unordered_set.hpp>`头文件中。*'
- en: '***Maps***'
  id: totrans-545
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***映射***'
- en: The `std::map` available in the STL’s `<map>` header is an associative container
    that contains key-value pairs. The keys of a `map` are sorted and unique, and
    `map` supports all the same operations as `set`. In fact, you can think of a `set`
    as a special kind of `map` containing keys and empty values. Accordingly, `map`
    supports efficient insertion, removal, and search, and you have control over sorting
    with comparator objects.
  id: totrans-546
  prefs: []
  type: TYPE_NORMAL
  zh: STL的`<map>`头文件中提供的`std::map`是一个关联容器，包含键值对。`map`的键是排序且唯一的，且`map`支持与`set`相同的所有操作。实际上，你可以将`set`看作是一个特殊类型的`map`，其中包含键和空值。因此，`map`支持高效的插入、删除和查找，并且你可以通过比较器对象控制排序。
- en: The major advantage of working with a map instead of a set of pairs is that
    `map` works as an *associative array*. An associative array takes a key rather
    than an integer-valued index. Think of how you use the `at` and `operator[]` methods
    to access indices in sequential containers. Because sequential containers have
    a natural ordering of elements, you use an integer to refer to them. The associative
    array allows you to use types other than integers to refer to elements. For example,
    you could use a string or a `float` as a key.
  id: totrans-547
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`map`而不是一对对的集合的主要优势在于，`map`作为*关联数组*工作。关联数组使用键而不是整数值的索引。想想你如何使用`at`和`operator[]`方法访问顺序容器中的索引。因为顺序容器的元素有自然的顺序，所以你用整数来引用它们。关联数组允许你使用除了整数之外的类型来引用元素。例如，你可以使用字符串或`float`作为键。
- en: To enable associative array operations, `map` supports a number of useful operations;
    for example, allowing you to insert, modify, and retrieve values by their associated
    keys.
  id: totrans-548
  prefs: []
  type: TYPE_NORMAL
  zh: 为了支持关联数组操作，`map`支持许多有用的操作；例如，允许你通过关联的键插入、修改和检索值。
- en: '**Constructing**'
  id: totrans-549
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**构造**'
- en: The class template `map<Key, Value, Comparator, Allocator>` takes four template
    parameters. The first is the key type `Key`. The second is the value type `Value`.
    The third is the comparator type, which defaults to `std::less`. The fourth parameter
    is the allocator type, which defaults to `std::allocator<T>`.
  id: totrans-550
  prefs: []
  type: TYPE_NORMAL
  zh: 类模板`map<Key, Value, Comparator, Allocator>`包含四个模板参数。第一个是键类型`Key`。第二个是值类型`Value`。第三个是比较器类型，默认为`std::less`。第四个参数是分配器类型，默认为`std::allocator<T>`。
- en: 'The map constructors are direct analogues to the constructors of `set`: a default
    constructor that initializes an empty `map`; move and copy constructors with the
    usual behavior; a range constructor that copies the elements from the range into
    the map; and a braced initializer. The main difference is in the braced initializer,
    because you need to initialize key-value pairs instead of just keys. To achieve
    this nested initialization, you use nested initializer lists, as [Listing 13-32](ch13.xhtml#ch13ex32)
    illustrates.'
  id: totrans-551
  prefs: []
  type: TYPE_NORMAL
  zh: '`map`的构造函数与`set`的构造函数直接对应：一个默认构造函数用于初始化一个空的`map`；移动和复制构造函数具有通常的行为；一个范围构造函数将范围中的元素复制到`map`中；以及一个大括号初始化器。主要的区别在于大括号初始化器，因为你需要初始化键值对，而不仅仅是键。为了实现这种嵌套初始化，你使用嵌套的初始化列表，正如[列表13-32](ch13.xhtml#ch13ex32)所示。'
- en: '[PRE31]'
  id: totrans-552
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: '*Listing 13-32: A `std::map` supports default construction and braced initialization.*'
  id: totrans-553
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表13-32：`std::map`支持默认构造和大括号初始化。*'
- en: Here, you default construct a `map` with keys of type `const char*` and values
    of type `int` ➊. This results in an empty `map` ➋. In the second test, you again
    have a `map` with keys of type `const char*` and values of type `int` ➌, but this
    time you use braced initialization ➍ to pack four elements into the `map` ➎.
  id: totrans-554
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，你使用默认构造函数构造一个`map`，其中键的类型是`const char*`，值的类型是`int` ➊。这将导致一个空的`map` ➋。在第二个测试中，你再次使用键类型为`const
    char*`、值类型为`int`的`map` ➌，但这次使用大括号初始化 ➍将四个元素打包到`map`中 ➎。
- en: '**Move and Copy Semantics**'
  id: totrans-555
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**移动和复制语义**'
- en: The move and copy semantics of `map` are identical to those of `set`.
  id: totrans-556
  prefs: []
  type: TYPE_NORMAL
  zh: '`map`的移动和复制语义与`set`相同。'
- en: '**Storage Model**'
  id: totrans-557
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**存储模型**'
- en: Both `map` and `set` use the same red-black tree internal structure.
  id: totrans-558
  prefs: []
  type: TYPE_NORMAL
  zh: '`map`和`set`使用相同的红黑树内部结构。'
- en: '**Element Access**'
  id: totrans-559
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**元素访问**'
- en: 'The major advantage to using a `map` instead of a `set` of `pair` objects is
    that `map` offers two associative array operations: `operator[]` and `at`. Unlike
    the sequential containers supporting these operations, like `vector` and `array`,
    which take a `size_t` index argument, `map` takes a `Key` argument and returns
    a reference to the corresponding value. As with sequential containers, `at` will
    throw a `std::out_of_range` exception if the given `key` doesn’t exist in the
    `map`. Unlike with sequential containers, `operator[]` won’t cause undefined behavior
    if the `key` doesn’t exist; instead, it will (silently) default construct a `Value`
    and insert the corresponding key-value pair into the map, even if you only intended
    to perform a read, as [Listing 13-33](ch13.xhtml#ch13ex33) illustrates.'
  id: totrans-560
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`map`而不是`set`的`pair`对象的主要优点是，`map`提供了两种关联数组操作：`operator[]`和`at`。与支持这些操作的顺序容器（如`vector`和`array`）不同，它们需要一个`size_t`类型的索引参数，`map`需要一个`Key`类型的参数，并返回对应值的引用。与顺序容器一样，`at`会在给定的`key`在`map`中不存在时抛出`std::out_of_range`异常。与顺序容器不同的是，如果`key`不存在，`operator[]`不会导致未定义行为；相反，它会（默默地）默认构造一个`Value`并将对应的键值对插入到map中，即使你只打算执行读取操作，如[Listing
    13-33](ch13.xhtml#ch13ex33)所示。
- en: '[PRE32]'
  id: totrans-561
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: '*Listing 13-33: A `std::map` is an associative array with several access methods.*'
  id: totrans-562
  prefs: []
  type: TYPE_NORMAL
  zh: '*Listing 13-33: `std::map`是一个具有多种访问方法的关联数组。*'
- en: You construct a `map` called `pub_year` containing two elements ➊. Next, you
    use `operator[]` to extract the value corresponding to the key `colour_of_magic`
    ➋. You also use `operator[]` to insert the new key-value pair `equal_rites`, `1987`
    ➌ and then retrieve it ➍. Notice that when you attempt to retrieve an element
    with the key `mort` (which doesn’t exist), the map has silently default-initialized
    an `int` for you ➎.
  id: totrans-563
  prefs: []
  type: TYPE_NORMAL
  zh: 你构造了一个名为`map`的`pub_year`，它包含两个元素 ➊。接下来，你使用`operator[]`提取与键`colour_of_magic`对应的值
    ➋。你还使用`operator[]`插入新的键值对`equal_rites`，`1987` ➌，然后检索它 ➍。注意，当你尝试检索一个不存在的键`mort`时，map会默默地为你默认初始化一个`int`
    ➎。
- en: Using `at`, you can still set and retrieve ➏ elements, but if you attempt to
    access a key that doesn’t exist, you get a `std::out_of_range` exception ➐.
  id: totrans-564
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`at`，你仍然可以设置和检索 ➏ 元素，但如果你尝试访问一个不存在的键，会得到`std::out_of_range`异常 ➐。
- en: A `map` supports all the `set`-like, element-retrieval operations. For example,
    `map` supports `find`, which accepts a `key` argument and returns an iterator
    pointing to the key-value `pair` or, if no matching key is found, to the end of
    `map`. Also similarly supported are `count`, `equal_range`, `lower_bound`, and
    `upper_bound`.
  id: totrans-565
  prefs: []
  type: TYPE_NORMAL
  zh: '`map`支持所有类似`set`的元素检索操作。例如，`map`支持`find`，它接受一个`key`参数并返回一个指向键值对的迭代器，或者如果没有找到匹配的键，则返回指向`map`末尾的迭代器。类似地，`map`还支持`count`、`equal_range`、`lower_bound`和`upper_bound`等操作。'
- en: '**Adding Elements**'
  id: totrans-566
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**添加元素**'
- en: In addition to the element access methods `operator[]` and `at`, you also have
    all the `insert` and `emplace` methods available from `set`. You simply need to
    treat each key-value pair as a `std::pair<Key, Value>`. As with `set`, `insert`
    returns a pair containing an iterator and a `bool`. The iterator points to the
    inserted element, and the `bool` answers whether `insert` added a new element
    (`true`) or not (`false`), as [Listing 13-34](ch13.xhtml#ch13ex34) illustrates.
  id: totrans-567
  prefs: []
  type: TYPE_NORMAL
  zh: 除了元素访问方法`operator[]`和`at`外，你还可以使用`set`提供的所有`insert`和`emplace`方法。你只需将每个键值对视为`std::pair<Key,
    Value>`。与`set`一样，`insert`返回一个包含迭代器和`bool`的`pair`。迭代器指向插入的元素，`bool`值表示`insert`是否添加了新元素（`true`）或没有（`false`），如[Listing
    13-34](ch13.xhtml#ch13ex34)所示。
- en: '[PRE33]'
  id: totrans-568
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: '*Listing 13-34: A `std::map` supports `insert` to add new elements.*'
  id: totrans-569
  prefs: []
  type: TYPE_NORMAL
  zh: '*Listing 13-34: `std::map`支持`insert`方法来添加新元素。*'
- en: 'You default construct a `map` ➊ and use the `insert` method with a braced initializer
    for a `pair` ➋. This construction is roughly equivalent to the following:'
  id: totrans-570
  prefs: []
  type: TYPE_NORMAL
  zh: 你默认构造了一个`map` ➊，并使用带花括号初始化器的`insert`方法来插入一个`pair` ➋。这个构造大致相当于以下内容：
- en: '[PRE34]'
  id: totrans-571
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: After insertion, the `map` now contains one element ➌. Next, you create a stand-alone
    `pair` ➍ and then pass it as an argument to `insert` ➎. This inserts a copy into
    the `map`, so it now contains two elements ➏.
  id: totrans-572
  prefs: []
  type: TYPE_NORMAL
  zh: 插入之后，`map`现在包含一个元素 ➌。接下来，你创建了一个独立的`pair` ➍，然后将它作为参数传递给`insert` ➎。这会将一个副本插入到`map`中，因此它现在包含两个元素
    ➏。
- en: When you attempt to invoke `insert` with a new element with the same `the_light_fantastic`
    key ➐, you get an iterator pointing to the element you already inserted ➎. The
    key (`first`) and the value (`second`) match ➑. The return value `is_new` indicates
    that no new element was inserted ➒, and you still have two elements ➓. This behavior
    mirrors the `insert` behavior of `set`.
  id: totrans-573
  prefs: []
  type: TYPE_NORMAL
  zh: 当你尝试使用相同的 `the_light_fantastic` 键 ➐ 调用 `insert` 插入新元素时，你会得到一个指向你已经插入的元素的迭代器
    ➎。键（`first`）和值（`second`）匹配 ➑。返回值 `is_new` 表示没有插入新元素 ➒，你仍然拥有两个元素 ➓。该行为与 `set` 的
    `insert` 行为一致。 |
- en: A `map` also offers an `insert_or_assign` method, which, unlike `insert`, will
    overwrite an existing value. Also unlike `insert`, `insert_or_assign` accepts
    separate key and value arguments, as [Listing 13-35](ch13.xhtml#ch13ex35) illustrates.
  id: totrans-574
  prefs: []
  type: TYPE_NORMAL
  zh: '`map` 还提供了 `insert_or_assign` 方法，区别于 `insert`，它会覆盖现有的值。与 `insert` 不同，`insert_or_assign`
    接受独立的键和值参数，如 [示例 13-35](ch13.xhtml#ch13ex35) 所示。'
- en: '[PRE35]'
  id: totrans-575
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: '*Listing 13-35: A `std::map` supports `insert_or_assign` to overwrite existing
    elements.*'
  id: totrans-576
  prefs: []
  type: TYPE_NORMAL
  zh: '*示例 13-35：`std::map` 支持 `insert_or_assign` 来覆盖现有元素。*'
- en: You construct a `map` with a single element ➊ and then call `insert_or _assign`
    to reassign the value associated with the key `the_light_fantastic` to 1986 ➋.
    The iterator points to the existing element, and when you query the corresponding
    value with `second`, you see the value updated to 1986 ➌. The `is_new` return
    value also indicates that you’ve updated an existing element rather than inserting
    a new one ➍.
  id: totrans-577
  prefs: []
  type: TYPE_NORMAL
  zh: 你构造了一个包含单个元素 ➊ 的 `map`，然后调用 `insert_or_assign` 将与键 `the_light_fantastic` 关联的值重新赋值为
    1986 ➋。迭代器指向现有元素，当你查询相应的值时，使用 `second` 你会看到值已更新为 1986 ➌。`is_new` 返回值也表明你已经更新了现有元素，而不是插入了新元素
    ➍。 |
- en: '**Removing Elements**'
  id: totrans-578
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**移除元素**'
- en: Like `set`, `map` supports `erase` and `clear` to remove elements, as shown
    in [Listing 13-36](ch13.xhtml#ch13ex36).
  id: totrans-579
  prefs: []
  type: TYPE_NORMAL
  zh: 类似于 `set`，`map` 支持 `erase` 和 `clear` 来移除元素，如 [示例 13-36](ch13.xhtml#ch13ex36)
    所示。
- en: '[PRE36]'
  id: totrans-580
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: '*Listing 13-36: A `std::map` supports element removal.*'
  id: totrans-581
  prefs: []
  type: TYPE_NORMAL
  zh: '*示例 13-36：`std::map` 支持元素移除。*'
- en: You construct a `map` with two elements ➊. In the first test, you invoke `erase`
    on the element with key `mort` ➋, so when you try to `find` it, you get back `end`
    ➌. In the second test, you clear `map` ➍, which causes `empty` to return `true`
    ➎.
  id: totrans-582
  prefs: []
  type: TYPE_NORMAL
  zh: 你构造了一个包含两个元素 ➊ 的 `map`。在第一次测试中，你对键为 `mort` 的元素调用 `erase` ➋，所以当你尝试 `find` 它时，你会得到
    `end` ➌。在第二次测试中，你清空了 `map` ➍，这导致 `empty` 返回 `true` ➎。
- en: '**List of Supported Operations**'
  id: totrans-583
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**支持的操作列表**'
- en: "[Table 13-12](ch13.xhtml#ch13tab12) summarizes the supported operations of\
    \ `map`. A key `k` has type `K`. A value `v` has type `V`. `P` is the type `pair<K,\
    \ V>`, and `p` is of type `P`. The map `m` is `map<K, V>`. A dagger (\x86) denotes\
    \ a method that returns a `std::pair<Iterator, bool>`, where the iterator points\
    \ to the resulting element and the `bool` equals `true` if the method inserted\
    \ an element and `false` if the element already existed."
  id: totrans-584
  prefs: []
  type: TYPE_NORMAL
  zh: "[表 13-12](ch13.xhtml#ch13tab12) 总结了 `map` 的支持操作。键 `k` 的类型是 `K`。值 `v` 的类型是 `V`。`P`\
    \ 是类型 `pair<K, V>`，`p` 的类型是 `P`。`map` `m` 的类型是 `map<K, V>`。匕首符号 (\x86) 表示一个返回\
    \ `std::pair<Iterator, bool>` 的方法，其中迭代器指向结果元素，`bool` 为 `true` 表示该方法插入了一个元素，`false`\
    \ 表示该元素已经存在。 |"
- en: '**Table 13-12:** A Partial List of Supported `map` Operations'
  id: totrans-585
  prefs: []
  type: TYPE_NORMAL
  zh: '**表 13-12：** `map` 操作部分支持列表'
- en: '| **Operation** | **Notes** |'
  id: totrans-586
  prefs: []
  type: TYPE_TB
  zh: '| **操作** | **备注** |'
- en: '| `map<`T`>{` ...`, [`cmp`], [`alc`] }` | Performs braced initialization of
    a newly constructed map. Uses cmp`=std::less<`T`>` and alc`=std::allocator<`T`>`
    by default. |'
  id: totrans-587
  prefs: []
  type: TYPE_TB
  zh: '| `map<`T`>{` ...`, [`cmp`], [`alc`] }` | 执行新构造的 `map` 的大括号初始化。默认使用 cmp`=std::less<`T`>`
    和 alc`=std::allocator<`T`>`。 |'
- en: '| `map<`T`>{` beg`,` end`, [`cmp`], [`alc`] }` | Range constructor that copies
    elements from the half-open range beg to end. Uses cmp`=std::less<`T`>` and alc`=std::allocator<`T`>`
    by default. |'
  id: totrans-588
  prefs: []
  type: TYPE_TB
  zh: '| `map<`T`>{` beg`,` end`, [`cmp`], [`alc`] }` | 范围构造函数，将元素从半开区间 beg 到 end
    进行复制。默认使用 cmp`=std::less<`T`>` 和 alc`=std::allocator<`T`>`。 |'
- en: '| `map<`T`>(`m`)` | Deep copy of m; allocates new memory. |'
  id: totrans-589
  prefs: []
  type: TYPE_TB
  zh: '| `map<`T`>(`m`)` | 对 m 进行深拷贝；分配新的内存。 |'
- en: '| map`<`T`>(move(`m`))` | Takes ownership of memory; elements in m. No allocations.
    |'
  id: totrans-590
  prefs: []
  type: TYPE_TB
  zh: '| map`<`T`>(move(`m`))` | 获取内存所有权；元素来自 m。没有内存分配。 |'
- en: '| `~map` | Destructs all elements contained by the map and releases dynamic
    memory. |'
  id: totrans-591
  prefs: []
  type: TYPE_TB
  zh: '| `~map` | 销毁 `map` 中的所有元素并释放动态内存。 |'
- en: '| m1 `=` m2 | m1 destructs its elements; copies each m2 element. Only allocates
    if it needs to resize to fit m2’s elements. |'
  id: totrans-592
  prefs: []
  type: TYPE_TB
  zh: '| m1 `=` m2 | m1 销毁其元素；复制每个 m2 元素。仅在需要调整大小以适应 m2 的元素时才会分配内存。 |'
- en: '| m1 `= move(`m2`)` | m1 destructs its elements; moves each m2 element. Only
    allocates if it needs to resize to fit m2’s elements. |'
  id: totrans-593
  prefs: []
  type: TYPE_TB
  zh: '| m1 `= move(`m2`)` | m1 销毁其元素；移动每个 m2 元素。仅在需要调整大小以适应 m2 的元素时才会分配内存。 |'
- en: '| m`.at(`k`)` | Accesses the value corresponding to the key k. Throws `std::out_of_bounds`
    if key not found. |'
  id: totrans-594
  prefs: []
  type: TYPE_TB
  zh: '| m`.at(`k`)` | 访问与键k对应的值。如果未找到该键，则抛出`std::out_of_bounds`异常。 |'
- en: '| m`[`k`]` | Accesses the value corresponding to the key k. If the key is not
    found, inserts a new key-value pair using k and a default initialized value. |'
  id: totrans-595
  prefs: []
  type: TYPE_TB
  zh: '| m`[`k`]` | 访问与键k对应的值。如果未找到该键，则使用k和默认初始化的值插入一个新的键值对。 |'
- en: '| m`.begin()` | Returns an iterator pointing to the first element. |'
  id: totrans-596
  prefs: []
  type: TYPE_TB
  zh: '| m`.begin()` | 返回一个迭代器，指向第一个元素。 |'
- en: '| m`.cbegin()` | Returns a `const` iterator pointing to the first element.
    |'
  id: totrans-597
  prefs: []
  type: TYPE_TB
  zh: '| m`.cbegin()` | 返回一个`const`迭代器，指向第一个元素。 |'
- en: '| m`.end()` | Returns an iterator pointing to 1 past the last element. |'
  id: totrans-598
  prefs: []
  type: TYPE_TB
  zh: '| m`.end()` | 返回一个迭代器，指向最后一个元素之后的位置。 |'
- en: '| m`.cend()` | Returns a `const` iterator pointing to 1 past the last element.
    |'
  id: totrans-599
  prefs: []
  type: TYPE_TB
  zh: '| m`.cend()` | 返回一个`const`迭代器，指向最后一个元素之后的位置。 |'
- en: '| m`.find(`k`)` | Returns an iterator pointing to the element matching k, or
    m`.end()` if no such element exists. |'
  id: totrans-600
  prefs: []
  type: TYPE_TB
  zh: '| m`.find(`k`)` | 返回一个迭代器，指向匹配k的元素，如果没有此类元素，则返回m`.end()`。'
- en: '| m`.count(`k`)` | Returns 1 if the map contains k; otherwise 0. |'
  id: totrans-601
  prefs: []
  type: TYPE_TB
  zh: '| m`.count(`k`)` | 如果map包含k，则返回1；否则返回0。 |'
- en: '| m`.equal_range(`k`)` | Returns a `pair` of iterators corresponding to the
    half-open range of elements matching k. |'
  id: totrans-602
  prefs: []
  type: TYPE_TB
  zh: '| m`.equal_range(`k`)` | 返回一个`pair`，其中包含对应于匹配k的元素的半开区间的两个迭代器。 |'
- en: '| m`.lower_bound(`k`)` | Returns an iterator pointing to the first element
    not less than k, or t.`end()` if no such element exists. |'
  id: totrans-603
  prefs: []
  type: TYPE_TB
  zh: '| m`.lower_bound(`k`)` | 返回一个迭代器，指向第一个不小于k的元素，如果没有此类元素，则返回t.`end()`。 |'
- en: '| m`.upper_bound(`k`)` | Returns an iterator pointing to the first element
    greater than k, or t`.end()` if no such element exists. |'
  id: totrans-604
  prefs: []
  type: TYPE_TB
  zh: '| m`.upper_bound(`k`)` | 返回一个迭代器，指向第一个大于k的元素，如果没有此类元素，则返回t`.end()`。 |'
- en: '| m`.clear()` | Removes all elements from the map. |'
  id: totrans-605
  prefs: []
  type: TYPE_TB
  zh: '| m`.clear()` | 移除map中的所有元素。 |'
- en: '| m`.erase(`k`)` | Removes the element with key k. |'
  id: totrans-606
  prefs: []
  type: TYPE_TB
  zh: '| m`.erase(`k`)` | 移除具有键k的元素。 |'
- en: '| m`.erase(`itr`)` | Removes the element pointed to by itr. |'
  id: totrans-607
  prefs: []
  type: TYPE_TB
  zh: '| m`.erase(`itr`)` | 移除itr指向的元素。 |'
- en: '| m`.erase(`beg`,` end`)` | Removes all elements on the half-open range from
    beg to end. |'
  id: totrans-608
  prefs: []
  type: TYPE_TB
  zh: '| m`.erase(`beg`,` end`)` | 移除从beg到end的半开区间内的所有元素。 |'
- en: "| m`.insert(`p`)` | Inserts a copy of the pair p into the map.\x86 |"
  id: totrans-609
  prefs: []
  type: TYPE_TB
  zh: "| m`.insert(`p`)` | 将p对的副本插入到map中。\x86 |"
- en: "| m`.insert_or_assign(`k`,` v`)` | If k exists, overwrites the corresponding\
    \ value with v. If k doesn’t exist, inserts the pair k, v into the map.\x86 |"
  id: totrans-610
  prefs: []
  type: TYPE_TB
  zh: "| m`.insert_or_assign(`k`,` v`)` | 如果k存在，使用v覆盖对应的值。如果k不存在，将k，v对插入到map中。\x86\
    \ |"
- en: "| m`.emplace(`...`)` | Constructs a P in place by forwarding the arguments\
    \ ....\x86 |"
  id: totrans-611
  prefs: []
  type: TYPE_TB
  zh: "| m`.emplace(`...`)` | 通过转发参数`...`在原地构造一个P。\x86 |"
- en: "| m`.emplace_hint(`k`, ...)` | Constructs a P in place by forwarding the arguments`...`.\
    \ Uses itr as a hint for where to insert the new element.\x86 |"
  id: totrans-612
  prefs: []
  type: TYPE_TB
  zh: "| m`.emplace_hint(`k`, ...)` | 通过转发参数`...`在原地构造一个P。使用itr作为插入新元素的提示位置。\x86 |"
- en: '| m`.try_emplace(`itr`,` ...`)` | If key k exists, does nothing. If k doesn’t
    exist, constructs a V in place by forwarding the arguments .... |'
  id: totrans-613
  prefs: []
  type: TYPE_TB
  zh: '| m`.try_emplace(`itr`,` ...`)` | 如果key k存在，则不做任何操作。如果k不存在，则通过转发参数`...`在原地构造一个V。
    |'
- en: '| m`.empty()` | Returns `true` if map’s size is zero; otherwise `false`. |'
  id: totrans-614
  prefs: []
  type: TYPE_TB
  zh: '| m`.empty()` | 如果map的大小为零，返回`true`；否则返回`false`。 |'
- en: '| m`.size()` | Returns the number of elements in the map. |'
  id: totrans-615
  prefs: []
  type: TYPE_TB
  zh: '| m`.size()` | 返回map中的元素数量。 |'
- en: '| m`.max_size()` | Returns the maximum number of elements in the map. |'
  id: totrans-616
  prefs: []
  type: TYPE_TB
  zh: '| m`.max_size()` | 返回map中元素的最大数量。 |'
- en: '| m`.extract(`k`)`m`.extract(`itr`)` | Obtains a node handle that owns the
    element matching k or pointed to by itr. (This is the only way to remove a move-only
    element.) |'
  id: totrans-617
  prefs: []
  type: TYPE_TB
  zh: '| m`.extract(`k`)`m`.extract(`itr`)` | 获取一个节点句柄，该句柄拥有与k匹配的元素或itr指向的元素。（这是移除仅能移动的元素的唯一方式。）
    |'
- en: '| m1`.merge(`m2`)`m1`.merge(move(`m2`))` | Splices each element of m2 into
    m1. If argument is an rvalue, will move the elements into m1. |'
  id: totrans-618
  prefs: []
  type: TYPE_TB
  zh: '| m1`.merge(`m2`)`m1`.merge(move(`m2`))` | 将m2的每个元素拼接到m1中。如果参数是右值，则将元素移动到m1中。
    |'
- en: '| m1`.swap(`m2`)``swap(`m1`,` m2`)` | Exchanges each element of m1 with those
    of m2. |'
  id: totrans-619
  prefs: []
  type: TYPE_TB
  zh: '| m1`.swap(`m2`)``swap(`m1`,` m2`)` | 交换m1和m2的每个元素。 |'
- en: '**Multimaps**'
  id: totrans-620
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**多重映射（Multimaps）**'
- en: The `std::multimap` available in the STL’s `<map>` header is an associative
    container that contains key-value pairs with *non-unique* keys. Because the keys
    are not unique, `multimap` doesn’t support the associative array features that
    `map` does. Namely, `operator[]` and `at` aren’t supported. As with `multiset`,
    `multimap` offers element access primarily through the `equal_range` method, as
    [Listing 13-37](ch13.xhtml#ch13ex37) illustrates.
  id: totrans-621
  prefs: []
  type: TYPE_NORMAL
  zh: STL 中的 `std::multimap` 位于 `<map>` 头文件中，是一个包含具有 *非唯一* 键的键值对的关联容器。由于键不唯一，`multimap`
    不支持 `map` 的关联数组特性。也就是说，不支持 `operator[]` 和 `at`。与 `multiset` 一样，`multimap` 主要通过
    `equal_range` 方法提供元素访问，如 [清单 13-37](ch13.xhtml#ch13ex37) 所示。
- en: '[PRE37]'
  id: totrans-622
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: '*Listing 13-37: A `std::multimap` supports non-unique keys.*'
  id: totrans-623
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 13-37：`std::multimap` 支持非唯一键。*'
- en: You construct an `array` containing a message ➊. You also default construct
    a `multimap<char, size_t>` called `indices` that you’ll use to store the index
    of every character in the message ➋. By looping through the array, you can store
    each character in the message along with its index as a new element in `multimap`
    ➌. Because you’re allowed to have non-unique keys, you can use the `count` method
    to reveal how many indices you insert with the key `a` ➍. You can also use the
    `equal_range` method to obtain the half-open range of indices with the key `d`
    ➎. Using the resulting `begin` and `end` iterators, you can see that the message
    has the letter `d` at indices 23 ➏ and 59 ➐.
  id: totrans-624
  prefs: []
  type: TYPE_NORMAL
  zh: 你构造了一个包含消息的 `array` ➊。你还默认构造了一个名为 `indices` 的 `multimap<char, size_t>`，它将用于存储消息中每个字符的索引
    ➋。通过遍历数组，你可以将每个字符及其索引作为新元素存储在 `multimap` 中 ➌。由于允许使用非唯一键，你可以使用 `count` 方法来查看以键
    `a` 插入的索引数量 ➍。你还可以使用 `equal_range` 方法获取键 `d` 的半开区间 ➎。利用结果中的 `begin` 和 `end` 迭代器，你可以看到消息中字母
    `d` 的索引分别是 23 ➏ 和 59 ➐。
- en: Aside from `operator[]` and `at`, every operation in [Table 13-12](ch13.xhtml#ch13tab12)
    works for `multimap` as well. (Note that the `count` method can take on values
    other than 0 and 1.)
  id: totrans-625
  prefs: []
  type: TYPE_NORMAL
  zh: 除了 `operator[]` 和 `at`，[表 13-12](ch13.xhtml#ch13tab12) 中的每个操作也适用于 `multimap`。（请注意，`count`
    方法可以返回除 0 和 1 以外的其他值。）
- en: '**Unordered Maps and Unordered Multimaps**'
  id: totrans-626
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**无序映射和无序多重映射**'
- en: Unordered maps and unordered multimaps are completely analogous to unordered
    sets and unordered multisets. The `std::unordered_map` and `std::unordered_multimap`
    are available in the STL’s `<unordered_map>` header. These associative containers
    typically use a red-black tree like their `set` counterparts. They also require
    a hash function and an equivalence function, and they support the bucket interface.
  id: totrans-627
  prefs: []
  type: TYPE_NORMAL
  zh: 无序映射和无序多重映射与无序集合和无序多重集合完全类似。`std::unordered_map` 和 `std::unordered_multimap`
    可以在 STL 的 `<unordered_map>` 头文件中找到。这些关联容器通常使用像 `set` 那样的红黑树。它们还需要哈希函数和等价性函数，并支持桶接口。
- en: '**NOTE**'
  id: totrans-628
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*Boost offers the `boost::unordered_map` and `boost::unordered_multimap` in
    the `<boost/unordered_map.hpp>` header.*'
  id: totrans-629
  prefs: []
  type: TYPE_NORMAL
  zh: '*Boost 在 `<boost/unordered_map.hpp>` 头文件中提供了 `boost::unordered_map` 和 `boost::unordered_multimap`。*'
- en: '***Niche Associative Containers***'
  id: totrans-630
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***特定领域的关联容器***'
- en: Use `set`, `map`, and their associated non-unique and unordered counterparts
    as the default choices when you need associative data structures. When special
    needs arise, Boost libraries offer a number of specialized associative containers,
    as highlighted in [Table 13-13](ch13.xhtml#ch13tab13).
  id: totrans-631
  prefs: []
  type: TYPE_NORMAL
  zh: 当需要关联数据结构时，使用 `set`、`map` 及其相关的非唯一和无序对立物作为默认选择。当出现特殊需求时，Boost 库提供了许多专门的关联容器，如
    [表 13-13](ch13.xhtml#ch13tab13) 所示。
- en: '**Table 13-13:** Special Boost Containers'
  id: totrans-632
  prefs: []
  type: TYPE_NORMAL
  zh: '**表 13-13：** 特殊 Boost 容器'
- en: '| **Class/Header** | **Description** |'
  id: totrans-633
  prefs: []
  type: TYPE_TB
  zh: '| **类/头文件** | **描述** |'
- en: '| `boost::container::flat_map``<boost/container/flat_map.hpp>` | Similar to
    an STL `map`, but it’s implemented like an ordered vector. This means fast random
    element access. |'
  id: totrans-634
  prefs: []
  type: TYPE_TB
  zh: '| `boost::container::flat_map``<boost/container/flat_map.hpp>` | 类似于 STL 中的
    `map`，但它的实现方式像一个有序的向量。这意味着快速的随机元素访问。 |'
- en: '| `boost::container::flat_set``<boost/container/flat_set.hpp>` | Similar to
    an STL `set`, but it’s implemented like an ordered vector. This means fast random
    element access. |'
  id: totrans-635
  prefs: []
  type: TYPE_TB
  zh: '| `boost::container::flat_set``<boost/container/flat_set.hpp>` | 类似于 STL 中的
    `set`，但它的实现方式像一个有序的向量。这意味着快速的随机元素访问。 |'
- en: '| `boost::intrusive::*``<boost/intrusive/*.hpp>` | Intrusive containers impose
    requirements on the elements they contain (such as inheriting from a particular
    base class). In exchange, they offer substantial performance gains. |'
  id: totrans-636
  prefs: []
  type: TYPE_TB
  zh: '| `boost::intrusive::*``<boost/intrusive/*.hpp>` | 内侵式容器对其包含的元素提出要求（例如要求继承自特定的基类）。作为交换，它们提供了显著的性能提升。
    |'
- en: '| `boost::multi_index_container``<boost/multi_index_container.hpp>` | Permits
    you to create associative arrays taking multiple indices rather than just one
    (like a map). |'
  id: totrans-637
  prefs: []
  type: TYPE_TB
  zh: '| `boost::multi_index_container``<boost/multi_index_container.hpp>` | 允许你创建关联数组，可以使用多个索引，而不仅仅是一个（像map一样）。
    |'
- en: '| `boost::ptr_set``boost::ptr_unordered_map``boost::ptr_unordered_set``<boost/ptr_container/*.hpp>`
    | Having a collection of smart pointers can be suboptimal. Pointer vectors manage
    a collection of dynamic objects in a more efficient and user-friendly way. |'
  id: totrans-638
  prefs: []
  type: TYPE_TB
  zh: '| `boost::ptr_set``boost::ptr_unordered_map``boost::ptr_unordered_set``<boost/ptr_container/*.hpp>`
    | 拥有智能指针的集合可能效率较低。指针向量以更高效和更友好的方式管理动态对象的集合。 |'
- en: '| `boost::bimap``<` `boost/bimap.hpp>` | A bimap is an associative container
    that allows both types to be used as a key. |'
  id: totrans-639
  prefs: []
  type: TYPE_TB
  zh: '| `boost::bimap``<` `boost/bimap.hpp>` | Bimap是一个关联容器，允许两种类型都作为键使用。 |'
- en: '| `boost::heap::binomial_heap``boost::heap::d_ary_heap``boost::heap::fibonacci_heap``boost::heap::pairing_heap``boost::heap::priority_queue``boost::heap::skew_heap``<boost/heap/*.hpp>`
    | The Boost Heap containers implement more advanced, featureful versions of `priority_queue`.
    |'
  id: totrans-640
  prefs: []
  type: TYPE_TB
  zh: '| `boost::heap::binomial_heap``boost::heap::d_ary_heap``boost::heap::fibonacci_heap``boost::heap::pairing_heap``boost::heap::priority_queue``boost::heap::skew_heap``<boost/heap/*.hpp>`
    | Boost堆容器实现了`priority_queue`的更高级、更具功能性的版本。 |'
- en: '**Graphs and Property Trees**'
  id: totrans-641
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**图和属性树**'
- en: 'This section discusses two specialized Boost libraries that serve niche but
    valuable purposes: modeling graphs and property trees. A *graph* is a set of objects
    in which some have a pairwise relation. The objects are called *verti**ces,*and
    their relations are called *edges*. [Figure 13-3](ch13.xhtml#ch13fig03) illustrates
    a graph containing four vertices and five edges.'
  id: totrans-642
  prefs: []
  type: TYPE_NORMAL
  zh: 本节讨论了两个专门的Boost库，它们在特定领域具有重要作用：建模图和属性树。*图*是一个对象集合，其中某些对象之间存在配对关系。这些对象被称为*顶点*，它们之间的关系称为*边*。[图13-3](ch13.xhtml#ch13fig03)展示了一个包含四个顶点和五条边的图。
- en: '![image](../images/fig13_3.jpg)'
  id: totrans-643
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/fig13_3.jpg)'
- en: '*Figure 13-3:A graph containing four vertices and five edges*'
  id: totrans-644
  prefs: []
  type: TYPE_NORMAL
  zh: '*图13-3：一个包含四个顶点和五条边的图*'
- en: Each square represents a vertex, and each arrow represents an edge.
  id: totrans-645
  prefs: []
  type: TYPE_NORMAL
  zh: 每个方框代表一个顶点，每个箭头代表一条边。
- en: A *property tree* is a tree structure storing nested key-value pairs. The hierarchical
    nature of a property tree’s key-value pairs makes it a hybrid between a map and
    a graph; each key-value pair has a relation to other key-value pairs. [Figure
    13-4](ch13.xhtml#ch13fig04) illustrates an example property tree containing nested
    key-value pairs.
  id: totrans-646
  prefs: []
  type: TYPE_NORMAL
  zh: '*属性树*是一个存储嵌套键值对的树形结构。属性树的键值对的层次结构使其成为映射和图的混合体；每个键值对与其他键值对之间存在关系。[图13-4](ch13.xhtml#ch13fig04)展示了一个包含嵌套键值对的示例属性树。'
- en: '![image](../images/fig13_4.jpg)'
  id: totrans-647
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/fig13_4.jpg)'
- en: '*Figure 13-4: An example property tree*'
  id: totrans-648
  prefs: []
  type: TYPE_NORMAL
  zh: '*图13-4：一个示例属性树*'
- en: 'The root element has three children: name, year, and features. In [Figure 13-4](ch13.xhtml#ch13fig04),
    name has a value finfisher, year has a value 2014, and features has three children:
    process with value LSASS, driver with value mssounddx.sys, and arch with value
    32.'
  id: totrans-649
  prefs: []
  type: TYPE_NORMAL
  zh: 根元素有三个子元素：name、year和features。在[图13-4](ch13.xhtml#ch13fig04)中，name的值为finfisher，year的值为2014，features有三个子元素：process，值为LSASS，driver，值为mssounddx.sys，arch，值为32。
- en: '**The Boost Graph Library**'
  id: totrans-650
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**Boost图形库**'
- en: 'The *Boost Graph Library* (BGL) is a set of collections and algorithms for
    storing and manipulating graphs. The BGL offers three containers that represent
    graphs:'
  id: totrans-651
  prefs: []
  type: TYPE_NORMAL
  zh: '*Boost图形库*（BGL）是一套用于存储和操作图的集合和算法。BGL提供了三种表示图的容器：'
- en: The `boost::adjacency_list` in the `<boost/graph/adjacency_list.hpp>` header
  id: totrans-652
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`<boost/graph/adjacency_list.hpp>`头文件中的`boost::adjacency_list`'
- en: The `boost::adjacency_matrix` in the `<boost/graph/adjacency_matrix.hpp>` header
  id: totrans-653
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`<boost/graph/adjacency_matrix.hpp>`头文件中的`boost::adjacency_matrix`'
- en: The `boost::edge_list` in the `<boost/graph/ edge_list.hpp>` header
  id: totrans-654
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`<boost/graph/edge_list.hpp>`头文件中的`boost::edge_list`'
- en: 'You use two non-member functions to build graphs: `boost::add_vertex` and `boost::add_edge`.
    To add a vertex to one of the BGL graph containers, you pass the graph object
    to `add_vertex`, which will return reference to the new vertex object. To add
    an edge, we pass the source vertex, the destination vertex, then the graph to
    `add_edge`.'
  id: totrans-655
  prefs: []
  type: TYPE_NORMAL
  zh: 你使用两个非成员函数来构建图：`boost::add_vertex`和`boost::add_edge`。要向BGL图容器中添加一个顶点，你需要将图对象传递给`add_vertex`，该函数会返回新顶点对象的引用。要添加一条边，我们传递源顶点、目标顶点以及图给`add_edge`。
- en: BGL contains a number of graph-specific algorithms. You can count the number
    of vertices in a graph object by passing it to the non-member function `boost::num_vertices`
    and the number of edges using `boost::num_edges`. You can also query a graph for
    adjacent vertices. Two vertices are *adjacent* if they share an edge. To get the
    vertices adjacent to a particular vertex, you can pass it and the graph object
    to the non-member function `boost::adjacent_ vertices`. This returns a half-open
    range as a `std::pair` of iterators.
  id: totrans-656
  prefs: []
  type: TYPE_NORMAL
  zh: BGL包含了一些特定于图形的算法。你可以通过将图形对象传递给非成员函数`boost::num_vertices`来计算图中的顶点数，通过`boost::num_edges`来计算边的数量。你还可以查询图中的相邻顶点。如果两个顶点共享一条边，它们是*相邻的*。要获取与特定顶点相邻的顶点，你可以将该顶点和图形对象传递给非成员函数`boost::adjacent_vertices`。这将返回一个半开区间，作为`std::pair`的迭代器。
- en: '[Listing 13-38](ch13.xhtml#ch13ex38) illustrates how you can build the graph
    represented in [Figure 13-3](ch13.xhtml#ch13fig03), count its vertices and edges,
    and compute adjacent vertices.'
  id: totrans-657
  prefs: []
  type: TYPE_NORMAL
  zh: '[清单13-38](ch13.xhtml#ch13ex38)展示了如何构建[图13-3](ch13.xhtml#ch13fig03)中表示的图，计算其顶点和边，并计算相邻的顶点。'
- en: '[PRE38]'
  id: totrans-658
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: '*Listing 13-38: The `boost::adjacency_list` stores graph data.*'
  id: totrans-659
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单13-38：`boost::adjacency_list`存储图形数据。*'
- en: Here, you’ve constructed an `adjacency_list` called `graph` ➊, then added four
    vertices using `add_vertex` ➋. Next, you add all the edges represented in [Figure
    13-3](ch13.xhtml#ch13fig03) using `add_edge` ➌. Then `num_vertices` shows you
    that you’ve added four vertices ➍, and `num_edges` tells you that you’ve added
    five edges ➎.
  id: totrans-660
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，你已经构造了一个名为`graph` ➊的`adjacency_list`，然后使用`add_vertex` ➋添加了四个顶点。接着，使用`add_edge`
    ➌添加了[图13-3](ch13.xhtml#ch13fig03)中表示的所有边。然后，`num_vertices`告诉你已添加了四个顶点 ➍，而`num_edges`告诉你已添加了五条边
    ➎。
- en: Finally, you’ve determined the `adjacent_vertices` to `vertex_1`, which you
    unpack into the iterators `begin` and `end` ➏. You use these iterators to construct
    a `std::set` ➐, which you use to show that `vertex_2` ➑ and `vertex_3` ➒ are adjacent,
    but `vertex_4` is not ➓.
  id: totrans-661
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，你已经确定了与`vertex_1`相邻的`adjacent_vertices`，并将其拆解为迭代器`begin`和`end` ➏。你使用这些迭代器构造一个`std::set`
    ➐，用于显示`vertex_2` ➑和`vertex_3` ➒是相邻的，但`vertex_4` 不是 ➓。
- en: '**Boost Property Trees**'
  id: totrans-662
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**Boost属性树**'
- en: Boost offers the `boost::property_tree::ptree` in the `<boost/property_tree/ptree.hpp>`
    header. This is a property tree that permits us to build and query property trees,
    as well as some limited serialization into various formats.
  id: totrans-663
  prefs: []
  type: TYPE_NORMAL
  zh: Boost提供了`boost::property_tree::ptree`，它位于`<boost/property_tree/ptree.hpp>`头文件中。这是一个属性树，它允许我们构建和查询属性树，并支持一些有限的序列化为各种格式。
- en: The tree `ptree` is default constructible. Default constructing will build an
    empty `ptree`.
  id: totrans-664
  prefs: []
  type: TYPE_NORMAL
  zh: 树`ptree`是默认可构造的。默认构造会构建一个空的`ptree`。
- en: You can insert elements into a `ptree` using its `put` method, which takes a
    path and a value argument. A *path* is a sequence of one or more nested keys separated
    by a period (**.**), and a *value* is an arbitrarily typed object.
  id: totrans-665
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用`ptree`的`put`方法插入元素，该方法接受路径和数值参数。*路径*是由一个或多个嵌套键组成的序列，键之间由句点（**.**）分隔，*数值*是任意类型的对象。
- en: You can get subtrees from a `ptree` using the `get_child` method, which takes
    the path of the desired subtree. If the subtree does not have any children (a
    so-called *leaf node*), you can also use the method template `get_value` to extract
    the corresponding value from the key-value pair; `get_value` takes a single template
    parameter corresponding to the desired output type.
  id: totrans-666
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用`get_child`方法从`ptree`中获取子树，该方法接受所需子树的路径。如果子树没有任何子项（即所谓的*叶节点*），你还可以使用模板方法`get_value`从键值对中提取相应的值；`get_value`接受一个模板参数，该参数对应所需的输出类型。
- en: 'Finally, `ptree` supports serialization and deserialization to several formats
    including Javascript object notation (JSON), the Windows initialization file (INI)
    format, the extensible markup language (XML), and a custom, `ptree`-specific format
    called INFO. For example, to write a `ptree` into a file in JSON format, you could
    use the `boost::property_tree::write_json` function from the `<boost/property_tree/json_parser.hpp>`
    header. The function `write_json` accepts two arguments: the path to the desired
    output file and a `ptree` reference.'
  id: totrans-667
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，`ptree`支持序列化和反序列化为几种格式，包括Javascript对象表示法（JSON）、Windows初始化文件（INI）格式、可扩展标记语言（XML）以及一种名为INFO的`ptree`特定格式。例如，要将`ptree`以JSON格式写入文件，你可以使用`<boost/property_tree/json_parser.hpp>`头文件中的`boost::property_tree::write_json`函数。`write_json`函数接受两个参数：所需输出文件的路径和一个`ptree`引用。
- en: '[Listing 13-39](ch13.xhtml#ch13ex39) highlights these basic `ptree` functions
    by building a `ptree` representing the property tree in [Figure 13-4](ch13.xhtml#ch13fig04),
    writing the `ptree` to file as JSON, and reading it back.'
  id: totrans-668
  prefs: []
  type: TYPE_NORMAL
  zh: '[清单 13-39](ch13.xhtml#ch13ex39) 通过构建一个表示[图 13-4](ch13.xhtml#ch13fig04)中属性树的
    `ptree`，将其写入文件作为 JSON，并读取回来，展示了这些基本的 `ptree` 函数。'
- en: '[PRE39]'
  id: totrans-669
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: '*Listing 13-39: The `boost::property_tree::ptree` method stores tree data.
    Output shows the contents of `rootkit.json`.*'
  id: totrans-670
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 13-39：`boost::property_tree::ptree` 方法存储树形数据。输出显示了 `rootkit.json` 的内容。*'
- en: Here, you’ve default constructed a `ptree` ➊, which you populate with the key
    values shown in [Figure 13-4](ch13.xhtml#ch13fig04). Keys with parents, such as
    `arch` ➋, use periods to show the appropriate path. Using `get_child`, you’ve
    extracted the subtree for key `year`. Because it’s a leaf node (having no children),
    you also invoke `get_value`, specifying the output type as `int` ➌.
  id: totrans-671
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，你默认构造了一个 `ptree` ➊，并用[图 13-4](ch13.xhtml#ch13fig04)中显示的键值填充它。具有父级的键（如 `arch`
    ➋）使用句点表示适当的路径。通过使用 `get_child`，你提取了键 `year` 的子树。因为它是一个叶节点（没有子节点），所以你还调用了 `get_value`，并将输出类型指定为
    `int` ➌。
- en: Next, you write the `ptree`’s JSON representation to the file `rootkit.json`
    ➍. To ensure that you get the same property tree back, you default construct another
    `ptree` called `p_copy` and pass it into `read_json` ➎. This copy is equivalent
    to the original ➏, illustrating that the serialization-deserialization operation
    is successful.
  id: totrans-672
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，你将 `ptree` 的 JSON 表示写入文件 `rootkit.json` ➍。为了确保你得到相同的属性树，你默认构造了另一个名为 `p_copy`
    的 `ptree`，并将其传递给 `read_json` ➎。这个副本与原始对象等价 ➏，说明序列化-反序列化操作是成功的。
- en: '**Initializer Lists**'
  id: totrans-673
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**初始化列表**'
- en: You can accept initializer lists in your user-defined types by incorporating
    the `std::initializer_list` container available in the STL’s `<initializer_list>`
    header. The `initializer_list` is a class template that takes a single template
    parameter corresponding to the underlying type contained in the initializer list.
    This template serves as a simple proxy for accessing the elements of an initializer
    list.
  id: totrans-674
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过结合 STL 的 `<initializer_list>` 头文件中的 `std::initializer_list` 容器，在用户定义的类型中接受初始化列表。`initializer_list`
    是一个类模板，接受一个模板参数，对应于初始化列表中包含的底层类型。这个模板作为访问初始化列表元素的简单代理。
- en: 'The `initializer_list` is immutable and supports three operations:'
  id: totrans-675
  prefs: []
  type: TYPE_NORMAL
  zh: '`initializer_list` 是不可变的，并支持三种操作：'
- en: The `size` method returns the number of elements in the `initializer_list`.
  id: totrans-676
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`size` 方法返回 `initializer_list` 中元素的数量。'
- en: The `begin` and `end` methods return the usual half-open-range iterators.
  id: totrans-677
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`begin` 和 `end` 方法返回常规的半开区间迭代器。'
- en: Generally, you should design functions to accept an `initializer_list` by value.
  id: totrans-678
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，你应该设计函数以值传递的方式接受 `initializer_list`。
- en: '[Listing 13-40](ch13.xhtml#ch13ex40) implements a `SquareMatrix` class that
    stores a matrix with equal numbers of rows and columns. Internally, the class
    will hold elements in a `vector` of `vector`s.'
  id: totrans-679
  prefs: []
  type: TYPE_NORMAL
  zh: '[清单 13-40](ch13.xhtml#ch13ex40) 实现了一个 `SquareMatrix` 类，该类存储具有相同行数和列数的矩阵。在内部，该类将元素保存在一个
    `vector` 的 `vector` 中。'
- en: '[PRE40]'
  id: totrans-680
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: '*Listing 13-40: An implementation of a `SquareMatrix`*'
  id: totrans-681
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 13-40：一个 `SquareMatrix` 的实现*'
- en: Here, you declare a convenience `square_root` function that finds the square
    root of a `size_t`, throwing an exception if the argument isn’t a perfect square
    ➊. The `SquareMatrix` class template defines a single constructor that accepts
    a `std::initializer` called `val` ➋. This permits braced initialization.
  id: totrans-682
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，你声明了一个方便的 `square_root` 函数，它用于查找 `size_t` 的平方根，如果参数不是完全平方数，则抛出异常 ➊。`SquareMatrix`
    类模板定义了一个构造函数，该构造函数接受一个名为 `val` 的 `std::initializer` ➋。这允许使用大括号进行初始化。
- en: First, you need to determine the dimensions of `SquareMatrix`. Use the `square_root`
    function to compute the square root of `val.size()` ➌ and store this into the
    `dim` field, which represents the number of rows and columns of the `SquareMatrix`
    instance. You can then use `dim` to initialize the vector of vectors `data` using
    its fill constructor ➍. Each of these `vector`s will correspond to a row in `SquareMatrix`.
    Next, you extract an iterator pointing to the first element in `initializer_list`
    ➎. You iterate over each row in `SquareMatrix`, assigning the corresponding `vector`
    to the appropriate half-open range ➏. You increment the iterator on each iteration
    to point to the next row ➐.
  id: totrans-683
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，您需要确定`SquareMatrix`的尺寸。使用`square_root`函数计算`val.size()`的平方根➌，并将其存储到`dim`字段中，该字段表示`SquareMatrix`实例的行数和列数。然后，您可以使用`dim`初始化向量的向量`data`，使用其填充构造函数➍。这些`vector`中的每一个都对应于`SquareMatrix`中的一行。接下来，您提取一个指向`initializer_list`中第一个元素的迭代器➎。您迭代`SquareMatrix`中的每一行，将相应的`vector`分配给适当的半开区间➏。您在每次迭代时递增迭代器，以指向下一行➐。
- en: Finally, you implement an `at` method to permit element access. You perform
    bounds checking ➑ and then return a reference to the desired element by extracting
    the appropriate `vector` and element ➒.
  id: totrans-684
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，您实现了一个`at`方法来允许元素访问。您执行边界检查➑，然后通过提取适当的`vector`和元素➒返回对所需元素的引用。
- en: '[Listing 13-41](ch13.xhtml#ch13ex41) illustrates how to use braced initialization
    to generate a `SquareMatrix` object.'
  id: totrans-685
  prefs: []
  type: TYPE_NORMAL
  zh: '[列表 13-41](ch13.xhtml#ch13ex41)说明了如何使用带花括号初始化生成`SquareMatrix`对象。'
- en: '[PRE41]'
  id: totrans-686
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: '*Listing 13-41: Using braced initializers with a `SquareMatrix`*'
  id: totrans-687
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 13-41：使用带花括号初始化器的`SquareMatrix`*'
- en: You use braced initializers to set up `SquareMatrix` ➊. Because the initializer
    list contains 16 elements, you end up with a `dim` of 4 ➋. You can use `at` to
    obtain a reference to any element, meaning you can set ➌ and get ➍➎ elements.
  id: totrans-688
  prefs: []
  type: TYPE_NORMAL
  zh: 您使用花括号初始化器设置了`SquareMatrix`➊。因为初始化列表包含16个元素，所以最终得到了`dim`为4➋。您可以使用`at`来获取任何元素的引用，这意味着您可以设置➌和获取➍➎元素。
- en: '**Summary**'
  id: totrans-689
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**摘要**'
- en: This chapter began with a discussion of the two go-to sequence containers, `array`
    and `vector`, which offer you a great balance between performance and features
    in a wide range of applications. Next, you learned about several sequence containers—`deque`,
    `list`, `stack`, `queue`, `priority_queue`, and `bitset`—that fill in when `vector`
    doesn’t meet the demands of a particular application. Then you explored the major
    associative containers, `set` and `map`, and their unordered/multipermutations.
    You also learned about two niche Boost containers, `graph` and `ptree`. The chapter
    wrapped up with a brief discussion of incorporating `initializer_list`s into user-defined
    types.
  id: totrans-690
  prefs: []
  type: TYPE_NORMAL
  zh: 本章始于讨论两个主要的序列容器，`array`和`vector`，它们在广泛的应用中提供了性能和功能的良好平衡。接下来，您了解了几种序列容器——`deque`、`list`、`stack`、`queue`、`priority_queue`和`bitset`——它们在`vector`无法满足特定应用要求时提供了解决方案。然后，您探讨了主要的关联容器，`set`和`map`，以及它们的无序/多重排列。您还了解了两个小众
    Boost 容器，`graph`和`ptree`。本章以简短讨论如何将`initializer_list`集成到用户定义类型中结束。
- en: '**EXERCISES**'
  id: totrans-691
  prefs: []
  type: TYPE_NORMAL
  zh: '**练习**'
- en: '**13-1.** Write a program that default constructs a `std::vector` of unsigned
    longs. Print the `capacity` of `vector` and then `reserve` 10 elements. Next,
    append the first 20 elements of the Fibonacci series to the vector. Print `capacity`
    again. Does `capacity` match the number of elements in the vector? Why or why
    not? Print the elements of `vector` using a range-based `for` loop.'
  id: totrans-692
  prefs: []
  type: TYPE_NORMAL
  zh: '**13-1.** 编写一个程序，用于默认构造一个`std::vector`的无符号长整型。打印`vector`的`capacity`，然后`reserve`
    10个元素。接下来，将斐波那契序列的前20个元素追加到`vector`中。再次打印`capacity`。`capacity`是否与`vector`中的元素数量匹配？为什么？打印`vector`的元素，使用range-based
    `for`循环。'
- en: '**13-2.** Rewrite [Listings 2-9](ch02.xhtml#ch02ex09), [2-10](ch02.xhtml#ch02ex10),
    and [2-11](ch02.xhtml#ch02ex11) in [Chapter 2](ch02.xhtml#ch02) using `std::array`.'
  id: totrans-693
  prefs: []
  type: TYPE_NORMAL
  zh: '**13-2.** 使用`std::array`重写[列表 2-9](ch02.xhtml#ch02ex09)，[2-10](ch02.xhtml#ch02ex10)和[2-11](ch02.xhtml#ch02ex11)在[第
    2 章](ch02.xhtml#ch02)中。'
- en: '**13-3.** Write a program that accepts any number of command line arguments
    and prints them in alphanumerically sorted order. Use a `std::set<const char*>`
    to store the elements, then iterate over the `set` to obtain the sorted result.
    You’ll need to implement a custom comparator that compares two C-style strings.'
  id: totrans-694
  prefs: []
  type: TYPE_NORMAL
  zh: '**13-3.** 编写一个接受任意数量命令行参数并按字母数字顺序打印它们的程序。使用`std::set<const char*>`存储元素，然后迭代`set`以获取排序结果。您需要实现一个自定义比较器来比较两个C风格字符串。'
- en: '**13-4.** Write a program that default constructs a `std::vector` of unsigned
    longs. Print the `capacity` of `vector` and then `reserve` 10 elements. Next,
    append the first 20 elements of the Fibonacci series to the vector. Print `capacity`
    again. Does `capacity` match the number of elements in the vector? Why or why
    not? Print the elements of `vector` using a range-based `for` loop.'
  id: totrans-695
  prefs: []
  type: TYPE_NORMAL
  zh: '**13-4.** 编写一个程序，默认构造一个无符号长整型的 `std::vector`。打印 `vector` 的 `capacity`，然后 `reserve`
    10 个元素。接下来，将 Fibonacci 序列的前 20 个元素追加到该向量中。再次打印 `capacity`。`capacity` 是否与向量中的元素数量相匹配？为什么或为什么不匹配？使用基于范围的
    `for` 循环打印 `vector` 的元素。'
- en: '**13-5.** Consider the following program that profiles the performance of a
    function summing a Fibonacci series:'
  id: totrans-696
  prefs: []
  type: TYPE_NORMAL
  zh: '**13-5.** 考虑以下程序，它对一个计算 Fibonacci 序列和的函数进行性能分析：'
- en: '[PRE42]'
  id: totrans-697
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: This program contains a computationally intensive function `fib_sum` ➊ that
    computes the sum of a Fibonacci series with a given length. Adapt your code from
    Exercise 13-1 by (a) generating the appropriate vector and (b) summing over the
    result with a range-based `for` loop. The `random` function ➋ returns a random
    number between 1,000 and 2,000, and the `Stopwatch` class ➌ adopted from [Listing
    12-25](ch12.xhtml#ch12ex25) in [Chapter 12](ch12.xhtml#ch12) helps you determine
    elapsed time. In the program’s `main`, you perform a million evaluations of the
    `fib_sum` function using random input ➎. You time how long this takes and print
    the result before exiting the program ➐. Compile the program and run it a few
    times to get an idea of how long your program takes to run. (This is called a
    *baseline*.)
  id: totrans-698
  prefs: []
  type: TYPE_NORMAL
  zh: 该程序包含一个计算密集型的函数 `fib_sum` ➊，用于计算给定长度的 Fibonacci 序列的和。从练习 13-1 中改编代码，（a）生成适当的向量，（b）使用基于范围的
    `for` 循环计算结果和。`random` 函数 ➋ 返回一个介于 1,000 和 2,000 之间的随机数，`Stopwatch` 类 ➌ 从 [Listing
    12-25](ch12.xhtml#ch12ex25) 在 [第 12 章](ch12.xhtml#ch12) 中借用，帮助你确定经过的时间。在程序的 `main`
    中，你对 `fib_sum` 函数进行百万次评估，使用随机输入 ➎。你会计时并在退出程序 ➐ 前打印结果。编译程序并运行几次，以了解程序的运行时间。（这被称为
    *基准线*。）
- en: '**13-6.** Next, comment out ➎ and uncomment ➏. Implement the function `cached_fib_sum`
    ➍ so you first check whether you’ve computed `fib_sum` for the given length yet.
    (Treat the length `n` as a key into the cache.) If the key is present in the cache,
    simply return the result. If the key isn’t present, compute the correct answer
    with `fib_sum`, store the new key-value entry into `cache`, and return the result.
    Run the program again. Is it faster? Try `unordered_map` instead of `map`. Could
    you use a `vector` instead? How fast can you get the program to run?'
  id: totrans-699
  prefs: []
  type: TYPE_NORMAL
  zh: '**13-6.** 接下来，注释掉 ➎ 并取消注释 ➏。实现函数 `cached_fib_sum` ➍，首先检查是否已经为给定的长度计算了 `fib_sum`。(将长度
    `n` 视为缓存的键。) 如果缓存中存在该键，则直接返回结果。如果键不存在，则使用 `fib_sum` 计算正确的答案，将新的键值对存入 `cache`，然后返回结果。重新运行程序。它是否更快了？尝试使用
    `unordered_map` 而不是 `map`。你能使用 `vector` 吗？你能让程序运行得有多快？'
- en: Implement a Matrix class like `SquareMatrix` in [Listing 13-38](ch13.xhtml#ch13ex38).
    Your `Matrix` should allow unequal numbers of rows and columns. Accept as your
    constructor’s first argument the number of rows in `Matrix`.
  id: totrans-700
  prefs: []
  type: TYPE_NORMAL
  zh: 实现一个类似于 [Listing 13-38](ch13.xhtml#ch13ex38) 中的 `SquareMatrix` 的矩阵类。你的 `Matrix`
    应该允许行列数不相等。将构造函数的第一个参数设为 `Matrix` 的行数。
- en: '**FURTHER READING**'
  id: totrans-701
  prefs: []
  type: TYPE_NORMAL
  zh: '**进一步阅读**'
- en: '*ISO International Standard ISO/IEC (2017) — Programming Language C++* (International
    Organization for Standardization; Geneva, Switzerland; *[https://isocpp.org/std/the-standard/](https://isocpp.org/std/the-standard/)*)'
  id: totrans-702
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*ISO 国际标准 ISO/IEC (2017) — 编程语言 C++*（国际标准化组织；瑞士日内瓦； *[https://isocpp.org/std/the-standard/](https://isocpp.org/std/the-standard/)*）'
- en: '*The Boost C++ Libraries*, 2nd Edition, by Boris Schäling (XML Press, 2014)'
  id: totrans-703
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*《Boost C++ 库》*，第二版，Boris Schäling 著（XML Press，2014）'
- en: '*The C++ Standard Library: A Tutorial and Reference*, 2nd Edition, by Nicolai
    M. Josuttis (Addison-Wesley Professional, 2012)'
  id: totrans-704
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*《C++ 标准库：教程与参考》*，第二版，Nicolai M. Josuttis 著（Addison-Wesley Professional，2012）'
