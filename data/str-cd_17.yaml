- en: '13'
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '13'
- en: USING FILSKA
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Filska
- en: '![Image](Images/common01.jpg)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Images/common01.jpg)'
- en: In [Chapter 12](ch12.xhtml#ch12), we designed and implemented Filska. Now, let’s
    use it to write some programs. We’ll develop six Filska programs of increasing
    complexity to gain experience thinking in the restricted world Filska offers us.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第12章](ch12.xhtml#ch12)中，我们设计并实现了Filska。现在，让我们用它编写一些程序。我们将开发六个逐步复杂的Filska程序，以便在Filska所提供的受限世界中积累思维经验。
- en: To be more specific, this rather long chapter comprises disconnected sections,
    each implementing a particular Filska example. You need not read straight through
    because no section builds necessarily upon any previous section. Instead, the
    goal of the chapter is to present case studies in using Filska, all with the hope
    of helping you think about how to code in Filska and, more importantly, how to
    think in new ways to help you be more creative in your own coding tasks, regardless
    of the language. So put on your dancing shoes, turn the fiddle music up to 11,
    and get ready to have some (possibly) high-spirited fun.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 更具体地说，这一相对较长的章节由若干独立部分组成，每一部分实现一个特定的Filska示例。你不需要按顺序阅读，因为每一部分并不一定依赖于前面的部分。相反，本章的目标是展示使用Filska的案例研究，所有这些都希望帮助你思考如何用Filska编码，更重要的是，如何以新的方式思考，从而帮助你在自己的编码任务中更加富有创意，无论你使用哪种编程语言。所以，穿上你的舞鞋，把小提琴音乐调到11，准备好迎接一些（可能）充满活力的乐趣吧。
- en: '**Hello, World!**'
  id: totrans-5
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**你好，世界！**'
- en: We’d be remiss if we didn’t start with the expected “Hello, world!” example.
    The most obvious way to write it in Filska is to load the respective ASCII codes
    for each character into subprogram memory and call `chr` to output the string
    one character at a time. However, this is also quite boring and not the least
    bit mathematical, so we’ll forgo the obvious and instead embrace the obfuscated.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们不从预期的“你好，世界！”示例开始，我们就会失职。用Filska编写它最直接的方式是将每个字符的相应ASCII码加载到子程序内存中，并调用`chr`一次输出一个字符。然而，这样做也相当无聊，且毫无数学感，所以我们将放弃显而易见的方法，而选择采用一种晦涩的方式。
- en: '***Hello, Math!***'
  id: totrans-7
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***你好，数学！***'
- en: Let’s develop the necessary sequence of characters as a series of simple math
    operations. We’ll use the X register and output it as a character when needed.
    Therefore, we need a subprogram to output the X register as a character.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们将必要的字符序列作为一系列简单的数学运算来开发。我们将使用X寄存器，并在需要时将其输出为字符。因此，我们需要一个子程序来将X寄存器作为字符输出。
- en: '[PRE0]'
  id: totrans-9
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The above fits the bill. The first instruction moves X to the subprogram memory,
    and the second dumps the ASCII character it represents to the console. The final
    instruction returns to `main` and, as it is the final instruction, the next call
    from `main` to `dump` will loop around and begin again with `txm`, as we desire.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 上述序列符合要求。第一条指令将X移动到子程序内存，第二条指令将其表示的ASCII字符转储到控制台。最后一条指令返回到`main`，并且由于它是最后一条指令，`main`对`dump`的下一次调用将会循环回到`txm`，如我们所希望的那样。
- en: We can now dump ASCII characters in X to the console. Next we need our sequence
    of operations on X. The ASCII code for `H` is 72, so we’ll start there and move
    from the current character to the next via additions of positive and negative
    offsets. The sequence we need is
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以将X中的ASCII字符转储到控制台。接下来，我们需要对X执行一系列操作。`H`的ASCII码是72，因此我们将从这里开始，并通过加上正负偏移量从当前字符移动到下一个字符。我们需要的序列是：
- en: '| *X* ← 8*X* ←*X* × 9*X* ←*X* *–* 3*X* ←*X* + 7*X* ←*X* + 0*X* ←*X* + 3*X*
    ←*X* *–* 35*X* ←*X* *–* 12*X* ←*X* + 55*X* ←*X* *–* 8*X* ←*X* + 3*X* ←*X* *–*
    6*X* ←*X* *–* 8*X* ←*X* *–* 35 |'
  id: totrans-12
  prefs: []
  type: TYPE_TB
  zh: '| *X* ← 8*X* ← *X* × 9 *X* ← *X* *–* 3 *X* ← *X* + 7 *X* ← *X* + 0 *X* ← *X*
    + 3 *X* ← *X* *–* 35 *X* ← *X* *–* 12 *X* ← *X* + 55 *X* ← *X* *–* 8 *X* ← *X*
    + 3 *X* ← *X* *–* 6 *X* ← *X* *–* 8 *X* ← *X* *–* 35 |'
- en: Note that here we output X with `dump` after each operation except the first.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，在每次操作后，除了第一次，我们都会使用`dump`输出X。
- en: We have an assignment, a multiplication, and a bunch of additions. So we need
    `set`, `mul`, and `add` along with `jmp` to call `dump`. Translating the sequence
    into code gives us [Listing 13-1](ch13.xhtml#ch013list1).
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有一个赋值，一个乘法和一堆加法。因此，我们需要`set`、`mul`和`add`，以及`jmp`来调用`dump`。将这些操作转化为代码给出了[清单13-1](ch13.xhtml#ch013list1)。
- en: '[PRE1]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '*Listing 13-1: A first version of “Hello, world!” in Filska*'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单13-1：Filska中的“你好，世界！”的第一个版本*'
- en: '[Listing 13-1](ch13.xhtml#ch013list1) is in the file *hello.filska*. The code
    uses `*main*` ’s memory to hold the offset and X to hold the running total. Each
    operation on X is followed by a call to `*dump*` . The final three instructions
    output a newline character and then halt. As we might expect, removing `*hlt*`
    makes the code dump `*HELLO*,` `WORLD!` forever.'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: '[清单 13-1](ch13.xhtml#ch013list1) 在文件 *hello.filska* 中。代码使用 `*main*` 的内存来存储偏移量，X
    用来存储累计值。每次对 X 的操作后都会调用 `*dump*`。最后的三条指令输出一个换行符，然后停止。正如我们所预期的那样，移除 `*hlt*` 使得代码永远输出
    `*HELLO*,` `WORLD!`。'
- en: '***Hello, Poly!***'
  id: totrans-18
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***你好，Poly！***'
- en: '[Listing 13-1](ch13.xhtml#ch013list1) is indeed obfuscated, but we can do better
    while still dumping `HELLO, WORLD!` to the console. The ASCII values we need to
    dump as characters are'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: '[清单 13-1](ch13.xhtml#ch013list1)确实被混淆了，但我们可以做得更好，同时仍然将 `HELLO, WORLD!` 输出到控制台。我们需要作为字符输出的
    ASCII 值是'
- en: '[PRE2]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Can we create a mathematical function, *y* = *f* (*x*), to generate this sequence
    for *x* ∈ [0, 12]? If we had such a function, we could generate `HELLO,` `WORLD!`
    character by character with repeated calls to *f* (*x*) for *x* = 0, 1, *…*, 12.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 我们能否创建一个数学函数，*y* = *f* (*x*)，来生成这个 *x* ∈ [0, 12] 的序列？如果我们有这样的一个函数，我们可以通过重复调用
    *f* (*x*) 来一个字符一个字符地生成 `HELLO,` `WORLD!`，对于 *x* = 0, 1, *…*, 12。
- en: A good candidate for such a function is a polynomial. We remember these from
    our high school algebra days as sums of terms where each term is a coefficient
    multiplying some power of *x*. Let’s use a polynomial for *f* (*x*). The degree
    of the polynomial is the highest power of *x* present. We need to pick a degree
    for the polynomial and then find the set of coefficients. For example, if we decide
    to use a third-degree polynomial, we get
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 一个合适的函数候选者是多项式。我们还记得在高中代数课上学过，这些多项式是各项的和，每一项是系数与某个 *x* 的幂的乘积。让我们使用一个多项式来表示 *f*
    (*x*)。多项式的阶数是 *x* 的最高幂。我们需要选择一个多项式的阶数，然后找到系数集。例如，如果我们决定使用三次多项式，我们得到
- en: '*y* = *p*[0]*x*³ + *p*[1]*x*² + *p*[2]*x* + *p*[3]'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: '*y* = *p*[0]*x*³ + *p*[1]*x*² + *p*[2]*x* + *p*[3]'
- en: Remember that *x*¹ = *x* and *x*⁰ = 1\. The *p*s are the coefficients, and we
    need to find them somehow after picking the degree.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，*x*¹ = *x*，*x*⁰ = 1。*p* 是系数，我们需要在选择多项式的阶数后以某种方式找出它们。
- en: What we are talking about here is known as *curve fitting*, which is the process
    of finding the equation of a curve that best fits a set of data. For us, our dataset
    is the sequence of ASCII characters we want to generate along with the input *x*
    value, a sequence of points, (*x*, *y*), so that 72 = *f* (0), 69 = *f* (1), and
    so on.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里讨论的内容被称为*曲线拟合*，即寻找最适合一组数据的曲线方程的过程。对我们来说，我们的数据集是我们想要生成的 ASCII 字符序列以及输入 *x*
    值，一系列点 (*x*, *y*)，使得 72 = *f* (0)，69 = *f* (1)，依此类推。
- en: '[PRE3]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: We’ll use a polynomial for *f* (*x*), but we still need to pick a degree and
    then learn how to fit a polynomial of that degree to the dataset. It’s known that
    an *n –* 1 degree polynomial can perfectly fit a dataset with *n* points. Generally,
    this isn’t what is wanted. The point of fitting the function is to explain the
    trend of the data using the function to make meaningful predictions at points
    not measured. However, we actually *do* want to hit each data point exactly. Therefore,
    let’s use a 12th degree polynomial to fit our 13 points (see Equation 13.1). We
    now need to find the coefficients of
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用一个多项式来表示 *f* (*x*)，但我们仍然需要选择阶数，然后学习如何将该阶数的多项式拟合到数据集上。已知一个 *n –* 1 次多项式可以完美地拟合一个有
    *n* 个数据点的数据集。通常来说，这并不是我们想要的。拟合函数的目的是用函数来解释数据的趋势，以便在未测量的点上做出有意义的预测。然而，我们实际上*确实*希望精确通过每一个数据点。因此，让我们使用一个
    12 次多项式来拟合我们的 13 个数据点（见方程 13.1）。现在我们需要找出系数
- en: '![Image](Images/13eqa01.jpg)'
  id: totrans-28
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/13eqa01.jpg)'
- en: Great! How do we find the coefficients? The answer is to use *least-squares
    fitting*, a method for finding the values for *p* that minimize the square of
    the difference between the data points and the function value at those data points.
    Implementing a routine to do least-squares fitting to a polynomial is beyond the
    scope of this book. Fortunately, we can use the power of NumPy to do it for us.
    Incidentally, we’ll encounter least-squares fitting of data later in this chapter
    when we write a Filska program to fit data to a line.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 太好了！我们如何找到这些系数呢？答案是使用*最小二乘法拟合*，这是一种找到 *p* 值的方法，该值最小化数据点与函数值之间的平方差。在本书的范围内实现最小二乘法拟合到多项式超出了讨论范围。幸运的是，我们可以利用
    NumPy 的强大功能来为我们完成这项工作。顺便提一句，我们将在本章稍后遇到数据的最小二乘法拟合，当我们编写 Filska 程序来将数据拟合到一条直线时。
- en: 'Consider the Python program in *hello.py*. We won’t show the code here, but
    please do review it. The code uses NumPy, specifically the `np.polyfit` routine,
    to fit the dataset and generate the coefficients we need. The same code also calculates
    the difference between the dataset and the polynomial values at the given *x*
    values, and generates a plot of the resulting polynomial. NumPy found the following
    coefficients:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑一下 *hello.py* 中的 Python 程序。我们这里不展示代码，但请务必查看。该代码使用了 NumPy，特别是 `np.polyfit`
    函数，来拟合数据集并生成所需的系数。相同的代码还计算了数据集和给定 *x* 值下的多项式值之间的差异，并生成了由此产生的多项式图。NumPy 找到了以下系数：
- en: '[PRE4]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Here, each `P` is the coefficient for the corresponding power of *x*. The polynomial
    is sensitive enough that all digits displayed are necessary. Our Filska program
    will use these constants in all their glory.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，每个 `P` 是对应 *x* 的幂次的系数。该多项式的精度足够高，以至于所有显示的数字都是必要的。我们的 Filska 程序将使用这些常量，并完全保留它们。
- en: '[Figure 13-1](ch13.xhtml#ch013fig1) shows us what the polynomial looks like.
    The circles are the actual data points we want the polynomial to output, and the
    curve is the polynomial itself (Equation 13.1).'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 13-1](ch13.xhtml#ch013fig1) 显示了该多项式的形状。圆圈是我们希望多项式输出的实际数据点，而曲线则是多项式本身（方程
    13.1）。'
- en: '![Image](Images/13fig01.jpg)'
  id: totrans-34
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/13fig01.jpg)'
- en: '*Figure 13-1: The polynomial of Equation 13.1 and the actual data points to
    output*'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 13-1：方程 13.1 的多项式与实际数据点输出*'
- en: A glance at [Figure 13-1](ch13.xhtml#ch013fig1) shows that the 12th degree polynomial
    fit is hitting all the points we want it to hit, but the function itself acts
    wildly outside of those points, so it wouldn’t be a good fit to the dataset if
    we were looking to learn something about the general trend of the data. Thankfully,
    we aren’t. Instead, we’re looking to build a needlessly complicated implementation
    of `HELLO, WORLD!` so we are doing just fine with our 12th degree polynomial.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 一眼看[图 13-1](ch13.xhtml#ch013fig1)，可以看到 12 次方多项式拟合正好击中了我们想要拟合的所有点，但该函数在这些点外的表现却非常不稳定，因此，如果我们想要了解数据的一般趋势，它并不是一个好的拟合。然而，幸运的是，我们并不是在做这个。相反，我们正在构建一个不必要复杂的
    `HELLO, WORLD!` 实现，所以我们的 12 次方多项式完全足够。
- en: '***Hello, Poly Implementation!***'
  id: totrans-37
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***Hello，Poly 实现！***'
- en: Let’s start designing the Filska code. We need the equivalent of the Python
    code in [Listing 13-2](ch13.xhtml#ch013list2).
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始设计 Filska 代码。我们需要生成与[列表 13-2](ch13.xhtml#ch013list2)中 Python 代码等效的代码。
- en: '[PRE5]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '*Listing 13-2: Python code to generate HELLO, WORLD! with a polynomial*'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 13-2：使用多项式生成 HELLO, WORLD! 的 Python 代码*'
- en: The function `f(x)` implements the polynomial returning the *y* for any given
    *x*. The *x* values we need are the numbers from 0 through 12\. Looking at the
    `for` loop, each *x* is given to *f* (*x*) to create a *y* output, which is a
    floating-point number we need to round to the nearest integer. Rounding means
    *y* = 72*.*04 leads to *d* = 72 and *y* = 72*.*54 produces *d* = 73\. It’s *d*
    we’ll treat as the ASCII character code to output, which is precisely what the
    `print` statement is doing via `chr`. To round *y* to get integer *d*, we use
    the standard trick of adding 0.5 followed by `floor` to arrive at *d*. Without
    this rounding, the output will not be `HELLO, WORLD!` but `HDKKN+VNQLD!`
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 函数 `f(x)` 实现了该多项式，返回任何给定 *x* 的 *y* 值。我们需要的 *x* 值是从 0 到 12 的数字。查看 `for` 循环，每个
    *x* 都被传递给 *f* (*x*) 以生成 *y* 输出，这是一个浮动小数，我们需要将其四舍五入为最近的整数。四舍五入意味着 *y* = 72*.*04
    将得到 *d* = 72，而 *y* = 72*.*54 则产生 *d* = 73。我们将 *d* 作为 ASCII 字符代码来输出，这正是 `print`
    语句通过 `chr` 所做的。为了将 *y* 四舍五入得到整数 *d*，我们使用标准技巧，即加上 0.5 后再用 `floor` 来得到 *d*。没有这个四舍五入，输出就不会是
    `HELLO, WORLD!`，而是 `HDKKN+VNQLD!`
- en: To generate Filska code equivalent to [Listing 13-2](ch13.xhtml#ch013list2),
    we need a subprogram implementing *f* (*x*) and a main loop over the integers
    from 0 through 12\. After passing each integer to *f* (*x*) and rounding, we emit
    the result as a character. The complete code is in *hello2.filska*. We’ll present
    the important parts in [Listing 13-3](ch13.xhtml#ch013list3), but please review
    the entire file to see all the source code.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 为了生成与[列表 13-2](ch13.xhtml#ch013list2)等效的 Filska 代码，我们需要一个实现 *f* (*x*) 的子程序，以及一个对从
    0 到 12 的整数进行主循环。在将每个整数传递给 *f* (*x*) 并四舍五入之后，我们将结果作为字符输出。完整的代码在 *hello2.filska*
    中。我们将在[列表 13-3](ch13.xhtml#ch013list3)中展示重要部分，但请查看整个文件以查看所有源代码。
- en: '[PRE6]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '*Listing 13-3: The main loop of hello2.filska*'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 13-3：hello2.filska 的主循环*'
- en: '[Listing 13-3](ch13.xhtml#ch013list3) presents `main` and `dump`. Let’s begin
    with `dump`. We’ve seen this subprogram before in [Listing 13-1](ch13.xhtml#ch013list1).
    It takes the contents of a register, here Y, and dumps it as a character to the
    console before returning to `main`.'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: '[清单 13-3](ch13.xhtml#ch013list3) 展示了 `main` 和 `dump`。我们先从 `dump` 开始。我们之前在 [清单
    13-1](ch13.xhtml#ch013list1) 中见过这个子程序。它获取寄存器的内容，这里是 Y，然后将其作为字符转储到控制台，然后返回到 `main`。'
- en: The `main` subprogram of [Listing 13-3](ch13.xhtml#ch013list3) implements the
    loop over *x* values. In this case, we’ll use the X register as *x*, so we initialize
    it to 0 ➊. Next, we transfer control to the `calc` subprogram ➋. This subprogram
    implements *y* = *f* (*x*) and returns *y* in the Y register. We’ll get to `calc`’s
    implementation momentarily. With Y, the ASCII value we want for the current X,
    we call `dump` to display the character at the console.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: '[清单 13-3](ch13.xhtml#ch013list3) 中的 `main` 子程序实现了对 *x* 值的循环。在这种情况下，我们将使用 X
    寄存器作为 *x*，因此我们将其初始化为 0 ➊。接下来，我们将控制权转交给 `calc` 子程序 ➋。这个子程序实现了 *y* = *f* (*x*) 并将
    *y* 返回到 Y 寄存器。稍后我们会介绍 `calc` 的实现。通过 Y，我们可以获得当前 X 的 ASCII 值，然后调用 `dump` 来在控制台显示该字符。'
- en: We want *x* from 0 through 12, so we increment memory, which holds our counter
    ➌, and check to see if we’ve hit 13 characters ➍. If memory equals 13, the `tst`
    returns true and we jump ahead two instructions. Otherwise, *x* < 13 and we go
    back to the `tmx` instruction to move the new *x* value from memory to the X register.
    The program ends when *x* = 13 by outputting a newline character and calling `hlt`.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望 *x* 从 0 到 12，因此我们递增内存中保存的计数器 ➌，并检查是否已经达到 13 个字符 ➍。如果内存等于 13，`tst` 返回真，并且我们跳过两个指令。否则，*x*
    < 13，我们回到 `tmx` 指令，将新的 *x* 值从内存移到 X 寄存器。程序在 *x* = 13 时结束，输出换行符并调用 `hlt`。
- en: All we have left to implement is `calc`, the subprogram mapping X to Y via the
    polynomial. [Listing 13-2](ch13.xhtml#ch013list2) points the way for us. We need
    something like `f(x)`, which calculates the polynomial term by term. If we create
    a sequence of Filska instructions that find *px*^(*n*) for some power, *n*, and
    some coefficient, *p*, we need only accumulate the terms for all powers and coefficients
    to arrive at *y*. We also need to round *y*, but that comes after we calculate
    it.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 我们剩下的就是实现 `calc`，这个子程序通过多项式将 X 映射到 Y。[清单 13-2](ch13.xhtml#ch013list2) 为我们指明了方向。我们需要像
    `f(x)` 这样的东西，它逐项计算多项式。如果我们创建一个 Filska 指令序列，来计算某个幂次 *px*^(*n*) 和某个系数 *p*，那么我们只需要对所有的幂次和系数累加各项，最终得到
    *y*。我们还需要对 *y* 进行四舍五入，但这是在计算完它之后。
- en: Rather than show all of `calc`, we’ll show how we start accumulating the proper
    terms of the polynomial, how we end, and how we round before returning to `main`.
    See [Listing 13-4](ch13.xhtml#ch013list4).
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不会展示整个 `calc`，而是展示如何开始累加多项式的适当项，如何结束，以及如何在返回 `main` 之前进行四舍五入。请参见 [清单 13-4](ch13.xhtml#ch013list4)。
- en: '[PRE7]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '*Listing 13-4: The calc subprogram of hello2.filska*'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 13-4：hello2.filska 的 calc 子程序*'
- en: The code is sectioned into blocks that each raise X to some power, multiply
    it by the proper coefficient, and add the product to the total in Y. The first
    block starts the chain, and the last block concludes it. Let’s start with the
    highest power of X, which is 12 ➊.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 代码被分成了几个块，每个块将 X 提升到某个幂次，将其与适当的系数相乘，并将乘积添加到 Y 中的总和。第一个块启动链条，最后一个块结束链条。我们从 X
    的最高幂次开始，即 12 ➊。
- en: To calculate *y* = *f* (*x*), we’ll use subprogram memory and Z as scratch space
    and accumulate the value of the polynomial term by term in Y. To start, we move
    12 into M then to Z. Recall that `set` applies to only the current subprogram’s
    memory. Next, we calculate *x*^(12) by raising X to the Z power, putting the result
    back into Z. This is the `pow` instruction. Now we need to multiply *x*^(12) by
    the proper coefficient, so we set M to the necessary value, multiply by Z, and
    store the result in Y as the first term of the polynomial.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 为了计算 *y* = *f* (*x*)，我们将使用子程序内存和 Z 作为临时空间，并按项累加多项式的值到 Y 中。首先，我们将 12 移入 M 然后到
    Z。回想一下，`set` 仅适用于当前子程序的内存。接下来，我们通过将 X 提升到 Z 次方来计算 *x*^(12)，并将结果放回 Z 中。这就是 `pow`
    指令。现在，我们需要将 *x*^(12) 与适当的系数相乘，因此我们将 M 设置为所需的值，与 Z 相乘，并将结果存储在 Y 中，作为多项式的第一项。
- en: The next term of the polynomial is calculated similarly ➋. The difference here
    is using 11 as the exponent, multiplying by the proper coefficient for *x*^(11),
    and adding the product to Y via the `mul,m=mz` and `add,y=my` instructions. The
    polynomial’s remaining terms are found in precisely the same way, by replacing
    the exponent with 10, then 9, and so on down to 0, multiplying by the appropriate
    coefficients each time.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 多项式的下一个项以类似的方式计算 ➋。不同之处在于使用11作为指数，乘以*x*^(11)的适当系数，然后通过`mul,m=mz`和`add,y=my`指令将乘积加到Y中。多项式的其余项则通过同样的方式求得，每次将指数替换为10、9，依此类推，直到0，并每次乘以相应的系数。
- en: At this point, Y holds the answer. All that remains is to round it to the nearest
    integer ➌. We add 0.5 to Y, leaving the answer in M. Then, we call `*flr*` , move
    the result back to Y, and jump back to `main` to output Y as a character.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 此时，Y保存着答案。剩下的就是将其四舍五入到最接近的整数 ➌。我们将0.5加到Y中，并将答案保存在M中。然后，我们调用`*flr*`，将结果返回到Y，并跳回`main`以输出Y作为字符。
- en: In this section, we developed two obfuscated ways to dump the string `HELLO,
    WORLD!` to the console. How many more can you think of? If you create a novel
    approach, please share it with me, and I’ll put it on the book’s GitHub site.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们开发了两种混淆的方式，将字符串`HELLO, WORLD!`输出到控制台。你能想到更多的方式吗？如果你创造了一个新的方法，请与我分享，我会将它发布到本书的GitHub网站上。
- en: 'Let’s move on to our next example: one that introduces us to execution tracing
    with Filska.'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来我们来介绍下一个例子：它将引导我们通过Filska进行执行跟踪。
- en: '**Fibonacci, Anyone?**'
  id: totrans-58
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**斐波那契数列，谁来挑战一下？**'
- en: In the previous section, we spent far too much energy developing cute ways to
    output the string `HELLO, WORLD!`. This section will work with a more straightforward
    example and use it to explore execution tracing. Our goal is to generate as many
    terms of the Fibonacci sequence as can fit properly in a Python float.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 在前一节中，我们花费了过多的精力开发了有趣的方式来输出字符串`HELLO, WORLD!`。本节将处理一个更直接的例子，并利用它来探索执行跟踪。我们的目标是生成尽可能多的斐波那契数列项，以适应Python浮点数的范围。
- en: The Fibonacci sequence uses the recurrence relation
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 斐波那契数列使用递推关系：
- en: '*F*[1] = 1,    *F*[2] = 1'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: '*F*[1] = 1,    *F*[2] = 1'
- en: '*F**[n]* = *F*[*n**–*1] + *F*[*n**–*2]'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: '*F**[n]* = *F*[*n**–*1] + *F*[*n**–*2]'
- en: so that *F*[3] = *F*[2] + *F*[1] = 1 + 1 = 2, and *F*[4] = *F*[3] + *F*[2] =
    2 + 1 = 3, and so on. The first few terms of the Fibonacci sequence are
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，*F*[3] = *F*[2] + *F*[1] = 1 + 1 = 2，*F*[4] = *F*[3] + *F*[2] = 2 + 1 = 3，依此类推。斐波那契数列的前几个项是：
- en: 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144, …
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144, …
- en: The Fibonacci sequence is named after Leonardo Bonacci, sometimes referred to
    as Leonardo of Pisa or, most commonly, as Fibonacci. The sequence was known outside
    of Europe for well over a millennia when Fibonacci used it as an idealized example
    of rabbit population growth in his 1202 text *Liber Abaci* (*The Book of Calculation*).
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 斐波那契数列以莱昂纳多·博纳奇的名字命名，他有时被称为比萨的莱昂纳多，或更常见的称呼是斐波那契。该数列在欧洲以外的地区已经为人所知超过千年，当斐波那契在他1202年的著作《算术书》（*Liber
    Abaci*）中将其作为理想化的兔子种群增长例子时，它已经广为流传。
- en: Many books have been written about the Fibonacci sequence and all the places
    it appears in mathematics. There is even an academic publication, *The* Fibonacci
    Quarterly, with issues going back to 1963 (see *[https://www.fq.math.ca/](https://www.fq.math.ca/)*).
    Here we’ll relate only a few interesting observations about the sequence.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 有许多书籍讨论了斐波那契数列及其在数学中出现的各个地方。甚至有一本学术期刊，《斐波那契季刊》（*The Fibonacci Quarterly*），其期刊从1963年开始出版（见
    *[https://www.fq.math.ca/](https://www.fq.math.ca/)*）。在这里，我们将仅列出一些关于该数列的有趣观察。
- en: The Fibonacci sequence is intimately related to *ϕ* (phi), also known as the
    golden ratio
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 斐波那契数列与*ϕ*（黄金比例）密切相关。
- en: '![Image](Images/f0349-01.jpg)'
  id: totrans-68
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Images/f0349-01.jpg)'
- en: where the golden ratio is a solution to
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 其中黄金比例是以下方程的解：
- en: '![Image](Images/f0349-02.jpg)'
  id: totrans-70
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Images/f0349-02.jpg)'
- en: For example, if we set *y* = 1, we get
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果我们设定 *y* = 1，我们得到：
- en: '![Image](Images/f0349-03.jpg)'
  id: totrans-72
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Images/f0349-03.jpg)'
- en: or
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 或者
- en: '*x*² *–* *x* *–* 1 = 0'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: '*x*² *–* *x* *–* 1 = 0'
- en: with the positive solution, via the quadratic formula, as
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 使用二次公式，正解为：
- en: '![Image](Images/f0349-04.jpg)'
  id: totrans-76
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Images/f0349-04.jpg)'
- en: which is *ϕ*. Like the Fibonacci sequence, *ϕ* shows up everywhere in mathematics
    and nature. A link to the Fibonacci sequence comes from the fact that as *n* →*∞*,
    the ratio of the *n* + 1th Fibonacci number to the *n*th approaches *ϕ*
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 它是*ϕ*。与斐波那契数列一样，*ϕ*在数学和自然界中无处不在。与斐波那契数列的联系来自于这样的事实：当 *n* → *∞* 时，*n* + 1项的斐波那契数与
    *n* 项斐波那契数的比值接近 *ϕ*。
- en: '![Image](Images/f0349-05.jpg)'
  id: totrans-78
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Images/f0349-05.jpg)'
- en: where the last ratio is *ϕ* to the precision of a Python float.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 其中最后的比率是*ϕ*，以Python浮动精度表示。
- en: With *ϕ* in hand, we can calculate the *n*th Fibonacci number directly via
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 有了*ϕ*，我们可以通过直接计算*F[n]*来获得第*n*个斐波那契数。
- en: '![Image](Images/f0350-01.jpg)'
  id: totrans-81
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Images/f0350-01.jpg)'
- en: which works in code for small values of *n*, but fails when *n* gets large because
    of precision issues.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 该代码对于小值的*n*有效，但当*n*变大时，由于精度问题，它会失败。
- en: We could fill the remainder of this book with fascinating facts and observations
    about the Fibonacci sequence, but we’ll bring things back to coding and implement
    the sequence in Filska (see [Listing 13-5](ch13.xhtml#ch013list5)). The code itself
    is in *fib.filska*.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 我们本可以用关于斐波那契数列的有趣事实和观察填满本书，但我们会回到编码问题，使用Filska实现该数列（参见[清单13-5](ch13.xhtml#ch013list5)）。代码本身位于*fib.filska*中。
- en: '[PRE8]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '*Listing 13-5: Generating the Fibonacci sequence*'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单13-5：生成斐波那契数列*'
- en: In [Listing 13-5](ch13.xhtml#ch013list5) we initialize a counter in Z set to
    78 ➊. Therefore, we’ll output 78 Fibonacci numbers, counting Z down by 1 each
    time until it is 0\. Why 78? Because *F*[78] = 8,944,394,323,791,464 is the largest
    Fibonacci number that fits in a 64-bit float. Were Filska extended to operate
    on integers as Python integers instead of Python floats, we could generate Fibonacci
    numbers until we run out of memory.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 在[清单13-5](ch13.xhtml#ch013list5)中，我们初始化了一个计数器Z，设置为78 ➊。因此，我们将输出78个斐波那契数，每次将Z递减1，直到它变为0。为什么是78？因为*F*[78]
    = 8,944,394,323,791,464是最大一个可以容纳在64位浮动数中的斐波那契数。如果Filska扩展为处理整数（像Python整数而非Python浮点数），我们就可以生成斐波那契数，直到内存用尽。
- en: To get the first two numbers, we decrement Z twice and print the constant `1`
    twice. Boring, but effective. Then, we use the X and Y registers to
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 要得到前两个数字，我们将Z递减两次，并打印常数`1`两次。乏味，但有效。接着，我们使用X和Y寄存器来
- en: hold the previous two Fibonacci numbers and their sum to generate the next.
    The recurrence loop begins by calculating the next Fibonacci number ➋. X and Y
    are updated by shifting the current value of Y to X and the new Fibonacci value
    in M to Y. We then decrement Z and branch forward to `hlt` if it is 0; otherwise,
    the loop repeats ➋. [Listing 13-5](ch13.xhtml#ch013list5) is straightforward;
    therefore, it’s a good example for execution tracing.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 保留前两个斐波那契数及其和来生成下一个。递归循环通过计算下一个斐波那契数开始 ➋。X和Y通过将当前Y值移到X并将新的斐波那契值存入M更新。然后，我们递减Z并在Z为0时跳转到`hlt`；否则，循环重复
    ➋。[清单13-5](ch13.xhtml#ch013list5)非常直观，因此是执行追踪的好例子。
- en: 'To run *fib.filska* with tracing, use a command line like this:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 要带追踪运行*fib.filska*，请使用如下命令行：
- en: '[PRE9]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The `-t` flag is the signal to trace execution, one instruction at a time. Doing
    this presents us with
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: '`-t`标志表示逐条指令追踪执行。这样会呈现给我们'
- en: '[PRE10]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'and a prompt waiting for us to hit ENTER or `q` to quit. Let’s break down the
    status line:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 并且出现一个提示，等待我们按ENTER键继续或按`q`退出。让我们来分解一下状态行：
- en: '| Displayed Text | Description |'
  id: totrans-94
  prefs: []
  type: TYPE_TB
  zh: '| 显示文本 | 描述 |'
- en: '| --- | --- |'
  id: totrans-95
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `CP:MAIN` | Current subprogram name |'
  id: totrans-96
  prefs: []
  type: TYPE_TB
  zh: '| `CP:MAIN` | 当前子程序名称 |'
- en: '| `PC:000` | Current program counter |'
  id: totrans-97
  prefs: []
  type: TYPE_TB
  zh: '| `PC:000` | 当前程序计数器 |'
- en: '| `X:0.000000` | Register values |'
  id: totrans-98
  prefs: []
  type: TYPE_TB
  zh: '| `X:0.000000` | 寄存器值 |'
- en: '| `Y:0.000000` |  |'
  id: totrans-99
  prefs: []
  type: TYPE_TB
  zh: '| `Y:0.000000` |  |'
- en: '| `Z:0.000000` |  |'
  id: totrans-100
  prefs: []
  type: TYPE_TB
  zh: '| `Z:0.000000` |  |'
- en: '| `M:0.000000` | Local memory value |'
  id: totrans-101
  prefs: []
  type: TYPE_TB
  zh: '| `M:0.000000` | 本地内存值 |'
- en: '| `Z:0` | “Zero” flag |'
  id: totrans-102
  prefs: []
  type: TYPE_TB
  zh: '| `Z:0` | “零”标志 |'
- en: '| `E:0` | “Equal” flag |'
  id: totrans-103
  prefs: []
  type: TYPE_TB
  zh: '| `E:0` | “相等”标志 |'
- en: '| `L:0` | “Less than” flag |'
  id: totrans-104
  prefs: []
  type: TYPE_TB
  zh: '| `L:0` | “小于”标志 |'
- en: '| `G:0` | “Greater than” flag |'
  id: totrans-105
  prefs: []
  type: TYPE_TB
  zh: '| `G:0` | “大于”标志 |'
- en: The next instruction is `set,78`. Hitting ENTER gives us
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 下一条指令是`set,78`。按下ENTER键后，我们得到
- en: '[PRE11]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: showing us that local memory is now 78 and that the next instruction is `dec`.
    If we press ENTER exactly seven times from this instruction, we pass through to
    the `jmp,nl` instruction
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 显示我们本地内存现在是78，并且下一条指令是`dec`。如果从这一条指令开始，我们按ENTER键正好七次，就会跳转到`jmp,nl`指令。
- en: '[PRE12]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: telling us that we are about to execute the first instruction of subprogram
    `nl`. How do we know it’s the first instruction? Because the program counter,
    `PC`, is 0\. Note also that the X register is 1, set previously by the `tmx` instruction
    in `main`.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 告诉我们即将执行子程序`nl`的第一条指令。我们怎么知道是第一条指令？因为程序计数器`PC`是0。还要注意，X寄存器的值是1，这是之前通过`tmx`指令在`main`中设置的。
- en: After three more presses of ENTER, we get
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 再按三次ENTER键后，我们得到
- en: '[PRE13]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: which shows us back in `main` and about to execute instruction 8 to move the
    1 from memory to Y.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 显示我们回到了`main`，并即将执行第8条指令，将1从内存移动到Y寄存器。
- en: Six more presses of ENTER later, and the one after that gives
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 六次按ENTER键后，再按一次ENTER，结果给出
- en: '[PRE14]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'The `add` instruction has set local memory to 2: *M* ←*X* + *Y*.'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: '`add`指令将本地内存设置为2：*M* ←*X* + *Y*。'
- en: Repeated ENTER keypresses trace through the remainder of the recurrence loop
    to `tst` on Z equal to 0 and then follow `gto` back to `add`, looping until Z
    is eventually 0.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 重复按下 ENTER 键会跟踪剩余的递归循环，直到 Z 为 0 并且返回到 `gto` 指令，再回到 `add`，直到 Z 最终为 0。
- en: The tracing functionality is quite useful when developing Filska programs. Also
    helpful is working with code in small pieces—usually individual subprograms—to
    get them running as they should.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 追踪功能在开发 Filska 程序时非常有用。另一种有帮助的方法是分块编写代码——通常是独立的子程序——并确保它们按预期运行。
- en: The remainder of this chapter presents several other Filska programs for fun
    and learning. Let’s see how Filska generates random numbers.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的其余部分展示了几个其他的 Filska 程序，供娱乐和学习使用。让我们来看一下 Filska 如何生成随机数。
- en: '**Random Numbers**'
  id: totrans-120
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**随机数**'
- en: Filska’s `rnd` instruction sets subprogram memory to a random floating-point
    number, [0,1). In reality, of course, this number isn’t random, but a pseudorandom
    approximation. Also, it’s cheating because `rnd` is using Python’s `random` module
    under the hood. Python’s `random` module uses the Mersenne Twister pseudorandom
    number generator, a pretty good generator that is sufficient for all but the most
    demanding of tasks. One measure of a pseudorandom generator’s quality is its *period*,
    that is, how many numbers it can generate before the sequence begins to repeat.
    For the Mersenne Twister, the period is 2^(19937) *–* 1, which should be good
    enough for most anyone.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: Filska 的 `rnd` 指令将子程序内存设置为一个随机的浮点数，范围为 [0,1)。当然，实际上这个数并不是随机的，而是一个伪随机的近似值。此外，这其实是作弊，因为
    `rnd` 在后台使用了 Python 的 `random` 模块。Python 的 `random` 模块使用的是 Mersenne Twister 伪随机数生成器，这是一个相当好的生成器，足以满足除最苛刻任务之外的所有需求。评估伪随机生成器质量的一个指标是其
    *周期*，即它在序列开始重复之前能够生成多少个数字。对于 Mersenne Twister 来说，周期为 2^(19937) *–* 1，这对于大多数人来说已经足够了。
- en: In this section, we’ll develop code to generate pseudorandom numbers with Filska
    *without* cheating, that is, without the `rnd` instruction. Instead, we’ll implement
    the Park and Miller linear congruential generator, also known as MINSTD. This
    linear congruential generator is a simple algorithm with a period of about 2^(31).
    Far less than the Mersenne Twister period, but still quite sufficient for many
    noncritical tasks like games.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将编写代码来生成伪随机数，且不作弊，也就是不使用 `rnd` 指令。相反，我们将实现 Park 和 Miller 线性同余生成器，也叫 MINSTD。这个线性同余生成器是一个简单的算法，周期大约为
    2^(31)。虽然比 Mersenne Twister 的周期要短得多，但对于许多非关键任务，比如游戏，依然非常足够。
- en: '***Implementing MINSTD***'
  id: totrans-123
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***实现 MINSTD***'
- en: Most pseudorandom number generators are iterative, meaning the previous pseudorandom
    value is used to generate the next. The first value in the sequence is generated
    from a user-supplied seed value. Fixing the seed value fixes the sequence of values
    generated. In this way, it’s possible to create a deterministic sequence of values
    that pass randomness tests, as strange as that sounds.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数伪随机数生成器都是迭代的，这意味着前一个伪随机值用于生成下一个。序列中的第一个值是从用户提供的种子值生成的。固定种子值就会固定生成的值序列。通过这种方式，可以创建一个通过随机性测试的确定性值序列，虽然听起来有些奇怪。
- en: '**NOTE**'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*There exist pseudorandom generators capable of generating the *n*th value
    of the sequence for a specified seed *without* generating the* n – *1 values before
    it. To find such a generator, search for “counter-based random number generator.”*'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: '*存在一些伪随机生成器能够在不生成前 *n – 1* 个值的情况下直接生成指定种子下的 *n* 值。要找到这样的生成器，可以搜索“基于计数器的随机数生成器”。*'
- en: 'The Park and Miller algorithm runs as follows:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: Park 和 Miller 算法运行如下：
- en: Select a seed value and call it *x*[0].
  id: totrans-128
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择一个种子值并将其命名为 *x*[0]。
- en: 'Generate the next seed value: *x*[*i*+1] ← 48271*x**[i]* mod (2^(31) *–* 1).'
  id: totrans-129
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 生成下一个种子值：*x*[*i*+1] ← 48271 *x*[*i*] mod (2^(31) *–* 1)。
- en: 'Return the floating-point version: *x*[*i*+1]/(2^(31) *–* 1).'
  id: totrans-130
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 返回浮点版本：*x*[*i*+1] / (2^(31) *–* 1)。
- en: Use *x*[*i*+1] as *x*[*i*] for the next pseudorandom value.
  id: totrans-131
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 *x*[*i*+1] 作为 *x*[*i*] 来生成下一个伪随机值。
- en: The algorithm is a recurrence relation similar to what we used above for generating
    Fibonacci numbers. Therefore, we expect an initialization section followed by
    a loop that spits out the next number in the sequence as a float. For the seed,
    *x*[0], we are free to pick any integer in [1, 2^(31) *–* 1). We’ll use 8,675,309,
    but you can replace it with any number you wish to get a different sequence of
    values. The code we need is in *random.filska* (see [Listing 13-6](ch13.xhtml#ch013list6)).
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 该算法是一个递归关系，类似于我们上面用于生成斐波那契数的关系。因此，我们预计会有一个初始化部分，后面跟着一个循环，输出序列中的下一个浮动值。对于种子，*x*[0]，我们可以自由选择任何整数，范围是[1,
    2^(31) *–* 1)。我们将使用8,675,309，但你可以用任何你喜欢的数字替换它，以获得不同的值序列。我们需要的代码在*random.filska*中（请参见[清单13-6](ch13.xhtml#ch013list6)）。
- en: '[PRE15]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '*Listing 13-6: Park and Miller LCG in Filska*'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单13-6：Filska中的Park和Miller LCG*'
- en: '[Listing 13-6](ch13.xhtml#ch013list6) initializes X with the desired seed,
    stores the multiplier (48,271) in memory, and starts the loop to calculate the
    next seed value. The recurrence relation is implemented in stages. First, the
    seed in X is multiplied by 48,271, with the result back in X. Then 2^(31) *–*
    1 is loaded into memory, followed by the modulo operation, again with the result
    in X. X is now the next value in the sequence. The floating-point version is output
    by `make_float`, which divides X by 2^(31) *–* 1, dumping the result to the console
    along with a newline to get one pseudorandom float per line. Back in `main`, the
    loop continues, so the program dumps floats forever.'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: '[清单13-6](ch13.xhtml#ch013list6)初始化X为所需的种子，将乘数（48,271）存储在内存中，并启动循环来计算下一个种子值。递归关系是分阶段实现的。首先，X中的种子乘以48,271，结果存回X中。然后，2^(31)
    *–* 1被加载到内存中，接着进行取模操作，结果再次存回X中。X现在是序列中的下一个值。浮点版本通过`make_float`输出，它将X除以2^(31) *–*
    1，并将结果与换行符一起输出到控制台，以便每行得到一个伪随机浮点数。在`main`中，循环继续进行，因此程序会不断地输出浮点数。'
- en: Run the program and direct output to a file, say *numbers.txt*.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 运行程序并将输出重定向到一个文件，例如 *numbers.txt*。
- en: '[PRE16]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Allow the program to run for maybe 15 minutes, or until there are more than
    1 million lines in the file. We need many values to get meaningful statistics
    on the quality of the output, and the more the merrier. When you get tired of
    waiting, use CTRL-C to exit the program.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 让程序运行大约15分钟，或者直到文件中有超过100万行。我们需要许多值才能对输出的质量进行有意义的统计分析，值越多越好。当你等得不耐烦时，使用CTRL-C退出程序。
- en: '***Evaluating MINSTD***'
  id: totrans-139
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***评估MINSTD***'
- en: We now have a large text file of floating-point values. They certainly look
    random enough, but are they? How can we tell? The honest answer is that we can’t.
    We cannot *prove* these are random values, and in fact, we know that they aren’t
    because we used a deterministic method to generate them. John von Neumann, one
    of the founders of computer science, famously quipped that anyone considering
    deterministic methods for generating random numbers is “in a state of sin.” Still,
    we’d like to think the sequence we just generated is at least random-ish, meaning
    knowing one value doesn’t help us much in guessing the next value.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了一个包含浮点值的大文本文件。它们看起来肯定足够随机，但它们真的是吗？我们如何判断？老实说，我们不能。我们不能*证明*这些是随机值，实际上我们知道它们不是，因为我们使用了确定性的方法来生成它们。计算机科学的创始人之一约翰·冯·诺依曼曾著名地调侃过，任何考虑使用确定性方法生成随机数的人都是“处于罪恶状态”。尽管如此，我们还是希望认为我们刚生成的序列至少是随机的——也就是说，知道一个值并不会对猜测下一个值有太大帮助。
- en: 'As it happens, there are many highly sophisticated ways to test for randomness.
    None are conclusive, but as a group, they lend credence to a belief that a sequence
    of values is random for all practical purposes. The tests are extensive, far beyond
    what we need, but fortunately for us, there is one that is simple, easy to evaluate,
    and included with standard Linux distributions. To boot, it has a cool, Tolkienesque
    name: `ent`.'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 事实上，有许多高度复杂的方法可以测试随机性。没有一种是结论性的，但作为一个整体，它们给人一种信念，即对于所有实际目的来说，值的序列是随机的。这些测试非常广泛，远超我们的需求，但幸运的是，有一种方法既简单、易于评估，而且包含在标准Linux发行版中。更棒的是，它有一个酷炫的托尔金式名字：`ent`。
- en: However, `ent` only works with random *bytes*, not floating-point numbers. That’s
    okay; a snippet of Python converts our file of random floats into a file of random
    bytes.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，`ent`只适用于随机的*字节*，而不是浮点数。没关系；一个Python代码片段可以将我们包含随机浮点数的文件转换为包含随机字节的文件。
- en: '[PRE17]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: We assume the captured floats are in the file *numbers.txt*. The byte version
    is stored in *random.dat*. The array `d` contains the floats read from *numbers.txt*.
    The loop generates a list, `b`, of integers found by multiplying the float value
    by 256 and dropping any fractional part via `floor`. Lastly, the list of integers
    is formed into a byte array and dumped into the output file.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 我们假设捕获的浮点数保存在文件*numbers.txt*中。字节版本则存储在*random.dat*中。数组 `d` 包含从 *numbers.txt*
    读取的浮点数。循环生成一个整数列表 `b`，通过将浮点值乘以 256 并使用 `floor` 函数舍去任何小数部分来得到整数。最后，整数列表被转化为字节数组并写入输出文件。
- en: Let’s run `ent` on *random.dat*
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在*random.dat*上运行 `ent`
- en: '[PRE18]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: producing
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 生成中
- en: '[PRE19]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: The values you see when you run the code will be slightly different because
    the number of randoms generated before hitting CTRL-C will be different, or if
    you change the seed value.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 当你运行代码时，你看到的值会略有不同，因为在按下 CTRL-C 之前生成的随机数数量不同，或者如果你改变了种子值的话。
- en: 'What to make of `ent`’s output? We’ll skip the chi-square part and consider
    the other metrics: entropy/compression, arithmetic mean value, estimate of *π*,
    and the serial correlation.'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 如何解读 `ent` 的输出？我们跳过卡方部分，考虑其他度量：熵/压缩、算术平均值、*π*的估算和序列相关性。
- en: The *entropy* is a measure of the information content, in this case as bits
    per byte. There are eight bits in a byte, so the maximum possible entropy is 8.0\.
    This means there is no way to simplify the file’s representatio, as there is no
    redundancy. Our file has an entropy of 7.999803 bits per byte, meaning it’s close
    to maximum randomness. This is essentially what the statement about optimum compression
    is saying.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: '*熵*是信息内容的度量，在这里以每字节比特数表示。一个字节有 8 位，所以最大可能的熵是 8.0。这意味着文件的表示没有简化的空间，因为没有冗余。我们的文件熵为
    7.999803 比特每字节，接近最大随机性。这基本上就是关于最优压缩的说法所指的意思。'
- en: If the file consists of purely random bytes, we expect as many bytes to be above
    the median value of 127.5 / 2 as below, so the arithmetic mean should be 127.5\.
    Our file has a mean value of 127.5722, which, again, is pretty close to what we’d
    expect from a random sequence.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 如果文件完全由随机字节组成，我们预计有一半的字节值会高于中位数 127.5 / 2，另一半低于中位数，因此算术平均值应该是 127.5。我们的文件平均值是
    127.5722，这再次接近我们从随机序列中期望得到的值。
- en: A Monte Carlo process simulates something. In this case, it’s using the random
    bytes to simulate dart throws then asking how many darts land inside a circle
    of radius 1 and how many land inside a square of side 1 circumscribed over the
    circle. The ratio of darts landing within the circle to those landing within the
    square leads to an estimate of *π*. Here, the estimate is in the ballpark but
    not too impressive. Also, there are only 1 million or so values in the file. Most
    randomness tests want hundreds of millions to billions of examples before making
    a statement, so we are doing well here, too.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 蒙特卡洛过程用于模拟某种事情。在这个例子中，它使用随机字节模拟掷飞镖，然后询问有多少个飞镖落在半径为 1 的圆内，有多少个落在圆内外接正方形的一边为 1
    的正方形内。落在圆内的飞镖与落在正方形内的飞镖之比可以估算出*π*值。这里的估算结果接近真实值，但并不十分精准。此外，文件中只有大约 100 万个值。大多数随机性测试需要数亿到数十亿个样本才能得出结论，因此我们在这里也表现得不错。
- en: The final test is a serial correlation test. The earlier tests looked at the
    values without caring about their ordering in the file. The serial test pays attention
    to the order. It’s looking to see if knowing the value of one byte gives you knowledge
    about the value of the next byte. For a random sequence, there should be no such
    correlation. Here we get a slight negative correlation, which, again, is a reasonable
    statement that we’ve generated a (mostly) random sequence.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 最后的测试是序列相关性测试。之前的测试关注的是数值本身，而不考虑它们在文件中的顺序。序列测试则关注顺序。它要检查的是，知道一个字节的值是否可以帮助你推测下一个字节的值。对于随机序列，应该没有这种相关性。在这里我们得到的是轻微的负相关性，这同样是一个合理的说法，表明我们已经生成了一个（大部分）随机的序列。
- en: The results above give us confidence that our Filska pseudorandom number generator
    is working correctly. Let’s move on to our next example, one that also generates
    data to be captured in a file.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 上面的结果让我们有信心认为我们的 Filska 伪随机数生成器正常工作。接下来我们将进入下一个示例，它同样会生成数据并将其保存到文件中。
- en: '**A Simple Fractal**'
  id: totrans-156
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**一个简单的分形**'
- en: In [Chapter 10](ch10.xhtml#ch10) we briefly encountered the Sierpiński triangle.
    Let’s see how to generate the points of this fractal in Filska. The algorithm
    is
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第10章](ch10.xhtml#ch10)中，我们简要接触过 Sierpiński 三角形。让我们看看如何在 Filska 中生成这个分形的点。算法是：
- en: 'Define three triangle vertices: (*x*[0], *y*[0]), (*x*[1], *y*[1]), and (*x*[2],
    *y*[2]).'
  id: totrans-158
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义三个三角形顶点：(*x*[0], *y*[0])、(*x*[1], *y*[1]) 和 (*x*[2], *y*[2])。
- en: Choose one vertex at random, say (*x*, *y*) = (*x*[0], *y*[0]).
  id: totrans-159
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 随机选择一个顶点，例如 (*x*, *y*) = (*x*[0], *y*[0])。
- en: Select another vertex at random, say (*x*[1], *y*[1]).
  id: totrans-160
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 随机选择另一个顶点，例如 (*x*[1], *y*[1])。
- en: Update ![Image](Images/f0356-01.jpg).
  id: totrans-161
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更新 ![图片](Images/f0356-01.jpg)。
- en: Output (*x*, *y*) to be plotted later.
  id: totrans-162
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 输出 (*x*, *y*) 以便稍后绘制。
- en: Repeat from Step 3 for the desired number of points.
  id: totrans-163
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从步骤 3 开始，重复所需的点数。
- en: In essence, we plot the midpoint between the current point and a randomly selected
    vertex of the triangle and repeat until we generate as many points as we wish
    to plot. Once again, this is a recurrence relation where the *n* + 1th point is
    constructed from the *n*th point, only now we are working in two dimensions, not
    one (see [Listing 13-7](ch13.xhtml#ch013list7)).
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 本质上，我们绘制当前点与随机选择的三角形顶点之间的中点，并重复此过程，直到我们生成足够多的点来绘制。再一次，这是一个递归关系，其中 *n* + 1 个点是从
    *n* 个点构造的，只不过现在我们是在二维空间中工作，而不是一维空间（参见 [列表 13-7](ch13.xhtml#ch013list7)）。
- en: '[PRE20]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: '*Listing 13-7: Pseudocode for the Sierpiński triangle*'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 13-7：谢尔皮ński三角形的伪代码*'
- en: 'Let’s make the algorithm explicit with pseudocode. First, we’ll pick the vertices
    of the triangle: (0,0); (0.5,1); (1,0). Then, we need to code [Listing 13-7](ch13.xhtml#ch013list7)
    where `rnd` returns a random float, [0, 1). We initialize *x* and *y* to the point
    (1,0). Any of the three points would do.'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过伪代码使算法更加明确。首先，我们选择三角形的顶点：(0,0)；(0.5,1)；(1,0)。然后，我们需要编码 [列表 13-7](ch13.xhtml#ch013list7)，其中
    `rnd` 返回一个随机浮点数，[0, 1)。我们将 *x* 和 *y* 初始化为点 (1,0)。任意三个点都可以。
- en: Next, we start a loop for the desired number of points, `N`. The three cases
    select one of the three vertex points with equal probability. If the random value
    in `r` is below one-third, we’ve selected the first point, (0,0), so the midpoint
    is the average of both the *x* and *y* values plus 0 and 0\. Similarly, if `r`
    is 0*.*333333 ≤*r* < 0*.*666666, we select the vertex at (0.5,1). Lastly, if `r`
    is ≥ 0*.*666666, we use the vertex at (1,0). After updating *x* and *y*, we print
    them as a pair and repeat the loop.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们开始一个循环，重复所需数量的点 `N`。三个案例以相等的概率选择三个顶点中的一个。如果 `r` 中的随机值小于三分之一，我们选择第一个点 (0,0)，因此中点是
    *x* 和 *y* 值的平均值，再加上 0 和 0。同样地，如果 `r` 是 0*.*333333 ≤*r* < 0*.*666666，我们选择顶点 (0.5,1)。最后，如果
    `r` ≥ 0*.*666666，我们使用顶点 (1,0)。更新 *x* 和 *y* 后，我们将它们作为一对打印出来并重复循环。
- en: The midpoint formulas simplify as shown in [Listing 13-7](ch13.xhtml#ch013list7).
    Observe that each pass through the loop updates *x* and *y* by first dividing
    by 2 (multiplying by 0.5) and then adding an offset depending upon the selected
    vertex. If the vertex is (0,0), the offset is 0 for both *x* and *y*. If the vertex
    is (0.5,1), the offset is 0.25 in *x* and 0.5 in *y*. Lastly, for (1,0), the offset
    is 0.5 in *x* and 0 for *y*.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 中点公式简化如 [列表 13-7](ch13.xhtml#ch013list7) 所示。请注意，每次循环都会通过首先将 *x* 和 *y* 除以 2（即乘以
    0.5），然后根据选定的顶点添加偏移量来更新 *x* 和 *y*。如果顶点是 (0,0)，则 *x* 和 *y* 的偏移量为 0。如果顶点是 (0.5,1)，则
    *x* 的偏移量为 0.25，*y* 的偏移量为 0.5。最后，对于 (1,0)，*x* 的偏移量为 0.5，*y* 的偏移量为 0。
- en: This observation means the loop can be rewritten first to divide *x* and *y*
    by 2, and then we can add the offset—there is no need to have code that calculates
    the repeated instances of `0.5*x` and `0.5*y` as shown in [Listing 13-7](ch13.xhtml#ch013list7).
    This simplification helps considerably when writing the Filska implementation.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 这一观察意味着我们可以重写循环，首先将 *x* 和 *y* 除以 2，然后我们可以加上偏移量——不需要像 [列表 13-7](ch13.xhtml#ch013list7)
    中那样计算 `0.5*x` 和 `0.5*y` 的重复实例。这一简化在编写 Filska 实现时大有帮助。
- en: 'Our implementation uses three subprograms: `main`, `loop`, and `print`. Also,
    we’ll store the current *x* value in the X register and, not surprisingly, the
    current *y* value in the Y register. We’ll use `main` to initialize X and Y, set
    up the counter for the desired number of output points, which we’ll store in Z,
    and then transfer execution to `loop` (see [Listing 13-8](ch13.xhtml#ch013list8)).'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的实现使用了三个子程序：`main`、`loop` 和 `print`。此外，我们将当前的 *x* 值存储在 X 寄存器中，显然，当前的 *y* 值存储在
    Y 寄存器中。我们将使用 `main` 来初始化 X 和 Y，设置用于输出点的计数器，我们将其存储在 Z 中，然后将执行转移到 `loop`（参见 [列表
    13-8](ch13.xhtml#ch013list8)）。
- en: '[PRE21]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: '*Listing 13-8: The main loop of sierpinski.filska*'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 13-8：sierpinski.filska 的主循环*'
- en: Next, we’ll use `print` to display the X and Y registers as an (*x*, *y*) pair
    on the same line (see [Listing 13-9](ch13.xhtml#ch013list9)).
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将使用 `print` 显示 X 和 Y 寄存器作为 (*x*, *y*) 对并输出到同一行（参见 [列表 13-9](ch13.xhtml#ch013list9)）。
- en: '[PRE22]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: '*Listing 13-9: The print subprogram of sierpinski.filska*'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 13-9：sierpinski.filska的打印子程序*'
- en: '[Listing 13-9](ch13.xhtml#ch013list9) first moves X to local memory to print
    it. Then it prints two spaces (character 32) before printing Y and a newline.'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: '[清单 13-9](ch13.xhtml#ch013list9)首先将X移动到本地内存中进行打印。然后它打印两个空格（字符32），再打印Y并换行。'
- en: '[Listing 13-10](ch13.xhtml#ch013list10) contains the bulk of the program. It’s
    the body of the loop in [Listing 13-7](ch13.xhtml#ch013list7).'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: '[清单 13-10](ch13.xhtml#ch013list10)包含了程序的大部分内容。它是[清单 13-7](ch13.xhtml#ch013list7)中的循环体。'
- en: '[PRE23]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: '*Listing 13-10: The loop subprogram of sierpinski.filska*'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 13-10：sierpinski.filska的循环子程序*'
- en: First, we divide the X and Y registers by 2 ➊. Then, we use `loop`’s memory
    to hold a random value ➋.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将X和Y寄存器各自除以2 ➊。然后，我们使用`loop`的内存来保存一个随机值 ➋。
- en: If the random value is less than 0.333333, the `tst,l,10` instruction ➌ is true
    and execution moves to the `jmp` to `print` ➐. This is the (0,0) vertex where
    there is no offset to add. If memory is less than 0.666666 ➍, execution moves
    to adding an offset of 0.25 to X and 0.5 to Y ➏. This is the (0.5,1) vertex case.
    Lastly, if memory is greater than or equal to 0.666666, we have the (1,0) case
    so we need only add an offset of 0.5 to X ➎. After printing the new X and Y values
    ➐, the Z register is decremented and tested for 0 ➑. If Z is 0, `hlt` stops the
    program. If not, the `loop` subprogram is run from the beginning courtesy of the
    `jpr` instruction.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 如果随机值小于0.333333，`tst,l,10`指令 ➌ 为真，执行将转到`jmp`指令去`print` ➐。这是(0,0)顶点，没有偏移量需要添加。如果内存值小于0.666666
    ➍，执行将转向向X添加0.25的偏移量，向Y添加0.5的偏移量 ➏。这是(0.5,1)顶点的情况。最后，如果内存值大于或等于0.666666，我们就到了(1,0)顶点，因此只需要向X添加0.5的偏移量
    ➎。打印出新的X和Y值 ➐后，Z寄存器会递减并测试是否为0 ➑。如果Z为0，`hlt`指令停止程序。如果不是，`loop`子程序将从头开始执行，感谢`jpr`指令。
- en: Let’s run the program and capture the output.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们运行程序并捕获输出结果。
- en: '[PRE24]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Here, *points.txt* becomes a collection of 60,000 (*x*, *y*) pairs.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，*points.txt*变成了60,000个(*x*, *y*)点对的集合。
- en: To see the fractal, we need to plot the points. A few lines of Python will do
    the trick.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 为了看到分形图形，我们需要绘制这些点。几行Python代码就能完成这一任务。
- en: '[PRE25]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: The result should look very much like [Figure 13-2](ch13.xhtml#ch013fig2). Note
    that [Figure 13-2](ch13.xhtml#ch013fig2) uses 600,000 points, 10 times as many
    as *sierpinski.filska* generates by default.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 结果应该与[图 13-2](ch13.xhtml#ch013fig2)非常相似。注意，[图 13-2](ch13.xhtml#ch013fig2)使用了600,000个点，是*sierpinski.filska*默认生成点数的10倍。
- en: '![Image](Images/13fig02.jpg)'
  id: totrans-189
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/13fig02.jpg)'
- en: '*Figure 13-2: The Sierpiński triangle with 600,000 points*'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 13-2：带有600,000个点的谢尔宾斯基三角形*'
- en: '**Getting to the Roots of the Problem**'
  id: totrans-191
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**深入问题的根本**'
- en: In algebra class, we all spent far too much time factoring quadratic equations
    of the form *ax*² + *bx* + *c* to find the roots, that is, the values of *x* such
    that *ax*² + *bx* + *c* = 0\. After much consternation and many practice problems,
    we were told of the formula to find the roots directly. This is the quadratic
    formula, which we used above to find the value of *ϕ*, the golden ratio.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 在代数课上，我们都花费了过多的时间去因式分解形式为*ax*² + *bx* + *c*的二次方程，以求得根值，也就是找到使得*ax*² + *bx* +
    *c* = 0的*x*值。经过许多困惑和练习题之后，我们终于得知了可以直接找到根值的公式。这就是二次公式，我们在上面用它来求得*ϕ*的值，也就是黄金比例。
- en: '![Image](Images/f0360-01.jpg)'
  id: totrans-193
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/f0360-01.jpg)'
- en: The value under the square root is known as the *discriminant*, Δ = *b*² – 4*ac*.
    The sign of the discriminant tells us something useful about the roots.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 平方根下的值被称为*判别式*，Δ = *b*² – 4*ac*。判别式的符号告诉我们关于根值的一些有用信息。
- en: '![Image](Images/f0360-02.jpg)'
  id: totrans-195
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/f0360-02.jpg)'
- en: For the first case, the discriminant is negative, and the square root of a negative
    number is imaginary. For the second case, the square root is 0, and the single
    root is *x* = *–b*/(2*a*). For the third case, the discriminant is positive, the
    square root exists, and there are two distinct real roots.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 对于第一种情况，判别式为负数，负数的平方根是虚数。对于第二种情况，平方根为0，唯一的根为*x* = *–b*/(2*a*)。对于第三种情况，判别式为正数，平方根存在，且有两个不同的实数根。
- en: The file *roots.filska* contains a complete program to calculate the roots of
    an arbitrary quadratic polynomial. Let’s run it a few times to see what it outputs.
    Then, we’ll examine the portions of the code related to the discriminant and the
    roots themselves. The remainder of the code handles text output. It is primarily
    a series of `set` and `chr` instructions, which are essential to the nice formatting
    of the program, but not helpful in learning how to implement the calculations
    in Filska.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 文件*roots.filska*包含了一个完整的程序，用于计算任意二次多项式的根。我们可以运行它几次，查看输出结果。接着，我们将研究与判别式和根相关的代码部分。其余的代码处理文本输出，主要是`set`和`chr`指令，这些指令对程序的格式化非常重要，但对于学习如何在Filska中实现计算并不帮助。
- en: '[Listing 13-11](ch13.xhtml#ch013list11) shows the output for three separate
    runs of *roots.filska*.'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: '[列表13-11](ch13.xhtml#ch013list11)显示了*roots.filska*三次独立运行的输出结果。'
- en: '[PRE26]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: '*Listing 13-11: Three runs of roots.filska*'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表13-11：三次运行的roots.filska*'
- en: The prompts ask the user to enter the coefficients of the quadratic, the *a*,
    *b*, and *c* values. In the first case, we are asking for the roots of *x*² +
    2*x* + 4 and are told they are complex because the discriminant is negative. In
    the second case, we want the roots of *x*² + 4*x* + 2, which are real. The last
    case is asking about *–* 4*x*² + 12*x –* 9, which leads to a zero discriminant
    and only one root.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 提示要求用户输入二次方程的系数，*a*、*b*和*c*值。在第一个例子中，我们要求求解*x*² + 2*x* + 4的根，并被告知它们是复数，因为判别式为负。在第二个例子中，我们要求求解*x*²
    + 4*x* + 2的根，结果是实数根。最后一个例子涉及的是*- 4*x*² + 12*x - 9*，它的判别式为零，因此只有一个根。
- en: 'The flow of this program is quite linear: the user enters the coefficients,
    the discriminant is calculated, and, based on the value of the discriminant, the
    proper roots are calculated. If you look at *roots.filska*, you’ll see that the
    key subprograms are `main`, `positive`, `equal`, and `negative`, along with three
    subprograms to get the coefficients: `getA`, `getB`, and `getC`.'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 这个程序的流程相当线性：用户输入系数，计算判别式，然后根据判别式的值计算相应的根。如果你查看*roots.filska*，你会看到关键的子程序有`main`、`positive`、`equal`和`negative`，以及三个用于获取系数的子程序：`getA`、`getB`和`getC`。
- en: '[Listing 13-12](ch13.xhtml#ch013list12) presents the `main` subprogram.'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: '[列表13-12](ch13.xhtml#ch013list12)展示了`main`子程序。'
- en: '[PRE27]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: '*Listing 13-12: The main subprogram*'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表13-12：主子程序*'
- en: From the comments, we see that `main` asks for *a*, *b*, and *c* and then calculates
    the discriminant (`D`) before using its value to jump to either `positive`, `equal`,
    or `negative`.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 从注释中我们可以看到，`main`请求输入*a*、*b*和*c*，然后计算判别式（`D`），接着根据判别式的值跳转到`positive`、`equal`或`negative`。
- en: Let’s begin with the last three instructions in `main`. At first glance, it
    seems odd to put them one after the other, but that’s merely an illusion caused
    by thinking in terms of functions. We need to consider them in relation to the
    `cmp` and `tst` instructions above.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从`main`中的最后三条指令开始。乍一看，把它们一个接一个地放在一起似乎有些奇怪，但这只是由于我们习惯于从函数的角度思考所产生的错觉。我们需要将它们与上面的`cmp`和`tst`指令进行关联考虑。
- en: The `cmp` instruction compares `main`’s memory, the discriminant, to 0 ➌. If
    the discriminant is greater than 0, we transfer control to the `positive` subprogram
    by branching three instructions forward using `tst,g,3`. Similarly, we transfer
    control to `equal` if the discriminant is 0 and `negative` if the discriminant
    is less than 0\. All three of these subprograms eventually execute `hlt` and none
    return control to `main`.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: '`cmp`指令将`main`的内存（判别式）与0进行比较➌。如果判别式大于0，我们通过使用`tst,g,3`指令向前跳转三条指令，转移控制到`positive`子程序。类似地，如果判别式为0，我们将控制转移到`equal`，如果判别式小于0，我们将控制转移到`negative`。这三个子程序最终都会执行`hlt`，且都不会将控制返回到`main`。'
- en: Filska is quite limited in the data it can track, an intentional design goal
    to make us think more about how to arrange our programs, so we need to consider
    which values must be stored and when. We should ask the user for the coefficients
    of the quadratic. We also need to keep them somewhere and get them back on demand.
    We have the three registers, but if we store the coefficients in them, we have
    only the single memory location of each subprogram to use for calculations. We
    need the registers to transfer data between subprograms and to participate in
    calculations.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: Filska 在其可以跟踪的数据上相当有限，这是一个故意的设计目标，旨在促使我们更多地思考如何安排程序，因此我们需要考虑哪些值必须存储以及何时存储。我们应该询问用户二次方程的系数。我们还需要将这些系数保存在某个地方，并根据需要提取它们。我们有三个寄存器，但如果将系数存储在其中，就只能使用每个子程序的单一内存位置进行计算。我们需要寄存器在子程序之间传输数据，并参与计算。
- en: 'The solution is to create a subprogram that acts as a small object. The subprogram
    can store a value passed to it and then return the value on demand. Think of the
    subprogram as an instance of a simple class that we might express in Python as
    follows:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 解决方案是创建一个作为小对象的子程序。子程序可以存储传递给它的值，然后根据需要返回该值。可以把这个子程序看作是一个简单类的实例，我们可能会像这样在 Python
    中表达它：
- en: '[PRE28]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Instances of this class are given a value to store when they are created, and
    later return that value when asked using the `Get` method. This is what we need:
    to assign a value once and then retrieve it multiple times later on.'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 这个类的实例在创建时会被赋予一个存储的值，并且在通过 `Get` 方法请求时返回该值。这正是我们需要的：一次赋值，然后以后多次取回。
- en: In Filska, we get the same effect with a subprogram using its memory to store
    the value. Consider `getA`.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Filska 中，我们通过一个子程序，利用其内存存储值，从而获得相同的效果。考虑 `getA`。
- en: '[PRE29]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'The first three lines of `getA` print `A?` and then ask for a number from the
    user with `ipt`. Whatever number the user enters is stored in local memory. Then,
    control is transferred back to `main` via `jmp`. The next transfer from `main`
    back to `getA` begins with the `tmx` instruction to put the user’s value in the
    X register and then transfer back to `main`. However, any future transfer back
    to `getA` will begin with the `gto` instruction jumping back 2 to start again
    at `tmx`. This loop repeats indefinitely: `getA` will now only load X with the
    user’s value. We have a “write once, read many” place to hold a number—precisely
    what we need.'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: '`getA` 的前三行输出 `A?`，然后通过 `ipt` 请求用户输入一个数字。用户输入的任何数字都会被存储在本地内存中。随后，控制通过 `jmp`
    转移回 `main`。接下来从 `main` 转移回 `getA`，首先通过 `tmx` 指令将用户的值存入 X 寄存器，然后再转移回 `main`。然而，任何未来的转移回
    `getA` 都将以 `gto` 指令开始，跳回 2 重新从 `tmx` 开始。这个循环会无限重复：`getA` 现在只会将用户的值加载到 X 中。我们有一个“写一次，读多次”的位置来存储一个数字——正是我们所需要的。'
- en: Looking again at [Listing 13-12](ch13.xhtml#ch013list12), we see the first three
    transfers to get the coefficients ➊. This is followed later, during the calculation
    of the discriminant, by transfers to `getA`, `getB`, and `getC` when those values
    are needed.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 再次查看[Listing 13-12](ch13.xhtml#ch013list12)，我们可以看到前面三次转移操作是为了获取系数 ➊。随后，在计算判别式时，当需要这些值时，会进行转移到
    `getA`、`getB` 和 `getC`。
- en: Calculation of the discriminant is an exercise in juggling data values so that
    we do not run out of places to put them (see [Listing 13-12](ch13.xhtml#ch013list12)
    ➋). Let’s walk through the code. We need to calculate *b*² *–* 4*ac* and begin
    by calculating *–* 4*ac*.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 判别式的计算是一个处理数据值的练习，以避免我们用完存放它们的位置（参见 [Listing 13-12](ch13.xhtml#ch013list12)
    ➋）。让我们来走一遍代码。我们需要计算 *b*² *–* 4*ac*，并从计算 *–* 4*ac* 开始。
- en: '[PRE30]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: We store *–* 4*ac* temporarily in Z. Now we need to find *b*² and add *–* 4*ac*
    to it.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将 *–* 4*ac* 暂时存储在 Z 中。现在我们需要计算 *b*² 并将 *–* 4*ac* 加到其中。
- en: '[PRE31]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: We now have the discriminant in Y. To calculate the roots, let’s rewrite the
    quadratic equation using the discriminant, Δ.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经将判别式存储在 Y 中。为了计算根，我们可以使用判别式 Δ 来重写二次方程。
- en: '![Image](Images/f0363-01.jpg)'
  id: totrans-222
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Images/f0363-01.jpg)'
- en: 'Writing the equation in this form buys us something: we need only *a*, *b*,
    and Δ to calculate the roots. Good! We have three registers available, so let’s
    use Z for *a*, X for *b*, and Y for Δ.'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 将方程写成这种形式能带来好处：我们只需要 *a*、*b* 和 Δ 就能计算根。很好！我们有三个寄存器可用，所以我们将 Z 用于 *a*，X 用于 *b*，Y
    用于 Δ。
- en: '[PRE32]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Here, the last instruction moves the discriminant to `main`’s memory for the
    `cmp` instruction of [Listing 13-12](ch13.xhtml#ch013list12) ➌.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，最后一条指令将判别式移动到 `main` 的内存中，以供[Listing 13-12](ch13.xhtml#ch013list12) ➌的 `cmp`
    指令使用。
- en: The remaining subprograms, `positive`, `equal`, and `negative`, and the subprograms
    used by them, calculate and output the specific roots. As mentioned, many of the
    instructions relate to formatting the output. You can review those instructions
    on your own, but let’s conclude by stepping through `positive` to see how the
    calculation is done for two real roots.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 剩下的子程序 `positive`、`equal` 和 `negative` 以及它们使用的子程序，计算并输出具体的根。如前所述，许多指令与格式化输出有关。你可以自行查看这些指令，但让我们通过逐步解析
    `positive` 来看看如何计算两个实数根。
- en: '[PRE33]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Rewriting the quadratic equation one last time, we see that the two roots for
    a positive discriminant are
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一次重写二次方程时，我们看到，对于一个正的判别式，两个根是：
- en: '![Image](Images/f0364-01.jpg)'
  id: totrans-229
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Images/f0364-01.jpg)'
- en: implying we need both *– b*/(2*a*) and ![Image](Images/f0394-01.jpg) so we can
    add and subtract them. The first term is built piece by piece, as indicated in
    the comments ➊. It’s left in `positive`’s memory. Then, transfer to `rest` builds
    ![Image](Images/f0394-01.jpg) in X. Notice that doing this destroys *b*, which
    was previously in X. That’s okay; we no longer need it. When `rest` transfers
    execution back to `positive`, X has the other term we need, so we first add the
    terms and call `?double` (read “print double”) to output what is in Y, subtract
    the terms, and call `?double` to get the other root. Notice also that using Y
    destroys the discriminant, but we no longer need it, either.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着我们需要同时计算 *– b*/(2*a*) 和 ![Image](Images/f0394-01.jpg)，这样我们就可以对它们进行加减。第一项是一步步构建的，正如注释➊所示。它保留在
    `positive` 的内存中。然后，转移到 `rest` 构建了 X 中的 ![Image](Images/f0394-01.jpg)。注意，做这一步时会销毁
    *b*，它之前存储在 X 中。这没关系；我们不再需要它。当 `rest` 将执行转移回 `positive` 时，X 中有了我们需要的另一个项，因此我们首先将项相加，并调用
    `?double`（读作“打印双精度”）来输出 Y 中的内容，再将项相减，调用 `?double` 来得到另一个根。还要注意，使用 Y 会销毁判别式，但我们也不再需要它。
- en: Whew! That was a lot of steps for something that a more powerful language could
    implement quickly. Still, the challenge, and fun, is in getting a constrained
    language to do something useful.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 呼！这些步骤对于一个更强大的语言来说可以很快实现。不过，挑战和乐趣就在于让一个受限的语言做一些有用的事情。
- en: '**Linear Least-Squares Fit to a Line**'
  id: totrans-232
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**线性最小二乘法拟合直线**'
- en: 'Previously, we fit a polynomial to a set of points to arrive at a silly way
    of printing `HELLO, WORLD!`. In this section, we’ll again use least-squares fitting,
    but this time to a line, which is far simpler. Specifically, we have a collection
    of (*x*, *y*) points, and we want to find the equation of a line that best fits
    them:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 之前，我们通过拟合一个多项式到一组数据点来得出一个傻乎乎的打印`HELLO, WORLD!`的方式。在这一节中，我们将再次使用最小二乘法拟合，但这次拟合的是一条直线，显然要简单得多。具体来说，我们有一组(*x*,
    *y*)点，我们想要找到一条最适合这些点的直线方程：
- en: '*y* = *b**x* + *a*'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: '*y* = *b**x* + *a*'
- en: for some *a* and *b* we need to calculate from the data.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 对于某些 *a* 和 *b*，我们需要从数据中计算出来。
- en: Unlike least-squares fitting to a polynomial or other function, fitting a line
    to a dataset has a closed-form solution; this means we can write the equations
    that give us *a* and *b* (see Equation 13.2)
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 与拟合多项式或其他函数的最小二乘法不同，拟合一条直线到数据集有一个封闭解；这意味着我们可以写出给我们 *a* 和 *b* 的方程（见方程 13.2）。
- en: '![Image](Images/13eqa02.jpg)'
  id: totrans-237
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Images/13eqa02.jpg)'
- en: for *N*, the number of points in the dataset.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 *N*，即数据集中的点数。
- en: Equation 13.2 appears a bit daunting at first. Don’t let it throw you. It says
    we must accumulate sums of all the *x* values and all *y* values along with the
    sums of *x*² and *x* times *y*. Once we have these sums, calculating *b* (the
    slope) and *a* (the intercept) is straightforward because the ∑ terms become simple
    numbers.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 方程 13.2 一开始看起来可能有点让人望而生畏。不要被它吓到。它表示我们必须对所有的 *x* 值和所有 *y* 值进行求和，还包括 *x*² 和 *x*
    乘 *y* 的和。一旦我们有了这些求和结果，计算 *b*（斜率）和 *a*（截距）就很简单，因为 ∑ 项会变成简单的数字。
- en: The code for this example is in *linfit.filska*. From a programming perspective,
    we’ll see a new kind of Filska subprogram, one that expands on the “write once,
    read many” idea we used in the previous section. However, before we write code,
    we must decide how we’ll get Filska to read the datafile. Normally, we’d store
    the data points as (*x*, *y*) pairs, one pair per line. However, if we use redirection
    to send the data to the Filska program, the `ipt` instruction will read only one
    value per line of the input file. Also, we need to tell Filska to stop reading
    the file so we can complete our calculations.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 这个示例的代码在*linfit.filska*中。从编程角度看，我们将看到一种新的Filska子程序，它扩展了我们在上一节中使用的“写一次，读多次”的思想。但是，在编写代码之前，我们必须决定如何让Filska读取数据文件。通常，我们会将数据点存储为(*x*,
    *y*)对，每行一个对。然而，如果我们使用重定向将数据发送到Filska程序，`ipt`指令每行只会读取一个值。此外，我们还需要告诉Filska停止读取文件，以便完成计算。
- en: The solution is to put the data in the file with one value per line, first the
    *x* value and then the associated *y* value on the next line. To tell Filska we
    are done, we’ll end the file with a flag value, one that won’t show up in our
    dataset. We’ll use *–*999999, an unlikely data value.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 解决方案是将数据以每行一个值的形式存储在文件中，首先是*x*值，然后是下行的对应*y*值。为了告诉Filska我们已经完成，我们将以一个标志值结束文件，这个值不会出现在我们的数据集中。我们将使用*–*999999，一个不太可能出现的数据值。
- en: For example, if our dataset is
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果我们的数据集是
- en: (0, 0*.*5), (1, 1*.*1), (2, 2*.*4), (3, 3*.*6)
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: (0, 0*.*5)，(1, 1*.*1)，(2, 2*.*4)，(3, 3*.*6)
- en: we’ll format it for input as
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将格式化为如下输入：
- en: '[PRE34]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: so each *x* is followed by its *y*, and the last value, `-999999`, tells us
    there’s no more data to read.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 所以每个*x*后面跟着它的*y*，最后一个值`-999999`告诉我们没有更多数据可读。
- en: 'As far as Equation 13.2 is concerned, we get the following sums for our example
    dataset:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 就方程式13.2而言，我们得到以下关于示例数据集的总和：
- en: '![Image](Images/f0366-01.jpg)'
  id: totrans-248
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Images/f0366-01.jpg)'
- en: Meaning the best fit line is
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着最佳拟合线是
- en: '![Image](Images/f0366-02.jpg)'
  id: totrans-250
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Images/f0366-02.jpg)'
- en: or *y* = *bx* + *a* = 1*.*06*x* + 0*.*31.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 或者*y* = *bx* + *a* = 1*.*06*x* + 0*.*31。
- en: Let’s see the code in action; then we’ll dive into it. I’ve included a sample
    dataset, *linfit_dataset.txt*. If you run *linfit.filska* using *linfit_dataset.txt*
    as the input you get
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先看看代码的运行效果，然后再深入分析。我已经包含了一个示例数据集，*linfit_dataset.txt*。如果你使用*linfit_dataset.txt*作为输入运行*linfit.filska*，你会得到
- en: '[PRE35]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: which tells us that the best-fit line is *y* = *Bx* + *A* (see [Figure 13-3](ch13.xhtml#ch013fig3)).
    The fit looks pretty good, so we have confidence that the code is working.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 这告诉我们最佳拟合线是*y* = *Bx* + *A*（见[图13-3](ch13.xhtml#ch013fig3)）。拟合效果相当不错，因此我们可以放心代码正在正常工作。
- en: '![Image](Images/13fig03.jpg)'
  id: totrans-255
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Images/13fig03.jpg)'
- en: '*Figure 13-3: Best-fit line to the sample dataset*'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: '*图13-3：最佳拟合线与示例数据集*'
- en: 'If we were using a high-level language to code this example, we’d likely store
    the dataset in some kind of array or list. Then we’d run through the list to generate
    the necessary sums. However, Filska has no arrays. So how can we do it? The solution
    comes from observing that all we need is a single pass through the dataset and
    some way of accumulating each point as we read it. There is no need to store all
    the data first and then process it, because we can process each point as it is
    read. In algorithm form, we need to code the following:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们使用一种高级语言来编写这个示例代码，我们可能会将数据集存储在某种数组或列表中。然后我们会遍历列表来生成必要的总和。然而，Filska没有数组。那么我们该如何做呢？解决方案来自于观察到我们只需要对数据集进行一次遍历，并在读取每个点时累积它。我们不需要先存储所有数据，然后再处理，因为我们可以在读取每个点时就进行处理。用算法形式表示，我们需要编写如下代码：
- en: Read a point from the input file, (*x*, *y*).
  id: totrans-258
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从输入文件中读取一个点，(*x*, *y*)。
- en: Add the *x* value to the running total of *x* values.
  id: totrans-259
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将*x*值加到*x*值的累计总和中。
- en: Add *x*² to the running total of *x*² values.
  id: totrans-260
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将*x*²加到*x*²值的累计总和中。
- en: Add *y* to the running total of *y* values.
  id: totrans-261
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将*y*加到*y*值的累计总和中。
- en: Add *xy* to the running total of *xy* values.
  id: totrans-262
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将*xy*加到*xy*值的累计总和中。
- en: Repeat from Step 1 until all points have been read.
  id: totrans-263
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从步骤1开始重复，直到所有点都被读取完。
- en: Calculate *a* and *b* using the running totals.
  id: totrans-264
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用累计总和计算*a*和*b*。
- en: We need to track the sums of *x*, *y*, *x*², and *xy*, along with the total
    number of points read, *N*. That’s too many values to depend solely upon memory
    and the registers. Thus, we need something much like the subprograms of the previous
    section, which can be initialized, sum, and finally report their totals. Using
    the analogy of a class, as we did previously, we need something like the following.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要跟踪 *x*、*y*、*x*² 和 *xy* 的总和，以及读取的总点数 *N*。这些值太多，不能仅依靠内存和寄存器来存储。因此，我们需要一些类似上一节中的子程序，可以初始化、累积并最终报告它们的总和。使用我们之前提到的类的类比，我们需要类似以下的结构。
- en: '[PRE36]'
  id: totrans-266
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: This class sets its internal state to 0 when instantiated, and then adds values
    passed to `Add` and reports its current sum when `Get` is called.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 这个类在实例化时将其内部状态设置为 0，然后将传递给 `Add` 的值相加，并在调用 `Get` 时报告当前的总和。
- en: We can build this structure in Filska using subprogram memory to store the sum
    and registers to provide values or return values. We’ll keep the current point’s
    *x* value in the X register and the *y* value in the Y register. We’ll use the
    Z register to tell the subprogram whether to accumulate (Z = 0) or return the
    sum (Z ≠ 0) in Y.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在 Filska 中构建这个结构，使用子程序内存存储总和，使用寄存器提供值或返回值。我们将把当前点的 *x* 值保存在 X 寄存器中，将 *y*
    值保存在 Y 寄存器中。我们将使用 Z 寄存器告诉子程序是否需要累积（Z = 0）或者将总和返回（Z ≠ 0）到 Y。
- en: Now take a look at [Listing 13-13](ch13.xhtml#ch013list13), which shows the
    `sumxy` subprogram from *linfit.filska*.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 现在来看一下 [Listing 13-13](ch13.xhtml#ch013list13)，它展示了来自 *linfit.filska* 的 `sumxy`
    子程序。
- en: '[PRE37]'
  id: totrans-270
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: '*Listing 13-13: The sumxy subprogram*'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: '*Listing 13-13: sumxy 子程序*'
- en: When `sumxy` is called the first time, it sets its local memory to 0 and returns
    to `main` ➊. Subsequent calls begin with ➋ and branch depending upon Z. At this
    point, X and Y contain the respective *x* and *y* values of the current point.
    If Z is not 0, the `tst` instruction branches forward to ➍ to move local memory,
    the sum of the products of *x* and *y*, to Y.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 当第一次调用 `sumxy` 时，它将其本地内存设置为 0，并返回到 `main` ➊。后续调用从 ➋ 开始，并根据 Z 的值进行分支。此时，X 和 Y
    分别包含当前点的 *x* 和 *y* 值。如果 Z 不为 0，`tst` 指令会跳转到 ➍，将本地内存中 *x* 和 *y* 的乘积总和移动到 Y。
- en: Note two things about the code so far. First, at ➋, to test that Z is not 0,
    we have to swap memory and Z, so Z’s value is in memory, but the memory value
    is stashed in Z. After all, losing the sum in memory would make the entire subprogram
    useless. Therefore, at ➍ the swap must happen again to restore the actual sum
    of the *xy* pairs and ensure that Z is also unchanged. Second, when Z ≠ 0, the
    subprogram is in a permanent state of simply reporting its sum in Y. That means
    it no longer pays attention to Z’s state. This works for our program and frees
    Z for other uses, if necessary. The `gto` jumping back to `tmy` makes this happen.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 目前代码有两个注意事项。首先，在 ➋ 处，为了测试 Z 是否为 0，我们必须交换内存和 Z，因此 Z 的值存放在内存中，而内存的值被暂存到 Z 中。毕竟，如果丢失了内存中的总和，整个子程序将变得无用。因此，在
    ➍ 处必须再次交换，以恢复 *xy* 配对的实际总和，并确保 Z 的值保持不变。其次，当 Z ≠ 0 时，子程序处于一个永久状态，只是报告 Y 中的总和。这意味着它不再关注
    Z 的状态。这样做对我们的程序有效，并且如果需要，还能释放 Z 供其他用途。`gto` 跳转回 `tmy` 使这一切发生。
- en: If Z is 0, the `tst` fails, and execution continues ➌. First, Z and memory are
    swapped, as at ➍ to restore the sum. Then Z is used to hold the product of *x*
    and *y* and added to memory, thereby accumulating the product for the current
    point. Of course, using Z in this way changes its value, so before transferring
    back to `main`, we must reset Z to 0\. The `jmp` to `main` is followed by a `gto`
    to branch back the beginning of the test on Z for the next transfer to `sumxy`
    from `main`.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 Z 为 0，`tst` 会失败，执行将继续到 ➌。首先，Z 和内存会交换，就像在 ➍ 处恢复总和一样。然后，Z 被用来保存 *x* 和 *y* 的乘积，并加到内存中，从而累积当前点的乘积。当然，以这种方式使用
    Z 会改变它的值，因此在返回 `main` 之前，我们必须将 Z 重置为 0。`jmp` 跳转到 `main` 后，接着是一个 `gto`，用于跳转回测试
    Z 的开始位置，以便从 `main` 转移到 `sumxy`。
- en: The pattern set up in `sumxy` is repeated for `sumx`, `sumy`, `sumx2`, and `sum`,
    where the second to last accumulates *x*² and the last counts the number of points
    processed. By controlling the state of Z, `main` moves from accumulating to calculating.
    The trigger to change state is reading the flag value of `-999999` for *x*.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `sumxy` 中设定的模式会重复用于 `sumx`、`sumy`、`sumx2` 和 `sum`，其中倒数第二个用于累积 *x*²，最后一个用于统计处理的点数。通过控制
    Z 的状态，`main` 从累积状态切换到计算状态。改变状态的触发条件是读取 *x* 的标志值 `-999999`。
- en: The `main` subprogram of *linfit.filska* is rather long, so we’ll only examine
    pieces of it. [Listing 13-14](ch13.xhtml#ch013list14) covers the first part, which
    initializes the sums and processes the data points.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: '*linfit.filska*中的`main`子程序相当长，因此我们只会分析其中的一部分。[清单13-14](ch13.xhtml#ch013list14)展示了第一部分，它初始化总和并处理数据点。'
- en: '[PRE38]'
  id: totrans-277
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: '*Listing 13-14: Accumulating sums in main*'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单13-14：在main中累加总和*'
- en: The first block of code calls each of the accumulator subprograms to initialize
    them ➊. Next, the main loop starts by setting Z = 0 to put each subprogram in
    accumulator mode. The first `ipt` instruction reads an *x* value, checks to see
    if it is `-999999`, and if so, branches forward to exit the loop. The code then
    places *x* in the X register. The second `ipt` reads the *y* value and puts it
    in Y.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 第一块代码调用每个累加器子程序以初始化它们 ➊。接下来，主循环开始时将Z设置为0，使每个子程序进入累加模式。第一个`ipt`指令读取*x*值，检查是否为`-999999`，如果是，程序跳转到前方以退出循环。然后代码将*x*放入X寄存器中。第二个`ipt`指令读取*y*值并将其放入Y寄存器中。
- en: The second block of `jmp` instructions accumulates each of the totals ➋. Lastly,
    the `gto` branches back to the beginning of the main loop, the first `ipt` instruction.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 第二块`jmp`指令累加每个总和 ➋。最后，`gto`指令将程序跳转回主循环的开头，即第一个`ipt`指令。
- en: When the flag value of `-999999` is read, the input file has been processed,
    and execution moves to calculation mode, so it’s time for Equation 13.2\. If we
    look at Equation 13.2, we see that both *a* and *b* depend on Δ. Therefore, we
    split the calculation into finding the numerators for *a* and *b* and then dividing
    by Δ.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 当读取到标志值`-999999`时，输入文件已经处理完毕，程序进入计算模式，开始执行公式13.2。若查看公式13.2，我们会发现*a*和*b*都依赖于Δ。因此，我们将计算分为首先求出*a*和*b*的分子，然后再除以Δ。
- en: '[Listing 13-15](ch13.xhtml#ch013list15) calculates the numerator for *a*.'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: '[清单13-15](ch13.xhtml#ch013list15)计算了*a*的分子。'
- en: '[PRE39]'
  id: totrans-283
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: '*Listing 13-15: Calculations in main*'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单13-15：main中的计算*'
- en: First, Z is set to 1 to cause the subprograms to return their sums in Y, and
    then the sequence of steps calculates what we need for *a*’s numerator in Equation
    13.2\. The `numA` subprogram, not shown, stores what’s in Z on the first call,
    returning it in Y on all future calls. A similar sequence of steps calculates
    the numerator for *b*, stored in `numB`, and Δ itself in `delta`. The final instructions
    of `main` calculate `numA` divided by `delta` and print it as *a*. Then the same
    is done for *b* using `numB`. The program ends with `hlt`.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，将Z设置为1，使得子程序将它们的和返回到Y中，然后一系列步骤计算我们在公式13.2中所需的*a*的分子。`numA`子程序（未展示）在第一次调用时存储Z中的值，并在以后的所有调用中将其返回到Y。类似的步骤计算*b*的分子，存储在`numB`中，Δ本身则存储在`delta`中。`main`的最终指令计算`numA`除以`delta`并将结果打印为*a*，然后使用`numB`对*b*执行相同操作。程序最后通过`hlt`结束。
- en: '**Discussion**'
  id: totrans-286
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**讨论**'
- en: It’s clear Filska is a limited language, though useful for specific tasks. Many
    programming languages develop idioms, which are snippets of code that show up
    frequently. We developed a Filska idiom above by using a subprogram as a memory
    location with additional functionality, something we showed was similar to a simple
    class in other languages. We used this idiom as a “write once, read many” memory,
    with or without additional processing, or, via a flag in a register, as a read/write
    memory, as we did for the linear least-squares fit example.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 很明显，Filska是一种功能有限的语言，但对于特定任务非常有用。许多编程语言都发展出了一些惯用法，它们是经常出现的代码片段。我们通过使用子程序作为具有附加功能的存储位置，开发了一个Filska的惯用法，这类似于其他语言中的简单类。我们将这种惯用法用作“一次写入，多次读取”的内存，不管是否有额外的处理，或者通过寄存器中的标志作为读/写内存，正如我们在线性最小二乘拟合示例中所做的那样。
- en: Filska does not support arrays, but it is possible to emulate them using subprograms
    as the array elements. We won’t list the code here, but do take a look at *array.filska*,
    an example that creates an array of 10 values. The demo stores values in the array
    by index and then dumps the array in order.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: Filska不支持数组，但可以通过使用子程序作为数组元素来模拟数组。我们不会在这里列出代码，但可以查看*array.filska*，这是一个创建10个值的数组示例。该演示通过索引存储数组中的值，然后按顺序输出数组。
- en: In the end, what should we make of Filska? We’ve seen it implement certain algorithms,
    even ones leading to useful outcomes. Is Filska Turing complete? Although it’s
    true that most imperative programming languages are very likely Turing complete,
    Filska is perhaps not because of its severe memory constraints. Three general-purpose
    registers and one memory location per subprogram might be the limiting factor.
    However, there is no limit to the number of subprograms we can define, and the
    array demo shows how to use that feature to emulate an array that is, in theory,
    as large as we would care to make it. Therefore, we might argue we do have an
    arbitrary amount of data available. In the end, deciding whether Filska is Turing
    complete is beyond what we can reasonably address in this book. Perhaps a theoretical
    computer scientist will take up the challenge and share their results with us.
    If so, check the GitHub site for the book.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 最终，我们应该如何看待 Filska 呢？我们已经看到它实现了一些算法，甚至包括那些能够产生有用结果的算法。Filska 是图灵完备的吗？虽然大多数命令式编程语言很可能是图灵完备的，但
    Filska 可能不是，因为它有着严格的内存限制。每个子程序只有三个通用寄存器和一个内存位置，这可能是其限制因素。然而，我们可以定义的子程序数量没有限制，而数组示例展示了如何利用这一特性来模拟一个理论上可以非常大的数组。因此，我们可以认为我们确实拥有了任意数量的数据。最终，判断
    Filska 是否图灵完备，超出了我们在本书中能够合理讨论的范围。也许某位理论计算机科学家会接受这个挑战，并与我们分享他们的结果。如果是这样，请查看本书的
    GitHub 网站。
- en: '**Summary**'
  id: totrans-290
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**摘要**'
- en: This chapter used Filska to implement a set of (hopefully) fun math-related
    examples. We got geeky and used curve fitting to produce `HELLO, WORLD!`. We explored
    the Fibonacci sequence, pseudorandom number generation, fractals, roots of equations,
    and fitting a data to a line. In each case, we needed to think carefully about
    the structure of our data and code to make the best use possible of Filska’s severe
    programming constraints.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 本章使用 Filska 实现了一些（希望是）有趣的数学相关例子。我们变得有些极客，使用曲线拟合生成了 `HELLO, WORLD!`。我们探索了斐波那契数列、伪随机数生成、分形、方程的根以及数据拟合直线。在每个案例中，我们都需要仔细思考数据和代码的结构，以便尽可能充分利用
    Filska 严苛的编程限制。
- en: Filska was designed to calculate, and all of our examples involved math in some
    way. Let’s relax a bit now and consider our second esolang, one designed purely
    for fun, and one that’s considerably simpler in every way. Let’s leave math behind,
    step outside, and watch the fireflies.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: Filska 被设计用于计算，我们所有的例子都或多或少涉及到数学。现在让我们稍微放松一下，考虑一下我们的第二种 esolang，它完全是为了娱乐而设计的，并且在各方面都要简单得多。让我们抛开数学，走到户外，观察萤火虫吧。
