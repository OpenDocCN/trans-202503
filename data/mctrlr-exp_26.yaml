- en: '**A  More Bootloader Vulns**'
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '**A 更多启动加载程序漏洞**'
- en: '**A.1 PN553 Signature Bypass**'
  id: totrans-1
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**A.1 PN553 签名绕过**'
- en: Wade (2021a) and Wade (2021b) document a memory corruption vulnerability in
    the bootloader of the PN553, PN547, PN548, PN551, and PN5180 series of NFC chips
    found in consumer smart-phones such as the Pixel 3 and Xiaomi MI Note 3\. These
    implement NFC communications so that the operating system can call high-level
    abstractions. Raw control of the chip would be useful to perform raw NFC transactions,
    and that is the value of exploits for this vulnerability.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: Wade (2021a) 和 Wade (2021b) 记录了 PN553、PN547、PN548、PN551 和 PN5180 系列 NFC 芯片在启动加载程序中的内存损坏漏洞，这些芯片出现在
    Pixel 3 和 Xiaomi MI Note 3 等消费类智能手机中。这些芯片实现了 NFC 通信，操作系统可以调用高级抽象。对芯片的原始控制将有助于执行原始的
    NFC 交易，这就是此漏洞利用的价值所在。
- en: Within a phone, Wade found that Linux presents the device as `/dev/nq-nci`.
    This character device allows both standard NCI commands and custom commands unique
    to the series. Boot-loader commands were as follows, which he extracted from an
    ELF library.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在手机中，Wade 发现 Linux 将设备呈现为 `/dev/nq-nci`。这个字符设备允许标准 NCI 命令和系列特有的自定义命令。启动加载程序命令如下，他从
    ELF 库中提取了这些命令。
- en: '| `c0` | Write Memory |'
  id: totrans-4
  prefs: []
  type: TYPE_TB
  zh: '| `c0` | 写入内存 |'
- en: '| `a2` | Read Memory |'
  id: totrans-5
  prefs: []
  type: TYPE_TB
  zh: '| `a2` | 读取内存 |'
- en: '| `a7` | Write 64 bytes to Configuration |'
  id: totrans-6
  prefs: []
  type: TYPE_TB
  zh: '| `a7` | 写入 64 字节到配置 |'
- en: '| `e0` | Checksum and Configuration |'
  id: totrans-7
  prefs: []
  type: TYPE_TB
  zh: '| `e0` | 校验和和配置 |'
- en: The `c0` commands perform firmware writes, but with an odd signing structure.
    The very first of these contains a version number, a SHA256 hash, and a signature
    of that hash. The hash itself is the hash of the *next* block, which in turn will
    include a hash of the block after itself. In this way, the update can proceed
    linearly from the beginning, verifying and writing blocks one at a time without
    ever having to hold the entire image in RAM.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: '`c0` 命令执行固件写入，但具有一种奇怪的签名结构。这些命令中的第一个包含一个版本号、一个 SHA256 哈希值和该哈希值的签名。哈希值本身是 *下一个*
    区块的哈希，而下一个区块将包含下一个区块的哈希。通过这种方式，更新可以从头到尾线性进行，逐个验证和写入区块，而无需将整个镜像保存在内存中。'
- en: '![Image](../images/f0250-01.jpg)'
  id: totrans-9
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/f0250-01.jpg)'
- en: 'Figure A.1: NXP PN553 NFC Controller'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: '图 A.1: NXP PN553 NFC 控制器'
- en: The final block is a bit different, having no hash, as there’s no subsequent
    block to continue the chain. Noticing that the final block could be sent multiple
    times without an error, Wade theorized that the upcoming hash is not replaced
    by this command. If it were possible to overwrite the expected value with an arbitrary
    hash, then anything might be used for the next block, regardless of the signature
    and hash chain.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 最后的区块稍有不同，没有哈希值，因为没有后续的区块来继续链条。Wade 注意到最后一个区块可以多次发送而不会报错，他推测这个命令并不会替换掉即将到来的哈希值。如果有可能用任意哈希值覆盖预期的值，那么下一个区块可能会用任何东西，而不管签名和哈希链如何。
- en: Now, the `c0` commands that write most blocks are just a little bit longer than
    the `c0` command that writes the very last block. Wade found that sending an illegally
    long `e0` command would replace the expected hash *before* returning an error.
    This corruption of the expected hash would break the chain, allowing further blocks
    to be written as if they were signed.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，写入大多数区块的 `c0` 命令比写入最后一个区块的 `c0` 命令稍长。Wade 发现发送一个非法长的 `e0` 命令会在返回错误之前替换掉预期的哈希值。这个哈希值的损坏会打破链条，允许后续的区块像已经签名一样被写入。
- en: Having this authority to patch the firmware, he then implemented a read command
    without range restrictions and happily dumped all memory for reverse engineering.
    He also notes that the SN100 chip, while similar to other series, encrypts its
    firmware updates, making exploitation far more difficult.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 拥有修补固件的权限后，他实现了一个没有范围限制的读取命令，并愉快地将所有内存转储以进行逆向工程。他还提到，SN100 芯片虽然与其他系列相似，但对其固件更新进行了加密，这使得利用该漏洞变得更加困难。
- en: '**A.2 Tegra X1, Fusée Gelée**'
  id: totrans-14
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**A.2 Tegra X1，Fusée Gelée**'
- en: The Nintendo Switch uses a Tegra X1 processor from Nvidia that strictly limits
    the device to booting content licensed by Nintendo. Temkin (2018) presents an
    exploit for the USB stack of the underlying X1 chip. Reported to Nvidia as CVE-2018-6242,
    the bug is better known as Fusée Gelée.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 任天堂 Switch 使用 Nvidia 的 Tegra X1 处理器，该处理器严格限制设备仅能启动任天堂授权的内容。Temkin (2018) 提出了针对
    X1 芯片 USB 堆栈的漏洞利用。该漏洞被报告给 Nvidia 并标记为 CVE-2018-6242，更广为人知的是 Fusée Gelée。
- en: The vulnerability is in a USB Recovery Mode (RCM) boot ROM that the device will
    enter when certain pins are strapped to ground and the external boot memory is
    unavailable. On a Switch, that’s performed by removing the eMMC board from its
    socket, holding the volume-down button and shorting pin 10 of the right joystick
    connector to ground. The Switch then appears as a USB device, awaiting a signed
    payload of executable code.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 漏洞存在于设备进入 USB 恢复模式（RCM）时的引导 ROM 中，当某些引脚接地且外部引导存储器不可用时，设备会进入该模式。在 Switch 上，这是通过从插座中取出
    eMMC 板，按住音量下按钮并将右侧摇杆连接器的第 10 引脚接地来执行的。然后，Switch 会作为一个 USB 设备出现，等待一个签名的可执行代码有效负载。
- en: '![Image](../images/f0252-01.jpg)'
  id: totrans-17
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/f0252-01.jpg)'
- en: 'Figure A.2: Fusée Gelée `memcpy`'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 图 A.2：Fusée Gelée `memcpy`
- en: 'Temkin describes the bug as an unchecked length when reading from the device.
    USB control requests include a 16-bit length field for the maximum amount of data
    that the device might transfer to the host in a reply. For example, the host might
    ask the device for its status, and the device could reply with just a couple of
    bytes instead of the maximum allowed by the host. She identified three exceptions
    to this rule, in which the X1’s USB stack would send as much data as the host
    allows:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: Temkin 描述了这个 bug，指出当从设备读取时没有检查长度。USB 控制请求包括一个 16 位长度字段，用于指示设备在回复中可能传输给主机的最大数据量。例如，主机可能会请求设备的状态，而设备可能只回复几个字节，而不是主机允许的最大字节数。她发现了三个例外情况，在这些情况下，X1
    的 USB 堆栈会传送主机允许的最大数据量：
- en: '`GET_CONFIGURATION` request with a `DEVICE` recipient.'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`GET_CONFIGURATION` 请求与 `DEVICE` 接收者。'
- en: '`GET_INTERFACE` request with an `INTERFACE` recipient.'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`GET_INTERFACE` 请求与 `INTERFACE` 接收者。'
- en: '`GET_STATUS` request with an `ENDPOINT` recipient.'
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`GET_STATUS` 请求与 `ENDPOINT` 接收者。'
- en: Reads past the end of a buffer are great for dumping memory, but buffering makes
    this far more serious. When the host asks for 65,535 bytes of status, those excess
    bytes are copied from the status variable’s address to one of the DMA buffers
    for USB transfer. Because the DMA buffers are small and located just beneath the
    call stack, this overflow in the copy can overwrite the *entire* call stack!
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 读取超出缓冲区末尾的数据对于内存转储很有用，但缓冲区使得这个问题更加严重。当主机请求 65,535 字节的状态时，超出的字节会从状态变量的地址复制到其中一个
    DMA 缓冲区以进行 USB 传输。由于 DMA 缓冲区较小并且位于调用栈下方，这种复制过程中的溢出可能会覆盖*整个*调用栈！
- en: Conveniently, the memory after the status variable is also controlled by the
    host. Much of it is used as a buffer to hold up to `0x30000` bytes of an RCM command.
    The command has a signature that we can’t forge, but it is stored in memory before
    the signature is checked.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 方便的是，状态变量之后的内存也由主机控制。大部分内存用作缓冲区，用来存储最多 `0x30000` 字节的 RCM 命令。命令有一个我们无法伪造的签名，但它会在签名检查之前被存储在内存中。
- en: '[Figure A.2](app01.xhtml#chAfig2) shows the layout of memory as Temkin’s exploit
    copies the pending RCM command over the call stack. There are no stack canaries
    or address space layout randomization (ASLR) to complicate things, and the call
    stack itself is executable. Trust-Zone is also not a problem here, as the RCM
    ROM runs in the highest privilege level as the Secure Monitor.'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 A.2](app01.xhtml#chAfig2)显示了内存布局，Temkin 的漏洞将待处理的 RCM 命令复制到调用栈上。这里没有堆栈保护或地址空间布局随机化（ASLR）来增加复杂性，并且调用栈本身是可执行的。Trust-Zone
    在这里也不是问题，因为 RCM ROM 以最高特权级别作为安全监控程序运行。'
- en: '**A.3 LPC55S69, K82 USB Overread**'
  id: totrans-26
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**A.3 LPC55S69，K82 USB 过度读取**'
- en: In addition to the TrustZone-M vulnerability in NXP’s LPC55S-69 that we’ll see
    in [Chapter C.4](app03.xhtml#app03_4), there is a USB overread bug in both that
    chip and NXP’s Kinetis K82 chip. Kilobytes of memory can be read past the end
    of a much smaller buffer. The bug was fixed in Revision A3 of the LPC55S69, but
    it is suspected that the same USB stack and its vulnerability were used in a variety
    of microcontrollers.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 除了我们将在 [C.4 章](app03.xhtml#app03_4) 中看到的 NXP 的 LPC55S-69 中的 TrustZone-M 漏洞外，NXP
    的 LPC55S69 和 Kinetis K82 芯片中还存在一个 USB 过度读取的 bug。可以在比实际缓冲区小得多的空间中读取到数千字节的内存。这个
    bug 已在 LPC55S69 的 A3 版本中修复，但怀疑相同的 USB 堆栈及其漏洞被应用在多种微控制器中。
- en: Alaudeen’s exploit for the LPC55S69 from Alaudeen (2021) is shown in [Figure
    A.3](app01.xhtml#chAfig3), which dumps 16kB from the chip before it resets. The
    K82 exploit in [Figure A.4](app01.xhtml#chAfig4) involves a more complicated transaction,
    but successfully dumps 64kB from the chip.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: Alaudeen (2021) 为 LPC55S69 提供的漏洞利用在 [图 A.3](app01.xhtml#chAfig3) 中展示，它在设备重置之前从芯片中转储
    16KB 数据。 [图 A.4](app01.xhtml#chAfig4) 中的 K82 漏洞利用涉及更复杂的事务，但成功地从芯片中转储了 64KB 数据。
- en: These two exploits are each limited to 4kB due to value of `MAX_CTRL_BUFFER_LENGTH`
    in libusb. It’s apparently possible to simply patch this `#define` to 65,536 in
    the library’s source code on many Linux platforms.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 由于libusb中`MAX_CTRL_BUFFER_LENGTH`的值，这两个漏洞每个都被限制在4kB。显然，在许多Linux平台上，只需简单地将该`#define`修改为65,536，就可以解决这个问题。
- en: '![Image](../images/f0254-01.jpg)'
  id: totrans-30
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/f0254-01.jpg)'
- en: 'Figure A.3: Alaudeen’s USB Exploit for the LPC55S69'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 图A.3：Alaudeen针对LPC55S69的USB漏洞
- en: '![Image](../images/f0255-01.jpg)'
  id: totrans-32
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/f0255-01.jpg)'
- en: 'Figure A.4: Alaudeen’s USB Exploit for the K82'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 图A.4：Alaudeen针对K82的USB漏洞
- en: Alaudeen provides sample dumps from both chips, but I can’t seem to find details
    on what is found within the dumps. As this chip has hundreds of kilobytes of SRAM,
    I expect that you are likely to find some bytes from the prior boot in the dump,
    but that you should not expect the technique to reveal much of the flash memory’s
    contents.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: Alaudeen提供了来自这两款芯片的示例转储，但我似乎找不到有关转储中发现内容的详细信息。由于这款芯片有数百KB的SRAM，我预计你可能会在转储中找到一些来自先前引导的字节，但不应指望此技术揭示闪存内容的太多信息。
- en: '**A.4 CH552 Verify Command**'
  id: totrans-35
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**A.4 CH552验证命令**'
- en: The CH552 is a cheap 8051 microcontroller with handy USB peripherals in the
    W.CH series from Nanjing Qinheng Microelectronics. Christophel and Thomas (2018)
    began as a German forum thread exploring this handy chip, but the conversation
    quickly took a turn to reverse engineering the bootloader as a way to write new
    clients without documentation.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: CH552是南京青恒微电子生产的价格便宜、功能实用的8051微控制器，具有USB外设。Christophel和Thomas（2018）最初在一个德国论坛线程中讨论这款有用的芯片，但讨论很快转向了反向工程引导加载程序，以便在没有文档的情况下编写新客户端。
- en: The bootloader comes pre-written to flash memory of these chips, but it is not
    in masked ROM, so software patches are possible. Eleven commands support reading,
    writing, erasing, and verifying flash memory. In keeping with the 8051’s Harvard
    architecture, there are separate commands for accessing the disjoint code and
    data memories.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 引导加载程序已预先写入这些芯片的闪存中，但它不在遮蔽ROM中，因此软件补丁是可能的。有11条命令支持读取、写入、擦除和验证闪存。与8051的哈佛架构一致，访问分开的代码和数据存储器有不同的命令。
- en: The exploitable bug here is in command `0xA6`, which verifies the code flash
    region. You provide it with a start address and some XOR-encoded bytes,^([1](footnotes.xhtml#app1fn1))
    and it returns zero if they match or non-zero if there’s an error. Thomas rewrites
    the vulnerable function as the C in [Figure A.6](app01.xhtml#chAfig6).
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的可利用漏洞存在于命令`0xA6`中，它验证代码闪存区域。你需要提供起始地址和一些XOR编码的字节,^([1](footnotes.xhtml#app1fn1))，如果匹配，它会返回零，否则返回非零值。Thomas将这个脆弱的函数重新编写成了[图A.6](app01.xhtml#chAfig6)中的C代码。
- en: The intent of the code seems to be that by requiring a multiple of eight bytes,
    an attacker should not be able to use the Verify function to brute-force the contents
    of memory. While it is true that guessing eight bytes at once would take forever,
    the bootloader’s author has forgotten to enforce alignment of the address!
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 该代码的目的是通过要求字节数为八的倍数，防止攻击者利用验证功能暴力破解内存的内容。虽然一次猜测八个字节确实需要很长时间，但引导加载程序的作者忘记强制对地址进行对齐！
- en: '![Image](../images/f0257-01.jpg)'
  id: totrans-40
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/f0257-01.jpg)'
- en: 'Figure A.5: W.CH CH552'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 图A.5：W.CH CH552
- en: '![Image](../images/f0258-01.jpg)'
  id: totrans-42
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/f0258-01.jpg)'
- en: 'Figure A.6: Decompiled CH552 Verification'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 图A.6：反编译CH552验证
- en: So to exploit this vulnerability, an attacker can set the address to seven known
    bytes followed by an eighth unknown byte, then brute-force the eighth byte. Once
    it is known, the window can slide forward by one byte to crack the next.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 要利用这个漏洞，攻击者可以将地址设置为七个已知字节，后面跟着一个未知的第八个字节，然后暴力破解第八个字节。一旦找到了这个字节，窗口就可以每次滑动一个字节来破解下一个字节。
- en: One direct way to exploit this is to begin at the known boot-loader, then slide
    forward into the application one byte at a time. A more generic technique, used
    in Cheron (2019), is to assume that the firmware ends with eight bytes of `0xff`
    and work backward to the start of the application image.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 利用此漏洞的直接方法是从已知的引导加载程序开始，然后每次向前滑动一个字节进入应用程序。Cheron（2019）中使用的一种更通用的技术是假设固件以八个`0xff`字节结束，然后从应用程序镜像的起始位置向后推算。
- en: '![Image](../images/f0259-01.jpg)'
  id: totrans-46
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/f0259-01.jpg)'
- en: 'Figure A.7: Stack Buffer Overflow in BCM61650'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 图A.7：BCM61650中的堆栈缓冲区溢出
- en: '**A.5 BCM61650/PRC6000 Headers**'
  id: totrans-48
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**A.5 BCM61650/PRC6000头文件**'
- en: Broadcom’s BCM61650, previously known as the PRC6000 before their acquisition
    of Percello, is a MIPS CPU used in 3G femtocells as a plugin to a popular French
    brand of DSL and fiber modems.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: Broadcom 的 BCM61650，之前在其收购 Percello 之前被称为 PRC6000，是一款用于 3G 微蜂窝的 MIPS CPU，作为流行法国品牌
    DSL 和光纤调制解调器的插件使用。
- en: Xilokar (2022) describes an exploit against the header format of the chip’s
    TFTP boot image. He begins by patching the module hardware to expose Ethernet
    pins, then popping a root shell by exposed passwords in a TFTP network boot image.
    After gaining this foothold, he wrote the quick kernel module in [Figure A.8](app01.xhtml#chAfig8)
    to dump the ROM into the kernel log.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: Xilokar（2022）描述了针对芯片 TFTP 启动映像头部格式的利用。他首先修补模块硬件以暴露以太网引脚，然后通过 TFTP 网络启动映像中的暴露密码获取
    root shell。获得这个立足点后，他编写了[图 A.8](app01.xhtml#chAfig8)中的快速内核模块，将 ROM 转储到内核日志中。
- en: Having the ROM dump, he identified a parsing bug in the bootloader’s header
    parsing routine, shown in [Figure A.7](app01.xhtml#chAfig7). The bug here is that
    `fm_sig_len` is directly read from the attacker-controlled bootloader header,
    and its destination buffer at `0xbf40-090c` is not far from the initial stack
    position of `0xbf403ff0`. A very long header will overwrite stack variables and
    the return pointer during the copy.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 拥有 ROM 转储后，他在引导加载程序的头部解析例程中发现了一个解析错误，如[图 A.7](app01.xhtml#chAfig7)所示。这里的错误是
    `fm_sig_len` 是直接从攻击者控制的引导加载程序头部读取的，而其目标缓冲区 `0xbf40-090c` 离初始堆栈位置 `0xbf403ff0`
    不远。一个非常长的头部将覆盖堆栈变量和返回指针。
- en: '![Image](../images/f0260-01.jpg)'
  id: totrans-52
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/f0260-01.jpg)'
- en: 'Figure A.8: Linux ROM Dumper for the BCM61650'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 图 A.8：BCM61650 的 Linux ROM 转储工具
- en: By crafting an obscenely long signature length, the Percello bootloader can
    be exploited to skip the signature validation. The FM loader can then be freely
    patched to allow an arbitrary kernel and initial ramdisk.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 通过制作一个极长的签名长度，可以利用 Percello 引导加载程序跳过签名验证。然后，可以自由修补 FM 加载程序以允许任意的内核和初始 ramdisk。
- en: '**A.6 PSoC4 Flash Doubler**'
  id: totrans-55
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**A.6 PSoC4 闪存加倍器**'
- en: The PSoC4 series of ARM Cortex M0 microcontrollers from Cypress has a protected
    ROM, called SROM, that implements many boot features. It in turn uses a hidden
    and protected flash memory, called SFLASH, to store settings such as the protection
    level of the chip and the capacity of flash memory.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: Cypress 的 PSoC4 系列 ARM Cortex M0 微控制器具有一个受保护的 ROM，称为 SROM，实施了许多启动功能。它又使用一个隐藏且受保护的闪存，称为
    SFLASH，用来存储设置，如芯片的保护级别和闪存容量。
- en: In Grinberg (2017a), Dmitry Grinberg published details for dumping the SROM
    by a ROP chain triggered from user flash memory, patching the SFLASH by re-implementing
    the SROM’s flash library, and doubling the capacity of a CY8C4013SXI-400 from
    8kB to 16kB by patching two bytes of SFLASH.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Grinberg（2017a）中，Dmitry Grinberg 发布了通过用户闪存触发的 ROP 链转储 SROM 的详细信息，修补 SFLASH
    通过重新实现 SROM 的闪存库，并通过修补 SFLASH 的两个字节将 CY8C4013SXI-400 的容量从 8kB 扩展到 16kB。
- en: As a follow-up, Grinberg (2017b) attempts to thoroughly document the extra registers
    and their meanings to aid in porting these attacks to other chips.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 作为后续，Grinberg（2017b）尝试彻底记录额外寄存器及其含义，以帮助将这些攻击移植到其他芯片。
- en: '**A.7 i.MX53 Overflow in Bootloader**'
  id: totrans-59
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**A.7 i.MX53 引导加载程序溢出**'
- en: The i.MX53 chip used in the first-generation USB Armory device has a stack buffer
    overflow vulnerability in its boot ROM, described in Delugré and Szkudlapski (2017),
    that allows for a bypass of the code signing and secure boot restrictions. A few
    more details are in Barisani (2017).
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一代 USB Armory 设备中使用的 i.MX53 芯片具有堆栈缓冲区溢出漏洞，如 Delugré 和 Szkudlapski（2017）所述，允许绕过代码签名和安全启动限制。更多细节见
    Barisani（2017）。
- en: The first vuln, CVE-2017-7932, is a stack buffer overflow in the X.509 parser.
    The certificate is parsed before it is verified, so the exploit can trigger without
    proper signing, and a proof of concept is available in the `hab_poc` function
    of `usbarmory_csftool` in the USB Armory git repository.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个漏洞，CVE-2017-7932，是 X.509 解析器中的堆栈缓冲区溢出。证书在验证之前就被解析，因此漏洞可以在没有正确签名的情况下触发，概念验证可以在
    USB Armory Git 仓库中的 `usbarmory_csftool` 的 `hab_poc` 函数中找到。
- en: The second, CVE-2017-7936, allows for remote code execution in ROM’s implementation
    of the Serial Download Protocol (SDP) by abusing incorrect memory checks.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个漏洞，CVE-2017-7936，通过滥用不正确的内存检查，在 ROM 中的串行下载协议（SDP）实现中允许远程代码执行。
- en: '**A.8 M16C Bootloader Timing Attack**'
  id: totrans-63
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**A.8 M16C 引导加载程序定时攻击**'
- en: Renesas M16C chips have a ROM bootloader that’s vulnerable to a straightforward
    timing attack, at least until the fourth revision of the bootloader. In Bazanski
    and Kowalczyk (2018), this was used as a way to dump the Mitsubishi M306K9FCLRP
    chip that functions as the embedded controller in a Toshiba Portégé R100 laptop.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 瑞萨M16C芯片具有一个ROM引导加载程序，容易受到简单的时序攻击，至少在引导加载程序的第四个版本之前是如此。在Bazanski和Kowalczyk（2018）中，利用这一点作为一种方式，来提取作为嵌入式控制器的三菱M306K9FCLRP芯片，该芯片用于东芝Portégé
    R100笔记本电脑。
- en: The firmware extraction bug itself is a simple timing attack against a password
    check. As you enumerate every possible first byte, one of them will be 3 µs faster
    than the other 255\. Repeating this for each byte gives the expected password
    in an average of 900 guesses, after which all seven bytes are known. With those
    seven bytes, you can freely read and write flash memory.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 固件提取漏洞本身是一个简单的时序攻击，针对密码检查。通过枚举每个可能的第一个字节，其中一个会比其他255个字节快3微秒。对每个字节重复此操作，平均需要900次猜测即可得到预期的密码，之后七个字节就能全部知道。有了这七个字节，你就可以自由地读写闪存。
- en: An exploit for this bug is available as Bazanski (2017). It runs as a Python
    host application, matched to an ICEStick FPGA devboard, programmed with the open
    source Icestorm toolchain.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: Bazanski（2017）提供了这个漏洞的利用程序。它作为一个Python主机应用程序运行，匹配一个使用开源Icestorm工具链编程的ICEStick
    FPGA开发板。
- en: '**A.9 IC204 Bypass by Magic Number**'
  id: totrans-67
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**A.9 IC204通过魔术数字绕过**'
- en: Lim (2021) describes the inner workings of a Mercedes-Benz ECU whose model number
    is the IC204\. Lim’s specific example is from a 2011 C300, but many vehicles between
    2007 and 2013 ought to be vulnerable to the same bug.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: Lim（2021）描述了一款梅赛德斯-奔驰ECU的内部工作，其型号为IC204。Lim的具体示例来自2011年的C300，但2007年至2013年间的许多车辆应该都容易受到同样的漏洞影响。
- en: '![Image](../images/f0263-01.jpg)'
  id: totrans-69
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/f0263-01.jpg)'
- en: 'Figure A.9: Nyan Cat on a 2011 Mercedes Dashboard'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 图A.9：2011年梅赛德斯仪表盘上的Nyan Cat
- en: The trick here is that the Renesas uPD70F3426 is programmed with a ROM bootloader
    chain that verifies signatures on each section as the boot progresses. Lim reverse
    engineered that ROM to find that the signature check is performed just once per
    firmware update, and each block’s successful verification is cached as a 32-bit
    magic word.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的技巧是，瑞萨uPD70F3426被编程为带有ROM引导加载程序链，验证每个部分的签名，随着引导过程的进行。Lim逆向工程该ROM，发现签名检查每次固件更新时只进行一次，每个块的成功验证会被缓存为一个32位的魔术数字。
- en: The magic word in this case is `0x5a5a5a5a`. By writing that word to `0x0f1f80`,
    `0x16ef80`, `0x1b3f80`, `0x1f4f80`, `0x1f5f80`, `0x0fff80` and `0x1fff80`, all
    of which are allowed by the ROM, the signature check can be bypassed and arbitrary
    code can be freely run.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，神奇的数字是`0x5a5a5a5a`。通过将该数字写入`0x0f1f80`、`0x16ef80`、`0x1b3f80`、`0x1f4f80`、`0x1f5f80`、`0x0fff80`和`0x1fff80`，这些位置都被ROM允许，签名检查可以被绕过，任意代码可以自由执行。
- en: After gaining control of the ECU firmware, he added Nyan Cat to the ABS and
    SYS malfunction messages in [Figure A.9](app01.xhtml#chAfig9).
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 在获取ECU固件控制权后，他将Nyan Cat添加到ABS和SYS故障消息中，如[图A.9](app01.xhtml#chAfig9)所示。
- en: '**A.10 Zynq 7000 Bootloader Dumping**'
  id: totrans-74
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**A.10 Zynq 7000引导加载程序转储**'
- en: Quite often a chip is exploited first by awkward and labor intensive means,
    and then the dump from that first exploit is reverse engineered to find a simpler
    method. Such was the case with the Xilinx Zynq bootloader, after being dumped
    by the glitching attack in [Chapter E.16](app05.xhtml#app05_16).
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 很多时候，芯片首先通过笨拙且劳动密集的方式被利用，接着从第一次利用的转储中进行逆向工程，找到一种更简单的方法。Xilinx Zynq引导加载程序就是这样，在[第E.16章](app05.xhtml#app05_16)中通过故障攻击被转储后，才发现了这一点。
- en: Schretlen (2021a) describes such a UART bootloader, which you can enable by
    pulling both boot mode pins high. It takes just the Python code from [Figure A.10](app01.xhtml#chAfig10)
    to upload and execute a valid image. When implementing this yourself, be careful
    to delay as that code does; it’s necessary to avoid reliability bugs in the ROM.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: Schretlen（2021a）描述了这样一个UART引导加载程序，你可以通过拉高两个引导模式引脚来启用它。只需要[图A.10](app01.xhtml#chAfig10)中的Python代码，就能上传并执行一个有效的镜像。在自己实现这个时，要小心像代码中那样延时；这样做是为了避免ROM中的可靠性问题。
- en: By this stage, it’s clear that we can upload an image, but what image is worth
    uploading to extract the ROM? A good first target would be something that copies
    the ROM into RAM for later extraction. Schretlen (2021c) presents an exploit in
    the form of a Zynq 7000 application header header, taking advantage of the fact
    that the bootloader never bothers to verify the source address of the image.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 到此阶段，我们已经明确可以上传镜像，但什么镜像值得上传以提取 ROM 呢？一个好的首选目标是复制 ROM 到 RAM 中，以便稍后提取。Schretlen（2021c）提出了一种利用
    Zynq 7000 应用程序头的漏洞，利用引导加载程序从不验证镜像源地址这一事实。
- en: Shown in [Figure A.10](app01.xhtml#chAfig10), the exploit payload is just an
    image header that copies the ROM out of its native address and into RAM at `0x00000000`.
    After booting the exploit, the attacker recovers the image by attaching a JTAG
    debugger and dumping that range of memory to disk. The JTAG debugger can’t read
    the original, but it can freely read the copy that the ROM refuses to boot.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 如 [图 A.10](app01.xhtml#chAfig10) 所示，漏洞载荷仅是一个镜像头，它将 ROM 从原地址复制到 `0x00000000`
    的 RAM 中。在执行漏洞攻击后，攻击者通过附加 JTAG 调试器并将该内存范围的内容转储到磁盘来恢复镜像。JTAG 调试器无法读取原始数据，但可以自由读取
    ROM 拒绝启动的复制数据。
- en: '**A.11 Zynq 7000 NAND/ONFI**'
  id: totrans-79
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**A.11 Zynq 7000 NAND/ONFI**'
- en: Schretlen (2022a) describes a memory corruption exploit for the NAND/ONFI interface
    of the Zynq ROM and the `embeddedsw` hardware abstraction library (HAL) prior
    to `xilinx_v2021.1`.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: Schretlen（2022a）描述了一种针对 Zynq ROM 的 NAND/ONFI 接口以及 `embeddedsw` 硬件抽象库（HAL）漏洞，适用于
    `xilinx_v2021.1` 之前的版本。
- en: The ONFI specification (Open NAND Flash Interface) is a standard for NAND chips
    that defines their package, their pinout, and various other modes, so chips from
    one vendor can be a drop-in, compatible replacement for those from another vendor.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: ONFI 规范（开放 NAND 闪存接口）是 NAND 芯片的标准，定义了它们的封装、引脚配置及其他各种模式，使得来自不同厂商的芯片可以互换、兼容。
- en: Beyond standardizing the pinout ([Figure A.12](app01.xhtml#chAfig12)) and signaling,
    ONFI also provides a standardized “parameter page” and matching data structure.
    The parameter page is a page of the NAND chip that can be read by device code,
    as a way for the NAND to report back some of its characteristics. The parameter
    page structure begins with `4f`, `4e`, `46`, `49` (“`ONFI`”) and includes fields
    for protocol revision numbers, a baker’s dozen of optional features and commands,
    JEDEC manufacturer information, and memory organization.^([2](footnotes.xhtml#app1fn2))
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 除了标准化引脚配置（[图 A.12](app01.xhtml#chAfig12)）和信号之外，ONFI 还提供了标准化的“参数页面”及匹配的数据结构。参数页面是
    NAND 芯片的一页，可以通过设备代码读取，以便 NAND 芯片报告其一些特性。参数页面结构以 `4f`、`4e`、`46`、`49`（“`ONFI`”）开始，并包括协议版本号、十三个可选功能和命令、JEDEC
    制造商信息和内存组织等字段。^([2](footnotes.xhtml#app1fn2))
- en: '![Image](../images/f0266-01.jpg)'
  id: totrans-83
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/f0266-01.jpg)'
- en: 'Figure A.10: Zynq Bootloader Client from Schretlen (2021a)'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 图 A.10：来自 Schretlen（2021a）的 Zynq 启动加载程序客户端
- en: '![Image](../images/f0267-01.jpg)'
  id: totrans-85
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/f0267-01.jpg)'
- en: 'Figure A.11: Zynq 7000 Exploit Header from Schretlen (2021c)'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 图 A.11：来自 Schretlen（2021c）的 Zynq 7000 漏洞头
- en: '![Image](../images/f0268-01.jpg)'
  id: totrans-87
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/f0268-01.jpg)'
- en: 'Figure A.12: Standardized NAND/ONFI Pinout'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 图 A.12：标准化的 NAND/ONFI 引脚配置
- en: Bytes 80 through 99 of the ONFI parameter page describe the memory organization
    as a number of data bytes per page, spare bytes per page, pages per block, and
    blocks per LUN, or logical unit number. These values are poorly verified, and
    having too many spare bytes per page will cause an overflow in the fetching of
    the Bad Block Table, which is loaded into a `0x200` byte local stack variable.
    Overflowing this buffer gives control of several useful stack variables.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: ONFI 参数页面的第 80 到 99 字节描述了内存的组织方式，包括每页的数据字节数、每页的备用字节数、每个块的页面数以及每个 LUN（逻辑单元号）的块数。这些值的验证较差，且每页备用字节过多会导致获取坏块表时发生溢出，坏块表会被加载到一个
    `0x200` 字节的本地栈变量中。溢出此缓冲区会使得多个有用的栈变量的控制权被获取。
- en: Because the parameter page isn’t known to be writable on any commercially available
    NAND flash chip, triggering this exploit requires emulating the NAND chip with
    an FPGA. Galan Schretlen had the advantage when writing this attack of previously
    having dumped the ROM by the techniques in [Chapters E.16](app05.xhtml#app05_16)
    and [A.10](app01.xhtml#app01_10); writing the exploit blind would be more of a
    challenge!
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 由于目前已知的任何商用 NAND 闪存芯片的参数页面均不可写，因此触发此漏洞需要使用 FPGA 模拟 NAND 芯片。Galan Schretlen 在编写此攻击时的优势在于他之前已经通过
    [章节 E.16](app05.xhtml#app05_16) 和 [A.10](app01.xhtml#app01_10) 的技术转储了 ROM；若盲目编写漏洞攻击则会更加具有挑战性！
- en: The following is his shellcode in ARM assembly that will unlock JTAG on Xilinx
    Zynq and dump a few useful register values to the UART.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是他在 ARM 汇编中的 shellcode，将解锁赛灵思 Zynq 上的 JTAG，并将几个有用的寄存器值转储到 UART。
- en: '![Image](../images/f0269-01.jpg)![Image](../images/f0270-01.jpg)![Image](../images/f0271-01.jpg)![Image](../images/f0272-01.jpg)'
  id: totrans-92
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/f0269-01.jpg)![Image](../images/f0270-01.jpg)![Image](../images/f0271-01.jpg)![Image](../images/f0272-01.jpg)'
- en: '**A.12 Zynq 7000 BOOT.BIN Parsing**'
  id: totrans-93
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**A.12 Zynq 7000 BOOT.BIN 解析**'
- en: The Xilinx Zynq 7000 exploit in [Chapter A.11](app01.xhtml#app01_11) is great
    when physical access is available, the NAND pins are broken out, and an FPGA emulator
    of the NAND chip is readily available, but these restrictions can be tiresome,
    and many high-end boards don’t use NAND chips, so they don’t break out the necessary
    pins. In this chapter we’ll discuss Schretlen (2022b), a memory corruption vulnerability
    in the parser of the `BOOT.BIN` file that might be found on an SD Card.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 当有物理访问权限，NAND 引脚已断开，并且有一个 FPGA 模拟器的 NAND 芯片易于获得时，赛灵思 Zynq 7000 的漏洞利用在[第 A.11
    章](app01.xhtml#app01_11)非常好用，但这些限制可能令人厌烦，并且许多高端板卡不使用 NAND 芯片，因此它们不会断开必要的引脚。在本章中，我们将讨论
    Schretlen（2022b），这是 `BOOT.BIN` 文件解析器中的内存破坏漏洞，该文件可能在 SD 卡上找到。
- en: This exploit requires no fancy emulator hardware, and it triggers before signatures
    are checked, so it does not require a separate break of the cryptography. It’s
    perfect for jailbreaking a device.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 此漏洞利用不需要复杂的模拟器硬件，并且在签名检查之前触发，因此不需要单独破解加密。非常适合越狱设备。
- en: Schretlen began by using Unicorn’s Python bindings to emulate the ROM that had
    previously been extracted. Once functional, the emulator could be used to explore
    the allowed address ranges in the Register Init Lists (RILs) of `BOOT.BIN`.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: Schretlen 首先使用 Unicorn 的 Python 绑定来模拟先前提取的 ROM。一旦功能正常，模拟器就可以用来探索 `BOOT.BIN`
    的注册初始化列表（RILs）中允许的地址范围。
- en: As `BOOT.BIN` is being parsed, the ROM loads sections into RAM according to
    the RILs. Only *after* the image has been completely loaded is the signature checked.
    This defends against time-of-check to time-of-use (TOCTOU) attacks, but this also
    means that a parser bug might be exploited before the signature check is complete.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 当解析 `BOOT.BIN` 时，ROM 根据 RILs 将部分加载到 RAM 中。只有在图像完全加载后才会检查签名。这样做可以防范时机检查到使用（TOCTOU）攻击，但这也意味着在签名检查完成之前可能会利用解析器漏洞。
- en: Schretlen found that while the base register of the SDIO DMA controller is not
    writable, it has already been set by the boot ROM because the machine is booting
    from an SD Card. You’ll see this same trick in many embedded exploits, in that
    they won’t bother to configure an I/O port or register that the exploited software
    has already configured.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: Schretlen 发现，虽然 SDIO DMA 控制器的基本寄存器不可写，但由于机器正在从 SD 卡引导，它已经被引导 ROM 设置。在许多嵌入式漏洞利用中，你会看到相同的技巧，即不会费心配置被利用软件已经配置的
    I/O 端口或寄存器。
- en: The following is a Python script that generates a payload header for triggering
    the bug. It requires a rather fast SD Card for race condition reasons that are
    best explained in the original paper, and the header must be followed by blocks
    with shellcode that fit into the overwritten bootloader.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个 Python 脚本，用于生成触发漏洞的有效负载头部。由于竞争条件的原因，它需要一个相当快的 SD 卡，这些原因最好在原始论文中进行解释，并且头部必须跟随适合于覆盖引导加载程序的
    shellcode 块。
- en: '![Image](../images/f0273-01.jpg)![Image](../images/f0274-01.jpg)![Image](../images/f0275-01.jpg)'
  id: totrans-100
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/f0273-01.jpg)![Image](../images/f0274-01.jpg)![Image](../images/f0275-01.jpg)'
- en: '**A.13 TMP91 Password**'
  id: totrans-101
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**A.13 TMP91 密码**'
- en: 'Toshiba’s TLCS-900 series, better known by its prefix TMP91, is a 16-bit microcontroller
    from the early 2000s. Its bootloader features two protections: a password and
    a protection flag. The protections are redundant, so that if the flag is set,
    the password alone is not very useful.'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 東芝的 TLCS-900 系列，以其前缀 TMP91 而闻名，是2000年代初的16位微控制器。其引导加载程序具有两种保护措施：密码和保护标志。这些保护措施是冗余的，因此如果设置了标志，则仅密码并不是非常有用。
- en: In the case of at least the TMP91FW27 and TMP91FW60 devices, O’Flynn (2023)
    describes a successful use of power analysis to recover the bootloader password,
    as well as a less successful fault injection attack against the protection flag.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 至少对于 TMP91FW27 和 TMP91FW60 设备，O’Flynn（2023）描述了成功使用功耗分析恢复引导加载程序密码，以及针对保护标志的不太成功的故障注入攻击。
- en: The ROM bootloader contains just five commands, with the password being required
    to lock the chip with `0x60` and to execute code from RAM with `0x10`. Enabling
    the protection flag ensures that no new programs will run from RAM even with the
    password.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: ROM引导加载程序仅包含五个命令，其中需要密码才能用`0x60`锁定芯片，并用`0x10`从RAM执行代码。启用保护标志可确保即使有密码，也无法从RAM运行新的程序。
- en: In O’Flynn’s case, he wanted to dump the firmware from his kitchen oven in order
    to work around a bug with the thermostat. The oven would work its way up to roughly
    the right temperature, but the thermometer always read the target temperature
    and never the actual temperature. This ruined a fine batch of cookies and Colin
    had to have his revenge with a firmware extraction and patch.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 在O’Flynn的情况下，他想提取自己厨房烤箱的固件，以便绕过恒温器的一个bug。烤箱会加热到大约正确的温度，但温度计总是显示目标温度，而不是实际温度。这导致了一批精美的饼干被毁，科林决定通过固件提取和修补来报复。
- en: His oven uses a TMP91FW60, but he prototyped his attack against the TMP91FW27,
    which is more plentiful on eBay. The idea here is to first attack a cheap target,
    then to go back and hit the rare target.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 他的烤箱使用的是TMP91FW60芯片，但他针对TMP91FW27进行了攻击原型开发，因为该芯片在eBay上更为常见。这里的思路是首先攻击一个便宜的目标，然后再回过头来攻击那个稀有的目标。
- en: For power analysis, he added a shunt resistor on the VCC pin, and he also replaced
    the quartz crystal with an external clock supply to keep power analysis synced
    with the target. By sending password guesses to the chip and measuring the voltage
    drop during each guess, he was able to reveal the correctness of the guess, one
    byte at a time. He also identified a potential target for a voltage or clock glitch
    to skip the flag check in the bootloader, which is necessary to run a RAM program
    when the protection flag is enabled.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 为了进行功率分析，他在VCC引脚上添加了分流电阻，并用外部时钟源替换了石英晶体，以便让功率分析与目标同步。通过向芯片发送密码猜测并测量每次猜测时的电压降，他能够逐字节地揭示猜测的正确性。他还确定了一个潜在的目标，通过电压或时钟故障跳过引导加载程序中的标志检查，这对于在启用保护标志时运行RAM程序是必要的。
- en: '![Image](../images/f0277-01.jpg)'
  id: totrans-108
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/f0277-01.jpg)'
- en: 'Figure A.13: TMP91 Bootloader Commands'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 图A.13：TMP91引导加载程序命令
- en: '![Image](../images/f0277-02.jpg)'
  id: totrans-110
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/f0277-02.jpg)'
- en: 'Figure A.14: O’Flynn’s TMP91 Target Board'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 图A.14：O’Flynn的TMP91目标板
- en: '![Image](../images/f0278-01.jpg)'
  id: totrans-112
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/f0278-01.jpg)'
- en: 'Figure A.15: TMP91FU62F0'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 图A.15：TMP91FU62F0
- en: At this point, all was well on his FW27 demo board, so he moved back to the
    FW60 chip from his oven. Power analysis revealed the password to be `samsungoven0`,
    but in adjusting his voltage glitch, he accidentally erased all memory. The firmware
    he had worked so hard to extract was gone!
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 到此为止，他的FW27演示板一切顺利，于是他转回了烤箱中的FW60芯片。功率分析揭示了密码是`samsungoven0`，但在调整电压故障时，他不小心擦除了所有内存。他辛苦提取的固件消失了！
- en: A few phone calls to Samsung support got a replacement shipped his way, but
    this board differed from the original oven in one crucial way. While both used
    the same password, the replacement did not have the protection flag enabled! Knowing
    the password, he could freely run shellcode from SRAM to dump the program memory.
    If you aren’t so lucky as to get a target missing the lockout bit, O’Flynn suggests
    searching your glitch parameters backward from the end of the search window.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 给三星客服打了几通电话后，他收到了替换品，但这个板子与原始烤箱有一个关键的区别。虽然两者使用相同的密码，但替换品并没有启用保护标志！知道密码后，他可以自由地从SRAM运行shellcode来提取程序内存。如果你没有这么幸运，得到一个没有锁定位的目标，O’Flynn建议从搜索窗口的末尾向后查找你的故障参数。
