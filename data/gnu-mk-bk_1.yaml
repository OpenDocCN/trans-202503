- en: Chapter 1. The Basics Revisited
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第1章 基础回顾
- en: This chapter covers material that might be considered basic GNU `make` knowledge
    but covers it to highlight commonly misunderstood functionality and clarify some
    confusing parts of GNU `make`. It also covers the differences between GNU `make`
    versions 3.79.1, 3.81, 3.82, and 4.0\. If you’re working with a version prior
    to 3.79.1, you should probably upgrade.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖的内容可能被视为基本的GNU `make`知识，但我们将重点讲解常见的误解功能，并澄清一些GNU `make`中的混淆部分。它还涵盖了GNU `make`版本3.79.1、3.81、3.82和4.0之间的差异。如果你使用的是3.79.1之前的版本，建议你升级。
- en: This chapter is in no way a replacement for the official GNU `make` manual (Free
    Software Foundation, 2004). I highly recommend owning a copy of it. You can also
    find the manual at *[http://www.gnu.org/make/manual](http://www.gnu.org/make/manual)*.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章绝不是官方GNU `make`手册（自由软件基金会，2004年）的替代品。我强烈推荐拥有一本该手册的副本。你也可以在* [http://www.gnu.org/make/manual](http://www.gnu.org/make/manual)
    *找到手册。
- en: Getting Environment Variables into GNU make
  id: totrans-3
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将环境变量导入GNU `make`
- en: 'Any variable set in the environment when GNU `make` is started will be available
    as a GNU `make` variable inside the makefile. For example, consider the following
    simple makefile:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在GNU `make`启动时，任何在环境中设置的变量都将在makefile内作为GNU `make`变量可用。例如，考虑以下简单的makefile：
- en: '[PRE0]'
  id: totrans-5
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'If `FOO` is set in the environment to `foo` when GNU `make` is run, this makefile
    will output `foo`, thus verifying that `FOO` was indeed set to `foo` inside the
    makefile. You can discover where `FOO` got that value by using GNU `make`’s `$(origin)`
    function. Try adding to the makefile as follows (the new part is in bold):'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在运行GNU `make`时，环境变量`FOO`被设置为`foo`，那么这个makefile将输出`foo`，从而验证`FOO`确实在makefile内被设置为`foo`。你可以通过使用GNU
    `make`的`$(origin)`函数来发现`FOO`是从哪里得到这个值的。尝试将下面的内容添加到makefile中（新部分用**加粗**表示）：
- en: '[PRE1]'
  id: totrans-7
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: If a variable `FOO` is defined in the environment and automatically imported
    into GNU `make`, `$(origin FOO)` will have the value `environment`. When you run
    the makefile, it should give the output `foo environment`.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 如果变量`FOO`在环境中定义，并自动导入到GNU `make`中，`$(origin FOO)`将返回`environment`。当你运行makefile时，它应该输出`foo
    environment`。
- en: 'A variable imported from the environment can be overridden inside the makefile.
    Simply set its value:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 可以在makefile中覆盖从环境导入的变量。只需设置其值：
- en: '[PRE2]'
  id: totrans-10
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: This gives the output `bar file`. Notice how the value of `$(origin FOO)` has
    changed from `environment` to `file`, indicating that the variable got its value
    inside a makefile.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 这将输出`bar file`。请注意，`$(origin FOO)`的值从`environment`变为`file`，表明该变量的值是在makefile内设置的。
- en: It’s possible to prevent a definition in a makefile from overriding the environment
    by specifying the `-e` (or `--environment-overrides`) option on the command line
    of GNU `make`. Running the preceding makefile with `FOO` set to `foo` in the environment
    and the `-e` command line option gives the output `foo environment override`.
    Notice here that `FOO` has the value from the environment (`foo`) and that the
    output of `$(origin FOO)` has changed to `environment override` to inform us that
    the variable came from the environment, even though it was redefined in the makefile.
    The word `override` appears only if a variable definition was actually overridden;
    the `$(origin)` function simply returns `environment` (no `override`) if the variable
    being tested was defined in the environment, but there was no attempt to redefine
    it in the makefile.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 可以通过在GNU `make`的命令行中指定`-e`（或`--environment-overrides`）选项，来防止makefile中的定义覆盖环境中的值。将`FOO`设置为`foo`并加上`-e`命令行选项来运行上述makefile时，会输出`foo
    environment override`。请注意，在这里`FOO`的值来自环境（`foo`），并且`$(origin FOO)`的输出已经变为`environment
    override`，告知我们该变量来自环境，尽管它在makefile中被重新定义。只有当变量定义被真正覆盖时，`override`这个词才会出现；如果变量在环境中定义且没有在makefile中重新定义，`$(origin)`函数将只返回`environment`（没有`override`）。
- en: If all you care about is whether the variable got its value from the environment,
    then using `$(firstword $(origin VAR))` is always guaranteed to return the string
    `environment` if the variable `VAR` got its value from the environment, regardless
    of whether `-e` is specified or not.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你关心的只是变量是否从环境中获取了值，那么使用`$(firstword $(origin VAR))`始终能保证返回字符串`environment`，如果变量`VAR`的值来自环境，无论是否指定`-e`选项。
- en: 'Suppose you absolutely want to guarantee that the variable `FOO` gets its value
    inside the makefile, not from the environment. You can do this with the `override`
    directive:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你完全希望保证变量`FOO`的值来自makefile，而不是来自环境。你可以使用`override`指令来做到这一点：
- en: '[PRE3]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: This will output `bar override` regardless of the value of `FOO` in the environment
    or whether you specify the `-e` command line option. Note that `$(origin)` tells
    you this is an override by returning `override`.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 这将输出 `bar override`，无论环境中 `FOO` 的值是多少，或者你是否指定了 `-e` 命令行选项。注意，`$(origin)` 会告诉你这是一个通过返回
    `override` 的覆盖。
- en: 'The other way to get around `-e` and set the value of a variable is by setting
    it on the GNU `make` command line. For example, revert your makefile to the following:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 设置变量的另一种方法是通过在 GNU `make` 的命令行中设置它。例如，将你的 makefile 恢复为以下内容：
- en: '[PRE4]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Running `FOO=foo make -e FOO=fooey` on the command line will output `fooey
    command line`. Here `$(origin FOO)` returned `command line`. Now try adding the
    override command back into the makefile:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 在命令行上运行 `FOO=foo make -e FOO=fooey` 将输出 `fooey command line`。此时 `$(origin FOO)`
    返回了 `command line`。现在尝试将覆盖命令重新添加到 makefile 中：
- en: '[PRE5]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: If you run that same command on the command line (`FOO=foo make -e FOO=fooey`),
    now it outputs `bar override`.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在命令行上运行相同的命令（`FOO=foo make -e FOO=fooey`），它现在输出 `bar override`。
- en: 'Confused? A simple rule exists to help you keep it all straight: the `override`
    directive beats the command line, which beats environment overrides (the `-e`
    option), which beats variables defined in a makefile, which beats the original
    environment. Alternatively, you can always use `$(origin)` to find out what’s
    going on.'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 迷茫了吗？有一个简单的规则可以帮助你理清楚这一切：`override` 指令优先于命令行，命令行优先于环境覆盖（`-e` 选项），环境覆盖优先于 makefile
    中定义的变量，而 makefile 中定义的变量又优先于原始环境。或者，你总是可以使用 `$(origin)` 来找出发生了什么。
- en: Setting Variables from Outside the Makefile
  id: totrans-23
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从外部设置变量
- en: It’s common to have options in a makefile that can be set on the command line
    when you start a build. For example, you might want to change the type of build
    being performed or specify a target architecture outside the makefile.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 在 makefile 中设置可以通过命令行指定的选项是很常见的。例如，你可能希望改变正在执行的构建类型，或者指定一个目标架构，甚至是在 makefile
    外部指定。
- en: 'Perhaps the most common use case is a debug option to specify whether the build
    should create debuggable or release code. A simple way to handle this is with
    a makefile variable called `BUILD_DEBUG`, which is set to `yes` in the makefile
    and overridden on the command line when building the release version. For example,
    the makefile might have the line `BUILD_DEBUG := yes` somewhere near the start.
    The `BUILD_DEBUG` variable would then be used elsewhere in the makefile to decide
    how to set compiler debug options. Because `BUILD_DEBUG` is set to `yes` in the
    makefile, the default would be to do debug builds. Then, at release time, this
    default can be overridden from the command line:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 最常见的用例之一是一个调试选项，用于指定构建时是否应该创建可调试或发布代码。处理此问题的一种简单方法是使用一个名为 `BUILD_DEBUG` 的 makefile
    变量，它在 makefile 中设置为 `yes`，并在构建发布版本时通过命令行覆盖。例如，makefile 可能在开始的地方有这一行：`BUILD_DEBUG
    := yes`。然后，`BUILD_DEBUG` 变量会在 makefile 的其他地方使用，以决定如何设置编译器的调试选项。因为在 makefile 中设置了
    `BUILD_DEBUG := yes`，默认情况下会进行调试构建。然后，在发布时，可以从命令行覆盖此默认值：
- en: '[PRE6]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Close to release time it might be tempting to set `BUILD_DEBUG` to `no` in the
    shell’s startup script (for example, in `.cshrc` or `.bashrc`) so that all builds
    are release rather than debug. Unfortunately, this doesn’t work because of how
    GNU `make` inherits variables from the environment and how variables inside a
    makefile override the environment.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 接近发布时，可能会有冲动在 shell 启动脚本中（例如 `.cshrc` 或 `.bashrc`）将 `BUILD_DEBUG` 设置为 `no`，这样所有的构建都是发布版本，而不是调试版本。不幸的是，这种方法不起作用，因为
    GNU `make` 会从环境中继承变量，而 makefile 中的变量会覆盖环境变量。
- en: 'Consider this simple makefile that prints the value of `BUILD_DEBUG`, which
    has been set to `yes` at the start of the makefile:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑这个简单的 makefile，它打印出 `BUILD_DEBUG` 的值，而该值在 makefile 开头被设置为 `yes`：
- en: '[PRE7]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Note
  id: totrans-30
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '*In this example, the commands associated with the `all` target have been placed
    on the same line as the target name by using a semicolon. The alternative would
    be:*'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: '*在这个例子中，`all` 目标相关的命令通过使用分号与目标名称放在同一行。另一种方法是：*'
- en: '[PRE8]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '*But that requires a tab to start the commands. When the commands fit on a
    single line, it’s clearer to use the semicolon format available in GNU `make`.*'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: '*但这需要使用制表符来开始命令。当命令可以放在一行时，使用 GNU `make` 提供的分号格式会更清晰。*'
- en: 'Now try running the makefile three times: once with no options, once setting
    `BUILD_DEBUG` on GNU `make`’s command line, and once with `BUILD_DEBUG` set in
    the environment:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 现在尝试运行 makefile 三次：一次不设置选项，一次在 GNU `make` 的命令行上设置 `BUILD_DEBUG`，还有一次在环境中设置 `BUILD_DEBUG`：
- en: '[PRE9]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The last line shows that variables defined inside a makefile override values
    in the environment. But note that if `BUILD_DEBUG` had not been defined at all
    in the makefile, it would have been inherited from the environment and imported
    into the makefile automatically.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一行显示了在makefile中定义的变量覆盖环境中的值。但请注意，如果`BUILD_DEBUG`在makefile中根本没有定义，它将自动从环境中继承并导入到makefile中。
- en: 'The problem with definitions in a makefile overriding imported environment
    variables can be *solved* with a GNU `make` hammer: the `-e` switch, which makes
    the environment take precedence. But that affects *every* variable.'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 使用GNU `make`工具可以通过`-e`选项来解决makefile中定义覆盖导入的环境变量的问题，该选项使环境变量优先。但这会影响*所有*变量。
- en: '[PRE10]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'The rule to remember is this: *command line beats makefile beats environment*.
    A variable defined on the command line takes precedence over the same variable
    defined in a makefile, which will take precedence over the same variable defined
    in the environment.'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 需要记住的规则是：*命令行优先于makefile，makefile优先于环境*。在命令行中定义的变量优先于在makefile中定义的同名变量，而makefile中的变量又优先于环境中定义的同名变量。
- en: It’s possible to have a `BUILD_DEBUG` variable that is set by default to `yes`
    and can be overridden *either* on the command line or in the environment. GNU
    `make` provides two ways to achieve this, both of which rely on checking to see
    if the variable is already defined.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 可以有一个默认设置为`yes`的`BUILD_DEBUG`变量，它可以*在命令行或环境中*被覆盖。GNU `make`提供了两种方法来实现这一点，这两种方法都依赖于检查变量是否已经定义。
- en: 'Here’s one way. Replace the setting of `BUILD_DEBUG` in the original makefile
    with this:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一种方法。将原始makefile中的`BUILD_DEBUG`设置替换为：
- en: '[PRE11]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Now if `BUILD_DEBUG` has not already been set (that’s what `ndef` means: *not
    defined*), it will be set to `yes`; otherwise, it is left unchanged. Because typing
    `ifndef SOME_VARIABLE` and `endif` is a bit unwieldy, GNU `make` provides a shorthand
    for this pattern in the form of the `?=` operator:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`BUILD_DEBUG`尚未设置（这就是`ndef`的意思：*未定义*），它将被设置为`yes`；否则，它将保持不变。因为输入`ifndef SOME_VARIABLE`和`endif`有点笨重，GNU
    `make`提供了一个简便的方式来实现这一模式，即`?=`运算符：
- en: '[PRE12]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'The `?=` operator tells GNU `make` to set `BUILD_DEBUG` to `yes` unless it
    is already defined, in which case leave it alone. Rerunning the test yields:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: '`?=`运算符告诉GNU `make`将`BUILD_DEBUG`设置为`yes`，除非它已经被定义，在这种情况下保持不变。重新运行测试得到：'
- en: '[PRE13]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'This technique provides the ultimate flexibility. A default setting in the
    makefile can be overridden in the environment and by a temporary override on the
    command line:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 这种技术提供了最终的灵活性。makefile中的默认设置可以通过环境或命令行中的临时覆盖来覆盖：
- en: '[PRE14]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Note
  id: totrans-49
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '*There’s actually a subtle difference between `ifndef` and `?=` in how they
    handle variables that are defined but set to an empty string. Whereas `ifndef`
    means* if not empty even if defined*, the `?=` operator treats an empty, defined
    variable as defined. This difference is discussed in more detail in [Chapter 4](ch04.html
    "Chapter 4. Pitfalls and Problems").*'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: '*实际上，`ifndef`和`?=`在处理已定义但设置为空字符串的变量时有细微的区别。`ifndef`的意思是*如果未定义即使已定义*，而`?=`运算符将空的已定义变量视为已定义。这个差异在[第4章](ch04.html
    "第4章. 陷阱和问题")中有更详细的讨论。*'
- en: The Environment Used by Commands
  id: totrans-51
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 命令使用的环境
- en: The environment GNU `make` uses when it runs commands (such as commands in any
    rules it executes) is the environment GNU `make` started with, plus any variables
    *exported* in the makefile—as well as a few variables GNU `make` adds itself.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: GNU `make`在执行命令时（例如它执行的任何规则中的命令）使用的环境是GNU `make`启动时的环境，再加上makefile中*导出的*任何变量—以及GNU
    `make`自己添加的一些变量。
- en: 'Consider this simple makefile:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 请考虑这个简单的makefile：
- en: '[PRE15]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'First, notice the double `$` sign: it’s an escaped `$` and means that the command
    passed to the shell by GNU `make` is `echo FOO is $FOO`. You can use a double
    `$` to get a single `$` into the shell.'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，注意双`$`符号：它是一个转义的`$`，意味着GNU `make`传递给shell的命令是`echo FOO is $FOO`。你可以使用双`$`来在shell中获得一个单一的`$`符号。
- en: If you run this makefile with `FOO` not defined in the environment, you’ll see
    the output `FOO is`. The value of `FOO` is not set because the makefile did not
    specifically export `FOO` into the environment used by GNU `make` to run commands.
    So when the shell runs the `echo` command for the `all` rule, `FOO` is not defined.
    If `FOO` had been set to `foo` in the environment before GNU `make` was run, you
    would see the output `FOO is bar`. This is because `FOO` was already present in
    the environment GNU `make` started with and then picked up the value `bar` inside
    the makefile.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在环境中没有定义`FOO`，运行这个makefile时，你会看到输出`FOO is`。因为makefile没有特别地将`FOO`导出到GNU `make`用来运行命令的环境中，所以`FOO`的值没有被设置。因此，当shell执行`all`规则的`echo`命令时，`FOO`没有被定义。如果在运行GNU
    `make`之前，环境中已经将`FOO`设置为`foo`，你将看到输出`FOO is bar`。这是因为`FOO`在GNU `make`启动时已经存在于环境中，随后makefile中将`bar`的值赋给了它。
- en: '[PRE16]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'If you’re not sure whether `FOO` is in the environment but want to ensure that
    it makes its way into the environment used for commands, use the `export` directive.
    For example, you can ensure that `FOO` appears in the environment of subprocesses
    by modifying the makefile, like so:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你不确定`FOO`是否在环境中，但想确保它进入用于命令的环境，可以使用`export`指令。例如，你可以通过修改makefile，确保`FOO`出现在子进程的环境中，如下所示：
- en: '[PRE17]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Alternatively, you can just put `export FOO` on a line by itself. In both cases
    `FOO` will be exported into the environment of the commands run for the `all`
    rule.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 另外，你可以单独在一行写上`export FOO`。在这两种情况下，`FOO`将被导出到运行`all`规则命令的环境中。
- en: 'You can remove a variable from the environment with `unexport`. To ensure that
    `FOO` is excluded from the subprocess environment, whether or not it was set in
    the parent environment, run the following:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用`unexport`将一个变量从环境中移除。为了确保`FOO`被排除在子进程的环境之外，无论它是否在父环境中设置，都可以运行以下命令：
- en: '[PRE18]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: You’ll see the output `FOO is`.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 你会看到输出`FOO is`。
- en: You might be wondering what happens if you `export` and `unexport` a variable.
    The answer is that the last directive wins.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会想知道，如果你`export`并`unexport`一个变量，会发生什么。答案是，最后一个指令会生效。
- en: 'The `export` directive can also be used with target-specific variables to modify
    the environment just for a particular rule. For example:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: '`export`指令也可以与目标特定变量一起使用，以便只修改某个特定规则的环境。例如：'
- en: '[PRE19]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: The makefile sets `FOO` to `just for all` for the `all` rule and `bar` for any
    other rule.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: makefile将`FOO`设置为`just for all`用于`all`规则，而对其他任何规则则设置为`bar`。
- en: 'Note that you can’t remove `FOO` from the environment of a specific rule with
    a target-specific `unexport`. If you write `all: unexport FOO`, you’ll get an
    error.'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: '注意，你不能使用目标特定的`unexport`从特定规则的环境中移除`FOO`。如果你写`all: unexport FOO`，你将得到一个错误。'
- en: 'GNU `make` also adds a number of variables to the subprocess environment—specifically,
    `MAKEFLAGS`, `MFLAGS`, and `MAKELEVEL`. The `MAKEFLAGS` and `MFLAGS` variables
    contain the flags specified on the command line: `MAKEFLAGS` contains the flags
    formatted for GNU `make`’s internal use and `MFLAGS` is only there for historical
    reasons. Never use `MAKEFLAGS` in a recipe. If you really need to, you can set
    `MFLAGS`. The `MAKELEVEL` variable contains the depth of recursive `make` calls,
    via `$(MAKE)`, starting at zero. For more detail on those variables, see the GNU
    `make` manual.'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: GNU `make`还会向子进程环境中添加一些变量，特别是`MAKEFLAGS`、`MFLAGS`和`MAKELEVEL`。`MAKEFLAGS`和`MFLAGS`变量包含命令行上指定的标志：`MAKEFLAGS`包含用于GNU
    `make`内部使用的格式化标志，而`MFLAGS`仅用于历史原因。在配方中不要使用`MAKEFLAGS`。如果确实需要，可以设置`MFLAGS`。`MAKELEVEL`变量包含递归`make`调用的深度，使用`$(MAKE)`，从零开始。有关这些变量的更多细节，请参阅GNU
    `make`手册。
- en: You can also ensure that every makefile variable gets exported, either by writing
    `export` on a line on its own or by specifying `.EXPORT_ALL_VARIABLES:`. But these
    shotgun approaches are probably a bad idea, because they fill the subprocess environment
    with useless—and perhaps harmful—variables.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以通过单独写一行`export`或指定`.EXPORT_ALL_VARIABLES:`来确保每个makefile变量都会被导出。但这些“扫射式”的方法可能不好，因为它们会把一些无用的—甚至可能有害的—变量填充到子进程环境中。
- en: The $(shell) Environment
  id: totrans-71
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: $(shell)环境
- en: 'You might expect that the environment used by a call to `$(shell)` would be
    the same as that used in the execution of a rule’s commands. In fact, it’s not.
    The environment used by `$(shell)` is exactly the same as the environment when
    GNU `make` was started, with nothing added or removed. You can verify this with
    the following makefile that gets the value of `FOO` from within a `$(shell)` call
    and a rule:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会期望`$(shell)`调用所使用的环境与规则命令执行时所使用的环境相同。事实上，并不是这样的。`$(shell)`使用的环境与GNU `make`启动时的环境完全相同，没有任何变化。你可以通过以下
    makefile 来验证这一点，该 makefile 从`$(shell)`调用和规则中获取`FOO`的值：
- en: '[PRE20]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'That outputs:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 这会输出：
- en: '[PRE21]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: No matter what you do, `$(shell)` gets the parent environment.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 无论你做什么，`$(shell)`都会获取父环境。
- en: 'This is a bug in GNU `make` (bug #10593—see *[http://savannah.gnu.org/bugs/?10593](http://savannah.gnu.org/bugs/?10593)*
    for details). Part of the reason this hasn’t been fixed is that the obvious solution—just
    using the rule environment in `$(shell)`—has a rather nasty consequence. Consider
    this makefile:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: '这是GNU `make`中的一个错误（错误 #10593——详情请见 *[http://savannah.gnu.org/bugs/?10593](http://savannah.gnu.org/bugs/?10593)*）。之所以没有修复的部分原因是，显而易见的解决方案——在`$(shell)`中使用规则环境——会带来一个相当糟糕的后果。考虑这个
    makefile：'
- en: '[PRE22]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: What’s the value of `FOO` in the rule for `all`? To get the value of `FOO` in
    the environment for `all`, the `$(shell)` has to be expanded, which requires getting
    the value of `FOO`—which requires expanding the `$(shell)` call, and so on, *ad
    infinitum*.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: '`all`规则中`FOO`的值是多少？要获取`all`环境中的`FOO`的值，必须展开`$(shell)`，这就需要获取`FOO`的值——这又需要展开`$(shell)`调用，依此类推，*无止境*。'
- en: 'In the face of this problem, GNU `make`’s developers opted for the easy way
    out: they just haven’t fixed the bug.'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 面对这个问题，GNU `make`的开发者选择了简单的解决方法：他们根本没有修复这个错误。
- en: 'Given that this bug isn’t going away for the moment, a workaround is necessary.
    Luckily, most decent shells have a way to set an environment variable inline.
    So the first makefile in this section can be changed to:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 鉴于这个错误目前不会消失，因此需要一个解决方法。幸运的是，大多数合适的 shell 都有一种方法可以内联设置环境变量。所以这一节中的第一个 makefile
    可以改成：
- en: '[PRE23]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'This obtains the desired result:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 这将得到期望的结果：
- en: '[PRE24]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: It works by setting the value of `FOO` within the shell used by the `$(shell)`
    function, using the `FOO=$(FOO)` syntax. Because the argument to `$(shell)` gets
    expanded before execution, that becomes `FOO=bar`, taking its value from the value
    of `FOO` set in the makefile.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 它通过在`$(shell)`函数使用的 shell 中设置`FOO`的值，采用`FOO=$(FOO)`语法来实现。因为`$(shell)`的参数在执行前就会展开，所以变成了`FOO=bar`，其值来自于
    makefile 中设置的`FOO`的值。
- en: The technique works fine if just one extra variable is needed in the environment.
    But if many are needed, it can be a bit problematic, because setting multiple
    shell variables on a single command line becomes messy.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 如果只需要一个额外的变量在环境中，这种方法效果很好。但如果需要很多变量，就有点麻烦了，因为在一行命令中设置多个 shell 变量会变得混乱。
- en: 'A more comprehensive solution is to write a replacement for the `$(shell)`
    command that *does* export variables. Here’s a function, `env_shell`, which does
    just that:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 一个更全面的解决方案是编写一个替代`$(shell)`命令的脚本，该命令*确实*导出变量。以下是一个函数`env_shell`，它正是做了这件事：
- en: '[PRE25]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Before I explain how this works, here’s how to use it in the previous makefile.
    All you need to do is to change `$(shell)` to `$(call env_shell)`. The first argument
    of `env_shell` is the list of variables that you need to add to the environment,
    whereas the second argument is the command to be executed. Here’s the updated
    makefile with `FOO` exported:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 在我解释它是如何工作的之前，这里是如何在之前的 makefile 中使用它的方法。你只需将`$(shell)`更改为`$(call env_shell)`。`env_shell`的第一个参数是需要添加到环境中的变量列表，而第二个参数是要执行的命令。以下是更新后的
    makefile，其中`FOO`已被导出：
- en: '[PRE26]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'When you run this you’ll see the output:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 当你运行这个时，你将看到如下输出：
- en: '[PRE27]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Now back to how `env_shell` works. First, it creates a shell script that adds
    all the variables from its first argument to the environment; then, it executes
    the command from its second argument. By default the shell script is stored in
    the file named in the `env_file` variable (which was set to */tmp/env* earlier).
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 现在回到`env_shell`是如何工作的。首先，它创建一个 shell 脚本，将其第一个参数中的所有变量添加到环境中；然后，它执行第二个参数中的命令。默认情况下，shell
    脚本存储在`env_file`变量指定的文件中（该变量之前设置为*/tmp/env*）。
- en: '*/tmp/env* ends up containing'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: '*/tmp/env* 最终包含：'
- en: '[PRE28]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'We can break down the call to `env_shell` into four parts:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将对`env_shell`的调用分解为四个部分：
- en: It deletes */tmp/env* with `$(shell rm -f $(env_file))`.
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它通过`$(shell rm -f $(env_file))`删除*/tmp/env*。
- en: It adds lines containing the definition of each of the variables named in the
    first argument (`$1`) with the loop `$(foreach V,$1,$(shell echo export $V=$($V)
    >> $(env_file)))`.
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它通过循环`$(foreach V,$1,$(shell echo export $V=$($V) >> $(env_file)))`添加包含每个变量定义的行，这些变量在第一个参数（`$1`）中指定。
- en: It appends the actual command to execute, which is in the second argument (`$2`),
    with `$(shell echo '$2' >> $(env_file))`.
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它将实际的执行命令（位于第二个参数`$2`中）附加到`$(shell echo '$2' >> $(env_file))`。
- en: 'It runs */tmp/env* with a call to `shell` using the `-e` option: `$(shell /bin/bash
    -e $(env_file))`.'
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它使用`-e`选项通过调用`shell`来运行*/tmp/env*：`$(shell /bin/bash -e $(env_file))`。
- en: It’s not a perfect solution; it would be nice if GNU `make` just figured out
    what should be in the environment. But it’s a workable solution until GNU `make`’s
    coders fix the bug.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 这不是一个完美的解决方案；如果GNU `make`能自动决定应该放入环境中的内容，那就太好了。但这是一个可行的解决方案，直到GNU `make`的开发者修复这个bug。
- en: Target-Specific and Pattern-Specific Variables
  id: totrans-102
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 目标特定变量和模式特定变量
- en: Every GNU `make` user is familiar with GNU `make` variables. And all GNU `make`
    users know that variables essentially have global scope. Once they are defined
    in a makefile, they can be used anywhere in the makefile. But how many GNU `make`
    users are familiar with GNU `make`’s locally scoped target-specific and pattern-specific
    variables? This section introduces target- and pattern-specific variables, and
    shows how they can be used to selectively alter options within a build based on
    the name of a target or targets being built.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 每个GNU `make`用户都熟悉GNU `make`的变量。所有GNU `make`用户都知道，变量本质上具有全局作用域。一旦它们在makefile中定义，就可以在makefile的任何地方使用。但有多少GNU
    `make`用户熟悉GNU `make`的局部作用域目标特定变量和模式特定变量呢？本节介绍了目标特定变量和模式特定变量，并展示了如何根据目标的名称或构建的目标来选择性地更改构建过程中的选项。
- en: Target-Specific Variables
  id: totrans-104
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 目标特定变量
- en: '[Example 1-1](ch01.html#example_makefile_with_four_phony_targets "Example 1-1. An
    example makefile with four phony targets") shows a simple example makefile that
    illustrates the difference between global and local scope in GNU `make`:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例1-1](ch01.html#example_makefile_with_four_phony_targets "示例1-1. 一个包含四个虚拟目标的makefile示例")展示了一个简单的makefile示例，说明了GNU
    `make`中全局作用域和局部作用域之间的区别：'
- en: Example 1-1. An example makefile with four phony targets
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 示例1-1。一个包含四个虚拟目标的makefile示例
- en: '[PRE29]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'This makefile has four targets: `all`, `foo`, `bar`, and `baz`. All four targets
    are phony; because we’re interested only in illustrating global and local scope
    for now, this makefile doesn’t actually make any files.'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 该makefile有四个目标：`all`，`foo`，`bar`和`baz`。所有四个目标都是虚拟的；因为我们现在仅关注展示全局和局部作用域，这个makefile实际上并不生成任何文件。
- en: The `all` target requires that `foo` and `bar` be built, whereas `bar` depends
    on `baz`. The commands for each target do the same thing—they print the value
    of variable `VAR` using a shell `echo`.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: '`all`目标要求构建`foo`和`bar`，而`bar`依赖于`baz`。每个目标的命令做的事情相同——它们使用`shell echo`打印变量`VAR`的值。'
- en: The `VAR` variable is initially defined at ➊ to have the value `global scope`.
    That’s the value `VAR` will have anywhere in the makefile—unless, of course, that
    value is overridden using a target- or pattern-specific variable.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: '`VAR`变量最初在➊处定义为`global scope`。这是`VAR`在makefile中任何地方的值——除非，当然，这个值被目标特定或模式特定变量覆盖。'
- en: 'To illustrate local scope, `VAR` is redefined to `local scope` at ➋ for the
    rule that creates `bar`. A target-specific variable definition is exactly like
    a normal variable definition: it uses the same `=`, `:=`, `+=`, and `?=` operators,
    but it is preceded by the name of the target (and its colon) for which the variable
    should be defined.'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 为了说明局部作用域，`VAR`在➋处被重新定义为`local scope`，用于创建`bar`的规则。目标特定变量的定义与普通变量的定义完全相同：它使用相同的`=`,`:=`，`+=`，和`?=`操作符，但它前面会加上目标名称（及其冒号），用于定义该目标的变量。
- en: If you run GNU `make` on this makefile, you’ll get the output shown in [Example 1-2](ch01.html#output_from_listing_1-1_showing_globally
    "Example 1-2. Output from Example 1-1 showing globally and locally scoped variables").
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在这个makefile上运行GNU `make`，你将看到[示例1-2](ch01.html#output_from_listing_1-1_showing_globally
    "示例1-2. 从示例1-1输出的全局和局部作用域变量")所示的输出。
- en: Example 1-2. Output from [Example 1-1](ch01.html#example_makefile_with_four_phony_targets
    "Example 1-1. An example makefile with four phony targets") showing globally and
    locally scoped variables
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 示例1-2。来自[示例1-1](ch01.html#example_makefile_with_four_phony_targets "示例1-1. 一个包含四个虚拟目标的makefile示例")的输出，显示了全局和局部作用域变量
- en: '[PRE30]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: You can clearly see that GNU `make` follows its standard depth-first, left-to-right
    search pattern. First it builds `foo`, because it’s the first prerequisite of
    `all`. Then it builds `baz`, which is a prerequisite of `bar`, the second prerequisite
    of `all`. Then it builds `bar` and, finally, `all`.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以清楚地看到，GNU `make`遵循其标准的深度优先、从左到右的搜索模式。首先它构建`foo`，因为它是`all`的第一个先决条件。然后构建`baz`，它是`bar`的先决条件，`all`的第二个先决条件。接着构建`bar`，最后构建`all`。
- en: Sure enough, within the rule for `bar` the value of `VAR` is `local scope`.
    And because there’s no local definition of `VAR` in either `all` or `foo`, `VAR`
    has the value `global scope` in those rules.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 果然，在`bar`的规则中，`VAR`的值是`local scope`。因为在`all`或`foo`中没有`VAR`的局部定义，所以在这些规则中，`VAR`的值是`global
    scope`。
- en: But what about `baz`? The makefile output shows that the value of `VAR` in `baz`
    is `local scope`, yet there was no explicit target-specific definition of `VAR`
    for `baz`. This is because `baz` is a prerequisite of `bar` and so has the same
    locally scoped variables as `bar`.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 那`baz`怎么办呢？makefile的输出显示`baz`中的`VAR`值为`local scope`，但实际上并没有为`baz`显式地定义针对特定目标的`VAR`。这是因为`baz`是`bar`的先决条件，因此它具有与`bar`相同的局部作用域变量。
- en: Target-specific variables apply not just to a target, but also to all that target’s
    prerequisites, as well as all *their* prerequisites, and so on. A target-specific
    variable’s scope is the entire tree of targets, starting from the target for which
    the variable was defined.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 针对特定目标的变量不仅适用于目标本身，还适用于该目标的所有先决条件，以及所有*它们*的先决条件，依此类推。针对特定目标的变量作用域是整个目标树，从定义该变量的目标开始。
- en: 'Note that because `all`, `foo`, `bar`, and `baz` have exactly the same recipe,
    it’s possible to write them all on a single line, as shown here:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，由于`all`、`foo`、`bar`和`baz`的配方完全相同，因此可以将它们写在一行上，如下所示：
- en: '[PRE31]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: But in this section, I’ve avoided having multiple targets because this sometimes
    causes confusion (many GNU `make` users think that this line represents a single
    rule that would run once for `all`, `foo`, `bar`, and `baz`, but it is actually
    four separate rules).
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 但在这一节中，我避免了使用多个目标，因为这有时会引起混淆（许多GNU `make`用户认为这一行代表一个单一规则，将同时为`all`、`foo`、`bar`和`baz`执行，但实际上它是四个独立的规则）。
- en: Pattern-Specific Variables
  id: totrans-122
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 特定模式变量
- en: 'Pattern-specific variables work in a manner similar to target-specific variables.
    But instead of being defined for a target, they are defined for a pattern and
    are applied to all targets that match that pattern. The following example is similar
    to [Example 1-1](ch01.html#example_makefile_with_four_phony_targets "Example 1-1. An
    example makefile with four phony targets") but has been modified to include a
    pattern-specific variable:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 特定模式的变量工作方式与针对特定目标的变量类似。不过，它们不是为某个目标定义的，而是为某个模式定义的，并应用于所有匹配该模式的目标。以下示例类似于[示例
    1-1](ch01.html#example_makefile_with_four_phony_targets "示例 1-1：一个包含四个虚拟目标的示例makefile")，但已修改为包含特定模式的变量：
- en: '[PRE32]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: The last line ➊ sets `VAR` to the value `starts with f` for any target beginning
    with `f` and followed by anything else (that’s the `%` wildcard). (It is also
    possible to use multiple targets to accomplish this. But don’t worry about that
    for now.)
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一行 ➊ 将`VAR`的值设置为`starts with f`，适用于任何以`f`开头并跟着其他任何内容的目标（即`%`通配符）。(也可以使用多个目标来实现这一点，但现在先不讨论这个。)
- en: 'Now if you run `make`, you get the following output:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果你运行`make`，你会看到如下输出：
- en: '[PRE33]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: This is the same as in [Example 1-2](ch01.html#output_from_listing_1-1_showing_globally
    "Example 1-2. Output from Example 1-1 showing globally and locally scoped variables"),
    except that in the rule for `foo` the value of `VAR` has been set to `starts with
    f` by the pattern-specific definition.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 这与[示例 1-2](ch01.html#output_from_listing_1-1_showing_globally "示例 1-2：示例 1-1
    的输出，显示全局和局部作用域的变量")是相同的，只是`foo`规则中`VAR`的值已通过特定模式的定义设置为`starts with f`。
- en: It’s worth noting that this is unrelated to GNU `make` pattern rules. You can
    use the pattern-specific variable definition to change the value of a variable
    in a normal rule. You can also use it with a pattern rule.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 值得注意的是，这与GNU `make`的模式规则无关。你可以使用特定模式的变量定义来更改常规规则中变量的值。你也可以在模式规则中使用它。
- en: 'For example, imagine that a makefile uses the built-in `%.o: %.c` pattern rule:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: '例如，假设一个makefile使用内建的`%.o: %.c`模式规则：'
- en: '[PRE34]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'It would be possible to set a variable on every `.o` file that rule builds
    using a pattern-specific variable. Here’s how to add the `-g` option to `CFLAGS`
    for every `.o` file:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用特定模式的变量为每个该规则构建的`.o`文件设置一个变量。下面是如何为每个`.o`文件将`-g`选项添加到`CFLAGS`中的方法：
- en: '[PRE35]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'It’s not uncommon in a project to have a standard rule for compiling files
    and to need a slightly different version of that rule for a specific file, or
    set of files, that otherwise use the same command. For example, here’s a makefile
    that builds all the `.c` files in two subdirectories (`lib1` and `lib2`) using
    a pattern rule:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 在一个项目中，通常会有一个标准的规则来编译文件，而对于某些特定的文件或文件集合，可能需要稍微不同版本的规则，尽管这些文件最终使用的是相同的命令。例如，以下是一个
    makefile，它使用模式规则构建两个子目录（`lib1` 和 `lib2`）中的所有 `.c` 文件：
- en: '[PRE36]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'First, the makefile gets the list of all `.c` files in *lib1/* into the variable
    `lib1_SRCS`, and the C files in *lib2/* into `lib2_SRCS`. Then it converts these
    to lists of object files using a substitution reference that changes `.c` to `.o`
    and stores the results in `lib1_OBJS` and `lib2_OBJS`. The pattern rule in the
    last line ➊ uses the GNU `make` built-in variable `COMPILE.C` to run a compiler
    that compiles a `.c` file into a `.o` file. The makefile builds all the objects
    in `lib1_OBJS` and `lib2_OBJS` because they are prerequisites of `all`. Both `lib1_OBJS`
    and `lib2_OBJS` contain a list of `.o` files corresponding to `.c` files. When
    GNU `make` searches for the `.o` files (the prerequisites of `all`), it finds
    that they are missing but that it can use the `%.o: %.c` rule to build then.'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: '首先，makefile 会将*lib1/*下所有的 `.c` 文件列出并存入 `lib1_SRCS` 变量，将*lib2/*下的 C 文件列出并存入
    `lib2_SRCS`。然后，它使用替换引用将这些文件转换为目标文件列表，将 `.c` 文件转换为 `.o` 文件，并将结果存储在 `lib1_OBJS`
    和 `lib2_OBJS` 中。最后一行的模式规则 ➊ 使用了 GNU `make` 的内建变量 `COMPILE.C` 来运行编译器，将 `.c` 文件编译成
    `.o` 文件。makefile 会构建 `lib1_OBJS` 和 `lib2_OBJS` 中的所有目标文件，因为它们是 `all` 的前提条件。`lib1_OBJS`
    和 `lib2_OBJS` 都包含了对应 `.c` 文件的 `.o` 文件列表。当 GNU `make` 搜索 `.o` 文件（即 `all` 的前提条件）时，它发现这些文件缺失，但可以使用
    `%.o: %.c` 规则来构建它们。'
- en: This works fine if all the `.c` files have the same compilation options. But
    now suppose that the `.c` file *lib1/special.c* requires the `-Wcomment` option
    to prevent the compiler from warning about an oddly written comment. Obviously,
    it would be possible to change the value of `CPPFLAGS` globally by adding the
    line `CPPFLAGS += -Wcomment` to the makefile. But this change would affect *every*
    compilation, which is probably not what you want.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 如果所有的 `.c` 文件使用相同的编译选项，这样做是没问题的。但假设 `.c` 文件*lib1/special.c*需要 `-Wcomment` 选项来防止编译器因注释书写不规范而发出警告。显然，可以通过在
    makefile 中添加 `CPPFLAGS += -Wcomment` 这一行来全局更改 `CPPFLAGS` 的值。但是，这样的修改会影响*每个*编译过程，这可能并不是你想要的效果。
- en: 'Fortunately, you can use a target-specific variable to just alter the value
    of `CPPFLAGS` for that single file, like so:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，你可以使用目标特定变量仅为该单个文件更改 `CPPFLAGS` 的值，如下所示：
- en: '[PRE37]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: The line alters the value of `CPPFLAGS` just for the creation of *lib1/special.o*.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 这一行会只在创建*lib1/special.o*时更改 `CPPFLAGS` 的值。
- en: 'Now suppose that an entire subdirectory requires a special `CPPFLAGS` option
    to maximize optimization for speed (the `-fast` option to `gcc`, for example).
    Here, a pattern-specific variable definition is ideal:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 假设一个子目录需要一个特殊的 `CPPFLAGS` 选项来最大化速度优化（例如 `gcc` 的 `-fast` 选项）。在这种情况下，使用特定模式的变量定义是最理想的：
- en: '[PRE38]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: This does the trick. Any `.o` files that are built in *lib1/* will be built
    using the `-fast` command line option.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 这样就能解决问题。所有在*lib1/*下构建的 `.o` 文件都将使用 `-fast` 命令行选项来编译。
- en: Version Checking
  id: totrans-144
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 版本检查
- en: 'Because GNU `make` is regularly updated and new features are added all the
    time, it’s important to know the version of GNU `make` that’s running or whether
    a specific GNU `make` feature is available. You can do this in two ways: either
    look at the `MAKE_VERSION` variable or look in the `.FEATURES` variable (added
    in GNU `make` 3.81). It’s also possible to check for specific features, like `$(eval)`.'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 因为 GNU `make` 经常更新并不断添加新特性，了解当前运行的 GNU `make` 版本或是否支持某些特定功能非常重要。你可以通过两种方式来做到这一点：要么查看
    `MAKE_VERSION` 变量，要么查看 `.FEATURES` 变量（该变量在 GNU `make` 3.81 版本中添加）。你也可以检查特定的功能，比如
    `$(eval)`。
- en: MAKE_VERSION
  id: totrans-146
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: MAKE_VERSION
- en: 'The `MAKE_VERSION` variable contains the version number of GNU `make` that’s
    processing the makefile where `MAKE_VERSION` is referenced. Here’s an example
    makefile that prints the version of GNU `make` and stops:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: '`MAKE_VERSION` 变量包含正在处理该 makefile 的 GNU `make` 版本号。在这里是一个示例 makefile，它打印出 GNU
    `make` 的版本并停止执行：'
- en: '[PRE39]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'And here’s the output generated when GNU `make` 3.80 parses this makefile:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是当 GNU `make` 3.80 解析这个 makefile 时生成的输出：
- en: '[PRE40]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: What if you want to determine that version 3.80 or later of GNU `make` is handling
    your makefile? If you assume the version number is always in the form `X.YY.Z`
    or `X.YY`, the following code fragment will set the `ok` variable to non-empty
    if the version mentioned in `need` is equal to or less than the running version
    of GNU `make`.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想确定 GNU `make` 版本 3.80 或更高版本正在处理你的 Makefile，怎么办？如果假设版本号始终为 `X.YY.Z` 或 `X.YY`
    形式，那么以下代码片段将在 `need` 中提到的版本小于或等于运行版本时，将 `ok` 变量设置为非空。
- en: '[PRE41]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: If `ok` is not blank, the required version of GNU `make` or later is being used;
    if it’s blank, the version is too old. The code fragment works by creating a space-separated
    list of the running version of GNU `make` in `MAKE_VERSION` and the required version
    (from `need`), and sorting that list. Suppose the running version is 3.81\. Then
    `$(sort $(MAKE_VERSION) $(need))` will be `3.80 3.81`. The `$(firstword)` of that
    is `3.80`, so the `$(filter)` call will keep `3.80`. Thus, `ok` will be non-empty.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 `ok` 不为空，则表示正在使用所需版本的 GNU `make` 或更高版本；如果为空，则表示版本过旧。该代码片段通过创建一个以空格分隔的 GNU
    `make` 运行版本列表（存储在 `MAKE_VERSION` 中）和所需版本（来自 `need`）来工作，并对该列表进行排序。假设运行的版本是 3.81，那么
    `$(sort $(MAKE_VERSION) $(need))` 将是 `3.80 3.81`。该列表的 `$(firstword)` 是 `3.80`，因此
    `$(filter)` 调用将保留 `3.80`，从而 `ok` 变量将非空。
- en: Now suppose the running version is 3.79.1\. Then `$(sort $(MAKE_VERSION) $(need))`
    will be `3.79.1 3.80`, and `$(firstword)` will return `3.79.1`. The `$(filter)`
    call will remove `3.79.1` and thus `ok` will be empty.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 现在假设运行版本是 3.79.1，那么 `$(sort $(MAKE_VERSION) $(need))` 将是 `3.79.1 3.80`，`$(firstword)`
    将返回 `3.79.1`。`$(filter)` 调用将移除 `3.79.1`，因此 `ok` 将为空。
- en: Note
  id: totrans-155
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '*This fragment won’t work correctly with versions of GNU `make` starting at
    10.01, because it assumes a single-digit major version number. Fortunately, that’s
    a long way off!*'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: '*此代码片段在 GNU `make` 版本从 10.01 开始时将无法正确工作，因为它假设主版本号为单数位数。幸运的是，这还需要很长时间！*'
- en: .FEATURES
  id: totrans-157
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: .FEATURES
- en: 'GNU `make` 3.81 introduced the `.FEATURES` default variable, which contains
    a list of supported features. In GNU `make` 3.81, seven features are listed and
    supported in `.FEATURES`:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: GNU `make` 3.81 引入了 `.FEATURES` 默认变量，该变量包含一个支持特性的列表。在 GNU `make` 3.81 中，`.FEATURES`
    列出了并支持七个特性：
- en: '****`archives`****. Archive (`ar`) files using the `archive(member)` syntax'
  id: totrans-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '****`archives`****。使用 `archive(member)` 语法归档（`ar`）文件'
- en: '****`check-symlink`****. The `-L` and `--check-symlink-times` flags'
  id: totrans-160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '****`check-symlink`****。`-L` 和 `--check-symlink-times` 标志'
- en: '****`else-if`****. Else branches in the non-nested form `else if X`'
  id: totrans-161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '****`else-if`****。非嵌套形式 `else if X` 的 else 分支'
- en: '****`jobserver`****. Building in parallel using the job server'
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '****`jobserver`****。使用作业服务器并行构建'
- en: '****`order-only`****. `order-only` prerequisite support'
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '****`order-only`****。`order-only` 先决条件支持'
- en: '****`second-expansion`****. Double expansion of prerequisite lists'
  id: totrans-164
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '****`second-expansion`****。先决条件列表的双重展开'
- en: '****`target-specific`****. Target-specific and pattern-specific variables'
  id: totrans-165
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '****`target-specific`****。目标特定和模式特定变量'
- en: 'GNU `make` 3.82 adds and supports the following:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: GNU `make` 3.82 添加并支持以下内容：
- en: '****`oneshell`****. The `.ONESHELL` special target'
  id: totrans-167
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '****`oneshell`****。`.ONESHELL` 特殊目标'
- en: '****`shortest-stem`****. Using the shortest stem option when choosing between
    pattern rules that match a target'
  id: totrans-168
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '****`shortest-stem`****。在选择匹配目标的模式规则时使用最短的词干选项'
- en: '****`undefine`****. The `undefine` directive'
  id: totrans-169
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '****`undefine`****。`undefine` 指令'
- en: 'And GNU `make` 4.0 adds the following:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 并且 GNU `make` 4.0 添加了以下内容：
- en: '****`guile`****. If GNU `make` was built with GNU Guile support, this will
    be present and the `$(guile)` function will be supported.'
  id: totrans-171
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '****`guile`****。如果 GNU `make` 是在支持 GNU Guile 的环境下构建的，那么该功能将会存在，并且 `$(guile)`
    函数将被支持。'
- en: '****`load`****. The ability to load dynamic objects to enhance the capabilities
    of GNU `make` is supported.'
  id: totrans-172
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '****`load`****。支持加载动态对象以增强 GNU `make` 功能。'
- en: '****`output-sync`****. The `-O` (and `--``output-sync`) command line options
    are supported.'
  id: totrans-173
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '****`output-sync`****。支持 `-O`（和 `--output-sync`）命令行选项。'
- en: 'You can find more details on these and many other features in [Recent GNU make
    Versions: 3.81, 3.82, and 4.0](ch01.html#recent_gnu_make_versions_3dot81comma_3do
    "Recent GNU make Versions: 3.81, 3.82, and 4.0").'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在 [近期的 GNU make 版本：3.81，3.82 和 4.0](ch01.html#recent_gnu_make_versions_3dot81comma_3do
    "近期的 GNU make 版本：3.81，3.82 和 4.0") 中找到更多关于这些以及其他许多特性的详细信息。
- en: 'To check if a specific feature is available, you can use the following `is_feature`
    function: it returns `T` if the requested feature is supported or an empty string
    if the feature is missing:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 若要检查是否有特定功能可用，可以使用以下 `is_feature` 函数：如果请求的功能受支持，则返回 `T`，如果功能缺失，则返回空字符串：
- en: '[PRE42]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'For example, the following makefile uses `is_feature` to echo whether the `archives`
    feature is available:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，下面的makefile使用`is_feature`来回显`archives`特性是否可用：
- en: '[PRE43]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'And here’s the output using GNU `make` 3.81:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是使用GNU `make` 3.81时的输出：
- en: '[PRE44]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'If you want to check whether the `.FEATURES` variable is even supported, either
    use `MAKE_VERSION` as described in [MAKE_VERSION](ch01.html#makeunderscoreversion
    "MAKE_VERSION") or simply expand `.FEATURES` and see whether it’s empty. The following
    makefile fragment does just this, setting `has_features` to `T` (for true) if
    the `.FEATURES` variable is present and contains any features:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想检查`.FEATURES`变量是否被支持，可以使用如[MAKE_VERSION](ch01.html#makeunderscoreversion
    "MAKE_VERSION")中所述的`MAKE_VERSION`，或者简单地展开`.FEATURES`并查看其是否为空。以下的makefile片段正是执行这一操作，如果`.FEATURES`变量存在并且包含任何特性，则将`has_features`设置为`T`（代表true）：
- en: '[PRE45]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: The fragment first uses `$(origin)` to check that the `.FEATURES` variable is
    a default variable; this way, `has_features` is not fooled if someone has defined
    `.FEATURES` in the makefile. If it is a default variable, the second `$(if)` checks
    whether or not `.FEATURES` is blank.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 该片段首先使用`$(origin)`来检查`.FEATURES`变量是否是默认变量；这样，如果有人在makefile中定义了`.FEATURES`，`has_features`就不会被误导。如果它是默认变量，第二个`$(if)`会检查`.FEATURES`是否为空。
- en: Detecting $(eval)
  id: totrans-184
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 检测`$(eval)`
- en: The `$(eval)` function is a powerful GNU `make` feature that was added in version
    3.80\. The argument to `$(eval)` is expanded and then parsed as if it were part
    of the makefile, allowing you to modify the makefile at runtime.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: '`$(eval)`函数是一个强大的GNU `make`特性，新增于版本3.80。`$(eval)`的参数会被展开，然后解析，仿佛它是makefile的一部分，从而允许你在运行时修改makefile。'
- en: 'If you use `$(eval)`, it is important to check that the feature is available
    in the version of GNU `make` reading your makefile. You could use `MAKE_VERSION`
    as described earlier to check for version 3.80\. Alternatively, you could use
    the following fragment of code that sets `eval_available` to `T` only if `$(eval)`
    is implemented:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你使用`$(eval)`，那么重要的是要检查该特性是否在读取你的makefile的GNU `make`版本中可用。你可以使用前面提到的`MAKE_VERSION`来检查版本是否为3.80。或者，你也可以使用以下代码片段，这段代码只有在`$(eval)`被实现时才会将`eval_available`设置为`T`：
- en: '[PRE46]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: If `$(eval)` is not available, GNU `make` will look for a variable called `eval
    eval_available := T` and try to get its value. This variable doesn’t exist, of
    course, so `eval_available` will be set to the empty string.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`$(eval)`不可用，GNU `make`将寻找一个名为`eval eval_available := T`的变量并尝试获取其值。当然，这个变量并不存在，因此`eval_available`将被设置为空字符串。
- en: You can use `eval_available` with `ifneq` to generate a fatal error if `$(eval)`
    isn’t implemented.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用`eval_available`配合`ifneq`来生成一个致命错误，如果`$(eval)`没有被实现的话。
- en: '[PRE47]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: The `eval_available` function is especially useful if you can’t check `MAKE_VERSION`—if,
    for example, your makefile is being run using a non-GNU `make` tool, such as `clearmake`
    or `emake`.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: '`eval_available`函数特别有用，如果你无法检查`MAKE_VERSION`，例如，如果你的makefile是通过非GNU的`make`工具运行的，如`clearmake`或`emake`。'
- en: Using Boolean Values
  id: totrans-192
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用布尔值
- en: Both GNU `make`’s `$(if)` function and `ifdef` construct treat the empty string
    and undefined variables as false, and anything else as true. But they differ subtly
    in how they evaluate their arguments.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: GNU `make`的`$(if)`函数和`ifdef`构造都将空字符串和未定义的变量视为false，其他任何内容视为true。但它们在评估参数时有细微的不同。
- en: 'The `$(if)` function—that is, `$(if` *`X`*`,`*`if-part`*`,`*`else-part`*`)`—expands
    *`if-part`* if *`X`* is not empty and *`else-part`* otherwise. When using `$(if)`,
    the condition is expanded and the value *after expansion* is tested for emptiness.
    The following code fragment reports that it took the *`else-part`* branch:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: '`$(if)`函数，也就是`$(if` *`X`*`,`*`if-part`*`,`*`else-part`*`)`，会在*`X`*不为空时展开*`if-part`*，否则展开*`else-part`*。在使用`$(if)`时，条件会被展开，并且*展开后的值*会被测试是否为空。以下代码片段报告了它走了*`else-part`*分支：'
- en: '[PRE48]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: Whereas the next fragment follows the *`if-part`* branch, because `HAS_A_VALUE`
    has a non-empty value.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 而接下来的片段则走了*`if-part`*分支，因为`HAS_A_VALUE`具有非空的值。
- en: '[PRE49]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'The `ifdef` construct works slightly differently: its argument is the *name*
    of a variable and is not expanded:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: '`ifdef`构造的工作方式略有不同：它的参数是一个变量的*名称*，并不会进行展开：'
- en: '[PRE50]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: The preceding example executes *`if-part`* if the variable `VAR` is non-empty
    and *`else-part`* if `VAR` is empty or undefined.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 上述示例会在变量`VAR`不为空时执行*`if-part`*，而在`VAR`为空或未定义时执行*`else-part`*。
- en: Undefined Variables in Conditionals
  id: totrans-201
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 条件中的未定义变量
- en: 'Because GNU `make` treats an undefined variable as simply empty, `ifdef` should
    really be called `ifempty`—especially because it treats a defined-but-empty variable
    as undefined. For example, the following fragment reports that `VAR` is undefined:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 因为GNU `make`将未定义的变量视为空值，`ifdef`实际上应该叫做`ifempty`——特别是因为它将已定义但为空的变量视为未定义。例如，以下代码片段报告`VAR`未定义：
- en: '[PRE51]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: In an actual makefile, this might not have been the intended result. You can
    ask for warnings of undefined variables with the `--warn-undefined-variables`
    command line option.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 在实际的makefile中，这可能不是预期的结果。你可以通过`--warn-undefined-variables`命令行选项来请求未定义变量的警告。
- en: 'One further nuance of `ifdef` is that it does not expand the variable `VAR`.
    It simply looks to see if it has been defined to a non-empty value. The following
    code reports that `VAR` is defined even though its value, when completely expanded,
    is an empty string:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: '`ifdef`的另一个细微差别是，它不会展开变量`VAR`。它只是检查`VAR`是否已被定义为非空值。以下代码片段报告`VAR`已定义，即使其完全展开后的值是空字符串：'
- en: '[PRE52]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'GNU `make` 3.81 introduced yet another wrinkle to `ifdef`: its argument is
    expanded so that the name of the variable being tested can be computed. This has
    no effect on conditionals, such as `ifdef VAR`, but allows you to write'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: GNU `make` 3.81版本为`ifdef`引入了另一个变化：它的参数会被展开，从而可以计算出被测试的变量名。这对条件语句，如`ifdef VAR`没有影响，但允许你编写如下代码：
- en: '[PRE53]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'This is exactly the same as:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 这与以下内容完全相同：
- en: '[PRE54]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: In both cases `VAR` is examined to see whether it is empty, exactly as described
    earlier, and in both output `VAR is defined`.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 在这两种情况下，`VAR`被检查是否为空，就像之前描述的那样，在两个输出中都会显示`VAR is defined`。
- en: Consistent Truth Values
  id: totrans-212
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 一致的真值
- en: 'GNU `make` treats any non-empty string as true. But if you work with truth
    values and `$(if)` a lot, it can be helpful to use just one consistent value for
    true. The following `make-truth` function turns any non-empty string into the
    value `T`:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: GNU `make`将任何非空字符串视为真。但如果你经常与真值和`$(if)`打交道，使用一个一致的真值可能会更方便。以下`make-truth`函数将任何非空字符串转为`T`：
- en: '[PRE55]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: Notice how we can drop the `else` part of the `$(if)`, because it’s empty. Throughout
    this book I’ll drop arguments that aren’t necessary rather than polluting makefiles
    with extraneous trailing commas. But there’s nothing to stop you from writing
    `$(if $1,T,)` if it makes you more comfortable.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们可以去掉`$(if)`中的`else`部分，因为它是空的。在本书中，我会省略那些不必要的参数，而不是用多余的尾随逗号污染makefile。但如果让你更舒服，你完全可以写`$(if
    $1,T,)`。
- en: 'All of the following `calls` to `make-truth` return `T`:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 以下所有对`make-truth`的`call`都会返回`T`：
- en: '[PRE56]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: Even ➊ returns `T`, because arguments to functions called using `$(call)` do
    not have any modifications made to them before being placed in `$1`, `$2`, and
    so on—not even the removal of leading or trailing space. So the second argument
    is a string with a single space in it, not the empty string.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 即使是➊也返回`T`，因为通过`$(call)`调用的函数的参数在放入`$1`、`$2`等变量之前，并不会进行任何修改——甚至不会去除首尾的空格。因此，第二个参数是一个包含单个空格的字符串，而不是空字符串。
- en: 'All the following return an empty string (for false):'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 以下所有代码都会返回空字符串（表示假）：
- en: '[PRE57]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'Look carefully at the difference between ➊ and ➋: whitespace in GNU `make`
    can be very significant!'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 仔细观察➊和➋之间的区别：GNU `make`中的空格可能非常重要！
- en: Logical Operations Using Boolean Values
  id: totrans-222
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用布尔值的逻辑操作
- en: GNU `make` had no built-in logical operators until version 3.81, when `$(or)`
    and `$(and)` were added. However, it’s easy to create user-defined functions that
    operate on Boolean values. These functions often use GNU `make`’s `$(if)` function
    to make decisions. `$(if)` treats any non-empty string as `'true'` and an empty
    string as `'false'`.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: GNU `make`在3.81版本之前没有内建的逻辑运算符，直到那个版本才加入了`$(or)`和`$(and)`。然而，创建操作布尔值的用户自定义函数非常容易。这些函数通常使用GNU
    `make`的`$(if)`函数来做决策。`$(if)`将任何非空字符串视为`'true'`，将空字符串视为`'false'`。
- en: User-Defined Logical Operators
  id: totrans-224
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 用户自定义逻辑运算符
- en: 'Let’s create a user-defined version of the simplest logical operator, `or`.
    If either parameter is true (that is, a non-empty string), the result should also
    be a non-empty string. We can achieve this by just concatenating the arguments:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一个用户自定义的最简单逻辑运算符`or`。如果任意一个参数为真（即非空字符串），结果也应该是非空字符串。我们可以通过简单地连接参数来实现这一点：
- en: '[PRE58]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'You can use the `make-truth` function in [Consistent Truth Values](ch01.html#consistent_truth_values
    "Consistent Truth Values") to clean up the result of the `or` so that it’s either
    `T` for true or an empty string for false:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在 [一致的布尔值](ch01.html#consistent_truth_values "一致的布尔值") 中使用 `make-truth` 函数来清理
    `or` 的结果，使其变为 `T`（真）或空字符串（假）：
- en: '[PRE59]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'Or for a more compact version you just can write:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，对于更简洁的版本，你只需要写：
- en: '[PRE60]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'All the following return `T`:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 以下所有的返回 `T`：
- en: '[PRE61]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'The only way to return false from `or` is to pass in two empty arguments:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 从 `or` 中返回假值的唯一方法是传入两个空的参数：
- en: '[PRE62]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'Defining `and` is a little more complex, requiring two calls to `$(if)`:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 定义 `and` 稍微复杂一些，需要两次调用 `$(if)`：
- en: '[PRE63]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: There’s no need to wrap this in `make-truth` because it always returns `T` if
    its arguments are non-empty and the empty string if either argument is empty.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 不需要将其包装在 `make-truth` 中，因为如果其参数非空，它总是返回 `T`，如果任一参数为空，则返回空字符串。
- en: 'Defining `not` is just a single `$(if)`:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 定义 `not` 只是一个简单的 `$(if)`：
- en: '[PRE64]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'With `and`, `or`, and `not` defined, you can quickly create other logical operators:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 在定义了 `and`、`or` 和 `not` 之后，你可以快速创建其他逻辑运算符：
- en: '[PRE65]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'These all also have simplified versions that just use `$(if)`:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 这些也有简化版本，只需要使用 `$(if)`：
- en: '[PRE66]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: As an exercise, try writing an `xnor` function!
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 作为练习，试着编写一个 `xnor` 函数！
- en: Built-in Logical Operators (GNU make 3.81 and Later)
  id: totrans-245
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 内建逻辑运算符（GNU make 3.81 及以后版本）
- en: GNU `make` 3.81 and later has built-in `and` and `or` functions that are faster
    than the versions defined earlier, so it’s preferable to use those whenever possible.
    You should test whether the `and` and `or` functions already exist and only define
    your own if they don’t.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: GNU `make` 3.81 及以后版本有内建的 `and` 和 `or` 函数，这些函数比之前定义的版本更快，因此在可能的情况下，最好使用这些内建函数。你应该测试
    `and` 和 `or` 函数是否已存在，只有在它们不存在时才定义你自己的版本。
- en: 'The easiest way to determine whether `and` and `or` are defined is to try using
    them:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 确定 `and` 和 `or` 是否已定义的最简单方法是尝试使用它们：
- en: '[PRE67]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: These variables will be `T` only if built-in `and` and `or` functions are present.
    In versions of GNU `make` prior to 3.81 (or in GNU `make`-emulating programs like
    `clearmake`), `have_native_and` and `have_native_or` will be empty because GNU
    `make` will not find functions called `and` or `or`, nor will it find variables
    called `and T`, `T`, or `or T`, `T`!
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 这些变量只有在内建的 `and` 和 `or` 函数存在时才会是 `T`。在 GNU `make` 3.81 之前的版本（或类似 `clearmake`
    的模拟程序）中，`have_native_and` 和 `have_native_or` 将为空，因为 GNU `make` 找不到名为 `and` 或 `or`
    的函数，也找不到名为 `and T`、`T` 或 `or T`、`T` 的变量！
- en: 'You can examine the results of these calls using `ifneq` and define your own
    functions only if necessary, like so:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用 `ifneq` 来检查这些调用的结果，并仅在必要时定义你自己的函数，像这样：
- en: '[PRE68]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: You may be concerned that you’ve written `$(call and,...)` and `$(call or,...)`
    everywhere, using `call` to invoke your own logic operators. Won’t you need to
    change all these to `$(and)` and `$(or)`—removing `call` to use the built-in operator?
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会担心，你已经在各处写了 `$(call and,...)` 和 `$(call or,...)`，用 `call` 来调用你自己的逻辑运算符。你是不是需要将它们全部改成
    `$(and)` 和 `$(or)`——去掉 `call` 来使用内建的运算符？
- en: 'That is not necessary. GNU `make` allows any built-in function to be called
    with the `call` keyword, so both `$(and...)` and `$(call and,...)` invoke the
    built-in operator. The opposite, however, is *not* true: it’s not possible to
    call the *user-defined* function `foo` by writing `$(foo arg1,arg2)`. You must
    write `$(call foo,arg1,arg2)`.'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 这是不必要的。GNU `make` 允许使用 `call` 关键字调用任何内建函数，因此 `$(and...)` 和 `$(call and,...)`
    都会调用内建运算符。然而，相反的情况 *并不* 成立：无法通过编写 `$(foo arg1,arg2)` 来调用 *用户定义* 的函数 `foo`。你必须写成
    `$(call foo,arg1,arg2)`。
- en: So defining your own `and` and `or` functions, and behaving gracefully in the
    presence of GNU `make` 3.81 or later, requires only the lines shown earlier to
    define `and` and `or`—no other changes are necessary.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，定义你自己的 `and` 和 `or` 函数，并在 GNU `make` 3.81 或更高版本下优雅地运行，只需要前面显示的几行来定义 `and`
    和 `or`——不需要其他更改。
- en: Note that there’s an important difference between the built-in functions and
    user-defined versions. The built-in versions will not evaluate both arguments
    if the first argument fully determines their truth value. For example, `$(and
    $a,$b)` doesn’t need to look at the value of `$b` if `$a` is false; `$(or $a,$b)`
    doesn’t need to look at the value of `$b` if `$a` is true.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，内建函数和用户定义的版本之间有一个重要区别。如果第一个参数完全决定了其真值，内建版本将不会评估第二个参数。例如，如果 `$a` 为假，则 `$(and
    $a,$b)` 不需要查看 `$b` 的值；如果 `$a` 为真，则 `$(or $a,$b)` 不需要查看 `$b` 的值。
- en: If you need that behavior, you can’t use the preceding user-defined versions
    because when you do a `$(call)` of a function, all the arguments are expanded.
    The alternative is to replace a `$(call and,X,Y)` with `$(if X,$(if Y,T))` and
    `$(call or,X,Y)` with `$(if X,T,$(if Y,T))`.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您需要这种行为，则不能使用前面的用户定义版本，因为在执行`$(call)`函数时，所有参数都会被展开。替代方案是将`$(call and,X,Y)`替换为`$(if
    X,$(if Y,T))`，将`$(call or,X,Y)`替换为`$(if X,T,$(if Y,T))`。
- en: Command Detection
  id: totrans-257
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 命令检测
- en: Sometimes it can be useful for a makefile to quickly return an error message
    if a specific piece of software is missing from the build system. For example,
    if the makefile needs the program `curl`, it can be helpful to determine at parse
    time, when the makefile is loaded by `make`, if `curl` is present on the system
    rather than waiting until partway through a build to discover that it’s not there.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，在makefile中快速返回错误信息，如果构建系统中缺少特定软件会非常有用。例如，如果makefile需要`curl`程序，在解析时（即make加载makefile时）检查系统中是否存在`curl`会比在构建过程中才发现它不存在更为有用。
- en: The simplest way to find out if a command is available is to use the `which`
    command inside a `$(shell)` call. This returns an empty string if the command
    is not found and the path to the command if it is, which works well with `make`’s
    *empty string means false, non-empty string means true* logic.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 查找命令是否可用的最简单方法是使用`which`命令，并将其放在`$(shell)`调用中。如果命令不存在，则返回空字符串；如果命令存在，则返回命令的路径，这与`make`的*空字符串表示假，非空字符串表示真*逻辑非常契合。
- en: 'So, for example, the following sets `HAVE_CURL` to a non-empty string if `curl`
    is present:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，以下代码在`curl`存在时将`HAVE_CURL`设置为非空字符串：
- en: '[PRE69]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'Then you can use `HAVE_CURL` to stop the build and output an error if `curl`
    is missing:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，您可以使用`HAVE_CURL`来停止构建并在`curl`缺失时输出错误：
- en: '[PRE70]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'The following `assert-command-present` function wraps this logic into a single
    handy function. Calling `assert-command-present` with the name of a command causes
    the build to immediately exit with an error if the command is missing. The following
    example uses `assert-command-present` to check for the presence of a `curl` and
    a command called `curly`:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 以下的`assert-command-present`函数将此逻辑封装为一个便捷的函数。调用`assert-command-present`并传入命令的名称，如果命令缺失，构建将立即退出并输出错误。以下示例使用`assert-command-present`检查`curl`和名为`curly`的命令是否存在：
- en: '[PRE71]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'Here’s what happens if you run this code on a system that has `curl` but no
    `curly`:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在一个有`curl`但没有`curly`的系统上运行这段代码，会发生以下情况：
- en: '[PRE72]'
  id: totrans-267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 'If a command is used only by certain build targets, it can be useful to only
    use `assert-command-present` for the relevant target. The following makefile will
    check for the existence of `curly` only if the `download` target will actually
    be used as part of the build:'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一个命令仅由某些构建目标使用，那么仅在相关目标下使用`assert-command-present`是有用的。以下的makefile将在`download`目标作为构建的一部分实际使用时，检查`curly`是否存在：
- en: '[PRE73]'
  id: totrans-269
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: 'The first line of the download target sets a target-specific variable called
    `_check` and exports it to the result of the call to `assert-command-present`.
    This causes the `$(call)` to happen only if `download` is actually used as part
    of the build, because the value of `_check` will get expanded when it is being
    prepared for insertion into the environment of the recipe. For example, `make
    all` will not check for the presence of `curly`:'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: '`download`目标的第一行设置了一个名为`_check`的目标特定变量，并将其导出为对`assert-command-present`调用的结果。这会导致`$(call)`仅在`download`作为构建的一部分时发生，因为当准备将其插入到配方的环境中时，`_check`的值会被展开。例如，`make
    all`不会检查`curly`是否存在：'
- en: '[PRE74]'
  id: totrans-271
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: Note that this makefile does define a variable called `_`, which you could access
    as `$(_)` or even `$_`. Using the underscore as a name is one way to indicate
    that the variable is just a placeholder, and its value should be ignored.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，这个makefile定义了一个名为`_`的变量，您可以通过`$(_)`甚至`$_`来访问它。使用下划线作为名称是一种表示该变量只是占位符，并且其值应该被忽略的方法。
- en: Delayed Variable Assignment
  id: totrans-273
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 延迟变量赋值
- en: 'GNU `make` offers two ways to define a variable: the simple `:=` operator and
    the recursive `=` operator. The simple operator `:=` evaluates its right side
    immediately and uses the resulting value to set the value of a variable. For example:'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: GNU `make`提供了两种定义变量的方式：简单的`:=`操作符和递归的`=`操作符。简单的`:=`操作符会立即评估右侧的值，并使用结果值来设置变量的值。例如：
- en: '[PRE75]'
  id: totrans-275
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: This snippet results in `FOO` having the value `before the rain`, because at
    the time `FOO` was set using `:=`, `BAR` had the value `before`.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 这个代码片段会导致`FOO`的值为`before the rain`，因为当使用`:=`设置`FOO`时，`BAR`的值为`before`。
- en: In contrast,
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 相比之下，
- en: '[PRE76]'
  id: totrans-278
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: This results in `FOO` having the value `$(BAR) the rain`, and `$(FOO)` evaluates
    to `after the rain`. That happens because `=` defines a recursive variable (one
    that can contain references to other variables using the `$()` or `${}` syntax)
    whose value is determined every time the variable is used. In contrast, simple
    variables defined using `:=` have a single fixed value determined at the time
    they were defined by expanding all the variable references straight away.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 这导致`FOO`的值为`$(BAR) the rain`，而`$(FOO)`的值为`after the rain`。这是因为`=`定义了一个递归变量（可以包含其他变量引用的变量，使用`$()`或`${}`语法），其值在每次使用该变量时被确定。相比之下，使用`:=`定义的简单变量在定义时通过立即展开所有变量引用来确定一个固定的值。
- en: Simple variables have a distinct speed advantage because they are fixed strings
    and don’t need to be expanded each time they are used. They can be tricky to use
    because it’s common for makefile writers to assume that variables can be set in
    any order since recursively defined variables (those set with `=`) get their final
    value only when they are used. Nevertheless, simple variables are usually faster
    to access than recursive variables, and I err on the side of always using `:=`
    if I can.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 简单变量具有明显的速度优势，因为它们是固定字符串，不需要每次使用时都进行展开。它们的使用可能有些棘手，因为makefile编写者常常假设变量可以按任意顺序设置，因为递归定义的变量（用`=`设置的变量）只有在使用时才会获得最终值。然而，简单变量通常比递归变量更快速访问，如果可能，我倾向于总是使用`:=`。
- en: But what if you could have the best of both worlds? A variable that gets set
    only when it is first used but gets to set to a fixed value that doesn’t change.
    This would be useful if the variable’s value requires a lot of computation but
    needs to be computed only once at most, and perhaps not at all if the variable
    never gets used. It is possible to achieve this with the `$(eval)` function.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 但是如果你能够兼顾两者的优点呢？一个变量，在首次使用时才会被设置，但它会被设定为一个固定值，且不会改变。如果变量的值需要大量计算，但最多只需要计算一次，甚至如果变量从未被使用则根本不计算，这将非常有用。这可以通过`$(eval)`函数实现。
- en: 'Consider the following definition:'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下定义：
- en: '[PRE77]'
  id: totrans-283
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: The `SHALIST` variable will contain the name and SHA1 cryptographic hash of
    every `.c` file found in the current directory and all subdirectories. This could
    take a long time to evaluate. And defining `SHALIST` using `=` means that this
    expensive call occurs every time you use `SHALIST`. If you use it more than once,
    this could significantly slow down execution of the makefile.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: '`SHALIST`变量将包含当前目录及所有子目录中每个`.c`文件的名称和SHA1加密哈希值。这个评估可能需要很长时间。而使用`=`定义`SHALIST`意味着每次使用`SHALIST`时都会发生这个昂贵的调用。如果使用多次，可能会显著降低makefile的执行速度。'
- en: On the other hand, if you define `SHALIST` using `:=`, the `$(shell)` would
    only be executed once—but it would happen every time the makefile is loaded. This
    might be inefficient if the value of `SHALIST` is not always needed, like when
    running `make clean`.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，如果你使用`:=`定义`SHALIST`，`$(shell)`只会执行一次，但每次加载makefile时都会发生。如果`SHALIST`的值并不总是需要，比如在运行`make
    clean`时，这可能效率低下。
- en: 'We want a way to define `SHALIST` so the `$(shell)` doesn’t happen if `SHALIST`
    is never used and is called only once if `SHALIST` is. Here’s how to do it:'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望能够定义`SHALIST`，使得如果`SHALIST`从未使用，则`$(shell)`不会执行；而如果`SHALIST`被使用，则仅执行一次。下面是如何实现：
- en: '[PRE78]'
  id: totrans-287
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: If `$(SHALIST)` is ever evaluated, the `$(eval SHALIST := $(shell find . -name
    '*.c' | xargs shasum))` part gets evaluated. Because `:=` is being used here,
    it actually does the `$(shell)` and redefines `SHALIST` to be result of that call.
    GNU `make` then retrieves the value of `$(SHALIST)`, which has just been set by
    the `$(eval)`.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`$(SHALIST)`被评估，`$(eval SHALIST := $(shell find . -name '*.c' | xargs shasum))`部分将会被评估。因为这里使用了`:=`，它实际上会执行`$(shell)`并将`SHALIST`重新定义为该调用的结果。然后，GNU
    `make`会获取由`$(eval)`刚刚设置的`$(SHALIST)`的值。
- en: 'You can see what’s happening by creating a small makefile that uses the `$(value)`
    function (which shows the definition of a variable without expanding it) to examine
    the value of `SHALIST` without evaluating it:'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过创建一个小的makefile，使用`$(value)`函数（该函数显示变量的定义而不展开它）来查看`SHALIST`的值，而不对其进行评估：
- en: '[PRE79]'
  id: totrans-290
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: 'Running that with a single `foo.c` file in the directory results in the following
    output:'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 使用目录中的一个`foo.c`文件运行该makefile，结果会产生以下输出：
- en: '[PRE80]'
  id: totrans-292
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: Clearly, `SHALIST` has changed value since the first time it was used at ➊.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，`SHALIST`的值自从第一次在➊使用时已经发生了变化。
- en: Simple List Manipulation
  id: totrans-294
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简单的列表操作
- en: 'In GNU `make`, lists elements are separated by spaces. For example, `peter
    paul and mary` is a list with four elements, as is `C:\Documents And Settings\Local
    User`. GNU `make` has a several built-in functions for manipulating lists:'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 在 GNU `make` 中，列表元素由空格分隔。例如，`peter paul and mary` 是一个包含四个元素的列表，`C:\Documents
    And Settings\Local User` 也是一个列表，包含四个元素。GNU `make` 提供了多个内置函数来操作列表：
- en: '****`$(firstword)`****. Gets the first word in a list.'
  id: totrans-296
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '****`$(firstword)`****。获取列表中的第一个单词。'
- en: '****`$(words)`****. Counts the number of list elements.'
  id: totrans-297
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '****`$(words)`****。计算列表元素的数量。'
- en: '****`$(word)`****. Extracts a word at a specific index (counting from 1).'
  id: totrans-298
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '****`$(word)`****。提取指定索引的单词（从 1 开始计数）。'
- en: '****`$(wordlist)`****. Extracts a range of words from a list.'
  id: totrans-299
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '****`$(wordlist)`****。从列表中提取一系列单词。'
- en: '****`$(foreach)`****. Lets you iterate over a list.'
  id: totrans-300
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '****`$(foreach)`****。允许你遍历一个列表。'
- en: 'Getting the first element of a list is trivial:'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 获取列表中的第一个元素很简单：
- en: '[PRE81]'
  id: totrans-302
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: That would output `The first word is a`.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 那将输出 `The first word is a`。
- en: 'You can get the last element by counting the number of words in the list, *N*,
    and then taking the *N*th word. Here’s a `lastword` function that returns the
    last word in a list:'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过计算列表中单词的数量 *N* 来获取最后一个元素，然后取出第 *N* 个单词。这里有一个 `lastword` 函数，它返回列表中的最后一个单词：
- en: '[PRE82]'
  id: totrans-305
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: The `$(if)` at ➊ is necessary because if the list were empty, `$(words $1)`
    would be `0` and `$(word 0,$1)` would generate a fatal error. The preceding example
    outputs `The last word is compilation`.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: ➊ 处的 `$(if)` 是必须的，因为如果列表为空，`$(words $1)` 将返回 `0`，而 `$(word 0,$1)` 会导致致命错误。前面的示例输出是
    `The last word is compilation`。
- en: Note
  id: totrans-307
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '*Versions 3.81 and later of GNU `make` have a built-in `lastword` function,
    which is quicker than the preceding implementation.*'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: '*GNU `make` 3.81 及更高版本内置了一个 `lastword` 函数，比之前的实现更快。*'
- en: 'Chopping the first word off a list is simply a matter of returning a sublist
    range from the second element to the end. GNU `make`’s built-in `$(wordlist` *`S`*`,`*`E`*`,`*`LIST`*`)`
    function returns a range of list elements from *`LIST`*, starting with the element
    at index *`S`* and ending at index *`E`* (inclusive):'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 剪去列表中的第一个单词只需返回从第二个元素到最后的子列表范围即可。GNU `make` 的内置 `$(wordlist` *`S`*`,`*`E`*`,`*`LIST`*`)`
    函数返回 *`LIST`* 中从索引 *`S`* 开始，到索引 *`E`* 结束（包括 *`E`*）的元素范围：
- en: '[PRE83]'
  id: totrans-310
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: You don’t have to worry about the empty list in the preceding example, because
    `$(wordlist)` doesn’t complain if its second argument isn’t a valid index. That
    example outputs `program for directed compilation`.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 你不需要担心前面示例中的空列表，因为 `$(wordlist)` 如果第二个参数不是有效的索引，也不会报错。那个示例的输出是 `program for
    directed compilation`。
- en: 'Chopping the last element off a list requires some more mental gymnastics,
    because there’s no simple way to do arithmetic in `make`: it’s not possible to
    just write `$(wordlist 1,$(words $1)–1, $1)`. Instead, we can define a `notlast`
    function that adds a dummy element to the start of the list and chops off the
    last element by using the *original* list length as the end index for `$(wordlist)`.
    Then, because we added a dummy element, we need to remember to chop that off by
    setting the start index for `$(wordlist)` at `2`:'
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 剪去列表中的最后一个元素需要一些额外的思考，因为在 `make` 中没有简单的算术运算方法：不能直接写 `$(wordlist 1,$(words $1)–1,
    $1)`。相反，我们可以定义一个 `notlast` 函数，通过在列表开头添加一个虚拟元素，并使用 *原始* 列表的长度作为 `$(wordlist)` 的结束索引，从而剪掉最后一个元素。然后，因为我们添加了一个虚拟元素，我们需要记得通过将
    `$(wordlist)` 的起始索引设置为 `2` 来去除它：
- en: '[PRE84]'
  id: totrans-313
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: And that outputs `a program for directed`.
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 这将输出 `a program for directed`。
- en: User-Defined Functions
  id: totrans-315
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 用户定义的函数
- en: This section is about defining `make` functions within a makefile. In [Chapter 5](ch05.html
    "Chapter 5. Pushing the Envelope"), you’ll learn how to modify the source of GNU
    `make` to define even more complex functions using C. We’ve used plenty of user-defined
    functions in previous sections, but now we’ll take a closer look.
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 本节介绍如何在 makefile 中定义 `make` 函数。在[第 5 章](ch05.html "第 5 章. 推动极限")，你将学习如何修改 GNU
    `make` 的源代码，使用 C 定义更复杂的函数。在前面的章节中，我们使用了很多用户定义的函数，现在我们将更详细地探讨这个话题。
- en: The Basics
  id: totrans-317
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 基础知识
- en: 'Here’s a very simple `make` function that takes three arguments and makes a
    date with them by inserting slashes between the three arguments:'
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个非常简单的 `make` 函数，它接受三个参数，并通过在这三个参数之间插入斜杠来生成日期：
- en: '[PRE85]'
  id: totrans-319
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: 'To use `make_date`, you `$(call)` it like this:'
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用 `make_date`，你可以像这样调用它：`$(call)`。
- en: '[PRE86]'
  id: totrans-321
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: That results in `today` containing `5/5/2014`.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 结果是 `today` 包含 `5/5/2014`。
- en: The function uses the special variables `$1`, `$2`, and `$3`, which contain
    the arguments specified in the `$(call)`. There’s no maximum number of arguments,
    but if you use more than nine, you need parentheses—that is, you can’t write `$10`
    but instead must use `$(10)`. If the function is called with missing arguments,
    the content of those variables will be undefined and treated as an empty string.
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 该函数使用了特殊变量`$1`、`$2`和`$3`，它们包含了在`$(call)`中指定的参数。没有参数数量的上限，但如果使用超过九个参数，则需要使用括号——也就是说，你不能写`$10`，而必须使用`$(10)`。如果函数调用时缺少某些参数，这些变量的内容将是未定义的，并被视为空字符串。
- en: The special argument `$0` contains the name of the function. In the preceding
    example, `$0` is `make_date`.
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 特殊参数`$0`包含函数的名称。在前面的例子中，`$0`是`make_date`。
- en: Because functions are essentially variables that reference some special variables
    that are created and filled in automatically by GNU `make` for you (if you use
    the `$(origin)` function on any of the argument variables [`$1`, etc.], they are
    classed as `automatic` just like `$@`), you can use built-in GNU `make` functions
    to build up complex functions.
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 由于函数本质上是引用一些由GNU `make`自动创建和填充的特殊变量（如果你在任何参数变量（如`$1`等）上使用`$(origin)`函数，它们会被分类为`automatic`，就像`$@`一样），你可以使用GNU
    `make`的内建函数来构建复杂的函数。
- en: 'Here’s a function that uses the `$(subst)` function to turn every `/` into
    a `\` in a path:'
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个使用`$(subst)`函数将路径中的每个`/`转换为`\`的函数：
- en: '[PRE87]'
  id: totrans-327
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: Don’t be worried about the use of `/` and `\` in this code. GNU `make` does
    very little escaping, and a literal `\` is most of the time an actual backslash
    character. You’ll read more about how `make` handles escaping in [Chapter 4](ch04.html
    "Chapter 4. Pitfalls and Problems").
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 不必担心代码中`/`和`\`的使用。GNU `make`几乎不做转义处理，字面上的`\`大部分时间都代表一个实际的反斜杠字符。你将在[第4章](ch04.html
    "第4章：陷阱与问题")中了解到更多关于`make`如何处理转义的内容。
- en: Argument-Handling Gotchas
  id: totrans-329
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参数处理陷阱
- en: '`make` starts processing a `$(call)` by splitting the argument list on commas
    to set the variables `$1`, `$2`, and so on. The arguments are then expanded so
    that these variables are completely expanded before they are ever referenced.
    It’s as if `make` used `:=` to set them. If expanding an argument has a side effect,
    such as calling `$(shell)`, that side effect will always occur as soon as the
    `$(call)` is executed, even if the argument never gets used by the function being
    called.'
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: '`make`在处理`$(call)`时，会通过逗号分隔参数列表来设置变量`$1`、`$2`等。然后展开这些参数，确保这些变量在引用之前被完全展开。这就像`make`使用`:=`来设置它们一样。如果展开一个参数时有副作用，比如调用`$(shell)`，这个副作用会在`$(call)`执行时立即发生，即使该参数最终并未被调用的函数使用。'
- en: 'One common problem is that the splitting of arguments can go wrong if an argument
    contains a comma. For example, here’s a simple function that swaps its two arguments:'
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 一个常见的问题是，如果参数中包含逗号，分割参数时可能会出错。例如，这里有一个简单的函数，它交换两个参数：
- en: '[PRE88]'
  id: totrans-332
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: If you do `$(call swap,first,argument,second)`, `make` doesn’t have any way
    of knowing whether the first argument was meant to be `first,argument` or just
    `first`. It will assume the latter and ends up returning `argument first` instead
    of `second first,argument`.
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你使用`$(call swap,first,argument,second)`，`make`没有办法知道第一个参数是想表示`first,argument`还是仅仅是`first`。它会假设后者，并最终返回`argument
    first`，而不是`second first,argument`。
- en: 'You have two ways around this. First, you could simply hide the first argument
    inside a variable. Because `make` doesn’t expand the arguments until after splitting,
    a comma inside a variable will not cause any confusion:'
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 你有两种方法来解决这个问题。首先，你可以简单地将第一个参数隐藏在一个变量中。因为`make`在分割参数之前不会展开这些参数，所以变量中的逗号不会引起任何混淆：
- en: '[PRE89]'
  id: totrans-335
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: 'The other approach is to create a simple variable that contains just a comma
    and use that instead:'
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种方法是创建一个仅包含逗号的简单变量，并使用它：
- en: '[PRE90]'
  id: totrans-337
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: 'Or even call that `,` variable and use it (with parentheses):'
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 或者甚至可以调用这个`,`变量并使用它（带括号）：
- en: '[PRE91]'
  id: totrans-339
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: As we’ll see in [Chapter 4](ch04.html "Chapter 4. Pitfalls and Problems"), giving
    variables clever names like `,` can be useful but also error prone.
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们将在[第4章](ch04.html "第4章：陷阱与问题")中看到的，给变量起一些巧妙的名字，如`,`，可能很有用，但也容易出错。
- en: Calling Built-in Functions
  id: totrans-341
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 调用内建函数
- en: 'It’s possible to use the `$(call)` syntax with `make`’s built-in functions.
    For example, you could call `$(info)` like this:'
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用`$(call)`语法与`make`的内建函数一起使用。例如，你可以像这样调用`$(info)`：
- en: '[PRE92]'
  id: totrans-343
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: 'This means that you can pass any function name as an argument to a user-defined
    function and `$(call)` it without needing to know whether it’s built in; therefore,
    it lets you create functions that act on functions. For example, you can create
    the classic `map` function from functional programming, which applies a function
    to every member of a list and returns the resulting list:'
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着你可以将任何函数名作为参数传递给用户定义的函数，并使用`$(call)`来调用它，而无需知道它是否是内置函数；因此，它允许你创建作用于函数的函数。例如，你可以创建经典的函数式编程中的`map`函数，该函数将一个函数应用于列表中的每个成员，并返回结果列表：
- en: '[PRE93]'
  id: totrans-345
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: 'The first argument is the function to call, and the second is the list to iterate
    over. Here’s an example use of `map`—iterating over a list of variable names and
    printing out the defined value and the expanded value of each variable:'
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个参数是要调用的函数，第二个参数是要遍历的列表。以下是`map`的一个示例用法——遍历一个变量名列表，并打印每个变量的定义值和扩展值：
- en: '[PRE94]'
  id: totrans-347
  prefs: []
  type: TYPE_PRE
  zh: '[PRE94]'
- en: 'The `print_variable` function takes the name of a variable as its first and
    only argument, and returns a string consisting of the name of the variable, its
    definition, and its value. The `print_variables` function simply applies `print_variable`
    to a list of variables using `map`. Here’s the output of the makefile snippet:'
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: '`print_variable`函数将变量名作为它的第一个也是唯一的参数，并返回一个由变量名、定义和其值组成的字符串。`print_variables`函数只是使用`map`将`print_variable`应用于一组变量列表。以下是makefile代码片段的输出结果：'
- en: '[PRE95]'
  id: totrans-349
  prefs: []
  type: TYPE_PRE
  zh: '[PRE95]'
- en: 'Functions in `make` can also be recursive: it’s possible for a function to
    `$(call)` itself. The following is a recursive implementation of the `reduce`
    function from functional programming, which takes two arguments: a function that
    will be called by `reduce` and a list to process.'
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: '`make`中的函数也可以是递归的：函数可以调用`$(call)`自身。下面是一个递归实现的`reduce`函数，来自函数式编程，它接受两个参数：一个会被`reduce`调用的函数和一个待处理的列表。'
- en: '[PRE96]'
  id: totrans-351
  prefs: []
  type: TYPE_PRE
  zh: '[PRE96]'
- en: 'The first argument (the function) is repeatedly called with two arguments:
    the next element of the list is `reduce`’s second argument and the result of the
    previous call to the function.'
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个参数（函数）会反复使用两个参数进行调用：列表中的下一个元素是`reduce`的第二个参数，前一次调用该函数的结果是第一个参数。
- en: 'To see this in action, here’s a `uniq` function that removes duplicates from
    a list:'
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 要查看其工作原理，下面是一个`uniq`函数，用于从列表中删除重复项：
- en: '[PRE97]'
  id: totrans-354
  prefs: []
  type: TYPE_PRE
  zh: '[PRE97]'
- en: The output here is `c b a`. This works because `reduce` will call `check_uniq`
    with each member of the input list, building up a new list from the result of
    `check_uniq`. The `check_uniq` function just determines whether an element is
    present in the given list (using the built-in function `filter`) and, if not present,
    returns the list with the element appended.
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的输出是`c b a`。之所以能这样工作，是因为`reduce`会使用输入列表中的每个成员调用`check_uniq`，并从`check_uniq`的结果构建一个新列表。`check_uniq`函数仅仅是判断一个元素是否存在于给定的列表中（使用内置的`filter`函数），如果不存在，则返回一个将该元素附加到列表后的新列表。
- en: 'To see that in action, here’s a modified version that uses `$(info)` to output
    the arguments sent to `check_uniq` on each invocation:'
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 要查看其实际效果，下面是一个修改版，使用`$(info)`在每次调用`check_uniq`时输出传递给它的参数：
- en: '[PRE98]'
  id: totrans-357
  prefs: []
  type: TYPE_PRE
  zh: '[PRE98]'
- en: 'And here’s the output:'
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是输出结果：
- en: '[PRE99]'
  id: totrans-359
  prefs: []
  type: TYPE_PRE
  zh: '[PRE99]'
- en: If you don’t need to preserve order, then using the built-in `$(sort)` function
    will be faster than this user-defined function since it also removes duplicates.
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 如果不需要保留顺序，那么使用内置的`$(sort)`函数会比这个用户定义的函数更快，因为它也会删除重复项。
- en: 'Recent GNU make Versions: 3.81, 3.82, and 4.0'
  id: totrans-361
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 最新的GNU make版本：3.81、3.82和4.0
- en: GNU `make` changes slowly, and new releases (both major and minor) become available
    only every few years. Because of this slow release cycle, it’s common to come
    across older versions of GNU `make` and useful to know the differences between
    them. This section assumes that the oldest common version in use is 3.79.1 (which
    was released on June 23, 2000) and highlights major changes in releases 3.81,
    3.82, and 4.0.
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: GNU `make`的变化很慢，新版本（包括主版本和次版本）通常每隔几年才发布一次。由于发布周期较慢，因此常常会遇到旧版本的GNU `make`，了解它们之间的差异非常有用。本节假设最常用的旧版本是3.79.1（发布于2000年6月23日），并重点介绍了3.81、3.82和4.0版本中的主要变化。
- en: What’s New in GNU make 3.81
  id: totrans-363
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: GNU make 3.81中的新功能
- en: 'GNU `make` 3.81 was released on April 1, 2006, three and a half years after
    the last version (GNU `make` 3.80), and it was packed with goodies: support for
    OS/2, a new command line option, new built-in variables, new conditionals, and
    new functions. For a complete list of changes, see the *NEWS* file in the GNU
    `make` 3.81 source code distribution.'
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: GNU `make` 3.81于2006年4月1日发布，比上一个版本（GNU `make` 3.80）晚了三年半，且新版本中加入了许多新特性：支持OS/2、新的命令行选项、新的内建变量、新的条件语句和新函数。有关更改的完整列表，请参阅GNU
    `make` 3.81源代码分发包中的*NEWS*文件。
- en: .SECONDEXPANSION
  id: totrans-365
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: .SECONDEXPANSION
- en: 'One frustrating problem users of GNU `make` run into is that the automatic
    variables are valid and assigned only when a rule’s commands are run; they are
    not valid as part of the rule definition. For example, it’s not possible to write
    `foo: $@.c` to mean that `foo` should be made from `foo.c`, even though `$@` will
    have the value `foo` when that rule’s commands are executed. That’s frustrating,
    because it would be nice to not have to repeat yourself like this:'
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: '用户使用GNU `make`时常遇到的一个令人沮丧的问题是，自动变量只有在规则的命令被执行时才有效并被赋值；它们在规则定义部分是无效的。例如，不能写`foo:
    $@.c`来表示`foo`应该由`foo.c`生成，尽管当该规则的命令被执行时，`$@`的值会是`foo`。这令人沮丧，因为如果不必像这样重复自己就好了：'
- en: '[PRE100]'
  id: totrans-367
  prefs: []
  type: TYPE_PRE
  zh: '[PRE100]'
- en: 'Before version 3.81, GNU `make` supported using `$$@` (note the two `$` signs)
    in the prerequisite list of a rule (this syntax comes from SysV `make`). For example,
    it was possible to say `foo: $$@.c`, and it was equivalent to `foo: foo.c`. That
    is, `$$@` had the value that `$@` has in the rule’s commands. To get that functionality
    in GNU `make` 3.81 and later, you must define `.SECONDEXPANSION` in the makefile.
    As a bonus, GNU `make` supports all the standard automatic variables in the rule
    definition (although note that automatic variables like `$$` will always be blank
    because they cannot be computed when the makefile is being parsed). This happens
    because GNU `make` will expand the prerequisite list of a rule twice: once when
    it reads the makefile and once again when searching for what to make.'
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: '在3.81版本之前，GNU `make`支持在规则的前提条件列表中使用`$$@`（注意两个`$`符号）（该语法来自SysV `make`）。例如，可以写`foo:
    $$@.c`，它等同于`foo: foo.c`。也就是说，`$$@`具有在规则命令中`$@`的值。要在GNU `make` 3.81及更高版本中获得此功能，必须在makefile中定义`.SECONDEXPANSION`。作为附加功能，GNU
    `make`支持在规则定义中使用所有标准的自动变量（尽管请注意，像`$$`这样的自动变量始终为空，因为它们无法在解析makefile时计算）。这发生的原因是，GNU
    `make`会对规则的前提条件列表进行两次扩展：第一次是在读取makefile时，第二次是在查找要构建的目标时。'
- en: 'You can use second expansion for more than just automatic variables. User-defined
    variables can also be *second expanded*, and they’ll end up getting the last value
    to which they were defined in the makefile. For example, you can do the following:'
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用第二次扩展（second expansion）不仅仅是自动变量。用户定义的变量也可以被*第二次扩展*，它们最终会得到在makefile中定义的最后一个值。例如，你可以这样做：
- en: '[PRE101]'
  id: totrans-370
  prefs: []
  type: TYPE_PRE
  zh: '[PRE101]'
- en: 'This gives the following output:'
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: 这将产生以下输出：
- en: '[PRE102]'
  id: totrans-372
  prefs: []
  type: TYPE_PRE
  zh: '[PRE102]'
- en: 'When the makefile was read, `all: $$(FOO)` was expanded to `all: $(FOO)`. Later,
    when figuring out how to build `all`, `$(FOO)` was expanded to `bar`—that is,
    the value `FOO` had when makefile parsing ended. Note that if you enable `.SECONDEXPANSION`
    and have filenames with `$`s in them, the `$`s will need to be escaped by writing
    `$$`.'
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: '当makefile被读取时，`all: $$(FOO)`会被扩展为`all: $(FOO)`。后来，当决定如何构建`all`时，`$(FOO)`被扩展为`bar`——也就是说，这是`FOO`在makefile解析结束时的值。请注意，如果你启用了`.SECONDEXPANSION`并且文件名中有`$`符号，那么`$`符号需要通过写`$$`来转义。'
- en: else
  id: totrans-374
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: else
- en: 'Another feature introduced in GNU `make` 3.81 was support for non-nested `else`
    branches by having the conditional on the same line as the `else`. For example,
    it’s possible to write:'
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: GNU `make` 3.81中引入的另一个新特性是通过将条件和`else`写在同一行来支持非嵌套的`else`分支。例如，可以写：
- en: '[PRE103]'
  id: totrans-376
  prefs: []
  type: TYPE_PRE
  zh: '[PRE103]'
- en: That syntax will be familiar to anyone who has used a language that supports
    `else if`, `elseif`, or `elsif`. This is GNU `make`’s way of having `else` and
    `if` on the same line.
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: 这种语法对任何使用过支持`else if`、`elseif`或`elsif`的语言的人来说都很熟悉。这是GNU `make`将`else`和`if`写在同一行的方式。
- en: 'Previously, the code would have looked like this:'
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: 之前，代码会像这样：
- en: '[PRE104]'
  id: totrans-379
  prefs: []
  type: TYPE_PRE
  zh: '[PRE104]'
- en: That’s a lot messier and much harder to read than the version with nonnested
    `else` branches.
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: 这种写法比起带有非嵌套`else`分支的版本，要乱得多，且更难以阅读。
- en: The -L Command Line Option
  id: totrans-381
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: -L命令行选项
- en: The command line option `-L` (and its long equivalent, `--check-symlink-times`)
    causes `make` to consider the modification time of the symlink and the modification
    time of the file pointed to by the symlink as GNU `make` decides which files need
    to be remade. Whichever is more recent is taken as the modification time. This
    can be useful if a build uses symlinks to point to different versions of source
    files because changing the symlink will change the modification time and force
    a rebuild.
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: 命令行选项 `-L`（及其长形式 `--check-symlink-times`）使 `make` 考虑符号链接的修改时间以及符号链接所指向文件的修改时间，以便决定哪些文件需要重新编译。较新的修改时间将被视为文件的修改时间。这在构建使用符号链接指向不同版本源文件时非常有用，因为改变符号链接将更改修改时间，并强制重新构建。
- en: .INCLUDE_DIRS
  id: totrans-383
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: .INCLUDE_DIRS
- en: The `.INCLUDE_DIRS` variable contains the list of directories that `make` will
    search when looking for makefiles that are included using the `include` directive.
    This variable is set by the standard list of directories built into GNU `make`
    and can be modified by the `-I` command line option. Although it’s possible to
    change the value of `.INCLUDE_DIRS` in the actual makefile with `=` or `:=`, this
    has no effect on how GNU `make` searches for makefiles.
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: '`.INCLUDE_DIRS` 变量包含 `make` 在查找通过 `include` 指令包含的 makefile 时会搜索的目录列表。该变量由 GNU
    `make` 内置的标准目录列表设置，并可以通过 `-I` 命令行选项进行修改。尽管可以在实际的 makefile 中通过 `=` 或 `:=` 来改变 `.INCLUDE_DIRS`
    的值，但这不会影响 GNU `make` 查找 makefile 的方式。'
- en: 'For example, running `make -I /usr/foo` on Linux with the following makefile
    outputs `/usr/foo /usr/local/include /usr/local/include /usr/include`:'
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，在 Linux 上运行 `make -I /usr/foo` 并使用以下 makefile 输出 `/usr/foo /usr/local/include
    /usr/local/include /usr/include`：
- en: '[PRE105]'
  id: totrans-386
  prefs: []
  type: TYPE_PRE
  zh: '[PRE105]'
- en: .FEATURES
  id: totrans-387
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: .FEATURES
- en: The `.FEATURES` variable expands to a list of features that GNU `make` supports
    and can be used to determine if a specific feature is available. With GNU `make`
    3.81 on Linux, the list of `.FEATURES` is `target-specific order-only second-expansion
    else-if archives jobserver check-symlink`. This means that GNU `make` 3.81 supports
    target- and pattern-specific variables, has orderonly prerequisites, supports
    second-expansion (`.SECONDEXPANSION`), supports `else if` non-nested conditionals,
    supports `ar` files, supports parallel making using the job server, and supports
    the new `-L` command line option for checking symlinks.
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: '`.FEATURES` 变量展开为 GNU `make` 支持的特性列表，可用于判断特定功能是否可用。在 Linux 上使用 GNU `make` 3.81
    时，`.FEATURES` 的列表为 `target-specific order-only second-expansion else-if archives
    jobserver check-symlink`。这意味着 GNU `make` 3.81 支持特定目标和模式的变量，具有 orderonly 先决条件，支持第二次展开（`.SECONDEXPANSION`），支持
    `else if` 非嵌套条件，支持 `ar` 文件，支持使用作业服务器进行并行编译，并支持用于检查符号链接的新 `-L` 命令行选项。'
- en: 'To test whether a specific feature is available, you can use `$(filter)`. For
    example:'
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: 要测试特定功能是否可用，可以使用 `$(filter)`。例如：
- en: '[PRE106]'
  id: totrans-390
  prefs: []
  type: TYPE_PRE
  zh: '[PRE106]'
- en: This line sets `has-order-only` to true if the version of `make` running has
    order-only prerequisite support. This isn’t backward compatible, though; for example,
    `.FEATURES` would expand to an empty list in GNU `make` 3.80, indicating that
    target-specific variables are not available even though they are. A backward compatible
    check would first need to determine whether `.FEATURES` is present by seeing if
    it is non-blank.
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: 这一行设置 `has-order-only` 为 true，前提是当前运行的 `make` 版本支持 order-only 先决条件。然而，这并不向后兼容；例如，在
    GNU `make` 3.80 中，`.FEATURES` 会展开为一个空列表，表示即使特定目标变量可用，它们仍不可用。向后兼容的检查首先需要通过查看 `.FEATURES`
    是否非空来判断它是否存在。
- en: .DEFAULT_GOAL
  id: totrans-392
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: .DEFAULT_GOAL
- en: 'Normally, if no goal is specified on the command line, `make` will build the
    first target it sees in the first makefile it parses. It’s possible to override
    this behavior by setting the `.DEFAULT_GOAL` variable anywhere in a makefile.
    For example, the following makefile will build `all` when run with no goal on
    the command line, despite the fact that the first target encountered is called
    `fail`:'
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，如果命令行中未指定目标，`make` 将构建它在第一个解析的 makefile 中看到的第一个目标。可以通过在 makefile 中的任何位置设置
    `.DEFAULT_GOAL` 变量来覆盖此行为。例如，以下 makefile 即使第一个目标是 `fail`，在没有命令行目标的情况下运行时，仍将构建 `all`：
- en: '[PRE107]'
  id: totrans-394
  prefs: []
  type: TYPE_PRE
  zh: '[PRE107]'
- en: The `.DEFAULT_GOAL` variable can also be read to get the current default goal;
    if set to blank (`.DEFAULT_GOAL :=`), `make` will automatically pick the next
    target it encounters as the default goal.
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: '`.DEFAULT_GOAL` 变量也可以读取当前的默认目标；如果设置为空（`.DEFAULT_GOAL :=`），`make` 将自动选择它遇到的下一个目标作为默认目标。'
- en: MAKE_RESTARTS
  id: totrans-396
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: MAKE_RESTARTS
- en: The `MAKE_RESTARTS` variable is the count of the number of times that `make`
    has restarted while performing makefile *remaking*. GNU `make` has a special feature
    that allows makefiles to be rebuilt by `make`. This remaking happens automatically
    when any makefile is included with `include`, as well as to the makefile `make`
    first started with, and any set with the `-f` command line option. `make` searches
    to see if there’s a rule to rebuild any of the makefiles. If it finds one, the
    makefile is rebuilt just like any other file `make` is capable of building, and
    GNU `make` restarts.
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
  zh: '`MAKE_RESTARTS` 变量表示 `make` 在执行 makefile *重建* 时重启的次数。GNU `make` 有一个特殊功能，允许
    makefile 由 `make` 自动重建。这种重建发生在任何通过 `include` 引入的 makefile 中，以及最初启动的 makefile 和通过
    `-f` 命令行选项设置的 makefile。`make` 会检查是否有规则来重建任何 makefile。如果找到，makefile 会像任何其他文件一样被重建，且
    GNU `make` 会重启。'
- en: If GNU `make` has not restarted, `MAKE_RESTARTS` is blank, not `0`.
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 GNU `make` 尚未重启，`MAKE_RESTARTS` 是空白，而不是 `0`。
- en: New Functions
  id: totrans-399
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 新函数
- en: 'GNU `make` 3.81 also introduced a variety of built-in functions:'
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
  zh: GNU `make` 3.81 还引入了多种内建函数：
- en: '****`$(info` *`text`*`)`****. This function is like the existing `$(warning)`
    function, but it prints the expanded *`text`* argument to `STDOUT` without reporting
    the makefile and line number. For example, the following makefile generates the
    output `Hello, World!`:'
  id: totrans-401
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '****`$(info` *`text`*`)`****。这个函数类似于现有的 `$(warning)` 函数，但它将展开后的 *`text`* 参数打印到
    `STDOUT`，而不报告 makefile 和行号。例如，以下 makefile 会生成 `Hello, World!` 输出：'
- en: '[PRE108]'
  id: totrans-402
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE108]'
- en: '****`$(lastword` *`LIST`*`)`****. This function returns the last word of a
    GNU `make` list. Previously this was possible by writing `$(word $(words` *`LIST`*`),`*`LIST`*`)`,
    but `$(lastword)` is more efficient. If you are using the GNU Make Standard Library
    (GMSL), there’s a function called `last`, which is the same as `$(lastword)`.
    If you are using GNU `make` 3.81 and GMSL 1.0.6 or later, `last` automatically
    uses the built-in `lastword` for speed.'
  id: totrans-403
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '****`$(lastword` *`LIST`*`)`****。该函数返回 GNU `make` 列表中的最后一个单词。之前可以通过写 `$(word
    $(words` *`LIST`*`),`*`LIST`*`)` 来实现，但 `$(lastword)` 更加高效。如果你使用 GNU Make Standard
    Library（GMSL），有一个名为 `last` 的函数，它与 `$(lastword)` 相同。如果你使用 GNU `make` 3.81 和 GMSL
    1.0.6 或更高版本，`last` 会自动使用内建的 `lastword` 来提高速度。'
- en: '****`$(flavor` *`VAR`*`)`****. This function returns the flavor of a variable
    (either `recursive` for recursively expanded or `simple` for simply expanded).
    For example, the following makefile prints that `REC` is recursive and `SIM` is
    simple:'
  id: totrans-404
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '****`$(flavor` *`VAR`*`)`****。该函数返回变量的类型（如果是递归展开，则为 `recursive`；如果是简单展开，则为
    `simple`）。例如，以下 makefile 会输出 `REC` 是递归的，`SIM` 是简单的：'
- en: '[PRE109]'
  id: totrans-405
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE109]'
- en: '****`$(or` *`arg1 arg2`* `...) and $(and)`****. `$(or)` returns a non-blank
    string if any of its arguments is non-blank, whereas `$(and)` returns a non-blank
    string if and only if all of its arguments are non-blank. If you are using the
    GMSL, `and` and `or` functions are part of the library. If you are using GNU `make`
    3.81 and GMSL 1.0.6 or later, the new built-in functions are *not* overridden
    with the GMSL versions, which means that makefiles that use GMSL are fully backward-
    and forward-compatible with GNU `make` 3.81.'
  id: totrans-406
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '****`$(or` *`arg1 arg2`* `...) 和 $(and)`****。`$(or)` 如果其任何一个参数非空，则返回非空字符串，而
    `$(and)` 只有在所有参数都非空时才返回非空字符串。如果你使用 GMSL，`and` 和 `or` 函数是库的一部分。如果你使用 GNU `make`
    3.81 和 GMSL 1.0.6 或更高版本，新的内建函数*不会*被 GMSL 版本覆盖，这意味着使用 GMSL 的 makefile 与 GNU `make`
    3.81 版本完全向后和向前兼容。'
- en: '****`$(abspath DIR)`****. This function returns the absolute path of `DIR`
    relative to the directory that GNU `make` was started in (taking into account
    any `-C` command line options). The path has all `.` and `..` elements resolved
    and duplicate slashes removed. Note that GNU `make` does not check whether the
    path *exists*; it just resolves the path elements to make an absolute path. For
    example, the following makefile prints `/home/jgc/bar` on my machine when it’s
    placed in */home/jgc*:'
  id: totrans-407
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '****`$(abspath DIR)`****。该函数返回相对于 GNU `make` 启动目录的 `DIR` 的绝对路径（考虑到任何 `-C` 命令行选项）。路径会解析所有的
    `.` 和 `..` 元素，并删除重复的斜杠。请注意，GNU `make` 并不会检查路径是否*存在*；它只会解析路径元素以生成绝对路径。例如，以下 makefile
    在我的机器上放在 */home/jgc* 中时，会输出 `/home/jgc/bar`：'
- en: '[PRE110]'
  id: totrans-408
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE110]'
- en: '****`$(realpath DIR)`****. This function returns the same result as `$(abspath
    DIR)` except that any symbolic links are resolved. For example, if `bar` is symlinked
    to `over-here`, the following makefile would return `/home/jgc/ over-here` if
    read from */home/jgc*:'
  id: totrans-409
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '****`$(realpath DIR)`****。该函数返回与 `$(abspath DIR)` 相同的结果，除了会解析任何符号链接。例如，如果 `bar`
    是指向 `over-here` 的符号链接，以下 makefile 会从 */home/jgc* 读取时返回 `/home/jgc/ over-here`：'
- en: '[PRE111]'
  id: totrans-410
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE111]'
- en: What’s New in GNU make 3.82
  id: totrans-411
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: GNU make 3.82中的新变化
- en: GNU `make` 3.82 was released four years after 3.81 and introduced a number of
    new features—as well as several backward incompatibilities.
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
  zh: GNU `make` 3.82在3.81发布四年后推出，引入了许多新特性——以及一些向后不兼容的变化。
- en: Backward Incompatibilities
  id: totrans-413
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 向后不兼容性
- en: 'The *NEWS* file for GNU `make` 3.82 starts with seven backward-incompatibility
    warnings. Here’s a quick overview:'
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
  zh: GNU `make` 3.82的*NEWS*文件以七个向后不兼容的警告开始。以下是快速概述：
- en: In GNU `make`, the shell that executes a rule’s commands is invoked with the
    `-c` command line option, which tells the shell to read the command to be executed
    from the first non-parameter argument to the shell. For example, when the following
    small rule is executed, `make` actually executes `execve("/bin/sh", ["/bin/sh",
    "-c", "echo \"hello\""], ...)`. To run the `echo "hello"`, `make` uses the shell
    `/bin/sh` and adds the `-c` command line option to it.
  id: totrans-415
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在GNU `make`中，执行规则命令的shell是通过`-c`命令行选项调用的，该选项告诉shell从第一个非参数参数开始读取要执行的命令。例如，当执行以下小规则时，`make`实际上执行的是`execve("/bin/sh",
    ["/bin/sh", "-c", "echo \"hello\""], ...)`。要运行`echo "hello"`，`make`使用shell`/bin/sh`并为其添加`-c`命令行选项。
- en: '[PRE112]'
  id: totrans-416
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE112]'
- en: But the POSIX standard for `make` was changed in 2008 to require that `-e` must
    be specified on the shell command line. The default behavior of GNU `make` 3.82
    and later is to not pass `-e` unless the `.POSIX` special target is specified.
    Anyone using this target in a makefile needs to watch out for this change.
  id: totrans-417
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 但是，POSIX标准在2008年修改了`make`的规定，要求必须在shell命令行中指定`-e`。GNU `make` 3.82及更高版本的默认行为是不传递`-e`，除非指定了`.POSIX`特殊目标。任何在makefile中使用此目标的人需要注意这一变化。
- en: The `$?` automatic variable includes the name of all prerequisites to a target
    that caused a rebuild, *even if they do not exist*. Previously, any prerequisites
    that did not exist were not placed into `$?`.
  id: totrans-418
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`$?`自动变量包括所有导致重新构建的前提条件的名称，*即使它们不存在*。之前，任何不存在的前提条件不会被放入`$?`。'
- en: The `$(wildcard)` function had always returned a sorted list of files, but this
    was never actually documented. This behavior changed in GNU `make` 3.82 so that
    any makefile relying on a sorted list from `$(wildcard)` needs to wrap it in a
    call to `$(sort)`; for example, do `$(sort $(wildcard *.c))` to get a sorted list
    of `.c` files.
  id: totrans-419
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`$(wildcard)`函数一直返回一个已排序的文件列表，但这从未实际文档化。这个行为在GNU `make` 3.82中发生了变化，因此任何依赖于`$(wildcard)`的已排序列表的makefile都需要将其包裹在`$(sort)`的调用中；例如，执行`$(sort
    $(wildcard *.c))`以获取已排序的`.c`文件列表。'
- en: 'It used to be possible to write a rule that mixed pattern targets and explicit
    targets, like this:'
  id: totrans-420
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 以前可以编写一个混合模式目标和显式目标的规则，像这样：
- en: '[PRE113]'
  id: totrans-421
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE113]'
- en: This had been undocumented and was completely removed in GNU `make` 3.81, because
    it was never intended to work. It now results in an error message.
  id: totrans-422
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这一直没有文档说明，并且在GNU `make` 3.81中被完全移除，因为这从未打算如此工作。现在它会导致错误信息。
- en: 'It’s no longer possible to have a prerequisite that contains an `=` sign, even
    when escaped with `\`. For example, the following no longer works:'
  id: totrans-423
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不再可能有一个包含`=`符号的前提条件，即使使用`\`进行转义。例如，下面的写法不再有效：
- en: '[PRE114]'
  id: totrans-424
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE114]'
- en: 'If you need an equal sign in a target or prerequisite name, first define a
    variable that expands to `=`, like so:'
  id: totrans-425
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果在目标或前提条件名称中需要一个等号，首先定义一个展开为`=`的变量，如下所示：
- en: '[PRE115]'
  id: totrans-426
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE115]'
- en: 'Variable names can’t contain whitespace in GNU `make` 3.82\. It was previously
    possible to do this:'
  id: totrans-427
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在GNU `make` 3.82中，变量名不能包含空格。之前是可以这样做的：
- en: '[PRE116]'
  id: totrans-428
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE116]'
- en: If you need a variable with a space in its name, first define another variable
    that contains just a space and use it as follows. But watch out; this sort of
    thing can be dangerous and hard to debug.
  id: totrans-429
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果需要一个包含空格的变量名，首先定义另一个只包含空格的变量，并按照以下方式使用它。但请注意，这种做法可能是危险的，且难以调试。
- en: '[PRE117]'
  id: totrans-430
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE117]'
- en: 'The order in which pattern rules and pattern-specific variables are applied
    used to be in the order in which they were found in the makefile. This changed
    in GNU `make` 3.82: they are now applied in `''shortest stem''` order. For example,
    the following makefile shows how different pattern rules are used with GNU `make`
    3.81 and 3.82.'
  id: totrans-431
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 模式规则和模式特定变量应用的顺序曾经是按它们在makefile中出现的顺序。这个顺序在GNU `make` 3.82中发生了变化：它们现在按照“最短stem”顺序应用。例如，下面的makefile展示了GNU
    `make` 3.81和3.82中不同模式规则的使用方法。
- en: '[PRE118]'
  id: totrans-432
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE118]'
- en: 'The *stem* is the part of the pattern that is matched by the `%`. In GNU `make`
    3.81 and earlier, the `out%.o` rule matches because it is defined first:'
  id: totrans-433
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '*stem*是模式中由`%`匹配的部分。在GNU `make` 3.81及更早版本中，`out%.o`规则可以匹配，因为它是首先定义的：'
- en: '[PRE119]'
  id: totrans-434
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE119]'
- en: 'In GNU `make` 3.82 and later, the `outp%.o` rule is used because the stem is
    shorter:'
  id: totrans-435
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在 GNU `make` 3.82 及更高版本中，使用 `outp%.o` 规则，因为该规则的模板更短：
- en: '[PRE120]'
  id: totrans-436
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE120]'
- en: Similar behavior occurs with pattern-specific variables.
  id: totrans-437
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 对模式特定变量也会出现类似的行为。
- en: 'New Command Line Option: --eval'
  id: totrans-438
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 新的命令行选项：`--eval`
- en: The new `--eval` command line option causes `make` to run its argument through
    `$(eval)` before parsing makefiles. For example, if you have this makefile and
    run `make --eval=FOO=bar`, you’ll see the output `FOO has value bar`.
  id: totrans-439
  prefs: []
  type: TYPE_NORMAL
  zh: 新的 `--eval` 命令行选项会使 `make` 在解析 Makefile 之前，将其参数通过 `$(eval)` 进行处理。例如，如果你有这个 Makefile，并运行
    `make --eval=FOO=bar`，你将看到输出 `FOO has value bar`。
- en: '[PRE121]'
  id: totrans-440
  prefs: []
  type: TYPE_PRE
  zh: '[PRE121]'
- en: This is because before the makefile is parsed, the line `FOO=bar` is treated
    as if it were the first line in the makefile and it sets `FOO` to `bar.`
  id: totrans-441
  prefs: []
  type: TYPE_NORMAL
  zh: 这是因为在解析 Makefile 之前，`FOO=bar` 这一行会被当作 Makefile 的第一行，并将 `FOO` 设置为 `bar`。
- en: 'New Special Variables: .RECIPEPREFIX and .SHELLFLAGS'
  id: totrans-442
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 新的特殊变量：`.RECIPEPREFIX` 和 `.SHELLFLAGS`
- en: 'GNU `make` 3.82 introduced two new special variables:'
  id: totrans-443
  prefs: []
  type: TYPE_NORMAL
  zh: GNU `make` 3.82 引入了两个新的特殊变量：
- en: '****`.RECIPEPREFIX`****. GNU `make` uses a `TAB` character as significant whitespace
    to start the commands in a rule. You can change this with the `.RECIPEPREFIX`
    variable. (If `.RECIPEPREFIX` is an empty string, then `TAB` is used). For example:'
  id: totrans-444
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '****`.RECIPEPREFIX`****。GNU `make` 使用 `TAB` 字符作为规则中命令的有效空白字符。你可以通过 `.RECIPEPREFIX`
    变量来更改此设置。（如果 `.RECIPEPREFIX` 是空字符串，则使用 `TAB`）。例如：'
- en: '[PRE122]'
  id: totrans-445
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE122]'
- en: Also, `.RECIPEPREFIX` can be changed over and over again in a makefile as needed.
  id: totrans-446
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 此外，`.RECIPEPREFIX` 可以根据需要在 Makefile 中反复更改。
- en: '****`.SHELLFLAGS`****. This variable contains the parameters sent to the shell
    when a rule’s commands are run. By default it is `-c` (or `-ec` if `.POSIX:` is
    specified in the makefile). It can be read or changed if a different shell is
    being used.'
  id: totrans-447
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '****`.SHELLFLAGS`****。该变量包含在规则的命令运行时传递给 shell 的参数。默认情况下，它是 `-c`（如果在 Makefile
    中指定了 `.POSIX:`，则为 `-ec`）。如果使用不同的 shell，可以读取或更改此值。'
- en: The .ONESHELL Target
  id: totrans-448
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '`.ONESHELL` 目标'
- en: 'When a rule’s commands are executed, each line is sent to the shell as a separate
    shell invocation. With GNU `make` 3.82, a new special target called `.ONESHELL`
    changes this behavior. If `.ONESHELL:` is set in the makefile, a single shell
    invocation is used for all the lines in a rule. For example:'
  id: totrans-449
  prefs: []
  type: TYPE_NORMAL
  zh: 当规则的命令执行时，每行都会作为一个单独的 shell 调用发送到 shell 中。在 GNU `make` 3.82 中，引入了一个新的特殊目标 `.ONESHELL`
    来改变这种行为。如果在 Makefile 中设置了 `.ONESHELL:`，则所有规则中的行将在同一个 shell 调用中执行。例如：
- en: '[PRE123]'
  id: totrans-450
  prefs: []
  type: TYPE_PRE
  zh: '[PRE123]'
- en: This does not output `/tmp` (unless `make` was started in */tmp*) because each
    line is executed in a separate shell. But with the `.ONESHELL` special target,
    both lines are executed in the same shell and `pwd` will output `/tmp`.
  id: totrans-451
  prefs: []
  type: TYPE_NORMAL
  zh: 这不会输出 `/tmp`（除非 `make` 是在 */tmp* 目录下启动的），因为每行命令都会在单独的 shell 中执行。但使用 `.ONESHELL`
    特殊目标时，两行命令会在同一个 shell 中执行，`pwd` 会输出 `/tmp`。
- en: '[PRE124]'
  id: totrans-452
  prefs: []
  type: TYPE_PRE
  zh: '[PRE124]'
- en: Changing Variables with the private and undefine Keywords
  id: totrans-453
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用 `private` 和 `undefine` 关键字来更改变量
- en: A target-specific variable is normally defined for a target and all its prerequisites.
    But if the target-specific variable is prefixed with the keyword `private`, it
    is defined only for that target, *not* its prerequisites.
  id: totrans-454
  prefs: []
  type: TYPE_NORMAL
  zh: 目标特定变量通常为目标及其所有前提条件定义。但如果目标特定变量以 `private` 关键字为前缀，则该变量仅为该目标定义，*而不是*其前提条件。
- en: In the following makefile, `DEBUG` is only set to `1` for the `foo.o` target
    because it is marked as `private:`
  id: totrans-455
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下 Makefile 中，`DEBUG` 只在 `foo.o` 目标上设置为 `1`，因为它被标记为 `private:`。
- en: '[PRE125]'
  id: totrans-456
  prefs: []
  type: TYPE_PRE
  zh: '[PRE125]'
- en: 'Another new keyword in GNU `make` 3.82 is `undefine`, which makes it possible
    to undefine a variable:'
  id: totrans-457
  prefs: []
  type: TYPE_NORMAL
  zh: GNU `make` 3.82 中的另一个新关键字是 `undefine`，它使得可以取消定义一个变量：
- en: '[PRE126]'
  id: totrans-458
  prefs: []
  type: TYPE_PRE
  zh: '[PRE126]'
- en: 'You can detect the difference between an empty variable and an undefined variable
    using the `$(flavor)` function. For example, the following outputs `simple` and
    then `undefined`:'
  id: totrans-459
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用 `$(flavor)` 函数来检测空变量与未定义变量之间的区别。例如，以下输出 `simple`，然后输出 `undefined`：
- en: '[PRE127]'
  id: totrans-460
  prefs: []
  type: TYPE_PRE
  zh: '[PRE127]'
- en: 'In versions of GNU `make` prior to 3.82, the `define` directive (which is used
    to define a multiline variable) would always create a recursively defined variable.
    For example, `COMMANDS` here would be a recursive variable, getting expanded at
    each use:'
  id: totrans-461
  prefs: []
  type: TYPE_NORMAL
  zh: 在 GNU `make` 3.82 之前的版本中，`define` 指令（用于定义多行变量）总是会创建一个递归定义的变量。例如，这里的 `COMMANDS`
    将是一个递归变量，每次使用时都会展开：
- en: '[PRE128]'
  id: totrans-462
  prefs: []
  type: TYPE_PRE
  zh: '[PRE128]'
- en: In GNU 3.82 it’s possible to add an optional `=`, `:=`, or `+=` after the variable
    name in a `define` statement. The default behavior is for the new variable to
    be recursively expanded each time; this is the same as adding an `=`. Adding a
    `:=` creates a simple variable, expanding the body of the `define` at definition
    time. And adding `+=` appends multiple lines to an existing variable.
  id: totrans-463
  prefs: []
  type: TYPE_NORMAL
  zh: 在 GNU 3.82 中，可以在 `define` 语句中的变量名后添加可选的 `=`、`:=` 或 `+=`。默认行为是每次都递归展开新变量；这与添加
    `=` 相同。添加 `:=` 会创建一个简单变量，在定义时展开 `define` 的主体。添加 `+=` 会将多行追加到现有变量中。
- en: 'The following makefile creates a simple variable called `COMMANDS` and then
    adds lines to it:'
  id: totrans-464
  prefs: []
  type: TYPE_NORMAL
  zh: 以下 makefile 创建了一个名为 `COMMANDS` 的简单变量，然后向其中添加行：
- en: '[PRE129]'
  id: totrans-465
  prefs: []
  type: TYPE_PRE
  zh: '[PRE129]'
- en: Notice the extra blank line at ➊. It’s necessary for the `wc -c $(FILE)` to
    appear on a new line after the `shasum $(FILE)`. Without it the `wc -c $(FILE)`
    would get appended to `shasum $(FILE)` without a newline.
  id: totrans-466
  prefs: []
  type: TYPE_NORMAL
  zh: 注意➊处的额外空行。这是必要的，因为 `wc -c $(FILE)` 必须在 `shasum $(FILE)` 之后新的一行显示。如果没有它，`wc -c
    $(FILE)` 会被追加到 `shasum $(FILE)` 后面，并且没有换行符。
- en: What’s New in GNU make 4.0
  id: totrans-467
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: GNU make 4.0 的新特性
- en: 'The release of GNU `make` 4.0 introduced two major features: integration with
    the GNU Guile language and an experimental option to dynamically load objects
    to expand `make`’s functionality at runtime. In addition, new command line options
    are especially helpful for debugging.'
  id: totrans-468
  prefs: []
  type: TYPE_NORMAL
  zh: GNU `make` 4.0 的发布引入了两个主要特性：与 GNU Guile 语言的集成，以及一个实验性选项，允许动态加载对象以在运行时扩展 `make`
    的功能。此外，新的命令行选项对于调试特别有帮助。
- en: GNU Guile
  id: totrans-469
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: GNU Guile
- en: The biggest change in GNU `make` 4.0 is the new `$(guile)` function, whose argument
    is code written in the GNU Guile language. The code is executed and its return
    value is converted to a string, which gets returned by the `$(guile)` function.
  id: totrans-470
  prefs: []
  type: TYPE_NORMAL
  zh: GNU `make` 4.0 中最大的变化是新的 `$(guile)` 函数，其参数是用 GNU Guile 语言编写的代码。该代码被执行，并将返回值转换为字符串，该字符串将由
    `$(guile)` 函数返回。
- en: 'The ability to drop into another language adds enormous functionality to GNU
    `make`. The following is a simple example of using Guile to check whether a file
    exists:'
  id: totrans-471
  prefs: []
  type: TYPE_NORMAL
  zh: 能够切换到另一种语言为 GNU `make` 添加了巨大的功能。以下是一个简单示例，使用 Guile 检查文件是否存在：
- en: '[PRE130]'
  id: totrans-472
  prefs: []
  type: TYPE_PRE
  zh: '[PRE130]'
- en: Using GNU Guile inside GNU `make` is covered in further detail in [Chapter 5](ch05.html
    "Chapter 5. Pushing the Envelope").
  id: totrans-473
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 GNU Guile 内嵌在 GNU `make` 中的内容将在 [第 5 章](ch05.html "第 5 章. 推动极限") 中进一步详细介绍。
- en: Loading Dynamic Objects
  id: totrans-474
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 加载动态对象
- en: We don’t use the `load` operator in this book to define functions in C, but
    defining functions in C and loading dynamic objects are explained in [Chapter 5](ch05.html
    "Chapter 5. Pushing the Envelope").
  id: totrans-475
  prefs: []
  type: TYPE_NORMAL
  zh: 本书中我们没有使用 `load` 操作符来定义 C 函数，但在 [第 5 章](ch05.html "第 5 章. 推动极限") 中解释了如何在 C 中定义函数和加载动态对象。
- en: Syncing Output with --output-sync
  id: totrans-476
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用 `--output-sync` 同步输出
- en: If you use recursive `make` or use the job server to run rules in parallel,
    the output produced by `make` can be very hard to read because output from different
    rules and sub-makes gets intermingled.
  id: totrans-477
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你使用递归的`make`或者使用作业服务器并行运行规则，`make`产生的输出可能会很难阅读，因为来自不同规则和子 `make` 的输出会交织在一起。
- en: 'Consider the following (slightly contrived) makefile:'
  id: totrans-478
  prefs: []
  type: TYPE_NORMAL
  zh: 请考虑以下（稍微做过修改的）makefile：
- en: '[PRE131]'
  id: totrans-479
  prefs: []
  type: TYPE_PRE
  zh: '[PRE131]'
- en: 'This makefile contains four targets: `one`, `two`, `three`, and `four`. The
    targets will be built in parallel if you use the `-j` option. Two calls to `sleep`
    have been added to simulate commands that get executed for different lengths of
    time.'
  id: totrans-480
  prefs: []
  type: TYPE_NORMAL
  zh: 这个 makefile 包含四个目标：`one`、`two`、`three` 和 `four`。如果使用 `-j` 选项，目标将并行构建。为了模拟不同执行时间的命令，添加了两次
    `sleep` 调用。
- en: 'When run with the `-j4` option, which runs four jobs in parallel, the output
    might look like this:'
  id: totrans-481
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用 `-j4` 选项运行时，它会并行运行四个作业，输出可能如下所示：
- en: '[PRE132]'
  id: totrans-482
  prefs: []
  type: TYPE_PRE
  zh: '[PRE132]'
- en: 'The output lines for each rule are mixed together, making it very hard to decipher
    which output goes with which rule. Specifying `-Otarget` (or `--output-sync=target`)
    causes `make` to keep track of which output is associated with which target and
    flush the output only when the rule is complete. Now the complete output for each
    target is clearly readable:'
  id: totrans-483
  prefs: []
  type: TYPE_NORMAL
  zh: 每个规则的输出行会混合在一起，使得很难辨别哪个输出属于哪个规则。指定 `-Otarget`（或 `--output-sync=target`）会使 `make`
    跟踪哪些输出与哪个目标相关联，并且只在规则完成时刷新输出。现在每个目标的完整输出清晰可读：
- en: '[PRE133]'
  id: totrans-484
  prefs: []
  type: TYPE_PRE
  zh: '[PRE133]'
- en: Specifying `--output-sync=recurse` handles recursive sub-makes—that is, rules
    that invoke `$(MAKE)`—by buffering the entire output of the rule *including* the
    sub-make and outputting it all in one go. This prevents sub-make output from getting
    mixed together but can lead to long pauses in output from `make`.
  id: totrans-485
  prefs: []
  type: TYPE_NORMAL
  zh: 指定`--output-sync=recurse`可以处理递归子make——即调用`$(MAKE)`的规则——通过缓存规则的所有输出，包括子make的输出，并一次性输出所有内容。这可以防止子make输出混合在一起，但可能导致`make`的输出出现长时间的暂停。
- en: The --trace Command Line Option
  id: totrans-486
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: --trace命令行选项
- en: You can use the new `--trace` option to trace the execution of rules in a makefile.
    When specified on the `make` command line, the commands for each rule that is
    executed are printed along with information about where the rule is defined and
    why it was executed.
  id: totrans-487
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用新的`--trace`选项来追踪makefile中规则的执行情况。当在`make`命令行中指定时，执行的每条规则的命令会与该规则的定义位置及其执行原因一起打印出来。
- en: 'For example, this simple makefile has four targets:'
  id: totrans-488
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，这个简单的makefile有四个目标：
- en: '[PRE134]'
  id: totrans-489
  prefs: []
  type: TYPE_PRE
  zh: '[PRE134]'
- en: 'Run it with `--trace`:'
  id: totrans-490
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`--trace`运行它：
- en: '[PRE135]'
  id: totrans-491
  prefs: []
  type: TYPE_PRE
  zh: '[PRE135]'
- en: This shows you why each rule was run, where it is in the makefile, and what
    commands were executed.
  id: totrans-492
  prefs: []
  type: TYPE_NORMAL
  zh: 这会显示每条规则为何被执行，它在makefile中的位置，以及执行了哪些命令。
- en: 'New Assignment Operators: != and ::='
  id: totrans-493
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 新的赋值运算符：`!=`和`::=`
- en: 'You can use the `!=` operator to execute a shell command and set a variable
    to the output of the command in a similar manner to `$(shell)`. For example, the
    following line uses `!=` to get the current date and time into a variable:'
  id: totrans-494
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用`!=`运算符执行一个shell命令，并将命令的输出设置为变量，这与`$(shell)`类似。例如，下面的代码行使用`!=`获取当前的日期和时间并存入变量：
- en: '[PRE136]'
  id: totrans-495
  prefs: []
  type: TYPE_PRE
  zh: '[PRE136]'
- en: An important subtlety with `!=` is that the resulting variable is recursive,
    so its value is expanded each time the variable is used. If the command executed
    (that is, the RHS of the `!=`) returns a `$`, it will be interpreted by `make`
    as a variable reference and expanded. For this reason it’s safer to use a `$(shell)`
    with `:=` instead of `!=`. (This was added for compatibility with BSD `make` and
    might also be added to POSIX.)
  id: totrans-496
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`!=`时需要注意一个重要的细节：结果变量是递归的，因此每次使用变量时它的值都会被展开。如果执行的命令（即`!=`的右侧部分）返回了`$`，`make`会将其解释为变量引用并展开。因此，最好使用`$(shell)`与`:=`，而不是使用`!=`。（这是为了兼容BSD
    `make`，也可能会被添加到POSIX中。）
- en: The `::=` operator is exactly like `:=` and was added for POSIX compatibility.
  id: totrans-497
  prefs: []
  type: TYPE_NORMAL
  zh: '`::=`运算符与`:=`完全相同，且是为了POSIX兼容性而添加的。'
- en: The $(file) Function
  id: totrans-498
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '`$(file)`函数'
- en: 'You can use the new `$(file)` function to create or append to a file. The following
    makefile uses `$(file)` to create a file and append to it each time a rule is
    executed. It creates a log of the makefile’s execution:'
  id: totrans-499
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用新的`$(file)`函数来创建或追加到一个文件。以下makefile使用`$(file)`在每次执行规则时创建一个文件并追加内容。它记录了makefile的执行日志：
- en: '[PRE137]'
  id: totrans-500
  prefs: []
  type: TYPE_PRE
  zh: '[PRE137]'
- en: 'The first `$(file)` creates the log file using the `>` operator, and subsequent
    calls to `$(file)` use `>>` to append to the log:'
  id: totrans-501
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个`$(file)`使用`>`操作符创建日志文件，随后的`$(file)`调用使用`>>`将内容追加到日志中：
- en: '[PRE138]'
  id: totrans-502
  prefs: []
  type: TYPE_PRE
  zh: '[PRE138]'
- en: It’s easy to see that the `$(file)` function is a useful addition to GNU `make`.
  id: totrans-503
  prefs: []
  type: TYPE_NORMAL
  zh: 很容易看出，`$(file)`函数是GNU `make`的一个有用扩展。
- en: What’s New in GNU make 4.1
  id: totrans-504
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: GNU make 4.1的新特性
- en: The most recent version of GNU `make` (at the time of this writing) is 4.1\.
    Released on October 5, 2014, it contains two useful changes and a large number
    of bug fixes and small improvements.
  id: totrans-505
  prefs: []
  type: TYPE_NORMAL
  zh: 当前版本的GNU `make`（在本文写作时）是4.1版本。该版本于2014年10月5日发布，包含了两个有用的改动以及大量的错误修复和小幅改进。
- en: New variables `MAKE_TERMOUT` and `MAKE_TERMERR` have been introduced. These
    Boolean values are set to true (that is, they are not empty) if `make` believes
    that `stdout` and `stderr` (respectively) are being sent to the console.
  id: totrans-506
  prefs: []
  type: TYPE_NORMAL
  zh: 新增了`MAKE_TERMOUT`和`MAKE_TERMERR`变量。如果`make`认为`stdout`和`stderr`（分别）被发送到控制台，则这两个布尔值会被设置为true（即它们不是空的）。
- en: The `$(file)` function has been modified so that it’s possible to open a file
    without writing anything to it. If no text argument is present, the file is simply
    opened and closed again; you can use that to create an empty file with `$(file
    > $(MY_FILE))`.
  id: totrans-507
  prefs: []
  type: TYPE_NORMAL
  zh: '`$(file)`函数已被修改，可以打开一个文件而不往其中写入任何内容。如果没有提供文本参数，文件会被简单地打开然后关闭；你可以用这个方法通过`$(file
    > $(MY_FILE))`创建一个空文件。'
