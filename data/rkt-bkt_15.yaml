- en: '**13'
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '**13**'
- en: THE RISE OF MBR RANSOMWARE**
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: '**MBR 勒索软件的兴起**'
- en: '![Image](../images/common.jpg)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/common.jpg)'
- en: 'So far, the examples of malware described in this book all belong to a particular
    class: computer trojans with rootkit or bootkit functionality whose intention
    is to persist on victims’ systems long enough to perform various malicious activities—committing
    browser click fraud, sending spam, opening a backdoor, or creating an HTTP proxy,
    to name just a few. These trojans use bootkit persistence methods to persevere
    on infected computers and rootkit functionality to remain undetected.'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，本书中描述的恶意软件示例都属于某一特定类别：具备 rootkit 或 bootkit 功能的计算机木马，其目的是在受害者的系统上长期存在，执行各种恶意活动——如进行浏览器点击欺诈、发送垃圾邮件、打开后门或创建
    HTTP 代理等。这些木马利用 bootkit 持久化方法在感染的计算机上持续存在，并利用 rootkit 功能保持隐匿。
- en: In this chapter, we’ll take a look at *ransomware*, a family of malware with
    a very different modus operandi. As the name suggests, the main purpose of ransomware
    is to lock users out of their data or computer system entirely and demand a ransom
    to restore access.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一章中，我们将重点介绍 *勒索软件*，这是一种有着截然不同作案手法的恶意软件家族。顾名思义，勒索软件的主要目的是完全锁定用户的数据或计算机系统，并要求支付赎金以恢复访问权限。
- en: In most known cases, ransomware uses encryption to deprive users of their data.
    Once the malware is executed, it attempts to encrypt everything of value to a
    user—documents, photos, emails, and so on—and then demands the user pay a ransom
    to get the encryption key to decrypt their data.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在大多数已知案例中，勒索软件通过加密来剥夺用户的数据。一旦恶意软件被执行，它会尝试加密对用户有价值的所有内容——文档、照片、电子邮件等——然后要求用户支付赎金以获取解密密钥，从而解锁数据。
- en: Most ransomware targets user files stored in the computer filesystem, though
    these methods don’t implement any advanced rootkit or bootkit functionality and
    thus aren’t relevant for this book. However, some ransomware families instead
    encrypt sectors of the hard drive to block user access to the system, using bootkit
    functionality to do so.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数勒索软件针对存储在计算机文件系统中的用户文件，尽管这些方法并未实现任何先进的 rootkit 或 bootkit 功能，因此与本书内容无关。然而，一些勒索软件家族则加密硬盘的某些扇区，利用
    bootkit 功能来阻止用户访问系统。
- en: 'In this chapter, we’ll focus on the latter category: ransomware that targets
    computer hard drives and deprives victims not only of files but also of access
    to the entire computer system. This type of ransomware encrypts certain areas
    of the hard drive and installs a malicious bootloader onto the MBR. Instead of
    booting the operating system, the bootloader performs low-level encryption of
    the hard drive’s content and displays a message to a victim demanding a ransom.
    In particular, we’ll focus on two families that have received a lot of media attention:
    Petya and Satana.'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一章中，我们将专注于后一类：针对计算机硬盘的勒索软件，不仅剥夺受害者的文件，还剥夺对整个计算机系统的访问。这类勒索软件加密硬盘的特定区域，并在 MBR
    上安装恶意引导程序。该引导程序不会启动操作系统，而是执行硬盘内容的低级加密，并向受害者显示要求支付赎金的信息。特别地，我们将关注两大受到媒体广泛关注的勒索软件家族：Petya
    和 Satana。
- en: '**A Brief History of Modern Ransomware**'
  id: totrans-8
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**现代勒索软件的简史**'
- en: The first traces of ransomware-like malware were apparent in the computer virus
    AIDS, first discovered in the wild in 1989\. AIDS used methods similar to those
    of modern ransomware to infect old MS-DOS COM executables by overwriting the beginning
    of files with malicious code in a way that made it impossible to recover them.
    AIDS, however, didn’t demand that victims pay a ransom to restore access to the
    infected programs—it simply obliterated the information without the option of
    retrieval.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 勒索软件类恶意软件的最早踪迹出现在计算机病毒 AIDS 中，该病毒首次在 1989 年在野外发现。AIDS 使用类似现代勒索软件的方法，通过覆盖文件开头的恶意代码来感染旧版
    MS-DOS COM 可执行文件，使其无法恢复。然而，AIDS 并没有要求受害者支付赎金以恢复访问受感染的程序——它只是彻底销毁了信息，且无法恢复。
- en: The first known malware to demand a ransom was the GpCode trojan, which first
    appeared in 2004\. It was famous for using a 660-bit RSA encryption algorithm
    to lock user files. Advances in integer factorization made it nearly feasible
    to factor 600-bit integers in 2004 (a cash prize was awarded in 2005 for the successful
    factoring of RSA-640, a 640-bit number). Subsequent modifications were upgraded
    with 1,024-bit RSA encryption, which improved the malware’s resilience against
    brute-force attacks. GpCode was spread via an email attachment purporting to be
    a job application. Once it was executed on the victim systems, it proceeded to
    encrypt user files and display the ransom message.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个已知要求支付赎金的恶意软件是GpCode Trojan，它首次出现在2004年。它因使用660位RSA加密算法锁定用户文件而闻名。整数因式分解的进展使得在2004年几乎能够对600位整数进行因式分解（2005年对成功分解RSA-640（一种640位数字）的人奖励了现金奖金）。随后的修改升级采用了1,024位RSA加密，提高了恶意软件对暴力破解攻击的抗性。GpCode通过伪装成求职申请的电子邮件附件进行传播。一旦在受害者系统上执行，它便开始加密用户文件并显示赎金信息。
- en: Despite these early appearances, ransomware wasn’t a widespread threat until
    2012, but it has remained prevalent ever since. One factor that likely played
    an important role in its growth was the rise in popularity of anonymized online
    services, such as Bitcoin payment systems and Tor. Ransomware developers could
    take advantage of such systems to collect ransom payments without being tracked
    by law enforcement organizations. This cybercrime business proved to be extremely
    profitable, resulting in varied development and wide distribution of ransomware.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管这些早期的勒索病毒出现了，但直到2012年勒索病毒才成为广泛的威胁，从那时起，它一直盛行。一个可能在其增长中起到了重要作用的因素是匿名在线服务的流行，如比特币支付系统和Tor网络。勒索病毒开发者能够利用这些系统收取赎金，而不被执法机构追踪到。这种网络犯罪业务证明了极其丰厚的利润，导致勒索病毒的多样化开发和广泛传播。
- en: The ransomware that kicked off the surge in 2012 was Reveton, which disguised
    itself as a message from a law enforcement organization tailored to a user’s location.
    For instance, victims in the United States were shown a message purporting to
    be from the FBI. The victims were accused of illegal activities, such as using
    copyrighted content without permission or viewing and distributing pornography,
    and instructed to pay a fine to services such as Ukash, Paysafe, or MoneyPak.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 2012年勒索病毒激增的起点是Reveton，它伪装成来自执法机构的消息，根据用户的位置量身定制。例如，在美国的受害者会看到一条伪装成FBI的消息。受害者被指控进行非法活动，如未经许可使用版权内容或观看和传播色情内容，并被指示支付罚款，通过如Ukash、Paysafe或MoneyPak等服务。
- en: Shortly after, more threats with similar functionality appeared in the wild.
    CryptoLocker, discovered in 2013, was the leading ransomware threat at that time.
    It used 2,048-bit RSA encryption and was mainly spread via compromised websites
    and email attachments. One of the interesting features of CryptoLocker was that
    its victims had to pay the ransom in the form of Bitcoin or prepaid cash vouchers.
    Using Bitcoin added another level of anonymity to the threat and made it extremely
    difficult to track the attackers.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 不久后，具有类似功能的更多威胁在野外出现。2013年发现的CryptoLocker，是当时领先的勒索病毒威胁。它使用了2,048位RSA加密，主要通过被攻陷的网站和电子邮件附件传播。CryptoLocker的一个有趣特点是，受害者必须以比特币或预付现金凭证的形式支付赎金。使用比特币为这种威胁增加了另一层匿名性，使追踪攻击者变得极其困难。
- en: Another remarkable piece of ransomware is CTB-Locker, which appeared in 2014\.
    CTB stands for *Curve/TOR/Bitcoin*, indicating the core technologies employed
    by the threat. CTB-Locker used the *Elliptic Curve Cryptography (ECC)* encryption
    algorithm and was the first known ransomware to use the TOR protocol to conceal
    C&C servers.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种显著的勒索病毒是CTB-Locker，它出现在2014年。CTB代表*Curve/TOR/Bitcoin*，指的是该威胁所使用的核心技术。CTB-Locker使用了*椭圆曲线加密算法（ECC）*，并且是已知的第一个使用TOR协议来隐藏C&C服务器的勒索病毒。
- en: The cybercrime business remains extremely profitable to this day, and ransomware
    continues to evolve, with many modifications regularly emerging. The ransomware
    families discussed here constitute only a small fraction of all the known threats
    in this class.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 网络犯罪业务至今仍然极为盈利，勒索病毒继续演化，许多修改版本不断出现。这里讨论的勒索病毒家族仅占所有已知威胁中的一小部分。
- en: '**Ransomware with Bootkit Functionality**'
  id: totrans-16
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**具有引导程序功能的勒索病毒**'
- en: 'In 2016, two new families of ransomware were discovered: Petya and Satana.
    Instead of encrypting user files in the filesystem, Petya and Satana encrypted
    parts of the hard drive to make the OS unbootable and displayed a message to victims
    demanding payment to restore the encrypted sectors. The easiest way to implement
    an interface to display a ransom message is to leverage MBR-based bootkit infection
    techniques.'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 2016年，发现了两种新的勒索病毒家族：Petya和Satana。与其加密文件系统中的用户文件不同，Petya和Satana加密了硬盘的一部分，导致操作系统无法启动，并显示一条消息，要求受害者支付赎金以恢复加密的扇区。实现显示赎金消息的最简单方法是利用基于MBR的引导病毒技术。
- en: Petya locked users out of their systems by encrypting the contents of the *master
    file table (MFT)* on the hard drive. The MFT is an essential, special data structure
    in the NTFS volume that contains information on all the files stored within it,
    like their location on the volume, their filenames, and other attributes. It is
    primarily used as an index for finding the locations of files on the hard drive.
    By encrypting the MFT, Petya ensured that files could not be located and that
    victims weren’t able to access files on the volume or even boot their system.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: Petya通过加密硬盘上*主文件表（MFT）*的内容，将用户锁定在系统之外。MFT是NTFS卷中的一个重要特殊数据结构，包含所有存储在其中的文件的信息，如它们在卷上的位置、文件名及其他属性。它主要作为查找硬盘上文件位置的索引。通过加密MFT，Petya确保了文件无法被定位，受害者无法访问卷上的文件，甚至无法启动系统。
- en: Petya was mainly distributed as a link in an email purporting to open a job
    application. The infected link actually pointed to the malicious ZIP archive containing
    the Petya dropper. The malware even used the legitimate service Dropbox to host
    the ZIP archives.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: Petya主要通过一封声称是工作申请的电子邮件链接进行传播。这个恶意链接实际上指向了一个包含Petya投放程序的恶意ZIP压缩包。该恶意软件甚至利用了合法的服务Dropbox来托管ZIP压缩包。
- en: Discovered shortly after Petya, Satana also deprived victims of access to their
    systems by encrypting the MBR of the hard drive. Though its MBR infection capabilities
    weren’t as sophisticated as Petya’s—and even contained a few bugs—they were interesting
    enough that Satana deserves a little discussion.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 在Petya之后不久发现的Satana也通过加密硬盘的MBR来使受害者无法访问他们的系统。尽管它的MBR感染能力不像Petya那样复杂——甚至包含一些漏洞——但它足够有趣，值得稍作讨论。
- en: '**SHAMOON: THE LOST TROJAN**'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: '**SHAMOON：失落的木马**'
- en: '*Shamoon* was a trojan that appeared around the same time as Satana and Petya
    and had similar functionality. It was notorious for destroying data on the targeted
    systems and rendering them unbootable. Its main purpose was to disrupt the services
    of targeted organizations, mostly in the energy and oil sector, but because it
    didn’t demand ransoms from its victims, it’s not discussed in detail here. Shamoon
    contained a component of a legitimate filesystem tool that it used to access the
    hard drive at a low level in order to overwrite user files, including the MBR
    sector, with chunks of its own data. This attack caused serious outages in many
    targeted organizations. It took a week for one of its victims—Saudi Aramco—to
    restore its services.'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: '*Shamoon*是一种木马，它与Satana和Petya大约同时出现，功能类似。它因在目标系统上销毁数据并使其无法启动而臭名昭著。它的主要目的是破坏目标组织的服务，主要针对能源和石油行业，但由于它没有要求受害者支付赎金，因此这里不做详细讨论。Shamoon包含一个合法文件系统工具的组件，用于以低级方式访问硬盘，从而覆盖用户文件，包括MBR扇区，用它自己的数据块替代。这种攻击导致了许多目标组织的严重停机。它的一个受害者——沙特阿美（Saudi
    Aramco）花了一周时间才恢复其服务。'
- en: '**The Ransomware Modus Operandi**'
  id: totrans-23
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**勒索病毒作案手法**'
- en: Before going into the technical analysis of Petya and Satana’s bootloader components,
    let’s take a high-level look at the way modern ransomware operates. Each family
    of ransomware has its own peculiarities that deviate slightly from the picture
    given here, but [Figure 13-1](ch13.xhtml#ch13fig01) reflects the most common pattern
    of ransomware operation.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 在深入分析Petya和Satana的引导程序组件之前，我们先从高层次了解一下现代勒索病毒的运作方式。每个勒索病毒家族都有一些偏离这里所示的典型模式的独特之处，但[图13-1](ch13.xhtml#ch13fig01)反映了勒索病毒操作最常见的模式。
- en: '![image](../images/13fig01.jpg)'
  id: totrans-25
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/13fig01.jpg)'
- en: '*Figure 13-1: Modus operandi of modern ransomware*'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: '*图13-1：现代勒索病毒的作案手法*'
- en: Shortly after being executed on the victim’s system, the ransomware generates
    a unique encryption key ➊ for a symmetric cipher—that is, any block or stream
    cipher (for example, AES, RC4, or RC5). This key, which we’ll refer to as the
    *file encryption key (FEK)*, is used to encrypt user files. The malware uses a
    (pseudo-) random number generator to generate a unique key that cannot be guessed
    or predicted.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 在被执行到受害者系统后不久，勒索软件会生成一个用于对称加密的唯一加密密钥 ➊——即任何块加密或流加密（例如AES、RC4或RC5）。这个密钥，我们称之为*文件加密密钥（FEK）*，用于加密用户文件。恶意软件使用一个（伪）随机数生成器生成一个独特的密钥，该密钥无法被猜测或预测。
- en: Once the file encryption key is generated, it’s transmitted to a C&C server
    ➋ for storage. To avoid interception by network traffic monitoring software, the
    malware encrypts the file encryption key with a public key embedded in the malware
    ➌, frequently using RSA encryption algorithms or ECC encryption, as is the case
    with CTB-Locker and Petya. This private key isn’t present in the malware body
    and is known only to the attackers, ensuring that no one else can access the file
    encryption key.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦文件加密密钥生成，它会被传送到C&C服务器 ➋ 进行存储。为了避免被网络流量监控软件拦截，恶意软件会使用嵌入在恶意软件中的公钥 ➌ 对文件加密密钥进行加密，通常使用RSA加密算法或ECC加密，如CTB-Locker和Petya所采用的方式。这把私钥不在恶意软件主体中，仅攻击者知晓，确保没有其他人能够访问文件加密密钥。
- en: Once the C&C server confirms receipt of the file encryption key, the malware
    proceeds to encrypt user files on the hard drive ➍. To reduce the volume of the
    files it needs to encrypt, the ransomware uses an embedded list of file extensions
    to filter out irrelevant files (executables, system files, and so forth), and
    encrypts only specific user files likely to be of greatest value to the victim,
    such as documents, images, and photos.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦C&C服务器确认收到文件加密密钥，恶意软件便开始加密硬盘上的用户文件 ➍。为了减少需要加密的文件量，勒索软件使用嵌入的文件扩展名列表来过滤掉无关的文件（如可执行文件、系统文件等），并只加密那些对受害者最有价值的特定用户文件，如文档、图像和照片。
- en: After encryption, the malware destroys the file encryption key on the victim’s
    system ➎, making it practically impossible for the user to recover the contents
    of the files without paying the ransom. At this point, the file encryption key
    typically exists only in the attacker’s C&C server, though in some cases an encrypted
    version of it is stored on the victim’s system. Even then, without knowing the
    private encryption key, it’s still practically impossible for the user to recover
    the file encryption key and restore access to the files.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 在加密后，恶意软件会摧毁受害者系统上的文件加密密钥 ➎，使得用户在不支付赎金的情况下几乎不可能恢复文件内容。此时，文件加密密钥通常只存在于攻击者的C&C服务器中，尽管在某些情况下，它的加密版本会存储在受害者的系统上。即便如此，如果不知道私有加密密钥，用户仍然几乎无法恢复文件加密密钥并恢复对文件的访问。
- en: Next, the malware shows the user a ransom message ➏ with instructions on how
    to pay the ransom. In some cases, the ransom message is embedded in the malware
    body, and in other cases, it retrieves a ransom page from the C&C server.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，恶意软件会向用户显示一条赎金信息 ➏，并附带支付赎金的说明。在某些情况下，赎金信息嵌入在恶意软件的主体中，而在其他情况下，它会从C&C服务器获取赎金页面。
- en: '**TORRENTLOCKER: A FATAL FLAW**'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: '**TORRENTLOCKER：致命缺陷**'
- en: Not all early ransomware was this impenetrable, due to flaws in the implementation
    of the encryption process. The early versions of TorrentLocker, for instance,
    used an Advanced Encryption Standard (AES) cipher in counter mode to encrypt files.
    In counter mode, the AES cipher generates a sequence of key characters, which
    is then XORed with the contents of the file to encrypt it. The weakness of this
    approach is that it yields the same key sequence for the same key and initialization
    value, regardless of the contents of the file. To recover the key sequence, a
    victim can XOR an encrypted file with the corresponding original version and then
    use this sequence to decrypt other files. After this discovery, TorrentLocker
    was updated to use the AES cipher in cipher block chaining (CBC) mode, eliminating
    the weakness. In CBC mode, before being encrypted, a plaintext block is XORed
    with the ciphertext block from the previous encryption iteration so that even
    a small difference in input data results in a significant difference in the encrypted
    result. This renders the data recovery approach against TorrentLocker ineffective.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 不是所有早期的勒索病毒都是如此难以破解的，因为加密过程的实现存在缺陷。例如，早期版本的TorrentLocker使用了高级加密标准（AES）加密算法的计数模式来加密文件。在计数模式下，AES加密算法生成一系列密钥字符，然后与文件内容进行异或（XOR）操作以加密文件。这个方法的弱点在于，它对于相同的密钥和初始化值生成相同的密钥序列，无论文件内容如何。为了恢复密钥序列，受害者可以将加密文件与对应的原始文件进行异或操作，然后使用这个序列来解密其他文件。发现这一点后，TorrentLocker被更新为使用AES加密算法的密码分组链接（CBC）模式，从而消除了这个弱点。在CBC模式下，在加密之前，明文块会与上一次加密迭代中的密文块进行异或操作，这样即使输入数据存在微小差异，最终的加密结果也会有显著不同。这使得通过恢复数据的方式来破解TorrentLocker变得无效。
- en: '**Analyzing the Petya Ransomware**'
  id: totrans-34
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**分析Petya勒索病毒**'
- en: In this section, we’ll focus on the technical analysis of the Petya hard drive
    encryption functionality. Petya arrives on the victim’s computer in the form of
    the malicious dropper, which, once executed, unpacks the payload containing the
    main ransomware functionality implemented as a DLL file.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将重点分析Petya硬盘加密功能的技术细节。Petya以恶意投放程序的形式进入受害者计算机，执行后会解压包含主要勒索病毒功能的有效载荷，这些功能实现为一个DLL文件。
- en: '***Acquiring Administrator Privileges***'
  id: totrans-36
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***获取管理员权限***'
- en: While most ransomware doesn’t require administrator privileges, Petya does in
    order to be able to write data directly onto the hard drive of the victim’s system.
    Without this privilege, Petya wouldn’t be able to modify the contents of the MBR
    and install the malicious bootloader. The dropper executable file contains a manifest
    specifying that the executable can be launched only with administrator privileges.
    [Listing 13-1](ch13.xhtml#ch13list01) shows an excerpt from the dropper’s manifest.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然大多数勒索病毒不需要管理员权限，但Petya确实需要管理员权限，以便能够直接向受害者系统的硬盘写入数据。如果没有此权限，Petya将无法修改MBR的内容并安装恶意引导加载程序。投放程序可执行文件包含一个清单，指定该可执行文件只能在管理员权限下启动。[清单13-1](ch13.xhtml#ch13list01)展示了来自投放程序清单的摘录。
- en: '[PRE0]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '*Listing 13-1: An excerpt from the Petya dropper’s manifest*'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单13-1：Petya投放程序清单摘录*'
- en: The security section contains the parameter `requestedExecutionLevel`, set to
    `requireAdministrator` ➊. When a user attempts to execute the dropper, the OS
    loader checks the user’s current execution level. If it is lower than `Administrator`,
    the OS displays a dialog asking whether the user wants to run the program with
    elevated privileges (if the user’s account has administrative privileges) or prompts
    for the administrator’s credentials (if the user account doesn’t have administrative
    privileges). If the user decides not to grant the application administrator privileges,
    the dropper won’t be launched and no damage will be done to the system. If the
    user is lured into executing the dropper with administrator privileges, the malware
    proceeds to infect the system.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 安全部分包含了参数`requestedExecutionLevel`，其值设置为`requireAdministrator` ➊。当用户尝试执行投放程序时，操作系统加载器会检查用户当前的执行级别。如果低于`Administrator`，操作系统会弹出对话框，询问用户是否希望以提升的权限运行该程序（如果用户的账户具有管理员权限），或者提示输入管理员凭据（如果用户账户没有管理员权限）。如果用户决定不授予该程序管理员权限，则投放程序不会启动，系统也不会受到损害。如果用户被引诱以管理员权限执行投放程序，恶意软件则会继续感染系统。
- en: Petya infects the system in two steps. In step 1, it gathers information on
    the target system, determines the type of partitioning used on the hard drive,
    generates its configuration information (encryption keys and ransomware message),
    constructs the malicious bootloader for step 2, and then infects the computer’s
    MBR with the malicious bootloader and initiates a system reboot.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: Petya 通过两步感染系统。在第一步中，它收集目标系统的信息，确定硬盘上使用的分区类型，生成其配置文件（加密密钥和勒索信息），构建第二步的恶意引导加载程序，然后用恶意引导加载程序感染计算机的
    MBR，并发起系统重启。
- en: After the reboot the malicious bootloader is executed, triggering the second
    step of the infection process. The malicious MBR bootloader encrypts the hard
    drive sectors that host the MFT and then reboots machine one more time. After
    the second reboot, the malicious bootloader shows the ransom message generated
    in step 1.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 重启后，恶意引导加载程序被执行，触发了感染过程的第二步。恶意的 MBR 引导加载程序加密了包含 MFT 的硬盘扇区，然后再次重启计算机。在第二次重启后，恶意引导加载程序显示了第一步生成的勒索消息。
- en: We’ll look at these steps in more detail in the following sections.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在接下来的章节中更详细地介绍这些步骤。
- en: '***Infecting the Hard Drive (Step 1)***'
  id: totrans-44
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***感染硬盘（第一步）***'
- en: Petya starts its infection of the MBR by getting the name of the file that represents
    the physical hard drive. On Windows operating systems, you can directly access
    the hard drive by executing the `CreateFile` API and passing it the string `'\\.\PhysicalDrive`X`'`
    as a filename parameter, where X corresponds to the index of the hard drive in
    the system. In the case of a system with a single hard drive, the filename of
    the physical hard drive is `'\\.\PhysicalDrive0'`. However, if there is more than
    one hard drive, the malware uses the index of the drive from which the system
    is booted.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: Petya 通过获取表示物理硬盘的文件名来启动 MBR 的感染过程。在 Windows 操作系统中，可以通过执行 `CreateFile` API，并传递字符串
    `'\\.\PhysicalDrive`X`'` 作为文件名参数来直接访问硬盘，其中 X 对应硬盘在系统中的索引。如果系统中只有一个硬盘，则物理硬盘的文件名为
    `'\\.\PhysicalDrive0'`。然而，如果有多个硬盘，恶意软件则使用系统启动的硬盘的索引。
- en: Petya accomplishes this by sending the special request `IOCTL_VOLUME_GET_VOLUME_DISK_EXTENTS`
    to the NTFS volume that contains the current instance of Windows, which it gets
    by executing the `DeviceIoControl` API. This request returns an array of structures
    that describe all the hard drives used to host the NTFS volume. More specifically,
    this request returns an array of NTFS volume extents. A *volume extent* is a contiguous
    run of sectors on one disk. For instance, a single NTFS volume might be hosted
    on two hard drives, in which case this request will return an array of two extents.
    The layout of the returned structures is shown in [Listing 13-2](ch13.xhtml#ch13list02).
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: Petya 通过向包含当前 Windows 实例的 NTFS 卷发送特殊请求 `IOCTL_VOLUME_GET_VOLUME_DISK_EXTENTS`
    来实现这一过程，恶意软件通过执行 `DeviceIoControl` API 获取此请求。此请求返回一个结构体数组，描述了用于托管 NTFS 卷的所有硬盘。更具体地说，这个请求返回一个
    NTFS 卷范围的数组。*卷范围*是指在一个硬盘上连续的扇区范围。例如，单一 NTFS 卷可能托管在两个硬盘上，在这种情况下，此请求将返回包含两个范围的数组。返回的结构体布局如
    [Listing 13-2](ch13.xhtml#ch13list02) 所示。
- en: '[PRE1]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '*Listing 13-2: The `DISK_EXTENT` layout*'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: '*Listing 13-2: `DISK_EXTENT` 布局*'
- en: The `StartingOffset` field ➋ describes the position of the volume extent on
    the hard drive as the offset from the beginning of the hard drive in sectors,
    and `ExtentLength` ➌ provides its length. The `DiskNumber` parameter ➊ contains
    the index of the corresponding hard drive in the system, which also corresponds
    to the index in the filename for the hard drive. The malware uses the `DiskNumber`
    field of the very first structure in the returned array of the volume extents
    to construct the filename and access the hard drive.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: '`StartingOffset` 字段 ➋ 描述了硬盘上卷范围的位置，表示从硬盘开始位置的扇区偏移量，而 `ExtentLength` ➌ 提供了它的长度。`DiskNumber`
    参数 ➊ 包含了系统中对应硬盘的索引，这个索引也与硬盘文件名中的索引相对应。恶意软件使用返回的卷范围数组中第一个结构体的 `DiskNumber` 字段来构建文件名并访问硬盘。'
- en: After constructing the filename for the physical hard drive, the malware determines
    the partitioning scheme of the hard drive with the request `IOCTL_DISK_GET_PARTITION_INFO_EX`,
    sent to the hard drive.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 在构建了物理硬盘的文件名后，恶意软件通过向硬盘发送请求 `IOCTL_DISK_GET_PARTITION_INFO_EX` 来确定硬盘的分区方案。
- en: Petya is capable of infecting hard drives with either MBR-based partitions or
    GUID Partition Table (GPT) partitions (the layout of the GPT partition is described
    in [Chapter 14](ch14.xhtml#ch14)). First we’ll look at how Petya infects MBR-based
    hard drives, and then we’ll describe the particulars of the GPT-based disk infection.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: Petya能够感染基于MBR的分区或GUID分区表（GPT）分区的硬盘（GPT分区的布局在[第14章](ch14.xhtml#ch14)中描述）。我们首先将查看Petya如何感染基于MBR的硬盘，然后描述基于GPT的磁盘感染细节。
- en: '**Infecting the MBR Hard Drive**'
  id: totrans-52
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**感染MBR硬盘**'
- en: To infect an MBR partitioning scheme, Petya first reads the MBR to calculate
    the amount of free disk space between the beginning of the hard drive and the
    beginning of the very first partition. This space is used to store the malicious
    bootloader and its configuration information. Petya retrieves the starting sector
    number of the very first partition; if it starts at a sector with an index less
    than 60 (0x3C), it means there’s not enough space on the hard drive, so Petya
    stops the infection process and exits.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 为了感染MBR分区方案，Petya首先读取MBR，以计算硬盘开始部分与第一个分区开始部分之间的空闲磁盘空间。该空间用于存储恶意引导程序及其配置信息。Petya获取第一个分区的起始扇区号；如果该分区起始的扇区索引小于60（0x3C），则表示硬盘上没有足够的空间，Petya会停止感染过程并退出。
- en: 'If the index is 60 or more, there is enough space and the malware proceeds
    with constructing the malicious bootloader, which consists of two components:
    the malicious MBR code and the second-stage bootloader. [Figure 13-2](ch13.xhtml#ch13fig02)
    shows the layout of the first 57 sectors of the hard drive after infection.'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 如果索引为60或以上，则表示有足够的空间，恶意软件会继续构建恶意引导程序，该引导程序由两个组件组成：恶意MBR代码和二阶段引导程序。[图13-2](ch13.xhtml#ch13fig02)显示了感染后硬盘前57个扇区的布局。
- en: '![image](../images/13fig02.jpg)'
  id: totrans-55
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/13fig02.jpg)'
- en: '*Figure 13-2: Layout of the hard drive sectors with Petya infection for MBR
    disks*'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: '*图13-2：Petya感染MBR硬盘的扇区布局*'
- en: To construct the malicious MBR, Petya combines the partition table of the original
    MBR with the malicious MBR code, writing the result to the very first sector of
    the hard drive ➊ in place of the original MBR. The original MBR is XORed with
    a fixed byte value of 0x37, and the result is written to sector 56 ➏.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 为了构建恶意MBR，Petya将原始MBR的分区表与恶意MBR代码结合，将结果写入硬盘的第一个扇区 ➊，替换掉原始MBR。原始MBR会与固定字节值0x37进行异或运算，结果写入第56扇区
    ➏。
- en: The second-stage malicious bootloader occupies 17 contiguous sectors (0x2E00
    bytes) of the disk space and is written on the hard drive in sectors 34 to 50
    ➌. The malware also obfuscates sectors 1 to 33 ➋ by XORing its contents with the
    fixed byte value 0x37.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 二阶段的恶意引导程序占据了17个连续扇区（0x2E00字节）的磁盘空间，并写入硬盘的34至50扇区 ➌。恶意软件还通过将扇区1至33 ➋的内容与固定字节值0x37进行异或运算来混淆这些扇区。
- en: The configuration data for the malicious bootloader is stored in sector 54 ➍
    and is used by the bootloader in step 2 of the infection process. We’ll dive into
    the details of the configuration data structure in “[Encrypting with the Malicious
    Bootloader Configuration Data](ch13.xhtml#ch13lev2sec3)” on [page 215](ch13.xhtml#page_215).
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 恶意引导程序的配置信息存储在第54扇区 ➍，并由引导程序在感染过程的第二步中使用。我们将在“[使用恶意引导程序配置数据加密](ch13.xhtml#ch13lev2sec3)”中详细讨论配置数据结构，详见[第215页](ch13.xhtml#page_215)。
- en: Petya also uses sector 55 ➎ to store a 512-byte buffer filled with 0x37 byte
    values, which will be used to validate the victim-provided password and unlock
    the hard drive, as we’ll discuss in “[Displaying the Ransom Message](ch13.xhtml#ch13lev3sec12)”
    on [page 224](ch13.xhtml#page_224).
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: Petya还使用第55扇区 ➎存储一个512字节的缓冲区，填充了0x37字节值，该缓冲区将用于验证受害者提供的密码并解锁硬盘，具体内容将在“[显示勒索信息](ch13.xhtml#ch13lev3sec12)”中讨论，详见[第224页](ch13.xhtml#page_224)。
- en: With that, the infection of the MBR is complete. Although in [Figure 13-2](ch13.xhtml#ch13fig02)
    sector 57 ➐ is marked “Encrypted clusters counter,” this isn’t used at this stage
    of infection. It will be used by the malicious bootloader code in step 2 to store
    the number of the MFT’s encrypted clusters.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 至此，MBR的感染已经完成。虽然在[图13-2](ch13.xhtml#ch13fig02)中，第57扇区 ➐标记为“加密簇计数器”，但在当前感染阶段并未使用它。恶意引导程序代码将在步骤2中使用它来存储MFT的加密簇数量。
- en: '**Infecting the GPT Hard Drive**'
  id: totrans-62
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**感染GPT硬盘**'
- en: The GPT hard drive infection process is similar to MBR hard drive infection,
    but with a few extra steps. The first additional step encrypts the backup copy
    of the GPT header to make system recovery more difficult. The GPT header holds
    information about the layout of the GPT hard drive, and this backup copy enables
    the system to recover the GPT header in the event that it’s corrupted or invalid.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: GPT硬盘感染过程类似于MBR硬盘感染，但有几个额外的步骤。第一个额外步骤是加密GPT头的备份副本，以使系统恢复变得更加困难。GPT头包含有关GPT硬盘布局的信息，这个备份副本使得系统在GPT头损坏或无效时能够恢复GPT头。
- en: To find the backup GPT header, Petya reads the sector at offset 1 from the hard
    drive that contains the GPT header, then reaches into the field that contains
    the offset of the backup copy.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 为了找到备份GPT头，Petya读取硬盘中包含GPT头的扇区的偏移量1处的扇区，然后进入包含备份副本偏移量的字段。
- en: Once it has the location, Petya obfuscates the backup GPT header, as well as
    the 32 sectors preceding it, by XORing them with the fixed constant 0x37, as shown
    in [Figure 13-3](ch13.xhtml#ch13fig03) ➊. These sectors contain the backup GPT.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦获取位置，Petya通过将其与固定常数0x37进行异或处理，混淆备份GPT头以及它之前的32个扇区，如[图13-3](ch13.xhtml#ch13fig03)
    ➊所示。这些扇区包含备份GPT。
- en: '![image](../images/13fig03.jpg)'
  id: totrans-66
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/13fig03.jpg)'
- en: '*Figure 13-3: Layout of the hard drive sectors with Petya infection for GPT
    disks*'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: '*图13-3：GPT磁盘上Petya感染后的硬盘扇区布局*'
- en: Since the layout of the hard drive is different for a GPT partitioning scheme
    than for MBR partitioning, Petya cannot simply reuse the GPT partition table as
    is to construct the malicious MBR (as it does in the case of the MBR hard drive).
    Instead, it manually constructs an entry in the partition table of the infected
    MBR that represents the whole hard drive.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 由于GPT分区方案与MBR分区方案的硬盘布局不同，Petya不能像在MBR硬盘的情况中那样简单地重复使用GPT分区表来构建恶意MBR。相反，它手动构建了一个表示整个硬盘的MBR感染分区表条目。
- en: Apart from these points, the infection of a GPT hard drive is exactly the same
    as that of MBR disks. However, it’s important to note that this approach won’t
    work on systems with UEFI boot enabled. As you’ll learn in [Chapter 14](ch14.xhtml#ch14),
    in a UEFI boot process, UEFI code (rather than the MBR code) is responsible for
    booting the system. If Petya is executed on a UEFI system, it will simply render
    the system unbootable, because the UEFI loader won’t be able to read the encrypted
    GPT or its backup copy to determine the location of the OS loader.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 除了这些点外，GPT硬盘的感染与MBR磁盘的感染完全相同。然而，值得注意的是，这种方法在启用了UEFI启动的系统上不起作用。正如你在[第14章](ch14.xhtml#ch14)中将学到的，在UEFI启动过程中，UEFI代码（而非MBR代码）负责启动系统。如果Petya在UEFI系统上执行，它会使系统无法启动，因为UEFI加载程序无法读取加密的GPT或其备份副本，以确定操作系统加载程序的位置。
- en: The Petya infection *will* work on hybrid systems that use legacy BIOS boot
    code and a GPT partitioning scheme—for instance, when the BIOS Compatibility Support
    Mode is enabled—since on such systems the MBR sector is still used to store the
    first-stage system bootloader code but is modified to recognize GPT partitions.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: Petya感染*将*在使用传统BIOS启动代码和GPT分区方案的混合系统上起作用——例如，当启用BIOS兼容性支持模式时——因为在这样的系统中，MBR扇区仍然用于存储第一阶段系统引导加载程序代码，但会修改以识别GPT分区。
- en: '***Encrypting with the Malicious Bootloader Configuration Data***'
  id: totrans-71
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***使用恶意引导加载程序配置数据进行加密***'
- en: We mentioned that during step 1 of the infection process, Petya writes the bootloader
    configuration data to sector 54 of the hard drive. The bootloader uses this data
    to complete the encryption of the hard drive’s sectors. Let’s look how this data
    is generated.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 我们提到，在感染过程的第1步中，Petya将引导加载程序配置数据写入硬盘的第54扇区。引导加载程序使用这些数据完成硬盘扇区的加密。我们来看一下这些数据是如何生成的。
- en: The configuration data structure is shown in [Listing 13-3](ch13.xhtml#ch13list03).
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 配置数据结构如[清单13-3](ch13.xhtml#ch13list03)所示。
- en: '[PRE2]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '*Listing 13-3: Petya configuration data layout*'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单13-3：Petya配置数据布局*'
- en: The structure starts with a flag ➊ indicating whether the MFT of the hard drive
    is encrypted or not. During step 1 of the infection process, the malware clears
    this flag, since no MFT encryption takes place at this stage. This flag is set
    by the malicious bootloader in step 2, once it starts the MFT encryption. Following
    the flag are the encryption key ➋ and initialization value (IV) ➌ used for encrypting
    the MFT, which we’ll go over next.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 该结构以一个标志 ➊ 开始，指示硬盘的 MFT 是否已加密。在感染过程的第 1 步中，恶意软件会清除这个标志，因为此时并不会进行 MFT 加密。这个标志在第
    2 步中由恶意引导加载程序设置，一旦它开始执行 MFT 加密。接下来的部分是用于加密 MFT 的加密密钥 ➋ 和初始化值（IV） ➌，我们将进一步讲解这些内容。
- en: '**Generating Cryptographic Keys**'
  id: totrans-77
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**生成加密密钥**'
- en: To implement cryptographic functionality, Petya uses the public library mbedtls
    (“embedded TLS”), intended for use in embedded solutions. This tiny library implements
    a wide variety of modern cryptographic algorithms for symmetric and asymmetric
    data encryption, hash functions, and more. Its small memory footprint is ideal
    for the limited resources available at the stage of the malicious bootloader where
    MFT encryption takes place.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 为了实现加密功能，Petya 使用了公共库 mbedtls（“嵌入式 TLS”），该库专为嵌入式解决方案设计。这个小巧的库实现了多种现代加密算法，包括对称和非对称数据加密、哈希函数等。它的小内存占用非常适合在恶意引导加载程序阶段使用
    MFT 加密时的有限资源。
- en: One of Petya’s most interesting features is that it uses the rare Salsa20 cipher
    to encrypt the MFT. This cipher generates a stream of key characters that are
    XORed with plaintext to obtain a ciphertext, and it takes as input a 256-bit key
    and a 64-bit initialization value. For the public key encryption algorithm, Petya
    uses ECC. [Figure 13-4](ch13.xhtml#ch13fig04) shows a high-level view of the process
    for generating cryptographic keys.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: Petya 最有趣的特点之一是它使用了罕见的 Salsa20 加密算法来加密 MFT。这个算法生成一个密钥字符流，通过与明文进行异或操作来得到密文，它的输入是一个
    256 位的密钥和一个 64 位的初始化值。对于公钥加密算法，Petya 使用了 ECC。[Figure 13-4](ch13.xhtml#ch13fig04)
    展示了生成加密密钥过程的高级视图。
- en: To generate the Salsa20 encryption key, the malware first generates a password—a
    16-byte random string of alphanumerical characters ➊. Petya then expands this
    string into a 32-byte Salsa20 key ➋ using the algorithm presented in [Listing
    13-4](ch13.xhtml#ch13list04), which encrypts the content of MFT sectors on the
    hard drive. The malware also generates a 64-bit nonce (initialization value) for
    Salsa20 using a pseudorandom-number generator.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 为了生成 Salsa20 加密密钥，恶意软件首先生成一个密码——一个包含字母数字字符的 16 字节随机字符串 ➊。然后，Petya 使用 [Listing
    13-4](ch13.xhtml#ch13list04) 中介绍的算法，将这个字符串扩展成一个 32 字节的 Salsa20 密钥 ➋，该密钥用于加密硬盘上
    MFT 扇区的内容。恶意软件还通过伪随机数生成器为 Salsa20 生成一个 64 位的 nonce（初始化值）。
- en: '[PRE3]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '*Listing 13-4: Expanding the password into a Salsa20 encryption key*'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: '*Listing 13-4: 将密码扩展为 Salsa20 加密密钥*'
- en: Next, Petya generates the key for the ransom message as a string to be displayed
    on the ransom page. A victim must provide this ransom key to the C&C server in
    order to get the password to decrypt the MFT.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，Petya 生成一个用于赎金信息的密钥，这个密钥作为字符串显示在赎金页面上。受害者必须将这个赎金密钥提供给 C&C 服务器，才能获得解密 MFT
    的密码。
- en: '**Generating the Ransom Key**'
  id: totrans-84
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**生成赎金密钥**'
- en: Only the attacker should be able to retrieve the password from the ransom key,
    so in order to protect it, Petya uses the ECC public key encryption scheme, which
    is embedded in the malware. We will refer to this public key as the C&C public
    key `ecc_cc_public_key`.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 只有攻击者能够从赎金密钥中提取密码，因此为了保护它，Petya 使用了内嵌在恶意软件中的 ECC 公钥加密方案。我们将这个公钥称为 C&C 公钥 `ecc_cc_public_key`。
- en: '![image](../images/13fig04.jpg)'
  id: totrans-86
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/13fig04.jpg)'
- en: '*Figure 13-4: Generating an encryption key*'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: '*Figure 13-4: 生成加密密钥*'
- en: 'First, Petya generates a temporary ECC key pair ➌, known as an *ephemeral key*,
    on the victim’s system to establish secure communication with the C&C server:
    `ecc_ephemeral_pub` and `ecc_ephemeral_priv`.'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，Petya 在受害者的系统上生成一个临时的 ECC 密钥对 ➌，即 *临时密钥*，用来与 C&C 服务器建立安全通信：`ecc_ephemeral_pub`
    和 `ecc_ephemeral_priv`。
- en: 'Next, it generates a shared secret (that is, a shared key) using the ECC Diffie-Hellman
    key agreement algorithm ➍. This algorithm allows two parties to share a secret
    known only to them, and any adversary eavesdropping would not be able to deduce
    it. On the victim’s computer, the shared secret is computed as `shared_secret
    = ECDHE(ecc_ephemeral_priv, ecc_cc_public_key)`, where `ECDHE` is the Diffie-Hellman
    key agreement routine. It takes two parameters: the private ephemeral key of the
    victim and the public C&C key embedded in the malware. The same secret is computed
    by the attacker as `shared_secret = ECDHE(ecc_ephemeral_pub, ecc_cc_private_key)`,
    where it takes its own private C&C key and the victim’s public ephemeral key.'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，它使用ECC Diffie-Hellman密钥交换算法 ➍生成共享密钥（即共享秘密）。该算法允许双方共享一个只有他们知道的秘密，任何窃听的对手都无法推测出来。在受害者的计算机上，共享秘密的计算方式是`shared_secret
    = ECDHE(ecc_ephemeral_priv, ecc_cc_public_key)`，其中`ECDHE`是Diffie-Hellman密钥交换过程。它需要两个参数：受害者的私有临时密钥和嵌入恶意软件中的公共C&C密钥。攻击者使用`shared_secret
    = ECDHE(ecc_ephemeral_pub, ecc_cc_private_key)`计算出相同的秘密，其中它使用自己的私有C&C密钥和受害者的公共临时密钥。
- en: 'Once the `shared_secret` is generated, the malware computes its hash value
    with the SHA512 hashing algorithm and uses the first 32 bytes of the hash as an
    AES key ➎: `aes_key = SHA512(shared_secret)[0:32]`.'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦生成了`shared_secret`，恶意软件使用SHA512哈希算法计算其哈希值，并使用哈希的前32个字节作为AES密钥 ➎：`aes_key =
    SHA512(shared_secret)[0:32]`。
- en: 'Then it encrypts the password ➏ as follows, using the `aes_key` it just derived:
    `encrypted_password = AES(aes_key XOR password)`. As you can see, before encrypting
    the password, the malware XORs the password with the AES key.'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，它使用刚刚导出的`aes_key`加密密码 ➏，如下所示：`encrypted_password = AES(aes_key XOR password)`。正如你所看到的，在加密密码之前，恶意软件会将密码与AES密钥进行异或操作。
- en: 'Finally, Petya encodes the ephemeral public key and the encrypted password
    using a base58 encoding algorithm to obtain an ASCII string that is used as the
    ransom key ➐: `ransom_key = base58_encode(ecc_ephemeral_pub, encrypted_password)`.'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，Petya使用base58编码算法对临时公钥和加密密码进行编码，以获得一个ASCII字符串，作为赎金密钥 ➐：`ransom_key = base58_encode(ecc_ephemeral_pub,
    encrypted_password)`。
- en: '**Verifying the Ransom Key**'
  id: totrans-93
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**验证赎金密钥**'
- en: If the user pays the ransom, the attacker provides the password to decrypt the
    data, so let’s look at how the attacker validates the ransom key to recover the
    victim’s password.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 如果用户支付赎金，攻击者会提供解密数据的密码，因此我们来看看攻击者如何验证赎金密钥以恢复受害者的密码。
- en: 'Once the victim sends the ransom key to the attackers, Petya decodes it using
    a `base58` decoding algorithm and obtains the victim’s public ephemeral key and
    encrypted password: `ecc_ephemeral_pub, encrypted_password = base58_decode(ransom_key)`
    ➑.'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦受害者将赎金密钥发送给攻击者，Petya使用`base58`解码算法对其进行解码，并获得受害者的公共临时密钥和加密密码：`ecc_ephemeral_pub,
    encrypted_password = base58_decode(ransom_key)` ➑。
- en: 'The attacker then computes the shared secret using the `ECDHE` key agreement
    protocol as described in the previous section: `shared_secret = ECDHE(ecc_ephemeral_pub,
    ecc_cc_private_key)` ➒.'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 攻击者接着使用前述的`ECDHE`密钥交换协议计算共享秘密：`shared_secret = ECDHE(ecc_ephemeral_pub, ecc_cc_private_key)`
    ➒。
- en: 'With the shared secret, the attacker can derive the AES encryption key by computing
    the SHA512 hash of the shared secret the same way as before: `aes_key = SHA512(shared_secret)[0:32]`
    ➓.'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 使用共享秘密，攻击者可以通过计算共享秘密的SHA512哈希值来推导AES加密密钥，方法与之前相同：`aes_key = SHA512(shared_secret)[0:32]`
    ➓。
- en: Once the AES key is computed, the attacker can decrypt the password and get
    the victim’s password as `password=AES_DECRYPT(encrypted_password) XOR aes_key`.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦计算出AES密钥，攻击者就可以解密密码，并得到受害者的密码：`password=AES_DECRYPT(encrypted_password) XOR
    aes_key`。
- en: The attacker has now obtained the victim’s password from the ransom key, which
    no one else can do without the attacker’s private key.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 攻击者现在已经通过赎金密钥获得了受害者的密码，其他人如果没有攻击者的私钥是无法做到这一点的。
- en: '**Generating Ransom URLs**'
  id: totrans-100
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**生成赎金URL**'
- en: As the final piece of configuration information for the second stage of the
    bootloader, Petya generates ransom URLs to be shown in the ransom message that
    tells the victim how to pay the ransom and recover the system’s data. The malware
    randomly generates an alphanumerical victim ID, and then combines it with the
    malicious domain name to get URLs in the form *http://<malicious_domain>/<victim_id>*.
    [Figure 13-5](ch13.xhtml#ch13fig05) shows a couple of example URLs.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 作为第二阶段引导加载程序的最终配置数据，Petya 生成勒索 URL，这些 URL 会显示在勒索信息中，告诉受害者如何支付赎金并恢复系统的数据。恶意软件随机生成一个字母数字组合的受害者
    ID，然后将其与恶意域名结合，生成形如 *http://<malicious_domain>/<victim_id>* 的 URL。[图 13-5](ch13.xhtml#ch13fig05)
    展示了一些示例 URL。
- en: '![image](../images/13fig05.jpg)'
  id: totrans-102
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/13fig05.jpg)'
- en: '*Figure 13-5: Petya configuration data with ransom URLs*'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 13-5：Petya 配置数据与勒索 URL*'
- en: You can see that the top-level domain name is *.onion*, which implies that the
    malware uses TOR to generate the URLs.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以看到顶级域名是 *.onion*，这意味着恶意软件使用 TOR 来生成这些 URL。
- en: '***Crashing the System***'
  id: totrans-105
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***使系统崩溃***'
- en: Once the malicious bootloader and its configuration data are written onto the
    hard drive, Petya crashes the system and forces a reboot so that it can execute
    the malicious bootloader and complete the infection of the system. [Listing 13-5](ch13.xhtml#ch13list05)
    shows how this is done.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦恶意引导加载程序及其配置数据被写入硬盘，Petya 会使系统崩溃并强制重启，以便它可以执行恶意引导加载程序并完成系统的感染。[清单 13-5](ch13.xhtml#ch13list05)展示了如何完成这一步。
- en: '[PRE4]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '*Listing 13-5: The Petya routine to force a system restart*'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 13-5：Petya 强制系统重启的例程*'
- en: Petya executes the system API routine `NtRaiseHardError` ➋ to crash the system,
    which notifies the system of a serious error preventing normal operation and requiring
    a reboot to avoid data loss or damage.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: Petya 执行系统 API 例程 `NtRaiseHardError` ➋ 来使系统崩溃，这会通知系统发生严重错误，阻止正常操作，并要求重启以避免数据丢失或损坏。
- en: To execute this routine, the calling process needs the privilege `SeShutdownPrivilege`,
    which is easily obtained given that Petya is launched with administrator account
    rights. As shown in [Listing 13-5](ch13.xhtml#ch13list05), before executing `NtRaiseHardError`,
    Petya adjusts the current privileges by calling `AdjustTokenPrivileges` ➊.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 要执行此例程，调用进程需要特权 `SeShutdownPrivilege`，由于 Petya 是以管理员帐户权限启动的，因此这一特权很容易获得。如[清单
    13-5](ch13.xhtml#ch13list05)所示，在执行 `NtRaiseHardError` 之前，Petya 通过调用 `AdjustTokenPrivileges`
    ➊ 调整当前的特权。
- en: '***Encrypting the MFT (Step 2)***'
  id: totrans-111
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***加密 MFT（步骤 2）***'
- en: 'Now let’s focus on the second step of the infection process. The bootloader
    consists of two components: a malicious MBR and the second-stage bootloader (which
    we’ll refer to as the malicious bootloader in this section). The only purpose
    of the malicious MBR code is to load the second-stage bootloader into memory and
    execute it, so we’ll skip an analysis of the malicious MBR. The second-stage bootloader
    implements the most interesting functionality of the ransomware.'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们关注感染过程的第二步。引导加载程序由两个组件组成：恶意 MBR 和第二阶段引导加载程序（在本节中我们将其称为恶意引导加载程序）。恶意 MBR
    代码的唯一目的是将第二阶段引导加载程序加载到内存中并执行它，因此我们将跳过对恶意 MBR 的分析。第二阶段引导加载程序实现了勒索软件最有趣的功能。
- en: '**Finding Available Disks**'
  id: totrans-113
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**查找可用磁盘**'
- en: Once the bootloader receives control, it must gather information on the available
    disks in the system. To do so, it relies on the well-known INT 13h service, as
    shown in [Listing 13-6](ch13.xhtml#ch13list06).
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦引导加载程序接管控制权，它必须收集系统中可用磁盘的信息。为此，它依赖于广为人知的 INT 13h 服务，如[清单 13-6](ch13.xhtml#ch13list06)所示。
- en: '[PRE5]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '*Listing 13-6: Using INT 13h to check the availability of disks in system*'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 13-6：使用 INT 13h 检查系统中磁盘的可用性*'
- en: To check for the availability and size of the hard drives, the malware stores
    the index numbers in the `dl` register ➊ and then executes INT 13h. The disks
    are assigned index numbers sequentially, so Petya finds hard drives in the system
    by checking disk indexes from 0 through 15\. Next, it moves the value 8 into the
    `ah` register ➋, which denotes the “get current drive parameters” function of
    INT 13h. Then the malware executes INT 13h. After execution, if `ah` is set to
    `0`, the specified disk is present in the system and the `dx` and `cx` registers
    contain disk size information. If the `ah` register isn’t equal to `0`, it means
    that the disk with the given index doesn’t exist in the system.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 为了检查硬盘的可用性和大小，恶意软件将索引号存储在 `dl` 寄存器中 ➊，然后执行 INT 13h。磁盘按顺序分配索引号，因此 Petya 会通过检查从
    0 到 15 的磁盘索引来查找系统中的硬盘。接着，它将值 8 移入 `ah` 寄存器 ➋，这表示 INT 13h 的“获取当前驱动器参数”功能。然后，恶意软件执行
    INT 13h。执行后，如果 `ah` 设置为 `0`，则说明指定的磁盘存在于系统中，并且 `dx` 和 `cx` 寄存器包含磁盘大小信息。如果 `ah`
    寄存器不等于 `0`，则表示给定索引的磁盘在系统中不存在。
- en: Next, the malicious bootloader reads the configuration data from sector 54 and
    checks whether the MFT of the hard drives is encrypted by looking at the very
    first byte in the read buffer, which corresponds to the `EncryptionStatus` field
    in the configuration data. If the flag is clear—meaning that the contents of the
    MFT aren’t encrypted—the malware proceeds to encrypt the MFT of the hard drives
    available in the system, completing the infection process. If the MFT is already
    encrypted, the malicious bootloader shows the ransom message to the victim. We’ll
    discuss the ransom message shortly, but first, we’ll focus on how the malicious
    bootloader performs the encryption.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，恶意引导程序从第 54 扇区读取配置数据，并检查通过查看读取缓冲区中的第一个字节来判断硬盘的 MFT 是否已加密，该字节对应于配置数据中的 `EncryptionStatus`
    字段。如果标志清除——意味着 MFT 内容未加密——恶意软件将继续加密系统中可用硬盘的 MFT，完成感染过程。如果 MFT 已加密，恶意引导程序将向受害者显示赎金消息。我们稍后将讨论赎金消息，但首先，我们将重点介绍恶意引导程序如何执行加密操作。
- en: '**Encrypting the MFT**'
  id: totrans-119
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**加密 MFT**'
- en: If the `EncryptionStatus` flag of the configuration data is clear (that is,
    set to `0`), the malware reads the Salsa20 encryption key and the IV from the
    `SalsaKey` and `SalsaNonce` parameters, respectively, and uses them to encrypt
    the hard drive data. The bootloader then sets the `EncryptionStatus` flag and
    destroys `SalsaKey` in the section 54 configuration data to prevent decryption
    of the data.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 如果配置数据的 `EncryptionStatus` 标志清除（即设置为 `0`），恶意软件会从 `SalsaKey` 和 `SalsaNonce` 参数中分别读取
    Salsa20 加密密钥和 IV，并用它们加密硬盘数据。然后，引导程序设置 `EncryptionStatus` 标志，并销毁配置数据第 54 节中的 `SalsaKey`，以防止数据被解密。
- en: Next, the bootloader reads sector 55 of the infected hard drive, which will
    later be used to validate the password entered by the victim. At this point, this
    sector occupies 0x37 bytes. Petya encrypts this sector with the Salsa20 algorithm
    using the key and the IV read from the configuration data, then writes the result
    back into sector 55.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，引导程序读取感染硬盘的第 55 扇区，该扇区稍后将用于验证受害者输入的密码。此时，该扇区占用 0x37 字节。Petya 使用从配置数据中读取的密钥和
    IV，通过 Salsa20 算法加密此扇区，然后将结果写回第 55 扇区。
- en: Now the malicious bootloader is ready to encrypt the MFT of the hard drives
    in the system. The encryption process extends the duration of the boot process
    considerably, so in order to avoid arousing suspicion, Petya displays a fake `chkdsk`
    message, as shown in [Figure 13-6](ch13.xhtml#ch13fig06). The system utility `chkdsk`
    is used to repair filesystems on the hard drive, and it’s not unusual to see a
    `chkdsk` message after a system crash. With the fake message on the screen, the
    malware runs the following algorithm for each hard drive available in the system.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，恶意引导程序已经准备好加密系统中硬盘的 MFT。加密过程大大延长了引导过程的时间，因此，为了避免引起怀疑，Petya 显示了一个假的 `chkdsk`
    消息，如[图 13-6](ch13.xhtml#ch13fig06)所示。系统工具 `chkdsk` 用于修复硬盘上的文件系统，系统崩溃后看到 `chkdsk`
    消息并不罕见。屏幕上显示虚假的消息时，恶意软件会对系统中每个硬盘执行以下算法。
- en: '![image](../images/13fig06.jpg)'
  id: totrans-123
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/13fig06.jpg)'
- en: '*Figure 13-6: A fake `chkdsk` message*'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 13-6：一个虚假的 `chkdsk` 消息*'
- en: First, the malware reads the MBR of the hard drive and iterates through the
    MBR partition table, looking for available partitions. It checks the parameter
    describing the type of the filesystem used in the partition and skips all the
    partitions with a type value other than 0x07 (indicating that the partition contains
    an NTFS volume), 0xEE, and 0xEF (indicating that the hard drive has a GPT layout).
    If the hard drive does have a GPT layout, the malicious boot code obtains the
    location of the partition from the GPT partition table.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，恶意软件读取硬盘的MBR，并遍历MBR分区表，寻找可用的分区。它检查描述分区使用的文件系统类型的参数，并跳过所有类型值不是0x07（表示分区包含NTFS卷）、0xEE和0xEF（表示硬盘采用GPT布局）的分区。如果硬盘确实具有GPT布局，恶意引导代码将从GPT分区表获取分区的位置。
- en: '**Parsing the GPT Partition Table**'
  id: totrans-126
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**解析GPT分区表**'
- en: 'In the case of GPT partition tables, the malware takes an additional step to
    find partitions on the hard drive: it reads the GPT partition table from the hard
    drive, starting at the third sector. Each entry in the GPT partition table is
    128 bytes long and is structured as shown in [Listing 13-7](ch13.xhtml#ch13list07).'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 对于GPT分区表，恶意软件会采取额外的一步来查找硬盘上的分区：它从硬盘的第三个扇区开始读取GPT分区表。每个GPT分区表项的长度为128字节，其结构如[列表13-7](ch13.xhtml#ch13list07)所示。
- en: '[PRE6]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '*Listing 13-7: Layout of the GPT partition table entry*'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表13-7：GPT分区表项的布局*'
- en: The very first field, `PartitionTypeGuid`, is an array of 16 bytes containing
    the identifier of the partition type, which determines what kind of data the partition
    is intended to store. The malicious boot code checks this field to filter out
    all partition entries except those with a `PartitionTypeGuid` field equal to `{EBD0A0A2-B9E5-4433-87C0-68B6B72699C7}`;
    this type is known as a basic data partition for the Windows operating system,
    used to store NTFS volumes. This is exactly what the malware is interested in.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个字段，`PartitionTypeGuid`，是一个包含16个字节的数组，包含分区类型的标识符，该标识符决定了分区用于存储哪种类型的数据。恶意引导代码检查该字段，以筛选出所有分区项，除非`PartitionTypeGuid`字段等于`{EBD0A0A2-B9E5-4433-87C0-68B6B72699C7}`；该类型被称为Windows操作系统的基本数据分区，用于存储NTFS卷。这正是恶意软件所关注的内容。
- en: If the malicious boot code identifies a basic data partition, it reads the `PartitionStartLba`
    and `PartitionLastLba` fields that contain the address of the very first and last
    sectors of the partition, respectively, to determine the location of the target
    partition on the hard drive. Once the Petya boot code has the coordinates of the
    partition, it proceeds to the next step.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 如果恶意引导代码识别到一个基本数据分区，它会读取`PartitionStartLba`和`PartitionLastLba`字段，这些字段分别包含分区的第一个和最后一个扇区的地址，以确定目标分区在硬盘上的位置。一旦Petya引导代码获取到分区的坐标，它就会进入下一步。
- en: '**Locating the MFT**'
  id: totrans-132
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**定位MFT**'
- en: To locate the MFT, the malware reads the VBR of the selected partitions from
    the hard drive (the layout of the VBR is described in detail in [Chapter 5](ch05.xhtml#ch05)).
    The parameters of the filesystem are described in the BIOS parameter block (BPB),
    the structure of which is shown in [Listing 13-8](ch13.xhtml#ch13list08).
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 为了定位MFT，恶意软件从硬盘读取所选分区的VBR（VBR的布局在[第5章](ch05.xhtml#ch05)中有详细描述）。文件系统的参数在BIOS参数块（BPB）中进行描述，其结构如[列表13-8](ch13.xhtml#ch13list08)所示。
- en: '[PRE7]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '*Listing 13-8: Layout of the BIOS parameter block in the VBR*'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表13-8：VBR中BIOS参数块的布局*'
- en: The malicious boot code checks the `MFTStartingCluster` ➋, which specifies the
    location of the MFT as an offset from the beginning of the partition in clusters.
    A *cluster* is the minimal addressable unit of storage in the filesystem. The
    size of the cluster may change from system to system and is specified in the `SectorsPerCluster`
    field ➊, which is also checked by the malware. For instance, the most typical
    value for this field for NTFS is 8, making it 4,096 bytes given that the sector
    size is 512 bytes. Using these two fields, Petya computes the offset of the MFT
    from the beginning of the partition.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 恶意引导代码检查`MFTStartingCluster` ➋，该字段指定了MFT的位置，表示为从分区开始的偏移量，单位为簇。*簇*是文件系统中最小的可寻址存储单元。簇的大小在不同的系统之间可能会有所不同，并且在`SectorsPerCluster`字段
    ➊ 中进行指定，恶意软件也会检查该字段。例如，NTFS的最典型值为8，因此在扇区大小为512字节的情况下，簇的大小为4,096字节。通过这两个字段，Petya计算出MFT相对于分区起始位置的偏移量。
- en: '**Parsing the MFT**'
  id: totrans-137
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**解析MFT**'
- en: The MFT is laid out as an array of items, each describing a particular file
    or directory. We won’t go into the details of the MFT format, as it is complex
    enough to warrant at least a chapter of its own. Instead, we’ll provide only the
    information necessary for understanding Petya’s malicious bootloader.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: MFT（主文件表）被排列成一个条目数组，每个条目描述一个特定的文件或目录。我们不会详细介绍MFT的格式，因为它足够复杂，至少需要一个章节来解释。相反，我们只提供理解Petya恶意引导程序所需的必要信息。
- en: At this point, the malware has the starting address of the MFT from `MFTStartingCluster`,
    but to get the exact locations, Petya also needs to know the size of the MFT.
    Moreover, the MFT may not be stored as a contiguous run of sectors on the hard
    drive, but rather partitioned into small runs of sectors spread out over the hard
    drive. To get information on the exact location of the MFT, the malicious code
    reads and parses the special metadata file *$MFT*, found in the NTFS metadata
    files that correspond to the first 16 records of the MFT.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 到这时，恶意软件已经通过`MFTStartingCluster`获得了MFT的起始地址，但要获取准确的位置信息，Petya还需要知道MFT的大小。此外，MFT可能并非以连续的扇区形式存储在硬盘上，而是分散存储为多个小的扇区块，分布在硬盘的不同位置。为了获得MFT的精确位置，恶意代码读取并解析了特殊的元数据文件
    *$MFT*，该文件位于NTFS元数据文件中，对应于MFT的前16条记录。
- en: 'Each of these files contains essential information for ensuring the correct
    operation of the filesystem:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 这些文件包含了确保文件系统正确操作的关键信息：
- en: '***$MFT*** Self-reference to the MFT, containing information on the size and
    location of the MFT on the hard drive'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: '***$MFT*** 自引用MFT，包含MFT在硬盘上的大小和位置的信息。'
- en: '***$MFTMirr*** Mirror of the MFT containing copies of the first 16 records'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: '***$MFTMirr*** MFT的镜像，包含前16条记录的副本。'
- en: '***$LogFile*** The logfile for the volume with the transaction data'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: '***$LogFile*** 包含卷的事务数据的日志文件。'
- en: '***$BadClus*** A list of all the corrupted clusters on the volume marked as
    “bad”'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: '***$BadClus*** 一个列出所有被标记为“坏”的损坏簇的列表。'
- en: As you can see, the very first metadata file, *$MFT*, contains all the information
    necessary for determining the exact location of the MFT on the hard drive. The
    malicious code parses this file to get the location of the contiguous runs of
    sectors, then encrypts them using the Salsa20 cipher.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，第一个元数据文件 *$MFT* 包含了确定MFT在硬盘上确切位置所需的所有信息。恶意代码解析这个文件以获取连续扇区的位置信息，然后使用Salsa20加密算法对它们进行加密。
- en: Once all the MFTs on the hard drives present in the system are encrypted, the
    infection process is complete, and the malware executes INT 19h to start the boot
    process all over again. This interrupt handler makes the BIOS boot code load the
    MBR of the bootable hard drive in memory and execute its code. This time, when
    the malicious boot code reads the configuration information from sector 54, the
    `EncryptionStatus` flag is set to `1`, indicating that the MFT encryption is complete,
    and the malware proceeds with displaying the ransom message.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦系统中硬盘上的所有MFT被加密，感染过程就完成了，恶意软件执行INT 19h来重新启动引导过程。这个中断处理程序使BIOS引导代码加载可启动硬盘的MBR到内存并执行其代码。这时，当恶意引导代码从第54扇区读取配置信息时，`EncryptionStatus`标志被设置为`1`，表示MFT加密已完成，恶意软件接着显示勒索信息。
- en: '**Displaying the Ransom Message**'
  id: totrans-147
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**显示勒索信息**'
- en: The ransom message displayed by the boot code is shown in [Figure 13-7](ch13.xhtml#ch13fig07).
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 引导代码显示的勒索信息如[图13-7](ch13.xhtml#ch13fig07)所示。
- en: '![image](../images/13fig07.jpg)'
  id: totrans-149
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/13fig07.jpg)'
- en: '*Figure 13-7: The Petya ransom message*'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: '*图13-7：Petya勒索信息*'
- en: The message informs the victim that their system has been compromised by Petya
    ransomware and that the hard disk is encrypted with a military-grade encryption
    algorithm. It then provides instructions for unlocking the data. You can see the
    list of URLs that Petya generated in the first step of the infection process.
    The pages at these URLs contain further instructions for the victim. The malware
    also displays the ransom code the user needs to enter to get the password for
    decryption.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 该信息通知受害者，他们的系统已被Petya勒索病毒感染，硬盘已被军用级加密算法加密。然后提供解锁数据的说明。你可以看到Petya在感染过程的第一步中生成的URL列表。这些URL页面包含进一步的指示信息。恶意软件还显示了用户需要输入的勒索代码，以获取解密密码。
- en: The malware generates the Salsa20 key from the password entered on the ransom
    page and attempts to decrypt sector 55, used for the key verification. If the
    password is correct, the decryption of sector 55 results in a buffer occupying
    0x37 bytes. In this case, the ransomware accepts the password, decrypts the MFTs,
    and restores the original MBR. If the password is incorrect, the malware shows
    the message `"Incorrect key! Please try again."`
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 该恶意软件通过在勒索页面上输入的密码生成Salsa20密钥，并尝试解密用于密钥验证的55号扇区。如果密码正确，解密55号扇区将得到一个占用0x37字节的缓冲区。在这种情况下，勒索病毒接受密码，解密MFT，并恢复原始MBR。如果密码错误，恶意软件会显示信息“`Incorrect
    key! Please try again.`”
- en: '***Wrapping Up: Final Thoughts on Petya***'
  id: totrans-153
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***总结：关于Petya的最终思考***'
- en: This concludes our discussion of the Petya infection process, but we have a
    few final notes on interesting aspects of its approach.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是我们对Petya感染过程的讨论，但我们还有一些关于其方法有趣方面的最终说明。
- en: First, unlike other ransomware that encrypts user files, Petya works with the
    hard drive in low-level mode, reading and writing raw data, and thus requires
    administrator privileges. However, it doesn’t exploit any local privilege escalation
    (LPE) vulnerabilities, instead relying on manifest information embedded in the
    malware, as discussed earlier in this chapter. Thus, if a user chooses not to
    grant the application administrator privileges, the malware won’t be launched
    due to the manifest requirements. And even if it were executed without administrative
    privileges, Petya couldn’t open the handle for the hard drive device and so couldn’t
    do any harm. In that case, the `CreateFile` routine that Petya used to obtain
    the handle for the hard drive would return a value of `INVALID_HANDLE`, resulting
    in an error.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，与其他加密用户文件的勒索病毒不同，Petya以低级模式操作硬盘，读取和写入原始数据，因此需要管理员权限。然而，它并没有利用任何本地权限提升（LPE）漏洞，而是依赖于之前本章讨论过的恶意软件中嵌入的清单信息。因此，如果用户选择不授予该应用程序管理员权限，恶意软件将由于清单要求而无法启动。即使没有管理员权限执行，Petya也无法打开硬盘设备的句柄，因此无法造成任何危害。在这种情况下，Petya用来获取硬盘句柄的`CreateFile`例程将返回`INVALID_HANDLE`值，从而导致错误。
- en: 'To circumvent this limitation, Petya was often distributed with another ransomware:
    Mischa. Mischa is an ordinary ransomware that encrypts user files rather than
    the hard drive and doesn’t require administrator access rights to the system.
    If Petya failed to get administrator privileges, the malicious dropper executed
    Mischa instead. Discussions on Mischa are outside the scope of this chapter.'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 为了绕过这个限制，Petya通常与另一种勒索病毒一起传播：Mischa。Mischa是一种普通的勒索病毒，它加密用户文件而不是硬盘，并且不需要管理员权限。如果Petya未能获取管理员权限，恶意下载器将执行Mischa。有关Mischa的讨论超出了本章的范围。
- en: Second, as already discussed, rather than encrypting the contents of the files
    on the hard drive, Petya encrypts the metadata stored in the MFT so that the filesystem
    can’t get information on the file locations and attributes. Thus, even though
    the file contents aren’t encrypted, victims still cannot access their files. This
    means the contents of the files may potentially be recovered through data recovery
    tools and methods. Such tools are frequently used in forensic analysis to recover
    information from corrupted images.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 其次，正如前面所讨论的，Petya并不是加密硬盘上文件的内容，而是加密存储在MFT中的元数据，从而使得文件系统无法获取文件的位置和属性信息。因此，即使文件内容没有被加密，受害者仍然无法访问他们的文件。这意味着文件内容有可能通过数据恢复工具和方法恢复。此类工具常用于法医分析中，恢复损坏镜像中的信息。
- en: Finally, as you may already have gleaned, Petya is quite a complex piece of
    malware written by skilled developers. The functionality it implements implies
    a deep understanding of filesystems and bootloaders. This malware marks another
    step in ransomware evolution.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，正如你可能已经领悟到的，Petya是一款非常复杂的恶意软件，由熟练的开发人员编写。它实现的功能表明其对文件系统和引导加载程序有着深刻的理解。这款恶意软件标志着勒索病毒进化的又一步。
- en: '**Analyzing the Satana Ransomware**'
  id: totrans-159
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**分析Satana勒索病毒**'
- en: 'Now, let’s take a look at another example of ransomware that targets the boot
    process: Satana. Whereas Petya infects only the hard drive’s MBR, Satana also
    encrypts the victim’s files.'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们来看一个针对启动过程的勒索病毒示例：Satana。与Petya只感染硬盘的MBR不同，Satana还加密了受害者的文件。
- en: Moreover, the MBR isn’t Satana’s main infection vector. We’ll demonstrate that
    the malicious bootloader code written in place of the original MBR contains flaws
    and was likely under development at the time of Satana’s distribution.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，MBR并不是Satana的主要感染媒介。我们将展示，作为原始MBR替代的恶意引导程序代码存在缺陷，且很可能是在Satana分发时还在开发中的。
- en: In this section, we’ll focus only on the MBR infection functionality, since
    user-mode file encryption functionality is beyond the scope of this chapter.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将只关注MBR感染功能，因为用户模式文件加密功能超出了本章的范围。
- en: '***The Satana Dropper***'
  id: totrans-163
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***Satana投放程序***'
- en: Let’s start with the Satana dropper. Once unpacked in memory, the malware copies
    itself into a file with a random name in the *TEMP* directory and executes the
    file. Satana requires administrator privileges to infect the MBR and, like Petya,
    doesn’t exploit any LPE vulnerabilities to gain elevated privileges. Instead,
    it checks the privilege level of its process using the `setupapi!IsUserAdmin`
    API routine, which in turn checks whether the security token of the current process
    is a member of the administrator group. If the dropper doesn’t have the privileges
    to infect the system, it executes the copy in the *TEMP* folder and attempts to
    execute the malware under the administrator account by using the `ShellExecute`
    API routine with a `runas` parameter, which displays a message asking the victim
    to grant the application administrator privileges. If the user chooses No, the
    malware calls `ShellExecute` with the same parameters over and over again until
    the user chooses Yes or kills the malicious process.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从Satana投放程序开始。解压到内存后，恶意软件将自身复制到*TEMP*目录下一个随机名称的文件中并执行该文件。Satana需要管理员权限才能感染MBR，并且像Petya一样，不利用任何LPE漏洞来提升权限。相反，它通过`setupapi!IsUserAdmin`
    API例程检查进程的权限级别，该例程进一步检查当前进程的安全令牌是否属于管理员组。如果投放程序没有足够的权限来感染系统，它会执行*TEMP*文件夹中的副本，并尝试通过使用带有`runas`参数的`ShellExecute`
    API例程，在管理员帐户下执行恶意软件，这会弹出一个提示消息，要求受害者授予应用程序管理员权限。如果用户选择“否”，恶意软件会重复调用`ShellExecute`，直到用户选择“是”或终止恶意进程。
- en: '***The MBR Infection***'
  id: totrans-165
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***MBR感染***'
- en: Once Satana gains administrator privileges, it proceeds with infecting the hard
    drive. Throughout the infection process, the malware extracts several components
    from the dropper’s image and writes them to the hard drive. [Figure 13-8](ch13.xhtml#ch13fig08)
    shows the layout of the first sectors of a hard drive infected by Satana. In this
    section, we’ll describe each element of the MBR infection in detail. We assume
    that sector indexing starts with 0, to simplify the explanation.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦Satana获得管理员权限，它就开始感染硬盘。在整个感染过程中，恶意软件从投放程序的镜像中提取多个组件，并将它们写入硬盘。[图13-8](ch13.xhtml#ch13fig08)显示了被Satana感染的硬盘前几个扇区的布局。在本节中，我们将详细描述MBR感染的每个元素。为了简化说明，我们假设扇区索引从0开始。
- en: '![image](../images/13fig08.jpg)'
  id: totrans-167
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/13fig08.jpg)'
- en: '*Figure 13-8: Layout of the hard drive with Satana infection*'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: '*图13-8：带有Satana感染的硬盘布局*'
- en: 'To access the hard drive in low-level mode, the malware uses the same APIs
    as Petya: `CreateFile`, `DeviceIoControl`, `WriteFile`, and `SetFilePointer`.
    To open a handle to a file representing the hard drive, Satana uses the `CreateFile`
    routine with the string `''\\.\PhysicalDrive0''` as a `FileName` argument. Then
    the dropper executes the `DeviceIoControl` routine with the `IOCTL_DISK_GET_DRIVE_GEOMETRY`
    parameter to get the hard drive parameters, such as the total number of sectors
    and the sector size in bytes.'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 为了以低级模式访问硬盘，恶意软件使用与Petya相同的API：`CreateFile`、`DeviceIoControl`、`WriteFile`和`SetFilePointer`。为了打开一个代表硬盘的文件句柄，Satana使用`CreateFile`例程，并将字符串`'\\.\PhysicalDrive0'`作为`FileName`参数传递。然后，投放程序执行`DeviceIoControl`例程，使用`IOCTL_DISK_GET_DRIVE_GEOMETRY`参数来获取硬盘参数，如总扇区数和扇区大小（以字节为单位）。
- en: '**NOTE**'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*The method of using ''\\.\PhysicalDrive0'' to obtain a handle to the hard
    drive isn’t 100 percent reliable, as it assumes that the bootable hard drive is
    always at index 0\. Though this is the case for most systems, it is not guaranteed.
    In this regard, Petya is more careful, as it determines the index of the current
    hard drive dynamically at infection time, while Satana uses a hardcoded value.*'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: '*使用''\\.\PhysicalDrive0''来获取硬盘句柄的方法并不是百分百可靠，因为它假设可引导硬盘总是在索引0的位置。虽然大多数系统是这种情况，但并不保证。在这方面，Petya更加小心，因为它在感染时动态确定当前硬盘的索引，而Satana则使用硬编码的值。*'
- en: Before proceeding with the infection of the MBR, Satana ensures there is enough
    free space to store the malicious bootloader components on the hard drive between
    the MBR and the first partition by enumerating the partitions and locating the
    first partition and its starting sector. If there are fewer than 15 sectors between
    the MBR and the first partition, Satana quits the infection process and continues
    with encrypting user files. Otherwise, it attempts to infect the MBR.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 在继续感染 MBR 之前，Satana 确保硬盘上 MBR 和第一个分区之间有足够的空闲空间来存储恶意引导加载程序组件，方法是枚举分区并定位第一个分区及其起始扇区。如果
    MBR 和第一个分区之间的扇区少于 15 个，Satana 会停止感染过程，转而继续加密用户文件。否则，它将尝试感染 MBR。
- en: First, Satana is supposed to write a buffer with user font information in sectors
    starting at sector 7 ➎. The buffer can take up to eight sectors of the hard drive.
    The information written to these sectors is intended to be used by the malicious
    bootloader to display the ransom message in a language other than the default
    (English). However, we haven’t seen it used in the Satana samples we’ve analyzed.
    The malware didn’t write anything at sector 7 and therefore used the default English
    language to display the ransom message.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，Satana 应该在从第 7 个扇区 ➎ 开始的扇区中写入包含用户字体信息的缓冲区。该缓冲区最多可以占用硬盘的八个扇区。写入这些扇区的信息旨在被恶意引导加载程序用来显示赎金信息，且该信息可以是除默认的英语以外的其他语言。然而，在我们分析的
    Satana 样本中并未看到该功能。恶意软件并未在第 7 个扇区写入任何内容，因此它使用默认的英语显示赎金信息。
- en: Satana writes the ransom message to display to the user at boot time in sectors
    2 to 5 ➌, written in plaintext without encryption.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: Satana 在启动时将赎金信息写入第 2 到第 5 个扇区 ➌，以明文形式显示，不进行加密。
- en: Then the malware reads the original MBR from the very first sector and encrypts
    it by XORing with a 512-byte key, generated at the stage of infection using a
    pseudorandom-number generator. Satana fills a buffer of 512 bytes with random
    data and XORs every byte of the MBR with the corresponding byte in the key buffer.
    Once the MBR is encrypted, the malware stores the encryption key in sector 6 ➍
    and the encrypted original MBR in sector 1 ➋ of the hard drive.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，恶意软件从第一个扇区读取原始 MBR，并通过与一个 512 字节的密钥进行异或加密，这个密钥是在感染阶段使用伪随机数生成器生成的。Satana 用随机数据填充
    512 字节的缓冲区，并将 MBR 的每个字节与密钥缓冲区中相应的字节进行异或。一旦 MBR 被加密，恶意软件将加密密钥存储在第 6 个扇区 ➍，并将加密后的原始
    MBR 存储在硬盘的第 1 个扇区 ➋。
- en: Finally, the malware writes the malicious MBR to the very first sector of the
    hard drive ➊. Before overwriting the MBR, Satana encrypts the infected MBR by
    XORing it with a randomly generated byte value and writes the key at the end of
    the infected MBR so that the malicious MBR code can use this key to decrypt itself
    at system bootup.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，恶意软件将恶意 MBR 写入硬盘的第一个扇区 ➊。覆盖 MBR 之前，Satana 会通过与随机生成的字节值进行异或加密来加密感染后的 MBR，并将密钥写入感染
    MBR 的末尾，以便恶意 MBR 代码在系统启动时可以使用该密钥解密自己。
- en: This step completes the MBR infection process, and Satana continues with user
    file encryption. To trigger the execution of the malicious MBR, Satana reboots
    the computer shortly after encrypting the user files.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 这个步骤完成了 MBR 的感染过程，Satana 接下来将继续进行用户文件加密。为了触发恶意 MBR 的执行，Satana 在加密用户文件后不久重启计算机。
- en: '***Dropper Debug Information***'
  id: totrans-178
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***Dropper 调试信息***'
- en: Before continuing our analysis of the malicious MBR code, we’d like to mention
    a particularly interesting aspect of the dropper. The samples of Satana we analyzed
    contained a lot of verbose debug information documenting the code implemented
    in the dropper, similar to our findings from the Carberp trojan discussed in [Chapter
    11](ch11.xhtml#ch11).
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 在继续分析恶意 MBR 代码之前，我们想提到 dropper 中一个特别有趣的方面。我们分析的 Satana 样本包含了大量详细的调试信息，记录了 dropper
    中实现的代码，这与我们在[第 11 章](ch11.xhtml#ch11)中讨论的 Carberp 木马的发现类似。
- en: This presence of debug information in the dropper reinforces the notion that
    Satana was in development when we were analyzing it. Satana uses the `OutputDebugString`
    API to output debugging messages, which you can see in the debugger or by using
    other tools that intercept debug output. [Listing 13-9](ch13.xhtml#ch13list09)
    shows an excerpt from the malware’s debug trace intercepted with the `DebugMonitor`
    tool.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: dropper 中调试信息的存在进一步证明了在我们分析 Satana 时，它仍处于开发阶段。Satana 使用 `OutputDebugString`
    API 输出调试信息，你可以在调试器中看到这些信息，或者通过其他拦截调试输出的工具查看。[清单 13-9](ch13.xhtml#ch13list09) 展示了使用
    `DebugMonitor` 工具拦截到的恶意软件调试跟踪的片段。
- en: '[PRE8]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '*Listing 13-9: Debug output of the Satana dropper*'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 13-9：Satana dropper 的调试输出*'
- en: 'You can see in this output that the malware tries to access `''\\.\PhysicalDrive0''`
    ➊ to read and write sectors from and to the hard drive. At ➋, Satana obtains the
    parameters of the hard drive: size and total number of sectors. At ➍, it writes
    the ransom message on the hard drive and then generates a key to encrypt the infected
    MBR ➌. It stores the encryption key ➎ and then overwrites the MBR with the infected
    code ➏. These messages reveal the malware’s functionality without requiring us
    to do hours of reverse-engineering work.'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以从输出中看到，恶意软件试图访问`'\\.\PhysicalDrive0'` ➊，以从硬盘读写扇区。在 ➋ 处，Satana获取硬盘的参数：大小和总扇区数。在
    ➍ 处，它将勒索信息写入硬盘，然后生成一个密钥来加密感染的MBR ➌。它存储加密密钥 ➎，然后用感染的代码覆盖MBR ➏。这些信息揭示了恶意软件的功能，而无需我们进行数小时的逆向工程工作。
- en: '***The Satana Malicious MBR***'
  id: totrans-184
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***Satana恶意MBR***'
- en: Satana’s malicious bootloader is relatively small and simple compared to Petya’s.
    The malicious code is contained in a single sector and implements the functionality
    for displaying the ransom message.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: Satana的恶意引导程序相比于Petya来说相对较小且简单。恶意代码被包含在一个扇区内，并实现了显示勒索信息的功能。
- en: Once the system boots, the malicious MBR code decrypts itself by reading the
    decryption key from the end of the MBR sectors and XORing the encrypted MBR code
    with the key. [Listing 13-10](ch13.xhtml#ch13list10) shows the malicious MBR decryptor
    code.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 系统启动后，恶意MBR代码通过读取MBR扇区末尾的解密密钥，并与密钥进行异或操作来解密自身。[列表13-10](ch13.xhtml#ch13list10)显示了恶意MBR解密器代码。
- en: '[PRE9]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '*Listing 13-10: Satana’s malicious MBR decryptor*'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表13-10：Satana的恶意MBR解密器*'
- en: First, the decryptor initializes the `si`, `di`, and `cx` registers ➊ to copy
    the encrypted MBR code to another memory location, and then it decrypts the copied
    code by XORing it with the byte value ➌. Once the decryption is done, the instruction
    at ➍ transfers the execution flow to the decrypted code (address in `cx`).
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，解密器初始化`si`、`di`和`cx`寄存器 ➊，以将加密的MBR代码复制到另一个内存位置，然后通过与字节值 ➌进行异或操作来解密复制的代码。一旦解密完成，指令
    ➍将执行流转移到解密后的代码（`cx`中的地址）。
- en: 'If you look closely at the line copying the encrypted MBR code to another memory
    location, you may spot a bug: the copying is done by the `rep movsb` instruction
    ➋, which copies the number of bytes specified by the `cx` register from the source
    buffer, whose address is stored in `ds:si`, to the destination buffer, whose address
    is specified in the `es:di` registers. However, the segment registers `ds` and
    `es` aren’t initialized in the MBR code. Instead, the malware assumes that the
    `ds` (data segment) register has exactly the same value as the `cs` (code segment)
    register (that is, that `ds:si` should be translated to cs:7c00h, which corresponds
    to the address of the MBR in memory). However, this isn’t always true: the `ds`
    register may contain a different value. If that is the case, the malware will
    attempt to copy the wrong bytes from the memory at the `ds:si` address—which is
    completely different from the location of the MBR. To fix the bug, the `ds` and
    `es` registers need to be initialized with the value of the `cs` register, 0x0000
    (since the MBR is loaded at address 0000:7c00h, the `cs` register contains 0x0000).'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你仔细观察复制加密MBR代码到另一个内存位置的那一行，可能会发现一个错误：复制是通过`rep movsb`指令 ➋完成的，该指令将由`cx`寄存器指定的字节数从源缓冲区（其地址存储在`ds:si`中）复制到目标缓冲区（其地址由`es:di`寄存器指定）。然而，MBR代码中并未初始化段寄存器`ds`和`es`。相反，恶意软件假设`ds`（数据段）寄存器的值与`cs`（代码段）寄存器的值完全相同（也就是说，`ds:si`应该转换为cs:7c00h，这对应内存中MBR的地址）。然而，这并非总是正确的：`ds`寄存器可能包含不同的值。如果是这种情况，恶意软件会尝试从`ds:si`地址处复制错误的字节——这与MBR所在的位置完全不同。为了解决这个问题，`ds`和`es`寄存器需要使用`cs`寄存器的值0x0000进行初始化（因为MBR加载在地址0000:7c00h，`cs`寄存器包含0x0000）。
- en: '**THE PRE-MBR EXECUTION ENVIRONMENT**'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: '**MBR执行环境之前**'
- en: The very first code executed after the CPU comes out of reset is not the MBR
    code but BIOS code that performs basic system initialization. The contents of
    the segment registers `cs`, `ds`, `es`, `ss`, and so on are initialized by BIOS
    before the MBR is executed. Since different platforms have different implementations
    of the BIOS, it is possible that the contents of certain segment registers may
    differ across different platforms. It’s therefore up to MBR code to ensure that
    segment registers contain the expected values.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: CPU 从复位状态启动后执行的第一段代码不是 MBR 代码，而是执行基本系统初始化的 BIOS 代码。在执行 MBR 之前，BIOS 会初始化段寄存器
    `cs`、`ds`、`es`、`ss` 等的内容。由于不同平台上 BIOS 的实现有所不同，因此某些段寄存器的内容在不同平台上可能会有所不同。因此，MBR
    代码必须确保段寄存器包含预期的值。
- en: 'The functionality of the decrypted code is straightforward: the malware reads
    the ransom message from sectors 2 to 5 into a memory buffer, and if there is a
    font written to sectors 7 to 15, Satana loads it using the INT 10h service. The
    malware then displays the ransom message using the same INT 10h service and reads
    input from the keyboard. Satana’s ransom message is shown in [Figure 13-9](ch13.xhtml#ch13fig09).'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 解密代码的功能非常直接：恶意软件将赎金信息从第2到第5扇区读取到内存缓冲区，如果第7到第15扇区写入了字体，Satana 会通过 INT 10h 服务加载它。然后，恶意软件通过同样的
    INT 10h 服务显示赎金信息，并从键盘读取输入。Satana 的赎金信息如[图13-9](ch13.xhtml#ch13fig09)所示。
- en: 'At the bottom, the message prompts the user to enter the password to unlock
    the MBR. There’s a trick, though: the malware doesn’t actually unlock the MBR
    upon entry of the password. As you can see in the password verification routine
    presented in [Listing 13-11](ch13.xhtml#ch13list11), the malware doesn’t restore
    the original MBR.'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 在底部，信息提示用户输入密码以解锁MBR。然而有一个小技巧：恶意软件在输入密码后并不会真正解锁MBR。正如在[清单13-11](ch13.xhtml#ch13list11)中展示的密码验证程序所示，恶意软件并没有恢复原始的MBR。
- en: '[PRE10]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '*Listing 13-11: Satana password verification routine*'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 13-11：Satana 密码验证程序*'
- en: '![image](../images/13fig09.jpg)'
  id: totrans-197
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/13fig09.jpg)'
- en: '*Figure 13-9: Satana ransom message*'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: '*图13-9：Satana 赎金信息*'
- en: The `compute_checksum` routine ➋ computes a checksum of the 8-byte string stored
    at address ds:2800h ➊ and stores the result in the `ax` register. Then the code
    compares the checksum with the value at address ds:2900h ➌. However, regardless
    of the outcome of the comparison, the code loops infinitely at ➍, meaning the
    execution flow doesn’t go any further from this point, even though the malicious
    MBR contains code for decrypting the original MBR and restoring it at the very
    first sector. The victim who paid the ransom to unlock their system isn’t actually
    able to do so without system recovery software. This is a vivid reminder that
    victims of ransomware shouldn’t pay the ransom, as no one can guarantee that they’ll
    retrieve their data.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: '`compute_checksum` 程序 ➋ 计算存储在地址 ds:2800h ➊ 的8字节字符串的校验和，并将结果存储在 `ax` 寄存器中。然后代码将校验和与地址
    ds:2900h ➌ 处的值进行比较。然而，无论比较结果如何，代码都会在 ➍ 无限循环，这意味着从此时起，执行流不会继续，尽管恶意的MBR包含了用于解密原始MBR并在第一个扇区恢复它的代码。支付赎金解锁系统的受害者，实际上在没有系统恢复软件的情况下是无法恢复的。这清楚地提醒我们，勒索软件的受害者不应支付赎金，因为没人能保证他们能找回数据。'
- en: '***Wrapping Up: Final Thoughts on Satana***'
  id: totrans-200
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***总结：关于 Satana 的最终思考***'
- en: Satana is an example of a ransomware program still catching up with modern ransomware
    trends. The flaws observed in the implementation and the abundance of debugging
    information suggest that the malware was in development when we first saw it in
    the wild.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: Satana 是一个仍在追赶现代勒索软件趋势的勒索软件程序。实施中的缺陷和大量调试信息表明，我们第一次在野外看到它时，它仍处于开发阶段。
- en: Compared to Petya, Satana lacks sophistication. Despite the fact that it never
    restores the original MBR, its MBR infection approach isn’t as damaging as Petya’s.
    The only boot component affected by Satana is the MBR, making it possible for
    the victim to restore access to the system by repairing the MBR using the Windows
    installation DVD, which can recover information on the system partitions and rebuild
    a new MBR with a valid partition table.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 与 Petya 相比，Satana 缺乏复杂性。尽管它从未恢复原始的MBR，但它的MBR感染方式并不像 Petya 那样具有破坏性。受Satana影响的唯一启动组件是MBR，这使得受害者可以通过使用Windows安装DVD修复MBR来恢复对系统的访问，系统安装DVD可以恢复系统分区上的信息，并重建一个包含有效分区表的新MBR。
- en: Victims can also restore access to the system by reading the encrypted MBR from
    sector 1 of the MBR and XORing it with the encryption key stored in sector 6\.
    This retrieves the original MBR, which should be written to the very first sector
    to restore access to the system. However, even if a victim manages to restore
    access to the system by recovering the MBR, the contents of the files encrypted
    by Satana will still be unavailable.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 受害者还可以通过读取来自MBR第1扇区的加密MBR，并与存储在第6扇区的加密密钥进行异或运算，来恢复对系统的访问。这将恢复原始的MBR，并应写入第一个扇区，以恢复对系统的访问。然而，即使受害者通过恢复MBR成功恢复了对系统的访问，Satana加密的文件内容仍然无法访问。
- en: '**Conclusion**'
  id: totrans-204
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**结论**'
- en: This chapter covers some of the major evolutions in modern ransomware. Attacks
    on both home users and organizations constitute a modern trend in the malware
    evolution, one that the antivirus industry has had to struggle to catch up with
    after the outbreak of trojans encrypting the contents of user files in 2012.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖了现代勒索软件的一些主要演变。对家庭用户和组织的攻击构成了恶意软件演变中的一种现代趋势，这一趋势在2012年木马病毒开始加密用户文件内容后，令杀毒软件行业不得不努力赶上。
- en: Although this new trend in ransomware is gaining in popularity, developing bootkit
    components requires different skills and knowledge than developing trojans for
    encrypting user files. The flaws in Satana’s bootloader component are a clear
    example of this gulf of skills.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管这种新兴的勒索软件趋势越来越流行，但开发引导程序组件需要的技能和知识与开发加密用户文件的木马病毒有所不同。Satana引导加载程序组件中的缺陷清楚地展示了这种技能差距。
- en: As we’ve seen with other malware, this arms race between malware and security
    software development has forced ransomware to evolve and adopt bootkit infection
    techniques to stay under the radar. As more and more ransomware has emerged, many
    security practices have become routine, such as backing up data—one of the best
    protection methods against a wide variety of threats, especially ransomware.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在其他恶意软件中看到的那样，恶意软件与安全软件开发之间的军备竞赛迫使勒索软件不断进化，并采用引导程序感染技术以保持隐蔽。随着越来越多的勒索软件出现，许多安全实践已经成为常规，例如备份数据——这是抵御各种威胁，尤其是勒索软件的最佳保护方法之一。
