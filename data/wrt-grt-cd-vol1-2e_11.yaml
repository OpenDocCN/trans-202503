- en: '**12'
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '**12'
- en: INPUT AND OUTPUT**
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 输入与输出**
- en: '![Image](../images/comm1.jpg)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/comm1.jpg)'
- en: 'A typical program has three basic tasks: input, computation, and output. So
    far we’ve concentrated on the computational aspects of the computer system, but
    now we’ll turn to input and output.'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 一个典型程序有三个基本任务：输入、计算和输出。到目前为止，我们主要关注计算机系统的计算方面，但现在我们将转向输入和输出。
- en: This chapter will focus on the primitive input/output (I/O) activities of the
    CPU, rather than on the abstract file or character I/O that high-level applications
    usually employ. It will discuss how the CPU transfers data to and from the outside
    world, paying special attention to the performance issues behind I/O operations.
    As all high-level I/O activities are eventually routed through the low-level I/O
    systems, it’s crucial to understand how these processes work if you want to write
    programs that communicate efficiently with the outside world.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将重点讨论 CPU 的原始输入/输出（I/O）活动，而不是高层应用通常使用的抽象文件或字符 I/O。它将讨论 CPU 如何将数据传输到外部世界并从外部世界获取数据，特别关注
    I/O 操作背后的性能问题。由于所有高层 I/O 活动最终都会通过低层 I/O 系统进行，因此如果你想编写与外部世界高效通信的程序，理解这些过程的工作原理至关重要。
- en: '**12.1 Connecting a CPU to the Outside World**'
  id: totrans-5
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**12.1 将 CPU 连接到外部世界**'
- en: The first thing to know is that I/O in a typical computer system is radically
    different from I/O in a typical high-level programming language. At the primitive
    I/O levels of a computer system, you’ll rarely find machine instructions that
    behave like Pascal’s `writeln`, C++’s `cout`, C’s `printf`, Swift’s `print`, or
    even the HLA `stdin` and `stdout` statements. In fact, most I/O machine instructions
    behave exactly like the 80x86’s `mov` instruction. To send data to an output device,
    the CPU simply moves that data to a special memory location; and to read data
    from an input device, the CPU retrieves the data from the device’s address. I/O
    operations behave much like memory read and write operations, except that I/O
    usually involves more wait states.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 首先要知道的是，典型计算机系统中的 I/O 与典型高级编程语言中的 I/O 截然不同。在计算机系统的原始 I/O 层次上，你很少能找到像 Pascal
    的 `writeln`、C++ 的 `cout`、C 的 `printf`、Swift 的 `print`，甚至 HLA 的 `stdin` 和 `stdout`
    语句那样的机器指令。事实上，大多数 I/O 机器指令的行为完全像 80x86 的 `mov` 指令。为了将数据发送到输出设备，CPU 只需将数据移动到一个特殊的内存位置；而为了从输入设备读取数据，CPU
    会从设备的地址中获取数据。I/O 操作的行为与内存的读写操作非常相似，不同之处在于 I/O 通常涉及更多的等待状态。
- en: 'Based on the CPU’s ability to read and write data at a given port address,
    I/O ports can be grouped into five categories: read-only, write-only, read/write,
    dual I/O, and bidirectional.'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 根据 CPU 在给定端口地址上读取和写入数据的能力，I/O 端口可以分为五类：只读、写入、读/写、双重 I/O 和双向 I/O。
- en: A *read-only port* is an input port. If the CPU can only read the data from
    the port, then the data must come from some source external to the computer system.
    It’s never a good idea to try to write to a read-only port because, although the
    hardware typically ignores such attempts, it can cause some devices to fail. A
    good example of a read-only port is the status port on the original IBM PC’s parallel
    printer interface. Data from this port specifies the current status of the printer,
    while the hardware ignores any data written to this port.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: '*只读端口*是一个输入端口。如果 CPU 只能从端口读取数据，那么这些数据必须来自计算机系统外部的某个来源。尝试写入只读端口通常不是一个好主意，因为尽管硬件通常会忽略这种尝试，但它可能会导致某些设备出现故障。一个好的只读端口例子是原始
    IBM PC 上并行打印机接口的状态端口。该端口的数据指定打印机的当前状态，而硬件会忽略写入该端口的任何数据。'
- en: A *write-only port* is always an output port. Data written to such a port is
    available for use by an external device. Attempting to read data from a write-only
    port generally returns whatever garbage value happens to be on the data bus, so
    your programs shouldn’t depend on the meaning of such values. An output port typically
    uses a latch device to hold data to be sent to the outside world. When a CPU writes
    to a port address associated with an output latch, the latch stores the data and
    makes it available on an external set of signal lines (see [Figure 12-1](ch12.xhtml#ch12fig01)).
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: '*写入端口*始终是一个输出端口。写入此类端口的数据可以供外部设备使用。尝试从写入端口读取数据通常会返回总线上的垃圾值，因此你的程序不应依赖于这些值的含义。输出端口通常使用一个锁存器设备来存储要发送到外部世界的数据。当
    CPU 写入与输出锁存器关联的端口地址时，锁存器会存储数据，并将其通过一组外部信号线提供（见[图12-1](ch12.xhtml#ch12fig01)）。'
- en: '![image](../images/12fig01.jpg)'
  id: totrans-10
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/12fig01.jpg)'
- en: '*Figure 12-1: A typical write-only port*'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 12-1：典型的写入端口*'
- en: A perfect example of an output port is a parallel printer port. The CPU typically
    writes an ASCII character to a byte-wide output port that connects to the DB-25F
    connector on the back of the computer’s case. A cable transmits this data to the
    printer, where it arrives on the printer’s input port (from the printer’s perspective,
    it is reading the data from the computer system). A processor inside the printer
    typically converts this ASCII character to a sequence of dots that it prints on
    paper.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 输出端口的一个完美示例是并行打印机端口。CPU通常将一个ASCII字符写入一个字节宽的输出端口，该端口连接到计算机机箱背面的DB-25F连接器。通过电缆将此数据传输到打印机，打印机的输入端口接收到该数据（从打印机的角度来看，它是从计算机系统读取数据）。打印机内部的处理器通常将此ASCII字符转换为一系列点，并打印到纸上。
- en: Output ports can be write-only or read/write. The port in [Figure 12-1](ch12.xhtml#ch12fig01),
    for example, is a write-only port. Because the outputs on the latch do not loop
    back to the CPU’s data bus, the CPU can’t read the data the latch contains. Both
    the address decode line (En) and the write control line (W) must be active for
    the latch to operate. If the CPU tries to read the data located at the latch’s
    address, the address decode line is active but the write control line is not,
    so the latch does not respond to the read request.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 输出端口可以是只写或读/写端口。例如，[图12-1](ch12.xhtml#ch12fig01)中的端口是一个只写端口。由于触发器上的输出不会回路到CPU的数据总线，因此CPU无法读取触发器中包含的数据。要使触发器工作，地址解码线（En）和写控制线（W）都必须处于激活状态。如果CPU尝试读取触发器地址上的数据，地址解码线虽然处于激活状态，但写控制线未激活，因此触发器不会响应读取请求。
- en: A *read/write port* is an output (write-only) port as far as the outside world
    is concerned. However, as the name implies, the CPU can also read data from such
    a port—specifically, it reads the data that was last written to the port. Doing
    so does not affect the data presented to the external peripheral device.^([1](footnotes.xhtml#fn12_1a))
    [Figure 12-2](ch12.xhtml#ch12fig02) illustrates a read/write port.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: '*读/写端口*从外界角度来看是一个输出（只写）端口。然而，顾名思义，CPU也可以从这样的端口读取数据——具体来说，它读取的是最后写入该端口的数据。这样做不会影响传递给外部外设的数据显示。^([1](footnotes.xhtml#fn12_1a))
    [图12-2](ch12.xhtml#ch12fig02)展示了一个读/写端口。'
- en: '![image](../images/12fig02.jpg)'
  id: totrans-15
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/12fig02.jpg)'
- en: '*Figure 12-2: A read/write port*'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: '*图12-2：读/写端口*'
- en: As you can see, the data written to the output port loops back to a second latch.
    Placing the address of these two latches on the address bus asserts the *address
    decode lines* on both latches. Therefore, to select between the two latches, the
    CPU must also assert either the read line or the write line. Asserting the read
    line (which happens during a read operation) will enable the lower latch. This
    places the data previously written to the output port on the CPU’s data bus, allowing
    the CPU to read that data.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，写入输出端口的数据会回路到第二个触发器。将这两个触发器的地址放置在地址总线上，会激活两个触发器的*地址解码线*。因此，为了在这两个触发器之间选择，CPU还必须激活读线或写线。激活读线（即在读操作过程中发生的情况）将启用下触发器。这会将先前写入输出端口的数据放到CPU的数据总线上，允许CPU读取该数据。
- en: The port in [Figure 12-2](ch12.xhtml#ch12fig02) is not an input port—true input
    ports read data from external pins. Although the CPU can read data from this latch,
    the organization of this circuit simply allows the CPU to read the data it previously
    wrote to the port, thus saving the program from having to maintain this value
    in a separate variable. The data on the external connector is output only, and
    you can’t connect real-world input devices to these signal pins.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: '[图12-2](ch12.xhtml#ch12fig02)中的端口不是输入端口——真正的输入端口从外部引脚读取数据。尽管CPU可以从这个触发器读取数据，但该电路的结构只是允许CPU读取它之前写入端口的数据，从而避免程序必须将该值保存在单独的变量中。外部连接器上的数据仅供输出，不能将现实世界的输入设备连接到这些信号引脚。'
- en: A *dual I/O port* is also a read/write port, but when you read a dual I/O port,
    you read data from an external input device rather than the last data written
    to the output side of the port’s address. Writing data to a dual I/O port transmits
    data to some external output device, just as writing to a write-only port does.
    [Figure 12-3](ch12.xhtml#ch12fig03) shows how you could interface a dual I/O port
    with the system.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: '*双I/O端口*也是一个读/写端口，但当你读取双I/O端口时，你是从外部输入设备读取数据，而不是从端口地址的输出侧读取最后写入的数据。向双I/O端口写入数据会将数据传输到某个外部输出设备，就像向只写端口写入数据一样。[图12-3](ch12.xhtml#ch12fig03)展示了如何将双I/O端口与系统进行接口。'
- en: '![image](../images/12fig03.jpg)'
  id: totrans-20
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/12fig03.jpg)'
- en: '*Figure 12-3: A dual I/O port*'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: '*图12-3：双I/O端口*'
- en: A dual I/O port is actually created with two ports—a read-only port and a write-only
    port—that share the same port address. Reading from the address accesses the read-only
    port, and writing to the address accesses the write-only port. Essentially, this
    port arrangement uses the read (R) and write (W) control lines to provide an extra
    address bit that specifies which of the two ports to use.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 双I/O端口实际上是由两个端口组成——一个只读端口和一个只写端口——它们共享相同的端口地址。读取该地址会访问只读端口，而写入该地址会访问只写端口。本质上，这种端口安排利用了读（R）和写（W）控制线，提供了一个额外的地址位，指定使用哪一个端口。
- en: Finally, a *bidirectional port* allows the CPU to both read data from and write
    data to an external device. To function properly, a bidirectional port must pass
    various control lines, such as read and write enable, to the peripheral device
    so that the device can change the direction of data transfer based on the CPU’s
    read/write request. In effect, a bidirectional port is an extension of the CPU’s
    bus through a bidirectional latch or buffer.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，*双向端口*允许CPU既能从外部设备读取数据，又能向外部设备写入数据。为了正常工作，双向端口必须向外围设备传递各种控制线，如读写使能信号，以便设备能够根据CPU的读写请求改变数据传输的方向。实际上，双向端口通过双向锁存器或缓冲器扩展了CPU的总线。
- en: 'Generally, a given peripheral device utilizes multiple I/O ports. The original
    IBM PC parallel printer interface, for example, uses three port addresses: a read/write
    I/O port, a read-only input port, and a write-only output port. The read/write
    data port allows the CPU to read the last ASCII character written through it.
    The input port returns control signals from the printer, which indicate whether
    the printer is ready to accept another character, offline, out of paper, and other
    statuses. The output port transmits control information to the printer. Later-model
    PCs substituted a bidirectional port for the data port, allowing data transfer
    from and to a device through the parallel port. The bidirectional data port improved
    performance for various devices such as disk and tape drives connected to the
    PC’s parallel port. (Of course, modern PCs talk to printers over the USB port—that’s
    quite a different animal from the hardware perspective, though.)'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，给定的外围设备使用多个I/O端口。例如，原始的IBM PC并行打印机接口使用了三个端口地址：一个读写I/O端口、一个只读输入端口和一个只写输出端口。读写数据端口允许CPU读取通过它写入的最后一个ASCII字符。输入端口返回来自打印机的控制信号，指示打印机是否准备好接收另一个字符、是否离线、是否缺纸等状态。输出端口则向打印机传输控制信息。后来的PC型号用双向端口替代了数据端口，通过并行端口实现设备间的数据传输。双向数据端口提高了连接到PC并行端口的各种设备（如磁盘和磁带驱动器）的性能。（当然，现代PC通过USB端口与打印机通信——从硬件角度来看，这是完全不同的一种设备。）
- en: '**12.2 Other Ways to Connect Ports to the System**'
  id: totrans-25
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**12.2 连接端口到系统的其他方式**'
- en: The examples thus far may have given you the impression that the CPU always
    reads and writes peripheral data using the data bus. However, while the CPU generally
    transfers the data it has *read* from input ports across the data bus, it doesn’t
    always use the data bus to *write* data to output ports. In fact, a very common
    output method is to simply access a port’s address directly without writing any
    data to it. [Figure 12-4](ch12.xhtml#ch12fig04) illustrates a simple example of
    this technique using a set/reset (S/R) flip-flop.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止的例子可能给你留下了这样一个印象：CPU总是通过数据总线读取和写入外围设备数据。然而，虽然CPU通常会通过数据总线传输从输入端口*读取*的数据，但它并不总是通过数据总线将数据*写入*输出端口。事实上，一种非常常见的输出方式是直接访问端口的地址，而不向其写入任何数据。[图12-4](ch12.xhtml#ch12fig04)展示了一个使用置位/复位（S/R）触发器的简单例子，演示了这一技术。
- en: '![image](../images/12fig04.jpg)'
  id: totrans-27
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/12fig04.jpg)'
- en: '*Figure 12-4: Outputting data to a port by directly accessing that port*'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: '*图12-4：通过直接访问端口输出数据*'
- en: In this circuit, an address decoder decodes two separate addresses. Any read
    or write access to the first address sets the output line to a `1`; any read or
    write access to the second address sets the output line to a `0`. This circuit
    ignores the data on the CPU’s data lines, as well as the status of the read and
    write lines. The only thing that matters is that the CPU accesses one of these
    two addresses.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 在该电路中，地址解码器解码两个独立的地址。对第一个地址的任何读写访问都会将输出线设置为`1`；对第二个地址的任何读写访问都会将输出线设置为`0`。该电路忽略了CPU数据线上的数据以及读写线的状态。唯一重要的是，CPU访问了这两个地址中的一个。
- en: Another possible way to connect an output port to a system is to connect the
    read/write status lines to the data input of a D flip-flop. [Figure 12-5](ch12.xhtml#ch12fig05)
    shows how you could design such a device.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种将输出端口连接到系统的方法是将读/写状态线连接到D触发器的数据输入端。[图12-5](ch12.xhtml#ch12fig05)展示了如何设计这样的设备。
- en: '![image](../images/12fig05.jpg)'
  id: totrans-31
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/12fig05.jpg)'
- en: '*Figure 12-5: Outputting data using the read/write control as the data to output*'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: '*图12-5：使用读/写控制作为输出数据的方式*'
- en: In this diagram, any read of the port sets the output bit to `0`, while any
    write to this port sets the output bit to `1` (the read control line will be `HIGH`
    when writing to the specified address).
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 在此图中，任何对端口的读取操作都会将输出位设置为`0`，而对该端口的任何写入操作都会将输出位设置为`1`（在写入指定地址时，读控制线会是`HIGH`）。
- en: These are only two examples of an amazing variety of designs that engineers
    have devised to avoid using the data bus (largely to reduce hardware costs or
    improve performance). However, unless otherwise noted, the remaining examples
    in this chapter presume that the CPU reads and writes data to and from an external
    device using the data bus.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 这些只是工程师们为避免使用数据总线（主要是为了降低硬件成本或提高性能）而设计的众多方案中的两个例子。然而，除非另有说明，本章中其余的例子假设CPU通过数据总线与外部设备进行数据的读写。
- en: '**12.3 I/O Mechanisms**'
  id: totrans-35
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**12.3 I/O机制**'
- en: 'There are three basic I/O mechanisms that computer systems use to communicate
    with peripheral devices: memory-mapped input/output, I/O-mapped input/output,
    and direct memory access (DMA). *Memory-mapped I/O* uses ordinary locations within
    the CPU’s memory address space to communicate with peripheral devices. *[I/O-mapped
    input/output](gloss01.xhtml#gloss01_115)* uses an address space separate from
    memory, as well as special machine instructions to transfer data between that
    I/O address space and the outside world. *Direct memory access (DMA)* is a special
    form of memory-mapped I/O where the peripheral device reads and writes data located
    in memory without CPU intervention. Each I/O mechanism has its own set of advantages
    and disadvantages, as we will discuss in this section.'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 计算机系统用来与外设设备通信的三种基本I/O机制是：内存映射输入/输出、I/O映射输入/输出和直接内存访问（DMA）。*内存映射I/O*使用CPU内存地址空间中的普通位置与外设设备进行通信。*[I/O映射输入/输出](gloss01.xhtml#gloss01_115)*使用与内存分开的地址空间，并且通过特殊的机器指令在该I/O地址空间与外部世界之间传输数据。*直接内存访问（DMA）*是一种特殊的内存映射I/O形式，其中外设设备在没有CPU干预的情况下读取和写入位于内存中的数据。每种I/O机制都有其优点和缺点，我们将在本节中讨论。
- en: Usually, the hardware system designer determines how a device connects to a
    computer system; programmers have little control over this decision. Nevertheless,
    by paying attention to the costs and benefits of the I/O mechanism used for communication
    between the CPU and the peripheral device, you can choose code sequences that
    will maximize I/O performance within your applications.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，硬件系统设计师决定设备如何连接到计算机系统；程序员对这个决定几乎没有控制权。然而，通过关注用于CPU与外设之间通信的I/O机制的成本与效益，你可以选择最大化应用程序中I/O性能的代码序列。
- en: '***12.3.1 Memory-Mapped I/O***'
  id: totrans-38
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***12.3.1 内存映射I/O***'
- en: A memory-mapped peripheral device is connected to the CPU’s address and data
    lines exactly like regular memory, so whenever the CPU writes to or reads from
    the address associated with the peripheral device, the CPU transfers data to or
    from the device. This mechanism has several benefits and only a few disadvantages.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 内存映射外设设备与CPU的地址和数据线连接的方式与常规内存相同，因此每当CPU写入或读取与外设相关联的地址时，CPU都会将数据传输到设备或从设备传输数据。这种机制有几个优点，仅有少数几个缺点。
- en: The principle advantage of a memory-mapped I/O subsystem is that the CPU can
    use any instruction that accesses memory, such as `mov`, to transfer data between
    the CPU and a peripheral. For example, if you’re trying to access a read/write
    or bidirectional port, you can use an 80x86 *read/modify/write* instruction, like
    `add`, to read the port, manipulate the value, and then write data back to the
    port, all with a single instruction. Of course, if the port is read-only or write-only,
    such an instruction will be of little use.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 内存映射I/O子系统的主要优点是CPU可以使用任何访问内存的指令，如`mov`，在CPU与外设之间传输数据。例如，如果你正在尝试访问一个读/写或双向端口，你可以使用80x86的*读/修改/写*指令，如`add`，来读取端口、操作值，然后将数据写回端口，所有这些操作只需一个指令。当然，如果端口是只读或只写的，那么这样的指令就没有太大用处。
- en: The big disadvantage of memory-mapped I/O devices is that they consume addresses
    in the CPU’s memory map. Every byte of address space that a peripheral device
    consumes is one less byte available for installing actual memory. Generally, the
    minimum amount of space you can allocate to a peripheral (or block of related
    peripherals) is a page of memory (4,096 bytes on an 80x86). Fortunately, a typical
    PC has only a couple dozen such devices, so this usually isn’t much of a problem.
    However, it can become a problem with some peripheral devices, like video cards,
    that consume a large chunk of the address space. Some video cards have between
    1GB and 32GB of on-board memory that they map into the memory address space, which
    means that the 1GB to 32GB address range consumed by such a card is not available
    to the system for use as regular RAM (though this is hardly a concern on a 64-bit
    processor).
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 内存映射 I/O 设备的一个大缺点是它们会占用 CPU 内存映射中的地址空间。外设设备消耗的每一个地址字节，都会减少一个可用于安装实际内存的字节。通常，分配给外设（或一组相关外设）的最小空间是一个内存页（在
    80x86 架构中为 4,096 字节）。幸运的是，一台典型的 PC 通常只有几十个这样的设备，因此这通常不是大问题。然而，对于一些外设设备（如显卡）来说，这可能会成为问题，因为它们会消耗大量地址空间。一些显卡拥有
    1GB 到 32GB 的板载内存，并将其映射到内存地址空间中，这意味着这些显卡消耗的 1GB 到 32GB 地址范围无法作为常规内存被系统使用（尽管在 64
    位处理器上，这几乎不会成为问题）。
- en: I/O and the Cache
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: I/O 与缓存
- en: The CPU cannot cache values intended for memory-mapped I/O ports. Caching data
    from an input port would mean that subsequent reads of the port would access the
    value in the cache rather than the port data, which could be different. Similarly,
    with a write-back cache mechanism, some writes might never reach an output port
    because the CPU might save up several writes in the cache before sending the last
    one to the actual I/O port. In order to avoid these potential problems, we need
    some mechanism to tell the CPU not to cache accesses to certain memory locations.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: CPU 不能缓存用于内存映射 I/O 端口的值。从输入端口缓存数据意味着后续读取该端口时，会从缓存中访问值，而不是直接从端口读取数据，而端口的数据可能会发生变化。同样，在写回缓存机制下，某些写操作可能永远无法到达输出端口，因为
    CPU 可能会先将多个写操作保存在缓存中，然后再将最后一个写操作发送到实际的 I/O 端口。为了避免这些潜在问题，我们需要一种机制来告诉 CPU 不要缓存对某些内存位置的访问。
- en: The solution is found in the CPU’s memory management subsystem. The 80x86’s
    page table entries, for example, contain a flag that the CPU can use to determine
    whether it is okay to map data from a page in memory to the cache. If this flag
    is set one way, the cache operates normally; if the flag is set the other way,
    the CPU does not cache accesses to that page.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 解决方案在于 CPU 的内存管理子系统。例如，80x86 的页表项包含一个标志，CPU 可以使用该标志来确定是否可以将内存中的页面数据映射到缓存中。如果该标志设置为某个方式，缓存会正常工作；如果该标志设置为另一种方式，CPU
    不会缓存对该页面的访问。
- en: '***12.3.2 I/O-Mapped Input/Output***'
  id: totrans-45
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***12.3.2 I/O 映射输入/输出***'
- en: As noted previously, I/O-mapped input/output uses a special I/O address space
    separate from the normal memory space, coupled with special machine instructions
    to access device addresses. For example, the 80x86 CPUs provide the `in` and `out`
    instructions specifically for this purpose. These instructions behave like `mov`
    except that they transmit data to and from the special I/O address space rather
    than the normal memory address space. Typically, processors that provide I/O-mapped
    input/output capabilities use the same physical address bus to transfer both memory
    addresses and I/O device addresses. Additional control lines differentiate between
    addresses that belong to the normal memory space and those that belong to the
    special I/O address space. This means that such CPUs could use both I/O-mapped
    input/output or memory-mapped I/O. Therefore, if the number of I/O-mapped locations
    in the CPU’s address space is insufficient, a hardware designer can always use
    memory-mapped I/O instead (as a video card does on a typical PC).
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，I/O 映射输入/输出使用一个与正常内存空间分开的特殊 I/O 地址空间，并结合特殊的机器指令来访问设备地址。例如，80x86 CPU 提供了
    `in` 和 `out` 指令，专门用于这个目的。这些指令的行为类似于 `mov`，不同之处在于它们传输数据时使用的是特殊的 I/O 地址空间，而不是普通的内存地址空间。通常，提供
    I/O 映射输入/输出功能的处理器使用相同的物理地址总线来传输内存地址和 I/O 设备地址。额外的控制线区分了属于正常内存空间的地址和属于特殊 I/O 地址空间的地址。这意味着这类
    CPU 可以同时使用 I/O 映射输入/输出或内存映射 I/O。因此，如果 CPU 地址空间中的 I/O 映射位置数量不足，硬件设计师始终可以改用内存映射
    I/O（就像典型 PC 上的显卡一样）。
- en: In modern 80x86 PC systems that utilize the PCI bus (or later variants), special
    peripheral chips on the system’s motherboard remap the I/O address space into
    the main memory space, allowing programs to access I/O-mapped devices using either
    memory-mapped or I/O-mapped input/output.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 在现代的 80x86 PC 系统中，使用 PCI 总线（或其后续变种）的系统主板上的特殊外设芯片将 I/O 地址空间重新映射到主内存空间，从而允许程序使用内存映射或
    I/O 映射输入/输出访问 I/O 映射的设备。
- en: '***12.3.3 Direct Memory Access***'
  id: totrans-48
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***12.3.3 直接内存访问***'
- en: Memory-mapped I/O subsystems and I/O-mapped subsystems are both forms of *programmed
    I/O*, as they require the CPU to move data between the peripheral device and memory.
    To store into memory a sequence of 10 bytes taken from a programmed I/O input
    port, the CPU must read each value from the input port and store it into memory.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 内存映射 I/O 子系统和 I/O 映射子系统都是*程序化 I/O*的一种形式，因为它们要求 CPU 在外设设备和内存之间移动数据。为了将从程序化 I/O
    输入端口获取的 10 字节数据存储到内存中，CPU 必须从输入端口读取每个值并将其存储到内存中。
- en: However, processing data 1 byte (or word or double word) at a time via the CPU
    may be too slow for very high-speed I/O devices. Such devices generally have an
    interface to the CPU’s bus so they can read and write memory directly—that is,
    without the CPU as an intermediary. Direct memory access (DMA) allows I/O operations
    to proceed in parallel with other CPU operations, which increases the overall
    speed of the system—unless the CPU and the DMA device both try to use the address
    and data buses at the same time. Concurrent processing occurs only if the bus
    is free for use by the I/O device, which happens when the CPU has a cache and
    is accessing cached code and data. Nevertheless, even if the CPU must halt and
    wait for a DMA operation to complete before beginning a different operation, the
    DMA approach is still much faster, because many of the bus operations are instruction
    fetches or I/O port accesses that don’t occur during DMA operations.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，通过 CPU 每次处理 1 字节（或字或双字）的数据可能对于非常高速的 I/O 设备来说过于缓慢。这些设备通常有一个接口连接到 CPU 的总线，这样它们可以直接读写内存——也就是说，无需
    CPU 作为中介。直接内存访问（DMA）允许 I/O 操作与其他 CPU 操作并行进行，从而提高系统的整体速度——除非 CPU 和 DMA 设备同时试图使用地址和数据总线。只有当总线为空闲时，I/O
    设备才能并行处理，这种情况发生在 CPU 拥有缓存并访问缓存的代码和数据时。尽管如此，即使 CPU 必须停止并等待 DMA 操作完成才能开始不同的操作，DMA
    方法仍然要快得多，因为许多总线操作是指令获取或 I/O 端口访问，这些操作在 DMA 操作期间不会发生。
- en: A typical DMA controller consists of a pair of counters and other circuitry
    that interfaces with memory and the peripheral device. One of the counters serves
    as an address register, supplying an address on the address bus for each transfer.
    The second counter specifies the number of data transfers. The application initializes
    the DMA controller’s address counter with the address of the block where it should
    begin transferring data. Each time the peripheral device wants to transfer data
    to or from memory, it sends a signal to the DMA controller, which places the value
    of the address counter on the address bus. In coordination with the DMA controller,
    the peripheral device places data on the data bus to write to memory during an
    input operation, or it reads data from the data bus, taken from memory, during
    an output operation.^([2](footnotes.xhtml#fn12_2a)) After a successful data transfer,
    the DMA controller increments its address register and decrements the transfer
    counter. This process repeats until the transfer counter decrements to zero.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 一个典型的 DMA 控制器由一对计数器和其他电路组成，电路与内存和外设设备进行接口。一个计数器作为地址寄存器，为每次传输提供地址总线上的地址。第二个计数器指定数据传输的数量。应用程序用应该开始传输数据的块的地址初始化
    DMA 控制器的地址计数器。每当外设设备想要向内存传输数据或从内存传输数据时，它会向 DMA 控制器发送信号，后者将地址计数器的值放置在地址总线上。与 DMA
    控制器协调，外设设备在输入操作期间将数据放置到数据总线上以写入内存，或者在输出操作期间从数据总线上读取内存中取出的数据。^([2](footnotes.xhtml#fn12_2a))
    在成功的数据传输后，DMA 控制器递增其地址寄存器并递减传输计数器。此过程会重复，直到传输计数器递减为零。
- en: '**12.4 I/O Speed Hierarchy**'
  id: totrans-52
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**12.4 I/O 速度层级**'
- en: Different peripheral devices have different data transfer rates. Some devices,
    like keyboards, are extremely slow compared to CPU speeds. Other devices, like
    solid-state disk drives, can actually transfer data faster than the CPU can process
    it. The appropriate programming technique for data transfer depends strongly on
    the transfer speed of the peripheral device involved in the I/O operation. Therefore,
    before discussing how to write the most appropriate code, we should establish
    some terminology to describe the different transfer rates of peripheral devices.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 不同的外设有不同的数据传输速率。一些设备，如键盘，与 CPU 的速度相比极为缓慢。其他设备，如固态硬盘驱动器，实际上可以比 CPU 处理数据的速度更快地传输数据。数据传输的适当编程技巧在很大程度上取决于参与
    I/O 操作的外设的传输速度。因此，在讨论如何编写最合适的代码之前，我们应当建立一些术语，以描述外设的不同传输速率。
- en: '**Low-speed devices** Devices that produce or consume data at a rate much slower
    than the CPU is capable of processing. For the purposes of discussion, we’ll assume
    that low-speed devices operate at speeds that are three or more orders of magnitude
    slower than the CPU.'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: '**低速设备**：数据产生或消耗速率远低于 CPU 可处理速率的设备。为了讨论的目的，我们假设低速设备的工作速度比 CPU 慢三倍或更多数量级。'
- en: '**Medium-speed devices** Devices that transfer data at approximately the same
    rate as, or up to three orders of magnitude slower than, the CPU (accessing the
    device using programmed I/O).'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: '**中速设备**：数据传输速率大致与 CPU 相同，或比 CPU 慢三个数量级的设备（使用程序化 I/O 访问设备）。'
- en: '**High-speed devices** Devices that transfer data faster than the CPU is capable
    of handling using programmed I/O.'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: '**高速设备**：数据传输速度超过 CPU 使用程序化 I/O 处理的设备。'
- en: The speed of the peripheral device determines the type of I/O mechanism used
    for the I/O operation. Clearly, high-speed devices must use DMA because programmed
    I/O is too slow. Medium- and low-speed devices can use any of the three I/O mechanisms
    for data transfer (though low-speed devices rarely use DMA because of the cost
    of the extra hardware involved).
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 外设的速度决定了 I/O 操作使用的 I/O 机制类型。显然，高速设备必须使用 DMA，因为程序化 I/O 太慢。中速和低速设备可以使用三种 I/O 机制中的任何一种进行数据传输（尽管低速设备由于额外硬件成本的原因很少使用
    DMA）。
- en: With typical bus architectures, CPUs are capable of one transfer per microsecond
    or better. Therefore, high-speed devices are those that transfer data more rapidly
    than once per microsecond. Medium-speed transfers are those that involve a data
    transfer every 1 to 100 microseconds. Low-speed devices usually transfer data
    less often than once every 100 microseconds. Of course, these definitions for
    low-, medium-, and high-speed devices are system dependent. Faster CPUs with faster
    buses allow faster medium-speed operations.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 对于典型的总线架构，CPU 每微秒可以进行一次数据传输，甚至更快。因此，高速设备是指那些数据传输速度超过每微秒一次的设备。中速传输是指每 1 到 100
    微秒进行一次数据传输的设备。低速设备通常每 100 微秒以上才传输一次数据。当然，低速、中速和高速设备的这些定义是依赖于系统的。更快的 CPU 和总线支持更快的中速操作。
- en: Note that one transfer per microsecond is not the same as a 1MB-per-second transfer
    rate. A peripheral device can actually transfer more than 1 byte per data transfer
    operation. For example, when using the 80x86 `in(dx,` `eax);` instruction, the
    peripheral device can transfer 4 bytes in one transfer. Therefore, if the device
    is capable of one transfer per microsecond, it can transfer 4MB per second using
    this instruction.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，每微秒一次的传输与每秒 1MB 的传输速率并不相同。外设实际上每次数据传输操作可以传输超过 1 字节的数据。例如，当使用 80x86 `in(dx,`
    `eax);` 指令时，外设可以在一次传输中传输 4 字节的数据。因此，如果设备能够每微秒进行一次传输，它可以通过此指令以每秒 4MB 的速度进行数据传输。
- en: '**12.5 System Buses and Data Transfer Rates**'
  id: totrans-60
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**12.5 系统总线和数据传输速率**'
- en: In [Chapter 6](ch06.xhtml#ch06), you saw that the CPU communicates with memory
    and I/O devices using the system bus. If you’ve ever looked inside a computer
    or read the specifications for a system, you’ve probably seen terms like *[PCI](gloss01.xhtml#gloss01_192)*,
    *[ISA](gloss01.xhtml#gloss01_127)*, *EISA*, or even *NuBus* used to refer to the
    computer’s system bus. In this section, we’ll discuss how these different computer
    system buses relate to the CPU bus, and how they affect the performance of a system.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第 6 章](ch06.xhtml#ch06)中，你看到 CPU 使用系统总线与内存和 I/O 设备进行通信。如果你曾经查看过计算机内部或阅读过系统规格，你可能见过诸如
    *[PCI](gloss01.xhtml#gloss01_192)*、 *[ISA](gloss01.xhtml#gloss01_127)*、 *EISA*
    或甚至 *NuBus* 等术语，用来指代计算机的系统总线。在本节中，我们将讨论这些不同的计算机系统总线如何与 CPU 总线相关，以及它们如何影响系统的性能。
- en: A single computer system often employs multiple buses. Therefore, a software
    engineer can choose which peripheral devices to use based upon their bus connections.
    Maximizing performance for a particular bus may require different programming
    techniques than for other buses. Although it’s not possible to choose the buses
    a particular computer system employs, a software engineer can select among the
    available buses to improve an application.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 单一计算机系统通常使用多个总线。因此，软件工程师可以根据外设设备的总线连接选择使用哪些外设设备。为了最大化某一特定总线的性能，可能需要不同于其他总线的编程技术。尽管无法选择特定计算机系统所采用的总线，但软件工程师可以在可用的总线中进行选择，以提升应用程序的性能。
- en: Computer system buses like PCI (Peripheral Component Interconnect) and ISA (Industry
    Standard Architecture) define physical connectors inside a computer system. Specifically,
    they describe the set of electronic signals (*connector pins* on the bus), physical
    dimensions (that is, connector layouts and distances from one another), and a
    data transfer protocol for connecting different electronic devices. These buses
    are often extensions of the CPU’s *local bus* (the address, data, and control
    lines), because many of the signals on the system buses are identical to the CPU’s
    signals.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 计算机系统总线，如 PCI（外设组件互连）和 ISA（工业标准架构），定义了计算机系统内部的物理连接器。具体来说，它们描述了一组电子信号（总线上的*连接针脚*）、物理尺寸（即连接器布局及其相互之间的距离）以及连接不同电子设备的数据传输协议。这些总线通常是
    CPU *本地总线*（地址、数据和控制线）的扩展，因为系统总线上的许多信号与 CPU 的信号是相同的。
- en: However, peripheral buses themselves are not necessarily identical to the CPU’s
    bus—they may have additional or fewer signals compared to those on the CPU. For
    example, the ISA bus supports only 24 address lines compared with the Intel and
    AMD’s x86-64 40 to 52 address lines.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，外设总线本身不一定与 CPU 的总线相同——它们可能比 CPU 上的信号多或少。例如，ISA 总线仅支持 24 条地址线，而英特尔和 AMD 的
    x86-64 总线则支持 40 到 52 条地址线。
- en: Different peripheral devices are designed to use different peripheral buses.
    [Figure 12-6](ch12.xhtml#ch12fig06) shows the organization of the PCI and ISA
    buses in a typical computer system.^([3](footnotes.xhtml#fn12_3a))
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 不同的外设设备被设计为使用不同的外设总线。[图 12-6](ch12.xhtml#ch12fig06) 显示了典型计算机系统中 PCI 和 ISA 总线的组织结构。^([3](footnotes.xhtml#fn12_3a))
- en: '![image](../images/12fig06.jpg)'
  id: totrans-66
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/12fig06.jpg)'
- en: '*Figure 12-6: Connection of the PCI and ISA buses in a typical PC*'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 12-6：典型 PC 中 PCI 和 ISA 总线的连接*'
- en: Notice how the CPU’s address and data buses connect to a PCI bus controller
    peripheral device, but not to the PCI bus itself. The PCI bus controller contains
    two sets of pins, providing a *bridge* between the CPU’s local bus and the PCI
    bus. The signal lines on the local bus are not connected directly to the corresponding
    lines on the PCI bus; instead, the PCI bus controller acts as an intermediary,
    rerouting all data transfer requests between the CPU and the PCI bus.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 注意 CPU 的地址和数据总线如何连接到 PCI 总线控制器外设设备，但不直接连接到 PCI 总线本身。PCI 总线控制器包含两组针脚，提供一个 *桥接*，连接
    CPU 的本地总线和 PCI 总线。当地总线上的信号线不会直接连接到 PCI 总线上的对应信号线；相反，PCI 总线控制器充当中介，重新路由所有 CPU 和
    PCI 总线之间的数据传输请求。
- en: Also note that the ISA bus controller is usually connected to the PCI bus controller,
    not directly to the CPU. This is typically for cost or performance reasons (there
    may be a limit to the number of devices that can connect directly to the CPU bus
    without additional buffering, for example).
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，ISA 总线控制器通常连接到 PCI 总线控制器，而不是直接连接到 CPU。这通常是出于成本或性能的考虑（例如，可能有一个限制，规定能够直接连接到
    CPU 总线的设备数量，超出这个数量可能需要额外的缓冲）。
- en: The CPU’s local bus usually runs at some fraction of the CPU’s frequency. Typical
    local bus frequencies are currently 66 MHz, 100 MHz, 133 MHz, 400 MHz, 533 MHz,
    and 800 MHz, but they may become even faster. Usually, only memory and a few selected
    peripherals like the PCI bus controller sit on the CPU’s bus and operate at this
    high frequency.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: CPU的本地总线通常以CPU频率的一部分运行。当前典型的本地总线频率为66 MHz、100 MHz、133 MHz、400 MHz、533 MHz和800
    MHz，但它们可能会变得更快。通常，只有内存和少数选定外设，如PCI总线控制器，才能连接到CPU的总线，并在这个高频率下运行。
- en: Because a typical CPU’s bus is 64 bits wide and it’s theoretically possible
    to achieve one data transfer per clock cycle, the CPU’s bus has a maximum data
    transfer rate of 8 bytes times the clock frequency, or 800MB per second for a
    100 MHz bus. In practice, CPUs rarely achieve the maximum data transfer rate,
    but they do achieve some percentage of it, so the faster the bus, the more data
    can move in and out of the CPU (and caches) in a given amount of time.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 因为典型的CPU总线宽度为64位，并且理论上每个时钟周期可以完成一次数据传输，所以CPU的总线最大数据传输速率为每秒8字节乘以时钟频率，例如对于100
    MHz的总线为每秒800MB。实际上，CPU很少能够达到最大数据传输速率，但它们通常能达到某个百分比的速率，因此总线越快，数据在给定时间内进出CPU（及缓存）的速度就越快。
- en: '***12.5.1 Performance of the PCI Bus***'
  id: totrans-72
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***12.5.1 PCI总线的性能***'
- en: The PCI bus comes in several configurations. The base configuration has a 32-bit-wide
    data bus operating at 33 MHz. Like the CPU’s local bus, the PCI bus is theoretically
    capable of transferring data on each clock cycle. This means that the bus has
    a theoretical maximum data transfer rate of 4 bytes times 33 MHz, or 132MB per
    second. In practice, though, the PCI bus doesn’t come anywhere near this level
    of performance except in short bursts. Newer versions of the PCI-e offer up to
    16 “lanes,” allowing for much faster data transfer (largely for high-performance
    video cards).
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: PCI总线有几种配置。基础配置有一个32位宽的数据总线，运行在33 MHz。像CPU的本地总线一样，PCI总线理论上能够在每个时钟周期传输数据。这意味着总线的理论最大数据传输速率为4字节乘以33
    MHz，即每秒132MB。然而，实际上，PCI总线除非在短暂的突发模式下，否则无法接近这一性能水平。更新版本的PCI-e提供多达16条“通道”，使数据传输速度更快（主要用于高性能显卡）。
- en: Whenever the CPU wants to access a peripheral on the PCI bus, it must negotiate
    with other peripheral devices for the right to use the bus. This negotiation can
    take several clock cycles before the PCI controller grants the CPU access to the
    bus. If a CPU writes a double word per bus transfer, the negotiation time actually
    slows the transfer rate dramatically. The only way to achieve anywhere near the
    maximum theoretical bandwidth on the bus is to use a DMA controller and move blocks
    of data in *burst mode*. In burst mode, the DMA controller negotiates just once
    for the bus and then makes many transfers without giving up the bus between each
    one.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 每当CPU想要访问PCI总线上的外设时，它必须与其他外设协商以获得使用总线的权利。这种协商可能需要几个时钟周期，直到PCI控制器授予CPU访问总线的权限。如果CPU每次总线传输写入双字，协商时间实际上会大大降低传输速率。要接近总线的最大理论带宽，唯一的方法是使用DMA控制器并以*突发模式*传输数据。在突发模式下，DMA控制器只进行一次协商，然后进行多次传输，在每次传输之间不释放总线。
- en: There are a couple of enhancements to the PCI bus that improve performance.
    Some PCI buses support a 64-bit-wide data path. This, obviously, doubles the maximum
    theoretical data transfer rate from 4 bytes per transfer to 8 bytes per transfer.
    Another enhancement is running the bus at 66 MHz, which also doubles the throughput.
    With a 64-bit-wide, 66 MHz bus, you would quadruple the data transfer rate of
    the baseline configuration. These optional enhancements to the PCI bus allow it
    to grow with the CPU as CPUs increase their performance. A high-performance version
    of the PCI bus, PCI-X, was available for a while, but it has largely been replaced
    by the PCI-e bus. PCI-e is a serial bus, transmitting data serially over a few
    data lines. However, it uses lanes to pass additional data in parallel. For example,
    a 16-lane PCI-e bus is 16 times faster than a single-lane variant.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: PCI总线有几个增强功能可以提高性能。一些PCI总线支持64位宽的数据路径。显然，这将最大理论数据传输速率从每次传输4字节提高到每次传输8字节。另一个增强功能是将总线运行在66
    MHz，这也将吞吐量翻倍。使用64位宽、66 MHz的总线，数据传输速率将是基线配置的四倍。这些PCI总线的可选增强功能使其能够随着CPU性能的提升而增长。高性能版本的PCI总线——PCI-X曾经使用一段时间，但它已经被PCI-e总线所取代。PCI-e是一种串行总线，通过几条数据线串行传输数据。然而，它使用通道并行传输额外的数据。例如，16通道的PCI-e总线比单通道版本快16倍。
- en: '***12.5.2 Performance of the ISA Bus***'
  id: totrans-76
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***12.5.2 ISA总线的性能***'
- en: The ISA bus is a carryover from the original PC/AT computer system. This bus
    is 16 bits wide and operates at 8 MHz. It requires four clock cycles for each
    bus cycle (a *bus cycle* is the time it takes to transfer one 16-bit word of data
    across the ISA bus). For this and other reasons, the ISA bus is capable of about
    only one data transmission per microsecond. With a 16-bit-wide bus, data transfer
    is limited to about 2MB per second. This is much slower than both the CPU’s local
    bus and the PCI bus. Generally, the ISA bus is really only capable of supporting
    low-speed and medium-speed devices—like an RS-232 communications device, a modem,
    or a parallel printer interface—to the ISA bus. Most other devices, like disks,
    scanners, and network cards, are too fast for the ISA bus.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: ISA总线是从原始的PC/AT计算机系统继承下来的。该总线宽16位，工作频率为8 MHz。每个总线周期需要四个时钟周期（*总线周期*是指通过ISA总线传输一个16位数据字所需的时间）。由于这些原因，ISA总线每微秒大约只能完成一次数据传输。使用16位宽的总线时，数据传输速率大约为每秒2MB。这比CPU本地总线和PCI总线都要慢得多。通常，ISA总线只能支持低速和中速设备——如RS-232通信设备、调制解调器或并行打印机接口——连接到ISA总线。大多数其他设备，如磁盘、扫描仪和网络卡，速度都超过了ISA总线的能力。
- en: Accessing the ISA bus on most systems involves first negotiating for the PCI
    bus, but the PCI bus is so much faster than the ISA bus that this negotiation
    time has very little impact on the performance of peripherals on the ISA bus.
    Therefore, connecting the ISA controller directly to the CPU’s local bus wouldn’t
    noticeably improve performance.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 在大多数系统上访问ISA总线首先需要争取PCI总线的使用权，但因为PCI总线的速度远快于ISA总线，这种协商时间对ISA总线上外设的性能几乎没有影响。因此，将ISA控制器直接连接到CPU的本地总线并不会显著提高性能。
- en: Fortunately, the ISA bus is thoroughly obsolete these days, and you won’t find
    it on modern PCs. A few industrial PCs and SBCs (single-board computers) support
    ISA bus connections for legacy applications, but other than that the ISA bus is
    dead.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，ISA总线如今已经彻底过时，你在现代PC上是找不到它的。少数工业PC和SBC（单板计算机）仍然支持ISA总线连接，以兼容遗留应用程序，但除此之外，ISA总线已经不复存在。
- en: '***12.5.3 The AGP Bus***'
  id: totrans-80
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***12.5.3 AGP总线***'
- en: Video display (aka graphics) cards are very special peripherals that need maximum
    bus performance to ensure quick screen updates and fast graphic operations. Unfortunately,
    if the CPU has to constantly negotiate with other peripherals for the use of the
    PCI bus, graphics performance can suffer. To overcome this problem, video card
    designers created the *Accelerated Graphics Port (AGP)*, an interface between
    the CPU’s local bus and the video display card that provides various control lines
    and bus protocols specifically designed for video display cards.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 视频显示（即图形）卡是非常特殊的外设，它们需要极高的总线性能，以确保快速的屏幕更新和图形操作。不幸的是，如果CPU必须不断与其他外设争用PCI总线的使用权，图形性能可能会受到影响。为了解决这个问题，显卡设计师创造了*加速图形端口（AGP）*，它是CPU本地总线与视频显示卡之间的接口，提供了多种控制线和总线协议，专门为视频显示卡设计。
- en: The AGP connection lets the CPU quickly move data to and from the video display
    RAM (see [Figure 12-7](ch12.xhtml#ch12fig07)).
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: AGP连接允许CPU快速将数据传输到视频显示RAM并从中获取数据（见[图12-7](ch12.xhtml#ch12fig07)）。
- en: '![image](../images/12fig07.jpg)'
  id: totrans-83
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/12fig07.jpg)'
- en: '*Figure 12-7: The AGP bus interface*'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: '*图12-7：AGP总线接口*'
- en: Because there’s only one AGP port per system, only one card can use the AGP
    slot at a time. The upside of this is that the system never has to negotiate for
    access to the AGP bus. However, by 2008 the performance of video cards surpassed
    that of the AGP bus. Most modern video cards use multilane PCI-e bus interfaces
    instead.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 因为每个系统只有一个AGP端口，所以一次只能有一张显卡使用AGP插槽。这样做的好处是系统无需与其他设备争用AGP总线的访问权限。然而，到了2008年，显卡的性能超过了AGP总线的性能。大多数现代显卡改用多通道PCI-e总线接口。
- en: '**12.6 Buffering**'
  id: totrans-86
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**12.6 缓冲区**'
- en: 'If a particular I/O device produces or consumes data faster than the system
    is capable of transferring data to or from that device, the system designer has
    two choices: provide a faster connection between the CPU and the device, or slow
    down the rate of transfer between the two.'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 如果某个I/O设备生成或消耗数据的速度超过了系统能够从该设备传输数据的速度，系统设计者有两个选择：提供更快的连接以连接CPU和设备，或降低两者之间的数据传输速度。
- en: If the peripheral device is connected to a slow bus like ISA, a system designer
    can create a faster connection by switching to a wider bus like the 64-bit PCI,
    a faster bus (one with a higher frequency), or a higher-performance bus like PCI-e.
    System designers can also sometimes create a faster interface to the bus, as they
    did with the AGP connection.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 如果外围设备连接到像ISA这样较慢的总线，系统设计师可以通过切换到更宽的总线（如64位PCI）、更快的总线（具有更高频率的总线）或更高性能的总线（如PCI-e）来创建更快的连接。系统设计师有时还可以创建更快的总线接口，正如他们在AGP连接中所做的那样。
- en: The alternative—slowing down the transfer rate between the peripheral and the
    computer system—isn’t always as bad an option as it might initially seem. Most
    high-speed devices don’t transfer data to the system at a constant rate. Instead,
    they typically transfer a block of data rapidly and then sit idle for some time.
    Although the burst rate is higher than the CPU or memory can handle, the average
    data transfer rate is usually lower. If you can average out the high-bandwidth
    peaks and transfer some of the data when the peripheral is inactive, you can easily
    move data between the peripheral and the computer system without resorting to
    an expensive, high-bandwidth bus or connection.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种选择——减慢外围设备与计算机系统之间的传输速率——并不像最初看起来那么糟糕。大多数高速设备并不是以恒定的速率向系统传输数据。相反，它们通常会快速传输一块数据，然后闲置一段时间。虽然突发速率高于CPU或内存能够处理的速率，但平均数据传输速率通常较低。如果你能够平衡高带宽的峰值，并在外围设备空闲时传输一些数据，就可以轻松地在外围设备和计算机系统之间移动数据，而不需要依赖昂贵的高带宽总线或连接。
- en: The trick is to use memory on the peripheral side to buffer the data. The peripheral
    can rapidly fill this buffer with data during an input operation, and rapidly
    extract data from the buffer during an output operation. Once the peripheral device
    is inactive, the system either empties or refills the buffer at a sustainable
    rate. As long as the average data transfer rate of the peripheral device is below
    the maximum bandwidth the system supports, and the buffer is large enough to hold
    bursts of data going to and from the peripheral, this scheme lets the peripheral
    communicate with the system at a lower average data transfer rate.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 这个技巧是利用外围设备的内存来缓冲数据。外围设备在输入操作时可以快速将数据填充到缓冲区，而在输出操作时可以快速从缓冲区提取数据。一旦外围设备处于空闲状态，系统就以可持续的速度清空或重新填充缓冲区。只要外围设备的平均数据传输速率低于系统所支持的最大带宽，并且缓冲区足够大以容纳传入和传出的数据，这种方案就可以让外围设备以较低的平均数据传输速率与系统进行通信。
- en: Often, to save costs, the buffering takes place in memory on the CPU rather
    than on the peripheral device. In this case, it is often the software engineer’s
    responsibility to initialize the buffer for a peripheral device. In some cases,
    neither the peripheral device nor the OS provides a buffer for the peripheral’s
    data, so the application must do so in order to maintain maximum performance and
    avoid data loss. In other cases, the device or OS may provide a small buffer,
    but the application itself might not process the data often enough to avoid data
    overruns in the small buffer; in these situations, an application can create a
    larger buffer that is local to the application.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，为了节省成本，缓冲会发生在CPU的内存中，而不是外围设备上。在这种情况下，通常由软件工程师负责为外围设备初始化缓冲区。在某些情况下，外围设备或操作系统都不会为外围设备的数据提供缓冲区，因此应用程序必须提供缓冲区，以保持最大性能并避免数据丢失。在其他情况下，设备或操作系统可能提供一个小的缓冲区，但应用程序可能不会处理数据足够频繁，导致小缓冲区中的数据溢出；在这种情况下，应用程序可以创建一个更大的本地缓冲区。
- en: '**12.7 Handshaking**'
  id: totrans-92
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**12.7 握手**'
- en: Many I/O devices cannot accept data at just any rate. For example, an i9-based
    PC is capable of sending several hundred million characters per second to a printer,
    but printers can’t print that many characters each second. Likewise, an input
    device such as a keyboard will never transmit several million keystrokes per second
    to the system (because the keyboard operates at human speeds, not computer speeds).
    Because of these differences in capabilities, the CPU needs some way to coordinate
    data transfer between the computer system and its peripheral devices.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 许多I/O设备不能接受任何速率的数据。例如，一个基于i9的PC每秒可以发送数亿个字符到打印机，但打印机无法每秒打印这么多字符。同样，一个输入设备（如键盘）永远不会每秒向系统传输数百万次按键（因为键盘的操作速度是人类速度，而不是计算机速度）。由于这些能力上的差异，CPU需要某种方式来协调计算机系统与外围设备之间的数据传输。
- en: One common approach is to send and receive status bits on a port separate from
    the data port. For example, a printer could send a single bit to tell the system
    whether it is ready to accept more data. Likewise, a single status bit in a different
    port could specify whether a keystroke is available at the keyboard data port.
    The CPU can test these bits prior to writing a character to the printer or reading
    a key from the keyboard.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 一种常见的方法是通过一个与数据端口不同的端口发送和接收状态位。例如，打印机可以发送一个单独的位来告诉系统它是否准备好接收更多数据。同样，另一个端口中的单一状态位可以指示键盘数据端口是否有按键输入。CPU可以在向打印机写入字符或从键盘读取键值之前测试这些位。
- en: Using status bits to indicate that a device is ready to accept or transmit data
    is known as *handshaking*, so named because the protocol is similar to two people
    signifying agreement with a handshake.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 使用状态位指示设备是否准备好接收或传输数据被称为*握手*，因为这种协议类似于两个人通过握手表示达成一致。
- en: 'The following 80x86 assembly language program segment demonstrates how handshaking
    works:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 以下80x86汇编语言程序段演示了握手的工作原理：
- en: '[PRE0]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: This code fragment will continuously loop while the HO bit of the printer status
    register (at input port `$379`) contains `0` and will exit once the HO bit is
    set (indicating that the printer is ready to accept data).
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码会持续循环，直到打印机状态寄存器（在输入端口`$379`处）的HO位为`0`，并且一旦HO位被设置（表示打印机已准备好接收数据），循环才会退出。
- en: '**12.8 Timeouts on an I/O Port**'
  id: totrans-99
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**12.8 I/O端口超时**'
- en: One problem with the `repeat..until` loop in the previous section is that it
    could spin indefinitely as it waits for the printer to become ready to accept
    additional input. If someone turns the printer off or the printer cable becomes
    disconnected, the program could freeze up, forever waiting for the printer to
    become available. Usually, it’s a better idea to inform the user when something
    goes wrong rather than allowing the system to hang. To do this, include a *timeout*
    period in the loop; once exceeded, the timeout causes the program to alert the
    user that something is wrong with the peripheral device.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 上一节中`repeat..until`循环的一个问题是，它可能会无限旋转，等待打印机准备好接收更多输入。如果有人关闭了打印机或者打印机电缆断开，程序可能会冻结，永远等待打印机重新可用。通常，更好的做法是在出现问题时告知用户，而不是让系统挂起。为此，可以在循环中加入*超时*期限；一旦超过该期限，超时就会导致程序提示用户外设设备出现问题。
- en: You can expect some sort of response from most peripheral devices within a reasonable
    amount of time. For example, even in the worst case, most printers will be ready
    to accept additional character data within a few seconds of the last transmission.
    Therefore, something is probably wrong if 30 seconds or more has passed without
    the printer accepting a new character. A program written to detect this kind of
    problem typically pauses, asking the user to check the printer, and then resumes
    printing once the user indicates the problem is resolved.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数外设设备在合理时间内都会有所响应。例如，即使在最坏的情况下，大多数打印机也会在上次传输后的几秒钟内准备好接收额外的字符数据。因此，如果超过30秒或更长时间，打印机没有接收新字符，可能存在问题。通常，编写的程序会暂停，提示用户检查打印机，之后用户确认问题解决后，程序会继续打印。
- en: Choosing a good timeout period is not an easy task. You must carefully balance
    the irritation of possible false alarms from the program with the pain of having
    it lock up for long periods when something actually is wrong. Both situations
    are equally annoying.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 选择一个合适的超时期限并不是一件容易的事。你必须仔细平衡程序可能产生的虚假警报带来的烦恼与程序在出现实际问题时长时间卡住的痛苦。这两种情况同样令人恼火。
- en: 'An easy way to create a timeout period is to count the number of times the
    program loops while waiting for a handshake signal from a peripheral. Consider
    the following modification to the `repeat..until` loop from the previous section:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 创建超时期限的一个简单方法是计算程序在等待外设的握手信号时循环的次数。考虑以下对上一节`repeat..until`循环的修改：
- en: '[PRE1]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: This code will exit once the printer is ready to accept data or when approximately
    30 seconds have expired. You might question the 30-second figure, since a software-based
    loop (counting down ECX to 0) should run at different speeds on different processors.
    However, the `in()` instruction reads a port on the bus, and that means this instruction
    will take approximately 1 microsecond to execute (I/O ports often inject lots
    of wait states). Hence, one million times through the loop will take about a second
    (plus or minus 50 percent, but close enough for our purposes). This is true almost
    regardless of the CPU frequency.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码将在打印机准备好接受数据时退出，或者大约30秒后退出。你可能会对30秒的数字产生疑问，因为基于软件的循环（将ECX计数到0）在不同处理器上运行的速度应该不同。然而，`in()`指令读取总线上的端口，这意味着该指令执行大约需要1微秒（I/O端口通常会注入很多等待状态）。因此，循环执行一百万次大约需要1秒（上下浮动50%，但对于我们的目的来说足够接近）。几乎无论CPU的频率如何，这一点都是成立的。
- en: '**12.9 Interrupts and Polled I/O**'
  id: totrans-106
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**12.9 中断和轮询输入/输出**'
- en: '*[Polling](gloss01.xhtml#gloss01_195)* is the process of constantly testing
    a port to see if data is available. The handshaking loops of the previous sections
    provide good examples of polling—the CPU waits in a short loop, testing the printer
    port’s status value until the printer is ready to accept more data, and then the
    CPU can transfer more data to the printer. Polled I/O is inherently inefficient.
    If the printer in this example takes 10 seconds to accept another byte of data,
    the CPU spins, doing nothing productive for those 10 seconds.'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: '*[轮询](gloss01.xhtml#gloss01_195)*是不断测试端口以查看数据是否可用的过程。前面章节中的握手循环提供了轮询的好例子——CPU在一个短小的循环中等待，测试打印机端口的状态值，直到打印机准备好接受更多数据，然后CPU可以将更多数据传输到打印机。轮询输入/输出本质上是低效的。如果这个例子中的打印机需要10秒钟来接收另一个字节的数据，那么在这10秒钟内，CPU什么都不做，完全浪费时间。'
- en: In early personal computer systems, this is exactly how a program would behave.
    When a program wanted to read a key from the keyboard, it would poll the keyboard
    status port until a key was available. These early computers could not do other
    processing while waiting for the keyboard.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 在早期的个人计算机系统中，程序的行为正是如此。当程序想要从键盘读取一个按键时，它会轮询键盘状态端口，直到有按键输入。这些早期的计算机在等待键盘时无法进行其他处理。
- en: 'The solution to this problem is to use an *interrupt mechanism*. An interrupt
    is triggered by an external hardware event, such as the printer becoming ready
    to accept another character, that causes the CPU to interrupt its current instruction
    sequence and call a special *interrupt service routine (ISR)*. Typically, an ISR
    runs through the following sequence of events:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 解决这个问题的方法是使用*中断机制*。中断是由外部硬件事件触发的，例如打印机准备好接收另一个字符，这会导致CPU中断当前的指令序列并调用一个特殊的*中断服务程序（ISR）*。通常，ISR会执行以下一系列事件：
- en: It preserves the current values of all machine registers and flags so that the
    interrupted computation can be continued later.
  id: totrans-110
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 它保留了所有机器寄存器和标志的当前值，以便中断的计算可以稍后继续。
- en: It does whatever operation is necessary to *service* the interrupt.
  id: totrans-111
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 它执行所需的操作来*服务*该中断。
- en: It restores the registers and flags to the values they had before the interrupt.
  id: totrans-112
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 它恢复寄存器和标志为中断前的值。
- en: It resumes execution of the code that was interrupted.
  id: totrans-113
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 它恢复被中断的代码的执行。
- en: In most computer systems, typical I/O devices generate an interrupt whenever
    they make data available to the CPU, or when they become able to accept data from
    the CPU. The ISR quickly processes the interrupt request in the background, allowing
    some other computation to proceed normally in the foreground.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 在大多数计算机系统中，典型的I/O设备在将数据提供给CPU时，或在能够接收来自CPU的数据时，都会产生一个中断。ISR在后台快速处理中断请求，允许前台的其他计算继续正常进行。
- en: Though ISRs are usually written by OS designers or peripheral device manufacturers,
    most OSes enable you to pass an interrupt to an application via *signals* or some
    similar mechanism. This allows you to include ISRs directly within an application.
    You could use this facility, for example, to have a peripheral device notify your
    application when its internal buffer is full and the application needs to copy
    data from the peripheral’s buffer to an application buffer to prevent data loss.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然ISR通常由操作系统设计者或外围设备制造商编写，大多数操作系统允许通过*信号*或类似机制将中断传递给应用程序。这使得你可以直接在应用程序中包含ISR。例如，你可以利用这个功能，当外围设备的内部缓冲区已满时，通知应用程序，并让应用程序将数据从外围设备的缓冲区复制到应用程序的缓冲区，以防止数据丢失。
- en: '**12.10 Protected-Mode Operation and Device Drivers**'
  id: totrans-116
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**12.10 受保护模式操作与设备驱动程序**'
- en: If you’re working on an ancient Windows 95 or 98 system, you can write assembly
    code to access I/O ports directly. The handshaking code shown earlier is a good
    example of this. However, modern versions of Windows and all versions of Linux
    and macOS employ a *protected mode* of operation. In this mode, direct access
    to devices is restricted to the OS and certain privileged programs. Standard applications,
    even those written in assembly language, are not so privileged. If you write a
    simple program that attempts to send data to an I/O port, the system will generate
    an illegal access exception and halt your program.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你正在使用一个古老的 Windows 95 或 98 系统，你可以编写汇编代码直接访问 I/O 端口。前面提到的握手代码就是一个很好的例子。然而，现代版本的
    Windows 以及所有版本的 Linux 和 macOS 都采用了*受保护模式*操作。在这种模式下，只有操作系统和某些特权程序可以直接访问设备。标准应用程序，即使是用汇编语言编写的，也没有这种特权。如果你编写一个简单的程序，试图将数据发送到
    I/O 端口，系统会产生一个非法访问异常并停止你的程序。
- en: Linux won’t allow just any program to access I/O ports; only programs with “superuser”
    (root) privileges can do so. For limited I/O access, it’s possible to use the
    Linux `ioperm` system call to make certain I/O ports accessible from user applications.
    (For more details, read the man page on `ioperm`.)
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: Linux 不允许任何程序访问 I/O 端口，只有拥有“超级用户”（root）权限的程序才能这样做。对于有限的 I/O 访问，可以使用 Linux 的
    `ioperm` 系统调用，使某些 I/O 端口对用户应用程序可用。（有关更多详细信息，请阅读 `ioperm` 的 man 页面。）
- en: If Linux, macOS, and Windows don’t allow direct access to peripheral devices,
    how does a program communicate with these devices? Clearly, this *can* be done,
    because applications interact with real-world devices all the time. The answer
    is that these OSes permit specially written modules, known as *device drivers*,
    to access I/O ports. A complete discussion of writing device drivers is well beyond
    the scope of this book, but understanding how they work may help you understand
    the possibilities and limitations of I/O under a protected-mode OS.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 Linux、macOS 和 Windows 不允许直接访问外部设备，那么程序是如何与这些设备进行通信的呢？显然，这是*可以*做到的，因为应用程序一直在与现实世界的设备互动。答案是，这些操作系统允许特别编写的模块，即*设备驱动程序*，来访问
    I/O 端口。编写设备驱动程序的完整讨论远远超出了本书的范围，但了解它们的工作原理有助于你理解在受保护模式操作系统下 I/O 的可能性和局限性。
- en: '***12.10.1 The Device Driver Model***'
  id: totrans-120
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***12.10.1 设备驱动模型***'
- en: A device driver is a special type of program that links with the OS. It must
    follow some specific protocols, and it must make some special calls to the OS
    that are not available to standard applications. Furthermore, in order to install
    a device driver in your system, you must have administrator privileges, because
    device drivers pose all kinds of security and resource allocation risks, and you
    can’t leave your system vulnerable. Therefore, installation is not a trivial process,
    and application programs cannot load and unload drivers at will.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 设备驱动程序是一种特殊类型的程序，它与操作系统相连接。它必须遵循一些特定的协议，并且必须调用操作系统的某些特殊接口，这些接口是标准应用程序无法使用的。此外，为了在系统中安装设备驱动程序，你必须拥有管理员权限，因为设备驱动程序可能带来各种安全性和资源分配风险，你不能让系统变得脆弱。因此，安装过程不是一件简单的事情，应用程序也不能随意加载或卸载驱动程序。
- en: Fortunately, there are only a limited number of devices found on a typical PC,
    so you only need a limited number of device drivers. You would typically install
    a device driver in the OS at the same time you install the device, or, if the
    device is built into the PC, at the same time you install the OS. About the only
    time you’d really need to write your own device driver is when building your own
    device, or in unique cases where you need to take advantage of some device’s capabilities
    that standard device drivers don’t handle.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，典型 PC 上的设备数量是有限的，因此你只需要有限数量的设备驱动程序。你通常会在安装设备的同时在操作系统中安装设备驱动程序，或者如果设备内置于
    PC 中，则在安装操作系统时一并安装。实际上，只有在自己构建设备时，或者在某些特殊情况下，你需要利用某些标准设备驱动程序无法处理的设备功能时，才需要编写自己的设备驱动程序。
- en: The device driver model works well with low-speed devices, where the OS and
    device driver can respond to the device much more quickly than it requires. The
    model is also great for use with medium- and high-speed devices where the system
    transmits large blocks of data to and from the device. However, the device driver
    model does have a few drawbacks, one being that it does not support medium- and
    high-speed data transfers that require substantial interaction between the device
    and the application.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 设备驱动程序模型非常适用于低速设备，在这种情况下，操作系统和设备驱动程序能够比设备所需的速度更快地响应设备。该模型对于中高速设备也非常适用，尤其是在系统需要传输大量数据块到设备与设备之间时。然而，设备驱动程序模型也有一些缺点，其中之一是它不支持需要设备与应用程序之间进行大量交互的中高速数据传输。
- en: The problem is that calling the OS is an expensive process. Whenever an application
    makes a call to the OS to transmit data to the device, it can potentially take
    hundreds of microseconds, if not milliseconds, before the device driver actually
    sees the application’s data. If the interaction between the device and the application
    requires a constant flurry of bytes moving back and forth, there will be a big
    delay if each transfer has to go through the OS. For applications of this sort,
    you’ll need to write a special device driver that can handle the transactions
    itself rather than continually returning to the application.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 问题在于，调用操作系统是一个昂贵的过程。每当应用程序调用操作系统将数据传输到设备时，可能需要几百微秒，甚至几毫秒，设备驱动程序才能实际看到应用程序的数据。如果设备与应用程序之间的交互需要持续不断的数据传输，那么如果每次传输都必须通过操作系统，就会产生很大的延迟。对于这类应用程序，你需要编写一个特殊的设备驱动程序，能够自行处理交易，而不是不断地返回给应用程序。
- en: Because applications can’t access devices directly (in modern OSes), all communication
    between them must take place through a device driver intermediary. The question,
    then, is how do applications communicate with device drivers?
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 因为应用程序不能直接访问设备（在现代操作系统中），它们之间的所有通信必须通过设备驱动程序作为中介进行。那么，问题是，应用程序如何与设备驱动程序进行通信？
- en: '***12.10.2 Communication with Device Drivers***'
  id: totrans-126
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***12.10.2 与设备驱动程序的通信***'
- en: For the most part, communicating with a peripheral device under a modern OS
    is exactly like writing data to a file or reading data from a file. In most OSes,
    you open a “file” using a special filename like *COM1* (the serial port) or *LPT1*
    (the parallel port) and the OS automatically creates a connection to the specified
    device. When you are finished using the device, you “close” the associated file,
    which tells the OS that the application is done with the device so other applications
    can use it.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 在大多数情况下，现代操作系统下与外部设备的通信就像向文件写入数据或从文件读取数据一样。在大多数操作系统中，你通过使用特殊的文件名如*COM1*（串行端口）或*LPT1*（并行端口）来打开一个“文件”，操作系统会自动与指定的设备建立连接。当你使用完设备时，你需要“关闭”关联的文件，这告诉操作系统应用程序已经完成对该设备的使用，其他应用程序可以使用该设备。
- en: Of course, most devices don’t support the same semantics as disk files. Some
    devices, like printers or modems, can accept a long stream of unformatted data,
    but others may require that you preformat the data into blocks and write the blocks
    to the device with a single write operation. The exact semantics depend upon the
    particular device. Nevertheless, the typical way to send data to a peripheral
    is to use an OS “write” function to which you pass a buffer containing some data,
    and the way to read data from a device is to call an OS “read” function to which
    you pass the address of some buffer into which the OS will place the data it reads.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，大多数设备并不支持与磁盘文件相同的语义。有些设备，如打印机或调制解调器，可以接受一长串未格式化的数据流，但其他设备可能需要你将数据预先格式化为块，并通过单次写操作将这些块写入设备。具体的语义取决于特定的设备。不过，向外部设备发送数据的典型方法是使用操作系统的“写”函数，向该函数传递一个包含一些数据的缓冲区，而从设备读取数据的方法是调用操作系统的“读”函数，向该函数传递一个缓冲区的地址，操作系统将数据写入该缓冲区。
- en: But not all devices conform to these *stream-I/O* data semantics of file I/O,
    either. Therefore, most OSes provide a *device-control API* that lets you pass
    information directly to the peripheral’s device driver to handle the cases where
    a stream-I/O model fails.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 但是并非所有设备都符合这些*流式 I/O*文件 I/O的数据语义。因此，大多数操作系统提供了一个*设备控制 API*，允许你将信息直接传递给外部设备的设备驱动程序，以处理流式
    I/O模型失败的情况。
- en: Because it varies by OS, the exact details concerning the OS API interface are
    a bit beyond the scope of this book. Though most OSes use a similar scheme, they
    differ enough to make it impossible to describe them in a general way. So, for
    further details, consult the programmer’s reference for your particular OS.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 由于各个操作系统不同，关于操作系统API接口的具体细节超出了本书的范围。尽管大多数操作系统使用类似的方案，但它们的差异足以使得无法用一般方式描述它们。因此，欲了解更多详情，请参考你特定操作系统的程序员参考手册。
- en: '**12.11 For More Information**'
  id: totrans-131
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**12.11 更多信息**'
- en: 'Silberschatz, Abraham, Peter Baer Galvin, and Greg Gagne. “[Chapter 13](ch13.xhtml#ch13):
    I/O Systems.” In *Operating System Concepts*. 8th ed. Hoboken, NJ: John Wiley
    & Sons, 2009.'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 'Silberschatz, Abraham, Peter Baer Galvin, 和 Greg Gagne. “[第13章](ch13.xhtml#ch13):
    输入/输出系统.” 载于 *操作系统概念*. 第8版. 霍博肯, NJ: 约翰·威利与儿子出版社, 2009年。'
- en: '**NOTE**'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*Early editions of Patterson and Hennessy’s* Computer Architecture: A Quantitative
    Approach *provided a good chapter on I/O devices and buses; sadly, as it covered
    very old peripheral devices, the authors dropped the chapter rather than updating
    it in subsequent revisions. Internet searches seem to be the last place you can
    find consistent information on this subject (outside of this book, of course).*'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: '*Patterson和Hennessy的早期版本*《计算机架构：定量方法*提供了关于I/O设备和总线的良好章节；可惜的是，由于它涵盖了非常旧的外围设备，作者决定删除该章节，而不是在后续版本中更新它。互联网搜索似乎是你能找到关于这个主题一致信息的最后地方（当然，除了这本书）。*'
