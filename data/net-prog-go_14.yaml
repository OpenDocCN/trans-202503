- en: '11'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '11'
- en: Securing Communications with TLS
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 TLS 保护通信
- en: '![](image_fi/book_art/chapterart.png)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![](image_fi/book_art/chapterart.png)'
- en: Five years before whistleblower Edward Snowden showed us how much we took our
    electronic privacy for granted, author and activist Cory Doctorow wrote, “We should
    treat personal electronic data with the same care and respect as weapons-grade
    plutonium—it is dangerous, long-lasting, and once it has leaked, there’s no getting
    it back.”
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在五年前，揭露者爱德华·斯诺登向我们展示了我们是多么地理所当然地认为电子隐私是理所应当的，作家兼活动家科里·多克特罗就曾写道：“我们应该像对待武器级铀一样对待个人电子数据——它是危险的、持久的，一旦泄露，就无法找回。”
- en: Prior to 2013, most people communicated on the internet by using plaintext.
    Social Security numbers, credit card details, passwords, sensitive emails, and
    other potentially embarrassing information traveled over the internet, ripe for
    interception by malicious actors. Most popular websites defaulted to HTTP; Google
    was one of the only major tech companies supporting HTTPS.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在 2013 年之前，大多数人通过使用明文在互联网上进行通信。社会安全号码、信用卡信息、密码、敏感电子邮件和其他可能令人尴尬的信息在互联网上传播，容易被恶意行为者拦截。大多数流行的网站默认使用
    HTTP；谷歌是为数不多的支持 HTTPS 的大型科技公司之一。
- en: Today, it’s unusual to find a website that doesn’t support HTTPS, particularly
    now that Let’s Encrypt offers free TLS certificates for your domain. We’re treating
    information in transit more like weapons-grade plutonium, helping ensure the privacy
    and integrity of the information we share. Our network applications should be
    no different. We should strive to authenticate our communication and use encryption
    where appropriate, particularly when that information has the potential to leak
    over insecure networks.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 今天，找一个不支持 HTTPS 的网站已经变得不寻常，尤其是现在 Let’s Encrypt 提供免费的 TLS 证书给你的域名。我们对传输中的信息的处理就像处理武器级铀一样，帮助确保我们共享信息的隐私性和完整性。我们的网络应用程序也应该如此。我们应该努力认证我们的通信，并在适当的时候使用加密，特别是当信息有可能通过不安全的网络泄露时。
- en: Up to this point, we’ve used TLS only as an afterthought in our code. This is
    partly because Go’s `net/http` library makes its use relatively effortless, but
    it’s also because we haven’t adequately explored the TLS protocol and the infrastructure
    that makes it possible. To write secure software, you should carefully plan for
    security before development starts and then use good security practices as you
    write code. TLS is a terrific way to improve the security posture of your software
    by protecting data in transit.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们只是在代码中将 TLS 当作事后的补充来使用。这部分是因为 Go 的 `net/http` 库使得它的使用相对轻松，但也因为我们没有充分探索
    TLS 协议以及使它成为可能的基础设施。要编写安全的软件，你应该在开发开始之前仔细规划安全性，然后在编写代码时使用良好的安全实践。TLS 是提高软件安全性的绝佳方式，它通过保护传输中的数据来改善软件的安全态势。
- en: This chapter will introduce you to the basics of TLS from a programmer’s perspective.
    You’ll learn about the client-server handshake process and the inherent trust
    that makes that process work. Then we’ll discuss how things can (and do) go wrong
    even when you use TLS. Finally, we’ll look at practical examples of how to incorporate
    TLS into your applications, including mutual client-server authentication.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将从程序员的角度介绍 TLS 的基础知识。你将了解客户端和服务器之间的握手过程，以及使这一过程得以实现的固有信任。然后我们将讨论即使你使用了 TLS，事情如何（以及如何）出错。最后，我们将看一些实际的例子，了解如何将
    TLS 集成到你的应用程序中，包括客户端和服务器的相互认证。
- en: A Closer Look at Transport Layer Security
  id: totrans-8
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 深入了解传输层安全性
- en: The TLS protocol supplies secure communication between a client and a server.
    It allows the client to authenticate the server and optionally permits the server
    to authenticate clients. The client uses TLS to encrypt its communication with
    the server, preventing third-party interception and manipulation.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: TLS 协议为客户端和服务器之间提供安全通信。它允许客户端认证服务器，并可选择性地允许服务器认证客户端。客户端使用 TLS 来加密与服务器的通信，防止第三方拦截和篡改。
- en: 'TLS uses a handshake process to establish certain criteria for the stateful
    TLS session. If the client initiated a TLS 1.3 handshake with the server, it would
    go something like this:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: TLS 使用握手过程来建立 TLS 会话的某些标准。如果客户端发起了 TLS 1.3 与服务器的握手，它将大致如下：
- en: Client Hello *google.com*. I’d like to communicate with you using TLS version
    1.3\. Here is a list of ciphers I’d like to use to encrypt our messages, in order
    of my preference. I generated a public- and private-key pair specifically for
    this conversation. Here’s my public key.
  id: totrans-11
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 客户端Hello *google.com*。我希望使用TLS版本1.3与你进行通信。以下是我希望用来加密我们消息的密码套件列表，按我的偏好顺序排列。我专门为这次会话生成了一对公钥和私钥。这是我的公钥。
- en: Server Greetings, client. TLS version 1.3 suits me fine. Based on your cipher
    list, I’ve decided we’ll use the Advanced Encryption Standard with Galois/Counter
    Mode (AES-GCM) cipher. I, too, created a new key pair for this conversation. Here
    is my public key and my certificate so you can prove that I truly am *google.com*.
    I’m also sending along a 32-byte value that corresponds to the TLS version you
    asked me to use. Finally, I’m including both a signature and a *message authentication
    code* *(MAC)* derived using your public key of everything we’ve discussed so far
    so you can verify the integrity of my reply when you receive it.
  id: totrans-12
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 服务器问候，客户端。TLS 1.3版本非常适合我。根据你的密码套件列表，我决定使用**高级加密标准与Galois/计数器模式（AES-GCM）**密码套件。我也为这次会话创建了新的密钥对。这里是我的公钥和证书，你可以证明我确实是*google.com*。我还发送了一个32字节的值，它对应于你要求我使用的TLS版本。最后，我还包括了一个签名和一个*消息认证码*（*MAC*），这是通过使用你的公钥对我们迄今讨论的所有内容进行衍生的，这样你就可以在收到我的回复时验证其完整性。
- en: Client (to self) An authority I trust signed the server’s certificate, so I’m
    confident I’m speaking to *google.com*. I’ve derived this conversation’s symmetric
    key from the server’s signature by using my private key. Using this symmetric
    key, I’ve verified the MAC and made sure no one has tampered with the server’s
    reply. The 32 bytes in the reply corresponds to TLS version 1.3, so no one is
    attempting to trick the server into using an older, weaker version of TLS. I now
    have everything I need to securely communicate with the server.
  id: totrans-13
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 客户端（自言自语）一个我信任的认证机构签署了服务器的证书，所以我确信我正在与*google.com*通信。我通过使用我的私钥从服务器的签名中衍生出了这次会话的对称密钥。使用这个对称密钥，我验证了MAC，并确保没有人篡改服务器的回复。回复中的32个字节对应于TLS版本1.3，因此没有人试图欺骗服务器使用更旧、更弱的TLS版本。我现在拥有了一切所需的东西，可以与服务器进行安全通信。
- en: Client (to server) *Here is some encrypted data.*
  id: totrans-14
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 客户端（发送给服务器）*这是一些加密数据。*
- en: The 32-byte value in the server’s hello message prevents *downgrade attacks*,
    in which an attacker intercepts the client’s hello message and modifies it to
    request an older, weaker version of TLS. If the client asked for TLS v1.3, but
    an attacker changed the client’s hello message to ask for TLS v1.1, the 32-byte
    value in the server’s hello message would correspond to TLS v1.1\. When the client
    received the server’s hello message, it would notice that the value indicated
    the wrong TLS version and abort the handshake.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 服务器的Hello消息中的32字节值防止了*降级攻击*，即攻击者拦截客户端的Hello消息并修改它，要求使用更旧、更弱的TLS版本。如果客户端请求的是TLS
    v1.3，但攻击者将客户端的Hello消息改为请求TLS v1.1，那么服务器的Hello消息中的32字节值将对应于TLS v1.1。当客户端接收到服务器的Hello消息时，它会注意到该值指示了错误的TLS版本，从而中止握手。
- en: From this point forward, the client and server communicate using AES-GCM symmetric-key
    cryptography (in this hypothetical example). Both the client and the server encapsulate
    application layer payloads in TLS records before passing the payloads onto the
    transport layer.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 从现在开始，客户端和服务器使用AES-GCM对称密钥加密（在这个假设的例子中）。客户端和服务器都会在传输层之前将应用层负载封装到TLS记录中，然后将负载传递给传输层。
- en: Despite its name, TLS is not a transport layer protocol. Instead, it’s situated
    between the transport and application layers of the TCP/IP stack. TLS encrypts
    an application layer protocol’s payload before passing the payload onto the transport
    layer. Once the payload reaches its destination, TLS receives the payload from
    the transport layer, decrypts it, and passes the payload along to the application
    layer protocol.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管名称中带有“传输”，TLS并不是一个传输层协议。相反，它位于TCP/IP协议栈的传输层和应用层之间。TLS在将应用层协议的负载传递到传输层之前会先对负载进行加密。一旦负载到达目的地，TLS会从传输层接收负载，对其解密，并将负载传递给应用层协议。
- en: Forward Secrecy
  id: totrans-18
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 前向保密
- en: The handshake method in our hypothetical conversation is an example of the Diffie-Hellman
    (DH) key exchange used in TLS v1.3\. The *DH key exchange* calls for the creation
    of new client and server key pairs, and a new symmetric key, all of which should
    exist for only the duration of the session. Once a session ends, the client and
    server shall discard the session keys.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 我们假设对话中的握手方法是 TLS v1.3 中使用的 Diffie-Hellman (DH) 密钥交换的一个例子。*DH 密钥交换*要求生成新的客户端和服务器密钥对，以及一个新的对称密钥，所有这些密钥仅在会话期间有效。一旦会话结束，客户端和服务器将丢弃会话密钥。
- en: The use of per-session keys means that TLS v1.3 gives you *forward secrecy*;
    an attacker who compromises your session keys can compromise only the data exchanged
    during that session. An attacker cannot use those keys to decrypt data exchanged
    during any other session.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 使用每会话密钥意味着 TLS v1.3 提供了 *前向保密*；如果攻击者破解了你的会话密钥，他们只能破解该会话期间交换的数据。攻击者无法使用这些密钥解密其他会话期间交换的数据。
- en: In Certificate Authorities We Trust
  id: totrans-21
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 我们信任证书颁发机构
- en: My father and I took a trip to Ireland shortly before I started authoring this
    book. In preparation for our adventure, I needed to obtain a new passport, since
    my old one had long since expired. The process was easy. I filled out an application,
    collected my vital records, took a picture of the bad side of my head, and presented
    everything, along with an application fee, to my local US Post Office branch.
    I also attested I was myself to the notary. A few weeks later, I received a newly
    minted US passport in the mail.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 我的父亲和我在我开始写这本书之前不久去了一趟爱尔兰。为了准备这次旅行，我需要办理一本新护照，因为我的旧护照早就过期了。这个过程很简单。我填写了申请表，收集了重要的个人记录，拍了一张丑陋的照片，并把这些材料以及申请费交给了当地的美国邮政局分局。我还向公证人证明了我就是我自己。几周后，我收到了新办理的美国护照。
- en: When we arrived in Ireland, a lovely customs agent greeted us and requested
    our passports. She asked questions about our holiday as her computer authenticated
    our identities. After no more than three minutes, she returned our passports and
    welcomed us to Ireland.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们到达爱尔兰时，一位可爱的海关官员迎接了我们，并要求出示护照。她在电脑验证我们的身份的同时，询问了关于我们假期的一些问题。不到三分钟，她就把护照还给我们，欢迎我们来到爱尔兰。
- en: My passport represents the US government’s attestation that I am Adam Woodbeck.
    But it’s only as good as Ireland’s trust in the US government’s ability to verify
    my identity. If Ireland doesn’t trust the United States, it will not take the
    United States’ word that I am me and will most likely refuse to let me enter the
    country. (If I’m being honest, I’m not charming enough to convince the customs
    agent to let me in on my word alone.)
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 我的护照代表了美国政府对我身份的认证，证明我是**亚当·伍德贝克**。但它的有效性仅取决于爱尔兰对美国政府验证我身份能力的信任。如果爱尔兰不信任美国，它将不会相信美国说我就是我，并很可能拒绝让我进入该国。（说实话，我并没有足够的魅力让海关人员仅凭我自己的话就放行我。）
- en: TLS’s certificates work in much the same way as my passport. If I wanted a new
    TLS certificate for *woodbeck.net*, I would send a request to a certificate authority,
    such as Let’s Encrypt. The certificate authority would then verify I am the proper
    owner of *woodbeck.net*. Once satisfied, the certificate authority would issue
    a new certificate for *woodbeck.net* and cryptographically sign it with its certificate.
    My server can present this certificate to clients so they can authenticate my
    server by confirming the certificate authority’s signature, giving them the confidence
    that they’re communicating with the real *woodbeck.net*, not an impostor.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: TLS 的证书工作原理与我的护照非常相似。如果我需要为 *woodbeck.net* 获取一个新的 TLS 证书，我会向证书颁发机构（如 Let’s Encrypt）提出请求。证书颁发机构会验证我是否是
    *woodbeck.net* 的合法拥有者。一旦确认无误，证书颁发机构会为 *woodbeck.net* 签发新的证书，并使用其证书进行加密签名。我的服务器可以向客户端展示这个证书，客户端通过验证证书颁发机构的签名来认证我的服务器，从而确认他们与真正的
    *woodbeck.net* 通信，而不是与冒名顶替者通信。
- en: A certificate authority issuing a signed certificate for *woodbeck.net* is analogous
    to the US government issuing my passport. They are both issued by trusted institutions
    that attest to their subject’s authenticity. Like Ireland’s trust of the United
    States, clients are inclined to trust the *woodbeck.net* certificate only if they
    trust the certificate authority that signed it. I could create my own certificate
    authority and self-sign certificates as easy as I could create a document claiming
    to be my passport. But Ireland would sooner admit that Jack Daniel’s Tennessee
    Whiskey is superior to Jameson Irish Whiskey than trust my self-issued passport,
    and no operating system or web browser in the world would trust my self-signed
    certificate.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 证书颁发机构为*woodbeck.net*签发签名证书类似于美国政府为我签发护照。它们都是由受信任的机构签发，证明其主体的真实性。就像爱尔兰对美国的信任一样，客户端只有在信任签发证书的证书颁发机构时，才会信任*woodbeck.net*证书。我可以像创建一个宣称是我护照的文件一样，创建自己的证书颁发机构并自签证书。但爱尔兰宁可承认Jack
    Daniel’s田纳西威士忌优于Jameson爱尔兰威士忌，也不可能信任我自签发的护照，世界上没有任何操作系统或网页浏览器会信任我自签的证书。
- en: How to Compromise TLS
  id: totrans-27
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 如何妥协TLS
- en: On December 24, 2013, Google learned that the Turktrust certificate authority
    in Turkey had mistakenly issued a certificate that allowed a malicious actor to
    masquerade as *google.com*. This meant that attackers could fool your web browser
    into thinking it was talking to Google over a TLS connection and trick you into
    divulging your credentials. Google quickly noticed the mistake and took steps
    to remedy the situation.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 2013年12月24日，谷歌发现土耳其的Turktrust证书颁发机构错误地签发了一个证书，使恶意行为者能够伪装成*google.com*。这意味着攻击者可以欺骗你的网页浏览器，使其认为自己与谷歌通过TLS连接进行通信，并诱使你泄露凭证。谷歌迅速注意到这一错误，并采取了补救措施。
- en: Turktrust’s mess-up undermined its authority and compromised our trust. But
    even if the certificate authorities operate correctly, attackers can narrow their
    focus and target individuals instead. If an attacker were able to install his
    own CA certificate in your operating system’s trusted certificate storage, your
    computer would trust any certificate he signs. This means an attacker could compromise
    all your TLS traffic.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: Turktrust的失误削弱了它的权威并破坏了我们的信任。但即使证书颁发机构运作正常，攻击者也可以将目标转向个人。如果攻击者能够在你的操作系统受信任的证书存储中安装自己的CA证书，你的计算机会信任他签发的任何证书。这意味着攻击者可以妥协你所有的TLS流量。
- en: Most people don’t get this kind of special attention. Instead, an attacker is
    more likely to compromise a server. Once compromised, the attacker could capture
    all TLS traffic and the corresponding session keys from memory.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数人不会得到这种特别的关注。相反，攻击者更可能妥协服务器。一旦服务器被攻破，攻击者就能捕获所有TLS流量及其对应的会话密钥。
- en: You’re unlikely to encounter any of these scenarios, but it’s important to be
    aware that they are possible. Overall, TLS 1.3 offers excellent security and is
    tough to compromise because of its full handshake signature, downgrade protection,
    forward secrecy, and strong encryption.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 你不太可能遇到这些场景，但了解它们是可能发生的非常重要。总体而言，TLS 1.3提供了极好的安全性，并且很难被妥协，因为它有完整的握手签名、降级保护、前向保密性和强加密。
- en: Protecting Data in Transit
  id: totrans-32
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 保护传输中的数据
- en: Ensuring the integrity of the data you transmit over a network should be your
    primary focus, no matter whether it’s your own data or the data of others. Go
    makes using TLS so easy that you would have a tough time justifying not using
    it. In this section, you’ll learn how to add TLS support to both the client and
    the server. You’ll also see how TLS works over TCP and how to mitigate the threat
    of malicious certificates with certificate pinning.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 无论是你自己的数据还是他人的数据，确保你在网络上传输的数据的完整性应该是你的主要关注点。Go使得使用TLS变得如此简单，以至于你几乎无法为不使用它辩解。在本节中，你将学习如何为客户端和服务器添加TLS支持。你还将看到TLS如何在TCP上工作，以及如何通过证书固定技术来减轻恶意证书的威胁。
- en: Client-side TLS
  id: totrans-34
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 客户端TLS
- en: The client’s primary concern during the handshake process is to authenticate
    the server by using its certificate. If the client cannot trust the server, it
    cannot consider its communication with the server secure. The `net/http/httptest`
    package provides constructs that easily demonstrate Go’s HTTP-over-TLS support
    (see [Listing 11-1](#listing11-1)).
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 客户端在握手过程中的主要关注点是通过使用证书验证服务器。如果客户端无法信任服务器，就无法认为与服务器的通信是安全的。`net/http/httptest`包提供了方便的构造，能够轻松演示Go的HTTP-over-TLS支持（参见[Listing
    11-1](#listing11-1)）。
- en: '[PRE0]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Listing 11-1: Testing HTTPS client and server support (*tls_client_test.go*)'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 清单 11-1：测试 HTTPS 客户端和服务器支持 (*tls_client_test.go*)
- en: The `httptest.NewTLSServer` function returns an HTTPS server 1. Aside from the
    function name, this bit of code looks identical to our use of `httptest` in Chapter
    8. Here, the `httptest.NewTLSServer` function handles the HTTPS server’s TLS configuration
    details, including the creation of a new certificate. No trusted authority signed
    this certificate, so no discerning HTTPS client would trust it. You’ll see how
    to work around this detail in just a moment by using a preconfigured client.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: '`httptest.NewTLSServer`函数返回一个 HTTPS 服务器 1。除了函数名之外，这段代码看起来与我们在第 8 章中使用的`httptest`完全相同。在这里，`httptest.NewTLSServer`函数处理了
    HTTPS 服务器的 TLS 配置细节，包括创建一个新的证书。此证书没有受到任何受信任机构的签名，因此没有辨别能力的 HTTPS 客户端会信任它。你将很快看到如何通过使用预配置的客户端来绕过这个细节。'
- en: If the server receives the client’s request over HTTP, the request’s `TLS` field
    will be `nil`. You can check for this case 2 and redirect the client to the HTTPS
    endpoint accordingly.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 如果服务器通过 HTTP 接收到客户端的请求，则请求的`TLS`字段将为`nil`。你可以检查这种情况 2，并相应地将客户端重定向到 HTTPS 端点。
- en: For testing purposes, the server’s `Client` method 3 returns a new `*http.Client`
    that inherently trusts the server’s certificate. You can use this client to test
    TLS-specific code within your handlers.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 出于测试目的，服务器的`Client`方法 3 返回一个新的`*http.Client`，该客户端固有信任服务器的证书。你可以使用此客户端测试处理程序中的
    TLS 特定代码。
- en: Let’s see what happens in [Listing 11-2](#listing11-2) when you attempt to communicate
    with the same server by using a new client without inherent trust for the server’s
    certificate.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看在[清单 11-2](#listing11-2)中，当你尝试使用一个新的客户端与相同的服务器进行通信时，且该客户端没有固有信任服务器证书时会发生什么。
- en: '[PRE1]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Listing 11-2: Testing the HTTPS server with a discerning client (*tls_client_test.go*)'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 清单 11-2：使用有辨别能力的客户端测试 HTTPS 服务器 (*tls_client_test.go*)
- en: You override the default TLS configuration in your client’s transport by creating
    a new transport, defining its TLS configuration, and configuring `http2` to use
    this transport. It’s good practice to restrict your client’s curve preference
    to the P-256 curve 1 and avoid the use of P-384 and P-521\. P-256 is immune to
    timing attacks, whereas P-384 and P-521 are not. Also, your client will negotiate
    a minimum of TLS 1.2\.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 你通过创建一个新的传输，定义其 TLS 配置，并配置`http2`使用该传输，来覆盖客户端传输中的默认 TLS 配置。好的做法是将客户端的曲线首选项限制为
    P-256 曲线 1，并避免使用 P-384 和 P-521。P-256 对时间攻击具有免疫性，而 P-384 和 P-521 则没有。此外，客户端将协商最低
    TLS 1.2\。
- en: An *elliptic curve* is a plane curve in which all points along the curve satisfy
    the same polynomial equation. Whereas first-generation cryptography like RSA uses
    large prime numbers to derive keys, elliptic curve cryptography uses points along
    an elliptic curve for key generation. P-256, P-384, and P-521 are specific elliptic
    curves defined in the National Institute of Standards and Technology’s Digital
    Signature Standard. You can find more details in the Federal Information Processing
    Standards (FIPS) publication 186-4 ([https://nvlpubs.nist.gov/nistpubs/FIPS/NIST.FIPS.186-4.pdf](https://nvlpubs.nist.gov/nistpubs/FIPS/NIST.FIPS.186-4.pdf)).
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: '*椭圆曲线*是一种平面曲线，曲线上的所有点都满足相同的多项式方程。与使用大素数来生成密钥的第一代加密技术（如 RSA）不同，椭圆曲线加密使用椭圆曲线上的点来生成密钥。P-256、P-384
    和 P-521 是在美国国家标准与技术研究院（NIST）数字签名标准中定义的特定椭圆曲线。你可以在《联邦信息处理标准》（FIPS）出版物 186-4 中找到更多细节（[https://nvlpubs.nist.gov/nistpubs/FIPS/NIST.FIPS.186-4.pdf](https://nvlpubs.nist.gov/nistpubs/FIPS/NIST.FIPS.186-4.pdf)）。'
- en: Since your transport no longer relies on the default TLS configuration, the
    client no longer has inherent HTTP/2 support. You need to explicitly bless your
    transport with HTTP/2 support 2 if you want to use it. Of course, this test doesn’t
    rely on HTTP/2, but this implementation detail can trip you up if you’re unaware
    that overriding the transport’s TLS configuration removes HTTP/2 support.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 由于你的传输不再依赖于默认的 TLS 配置，客户端不再具备固有的 HTTP/2 支持。如果你想使用 HTTP/2，你需要显式地为你的传输添加 HTTP/2
    支持 2。当然，这个测试并不依赖于 HTTP/2，但如果你没有意识到覆盖传输的 TLS 配置会移除 HTTP/2 支持，那么这个实现细节可能会让你陷入困境。
- en: Your client uses the operating system’s trusted certificate store because you
    don’t explicitly tell it which certificates to trust. The first call to the test
    server results in an error because your client doesn’t trust the server certificate’s
    signatory. You could work around this and configure your client’s transport to
    skip verification of the server’s certificate by setting its `InsecureSkipVerify`
    field to `true`3. I don’t recommend you entertain enabling `InsecureSkipVerify`
    for anything other than debugging. Shipping code with this enabled is a code smell
    in my opinion. You’ll learn a better alternative later in this chapter when we
    discuss a concept known as *certificate pinning*. As the field name implies, enabling
    it makes your client inherently insecure and susceptible to man-in-the-middle
    attacks, since it now blindly trusts any certificate a server offers up. If you
    make the same call with your newly naive client, you’ll see that it happily negotiates
    TLS with the server.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 你的客户端使用操作系统的受信证书存储，因为你没有明确告诉它信任哪些证书。第一次调用测试服务器时会出现错误，因为你的客户端不信任服务器证书的签发者。你可以绕过这个问题，通过将
    `InsecureSkipVerify` 字段设置为 `true`3 来配置客户端的传输跳过验证服务器的证书。我不建议你在除调试之外的任何情况下启用 `InsecureSkipVerify`。我认为启用该选项并发布代码是一个代码气味。你将在本章稍后学习更好的替代方案，当我们讨论
    *证书钉扎* 概念时。正如字段名所示，启用此选项会使你的客户端本质上不安全，容易受到中间人攻击，因为它现在会盲目信任服务器提供的任何证书。如果你使用新配置的天真客户端进行相同的调用，你会发现它会愉快地与服务器协商
    TLS。
- en: TLS over TCP
  id: totrans-48
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: TCP 上的 TLS
- en: TLS is stateful; a client and a server negotiate session parameters during the
    initial handshake only, and once they’ve agreed, they exchange encrypted TLS records
    for the duration of the session. Since TCP is also stateful, it’s the ideal transport
    layer protocol with which to implement TLS, because you can leverage TCP’s reliability
    guarantees to maintain your TLS sessions.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: TLS 是有状态的；客户端和服务器在初始握手时协商会话参数，一旦达成一致，它们就会在会话期间交换加密的 TLS 记录。由于 TCP 本身也是有状态的，它是实现
    TLS 的理想传输层协议，因为你可以利用 TCP 的可靠性保证来维持你的 TLS 会话。
- en: Let’s take the application protocol out of the picture for a moment and learn
    how to establish a TLS connection over TCP. [Listing 11-3](#listing11-3) demonstrates
    how to use the `crypto/tls` package to initiate a TLS connection with a few lines
    of code.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们暂时不考虑应用协议，学习如何通过 TCP 建立 TLS 连接。[清单 11-3](#listing11-3) 展示了如何使用 `crypto/tls`
    包，通过几行代码发起 TLS 连接。
- en: '[PRE2]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Listing 11-3: Starting a TLS connection with *www.google.com* (*tls_client_test.go*)'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 清单 11-3：启动与 *www.google.com* 的 TLS 连接（*tls_client_test.go*）
- en: The `tls.DialWithDialer` function 1 accepts a `*net.Dialer`, a network, an address,
    and a `*tls.Config`. Here, you give your dialer a time-out of 30 seconds and specify
    recommended TLS settings. If successful, you can inspect the connection’s state
    2 to glean details about your TLS connection.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: '`tls.DialWithDialer` 函数 1 接受一个 `*net.Dialer`、网络类型、地址和一个 `*tls.Config`。在这里，你为拨号器设置了
    30 秒的超时，并指定了推荐的 TLS 设置。如果成功，你可以检查连接的状态 2，以获取关于 TLS 连接的详细信息。'
- en: '[Listing 11-4](#listing11-4) shows the output of [Listing 11-3](#listing11-3)’s
    test.'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: '[清单 11-4](#listing11-4) 显示了 [清单 11-3](#listing11-3) 测试的输出。'
- en: '[PRE3]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Listing 11-4: Running the `TestClientTLSGoogle` test'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 清单 11-4：运行 `TestClientTLSGoogle` 测试
- en: Your TLS client is using the TLS_AES_128_GCM_SHA256 cipher suite over TLS version
    1.3\. Notice that `tls.DialWithDialer` did not object to the server’s certificate.
    The underlying TLS client used the operating system’s trusted certificate storage
    and confirmed that *www.google.com*’s certificate is signed by a trusted CA—Google
    Trust Services, in this example.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 你的 TLS 客户端使用的是 TLS_AES_128_GCM_SHA256 密码套件，基于 TLS 1.3 版本。注意，`tls.DialWithDialer`
    并没有对服务器的证书提出异议。底层 TLS 客户端使用操作系统的受信证书存储，并确认 *www.google.com* 的证书由受信的证书颁发机构签发——在本例中是
    Google Trust Services。
- en: Server-side TLS
  id: totrans-58
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 服务器端 TLS
- en: 'The server-side code isn’t much different from what you’ve learned thus far.
    The main difference is that the server needs to present a certificate to the client
    as part of the handshake process. You can create one with the *generate_cert.go*
    file found in Go’s *src/crypto/tls* subdirectory. For production use, you’re better
    off using certificates from Let’s Encrypt or another certificate authority. You
    can use the LEGO library ([https://github.com/go-acme/lego/](https://github.com/go-acme/lego/))
    to add certificate management to your services. Generate a new cert and private
    key, like so:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 服务器端的代码与之前学习的差别不大。主要的不同之处在于，服务器需要在握手过程中向客户端提供证书。你可以使用 Go 的 *src/crypto/tls*
    子目录中的 *generate_cert.go* 文件来创建证书。对于生产环境，最好使用 Let’s Encrypt 或其他证书颁发机构的证书。你可以使用
    LEGO 库（[https://github.com/go-acme/lego/](https://github.com/go-acme/lego/)）将证书管理功能添加到你的服务中。生成一个新的证书和私钥，像这样：
- en: '[PRE4]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: This command creates a certificate named *cert.pem* with the hostname *localhost*
    and a private key named *key.pem*. The rest of the code in this section assumes
    that both files exist in the current directory.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 该命令会创建一个名为 *cert.pem* 的证书，主机名为 *localhost*，并创建一个名为 *key.pem* 的私钥。接下来的代码假设这两个文件已经存在于当前目录中。
- en: Keeping with the tradition of earlier chapters, [Listing 11-5](#listing11-5)
    includes the first bit of code for a TLS-only echo server.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 延续前几章的传统，[列表 11-5](#listing11-5) 包含了一个仅支持 TLS 的回显服务器的第一个代码片段。
- en: '[PRE5]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Listing 11-5: Server struct type and constructor function (*tls_echo.go*)'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 11-5：服务器结构体类型和构造函数（*tls_echo.go*）
- en: The `Server` struct has a few fields used to record its settings, its TLS configuration,
    and a channel to signal when the server is ready for incoming connections. You’ll
    write a test case and use the `Ready` method 1 a little later in this section
    to block until the server is ready to accept connections.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: '`Server` 结构体有一些字段，用于记录服务器的设置、TLS 配置和一个信号通道，用于指示服务器何时准备好接受传入的连接。稍后你会写一个测试用例，并使用
    `Ready` 方法 1 来阻塞，直到服务器准备好接受连接。'
- en: The `NewTLSServer` function accepts a context for stopping the server, an address,
    the maximum duration the server should allow connections to idle, and a TLS configuration.
    Although controlling for idling clients isn’t related to TLS, you’ll use the maximum
    idle duration to push the socket deadline forward, as in Chapter 3.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: '`NewTLSServer` 函数接受一个用于停止服务器的上下文、一个地址、服务器允许连接空闲的最长时间以及 TLS 配置。尽管控制空闲客户端与 TLS
    无关，但你将使用最大空闲时间来推进套接字的截止时间，就像在第 3 章中一样。'
- en: Servers you used in earlier chapters rely on the separate concepts of listening
    and serving. Often, you’ll invoke a helper function that will do both for you,
    such as the `net/http` server’s `ListenAndServe` method. [Listing 11-6](#listing11-6)
    adds a similar method to the echo server.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 你在前几章使用的服务器依赖于监听和服务这两个独立的概念。通常，你会调用一个辅助函数来同时执行这两个操作，比如 `net/http` 服务器的 `ListenAndServe`
    方法。[列表 11-6](#listing11-6) 向回显服务器添加了一个类似的方法。
- en: '[PRE6]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Listing 11-6: Adding methods to listen and serve and signal the server’s readiness
    for connections (*tls_echo.go*)'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 11-6：为监听和服务方法添加信号，指示服务器已准备好接收连接（*tls_echo.go*）
- en: The `ListenAndServe` method accepts full paths to a certificate and a private
    key and returns an error. It creates a new `net.Listener` bound to the server’s
    address and then spins off a goroutine to close the listener when you cancel the
    context. Finally, the method passes the listener, the certificate path, and the
    key path onto the server’s `ServeTLS` method.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: '`ListenAndServe` 方法接受证书和私钥的完整路径，并返回错误。它创建一个绑定到服务器地址的 `net.Listener`，然后启动一个
    goroutine，在你取消上下文时关闭监听器。最后，方法将监听器、证书路径和密钥路径传递给服务器的 `ServeTLS` 方法。'
- en: '[Listing 11-7](#listing11-7) rounds out the echo server’s implementation with
    its `ServeTLS` method.'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: '[列表 11-7](#listing11-7) 通过 `ServeTLS` 方法完善了回显服务器的实现。'
- en: '[PRE7]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Listing 11-7: Adding TLS support to a net.Listener (*tls_echo.go*)'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 11-7：为 `net.Listener` 添加 TLS 支持（*tls_echo.go*）
- en: The `ServeTLS` method first checks the server’s TLS configuration. If it’s `nil`,
    it adds a default configuration with `PreferServerCipherSuites` set to `true`1.
    `PreferServerCipherSuites` is meaningful to the server only, and it makes the
    server use its preferred cipher suite instead of deferring to the client’s preference.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: '`ServeTLS` 方法首先检查服务器的 TLS 配置。如果配置为 `nil`，它将添加一个默认配置，并将 `PreferServerCipherSuites`
    设置为 `true`。`PreferServerCipherSuites` 对服务器有意义，它使服务器使用自己首选的密码套件，而不是听从客户端的偏好。'
- en: If the server’s TLS configuration does not have at least one certificate, or
    if its `GetCertificate` method is `nil`, you create a new `tls.Certificate` by
    reading in the certificate and private-key files from the filesystem 2.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 如果服务器的TLS配置没有至少一个证书，或者其`GetCertificate`方法为`nil`，你可以通过从文件系统读取证书和私钥文件来创建一个新的`tls.Certificate`
    2。
- en: At this point in the code, the server has a TLS configuration with at least
    one certificate ready to present to clients. All that’s left is to add TLS support
    to the `net.Listener` by passing it and the server’s TLS configuration to the
    `tls.NewListener` function 3. The `tls.NewListener` function acts like middleware,
    in that it augments the listener to return TLS-aware connection objects from its
    `Accept` method.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 在这段代码中，服务器拥有一个TLS配置，其中至少包含一个证书，准备向客户端展示。剩下的就是通过将TLS配置和监听器传递给`tls.NewListener`函数来为`net.Listener`添加TLS支持
    3。`tls.NewListener`函数充当中间件，它增强了监听器，使其从`Accept`方法返回TLS支持的连接对象。
- en: '[Listing 11-8](#listing11-8) finishes up the `ServeTLS` method by accepting
    connections from the listener and handling them in separate goroutines.'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: '[列表11-8](#listing11-8)通过从监听器接受连接并在单独的goroutine中处理它们来完成`ServeTLS`方法。'
- en: '[PRE8]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Listing 11-8: Accepting TLS-aware connections from the listener (*tls_echo.go*)'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 列表11-8：从监听器接受TLS支持的连接（*tls_echo.go*）
- en: This pattern is like the one you’ve seen in earlier chapters. You use an endless
    `for` loop to continually block on the listener’s `Accept` method 1, which returns
    a new `net.Conn` object when a client successfully connects. Since you’re using
    a TLS-aware listener, it returns connection objects with underlying TLS support.
    You interact with these connection objects the same as you always do. Go abstracts
    the TLS details away from you at this point. You then spin off this connection
    into its own goroutine to handle the connection from that point forward.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 这个模式与前面章节中你见过的类似。你使用一个无限的`for`循环，不断阻塞在监听器的`Accept`方法 1 上，当客户端成功连接时，它会返回一个新的`net.Conn`对象。由于你使用的是一个支持TLS的监听器，它返回的是具有TLS支持的连接对象。你与这些连接对象的交互方式与以往相同。Go在这一点上将TLS的细节抽象给你。然后你会将这个连接分配到一个新的goroutine中，从那时起处理该连接。
- en: The server handles each connection the same way. It first conditionally sets
    the socket deadline to the server’s maximum idle duration 3, then waits for the
    client to send data. If the server doesn’t read anything from the socket before
    it reaches the deadline, the connection’s `Read` method 4 returns an *I/O time-out*
    error, ultimately causing the connection to close 2.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 服务器以相同的方式处理每个连接。它首先有条件地将套接字截止日期设置为服务器的最大空闲时长 3，然后等待客户端发送数据。如果服务器在达到截止日期之前没有从套接字读取到任何数据，连接的`Read`方法
    4 会返回*I/O超时*错误，最终导致连接关闭 2。
- en: If, instead, the server reads data from the connection, it writes that same
    payload back to the client. Control loops back around to reset the deadline and
    then wait for the next payload from the client.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 如果相反，服务器从连接读取数据，它会将相同的负载写回给客户端。控制循环回绕以重置截止日期，然后等待来自客户端的下一个负载。
- en: Certificate Pinning
  id: totrans-83
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 证书钉扎
- en: Earlier in the chapter, we discussed ways to compromise the trust that TLS relies
    on, whether by a certificate authority issuing fraudulent certificates or an attacker
    injecting a malicious certificate into your computer’s trusted certificate storage.
    You can mitigate both attacks by using certificate pinning.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章前面，我们讨论了破坏TLS信任的方式，无论是证书颁发机构颁发伪造证书，还是攻击者将恶意证书注入到计算机的可信证书存储中。你可以通过使用证书钉扎（certificate
    pinning）来减轻这两种攻击。
- en: '*Certificate pinning* is the process of scrapping the use of the operating
    system’s trusted certificate storage and explicitly defining one or more trusted
    certificates in your application. Your application will trust connections only
    from hosts presenting a pinned certificate or a certificate signed by a pinned
    certificate. If you plan on deploying clients in zero-trust environments that
    must securely communicate with your server, consider pinning your server’s certificate
    to each client.'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: '*证书钉扎*是指放弃使用操作系统的可信证书存储，并在应用程序中显式定义一个或多个可信证书。你的应用程序将只信任来自展示钉扎证书或由钉扎证书签名的证书的主机。如果你计划在零信任环境中部署客户端，并且需要与服务器安全通信，请考虑将服务器的证书钉扎到每个客户端。'
- en: Assuming the server introduced in the preceding section uses the *cert.pem*
    and the *key.pem* you generated for the hostname *localhost*, all clients will
    abort the TLS connection as soon as the server presents its certificate. Clients
    won’t trust the server’s certificate because no trusted certificate authority
    signed it.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 假设前面一节介绍的服务器使用了您为*localhost*主机名生成的*cert.pem*和*key.pem*文件，所有客户端将在服务器展示证书后立即中止TLS连接。客户端不会信任服务器的证书，因为没有受信任的证书机构签署它。
- en: You could set the `tls.Config`’s `InsecureSkipVerify` field to `true`, but as
    this method is insecure, I don’t recommend you consider it a practical choice.
    Instead, let’s explicitly tell our client it can trust the server’s certificate
    by pinning the server’s certificate to the client. [Listing 11-9](#listing11-9)
    has the beginnings of a test to show that process.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以将`tls.Config`的`InsecureSkipVerify`字段设置为`true`，但由于此方法不安全，我不建议您将其视为一个实际选择。相反，我们明确告诉客户端它可以通过将服务器证书固定到客户端来信任服务器的证书。[列表11-9](#listing11-9)展示了这个过程的开始。
- en: '[PRE9]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Listing 11-9: Creating a new TLS echo server and starting it in the background
    (*tls_echo_test.go*)'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 列表11-9：创建一个新的TLS回显服务器并在后台启动它（*tls_echo_test.go*）
- en: Since the hostname in *cert.pem* is *localhost*, you create a new TLS echo server
    listening on *localhost* port 34443\. The port isn’t important here, but clients
    expect the server to be reachable by the same hostname as the one in the certificate
    it presents. You spin up the server in the background by using the *cert.pem*
    and *key.pem* files 1 and block until it’s ready for incoming connections 2.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 由于*cert.pem*中的主机名是*localhost*，您创建一个新的TLS回显服务器，监听*localhost*端口34443。这里端口不重要，但客户端期望服务器可以通过与证书中显示的相同主机名进行访问。您通过使用*cert.pem*和*key.pem*文件1启动服务器并阻塞，直到它准备好接受连接2。
- en: '[Listing 11-10](#listing11-10) picks up where we left off by creating a client
    TLS configuration with explicit trust for the server’s certificate.'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: '[列表11-10](#listing11-10)从我们停下的地方继续，通过创建一个带有明确信任服务器证书的客户端TLS配置。'
- en: '[PRE10]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Listing 11-10: Pinning the server certificate to the client (*tls_echo_test.go*)'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 列表11-10：将服务器证书固定到客户端（*tls_echo_test.go*）
- en: Pinning a server certificate to the client is straightforward. First, you read
    in the *cert.pem* file. Then, you create a new certificate pool 1 and append the
    certificate to it. Finally, you add the certificate pool to the `tls.Config`’s
    `RootCAs` field 2. As the name suggests, you can add more than one trusted certificate
    to the certificate pool. This can be useful when you are migrating to a new certificate
    but have yet to completely phase out the old certificate.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 将服务器证书固定到客户端是直接的。首先，您需要读取*cert.pem*文件。然后，您创建一个新的证书池1，并将证书添加到池中。最后，您将证书池添加到`tls.Config`的`RootCAs`字段2。如名称所示，您可以将多个受信任的证书添加到证书池中。这在您迁移到新证书，但尚未完全淘汰旧证书时非常有用。
- en: The client, using this configuration, will authenticate only servers that present
    the *cert.pem* certificate or any certificate signed by it. Let’s confirm this
    behavior in the rest of the test (see [Listing 11-11](#listing11-11)).
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 使用此配置的客户端将仅认证展示*cert.pem*证书或任何由其签署的证书的服务器。我们将在测试的其余部分确认这一行为（见[列表11-11](#listing11-11)）。
- en: '[PRE11]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Listing 11-11: Authenticating the server by using a pinned certificate (*tls_echo_test.go*)'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 列表11-11：通过使用固定的证书进行服务器认证（*tls_echo_test.go*）
- en: You pass `tls.Dial` the `tls.Config` with the pinned server certificate 1. Your
    TLS client authenticates the server’s certificate without having to resort to
    using `InsecureSkipVerify` and all the insecurity that option introduces.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 您将包含固定服务器证书1的`tls.Config`传递给`tls.Dial`。您的TLS客户端将在不需要使用`InsecureSkipVerify`及其带来的所有不安全性的情况下验证服务器的证书。
- en: Now that you’ve set up a trusted connection with a server, even though the server
    presented an unsigned certificate, let’s make sure the server works as expected.
    It should echo back any message you send it. If you idle long enough 2, you find
    that your next interaction with the socket results in an error 3, showing the
    server closed the socket.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，您已经与服务器建立了受信任的连接，尽管服务器展示了一个未签名的证书，我们还是来确保服务器按预期工作。它应该回显您发送的任何消息。如果您长时间空闲2，您会发现与套接字的下一次交互会导致错误3，显示服务器关闭了套接字。
- en: Mutual TLS Authentication
  id: totrans-100
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 相互TLS认证
- en: In the preceding section, you learned how clients authenticate servers by using
    the server’s certificate and a trusted third-party certificate or by configuring
    the client to explicitly trust the server’s certificate. Servers can authenticate
    clients in the same manner. This is particularly useful in zero-trust network
    infrastructures, where clients and servers must each prove their identities. For
    example, you may have a client outside your network that must present a certificate
    to a proxy before the proxy will allow the client to access your trusted network
    resources. Likewise, the client authenticates the certificate presented by your
    proxy to make sure it’s talking to your proxy and not one controlled by a malicious
    actor.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 在前一节中，你学习了客户端如何通过使用服务器的证书和受信任的第三方证书，或者通过配置客户端显式信任服务器的证书来验证服务器身份。服务器也可以以相同的方式验证客户端身份。这在零信任网络架构中尤为重要，在这种架构下，客户端和服务器都必须证明自己的身份。例如，你可能有一个位于你网络外部的客户端，该客户端必须向代理服务器出示证书，代理服务器才会允许该客户端访问你的受信任网络资源。同样，客户端也会验证代理服务器出示的证书，以确保它与代理服务器通信，而不是与由恶意行为者控制的代理服务器通信。
- en: You can instruct your server to set up TLS sessions with only authenticated
    clients. Those clients would have to present a certificate signed by a trusted
    certificate authority or pinned to the server. Before you can look at example
    code, the client needs a certificate it can present to the server for authentication.
    However, clients cannot use the certificates generated with *$GOROOT/src/crypto/tls/generate_cert.go*
    for client authentication. Instead, you need to create your own certificate and
    private key.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以指示服务器只与已认证的客户端建立TLS会话。那些客户端必须出示由受信任的证书颁发机构签名或已固定到服务器的证书。在你查看示例代码之前，客户端需要一个可以向服务器出示的证书用于身份验证。然而，客户端不能使用在
    *$GOROOT/src/crypto/tls/generate_cert.go* 中生成的证书进行客户端身份验证。相反，你需要创建自己的证书和私钥。
- en: Generating Certificates for Authentication
  id: totrans-103
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 为身份验证生成证书
- en: Go’s standard library contains everything you need to generate your own certificates
    using the elliptic curve digital signature algorithm (ECDSA) and the P-256 elliptic
    curve. [Listing 11-12](#listing11-12) shows the beginnings of a command line utility
    for doing exactly that. As you go through it, keep in mind that it may not entirely
    fit your use case. For example, it creates 10-year certificates and uses my name
    as the certificate’s subject, which you likely don’t want to use in your code
    (though if you do, I’m flattered). Tweak, as necessary.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: Go的标准库包含了生成你自己证书所需的所有内容，使用的是椭圆曲线数字签名算法（ECDSA）和P-256椭圆曲线。[列表11-12](#listing11-12)展示了一个命令行工具的初步实现，正是用来做这个的。在你阅读它时，记住它可能不完全适合你的使用场景。例如，它生成的是10年的证书，并且使用我的名字作为证书的主体，这可能不是你在代码中想使用的（不过如果你愿意使用，我会感到受宠若惊）。根据需要进行调整。
- en: '[PRE12]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Listing 11-12: Creating an X.509 certificate template (*cert/generate.go*)'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 列表11-12：创建X.509证书模板 (*cert/generate.go*)
- en: The command line utility accepts a comma-separated list of hostnames and IP
    addresses that will use the certificate. It also allows you to specify the certificate
    and private-key filenames, but it defaults to our familiar *cert.pem* and *key.pem*
    filenames.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 该命令行工具接受一个用逗号分隔的主机名和IP地址列表，这些主机名和IP地址将使用该证书。它还允许你指定证书和私钥的文件名，但默认使用我们熟悉的 *cert.pem*
    和 *key.pem* 文件名。
- en: The process of generating a certificate and a private key involves building
    a template in your code that you then encode to the X.509 format. Each certificate
    needs a serial number, which a certificate authority typically assigns. Since
    you’re generating your own self-signed certificate, you generate your own serial
    number using a cryptographically random, unsigned 128-bit integer 1. You then
    create an `x509.Certificate` object that represents an X.509-formatted certificate
    and set various values, such as the serial number, the certificate’s subject,
    the validity lifetime, and various usages for this certificate. Since you want
    to use this certificate for client authentication, you must include the `x509.ExtKeyUsageClientAuth`
    value 2. If you omit this value, the server won’t be able to verify the certificate
    when presented by the client.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 生成证书和私钥的过程包括在代码中构建一个模板，然后将其编码为 X.509 格式。每个证书都需要一个序列号，通常由证书颁发机构分配。由于你正在生成自己的自签名证书，你使用加密随机的、无符号的
    128 位整数 1 来生成自己的序列号。接着，你创建一个 `x509.Certificate` 对象，表示一个 X.509 格式的证书，并设置各种值，如序列号、证书的主题、有效期和该证书的各种用途。由于你希望使用此证书进行客户端身份验证，你必须包括
    `x509.ExtKeyUsageClientAuth` 值 2。如果遗漏此值，服务器将无法在客户端提供证书时验证该证书。
- en: The template is almost ready. You just need to add the hostnames and IP addresses
    before generating the certificate (see [Listing 11-13](#listing11-13)).
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 模板几乎准备好了。你只需要在生成证书之前添加主机名和 IP 地址（参见 [清单 11-13](#listing11-13)）。
- en: '[PRE13]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Listing 11-13: Writing the Privacy-Enhanced Mail (PEM)–encoded certificate
    (*cert/generate.go*)'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 清单 11-13：编写隐私增强邮件（PEM）编码的证书（*cert/generate.go*）
- en: You loop through the comma-separated list of hostnames and IP addresses 1, assigning
    each to its appropriate slice in the template. If the hostname is an IP address,
    you assign it to the `IPAddresses` slice 2. Otherwise, you assign the hostname
    to the `DNSNames` slice 3. Go’s TLS client uses these values to authenticate a
    server. For example, if the client connects to *https://www.google.com* but the
    common name or alternative names in the server’s certificate do not match *www.google.com*’s
    hostname or resolved IP address, the client fails to authenticate the server.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 你遍历以逗号分隔的主机名和 IP 地址列表 1，将每个地址分配到模板中的相应切片。如果主机名是 IP 地址，你将其分配到 `IPAddresses` 切片
    2。否则，你将主机名分配到 `DNSNames` 切片 3。Go 的 TLS 客户端使用这些值来验证服务器。例如，如果客户端连接到 *https://www.google.com*，但服务器证书中的常见名称或备用名称与
    *www.google.com* 的主机名或解析后的 IP 地址不匹配，客户端将无法验证服务器。
- en: Next you generate a new ECDSA private key 4 using the P-256 elliptic curve.
    At this point, you have everything you need to generate the certificate. The `x509.CreateCertificate`
    function 5 accepts a source of entropy (`crypto/rand`’s `Reader` is ideal), the
    template for the new certificate, a parent certificate, a public key, and a corresponding
    private key. It then returns a slice of bytes containing the Distinguished Encoding
    Rules (DER)–encoded certificate. You use your template for the parent certificate
    since the resulting certificate signs itself. All that’s left to do is create
    a new file, generate a new `pem.Block` with the DER-encoded byte slice, and PEM-encode
    everything to the new file 6. You don’t have to concern yourself with the various
    encodings. Go is quite happy with using PEM-encoded certificates on disk.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，你使用 P-256 椭圆曲线生成一个新的 ECDSA 私钥 4。此时，你已经拥有生成证书所需的一切。`x509.CreateCertificate`
    函数 5 接受一个熵源（`crypto/rand` 的 `Reader` 是理想选择）、新证书的模板、父证书、公钥和相应的私钥。然后，它返回一个字节切片，包含按区分编码规则（DER）编码的证书。你使用模板作为父证书，因为生成的证书将自签名。接下来要做的就是创建一个新文件，生成一个新的
    `pem.Block`，并将 DER 编码的字节切片进行 PEM 编码，保存到新文件中 6。你不需要担心各种编码。Go 非常适合在磁盘上使用 PEM 编码的证书。
- en: Now that you have a new certificate on disk, let’s write the corresponding private
    key in [Listing 11-14](#listing11-14).
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经在磁盘上生成了新的证书，我们来编写相应的私钥，参见 [清单 11-14](#listing11-14)。
- en: '[PRE14]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Listing 11-14: Writing the PEM-encoded private key (*cert/generate.go*)'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 清单 11-14：编写 PEM 编码的私钥（*cert/generate.go*）
- en: 'Whereas the certificate is meant to be publicly shared, the private key is
    just that: private. You should take care to assign it minimal permissions. Here,
    you’re giving only the user read-write access to the private-key file 1 and removing
    access for everyone else. We marshal the private key into a byte slice 2 and,
    similarly, assign it to a new `pem.Block` before writing the PEM-encoded output
    to the private-key file 3.'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 证书是为了公开共享，而私钥则完全相反：是私密的。你应该小心地为它分配最小的权限。在这里，你只给用户读写私钥文件的权限1，并移除其他所有人的访问权限。我们将私钥编组为字节切片2，并且类似地，将其分配给新的`pem.Block`，然后将PEM编码的输出写入私钥文件3。
- en: '[Listing 11-15](#listing11-15) uses the preceding code to generate certificate
    and key pairs for the server and the client.'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: '[Listing 11-15](#listing11-15)使用前面的代码生成了服务器和客户端的证书和密钥对。'
- en: '[PRE15]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Listing 11-15: Generating a certificate and private-key pair for the server
    and the client'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 'Listing 11-15: 为服务器和客户端生成证书和私钥对'
- en: Since the server binds to *localhost* and the client connects to the server
    from *localhost*, this value is appropriate for both the client and server certificates.
    If you want to move the client to a different hostname or bind the server to an
    IP address, for example, you’ll need to change the *host* flag accordingly.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 由于服务器绑定到*localhost*，而客户端从*localhost*连接到服务器，因此这个值适用于客户端和服务器证书。如果你想将客户端移动到不同的主机名或将服务器绑定到IP地址，例如，你需要相应地更改*host*标志。
- en: Implementing Mutual TLS
  id: totrans-122
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 实现互相TLS认证
- en: Now that you’ve generated certificate and private-key pairs for both the server
    and the client, you can start writing their code. Let’s write a test that implements
    mutual TLS authentication between our echo server and a client, starting in [Listing
    11-16](#listing11-16).
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经为服务器和客户端生成了证书和私钥对，你可以开始编写它们的代码了。让我们编写一个测试，实现我们的回显服务器和客户端之间的互相TLS认证，从[Listing
    11-16](#listing11-16)开始。
- en: '[PRE16]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Listing 11-16: Creating a certificate pool to serve CA certificates (*tls_mutual_test.go*)'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 'Listing 11-16: 创建证书池以提供CA证书(*tls_mutual_test.go*)'
- en: Both the client and server use the `caCertPool` function to create a new X.509
    certificate pool. The function accepts the file path to a PEM-encoded certificate,
    which you read in 1 and append to the new certificate pool 2. The certificate
    pool serves as a source of trusted certificates. The client puts the server’s
    certificate in its certificate pool, and vice versa.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 客户端和服务器都使用`caCertPool`函数来创建一个新的X.509证书池。该函数接受一个PEM编码证书的文件路径，你在第1步中读取该证书并将其附加到新的证书池2中。证书池作为受信任证书的来源。客户端将服务器的证书放入其证书池中，反之亦然。
- en: '[Listing 11-17](#listing11-17) details the initial test code to demonstrate
    mutual TLS authentication between a client and a server.'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: '[Listing 11-17](#listing11-17)详细介绍了初步的测试代码，用于演示客户端和服务器之间的互相TLS认证。'
- en: '[PRE17]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Listing 11-17: Instantiating a CA cert pool and a server certificate (*tls_mutual_test.go*)'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 'Listing 11-17: 实例化CA证书池和服务器证书(*tls_mutual_test.go*)'
- en: Before creating the server, you need to first populate a new CA certificate
    pool with the client’s certificate 1. You also need to load the server’s certificate
    at this point 2 instead of relying on the server’s `ServeTLS` method to do it
    for you, as you have in previous listings. Why you need the server’s certificate
    now will be clear when you see the TLS configuration changes in [Listing 11-18](#listing11-18).
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建服务器之前，你需要先用客户端的证书1填充一个新的CA证书池。此时，你还需要加载服务器的证书2，而不是像之前的列表中那样依赖服务器的`ServeTLS`方法来为你加载。你为什么现在需要服务器的证书，看到[Listing
    11-18](#listing11-18)中的TLS配置更改后就会明白。
- en: '[PRE18]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Listing 11-18: Accessing the client’s hello information using GetConfigForClient
    (*tls_mutual_test.go*)'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 'Listing 11-18: 使用GetConfigForClient访问客户端的hello信息(*tls_mutual_test.go*)'
- en: Remember that in [Listing 11-13](#listing11-13), you defined the `IPAddresses`
    and `DNSNames` slices of the template used to generate your client’s certificate.
    These values populate the common name and alternative names portions of the client’s
    certificate. You learned that Go’s TLS client uses these values to authenticate
    the server. But the server does not use these values from the client’s certificate
    to authenticate the client.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，在[Listing 11-13](#listing11-13)中，你定义了生成客户端证书时使用的模板中的`IPAddresses`和`DNSNames`切片。这些值填充了客户端证书的公共名称和备用名称部分。你已经了解到Go的TLS客户端使用这些值来验证服务器。但是服务器并不使用这些来自客户端证书的值来验证客户端。
- en: Since you’re implementing mutual TLS authentication, you need to make some changes
    to the server’s certificate verification process so that it authenticates the
    client’s IP address or hostnames against the client certificate’s common name
    and alternative names. To do that, the server at the very least needs to know
    the client’s IP address. The only way you can get client connection information
    before certificate verification is by defining the `tls.Config`’s `GetConfigForClient`
    method 1. This method allows you to define a function that receives the `*tls.ClientHelloInfo`
    object created as part of the TLS handshake process with the client. From this,
    you can retrieve the client’s IP address. But first, you need to return a proper
    TLS configuration.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 由于你正在实现双向TLS认证，你需要对服务器的证书验证过程进行一些更改，以便它根据客户端证书的公共名称和备用名称来验证客户端的IP地址或主机名。为此，服务器至少需要知道客户端的IP地址。在证书验证之前获取客户端连接信息的唯一方法是定义`tls.Config`的`GetConfigForClient`方法1。这个方法允许你定义一个函数，该函数接收在TLS握手过程中与客户端创建的`*tls.ClientHelloInfo`对象。通过这个，你可以获取客户端的IP地址。但首先，你需要返回一个适当的TLS配置。
- en: You add the server’s certificate to the TLS configuration 2 and the server pool
    to the TLS configuration’s `ClientCAs` field 4. This field is the server’s equivalent
    to the TLS configuration’s `RootCAs` field on the client. You also need to tell
    the server that every client must present a valid certificate before completing
    the TLS handshake process 3. Since you control both the client and the server,
    specify a minimum TLS protocol version of 1.3 5.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 你将服务器的证书添加到TLS配置中2，并将服务器池添加到TLS配置的`ClientCAs`字段4中。这个字段是服务器的等效项，类似于客户端TLS配置中的`RootCAs`字段。你还需要告诉服务器，每个客户端在完成TLS握手过程之前必须提供有效的证书3。由于你控制客户端和服务器，指定一个最小的TLS协议版本为1.35。
- en: This function returns the same TLS configuration for every client connection.
    As mentioned, the only reason you’re using the `GetConfigForClient` method is
    so you can retrieve the client’s IP from its hello information. [Listing 11-19](#listing11-19)
    implements the verification process that authenticates the client by using its
    IP address and its certificate’s common name and alternative names.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数为每个客户端连接返回相同的TLS配置。如前所述，你使用`GetConfigForClient`方法的唯一原因是为了从客户端的hello信息中获取客户端的IP地址。[示例
    11-19](#listing11-19)实现了通过使用客户端的IP地址以及证书的公共名称和备用名称来验证客户端的过程。
- en: '[PRE19]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Listing 11-19: Making the server authenticate the client’s IP and hostnames
    (*tls_mutual_test.go*)'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 11-19：使服务器验证客户端的IP地址和主机名（*tls_mutual_test.go*）
- en: Since you want to augment the usual certificate verification process on the
    server, you define an appropriate function and assign it to the TLS configuration’s
    `VerifyPeerCertificate` method 1. The server calls this method after the normal
    certificate verification checks. The only check you’re performing above and beyond
    the normal checks is to verify the client’s hostname with the leaf certificate.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 由于你想在服务器上增强常规证书验证过程，你定义了一个合适的函数并将其分配给TLS配置的`VerifyPeerCertificate`方法1。服务器在正常的证书验证检查后调用此方法。你执行的唯一额外检查是通过叶证书验证客户端的主机名。
- en: The *leaf certificate* is the last certificate in the certificate chain given
    to the server by the client. The leaf certificate contains the client’s public
    key. All other certificates in the chain are intermediate certificates used to
    verify the authenticity of the leaf certificate and culminate with the certificate
    authority’s certificate. You’ll find each leaf certificate at index 0 in each
    `verifiedChains` slice. In other words, you can find the leaf certificate of the
    first chain at `verifiedChains[0][0]`. If the server calls your function assigned
    to the `VerifyPeerCertificate` method, the leaf certificate in the first chain
    exists at a minimum.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: '*叶证书*是客户端提供给服务器的证书链中的最后一张证书。叶证书包含客户端的公钥。链中的所有其他证书都是中间证书，用于验证叶证书的真实性，并最终以证书颁发机构的证书作为结束。你可以在每个`verifiedChains`切片中的索引0找到每个叶证书。换句话说，你可以在`verifiedChains[0][0]`中找到第一个链的叶证书。如果服务器调用你分配给`VerifyPeerCertificate`方法的函数，至少可以找到第一个链中的叶证书。'
- en: Create a new `x509.VerifyOptions` object and modify the `KeyUsages` method to
    indicate you want to perform client authentication 2. Then, assign the server
    pool to the `Roots` method 3. The server uses this pool as its trusted certificate
    source during verification.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个新的 `x509.VerifyOptions` 对象，并修改 `KeyUsages` 方法以指示您希望执行客户端身份验证 2。然后，将服务器池分配给
    `Roots` 方法 3。服务器在验证期间使用此池作为其可信证书源。
- en: Now, extract the client’s IP address from the connection object in the `*tls.ClientHelloInfo`
    object named `hello` passed into [Listing 11-18](#listing11-18)’s `GetConfigForClient`
    method. Use the IP address to perform a reverse DNS lookup 4 to consider any hostnames
    assigned to the client’s IP address. If this lookup fails or returns an empty
    slice, the way you handle that situation is up to you. If you’re relying on the
    client’s hostname for authentication and the reverse lookup fails, you cannot
    authenticate the client. But if you’re using the client’s IP address only in the
    certificate’s common name or alternative names, then a reverse lookup failure
    is inconsequential. For demonstration purposes, we’ll consider a failed reverse
    lookup to equate to a failed test. At minimum, you append the client’s IP address
    to the `hostnames` slice.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，从传递到 [第 11-18 行](#listing11-18) 的 `GetConfigForClient` 方法的 `*tls.ClientHelloInfo`
    对象 `hello` 中提取客户端的 IP 地址。使用该 IP 地址执行反向 DNS 查找 4，以考虑分配给客户端 IP 地址的任何主机名。如果此查找失败或返回空切片，则如何处理这种情况由您决定。如果您依赖客户端的主机名进行身份验证，并且反向查找失败，则无法对客户端进行身份验证。但如果您仅在证书的通用名称或备用名称中使用客户端的
    IP 地址，则反向查找失败无关紧要。为了演示目的，我们将考虑失败的反向查找等同于失败的测试。最少，您应将客户端的 IP 地址附加到 `hostnames`
    切片中。
- en: All that’s left to do is loop through each verified chain, assign a new intermediate
    certificate pool to `opts.Intermediates`, add all certificates but the leaf certificate
    to the intermediate certificate pool 5, and attempt to verify the client 6. If
    verification returns a `nil` error, you authenticated the client. If you fail
    to verify each hostname with each leaf certificate, return an error to indicate
    that client authentication failed. The client will receive an error, and the server
    will terminate the connection.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 唯一剩下的事情就是循环遍历每个验证的链条，将一个新的中间证书池分配给 `opts.Intermediates`，将所有证书但叶子证书添加到中间证书池 5，并尝试验证客户端
    6。如果验证返回 `nil` 错误，则您已经成功认证了客户端。如果未能验证每个叶证书的每个主机名，则返回错误以指示客户端认证失败。客户端将收到一个错误，并且服务器将终止连接。
- en: Now that the server’s TLS configuration properly authenticates client certificates,
    continue with the server implementation in [Listing 11-20](#listing11-20).
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 现在服务器的 TLS 配置正确验证客户端证书，接着继续在 [第 11-20 行](#listing11-20) 中完成服务器实现。
- en: '[PRE20]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Listing 11-20: Starting the TLS server (*tls_mutual_test.go*)'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 第 11-20 行：启动 TLS 服务器 (*tls_mutual_test.go*)
- en: Create a new TLS server instance, making sure to pass in the TLS configuration
    you just created 1. Call its `ListenAndServeTLS` method in a goroutine and make
    sure to wait until the server is ready for connections 2 before proceeding.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个新的 TLS 服务器实例，确保传递刚刚创建的 TLS 配置 1。在一个 goroutine 中调用其 `ListenAndServeTLS` 方法，并确保在继续之前等待服务器准备好连接
    2。
- en: Now that the server implementation is ready, let’s move on to the client portion
    of the test. [Listing 11-21](#listing11-21) implements a TLS client that can present
    *clientCert.pem* upon request by the server.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，服务器实现准备就绪，让我们继续进行测试的客户端部分。[第 11-21 行](#listing11-21) 实现了一个 TLS 客户端，可以在服务器要求时提交
    *clientCert.pem*。
- en: '[PRE21]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Listing 11-21: Pinning the server certificate to the client (*tls_mutual_test.go*)'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 第 11-21 行：将服务器证书固定到客户端 (*tls_mutual_test.go*)
- en: The client retrieves a new certificate pool populated with the server’s certificate
    1. The client then uses the certificate pool in the `RootCAs` field of its TLS
    configuration 3, meaning the client will trust only server certificates signed
    by *serverCert.pem*. You also configure the client with its own certificate 2
    to present to the server upon request.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 客户端检索一个新的证书池，其中包含服务器的证书 1。然后客户端在其 TLS 配置的 `RootCAs` 字段中使用此证书池 3，这意味着客户端仅信任由
    *serverCert.pem* 签名的服务器证书。您还配置客户端使用其自己的证书 2，在服务器请求时提交给服务器。
- en: It’s worth noting that the client and server have not initialized a TLS session
    yet. They haven’t completed the TLS handshake. If `tls.Dial` returns an error,
    it isn’t because of an authentication issue but more likely a TCP connection issue.
    Let’s continue with the client code to initiate the handshake (see [Listing 11-22](#listing11-22)).
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 值得注意的是，客户端和服务器尚未初始化 TLS 会话。它们还没有完成 TLS 握手。如果 `tls.Dial` 返回错误，这并非因为认证问题，而更可能是由于
    TCP 连接问题。让我们继续查看客户端代码以启动握手（参见 [Listing 11-22](#listing11-22)）。
- en: '[PRE22]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Listing 11-22: TLS handshake completes as you interact with the connection
    (*tls_mutual_test.go*)'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 'Listing 11-22: TLS 握手在你与连接互动时完成（*tls_mutual_test.go*）'
- en: The first read from, or write to, the socket connection automatically initiates
    the handshake process between the client and the server. If the server rejects
    the client certificate, the read call 1 will return a *bad certificate* error.
    But if you created appropriate certificates and properly pinned them, both the
    client and the server are happy, and this test passes.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 从套接字连接中进行的首次读取或写入操作会自动启动客户端与服务器之间的握手过程。如果服务器拒绝客户端证书，读取调用将返回一个*坏证书*错误。但如果你创建了合适的证书并正确地进行了固定，那么客户端和服务器都能正常工作，测试也会通过。
- en: What You’ve Learned
  id: totrans-156
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 你所学到的
- en: Transport Layer Security provides both authentication and encrypted communication
    between a client and a server. The server presents a certificate, signed by certificate
    authority, to a client as part of the TLS handshake process. The client verifies
    the certificate’s signatory. If a third party, trusted by the client, signed the
    server’s certificate, the server is authentic in the eyes of the client. From
    that point forward, the client and server communicate using symmetric-key cryptography.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 传输层安全性（TLS）为客户端与服务器之间提供认证和加密通信。服务器向客户端呈现一个由证书颁发机构签署的证书，作为 TLS 握手过程的一部分。客户端验证证书的签署者。如果证书被客户端信任的第三方签署，那么服务器在客户端眼中就是可信的。从那时起，客户端和服务器将使用对称密钥加密通信。
- en: By default, Go’s TLS configuration uses the operating system’s trusted certificate
    storage. This storage typically consists of certificates from the world’s foremost
    trusted certificate authorities. However, we can modify the TLS configuration
    to trust specific keys, a process known as key pinning.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，Go 的 TLS 配置使用操作系统的可信证书存储区。该存储区通常包含来自全球领先的受信任证书颁发机构的证书。然而，我们可以修改 TLS 配置以信任特定的密钥，这一过程被称为密钥固定（key
    pinning）。
- en: We can also modify a server’s TLS configuration to require a certificate from
    the client. The server would then use this certificate to authenticate the client
    in the same manner the client authenticates the server. This process is known
    as mutual TLS authentication.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以修改服务器的 TLS 配置，要求客户端提供证书。然后，服务器会使用该证书以与客户端认证服务器相同的方式来认证客户端。这一过程被称为双向 TLS
    认证。
- en: TLS 1.3 provides forward secrecy for all communication between a client and
    server. This means that compromising one session does not compromise any other
    session. Both the client and server generate per-session public- and private-key
    pairs. They also exchange an ephemeral shared secret as part of the handshake
    process. Once the session ends, the client and server shall purge the shared secret
    and their temporary key pairs. An attacker who was able to capture the shared
    secret and session traffic would be able to decrypt only that session’s traffic.
    An attacker could not use the shared secret from one session to decrypt traffic
    from any other session.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: TLS 1.3 为客户端和服务器之间的所有通信提供前向保密性。这意味着，一次会话的泄露不会影响其他任何会话。客户端和服务器为每个会话生成公钥和私钥对。它们还会在握手过程中交换一个临时共享密钥。一旦会话结束，客户端和服务器将删除共享密钥和它们的临时密钥对。一个能够捕获共享密钥和会话流量的攻击者只能解密该会话的流量。攻击者无法使用一个会话的共享密钥来解密其他会话的流量。
- en: Even though TLS is ubiquitous and secures much of the world’s digital communication,
    attackers can compromise it. Part of a certificate authority’s job is to verify
    that the entity requesting a certificate for a specific domain name owns the domain
    name. If attackers dupe a certificate authority, or the certificate authority
    otherwise makes a mistake and issues a fraudulent certificate, the owner of the
    fraudulent certificate could masquerade as Google, for example, and trick people
    into divulging sensitive information.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管TLS无处不在，并保护着世界上大量的数字通信，但攻击者仍然能够攻破它。证书颁发机构的部分职责是验证请求特定域名证书的实体是否拥有该域名。如果攻击者欺骗了证书颁发机构，或者证书颁发机构犯了错误并颁发了伪造的证书，那么伪造证书的持有者就可能伪装成谷歌（Google）等，并诱使人们泄露敏感信息。
- en: Another attack vector includes fooling a client into adding the attacker’s certificate
    into the client’s trusted certificate storage. The attacker could then issue and
    sign any certificate they want, and the client would inherently trust that the
    attacker is who their certificate claims them to be.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种攻击途径是欺骗客户端将攻击者的证书添加到客户端的受信证书存储中。攻击者随后可以签发并签署任何他们想要的证书，而客户端会天然地信任攻击者所声明的身份。
- en: An attacker could also compromise a server and intercept TLS session keys and
    secrets, or even capture traffic at the application later after the server has
    decrypted it.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 攻击者还可能攻破服务器，拦截TLS会话密钥和机密信息，甚至在服务器解密后捕获应用层的流量。
- en: Overall, however, these attacks are rare, and TLS succeeds at achieving its
    goals of authentication and encrypted communication.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，整体来说，这些攻击是罕见的，TLS在实现身份验证和加密通信的目标方面是成功的。
