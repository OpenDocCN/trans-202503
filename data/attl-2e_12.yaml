- en: '12'
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '12'
- en: LOCALIZATION
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本地化
- en: '*When I’m working on a problem, I never think about beauty. I think only how
    to solve the problem. But when I have finished, if the solution is not beautiful,
    I know it is wrong.'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: '*当我在解决问题时，我从不考虑美观。我只考虑如何解决问题。但当我完成后，如果解决方案不美观，我知道它是错误的。*'
- en: —R. Buckminster Fuller*
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: —R. 巴克敏斯特·富勒*
- en: '![Image](../images/common.jpg)'
  id: totrans-4
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/common.jpg)'
- en: Once you’ve accomplished the significant work involved in internationalizing
    your software, you can begin to consider building message catalogs for other languages
    and cultures. Building a language-specific message catalog is known as *localization*.
    You are localizing your software for a target locale. We will spend this chapter
    discussing the way GNU projects approach these topics, including how to hook message
    catalog management into an Autotools build system.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你完成了国际化软件的重大工作，你就可以开始考虑为其他语言和文化构建消息目录。构建特定语言的消息目录被称为*本地化*。你正在为目标区域设置本地化你的软件。我们将在本章讨论GNU项目如何处理这些主题，包括如何将消息目录管理集成到Autotools构建系统中。
- en: Getting Started
  id: totrans-6
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 入门
- en: Message catalogs must be located where applications can find them. It could
    have been decided that applications should just store their language-specific
    message catalogs in a location selected by each project, but Linux (and Unix,
    in general) has long practiced the subtle art of quietly guiding application developers
    by convention. Not only do such conventions keep developers from having to make
    the same decisions over and over, but they also maximize the potential for reuse
    wherever possible. To these ends, the established convention for message catalogs
    is to place them in a common directory under the system data directory—what the
    *GNU Coding Standards* refers to as the `datadir`—most often defined as `$(prefix)`*/share*.^([1](footnote.xhtml#ch12fn1))
    A special directory, `$(datadir)`*/locale*, houses all application message catalogs
    in a format that provides some nice features for the user.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 消息目录必须存放在应用程序能够找到的位置。可能已经决定，应用程序应该将其特定语言的消息目录存储在每个项目选择的某个位置，但Linux（以及Unix，通常也是如此）长期以来一直通过约定悄悄地指导应用程序开发者。这些约定不仅避免了开发者反复做出相同的决策，而且尽可能地最大化了重用的潜力。为此，消息目录的约定位置是将它们放在系统数据目录下的公共目录中——*GNU
    编码标准*所称的`datadir`——通常定义为`$(prefix)`*/share*.^([1](footnote.xhtml#ch12fn1)) 一个特殊的目录`$(datadir)`*/locale*，存放所有应用程序的消息目录，并以一种为用户提供一些好功能的格式呈现。
- en: '*Language Selection*'
  id: totrans-8
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '*语言选择*'
- en: 'I mentioned in [Chapter 11](ch11.xhtml) that application selection of the current
    language, and hence the message catalog used by the application, is done in two
    phases. I’ve discussed the programmer phase already. Now let’s turn to the user
    phase, which allows the user some choice over which message catalog is selected.
    As with the selection of locale, the selection of the message catalog can be directed
    through the use of environment variables. The following environment variables
    are used to select the message catalog an application will use:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 我在[第11章](ch11.xhtml)中提到过，当前语言的应用程序选择，以及由应用程序使用的消息目录，是分两阶段完成的。我已经讨论过程序员阶段。现在让我们转向用户阶段，在这个阶段，用户可以选择所选的消息目录。与选择区域设置类似，消息目录的选择可以通过使用环境变量来指示。以下环境变量用于选择应用程序将使用的消息目录：
- en: '`LANGUAGE`'
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`LANGUAGE`'
- en: '`LC_ALL`'
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`LC_ALL`'
- en: '`LC_`*`xxx`*'
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`LC_`*`xxx`*'
- en: '`LANG`'
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`LANG`'
- en: Up to this point, we’ve only focused on the `LC_ALL` variable, but, in actuality,
    the application’s global locale is selected by first examining `LC_ALL`, then
    a category-specific variable (`LC_TIME`, for example), and finally `LANG`, in
    that order. In other words, if `LC_ALL` is not set or is set to the empty string,
    `setlocale` will look for `LC_`*`xxx`* variables (specifically, `LC_COLLATE`,
    `LC_CTYPE`, `LC_MESSAGES`, `LC_MONETARY`, `LC_NUMERIC`, and `LC_TIME`) and use
    their values to determine which locales are used for the associated areas of library
    functionality. Finally, if none of those are set, `LANG` is examined. If `LANG`
    is not set, you get an implementation-defined default, which is not always the
    same as the `C` locale.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们只关注了`LC_ALL`变量，但实际上，应用程序的全局区域设置是通过首先检查`LC_ALL`，然后是特定类别的变量（例如`LC_TIME`），最后是`LANG`，按照这个顺序来选择的。换句话说，如果`LC_ALL`未设置或设置为空字符串，`setlocale`将查找`LC_`*`xxx`*变量（特别是`LC_COLLATE`、`LC_CTYPE`、`LC_MESSAGES`、`LC_MONETARY`、`LC_NUMERIC`和`LC_TIME`），并使用它们的值来确定使用哪些区域设置来处理关联的库功能。最后，如果这些都没有设置，则检查`LANG`。如果`LANG`未设置，则会得到一个实现定义的默认值，这个默认值并不总是与`C`区域设置相同。
- en: 'On top of these variables used by `setlocale`, the *gettext* functions look
    at `LANGUAGE` first, which, if set, will override all the others for message catalog
    selection. Additionally, the *value* set in the `LANGUAGE` variable has some impact
    on the selection criteria. Before we get into value formats, let’s take a look
    at the directory structure beneath `$(datadir)`*/locale*. If you look at this
    directory on your own system, you’d see something like this:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 除了`setlocale`使用的这些变量外，*gettext*函数首先会查看`LANGUAGE`，如果已设置，`LANGUAGE`会覆盖所有其他变量以选择消息目录。此外，`LANGUAGE`变量中设置的*值*对选择标准有一定影响。在我们深入了解值的格式之前，先来看一下`$(datadir)`*/locale*下的目录结构。如果你自己查看这个目录，可能会看到类似这样的内容：
- en: '[PRE0]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The format of these directory names should look somewhat familiar—it’s the
    same format used by locale names defined in “Generating and Installing Locales”
    on [page 303](ch11.xhtml#page_303). Under each locale directory containing message
    catalogs (it’s rather sparse—application localization is not as prevalent as you
    might imagine), you’ll find a directory named *LC_MESSAGES*, containing one or
    more *message object* (*.mo*) files, which are compiled message catalogs. Here’s
    Spanish in Spain, for instance:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 这些目录名的格式应该看起来很熟悉——它与“生成和安装语言环境”中定义的语言环境名称格式相同，见 [第303页](ch11.xhtml#page_303)。在每个包含消息目录的语言环境目录下（这其实比较稀疏——应用程序本地化并不像你想象的那么普遍），你会找到一个名为*LC_MESSAGES*的目录，里面包含一个或多个*消息对象*（*.mo*）文件，这些是已编译的消息目录。例如，这里是西班牙语（西班牙）的情况：
- en: '[PRE1]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'If you examine the region-independent Spanish locale directory, */usr/share/locale/es*,
    you’ll see a lot more message catalogs. Most programs don’t bother differentiating
    regional locales when translating:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你检查区域独立的西班牙语语言环境目录 */usr/share/locale/es*，你会看到更多的消息目录。大多数程序在翻译时并不会区分不同的区域语言环境：
- en: '[PRE2]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: As I mentioned earlier, the base name of a message object file is the domain
    of the owning application. When you call `textdomain` and `bindtextdomain`, the
    *`domain`* you specify selects a message object file by name. In this directory
    listing, *blueberry* is the message catalog domain of the application that uses
    the *blueberry.mo* message catalog.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 如我之前提到的，消息对象文件的基本名称是拥有应用程序的域名。当你调用`textdomain`和`bindtextdomain`时，你指定的*`domain`*会通过名称选择一个消息对象文件。在这个目录列表中，*blueberry*是使用*blueberry.mo*消息目录的应用程序的消息目录域名。
- en: '*Building Message Catalogs*'
  id: totrans-22
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '*构建消息目录*'
- en: The *gettext* library provides a set of utilities that help you build message
    catalogs from source code that’s been internationalized for message catalog selection.
    Figure 11-1 depicts the flow of data through the *gettext* utilities, from source
    code to binary message object.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: '*gettext*库提供了一组工具，帮助你从已国际化的源代码中构建消息目录，以供消息目录选择。图11-1描述了数据通过*gettext*工具的流动，从源代码到二进制消息对象。'
- en: '![Image](../images/12fig01.jpg)'
  id: totrans-24
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/12fig01.jpg)'
- en: '*Figure 12-1: The flow of data from source file to message object file*'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: '*图12-1：从源文件到消息对象文件的数据流*'
- en: The `xgettext` utility extracts messages from programming language source files
    and builds a *portable object template* (*.pot*) file. This is done each time
    the message strings in source files are changed or updated in some way. Perhaps
    existing messages are modified or removed or new messages are added. In any case,
    the *.pot* file must be updated. The *.pot* file is usually named after the message
    catalog domain used by the package or program.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: '`xgettext`工具从编程语言源文件中提取消息，并构建一个*可移植对象模板*（*.pot*）文件。每当源文件中的消息字符串发生更改或更新时，都会执行此操作。可能是现有消息被修改或删除，或者添加了新的消息。无论如何，*.pot*文件必须更新。*.pot*文件通常以包或程序使用的消息目录域名命名。'
- en: 'Assuming we created a message catalog in a project for a French locale, this
    process generates files in the current directory, but we’re going to follow a
    common convention by generating all of our message artifacts into a directory
    off the project root called *po*:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们为法语语言环境在一个项目中创建了消息目录，那么此过程将在当前目录下生成文件，但我们将遵循一种常见的约定，将所有消息文件生成到项目根目录下的一个名为*po*的目录中：
- en: '[PRE3]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The internal layout of the *po* directory in my examples is arbitrary—you can
    tell the *gettext* tools how to name output files, and you can put them anywhere
    you like. I chose this structure because it’s what we’re going to use when we
    integrate *gettext* with an Autotools project later in this chapter.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 我示例中*po*目录的内部结构是任意的——你可以告诉*gettext*工具如何命名输出文件，并可以将其放在任何你喜欢的位置。我选择这个结构是因为我们将在本章稍后将*gettext*与Autotools项目集成时使用这种结构。
- en: 'Let’s generate a *.pot* file for the source code of the `gt` program in [Listing
    11-12](ch11.xhtml#ch11ex12) on [page 328](ch11.xhtml#page_328):'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们为[第11-12节](ch11.xhtml#ch11ex12)中`gt`程序的源代码生成一个*.pot*文件，见[第328页](ch11.xhtml#page_328)：
- en: '[PRE4]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The `xgettext` utility is designed to build *.pot* files from the source files
    of many different programming languages, so it accepts `--language` or `-L` command
    line options as hints. However, it will also guess the language, based on the
    file extension, if no such option is given.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: '`xgettext`工具被设计用于从许多不同编程语言的源文件中构建*.pot*文件，因此它接受`--language`或`-L`命令行选项作为提示。然而，如果没有提供此类选项，它也会根据文件扩展名猜测语言。'
- en: Because `xgettext` is designed to parse many different types of source file,
    it can sometimes require help locating the messages we want it to extract. It
    assumes text to be extracted is somehow associated with the `gettext` function
    in the C language. For other language source files, it looks for appropriate variations
    of this function name. Unfortunately, we threw a monkey wrench into the works
    when we replaced `gettext` with the underscore (`_`) macro name. This is where
    the `--keyword` (`-k`) option can be used to tell `xgettext` where to look for
    message text to be extracted. Our use of `-k_` causes `xgettext` to look for `_`
    instead of `gettext`. Without this option, `xgettext` won’t find any messages
    to extract and, therefore, won’t generate a *.pot* file.^([2](footnote.xhtml#ch12fn2))
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 因为`xgettext`被设计成解析许多不同类型的源文件，它有时需要帮助来定位我们希望它提取的消息。它假定要提取的文本与C语言中的`gettext`函数以某种方式相关联。对于其他语言的源文件，它会查找该函数名称的适当变体。不幸的是，当我们将`gettext`替换为下划线（`_`）宏名称时，我们给过程带来了麻烦。这时，可以使用`--keyword`（`-k`）选项告诉`xgettext`在哪里查找要提取的消息文本。我们使用`-k_`使`xgettext`查找`_`而不是`gettext`。如果没有这个选项，`xgettext`将找不到任何消息来提取，因此不会生成*.pot*文件。^([2](footnote.xhtml#ch12fn2))
- en: I’m also telling it to add comments (`-c`) and to sort the output messages (`-s`)
    as they’re added to the *.pot* file. If you don’t tell it otherwise (with the
    `-o` option), it’ll create a file called *messages.po*. Files not associated with
    a command line option are considered input files by `xgettext`.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 我还告诉它添加注释（`-c`）并在将信息添加到*.pot*文件时按顺序排序输出消息（`-s`）。如果你没有另行指定（使用`-o`选项），它会创建一个名为*messages.po*的文件。没有与命令行选项相关联的文件将被`xgettext`视为输入文件。
- en: At this point, though not strictly required, and depending on the workflow you
    choose to use, you may want to hand-edit *gt.pot* to update placeholder values
    that `xgettext` adds. For example, you may want to replace the `PACKAGE` and `VERSION`
    placeholder strings in the `Project-Id-Version` field and perhaps add an email
    address to the `Report-Msgid-Bugs-To` field. These can be added during generation
    by using the `--package-name`, `--package-version`, and `--msgid-bugs-address`
    command line options. There are a few others; you can look them up in the manual.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 此时，虽然不是严格要求的，并且取决于你选择使用的工作流，你可能需要手动编辑*gt.pot*，以更新`xgettext`添加的占位符值。例如，你可能想要替换`Project-Id-Version`字段中的`PACKAGE`和`VERSION`占位符字符串，并可能向`Report-Msgid-Bugs-To`字段添加电子邮件地址。这些可以通过使用`--package-name`、`--package-version`和`--msgid-bugs-address`命令行选项在生成时添加。还有一些其他选项，你可以在手册中查找。
- en: From this template, we can now generate *portable object* (*.po*) files for
    different locales. The `msginit` utility is used to create an initial version
    of a locale-specific *.po* file, while `msgmerge` is used to update an existing
    *.po* file that was previously generated with `msginit`.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 从这个模板中，我们现在可以为不同的语言环境生成*portable object*（*.po*）文件。`msginit`工具用于创建特定语言环境的*.po*文件的初始版本，而`msgmerge`用于更新之前通过`msginit`生成的现有*.po*文件。
- en: 'Let’s create a French *fr.po* file from our template, *gt.pot*:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从我们的模板*gt.pot*创建一个法语*fr.po*文件：
- en: '[PRE5]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: If you don’t specify any input or output files, it looks in the current directory
    for a *.pot* file and derives the output filename from the locale you specify
    with the `--locale` (`-l`) option. I’ve also added the `--no-translator` option
    to suppress an interactive aspect of this utility. If you leave it off, `msginit`
    attempts to find your email address on the local host and use it. If it gets confused,
    it stops and asks you which address to use.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你没有指定任何输入或输出文件，它会在当前目录中查找*.pot*文件，并根据你通过`--locale`（`-l`）选项指定的语言环境派生输出文件名。我还添加了`--no-translator`选项，以抑制该工具的交互式功能。如果你不加这个选项，`msginit`会尝试在本地主机上找到你的电子邮件地址并使用它。如果它搞不清楚，它会停止并询问你使用哪个地址。
- en: In addition to the specified or implied *.pot* file, it also examines makefiles
    and other build files within the near vicinity of the source files you specify
    to see what the project might be called. The project name, `PROJECT`, that you
    see in this output is the default it uses when it can’t find a project name, but
    it may surprise you how thorough `msginit` can be when searching for a project
    name.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 除了指定或隐含的*.pot*文件，它还会检查指定源文件附近的makefile和其他构建文件，以查看项目可能的名称。你在输出中看到的项目名称`PROJECT`是它在找不到项目名称时使用的默认名称，但你会惊讶于`msginit`在搜索项目名称时的彻底程度。
- en: Now, there’s nothing very French about this *.po* file yet—would that it were
    so simple! No, you still have to translate the strings from English to French
    manually. So what’s different about this *.po* file from its source template file?
    Essentially, everything related to a locale-specific implementation in the template
    has been filled in, including the title and copyright year in the comments at
    the top as well as the `PO-Revision-Date`, `Last-Translator`, `Language-Team`,
    `Language`, and `Plural-Forms` fields.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，这个*.po*文件还没有任何法语内容——希望事情能那么简单！不，您仍然需要手动将字符串从英语翻译成法语。那么这个*.po*文件与其源模板文件有什么不同呢？实质上，模板中与特定语言实现相关的所有内容已经填写，包括顶部注释中的标题和版权年份，以及`PO-Revision-Date`、`Last-Translator`、`Language-Team`、`Language`和`Plural-Forms`字段。
- en: The next step in the process is to actually translate the file. Normally, I’d
    go find a native French speaker with a good grasp of English and ask them to fill
    in the blanks for me. Since there’s little chance of misusing an internet translator
    with gt’s one simple message, I’ll just look it up myself and set the `msgstr`
    field at the bottom of the file to `"Bonjour le monde!\n"`.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 该过程的下一步是实际翻译文件。通常，我会找一个英语水平不错的法语母语者，让他们帮我填写空白。由于`gt`的简单消息几乎不可能误用互联网翻译工具，所以我自己查找并将文件底部的`msgstr`字段设置为`"Bonjour
    le monde!\n"`。
- en: 'Once translated, the *.po* file is passed through the `msgfmt` utility to create
    the locale-specific *message object* (*.mo*) file. Let’s do this for *fr.po*:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 翻译完成后，*.po*文件会通过`msgfmt`工具生成地区特定的*消息对象*（*.mo*）文件。让我们为*fr.po*做这个：
- en: '[PRE6]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: There are lots of options you can use with `msgfmt`. For our example, the default
    functionality is quite sufficient. Still, I specified the output file (with `-o`)
    because the default output file is *messages.mo* and I wanted to be clear that
    this is the French language message file.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: '`msgfmt`有很多选项可以使用。对于我们的例子，默认的功能已经足够。尽管如此，我仍然指定了输出文件（使用`-o`），因为默认的输出文件是*messages.mo*，而我想明确说明这是法语的消息文件。'
- en: To test our French message catalog, we could copy *fr.mo* over to */usr/local/share/locale/fr/LC_MESSAGES/gt.mo*
    as root and then execute `gt` with the `LANGUAGE` variable set to `fr`, but a
    simpler way is to use that hack I added to gt that lets us build a version that
    treats the current directory as the `localedir`.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 为了测试我们的法语消息目录，我们可以将*fr.mo*复制到*/usr/local/share/locale/fr/LC_MESSAGES/gt.mo*，然后以root身份执行`gt`，并将`LANGUAGE`变量设置为`fr`，但更简单的方法是使用我为`gt`添加的一个小技巧，这让我们可以构建一个将当前目录视为`localedir`的版本。
- en: '**NOTE**'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*I named the output file* fr.mo, *but the installed message file must be named
    after the project’s or program’s message domain*—gt *in this case*—*so during
    installation* fr.mo *should be renamed to* gt.mo. *It’s installed into a language-specific
    subdirectory of `localedir`, so the French nature of the* .mo *file is maintained
    after installation by virtue of its location in the filesystem.*'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: '*我将输出文件命名为* fr.mo，*但安装的消息文件必须根据项目或程序的消息域命名*——在此案例中是gt——*因此，在安装时* fr.mo *应该重命名为*
    gt.mo。*它被安装到`localedir`的特定语言子目录中，因此通过文件系统中的位置，.mo文件的法语特性在安装后得以保持。*'
- en: 'First, let’s install our *fr.mo* file locally and then rebuild `gt` so that
    it looks in the current directory rather than the system data directory. Then
    we’ll run `gt` with English and French locales, as follows:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们本地安装*fr.mo*文件，然后重新构建`gt`，使其查找当前目录而不是系统数据目录。然后，我们将以英语和法语地区设置运行`gt`，如下所示：
- en: '[PRE7]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'This console example should raise a few concerns: Why did I use `LANGUAGE`
    rather than `LC_ALL`? How was I able to use `french` instead of `fr` as the value
    of `LANGUAGE` without causing `gt` heartache while searching for the French version
    of *gt.mo*?'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 这个控制台示例应该引发一些疑问：为什么我使用`LANGUAGE`而不是`LC_ALL`？我怎么能用`french`而不是`fr`作为`LANGUAGE`的值而不引发`gt`在寻找法语版本的*gt.mo*时的麻烦？
- en: To answer the first question, I cannot use the `LC_*` or `LANG` variables here,
    because I don’t have any French locales installed on my system and these variables
    merely set the locale, leaving `textdomain` and `bindtextdomain` to determine
    the locale based on queries to the structure returned by `localeconv` (or, rather,
    a more extensive internal form of that structure) in the C library. Because I
    don’t have any French locales installed, `setlocale` will not be able to set a
    locale based on the values of the `LANG` or `LC_*` variables, so it will simply
    leave the current global locale set to the system default—English, on my host.
    Therefore, the language used will continue to be English.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 为了回答第一个问题，我在这里不能使用`LC_*`或`LANG`变量，因为我的系统上没有安装任何法语区域，且这些变量仅用于设置区域，剩下的`textdomain`和`bindtextdomain`则根据`localeconv`（或者更准确地说，是该结构的一个更广泛的内部形式）返回的结构来确定区域。由于我没有安装任何法语区域，`setlocale`无法根据`LANG`或`LC_*`变量的值设置区域，因此它会将当前全局区域保持为系统默认的区域——在我的主机上是英语。因此，使用的语言将继续是英语。
- en: The answer to the second question brings us back to an as yet unproven statement
    I made in “Language Selection” on [page 332](ch12.xhtml#page_332), where I said
    that the *value* the user sets in the `LANGUAGE` variable has some impact on the
    selection criteria used by `textdomain` and `bindtextdomain`. The *gettext* library
    allows the user to select *fallback* message catalogs when a requested locale
    is not available on the system. This is done by being *less specific* in the `LANGUAGE`
    variable (which is specifically used by `textdomain` and `bindtextdomain`) than
    in the other variables, which are examined by `setlocale`. The value format supported
    by `LANGUAGE` can exactly duplicate the strict format required in `LC_*` and `LANG`,
    but it also supports locale names with missing components and language aliases.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 对第二个问题的回答将我们带回到我在《语言选择》一节中所做的一个尚未被证明的陈述，在[第332页](ch12.xhtml#page_332)中，我提到用户在`LANGUAGE`变量中设置的*值*对`textdomain`和`bindtextdomain`使用的选择标准有一定的影响。*gettext*库允许用户在请求的区域在系统中不可用时选择*后备*消息目录。这是通过在`LANGUAGE`变量中比在其他变量中使用更*不具体*的值来实现的，后者是`setlocale`检查的变量。`LANGUAGE`支持的值格式可以完全复制`LC_*`和`LANG`中要求的严格格式，但它也支持带有缺失组件的区域名称和语言别名。
- en: 'First, let’s consider what I mean by missing components. Recall the components
    of a locale name:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们考虑一下我所说的缺失组件是什么意思。回想一下区域名称的组件：
- en: '[PRE8]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The `bindtextdomain` function attempts to find message catalogs in the specified
    locale directories that match this entire format, as specified either in the `LANGUAGE`
    variable or in the current locale string, as provided by `localeconv`. But then
    it backs off by dropping first the *`codeset`*, then a normalized form of the
    *`codeset`*,^([3](footnote.xhtml#ch12fn3)) then the *`territory`*, and finally
    the *`modifier`*. If all components are dropped, we’re left with just the *`language`*
    portion of the locale name (or whatever other random text was specified in `LANGUAGE`).
    If a match still cannot be found, `bindtextdomain` then looks at the */usr/share/locale/locale.alias*
    file for an alias matching the value in `LANGUAGE` (`french` is an alias on my
    system for `fr_FR.ISO-8859-1`). This algorithm allows users to be rather vague
    about which message catalog they want to use and still obtain one that’s reasonably
    close to their native language, if an exact match for the current locale is not
    available.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: '`bindtextdomain`函数尝试在指定的区域目录中找到与此完整格式匹配的消息目录，该格式由`LANGUAGE`变量或`localeconv`提供的当前区域字符串指定。然后它会退回，首先去掉*`codeset`*，然后是*`codeset`*的标准化形式^[3](footnote.xhtml#ch12fn3)，接着是*`territory`*，最后是*`modifier`*。如果所有组件都被去除，我们将只剩下区域名称的*`language`*部分（或者在`LANGUAGE`中指定的任何其他随机文本）。如果仍然找不到匹配项，`bindtextdomain`会查看*/usr/share/locale/locale.alias*文件，寻找与`LANGUAGE`中值匹配的别名（在我的系统上，`french`是`fr_FR.ISO-8859-1`的别名）。这个算法允许用户在选择消息目录时比较模糊，甚至在没有完全匹配当前区域的情况下，仍然能获取到一个相对接近其母语的消息目录。'
- en: Integrating gettext with the Autotools
  id: totrans-57
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 将gettext与Autotools集成
- en: Up to this point in this chapter, I’ve been building little utilities and programs
    like `gt` by just using `gcc` from the command line. Now it’s time to turn gt
    into an Autotools project so we can add *Native Language Support (NLS)* functionality
    in the manner the GNU project recommends. It’s really best to go this route, because
    it allows translators out there—people who love to do this sort of thing, and
    who like your program—to more easily add a message catalog for their language.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，本章中我一直在通过命令行使用`gcc`构建像`gt`这样的简单工具和程序。现在是时候将`gt`转变为一个Autotools项目，以便我们可以按照GNU项目推荐的方式添加*本地语言支持（NLS）*功能。实际上，走这条路是最好的，因为它允许那些喜欢做这类事情、并且喜欢你程序的翻译人员更轻松地为他们的语言添加消息目录。
- en: The information in this section was mostly taken from Section 13, “The Maintainer’s
    View,” of the *GNU gettext Utilities Manual*.^([4](footnote.xhtml#ch12fn4)) The
    *gettext* manual is a little out-of-date with respect to the Autotools and even
    the *gettext* package itself, but it’s otherwise well organized and very detailed
    on the topics of internationalization and localization. In fact, it’s so complete
    that it’s hard to get your head around it until you have some of the basics behind
    you. My goal in this chapter is to give you the background you need to dig into
    the *gettext* manual without fear. In fact, this chapter only lightly brushes
    over many topics that the manual covers in great detail.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 本节中的信息大部分摘自*GNU gettext工具手册*的第13节，“维护者视角”。^([4](footnote.xhtml#ch12fn4)) 由于涉及Autotools以及*gettext*包本身，*gettext*手册的内容有些过时，但它在国际化和本地化的主题上组织得很好，且非常详细。事实上，它内容如此全面，以至于在掌握一些基础知识之前很难完全理解。我的目标是在本章中提供你需要的背景，以便你可以毫无畏惧地深入阅读*gettext*手册。实际上，本章仅轻微地涉及了手册中详细阐述的许多话题。
- en: 'Let’s move *gt.c* into a project *src* directory and create *configure.ac*,
    *Makefile.am*, and the other GNU-mandated text files. Assuming you’re in the directory
    where our original *gt.c* file was created, do the following:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们将*gt.c*文件移动到项目的*src*目录中，并创建*configure.ac*、*Makefile.am*以及其他GNU要求的文本文件。假设你当前位于原始*gt.c*文件所在的目录，执行以下操作：
- en: Git tag 12.0
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: Git 标签 12.0
- en: '[PRE9]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The *Makefile.am* file should look like the one shown in [Listing 12-1](ch12.xhtml#ch12ex1).
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: '*Makefile.am*文件应与[清单 12-1](ch12.xhtml#ch12ex1)中所示的文件相似。'
- en: '[PRE10]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '*Listing 12-1:* Makefile.am: *The initial contents of this Automake input file*'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 12-1:* Makefile.am: *此Automake输入文件的初始内容*'
- en: I’ve added target-specific `CPPFLAGS` to allow me to pass the `LOCALE_DIR` on
    the compiler command line. We should also edit our *src/gt.c* file and add the
    *config.h* header file to it so we’ll have access to the `LOCALE_DIR` variable
    we’re defining in there. [Listing 12-2](ch12.xhtml#ch12ex2) shows the changes
    we need to make. You can also remove the `TEST_L10N` hack; we will no longer need
    this because we can test Autotools-built `gt` using a local installation.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 我添加了特定于目标的`CPPFLAGS`，以便我可以在编译命令行中传递`LOCALE_DIR`。我们还应该编辑我们的*src/gt.c*文件，并向其中添加*config.h*头文件，这样我们就可以访问我们在其中定义的`LOCALE_DIR`变量。[清单
    12-2](ch12.xhtml#ch12ex2)显示了我们需要进行的更改。你还可以删除`TEST_L10N`的临时代码；我们将不再需要这个，因为我们可以通过本地安装来测试Autotools构建的`gt`。
- en: '[PRE11]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '*Listing 12-2:* src/gt.c: *Changes required to configure the `LOCALE_DIR`*'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 12-2:* src/gt.c: *配置`LOCALE_DIR`所需的更改*'
- en: Now edit the new *configure.ac* file and make the changes shown in [Listing
    12-3](ch12.xhtml#ch12ex3).
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 现在编辑新的*configure.ac*文件，并进行[清单 12-3](ch12.xhtml#ch12ex3)中所示的更改。
- en: '[PRE12]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '*Listing 12-3:* configure.ac: *Changes necessary to the `autoscan`-generated*
    .scan *file*'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 12-3:* configure.ac: *对`autoscan`生成的*.scan*文件所需的更改*'
- en: Note that some header file references were removed in the `AC_CHECK_HEADERS`
    line in [Listing 12-3](ch12.xhtml#ch12ex3).
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，在[清单 12-3](ch12.xhtml#ch12ex3)中的`AC_CHECK_HEADERS`行中，删除了一些头文件引用。
- en: 'At this point, you should be able to execute `autoreconf -i`, followed by `configure`
    and `make` to build `gt`:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 到此为止，你应该能够执行`autoreconf -i`，然后执行`configure`和`make`来构建`gt`：
- en: '[PRE13]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '**NOTE**'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*I created the m4 directory before running *`autoreconf`* because *`autoreconf`*
    complains about m4 not being present when it finds *`AC_CONFIG_MACRO_DIRS`* in*
    configure.ac. *It still works, but warns you that the directory is missing. Creating
    it in advance just reduces noise.*'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: '*我在运行*`autoreconf`*之前创建了m4目录，因为*`autoreconf`*在找到*`AC_CONFIG_MACRO_DIRS`*时会抱怨m4目录不存在。*它仍然可以工作，但会警告你该目录丢失。提前创建它只是为了减少噪音。*'
- en: The first step in enhancing an existing Autotools project for NLS support with
    *gettext* is to add a bunch of *gettext*-specific files to your project. It’s
    actually kind of tedious, so the *gettext* people have created a little utility
    called `gettextize` that works pretty well. When you run `gettextize`, it does
    a small amount of analysis, dumps a bunch of files into your project’s *po* directory
    (it creates one if it’s not there yet), and then displays a six- or seven-step
    procedure on your console. To ensure you don’t ignore this output, it waits until
    you press enter to terminate the program, obtaining from you in the process a
    promise that you’ll read and perform those steps. Sadly, the instructions are
    a little out-of-date—not all of them are actually necessary, and some of them
    don’t apply if you’re using the full Autotools suite. Like many programs that
    integrate with the Autotools, *gettext* was written to be usable by packages that
    use Autoconf alone and by programs that use the full Autotools suite. I’ll explain
    which ones are important as we go.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 在增强现有的Autotools项目以支持NLS和*gettext*时，第一步是将一堆*gettext*特定的文件添加到你的项目中。这其实是一个相当繁琐的过程，因此*gettext*团队创建了一个叫做`gettextize`的小工具，它工作得相当不错。当你运行`gettextize`时，它会进行一些小的分析，将一堆文件丢到项目的*po*目录中（如果还没有的话，它会创建一个），然后在控制台显示一个六到七步的过程。为了确保你不会忽略这个输出，它会等你按回车键终止程序，并在过程中获得你承诺阅读并执行这些步骤。不幸的是，这些指示有点过时——并非所有步骤都是必需的，而且如果你使用的是完整的Autotools套件，有些步骤甚至不适用。像许多与Autotools集成的程序一样，*gettext*是为了仅使用Autoconf的包和使用完整Autotools套件的程序而编写的。我会在接下来的内容中解释哪些步骤是重要的。
- en: 'Let’s start by running `gettextize` on our gt project directory:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从在我们的gt项目目录中运行`gettextize`开始：
- en: Git tag 12.1
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: Git标签 12.1
- en: '[PRE14]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The first thing `gettextize` does is create a *po* subdirectory (at ➊) in the
    root of our project directory, if needed. This will be where all the NLS-related
    files are kept and managed by an NLS-specific makefile, which `gettextize` also
    provides, as you can see from the third `Copying file` message found in the first
    few lines of the output.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: '`gettextize`做的第一件事是创建一个*po*子目录（在➊位置）在我们的项目根目录中，如果需要的话。这里将保存所有与NLS相关的文件，并由一个特定于NLS的makefile进行管理，`gettextize`也提供了这个makefile，正如你可以从输出的前几行中看到的第三条`Copying
    file`消息。'
- en: After copying files from your system’s *gettext* installation folder to the
    *po* directory, it then updates the root-level *Makefile.am* file and *configure.ac*
    (at ➋). [Listings 12-4](ch12.xhtml#ch12ex4) and [12-5](ch12.xhtml#ch12ex5) show
    the changes it makes to these files.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 在将文件从系统的*gettext*安装文件夹复制到*po*目录后，接着它会更新根目录的*Makefile.am*文件和*configure.ac*（在➋位置）。[Listings
    12-4](ch12.xhtml#ch12ex4)和[12-5](ch12.xhtml#ch12ex5)展示了它对这些文件所做的更改。
- en: '[PRE15]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '*Listing 12-4:* Makefile.am: *Changes to this file made by `gettextize`*'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: '*Listing 12-4:* Makefile.am: *`gettextize`对该文件的更改*'
- en: A `SUBDIRS` variable is added (or updated, if one exists) to the top-level *Makefile.am*
    file so that *po/Makefile* will be processed by `make`, and `AC_LOCAL_AMFLAGS`
    is added to support the *m4* directory, which `gettextize` would have added had
    we not done so first. Finally, `gettextize` adds an `EXTRA_DIST` variable to ensure
    that *config.rpath* gets distributed.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 一个`SUBDIRS`变量被添加（或者如果已存在则更新）到顶级*Makefile.am*文件中，以便`make`会处理*po/Makefile*，并且添加了`AC_LOCAL_AMFLAGS`以支持*m4*目录，这是`gettextize`本应添加的，如果我们没有先这样做的话。最后，`gettextize`会添加一个`EXTRA_DIST`变量，确保*config.rpath*能够被分发。
- en: '**NOTE**'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*Adding *`AC_LOCAL_AMFLAGS = -I m4`* is no longer necessary with later versions
    of Automake, because it provides the *`AC_CONFIG_MACRO_DIRS`* macro, which handles
    this include directive for *`aclocal`* transparently.*'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: '*添加*`AC_LOCAL_AMFLAGS = -I m4`*在Automake的较新版本中不再必要，因为它提供了*`AC_CONFIG_MACRO_DIRS`*宏，能够透明地处理这个包含指令用于*`aclocal`*。*'
- en: I manually changed `$(datadir)`*/locale* to the Autoconf-provided `$(localedir)`
    in the `src_gt_CPPFLAGS` line.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 我手动将`$(datadir)`*/locale*改为Autoconf提供的`$(localedir)`，并更新了`src_gt_CPPFLAGS`行。
- en: '[PRE16]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: '*Listing 12-5:* configure.ac: *Changes to this file made by `gettextize`*'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: '*Listing 12-5:* configure.ac: *`gettextize`对该文件的更改*'
- en: The only change made to *configure.ac* by `gettextize` is to add the *po/**Makefile.in*
    file to the `AC_CONFIG_FILES` file list. An astute reader would notice the *.in*
    on the end of this reference and perhaps believe that `gettextize` had made a
    mistake. Looking back at the list of files copied by the utility shows us, however,
    that the file copied into the *po* directory really is called *Makefile.in.in*.
    Autoconf processes the file first, and then *gettext* utilities process it again
    later to remove the second *.in* extension.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: '`gettextize` 对 *configure.ac* 做的唯一更改是将 *po/**Makefile.in* 文件添加到 `AC_CONFIG_FILES`
    文件列表中。一个敏锐的读者会注意到这个引用的末尾有一个 *.in*，可能会认为 `gettextize` 出了错。然而，回头看看该工具复制的文件列表，我们会发现复制到
    *po* 目录中的文件确实叫做 *Makefile.in.in*。Autoconf 首先处理这个文件，然后 *gettext* 工具再次处理它，去掉第二个
    *.in* 后缀。'
- en: Referring back to the output of `gettextize`, we see at ➌ that `gettextize`
    is asking us to add a macro invocation, `AM_GNU_GETTEXT([external])`, to *configure.ac*.
    This may perhaps seem strange, given that it just finished editing *configure.ac*
    for us. The displayed text isn’t clear on this point, but the fact is, an entire
    copy of the *gettext* runtime used to be added to projects on demand. This line
    is simply telling us that if we do not intend to use such an internal version
    of the *gettext* library, we should indicate so by using the `external` option
    in a call to this macro so that `configure` will know to look outside the project
    for the *gettext* utilities and libraries. As it happens, using an internal version
    of the *gettext* library is no longer generally promoted—mainly because *gettext*
    is now integrated into *libc* (at least on Linux systems), so everyone has ready
    access to an external version of *gettext*. If you’re using another type of system
    with GNU tools, you should install the *gettext* package so you can use that external
    version.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 回到 `gettextize` 的输出，我们看到在 ➌ 处，`gettextize` 正在要求我们在 *configure.ac* 中添加一个宏调用，`AM_GNU_GETTEXT([external])`。这可能看起来很奇怪，因为它刚刚为我们编辑了
    *configure.ac*。显示的文本在这一点上并不清楚，但实际上，曾经有一个完整的 *gettext* 运行时是根据需求添加到项目中的。这一行只是告诉我们，如果我们不打算使用这种内部版本的
    *gettext* 库，我们应该通过在调用此宏时使用 `external` 选项来表明这一点，这样 `configure` 就会知道去项目外部查找 *gettext*
    工具和库。实际上，使用 *gettext* 库的内部版本现在一般不再推荐——主要是因为 *gettext* 现在已经集成到了 *libc* 中（至少在 Linux
    系统上是这样），因此每个人都可以轻松访问外部版本的 *gettext*。如果你使用的是另一种类型的系统，并且使用 GNU 工具，你应该安装 *gettext*
    包，以便使用那个外部版本。
- en: I noticed also when I added this macro that `autoreconf` complained that I was
    using `AM_GNU_GETTEXT` but not `AM_GETTEXT_VERSION`, which indicates to the build
    system the lowest allowable version of *gettext* that may be used with this project.
    I added this macro as well, with a version value corresponding to the output of
    `gettext --version` on my system. I might have used a lower version value to allow
    my project to build on other, perhaps older systems, but I’d have had to do a
    bit of research to ensure that all the options I used were valid back to the version
    I chose to use.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 我还注意到，当我添加这个宏时，`autoreconf` 报告我使用了 `AM_GNU_GETTEXT` 但没有使用 `AM_GETTEXT_VERSION`，它会告诉构建系统可以与此项目一起使用的
    *gettext* 最低版本。我也添加了这个宏，并设置了与我系统中 `gettext --version` 输出相对应的版本值。我本可以使用一个较低的版本值，以便让我的项目能够在其他可能较旧的系统上构建，但我必须做些研究以确保我使用的所有选项在我选择的版本下都是有效的。
- en: '[Listing 12-6](ch12.xhtml#ch12ex6) shows this addition to *configure.ac*.'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: '[列表 12-6](ch12.xhtml#ch12ex6) 显示了对 *configure.ac* 的这次添加。'
- en: '[PRE17]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: '*Listing 12-6:* configure.ac: *Adding `AM_GNU_GETTEXT`*'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 12-6:* configure.ac: *添加 `AM_GNU_GETTEXT`*'
- en: The next step, at ➍, indicates that we should copy *po/Makevars.template* to
    *po/Makevars* and edit it to ensure the values are correct. I say “copy” rather
    than “move” because removing the template will just cause it to be replaced the
    next time you run `autoreconf -i` anyway, so there’s no point in being pedantic
    about it.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步，在➍中，表示我们应该将 *po/Makevars.template* 复制到 *po/Makevars* 并编辑它以确保值是正确的。我说“复制”而不是“移动”，因为移除模板会导致它在下次运行
    `autoreconf -i` 时被替换掉，所以对这点纠结没有意义。
- en: '[Listing 12-7](ch12.xhtml#ch12ex7) shows a pared-down version of this file—I’ve
    removed the comments so we can more easily see the functional content, but the
    comments are extensive and really quite useful, so please do examine the full
    file.'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: '[列表 12-7](ch12.xhtml#ch12ex7) 显示了该文件的精简版——我删除了注释，这样我们可以更容易地看到功能性内容，但注释非常详尽且非常有用，所以请一定查看完整的文件。'
- en: '[PRE18]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: '*Listing 12-7:* po/Makevars.template: *A list of variables that control the
    NLS build*'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 12-7:* po/Makevars.template: *控制 NLS 构建的变量列表*'
- en: I’ve highlighted the changes I made to gt’s version of this file. As you can
    see, the defaults are mostly just fine. I changed the copyright holder from the
    default, `Free Software Foundation`. I’ve also indicated that gt is not a GNU
    package—the default here was blank, which tells *gettext* to attempt to figure
    it out at runtime.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 我已突出显示我对gt版本文件所做的更改。如你所见，默认设置大多数情况下是没问题的。我将版权持有者从默认的`Free Software Foundation`更改为其他名称。我还指出，gt不是GNU包——这里的默认值是空白，这意味着*gettext*会尝试在运行时确定该信息。
- en: I’ve specified a value for `MSGID_BUGS_ADDRESS`, which is a value in the generated
    *.pot* file. The value generate by the *po* directory’s makefile will be the email
    address (or web link) you specify here. Finally, I’ve set `PO_DEPENDS_ON_POT`
    to `no` because otherwise, anytime the *gt.pot* file changes in insignificant
    ways, the locale-specific *.po* files all get regenerated, and I’d rather just
    generate the *.po* files in my project when a distribution is created. This is
    an arbitrary decision based on personal preference; you can choose to leave it
    at its default value of `yes`, if you want.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 我为`MSGID_BUGS_ADDRESS`指定了一个值，这是生成的*.pot*文件中的一个值。*po*目录的makefile生成的值将是你在此处指定的电子邮件地址（或网页链接）。最后，我将`PO_DEPENDS_ON_POT`设置为`no`，因为否则，每当*gt.pot*文件发生细微变化时，所有特定语言环境的*.po*文件都会重新生成，而我更倾向于仅在创建分发包时生成我的项目中的*.po*文件。这是一个基于个人偏好的任意决定；如果你愿意，也可以选择保留其默认值`yes`。
- en: At ➎, we see a request to add some text to *po/POTFILES.in*. This is a result
    of Automake’s requirement that all source files be specified in makefiles. We’re
    being asked to add all of the source files that must be processed by `xgettext`
    to extract messages. Files may be added one per line, and comments starting with
    a hash (`#`) mark may be used in this file if desired. [Listing 12-8](ch12.xhtml#ch12ex8)
    highlights what I’ve added to gt’s version of *po/POTFILES.in*.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 在➎处，我们看到要求向*po/POTFILES.in*添加一些文本。这是Automake要求在makefile中指定所有源文件的结果。我们被要求添加所有必须由`xgettext`处理的源文件，以提取消息。文件可以一行一行地添加，如果需要，该文件中可以使用以井号（`#`）开头的注释。[Listing
    12-8](ch12.xhtml#ch12ex8)突出显示了我对gt版本的*po/POTFILES.in*所做的更改。
- en: '[PRE19]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: '*Listing 12-8:* po/POTFILES.in: *Changes made to the generated version of this
    file*'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: '*Listing 12-8:* po/POTFILES.in: *对该文件生成版本所做的更改*'
- en: The files listed in *po/POTFILES.in* should be relative to the project directory
    root.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: '*po/POTFILES.in*中列出的文件应该相对于项目目录根目录。'
- en: The steps listed at ➏ and ➐ are no longer necessary with late versions of the
    Autotools. The `configure` script will automatically run `aclocal` and rebuild
    itself for you when you execute it, if necessary. The *config.sub* and *config.guess*
    files are now automatically installed by `autoreconf` based on the use of the
    *gettext* macros. Unfortunately, `autoreconf` installs the versions of these files
    that ship with Autoconf; they’re likely out-of-date, so the advice to find and
    install the latest versions is still valid. If you need to, you can pull the latest
    versions of these files from the GNU Savannah *config* repository using the supplied
    `wget` commands. You’ll know if you need to if *gettext* has problems figuring
    out your platform using the ones installed by `autoreconf`. Be sure to run `autoreconf
    -i` at least once more after these steps are completed.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 在➏和➐列出的步骤，在新版本的Autotools中已经不再需要。`configure`脚本在执行时会自动运行`aclocal`并在必要时重新构建自身。*config.sub*和*config.guess*文件现在会由`autoreconf`根据使用*gettext*宏来自动安装。不幸的是，`autoreconf`安装的是与Autoconf一起提供的这些文件版本；它们可能已经过时，因此仍然建议找到并安装最新版本。如果需要的话，可以使用提供的`wget`命令从GNU
    Savannah *config*仓库中获取这些文件的最新版本。如果*gettext*在使用`autoreconf`安装的版本时遇到问题，它可能无法识别你的平台。确保在完成这些步骤后，再运行`autoreconf
    -i`至少一次。
- en: The request to copy and consume *gettext.h* at ➑ is optional but helpful, in
    my opinion, because it enables a `configure` script option added by *gettext*
    Autoconf macros that allows the user to disable NLS processing while building
    from a distribution archive. I copied */usr/share/gettext/gettext.h* into gt’s
    *src* directory and added it to the list of source files for the `gt` program
    in *Makefile.am*, as shown in [Listing 12-9](ch12.xhtml#ch12ex9).
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 在➑处要求复制和使用*gettext.h*是可选的，但在我看来是有帮助的，因为它启用了由*gettext* Autoconf宏添加的`configure`脚本选项，允许用户在从分发档案构建时禁用NLS处理。我将*/usr/share/gettext/gettext.h*复制到gt的*src*目录，并将其添加到`gt`程序在*Makefile.am*中的源文件列表中，如[Listing
    12-9](ch12.xhtml#ch12ex9)所示。
- en: '[PRE20]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: '*Listing 12-9:* Makefile.am: *Adding src/gettext.h to `src_gt_SOURCES`*'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: '*Listing 12-9:* Makefile.am: *将src/gettext.h添加到`src_gt_SOURCES`中*'
- en: 'Let’s try building after all these changes:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在进行所有这些更改后尝试构建：
- en: '[PRE21]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: '**NOTE**'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*Some corner-case conditions may cause files written by *`autoreconf`* to be
    considered “modified locally,” which would generate errors without the *`-f`*
    or *`--force`* flag. I recommend you try it first using only *`-i`*. If you get
    errors about files like* ABOUT-NLS *being modified locally, then re-execute it
    with the *`-f`* flag also. Just be aware that *`-f`* will overwrite some files
    you may have intentionally modified.*'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: '*某些极端情况可能导致由*`autoreconf`*编写的文件被视为“本地修改”，这样没有*`-f`*或*`--force`*标志就会生成错误。我建议你先尝试仅使用*`-i`*。如果你遇到像*ABOUT-NLS*之类的文件被本地修改的错误，那么重新执行时加上*`-f`*标志。只需注意，*`-f`*会覆盖你可能故意修改的某些文件。*'
- en: As you can see from this output, `xgettext` is run against our source code—specifically,
    the files we mentioned in *po/POTFILES.in*—whenever we build, if any of the files
    are missing at build time. If a file is found, it won’t be rebuilt automatically,
    but there is a manual `make` target I’ll mention shortly.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 如你从此输出中看到的那样，`xgettext`会对我们的源代码运行——特别是我们在*po/POTFILES.in*中提到的文件——每当我们进行构建时，如果构建时缺少任何文件。如果找到文件，它不会自动重新构建，但我稍后会提到一个手动的`make`目标。
- en: '*What Should Be Committed?*'
  id: totrans-116
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '*什么应该提交？*'
- en: We’ve added a lot of new files to the gt project. In “A Word About the Utility
    Scripts” on [page 172](ch06.xhtml#page_172), I gave you my philosophy on what
    should be committed to a source repository, which is that people who check out
    your project from its repository should be willing to take on the role of maintainer
    or developer, rather than user. Users build from distribution archives, but maintainers
    and developers use a different set of tools. Therefore, people who check out source
    from repositories should be willing to use the Autotools.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 我们为gt项目添加了很多新文件。在[第172页](ch06.xhtml#page_172)的《关于实用脚本的一些话》中，我给出了关于应提交到源仓库的内容的哲学观点：从仓库中检出你的项目的人应该愿意担任维护者或开发者的角色，而不是用户。用户从发行包中构建，但维护者和开发者使用的是一套不同的工具。因此，从仓库检出源代码的人应该愿意使用Autotools。
- en: It’s now time to consider which of these new files you should commit to gt’s
    repository. Following my philosophy, I would only commit those files that are
    actually assets of the project. Anything that can be easily regenerated or recopied
    from other sources during the Autotools bootstrap process (`autoreconf` `-i`)
    should be left out.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是考虑哪些新文件应该提交到gt的仓库的时候了。按照我的哲学，我只会提交那些实际上是项目资产的文件。任何在Autotools引导过程中（`autoreconf`
    `-i`）可以轻松重新生成或从其他来源重新复制的文件应该被排除在外。
- en: The `gettextize` utility runs a program called `autopoint`, which acts for NLS-enabled
    projects as `autoreconf -i` does for Autotools projects, copying files into the
    project directory structure as needed. The `AM_GETTEXT_*` macros we added to *configure.ac*
    earlier ensure that the appropriate *.m4* files are added to the *m4* directory,
    the appropriate NLS files are added to the *po* directory, and (if you were using
    an internal version of the *gettext* library) the *gettext* source and build files
    are added to the *intl* directory. In fact, `autopoint` is a sort of contraction
    of the phrase *auto-po-intl-m4*.^([5](footnote.xhtml#ch12fn5)) More recent versions
    of `autoreconf` are aware of `autopoint` and will execute it for you if they notice
    you have an NLS-enabled project, but only if you provide the `-i` option to `autoreconf`,
    because `autopoint` only installs missing files and file installation is a function
    of the `-i` option.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: '`gettextize`工具运行一个名为`autopoint`的程序，它对启用了NLS的项目的作用就像`autoreconf -i`对Autotools项目的作用一样，按照需要将文件复制到项目目录结构中。我们之前添加到*configure.ac*中的`AM_GETTEXT_*`宏确保了适当的*.m4*文件被添加到*m4*目录，适当的NLS文件被添加到*po*目录，且（如果你使用的是内部版本的*gettext*库）*gettext*源代码和构建文件被添加到*intl*目录。实际上，`autopoint`是短语*auto-po-intl-m4*的缩写。更新版本的`autoreconf`能够识别`autopoint`，并且会在你使用启用NLS的项目时执行它，但前提是你向`autoreconf`提供了`-i`选项，因为`autopoint`仅安装缺失的文件，而文件安装是`-i`选项的一个功能。'
- en: Because `autopoint` installs all required non-asset files in your *po* directory,
    the only thing you need to commit in that directory are the files you modified,
    including *POTFILES.in*, *Makevars*, *ChangeLog*,^([6](footnote.xhtml#ch12fn6))
    and, of course, your *.po* files. You don’t need to commit your *.pot* file because
    the *po/Makefile* will regenerate that from your source code if it’s missing.
    You don’t need to commit your *.mo* files, as those get generated directly from
    *.po* files at install time. You don’t need the *ABOUT-NLS* file unless you’ve
    modified it. You don’t need anything in the *m4* directory except macro files
    you wrote and added yourself. You will need to commit the *src/gettext.h* file
    since you manually copied that file from your system *gettext* install directory.^([7](footnote.xhtml#ch12fn7))
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 因为 `autopoint` 会将所有需要的非资产文件安装到你的 *po* 目录中，所以你只需要提交该目录中你修改过的文件，包括 *POTFILES.in*、*Makevars*、*ChangeLog*、^([6](footnote.xhtml#ch12fn6))
    以及，当然，你的 *.po* 文件。你不需要提交你的 *.pot* 文件，因为 *po/Makefile* 会根据源代码重新生成它（如果它缺失的话）。你不需要提交
    *.mo* 文件，因为这些文件会在安装时直接从 *.po* 文件生成。除非你修改了 *ABOUT-NLS* 文件，否则你不需要提交它。你不需要提交 *m4*
    目录中的任何文件，除非是你自己编写并添加的宏文件。你需要提交 *src/gettext.h* 文件，因为你是手动从系统的 *gettext* 安装目录中复制的那个文件。^([7](footnote.xhtml#ch12fn7))
- en: 'This leaves us with the following files in gt’s directory structure:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 这时我们在 gt 的目录结构中剩下以下文件：
- en: '[PRE22]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: '*Adding a Language*'
  id: totrans-123
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '*添加语言*'
- en: 'Let’s add our French language *.po* file:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们添加我们的法语 *.po* 文件：
- en: Git tag 12.2
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: Git 标签 12.2
- en: '[PRE23]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: While we do run `msginit`, we don’t need to specify input and output files.
    Rather, `msginit` automatically discovers and uses all *.pot* files in the current
    directory as input files, and it automatically names the output *.po* file after
    the language specified. The only option we need to use is the `--locale` option
    to specify the target locale for which a *.po* file should be generated.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然我们运行了 `msginit`，但无需指定输入和输出文件。相反，`msginit` 会自动发现并使用当前目录中的所有 *.pot* 文件作为输入文件，并且会根据指定的语言自动命名输出的
    *.po* 文件。我们唯一需要使用的选项是 `--locale` 选项，用于指定应该生成 *.po* 文件的目标语言环境。
- en: '**NOTE**'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*I didn’t use the *`--no-translator`* option this time because when I run*
    msginit, *I’m acting in the role of the translator for the target language. That
    is to say, the person who runs *`msginit`* for a given locale or language* should
    *be the translator for that language. Therefore, that person should also be willing
    to provide contact information for the translation, which they can input at the
    interactive prompt for their email address when they run *`msginit`* in this manner.*'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: '*这次我没有使用* `--no-translator` *选项，因为当我运行* msginit *时，我是以目标语言的翻译者身份进行操作。也就是说，运行*
    `msginit` *的人应该是该语言的翻译者。因此，这个人还应该愿意提供翻译联系信息，在这种方式下运行* `msginit` *时，他们可以在交互提示中输入他们的电子邮件地址。*'
- en: We also need to add all supported languages to a file named *LINGUAS* in the
    *po* directory (and this new file should also be committed). This tells the build
    system which languages to support. We may actually have more languages in the
    *po* directory than we currently support. The languages in the *LINGUAS* file
    are those for which *.mo* files will be generated and installed when we run `make
    install`. The format of *LINGUAS* is fairly loose; you only need some sort of
    whitespace between languages. You may also use hash-preceded comments, if you
    want.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要将所有支持的语言添加到 *po* 目录中的名为 *LINGUAS* 的文件中（这个新文件也应该被提交）。这告诉构建系统要支持哪些语言。我们实际上可能在
    *po* 目录中有比当前支持的更多语言。*LINGUAS* 文件中的语言是那些在运行 `make install` 时，将生成并安装 *.mo* 文件的语言。*LINGUAS*
    的格式相当松散；你只需要在语言之间留一些空白。你也可以使用以哈希符号开头的注释，如果你需要的话。
- en: You’ll find a file named *fr.po* in the *po* directory now. Of course, it still
    has to be translated by someone who speaks both languages fairly well. The contents
    should look something like that of [Listing 12-10](ch12.xhtml#ch12ex10) after
    translation. I’ve updated mine, filling in all the blanks, so to speak.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你会在 *po* 目录中找到一个名为 *fr.po* 的文件。当然，这个文件仍然需要由精通两种语言的人翻译。翻译后，内容应该类似于 [示例 12-10](ch12.xhtml#ch12ex10)
    的样子。我已经更新了我的文件，填补了所有空白，可以这么说。
- en: '[PRE24]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: '*Listing 12-10:* po/fr.po: *The translated French portable object file*'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: '*示例 12-10:* po/fr.po: *已翻译的法语可移植对象文件*'
- en: '*Installing Language Files*'
  id: totrans-134
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '*安装语言文件*'
- en: 'Installation of language files is no harder than running `make` with the usual
    Automake-provided `install` target:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 安装语言文件并不比运行带有常规 Automake 提供的 `install` 目标的 `make` 命令更难：
- en: '[PRE25]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: You may also use a `DESTDIR` variable on the `make` command line to test your
    installation in a local staging directory in order to see what gets installed.
    Of course you don’t need `sudo` when you do this, as long as you have write privileges
    in your `DESTDIR` location.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以在 `make` 命令行中使用 `DESTDIR` 变量来测试你的安装在本地临时目录中的效果，以查看哪些文件被安装。当然，在执行此操作时，你不需要使用
    `sudo`，只要你在 `DESTDIR` 目录中有写权限即可。
- en: 'Testing is not quite as simple as executing your program from the *src* directory
    after building, but neither is it that difficult. The problem is the entire Linux
    NLS system is designed to work with installed language files. You’ll need to install
    into a local prefix directory, such as `$PWD`*/root*, for instance:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 测试并不像在 *src* 目录中执行程序那样简单，虽然也不是非常困难。问题在于整个 Linux NLS 系统是为了与已安装的语言文件一起工作而设计的。你需要将文件安装到一个本地前缀目录，例如
    `$PWD`*/root*，例如：
- en: '[PRE26]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Why does this work? Because we’re passing the locale directory, based on `prefix`,
    into *gt.c* in the makefile on the `gcc` command line. Therefore, the `prefix`
    you use tells `gt` where the NLS files will be installed.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么这样有效？因为我们将基于 `prefix` 的语言目录传递给 makefile 中的 *gt.c*，并通过 `gcc` 命令行传递。因此，你使用的
    `prefix` 告诉 `gt` NLS 文件将被安装到哪里。
- en: '**NOTE**'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*Don’t try this with the *`DESTDIR`* variable. The *`prefix`* will still be
    set to* /usr/local, *but the *`install`* target will put everything into *`$(DESTDIR)/$(prefix)`*.
    The locale directory is based only on *`prefix`*, which tricks built software
    into thinking it’s being installed into *`$(prefix)`*, while allowing packagers
    to stage the installation locally.*'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: '*不要在 *`DESTDIR`* 变量上尝试此操作。*`prefix`* 仍然会设置为 /usr/local，但 *`install`* 目标会将所有内容放入
    *`$(DESTDIR)/$(prefix)`* 中。语言目录仅基于 *`prefix`*，这会欺骗已构建的软件，使其认为正在安装到 *`$(prefix)`*
    中，同时允许打包者将安装过程本地化。*'
- en: '*Manual make Targets*'
  id: totrans-143
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '*手动 make 目标*'
- en: The *gettext* makefile provides a couple of targets that can be used manually
    from the *po* directory (in fact, they’ll only work from the *po* directory).
    If you want to manually update one of your *.pot* files, you can run `make` *`domain`*`.update-pot`,
    where *`domain`* is the name of the NLS domain you specified when you called `textdomain`
    and `bindtextdomain` in your source code.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: '*gettext* makefile 提供了一些目标，可以从 *po* 目录手动使用（实际上，它们只在 *po* 目录下有效）。如果你想手动更新某个
    *.pot* 文件，可以运行 `make` *`domain`*`.update-pot`，其中 *`domain`* 是你在源代码中调用 `textdomain`
    和 `bindtextdomain` 时指定的 NLS 域名。'
- en: If you want to update the translated language files using `msgmerge`, which
    will merge new messages from the *.pot* files into the locale-specific *.po* files,
    you can run `make update-po`. This will update all of the *.po* files whose locales
    are specified in *LINGUAS*.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想使用 `msgmerge` 更新翻译后的语言文件，该命令会将来自 *.pot* 文件的新消息合并到特定语言的 *.po* 文件中，你可以运行 `make
    update-po`。这将更新所有在 *LINGUAS* 中指定的语言的 *.po* 文件。
- en: Note that *.mo* files are not created at build time but only at installation
    time. The reason for this is that they’re useless before they’re installed. If
    you really need to have the *.mo* files without installing your package, you can
    install into a local prefix or into a `DESTDIR` staging directory, in the manner
    outlined earlier.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，*.mo* 文件不是在构建时创建的，而是在安装时创建的。原因是，在安装之前它们是没有用的。如果你真的需要在不安装包的情况下获取 *.mo* 文件，你可以将其安装到本地前缀目录或
    `DESTDIR` 临时目录，就像之前所描述的那样。
- en: Summary
  id: totrans-147
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, I barely grazed the surface of the topic of adding NLS support
    to projects.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我只是浅尝辄止地介绍了如何为项目添加 NLS 支持这一主题。
- en: What did I skip? Well, for instance, there are dozens of options in the *gettext*
    tools that help localizers build language files for programs that cause the software
    to display messages sensibly.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 我跳过了什么？例如，*gettext* 工具中有很多选项可以帮助本地化人员为程序构建语言文件，从而使软件能够合理地显示消息。
- en: For another example, in a typical `printf` statement in C, you might provide
    a format string in English such as `"There are %d files in the '%s' directory."`
    In this example, `%d` and `%s` are placeholders for a count and a directory name,
    of course, but in German, the translated string would become something like `"Im
    verzeichnis '%s' befinden sich %d dateien."` Even a non-German-speaking programmer
    can see what’s wrong here—the order of the format specifiers has changed. One
    solution, of course, is to use `printf`’s newer positional format specifiers.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 另外一个例子是，在 C 语言的典型`printf`语句中，你可能会提供一个英语格式字符串，如 `"There are %d files in the '%s'
    directory."` 在这个例子中，`%d`和`%s`是用来替代计数和目录名的占位符，但在德语中，翻译后的字符串会变成类似于 `"Im verzeichnis
    '%s' befinden sich %d dateien."` 甚至一个不懂德语的程序员也能看出问题所在——格式说明符的顺序发生了变化。当然，一种解决方案是使用`printf`更新后的位置格式说明符。
- en: There are dozens of other issues you will want to consider; the *GNU gettext
    Utilities Manual* is a great place to start.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 还有许多其他问题你需要考虑；*GNU gettext 工具手册*是一个很好的起点。
