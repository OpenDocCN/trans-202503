- en: Chapter 5. Let’s Get Functional
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第五章：让我们来了解函数式编程
- en: I’ve mentioned several times that F# is a functional language, but as you’ve
    learned from previous chapters you can build rich applications in F# without using
    any functional techniques. Does that mean that F# isn’t really a functional language?
    No. F# is a general-purpose, multiparadigm language that allows you to program
    in the style most suited to your task. It is considered a functional-first language,
    meaning that its constructs encourage a functional style. In other words, when
    developing in F# you should favor functional approaches whenever possible and
    switch to other styles as appropriate.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 我之前多次提到过 F# 是一种函数式语言，但正如你从前面的章节中学到的，你可以在 F# 中构建丰富的应用程序，而不使用任何函数式技巧。这是否意味着 F#
    并不是真正的函数式语言呢？不是的。F# 是一种通用的多范式语言，允许你以最适合任务的风格进行编程。它被认为是一种函数式优先语言，这意味着它的结构鼓励使用函数式风格。换句话说，在
    F# 中开发时，你应该尽可能倾向于函数式方法，并在合适的情况下切换到其他风格。
- en: In this chapter, we’ll see what functional programming really is and how functions
    in F# differ from those in other languages. Once we’ve established that foundation,
    we’ll explore several data types commonly used with functional programming and
    take a brief side trip into lazy evaluation.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将了解函数式编程的真正含义，以及 F# 中的函数与其他语言中的函数有何不同。一旦我们建立了这一基础，我们将探索几种在函数式编程中常用的数据类型，并简要了解惰性求值。
- en: What Is Functional Programming?
  id: totrans-3
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 什么是函数式编程？
- en: Functional programming takes a fundamentally different approach toward developing
    software than object-oriented programming. While object-oriented programming is
    primarily concerned with managing an ever-changing system state, functional programming
    emphasizes immutability and the application of deterministic functions. This difference
    drastically changes the way you build software, because in object-oriented programming
    you’re mostly concerned with defining classes (or structs), whereas in functional
    programming your focus is on defining functions with particular emphasis on their
    input and output.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 函数式编程在软件开发中采用了与面向对象编程根本不同的方法。面向对象编程主要关注于管理一个不断变化的系统状态，而函数式编程则强调不可变性和确定性函数的应用。这种差异极大地改变了你构建软件的方式，因为在面向对象编程中，你主要关心的是定义类（或结构体），而在函数式编程中，你的重点是定义函数，特别强调它们的输入和输出。
- en: F# is an impure functional language where data is immutable by default, though
    you can still define mutable data or cause other side effects in your functions.
    Immutability is part of the functional concept called *referential transparency*,
    which means that an expression can be replaced with its result without affecting
    the program’s behavior. For example, if you can replace `let sum = add 5 10` with
    `let sum = 15` without otherwise affecting the program’s behavior, then `add`
    is said to be referentially transparent. But immutability and referential transparency
    are only two aspects of functional programming, and they certainly don’t make
    a language functional on their own.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: F# 是一种不纯的函数式语言，其中数据默认是不可变的，尽管你仍然可以定义可变数据或在函数中引起其他副作用。不可变性是函数式编程概念的一部分，称为*参照透明性*，这意味着一个表达式可以被其结果替代，而不影响程序的行为。例如，如果你可以用
    `let sum = 15` 替换 `let sum = add 5 10` 而不影响程序的行为，那么 `add` 被称为具有参照透明性。但不可变性和参照透明性只是函数式编程的两个方面，它们并不会单独让一种语言变成函数式语言。
- en: Programming with Functions
  id: totrans-6
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用函数进行编程
- en: If you’ve never done any “real” functional programming, F# will forever change
    the way you think about functions because its functions closely resemble mathematical
    functions in both structure and behavior. For example, [Chapter 3](ch03.html "Chapter 3. Fundamentals")
    introduced the `unit` type, but I avoided discussing its importance in functional
    programming. Unlike C# and Visual Basic, F# makes no distinction between functions
    that return values and those that don’t. In fact, every function in F# accepts
    exactly one input value and returns exactly one output value. The `unit` type
    enables this behavior. When a function doesn’t have any specific input (no parameters),
    it actually accepts `unit`. Similarly, when a function doesn’t have any specific
    output, it returns `unit`.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你从未进行过任何“真实”的函数式编程，F# 将永远改变你对函数的思考方式，因为它的函数在结构和行为上都与数学函数高度相似。例如，[第 3 章](ch03.html
    "第 3 章. 基础")介绍了 `unit` 类型，但我避开了讨论它在函数式编程中的重要性。与 C# 和 Visual Basic 不同，F# 不区分返回值的函数和不返回值的函数。事实上，F#
    中的每个函数都接受恰好一个输入值并返回恰好一个输出值。`unit` 类型使这种行为成为可能。当一个函数没有特定输入（没有参数）时，它实际上接受 `unit`。类似地，当一个函数没有特定输出时，它返回
    `unit`。
- en: The fact that every F# function returns a value allows the compiler to make
    certain assumptions about your code. One important assumption is that the result
    of the last evaluated expression in a function is the function’s return value.
    This means that although `return` is a keyword in F#, you don’t need to explicitly
    identify return values.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 每个 F# 函数都返回一个值，这一事实使得编译器可以对你的代码做出某些假设。一个重要的假设是函数中最后一个被评估的表达式是函数的返回值。这意味着，虽然
    `return` 是 F# 中的一个关键字，但你不需要明确地标识返回值。
- en: Functions as Data
  id: totrans-9
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 函数作为数据
- en: A defining (and arguably the most important) characteristic of any functional
    language is that it treats functions like any other data type. The .NET Framework
    has always supported this concept to some degree with delegation, but until relatively
    recently delegation was too cumbersome to be viable in all but a few limited scenarios.
    Only when LINQ was introduced with the goodness of lambda expressions and the
    built-in generic delegate types (`Action` and `Func`) did delegation reach its
    full potential. F# uses delegation behind the scenes, but unlike C# and Visual
    Basic, its syntax abstracts away the delegation with the `->` token. The `->`
    token, generally read as “goes to” or “returns,” identifies a value as a *function
    value* where the data type specified on the left is the function’s input type
    and the data type on the right is its return type. For example, the signature
    for a function that both accepts and returns a string is `string -> string`. Similarly,
    a parameterless function that returns a string is represented as `unit -> string`.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 任何函数式语言的一个定义性（也是可能最重要的）特征是它把函数当作任何其他数据类型来处理。虽然 .NET Framework 一直在某种程度上支持这个概念（通过委托），但直到最近，委托由于过于繁琐，几乎只在少数几个有限的场景中可行。直到引入
    LINQ 和 Lambda 表达式的好处，以及内置的泛型委托类型（`Action` 和 `Func`），委托才真正发挥了其全部潜力。F# 在幕后使用委托，但与
    C# 和 Visual Basic 不同，它的语法通过 `->` 符号抽象化了委托。`->` 符号通常读作“传递到”或“返回”，它标识一个值是一个*函数值*，其中左侧指定的数据类型是函数的输入类型，右侧的数据类型是返回类型。例如，一个既接受又返回字符串的函数签名是
    `string -> string`。类似地，一个没有参数并返回字符串的函数表示为 `unit -> string`。
- en: Signatures become increasingly complex when you begin working with *higher-order
    functions*—functions that accept or return other functions. Higher-order functions
    are used extensively in F# (and functional programming in general) because they
    allow you to isolate common parts of functions and substitute the parts that change.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 当你开始使用*高阶函数*（接受或返回其他函数的函数）时，函数签名会变得越来越复杂。高阶函数在 F#（以及函数式编程一般）中被广泛使用，因为它们允许你隔离函数的公共部分，并替换那些会变化的部分。
- en: In some ways, higher-order functions are to functional programming what interfaces
    are to object-oriented programming. For example, consider a function that applies
    a transformation to a string and prints the result. Its signature might look something
    like `(string -> string) -> string -> unit`. This simple notation goes a long
    way toward making your code more comprehensible than when you’re dealing with
    the delegates directly.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 从某种意义上说，高阶函数对函数式编程的意义，就像接口对面向对象编程的意义一样。例如，考虑一个将转换应用于字符串并打印结果的函数。它的签名可能类似于 `(string
    -> string) -> string -> unit`。这个简单的符号大大提高了代码的可理解性，比直接处理委托要容易得多。
- en: Note
  id: totrans-13
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '*You can use the function signatures in type annotations whenever you’re expecting
    a function. As with other data types, though, the compiler can often infer the
    function type.*'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: '*你可以在类型注解中使用函数签名，只要你期待一个函数。和其他数据类型一样，编译器通常能够推断出函数类型。*'
- en: Interoperability Considerations
  id: totrans-15
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 互操作性考虑
- en: Despite the fact that F# functions are ultimately based on delegation, be careful
    when working with libraries written in other .NET languages, because the delegate
    types aren’t interchangeable. F# functions rely on the overloaded `FSharpFunc`
    delegate types, whereas traditional .NET delegates are often based on the `Func`
    and `Action` types. If you need to pass `Func` and `Action` delegates into an
    F# assembly, you can use the following class to simplify the conversion.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管 F# 函数最终是基于委托的，但在与其他 .NET 语言编写的库一起使用时要小心，因为委托类型不能互换。F# 函数依赖于重载的 `FSharpFunc`
    委托类型，而传统的 .NET 委托通常基于 `Func` 和 `Action` 类型。如果你需要将 `Func` 和 `Action` 委托传入 F# 程序集中，可以使用以下类来简化转换。
- en: '[PRE0]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The `FSharpFuncUtil` class defines the overloaded `ToFSharpFunc` method as traditional
    .NET extension methods (via the `ExtensionAttribute` on both the class and methods)
    so you can easily call them from another language. The first overload handles
    converting single-parameter `Func` instances, while the second handles single-parameter
    `Action` instances. These extension methods don’t cover every use case, but they’re
    certainly a good starting point.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: '`FSharpFuncUtil` 类定义了重载的 `ToFSharpFunc` 方法，作为传统的 .NET 扩展方法（通过在类和方法上使用 `ExtensionAttribute`），这样你就可以轻松地从其他语言调用它们。第一个重载处理单参数
    `Func` 实例，而第二个重载处理单参数 `Action` 实例。这些扩展方法并没有覆盖所有使用场景，但它们无疑是一个不错的起点。'
- en: Currying
  id: totrans-19
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 柯里化
- en: Functions in F# work a bit differently than you’re probably accustomed to. For
    example, consider the simple `add` function, introduced in [Chapter 2](ch02.html
    "Chapter 2. F# Interactive").
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: F# 中的函数与你可能习惯的方式有些不同。例如，考虑在[第2章](ch02.html "第2章. F# 交互式")中介绍的简单 `add` 函数。
- en: '[PRE1]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'You might think that `add` accepts two parameters, but that’s not how F# functions
    work. Remember, in F# every function accepts exactly one input and returns exactly
    one output. If you create the preceding binding in FSI or hover over the name
    in Visual Studio, you’ll see that its signature is:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会认为 `add` 接受两个参数，但 F# 函数并不是这样工作的。记住，在 F# 中，每个函数接受恰好一个输入并返回恰好一个输出。如果你在 FSI
    中创建上述绑定或在 Visual Studio 中悬停在名称上，你会看到它的签名是：
- en: '[PRE2]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Here, the name `add` is bound to a function that accepts an integer (`a`) and
    returns a function. The returned function accepts an integer (`b`) and returns
    an integer. Understanding this automatic function chaining—called *currying*—is
    critical to using F# effectively because it enables several other features that
    affect how you design functions.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`add` 被绑定到一个接受整数（`a`）并返回一个函数的函数。返回的函数接受一个整数（`b`）并返回一个整数。理解这种自动的函数链式调用——称为*柯里化*——对于有效使用
    F# 至关重要，因为它启用了多个影响你如何设计函数的其他特性。
- en: To better illustrate how currying actually works, let’s rewrite `add` to more
    closely resemble the compiled code.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更好地说明柯里化是如何工作的，让我们重新编写 `add`，使其更接近编译后的代码。
- en: '[PRE3]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The most significant thing here is that both this and the previous version have
    exactly the same signature. Here, though, `add` accepts only a single parameter
    (`a`) and returns a separate function as defined by a lambda expression. The returned
    function accepts the second parameter (`b`) and invokes the multiplication operator
    as another function call.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 这里最重要的是，这个版本和之前的版本具有完全相同的签名。然而，在这里，`add` 只接受一个参数（`a`）并返回一个由 lambda 表达式定义的独立函数。返回的函数接受第二个参数（`b`）并调用乘法运算符，作为另一个函数调用。
- en: Partial Application
  id: totrans-28
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 部分应用
- en: One of the capabilities unlocked by curried functions is partial application.
    *Partial application* allows you to create new functions from existing ones simply
    by supplying some of the arguments. For example, in the case of `add`, you could
    use partial application to create a new `addTen` function that always adds 10
    to a number.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 柯里化函数解锁的一项功能是部分应用。*部分应用* 允许你通过提供部分参数来从现有函数创建新函数。例如，在 `add` 的情况下，你可以使用部分应用来创建一个新的
    `addTen` 函数，它总是将 10 加到一个数字上。
- en: '[PRE4]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Notice at ① how `addTen`’s definition and signature are listed. Although we
    didn’t explicitly include any parameters in the definition, the signature is still
    a function that both accepts and returns an integer. The compiler evaluated the
    curried `add` function as far as it could with the provided arguments (just `10`,
    in this case) and bound the resulting function to the name, `addTen`.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意在①处如何列出了 `addTen` 的定义和签名。尽管我们在定义中没有明确包括任何参数，但签名仍然是一个接受并返回整数的函数。编译器根据提供的参数（在这种情况下仅为
    `10`）尽可能地计算柯里化的 `add` 函数，并将结果函数绑定到 `addTen` 这个名称上。
- en: Currying applies arguments one at a time, from left to right, so partially applied
    arguments must correspond to the function’s first parameters.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 柯里化一次应用一个参数，从左到右，因此部分应用的参数必须对应于函数的第一个参数。
- en: Warning
  id: totrans-33
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 警告
- en: '*Once you’re comfortable with currying and partial application, you may start
    thinking that you could simulate them in C# or Visual Basic by returning Func
    or Action instances. Don’t. Neither language is designed to support this type
    of functional programming, so simulating these concepts is inelegant at best and
    immensely error prone at worst.*'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: '*一旦你熟悉了柯里化和部分应用，你可能会开始考虑是否可以通过返回 Func 或 Action 实例在 C# 或 Visual Basic 中模拟它们。不要这么做。这两种语言并不支持这种类型的函数式编程，因此模拟这些概念充其量是笨拙的，最糟糕的情况下极容易出错。*'
- en: Pipelining
  id: totrans-35
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 管道化
- en: Another feature often associated with currying (and used extensively in F#)
    is pipelining. *Pipelining* allows you to create your own function chains by evaluating
    one expression and sending the result to another function as the final argument.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 与柯里化（currying）常常关联的另一个特性（并在 F# 中广泛使用）是管道化（pipelining）。*管道化*允许你通过计算一个表达式并将结果作为最终参数传递给另一个函数，来创建自己的函数链。
- en: Forward Pipelining
  id: totrans-37
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 前向管道化
- en: 'Usually you’ll send values forward to the next function using the *forward
    pipelining operator* (`|>`). If you don’t want to do anything with a function’s
    result when it returns something other than `unit`, you can pipe the result forward
    to the `ignore` function like this:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，你会使用*前向管道化操作符*（`|>`）将值传递给下一个函数。如果你不想对函数返回的结果做任何处理（当它返回的结果不是 `unit` 时），你可以像这样将结果传递给
    `ignore` 函数：
- en: '[PRE5]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Pipelining isn’t restricted to simple scenarios like ignoring a result. As
    long as the last argument of the receiving function is compatible with the source
    function’s return type, you can create complex function chains. For example, suppose
    you have a list of daily temperatures in degrees Fahrenheit and want to find the
    average temperature, convert it to Celsius, and print the result. You could do
    it the old-fashioned, procedural way by defining a binding for each step, or you
    could use pipelining to chain the steps like this:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 管道化不仅限于像忽略结果这样的简单场景。只要接收函数的最后一个参数与源函数的返回类型兼容，你就可以创建复杂的函数链。例如，假设你有一个包含每日温度（以华氏度为单位）的列表，并且你想计算平均温度、将其转换为摄氏度并打印结果。你可以采用传统的过程式方式为每个步骤定义绑定，或者你可以使用管道化将这些步骤链在一起，如下所示：
- en: '[PRE6]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Here the `marchHighTemps` list is piped to the `List` module’s `average` function.
    The `average` function is then evaluated and its result passed on to the `fahrenheitToCelsius`
    function. Finally, the average temperature in Celsius is passed along to `printfn`.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，`marchHighTemps` 列表被传递到 `List` 模块的 `average` 函数。接着，`average` 函数被计算，其结果传递给
    `fahrenheitToCelsius` 函数。最后，摄氏温度的平均值被传递给 `printfn`。
- en: Backward Pipelining
  id: totrans-43
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 反向管道化
- en: Like its forward counterpart, the *backward pipelining operator* (`<|`) sends
    the result of an expression to another function as the final argument, but does
    it from right to left instead. Because it changes precedence within an expression,
    the backward pipelining operator is sometimes used as a replacement for parentheses.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 与前向管道化操作符类似，*反向管道化操作符*（`<|`）将表达式的结果作为最终参数传递给另一个函数，但它是从右到左进行的。由于它改变了表达式中的优先级，反向管道化操作符有时可以替代括号使用。
- en: The backward pipelining operator can change the semantics of your code. For
    instance, in the `fahrenheitToCelsius` example in the previous section, the emphasis
    is on the list of temperatures because that’s what’s listed first. To change the
    semantics to emphasize the output, you could place the `printfn` function call
    ahead of the backward pipelining operator.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 反向管道化操作符可能会改变你代码的语义。例如，在上一节中的 `fahrenheitToCelsius` 示例中，重点放在温度列表上，因为它是首先列出的。若要改变语义以强调输出，你可以将
    `printfn` 函数调用放在反向管道化操作符之前。
- en: '[PRE7]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Noncurried Functions
  id: totrans-47
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 非柯里化函数
- en: Although pipelining is typically associated with curried functions, it also
    works with noncurried functions (like methods) that accept only a single argument.
    For instance, to force a delay in execution you could pipe a value into the `TimeSpan`
    class’s static `FromSeconds` method and then send the resulting `TimeSpan` object
    to `Thread.Sleep`, as shown here.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管流水线通常与柯里化函数相关联，但它也适用于仅接受单一参数的非柯里化函数（如方法）。例如，为了强制延迟执行，你可以将一个值传递给 `TimeSpan`
    类的静态 `FromSeconds` 方法，然后将生成的 `TimeSpan` 对象传递给 `Thread.Sleep`，如下所示。
- en: '[PRE8]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Because neither the `TimeSpan` class nor the `Thread` class is defined in F#,
    the functions aren’t curried, but you can see how we can chain these functions
    together with the forward pipelining operator.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 因为 `TimeSpan` 类和 `Thread` 类都没有在 F# 中定义，所以这些函数并未被柯里化，但你可以看到如何使用前向流水线运算符将这些函数链在一起。
- en: Function Composition
  id: totrans-51
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 函数组合
- en: 'Like pipelining, *function composition* allows you to create function chains.
    It comes in two forms: forward (`>>`) and backward (`<<`).'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 与流水线类似，*函数组合*允许你创建函数链。它有两种形式：前向（`>>`）和后向（`<<`）。
- en: Function composition is subject to the same rules as pipelining regarding inputs
    and outputs. Where function composition differs is that instead of defining a
    one-time operation, the composition operators actually generate new functions.
    Continuing with our average temperature example, you could easily create a new
    function from the `List.average` and `fahrenheitToCelsius` functions with the
    forward composition operator.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 函数组合遵循与流水线相同的输入输出规则。函数组合的不同之处在于，组合运算符不仅定义一次性操作，而是生成新的函数。继续使用我们的平均温度示例，你可以使用前向组合运算符轻松地将
    `List.average` 和 `fahrenheitToCelsius` 函数组合成一个新函数。
- en: '[PRE9]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The composition operator results in a new function that accepts a list of floats
    and returns a float. Now, instead of calling the two functions independently,
    you can simply call `averageInCelsius` instead.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 组合运算符会生成一个新的函数，该函数接受一个浮点数列表并返回一个浮点数。现在，你不再需要独立调用这两个函数，而是可以直接调用 `averageInCelsius`。
- en: '[PRE10]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: As with pipelining, you can compose functions from noncurried functions. For
    instance, you could compose the forced delay example from [Noncurried Functions](ch05.html#noncurried_functions
    "Noncurried Functions") as well.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 与流水线一样，你可以将非柯里化函数组合起来。例如，你也可以将强制延迟示例从[非柯里化函数](ch05.html#noncurried_functions
    "Noncurried Functions")中组合起来。
- en: '[PRE11]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: As you might expect, you can now call the `delay` function to temporarily pause
    execution.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所期望的那样，你现在可以调用 `delay` 函数来暂时暂停执行。
- en: '[PRE12]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Recursive Functions
  id: totrans-61
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 递归函数
- en: 'There are typically three looping constructs associated with imperative code:
    `while` loops, simple `for` loops, and enumerable `for` loops. Because each relies
    on a state change to determine when the exit criteria have been met, you’ll need
    to take a different approach to looping when writing purely functional code. In
    functional programming, the preferred looping mechanism is *recursion*. A *recursive
    function* is one that calls itself either directly or indirectly through another
    function.'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 通常与命令式代码相关联的循环构造有三种：`while` 循环、简单的 `for` 循环和可枚举的 `for` 循环。因为每种循环都依赖于状态变化来确定退出条件，所以在编写纯函数式代码时，你需要采取不同的循环方式。在函数式编程中，首选的循环机制是*递归*。*递归函数*是指直接或间接通过另一个函数调用自身的函数。
- en: Although methods within a type are implicitly recursive, `let`-bound functions,
    such as those defined within a module, are not. To make a `let-`bound function
    recursive, you must include the `rec` keyword in its definition, as this factorial
    function illustrates.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管类型内的方法是隐式递归的，但通过 `let` 绑定的函数（如模块内定义的函数）并不是递归的。要使一个 `let` 绑定的函数递归，你必须在其定义中包含
    `rec` 关键字，正如这个阶乘函数所示。
- en: '[PRE13]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The `rec` keyword instructs the compiler to make the function name available
    within the function but does not otherwise change the function’s signature (`int64
    -> int64`).
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: '`rec` 关键字指示编译器在函数内使函数名可用，但不会改变函数的签名（`int64 -> int64`）。'
- en: Tail-Call Recursion
  id: totrans-66
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 尾递归
- en: 'The preceding factorial example is simple, but it suffers from a major flaw.
    For example, consider what happens when you call `factorial 5`. On each recursive
    iteration (other than when the value is 1), the function calculates the product
    of `v` and the factorial of `v - 1`. In other words, calculating the factorial
    for a given value inherently requires each subsequent factorial call to complete.
    At run time, it looks a bit like this:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的阶乘示例很简单，但它存在一个重大缺陷。例如，考虑调用`factorial 5`时会发生什么。在每次递归迭代中（当值不为1时），该函数都会计算`v`与`v
    - 1`的阶乘的乘积。换句话说，为给定值计算阶乘本质上需要每个后续的阶乘调用都完成。运行时，它看起来大致如下：
- en: '[PRE14]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'The preceding snippet shows that each call is added to the stack. It’s unlikely
    that this would be a problem with a factorial function, since the calculation
    can quickly overflow the data type, but more complex recursion scenarios could
    result in running out of stack space. To address this problem, you can revise
    the function to use a *tail call* by removing the dependency on subsequent iterations,
    as shown here:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 上面的代码片段显示了每个调用都会被加入到栈中。对于阶乘函数来说，这不太可能成为问题，因为计算很快就会溢出数据类型，但更复杂的递归场景可能会导致栈空间耗尽。为了解决这个问题，可以通过删除对后续迭代的依赖，将函数修改为使用*尾递归*，如下所示：
- en: '[PRE15]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The revised factorial function ① creates and then calls a nested recursive function,
    `fact` ②, to isolate the implementation details. The `fact` function accepts both
    the current iteration value (`c`) and the product calculated by the previous iteration
    (`p`). At ③ (the nonzero case), the `fact` function makes the recursive call.
    (Notice how only the arguments to the recursive call are calculated here.) Finally,
    to initiate recursion, the `factorial` function ④ invokes the first `fact` iteration,
    passing the supplied value and `1L`.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 修改后的阶乘函数①创建并调用了一个嵌套的递归函数`fact`②，来隔离实现细节。`fact`函数接收当前迭代值（`c`）和前一次迭代计算的积（`p`）。在③（非零情况下），`fact`函数进行递归调用。（注意，递归调用的参数只有在此处计算。）最后，为了启动递归，`factorial`函数④调用第一个`fact`迭代，传入提供的值和`1L`。
- en: Although the recursive call is still present in the code, when the F# compiler
    detects that no iteration is dependent on subsequent iterations, it optimizes
    the compiled form by replacing the recursion with an imperative loop. This allows
    the system to iterate as long as necessary. You can observe this optimization
    by examining the stack traces for each version by inserting a breakpoint and looking
    at the call stack window (if you’re running this as a console application) or
    by printing out the stack information returned from `System.Diagnostics.StackTrace`,
    as shown here. (Note that your namespaces will likely vary.)
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管递归调用仍然存在于代码中，但当F#编译器检测到没有迭代依赖于后续迭代时，它会通过将递归替换为命令式循环来优化编译后的形式。这允许系统根据需要进行迭代。你可以通过插入断点并查看调用栈窗口（如果你以控制台应用程序运行此代码）或打印出从`System.Diagnostics.StackTrace`返回的栈信息来观察这种优化，如下所示。（请注意，你的命名空间可能会有所不同。）
- en: '[PRE16]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Mutually Recursive Functions
  id: totrans-74
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 互递归函数
- en: When two or more functions call each other recursively, they are said to be
    *mutually recursive*. Like mutually recursive types (described in [Chapter 4](ch04.html
    "Chapter 4. Staying Objective")), mutually recursive functions must be defined
    together with the `and` keyword. For example, a Fibonacci number calculation is
    easily expressed through mutual recursion.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 当两个或更多的函数互相递归调用时，它们被称为*互递归*。像互递归类型（在[第4章](ch04.html "第4章. 保持客观")中描述的那样）一样，互递归函数必须一起定义，并使用`and`关键字。例如，斐波那契数的计算可以通过互递归轻松表达。
- en: '[PRE17]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: The preceding `fibonacci` function defines two mutually recursive functions,
    `f` and `g`. (The function keyword inside each is a shortcut for pattern matching.)
    For all values other than 1, `f` calls `g`. Similarly, `g` recursively calls itself
    and `f`.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 上面的`fibonacci`函数定义了两个互递归函数，`f`和`g`。（每个内部的`function`关键字是模式匹配的快捷方式。）对于所有值不为1的情况，`f`调用`g`。类似地，`g`递归地调用自己和`f`。
- en: 'Because the mutual recursion is hidden inside `fibonacci`, consumers of this
    code can simply call `fibonacci` directly. For example, to compute the sixth number
    in the Fibonacci sequence you’d write:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 由于互递归被隐藏在`fibonacci`内部，代码的使用者可以直接调用`fibonacci`。例如，要计算斐波那契数列中的第六个数字，可以这样写：
- en: '[PRE18]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Mutual recursion can be useful, but this example is really only good for illustrating
    the concept. For performance reasons, a more realistic Fibonacci example would
    likely forego mutual recursion in favor of a technique called *memoization*, where
    expensive computations are performed once and the results are cached to avoid
    calculating the same values multiple times.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 互递归可能很有用，但这个例子实际上仅适用于说明概念。出于性能考虑，一个更现实的 Fibonacci 示例可能会放弃互递归，改为使用一种叫做 *备忘录化*
    的技术，其中昂贵的计算只进行一次，结果会被缓存，以避免多次计算相同的值。
- en: Lambda Expressions
  id: totrans-81
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Lambda 表达式
- en: If you’ve ever used LINQ or done any other functional programming, you’re probably
    already familiar with *lambda expressions* (or *function expressions*, as they’re
    sometimes called). Lambda expressions are used extensively in functional programming.
    In brief, they provide a convenient way to define simple, single-use, anonymous
    (unnamed) functions. Lambda expressions are typically favored over let-bound functions
    when the function is significant only within its context (such as when filtering
    a collection).
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你曾经使用过 LINQ 或做过其他函数式编程，你可能已经熟悉 *lambda 表达式*（有时也叫 *函数表达式*）。lambda 表达式在函数式编程中被广泛使用。简而言之，它们提供了一种方便的方式来定义简单的、单次使用的匿名（无名）函数。当函数仅在其上下文中有意义时（例如，在过滤集合时），lambda
    表达式通常比 `let` 绑定的函数更受欢迎。
- en: 'Lambda expression syntax is similar to that of a function value except that
    it begins with the `fun` keyword, omits the function identifier, and uses the
    arrow token (`->`) in place of an equal sign. For example, you could express the
    Fahrenheit-to-Celsius conversion function inline as a lambda expression and immediately
    evaluate it like this:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: Lambda 表达式的语法类似于函数值，只不过它以 `fun` 关键字开头，省略了函数标识符，并且使用箭头符号（`->`）代替等号。例如，你可以将华氏度到摄氏度的转换函数作为
    lambda 表达式内联表示，并立即像这样求值：
- en: '[PRE19]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Although defining ad hoc functions like this is certainly one use for lambda
    expressions, they’re more commonly created inline with calls to higher-order functions,
    or included in pipeline chains.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管像这样定义临时函数确实是 lambda 表达式的一种用途，但它们更常见的是与高阶函数的调用一起内联创建，或者被包含在管道链中。
- en: Closures
  id: totrans-86
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 闭包
- en: '*Closures* enable functions to access values visible in the scope where a function
    is defined regardless of whether that value is part of the function. Although
    closures are typically associated with lambda expressions, nested functions created
    with `let` bindings can be closures as well, since ultimately they both compile
    to either an `FSharpFunc` or a formal method. Closures are typically used to isolate
    some state. For instance, consider the quintessential closure example—a function
    that returns a function that manipulates an internal counter value, as shown here:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: '*闭包*使得函数能够访问在其定义的作用域内可见的值，无论该值是否是函数的一部分。尽管闭包通常与 lambda 表达式相关联，但使用 `let` 绑定创建的嵌套函数也可以是闭包，因为它们最终都会编译为
    `FSharpFunc` 或正式的方法。闭包通常用于隔离某些状态。例如，考虑经典的闭包示例——一个返回能够操作内部计数器值的函数，如下所示：'
- en: '[PRE20]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: The `createCounter` function defines a reference cell that’s captured by the
    returned function. Because the reference cell is in scope when the returned function
    is created, the function has access to it no matter when it’s called. This allows
    you to simulate a stateful object without a formal type definition.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: '`createCounter` 函数定义了一个由返回的函数捕获的引用单元。因为引用单元在返回函数创建时处于作用域内，所以该函数无论何时被调用，都可以访问它。这使得你可以在没有正式类型定义的情况下模拟一个有状态的对象。'
- en: 'To observe the function modifying the reference cell’s value, we just need
    to invoke the generated function and call it like this:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 要观察函数修改引用单元值的过程，我们只需要调用生成的函数，并像这样调用它：
- en: '[PRE21]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Functional Types
  id: totrans-92
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 函数类型
- en: F# includes native support for several additional data types. These types—tuples,
    records, and discriminated unions—are typically associated with functional programming,
    but they’re often useful in mixed-paradigm development as well. While each of
    these types has a specific purpose, they’re all intended to help you remain focused
    on the problem your software is trying to solve.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: F# 原生支持几种额外的数据类型。这些类型——元组、记录和区分联合类型——通常与函数式编程相关联，但它们在混合范式开发中也非常有用。虽然这些类型各有特定的用途，但它们的共同目标是帮助你始终关注你的软件正在解决的问题。
- en: Tuples
  id: totrans-94
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 元组
- en: The most basic functional type is the *tuple*. Tuples are a convenient way to
    group a number of values within a single immutable construct without creating
    a custom type. Tuples are expressed as comma-delimited lists and are sometimes
    enclosed in parentheses. For example, the following two definitions representing
    geometric points as tuples are equally valid.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 最基本的函数式类型是 *元组*。元组是将多个值组合成一个单一不可变结构的便捷方式，而无需创建自定义类型。元组通常表示为以逗号分隔的列表，有时会被括在括号中。例如，下面两个表示几何点的元组定义都是有效的。
- en: '[PRE22]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'The signature for a tuple type includes the type of each value separated by
    an asterisk (`*`). The asterisk is used as the tuple element delimiter for mathematical
    reasons: Tuples represent the Cartesian product of all values their elements contain.
    Therefore, to express a tuple in a type annotation, you write it as an asterisk-delimited
    list of types like this:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 元组类型的签名包括每个值的类型，类型之间用星号（`*`）分隔。星号作为元组元素的分隔符是出于数学原因：元组表示它们元素所包含的所有值的笛卡尔积。因此，要在类型注解中表达元组，你应该将其写成一个以星号分隔的类型列表，如下所示：
- en: '[PRE23]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Despite some syntactic similarities, particularly when the values are enclosed
    in parentheses, it’s important to recognize that other than the fact that they
    contain multiple values, tuples aren’t collections; they simply group a fixed
    number of values within a single construct. The tuple types don’t implement `IEnumerable<'T>`,
    so they can’t be enumerated or iterated over in an enumerable `for` loop, and
    individual tuple values are exposed only through properties with nonspecific names
    like `Item1` and `Item2`.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管在语法上有一些相似之处，尤其是当值被括号括起来时，但重要的是要认识到，除了包含多个值这一点之外，元组并不是集合；它们只是将固定数量的值组合在一个单一的结构中。元组类型并未实现
    `IEnumerable<'T>`，因此不能在可枚举的 `for` 循环中进行枚举或迭代，并且单个元组值只能通过像 `Item1` 和 `Item2` 这样的非特定名称的属性来访问。
- en: Tuples in .NET
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: .NET 中的元组
- en: Tuples have always been part of F# but were only introduced to the larger .NET
    Framework with .NET 4\. Prior to .NET 4, the tuple classes were located in the
    `FSharp.Core` library, but they have since been moved to `mscorlib`. This difference
    is only really important if you intend to write cross-language code against earlier
    versions of the .NET Framework, because it affects which assembly you reference.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 元组一直是 F# 的一部分，但直到 .NET 4 才被引入到更大的 .NET Framework 中。在 .NET 4 之前，元组类位于 `FSharp.Core`
    库中，但它们现在已被移到 `mscorlib`。这个差异只有在你打算编写针对早期版本 .NET Framework 的跨语言代码时才重要，因为它会影响你引用的程序集。
- en: Extracting Values
  id: totrans-102
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 提取值
- en: Tuples are often useful for returning multiple values from a function or for
    sending multiple values to a function without currying them. For instance, to
    calculate the slope of a line you could pass two points as tuples to a `slope`
    function. To make the function work, though, you’ll need some way to access the
    individual values. (Fortunately, tupled values are always accessible in the order
    in which they’re defined, so some of the guesswork is eliminated.)
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 元组常用于从函数返回多个值，或者在不进行柯里化的情况下将多个值传递给函数。例如，计算一条直线的斜率时，你可以将两个点作为元组传递给 `slope` 函数。为了使函数工作，你需要某种方式来访问单独的值。（幸运的是，元组值总是按定义的顺序可以访问，因此减少了很多猜测的工作。）
- en: When working with *pairs* (tuples containing two values like the geometric points
    we discussed previously), you can use the `fst` and `snd` functions to retrieve
    the first and second values, respectively, as shown here.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 在处理 *对偶*（包含两个值的元组，例如我们之前讨论的几何点）时，你可以使用 `fst` 和 `snd` 函数分别获取第一个和第二个值，如此处所示。
- en: '[PRE24]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Notice how we define bindings for the various coordinates with the `fst` and
    `snd` functions. As you can see, however, extracting each value this way can get
    pretty tedious and these functions work only with pairs; if you were to try either
    against a *triple* (a tuple with three values), you’d get a type mismatch. (The
    reason is that at their core, tuples compile to one of the nine generic overloads
    of the `Tuple` class.) Aside from sharing a common name, the tuple classes are
    independent of each other and are otherwise incompatible.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 注意我们如何使用 `fst` 和 `snd` 函数定义不同坐标的绑定。不过，如你所见，以这种方式提取每个值可能会变得相当繁琐，而且这些函数仅适用于对偶（包含两个值的元组）；如果你尝试在
    *三元组*（包含三个值的元组）上使用它们，你会遇到类型不匹配的问题。（原因在于，元组在底层会编译为 `Tuple` 类的九种通用重载之一。）除了共享相同的名称外，元组类相互独立且通常不兼容。
- en: A more practical approach to extract tuple values involves introducing a *Tuple
    pattern*. Tuple patterns allow you to specify an identifier for each value in
    the tuple by separating the identifiers with commas. For example, here’s the `slope`
    function revised to use Tuple patterns instead of the pair functions.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 更实际的提取元组值的方法是引入*元组模式*。元组模式允许你通过用逗号分隔标识符来为元组中的每个值指定一个标识符。例如，这里是修改后的 `slope` 函数，使用元组模式而不是对偶函数。
- en: '[PRE25]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: You can see how Tuple patterns may help, but you need to be careful with them.
    If your pattern doesn’t match the number of values in the tuple, you’ll get a
    type mismatch.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以看到元组模式如何提供帮助，但你需要小心使用它们。如果你的模式与元组中的值数量不匹配，你将得到类型不匹配的错误。
- en: 'Fortunately, unlike the pair functions, resolving the problem is simply a matter
    of adding or removing identifiers. If you don’t care about a particular value
    in your Tuple pattern, you can ignore it with the Wildcard pattern (`_`). For
    instance, if you have three-dimensional coordinates but care only about the z-coordinate,
    you could ignore the x- and y-values as follows:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，不像对偶函数那样，解决这个问题仅仅是添加或删除标识符的问题。如果你不关心元组模式中的某个特定值，可以使用通配符模式（`_`）忽略它。例如，如果你有三维坐标，但只关心
    z 坐标，你可以按如下方式忽略 x 和 y 值：
- en: '[PRE26]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Tuple patterns aren’t limited to `let` bindings. In fact, we can make a further
    revision to the `slope` function and include the patterns right in the function
    signature!
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 元组模式不限于 `let` 绑定。实际上，我们可以进一步修改 `slope` 函数，并直接在函数签名中包含模式！
- en: '[PRE27]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Equality Semantics
  id: totrans-114
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 相等性语义
- en: 'Despite the fact that they’re formally reference types, each of the built-in
    tuple types implements the `IStructuralEquatable` interface. This ensures that
    all equality comparisons involve comparing the individual component values rather
    than checking that two tuple instances reference the same `Tuple` object in memory.
    In other words, two tuple instances are considered equal when the corresponding
    component values in each instance are the same, as shown here:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管它们在形式上是引用类型，但每种内置的元组类型都实现了 `IStructuralEquatable` 接口。这确保了所有的相等性比较都涉及比较每个组件的值，而不是检查两个元组实例是否引用了内存中相同的
    `Tuple` 对象。换句话说，当两个元组实例中对应组件的值相同时，它们被认为是相等的，如下所示：
- en: '[PRE28]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: For the same reasons that the `fst` and `snd` functions work only with pairs,
    comparing tuples of different lengths will cause an error.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 `fst` 和 `snd` 函数仅适用于对偶，比较不同长度的元组将会导致错误。
- en: Syntactic Tuples
  id: totrans-118
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 语法元组
- en: So far, all of the tuples we’ve looked have been concrete ones, but F# also
    includes *syntactic tuples*. For the most part, syntactic tuples are how F# works
    around noncurried functions in other languages. Because F# functions always accept
    a single parameter, but functions in C# and Visual Basic can accept more than
    one, in order to call functions from libraries written in other languages you
    can use a syntactic tuple and let the compiler work out the details.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们查看的所有元组都是具体的元组，但 F# 还包括了*语法元组*。在大多数情况下，语法元组是 F# 处理其他语言中非柯里化函数的方式。因为
    F# 函数总是接受一个参数，而 C# 和 Visual Basic 中的函数可以接受多个参数，为了调用其他语言编写的库中的函数，你可以使用语法元组，让编译器处理细节。
- en: 'For example, the `String` class’s `Format` method accepts both a format string
    and a `params` array of values. If `String.Format` were a curried function, you’d
    expect its signature to be something like `Format : format:string -> params args
    : obj [] -> string`, but it’s not. Instead, if you hover your cursor over the
    function name in Visual Studio, you’ll see that its signature is actually `Format(format:string,
    params args : obj []) : string`. This distinction is significant because it means
    that the arguments must be applied as a group rather than individually as they
    would with curried functions. If you were to try invoking the method as a curried
    F# function, you’d get an error like this:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: '例如，`String` 类的 `Format` 方法同时接受一个格式字符串和一个 `params` 参数数组。如果 `String.Format` 是一个柯里化函数，你会期望它的签名类似于
    `Format : format:string -> params args : obj [] -> string`，但实际并非如此。相反，如果你将鼠标悬停在
    Visual Studio 中的函数名上，你会看到它的签名实际上是 `Format(format:string, params args : obj [])
    : string`。这种区别非常重要，因为它意味着参数必须作为一个整体传递，而不是像柯里化函数那样逐个传递。如果你尝试以柯里化 F# 函数的方式调用这个方法，你将得到类似如下的错误：'
- en: '[PRE29]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'The correct way to call `String.Format` in F# is with a syntactic tuple, like
    this:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 在 F# 中调用 `String.Format` 的正确方式是使用语法元组，如下所示：
- en: '[PRE30]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: You’ve probably noticed that F# generally doesn’t require parentheses around
    arguments when calling a function; it uses parentheses primarily to establish
    precedence. Because functions are applied from left to right, you’ll mainly use
    parentheses in a function call to pass the result of another function as an argument.
    In this case, the parentheses around the arguments are necessary. Without them,
    the left-to-right evaluation would cause the compiler to essentially treat the
    expression as `((System.String.Format "hello {0}"), "Dave")`. In general, it’s
    good practice to include parentheses around syntactic tuples in order to remove
    any ambiguity.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能已经注意到，F# 通常在调用函数时不需要在参数周围加括号；它主要使用括号来确定优先级。由于函数是从左到右应用的，你主要会在函数调用中使用括号来将另一个函数的结果作为参数传递。在这种情况下，参数周围的括号是必要的。没有它们，左到右的求值将导致编译器基本上将表达式当作
    `((System.String.Format "hello {0}"), "Dave")` 处理。一般来说，最好在语法元组周围加上括号，以消除任何歧义。
- en: Out Parameters
  id: totrans-125
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '`out` 参数'
- en: F# doesn’t directly support `out` parameters—parameters passed by reference
    with values assigned in the method body so they can be returned to the caller.
    To fully support the .NET Framework, however, F# needs a way to access `out` parameter
    values. For example, the `TryParse` methods on the various numeric data type classes
    attempt to convert a string to the corresponding numeric type and return a Boolean
    value indicating success or failure. If the conversion succeeds, the `TryParse`
    methods set the `out` parameter to the appropriate converted value. For instance,
    calling `System.Int32.TryParse` with `"10"` would return `true` and set the `out`
    parameter to `10`. Similarly, calling the same function with `"abc"` would return
    `false` and leave the `out` parameter unchanged.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: F# 并不直接支持 `out` 参数——即通过引用传递并在方法体内赋值，以便返回给调用者的参数。为了完全支持 .NET Framework，F# 需要一种方法来访问
    `out` 参数值。例如，多个数值数据类型类中的 `TryParse` 方法尝试将字符串转换为相应的数值类型，并返回一个表示成功或失败的布尔值。如果转换成功，`TryParse`
    方法将 `out` 参数设置为适当的转换值。例如，调用 `System.Int32.TryParse` 并传入 `"10"` 将返回 `true` 并将 `out`
    参数设置为 `10`。类似地，调用相同的函数并传入 `"abc"` 将返回 `false` 并保持 `out` 参数不变。
- en: 'In C#, calling `System.Int32.TryParse` would look like this:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 在 C# 中，调用 `System.Int32.TryParse` 看起来是这样的：
- en: '[PRE31]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: The problem with `out` parameters in a functional language is that they require
    a side effect, as shown by the uninitialized variable at ①. To work around this
    problem, the F# compiler converts the return value and `out` parameter to a pair.
    Therefore, when you invoke a method with an `out` parameter in F#, you treat it
    exactly like any other tuple-returning function.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 在函数式语言中，`out` 参数的问题在于它们需要副作用，正如①处的未初始化变量所示。为了绕过这个问题，F# 编译器将返回值和 `out` 参数转换为一对。因此，当你在
    F# 中调用带有 `out` 参数的方法时，你就像调用任何返回元组的函数一样处理它。
- en: 'Calling the same `Int32.TryParse` method in F# looks like this:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 在 F# 中调用相同的 `Int32.TryParse` 方法看起来是这样的：
- en: '[PRE32]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: For a behind-the-scenes look at the generated class, we can once again turn
    to ILSpy to see how it’s represented in C#.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 要查看生成类的幕后细节，我们可以再次使用 ILSpy 来查看它在 C# 中的表示方式。
- en: '[PRE33]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Here, the F# compiler wrapped the `Int32.TryParse` call inside a static class.
    The generated class’s static constructor ① invokes `TryParse` at ③ and wraps the
    results in a tuple at ②. Then, the internal `v@3` and `r@3` fields are assigned
    to the `out` parameter value and the return value at ④ and ⑤, respectively. In
    turn, the `v` and `r` values defined by the `let` binding are compiled to read-only
    properties that return the `v@3` and `r@3` values.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，F# 编译器将 `Int32.TryParse` 调用封装在一个静态类中。生成的类的静态构造函数 ① 在 ③ 处调用 `TryParse` 并将结果封装在元组中
    ②。然后，内部的 `v@3` 和 `r@3` 字段分别在 ④ 和 ⑤ 处被赋值为 `out` 参数值和返回值。反过来，通过 `let` 绑定定义的 `v`
    和 `r` 值被编译成只读属性，这些属性返回 `v@3` 和 `r@3` 的值。
- en: Record Types
  id: totrans-135
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 记录类型
- en: Like tuples, *record types* allow you to group values in a single immutable
    construct. You might think of them as bridging the functional gap between tuples
    and your own classes. Record types provide many of the same conveniences as tuples,
    like simple syntax and value equality semantics, while offering you some control
    over their internal structure and allowing you to add custom functionality.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 像元组一样，*记录类型*允许你将值组合成一个不可变的结构。你可以把它们看作是在元组和自定义类之间架起的功能性桥梁。记录类型提供了与元组相同的许多便利性，如简单的语法和值相等语义，同时还允许你对其内部结构进行一定控制，并能够添加自定义功能。
- en: Defining Record Types
  id: totrans-137
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 定义记录类型
- en: Record type definitions consist of the `type` keyword, an identifier, and a
    list of labels with type annotations all enclosed in braces. For example, this
    listing shows a simple record type representing an RGB color.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 记录类型定义由`type`关键字、标识符以及所有用大括号括起来的标签与类型注释列表组成。例如，以下列出的是一个表示RGB颜色的简单记录类型。
- en: '[PRE34]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: If you take a peek at what the compiler generates from this definition, you’ll
    see a sealed class with read-only properties, equality semantics, and a single
    constructor to initialize all values.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你查看编译器从这个定义生成的内容，你会看到一个封闭的类，带有只读属性、相等语义以及一个用于初始化所有值的构造函数。
- en: Note
  id: totrans-141
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '*When defining record types on a single line, you must separate each label
    and type annotation pair by semicolons. If you place each pair on a separate line,
    you can safely omit the semicolons.*'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: '*在定义单行记录类型时，必须用分号分隔每个标签和类型注释对。如果将每对标签和类型注释放在单独的一行，则可以安全地省略分号。*'
- en: Creating Records
  id: totrans-143
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 创建记录
- en: New records are created via *record expressions*. Record expressions allow you
    to specify a value for each label in the record type. For example, you could create
    a new `rgbColor` instance using a record expression, as shown next. (Note that,
    as when defining a record type, you must separate each label or assignment pair
    by semicolons or place it on a line of its own.)
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 新的记录是通过*记录表达式*创建的。记录表达式允许您为记录类型中的每个标签指定一个值。例如，您可以使用记录表达式创建一个新的`rgbColor`实例，如下所示。（请注意，与定义记录类型时一样，您必须用分号分隔每个标签或赋值对，或者将其放在单独的一行。）
- en: '[PRE35]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Notice that nowhere in the record expression do we include an explicit reference
    to the `rgbColor` type. This is another example of F#’s type inference engine
    at work. Based on the labels alone, the compiler was able to infer that we were
    creating an instance of `rgbColor`. Because the compiler relies on the labels
    rather than position to determine the correct type, order doesn’t matter. This
    means that you can place the label and value pairs in any order. Here, we create
    an `rgbColor` instance with the labels in `G`, `B`, `R` order.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，在记录表达式中，我们没有包含对`rgbColor`类型的显式引用。这是F#类型推断引擎工作原理的另一个例子。仅凭标签，编译器就能够推断出我们正在创建一个`rgbColor`实例。因为编译器依赖标签而非位置来确定正确的类型，所以顺序不重要。这意味着您可以以任意顺序放置标签和值对。在这里，我们以`G`、`B`、`R`的顺序创建了一个`rgbColor`实例。
- en: '[PRE36]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Unlike with tuples, we don’t need to use special value extraction functions
    like `fst` or `snd` with record types, because each value can be accessed by its
    label. For instance, a function that converts an `rgbColor` value to its hexadecimal
    string equivalent might look like this:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 与元组不同，我们不需要像`fst`或`snd`这样的特殊值提取函数来处理记录类型，因为每个值可以通过它的标签来访问。例如，一个将`rgbColor`值转换为其十六进制字符串等效值的函数可能是这样的：
- en: '[PRE37]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Avoiding Naming Conflicts
  id: totrans-150
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 避免命名冲突
- en: The compiler can usually infer the correct type, but it’s possible to define
    two record types with the same structure. Consider what happens when you add a
    `color` type with the same structure as `rgbColor`.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 编译器通常能够推断出正确的类型，但也可能定义两个具有相同结构的记录类型。考虑一下当你添加一个与`rgbColor`结构相同的`color`类型时会发生什么。
- en: '[PRE38]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Despite having two record types with the same structure, type inference still
    succeeds, but notice at ① that the resulting type is `color`. Due to F#’s top-down
    evaluation, the compiler uses the most recently defined type that matches the
    labels. If your goal was to define `red` as `color` you’d be fine, but if you
    wanted `rgbColor` instead you’d have to be a bit more explicit in your record
    expression and include the type name, as shown here:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管有两个结构相同的记录类型，类型推断仍然成功，但请注意，在①处，生成的类型是`color`。由于F#的自顶向下评估，编译器使用最最近定义的与标签匹配的类型。如果您的目标是将`red`定义为`color`，那是没问题的，但如果您希望使用`rgbColor`，则必须在记录表达式中稍微明确一些，并包括类型名，如下所示：
- en: '[PRE39]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: By qualifying one of the names with the type name at ①, you bypass type inference
    and the correct type is resolved ②. (Although you can technically qualify the
    type on any name, the convention is to do it on either the first one or all of
    them.)
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 通过在①处使用类型名限定其中一个名称，您可以绕过类型推断，正确的类型会在②处被解析。（尽管技术上您可以在任何名称上限定类型，但惯例是只在第一个名称或所有名称上限定类型。）
- en: Copying Records
  id: totrans-156
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 复制记录
- en: 'Not only can you use record expressions to create new record instances from
    scratch, but you can also use them to create new record instances from existing
    ones by copying values forward and setting new values for one or more properties.
    The alternate syntax, called a *copy and update record expression*, makes it easy
    to create yellow from red, as shown here:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 你不仅可以使用记录表达式从头创建新的记录实例，还可以通过将值向前复制并为一个或多个属性设置新值来从现有实例创建新的记录实例。另一种语法，称为*复制和更新记录表达式*，使得从红色创建黄色变得简单，如下所示：
- en: '[PRE40]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: To specify new values for multiple properties, separate them with semicolons.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 要为多个属性指定新值，使用分号分隔它们。
- en: Mutability
  id: totrans-160
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 可变性
- en: 'Like virtually everything else in F#, record types are immutable by default.
    However, because their syntax is so convenient, they’re commonly used in place
    of classes. In many cases, though, these scenarios require mutability. To make
    record type properties mutable within F#, use the `mutable` keyword just as with
    a `let` binding. For instance, you could make all of `rgbColor`’s members mutable
    like this:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 像F#中的几乎所有其他内容一样，记录类型默认是不可变的。然而，由于其语法非常便捷，它们通常被用来代替类。然而，在许多情况下，这些场景要求可变性。为了在F#中使记录类型的属性可变，可以像使用`let`绑定一样使用`mutable`关键字。例如，你可以像这样使`rgbColor`的所有成员变为可变：
- en: '[PRE41]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'When a record type property is mutable, you can change its value with the standard
    assignment operator (`<-`) like this:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 当记录类型的属性是可变的时，你可以像这样使用标准赋值运算符（`<-`）来改变其值：
- en: '[PRE42]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: Climutable
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: Climutable
- en: Although record types support binary serialization by default, other forms of
    serialization require a default constructor and writable properties. To allow
    for more situations where record types can be used in favor of classes, the F#
    team introduced the `CLIMutable` attribute in F# 3.0.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然记录类型默认支持二进制序列化，但其他形式的序列化需要默认构造函数和可写属性。为了在更多情况下使用记录类型代替类，F#团队在F# 3.0中引入了`CLIMutable`属性。
- en: Decorating a record type with this attribute instructs the compiler to include
    a default constructor and to make the generated properties read/write, but the
    compiler doesn’t expose those capabilities within F#. Even though the generated
    properties are writable, unless they’re explicitly marked as mutable with the
    `mutable` keyword in the record type definition, their values can’t be changed
    in F# code. For this reason, be careful when using `CLIMutable` record types across
    language boundaries to ensure that you don’t inadvertently change something.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 使用此属性装饰记录类型会指示编译器包含一个默认构造函数，并使生成的属性可读/可写，但编译器不会在F#中暴露这些功能。即使生成的属性是可写的，除非它们在记录类型定义中明确标记为`mutable`，否则它们的值无法在F#代码中更改。因此，在跨语言边界使用`CLIMutable`记录类型时，要小心以确保不会无意中改变某些内容。
- en: Additional Members
  id: totrans-168
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 附加成员
- en: 'Because record types are really just syntactic sugar for classes, you can define
    additional members just as you would on a class. For example, you could augment
    `rgbColor` with a method that returns its hexadecimal string equivalent like this:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 因为记录类型实际上只是类的语法糖，所以你可以像在类中一样定义附加成员。例如，你可以像这样增加一个方法，使`rgbColor`返回其十六进制字符串等价物：
- en: '[PRE43]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: Now you can call the `ToHexString` method on any `rgbColor` instance.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你可以在任何`rgbColor`实例上调用`ToHexString`方法。
- en: '[PRE44]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Additional members on record types can also be static. For example, suppose
    you wanted to expose a few common colors as static properties on a record type.
    You could do this:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 记录类型上的附加成员也可以是静态的。例如，假设你想将几个常见颜色暴露为记录类型上的静态属性。你可以这样做：
- en: '[PRE45]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: The static `Red`, `Green`, and `Blue` properties behave like any other static
    member and can be used anywhere you need an `rgbColor` instance.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 静态的`Red`、`Green`和`Blue`属性像其他任何静态成员一样，可以在需要`rgbColor`实例的地方使用。
- en: '[PRE46]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: You can also create custom operators for your record types as static members.
    Let’s implement the addition operator to add two `rgbColor` instances.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以为记录类型创建自定义运算符作为静态成员。我们来实现一个加法运算符来添加两个`rgbColor`实例。
- en: '[PRE47]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'The operator overload on `rgbColor` is defined and invoked like any other operator:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 对`rgbColor`的运算符重载像任何其他运算符一样被定义和调用：
- en: '[PRE48]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: Discriminated Unions
  id: totrans-181
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 区别联合
- en: '*Discriminated unions* are user-defined data types whose values are restricted
    to a known set of values called *union cases*. There are no equivalent structures
    in the other popular .NET languages.'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: '*区别联合*是用户定义的数据类型，其值被限制为一组已知的值，称为*联合案例*。其他流行的.NET语言中没有等价的结构。'
- en: At first glance, you might mistake some simple discriminated unions for enumerations
    because their syntax is so similar, but they’re entirely different constructs.
    For one, enumerations simply define labels for known integral values, but they
    aren’t restricted to those values. By contrast, the only valid values for discriminated
    unions are their union cases. Furthermore, each union case can either stand on
    its own or contain associated immutable data.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 刚开始时，你可能会因为语法非常相似而把一些简单的区分联合类型误认为枚举类型，但它们实际上是完全不同的构造。首先，枚举类型仅仅是为已知的整数值定义标签，但它们并不局限于这些值。相比之下，区分联合类型的唯一有效值是它们的联合案例。此外，每个联合案例可以独立存在，或者包含关联的不可变数据。
- en: The built-in `Option<'T>` type highlights each of these points. We’re really
    only interested in its definition here, so let’s take a look at that.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 内置的`Option<'T>`类型突出了这些要点。我们这里只对它的定义感兴趣，因此我们来看一下它的定义。
- en: '[PRE49]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: '`Option<''T>` defines two cases, `None` and `Some`. `None` is an empty union
    case, meaning that it doesn’t contain any associated data. On the other hand,
    `Some` has an associated instance of `''T` as indicated by the `of` keyword.'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: '`Option<''T>`定义了两个案例，`None`和`Some`。`None`是一个空的联合案例，意味着它不包含任何关联的数据。另一方面，`Some`有一个与之关联的`''T`实例，如`of`关键字所示。'
- en: 'To demonstrate how discriminated unions enforce a specific set of values, let’s
    define a simple function that accepts a generic option and writes out the associated
    value when the option is `Some`, or `"None"` when the option is `None`:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 为了演示区分联合类型如何强制执行一组特定的值，让我们定义一个简单的函数，接受一个泛型选项，当选项是`Some`时输出关联的值，或者当选项是`None`时输出`"None"`：
- en: '[PRE50]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'When we invoke this function, we simply need to provide one of the option cases:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们调用这个函数时，我们只需要提供其中一个选项案例：
- en: '[PRE51]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'Notice how in each of the three calls to `showValue`, we specified only the
    union case names. The compiler resolved both `Some` and `None` as `Option<''T>`.
    (In the event of a naming conflict, you can qualify the case names with the discriminated
    union name just as you would with a record type.) However, if you were to call
    `showValue` with a value other than `Some` or `None`, the compiler will raise
    an error like this:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，在对`showValue`的三次调用中，我们只指定了联合案例的名称。编译器将`Some`和`None`都解析为`Option<'T>`。 (如果发生命名冲突，你可以像使用记录类型时一样，使用区分联合类型名称来限定案例名称。)
    然而，如果你用除`Some`或`None`之外的值来调用`showValue`，编译器会抛出如下错误：
- en: '[PRE52]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: Defining Discriminated Unions
  id: totrans-193
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 定义区分联合类型
- en: Like other types, discriminated union definitions begin with the `type` keyword.
    Union cases are delimited with bars. The bar before the first union case is optional,
    but omitting it when there’s only one case can be confusing because it will make
    the definition look like a type abbreviation. In fact, if you omit the bar in
    a single-case discriminated union and there is no data associated with the case,
    the compiler will treat the definition as a type abbreviation when there is a
    naming conflict with another type.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 与其他类型一样，区分联合类型的定义以`type`关键字开头。联合案例之间用竖线分隔。第一个联合案例前的竖线是可选的，但在只有一个案例的情况下省略它可能会引起混淆，因为它会使定义看起来像是类型缩写。事实上，如果在单案例的区分联合类型中省略竖线，并且该案例没有与之关联的数据，当与其他类型发生命名冲突时，编译器会将该定义视为类型缩写。
- en: 'The normal rules for identifiers apply when you are defining union cases, with
    one exception: Union case names must begin with an uppercase letter to help the
    compiler differentiate union cases from other identifiers in pattern matching.
    If a case name does not begin with an uppercase letter, the compiler will raise
    an error.'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 定义联合案例时，标识符的正常规则适用，但有一个例外：联合案例的名称必须以大写字母开头，以帮助编译器在模式匹配中区分联合案例与其他标识符。如果案例名称不是以大写字母开头，编译器会抛出错误。
- en: 'In practice, discriminated unions typically serve one of three purposes:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，区分联合类型通常有三个用途：
- en: Representing simple object hierarchies
  id: totrans-197
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 表示简单的对象层次结构
- en: Representing tree structures
  id: totrans-198
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 表示树形结构
- en: Replacing type abbreviations
  id: totrans-199
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 替代类型缩写
- en: Simple Object Hierarchies
  id: totrans-200
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 简单的对象层次结构
- en: Discriminated unions are commonly used to represent simple object hierarchies.
    In fact, they excel at this task so much that they’re often used as a substitute
    for formal classes and inheritance.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 区分联合类型通常用于表示简单的对象层次结构。实际上，它们在这方面表现得非常出色，以至于它们常常被用作正式类和继承的替代方案。
- en: 'Imagine working on a system that needs some basic geometry functionality. In
    an object-oriented environment, such functionality would probably consist of an
    `IShape` interface and a number of concrete shape classes like `Circle`, `Rectangle`,
    and `Triangle`, with each implementing `IShape`. A possible implementation might
    look like this:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你正在开发一个需要一些基本几何功能的系统。在面向对象的环境中，这些功能可能包括一个 `IShape` 接口和一些具体的形状类，例如 `Circle`、`Rectangle`
    和 `Triangle`，它们都实现了 `IShape` 接口。一个可能的实现如下所示：
- en: '[PRE53]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'Discriminated unions offer a cleaner alternative that is less prone to side
    effects. Here’s what that same object hierarchy might look like as a discriminated
    union:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 被区分的联合类型提供了一种更简洁的替代方案，且不易引发副作用。以下是该对象层次结构在被区分联合类型下可能的样子：
- en: '[PRE54]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: It’s Bigger on the Inside
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 它在内部更大
- en: Discriminated unions are much more complex than their syntax might lead you
    to believe. Each discriminated union compiles to an abstract class responsible
    for handling equality and comparison semantics as well as type checking and union
    case creation. Similarly, each union case compiles to a class that is both nested
    within and inherits from the union class. The union case classes define the properties
    and backing stores for each of their associated values along with an internal
    constructor.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 被区分的联合类型比其语法看起来要复杂得多。每个被区分的联合类型会编译成一个抽象类，负责处理相等性和比较语义、类型检查以及联合情况的创建。类似地，每个联合情况会编译成一个类，既嵌套在联合类内部，又继承自联合类。联合情况类定义了每个关联值的属性和存储，并包含一个内部构造函数。
- en: Although it’s possible to replicate some of the discriminated union functionality
    within other languages, doing so is nontrivial. Proving just how complex discriminated
    unions really are, inspecting the compiled `Shape` type we just defined in ILSpy
    reveals nearly 700 lines of C# code!
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管可以在其他语言中模拟某些被区分联合类型的功能，但这样做并不简单。为了证明被区分联合类型的复杂性，我们在 ILSpy 中检查刚刚定义的 `Shape`
    类型时，发现它竟然生成了近 700 行 C# 代码！
- en: 'The `Shape` type defines three cases: `Circle`, `Rectangle`, and `Triangle`.
    Each case has at least one attached value specific to the shape it represents.
    Notice at ① and ② how the tuple syntax is used to associate multiple data values
    with a case. But despite using the tuple syntax, cases don’t actually compile
    to tuples. Instead, each associated data item compiles to an individual property
    that follows the tuple naming pattern (that is, `Item1`, `Item2`, and so on).
    This distinction is important because there’s no direct conversion from a union
    case to a tuple, meaning that you can’t use them interchangeably. The only real
    exception to this rule is that when the types are wrapped in parentheses the compiler
    will interpret the grouping as a tuple. In other words, the compiler treats `of
    string * int` and `of (string * int)` differently; the former is tuple-like, while
    the latter actually is a tuple. Unless you really need a true tuple, though, use
    the default format.'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: '`Shape` 类型定义了三种情况：`Circle`、`Rectangle` 和 `Triangle`。每种情况都有至少一个与其代表的形状相关联的值。请注意在①和②中，如何使用元组语法将多个数据值与一个情况关联。尽管使用了元组语法，但情况实际上并不会编译成元组。相反，每个关联的数据项会编译成一个独立的属性，并遵循元组命名模式（即
    `Item1`、`Item2` 等）。这一区别很重要，因为从联合情况到元组没有直接的转换，这意味着你不能将它们互换使用。唯一的例外是，当类型被括号包裹时，编译器会将分组解释为元组。换句话说，编译器将
    `of string * int` 和 `of (string * int)` 区别对待；前者是类似元组的，而后者实际上就是元组。不过，除非你确实需要一个真正的元组，否则请使用默认格式。'
- en: 'As you’d expect, creating `Shape` instances is the same as creating `Option<''T>`
    instances. For example, here’s how to create an instance of each case:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所预期的，创建 `Shape` 实例的方式与创建 `Option<'T>` 实例的方式相同。例如，以下是如何创建每个情况的实例：
- en: '[PRE55]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: One of the major annoyances with the tuple syntax for multiple associated values
    is that it’s easy to forget what each position represents. To work around the
    issue, include XML documentation comments—like those preceding each case in this
    section’s `Shape` definition—as a reminder.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 使用元组语法表示多个关联值的一个主要问题是很容易忘记每个位置代表什么。为了解决这个问题，可以在每个情况前面包含 XML 文档注释——就像本节中 `Shape`
    定义前面的注释那样，作为提醒。
- en: Fortunately, relief is available. One of the language enhancements in F# 3.1
    is support for named union type fields. The refined syntax resembles a hybrid
    of the current tupled syntax and type-annotated field definitions. For example,
    under the new syntax, `Shape` could be redefined as follows.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，问题已经得到解决。F# 3.1中的一项语言增强是支持命名联合体类型字段。经过精炼的语法看起来像是当前的元组语法和类型注解字段定义的混合。例如，在新语法下，`Shape`可以重新定义如下。
- en: '[PRE56]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'For discriminated unions defined with the F# 3.1 syntax, creating new case
    instances is significantly more developer friendly—not only because the labels
    appear in IntelliSense, but also because you can use named arguments like this:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 对于使用 F# 3.1 语法定义的区分联合体，创建新的案例实例对开发者更友好——不仅因为标签会出现在 IntelliSense 中，还因为您可以像这样使用命名参数：
- en: '[PRE57]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: Tree Structures
  id: totrans-217
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 树结构
- en: 'Discriminated unions can also be *self-referencing*, meaning that the data
    associated with a union case can be another case from the same union. This is
    handy for creating simple trees like this one, which represents a rudimentary
    markup structure:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 区分联合体也可以是*自引用的*，这意味着与联合体某个案例相关的数据可以是同一联合体中的另一个案例。这对于创建像这样简单的树结构非常有用，它表示一个基本的标记结构：
- en: '[PRE58]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: Most of this definition should be familiar by now, but notice that the `ContentElement`
    case has an associated string and list of `Markup` values.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 这个定义中的大部分应该已经很熟悉了，但请注意，`ContentElement`案例有一个关联的字符串和`Markup`类型值的列表。
- en: The nested `Markup` list ① makes it trivial to construct a simple HTML document
    like the following. Here, `ContentElement` nodes represent elements (such as `html`,
    `head`, and `body`) that contain additional content, while `Content` nodes represent
    raw text contained within a `ContentElement`.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 嵌套的`Markup`列表①使得构建一个简单的HTML文档变得非常简单，像下面这样。在这里，`ContentElement`节点表示包含额外内容的元素（如`html`、`head`和`body`），而`Content`节点表示包含在`ContentElement`中的原始文本。
- en: '[PRE59]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'To convert the preceding tree structure to an actual HTML document, you could
    write a simple recursive function with a match expression to handle each union
    case, like this:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 要将前面的树结构转换为实际的HTML文档，您可以编写一个简单的递归函数，并使用匹配表达式处理每个联合体案例，像这样：
- en: '[PRE60]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: The `match` expression is used here roughly like a `switch` statement in C#
    or a `SELECT CASE` statement in Visual Basic. Each match case, denoted by a vertical
    pipe (`|`), matches against an Identifier pattern that includes the union case
    name and identifiers for each of its associated values. For instance, the match
    case at ① matches `ContentElement` items and represents the associated values
    with the `tag` and `children` identifiers within the case body (the part after
    the arrow). Likewise, the match cases at ② and ③ match the `EmptyElement` and
    `Content` cases, respectively. (Note that because match expressions return a value,
    each match case’s return type must be the same.)
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的`match`表达式大致类似于 C# 中的 `switch` 语句或 Visual Basic 中的 `SELECT CASE` 语句。每个匹配案例，由竖线符号（`|`）表示，与一个标识符模式匹配，该模式包括联合体案例的名称和其所有相关值的标识符。例如，①处的匹配案例匹配`ContentElement`项，并在案例体（箭头后面的部分）中使用`tag`和`children`标识符表示相关值。同样，②和③处的匹配案例分别匹配`EmptyElement`和`Content`案例。（请注意，由于匹配表达式会返回一个值，因此每个匹配案例的返回类型必须相同。）
- en: Invoking the `toHtml` function with `movieList` results in the following HTML
    (formatted for readability). As you look over the resulting HTML, try tracing
    each element back to its node in `movieList`.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`movieList`调用`toHtml`函数会生成以下HTML（已格式化以便阅读）。在查看生成的HTML时，试着追溯每个元素在`movieList`中的节点。
- en: '[PRE61]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: Replacing Type Abbreviations
  id: totrans-228
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 替换类型缩写
- en: Single-case discriminated unions can be a useful alternative to type abbreviations,
    which, while nice for aliasing existing types, don’t provide any additional type
    safety. For instance, suppose you’ve defined `UserId` as an alias for `System.Guid`
    and you have a function `UserId -> User`. Although the function accepts `UserId`,
    nothing prevents you from sending in an arbitrary `Guid`, no matter what that
    `Guid` actually represents.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 单案例区分联合体可以作为类型缩写的有用替代方案，虽然类型缩写对于创建现有类型的别名很方便，但它们并不会提供额外的类型安全性。例如，假设您将`UserId`定义为`System.Guid`的别名，并且有一个函数`UserId
    -> User`。尽管该函数接受`UserId`，但没有任何东西可以阻止您传入任意的`Guid`，无论该`Guid`实际代表什么。
- en: 'Let’s extend the markup examples from the previous section to show how single-case
    discriminated unions can solve this problem. If you wanted to display the generated
    HTML in a browser, you could define a function like this:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们扩展前一节的标记示例，展示单案例区分联合体如何解决这个问题。如果您想在浏览器中显示生成的HTML，您可以定义一个像这样的函数：
- en: '[PRE62]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: The actual mechanics of the `displayHtml` function aren’t important for this
    discussion. Instead, focus your attention on ① the `HtmlString` type abbreviation
    and ② the type annotation explicitly stating that the `html` parameter is an `HtmlString`.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: '`displayHtml`函数的实际机制对于这个讨论并不重要。相反，请将注意力集中在① `HtmlString`类型别名和② 类型注解明确声明`html`参数是`HtmlString`。'
- en: It’s clear from the signature that the `displayHtml` function expects the supplied
    string to contain HTML, but because `HtmlString` is merely a type abbreviation
    there’s nothing ensuring that it actually is HTML. As written, both `movieList
    |> toHtml |> displayHtml` and `"abc123" |> displayHtml` are valid.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 从签名可以明显看出，`displayHtml`函数期望传入的字符串包含HTML，但由于`HtmlString`仅仅是类型的别名，并不能确保它实际上是HTML。按照当前写法，`movieList
    |> toHtml |> displayHtml`和`"abc123" |> displayHtml`都是有效的。
- en: 'To introduce a bit more type safety, we can replace the `HtmlString` definition
    with a single-case discriminated union, like this:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 为了引入更多的类型安全性，我们可以用单案例区分联合类型替换`HtmlString`定义，如下所示：
- en: '[PRE63]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: Now that `HtmlString` is a discriminated union, we need to change the `displayHtml`
    function to extract the associated string. We can do this in one of two ways.
    The first option requires us to change the function’s signature to include an
    Identifier pattern. Alternatively, we can leave the signature alone and introduce
    an intermediate binding (also using an Identifier pattern) for the associated
    value. The first option is cleaner, so that’s the approach we’ll use.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 由于`HtmlString`现在是一个区分联合类型，我们需要修改`displayHtml`函数以提取关联的字符串。我们可以通过两种方式实现这一点。第一种方法需要我们更改函数的签名以包括标识符模式。或者，我们可以不改变签名，改为引入一个中间绑定（同样使用标识符模式）来处理关联值。第一种方法更简洁，因此我们将使用这种方法。
- en: '[PRE64]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'To call the `displayHtml` function, we only need to wrap the string from the
    `toHtml` function in an `HtmlString` instance and pass it to `displayHtml` as
    follows:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 要调用`displayHtml`函数，我们只需要将`toHtml`函数的字符串包装在`HtmlString`实例中，并将其传递给`displayHtml`，如下所示：
- en: '[PRE65]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'Finally, we can further simplify this code by revising the `toHtml` function
    to return an `HtmlString` instead of a string. One approach would look like this:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们可以通过修改`toHtml`函数返回`HtmlString`而不是字符串来进一步简化这段代码。一种做法如下所示：
- en: '[PRE66]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: In this revised version, we’ve wrapped each case’s return value in an `HtmlString`
    instance. Less trivial, though, is ①, which now uses an Identifier pattern to
    extract the HTML from the recursive result in order to write the raw text to the
    `StringWriter`.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个修订版中，我们将每个案例的返回值包装在`HtmlString`实例中。然而，更不平凡的是①，现使用标识符模式从递归结果中提取HTML，以便将原始文本写入`StringWriter`。
- en: 'With the `toHtml` function now returning an `HtmlString`, passing its result
    to `displayHtml` is simplified to this:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，`toHtml`函数返回一个`HtmlString`，将其结果传递给`displayHtml`简化为如下代码：
- en: '[PRE67]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: Single-case discriminated unions can’t guarantee that any associated values
    are actually correct, but they do offer a little extra safety in that they force
    developers to make conscious decisions about what they’re passing to a function.
    Developers could create an `HtmlString` instance with an arbitrary string, but
    if they do they’ll be forced to think about whether the data is correct.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 单案例区分联合类型无法保证任何关联值实际上是正确的，但它们提供了一些额外的安全性，迫使开发者在传递给函数时做出有意识的决定。开发者可以创建一个包含任意字符串的`HtmlString`实例，但如果这样做，他们将被迫考虑数据是否正确。
- en: Additional Members
  id: totrans-246
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 附加成员
- en: 'Like record types, discriminated unions also allow additional members. For
    example, we could redefine the `toHtml` function as a method on the `Markup` discriminated
    union as follows:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 与记录类型类似，区分联合类型也允许附加成员。例如，我们可以将`toHtml`函数重新定义为`Markup`区分联合类型上的方法，如下所示：
- en: '[PRE68]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'Calling this method is like calling a method on any other type:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 调用这个方法就像调用其他类型的方法一样：
- en: '[PRE69]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: Lazy Evaluation
  id: totrans-251
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 惰性求值
- en: By default, F# uses *eager evaluation*, which means that expressions are evaluated
    immediately. Most of the time, eager evaluation will be fine in F#, but sometimes
    you can improve perceived performance by deferring execution until the result
    is actually needed, through *lazy evaluation*.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，F#使用*急切求值*，这意味着表达式会立即求值。大多数情况下，急切求值在F#中是没问题的，但有时你可以通过推迟执行直到结果真正需要时来提高感知性能，这就是*惰性求值*。
- en: F# supports a few mechanisms for enabling lazy evaluation, but one of the easiest
    and most common ways is through the use of the `lazy` keyword. Here, the lazy
    keyword is used in conjunction with a series of expressions that includes a delay
    to simulate a long-running operation.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: F#支持一些启用懒惰求值的机制，但最简单和最常见的方法之一是通过使用`lazy`关键字。在这里，`lazy`关键字与一系列包含延迟的表达式结合使用，以模拟一个长时间运行的操作。
- en: '[PRE70]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: You can see the `lazy` keyword’s impact. If this expression had been eagerly
    evaluated, `evaluating lazy expression` would have been printed and there would
    have been an immediate one-second delay before it returned `42`. Instead, the
    expression’s result is an instance of the built-in `Lazy<'T>` type. In this case,
    the compiler inferred the return type and created an instance of `Lazy<int>`.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以看到`lazy`关键字的影响。如果这个表达式是立即求值的，那么`evaluating lazy expression`将会被打印，并且在返回`42`之前会有一个即时的延迟一秒钟。相反，这个表达式的结果是内置的`Lazy<'T>`类型的一个实例。在这种情况下，编译器推断出返回类型，并创建了一个`Lazy<int>`的实例。
- en: Note
  id: totrans-256
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '*Be careful using the lazy type across language boundaries. Prior to F# 3.0,
    the `Lazy<''T>` class was located in the FSharp.Core assembly. In .NET 4.0, `Lazy<''T>`
    was moved to `mscorlib`.*'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: '*小心跨语言边界使用懒类型。在F# 3.0之前，`Lazy<''T>`类位于FSharp.Core程序集。在.NET 4.0中，`Lazy<''T>`被移动到了`mscorlib`。*'
- en: The `Lazy<'T>` instance created by the `lazy` keyword can be passed around like
    any other type, but the underlying expression won’t be evaluated until you force
    that evaluation by either calling the `Force` method or accessing its `Value`
    property, as shown next. Convention generally favors the `Force` method, but it
    doesn’t really matter whether you use it or the `Value` property to force evaluation.
    Internally, `Force` is just an extension method that wraps the `Value` property.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 由`lazy`关键字创建的`Lazy<'T>`实例可以像其他类型一样传递，但底层的表达式不会被求值，直到你通过调用`Force`方法或访问它的`Value`属性来强制求值，如下所示。通常约定更倾向于使用`Force`方法，但其实无论你使用它还是`Value`属性来强制求值都没有关系。在内部，`Force`只是一个扩展方法，它封装了`Value`属性。
- en: '[PRE71]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: Now that we’ve forced evaluation, we see that the underlying expression has
    printed its message, slept, and returned `42`. The `Lazy<'T>` type can also improve
    application performance through memoization. Once the associated expression is
    evaluated, its result is cached within the `Lazy<'T>` instance and used for subsequent
    requests. If the expression involves an expensive or time-consuming operation,
    the result can be dramatic.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经强制求值，我们看到底层的表达式已经打印了它的信息，休眠了一段时间，并返回了`42`。`Lazy<'T>`类型也可以通过记忆化提高应用程序性能。一旦相关的表达式被求值，它的结果会被缓存到`Lazy<'T>`实例中，并在随后的请求中使用。如果该表达式涉及一个昂贵或耗时的操作，结果可能会非常显著。
- en: 'To more effectively observe memoization’s impact, we can enable timing in FSI
    and repeatedly force evaluation as follows:'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更有效地观察记忆化的影响，我们可以在FSI中启用计时，并重复强制求值，如下所示：
- en: '[PRE72]'
  id: totrans-262
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: As you can see at ①, the first time `Force` is called we incur the expense of
    putting the thread to sleep. The subsequent calls at ② and ③ complete instantaneously
    because the memoization mechanism has cached the result.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，在①处，第一次调用`Force`时，我们付出了让线程休眠的代价。随后在②和③处的调用则瞬间完成，因为记忆化机制已经缓存了结果。
- en: Summary
  id: totrans-264
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 总结
- en: As you’ve seen in this chapter, functional programming requires a different
    mindset than object-oriented programming. While object-oriented programming emphasizes
    managing system state, functional programming is more concerned with program correctness
    and predictability through the application of side-effect-free functions to data.
    Functional languages like F# treat functions as data. In doing so, they allow
    for greater composability within systems through concepts like higher-order functions,
    currying, partial application, pipelining, and function composition. Functional
    data types like tuples, record types, and discriminated unions help you write
    correct code by letting you focus on the problem you’re trying to solve instead
    of attempting to satisfy the compiler.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你在本章中看到的，函数式编程要求与面向对象编程不同的思维方式。面向对象编程强调管理系统状态，而函数式编程则更关注通过将无副作用的函数应用于数据来确保程序的正确性和可预测性。像F#这样的函数式语言将函数视为数据。这样，它们通过更高阶函数、柯里化、部分应用、管道化和函数组合等概念，在系统内部实现了更大的组合性。像元组、记录类型和判别联合等函数式数据类型，通过让你专注于解决问题，而不是试图满足编译器，帮助你编写正确的代码。
