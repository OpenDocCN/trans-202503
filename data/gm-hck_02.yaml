- en: '**1**'
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '**1**'
- en: '**SCANNING MEMORY USING CHEAT ENGINE**'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: '**使用作弊引擎扫描内存**'
- en: '![image](../images/common.jpg)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/common.jpg)'
- en: 'The best game hackers in the world spend years personalizing expansive arsenals
    with custom-built tools. Such potent toolkits enable these hackers to seamlessly
    analyze games, effortlessly prototype hacks, and effectively develop bots. At
    the core, however, each unique kit is built from the same four-piece powerhouse:
    a memory scanner, an assembler-level debugger, a process monitor, and a hex editor.'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 世界上最顶尖的游戏黑客花费数年时间，个性化定制庞大的工具箱。如此强大的工具包使这些黑客能够无缝地分析游戏，轻松地原型化黑客攻击，并有效地开发机器人。然而，在核心上，每个独特的工具包都由同样的四个核心组成：一个内存扫描器、一个汇编级调试器、一个进程监控器和一个十六进制编辑器。
- en: Memory scanning is the gateway to game hacking, and this chapter will teach
    you about Cheat Engine, a powerful memory scanner that searches a game’s operating
    memory (which lives in RAM) for values like the player’s level, health, or in-game
    money. First, I’ll focus on basic memory scanning, memory modification, and pointer
    scanning. Following that, we’ll dive into Cheat Engine’s powerful embedded Lua
    scripting engine.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 内存扫描是游戏黑客的入口，本章将教你如何使用作弊引擎——一个强大的内存扫描器，它搜索游戏的运行内存（也就是RAM）中的值，比如玩家的等级、血量或游戏中的货币。首先，我会介绍基础的内存扫描、内存修改和指针扫描。接着，我们将深入了解作弊引擎强大的嵌入式Lua脚本引擎。
- en: '**NOTE**'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*You can grab Cheat Engine from* [http://www.cheatengine.org/](http://www.cheatengine.org/)*.
    Pay attention when running the installer because it will try to install some toolbars
    and other bloatware. You can disable those options if you wish.*'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: '*你可以从* [http://www.cheatengine.org/](http://www.cheatengine.org/) *下载作弊引擎。安装时要注意，因为它会尝试安装一些工具栏和其他垃圾软件。如果你愿意，可以禁用这些选项。*'
- en: '**Why Memory Scanners Are Important**'
  id: totrans-7
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**为什么内存扫描器很重要**'
- en: Knowing a game’s state is paramount to interacting with the game intelligently,
    but unlike humans, software can’t determine the state of a game simply by looking
    at what’s on the screen. Fortunately, underneath all of the stimuli produced by
    a game, a computer’s memory contains a purely numeric representation of that game’s
    state—and programs can understand numbers easily. Hackers use memory scanners
    to find those values in memory, and then in their programs, they read the memory
    in these locations to understand the game’s state.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 了解游戏的状态对于智能地与游戏互动至关重要，但与人类不同，软件不能仅仅通过看屏幕上的内容来确定游戏的状态。幸运的是，在游戏产生的所有刺激背后，计算机的内存包含了该游戏状态的纯数字表示——而程序能够轻松理解数字。黑客使用内存扫描器来找到这些内存中的值，然后在他们的程序中读取这些位置的内存，以了解游戏的状态。
- en: 'For example, a program that heals players when they fall below 500 health needs
    to know how to do two things: track a player’s current health and cast a healing
    spell. The former requires access to the game’s state, while the latter might
    only require a button to be pressed. Given the location where a player’s health
    is stored and the way to read a game’s memory, the program would look something
    like this pseudocode:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，一个当玩家血量低于500时自动治疗玩家的程序需要做两件事：追踪玩家当前的血量和施放治疗法术。前者需要访问游戏的状态，而后者可能只需要按下一个按钮。给定玩家血量存储的位置和读取游戏内存的方式，程序大致的伪代码可能如下所示：
- en: '[PRE0]'
  id: totrans-10
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: A memory scanner allows you to find `HEALTH_LOCATION` so that your software
    can query it for you later.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 内存扫描器让你可以找到`HEALTH_LOCATION`，以便你的软件稍后可以查询它。
- en: '**Basic Memory Scanning**'
  id: totrans-12
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**基础内存扫描**'
- en: The memory scanner is the most basic, yet most important, tool for the aspiring
    game hacker. As in any program, all data in the memory of a game resides at an
    absolute location called a *memory address*. If you think of the memory as a very
    large byte array, a memory address is an index pointing to a value in that array.
    When a memory scanner is told to find some value *x* (called a *scan value*, because
    it’s the value you’re scanning for) in a game’s memory, the scanner loops through
    the byte array looking for any value equal to *x*. Every time it finds a matching
    value, it adds the index of the match to a result list.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 内存扫描器是对有抱负的游戏黑客来说最基础也是最重要的工具。和任何程序一样，游戏中的所有数据都存在一个叫做*内存地址*的绝对位置。如果你把内存看作一个非常大的字节数组，那么内存地址就是指向该数组中某个值的索引。当内存扫描器被告知要在游戏内存中找到某个值*x*（称为*扫描值*，因为它是你正在扫描的值）时，扫描器会循环遍历字节数组，寻找任何等于*x*的值。每次找到匹配的值时，它会将该匹配项的索引添加到结果列表中。
- en: Due to the sheer size of a game’s memory, however, the value of *x* can appear
    in hundreds of locations. Imagine that *x* is the player’s health, which is currently
    500\. Our *x* uniquely holds `500`, but `500` is not uniquely held by *x*, so
    a scan for *x* returns all variables with a value of `500`. Any addresses not
    related to *x* are ultimately clutter; they share a value of `500` with *x* only
    by chance. To filter out these unwanted values, the memory scanner allows you
    to rescan the result list, removing addresses that no longer hold the same value
    as *x*, whether *x* is still `500` or has changed.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，由于游戏内存的庞大，*x* 的值可能出现在数百个位置。假设 *x* 是玩家的生命值，目前是 500。我们的 *x* 唯一持有 `500`，但 `500`
    并非仅由 *x* 独占，因此扫描 *x* 会返回所有值为 `500` 的变量。任何与 *x* 无关的地址最终都是杂乱无章的；它们仅仅是偶然与 *x* 一起共享
    `500` 的值。为了过滤掉这些不需要的值，内存扫描器允许你重新扫描结果列表，移除那些不再持有与 *x* 相同值的地址，无论 *x* 是否仍为 `500`
    或已发生变化。
- en: For these rescans to be effective, the overall state of the game must have significant
    *entropy*—a measure of disorder. You increase entropy by changing the in-game
    environment, often by moving around, killing creatures, or switching characters.
    As entropy increases, unrelated addresses are less likely to continue to arbitrarily
    hold the same value, and given enough entropy, a few rescans should filter out
    all false positives and leave you with the true address of *x*.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使这些重新扫描有效，游戏的整体状态必须具有显著的 *熵*——一种衡量混乱的指标。通过改变游戏内的环境，通常是通过四处走动、击杀怪物或更换角色，可以增加熵值。随着熵值的增加，无关的地址不太可能继续随意持有相同的值，且在足够的熵值下，几次重新扫描应该可以过滤掉所有假阳性，最终只留下
    *x* 的真实地址。
- en: '**Cheat Engine’s Memory Scanner**'
  id: totrans-16
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**Cheat Engine 的内存扫描器**'
- en: This section gives you a tour of Cheat Engine’s memory-scanning options, which
    will help you track down the addresses of game state values in memory. I’ll give
    you a chance to try the scanner out in “[Basic Memory Editing](ch01.xhtml#ch01sb01)”
    on [page 11](ch01.xhtml#page_11); for now, open Cheat Engine and have a look around.
    The memory scanner is tightly encapsulated in its main window, as shown in [Figure
    1-1](ch01.xhtml#ch1fig1).
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 本节将带你了解 Cheat Engine 的内存扫描选项，帮助你追踪游戏状态值在内存中的地址。我将在《[基础内存编辑](ch01.xhtml#ch01sb01)》的第[11页](ch01.xhtml#page_11)让你有机会亲自尝试扫描器；现在，打开
    Cheat Engine 并四处看看。内存扫描器紧密封装在其主窗口中，如[图 1-1](ch01.xhtml#ch1fig1)所示。
- en: '![image](../images/f01-01.jpg)'
  id: totrans-18
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f01-01.jpg)'
- en: '*Figure 1-1: Cheat Engine main screen*'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 1-1：Cheat Engine 主界面*'
- en: To begin scanning a game’s memory, click the Attach icon ➊ to attach to a process
    and then enter the scan value (referred to as *x* in our conceptual scanner) you
    want to locate ➌. By attaching to a process, we’re telling Cheat Engine to prepare
    to operate on it; in this case, that operation is a scan. It helps to also tell
    Cheat Engine what kind of scan to run, as I’ll discuss next.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 要开始扫描游戏的内存，点击附加图标 ➊ 以附加到一个进程，然后输入你想要查找的扫描值（在我们概念化的扫描器中称为 *x*） ➌。通过附加到一个进程，我们告诉
    Cheat Engine 准备对其进行操作；在这种情况下，这个操作是一个扫描。接下来，我将讨论告诉 Cheat Engine 执行哪种类型的扫描也会有所帮助。
- en: '***Scan Types***'
  id: totrans-21
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***扫描类型***'
- en: 'Cheat Engine allows you to select two different scan directives, called Scan
    Type and Value Type ➍. Scan Type tells the scanner how to compare your scan value
    with the memory being scanned using one of the following scan types:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 'Cheat Engine 允许你选择两种不同的扫描指令，分别是扫描类型和数值类型 ➍。扫描类型告诉扫描器如何使用以下扫描类型之一来比较你的扫描值与正在扫描的内存： '
- en: '**Exact Value** Returns addresses pointing to values equal to the scan value.
    Choose this option if the value you are looking for won’t change during the scan;
    health, mana, and level typically fall into this category.'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: '**精确值** 返回指向等于扫描值的地址。如果你正在寻找的值在扫描过程中不会改变，请选择此选项；例如，生命值、法力值和等级通常属于此类别。'
- en: '**Bigger Than** Returns addresses pointing to values greater than the scan
    value. This option is useful when the value you’re searching for is steadily increasing,
    which often happens with timers.'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: '**大于** 返回指向比扫描值更大的值的地址。当你搜索的值不断增加时，这个选项非常有用，这通常发生在计时器中。'
- en: '**Smaller Than** Returns addresses pointing to values smaller than the scan
    value. Like Bigger Than, this option is useful for finding timers (in this case,
    ones that count down rather than up).'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: '**小于** 返回指向比扫描值更小的值的地址。与“大于”类似，这个选项在寻找计时器时非常有用（在这种情况下，是倒计时而不是正计时）。'
- en: '**Value Between** Returns addresses pointing to values within a scan value
    range. This option combines Bigger Than and Smaller Than, displaying a secondary
    scan value box that allows you to input a much smaller range of values.'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: '**介于某两个值之间** 返回指向位于扫描值范围内的值的地址。此选项结合了“大于”和“小于”，显示一个次级扫描值框，允许你输入一个更小范围的值。'
- en: '**Unknown Initial Value** Returns all addresses in a program’s memory, allowing
    rescans to examine the entire address range relative to their initial values.
    This option is useful for finding item or creature types, since you won’t always
    know the internal values the game developers used to represent these objects.'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: '**未知初始值** 返回程序内存中所有地址，允许重新扫描检查相对于它们初始值的整个地址范围。此选项对于寻找物品或生物类型非常有用，因为你并不总是知道游戏开发者用来表示这些对象的内部值。'
- en: The Value Type directive tells the Cheat Engine scanner what type of variable
    it’s searching for.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 值类型指令告诉作弊引擎扫描器正在寻找哪种类型的变量。
- en: '***Running Your First Scan***'
  id: totrans-29
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***运行第一次扫描***'
- en: Once the two scan directives are set, click **First Scan** ➋ to run an initial
    scan for values, and the scanner will populate the results list ➎. Any green addresses
    in this list are *static*, meaning that they should remain persistent across program
    restarts. Addresses listed in black reside in *dynamically allocated memory*,
    memory that is allocated at runtime.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦设置了两个扫描指令，点击**第一次扫描** ➋开始初始值扫描，扫描仪将填充结果列表➎。列表中任何绿色的地址都是*静态*的，意味着它们应该在程序重启后保持不变。以黑色列出的地址位于*动态分配内存*中，即在运行时分配的内存。
- en: When the results list is first populated, it shows the address and real-time
    value of each result. Each rescan will also show the value of each result during
    the previous scan. (Any real-time values displayed are updated at an interval
    that you can set in Edit ▸ Settings ▸General Settings ▸Update interval.)
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 当结果列表首次填充时，它会显示每个结果的地址和实时值。每次重新扫描时，还会显示上次扫描期间每个结果的值。（任何显示的实时值会以你在 编辑 ▸ 设置 ▸
    常规设置 ▸ 更新间隔 中设置的时间间隔进行更新。）
- en: '***Next Scans***'
  id: totrans-32
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***下一次扫描***'
- en: 'Once the results list is populated, the scanner enables the Next Scan ➋ button,
    which offers six new scan types. These additional scan types allow you to compare
    the addresses in the results list to their values in the previous scan, which
    will help you narrow down which address holds the game state value you’re scanning
    for. They are as follows:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦结果列表被填充，扫描仪会启用“下一次扫描”➋按钮，该按钮提供六种新的扫描类型。这些附加扫描类型允许你将结果列表中的地址与上次扫描中的值进行比较，从而帮助你缩小哪个地址包含你正在扫描的游戏状态值。它们如下：
- en: '**Increased Value** Returns addresses pointing to values that have increased.
    This complements the Bigger Than scan type by keeping the same minimum value and
    removing any address whose value has decreased.'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: '**增加的值** 返回指向已增加的值的地址。此选项与“大于”扫描类型互补，保持相同的最小值，并移除任何值已减少的地址。'
- en: '**Increased Value By** Returns addresses pointing to values that have increased
    by a defined amount. This scan type usually returns far fewer false positives,
    but you can use it only when you know exactly how much a value has increased.'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: '**增加的值** 返回指向值增加了指定数量的地址。此扫描类型通常会返回更少的误报，但仅当你准确知道一个值增加了多少时才可以使用它。'
- en: '**Decreased Value** This option is the opposite of Increased Value.'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: '**减少的值** 这个选项是“增加的值”的相反操作。'
- en: '**Decreased Value By** This option is the opposite of Increased Value By.'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: '**减少的值** 这个选项是“增加的值”的相反操作。'
- en: '**Changed Value** Returns addresses pointing to values that have changed. This
    type is useful when you know a value will mutate, but you’re unsure how.'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: '**已更改的值** 返回指向已更改的值的地址。当你知道一个值会发生变化，但不确定变化方式时，此类型非常有用。'
- en: '**Unchanged Value** Returns addresses pointing to values that haven’t changed.
    This can help you eliminate false positives, since you can easily create a large
    amount of entropy while ensuring the desired value stays the same.'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: '**未更改的值** 返回指向未更改的值的地址。这有助于你排除误报，因为你可以轻松产生大量熵，同时确保所需的值保持不变。'
- en: You’ll usually need to use multiple scan types in order to narrow down a large
    result list and find the correct address. Eliminating false positives is often
    a matter of properly creating entropy (as described in “[Basic Memory Scanning](ch01.xhtml#ch00lev1sec8)”
    on [page 4](ch01.xhtml#page_4)), tactically changing your scan directives, bravely
    pressing Next Scan, and then repeating the process until you have a single remaining
    address.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 您通常需要使用多种扫描类型，以便缩小大量结果列表并找到正确的地址。消除误报通常是通过正确创建熵（如在“[基本内存扫描](ch01.xhtml#ch00lev1sec8)”第[4页](ch01.xhtml#page_4)中所述）、战术性地改变扫描指令、勇敢地按下“下一次扫描”，然后重复这一过程，直到只剩下一个地址。
- en: '***When You Can’t Get a Single Result***'
  id: totrans-41
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***当你无法获得单一结果时***'
- en: Sometimes it is impossible to pinpoint a single result in Cheat Engine, in which
    case you must determine the correct address through experimentation. For example,
    if you’re looking for your character’s health and can’t narrow it down to fewer
    than five addresses, you could try modifying the value of each address (as discussed
    in “[Manual Modification with Cheat Engine](ch01.xhtml#ch00lev1sec16)” on [page
    8](ch01.xhtml#page_8)) until you see the health display change or the other values
    automatically change to the one you set.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 有时在作弊引擎中无法确定一个单一的结果，在这种情况下，您必须通过实验来确定正确的地址。例如，如果您正在寻找角色的生命值并且无法将地址缩小到少于五个地址，您可以尝试修改每个地址的值（如在“[使用作弊引擎手动修改](ch01.xhtml#ch00lev1sec16)”第[8页](ch01.xhtml#page_8)中所述），直到看到生命值显示变化，或者其他值自动变化为您设置的值。
- en: '***Cheat Tables***'
  id: totrans-43
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***作弊表***'
- en: Once you’ve found the correct address, you can double-click it to add it to
    the *cheat table pane* ➏; addresses in the cheat table pane can be modified, watched,
    and saved to cheat table files for future use.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦您找到正确的地址，可以双击它将其添加到*作弊表面板* ➏；在作弊表面板中的地址可以被修改、监视，并保存到作弊表文件中以供将来使用。
- en: For each address in the cheat table pane, you can add a description by double-clicking
    the Description column, and you can add a color by right-clicking and selecting
    Change Color. You can also display the values of each address in hexadecimal or
    decimal format by right-clicking and selecting Show as hexadecimal or Show as
    decimal, respectively. Lastly, you can change the data type of each value by double-clicking
    the Type column, or you can change the value itself by double-clicking the Value
    column.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 在作弊表面板的每个地址上，您可以通过双击描述栏来添加描述，也可以通过右键单击并选择“更改颜色”来添加颜色。您还可以通过右键单击并分别选择“以十六进制显示”或“以十进制显示”来显示每个地址的值，最后，您可以通过双击类型栏来更改每个值的数据类型，或者通过双击值栏来更改值本身。
- en: Since the main purpose of the cheat table pane is to allow a game hacker to
    neatly track addresses, it can be dynamically saved and loaded. Go to **File**
    ▸ **Save** or **File** ▸**Save As** to save the current cheat table pane to a
    *.ct* document file containing each address with its value type, description,
    display color, and display format. To load the saved *.ct* documents, go to **File**
    ▸**Load**. (You’ll find many ready-made cheat tables for popular games at *[http://cheatengine.org/tables.php](http://cheatengine.org/tables.php)*.)
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 由于作弊表面板的主要目的是允许游戏黑客整洁地跟踪地址，因此它可以动态保存和加载。请前往**文件** ▸ **保存**或**文件** ▸ **另存为**，将当前的作弊表面板保存为一个*.ct*文档文件，其中包含每个地址及其值类型、描述、显示颜色和显示格式。要加载已保存的*.ct*文档，请前往**文件**
    ▸ **加载**。（您可以在*[http://cheatengine.org/tables.php](http://cheatengine.org/tables.php)*找到许多流行游戏的现成作弊表。）
- en: Now that I’ve described how to scan for a game state value, I’ll discuss how
    you can change that value when you know where it lives in memory.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我已经描述了如何扫描游戏状态值，接下来我将讨论在您知道它在内存中的位置时，如何更改该值。
- en: '**Memory Modification in Games**'
  id: totrans-48
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**游戏中的内存修改**'
- en: Bots cheat a game system by modifying memory values in the game’s state in order
    to give you lots of in-game money, modify your character’s health, change your
    character’s position, and so on. In most online games, a character’s vitals (such
    as health, mana, skills, and position) are held in memory but are controlled by
    the game server and relayed to your local game client over the Internet, so modifying
    such values during online play is merely cosmetic and doesn’t affect the actual
    values. (Any useful memory modification to an online game requires a much more
    advanced hack that’s beyond Cheat Engine’s capabilities.) In local games with
    no remote server, however, you can manipulate all of these values at will.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 机器人通过修改游戏状态中的内存值来作弊，以便给你大量的游戏内货币、修改你角色的健康、改变角色位置等。在大多数在线游戏中，角色的生命值（如健康、魔法、技能和位置）保存在内存中，但由游戏服务器控制并通过互联网传递到你的本地游戏客户端，因此在在线游戏中修改这些值仅仅是表面上的，不会影响实际值。（对在线游戏的任何有效内存修改都需要一种比作弊引擎更高级的黑客技术。）然而，在没有远程服务器的本地游戏中，你可以随意操控这些值。
- en: '***Manual Modification with Cheat Engine***'
  id: totrans-50
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***使用作弊引擎手动修改***'
- en: We’ll use Cheat Engine to understand how the memory modification magic works.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用作弊引擎来了解内存修改的原理。
- en: 'To modify memory manually, do the following:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 要手动修改内存，请执行以下操作：
- en: Attach Cheat Engine to a game.
  id: totrans-53
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将作弊引擎附加到一个游戏。
- en: Either scan for the address you wish to modify or load a cheat table that contains
    it.
  id: totrans-54
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你可以扫描你想要修改的地址，或者加载一个包含该地址的作弊表。
- en: Double-click on the Value column for the address to open an input prompt where
    you can enter a new value.
  id: totrans-55
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 双击地址栏的值列，打开输入提示框，你可以在其中输入新值。
- en: If you want to make sure the new value can’t be overwritten, select the box
    under the Active column to *freeze* the address, which will make Cheat Engine
    keep writing the same value back to it every time it changes.
  id: totrans-56
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果你想确保新值不会被覆盖，请选择“活动”列下的框，*冻结*该地址，这将使作弊引擎每次该地址值发生变化时，都将相同的值写回。
- en: This method works wonders for quick-and-dirty hacks, but constantly changing
    values by hand is cumbersome; an automated solution would be much more appealing.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法对快速粗糙的黑客攻击非常有效，但手动不断更改值是繁琐的；一个自动化的解决方案将更加吸引人。
- en: '***Trainer Generator***'
  id: totrans-58
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***训练器生成器***'
- en: Cheat Engine’s trainer generator allows you to automate the whole memory modification
    process without writing any code.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 作弊引擎的训练器生成器允许你在不编写任何代码的情况下自动化整个内存修改过程。
- en: To create a *trainer* (a simple bot that binds memory modification actions to
    keyboard hotkeys), go to **File** ▸ **Create generic trainer Lua script from table**.
    This opens a Trainer generator dialog similar to the one shown in [Figure 1-2](ch01.xhtml#ch1fig2).
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建一个*训练器*（一个简单的机器人，将内存修改操作绑定到键盘快捷键），请转到**文件** ▸ **从表格创建通用训练器Lua脚本**。这将打开一个训练器生成器对话框，类似于[图
    1-2](ch01.xhtml#ch1fig2)所示的对话框。
- en: '![image](../images/f01-02.jpg)'
  id: totrans-61
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f01-02.jpg)'
- en: '*Figure 1-2: Cheat Engine Trainer generator dialog*'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 1-2：作弊引擎训练器生成器对话框*'
- en: 'There are a number of fields to modify here:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一些可以修改的字段：
- en: '**Processname** The name of the executable the trainer should attach to. This
    is the name shown in the process list when you attach with Cheat Engine, and it
    should be autofilled with the name of the process Cheat Engine is attached to.'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: '**进程名称** 训练器应该附加到的可执行文件名称。这是你在使用作弊引擎时在进程列表中看到的名称，通常会自动填充作弊引擎附加的进程名称。'
- en: '**Popup trainer on keypress** Optionally enables a hotkey—which you set by
    entering a key combination in the box below the checkbox—to display the trainer’s
    main window.'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: '**按键时弹出训练器** 可选择启用一个快捷键——你可以通过在复选框下方的框中输入一个键组合来设置——用来显示训练器的主窗口。'
- en: '**Title** The name of your trainer, which will be displayed on its interface.
    This is optional.'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: '**标题** 训练器的名称，将显示在其界面上。这个字段是可选的。'
- en: '**About text** The description of your trainer, to be displayed on the interface;
    this is also optional.'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: '**关于文本** 你训练器的描述，将显示在界面上；这是可选的。'
- en: '**Freeze interval (in milliseconds)** The interval during which a freeze operation
    overwrites the value. You should generally leave this at 250, as lower intervals
    can sap resources and higher values may be too slow.'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: '**冻结间隔（毫秒）** 冻结操作覆盖值的时间间隔。通常，你应该将其保持为250，因为较短的间隔会消耗资源，而较长的间隔可能太慢。'
- en: Once these values are configured, click **Add Hotkey** to set up a key sequence
    to activate your trainer. You will be prompted to select a value from your cheat
    table. Enter a value, and you will be taken to a Set/Change hotkey screen similar
    to [Figure 1-3](ch01.xhtml#ch1fig3).
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 配置好这些值后，点击 **添加快捷键** 来设置一个键序列以激活你的训练器。系统会提示你从作弊表中选择一个值。输入一个值后，你将进入类似于 [图 1-3](ch01.xhtml#ch1fig3)
    的设置/更改快捷键界面。
- en: '![image](../images/f01-03.jpg)'
  id: totrans-70
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f01-03.jpg)'
- en: '*Figure 1-3: Cheat Engine Set/Change hotkey screen*'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 1-3：Cheat Engine 设置/更改快捷键界面*'
- en: 'On this screen, place your cursor in the box labeled Type the keys you want
    to set the hotkey to ➊ and enter the desired key combination. Next, choose the
    desired action from the drop-down menu ➋; your options should appear in the following
    order:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 在此页面上，将光标放在标记为“输入要设置的快捷键”的框中 ➊，并输入所需的快捷键组合。接下来，从下拉菜单中选择所需的操作 ➋；选项应该按以下顺序出现：
- en: '**Toggle freeze** Toggles the freeze state of the address.'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: '**切换冻结** 切换地址的冻结状态。'
- en: '**Toggle freeze and allow increase** Toggles the freeze state of the address
    but allows the value to increase. Any time the value decreases, the trainer overwrites
    it with its previous value. Increased values will not be overwritten.'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: '**切换冻结并允许增加** 切换地址的冻结状态，但允许值增加。每当值减少时，训练器会用其先前的值覆盖它。增加的值将不会被覆盖。'
- en: '**Toggle freeze and allow decrease** Does the opposite of Toggle freeze and
    allow increase.'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: '**切换冻结并允许减少** 执行与“切换冻结并允许增加”相反的操作。'
- en: '**Freeze** Sets the address to frozen if it’s not frozen already.'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: '**冻结** 如果地址未被冻结，则将地址设置为冻结状态。'
- en: '**Unfreeze** Unfreezes the address if it’s frozen.'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: '**解冻** 如果地址被冻结，则解冻该地址。'
- en: '**Set value to** Sets the value to whatever you specify in the value box ➌.'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: '**设置值为** 将值设置为你在值框 ➌ 中指定的内容。'
- en: '**Decrease value with** Decreases the value by the amount you specify in the
    value box ➌.'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: '**减少值** 根据你在值框 ➌ 中指定的数值减少该值。'
- en: '**Increase value with** Does the opposite of Decrease value with.'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: '**增加值** 执行与“减少值”相反的操作。'
- en: Finally, you can set a description for the action ➍. Click **Apply**, then **OK**,
    and your action will appear in the list on the Trainer generator screen. At this
    point, Cheat Engine runs the trainer in the background, and you can simply press
    the hotkeys you configured to execute the memory actions.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，你可以为该操作设置一个描述 ➍。点击 **应用**，然后点击 **确定**，你的操作将出现在训练器生成器屏幕上的列表中。此时，Cheat Engine
    会在后台运行训练器，你只需按下配置的快捷键即可执行内存操作。
- en: To save your trainer to a portable executable, click **Generate trainer**. Running
    this executable after the game is launched will attach your trainer to the game
    so you can use it without starting Cheat Engine.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 要将训练器保存为可执行文件，请点击 **生成训练器**。在游戏启动后运行该可执行文件将会将训练器附加到游戏中，这样你就可以在不启动 Cheat Engine
    的情况下使用它。
- en: Now that you know your way around Cheat Engine’s memory scanner and trainer
    generator, try modifying some memory yourself.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经熟悉了 Cheat Engine 的内存扫描器和训练器生成器，试着自己修改一些内存吧。
- en: '**BASIC MEMORY EDITING**'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: '**基础内存编辑**'
- en: 'Download the files for this book from *[https://www.nostarch.com/gamehacking/](https://www.nostarch.com/gamehacking/)*,
    and run the file *BasicMemory.exe*. Next, start up Cheat Engine and attach to
    the binary. Then, using only Cheat Engine, find the addresses for the x- and y-coordinates
    of the gray ball. (Hint: Use the 4 Bytes value type.)'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 从 *[https://www.nostarch.com/gamehacking/](https://www.nostarch.com/gamehacking/)*
    下载本书的文件，并运行文件 *BasicMemory.exe*。接着，启动 Cheat Engine 并附加到二进制文件。然后，仅使用 Cheat Engine，找到灰色球的
    x 和 y 坐标地址。（提示：使用 4 字节值类型。）
- en: 'Once you’ve found the values, modify them to place the ball on top of the black
    square. The game will let you know once you’ve succeeded by displaying the text
    “Good job!” (Hint: Each time the ball is moved, its position—stored as a 4-byte
    integer—in that plane is changed by 1\. Also, try to look only for static [green]
    results.)'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦找到这些值，修改它们，将球放置在黑色方块上方。当你成功时，游戏会通过显示文本“做得好！”来告知你。（提示：每次移动球时，它的位置—作为一个 4 字节整数—在该平面中变化
    1。还要尝试只查找静态的 [绿色] 结果。）
- en: '**Pointer Scanning**'
  id: totrans-87
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**指针扫描**'
- en: As I’ve mentioned, online games often store values in dynamically allocated
    memory. While addresses that reference dynamic memory are useless to us in and
    of themselves, some static address will always point to another address, which
    in turn points to another, and so on, until the tail of the chain points to the
    dynamic memory we’re interested in. Cheat Engine can locate these chains using
    a method called *pointer scanning*.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 如我所提到的，在线游戏通常将值存储在动态分配的内存中。虽然引用动态内存的地址本身对我们没有用，但某个静态地址总是会指向另一个地址，而该地址又会指向另一个，以此类推，直到链的末尾指向我们感兴趣的动态内存。Cheat
    Engine可以使用一种叫做*指针扫描*的方法来定位这些链。
- en: In this section, I’ll introduce you to pointer chains and then describe how
    pointer scanning works in Cheat Engine. When you have a good grasp of the user
    interface, you can get some hands-on experience in “[Pointer Scanning](ch01.xhtml#ch00lev1sec18)”
    on [page 18](ch01.xhtml#page_18).
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我将向你介绍指针链，并描述如何在Cheat Engine中进行指针扫描。当你掌握了用户界面后，你可以在[第18页](ch01.xhtml#page_18)的“[指针扫描](ch01.xhtml#ch00lev1sec18)”中获得一些实践经验。
- en: '***Pointer Chains***'
  id: totrans-90
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***指针链***'
- en: 'The chain of offsets I’ve just described is called a *pointer chain* and looks
    like this:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 我刚才描述的这个偏移链被称为*指针链*，其结构如下：
- en: '[PRE1]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The first value in this pointer chain (`start`) is called a *memory pointer*.
    It’s an address that starts the chain. The remaining values (`offset1`, `offset2`,
    and so on) make up the route to the desired value, called a *pointer path*.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 这个指针链中的第一个值（`start`）称为*内存指针*。它是启动链的地址。其余的值（`offset1`，`offset2`，依此类推）构成到达目标值的路径，称为*指针路径*。
- en: 'This pseudocode shows how a pointer chain might be read:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 这个伪代码展示了如何读取一个指针链：
- en: '[PRE2]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'This code creates the function `readPointerPath()`, which takes a pointer chain
    called `chain` as a parameter. The function `readPointerPath()` treats the pointer
    path in `chain` as a list of memory offsets from the address `ret`, which is initially
    set to the memory pointer at ➊. It then loops through these offsets, updating
    the value of `ret` to the result of `read(ret + offset)` on each iteration and
    returning `ret` once it’s finished. This pseudocode shows what `readPointerPath()`
    looks like when the loop is unrolled:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码创建了一个名为`readPointerPath()`的函数，它以一个名为`chain`的指针链作为参数。`readPointerPath()`函数将`chain`中的指针路径视为从地址`ret`（最初设置为➊处的内存指针）开始的一系列内存偏移量。然后，它循环遍历这些偏移量，在每次迭代时通过`read(ret
    + offset)`更新`ret`的值，并在完成后返回`ret`。以下是当循环展开时，`readPointerPath()`的伪代码：
- en: '[PRE3]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The function ultimately calls `read` four times, on four different addresses—one
    for each element in `chain`.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 该函数最终调用`read`四次，针对`chain`中的每个地址调用一次。
- en: '**NOTE**'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*Many game hackers prefer to code their chain reads in place, instead of encapsulating
    them in functions like* `readPointerPath()`.'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: '*许多游戏黑客更喜欢将链读取直接编写在代码中，而不是像* `readPointerPath()` *那样将它们封装成函数。*'
- en: '***Pointer Scanning Basics***'
  id: totrans-101
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***指针扫描基础***'
- en: Pointer chains exist because every chunk of dynamically allocated memory must
    have a corresponding static address that the game’s code can use to reference
    it. Game hackers can access these chunks by locating the pointer chains that reference
    them. Because of their multitier structure, however, pointer chains cannot be
    located through the linear approach that memory scanners use, so game hackers
    have devised new ways to find them.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 指针链存在的原因是每一块动态分配的内存都必须有一个对应的静态地址，游戏代码可以用这个地址来引用它。游戏黑客可以通过定位引用这些内存块的指针链来访问它们。然而，由于指针链具有多层结构，它们无法通过内存扫描器使用的线性方式来定位，因此游戏黑客发明了新的方法来查找它们。
- en: From a reverse engineering perspective, you could locate and analyze the assembly
    code in order to deduce what pointer path it used to access the value, but doing
    so is very time-consuming and requires advanced tools. *Pointer scanners* solve
    this problem by using brute-force to recursively iterate over every possible pointer
    chain until they find one that resolves to the target memory address.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 从逆向工程的角度来看，你可以定位并分析汇编代码，从而推断它使用的指针路径来访问该值，但这样做非常耗时且需要高级工具。*指针扫描器*通过暴力破解的方法递归遍历每一个可能的指针链，直到找到一个可以解析到目标内存地址的链。
- en: The [Listing 1-1](ch01.xhtml#ch1exe1) pseudocode should give you a general idea
    of how a pointer scanner works.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: '[清单1-1](ch01.xhtml#ch1exe1)中的伪代码应该能让你大致了解指针扫描器是如何工作的。'
- en: '[PRE4]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '*Listing 1-1: Pseudocode for a pointer scanner*'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单1-1：指针扫描的伪代码*'
- en: This code creates the functions `pointerScan()` and `rScan()`.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码创建了`pointerScan()`和`rScan()`这两个函数。
- en: '**pointerScan()**'
  id: totrans-108
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**pointerScan()**'
- en: The `pointerScan()` function is the entry point to the scan. It takes the parameters
    `target` (the dynamic memory address to find), `maxAdd` (the maximum value of
    any offset), and `maxDepth` (the maximum length of the pointer path). It then
    loops through every 4-byte aligned address ➊ in the game, calling `rScan()` with
    the parameters `address` (the address in the current iteration), `target`, `maxAdd`,
    `maxDepth`, and `curDepth` (the depth of the path, which is always 1 in this case).
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: '`pointerScan()` 函数是扫描的入口点。它接受以下参数：`target`（要查找的动态内存地址），`maxAdd`（任何偏移量的最大值），以及
    `maxDepth`（指针路径的最大长度）。然后，它会遍历游戏中的每个 4 字节对齐的地址 ➊，并使用参数 `address`（当前迭代中的地址）、`target`、`maxAdd`、`maxDepth`
    和 `curDepth`（路径的深度，此时始终为 1）调用 `rScan()`。'
- en: '**rScan()**'
  id: totrans-110
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**rScan()**'
- en: The `rScan()` function reads memory from every 4-byte aligned offset between
    `0` and `maxAdd` ➋, and returns if a result is equal to `target` ➌. If `rScan()`
    doesn’t return in the first loop and the recursion is not too deep ➍, it increments
    `curDepth` and again loops over each offset ➎, calling itself for each iteration.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: '`rScan()` 函数从 `0` 到 `maxAdd` 之间的每个 4 字节对齐偏移量 ➋ 读取内存，并在结果等于 `target` ➌ 时返回。如果
    `rScan()` 在第一次循环中没有返回，且递归深度不太深 ➍，它会递增 `curDepth` 并再次循环每个偏移量 ➎，对每次迭代进行自我调用。'
- en: If a self call returns a partial pointer path ➏, `rScan()` will prepend the
    current offset to the path and return up the recursion chain ➐ until it reaches
    `pointerScan()`. When a call to `rScan()` from `pointerScan()` returns a pointer
    path, `pointerScan()` pushes the current address to the front of the path and
    returns it as a complete chain.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 如果自调用返回一个部分指针路径 ➏，`rScan()` 会将当前偏移量添加到路径前，并沿着递归链向上返回 ➐，直到它到达 `pointerScan()`。当从
    `pointerScan()` 调用 `rScan()` 并返回一个指针路径时，`pointerScan()` 会将当前地址推送到路径的前面，并将其作为完整的链条返回。
- en: '***Pointer Scanning with Cheat Engine***'
  id: totrans-113
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***使用 Cheat Engine 进行指针扫描***'
- en: The previous example showed the basic process of pointer scanning, but the implementation
    I’ve shown is primitive. Aside from being insanely slow to execute, it would generate
    countless false positives. Cheat Engine’s pointer scanner uses a number of advanced
    interpolations to speed up the scan and make it more accurate, and in this section,
    I’ll introduce you to the smorgasbord of available scanning options.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的示例展示了指针扫描的基本过程，但我展示的实现方式比较原始。除了执行速度极慢外，它还会生成无数的假阳性。Cheat Engine 的指针扫描器使用了许多高级插值方法来加速扫描并提高其准确性，在本节中，我将向你介绍可用的各种扫描选项。
- en: To initiate a pointer scan in Cheat Engine, right-click on a dynamic memory
    address in your cheat table and click **Pointer scan for this address**. When
    you initiate a pointer scan, Cheat Engine will ask you where to store the scan
    results as a *.ptr* file. Once you enter a location, a Pointerscanner scanoptions
    dialog similar to the one shown in [Figure 1-4](ch01.xhtml#ch1fig4) will appear.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 要在 Cheat Engine 中启动指针扫描，右键点击你的作弊表中的动态内存地址，然后点击 **Pointer scan for this address**。当你启动指针扫描时，Cheat
    Engine 会询问你将扫描结果存储为 *.ptr* 文件的位置。一旦你输入了位置，类似 [图 1-4](ch01.xhtml#ch1fig4) 所示的指针扫描选项对话框将会出现。
- en: '![image](../images/f01-04.jpg)'
  id: totrans-116
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f01-04.jpg)'
- en: '*Figure 1-4: Cheat Engine Pointerscanner scanoptions dialog*'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 1-4：Cheat Engine 指针扫描选项对话框*'
- en: The Address to find input field at the top displays your dynamic memory address.
    Now carefully select from among Cheat Engine’s many scan options.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 顶部的“查找地址”输入字段显示的是你的动态内存地址。现在，仔细从 Cheat Engine 的多种扫描选项中选择。
- en: '**Key Options**'
  id: totrans-119
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**关键选项**'
- en: 'Several of Cheat Engine’s scan options typically retain their default values.
    Those options are as follows:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: Cheat Engine 的几个扫描选项通常保留默认值。以下是这些选项：
- en: '**Addresses must be 32-bits aligned** Tells Cheat Engine to scan only addresses
    that are multiples of 4, which greatly increases the scan speed. As you’ll learn
    in [Chapter 4](ch04.xhtml#ch04), compilers align data so that most addresses will
    be multiples of 4 anyway by default. You’ll rarely need to disable this option.'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: '**地址必须是 32 位对齐** 告诉 Cheat Engine 只扫描 4 的倍数的地址，这大大提高了扫描速度。正如你在 [第 4 章](ch04.xhtml#ch04)
    中将学到的那样，编译器会对数据进行对齐，因此大多数地址默认情况下会是 4 的倍数。你很少需要禁用这个选项。'
- en: '**Only find paths with a static address** Speeds up the scan by preventing
    Cheat Engine from searching paths with a dynamic start pointer. This option should
    *always* be enabled because scanning for a path starting at another dynamic address
    can be counterproductive.'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: '**仅查找具有静态地址的路径** 通过防止 Cheat Engine 查找具有动态起始指针的路径来加速扫描。这个选项应该 *始终* 启用，因为扫描从另一个动态地址开始的路径可能会适得其反。'
- en: '**Don’t include pointers with read-only nodes** Should also always be enabled.
    Dynamically allocated memory that stores volatile data should never be read-only.'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: '**不包含只读节点的指针** 也应该始终启用。存储易变数据的动态分配内存不应为只读。'
- en: '**Stop traversing a path when a static has been found** Terminates the scan
    when it finds a pointer path with a static start address. This should be enabled
    to reduce false positives and speed up the scan.'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: '**当找到静态地址时停止遍历路径** 当发现指向静态起始地址的指针路径时终止扫描。应该启用此选项，以减少假阳性并加速扫描。'
- en: '**Pointer path may only be inside this region** Can typically be left as is.
    The other options available to you compensate for this large range by intelligently
    narrowing the scope of the scan.'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: '**指针路径仅限于此区域内** 通常可以保持默认设置。你可以使用的其他选项通过智能缩小扫描范围来弥补这一大范围。'
- en: '**First element of pointerstruct must point to module** Tells Cheat Engine
    not to search heap chunks in which virtual function tables are not found, under
    the assumption that the game was coded using object orientation. While this setting
    can immensely speed up scans, it’s highly unreliable and you should almost always
    leave it disabled.'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: '**指针结构的第一个元素必须指向模块** 告诉 Cheat Engine 不要搜索那些未找到虚函数表的堆块，假设游戏是使用面向对象编程方法编写的。虽然这个设置可以极大地加速扫描，但它非常不可靠，你几乎总是应该将其禁用。'
- en: '**No looping pointers** Invalidates any paths that point to themselves, weeding
    out inefficient paths but slightly slowing down the scan. This should usually
    be enabled.'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: '**无循环指针** 使任何指向自身的路径无效，从而筛除低效路径，但会稍微降低扫描速度。通常应该启用此选项。'
- en: '**Max level** Determines the maximum length of the pointer path. (Remember
    the `maxDepth` variable in the example code in [Listing 1-1](ch01.xhtml#ch1exe1)?)
    This should be kept around 6 or 7.'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: '**最大层级** 确定指针路径的最大长度。（记得 [Listing 1-1](ch01.xhtml#ch1exe1) 示例代码中的 `maxDepth`
    变量吗？）这个值应该保持在 6 或 7 左右。'
- en: Of course, there will be times when you’ll need to change these options from
    the settings described. For example, failing to obtain reliable results with the
    No looping pointers or Max level settings typically means that the value you’re
    looking for exists in a dynamic data structure, like a linked list, binary tree,
    or vector. Another example is the Stop traversing a path when a static has been
    found option, which in rare cases can prevent you from getting reliable results.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，也会有需要改变这些选项的情况。例如，如果使用“无循环指针”或“最大层级”设置时无法获得可靠结果，通常意味着你正在寻找的值存在于一个动态数据结构中，比如链表、二叉树或向量。另一个例子是“当找到静态地址时停止遍历路径”选项，在少数情况下，它可能会阻止你获得可靠的结果。
- en: '**Situational Options**'
  id: totrans-130
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**情况性选项**'
- en: 'Unlike the previous options, your settings for the remaining ones will depend
    on your situation. Here’s how to determine the best configuration for each:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 与之前的选项不同，其余设置的配置将取决于你的情况。以下是如何为每个设置确定最佳配置：
- en: '**Improve pointerscan with gathered heap data** Allows Cheat Engine to use
    the heap allocation record to determine offset limits, effectively speeding up
    the scan by weeding out many false positives. If you run into a game using a custom
    memory allocator (which is becoming increasingly common), this option can actually
    do the exact opposite of what it’s meant to do. You can leave this setting enabled
    in initial scans, but it should be the first to go when you’re unable to find
    reliable paths.'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: '**使用收集的堆数据改善指针扫描** 允许 Cheat Engine 使用堆分配记录来确定偏移限制，从而有效地通过筛除许多假阳性来加速扫描。如果你遇到使用自定义内存分配器的游戏（这种情况越来越常见），这个选项实际上可能会做出与其预期相反的效果。在初次扫描时可以启用此设置，但当你无法找到可靠路径时，它应该是第一个禁用的选项。'
- en: '**Only allow static and heap addresses in the path** Invalidates all paths
    that can’t be optimized with heap data, making this approach even more aggressive.'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: '**路径中只允许静态和堆地址** 使所有无法通过堆数据优化的路径无效，从而使该方法更加激进。'
- en: '**Max different offsets per node** Limits the number of same-value pointers
    the scanner checks. That is, if *n* different addresses point to `0x0BADF00D`,
    this option tells Cheat Engine to consider only the first *m* addresses. This
    can be extremely helpful when you’re unable to narrow down your result set. In
    other cases, you may want to disable it, as it will miss many valid paths.'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: '**每个节点的最大不同偏移量** 限制扫描器检查的相同值指针的数量。也就是说，如果 *n* 个不同的地址指向 `0x0BADF00D`，此选项告诉 Cheat
    Engine 只考虑前 *m* 个地址。当你无法缩小结果集时，这个选项可以非常有帮助。在其他情况下，你可能希望禁用它，因为它会错过许多有效的路径。'
- en: '**Allow stack addresses of the first thread(s) to be handled as static** Scans
    the call stacks of oldest *m* threads in the game, considering the first *n* bytes
    in each one. This allows Cheat Engine to scan the parameters and local variables
    of functions in the game’s call chain (the goal being to find variables used by
    the game’s main loop). The paths found with this option can be both highly volatile
    and extremely useful; I use it only when I fail to find heap addresses.'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: '**允许将第一线程的堆栈地址视为静态** 扫描游戏中最旧的 *m* 个线程的调用栈，考虑每个栈中前 *n* 字节。这使得 Cheat Engine 能够扫描游戏调用链中的函数参数和局部变量（目标是找到游戏主循环使用的变量）。使用此选项找到的路径既可能非常不稳定，又可能极其有用；当我无法找到堆地址时，我才会使用这个选项。'
- en: '**Stack addresses as only static address** Takes the previous option even further
    by allowing only stack addresses in pointer paths.'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: '**将堆栈地址视为唯一的静态地址** 通过仅允许堆栈地址出现在指针路径中，进一步加强了之前的选项。'
- en: '**Pointers must end with specific offsets** Can be useful if you know the offset(s)
    at the end of a valid path. This option will allow you to specify those offsets
    (starting with the last offset at the top), greatly reducing the scope of the
    scan.'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: '**指针必须以特定的偏移量结束** 如果你知道有效路径结尾的偏移量，这个选项会非常有用。它允许你指定这些偏移量（从最后一个偏移量开始），大大减少扫描的范围。'
- en: '**Nr of threads scanning** Determines how many threads the scanner will use.
    A number equal to the number of cores in your processor often works best. A drop-down
    menu with options allows you to specify the priority for each thread. Idle is
    best if you want your scan to go very slowly, Normal is what you should use for
    most scans, and Time critical is useful for lengthy scans but will render your
    computer useless for the scan duration.'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: '**扫描线程数** 确定扫描器将使用多少个线程。通常，线程数设置为与处理器核心数相同效果最佳。下拉菜单中的选项允许你为每个线程指定优先级。如果你希望扫描非常缓慢，选择“空闲”最合适；如果是大多数扫描，选择“正常”；“时间关键”适用于长时间的扫描，但会使你的电脑在扫描过程中变得无法使用。'
- en: '**Maximum offset value** Determines the maximum value of each offset in the
    path. (Remember the `maxAdd` variable in [Listing 1-1](ch01.xhtml#ch1exe1)?) I
    typically start with a low value, increasing it only if my scan fails; `128` is
    a good starting value. Keep in mind that this value is mostly ignored if you’re
    using the heap optimization options.'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: '**最大偏移量值** 确定路径中每个偏移量的最大值。（记得 [Listing 1-1](ch01.xhtml#ch1exe1) 中的 `maxAdd`
    变量吗？）我通常从一个较低的值开始，只有当扫描失败时才会增加它；`128` 是一个不错的起始值。请记住，如果你使用的是堆优化选项，这个值大多会被忽略。'
- en: '**NOTE**'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*What if both Only allow static and heap addresses in the path and Stack addresses
    as only static address are enabled? Will the scan come up empty? Seems like a
    fun, albeit useless, experiment.*'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: '*如果同时启用了“仅允许路径中的静态和堆地址”和“将堆栈地址视为唯一的静态地址”选项，会怎么样？扫描会没有结果吗？看起来像是一个有趣的实验，尽管它可能没什么用。*'
- en: Once you have defined your scan options, click **OK** to start a pointer scan.
    When the scan completes, a results window will appear with the list of pointer
    chains found. This list often has thousands of results, containing both real chains
    and false positives.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 定义扫描选项后，点击 **确定** 开始指针扫描。当扫描完成后，会出现一个结果窗口，显示找到的指针链列表。这个列表通常会有数千个结果，包含了真实链和误报。
- en: '***Pointer Rescanning***'
  id: totrans-143
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***指针重扫***'
- en: The pointer scanner has a rescan feature that can help you eliminate false positives.
    To begin, press CTRL-R from the results window to open the Rescan pointerlist
    dialog, as shown in [Figure 1-5](ch01.xhtml#ch1fig5).
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 指针扫描器有一个重扫功能，可以帮助你消除误报。首先，在结果窗口中按 CTRL-R 打开重扫指针列表对话框，如 [图 1-5](ch01.xhtml#ch1fig5)
    所示。
- en: '![image](../images/f01-05.jpg)'
  id: totrans-145
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f01-05.jpg)'
- en: '*Figure 1-5: Cheat Engine Rescan pointerlist dialog*'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 1-5：Cheat Engine 重扫指针列表对话框*'
- en: 'There are two main options to consider when you tell Cheat Engine to rescan:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 在告诉 Cheat Engine 进行重扫时，有两个主要选项需要考虑：
- en: '**Only filter out invalid pointers** If you check this box ➊, the rescan will
    discard only pointer chains that point to invalid memory, which helps if your
    initial result set is very large. Disable this to filter out paths that don’t
    resolve to a specific address or value (as shown in the figure).'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: '**仅过滤无效指针** 如果你勾选这个框 ➊，重扫将仅丢弃指向无效内存的指针链，这在初始结果集非常大的时候会很有帮助。禁用此选项则会过滤掉那些没有解析到特定地址或值的路径（如图所示）。'
- en: '**Repeat rescan until stopped** If you check this box ➋, the rescan will execute
    in a continuous loop. Ideally, you should enable this setting and let rescan run
    while you create a large amount of memory entropy.'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: '**重复重扫直到停止** 如果你勾选此框 ➋，重扫将以循环方式执行。理想情况下，你应该启用此设置并让重扫在你创建大量内存熵时运行。'
- en: For the initial rescan, enable both **Only filter out invalid pointers** and
    **Repeat rescan until stopped**, and then press **OK** to initiate the rescan.
    The rescan window will go away, and a Stop rescan loop button will appear in the
    results window. The result list will be constantly rescanned until you click Stop
    rescan loop, but spend a few minutes creating memory entropy before doing so.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 对于初始重扫，启用 **仅过滤无效指针** 和 **重复重扫直到停止**，然后按 **确定** 以启动重扫。重扫窗口将消失，结果窗口中会出现一个“停止重扫循环”按钮。结果列表将持续重扫，直到你点击停止重扫循环，但在此之前，花几分钟创建内存熵。
- en: In rare cases, rescanning using a rescan loop may still leave you with a large
    list of possible paths. When this happens, you may need to restart the game, find
    the address that holds your value (it may have changed!), and use the rescan feature
    on this address to further narrow results. In this scan, leave **Only filter out
    invalid pointers** unchecked and enter the *new* address in the **Address to find**
    field.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 在极少数情况下，使用重扫循环可能仍然会留下一个较大的可能路径列表。当这种情况发生时，你可能需要重新启动游戏，找到保存你值的地址（它可能已更改！），并在该地址上使用重扫功能进一步缩小结果范围。在此扫描中，保持
    **仅过滤无效指针** 取消选中，并在 **查找的地址** 字段中输入 *新的* 地址。
- en: '**NOTE**'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*If you had to close the results window, you can reopen it and load the result
    list by going to the main Cheat Engine window and pressing the Memory View button
    below the results pane. This should bring up a memory dump window. When the window
    appears, press CTRL-P to open the pointer scan results list. Then press CTRL-O
    to open the* .ptr *file where you saved the pointer scan.*'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: '*如果你不得不关闭结果窗口，你可以重新打开它，并通过进入主 Cheat Engine 窗口，按下结果窗格下方的内存视图按钮来加载结果列表。这应该会弹出一个内存转储窗口。窗口出现后，按
    CTRL-P 打开指针扫描结果列表。然后按 CTRL-O 打开你保存指针扫描的 *.ptr* 文件。*'
- en: If your results still aren’t narrow enough, try running the same scan across
    system restarts or even on different systems. If this still yields a large result
    set, each result can safely be considered static because more than one pointer
    chain can resolve to the same address.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你的结果仍然不够精确，尝试在系统重启后，甚至在不同的系统上运行相同的扫描。如果这仍然产生较大的结果集，则可以安全地认为每个结果是静态的，因为多个指针链可能会解析到相同的地址。
- en: Once you’ve narrowed down your result set, double-click on a usable pointer
    chain to add it to your cheat table. If you have a handful of seemingly usable
    chains, grab the one with the fewest offsets. If you find multiple chains with
    identical offsets that start with the same pointer but diverge after a certain
    point, your data may be stored in a dynamic data structure.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你缩小了结果集的范围，双击一个可用的指针链，将其添加到作弊表中。如果你有几条看似可用的链，选择偏移量最少的那一条。如果你发现有多个指针链的偏移量完全相同且起始指针相同，但在某一点后分岔，那么你的数据可能存储在动态数据结构中。
- en: That’s all there is to pointer scanning in Cheat Engine. Try it yourself!
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是 Cheat Engine 中指针扫描的全部内容。试试看吧！
- en: '**POINTER SCANNING**'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: '**指针扫描**'
- en: 'Go to *[https://www.nostarch.com/gamehacking/](https://www.nostarch.com/gamehacking/)*
    and download *MemoryPointers.exe*. Unlike the last task, which required you to
    win only once, this one requires that you win 50 times in 10 seconds. Upon each
    win, the memory addresses for the x- and y-coordinates will change, meaning you
    will be able to freeze the value only if you have found a proper pointer path.
    Start this exercise the same way as the previous one, but once you’ve found the
    addresses, use the Pointer scan feature to locate pointer paths to them. Then,
    place the ball on top of the black square, freeze the value in place, and press
    TAB to begin the test. Just as before, the game will let you know once you’ve
    won. (Hint: Try setting the maximum level to `5` and the maximum offset value
    to `512`. Also, play with the options to allow stack addresses, terminate the
    scan when a static is found, and improve the pointer scan with heap data. See
    which combination of options gives the best results.)'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 访问 *[https://www.nostarch.com/gamehacking/](https://www.nostarch.com/gamehacking/)*
    并下载 *MemoryPointers.exe*。与上一个任务不同，这个任务要求你在 10 秒内赢得 50 次。每次获胜后，x 和 y 坐标的内存地址将会变化，意味着你只能在找到合适的指针路径时冻结该值。像前一个任务一样开始此练习，但一旦找到地址，使用指针扫描功能来定位指针路径。然后，将球放在黑色方块上，冻结该值，并按
    TAB 开始测试。就像之前一样，游戏会在你获胜后告知你。（提示：尝试将最大级别设置为 `5`，最大偏移值设置为 `512`。此外，可以调整选项来允许堆栈地址，找到静态时终止扫描，并通过堆数据改善指针扫描。看看哪种选项组合能给出最佳结果。）
- en: '**Lua Scripting Environment**'
  id: totrans-159
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**Lua 脚本环境**'
- en: Historically, bot developers rarely used Cheat Engine to update their addresses
    when a game released a patch because it was much easier to do so in OllyDbg. This
    made Cheat Engine useless to game hackers other than for initial research and
    development—that is, until a powerful Lua-based embedded scripting engine was
    implemented around Cheat Engine’s robust scanning environment. While this engine
    was created to enable the development of simple bots within Cheat Engine, professional
    game hackers found they could also use it to easily write complex scripts to automatically
    locate addresses across different versions of a game’s binary—a task that might
    otherwise take hours.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 历史上，机器人开发者在游戏发布补丁时很少使用 Cheat Engine 来更新地址，因为在 OllyDbg 中这样做要容易得多。这使得 Cheat Engine
    对游戏黑客除了初期研究和开发外几乎没有用处——直到一个强大的基于 Lua 的嵌入式脚本引擎在 Cheat Engine 强大的扫描环境中实现。虽然这个引擎是为了在
    Cheat Engine 中开发简单的机器人而创建的，但专业游戏黑客发现他们也可以利用它轻松编写复杂的脚本，自动定位不同版本游戏二进制文件中的地址——否则这个任务可能需要几个小时。
- en: '**NOTE**'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*You’ll find more detail about the Cheat Engine Lua scripting engine on the
    wiki at* [http://wiki.cheatengine.org/](http://wiki.cheatengine.org/).'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: '*你可以在 wiki 上找到有关 Cheat Engine Lua 脚本引擎的更多详细信息，网址是* [http://wiki.cheatengine.org/](http://wiki.cheatengine.org/)。'
- en: To start using the Lua engine, press CTRL-ALT-L from the main Cheat Engine window.
    Once the window opens, write your script in the text area and click **Execute
    script** to run it. Save a script with CTRL-S and open a saved script with CTRL-O.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 要开始使用 Lua 引擎，从主 Cheat Engine 窗口按 CTRL-ALT-L。窗口打开后，在文本区域编写你的脚本，并点击 **执行脚本** 来运行它。使用
    CTRL-S 保存脚本，使用 CTRL-O 打开已保存的脚本。
- en: The scripting engine has hundreds of functions and infinite use cases, so I’ll
    give you just a glimpse of its abilities by breaking down two scripts. Every game
    is different and every game hacker writes scripts to accomplish unique goals,
    so these scripts are only useful for demonstrating concepts.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 脚本引擎有数百个函数和无限的使用案例，因此我将通过分解两个脚本来让你了解它的一部分能力。每个游戏都是不同的，每个游戏黑客编写脚本来实现独特的目标，所以这些脚本仅用于演示概念。
- en: '***Searching for Assembly Patterns***'
  id: totrans-165
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***搜索汇编模式***'
- en: This first script locates functions that compose outgoing packets and sends
    them to the game server. It works by searching a game’s assembly code for functions
    that contain a certain code sequence.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个脚本定位组成出站数据包的函数，并将它们发送到游戏服务器。它通过在游戏的汇编代码中搜索包含特定代码序列的函数来工作。
- en: '[PRE5]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The code begins by getting the base address of the module that Cheat Engine
    is attached to ➊. Once it has the base address, the function `LocatePacketCreation()`
    is defined ➋. This function loops through the first `0x2FFFFFF` bytes of memory
    in the game ➌, searching for a sequence that represents this x86 assembler code:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 代码首先获取 Cheat Engine 附加的模块的基地址 ➊。获得基地址后，定义了函数 `LocatePacketCreation()` ➋。这个函数循环遍历游戏中前
    `0x2FFFFFF` 字节的内存 ➌，搜索一个代表此 x86 汇编代码的序列：
- en: '[PRE6]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The function checks that the type is equal to `packetType`, but it doesn’t care
    what the function offset is ➍. Once this sequence is found, the function returns.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 该函数检查类型是否等于`packetType`，但它不关心函数偏移量是什么 ➍。一旦找到这个序列，函数就会返回。
- en: 'Next, the `LocateFunctionHead()` function is defined ➎. The function backtracks
    up to 0x1FFF bytes from a given address ➏, and at each address, it checks for
    a stub of assembler code ➐ that looks something like this:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，定义了`LocateFunctionHead()`函数 ➎。该函数从给定地址回溯最多0x1FFF字节 ➏，并在每个地址处检查一个看起来像这样的汇编代码存根
    ➐：
- en: '[PRE7]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: This stub will be present at the beginning of every function, because it’s part
    of the function prologue that sets up the function’s stack frame. Once it finds
    the code, the function will return the address of the stub plus 1 ➑ (the first
    byte, `0xCC`, is padding).
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 这个存根将在每个函数的开头出现，因为它是设置函数堆栈帧的函数前言的一部分。一旦找到代码，函数将返回存根的地址加1 ➑（第一个字节`0xCC`是填充字节）。
- en: 'To tie these steps together, the `LocatePacketCreation()` function is called
    with the `packetType` that I’m looking for (arbitrarily `0x64`) and the resulting
    address is passed into the `LocateFunctionHead()` function ➒. This effectively
    locates the first function that pushes `packetType` into a function call and stores
    its address in `funcAddress`. This stub shows the result:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 为了将这些步骤串联起来，调用`LocatePacketCreation()`函数，并传入我正在寻找的`packetType`（随意设为`0x64`），然后将得到的地址传递给`LocateFunctionHead()`函数
    ➒。这实际上定位了第一个将`packetType`传递到函数调用中的函数，并将其地址存储在`funcAddress`中。这个代码片段显示了结果：
- en: '[PRE8]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: This 35-line script can automatically locate 15 different functions in under
    a minute.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 这个35行的脚本可以在不到一分钟的时间内自动定位15个不同的函数。
- en: '***Searching for Strings***'
  id: totrans-177
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***搜索字符串***'
- en: This next Lua script scans a game’s memory for text strings. It works much as
    the Cheat Engine’s memory scanner does when you use the string value type.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来的Lua脚本扫描游戏内存中的文本字符串。它的工作方式与在Cheat Engine中使用字符串值类型时的内存扫描器相似。
- en: '[PRE9]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: After getting the base address, the `findString()` function is defined ➊, which
    takes a string, `str`, as a parameter. This function loops through the game’s
    memory ➍ in 4,096-byte-long chunks ➋. The chunks are scanned sequentially, each
    one starting `len` (the length of `str`) bytes before the end of the previous
    one ➌ to prevent missing a string that begins on one chunk and ends on another.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 在获取基本地址后，定义了`findString()`函数 ➊，该函数将一个字符串`str`作为参数。该函数会以4,096字节为一块循环遍历游戏内存 ➍。数据块按顺序扫描，每个块的起始位置比上一个块的末尾提前`len`（`str`的长度）字节
    ➌，以防止遗漏从一个块开始、另一个块结束的字符串。
- en: As `findString()` reads each chunk, it iterates over every byte until the overlap
    point in the chunk ➎, passing each subchunk into the `checkForString()` function
    ➏. If `checkForString()` matches the subchunk to `str`, it prints the address
    of that subchunk to the console ➐.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 当`findString()`读取每个数据块时，它会遍历每个字节，直到数据块中的重叠点 ➎，然后将每个子块传递给`checkForString()`函数
    ➏。如果`checkForString()`将子块与`str`匹配，它会将该子块的地址打印到控制台 ➐。
- en: Lastly, to find all addresses that reference the strings `"hello"` and `"world"`,
    the functions `findString("hello")` ➑ and `findString("world")` ➒ are called.
    By using this code to search for embedded debug strings and pairing it with the
    previous code to locate function headers, I’m able to find a large number of internal
    functions within a game in mere seconds.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，为了查找所有引用字符串`"hello"`和`"world"`的地址，调用了`findString("hello")` ➑和`findString("world")`
    ➒。通过使用这段代码搜索嵌入的调试字符串，并将其与前面的代码结合使用来定位函数头，我能够在几秒钟内找到游戏中的大量内部函数。
- en: '**OPTIMIZING MEMORY CODE**'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: '**优化内存代码**'
- en: Due to the high overhead of memory reading, optimization is extremely important
    when you’re writing code that performs memory reads. In the previous code snippet,
    notice that the function `findString()` does not use the Lua engine’s builtin
    `readString()` function. Instead, it reads big chunks of memory and searches them
    for the desired string. Let’s break down the numbers.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 由于内存读取的高开销，当编写执行内存读取的代码时，优化非常重要。在之前的代码片段中，请注意`findString()`函数没有使用Lua引擎内建的`readString()`函数。相反，它会读取大块的内存并在其中搜索所需的字符串。让我们来分析一下这些数字。
- en: A scan using `readString()` would try to read a string of `len` bytes at every
    possible memory address. This means it would read, at most, `(0x2FFFFFF * len
    + len)` bytes. However, `findString()` reads chunks of 4,096 bytes and scans them
    locally for matching strings. This means it would read, at most, `(0x2FFFFFF +
    4096 + (0x2FFFFFF / (4096 - 10)) * len)` bytes. When searching for a string with
    a length of 10, the number of bytes that each method would read is 503,316,480
    and 50,458,923, respectively.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `readString()` 的扫描会尝试在每一个可能的内存地址处读取一个 `len` 字节的字符串。这意味着它最多会读取 `(0x2FFFFFF
    * len + len)` 字节。而 `findString()` 会读取 4,096 字节的块，并在本地扫描这些块中的匹配字符串。这意味着它最多会读取 `(0x2FFFFFF
    + 4096 + (0x2FFFFFF / (4096 - 10)) * len)` 字节。在查找一个长度为 10 的字符串时，每种方法读取的字节数分别为
    503,316,480 和 50,458,923 字节。
- en: Not only does `findString()` read an order of magnitude less data, it also invokes
    far fewer memory reads. Reading in chunks of 4,096 bytes would require a total
    of `(0x2FFFFFF / (4096 - len))` reads. Compare that to a scan using `readString()`,
    which would need `0x2FFFFFF` reads. The scan that uses `findString()` is a huge
    improvement because invoking a read is much more expensive than increasing the
    size of data being read. (Note that I chose 4,096 arbitrarily. I keep the chunk
    relatively small because reading memory can be time-consuming, and it might be
    wasteful to read four pages at a time just to find the string in the first.)
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: '`findString()` 不仅读取的数据量少一个数量级，而且调用的内存读取次数也大大减少。以 4,096 字节为单位进行分块读取，可能需要总共 `(0x2FFFFFF
    / (4096 - len))` 次读取。相比之下，使用 `readString()` 的扫描则需要 `0x2FFFFFF` 次读取。使用 `findString()`
    的扫描有了巨大的改进，因为调用读取操作的代价要比增加读取数据的大小要高得多。（注意，我选择 4,096 是随便挑的。由于读取内存可能非常耗时，我保持数据块相对较小，因为一次读取四页数据可能会浪费时间，仅仅是为了在第一页中找到字符串。）'
- en: '**Closing Thoughts**'
  id: totrans-187
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**结束语**'
- en: By this point, you should have a basic understanding of Cheat Engine and how
    it works. Cheat Engine is a very important tool in your kit, and I encourage you
    to get some hands-on experience with it by following “[Basic Memory Editing](ch01.xhtml#ch01sb01)”
    on [page 11](ch01.xhtml#page_11) and “[Pointer Scanning](ch01.xhtml#ch00lev1sec18)”
    on [page 18](ch01.xhtml#page_18) and playing around with it on your own.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 到这个阶段，你应该已经对 Cheat Engine 及其工作原理有了基本的理解。Cheat Engine 是你工具箱中非常重要的一项工具，我鼓励你通过阅读
    “[基本内存编辑](ch01.xhtml#ch01sb01)”（第 11 页）和 “[指针扫描](ch01.xhtml#ch00lev1sec18)”（第
    18 页），并自己动手实践，来积累一些使用经验。
