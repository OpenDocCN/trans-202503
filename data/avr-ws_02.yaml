- en: '[2](nsp-boxall502581-0008.xhtml#rch02)'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '[2](nsp-boxall502581-0008.xhtml#rch02)'
- en: First Steps
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第一阶段
- en: '![](images/nsp-boxall502581-ct.jpg)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![](images/nsp-boxall502581-ct.jpg)'
- en: Now that you’ve installed the requisite software and are prepared to enter the
    world of AVR microcontrollers, this chapter will ease you into your first AVR
    projects with some basic circuits and code.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，您已经安装了所需的软件，并准备好进入 AVR 微控制器的世界，本章将通过一些基础电路和代码带您轻松进入第一个 AVR 项目。
- en: 'In this chapter, you’ll learn how to:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，您将学习如何：
- en: • Test your setup for making AVR-based projects.
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: • 测试您的 AVR 项目设置。
- en: • Read basic circuit schematics.
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: • 阅读基础电路原理图。
- en: • Control LEDs with the digital output pins on both AVR microcontrollers, the
    ATtiny85 and the ATmega328P-PU.
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: • 使用 AVR 微控制器的数字输出引脚控制 LED，包括 ATtiny85 和 ATmega328P-PU。
- en: I’ll also show you how to start coding with `#define` macros and `for` loops,
    and how to use bitwise arithmetic and bit shifting to generate outputs efficiently.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 我还将向您展示如何使用 `#define` 宏和 `for` 循环开始编写代码，以及如何使用按位算术和位移操作高效生成输出。
- en: '[Testing the Hardware and Toolchain](nsp-boxall502581-0008.xhtml#rah0401)'
  id: totrans-9
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '[测试硬件和工具链](nsp-boxall502581-0008.xhtml#rah0401)'
- en: 'At this point, it’s wise to check that the USBasp programmer and the previously
    installed toolchain are working as expected. We’ll do this in three stages: by
    building a simple circuit, testing the USBasp, and uploading code to the microcontroller.'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 在此时，明智的做法是检查 USBasp 编程器和之前安装的工具链是否按预期工作。我们将通过三个阶段来检查：构建一个简单的电路，测试 USBasp，并将代码上传到微控制器。
- en: '[Build the Circuit](nsp-boxall502581-0008.xhtml#rbh0401)'
  id: totrans-11
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '[构建电路](nsp-boxall502581-0008.xhtml#rbh0401)'
- en: 'In this section you’ll build a simple device that flashes an LED on and off,
    which is a fun and simple way to test your hardware and toolchain. To get started,
    you’ll need the following hardware:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，您将构建一个简单的设备，使 LED 闪烁，这是测试硬件和工具链的一种有趣且简单的方法。要开始，您需要以下硬件：
- en: • USBasp programmer
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: • USBasp 编程器
- en: • Solderless breadboard
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: • 无焊面包板
- en: • ATtiny85–20PU microcontroller
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: • ATtiny85–20PU 微控制器
- en: • One 5 mm red LED
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: • 一个 5 毫米红色 LED
- en: • One 560 Ω resistor
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: • 一个 560 Ω 电阻
- en: • Seven jumper wires
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: • 七根跳线
- en: Now let’s focus on the practical steps of putting the circuit together to make
    sure your toolchain works correctly and will hold up when we dig into meatier
    projects. To connect the components of your test circuit, first place the solderless
    breadboard on a flat surface, as shown in [Figure 2-1](nsp-boxall502581-0012.xhtml#f02001)
    .
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们专注于实际步骤，将电路连接起来，以确保您的工具链正常工作，并在我们深入更复杂的项目时能够稳定运行。要连接测试电路的组件，首先将无焊面包板放置在平坦的表面上，如[图
    2-1](nsp-boxall502581-0012.xhtml#f02001)所示。
- en: '![Photo of a 400-hole solderless breadboard](images/nsp-boxall502581-f02001.jpg)'
  id: totrans-20
  prefs: []
  type: TYPE_IMG
  zh: '![400 孔无焊面包板的照片](images/nsp-boxall502581-f02001.jpg)'
- en: 'Figure 2-1: A solderless breadboard'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2-1：无焊面包板
- en: Insert your ATtiny85 into the breadboard so that it sits across the vertical
    gap in the board’s top four rows, as shown in [Figure 2-2](nsp-boxall502581-0012.xhtml#f02002)
    , making sure you insert the microcontroller’s pin 1—indicated by the small circle
    beside the leg, as described in [Chapter 1](nsp-boxall502581-0011.xhtml#ch01)
    —into column e, row 1 of the breadboard. The pins are numbered in a counterclockwise
    direction from 1, so pin 4 is at the bottom left in this figure, and pin 8 is
    at the top right.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 将 ATtiny85 插入面包板，使其横跨面包板顶部四行的垂直间隙，如[图 2-2](nsp-boxall502581-0012.xhtml#f02002)所示，确保将微控制器的引脚
    1——由引脚旁的小圆圈标记，如[第 1 章](nsp-boxall502581-0011.xhtml#ch01)中所描述——插入面包板的 e 列，第 1 行。引脚编号是按逆时针方向排列的，因此图中的引脚
    4 位于左下角，而引脚 8 位于右上角。
- en: '![Photo of an ATtiny85 microcontroller positioned at the top of a solderless
    breadboard](images/nsp-boxall502581-f02002.jpg)'
  id: totrans-23
  prefs: []
  type: TYPE_IMG
  zh: '![ATtiny85 微控制器放置在无焊面包板顶部的照片](images/nsp-boxall502581-f02002.jpg)'
- en: 'Figure 2-2: The AVR in the breadboard'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2-2：AVR 微控制器在面包板中的位置
- en: Now take the 560 Ω resistor and insert one leg in the same row as pin 2 of the
    ATtiny85 and the other leg a few rows farther along. In [Figure 2-3](nsp-boxall502581-0012.xhtml#f02003)
    , I’ve inserted the second leg into row 8.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，拿起 560 Ω 电阻，将一脚插入与 ATtiny85 引脚 2 相同的行，另一脚插入更远几行的位置。如[图 2-3](nsp-boxall502581-0012.xhtml#f02003)所示，我将第二脚插入第
    8 行。
- en: '![Adding the first resistor to the solderless breadboard from pin 2 of the
    microcontroller](images/nsp-boxall502581-f02003.jpg)'
  id: totrans-26
  prefs: []
  type: TYPE_IMG
  zh: '![将第一个电阻从微控制器引脚 2 插入无焊面包板的照片](images/nsp-boxall502581-f02003.jpg)'
- en: 'Figure 2-3: The resistor in the breadboard'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2-3：面包板中的电阻
- en: Next, take a look at your LED. Note that one leg is longer than the other, as
    shown in [Figure 2-4](nsp-boxall502581-0012.xhtml#f02004) .
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，看看你的 LED。注意，其中一条引脚比另一条长，如 [图 2-4](nsp-boxall502581-0012.xhtml#f02004) 所示。
- en: '![Photo of a red LED](images/nsp-boxall502581-f02004.jpg)'
  id: totrans-29
  prefs: []
  type: TYPE_IMG
  zh: '![红色 LED 的照片](images/nsp-boxall502581-f02004.jpg)'
- en: 'Figure 2-4: A typical LED'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2-4：典型的 LED
- en: Insert the LED into the solderless breadboard, with the longer leg in the same
    row as the lower end of the resistor (row 8 in our example) and the shorter leg
    two rows farther along, using [Figure 2-5](nsp-boxall502581-0012.xhtml#f02005)
    as a guide.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 将 LED 插入无焊接面包板中，较长的引脚与电阻的下端在同一排（在我们的例子中是第 8 排），较短的引脚则插入距其两排的地方，使用 [图 2-5](nsp-boxall502581-0012.xhtml#f02005)
    作为指南。
- en: '![Photo of the red LED inserted into the solderless breadboard, with the anode
    connected to the other end of the resistor](images/nsp-boxall502581-f02005.jpg)'
  id: totrans-32
  prefs: []
  type: TYPE_IMG
  zh: '![红色 LED 插入无焊接面包板中的照片，阳极连接到电阻的另一端](images/nsp-boxall502581-f02005.jpg)'
- en: 'Figure 2-5: Your circuit so far'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2-5：到目前为止的电路
- en: Take a jumper wire and insert one end into the same row as the LED’s shorter
    leg, then the other end into the same row as pin 4 of the ATtiny85, as demonstrated
    in [Figure 2-6](nsp-boxall502581-0012.xhtml#f02006) .
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 拿一根跳线，将一端插入 LED 较短引脚所在的同一排，另一端插入 ATtiny85 的 4 号引脚所在的同一排，如 [图 2-6](nsp-boxall502581-0012.xhtml#f02006)
    所示。
- en: '![Photo of the circuit with a jumper wire between the LED cathode and microcontroller
    ground pin](images/nsp-boxall502581-f02006.jpg)'
  id: totrans-35
  prefs: []
  type: TYPE_IMG
  zh: '![显示 LED 阴极和微控制器接地引脚之间连接的电路照片](images/nsp-boxall502581-f02006.jpg)'
- en: 'Figure 2-6: The wiring begins!'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2-6：接线开始了！
- en: Now that you’ve placed the components, I’ll show you how to get the code from
    your computer to the microcontroller with the AVR programmer.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经放置好了组件，我将向你展示如何通过 AVR 编程器将代码从电脑传输到微控制器。
- en: '[Connect and Run the Programmer](nsp-boxall502581-0008.xhtml#rbh0402)'
  id: totrans-38
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '[连接并运行编程器](nsp-boxall502581-0008.xhtml#rbh0402)'
- en: To connect the USBasp programmer to the breadboard, first connect six male to
    female jumper wires to the six connection pins on the USBasp, shown in [Figure 2-7](nsp-boxall502581-0012.xhtml#f02007)
    .
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 要将 USBasp 编程器连接到面包板，首先将六根公对母跳线连接到 USBasp 上的六个连接引脚，如 [图 2-7](nsp-boxall502581-0012.xhtml#f02007)
    所示。
- en: '![Photo of the connection pins on the USBasp programmer that connect to the
    circuit](images/nsp-boxall502581-f02007.jpg)'
  id: totrans-40
  prefs: []
  type: TYPE_IMG
  zh: '![USBasp 编程器连接引脚的照片，连接到电路](images/nsp-boxall502581-f02007.jpg)'
- en: 'Figure 2-7: USBasp connection pins'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2-7：USBasp 连接引脚
- en: Next, connect each of the USBasp’s six pins to the ATtiny85 using the mapping
    in [Table 2-1](nsp-boxall502581-0012.xhtml#tab0201) . You’ll use these same connections
    every time you program an ATtiny85 microcontroller. Don’t worry for now about
    the meaning of the pin labels; I’ll explain them to you as we go along in the
    book.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，使用 [表 2-1](nsp-boxall502581-0012.xhtml#tab0201) 中的映射，将 USBasp 的六个引脚连接到 ATtiny85。每次你编程
    ATtiny85 微控制器时，都需要使用这些相同的连接。现在不用担心引脚标签的含义，我将在书中逐步为你解释。
- en: '| Table 2-1 : USBasp to ATtiny85 Connections |'
  id: totrans-43
  prefs: []
  type: TYPE_TB
  zh: '| 表 2-1：USBasp 到 ATtiny85 的连接 |'
- en: '| --- |'
  id: totrans-44
  prefs: []
  type: TYPE_TB
  zh: '| --- |'
- en: '| USBasp pin | ATtiny85 pin |'
  id: totrans-45
  prefs: []
  type: TYPE_TB
  zh: '| USBasp 引脚 | ATtiny85 引脚 |'
- en: '| --- | --- |'
  id: totrans-46
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| RST | 1 |'
  id: totrans-47
  prefs: []
  type: TYPE_TB
  zh: '| RST | 1 |'
- en: '| GND | 4 |'
  id: totrans-48
  prefs: []
  type: TYPE_TB
  zh: '| GND | 4 |'
- en: '| VCC | 8 |'
  id: totrans-49
  prefs: []
  type: TYPE_TB
  zh: '| VCC | 8 |'
- en: '| SCK | 7 |'
  id: totrans-50
  prefs: []
  type: TYPE_TB
  zh: '| SCK | 7 |'
- en: '| MISO | 6 |'
  id: totrans-51
  prefs: []
  type: TYPE_TB
  zh: '| MISO | 6 |'
- en: '| MOSI | 5 |'
  id: totrans-52
  prefs: []
  type: TYPE_TB
  zh: '| MOSI | 5 |'
- en: '[Figure 2-8](nsp-boxall502581-0012.xhtml#f02008) illustrates the connections
    between the USBasp and an ATtiny85 described in [Table 2-1](nsp-boxall502581-0012.xhtml#tab0201)
    . I’ve removed the rest of the circuit to show just an example of the connections.'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 2-8](nsp-boxall502581-0012.xhtml#f02008) 展示了 USBasp 和 ATtiny85 之间的连接，具体描述见
    [表 2-1](nsp-boxall502581-0012.xhtml#tab0201)。我已移除电路的其余部分，仅展示了连接的示例。'
- en: '![Photo showing the six connections between the USBasp programmer and the microcontroller
    on the solderless breadboard](images/nsp-boxall502581-f02008.jpg)'
  id: totrans-54
  prefs: []
  type: TYPE_IMG
  zh: '![展示 USBasp 编程器和微控制器之间六个连接的照片，位于无焊接面包板上](images/nsp-boxall502581-f02008.jpg)'
- en: 'Figure 2-8: A USBasp connected to an ATtiny85 on a solderless breadboard'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2-8：USBasp 连接到 ATtiny85 上的无焊接面包板
- en: 'Next, check the USBasp is working correctly by connecting your USBasp programmer
    to your computer. To do this, you’ll use a program that’s part of the installed
    toolchain called AVRDUDE, which is a utility to upload code to AVR microcontrollers.
    Open a terminal window and enter the command `avrdude -p t85 -c usbasp -B 4` .
    This command includes the following options:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，检查 USBasp 是否正常工作，将你的 USBasp 编程器连接到电脑。为此，你需要使用一个名为 AVRDUDE 的程序，它是安装工具链的一部分，用于将代码上传到
    AVR 微控制器。打开终端窗口，输入命令 `avrdude -p t85 -c usbasp -B 4`。该命令包含以下选项：
- en: • `-p` selects the type of microcontroller being used in the project. You used
    `t85` just now for the ATtiny85, and later you’ll use `m328p` for the ATmega328P-PU.
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: • `-p` 选择项目中使用的微控制器类型。你刚才使用了 `t85` 代表 ATtiny85，稍后你将使用 `m328p` 代表 ATmega328P-PU。
- en: • `-c` selects the type of hardware programmer being used. In this case you’ve
    specified `usbasp` , representing your USBasp programmer.
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: • `-c` 选择正在使用的硬件编程器类型。在这种情况下，你指定了 `usbasp`，代表你的 USBasp 编程器。
- en: • `-B` sets the processing speed of the microcontroller in the USBasp programmer.
    You set this value to `4` to bring the speed down to 187.5 kHz. This is necessary
    for new microcontrollers, as they are set at the factory with a clock speed of
    1 MHz, which is slower than the USBasp’s default speed. I’ll explain more about
    speeds in [Chapter 12](nsp-boxall502581-0022.xhtml#ch12) .
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: • `-B` 设置 USBasp 编程器中微控制器的处理速度。你将该值设置为 `4`，将速度降低到 187.5 kHz。这对新微控制器是必要的，因为它们在出厂时的时钟速度为
    1 MHz，低于 USBasp 的默认速度。关于速度的更多内容，我将在[第 12 章](nsp-boxall502581-0022.xhtml#ch12)
    中解释。
- en: 'The software toolchain should interrogate the programmer and microcontroller,
    and your terminal should look something like this afterward:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 软件工具链应该与编程器和微控制器进行通信，你的终端显示应该像下面这样：
- en: '[PRE0]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: By reporting the *device signature* , a unique identifier for the type of AVR
    microcontroller, the software toolchain has indicated that all is well.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 通过报告*设备签名*，即 AVR 微控制器类型的唯一标识符，软件工具链表示一切正常。
- en: The AVRDUDE documentation ( [http://www.nongnu.org/avrdude/user-manual/avrdude_4.html](http://www.nongnu.org/avrdude/user-manual/avrdude_4.html)
    ) describes other options beyond those included in this `avrdude` command, if
    you’re curious. For now, if you saw the correct output after entering that command,
    skip ahead to [Project 0](nsp-boxall502581-0012.xhtml#pro0) . You’re ready to
    program your AVR!
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: AVRDUDE 文档（[http://www.nongnu.org/avrdude/user-manual/avrdude_4.html](http://www.nongnu.org/avrdude/user-manual/avrdude_4.html)）描述了除了
    `avrdude` 命令中包含的选项之外的其他选项，如果你感兴趣的话。目前，如果你在输入该命令后看到正确的输出，可以跳到[项目 0](nsp-boxall502581-0012.xhtml#pro0)。你已经准备好编程你的
    AVR 了！
- en: '[What If It Didn’t Work?](nsp-boxall502581-0008.xhtml#rbh0403)'
  id: totrans-64
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '[如果它没有成功怎么办？](nsp-boxall502581-0008.xhtml#rbh0403)'
- en: 'If, after running the command in the previous step, you got an error like the
    following, then there was a problem with the hardware connection between the programmer
    and the circuit:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在运行上一步骤中的命令后，出现类似下面的错误，那么说明编程器和电路之间的硬件连接存在问题：
- en: '[PRE1]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Don’t use `-F` to override the check, as the error message suggests. Instead,
    double-check the wiring between the USBasp and the solderless breadboard to make
    sure no connections are loose. Then check the circuit itself to confirm the components
    are connected to one another according to the instructions given in the “Build
    the Circuit” section. In particular, check that the ATtiny85’s pin 1 is aligned
    with the top-left corner of the breadboard. Orienting a chip incorrectly is one
    of the most common circuit errors!
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 不要像错误信息建议的那样使用 `-F` 来覆盖检查。相反，请仔细检查 USBasp 与无焊接面包板之间的连线，确保没有连接松动。然后检查电路本身，确认各个组件按“构建电路”部分的说明互相连接。特别是，检查
    ATtiny85 的引脚 1 是否与面包板的左上角对齐。错误地放置芯片是最常见的电路错误之一！
- en: If everything looks correct, try running the `avrdude` command again. It should
    work, but if it doesn’t, walk away for a few moments, then review the process
    again.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一切看起来都正确，再次尝试运行 `avrdude` 命令。它应该可以工作，但如果不行，离开几分钟，然后再回过头来复查整个过程。
- en: Using AVR Safely
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 安全使用 AVR
- en: 'As we move on to our [first project](nsp-boxall502581-0012.xhtml#pro0) , a
    reminder about safety: as with any hobby or craft, it’s up to you to take care
    of yourself and those around you. In this book, I discuss working with basic hand
    tools, battery-powered electrical devices, sharp knives, cutters, and sometimes
    hot soldering irons. *At no point in your projects should you work directly with
    AC mains current* . That is, don’t directly wire anything you make to the wall
    outlets. Leave that to a licensed electrician who is trained for such work. Remember
    that direct contact with AC current could kill you.'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们进入[第一个项目](nsp-boxall502581-0012.xhtml#pro0)之前，提醒大家注意安全：与任何爱好或手工艺一样，保护自己和周围的人是你的责任。在本书中，我讨论了使用基本手工工具、电池驱动的电器、锋利的刀具、切割工具，以及有时使用热烙铁。*在你的项目中，绝对不要直接接触交流电源*。也就是说，不要将你制作的任何东西直接连接到墙壁插座。把这部分交给经过训练的持证电工来处理。记住，直接接触交流电流可能致命。
- en: Once you’ve got your circuit working, keep it together, including the USBasp,
    as you’ll need all of this for the [first project](nsp-boxall502581-0012.xhtml#pro0)
    .
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你的电路工作正常，将它们保留在一起，包括 USBasp，因为你需要所有这些东西来完成 [第一个项目](nsp-boxall502581-0012.xhtml#pro0)。
- en: '[Project 0: Blinking an LED](nsp-boxall502581-0008.xhtml#rpro0)'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: '[Project 0: 闪烁 LED](nsp-boxall502581-0008.xhtml#rpro0)'
- en: Now that you have a working circuit and programmer connection, it’s time to
    create and upload your first *program* (also known as *code* ), a set of instructions
    that tells the microcontroller how to accomplish a particular task.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经有了一个工作的电路和编程器连接，是时候创建并上传你的第一个 *程序*（也称为 *代码*），这是一组指令，告诉微控制器如何完成某项特定任务。
- en: Over the course of this book, our programs will increase in length as the projects
    get more complex. Instead of typing out each piece of code included in the book,
    please download the ZIP file containing the book’s code from [http://www.nostarch.com/avr-workshop](http://www.nostarch.com/avr-workshop)
    . This file includes folders for each project (organized by chapter) that contain
    the code and anything else required to program the projects.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 随着本书项目的逐渐复杂，我们的程序会变得越来越长。为了避免手动输入书中每一段代码，请从 [http://www.nostarch.com/avr-workshop](http://www.nostarch.com/avr-workshop)
    下载包含本书代码的 ZIP 文件。该文件包含每个项目的文件夹（按章节组织），其中包含代码和完成项目编程所需的其他内容。
- en: Note If you’re reading an electronic version of this book, don’t copy and paste
    the code from the book into your text editor. Use the downloaded code files instead.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：如果你正在阅读本书的电子版，请不要直接从书中复制粘贴代码到文本编辑器中。请使用下载的代码文件。
- en: Projects in this book use the C programming language. Since C is popular across
    many microcontroller and computer platforms, it should be easy to find help if
    you need it and to share your work with others.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 本书中的项目使用 C 编程语言。由于 C 语言在许多微控制器和计算机平台中都很常见，因此如果你需要帮助或想与他人分享工作，应该很容易找到相关的支持。
- en: '[Uploading Your First AVR Code](nsp-boxall502581-0008.xhtml#rbh0404)'
  id: totrans-77
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '[上传你的第一个 AVR 代码](nsp-boxall502581-0008.xhtml#rbh0404)'
- en: Once you’ve downloaded and extracted the book’s code files, use a text editor
    to open the *main.c* file located in the *Project 0* subfolder of the *Chapter
    2* folder. This C file contains a small program that should cause your LED to
    blink on and off once you compile the code and upload it to the microcontroller.
    However, to get the desired effect, you’ll need to pair the C files for each of
    your projects with a *Makefile* .
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 下载并解压本书的代码文件后，使用文本编辑器打开 *Chapter 2* 文件夹中的 *Project 0* 子文件夹内的 *main.c* 文件。这个
    C 文件包含一个小程序，编译并上传到微控制器后，它应该会让你的 LED 闪烁。但为了实现预期效果，你需要将每个项目的 C 文件与 *Makefile* 配对使用。
- en: A Makefile contains a set of instructions for the toolchain to use when compiling
    and uploading your code to the microcontroller, including the microcontroller
    type, the CPU speed the microcontroller requires, and the type of programmer you
    plan to use. Every time you start a new project of your own, you should create
    a new folder for that project and place the *main.c* file and Makefile inside
    that folder. To save you time I’ve already done this for the [Project 0](nsp-boxall502581-0012.xhtml#pro0)
    files and for all the other projects in this book.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: Makefile 包含了一组供工具链在编译并上传代码到微控制器时使用的指令，其中包括微控制器类型、微控制器所需的 CPU 速度，以及你计划使用的编程器类型。每当你开始一个新项目时，都应该为该项目创建一个新文件夹，并将
    *main.c* 文件和 Makefile 放入该文件夹内。为了节省你的时间，我已经为 [Project 0](nsp-boxall502581-0012.xhtml#pro0)
    和本书中所有其他项目准备好了这些文件。
- en: If you’re curious about the contents of the Makefile, open the one for [Project
    0](nsp-boxall502581-0012.xhtml#pro0) with a text editor and take a look. I’ll
    introduce any necessary changes to the Makefiles in the download bundle for this
    book as you progress with the projects.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你对 Makefile 的内容感兴趣，可以用文本编辑器打开 [Project 0](nsp-boxall502581-0012.xhtml#pro0)
    目录下的 Makefile 文件查看。我会在你进行项目时，介绍书中下载包中 Makefile 的必要修改。
- en: Now that you’re familiar with these file types, it’s time to bring your [first
    project](nsp-boxall502581-0012.xhtml#pro0) to life using the circuit you constructed
    earlier in this chapter. If you closed it earlier, open a terminal window just
    as you did when testing the toolchain. Next, navigate to the folder containing
    the two files for [Project 0](nsp-boxall502581-0012.xhtml#pro0) , and enter the
    command `make flash` .
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 既然你已经熟悉了这些文件类型，现在是时候使用你在本章早些时候构建的电路来实现你的[第一个项目](nsp-boxall502581-0012.xhtml#pro0)了。如果你之前关闭了它，请像测试工具链时那样打开一个终端窗口。接下来，导航到包含[项目
    0](nsp-boxall502581-0012.xhtml#pro0)的两个文件的文件夹，并输入命令`make flash`。
- en: 'After a moment, the toolchain should compile the program file and create the
    required data file to upload to the microcontroller. The microcontroller should
    then start running the program; in this case, your LED should start blinking.
    During this process, the status should appear in the terminal window, as shown
    here:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 稍等片刻，工具链应当编译程序文件并创建所需的数据文件，以便上传到微控制器。微控制器随后应开始运行该程序；在这种情况下，你的LED应该开始闪烁。在此过程中，状态应显示在终端窗口中，如下所示：
- en: '[PRE2]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Let’s take a look at the code to see how this program works:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看一下代码，看看这个程序是如何工作的：
- en: '[PRE3]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The first line of *main.c* ❶ is a *comment* naming the program and describing
    what it’s intended to accomplish. When writing programs, it’s a good idea to add
    comments like these explaining how to use the program or highlighting other important
    details; they may prove useful when you revisit your code or share it with others.
    Comments can be any length you like, and you can use them anywhere in your program.
    To add a comment on a single line, enter two forward slashes and then the comment,
    like this:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: '*main.c*的第一行❶是一个*注释*，标明程序名称并描述其目标。当编写程序时，添加像这样的注释，解释如何使用程序或突出其他重要细节，是一个好习惯；当你回顾代码或与他人共享代码时，这些注释可能会非常有用。注释可以是任意长度的，且可以在程序的任何位置使用。要在单行中添加注释，只需输入两个正斜杠，然后写上注释，像这样：'
- en: '[PRE4]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The forward slashes tell the compiler in the software toolchain to ignore the
    rest of the text on the line when compiling the program. In your own projects,
    you can include comments spanning two or more lines by entering the characters
    `/*` on a line before the comment text, then ending the comment with the characters
    `*/` , as follows:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 正斜杠告诉软件工具链中的编译器，在编译程序时忽略行上的其余文本。在你自己的项目中，你可以通过在注释文本之前的行上输入`/*`字符，然后以`*/`字符结束注释，从而添加跨越两行或更多行的注释，如下所示：
- en: '[PRE5]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Returning to *main.c* , the `include` statements ❷ tell the compiler to look
    inside a library file, like *avr/io.h* , for more information required to compile
    the program. There are many libraries, each allowing you to use different functions
    in your code, and you can even create your own if necessary. You’ll learn about
    that in [Chapter 10](nsp-boxall502581-0020.xhtml#ch10) .
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 返回到*main.c*，`include`语句❷告诉编译器查找像*avr/io.h*这样的库文件，以获取编译程序所需的更多信息。有许多库，每个库允许你在代码中使用不同的功能，如果需要，你甚至可以创建自己的库。你将在[第10章](nsp-boxall502581-0020.xhtml#ch10)中学习到这方面的内容。
- en: All the instructions to run the program appear between the curly brackets after
    `int main(void)` , where the main section of the program begins ❸. Within these
    brackets, the program configures certain *parameters* of the microcontroller—that
    is, certain settings to make various operations take place. First, the program
    tells the microcontroller which physical pins will be inputs or outputs ❹. You
    hooked your LED up to pin 2, which the AVR knows as PB3, so the code activates
    that pin as an output. (Don’t worry if this is a little confusing right now; I’ll
    cover inputs and outputs in detail in the next few chapters.)
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 所有运行程序的指令都出现在`int main(void)`之后的花括号内，这里是程序的主要部分开始的位置❸。在这些花括号内，程序配置了微控制器的某些*参数*——也就是一些设置，用来使各种操作发生。首先，程序告诉微控制器哪些物理引脚将作为输入或输出❹。你将LED连接到引脚2，AVR将其识别为PB3，因此代码将该引脚设置为输出。（如果现在有些困惑，不用担心；我将在接下来的几章中详细介绍输入和输出。）
- en: Finally, the code between the curly brackets after `while(1)` ❺ should execute
    repeatedly, blinking the LED by continuously toggling whether pin 2 outputs a
    1 or a 0, until the microcontroller loses power or you reset it. A 1 supplies
    power to the LED, so that should turn the LED on, while a 0 should turn the LED
    off.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，`while(1)`后面花括号中的代码❺应当重复执行，通过持续切换引脚2是输出1还是0，来让LED闪烁，直到微控制器失去电力或你重置它。1为LED供电，这会使LED亮起，而0则使LED熄灭。
- en: To experiment with the speed of the LED’s blinking, go back to *main.c* and
    replace `1000` in the two lines that read `_delay_ms(1000);` with any non-negative
    number you like. Then save the *main.c* file and rerun the `make flash` command.
    The LED should blink faster or slower, depending on the value you use.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 要实验LED闪烁的速度，返回到*main.c*文件，将两行`_delay_ms(1000);`中的`1000`替换为你喜欢的任何非负数值。然后保存*main.c*文件，并重新运行`make
    flash`命令。LED应该会根据你使用的值闪烁得更快或更慢。
- en: '[What If It Didn’t Work?](nsp-boxall502581-0008.xhtml#rbh0405)'
  id: totrans-94
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '[如果它没有工作怎么办？](nsp-boxall502581-0008.xhtml#rbh0405)'
- en: 'If there is an error in your code, the compiler will indicate which line in
    the code contains the error, or a line very close to it. For example, here’s what
    happened when I ran the `make flash` command with a spelling mistake in line 10
    of the [Project 0](nsp-boxall502581-0012.xhtml#pro0) code. The compiler found
    the error and gave the resulting output:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 如果代码中有错误，编译器会指示出包含错误的代码行，或与其非常接近的行。例如，当我在[项目0](nsp-boxall502581-0012.xhtml#pro0)的第10行代码中拼写错误时，运行`make
    flash`命令时会发生如下情况。编译器找到了错误，并给出了相应的输出：
- en: '[PRE6]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: If this happens to you, open the *main.c* file in your text editor and locate
    and fix the mistake before trying another upload. To compile your program for
    this purpose without uploading it, just run the `make` command by itself in the
    terminal window.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 如果发生这种情况，打开*main.c*文件，在文本编辑器中找到并修正错误，然后再尝试上传。为了在不上传程序的情况下编译程序，只需在终端窗口中单独运行`make`命令。
- en: Running `make` is a good way to check for errors like typos in the code, but
    it may not help you catch errors in logic—that is, whether you’ve correctly told
    the microcontroller what you want it to do. As a general rule, remember that even
    if your program compiles, it may not behave as you expect if you don’t carefully
    plan your instructions to the microcontroller before you write the code.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 运行`make`命令是检查代码中错误（如拼写错误）的一种好方法，但它可能无法帮助你发现逻辑错误——即你是否正确地告诉了微控制器你希望它执行的操作。作为一般规则，记住即使程序能编译成功，如果你在编写代码前没有仔细规划给微控制器的指令，它也可能无法按预期行为运行。
- en: '[Controlling Digital Outputs](nsp-boxall502581-0008.xhtml#rah0402)'
  id: totrans-99
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '[控制数字输出](nsp-boxall502581-0008.xhtml#rah0402)'
- en: Now that you’ve seen the electronic components you’ll use in this book, let’s
    talk a bit more about the digital output pins on the ATtiny85 and the ATmega328P-PU.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经了解了本书中将使用的电子元件，让我们再谈谈ATtiny85和ATmega328P-PU上的数字输出引脚。
- en: To recap, a digital output pin is a source of electrical current that you can
    control; it can be either on or off. On the ATtiny85 up to six pins can operate
    as outputs, and on the ATmega328P-PU up to eight pins can operate as outputs.
    I say “up to” because some pins can have more than one function, depending on
    how you set them up. I’ll explain how to select pin functions later in this chapter.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 总结一下，数字输出引脚是一个可以控制的电流源；它可以是开（on）或关（off）。在ATtiny85上最多有六个引脚可以作为输出工作，在ATmega328P-PU上最多有八个引脚可以作为输出工作。我说“最多”是因为有些引脚可以有多个功能，具体取决于你如何设置它们。稍后我会在本章中解释如何选择引脚功能。
- en: Each output pin offers a maximum amount of current. On the ATtiny85, that maximum
    is 40 mA. However, the total maximum current you can run through the IC is 200
    mA. Drawing too much current can cause problems, so to avoid any issues, assume
    you can have a maximum of 20 mA per output pin on the ATtiny85 and the ATmega328P-PU.
    Keep these ratings in the back of your mind when creating your own projects; all the
    projects in this book are designed to avoid this problem.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 每个输出引脚提供的最大电流量是有限的。在ATtiny85上，这个最大值是40 mA。然而，你可以通过IC的总最大电流为200 mA。过多的电流可能会引发问题，因此为了避免任何问题，假设你在ATtiny85和ATmega328P-PU的每个输出引脚上最大电流为20
    mA。在创建自己的项目时，请记住这些额定值；本书中的所有项目都设计得能避免这个问题。
- en: '[Hardware Registers](nsp-boxall502581-0008.xhtml#rbh0406)'
  id: totrans-103
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '[硬件寄存器](nsp-boxall502581-0008.xhtml#rbh0406)'
- en: The key to understanding digital outputs is to learn about the *hardware registers*
    . Our AVR microcontrollers all have multiple registers that store information
    related to all the possible settings for the microcontroller’s operations. The
    numerical values placed inside these registers control digital outputs.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 理解数字输出的关键是学习*硬件寄存器*。我们的AVR微控制器都有多个寄存器，用于存储与微控制器操作的所有可能设置相关的信息。放入这些寄存器中的数值控制数字输出。
- en: The first AVR register to consider is called the *DDR* , for *data-direction
    register* . This is used to tell the microcontroller which pins are outputs and
    which are inputs. Some microcontrollers, such as the ATtiny85, will have only
    one DDR register, and some, like the ATmega328P-PU, will have more. The second
    register to consider is called *PORT* . You’ll use this to set which pins are
    on or off.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个需要考虑的AVR寄存器叫做*DDR*，即*数据方向寄存器*。这个寄存器用于告诉微控制器哪些引脚是输出，哪些是输入。有些微控制器，比如ATtiny85，只有一个DDR寄存器，而一些像ATmega328P-PU这样的微控制器则有多个。第二个需要考虑的寄存器叫做*PORT*。你将使用这个寄存器来设置哪些引脚是打开的，哪些是关闭的。
- en: Each register is 8 bits in size, where a bit can be either a 0 or a 1, just
    like a binary number. Each bit relates to a physical pin on the microcontroller.
    In the DDR *x* registers, 1s indicate that a pin is an output and 0s indicate
    that a pin is an input. In the PORT *x* registers, 1s indicate that a pin is on
    and 0s indicate that a pin is off.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 每个寄存器的大小为8位，每个位可以是0或1，就像二进制数一样。每个位与微控制器上的一个物理引脚相关联。在DDR *x* 寄存器中，1表示引脚为输出，0表示引脚为输入。在PORT
    *x* 寄存器中，1表示引脚为开启，0表示引脚为关闭。
- en: 'You can find out how many pins and registers are available by looking at the
    data sheet for your microcontroller (you can download the ATtiny85’s data sheet
    from the Microchip website at [https://www.microchip.com/wwwproducts/en/ATtiny85](https://www.microchip.com/wwwproducts/en/ATtiny85)
    ). For example, the diagram in [Figure 2-9](nsp-boxall502581-0012.xhtml#f02009)
    shows that there is one PORT register on the ATtiny85: the PORTB register, which
    spans pins 5, 6, 7, 3, 2, and 1.'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过查看微控制器的数据手册来了解有多少引脚和寄存器可用（你可以从Microchip网站下载ATtiny85的数据手册，网址为[https://www.microchip.com/wwwproducts/en/ATtiny85](https://www.microchip.com/wwwproducts/en/ATtiny85)）。例如，[图2-9](nsp-boxall502581-0012.xhtml#f02009)中的图示显示，ATtiny85有一个PORT寄存器：PORTB寄存器，涵盖了引脚5、6、7、3、2和1。
- en: '![Diagram of the ATtiny85 microcontroller’s pins and their functions](images/nsp-boxall502581-f02009.jpg)'
  id: totrans-108
  prefs: []
  type: TYPE_IMG
  zh: '![ATtiny85微控制器的引脚及其功能图示](images/nsp-boxall502581-f02009.jpg)'
- en: 'Figure 2-9: Pinouts and PORT registers for the ATtiny85'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 图2-9：ATtiny85的引脚和PORT寄存器
- en: PORT register names are usually abbreviated on diagrams and data sheets; in
    [Figure 2-9](nsp-boxall502581-0012.xhtml#f02009) , the PORTB register is referred
    to as PB, with each pin labeled as PB *x* , where *x* is the number of the pin.
    You’ll refer to this register as `PORTB` in your code. The matching DDR register
    is called DDRB, as it controls the data direction for PORTB. Please note that
    you can only use pins PB0 through PB4, as PB5 has other functions, which we’ll
    examine later.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 在图示和数据手册中，PORT寄存器的名称通常会缩写；在[图2-9](nsp-boxall502581-0012.xhtml#f02009)中，PORTB寄存器被称为PB，每个引脚被标记为PB
    *x*，其中*x*是引脚的编号。在代码中，你将称这个寄存器为`PORTB`。对应的DDR寄存器叫做DDRB，它控制PORTB的数据显示方向。请注意，你只能使用PB0到PB4引脚，因为PB5有其他功能，我们稍后会讨论。
- en: 'To set some of the pins in the DDRB register to outputs, just set the respective
    bits to 1s. As an example, let’s revisit the code from [Project 0](nsp-boxall502581-0012.xhtml#pro0)
    :'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 要将DDRB寄存器中的一些引脚设置为输出，只需将相应的位设置为1。举个例子，让我们重新看一下[项目0](nsp-boxall502581-0012.xhtml#pro0)中的代码：
- en: '[PRE7]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'This code sets the physical pin 2 to an output ❶. To set all the PORTB pins
    to outputs, you could use:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码将物理引脚2设置为输出❶。要将所有PORTB引脚设置为输出，你可以使用：
- en: '[PRE8]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Let’s examine how this works. The physical pins of the DDRB register of your
    ATtiny85 are 1, 3, 2, 7, 6, and 5\. Each pin corresponds to a single bit in the
    register; from left to right, those pins are bits 5, 3, 4, 2, 1, and 0, respectively.
    So, for example, to set physical pin 6 (PB1) as an output and the rest as inputs
    you would use:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看这是如何工作的。ATtiny85的DDRB寄存器的物理引脚为1、3、2、7、6和5。每个引脚对应寄存器中的一个单独的位；从左到右，这些引脚分别是位5、3、4、2、1和0。因此，举个例子，要将物理引脚6（PB1）设置为输出，其他引脚设置为输入，你可以使用：
- en: '[PRE9]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'And, as we saw in the [Project 0](nsp-boxall502581-0012.xhtml#pro0) code, to
    set physical pin 2 (PB3) as an output and the rest as inputs you would use:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们在[项目0](nsp-boxall502581-0012.xhtml#pro0)代码中看到的，要将物理引脚2（PB3）设置为输出，其他引脚设置为输入，你可以使用：
- en: '[PRE10]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: We call the bit on the right-hand side of the register the *first bit* or *least
    significant bit (LSB)* and the bit on the left-hand side the *last bit* or *most
    significant bit (MSB)* . This may seem backward at first, but bits are the equivalent
    of binary numbers, whose contents are referenced using the same method.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将寄存器右侧的位称为*第一位*或*最低有效位（LSB）*，而寄存器左侧的位称为*最后一位*或*最高有效位（MSB）*。刚开始可能会觉得有点不直观，但位是二进制数的等价物，其内容使用相同的方法进行引用。
- en: 'Because the ATtiny85 has only six outputs, you can leave the last two bits
    (6 and 7) as 0s or 1s in the DDRB statement. Once you’ve set a pin to an output,
    use the `PORT` `x` function to switch the output on or off. To turn all the outputs
    on, use:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 因为ATtiny85只有六个输出，你可以在DDRB语句中将最后两个位（6和7）设置为0或1。一旦你将引脚设置为输出，可以使用`PORT` `x`函数来切换输出的开关。要将所有输出打开，请使用：
- en: '[PRE11]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'To turn them all off, use:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 要将它们全部关闭，请使用：
- en: '[PRE12]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Or to turn, say, pins 3 (PB4) and 5 (PB0) on and the rest off, use:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，要打开3号引脚（PB4）和5号引脚（PB0），并将其余引脚关闭，可以使用：
- en: '[PRE13]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: To experiment with these functions, in the [next project](nsp-boxall502581-0012.xhtml#pro1)
    you’ll build a new circuit like the one in [Project 0](nsp-boxall502581-0012.xhtml#pro0)
    , but this time with four LEDs.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 要实验这些功能，在[下一个项目](nsp-boxall502581-0012.xhtml#pro1)中，你将构建一个类似于[项目 0](nsp-boxall502581-0012.xhtml#pro0)的电路，但这次将使用四颗LED。
- en: '[Project 1: Experimenting with ATtiny85 Digital Outputs](nsp-boxall502581-0008.xhtml#rpro1)'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: '[项目 1：实验 ATtiny85 数字输出](nsp-boxall502581-0008.xhtml#rpro1)'
- en: To practice and increase your understanding of using the ATtiny85’s DDRB and
    PORTB registers, in this project you’ll control four output devices (LEDs). Although
    blinking LEDs may seem a somewhat trivial example, the ability to control digital
    outputs is the foundation for controlling a wide range of objects.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 为了练习并增加对使用ATtiny85的DDRB和PORTB寄存器的理解，在这个项目中你将控制四个输出设备（LED）。尽管闪烁的LED看起来可能是一个相对简单的例子，但控制数字输出的能力是控制各种对象的基础。
- en: '[The Hardware](nsp-boxall502581-0008.xhtml#rbh0407)'
  id: totrans-129
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '[硬件](nsp-boxall502581-0008.xhtml#rbh0407)'
- en: 'You will need the following hardware:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 你将需要以下硬件：
- en: • USBasp programmer
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: • USBasp 编程器
- en: • Solderless breadboard
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: • 无焊面包板
- en: • ATtiny85–20PU microcontroller
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: • ATtiny85–20PU 微控制器
- en: • Four LEDs
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: • 四个LED
- en: • Four 560 Ω resistors
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: • 四个 560 Ω 电阻
- en: • Jumper wires
  id: totrans-136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: • 跳线
- en: The circuit for this project is similar to the one in [Project 0](nsp-boxall502581-0012.xhtml#pro0)
    , but with three more LEDs. Assemble your circuit as shown in [Figure 2-10](nsp-boxall502581-0012.xhtml#f02010)
    .
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 该项目的电路与[项目 0](nsp-boxall502581-0012.xhtml#pro0)中的类似，只是多了三颗LED。请按照[图 2-10](nsp-boxall502581-0012.xhtml#f02010)中的方式组装电路。
- en: '![Diagram of the physical circuit layout for Project 1](images/nsp-boxall502581-f02010.jpg)'
  id: totrans-138
  prefs: []
  type: TYPE_IMG
  zh: '![项目 1 物理电路布局图](images/nsp-boxall502581-f02010.jpg)'
- en: 'Figure 2-10: A physical layout diagram of the main circuit for [Project 1](nsp-boxall502581-0012.xhtml#pro1)'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2-10：用于[项目 1](nsp-boxall502581-0012.xhtml#pro1)的主电路物理布局图
- en: Once you’ve assembled your circuit, connect the USBasp programmer. Repeat the
    connections as shown in [Table 2-1](nsp-boxall502581-0012.xhtml#tab0201) .
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你组装好电路，连接USBasp编程器。按照[表 2-1](nsp-boxall502581-0012.xhtml#tab0201)中的连接方式进行重复连接。
- en: Note If you’d like to try creating diagrams like the one in [Figure 2-10](nsp-boxall502581-0012.xhtml#f02010)
    , use Autodesk Tinkercad, available at [https://www.tinkercad.com/](https://www.tinkercad.com/)
    .
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想尝试创建像[图 2-10](nsp-boxall502581-0012.xhtml#f02010)中的图示一样的图表，可以使用Autodesk
    Tinkercad，网址：[https://www.tinkercad.com/](https://www.tinkercad.com/)。
- en: '[The Code](nsp-boxall502581-0008.xhtml#rbh0408)'
  id: totrans-142
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '[代码](nsp-boxall502581-0008.xhtml#rbh0408)'
- en: Open a terminal window, navigate to the folder containing the two files for
    [Project 1](nsp-boxall502581-0012.xhtml#pro1) , and enter the command `make flash`
    . After a moment, the toolchain should compile the program file and create the
    required data file to upload to the microcontroller. Then the microcontroller
    should run the program that turns the digital outputs on and off, causing all
    four of the LEDs to blink.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 打开终端窗口，导航到包含[项目 1](nsp-boxall502581-0012.xhtml#pro1)两个文件的文件夹，并输入命令`make flash`。稍等片刻，工具链应会编译程序文件，并创建所需的数据文件上传到微控制器。然后，微控制器将运行该程序，控制数字输出的开关，从而使四个LED灯闪烁。
- en: 'To see how this works, open the *main.c* file located in the *Project 1* subfolder
    of the *Chapter 2* folder:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 要查看这个是如何工作的，请打开位于*Chapter 2*文件夹中*Project 1*子文件夹中的*main.c*文件：
- en: '[PRE14]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'First we use `DDRB` to set all the pins to outputs ❶. The `_delay_ms()` function
    ❷ tells the microcontroller to stop everything for a set period of time. To use
    a delay, just enter the number of milliseconds you want the program to pause inside
    the parentheses: `_delay_ms(250)` sets the delay to 250 milliseconds. Next, we
    turn on the digital outputs so current will flow from the pins, through the resistors
    and LEDs, and then to GND, completing the electrical circuit ❸. After another
    delay we turn off the digital outputs, causing the LEDs to turn off ❹.'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 首先我们使用`DDRB`将所有引脚设置为输出 ❶。`_delay_ms()`函数 ❷让微控制器暂停一段时间。要使用延时，只需在括号中输入你希望程序暂停的毫秒数：`_delay_ms(250)`将延时时间设置为
    250 毫秒。接下来，我们打开数字输出，使电流从引脚流出，经过电阻和 LED，再流向地面（GND），完成电路 ❸。经过另一个延时后，我们关闭数字输出，导致
    LED 关闭 ❹。
- en: By now you should understand how to set the pins on the ATtiny85 to outputs,
    turn them on and off, and create a delay. Experiment with the delay and pins by
    changing which LEDs turn on and off, the length of the delay, and so on.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 到现在为止，你应该理解了如何将 ATtiny85 的引脚设置为输出、打开和关闭它们，并创建延时。通过改变哪些 LED 打开和关闭、延时的长度等，来实验延时和引脚。
- en: '[Using Schematic Diagrams](nsp-boxall502581-0008.xhtml#rah0403)'
  id: totrans-148
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '[使用原理图](nsp-boxall502581-0008.xhtml#rah0403)'
- en: '[Projects 0](nsp-boxall502581-0012.xhtml#pro0) and [1](nsp-boxall502581-0012.xhtml#pro1)
    showed you how to build circuits using a picture and a physical layout diagram,
    respectively. Physical layout diagrams like the one in [Figure 2-10](nsp-boxall502581-0012.xhtml#f02010)
    may seem like the easiest way to diagram a circuit, but as you add more components,
    direct representations make physical diagrams a real mess. Because your circuits
    are about to get more complicated, from now on I’ll use *schematic diagrams* (also
    known as *circuit diagrams* ) to illustrate them, like the one shown in [Figure
    2-11](nsp-boxall502581-0012.xhtml#f02011) .'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: '[项目 0](nsp-boxall502581-0012.xhtml#pro0) 和 [1](nsp-boxall502581-0012.xhtml#pro1)
    分别展示了如何使用图片和物理布局图来构建电路。像[图 2-10](nsp-boxall502581-0012.xhtml#f02010)中的物理布局图看似是绘制电路的最简单方法，但随着组件的增多，直接的表示方式使物理图变得一团糟。因为你的电路即将变得更加复杂，从现在开始，我将使用*原理图*（也叫*电路图*）来展示它们，就像[图
    2-11](nsp-boxall502581-0012.xhtml#f02011)所示的那样。'
- en: '![Example of a simple microcontroller circuit schematic](images/nsp-boxall502581-f02011.jpg)'
  id: totrans-150
  prefs: []
  type: TYPE_IMG
  zh: '![一个简单的微控制器电路原理图示例](images/nsp-boxall502581-f02011.jpg)'
- en: 'Figure 2-11: An example schematic diagram'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2-11：一个示例原理图
- en: Schematics are road maps that show where electrical current flows through various
    components, with the lines between components indicating those paths. Instead
    of showing components and wires, a schematic uses symbols and lines.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 原理图是电流流经各个组件的路线图，组件之间的连线表示这些路径。原理图不是显示组件和电线，而是使用符号和线条。
- en: '[Components in Schematics](nsp-boxall502581-0008.xhtml#rbh0409)'
  id: totrans-153
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '[原理图中的组件](nsp-boxall502581-0008.xhtml#rbh0409)'
- en: Once you know what the symbols mean, reading a schematic is easy. To begin,
    let’s examine the symbols for the components you’ve already used.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你知道这些符号的含义，阅读原理图就变得很容易了。首先，让我们检查一下你已经使用过的组件符号。
- en: '[Figure 2-12](nsp-boxall502581-0012.xhtml#f02012) shows the ATtiny85 microcontroller
    symbol. The pin numbers are labeled clearly; don’t forget that pin 1 is at the
    top left on the physical chip. Other microcontrollers and ICs use similar symbols,
    but their size depends on the number of pins.'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 2-12](nsp-boxall502581-0012.xhtml#f02012)展示了 ATtiny85 微控制器的符号。引脚编号标注得很清楚；别忘了，第
    1 引脚位于物理芯片的左上角。其他微控制器和集成电路（IC）使用类似的符号，但其大小取决于引脚数量。'
- en: '![Schematic symbol for the ATtiny85–20PU microcontroller](images/nsp-boxall502581-f02012.jpg)'
  id: totrans-156
  prefs: []
  type: TYPE_IMG
  zh: '![ATtiny85–20PU 微控制器的原理符号](images/nsp-boxall502581-f02012.jpg)'
- en: 'Figure 2-12: The ATtiny85 microcontroller symbol'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2-12：ATtiny85 微控制器符号
- en: '[Figure 2-13](nsp-boxall502581-0012.xhtml#f02013) shows the resistor symbol.
    It’s good practice to display the resistor value and part designator along with
    the resistor symbol (220 Ω and R1, in this case). This makes life a lot easier
    for everyone trying to make sense of the schematic, including you!'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 2-13](nsp-boxall502581-0012.xhtml#f02013)展示了电阻符号。通常的做法是将电阻值和部件标识符与电阻符号一起显示（此例中为
    220 Ω 和 R1）。这会使所有试图理解原理图的人，包括你，轻松很多！'
- en: '![Schematic symbol for a common resistor](images/nsp-boxall502581-f02013.jpg)'
  id: totrans-159
  prefs: []
  type: TYPE_IMG
  zh: '![常见电阻的原理符号](images/nsp-boxall502581-f02013.jpg)'
- en: 'Figure 2-13: The resistor symbol'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2-13：电阻符号
- en: '[Figure 2-14](nsp-boxall502581-0012.xhtml#f02014) shows the LED symbol. All
    members of the diode family share a common symbol, the triangle and vertical line,
    but LED symbols show two parallel arrows pointing away from the triangle to indicate
    that light is being emitted.'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: '[图2-14](nsp-boxall502581-0012.xhtml#f02014)显示了LED符号。二极管家族中的所有成员共享一个常见符号——三角形和竖线，但LED符号会显示两个平行的箭头指向三角形的外侧，以表示发光。'
- en: '![Schematic symbol for a common LED](images/nsp-boxall502581-f02014.jpg)'
  id: totrans-162
  prefs: []
  type: TYPE_IMG
  zh: '![常见LED的原理图符号](images/nsp-boxall502581-f02014.jpg)'
- en: 'Figure 2-14: The LED symbol'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 图2-14：LED符号
- en: Now that you have an understanding of the various component schematic symbols,
    I’ll show you how the wired connections between the components are shown in circuit
    schematics.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经了解了各种元件的原理图符号，接下来我将向你展示在电路原理图中，元件之间的导线连接是如何表示的。
- en: '[Wires in Schematics](nsp-boxall502581-0008.xhtml#rbh0410)'
  id: totrans-165
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '[原理图中的导线](nsp-boxall502581-0008.xhtml#rbh0410)'
- en: 'When wires cross or connect in schematics, they are drawn in the following ways:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 当导线在原理图中交叉或连接时，它们的绘制方式如下：
- en: Crossing but not connected wires
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 交叉但不连接的导线
- en: When two wires cross but are not connected, the crossing can be represented
    in one of two ways, as shown in [Figure 2-15](nsp-boxall502581-0012.xhtml#f02015)
    . Either way is correct; it’s just a matter of preference.
  id: totrans-168
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当两根导线交叉但没有连接时，可以用两种方式表示交叉，如[图2-15](nsp-boxall502581-0012.xhtml#f02015)所示。两种方式都是正确的，选择哪种方式仅仅是个人偏好问题。
- en: '![Two ways of representing non-connecting wires in circuit schematics](images/nsp-boxall502581-f02015.jpg)'
  id: totrans-169
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![表示电路原理图中不连接导线的两种方式](images/nsp-boxall502581-f02015.jpg)'
- en: 'Figure 2-15: Non-connecting crossed wires'
  id: totrans-170
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图2-15：不连接的交叉导线
- en: Connected wires
  id: totrans-171
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 连接的导线
- en: When wires are physically connected, a *junction dot* is drawn at the point
    of connection, as shown in [Figure 2-16](nsp-boxall502581-0012.xhtml#f02016) .
  id: totrans-172
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当导线物理连接时，会在连接点绘制一个*交点标记*，如[图2-16](nsp-boxall502581-0012.xhtml#f02016)所示。
- en: '![Representation of connected wires in a circuit schematic](images/nsp-boxall502581-f02016.jpg)'
  id: totrans-173
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![电路原理图中连接导线的表示](images/nsp-boxall502581-f02016.jpg)'
- en: 'Figure 2-16: Two wires that are connected'
  id: totrans-174
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图2-16：连接的两根导线
- en: Wire connected to ground
  id: totrans-175
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 连接到地的导线
- en: The symbol shown in [Figure 2-17](nsp-boxall502581-0012.xhtml#f02017) indicates
    when a wire is connected to ground (GND).
  id: totrans-176
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[图2-17](nsp-boxall502581-0012.xhtml#f02017)中所示的符号表示导线与地（GND）连接。'
- en: '![Schematic symbol for circuit ground](images/nsp-boxall502581-f02017.jpg)'
  id: totrans-177
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![电路接地的原理图符号](images/nsp-boxall502581-f02017.jpg)'
- en: 'Figure 2-17: The GND symbol'
  id: totrans-178
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图2-17：GND符号
- en: The GND symbol at the end of a line in a schematic tells you that the wire is
    physically connected to the microcontroller’s GND pin. For your circuits, this
    is also known as the *negative* .
  id: totrans-179
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 原理图中位于一根导线末端的GND符号表示该导线与微控制器的GND引脚物理连接。对于你的电路，这也被称为*负极*。
- en: '[Dissecting a Schematic](nsp-boxall502581-0008.xhtml#rbh0411)'
  id: totrans-180
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '[分析原理图](nsp-boxall502581-0008.xhtml#rbh0411)'
- en: Now that you know the symbols for the parts you’ve used so far, let’s dissect
    the schematic you’d draw for [Project 1](nsp-boxall502581-0012.xhtml#pro1) . Compare
    the schematic shown in [Figure 2-18](nsp-boxall502581-0012.xhtml#f02018) with
    physical image of the circuit in [Figure 2-10](nsp-boxall502581-0012.xhtml#f02010)
    .
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经了解了目前为止使用的符号，让我们来分析你为[项目1](nsp-boxall502581-0012.xhtml#pro1)绘制的原理图。将[图2-18](nsp-boxall502581-0012.xhtml#f02018)中的原理图与[图2-10](nsp-boxall502581-0012.xhtml#f02010)中的电路实物图进行对比。
- en: '![Schematic diagram for Project 1](images/nsp-boxall502581-f02018.jpg)'
  id: totrans-182
  prefs: []
  type: TYPE_IMG
  zh: '![项目1的原理图](images/nsp-boxall502581-f02018.jpg)'
- en: 'Figure 2-18: Schematic for [Project 1](nsp-boxall502581-0012.xhtml#pro1)'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 图2-18：为[项目1](nsp-boxall502581-0012.xhtml#pro1)绘制的原理图
- en: The arrow with +5V written above it represents the 5 V power supply on the breadboard,
    and the ATtiny85 is labeled with its chip name. LEDs 1 through 4 are connected
    to the ATtiny85 at the same pins you saw in [Figure 2-10](nsp-boxall502581-0012.xhtml#f02010)
    , and just like in the original circuit, all four resistors attached to the LEDs
    go to GND, pin 4 on the microcontroller. Note the dots at the junctions of R1,
    R2, R3, and R4, which indicate that those resistors are all connected to the same
    place (GND). The Xs on pins 1 and 3 in [Figure 2-18](nsp-boxall502581-0012.xhtml#f02018)
    signal that those pins are not connected to anything.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 上方标有 +5V 的箭头代表面包板上的 5V 电源，ATtiny85 被标注为其芯片名称。LED 1 到 4 与 ATtiny85 相连，连接方式与 [图
    2-10](nsp-boxall502581-0012.xhtml#f02010) 中所示相同，正如原始电路一样，所有四个连接到 LED 的电阻都接地（GND），接到微控制器的
    4 号引脚。注意 R1、R2、R3 和 R4 连接点处的点，它们表示这些电阻都连接到相同的位置（GND）。[图 2-18](nsp-boxall502581-0012.xhtml#f02018)
    中引脚 1 和 3 上的 X 表示这些引脚没有连接任何东西。
- en: In this schematic, you can trace the flow of current from the power supply through
    the circuit to ground. Current is sourced from the 5 V power supply and enters
    the microcontroller. Our code then allows the current to flow from digital output
    pins when required. This current goes through an LED (which causes the LED to
    glow) and the resistor (which regulates the current) before reaching ground and
    completing the circuit.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个原理图中，你可以追踪电流从电源流经电路到地的路径。电流从 5V 电源供应，进入微控制器。我们的代码允许电流根据需要从数字输出引脚流出。电流通过 LED（使
    LED 发光）和电阻（调节电流）后，最终到达地并完成电路。
- en: Note If you’d like to create your own computer-drawn schematics, try the open
    source KiCad package, available for free or with a donation from [https://www.kicad.org/](https://www.kicad.org/)
    .
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 注意 如果你想自己绘制计算机绘制的原理图，可以尝试使用开源的 KiCad 软件包，免费提供或通过捐赠获取，网址：[https://www.kicad.org/](https://www.kicad.org/)。
- en: Along with using the ATmega328P-PU for the first time, the [following project](nsp-boxall502581-0012.xhtml#pro2)
    will also put your new knowledge of reading circuit schematics to use.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 除了首次使用 ATmega328P-PU，本 [项目](nsp-boxall502581-0012.xhtml#pro2) 还将让你运用新学的电路原理图阅读知识。
- en: '[Project 2: Experimenting with ATmega328P-PU Digital Outputs](nsp-boxall502581-0008.xhtml#rpro2)'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: '[项目2：实验 ATmega328P-PU 数字输出](nsp-boxall502581-0008.xhtml#rpro2)'
- en: You can tell at a glance that the ATmega328P-PU has more digital outputs than
    the ATtiny85\. The pinout diagram from the data sheet in [Figure 2-19](nsp-boxall502581-0012.xhtml#f02019)
    gives the details.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以一眼看出，ATmega328P-PU 拥有比 ATtiny85 更多的数字输出。来自数据手册中的引脚图 [图 2-19](nsp-boxall502581-0012.xhtml#f02019)
    提供了详细信息。
- en: '![Diagram of the ATmega328P-PU’s pins and their functions](images/nsp-boxall502581-f02019.jpg)'
  id: totrans-190
  prefs: []
  type: TYPE_IMG
  zh: '![ATmega328P-PU 的引脚及其功能图](images/nsp-boxall502581-f02019.jpg)'
- en: 'Figure 2-19: The ATmega328P-PU pinout and port register diagram'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2-19：ATmega328P-PU 的引脚图和端口寄存器图
- en: 'There are two registers you can use for digital outputs: PORTB (PB) and PORTD
    (PD). For this and the following few projects, you’ll use the PORTB register.
    In this project, you’ll put the ATmega328P-PU’s digital outputs to work using
    more LEDs.'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 有两个寄存器可以用于数字输出：PORTB (PB) 和 PORTD (PD)。在本项目以及接下来的几个项目中，你将使用 PORTB 寄存器。在这个项目中，你将通过更多的
    LED 来使用 ATmega328P-PU 的数字输出。
- en: '[The Hardware](nsp-boxall502581-0008.xhtml#rbh0412)'
  id: totrans-193
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '[硬件部分](nsp-boxall502581-0008.xhtml#rbh0412)'
- en: 'You will need the following hardware:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 你将需要以下硬件：
- en: • USBasp programmer
  id: totrans-195
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: • USBasp 编程器
- en: • Solderless breadboard
  id: totrans-196
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: • 无焊面包板
- en: • ATmega328P-PU microcontroller
  id: totrans-197
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: • ATmega328P-PU 微控制器
- en: • Eight LEDs
  id: totrans-198
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: • 八个 LED
- en: • Eight 560 Ω resistors
  id: totrans-199
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: • 八个 560 Ω 电阻
- en: • Jumper wires
  id: totrans-200
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: • 跳线
- en: I’ve provided both a physical layout diagram and the schematic for the required
    circuit, which you can use to assemble your circuit. The diagram in [Figure 2-20](nsp-boxall502581-0012.xhtml#f02020)
    indicates the physical connections you see with your own eyes, and the schematic
    in [Figure 2-21](nsp-boxall502581-0012.xhtml#f02021) indicates the same electrical
    connections between the various components in a more compact and easier-to-follow
    form.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 我提供了物理布局图和所需电路的原理图，你可以使用它们来组装电路。 [图 2-20](nsp-boxall502581-0012.xhtml#f02020)
    显示了你肉眼可见的物理连接，而 [图 2-21](nsp-boxall502581-0012.xhtml#f02021) 中的原理图则以更紧凑、易于理解的形式展示了各组件之间相同的电气连接。
- en: '![Diagram of the physical circuit layout for Project 2](images/nsp-boxall502581-f02020.jpg)'
  id: totrans-202
  prefs: []
  type: TYPE_IMG
  zh: '![项目2的物理电路布局图](images/nsp-boxall502581-f02020.jpg)'
- en: 'Figure 2-20: Diagram for [Project 2](nsp-boxall502581-0012.xhtml#pro2)'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2-20： [项目2](nsp-boxall502581-0012.xhtml#pro2) 的电路图
- en: '![Schematic diagram for Project 2](images/nsp-boxall502581-f02021.jpg)'
  id: totrans-204
  prefs: []
  type: TYPE_IMG
  zh: '![项目2的原理图](images/nsp-boxall502581-f02021.jpg)'
- en: 'Figure 2-21: Schematic for [Project 2](nsp-boxall502581-0012.xhtml#pro2)'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 图2-21：[项目2](nsp-boxall502581-0012.xhtml#pro2)的原理图
- en: Connect your USBasp programmer to the circuit, then connect jumper wires between
    the programmer and the microcontroller using the information in [Table 2-2](nsp-boxall502581-0012.xhtml#tab0202)
    . Take note of the connections, as they will be the same every time you program
    an ATmega328P-PU microcontroller.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 将USBasp编程器连接到电路，然后使用[表2-2](nsp-boxall502581-0012.xhtml#tab0202)中的信息连接编程器和微控制器之间的跳线。请注意这些连接，因为每次你为ATmega328P-PU微控制器编程时，它们都将保持一致。
- en: '| Table 2-2 : USBasp to ATmega328P-PU Connections |'
  id: totrans-207
  prefs: []
  type: TYPE_TB
  zh: '| 表2-2：USBasp与ATmega328P-PU连接 |'
- en: '| --- |'
  id: totrans-208
  prefs: []
  type: TYPE_TB
  zh: '| --- |'
- en: '| USBasp pin | ATmega328P-PU pin |'
  id: totrans-209
  prefs: []
  type: TYPE_TB
  zh: '| USBasp引脚 | ATmega328P-PU引脚 |'
- en: '| --- | --- |'
  id: totrans-210
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| RST | 1 |'
  id: totrans-211
  prefs: []
  type: TYPE_TB
  zh: '| RST | 1 |'
- en: '| GND | 8 |'
  id: totrans-212
  prefs: []
  type: TYPE_TB
  zh: '| GND | 8 |'
- en: '| VCC | 7 |'
  id: totrans-213
  prefs: []
  type: TYPE_TB
  zh: '| VCC | 7 |'
- en: '| SCK | 19 |'
  id: totrans-214
  prefs: []
  type: TYPE_TB
  zh: '| SCK | 19 |'
- en: '| MISO | 18 |'
  id: totrans-215
  prefs: []
  type: TYPE_TB
  zh: '| MISO | 18 |'
- en: '| MOSI | 17 |'
  id: totrans-216
  prefs: []
  type: TYPE_TB
  zh: '| MOSI | 17 |'
- en: 'Before uploading code to the microcontroller, test that the programmer is communicating
    with the ATmega328P-PU. Connect your USBasp programmer to your computer and open
    a terminal window. Enter the command `avrdude -p m328p -c usbasp -B 4` and press
    enter . The software toolchain should interrogate the programmer and microcontroller,
    and you should see the following output in your terminal:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 在将代码上传到微控制器之前，先测试编程器是否与ATmega328P-PU通信。将USBasp编程器连接到计算机，并打开终端窗口。输入命令`avrdude
    -p m328p -c usbasp -B 4`并按下回车键。软件工具链应该会与编程器和微控制器进行通信，你应该在终端中看到以下输出：
- en: '[PRE15]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The only difference between this `avrdude` command and the command used earlier
    to test your setup with the ATtiny85 is that we changed the microcontroller parameter
    `-p` to `m328p` . If you saw the correct output after entering this command, you
    can move forward; otherwise, review the “What If It Didn’t Work?” section on [page
    35](nsp-boxall502581-0012.xhtml#p35) .
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 这个`avrdude`命令与之前测试ATtiny85设置时使用的命令唯一的区别在于，我们将微控制器参数`-p`改为了`m328p`。如果在输入此命令后看到正确的输出，说明可以继续；否则，请查阅[第35页](nsp-boxall502581-0012.xhtml#p35)的“如果没有工作怎么办？”部分。
- en: '[The Code](nsp-boxall502581-0008.xhtml#rbh0413)'
  id: totrans-220
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '[代码](nsp-boxall502581-0008.xhtml#rbh0413)'
- en: Open a terminal window, navigate to the folder containing the two files for
    [Project 2](nsp-boxall502581-0012.xhtml#pro2) , and enter the command `make flash`
    . After a moment, the toolchain should compile the program file and create the
    required data file to upload to the microcontroller. Then the microcontroller
    should run the program, causing all eight of the LEDs to blink together.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 打开终端窗口，导航到包含[项目2](nsp-boxall502581-0012.xhtml#pro2)两个文件的文件夹，并输入命令`make flash`。稍等片刻，工具链应当编译程序文件，并创建上传到微控制器所需的数据文件。然后微控制器应该会运行该程序，导致所有八个LED同时闪烁。
- en: To see how this works, open the *main.c* file located in the *Project 2* subfolder
    of the *Chapter 2* folder.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 要查看它是如何工作的，请打开位于*第二章*文件夹中*项目2*子文件夹中的*main.c*文件。
- en: '[PRE16]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'The code in this project is identical to that of [Project 1](nsp-boxall502581-0012.xhtml#pro1)
    . However, because the ATmega328P-PU has a full PORTB register (that is, eight
    outputs), you can control all of them with the `PORTB` function. For some practice,
    change the `PORTB` lines to experiment with blinking LEDs. Try turning half of
    them on and half of them off by changing the line at ❶ to:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 本项目中的代码与[项目1](nsp-boxall502581-0012.xhtml#pro1)中的代码相同。然而，由于ATmega328P-PU有一个完整的PORTB寄存器（即八个输出），你可以使用`PORTB`函数控制所有这些输出。为了练习，可以更改`PORTB`线路，尝试让LED闪烁。尝试通过更改❶处的线路，将一半的LED打开，另一半关闭：
- en: '[PRE17]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'and the line at ❷ to:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 和❷处的线路：
- en: '[PRE18]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: You can also increase the effects by adding more `PORTB` lines with different
    on/off states. Go crazy! Keep this circuit together when you’re done experimenting,
    since you’ll use it for the rest of this chapter.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以通过添加更多的`PORTB`线路并设置不同的开/关状态来增加效果。尽情发挥吧！完成实验后，保持这个电路连接，因为你将在本章剩余部分中继续使用它。
- en: You’ll soon see how each bit of the PORTB register relates to a digital output
    on the microcontroller. However, there’s a better way to control the outputs to
    create complicated patterns. In the [next project](nsp-boxall502581-0012.xhtml#pro3)
    , you’ll use the same circuit to control outputs more efficiently with variables,
    functions, bit shifting, and bitwise arithmetic.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 你很快就会看到PORTB寄存器的每一位是如何与微控制器的数字输出相对应的。然而，有一种更好的方法可以控制输出，从而创建复杂的模式。在[下一个项目](nsp-boxall502581-0012.xhtml#pro3)中，你将使用相同的电路，通过变量、函数、位移和位运算更高效地控制输出。
- en: '[Project 3: Bit-Shifting Digital Outputs](nsp-boxall502581-0008.xhtml#rpro3)'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: '[项目 3：位移数字输出](nsp-boxall502581-0008.xhtml#rpro3)'
- en: In this project, you’ll learn more efficient ways to control the digital outputs.
    These techniques will give you more control over the outputs without excessive
    code, so that you don’t waste program memory in the microcontroller.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个项目中，你将学习更高效的方式来控制数字输出。这些技术将使你在不增加过多代码的情况下对输出进行更精细的控制，从而避免浪费微控制器的程序内存。
- en: This project uses the same hardware as [Project 2](nsp-boxall502581-0012.xhtml#pro2)
    , so you should have that set up already. Open a terminal window, navigate to
    the folder containing the two files for [Project 3](nsp-boxall502581-0012.xhtml#pro3)
    , and enter the command `make flash` . Once again, the toolchain should process
    the code, and in a moment the LEDs should start blinking on and off in a repeating
    pattern from left to right, then from right to left, and so on.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 本项目使用与[项目 2](nsp-boxall502581-0012.xhtml#pro2) 相同的硬件，因此你应该已经设置好了。打开终端窗口，导航到包含[项目
    3](nsp-boxall502581-0012.xhtml#pro3) 的两个文件的文件夹，然后输入命令 `make flash`。再次，工具链应该处理代码，很快
    LED 灯应该开始按左到右、然后右到左的重复模式闪烁。
- en: 'Now open the *main.c* file located in the *Project 3* subfolder of the *Chapter
    2* folder for a closer look at how this works:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 现在打开位于*第 2 章*文件夹中的*项目 3*子文件夹中的 *main.c* 文件，仔细看看它是如何工作的：
- en: '[PRE19]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: This code introduces some new concepts. First, the `#define` macro lets you
    assign values to words, which are called *constant values* or just *constants*
    for short. Constants make it possible to reference values later in your code and
    make your code easier to read. For example, `#define TIME 100` ❶ tells the compiler
    to replace the word `TIME` with the value 100 anywhere you use `TIME` in your
    code, as in the `__delay_ms_` lines ❹. To change the blink delay you only need
    to change the value in the original `#define` macro, and the compiler takes care
    of the rest. Whenever you use `#define` , you must place it before the main `int
    main(void)` loop in the code.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码引入了一些新概念。首先，`#define` 宏允许你将值分配给单词，这些值被称为*常量值*或简称*常量*。常量使得在代码中稍后引用值成为可能，同时也让代码更易于阅读。例如，`#define
    TIME 100` ❶ 告诉编译器在代码中任何使用 `TIME` 的地方都将 `TIME` 替换为 100，正如在 `__delay_ms_` 行 ❹ 中一样。要更改闪烁延迟，你只需要更改原始
    `#define` 宏中的值，编译器会处理剩余的部分。每次使用 `#define` 时，你必须将其放在主 `int main(void)` 循环之前。
- en: Inside the main loop we define a *variable* , which that represents data. A
    variable’s value can change while the code is being executed, whereas the value
    of a constant defined by the `#define` macro cannot. You can think of a variable
    as a part of the microcontroller’s memory that stores a number you can change
    as needed during program execution. The first type of variable you’ll use in this
    book is an *integer* . In programming terms, this type can hold a whole number;
    that is, a number that can be positive, negative, or zero, without a fractional
    or decimal part.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 在主循环中，我们定义了一个*变量*，它表示数据。变量的值可以在代码执行过程中改变，而通过 `#define` 宏定义的常量的值则不能。你可以将变量看作是微控制器内存的一部分，用于存储在程序执行过程中你可以根据需要更改的数字。本书中你将使用的第一个变量类型是*整数*。在编程术语中，这种类型可以存储一个整数；也就是说，可以是正数、负数或零，且没有小数部分。
- en: To define a variable, first enter the type and then the label. The line `uint8_t
    i;` ❷ defines a variable called `i` of type `uint8_t` . This type of variable
    can store a whole number between 0 and 255 (the `u` stands for *unsigned* ; an
    unsigned integer cannot store negative numbers). The letter `i` now represents
    an integer whose value you can change.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 要定义一个变量，首先输入类型，然后是标签。行 `uint8_t i;` ❷ 定义了一个名为 `i` 的变量，类型为 `uint8_t`。这种类型的变量可以存储一个介于
    0 和 255 之间的整数（`u` 代表*无符号*；无符号整数不能存储负数）。字母 `i` 现在表示一个整数，你可以随时更改其值。
- en: 'There are six types of integer variables you can make use of:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 有六种类型的整数变量可以使用：
- en: • `uint8_t` is an 8-bit unsigned integer (0 to 255).
  id: totrans-239
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: • `uint8_t` 是一个 8 位无符号整数（0 到 255）。
- en: • `int8_t` is an 8-bit signed integer (–128 to 127).
  id: totrans-240
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: • `int8_t` 是一个 8 位有符号整数（–128 到 127）。
- en: • `uint16_t` is a 16-bit unsigned integer (0 to 65,535).
  id: totrans-241
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: • `uint16_t` 是一个 16 位无符号整数（0 到 65,535）。
- en: • `int16_t` is a 16-bit signed integer (–32,768 to 32,767).
  id: totrans-242
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: • `int16_t` 是一个 16 位有符号整数（–32,768 到 32,767）。
- en: • `uint32_t` is a 32-bit unsigned integer (0 to 4,294,967,295).
  id: totrans-243
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: • `uint32_t` 是一个 32 位无符号整数（0 到 4,294,967,295）。
- en: • `int32_t` is a 32-bit signed integer (–2,147,483,648 to 2,147,483,647).
  id: totrans-244
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: • `int32_t` 是一个 32 位有符号整数（–2,147,483,648 到 2,147,483,647）。
- en: At first glance, you may think that the smaller integer types are redundant
    and that you should just use `int32_t` for all your integer needs. However, the
    larger the integer type, the more time it takes your microcontroller to process
    those numbers. To maximize efficiency, bear in mind the needs of your project
    when selecting an integer type, and use the smallest type that will accommodate
    the largest possible value.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 初看之下，你可能会认为较小的整数类型是多余的，应该只使用`int32_t`来满足所有整数需求。然而，整数类型越大，微控制器处理这些数字所需的时间就越长。为了最大化效率，在选择整数类型时，请考虑项目的需求，并使用能够容纳最大可能值的最小类型。
- en: 'This code also introduces `for` *loops* , which allow you to repeat a section
    of code without retyping it. Retyping is inefficient and wastes memory; `for`
    loops simply let you set how many times the code inside the loop will repeat.
    There are two `for` loops in the [Project 3](nsp-boxall502581-0012.xhtml#pro3)
    code. Let’s look at the first one ❸:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码还引入了`for` *循环*，它允许你重复某段代码而无需重新输入。重复输入代码效率低下，浪费内存；`for` 循环则可以让你设置循环体内的代码重复执行的次数。在[项目3](nsp-boxall502581-0012.xhtml#pro3)的代码中有两个`for`循环。让我们来看第一个
    ❸：
- en: '[PRE20]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'A `for` loop repeats the code between the curly brackets as long as a certain
    condition is true. In this case, this loop will repeat until the value of the
    variable `i` is 8\. In the first section of the loop, we set the initial value of
    `i` to 0 using `i = 0` . The second section of the loop checks to see if the condition
    is true: in this case, if `i < 8` . The third section of the loop keeps track
    of how many times the code loops; `i++` means “add one to the value of `i` after
    each loop.” Every time the code between the curly brackets is executed, the value
    of `i` increases by one and the code checks to see if `i` is less than 8\. When
    `i` equals 8, the looping stops and the microcontroller moves on to the code after
    the `for` loop.'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: '`for`循环会在特定条件为真时重复大括号中的代码。在这个例子中，循环会一直重复，直到变量`i`的值为8。在循环的第一部分，我们通过`i = 0`设置`i`的初始值。循环的第二部分检查条件是否为真：在此情况下，检查`i
    < 8`。循环的第三部分跟踪代码循环的次数；`i++`表示“每次循环后将`i`的值加1”。每次执行大括号内的代码时，`i`的值增加1，并且代码会检查`i`是否小于8。当`i`等于8时，循环停止，微控制器将继续执行`for`循环后的代码。'
- en: 'The final concept this project introduces is *bit shifting* , a technique that
    moves the bits in a binary number to the left or right. This helps you to efficiently
    use binary numbers in your `PORT` `x` functions to turn the output pins on and
    off. The `for` loop at ❸ shifts the first bit one to the left every time the loop
    completes. This is faster than using the equivalent eight `PORTB` functions:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 本项目引入的最终概念是*位移*，这是一种将二进制数中的位向左或向右移动的技术。它帮助你高效地使用二进制数字，在`PORT` `x`函数中控制输出引脚的开关。在❸处的`for`循环每次循环完成时将第一个位向左移一位。这比使用等效的八个`PORTB`函数更为高效：
- en: '[PRE21]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Instead of wasting code on such functions, you can shift the first bit to the
    left with `<<` or to the right with `>>` , followed by the number of bits to move.
    For example, to turn the first three outputs in PORTB on and off in sequence,
    you could enter:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 与其浪费代码在这种函数上，不如使用`<<`将第一个位向左移动，或者使用`>>`将其向右移动，后面跟上需要移动的位数。例如，要依次开启和关闭PORTB中的前三个输出，可以输入：
- en: '[PRE22]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: The `for` loop at ❸ demonstrates shifting bits to the left with `<< i` . Here,
    `i` starts with a value of 0 in the first loop, meaning the first output is on.
    When the code loops again, `i` has a value of 1, meaning the second output is
    on, and so forth. In the same manner, the `for` loop at ❺ turns on the LEDs from
    left to right with `>>` .
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: ❸处的`for`循环演示了如何使用`<< i`将位向左移。这里，`i`在第一次循环时值为0，表示第一个输出被开启。当代码再次循环时，`i`的值变为1，表示第二个输出被开启，以此类推。以相同的方式，❺处的`for`循环使用`>>`从左到右依次开启LED灯。
- en: You can manipulate outputs even more effectively with some deeper manipulation
    of the PORT *x* register using *bitwise arithmetic* . This is a way of manipulating
    numbers in the form of their individual bits that is directly supported by the
    microcontroller. Don’t let past experiences in math class scare you; it’s quite
    simple. The four operators you can use with numbers or variables to change the
    bits in a register are NOT, AND, OR, and XOR. You’ll see how they work in [Projects
    4](nsp-boxall502581-0012.xhtml#pro4) through [7](nsp-boxall502581-0012.xhtml#pro7)
    .
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过更深入地操作 PORT *x* 寄存器，利用 *位运算* 来更有效地控制输出。这是一种通过微控制器直接支持的位操作方式，用于操作数字的各个位。不要让你过去在数学课上的经历吓到你；这非常简单。你可以用来改变寄存器中位的四种操作符是：NOT、AND、OR
    和 XOR。你将在 [项目 4](nsp-boxall502581-0012.xhtml#pro4) 到 [7](nsp-boxall502581-0012.xhtml#pro7)
    中看到它们的使用方法。
- en: '[Project 4: Experimenting with NOT](nsp-boxall502581-0008.xhtml#rpro4)'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: '[项目 4：实验与 NOT 运算](nsp-boxall502581-0008.xhtml#rpro4)'
- en: 'The NOT ( `~` ) operator inverts all the bits in a number or register. If you
    place a tilde ( `~` ) in front of a number, it will be interpreted as the binary
    opposite. For example:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: NOT (`~`) 运算符会反转一个数字或寄存器中的所有位。如果你在数字前加上波浪符号（`~`），它将被视为该数字的二进制反码。例如：
- en: '[PRE23]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Try this yourself by replacing the main loop from [Project 2](nsp-boxall502581-0012.xhtml#pro2)
    with the following:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过将 [项目 2](nsp-boxall502581-0012.xhtml#pro2) 中的主循环替换为以下代码，来自己尝试一下：
- en: '[PRE24]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: After the `~` line, all the pins on PORTB should be turned on. NOT (and all
    the other bitwise operators) is a useful tool to keep in your arsenal when planning
    out projects.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `~` 这一行之后，PORTB 上的所有引脚应该都点亮。NOT（以及所有其他位运算符）是你在规划项目时可以保留在工具箱中的有用工具。
- en: '[Project 5: Experimenting with AND](nsp-boxall502581-0008.xhtml#rpro5)'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: '[项目 5：实验与 AND 运算](nsp-boxall502581-0008.xhtml#rpro5)'
- en: 'The AND ( `&` ) operator compares two binary numbers and returns a new binary
    number. If both numbers have 1s at the same position, the new number will have
    a 1 at that position, and the other bits will be 0s. For example:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: AND (`&`) 运算符比较两个二进制数，并返回一个新的二进制数。如果两个数字在相同位置上都有 1，新的数字在该位置会是 1，其他位将是 0。例如：
- en: '[PRE25]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'AND is useful when you only want to turn outputs on depending on a certain
    value. [Project 5](nsp-boxall502581-0012.xhtml#pro5) demonstrates this by displaying
    binary numbers from 0 to 255\. Use the same circuit from [Project 3](nsp-boxall502581-0012.xhtml#pro3)
    , and open the *main.c* file located in the *Project 5* subfolder of the *Chapter
    2* folder:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: AND 运算在你希望根据某个特定值来控制输出时非常有用。[项目 5](nsp-boxall502581-0012.xhtml#pro5) 通过显示从 0
    到 255 的二进制数字来演示这一点。使用 [项目 3](nsp-boxall502581-0012.xhtml#pro3) 中相同的电路，并打开位于 *Chapter
    2* 文件夹中的 *Project 5* 子文件夹里的 *main.c* 文件：
- en: '[PRE26]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: In this code, the `for` loop counts from 0 to 255\. Every time the code loops,
    it performs an AND on `0b11111111` and the variable `i` and sets `PORTB` to the
    result of the operation. For example, let’s say `i` has a value of 9, which is
    `0b00001001` . The result of `0b00001001 & 0b11111111` will be `0b00001001` because
    the bits in the ones and eights columns match. Thus, the `PORTB` setting will
    be `0b00001001` and all the LEDs for 1 and 4 will turn on.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 在这段代码中，`for` 循环从 0 计数到 255。每次代码循环时，它都会对 `0b11111111` 和变量 `i` 执行与运算，并将 `PORTB`
    设置为运算结果。例如，假设 `i` 的值为 9，即 `0b00001001`。`0b00001001 & 0b11111111` 的结果将是 `0b00001001`，因为一位和八位的位匹配。因此，`PORTB`
    的设置将是 `0b00001001`，并且 1 和 4 号 LED 会点亮。
- en: '[Project 6: Experimenting with OR](nsp-boxall502581-0008.xhtml#rpro6)'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: '[项目 6：实验与 OR 运算](nsp-boxall502581-0008.xhtml#rpro6)'
- en: 'The OR ( `|` ) operator compares two binary numbers and returns another binary
    number with 1s in any position where either operand had a bit set to 1\. For example:'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: OR (`|`) 运算符比较两个二进制数，并返回另一个二进制数，在任何一个操作数的某个位为 1 的位置，结果也为 1。例如：
- en: '[PRE27]'
  id: totrans-269
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'This operator is useful when you want to turn outputs on when bits in either
    of two numbers have a certain value. To try it out, use the same circuit from
    [Project 3](nsp-boxall502581-0012.xhtml#pro3) and open the *main.c* file in the
    *Project 6* subfolder of the *Chapter 2* folder:'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 这个运算符在你希望根据两个数字中的位是否具有某个特定值来控制输出时非常有用。你可以使用 [项目 3](nsp-boxall502581-0012.xhtml#pro3)
    中相同的电路，并打开位于 *Chapter 2* 文件夹中的 *Project 6* 子文件夹里的 *main.c* 文件，来试试这个方法：
- en: '[PRE28]'
  id: totrans-271
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: The main loop counts from 0 to 255, as in the previous example. Every time the
    code loops, it performs an OR on `0b00001111` and the variable `i` and sets `PORTB`
    to the result of the operation. If `i` has a value of, for example, 0, which is
    `0b00000000` , the result of `0b00001111 | 0b00000000` will be `0b00001111` .
    Thus, the `PORTB` setting will be `0b0001111` , and the four LEDs on the right
    side will stay on.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 主循环从 0 计数到 255，如前面的示例所示。每次代码循环时，它都会对 `0b00001111` 和变量 `i` 执行 OR 运算，并将 `PORTB`
    设置为运算结果。如果 `i` 的值为 0，例如 `0b00000000`，则 `0b00001111 | 0b00000000` 的结果为 `0b00001111`。因此，`PORTB`
    的设置将为 `0b0001111`，右侧的四个 LED 将保持亮起。
- en: As the value of `i` increases, the number of bits in `i` increases and more
    LEDs will turn on. For example, when `i` has a value of 128, or `0b10000000` ,
    the resulting `PORTB` is `0b10001111` . Load this code onto your AVR to see it
    in action, then experiment with the code and create your own OR situations to
    practice.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 随着 `i` 的值增加，`i` 中的位数也会增加，更多的 LED 将会亮起。例如，当 `i` 的值为 128，或 `0b10000000` 时，结果的
    `PORTB` 为 `0b10001111`。将此代码加载到你的 AVR 上以查看其实际效果，然后实验代码并创建你自己的 OR 情况来练习。
- en: '[Project 7: Experimenting with XOR](nsp-boxall502581-0008.xhtml#rpro7)'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: '[项目 7：实验 XOR](nsp-boxall502581-0008.xhtml#rpro7)'
- en: 'The final operator, XOR ( `^` ), compares the same bits in two numbers and
    returns a new binary number. Anywhere the two numbers had opposite bits in the
    same position, the new number will have a 1; anywhere the two numbers had identical
    bits, the new number will have a 0\. For example:'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 最后的运算符 XOR (`^`) 比较两个数字中相同位置的位，并返回一个新的二进制数。任何两个数字在相同位置上有不同的位，新的数字将在该位置上为 1；如果两个数字在同一位置上具有相同的位，新的数字将在该位置上为
    0。例如：
- en: '[PRE29]'
  id: totrans-276
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'XOR operators are useful when you want to turn outputs on when bits in two
    numbers have different values. To see how this works, use the same circuit from
    [Project 3](nsp-boxall502581-0012.xhtml#pro3) and open the *main.c* file located
    in the *Project 7* subfolder of the *Chapter 2* folder:'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: XOR 运算符在你希望当两个数字的位值不同时时打开输出时非常有用。要查看这一点，可以使用与[项目 3](nsp-boxall502581-0012.xhtml#pro3)相同的电路，并打开位于
    *Chapter 2* 文件夹下 *Project 7* 子文件夹中的 *main.c* 文件：
- en: '[PRE30]'
  id: totrans-278
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Once again, the code’s main loop counts from 0 to 255\. Every time the code
    loops, it performs an XOR on `0b11111111` and the variable `i` and sets `PORTB`
    to the result of the operation. For example, if `i` has a value of 15, or `0b00001111`
    , the result of `0b11111111 ^ 0b00001111` is `0b11110000` .
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 代码的主循环再次从 0 计数到 255。每次循环时，代码都会对 `0b11111111` 和变量 `i` 进行 XOR 运算，并将 `PORTB` 设置为运算结果。例如，如果
    `i` 的值为 15，或 `0b00001111`，则 `0b11111111 ^ 0b00001111` 的结果为 `0b11110000`。
- en: When you run this code on your AVR, it should demonstrate counting in binary
    from 0 to 255\. However, in this case the LEDs are lit in an inverse fashion—that
    is, numbers are shown with LEDs that are off, not on.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 当你在 AVR 上运行此代码时，它应展示从 0 到 255 的二进制计数。然而，在这种情况下，LED 会以反向的方式点亮——也就是说，数字通过 LED
    显示时是关闭的，而不是打开的。
- en: As this chapter concludes, I encourage you to experiment with the code samples.
    Enjoy creating patterns, learning about bitwise arithmetic, and bit shifting using
    your newfound knowledge. In the [next chapter](nsp-boxall502581-0013.xhtml#ch03)
    , you’ll learn to use the inputs of your microcontrollers to create interactive
    devices.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 本章结束时，我鼓励你实验代码示例。享受创造图案、学习位运算和使用位移的过程，利用你新获得的知识。在[下一章](nsp-boxall502581-0013.xhtml#ch03)中，你将学习如何使用微控制器的输入来创建互动设备。
