- en: '9'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '9'
- en: Numeric Conversion
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 数字转换
- en: '![](image_fi/book_art/chapterart.png)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![](image_fi/book_art/chapterart.png)'
- en: This chapter discusses the conversion between various numeric formats, including
    integer to decimal string, integer to hexadecimal string, floating-point to string,
    hexadecimal string to integer, decimal string to integer, and real string to floating-point.
    In addition to the basic conversions, this chapter discusses error handling (for
    string-to-numeric conversions) and performance enhancements. This chapter discusses
    standard-precision conversions (for 8-, 16-, 32-, and 64-bit integer formats)
    as well as extended-precision conversions (for example, 128-bit integer and string
    conversions).
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章讨论了不同数字格式之间的转换，包括整数到十进制字符串、整数到十六进制字符串、浮点数到字符串、十六进制字符串到整数、十进制字符串到整数，以及实数字符串到浮点数。除了基本的转换外，本章还讨论了错误处理（对于字符串到数字的转换）和性能优化。本章讨论了标准精度转换（适用于8位、16位、32位和64位整数格式）以及扩展精度转换（例如，128位整数和字符串转换）。
- en: 9.1 Converting Numeric Values to Strings
  id: totrans-4
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 9.1 将数字值转换为字符串
- en: Up to this point, this book has relied upon the C Standard Library to perform
    numeric I/O (writing numeric data to the display and reading numeric data from
    the user). However, the C Standard Library doesn’t provide extended-precision
    numeric I/O facilities (and even 64-bit numeric I/O is questionable; this book
    has been using a Microsoft extension to `printf()` to do 64-bit numeric output).
    Therefore, it’s time to break down and discuss how to do numeric I/O in assembly
    language—well, sort of. Because most operating systems support only character
    or string input and output, we aren’t going to do actual numeric I/O. Instead,
    we’re going write functions that convert between numeric values and strings, and
    then do string I/O.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，本书依赖于C标准库来执行数字输入输出（将数字数据写入显示器并从用户读取数字数据）。然而，C标准库没有提供扩展精度的数字输入输出功能（甚至64位数字输入输出也有问题；本书使用了Microsoft扩展的`printf()`来进行64位数字输出）。因此，现在是时候解析并讨论如何在汇编语言中进行数字输入输出了——嗯，算是吧。因为大多数操作系统仅支持字符或字符串输入输出，我们不会进行实际的数字输入输出。相反，我们将编写将数字值与字符串之间转换的函数，然后进行字符串输入输出。
- en: The examples in this section work specifically with 64-bit (non-extended-precision)
    and 128-bit values, but the algorithms are general and extend to any number of
    bits.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 本节中的示例专门处理64位（非扩展精度）和128位值，但算法是通用的，可以扩展到任何位数。
- en: 9.1.1 Converting Numeric Values to Hexadecimal Strings
  id: totrans-7
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 9.1.1 将数字值转换为十六进制字符串
- en: Converting a numeric value to a hexadecimal string is relatively straightforward.
    Just take each nibble (4 bits) in the binary representation and convert that to
    one of the 16 characters “0” through “9” or “A” through “F”. Consider the `btoh`
    function in [Listing 9-1](#listing9-1) that takes a byte in the AL register and
    returns the two corresponding characters in AH (HO nibble) and AL (LO nibble).
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 将数值转换为十六进制字符串相对简单。只需将二进制表示中的每个半字节（4位）转换为“0”到“9”或“A”到“F”中的一个字符。请参考[清单9-1](#listing9-1)中的`btoh`函数，该函数接收AL寄存器中的一个字节，并返回AH（高半字节）和AL（低半字节）中的两个对应字符。
- en: '[PRE0]'
  id: totrans-9
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Listing 9-1: A function that converts a byte to two hexadecimal characters'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 清单9-1：一个将字节转换为两个十六进制字符的函数
- en: You can convert any numeric value in the range 0 to 9 to its corresponding ASCII
    character by ORing the numeric value with 0 (30h). Unfortunately, this maps numeric
    values in the range 0Ah through 0Fh to 3Ah through 3Fh. So, the code in [Listing
    9-1](#listing9-1) checks to see if it produces a value greater than 3Ah and adds
    7 to produce a final character code in the range 41h to 46h (“A” through “F”).
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过将数值与0（30h）进行按位或运算，将0到9范围内的任何数值转换为相应的ASCII字符。不幸的是，这会将0Ah到0Fh的数值映射到3Ah到3Fh。因此，[清单9-1](#listing9-1)中的代码会检查其是否产生大于3Ah的值，并加上7，以生成最终的字符代码，范围是41h到46h（“A”到“F”）。
- en: Once we can convert a single byte to a pair of hexadecimal characters, creating
    a string, output to the display is straightforward. We can call the `btoh` (*byte
    to hex*) function for each byte in the number and store the corresponding characters
    away in a string. [Listing 9-2](#listing9-2) provides examples of `btoStr` (*byte
    to string*), `wtoStr` (*word to string*), `dtoStr` (*double word to string*),
    and `qtoStr` (*quad word to string*) functions.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们能够将单个字节转换为一对十六进制字符，创建一个字符串并输出到显示器就变得简单了。我们可以对数字中的每个字节调用`btoh`（*字节到十六进制*）函数，并将相应的字符存储在字符串中。[清单9-2](#listing9-2)提供了`btoStr`（*字节到字符串*）、`wtoStr`（*字词到字符串*）、`dtoStr`（*双字到字符串*）和`qtoStr`（*四字到字符串*）函数的示例。
- en: '[PRE1]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Listing 9-2: `btoStr`, `wtoStr`, `dtoStr`, and `qtoStr` functions'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 清单 9-2：`btoStr`、`wtoStr`、`dtoStr`和`qtoStr`函数
- en: 'Here’s the build command and sample output:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 这是构建命令和示例输出：
- en: '[PRE2]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Each successive function in [Listing 9-2](#listing9-2) builds on the work done
    in the previous functions. For example, `wtoStr` calls `btoStr` twice to convert
    the 2 bytes in AX to a string of four hexadecimal characters. The code would be
    faster (but a lot larger) if you were to inline-expand each of these functions
    wherever the code calls them. If you needed only *one* of these functions, an
    inline expansion of any calls it makes would be worth the extra effort.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: '[清单 9-2](#listing9-2)中的每个后续函数都建立在前一个函数的基础上。例如，`wtoStr`调用`btoStr`两次，将AX中的2个字节转换为4个十六进制字符的字符串。如果你在每个调用这些函数的地方都内联展开它们，代码会更快（但也会变得更大）。如果你只需要*其中一个*函数，内联展开它的所有调用会值得付出额外的努力。'
- en: 'Here’s a version of `qtoStr` with two improvements: inline expansion of the
    calls to `dtoStr`, `wtoStr`, and `btoStr`, plus the use of a simple table lookup
    (array access) to do the nibble-to-hex-character conversion (see Chapter 10 for
    more information on table lookups). The framework for this faster version of `qtoStr`
    appears in [Listing 9-3](#listing9-3).'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 这是`qtoStr`的一个版本，包含两个改进：内联展开对`dtoStr`、`wtoStr`和`btoStr`的调用，以及使用一个简单的表查找（数组访问）来进行半字节到十六进制字符的转换（有关表查找的更多信息，请参见第10章）。这个更快版本的`qtoStr`的框架出现在[清单
    9-3](#listing9-3)中。
- en: '[PRE3]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Listing 9-3: Faster implementation of `qtoStr`'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 清单 9-3：`qtoStr`的更快实现
- en: Writing a short main program that contains the following loop
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 编写一个简短的主程序，包含以下循环
- en: '[PRE4]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'and then using a stopwatch on an old 2012-era 2.6 GHz Intel Core i7 processor,
    I got the approximate timings for the inline and original versions of `qtoStr`:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我使用一台2012年款的2.6 GHz Intel Core i7处理器，通过秒表得到了`qtoStr`内联版本和原始版本的大致执行时间：
- en: 'Inline version: 19 seconds'
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 内联版本：19秒
- en: 'Original version: 85 seconds'
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 原始版本：85秒
- en: As you can see, the inline version is significantly (four times) faster, but
    you probably won’t convert 64-bit numbers to hexadecimal strings often enough
    to justify the kludgy code of the inline version.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，内联版本显著（快了四倍）更快，但你可能不会经常将64位数字转换为十六进制字符串，因此不足以为内联版本那种不够简洁的代码辩护。
- en: For what it’s worth, you could probably cut the time almost in half by using
    a much larger table (256 16-bit entries) for the hex characters and convert a
    whole byte at a time rather than a nibble. This would require half the instructions
    of the inline version (though the table would be 32 times bigger).
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 说实话，你可能通过使用一个更大的表（256个16位条目）来表示十六进制字符，并一次转换一个字节，而不是一个半字节，从而将时间几乎减少一半。这将需要比内联版本少一半的指令（尽管表的大小将增加32倍）。
- en: 9.1.2 Converting Extended-Precision Hexadecimal Values to Strings
  id: totrans-28
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 9.1.2 将扩展精度十六进制值转换为字符串
- en: 'Extended-precision hexadecimal-to-string conversion is easy. It’s simply an
    extension of the normal hexadecimal conversion routines from the previous section.
    For example, here’s a 128-bit hexadecimal conversion function:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 扩展精度的十六进制到字符串的转换非常简单。它只是上一节中正常十六进制转换例程的扩展。例如，这里是一个128位的十六进制转换函数：
- en: '[PRE5]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 9.1.3 Converting Unsigned Decimal Values to Strings
  id: totrans-31
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 9.1.3 将无符号十进制值转换为字符串
- en: Decimal output is a little more complicated than hexadecimal output because
    the HO bits of a binary number affect the LO digits of the decimal representation
    (this was not true for hexadecimal values, which is why hexadecimal output is
    so easy). Therefore, we will have to create the decimal representation for a binary
    number by extracting one decimal digit at a time from the number.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 十进制输出比十六进制输出稍微复杂一些，因为二进制数字的高位（HO位）会影响十进制表示中的低位数字（十六进制值并不受此影响，这也是为什么十六进制输出如此简单的原因）。因此，我们需要通过从数字中提取每一位十进制数字，来创建二进制数的十进制表示。
- en: The most common solution for unsigned decimal output is to successively divide
    the value by 10 until the result becomes 0\. The remainder after the first division
    is a value in the range 0 to 9, and this value corresponds to the LO digit of
    the decimal number. Successive divisions by 10 (and their corresponding remainder)
    extract successive digits from the number.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 输出无符号十进制数的最常见方法是不断地将值除以10，直到结果变为0。第一次除法后的余数是一个0到9之间的数值，这个值对应十进制数的低位数字。通过连续除以10（以及对应的余数），可以提取数字的每一位。
- en: Iterative solutions to this problem generally allocate storage for a string
    of characters large enough to hold the entire number. Then the code extracts the
    decimal digits in a loop and places them in the string one by one. At the end
    of the conversion process, the routine prints the characters in the string in
    reverse order (remember, the divide algorithm extracts the LO digits first and
    the HO digits last, the opposite of the way you need to print them).
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 对这个问题的迭代解决方案通常会分配足够大的存储空间来容纳整个数字的字符字符串。然后，代码在循环中提取十进制数字，并将它们逐一放入字符串中。在转换过程结束时，例程会以相反的顺序打印字符串中的字符（记住，除法算法先提取低位数字，最后提取高位数字，这与你需要打印的顺序正好相反）。
- en: 'This section employs a *recursive solution* because it is a little more elegant.
    This solution begins by dividing the value by 10 and saving the remainder in a
    local variable. If the quotient is not 0, the routine recursively calls itself
    to output any leading digits first. On return from the recursive call (which outputs
    all the leading digits), the recursive algorithm outputs the digit associated
    with the remainder to complete the operation. Here’s how the operation works when
    printing the decimal value 789:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 本节采用了*递归解决方案*，因为它稍微更优雅一些。该解决方案首先通过将值除以 10 并将余数保存在局部变量中开始。如果商不为 0，例程会递归调用自己，先输出所有前导数字。递归调用返回后（输出了所有前导数字），递归算法会输出与余数相关的数字，完成操作。当打印十进制值
    789 时，操作过程如下：
- en: Divide 789 by 10\. The quotient is 78, and the remainder is 9.
  id: totrans-36
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 789 除以 10。商为 78，余数为 9。
- en: Save the remainder (9) in a local variable and recursively call the routine
    with the quotient.
  id: totrans-37
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将余数（9）保存在一个局部变量中，并递归地调用该例程，使用商值作为参数。
- en: '*Recursive entry 1*: Divide 78 by 10\. The quotient is 7, and the remainder
    is 8.'
  id: totrans-38
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '*递归入口 1*：将 78 除以 10。商为 7，余数为 8。'
- en: Save the remainder (8) in a local variable and recursively call the routine
    with the quotient.
  id: totrans-39
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将余数（8）保存在局部变量中，并递归地调用该例程，使用商值作为参数。
- en: '*Recursive entry 2*: Divide 7 by 10\. The quotient is 0, and the remainder
    is 7.'
  id: totrans-40
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '*递归入口 2*：将 7 除以 10。商为 0，余数为 7。'
- en: Save the remainder (7) in a local variable. Because the quotient is 0, don’t
    call the routine recursively.
  id: totrans-41
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将余数（7）保存在局部变量中。由于商为 0，不再递归调用例程。
- en: Output the remainder value saved in the local variable (7). Return to the caller
    (recursive entry 1).
  id: totrans-42
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 输出保存在局部变量中的余数值（7）。返回到调用者（递归入口 1）。
- en: '*Return to recursive entry 1*: Output the remainder value saved in the local
    variable in recursive entry 1 (8). Return to the caller (original invocation of
    the procedure).'
  id: totrans-43
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '*返回到递归入口 1*：输出在递归入口 1 中保存在局部变量中的余数值（8）。返回到调用者（原始例程调用）。'
- en: '*Original invocation*: Output the remainder value saved in the local variable
    in the original call (9). Return to the original caller of the output routine.'
  id: totrans-44
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '*原始调用*：输出原始调用中保存在局部变量中的余数值（9）。返回到输出例程的原始调用者。'
- en: '[Listing 9-4](#listing9-4) implements the recursive algorithm.'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: '[列表 9-4](#listing9-4) 实现了递归算法。'
- en: '[PRE6]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Listing 9-4: Unsigned integer-to-string function (recursive)'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 9-4：无符号整数到字符串的转换函数（递归）
- en: 'Here’s the build command and program output:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 这是构建命令和程序输出：
- en: '[PRE7]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Unlike hexadecimal output, there really is no need to provide a byte-size, word-size,
    or dword-size numeric-to-decimal-string conversion function. Simply zero-extending
    the smaller values to 64 bits is sufficient. Unlike the hexadecimal conversions,
    there are no leading zeros emitted by the `qtoStr` function, so the output is
    the same for all sizes of variables (64 bits and smaller).
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 与十六进制输出不同，实际上没有必要提供字节大小、字大小或双字大小的数字到十进制字符串的转换函数。只需要将较小的值零扩展到 64 位即可。与十六进制转换不同，`qtoStr`
    函数不会输出前导零，因此对于所有大小的变量（64 位及以下），输出是相同的。
- en: Unlike the hexadecimal conversion (which is very fast to begin with, plus you
    don’t really call it that often), you will frequently call the integer-to-string
    conversion function. Because it uses the `div` instruction, it can be fairly slow.
    Fortunately, we can speed it up by using the `fist` and `fbstp` instructions.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 与十六进制转换（本身就非常快速，而且你也不常用它）不同，整数到字符串的转换函数你会频繁调用。因为它使用了 `div` 指令，所以可能会比较慢。幸运的是，我们可以通过使用
    `fist` 和 `fbstp` 指令来加速它。
- en: The `fbstp` instruction converts the 80-bit floating-point value currently sitting
    on the top of stack to an 18-digit packed BCD value (using the format appearing
    in [Figure 6-7](c06.xhtml#figure6-7) in Chapter 6). The `fist` instruction allows
    you to load a 64-bit integer onto the FPU stack. So, by using these two instructions,
    you can (mostly) convert a 64-bit integer to a packed BCD value, which encodes
    a single decimal digit per 4 bits. Therefore, you can convert the packed BCD result
    that `fbstp` produces to a character string by using the same algorithm you use
    for converting hexadecimal numbers to a string.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: '`fbstp` 指令将当前位于栈顶的 80 位浮点值转换为一个 18 位的打包 BCD 值（采用第 6 章中 [图 6-7](c06.xhtml#figure6-7)
    所示的格式）。`fist` 指令允许将一个 64 位整数加载到 FPU 栈上。因此，通过使用这两个指令，你可以（大部分）将一个 64 位整数转换为打包 BCD
    值，该值每 4 位编码一个十进制数字。因此，你可以使用将十六进制数字转换为字符串的相同算法，将 `fbstp` 产生的打包 BCD 结果转换为字符字符串。'
- en: 'There is only one catch with using `fist` and `fbstp` to convert an integer
    to a string: the Intel packed BCD format (see [Figure 6-7](c06.xhtml#figure6-7)
    in Chapter 6) supports only 18 digits, whereas a 64-bit integer can have up to
    19 digits. Therefore, any `fbstp`-based `utoStr` function will have to handle
    that 19th digit as a special case. With all this in mind, [Listing 9-5](#listing9-5)
    provides this new version of the `utoStr` function.'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `fist` 和 `fbstp` 将整数转换为字符串时，有一个小问题：Intel 打包 BCD 格式（见第 6 章中的 [图 6-7](c06.xhtml#figure6-7)）仅支持
    18 位，而 64 位整数最多可以有 19 位。因此，任何基于 `fbstp` 的 `utoStr` 函数都必须处理第 19 位作为特殊情况。考虑到这一点，[清单
    9-5](#listing9-5) 提供了这个新的 `utoStr` 函数版本。
- en: '[PRE8]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Listing 9-5: A `fist` and `fbstp`-based `utoStr` function'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 清单 9-5：基于 `fist` 和 `fbstp` 的 `utoStr` 函数
- en: 'Here’s the build command and sample output from this program:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 这是该程序的构建命令和示例输出：
- en: '[PRE9]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The program in [Listing 9-5](#listing9-5) does use a `div` instruction, but
    it executes only once or twice, and only if there are 19 or 20 digits in the number.
    Therefore, the execution time of this `div` instruction will have little overall
    impact on the speed of the `utoStr` function (especially when you consider how
    often you actually print 19-digit numbers).
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: '[清单 9-5](#listing9-5) 中的程序确实使用了 `div` 指令，但它仅执行一到两次，而且仅当数字中有 19 或 20 位时才会执行。因此，这个
    `div` 指令的执行时间对 `utoStr` 函数的整体速度影响很小（尤其是在你考虑到实际打印 19 位数字的频率时）。'
- en: 'I got the following execution times on a 2.6 GHz circa-2012 Core i7 processor:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 我在一台 2.6 GHz 的 2012 年左右的 Core i7 处理器上得到了以下执行时间：
- en: 'Original `utoStr`: 108 seconds'
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 原始 `utoStr`：108 秒
- en: '`fist` and `fbstp` implementation: 11 seconds'
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`fist` 和 `fbstp` 实现：11 秒'
- en: Clearly, the `fist` and `fbstp` implementation is the winner.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，`fist` 和 `fbstp` 的实现是赢家。
- en: 9.1.4 Converting Signed Integer Values to Strings
  id: totrans-63
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 9.1.4 带符号整数值转换为字符串
- en: To convert a signed integer value to a string, you first check to see if the
    number is negative; if it is, you emit a hyphen (-) character and negate the value.
    Then you call the `utoStr` function to finish the job. [Listing 9-6](#listing9-6)
    shows the relevant code.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 要将带符号整数值转换为字符串，首先检查该数字是否为负数；如果是，则输出一个连字符（-）并取其绝对值。然后调用 `utoStr` 函数完成剩余的转换。[清单
    9-6](#listing9-6) 显示了相关代码。
- en: '[PRE10]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Listing 9-6: Signed integer-to-string conversion'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 清单 9-6：带符号整数到字符串转换
- en: 9.1.5 Converting Extended-Precision Unsigned Integers to Strings
  id: totrans-67
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 9.1.5 扩展精度无符号整数转换为字符串
- en: For extended-precision output, the only operation through the entire string-conversion
    algorithm that requires extended-precision arithmetic is the divide-by-10 operation.
    Because we are dividing an extended-precision value by a value that easily fits
    into a quad word, we can use the fast (and easy) extended-precision division algorithm
    that uses the `div` instruction (see “Special Case Form Using `div` Instruction”
    in “Extended-Precision Division” in Chapter 8). [Listing 9-7](#listing9-7) implements
    a 128-bit decimal output routine utilizing this technique.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 对于扩展精度输出，整个字符串转换算法中唯一需要扩展精度运算的操作是除以 10 操作。因为我们要用扩展精度值除以一个轻松适配到四字单元的值，我们可以使用快速（且简单的）扩展精度除法算法，采用
    `div` 指令（详见第 8 章中的《使用 `div` 指令的特殊情况形式》部分）。[清单 9-7](#listing9-7) 实现了一个使用该技术的 128
    位十进制输出例程。
- en: '[PRE11]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Listing 9-7: 128-bit extended-precision decimal output routine'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 清单 9-7：128 位扩展精度十进制输出例程
- en: 'Here’s the build command and program output:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 这是构建命令和程序输出：
- en: '[PRE12]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Sadly, we cannot use the `fbstp` instruction to improve the performance of this
    algorithm as `fbstp` is limited to 80-bit BCD values.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 可惜，我们不能使用`fbstp`指令来提高该算法的性能，因为`fbstp`仅限于 80 位 BCD 值。
- en: 9.1.6 Converting Extended-Precision Signed Decimal Values to Strings
  id: totrans-74
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 9.1.6 将扩展精度有符号十进制值转换为字符串
- en: 'Once you have an extended-precision unsigned decimal output routine, writing
    an extended-precision signed decimal output routine is easy. The basic algorithm
    is similar to that for 64-bit integers given earlier:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你有了扩展精度无符号十进制输出例程，编写扩展精度有符号十进制输出例程就很简单了。基本算法与之前给出的 64 位整数类似：
- en: Check the sign of the number.
  id: totrans-76
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 检查数字的符号。
- en: If it is positive, call the unsigned output routine to print it. If the number
    is negative, print a minus sign. Then negate the number and call the unsigned
    output routine to print it.
  id: totrans-77
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果是正数，调用无符号输出例程打印它。如果是负数，则打印一个负号。然后将该数字取反，并调用无符号输出例程打印它。
- en: To check the sign of an extended-precision integer, test the HO bit of the number.
    To negate a large value, the best solution is probably to subtract that value
    from 0\. [Listing 9-8](#listing9-8) is a quick version of `i128toStr` that uses
    the `otoStr` routine from the previous section.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 要检查扩展精度整数的符号，请测试数字的 HO 位。为了取反一个大数，最好的解决方案可能是从 0 中减去该值。[列表 9-8](#listing9-8)是一个快速版的`i128toStr`，它使用了上一节中的`otoStr`例程。
- en: '[PRE13]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Listing 9-8: 128-bit signed integer-to-string conversion'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 9-8：128 位有符号整数到字符串的转换
- en: 9.1.7 Formatted Conversions
  id: totrans-81
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 9.1.7 格式化转换
- en: The code in the previous sections converted signed and unsigned integers to
    strings by using the minimum number of necessary character positions. To create
    nicely formatted tables of values, you will need to write functions that provide
    appropriate padding in front of the string of digits before actually emitting
    the digits. Once you have the “unformatted” versions of these routines, implementing
    the formatted versions is easy.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 前面部分的代码通过使用最少的必要字符位置将有符号和无符号整数转换为字符串。为了创建格式化良好的值表，你需要编写在输出数字之前为数字字符串提供适当填充的函数。一旦你有了这些例程的“未格式化”版本，实现格式化版本就很容易了。
- en: The first step is to write `iSize` and `uSize` routines that compute the minimum
    number of character positions needed to display the value. One algorithm to accomplish
    this is similar to the numeric string conversion routines. In fact, the only difference
    is that you initialize a counter to 0 upon entry into the routine (for example,
    the nonrecursive shell routine), and you increment this counter rather than outputting
    a digit on each recursive call. (Don’t forget to increment the counter inside
    `iSize` if the number is negative; you must allow for the output of the minus
    sign.) After the calculation is complete, these routines should return the size
    of the operand in the EAX register.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 第一步是编写`iSize`和`uSize`例程，计算显示值所需的最小字符位置数。实现此目标的一个算法类似于数字字符串转换例程。实际上，唯一的区别是进入例程时初始化一个计数器为
    0（例如，非递归外壳例程），然后在每次递归调用时增加此计数器，而不是输出一个数字。（不要忘记在数字为负时在`iSize`中增加计数器；你必须为输出负号留出空间。）计算完成后，这些例程应该将操作数的大小返回到
    EAX 寄存器。
- en: 'The only problem is that such a conversion scheme is slow (using recursion
    and `div` is not very fast). As it turns out, a brute-force version that simply
    compares the integer value against 1, 10, 100, 1000, and so on, works much faster.
    Here’s the code that will do this:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 唯一的问题是这种转换方案速度较慢（使用递归和`div`并不是很快）。事实证明，一个简单的暴力版本，通过将整数值与 1、10、100、1000 等进行比较，运行得要快得多。以下是实现这一点的代码：
- en: '[PRE14]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'For signed integers, you can use the following code:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 对于有符号整数，可以使用以下代码：
- en: '[PRE15]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: For extended-precision size operations, the brute-force approach quickly becomes
    unwieldy (64 bits is bad enough). The best solution is to divide your extended-precision
    value by a power of 10 (say, 1e+18). This will reduce the size of the number by
    18 digits. Repeat this process as long as the quotient is greater than 64 bits
    (keeping track of the number of times you’ve divided the number by 1e+18). When
    the quotient fits into 64 bits (19 or 20 digits), call the 64-bit `uSize` function
    and add in the number of digits you eliminated with the division operation (18
    for each division by 1e+18). The implementation is left to you on this one . .
    .
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 对于扩展精度的大小操作，暴力算法方法很快就变得不切实际（64 位已经够糟糕了）。最佳解决方案是将扩展精度值除以 10 的幂（例如，1e+18）。这样可以将数字的大小减少
    18 位。只要商大于 64 位（并跟踪除以 1e+18 的次数），就重复这一过程。当商适合 64 位（19 或 20 位数字）时，调用 64 位的 `uSize`
    函数，并加上你通过除法操作消除的数字位数（每除以 1e+18 减少 18 位）。这个实现留给你自己完成……
- en: Once you have the `iSize` and `uSize` routines, writing the formatted output
    routines, `utoStrSize` or `itoStrSize`, is easy. On initial entry, these routines
    call the corresponding `iSize` or `uSize` routine to determine the number of character
    positions for the number. If the value that the `iSize` or `uSize` routine returns
    is greater than the value of the minimum size parameter (passed into `utoStrSize`
    or `itoStrSize`), no other formatting is necessary. If the value of the parameter
    size is greater than the value `iSize` or `uSize` returns, the program must compute
    the difference between these two values and emit that many spaces (or other filler
    characters) to the output string before the numeric conversion. [Listing 9-9](#listing9-9)
    shows the `utoStrSize` and `itoStrSize` functions.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你有了 `iSize` 和 `uSize` 例程，编写格式化输出例程 `utoStrSize` 或 `itoStrSize` 就变得容易了。初次进入时，这些例程会调用相应的
    `iSize` 或 `uSize` 例程来确定数字所需的字符位置数。如果 `iSize` 或 `uSize` 例程返回的值大于最小大小参数（传入 `utoStrSize`
    或 `itoStrSize` 的值），则不需要其他格式化操作。如果参数大小的值大于 `iSize` 或 `uSize` 返回的值，程序必须计算这两个值之间的差异，并在数字转换之前将相应数量的空格（或其他填充字符）输出到字符串中。[清单
    9-9](#listing9-9) 显示了 `utoStrSize` 和 `itoStrSize` 函数。
- en: '[PRE16]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Listing 9-9: Formatted integer-to-string conversion functions'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 清单 9-9：格式化整数到字符串的转换函数
- en: 9.1.8 Converting Floating-Point Values to Strings
  id: totrans-92
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 9.1.8 将浮点值转换为字符串
- en: The code appearing thus far in this chapter has dealt with converting integer
    numeric values to character strings (typically for output to the user). Converting
    floating-point values to a string is just as important. This section (and its
    subsections) covers that conversion.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 本章迄今为止的代码涉及将整数数值转换为字符字符串（通常用于输出给用户）。将浮点数值转换为字符串同样重要。本节（及其子节）涵盖了这一转换。
- en: 'Floating-point values can be converted to strings in one of two forms:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 浮点数值可以转换为两种形式的字符串：
- en: Decimal notation conversion (for example, ± *xxx.yyy* format)
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 十进制表示法转换（例如，± *xxx.yyy* 格式）
- en: Exponential (or scientific) notation conversion (for example, ± *x.yyyyye* ±
    *zz* format)
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 指数（或科学）表示法转换（例如，± *x.yyyyye* ± *zz* 格式）
- en: Regardless of the final output format, two distinct operations are needed to
    convert a value in floating-point form to a character string. First, you must
    convert the mantissa to an appropriate string of digits. Second, you must convert
    the exponent to a string of digits.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 无论最终的输出格式如何，都需要两个不同的操作来将浮点值转换为字符字符串。首先，你必须将尾数转换为适当的数字字符串。其次，你必须将指数转换为数字字符串。
- en: 'However, this isn’t a simple case of converting two integer values to a decimal
    string and concatenating them (with an *e* between the mantissa and exponent).
    First of all, the mantissa is not an integer value: it is a fixed-point fractional
    binary value. Simply treating it as an *n*-bit binary value (where *n* is the
    number of mantissa bits) will almost always result in an incorrect conversion.
    Second, while the exponent is, more or less, an integer value,^([1](#c09-footnote-1))
    it represents a power of 2, not a power of 10\. Displaying that power of 2 as
    an integer value is not appropriate for decimal floating-point representation.
    Dealing with these two issues (fractional mantissa and binary exponent) is the
    major complication associated with converting a floating-point value to a string.'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这并不是一个简单的将两个整数值转换为十进制字符串并连接它们（在尾数和指数之间加上一个*e*）的情况。首先，尾数不是一个整数值：它是一个定点小数二进制值。简单地将它视为一个*n*位的二进制值（其中*n*是尾数位数）几乎总会导致转换错误。其次，虽然指数在某种程度上是一个整数值，^([1](#c09-footnote-1))
    它表示的是2的幂，而不是10的幂。将2的幂以整数形式显示并不适合十进制浮动点表示。处理这两个问题（分数尾数和二进制指数）是将浮动点值转换为字符串的主要复杂性所在。
- en: Though there are three floating-point formats on the x86-64—single-precision
    (32-bit `real4`), double-precision (64-bit `real8`), and extended-precision (80-bit
    `real10`)—the x87 FPU automatically converts the `real4` and `real8` formats to
    `real10` upon loading the value into the FPU. Therefore, by using the x87 FPU
    for all floating-point arithmetic during the conversion, all we need to do is
    write code to convert `real10` values into string form.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管在x86-64上有三种浮动点格式——单精度（32位`real4`）、双精度（64位`real8`）和扩展精度（80位`real10`）——x87 FPU在将值加载到FPU时会自动将`real4`和`real8`格式转换为`real10`格式。因此，通过在转换过程中使用x87
    FPU进行所有浮动点算术操作，我们只需要编写代码将`real10`值转换为字符串形式。
- en: '`real10` floating-point values have a 64-bit mantissa. This is not a 64-bit
    integer. Instead, those 64 bits represent a value between 0 and slightly less
    than 2\. (See “IEEE Floating-Point Formats” in Chapter 2 for more details on the
    IEEE 80-bit floating-point format.) Bit 63 is usually 1\. If bit 63 is 0, the
    mantissa is denormalized, representing numbers between 0 and about 3.65 × 10^(-4951).'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: '`real10`浮动点值具有64位尾数。这不是一个64位整数。相反，这64位表示的值介于0和略小于2之间。（有关IEEE 80位浮动点格式的更多细节，请参见第2章中的《IEEE浮动点格式》）第63位通常为1。如果第63位为0，则尾数是非规格化的，表示介于0和大约3.65
    × 10^(-4951)之间的数字。'
- en: To output the mantissa in decimal form with approximately 18 digits of precision,
    the trick is to successively multiply or divide the floating-point value by 10
    until the number is between 1e+18 and just less than 1e+19 (that is, 9.9999 .
    . . e+18). Once the exponent is in the appropriate range, the mantissa bits form
    an 18-digit integer value (no fractional part), which can be converted to a decimal
    string to obtain the 18 digits that make up the mantissa value (using our friend,
    the `fbstp` instruction). In practice, you would multiply or divide by large powers
    of 10 to get the value into the range 1e+18 to 1e+19\. This is faster (fewer floating-point
    operations) and more accurate (also because of fewer floating-point operations).
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 要以大约18位精度以十进制形式输出尾数，诀窍是反复将浮动点值乘以或除以10，直到该数字位于1e+18和略小于1e+19之间（即9.9999...e+18）。一旦指数在适当的范围内，尾数位将形成一个18位的整数值（没有小数部分），该值可以转换为十进制字符串，从而获得组成尾数值的18个数字（使用我们的好朋友`fbstp`指令）。实际上，你可以通过将浮动点值乘以或除以大的10的幂来将其值调整到1e+18到1e+19的范围。这种方法更快（浮动点操作较少），也更精确（同样因为浮动点操作较少）。
- en: To convert the exponent to an appropriate decimal string, you need to track
    the number of multiplications or divisions by 10\. For each division by 10, add
    1 to the decimal exponent value; for each multiplication by 10, subtract 1 from
    the decimal exponent value. At the end of the process, subtract 18 from the decimal
    exponent value (as this process produces a value whose exponent is 18) and convert
    the decimal exponent value to a string.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 要将指数转换为适当的十进制字符串，你需要追踪除以或乘以10的次数。每次除以10时，将十进制指数值加1；每次乘以10时，将十进制指数值减1。过程结束时，从十进制指数值中减去18（因为此过程产生的值的指数是18），然后将十进制指数值转换为字符串。
- en: 9.1.8.1 Converting Floating-Point Exponents
  id: totrans-103
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 9.1.8.1 转换浮动点指数
- en: 'To convert the exponent to a string of decimal digits, use the following algorithm:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 要将指数转换为十进制数字字符串，请使用以下算法：
- en: If the number is 0.0, directly produce the mantissa output string of “ 000000000000000000”
    (notice the space at the beginning of the string).
  id: totrans-105
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果数字是 0.0，直接输出尾数字符串“ 000000000000000000”（注意字符串开头的空格）。
- en: Initialize the decimal exponent to 0.
  id: totrans-106
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将十进制指数初始化为 0。
- en: If the exponent is negative, emit a hyphen (-) character and negate the value;
    if it is positive, emit a space character.
  id: totrans-107
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果指数为负，输出一个连字符（-）并取反值；如果是正数，则输出一个空格字符。
- en: If the value of the (possibly negated) exponent is less than 1.0, go to step
    8.
  id: totrans-108
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果（可能为负的）指数值小于 1.0，跳至步骤 8。
- en: '*Positive exponents*: Compare the number against successively smaller powers
    of 10, starting with 10^(+4096), then 10^(+2048), then 10^(+1024), then . . .
    , then 10⁰. After each comparison, if the current value is greater than the power
    of 10, divide by that power of 10 and add the power of 10 exponent (4096, 2048,
    . . . , 0) to the decimal exponent value.'
  id: totrans-109
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '*正指数*：将数字与逐渐减小的 10 的幂进行比较，从 10^(+4096) 开始，然后是 10^(+2048)，然后是 10^(+1024)，然后是...，最后是
    10⁰。每次比较后，如果当前值大于该幂次，则除以该幂次，并将该幂次的指数（4096, 2048, ... , 0）加到十进制指数值上。'
- en: Repeat step 5 until the exponent is 0 (that is, the value is in the range 1.0
    ≤ value < 10.0).
  id: totrans-110
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 重复步骤 5，直到指数为 0（即值处于 1.0 ≤ value < 10.0 范围内）。
- en: Go to step 10.
  id: totrans-111
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 跳至步骤 10。
- en: '*Negative exponents*: Compare the number against successful larger powers of
    10 starting with 10^(-4096), then 10^(-2048), then 10^(-1024), then . . . , then
    10⁰. After each comparison, if the current value is less than the power of 10,
    divide by that power of 10 and subtract the power of 10 exponent (4096, 2048,
    . . . , 0) from the decimal exponent value.'
  id: totrans-112
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '*负指数*：将数字与逐渐增大的 10 的幂进行比较，从 10^(-4096) 开始，然后是 10^(-2048)，然后是 10^(-1024)，然后是...，最后是
    10⁰。每次比较后，如果当前值小于该幂次，则除以该幂次，并将该幂次的指数（4096, 2048, ... , 0）从十进制指数值中减去。'
- en: Repeat step 8 until the exponent is 0 (that is, the value is in the range 1.0
    ≤ value < 10.0).
  id: totrans-113
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 重复步骤 8，直到指数为 0（即值处于 1.0 ≤ value < 10.0 范围内）。
- en: Certain legitimate floating-point values are too large to represent with 18
    digits (for example, 9,223,372,036,854,775,807 fits into 63 bits but requires
    more than 18 significant digits to represent). Specifically, values in the range
    403A_DE0B_6B3A_763F_FF01h to 403A_DE0B_6B3A_763F_FFFFh are greater than 999,999,999,999,999,999
    but still fit within a 64-bit mantissa. The `fbstp` instruction will not be able
    to convert these values to a packed BCD value.
  id: totrans-114
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 某些合法的浮点值太大，无法用 18 位数字表示（例如，9,223,372,036,854,775,807 可以适配到 63 位，但需要超过 18 位有效数字才能表示）。具体来说，范围在
    403A_DE0B_6B3A_763F_FF01h 到 403A_DE0B_6B3A_763F_FFFFh 之间的值大于 999,999,999,999,999,999，但仍然适配到
    64 位尾数。`fbstp` 指令无法将这些值转换为压缩 BCD 值。
- en: To resolve this issue, the code should explicitly test for values in this range
    and round them up to 1e+17 (and increment the decimal exponent value, should this
    happen). In some cases, values could be greater than 1e+19\. In such instances,
    one last division by 10.0 will solve the problem.
  id: totrans-115
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 为了解决这个问题，代码应该显式地测试该范围内的值，并将其向上舍入为 1e+17（如果发生这种情况，还要增加十进制指数值）。在某些情况下，值可能大于 1e+19。此时，最后一次除以
    10.0 将解决这个问题。
- en: At this point, the floating-point value is a reasonable number that the `fbstp`
    instruction can convert to a packed BCD value, so the conversion function uses
    `fbstp` to do this conversion.
  id: totrans-116
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 此时，浮点值已经是 `fbstp` 指令可以转换为压缩 BCD 值的合理数值，因此转换函数使用 `fbstp` 来进行此转换。
- en: Finally, convert the packed BCD value to a string of ASCII characters using
    an operation converting numeric values to hexadecimal (BCD) to strings (see “Converting
    Unsigned Decimal Values to Strings” on page 500 and [Listing 9-5](#listing9-5)).
  id: totrans-117
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，使用将数值转换为十六进制（BCD）字符串的操作，将压缩 BCD 值转换为 ASCII 字符串（参见第 500 页的“将无符号十进制值转换为字符串”和[清单
    9-5](#listing9-5)）。
- en: '[Listing 9-10](#listing9-10) provides the (abbreviated) code and data to implement
    the mantissa-to-string conversion function, `FPDigits`. `FPDigits` converts the
    mantissa to a sequence of 18 digits and returns the decimal exponent value in
    the EAX register. It doesn’t place a decimal point anywhere in the string, nor
    does it process the exponent at all.'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: '[清单 9-10](#listing9-10) 提供了（简化的）代码和数据，用于实现尾数到字符串的转换函数`FPDigits`。`FPDigits`
    将尾数转换为 18 位数字序列，并返回 EAX 寄存器中的十进制指数值。它不会在字符串中放置小数点，也不会处理指数部分。'
- en: '[PRE17]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Listing 9-10: Floating-point mantissa-to-string conversion'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 清单 9-10：浮点尾数到字符串的转换
- en: 9.1.8.2 Converting a Floating-Point Value to a Decimal String
  id: totrans-121
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 9.1.8.2 将浮点值转换为十进制字符串
- en: 'The `FPDigits` function does most of the work needed to convert a floating-point
    value to a string in decimal notation: it converts the mantissa to a string of
    digits and provides the exponent in a decimal integer form. Although the decimal
    format does not explicitly display the exponent value, a procedure that converts
    the floating-point value to a decimal string will need the (decimal) exponent
    value to determine where to put the decimal point. Along with a few additional
    arguments that the caller supplies, it’s relatively easy to take the output from
    `FPDigits` and convert it to an appropriately formatted decimal string of digits.'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: '`FPDigits` 函数执行将浮点值转换为十进制字符串所需的大部分工作：它将尾数转换为一串数字，并以十进制整数形式提供指数。尽管十进制格式没有明确显示指数值，但将浮点值转换为十进制字符串的过程需要指数（十进制）值，以确定小数点的位置。结合调用者提供的几个附加参数，从
    `FPDigits` 获取输出并将其转换为适当格式化的十进制数字字符串相对容易。'
- en: 'The final function to write is `r10ToStr`, the main function to call when converting
    a `real10` value to a string. This is a formatted output function that translates
    the binary floating-point value by using standard formatting options to control
    the output width, the number of positions after the decimal point, and any fill
    characters to write where digits don’t appear (usually, this is a space). The
    `r10ToStr` function call will need the following arguments:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 最终要写入的函数是 `r10ToStr`，这是将 `real10` 值转换为字符串时调用的主要函数。这是一个格式化输出函数，通过使用标准格式化选项来转换二进制浮点值，控制输出宽度、小数点后的位置数以及在没有出现数字的地方填充字符（通常是空格）。调用
    `r10ToStr` 函数时需要以下参数：
- en: '`r10`'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: '`r10`'
- en: The `real10` value to convert to a string (if `r10` is a `real4` or `real8`
    value, the FPU will automatically convert it to a `real10` value when loading
    it into the FPU).
  id: totrans-125
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要转换为字符串的 `real10` 值（如果 `r10` 是 `real4` 或 `real8` 值，FPU 会在将其加载到 FPU 时自动将其转换为
    `real10` 值）。
- en: '`fWidth`'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: '`fWidth`'
- en: The field width. This is the total number of character positions that the string
    will consume. This count includes room for a sign (which could be a space or a
    hyphen) but does not include space for a zero-terminating byte for the string.
    The field width must be greater than 0 and less than or equal to 1024.
  id: totrans-127
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 字段宽度。这是字符串将占用的总字符位置数。此计数包括符号的空间（可以是空格或连字符），但不包括字符串的零终止字节空间。字段宽度必须大于 0 且小于或等于
    1024。
- en: '`decDigits`'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: '`decDigits`'
- en: The number of digits to the right of the decimal point. This value must be at
    least 3 less than `fWidth` because there must be room for a sign character, at
    least one digit to the left of the decimal point, and the decimal point. If this
    value is 0, the conversion routine will not emit a decimal point to the string.
    This is an unsigned value; if the caller supplies a negative number here, the
    procedure will treat it as a very large positive value (and will return an error).
  id: totrans-129
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 小数点右侧的数字个数。此值必须至少比 `fWidth` 小 3，因为必须为符号字符、至少一个小数点左侧的数字以及小数点留出空间。如果此值为 0，则转换例程不会在字符串中发出小数点。这是一个无符号值；如果调用者在此处提供负数，程序将把它当作一个非常大的正数（并将返回错误）。
- en: '`fill`'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: '`fill`'
- en: The fill character. If the numeric string that `r10ToStr` produces uses fewer
    characters than `fWidth`, the procedure will right-justify the numeric value in
    the output string and fill the leftmost characters with this `fill` character
    (which is usually a space character).
  id: totrans-131
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 填充字符。如果 `r10ToStr` 生成的数字字符串使用的字符少于 `fWidth`，程序将把数字值右对齐，并用此 `fill` 字符（通常是空格字符）填充最左侧的字符。
- en: '`buffer`'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: '`buffer`'
- en: A buffer to receive the numeric string.
  id: totrans-133
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 用于接收数字字符串的缓冲区。
- en: '`maxLength`'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: '`maxLength`'
- en: The size of the buffer (including the zero-terminating byte). If the conversion
    routine attempts to create a string larger than this value (meaning `fWidth` is
    greater than or equal to this value), then it returns an error.
  id: totrans-135
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 缓冲区的大小（包括零终止字节）。如果转换例程尝试创建比此值更大的字符串（即 `fWidth` 大于或等于此值），则会返回错误。
- en: 'The string output operation has only three real tasks: properly position the
    decimal point (if present), copy only those digits specified by the `fWidth` value,
    and round the truncated digits into the output digits.'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 字符串输出操作只有三个实际任务：正确放置小数点（如果存在），仅复制由 `fWidth` 值指定的数字，并将截断的数字四舍五入为输出数字。
- en: The rounding operation is the most interesting part of the procedure. The `r10ToStr`
    function converts the `real10` value to ASCII characters before rounding because
    it’s easier to round the result after the conversion. So the rounding operation
    consists of adding 5 to the (ASCII) digit just beyond the least significant displayed
    digit. If this sum exceeds (the character) 9, the rounding algorithm has to add
    1 to the least significant displayed digit. If that sum exceeds 9, the algorithm
    must subtract (the value) 10 from the character and add 1 to the next least significant
    digit. This process repeats until reaching the most significant digit or until
    there is no carry out of a given digit (that is, the sum does not exceed 9). In
    the (rare) case that rounding bubbles through all the digits (for example, the
    string is “999999 . . . 9”), then the rounding algorithm has to replace the string
    with “10000 . . . 0” and increment the decimal exponent by 1.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 舍入操作是该过程最有趣的部分。`r10ToStr` 函数在舍入之前将 `real10` 值转换为 ASCII 字符，因为转换后的结果更容易进行舍入。所以，舍入操作的过程包括将
    5 加到最不重要显示数字之后的（ASCII）数字上。如果这个和超过了（字符）9，舍入算法必须将 1 加到最不重要显示数字上。如果这个和超过了 9，算法必须从字符中减去（值）10，并将
    1 加到下一个不那么重要的数字上。这个过程会重复进行，直到达到最重要的数字，或者直到没有进位（即和不超过 9）。在（罕见的）舍入通过所有数字的情况下（例如字符串为“999999
    . . . 9”），舍入算法必须将字符串替换为“10000 . . . 0”，并将十进制指数加 1。
- en: 'The algorithm for emitting the string differs for values with negative and
    non-negative exponents. Negative exponents are probably the easiest to process.
    Here’s the algorithm for emitting values with a negative exponent:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 输出字符串的算法对于负指数和非负指数的值有所不同。负指数的处理可能是最简单的。以下是输出负指数值的算法：
- en: The function begins by adding 3 to `decDigits`.
  id: totrans-139
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 函数首先将 3 加到 `decDigits`。
- en: If `decDigits` is less than 4, the function sets it to 4 as a default value.^([3](#c09-footnote-3))
  id: totrans-140
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果 `decDigits` 小于 4，则将其设置为 4 作为默认值。^([3](#c09-footnote-3))
- en: If `decDigits` is greater than `fWidth`, the function emits `fWidth "#"` characters
    to the string and returns.
  id: totrans-141
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果 `decDigits` 大于 `fWidth`，函数向字符串中输出 `fWidth` 个 `"#"` 字符，然后返回。
- en: If `decDigits` is less than `fWidth`, then output `(fWidth - decDigits)` padding
    characters (`fill`) to the output string.
  id: totrans-142
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果 `decDigits` 小于 `fWidth`，则输出 `(fWidth - decDigits)` 个填充字符 (`fill`) 到输出字符串中。
- en: If `r10` was negative, emit `-0.` to the string; otherwise, emit `0.` to the
    string (with a leading space in front of the 0 if non-negative).
  id: totrans-143
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果 `r10` 为负数，向字符串中输出 `-0.`；否则，输出 `0.`（如果是非负数，则在 0 前面加上空格）。
- en: Next, output the digits from the converted number. If the field width is less
    than 21 (18 digits plus the 3 leading `0.` or `-0.` characters), then the function
    outputs the specified (`fWidth`) characters from the converted digit string. If
    the width is greater than 21, the function emits all 18 digits from the converted
    digits and follows it by however many 0 characters are necessary to fill out the
    field width.
  id: totrans-144
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，输出转换后的数字的数字。如果字段宽度小于 21（18 位数字加上 3 位前导 `0.` 或 `-0.` 字符），则函数从转换后的数字字符串中输出指定的
    (`fWidth`) 字符。如果宽度大于 21，则函数输出转换后的所有 18 位数字，并在其后跟随需要填充字段宽度的零字符。
- en: Finally, the function zero-terminates the string and returns.
  id: totrans-145
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，函数将字符串以零终止并返回。
- en: 'If the exponent is positive or 0, the conversion is slightly more complicated.
    First, the code has to determine the number of character positions required by
    the result. This is computed as follows:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 如果指数为正数或 0，则转换稍微复杂一些。首先，代码需要确定结果所需的字符位置数量。其计算方式如下：
- en: '[PRE18]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: The `exponent` value is the number of digits to the left of the decimal point
    (minus 1). The `2` component is present because there is always a position for
    the sign character (space or hyphen) and there is always at least one digit to
    the left of the decimal point. The `decDigits` component adds in the number of
    digits to appear after the decimal point. Finally, this equation adds in 1 for
    the dot character if a decimal point is present (that is, if `decDigits` is greater
    than 0).
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: '`exponent` 值是小数点左侧的数字数量（减去 1）。`2` 组件存在是因为始终有一个位置用于符号字符（空格或连字符），并且小数点左侧始终至少有一个数字。`decDigits`
    组件添加了小数点后面显示的数字数量。最后，如果小数点存在（即如果 `decDigits` 大于 0），此方程式会为点字符加上 1。'
- en: Once the required width is computed, the function compares this value against
    the `fWidth` value the caller supplies. If the computed value is greater than
    `fWidth`, the function emits `fWidth` “`#`” characters and returns. Otherwise,
    it can emit the digits to the output string.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦计算出所需的宽度，函数会将该值与调用者提供的 `fWidth` 值进行比较。如果计算出的值大于 `fWidth`，函数将输出 `fWidth` 个
    "`#`" 字符并返回。否则，它可以将数字输出到字符串中。
- en: As happens with negative exponents, the code begins by determining whether the
    number will consume all the character positions in the output string. If not,
    it computes the difference between `fWidth` and the actual number of characters
    and outputs the `fill` character to pad the numeric string. Next, it outputs a
    space or a hyphen character (depending on the sign of the original value). Then
    the function outputs the digits to the left of the decimal point (by counting
    down the `exponent` value). If the `decDigits` value is nonzero, the function
    emits the dot character and any digits remaining in the digit string that `FPDigits`
    produced. If the function ever exceeds the 18 digits that `FPDigits` produces
    (either before or after the decimal point), then the function fills the remaining
    positions with the 0 character. Finally, the function emits the zero-terminating
    byte for the string and returns to the caller.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 正如负指数情况那样，代码首先确定数字是否会占用输出字符串中的所有字符位置。如果不会，它会计算 `fWidth` 与实际字符数之间的差异，并输出 `fill`
    字符来填充数字字符串。接着，输出一个空格或连字符字符（取决于原始值的符号）。然后，函数输出小数点左侧的数字（通过递减 `exponent` 值）。如果 `decDigits`
    值不为零，函数会输出点字符并输出 `FPDigits` 生成的数字字符串中的任何剩余数字。如果函数超过了 `FPDigits` 生成的 18 个数字（无论是在小数点之前还是之后），函数会用
    0 字符填充剩余的位置。最后，函数输出字符串的零终止字节并返回给调用者。
- en: '[Listing 9-11](#listing9-11) provides the source code for the `r10ToStr` function.'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: '[清单 9-11](#listing9-11) 提供了 `r10ToStr` 函数的源代码。'
- en: '[PRE19]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Listing 9-11: `r10ToStr` conversion function'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 清单 9-11：`r10ToStr` 转换函数
- en: 9.1.8.3 Converting a Floating-Point Value to Exponential Form
  id: totrans-154
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 9.1.8.3 将浮点值转换为指数形式
- en: Converting a floating-point value to exponential (scientific) form is a bit
    easier than converting it to decimal form. The mantissa always takes the form
    `sx.y` where `s` is a hyphen or a space, `x` is exactly one decimal digit, and
    `y` is one or more decimal digits. The `FPDigits` function does almost all the
    work to create this string. The exponential conversion function needs to output
    the mantissa string with sign and decimal point characters and then output the
    decimal exponent for the number. Converting the exponent value (returned as a
    decimal integer in the EAX register by `FPDigits`) to a string is just the numeric-to-decimal
    string conversion given earlier in this chapter, using different output formatting.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 将浮点值转换为指数（科学）形式比转换为十进制形式要容易一些。尾数总是呈现为 `sx.y` 形式，其中 `s` 是一个连字符或空格，`x` 是恰好一个小数位，`y`
    是一个或多个小数位。`FPDigits` 函数几乎完成了创建该字符串的所有工作。指数转换函数需要输出带符号和小数点字符的尾数字符串，然后输出该数字的十进指数。将指数值（由
    `FPDigits` 在 EAX 寄存器中以十进制整数形式返回）转换为字符串，实际上只是本章早些时候提到的数字到十进制字符串转换，使用不同的输出格式。
- en: The function this chapter presents allows you to specify the number of digits
    for the exponent as 1, 2, 3, or 4\. If the exponent requires more digits than
    the caller specifies, the function returns a failure. If it requires fewer digits
    than the caller specifies, the function pads the exponent with leading 0s. To
    emulate the typical floating-point conversion forms, specify an exponent size
    of 2 for single-precision values, 3 for double-precision values, and 4 for extended-precision
    values.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 本章介绍的函数允许你指定指数的数字位数为 1、2、3 或 4。如果指数需要的位数超过调用者指定的数字，函数将返回失败。如果需要的位数少于调用者指定的数字，函数会在指数前填充
    0。为了模拟典型的浮点转换形式，对于单精度值，指定 2 位的指数；对于双精度值，指定 3 位的指数；对于扩展精度值，指定 4 位的指数。
- en: '[Listing 9-12](#listing9-12) provides a quick-and-dirty function that converts
    the decimal exponent value to the appropriate string form and emits those characters
    to a buffer. This function leaves RDI pointing beyond the last exponent digit
    and doesn’t zero-terminate the string. It’s really just a helper function to output
    characters for the `e10ToStr` function that will appear in the next listing.'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: '[列表 9-12](#listing9-12) 提供了一个快速且粗略的函数，将十进制指数值转换为适当的字符串形式，并将这些字符输出到缓冲区。此函数将
    RDI 指向超出最后一个指数数字的位置，并且没有对字符串进行零终止。它实际上只是一个辅助函数，用于输出 `e10ToStr` 函数的字符，该函数将在下一个列表中出现。'
- en: '[PRE20]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Listing 9-12: Exponent conversion function'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: '列表 9-12: 指数转换函数'
- en: The actual `e10ToStr` function in [Listing 9-13](#listing9-13) is similar to
    the `r10ToStr` function. The output of the mantissa is less complex because the
    form is fixed, but there is a little additional work at the end to output the
    exponent. Refer back to “Converting a Floating-Point Value to a Decimal String”
    on page 527 for details on the operation of this code.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 实际的 `e10ToStr` 函数在[列表 9-13](#listing9-13)中，类似于 `r10ToStr` 函数。由于形式固定，尾数的输出不那么复杂，但在输出指数时需要做一些额外的工作。有关此代码的操作细节，请参考第527页的“将浮点值转换为十进制字符串”。
- en: '[PRE21]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Listing 9-13: `e10ToStr` conversion function'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: '列表 9-13: `e10ToStr` 转换函数'
- en: 9.2 String-to-Numeric Conversion Routines
  id: totrans-163
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 9.2 字符串与数字转换例程
- en: The routines converting numeric values to strings, and strings to numeric values,
    have a couple of fundamental differences. First of all, numeric-to-string conversions
    generally occur without possibility of error;^([4](#c09-footnote-4)) string-to-numeric
    conversion, on the other hand, must handle the real possibility of errors such
    as illegal characters and numeric overflow.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 数值到字符串的转换例程和字符串到数字的转换例程有一些基本的区别。首先，数字到字符串的转换通常不会发生错误；^([4](#c09-footnote-4))
    而字符串到数字的转换则必须处理实际可能出现的错误，如非法字符和数字溢出。
- en: A typical numeric input operation consists of reading a string of characters
    from the user and then translating this string of characters into an internal
    numeric representation. For example, in C++ a statement like `cin >> i32;` reads
    a line of text from the user and converts a sequence of digits appearing at the
    beginning of that line of text into a 32-bit signed integer (assuming `i32` is
    a 32-bit `int` object). The `cin >> i32;` statement skips over certain characters,
    like leading spaces, in the string that may appear before the actual numeric characters.
    The input string may also contain additional data beyond the end of the numeric
    input (for example, it is possible to read two integer values from the same input
    line), and therefore the input conversion routine must determine where the numeric
    data ends in the input stream.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 一个典型的数字输入操作包括从用户读取一串字符，然后将这串字符转换为内部数字表示。例如，在 C++ 中，像 `cin >> i32;` 这样的语句从用户那里读取一行文本，并将该行文本开头的一串数字字符转换为一个
    32 位带符号整数（假设 `i32` 是一个 32 位的 `int` 对象）。`cin >> i32;` 语句跳过某些字符，如开头的空格，这些字符可能出现在实际的数字字符之前。输入字符串也可能包含数字输入后的额外数据（例如，可能从同一行输入中读取两个整数值），因此输入转换例程必须确定数字数据在输入流中的结束位置。
- en: 'Typically, C++ achieves this by looking for a character from a set of *delimiter*
    characters. The delimiter character set could be something as simple as “any character
    that is not a numeric digit” or the set of whitespace characters (space, tab,
    and so on), and perhaps a few other characters such as a comma (`,`) or some other
    punctuation character. For the sake of example, the code in this section will
    assume that any leading spaces or tab characters (ASCII code 9) may precede any
    numeric digits, and the conversion stops on the first nondigit character it encounters.
    Possible error conditions are as follows:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，C++ 通过查找一组*分隔符*字符来实现这一点。分隔符字符集可能是简单的“任何非数字字符”，或者是空白字符集（空格、制表符等），也可能是其他一些字符，如逗号（`,`）或其他标点符号字符。为了举例说明，本节中的代码假设任何开头的空格或制表符字符（ASCII
    码 9）可能出现在数字字符之前，转换在遇到第一个非数字字符时停止。可能的错误情况如下：
- en: No numeric digits at all at the beginning of the string (following any spaces
    or tabs).
  id: totrans-167
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 字符串开头完全没有数字（跳过任何空格或制表符）。
- en: The string of digits is a value that would be too large for the intended numeric
    size (for example, 64 bits).
  id: totrans-168
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数字串是一个值，其大小超出了目标数字类型的范围（例如，64位）。
- en: It will be up to the caller to determine if the numeric string ends with an
    invalid character (upon return from the function call).
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 由调用者来确定数字字符串是否以无效字符结尾（从函数调用返回时）。
- en: 9.2.1 Converting Decimal Strings to Integers
  id: totrans-170
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 9.2.1 将十进制字符串转换为整数
- en: 'The basic algorithm to convert a string containing decimal digits to a number
    is the following:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 将包含十进制数字的字符串转换为数字的基本算法如下：
- en: Initialize an accumulator variable to 0.
  id: totrans-172
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 初始化累加器变量为0。
- en: Skip any leading spaces or tabs in the string.
  id: totrans-173
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 跳过字符串中的任何前导空格或制表符。
- en: Fetch the first character after the spaces or tabs.
  id: totrans-174
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 获取空格或制表符之后的第一个字符。
- en: If the character is not a numeric digit, return an error. If the character is
    a numeric digit, fall through to step 5.
  id: totrans-175
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果字符不是数字字符，则返回错误。如果字符是数字字符，则继续到第5步。
- en: Convert the numeric character to a numeric value (using AND 0Fh).
  id: totrans-176
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将数字字符转换为数值（使用 AND 0Fh）。
- en: Set the accumulator = (accumulator × 10) + current numeric value.
  id: totrans-177
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 设置累加器 =（累加器 × 10）+ 当前的数字值。
- en: If overflow occurs, return and report an error. If no overflow occurs, fall
    through to step 8.
  id: totrans-178
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果发生溢出，返回并报告错误。如果没有溢出，继续执行第8步。
- en: Fetch the next character from the string.
  id: totrans-179
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从字符串中获取下一个字符。
- en: If the character is a numeric digit, go back to step 5, else fall through to
    step 10.
  id: totrans-180
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果字符是数字字符，返回到第5步，否则继续到第10步。
- en: Return success, with accumulator containing the converted value.
  id: totrans-181
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 返回成功，累加器包含转换后的值。
- en: 'For signed integer input, you use this same algorithm with the following modifications:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 对于有符号整数输入，您使用相同的算法，进行以下修改：
- en: If the first non-space or tab character is a hyphen (`-`), set a flag denoting
    that the number is negative and skip the “`-`” character (if the first character
    is not `-`, then clear the flag).
  id: totrans-183
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果第一个非空格或制表符字符是一个连字符（`-`），则设置一个标志，表示该数字为负数，并跳过“`-`”字符（如果第一个字符不是`-`，则清除标志）。
- en: At the end of a successful conversion, if the flag is set, then negate the integer
    result before return (must check for overflow on the negate operation).
  id: totrans-184
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在成功转换结束时，如果设置了标志，则在返回之前对整数结果取负（必须检查取负操作是否溢出）。
- en: '[Listing 9-14](#listing9-14) implements the conversion algorithm.'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: '[清单 9-14](#listing9-14) 实现了转换算法。'
- en: '[PRE22]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Listing 9-14: Numeric-to-string conversions'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 清单 9-14：数字到字符串的转换
- en: 'Here’s the build command and sample output for this program:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是该程序的构建命令和示例输出：
- en: '[PRE23]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: For an extended-precision string-to-numeric conversion, you simply modify the
    `strtou` function to have an extend-precision accumulator and then do an extended-precision
    multiplication by 10 (rather than a standard multiplication).
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 对于扩展精度的字符串到数字转换，您只需修改`strtou`函数，使其具有扩展精度累加器，然后进行扩展精度的乘法（而不是标准乘法）。
- en: 9.2.2 Converting Hexadecimal Strings to Numeric Form
  id: totrans-191
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 9.2.2 将十六进制字符串转换为数字形式
- en: 'As was the case for numeric output, hexadecimal input is the easiest numeric
    input routine to write. The basic algorithm for hexadecimal-string-to-numeric
    conversion is the following:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 与数字输出类似，十六进制输入是最容易编写的数字输入程序。十六进制字符串到数字转换的基本算法如下：
- en: Initialize an extended-precision accumulator value to 0.
  id: totrans-193
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将扩展精度累加器值初始化为0。
- en: For each input character that is a valid hexadecimal digit, repeat steps 3 through
    6; drop down to step 7 when it is not a valid hexadecimal digit.
  id: totrans-194
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于每个有效的十六进制数字字符，重复步骤3到6；如果不是有效的十六进制数字字符，则跳到步骤7。
- en: Convert the hexadecimal character to a value in the range 0 to 15 (0h to 0Fh).
  id: totrans-195
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将十六进制字符转换为0到15（0h到0Fh）范围内的值。
- en: If the HO 4 bits of the extended-precision accumulator value are nonzero, raise
    an exception.
  id: totrans-196
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果扩展精度累加器值的高4位非零，则引发异常。
- en: Multiply the current extended-precision value by 16 (that is, shift left 4 bits).
  id: totrans-197
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将当前的扩展精度值乘以16（即向左移动4位）。
- en: Add the converted hexadecimal digit value to the accumulator.
  id: totrans-198
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将转换后的十六进制数字值添加到累加器中。
- en: Check the current input character to ensure it is a valid delimiter. Raise an
    exception if it is not.
  id: totrans-199
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 检查当前输入字符以确保它是一个有效的分隔符。如果不是，则引发异常。
- en: '[Listing 9-15](#listing9-15) implements this extended-precision hexadecimal
    input routine for 64-bit values.'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: '[清单 9-15](#listing9-15) 实现了这个64位值的扩展精度十六进制输入程序。'
- en: '[PRE24]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Listing 9-15: Hexadecimal string-to-numeric conversion'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 清单 9-15：十六进制字符串到数字的转换
- en: 'Here’s the build command and program output:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是构建命令和程序输出：
- en: '[PRE25]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: For hexadecimal string conversions that handle numbers greater than 64 bits,
    you have to use an extended-precision shift left by 4 bits. [Listing 9-16](#listing9-16)
    demonstrates the necessary modifications to the `strtoh` function for a 128-bit
    conversion.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 对于处理大于 64 位数字的十六进制字符串转换，你需要使用扩展精度左移 4 位。[列表 9-16](#listing9-16) 演示了对 `strtoh`
    函数进行必要修改以支持 128 位转换。
- en: '[PRE26]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Listing 9-16: 128-bit hexadecimal string-to-numeric conversion'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 9-16：128 位十六进制字符串到数值的转换
- en: 9.2.3 Converting Unsigned Decimal Strings to Integers
  id: totrans-208
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 9.2.3 无符号十进制字符串转换为整数
- en: The algorithm for unsigned decimal input is nearly identical to that for hexadecimal
    input. In fact, the only difference (beyond accepting only decimal digits) is
    that you multiply the accumulating value by 10 rather than 16 for each input character
    (in general, the algorithm is the same for any base; just multiply the accumulating
    value by the input base). [Listing 9-17](#listing9-17) demonstrates how to write
    a 64-bit unsigned decimal input routine.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 无符号十进制输入的算法与十六进制输入几乎完全相同。事实上，唯一的区别（除了仅接受十进制数字外）是，对于每个输入字符，你将累积值乘以 10 而不是 16（一般来说，任何进制的算法都是一样的；只需将累积值乘以输入的进制）。[列表
    9-17](#listing9-17) 演示了如何编写一个 64 位无符号十进制输入例程。
- en: '[PRE27]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Listing 9-17: Unsigned decimal string-to-numeric conversion'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 9-17：无符号十进制字符串到数值的转换
- en: 'Here’s the build command and sample output for the program in [Listing 9-17](#listing9-17):'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 这是[列表 9-17](#listing9-17) 中程序的构建命令和示例输出：
- en: '[PRE28]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Is it possible to create a faster function that uses the `fbld` (x87 FPU BCD
    store) instruction? Probably not. The `fbstp` instruction was much faster for
    integer conversions because the standard algorithm used multiple executions of
    the (very slow) `div` instruction. Decimal-to-numeric conversion uses the `mul`
    instruction, which is much faster than `div`. Though I haven’t actually tried
    it, I suspect using `fbld` won’t produce faster running code.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 是否可以创建一个更快的函数，使用 `fbld`（x87 FPU BCD 存储）指令？可能不行。`fbstp` 指令在整数转换中要快得多，因为标准算法使用了多次执行（非常慢的）`div`
    指令。十进制到数值的转换使用的是 `mul` 指令，这比 `div` 快得多。虽然我没有实际尝试过，但我怀疑使用 `fbld` 不会产生更快的运行代码。
- en: 9.2.4 Conversion of Extended-Precision String to Unsigned Integer
  id: totrans-215
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 9.2.4 扩展精度字符串转换为无符号整数
- en: The algorithm for (decimal) string-to-numeric conversion is the same regardless
    of integer size. You read a decimal character, convert it to an integer, multiply
    the accumulating result by 10, and add in the converted character. The only things
    that change for larger-than-64-bit values are the multiplication by 10 and addition
    operations. For example, to convert a string to a 128-bit integer, you would need
    to be able to multiply a 128-bit value by 10 and add an 8-bit value (zero-extended
    to 128 bits) to a 128-bit value.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: （十进制）字符串到数值的转换算法是相同的，无论整数的大小如何。你读取一个十进制字符，将其转换为整数，将累积结果乘以 10，然后将转换后的字符加进去。对于大于
    64 位的值，唯一变化的是乘以 10 和加法操作。例如，要将一个字符串转换为 128 位整数，你需要能够将 128 位的值乘以 10，并将一个 8 位值（零扩展到
    128 位）加到 128 位值上。
- en: '[Listing 9-18](#listing9-18) demonstrates how to write a 128-bit unsigned decimal
    input routine. Other than the 128-bit multiplication by 10 and 128-bit addition
    operations, this code is functionally identical to the 64-bit string to integer
    conversion.'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: '[列表 9-18](#listing9-18) 演示了如何编写一个 128 位无符号十进制输入例程。除了 128 位乘以 10 和 128 位加法操作外，这段代码在功能上与
    64 位字符串到整数的转换完全相同。'
- en: '[PRE29]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Listing 9-18: Extended-precision unsigned decimal input'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 9-18：扩展精度无符号十进制输入
- en: 9.2.5 Conversion of Extended-Precision Signed Decimal String to Integer
  id: totrans-220
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 9.2.5 扩展精度有符号十进制字符串转换为整数
- en: 'Once you have an unsigned decimal input routine, writing a signed decimal input
    routine is easy, as described by the following algorithm:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你有了一个无符号十进制输入例程，编写一个有符号十进制输入例程就很简单，具体算法如下：
- en: Consume any delimiter characters at the beginning of the input stream.
  id: totrans-222
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 消耗输入流开始部分的所有分隔符字符。
- en: If the next input character is a minus sign, consume this character and set
    a flag noting that the number is negative; else just drop down to step 3.
  id: totrans-223
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果下一个输入字符是减号，消耗此字符并设置一个标志，表示该数字是负数；否则直接跳到步骤 3。
- en: Call the unsigned decimal input routine to convert the rest of the string to
    an integer.
  id: totrans-224
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 调用无符号十进制输入例程，将其余部分的字符串转换为整数。
- en: Check the return result to make sure its HO bit is clear. Raise a value out
    of range exception if the HO bit of the result is set.
  id: totrans-225
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 检查返回结果，确保其高位（HO）位是清除的。如果结果的高位是设置的，则引发超出范围的异常。
- en: If the code encountered a minus sign in step 2, negate the result.
  id: totrans-226
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果代码在第2步中遇到了减号，则取结果的相反值。
- en: I’ll leave the actual code implementation as a programming exercise for you.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 我会把实际的代码实现留给你作为编程练习。
- en: 9.2.6 Conversion of Real String to Floating-Point
  id: totrans-228
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 9.2.6 实现字符串到浮点数的转换
- en: 'Converting a string of characters representing a floating-point number to the
    80-bit `real10` format is slightly easier than the `real10`-to-string conversion
    appearing earlier in this chapter. Because decimal conversion (with no exponent)
    is a subset of the more general scientific notation conversion, if you can handle
    scientific notation, you get decimal conversion for free. Beyond that, the basic
    algorithm is to convert the mantissa characters to a packed BCD form (so the function
    can use the `fbld` instruction to do the string-to-numeric conversion) and then
    read the (optional) exponent and adjust the `real10` exponent accordingly. The
    algorithm to do the conversion is the following:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 将表示浮点数的字符字符串转换为80位的`real10`格式，比本章前面出现的`real10`到字符串的转换稍微简单一些。因为十进制转换（没有指数）是更一般的科学计数法转换的一个子集，所以如果你能处理科学计数法，你就能免费处理十进制转换。除此之外，基本的算法是将尾数字符转换为压缩的BCD格式（这样该函数就可以使用`fbld`指令来进行字符串到数字的转换），然后读取（可选的）指数并相应地调整`real10`的指数。进行转换的算法如下：
- en: Begin by stripping away any leading space or tab characters (and any other delimiters).
  id: totrans-230
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从去除任何前导的空格或制表符字符（以及其他分隔符）开始。
- en: Check for a leading plus (`+`) or minus (`-`) sign character. Skip it if one
    is present. Set a sign flag to true if the number is negative (false if non-negative).
  id: totrans-231
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 检查是否有前导的加号（`+`）或减号（`-`）字符。如果有，跳过它。如果数字是负数，则将符号标志设置为真（如果是非负数，则设置为假）。
- en: Initialize an exponent value to –18\. The algorithm will create a left-justified
    packed BCD value from the mantissa digits in the string to provide to the `fbld`
    instruction, and left-justified packed BCD values are always greater than or equal
    to 10^(18). Initializing the exponent to –18 accounts for this.
  id: totrans-232
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 初始化指数值为-18。该算法将根据字符串中的尾数数字创建一个左对齐的压缩BCD值，提供给`fbld`指令，而左对齐的压缩BCD值总是大于或等于10^(18)。初始化指数为-18是为了考虑到这一点。
- en: Initialize a significant-digit-counter variable that counts the number of significant
    digits processed thus far to 18.
  id: totrans-233
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 初始化一个有效数字计数器变量，记录到目前为止已处理的有效数字的数量，初始值为18。
- en: If the number begins with any leading zeros, skip over them (do not change the
    exponent or significant digit counters for leading zeros to the left of the decimal
    point).
  id: totrans-234
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果数字以任何前导零开头，则跳过这些零（不改变小数点左侧的前导零的指数或有效数字计数器）。
- en: If the scan encounters a decimal point after processing any leading zeros, go
    to step 11; else fall through to step 7.
  id: totrans-235
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果扫描在处理完任何前导零后遇到小数点，则跳到第11步；否则跳到第7步。
- en: For each nonzero digit to the left of the decimal point, if the significant
    digit counter is not zero, insert the nonzero digit into a “digit string” array
    at the position specified by the significant digit counter (minus 1).^([5](#c09-footnote-5))
    Note that this will insert the characters into the string in a reversed position.
  id: totrans-236
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于小数点左侧的每个非零数字，如果有效数字计数器不为零，将该非零数字插入到“数字字符串”数组中，位置由有效数字计数器（减去1）指定。^([5](#c09-footnote-5))
    请注意，这将以反向位置将字符插入到字符串中。
- en: For each digit to the left of the decimal point, increment the exponent value
    (originally initialized to –18) by 1\.
  id: totrans-237
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于小数点左侧的每个数字，将指数值（最初初始化为-18）增加1。
- en: If the significant digit counter is not zero, decrement the significant digit
    counter (this will also provide the index into the digit string array).
  id: totrans-238
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果有效数字计数器不为零，递减有效数字计数器（这也将提供对数字字符串数组的索引）。
- en: If the first nondigit encountered is not a decimal point, skip to step 14.
  id: totrans-239
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果遇到的第一个非数字字符不是小数点，跳到第14步。
- en: Skip over the decimal point character.
  id: totrans-240
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 跳过小数点字符。
- en: For each digit encountered to the right of the decimal point, continue adding
    the digits (in reverse order) to the digit string array as long as the significant
    digit counter is not zero. If the significant digit counter is greater than zero,
    decrement it. Also, decrement the exponent value.
  id: totrans-241
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于小数点右侧的每个数字，继续将这些数字（按相反顺序）添加到数字字符串数组中，只要有效数字计数器不为零。如果有效数字计数器大于零，则递减它。同时，递减指数值。
- en: '*If the algorithm hasn’t encountered at least one decimal digit by this point,
    report an illegal character exception and return*.'
  id: totrans-242
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '*如果算法在此时还未遇到至少一个十进制数字，则报告非法字符异常并返回*。'
- en: If the current character is not `e` or `E`, then go to step 20.^([6](#c09-footnote-6))
    Otherwise, skip over the `e` or `E` character and continue with step 15.
  id: totrans-243
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果当前字符不是`e`或`E`，则跳到步骤20。^([6](#c09-footnote-6))否则，跳过`e`或`E`字符，继续执行步骤15。
- en: If the next character is `+` or `-`, skip over it. Set a flag to true if the
    sign character is `-`, and set it to false otherwise (note that this exponent
    sign flag is different from the mantissa sign flag set earlier in this algorithm).
  id: totrans-244
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果下一个字符是`+`或`-`，则跳过它。如果符号字符是`-`，则将标志设置为true，否则设置为false（请注意，该指数符号标志与算法中较早设置的尾数符号标志不同）。
- en: If the next character is not a decimal digit, report an error.
  id: totrans-245
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果下一个字符不是十进制数字，则报告错误。
- en: Convert the string of digits (starting with the current decimal digit character)
    to an integer.
  id: totrans-246
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将数字字符串（从当前的十进制数字字符开始）转换为整数。
- en: Add the converted integer to the exponent value (which was initialized to –18
    at the start of this algorithm).
  id: totrans-247
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将转换后的整数加到指数值上（该值在算法开始时被初始化为–18）。
- en: If the exponent value is outside the range –4930 to +4930, report an out-of-range
    exception.
  id: totrans-248
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果指数值超出了–4930到+4930的范围，则报告超出范围异常。
- en: Convert the digit string array of characters to an 18-digit (9-byte) packed
    BCD value by stripping the HO 4 bits of each character, merging pairs of characters
    into a single byte (by shifting the odd-indexed byte to the left 4 bits and logically
    ORing with the even-indexed byte of each pair), and then setting the HO (10th)
    byte to 0.
  id: totrans-249
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将数字字符数组转换为18位（9字节）打包的BCD值，通过去除每个字符的高4位，将成对的字符合并为一个字节（通过将奇数索引字节左移4位，并与每对中的偶数索引字节进行逻辑或运算），然后将高字节（第10个字节）设为0。
- en: Convert the packed BCD value to a `real10` value (using the `fbld` instruction).
  id: totrans-250
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将打包的BCD值转换为`real10`值（使用`fbld`指令）。
- en: Take the absolute value of the exponent (though preserve the sign of the exponent).
    This value will be 13 bits or less (4096 has bit 12 set, so 4930 or less will
    have some combination of bits 0 to 13 set to 1, with all other bits 0).
  id: totrans-251
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 取指数的绝对值（但保留指数的符号）。该值将是13位或更小（4096有第12位被设置，因此4930或更小的值会有一些第0到第13位的组合被设置为1，其他位为0）。
- en: If the exponent was positive, then for each set bit in the exponent, multiply
    the current `real10` value by 10 raised to the power specified by that bit. For
    example, if bits 12, 10, and 1 are set, multiply the `real10` value by 10^(4096),
    10^(1024), and 10².
  id: totrans-252
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果指数为正，则对于指数中每一位被设置的位，将当前的`real10`值乘以10的该位指定的幂次方。例如，如果位12、10和1被设置，则将`real10`值分别乘以10^(4096)、10^(1024)和10²。
- en: If the exponent was negative, then for each set bit in the exponent, divide
    the current `real10` value by 10 raised to the power specified by that bit. For
    example, if bits 12, 10, and 1 are set, divide the `real10` value by 10^(4096),
    10^(1024), and 10².
  id: totrans-253
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果指数为负，则对于指数中每一位被设置的位，将当前的`real10`值除以10的该位指定的幂次方。例如，如果位12、10和1被设置，则将`real10`值分别除以10^(4096)、10^(1024)和10²。
- en: If the mantissa is negative (the first sign flag set at the beginning of the
    algorithm), then negate the floating-point number.
  id: totrans-254
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果尾数为负（算法开始时设置了第一个符号标志），则取反浮点数。
- en: '[Listing 9-19](#listing9-19) provides an implementation of this algorithm.'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: '[列表9-19](#listing9-19)提供了该算法的实现。'
- en: '[PRE30]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Listing 9-19: A `strToR10` function'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 列表9-19：`strToR10`函数
- en: Here’s the build command and sample output for [Listing 9-19](#listing9-19).
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是[列表9-19](#listing9-19)的构建命令和示例输出。
- en: '[PRE31]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 9.3 For More Information
  id: totrans-260
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 9.3 更多信息
- en: 'Donald Knuth’s *The Art of Computer Programming*, Volume 2: *Seminumerical
    Algorithms* (Addison-Wesley Professional, 1997) contains a lot of useful information
    about decimal arithmetic and extended-precision arithmetic, though that text is
    generic and doesn’t describe how to do this in x86 assembly language.'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 唐纳德·克努斯的*《计算机程序设计的艺术》*第二卷：*半数值算法*（Addison-Wesley Professional，1997年）包含了许多关于十进制算术和扩展精度算术的有用信息，尽管该文本是通用的，并没有描述如何在x86汇编语言中实现此操作。
- en: 9.4 Test Yourself
  id: totrans-262
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 9.4 自测
- en: What is the code that will convert an 8-bit hexadecimal value in AL into two
    hexadecimal digits (in AH and AL)?
  id: totrans-263
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将8位十六进制值从AL转换为两个十六进制数字（分别存入AH和AL）的代码是什么？
- en: How many hexadecimal digits will `dToStr` produce?
  id: totrans-264
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`dToStr`将生成多少个十六进制数字？'
- en: Explain how to use `qToStr` to write a 128-bit hexadecimal output routine.
  id: totrans-265
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 解释如何使用`qToStr`编写一个128位十六进制输出例程。
- en: What instruction should you use to produce the fastest 64-bit decimal-to-string
    conversion function?
  id: totrans-266
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你应该使用什么指令来产生最快的64位十进制到字符串转换函数？
- en: How do you write a signed decimal-to-string conversion if you’re given a function
    that does an unsigned decimal-to-string conversion?
  id: totrans-267
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果给定一个无符号十进制到字符串的转换函数，如何编写一个有符号十进制到字符串的转换？
- en: What are the parameters for the `utoStrSize` function?
  id: totrans-268
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`utoStrSize` 函数的参数是什么？'
- en: What string will `uSizeToStr` produce if the number requires more print positions
    than specified by the `minDigits` parameter?
  id: totrans-269
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果数字需要的打印位置超过 `minDigits` 参数指定的数量，`uSizeToStr` 会输出什么字符串？
- en: What are the parameters for the `r10ToStr` function?
  id: totrans-270
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`r10ToStr` 函数的参数是什么？'
- en: What string will `r10ToStr` produce if the output won’t fit in the string size
    specified by the `fWidth` argument?
  id: totrans-271
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果输出不能适应 `fWidth` 参数指定的字符串大小，`r10ToStr` 会输出什么字符串？
- en: What are the arguments to the `e10ToStr` function?
  id: totrans-272
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`e10ToStr` 函数的参数是什么？'
- en: What is a delimiter character?
  id: totrans-273
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 什么是分隔符字符？
- en: What are two possible errors that could occur during a string-to-numeric conversion?
  id: totrans-274
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在字符串到数字的转换过程中，可能出现的两种错误是什么？
