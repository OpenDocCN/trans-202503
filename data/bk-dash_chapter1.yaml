- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">1</samp> <samp class="SANS_Dogma_OT_Bold_B_11">PYTHON
    REFRESHER</samp>
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">1</samp> <samp class="SANS_Dogma_OT_Bold_B_11">PYTHON
    回顾</samp>
- en: '![](../images/opener-img.png)'
  id: totrans-1
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/opener-img.png)'
- en: If you’re looking to work on Dash apps, you probably already know at least a
    little bit of Python. This book doesn’t assume you’re an expert, however, so here
    we’ll review some important Python concepts that are more relevant to working
    with Dash, including lists, dictionaries, object-oriented programming, and decorator
    functions. If you’re already really confident in your abilities in these areas,
    feel free to skip to [Chapter 2](chapter2.xhtml), which covers PyCharm, the Python
    IDE that we’ll use throughout this book.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你打算开发 Dash 应用程序，可能至少已经了解一点 Python。尽管本书不会假设你是专家，但我们会复习一些在使用 Dash 时更相关的 Python
    概念，包括列表、字典、面向对象编程和装饰器函数。如果你已经非常熟悉这些领域，可以直接跳到 [第二章](chapter2.xhtml)，本章将介绍我们将在本书中使用的
    Python IDE——PyCharm。
- en: <samp class="SANS_Futura_Std_Bold_B_11">Lists</samp>
  id: totrans-3
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">列表</samp>
- en: 'Let’s quickly revise the most important container data type used in practically
    all Dash apps: Python lists! Lists are important in Dash because they are used
    to define the layout, they are used to incorporate Dash Bootstrap themes, and
    they are commonly seen inside the callback and in figures built by Plotly.'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们快速复习一下在几乎所有 Dash 应用程序中都使用的最重要的容器数据类型：Python 列表！在 Dash 中，列表非常重要，因为它们用于定义布局，包含
    Dash Bootstrap 主题，并且通常出现在回调和由 Plotly 构建的图形中。
- en: 'The list container type stores a sequence of elements. Lists are mutable, meaning
    you can modify them after they’ve been created. Here we create a list named <samp
    class="SANS_TheSansMonoCd_W5Regular_11">lst</samp> and print its length:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 列表容器类型存储一系列元素。列表是可变的，意味着你可以在创建后修改它们。在这里，我们创建了一个名为 <samp class="SANS_TheSansMonoCd_W5Regular_11">lst</samp>
    的列表，并打印其长度：
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">lst = [1, 2, 2]</samp>
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W5Regular_11">lst = [1, 2, 2]</samp>
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">print(len(lst))</samp>
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W5Regular_11">print(len(lst))</samp>
- en: 'Our output is simply:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的输出仅为：
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">3</samp>
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W5Regular_11">3</samp>
- en: We create a list using square brackets and comma-separated elements. Lists can
    hold arbitrary Python objects, duplicate values, and even other lists, so they
    are among the most flexible container types in Python. Here we populated our list
    <samp class="SANS_TheSansMonoCd_W5Regular_11">lst</samp> with three integer elements.
    The <samp class="SANS_TheSansMonoCd_W5Regular_11">len()</samp> function returns
    the number of elements in a list.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用方括号和逗号分隔的元素来创建列表。列表可以包含任意的 Python 对象、重复值，甚至其他列表，因此它们是 Python 中最灵活的容器类型之一。在这里，我们用三个整数元素填充了我们的列表
    <samp class="SANS_TheSansMonoCd_W5Regular_11">lst</samp>。<samp class="SANS_TheSansMonoCd_W5Regular_11">len()</samp>
    函数返回列表中的元素数量。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_I_11">Adding Elements</samp>
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_I_11">添加元素</samp>
- en: 'There are three common ways to add elements to a list that already exists:
    appending, inserting, and concatenation.'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 向已存在的列表添加元素有三种常见方法：追加、插入和连接。
- en: 'The <samp class="SANS_TheSansMonoCd_W5Regular_11">append()</samp> method places
    its argument at the end of the list. Here’s an example of appending:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W5Regular_11">append()</samp> 方法将其参数放置在列表的末尾。以下是一个追加的示例：
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">lst = [1, 2, 2]</samp>
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W5Regular_11">lst = [1, 2, 2]</samp>
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">lst.append(4)</samp>
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W5Regular_11">lst.append(4)</samp>
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">print(lst)</samp>
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W5Regular_11">print(lst)</samp>
- en: 'This will print:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 这将打印：
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">[1, 2, 2, 4]</samp>
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W5Regular_11">[1, 2, 2, 4]</samp>
- en: 'The <samp class="SANS_TheSansMonoCd_W5Regular_11">insert()</samp> method inserts
    an element at a given position and moves all subsequent elements to the right.
    Here’s an example of inserting:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W5Regular_11">insert()</samp> 方法将在给定的位置插入一个元素，并将所有后续元素向右移动。以下是一个插入的示例：
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">lst = [1, 2, 4]</samp>
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W5Regular_11">lst = [1, 2, 4]</samp>
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">lst.insert(2,2)</samp>
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W5Regular_11">lst.insert(2,2)</samp>
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">print(lst)</samp>
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W5Regular_11">print(lst)</samp>
- en: 'This prints the same result:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 这将打印相同的结果：
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">[1, 2, 2, 4]</samp>
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W5Regular_11">[1, 2, 2, 4]</samp>
- en: 'And finally, concatenation:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，连接操作：
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">print([1, 2, 2] +</samp> <samp
    class="SANS_TheSansMonoCd_W5Regular_11">[4])</samp>
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W5Regular_11">print([1, 2, 2] +</samp> <samp
    class="SANS_TheSansMonoCd_W5Regular_11">[4])</samp>
- en: 'We get:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 我们得到：
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">[1, 2, 2, 4]</samp>
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W5Regular_11">[1, 2, 2, 4]</samp>
- en: For concatenation, we use the plus (<samp class="SANS_TheSansMonoCd_W5Regular_11">+</samp>)
    operator. This creates a new list by gluing together two existing lists.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 对于连接操作，我们使用加号 (<samp class="SANS_TheSansMonoCd_W5Regular_11">+</samp>) 运算符。它通过将两个现有列表拼接在一起创建一个新的列表。
- en: All operations generate the same list, <samp class="SANS_TheSansMonoCd_W5Regular_11">[1,
    2, 2, 4]</samp>. The append operation is the fastest because it neither has to
    traverse the list to insert an element at the correct position as inserting does,
    nor has to create a new list out of two sublists as concatenation does.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 所有操作都会生成相同的列表 <samp class="SANS_TheSansMonoCd_W5Regular_11">[1, 2, 2, 4]</samp>。其中，添加操作最快，因为它不需要像插入操作那样遍历列表并将元素插入正确位置，也不需要像连接操作那样创建一个由两个子列表组成的新列表。
- en: 'To append multiple elements to a given list, use the <samp class="SANS_TheSansMonoCd_W5Regular_11">extend()</samp>
    method:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 要向给定列表中添加多个元素，可以使用 <samp class="SANS_TheSansMonoCd_W5Regular_11">extend()</samp>
    方法：
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">lst = [1, 2]</samp>
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W5Regular_11">lst = [1, 2]</samp>
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">lst.extend([2, 4])</samp>
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W5Regular_11">lst.extend([2, 4])</samp>
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">print(lst)</samp>
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W5Regular_11">print(lst)</samp>
- en: 'The code changes the existing list object <samp class="SANS_TheSansMonoCd_W5Regular_11">lst</samp>
    as follows:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 该代码通过如下方式修改现有的列表对象 <samp class="SANS_TheSansMonoCd_W5Regular_11">lst</samp>：
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">[1, 2, 2, 4]</samp>
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W5Regular_11">[1, 2, 2, 4]</samp>
- en: The preceding code is an example of a list that’s able to hold duplicate values.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码是一个可以容纳重复值的列表示例。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_I_11">Removing Elements</samp>
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_I_11">删除元素</samp>
- en: 'We can remove an element <samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp>
    from a list with <samp class="SANS_TheSansMonoCd_W5Regular_11">lst.remove(x)</samp>,
    like so:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用 <samp class="SANS_TheSansMonoCd_W5Regular_11">lst.remove(x)</samp> 从列表中移除元素
    <samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp>，如：
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">lst = [1, 2, 2, 4]</samp>
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W5Regular_11">lst = [1, 2, 2, 4]</samp>
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">lst.remove(1)</samp>
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W5Regular_11">lst.remove(1)</samp>
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">print(lst)</samp>
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W5Regular_11">print(lst)</samp>
- en: 'This gives us the result:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 这将给我们如下结果：
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">[2, 2, 4]</samp>
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W5Regular_11">[2, 2, 4]</samp>
- en: This method operates on the list object itself—no new list is created, and the
    original list is altered.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 该方法作用于列表对象本身——不会创建新列表，而是修改原始列表。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_I_11">Reversing Lists</samp>
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_I_11">反转列表</samp>
- en: 'You can reverse the order of the list elements using the method <samp class="SANS_TheSansMonoCd_W5Regular_11">lst.reverse()</samp>:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用 <samp class="SANS_TheSansMonoCd_W5Regular_11">lst.reverse()</samp> 方法反转列表元素的顺序：
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">lst = [1, 2, 2, 4]</samp>
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W5Regular_11">lst = [1, 2, 2, 4]</samp>
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">lst.reverse()</samp>
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W5Regular_11">lst.reverse()</samp>
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">print(l)</samp>
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W5Regular_11">print(l)</samp>
- en: 'This prints:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 这将打印：
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">[4, 2, 2, 1]</samp>
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W5Regular_11">[4, 2, 2, 1]</samp>
- en: Reversing the list also modifies the original list object rather than creating
    a new list object.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 反转列表也会修改原始列表对象，而不是创建一个新的列表对象。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_I_11">Sorting Lists</samp>
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_I_11">排序列表</samp>
- en: 'You can sort the list elements using the method <samp class="SANS_TheSansMonoCd_W5Regular_11">lst.sort()</samp>:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用 <samp class="SANS_TheSansMonoCd_W5Regular_11">lst.sort()</samp> 方法对列表元素进行排序：
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">lst = [2, 1, 4, 2]</samp>
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W5Regular_11">lst = [2, 1, 4, 2]</samp>
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">lst.sort()</samp>
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W5Regular_11">lst.sort()</samp>
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">print(lst)</samp>
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W5Regular_11">print(lst)</samp>
- en: 'We see the sorted list:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 我们看到排序后的列表：
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">[1, 2, 2, 4]</samp>
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W5Regular_11">[1, 2, 2, 4]</samp>
- en: 'Again, sorting the list modifies the original list object. The resultant list
    is sorted in ascending order by default. To sort in descending order, you pass
    <samp class="SANS_TheSansMonoCd_W5Regular_11">reverse=True</samp>, as shown here:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，排序列表会修改原始列表对象。默认情况下，结果列表按升序排序。要按降序排序，可以传递 <samp class="SANS_TheSansMonoCd_W5Regular_11">reverse=True</samp>，如下所示：
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">lst = [2, 1, 4, 2]</samp>
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W5Regular_11">lst = [2, 1, 4, 2]</samp>
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">lst.sort(reverse=True)</samp>
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W5Regular_11">lst.sort(reverse=True)</samp>
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">print(lst)</samp>
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W5Regular_11">print(lst)</samp>
- en: 'And we see the result is in reverse order:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们看到结果是按逆序排列的：
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">[4, 2, 2, 1]</samp>
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W5Regular_11">[4, 2, 2, 1]</samp>
- en: 'You can also specify a <samp class="SANS_TheSansMonoCd_W5Regular_11">key</samp>
    function and pass it as the parameter key to <samp class="SANS_TheSansMonoCd_W5Regular_11">sort()</samp>
    to customize the sorting behavior. The <samp class="SANS_TheSansMonoCd_W5Regular_11">key</samp>
    function simply transforms one list element into an element that is sortable.
    For example, it might transform an unsortable object such as a Dash component
    into a sortable type by using the Dash component’s string identifier as a key.
    Generally, these <samp class="SANS_TheSansMonoCd_W5Regular_11">key</samp> functions
    allow you to sort lists of custom objects; for example, sorting a list of staff
    objects by their age. The following example sorts the list but uses the inverse,
    negative value of an element as a <samp class="SANS_TheSansMonoCd_W5Regular_11">key</samp>:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以指定一个 <samp class="SANS_TheSansMonoCd_W5Regular_11">key</samp> 函数，并将其作为参数传递给
    <samp class="SANS_TheSansMonoCd_W5Regular_11">sort()</samp>，以自定义排序行为。<samp class="SANS_TheSansMonoCd_W5Regular_11">key</samp>
    函数只是将一个列表元素转换为可以排序的元素。例如，它可以通过使用 Dash 组件的字符串标识符作为键，将一个不可排序的对象（如 Dash 组件）转换为可排序类型。通常，这些
    <samp class="SANS_TheSansMonoCd_W5Regular_11">key</samp> 函数允许你对自定义对象的列表进行排序；例如，按员工年龄对员工对象列表进行排序。以下示例对列表进行排序，但使用元素的逆（负）值作为
    <samp class="SANS_TheSansMonoCd_W5Regular_11">key</samp>：
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">lst = [2, 1, 4, 2]</samp>
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W5Regular_11">lst = [2, 1, 4, 2]</samp>
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">lst.sort(key=</samp><samp class="SANS_TheSansMonoCd_W5Regular_11">lambda
    x:</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">−</samp><samp class="SANS_TheSansMonoCd_W5Regular_11">x)</samp>
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W5Regular_11">lst.sort(key=</samp><samp class="SANS_TheSansMonoCd_W5Regular_11">lambda
    x:</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">−</samp><samp class="SANS_TheSansMonoCd_W5Regular_11">x)</samp>
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">print(lst)</samp>
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W5Regular_11">print(lst)</samp>
- en: 'This gives us:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 这将给我们：
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">[4, 2, 2, 1]</samp>
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W5Regular_11">[4, 2, 2, 1]</samp>
- en: The <samp class="SANS_TheSansMonoCd_W5Regular_11">key</samp> of element <samp
    class="SANS_TheSansMonoCd_W5Regular_11">4</samp> is the negative value <samp class="SANS_TheSansMonoCd_W5Regular_11">−</samp><samp
    class="SANS_TheSansMonoCd_W5Regular_11">4</samp>, which is the smallest value
    among all list elements. Because the list is sorted in ascending manner, this
    is the first value of the resultant sorted list.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 元素 <samp class="SANS_TheSansMonoCd_W5Regular_11">4</samp> 的 <samp class="SANS_TheSansMonoCd_W5Regular_11">key</samp>
    是负值 <samp class="SANS_TheSansMonoCd_W5Regular_11">−</samp><samp class="SANS_TheSansMonoCd_W5Regular_11">4</samp>，这是所有列表元素中最小的值。由于列表是按升序排序的，这就是结果排序列表的第一个值。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_I_11">Indexing List Elements</samp>
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_I_11">索引列表元素</samp>
- en: 'You can determine the index of a specified list element <samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp>
    using the method <samp class="SANS_TheSansMonoCd_W5Regular_11">list.index(x)</samp>,
    like so:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用 <samp class="SANS_TheSansMonoCd_W5Regular_11">list.index(x)</samp> 方法来确定指定列表元素
    <samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp> 的索引，如下所示：
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">print([2, 2, 4].index(2))</samp>
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W5Regular_11">print([2, 2, 4].index(2))</samp>
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">print([2, 2, 4].index(2,1))</samp>
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W5Regular_11">print([2, 2, 4].index(2,1))</samp>
- en: The method <samp class="SANS_TheSansMonoCd_W5Regular_11">index(x)</samp> finds
    the first occurrence of the element <samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp>
    in the list and returns its index.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 方法 <samp class="SANS_TheSansMonoCd_W5Regular_11">index(x)</samp> 会查找列表中元素 <samp
    class="SANS_TheSansMonoCd_W5Regular_11">x</samp> 的第一次出现，并返回其索引。
- en: 'You can specify a starting index by passing a second argument that sets the
    index from which to start the search. Consequently, while the first line prints
    the index of the first occurrence of the value 2, the second line prints the index
    of the first occurrence of the value 2 but starts the search from index 1\. The
    method immediately finds the value 2 in both cases and prints:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过传递第二个参数来指定起始索引，该参数设置从哪个索引开始搜索。因此，第一行打印的是值 2 的第一次出现的索引，第二行则从索引 1 开始搜索，打印值
    2 第一次出现的索引。在这两种情况下，该方法都会立即找到值 2 并打印：
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">0</samp>
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W5Regular_11">0</samp>
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">1</samp>
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W5Regular_11">1</samp>
- en: <samp class="SANS_Dogma_OT_Bold_B_11">INDEXING BASICS</samp>
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Dogma_OT_Bold_B_11">索引基础</samp>
- en: <samp class="SANS_Futura_Std_Book_11">Here’s a quick overview of indices in
    Python, by example. Suppose we have the string</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">'universe'</samp><samp
    class="SANS_Futura_Std_Book_11">. The indices are simply the positions of the
    characters of this string, starting at 0:</samp>
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_11">这里是 Python 中索引的快速概述，通过示例来展示。假设我们有一个字符串</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">'universe'</samp><samp class="SANS_Futura_Std_Book_11">。这些索引实际上就是该字符串中各个字符的位置，从
    0 开始：</samp>
- en: <samp class="SANS_Futura_Std_Book_11">Index             0      1      2      3      4      5      6      7</samp>
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_11">索引             0      1      2      3      4      5      6      7</samp>
- en: <samp class="SANS_Futura_Std_Book_11">Character      u      n      i       v       e      r      s      e</samp>
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_11">字符      u      n      i       v       e      r      s      e</samp>
- en: <samp class="SANS_Futura_Std_Book_11">The first character has index 0, the second
    character has index 1, and the</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">i</samp><samp
    class="SANS_Futura_Std_Book_11">-th character has index</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">i</samp><samp
    class="SANS_TheSansMonoCd_W5Regular_11">−</samp><samp class="SANS_TheSansMonoCd_W5Regular_11">1</samp><samp
    class="SANS_Futura_Std_Book_11">.</samp>
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_11">第一个字符的索引是 0，第二个字符的索引是 1，</samp> <samp
    class="SANS_TheSansMonoCd_W5Regular_11">i</samp><samp class="SANS_Futura_Std_Book_11">-th
    字符的索引是</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">i</samp><samp class="SANS_TheSansMonoCd_W5Regular_11">−</samp><samp
    class="SANS_TheSansMonoCd_W5Regular_11">1</samp><samp class="SANS_Futura_Std_Book_11">。</samp>
- en: <samp class="SANS_Futura_Std_Bold_B_11">Slicing</samp>
  id: totrans-87
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">切片</samp>
- en: '*Slicing* is the process of carving out a substring from a given string. We
    call that substring a *slice*. The slicing notation is as follows:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: '*切片* 是从给定字符串中切出子字符串的过程。我们称这个子字符串为 *切片*。切片的语法如下：'
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">string[start:stop:step]</samp>
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W5Regular_11">string[start:stop:step]</samp>
- en: 'The <samp class="SANS_TheSansMonoCd_W5Regular_11">start</samp> argument is
    the index at which we want to start the string and is included in the slice, and
    <samp class="SANS_TheSansMonoCd_W5Regular_11">stop</samp> is the index at which
    we want the string to stop and is excluded from the slice. Forgetting that the
    <samp class="SANS_TheSansMonoCd_W5Regular_11">stop</samp> index is excluded is
    a common source of bugs, so bear it in mind. The <samp class="SANS_TheSansMonoCd_W5Regular_11">step</samp>
    argument tells Python which elements to include, so a <samp class="SANS_TheSansMonoCd_W5Regular_11">step</samp>
    of 2 would include every other element and a <samp class="SANS_TheSansMonoCd_W5Regular_11">step</samp>
    of 3 would include every third element. Here’s an example with a step size of
    2:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W5Regular_11">start</samp> 参数是我们希望开始字符串的位置，并且该位置会包含在切片中，而
    <samp class="SANS_TheSansMonoCd_W5Regular_11">stop</samp> 是我们希望字符串停止的位置，该位置会排除在切片之外。忘记
    <samp class="SANS_TheSansMonoCd_W5Regular_11">stop</samp> 索引被排除在外是一个常见的错误源，所以一定要记住这一点。<samp
    class="SANS_TheSansMonoCd_W5Regular_11">step</samp> 参数告诉 Python 要包含哪些元素，因此，如果
    <samp class="SANS_TheSansMonoCd_W5Regular_11">step</samp> 为 2，它会包含每隔一个元素；如果 <samp
    class="SANS_TheSansMonoCd_W5Regular_11">step</samp> 为 3，它会包含每隔三个元素。下面是一个步长为 2
    的例子：
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">s = '----p-y-t-h-o-n----'</samp>
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W5Regular_11">s = '----p-y-t-h-o-n----'</samp>
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">print(s[4:15:2])</samp>
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W5Regular_11">print(s[4:15:2])</samp>
- en: 'This will give us:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 这将给我们：
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">python</samp>
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W5Regular_11">python</samp>
- en: 'All three arguments are optional, so you can skip them to use the default values
    of <samp class="SANS_TheSansMonoCd_W5Regular_11">start=0</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">stop=len(string)</samp>,
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">step=</samp><samp class="SANS_TheSansMonoCd_W5Regular_11">1</samp>.
    Leaving out the <samp class="SANS_TheSansMonoCd_W5Regular_11">start</samp> argument
    before the slicing colon indicates that the slice starts from the first position,
    and leaving out the <samp class="SANS_TheSansMonoCd_W5Regular_11">stop</samp>
    argument ends the slice at the final element. Leaving out the <samp class="SANS_TheSansMonoCd_W5Regular_11">step</samp>
    argument assumes a step of 1\. Here we skip the <samp class="SANS_TheSansMonoCd_W5Regular_11">step</samp>
    argument:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 所有三个参数都是可选的，因此你可以跳过它们，使用默认值 <samp class="SANS_TheSansMonoCd_W5Regular_11">start=0</samp>、<samp
    class="SANS_TheSansMonoCd_W5Regular_11">stop=len(string)</samp> 和 <samp class="SANS_TheSansMonoCd_W5Regular_11">step=</samp><samp
    class="SANS_TheSansMonoCd_W5Regular_11">1</samp>。在切片冒号前省略 <samp class="SANS_TheSansMonoCd_W5Regular_11">start</samp>
    参数表示切片从第一个位置开始，省略 <samp class="SANS_TheSansMonoCd_W5Regular_11">stop</samp> 参数表示切片在最后一个元素处结束。省略
    <samp class="SANS_TheSansMonoCd_W5Regular_11">step</samp> 参数表示步长为 1。这里我们省略了 <samp
    class="SANS_TheSansMonoCd_W5Regular_11">step</samp> 参数：
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">x = 'universe'</samp>
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W5Regular_11">x = 'universe'</samp>
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">print(x[2:4])</samp>
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W5Regular_11">print(x[2:4])</samp>
- en: 'This gives us:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 这给我们：
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">iv</samp>
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W5Regular_11">iv</samp>
- en: 'Here we specify the start but not the stop, and give a step of 2, so we get
    every other character, starting at the third character and going to the end of
    the string:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 这里我们指定了起始位置但没有指定结束位置，并给定了步长为 2，因此我们从第三个字符开始，跳过每个字符，直到字符串的末尾：
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">x = 'universe'</samp>
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W5Regular_11">x = 'universe'</samp>
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">print(x[2::2])</samp>
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W5Regular_11">print(x[2::2])</samp>
- en: 'This gives us:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 这给我们：
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">ies</samp>
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W5Regular_11">ies</samp>
- en: 'If we accidentally give a <samp class="SANS_TheSansMonoCd_W5Regular_11">stop</samp>
    index that overshoots the maximal sequence index, Python will just assume we meant
    to end the slice at the end of the original string. Here is an example:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们不小心给出了一个超出最大序列索引的 <samp class="SANS_TheSansMonoCd_W5Regular_11">stop</samp>
    索引，Python 会假设我们是想让切片在原始字符串的末尾结束。这里是一个例子：
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">word = "galaxy"</samp>
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W5Regular_11">word = "galaxy"</samp>
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">print(word[4:50])</samp>
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W5Regular_11">print(word[4:50])</samp>
- en: 'This prints:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 这打印出：
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">xy</samp>
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W5Regular_11">xy</samp>
- en: Just remember that nothing unexpected happens if slicing overshoots sequence
    indices.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 只需记住，如果切片超出序列索引，什么意外情况也不会发生。
- en: You can also provide negative integers for all three arguments. A negative index
    for <samp class="SANS_TheSansMonoCd_W5Regular_11">start</samp> or <samp class="SANS_TheSansMonoCd_W5Regular_11">stop</samp>
    tells Python to count from the end. For example, <samp class="SANS_TheSansMonoCd_W5Regular_11">string[</samp><samp
    class="SANS_TheSansMonoCd_W5Regular_11">–</samp><samp class="SANS_TheSansMonoCd_W5Regular_11">3:]</samp>
    would start slicing with the third-to-last element and <samp class="SANS_TheSansMonoCd_W5Regular_11">string[</samp><samp
    class="SANS_TheSansMonoCd_W5Regular_11">–</samp><samp class="SANS_TheSansMonoCd_W5Regular_11">10:</samp><samp
    class="SANS_TheSansMonoCd_W5Regular_11">–</samp><samp class="SANS_TheSansMonoCd_W5Regular_11">5]</samp>
    would start slicing with the tenth-to-last element (included) and stop with the
    fifth-to-last element (excluded). A negative step size means that Python slices
    from the right to the left. For example, <samp class="SANS_TheSansMonoCd_W5Regular_11">string[::</samp><samp
    class="SANS_TheSansMonoCd_W5Regular_11">–</samp><samp class="SANS_TheSansMonoCd_W5Regular_11">1]</samp>
    would reverse the string and <samp class="SANS_TheSansMonoCd_W5Regular_11">string[::</samp><samp
    class="SANS_TheSansMonoCd_W5Regular_11">–</samp><samp class="SANS_TheSansMonoCd_W5Regular_11">2]</samp>
    would take every other character, starting from the last and moving forward toward
    the left.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以为所有三个参数提供负整数。<samp class="SANS_TheSansMonoCd_W5Regular_11">start</samp>
    或 <samp class="SANS_TheSansMonoCd_W5Regular_11">stop</samp> 的负索引告诉 Python 从末尾开始计数。例如，<samp
    class="SANS_TheSansMonoCd_W5Regular_11">string[</samp><samp class="SANS_TheSansMonoCd_W5Regular_11">–</samp><samp
    class="SANS_TheSansMonoCd_W5Regular_11">3:]</samp> 将从倒数第三个元素开始切片，而 <samp class="SANS_TheSansMonoCd_W5Regular_11">string[</samp><samp
    class="SANS_TheSansMonoCd_W5Regular_11">–</samp><samp class="SANS_TheSansMonoCd_W5Regular_11">10:</samp><samp
    class="SANS_TheSansMonoCd_W5Regular_11">–</samp><samp class="SANS_TheSansMonoCd_W5Regular_11">5]</samp>
    将从倒数第十个元素开始（包括该元素），并且在倒数第五个元素处停止（不包括该元素）。负步长意味着 Python 会从右往左切片。例如，<samp class="SANS_TheSansMonoCd_W5Regular_11">string[::</samp><samp
    class="SANS_TheSansMonoCd_W5Regular_11">–</samp><samp class="SANS_TheSansMonoCd_W5Regular_11">1]</samp>
    会将字符串反转，而 <samp class="SANS_TheSansMonoCd_W5Regular_11">string[::</samp><samp
    class="SANS_TheSansMonoCd_W5Regular_11">–</samp><samp class="SANS_TheSansMonoCd_W5Regular_11">2]</samp>
    会每隔一个字符取一个，且从最后一个字符开始，向左移动。
- en: <samp class="SANS_Futura_Std_Bold_B_11">Dictionaries</samp>
  id: totrans-112
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">字典</samp>
- en: 'The *dictionary* is a useful data structure for storing key-value pairs. We
    define a dictionary in curly brackets, like so:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: '*字典* 是一种用于存储键值对的有用数据结构。我们通过大括号来定义字典，如下所示：'
- en: '<samp class="SANS_TheSansMonoCd_W5Regular_11">calories = {''apple'': 52, ''banana'':
    89, ''choco'': 546}</samp>'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: '<samp class="SANS_TheSansMonoCd_W5Regular_11">calories = {''apple'': 52, ''banana'':
    89, ''choco'': 546}</samp>'
- en: 'The key comes first, followed by a colon, and then the value. The key-value
    pairs should be separated by commas. Here <samp class="SANS_TheSansMonoCd_W5Regular_11">''apple''</samp>
    is the first key and <samp class="SANS_TheSansMonoCd_W5Regular_11">52</samp> is
    its value. You can access individual dictionary elements by specifying which dictionary
    to take the element from and specifying the key within brackets. In the following
    example, we compare the calories of an apple to the calories of a piece of chocolate:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 键首先出现，后面跟着冒号，然后是值。键值对之间应该用逗号分隔。这里，<samp class="SANS_TheSansMonoCd_W5Regular_11">'apple'</samp>
    是第一个键，<samp class="SANS_TheSansMonoCd_W5Regular_11">52</samp> 是它的值。你可以通过指定字典和括号中的键来访问字典中的单个元素。在下面的例子中，我们比较了苹果的卡路里和一块巧克力的卡路里：
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">print(calories['apple'] < calories['choco'])</samp>
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W5Regular_11">print(calories['apple'] < calories['choco'])</samp>
- en: 'Of course, it returns:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，它会返回：
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">True</samp>
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W5Regular_11">True</samp>
- en: 'The dictionary is a mutable data structure, so you can change it after creation.
    For instance, you can add, remove, or update existing key-value pairs. Here we
    add a new key-value pair to the dictionary, storing the information that a cappuccino
    has 74 calories:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 字典是一种可变数据结构，因此你可以在创建后更改它。例如，你可以添加、删除或更新现有的键值对。这里，我们向字典中添加了一个新的键值对，存储了卡布奇诺的卡路里是74：
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">calories['cappu'] = 74</samp>
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W5Regular_11">calories['cappu'] = 74</samp>
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">print(calories['banana'] < calories['cappu'])</samp>
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W5Regular_11">print(calories['banana'] < calories['cappu'])</samp>
- en: 'When we assert that a cappuccino has more calories than a banana, we get:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们断言一杯卡布奇诺的卡路里比一根香蕉还多时，我们得到：
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">False</samp>
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W5Regular_11">False</samp>
- en: 'We use the <samp class="SANS_TheSansMonoCd_W5Regular_11">keys()</samp> and
    <samp class="SANS_TheSansMonoCd_W5Regular_11">values()</samp> functions to access
    all keys and values of the dictionary. Here we check whether the string <samp
    class="SANS_TheSansMonoCd_W5Regular_11">''apple''</samp> is one of the dictionary
    keys and the integer <samp class="SANS_TheSansMonoCd_W5Regular_11">52</samp> is
    one of the dictionary values. Both are in fact <samp class="SANS_TheSansMonoCd_W5Regular_11">True</samp>:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用 <samp class="SANS_TheSansMonoCd_W5Regular_11">keys()</samp> 和 <samp class="SANS_TheSansMonoCd_W5Regular_11">values()</samp>
    函数来访问字典中的所有键和值。这里我们检查字符串 <samp class="SANS_TheSansMonoCd_W5Regular_11">'apple'</samp>
    是否是字典的一个键，以及整数 <samp class="SANS_TheSansMonoCd_W5Regular_11">52</samp> 是否是字典的一个值。事实上，这两者的结果都是
    <samp class="SANS_TheSansMonoCd_W5Regular_11">True</samp>：
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">print('apple' in calories.keys())</samp>
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W5Regular_11">print('apple' in calories.keys())</samp>
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">print(52 in calories.values())</samp>
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W5Regular_11">print(52 in calories.values())</samp>
- en: 'To access all key-value pairs of a dictionary, we use the <samp class="SANS_TheSansMonoCd_W5Regular_11">dictionary.items()</samp>
    method. In the following <samp class="SANS_TheSansMonoCd_W5Regular_11">for</samp>
    loop, we iterate over each <samp class="SANS_TheSansMonoCd_W5Regular_11">(key,
    value)</samp> pair in the <samp class="SANS_TheSansMonoCd_W5Regular_11">calories</samp>
    dictionary and check whether each value is more than 500 calories. If this is
    the case, it prints the associated key:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 要访问字典的所有键值对，我们使用 <samp class="SANS_TheSansMonoCd_W5Regular_11">dictionary.items()</samp>
    方法。在以下的 <samp class="SANS_TheSansMonoCd_W5Regular_11">for</samp> 循环中，我们遍历 <samp
    class="SANS_TheSansMonoCd_W5Regular_11">calories</samp> 字典中的每一个 <samp class="SANS_TheSansMonoCd_W5Regular_11">(key,
    value)</samp> 对，并检查每个值是否大于 500 卡路里。如果是这样，它会打印出相应的键：
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">for key, value in calories.items():</samp>
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W5Regular_11">for key, value in calories.items():</samp>
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">   if value > 500:</samp>
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W5Regular_11">   if value > 500:</samp>
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">      print(key)</samp>
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W5Regular_11">      print(key)</samp>
- en: 'Our only result is:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 我们唯一的结果是：
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">'choco'</samp>
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W5Regular_11">'choco'</samp>
- en: This gives us an easy way to iterate over all keys and all values in a dictionary
    without accessing them individually.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 这为我们提供了一种方便的方法，可以在不单独访问每个元素的情况下，遍历字典中的所有键和值。
- en: <samp class="SANS_Futura_Std_Bold_B_11">List Comprehension</samp>
  id: totrans-134
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">列表推导式</samp>
- en: List comprehension is a compact way of creating lists with the simple one-liner
    formula <samp class="SANS_TheSansMonoCd_W5Regular_11">[expression</samp> <samp
    class="SANS_TheSansMonoCd_W5Regular_11">+</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">context]</samp>.
    The <samp class="SANS_TheSansMonoCd_W5Regular_11">context</samp> tells Python
    which elements to add to the new list. The <samp class="SANS_TheSansMonoCd_W5Regular_11">expression</samp>
    defines what to do with each of those new elements before adding them. For example,
    the list comprehension statement
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 列表推导式是一种紧凑的创建列表的方式，其基本格式是 <samp class="SANS_TheSansMonoCd_W5Regular_11">[expression</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">+</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">context]</samp>。<samp
    class="SANS_TheSansMonoCd_W5Regular_11">context</samp> 告诉 Python 向新列表添加哪些元素。<samp
    class="SANS_TheSansMonoCd_W5Regular_11">expression</samp> 定义了在添加这些新元素之前需要对它们做什么。例如，列表推导式语句
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">[x for x in range(3)]</samp>
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W5Regular_11">[x for x in range(3)]</samp>
- en: 'creates the new list <samp class="SANS_TheSansMonoCd_W5Regular_11">[0, 1, 2]</samp>.
    The <samp class="SANS_TheSansMonoCd_W5Regular_11">context</samp> in this example
    is <samp class="SANS_TheSansMonoCd_W5Regular_11">for x in range(3)</samp>, so
    the loop variable <samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp> takes
    on the three values 0, 1, and 2\. The expression <samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp>
    is very basic in this example: it simply adds the current loop variable to the
    list without modification. However, list comprehensions are capable of handling
    far more advanced expressions.'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 创建新的列表 <samp class="SANS_TheSansMonoCd_W5Regular_11">[0, 1, 2]</samp>。这个例子中的
    <samp class="SANS_TheSansMonoCd_W5Regular_11">context</samp> 是 <samp class="SANS_TheSansMonoCd_W5Regular_11">for
    x in range(3)</samp>，因此循环变量 <samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp>
    依次取值 0、1 和 2。这个例子中的 <samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp> 表达式非常简单：它只是将当前的循环变量添加到列表中，而不进行任何修改。然而，列表推导式能够处理更复杂的表达式。
- en: 'List comprehension is often used in dashboard applications; for example, it
    is used to create multiple options for a dropdown menu on the fly. Here we create
    a list of strings—weekdays—and then use the list in a list comprehension to create
    a list of dictionaries. We’ll use the dictionaries to create the labels and options
    for a Dash dropdown menu shown in [Figure 1-1](chapter1.xhtml#fig1-1):'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 列表推导式通常用于仪表盘应用程序中；例如，它用于动态创建多个下拉菜单选项。在这里，我们创建了一个字符串列表——工作日——然后使用该列表在列表推导式中创建一个字典列表。我们将使用这些字典来为
    Dash 下拉菜单创建标签和选项，菜单显示在[图 1-1](chapter1.xhtml#fig1-1)中：
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">days = ['Mon', 'Tue', 'Wed', 'Thu',
    'Fri', 'Sat', 'Sun']</samp>
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W5Regular_11">days = ['Mon', 'Tue', 'Wed', 'Thu',
    'Fri', 'Sat', 'Sun']</samp>
- en: '<samp class="SANS_TheSansMonoCd_W5Regular_11">options = [{''label'': day, ''value'':
    day} for day in days]</samp>'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: '<samp class="SANS_TheSansMonoCd_W5Regular_11">options = [{''label'': day, ''value'':
    day} for day in days]</samp>'
- en: '![](../images/Figure1-1.png)'
  id: totrans-141
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/Figure1-1.png)'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 1-1: A Dash dropdown
    menu</samp>'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">图 1-1：一个 Dash 下拉菜单</samp>
- en: 'The context is <samp class="SANS_TheSansMonoCd_W5Regular_11">for day in days</samp>,
    so we iterate over each weekday <samp class="SANS_TheSansMonoCd_W5Regular_11">''Mon'',</samp><samp
    class="SANS_TheSansMonoCd_W5Regular_11">…,</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">''Sun''</samp>.
    The expression creates a dictionary with two key-value pairs, <samp class="SANS_TheSansMonoCd_W5Regular_11">{''label'':
    day, ''value'': day}</samp>. This is a very concise way to create the following
    list of dictionaries:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: '上下文是 <samp class="SANS_TheSansMonoCd_W5Regular_11">for day in days</samp>，因此我们遍历每个工作日
    <samp class="SANS_TheSansMonoCd_W5Regular_11">''Mon'',</samp><samp class="SANS_TheSansMonoCd_W5Regular_11">
    … ,</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">''Sun''</samp>。该表达式创建了一个包含两个键值对的字典，<samp
    class="SANS_TheSansMonoCd_W5Regular_11">{''label'': day, ''value'': day}</samp>。这是一种非常简洁的方式，来创建以下字典列表：'
- en: '<samp class="SANS_TheSansMonoCd_W5Regular_11">[{''label'': ''Mon'', ''value'':
    ''Mon''}, {''label'': ''Tue'', ''value'': ''Tue''},'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: '<samp class="SANS_TheSansMonoCd_W5Regular_11">[{''label'': ''Mon'', ''value'':
    ''Mon''}, {''label'': ''Tue'', ''value'': ''Tue''},'
- en: '{''label'': ''Wed'', ''value'': ''Wed''}, {''label'': ''Thu'', ''value'': ''Thu''},'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: '{''label'': ''Wed'', ''value'': ''Wed''}, {''label'': ''Thu'', ''value'': ''Thu''},'
- en: '{''label'': ''Fri'', ''value'': ''Fri''}, {''label'': ''Sat'', ''value'': ''Sat''},'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: '{''label'': ''Fri'', ''value'': ''Fri''}, {''label'': ''Sat'', ''value'': ''Sat''},'
- en: '{''label'': ''Sun'', ''value'': ''Sun''}]</samp>'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: '{''label'': ''Sun'', ''value'': ''Sun''}]</samp>'
- en: 'The alternative is to use a regular Python <samp class="SANS_TheSansMonoCd_W5Regular_11">for</samp>
    loop, as shown in these three lines:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种方式是使用常规的 Python <samp class="SANS_TheSansMonoCd_W5Regular_11">for</samp>
    循环，如这三行代码所示：
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">options = []</samp>
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W5Regular_11">options = []</samp>
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">for day in days:</samp>
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W5Regular_11">for day in days:</samp>
- en: '<samp class="SANS_TheSansMonoCd_W5Regular_11">   options.append({''label'':
    day, ''value'': day})</samp>'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: '<samp class="SANS_TheSansMonoCd_W5Regular_11">   options.append({''label'':
    day, ''value'': day})</samp>'
- en: You create a list of dictionaries where both the label and the value are associated
    with the respective day. Here the dropdown menu will show the label <samp class="SANS_TheSansMonoCd_W5Regular_11">'Mon'</samp>
    and, if selected by the user, will associate the label with the value <samp class="SANS_TheSansMonoCd_W5Regular_11">'Mon'</samp>
    to it.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 你创建了一个字典列表，其中标签和对应的值与相应的星期几相关联。在这里，下拉菜单将显示标签<samp class="SANS_TheSansMonoCd_W5Regular_11">'Mon'</samp>，如果用户选择它，标签将与值<samp
    class="SANS_TheSansMonoCd_W5Regular_11">'Mon'</samp>关联。
- en: 'The context consists of an arbitrary number of <samp class="SANS_TheSansMonoCd_W5Regular_11">for</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">if</samp> statements. We could
    use an <samp class="SANS_TheSansMonoCd_W5Regular_11">if</samp> statement within
    the list comprehension to filter results; for example, we can create dropdown
    options with only weekdays:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 这个上下文包含了任意数量的 <samp class="SANS_TheSansMonoCd_W5Regular_11">for</samp> 和 <samp
    class="SANS_TheSansMonoCd_W5Regular_11">if</samp> 语句。我们可以在列表推导式中使用 <samp class="SANS_TheSansMonoCd_W5Regular_11">if</samp>
    语句来过滤结果；例如，我们可以仅使用工作日来创建下拉菜单选项：
- en: '<samp class="SANS_TheSansMonoCd_W5Regular_11">options = [{''label'': day, ''value'':
    day} for day in days if day not in [''Sat'', ''Sun'']]</samp>'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: '<samp class="SANS_TheSansMonoCd_W5Regular_11">options = [{''label'': day, ''value'':
    day} for day in days if day not in [''Sat'', ''Sun'']]</samp>'
- en: Here we use the <samp class="SANS_TheSansMonoCd_W5Regular_11">if</samp> statement
    to exclude <samp class="SANS_TheSansMonoCd_W5Regular_11">Sat</samp> and <samp
    class="SANS_TheSansMonoCd_W5Regular_11">Sun</samp> from the resultant list. It’s
    a quicker, more concise way of writing this regular <samp class="SANS_TheSansMonoCd_W5Regular_11">if</samp>
    statement within a <samp class="SANS_TheSansMonoCd_W5Regular_11">for</samp> loop.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们使用<samp class="SANS_TheSansMonoCd_W5Regular_11">if</samp>语句将<samp class="SANS_TheSansMonoCd_W5Regular_11">Sat</samp>和<samp
    class="SANS_TheSansMonoCd_W5Regular_11">Sun</samp>排除在结果列表之外。这是一种更快速、更简洁的写法，用于在<samp
    class="SANS_TheSansMonoCd_W5Regular_11">for</samp>循环中实现常规的<samp class="SANS_TheSansMonoCd_W5Regular_11">if</samp>语句。
- en: <samp class="SANS_Futura_Std_Bold_B_11">Object-Oriented Programming</samp>
  id: totrans-156
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">面向对象编程</samp>
- en: In Python, everything is an object. Even integer values are objects. This is
    different from programming languages like C, where integers, floats, and Booleans
    are primitive data types. In this way, Python is built on a rigorously consistent
    object-oriented paradigm.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 在Python中，一切都是对象。即使是整数值也是对象。这与C语言等编程语言不同，在这些语言中，整数、浮动数和布尔值是原始数据类型。因此，Python是建立在一种严谨一致的面向对象范式上的。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_I_11">Classes and Objects</samp>
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_I_11">类与对象</samp>
- en: At the heart of object-oriented Python are classes. Classes are blueprints for
    creating objects. A class description tells you what an object looks like and
    what it can do, respectively known as the object’s *data* and *functionality*.
    The data is defined in *attributes*, which are variables associated with a given
    object. The functionality is defined in *methods*, which are functions associated
    with the given object.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 面向对象的Python核心是类。类是创建对象的蓝图。类的描述告诉你一个对象的外观以及它能做什么，这分别被称为对象的*数据*和*功能*。数据通过*属性*定义，属性是与给定对象相关的变量。功能通过*方法*定义，方法是与给定对象相关的函数。
- en: 'Let’s see these concepts in action using Harry Potter examples. First we’ll
    make a class with attributes but no methods. Here we create a <samp class="SANS_TheSansMonoCd_W5Regular_11">Muggle</samp>
    class and make two <samp class="SANS_TheSansMonoCd_W5Regular_11">Muggle</samp>
    objects from it:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过哈利·波特的例子来看这些概念的实际应用。首先，我们将创建一个只有属性而没有方法的类。在这里，我们创建了一个<samp class="SANS_TheSansMonoCd_W5Regular_11">Muggle</samp>类，并从中创建了两个<samp
    class="SANS_TheSansMonoCd_W5Regular_11">Muggle</samp>对象：
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">class Muggle:</samp>
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W5Regular_11">class Muggle:</samp>
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">   def __init__(self, age, name,
    liking_person):</samp>
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W5Regular_11">   def __init__(self, age, name,
    liking_person):</samp>
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">      self.age =</samp> <samp
    class="SANS_TheSansMonoCd_W5Regular_11">age</samp>
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W5Regular_11">      self.age =</samp> <samp
    class="SANS_TheSansMonoCd_W5Regular_11">age</samp>
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">      self.name = name</samp>
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W5Regular_11">      self.name = name</samp>
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">      self.likes = liking_person</samp>
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W5Regular_11">      self.likes = liking_person</samp>
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">Vernon = Muggle(52, "Vernon",
    None)</samp>
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W5Regular_11">Vernon = Muggle(52, "Vernon",
    None)</samp>
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">Petunia = Muggle(49, "Petunia",
    Vernon)</samp>
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W5Regular_11">Petunia = Muggle(49, "Petunia",
    Vernon)</samp>
- en: We create a new blueprint for <samp class="SANS_TheSansMonoCd_W5Regular_11">Muggle</samp>
    objects using the keyword <samp class="SANS_TheSansMonoCd_W5Regular_11">class</samp>.
    This dictates what data every <samp class="SANS_TheSansMonoCd_W5Regular_11">Muggle</samp>
    object will have and what it can do. Here we say that each <samp class="SANS_TheSansMonoCd_W5Regular_11">Muggle</samp>
    object should have an age, a name, and someone they like.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用关键字<samp class="SANS_TheSansMonoCd_W5Regular_11">class</samp>为<samp class="SANS_TheSansMonoCd_W5Regular_11">Muggle</samp>对象创建一个新的蓝图。这决定了每个<samp
    class="SANS_TheSansMonoCd_W5Regular_11">Muggle</samp>对象将拥有的数据以及它能做什么。在这里，我们规定每个<samp
    class="SANS_TheSansMonoCd_W5Regular_11">Muggle</samp>对象应有一个年龄、一个名字和一个他们喜欢的人。
- en: For every class, you must use the method <samp class="SANS_TheSansMonoCd_W5Regular_11">__init__()</samp>
    to initialize the class with data. Every <samp class="SANS_TheSansMonoCd_W5Regular_11">Muggle</samp>
    object will have the attributes <samp class="SANS_TheSansMonoCd_W5Regular_11">age</samp>,
    <samp class="SANS_TheSansMonoCd_W5Regular_11">name</samp>, and <samp class="SANS_TheSansMonoCd_W5Regular_11">likes</samp>.
    By passing them in as arguments to the <samp class="SANS_TheSansMonoCd_W5Regular_11">def</samp>
    statement, we make them required arguments when creating an object. The first
    value of any class method is a reference to the object itself, denoted as <samp
    class="SANS_TheSansMonoCd_W5Regular_11">self</samp>. As soon as you call the initialization
    method in your code, Python creates an empty object you can access using the name
    <samp class="SANS_TheSansMonoCd_W5Regular_11">self</samp>.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 对于每个类，你必须使用方法<samp class="SANS_TheSansMonoCd_W5Regular_11">__init__()</samp>来初始化类的数据。每个<samp
    class="SANS_TheSansMonoCd_W5Regular_11">Muggle</samp>对象都会有属性<samp class="SANS_TheSansMonoCd_W5Regular_11">age</samp>、<samp
    class="SANS_TheSansMonoCd_W5Regular_11">name</samp>和<samp class="SANS_TheSansMonoCd_W5Regular_11">likes</samp>。通过将它们作为参数传递给<samp
    class="SANS_TheSansMonoCd_W5Regular_11">def</samp>语句，我们使它们在创建对象时成为必需的参数。任何类方法的第一个值是对对象本身的引用，用<samp
    class="SANS_TheSansMonoCd_W5Regular_11">self</samp>表示。只要你在代码中调用初始化方法，Python就会创建一个空对象，你可以使用<samp
    class="SANS_TheSansMonoCd_W5Regular_11">self</samp>来访问它。
- en: <samp class="SANS_Dogma_OT_Bold_B_15">NOTE</samp>
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Dogma_OT_Bold_B_15">注意</samp>
- en: '*Although the first argument is self when defining a method, you don’t actually
    specify this argument when calling the method. Python does it for you internally.*'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: '*尽管在定义方法时，第一个参数是self，但在调用方法时你实际上不需要指定这个参数。Python会在内部为你处理它。*'
- en: 'When you create an object from the class, the initialization method <samp class="SANS_TheSansMonoCd_W5Regular_11">__init__</samp>
    is automatically called first to instantiate a new object by using the name of
    the class as a function call. The calls <samp class="SANS_TheSansMonoCd_W5Regular_11">Muggle(52,
    "Vernon", None)</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">Muggle(49,
    "Petunia", Vernon)</samp> create two new class objects, both defining the three
    attributes, shown here:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 当你从类创建对象时，初始化方法<samp class="SANS_TheSansMonoCd_W5Regular_11">__init__</samp>会自动首先被调用，通过将类的名称作为函数调用来实例化一个新对象。调用<samp
    class="SANS_TheSansMonoCd_W5Regular_11">Muggle(52, "Vernon", None)</samp>和<samp
    class="SANS_TheSansMonoCd_W5Regular_11">Muggle(49, "Petunia", Vernon)</samp>会创建两个新的类对象，两个对象都定义了这三个属性，如下所示：
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">Muggle</samp>
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W5Regular_11">麻瓜</samp>
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">   age = 52</samp>
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W5Regular_11">   age = 52</samp>
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">   name = "Vernon"</samp>
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W5Regular_11">   name = "Vernon"</samp>
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">   likes = None</samp>
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W5Regular_11">   likes = None</samp>
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">Muggle</samp>
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W5Regular_11">麻瓜</samp>
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">   age = 49</samp>
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W5Regular_11">   age = 49</samp>
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">   name = "Petunia"</samp>
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W5Regular_11">   name = "Petunia"</samp>
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">   likes = "Vernon"</samp>
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W5Regular_11">   likes = "Vernon"</samp>
- en: You can see that these objects follow the same blueprint but are different instances
    of a <samp class="SANS_TheSansMonoCd_W5Regular_11">Muggle</samp>; they have the
    same properties but different DNA.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以看到这些对象遵循相同的蓝图，但它们是<samp class="SANS_TheSansMonoCd_W5Regular_11">Muggle</samp>的不同实例；它们具有相同的属性，但不同的“DNA”。
- en: From now on, these objects live in your computer’s memory until Python kills
    them when the program terminates.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 从现在开始，这些对象将驻留在计算机的内存中，直到程序终止时，Python才会将它们销毁。
- en: 'Can you see the tragic element of the story so far? Petunia likes Vernon, but
    Vernon likes nobody. Let’s cheer this up a bit, shall we? We’ll change the <samp
    class="SANS_TheSansMonoCd_W5Regular_11">likes</samp> attribute for <samp class="SANS_TheSansMonoCd_W5Regular_11">Vernon</samp>
    to <samp class="SANS_TheSansMonoCd_W5Regular_11">Petunia</samp>. We can access
    the different attributes of an object using the name of the object, dot notation,
    and then the name of the attribute, like so:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，你能看到这个故事中的悲剧元素吗？Petunia喜欢Vernon，但Vernon不喜欢任何人。我们来稍微让这个故事变得轻松一些，好吗？我们将把<samp
    class="SANS_TheSansMonoCd_W5Regular_11">Vernon</samp>的<samp class="SANS_TheSansMonoCd_W5Regular_11">likes</samp>属性改为<samp
    class="SANS_TheSansMonoCd_W5Regular_11">Petunia</samp>。我们可以通过对象的名称、点表示法，然后是属性名称来访问对象的不同属性，像这样：
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">Vernon.likes = "Petunia"</samp>
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W5Regular_11">Vernon.likes = "Petunia"</samp>
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">print(Vernon.likes)</samp>
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W5Regular_11">print(Vernon.likes)</samp>
- en: 'This will print:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 这将输出：
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">Petunia</samp>
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W5Regular_11">Petunia</samp>
- en: 'Let’s define the <samp class="SANS_TheSansMonoCd_W5Regular_11">Wizard</samp>
    class so that we can create some wizards in our small world. This time we’ll add
    some functionality:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们定义一个 <samp class="SANS_TheSansMonoCd_W5Regular_11">Wizard</samp> 类，以便我们能在这个小世界中创建一些巫师。这一次，我们将添加一些功能：
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">class Wizard:</samp>
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W5Regular_11">class Wizard:</samp>
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">   def __init__(self, age, name):</samp>
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W5Regular_11">   def __init__(self, age, name):</samp>
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">      self.age = age</samp>
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W5Regular_11">      self.age = age</samp>
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">      self.name = name</samp>
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W5Regular_11">      self.name = name</samp>
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">      self.mana = 100</samp>
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W5Regular_11">      self.mana = 100</samp>
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">   def love_me(self, victim):</samp>
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W5Regular_11">   def love_me(self, victim):</samp>
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">      if self.mana >= 100:</samp>
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W5Regular_11">      if self.mana >= 100:</samp>
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">         victim.likes = self.name</samp>
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W5Regular_11">         victim.likes = self.name</samp>
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">         self.mana =</samp> <samp
    class="SANS_TheSansMonoCd_W5Regular_11">self.mana</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">–</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">100</samp>
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W5Regular_11">         self.mana =</samp> <samp
    class="SANS_TheSansMonoCd_W5Regular_11">self.mana</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">–</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">100</samp>
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">Wiz = Wizard(42, "Tom")</samp>
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W5Regular_11">Wiz = Wizard(42, "Tom")</samp>
- en: 'Every <samp class="SANS_TheSansMonoCd_W5Regular_11">Wizard</samp> object has
    three attributes: <samp class="SANS_TheSansMonoCd_W5Regular_11">age</samp>, <samp
    class="SANS_TheSansMonoCd_W5Regular_11">name</samp>, and <samp class="SANS_TheSansMonoCd_W5Regular_11">mana</samp>
    level (how much magic power the wizard has left). The <samp class="SANS_TheSansMonoCd_W5Regular_11">age</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">name</samp> attributes are set
    when you create a <samp class="SANS_TheSansMonoCd_W5Regular_11">Wizard</samp>
    object according to the values passed in as arguments. The <samp class="SANS_TheSansMonoCd_W5Regular_11">mana</samp>
    attribute is hardcoded to <samp class="SANS_TheSansMonoCd_W5Regular_11">100</samp>
    in the <samp class="SANS_TheSansMonoCd_W5Regular_11">__init__</samp> method. For
    example, calling <samp class="SANS_TheSansMonoCd_W5Regular_11">Wizard(42, "Tom")</samp>
    would set <samp class="SANS_TheSansMonoCd_W5Regular_11">self.age</samp> to <samp
    class="SANS_TheSansMonoCd_W5Regular_11">42</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">self.name</samp>
    to <samp class="SANS_TheSansMonoCd_W5Regular_11">"Tom"</samp>, and <samp class="SANS_TheSansMonoCd_W5Regular_11">self.mana</samp>
    to <samp class="SANS_TheSansMonoCd_W5Regular_11">100</samp>.'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 每个 <samp class="SANS_TheSansMonoCd_W5Regular_11">Wizard</samp> 对象有三个属性：<samp
    class="SANS_TheSansMonoCd_W5Regular_11">age</samp>、<samp class="SANS_TheSansMonoCd_W5Regular_11">name</samp>
    和 <samp class="SANS_TheSansMonoCd_W5Regular_11">mana</samp> 等级（即巫师剩余的魔法力量）。<samp
    class="SANS_TheSansMonoCd_W5Regular_11">age</samp> 和 <samp class="SANS_TheSansMonoCd_W5Regular_11">name</samp>
    属性是在创建 <samp class="SANS_TheSansMonoCd_W5Regular_11">Wizard</samp> 对象时，根据传入的参数值来设置的。而
    <samp class="SANS_TheSansMonoCd_W5Regular_11">mana</samp> 属性则在 <samp class="SANS_TheSansMonoCd_W5Regular_11">__init__</samp>
    方法中被硬编码为 <samp class="SANS_TheSansMonoCd_W5Regular_11">100</samp>。例如，调用 <samp
    class="SANS_TheSansMonoCd_W5Regular_11">Wizard(42, "Tom")</samp> 会将 <samp class="SANS_TheSansMonoCd_W5Regular_11">self.age</samp>
    设置为 <samp class="SANS_TheSansMonoCd_W5Regular_11">42</samp>，<samp class="SANS_TheSansMonoCd_W5Regular_11">self.name</samp>
    设置为 <samp class="SANS_TheSansMonoCd_W5Regular_11">"Tom"</samp>，并且 <samp class="SANS_TheSansMonoCd_W5Regular_11">self.mana</samp>
    设置为 <samp class="SANS_TheSansMonoCd_W5Regular_11">100</samp>。
- en: We also add the method <samp class="SANS_TheSansMonoCd_W5Regular_11">love_me()</samp>,
    which casts a love spell on the victim. If the wizard has enough mana left, they
    can force the victim to love them by setting the victim’s <samp class="SANS_TheSansMonoCd_W5Regular_11">likes</samp>
    attribute to the caster’s name. However, this only works if the mana level of
    the wizard is greater than or equal to 100 (<samp class="SANS_TheSansMonoCd_W5Regular_11">self.mana</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">>=</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">100</samp>).
    When successful, the victim’s <samp class="SANS_TheSansMonoCd_W5Regular_11">likes</samp>
    attribute points to the casting wizard’s name and the casting wizard’s mana level
    reduces by 100.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还添加了一个方法<sup class="SANS_TheSansMonoCd_W5Regular_11">love_me()</sup>，它对受害者施下爱情魔咒。如果巫师剩余的法力足够，他们可以通过将受害者的<sup
    class="SANS_TheSansMonoCd_W5Regular_11">likes</sup>属性设置为施法者的名字来迫使受害者爱上他们。然而，只有当巫师的法力大于或等于100时（<sup
    class="SANS_TheSansMonoCd_W5Regular_11">self.mana</sup> <sup class="SANS_TheSansMonoCd_W5Regular_11">>=</sup>
    <sup class="SANS_TheSansMonoCd_W5Regular_11">100</sup>），这才有效。成功后，受害者的<sup class="SANS_TheSansMonoCd_W5Regular_11">likes</sup>属性指向施法巫师的名字，而施法巫师的法力值减少100。
- en: 'We’ve created a 42-year-old wizard named Tom. Tom is lonely and wants to be
    liked. Let’s get Petunia and Vernon to love him. We access an object’s methods
    using the dot notation and pass in the <samp class="SANS_TheSansMonoCd_W5Regular_11">Petunia</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">Vernon</samp> objects:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建了一个42岁的巫师，名叫Tom。Tom很孤独，想要被喜欢。让我们让Petunia和Vernon爱上他。我们使用点表示法来访问对象的方法，并传入<sup
    class="SANS_TheSansMonoCd_W5Regular_11">Petunia</sup>和<sup class="SANS_TheSansMonoCd_W5Regular_11">Vernon</sup>对象：
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">Wiz.love_me(Petunia)</samp>
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W5Regular_11">Wiz.love_me(Petunia)</samp>
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">Wiz.love_me(Vernon)</samp>
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W5Regular_11">Wiz.love_me(Vernon)</samp>
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">print(Petunia.likes=="Tom" and
    Vernon.likes=="Tom")</samp>
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W5Regular_11">print(Petunia.likes=="Tom" and
    Vernon.likes=="Tom")</samp>
- en: Can you tell whether Tom was successful in making both Petunia and Vernon love
    him?
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 你能告诉我Tom是否成功让Petunia和Vernon都爱上他吗？
- en: One of the most common sources of confusion in object-oriented programming is
    forgetting to include the <samp class="SANS_TheSansMonoCd_W5Regular_11">self</samp>
    argument when defining a method. Another is that the definition of the initialization
    method uses the syntax <samp class="SANS_TheSansMonoCd_W5Regular_11">__init__()</samp>,
    whereas you’d call the class creation method using the syntax <samp class="SANS_TheSansMonoCd_W5Regular_11">ClassName()</samp>
    and not <samp class="SANS_TheSansMonoCd_W5Regular_11">ClassName.__init__()</samp>,
    as you might expect. This is shown in the code where we do not call <samp class="SANS_TheSansMonoCd_W5Regular_11">Wizard.__init__(20,
    'Ron')</samp> but simply call <samp class="SANS_TheSansMonoCd_W5Regular_11">Wizard(20,
    'Ron')</samp> to create a new <samp class="SANS_TheSansMonoCd_W5Regular_11">Wizard</samp>
    object.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 面向对象编程中最常见的混淆来源之一是忘记在定义方法时包含<sup class="SANS_TheSansMonoCd_W5Regular_11">self</sup>参数。另一个问题是初始化方法的定义使用了语法<sup
    class="SANS_TheSansMonoCd_W5Regular_11">__init__()</sup>，而你调用类创建方法时使用语法<sup class="SANS_TheSansMonoCd_W5Regular_11">ClassName()</sup>，而不是你可能预期的<sup
    class="SANS_TheSansMonoCd_W5Regular_11">ClassName.__init__()</sup>。这在代码中有所体现，我们并没有调用<sup
    class="SANS_TheSansMonoCd_W5Regular_11">Wizard.__init__(20, 'Ron')</sup>，而是简单地调用<sup
    class="SANS_TheSansMonoCd_W5Regular_11">Wizard(20, 'Ron')</sup>来创建一个新的<sup class="SANS_TheSansMonoCd_W5Regular_11">Wizard</sup>对象。
- en: This has been a brief overview of object-oriented programming in Python, but
    it’s worth ensuring that you fully understand how to build classes and objects
    in Python.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 这只是对 Python 中面向对象编程的简要概述，但值得确保你完全理解如何在 Python 中构建类和对象。
- en: For further information, you can check out the cheat sheet on object-oriented
    programming at [*https://<wbr>blog<wbr>.finxter<wbr>.com<wbr>/object<wbr>-oriented<wbr>-programming<wbr>-terminology<wbr>-cheat<wbr>-sheet*](https://blog.finxter.com/object-oriented-programming-terminology-cheat-sheet).
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 如需进一步信息，可以查看有关面向对象编程的备忘单：[*https://<wbr>blog<wbr>.finxter<wbr>.com<wbr>/object<wbr>-oriented<wbr>-programming<wbr>-terminology<wbr>-cheat<wbr>-sheet*](https://blog.finxter.com/object-oriented-programming-terminology-cheat-sheet)。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_I_11">Terminology</samp>
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_I_11">术语</samp>
- en: Here we’ll quickly sweep through a few key definitions in object-oriented Python.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们将快速浏览面向对象的 Python 中的一些关键定义。
- en: '**Class      **A blueprint to create objects. The class defines the data (attributes)
    and functionality (methods) of the objects. You can access both attributes and
    methods via the dot notation.'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: '**类** 创建对象的蓝图。类定义了对象的属性（数据）和功能（方法）。你可以通过点表示法访问属性和方法。'
- en: '**Object      **A piece of encapsulated data with associated functionality
    that is built according to a class definition. Objects are also referred to as
    *instances* of a class. Often, an object is made to model a thing in the real
    world. For example, we might create the object <samp class="SANS_TheSansMonoCd_W5Regular_11">Obama</samp>
    according to the class definition <samp class="SANS_TheSansMonoCd_W5Regular_11">Person</samp>**.**
    An object consists of an arbitrary number of attributes and methods, encapsulated
    within a single unit.'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: '**对象** 一个根据类定义构建的、包含封装数据和相关功能的单元。对象也被称为类的*实例*。通常，一个对象被用来模拟现实世界中的事物。例如，我们可以根据类定义
    <samp class="SANS_TheSansMonoCd_W5Regular_11">Person</samp> 创建对象 <samp class="SANS_TheSansMonoCd_W5Regular_11">Obama</samp>**。**
    一个对象由任意数量的属性和方法组成，这些属性和方法被封装在一个单独的单元中。'
- en: '**Instantiation      **The process of creating an object of a class.'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: '**实例化** 创建一个类的对象的过程。'
- en: '**Method      **A function associated with a specific object. We define methods
    using the keyword def in the class definition. An object can have as many methods
    as you like.'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: '**方法** 与特定对象关联的函数。我们使用关键字 def 在类定义中定义方法。一个对象可以有任意多个方法。'
- en: '**Attribute      A** variable used to hold data associated with a class or
    instance.'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: '**属性** 用于存储与类或实例相关联的数据的变量。'
- en: '**Class attribute**A variable that is created statically in the class definition
    and is shared by all objects created from that class. These are also variously
    known as *class variables***,** *static variables*, and *static attributes***.**'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: '**类属性** 在类定义中静态创建的变量，并且由该类创建的所有对象共享。它们也被称为*类变量*、**静态变量**和*静态属性*。'
- en: '**Dynamic attribute      **An object attribute that is defined dynamically
    during program execution, and is not defined within any method. For example, you
    can simply add a new attribute <samp class="SANS_TheSansMonoCd_W5Regular_11">my_attribute</samp>
    to any object <samp class="SANS_TheSansMonoCd_W5Regular_11">o</samp> by calling
    <samp class="SANS_TheSansMonoCd_W5Regular_11">o.my_attribute</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">=</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">42</samp>**.**'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: '**动态属性** 在程序执行期间动态定义的对象属性，并且在任何方法内没有定义。例如，你可以通过调用 <samp class="SANS_TheSansMonoCd_W5Regular_11">o.my_attribute</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">=</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">42</samp>，简单地将一个新属性
    <samp class="SANS_TheSansMonoCd_W5Regular_11">my_attribute</samp> 添加到任何对象 <samp
    class="SANS_TheSansMonoCd_W5Regular_11">o</samp> 上**。'
- en: '**Instance attribute**A variable that holds data belonging to only a single
    object. Other objects do not share this variable, as they do with class attributes.
    In most cases, you create an instance attribute <samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp>
    when creating the instance using the <samp class="SANS_TheSansMonoCd_W5Regular_11">self</samp>
    variable name, like self.x = 42\. These are also known as *instance variables***.**'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: '**实例属性** 存储属于单个对象的数据的变量。其他对象不能像类属性那样共享此变量。通常，在使用 <samp class="SANS_TheSansMonoCd_W5Regular_11">self</samp>
    变量名创建实例时，你会创建一个实例属性 <samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp>，例如
    self.x = 42。这些也被称为*实例变量*。'
- en: '**Inheritance      **A programming concept that allows you to create new classes
    as modifications of existing classes by reusing some or all of the data and functionality
    when defining the new class. That is, class A can inherit attributes or methods
    from class <samp class="SANS_TheSansMonoCd_W5Regular_11">B</samp> so that it has
    the same data and functionality as class <samp class="SANS_TheSansMonoCd_W5Regular_11">B</samp>**,**
    but class <samp class="SANS_TheSansMonoCd_W5Regular_11">A</samp> can alter the
    behavior or add data and methods. For example, the class <samp class="SANS_TheSansMonoCd_W5Regular_11">Dog</samp>
    may inherit the attribute <samp class="SANS_TheSansMonoCd_W5Regular_11">number_of_legs</samp>
    from the class Animal. In this case, you would define the inherited class <samp
    class="SANS_TheSansMonoCd_W5Regular_11">Dog</samp> as follows: <samp class="SANS_TheSansMonoCd_W5Regular_11">class
    Dog(Animal):</samp> followed by the body of the class.'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: '**继承**      一种编程概念，允许你通过重用一些或所有数据和功能来创建新类作为现有类的修改版本。也就是说，类A可以继承类<samp class="SANS_TheSansMonoCd_W5Regular_11">B</samp>的属性或方法，使其拥有与类<samp
    class="SANS_TheSansMonoCd_W5Regular_11">B</samp>相同的数据和功能，但类<samp class="SANS_TheSansMonoCd_W5Regular_11">A</samp>可以改变行为或添加数据和方法。例如，类<samp
    class="SANS_TheSansMonoCd_W5Regular_11">Dog</samp>可以继承类Animal的属性<samp class="SANS_TheSansMonoCd_W5Regular_11">number_of_legs</samp>。在这种情况下，你可以按如下方式定义继承类<samp
    class="SANS_TheSansMonoCd_W5Regular_11">Dog</samp>：<samp class="SANS_TheSansMonoCd_W5Regular_11">class
    Dog(Animal):</samp>，然后是类体。'
- en: If you have understood these terms, you can follow most discussions about object-oriented
    programming. Mastering object orientation is an important step toward proficiency
    in Python.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你理解了这些术语，你就能跟随大多数关于面向对象编程的讨论。掌握面向对象是精通Python的重要一步。
- en: <samp class="SANS_Futura_Std_Bold_B_11">Decorator Functions and Annotations</samp>
  id: totrans-221
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">装饰器函数和注解</samp>
- en: Dash relies heavily on the Python concept of *decorators* or *decorator functions*,
    which add functionality to existing code without modifying the code itself. This
    is useful if you want to modify or customize, say, the output of an existing function
    without having to change the actual code of the function. For example, you may
    not have access to a function definition, but you may still want to change the
    behavior of the function. Decorator functions to the rescue!
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: Dash在很大程度上依赖于Python中的*装饰器*或*装饰器函数*的概念，装饰器函数可以在不修改代码本身的情况下为现有代码添加功能。如果你想修改或定制现有函数的输出，而不需要改变函数的实际代码，这非常有用。例如，你可能没有访问函数定义的权限，但仍然希望改变该函数的行为。装饰器函数来帮忙了！
- en: Think of a decorator function as a wrapper. It takes an original function, calls
    it, and modifies its behavior after the fact according to the desires of the programmer.
    This way, you can change the behavior of a function dynamically, after the function
    was originally defined.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 把装饰器函数想象成一个包装器。它接受一个原始函数，调用它，然后根据程序员的需求修改其行为。这样，你可以在函数最初定义后动态地改变函数的行为。
- en: 'Let’s start with a straightforward example. Let’s define a function that prints
    some text to the standard output:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从一个简单的例子开始。定义一个打印文本到标准输出的函数：
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">def print_text():</samp>
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W5Regular_11">def print_text():</samp>
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">   print("Hello world!")</samp>
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W5Regular_11">   print("Hello world!")</samp>
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">print_text()</samp>
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W5Regular_11">print_text()</samp>
- en: 'The output is:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 输出为：
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">Hello world!</samp>
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W5Regular_11">Hello world!</samp>
- en: 'The function will always print the same message. Say you want to decorate this
    output to make it more interesting. One way is to define a new <samp class="SANS_TheSansMonoCd_W5Regular_11">pretty_print()</samp>
    function; this is not yet a decorator function, because it doesn’t change the
    behavior of another function. However, it does demonstrate wrapping another function
    and modifying its behavior:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 该函数将始终打印相同的消息。假设你想装饰这个输出，使其更有趣。一种方法是定义一个新的<samp class="SANS_TheSansMonoCd_W5Regular_11">pretty_print()</samp>函数；这还不是装饰器函数，因为它没有改变另一个函数的行为。然而，它确实展示了如何包装另一个函数并修改其行为：
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">def print_text():</samp>
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W5Regular_11">def print_text():</samp>
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">   print("Hello world!")</samp>
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W5Regular_11">   print("Hello world!")</samp>
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">def pretty_print():</samp>
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W5Regular_11">def pretty_print():</samp>
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">   annotate = '+'</samp>
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W5Regular_11">   annotate = '+'</samp>
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">   print(annotate * 30)</samp>
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W5Regular_11">   print(annotate * 30)</samp>
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">   print_text()</samp>
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W5Regular_11">   print_text()</samp>
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">   print(annotate * 30)</samp>
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W5Regular_11">   print(annotate * 30)</samp>
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">pretty_print()</samp>
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W5Regular_11">pretty_print()</samp>
- en: 'Now the output looks like this:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 现在输出看起来是这样的：
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">++++++++++++++++++++++++++++++</samp>
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W5Regular_11">++++++++++++++++++++++++++++++</samp>
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">Hello world!</samp>
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W5Regular_11">Hello world!</samp>
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">++++++++++++++++++++++++++++++</samp>
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W5Regular_11">++++++++++++++++++++++++++++++</samp>
- en: The outer function <samp class="SANS_TheSansMonoCd_W5Regular_11">pretty_print()</samp>
    calls the inner function <samp class="SANS_TheSansMonoCd_W5Regular_11">print_text()</samp>
    and embellishes the result with 30 plus (<samp class="SANS_TheSansMonoCd_W5Regular_11">+</samp>)
    symbols before and after the output of the inner function <samp class="SANS_TheSansMonoCd_W5Regular_11">print_text()</samp>.
    Essentially, you *wrap* the result of the inner function and enrich it with additional
    functionality.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 外部函数<samp class="SANS_TheSansMonoCd_W5Regular_11">pretty_print()</samp>调用内部函数<samp
    class="SANS_TheSansMonoCd_W5Regular_11">print_text()</samp>，并在内部函数输出的前后添加30个加号（<samp
    class="SANS_TheSansMonoCd_W5Regular_11">+</samp>）符号，从而装饰了结果。本质上，你是*包装*了内部函数的结果，并用额外的功能来丰富它。
- en: 'Decorator functions allow you to generalize code like this. For instance, you
    may want to pass an arbitrary inner function into your <samp class="SANS_TheSansMonoCd_W5Regular_11">pretty_print()</samp>
    function so that you can use it on any Python function. Here we create a decorator
    function, but note that for the purposes of showing how it works, we’re creating
    this function the long way. In a moment we’ll look at the shorter way Python provides
    to do the same thing. Here’s the long version:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 装饰器函数允许你像这样将代码进行通用化。例如，你可能希望将一个任意的内部函数传入到你的<samp class="SANS_TheSansMonoCd_W5Regular_11">pretty_print()</samp>函数中，这样你就可以将它应用于任何Python函数。这里我们创建了一个装饰器函数，但请注意，为了展示它是如何工作的，我们使用了较长的方式来创建这个函数。稍后我们将看看Python提供的更简短的方式来实现相同的功能。以下是较长的版本：
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">def pretty_print_decorator(f):</samp>
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W5Regular_11">def pretty_print_decorator(f):</samp>
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">   annotate =</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">'+'</samp>
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W5Regular_11">   annotate =</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">'+'</samp>
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">   def pretty_print():</samp>
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W5Regular_11">   def pretty_print():</samp>
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">      print(annotate * 50)</samp>
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W5Regular_11">      print(annotate * 50)</samp>
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">      f()</samp>
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W5Regular_11">      f()</samp>
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">      print(annotate * 50)</samp>
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W5Regular_11">      print(annotate * 50)</samp>
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">   return pretty_print</samp>
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W5Regular_11">   return pretty_print</samp>
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">def print_text():</samp>
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W5Regular_11">def print_text():</samp>
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">   print("Hello world!")</samp>
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W5Regular_11">   print("Hello world!")</samp>
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">def print_text_2():</samp>
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W5Regular_11">def print_text_2():</samp>
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">   print("Hello universe!")</samp>
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W5Regular_11">   print("Hello universe!")</samp>
- en: 'When we use it like so:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们像这样使用它时：
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">pretty_print_decorator(print_text)()</samp>
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W5Regular_11">pretty_print_decorator(print_text)()</samp>
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">pretty_print_decorator(print_text_2)()</samp>
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W5Regular_11">pretty_print_decorator(print_text_2)()</samp>
- en: 'we’ll get output like this:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将得到如下的输出：
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">++++++++++++++++++++++++++++++++++++++++++++++++++</samp>
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W5Regular_11">++++++++++++++++++++++++++++++++++++++++++++++++++</samp>
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">Hello world!</samp>
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W5Regular_11">Hello world!</samp>
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">++++++++++++++++++++++++++++++++++++++++++++++++++</samp>
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W5Regular_11">++++++++++++++++++++++++++++++++++++++++++++++++++</samp>
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">++++++++++++++++++++++++++++++++++++++++++++++++++</samp>
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W5Regular_11">++++++++++++++++++++++++++++++++++++++++++++++++++</samp>
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">Hello universe!</samp>
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W5Regular_11">Hello universe!</samp>
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">++++++++++++++++++++++++++++++++++++++++++++++++++</samp>
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W5Regular_11">++++++++++++++++++++++++++++++++++++++++++++++++++</samp>
- en: Here the decorator function takes a function as input and returns another function
    that modifies the behavior by wrapping its output in <samp class="SANS_TheSansMonoCd_W5Regular_11">+</samp>
    symbols. You can pass any function that prints any output and create a similar
    function that additionally wraps the output in a series of <samp class="SANS_TheSansMonoCd_W5Regular_11">+</samp>
    symbols.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，装饰器函数接收一个函数作为输入，并返回另一个函数，通过将输出包裹在<samp class="SANS_TheSansMonoCd_W5Regular_11">+</samp>符号中来修改行为。你可以传递任何打印任何输出的函数，并创建一个类似的函数，额外将输出包裹在一系列的<samp
    class="SANS_TheSansMonoCd_W5Regular_11">+</samp>符号中。
- en: This simple decorator function takes in a function object and applies some output
    modifications, but decorator functions can do all kinds of complicated things,
    such as analyze output, apply some extra logic, or filter out some undesired messages.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 这个简单的装饰器函数接收一个函数对象并应用一些输出修改，但装饰器函数可以做各种复杂的事情，比如分析输出、应用一些额外的逻辑或过滤掉一些不需要的消息。
- en: 'This is an unrealistically complicated way to build a decorator function. Because
    the pattern is so common, Python provides a convenient method that accomplishes
    the same thing with less code: you add one line of code in front of the function
    to be decorated. This line consists of the at symbol (<samp class="SANS_TheSansMonoCd_W5Regular_11">@</samp>),
    followed by the name of a decorator function you defined earlier. Here we define
    the <samp class="SANS_TheSansMonoCd_W5Regular_11">pretty_print_decorator(f)</samp>
    function, then apply it when we define the two print functions:'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 这是构建装饰器函数的一种不切实际的复杂方式。因为这种模式太常见，Python 提供了一种方便的方法，可以用更少的代码实现相同的功能：你只需要在要装饰的函数前添加一行代码。这一行由@符号(<samp
    class="SANS_TheSansMonoCd_W5Regular_11">@</samp>)开头，后面跟着你之前定义的装饰器函数的名称。在这里，我们定义了<sup
    class="SANS_TheSansMonoCd_W5Regular_11">pretty_print_decorator(f)</sup>函数，然后在定义两个打印函数时应用它：
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">def pretty_print_decorator(f):</samp>
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W5Regular_11">def pretty_print_decorator(f):</samp>
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">   annotate = '+'</samp>
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W5Regular_11">   annotate = '+'</samp>
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">   def pretty_print():</samp>
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W5Regular_11">   def pretty_print():</samp>
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">      print(annotate * 50)</samp>
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W5Regular_11">      print(annotate * 50)</samp>
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">      f()</samp>
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W5Regular_11">      f()</samp>
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">      print(annotate * 50)</samp>
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W5Regular_11">      print(annotate * 50)</samp>
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">   return pretty_print</samp>
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W5Regular_11">   return pretty_print</samp>
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">@pretty_print_decorator</samp>
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W5Regular_11">@pretty_print_decorator</samp>
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">def print_text():</samp>
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W5Regular_11">def print_text():</samp>
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">   print("Hello world!")</samp>
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W5Regular_11">   print("Hello world!")</samp>
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">@pretty_print_decorator</samp>
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W5Regular_11">@pretty_print_decorator</samp>
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">def print_text_2():</samp>
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W5Regular_11">def print_text_2():</samp>
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">   print("Hello universe!")</samp>
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W5Regular_11">   print("Hello universe!")</samp>
- en: 'We call our two defined functions like so:'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 我们以这种方式调用我们定义的两个函数：
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">print_text()</samp>
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W5Regular_11">print_text()</samp>
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">print_text_2()</samp>
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W5Regular_11">print_text_2()</samp>
- en: 'And we should get output like this:'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 我们应该得到像这样的输出：
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">++++++++++++++++++++++++++++++++++++++++++++++++++</samp>
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W5Regular_11">++++++++++++++++++++++++++++++++++++++++++++++++++</samp>
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">Hello world!</samp>
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W5Regular_11">Hello world!</samp>
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">++++++++++++++++++++++++++++++++++++++++++++++++++</samp>
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W5Regular_11">++++++++++++++++++++++++++++++++++++++++++++++++++</samp>
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">++++++++++++++++++++++++++++++++++++++++++++++++++</samp>
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W5Regular_11">++++++++++++++++++++++++++++++++++++++++++++++++++</samp>
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">Hello universe!</samp>
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W5Regular_11">你好，宇宙！</samp>
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">++++++++++++++++++++++++++++++++++++++++++++++++++</samp>
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W5Regular_11">++++++++++++++++++++++++++++++++++++++++++++++++++</samp>
- en: You can see that the output is exactly the same as before. But this time, rather
    than calling the decorator function <samp class="SANS_TheSansMonoCd_W5Regular_11">pretty_print_factory</samp>
    explicitly, such as in <samp class="SANS_TheSansMonoCd_W5Regular_11">pretty_print_decorator(print_text)</samp>
    to decorate the existing function <samp class="SANS_TheSansMonoCd_W5Regular_11">print_text</samp>,
    we modify the behavior of <samp class="SANS_TheSansMonoCd_W5Regular_11">print_text()</samp>
    directly using the decorator function with the <samp class="SANS_TheSansMonoCd_W5Regular_11">@</samp>
    prefix. Each time we then call the decorated function, it is automatically passed
    through the decorator function. This way, we can stack arbitrarily complicated
    function hierarchies, each adding a new layer of complexity by decorating the
    output of another function.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以看到输出与之前完全相同。但这一次，我们不是显式地调用装饰器函数 <samp class="SANS_TheSansMonoCd_W5Regular_11">pretty_print_factory</samp>，例如在
    <samp class="SANS_TheSansMonoCd_W5Regular_11">pretty_print_decorator(print_text)</samp>
    中装饰现有函数 <samp class="SANS_TheSansMonoCd_W5Regular_11">print_text</samp>，而是直接使用带有
    <samp class="SANS_TheSansMonoCd_W5Regular_11">@</samp> 前缀的装饰器函数修改 <samp class="SANS_TheSansMonoCd_W5Regular_11">print_text()</samp>
    的行为。然后，每次调用装饰后的函数时，它都会自动通过装饰器函数。通过这种方式，我们可以堆叠任意复杂的函数层次结构，每一层都通过装饰另一个函数的输出添加新的复杂性。
- en: Decorator functions are at the heart of the Dash framework. Dash provides advanced
    functionality that you can access by applying a decorator function that is already
    defined by Dash to any of your functions with the <samp class="SANS_TheSansMonoCd_W5Regular_11">@</samp>
    annotation. Dash refers to these decorator functions as *callback decorators*.
    You’ll see plenty of these examples in the dashboard applications discussed in
    this book.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 装饰器函数是Dash框架的核心。Dash提供了高级功能，您可以通过将Dash已定义的装饰器函数应用于任何函数（使用注解 <samp class="SANS_TheSansMonoCd_W5Regular_11">@</samp>）来访问这些功能。Dash将这些装饰器函数称为*回调装饰器*。在本书讨论的仪表板应用程序中，您会看到很多这样的例子。
- en: <samp class="SANS_Futura_Std_Bold_B_11">Summary</samp>
  id: totrans-294
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">摘要</samp>
- en: This was a very quick overview of some of the Python concepts that are most
    relevant to creating apps with Dash. If you found this difficult to follow, we
    recommend checking out the “Python Basics” appendix before you begin building
    apps.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一些与使用Dash创建应用程序最相关的Python概念的快速概述。如果您觉得这些内容难以理解，我们建议在开始构建应用程序之前查阅“Python基础”附录。
- en: But before we start creating dashboard applications, let’s dive into the PyCharm
    framework we recommend you use for the book. If you’re already a PyCharm expert
    or you have a different preferred programming environment, feel free to skip to
    [Chapter 3](chapter3.xhtml).
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 但在我们开始创建仪表板应用程序之前，让我们先深入了解我们推荐您使用的PyCharm框架。如果您已经是PyCharm专家或者您有其他喜欢的编程环境，请随意跳转到[第三章](chapter3.xhtml)。
