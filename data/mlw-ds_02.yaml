- en: '**2**'
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '**2**'
- en: '**BEYOND BASIC STATIC ANALYSIS: X86 DISASSEMBLY**'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: '**超越基础静态分析：X86 反汇编**'
- en: '![image](../images/common01.jpg)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/common01.jpg)'
- en: To thoroughly understand a malicious program, we often need to go beyond basic
    static analysis of its sections, strings, imports, and images. This involves reverse
    engineering a program’s assembly code. Indeed, disassembly and reverse engineering
    lie at the heart of deep static analysis of malware samples.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 为了彻底理解一个恶意程序，我们常常需要超越对其各个部分、字符串、导入项和图像的基础静态分析。这涉及到对程序汇编代码的逆向工程。事实上，反汇编和逆向工程是深入静态分析恶意软件样本的核心所在。
- en: Because reverse engineering is an art, technical craft, and science, a thorough
    exploration is beyond the scope of this chapter. My goal here is to introduce
    you to reverse engineering so that you can apply it to malware data science. Understanding
    this methodology is essential for successfully applying machine learning and data
    analysis to malware.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 由于逆向工程既是一种艺术，也是一项技术工艺和科学，彻底的探索超出了本章的范围。我的目标是向你介绍逆向工程，以便你可以将其应用于恶意软件数据科学。理解这一方法论对于成功将机器学习和数据分析应用于恶意软件至关重要。
- en: In this chapter I start with the concepts you’ll need to understand x86 disassembly.
    Later in the chapter I show how malware authors attempt to bypass disassembly
    and discuss ways to mitigate these anti-analysis and anti-detection maneuvers.
    But first, let’s review some common disassembly methods as well as the basics
    of x86 assembly language.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我将从你需要理解 x86 反汇编的概念开始。接下来，我会展示恶意软件作者如何尝试绕过反汇编，并讨论如何减轻这些反分析和反检测手段的影响。但首先，让我们回顾一些常见的反汇编方法以及
    x86 汇编语言的基础知识。
- en: '**Disassembly Methods**'
  id: totrans-6
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**反汇编方法**'
- en: '*Disassembly* is the process by which we translate malware’s binary code into
    valid x86 assembly language. Malware authors generally write malware programs
    in a high-level language like C or C++ and then use a compiler to compile the
    source code into x86 binary code. Assembly language is the human-readable representation
    of this binary code. Therefore, disassembling a malware program into assembly
    language is necessary to understand how it behaves at its core.'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: '*反汇编*是将恶意软件的二进制代码转换为有效的 x86 汇编语言的过程。恶意软件作者通常使用像 C 或 C++ 这样的高级语言编写恶意程序，然后使用编译器将源代码编译成
    x86 二进制代码。汇编语言是这种二进制代码的人类可读表示。因此，将恶意程序反汇编成汇编语言是理解其核心行为的必要步骤。'
- en: Unfortunately, disassembly is no easy feat because malware authors regularly
    employ tricks to thwart would-be reverse engineers. In fact, perfect disassembly
    in the face of deliberate obfuscation is an unsolved problem in computer science.
    Currently, only approximate, error-prone methods exist for disassembling such
    programs.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，反汇编并不是一件简单的事，因为恶意软件作者经常使用各种技巧来阻挠逆向工程师。事实上，在故意混淆的情况下，完美的反汇编仍然是计算机科学中的一个未解之谜。目前，针对这类程序的反汇编方法仅限于近似的、易出错的手段。
- en: For example, consider the case of *self-modifying code*, or binary code that
    modifies itself as it executes. The only way to disassemble this code properly
    is to understand the program logic by which the code modifies itself, but that
    can be exceedingly complex.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，考虑*自我修改代码*的情况，即在执行过程中修改自身的二进制代码。正确地反汇编这种代码的唯一方法是理解代码修改自身的程序逻辑，但这可能会异常复杂。
- en: Because perfect disassembly is currently impossible, we must use imperfect methods
    to accomplish this task. The method we’ll use is *linear disassembly*, which involves
    identifying the contiguous sequence of bytes in the Portable Executable (PE) file
    that corresponds to its x86 program code and then decoding these bytes. The key
    limitation of this approach is that it ignores subtleties about how instructions
    are decoded by the CPU in the course of program execution. Also, it doesn’t account
    for the various obfuscations malware authors sometimes use to make their programs
    harder to analyze.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 由于完美的反汇编目前无法实现，我们必须使用不完美的方法来完成这项任务。我们将使用的方法是 *线性反汇编*，它涉及识别可移植执行文件（PE 文件）中与其
    x86 程序代码对应的连续字节序列，然后对这些字节进行解码。这种方法的关键局限性在于，它忽视了在程序执行过程中 CPU 如何解码指令的细微差别。此外，它也没有考虑恶意软件作者有时使用的各种混淆技术，这些技术使得程序更难以分析。
- en: The other methods of reverse engineering, which we won’t cover here, are the
    more complex disassembly methods used by industrial-grade disassemblers such as
    IDA Pro. These more advanced methods actually simulate or reason about program
    execution to discover which assembly instructions a program might reach as a result
    of a series of conditional branches.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 其他逆向工程方法（我们在这里不讨论）是工业级反汇编器（如IDA Pro）使用的更复杂的反汇编方法。这些更先进的方法实际上模拟或推理程序执行，以发现程序可能由于一系列条件分支而达到的汇编指令。
- en: Although this type of disassembly can be more accurate than linear disassembly,
    it’s far more CPU intensive than linear disassembly methods, making it less suitable
    for data science purposes where the focus is on disassembling thousands or even
    millions of programs.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管这种反汇编方法比线性反汇编方法更准确，但它比线性反汇编方法更加占用CPU资源，因此在数据科学应用中不太适用，因为数据科学的重点是反汇编成千上万甚至百万个程序。
- en: Before you can begin analysis using linear disassembly, however, you’ll need
    to review the basic components of assembly language.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在开始使用线性反汇编进行分析之前，您需要先回顾汇编语言的基本组成部分。
- en: '**Basics of x86 Assembly Language**'
  id: totrans-14
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**x86汇编语言基础**'
- en: Assembly language is the lowest-level human-readable programming language for
    a given architecture, and it maps closely to the binary instruction format of
    a particular CPU architecture. A line of assembly language is almost always equivalent
    to a single CPU instruction. Because assembly is so low level, you can often retrieve
    it easily from a malware binary by using the right tools.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 汇编语言是针对特定架构的最低级别人类可读编程语言，它与特定CPU架构的二进制指令格式紧密对应。每一行汇编语言几乎总是等同于一条CPU指令。由于汇编语言的低级性质，通常可以通过使用正确的工具轻松从恶意软件的二进制文件中提取出它。
- en: Gaining basic proficiency in reading disassembled malware x86 code is easier
    than you might think. This is because most malware assembly code spends most of
    its time calling into the operating system by way of the Windows operating system’s
    *dynamic-link libraries (DLLs)*, which are loaded into program memory at runtime.
    Malware programs use DLLs to do most of the real work, such as modifying the system
    registry, moving and copying files, making network connections and communicating
    via network protocols, and so on. Therefore, following malware assembly code often
    involves understanding the ways in which function calls are made from assembly
    and understanding what various DLL calls do. Of course, things can get much more
    complicated, but knowing this much can reveal a lot about the malware.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 获得基本的反汇编恶意软件x86代码阅读能力比你想象的要容易。这是因为大多数恶意软件汇编代码大多数时间通过Windows操作系统的*动态链接库（DLLs）*调用操作系统，而DLL会在运行时加载到程序内存中。恶意软件程序使用DLL完成大部分实际工作，例如修改系统注册表、移动和复制文件、建立网络连接以及通过网络协议进行通信等。因此，跟踪恶意软件汇编代码通常需要理解从汇编语言中如何进行函数调用，并理解各种DLL调用的作用。当然，事情可能变得更加复杂，但知道这些基本情况可以揭示恶意软件的很多信息。
- en: In the following sections I introduce some important assembly language concepts.
    I also explain some abstract concepts like control flow and control flow graphs.
    Finally, we disassemble the *ircbot.exe* program and explore how its assembly
    and control flow can give us insight into its purpose.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的章节中，我将介绍一些重要的汇编语言概念。我还将解释一些抽象的概念，如控制流和控制流图。最后，我们将反汇编*ircbot.exe*程序，并探索其汇编和控制流如何为我们提供关于其目的的洞察。
- en: 'There are two major dialects of x86 assembly: Intel and AT&T. In this book
    I use Intel syntax, which can be obtained from all major disassemblers and is
    the syntax used in the official Intel documentation of the x86 CPU.'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: x86汇编语言有两种主要的方言：Intel和AT&T。在本书中，我使用的是Intel语法，它可以从所有主要的反汇编器中获得，并且是x86 CPU官方文档中使用的语法。
- en: Let’s start by taking a look at CPU registers.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从查看CPU寄存器开始。
- en: '***CPU Registers***'
  id: totrans-20
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***CPU寄存器***'
- en: '*Registers* are small data storage units on which x86 CPUs perform computations.
    Because registers are located on the CPU itself, register access is orders of
    magnitude faster than memory access. This is why core computational operations,
    such as arithmetic and condition testing instructions, all target registers. It’s
    also why the CPU uses registers to store information about the status of running
    programs. Although many registers are available to experienced x86 assembly programmers,
    we’ll just focus on a few important ones here.'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: '*寄存器*是x86 CPU上执行计算的小型数据存储单元。由于寄存器位于CPU内部，因此寄存器访问比内存访问快得多。这也是为什么核心计算操作，如算术运算和条件测试指令，都针对寄存器的原因。寄存器也是CPU用来存储关于正在运行的程序状态的信息的地方。尽管许多寄存器对有经验的x86汇编程序员来说是可用的，但我们这里只关注其中几个重要的寄存器。'
- en: '**General-Purpose Registers**'
  id: totrans-22
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**通用寄存器**'
- en: General-purpose registers are like scratch space for assembly programmers. On
    a 32-bit system, each of these registers contains 32, 16, or 8 bits of space against
    which we can perform arithmetic operations, bitwise operations, byte order–swapping
    operations, and more.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 通用寄存器对于汇编程序员来说就像是临时存储空间。在32位系统上，每个寄存器都包含32位、16位或8位的空间，我们可以在其上执行算术运算、按位运算、字节顺序交换等操作。
- en: In common computational workflows, programs move data into registers from memory
    or from external hardware devices, perform some operations on this data, and then
    move the data back out to memory for storage. For example, to sort a long list,
    a program typically pulls list items in from an array in memory, compares them
    in the registers, and then writes the comparison results back out to memory.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 在常见的计算工作流程中，程序将数据从内存或外部硬件设备加载到寄存器中，对这些数据进行某些操作，然后将数据返回内存进行存储。例如，排序一个长列表时，程序通常会从内存中的数组中提取列表项，在寄存器中进行比较，然后将比较结果写回内存。
- en: To understand some of the nuances of the general-purpose register model in the
    Intel 32-bit architecture, take a look at [Figure 2-1](ch02.xhtml#ch02fig1).
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 要理解Intel 32位架构中通用寄存器模型的一些细节，看看[图2-1](ch02.xhtml#ch02fig1)。
- en: '![image](../images/f0014-01.jpg)'
  id: totrans-26
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f0014-01.jpg)'
- en: '*Figure 2-1: Registers in the x86 architecture*'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: '*图2-1：x86架构中的寄存器*'
- en: 'The vertical axis shows the layout of the general-purpose registers, and the
    horizontal axis shows how EAX, EBX, ECX, and EDX are subdivided. EAX, EBX, ECX,
    and EDX are 32-bit registers that have smaller, 16-bit registers inside them:
    AX, BX, CX, and DX. As you can see in the figure, these 16-bit registers can be
    subdivided into upper and lower 8-bit registers: AH, AL, BH, BL, CH, CL, DH, and
    DL. Although it’s sometimes useful to address the subdivisions in EAX, EBX, ECX,
    and EDX, you’ll mostly see direct references to EAX, EBX, ECX, and EDX.'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 垂直轴显示了通用寄存器的布局，水平轴显示了EAX、EBX、ECX和EDX的细分情况。EAX、EBX、ECX和EDX是32位寄存器，它们内部包含更小的16位寄存器：AX、BX、CX和DX。正如图中所示，这些16位寄存器可以进一步细分为上下8位寄存器：AH、AL、BH、BL、CH、CL、DH和DL。尽管有时在EAX、EBX、ECX和EDX中的细分非常有用，但你通常会看到直接引用EAX、EBX、ECX和EDX。
- en: '**Stack and Control Flow Registers**'
  id: totrans-29
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**栈和控制流寄存器**'
- en: The stack management registers store critical information about the *program
    stack*, which is responsible for storing local variables for functions, arguments
    passed into functions, and control information relating to the program control
    flow. Let’s go over some of these registers.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 栈管理寄存器存储着关于*程序栈*的关键信息，程序栈负责存储函数的局部变量、传递给函数的参数以及与程序控制流相关的控制信息。我们来逐一了解一些这些寄存器。
- en: In simple terms, the ESP register points to the top of the stack for the currently
    executing function, whereas the EBP register points to the bottom of the stack
    for the currently executing function. This is crucial information for modern programs,
    because it means that by referencing data relative to the stack rather than using
    its absolute address, procedural and object-oriented code can access local variables
    more gracefully and efficiently.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 简单来说，ESP寄存器指向当前执行函数的栈顶，而EBP寄存器指向当前执行函数的栈底。这对于现代程序至关重要，因为这意味着通过引用相对于栈的数据，而不是使用它的绝对地址，过程式和面向对象代码可以更优雅、高效地访问局部变量。
- en: Although you won’t see direct references to the EIP register in x86 assembly
    code, it’s important in security analysis, particularly in the context of vulnerability
    research and buffer-overflow exploit development. This is because EIP contains
    the memory address of the currently executing instruction. Attackers can use buffer-overflow
    exploits to corrupt the value of the EIP register indirectly and take control
    of program execution.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管在 x86 汇编代码中你不会看到对 EIP 寄存器的直接引用，但它在安全分析中非常重要，尤其是在漏洞研究和缓冲区溢出利用开发的上下文中。这是因为 EIP
    包含当前执行指令的内存地址。攻击者可以利用缓冲区溢出漏洞间接破坏 EIP 寄存器的值，并控制程序的执行。
- en: In addition to its role in exploitation, EIP is also important in the analysis
    of malicious code deployed by malware. Using a debugger we can inspect EIP’s value
    at any moment, which helps us understand what code malware is executing at any
    particular time.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 除了在利用中的作用外，EIP 在恶意代码分析中也非常重要。使用调试器，我们可以在任何时候检查 EIP 的值，这帮助我们理解恶意软件在特定时间执行的代码。
- en: EFLAGS is a status register that contains CPU *flags*, which are bits that store
    status information about the state of the currently executing program. The EFLAGS
    register is central to the process of making *conditional branches*, or changes
    in execution flow resulting from the outcome of if/then-style program logic, within
    x86 programs. Specifically, whenever an x86 assembly program checks whether some
    value is greater or less than zero and then jumps to a function based on the outcome
    of this test, the EFLAGS register plays an enabling role, as described in more
    detail in “[Basic Blocks and Control Flow Graphs](ch02.xhtml#lev30)” on [page
    19](ch02.xhtml#page_19).
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: EFLAGS 是一个状态寄存器，包含 CPU *标志*，这些标志是存储当前执行程序状态信息的位。EFLAGS 寄存器在执行 x86 程序中的 *条件跳转*
    中起着至关重要的作用，条件跳转是根据 if/then 风格的程序逻辑的结果改变执行流的过程。具体来说，每当 x86 汇编程序检查某个值是否大于或小于零，然后根据此测试的结果跳转到一个函数时，EFLAGS
    寄存器就发挥了作用，详细描述见 “[基本块与控制流图](ch02.xhtml#lev30)” 第 [19 页](ch02.xhtml#page_19)。
- en: '***Arithmetic Instructions***'
  id: totrans-35
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***算术指令***'
- en: '*Instructions* operate on general-purpose registers. You can perform simple
    computations with the general-purpose registers using arithmetic instructions.
    For example, `add`, `sub`, `inc`, `dec`, and `mul` are examples of arithmetic
    instructions you’ll encounter frequently in malware reverse engineering. [Table
    2-1](ch02.xhtml#ch02tab1) lists some examples of basic instructions and their
    syntax.'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: '*指令* 作用于通用寄存器。你可以通过算术指令对通用寄存器进行简单计算。例如，`add`、`sub`、`inc`、`dec` 和 `mul` 都是你在恶意软件逆向工程中常见的算术指令。
    [表 2-1](ch02.xhtml#ch02tab1) 列出了基本指令及其语法的一些示例。'
- en: '**Table 2-1:** Arithmetic Instructions'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: '**表 2-1：** 算术指令'
- en: '| **Instructions** | **Description** |'
  id: totrans-38
  prefs: []
  type: TYPE_TB
  zh: '| **指令** | **描述** |'
- en: '| --- | --- |'
  id: totrans-39
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `add ebx, 100` | Adds 100 to the value in EBX and then stores the result
    in EBX |'
  id: totrans-40
  prefs: []
  type: TYPE_TB
  zh: '| `add ebx, 100` | 将 100 加到 EBX 中的值，并将结果存储回 EBX |'
- en: '| `sub ebx, 100` | Subtracts 100 from the value in EBX and then stores the
    result in EBX |'
  id: totrans-41
  prefs: []
  type: TYPE_TB
  zh: '| `sub ebx, 100` | 从 EBX 中的值减去 100，并将结果存储回 EBX |'
- en: '| `inc ah` | Increments the value in AH by 1 |'
  id: totrans-42
  prefs: []
  type: TYPE_TB
  zh: '| `inc ah` | 将 AH 中的值加 1 |'
- en: '| `dec al` | Decrements the value in AL by 1 |'
  id: totrans-43
  prefs: []
  type: TYPE_TB
  zh: '| `dec al` | 将 AL 中的值减 1 |'
- en: The `add` instruction adds two integers and stores the result in the first operand
    specified, whether this is a memory location or a register according to the following
    syntax. Keep in mind only one argument can be a memory location. The `sub` instruction
    is similar to `add`, except it subtracts integers. The `inc` instruction increments
    a register or memory location’s integer value, whereas `dec` decrements a register
    or memory location’s integer value.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: '`add` 指令将两个整数相加，并将结果存储在第一个操作数指定的位置，无论该位置是内存位置还是寄存器，具体语法如下。请记住，只有一个参数可以是内存位置。`sub`
    指令与 `add` 类似，只是它进行整数的减法运算。`inc` 指令将寄存器或内存位置的整数值递增，而 `dec` 指令则递减寄存器或内存位置的整数值。'
- en: '***Data Movement Instructions***'
  id: totrans-45
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***数据移动指令***'
- en: The x86 processor provides a robust set of instructions for moving data between
    registers and memory. These instructions provide the underlying mechanisms that
    allow us to manipulate data. The staple memory movement instruction is the `mov`
    instruction. [Table 2-2](ch02.xhtml#ch02tab2) shows how you can use the `mov`
    instruction to move data around.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: x86 处理器提供了一组强大的指令，用于在寄存器和内存之间移动数据。这些指令提供了允许我们操作数据的基础机制。基础的内存移动指令是 `mov` 指令。[表
    2-2](ch02.xhtml#ch02tab2) 展示了如何使用 `mov` 指令来移动数据。
- en: '**Table 2-2:** Data Movement Instructions'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: '**表 2-2：** 数据移动指令'
- en: '| **Instructions** | **Description** |'
  id: totrans-48
  prefs: []
  type: TYPE_TB
  zh: '| **指令** | **描述** |'
- en: '| --- | --- |'
  id: totrans-49
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `mov ebx,eax` | Moves the value in register EAX into register EBX |'
  id: totrans-50
  prefs: []
  type: TYPE_TB
  zh: '| `mov ebx,eax` | 将 EAX 寄存器中的值移动到 EBX 寄存器 |'
- en: '| `mov eax, [0x12345678]` | Moves the data at memory address 0x12345678 into
    the EAX register |'
  id: totrans-51
  prefs: []
  type: TYPE_TB
  zh: '| `mov eax, [0x12345678]` | 将内存地址 0x12345678 处的数据移动到 EAX 寄存器 |'
- en: '| `mov edx, 1` | Moves the value 1 into the register EDX |'
  id: totrans-52
  prefs: []
  type: TYPE_TB
  zh: '| `mov edx, 1` | 将值 1 移动到 EDX 寄存器 |'
- en: '| `mov [0x12345678], eax` | Moves the value in EAX into the memory location
    0x12345678 |'
  id: totrans-53
  prefs: []
  type: TYPE_TB
  zh: '| `mov [0x12345678], eax` | 将 EAX 中的值移动到内存位置 0x12345678 |'
- en: Related to the `mov` instruction, the `lea` instruction loads the absolute memory
    address specified into the register used for getting a pointer to a memory location.
    For example, `lea edx, [esp-4]` subtracts 4 from the value in ESP and loads the
    resulting value into EDX.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 与 `mov` 指令相关，`lea` 指令将指定的绝对内存地址加载到用于获取指针的寄存器中。例如，`lea edx, [esp-4]` 从 ESP 中的值减去
    4，并将结果值加载到 EDX 中。
- en: '**Stack Instructions**'
  id: totrans-55
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**堆栈指令**'
- en: The *stack* in x86 assembly is a data structure that allows you to push and
    pop values onto and off of it. This is similar to how you would add and remove
    plates on and off the top of a stack of plates.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 在 x86 汇编中，*堆栈* 是一种数据结构，允许你将值推入堆栈或从堆栈中弹出。这类似于你如何在一堆盘子上添加或移除盘子。
- en: Because control flow is often expressed through C-style function calls in x86
    assembly and because these function calls use the stack to pass arguments, allocate
    local variables, and remember what part of the program to return to after a function
    finishes executing, the stack and control flow need to be understood together.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 由于在 x86 汇编中，控制流通常通过 C 风格的函数调用来表示，而且这些函数调用使用堆栈来传递参数、分配局部变量并记住函数执行完毕后返回程序的哪一部分，因此堆栈和控制流需要一起理解。
- en: The `push` instruction pushes values onto the program stack when the programmer
    wants to save a register value onto the stack, and the `pop` instruction deletes
    values from the stack and places them into a designated register.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: '`push` 指令在程序员希望将寄存器值保存到堆栈时，将值推入程序堆栈，而 `pop` 指令则从堆栈中删除值并将其放入指定的寄存器。'
- en: 'The `push` instruction uses the following syntax to perform its operations:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: '`push` 指令使用以下语法执行操作：'
- en: '[PRE0]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: In this example, the program points the stack pointer (the register ESP) to
    a new memory address, thereby making room for the value (1), which is now stored
    at the top location on the stack. Then it copies the value from the argument to
    the memory location the CPU has just made room for on the top of the stack.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，程序将堆栈指针（寄存器 ESP）指向一个新的内存地址，从而为值（1）腾出空间，当前该值被存储在堆栈顶部的位置。然后，它将参数中的值复制到
    CPU 刚刚为堆栈顶部位置腾出的内存位置。
- en: 'Let’s contrast this with `pop`:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们与 `pop` 做对比：
- en: '[PRE1]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The program uses `pop` to pop the top value off the stack and move it into a
    specified register. In this example, `pop eax` pops the top value off the stack
    and moves it into `eax`.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 程序使用 `pop` 从堆栈中弹出顶部值，并将其移动到指定的寄存器。在这个例子中，`pop eax` 将堆栈顶部的值弹出，并将其移动到 `eax` 中。
- en: An unintuitive but important detail to understand about the x86 program stack
    is that it grows downward in memory, so that the highest value on the stack is
    actually stored at the lowest address in stack memory. This becomes very important
    to remember when you analyze assembly code that references data stored on the
    stack, as it can quickly get confusing unless you know the stack’s memory layout.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 关于 x86 程序堆栈，一个不直观但很重要的细节是，它在内存中向下增长，因此堆栈中的最高值实际上存储在堆栈内存中的最低地址。当你分析引用堆栈中存储数据的汇编代码时，这一点非常重要，因为如果不了解堆栈的内存布局，可能会很容易产生混淆。
- en: Because the x86 stack grows downward in memory, when the `push` instruction
    allocates space on the program stack for a new value, it decrements the value
    of ESP so that it points to a lower location in memory and then copies a value
    from the target register into that memory location, starting at the top address
    of the stack and growing up. Conversely, the `pop` instruction actually copies
    the top value off of the stack and then increments the value of ESP so it points
    to a higher memory location.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 x86 栈在内存中是向下生长的，当 `push` 指令为新值在程序栈上分配空间时，它会减少 ESP 的值，使其指向内存中较低的位置，然后将目标寄存器中的值复制到该内存位置，从栈顶地址开始向上增长。相反，`pop`
    指令实际上会将栈顶的值弹出，然后增加 ESP 的值，使其指向较高的内存位置。
- en: '**Control Flow Instructions**'
  id: totrans-67
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**控制流指令**'
- en: An x86 program’s *control flow* defines the network of possible instruction
    execution sequences a program may execute, depending on the data, device interactions,
    and other inputs the program might receive. Control flow instructions define a
    program’s control flow. They are more complicated than stack instructions but
    still quite intuitive. Because control flow is often expressed through C-style
    function calls in x86 assembly, the stack and control flow are closely related.
    They’re also related because these function calls use the stack to pass arguments,
    allocate local variables, and remember what part of the program to return to after
    a function finishes executing.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 一个 x86 程序的 *控制流* 定义了程序可能执行的指令序列网络，取决于程序可能接收到的数据、设备交互以及其他输入。控制流指令定义了程序的控制流。它们比栈指令复杂，但仍然非常直观。因为控制流通常通过
    C 风格的函数调用在 x86 汇编中表达，栈和控制流是紧密相关的。它们也有关联，因为这些函数调用使用栈来传递参数、分配局部变量，并记住函数执行完毕后程序应返回到哪个部分。
- en: The `call` and `ret` control flow instructions are the most important in terms
    of how programs call functions in x86 assembly and how programs return from functions
    after these functions are done executing.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: '`call` 和 `ret` 控制流指令是 x86 汇编中调用函数和返回函数后最重要的指令。'
- en: 'The `call` instruction calls a function. Think of this as a function you might
    write in a higher-level language like C to allow the program to return to the
    instruction after the `call` instruction is invoked and the function has finished
    executing. You can invoke the `call` instruction using the following syntax, where
    address denotes the memory location where the function’s code begins:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: '`call` 指令用于调用函数。可以将其理解为在 C 语言等高级语言中编写的一个函数，目的是让程序在 `call` 指令被调用且函数执行完毕后返回到
    `call` 指令之后的指令。你可以使用以下语法来调用 `call` 指令，其中地址表示函数代码开始的内存位置：'
- en: '[PRE2]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The `call` instruction does two things. First, it pushes the address of the
    instruction that will execute after the function call returns onto the top of
    the stack so that the program knows what address to return to after the called
    function finishes executing. Second, `call` replaces the current value of EIP
    with the value specified by the address operand. Then, the CPU begins execution
    at the new memory location pointed to by EIP.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: '`call` 指令完成了两件事情。首先，它将函数调用返回后将要执行的指令地址压入栈顶，这样程序就知道在被调用函数执行完毕后应该返回到哪个地址。其次，`call`
    用地址操作数指定的值替换当前的 EIP 值。然后，CPU 开始在 EIP 指向的新内存位置执行指令。'
- en: 'Just as `call` initiates a function call, the `ret` instruction completes it.
    You can use the `ret` instruction on its own and without any parameter, as shown
    here:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 就像 `call` 发起一个函数调用一样，`ret` 指令完成它。你可以单独使用 `ret` 指令，而不需要任何参数，如下所示：
- en: '[PRE3]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: When invoked, `ret` pops the top value off the stack, which we expect to be
    the saved program counter value (EIP) that the `call` instruction pushed onto
    the stack when the `call` instruction was invoked. Then it places the popped program
    counter value back into EIP and resumes execution.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 当被调用时，`ret` 指令从栈顶弹出一个值，我们预计这个值是 `call` 指令在调用时压入栈中的程序计数器值（EIP）。然后，它将弹出的程序计数器值放回
    EIP 中，并恢复执行。
- en: The `jmp` instruction is another important control flow construction, which
    operates more simply than `call`. Instead of worrying about saving EIP, `jmp`
    simply tells the CPU to move to the memory address specified as its parameter
    and begin execution there. For example, `jmp 0x12345678` tells the CPU to start
    executing the program code stored at memory location 0x12345678 on the next instruction.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: '`jmp`指令是另一种重要的控制流结构，其操作比`call`指令简单。`jmp`并不需要关心保存EIP，简单地告诉CPU跳转到指定的内存地址并从那里开始执行。例如，`jmp
    0x12345678`告诉CPU在下一条指令时，从内存地址0x12345678开始执行程序代码。'
- en: 'You may be wondering how you can make `jmp` and `call` instructions execute
    in a conditional way, such as “if the program has received a network packet, execute
    the following function.” The answer is that x86 assembly doesn’t have high-level
    constructs like if, then, else, else if, and so on. Instead, branching to an address
    within a program’s code typically requires two instructions: a `cmp` instruction,
    which checks the value in some register against some test value and stores the
    result of that test in the EFLAGS register, and a conditional branch instruction.'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会想知道如何使`jmp`和`call`指令以条件方式执行，例如“如果程序收到了网络数据包，则执行以下函数。”答案是，x86汇编语言没有像if、then、else、else
    if这样的高级构造。相反，程序跳转到某个地址通常需要两条指令：一条`cmp`指令，用于检查某个寄存器中的值与测试值的关系，并将测试结果存储在EFLAGS寄存器中；另一条是条件分支指令。
- en: Most conditional branch instructions start with a *j*, which allows the program
    to jump to a memory address, and are post-fixed with letters that stand for the
    condition being tested. For example, `jge` tells the program to jump if greater
    than or equal to. This means that the value in the register being tested must
    be greater than or equal to the test value.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数条件分支指令以*j*开头，允许程序跳转到某个内存地址，且后面附加了表示测试条件的字母。例如，`jge`表示如果大于或等于时跳转。这意味着，测试的寄存器中的值必须大于或等于测试值。
- en: 'The `cmp` instruction uses the following syntax:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: '`cmp`指令使用以下语法：'
- en: '[PRE4]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: As stated earlier, `cmp` compares the value in the specified general-purpose
    register with value and then stores the result of that comparison in the EFLAGS
    register.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，`cmp`将指定通用寄存器中的值与目标值进行比较，然后将比较结果存储在EFLAGS寄存器中。
- en: 'The various conditional `jmp` instructions are then invoked as follows:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 各种条件`jmp`指令的调用方式如下：
- en: '[PRE5]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'As you can see, we can prefix *j* to any number of conditional test instructions.
    For example, to jump only if the value tested is greater than or equal to the
    value in the register, use the following instruction:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，我们可以在任何条件测试指令前加上* j*。例如，要在测试值大于或等于寄存器中的值时跳转，可以使用以下指令：
- en: '[PRE6]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Note that unlike the case of the `call` and `ret` instructions, the `jmp` family
    of instructions never touches the program stack. In fact, in the case of the `jmp`
    family of instructions, the x86 program is responsible for tracking its own execution
    flow and potentially saving or deleting information about what addresses it has
    visited and where it should return to after a particular sequence of instructions
    has executed.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，与`call`和`ret`指令不同，`jmp`指令系列永远不会涉及程序栈。事实上，在`jmp`系列指令的情况下，x86程序负责跟踪自己的执行流，并可能保存或删除关于它已访问过哪些地址的信息，以及在执行完某些指令序列后应该返回到哪里。
- en: '**Basic Blocks and Control Flow Graphs**'
  id: totrans-87
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**基本块与控制流图**'
- en: Although x86 programs look sequential when we scroll through their code in a
    text editor, they actually have loops, conditional branches, and unconditional
    branches (control flow). All of these give each x86 program a *network* structure.
    Let’s use the simple toy assembly program in [Listing 2-1](ch02.xhtml#ch02list1)
    to see how this works.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管当我们在文本编辑器中滚动查看x86程序时，它们看起来是顺序执行的，但实际上它们包含循环、条件分支和无条件分支（控制流）。所有这些使得每个x86程序都有一个*网络*结构。让我们用[示例2-1](ch02.xhtml#ch02list1)中的简单汇编程序来看看这如何工作。
- en: '[PRE7]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '*Listing 2-1: Assembly program for understanding control flow graph*'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: '*示例2-1：用于理解控制流图的汇编程序*'
- en: As you can see, this program initializes a counter to the value 10, stored in
    register EAX ➊. Next, it does a loop in which the value in EAX is decremented
    by 1 ➋ on each iteration. Finally, once EAX has reached a value of 0 ➌, the program
    breaks out of the loop.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，程序首先将计数器初始化为值10，存储在寄存器EAX中➊。接下来，它执行一个循环，在每次迭代时将EAX中的值递减1➋。最后，当EAX的值降到0➌时，程序跳出循环。
- en: In the language of control flow graph analysis, we can think of these instructions
    as comprising three basic blocks. A *basic block* is a sequence of instructions
    that we know will always execute contiguously. In other words, a basic block always
    ends with either a branching instruction or an instruction that is the target
    of a branch, and it always begins with either the first instruction of the program,
    called the program’s *entry point*, or a branch target.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 在控制流图分析的语言中，我们可以认为这些指令由三个基本块组成。一个 *基本块* 是一个指令序列，我们知道它们总是会连续执行。换句话说，基本块总是以分支指令或作为分支目标的指令结束，并且总是以程序的第一个指令（称为程序的
    *入口点*）或分支目标开始。
- en: In [Listing 2-1](ch02.xhtml#ch02list1), you can see where the basic blocks of
    our simple program begin and end. The first basic block is composed of the instruction
    `mov eax, 10` under `setup:`. The second basic block is composed of lines beginning
    with `sub eax, 1` through `jne $loopstart` under `loopstart:`, and the third starts
    at `mov eax, 1` under `loopend:`. We can visualize the relationships between the
    basic blocks using the graph in [Figure 2-2](ch02.xhtml#ch02fig2). (We use the
    term *graph* synonymously with the term *network*; in computer science, these
    terms are interchangeable.)
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 在[列表 2-1](ch02.xhtml#ch02list1)中，你可以看到我们简单程序的基本块的开始和结束。第一个基本块由 `setup:` 下的指令
    `mov eax, 10` 组成。第二个基本块由 `loopstart:` 下从 `sub eax, 1` 到 `jne $loopstart` 的行组成，第三个基本块从
    `loopend:` 下的 `mov eax, 1` 开始。我们可以通过[图 2-2](ch02.xhtml#ch02fig2)中的图形来可视化基本块之间的关系。（我们使用术语
    *图* 和 *网络* 同义，在计算机科学中这两个术语可以互换使用。）
- en: '![image](../images/f0019-01.jpg)'
  id: totrans-94
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f0019-01.jpg)'
- en: '*Figure 2-2: A visualization of the control flow graph of our simple assembly
    program*'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 2-2：我们简单汇编程序的控制流图的可视化*'
- en: If one basic block can ever flow into another basic block, we connect it, as
    shown in [Figure 2-2](ch02.xhtml#ch02fig2). The figure shows that the `setup`
    basic block leads to the `loopstart` basic block, which repeats 10 times before
    it transitions to the `loopend` basic block. Real-world programs have control
    flow graphs such as these, but they’re much more complicated, with thousands of
    basic blocks and thousands of interconnections.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一个基本块可以流向另一个基本块，我们就将它们连接起来，如[图 2-2](ch02.xhtml#ch02fig2)所示。图中显示，`setup` 基本块通向
    `loopstart` 基本块，后者会重复 10 次，然后过渡到 `loopend` 基本块。现实世界中的程序有这样的控制流图，但它们要复杂得多，包含成千上万个基本块和成千上万个连接。
- en: '**Disassembling ircbot.exe Using pefile and capstone**'
  id: totrans-97
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**使用 pefile 和 capstone 反汇编 ircbot.exe**'
- en: 'Now that you have a good understanding of the basics of assembly language,
    let’s disassemble the first 100 bytes of *ircbot.exe*’s assembly code using linear
    disassembly. To do this, we’ll use the open source Python libraries `pefile` (introduced
    in [Chapter 1](ch01.xhtml#ch01)) and `capstone`, which is an open source disassembly
    library that can disassemble 32-bit x86 binary code. You can install both of these
    libraries with `pip` using the following commands:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经对汇编语言的基础有了很好的理解，让我们使用线性反汇编法来反汇编 *ircbot.exe* 的前 100 字节汇编代码。为此，我们将使用开源 Python
    库 `pefile`（在[第 1 章](ch01.xhtml#ch01)中介绍）和 `capstone`，这是一个开源反汇编库，能够反汇编 32 位 x86
    二进制代码。你可以使用以下命令通过 `pip` 安装这两个库：
- en: '[PRE8]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Once these two libraries are installed, we can leverage them to disassemble
    *ircbot.exe* using the code in [Listing 2-2](ch02.xhtml#ch02list2).
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦安装了这两个库，我们就可以利用它们使用[列表 2-2](ch02.xhtml#ch02list2)中的代码来反汇编 *ircbot.exe*。
- en: '[PRE9]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '*Listing 2-2: Disassembling* ircbot.exe'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 2-2：反汇编* ircbot.exe'
- en: 'This should produce the following output:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 这将产生以下输出：
- en: '[PRE10]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Don’t worry about understanding all of the instructions in the disassembly
    output: that would involve an understanding of assembly that goes beyond the scope
    of this book. However, you should feel comfortable with many of the instructions
    in the output and have some sense of what they do. For example, the malware pushes
    the value in register EBP onto the stack ➊, saving its value. Then it proceeds
    to move the value in ESP into EBP and pushes some numerical values onto the stack.
    The program moves some data in memory into the EAX register ➋, and it adds the
    value -0x5c to the value in the ESP register ➌. Finally, the program uses the
    `call` instruction to call a function stored at the memory address 0x496308 ➍.'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 不必担心理解反汇编输出中的所有指令：这需要对汇编语言有更深入的理解，超出了本书的范围。然而，你应该对输出中的许多指令感到熟悉，并对它们的作用有一些基本的了解。例如，恶意软件将寄存器EBP中的值压入栈中
    ➊，保存其值。接着，它将ESP中的值移动到EBP并将一些数值压入栈中。程序将内存中的一些数据移动到EAX寄存器中 ➋，并将值-0x5c加到ESP寄存器中的值上
    ➌。最后，程序使用`call`指令调用存储在内存地址0x496308的函数 ➍。
- en: Because this is not a book on reverse engineering, I won’t go into any more
    depth here about what the code means. What I’ve presented is a start to understanding
    how assembly language works. For more information on assembly language, I recommend
    the Intel programmer’s manual at *[http://www.intel.com/content/www/us/en/processors/architectures-software-developer-manuals.html](http://www.intel.com/content/www/us/en/processors/architectures-software-developer-manuals.html)*.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 因为这不是一本关于逆向工程的书，所以我不会在这里深入讲解代码的含义。我展示的内容是理解汇编语言运作的起点。如果你想了解更多关于汇编语言的信息，我推荐查看英特尔的程序员手册，链接为
    *[http://www.intel.com/content/www/us/en/processors/architectures-software-developer-manuals.html](http://www.intel.com/content/www/us/en/processors/architectures-software-developer-manuals.html)*。
- en: '**Factors That Limit Static Analysis**'
  id: totrans-107
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**限制静态分析的因素**'
- en: In this chapter and [Chapter 1](ch01.xhtml#ch01), you learned about a variety
    of ways in which static analysis techniques can be used to elucidate the purpose
    and methods of a newly discovered malicious binary. Unfortunately, static analysis
    has limitations that render it less useful in some circumstances. For example,
    malware authors can employ certain offensive tactics that are far easier to implement
    than to defend against. Let’s take a look at some of these offensive tactics and
    see how to defend against them.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章以及[第1章](ch01.xhtml#ch01)中，你学习了多种静态分析技术，可以用来阐明新发现的恶意二进制文件的目的和方法。不幸的是，静态分析存在一些局限性，使得在某些情况下其效果不佳。例如，恶意软件作者可以采用某些攻击策略，这些策略比防御它们要容易得多。让我们来看看这些攻击策略，并看看如何防御它们。
- en: '***Packing***'
  id: totrans-109
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***打包***'
- en: Malware *packing* is the process by which malware authors compress, encrypt,
    or otherwise mangle the bulk of their malicious program so that it appears inscrutable
    to malware analysts. When the malware is run, it unpacks itself and then begins
    execution. The obvious way around malware packing is to actually run the malware
    in a safe environment, a dynamic analysis technique I’ll cover in [Chapter 3](ch03.xhtml#ch03).
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 恶意软件的*打包*是恶意软件作者通过压缩、加密或其他方式对其恶意程序的主要部分进行处理，使其看起来对恶意软件分析师难以理解。当恶意软件运行时，它会自解包并开始执行。绕过恶意软件打包的显而易见方法是将恶意软件实际运行在一个安全环境中，这是我将在[第3章](ch03.xhtml#ch03)中介绍的动态分析技术。
- en: '**NOTE**'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*Software packing is also used by benign software installers for legitimate
    reasons. Benign software authors use packing to deliver their code because it
    allows them to compress program resources to reduce software installer download
    sizes. It also helps them thwart reverse engineering attempts by business competitors,
    and it provides a convenient way to bundle many program resources within a single
    installer file.*'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: '*软件打包也被无害的软件安装程序用于合法的目的。无害软件作者使用打包技术来交付他们的代码，因为这可以压缩程序资源，从而减少软件安装程序的下载大小。它还帮助他们抵御竞争对手的逆向工程尝试，并提供了一种方便的方式将多个程序资源打包成一个安装文件。*'
- en: '***Resource Obfuscation***'
  id: totrans-113
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***资源混淆***'
- en: Another anti-detection, anti-analysis technique malware authors use is *resource
    obfuscation*. They obfuscate the way program resources, such as strings and graphical
    images, are stored on disk, and then deobfuscate them at runtime so they can be
    used by the malicious program. For example, a simple obfuscation would be to add
    a value of 1 to all bytes in images and strings stored in the PE resources section
    and then subtract 1 from all of this data at runtime. Of course, any number of
    obfuscations are possible here, all of which make life difficult for malware analysts
    attempting to make sense of a malware binary using static analysis.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 恶意软件作者使用的另一种反检测、反分析技术是*资源混淆*。他们通过混淆程序资源（如字符串和图像）在磁盘上的存储方式，然后在运行时解混淆，使恶意程序能够使用这些资源。例如，一种简单的混淆方法是将存储在
    PE 资源部分中的所有图像和字符串字节值加 1，然后在运行时从这些数据中减去 1。当然，这里可以使用任何数量的混淆方法，所有这些都会使恶意软件分析师在进行静态分析时难以理解恶意软件的二进制文件。
- en: As with packing, one way around resource obfuscation is to just run the malware
    in a safe environment. When this is not an option, the only mitigation for resource
    obfuscation is to actually figure out the ways in which malware has obfuscated
    its resources and to manually deobfuscate them, which is what professional malware
    analysts often do.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 和打包一样，绕过资源混淆的一种方法是将恶意软件在安全环境中运行。如果这不是一个可行的选项，那么唯一的缓解方法就是实际找出恶意软件混淆资源的方式，并手动解混淆，这正是专业恶意软件分析师经常做的事。
- en: '***Anti-disassembly Techniques***'
  id: totrans-116
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***反反汇编技术***'
- en: A third group of anti-detection, anti-analysis techniques used by malware authors
    are *anti-disassembly* techniques. These techniques are designed to exploit the
    inherent limitations of state-of-the-art disassembly techniques to hide code from
    malware analysts or make malware analysts think that a block of code stored on
    disk contains different instructions than it actually does.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 恶意软件作者使用的第三类反检测、反分析技术是*反反汇编*技术。这些技术旨在利用最先进的反汇编技术的固有局限性，隐藏恶意软件代码或让恶意软件分析师误认为磁盘上存储的代码块包含与实际不同的指令。
- en: An example of an anti-disassembly technique involves branching to a memory location
    that the malware author’s disassemblers will interpret as a different instruction,
    essentially hiding the malware’s true instructions from reverse engineers. Anti-disassembly
    techniques have huge potential and there’s no perfect way to defend against them.
    In practice, the two main defenses against these techniques are to run malware
    samples in a dynamic environment and to manually figure out where anti-disassembly
    strategies manifest within a malware sample and how to bypass them.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 一种反反汇编技术的示例是跳转到一个内存位置，恶意软件作者的反汇编工具会将其解释为不同的指令，从而本质上隐藏了恶意软件的真实指令，避免了逆向工程师的分析。反反汇编技术具有巨大的潜力，目前还没有完美的防御方法。在实际操作中，对抗这些技术的两种主要防御手段是将恶意软件样本在动态环境中运行，以及手动找出恶意软件样本中反反汇编策略的表现形式，并绕过它们。
- en: '***Dynamically Downloaded Data***'
  id: totrans-119
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***动态下载的数据***'
- en: A final class of anti-analysis techniques malware authors use involves externally
    sourcing data and code. For example, a malware sample may load code dynamically
    from an external server at malware startup time. If this is the case, static analysis
    will be useless against such code. Similarly, malware may source decryption keys
    from external servers at startup time and then use these keys to decrypt data
    or code that will be used in the malware’s execution.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 恶意软件作者使用的最后一类反分析技术涉及外部获取数据和代码。例如，恶意软件样本可能会在启动时从外部服务器动态加载代码。如果是这种情况，静态分析将对这些代码毫无作用。类似地，恶意软件可能会在启动时从外部服务器获取解密密钥，然后使用这些密钥解密将在恶意软件执行过程中使用的数据或代码。
- en: Obviously, if the malware is using an industrial-strength encryption algorithm,
    static analysis will not be sufficient to recover the encrypted data and code.
    Such anti-analysis and anti-detection techniques are quite powerful, and the only
    way around them is to acquire the code, data, or private keys on the external
    servers by some means and then use them in one’s analysis of the malware in question.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，如果恶意软件使用了工业级加密算法，静态分析将无法恢复加密的数据和代码。此类反分析和反检测技术非常强大，唯一的应对方法是通过某种手段获取外部服务器上的代码、数据或私钥，然后在分析恶意软件时使用它们。
- en: '**Summary**'
  id: totrans-122
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**总结**'
- en: This chapter introduced x86 assembly code analysis and demonstrated how we can
    perform disassembly-based static analysis on *ircbot.exe* using open source Python
    tools. Although this is not meant to be a complete primer on x86 assembly, you
    should now feel comfortable enough that you have a starting place for figuring
    out what’s going on in a given malware assembly dump. Finally, you learned ways
    in which malware authors can defend against disassembly and other static analysis
    techniques, and how you can mitigate these anti-analysis and anti-detection strategies.
    In [Chapter 3](ch03.xhtml#ch03), you’ll learn to conduct dynamic malware analysis
    that makes up for many of the weaknesses of static malware analysis.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 本章介绍了x86汇编代码分析，并演示了如何使用开源Python工具对*ircbot.exe*进行基于反汇编的静态分析。虽然这不是一本完整的x86汇编入门书，但你应该已经足够熟悉，能够找到开始理解给定恶意软件汇编转储的方法。最后，你学习了恶意软件作者如何防御反汇编和其他静态分析技术，以及如何应对这些反分析和反检测策略。在[第3章](ch03.xhtml#ch03)中，你将学习如何进行动态恶意软件分析，以弥补静态恶意软件分析的诸多不足。
