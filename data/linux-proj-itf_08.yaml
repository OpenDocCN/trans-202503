- en: Chapter 8. Users and Groups
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第8章 用户与组
- en: Every user has a unique login name and an associated numeric user identifier
    (UID). Users can belong to one or more groups. Each group also has a unique name
    and a group identifier (GID).
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 每个用户都有一个唯一的登录名和一个关联的数字用户标识符（UID）。用户可以属于一个或多个组。每个组也有一个唯一的名称和一个组标识符（GID）。
- en: The primary purpose of user and group IDs is to determine ownership of various
    system resources and to control the permissions granted to processes accessing
    those resources. For example, each file belongs to a particular user and group,
    and each process has a number of user and group IDs that determine who owns the
    process and what permissions it has when accessing a file (see [Chapter 9](ch09.html
    "Chapter 9. Process Credentials") for details).
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 用户和组ID的主要目的是确定各种系统资源的所有权，并控制访问这些资源的进程所授予的权限。例如，每个文件属于一个特定的用户和组，每个进程都有一个或多个用户和组ID，这些ID决定了进程的所有者是谁，以及它在访问文件时拥有哪些权限（有关详细信息，请参见[第9章](ch09.html
    "第9章 进程凭证")）。
- en: In this chapter, we look at the system files that are used to define the users
    and groups on the system, and then describe the library functions used to retrieve
    information from these files. We conclude with a discussion of the *crypt()* function,
    which is used to encrypt and authenticate login passwords.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将介绍用于定义系统中用户和组的系统文件，然后描述用于从这些文件中检索信息的库函数。最后，我们将讨论用于加密和验证登录密码的*crypt()*函数。
- en: 'The Password File: `/etc/passwd`'
  id: totrans-4
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 密码文件：`/etc/passwd`
- en: 'The system *password file*, `/etc/passwd`, contains one line for each user
    account on the system. Each line is composed of seven fields separated by colons
    (`:`), as in the following example:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 系统的*密码文件*，`/etc/passwd`，包含系统中每个用户帐户的一行。每一行由七个字段组成，这些字段由冒号（`:`）分隔，如下例所示：
- en: '[PRE0]'
  id: totrans-6
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'In order, these fields are as follows:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 依次排列，这些字段如下：
- en: '*Login name*: This is the unique name that the user must enter in order to
    log in. Often, this is also called the username. We can also consider the login
    name to be the human-readable (symbolic) identifier corresponding to the numeric
    user identifier (described in a moment). Programs such as *ls(1)* display this
    name, rather than the numeric user ID associated with the file, when asked to
    show the ownership of a file (as in *ls -l*).'
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*登录名*：这是用户必须输入的唯一名称才能登录。通常，这也称为用户名。我们也可以将登录名视为与数字用户标识符（稍后描述）对应的人类可读（符号）标识符。当程序如*ls(1)*被要求显示文件的所有者时，它会显示此名称，而不是与文件相关联的数字用户ID（例如，在*ls
    -l*中）。'
- en: '*Encrypted password*: This field contains a 13-character encrypted password,
    which we describe in more detail in Section 8.5\. If the password field contains
    any other string—in particular, a string of other than 13 characters—then logins
    to this account are disabled, since such a string can’t represent a valid encrypted
    password. Note, however, that this field is ignored if shadow passwords have been
    enabled (which is typical). In this case, the password field in `etc/passwd` conventionally
    contains the letter *x* (although any nonempty character string may appear), and
    the encrypted password is instead stored in the shadow password file ([The Shadow
    Password File: `/etc/shadow`](ch08.html#the_shadow_password_file_colon__solidus
    "The Shadow Password File: /etc/shadow")). If the password field in `/etc/passwd`
    is empty, then no password is required to log in to this account (this is true
    even if shadow passwords are enabled).'
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*加密密码*：此字段包含一个13个字符的加密密码，我们将在8.5节中详细描述。如果密码字段包含任何其他字符串——特别是其他长度为13以外的字符串——则该帐户的登录将被禁用，因为这样的字符串不能表示有效的加密密码。需要注意的是，如果启用了影子密码（这是典型的情况），则此字段将被忽略。在这种情况下，`/etc/passwd`中的密码字段通常包含字母*x*（尽管可以出现任何非空字符字符串），而加密密码则存储在影子密码文件中（[影子密码文件：`/etc/shadow`](ch08.html#the_shadow_password_file_colon__solidus
    "影子密码文件：/etc/shadow")）。如果`/etc/passwd`中的密码字段为空，则登录此帐户时不需要密码（即使启用了影子密码，这也成立）。'
- en: Note
  id: totrans-10
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Here, we assume that passwords are encrypted using Data Encryption Standard
    (DES), the historical and still widely used UNIX password-encryption scheme. It
    is possible to replace DES with other schemes, such as MD5, which produces a 128-bit
    *message digest* (a kind of hash) of its input. This value is stored as a 34-character
    string in the password (or shadow password) file.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们假设密码是使用数据加密标准（DES）加密的，这是一种历史悠久且仍广泛使用的UNIX密码加密方案。也可以用其他方案替代DES，如MD5，它生成一个128位的*消息摘要*（一种哈希值）。这个值以34个字符的字符串形式存储在密码（或影子密码）文件中。
- en: '*User ID* (UID): This is the numeric ID for this user. If this field has the
    value 0, then this account has superuser privileges. There is normally one such
    account, with the login name *root*. On Linux 2.2 and earlier, user IDs are maintained
    as 16-bit values, allowing the range 0 through to 65,535; on Linux 2.4 and later,
    they are stored using 32 bits, allowing a much larger range.'
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*用户 ID*（UID）：这是该用户的数字 ID。如果此字段的值为 0，则该账户具有超级用户权限。通常，只有一个这样的账户，登录名为 *root*。在
    Linux 2.2 及之前版本中，用户 ID 作为 16 位值存储，允许的范围是 0 到 65,535；在 Linux 2.4 及之后版本中，它们以 32
    位存储，允许更大的范围。'
- en: Note
  id: totrans-13
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: It is possible (but unusual) to have more than one record in the password file
    with the same user ID, thus permitting multiple login names for the same user
    ID. This allows multiple users to access the same resources (e.g., files) using
    different passwords. The different login names can be associated with different
    sets of group IDs.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 可以（但不常见）在密码文件中有多个具有相同用户 ID 的记录，从而允许同一用户 ID 有多个登录名。这使得多个用户可以使用不同的密码访问相同的资源（例如文件）。不同的登录名可以与不同的组
    ID 集关联。
- en: '*Group ID* (GID): This is the numeric ID of the first of the groups of which
    this user is a member. Further group memberships for this user are defined in
    the system group file.'
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*组 ID*（GID）：这是该用户所属的第一个组的数字 ID。该用户的进一步组成员关系定义在系统组文件中。'
- en: '*Comment*: This field holds text about the user. This text is displayed by
    various programs, such as *finger(1)*.'
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*注释*：此字段包含有关用户的文本。各种程序，如 *finger(1)*，会显示此文本。'
- en: '*Home directory*: This is the initial directory into which the user is placed
    after logging in. This field becomes the value of the `HOME` environment variable.'
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*主目录*：这是用户登录后进入的初始目录。此字段成为 `HOME` 环境变量的值。'
- en: '*Login shell*: This is the program to which control is transferred once the
    user is logged in. Usually, this is one of the shells, such as *bash*, but it
    can be any program. If this field is empty, then the login shell defaults to `/bin/sh`,
    the Bourne shell. This field becomes the value of the `SHELL` environment variable.'
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*登录 shell*：这是用户登录后控制权转交给的程序。通常，这是其中一个 shell，例如 *bash*，但它可以是任何程序。如果此字段为空，则登录
    shell 默认为 `/bin/sh`，即 Bourne shell。此字段成为 `SHELL` 环境变量的值。'
- en: On a stand-alone system, all the password information resides in the file `/etc/passwd`.
    However, if we are using a system such as Network Information System (NIS) or
    Lightweight Directory Access Protocol (LDAP) to distribute passwords in a network
    environment, part or all of this information resides on a remote system. As long
    as programs accessing password information employ the functions described later
    in this chapter (*getpwnam()*, *getpwuid()*, and so on), the use of NIS or LDAP
    is transparent to applications. Similar comments apply regarding the shadow password
    and group files discussed in the following sections.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 在独立系统上，所有密码信息存储在文件 `/etc/passwd` 中。然而，如果我们使用类似网络信息系统（NIS）或轻量级目录访问协议（LDAP）这样的系统来在网络环境中分发密码，那么部分或全部信息将存储在远程系统上。只要访问密码信息的程序采用本章后面描述的函数（*getpwnam()*、*getpwuid()*
    等），NIS 或 LDAP 的使用对于应用程序是透明的。类似的评论适用于后面讨论的影子密码和组文件。
- en: 'The Shadow Password File: `/etc/shadow`'
  id: totrans-20
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 影子密码文件：`/etc/shadow`
- en: Historically, UNIX systems maintained all user information, including the encrypted
    password, in `/etc/passwd`. This presented a security problem. Since various unprivileged
    system utilities needed to have read access to other information in the password
    file, it had to be made readable to all users. This opened the door for password-cracking
    programs, which try encrypting large lists of likely passwords (e.g., standard
    dictionary words or people’s names) to see if they match the encrypted password
    of a user. The *shadow password file*, `/etc/shadow`, was devised as a method
    of preventing such attacks. The idea is that all of the nonsensitive user information
    resides in the publicly readable password file, while encrypted passwords are
    maintained in the shadow password file, which is readable only by privileged programs.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 历史上，UNIX 系统将所有用户信息，包括加密密码，都保存在`/etc/passwd`中。这带来了安全问题。由于各种无特权的系统工具需要读取密码文件中的其他信息，因此该文件必须对所有用户可读。这为密码破解程序打开了大门，这些程序尝试加密可能的密码列表（例如，标准字典单词或人名），以查看它们是否与用户的加密密码匹配。*影子密码文件*`/etc/shadow`的设计目的是防止此类攻击。其思路是，所有不敏感的用户信息保存在公开可读的密码文件中，而加密密码则保存在影子密码文件中，只有特权程序才能读取该文件。
- en: In addition to the login name, which provides the match to the corresponding
    record in the password file, and the encrypted password, the shadow password file
    also contains a number of other security-related fields. Further details on these
    fields can be found in the *shadow(5)* manual page. We’ll concern ourselves mainly
    with the encrypted password field, which we discuss in greater detail when looking
    at the *crypt()* library function later in Section 8.5.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 除了提供与密码文件中相应记录匹配的登录名和加密密码外，影子密码文件还包含其他许多与安全相关的字段。有关这些字段的详细信息，请参阅*shadow(5)*手册页。我们主要关心的是加密密码字段，我们将在第8.5节进一步讨论此字段，并查看*crypt()*库函数。
- en: SUSv3 doesn’t specify shadow passwords. Not all UNIX implementations provide
    this feature, and on implementations where it is provided the details of the file
    locations and APIs vary.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: SUSv3 没有指定影子密码。并非所有 UNIX 实现都提供此功能，在提供此功能的实现中，文件位置和 API 的细节有所不同。
- en: 'The Group File: `/etc/group`'
  id: totrans-24
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 组文件：`/etc/group`
- en: For various administrative purposes, in particular, controlling access to files
    and other system resources, it is useful to organize users into *groups*.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 出于各种管理目的，特别是控制对文件和其他系统资源的访问，组织用户到*组*中是非常有用的。
- en: The set of groups to which a user belongs is defined by the combination of the
    group ID field in the user’s password entry and the groups under which the user
    is listed in the group file. This strange split of information across two files
    is historical in origin. In early UNIX implementations, a user could be a member
    of only one group at a time. A user’s initial group membership at login was determined
    by the group ID field of the password file and could be changed thereafter using
    the *newgrp(1)* command, which required the user to supply the group password
    (if the group was password protected). 4.2BSD introduced the concept of multiple
    simultaneous group memberships, which was later standardized in POSIX.1-1990\.
    Under this scheme, the group file listed the extra group memberships of each user.
    (The *groups(1)* command displays the groups of which the shell process is a member,
    or, if one or more usernames are supplied as command-line arguments, then the
    group memberships of those users.)
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 用户所属的组集由用户密码条目中的组 ID 字段和组文件中列出的用户所属组的组合定义。这种将信息分散到两个文件中的做法源于历史。在早期的 UNIX 实现中，用户一次只能属于一个组。用户在登录时的初始组成员身份是由密码文件中的组
    ID 字段确定的，之后可以使用*newgrp(1)*命令进行更改，前提是用户需要提供组密码（如果该组受密码保护）。4.2BSD 引入了多个同时组成员身份的概念，后来在
    POSIX.1-1990 中进行了标准化。在这种方案下，组文件列出了每个用户的额外组成员身份。（*groups(1)* 命令显示 shell 进程所属的组，或者，如果在命令行参数中提供一个或多个用户名，则显示这些用户的组成员身份。）
- en: 'The *group file*, `/etc/group`, contains one line for each group in the system.
    Each line consists of four colon-separated fields, as in the following examples:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: '*组文件*`/etc/group`包含系统中每个组的一行。每一行由四个由冒号分隔的字段组成，如下例所示：'
- en: '[PRE1]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'In order, these fields are as follows:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 按顺序，这些字段如下：
- en: '*Group name*: This is the name of the group. Like the login name in the password
    file, we can consider this to be the human-readable (symbolic) identifier corresponding
    to the numeric group identifier.'
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*组名*：这是组的名称。与密码文件中的登录名一样，我们可以将其视为与数字组标识符对应的人类可读（符号）标识符。'
- en: '*Encrypted password*: This field contains an optional password for the group.
    With the advent of multiple group memberships, group passwords are nowadays rarely
    used on UNIX systems. Nevertheless, it is possible to place a password on a group
    (a privileged user can do this using the *gpasswd* command). If a user is not
    a member of the group, *newgrp(1)* requests this password before starting a new
    shell whose group memberships include that group. If password shadowing is enabled,
    then this field is ignored (in this case, conventionally it contains just the
    letter *x*, but any string, including an empty string, may appear) and the encrypted
    passwords are actually kept in the *shadow group file*, `/etc/gshadow`, which
    can be accessed only by privileged users and programs. Group passwords are encrypted
    in a similar fashion to user passwords ([Password Encryption and User Authentication](ch08.html#password_encryption_and_user_authenticat
    "Password Encryption and User Authentication")).'
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*加密密码*：此字段包含一个可选的密码，用于该组。随着多个组成员身份的出现，UNIX 系统上现在很少使用组密码。尽管如此，仍然可以给组设置密码（特权用户可以使用
    *gpasswd* 命令做到这一点）。如果用户不是该组的成员，*newgrp(1)* 在启动新 shell 之前会要求输入此密码，而该 shell 的组成员包括该组。如果启用了密码影像功能，则此字段会被忽略（在这种情况下，通常只包含字母
    *x*，但也可以出现任何字符串，包括空字符串），加密后的密码实际上保存在 *shadow group file* 文件中，即 `/etc/gshadow`，该文件只能由特权用户和程序访问。组密码的加密方式与用户密码类似（参见[密码加密与用户认证](ch08.html#password_encryption_and_user_authenticat
    "Password Encryption and User Authentication")）。'
- en: '*Group ID* (GID): This is the numeric ID for this group. There is normally
    one group defined with the group ID 0, named *root* (like the `/etc/passwd` record
    with user ID of 0, but unlike the user ID 0, this group has no special privileges).
    On Linux 2.2 and earlier, group IDs are maintained as 16-bit values, allowing
    the range 0 through to 65,535; on Linux 2.4 and later, they are stored using 32
    bits.'
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*组 ID*（GID）：这是该组的数字 ID。通常有一个组定义为组 ID 0，名为 *root*（与用户 ID 为 0 的 `/etc/passwd`
    记录类似，但与用户 ID 0 不同，该组没有特殊权限）。在 Linux 2.2 及更早版本中，组 ID 被作为 16 位值维护，范围从 0 到 65,535；在
    Linux 2.4 及更高版本中，它们使用 32 位存储。'
- en: '*User list*: This is a comma-separated list of names of users who are members
    of this group. (This list consists of usernames rather than user IDs, since, as
    noted earlier, user IDs are not necessarily unique in the password file.)'
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*用户列表*：这是一个由逗号分隔的用户名单，列出了此组的成员。（此列表包含用户名，而不是用户 ID，因为，如前所述，用户 ID 在密码文件中不一定是唯一的。）'
- en: 'To record that the user *avr* is a member of the groups *users*, *staff*, and
    *teach*, we would see the following record in the password file:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 为了记录用户 *avr* 是 *users*、*staff* 和 *teach* 组的成员，我们会在密码文件中看到以下记录：
- en: '[PRE2]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'And the following records would appear in the group file:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 以下记录会出现在组文件中：
- en: '[PRE3]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The fourth field of the password record, containing the group ID 100, specifies
    membership of the group *users*. The remaining group memberships are indicated
    by listing *avr* once in each of the relevant records in the group file.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 密码记录的第四个字段，包含组 ID 100，指定了 *users* 组的成员身份。其余的组成员身份通过在组文件中的相关记录中一次列出 *avr* 来表示。
- en: Retrieving User and Group Information
  id: totrans-39
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 检索用户和组信息
- en: In this section, we look at library functions that permit us to retrieve individual
    records from the password, shadow password, and group files, and to scan all of
    the records in each of these files.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将介绍一些库函数，它们允许我们从密码文件、影像密码文件和组文件中检索单个记录，并扫描每个文件中的所有记录。
- en: Retrieving records from the password file
  id: totrans-41
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 从密码文件中检索记录
- en: The *getpwnam()* and *getpwuid()* functions retrieve records from the password
    file.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: '*getpwnam()* 和 *getpwuid()* 函数从密码文件中检索记录。'
- en: '[PRE4]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Note
  id: totrans-44
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注释
- en: Both return a pointer on success, or `NULL` on error; see main text for description
    of the “not found” case
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 两者在成功时返回一个指针，在出错时返回 `NULL`；有关“未找到”情况的描述，请参见正文
- en: 'Given a login name in *name*, the *getpwnam()* function returns a pointer to
    a structure of the following type, containing the corresponding information from
    the password record:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 给定登录名 *name*，*getpwnam()* 函数返回一个指向以下类型结构的指针，该结构包含来自密码记录的相应信息：
- en: '[PRE5]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The *pw_gecos* and *pw_passwd* fields of the *passwd* structure are not defined
    in SUSv3, but are available on all UNIX implementations. The *pw_passwd* field
    contains valid information only if password shadowing is not enabled. (Programmatically,
    the simplest way to determine whether password shadowing is enabled is to follow
    a successful *getpwnam()* call with a call to *getspnam()*, described shortly,
    to see if it returns a shadow password record for the same username.) Some other
    implementations provide additional, nonstandard fields in this structure.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: '*passwd* 结构体的 *pw_gecos* 和 *pw_passwd* 字段在 SUSv3 中没有定义，但在所有 UNIX 实现中都可用。如果没有启用密码阴影，则
    *pw_passwd* 字段包含有效信息。（从编程角度来看，确定是否启用了密码阴影的最简单方法是，在成功调用 *getpwnam()* 后，调用 *getspnam()*（稍后描述），查看是否返回相同用户名的阴影密码记录。）一些其他实现提供了此结构体中的额外非标准字段。'
- en: Note
  id: totrans-49
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The *pw_gecos* field derives its name from early UNIX implementations, where
    this field contained information that was used for communicating with a machine
    running the General Electric Comprehensive Operating System (GECOS). Although
    this usage has long since become obsolete, the field name has survived, and the
    field is used for recording information about the user.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: '*pw_gecos* 字段的名字来源于早期的 UNIX 实现，当时这个字段包含用于与运行通用电气综合操作系统（GECOS）的机器进行通信的信息。尽管这种用法早已过时，但字段名称得以保留，并且该字段用于记录有关用户的信息。'
- en: The *getpwuid()* function returns exactly the same information as *getpwnam()*,
    but does a lookup using the numeric user ID supplied in the argument *uid*.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: '*getpwuid()* 函数返回与 *getpwnam()* 完全相同的信息，但通过传入的 *uid* 数字用户 ID 进行查找。'
- en: Both *getpwnam()* and *getpwuid()* return a pointer to a statically allocated
    structure. This structure is overwritten on each call to either of these functions
    (or to the *getpwent()* function described below).
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: '*getpwnam()* 和 *getpwuid()* 都返回指向静态分配结构体的指针。每次调用这些函数（或者下面描述的 *getpwent()* 函数）时，都会覆盖该结构体。'
- en: Note
  id: totrans-53
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Because they return a pointer to statically allocated memory, *getpwnam()* and
    *getpwuid()* are not reentrant. In fact, the situation is even more complex, since
    the returned *passwd* structure contains pointers to other information (e.g.,
    the *pw_name* field) that is also statically allocated. (We explain reentrancy
    in [Reentrant and Async-Signal-Safe Functions](ch21.html#reentrant_and_async-signal-safe_function
    "Reentrant and Async-Signal-Safe Functions").) Similar statements apply to the
    *getgrnam()* and *getgrgid()* functions (described shortly).
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 由于它们返回指向静态分配内存的指针，*getpwnam()* 和 *getpwuid()* 不是可重入的。实际上，情况更为复杂，因为返回的 *passwd*
    结构体包含指向其他信息的指针（例如，*pw_name* 字段），这些信息也是静态分配的。（我们在[可重入和异步信号安全函数](ch21.html#reentrant_and_async-signal-safe_function
    "可重入和异步信号安全函数")中解释了可重入性。）类似的说法适用于 *getgrnam()* 和 *getgrgid()* 函数（稍后描述）。
- en: SUSv3 specifies an equivalent set of reentrant functions—*getpwnam_r()*, *getpwuid_r()*,
    *getgrnam_r()*, and *getgrgid_r()*—that include as arguments both a *passwd* (or
    *group*) structure and a buffer area to hold the other structures to which the
    fields of the *passwd (group)* structure point. The number of bytes required for
    this additional buffer can be obtained using the call *sysconf(_SC_GETPW_R_SIZE_MAX)*
    (or *sysconf(_SC_GETGR_R_SIZE_MAX)* in the case of the group-related functions).
    See the manual pages for details of these functions.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: SUSv3 指定了一组等效的可重入函数——*getpwnam_r()*、*getpwuid_r()*、*getgrnam_r()* 和 *getgrgid_r()*——这些函数的参数既包括
    *passwd*（或 *group*）结构体，又包括一个缓冲区，用于保存其他结构体，这些结构体是 *passwd*（*group*）结构体字段指向的内容。可以使用调用
    *sysconf(_SC_GETPW_R_SIZE_MAX)*（或者在与组相关的函数中使用 *sysconf(_SC_GETGR_R_SIZE_MAX)*）来获取此附加缓冲区所需的字节数。有关这些函数的详细信息，请参见手册页。
- en: 'According to SUSv3, if a matching *passwd* record can’t be found, then *getpwnam()*
    and *getpwuid()* should return `NULL` and leave *errno* unchanged. This means
    that we should be able to distinguish the error and the “not found” cases using
    code such as the following:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 根据 SUSv3，如果无法找到匹配的 *passwd* 记录，则 *getpwnam()* 和 *getpwuid()* 应返回 `NULL` 并保持
    *errno* 不变。这意味着我们应该能够通过如下代码区分错误情况和“未找到”情况：
- en: '[PRE6]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: However, a number of UNIX implementations don’t conform to SUSv3 on this point.
    If a matching *passwd* record is not found, then these functions return `NULL`
    and set *errno* to a nonzero value, such as `ENOENT` or `ESRCH`. Before version
    2.7, *glibc* produced the error `ENOENT` for this case, but since version 2.7,
    *glibc* conforms to the SUSv3 requirements. This variation across implementations
    arises in part because POSIX.1-1990 did not require these functions to set *errno*
    on error and allowed them to set *errno* for the “not found” case. The upshot
    of all of this is that it isn’t really possible to portably distinguish the error
    and “not found” cases when using these functions.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，一些 UNIX 实现未遵循 SUSv3 在这一点上的规定。如果找不到匹配的 *passwd* 记录，这些函数将返回 `NULL` 并将 *errno*
    设置为非零值，如 `ENOENT` 或 `ESRCH`。在版本 2.7 之前，*glibc* 在这种情况下会产生 `ENOENT` 错误，但从版本 2.7
    开始，*glibc* 遵循了 SUSv3 的要求。这个实现差异部分源于 POSIX.1-1990 并未要求这些函数在出错时设置 *errno*，而是允许它们在“未找到”情况下设置
    *errno*。所有这些的结果是，使用这些函数时，实际上无法在错误和“未找到”之间进行可移植的区分。
- en: Retrieving records from the group file
  id: totrans-59
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 从组文件中检索记录
- en: The *getgrnam()* and *getgrgid()* functions retrieve records from the group
    file.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: '*getgrnam()* 和 *getgrgid()* 函数从组文件中检索记录。'
- en: '[PRE7]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Note
  id: totrans-62
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Both return a pointer on success, or `NULL` on error; see main text for description
    of the “not found” case
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 成功时返回指针，错误时返回 `NULL`；详见正文描述的“未找到”情况
- en: 'The *getgrnam()* function looks up group information by group name, and the
    *getgrgid()* function performs lookups by group ID. Both functions return a pointer
    to a structure of the following type:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: '*getgrnam()* 函数通过组名查找组信息，而 *getgrgid()* 函数通过组ID进行查找。两个函数都返回指向以下类型结构的指针：'
- en: '[PRE8]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Note
  id: totrans-66
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The *gr_passwd* field of the *group* structure is not specified in SUSv3, but
    is available on most UNIX implementations.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: '*group* 结构中的 *gr_passwd* 字段在 SUSv3 中没有指定，但在大多数 UNIX 实现中可用。'
- en: As with the corresponding password functions described above, this structure
    is overwritten on each call to one of these functions.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 与上述对应的密码函数一样，每次调用这些函数时，该结构都会被覆盖。
- en: If these functions can’t find a matching *group* record, then they show the
    same variations in behavior that we described for *getpwnam()* and *getpwuid()*.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 如果这些函数找不到匹配的 *group* 记录，那么它们表现出与 *getpwnam()* 和 *getpwuid()* 相同的行为变化。
- en: Example program
  id: totrans-70
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 示例程序
- en: 'One common use of the functions that we have already described in this section
    is to convert symbolic user and group names into numeric IDs and vice versa. [Example 8-1](ch08.html#functions_to_convert_user_and_group_ids
    "Example 8-1. Functions to convert user and group IDs to and from user and group
    names") demonstrates these conversions, in the form of four functions: *userNameFromId()*,
    *userIdFromName()*, *groupNameFromId()*, and *groupIdFromName()*. As a convenience
    to the caller, *userIdFromName()* and *groupIdFromName()* also allow the *name*
    argument to be a (purely) numeric string; in that case, the string is converted
    directly to a number and returned to the caller. We employ these functions in
    some example programs later in this book.'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 本节中我们已经描述的函数的一个常见用途是将符号用户和组名称转换为数字 ID，反之亦然。[示例 8-1](ch08.html#functions_to_convert_user_and_group_ids
    "示例 8-1：将用户和组 ID 转换为用户和组名称的函数") 展示了这些转换，形式为四个函数：*userNameFromId()*、*userIdFromName()*、*groupNameFromId()*
    和 *groupIdFromName()*。为了方便调用者，*userIdFromName()* 和 *groupIdFromName()* 还允许 *name*
    参数为（纯粹的）数字字符串；在这种情况下，字符串会被直接转换为数字并返回给调用者。我们将在本书后面的示例程序中使用这些函数。
- en: Example 8-1. Functions to convert user and group IDs to and from user and group
    names
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 8-1：将用户和组 ID 转换为用户和组名称的函数
- en: '[PRE9]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Scanning all records in the password and group files
  id: totrans-74
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 扫描密码文件和组文件中的所有记录
- en: The *setpwent()*, *getpwent()*, and *endpwent()* functions are used to perform
    sequential scans of the records in the password file.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: '*setpwent()*、*getpwent()* 和 *endpwent()* 函数用于执行密码文件记录的顺序扫描。'
- en: '[PRE10]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Note
  id: totrans-77
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Returns pointer on success, or `NULL` on end of stream or error
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 成功时返回指针，结束流或错误时返回 `NULL`
- en: '[PRE11]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The *getpwent()* function returns records from the password file one by one,
    returning `NULL` when there are no more records (or an error occurs). On the first
    call, *getpwent()* automatically opens the password file. When we have finished
    with the file, we call *endpwent()* to close it.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: '*getpwent()* 函数从密码文件中逐条返回记录，当没有更多记录（或发生错误）时，返回`NULL`。在第一次调用时，*getpwent()* 会自动打开密码文件。当我们处理完文件后，调用
    *endpwent()* 关闭文件。'
- en: 'We can walk through the entire password file printing login names and user
    IDs with the following code:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过以下代码遍历整个密码文件，打印登录名和用户ID：
- en: '[PRE12]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The *endpwent()* call is necessary so that any subsequent *getpwent()* call
    (perhaps in some other part of our program or in some library function that we
    call) will reopen the password file and start from the beginning. On the other
    hand, if we are part-way through the file, we can use the *setpwent()* function
    to restart from the beginning.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 必须调用*endpwent()*，以便任何后续的*getpwent()*调用（可能在程序的其他部分或我们调用的某些库函数中）会重新打开密码文件并从头开始。另一方面，如果我们在文件中间，使用*setpwent()*函数可以从头开始重新启动。
- en: The *getgrent()*, *setgrent()*, and *endgrent()* functions perform analogous
    tasks for the group file. We omit the prototypes for these functions because they
    are similar to those of the password file functions described above; see the manual
    pages for details.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: '*getgrent()*、*setgrent()*和*endgrent()*函数执行类似于组文件的任务。由于这些函数与上述密码文件函数类似，我们省略了这些函数的原型；详细信息请参见手册页。'
- en: Retrieving records from the shadow password file
  id: totrans-85
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 从影子密码文件中检索记录
- en: The following functions are used to retrieve individual records from the shadow
    password file and to scan all records in that file.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 以下函数用于从影子密码文件中检索单个记录并扫描文件中的所有记录。
- en: '[PRE13]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Note
  id: totrans-88
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Returns pointer on success, or `NULL` on not found or error
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 成功时返回指针，未找到或出错时返回`NULL`
- en: '[PRE14]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Note
  id: totrans-91
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Returns pointer on success, or `NULL` on end of stream or error
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 成功时返回指针，流结束或出错时返回`NULL`
- en: '[PRE15]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: We won’t describe these functions in detail, since their operation is similar
    to the corresponding password file functions. (These functions aren’t specified
    in SUSv3, and aren’t present on all UNIX implementations.)
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不会详细描述这些函数，因为它们的操作与对应的密码文件函数类似。（这些函数没有在SUSv3中指定，并且并非所有UNIX实现都包含这些函数。）
- en: 'The *getspnam()* and *getspent()* functions return pointers to a structure
    of type *spwd*. This structure has the following form:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: '*getspnam()*和*getspent()*函数返回指向*spwd*类型结构的指针。该结构具有以下形式：'
- en: '[PRE16]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: We demonstrate the use of *getspnam()* in [Example 8-2](ch08.html#authenticating_a_user_against_the_shadow
    "Example 8-2. Authenticating a user against the shadow password file").
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在[示例8-2](ch08.html#authenticating_a_user_against_the_shadow "示例8-2：验证用户与影子密码文件")中展示了如何使用*getspnam()*。
- en: Password Encryption and User Authentication
  id: totrans-98
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 密码加密与用户认证
- en: Some applications require that users authenticate themselves. Authentication
    typically takes the form of a username (login name) and password. An application
    may maintain its own database of usernames and passwords for this purpose. Sometimes,
    however, it is necessary or convenient to allow users to enter their standard
    username and password as defined in `/etc/passwd` and `/etc/shadow`. (For the
    remainder of this section, we assume a system where password shadowing is enabled,
    and thus that the encrypted password is stored in `/etc/shadow`.) Network applications
    that provide some form of login to a remote system, such as *ssh* and *ftp*, are
    typical examples of such programs. These applications must validate a username
    and password in the same way that the standard *login* program does.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 一些应用程序要求用户进行身份验证。身份验证通常是通过用户名（登录名）和密码的形式进行的。应用程序可能会维护自己的用户名和密码数据库以供此用途。然而，有时允许用户输入在`/etc/passwd`和`/etc/shadow`中定义的标准用户名和密码是必要或方便的。（在本节的其余部分，我们假设启用了密码影藏功能，因此加密的密码存储在`/etc/shadow`中。）提供某种远程系统登录功能的网络应用程序，如*ssh*和*ftp*，就是这种程序的典型例子。这些应用程序必须以与标准*login*程序相同的方式验证用户名和密码。
- en: For security reasons, UNIX systems encrypt passwords using a *one-way encryption*
    algorithm, which means that there is no method of re-creating the original password
    from its encrypted form. Therefore, the only way of validating a candidate password
    is to encrypt it using the same method and see if the encrypted result matches
    the value stored in `/etc/shadow`. The encryption algorithm is encapsulated in
    the *crypt()* function.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 出于安全考虑，UNIX系统使用*单向加密*算法加密密码，这意味着无法从加密后的密码恢复出原始密码。因此，验证候选密码的唯一方法是使用相同的算法对其进行加密，并查看加密结果是否与`/etc/shadow`中存储的值匹配。加密算法封装在*crypt()*函数中。
- en: '[PRE17]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Note
  id: totrans-102
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Returns pointer to statically allocated string containing encrypted password
    on success, or `NULL` on error
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 返回指向静态分配的字符串的指针，成功时包含加密后的密码，出错时返回`NULL`
- en: The *crypt()* algorithm takes a *key* (i.e., a password) of up to 8 characters,
    and applies a variation of the Data Encryption Standard (DES) algorithm to it.
    The *salt* argument is a 2-character string whose value is used to perturb (vary)
    the algorithm, a technique designed to make it more difficult to crack the encrypted
    password. The function returns a pointer to a statically allocated 13-character
    string that is the encrypted password.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: '*crypt()* 算法采用一个最多 8 个字符的 *key*（即密码），并对其应用一种变化版的数据加密标准（DES）算法。*salt* 参数是一个
    2 字符的字符串，其值用于扰动（变化）算法，这是一种旨在使破解加密密码更加困难的技术。该函数返回一个指向静态分配的 13 字符字符串的指针，该字符串即为加密后的密码。'
- en: Note
  id: totrans-105
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Details of DES can be found at [http://www.itl.nist.gov/fipspubs/fip46-2.htm](http://www.itl.nist.gov/fipspubs/fip46-2.htm).
    As noted earlier, other algorithms may be used instead of DES. For example, MD5
    yields a 34-character string starting with a dollar sign (`$`), which allows *crypt()*
    to distinguish DES-encrypted passwords from MD5-encrypted passwords.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: DES 的详细信息可以在 [http://www.itl.nist.gov/fipspubs/fip46-2.htm](http://www.itl.nist.gov/fipspubs/fip46-2.htm)
    中找到。如前所述，可以使用其他算法代替 DES。例如，MD5 会生成一个以美元符号（`$`）开头的 34 字符串，这使得 *crypt()* 能区分 DES
    加密的密码和 MD5 加密的密码。
- en: 'In our discussion of password encryption, we are using the word “encryption”
    somewhat loosely. Accurately, DES uses the given password string as an encryption
    key to encode a fixed bit string, while MD5 is a complex type of hashing function.
    The result in both cases is the same: an undecipherable and irreversible transformation
    of the input password.'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们讨论密码加密时，使用了“加密”这个词稍微有些宽泛。准确来说，DES 使用给定的密码字符串作为加密密钥对一个固定的位串进行编码，而 MD5 是一种复杂的哈希函数类型。在这两种情况下，结果都是相同的：输入密码的不可解读且不可逆的转换。
- en: Both the *salt* argument and the encrypted password are composed of characters
    selected from the 64-character set `[a-zA-Z0-9/.]`. Thus, the 2-character *salt*
    argument can cause the encryption algorithm to vary in any of 64 * 64 = 4096 different
    ways. This means that instead of preencrypting an entire dictionary and checking
    the encrypted password against all words in the dictionary, a cracker would need
    to check the password against 4096 encrypted versions of the dictionary.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: '*salt* 参数和加密密码由从 64 字符集 `[a-zA-Z0-9/.]` 中选择的字符组成。因此，2 字符的 *salt* 参数可以使加密算法在
    64 * 64 = 4096 种不同的方式中变化。这意味着，破解者需要检查密码与字典的 4096 个加密版本，而不是预先加密整个字典并与字典中的所有单词进行比较。'
- en: The encrypted password returned by *crypt()* contains a copy of the original
    *salt* value as its first two characters. This means that when encrypting a candidate
    password, we can obtain the appropriate *salt* value from the encrypted password
    value already stored in `/etc/shadow`. (Programs such as *passwd(1)* generate
    a random *salt* value when encrypting a new password.) In fact, the *crypt()*
    function ignores any characters in the *salt* string beyond the first two. Therefore,
    we can specify the encrypted password itself as the *salt* argument.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: '*crypt()* 返回的加密密码包含原始 *salt* 值的副本，作为其前两个字符。这意味着，在加密候选密码时，我们可以从 `/etc/shadow`
    中已存储的加密密码值中获取适当的 *salt* 值。（例如，*passwd(1)* 程序在加密新密码时会生成一个随机的 *salt* 值。）事实上，*crypt()*
    函数会忽略 *salt* 字符串中超过前两个字符的任何内容。因此，我们可以将加密密码本身指定为 *salt* 参数。'
- en: In order to use *crypt()* on Linux, we must compile programs with the *-lcrypt*
    option, so that they are linked against the *crypt* library.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 为了在 Linux 上使用 *crypt()*，我们必须在编译程序时使用 *-lcrypt* 选项，以便将程序与 *crypt* 库链接。
- en: Example program
  id: totrans-111
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 示例程序
- en: '[Example 8-2](ch08.html#authenticating_a_user_against_the_shadow "Example 8-2. Authenticating
    a user against the shadow password file") demonstrates how to use *crypt()* to
    authenticate a user. This program first reads a username and then retrieves the
    corresponding password record and (if it exists) shadow password record. The program
    prints an error message and exits if no password record is found, or if the program
    doesn’t have permission to read from the shadow password file (this requires either
    superuser privilege or membership of the *shadow* group). The program then reads
    the user’s password, using the *getpass()* function.'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 8-2](ch08.html#authenticating_a_user_against_the_shadow "示例 8-2. 使用 shadow
    密码文件对用户进行身份验证") 演示了如何使用 *crypt()* 对用户进行身份验证。该程序首先读取用户名，然后检索相应的密码记录以及（如果存在）shadow
    密码记录。如果未找到密码记录，或者程序没有权限从 shadow 密码文件中读取（这需要超级用户权限或属于 *shadow* 组），程序将打印错误信息并退出。然后，程序使用
    *getpass()* 函数读取用户密码。'
- en: '[PRE18]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Note
  id: totrans-114
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Returns pointer to statically allocated input password string on success, or
    `NULL` on error
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 成功时返回指向静态分配的输入密码字符串的指针，出错时返回 `NULL`
- en: The *getpass()* function first disables echoing and all processing of terminal
    special characters (such as the *interrupt* character, normally *Control-C*).
    (We explain how to change these terminal settings in [Chapter 62](ch62.html "Chapter 62. Terminals").)
    It then prints the string pointed to by *prompt*, and reads a line of input, returning
    the null-terminated input string with the trailing newline stripped, as its function
    result. (This string is statically allocated, and so will be overwritten on a
    subsequent call to *getpass()*.) Before returning, *getpass()* restores the terminal
    settings to their original states.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: '*getpass()* 函数首先禁用回显以及终端特殊字符的所有处理（例如 *中断* 字符，通常是 *Control-C*）。(我们在[第 62 章](ch62.html
    "第 62 章. 终端")中解释了如何更改这些终端设置。) 然后它打印由 *prompt* 指向的字符串，并读取一行输入，将空字符终止的输入字符串返回，去掉尾随的换行符作为函数结果。（该字符串是静态分配的，因此在随后的
    *getpass()* 调用中将被覆盖。）在返回之前，*getpass()* 恢复终端设置到原始状态。'
- en: 'Having read a password with *getpass()*, the program in [Example 8-2](ch08.html#authenticating_a_user_against_the_shadow
    "Example 8-2. Authenticating a user against the shadow password file") then validates
    that password by using *crypt()* to encrypt it and checking that the resulting
    string matches the encrypted password recorded in the shadow password file. If
    the password matches, then the ID of the user is displayed, as in the following
    example:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用 *getpass()* 读取密码后，[示例 8-2](ch08.html#authenticating_a_user_against_the_shadow
    "示例 8-2. 通过影子密码文件验证用户身份") 中的程序接着使用 *crypt()* 对密码进行加密，并检查加密后的字符串是否与影子密码文件中记录的加密密码匹配。如果密码匹配，则显示用户的
    ID，如下例所示：
- en: '[PRE19]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Note
  id: totrans-119
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The program in [Example 8-2](ch08.html#authenticating_a_user_against_the_shadow
    "Example 8-2. Authenticating a user against the shadow password file") sizes the
    character array holding a username using the value returned by *sysconf(_SC_LOGIN_NAME_MAX)*,
    which yields the maximum size of a username on the host system. We explain the
    use of *sysconf()* in Section 11.2.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 8-2](ch08.html#authenticating_a_user_against_the_shadow "示例 8-2. 通过影子密码文件验证用户身份")
    中的程序使用 *sysconf(_SC_LOGIN_NAME_MAX)* 返回的值来确定存储用户名的字符数组的大小，该值表示主机系统上用户名的最大大小。我们在第
    11.2 节中解释了 *sysconf()* 的使用。'
- en: Example 8-2. Authenticating a user against the shadow password file
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 8-2. 通过影子密码文件验证用户身份
- en: '[PRE20]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: '[Example 8-2](ch08.html#authenticating_a_user_against_the_shadow "Example 8-2. Authenticating
    a user against the shadow password file") illustrates an important security point.
    Programs that read a password should immediately encrypt that password and erase
    the unencrypted version from memory. This minimizes the possibility of a program
    crash producing a core dump file that could be read to discover the password.'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 8-2](ch08.html#authenticating_a_user_against_the_shadow "示例 8-2. 通过影子密码文件验证用户身份")
    说明了一个重要的安全点。读取密码的程序应立即加密该密码，并从内存中擦除未加密的版本。这可以最大限度地减少程序崩溃时产生核心转储文件并被读取以发现密码的可能性。'
- en: Note
  id: totrans-124
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: There are other possible ways in which the unencrypted password could be exposed.
    For example, the password could be read from the swap file by a privileged program
    if the virtual memory page containing the password is swapped out. Alternatively,
    a process with sufficient privilege could read `/dev/mem` (a virtual device that
    presents the physical memory of a computer as a sequential stream of bytes) in
    an attempt to discover the password.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 还有其他可能的方式使未加密的密码暴露。例如，如果包含密码的虚拟内存页被交换出去，特权程序可能会从交换文件中读取密码。或者，具有足够权限的进程可能会尝试读取
    `/dev/mem`（一个虚拟设备，它将计算机的物理内存呈现为一系列连续的字节流），以试图发现密码。
- en: The *getpass()* function appeared in SUSv2, which marked it LEGACY, noting that
    the name was misleading and the function provided functionality that was in any
    case easy to implement. The specification of *getpass()* was removed in SUSv3\.
    It nevertheless appears on most UNIX implementations.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: '*getpass()* 函数首次出现在 SUSv2 中，该版本将其标记为遗留功能，并指出该名称具有误导性，且该函数提供的功能实际上很容易实现。*getpass()*
    的规范在 SUSv3 中被删除。然而，它仍然出现在大多数 UNIX 实现中。'
- en: Summary
  id: totrans-127
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 总结
- en: Each user has a unique login name and an associated numeric user ID. Users can
    belong to one or more groups, each of which also has a unique name and an associated
    numeric identifier. The primary purpose of these identifiers is to establish ownership
    of various system resources (e.g., files) and permissions for accessing them.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 每个用户都有一个唯一的登录名和相关联的数字用户ID。用户可以属于一个或多个组，每个组也有一个唯一的名称和相关联的数字标识符。这些标识符的主要用途是建立各种系统资源（例如文件）的所有权以及访问这些资源的权限。
- en: A user’s name and ID are defined in the `/etc/passwd` file, which also contains
    other information about the user. A user’s group memberships are defined by fields
    in the `/etc/passwd` and `/etc/group` files. A further file, `/etc/shadow`, which
    can be read only by privileged processes, is used to separate the sensitive password
    information from the publicly available user information in `/etc/passwd`. Various
    library functions are provided for retrieving information from each of these files.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 用户的名字和ID在`/etc/passwd`文件中定义，该文件还包含关于用户的其他信息。用户的组成员身份通过`/etc/passwd`和`/etc/group`文件中的字段来定义。另一个文件`/etc/shadow`只能由特权进程读取，用于将敏感的密码信息与`/etc/passwd`中的公开用户信息分开。提供了各种库函数用于从这些文件中检索信息。
- en: The *crypt()* function encrypts a password in the same manner as the standard
    *login* program, which is useful for programs that need to authenticate users.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: '*crypt()*函数以与标准*login*程序相同的方式加密密码，这对于需要认证用户的程序非常有用。'
- en: Exercises
  id: totrans-131
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习
- en: When we execute the following code, we find that it displays the same number
    twice, even though the two users have different IDs in the password file. Why
    is this?
  id: totrans-132
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当我们执行以下代码时，我们发现它显示相同的数字两次，即使这两个用户在密码文件中有不同的ID。为什么会这样？
- en: '[PRE21]'
  id: totrans-133
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Implement *getpwnam()* using *setpwent()*, *getpwent()*, and *endpwent()*.
  id: totrans-134
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用*getpwnam()*实现*setpwent()*、*getpwent()*和*endpwent()*。
