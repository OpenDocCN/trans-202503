- en: '6'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '6'
- en: Performing Complex Joins with Multiple Tables
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 使用多个表进行复杂连接
- en: '![](image_fi/book_art/chapterart.png)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![](image_fi/book_art/chapterart.png)'
- en: In [Chapter 5](c05.xhtml), you saw how to join two tables and display the data
    in one result set. In this chapter, you’ll create complex joins with more than
    two tables, learn about associative tables, and see how to combine or limit the
    results of a query. You’ll then explore different ways to temporarily save a query’s
    results in a table-like format, including temporary tables, derived tables, and
    Common Table Expressions (CTEs). Finally, you’ll learn how to work with subqueries,
    which let you nest one query inside another for more refined results.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第五章](c05.xhtml)中，你学会了如何连接两个表并将数据显示在一个结果集中。在这一章，你将学习如何进行多个表的复杂连接，了解关联表，了解如何合并或限制查询结果。然后，你将探索将查询结果临时保存为类似表格的格式的不同方法，包括临时表、派生表和公共表表达式（CTEs）。最后，你将学习如何使用子查询，子查询允许你在一个查询中嵌套另一个查询，以获得更精细的结果。
- en: Writing One Query with Two Join Types
  id: totrans-4
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用两种连接类型编写一个查询
- en: Joining three or more tables introduces greater complexity than joining two,
    as you might have different join types (like an inner and an outer join) in the
    same query. For example, [Figure 6-1](#figure6-1) illustrates three tables in
    the `police` database, which contains information on crimes, including the suspect
    and location.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 连接三个或更多的表比连接两个表更加复杂，因为你可能在同一个查询中使用不同类型的连接（例如内连接和外连接）。例如，[图6-1](#figure6-1)展示了`police`数据库中的三个表，包含关于犯罪的信息，包括嫌疑人和位置。
- en: '![](image_fi/503007c06/f06001.png)'
  id: totrans-6
  prefs: []
  type: TYPE_IMG
  zh: '![](image_fi/503007c06/f06001.png)'
- en: 'Figure 6-1: Three tables within the `police` database'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 图6-1：`police`数据库中的三个表
- en: 'The `location` table contains the locations where the crimes occurred:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: '`location`表包含犯罪发生地点的信息：'
- en: '[PRE0]'
  id: totrans-9
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The `crime` table contains a description of the crimes:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: '`crime`表包含犯罪描述信息：'
- en: '[PRE1]'
  id: totrans-11
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The `suspect` table contains information about the suspect:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: '`suspect`表包含关于嫌疑人的信息：'
- en: '[PRE2]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Say you want to write a query that joins all three tables to get a list of crimes,
    where they occurred, and the name of the suspect. The `police` database was designed
    so that there will always be a matching location in the `location` table for every
    crime in the `crime` table. However, there may not be a matching suspect in the
    `suspect` table because the police have not identified a suspect for every crime.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你想编写一个查询，将所有三个表连接起来，获取犯罪列表、犯罪发生地点以及嫌疑人姓名。`police`数据库的设计保证了`crime`表中的每个犯罪案件在`location`表中都有一个匹配的地点。然而，`suspect`表中可能没有匹配的嫌疑人，因为警方并未为每个案件确定嫌疑人。
- en: 'You’ll perform an inner join between the `crime` and `location` tables, because
    you know there will be a match. But because there may not be a suspect match for
    each crime, you’ll do an outer join between the `crime` table and the `suspect`
    table. Your query might look like this:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 你将对`crime`和`location`表进行内连接，因为你知道它们一定会匹配。但是由于并非每个犯罪案件都有嫌疑人，因此你将在`crime`表和`suspect`表之间进行外连接。你的查询可能是这样的：
- en: '[PRE3]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: In this example, you alias the tables with `c` for `crime`, `l` for `location`,
    and `s` for `suspect`. You use the `join` syntax for the inner join between the
    `crime` and `location` tables ❶, and the `left join` syntax for the outer join
    to the `suspect` table ❷.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，你将`crime`表别名为`c`，`location`表别名为`l`，`suspect`表别名为`s`。你使用`join`语法进行`crime`和`location`表的内连接❶，使用`left
    join`语法进行`crime`和`suspect`表的外连接❷。
- en: Using a left join might cause some confusion in this context. When you were
    using `left join` with only two tables in [Chapter 5](c05.xhtml), it was easy
    to understand which was the left table and which was the right, because there
    were only two possibilities. But how does it work now that you’re joining three
    tables?
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个上下文中使用左连接可能会引起一些困惑。当你在[第五章](c05.xhtml)中使用只有两个表的`left join`时，很容易理解哪个是左表，哪个是右表，因为只有两种可能性。但是现在你连接了三个表，应该怎么理解呢？
- en: To understand multiple-table joins, imagine that MySQL is building temporary
    tables as it progresses through the query. MySQL joins the first two tables, `crime`
    and `location`, and the result of that join becomes the left table. Then MySQL
    does a `left join` between the `crime`/`location` combined table and the `suspect`
    table on the right.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 要理解多个表的连接，假设MySQL在执行查询时构建临时表。MySQL首先连接前两个表`crime`和`location`，连接的结果成为左表。然后，MySQL在`crime`/`location`合并表和`suspect`表之间执行`left
    join`。
- en: 'You used a *left* join for the outer join because you want all of the crimes
    and locations to appear regardless of whether there is a match with the `suspect`
    table on the right. The results of this query are as follows:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 你使用了*左*连接进行外连接，因为你希望所有的犯罪和地点都显示出来，无论右侧的`suspect`表中是否有匹配项。此查询的结果如下：
- en: '[PRE4]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The suspect for the last crime was able to escape, so the value of the `suspect_name`
    on the last row is `null`. If you had used an inner join instead, the query wouldn’t
    have returned the last row, because inner joins return rows only where there is
    a match.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一宗犯罪的嫌疑人成功逃脱，因此最后一行的`suspect_name`值为`null`。如果你使用了内连接，查询就不会返回最后一行，因为内连接只会返回有匹配的行。
- en: 'You can use the null value that gets returned from an outer join to your advantage.
    Say you want to write a query to display only crimes where the suspect is not
    known. You could specify in the query that you want to see only rows where the
    suspect name `is` `null`:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以利用外连接返回的`null`值。假设你想编写一个查询，仅显示嫌疑人未知的犯罪。你可以在查询中指定仅显示`suspect_name`为`null`的行：
- en: '[PRE5]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The results of this query are:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 此查询的结果为：
- en: '[PRE6]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Adding the `where` clause on the last line of the query showed you only rows
    that have no matching row in the `suspect` table, which limited your list to crimes
    with unknown suspects.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 在查询的最后一行添加`where`子句后，结果只显示了那些在`suspect`表中没有匹配行的记录，这将列表限制为嫌疑人未知的犯罪。
- en: Joining Many Tables
  id: totrans-28
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 连接多个表
- en: MySQL allows up to 61 tables in a join, though you’ll rarely need to write queries
    with that many. If you find yourself joining more than 10 tables, that’s a sign
    the database could be redesigned to make writing queries simpler.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: MySQL允许在连接中使用最多61个表，尽管你很少需要编写包含这么多表的查询。如果你发现自己连接了超过10个表，这通常是数据库结构需要重设计的信号，以简化查询编写。
- en: The `wine` database has six tables you can use to help plan a trip to a winery.
    Let’s look at all six in turn.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: '`wine`数据库有六个表，你可以用它们来帮助规划参观酒厂的行程。让我们逐一查看这六个表。'
- en: 'The `country` table stores the countries where the wineries are located:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: '`country`表存储酒厂所在的国家：'
- en: '[PRE7]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'The `region` table stores the regions within those countries where the wineries
    are located:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: '`region`表存储这些国家中酒厂所在的地区：'
- en: '[PRE8]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'The `viticultural_area` table stores the wine-growing subregions where the
    wineries are located:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: '`viticultural_area`表存储酒厂所在的葡萄酒种植子区域：'
- en: '[PRE9]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'The `wine_type` table stores information about the types of wine available:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: '`wine_type`表存储关于可用葡萄酒种类的信息：'
- en: '[PRE10]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'The `winery` table stores information about the wineries:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: '`winery`表存储关于酒厂的信息：'
- en: '[PRE11]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'The `portfolio` table stores information about the winery’s portfolio of wines—that
    is, which wines the winery offers:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: '`portfolio`表存储酒厂酒品组合的信息——也就是酒厂提供哪些酒：'
- en: '[PRE12]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: For example, the winery with a `winery_id` of `1` (Silva Vineyards) offers the
    wine with a `wine_type_id` of `1` (Chardonnay), which is in season (its `in_season_flag`—a
    boolean value—is `1`, indicating true).
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，`winery_id`为`1`（Silva Vineyards）的酒厂提供`wine_type_id`为`1`（Chardonnay）的酒，这款酒在季节中（其`in_season_flag`—一个布尔值—为`1`，表示是真的）。
- en: '[Listing 6-1](#listing6-1) shows a query that joins all six tables to find
    a winery in the USA that has a Merlot in season and is offering tours.'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: '[列表 6-1](#listing6-1)展示了一个查询，通过连接所有六个表，找出在美国有季节性梅洛酒并提供酒厂参观的酒厂。'
- en: '[PRE13]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Listing 6-1: A query to list US wineries with in-season Merlot'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 6-1：查询列出季节性梅洛酒的美国酒厂
- en: While this is a longer query than you’re used to, you’ve seen most of the syntax
    before. You create table aliases for each table name in the query (`country`,
    `region`, `viticultural_area`, `winery`, `portfolio`, and `wine_type`). When referring
    to columns in the query, you precede the column names with the table aliases and
    a period. For example, you precede the `offering_tours_flag` column with `w` because
    it is in the `winery` table, resulting in `w.offering_tours_flag`. (Remember from
    [Chapter 4](c04.xhtml) that it’s best practice to add the suffix `_flag` to columns
    that contain boolean values like `true` or `false`, which is the case with the
    `offering_tours` column, since a winery either offers tours or doesn’t.) Finally,
    you perform inner joins on each table with the word `join`, as there should be
    matching values when you join these tables.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这个查询比你平时用的要长，但你已经见过大部分的语法。在查询中，你为每个表名创建了表别名（`country`、`region`、`viticultural_area`、`winery`、`portfolio`和`wine_type`）。当在查询中引用列时，你会在列名之前加上表别名和一个点。例如，你会在`offering_tours_flag`列之前加上`w`，因为它在`winery`表中，所以结果是`w.offering_tours_flag`。（记住在[第4章](c04.xhtml)中提到的最佳实践，应该为包含布尔值（如`true`或`false`）的列添加`_flag`后缀，这就是`offering_tours`列的情况，因为酒庄要么提供游览，要么不提供。）最后，你使用`join`执行内连接，因为在连接这些表时应该有匹配的值。
- en: 'Unlike our earlier queries, this query contains some joins between tables where
    more than one condition must be met. For example, when you join the `country`
    and `region` tables, there are *two* conditions that need to be met:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 与我们之前的查询不同，这个查询包含了表之间的连接，其中需要满足多个条件。例如，当你连接`country`和`region`表时，需要满足*两个*条件：
- en: The value in the `country_id` column of the `country` table must match the value
    in the `country_id` column of the `region` table.
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`country`表中的`country_id`列的值必须与`region`表中的`country_id`列的值匹配。'
- en: The value in the `country_name` column of the `country` table must equal `USA`.
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`country`表中的`country_name`列必须等于`USA`。'
- en: 'You handled the first condition using the `on` keyword:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 你使用`on`关键字处理了第一个条件：
- en: '[PRE14]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Then you used the `and` keyword to specify the second condition:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 然后你使用了`and`关键字来指定第二个条件：
- en: '[PRE15]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: You can add more `and` statements to specify as many joining conditions as you
    need.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以添加更多的`and`语句来指定你需要的多个连接条件。
- en: 'The results of the query in [Listing 6-1](#listing6-1) are as follows:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 查询结果如下所示：[清单 6-1](#listing6-1)：
- en: '[PRE16]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Associative Tables
  id: totrans-58
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 关联表
- en: 'In [Listing 6-1](#listing6-1), most of the tables are straightforward: the
    `winery` table stores a list of wineries, `region` stores a list of regions, `country`
    stores countries, and `viticultural_area` stores viticultural areas (wine-growing
    subregions).'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 在[清单 6-1](#listing6-1)中，大部分表格都是直观的：`winery`表存储酒庄列表，`region`表存储地区列表，`country`表存储国家，`viticultural_area`表存储葡萄种植区（葡萄种植子区域）。
- en: 'The `portfolio` table, however, is a little different. Remember, it stores
    information about which wines are in each winery’s portfolio. Here it is again:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，`portfolio`表略有不同。记住，它存储的是关于哪些酒在每个酒庄的酒单中的信息。这里再次展示：
- en: '[PRE17]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Its `winery_id` column is the primary key of the `winery` table, and its `wine_type_id`
    column is the primary key of the `wine_type` table. This makes `portfolio` an
    *associative table* because it associates rows that are stored in other tables
    to each other by referencing their primary keys, as illustrated in [Figure 6-2](#figure6-2).
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 它的`winery_id`列是`winery`表的主键，`wine_type_id`列是`wine_type`表的主键。这使得`portfolio`成为一个*关联表*，因为它通过引用主键，将存储在其他表中的行相互关联，如[图6-2](#figure6-2)所示。
- en: '![](image_fi/503007c06/f06002.png)'
  id: totrans-63
  prefs: []
  type: TYPE_IMG
  zh: '![](image_fi/503007c06/f06002.png)'
- en: 'Figure 6-2: The `portfolio` table is an associative table.'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 图6-2：`portfolio`表是一个关联表。
- en: 'The `portfolio` table represents *many-to-many relationships* because one winery
    can produce many wine types, and one wine type can be produced in many wineries.
    For example, winery `1` (Silva Vineyards) offers many wine types: `1` (Chardonnay),
    `2` (Cabernet Sauvignon), and `3` (Merlot). Wine type `1` (Chardonnay) is offered
    by many wineries: `1` (Silva Vineyards), `2` (Chateau Traileur Parc), and `3`
    (Winosaur Estate). The `portfolio` table contains that list of relationships between
    each `winery_id` and `wine_type_id` that tells us which wineries have which wine
    types. As a bonus, it also contains the `in_season_flag` column, which, as you’ve
    seen, tracks whether that wine is in season at that winery.'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: '`portfolio` 表表示 *多对多关系*，因为一个酒庄可以生产多种葡萄酒类型，而一种葡萄酒类型可以在多个酒庄生产。例如，酒庄 `1`（Silva
    Vineyards）提供多种葡萄酒类型：`1`（Chardonnay）、`2`（Cabernet Sauvignon）和 `3`（Merlot）。葡萄酒类型
    `1`（Chardonnay）由多个酒庄提供：`1`（Silva Vineyards）、`2`（Chateau Traileur Parc）和 `3`（Winosaur
    Estate）。`portfolio` 表包含了每个 `winery_id` 和 `wine_type_id` 之间的关系，告诉我们哪些酒庄提供哪些葡萄酒类型。作为附加内容，它还包含了
    `in_season_flag` 列，正如你所见，它跟踪该葡萄酒是否在该酒庄的当季生产。'
- en: Next, we’ll look at different ways to work with the data that’s returned from
    your queries. We’ll start with some simple options for managing the data in your
    result set and then cover some more involved approaches in the latter half of
    the chapter.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将探讨不同的方式来处理查询返回的数据。我们将从一些简单的选项开始，管理结果集中的数据，然后在本章后半部分介绍一些更复杂的方法。
- en: Managing the Data in Your Result Set
  id: totrans-67
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 管理结果集中的数据
- en: Sometimes you’ll want to control how much data from your queries is displayed
    in your result set. For example, you might want to pare down your results or combine
    the results of several `select` statements. SQL provides keywords to add this
    functionality to your queries.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 有时你需要控制查询返回的数据在结果集中如何显示。例如，你可能希望缩小结果范围或合并多个 `select` 语句的结果。SQL 提供了关键字来实现这些功能。
- en: The limit Keyword
  id: totrans-69
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '`limit` 关键字'
- en: 'The `limit` keyword lets you limit the number of rows displayed in your result
    set. For example, consider a table called `best_wine_contest` that holds the results
    of a contest where wine tasters voted for their favorite wines. If you query the
    table and `order by` the `place` column, you’ll see the wines that ranked the
    best first:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: '`limit` 关键字允许你限制结果集中显示的行数。例如，假设有一个名为 `best_wine_contest` 的表格，记录了一个葡萄酒品鉴比赛的结果，品鉴师为自己最喜欢的葡萄酒投票。如果你查询该表并使用
    `order by` 对 `place` 列排序，你将看到排名最好的葡萄酒排在最前面：'
- en: '[PRE18]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'The results are:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 结果是：
- en: '[PRE19]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'If you want to see only the top three wines, use `limit 3`:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你只想查看前 3 名的葡萄酒，可以使用 `limit 3`：
- en: '[PRE20]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Now the results are:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 现在结果是：
- en: '[PRE21]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: The `limit` keyword limited the results to three rows. To see only the wine
    that won top place, you could use `limit 1`.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: '`limit` 关键字将结果限制为三行。若要查看仅获胜的葡萄酒，你可以使用 `limit 1`。'
- en: The union Keyword
  id: totrans-79
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '`union` 关键字'
- en: 'The `union` keyword combines the results of multiple `select` statements into
    one result set. For example, the following query selects all the wine types from
    two different tables, `wine_type` and `best_wine_contest`, and shows them in one
    list:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: '`union` 关键字将多个 `select` 语句的结果合并成一个结果集。例如，以下查询从两个不同的表 `wine_type` 和 `best_wine_contest`
    中选择所有葡萄酒类型，并将它们显示在一个列表中：'
- en: '[PRE22]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'The result is:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 结果是：
- en: '[PRE23]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: The `wine_type` table has a column called `wine_type_name` that includes Chardonnay,
    Cabernet Sauvignon, and Merlot. The `best_wine_contest` table has a column called
    `wine_name` that includes Riesling, Pinot Grigio, Zinfandel, Malbec, and Verdejo.
    Using `union` allows you to see all of the wines together in one result set.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: '`wine_type` 表有一个名为 `wine_type_name` 的列，其中包括 Chardonnay、Cabernet Sauvignon 和
    Merlot。`best_wine_contest` 表有一个名为 `wine_name` 的列，其中包括 Riesling、Pinot Grigio、Zinfandel、Malbec
    和 Verdejo。使用 `union` 可以将所有葡萄酒一并显示在一个结果集中。'
- en: You can use `union` only when every `select` statement has the same number of
    columns. The union works in this example because you specified just one column
    in each of the `select` statements. The column name in the result set is usually
    taken from the first `select` statement.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 你只能在每个 `select` 语句具有相同列数时使用 `union`。在这个例子中，`union` 是可行的，因为你在每个 `select` 语句中都只指定了一个列。结果集中的列名通常来自第一个
    `select` 语句。
- en: 'The `union` keyword will remove duplicate values from the result set. For example,
    if you had Merlot in both the `wine_type` and the `best_wine_contest` tables,
    using `union` would produce a list of distinct wines, with Merlot listed only
    once. To see a list that includes duplicate values, use `union all`:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: '`union` 关键字将从结果集中移除重复值。例如，如果 `wine_type` 和 `best_wine_contest` 表中都有 Merlot，使用
    `union` 将只列出一次 Merlot 的独特酒种。如果你希望看到包含重复值的列表，可以使用 `union all`：'
- en: '[PRE24]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'The result would be:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 结果如下：
- en: '[PRE25]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Now you can see that Merlot is listed twice.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你可以看到 Merlot 被列出了两次。
- en: Next, you’ll dive in a bit deeper to make your queries even more efficient by
    creating temporary result sets in a table-like format.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，你将更深入地探讨如何通过创建类似表格格式的临时结果集来使查询更加高效。
- en: Temporary Tables
  id: totrans-92
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 临时表
- en: MySQL allows you to create temporary tables—that is, a temporary result set
    that will exist only for your current session and then be automatically dropped.
    For example, you can create a temporary table using a tool like MySQL Workbench
    and then query that table within the tool. If you close and reopen MySQL Workbench,
    however, the temporary table will be gone. You can reuse a temporary table several
    times in a single session.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: MySQL 允许你创建临时表——即仅在当前会话中存在并在会话结束时自动删除的临时结果集。例如，你可以使用像 MySQL Workbench 这样的工具创建临时表，然后在该工具中查询该表。然而，如果你关闭并重新打开
    MySQL Workbench，临时表将会消失。在一个会话中，你可以多次重用临时表。
- en: 'You can define a temporary table the same way you create a regular table, except
    that you use the syntax `create temporary table` instead of `create table`:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以像创建常规表一样定义临时表，只是你使用 `create temporary table` 而不是 `create table` 语法：
- en: '[PRE26]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: The `wp1` temporary table gets created with the column names and data types
    that you specified, without any rows.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: '`wp1` 临时表会根据你指定的列名和数据类型创建，但不会包含任何行。'
- en: To create a temporary table based on the results of a query, simply precede
    the query with the same `create temporary table` syntax, as shown in [Listing
    6-2](#listing6-2), and the resulting temporary table will contain the rows of
    data that were selected from the query.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 要基于查询结果创建临时表，只需在查询前添加相同的 `create temporary table` 语法，如 [Listing 6-2](#listing6-2)
    所示，结果的临时表将包含从查询中选取的行数据。
- en: '[PRE27]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Listing 6-2: Creating a temporary table'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: Listing 6-2：创建临时表
- en: 'Here you create a temporary table called `winery_portfolio` that stores the
    results of a query joining the `winery`, `portfolio`, and `wine_type` tables from
    [Listing 6-1](#listing6-1) and [Figure 6-2](#figure6-2). The `winery` and `portfolio`
    tables are joined based on two conditions:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，你创建了一个名为 `winery_portfolio` 的临时表，用来存储来自 [Listing 6-1](#listing6-1) 和 [Figure
    6-2](#figure6-2) 的查询结果，该查询将 `winery`、`portfolio` 和 `wine_type` 表连接起来。`winery`
    和 `portfolio` 表是基于两个条件连接的：
- en: The values of the `winery_id` columns in the tables match ❶.
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 表中的 `winery_id` 列的值匹配 ❶。
- en: The winery is offering tours. For this, you check that the `offering_tours_flag`
    in the `winery` table is set to `true` ❷.
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 酒庄提供参观服务。为此，你需要检查 `winery` 表中的 `offering_tours_flag` 是否设置为 `true` ❷。
- en: 'Those results are joined with the `wine_type` table based on two conditions:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 这些结果根据两个条件与 `wine_type` 表连接：
- en: The values of the `wine_type_id` columns in the tables match ❸.
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 表中的 `wine_type_id` 列的值匹配 ❸。
- en: The `wine_type_name` in the `wine_type` table is `Merlot` ❹.
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`wine_type` 表中的 `wine_type_name` 是 `Merlot` ❹。'
- en: 'Once you’ve created a temporary table, you can query its contents by selecting
    from it, just as you would with a permanent table:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你创建了临时表，你可以像查询永久表一样查询其内容，通过从中选择数据：
- en: '[PRE28]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'The results are:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 结果如下：
- en: '[PRE29]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Now you can write a second query to select from the `winery_portfolio` temporary
    table and join it with other three tables from [Listing 6-1](#listing6-1):'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你可以写第二个查询，从 `winery_portfolio` 临时表中选择数据，并将其与来自 [Listing 6-1](#listing6-1)
    的其他三个表连接：
- en: '[PRE30]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Here you are joining the `winery_portfolio` temporary table to the remaining
    tables that were part of the original query in [Listing 6-1](#listing6-1): `country`,
    `region`, and `viticultural_area`. In this way, you simplified a large, six-table
    query by isolating the data from three tables into a temporary table and then
    joining that temporary table with the other three tables. This query returns the
    same results as [Listing 6-1](#listing6-1).'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，你将 `winery_portfolio` 临时表与原始查询中其他三个表（来自 [Listing 6-1](#listing6-1)）连接：`country`、`region`
    和 `viticultural_area`。通过这种方式，你将一个大型的六表查询简化为将三个表的数据隔离到临时表中，然后再将该临时表与另外三个表连接。这条查询返回的结果与
    [Listing 6-1](#listing6-1) 相同。
- en: Common Table Expressions
  id: totrans-113
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 公共表表达式
- en: 'Common Table Expressions (CTEs), a feature introduced in MySQL version 8.0,
    are a temporary result set that you name and can then select from as if it were
    a table. You can use CTEs only for the duration of one query (versus temporary
    tables, which can be used for the entire session). [Listing 6-3](#listing6-3)
    shows how to use a CTE to simplify the query from [Listing 6-1](#listing6-1):'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 公共表表达式（CTE），是MySQL 8.0版本中引入的一项功能，它是一个临时结果集，你可以为其命名，并像查询表一样从中选择数据。CTE只能在一个查询的生命周期内使用（与临时表不同，临时表可以在整个会话中使用）。[清单6-3](#listing6-3)展示了如何使用CTE简化[清单6-1](#listing6-1)中的查询：
- en: '[PRE31]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Listing 6-3: Naming and then querying a CTE'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 清单6-3：命名并查询一个CTE
- en: First, you use the `with` keyword to give the CTE a name; here, you define the
    name `winery_portfolio_cte` for the results of the query shown between the parentheses
    ❶. Then you add another query ❷ that uses `winery_portfolio_cte` in a join as
    if it were a table ❸. The results are the same as those of [Listing 6-1](#listing6-1).
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，你使用`with`关键字为CTE命名；在这里，你为查询结果定义了`winery_portfolio_cte`这个名称，查询结果位于括号之间 ❶。然后你添加另一个查询
    ❷，该查询将`winery_portfolio_cte`作为表进行连接 ❸。结果与[清单6-1](#listing6-1)中的查询相同。
- en: 'CTEs and temporary tables both temporarily save the results of a query in a
    table-like format. However, while temporary tables can be used more than once
    (that is, in multiple queries) in a session, CTEs can be used only for the duration
    of the query in which they are defined. After you run [Listing 6-3](#listing6-3),
    try to run another query to select from `winery_portfolio_cte`:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: CTE和临时表都将查询的结果临时保存在类似表的格式中。然而，虽然临时表可以在一个会话中多次使用（即在多个查询中），但CTE只能在定义它的查询生命周期内使用。在运行[清单6-3](#listing6-3)后，尝试运行另一个查询从`winery_portfolio_cte`中选择数据：
- en: '[PRE32]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'You’ll get an error:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 你会遇到一个错误：
- en: '[PRE33]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: MySQL is looking for a *table* named `winery_portfolio_cte`, so it’s no surprise
    it can’t locate your CTE. Besides that, the CTE existed only for the duration
    of your query, so it’s no longer available.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: MySQL正在寻找一个名为`winery_portfolio_cte`的*表*，所以它无法找到你的CTE也就不足为奇了。此外，CTE只在查询期间存在，因此它不再可用。
- en: Recursive Common Table Expressions
  id: totrans-123
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 递归公共表表达式
- en: Recursion is a technique that is used when an object references itself. When
    I think of recursion, I think of Russian nesting dolls. You open the largest doll
    and discover a smaller doll within it; then you open that doll and find an even
    smaller doll within that; and so on until you reach the tiniest doll in the center.
    In other words, to see all the dolls, you start with the largest doll and then
    iterate through each smaller doll until you find a doll that doesn’t contain another
    one.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 递归是一种当对象引用自身时使用的技术。当我想到递归时，我会想到俄罗斯套娃。你打开最大的一个娃娃，发现里面有一个更小的娃娃；然后你打开那个娃娃，发现里面有一个更小的娃娃；依此类推，直到你找到最小的娃娃。换句话说，要查看所有的娃娃，你从最大的娃娃开始，然后依次打开每个更小的娃娃，直到找到一个不包含其他娃娃的娃娃。
- en: Recursion is useful when your data is organized as a hierarchy or a series of
    values where you need to know the previous value to arrive at the current value.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 递归在数据以层次结构或一系列值的形式组织时非常有用，在这种情况下，你需要知道前一个值才能得出当前值。
- en: 'A recursive CTE references itself. Recursive CTEs have two `select` statements
    separated by a `union` statement. Take a look at this recursive CTE called `borg_scale_cte`,
    which contains a series of numbers between 6 and 20:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 递归CTE引用自身。递归CTE包含两个`select`语句，二者之间用`union`语句连接。看看这个名为`borg_scale_cte`的递归CTE，它包含了6到20之间的一系列数字：
- en: '[PRE34]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: First, you define the CTE as `recursive` and name it `borg_scale_cte` ❶. Then,
    the first `select` statement returns the first row containing the number `6` ❷.
    The second `select` statement returns all other rows with values `7` through `20`.
    It continually adds `1` to the `current_count` column and selects the resulting
    numbers ❸, so long as the `current_count` is less than `20` ❹.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，你定义CTE为`recursive`并命名为`borg_scale_cte` ❶。然后，第一个`select`语句返回包含数字`6`的第一行 ❷。第二个`select`语句返回所有其他包含`7`到`20`之间的值的行。它不断地将`current_count`列的值加`1`，并选择得到的数字
    ❸，只要`current_count`小于`20` ❹。
- en: 'In the last line, you use the wildcard character `*` to select all the values
    from the CTE, which returns:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 在最后一行，你使用通配符字符`*`来选择CTE中的所有值，返回的结果是：
- en: '[PRE35]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: You can also use a recursive CTE as if it were a table and join it with other
    tables, for example.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以像使用表一样使用递归CTE，并将其与其他表连接，例如。
- en: Derived Tables
  id: totrans-132
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 派生表
- en: 'Derived tables are an alternative to CTEs for creating a table of results just
    for use within a query. The SQL that creates the derived table goes within parentheses:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 派生表是创建仅供查询使用的结果表的替代方案。创建派生表的SQL放在括号内：
- en: '[PRE36]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: The query within the parentheses produces a derived table aliased as `wot` (short
    for *wineries offering tours*). You can treat `wot` as if it were just another
    table, joining it to the `portfolio` and `wine_type` tables, and selecting columns
    from it. As with a CTE, the derived table is available just for the duration of
    your query.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 括号中的查询生成一个别名为`wot`（即*提供旅游的酒厂*）的派生表。你可以像对待其他表一样将`wot`与`portfolio`和`wine_type`表连接，并从中选择列。与CTE类似，派生表仅在查询执行期间可用。
- en: The choice to use a derived table rather than a CTE is often a matter of style.
    Some developers prefer to use CTEs because they feel CTEs are a more readable
    option. If you need to use recursion, however, you would have to use a CTE.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 选择使用派生表而不是CTE通常是风格问题。一些开发者更喜欢使用CTE，因为他们认为CTE更具可读性。然而，如果你需要使用递归，就必须使用CTE。
- en: Subqueries
  id: totrans-137
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 子查询
- en: 'A subquery (or inner query) is a query nested within another query. A subquery
    is used to return data that will be used by the main query. When a query has a
    subquery, MySQL runs the subquery first, selects the resulting value from the
    database, and then passes it back to the outer query. For example, this SQL statement
    uses a subquery to return a list of all the wine-growing regions in the United
    States from the `wine` database:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 子查询（或内查询）是嵌套在另一个查询中的查询。子查询用于返回主查询将要使用的数据。当查询中包含子查询时，MySQL首先执行子查询，从数据库中选择结果值，然后将其返回给外部查询。例如，这条SQL语句使用子查询从`wine`数据库中返回美国所有葡萄酒种植区的列表：
- en: '[PRE37]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'The result of this query is as follows:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 这个查询的结果如下：
- en: '[PRE38]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'The query has two parts: the outer query ❶ and the subquery ❷. Try running
    the subquery in isolation, without the outer query:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 这个查询有两个部分：外部查询❶和子查询❷。尝试单独运行子查询，而不带外部查询：
- en: '[PRE39]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'The result shows that the `country_id` returned for USA is `3`:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 结果显示，返回的美国`country_id`是`3`：
- en: '[PRE40]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'In your query, `3` is passed from the subquery to the outer query, which makes
    the entire SQL statement evaluate to:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 在你的查询中，`3`从子查询传递到外部查询，这使得整个SQL语句的结果为：
- en: '[PRE41]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'This results in a list of regions for `country_id 3` (`USA`) being returned:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 这会返回`country_id 3`（即美国）地区的列表：
- en: '[PRE42]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: Subqueries That Return More Than One Row
  id: totrans-150
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 返回多行的子查询
- en: 'Subqueries can return more than one row. Here’s the same query as before, this
    time including all countries, not just the USA:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 子查询可以返回多行数据。以下是与之前相同的查询，这次包含了所有国家，而不仅仅是美国：
- en: '[PRE43]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Now the line of the subquery that specifies that you want only USA regions
    is commented out ❷, so the `country_id` for all countries will be returned. When
    you run this query, instead of a list of regions, MySQL returns an error:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，注释掉了指定只获取美国地区的子查询行❷，因此所有国家的`country_id`都会被返回。当你运行这个查询时，MySQL返回一个错误，而不是地区列表：
- en: '[PRE44]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'The problem is that the outer query expects only one row to be returned because
    you used the `=` syntax ❶. Instead, the subquery returns three rows: `country_id`
    `3` for the USA, `1` for France, and `2` for Spain. You should use `=` only when
    there is no possibility that the subquery could return more than one row.'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 问题在于外部查询期望只返回一行数据，因为你使用了`=`语法❶。然而，子查询返回了三行数据：美国的`country_id`为`3`，法国为`1`，西班牙为`2`。你应该只在子查询不可能返回多行数据时使用`=`。
- en: This is a common mistake that you should be mindful of. Many developers have
    written a query that worked when they tested it, but all of a sudden, one day
    it starts producing `Subquery returns more than 1 row` errors. Nothing has changed
    about the query (unlike in this case where a line has been commented out), but
    the data in their database has changed. For example, new rows might have been
    added to a table, and the developer’s subquery now returns multiple rows where
    it used to return one.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个常见的错误，你应该注意。有很多开发者写了一个查询，当他们测试时运行正常，但突然有一天它开始出现`子查询返回多于一行`的错误。查询本身没有变化（不像这个例子中，某行已被注释掉），但是数据库中的数据发生了变化。例如，可能往表中添加了新行，导致开发者的子查询现在返回多行，而以前返回的是一行。
- en: 'To write a query where more than one row can be returned from the subquery,
    you can use the `in` keyword instead of `=`:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想编写一个可以从子查询返回多行的查询，可以使用`in`关键字替代`=`：
- en: '[PRE45]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: Now that you’ve replaced `=` with `in`, the outer query can accept multiple
    rows back from the subquery without error, and you’ll get a list of regions for
    all countries.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已将 `=` 替换为 `in`，外部查询可以接受子查询返回的多行结果，而不会出错，并且你将得到所有国家的地区列表。
- en: Correlated Subqueries
  id: totrans-160
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 关联子查询
- en: In a correlated subquery, a column from a table in the subquery is joined with
    a column from a table in the outer query.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 在关联子查询中，子查询中的表列与外部查询中的表列进行连接。
- en: 'Let’s take a look at two tables called `best_paid` and `employee` in the `pay`
    database. The `best_paid` table shows that the highest salary in the Sales department
    is $200,000, and the highest salary in the Manufacturing department is $80,000:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看 `pay` 数据库中的两个表：`best_paid` 和 `employee`。`best_paid` 表显示，销售部门的最高薪资是 $200,000，制造部门的最高薪资是
    $80,000：
- en: '[PRE46]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'The `employee` table stores a list of employees, their department, and their
    salary:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: '`employee` 表存储了员工列表、他们的部门和薪资：'
- en: '[PRE47]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'You can use a correlated subquery to find the highest-paid employees in each
    department:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用关联子查询来查找每个部门薪水最高的员工：
- en: '[PRE48]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: In the outer query, you select employees and salaries from the `employee` table.
    In the subquery, you join the results of the outer query with the `best_paid`
    table to determine if this employee has the highest salary for their department.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 在外部查询中，你从 `employee` 表中选择员工和薪资。在子查询中，你将外部查询的结果与 `best_paid` 表连接，以确定该员工是否在其部门中拥有最高薪资。
- en: 'The results are:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 结果是：
- en: '[PRE49]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: The results show that Wanda is the highest-paid employee in the Sales department
    and Betty and Sean are tied for the highest salary in the Manufacturing department.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 结果显示，Wanda 是销售部门薪水最高的员工，而 Betty 和 Sean 在制造部门并列最高薪资。
- en: Summary
  id: totrans-172
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, you wrote complex SQL statements using multiple tables. You
    saw how to limit or combine the rows of your results, and you explored several
    different ways to write queries using result sets as if they were tables.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一章中，你编写了使用多个表的复杂 SQL 语句。你了解了如何限制或合并结果行，并探索了多种方式来编写查询，将结果集当作表来使用。
- en: In the next chapter, you’ll compare values in your queries; for example, you’ll
    check that one value is more than another value, compare values that have different
    data types, and check whether a value matches some pattern.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，你将比较查询中的值；例如，你将检查一个值是否大于另一个值，比较不同数据类型的值，并检查某个值是否匹配某个模式。
