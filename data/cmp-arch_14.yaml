- en: '**11**'
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '**11**'
- en: '**RETRO ARCHITECTURES**'
  id: totrans-1
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '**复古架构**'
- en: '![Image](../images/f0245-01.jpg)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/f0245-01.jpg)'
- en: Now that you’ve made it through the theory, let’s have some fun. [Part III](part03.xhtml)
    will consolidate your theoretical knowledge by programming on a series of real,
    emulated architectures. It’s possible to skip around these chapters depending
    on your interests, but they present systems roughly in order of their complexity
    and history, so seeing and programming the earlier systems may help you understand
    the later ones.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经掌握了理论部分，接下来让我们开始一些有趣的实践。[第三部分](part03.xhtml)将通过在一系列真实的模拟架构上编程，来巩固你的理论知识。你可以根据自己的兴趣跳过某些章节，但这些章节大致按照复杂性和历史的顺序呈现，因此查看并编程较早的系统，可能有助于你理解后续的系统。
- en: We previously studied the Analytical Engine and Manchester Baby, and in this
    chapter we’ll progress to 1980s 8-bit and then 16-bit systems. Modern embedded
    systems are somewhat similar to these retro systems, so we’ll work with them in
    the next chapter. We’ll then look at 1990s desktop PCs, followed by modern smart
    and parallel architectures. At each step we’ll introduce new features that have
    stuck around into modern designs.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 我们之前研究过分析机和曼彻斯特婴儿计算机，而在本章中，我们将进阶到1980年代的8位系统，然后是16位系统。现代嵌入式系统与这些复古系统有些相似，因此我们将在下一章对它们进行研究。接下来，我们将研究1990年代的桌面PC，然后是现代智能和并行架构。在每个阶段，我们将介绍一些在现代设计中依然沿用的新特性。
- en: 'The basic structure of the classical CPU didn’t change very much from 1836
    to 1990\. The design served us well, from the Analytical Engine through what’s
    now known as the 1980s golden age of architectures. In this chapter, we’ll look
    at two designs from this golden age: the famous 8-bit 6502, as used in the Commodore
    64, Nintendo Entertainment System (NES), and BBC Micro; and the 16-bit 68000,
    which defined the 16-bit generation of machines, including the Commodore Amiga
    and Sega Megadrive. We’ll study these as relatively simple examples of classical
    CPUs, before things got complicated. These examples should help you to consolidate
    what you’ve learned in the previous chapters, so refer back to them if you need
    to look anything up as you go.'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 从1836年到1990年，经典CPU的基本结构变化不大。这个设计伴随我们走过了从分析机到现在所说的1980年代黄金时代的架构。在本章中，我们将看两个来自这一黄金时代的设计：著名的8位6502处理器，曾用于Commodore
    64、任天堂娱乐系统（NES）和BBC Micro；以及16位68000处理器，它定义了16位机器的一代，包括Commodore Amiga和Sega Megadrive。我们将把这些作为相对简单的经典CPU示例进行研究，了解在事物变得复杂之前的样貌。这些示例将帮助你巩固前面章节所学的内容，因此在进行时如果有任何需要查阅的地方，随时可以回头参考。
- en: Programming in the 1980s Golden Age
  id: totrans-6
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 1980年代黄金时代的编程
- en: Programming in the 1980s was dominated by architecture. The 1980s hardware market
    was highly heterogeneous, with many competing companies designing and producing
    different, incompatible machines. [Figure 11-1](ch11.xhtml#ch11fig1) shows just
    a few of the different machines that came out over the course of the decade.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 1980年代的编程由架构主导。1980年代的硬件市场高度异质化，许多竞争公司设计并生产不同且不兼容的机器。[图11-1](ch11.xhtml#ch11fig1)展示了十年间发布的几款不同机器。
- en: Instead of downloading apps, you could buy magazines full of printed assembly
    code that you would type out to run simple games and applications. Without modern
    operating systems, this code could read and write the machine’s entire memory
    space, so you could see exactly what was going on in your machine and be at one
    with its architecture.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 在没有现代操作系统的情况下，你可以购买满是打印汇编代码的杂志，将其输入以运行简单的游戏和应用程序。这些代码能够读取和写入机器的整个内存空间，因此你可以精确地看到机器中的一切，感受到与其架构的融合。
- en: Computer design companies such as Commodore could produce their own custom ROMs
    at much lower cost using programmable ROMS or PLAs than if they had to do their
    own photolithography, and these technologies were a major enabler of the multitude
    of home computer systems. In today’s language, these ROMs were basic input-output
    systems (BIOSes), collections of subroutines that, for example, print ASCII text
    to the screen; draw points, lines, and triangles; and make sounds. The programmer
    could also perform these tasks directly via I/O—that is, by loading and storing
    directly to I/O module addresses—but subroutines were provided for convenience
    to automate the process. You would call a subroutine on a ROM chip by putting
    the necessary arguments into CPU registers and then doing a jump to the subroutine
    address in the ROM.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 像Commodore这样的计算机设计公司，使用可编程ROM或PLA比起自己进行光刻，能够以更低的成本生产自定义ROM，这些技术是大量家庭计算机系统得以实现的关键。用今天的话来说，这些ROM是基本输入输出系统（BIOS），它们是一些子例程，举个例子，打印ASCII文本到屏幕；绘制点、线和三角形；以及发出声音。程序员也可以通过I/O直接执行这些任务——也就是直接加载和存储到I/O模块地址——但为了方便起见，提供了子例程来自动化这个过程。你可以通过将必要的参数放入CPU寄存器，然后跳转到ROM中的子例程地址，来调用ROM芯片上的子例程。
- en: ROM and RAM were equally important, and they worked together. RAM was a scarce
    resource for user data and user programs that made many calls to the subroutines
    in ROM. In addition to knowing ROM subroutine addresses by heart, programmers
    and communities often had conventions for favorite regions of RAM to use for different
    tasks, so they would generally know their way around the memory map of their whole
    computer.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: ROM和RAM同样重要，它们协同工作。RAM是用户数据和用户程序的宝贵资源，这些程序频繁调用ROM中的子例程。除了记住ROM子例程地址，程序员和社区通常还会为不同任务约定RAM的常用区域，因此他们通常能够熟悉整个计算机的内存映射。
- en: 'Because of these conventions, users had much more direct access to their computers.
    The number of addresses was quite small: 32,768 (32 k[2]B) or 65,536 (64 k[2]B),
    and this meant you could find where variables like the number of lives in a game
    were stored, and then go inside the memory to edit them. Directly overwriting
    memory like this was called a *poke*, and successful pokes were collected onto
    *cheat disks* and passed around to modify games.'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这些约定，用户可以更加直接地访问他们的计算机。地址数量相当小：32,768（32 k[2]B）或65,536（64 k[2]B），这意味着你可以找到像游戏中的生命数量这样的变量存储位置，然后直接进入内存进行编辑。直接覆盖内存的操作被称为*poke*，成功的poke会被收集到*作弊器磁盘*中并传播开来，以修改游戏。
- en: '![Image](../images/f0247-01.jpg)'
  id: totrans-12
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/f0247-01.jpg)'
- en: '*Figure 11-1: Different computers from the 1980s golden age*'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: '*图11-1：1980年代黄金时代的不同计算机*'
- en: '*8-Bit Era*'
  id: totrans-14
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '*8位时代*'
- en: 'The early 1980s was the 8-bit era: this was the time of the Commodore 64 and
    Atari 2600, games consoles like the Sega Master System and Nintendo NES, and the
    British machines BBC Micro and ZX Spectrum.'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 1980年代初期是8位时代：这是Commodore 64和Atari 2600的时代，也是像Sega Master System和Nintendo NES这样的游戏主机时代，还有英国的BBC
    Micro和ZX Spectrum。
- en: Some of these machines shared some subcomponents; for example, the 6502 was
    used in both the Commodore 64 and BBC Micro, and the Spectrum’s Z80 chip could
    be added to the BBC Micro as a second processor, so you could have friends sharing
    programs at this level. But the machines would have different graphics and sound
    chips containing different functions at different addresses that weren’t compatible,
    and typically each machine would have its own friends, user groups, and magazines
    form around it.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 这些机器共享了一些子组件；例如，6502处理器被用于Commodore 64和BBC Micro，而Spectrum的Z80芯片可以作为第二处理器添加到BBC
    Micro中，这样你就可以在这个层面上与朋友分享程序。但这些机器的图形和声音芯片不同，包含不同功能，位于不同的地址上，因此不兼容，通常每台机器都会有自己的朋友、用户组以及围绕它形成的杂志。
- en: Computer graphics and music of this era looked (see [Figure 11-2](ch11.xhtml#ch11fig2))
    and sounded *like computers* because they reflected their architecture, creating
    a computer culture that has been lost today. You could actually feel the 8-bit-ness
    of an 8-bit game in a way that you don’t see 64-bit-ness in contemporary games.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 这个时代的计算机图形和音乐看起来（参见[图11-2](ch11.xhtml#ch11fig2)）和听起来*像计算机*，因为它们反映了计算机的架构，创造了一种今天已经失传的计算机文化。你实际上可以感觉到8位游戏的“8位性”，而今天的64位游戏中却无法感受到那种“64位性”。
- en: '![Image](../images/f0248-01.jpg)'
  id: totrans-18
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/f0248-01.jpg)'
- en: '*Figure 11-2: An example of typical 8-bit game graphics*'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: '*图11-2：典型的8位游戏图形示例*'
- en: Even just playing—rather than writing—games in the golden age could be subliminally
    educational about architecture. Games were usually written specifically to play
    with and explore the architecture, to push it to its limits, and to show off programming
    skills. For example, the 8-bit architecture encouraged games to use certain sizes
    of sprites and certain layouts of levels. You could animate *Space Invaders* easily
    by overwriting the area of memory where the *A* character was defined, replacing
    it with an 8×8 pixel space invader, then just print the *A* character on the screen
    to move it around, without needing any graphics commands. (The downside of this
    was that when you listed your program to debug it afterward, all the *A*s had
    also changed into space invaders.)
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 即便只是玩游戏——而不是编写——也能潜移默化地学到架构知识。游戏通常是专门为了与架构互动和探索架构而编写的，目的是将其推到极限，并展示编程技巧。例如，8位架构鼓励游戏使用特定尺寸的精灵和特定布局的关卡。你可以通过覆盖内存中定义字符*A*的区域，将其替换为一个8×8像素的外星人，从而轻松地给*Space
    Invaders*动画，而无需任何图形命令。然后，只需将*A*字符打印到屏幕上，就能移动它。（这样做的缺点是，当你列出程序进行调试时，所有的*A*也会变成外星人了。）
- en: '*16-Bit Era*'
  id: totrans-21
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '*16位时代*'
- en: The late 1980s introduced 16-bit machines and continued this style of assembly
    programming, but with the extra bits and more advanced I/O modules enabling a
    move to *sampling* of images and sounds rather than their pure computer generation,
    as on 8-bit machines. These developments gave rise to the distinctive 16-bit aesthetics
    of sprite-based games like *Sonic* and *Mario* ([Figure 11-3](ch11.xhtml#ch11fig3)),
    and sample-based music by artists such as The Prodigy and the soundtracks of games
    such as *Streets of Rage 2*.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 1980年代末期推出了16位机器，并延续了这种汇编编程风格，但额外的位数和更先进的I/O模块使得图像和声音的*采样*成为可能，而不再像8位机器那样纯粹由计算机生成。这些发展催生了具有鲜明16位美学的精灵式游戏，比如*Sonic*和*Mario*（[图11-3](ch11.xhtml#ch11fig3)），以及The
    Prodigy等艺术家创作的基于采样的音乐和如*Streets of Rage 2*等游戏的原声带。
- en: '![Image](../images/f0249-01.jpg)'
  id: totrans-23
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/f0249-01.jpg)'
- en: '*Figure 11-3: An example of typical 16-bit game graphics*'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: '*图11-3：典型16位游戏图形示例*'
- en: Popular machines included the Commodore Amiga, Atari ST, Sega Megadrive, and
    Nintendo SNES. High-performance programs such as games and demos were still mostly
    written in assembly, with full access to memory, but they would make heavier use
    of calls to additional graphics and sound hardware.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 流行的机器包括Commodore Amiga、Atari ST、Sega Megadrive和Nintendo SNES。像游戏和演示程序等高性能程序仍然主要用汇编语言编写，能够完全访问内存，但它们会更多地使用对额外图形和声音硬件的调用。
- en: Companies continued to produce 16-bit machines into the early 1990s, including
    for many now-classic games. But by this time most programmers had shifted to the
    C language, which could compile into assembly code for multiple machines, making
    it easier to port software between them. Programmers came to rely more on heavyweight
    operating systems, also accessed primarily via C libraries. Together, C and operating
    systems acted to wrap and hide architecture, presenting higher-level and more
    portable interfaces to the machines, but ending the 1980s golden age of architecture-based
    programming.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 各公司继续在1990年代初期生产16位机器，包括许多如今已经成为经典的游戏。但此时大多数程序员已转向使用C语言，它能够编译成多个机器的汇编代码，使得在不同平台间移植软件变得更加容易。程序员们开始更多依赖重量级操作系统，这些操作系统主要通过C库进行访问。C语言和操作系统共同作用，封装并隐藏了硬件架构，提供了更高级且更便携的接口，但也终结了1980年代架构编程的黄金时代。
- en: Good times! Let’s relive them here by learning to program on two classic systems
    from the period, the 8-bit 6502-based Commodore 64 (C64) and the 16-bit 68000-based
    Commodore Amiga. For each system, we’ll first study its CPU in isolation, then
    its wider computer design. In the exercises, we’ll write assembly programs for
    a C64 animated text demo and a simple Amiga game.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 美好的时光！让我们通过在两个经典系统上学习编程来重温这些时光：8位6502架构的Commodore 64（C64）和16位68000架构的Commodore
    Amiga。对于每个系统，我们首先会独立学习其CPU，然后研究它的计算机设计。在练习中，我们将编写C64动画文本演示和简单的Amiga游戏的汇编程序。
- en: Working with the MOS 6502 8-Bit CPU
  id: totrans-28
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用MOS 6502 8位CPU进行编程
- en: 'MOS Technology’s MOS 6502 was an 8-bit processor, designed in 1975 by Chuck
    Peddle. *MOS* stands for *metal-oxide semiconductor*, as in the MOS field-effect
    transistors, or MOSFETs, used by the company. The 6502 was used in many of the
    classic 8-bit micros of the 1980s: the Commodore 64, NES, Atari 2600, Apple II,
    and BBC Micro; it was also used in first-generation arcade machines such as *Asteroids*.'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: MOS科技的MOS 6502是一个8位处理器，由Chuck Peddle于1975年设计。*MOS*代表*金属氧化物半导体*，指的是公司使用的MOS场效应晶体管（MOSFET）。6502在1980年代许多经典的8位微型计算机中得到了应用：如Commodore
    64、NES、Atari 2600、Apple II和BBC Micro；它还被用于第一代街机游戏机，如*Asteroids*。
- en: Here we’ll study the 6502 using the same steps as for the Analytical Engine
    and Manchester Baby. We’ll first examine its structures, including registers,
    the arithmetic logic unit (ALU), the decoder, and the control unit (CU). We’ll
    then look at its instruction set, including instructions for memory access, arithmetic,
    and control flow.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们将通过与分析引擎（Analytical Engine）和曼彻斯特宝宝（Manchester Baby）相同的步骤来研究6502。我们将首先检查其结构，包括寄存器、算术逻辑单元（ALU）、解码器和控制单元（CU）。然后我们将研究其指令集，包括内存访问、算术运算和控制流的指令。
- en: '*Internal Subcomponents*'
  id: totrans-31
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '*内部子组件*'
- en: The 6502 had 3,000 transistors and wires connecting them. The layout of these
    components was designed and drawn by hand on transparent sheets, with pens and
    masking tape, and then made directly into chips using photolithography.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 6502有3000个晶体管和连接它们的导线。这些组件的布局是通过透明纸张手工设计并绘制的，使用钢笔和胶带，然后通过光刻技术直接制作成芯片。
- en: '**NOTE**'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*The term* taping out *is still used to refer to the equivalent modern computerized
    process of finalizing photolithography mask designs. For chip designers, a tape-out
    marks the end of their work and handover to a fab plant. Like “shipping” for software
    companies, taping out can be a reason to have a large party, lasting until the
    chips arrive in the mail and fail to work.*'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: '*“Taping out”*一词仍然用于指代现代计算机化的光刻掩模设计完成过程。对于芯片设计师来说，taping out标志着他们工作的结束，并交接给制造厂。就像软件公司中的“发布”一样，taping
    out也是举办大型派对的理由，直到芯片通过邮寄到达并无法正常工作为止。'
- en: Physically, the 6502 appears as a plastic-packaged integrated circuit (IC) about
    2 cm long, with 40 pins, as seen in [Figure 9-2](ch09.xhtml#ch09fig2). Eight of
    these are data pins, labeled D0 through D7\. These pins read and write 8-bit words
    of data to and from memory, and they define the CPU as an 8-bit machine. The 6502
    uses a 16-bit address space accessed by writing 16-bit addresses on the 16 address
    pins, A0 through A15\. This enables up to 64 k[2]B to be addressed. The R/W is
    the control line that specifies whether we want to read or write to the address.
    The package also has pins for ground and supply voltage, a clock, and an IRQ (interrupt
    request) line. The clock sets the speed of the CPU, usually to around 1 to 3 MHz.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 物理上，6502呈现为一个长约2厘米的塑料封装集成电路（IC），有40个引脚，如[图9-2](ch09.xhtml#ch09fig2)所示。这些引脚中有8个是数据引脚，标记为D0到D7。这些引脚用于读取和写入8位数据字到内存中，也定义了CPU为8位机器。6502使用一个16位的地址空间，通过在16个地址引脚A0到A15上写入16位地址来进行访问。这使得最多可以寻址64
    k[2]B的内存。R/W是控制线，指示我们是否要读取或写入地址。封装还具有地线、供电电压、时钟和IRQ（中断请求）引脚。时钟设定CPU的速度，通常为1到3
    MHz之间。
- en: The actual silicon chip is much smaller than the outer package, about 5 mm².
    [Figure 11-4](ch11.xhtml#ch11fig4) shows a photograph of the chip under a microscope
    (known as a *die shot*).
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 实际的硅芯片比外包装小得多，约为5 mm²。[图11-4](ch11.xhtml#ch11fig4)展示了芯片在显微镜下的照片（称为*晶片图*）。
- en: '![Image](../images/f0251-01.jpg)'
  id: totrans-37
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/f0251-01.jpg)'
- en: '*Figure 11-4: A 6502 chip microscope photograph*'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: '*图11-4：6502芯片显微镜照片*'
- en: Details of this chip’s design were lost for several decades, but they were recently
    fully reverse engineered at the transistor level in a heroic effort by the Visual
    6502 project (*[http://visual6502.org](http://visual6502.org)*). The workers on
    this project exposed the silicon by applying acid to dissolve some of the plastic
    casing. They then took die shots of the chip to reverse engineer its circuit diagram.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 这个芯片的设计细节在几十年间丢失，但最近在Visual 6502项目中通过英雄般的努力，成功地在晶体管级别进行了完全的逆向工程 (*[http://visual6502.org](http://visual6502.org)*)。该项目的工作人员通过施加酸性物质溶解部分塑料外壳来暴露硅片，然后拍摄芯片的晶片图像，逆向工程其电路图。
- en: The circuit contains only transistors and copper wires, but some very skilled
    chip-reading people have learned to look at these and mentally chunk them into
    logic gates. From there, they were chunked into well-known simple machines. This
    painstaking process, guided by the surviving block diagram shown in [Figure 11-5](ch11.xhtml#ch11fig5),
    enabled the whole architecture to be reverse engineered and reconstructed.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 该电路仅包含晶体管和铜线，但一些非常擅长芯片阅读的人已经学会了如何观察这些电路并将它们在脑中分块成逻辑门。从那里，它们被分块成著名的简单机器。通过这项艰苦的工作，借助[图
    11-5](ch11.xhtml#ch11fig5)所示的生还区块图，这整个架构得以反向工程并重建。
- en: '![Image](../images/f0252-01.jpg)'
  id: totrans-41
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/f0252-01.jpg)'
- en: '*Figure 11-5: The original 6502 block diagram*'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 11-5：原始6502区块图*'
- en: The circuit in [Figure 11-5](ch11.xhtml#ch11fig5) shows some recognizable subcomponents
    that are common to most classic-design chips. Each component is a digital logic
    simple machine. We’ll examine each of the main subcomponents in turn.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 11-5](ch11.xhtml#ch11fig5)中的电路展示了一些典型的子组件，这些组件在大多数经典设计的芯片中都很常见。每个组件都是一个数字逻辑简单机器。我们将逐一检查这些主要的子组件。'
- en: '**THE MONSTER 6502**'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: '**怪兽6502**'
- en: As a result of the Visual 6502 project, the 6502 is now being manufactured again
    for use as a cheap, embedded processor—for example, in Internet of Things (IoT)
    devices—as well as for education, such as our present study. The design was also
    used by Eric Schlaepfer and Evil Mad Scientist Laboratories to create a fully
    functioning—but slower than the original—MOnSter 6502 rebuild from big transistors
    rather than ICs, shown here.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 由于视觉6502项目的成果，6502现在再次被生产出来，用作廉价的嵌入式处理器——例如，在物联网（IoT）设备中——以及用于教育，比如我们目前的研究。该设计还被Eric
    Schlaepfer和Evil Mad Scientist Laboratories用来制造一个完全功能性的、但比原版慢的MOnSter 6502重建版，这个版本使用了大晶体管而非集成电路（ICs），如下所示。
- en: '![Image](../images/f0253-01.jpg)'
  id: totrans-46
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/f0253-01.jpg)'
- en: '**User Registers**'
  id: totrans-47
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**用户寄存器**'
- en: 'In [Figure 11-4](ch11.xhtml#ch11fig4) the registers and ALU are the regular
    area in the lower half of the chip. The 8 bits are stacked vertically, as in Babbage’s
    machines. There are three 8-bit user registers: two general-purpose ones called
    X and Y, and an accumulator called A.'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 在[图 11-4](ch11.xhtml#ch11fig4)中，寄存器和算术逻辑单元（ALU）位于芯片的下半部分。8位数据按垂直堆叠排列，类似于巴贝奇的机器。有三个8位用户寄存器：两个通用寄存器，分别称为
    X 和 Y，以及一个称为 A 的累加器。
- en: The X and Y registers are intended to be usable together to represent 16-bit
    addresses, with the first 8 of the 16 bits stored in X and the second 8 bits stored
    in Y. It’s quite hard work to manipulate the two halves separately, so the architecture
    often provides methods to manipulate the two 8-bit halves of 16-bit addresses
    together.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: X和Y寄存器设计为可以一起使用，表示16位地址，其中前8位存储在X中，后8位存储在Y中。单独操作这两部分比较困难，因此架构通常提供方法，能够一起操作这两个8位部分的16位地址。
- en: It’s common to imagine and visualize 8-bit memory as divided into 256 pages
    of 256 bytes each. For example, 8-bit hex editors may display one page of memory
    on the screen at a time, like the pages of a book. Viewed this way, one of the
    two bytes is the page number and the other says what line on the page is used.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 通常将8位内存想象成被划分为256页，每页256字节。例如，8位十六进制编辑器可能一次在屏幕上显示一页内存，就像一本书的页面那样。以这种方式看，其中一个字节是页码，另一个字节表示该页上使用的是哪一行。
- en: '**NOTE**'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*It’s common 6502 programming practice to use the 256 addresses in page 0 of
    memory as if they were additional registers. This is slower than using actual
    registers, so A, X, and Y are preferred in the first instance.*'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: '*在6502编程实践中，通常使用内存第0页的256个地址，仿佛它们是额外的寄存器。这样比使用实际寄存器要慢，因此在首选情况下，还是使用A、X和Y寄存器。*'
- en: '**Internal Registers**'
  id: totrans-53
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**内部寄存器**'
- en: Recall that the program counter keeps track of the current line number. Here,
    the program counter stores a 2 byte address. It’s automatically incremented by
    the CU after executing each instruction, unless it’s a flow control instruction.
    It can be accessed as 2 individual bytes (PCH, PCL) storing the high and low parts
    of the 16-bit address. On power-up, the 6502 copies the content of addresses FFFC
    and FFFD (usually ROM, and pointing to a ROM subroutine) into the program counter
    to tell it where to begin executing.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 回想一下，程序计数器用于跟踪当前行号。此处，程序计数器存储一个2字节地址。它在执行每条指令后，由控制单元（CU）自动递增，除非是流程控制指令。它可以作为两个独立的字节（PCH，PCL）访问，分别存储16位地址的高位和低位。在开机时，6502将FFFC和FFFD地址的内容（通常是ROM，并指向一个ROM子程序）复制到程序计数器中，指示程序从哪里开始执行。
- en: Here, the stack pointer is a single byte, and it’s assumed to refer to lines
    on page 1 of memory; note this is the second page, after page 0\. In most programming
    styles, the stack isn’t accessed directly by the programmer, but rather is used
    internally by the subroutine instructions to push and pop the address of the calling
    line. However, it can also be accessed directly using instructions (`PHA` and
    `PLA`) that push and pop the contents of the accumulator to and from the stack.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，堆栈指针是一个字节，它被假定为指向内存第1页的行；注意这是第二页，紧跟着第0页。在大多数编程风格中，堆栈不是由程序员直接访问的，而是由子程序指令内部使用，用于推入和弹出调用行的地址。然而，它也可以通过指令（`PHA`
    和 `PLA`）直接访问，这些指令将累加器的内容推入和弹出堆栈。
- en: 'The instruction register holds a copy of the current instruction; in the 6502,
    opcodes are 8 bits long and may require 0, 1, or 2 bytes of operand. Because the
    data bus is 8-bit, fetching instructions usually requires several steps; the opcode
    and operand need to be copied in one byte at a time. This is one of the reasons
    why 8-bit machines are slow: machines with larger word lengths could fetch whole
    instructions, including opcodes and operands, as single words.'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 指令寄存器保存当前指令的副本；在6502中，操作码为8位，可能需要0、1或2个字节的操作数。由于数据总线是8位的，因此获取指令通常需要多个步骤；操作码和操作数需要逐字节复制。这是8位机器速度较慢的原因之一：具有较大字长的机器可以将整个指令（包括操作码和操作数）作为单个字取出。
- en: The status register holds 8 bits of flags that can be tested and used by control
    flow instructions. These are set in the ALU, which we’ll turn to next.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 状态寄存器包含8位标志，可以被控制流指令测试和使用。这些标志在ALU中设置，我们接下来将讨论它。
- en: '**Arithmetic Logic Unit**'
  id: totrans-58
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**算术逻辑单元**'
- en: In the 6502, the ALU is physically built around the registers so that the 8
    bits flow horizontally, as in Babbage’s machines. The registers-ALU area looks
    a lot like Babbage’s Difference Engine, and contains a similar parallel propagation
    of bits and carries. If you miniaturized Babbage’s metal machine onto a chip,
    this is pretty much what it would look like; only the scale has changed.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 在6502中，ALU的物理结构围绕寄存器构建，使得8位数据水平流动，就像巴贝奇的机器一样。寄存器-ALU区域看起来很像巴贝奇的差分机，并且包含类似的并行传播位和进位。如果你把巴贝奇的金属机器微型化到一块芯片上，它的外观大致就是这样；只是尺度发生了变化。
- en: The ALU provides integer addition and subtraction simple machines, activated
    by instructions (`ADC`, `SBC`), along with dedicated increment and decrement (`INC`,
    `DEC`). There are bitshifts and bitwise Boolean instructions (`ASL,` `ASR; AND,
    ORA, EOR`). There are no multiplication or division instructions—these must be
    constructed in software from what’s available. There is also no floating point.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: ALU提供整数加法和减法简单运算，通过指令（`ADC`、`SBC`）激活，以及专门的增量和减量指令（`INC`、`DEC`）。还有位移和按位布尔运算指令（`ASL`、`ASR`；`AND`、`ORA`、`EOR`）。没有乘法或除法指令——这些必须通过可用的软件来构建。同时也没有浮动点运算。
- en: '[Figure 11-6](ch11.xhtml#ch11fig6) shows the ALU’s assigned meanings of the
    bits in the status register, which are written as side effects of its operations.'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: '[图11-6](ch11.xhtml#ch11fig6)显示了ALU在状态寄存器中分配的位的含义，这些位是作为其操作的副作用写入的。'
- en: '![Image](../images/f0255-01.jpg)'
  id: totrans-62
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/f0255-01.jpg)'
- en: '*Figure 11-6: The status register flags*'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: '*图11-6：状态寄存器标志*'
- en: The ALU’s operations include flagging if the result was zero (Z) or negative
    (N), if there was an overflow (V), and if there was a carry (C).
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: ALU的操作包括标记结果是否为零（Z）或负数（N），是否发生溢出（V），以及是否有进位（C）。
- en: '**Decoder**'
  id: totrans-65
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**解码器**'
- en: In [Figure 11-4](ch11.xhtml#ch11fig4), the decoder is visible in the upper one-fifth
    of the die shot as a semi-regular binary structure. It looks like a load of binary
    numbers stored in an array, which is pretty much what it is. Opcodes are 8 bits,
    meaning that 256 distinct instructions are possible. Each opcode is decoded and
    used to activate a control line.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 在[图11-4](ch11.xhtml#ch11fig4)中，解码器位于芯片照片的上五分之一处，呈现为半规则的二进制结构。它看起来像是存储在数组中的大量二进制数字，实际上就是这样。操作码为8位，意味着最多可以有256条不同的指令。每个操作码都会被解码并用于激活控制线。
- en: '**Control Unit**'
  id: totrans-67
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**控制单元**'
- en: In [Figure 11-4](ch11.xhtml#ch11fig4), the CU forms the middle region of the
    chip. It appears visually as a highly irregular region. This is because every
    operation is different, so it’s implemented with entirely different circuitry.
    The 6502 CU often needs to do more work than later 16-bit machines, because the
    6502 operates with 16-bit address and sometimes 16- or 24-bit instructions, which
    the CU has to break up into 8-bit chunks and marshal over the 8-bit bus.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 在[图 11-4](ch11.xhtml#ch11fig4)中，CU 形成了芯片的中间区域。它在视觉上呈现为一个非常不规则的区域。这是因为每个操作都不同，因此它是用完全不同的电路实现的。6502
    的 CU 通常需要比后来的 16 位机器做更多的工作，因为 6502 使用 16 位地址，并且有时使用 16 位或 24 位指令，CU 必须将它们分解成 8
    位的块，并通过 8 位总线传输。
- en: '*Programmer Interface*'
  id: totrans-69
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '*程序员接口*'
- en: '[Figure 11-7](ch11.xhtml#ch11fig7) shows the complete instruction set for the
    6502.'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 11-7](ch11.xhtml#ch11fig7) 显示了 6502 的完整指令集。'
- en: '![Image](../images/f0256-01.jpg)'
  id: totrans-71
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/f0256-01.jpg)'
- en: '*Figure 11-7: The complete 6502 instruction set. For full definitions of these
    instructions, see* [https://en.wikibooks.org/wiki/6502_Assembly](https://en.wikibooks.org/wiki/6502_Assembly).'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 11-7：完整的 6502 指令集。欲了解这些指令的完整定义，请参见* [https://en.wikibooks.org/wiki/6502_Assembly](https://en.wikibooks.org/wiki/6502_Assembly)。'
- en: Because opcodes are 8-bit, there’s space for 256 instructions; notice, though,
    that the instruction set architecture contains a few less, so there are some gaps
    in the table.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 由于操作码是 8 位的，因此有空间容纳 256 条指令；然而，指令集架构实际上包含的指令略少，所以表格中有一些空隙。
- en: '**Load and Store**'
  id: totrans-74
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**加载与存储**'
- en: 'Loading (`LD`) to and storing (`ST`) from the three user registers (X, Y, and
    A) is done using instructions such as:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 从三个用户寄存器（X、Y 和 A）加载（`LD`）和存储（`ST`）是通过以下指令完成的：
- en: '[PRE0]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Offset addressing enables the value of a user register to be used as an offset
    to a given address. This is useful for iterating over arrays. For example:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 偏移寻址使得用户寄存器的值可以作为偏移量应用到给定的地址。这对于遍历数组非常有用。例如：
- en: '[PRE1]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Indirect addressing allows us to specify an address that in turns holds another
    address where we actually want to load or store:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 间接寻址允许我们指定一个地址，这个地址包含另一个我们实际想要加载或存储的地址：
- en: '[PRE2]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Indirection and offsetting can be used together, such as:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 间接寻址和偏移可以一起使用，例如：
- en: '[PRE3]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '*Zero-paging* is the 6502 convention that page 0 of memory is intended to function
    similarly to 256 additional registers. This requires specifying and moving around
    only 1 byte of address, as in:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: '*零页* 是 6502 的约定，表示内存的第 0 页功能类似于额外的 256 个寄存器。这要求仅指定并移动 1 字节的地址，如下所示：'
- en: '[PRE4]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: This is faster than moving 2 bytes around individually.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 这比单独移动 2 字节更快。
- en: '**Arithmetic**'
  id: totrans-86
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**算术**'
- en: 'The `ADC` instruction means “add data with carry.” It adds the integer contents
    of its address operand, and the carry bit from the status register, to the accumulator.
    The following program should end with hex value 0A[16] (decimal 10) in the accumulator:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: '`ADC` 指令表示“带进位的加法”。它将地址操作数的整数内容与状态寄存器中的进位位加到累加器中。以下程序应该以累加器中十六进制值 0A[16]（十进制
    10）结束：'
- en: '[PRE5]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '`CLC` clears the carry flag; it’s important to do this before any new addition,
    unless you want the carry from a previous operation to get added in as well.'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: '`CLC` 清除进位标志；在进行任何新的加法之前，清除进位是很重要的，除非你希望将前一个操作的进位也加上。'
- en: 'To add two 16-bit integers, we can make use of the carry status flag state,
    instead of clearing it. Each `ADC` reads and writes it, so we can split a 16-bit
    addition into a pair of two 8-bit additions with a carry. Here, the two inputs,
    `num1` and `num2`, and the output, `result`, are each split into low and high
    bytes:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 要添加两个 16 位整数，我们可以利用进位状态标志的状态，而不是将其清除。每次 `ADC` 操作都会读取和写入进位标志，因此我们可以将 16 位加法拆分为两次
    8 位加法，并带上进位。这里，两个输入 `num1` 和 `num2` 以及输出 `result` 都被分为低字节和高字节：
- en: '[PRE6]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Similarly, `SBC` is “subtract with carry,” so the following computes 7 – 3,
    resulting in the value 4 in the accumulator:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 类似地，`SBC` 是“带借位的减法”，所以以下代码计算 7 – 3，结果是累加器中的值为 4：
- en: '[PRE7]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'We can increment (`INC` or `IN`) and decrement (`DEC` or `DE`) both address
    and register contents with instructions such as:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用指令，如：`INC` 或 `IN` 来递增地址和寄存器内容，使用 `DEC` 或 `DE` 来递减。
- en: '[PRE8]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Here again, # denotes that the operand is a constant, with the other operands
    being addresses.'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，# 表示操作数是常量，其他操作数是地址。
- en: '**Jump and Branches**'
  id: totrans-97
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**跳转与分支**'
- en: '`JMP` is the jump instruction. The following program continually increments
    register X, which will overflow after FF[16], going back to 00[16]:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: '`JMP` 是跳转指令。以下程序不断递增寄存器 X，当其超过 FF[16] 时，会回绕至 00[16]：'
- en: '[PRE9]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Instead of specifying the line number to jump to—as a BASIC programmer of the
    era might—this notation first marks the destination line with a *label*—in this
    case, `mylabel`—then specifies the name of this label in the jump instruction.
    The label line doesn’t compile to machine code; it’s ignored when first seen by
    the assembler. But when the assembler sees the label again in the jump instruction,
    it replaces it with the address of the instruction following the label.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 与当时的BASIC程序员可能直接指定跳转的行号不同，这种符号首先用一个*标签*标记目标行——在这个例子中是`mylabel`——然后在跳转指令中指定这个标签的名称。标签行不会被编译成机器码；当汇编器首次看到它时，它会被忽略。但是，当汇编器在跳转指令中再次看到标签时，它会将其替换为标签后面指令的地址。
- en: 'Conditional branching can be done in two stages. First, comparison instructions
    check if some condition is true and store the result in the status register. Then,
    branch instructions consult the status register to decide when to branch. For
    example, the following uses register X to count down from 5 to 2 then halt, by
    comparing X to 2 (`CPX`) and branching if the comparison isn’t equal (`BNE`):'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 条件分支可以分为两个阶段。首先，比较指令检查某个条件是否为真，并将结果存储在状态寄存器中。然后，分支指令会查询状态寄存器，以决定何时分支。例如，以下程序使用寄存器X从5递减到2，然后停止，通过将X与2进行比较（`CPX`），如果不相等则跳转（`BNE`）：
- en: '[PRE10]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'You can also branch (`B`) if the comparison was equal (`BEQ`), negative (on
    minus, `BMI`), or positive (on plus, `BPL`). Or if the carry (`C`) or overflow
    (`V`) flag is clear (`C`) or set (`S`): `BCC`, `BVC`, `BCS`, `BVS`, respectively.'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以根据比较结果进行分支（`B`），例如如果相等则跳转（`BEQ`），负值（即负数，`BMI`），或正值（即正数，`BPL`）。或者，如果进位标志（`C`）或溢出标志（`V`）为清除（`C`）或设置（`S`）：分别使用`BCC`、`BVC`、`BCS`、`BVS`。
- en: '**Subroutines**'
  id: totrans-104
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**子程序**'
- en: '`JSR` and `RTS` jump to and return from a subroutine, respectively. For example,
    the following program uses a common convention of placing arguments for a subroutine
    into addresses at the start of memory, which are then picked up by the subroutine
    code. `BRK` is “break,” roughly the 6502’s halt instruction (actually an interrupt).
    It’s needed to prevent the main program execution overrunning into the code of
    the subroutine after it.'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: '`JSR`和`RTS`分别是跳转到子程序和从子程序返回的指令。例如，以下程序使用一种常见约定，将子程序的参数放入内存起始地址中，然后由子程序代码取出。`BRK`是“中断”指令，类似于6502的停止指令（实际上是一个中断）。它用于防止主程序执行时超出子程序的代码区域。'
- en: '[PRE11]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: In the exercises, you’ll see how to run the above and similar examples on an
    emulated standalone 6502\. A 6502 by itself isn’t very exciting, though. We need
    a computer design to add memory and I/O to the CPU, so now let’s zoom out from
    the 6502 and look at a complete computer design, the Commodore 64, based upon
    it.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 在练习中，你将看到如何在模拟的独立6502上运行上述以及类似的示例。单独的6502并不是特别激动人心，我们需要设计一个计算机系统来为CPU增加内存和I/O功能，因此现在让我们从6502的视角缩小，来看一看基于6502的完整计算机设计——Commodore
    64。
- en: 8-Bit Computer Design with the Commodore 64
  id: totrans-108
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 基于Commodore 64的8位计算机设计
- en: The 6502-based Commodore 64, or C64, was and still is the highest-selling computer
    model of all time. Released in 1982, it defined the 8-bit home computing market
    in most of the world by combining gaming features with the potential for business
    and creative applications. Commodore was so named because its founder, the colorful
    Holocaust survivor Jack Tramiel, originally wanted “General Computers,” like “General
    Electric,” but “General” was taken. Commodore is a lower, second-choice rank below
    general. The C64 board was shown previously in [Figure 9-1](ch09.xhtml#ch09fig1).
    Its name comes from the fact that it used the full 64 k[2]B of available memory
    from its 16-bit address space with 8-bit words (2^(16) addresses × 8 bits = 64
    k[2]B), unlike some other 6502-based machines.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 基于6502的Commodore 64（C64）是有史以来销量最高的计算机型号。它于1982年发布，通过将游戏功能与商业和创意应用的潜力结合，定义了全球大部分地区的8位家用计算机市场。Commodore这个名字源于它的创始人、充满传奇的二战幸存者Jack
    Tramiel，他原本想取名为“General Computers”，就像“General Electric”一样，但“General”已经被使用。Commodore比General低一级，是一个次选的等级。C64的电路板在[图9-1](ch09.xhtml#ch09fig1)中已经展示过。它的名字来自于它使用了其16位地址空间中的64
    k[2]B可用内存，采用8位字（2^(16)个地址 × 8位 = 64 k[2]B），与其他一些基于6502的机器不同。
- en: '*Understanding the Architecture*'
  id: totrans-110
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '*理解架构*'
- en: MOS produced several variants of the 6502 and assigned different model numbers
    to each. As with 7400 logic chips, “6502” is thus ambiguous, sometimes used to
    mean the original, numbered CPU design, and other times referring to all members
    of the family, which each have related numbers. The 6502 family member used in
    the Commodore 64 is more precisely known as the 6510.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: MOS 生产了几种 6502 的变体，并为每个变体分配了不同的型号。与 7400 逻辑芯片类似，"6502" 是一个模糊的术语，有时指的是原始的编号 CPU
    设计，有时则指所有该家族的成员，每个成员都有相关的编号。用于 Commodore 64 的 6502 家族成员更准确地称为 6510。
- en: In addition to a full 64 k[2]B of actual RAM, the C64 also added devices, I/O
    modules, and their own ROMs containing libraries of subroutines for talking to
    them (what we now call a BIOS). It’s this configuration that differentiates the
    C64 from other 6502-based machines as a programming platform.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 除了具有完整的 64 k[2]B 实际 RAM 外，C64 还增加了设备、I/O 模块及其包含与设备通信的子程序库的 ROM（我们现在称之为 BIOS）。正是这种配置使得
    C64 在编程平台上与其他基于 6502 的机器有所不同。
- en: The physical board layout is connected as in the block diagram of [Figure 11-8](ch11.xhtml#ch11fig8).
    The bus—consisting of 16-bit addressing and 8-bit data—dominates this diagram
    and connects the CPU, RAM, ROM, and I/O.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 物理板布局与 [图 11-8](ch11.xhtml#ch11fig8) 的框图连接。总线——由 16 位寻址和 8 位数据组成——主导了该图，并连接了
    CPU、RAM、ROM 和 I/O。
- en: '![Image](../images/f0261-01.jpg)'
  id: totrans-114
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/f0261-01.jpg)'
- en: '*Figure 11-8: A C64 block diagram*'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 11-8：C64 框图*'
- en: '[Figure 11-9](ch11.xhtml#ch11fig9) shows the memory map for the C64.'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 11-9](ch11.xhtml#ch11fig9) 显示了 C64 的内存映射。'
- en: '![Image](../images/f0262-01.jpg)'
  id: totrans-117
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/f0262-01.jpg)'
- en: '*Figure 11-9: A C64 memory map*'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 11-9：C64 内存映射*'
- en: In this memory map, the RAM, ROM, and I/O are each assigned address ranges within
    the 16-bit address space. The I/O address space is broken down into ranges used
    by individual I/O modules and chips. (Because address space was a scarce resource
    at this time, the C64 enables the programmer to temporarily disconnect the ROMs
    from it and mount additional RAM in their place.)
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 在此内存映射中，RAM、ROM 和 I/O 分别在 16 位地址空间内分配了地址范围。I/O 地址空间被划分为各个 I/O 模块和芯片使用的范围。（因为在当时地址空间是稀缺资源，所以
    C64 使程序员能够暂时断开 ROM，将额外的 RAM 挂载到其位置。）
- en: '**PETSCII CHARACTERS**'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: '**PETSCII 字符**'
- en: The Commodore 64 extended ASCII differently from Unicode, into a now dead branch
    of evolution called PETSCII, by using the first digit as a “shift” character and
    defining a second set of ASCII-like symbols. It also defined new visual symbols
    in the unshifted sector in place of control codes, including the C64’s iconic
    playing card symbols and bitmap graphic elements used for drawing and shown here.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: Commodore 64 以不同于 Unicode 的方式扩展了 ASCII，采用了现在已不再使用的 PETSCII 字符集，通过将第一个数字作为“移位”字符，并定义了第二组类似
    ASCII 的符号。它还在未移位区定义了新的视觉符号，代替了控制代码，包括 C64 标志性的扑克牌符号和用于绘图的位图图形元素，如图所示。
- en: '![Image](../images/f0262-02.jpg)'
  id: totrans-122
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/f0262-02.jpg)'
- en: '*Programming the C64*'
  id: totrans-123
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '*C64 编程*'
- en: Programming the C64 is done in 6502 assembly as discussed in the “Programmer
    Interface” section on [page 255](ch11.xhtml#lev217), but with added interactions
    with the particular ROMs and I/O modules mounted in the address space. The ROMs
    contain libraries of Commodore’s own subroutines (known as “KERNAL,” with an A).
    I/O includes a memory-mapped screen display that can be switched between character
    and pixel modes. Character mode allows PETSCII characters to be drawn at screen
    locations by writing their codes directly into this memory space. The state of
    the keyboard can be read by reading its memory-mapped space, but ROM subroutines
    are provided to simplify this process and decode its state to PETSCII character
    codes.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: C64 的编程使用 6502 汇编语言，如在 [第 255 页](ch11.xhtml#lev217)“程序员接口”部分讨论的那样，但它还与特定的 ROM
    和 I/O 模块进行交互，这些模块在地址空间中被挂载。ROM 包含 Commodore 自己的子程序库（称为“KERNAL”，带 A）。I/O 包括一个内存映射的屏幕显示，可以在字符模式和像素模式之间切换。字符模式允许通过将
    PETSCII 字符的代码直接写入该内存空间，在屏幕位置绘制 PETSCII 字符。可以通过读取键盘的内存映射空间来读取键盘状态，但提供了 ROM 子程序来简化此过程并将其状态解码为
    PETSCII 字符代码。
- en: The following program illustrates these structures. It displays a scrolling
    message on a colored screen, and exits when the A key is pressed.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 以下程序演示了这些结构。它在彩色屏幕上显示滚动消息，并在按下 A 键时退出。
- en: '[PRE12]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: This creates a scrolling text result, as in [Figure 11-10](ch11.xhtml#ch11fig10).
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 这将创建一个滚动文本效果，如 [图 11-10](ch11.xhtml#ch11fig10) 所示。
- en: '![Image](../images/f0264-01.jpg)'
  id: totrans-128
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/f0264-01.jpg)'
- en: '*Figure 11-10: The hello C64 result. The text scrolls across the screen.*'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 11-10：C64 上的 hello 结果，文本滚动穿过屏幕。*'
- en: 'The program can be used as the starting point for writing a game, as it includes
    all of the basic game elements: a loop, display, keyboard read, and state update.'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 该程序可以作为编写游戏的起点，因为它包含了所有基本的游戏元素：循环、显示、键盘读取和状态更新。
- en: '**CHIPTUNES**'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: '**芯片音乐**'
- en: In the 8-bit era, the sound chip was a genuine synthesizer, an actual musical
    instrument made in hardware and placed inside the computer.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 在 8 位时代，声音芯片是真正的合成器，一种通过硬件制作并放入计算机中的实际音乐乐器。
- en: The simplest way to generate tones is to use square waves. This is how a non-musician
    architect would go about building a sound chip, such as the Texas Instruments
    SN76489\. Square waves alternate at a given frequency (musical pitch) between
    a digital 0 and 1, so they can be made entirely from digital logic rather than
    requiring the analog voltages that would be needed to make other waveforms. Limiting
    chips to square waves gave devices of the era their characteristic, primitive
    8-bit sound.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 生成音调的最简单方法是使用方波。这是一个非音乐家出身的架构师构建声音芯片时的常见做法，比如德州仪器的 SN76489。方波在给定频率（音乐音高）下在数字
    0 和 1 之间交替，因此它们完全可以由数字逻辑构成，而无需其他波形所需的模拟电压。将芯片限制为方波使得那个时代的设备具有了其典型的原始 8 位声音。
- en: As Commodore had bought MOS, they used MOS’s latest tone generator, the 6581
    Sound Interface Device (SID), in the C64\. SID was far superior to previous sound
    chips. It was designed as a real musical instrument, by a musical synthesizer
    designer. It added analog sawtooth and sine waves into the mix, and revolutionized
    8-bit audio by adding analog filters to these waves. Filters emphasize or mute
    bands of harmonics in a musical signal. Both square and sawtooth waves have infinite
    harmonics, which provide good raw material for filters to act upon. Filters can
    be swept over notes in many different ways to create many effects, and this gave
    the C64 its large musical palette.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 由于康莫多尔收购了 MOS，他们在 C64 中使用了 MOS 最新的音调生成器——6581 声音接口设备（SID）。SID 比以前的声音芯片要强大得多。它是由一位音乐合成器设计师设计的，作为一款真正的音乐乐器。它将模拟锯齿波和正弦波加入到音频中，并通过给这些波形添加模拟滤波器，彻底革新了
    8 位音频。滤波器能够强调或消除音乐信号中的谐波频段。方波和锯齿波都有无限的谐波，这为滤波器提供了良好的处理原料。滤波器可以以多种方式在音符上滑动，创造出许多不同的效果，这使得
    C64 拥有了丰富的音乐表现力。
- en: 'SID contains the analog device and an I/O module that interfaces it to the
    address space, so it attaches to the bus. In the C64, it’s controlled by writing
    parameters such as frequencies, volumes, and filter cutoffs to its assigned address
    space, D400 to D7FF, as in the following example, which plays a square wave on
    channel 1:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: SID 包含模拟设备和一个 I/O 模块，将其与地址空间连接，因此它附加到总线上。在 C64 中，通过向其分配的地址空间（D400 到 D7FF）写入频率、音量和滤波器截止等参数来控制它，以下示例通过通道
    1 播放方波：
- en: '[PRE13]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: After SID’s release, the great 8-bit “chiptune” composers such as Rob Hubbard
    found highly creative ways to hack it to play samples and to appear to have many
    more voices than the three it had in hardware. SID presented a limited and constrained
    palette, encouraging minimalist, mathematical aesthetics. Hubbard was influenced
    by Philip Glass, Jean-Michel Jarre, and Kraftwerk. More recently, music producers
    in the 2010s, such as Max Martin and Dr. Luke, have used SID for its retro gaming
    sound.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 在 SID 发布后，像 Rob Hubbard 这样的伟大 8 位“芯片音乐”作曲家找到了高度创意的方式，通过黑客技术让它播放样本，并且让它看起来拥有比硬件上实际提供的三个声音更多的音轨。SID
    提供了一个有限且受限的音色调色板，促使了极简主义和数学美学的发展。Hubbard 受到了 Philip Glass、Jean-Michel Jarre 和
    Kraftwerk 的影响。近年来，像 Max Martin 和 Dr. Luke 这样的音乐制作人在 2010 年代使用 SID 来营造复古游戏音效。
- en: Working with the Motorola 68000 16-Bit CPU
  id: totrans-138
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 与摩托罗拉 68000 16 位 CPU 协同工作
- en: 'The 16-bit era is somewhat misnamed: it should have been the “16/32-bit era.”
    This is because the defining chip of the era was the Motorola 68000, used in the
    Commodore Amiga, Atari ST, Apple Macintosh, and Sega Megadrive, as well as in
    arcade machines such as *Street Fighter II*. The 68000 used 16-bit data words,
    but also had 32-bit registers and an ALU inside the CPU. The Atari ST’s name refers
    to this hybrid “*S*ixteen/*T*hirty-two” nature of the 68000\. Also known as the
    68k, the 68000 was released in 1979 and appeared in computers in the later 1980s
    to define the 16-bit era.'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 16位时代有些名不副实：它本应被称为“16/32位时代”。这是因为这个时代的代表性芯片是摩托罗拉68000，它被用于Commodore Amiga、Atari
    ST、Apple Macintosh、Sega Megadrive以及街机游戏如*街头霸王II*。68000使用16位数据字，但也拥有32位寄存器和CPU内的ALU。Atari
    ST的名字正是来源于68000的这种混合“*S*ixteen/*T*hirty-two”特性。68000，也被称为68k，于1979年发布，并在1980年代后期的计算机中出现，定义了16位时代。
- en: Both the 6502 and 68000 descended from the earlier Motorola 6800, in separate
    branches of evolution. Their names reflect this, and they share some structures
    and instructions. This means that learning the 68000 is often an extension of
    what we learned about the 6502\. If you’re unsure of how to do something in the
    68000, you can often make a good guess based on the 6502 equivalent.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 6502和68000都源自早期的摩托罗拉6800，在不同的进化分支上发展。它们的名字反映了这一点，并共享一些结构和指令。这意味着学习68000通常是对我们在6502中学到的内容的扩展。如果你不确定如何在68000中完成某项任务，通常可以根据6502的等效操作做出合理的猜测。
- en: '*Internal Subcomponents*'
  id: totrans-141
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '*内部子组件*'
- en: '[Figure 11-11](ch11.xhtml#ch11fig11) shows a die shot of the Motorola 68000\.
    In the figure, you can see the same basic structure as in the 6502, with the registers
    and ALU at the bottom, control logic in the center, and decoder near the top.'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: '[图11-11](ch11.xhtml#ch11fig11)展示了摩托罗拉68000的芯片照。图中可以看到与6502相同的基本结构，寄存器和算术逻辑单元（ALU）位于底部，控制逻辑位于中央，解码器位于顶部附近。'
- en: '![Image](../images/f0266-01.jpg)'
  id: totrans-143
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/f0266-01.jpg)'
- en: '*Figure 11-11: A 68000 die shot*'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: '*图11-11：68000芯片照*'
- en: You can see that the registers and ALU section now has more repeated rows due
    to having more than 8 bits. Unlike the 6502, the digital logic is now too small
    to see when the whole CPU is shown on a printed page.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 可以看到，寄存器和ALU部分现在有更多重复的行，因为它们的位数超过了8位。与6502不同的是，当整个CPU在打印页面上显示时，其数字逻辑现在已经小到无法看到。
- en: There are 16 user registers, all 32-bit, of which 8 are called D0 to D7 for
    “data registers,” and the others are called A0 to A7 for “address registers.”
    A7 is used as the stack pointer. There’s a 16-bit status register containing similar
    status bits to the 6502, and some extra information.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 有16个用户寄存器，都是32位，其中8个被称为D0到D7，用作“数据寄存器”，其余的被称为A0到A7，用作“地址寄存器”。A7被用作堆栈指针。还有一个16位状态寄存器，包含类似6502的状态位，并带有一些额外信息。
- en: The bus has 16 data lines and 24 address lines. The addresses, however, refer
    to locations of bytes rather than 16-bit words, so there are 2^(24) addressable
    bytes, which is 16 M[2]B of addressable memory. The 24-bit addresses are written
    as six hex characters, such as DFF102[16].
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 总线有16条数据线和24条地址线。然而，这些地址指向的是字节位置，而不是16位字，因此可以寻址的字节数是2^(24)，即16M[2]B的可寻址内存。24位地址以六个十六进制字符表示，例如DFF102[16]。
- en: The 68000 has a two-stage pipeline that fetches the next instruction while simultaneously
    decoding and executing the current one.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 68000有一个两阶段的流水线，在解码和执行当前指令的同时，预取下一条指令。
- en: '*Programmer Interface*'
  id: totrans-149
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '*程序员接口*'
- en: As we’ve done for other machines, having seen the structure of the 68000 we’ll
    now examine the instruction set that it enables—via memory access, arithmetic,
    and flow control—and that you can use to write your own programs. The 16-bit era
    saw a widespread shift from the use of upper- to lowercase characters in programming,
    which we’ll respect from here onward.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在其他机器中所做的那样，在了解68000的结构之后，我们现在将审视它所启用的指令集——通过内存访问、算术运算和流程控制——这些指令集可以帮助你编写自己的程序。16位时代在编程中广泛地从使用大写字母转向了小写字母，从此我们也将尊重这一点。
- en: '**Data Movement**'
  id: totrans-151
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**数据移动**'
- en: 'A single `move` instruction is used for load, store, and register data transfers:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 单条`move`指令用于加载、存储和寄存器数据传输：
- en: '[PRE14]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The `l` here stands for “longword” and moves 32 bits at a time. This is fast
    between registers. When accessing memory, the 32 bits must be split up by the
    CPU and sent over the 16-bit bus in two steps, sequenced by the CU.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的`l`代表“长字”（longword），每次移动32位。这在寄存器之间非常快速。访问内存时，32位数据必须被CPU拆分，并通过16位总线分两步发送，由控制单元（CU）按顺序执行。
- en: 'If you only want to move 16-bit words (`w`) or 8-bit bytes (`b`) around, you
    can use variants of `move`:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你只想移动 16 位字（`w`）或 8 位字节（`b`），你可以使用 `move` 的变种：
- en: '[PRE15]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Indirect addressing is specified using parentheses:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 间接寻址通过括号指定：
- en: '[PRE16]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Offset addressing includes the following:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 偏移寻址包括以下内容：
- en: '[PRE17]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'A more complicated and unusual 68000 addressing mode combines indirect addressing
    with register incrementation; this is useful for iterating over data stored in
    contiguous addresses:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 更复杂且不常见的 68000 寻址模式将间接寻址与寄存器递增结合使用；这对于遍历存储在连续地址中的数据非常有用：
- en: '[PRE18]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'For C programmers: this is roughly what `*(a++)` and `*(--a)` would compile
    into. Pushing and popping the stack doesn’t need dedicated instructions because
    it can be done using this mode with the stack pointer register:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 C 程序员：这大致是 `*(a++)` 和 `*(--a)` 编译后的结果。推送和弹出堆栈不需要专门的指令，因为可以使用此模式与堆栈指针寄存器来实现：
- en: '[PRE19]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Load effective addresses (`lea`) is a related 68000 instruction that can load
    the address of indirections. For example:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 有效地址加载指令（`lea`）是 68000 的相关指令，可以加载间接寻址的地址。例如：
- en: '[PRE20]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Note that `lea` loads the numerical address itself, rather than the content
    of the address.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，`lea` 加载的是数值地址本身，而不是地址的内容。
- en: '**Flow Control**'
  id: totrans-168
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**流程控制**'
- en: 'Due to their shared history, jumps, subroutines, and branches on the 68000
    are the same as on the 6502\. For example:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 由于历史渊源，68000 的跳转、子程序和分支与 6502 相同。例如：
- en: '[PRE21]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'That said, stack logic improved: with the 68000 you can push a series of arguments
    to the stack, make a jump to a subroutine, and pop them off from inside the subroutine.
    This allows subroutines to behave like functions with parameters.'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 话虽如此，堆栈逻辑有所改进：在 68000 上，你可以将一系列参数推送到堆栈，跳转到子程序，然后从子程序内将它们弹出。这使得子程序能够像具有参数的函数一样工作。
- en: '**Arithmetic**'
  id: totrans-172
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**算术**'
- en: 'Here are some examples of arithmetic instructions:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一些算术指令的示例：
- en: '[PRE22]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: The addition and subtraction instructions are similar to those for the 6502\.
    But unlike the 6502, the 68000 can perform multiplication and division in hardware.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 加法和减法指令与 6502 类似。但与 6502 不同，68000 可以通过硬件执行乘法和除法。
- en: 16-Bit Computer Design with the Commodore Amiga
  id: totrans-176
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用 Commodore Amiga 的 16 位计算机设计
- en: '*Amiga* is the feminine of *amigo*, meaning *friend*, and Commodore’s 1985
    Amiga was intended to have that kind of relationship with its users. Early versions
    of the Amiga were intended as high-end graphics workstations and marketed to self-described
    “creatives”—the market now targeted by Apple. However, the now-classic A500 model
    rapidly became a standard mass-market gaming platform. This became self-fulfilling
    as both developer and gamer populations increased together. Growth was accelerated
    by the ease of (illegally) cracking and copying game disks, with bars in many
    towns around the world hosting “Amiga nights” where they were traded. In Europe,
    the Amiga was adopted by the “demo scene,” a subculture of artistic assembly programmers
    who met up to compete at pushing the graphics and sound to their limits, not in
    games but in multimedia demonstrations. These scenes overlapped, with crackers
    adding demos to the boot sequences of newly cracked games (those with the copy-protection
    removed). Commodore management ignored all this and tried to push the Amiga in
    the business market, where it and the company were destroyed by beige-box PCs.'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: '*Amiga* 是 *amigo* 的阴性形式，意为 *朋友*，而 Commodore 的 1985 年推出的 Amiga 意在与其用户建立这样的关系。早期版本的
    Amiga 旨在作为高端图形工作站，面向自称为“创意人士”的市场——如今 Apple 面向的正是这一市场。然而，现在经典的 A500 型号迅速成为了标准的大众市场游戏平台。这一现象自我实现，因为开发者和玩家群体一同增长。随着（非法）破解和复制游戏磁盘的便利，世界许多城市的酒吧举行“Amiga之夜”，在其中交换这些磁盘，增长速度进一步加快。在欧洲，Amiga
    被“演示场景”（demo scene）接受，这是一群艺术性汇编程序员组成的亚文化，他们聚集在一起竞赛，推动图形和声音的极限，目标不是在游戏中，而是在多媒体演示中。这些场景有交集，破解者将演示加到新破解游戏的启动序列中（那些移除了复制保护的游戏）。Commodore
    管理层忽视了这一切，并试图将 Amiga 推向商业市场，最终它和公司都被“米色箱”PC 摧毁了。'
- en: '**Understanding the Architecture**'
  id: totrans-178
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**理解架构**'
- en: The classic A500 had 0.5 M[2]B of RAM, though it and its successors were upgradable
    to a few mebibytes. (This was still much smaller than the 16 M[2]B addressable
    by the CPU.) [Figure 11-12](ch11.xhtml#ch11fig12) shows the A500 mainboard.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 经典的 A500 配备了 0.5 M[2]B 的 RAM，尽管它和后续型号可以升级为几个 Mebibyte。（这仍然远小于 CPU 可寻址的 16 M[2]B。）[图
    11-12](ch11.xhtml#ch11fig12) 显示了 A500 的主板。
- en: '![Image](../images/f0270-01.jpg)'
  id: totrans-180
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/f0270-01.jpg)'
- en: '*Figure 11-12: An Amiga A500 mainboard*'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 11-12：一块 Amiga A500 主板*'
- en: 'The design was based around four large custom chips, given human names:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 设计基于四个大型定制芯片，赋予它们人类名字：
- en: '**Agnus** This chip contained a coprocessor (“copper”) with its own separate
    RAM and bus, in addition to the main CPU system. The copper was responsible for
    graphics. Machine code for the copper could be written as data lines and sent
    to the copper as data by the main CPU program. (A similar system is used today
    in GPUs.) Agnus also contained a DMA-based “blitter,” used for copying sprites
    onto video RAM without CPU.'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: '**Agnus** 这款芯片包含了一个协处理器（“铜处理器”），该协处理器有自己的独立 RAM 和总线，除了主 CPU 系统外，铜处理器负责图形处理。铜处理器的机器码可以作为数据行编写，并通过主
    CPU 程序将数据传输给铜处理器。（今天的 GPU 也使用类似的系统。）Agnus 还包含一个基于 DMA 的“blitter”，用于将精灵图像复制到视频内存中，而无需
    CPU 介入。'
- en: '**Paula** This chip contained a sound device and its I/O module, as well as
    several other I/O modules, such as for disks and communications ports. It used
    DMA to read audio samples and other I/O data from RAM without CPU intervention.'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: '**Paula** 这款芯片包含一个音频设备及其 I/O 模块，此外还有其他多个 I/O 模块，如磁盘和通信端口。它使用 DMA 从 RAM 中读取音频样本和其他
    I/O 数据，而无需 CPU 介入。'
- en: '**Denise** This was the VDU chip, reading sprites and bitplanes from RAM, compositing
    them together under various screen modes, and outputting CRT display controls.'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: '**Denise** 这款芯片是视频显示单元（VDU）芯片，负责从 RAM 中读取精灵图像和位平面，根据不同的屏幕模式将它们合成在一起，并输出 CRT
    显示控制。'
- en: '**Gary** This was a memory controller, translating and routing addresses from
    the bus to particular chips and addresses within them.'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: '**Gary** 这是一款内存控制器，用于将总线上的地址翻译并路由到特定的芯片及其内部地址。'
- en: The A500 BIOS (called Kickstart) provides subroutines for accessing I/O, such
    as graphics and sound. It comes on a chip usually described as a ROM but that
    is more correctly considered an I/O module. This is because, unlike the C64 BIOS,
    these subroutines aren’t mounted into address space directly. Instead, they’re
    stored on a part of the chip that isn’t directly addressed. When a subset (library)
    of the subroutines is needed, a command is sent to the smaller, addressed part
    of the chip to copy them into a new location in RAM.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: A500 的 BIOS（称为 Kickstart）提供了访问 I/O 的子程序，如图形和声音。它存储在一个芯片中，通常被描述为 ROM，但更准确地说，它应该被视为一个
    I/O 模块。这是因为，与 C64 的 BIOS 不同，这些子程序并没有直接映射到地址空间中。相反，它们被存储在芯片的一部分，这部分并没有直接映射到地址空间。当需要子程序的一个子集（库）时，会向芯片的较小、已映射部分发送命令，将子程序复制到
    RAM 中的新位置。
- en: The whole computer was synchronized to the clock rate of the TV CRT scan display,
    meaning that it (and its games) ran at different speeds in the UK and US due to
    their different TV standards!
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 整台计算机与电视 CRT 扫描显示的时钟频率同步，这意味着它（以及它的游戏）在英国和美国运行的速度不同，因为它们使用不同的电视标准！
- en: The Amiga was designed as a multimedia machine, and a fundamental requirement,
    especially for the 16-bit games of the time, was to quickly draw sprites—small
    images such as game characters—that are overlaid onto backgrounds to build up
    a scene.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: Amiga 被设计为一款多媒体机器，尤其是当时的 16 位游戏，基本要求之一就是能够快速绘制精灵图像——如游戏角色等小图像——这些精灵图像会覆盖在背景上以构建场景。
- en: A naive method to draw sprites is to store a primary copy of the sprite at a
    fixed location in RAM, then write a subroutine in assembly language to copy each
    pixel one at a time to a parameterized location in video RAM. However, this is
    very slow because every pixel in the sprite then needs to be loaded into the CPU
    and written out again to video RAM in sequence.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 一种简单的精灵绘制方法是将精灵的主副本存储在 RAM 中的固定位置，然后用汇编语言编写子程序，将每个像素逐一复制到视频内存中的参数化位置。然而，这种方法非常慢，因为精灵中的每个像素都需要加载到
    CPU 中，并按顺序重新写入视频内存。
- en: “Blitting” was a famous use of DMA in the Amiga copper to render sprites more
    efficiently. The copper could be commanded by the CPU to initiate a complete sprite
    “blit” by DMA. It would then read the sprite (or blitter object, “bob”) pixel
    by pixel from its location in regular RAM, and copy it into video RAM without
    any further CPU intervention.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: “Blitting” 是 Amiga 铜处理器利用 DMA 更高效地渲染精灵图像的一种著名应用。铜处理器可以通过 CPU 指令启动一个完整的精灵“blit”操作，利用
    DMA 将精灵（或 blitter 对象，“bob”）逐像素从常规 RAM 中读取，并复制到视频 RAM 中，无需 CPU 进一步干预。
- en: “Hardware sprites” were a second method, in which the primary copy of the sprite
    was loaded into the VDU at the start of a game. The VDU contained its own dedicated
    digital logic to implement similar blitting commands internally. There were severe
    memory limits inside the VDU, allowing only eight hardware sprites, which could
    often be used for the animation frames of a main character in a game or for the
    mouse pointer symbol.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: “硬件精灵”是第二种方法，其中精灵的主副本在游戏开始时被加载到VDU中。VDU包含其专用的数字逻辑，用于内部实现类似的位图命令。VDU内部存在严格的内存限制，只允许使用八个硬件精灵，这些精灵通常用于游戏中主角的动画帧或鼠标指针符号。
- en: For backdrops of 2D games, “playfields” are another hardware acceleration, which
    allow backdrop images to be stored and scrolled around. Several can be overlaid
    with transparency masks to create parallax effects.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 对于2D游戏的背景图，“游戏背景”是另一种硬件加速，允许背景图像被存储并滚动。多个背景可以与透明遮罩叠加，以创建视差效果。
- en: '**Programming the Amiga**'
  id: totrans-194
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**Amiga编程**'
- en: 'The following is a short program that displays a spaceship sprite on the screen:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个简单的程序，用于在屏幕上显示一个太空船精灵：
- en: '[PRE23]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Here, the sprite is defined in the data segment at the end. Amiga programs tend
    to involve a lot of defining constants for use with the many complex ROM I/O subroutines
    used to call its graphics capabilities. In real life, library files would be included
    to make the most of these definitions, but they’re shown here in full as an illustration
    of a complete program.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，精灵在数据段的末尾定义。Amiga程序通常涉及大量定义常量，用于调用其图形功能的许多复杂ROM I/O子程序。在现实生活中，库文件会被包含进来，以便最大化这些定义的使用，但在这里，它们作为完整程序的示例被展示出来。
- en: A screenshot of the result is shown in [Figure 11-13](ch11.xhtml#ch11fig13).
    Note that the sprite doesn’t yet move, but further commands could be added to
    create a game loop that repeatedly reads the keyboard, updates the sprite location,
    then does the drawing. In real games, sprites aren’t usually defined as data lines
    in assembly; rather, they’re drawn in the famous pixel art program *Deluxe Paint*,
    then loaded into similar memory areas from files.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 结果的截图如[图 11-13](ch11.xhtml#ch11fig13)所示。请注意，精灵还没有移动，但可以添加更多命令来创建一个游戏循环，循环地读取键盘、更新精灵位置，然后进行绘制。在真实的游戏中，精灵通常不会作为数据行在汇编语言中定义；相反，它们会在著名的像素艺术程序*Deluxe
    Paint*中绘制，然后从文件加载到类似的内存区域。
- en: '![Image](../images/f0275-01.jpg)'
  id: totrans-199
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/f0275-01.jpg)'
- en: '*Figure 11-13: The Amiga sprite game result*'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 11-13：Amiga精灵游戏结果*'
- en: Retro Peripherals
  id: totrans-201
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 复古外设
- en: The 8-bit and 16-bit eras introduced many peripherals that either are still
    with us today or have had strong influences on modern standards. Let’s look at
    some of the most important ones here to complete our study of retro computing.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 8位和16位时代引入了许多外设，这些外设要么至今仍在使用，要么对现代标准产生了强烈影响。让我们在这里看看一些最重要的外设，来完成我们对复古计算的研究。
- en: '*Cathode Ray Tube Displays*'
  id: totrans-203
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '*阴极射线管显示器*'
- en: While the Manchester Baby’s Williams tube, seen in the “Historical RAMs” box
    on [page 220](ch10.xhtml#page_220), wasn’t originally intended as a human display
    device, its programmers were quick to realize its potential for this use, and
    they soon began to write deliberately human-readable patterns to some parts of
    the screen as a form of output, with the rest of the screen storing internal data
    that appears as random patterns of on and off pixels. In recent decades, hackers
    have written simple retro arcade games to play on the Baby, displaying *Snake*
    and *Space Invaders* on parts of its Williams tube as the display.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然曼彻斯特婴儿机的威廉姆斯管，如[第220页](ch10.xhtml#page_220)“历史RAM”框中所示，最初并非作为人类显示设备设计，但它的程序员迅速意识到它作为显示设备的潜力，并很快开始在屏幕的某些部分编写易于人类阅读的模式作为输出，而屏幕的其余部分则存储内部数据，这些数据表现为随机的开关像素模式。在近几十年中，黑客们编写了简单的复古街机游戏，在婴儿机上播放，展示了*蛇*和*太空侵略者*等游戏，显示在威廉姆斯管的某些部分作为显示。
- en: These green-on-black pixels are the origin of the later cathode ray tube (CRT)
    green screen, and then color monitors, used as human displays in the retro age,
    as seen in [Figure 1-31](ch01.xhtml#ch01fig31).
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 这些黑底绿字的像素是后来的阴极射线管（CRT）绿色屏幕以及之后的彩色显示器的起源，这些设备在复古时代作为人类显示器使用，如[图 1-31](ch01.xhtml#ch01fig31)所示。
- en: Programmers grew accustomed to the green color scheme, and in the 1980s often
    switched their RGB monitors into high-resolution green-on-black modes with a hardware
    switch to aid their concentration and familiarity. Some claimed that using only
    the green pixels improved the precision of the display, as the red and blue sub-pixels
    are some distance away from the green so tend to blur the pixel when used. Today,
    we still follow this tradition when we put our terminal emulators and text editors
    such as Vim into green-on-black mode. This classic programming scheme is celebrated
    in the stylized computer code in the movies *Ghost in the Shell* and *The Matrix*.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 程序员逐渐习惯了绿色配色方案，在1980年代，常通过硬件开关将RGB显示器切换到高分辨率的绿底黑字模式，以帮助集中注意力和提高熟悉度。有些人声称，只有使用绿色像素可以提高显示精度，因为红色和蓝色子像素与绿色的距离较远，使用时容易导致像素模糊。今天，当我们将终端模拟器和文本编辑器（如Vim）设置为绿底黑字模式时，依然遵循这一传统。这种经典的编程方案在电影《攻壳机动队》和《黑客帝国》中以风格化的计算机代码形式得到了庆祝。
- en: To reduce costs, home computers of the golden age were often designed to use
    consumer television CRTs as RGB monitors. To display to a CRT monitor or TV, an
    8-bit machine such as the C64 first needs to read the desired pixel values from
    video RAM, then arrange for them to be mapped onto the strength of the CRT beam
    as it periodically scans the columns and rows of the screen.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 为了降低成本，黄金时代的家用计算机通常设计为使用消费级电视CRT作为RGB显示器。为了在CRT显示器或电视上显示，像C64这样的8位机器首先需要从视频内存中读取所需的像素值，然后安排将其映射到CRT束的强度上，在显示器扫描屏幕的列和行时定期进行调整。
- en: CRT monitors produce complex visual halos around each pixel that blur into its
    neighbors, and pixel art for games of the time was optimized to work with this
    blurring, which looks completely unlike the result of playing retro games on a
    modern flat-screen monitor. The arcade game *Asteroids* exploited this effect
    to the extreme by turning up the brightness for the bullets to the maximum, resulting
    in the CRT ray functioning as a kind of death ray firing right into the player’s
    eyes—an effect that’s impossible to capture in emulation.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: CRT显示器在每个像素周围产生复杂的视觉光晕，这些光晕会与邻近的像素混合，而当时游戏的像素艺术正是为适应这种模糊效果而优化的，这与在现代平面显示器上玩复古游戏的效果完全不同。街机游戏*小行星*极端地利用了这一效果，将子弹的亮度调到最大，导致CRT射线像一种死亡射线直射玩家眼睛——这种效果在仿真中是无法捕捉的。
- en: '*User Input*'
  id: totrans-209
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '*用户输入*'
- en: Keyboards in the retro age were typically memory-mapped, with each key wired
    directly to an address in memory space to look like RAM. There would be a group
    of addresses together, each mapped to a key, and by loading from one you could
    determine if the key was up or down.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 复古时代的键盘通常是内存映射的，每个键都直接连接到内存空间中的一个地址，看起来像RAM。地址分成一组，每个地址都映射到一个键，加载其中一个地址就可以判断键是按下还是松开。
- en: A mouse of the retro era is shown in [Figure 11-14](ch11.xhtml#ch11fig14).
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 复古时代的鼠标如[图11-14](ch11.xhtml#ch11fig14)所示。
- en: '![Image](../images/f0276-01.jpg)'
  id: totrans-212
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/f0276-01.jpg)'
- en: '*Figure 11-14: A ball mouse teardown*'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: '*图11-14：球形鼠标拆解图*'
- en: Mice like the one in [Figure 11-14](ch11.xhtml#ch11fig14) work by physically
    rolling a thumb-sized rubber ball over your desk, which in turn spins two roller
    sensors detecting its horizontal and vertical rotations. The sensors convert the
    rotations into analog then digital signals to send down the wire to your computer.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 像[图11-14](ch11.xhtml#ch11fig14)中的鼠标一样，通过在桌面上滚动一个拇指大小的橡胶球来工作，这个球会旋转两个滚轮传感器，检测它的水平和垂直旋转。传感器将旋转转换为模拟信号，再转为数字信号，通过电缆传输到计算机。
- en: '*Serial Port*'
  id: totrans-215
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '*串口*'
- en: The serial port was, and still is, a simple communications protocol (formally
    the RS232 standard) found on retro machines but still very relevant in embedded
    systems today. The core of a serial port is two wires, called RX and TX, which
    stand for *receive* and *transmit*, respectively. These use digital voltages over
    time to transmit 0s and 1s, so there’s one wire sending information one way and
    another wire sending information the other way. A historical serial port has many
    other wires as well, as in the old days they were used as controls for many things,
    but nowadays we tend to use only RX and TX. Serial port connectors still have
    extra, mostly unused, pins from this history, as shown in [Figure 11-15](ch11.xhtml#ch11fig15).
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 串口曾经是，且仍然是，一种简单的通信协议（正式名称为 RS232 标准），曾出现在复古机器中，但在嵌入式系统中仍然非常重要。串口的核心是两根线，分别称为
    RX 和 TX，代表*接收*和*发送*。它们通过时间上的数字电压来传输 0 和 1，因此有一根线在一个方向上传输信息，另一根线则在另一个方向上传输信息。历史上的串口还包含许多其他线路，因为在早期它们被用作控制许多设备的信号，但如今我们通常只使用
    RX 和 TX。串口连接器仍然保留着这些额外的大多未使用的引脚，正如[图 11-15](ch11.xhtml#ch11fig15)所示。
- en: '![Image](../images/f0277-01.jpg)'
  id: totrans-217
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/f0277-01.jpg)'
- en: '*Figure 11-15: A traditional serial port connector*'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 11-15：传统的串口连接器*'
- en: Serial ports can run at different speeds. They may also use different conventions
    for error checking, which can add extra redundant bits, and for *stop bits*, which
    show where the boundaries of characters lie in the stream of 0s and 1s. You have
    to make sure the device at one end of the wire is using the same speed and conventions
    as the device at the other end of the wire.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 串口可以以不同的速度运行。它们可能还使用不同的错误检查约定，这可能会增加额外的冗余位，以及*停止位*，用来标示字符在一串 0 和 1 中的边界。你需要确保线路两端的设备使用相同的速度和约定。
- en: '*MIDI Interfaces*'
  id: totrans-220
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '*MIDI 接口*'
- en: '*MIDI (Musical Instrument Device Interface*, as seen in [Figure 11-16](ch11.xhtml#ch11fig16))
    has been the standard bus for musical keyboards, synthesizers, samplers, and 1980s
    keytars to communicate real-time, symbolic musical input and output since its
    standardization in 1983\. It’s an early example of a bus hierarchy, in which an
    optional MIDI interface could be connected to the main bus; it also provides a
    secondary MIDI bus for multiple musical devices to communicate along.'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: '*MIDI（音乐设备接口*，如[图 11-16](ch11.xhtml#ch11fig16)所示）自 1983 年标准化以来，一直是音乐键盘、合成器、采样器和
    1980 年代键琴的标准总线，用于实时传输符号化的音乐输入和输出。它是总线层次结构的早期示例，其中一个可选的 MIDI 接口可以连接到主总线上；它还提供了一个次级
    MIDI 总线，使多个音乐设备能够进行通信。'
- en: '![Image](../images/f0277-02.jpg)'
  id: totrans-222
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/f0277-02.jpg)'
- en: '*Figure 11-16: A MIDI connector*'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 11-16：MIDI 连接器*'
- en: MIDI connections are composed of a pair of unidirectional buses. One is for
    the manager to send messages to devices, and the other is for devices to send
    messages to the manager. They’re buses in the sense that all devices use the same
    physical wires and can see all the messages on these wires, and so the devices
    must look out for which messages are addressed to them to read, and act on only
    those.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: MIDI 连接由一对单向总线组成。一条是用于管理器向设备发送消息，另一条是用于设备向管理器发送消息。它们被称为总线，因为所有设备使用相同的物理线缆，并且可以看到这些线上所有的消息，因此设备必须注意哪些消息是发送给它们的，只处理这些消息。
- en: 'Each direction’s bus has its own connector and runs on three physical wires.
    (In fact, a standard MIDI connector has five pins, with two spare to help with
    related work such as supplying “phantom” power to devices.) One wire is 5 V, one
    is ground, and one is UART (universal asynchronous receiver-transmitter) data.
    The bus nature of the wire from the manager to the devices is seen in the MIDI
    specification that all devices have three sockets: “in,” “out,” and “thru,” where
    “thru” relays all “in” messages to the next device in a daisy-chain wiring scheme;
    other hardware adapters can merge the “out” messages from several devices onto
    a single wire, which is a rarer thing to want to do. As a 1980s standard, all
    messages are 8-bit words (known as “MIDI bytes”), transmitted similarly to a serial
    port connection at a standard rate of 31.25Kbps.'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 每个方向的总线都有自己的连接器，并通过三根物理线进行传输。（实际上，一个标准的MIDI连接器有五个引脚，其中两个备用引脚有助于处理相关工作，比如为设备提供“虚拟”电源。）一根线是5V，另一根是地线，还有一根是UART（通用异步接收发送器）数据线。总线性质通过MIDI规范可以看出，所有设备都有三个插口：“in”（输入）、“out”（输出）和“thru”（通道），其中“thru”将所有“in”消息转发给下一个设备，采用串联接线方案；其他硬件适配器可以将多个设备的“out”消息合并到一根线中，这种情况相对较少见。作为1980年代的标准，所有消息都是8位字（称为“MIDI字节”），以类似串口连接的方式传输，标准传输速率为31.25Kbps。
- en: MIDI, including recent extensions in MIDI 2.0, is still with us today.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: MIDI，包括最近的MIDI 2.0扩展，至今仍然在使用。
- en: Summary
  id: totrans-227
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 概述
- en: For readers of a certain age, understanding and programming golden age machines
    can be a beautiful way to relive their youth and understand what was really going
    on inside their old machines. But for everyone else, these machines are still
    valuable to study because they bridge the gap between the simplest electronic
    computers, such as the Baby, and what you actually have on your desk and in your
    pocket today. Those modern machines have many more features that can be overwhelming,
    so by practicing on older machines of increasing power, you can build your confidence.
    To this end, this chapter studied an 8-bit system, the Commodore 64, and a 16-bit
    system, the Commodore Amiga. The two are related through their CPUs’ common ancestry,
    meaning they share some instructions and styles. Many of the ideas introduced
    by these classic systems are still in use today, as we will see in the next chapters.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 对于某个年龄段的读者来说，理解并编程那些黄金时代的机器可以是重温青春并理解当时老旧机器内部运作的美好方式。但对于其他人来说，这些机器依然值得学习，因为它们架起了最简单电子计算机（如Baby机）与如今桌面和口袋中的现代计算机之间的桥梁。这些现代机器有许多更多的功能，可能令人应接不暇，因此，通过在越来越强大的旧机器上练习，你可以建立自己的信心。为此，本章研究了一台8位系统——Commodore
    64和一台16位系统——Commodore Amiga。这两台机器通过它们的CPU的共同祖先相关联，意味着它们共享一些指令和风格。这些经典系统所引入的许多理念至今仍在使用，正如我们将在接下来的章节中看到的那样。
- en: Exercises
  id: totrans-229
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 练习
- en: '**6502 Programming**'
  id: totrans-230
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**6502编程**'
- en: 'Easy6502 is an open source 6502 emulator that runs in your browser. It’s written
    in JavaScript by Nick Morgan, the author of *JavaScript for Kids* and *JavaScript
    Crash Course*, also available from No Starch Press. Download Easy6502 with:'
  id: totrans-231
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Easy6502是一个开源的6502模拟器，可以在浏览器中运行。它由Nick Morgan编写，Nick是《JavaScript for Kids》和《JavaScript
    Crash Course》的作者，这两本书也由No Starch Press出版。可以通过以下链接下载Easy6502：
- en: '[PRE24]'
  id: totrans-232
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Open the downloaded *emulator.html* in your browser to run Easy6502\. Then enter
    and run the sample 6502 programs from this chapter. The emulator shows the content
    of the registers on the right.
  id: totrans-233
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在浏览器中打开下载的*emulator.html*文件来运行Easy6502。然后输入并运行本章中的示例6502程序。模拟器在右侧显示寄存器的内容。
- en: Try writing a 16-bit multiplication subroutine in 6502 assembly using Easy6502.
  id: totrans-234
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 尝试在Easy6502中编写一个16位乘法子程序，使用6502汇编语言。
- en: Nick’s own tutorial can be found in the downloaded *tutorial.html*. This gives
    many more 6502 programming details and builds up to writing a retro *Snake*-type
    game. Try to learn enough to understand how this game works, then try to modify
    it in some way, either to change the rules of the game or to transform it into
    another retro game such as *Space Invaders* or *Tetris*. Code built in this emulator
    can be ported to the C64 or other 6502-based machines, with some extra work to
    replace the graphics and I/O with calls to their specific designs.
  id: totrans-235
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Nick的个人教程可以在下载的*tutorial.html*文件中找到。该教程提供了更多6502编程的细节，并逐步介绍如何编写一个复古的*蛇形*游戏。尝试学习足够的内容以理解这个游戏的工作原理，然后尝试以某种方式修改它，既可以改变游戏规则，也可以将其转变为另一个复古游戏，比如*太空侵略者*或*俄罗斯方块*。在这个模拟器中编写的代码可以移植到C64或其他基于6502的机器上，只需进行一些额外工作来替换图形和I/O，使用它们特定设计的调用。
- en: '**C64 Programming**'
  id: totrans-236
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**C64编程**'
- en: Nowadays, we can do C64 programming and assembling on a modern machine, then
    just run the resulting executable machine code on a C64 emulator, such as the
    open source VICE emulator, which can be installed locally. To get started, install
    the Dasm assembler from *[https://dasm-assembler.github.io](https://dasm-assembler.github.io)*.
  id: totrans-237
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们可以在现代机器上进行 C64 编程和汇编，然后仅需在 C64 模拟器（如开源的 VICE 模拟器）上运行生成的可执行机器代码，该模拟器可以本地安装。要开始使用，首先安装
    *[https://dasm-assembler.github.io](https://dasm-assembler.github.io)* 上的 Dasm
    汇编器。
- en: 'Put your assembly code in a file such as *hello.asm*. Dasm requires the following
    two lines to be added to the start of the file to tell it to generate an executable
    for the C64 rather than other machines. They must have exactly eight spaces of
    indent:'
  id: totrans-238
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将你的汇编代码放在一个文件中，如 *hello.asm*。Dasm 需要在文件开头添加以下两行，以告诉它生成 C64 的可执行文件，而不是其他机器的可执行文件。它们必须精确地有八个空格的缩进：
- en: '[PRE25]'
  id: totrans-239
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Assemble your code into a C64 program (*.prg*) with:'
  id: totrans-240
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下命令将你的代码组装成 C64 程序 (*.prg*)：
- en: '[PRE26]'
  id: totrans-241
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'The *.prg* file can be imported into a C64 emulator, such as the online JavaScript-based
    emulator at *[https://c64emulator.111mb.de](https://c64emulator.111mb.de)*, or
    VICE. (For SID programs: some emulators, such as the JavaScript one mentioned
    here, have sound disabled by default, so you need to turn it on.)'
  id: totrans-242
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '*.prg* 文件可以导入到 C64 模拟器中，例如基于 JavaScript 的在线模拟器 *[https://c64emulator.111mb.de](https://c64emulator.111mb.de)*，或者
    VICE。（对于 SID 程序：某些模拟器，如这里提到的 JavaScript 模拟器，默认情况下禁用了声音，因此你需要手动启用它。）'
- en: If you’re lucky enough to have access to a real physical C64 and tape drive,
    you can also try converting your *.prg* files to tape images (*.tap*) and then
    sound waves (*.wav*) using a program such as *tap2wav.py* available at *[https://github.com/Zibri/C64](https://github.com/Zibri/C64)*.
    Then record the *.wav* to a physical tape to load to the read machine. Try inspecting
    the *.tap* and *.wav* files to see the 0s and 1s along the way.
  id: totrans-243
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果你足够幸运，能拥有一台真实的物理 C64 和磁带驱动器，你还可以尝试使用程序 *tap2wav.py*（可在 *[https://github.com/Zibri/C64](https://github.com/Zibri/C64)*
    上找到）将你的 *.prg* 文件转换为磁带镜像 (*.tap*)，然后再转换成声音波形 (*.wav*)。然后将 *.wav* 文件录制到物理磁带上，加载到读取机上。尝试检查
    *.tap* 和 *.wav* 文件，看看其中的 0 和 1 是如何表示的。
- en: '**Programming a Sprite-Based Game on the Amiga**'
  id: totrans-244
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**在 Amiga 上编程基于精灵的游戏**'
- en: 'Assemble and run the spaceship code shown in the “Programming the Amiga” section
    on [page 271](ch11.xhtml#ch11lev2sec1) as follows:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 按照 [第271页](ch11.xhtml#ch11lev2sec1) “编程 Amiga” 部分中的方法，组装并运行飞船代码，步骤如下：
- en: 'Download the vasm cross-assembler from *[http://sun.hasenbraten.de/vasm](http://sun.hasenbraten.de/vasm)*.
    Build it in Amiga mode with:'
  id: totrans-246
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从 *[http://sun.hasenbraten.de/vasm](http://sun.hasenbraten.de/vasm)* 下载 vasm
    交叉汇编器。以 Amiga 模式构建它，命令如下：
- en: '[PRE27]'
  id: totrans-247
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Use vasm to assemble your assembly program with:'
  id: totrans-248
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 vasm 来组装你的汇编程序，命令如下：
- en: '[PRE28]'
  id: totrans-249
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Install *amitools* for Python from *[https://pypi.org/project/amitools/](https://pypi.org/project/amitools/)*.
    Create a disk image and write the file to it, and make the disk image bootable
    with:'
  id: totrans-250
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从 *[https://pypi.org/project/amitools/](https://pypi.org/project/amitools/)*
    安装 Python 版本的 *amitools*。创建一个磁盘映像并将文件写入其中，使磁盘映像可以启动，命令如下：
- en: '[PRE29]'
  id: totrans-251
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Download and install the FS-UAE Amiga emulator from *[https://fs-uae.net/download](https://fs-uae.net/download)*.
    Run it and boot from your virtual *mydisk.adf* disk image.
  id: totrans-252
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从 *[https://fs-uae.net/download](https://fs-uae.net/download)* 下载并安装 FS-UAE
    Amiga 模拟器。运行它并从你的虚拟 *mydisk.adf* 磁盘映像启动。
- en: '**More Challenging**'
  id: totrans-253
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**更具挑战性**'
- en: Research how to read the Amiga keyboard or joystick, then extend the spaceship
    example into a simple game using the keyboard to move the sprite around. Research
    how to add double buffering to remove the flicker as the screen is redrawn during
    the loop.
  id: totrans-254
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 研究如何读取 Amiga 键盘或操纵杆，然后将飞船示例扩展为一个简单的游戏，使用键盘来控制精灵的移动。研究如何添加双缓冲以去除屏幕重绘时的闪烁。
- en: Building your own 6502-based computer has recently become a popular hobby. Take
    a look around YouTube and *[https://hackaday.com](https://hackaday.com)* to find
    examples of “6502 breadboard computers” and learn how they are made. You might
    try doing a rebuild of one of these existing designs, or making your own design.
  id: totrans-255
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最近，构建自己的基于 6502 的计算机已经成为一种流行的爱好。可以在 YouTube 和 *[https://hackaday.com](https://hackaday.com)*
    上查看“6502 面包板计算机”的示例，并了解它们是如何制作的。你可以尝试重建这些现有设计中的一个，或者自己设计一个。
- en: Further Reading
  id: totrans-256
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: 'To read the book that taught a generation of 8-bit programmer kids, see Lisa
    Watts and Mike Wharton, *Usborne Introduction to Machine Code for Beginners* (London:
    Usborne, 1983). The book is now freely available online at *[https://archive.org/details/machine-code-for-beginners](https://archive.org/details/machine-code-for-beginners)*.'
  id: totrans-257
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要阅读那本教导一代 8 位程序员孩子的书，请参见 Lisa Watts 和 Mike Wharton 的 *《Usborne 初学者机器码入门》*（伦敦：Usborne，1983）。该书现已在网上免费提供，访问
    *[https://archive.org/details/machine-code-for-beginners](https://archive.org/details/machine-code-for-beginners)*。
- en: 'For a guided tour of the C64 system from 1983, see J. Butterfield, ed., “Commodore
    64 Architecture,” *Computer!* 32 (January 1983): 208, *[https://www.atarimagazines.com/compute/issue32/112_1_COMMODORE_64_ARCHITECTURE.php](https://www.atarimagazines.com/compute/issue32/112_1_COMMODORE_64_ARCHITECTURE.php)*.'
  id: totrans-258
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要了解 1983 年 C64 系统的导览，请参考 J. Butterfield 主编的《Commodore 64 架构》，*Computer!* 32（1983年1月）：208，*
    [https://www.atarimagazines.com/compute/issue32/112_1_COMMODORE_64_ARCHITECTURE.php](https://www.atarimagazines.com/compute/issue32/112_1_COMMODORE_64_ARCHITECTURE.php)*。
- en: 'For information on 8 bit–era audio programming, see James Vogel and Nevin Scrimshaw,
    *The Commodore 64 Music Book* (Boston: Birkhauser, 1983), *[https://archive.org/details/The_Commodore_64_Music_Book/page/n3/mode/2up](https://archive.org/details/The_Commodore_64_Music_Book/page/n3/mode/2up)*.'
  id: totrans-259
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 若要获取关于 8 位时代音频编程的信息，请参见 James Vogel 和 Nevin Scrimshaw 的 *《Commodore 64 音乐书》*（波士顿：Birkhauser，1983），*
    [https://archive.org/details/The_Commodore_64_Music_Book/page/n3/mode/2up](https://archive.org/details/The_Commodore_64_Music_Book/page/n3/mode/2up)*。
- en: See *[https://github.com/emu-russia/breaks](https://github.com/emu-russia/breaks)*
    for a 6502 and NES rebuild in LogiSim.
  id: totrans-260
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 查看 *[https://github.com/emu-russia/breaks](https://github.com/emu-russia/breaks)*
    获取 LogiSim 中的 6502 和 NES 重建。
