- en: Chapter 34. Process Groups, Sessions, and Job Control
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第34章：进程组、会话和作业控制
- en: 'Process groups and sessions form a two-level hierarchical relationship between
    processes: a process group is a collection of related processes, and a session
    is a collection of related process groups. The meaning of the term *related* in
    each case will become clear in the course of this chapter.'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 进程组和会话在进程之间形成了一个二级层次结构关系：进程组是相关进程的集合，会话是相关进程组的集合。每种情况下“相关”的含义将在本章中得到明确说明。
- en: Process groups and sessions are abstractions defined to support shell job control,
    which allows interactive users to run commands in the foreground or in the background.
    The term *job* is often used synonymously with the term *process group*.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 进程组和会话是为支持 Shell 作业控制而定义的抽象概念，它允许交互式用户在前台或后台运行命令。术语*作业*通常与*进程组*一词同义使用。
- en: This chapter describes process groups, sessions, and job control.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章描述了进程组、会话和作业控制。
- en: Overview
  id: totrans-4
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 概述
- en: A *process group* is a set of one or more processes sharing the same *process
    group identifier* (PGID). A process group ID is a number of the same type (*pid_t*)
    as a process ID. A process group has a *process group leader*, which is the process
    that creates the group and whose process ID becomes the process group ID of the
    group. A new process inherits its parent’s process group ID.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: '*进程组*是一个或多个进程共享相同*进程组标识符*（PGID）的集合。进程组 ID 是与进程 ID 类型相同的数字（*pid_t*）。每个进程组都有一个*进程组领导进程*，即创建该组的进程，其进程
    ID 成为该进程组的进程组 ID。新进程继承其父进程的进程组 ID。'
- en: A process group has a *lifetime*, which is the period of time beginning when
    the leader creates the group and ending when the last member process leaves the
    group. A process may leave a process group either by terminating or by joining
    another process group. The process group leader need not be the last member of
    a process group.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 进程组有一个*生命周期*，即从领导进程创建该组开始，到最后一个成员进程离开该组为止的时间段。进程可以通过终止或加入另一个进程组来离开当前的进程组。进程组的领导进程不一定是进程组中的最后一个成员。
- en: A *session* is a collection of process groups. A process’s session membership
    is determined by its *session identifier* (SID), which, like the process group
    ID, is a number of type *pid_t*. A *session leader* is the process that creates
    a new session and whose process ID becomes the session ID. A new process inherits
    its parent’s session ID.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: '*会话*是多个进程组的集合。进程的会话成员身份由其*会话标识符*（SID）决定，SID和进程组 ID 一样，都是*pid_t* 类型的数字。*会话领导进程*是创建新会话的进程，其进程
    ID 成为会话 ID。新进程继承其父进程的会话 ID。'
- en: All of the processes in a session share a single *controlling terminal*. The
    controlling terminal is established when the session leader first opens a terminal
    device. A terminal may be the controlling terminal of at most one session.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 会话中的所有进程共享一个*控制终端*。控制终端是在会话领导进程首次打开终端设备时建立的。一个终端最多只能是一个会话的控制终端。
- en: At any point in time, one of the process groups in a session is the *foreground
    process group* for the terminal, and the others are *background process groups*.
    Only processes in the foreground process group can read input from the controlling
    terminal. When the user types one of the signal-generating terminal characters
    on the controlling terminal, a signal is sent to all members of the foreground
    process group. These characters are the *interrupt* character (usually *Control-C*),
    which generates `SIGINT`; the *quit* character (usually *Control-\*), which generates
    `SIGQUIT`; and the *suspend* character (usually *Control-Z*), which generates
    `SIGTSTP`.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 在任何时候，会话中的一个进程组是终端的*前台进程组*，其他进程组则是*后台进程组*。只有前台进程组中的进程可以从控制终端读取输入。当用户在控制终端输入某个信号生成字符时，信号会发送给前台进程组中的所有成员。这些字符包括*中断*字符（通常是*Control-C*，生成`SIGINT`信号）；*退出*字符（通常是*Control-\*，生成`SIGQUIT`信号）；和*挂起*字符（通常是*Control-Z*，生成`SIGTSTP`信号）。
- en: As a consequence of establishing the connection to (i.e., opening) the controlling
    terminal, the session leader becomes the *controlling process* for the terminal.
    The principal significance of being the controlling process is that the kernel
    sends this process a `SIGHUP` signal if a terminal disconnect occurs.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 作为与控制终端建立连接（即打开终端）的结果，会话领导进程成为该终端的*控制进程*。成为控制进程的主要意义在于，如果发生终端断开，内核会向该进程发送`SIGHUP`信号。
- en: Note
  id: totrans-11
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: By inspecting the Linux-specific `/proc/`*PID*`/stat` files, we can determine
    the process group ID and session ID of any process. We can also determine the
    device ID of the process’s controlling terminal (expressed as a single decimal
    integer containing both major and minor IDs) and the process ID of the controlling
    process for that terminal. See the *proc(5)* manual page for further details.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 通过检查 Linux 特定的 `/proc/`*PID*`/stat` 文件，我们可以确定任何进程的进程组 ID 和会话 ID。我们还可以确定进程控制终端的设备
    ID（以包含主次设备 ID 的单一十进制整数表示）以及该终端的控制进程的进程 ID。有关更多详细信息，请参阅*proc(5)*手册页。
- en: The main use of sessions and process groups is for shell job control. Looking
    at a specific example from this domain helps clarify these concepts. For an interactive
    login, the controlling terminal is the one on which the user logs in. The login
    shell becomes the session leader and the controlling process for the terminal,
    and is also made the sole member of its own process group. Each command or pipeline
    of commands started from the shell results in the creation of one or more processes,
    and the shell places all of these processes in a new process group. (These processes
    are initially the only members of that process group, although any child processes
    that they create will also be members of the group.) A command or pipeline is
    created as a background process group if it is terminated with an ampersand (`&`).
    Otherwise, it becomes the foreground process group. All processes created during
    the login session are part of the same session.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 会话和进程组的主要用途是用于 shell 作业控制。通过查看来自该领域的具体示例，有助于澄清这些概念。对于交互式登录，控制终端是用户登录的终端。登录 shell
    成为会话的领导者和该终端的控制进程，并且也成为其进程组的唯一成员。每个从 shell 启动的命令或命令管道都会创建一个或多个进程，shell 将这些进程放入一个新的进程组中。（这些进程最初是该进程组的唯一成员，尽管它们创建的任何子进程也会成为该组的成员。）如果一个命令或管道以一个与符号（`&`）结束，它将作为一个后台进程组创建。否则，它将成为前台进程组。所有在登录会话期间创建的进程都属于同一个会话。
- en: Note
  id: totrans-14
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: In a windowing environment, the controlling terminal is a pseudoterminal, and
    there is a separate session for each terminal window, with the window’s startup
    shell being the session leader and controlling process for the terminal.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在图形环境中，控制终端是一个伪终端，每个终端窗口都有一个独立的会话，窗口的启动 shell 是会话的领导者和该终端的控制进程。
- en: 'Process groups occasionally find uses in areas other than job control, since
    they have two useful properties: a parent process can wait on any of its children
    in a particular process group ([The *waitpid()* System Call](ch26.html#the_waitpid_open_parenthesis_close_paren
    "The waitpid() System Call")), and a signal can be sent to all of the members
    of a process group ([Sending Signals: *kill()*](ch20.html#sending_signals_colon_kill_open_parenthe
    "Sending Signals: kill()")).'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 进程组偶尔在作业控制以外的领域也有应用，因为它们具有两个有用的属性：父进程可以在特定进程组中的任何子进程上等待（[*waitpid()* 系统调用](ch26.html#the_waitpid_open_parenthesis_close_paren
    "waitpid() 系统调用")），并且可以向进程组的所有成员发送信号（[发送信号：*kill()*](ch20.html#sending_signals_colon_kill_open_parenthe
    "发送信号：kill()")）。
- en: '[Figure 34-1](ch34.html#relationships_between_process_groups_com "Figure 34-1. Relationships
    between process groups, sessions, and the controlling terminal") shows the process
    group and session relationships between the various processes resulting from the
    execution of the following commands:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 34-1](ch34.html#relationships_between_process_groups_com "图 34-1. 进程组、会话和控制终端之间的关系")
    展示了由执行以下命令所产生的各个进程之间的进程组和会话关系：'
- en: '[PRE0]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: At this point, the shell (*bash*), *find*, *wc*, *sort*, and *uniq* are all
    running.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 此时，shell（*bash*）、*find*、*wc*、*sort* 和 *uniq* 都在运行。
- en: '![Relationships between process groups, sessions, and the controlling terminal](figs/web/34-1_PGSJC-overview.png.jpg)Figure 34-1. Relationships
    between process groups, sessions, and the controlling terminal'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: '![进程组、会话和控制终端之间的关系](figs/web/34-1_PGSJC-overview.png.jpg)图 34-1. 进程组、会话和控制终端之间的关系'
- en: Process Groups
  id: totrans-21
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 进程组
- en: Each process has a numeric process group ID that defines the process group to
    which it belongs. A new process inherits its parent’s process group ID. A process
    can obtain its process group ID using *getpgrp()*.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 每个进程都有一个数字型的进程组 ID，用于定义它所属的进程组。一个新进程会继承其父进程的进程组 ID。一个进程可以使用*getpgrp()*来获取其进程组
    ID。
- en: '[PRE1]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Note
  id: totrans-24
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Always successfully returns process group ID of calling process
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 始终成功返回调用进程的进程组 ID
- en: If the value returned by *getpgrp()* matches the caller’s process ID, this process
    is the leader of its process group.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 *getpgrp()* 返回的值与调用进程的进程 ID 匹配，则该进程是其进程组的领导者。
- en: The *setpgid()* system call changes the process group of the process whose process
    ID is *pid* to the value specified in *pgid*.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: '*setpgid()* 系统调用将进程 ID 为 *pid* 的进程的进程组更改为 *pgid* 中指定的值。'
- en: '[PRE2]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Note
  id: totrans-29
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Returns 0 on success, or -1 on error
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 成功时返回 0，出错时返回 -1
- en: 'If *pid* is specified as 0, the calling process’s process group ID is changed.
    If *pgid* is specified as 0, then the process group ID of the process specified
    by *pid* is made the same as its process ID. Thus, the following *setpgid()* calls
    are equivalent:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 *pid* 被指定为 0，则调用进程的进程组 ID 会被更改。如果 *pgid* 被指定为 0，则由 *pid* 指定的进程的进程组 ID 会与其进程
    ID 相同。因此，以下 *setpgid()* 调用是等效的：
- en: '[PRE3]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: If the *pid* and *pgid* arguments specify the same process (i.e., *pgid* is
    0 or matches the process ID of the process specified by *pid*), then a new process
    group is created, and the specified process is made the leader of the new group
    (i.e., the process group ID of the process is made the same as its process ID).
    If the two arguments specify different values (i.e., *pgid* is not 0 and doesn’t
    match the process ID of the process specified by *pid*), then *setpgid()* is being
    used to move a process between process groups.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 *pid* 和 *pgid* 参数指定相同的进程（即 *pgid* 为 0 或与由 *pid* 指定的进程的进程 ID 匹配），则会创建一个新的进程组，并将指定的进程设为新组的领导者（即进程的进程组
    ID 会与其进程 ID 相同）。如果这两个参数指定不同的值（即 *pgid* 不为 0 且与由 *pid* 指定的进程的进程 ID 不匹配），则 *setpgid()*
    用于将进程从一个进程组移动到另一个进程组。
- en: The typical callers of *setpgid()* (and *setsid()*, described in [Sessions](ch34.html#sessions
    "Sessions")) are programs such as the shell and *login(1)*. In [Creating a Daemon](ch37.html#creating_a_daemon
    "Creating a Daemon"), we’ll see that a program also calls *setsid()* as one of
    the steps on the way to becoming a daemon.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: '*setpgid()*（以及在 [会话](ch34.html#sessions "Sessions") 中描述的 *setsid()*）的典型调用者是像
    shell 和 *login(1)* 这样的程序。在 [创建守护进程](ch37.html#creating_a_daemon "Creating a Daemon")
    中，我们将看到一个程序也会在成为守护进程的过程中调用 *setsid()*。'
- en: 'Several restrictions apply when calling *setpgid()*:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 调用 *setpgid()* 时有若干限制：
- en: The *pid* argument may specify only the calling process or one of its children.
    Violation of this rule results in the error `ESRCH`.
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*pid* 参数只能指定调用进程或其子进程之一。违反此规则会导致错误 `ESRCH`。'
- en: When moving a process between groups, the calling process and the process specified
    by *pid* (which may be one and the same), as well as the target process group,
    must all be part of the same session. Violation of this rule results in the error
    `EPERM`.
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当将进程在进程组之间移动时，调用进程和 *pid* 所指定的进程（可能是同一个进程），以及目标进程组，必须都属于同一会话。违反此规则会导致错误 `EPERM`。
- en: The *pid* argument may not specify a process that is a session leader. Violation
    of this rule results in the error `EPERM`.
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*pid* 参数不能指定会话领导进程。违反此规则会导致错误 `EPERM`。'
- en: A process may not change the process group ID of one of its children after that
    child has performed an *exec()*. Violation of this rule results in the error `EACCES`.
    The rationale for this constraint is that it could confuse a program if its process
    group ID were changed after it had commenced.
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在子进程执行 *exec()* 后，进程不能更改该子进程的进程组 ID。违反此规则会导致错误 `EACCES`。此约束的理由是，如果在程序开始执行后更改其进程组
    ID，可能会混淆该程序。
- en: Using *setpgid()* in a job-control shell
  id: totrans-40
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 在作业控制 shell 中使用 *setpgid()*。
- en: 'The restriction that a process may not change the process group ID of one of
    its children after that child has performed an *exec()* affects the programming
    of job-control shells, which have the following requirements:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 进程在其子进程执行 *exec()* 后不能更改该子进程的进程组 ID，这一限制影响了作业控制 shell 的编程，作业控制 shell 有以下要求：
- en: All of the processes in a job (i.e., a command or a pipeline) must be placed
    in a single process group. (We can see the desired result by looking at the two
    process groups created by *bash* in [Figure 34-1](ch34.html#relationships_between_process_groups_com
    "Figure 34-1. Relationships between process groups, sessions, and the controlling
    terminal").) This step permits the shell to use *killpg()* (or, equivalently,
    *kill()* with a negative *pid* argument) to simultaneously send job-control signals
    to all of the members of the process group. Naturally, this step must be carried
    out before any job-control signals are sent.
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 作业中的所有进程（即一个命令或一个管道）必须放入一个单一的进程组中。（我们可以通过查看[图 34-1](ch34.html#relationships_between_process_groups_com
    "图 34-1. 进程组、会话和控制终端之间的关系")中*bash*创建的两个进程组，来看到期望的结果。）这一步骤允许 shell 使用*killpg()*（或等效的，用负的*pid*参数调用*kill()*）同时向进程组中的所有成员发送作业控制信号。当然，这一步必须在发送任何作业控制信号之前完成。
- en: Each of the child processes must be transferred to the process group before
    it execs a program, since the program itself is ignorant of manipulations of the
    process group ID.
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每个子进程必须在执行程序之前被转移到进程组中，因为程序本身对进程组 ID 的操作是无感知的。
- en: For each process in the job, either the parent or the child could use *setpgid()*
    to change the process group ID of the child. However, because the scheduling of
    the parent and child is indeterminate after a *fork()* ([Race Conditions After
    *fork()*](ch24.html#race_conditions_after_fork_open_parenthe "Race Conditions
    After fork()")), we can’t rely on the parent changing the child’s process group
    ID before the child does an *exec()*; nor can we rely on the child changing its
    process group ID before the parent tries to send any job-control signals to it.
    (Dependence on either one of these behaviors would result in a race condition.)
    Therefore, job-control shells are programmed so that the parent and the child
    process both call *setpgid()* to change the child’s process group ID to the same
    value immediately after a *fork()*, and the parent ignores any occurrence of the
    `EACCES` error on the *setpgid()* call. In other words, in a job-control shell,
    we’ll find code something like that shown in [Example 34-1](ch34.html#how_a_job-control_shell_sets_the_process
    "Example 34-1. How a job-control shell sets the process group ID of a child process").
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 对于作业中的每个进程，父进程或子进程都可以使用*setpgid()*来更改子进程的进程组 ID。然而，由于在*fork()*之后父子进程的调度是不可预测的（[*fork()*后的竞争条件](ch24.html#race_conditions_after_fork_open_parenthe
    "fork()后的竞争条件")），我们不能依赖父进程在子进程执行*exec()*之前更改子进程的进程组 ID；也不能依赖子进程在父进程尝试发送任何作业控制信号之前更改其进程组
    ID。（依赖这两种行为中的任何一种都会导致竞争条件。）因此，作业控制 shell 的编程方式是，父进程和子进程都在*fork()*之后立即调用*setpgid()*将子进程的进程组
    ID更改为相同的值，并且父进程会忽略*setpgid()*调用时出现的`EACCES`错误。换句话说，在作业控制 shell 中，我们会找到类似[示例 34-1](ch34.html#how_a_job-control_shell_sets_the_process
    "示例 34-1. 如何通过作业控制 shell 设置子进程的进程组 ID")所示的代码。
- en: Example 34-1. How a job-control shell sets the process group ID of a child process
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 34-1. 如何通过作业控制 shell 设置子进程的进程组 ID
- en: '[PRE4]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Things are slightly more complex than shown in [Example 34-1](ch34.html#how_a_job-control_shell_sets_the_process
    "Example 34-1. How a job-control shell sets the process group ID of a child process"),
    since, when creating the processes for a pipeline, the parent shell records the
    process ID of the first process in the pipeline and uses this as the process group
    ID (*pipelinePgid*) for all of the processes in the group.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 情况比在[示例 34-1](ch34.html#how_a_job-control_shell_sets_the_process "示例 34-1. 如何通过作业控制
    shell 设置子进程的进程组 ID")中展示的要复杂一些，因为在为管道创建进程时，父 shell 会记录管道中第一个进程的进程 ID，并将其作为该进程组中所有进程的进程组
    ID（*pipelinePgid*）。
- en: Other (obsolete) interfaces for retrieving and modifying process group IDs
  id: totrans-48
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 其他（过时的）用于检索和修改进程组ID的接口
- en: The different suffixes in the names of the *getpgrp()* and *setpgid()* system
    calls deserve explanation.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: '*getpgrp()*和*setpgid()*系统调用名称中不同的后缀值得解释。'
- en: In the beginning, 4.2BSD provided a *getprgp(pid)* system call that returned
    the process group ID of the process specified by *pid*. In practice, *pid* was
    always used to specify the calling process. Consequently, the POSIX committee
    deemed the call to be more complex than necessary, and instead adopted the System
    V *getpgrp()* call, which took no arguments and returned the process group ID
    of the calling process.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 起初，4.2BSD 提供了一个 *getprgp(pid)* 系统调用，返回由 *pid* 指定的进程的进程组 ID。在实践中，*pid* 总是用来指定调用进程。因此，POSIX
    委员会认为这个调用比必要的更复杂，改为采用了不需要参数的 System V *getpgrp()* 调用，返回调用进程的进程组 ID。
- en: In order to change the process group ID, 4.2BSD provided the call *setpgrp(pid,
    pgid)*, which operated in a similar manner to *setpgid()*. The principal difference
    was that the BSD *setpgrp()* could be used to set the process group ID to any
    value. (We noted earlier that *setpgid()* can’t transfer a process into a process
    group in a different session.) This resulted in some security issues and was also
    more flexible than required for implementing job control. Consequently, the POSIX
    committee settled on a more restrictive function and gave it the name *setpgid()*.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更改进程组 ID，4.2BSD 提供了 *setpgrp(pid, pgid)* 调用，该调用的操作方式与 *setpgid()* 类似。主要区别在于
    BSD 的 *setpgrp()* 可以将进程组 ID 设置为任何值。（我们之前提到过 *setpgid()* 不能将进程转移到不同会话中的进程组。）这导致了一些安全问题，并且在实现作业控制时比必要的更加灵活。因此，POSIX
    委员会选择了一个更具限制性的函数，并命名为 *setpgid()*。
- en: To further complicate matters, SUSv3 specifies *getpgid(pid)*, with the same
    semantics as the old BSD *getpgrp()*, and also weakly specifies an alternative,
    System V-derived version of *setpgrp()*, taking no arguments, as being approximately
    equivalent to *setpgid(0, 0)*.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使问题更加复杂，SUSv3 规定了 *getpgid(pid)*，其语义与旧的 BSD *getpgrp()* 相同，并且还弱地规定了一个替代的 System
    V 衍生版 *setpgrp()*，不接受任何参数，大致相当于 *setpgid(0, 0)*。
- en: Although the *setpgid()* and *getpgrp()* system calls that we described earlier
    are sufficient for implementing shell job control, Linux, like most other UNIX
    implementations, also provides *getpgid(pid)* and *setpgrp(void)*. For backward
    compatibility, many BSD-derived implementations continue to provide *setprgp(pid,
    pgid)* as a synonym for *setpgid(pid, pgid)*.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管我们之前描述的 *setpgid()* 和 *getpgrp()* 系统调用足以实现 shell 作业控制，但 Linux 和大多数其他 UNIX
    实现也提供了 *getpgid(pid)* 和 *setpgrp(void)*。为了向后兼容，许多 BSD 衍生实现继续提供 *setprgp(pid, pgid)*
    作为 *setpgid(pid, pgid)* 的同义词。
- en: If we explicitly define the `_BSD_SOURCE` feature test macro when compiling
    a program, then *glibc* provides the BSD-derived versions of *setpgrp()* and *getpgrp()*,
    instead of the default versions.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们在编译程序时显式定义了 `_BSD_SOURCE` 特性测试宏，那么 *glibc* 会提供基于 BSD 的 *setpgrp()* 和 *getpgrp()*
    版本，而不是默认版本。
- en: Sessions
  id: totrans-55
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 会话
- en: A *session* is a collection of process groups. The session membership of a process
    is defined by its numeric session ID. A new process inherits its parent’s session
    ID. The *getsid()* system call returns the session ID of the process specified
    by *pid*.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 会话是进程组的集合。进程的会话成员身份由其数字会话 ID 定义。一个新进程继承其父进程的会话 ID。*getsid()* 系统调用返回由 *pid* 指定的进程的会话
    ID。
- en: '[PRE5]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Note
  id: totrans-58
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Returns session ID of specified process, or *(pid_t)* -1 on error
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 返回指定进程的会话 ID，或在错误时返回 *(pid_t)* -1
- en: If *pid* is specified as 0, *getsid()* returns the session ID of the calling
    process.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 *pid* 被指定为 0，*getsid()* 将返回调用进程的会话 ID。
- en: Note
  id: totrans-61
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: On a few UNIX implementations (e.g., HP-UX 11), *getsid()* can be used to retrieve
    the session ID of a process only if it is in the same session as the calling process.
    (SUSv3 permits this possibility.) In other words, the call merely serves, by its
    success or failure (`EPERM`), to inform us if the specified process is in the
    same session as the caller. This restriction doesn’t apply on Linux or on most
    other implementations.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 在一些 UNIX 实现（例如 HP-UX 11）中，*getsid()* 只能在进程与调用进程属于同一会话时才能用来检索进程的会话 ID。（SUSv3
    允许这种可能性。）换句话说，这个调用仅通过其成功或失败（`EPERM`）来告知我们指定的进程是否与调用者处于同一会话。这种限制不适用于 Linux 或大多数其他实现。
- en: If the calling process is not a process group leader, *setsid()* creates a new
    session.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 如果调用进程不是进程组的领导者，*setsid()* 将创建一个新的会话。
- en: '[PRE6]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Note
  id: totrans-65
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Returns session ID of new session, or *(pid_t)* -1 on error
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 返回新会话的会话 ID，或在错误时返回 *(pid_t)* -1
- en: 'The *setsid()* system call creates a new session as follows:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: '*setsid()* 系统调用创建一个新会话，具体如下：'
- en: The calling process becomes the leader of a new session, ands is made the leader
    of a new process group within that session. The calling process’s process group
    ID and session ID are set to the same value as its process ID.
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 调用进程成为新会话的领导者，并成为该会话内新进程组的领导者。调用进程的进程组ID和会话ID被设置为与其进程ID相同的值。
- en: The calling process has no controlling terminal. Any previously existing connection
    to a controlling terminal is broken.
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 调用进程没有控制终端。任何之前存在的与控制终端的连接都会被断开。
- en: If the calling process is a process group leader, *setsid()* fails with the
    error `EPERM`. The simplest way of ensuring that this doesn’t happen is to perform
    a *fork()* and have the parent exit while the child carries on to call *setsid()*.
    Since the child inherits its parent’s process group ID and receives its own unique
    process ID, it can’t be a process group leader.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 如果调用进程是进程组领导者，*setsid()*将失败并返回错误`EPERM`。确保不发生这种情况的最简单方法是执行*fork()*并让父进程退出，而子进程继续调用*setsid()*。由于子进程继承了父进程的进程组ID并获得了自己的唯一进程ID，因此它不能成为进程组领导者。
- en: The restriction against a process group leader being able to call *setsid()*
    is necessary because, without it, the process group leader would be able to place
    itself in another (new) session, while other members of the process group remained
    in the original session. (A new process group would not be created, since, by
    definition, the process group leader’s process group ID is already the same as
    its process ID.) This would violate the strict two-level hierarchy of sessions
    and process groups, whereby all members of a process group must be part of the
    same session.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 对进程组领导者不能调用*setsid()*的限制是必要的，因为如果没有此限制，进程组领导者将能够将自己置于另一个（新的）会话中，而进程组中的其他成员仍然保留在原始会话中。（不会创建新的进程组，因为按定义，进程组领导者的进程组ID已经与其进程ID相同。）这会违反严格的两级会话和进程组层次结构，其中进程组的所有成员必须属于同一个会话。
- en: Note
  id: totrans-72
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: When a new process is created via *fork()*, the kernel ensures not only that
    it has a unique process ID, but also that the process ID doesn’t match the process
    group ID or session ID of any existing process. Thus, even if the leader of a
    process group or a session has exited, a new process can’t reuse the leader’s
    process ID and thereby accidentally become the leader of an existing session or
    process group.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 当通过*fork()*创建新进程时，内核不仅确保它具有唯一的进程ID，而且确保进程ID与任何现有进程的进程组ID或会话ID不匹配。因此，即使进程组或会话的领导者已经退出，新进程也不能重用领导者的进程ID，从而意外成为现有会话或进程组的领导者。
- en: '[Example 34-2](ch34.html#creating_a_new_session "Example 34-2. Creating a new
    session") demonstrates the use of *setsid()* to create a new session. To check
    that it no longer has a controlling terminal, this program attempts to open the
    special file `/dev/tty` (described in the next section). When we run this program,
    we see the following:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 34-2](ch34.html#creating_a_new_session "示例 34-2. 创建新会话")演示了如何使用*setsid()*来创建一个新会话。为了检查它不再拥有控制终端，程序尝试打开特殊文件`/dev/tty`（将在下一节描述）。当我们运行此程序时，会看到以下内容：'
- en: '[PRE7]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: As can be seen from the output, the process successfully places itself in a
    new process group within a new session. Since this session has no controlling
    terminal, the *open()* call fails. (In the penultimate line of program output
    above, we see a shell prompt mixed with the program output, because the shell
    notices that the parent process has exited after the *fork()* call, and so prints
    its next prompt before the child has completed.)
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 从输出中可以看出，进程成功地将自己放置在一个新的进程组中，并且该进程组属于一个新会话。由于此会话没有控制终端，*open()*调用失败。（在上面程序输出的倒数第二行中，我们看到一个与程序输出混合的shell提示符，因为shell注意到在*fork()*调用后父进程已经退出，因此在子进程完成之前打印出下一个提示符。）
- en: Example 34-2. Creating a new session
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 34-2. 创建新会话
- en: '[PRE8]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Controlling Terminals and Controlling Processes
  id: totrans-79
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 控制终端和控制进程
- en: All of the processes in a session may have a (single) controlling terminal.
    Upon creation, a session has no controlling terminal; the controlling terminal
    is established when the session leader first opens a terminal that is not already
    the controlling terminal for a session, unless the `O_NOCTTY` flag is specified
    when calling *open()*. A terminal may be the controlling terminal for at most
    one session.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 会话中的所有进程可能有一个（单一的）控制终端。创建时，会话没有控制终端；控制终端是在会话领导者首次打开一个未作为任何会话的控制终端的终端时建立的，除非在调用*open()*时指定了`O_NOCTTY`标志。一个终端最多只能是一个会话的控制终端。
- en: Note
  id: totrans-81
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: SUSv3 specifies the function *tcgetsid(int fd)* (prototyped in `<termios.h>`),
    which returns the ID of the session associated with the controlling terminal specified
    by *fd*. This function is provided in *glibc* (where it is implemented using the
    *ioctl()* `TIOCGSID` operation).
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: SUSv3 指定了函数 *tcgetsid(int fd)*（在 `<termios.h>` 中声明），该函数返回与指定 *fd* 的控制终端关联的会话
    ID。这个函数在 *glibc* 中提供（其通过 *ioctl()* 的 `TIOCGSID` 操作实现）。
- en: The controlling terminal is inherited by the child of a *fork()* and preserved
    across an *exec()*.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 控制终端是由 *fork()* 的子进程继承的，并且在 *exec()* 之后保持不变。
- en: When a session leader opens a controlling terminal, it simultaneously becomes
    the controlling process for the terminal. If a terminal disconnect subsequently
    occurs, the kernel sends the controlling process a `SIGHUP` signal to inform it
    of this event. We go into further detail on this point in [`SIGHUP` and Termination
    of the Controlling Process](ch34.html#sighup_and_termination_of_the_controllin
    "SIGHUP and Termination of the Controlling Process").
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 当会话领导者打开控制终端时，它同时也成为该终端的控制进程。如果随后发生终端断开连接，内核会向控制进程发送 `SIGHUP` 信号，通知它这一事件。我们在
    [`SIGHUP` 和控制进程终止](ch34.html#sighup_and_termination_of_the_controllin "SIGHUP
    and Termination of the Controlling Process") 中会进一步详细说明这一点。
- en: If a process has a controlling terminal, opening the special file `/dev/tty`
    obtains a file descriptor for that terminal. This is useful if standard input
    and output are redirected, and a program wants to ensure that it is communicating
    with the controlling terminal. For example, the *getpass()* function described
    in [Password Encryption and User Authentication](ch08.html#password_encryption_and_user_authenticat
    "Password Encryption and User Authentication") opens `/dev/tty` for this purpose.
    If the process doesn’t have a controlling terminal, opening `/dev/tty` fails with
    the error `ENXIO`.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一个进程有控制终端，打开特殊文件 `/dev/tty` 会获取该终端的文件描述符。如果标准输入和输出被重定向，并且程序希望确保与控制终端通信，这是非常有用的。例如，[密码加密与用户认证](ch08.html#password_encryption_and_user_authenticat
    "Password Encryption and User Authentication") 中描述的 *getpass()* 函数就是为此目的打开 `/dev/tty`。如果进程没有控制终端，打开
    `/dev/tty` 会因为错误 `ENXIO` 失败。
- en: Removing a process’s association with the controlling terminal
  id: totrans-86
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 移除进程与控制终端的关联
- en: The *ioctl(fd, TIOCNOTTY)* operation can be used to remove a process’s association
    with its controlling terminal, specified via the file descriptor *fd*. After this
    call, attempts to open `/dev/tty` will fail. (Although not specified in SUSv3,
    the `TIOCNOTTY` operation is supported on most UNIX implementations.)
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: '*ioctl(fd, TIOCNOTTY)* 操作可以用来移除进程与其控制终端的关联，控制终端通过文件描述符 *fd* 指定。调用此操作后，尝试打开
    `/dev/tty` 将会失败。（虽然在 SUSv3 中没有明确规定，但 `TIOCNOTTY` 操作在大多数 UNIX 实现中都被支持。）'
- en: 'If the calling process is the controlling process for the terminal, then as
    for the termination of the controlling process ([`SIGHUP` and Termination of the
    Controlling Process](ch34.html#sighup_and_termination_of_the_controllin "SIGHUP
    and Termination of the Controlling Process")), the following steps occur:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 如果调用进程是终端的控制进程，那么与控制进程终止时的处理方式类似（参见 [`SIGHUP` 和控制进程终止](ch34.html#sighup_and_termination_of_the_controllin
    "SIGHUP and Termination of the Controlling Process")），以下步骤将发生：
- en: All processes in the session lose their association with the controlling terminal.
  id: totrans-89
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 会话中的所有进程都会失去与控制终端的关联。
- en: The controlling terminal loses its association with the session, and can therefore
    be acquired as the controlling process by another session leader.
  id: totrans-90
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 控制终端失去与会话的关联，因此可以被另一个会话领导者作为控制进程获取。
- en: The kernel sends a `SIGHUP` signal (and a `SIGCONT` signal) to all members of
    the foreground process group, to inform them of the loss of the controlling terminal.
  id: totrans-91
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 内核向前台进程组的所有成员发送 `SIGHUP` 信号（以及 `SIGCONT` 信号），以通知它们控制终端丢失。
- en: Establishing a controlling terminal on BSD
  id: totrans-92
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 在 BSD 上建立控制终端
- en: SUSv3 leaves the manner in which a session acquires a controlling terminal unspecified,
    merely stating that specifying the `O_NOCTTY` flag when opening a terminal guarantees
    that the terminal won’t become a controlling terminal for the session. The Linux
    semantics that we have described above derive from System V.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: SUSv3 并没有明确指定会话如何获取控制终端，只是声明在打开终端时指定 `O_NOCTTY` 标志可以保证该终端不会成为会话的控制终端。我们在上面描述的
    Linux 语义源自 System V。
- en: 'On BSD systems, opening a terminal in the session leader never causes the terminal
    to become a controlling terminal, regardless of whether the `O_NOCTTY` flag is
    specified. Instead, the session leader uses the *ioctl()* `TIOCSCTTY` operation
    to explicitly establish the terminal referred to by the file descriptor *fd* as
    the controlling terminal:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 在 BSD 系统中，打开终端时，即使指定了 `O_NOCTTY` 标志，终端也不会成为控制终端。相反，会话领导进程使用 *ioctl()* 的 `TIOCSCTTY`
    操作显式地将文件描述符 *fd* 所指向的终端设为控制终端：
- en: '[PRE9]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: This operation can be performed only if the session doesn’t already have a controlling
    terminal.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 只有当会话还没有控制终端时，才能执行此操作。
- en: The `TIOCSCTTY` operation is also available on Linux, but it is not widespread
    on other (non-BSD) implementations.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: '`TIOCSCTTY` 操作在 Linux 上也可用，但在其他（非 BSD）实现中并不普遍。'
- en: 'Obtaining a pathname that refers to the controlling terminal: *ctermid()*'
  id: totrans-98
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 获取指向控制终端的路径名：*ctermid()*
- en: The *ctermid()* function returns a pathname referring to the controlling terminal.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: '*ctermid()* 函数返回一个路径名，指向控制终端。'
- en: '[PRE10]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Note
  id: totrans-101
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Returns pointer to string containing pathname of controlling terminal, or `NULL`
    if pathname could not be determined
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 返回指向包含控制终端路径名的字符串的指针，若路径名无法确定，则返回 `NULL`
- en: 'The *ctermid()* function returns the controlling terminal’s pathname in two
    different ways: via the function result and via the buffer pointed to by *ttyname*.'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: '*ctermid()* 函数通过两种方式返回控制终端的路径名：通过函数结果和通过 *ttyname* 指向的缓冲区。'
- en: If *ttyname* is not `NULL`, then it should be a buffer of at least `L_ctermid`
    bytes, and the pathname is copied into this array. In this case, the function
    return value is also a pointer to this buffer. If *ttyname* is `NULL`, *ctermid()*
    returns a pointer to a statically allocated buffer containing the pathname. When
    *ttyname* is `NULL`, *ctermid()* is not reentrant.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 *ttyname* 不是 `NULL`，则它应为至少 `L_ctermid` 字节的缓冲区，路径名将被复制到此数组中。在这种情况下，函数的返回值也是指向该缓冲区的指针。如果
    *ttyname* 是 `NULL`，*ctermid()* 会返回指向一个静态分配的缓冲区的指针，缓冲区包含路径名。当 *ttyname* 是 `NULL`
    时，*ctermid()* 不是可重入的。
- en: On Linux and other UNIX implementations, *ctermid()* typically yields the string
    `/dev/tty`. The purpose of this function is to ease portability to non-UNIX systems.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Linux 和其他 UNIX 实现中，*ctermid()* 通常返回字符串 `/dev/tty`。此函数的目的是简化向非 UNIX 系统的可移植性。
- en: Foreground and Background Process Groups
  id: totrans-106
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 前台和后台进程组
- en: The controlling terminal maintains the notion of a foreground process group.
    Within a session, only one process group can be in the foreground at a particular
    moment; all of the other process groups in the session are background process
    groups. The foreground process group is the only process group that can freely
    read and write on the controlling terminal. When one of the signal-generating
    terminal characters is typed on the controlling terminal, the terminal driver
    delivers the corresponding signal to the members of the foreground process group.
    We describe further details in Section 34.7.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 控制终端维护前台进程组的概念。在一个会话中，只有一个进程组可以在某一时刻处于前台；该会话中的所有其他进程组为后台进程组。前台进程组是唯一可以自由读取和写入控制终端的进程组。当在控制终端上输入一个信号生成字符时，终端驱动程序会将相应的信号传递给前台进程组的成员。我们将在第
    34.7 节中详细描述。
- en: Note
  id: totrans-108
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: In theory, situations can arise where a session has no foreground process group.
    This could happen, for example, if all processes in the foreground process group
    terminate, and no other process notices this fact and moves itself into the foreground.
    In practice, such situations are rare. Normally, the shell is the process monitoring
    the status of the foreground process group, and it moves itself back into the
    foreground when it notices (via *wait()*) that the foreground process group has
    terminated.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 理论上，可能出现会话没有前台进程组的情况。例如，如果前台进程组中的所有进程终止，而没有其他进程注意到并将自己移动到前台，就可能发生这种情况。在实践中，这种情况比较少见。通常，shell
    是监视前台进程组状态的进程，它会在通过 *wait()* 注意到前台进程组已终止时，将自己重新调回前台。
- en: The *tcgetpgrp()* and *tcsetpgrp()* functions respectively retrieve and change
    the process group of a terminal. These functions are used primarily by job-control
    shells.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: '*tcgetpgrp()* 和 *tcsetpgrp()* 函数分别用于检索和改变终端的进程组。这些函数主要由作业控制 shell 使用。'
- en: '[PRE11]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Note
  id: totrans-112
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Returns process group ID of terminal’s foreground process group, or -1 on error
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 返回终端前台进程组的进程组 ID，出错时返回 -1
- en: '[PRE12]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Note
  id: totrans-115
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Returns 0 on success, or -1 on error
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 成功时返回 0，出错时返回 -1
- en: The *tcgetpgrp()* function returns the process group ID of the foreground process
    group of the terminal referred to by the file descriptor *fd*, which must be the
    controlling terminal of the calling process.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: '*tcgetpgrp()*函数返回由文件描述符*fd*所引用的终端的前台进程组ID，该终端必须是调用进程的控制终端。'
- en: Note
  id: totrans-118
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: If there is no foreground process group for this terminal, *tcgetpgrp()* returns
    a value greater than 1 that doesn’t match the ID of any existing process group.
    (This is the behavior specified by SUSv3.)
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 如果此终端没有前台进程组，*tcgetpgrp()*将返回一个大于1的值，该值不匹配任何现有的进程组ID。（这是SUSv3所规定的行为。）
- en: The *tcsetpgrp()* function changes the foreground process group for a terminal.
    If the calling process has a controlling terminal, and the file descriptor *fd*
    refers to that terminal, then *tcsetpgrp()* sets the foreground process group
    of the terminal to the value specified in *pgid*, which must match the process
    group ID of one of the processes in the calling process’s session.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: '*tcsetpgrp()*函数更改终端的前台进程组。如果调用进程有一个控制终端，并且文件描述符*fd*指向该终端，则*tcsetpgrp()*将终端的前台进程组设置为*pgid*中指定的值，该值必须与调用进程会话中的某个进程组ID匹配。'
- en: 'Both *tcgetpgrp()* and *tcsetpgrp()* are standardized in SUSv3\. On Linux,
    as on many other UNIX implementations, these functions are implemented using two
    unstandardized *ioctl()* operations: `TIOCGPGRP` and `TIOCSPGRP`.'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: '*tcgetpgrp()*和*tcsetpgrp()*函数在SUSv3中已标准化。在Linux中，和许多其他UNIX实现一样，这些函数是通过两个非标准化的*ioctl()*操作实现的：`TIOCGPGRP`和`TIOCSPGRP`。'
- en: The `SIGHUP` Signal
  id: totrans-122
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '`SIGHUP`信号'
- en: 'When a controlling process loses its terminal connection, the kernel sends
    it a `SIGHUP` signal to inform it of this fact. (A `SIGCONT` signal is also sent,
    to ensure that the process is restarted in case it had been previously stopped
    by a signal.) Typically, this may occur in two circumstances:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 当控制进程失去其终端连接时，内核会发送`SIGHUP`信号通知它这一事实。（还会发送`SIGCONT`信号，以确保如果进程之前因信号被停止，它能够重新启动。）通常，这可能在两种情况下发生：
- en: When a “disconnect” is detected by the terminal driver, indicating a loss of
    signal on a modem or terminal line.
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当终端驱动程序检测到“断开连接”，表示调制解调器或终端线路信号丢失时。
- en: When a terminal window is closed on a workstation. This occurs because the last
    open file descriptor for the master side of the pseudoterminal associated with
    the terminal window is closed.
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当工作站上的终端窗口被关闭时。之所以发生这种情况，是因为与终端窗口关联的伪终端的主端口的最后一个打开的文件描述符被关闭了。
- en: The default action of `SIGHUP` is to terminate a process. If the controlling
    process instead handles or ignores this signal, then further attempts to read
    from the terminal return end-of-file.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: '`SIGHUP`的默认行为是终止进程。如果控制进程处理或忽略该信号，则进一步尝试从终端读取将返回文件末尾。'
- en: Note
  id: totrans-127
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: SUSv3 states that if both a terminal disconnect occurs and one of the conditions
    giving rise to an `EIO` error from *read()* exists, then it is unspecified whether
    *read()* returns end-of-file or fails with the error `EIO`. Portable programs
    must allow for both possibilities. We look at the circumstances in which *read()*
    may fail with the `EIO` error in [Implementing Job Control](ch34.html#implementing_job_control
    "Implementing Job Control") and [Orphaned Process Groups (and `SIGHUP` Revisited)](ch34.html#orphaned_process_groups_open_parenthesis
    "Orphaned Process Groups (and SIGHUP Revisited)").
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: SUSv3规定，如果既发生了终端断开连接，又存在某种条件导致*read()*函数返回`EIO`错误，则*read()*是否返回文件末尾或以`EIO`错误失败未作说明。便携式程序必须考虑到这两种可能性。我们将在[实现作业控制](ch34.html#implementing_job_control
    "实现作业控制")和[孤儿进程组（以及`SIGHUP`信号复审）](ch34.html#orphaned_process_groups_open_parenthesis
    "孤儿进程组（以及`SIGHUP`信号复审）")中查看*read()*可能因`EIO`错误失败的情况。
- en: 'The delivery of `SIGHUP` to the controlling process can set off a kind of chain
    reaction, resulting in the delivery of `SIGHUP` to many other processes. This
    may occur in two ways:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 向控制进程发送`SIGHUP`信号可能会引发一种链式反应，导致`SIGHUP`信号被发送到其他许多进程。这可能通过两种方式发生：
- en: The controlling process is typically a shell. The shell establishes a handler
    for `SIGHUP`, so that, before terminating, it can send a `SIGHUP` to each of the
    jobs that it has created. This signal terminates those jobs by default, but if
    instead they catch the signal, then they are thus informed of the shell’s demise.
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 控制进程通常是一个shell。shell为`SIGHUP`信号建立一个处理程序，以便在终止之前，它可以向每个它创建的作业发送一个`SIGHUP`信号。该信号默认会终止这些作业，但如果这些作业捕获了该信号，则它们会因此得知shell的终结。
- en: Upon termination of the controlling process for a terminal, the kernel disassociates
    all processes in the session from the controlling terminal, disassociates the
    controlling terminal from the session (so that it may be acquired as the controlling
    terminal by another session leader), and informs the members of the foreground
    process group of the terminal of the loss of their controlling terminal by sending
    them a `SIGHUP` signal.
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当终端的控制进程终止时，内核会将会话中的所有进程与控制终端解除关联，将控制终端与会话解除关联（以便它可以被另一个会话的会话领导者作为控制终端获取），并通过向前台进程组成员发送
    `SIGHUP` 信号，告知它们其控制终端已丢失。
- en: We go into the details of each of these two cases in the next sections.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在接下来的章节中详细讨论这两种情况。
- en: Note
  id: totrans-133
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The `SIGHUP` signal also finds other uses. In [Orphaned Process Groups (and
    `SIGHUP` Revisited)](ch34.html#orphaned_process_groups_open_parenthesis "Orphaned
    Process Groups (and SIGHUP Revisited)"), we’ll see that `SIGHUP` is generated
    when a process group becomes orphaned. In addition, manually sending `SIGHUP`
    is conventionally used as a way of triggering a daemon process to reinitialize
    itself or reread its configuration file. (By definition, a daemon process doesn’t
    have a controlling terminal, and so can’t otherwise receive `SIGHUP` from the
    kernel.) We describe the use of `SIGHUP` with daemon processes in Section 37.4.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: '`SIGHUP` 信号还有其他用途。在 [孤儿进程组（和 `SIGHUP` 重新讨论)](ch34.html#orphaned_process_groups_open_parenthesis
    "Orphaned Process Groups (and SIGHUP Revisited)") 中，我们将看到当进程组成为孤儿时会生成 `SIGHUP`。此外，手动发送
    `SIGHUP` 通常用于触发守护进程重新初始化或重新读取其配置文件。（根据定义，守护进程没有控制终端，因此无法从内核接收 `SIGHUP`。）我们在第 37.4
    节中描述了 `SIGHUP` 在守护进程中的应用。'
- en: Handling of `SIGHUP` by the Shell
  id: totrans-135
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Shell 对 `SIGHUP` 的处理
- en: In a login session, the shell is normally the controlling process for the terminal.
    Most shells are programmed so that, when run interactively, they establish a handler
    for `SIGHUP`. This handler terminates the shell, but beforehand sends a `SIGHUP`
    signal to each of the process groups (both foreground and background) created
    by the shell. (The `SIGHUP` signal may be followed by a `SIGCONT` signal, depending
    on the shell and whether or not the job is currently stopped.) How the processes
    in these groups respond to `SIGHUP` is application-dependent; if no special action
    is taken, they are terminated by default.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 在登录会话中，shell 通常是终端的控制进程。大多数 shell 都会在交互式运行时建立一个 `SIGHUP` 的处理程序。该处理程序会终止 shell，但在此之前，会向
    shell 创建的每个进程组（包括前台和后台）发送 `SIGHUP` 信号。（`SIGHUP` 信号后可能会跟随一个 `SIGCONT` 信号，具体取决于
    shell 和作业是否被暂停。）这些进程组中的进程如何响应 `SIGHUP` 是依赖于应用的；如果没有采取特别的行动，它们默认会被终止。
- en: Note
  id: totrans-137
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Some job-control shells also send `SIGHUP` to stopped background jobs if the
    shell exits normally (e.g., when we explicitly log out or type *Control-D* in
    a shell window). This is done by both *bash* and the Korn shell (after printing
    a message on the first logout attempt).
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 一些作业控制 shell 也会在 shell 正常退出时（例如，当我们显式注销或在 shell 窗口中输入 *Control-D* 时）向暂停的后台作业发送
    `SIGHUP`。这一点在 *bash* 和 Korn shell 中都有实现（在第一次注销尝试时会打印一条消息）。
- en: The *nohup(1)* command can be used to make a command immune to the `SIGHUP`
    signal—that is, start it with the disposition of `SIGHUP` set to `SIG_IGN.` The
    *bash* built-in command *disown* serves a similar purpose, removing a job from
    the shell’s list of jobs, so that the job is not sent `SIGHUP` when the shell
    terminates.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: '*nohup(1)* 命令可用于使命令免受 `SIGHUP` 信号的影响——也就是说，以将 `SIGHUP` 的处理方式设置为 `SIG_IGN` 的方式启动它。*bash*
    内置命令 *disown* 具有类似的功能，它将作业从 shell 的作业列表中移除，从而在 shell 终止时该作业不会收到 `SIGHUP`。'
- en: We can use the program in [Example 34-3](ch34.html#catching_sighup "Example 34-3. Catching
    SIGHUP") to demonstrate that when the shell receives `SIGHUP`, it in turn sends
    `SIGHUP` to the jobs it has created. The main task of this program is to create
    a child process, and then have both the parent and the child pause to catch `SIGHUP`
    and display a message if it is received. If the program is given an optional command-line
    argument (which may be any string), the child places itself in a different process
    group (within the same session). This is useful to show that the shell doesn’t
    send `SIGHUP` to a process group that it did not create, even if it is in the
    same session as the shell. (Since the final `for` loop of the program loops forever,
    this program uses *alarm()* to establish a timer to deliver `SIGALRM`. The arrival
    of an unhandled `SIGALRM` signal guarantees process termination, if the process
    is not otherwise terminated.)
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用 [示例 34-3](ch34.html#catching_sighup "示例 34-3. 捕获 SIGHUP") 中的程序来演示当 shell
    接收到 `SIGHUP` 时，它会将 `SIGHUP` 发送给它所创建的作业。该程序的主要任务是创建一个子进程，然后让父进程和子进程都暂停，以捕获 `SIGHUP`
    并在接收到时显示一条消息。如果程序提供了一个可选的命令行参数（可以是任意字符串），则子进程将自己置于一个不同的进程组中（在同一个会话内）。这有助于展示即使进程与
    shell 在同一个会话中，shell 也不会向它没有创建的进程组发送 `SIGHUP`。 （由于程序的最终 `for` 循环会永远循环，因此该程序使用 *alarm()*
    来设置定时器以发送 `SIGALRM`。未处理的 `SIGALRM` 信号的到达会确保进程终止，除非该进程已被其他方式终止。）
- en: Example 34-3. Catching `SIGHUP`
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 34-3. 捕获 `SIGHUP`
- en: '[PRE13]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Suppose that we enter the following commands in a terminal window in order
    to run two instances of the program in [Example 34-3](ch34.html#catching_sighup
    "Example 34-3. Catching SIGHUP"), and then we close the terminal window:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们在终端窗口中输入以下命令来运行 [示例 34-3](ch34.html#catching_sighup "示例 34-3. 捕获 SIGHUP")
    的两个实例，然后我们关闭终端窗口：
- en: '[PRE14]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The first command results in the creation of two processes that remain in the
    process group created by the shell. The second command creates a child that places
    itself in a separate process group.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个命令会创建两个进程，这些进程保持在 shell 创建的进程组中。第二个命令创建了一个子进程，将自己放入一个单独的进程组。
- en: 'When we look at `samegroup.log`, we see that it contains the following output,
    indicating that both members of this process group were signaled by the shell:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们查看 `samegroup.log` 时，我们看到它包含以下输出，表明该进程组中的两个成员都收到了 shell 发送的信号：
- en: '[PRE15]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'When we examine `diffgroup.log`, we find the following output, indicating that
    when the shell received `SIGHUP`, it did not send a signal to the process group
    that it did not create:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们检查 `diffgroup.log` 时，我们会看到以下输出，表明当 shell 接收到 `SIGHUP` 时，它没有向它没有创建的进程组发送信号：
- en: '[PRE16]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: '`SIGHUP` and Termination of the Controlling Process'
  id: totrans-150
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '`SIGHUP` 和控制进程的终止'
- en: If the `SIGHUP` signal that is sent to the controlling process as the result
    of a terminal disconnect causes the controlling process to terminate, then `SIGHUP`
    is sent to all of the members of the terminal’s foreground process group (refer
    to [Details of Process Termination](ch25.html#details_of_process_termination "Details
    of Process Termination")). This behavior is a consequence of the termination of
    the controlling process, rather than a behavior associated specifically with the
    `SIGHUP` signal. If the controlling process terminates for any reason, then the
    foreground process group is signaled with `SIGHUP`.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 如果由于终端断开连接而发送给控制进程的 `SIGHUP` 信号导致控制进程终止，则 `SIGHUP` 会发送给终端前台进程组的所有成员（参见 [进程终止详情](ch25.html#details_of_process_termination
    "进程终止详情")）。这种行为是控制进程终止的结果，而不是与 `SIGHUP` 信号特定相关的行为。如果控制进程由于任何原因终止，则前台进程组会收到 `SIGHUP`
    信号。
- en: Note
  id: totrans-152
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: On Linux, the `SIGHUP` signal is followed by a `SIGCONT` signal to ensure that
    the process group is resumed if it had earlier been stopped by a signal. However,
    SUSv3 doesn’t specify this behavior, and most other UNIX implementations don’t
    send a `SIGCONT` in this circumstance.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Linux 上，`SIGHUP` 信号后会跟随一个 `SIGCONT` 信号，以确保如果进程组之前由于信号而被停止，则该进程组会恢复。然而，SUSv3
    没有指定这种行为，并且大多数其他 UNIX 实现不会在这种情况下发送 `SIGCONT`。
- en: We can use the program in [Example 34-4](ch34.html#catching_sighup_when_a_terminal_disconne
    "Example 34-4. Catching SIGHUP when a terminal disconnect occurs") to demonstrate
    that termination of the controlling process causes a `SIGHUP` signal to be sent
    to all members of the terminal’s foreground process group. This program creates
    one child process for each of its command-line arguments ![](figs/web/U002.png).
    If the corresponding command-line argument is the letter *d*, then the child process
    places itself in its own (different) process group ![](figs/web/U003.png); otherwise,
    the child remains in the same process group as its parent. (We use the letter
    *s* to specify the latter action, although any letter other than *d* can be used.)
    Each child then establishes a handler for `SIGHUP` ![](figs/web/U004.png). To
    ensure that they terminate if no event occurs that would otherwise terminate them,
    the parent and the children both call *alarm()* to set a timer that delivers a
    `SIGALRM` signal after 60 seconds ![](figs/web/U005.png). Finally, all processes
    (including the parent) print out their process ID and process group ID ![](figs/web/U006.png)
    and then loop waiting for signals to arrive ![](figs/web/U007.png). When a signal
    is delivered, the handler prints the process ID of the process and signal number
    ![](figs/web/U001.png).
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用[示例34-4](ch34.html#catching_sighup_when_a_terminal_disconne "示例34-4. 当终端断开连接时捕获SIGHUP")中的程序来演示控制进程的终止导致`SIGHUP`信号发送到终端前台进程组的所有成员。此程序为每个命令行参数创建一个子进程
    ![](figs/web/U002.png)。如果相应的命令行参数是字母*d*，则子进程将自己放入自己的（不同的）进程组 ![](figs/web/U003.png)；否则，子进程将与父进程保持在同一进程组内。（我们使用字母*s*来指定后者的行为，尽管除了*d*外，任何字母都可以使用。）然后，每个子进程会为`SIGHUP`信号建立一个处理程序
    ![](figs/web/U004.png)。为了确保它们在没有事件终止它们的情况下也能终止，父进程和子进程都调用*alarm()*设置一个定时器，在60秒后发送`SIGALRM`信号
    ![](figs/web/U005.png)。最后，所有进程（包括父进程）都会打印出它们的进程ID和进程组ID ![](figs/web/U006.png)，然后循环等待信号到达
    ![](figs/web/U007.png)。当信号到达时，处理程序打印出进程ID和信号编号 ![](figs/web/U001.png)。
- en: Example 34-4. Catching `SIGHUP` when a terminal disconnect occurs
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 示例34-4. 当终端断开连接时捕获`SIGHUP`
- en: '[PRE17]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Suppose that we run the program in [Example 34-4](ch34.html#catching_sighup_when_a_terminal_disconne
    "Example 34-4. Catching SIGHUP when a terminal disconnect occurs") in a terminal
    window with the following command:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们在一个终端窗口中运行[示例34-4](ch34.html#catching_sighup_when_a_terminal_disconne "示例34-4.
    当终端断开连接时捕获SIGHUP")程序，命令如下：
- en: '[PRE18]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'The *exec* command is a shell built-in command that causes the shell to do
    an *exec()*, replacing itself with the named program. Since the shell was the
    controlling process for the terminal, our program is now the controlling process
    and will receive `SIGHUP` when the terminal window is closed. After closing the
    terminal window, we find the following lines in the file `sig.log`:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: '*exec*命令是一个内建命令，使得shell执行*exec()*，将自身替换为指定的程序。由于shell是终端的控制进程，因此我们的程序现在成为了控制进程，并将在终端窗口关闭时接收到`SIGHUP`信号。关闭终端窗口后，我们在`sig.log`文件中看到以下几行：'
- en: '[PRE19]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Closing the terminal window caused `SIGHUP` to be sent to the controlling process
    (the parent), which terminated as a result. We see that the two children that
    were in the same process group as the parent (i.e., the foreground process group
    for the terminal) also both received `SIGHUP`. However, the child that was in
    a separate (background) process group did not receive this signal.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 关闭终端窗口导致`SIGHUP`信号被发送到控制进程（父进程），因此父进程终止了。我们看到与父进程在同一进程组中的两个子进程（即终端的前台进程组）也都收到了`SIGHUP`信号。然而，位于单独（后台）进程组中的子进程并没有收到此信号。
- en: Job Control
  id: totrans-162
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 作业控制
- en: Job control is a feature that first appeared around 1980 in the C shell on BSD.
    Job control permits a shell user to simultaneously execute multiple commands (jobs),
    one in the foreground and the others in the background. Jobs can be stopped and
    resumed, and moved between the foreground and background, as described in the
    following paragraphs.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 作业控制是1980年左右首次出现在BSD的C shell中的一种功能。作业控制允许用户同时执行多个命令（作业），其中一个在前台执行，其他的在后台执行。作业可以被停止和恢复，并可以在前台和后台之间移动，具体内容在以下段落中描述。
- en: Note
  id: totrans-164
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: In the initial POSIX.1 standard, support for job control was optional. Later
    UNIX standards made support mandatory.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 在最初的POSIX.1标准中，作业控制的支持是可选的。后来，UNIX标准将其作为强制要求。
- en: In the days of character-based dumb terminals (physical terminal devices that
    were limited to displaying ASCII characters), many shell users knew how to use
    shell job-control commands. With the advent of bit-mapped monitors running the
    X Window System, knowledge of shell job control is less common. However, job control
    remains a useful feature. Using job control to manage multiple simultaneous commands
    can be faster and simpler than switching back and forth between multiple windows.
    For those readers unfamiliar with job control, we begin with a short tutorial
    on its use. We then go on to look at a few details of the implementation of job
    control and consider the implications of job control for application design.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 在字符型傻瓜终端（物理终端设备，仅限显示 ASCII 字符）的时代，许多 shell 用户都知道如何使用 shell 作业控制命令。随着位图显示器运行
    X 窗口系统的出现，了解 shell 作业控制的知识变得不太常见。然而，作业控制仍然是一个有用的功能。使用作业控制来管理多个同时执行的命令，比在多个窗口之间来回切换可能更快更简单。对于那些不熟悉作业控制的读者，我们将从简短的教程开始，介绍其使用方法。接着，我们将进一步探讨作业控制的实现细节，并考虑作业控制对应用设计的影响。
- en: Using Job Control Within the Shell
  id: totrans-167
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 在 shell 中使用作业控制
- en: 'When we enter a command terminated by an ampersand (`&`), it is run as a background
    job, as illustrated by the following examples:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们输入一个以符号“&” (`&`) 结尾的命令时，它会作为后台作业运行，如以下示例所示：
- en: '[PRE20]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Each job that is placed in the background is assigned a unique job number by
    the shell. This job number is shown in square brackets after the job is started
    in the background, and also when the job is manipulated or monitored by various
    job-control commands. The number following the job number is the process ID of
    the process created to execute the command, or, in the case of a pipeline, the
    process ID of the last process in the pipeline. In the commands described in the
    following paragraphs, jobs can be referred to using the notation *%num*, where
    *num* is the number assigned to this job by the shell.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 每个被置于后台的作业都会被 shell 分配一个唯一的作业编号。该作业编号会在作业开始执行时以方括号的形式显示在后台，并且在通过各种作业控制命令操作或监控作业时也会显示。作业编号后面的数字是为了执行该命令而创建的进程的进程
    ID，或者在管道的情况下，管道中最后一个进程的进程 ID。在接下来的命令中，作业可以通过 *%num* 这种表示法来引用，其中 *num* 是由 shell
    分配给该作业的编号。
- en: Note
  id: totrans-171
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: In many cases, the *%num* argument can be omitted, in which case the *current*
    job is used by default. The current job is the last job that was stopped in the
    foreground (using the *suspend* character described below), or, if there is no
    such job, then the last job that was started in the background. (There are some
    variations in the details of how different shells determine which background job
    is considered the current job.) In addition, the notation %% or %+ refers to the
    current job, and the notation %- refers to the *previous current* job. The current
    and previous current jobs are marked by a plus (+) and a minus (-) sign, respectively,
    in the output produced by the *jobs* command, which we describe next.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 在许多情况下，*%num* 参数可以省略，在这种情况下，默认使用 *当前* 作业。当前作业是最后一个在前台停止的作业（使用下面描述的 *suspend*
    字符），或者如果没有这样的作业，则是最后一个在后台启动的作业。（不同的 shell 在如何确定哪个后台作业是当前作业方面有一些细微的差异。）此外，表示法 %%
    或 %+ 指代当前作业，而表示法 %- 则指代 *之前的当前作业*。当前作业和之前的当前作业分别在 *jobs* 命令的输出中用加号（+）和减号（-）标记，我们接下来将对此进行描述。
- en: 'The *jobs* shell built-in command lists all background jobs:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: '*jobs* shell 内建命令列出所有后台作业：'
- en: '[PRE21]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'At this point, the shell is the foreground process for the terminal. Since
    only a foreground process can read input from the controlling terminal and receive
    terminal-generated signals, sometimes it is necessary to move a background job
    into the foreground. This is done using the *fg* shell built-in command:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一点上，shell 是终端的前台进程。由于只有前台进程才能从控制终端读取输入并接收终端生成的信号，因此有时需要将后台作业移到前台。这可以通过使用 *fg*
    shell 内建命令来完成：
- en: '[PRE22]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: As demonstrated in this example, the shell redisplays a job’s command line whenever
    the job is moved between the foreground and the background. Below, we’ll see that
    the shell also does this whenever the job’s state changes in the background.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 如这个示例所示，shell 每次将作业从前台移到后台时，都会重新显示该作业的命令行。下面，我们还会看到，每当作业在后台的状态发生变化时，shell 也会执行此操作。
- en: 'When a job is running in the foreground, we can suspend it using the terminal
    *suspend* character (normally *Control-Z*), which sends the `SIGTSTP` signal to
    the terminal’s foreground process group:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 当作业在前台运行时，我们可以使用终端的*suspend*字符（通常是*Control-Z*）来暂停它，这会将`SIGTSTP`信号发送给终端的前台进程组：
- en: '[PRE23]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: After we typed *Control-Z*, the shell displays the command that has been stopped
    in the background. If desired, we can use the *fg* command to resume the job in
    the foreground, or use the *bg* command to resume it in the background. In both
    cases, the shell resumes the stopped job by sending it a `SIGCONT` signal.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们按下*Control-Z*后，shell会显示已在后台暂停的命令。如果需要，我们可以使用*fg*命令将作业恢复到前台，或者使用*bg*命令将其恢复到后台。在这两种情况下，shell都会通过发送`SIGCONT`信号来恢复暂停的作业。
- en: '[PRE24]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'We can stop a background job by sending it a `SIGSTOP` signal:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过向后台作业发送`SIGSTOP`信号来暂停它：
- en: '[PRE25]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Note
  id: totrans-184
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The Korn and C shells provide the command *stop* as a shorthand for *kill -stop*.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: Korn和C shell提供了*stop*命令，作为*kill -stop*命令的简写。
- en: 'When a background job eventually completes, the shell prints a message prior
    to displaying the next shell prompt:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个后台作业最终完成时，shell会在显示下一个shell提示符之前打印一条消息：
- en: '[PRE26]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Only processes in the foreground job may read from the controlling terminal.
    This restriction prevents multiple jobs from competing for terminal input. If
    a background job tries to read from the terminal, it is sent a `SIGTTIN` signal.
    The default action of `SIGTTIN` is to stop the job:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 只有前台作业中的进程可以从控制终端读取。这一限制防止了多个作业争夺终端输入。如果后台作业尝试从终端读取，它会收到一个`SIGTTIN`信号。`SIGTTIN`的默认行为是暂停该作业：
- en: '[PRE27]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Note
  id: totrans-190
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: It may not always be necessary to press the *Enter* key to see the job state
    changes in the previous example and some of the following examples. Depending
    on kernel scheduling decisions, the shell may receive notification about changes
    in the state of the background job before the next shell prompt is displayed.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些情况下，可能不需要按*Enter*键来查看前一个示例及一些后续示例中的作业状态变化。根据内核调度的决策，shell可能在显示下一个shell提示符之前就收到关于后台作业状态变化的通知。
- en: At this point, we must bring the job into the foreground (*fg*), and provide
    the required input. If desired, we can then continue execution of the job in the
    background by first suspending it and then resuming it in the background (*bg*).
    (Of course, in this particular example, *cat* would immediately be stopped again,
    since it would once more try to read from the terminal.)
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 在此时，我们必须将作业带到前台（*fg*），并提供所需的输入。如果需要，我们可以通过先暂停作业再将其恢复到后台（*bg*）来继续执行作业。（当然，在这个特定的例子中，*cat*会立即被暂停，因为它会再次尝试从终端读取。）
- en: By default, background jobs are allowed to perform output to the controlling
    terminal. However, if the `TOSTOP` flag (*terminal output stop*, [Terminal Flags](ch62.html#terminal_flags
    "Terminal Flags")) is set for the terminal, then attempts by background jobs to
    perform terminal output result in the generation of a `SIGTTOU` signal. (We can
    set the `TOSTOP` flag using the *stty* command, which is described in Section
    62.3.) Like `SIGTTIN`, a `SIGTTOU` signal stops the job.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，后台作业被允许向控制终端输出。然而，如果终端设置了`TOSTOP`标志（*终端输出停止*，[终端标志](ch62.html#terminal_flags
    "终端标志")），那么后台作业试图执行终端输出时，会生成一个`SIGTTOU`信号。（我们可以使用*stty*命令设置`TOSTOP`标志，该命令在第62.3节中有详细说明。）与`SIGTTIN`一样，`SIGTTOU`信号也会暂停作业。
- en: '[PRE28]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'We can then see the output of the job by bringing it into the foreground:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过将作业带到前台来查看作业的输出：
- en: '[PRE29]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: The various states of a job under job control, as well as the shell commands
    and terminal characters (and the accompanying signals) used to move a job between
    these states, are summarized in [Figure 34-2](ch34.html#job-control_states "Figure 34-2. Job-control
    states"). This figure also includes a notional *terminated* state for a job. This
    state can be reached by sending various signals to the job, including `SIGINT`
    and `SIGQUIT`, which can be generated from the keyboard.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 作业控制下作业的各种状态，以及用于在这些状态之间移动作业的shell命令和终端字符（以及随之产生的信号），总结在[图34-2](ch34.html#job-control_states
    "图34-2. 作业控制状态")中。该图还包括一个概念上的*已终止*状态。这个状态可以通过向作业发送各种信号来实现，包括`SIGINT`和`SIGQUIT`，这些信号可以通过键盘生成。
- en: '![Job-control states](figs/web/34-2_PGSJC-job-control.png.jpg)Figure 34-2. Job-control
    states'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: '![作业控制状态](figs/web/34-2_PGSJC-job-control.png.jpg)图34-2. 作业控制状态'
- en: Implementing Job Control
  id: totrans-199
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 实现作业控制
- en: In this section, we examine various aspects of the implementation of job control,
    and conclude with an example program that makes the operation of job control more
    transparent.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 本节将探讨作业控制实现的各个方面，并以一个示例程序结束，该程序使作业控制的操作更加透明。
- en: 'Although optional in the original POSIX.1 standard, later standards, including
    SUSv3, require that an implementation support job control. This support requires
    the following:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管在原始的 POSIX.1 标准中是可选的，但后来的标准，包括 SUSv3，要求实现支持作业控制。此支持要求如下：
- en: 'The implementation must provide certain job-control signals: `SIGTSTP`, `SIGSTOP`,
    `SIGCONT`, `SIGTTOU`, and `SIGTTIN`. In addition, the `SIGCHLD` signal ([The `SIGCHLD`
    Signal](ch26.html#the_sigchld_signal "The SIGCHLD Signal")) is also necessary,
    since it allows the shell (the parent of all jobs) to find out when one of its
    children terminates or is stopped.'
  id: totrans-202
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现必须提供特定的作业控制信号：`SIGTSTP`、`SIGSTOP`、`SIGCONT`、`SIGTTOU` 和 `SIGTTIN`。此外，`SIGCHLD`
    信号（[`SIGCHLD` 信号](ch26.html#the_sigchld_signal "SIGCHLD 信号")）也是必需的，因为它允许 shell（所有作业的父进程）在其子进程终止或停止时获知。
- en: The terminal driver must support generation of the job-control signals, so that
    when certain characters are typed, or terminal I/O and certain other terminal
    operations (described below) are performed from a background job, an appropriate
    signal (as shown in [Figure 34-2](ch34.html#job-control_states "Figure 34-2. Job-control
    states")) is sent to the relevant process group. In order to be able to carry
    out these actions, the terminal driver must also record the session ID (controlling
    process) and foreground process group ID associated with a terminal ([Figure 34-1](ch34.html#relationships_between_process_groups_com
    "Figure 34-1. Relationships between process groups, sessions, and the controlling
    terminal")).
  id: totrans-203
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 终端驱动程序必须支持生成作业控制信号，以便在输入特定字符或从后台作业执行某些终端 I/O 和其他终端操作（如下所述）时，能够将适当的信号（如[图 34-2](ch34.html#job-control_states
    "图 34-2. 作业控制状态")所示）发送到相关的进程组。为了能够执行这些操作，终端驱动程序还必须记录与终端相关的会话 ID（控制进程）和前台进程组 ID（[图
    34-1](ch34.html#relationships_between_process_groups_com "图 34-1. 进程组、会话与控制终端之间的关系")）。
- en: The shell must support job control (most modern shells do so). This support
    is provided in the form of the commands described earlier to move a job between
    the foreground and background and monitor the state of jobs. Certain of these
    commands send signals to a job (as shown in [Figure 34-2](ch34.html#job-control_states
    "Figure 34-2. Job-control states")). In addition, when performing operations that
    move a job between the *running in foreground* and any of the other states, the
    shell uses calls to *tcsetpgrp()* to adjust the terminal driver’s record of the
    foreground process group.
  id: totrans-204
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Shell 必须支持作业控制（大多数现代 shell 都支持）。这种支持以先前描述的命令形式提供，用于在前台和后台之间移动作业并监控作业的状态。这些命令中的某些会向作业发送信号（如[图
    34-2](ch34.html#job-control_states "图 34-2. 作业控制状态")所示）。此外，在执行将作业从*前台运行*状态移动到其他状态的操作时，shell
    会调用 *tcsetpgrp()* 来调整终端驱动程序记录的前台进程组。
- en: Note
  id: totrans-205
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'In [Sending Signals: *kill()*](ch20.html#sending_signals_colon_kill_open_parenthe
    "Sending Signals: kill()"), we saw that signals can generally be sent to a process
    only if the real or effective user ID of the sending process matches the real
    user ID or saved set-user-ID of the receiving process. However, `SIGCONT` is an
    exception to this rule. The kernel allows a process (e.g., the shell) to send
    `SIGCONT` to any process in the same session, regardless of process credentials.
    This relaxation of the rules for `SIGCONT` is required so that if a user starts
    a set-user-ID program that changes its credentials (in particular, its real user
    ID), it is still possible to resume it with `SIGCONT` if it is stopped.'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 在[发送信号：*kill()*](ch20.html#sending_signals_colon_kill_open_parenthe "发送信号：kill()")中，我们看到，通常只有当发送进程的实际或有效用户
    ID 与接收进程的实际用户 ID 或保存的设定用户 ID 匹配时，才能向进程发送信号。然而，`SIGCONT` 是这个规则的例外。内核允许进程（例如 shell）向同一会话中的任何进程发送
    `SIGCONT`，而不考虑进程凭据。对 `SIGCONT` 规则的放宽是必要的，这样如果用户启动一个改变其凭据（特别是其实际用户 ID）的 set-user-ID
    程序，即使该程序被停止，仍然可以通过 `SIGCONT` 恢复它。
- en: The `SIGTTIN` and `SIGTTOU` signals
  id: totrans-207
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '`SIGTTIN` 和 `SIGTTOU` 信号'
- en: 'SUSv3 specifies (and Linux implements) some special cases that apply with respect
    to the generation of the `SIGTTIN` and `SIGTTOU` signals for background jobs:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: SUSv3 规范（并且 Linux 实现了）一些特殊情况，这些情况适用于生成背景作业的 `SIGTTIN` 和 `SIGTTOU` 信号：
- en: '`SIGTTIN` is not sent if the process is currently blocking or ignoring this
    signal. Instead, a *read()* from the controlling terminal fails, setting *errno*
    to `EIO`. The rationale for this behavior is that the process would otherwise
    have no way of knowing that the *read()* was not permitted.'
  id: totrans-209
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果进程当前阻塞或忽略`SIGTTIN`信号，则不会发送该信号。相反，从控制终端执行*read()*操作失败，并将*errno*设置为`EIO`。这样做的原因是，进程否则无法知道*read()*操作被拒绝。
- en: Even if the terminal `TOSTOP` flag is set, `SIGTTOU` is not sent if the process
    is currently blocking or ignoring this signal. Instead, a *write()* to the controlling
    terminal is permitted (i.e., the `TOSTOP` flag is ignored).
  id: totrans-210
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 即使终端的`TOSTOP`标志已设置，如果进程当前阻塞或忽略此信号，则不会发送`SIGTTOU`。相反，允许对控制终端执行*write()*操作（即，忽略`TOSTOP`标志）。
- en: Regardless of the setting of the `TOSTOP` flag, certain functions that change
    terminal driver data structures result in the generation of `SIGTTOU` for a background
    process if it tries to apply them to its controlling terminal. These functions
    include *tcsetpgrp()*, *tcsetattr()*, *tcflush()*, *tcflow()*, *tcsendbreak()*,
    and *tcdrain()*. (These functions are described in [Chapter 62](ch62.html "Chapter 62. Terminals").)
    If `SIGTTOU` is being blocked or ignored, these calls succeed.
  id: totrans-211
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 无论`TOSTOP`标志的设置如何，某些更改终端驱动程序数据结构的函数会导致如果后台进程尝试在其控制终端上应用这些函数时，生成`SIGTTOU`信号。这些函数包括*tcsetpgrp()*、*tcsetattr()*、*tcflush()*、*tcflow()*、*tcsendbreak()*和*tcdrain()*。（这些函数在[第
    62 章](ch62.html "Chapter 62. Terminals")中有描述。）如果`SIGTTOU`信号被阻塞或忽略，这些调用将成功执行。
- en: 'Example program: demonstrating the operation of job control'
  id: totrans-212
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 示例程序：演示作业控制的操作
- en: 'The program in [Example 34-5](ch34.html#observing_the_treatment_of_a_process_und
    "Example 34-5. Observing the treatment of a process under job control") allows
    us to see how the shell organizes the commands in a pipeline into a job (process
    group). This program also allows us to monitor certain of the signals sent and
    the changes made to the terminal’s foreground process group setting under job
    control. The program is designed so that multiple instances can be run in a pipeline,
    as in the following example:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 34-5](ch34.html#observing_the_treatment_of_a_process_und "Example 34-5.
    观察作业控制下进程的处理")中的程序允许我们看到 shell 如何将管道中的命令组织成一个作业（进程组）。该程序还允许我们监控发送的某些信号以及作业控制下对终端前台进程组设置的更改。该程序设计允许多个实例在管道中运行，如下所示的示例：'
- en: '[PRE30]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'The program in [Example 34-5](ch34.html#observing_the_treatment_of_a_process_und
    "Example 34-5. Observing the treatment of a process under job control") performs
    the following steps:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 34-5](ch34.html#observing_the_treatment_of_a_process_und "Example 34-5.
    观察作业控制下进程的处理")中的程序执行以下步骤：'
- en: 'On startup, the program installs a single handler for `SIGINT`, `SIGTSTP`,
    and `SIGCONT` ![](figs/web/U004.png). The handler carries out the following steps:'
  id: totrans-216
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在启动时，程序为`SIGINT`、`SIGTSTP`和`SIGCONT`信号安装一个统一的处理程序 ![](figs/web/U004.png)。该处理程序执行以下操作：
- en: Display the foreground process group for the terminal ![](figs/web/U001.png).
    To avoid multiple identical lines of output, this is done only by the process
    group leader.
  id: totrans-217
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 显示终端的前台进程组 ![](figs/web/U001.png)。为了避免输出重复的行，仅由进程组的领导者执行此操作。
- en: Display the ID of the process, the process’s position in the pipeline, and the
    signal received ![](figs/web/U002.png).
  id: totrans-218
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 显示进程的 ID、进程在管道中的位置和接收到的信号 ![](figs/web/U002.png)。
- en: The handler must do some extra work if it catches `SIGTSTP`, since, when caught,
    this signal doesn’t stop a process. So, to actually stop the process, the handler
    raises the `SIGSTOP` signal ![](figs/web/U003.png), which always stops a process.
    (We refine this treatment of `SIGTSTP` in [Handling Job-Control Signals](ch34.html#handling_job-control_signals
    "Handling Job-Control Signals").)
  id: totrans-219
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果处理程序捕获到`SIGTSTP`信号，它必须做一些额外的工作，因为在捕获时，这个信号并不会停止进程。因此，为了真正停止进程，处理程序会发送`SIGSTOP`信号
    ![](figs/web/U003.png)，该信号始终会停止进程。（我们在[处理作业控制信号](ch34.html#handling_job-control_signals
    "Handling Job-Control Signals")中详细阐述了如何处理`SIGTSTP`。）
- en: If the program is the initial process in the pipeline, it prints headings for
    the output produced by all of the processes ![](figs/web/U006.png). In order to
    test whether it is the initial (or final) process in the pipeline, the program
    uses the *isatty()* function (described in [Terminal Identification](ch62.html#terminal_identification
    "Terminal Identification")) to check whether its standard input (or output) is
    a terminal ![](figs/web/U005.png). If the specified file descriptor refers to
    a pipe, *isatty()* returns false (0).
  id: totrans-220
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果程序是管道中的初始进程，它会打印所有进程产生的输出的标题 ![](figs/web/U006.png)。为了测试它是否是管道中的初始（或最终）进程，程序使用
    *isatty()* 函数（在[终端识别](ch62.html#terminal_identification "终端识别")中描述）来检查它的标准输入（或输出）是否是一个终端
    ![](figs/web/U005.png)。如果指定的文件描述符指向一个管道，*isatty()* 会返回 false（0）。
- en: The program builds a message to be passed to its successor in the pipeline.
    This message is an integer indicating the position of this process in the pipeline.
    Thus, for the initial process, the message contains the number 1\. If the program
    is the initial process in the pipeline, the message is initialized to 0\. If it
    is not the initial process in the pipeline, the program first reads this message
    from its predecessor ![](figs/web/U007.png). The program increments the message
    value before proceeding to the next steps ![](figs/web/U008.png).
  id: totrans-221
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 程序构建一个消息传递给其管道中的后继进程。这个消息是一个整数，表示此进程在管道中的位置。因此，对于初始进程，消息包含数字1。如果程序是管道中的初始进程，消息被初始化为0。如果它不是管道中的初始进程，程序会先从其前一个进程读取此消息
    ![](figs/web/U007.png)。程序在继续到下一步之前会增加消息值 ![](figs/web/U008.png)。
- en: Regardless of its position in the pipeline, the program displays a line containing
    its pipeline position, process ID, parent process ID, process group ID, and session
    ID ![](figs/web/U009.png).
  id: totrans-222
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 无论它在管道中的位置如何，程序都会显示一行，包含它的管道位置、进程ID、父进程ID、进程组ID和会话ID ![](figs/web/U009.png)。
- en: Unless it is the last command in the pipeline, the program writes an integer
    message for its successor in the pipeline ![](figs/web/U010.png).
  id: totrans-223
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 除非它是管道中的最后一个命令，否则程序会为其管道中的后续进程写一个整数消息 ![](figs/web/U010.png)。
- en: Finally, the program loops forever, using *pause()* to wait for signals ![](figs/web/U011.png).
  id: totrans-224
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后，程序永远循环，使用 *pause()* 等待信号 ![](figs/web/U011.png)。
- en: Example 34-5. Observing the treatment of a process under job control
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 示例34-5. 观察作业控制下的进程处理
- en: '[PRE31]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'The following shell session demonstrates the use of the program in [Example 34-5](ch34.html#observing_the_treatment_of_a_process_und
    "Example 34-5. Observing the treatment of a process under job control"). We begin
    by displaying the process ID of the shell (which is the session leader, and the
    leader of a process group of which it is the sole member), and then create a background
    job containing two processes:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 以下的Shell会话演示了在[示例34-5](ch34.html#observing_the_treatment_of_a_process_und "示例34-5.
    观察作业控制下的进程处理")中使用程序的方法。我们首先显示Shell的进程ID（它是会话的领导者，且是进程组的领导者，进程组中只有它一个成员），然后创建一个包含两个进程的后台作业：
- en: '[PRE32]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: From the above output, we can see that the shell remains the foreground process
    for the terminal. We can also see that the new job is in the same session as the
    shell and that all of the processes are in the same process group. Looking at
    the process IDs, we can see that the processes in the job were created in the
    same order as the commands were given on the command line. (Most shells do things
    this way, but some shell implementations create the processes in a different order.)
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 从上述输出可以看出，Shell仍然是终端的前台进程。我们还可以看到新作业与Shell在同一个会话中，并且所有进程都在同一个进程组中。查看进程ID，我们可以看到作业中的进程是按照命令行上给出的命令顺序创建的。（大多数Shell是这样做的，但某些Shell实现会以不同的顺序创建进程。）
- en: 'We continue, creating a second background job consisting of three processes:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 我们继续，创建一个由三个进程组成的第二个后台作业：
- en: '[PRE33]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'We see that the shell is still the foreground process group for the terminal.
    We also see that the processes for the new job are in the same session as the
    shell, but are in a different process group from the first job. Now we bring the
    second job into the foreground and send it a `SIGINT` signal:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 我们看到Shell仍然是终端的前台进程组。我们还看到新作业的进程与Shell在同一个会话中，但在与第一个作业不同的进程组中。现在，我们将第二个作业带入前台，并向它发送
    `SIGINT` 信号：
- en: '[PRE34]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'From the above output, we see that the `SIGINT` signal was delivered to all
    of the processes in the foreground process group. We also see that this job is
    now the foreground process group for the terminal. Next, we send a `SIGTSTP` signal
    to the job:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 从上述输出中，我们看到 `SIGINT` 信号已被发送到前台进程组中的所有进程。我们还看到该作业现在是终端的前台进程组。接下来，我们向该作业发送 `SIGTSTP`
    信号：
- en: '[PRE35]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Now all members of the process group are stopped. The output indicates that
    process group 1228 was the foreground job. However, after this job was stopped,
    the shell became the foreground process group, although we can’t tell this from
    the output.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，所有进程组的成员都已停止。输出表明进程组 1228 是前台作业。然而，在该作业停止后，虽然从输出中看不出来，shell 成为了前台进程组。
- en: 'We then proceed by restarting the job using the *bg* command, which delivers
    a `SIGCONT` signal to the processes in the job:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们使用 *bg* 命令重新启动作业，该命令将 `SIGCONT` 信号发送到作业中的进程：
- en: '[PRE36]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Handling Job-Control Signals
  id: totrans-239
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 处理作业控制信号
- en: Because the operation of job control is transparent to most applications, they
    don’t need to take special action for dealing with job-control signals. One exception
    is programs that perform screen handling, such as *vi* and *less*. Such programs
    control the precise layout of text on a terminal and change various terminal settings,
    including settings that allow terminal input to be read a character (rather than
    a line) at a time. (We describe the various terminal settings in [Chapter 62](ch62.html
    "Chapter 62. Terminals").)
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 由于作业控制的操作对大多数应用程序是透明的，因此它们无需为处理作业控制信号采取特殊行动。一个例外是执行屏幕处理的程序，如 *vi* 和 *less*。这些程序控制文本在终端上的精确布局，并更改各种终端设置，包括允许终端按字符（而不是按行）逐次读取输入的设置。（我们在[第62章](ch62.html
    "第62章。终端")中描述了各种终端设置。）
- en: Screen-handling programs need to handle the terminal stop signal (`SIGTSTP`).
    The signal handler should reset the terminal into canonical (line-at-a-time) input
    mode and place the cursor at the bottom-left corner of the terminal. When resumed,
    the program sets the terminal back into the mode required by the program, checks
    the terminal window size (which may have been changed by the user in the meantime),
    and redraws the screen with the desired contents.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 屏幕处理程序需要处理终端停止信号（`SIGTSTP`）。信号处理程序应将终端重置为标准（逐行）输入模式，并将光标放置在终端的左下角。当程序恢复时，它会将终端设置回程序所需的模式，检查终端窗口大小（此时用户可能已更改），并重新绘制屏幕以显示所需内容。
- en: Note
  id: totrans-242
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: When we suspend or exit a terminal-handling program, such as *vi* on an *xterm*
    or other terminal emulator, we typically see that the terminal is redrawn with
    the text that was visible before the program was started. The terminal emulator
    achieves this effect by catching two character sequences that programs employing
    the *terminfo* or *termcap* packages are required to output when assuming and
    releasing control of terminal layout. The first of these sequences, called *smcup*
    (normally *Escape* followed by `[?1049h`), causes the terminal emulator to switch
    to its “alternate” screen. The second sequence, called *rmcup* (normally *Escape*
    followed by `[?1049l`), causes the terminal emulator to revert to its default
    screen, thus resulting in the reappearance of the original text that was on display
    before the screen-handling program took control of the terminal.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们挂起或退出一个终端处理程序时，比如在 *xterm* 或其他终端仿真器上使用 *vi*，通常会看到终端被重绘为程序启动前显示的文本。终端仿真器通过捕捉两个字符序列来实现这一效果，这些程序在使用
    *terminfo* 或 *termcap* 包时，必须在获取和释放终端布局控制时输出这两个序列。第一个序列称为 *smcup*（通常是 *Escape*
    后跟 `[?1049h]`），它使终端仿真器切换到“备用”屏幕。第二个序列称为 *rmcup*（通常是 *Escape* 后跟 `[?1049l]`），它使终端仿真器恢复到默认屏幕，从而使终端恢复到屏幕处理程序控制终端之前的原始文本。
- en: 'When handling `SIGTSTP`, we should be aware of some subtleties. We have already
    noted the first of these in [Implementing Job Control](ch34.html#implementing_job_control
    "Implementing Job Control"): if `SIGTSTP` is caught, then it doesn’t perform its
    default action of stopping a process. We dealt with this issue in [Example 34-5](ch34.html#observing_the_treatment_of_a_process_und
    "Example 34-5. Observing the treatment of a process under job control") by having
    the handler for `SIGTSTP` raise the `SIGSTOP` signal. Since `SIGSTOP` can’t be
    caught, blocked, or ignored, it is guaranteed to immediately stop the process.
    However, this approach is not quite correct. In [The Wait Status Value](ch26.html#the_wait_status_value
    "The Wait Status Value"), we saw that a parent process can use the wait status
    value returned by *wait()* or *waitpid()* to determine which signal caused one
    of its child to stop. If we raise the `SIGSTOP` signal in the handler for `SIGTSTP`,
    it will (misleadingly) appear to the parent that the child was stopped by `SIGSTOP`.'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 在处理`SIGTSTP`时，我们需要注意一些细节。我们已经在[实现作业控制](ch34.html#implementing_job_control "实现作业控制")中提到过其中的第一个：如果捕获到`SIGTSTP`，它就不会执行默认的停止进程的操作。我们在[示例
    34-5](ch34.html#observing_the_treatment_of_a_process_und "示例 34-5：观察作业控制下进程的处理")中通过让`SIGTSTP`的处理程序触发`SIGSTOP`信号来解决这个问题。由于`SIGSTOP`不能被捕获、阻塞或忽略，因此它保证立即停止进程。然而，这种做法并不完全正确。在[等待状态值](ch26.html#the_wait_status_value
    "等待状态值")中，我们看到父进程可以使用`wait()`或`waitpid()`返回的等待状态值来判断是哪个信号导致其子进程停止。如果我们在`SIGTSTP`的处理程序中触发`SIGSTOP`信号，父进程会误认为子进程是被`SIGSTOP`信号停止的。
- en: 'The proper approach in this situation is to have the `SIGTSTP` handler raise
    a further `SIGTSTP` signal to stop the process, as follows:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，正确的做法是让`SIGTSTP`的处理程序触发一个额外的`SIGTSTP`信号来停止进程，具体如下：
- en: The handler resets the disposition of `SIGTSTP` to its default (`SIG_DFL`).
  id: totrans-246
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 处理程序将`SIGTSTP`的处理方式重置为默认值（`SIG_DFL`）。
- en: The handler raises `SIGTSTP`.
  id: totrans-247
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 处理程序触发`SIGTSTP`。
- en: 'Since `SIGTSTP` was blocked on entry to the handler (unless the `SA_NODEFER`
    flag was specified), the handler unblocks this signal. At this point, the pending
    `SIGTSTP` raised in the previous step performs its default action: the process
    is immediately suspended.'
  id: totrans-248
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 由于在进入处理程序时`SIGTSTP`信号已被阻塞（除非指定了`SA_NODEFER`标志），处理程序会解除阻塞该信号。此时，之前步骤中触发的挂起的`SIGTSTP`信号将执行其默认操作：进程会立即被挂起。
- en: At some later time, the process will be resumed upon receipt of `SIGCONT`. At
    this point, execution of the handler continues.
  id: totrans-249
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 稍后，当进程接收到`SIGCONT`时，将会恢复执行。此时，处理程序的执行继续进行。
- en: Before returning, the handler reblocks the `SIGTSTP` signal and reestablishes
    itself to handle the next occurrence of the `SIGTSTP` signal.
  id: totrans-250
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在返回之前，处理程序会重新阻塞`SIGTSTP`信号，并重新建立自己以处理下一个`SIGTSTP`信号的发生。
- en: The step of reblocking the `SIGTSTP` signal is needed to prevent the handler
    from being recursively called if another `SIGTSTP` signal was delivered after
    the handler reestablished itself, but before the handler returned. As noted in
    [Implementation and Portability of *signal()*](ch22.html#implementation_and_portability_of_signal
    "Implementation and Portability of signal()"), recursive invocations of a signal
    handler could cause stack overflow if a rapid stream of signals is delivered.
    Blocking the signal also avoids problems if the signal handler needs to perform
    some other actions (e.g., saving or restoring values from global variables) after
    reestablishing the handler but before returning.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 重新阻塞`SIGTSTP`信号的步骤是为了防止如果在处理程序重新建立自己之后，但在返回之前，又送来了另一个`SIGTSTP`信号时，处理程序会被递归调用。如[*signal()*的实现与可移植性](ch22.html#implementation_and_portability_of_signal
    "signal()的实现与可移植性")中所指出的，信号处理程序的递归调用可能会导致堆栈溢出，尤其是在快速连续发送信号的情况下。阻塞信号还可以避免信号处理程序在重新建立自己后但在返回之前需要执行其他操作（例如保存或恢复全局变量的值）时出现问题。
- en: Example program
  id: totrans-252
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 示例程序
- en: 'The handler in [Example 34-6](ch34.html#handling_sigtstp "Example 34-6. Handling
    SIGTSTP") implements the steps described above to correctly handle `SIGTSTP`.
    (We show another example of the handling of the `SIGTSTP` signal in [Example 62-4](ch62.html#demonstrating_cbreak_and_raw_modes
    "Example 62-4. Demonstrating cbreak and raw modes"), in [Terminal Line Speed (Bit
    Rate)](ch62.html#terminal_line_speed_open_parenthesis_bit "Terminal Line Speed
    (Bit Rate)").) After establishing the `SIGTSTP` handler, the *main()* function
    of this program sits in a loop waiting for signals. Here is an example of what
    we see when running this program:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 34-6](ch34.html#handling_sigtstp "示例 34-6. 处理 SIGTSTP")中的处理程序实现了上述步骤，正确处理了
    `SIGTSTP` 信号。（我们在[示例 62-4](ch62.html#demonstrating_cbreak_and_raw_modes "示例 62-4.
    演示 cbreak 和 raw 模式")中展示了另一个 `SIGTSTP` 信号处理的例子，在[终端行速率（比特率）](ch62.html#terminal_line_speed_open_parenthesis_bit
    "终端行速率（比特率）")中也有提到。）在建立了 `SIGTSTP` 信号处理程序后，程序的*main()*函数进入一个循环，等待信号。以下是我们运行此程序时可能看到的输出：'
- en: '[PRE37]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: In a screen-handling program such as *vi*, the *printf()* calls inside the signal
    handler in [Example 34-6](ch34.html#handling_sigtstp "Example 34-6. Handling SIGTSTP")
    would be replaced by code that caused the program to modify the terminal mode
    and redraw the terminal display, as outlined above. (Because of the need to avoid
    calling non-async-signal-safe functions, described in [Reentrant and Async-Signal-Safe
    Functions](ch21.html#reentrant_and_async-signal-safe_function "Reentrant and Async-Signal-Safe
    Functions"), the handler should do this by setting a flag to inform the main program
    to redraw the screen.)
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 在像 *vi* 这样的屏幕处理程序中，[示例 34-6](ch34.html#handling_sigtstp "示例 34-6. 处理 SIGTSTP")中的信号处理程序内的*printf()*调用会被替换为修改终端模式并重新绘制终端显示的代码，正如上述所述。（由于需要避免调用非异步信号安全函数，[可重入和异步信号安全函数](ch21.html#reentrant_and_async-signal-safe_function
    "可重入和异步信号安全函数")中有描述，信号处理程序应该通过设置标志通知主程序重新绘制屏幕。）
- en: Note that the `SIGTSTP` handler may interrupt certain blocking system calls
    (as described in [Interruption and Restarting of System Calls](ch21.html#interruption_and_restarting_of_system_ca
    "Interruption and Restarting of System Calls")). This point is illustrated in
    the above program output by the fact that, after the *pause()* call is interrupted,
    the main program prints the message *Main*.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，`SIGTSTP` 信号处理程序可能会中断某些阻塞的系统调用（如[系统调用的中断与重启](ch21.html#interruption_and_restarting_of_system_ca
    "系统调用的中断与重启")中所述）。这一点在上述程序输出中得到了说明，具体表现为，在*pause()*调用被中断后，主程序打印出*Main*信息。
- en: Example 34-6. Handling `SIGTSTP`
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 34-6. 处理 `SIGTSTP`
- en: '[PRE38]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Dealing with ignored job-control and terminal-generated signals
  id: totrans-259
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 处理被忽略的作业控制信号和终端生成信号
- en: The program in [Example 34-6](ch34.html#handling_sigtstp "Example 34-6. Handling
    SIGTSTP") establishes a signal handler for `SIGTSTP` only if that signal is not
    being ignored. This is an instance of the more general rule that applications
    should handle job-control and terminal-generated signals only if these signals
    were not previously being ignored. In the case of job-control signals (`SIGTSTP`,
    `SIGTTIN`, and `SIGTTOU`), this prevents an application from attempting to handle
    these signals if it is started from a non-job-control shell (such as the traditional
    Bourne shell). In a non-job-control shell, the dispositions of these signals are
    set to `SIG_IGN`; only job-control shells set the dispositions of these signals
    to `SIG_DFL`.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 34-6](ch34.html#handling_sigtstp "示例 34-6. 处理 SIGTSTP")中的程序仅在未忽略`SIGTSTP`信号时才会建立信号处理程序。这是一个更一般的规则的实例，应用程序应当仅在信号未被事先忽略的情况下处理作业控制和终端生成的信号。在作业控制信号（`SIGTSTP`、`SIGTTIN`
    和 `SIGTTOU`）的情况下，这可以防止应用程序尝试处理这些信号，特别是在它是从非作业控制的 shell（如传统 Bourne shell）启动时。在非作业控制的
    shell 中，这些信号的处理方式被设置为 `SIG_IGN`；只有作业控制的 shell 才会将这些信号的处理方式设置为 `SIG_DFL`。'
- en: 'A similar statement also applies to the other signals that can be generated
    from the terminal: `SIGINT`, `SIGQUIT`, and `SIGHUP`. In the case of `SIGINT`
    and `SIGQUIT`, the reason is that when a command is executed in the background
    under non-job-control shells, the resulting process is not placed in a separate
    process group. Instead, the process stays in the same group as the shell, and
    the shell sets the disposition of `SIGINT` and `SIGQUIT` to be ignored before
    execing the command. This ensures that the process is not killed if the user types
    the terminal *interrupt* or *quit* characters (which should affect only the job
    that is notionally in the foreground). If the process subsequently undoes the
    shell’s manipulations of the dispositions of these signals, then it once more
    becomes vulnerable to receiving them.'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 类似的说法也适用于从终端生成的其他信号：`SIGINT`、`SIGQUIT`和`SIGHUP`。对于`SIGINT`和`SIGQUIT`，原因在于当命令在非作业控制的
    shell 中后台执行时，生成的进程并没有被放入单独的进程组中。相反，进程保持在与 shell 相同的组中，并且在执行命令之前，shell 会将`SIGINT`和`SIGQUIT`的处理设置为忽略。这确保了如果用户输入终端的*中断*或*退出*字符（这些字符应该仅影响名义上在前台的作业），进程不会被终止。如果进程随后撤销了
    shell 对这些信号处理的操作，它就再次变得容易受到这些信号的影响。
- en: The `SIGHUP` signal is ignored if a command is executed via *nohup(1)*. This
    prevents the command from being killed as a consequence of a terminal hangup.
    Thus, an application should not attempt to change the disposition if it is being
    ignored.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 如果通过 *nohup(1)* 执行命令，则会忽略`SIGHUP`信号。这样可以防止命令因为终端挂起而被终止。因此，如果命令被忽略，应用程序不应该尝试更改信号的处理方式。
- en: Orphaned Process Groups (and `SIGHUP` Revisited)
  id: totrans-263
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 孤儿进程组（以及`SIGHUP`的回顾）
- en: 'In [Orphans and Zombies](ch26.html#orphans_and_zombies "Orphans and Zombies"),
    we saw that an orphaned process is one that has been adopted by *init* (process
    ID 1) after its parent terminated. Within a program, we can create an orphaned
    child using the following code:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 在[孤儿进程和僵尸进程](ch26.html#orphans_and_zombies "孤儿进程和僵尸进程")中，我们看到，孤儿进程是指其父进程终止后被
    *init*（进程 ID 1）收养的进程。在程序中，我们可以使用以下代码创建一个孤儿子进程：
- en: '[PRE39]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Suppose that we include this code in a program executed from the shell. [Figure 34-3](ch34.html#steps_in_the_creation_of_an_orphaned_pro
    "Figure 34-3. Steps in the creation of an orphaned process group") shows the state
    of processes before and after the parent exits.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们在从 shell 执行的程序中包含这段代码。[图 34-3](ch34.html#steps_in_the_creation_of_an_orphaned_pro
    "图 34-3. 孤儿进程组创建步骤") 显示了父进程退出前后进程的状态。
- en: After the parent terminates, the child process in [Figure 34-3](ch34.html#steps_in_the_creation_of_an_orphaned_pro
    "Figure 34-3. Steps in the creation of an orphaned process group") is not only
    an orphaned process, it is also part of an *orphaned process group*. SUSv3 defines
    a process group as orphaned if “the parent of every member is either itself a
    member of the group or is not a member of the group’s session.” Put another way,
    a process group is not orphaned if at least one of its members has a parent in
    the same session but in a different process group. In [Figure 34-3](ch34.html#steps_in_the_creation_of_an_orphaned_pro
    "Figure 34-3. Steps in the creation of an orphaned process group"), the process
    group containing the child is orphaned because the child is in a process group
    on its own and its parent (*init*) is in a different session.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 在父进程终止后，[图 34-3](ch34.html#steps_in_the_creation_of_an_orphaned_pro "图 34-3.
    孤儿进程组创建步骤")中的子进程不仅是一个孤儿进程，还是*孤儿进程组*的一部分。SUSv3 定义一个进程组为孤儿进程组，如果“每个成员的父进程要么是该组的成员，要么不是该组会话的成员。”换句话说，只有当至少有一个成员的父进程在同一会话中，但在不同的进程组时，进程组才不是孤儿进程组。在[图
    34-3](ch34.html#steps_in_the_creation_of_an_orphaned_pro "图 34-3. 孤儿进程组创建步骤")中，包含子进程的进程组是孤儿进程组，因为子进程处于一个单独的进程组中，并且它的父进程（*init*）处于不同的会话中。
- en: Note
  id: totrans-268
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: By definition, a session leader is in an orphaned process group. This follows
    because *setsid()* creates a new process group in the new session, and the parent
    of the session leader is in a different session.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 根据定义，会话领导者处于孤儿进程组中。因为 *setsid()* 会在新会话中创建一个新的进程组，而会话领导者的父进程处于不同的会话中。
- en: '![Steps in the creation of an orphaned process group](figs/web/34-3_PGSJC-orphaned-pgrp.png.jpg)Figure 34-3. Steps
    in the creation of an orphaned process group'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: '![孤儿进程组创建步骤](figs/web/34-3_PGSJC-orphaned-pgrp.png.jpg)图 34-3. 孤儿进程组创建步骤'
- en: 'To see why orphaned process groups are important, we need to view things from
    the perspective of shell job control. Consider the following scenario based on
    [Figure 34-3](ch34.html#steps_in_the_creation_of_an_orphaned_pro "Figure 34-3. Steps
    in the creation of an orphaned process group"):'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 为了理解为什么孤儿进程组很重要，我们需要从外壳作业控制的角度来看待问题。请考虑以下基于[图34-3](ch34.html#steps_in_the_creation_of_an_orphaned_pro
    "Figure 34-3. Steps in the creation of an orphaned process group")的情境：
- en: Before the parent process exits, the child was stopped (perhaps because the
    parent sent it a stop signal).
  id: totrans-272
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在父进程退出之前，子进程被停止（可能是因为父进程向其发送了停止信号）。
- en: When the parent process exits, the shell removes the parent’s process group
    from its list of jobs. The child is adopted by *init* and becomes a background
    process for the terminal. The process group containing the child is orphaned.
  id: totrans-273
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当父进程退出时，外壳会将父进程的进程组从其作业列表中移除。子进程被*init*收养，并成为终端的后台进程。包含子进程的进程组变成孤儿进程组。
- en: At this point, there is no process that monitors the state of the stopped child
    via *wait()*.
  id: totrans-274
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 此时，没有进程通过*wait()*监控停止子进程的状态。
- en: Since the shell did not create the child process, it is not aware of the child’s
    existence or that the child is part of the same process group as the deceased
    parent. Furthermore, the *init* process checks only for a terminated child, and
    then reaps the resulting zombie process. Consequently, the stopped child might
    languish forever, since no other process knows to send it a `SIGCONT` signal in
    order to cause it to resume execution.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 由于外壳没有创建子进程，因此它不知道子进程的存在，也不知道子进程与已故的父进程属于同一个进程组。此外，*init*进程只检查是否有终止的子进程，然后回收产生的僵尸进程。因此，停止的子进程可能会永远被搁置，因为没有其他进程知道应该发送`SIGCONT`信号来使其恢复执行。
- en: 'Even if a stopped process in an orphaned process group has a still-living parent
    in a different session, that parent is not guaranteed to be able to send `SIGCONT`
    to the stopped child. A process may send `SIGCONT` to any other process in the
    same session, but if the child is in a different session, the normal rules for
    sending signals apply ([Sending Signals: *kill()*](ch20.html#sending_signals_colon_kill_open_parenthe
    "Sending Signals: kill()")), so the parent may not be able to send a signal to
    the child if the child is a privileged process that has changed its credentials.'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: '即使孤儿进程组中的一个停止进程在不同会话中仍有存活的父进程，该父进程也无法保证能够向停止的子进程发送`SIGCONT`信号。进程可以向同一会话中的任何其他进程发送`SIGCONT`信号，但如果子进程在不同的会话中，则发送信号的正常规则适用（[发送信号：*kill()*](ch20.html#sending_signals_colon_kill_open_parenthe
    "Sending Signals: kill()")），因此如果子进程是一个已经更改了其凭据的特权进程，父进程可能无法向子进程发送信号。'
- en: To prevent scenarios such as the one described above, SUSv3 specifies that if
    a process group becomes orphaned and has any stopped members, then all members
    of the group are sent a `SIGHUP` signal, to inform them that they have become
    disconnected from their session, followed by a `SIGCONT` signal, to ensure that
    they resume execution. If the orphaned process group doesn’t have any stopped
    members, no signals are sent.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 为了防止上述情况的发生，SUSv3规定，如果一个进程组变成了孤儿进程组并且其中有任何停止的成员，那么该组的所有成员都会收到`SIGHUP`信号，告知它们已与会话断开连接，随后会发送`SIGCONT`信号，确保它们恢复执行。如果孤儿进程组中没有停止的成员，则不会发送任何信号。
- en: A process group may become orphaned either because the last parent in a different
    process group in the same session terminated or because of the termination of
    the last process within the group that had a parent in another group. (The latter
    case is the one illustrated in [Figure 34-3](ch34.html#steps_in_the_creation_of_an_orphaned_pro
    "Figure 34-3. Steps in the creation of an orphaned process group").) In either
    case, the treatment of a newly orphaned process group containing stopped children
    is the same.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 进程组可能变成孤儿进程组，原因可能是同一会话中不同进程组中的最后一个父进程终止，或者是组内最后一个有父进程的进程终止（后者是[图34-3](ch34.html#steps_in_the_creation_of_an_orphaned_pro
    "Figure 34-3. Steps in the creation of an orphaned process group")中所示的情况）。无论是哪种情况，处理新成为孤儿的包含停止子进程的进程组的方式都是一样的。
- en: Note
  id: totrans-279
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Sending `SIGHUP` and `SIGCONT` to a newly orphaned process group that contains
    stopped members is done in order to eliminate a specific loophole in the job-control
    framework. There is nothing to prevent the members of an already-orphaned process
    group from later being stopped if another process (with suitable privileges) sends
    them a stop signal. In this case, the processes will remain stopped until some
    process (again with suitable privileges) sends them a `SIGCONT` signal.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 向包含已停止成员的新的孤儿进程组发送`SIGHUP`和`SIGCONT`信号是为了消除作业控制框架中的一个特定漏洞。如果另一个进程（具有适当权限）向其发送停止信号，已经成为孤儿的进程组中的成员仍然可能被停止。在这种情况下，进程将保持停止状态，直到某个进程（同样具有适当权限）向其发送`SIGCONT`信号。
- en: When called by a member of an orphaned process group, the *tcsetpgrp()* function
    ([Foreground and Background Process Groups](ch34.html#foreground_and_background_process_groups
    "Foreground and Background Process Groups")) fails with the error `ENOTTY`, and
    calls to the *tcsetattr()*, *tcflush()*, *tcflow()*, *tcsendbreak()*, and *tcdrain()*
    functions (all described in [Chapter 62](ch62.html "Chapter 62. Terminals")) fail
    with the error `EIO`.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 当孤儿进程组的成员调用时，*tcsetpgrp()*函数（[前台和后台进程组](ch34.html#foreground_and_background_process_groups
    "前台和后台进程组")）会因错误`ENOTTY`而失败，并且对*tcsetattr()*、*tcflush()*、*tcflow()*、*tcsendbreak()*和*tcdrain()*函数的调用（这些函数在[第62章](ch62.html
    "第62章. 终端")中有描述）也会因错误`EIO`而失败。
- en: Example program
  id: totrans-282
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 示例程序
- en: The program in [Example 34-7](ch34.html#sighup_and_orphaned_process_groups "Example 34-7. SIGHUP
    and orphaned process groups") demonstrates the treatment of orphaned processes
    that we have just described. After establishing handlers for `SIGHUP` and `SIGCONT`
    ![](figs/web/U002.png), this program creates one child process for each command-line
    argument ![](figs/web/U003.png). Each child then stops itself (by raising `SIGSTOP`)
    ![](figs/web/U004.png), or waits for signals (using *pause()*) ![](figs/web/U005.png).
    The choice of action by the child is determined by whether or not the corresponding
    command-line argument starts with the letter *s* (for *stop*). (We use a command-line
    argument starting with the letter *p* to specify the converse action of calling
    *pause()*, although any character other than the letter *s* can be used.)
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 34-7](ch34.html#sighup_and_orphaned_process_groups "示例 34-7. SIGHUP 和孤儿进程组")中的程序展示了我们刚才描述的孤儿进程的处理方式。在为`SIGHUP`和`SIGCONT`信号建立处理程序后！[](figs/web/U002.png)，该程序为每个命令行参数创建一个子进程！[](figs/web/U003.png)。然后每个子进程会停止自身（通过发送`SIGSTOP`信号）！[](figs/web/U004.png)，或者等待信号（使用*pause()*）！[](figs/web/U005.png)。子进程的行为由命令行参数是否以字母*s*（表示*stop*）开头来决定。（我们使用以字母*p*开头的命令行参数来指定调用*pause()*的反向操作，尽管可以使用除字母*s*以外的任何字符。）'
- en: 'After creating all of the children, the parent sleeps for a few seconds to
    allow the children time to get set up ![](figs/web/U006.png). (As noted in [Creating
    a New Process: *fork()*](ch24.html#creating_a_new_process_colon_fork_open_p "Creating
    a New Process: fork()"), using *sleep()* in this way is an imperfect, but sometimes
    viable method of accomplishing this result.) The parent then exits ![](figs/web/U007.png),
    at which point the process group containing the children becomes orphaned. If
    any of the children receives a signal as a consequence of the process group becoming
    orphaned, the signal handler is invoked, and it displays the child’s process ID
    and the signal number ![](figs/web/U001.png).'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建所有子进程后，父进程会睡眠几秒钟，以便给子进程一些时间进行初始化！[](figs/web/U006.png)。如[创建新进程：*fork()*](ch24.html#creating_a_new_process_colon_fork_open_p
    "创建新进程：fork()")中所述，使用*sleep()*这种方式虽然不完美，但有时是实现该结果的可行方法。然后父进程退出！[](figs/web/U007.png)，此时包含子进程的进程组变成了孤儿进程组。如果任何子进程因进程组变成孤儿而接收到信号，则会调用信号处理程序，并显示该子进程的进程ID和信号编号！[](figs/web/U001.png)。
- en: Example 34-7. `SIGHUP` and orphaned process groups
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 34-7. `SIGHUP` 和孤儿进程组
- en: '[PRE40]'
  id: totrans-286
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'The following shell session log shows the results of two different runs of
    the program in [Example 34-7](ch34.html#sighup_and_orphaned_process_groups "Example 34-7. SIGHUP
    and orphaned process groups"):'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是[示例 34-7](ch34.html#sighup_and_orphaned_process_groups "示例 34-7. SIGHUP 和孤儿进程组")中程序两次运行结果的
    shell 会话日志：
- en: '[PRE41]'
  id: totrans-288
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'The first run creates two children in the to-be-orphaned process group: one
    stops itself and the other pauses. (In this run, the shell prompt appears in the
    middle of the children’s output because the shell notices that the parent has
    already exited.) As can be seen, both children receive `SIGCONT` and `SIGHUP`
    after the parent exits. In the second run, two children are created, neither stops
    itself, and consequently no signals are sent when the parent exits.'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 第一次运行创建了两个子进程，它们处于即将成为孤儿的进程组中：一个子进程停止自己，另一个暂停。（在这个运行中，Shell提示符出现在子进程输出的中间，因为Shell注意到父进程已经退出。）如可以看到，父进程退出后，两个子进程都接收到`SIGCONT`和`SIGHUP`信号。在第二次运行中，创建了两个子进程，它们都没有停止自己，因此在父进程退出时没有发送任何信号。
- en: Orphaned process groups and the `SIGTSTP`, `SIGTTIN`, and `SIGTTOU` signals
  id: totrans-290
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 孤儿进程组与`SIGTSTP`、`SIGTTIN`和`SIGTTOU`信号
- en: Orphaned process groups also affect the semantics for delivery of the `SIGTSTP`,
    `SIGTTIN`, and `SIGTTOU` signals.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 孤儿进程组还会影响`SIGTSTP`、`SIGTTIN`和`SIGTTOU`信号的传递语义。
- en: In [Using Job Control Within the Shell](ch34.html#using_job_control_within_the_shell
    "Using Job Control Within the Shell"), we saw that `SIGTTIN` is sent to a background
    process if it tries to *read()* from the controlling terminal, and `SIGTTOU` is
    sent to a background process that tries to *write()* to the controlling terminal
    if the terminal’s `TOSTOP` flag is set. However, it makes no sense to send these
    signals to an orphaned process group since, once stopped, it will never be resumed
    again. For this reason, instead of sending `SIGTTIN` or `SIGTTOU`, the kernel
    causes *read()* or *write()* to fail with the error `EIO`.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 在[使用Shell中的作业控制](ch34.html#using_job_control_within_the_shell "使用Shell中的作业控制")中，我们看到如果后台进程尝试从控制终端*read()*，则会发送`SIGTTIN`信号；如果后台进程尝试向控制终端*write()*，并且终端的`TOSTOP`标志已设置，则会发送`SIGTTOU`信号。然而，向孤儿进程组发送这些信号是没有意义的，因为一旦停止，它将永远不会被恢复。因此，内核不发送`SIGTTIN`或`SIGTTOU`，而是使*read()*或*write()*失败，并返回错误`EIO`。
- en: For similar reasons, if delivery of `SIGTSTP`, `SIGTTIN`, or `SIGTTOU` would
    stop a member of an orphaned process group, then the signal is silently discarded.
    (If the signal is being handled, then it is delivered to the process.) This behavior
    occurs no matter how the signal is sent—for example, whether the signal is generated
    by the terminal driver or sent by an explicit call to *kill()*.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 出于类似的原因，如果`SIGTSTP`、`SIGTTIN`或`SIGTTOU`的传递会停止一个孤儿进程组的成员，那么该信号将被静默丢弃。（如果信号正在被处理，则会传递给进程。）无论信号是如何发送的——例如，信号是由终端驱动程序生成，还是通过显式调用*kill()*发送——都会发生这种行为。
- en: Summary
  id: totrans-294
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 总结
- en: 'Sessions and process groups (also known as jobs) form a two-level hierarchy
    of processes: a session is a collection of process groups, and a process group
    is a collection of processes. A session leader is the process that created the
    session using *setsid()*. Similarly, a process group leader is the process that
    created the group using *setpgid()*. All of the members of a process group share
    the same process group ID (which is the same as the process ID of the process
    group leader), and all processes in the process groups that constitute a session
    have the same session ID (which is the same as the process ID of the session leader).
    Each session may have a controlling terminal (`/dev/tty`), which is established
    when the session leader opens a terminal device. Opening the controlling terminal
    also causes the session leader to become the controlling process for the terminal.'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 会话和进程组（也称为作业）形成了一个两级层次的进程结构：会话是多个进程组的集合，进程组是多个进程的集合。会话领导者是创建会话的进程，使用*setsid()*来创建。类似地，进程组领导者是创建进程组的进程，使用*setpgid()*来创建。进程组中的所有成员共享相同的进程组ID（与进程组领导者的进程ID相同），而构成会话的进程组中的所有进程共享相同的会话ID（与会话领导者的进程ID相同）。每个会话可能有一个控制终端（`/dev/tty`），该终端在会话领导者打开终端设备时建立。打开控制终端还会使会话领导者成为该终端的控制进程。
- en: 'Sessions and process groups were defined to support shell job control (although
    occasionally they find other uses in applications). Under job control, the shell
    is the session leader and controlling process for the terminal on which it is
    running. Each job (a simple command or a pipeline) executed by the shell is created
    as a separate process group, and the shell provides commands to move a job between
    three states: running in the foreground, running in the background, and stopped
    in the background.'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 会话和进程组是为了支持shell作业控制而定义的（尽管有时它们在应用程序中也有其他用途）。在作业控制下，shell是会话领导者和控制终端的控制进程。由shell执行的每个作业（一个简单命令或管道）都会被创建为一个单独的进程组，shell提供命令以在三种状态之间移动作业：在前台运行、在后台运行和在后台停止。
- en: To support job control, the terminal driver maintains a record of the foreground
    process group (job) for the controlling terminal. The terminal driver delivers
    job-control signals to the foreground job when certain characters are typed. These
    signals either terminate or stop the foreground job.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 为了支持作业控制，终端驱动程序会维护一个控制终端的前台进程组（作业）的记录。当某些字符被输入时，终端驱动程序会向前台作业发送作业控制信号。这些信号会终止或停止前台作业。
- en: The notion of the terminal’s foreground job is also used to arbitrate terminal
    I/O requests. Only processes in the foreground job may read from the controlling
    terminal. Background jobs are prevented from reading by delivery of the `SIGTTIN`
    signal, whose default action is to stop the job. If the terminal `TOSTOP` is set,
    then background jobs are also prevented from writing to the controlling terminal
    by delivery of a `SIGTTOU` signal, whose default action is to stop the job.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 终端前台作业的概念也被用来仲裁终端I/O请求。只有前台作业中的进程才能从控制终端读取数据。通过发送`SIGTTIN`信号，后台作业被阻止读取数据，默认操作是停止该作业。如果终端设置了`TOSTOP`，则通过发送`SIGTTOU`信号，后台作业也会被阻止向控制终端写入数据，默认操作是停止该作业。
- en: When a terminal disconnect occurs, the kernel delivers a `SIGHUP` signal to
    the controlling process to inform it of the fact. Such an event may result in
    a chain reaction whereby a `SIGHUP` signal is delivered to many other processes.
    First, if the controlling process is a shell (as is typically the case), then,
    before terminating, the shell sends `SIGHUP` to each of the process groups it
    has created. Second, if delivery of `SIGHUP` results in termination of a controlling
    process, then the kernel also sends `SIGHUP` to all of the members of the foreground
    process group of the controlling terminal.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 当终端断开连接时，内核会向控制进程发送`SIGHUP`信号，以通知其发生了这种情况。这样的事件可能会引发连锁反应，导致`SIGHUP`信号被发送到许多其他进程。首先，如果控制进程是一个shell（通常情况如此），那么在终止之前，shell会向它所创建的每个进程组发送`SIGHUP`信号。其次，如果`SIGHUP`信号的传递导致控制进程终止，那么内核还会向控制终端的前台进程组中的所有成员发送`SIGHUP`信号。
- en: In general, applications don’t need to be cognizant of job-control signals.
    One exception is when a program performs screen-handling operations. Such programs
    need to correctly handle the `SIGTSTP` signal, resetting terminal attributes to
    sane values before the process is suspended, and restoring the correct (application-specific)
    terminal attributes when the application is once more resumed following delivery
    of a `SIGCONT` signal.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 一般来说，应用程序不需要关注作业控制信号。唯一的例外是当程序执行屏幕处理操作时。这类程序需要正确处理`SIGTSTP`信号，在进程挂起之前将终端属性重置为合理的值，并在应用程序恢复后，收到`SIGCONT`信号时恢复正确的（应用特定的）终端属性。
- en: A process group is considered to be orphaned if none of its member processes
    has a parent in a different process group in the same session. Orphaned process
    groups are significant because there is no process outside the group that can
    both monitor the state of any stopped processes within the group and is always
    allowed to send a `SIGCONT` signal to these stopped processes in order to restart
    them. This could result in such stopped processes languishing forever on the system.
    To avoid this possibility, when a process group with stopped member processes
    becomes orphaned, all members of the process group are sent a `SIGHUP` signal,
    followed by a `SIGCONT` signal, to notify them that they have become orphaned
    and ensure that they are restarted.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 如果进程组的成员进程没有其他来自不同进程组的父进程，该进程组则被认为是孤儿进程组。孤儿进程组非常重要，因为没有外部进程可以同时监控该组中任何停止进程的状态，并且总是允许向这些停止的进程发送`SIGCONT`信号以重新启动它们。这样会导致这些停止的进程永远在系统中处于挂起状态。为避免这种可能性，当一个包含停止进程的进程组成为孤儿进程组时，该进程组的所有成员会收到一个`SIGHUP`信号，随后发送一个`SIGCONT`信号，通知它们已经成为孤儿进程组，并确保它们被重新启动。
- en: Further information
  id: totrans-302
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 更多信息
- en: '[Chapter 9](ch09.html "Chapter 9. Process Credentials") of [Stevens & Rago,
    2005] covers similar material to this chapter, and includes a description of the
    steps that occur during login to establish the session for a login shell. The
    *glibc* manual contains a lengthy description of the functions relating to job
    control and the implementation of job control within the shell. The SUSv3 rationale
    contains an extensive discussion of sessions, process groups, and job control.'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: '[第9章](ch09.html "第9章 进程凭证")的[Stevens & Rago, 2005]涵盖了与本章类似的内容，并描述了登录过程中的步骤，以建立登录
    Shell 的会话。*glibc* 手册中包含了关于作业控制及其在 Shell 中实现的详细说明。SUSv3 理由中有对会话、进程组和作业控制的广泛讨论。'
- en: Exercises
  id: totrans-304
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习
- en: 'Suppose a parent process performs the following steps:'
  id: totrans-305
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 假设父进程执行以下步骤：
- en: '[PRE42]'
  id: totrans-306
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE42]'
- en: What problem might be encountered with this application design? (Consider shell
    pipelines.) How could this problem be avoided?
  id: totrans-307
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这种应用设计可能会遇到什么问题？（考虑到 Shell 管道）该如何避免这个问题？
- en: Write a program to verify that a parent process can change the process group
    ID of one of its children before the child performs an *exec()*, but not afterward.
  id: totrans-308
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写一个程序验证父进程在子进程执行*exec()*之前可以更改其子进程的进程组 ID，但在子进程执行*exec()*之后则无法更改。
- en: Write a program to verify that a call to *setsid()* from a process group leader
    fails.
  id: totrans-309
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写一个程序验证从进程组领导者调用*setsid()*是否失败。
- en: Modify the program in [Example 34-4](ch34.html#catching_sighup_when_a_terminal_disconne
    "Example 34-4. Catching SIGHUP when a terminal disconnect occurs") (`disc_SIGHUP.c`)
    to verify that, if the controlling process doesn’t terminate as a consequence
    of receiving `SIGHUP`, then the kernel doesn’t send `SIGHUP` to the members of
    the foreground process.
  id: totrans-310
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 修改[示例 34-4](ch34.html#catching_sighup_when_a_terminal_disconne "示例 34-4. 捕获终端断开连接时的
    SIGHUP")（`disc_SIGHUP.c`）中的程序，验证如果控制进程在接收到`SIGHUP`后没有终止，那么内核不会将`SIGHUP`发送给前台进程组的成员。
- en: Suppose that, in the signal handler of [Example 34-6](ch34.html#handling_sigtstp
    "Example 34-6. Handling SIGTSTP"), the code that unblocks the `SIGTSTP` signal
    was moved to the start of the handler. What potential race condition does this
    create?
  id: totrans-311
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 假设在[示例 34-6](ch34.html#handling_sigtstp "示例 34-6. 处理 SIGTSTP")的信号处理程序中，将解除阻塞`SIGTSTP`信号的代码移动到处理程序的开始处。这样会产生什么潜在的竞态条件？
- en: Write a program to verify that when a process in an orphaned process group attempts
    to *read()* from the controlling terminal, the *read()* fails with the error `EIO`.
  id: totrans-312
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写一个程序验证当一个孤儿进程组中的进程尝试从控制终端*read()*时，*read()*会因为错误`EIO`而失败。
- en: Write a program to verify that if one of the signals `SIGTTIN`, `SIGTTOU`, or
    `SIGTSTP` is sent to a member of an orphaned process group, then the signal is
    discarded (i.e., has no effect) if it would stop the process (i.e., the disposition
    is `SIG_DFL`), but is delivered if a handler is installed for the signal.
  id: totrans-313
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写一个程序验证，如果`SIGTTIN`、`SIGTTOU`或`SIGTSTP`信号发送到孤儿进程组的成员时，如果该信号会停止进程（即其处理方式为`SIG_DFL`），则该信号会被丢弃（即没有效果）；但是，如果该信号安装了处理程序，则信号会被传递。
