- en: <hgroup>
  id: totrans-0
  prefs: []
  type: TYPE_NORMAL
  zh: <hgroup>
- en: 29 PROGRAMMING CRUD OPERATIONS
  id: totrans-1
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 29 编程 CRUD 操作
- en: </hgroup>
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: </hgroup>
- en: '![](../images/opener.jpg)'
  id: totrans-3
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/opener.jpg)'
- en: In the preceding chapter, we began developing a database-driven web application,
    with a focus on learning how to read data from the database. However, reading
    is just one of the four primary database operations known collectively as *CRUD*,
    short for *create, read, update, delete*. In this chapter, we’ll look at the other
    components of CRUD as we expand our web application. We’ll write code that allows
    users to change the database data by deleting, adding, or updating entries through
    interactive links and web forms.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在前一章中，我们开始开发一个基于数据库的 Web 应用程序，重点学习如何从数据库读取数据。然而，读取只是四种主要数据库操作之一，这四种操作统称为 *CRUD*，即
    *创建（create）、读取（read）、更新（update）、删除（delete）*。在本章中，我们将研究 CRUD 中的其他操作，同时扩展我们的 Web
    应用程序。我们将编写代码，允许用户通过交互式链接和 Web 表单，通过删除、添加或更新条目来更改数据库数据。
- en: 'Just about any database-driven mobile or web application revolves around the
    four CRUD operations. Take an email app as an example: when you write a new email
    and send it, this *creates* an item in the database representing the receiver
    of the email, as well as an item in your own system’s Sent mailbox database. It’s
    common to *read* or *delete* email in your inbox, and you may also draft an email
    and then *update* it later before sending (or deleting) it.'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 几乎所有基于数据库的移动或 Web 应用程序都围绕这四个 CRUD 操作展开。以电子邮件应用程序为例：当你写一封新邮件并发送时，这 *创建* 了一个表示收件人的数据库条目，并且在你自己的系统的已发送邮件箱数据库中也会创建一个条目。通常你会在收件箱中
    *读取* 或 *删除* 邮件，或者你可能会草拟一封邮件，稍后再 *更新* 它，然后发送（或删除）它。
- en: As we start adding the remaining CRUD features to our web application, you’ll
    notice a pattern. Each change will begin with a new case in the front-controller
    switch statement inside the Application class, invoking a new method in the ProductController
    class. This method, in turn, will call a new repository class method, where the
    actual database interaction will take place. Finally, we’ll update the appropriate
    page templates to add the necessary user interface for the new feature.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们开始将剩余的 CRUD 特性添加到 Web 应用程序时，你会注意到一个模式。每个更改都会以 Application 类中的前端控制器开关语句中的新案例开始，并调用
    ProductController 类中的新方法。该方法将进一步调用一个新的存储库类方法，实际的数据库交互将在这里进行。最后，我们将更新相应的页面模板，添加新功能所需的用户界面。
- en: Deleting Data
  id: totrans-7
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 删除数据
- en: Sometimes we need to delete data from a database table. For example, a car manufacturer
    may stop making a particular model of a car. The model’s details might be copied
    into an archive database table, and then the model is deleted from the main table
    of car models. To delete data from a table, we use the DELETE SQL keyword. If
    no criteria are given, all records are deleted from the named table.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 有时我们需要从数据库表中删除数据。例如，一家汽车制造商可能停止生产某个特定型号的汽车。该型号的详细信息可能会被复制到归档数据库表中，然后从汽车模型的主表中删除该型号。要从表中删除数据，我们使用
    DELETE SQL 关键字。如果没有提供任何条件，所有记录都会从指定的表中删除。
- en: 'When deleting a specific row or rows matching certain criteria, we need to
    provide an SQL WHERE clause. For example, to delete the row with an ID of 4 from
    a model table, the SQL statement would be as follows:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 当删除特定行或符合某些条件的行时，我们需要提供一个 SQL WHERE 子句。例如，要从模型表中删除 ID 为 4 的行，SQL 语句如下：
- en: '[PRE0]'
  id: totrans-10
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: We’ll look at examples of deleting an entire table and selectively deleting
    entries from a table in this section.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将查看删除整个表以及选择性删除表中条目的示例。
- en: Deleting Everything from a Table
  id: totrans-12
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 从表中删除所有内容
- en: Let’s first add a feature to our web application from the previous chapter that
    deletes all the products from the products table in the database. [Figure 29-1](#fig29-1)
    shows the Delete All Products link we’ll create, along with a pop-up confirmation
    dialog. It’s always a good idea to offer users a chance to reconsider and cancel
    destructive operations such as permanently deleting data (assuming they have the
    option to delete data at all).
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们首先为前一章中的 Web 应用程序添加一个功能，从数据库中的产品表删除所有产品。[图 29-1](#fig29-1) 显示了我们将创建的“删除所有产品”链接，以及一个弹出确认对话框。总是一个好主意为用户提供重新考虑和取消破坏性操作（例如永久删除数据）的机会（假设他们确实有删除数据的选项）。
- en: '![](../images/figure29-1.jpg)'
  id: totrans-14
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/figure29-1.jpg)'
- en: 'Figure 29-1: Deleting all products'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 图 29-1：删除所有产品
- en: First, we’ll add a new route to detect a POST submission with the action =deleteAll
    variable. Update the run() method in the Application class to match [Listing 29-1](#lis29-1).
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将添加一个新的路由来检测POST提交，其中包含action=deleteAll变量。更新Application类中的run()方法，使其与[列表29-1](#lis29-1)的内容一致。
- en: '[PRE1]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Listing 29-1: The updated Application class to act on the deleteAll action'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 列表29-1：更新后的Application类，用于执行deleteAll操作
- en: We add a new $isPostSubmission variable that will be true if the received request
    uses the POST method. While it’s technically possible to write a web application
    that changes the server state (such as the database contents) in response to GET
    messages, this would violate the definition of the HTTP GET method. For this reason,
    we’ll use the POST method and an HTML <form> element for any database-changing
    requests (deletions, creations, or updates) in this chapter.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 我们添加一个新的$isPostSubmission变量，如果接收到的请求使用POST方法，则该变量为true。虽然技术上可以编写一个响应GET消息并更改服务器状态（例如数据库内容）的Web应用程序，但这将违反HTTP
    GET方法的定义。因此，在本章中，对于任何更改数据库的请求（删除、创建或更新），我们将使用POST方法和HTML <form>元素。
- en: We next add a new case to the front-controller switch statement for when the
    value of action in the URL is 'deleteAll'. When this action is received through
    a POST request, we invoke the deleteAll() method of the ProductController object.
    If $isPostSubmission is false, we instead use the defaultController to return
    an error message to the user.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们在前控制器的switch语句中添加一个新的case，用于处理URL中的action值为'deleteAll'的情况。当通过POST请求接收到该操作时，我们调用ProductController对象的deleteAll()方法。如果$isPostSubmission为false，我们将使用defaultController返回一个错误消息给用户。
- en: We’ll define the deleteAll() method next. Update *src/ProductController.php*
    to match the contents of [Listing 29-2](#lis29-2).
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将定义deleteAll()方法。更新*src/ProductController.php*，使其与[列表29-2](#lis29-2)的内容一致。
- en: '[PRE2]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Listing 29-2: Adding the deleteAll() method to ProductController'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 列表29-2：将deleteAll()方法添加到ProductController
- en: We declare the ProductController class’s deleteAll() method to in turn invoke
    the deleteAll() method of the ProductRepository class (which manages communication
    with the database). Then we invoke the list() method to make the application display
    the Product List page, using the header() function and location URL /?action=products.
    The user should therefore see an empty list of products after they’ve all been
    deleted.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 我们声明ProductController类的deleteAll()方法，依次调用ProductRepository类的deleteAll()方法（该类负责与数据库的通信）。然后，我们调用list()方法，使应用程序显示产品列表页面，使用header()函数和位置URL
    /?action=products。因此，用户在所有产品被删除后应该看到一个空的产品列表。
- en: Now we’ll add the deleteAll() method to the ProductRepository class. Update
    *src/ProductRepository.php* as shown in [Listing 29-3](#lis29-3).
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将deleteAll()方法添加到ProductRepository类。更新*src/ProductRepository.php*，使其与[列表29-3](#lis29-3)的内容一致。
- en: '[PRE3]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Listing 29-3: Adding the deleteAll() method to ProductRepository'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 列表29-3：将deleteAll()方法添加到ProductRepository
- en: We declare the deleteAll() method to return an integer value indicating the
    number of rows deleted from the database. If the connection is NULL, we return
    0. Otherwise, we declare, prepare, and execute the 'DELETE FROM product' SQL query
    string, which deletes every entry from the product table. Then we invoke the rowCount()
    method of the PDO statement object ❶, which returns the number of rows affected
    by the most recently executed query. We return this integer value at the end of
    the method.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 我们声明deleteAll()方法，返回一个整数值，表示从数据库中删除的行数。如果连接为NULL，则返回0。否则，我们声明、准备并执行'DELETE FROM
    product'的SQL查询语句，该语句删除产品表中的所有条目。然后，我们调用PDO语句对象的rowCount()方法❶，它返回最近执行的查询所影响的行数。我们在方法的末尾返回该整数值。
- en: Finally, we need to update the template for the Product List page to offer a
    link for deleting all the products. Update *templates/product/list.xhtml.twig*
    to match the contents of [Listing 29-4](#lis29-4).
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们需要更新产品列表页面的模板，提供一个删除所有产品的链接。更新*templates/product/list.xhtml.twig*，使其与[列表29-4](#lis29-4)的内容一致。
- en: '[PRE4]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Listing 29-4: The list.xhtml.twig template for listing all products'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 列表29-4：用于列出所有产品的list.xhtml.twig模板
- en: Here we add a paragraph to the end of the template declaring a POST method form
    containing a Bootstrap-styled button with the text Delete ALL products. The action
    for our controller to receive (deleteAll) is sent through the form’s action attribute.
    This button includes a pop-up confirmation message (launched by the JavaScript
    confirm() function) declared in its onclick attribute, so the user will be able
    to confirm or cancel the request.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们在模板的末尾添加一个段落，声明一个包含Bootstrap样式按钮的POST方法表单，按钮文本为“删除所有产品”。控制器接收的操作（deleteAll）通过表单的action属性传递。此按钮包含一个弹出确认消息（通过JavaScript的confirm()函数触发），并在其onclick属性中声明，这样用户就能确认或取消请求。
- en: Deleting Individual Items by ID
  id: totrans-33
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 根据ID删除单个项目
- en: 'Just as we can show a particular product based on its ID, we can also use an
    ID to specify which individual product to delete from the database. Let’s add
    that feature now. [Figure 29-2](#fig29-2) shows a screenshot of the page we’ll
    create: each product in the Product List page will get its own Show and Delete
    button-styled links, each triggering a database action based on the product’s
    ID.'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 就像我们可以根据产品ID展示特定产品一样，我们也可以使用ID指定要从数据库中删除的单个产品。现在让我们添加这个功能。[图29-2](#fig29-2)展示了我们将要创建的页面截图：在产品列表页面中，每个产品将有自己显示和删除按钮样式的链接，每个链接都根据产品ID触发数据库操作。
- en: '![](../images/figure29-2.jpg)'
  id: totrans-35
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/figure29-2.jpg)'
- en: 'Figure 29-2: The Show and Delete buttons for an individual product'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 图29-2：每个单独产品的显示和删除按钮
- en: We first need to add a new route URL pattern of action=delete, where the ID
    of the product to be deleted is passed through a POST form submission as a variable
    id. Update the Application class code to match [Listing 29-5](#lis29-5).
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先需要添加一个新的路由URL模式，action=delete，其中要删除的产品ID通过POST表单提交作为变量id。请根据[清单29-5](#lis29-5)更新Application类代码。
- en: '[PRE5]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Listing 29-5: The Application class, updated to act on the delete action'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 清单29-5：更新后的Application类，用于处理删除操作
- en: Here we add a new case in the front-controller switch statement for when the
    value of action in the URL is 'delete'. In this case, we attempt to extract an
    integer variable id from the POST variables received in the request ❶. If $isPostSubmission
    is true and the ID isn’t empty, we pass the ID to the delete() method of the ProductController
    object. Otherwise, we pass an appropriate error message to the error() method
    of the DefaultController object for display.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们在前端控制器的switch语句中添加一个新的case，用于当URL中的action值为“delete”时。在这种情况下，我们尝试从请求接收到的POST变量中提取一个整数变量id
    ❶。如果$isPostSubmission为true并且ID不为空，我们将ID传递给ProductController对象的delete()方法。否则，我们将适当的错误信息传递给DefaultController对象的error()方法进行显示。
- en: To define the delete() method, update *src/ProductController.php* according
    to [Listing 29-6](#lis29-6).
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 要定义delete()方法，请根据[清单29-6](#lis29-6)更新*src/ProductController.php*。
- en: '[PRE6]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Listing 29-6: Adding the delete() method to ProductController'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 清单29-6：向ProductController添加delete()方法
- en: The delete() method takes in an integer product ID and passes it to the delete()
    method of the ProductRepository object. Then it makes the application display
    the Product List page via the list() method. The user should therefore see the
    list of products, less the one deleted, after clicking the link to delete an item.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: delete()方法接受一个整数类型的产品ID，并将其传递给ProductRepository对象的delete()方法。然后，它通过list()方法使应用程序显示产品列表页面。因此，用户在点击删除链接后，应该看到删除项后的产品列表。
- en: Now we’ll add the delete() method to the ProductRepository class in *src/ProductRepository.php*.
    [Listing 29-7](#lis29-7) shows how.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将在*src/ProductRepository.php*中向ProductRepository类添加delete()方法。[清单29-7](#lis29-7)展示了如何操作。
- en: '[PRE7]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Listing 29-7: Adding the delete() method to ProductRepository'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 清单29-7：向ProductRepository添加delete()方法
- en: The delete() method takes in an integer argument (the ID) and returns a Boolean
    indicating the success of the deletion. If the connection is NULL, we return false.
    Otherwise, we declare the SQL query string 'DELETE FROM product WHERE id = :id'
    to delete just the product with the specified ID. We then prepare the statement
    and bind the $id argument to the :id placeholder. Executing the statement then
    produces a Boolean success value, which we store and return.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: delete()方法接受一个整数参数（ID），并返回一个布尔值，表示删除操作是否成功。如果连接为NULL，我们返回false。否则，我们声明SQL查询字符串
    'DELETE FROM product WHERE id = :id' 来删除指定ID的产品。然后，我们准备语句并将$id参数绑定到:id占位符。执行该语句后会返回一个布尔成功值，我们将其存储并返回。
- en: Finally, we need to update the Product List template to offer the button-styled
    Show and Delete links for each product. Modify *templates/product/list.xhtml.twig*
    to match the contents of [Listing 29-8](#lis29-8).
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们需要更新产品列表模板，为每个产品提供样式为按钮的 Show 和 Delete 链接。修改 *templates/product/list.xhtml.twig*
    文件，使其与[列表 29-8](#lis29-8)的内容匹配。
- en: '[PRE8]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Listing 29-8: The list.xhtml.twig template offering deletion by ID'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 29-8：提供按 ID 删除功能的 list.xhtml.twig 模板
- en: We style the existing Show link as a secondary button ❶. Then we declare a POST
    submission form with action=delete and a button Delete, passing id as a hidden
    variable filling in the product ID with the Twig {{product.id}} placeholder ❷.
    As with the Delete ALL products form, this form button includes a pop-up confirmation
    message declared in an onclick attribute, so the user will be able to confirm
    or cancel the request. We also add a Twig else block ❸ so that the message (there
    are no products to display) is shown if no products are found in the database.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将现有的 Show 链接样式修改为次级按钮 ❶。然后我们声明一个 POST 提交表单，action=delete，并设置一个名为 Delete 的按钮，传递
    id 作为隐藏变量，用 Twig 的 {{product.id}} 占位符填充产品 ID ❷。与删除所有产品的表单一样，该表单按钮包括一个在 onclick
    属性中声明的弹出确认消息，这样用户就可以确认或取消请求。我们还添加了一个 Twig else 块 ❸，如果数据库中没有找到产品，将显示消息（没有产品可显示）。
- en: Creating New Database Entries
  id: totrans-53
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建新的数据库条目
- en: 'Let’s turn to the *C* in CRUD: creating new database entries by using SQL INSERT
    statements. For example, here’s an SQL statement that inserts a new row into a
    table called cat:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来关注 CRUD 中的 *C*：通过 SQL INSERT 语句创建新的数据库条目。例如，下面是一个向名为 cat 的表中插入新行的 SQL 语句：
- en: '[PRE9]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Three values are provided for the name, gender, and age columns. The INSERT
    SQL statement requires us to first list the sequence of column names, and then
    follow this with the values to be inserted into those columns.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 为名称、性别和年龄列提供了三个值。INSERT SQL 语句要求我们首先列出列名的顺序，然后跟随这些值，插入到相应的列中。
- en: We touched on how to create new database entries when we first set up our application’s
    database with its two initial products in “Setting Up the Database Schema” on
    [page 543](chapter28.xhtml#pg_543). Now we’ll make the process interactive by
    adding a form to our application that allows users to define new products and
    submit them to the database. [Figure 29-3](#fig29-3) shows the form we’ll create.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在“设置数据库模式”章节中提到过如何创建新的数据库条目，并且介绍了如何在应用程序的数据库中设置两个初始产品，[页面 543](chapter28.xhtml#pg_543)中有详细说明。现在，我们将通过向应用程序中添加一个表单来使这个过程更加互动，让用户可以定义新的产品并将其提交到数据库中。[图
    29-3](#fig29-3)展示了我们将创建的表单。
- en: '![](../images/figure29-3.jpg)'
  id: totrans-58
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/figure29-3.jpg)'
- en: 'Figure 29-3: The link to create a new product and its associated form'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 图 29-3：创建新产品的链接及其相关表单
- en: We’ll add a button link at the bottom of the Product List page to create a new
    product. This link will launch a Create NEW Product page with form fields for
    submitting the new product’s description and price.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在产品列表页面的底部添加一个按钮链接，用于创建新产品。该链接将启动一个创建新产品页面，包含提交新产品描述和价格的表单字段。
- en: Adding Products Through a Web Form
  id: totrans-61
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 通过 Web 表单添加产品
- en: To offer the Create NEW Product page form feature, we first need to add two
    new route actions to the application, one to display the form (action=create)
    and one to process the form submission (action=processCreate). [Listing 29-9](#lis29-9)
    shows how to add cases for these actions to the front controller in the Application
    class.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 为了提供创建新产品页面表单功能，我们首先需要向应用程序添加两个新的路由动作，一个用于显示表单（action=create），另一个用于处理表单提交（action=processCreate）。[列表
    29-9](#lis29-9)展示了如何向应用程序类的前端控制器中添加这两个动作的 case。
- en: '[PRE10]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Listing 29-9: Adding the ''create'' and ''processCreate'' routes to the front
    controller'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 29-9：将 'create' 和 'processCreate' 路由添加到前端控制器
- en: First, we add a new case in the front-controller switch statement for when the
    value of action in the URL is 'create' ❶. This invokes the create() method of
    the ProductController object.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们在前端控制器的 switch 语句中为 URL 中 action 值为 'create' 时添加一个新 case ❶。这将调用 ProductController
    对象的 create() 方法。
- en: Next, we declare the case for the 'processCreate' action ❷. For that, we retrieve
    the description and price values from the POST submission variables. Notice the
    use of two filters for the float price variable; the FILTER_FLAG_ALLOW_FRACTION
    argument is required to permit the decimal-point character.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们声明 'processCreate' 动作的 case ❷。为此，我们从 POST 提交的变量中获取描述和价格的值。请注意，浮动价格变量使用了两个过滤器；FILTER_FLAG_ALLOW_FRACTION
    参数是必需的，以允许小数点字符。
- en: If $isPostSubmission is true and both $description and $price are not empty
    ❸, the description and price are passed to the processCreate() method of the ProductController
    object. Otherwise, an appropriate error message will be displayed using the error()
    method of the DefaultController object.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 $isPostSubmission 为 true 且 $description 和 $price 都不为空 ❸，则描述和价格将传递给 ProductController
    对象的 processCreate() 方法。否则，将使用 DefaultController 对象的 error() 方法显示适当的错误信息。
- en: This example is assuming that the product database table uses auto-incrementing
    to choose a new, unique integer ID when a new row is added, as demonstrated in
    [Chapter 28](chapter28.xhtml). Without this feature, we’d also have to supply
    an ID for the new product, perhaps using logic that first finds the highest current
    ID in the database and then adds 1 to it.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 本示例假设产品数据库表使用自动递增的方式为新添加的行选择一个新的唯一整数 ID，如 [第 28 章](chapter28.xhtml) 所示。如果没有此功能，我们还需要为新产品提供一个
    ID，可能需要使用逻辑先查找数据库中当前最大的 ID，然后加 1。
- en: We’ll now add the create() and processCreate() methods to the Product Controller
    class. Update *src/ProductController.php* to match [Listing 29-10](#lis29-10).
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将把 create() 和 processCreate() 方法添加到 ProductController 类中。更新 *src/ProductController.php*
    文件以匹配 [列表 29-10](#lis29-10)。
- en: '[PRE11]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Listing 29-10: Adding the create() and processCreate() methods to ProductController'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 29-10：将 create() 和 processCreate() 方法添加到 ProductController
- en: The create() method ❶ simply renders the *templates/product/create.xhtml.twig*
    template to display the new product form (we’ll create this template shortly).
    The processCreate() method ❷ takes in a string for the new description and a float
    for the new price and passes them along to the insert() method of the ProductRepository
    object for insertion into the database. Then processCreate() invokes the Product
    List page via the list() method so that the user will see the updated list of
    products, including the newly created one.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: create() 方法 ❶ 只是渲染 *templates/product/create.xhtml.twig* 模板来显示新产品表单（我们稍后会创建这个模板）。processCreate()
    方法 ❷ 接受一个字符串作为新描述和一个浮动值作为新价格，并将它们传递给 ProductRepository 对象的 insert() 方法，以便插入到数据库中。然后，processCreate()
    调用 list() 方法来跳转到产品列表页面，以便用户看到更新后的产品列表，其中包括新创建的产品。
- en: 'If we were being completely correct, our processCreate() method would not call
    the list() method, but instead would force a redirect, sending a new request to
    the server to list all products. By not redirecting, we’ll get a problem: if the
    user refreshes their browser page after submitting a form, the form will be submitted
    a second time. However, adding redirects now would make our work in the next section
    more complex, so we’ll just call the list() method for now and formulate a better
    redirect solution at the end of this chapter.'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们完全按照规范操作，processCreate() 方法将不会调用 list() 方法，而是会强制重定向，向服务器发送新请求以列出所有产品。如果不进行重定向，我们将遇到一个问题：如果用户在提交表单后刷新浏览器页面，表单将被提交第二次。但是，现在添加重定向会让我们在下一部分的工作变得更加复杂，所以我们目前就先调用
    list() 方法，等到本章最后再制定一个更好的重定向方案。
- en: To add the insert() method to the ProductRepository class, update *src/ProductRepository.php*
    as shown in [Listing 29-11](#lis29-11).
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 要将 insert() 方法添加到 ProductRepository 类中，请更新 *src/ProductRepository.php* 文件，按照
    [列表 29-11](#lis29-11) 的示例。
- en: '[PRE12]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Listing 29-11: Adding the insert() method to ProductRepository'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 29-11：将 insert() 方法添加到 ProductRepository
- en: The new insert() method takes in a string argument ($description) and a float
    argument ($price) and returns an integer—either the ID of the newly created database
    record or -1 if no record is created. If the database connection is NULL, we return
    -1 right away. Otherwise, we declare and prepare the SQL query string 'INSERT
    INTO product (description, price) VALUES (:description, :price)' to add a new
    entry to the product table.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 新的 insert() 方法接受一个字符串参数（$description）和一个浮动值参数（$price），并返回一个整数——要么是新创建的数据库记录的
    ID，要么是 -1，表示没有创建记录。如果数据库连接为 NULL，我们会立即返回 -1。否则，我们声明并准备 SQL 查询字符串 'INSERT INTO
    product (description, price) VALUES (:description, :price)' 来向产品表中添加一个新条目。
- en: We then bind the $description argument to the :description placeholder and the
    $price argument to the :price placeholder before executing the statement. Finally,
    we test the Boolean $success value from the execution ❶. If true, we use the lastInsertId()
    method of the PDO connection object to return the ID of the most recently inserted
    database entry, which should correspond to the new product. If false, we return
    -1 instead.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们将$description参数绑定到:description占位符，将$price参数绑定到:price占位符，之后执行语句。最后，我们测试执行结果的布尔值$success
    ❶。如果为真，我们使用PDO连接对象的lastInsertId()方法返回最近插入的数据库条目的ID，该ID应对应于新产品。如果为假，我们返回-1。
- en: Now let’s revise the Product List page template to include the link for adding
    a new product. Update *templates/product/list.xhtml.twig* to match the contents
    of [Listing 29-12](#lis29-12).
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们修改产品列表页面模板，以包含添加新产品的链接。更新*templates/product/list.xhtml.twig*以匹配[清单29-12](#lis29-12)中的内容。
- en: '[PRE13]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Listing 29-12: Adding the new product link to the list.xhtml.twig template'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 清单29-12：将新产品链接添加到list.xhtml.twig模板
- en: Here we add a paragraph to the end of the template containing a Bootstrap button–styled
    link with the text Create NEW product. The link triggers the create URL action.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们向模板的末尾添加一个段落，其中包含一个Bootstrap样式的按钮链接，文本为“创建新产品”。该链接触发create URL动作。
- en: Now let’s add the Twig template to display the Create NEW Product page form.
    Create the *templates/product/create.xhtml.twig* template file containing the
    code shown in [Listing 29-13](#lis29-13).
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们添加Twig模板以显示创建新产品页面的表单。创建*templates/product/create.xhtml.twig*模板文件，包含[清单29-13](#lis29-13)中所示的代码。
- en: '[PRE14]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Listing 29-13: The create.xhtml.twig template for the new product form'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 清单29-13：新产品表单的create.xhtml.twig模板
- en: This template presents an HTML form ❶ whose submit action is action=processCreate,
    so the submitted values will be passed along to the processCreate() method of
    the ProductController class described earlier. The form contains two paragraphs,
    for the description and price, and then a Submit button.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 该模板呈现一个HTML表单 ❶，其提交动作为action=processCreate，因此提交的值将传递给前面描述的ProductController类中的processCreate()方法。表单包含两个段落，分别用于描述和价格，然后是一个提交按钮。
- en: Highlighting the Newly Created Product
  id: totrans-87
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 突出显示新创建的产品
- en: When something is changed, it’s helpful to highlight the change to the user.
    Let’s update our application to highlight the new product in the product list
    after it’s been added to the database. [Figure 29-4](#fig29-4) shows the effect
    we want to achieve; it shows we’ve added a very expensive bag of nails costing
    $999!
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 当某些内容发生变化时，突出显示变化对用户非常有帮助。让我们更新应用程序，以在新产品添加到数据库后，在产品列表中突出显示它。[图29-4](#fig29-4)展示了我们想要实现的效果；它显示了我们添加了一个非常昂贵的钉子袋，价格为999美元！
- en: '![](../images/figure29-4.jpg)'
  id: totrans-89
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/figure29-4.jpg)'
- en: 'Figure 29-4: Displaying the newly created product with a highlighted background'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 图29-4：显示新创建的产品并突出显示背景
- en: To implement this feature, we can take advantage of the return value from the
    ProductRepository class’s insert() method, which we declared in the preceding
    section. This value indicates the ID of the newly created product, so we can add
    logic to the application to highlight the product whose ID matches this value.
    First, we need to update the ProductController class, shown in [Listing 29-14](#lis29-14).
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 为实现此功能，我们可以利用ProductRepository类的insert()方法返回值，该方法在前面的章节中已声明。这个返回值表示新创建的产品的ID，因此我们可以向应用程序添加逻辑，以突出显示ID与该值匹配的产品。首先，我们需要更新ProductController类，如[清单29-14](#lis29-14)所示。
- en: '[PRE15]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Listing 29-14: Updating the list() and update() methods in the ProductController
    class'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 清单29-14：更新ProductController类中的list()和update()方法
- en: We update the list() method (which displays the complete product list) to take
    in an optional $newProductId parameter with a default value of NULL. We pass this
    parameter to the Twig Product List template, along with the array of products
    ❶. Next, we update the processCreate() method to receive the new product ID returned
    from insert() and pass it along to the list() method.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 我们更新list()方法（显示完整的产品列表），使其接受一个可选的$newProductId参数，默认值为NULL。我们将此参数传递给Twig产品列表模板，以及产品数组
    ❶。接下来，我们更新processCreate()方法，接收从insert()返回的新产品ID，并将其传递给list()方法。
- en: Now we can update the Product List template to highlight the product matching
    the id variable passed to the template. Since the product IDs start at 1 and auto-increment,
    a value of -1 will never match an object retrieved from the database, so the list()
    method’s default $newProductId parameter value of -1 will result in no products
    being highlighted. Modify *templates/product/list.xhtml.twig* as shown in [Listing
    29-15](#lis29-15).
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以更新产品列表模板，以突出显示与传递给模板的id变量匹配的产品。由于产品ID从1开始并且自动递增，-1的值永远不会与从数据库中检索到的对象匹配，因此list()方法的默认$newProductId参数值-1将导致没有产品被高亮显示。按照[列表29-15](#lis29-15)中的示例，修改*templates/product/list.xhtml.twig*模板。
- en: '[PRE16]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Listing 29-15: Updating the list.xhtml.twig template to highlight the newly
    added product within the list'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 列表29-15：更新list.xhtml.twig模板，以在列表中突出显示新增的产品
- en: We’ve added a Twig if statement inside the loop through the products that sets
    the Twig highlight variable to 'active' if the ID of the current product matches
    the received Twig variable id ❶. Otherwise, the highlight variable is set to an
    empty string. We include the value of highlight in the CSS style classes for each
    list item ❷, so each product will either be highlighted or not, as appropriate.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在遍历产品的Twig循环中添加了一个if语句，该语句检查当前产品的ID是否与接收到的Twig变量id ❶匹配。如果匹配，Twig的高亮变量会被设置为'active'，否则高亮变量会被设置为空字符串。我们将highlight的值包含到每个列表项的CSS样式类中
    ❷，因此每个产品将根据需要被高亮显示或不显示。
- en: Finally, we need to add a <style> element for the active CSS class in the base
    template. Update */templates/product/base.xhtml.twig* according to [Listing 29-16](#lis29-16).
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们需要在基础模板中添加一个<style>元素来为活动的CSS类设置样式。按照[列表29-16](#lis29-16)更新*/templates/product/base.xhtml.twig*。
- en: '[PRE17]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Listing 29-16: Declaring a <style> element in the base.xhtml.twig Twig template'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 列表29-16：在base.xhtml.twig Twig模板中声明<style>元素
- en: In the <head> element, we add a CSS rule that active list items should have
    a pink background.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 在<head>元素中，我们添加了一个CSS规则，指定活动的列表项应该有粉色背景。
- en: Updating a Database Entry
  id: totrans-103
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 更新数据库条目
- en: 'The last CRUD operation to explore is the *U* for *update*. This operation
    is necessary since the data in a database constantly needs to be changed to reflect
    changes in the real world, such as a person’s new address, the increase in the
    price of a product, a user changing their subscription status, and so on. To modify
    an existing record in a table, we can use the SQL UPDATE keyword. For example,
    here’s an SQL statement that changes the age of a cat to 5, for the row whose
    ID is 1:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一项要探索的CRUD操作是*U*代表*更新*。这个操作很重要，因为数据库中的数据需要不断更新，以反映现实世界中的变化，比如人的新地址、产品价格的上涨、用户更改订阅状态等。为了修改表中的现有记录，我们可以使用SQL的UPDATE关键字。例如，下面是一个SQL语句，它将ID为1的猫的年龄改为5：
- en: '[PRE18]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Let’s add a way to update an existing product to our web application. Much like
    creating a new product, we’ll do this through a web form. [Figure 29-5](#fig29-5)
    shows how this new feature will work.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们为我们的Web应用程序添加一个更新现有产品的功能。就像创建新产品一样，我们通过Web表单来实现。图[29-5](#fig29-5)展示了这个新功能的工作原理。
- en: '![](../images/figure29-5.jpg)'
  id: totrans-107
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/figure29-5.jpg)'
- en: 'Figure 29-5: Updating an existing product'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 图29-5：更新现有产品
- en: We’ll add an Edit button to each product in the Product List page, which will
    take the user to an Edit Product page with form fields to modify the product’s
    description and price (the ID will be read-only). These fields will start out
    with the current values filled in. Once the changes are submitted, the newly updated
    product will be highlighted on the Product List page.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在产品列表页面的每个产品上添加一个“编辑”按钮，点击该按钮后，用户将进入编辑产品页面，页面上有表单字段用于修改产品的描述和价格（ID字段为只读）。这些字段初始时会填入当前的值。一旦提交更改，更新后的产品将在产品列表页面上突出显示。
- en: To implement this feature, we must first add two new route actions, one to display
    the editing form (action=edit) and one to process the form submission (action=processEdit).
    [Listing 29-17](#lis29-17) adds these two new cases to the front controller in
    the Application class.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 为了实现这个功能，我们首先需要添加两个新的路由动作，一个用于显示编辑表单（action=edit），一个用于处理表单提交（action=processEdit）。[列表29-17](#lis29-17)将这两个新操作添加到了应用程序类的前端控制器中。
- en: '[PRE19]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Listing 29-17: Adding the ''edit'' and ''processEdit'' routes to the front
    controller'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 列表29-17：将'edit'和'processEdit'路由添加到前端控制器
- en: We add a new case in the front-controller switch statement for when the value
    of action in the URL is 'edit' ❶. As with the 'show' and 'delete' cases, we attempt
    to extract an integer id variable from the URL-encoded variables received in the
    request. If the value of id is empty, we display an appropriate error message
    by passing a string message to the error() method of the DefaultController object.
    If the value isn’t empty, we pass it to the edit() method of the ProductController
    object.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在前端控制器的switch语句中添加一个新的case，用于处理当URL中action的值为'edit'❶时的情况。与'show'和'delete'的情况一样，我们尝试从请求中接收到的URL编码变量中提取一个整数id变量。如果id的值为空，我们通过将字符串消息传递给DefaultController对象的error()方法来显示适当的错误消息。如果值不为空，我们将其传递给ProductController对象的edit()方法。
- en: Next, we add the 'processEdit' case ❷, which starts by retrieving id, description,
    and price from the POST submitted variables. If $isPostSubmission is true and
    all three variables (id, description, and price) aren’t empty, we pass the values
    to the processEdit() method of the ProductController object. Otherwise, we again
    display an appropriate error message by using the error() method of the DefaultController
    object.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们添加'processEdit' case❷，它首先通过POST提交的变量检索id、description和price。如果$isPostSubmission为true，并且三个变量（id、description和price）都不为空，我们将这些值传递给ProductController对象的processEdit()方法。否则，我们再次使用DefaultController对象的error()方法显示适当的错误消息。
- en: Now we’ll add the new methods to the ProductController class. Update *src/ProductController.php*
    to match the contents of [Listing 29-18](#lis29-18).
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将向ProductController类中添加新方法。更新*src/ProductController.php*文件，使其与[Listing 29-18](#lis29-18)的内容一致。
- en: '[PRE20]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Listing 29-18: Adding the edit() and processEdit() methods to ProductController'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: Listing 29-18：向ProductController添加edit()和processEdit()方法
- en: The edit() method uses the provided integer $id argument to retrieve a single
    Product object from the database ❶. Then it passes this object to the */templates/product/edit.xhtml.twig*
    template, which displays the form for editing the product. The processEdit() method
    takes in an $id integer, $description string, and $price float and passes them
    to the update() method of the ProductRepository object ❷. Then it makes the application
    display to the Product List page via the list() method. As with the processCreate()
    method, we pass the ID of the updated product to list() so that product will be
    highlighted.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: edit()方法使用提供的整数$id参数从数据库中检索单个Product对象❶。然后它将该对象传递给*/templates/product/edit.xhtml.twig*模板，该模板显示用于编辑产品的表单。processEdit()方法接受一个$id整数、$description字符串和$price浮动值，并将它们传递给ProductRepository对象的update()方法❷。接着，它通过list()方法使应用程序显示到产品列表页面。与processCreate()方法类似，我们将更新产品的ID传递给list()，以便该产品会被高亮显示。
- en: Listing 29-19 shows how to add the new update() method to the ProductRepository
    class.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: Listing 29-19展示了如何将新的update()方法添加到ProductRepository类中。
- en: '[PRE21]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Listing 29-19: Adding the update() method to the ProductRepository class'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: Listing 29-19：将update()方法添加到ProductRepository类中
- en: The update() method takes in a product’s ID, description, and price, and returns
    a Boolean value indicating the success or failure of the update. If the database
    connection is NULL, then false is returned. Otherwise, we declare the SQL query
    string 'UPDATE product SET description = :description, price = :price WHERE id=:id',
    using the WHERE clause with the object’s ID to specify the particular database
    row to be updated. After preparing the statement, we bind the $id, $description,
    and $price variables to their corresponding placeholders.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: update()方法接受一个产品的ID、描述和价格，并返回一个布尔值，表示更新的成功或失败。如果数据库连接为NULL，则返回false。否则，我们声明SQL查询字符串'UPDATE
    product SET description = :description, price = :price WHERE id=:id'，使用WHERE子句和对象的ID来指定要更新的特定数据库行。在准备好语句后，我们将$id、$description和$price变量绑定到相应的占位符。
- en: Then we execute the statement and return the resulting Boolean success value.
    Note that we’re returning a Boolean here, rather than the product ID as we did
    previously for the insert() method. The difference here is that the calling method
    already knows the product ID in question, so it’s sufficient to simply return
    the true/false success of executing the database update statement.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们执行该语句并返回结果布尔值的成功状态。请注意，这里返回的是布尔值，而不是像我们在之前的insert()方法中那样返回产品ID。这里的区别在于，调用方法已经知道了相关的产品ID，因此只需要返回执行数据库更新语句的真/假成功状态即可。
- en: Now we need to offer an Edit button for each product on the Product List page.
    Update the *templates/product/list.xhtml.twig* file as shown in [Listing 29-20](#lis29-20).
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们需要为产品列表页面上的每个产品提供一个编辑按钮。更新 *templates/product/list.xhtml.twig* 文件，如[列表 29-20](#lis29-20)所示。
- en: '[PRE22]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Listing 29-20: Adding an Edit button to the list.xhtml.twig template'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 29-20：向 list.xhtml.twig 模板添加编辑按钮
- en: Inside the Twig for loop for the current product, we add a Bootstrap button–styled
    link with the text Edit. This link for the edit action includes the id of the
    current product.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 在当前产品的 Twig 循环中，我们添加了一个使用 Bootstrap 样式的按钮链接，文本为“编辑”。这个编辑操作的链接包含当前产品的 ID。
- en: Finally, let’s add the Twig template to display the form to edit the details
    of a product. Create *templates/product/edit.xhtml.twig* containing the code shown
    in [Listing 29-21](#lis29-21).
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，让我们添加一个 Twig 模板来显示编辑产品详细信息的表单。创建 *templates/product/edit.xhtml.twig* 文件，并包含[列表
    29-21](#lis29-21)中所示的代码。
- en: '[PRE23]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Listing 29-21: The edit.xhtml.twig template for the form to edit a product'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 29-21：用于编辑产品的 edit.xhtml.twig 模板
- en: The main work of this template is to present an HTML form ❶ whose submit action
    is action=processEdit, so the submitted values will go to the processEdit() method
    of the ProductController class described earlier. This form contains three paragraphs,
    for the ID, description, and price, and then a Submit button. The ID, description,
    and price form inputs are populated with the values of the Product object for
    those properties. The ID input has the readonly attribute; since we don’t want
    the user to be able to edit this value, it’s displayed but isn’t editable ❷.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 该模板的主要工作是呈现一个 HTML 表单 ❶，其提交操作为 action=processEdit，因此提交的值将传递给前面描述的 ProductController
    类中的 processEdit() 方法。此表单包含三个段落，分别用于 ID、描述和价格，然后是一个提交按钮。ID、描述和价格表单输入框将被填充为 Product
    对象中相应属性的值。ID 输入框具有 readonly 属性；因为我们不希望用户编辑此值，它会被显示但不可编辑 ❷。
- en: Avoiding Double Form Submission with Redirects
  id: totrans-132
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 避免通过重定向进行双重表单提交
- en: In our current implementation, we call the list() method after processing a
    form submission to add or edit a product. By passing a product ID to this method,
    we can make our template highlight the product that’s been created or updated.
    If the user were to refresh their browser page after submitting a form, however,
    the browser would attempt to submit the form data a second time by repeating the
    HTTP POST request. We can avoid this problem by making the server *redirect* to
    request the Product List page after a form submission (a GET request for the URL
    /?action=products). If the page is refreshed, this GET request to list all products
    will be repeated rather than the POST request. This technique is sometimes called
    the *post-redirect-get (PRG) pattern*.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们当前的实现中，我们在处理完表单提交以添加或编辑产品后调用 list() 方法。通过将产品 ID 传递给此方法，我们可以使模板突出显示已创建或更新的产品。然而，如果用户在提交表单后刷新浏览器页面，浏览器将尝试通过重复
    HTTP POST 请求再次提交表单数据。我们可以通过使服务器在表单提交后*重定向*到请求产品列表页面来避免这个问题（即发送一个 GET 请求到 URL /?action=products）。如果页面被刷新，GET
    请求将重新发送以列出所有产品，而不是 POST 请求。这种技术有时被称为*后提交重定向获取（PRG）模式*。
- en: Let’s update our application to use this redirect approach. Rather than passing
    the product ID as an argument to the list() method, we’ll need to store the ID
    in the $_SESSION array. As we discussed in [Chapter 14](chapter14.xhtml), this
    is a special array for storing data about the user’s current browser session.
    First, we’ll update the list() method and add a new session helper method in *src/ProductController.php*,
    as shown in [Listing 29-22](#lis29-22).
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们更新应用程序以使用这种重定向方法。我们不再将产品 ID 作为参数传递给 list() 方法，而是需要将 ID 存储在 $_SESSION 数组中。正如我们在[第
    14 章](chapter14.xhtml)中讨论的那样，这是一个专门用于存储用户当前浏览器会话数据的数组。首先，我们将更新 list() 方法，并在 *src/ProductController.php*
    中添加一个新的会话辅助方法，如[列表 29-22](#lis29-22)所示。
- en: '[PRE24]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Listing 29-22: Updating the list() method and adding getIdFromSession() to
    the ProductController class'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 29-22：更新 list() 方法并将 getIdFromSession() 添加到 ProductController 类
- en: The list() method no longer has any parameters as input. Instead we attempt
    to retrieve an ID from the session by using the getIdFromSession() method ❶. This
    method initializes the $id variable to NULL, then tests whether the $_SESSION
    array contains a variable with a key of 'id' ❷. If such a key exists, its value
    is retrieved and stored in $id, then that element of the array is unset so that
    it will no longer be stored in the session once retrieved. The method returns
    the value of $id, which will be either NULL or the value retrieved from the session.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: list()方法不再有任何参数输入。相反，我们尝试使用getIdFromSession()方法从会话中检索ID ❶。该方法将$id变量初始化为NULL，然后测试$_SESSION数组是否包含一个键为'id'
    ❷的变量。如果存在这样的键，则其值被检索并存储在$id中，然后该数组元素会被删除，以便在检索后不再存储在会话中。该方法返回$id的值，可能是NULL或从会话中检索到的值。
- en: Now we can update the ProductController class methods to use redirects after
    storing the ID in the session. Update these methods in *src/ProductController.php*
    as shown in [Listing 29-23](#lis29-23).
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以更新ProductController类方法，在将ID存储到会话中后使用重定向。按照[清单29-23](#lis29-23)所示，更新*src/ProductController.php*中的这些方法。
- en: '[PRE25]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Listing 29-23: Updating the POST action methods to use redirects in ProductController'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 清单29-23：更新ProductController中的POST操作方法以使用重定向
- en: Both the delete() and deleteAll() methods have been updated to use the built-in
    header() function to redirect the server to process a GET request for the URL
    /?action=products ❶. This value of action will result in the products being listed
    by our list() method.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 删除(delete())和删除所有(deleteAll())方法已更新为使用内置的header()函数，重定向服务器处理URL /?action=products的GET请求
    ❶。该action值将导致我们的list()方法列出产品。
- en: We’ve also updated processCreate() to store the ID of the newly created product
    ($newObjectId) in the session with key 'id' ❷. Then it redirects the server to
    process a GET request for the URL /?action=products. Likewise, we’ve updated the
    processEdit() method to store the ID of the edited product’s ID ($id) in the session
    with the key 'id' ❸ and to redirect to /?action=products in the same way. We’ve
    now improved our web application to properly redirect after processing a POST
    form submission, so a refresh of the browser will not result in a repeat submission
    of the form data.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还更新了processCreate()方法，将新创建的产品的ID（$newObjectId）存储在会话中，键名为'id' ❷。然后，它将服务器重定向到处理URL
    /?action=products的GET请求。同样，我们更新了processEdit()方法，将编辑过的产品的ID（$id）存储在会话中，键名为'id'
    ❸，并以相同的方式重定向到/?action=products。现在，我们已经改进了Web应用程序，在处理POST表单提交后正确重定向，因此刷新浏览器时不会导致表单数据的重复提交。
- en: Since we’re storing the ID in the session, we have to ensure that the session
    is started by our front-controller index script each time a request is received.
    Update */public/index.php* as shown in [Listing 29-24](#lis29-24).
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们将ID存储在会话中，因此我们必须确保每次接收到请求时，前控制器index脚本会启动会话。按照[清单29-24](#lis29-24)所示，更新*/public/index.php*。
- en: '[PRE26]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Listing 29-24: Updating index.php to ensure that sessions are active for our
    web application'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 清单29-24：更新index.php以确保我们的Web应用程序会话处于活动状态
- en: We now call the session_start() function before any actions are taken. This
    ensures that our web application can store and retrieve values from the user’s
    HTTP session.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在在执行任何操作之前调用session_start()函数。这确保了我们的Web应用程序可以存储和检索来自用户HTTP会话的值。
- en: Summary
  id: totrans-147
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 总结
- en: 'In this chapter, we explored the full range of standard database operations:
    creating, reading, updating, and deleting entries, collectively known as *CRUD*.
    As in the preceding chapter, we used prepared statements for all our database
    queries, making it easy to bind parameters to the four actions such as deleting
    a row by its ID or inserting new values into multiple fields of a database entry.'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们探讨了标准数据库操作的全方位内容：创建、读取、更新和删除条目，统称为*CRUD*。与前一章一样，我们对所有数据库查询都使用了预处理语句，使得绑定参数到这四个操作变得容易，例如通过ID删除一行或将新值插入到数据库条目的多个字段中。
- en: We continued to see how much of the architecture of a database-driven web application
    is identical to that of a non-database application. The core of our code is focused
    around a front controller interrogating the requests received from the web client
    and invoking appropriate controller methods. By encapsulating our database actions
    in a repository class, we were able to keep the logic in our controller classes
    focused on responding to requests by arranging data and rendering the appropriate
    Twig template.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 我们继续看到，数据库驱动的网页应用程序的架构与非数据库应用程序是多么相似。我们的代码核心围绕一个前端控制器展开，它负责检查从网页客户端接收到的请求，并调用相应的控制器方法。通过将数据库操作封装在一个存储库类中，我们能够保持控制器类的逻辑专注于通过整理数据并渲染适当的Twig模板来响应请求。
- en: We also saw how forms for creating and updating database rows are presented
    and processed just like any other web form, only now the data is passed to the
    repository method to work with the database. We then saw how to improve the system
    by using redirects after processing form submissions to avoid a repeat of the
    form actions if the browser page happens to be refreshed.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还看到，创建和更新数据库行的表单是如何呈现和处理的，和其他任何网页表单一样，只不过现在数据会传递到存储库方法，用于与数据库进行交互。接着，我们看到如何通过在处理表单提交后使用重定向来改进系统，以避免在浏览器页面刷新时重复表单操作。
- en: Exercises
  id: totrans-151
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 练习
- en: 1.   Open a web application you regularly use, such as a social media app or
    e-commerce site. Explore the actions available to you as a user and reflect on
    which CRUD operations are being executed for each action. How is data coming from
    and being saved to the database sitting behind the web application you’re using?
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 1.   打开一个你常用的网络应用程序，例如社交媒体应用或电子商务网站。探索作为用户你可以执行的操作，并思考每个操作对应的CRUD操作。数据是如何从你使用的网页应用后端数据库中获取并保存的？
- en: '2.   Create a CRUD web application for Book objects with these properties:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 2.   为书籍对象创建一个CRUD网页应用，具有以下属性：
- en: id (integer), an auto-incrementing primary key
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: id（整数），自增长主键
- en: title (string)
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 标题（字符串）
- en: author (string)
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 作者（字符串）
- en: price (float)
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 价格（浮动）
- en: 'You can either create a new project from scratch or reuse classes from this
    chapter and the [Chapter 28](chapter28.xhtml) exercises. I suggest you follow
    this sequence when incrementally adding CRUD features to your application:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以从头开始创建一个新项目，或者重用本章和[第28章](chapter28.xhtml)的练习中的类。我建议你按照以下顺序逐步为应用程序添加CRUD功能：
- en: a.   List all objects.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: a.   列出所有对象。
- en: b.   List one object, given an ID.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: b.   列出一个对象，给定一个ID。
- en: c.   Delete all objects.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: c.   删除所有对象。
- en: d.   Delete one object, given an ID.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: d.   删除一个对象，给定一个ID。
- en: e.   Create a new object.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: e.   创建一个新对象。
- en: f.   Edit an object, given an ID.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: f.   编辑一个对象，给定一个ID。
