- en: <hgroup>
  id: totrans-0
  prefs: []
  type: TYPE_NORMAL
  zh: <hgroup>
- en: <samp class="SANS_Dogma_OT_Bold_B_11">INTRODUCTION</samp>
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: <samp class="SANS_Dogma_OT_Bold_B_11">简介</samp>
- en: </hgroup>
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: </hgroup>
- en: '![](../images/opener.jpg)'
  id: totrans-3
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/opener.jpg)'
- en: This book is an introduction to graphs and their algorithms for programmers
    who want to understand and apply them. Graphs are a type of data structure used
    throughout mathematics, computer science, and numerous other fields to model and
    solve a wide range of real-world problems. The structure of a graph allows us
    to represent connections or associations between items. Understanding this structure
    is critical to harnessing the power of graphs and using them efficiently.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 本书是一本面向程序员的图及其算法入门书，旨在帮助读者理解并应用这些算法。图是一种数据结构，广泛应用于数学、计算机科学以及许多其他领域，用来建模和解决各种现实世界中的问题。图的结构使我们能够表示项目之间的连接或关联。理解这种结构对于充分利用图的强大功能并高效地使用它们至关重要。
- en: '*Graph Algorithms the Fun Way* grew out of the chapter on graphs in my previous
    book, *Data Structures the Fun Way* (No Starch Press, 2022), where I wrote, “We
    could devote an entire book to this single vastly impactful data structure.” Yet
    this book still only scratches the surface of the exciting and powerful world
    of graph algorithms, an area of study with a long history and ongoing research.
    A comprehensive coverage of all graph techniques and their relative advantages
    would require numerous volumes and be out of date the moment it was printed. Instead,
    this book is meant to serve as a foundation for people approaching this exciting
    field for the first time.'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: '*Graph Algorithms the Fun Way*（《有趣的图算法》）源自我之前的书《Data Structures the Fun Way》（《有趣的数据结构》）（No
    Starch Press，2022）中的图章节，当时我写道：“我们可以为这一单一且深远影响的数据结构专门写一本书。”然而，这本书仍然只是触及了图算法的激动人心且强大的世界的表面，这是一个历史悠久且仍在研究的领域。全面覆盖所有图技术及其相对优点将需要多卷巨著，而且一旦印刷就会过时。相反，这本书旨在为首次接触这一激动人心领域的人提供基础。'
- en: The book starts by introducing the components of graphs, then dives into exploring
    a variety of graph algorithms and how they apply to real-world problems. It is
    more than a cookbook of common algorithms. Its goal is to help readers understand
    the ideas behind the algorithms and build the intuitions to adapt the concepts
    covered here to techniques beyond this book.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 本书首先介绍图的组成部分，然后深入探索各种图算法及其在现实世界问题中的应用。这不仅仅是一本常见算法的食谱。它的目标是帮助读者理解算法背后的思想，并培养出将书中概念应用于其他技术的直觉。
- en: <samp class="SANS_Futura_Std_Bold_B_11">Who Is This Book For?</samp>
  id: totrans-7
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">这本书适合谁？</samp>
- en: This book is for programmers who want to learn more about graphs, graph algorithms,
    and the computational thinking behind such techniques. I assume no prior knowledge
    of graphs or graph algorithms. However, readers should have the kind of basic
    familiarity with Python that can be expected after an introductory course, book,
    or boot camp. They should be familiar with fundamental Python programming concepts,
    including basic data structures such as lists and dictionaries.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 本书适用于那些希望深入了解图、图算法及其背后计算思维的程序员。我假设读者没有图或图算法的基础知识。然而，读者应具备通过入门课程、书籍或训练营所能预期的基本
    Python 知识。他们应熟悉基本的 Python 编程概念，包括列表和字典等基本数据结构。
- en: I hope this book will be useful to a wide range of audiences, not just programmers
    learning graph algorithms for the first time. The examples and metaphors used
    throughout the book are designed to provide an alternative way to view the topics
    from their standard mathematical definitions. Advanced students and experienced
    computer scientists may find a new perspective to understand particularly difficult
    or tricky topics.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 我希望这本书对广泛的读者群体都有用，而不仅仅是第一次学习图算法的程序员。书中使用的示例和隐喻旨在提供一种替代视角，以不同于标准数学定义的方式来看待这些主题。高级学生和经验丰富的计算机科学家可能会发现一种新视角，帮助他们理解特别困难或棘手的课题。
- en: <samp class="SANS_Futura_Std_Bold_B_11">Analogies and Examples</samp>
  id: totrans-10
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">类比和示例</samp>
- en: This book supplements formal descriptions and code with a range of real-world
    and absurd examples and analogies. The structure of graphs makes them perfect
    for illustrating algorithms with stories of adventurers searching labyrinths or
    planning vacations through unknown cities. The goal of these examples and analogies
    is twofold. First, they motivate the algorithms themselves and why we care about
    the problems they solve. Second, they provide an alternate approach to visualizing
    these problems that will help readers break free of technicalities and minutiae.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 本书通过一系列真实世界和荒诞的示例与类比来补充正式的描述和代码。图的结构使它们非常适合用来通过冒险者探索迷宫或规划未知城市的旅行故事来展示算法。这些示例和类比的目标是双重的。首先，它们激发了算法本身，并阐明了我们为什么关心它们所解决的问题。其次，它们提供了另一种可视化这些问题的方法，帮助读者摆脱技术细节和琐碎问题。
- en: <samp class="SANS_Futura_Std_Bold_B_11">Language and Coding Conventions</samp>
  id: totrans-12
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">语言与编码规范</samp>
- en: I chose to present example code in Python due to the language’s wide use and
    readability. However, aficionados of other languages need not fear, as the concepts
    behind the code are language-agnostic. Graph algorithms have been implemented
    in a wide range of languages, and all code examples in this book can be adapted
    beyond Python.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 我选择使用 Python 来展示示例代码，因为它的广泛使用和可读性。然而，其他语言的爱好者不必担心，因为代码背后的概念是与语言无关的。图算法已经在多种语言中实现，本书中的所有代码示例都可以超越
    Python 进行适配。
- en: 'The code throughout the book uses common Python conventions. To make the code
    clearer, I use type hints, as in the following code block:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 本书中的代码遵循常见的 Python 编程规范。为了让代码更加清晰，我使用了类型提示，如以下代码块所示：
- en: '[PRE0]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The input arguments list the expected types, such as <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp>,
    and the function definition describes the expected return type (<samp class="SANS_TheSansMonoCd_W5Regular_11">bool</samp>).
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 输入参数列出了预期的类型，如 <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp>，函数定义描述了预期的返回类型（<samp
    class="SANS_TheSansMonoCd_W5Regular_11">bool</samp>）。
- en: The code in this book uses multiple core Python libraries. Since functions throughout
    a file often use the same library, individual code snippets do not explicitly
    include the <samp class="SANS_TheSansMonoCd_W5Regular_11">import</samp> statements.
    Users implementing the code will need to make sure to import the relevant libraries.
    Where ambiguous, I identify the needed libraries in the code’s text description.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 本书中的代码使用了多个核心 Python 库。由于文件中的多个函数通常使用相同的库，因此单个代码片段并没有明确包含 <samp class="SANS_TheSansMonoCd_W5Regular_11">import</samp>
    语句。实现代码的用户需要确保导入相关的库。若有歧义，我将在代码的文字描述中指出所需的库。
- en: 'Standard Python libraries used in this book include:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 本书中使用的标准 Python 库包括：
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">csv</samp>
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W5Regular_11">csv</samp>
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">copy</samp>
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W5Regular_11">copy</samp>
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">itertools</samp>
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W5Regular_11">itertools</samp>
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">math</samp>
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W5Regular_11">math</samp>
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">queue</samp>
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W5Regular_11">队列</samp>
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">random</samp>
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W5Regular_11">random</samp>
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">typing</samp> (for <samp class="SANS_TheSansMonoCd_W5Regular_11">Union</samp>)
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W5Regular_11">typing</samp>（用于 <samp class="SANS_TheSansMonoCd_W5Regular_11">Union</samp>）
- en: The <samp class="SANS_TheSansMonoCd_W5Regular_11">typing</samp> library in particular
    is needed for a number of code snippets, in order to support type hints for functions
    with multiple return values.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W5Regular_11">typing</samp> 库特别用于一些代码片段，以支持多个返回值的函数类型提示。
- en: In addition, Appendix B defines a custom <samp class="SANS_TheSansMonoCd_W5Regular_11">PriorityQueue</samp>
    class used in multiple examples, and Appendix C defines a minimal <samp class="SANS_TheSansMonoCd_W5Regular_11">UnionFind</samp>
    data structure.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，附录 B 定义了一个自定义的 <samp class="SANS_TheSansMonoCd_W5Regular_11">PriorityQueue</samp>
    类，供多个示例使用，附录 C 定义了一个简化的 <samp class="SANS_TheSansMonoCd_W5Regular_11">UnionFind</samp>
    数据结构。
- en: The code in this book is structured to stand alone as much as possible and requires
    only these core Python libraries. This means I sometimes don’t take advantage
    of good existing libraries. For example, in [Chapter 1](chapter1.xhtml) I represent
    a matrix as a list of lists instead of leveraging the <samp class="SANS_TheSansMonoCd_W5Regular_11">numpy</samp>
    library optimized for matrix operations. I call out instances where existing libraries
    would be a good fit, but I leave their integration into the code as an exercise
    for the reader.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 本书中的代码结构尽可能独立运行，只需要这些核心的Python库。这意味着我有时不会利用现有的优秀库。例如，在[第一章](chapter1.xhtml)中，我将矩阵表示为列表的列表，而不是利用专门优化矩阵操作的<samp
    class="SANS_TheSansMonoCd_W5Regular_11">numpy</samp>库。我会指出现有库可以很好地适配的情况，但将这些库的集成作为读者的练习。
- en: I’ve also made many of the implementations in the book more verbose than strictly
    necessary in order to focus on the computational ideas behind them. This means
    that individual implementations may be broken into extra stages to illustrate
    the computational concepts, structured in a way that matches the explanation,
    or otherwise may not be fully optimized. In addition, to keep the examples simple,
    I often leave out the basic validity checks that are vital for production programs.
    Treat the examples as illustrations of general concepts rather than code to use
    verbatim in your own projects.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 我还将书中的许多实现写得比严格必要的更加冗长，以便更好地关注背后的计算概念。这意味着，单个实现可能被分解为额外的阶段，以便说明计算概念，或结构方式与解释相匹配，或者可能没有完全优化。此外，为了保持示例的简洁，我通常省略了对于生产程序至关重要的基本有效性检查。请将这些示例视为一般概念的插图，而不是可以照抄到自己项目中的代码。
- en: <samp class="SANS_Futura_Std_Bold_B_11">Terminology and Definitions</samp>
  id: totrans-30
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">术语和定义</samp>
- en: Since graph algorithms have been studied in a variety of fields, multiple terms
    sometimes exist for the same underlying concept. For example, links in a graph
    are also commonly referred to as *edges* or *arcs*. I define each concept when
    it is introduced and note some of the alternative names that readers might find
    in other references.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 由于图算法在多个领域中都被研究，因此有时同一基本概念会有多个术语。例如，图中的连接通常也被称为*边*或*弧*。我在引入每个概念时会进行定义，并指出读者在其他参考资料中可能会看到的一些替代名称。
- en: In other cases, the same term is used differently within different fields. In
    particular, the definitions of several key terms have deviated over the years
    between formal graph theory in mathematics and computer science study. For example,
    in mathematics, a *path* through a graph cannot include repeated nodes, while
    in computer science it often can. Where definitions differ, I default to the common
    computer science usages and note the difference in the text.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 在其他情况下，相同的术语在不同领域中有不同的使用方式。特别是，在数学的正式图论和计算机科学研究中，几个关键术语的定义多年来发生了偏差。例如，在数学中，图中的*路径*不能包含重复的节点，而在计算机科学中，通常是可以的。当定义不同时，我通常使用计算机科学中的常见用法，并在文本中注明差异。
- en: <samp class="SANS_Futura_Std_Bold_B_11">How to Use This Book</samp>
  id: totrans-33
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">如何使用本书</samp>
- en: 'This book is structured progressively, with later chapters building on earlier
    ones. [Part I](part1.xhtml) sets up the conceptual foundations on which later
    chapters rely:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 本书结构是渐进式的，后续章节建立在前面章节的基础上。[第一部分](part1.xhtml)建立了后续章节依赖的概念基础：
- en: '**[Chapter 1](chapter1.xhtml): Representing Graphs **Introduces the structure
    of graphs, discusses the graph representations of adjacency lists and adjacency
    matrices, and provides the implementations used throughout the rest of the book.'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: '**[第一章](chapter1.xhtml)：图的表示**介绍了图的结构，讨论了邻接表和邻接矩阵的图表示，并提供了全书其他部分使用的实现方法。'
- en: '**[Chapter 2](chapter2.xhtml): Neighbors and Neighborhoods **Covers the core
    concept of neighboring nodes, basic algorithms to build sets of neighbors, and
    some basic metrics for understanding the local connectivity around a node.'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: '**[第二章](chapter2.xhtml)：邻居与邻域**涵盖了邻接节点的核心概念、构建邻居集合的基本算法以及一些理解节点周围局部连接性的基本度量。'
- en: '**[Chapter 3](chapter3.xhtml): Paths Through Graphs **Discusses paths through
    graphs and introduces multiple representations including lists of nodes, lists
    of edges, and lists of back pointers.'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: '**[第三章](chapter3.xhtml)：图中的路径**讨论图中的路径，并介绍了多种表示方法，包括节点列表、边列表和回指针列表。'
- en: 'Later sections are less interdependent but still call upon concepts in earlier
    chapters. Each is organized around a theme. [Part II](part2.xhtml) focuses on
    searches and shortest paths in a graph:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 后续章节相互独立，但仍会调用前面章节的概念。每一章节都围绕一个主题进行组织。[第二部分](part2.xhtml)重点介绍图中的搜索和最短路径：
- en: '**[Chapter 4](chapter4.xhtml): Depth-First Search **Introduces two implementations
    of depth-first search, a recursive approach and an iterative stack-based approach,
    and also discusses how search information can be encoded in a depth-first search
    tree.'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: '**[第4章](chapter4.xhtml): 深度优先搜索** 介绍了两种深度优先搜索的实现方法，一种是递归方法，另一种是基于栈的迭代方法，同时还讨论了如何在深度优先搜索树中编码搜索信息。'
- en: '**[Chapter 5](chapter5.xhtml): Breadth-First Search **Explores breadth-first
    search, discusses its properties, and shows how we can use it to find the shortest
    paths through unweighted graphs.'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: '**[第5章](chapter5.xhtml): 广度优先搜索** 探讨了广度优先搜索，讨论了其特性，并展示了如何利用该算法在无权图中找到最短路径。'
- en: '**[Chapter 6](chapter6.xhtml): Solving Puzzles **Shows how we can use graphs
    to encode puzzles and use the search algorithms from [Chapters 4](chapter4.xhtml)
    and [5](chapter5.xhtml) to solve these puzzles.'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: '**[第6章](chapter6.xhtml): 解谜** 展示了如何使用图来编码谜题，并利用[第4章](chapter4.xhtml)和[第5章](chapter5.xhtml)中的搜索算法来解决这些谜题。'
- en: '**[Chapter 7](chapter7.xhtml): Shortest Paths **Introduces three algorithms
    for finding shortest paths through weighted graphs: Dijkstra’s algorithm, the
    Bellman-Ford algorithm, and the Floyd-Warshall algorithm.'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: '**[第7章](chapter7.xhtml): 最短路径** 介绍了三种用于在加权图中寻找最短路径的算法：Dijkstra算法、Bellman-Ford算法和Floyd-Warshall算法。'
- en: '**[Chapter 8](chapter8.xhtml): Heuristic-Guided Searches **Describes two heuristic-based
    searches, heuristic greedy search and A* search, and shows how they can make use
    of heuristic information about how promising the nodes are.'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: '**[第8章](chapter8.xhtml): 启发式搜索** 描述了两种基于启发式的搜索方法，启发式贪心搜索和A*搜索，并展示了它们如何利用关于节点潜力的启发式信息。'
- en: '[Part III](part3.xhtml) focuses on connectivity and ordering in graphs:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: '[第三部分](part3.xhtml)重点介绍图中的连通性和顺序问题：'
- en: '**[Chapter 9](chapter9.xhtml): Topological Sort **Discusses the problem of
    sorting a graph’s nodes in topological order and introduces two algorithms for
    this task: Kahn’s algorithm and an extension of depth-first search.'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: '**[第9章](chapter9.xhtml): 拓扑排序** 讨论了将图的节点按拓扑顺序排序的问题，并介绍了两种实现该任务的算法：Kahn算法和深度优先搜索的扩展版本。'
- en: '**[Chapter 10](chapter10.xhtml): Minimum Spanning Trees **Describes two algorithms
    for finding minimum spanning trees on graphs, Prim’s algorithm and Kruskal’s algorithm,
    and also shows how the ideas behind Kruskal’s algorithm can be extended to problems
    such as generating solvable mazes or clustering spatial data.'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: '**[第10章](chapter10.xhtml): 最小生成树** 描述了两种用于寻找图中最小生成树的算法：Prim算法和Kruskal算法，并展示了Kruskal算法背后的思想如何扩展到生成可解迷宫或聚类空间数据等问题。'
- en: '**[Chapter 11](chapter11.xhtml): Bridges and Articulation Points **Examines
    algorithms based on depth-first search for finding bridges and articulation points
    in graphs.'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: '**[第11章](chapter11.xhtml): 桥和关节点** 检视了基于深度优先搜索的算法，用于在图中找到桥和关节点。'
- en: '**[Chapter 12](chapter12.xhtml): Strongly Connected Components **Explores Kosaraju-Sharir’s
    algorithm to identify strongly connected components in directed graphs.'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: '**[第12章](chapter12.xhtml): 强连通分量** 探讨了Kosaraju-Sharir算法，用于识别有向图中的强连通分量。'
- en: '**[Chapter 13](chapter13.xhtml): Random Walks **Introduces into random walks
    on graphs and discusses the concept of Markov chains, then shows how to implement
    random walk behavior on graphs and estimate the underlying graphs from observed
    data.'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: '**[第13章](chapter13.xhtml): 随机游走** 介绍了图上的随机游走，并讨论了马尔可夫链的概念，接着展示了如何在图中实现随机游走行为并从观察数据中估计出潜在的图结构。'
- en: '[Part IV](part4.xhtml) introduces the concept of flow within graphs and uses
    it to solve a particular matching problem:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: '[第四部分](part4.xhtml)介绍了图中的流量概念，并用它来解决特定的匹配问题：'
- en: '**[Chapter 14](chapter14.xhtml): Max-Flow Algorithms **Defines the concepts
    of flow through a graph and the max-flow problem, introduces an extended version
    of the graph data structure to support this problem, and describes the Ford-Fulkerson
    and Edmond-Karp algorithms for solving the maximum-flow problem.'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: '**[第14章](chapter14.xhtml): 最大流算法** 定义了图中流量的概念和最大流问题，介绍了一种扩展的图数据结构以支持该问题，并描述了解决最大流问题的Ford-Fulkerson算法和Edmond-Karp算法。'
- en: '**[Chapter 15](chapter15.xhtml): Bipartite Graph Matching **Introduces the
    task of matching in graphs and the concept of bipartite graphs before focusing
    on the specialization of matching within bipartite graphs. We show how to use
    maximum-flow algorithms to solve one variety of the matching problem on bipartite
    graphs.'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: '**[第15章](chapter15.xhtml): 二分图匹配**介绍了图中的匹配任务和二分图的概念，然后重点讨论了在二分图中进行匹配的专门化方法。我们展示了如何使用最大流算法来解决二分图上的一种匹配问题。'
- en: '[Part V](part5.xhtml) covers various node assignment and path planning problems
    through graphs:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: '**[第V部分](part5.xhtml)**通过图探索各种节点分配和路径规划问题：'
- en: '**[Chapter 16](chapter16.xhtml): Graph Coloring **Introduces the problem of
    assigning colors to graph nodes such that no two neighbors share a color and considers
    a range of algorithms to solve this problem.'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: '**[第16章](chapter16.xhtml): 图着色**介绍了为图的节点分配颜色的问题，要求相邻的节点不能共享相同颜色，并探讨了解决该问题的多种算法。'
- en: '**[Chapter 17](chapter17.xhtml): Cliques, Independent Sets, and Vertex Covers **Introduces
    algorithms for three computationally challenging assignment problems: finding
    a maximum clique, finding a maximum independent set, and finding a minimum vertex
    cover.'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: '**[第17章](chapter17.xhtml): 克里克、独立集和顶点覆盖**介绍了三种计算上具有挑战性的分配问题的算法：寻找最大克里克、寻找最大独立集和寻找最小顶点覆盖。'
- en: '**[Chapter 18](chapter18.xhtml): Tours Through Graphs **Considers three path-planning
    problems: finding paths that visit each node exactly once, finding paths that
    visit each node exactly once while minimizing the edge weights traversed, and
    finding paths that cross each edge exactly once. We describe why the first two
    problems are difficult, but there exists an efficient solution for the third.'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: '**[第18章](chapter18.xhtml): 图的巡回**探讨了三种路径规划问题：找到经过每个节点恰好一次的路径，找到经过每个节点恰好一次且最小化经过的边权重的路径，以及找到经过每条边恰好一次的路径。我们描述了前两个问题的困难性，但第三个问题有高效的解决方案。'
- en: 'The appendices provide additional functions and data structures that are helpful
    for implementing the algorithms in this book:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 附录提供了额外的函数和数据结构，有助于实现本书中的算法：
- en: '**[Appendix A](appendix_A.xhtml) **Describes functions for programmatically
    creating graphs, including loading them from files.'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: '**[附录A](appendix_A.xhtml)**描述了程序化创建图的函数，包括从文件加载图。'
- en: '**[Appendix B](appendix_B.xhtml) **Defines the modifiable priority queue data
    structure used in algorithms throughout the book.'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: '**[附录B](appendix_B.xhtml)**定义了本书中算法所使用的可修改优先队列数据结构。'
- en: '**[Appendix C](appendix_C.xhtml) **Introduces a minimal <samp class="SANS_TheSansMonoCd_W5Regular_11">UnionFind</samp>
    data structure necessary to implement some of the algorithms in [Chapter 10](chapter10.xhtml)'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: '**[附录C](appendix_C.xhtml)**介绍了一个最小的<samp class="SANS_TheSansMonoCd_W5Regular_11">UnionFind</samp>数据结构，必要时用于实现[第10章](chapter10.xhtml)中的一些算法。'
- en: Throughout the book, the reader should focus on the questions *How?* and *Why?
    How* does this real-world problem map onto a graph formulation? *Why* does a certain
    approach help us compute the solution? *How* does an algorithm use the graph’s
    structure to solve the problem? *Why* do we care about this problem? *How* do
    these algorithms apply to different problems? *Why* is the author using that ridiculous
    analogy? Understanding the answers to these questions will provide the foundation
    you need to effectively use existing algorithms and develop your own techniques
    in the future.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书中，读者应关注*如何？*和*为什么？* 如何将这个现实问题映射到图的表述中？*为什么*某种方法能帮助我们计算解决方案？*如何*利用图的结构来解决问题？*为什么*我们关心这个问题？*如何*将这些算法应用于不同的问题？*为什么*作者使用那个荒谬的类比？理解这些问题的答案将为你提供有效使用现有算法并在未来开发自己技术的基础。
