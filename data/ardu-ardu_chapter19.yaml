- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">19</samp> <samp class="SANS_Dogma_OT_Bold_B_11">THE
    ESP32 MICROCONTROLLER PLATFORM AND IOT</samp>
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">19</samp> <samp class="SANS_Dogma_OT_Bold_B_11">ESP32
    微控制器平台与物联网</samp>
- en: '![](../images/opener-img.png)'
  id: totrans-1
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/opener-img.png)'
- en: The phrase *Internet of things (IoT)* describes a wide variety of devices that
    communicate or are controlled over the internet. In the past, building IoT Arduino
    projects that communicate using Wi-Fi was complex and expensive, as Wi-Fi shields
    for Arduino were cumbersome and had limited features when combined with the Arduino’s
    microcontroller. However, this is no longer the case, thanks to the Espressif
    ESP32 microcontroller platform, which has built-in Wi-Fi and Arduino compatibility.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: '*物联网（IoT）*这一术语描述了通过互联网通信或被控制的各种设备。过去，使用 Wi-Fi 通信的物联网 Arduino 项目既复杂又昂贵，因为 Arduino
    的 Wi-Fi 扩展板通常体积庞大，且与 Arduino 微控制器结合时功能有限。然而，随着 Espressif 的 ESP32 微控制器平台的出现，情况已经发生了改变，ESP32
    内置了 Wi-Fi，并且与 Arduino 兼容。'
- en: We’ll use ESP32-based boards in the final six chapters of this book. For the
    best learning experience, you may want to read these chapters in order; however,
    you can still skip around between them if you prefer.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本书的最后六章将使用基于 ESP32 的开发板。为了获得最佳的学习体验，建议按顺序阅读这些章节；不过，如果你愿意，也可以随意跳过某些章节。
- en: 'In this chapter, I’ll introduce you to the ESP32-based Arduino-compatible development
    board. You’ll learn to install new board profiles in the Arduino IDE, test ESP32
    Wi-Fi connectivity, and use PWM with the ESP32 board. You’ll learn to:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一章中，我将向你介绍基于 ESP32 的 Arduino 兼容开发板。你将学习如何在 Arduino IDE 中安装新开发板配置文件，测试 ESP32
    的 Wi-Fi 连接，并在 ESP32 开发板上使用 PWM。你将学习：
- en: Create a simple web page with buttons
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个带按钮的简单网页
- en: Build a remote control for four outputs with state display
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构建一个带状态显示的四路输出遥控器
- en: Build a remote-control-adjustable PWM output
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构建一个可遥控调整的 PWM 输出
- en: You’ll use the skills you develop in this chapter to work with other internet-connected
    devices in the later chapters of this book.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 你将在本章中掌握的技能将帮助你在本书后续章节中与其他联网设备进行互动。
- en: <samp class="SANS_Futura_Std_Bold_B_11">The ESP32</samp>
  id: totrans-9
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">ESP32</samp>
- en: The ESP32 is a microcontroller with built-in Wi-Fi and Bluetooth, as well as
    a higher operating speed than a typical Arduino or compatible board. It’s not
    a simple one-chip configuration; instead, it requires an external flash memory
    IC and an antenna for the wireless operations. The IC and antenna are usually
    grouped closely together, as shown in [Figure 19-1](chapter19.xhtml#fig19-1).
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: ESP32 是一款内置 Wi-Fi 和蓝牙的微控制器，其运行速度比典型的 Arduino 或兼容开发板更快。它并不是一个简单的单片配置；相反，它需要外部闪存芯片和无线操作所需的天线。芯片和天线通常紧密放置在一起，如[图
    19-1](chapter19.xhtml#fig19-1)所示。
- en: '![AN IMAGE OF THE ESP32 MICROCONTROLLER UNIT PCB](../images/fig19-1.png)'
  id: totrans-11
  prefs: []
  type: TYPE_IMG
  zh: '![ESP32 微控制器单元 PCB 图片](../images/fig19-1.png)'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 19-1: Example ESP32
    chipset in a module with the top can removed</samp>'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">图 19-1：示例 ESP32 芯片组，去除顶部金属外壳后的模块</samp>
- en: To avoid signal interference, the required circuitry is supplied in a module,
    which has a metal can on top. This module is then fitted to boards with the circuitry
    used to interface with other devices or is added to boards to become Arduino-compatible,
    as shown in [Figure 19-2](chapter19.xhtml#fig19-2).
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 为了避免信号干扰，所需的电路被集成在一个模块中，该模块上方有金属外壳。这个模块被安装到开发板上，电路用于与其他设备连接，或者被添加到开发板上以实现 Arduino
    兼容性，如[图 19-2](chapter19.xhtml#fig19-2)所示。
- en: '![AN IMAGE OF THE ESP32-BASED ARDUINO-COMPATIBLE BOARD](../images/fig19-2.png)'
  id: totrans-14
  prefs: []
  type: TYPE_IMG
  zh: '![ESP32 基于的 Arduino 兼容开发板图片](../images/fig19-2.png)'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 19-2: An ESP32 development
    board</samp>'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">图 19-2：ESP32 开发板示例</samp>
- en: Boards like PMD Way part 51045204, shown in [Figure 19-2](chapter19.xhtml#fig19-2),
    are known as *ESP32 development boards* (or *dev boards*). You’ll use this board
    for projects from this chapter through [Chapter 24](chapter24.xhtml). Make sure
    to order the required USB cable if it isn’t included with the board you purchase.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 像 PMD Way part 51045204 这样的开发板，见[图 19-2](chapter19.xhtml#fig19-2)，通常被称为*ESP32
    开发板*（或 *开发板*）。你将在本章及[第 24 章](chapter24.xhtml)的项目中使用此开发板。如果购买的开发板没有附带 USB 电缆，请确保单独订购所需的电缆。
- en: There are four major differences between the Arduino Uno and the ESP32 dev board.
    The first is the large external flash memory IC; the ESP32 offers much more space
    for Arduino code than offered by an 8-bit Arduino. The second difference is the
    faster CPU speed of up to 240 MHz.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: Arduino Uno 和 ESP32 开发板之间有四个主要的区别。第一个是较大的外部闪存 IC；ESP32 提供的空间比 8 位 Arduino 更多，可以存储更多的
    Arduino 代码。第二个区别是 CPU 的速度更快，最高可达 240 MHz。
- en: The third difference is that the ESP32 is a 3.3 V device, so all connections
    to external devices via input or output pins must either operate at 3.3 V or be
    3.3 V tolerant. If the connection isn’t at this voltage by default, you’ll need
    to use a level converter such as PMD Way part 441079, shown in [Figure 19-3](chapter19.xhtml#fig19-3).
    Connect the converter between the wires from the 5 V device to the HV pads and
    the matching lower voltage wires on the LV pads to the ESP32, and connect GND
    of both sides to the ESP32 and the 5 V device.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 第三个区别是，ESP32 是 3.3 V 设备，因此所有通过输入或输出引脚连接的外部设备，必须在 3.3 V 下工作，或者具有 3.3 V 容忍性。如果默认连接电压不是
    3.3 V，你需要使用电平转换器，例如 [图 19-3](chapter19.xhtml#fig19-3) 中显示的 PMD Way 441079。将转换器连接在
    5 V 设备的线路和 HV 垫之间，以及连接 ESP32 的 LV 垫上的匹配低电压线路，最后将两侧的 GND 连接到 ESP32 和 5 V 设备。
- en: '![AN IMAGE OF THE FOUR-CHANNEL LEVEL CONVERTER PCB](../images/fig19-3.png)'
  id: totrans-19
  prefs: []
  type: TYPE_IMG
  zh: '![四通道电平转换器 PCB 图像](../images/fig19-3.png)'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 19-3: A four-channel
    level converter board</samp>'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">图 19-3：四通道电平转换器板</samp>
- en: When shopping for a level converter, get a four-channel unit like the unit in
    [Figure 19-3](chapter19.xhtml#fig19-3). That way, you can use both SPI and I²C
    data buses without running out of converter pins.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 在购买电平转换器时，选择一个四通道的设备，比如[图 19-3](chapter19.xhtml#fig19-3)中的设备。这样，你可以同时使用 SPI
    和 I²C 数据总线，而不会用完转换器的引脚。
- en: The final difference between the Arduino Uno and the ESP32 is that, while the
    ESP32 shares the same physical form factor as an Uno, the pinouts are different,
    as shown in [Table 19-1](chapter19.xhtml#tab19-1). This also means that some Arduino
    shields may not work with the ESP32 board, so investigate the required connections
    of a shield before purchasing to use with your ESP32.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: Arduino Uno 和 ESP32 之间的最后一个区别是，尽管 ESP32 和 Uno 具有相同的物理外形尺寸，但它们的引脚排布是不同的，具体如下所示
    [表 19-1](chapter19.xhtml#tab19-1)。这也意味着某些 Arduino 扩展板可能无法与 ESP32 开发板兼容，因此在购买用于
    ESP32 的扩展板之前，需先了解其所需的连接方式。
- en: <samp class="SANS_Futura_Std_Heavy_B_11">Table 19-1:</samp> <samp class="SANS_Futura_Std_Book_11">ESP32
    and Arduino Pinout Comparison</samp>
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Heavy_B_11">表 19-1：</samp> <samp class="SANS_Futura_Std_Book_11">ESP32
    和 Arduino 引脚排布比较</samp>
- en: '| <samp class="SANS_Futura_Std_Heavy_B_11">Arduino label</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">Uno
    R3</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">ESP32</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">Arduino
    label</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">Uno R3</samp> | <samp
    class="SANS_Futura_Std_Heavy_B_11">ESP32</samp> |'
  id: totrans-24
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_Futura_Std_Heavy_B_11">Arduino 标签</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">Uno
    R3</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">ESP32</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">Arduino
    标签</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">Uno R3</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">ESP32</samp>
    |'
- en: '| --- | --- | --- | --- | --- | --- |'
  id: totrans-25
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- | --- | --- |'
- en: '| <samp class="SANS_Futura_Std_Book_11">I</samp><samp class="SANS_Futura_Std_Book_SUP_11">2</samp><samp
    class="SANS_Futura_Std_Book_11">C clock</samp> | <samp class="SANS_Futura_Std_Book_11">SCL</samp>
    | <samp class="SANS_Futura_Std_Book_11">SCL</samp> | <samp class="SANS_Futura_Std_Book_11">Digital
    I/O</samp> | <samp class="SANS_Futura_Std_Book_11">D3</samp> | <samp class="SANS_Futura_Std_Book_11">IO25</samp>
    |'
  id: totrans-26
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_Futura_Std_Book_11">I</samp><samp class="SANS_Futura_Std_Book_SUP_11">2</samp><samp
    class="SANS_Futura_Std_Book_11">C 时钟</samp> | <samp class="SANS_Futura_Std_Book_11">SCL</samp>
    | <samp class="SANS_Futura_Std_Book_11">SCL</samp> | <samp class="SANS_Futura_Std_Book_11">数字
    I/O</samp> | <samp class="SANS_Futura_Std_Book_11">D3</samp> | <samp class="SANS_Futura_Std_Book_11">IO25</samp>
    |'
- en: '| <samp class="SANS_Futura_Std_Book_11">I</samp><samp class="SANS_Futura_Std_Book_SUP_11">2</samp><samp
    class="SANS_Futura_Std_Book_11">C data</samp> | <samp class="SANS_Futura_Std_Book_11">SDA</samp>
    | <samp class="SANS_Futura_Std_Book_11">SDA</samp> | <samp class="SANS_Futura_Std_Book_11">Digital
    I/O</samp> | <samp class="SANS_Futura_Std_Book_11">D2</samp> | <samp class="SANS_Futura_Std_Book_11">IO26</samp>
    |'
  id: totrans-27
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_Futura_Std_Book_11">I</samp><samp class="SANS_Futura_Std_Book_SUP_11">2</samp><samp
    class="SANS_Futura_Std_Book_11">C 数据</samp> | <samp class="SANS_Futura_Std_Book_11">SDA</samp>
    | <samp class="SANS_Futura_Std_Book_11">SDA</samp> | <samp class="SANS_Futura_Std_Book_11">数字
    I/O</samp> | <samp class="SANS_Futura_Std_Book_11">D2</samp> | <samp class="SANS_Futura_Std_Book_11">IO26</samp>
    |'
- en: '| <samp class="SANS_Futura_Std_Book_11">Analog reference</samp> | <samp class="SANS_Futura_Std_Book_11">AREF</samp>
    | <samp class="SANS_Futura_Std_Book_11">RESET</samp> | <samp class="SANS_Futura_Std_Book_11">Digital
    I/O</samp> | <samp class="SANS_Futura_Std_Book_11">D1</samp> | <samp class="SANS_Futura_Std_Book_11">TX
    only</samp> |'
  id: totrans-28
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_Futura_Std_Book_11">模拟参考</samp> | <samp class="SANS_Futura_Std_Book_11">AREF</samp>
    | <samp class="SANS_Futura_Std_Book_11">RESET</samp> | <samp class="SANS_Futura_Std_Book_11">数字
    I/O</samp> | <samp class="SANS_Futura_Std_Book_11">D1</samp> | <samp class="SANS_Futura_Std_Book_11">仅
    TX</samp> |'
- en: '| <samp class="SANS_Futura_Std_Book_11">GND</samp> | <samp class="SANS_Futura_Std_Book_11">GND</samp>
    | <samp class="SANS_Futura_Std_Book_11">GND</samp> | <samp class="SANS_Futura_Std_Book_11">Digital
    I/O</samp> | <samp class="SANS_Futura_Std_Book_11">D0</samp> | <samp class="SANS_Futura_Std_Book_11">RX
    only</samp> |'
  id: totrans-29
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_Futura_Std_Book_11">GND</samp> | <samp class="SANS_Futura_Std_Book_11">GND</samp>
    | <samp class="SANS_Futura_Std_Book_11">GND</samp> | <samp class="SANS_Futura_Std_Book_11">数字
    I/O</samp> | <samp class="SANS_Futura_Std_Book_11">D0</samp> | <samp class="SANS_Futura_Std_Book_11">仅
    RX</samp> |'
- en: '| <samp class="SANS_Futura_Std_Book_11">Digital I/O</samp> | <samp class="SANS_Futura_Std_Book_11">D13</samp>
    | <samp class="SANS_Futura_Std_Book_11">IO18</samp> | <samp class="SANS_Futura_Std_Book_11">Analog
    input</samp> | <samp class="SANS_Futura_Std_Book_11">A5</samp> | <samp class="SANS_Futura_Std_Book_11">IO39</samp>
    |'
  id: totrans-30
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_Futura_Std_Book_11">数字 I/O</samp> | <samp class="SANS_Futura_Std_Book_11">D13</samp>
    | <samp class="SANS_Futura_Std_Book_11">IO18</samp> | <samp class="SANS_Futura_Std_Book_11">模拟输入</samp>
    | <samp class="SANS_Futura_Std_Book_11">A5</samp> | <samp class="SANS_Futura_Std_Book_11">IO39</samp>
    |'
- en: '| <samp class="SANS_Futura_Std_Book_11">Digital I/O</samp> | <samp class="SANS_Futura_Std_Book_11">D12</samp>
    | <samp class="SANS_Futura_Std_Book_11">IO19</samp> | <samp class="SANS_Futura_Std_Book_11">Analog
    input</samp> | <samp class="SANS_Futura_Std_Book_11">A4</samp> | <samp class="SANS_Futura_Std_Book_11">IO36</samp>
    |'
  id: totrans-31
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_Futura_Std_Book_11">数字 I/O</samp> | <samp class="SANS_Futura_Std_Book_11">D12</samp>
    | <samp class="SANS_Futura_Std_Book_11">IO19</samp> | <samp class="SANS_Futura_Std_Book_11">模拟输入</samp>
    | <samp class="SANS_Futura_Std_Book_11">A4</samp> | <samp class="SANS_Futura_Std_Book_11">IO36</samp>
    |'
- en: '| <samp class="SANS_Futura_Std_Book_11">Digital I/O</samp> | <samp class="SANS_Futura_Std_Book_11">D11</samp>
    | <samp class="SANS_Futura_Std_Book_11">IO23</samp> | <samp class="SANS_Futura_Std_Book_11">Analog
    input</samp> | <samp class="SANS_Futura_Std_Book_11">A3</samp> | <samp class="SANS_Futura_Std_Book_11">IO34</samp>
    |'
  id: totrans-32
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_Futura_Std_Book_11">数字 I/O</samp> | <samp class="SANS_Futura_Std_Book_11">D11</samp>
    | <samp class="SANS_Futura_Std_Book_11">IO23</samp> | <samp class="SANS_Futura_Std_Book_11">模拟输入</samp>
    | <samp class="SANS_Futura_Std_Book_11">A3</samp> | <samp class="SANS_Futura_Std_Book_11">IO34</samp>
    |'
- en: '| <samp class="SANS_Futura_Std_Book_11">Digital I/O</samp> | <samp class="SANS_Futura_Std_Book_11">D10</samp>
    | <samp class="SANS_Futura_Std_Book_11">IO5</samp> | <samp class="SANS_Futura_Std_Book_11">Analog
    input</samp> | <samp class="SANS_Futura_Std_Book_11">A2</samp> | <samp class="SANS_Futura_Std_Book_11">IO35</samp>
    |'
  id: totrans-33
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_Futura_Std_Book_11">数字 I/O</samp> | <samp class="SANS_Futura_Std_Book_11">D10</samp>
    | <samp class="SANS_Futura_Std_Book_11">IO5</samp> | <samp class="SANS_Futura_Std_Book_11">模拟输入</samp>
    | <samp class="SANS_Futura_Std_Book_11">A2</samp> | <samp class="SANS_Futura_Std_Book_11">IO35</samp>
    |'
- en: '| <samp class="SANS_Futura_Std_Book_11">Digital I/O</samp> | <samp class="SANS_Futura_Std_Book_11">D9</samp>
    | <samp class="SANS_Futura_Std_Book_11">IO13</samp> | <samp class="SANS_Futura_Std_Book_11">Analog
    input</samp> | <samp class="SANS_Futura_Std_Book_11">A1</samp> | <samp class="SANS_Futura_Std_Book_11">IO4</samp>
    |'
  id: totrans-34
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_Futura_Std_Book_11">数字 I/O</samp> | <samp class="SANS_Futura_Std_Book_11">D9</samp>
    | <samp class="SANS_Futura_Std_Book_11">IO13</samp> | <samp class="SANS_Futura_Std_Book_11">模拟输入</samp>
    | <samp class="SANS_Futura_Std_Book_11">A1</samp> | <samp class="SANS_Futura_Std_Book_11">IO4</samp>
    |'
- en: '| <samp class="SANS_Futura_Std_Book_11">Digital I/O</samp> | <samp class="SANS_Futura_Std_Book_11">D8</samp>
    | <samp class="SANS_Futura_Std_Book_11">IO12</samp> | <samp class="SANS_Futura_Std_Book_11">Analog
    input</samp> | <samp class="SANS_Futura_Std_Book_11">A0</samp> | <samp class="SANS_Futura_Std_Book_11">IO2</samp>
    |'
  id: totrans-35
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_Futura_Std_Book_11">数字 I/O</samp> | <samp class="SANS_Futura_Std_Book_11">D8</samp>
    | <samp class="SANS_Futura_Std_Book_11">IO12</samp> | <samp class="SANS_Futura_Std_Book_11">模拟输入</samp>
    | <samp class="SANS_Futura_Std_Book_11">A0</samp> | <samp class="SANS_Futura_Std_Book_11">IO2</samp>
    |'
- en: '| <samp class="SANS_Futura_Std_Book_11">Digital I/O</samp> | <samp class="SANS_Futura_Std_Book_11">D7</samp>
    | <samp class="SANS_Futura_Std_Book_11">IO14</samp> | <samp class="SANS_Futura_Std_Book_11">Board
    voltage</samp> | <samp class="SANS_Futura_Std_Book_11">IOREF</samp> | <samp class="SANS_Futura_Std_Book_11">IO0</samp>
    |'
  id: totrans-36
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_Futura_Std_Book_11">数字 I/O</samp> | <samp class="SANS_Futura_Std_Book_11">D7</samp>
    | <samp class="SANS_Futura_Std_Book_11">IO14</samp> | <samp class="SANS_Futura_Std_Book_11">板载电压</samp>
    | <samp class="SANS_Futura_Std_Book_11">IOREF</samp> | <samp class="SANS_Futura_Std_Book_11">IO0</samp>
    |'
- en: '| <samp class="SANS_Futura_Std_Book_11">Digital I/O</samp> | <samp class="SANS_Futura_Std_Book_11">D6</samp>
    | <samp class="SANS_Futura_Std_Book_11">IO27</samp> | <samp class="SANS_Futura_Std_Book_11">Reset
    MCU</samp> | <samp class="SANS_Futura_Std_Book_11">RESET</samp> | <samp class="SANS_Futura_Std_Book_11">RESET</samp>
    |'
  id: totrans-37
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_Futura_Std_Book_11">数字 I/O</samp> | <samp class="SANS_Futura_Std_Book_11">D6</samp>
    | <samp class="SANS_Futura_Std_Book_11">IO27</samp> | <samp class="SANS_Futura_Std_Book_11">重置
    MCU</samp> | <samp class="SANS_Futura_Std_Book_11">RESET</samp> | <samp class="SANS_Futura_Std_Book_11">RESET</samp>
    |'
- en: '| <samp class="SANS_Futura_Std_Book_11">Digital I/O</samp> | <samp class="SANS_Futura_Std_Book_11">D5</samp>
    | <samp class="SANS_Futura_Std_Book_11">IO16</samp> | <samp class="SANS_Futura_Std_Book_11">3.3
    V output</samp> | <samp class="SANS_Futura_Std_Book_11">3.3V</samp> | <samp class="SANS_Futura_Std_Book_11">3.3V</samp>
    |'
  id: totrans-38
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_Futura_Std_Book_11">数字 I/O</samp> | <samp class="SANS_Futura_Std_Book_11">D5</samp>
    | <samp class="SANS_Futura_Std_Book_11">IO16</samp> | <samp class="SANS_Futura_Std_Book_11">3.3
    V 输出</samp> | <samp class="SANS_Futura_Std_Book_11">3.3V</samp> | <samp class="SANS_Futura_Std_Book_11">3.3V</samp>
    |'
- en: '| <samp class="SANS_Futura_Std_Book_11">Digital I/O</samp> | <samp class="SANS_Futura_Std_Book_11">D4</samp>
    | <samp class="SANS_Futura_Std_Book_11">IO17</samp> | <samp class="SANS_Futura_Std_Book_11">5
    V output</samp> | <samp class="SANS_Futura_Std_Book_11">5V</samp> | <samp class="SANS_Futura_Std_Book_11">5V</samp>
    |'
  id: totrans-39
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_Futura_Std_Book_11">数字 I/O</samp> | <samp class="SANS_Futura_Std_Book_11">D4</samp>
    | <samp class="SANS_Futura_Std_Book_11">IO17</samp> | <samp class="SANS_Futura_Std_Book_11">5
    V 输出</samp> | <samp class="SANS_Futura_Std_Book_11">5V</samp> | <samp class="SANS_Futura_Std_Book_11">5V</samp>
    |'
- en: '|  |  |  | <samp class="SANS_Futura_Std_Book_11">GND</samp> | <samp class="SANS_Futura_Std_Book_11">GND</samp>
    | <samp class="SANS_Futura_Std_Book_11">GND</samp> |'
  id: totrans-40
  prefs: []
  type: TYPE_TB
  zh: '|  |  |  | <samp class="SANS_Futura_Std_Book_11">GND</samp> | <samp class="SANS_Futura_Std_Book_11">GND</samp>
    | <samp class="SANS_Futura_Std_Book_11">GND</samp> |'
- en: '|  |  |  | <samp class="SANS_Futura_Std_Book_11">GND</samp> | <samp class="SANS_Futura_Std_Book_11">GND</samp>
    | <samp class="SANS_Futura_Std_Book_11">GND</samp> |'
  id: totrans-41
  prefs: []
  type: TYPE_TB
  zh: '|  |  |  | <samp class="SANS_Futura_Std_Book_11">GND</samp> | <samp class="SANS_Futura_Std_Book_11">GND</samp>
    | <samp class="SANS_Futura_Std_Book_11">GND</samp> |'
- en: '|  |  |  | <samp class="SANS_Futura_Std_Book_11">Raw voltage in</samp> | <samp
    class="SANS_Futura_Std_Book_11">Vin</samp> | <samp class="SANS_Futura_Std_Book_11">Vin</samp>
    |'
  id: totrans-42
  prefs: []
  type: TYPE_TB
  zh: '|  |  |  | <samp class="SANS_Futura_Std_Book_11">原始电压输入</samp> | <samp class="SANS_Futura_Std_Book_11">Vin</samp>
    | <samp class="SANS_Futura_Std_Book_11">Vin</samp> |'
- en: ESP32 pins labeled IO*xx* are (3.3 V) digital input and output pins. When addressing
    these pins in your Arduino sketches, don’t include the IO, just use the number.
    I’ll demonstrate that shortly.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: ESP32 上标记为 IO*xx* 的引脚是（3.3 V）数字输入和输出引脚。在 Arduino 草图中引用这些引脚时，不需要包含 IO，只需使用数字编号。我很快会演示这一点。
- en: <samp class="SANS_Dogma_OT_Bold_B_21">NOTE</samp>
  id: totrans-44
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: <samp class="SANS_Dogma_OT_Bold_B_21">注意</samp>
- en: '*Port manipulation doesn’t work with the ESP32 board. Pins may also have other
    functions beyond those shown in the table, but for the purposes of the projects
    in this chapter, you’ll use only the functions shown in the table.*'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: '*端口操作在 ESP32 板上无法使用。引脚可能还具有表格中未显示的其他功能，但对于本章中的项目，你只会使用表格中显示的功能。*'
- en: <samp class="SANS_Futura_Std_Bold_B_11">Configuring the Arduino IDE for the
    ESP32</samp>
  id: totrans-46
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">为 ESP32 配置 Arduino IDE</samp>
- en: The Arduino IDE doesn’t come with the ESP32 boards preinstalled, so you’ll need
    to install the required files. With your ESP32 on hand, open the Arduino IDE and
    select **File** ![](../images/arr.png) **Preferences**. When the Preferences dialog
    appears, click the small button next to the Additional Boards Manager URLs field,
    and the Additional Boards Manager URLs dialog should appear, as shown in [Figure
    19-4](chapter19.xhtml#fig19-4).
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: Arduino IDE 默认没有预装 ESP32 板，因此你需要安装所需的文件。拿起你的 ESP32，打开 Arduino IDE，选择 **文件**
    ![](../images/arr.png) **首选项**。当首选项对话框出现时，点击附加板管理器 URL 字段旁的小按钮，附加板管理器 URL 对话框应该会出现，如
    [图 19-4](chapter19.xhtml#fig19-4) 所示。
- en: '![AN IMAGE OF ADDING THE BOARD PROFILES IN ARDUINO IDE](../images/fig19-4.png)'
  id: totrans-48
  prefs: []
  type: TYPE_IMG
  zh: '![添加板卡配置的 Arduino IDE 图片](../images/fig19-4.png)'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 19-4: The Arduino IDE
    Additional Boards Manager URLs dialog</samp>'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">图 19-4：Arduino IDE 附加板管理器 URL
    对话框</samp>
- en: 'Enter the following URL into the dialog:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 在对话框中输入以下 URL：
- en: '[PRE0]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: If you already have other URLs in the dialog, place a comma at the end of the
    last URL and paste the new one after the comma.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 如果对话框中已经有其他 URL，在最后一个 URL 后添加逗号，并将新 URL 粘贴到逗号后面。
- en: Click **OK** to close the Preferences dialog. Now close and reopen the IDE.
    If your computer is not connected to the internet, connect it now. Select **Tools**
    ![](../images/arr.png) **Boards Manager**. When the Boards Manager opens, enter
    **ESP32** in the search dialog. The ESP32 package should appear. Always use the
    latest version available.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 点击**确定**关闭首选项对话框。现在关闭并重新打开IDE。如果你的电脑未连接到互联网，请现在连接。选择**工具** ![](../images/arr.png)
    **板管理器**。打开板管理器后，在搜索框中输入**ESP32**。ESP32软件包应显示在列表中。请始终使用最新版本。
- en: Click **Install** and wait a few moments for the process to complete, as shown
    in the progress bar at the bottom of the Boards Manager dialog.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 点击**安装**并等待片刻，直到进度条显示过程完成，如“板管理器”对话框底部所示。
- en: Since the ESP32 uses the CH340 USB-to-serial interface, which differs from that
    used on an Arduino Uno or compatible board, you’ll need to install drivers for
    the interface for your computer. To do this, follow the guide provided by SparkFun
    at [*https://<wbr>learn<wbr>.sparkfun<wbr>.com<wbr>/tutorials<wbr>/how<wbr>-to<wbr>-install<wbr>-ch340<wbr>-drivers<wbr>/all*](https://learn.sparkfun.com/tutorials/how-to-install-ch340-drivers/all).
    Once you’ve installed the driver, connect your ESP32 dev board to the PC via a
    USB cable.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 由于ESP32使用的是与Arduino Uno或兼容板不同的CH340 USB到串口接口，你需要为计算机安装相应的驱动程序。为此，请按照SparkFun提供的指南，访问
    [*https://<wbr>learn<wbr>.sparkfun<wbr>.com<wbr>/tutorials<wbr>/how<wbr>-to<wbr>-install<wbr>-ch340<wbr>-drivers<wbr>/all*](https://learn.sparkfun.com/tutorials/how-to-install-ch340-drivers/all)。安装驱动程序后，通过USB线将ESP32开发板连接到PC。
- en: If you don’t already have the latest version of Python on your PC, you’ll also
    need to download and install it, since the Arduino IDE requires it as part of
    the toolchain to upload code to an ESP32 board. If necessary, visit [*https://<wbr>www<wbr>.python<wbr>.org<wbr>/downloads*](https://www.python.org/downloads)
    and follow the links for your operating system and install.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你的电脑上还没有安装最新版本的Python，你还需要下载并安装它，因为Arduino IDE需要它作为工具链的一部分，以便将代码上传到ESP32板。如果需要，请访问
    [*https://<wbr>www<wbr>.python<wbr>.org<wbr>/downloads*](https://www.python.org/downloads)，根据你的操作系统选择并安装。
- en: 'After installing Python, macOS users may need to open the terminal and run
    the following command before re-opening the Arduino IDE:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 安装完Python后，macOS用户可能需要打开终端并运行以下命令，然后再重新打开Arduino IDE：
- en: '[PRE1]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Now open the Arduino IDE, select **Tools**, and change all the settings from
    Board onward to match those shown in [Figure 19-5](chapter19.xhtml#fig19-5).
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 现在打开Arduino IDE，选择**工具**，并将所有设置从板开始更改为与[图19-5](chapter19.xhtml#fig19-5)中所示的设置相匹配。
- en: '![AN IMAGE OF THE ESP32 SETTINGS MENU IN IDE](../images/fig19-5.png)'
  id: totrans-60
  prefs: []
  type: TYPE_IMG
  zh: '![IDE中的ESP32设置菜单图片](../images/fig19-5.png)'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 19-5: Board settings
    in Arduino IDE for the ESP32</samp>'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">图19-5：Arduino IDE中的ESP32板设置</samp>
- en: The only parameter that may vary on your computer is the USB port; select the
    appropriate port shown in that option.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 唯一可能因你的计算机而有所不同的参数是USB端口；请选择显示的适当端口。
- en: <samp class="SANS_Futura_Std_Bold_B_11">Testing the ESP32</samp>
  id: totrans-63
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">测试ESP32</samp>
- en: Before moving on to the first project of the chapter, test the dev board to
    check you can upload a sketch, operate GPIO pins, and operate your Wi-Fi.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 在开始本章第一个项目之前，先测试开发板，确保你可以上传草图，操作GPIO引脚，并连接Wi-Fi。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">The GPIO Pins</samp>
  id: totrans-65
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">GPIO引脚</samp>
- en: 'First, try controlling some GPIO pins by building the classic test circuit
    that blinks some LEDs. You will need the following:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，尝试通过构建经典的测试电路来控制一些GPIO引脚，电路会闪烁一些LED灯。你需要以下材料：
- en: An ESP32 dev board and matching USB cable
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一块ESP32开发板和匹配的USB电缆
- en: A solderless breadboard
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一块无焊面包板
- en: Assorted jumper wires
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 各种跳线
- en: Four LEDs
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 四个LED灯
- en: One 560 Ω, 0.25 W, 1 percent resistor
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个560 Ω，0.25 W，1% 的电阻器
- en: Assemble the circuit as shown in [Figure 19-6](chapter19.xhtml#fig19-6).
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 按照[图19-6](chapter19.xhtml#fig19-6)中的示意图组装电路。
- en: '![THE SCHEMATIC FOR TESTING LISTING 19-1](../images/fig19-6.png)'
  id: totrans-73
  prefs: []
  type: TYPE_IMG
  zh: '![测试电路图19-1](../images/fig19-6.png)'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 19-6: A basic four-LED
    circuit for testing purposes.</samp>'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">图19-6：一个用于测试目的的基本四LED电路。</samp>
- en: Now enter and upload [Listing 19-1](#LiT-19-1) to your ESP32 dev board. A moment
    after uploading the sketch, each LED should turn on and off in turn.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 现在输入并上传[列出19-1](#LiT-19-1)到你的ESP32开发板。上传草图后，片刻之内，每个LED灯应该依次打开和关闭。
- en: '[PRE2]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 19-1: Testing outputs
    from the ESP32 dev board</samp>'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">清单19-1：测试来自ESP32开发板的输出</samp>
- en: Although the hardware descriptions for the GPIO pins are IO*xx*, as shown in
    [Table 19-1](chapter19.xhtml#tab19-1), the sketch references the pins by just
    their numerical part identifiers when setting up the GPIO pin status ❶ and addressing
    them to turn on and off ❷ ❸.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管GPIO引脚的硬件描述是IO*xx*，如[表19-1](chapter19.xhtml#tab19-1)所示，但草图在设置GPIO引脚状态❶并控制它们的开关❷❸时，仅通过其数字标识符来引用引脚。
- en: If your sketch didn’t upload, check the settings for the board type and parameters
    as described in the previous section. Once you’ve finished this test, keep the
    circuit assembled, as you’ll use it for the following projects.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你的草图没有上传，检查之前章节中描述的板卡类型和参数设置。完成此测试后，请保持电路组装，因为你将在接下来的项目中使用它。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">The Wi-Fi Connectivity</samp>
  id: totrans-80
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Wi-Fi连接性</samp>
- en: You’ll now test the ESP32’s Wi-Fi connectivity, using the WiFiScan sketch included
    with the ESP32 board profile that scans for the existence of Wi-Fi networks in
    your immediate vicinity.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 你现在将测试ESP32的Wi-Fi连接性，使用ESP32开发板配置文件中包含的WiFiScan草图，该草图会扫描你周围的Wi-Fi网络。
- en: You won’t need any extra hardware beyond the board, the USB cable, and a Wi-Fi
    network. Upload the sketch from the IDE’s examples via **File** ![](../images/arr.png)
    **Examples** ![](../images/arr.png) **WiFi** ![](../images/arr.png) **WiFiScan**,
    then open the Serial Monitor in the Arduino IDE. After a few moments, the board
    should search for the existence of Wi-Fi access points and list them, along with
    their signal strength, as shown in [Figure 19-7](chapter19.xhtml#fig19-7).
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 你无需额外的硬件，除了开发板、USB线和Wi-Fi网络。通过IDE的示例上传草图，路径为**文件** ![](../images/arr.png) **示例**
    ![](../images/arr.png) **WiFi** ![](../images/arr.png) **WiFiScan**，然后在Arduino
    IDE中打开串行监视器。过一会儿，开发板应该会搜索Wi-Fi接入点的存在，并列出它们以及信号强度，如[图19-7](chapter19.xhtml#fig19-7)所示。
- en: '![AN IMAGE OF THE OUTPUT PRODUCED WHEN SCANNING FOR NEW WI-FI NETWORKS](../images/fig19-7.png)'
  id: totrans-83
  prefs: []
  type: TYPE_IMG
  zh: '![扫描新Wi-Fi网络时产生的输出图像](../images/fig19-7.png)'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 19-7: Example results
    of scanning for Wi-Fi access points</samp>'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">图19-7：扫描Wi-Fi接入点的示例结果</samp>
- en: The Serial Monitor simply shows the access point names, not whether the connection
    is open. If you’d like more information on the meaning of the signal strength,
    visit [*https://<wbr>en<wbr>.wikipedia<wbr>.org<wbr>/wiki<wbr>/Received<wbr>_signal<wbr>_strength<wbr>_indication*](https://en.wikipedia.org/wiki/Received_signal_strength_indication).
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 串行监视器仅显示接入点的名称，而不显示连接是否开放。如果你想了解信号强度的含义，可以访问[*https://<wbr>en<wbr>.wikipedia<wbr>.org<wbr>/wiki<wbr>/Received<wbr>_signal<wbr>_strength<wbr>_indication*](https://en.wikipedia.org/wiki/Received_signal_strength_indication)获取更多信息。
- en: <samp class="SANS_Futura_Std_Bold_B_11">Port Forwarding</samp>
  id: totrans-86
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">端口转发</samp>
- en: To control your project from a device that isn’t connected to your local network,
    such as a tablet or phone using a cellular connection that doesn’t have a static
    IP address, you’ll need to use a technique called *port forwarding* in your network
    router or modem. Port forwarding gives you a static IP address from an external
    provider that then diverts data directly to your device.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 若要从未连接到本地网络的设备（如通过蜂窝连接的平板电脑或手机）控制你的项目，并且这些设备没有静态IP地址，你需要使用一种叫做*端口转发*的技术，这需要在你的网络路由器或调制解调器中设置。端口转发可以从外部提供商获取静态IP地址，然后将数据直接转发到你的设备。
- en: Port forwarding services are provided by organizations such as No-IP ([*https://<wbr>www<wbr>.noip<wbr>.com*](https://www.noip.com))
    and Dyn ([*https://<wbr>account<wbr>.dyn<wbr>.com*](https://account.dyn.com)).
    Setup is often unique to the make and model of your router, so do an internet
    search for *router port forwarding* for your model of router. Alternatively, you
    could ask your ISP, if it provided the router, or visit a tutorial site such as
    [*http://<wbr>www<wbr>.wikihow<wbr>.com<wbr>/Port<wbr>-Forward*](http://www.wikihow.com/Port-Forward)
    for more information.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 端口转发服务由一些组织提供，如No-IP（[*https://<wbr>www<wbr>.noip<wbr>.com*](https://www.noip.com)）和Dyn（[*https://<wbr>account<wbr>.dyn<wbr>.com*](https://account.dyn.com)）。设置通常与路由器的品牌和型号有关，因此可以在互联网上搜索你的路由器型号的*路由器端口转发*。另外，你也可以向提供路由器的ISP咨询，或者访问如[*http://<wbr>www<wbr>.wikihow<wbr>.com<wbr>/Port<wbr>-Forward*](http://www.wikihow.com/Port-Forward)的教程网站获取更多信息。
- en: Once you’ve set up port forwarding or otherwise confirmed your static IP address,
    you’re ready to start building a framework for remote-control applications. However,
    if you can’t organize port forwarding, you can still control your projects from
    your local-area Wi-Fi network.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你设置了端口转发或以其他方式确认了静态 IP 地址，你就可以开始构建远程控制应用程序的框架了。不过，如果你无法设置端口转发，你仍然可以通过本地 Wi-Fi
    网络控制你的项目。
- en: '<samp class="SANS_Futura_Std_Heavy_B_21">Project #55: Remote-Controlling a
    Single GPIO Pin</samp>'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: '<samp class="SANS_Futura_Std_Heavy_B_21">项目 #55：远程控制单个 GPIO 引脚</samp>'
- en: In this project, you’ll remotely control a GPIO pin on your ESP32 dev board
    via any device with a web browser. This includes building a simple web page hosted
    by the ESP32 using HTML and CSS. You can then use this page to control anything
    you normally would control with an Arduino 3.3 V (or 5 V with a level converter)
    digital output, such as a relay, MOSFET, LED, or so on.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个项目中，你将通过任何带有网页浏览器的设备远程控制你的 ESP32 开发板上的 GPIO 引脚。这包括使用 HTML 和 CSS 构建一个由 ESP32
    托管的简单网页。然后，你可以使用这个网页控制任何通常用 Arduino 3.3 V（或通过电平转换器转换为 5 V）数字输出控制的设备，例如继电器、MOSFET、LED
    等。
- en: 'For the hardware, use the circuit for testing the GPIO pins described in the
    previous section. Enter and upload the Project #55 sketch to your ESP32 dev board.
    Don’t forget to update your Wi-Fi network credentials in the sketch before uploading.
    A moment after that, open the Serial Monitor in the Arduino IDE to watch the ESP32’s
    progress as it connects to the Wi-Fi network. The sketch should then display your
    project’s IP address, as shown in [Figure 19-8](chapter19.xhtml#fig19-8).'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: '对于硬件，使用前一节中描述的 GPIO 引脚测试电路。输入并上传项目 #55 的草图到你的 ESP32 开发板。在上传之前，别忘了在草图中更新你的 Wi-Fi
    网络凭证。上传后，稍等片刻，打开 Arduino IDE 中的串口监视器，观察 ESP32 连接 Wi-Fi 网络的过程。草图应该显示你项目的 IP 地址，如[图
    19-8](chapter19.xhtml#fig19-8)所示。'
- en: '![AN IMAGE OF THE OUTPUT FROM THE ESP32 ONCE CONNECTED TO A WI-FI NETWORK](../images/fig19-8.png)'
  id: totrans-93
  prefs: []
  type: TYPE_IMG
  zh: '![ESP32 连接到 Wi-Fi 网络后的输出图像](../images/fig19-8.png)'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 19-8: The Serial Monitor
    showing that the ESP32 has connected to the Wi-Fi network</samp>'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">图 19-8：串口监视器显示 ESP32 已连接到 Wi-Fi
    网络</samp>
- en: Next, using the web browser on a web-enabled device, visit the IP address shown
    in the Serial Monitor. You should see the simple web page hosted by the ESP32
    dev board, as shown in [Figure 19-9](chapter19.xhtml#fig19-9).
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，使用带有网页浏览器的设备，访问串口监视器中显示的 IP 地址。你应该能看到由 ESP32 开发板托管的简单网页，如[图 19-9](chapter19.xhtml#fig19-9)所示。
- en: '![<<AN IMAGE OF THE WEB PAGE INTERFACE FOR PROJECT #55](../images/fig19-9.png)'
  id: totrans-96
  prefs: []
  type: TYPE_IMG
  zh: '![<<项目 #55 网页接口的图像](../images/fig19-9.png)'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 19-9: A remote-control
    web page</samp>'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">图 19-9：远程控制网页</samp>
- en: 'When you click the On or Off buttons, the LED connected to GPIO 16 should turn
    on and off. For this project, the ESP32 dev board has two jobs: to act as a web
    server that hosts the simple web page for the user interface (including the On/Off
    buttons) and to respond to HTML requests from the web browser (to turn the GPIO
    pin on and off).'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 当你点击开（On）或关（Off）按钮时，连接到 GPIO 16 的 LED 应该会开关。在这个项目中，ESP32 开发板有两个任务：一是作为网页服务器托管用户界面的简单网页（包括开/关按钮），二是响应网页浏览器的
    HTML 请求（打开或关闭 GPIO 引脚）。
- en: 'Let’s take a closer look at how this works:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更详细地了解一下它是如何工作的：
- en: '[PRE3]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: First, the sketch includes the Arduino Wi-Fi library ❶ and creates an instance
    of a server with a port of 80\. Following this, it stores the SSID (Wi-Fi access
    point name) and password in the respective fields. It declares a string variable
    to contain the text of the HTTP request from the client (the web browser displaying
    the project’s web page) and then sets the GPIO pin it will control.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，草图包含了 Arduino Wi-Fi 库 ❶，并创建了一个端口为 80 的服务器实例。接下来，它将 SSID（Wi-Fi 接入点名称）和密码存储在相应的字段中。它声明了一个字符串变量，用来存储来自客户端（显示项目网页的网页浏览器）的
    HTTP 请求文本，然后设置它将控制的 GPIO 引脚。
- en: The sketch then declares variables to take care of the connection time allowed
    for each client to the server (the ESP32 dev board) ❷. In <samp class="SANS_TheSansMonoCd_W5Regular_11">void
    setup()</samp>, it configures the Serial Monitor and then sets GPIO16 as an output
    and to LOW. The ESP32 attempts to connect to the Wi-Fi network using the credentials
    entered earlier, with the code looping and displaying a tilde (<samp class="SANS_TheSansMonoCd_W5Regular_11">~</samp>)
    every half second until the network connection is successful. Once the ESP32 has
    made a Wi-Fi connection, the sketch displays the IP address in the Serial Monitor
    and the project begins to operate as a web server, thanks to <samp class="SANS_TheSansMonoCd_W5Regular_11">server.begin()</samp>.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 草图接着声明了变量来处理每个客户端与服务器（ESP32 开发板）连接时允许的时间 ❷。在 <samp class="SANS_TheSansMonoCd_W5Regular_11">void
    setup()</samp> 中，它配置了串口监视器，然后将 GPIO16 设置为输出并拉低。ESP32 使用之前输入的凭据尝试连接 Wi-Fi 网络，代码会每半秒循环一次并显示波浪线
    (<samp class="SANS_TheSansMonoCd_W5Regular_11">~</samp>)，直到网络连接成功。一旦 ESP32 成功连接到
    Wi-Fi，草图将在串口监视器中显示 IP 地址，项目也开始作为一个网页服务器运行，这都得益于 <samp class="SANS_TheSansMonoCd_W5Regular_11">server.begin()</samp>。
- en: The ESP32 now runs the code in <samp class="SANS_TheSansMonoCd_W5Regular_11">void
    loop()</samp> until a reset or removal of power. Each loop begins by checking
    to see if a client (a person using a web browser) is trying to connect to the
    project ❸. If so, the code takes note of the point in time at which the connection
    starts using the <samp class="SANS_TheSansMonoCd_W5Regular_11">millis()</samp>
    function to allow each individual client to connect to the ESP32 for only up to
    two seconds (as set with <samp class="SANS_TheSansMonoCd_W5Regular_11">timeoutTime</samp>).
    This is because other users may want access as well—you don’t want one person
    hogging access to the project. The code also empties the string variable <samp
    class="SANS_TheSansMonoCd_W5Regular_11">currentLine</samp>, awaiting text from
    the client.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: ESP32 接下来会运行 <samp class="SANS_TheSansMonoCd_W5Regular_11">void loop()</samp>
    中的代码，直到重置或断电。每次循环开始时，代码会检查是否有客户端（使用网页浏览器的人）尝试连接到项目 ❸。如果是，代码会记录连接开始的时间点，使用 <samp
    class="SANS_TheSansMonoCd_W5Regular_11">millis()</samp> 函数，以确保每个客户端最多连接到 ESP32
    两秒钟（如 <samp class="SANS_TheSansMonoCd_W5Regular_11">timeoutTime</samp> 设置的时间）。这是因为其他用户也可能想要访问，你不希望某一个人占用项目的访问权限。代码还会清空字符串变量
    <samp class="SANS_TheSansMonoCd_W5Regular_11">currentLine</samp>，等待客户端发送的文本。
- en: If the client has been connected for less than 2,000 milliseconds and has made
    a request, the ESP32 receives it. The code feeds the <samp class="SANS_TheSansMonoCd_W5Regular_11">currentTime</samp>
    variable with the latest value of <samp class="SANS_TheSansMonoCd_W5Regular_11">millis()</samp>.
    The string request receives the client request ❹, one character at a time. This
    request is displayed on the Serial Monitor so that, if you’re curious, you can
    see the information the client sends out (browser type, device operating system,
    and so on). Once the client has finished sending the request, as denoted by a
    newline character (<samp class="SANS_TheSansMonoCd_W5Regular_11">\n</samp>), the
    ESP32 sends a response in HTML back to the client browser. To do so, it uses <samp
    class="SANS_TheSansMonoCd_W5Regular_11">client.println()</samp> functions, which
    send the text out via the Wi-Fi connection in the same way you may use <samp class="SANS_TheSansMonoCd_W5Regular_11">Serial.println()</samp>
    in other projects.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 如果客户端连接时间少于 2000 毫秒并已发出请求，ESP32 会接收到该请求。代码将最新的 <samp class="SANS_TheSansMonoCd_W5Regular_11">millis()</samp>
    值赋给 <samp class="SANS_TheSansMonoCd_W5Regular_11">currentTime</samp> 变量。字符串请求按一个字符接收客户端请求
    ❹。该请求会显示在串口监视器中，以便你如果好奇的话，可以查看客户端发送的信息（浏览器类型、设备操作系统等）。一旦客户端完成发送请求，并以换行符 (<samp
    class="SANS_TheSansMonoCd_W5Regular_11">\n</samp>) 标记，ESP32 就会以 HTML 格式向客户端浏览器发送响应。为此，它使用
    <samp class="SANS_TheSansMonoCd_W5Regular_11">client.println()</samp> 函数，通过 Wi-Fi
    连接发送文本，就像你在其他项目中使用 <samp class="SANS_TheSansMonoCd_W5Regular_11">Serial.println()</samp>
    一样。
- en: The ESP32 can finally act on the client request and take an action. Client requests
    are received in the form <samp class="SANS_TheSansMonoCd_W5Regular_11">/16/on</samp>
    or <samp class="SANS_TheSansMonoCd_W5Regular_11">/16/off</samp>, so the string
    request is searched in turn for an on command ❺ and acted upon by sending this
    to the Serial Monitor and then turning GPIO16 on; if an off command is received,
    the opposite occurs ❻. This is the point where you can modify the actions to suit
    your own purposes. This project simply calls a <samp class="SANS_TheSansMonoCd_W5Regular_11">digitalWrite()</samp>
    function, and you can replace this with your own function to have the ESP32 take
    an action of your own choosing.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: ESP32 最终可以响应客户端请求并执行操作。客户端请求以 <samp class="SANS_TheSansMonoCd_W5Regular_11">/16/on</samp>
    或 <samp class="SANS_TheSansMonoCd_W5Regular_11">/16/off</samp> 的形式接收，因此该字符串请求会依次搜索开启命令
    ❺ 并执行，通过将其发送到串口监视器并打开 GPIO16；如果收到关闭命令，则会发生相反的操作 ❻。这是你可以根据自己的需要修改操作的地方。这个项目只是调用了一个
    <samp class="SANS_TheSansMonoCd_W5Regular_11">digitalWrite()</samp> 函数，你可以用自己的函数替换它，让
    ESP32 执行你自己选择的操作。
- en: The final section of the code enables ESP32 to host the simple web page that
    is the user interface shown in [Figure 19-10](chapter19.xhtml#fig19-10). Using
    many <samp class="SANS_TheSansMonoCd_W5Regular_11">client.println()</samp> functions,
    the code creates HTML that creates the framework for a web page, defines using
    CSS the buttons to be displayed, positions the buttons, and sends HTML to define
    the end of the web page. Once the client request is complete, the sketch flushes
    the request from the variable ❼ and closes the connection, ready for the next
    user.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 代码的最后一部分使 ESP32 托管了简单的网页，即用户界面，如 [图 19-10](chapter19.xhtml#fig19-10) 所示。通过多个
    <samp class="SANS_TheSansMonoCd_W5Regular_11">client.println()</samp> 函数，代码生成
    HTML，创建网页的框架，使用 CSS 定义要显示的按钮，定位按钮，并发送 HTML 来定义网页的结束。一旦客户端请求完成，草图会从变量中刷新请求 ❼ 并关闭连接，为下一个用户做好准备。
- en: 'Let’s take a closer look at the HTML contained in the <samp class="SANS_TheSansMonoCd_W5Regular_11">client.println()</samp>
    functions:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们仔细看看 `<samp class="SANS_TheSansMonoCd_W5Regular_11">client.println()</samp>`
    函数中包含的 HTML：
- en: '[PRE4]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'This code uses CSS to select the color, size, font size, and rounded edges
    of the web interface’s buttons ❶, with the heading displayed in a larger type
    ❷. It then adds the two buttons to the web page. Each button has a hyperlink to
    its respective operation attached: the first link is <samp class="SANS_TheSansMonoCd_W5Regular_11">/16/on</samp>
    ❸, and the second is <samp class="SANS_TheSansMonoCd_W5Regular_11">/16/off</samp>
    ❹. When the user clicks either of the buttons, the client request will consist
    of the IP address of the ESP32, followed by */16/on*—for example, *http://<wbr>192<wbr>.168<wbr>.20<wbr>.28<wbr>/16<wbr>/on*.'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码使用 CSS 来选择网页界面按钮的颜色、大小、字体大小和圆角 ❶，并将标题显示为更大的字体 ❷。然后，它将两个按钮添加到网页中。每个按钮都附有一个指向其各自操作的超链接：第一个链接是
    <samp class="SANS_TheSansMonoCd_W5Regular_11">/16/on</samp> ❸，第二个是 <samp class="SANS_TheSansMonoCd_W5Regular_11">/16/off</samp>
    ❹。当用户点击其中任何一个按钮时，客户端请求将包括 ESP32 的 IP 地址，后跟 */16/on*——例如 *http://<wbr>192<wbr>.168<wbr>.20<wbr>.28<wbr>/16<wbr>/on*。
- en: If you hover your mouse over the button on the web page, the link should appear
    at the bottom of the screen. For example, [Figure 19-10](chapter19.xhtml#fig19-10)
    shows what happens when the mouse hovers over the On button. (The URL in the browser
    tab at the top is for the last page I visited, the result of clicking the Off
    button.)
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你将鼠标悬停在网页上的按钮上，链接应该会出现在屏幕底部。例如，[图 19-10](chapter19.xhtml#fig19-10) 显示了当鼠标悬停在开启按钮上时的情况。（浏览器标签页顶部的
    URL 是我上次访问页面的地址，点击关闭按钮后的结果。）
- en: '![AN IMAGE OF THE HYPERLINK DISPLAYED IN THE WEB BROWSER](../images/fig19-10.png)'
  id: totrans-111
  prefs: []
  type: TYPE_IMG
  zh: '![网页浏览器中显示的超链接的图像](../images/fig19-10.png)'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 19-10: Example hyperlink
    displayed in the browser</samp>'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">图 19-10：在浏览器中显示的示例超链接</samp>
- en: When installing a project on a more permanent basis, the end user can also bookmark
    the full URL for each function. For example, if the IP address returned by the
    project is 192.168.20.28, the bookmark to turn on would be *http://<wbr>192<wbr>.168<wbr>.20<wbr>.28<wbr>/16<wbr>/on*.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 当在较为永久的基础上安装项目时，最终用户也可以为每个功能添加完整的 URL 书签。例如，如果项目返回的 IP 地址是 192.168.20.28，则需要打开的书签为
    *http://<wbr>192<wbr>.168<wbr>.20<wbr>.28<wbr>/16<wbr>/on*。
- en: Be warned that anyone who has the URL address for this type of project can operate
    the controls. For increased security, you might create a secure website or portal
    that password-protects access to the control buttons.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，任何拥有此类型项目的URL地址的人都可以操作控制按钮。为了提高安全性，你可以创建一个安全的网站或门户，设置密码保护以限制对控制按钮的访问。
- en: '<samp class="SANS_Futura_Std_Heavy_B_21">Project #56: Remote-Controlling Four
    GPIO Pins</samp>'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Heavy_B_21">项目#56：远程控制四个GPIO引脚</samp>
- en: This project builds on the previous project by allowing you to remotely control
    four GPIO pins, displaying their status on the web page hosted by the ESP32\.
    Users can then quickly review the status of the devices under control, which is
    ideal for truly remote-controlled projects.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 这个项目基于之前的项目，允许你远程控制四个GPIO引脚，并在ESP32主机托管的网页上显示其状态。用户可以快速查看被控制设备的状态，这对于真正的远程控制项目非常理想。
- en: 'You’ll use the same demonstration circuit described in “The GPIO Pins” on page
    326 (this is why it includes four LEDs). Once you’ve set up that circuit, enter
    and upload the Project #56 sketch to your ESP32 dev board. A moment after that,
    open the Serial Monitor in the Arduino IDE to watch as the ESP32 connects to the
    Wi-Fi network.'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 你将使用与“GPIO引脚”一节中描述的相同演示电路（这就是为什么它包括四个LED）。设置好电路后，输入并上传项目#56的草图到你的ESP32开发板。上传后不久，打开Arduino
    IDE中的串口监视器，观察ESP32如何连接到Wi-Fi网络。
- en: Once the ESP32 connects, the IP address of the project should appear in the
    Serial Monitor. Enter that IP address into a web browser and the interface for
    this project should appear, as shown in [Figure 19-11](chapter19.xhtml#fig19-11).
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦ESP32连接，项目的IP地址应出现在串口监视器中。将该IP地址输入到网页浏览器中，项目的界面应显示出来，如[图19-11](chapter19.xhtml#fig19-11)所示。
- en: '![AN IMAGE OF THE WEB CONTROL INTERFACE FOR PROJECT #56>, SHOWING ALL FOUR
    OUTPUTS ARE OFF](../images/fig19-11.png)'
  id: totrans-119
  prefs: []
  type: TYPE_IMG
  zh: '![项目#56的网页控制界面图像，显示所有四个输出均为关闭状态](../images/fig19-11.png)'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 19-11: The user interface
    for Project #56</samp>'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">图19-11：项目#56的用户界面</samp>
- en: You should be able to control all four LEDs by clicking their respective buttons.
    After each button click, the web page should also indicate the state of the linked
    LED. For example, [Figure 19-12](chapter19.xhtml#fig19-12) shows that outputs
    2 and 4 are on.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该能够通过点击相应按钮控制所有四个LED。每次点击按钮后，网页应显示已连接LED的状态。例如，[图19-12](chapter19.xhtml#fig19-12)显示输出2和4已开启。
- en: '![AN IMAGE OF THE WEB CONTROL INTERFACE FOR PROJECT #56, SHOWING OUTPUTS 1
    AND 3 ARE OFF AND 2 AND 4 ARE ON](../images/fig19-12.png)'
  id: totrans-122
  prefs: []
  type: TYPE_IMG
  zh: '![项目#56的网页控制界面图像，显示输出1和3关闭，2和4开启](../images/fig19-12.png)'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 19-12: Outputs 2 and
    4 are on, while 1 and 3 are off.</samp>'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">图19-12：输出2和4已开启，而1和3关闭。</samp>
- en: You can imagine how much more useful this is to have four sets of buttons, enabling
    control of more relays, outputs, devices controlled by MOSFETs, and so on.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以想象，拥有四组按钮，能够控制更多的继电器、输出、由MOSFET控制的设备等，这将变得多么有用。
- en: 'Let’s take a closer look to see how this works:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们仔细看看它是如何工作的：
- en: '[PRE5]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The framework for this project is the same as that of the previous project,
    except that it controls four GPIOs and eight buttons while keeping track of the
    GPIO status. The sketch uses four string variables to store the status of the
    four GPIO pins in text form, On or Off, declaring them with a default value of
    Off ❶. To save confusion, the sketch also declares variables to give each GPIO
    pin a name instead of a number in the code ❷. It then sets the pins as outputs
    and to LOW ❸.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 这个项目的框架与之前的项目相同，唯一不同的是它控制四个GPIO引脚和八个按钮，并跟踪GPIO的状态。这个草图使用了四个字符串变量来存储四个GPIO引脚的状态，以文本形式表示“开”或“关”，并声明它们的默认值为“关”❶。为了避免混淆，草图还声明了变量，为每个GPIO引脚指定一个名称，而不是在代码中使用数字❷。然后，它将引脚设置为输出，并设定为LOW❸。
- en: As there are now eight buttons and eight matching actions (on and off for each
    of the four GPIOs), there are eight client requests to look out for ❹. After each
    action has taken place, the status of the matching GPIO is updated in its matching
    state variable ❺. This occurs for all eight client request types.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 由于现在有八个按钮和八个相应的操作（每个GPIO的开与关），需要注意八个客户端请求❹。每次操作完成后，匹配GPIO的状态将在其相应的状态变量中更新❺。这对所有八种客户端请求类型都适用。
- en: Once again, the code uses many <samp class="SANS_TheSansMonoCd_W5Regular_11">client.println()</samp>
    functions to create the HTML for the user interface. Functions like the one at
    ❻ in the project code generate the HTML required to display the status of each
    GPIO pin. The sketch also attaches a hyperlink to each button (using <samp class="SANS_TheSansMonoCd_W5Regular_11"><a
    href=</samp>) such as <samp class="SANS_TheSansMonoCd_W5Regular_11">/16/on</samp>
    to turn GPIO 16 on, and so on.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 再次强调，代码中使用了许多 <samp class="SANS_TheSansMonoCd_W5Regular_11">client.println()</samp>
    函数来生成用户界面的 HTML。项目代码中的 ❻ 位置的函数生成了显示每个 GPIO 引脚状态所需的 HTML。草图还为每个按钮附加了超链接（使用 <samp
    class="SANS_TheSansMonoCd_W5Regular_11"><a href=</samp>），例如 <samp class="SANS_TheSansMonoCd_W5Regular_11">/16/on</samp>
    用于开启 GPIO 16，等等。
- en: 'Here’s the full HTML code contained in the sketch:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 这是草图中包含的完整 HTML 代码：
- en: '[PRE6]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: I encourage you to experiment with the buttons—changing their size, shape, the
    URLs attached to them, and so on—to help you master the process of building an
    interface.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 我鼓励你尝试修改按钮的大小、形状、链接等内容，以帮助你掌握构建界面的过程。
- en: Keep this project’s circuit assembled. You’ll use it in the next section to
    learn about using pulse-width modulation on the ESP32 dev board.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 保持该项目的电路已组装好。你将在下一部分使用它，学习如何在 ESP32 开发板上使用脉冲宽度调制。
- en: <samp class="SANS_Futura_Std_Bold_B_11">Pulse-Width Modulation</samp>
  id: totrans-134
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">脉冲宽度调制</samp>
- en: Just like with the usual Arduino and compatible boards, the ESP32 dev board
    offers pulse-width modulation (PWM) with all the GPIO pins on the ESP32 dev board.
    PWM allows you to control the perceived brightness of an LED, instead of simply
    switching it on and off. The LED’s brightness is determined by the duty cycle,
    or the length of time the GPIO pin is on (so the LED is lit) versus the length
    of time it is off (the LED is unlit).
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 就像通常的 Arduino 和兼容板一样，ESP32 开发板提供了所有 GPIO 引脚的脉冲宽度调制（PWM）。PWM 使你能够控制 LED 的感知亮度，而不仅仅是开关
    LED。LED 的亮度由占空比决定，即 GPIO 引脚处于开启状态的时间（LED 点亮）与关闭状态的时间（LED 熄灭）的比例。
- en: Duty cycle is expressed as the percentage of time the pin is on in each *cycle*,
    the fixed period of time in which the pin can be on or off. The greater the duty
    cycle, the greater the perceived brightness of the LED connected to the pin. Furthermore,
    the higher the frequency of the PWM signal—that is, the faster the signal is turned
    on and off—the smoother the visual effect. If you’re controlling a motor, a higher
    PWM frequency makes the rotational speed a closer approximation of the actual
    speed required.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 占空比是指引脚在每个 *周期* 中处于开启状态的时间百分比，周期是指引脚可以开或关的固定时间段。占空比越大，连接到引脚的 LED 的感知亮度就越高。此外，PWM
    信号的频率越高，即信号开关的速度越快，视觉效果越平滑。如果你在控制电机，更高的 PWM 频率使得转速更加接近所需的实际速度。
- en: '[Figure 19-13](chapter19.xhtml#fig19-13) shows four possible PWM duty cycles.
    The filled-in gray areas represent the amount of time that the LED is on; as you
    can see, this increases with the duty cycle.'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 19-13](chapter19.xhtml#fig19-13) 展示了四种可能的 PWM 占空比。填充的灰色区域表示 LED 点亮的时间；如你所见，随着占空比的增加，这一时间也在增加。'
- en: '![A DIAGRAM EXPLAINING THE PWM DUTY CYCLE WIDTHS](../images/fig19-13.png)'
  id: totrans-138
  prefs: []
  type: TYPE_IMG
  zh: '![解释 PWM 占空比宽度的示意图](../images/fig19-13.png)'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 19-13: Various PWM duty
    cycles</samp>'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">图 19-13：各种 PWM 占空比</samp>
- en: The ESP32 module has 16 PWM channels (numbered 0 to 15). You can direct each
    channel to a GPIO pin. To do so, you must add two lines to <samp class="SANS_TheSansMonoCd_W5Regular_11">void
    setup()</samp> for each pin you want to use. The first line is
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: ESP32 模块有 16 个 PWM 通道（编号 0 到 15）。你可以将每个通道指向一个 GPIO 引脚。为了做到这一点，你需要为每个要使用的引脚在
    `<samp class="SANS_TheSansMonoCd_W5Regular_11">void setup()</samp>` 中添加两行代码。第一行是
- en: '[PRE7]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: where <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">channel</samp>
    is the PWM channel to use (0 through 15), <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">frequency</samp>
    is the PWM frequency, and <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">resolution</samp>
    is the detail for the duty cycle. For <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">frequency</samp>,
    I suggest 5,000 for 5 kHz. For <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">resolution</samp>,
    use 8 for 8-bit resolution, giving you a value of between 0 and 255 for the duty
    cycle (the same way you’d use <samp class="SANS_TheSansMonoCd_W5Regular_11">analogWrite()</samp>
    when using an Arduino or compatible board).
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 其中，<samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">channel</samp>是要使用的PWM通道（0到15），<samp
    class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">frequency</samp>是PWM频率，<samp
    class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">resolution</samp>是占空比的精度。对于<samp
    class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">frequency</samp>，我建议使用5,000，即5
    kHz。对于<samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">resolution</samp>，使用8位分辨率，得到一个0到255之间的值用于占空比（就像你在使用Arduino或兼容板时使用<samp
    class="SANS_TheSansMonoCd_W5Regular_11">analogWrite()</samp>一样）。
- en: The second line required is
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 第二行需要的是
- en: '[PRE8]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: where <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">GPIO</samp> is
    the number of the GPIO pin to use, and <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">channel</samp>
    is the PWM channel to use, as defined in the previous line of code.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 其中，<samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">GPIO</samp>是要使用的GPIO引脚的编号，<samp
    class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">channel</samp>是要使用的PWM通道，正如前一行代码中所定义的。
- en: Finally, to activate PWM on the GPIO, use
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，若要在GPIO上启用PWM，使用
- en: '[PRE9]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: where <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">channel</samp>
    is the PWM channel to control, and <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">dutyCycle</samp>
    is, of course, the duty cycle.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 其中，<samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">channel</samp>是要控制的PWM通道，<samp
    class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">dutyCycle</samp>当然是占空比。
- en: To stop using PWM on a particular GPIO pin and instead use it as a digital input
    or output, use
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 要停止在特定GPIO引脚上使用PWM，并改为将其用作数字输入或输出，使用
- en: '[PRE10]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: where <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">GPIO</samp> is
    the number of the GPIO pin (not the PWM channel).
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 其中，<samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">GPIO</samp>是GPIO引脚的编号（而非PWM通道）。
- en: You can test PWM and experiment with these parameters with the following sketch,
    which uses the same four-LED circuit you’ve used throughout this chapter. A moment
    after you enter and upload [Listing 19-2](#LiT-19-2), all four LEDs should use
    PWM to exhibit a “breathing” effect by using increasing and then decreasing values
    for the duty cycle.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用以下示例代码测试PWM，并尝试这些参数，该代码使用了你在本章中一直使用的相同四个LED电路。在你输入并上传[清单 19-2](#LiT-19-2)后，所有四个LED应该会使用PWM展现“呼吸”效果，通过增加和减少占空比值来实现。
- en: '[PRE11]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 19-2: Testing PWM outputs</samp>'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">清单 19-2：测试PWM输出</samp>
- en: This sketch demonstrates the three relevant lines for using PWM, setting up
    the required PWM channels ❶, and then attaching those channels to GPIO pins ❷.
    This allows the duty cycles to be set for each of the pins at an increasing ❸
    and decreasing ❹ level.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 这个示例演示了使用PWM的三行相关代码，设置所需的PWM通道❶，然后将这些通道连接到GPIO引脚❷。这允许为每个引脚设置占空比，并按递增❸和递减❹的方式调整。
- en: You’ll put this technique to use in the next project.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 你将在下一个项目中使用这一技巧。
- en: '<samp class="SANS_Futura_Std_Heavy_B_21">Project #57: Building a Hosted Web
    Page for a User Interface</samp>'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: '<samp class="SANS_Futura_Std_Heavy_B_21">项目 #57：构建用于用户界面的托管网页</samp>'
- en: 'This project synthesizes everything you’ve learned in this chapter: using an
    ESP32 dev board to control a GPIO via Wi-Fi, using PWM for various output levels,
    and building a hosted web page for a user interface. You can use this as a framework
    to build projects that require PWM control, such as LED lighting effects, controlling
    DC motors via MOSFETs, or experimenting with sound effects from a distance.'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 本项目综合了你在本章中学到的所有内容：使用ESP32开发板通过Wi-Fi控制GPIO，使用PWM控制不同的输出电平，并构建一个用于用户界面的托管网页。你可以将其作为框架，构建需要PWM控制的项目，如LED灯光效果、通过MOSFET控制直流电机，或远程实验声音效果。
- en: 'This project uses the same circuit as in previous projects, with only one LED
    connected to GPIO16 being controlled. Once the circuit is ready and the ESP32
    dev board has been connected to the PC, upload the Project #57 sketch. A moment
    after that, determine the project’s IP address as usual with the Serial Monitor
    and then enter that address into your web browser. The browser should display
    the project interface, as shown in [Figure 19-14](chapter19.xhtml#fig19-14).'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: '这个项目使用与之前项目相同的电路，仅控制连接到GPIO16的一个LED。当电路准备好并且ESP32开发板已连接到PC时，上传Project #57的草图。稍等片刻，像往常一样通过串口监视器确定项目的IP地址，然后在浏览器中输入该地址。浏览器应该会显示项目的界面，如[图19-14](chapter19.xhtml#fig19-14)所示。'
- en: '![AN IMAGE OF THE WEB CONTROL INTERFACE FOR PROJECT #57](../images/fig19-14.png)'
  id: totrans-160
  prefs: []
  type: TYPE_IMG
  zh: '![Project #57的网页控制界面图片](../images/fig19-14.png)'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 19-14: The user interface
    for Project #57</samp>'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">图19-14：Project #57的用户界面</samp>'
- en: You should be able to turn the LED on and off with the appropriate buttons as
    usual. This time, though, you can also decrease or increase the duty cycle one
    step at a time with the DC− and DC+ buttons. You can click the second row of four
    additional buttons to give the duty cycle a preset value, and the line of text
    beneath them shows the current duty cycle value. For example, [Figure 19-14](chapter19.xhtml#fig19-14)
    shows the LED as off (as the duty cycle is 0), while in [Figure 19-15](chapter19.xhtml#fig19-15),
    the LED is on with a duty cycle of 72/255.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该能够像往常一样通过适当的按钮打开或关闭LED。不过这次，你还可以通过DC−和DC+按钮逐步减少或增加占空比。你可以点击第二排的四个附加按钮为占空比设置预设值，下面的文本行显示当前的占空比值。例如，[图19-14](chapter19.xhtml#fig19-14)显示LED关闭（因为占空比为0），而在[图19-15](chapter19.xhtml#fig19-15)中，LED亮起，占空比为72/255。
- en: '![AN IMAGE OF THE WEB CONTROL INTERFACE WITH THE DUTY CYCLE SET TO 72/255](../images/fig19-15.png)'
  id: totrans-163
  prefs: []
  type: TYPE_IMG
  zh: '![占空比设置为72/255的网页控制界面图片](../images/fig19-15.png)'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 19-15: The user interface
    with the duty cycle set to 72/255</samp>'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">图19-15：占空比设置为72/255的用户界面</samp>
- en: 'Let’s see how this works:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看这是如何工作的：
- en: '[PRE12]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The operation of this project is similar to that of the previous projects, but
    with more buttons and a different type of status display.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 该项目的操作类似于之前的项目，但按钮更多，状态显示方式也不同。
- en: When the user changes the duty cycle of the PWM output, that value is stored
    in an integer variable ❶. The custom <samp class="SANS_TheSansMonoCd_W5Regular_11">pinOff()</samp>
    function is called when the user clicks the Off button. Since you can’t set PWM
    to 0 duty cycle to turn off the GPIO output, this function detaches the PWM channel
    from the GPIO pin and then uses <samp class="SANS_TheSansMonoCd_W5Regular_11">digitalWrite()</samp>
    to turn off the GPIO pin. The <samp class="SANS_TheSansMonoCd_W5Regular_11">pinOn()</samp>
    function does the opposite; since you can’t set the PWM to full-on, this function
    detaches the PWM channel and then turns the GPIO pin on using <samp class="SANS_TheSansMonoCd_W5Regular_11">digitalWrite()</samp>.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 当用户更改PWM输出的占空比时，该值会存储在一个整数变量❶中。用户点击“Off”按钮时会调用自定义的<samp class="SANS_TheSansMonoCd_W5Regular_11">pinOff()</samp>函数。由于无法通过将PWM设置为0占空比来关闭GPIO输出，因此该函数将PWM通道从GPIO引脚上分离，然后使用<samp
    class="SANS_TheSansMonoCd_W5Regular_11">digitalWrite()</samp>关闭GPIO引脚。<samp class="SANS_TheSansMonoCd_W5Regular_11">pinOn()</samp>函数则执行相反的操作；由于无法将PWM设置为完全开启，该函数将PWM通道分离，然后使用<samp
    class="SANS_TheSansMonoCd_W5Regular_11">digitalWrite()</samp>打开GPIO引脚。
- en: The sketch uses the custom <samp class="SANS_TheSansMonoCd_W5Regular_11">PWM(int
    dc)</samp> function to activate PWM, attach a PWM channel to the GPIO pin, and
    set the required duty cycle, passed in via the parameter <samp class="SANS_TheSansMonoCd_W5Regular_11">dc</samp>.
    When you first start the project or reset it, the sketch turns the GPIO pin off
    ❷.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 该草图使用自定义的<samp class="SANS_TheSansMonoCd_W5Regular_11">PWM(int dc)</samp>函数来激活PWM，将PWM通道连接到GPIO引脚，并设置所需的占空比，通过参数<samp
    class="SANS_TheSansMonoCd_W5Regular_11">dc</samp>传入。当你第一次启动项目或重置它时，草图会关闭GPIO引脚❷。
- en: Next, the sketch reviews client requests. If the user presses the Off button
    to turn off the GPIO pin off, the code calls the <samp class="SANS_TheSansMonoCd_W5Regular_11">pinOff()</samp>
    function ❸ and sets the <samp class="SANS_TheSansMonoCd_W5Regular_11">dutyCycle</samp>
    variable to 0 for display purposes on the interface. If the user presses the DC
    button ❹, the duty cycle decreases by 1\. If this would cause the duty cycle to
    fall below 1, the GPIO is switched off instead using <samp class="SANS_TheSansMonoCd_W5Regular_11">pinOff()</samp>.
    Likewise, if the user presses the DC+ button ❺, the duty cycle increases by 1\.
    If this would push the cycle beyond 254, the sketch instead turns on GPIO using
    <samp class="SANS_TheSansMonoCd_W5Regular_11">pinOn()</samp>. Pressing the On
    button ❻ calls the <samp class="SANS_TheSansMonoCd_W5Regular_11">pinOn()</samp>
    function and sets the <samp class="SANS_TheSansMonoCd_W5Regular_11">dutyCycle</samp>
    variable to 255 for display purposes on the interface.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，草图回顾客户端请求。如果用户按下关闭按钮以关闭GPIO引脚，代码会调用<samp class="SANS_TheSansMonoCd_W5Regular_11">pinOff()</samp>函数❸，并将<samp
    class="SANS_TheSansMonoCd_W5Regular_11">dutyCycle</samp>变量设置为0，以便在界面上显示。如果用户按下DC按钮❹，占空比会减少1。如果这样会导致占空比低于1，则使用<samp
    class="SANS_TheSansMonoCd_W5Regular_11">pinOff()</samp>函数关闭GPIO。同样，如果用户按下DC+按钮❺，占空比增加1。如果这样会导致占空比超过254，则草图会使用<samp
    class="SANS_TheSansMonoCd_W5Regular_11">pinOn()</samp>函数打开GPIO。按下开启按钮❻会调用<samp
    class="SANS_TheSansMonoCd_W5Regular_11">pinOn()</samp>函数，并将<samp class="SANS_TheSansMonoCd_W5Regular_11">dutyCycle</samp>变量设置为255，以便在界面上显示。
- en: The four final buttons ❼ set the duty cycle to preset levels. They’re just examples
    to give you an idea of what is possible. Each request simply sets the PWM value
    via <samp class="SANS_TheSansMonoCd_W5Regular_11">pinPWM()</samp> and then updates
    the <samp class="SANS_TheSansMonoCd_W5Regular_11">dutyCycle</samp> variable accordingly.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 最后的四个按钮❼将占空比设置为预设值。它们仅作为示例，给你一个了解可能实现的功能的概念。每个请求只是通过<samp class="SANS_TheSansMonoCd_W5Regular_11">pinPWM()</samp>设置PWM值，然后相应地更新<samp
    class="SANS_TheSansMonoCd_W5Regular_11">dutyCycle</samp>变量。
- en: <samp class="SANS_Futura_Std_Bold_B_11">Moving On</samp>
  id: totrans-172
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">继续前进</samp>
- en: This chapter demonstrated how to remotely control your ESP32 dev board over
    the internet via web pages designed to your specifications. Rather than controlling
    operations, you can also simply display data generated via the ESP32 on a web
    page for remote viewing, such as data from a sensor.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 本章演示了如何通过专门设计的网页远程控制ESP32开发板，而不是控制操作，你也可以简单地在网页上显示通过ESP32生成的数据进行远程查看，例如来自传感器的数据。
- en: You’ll continue to use your ESP32 in the following chapters. In the next, you’ll
    learn to control it by interacting with social media.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的章节中，你将继续使用ESP32。在下一章，你将学习如何通过与社交媒体互动来控制它。
