- en: '8'
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '8'
- en: RUNNING SCRIPTS REMOTELY
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 远程运行脚本
- en: '![Images](../images/common.jpg)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/common.jpg)'
- en: If you’re the sole IT person in a small organization, chances are you have several
    servers to manage. If you have a script you need to run, you could log in to each
    server, open up the PowerShell console, and run your script there. But you can
    save a lot of time if you run one script that performs a particular task on each
    server. In this chapter, you’ll learn how to run commands remotely using PowerShell
    remoting.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你是一个小型组织中的唯一IT人员，可能有多台服务器需要管理。如果你有一个脚本需要运行，你可以登录到每台服务器，打开PowerShell控制台并在那里运行你的脚本。但如果你运行一个脚本，执行每台服务器上的特定任务，你可以节省很多时间。在本章中，你将学习如何使用PowerShell远程管理来远程运行命令。
- en: '*PowerShell remoting* is a feature that allows a user to remotely run commands
    in a session on one or many computers at once. A *session*, or more specifically,
    a `PSSession`, is a PowerShell remoting term that refers to the environment running
    PowerShell on a remote computer from which you can execute commands. Though executed
    differently, the Microsoft Sysinternals tool `psexec` is the same concept: you
    write code that works on your local machine, send that code over to a remote computer,
    and execute the code as if you were sitting in front of it.'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: '*PowerShell远程管理*是一个功能，允许用户在一个或多个计算机上的会话中远程执行命令。*会话*，或更具体地说，`PSSession`，是PowerShell远程管理的术语，指的是在远程计算机上运行PowerShell的环境，从中可以执行命令。尽管执行方式不同，但微软的Sysinternals工具`psexec`与此概念相同：你编写在本地计算机上工作的代码，将其发送到远程计算机，并像坐在它前面一样执行该代码。'
- en: We’ll spend most of this chapter looking at sessions—what they are, how to use
    them, and what to do when you’re done with them—but first, you’ll need to understand
    a few things about scriptblocks.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的大部分内容将集中在会话上——它们是什么，如何使用它们，以及完成后如何处理它们——但首先，你需要了解一些关于脚本块的内容。
- en: '**NOTE**'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*Microsoft introduced PowerShell remoting in PowerShell v2, which is built
    on top of the* Windows Remote Management (WinRM) *service. For this reason, you
    may, on occasion, see the term WinRM used to refer to PowerShell remoting.*'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: '*微软在PowerShell v2中引入了PowerShell远程管理，它是建立在* Windows远程管理(WinRM) *服务之上的。因此，偶尔你可能会看到WinRM一词，用来指代PowerShell远程管理。*'
- en: Working with Scriptblocks
  id: totrans-8
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用脚本块
- en: 'PowerShell remoting makes extensive use of *scriptblocks*, which, like functions,
    are code packaged into a single executable unit. But they’re different from functions
    in a couple of key ways: they’re anonymous—or unnamed—and they can be assigned
    to variables.'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: PowerShell远程管理广泛使用*脚本块*，它们像函数一样，是封装成一个可执行单元的代码。但它们与函数有几个关键区别：它们是匿名的——或者说没有名称——并且可以赋值给变量。
- en: To examine this difference, let’s consider an example. Let’s define a function,
    called `New-Thing`, which calls `Write-Host` to display some text in the console
    (see [Listing 8-1](ch08.xhtml#ch8list1)).
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 为了检验这种差异，我们来看一个例子。我们定义一个名为`New-Thing`的函数，它调用`Write-Host`在控制台中显示一些文本（见[列表 8-1](ch08.xhtml#ch8list1)）。
- en: '[PRE0]'
  id: totrans-11
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '*Listing 8-1: Defining the `New-Thing` function, which displays text in the
    console window*'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 8-1：定义`New-Thing`函数，在控制台窗口显示文本*'
- en: If you run this script, you should see that it returns the text `"Hi! I am in
    New-Thing!"` to the console. But notice that for this result, you had to call
    `New-Thing` for the function to run.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你运行这个脚本，你应该看到它将文本`"Hi! I am in New-Thing!"`返回到控制台。但请注意，为了得到这个结果，你必须调用`New-Thing`函数才能执行。
- en: You can replicate the result of the `New-Thing` function call with a scriptblock
    by first assigning the scriptblock to a variable, as in [Listing 8-2](ch08.xhtml#ch8list2).
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过首先将脚本块赋值给一个变量来复制`New-Thing`函数调用的结果，如[列表 8-2](ch08.xhtml#ch8list2)所示。
- en: '[PRE1]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '*Listing 8-2: Creating a scriptblock and assigning it to a variable called
    `$newThing`*'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 8-2：创建脚本块并将其赋值给名为`$newThing`的变量*'
- en: To build a scriptblock, place the code you want to execute between curly brackets.
    You stored our scriptblock in the `$newThing` variable, and you might think that
    to execute that scriptblock, you could simply call the variable, as shown in [Listing
    8-3](ch08.xhtml#ch8list3).
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 要构建一个脚本块，将你想执行的代码放在花括号之间。你将我们的脚本块存储在变量`$newThing`中，你可能认为要执行这个脚本块，只需调用该变量，如[列表
    8-3](ch08.xhtml#ch8list3)所示。
- en: '[PRE2]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '*Listing 8-3: Creating and executing a scriptblock*'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 8-3：创建并执行脚本块*'
- en: But as you can see, PowerShell reads the contents of `$newThing` literally.
    It doesn’t realize that `Write-Host` is a command it should execute and instead
    displays the value of the scriptblock.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 但正如你所看到的，PowerShell会字面地读取`$newThing`的内容。它没有意识到`Write-Host`是一个应该执行的命令，而是显示了脚本块的值。
- en: To tell PowerShell to run the code inside, you need to use an ampersand (`&`)
    followed by the variable name. [Listing 8-4](ch08.xhtml#ch8list4) shows this syntax.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 要告诉PowerShell运行内部的代码，你需要使用&符号（`&`）后跟变量名。[示例 8-4](ch08.xhtml#ch8list4)展示了这种语法。
- en: '[PRE3]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '*Listing 8-4: Executing a scriptblock*'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: '*示例 8-4：执行脚本块*'
- en: The ampersand tells PowerShell that the stuff between the curly brackets is
    code that it should run. The ampersand is one way to execute a code block; however,
    it does not allow you the customization a command would, which you’ll need when
    using PowerShell remoting to work on remote computers. The next section covers
    another way to execute scriptblocks.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: '&符号告诉PowerShell，花括号中的内容是它应该执行的代码。&符号是执行代码块的一种方式；然而，它不允许像命令那样进行定制，而你在使用PowerShell远程操作时，通常需要这种定制功能来操作远程计算机。下一节将介绍另一种执行脚本块的方法。'
- en: Using Invoke-Command to Execute Code on Remote Systems
  id: totrans-25
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 使用`Invoke-Command`在远程系统上执行代码
- en: 'You’ll use two main commands when working with PowerShell remoting: `Invoke-Command`
    and `New-PSSession`. In this section, you’ll learn about `Invoke-Command`; the
    next section covers the `New-PSSession` command.'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用PowerShell远程操作时，你将使用两个主要命令：`Invoke-Command`和`New-PSSession`。在本节中，你将学习`Invoke-Command`；下一节将介绍`New-PSSession`命令。
- en: '`Invoke-Command` is probably the command you’ll use the most with PowerShell
    remoting. There are two main ways to use it. The first is when you run what I
    call *ad hoc commands*—small, one-off expressions you want to execute. The second
    is using interactive sessions. We’ll cover both in this chapter.'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: '`Invoke-Command`可能是你在使用PowerShell远程操作时最常用的命令。有两种主要的使用方式。第一种是当你运行我所说的*临时命令*——你希望执行的小型、一次性的表达式。第二种是使用交互式会话。本章将介绍这两种方式。'
- en: An example of an ad hoc command is when you run `Start-Service` to start a service
    on a remote computer When you execute an ad hoc command by using `Invoke-Command`,
    PowerShell creates a session behind the scenes, tearing it down as soon as the
    command has completed. This limits what you can do with just `Invoke-Command`,
    which is why in the next section, you’ll see how to create your own sessions.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 一个临时命令的例子是，当你运行`Start-Service`命令以启动远程计算机上的服务时。当你使用`Invoke-Command`执行临时命令时，PowerShell会在后台创建一个会话，并在命令执行完成后立即拆除该会话。这限制了你只能用`Invoke-Command`做的事情，这就是为什么在下一节你将看到如何创建自己的会话。
- en: But for now, let’s see how `Invoke-Command` works with an ad hoc command. Open
    your PowerShell console, type `Invoke-Command`, and press ENTER, as in [Listing
    8-5](ch08.xhtml#ch8list5).
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 但现在，让我们看看`Invoke-Command`如何与临时命令一起工作。打开你的PowerShell控制台，键入`Invoke-Command`并按ENTER，正如在[示例
    8-5](ch08.xhtml#ch8list5)中所示。
- en: '[PRE4]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '*Listing 8-5: Running `Invoke-Command` with no parameters*'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: '*示例 8-5：无参数运行`Invoke-Command`*'
- en: Your console should immediately ask you to provide a scriptblock. You’ll provide
    the `hostname` command, which will return the hostname of the computer the command
    is run on.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 你的控制台应该立即要求你提供一个脚本块。你将提供`hostname`命令，它将返回执行命令的计算机的主机名。
- en: To pass a scriptblock with `hostname` to `Invoke-Command`, you need to use the
    required parameter, `ComputerName`, which tells `Invoke-Command` which remote
    computer to run this command on, as you can see in [Listing 8-6](ch08.xhtml#ch8list6).
    (Note that for this to work, my machine and the remote computer `WEBSRV1` have
    to be part of the same Active Directory (AD) domain, and my machine needs to have
    admin rights on `WEBSRV1`.)
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 要将`hostname`脚本块传递给`Invoke-Command`，你需要使用必需的参数`ComputerName`，它告诉`Invoke-Command`在哪台远程计算机上运行此命令，正如你在[示例
    8-6](ch08.xhtml#ch8list6)中看到的那样。（注意，要使其正常工作，我的计算机和远程计算机`WEBSRV1`必须是同一Active Directory（AD）域的一部分，并且我的计算机需要在`WEBSRV1`上拥有管理员权限。）
- en: '[PRE5]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '*Listing 8-6: Running a simple `Invoke-Command` example*'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: '*示例 8-6：运行一个简单的`Invoke-Command`示例*'
- en: Notice that the output of `hostname` is now the name of the remote computer—in
    my system, the remote computer is called `WEBSRV1`. You’ve now executed your first
    remote command!
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，`hostname`的输出现在是远程计算机的名称——在我的系统中，远程计算机名为`WEBSRV1`。你现在已经成功执行了你的第一个远程命令！
- en: '**NOTE**'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*If you try this on a remote machine with an operating system older than Windows
    Server 2012 R2, it might not work as expected. If this is the case, you’ll first
    have to enable PowerShell remoting. As of Server 2012 R2, PowerShell remoting
    is enabled, by default, with the WinRM service running with all the necessary
    firewall ports open and access rights set up. But if you’re running an earlier
    version of Windows, this has to be done manually, so run Enable-PSRemoting on
    your remote computer in an elevated console session first before attempting to
    run Invoke-Command against an older server. You may also use the Test-WSMan command
    to confirm whether PowerShell remoting is configured and available.*'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: '*如果您在运行 Windows Server 2012 R2 之前版本的操作系统的远程计算机上尝试此操作，可能无法按预期工作。如果是这种情况，您首先需要启用
    PowerShell 远程处理。从 Server 2012 R2 开始，PowerShell 远程处理默认启用，WinRM 服务正在运行，并且所有必要的防火墙端口已打开并设置了访问权限。但如果您运行的是较早版本的
    Windows，则必须手动执行此操作，因此在尝试对旧版本的服务器运行 Invoke-Command 之前，首先需要在远程计算机上以提升权限的控制台会话运行
    Enable-PSRemoting。您还可以使用 Test-WSMan 命令确认 PowerShell 远程处理是否已配置并可用。*'
- en: Running Local Scripts on Remote Computers
  id: totrans-39
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 在远程计算机上运行本地脚本
- en: In the previous section, you executed scriptblocks on remote computers. You
    can also use `Invoke-Command` to execute entire scripts. Instead of using the
    `Scriptblock` parameter, you can use the `FilePath` parameter and a path to a
    script on your machine. When using the `FilePath` parameter, `Invoke-Command`
    will read the contents of the script locally and then execute that code on the
    remote computer. Contrary to popular belief, the script itself isn’t executed
    on the remote computer.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一节中，您在远程计算机上执行了脚本块。您还可以使用 `Invoke-Command` 执行整个脚本。与使用 `Scriptblock` 参数不同，您可以使用
    `FilePath` 参数并提供本地计算机上的脚本路径。使用 `FilePath` 参数时，`Invoke-Command` 会在本地读取脚本内容，然后在远程计算机上执行这些代码。与普遍认知相反，脚本本身并不会在远程计算机上执行。
- en: 'To demonstrate, let’s say you have a script on your local computer in the root
    of *C:\* called *GetHostName.ps1*. This script has one line in it: `hostname`.
    You’d like to run this script on a remote computer to return the computer’s hostname.
    Note that while we’re keeping the script extremely simple, `Invoke-Command` doesn’t
    care what’s inside the script. It will happily execute whatever is there.'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 举个例子，假设您在本地计算机的 *C:\* 根目录下有一个名为 *GetHostName.ps1* 的脚本。该脚本包含一行：`hostname`。您希望在远程计算机上运行这个脚本以返回计算机的主机名。请注意，虽然我们保持脚本极其简单，但
    `Invoke-Command` 并不关心脚本中的内容。它会高兴地执行其中的任何内容。
- en: To run the script, you pass the script file to the `FilePath` parameter on `Invoke-Command`,
    as shown in [Listing 8-7](ch08.xhtml#ch8list7).
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 要运行脚本，您将脚本文件传递给 `Invoke-Command` 的 `FilePath` 参数，如 [清单 8-7](ch08.xhtml#ch8list7)
    所示。
- en: '[PRE6]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '*Listing 8-7: Running a local script on remote computers*'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 8-7：在远程计算机上运行本地脚本*'
- en: '`Invoke-Command` runs the code inside *GetHostName.ps1* on the `WEBSRV1` computer
    and returns the output back to your local session.'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: '`Invoke-Command` 会在 `WEBSRV1` 计算机上运行 *GetHostName.ps1* 中的代码，并将输出返回到您的本地会话。'
- en: Using Local Variables Remotely
  id: totrans-46
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 在远程使用本地变量
- en: 'Though PowerShell remoting takes care of a lot of things, you have to watch
    out when using local variables. Let’s say you have a file path on a remote computer
    that’s *C:\File.txt*. Because this file path may change at some point, you may
    decide to assign that path as a variable; for example, `$serverFilePath`:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管 PowerShell 远程处理解决了许多问题，但在使用本地变量时仍需小心。假设您在远程计算机上有一个文件路径 *C:\File.txt*。由于这个文件路径可能会在某个时候发生变化，您可能决定将该路径分配为一个变量，例如
    `$serverFilePath`：
- en: '[PRE7]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Now, you may need to reference the *C:\File.txt* path inside a remote scriptblock.
    In [Listing 8-8](ch08.xhtml#ch8list8), you can see what happens when you attempt
    to reference the variable directly.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，您可能需要在远程脚本块中引用 *C:\File.txt* 路径。在 [清单 8-8](ch08.xhtml#ch8list8) 中，您可以看到当您尝试直接引用该变量时会发生什么情况。
- en: '[PRE8]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '*Listing 8-8: Local variables do not work in remote sessions.*'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 8-8：本地变量在远程会话中不起作用。*'
- en: Notice that the `$serverFilePath` variable doesn’t have a value, because while
    inside the scriptblock being executed on the remote computer, the variable doesn’t
    exist! When you define a variable in a script or at the console, that variable
    is stored in a particular *runspace*, which is a container that PowerShell uses
    to store the information for the session. You may have run into runspaces if you’ve
    tried to open two PowerShell consoles at the same time and (failed to) use the
    variables of one in the other.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，`$serverFilePath` 变量没有值，因为在远程计算机上执行的脚本块中，该变量并不存在！当你在脚本或控制台中定义一个变量时，该变量会存储在一个特定的
    *运行空间* 中，这是 PowerShell 用来存储会话信息的容器。如果你尝试同时打开两个 PowerShell 控制台并（未能）在另一个控制台中使用其中的变量，你可能已经遇到过运行空间的概念。
- en: By default, variables, functions, and other constructs can’t spread over multiple
    runspaces. However, you can use a couple of methods to use variables, functions,
    and so forth, in various runspaces. There are two main ways to transfer variables
    to a remote computer.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，变量、函数和其他构造不能跨多个运行空间传播。然而，你可以使用几种方法在不同的运行空间中使用变量、函数等。有两种主要方法可以将变量传递到远程计算机。
- en: Passing Variables with the ArgumentList Parameter
  id: totrans-54
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 使用 `ArgumentList` 参数传递变量
- en: To get the value of a variable into a remote scriptblock, you can use the `ArgumentList`
    parameter on `Invoke-Command`. This parameter allows you to pass an array of local
    values to the scriptblock, called `$args`, which you can use in your scriptblock’s
    code. To show how this works, in [Listing 8-9](ch08.xhtml#ch8list9), you’ll pass
    the `$serverFilePath` variable, which contains the file path *C:\File.txt*, to
    the remote scriptblock and then reference it through the `$args` array.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 要将变量的值传递到远程脚本块中，你可以在 `Invoke-Command` 上使用 `ArgumentList` 参数。这个参数允许你将本地值的数组传递到脚本块中，称为
    `$args`，你可以在脚本块的代码中使用它。为了演示这个过程，在 [列表 8-9](ch08.xhtml#ch8list9) 中，你将传递包含文件路径 *C:\File.txt*
    的 `$serverFilePath` 变量到远程脚本块，并通过 `$args` 数组进行引用。
- en: '[PRE9]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '*Listing 8-9: Using the `$args` array to pass local variables to a remote session*'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 8-9：使用 `$args` 数组将本地变量传递到远程会话*'
- en: As you should see, the variable’s value, *C:\File.txt*, is now inside the scriptblock.
    This is because you passed `$serverFilePath` into `ArgumentList` and replaced
    the `$serverFilePath` reference inside the scriptblock with `$args[0]`. If you
    want to pass more than one variable into the scriptblock, you can add another
    value to the `ArgumentList` parameter value and increment the `$args` reference
    by one where you want to reference the new variable.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，变量的值 *C:\File.txt* 现在已在脚本块中。这是因为你将 `$serverFilePath` 传递到 `ArgumentList`
    中，并且将脚本块内的 `$serverFilePath` 引用替换为 `$args[0]`。如果你想传递多个变量到脚本块中，你可以在 `ArgumentList`
    参数值中添加另一个值，并在需要引用新变量的地方将 `$args` 引用加 1。
- en: Using the $Using Statement to Pass Variable Values
  id: totrans-59
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 使用 `$Using` 语句传递变量值
- en: Another way to pass the values of local variables to a remote scriptblock is
    with the `$using` statement. You can avoid using the `ArgumentList` parameter
    by prepending `$using` to any local variable name. Before PowerShell sends the
    scriptblock to the remote computer, it will look for the `$using` statement and
    expand all the local variables inside the scriptblock.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 将本地变量的值传递给远程脚本块的另一种方法是使用 `$using` 语句。通过在任何本地变量名前加上 `$using`，你可以避免使用 `ArgumentList`
    参数。在 PowerShell 将脚本块发送到远程计算机之前，它会查找 `$using` 语句，并展开脚本块中的所有本地变量。
- en: In [Listing 8-10](ch08.xhtml#ch8list10), you’ll rewrite [Listing 8-9](ch08.xhtml#ch8list9)
    to use `$using:serverFilePath` instead of `ArgumentList`.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [列表 8-10](ch08.xhtml#ch8list10) 中，你将重写 [列表 8-9](ch08.xhtml#ch8list9)，使用 `$using:serverFilePath`
    来代替 `ArgumentList`。
- en: '[PRE10]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '*Listing 8-10: Using `$using` to reference local variables in a remote session*'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 8-10：使用 `$using` 来引用远程会话中的本地变量*'
- en: As you should see, the results of [Listings 8-9](ch08.xhtml#ch8list9) and [8-10](ch08.xhtml#ch8list10)
    are the same.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，[列表 8-9](ch08.xhtml#ch8list9) 和 [8-10](ch08.xhtml#ch8list10) 的结果是相同的。
- en: 'The `$using` statement requires less work and is more intuitive, but down the
    road, when you begin to write Pester to test your scripts, you’ll see that you
    may have to revert to using the `ArgumentList` parameter: when using the `$using`
    option, Pester will have no way to evaluate the value in a `$using` variable.
    When using the `ArgumentList` parameter, the variables passed to the remote session
    are defined locally, which Pester can interpret and understand. If this doesn’t
    make sense now, it will when you read [Chapter 9](ch09.xhtml#ch9). For now, the
    `$using` statement works excellently!'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: '`$using`语句需要的工作更少，也更直观，但将来当你开始编写Pester测试脚本时，你会发现可能需要回退到使用`ArgumentList`参数：当使用`$using`选项时，Pester无法评估`$using`变量中的值。而当使用`ArgumentList`参数时，传递给远程会话的变量是在本地定义的，Pester可以解释和理解这些变量。如果现在这不太清楚，等你读到[第9章](ch09.xhtml#ch9)时你就会明白了。现在，`$using`语句已经非常优秀了！'
- en: Now that you have a basic understanding of the `Invoke-Command` cmdlet, let’s
    learn a few more sessions.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你对`Invoke-Command` cmdlet有了基本的了解，让我们学习更多关于会话的内容。
- en: Working with Sessions
  id: totrans-67
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用会话
- en: As mentioned earlier, PowerShell remoting uses a concept called a *session*.
    When you create a session remotely, PowerShell opens a *local session* on the
    remote computer, which you can use to execute commands there. You don’t need to
    know too many of the technical details of a session. What you do need to know
    is that you can create, connect to, and disconnect from a session, and it will
    maintain the same state that you left it in. The session won’t end until you remove
    it.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，PowerShell远程操作使用了一个叫做*会话*的概念。当你在远程创建会话时，PowerShell会在远程计算机上打开一个*本地会话*，你可以使用这个会话在那里执行命令。你不需要了解太多会话的技术细节。你需要知道的是，你可以创建会话、连接到会话、断开会话，并且会话将保持你离开时的状态。会话在你删除它之前不会结束。
- en: In the previous section, when you ran `Invoke-Command`, it brought up a new
    session, ran the code, and tore it down all in one go. In this section, you’ll
    see how to create what I call *full sessions*, sessions that you can enter commands
    into directly. Using `Invoke-Command` to execute one-off ad hoc commands works
    well, but it’s not too efficient when you need to run a lot of commands that can’t
    all squeeze into a single scriptblock. For example, if you’re working on a large
    script that performs work locally, has to grab information from another source,
    use that information in a remoting session, grab information from a remoting session
    to be used locally, and then return to the local computer, you will have to create
    a script that runs `Invoke-Command` repeatedly. On top of that, you’ll have more
    issues if you need to set a variable in the remote session and use it again later.
    Using `Invoke-Command` as you have so far, this wouldn’t work—you’ll need a session
    that stays there after you leave.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一节中，当你运行`Invoke-Command`时，它会启动一个新的会话，运行代码，并且一气呵成地结束会话。在本节中，你将看到如何创建我所称的*完整会话*，即你可以直接向其中输入命令的会话。使用`Invoke-Command`执行一次性的临时命令效果很好，但当你需要运行很多不能全部放入单个脚本块的命令时，它就不那么高效了。例如，如果你正在编写一个大型脚本，这个脚本需要本地执行一些工作、从另一个源获取信息、在远程会话中使用这些信息、从远程会话获取信息并返回本地计算机，你就必须创建一个脚本，反复运行`Invoke-Command`。更麻烦的是，如果你需要在远程会话中设置一个变量并在之后再次使用它，使用目前的`Invoke-Command`方法是无法实现的——你需要一个在你离开后仍然保持活动的会话。
- en: Creating a New Session
  id: totrans-70
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 创建新会话
- en: To create a semipermanent session on a remote computer with PowerShell remoting,
    you have to explicitly create a full session by using the `New-PSSession` command,
    which will create a session on the remote computer and a reference to that session
    on your local computer.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 要在远程计算机上创建一个半永久的会话，进行PowerShell远程操作，你必须显式地通过使用`New-PSSession`命令来创建一个完整会话，这会在远程计算机上创建一个会话，并在本地计算机上创建该会话的引用。
- en: To create a new `PSSession`, use `New-PSSession` with the `ComputerName` parameter,
    as in [Listing 8-11](ch08.xhtml#ch8list11). In this example, the computer I’m
    running this on is in the same Active Directory domain as `WEBSRV1`, and I’m logged
    in as a domain user with admin rights on `WEBSRV1`. To connect by using the `ComputerName`
    parameter (as I have in [Listing 8-11](ch08.xhtml#ch8list11)), the user must be
    a local administrator or at least in the Remote Management Users group on the
    remote computer. If you’re not in an AD domain, you can use the `Credential` parameter
    on `New-PSSession` to pass a `PSCredential` object containing an alternate credential
    to authenticate to the remote computer.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建一个新的 `PSSession`，请使用带有 `ComputerName` 参数的 `New-PSSession`，就像在 [清单 8-11](ch08.xhtml#ch8list11)
    中所示。在此示例中，我运行此命令的计算机与 `WEBSRV1` 处于同一的 Active Directory 域中，并且我以域用户的身份登录 `WEBSRV1`，具有管理员权限。要通过使用
    `ComputerName` 参数进行连接（就像我在 [清单 8-11](ch08.xhtml#ch8list11) 中所做的那样），用户必须是本地管理员或者至少是远程管理用户组中的成员。如果您不在
    AD 域中，可以在 `New-PSSession` 上使用 `Credential` 参数，传递一个包含用于身份验证到远程计算机的备用凭据的 `PSCredential`
    对象。
- en: '[PRE11]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '*Listing 8-11: Creating a new `PSSession`*'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 8-11：创建一个新的 `PSSession`*'
- en: As you can see, `New-PSSession` returns a session. Once the session is established,
    you can jump in and out of the session with `Invoke-Command`; instead of using
    the `ComputerName` parameter, as you did with the ad hoc command, you’ll have
    to use the `Session` parameter.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，`New-PSSession` 返回一个会话。一旦建立了会话，您可以通过 `Invoke-Command` 跳入和跳出会话；与使用临时命令时不同，您将必须使用
    `Session` 参数。
- en: You need to provide the `Session` parameter with a session object. You can use
    the `Get-PSSession` command to see all your current sessions. In [Listing 8-12](ch08.xhtml#ch8list12),
    you’ll store the output of `Get-PSSession` in a variable.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 您需要使用 `Session` 参数并提供一个会话对象。您可以使用 `Get-PSSession` 命令查看所有当前会话。在 [清单 8-12](ch08.xhtml#ch8list12)
    中，您将会将 `Get-PSSession` 的输出存储在一个变量中。
- en: '[PRE12]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '*Listing 8-12: Finding sessions created on the local computer*'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 8-12：查找在本地计算机上创建的会话*'
- en: Because you ran `New-PSSession` only once, you have only one `PSSession` created
    in [Listing 8-12](ch08.xhtml#ch8list12). If you have multiple sessions, you can
    pick the session you want `Invoke-Command` to use by using the `Get-PSSession`
    command’s `Id` parameter.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 因为您只运行了一次 `New-PSSession`，所以在 [清单 8-12](ch08.xhtml#ch8list12) 中只创建了一个 `PSSession`。如果您有多个会话，可以通过使用
    `Get-PSSession` 命令的 `Id` 参数来选择 `Invoke-Command` 要使用的会话。
- en: Invoking Commands in a Session
  id: totrans-80
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 在会话中调用命令
- en: Now that you have a session in a variable, you can pass that variable to `Invoke-Command`
    and run some code inside the session, as in [Listing 8-13](ch08.xhtml#ch8list13).
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您有了一个存储在变量中的会话，可以将该变量传递给 `Invoke-Command` 并在会话中运行一些代码，就像在 [清单 8-13](ch08.xhtml#ch8list13)
    中所示。
- en: '[PRE13]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '*Listing 8-13: Using an existing session to invoke commands on a remote computer*'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 8-13：使用现有会话在远程计算机上调用命令*'
- en: You should notice that this command runs much faster than when you passed it
    a command. This is because `Invoke-Command` doesn’t have to create and tear down
    a new session. When you create a full session, not only is it faster, but you
    also have access to more functionality. For example, as you can see in [Listing
    8-14](ch08.xhtml#ch8list14), you can set variables in the remote session and return
    to the session without losing those variables.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 您应该注意到，此命令的运行速度比您传递命令时要快得多。这是因为 `Invoke-Command` 不需要创建和拆除一个新的会话。当您创建完整会话时，不仅速度更快，而且还可以访问更多功能。例如，正如您在
    [清单 8-14](ch08.xhtml#ch8list14) 中所见，您可以在远程会话中设置变量，并且返回到会话时不会丢失这些变量。
- en: '[PRE14]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '*Listing 8-14: Variable values remain over subsequent session connections.*'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 8-14：变量值在后续会话连接中保持不变。*'
- en: As long as the session stays open, you can do whatever you need in the remote
    session, and the state of the session will go unchanged. However, this is valid
    for only your current local session. If you start another PowerShell process,
    you can’t just pick up where you left off. The remote session will still be active,
    but the reference to that remote session on the local computer will be gone. In
    that case, the `PSSession` will go into a disconnected state (which you’ll see
    in an upcoming section).
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 只要会话保持打开状态，您可以在远程会话中执行任何您需要的操作，会话的状态将保持不变。但是，这仅适用于当前的本地会话。如果启动另一个 PowerShell
    进程，您不能继续之前的操作。远程会话仍然处于活动状态，但是本地计算机对该远程会话的引用将会丢失。在这种情况下，`PSSession` 将进入断开连接状态（您将在后面的部分看到）。
- en: Opening Interactive Sessions
  id: totrans-88
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 打开交互式会话
- en: '[Listing 8-14](ch08.xhtml#ch8list14) used `Invoke-Command` to send commands
    to a remote computer and receive a response. Running remote commands like this
    is like running an unmonitored script. It’s not interactive, as when you’re punching
    keystrokes into a PowerShell console. If you want to open an interactive console
    for the session running on a remote computer—for some troubleshooting, for example—you
    can use the `Enter-PSSession` command.'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: '[Listing 8-14](ch08.xhtml#ch8list14) 使用 `Invoke-Command` 向远程计算机发送命令并接收响应。像这样运行远程命令就像运行一个没有监控的脚本。它不是交互式的，就像你在
    PowerShell 控制台中输入按键一样。如果你想为远程计算机上运行的会话打开一个交互式控制台——例如进行故障排除——你可以使用 `Enter-PSSession`
    命令。'
- en: The `Enter-PSSession` command allows the user to work with the session interactively.
    It can either create its own session or rely on an existing one created with `New-PSSession`.
    If you do not specify a session to enter into, `Enter-PSSession` will create a
    new one and wait for further input, as in [Listing 8-15](ch08.xhtml#ch8list15).
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: '`Enter-PSSession` 命令允许用户以交互方式操作会话。它可以创建自己的会话，也可以依赖于通过 `New-PSSession` 创建的现有会话。如果没有指定要进入的会话，`Enter-PSSession`
    将创建一个新的会话并等待进一步输入，如 [Listing 8-15](ch08.xhtml#ch8list15) 所示。'
- en: '[PRE15]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '*Listing 8-15: Entering an interactive session*'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: '*Listing 8-15: 进入交互式会话*'
- en: 'Notice that your PowerShell prompt changes to `[WEBSRV1]: PS`. This prompt
    indicates that you’re no longer running commands locally but in that remote session.
    At this point, you can run any command you want, as if you’re at the console of
    the remote computer. Working with sessions interactively like this is a great
    way to eliminate using the *Remote Desktop Protocol* (*RDP*) application to bring
    up an interactive GUI to perform tasks, like troubleshooting on a remote computer.'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: '请注意，你的 PowerShell 提示符已经变为 `[WEBSRV1]: PS`。这个提示符表示你不再在本地运行命令，而是在那个远程会话中。此时，你可以像在远程计算机的控制台上一样运行任何命令。像这样交互式地操作会话是避免使用
    *远程桌面协议*（*RDP*）应用程序启动交互式 GUI 来执行任务（例如远程计算机的故障排除）的好方法。'
- en: Disconnecting from and Reconnecting to Sessions
  id: totrans-94
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 断开和重新连接会话
- en: If you close your PowerShell console, open it back up again, and try to use
    `Invoke-Command` in the session you were previously working in, you will receive
    an error message, as in [Listing 8-16](ch08.xhtml#ch8list16).
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你关闭了 PowerShell 控制台，然后重新打开它，再尝试在之前工作的会话中使用 `Invoke-Command`，你将收到一条错误消息，如 [Listing
    8-16](ch08.xhtml#ch8list16) 所示。
- en: '[PRE16]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: '*Listing 8-16: Attempting to run commands in a disconnected session*'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: '*Listing 8-16: 尝试在断开的会话中运行命令*'
- en: PowerShell can find the `PSSession` on the remote computer but can’t find the
    reference on the local machine, which tells you the session is disconnected. This
    is what happens if you don’t correctly disconnect the local session reference
    to the remote `PSSession`.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: PowerShell 能够在远程计算机上找到 `PSSession`，但在本地计算机上找不到该引用，这表明会话已断开。如果没有正确断开本地会话对远程 `PSSession`
    的引用，就会发生这种情况。
- en: You can disconnect existing sessions by using the `Disconnect-PSSession` command.
    You can clean up any sessions previously created by retrieving them with `Get-PSSession`
    and then piping those sessions to the `Disconnect-PSSession` command (see [Listing
    8-17](ch08.xhtml#ch8list17)). Or, alternatively, you can use the `Session` parameter
    on `Disconnect-PSSession` to disconnect one session at a time.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用 `Disconnect-PSSession` 命令断开现有会话。你可以通过 `Get-PSSession` 检索之前创建的会话，然后将这些会话传递给
    `Disconnect-PSSession` 命令进行清理（参见 [Listing 8-17](ch08.xhtml#ch8list17)）。或者，您还可以使用
    `Disconnect-PSSession` 的 `Session` 参数一次断开一个会话。
- en: '[PRE17]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: '*Listing 8-17: Disconnecting a `PSSession`*'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: '*Listing 8-17: 断开 `PSSession` 连接*'
- en: To properly disconnect from a session, you pass your remote session name to
    the `Session` parameter by either calling it explicitly via `Disconnect-PSSession
    -Session` session name or piping an existing session to the command via `Get-PSSession`
    as in [Listing 8-17](ch08.xhtml#ch8list17).
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 要正确地断开会话，你可以通过显式调用 `Disconnect-PSSession -Session` 会话名称，或通过 `Get-PSSession`
    将现有会话传递给命令来将远程会话名称传递给 `Session` 参数，如 [Listing 8-17](ch08.xhtml#ch8list17) 所示。
- en: If you’d like to connect to your session again later, after you’ve disconnected
    with `Disconnect-PSSession`, close your PowerShell console and then use the `Connect-PSSession`
    command, as in [Listing 8-18](ch08.xhtml#ch8list18). Note that you can see and
    connect only to disconnected sessions that your account has already created. You
    will not be able to see sessions other users have created.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想在稍后重新连接会话，在使用`Disconnect-PSSession`断开连接后，关闭你的 PowerShell 控制台，然后使用`Connect-PSSession`命令，如[示例
    8-18](ch08.xhtml#ch8list18)所示。请注意，你只能看到并连接到已断开的会话，这些会话必须是你账户之前创建的。你将无法看到其他用户创建的会话。
- en: '[PRE18]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: '*Listing 8-18: Reconnecting to a `PSSession`*'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: '*示例 8-18：重新连接到`PSSession`*'
- en: You should now be able to run code on the remote computer as if you never closed
    your console.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你应该能够像从未关闭过控制台一样，在远程计算机上运行代码。
- en: If you still receive an error message, you may have mismatched PowerShell versions.
    Disconnected sessions work only if the local machine and remote server have the
    same PowerShell version. For example, if you have PowerShell 5.1 on your local
    computer, but the remote server you’re connecting to is running a version of PowerShell
    that doesn’t support disconnected sessions (such as PowerShell v2 or older), disconnected
    sessions won’t work. Always be sure that both the local machine and remote server
    have the same PowerShell version.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你仍然收到错误信息，可能是 PowerShell 版本不匹配。断开会话仅在本地计算机和远程服务器的 PowerShell 版本相同的情况下有效。例如，如果本地计算机上运行
    PowerShell 5.1，而你连接的远程服务器正在运行一个不支持断开会话的版本（例如 PowerShell v2 或更早版本），则断开会话将无法正常工作。始终确保本地计算机和远程服务器使用相同版本的
    PowerShell。
- en: To check whether your local computer’s PowerShell version matches the version
    on your remote computer, check the value of the `$PSVersionTable` variable, which
    contains versioning information (see [Listing 8-19](ch08.xhtml#ch8list19)).
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 要检查本地计算机的 PowerShell 版本是否与远程计算机的版本匹配，请检查`$PSVersionTable`变量的值，该变量包含版本信息（见[示例
    8-19](ch08.xhtml#ch8list19)）。
- en: '[PRE19]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: '*Listing 8-19: Checking the PowerShell version on a local computer*'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: '*示例 8-19：检查本地计算机上的 PowerShell 版本*'
- en: To check for the version on your remote computer, run `Invoke-Command` on that
    computer, passing it the `$PSVersionTable` variable, as in [Listing 8-20](ch08.xhtml#ch8list20).
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 要检查远程计算机上的版本，可以在该计算机上运行`Invoke-Command`，并传递`$PSVersionTable`变量，如[示例 8-20](ch08.xhtml#ch8list20)所示。
- en: '[PRE20]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: '*Listing 8-20: Checking the PowerShell version on a remote computer*'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: '*示例 8-20：检查远程计算机上的 PowerShell 版本*'
- en: I suggest that, before you disconnect from a session, you check that your versions
    match; that way, you can avoid losing valuable work on a remote system.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 我建议，在断开连接之前，你检查一下版本是否匹配；这样，你就能避免在远程系统上丢失宝贵的工作。
- en: Removing Sessions with Remove-PSSession
  id: totrans-115
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 使用 Remove-PSSession 删除会话
- en: 'Whenever the `New-PSSession` command creates a new session, that session exists
    both on the remote server and on the local computer. You can open a lot of sessions
    across many servers at the same time as well, and if some of those sessions are
    no longer in use, you may eventually need to clean them up. You can do so with
    the `Remove-PSSession` command, which goes out to the remote computer, tears down
    that session, and if it exists, removes the local `PSSession` reference. [Listing
    8-21](ch08.xhtml#ch8list21) is an example of this:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 每当`New-PSSession`命令创建一个新会话时，该会话会同时存在于远程服务器和本地计算机上。你也可以同时在多个服务器上打开多个会话，如果其中一些会话不再使用，你可能最终需要清理它们。你可以使用`Remove-PSSession`命令来执行此操作，该命令会访问远程计算机，关闭该会话，并在存在的情况下，移除本地的`PSSession`引用。[示例
    8-21](ch08.xhtml#ch8list21)就是一个例子：
- en: '[PRE21]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: '*Listing 8-21: Removing a `PSSession`*'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: '*示例 8-21：删除`PSSession`*'
- en: Here, you see that you’re running `Get-PSSession` again, and nothing is returned.
    This means there are no sessions on your local computer.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，你再次运行`Get-PSSession`，但没有返回任何结果。这意味着本地计算机上没有会话。
- en: Understanding PowerShell Remoting Authentication
  id: totrans-120
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 理解 PowerShell 远程身份验证
- en: So far, I’ve been ignoring the question of authentication. By default, if your
    local and remote computers are both in the same domain and both have PowerShell
    remoting enabled, you don’t need to explicitly authenticate. But if they’re not,
    you’ll need to authenticate somehow.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我一直没有涉及身份验证的问题。默认情况下，如果本地计算机和远程计算机都在同一个域中，并且都启用了 PowerShell 远程功能，你无需显式身份验证。但是，如果它们不在同一域中，你需要以某种方式进行身份验证。
- en: Two of the most common ways you can authenticate to remote computers with PowerShell
    remoting are by using Kerberos or CredSSP. If you’re in an Active Directory domain,
    you’re probably already using a Kerberos ticket system, whether you know it or
    not. Active Directory and some Linux systems use Kerberos *realms*, entities that
    issue tickets to clients. These tickets are then presented to resources and compared
    (in Active Directory) on domain controllers.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 PowerShell 远程连接到远程计算机的两种最常见身份验证方式是通过 Kerberos 或 CredSSP。如果你处于一个 Active Directory
    域中，你很可能已经在使用 Kerberos 票证系统，无论你是否意识到这一点。Active Directory 和一些 Linux 系统使用 Kerberos
    *领域*，它们向客户端颁发票证。这些票证随后会被提交给资源并与域控制器（在 Active Directory 中）进行比对。
- en: CredSSP, on the other hand, doesn’t need Active Directory. CredSSP was introduced
    way back with Windows Vista and uses a client-side credential service provider
    (CSP) to enable applications to delegate user credentials to remote computers.
    CredSSP doesn’t require an outside system, such as a domain controller, in order
    to authenticate two systems.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，CredSSP 不需要 Active Directory。CredSSP 从 Windows Vista 开始就已被引入，它使用客户端凭据服务提供程序（CSP）来使应用程序能够将用户凭据委托给远程计算机。CredSSP
    不需要像域控制器这样的外部系统来进行两台系统的身份验证。
- en: In an Active Directory environment, PowerShell remoting uses the Kerberos network
    authentication protocol to make calls out to Active Directory that perform all
    the authentication under the hood. PowerShell uses the account you’re logged onto
    locally as the user in order to authenticate to the remote computer—just like
    many other services. This is the beauty of single sign-on.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Active Directory 环境中，PowerShell 远程使用 Kerberos 网络身份验证协议向 Active Directory 发起调用，所有身份验证操作都在后台完成。PowerShell
    使用你本地登录的账户作为远程计算机的用户身份进行身份验证——就像许多其他服务一样。这就是单点登录的优势所在。
- en: But sometimes you’re forced to change up that authentication type a bit if you’re
    not in an Active Directory environment; for example, when you need to connect
    to remote computers over the internet or on the local network, but via local credentials
    on the remote computer. PowerShell supports numerous methods for PowerShell remoting
    authentication, but the most common—other than just using Kerberos—is CredSSP,
    which allows a local computer to delegate the user’s credentials to the remote
    computer. This concept is similar to Kerberos, but Active Directory is not needed.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 但有时如果你不在 Active Directory 环境中，你就不得不稍微改变身份验证类型；例如，当你需要通过远程计算机上的本地凭据连接到远程计算机，无论是通过互联网还是本地网络时。PowerShell
    支持多种 PowerShell 远程身份验证方法，但最常见的——除了使用 Kerberos 之外——是 CredSSP，它允许本地计算机将用户凭据委托给远程计算机。这个概念类似于
    Kerberos，但不需要 Active Directory。
- en: You don’t usually need to use a different authentication type when working in
    an Active Directory environment, but it does come up sometimes, so it’s best you’re
    prepared. In this section, you’ll learn about a common authentication issue and
    how to work around it.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Active Directory 环境中工作时，通常不需要使用不同的身份验证类型，但有时会遇到这种情况，因此最好做好准备。在本节中，你将学习一个常见的身份验证问题以及如何绕过它。
- en: The Double Hop Problem
  id: totrans-127
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 双跳问题
- en: The *double hop problem* has been an issue ever since Microsoft added the PowerShell
    remoting feature. This problem arises when you’re running code inside a remote
    session, and then attempt to access remote resources from that remote session.
    For example, if you have a domain controller called DC on your network and you
    want to check out the files on the root of *C:\* by using the `C$` administrative
    share, you can browse the share remotely from your local machine without an issue
    (see [Listing 8-22](ch08.xhtml#ch8list22)).
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: '*双跳问题* 自从 Microsoft 添加了 PowerShell 远程功能以来一直存在。当你在远程会话中运行代码，然后尝试从该远程会话访问远程资源时，就会出现这个问题。例如，如果你的网络中有一个名为
    DC 的域控制器，并且你想通过 `C$` 管理共享查看 *C:\* 根目录下的文件，你可以从本地计算机远程浏览该共享，毫无问题（参见 [示例 8-22](ch08.xhtml#ch8list22)）。'
- en: '[PRE22]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: '*Listing 8-22: Enumerating files over a UNC share*'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: '*示例 8-22：列举 UNC 共享上的文件*'
- en: The issue arises when you create a `PSSession` and attempt to rerun the same
    command, as in [Listing 8-23](ch08.xhtml#ch8list23).
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 这个问题出现在你创建了一个 `PSSession` 并尝试重新运行相同的命令时，如 [示例 8-23](ch08.xhtml#ch8list23) 中所示。
- en: '[PRE23]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: '*Listing 8-23: Attempting to access network resources in a session*'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: '*示例 8-23：尝试在会话中访问网络资源*'
- en: In this case, PowerShell tells you that access is denied—even when you know
    your user account has access. This happens because, when you use the default Kerberos
    authentication, PowerShell remoting doesn’t then pass that credential to the other
    network resource. In other words, it doesn’t make both hops. For security reasons,
    PowerShell adheres to Windows restrictions and refuses to delegate those credentials,
    and as a result, returns an Access Denied message.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，即使你知道你的用户账户有访问权限，PowerShell 仍然告诉你访问被拒绝。这是因为，当你使用默认的 Kerberos 身份验证时，PowerShell
    远程操作并不会将凭据传递给其他网络资源。换句话说，它没有完成两个跳跃。出于安全原因，PowerShell 遵循 Windows 限制，拒绝委派这些凭据，结果返回“访问被拒绝”的消息。
- en: Double Hopping with CredSSP
  id: totrans-135
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 使用 CredSSP 的双跳问题
- en: In this section, you’ll learn how to work around the double hop problem. I say
    *work around* instead of *fix* for a reason. Microsoft has warned that using CredSSP
    is a security problem, as the credential passed to the first computer is automatically
    used for all connections from that computer. This means if the original computer
    is compromised, that credential can be used from that computer to connect to other
    computers across the network. Nevertheless, other than using some fancy workarounds,
    like resource-based Kerberos constrained delegation, many users choose to use
    the CredSSP approach because it’s easy to use.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，你将学习如何解决双跳问题。我使用“解决”而不是“修复”有原因。微软已警告，使用 CredSSP 是一个安全问题，因为传递给第一个计算机的凭据会自动用于从该计算机进行的所有连接。这意味着，如果原始计算机被攻破，那么可以利用该凭据从该计算机连接到网络上的其他计算机。尽管如此，除了使用一些复杂的变通方法，如基于资源的
    Kerberos 受限委派，许多用户还是选择使用 CredSSP 方法，因为它容易使用。
- en: Before you implement CredSSP, you have to enable it on both the client and the
    server by using the `Enable-WsManCredSSP` command in an elevated PowerShell session.
    This command has a `Role` parameter, which allows you to define whether CredSSP
    is being enabled on the client or the server side. First, enable CredSSP on the
    client side, as in [Listing 8-24](ch08.xhtml#ch8list24).
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 在实现 CredSSP 之前，你必须在客户端和服务器上都启用它，可以通过在提升的 PowerShell 会话中使用 `Enable-WsManCredSSP`
    命令来实现。此命令有一个 `Role` 参数，允许你定义是启用客户端还是服务器端的 CredSSP。首先，在客户端启用 CredSSP，如 [清单 8-24](ch08.xhtml#ch8list24)
    所示。
- en: '**NOTE**'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*To get CredSSP to work, you may have to relax a local policy. If you receive
    a permission error when trying to enable CredSSP, be sure you enable the Allow
    Delegating Saved Credentials with NTLM-only Server Authentication setting by running
    gpedit.msc and looking under Computer Configuration ▶ Administrative Templates
    ▶ System ▶ Credentials Delegation. While in the policy, click on the **Show**
    button and enter **WSMAN/*** to allow delegation from any endpoint.*'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: '*要使 CredSSP 生效，可能需要放宽本地策略。如果在尝试启用 CredSSP 时收到权限错误，请确保通过运行 gpedit.msc 并在计算机配置
    ▶ 管理模板 ▶ 系统 ▶ 凭据委派下启用“允许仅使用 NTLM 服务器身份验证的保存凭据委派”设置。在该策略中，点击 **显示** 按钮并输入 **WSMAN/***
    以允许从任何端点委派凭据。*'
- en: '[PRE24]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: '*Listing 8-24: Enabling CredSSP support on the client computer*'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 8-24：在客户端计算机上启用 CredSSP 支持*'
- en: You enable CredSSP on the client by passing the value `Client` ❷ to the `Role`
    parameter ❶. You also use the required `DelegateComputer` parameter ❸ here because
    PowerShell needs to know which computers are allowed to use the credential you’ll
    be delegating it to. You could pass an asterisk (`*`) to `DelegateComputer` in
    order to allow delegation to all computers, but for security purposes, it’s better
    to just allow the computers you’re working with, in this case, `WEBSRV1`.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 通过将值 `Client` ❷ 传递给 `Role` 参数 ❶，你可以在客户端启用 CredSSP。你还需要使用必需的 `DelegateComputer`
    参数 ❸，因为 PowerShell 需要知道哪些计算机被允许使用你将委派的凭据。你可以将星号（`*`）传递给 `DelegateComputer`，以允许将凭据委派给所有计算机，但出于安全原因，最好只允许你正在使用的计算机，在这种情况下是
    `WEBSRV1`。
- en: Once CredSSP is enabled on the client, you need to do the same on the server
    ([Listing 8-25](ch08.xhtml#ch8list25)). Luckily, you can just open up a new remote
    session without using CredSSP, and then enable CredSSP within the session—rather
    than having to use Microsoft Remote Desktop to access the server or visit it physically.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦在客户端启用了 CredSSP，你需要在服务器上执行相同的操作（[清单 8-25](ch08.xhtml#ch8list25)）。幸运的是，你可以直接打开一个新的远程会话而不使用
    CredSSP，然后在会话内启用 CredSSP，而不必使用 Microsoft 远程桌面访问服务器或亲自访问它。
- en: '[PRE25]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: '*Listing 8-25: Enabling CredSSP support on the server computer*'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 8-25：在服务器计算机上启用 CredSSP 支持*'
- en: 'With that, you’ve enabled CredSSP on both the client and the server: the client
    is allowing its user credentials to be delegated to the remote server, and the
    remote server has CredSSP enabled itself. Now you can try to access remote network
    resources from that remote session again (see [Listing 8-26](ch08.xhtml#ch8list26)).
    Note that if you ever need to undo enabling CredSSP, the command `Disable-WsmanCredSSP`
    will revert your changes.'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 这样，你就已在客户端和服务器上启用了CredSSP：客户端允许将用户凭据委托给远程服务器，而远程服务器本身也启用了CredSSP。现在，你可以再次尝试从该远程会话访问远程网络资源（参见[清单8-26](ch08.xhtml#ch8list26)）。请注意，如果你需要撤销启用CredSSP，命令`Disable-WsmanCredSSP`将恢复你的更改。
- en: '[PRE26]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: '*Listing 8-26: Accessing network resources over a CredSSP-authenticated session*'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单8-26：通过CredSSP认证的会话访问网络资源*'
- en: Notice that you have to explicitly tell `Invoke-Command` (or `Enter-PSSession)`
    that you’d like to use CredSSP authentication ❶, and both commands—whichever you
    use—require a credential. You get that credential by using the `Get-Credential`
    command rather than the default Kerberos ❷.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，你必须明确告诉`Invoke-Command`（或`Enter-PSSession`）你希望使用CredSSP认证❶，并且无论你使用哪个命令，都需要提供凭据。你可以通过使用`Get-Credential`命令来获取凭据，而不是默认的Kerberos认证❷。
- en: After you execute `Invoke-Command` and provide `Get-Credential` with a username
    and password with access to the `c$` share on DC, you can see the `Get-ChildItem`
    command works as expected!
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 执行`Invoke-Command`并为`Get-Credential`提供具有访问DC上`c$`共享的用户名和密码后，你可以看到`Get-ChildItem`命令按预期工作！
- en: Summary
  id: totrans-151
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 总结
- en: PowerShell remoting is, by far, the easiest way to remotely execute code on
    remote systems. As you learned in this chapter, the PowerShell remoting feature
    is easy to use and intuitive. Once you’ve grasped the concept of a scriptblock
    and where that code inside of it is being executed, remote scriptblocks will be
    second nature to you.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: PowerShell远程执行是目前最简单的在远程系统上执行代码的方法。如你在本章所学，PowerShell远程执行功能易于使用且直观。一旦你掌握了脚本块的概念以及其中代码的执行位置，远程脚本块将成为你的第二天性。
- en: In [Part III](part3.xhtml#part3) of this book—where you will build your own
    robust PowerShell module—you’ll use PowerShell remoting in nearly every command.
    If you had trouble following along in this chapter, please go over it again or
    begin to experiment. Try different scenarios, break things, fix them, do whatever
    you can to understand PowerShell remoting. It’s one of the most important skills
    you can learn from this book.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书的[第三部分](part3.xhtml#part3)—你将构建自己的强大PowerShell模块—你几乎会在每个命令中使用PowerShell远程执行。如果你在本章中遇到困难，请再读一遍或开始尝试实验。尝试不同的场景，打破它们，修复它们，做任何你能做的事情来理解PowerShell远程执行。这是你从本书中可以学习的最重要的技能之一。
- en: '[Chapter 9](ch09.xhtml#ch9) covers another major skill: testing with Pester.'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: '[第9章](ch09.xhtml#ch9)介绍了另一个重要技能：使用Pester进行测试。'
