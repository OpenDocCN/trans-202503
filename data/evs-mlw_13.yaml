- en: <hgroup>
  id: totrans-0
  prefs: []
  type: TYPE_NORMAL
  zh: <hgroup>
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">10</samp> <samp class="SANS_Dogma_OT_Bold_B_11">ANTI-DEBUGGING</samp>
  id: totrans-1
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">10</samp> <samp class="SANS_Dogma_OT_Bold_B_11">反调试</samp>
- en: </hgroup>
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: </hgroup>
- en: '![](../images/opener.jpg)'
  id: totrans-3
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/opener.jpg)'
- en: '*Anti-debugging* is a series of anti-reversing techniques used by malware (and
    even some legitimate programs) to hamper or prevent debugging. For example, the
    malware might try to interfere with the debugger process if it detects that it’s
    attached to a debugger, or it might try to prevent debugging altogether by using
    so-called anti-attach mechanisms or crashing the debugger program. In this chapter,
    we’ll explore some of these techniques in detail.'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: '*反调试*是一系列由恶意软件（甚至一些合法程序）使用的反逆向技术，旨在阻碍或防止调试。例如，如果恶意软件检测到调试器正在附加，它可能会尝试干扰调试器进程，或者通过使用所谓的反附加机制或使调试程序崩溃，试图完全阻止调试。在本章中，我们将详细探讨其中一些技术。'
- en: <samp class="SANS_Futura_Std_Bold_B_11">Using Windows API Functions to Access
    the PEB</samp>
  id: totrans-5
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">使用Windows API函数访问PEB</samp>
- en: As you learned in [Chapter 1](chapter1.xhtml), the Process Environment Block
    (PEB) is a structure that contains pointers to information in memory about the
    currently running process. The PEB includes several pointers that are relevant
    to anti-debugging, as listed in [Table 10-1](chapter10.xhtml#tab10-1).
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 如你在[第1章](chapter1.xhtml)中所学到的，进程环境块（PEB）是一个结构，包含指向当前运行进程的内存信息的指针。PEB包括与反调试相关的几个指针，如[表10-1](chapter10.xhtml#tab10-1)所列。
- en: <samp class="SANS_Futura_Std_Heavy_B_11">Table 10-1:</samp> <samp class="SANS_Futura_Std_Book_11">PEB
    Members Relating to Anti-debugging</samp>
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Heavy_B_11">表 10-1:</samp> <samp class="SANS_Futura_Std_Book_11">与反调试相关的PEB成员</samp>
- en: '| <samp class="SANS_Futura_Std_Heavy_B_11">PEB offset</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">PEB
    member</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">Description</samp> |'
  id: totrans-8
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_Futura_Std_Heavy_B_11">PEB偏移量</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">PEB成员</samp>
    | <samp class="SANS_Futura_Std_Heavy_B_11">描述</samp> |'
- en: '| --- | --- | --- |'
  id: totrans-9
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| <samp class="SANS_Futura_Std_Book_11">0x002</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">BeingDebugged</samp>
    | <samp class="SANS_Futura_Std_Book_11">Indicates whether the program is currently
    being debugged</samp> |'
  id: totrans-10
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_Futura_Std_Book_11">0x002</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">BeingDebugged</samp>
    | <samp class="SANS_Futura_Std_Book_11">指示程序当前是否正在被调试</samp> |'
- en: '| <samp class="SANS_Futura_Std_Book_11">0x018</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">ProcessHeap</samp>
    | <samp class="SANS_Futura_Std_Book_11">Contains pointers to the heap’s</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">Flags</samp> <samp class="SANS_Futura_Std_Book_11">and</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">ForceFlags</samp> <samp class="SANS_Futura_Std_Book_11">members</samp>
    |'
  id: totrans-11
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_Futura_Std_Book_11">0x018</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">ProcessHeap</samp>
    | <samp class="SANS_Futura_Std_Book_11">包含指向堆的</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">Flags</samp>
    <samp class="SANS_Futura_Std_Book_11">和</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">ForceFlags</samp>
    <samp class="SANS_Futura_Std_Book_11">成员的指针</samp> |'
- en: '| <samp class="SANS_Futura_Std_Book_11">0x068</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">NtGlobalFlag</samp>
    | <samp class="SANS_Futura_Std_Book_11">Contains information related to the creation
    of memory heaps</samp> |'
  id: totrans-12
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_Futura_Std_Book_11">0x068</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">NtGlobalFlag</samp>
    | <samp class="SANS_Futura_Std_Book_11">包含与内存堆创建相关的信息</samp> |'
- en: Windows exposes a wealth of data about its internal workings to programs via
    its APIs. Some Windows API functions have the sole purpose of telling the calling
    program whether a debugger is attached, and malware can easily exploit this fact
    by having them query the PEB to determine whether it’s being debugged. Not only
    that, but malware can also abuse some API functions to trick Windows into exposing
    an attached debugger. In this section, we’ll look at some common ways in which
    malware can leverage the Windows API and NT API to try to identify a malware analyst
    debugging its code. Later in the chapter, you’ll see how malware can also query
    the PEB directly, which is why it’s important to have at least a basic understanding
    of the PEB’s relevant members.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: Windows通过其API向程序公开了大量有关其内部工作原理的数据。有些Windows API函数的唯一目的是告诉调用程序是否附加了调试器，而恶意软件可以轻松利用这一点，通过查询PEB来确定是否正在进行调试。不仅如此，恶意软件还可以滥用一些API函数，欺骗Windows暴露附加的调试器。在本节中，我们将探讨恶意软件如何利用Windows
    API和NT API来试图识别调试其代码的恶意分析师。稍后章节中，你还将看到恶意软件如何直接查询PEB，这也是为什么至少需要了解PEB相关成员的基本概念。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_I_11">IsDebuggerPresent
    and CheckRemoteDebuggerPresent</samp>
  id: totrans-14
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_I_11">IsDebuggerPresent
    和 CheckRemoteDebuggerPresent</samp>
- en: 'One of the best-known and simplest Windows functions for detecting debuggers
    is <samp class="SANS_TheSansMonoCd_W5Regular_11">IsDebuggerPresent</samp>. This
    function returns a nonzero value if the current process is being debugged; otherwise,
    it returns <samp class="SANS_TheSansMonoCd_W5Regular_11">0</samp>. The <samp class="SANS_TheSansMonoCd_W5Regular_11">CheckRemoteDebuggerPresent</samp>
    function returns the same information, but with a value of <samp class="SANS_TheSansMonoCd_W5Regular_11">True</samp>
    or <samp class="SANS_TheSansMonoCd_W5Regular_11">False</samp>. The following example
    shows how malware might use it:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 最著名且最简单的Windows调试器检测函数之一是<samp class="SANS_TheSansMonoCd_W5Regular_11">IsDebuggerPresent</samp>。如果当前进程正在被调试，这个函数将返回非零值；否则，它将返回<samp
    class="SANS_TheSansMonoCd_W5Regular_11">0</samp>。<samp class="SANS_TheSansMonoCd_W5Regular_11">CheckRemoteDebuggerPresent</samp>函数返回相同的信息，但返回值为<samp
    class="SANS_TheSansMonoCd_W5Regular_11">True</samp>或<samp class="SANS_TheSansMonoCd_W5Regular_11">False</samp>。以下示例展示了恶意软件如何使用它：
- en: '[PRE0]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Two parameters are being pushed to the stack here: a handle to the target process
    (in this case, the malware’s own process, <samp class="SANS_TheSansMonoCd_W5Regular_11">hProcess</samp>)
    followed by a pointer to a variable that will receive the information returned
    (<samp class="SANS_TheSansMonoCd_W5Regular_11">DebuggerPresent</samp>). Once the
    malware calls <samp class="SANS_TheSansMonoCd_W5Regular_11">CheckRemoteDebuggerPresent</samp>,
    the return value (<samp class="SANS_TheSansMonoCd_W5Regular_11">True</samp> or
    <samp class="SANS_TheSansMonoCd_W5Regular_11">False</samp>) is stored in the <samp
    class="SANS_TheSansMonoCd_W5Regular_11">DebuggerPresent</samp> variable. As you’ll
    see later in the chapter, these are some of the easiest debugger detection techniques
    to circumvent.'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有两个参数被压入栈中：一个是目标进程的句柄（在此案例中，是恶意软件自身的进程，<samp class="SANS_TheSansMonoCd_W5Regular_11">hProcess</samp>），另一个是指向一个变量的指针，该变量将接收返回的信息（<samp
    class="SANS_TheSansMonoCd_W5Regular_11">DebuggerPresent</samp>）。一旦恶意软件调用<samp
    class="SANS_TheSansMonoCd_W5Regular_11">CheckRemoteDebuggerPresent</samp>，返回值（<samp
    class="SANS_TheSansMonoCd_W5Regular_11">True</samp>或<samp class="SANS_TheSansMonoCd_W5Regular_11">False</samp>）将被存储在<ssamp
    class="SANS_TheSansMonoCd_W5Regular_11">DebuggerPresent</samp>变量中。如你将在本章后续部分看到的，这些是最容易被规避的调试器检测技术之一。
- en: '#### <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_I_11">NtQueryInformationProcess</samp>'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: '#### <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_I_11">NtQueryInformationProcess</samp>'
- en: To detect a debugger, <samp class="SANS_TheSansMonoCd_W5Regular_11">CheckRemoteDebuggerPresent</samp>
    calls the system function <samp class="SANS_TheSansMonoCd_W5Regular_11">NtQueryInformationProcess</samp>,
    a lower-level Windows NT function that can return a lot of different information
    about the system. <samp class="SANS_TheSansMonoCd_W5Regular_11">NtQueryInformationProcess</samp>
    can also be called directly. It takes several parameters, including <samp class="SANS_TheSansMonoCd_W5Regular_11">ProcessHandle</samp>
    (a handle to the target process) and the <samp class="SANS_TheSansMonoCd_W5Regular_11">ProcessInformationClass</samp>
    value (the type of information that should be returned). In the case of debugger
    detection, the <samp class="SANS_TheSansMonoCd_W5Regular_11">ProcessInformationClass</samp>
    value would be <samp class="SANS_TheSansMonoCd_W5Regular_11">7</samp>, or <samp
    class="SANS_TheSansMonoCd_W5Regular_11">ProcessDebugPort</samp>. A nonzero value
    indicates that the process is currently running under a debugger.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 要检测调试器，<samp class="SANS_TheSansMonoCd_W5Regular_11">CheckRemoteDebuggerPresent</samp>
    会调用系统函数 <samp class="SANS_TheSansMonoCd_W5Regular_11">NtQueryInformationProcess</samp>，这是一个低级的
    Windows NT 函数，可以返回关于系统的很多不同信息。<samp class="SANS_TheSansMonoCd_W5Regular_11">NtQueryInformationProcess</samp>
    也可以直接调用。它需要多个参数，包括 <samp class="SANS_TheSansMonoCd_W5Regular_11">ProcessHandle</samp>（目标进程的句柄）和
    <samp class="SANS_TheSansMonoCd_W5Regular_11">ProcessInformationClass</samp> 值（应该返回的信息类型）。在调试器检测的情况下，<samp
    class="SANS_TheSansMonoCd_W5Regular_11">ProcessInformationClass</samp> 的值应该是 <samp
    class="SANS_TheSansMonoCd_W5Regular_11">7</samp>，或者是 <samp class="SANS_TheSansMonoCd_W5Regular_11">ProcessDebugPort</samp>。如果返回非零值，表示进程当前在调试器下运行。
- en: Alternatively, the malware author can specify <samp class="SANS_TheSansMonoCd_W5Regular_11">ProcessInformationClass
    ProcessDebugFlags</samp> (<samp class="SANS_TheSansMonoCd_W5Regular_11">1F</samp>).
    If the process is being debugged, the debug flags will be set, tipping off the
    malware. Finally, the <samp class="SANS_TheSansMonoCd_W5Regular_11">ProcessDebugObjectHandle</samp>
    (<samp class="SANS_TheSansMonoCd_W5Regular_11">1E</samp>) information class can
    also reveal a debugger.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 另外，恶意软件作者可以指定 <samp class="SANS_TheSansMonoCd_W5Regular_11">ProcessInformationClass
    ProcessDebugFlags</samp>（<samp class="SANS_TheSansMonoCd_W5Regular_11">1F</samp>）。如果进程正在被调试，调试标志会被设置，从而向恶意软件发出信号。最后，<samp
    class="SANS_TheSansMonoCd_W5Regular_11">ProcessDebugObjectHandle</samp>（<samp
    class="SANS_TheSansMonoCd_W5Regular_11">1E</samp>）信息类也可以揭示调试器的存在。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_I_11">NtQuerySystemInformation</samp>
  id: totrans-21
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_I_11">NtQuerySystemInformation</samp>
- en: '<samp class="SANS_TheSansMonoCd_W5Regular_11">NtQuerySystemInformation</samp>
    is a Windows NT function that can be used to, you guessed it, query system information.
    This function can return many different types of information, and an especially
    crucial structure for our purposes is <samp class="SANS_TheSansMonoCd_W5Regular_11">SYSTEM_KERNEL_DEBUGGER_INFORMATION</samp>.
    This structure contains two important values for debugger detection: <samp class="SANS_TheSansMonoCd_W5Regular_11">KdDebuggerEnabled</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">KdDebuggerNotPresent</samp>,
    both of which can be used to detect a kernel debugger attached to the calling
    process. *Kernel debuggers* are specialized tools for debugging low-level software
    and sometimes for malware analysis. If <samp class="SANS_TheSansMonoCd_W5Regular_11">KdDebuggerEnabled</samp>
    returns nonzero or <samp class="SANS_TheSansMonoCd_W5Regular_11">KdDebuggerNotPresent</samp>
    returns <samp class="SANS_TheSansMonoCd_W5Regular_11">0</samp>, it might indicate
    to the malware that a kernel debugger is present.'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W5Regular_11">NtQuerySystemInformation</samp>
    是一个 Windows NT 函数，用于查询系统信息。这个函数可以返回多种不同类型的信息，而对于我们来说，尤其关键的结构是 <samp class="SANS_TheSansMonoCd_W5Regular_11">SYSTEM_KERNEL_DEBUGGER_INFORMATION</samp>。这个结构包含了两个重要的值，用于调试器检测：<samp
    class="SANS_TheSansMonoCd_W5Regular_11">KdDebuggerEnabled</samp> 和 <samp class="SANS_TheSansMonoCd_W5Regular_11">KdDebuggerNotPresent</samp>，这两者都可以用来检测内核调试器是否附加到调用进程上。*内核调试器*
    是用于调试低级软件的专用工具，有时也用于恶意软件分析。如果 <samp class="SANS_TheSansMonoCd_W5Regular_11">KdDebuggerEnabled</samp>
    返回非零值，或者 <samp class="SANS_TheSansMonoCd_W5Regular_11">KdDebuggerNotPresent</samp>
    返回 <samp class="SANS_TheSansMonoCd_W5Regular_11">0</samp>，可能意味着恶意软件检测到一个内核调试器存在。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_I_11">OutputDebugString</samp>
  id: totrans-23
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_I_11">OutputDebugString</samp>
- en: 'The <samp class="SANS_TheSansMonoCd_W5Regular_11">OutputDebugString</samp>
    function simply displays a string in the debugger. If a process is attached to
    a debugger, the string will be displayed; if not, <samp class="SANS_TheSansMonoCd_W5Regular_11">OutputDebugString</samp>
    will return with an error. Malware can abuse this function by manually setting
    an error code using <samp class="SANS_TheSansMonoCd_W5Regular_11">SetLastError</samp>
    (this error can be any arbitrary value), calling <samp class="SANS_TheSansMonoCd_W5Regular_11">OutputDebugString</samp>
    with a random string value, and then calling <samp class="SANS_TheSansMonoCd_W5Regular_11">GetLastError</samp>
    to check whether the error state has changed, as demonstrated in the following
    pseudocode:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W5Regular_11">OutputDebugString</samp>函数仅仅是在调试器中显示一个字符串。如果进程附加了调试器，该字符串将会显示；如果没有，<samp
    class="SANS_TheSansMonoCd_W5Regular_11">OutputDebugString</samp>将返回错误。恶意软件可以通过手动使用<samp
    class="SANS_TheSansMonoCd_W5Regular_11">SetLastError</samp>设置一个错误代码（这个错误可以是任何任意值），然后调用<samp
    class="SANS_TheSansMonoCd_W5Regular_11">OutputDebugString</samp>并传递一个随机字符串值，再调用<samp
    class="SANS_TheSansMonoCd_W5Regular_11">GetLastError</samp>检查错误状态是否发生变化，示例如下的伪代码：
- en: '[PRE1]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: This malware sample sets an error code of <samp class="SANS_TheSansMonoCd_W5Regular_11">5</samp>
    using <samp class="SANS_TheSansMonoCd_W5Regular_11">SetLastError</samp>, then
    invokes <samp class="SANS_TheSansMonoCd_W5Regular_11">OutputDebugString</samp>
    with the random string value <samp class="SANS_TheSansMonoCd_W5Regular_11">testing123</samp>.
    Next, the malware calls <samp class="SANS_TheSansMonoCd_W5Regular_11">GetLastError</samp>
    to get the last error code and compares that value to the error code from the
    previous <samp class="SANS_TheSansMonoCd_W5Regular_11">SetLastError</samp> call.
    If the call to <samp class="SANS_TheSansMonoCd_W5Regular_11">OutputDebugString</samp>
    succeeded with no error, the <samp class="SANS_TheSansMonoCd_W5Regular_11">GetLastError</samp>
    code should still be <samp class="SANS_TheSansMonoCd_W5Regular_11">5</samp>, meaning
    that a debugger is present. This is an old technique, but malware occasionally
    still attempts to use it.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 这个恶意软件样本使用<samp class="SANS_TheSansMonoCd_W5Regular_11">SetLastError</samp>设置一个错误代码为<samp
    class="SANS_TheSansMonoCd_W5Regular_11">5</samp>，然后调用<samp class="SANS_TheSansMonoCd_W5Regular_11">OutputDebugString</samp>并传入随机字符串值<samp
    class="SANS_TheSansMonoCd_W5Regular_11">testing123</samp>。接着，恶意软件调用<samp class="SANS_TheSansMonoCd_W5Regular_11">GetLastError</samp>获取最后的错误代码，并将其与之前<samp
    class="SANS_TheSansMonoCd_W5Regular_11">SetLastError</samp>调用的错误代码进行比较。如果调用<samp
    class="SANS_TheSansMonoCd_W5Regular_11">OutputDebugString</samp>成功且没有错误，则<samp
    class="SANS_TheSansMonoCd_W5Regular_11">GetLastError</samp>的代码仍应为<samp class="SANS_TheSansMonoCd_W5Regular_11">5</samp>，这意味着调试器存在。这是一个老技巧，但恶意软件偶尔仍会尝试使用它。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_I_11">CloseHandle and NtClose</samp>
  id: totrans-27
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_I_11">CloseHandle 和 NtClose</samp>
- en: 'If a malware sample is being debugged and the malware attempts to call the
    <samp class="SANS_TheSansMonoCd_W5Regular_11">CloseHandle</samp> or <samp class="SANS_TheSansMonoCd_W5Regular_11">NtClose</samp>
    function with an invalid handle, it will raise an <samp class="SANS_TheSansMonoCd_W5Regular_11">EXCEPTION_INVALID_HANDLE</samp>
    exception. Once this exception is triggered, it will be passed to the debugger’s
    exception handler, tipping off the malware that it is being debugged. The following
    simple code demonstrates this:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 如果正在调试一个恶意软件样本，并且恶意软件试图使用无效句柄调用<samp class="SANS_TheSansMonoCd_W5Regular_11">CloseHandle</samp>或<samp
    class="SANS_TheSansMonoCd_W5Regular_11">NtClose</samp>函数，它将引发一个<samp class="SANS_TheSansMonoCd_W5Regular_11">EXCEPTION_INVALID_HANDLE</samp>异常。一旦这个异常被触发，它将被传递到调试器的异常处理程序，提示恶意软件它正在被调试。以下简单代码演示了这一过程：
- en: '[PRE2]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The preceding code calls <samp class="SANS_TheSansMonoCd_W5Regular_11">NtClose</samp>
    with an invalid handle as a parameter. Once executed, this will raise an exception
    and tip off the malware that it is being debugged.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码调用<samp class="SANS_TheSansMonoCd_W5Regular_11">NtClose</samp>并传递一个无效的句柄作为参数。一旦执行，这将引发一个异常，并提示恶意软件它正在被调试。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_I_11">NtQueryObject</samp>
  id: totrans-31
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_I_11">NtQueryObject</samp>
- en: For a debugger to work properly, it must create a special kernel object called
    a *debug object*. Malware can call <samp class="SANS_TheSansMonoCd_W5Regular_11">NtQueryObject</samp>
    to get a list of all debug objects, whose presence would indicate either that
    the malware is currently being debugged or that the host has used a debugger in
    the past.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使调试器正常工作，它必须创建一个名为*调试对象*的特殊内核对象。恶意软件可以调用<samp class="SANS_TheSansMonoCd_W5Regular_11">NtQueryObject</samp>获取所有调试对象的列表，调试对象的存在意味着恶意软件当前正在被调试，或者主机曾经使用过调试器。
- en: The first parameter for this function, <samp class="SANS_TheSansMonoCd_W5Regular_11">Handle</samp>,
    is the handle to the object being queried for information. The second parameter,
    <samp class="SANS_TheSansMonoCd_W5Regular_11">NtQueryObject</samp>, accepts an
    <samp class="SANS_TheSansMonoCd_W5Regular_11">ObjectInformationClass</samp> value
    that will tell the function what type of data needs to be returned. The third
    parameter, <samp class="SANS_TheSansMonoCd_W5Regular_11">ObjectInformation</samp>,
    accepts a pointer to where the returned data will be stored.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 该函数的第一个参数，<samp class="SANS_TheSansMonoCd_W5Regular_11">Handle</samp>，是查询信息的对象的句柄。第二个参数，<samp
    class="SANS_TheSansMonoCd_W5Regular_11">NtQueryObject</samp>，接受一个<sup class="SANS_TheSansMonoCd_W5Regular_11">ObjectInformationClass</samp>值，该值告诉函数需要返回何种类型的数据。第三个参数，<samp
    class="SANS_TheSansMonoCd_W5Regular_11">ObjectInformation</samp>，接受一个指针，指向存储返回数据的位置。
- en: If you spot malware calling <samp class="SANS_TheSansMonoCd_W5Regular_11">NtQueryObject</samp>,
    providing an <samp class="SANS_TheSansMonoCd_W5Regular_11">ObjectInformationClass</samp>
    value of <samp class="SANS_TheSansMonoCd_W5Regular_11">3</samp> (<samp class="SANS_TheSansMonoCd_W5Regular_11">ObjectAllTypesInformation</samp>),
    and then inspecting the <samp class="SANS_TheSansMonoCd_W5Regular_11">ObjectInformation</samp>
    buffer for strings such as <samp class="SANS_TheSansMonoCd_W5Regular_11">DebugObject</samp>,
    you can be relatively certain the malware is attempting to identify a debugger.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你发现恶意软件调用了<samp class="SANS_TheSansMonoCd_W5Regular_11">NtQueryObject</samp>，并提供了一个<sup
    class="SANS_TheSansMonoCd_W5Regular_11">ObjectInformationClass</samp>值为<sup class="SANS_TheSansMonoCd_W5Regular_11">3</samp>（<sup
    class="SANS_TheSansMonoCd_W5Regular_11">ObjectAllTypesInformation</samp>），然后检查<sup
    class="SANS_TheSansMonoCd_W5Regular_11">ObjectInformation</samp>缓冲区中的字符串，如<samp
    class="SANS_TheSansMonoCd_W5Regular_11">DebugObject</samp>，你可以相对确定恶意软件正在尝试识别调试器。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_I_11">Heap Flags</samp>
  id: totrans-35
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_I_11">堆标志</samp>
- en: The PEB contains pointers to the process’s memory heap structure, known as the
    *process heap*, at location 0x18 (0x30 for 64-bit processes). The process heap
    contains various members that are pointers to additional data; two of these members
    are <samp class="SANS_TheSansMonoCd_W5Regular_11">Flags</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">ForceFlags</samp>,
    which point to a block of data that provides information to the Windows kernel
    about the process heap memory. In Windows 7 and above, if a process is being debugged,
    the value of the <samp class="SANS_TheSansMonoCd_W5Regular_11">Flags</samp> member
    will be <samp class="SANS_TheSansMonoCd_W5Regular_11">0x40000062</samp>, and the
    value of the <samp class="SANS_TheSansMonoCd_W5Regular_11">ForceFlags</samp> member
    will be <samp class="SANS_TheSansMonoCd_W5Regular_11">0x40000060</samp>. To detect
    a debugger, malware may attempt to read these values in its heap structure by
    calling the function <samp class="SANS_TheSansMonoCd_W5Regular_11">RtlQueryProcessHeapInformation</samp>
    or <samp class="SANS_TheSansMonoCd_W5Regular_11">RtlQueryProcessDebugInformation</samp>,
    or it may manually read the PEB as we’ll discuss in the next section.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: PEB包含指向进程内存堆结构的指针，称为*进程堆*，位于位置0x18（64位进程为0x30）。进程堆包含多个成员，这些成员是指向附加数据的指针；其中两个成员是<sup
    class="SANS_TheSansMonoCd_W5Regular_11">Flags</samp>和<sup class="SANS_TheSansMonoCd_W5Regular_11">ForceFlags</samp>，它们指向一个数据块，提供有关进程堆内存的信息给Windows内核。在Windows
    7及以上版本中，如果进程正在调试，<samp class="SANS_TheSansMonoCd_W5Regular_11">Flags</samp>成员的值将为<sup
    class="SANS_TheSansMonoCd_W5Regular_11">0x40000062</samp>，<sup class="SANS_TheSansMonoCd_W5Regular_11">ForceFlags</samp>成员的值将为<sup
    class="SANS_TheSansMonoCd_W5Regular_11">0x40000060</samp>。为了检测调试器，恶意软件可能会通过调用函数<samp
    class="SANS_TheSansMonoCd_W5Regular_11">RtlQueryProcessHeapInformation</samp>或<samp
    class="SANS_TheSansMonoCd_W5Regular_11">RtlQueryProcessDebugInformation</samp>尝试读取堆结构中的这些值，或者它可能会手动读取PEB，如下一节中所讨论的。
- en: This isn’t a common anti-debugging technique, so I won’t go into further detail
    here, but it’s important to be aware that it exists. If you spot malware calling
    one or both of these functions, inspect the code that follows. If the malware
    is querying the <samp class="SANS_TheSansMonoCd_W5Regular_11">Flags</samp> or
    <samp class="SANS_TheSansMonoCd_W5Regular_11">ForceFlags</samp> member, there’s
    a good chance it’s trying to detect your debugger.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 这不是一种常见的反调试技术，所以我在这里不再详细介绍，但了解它的存在是很重要的。如果你发现恶意软件调用了其中一个或两个函数，检查后续的代码。如果恶意软件正在查询<sup
    class="SANS_TheSansMonoCd_W5Regular_11">Flags</samp>或<sup class="SANS_TheSansMonoCd_W5Regular_11">ForceFlags</samp>成员，那么很有可能它正在尝试检测你的调试器。
- en: <samp class="SANS_Futura_Std_Bold_B_11">Directly Accessing the PEB</samp>
  id: totrans-38
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">直接访问PEB</samp>
- en: 'Rather than relying on the Windows functions described in the previous section,
    malware might directly access and read the PEB, as shown in the following assembly
    code:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 恶意软件可能直接访问和读取 PEB，而不是依赖于前一节中描述的 Windows 函数，如以下汇编代码所示：
- en: '[PRE3]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Here, in order to obtain the address of the PEB to read it, the malware moves
    the address at <samp class="SANS_TheSansMonoCd_W5Regular_11">fs:0x30</samp> into
    <samp class="SANS_TheSansMonoCd_W5Regular_11">eax</samp>. (As you might recall
    from [Chapter 1](chapter1.xhtml), <samp class="SANS_TheSansMonoCd_W5Regular_11">fs:0x30</samp>
    is the address for the beginning of the PEB.) Next, the malware compares the value
    of <samp class="SANS_TheSansMonoCd_W5Regular_11">1</samp> to the value of <samp
    class="SANS_TheSansMonoCd_W5Regular_11">eax+0x2</samp>, which is the <samp class="SANS_TheSansMonoCd_W5Regular_11">BeingDebugged</samp>
    field in the PEB structure. If this value is <samp class="SANS_TheSansMonoCd_W5Regular_11">1</samp>,
    it’s likely that a debugger is attached to the process, and the malware might
    respond accordingly.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，为了获取 PEB 的地址以读取它，恶意软件将 <samp class="SANS_TheSansMonoCd_W5Regular_11">fs:0x30</samp>
    的地址移动到 <samp class="SANS_TheSansMonoCd_W5Regular_11">eax</samp> 中。（如你在[第1章](chapter1.xhtml)中所回忆，<samp
    class="SANS_TheSansMonoCd_W5Regular_11">fs:0x30</samp> 是 PEB 起始位置的地址。）接下来，恶意软件将
    <samp class="SANS_TheSansMonoCd_W5Regular_11">1</samp> 与 <samp class="SANS_TheSansMonoCd_W5Regular_11">eax+0x2</samp>
    的值进行比较，后者是 PEB 结构中的 <samp class="SANS_TheSansMonoCd_W5Regular_11">BeingDebugged</samp>
    字段。如果该值为 <samp class="SANS_TheSansMonoCd_W5Regular_11">1</samp>，则很可能有调试器附加到该进程，恶意软件可能会相应地做出反应。
- en: Another example of manual PEB reading involves the <samp class="SANS_TheSansMonoCd_W5Regular_11">NtGlobalFlag</samp>,
    which is located at byte 0x68 in the PEB and contains information related to the
    creation of memory heaps. When a process is started under a debugger, the value
    of <samp class="SANS_TheSansMonoCd_W5Regular_11">NtGlobalFlag</samp> will be <samp
    class="SANS_TheSansMonoCd_W5Regular_11">0x70</samp>, so malware can read that
    value in its PEB for a quick debugger check.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个手动读取 PEB 的例子涉及到 <samp class="SANS_TheSansMonoCd_W5Regular_11">NtGlobalFlag</samp>，它位于
    PEB 中字节 0x68 处，包含与内存堆创建相关的信息。当进程在调试器下启动时，<samp class="SANS_TheSansMonoCd_W5Regular_11">NtGlobalFlag</samp>
    的值将为 <samp class="SANS_TheSansMonoCd_W5Regular_11">0x70</samp>，因此恶意软件可以读取其 PEB
    中的该值进行快速的调试器检查。
- en: Keep in mind that malware can query any member of the PEB structure in this
    manner. Accessing the PEB directly, rather than invoking common Windows functions
    in order to do so, can be an effective way for malware to detect a debugger without
    raising alarms.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，恶意软件可以通过这种方式查询 PEB 结构的任何成员。直接访问 PEB，而不是调用常见的 Windows 函数来实现这一点，可能是恶意软件在不引起警报的情况下检测调试器的有效方法。
- en: <samp class="SANS_Futura_Std_Bold_B_11">Timing Checks</samp>
  id: totrans-44
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">时序检查</samp>
- en: '[Chapter 7](chapter7.xhtml) described timing checks specifically in the context
    of detecting sandboxes and VM environments, but these checks can also be used
    to detect debuggers. Three of the common timing-based methods for debugger detection
    are <samp class="SANS_TheSansMonoCd_W5Regular_11">GetTickCount</samp>, the <samp
    class="SANS_TheSansMonoCd_W5Regular_11">rdtsc</samp> instruction, and system time
    checks.'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: '[第7章](chapter7.xhtml)描述了时序检查，特别是在检测沙箱和虚拟机环境中的应用，但这些检查也可以用来检测调试器。检测调试器的三种常见时序方法是
    <samp class="SANS_TheSansMonoCd_W5Regular_11">GetTickCount</samp>、<samp class="SANS_TheSansMonoCd_W5Regular_11">rdtsc</samp>
    指令和系统时间检查。'
- en: As you might remember from [Chapter 5](chapter5.xhtml), <samp class="SANS_TheSansMonoCd_W5Regular_11">GetTickCount</samp>
    returns the number of milliseconds that have elapsed since system boot-up. Malware
    can call <samp class="SANS_TheSansMonoCd_W5Regular_11">GetTickCount</samp> at
    various points in its code to see how much time has elapsed since its last call
    to this function. When malware is being debugged, the program will naturally execute
    more slowly, especially if the malware analyst is setting breakpoints throughout
    the debugging process. If the analyst happens to place a breakpoint on a function
    or is single-stepping through code, the difference between the first call of <samp
    class="SANS_TheSansMonoCd_W5Regular_11">GetTickCount</samp> and the last will
    be much greater than it would be otherwise. Malware can exploit this fact to detect
    a debugger.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你可能还记得的 [第5章](chapter5.xhtml) 中所提到的，<samp class="SANS_TheSansMonoCd_W5Regular_11">GetTickCount</samp>
    返回自系统启动以来经过的毫秒数。恶意软件可以在其代码的不同位置调用 <samp class="SANS_TheSansMonoCd_W5Regular_11">GetTickCount</samp>
    来查看自上次调用此函数以来经过了多少时间。当恶意软件正在被调试时，程序自然会变得更慢，尤其是当恶意软件分析师在整个调试过程中设置了断点。如果分析师恰好在某个函数上设置了断点，或者在逐步执行代码时，<samp
    class="SANS_TheSansMonoCd_W5Regular_11">GetTickCount</samp> 的第一次调用和最后一次调用之间的时间差将远大于平常。恶意软件可以利用这一点来检测是否存在调试器。
- en: Malware can use the <samp class="SANS_TheSansMonoCd_W5Regular_11">rdtsc</samp>
    instruction in a similar manner. By placing <samp class="SANS_TheSansMonoCd_W5Regular_11">rdtsc</samp>
    instructions throughout its code, malware can determine whether it’s being debugged
    based on CPU timing (see the x64dbg screenshot in [Figure 10-1](chapter10.xhtml#fig10-1)).
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 恶意软件也可以以类似的方式使用 <samp class="SANS_TheSansMonoCd_W5Regular_11">rdtsc</samp> 指令。通过在其代码中各个位置插入
    <samp class="SANS_TheSansMonoCd_W5Regular_11">rdtsc</samp> 指令，恶意软件可以通过 CPU 定时来判断自己是否正在被调试（参见
    [图10-1](chapter10.xhtml#fig10-1) 中的 x64dbg 截图）。
- en: '![](../images/fig10-1.jpg)'
  id: totrans-48
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/fig10-1.jpg)'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 10-1: Malware using
    rdtsc as an anti-debugging technique</samp>'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">图10-1：恶意软件使用 rdtsc 作为反调试技术</samp>
- en: Finally, malware can simply query the system time by calling functions such
    as <samp class="SANS_TheSansMonoCd_W5Regular_11">GetLocalTime</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">GetSystemTime</samp>,
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">NtQuerySystemTime</samp> at
    various points in its code to detect a debugger in use.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，恶意软件可以通过调用诸如 <samp class="SANS_TheSansMonoCd_W5Regular_11">GetLocalTime</samp>、<samp
    class="SANS_TheSansMonoCd_W5Regular_11">GetSystemTime</samp> 和 <samp class="SANS_TheSansMonoCd_W5Regular_11">NtQuerySystemTime</samp>
    等函数，在其代码中的各个位置查询系统时间，以检测是否正在使用调试器。
- en: There are many other methods of using timing checks to catch a debugger in its
    tracks; these are only some of the most common. The takeaway here is that if you
    spot malware that is occasionally calling timing functions or using instructions
    such as <samp class="SANS_TheSansMonoCd_W5Regular_11">rdtsc</samp> throughout
    its code, it could be using anti-debugging techniques. The best way to address
    this is to simply avoid using a debugger. However, this isn’t always practical.
    You may have to identify where these functions and instructions are being executed
    in the malware and patch them out, or you may modify their return values to trick
    the malware into believing it’s not being debugged.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 还有许多其他使用时间检查来捕捉调试器的方法，这里列出的只是其中一些最常见的方法。这里的重点是，如果你发现恶意软件偶尔调用时间函数或在代码中使用诸如 <samp
    class="SANS_TheSansMonoCd_W5Regular_11">rdtsc</samp> 这样的指令，它可能正在使用反调试技术。解决这个问题的最好方法是干脆避免使用调试器。然而，这并不总是可行的。你可能需要找出这些函数和指令在恶意软件中的执行位置，并将其修补，或者修改它们的返回值，欺骗恶意软件让其相信自己没有被调试。
- en: <samp class="SANS_Futura_Std_Bold_B_11">System Artifacts</samp>
  id: totrans-52
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">系统人工制品</samp>
- en: Malware may be able to detect a debugger via system artifacts such as desktop
    windows, registry keys, and loaded modules. We’ll cover each briefly in this section,
    but you might also find it helpful to refer back to [Part II](part2.xhtml), which
    covered how malware might search for these types of artifacts.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 恶意软件可能通过系统的人工制品（如桌面窗口、注册表键和值、已加载的模块等）来检测调试器。在本节中，我们将简要介绍这些内容，但你可能会觉得参考 [第二部分](part2.xhtml)
    更有帮助，第二部分详细讨论了恶意软件如何搜索这些类型的人工制品。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_I_11">Hunting for Debugger
    Windows</samp>
  id: totrans-54
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_I_11">寻找调试器窗口</samp>
- en: '[Chapter 5](chapter5.xhtml) discussed how malware can detect analyst tools
    using functions such as <samp class="SANS_TheSansMonoCd_W5Regular_11">FindWindow</samp>,
    which locates a desktop window, and <samp class="SANS_TheSansMonoCd_W5Regular_11">EnumWindows</samp>,
    which enumerates open desktop windows. Malware can also use these functions to
    look specifically for debugger windows. For example, it might call <samp class="SANS_TheSansMonoCd_W5Regular_11">FindWindow</samp>
    to enumerate open windows with debugger product names such as x64dbg, OllyDbg,
    or Immunity debugger. [Figure 10-2](chapter10.xhtml#fig10-2) shows the ransomware
    variant Satan hunting for any open OllyDbg windows.'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: '[第5章](chapter5.xhtml)讨论了恶意软件如何利用诸如<samp class="SANS_TheSansMonoCd_W5Regular_11">FindWindow</samp>等函数检测分析工具，该函数用于定位桌面窗口，以及<samp
    class="SANS_TheSansMonoCd_W5Regular_11">EnumWindows</samp>，它用于枚举打开的桌面窗口。恶意软件还可以使用这些函数专门查找调试器窗口。例如，它可能会调用<samp
    class="SANS_TheSansMonoCd_W5Regular_11">FindWindow</samp>来枚举带有调试器产品名称的打开窗口，例如x64dbg、OllyDbg或Immunity调试器。[图10-2](chapter10.xhtml#fig10-2)展示了勒索软件变种Satan在寻找任何打开的OllyDbg窗口。'
- en: '![](../images/fig10-2.jpg)'
  id: totrans-56
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/fig10-2.jpg)'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 10-2: The malware Satan
    looking for OllyDbg-related windows</samp>'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">图10-2：恶意软件Satan寻找与OllyDbg相关的窗口</samp>
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_I_11">Enumerating Loaded
    Modules</samp>
  id: totrans-58
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_I_11">枚举加载的模块</samp>
- en: When you attach malware to a debugger, the debugger may load modules into the
    malware’s address space; for example, the WinDbg debugger may load the *dbghelp.dll*
    library. Malware can locate a suspect module by calling the <samp class="SANS_TheSansMonoCd_W5Regular_11">GetModuleHandle</samp>
    function and passing the module’s name (such as *dbghelp.dll*) as a parameter.
    Alternatively, it can enumerate all loaded modules by using <samp class="SANS_TheSansMonoCd_W5Regular_11">Module32First</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">Module32Next</samp> and then
    search for a specific module name.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 当你将恶意软件附加到调试器时，调试器可能会将模块加载到恶意软件的地址空间中；例如，WinDbg调试器可能会加载*dbghelp.dll*库。恶意软件可以通过调用<samp
    class="SANS_TheSansMonoCd_W5Regular_11">GetModuleHandle</samp>函数，并传递模块名称（如*dbghelp.dll*）作为参数，来定位可疑模块。或者，它可以通过使用<samp
    class="SANS_TheSansMonoCd_W5Regular_11">Module32First</samp>和<samp class="SANS_TheSansMonoCd_W5Regular_11">Module32Next</samp>枚举所有加载的模块，然后搜索特定的模块名称。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_I_11">Searching for Debugger
    Processes</samp>
  id: totrans-60
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_I_11">搜索调试器进程</samp>
- en: Malware can also enumerate the running processes on the host to search for debugger
    processes. To do so, it might call <samp class="SANS_TheSansMonoCd_W5Regular_11">CreateToolhelp32Snapshot</samp>,
    <samp class="SANS_TheSansMonoCd_W5Regular_11">Process32First</samp>, and <samp
    class="SANS_TheSansMonoCd_W5Regular_11">Process32Next</samp>, then look specifically
    for common debugger process names, such as *ollydbg.exe*, *x64dbg.exe*, or *ida64.exe*.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 恶意软件还可以枚举主机上运行的进程，查找调试器进程。为此，它可能会调用<samp class="SANS_TheSansMonoCd_W5Regular_11">CreateToolhelp32Snapshot</samp>、<samp
    class="SANS_TheSansMonoCd_W5Regular_11">Process32First</samp>和<samp class="SANS_TheSansMonoCd_W5Regular_11">Process32Next</samp>，然后专门查找常见的调试器进程名称，如*ollydbg.exe*、*x64dbg.exe*或*ida64.exe*。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_I_11">Checking Parent Processes</samp>
  id: totrans-62
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_I_11">检查父进程</samp>
- en: To detect a debugger, malware can check to see what its parent process is. If
    the malware is running inside a debugger, its parent process will be the debugger
    process. If the malware detects it is running as a child process of a debugger
    process (such as *x64dbg.exe*), the malware will identify that it is being debugged.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 为了检测调试器，恶意软件可以检查其父进程是什么。如果恶意软件运行在调试器内部，它的父进程将是调试器进程。如果恶意软件检测到它作为调试器进程的子进程运行（例如*x64dbg.exe*），那么它就能识别出自己正在被调试。
- en: Malware can detect its parent process in a few ways. One approach is to obtain
    its own process ID (<samp class="SANS_TheSansMonoCd_W5Regular_11">GetCurrentProcessId</samp>),
    take a snapshot of all running processes (<samp class="SANS_TheSansMonoCd_W5Regular_11">CreateToolhelp32Snapshot</samp>),
    and use <samp class="SANS_TheSansMonoCd_W5Regular_11">Process32First</samp> and
    <samp class="SANS_TheSansMonoCd_W5Regular_11">Proces32Next</samp> to search for
    its own process name. Once it finds its process, the process snapshot structure
    contains an entry (<samp class="SANS_TheSansMonoCd_W5Regular_11">th32ParentProcessID</samp>)
    representing its parent process ID.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 恶意软件可以通过几种方式检测其父进程。一种方法是获取自身的进程ID (<samp class="SANS_TheSansMonoCd_W5Regular_11">GetCurrentProcessId</samp>)，获取所有运行中的进程快照
    (<samp class="SANS_TheSansMonoCd_W5Regular_11">CreateToolhelp32Snapshot</samp>)，并使用
    <samp class="SANS_TheSansMonoCd_W5Regular_11">Process32First</samp> 和 <samp class="SANS_TheSansMonoCd_W5Regular_11">Proces32Next</samp>
    搜索其自身的进程名。一旦找到其进程，进程快照结构中将包含一个条目 (<samp class="SANS_TheSansMonoCd_W5Regular_11">th32ParentProcessID</samp>)，表示其父进程的ID。
- en: Similarly, malware could spawn a child process using <samp class="SANS_TheSansMonoCd_W5Regular_11">CreateProcess</samp>,
    making the malware’s original process the parent process of this new child. The
    child process could then invoke <samp class="SANS_TheSansMonoCd_W5Regular_11">DebugActiveProcess</samp>
    with its parent process as a parameter. If the parent process (the original malware
    process) is already being debugged, this function will throw an exception such
    as <samp class="SANS_TheSansMonoCd_W5Regular_11">STATUS_PORT_ALREADY_SET</samp>,
    cluing in the malware that there’s a debugger attached to it.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 类似地，恶意软件可以使用 <samp class="SANS_TheSansMonoCd_W5Regular_11">CreateProcess</samp>
    创建一个子进程，使得恶意软件的原始进程成为这个新子进程的父进程。然后，子进程可以调用 <samp class="SANS_TheSansMonoCd_W5Regular_11">DebugActiveProcess</samp>，并将其父进程作为参数。如果父进程（即原始的恶意软件进程）已经在调试中，那么这个函数将抛出一个异常，如
    <samp class="SANS_TheSansMonoCd_W5Regular_11">STATUS_PORT_ALREADY_SET</samp>，这让恶意软件意识到它正被调试器监控。
- en: '### <samp class="SANS_Futura_Std_Bold_B_11">Breakpoint Detection and Traps</samp>'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: '### <samp class="SANS_Futura_Std_Bold_B_11">断点检测与陷阱</samp>'
- en: When investigating malware in a debugger, a malware analyst commonly creates
    breakpoints on specific instructions, function calls, or specific memory segments.
    As you might remember from [Chapter 3](chapter3.xhtml), the act of creating software
    breakpoints in the malware’s code modifies the running malware sample. This means
    that the malware can detect these breakpoints in some interesting ways. This section
    will discuss some of the breakpoint detection, circumvention, and exploitation
    methods malware might employ.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 在调试器中调查恶意软件时，恶意软件分析师通常会在特定的指令、函数调用或特定的内存段上创建断点。正如你可能记得的那样，来自[第3章](chapter3.xhtml)，在恶意软件代码中创建软件断点会修改正在运行的恶意软件样本。这意味着恶意软件可以通过一些有趣的方式检测这些断点。本节将讨论恶意软件可能采用的一些断点检测、规避和利用方法。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_I_11">Detecting Debuggers
    with Breakpoints</samp>
  id: totrans-68
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_I_11">通过断点检测调试器</samp>
- en: When a debugger hits a breakpoint instruction such as <samp class="SANS_TheSansMonoCd_W5Regular_11">int
    3</samp> (one of the most common) in a program, it breaks at that point in the
    program’s code. This occurs because the breakpoint instruction causes an interrupt
    exception in the program, which ultimately transfers control to the debugger.
    When a program is not being debugged, however, breakpoint instructions cause an
    <samp class="SANS_TheSansMonoCd_W5Regular_11">EXCEPTION_BREAKPOINT</samp> and
    the control flow is passed to the program’s default exception handler.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 当调试器在程序中的某个断点指令（如 <samp class="SANS_TheSansMonoCd_W5Regular_11">int 3</samp>，这是最常见的断点之一）处停下时，它会在程序代码的这一点上中断。这是因为断点指令会导致程序发生中断异常，最终将控制权转交给调试器。然而，当程序没有被调试时，断点指令会引发
    <samp class="SANS_TheSansMonoCd_W5Regular_11">EXCEPTION_BREAKPOINT</samp>，控制流则会传递给程序的默认异常处理程序。
- en: 'This is a great way for malware to test whether it’s being debugged. If malware
    executes the instruction <samp class="SANS_TheSansMonoCd_W5Regular_11">int 3</samp>
    and it’s not being debugged, an <samp class="SANS_TheSansMonoCd_W5Regular_11">EXCEPTION_BREAKPOINT</samp>
    will be raised and the exception handler will be invoked. Of course, the opposite
    is also true. If this <samp class="SANS_TheSansMonoCd_W5Regular_11">EXCEPTION_BREAKPOINT</samp>
    doesn’t invoke the exception handler, the malware can infer that it’s being debugged.
    Take a look at the following simplified pseudocode:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 这是恶意软件测试其是否正在被调试的一种有效方法。如果恶意软件执行指令<samp class="SANS_TheSansMonoCd_W5Regular_11">int
    3</samp>，且未被调试，则会触发一个<samp class="SANS_TheSansMonoCd_W5Regular_11">EXCEPTION_BREAKPOINT</samp>并调用异常处理程序。当然，反之亦然。如果这个<samp
    class="SANS_TheSansMonoCd_W5Regular_11">EXCEPTION_BREAKPOINT</samp>没有触发异常处理程序，恶意软件可以推断它正在被调试。请看下面的简化伪代码：
- en: '[PRE4]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: This pseudocode features a simple <samp class="SANS_TheSansMonoCd_W5Regular_11">try...
    catch</samp> statement. The malware attempts to execute the <samp class="SANS_TheSansMonoCd_W5Regular_11">int
    3</samp> instruction ❶, and if this statement successfully returns without invoking
    an exception handler, the malware assumes it’s running in a debugger. If this
    instruction raises an exception ❷, however, the malware can safely assume it’s
    not attached to a debugger.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 这段伪代码使用了一个简单的<samp class="SANS_TheSansMonoCd_W5Regular_11">try... catch</samp>语句。恶意软件尝试执行<samp
    class="SANS_TheSansMonoCd_W5Regular_11">int 3</samp>指令❶，如果这个语句成功返回且未调用异常处理程序，则恶意软件认为它正在调试器中运行。然而，如果这个指令触发了异常❷，恶意软件就可以安全地假设它没有附加到调试器上。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_I_11">Detecting and Circumventing
    Software Breakpoints</samp>
  id: totrans-73
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_I_11">检测和规避软件断点</samp>
- en: 'Malware can also directly detect the use of breakpoints by implementing breakpoint-scanning
    techniques. In the following assembly code example, the malware scans its code
    for the breakpoint instruction <samp class="SANS_TheSansMonoCd_W5Regular_11">int
    3</samp> (<samp class="SANS_TheSansMonoCd_W5Regular_11">0xCC</samp> in hex):'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 恶意软件还可以通过实现断点扫描技术来直接检测断点的使用。在下面的汇编代码示例中，恶意软件扫描其代码中是否包含断点指令<samp class="SANS_TheSansMonoCd_W5Regular_11">int
    3</samp>（十六进制为<samp class="SANS_TheSansMonoCd_W5Regular_11">0xCC</samp>）：
- en: '[PRE5]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: This malware sample is trying to determine whether a malware analyst has set
    a software breakpoint on the <samp class="SANS_TheSansMonoCd_W5Regular_11">WriteProcessMemory</samp>
    function. First, the malware moves the address of <samp class="SANS_TheSansMonoCd_W5Regular_11">WriteProcessMemory</samp>
    into the <samp class="SANS_TheSansMonoCd_W5Regular_11">ebx</samp> register. Then,
    it compares the value of <samp class="SANS_TheSansMonoCd_W5Regular_11">0xCC</samp>
    (the <samp class="SANS_TheSansMonoCd_W5Regular_11">int 3</samp> debugger breakpoint
    instruction) to the first byte in <samp class="SANS_TheSansMonoCd_W5Regular_11">ebx</samp>,
    which is the beginning of the <samp class="SANS_TheSansMonoCd_W5Regular_11">WriteProcessMemory</samp>
    function and where the breakpoint will reside. Once the malware identifies a software
    breakpoint, it may attempt to overwrite or clear the breakpoint.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 这个恶意软件样本试图确定恶意软件分析师是否在<samp class="SANS_TheSansMonoCd_W5Regular_11">WriteProcessMemory</samp>函数上设置了软件断点。首先，恶意软件将<samp
    class="SANS_TheSansMonoCd_W5Regular_11">WriteProcessMemory</samp>的地址移动到<samp class="SANS_TheSansMonoCd_W5Regular_11">ebx</samp>寄存器中。然后，它将<samp
    class="SANS_TheSansMonoCd_W5Regular_11">0xCC</samp>（即<samp class="SANS_TheSansMonoCd_W5Regular_11">int
    3</samp>调试器断点指令）与<samp class="SANS_TheSansMonoCd_W5Regular_11">ebx</samp>中的第一个字节进行比较，这个字节是<samp
    class="SANS_TheSansMonoCd_W5Regular_11">WriteProcessMemory</samp>函数的起始位置，也是断点将放置的地方。一旦恶意软件识别出软件断点，它可能会尝试覆盖或清除该断点。
- en: You can overcome some breakpoint detection techniques by using uncommon breakpoint
    instructions. Many debuggers have this option. In x64dbg, simply navigate to **Options****Settings****Engine**
    and set your preferred breakpoint instruction under Default Breakpoint Type, as
    shown in [Figure 10-3](chapter10.xhtml#fig10-3).
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过使用不常见的断点指令来克服某些断点检测技术。许多调试器都有这个选项。在x64dbg中，只需导航到**Options****Settings****Engine**，然后在“Default
    Breakpoint Type”下设置你喜欢的断点指令，如[图 10-3](chapter10.xhtml#fig10-3)所示。
- en: '![](../images/fig10-3.jpg)'
  id: totrans-78
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/fig10-3.jpg)'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 10-3: Setting the default
    breakpoint type in x64dbg</samp>'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">图 10-3：在 x64dbg 中设置默认断点类型</samp>
- en: Some variations of malware look for these alternative breakpoint instructions
    as well, so a better option is to use hardware breakpoints to circumvent software
    breakpoint detection techniques. Hardware breakpoints can also be circumvented
    by malware, however, as the next section will discuss.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 一些变种的恶意软件也会寻找这些替代的断点指令，因此更好的选择是使用硬件断点来规避软件断点检测技术。然而，硬件断点同样可以被恶意软件规避，接下来的部分将对此进行讨论。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_I_11">Detecting and Circumventing
    Hardware and Memory Breakpoints</samp>
  id: totrans-81
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_I_11">检测和规避硬件及内存断点</samp>
- en: 'Like software breakpoints, hardware breakpoints can be used by analysts to
    intercept function calls, break on interesting behavior, and generally control
    the malware’s execution. Because hardware breakpoints are implemented in CPU registers
    (DR0–DR3) rather than as instructions, malware can scan these registers for them.
    If any of these registers contain data (specifically, a memory address), the malware
    might assume there’s a hardware breakpoint in place and take evasive actions,
    such as clearing these registers, effectively removing the breakpoints. One way
    to find hardware breakpoints is by using the <samp class="SANS_TheSansMonoCd_W5Regular_11">GetThreadContext</samp>
    function (or <samp class="SANS_TheSansMonoCd_W5Regular_11">Wow64GetThreadContext</samp>
    for 64-bit programs) as follows:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 与软件断点类似，硬件断点可被分析人员用来拦截函数调用、在感兴趣的行为上中断，以及一般性地控制恶意软件的执行。由于硬件断点是通过 CPU 寄存器（DR0–DR3）实现的，而不是通过指令，因此恶意软件可以扫描这些寄存器以寻找断点。如果这些寄存器中的任何一个包含数据（特别是内存地址），恶意软件可能会认为已设置硬件断点，并采取规避措施，例如清除这些寄存器，从而有效地移除断点。查找硬件断点的一种方法是使用
    <samp class="SANS_TheSansMonoCd_W5Regular_11">GetThreadContext</samp> 函数（对于 64
    位程序，使用 <samp class="SANS_TheSansMonoCd_W5Regular_11">Wow64GetThreadContext</samp>），如下所示：
- en: '[PRE6]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: In this sample pseudocode (adapted from [*https://<wbr>www<wbr>.codeproject<wbr>.com<wbr>/Articles<wbr>/30815<wbr>/An<wbr>-Anti<wbr>-Reverse<wbr>-Engineering<wbr>-Guide*](https://www.codeproject.com/Articles/30815/An-Anti-Reverse-Engineering-Guide)),
    the malware defines a new <samp class="SANS_TheSansMonoCd_W5Regular_11">CONTEXT</samp>
    structure (<samp class="SANS_TheSansMonoCd_W5Regular_11">context</samp>), which
    is a Windows structure used to store CPU state and related data for the process.
    This structure must be in place to store the debug register (DR0–DR3) data that
    the malware will check for shortly. Next, the malware specifies that the <samp
    class="SANS_TheSansMonoCd_W5Regular_11">CONTEXT_DEBUG_REGISTERS</samp> should
    be the data that <samp class="SANS_TheSansMonoCd_W5Regular_11">GetThreadContext</samp>
    returns. The malware then gets a handle to its current thread (<samp class="SANS_TheSansMonoCd_W5Regular_11">HANDLE</samp>)
    and calls <samp class="SANS_TheSansMonoCd_W5Regular_11">GetThreadContext</samp>,
    which will store the current thread’s <samp class="SANS_TheSansMonoCd_W5Regular_11">CONTEXT_DEBUG_REGISTERS</samp>
    in the <samp class="SANS_TheSansMonoCd_W5Regular_11">context</samp> structure.
    Finally, the malware sample inspects the debug registers for data. If these registers
    are nonzero, the check returns true, informing the malware that a hardware breakpoint
    has been set by the debugger.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例伪代码中（改编自 [*https://<wbr>www<wbr>.codeproject<wbr>.com<wbr>/Articles<wbr>/30815<wbr>/An<wbr>-Anti<wbr>-Reverse<wbr>-Engineering<wbr>-Guide*](https://www.codeproject.com/Articles/30815/An-Anti-Reverse-Engineering-Guide)），恶意软件定义了一个新的
    <samp class="SANS_TheSansMonoCd_W5Regular_11">CONTEXT</samp> 结构体（<samp class="SANS_TheSansMonoCd_W5Regular_11">context</samp>），这是一个
    Windows 结构，用于存储进程的 CPU 状态和相关数据。这个结构体必须到位，以便存储恶意软件稍后检查的调试寄存器（DR0–DR3）数据。接下来，恶意软件指定
    <samp class="SANS_TheSansMonoCd_W5Regular_11">CONTEXT_DEBUG_REGISTERS</samp> 应该是
    <samp class="SANS_TheSansMonoCd_W5Regular_11">GetThreadContext</samp> 返回的数据。然后，恶意软件获取其当前线程的句柄（<samp
    class="SANS_TheSansMonoCd_W5Regular_11">HANDLE</samp>），并调用 <samp class="SANS_TheSansMonoCd_W5Regular_11">GetThreadContext</samp>，该函数会将当前线程的
    <samp class="SANS_TheSansMonoCd_W5Regular_11">CONTEXT_DEBUG_REGISTERS</samp> 存储到
    <samp class="SANS_TheSansMonoCd_W5Regular_11">context</samp> 结构中。最后，恶意软件样本检查调试寄存器中的数据。如果这些寄存器非零，则该检查返回
    true，通知恶意软件调试器已设置硬件断点。
- en: 'The malware can then completely remove any hardware breakpoints it detects
    by using <samp class="SANS_TheSansMonoCd_W5Regular_11">SetThreadContext</samp>
    (or <samp class="SANS_TheSansMonoCd_W5Regular_11">Wow64SetThreadContext</samp>
    for 64-bit malware). Adding this line to the preceding code example will effectively
    clear the debug registers, subsequently removing the malware analyst’s hardware
    breakpoints:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 恶意软件可以使用<sup class="SANS_TheSansMonoCd_W5Regular_11">SetThreadContext</sup>（或者对于64位恶意软件使用<sup
    class="SANS_TheSansMonoCd_W5Regular_11">Wow64SetThreadContext</sup>）完全移除它检测到的任何硬件断点。将此行添加到前面的代码示例中，将有效清除调试寄存器，进而移除恶意软件分析师的硬件断点：
- en: '[PRE7]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Finally, malware can detect memory breakpoints with the <samp class="SANS_TheSansMonoCd_W5Regular_11">ReadProcessMemory</samp>
    function. Setting a memory breakpoint alters the memory page, so if the malware
    invokes <samp class="SANS_TheSansMonoCd_W5Regular_11">ReadProcessMemory</samp>
    on a suspect memory page, and if it returns an unexpected value such as <samp
    class="SANS_TheSansMonoCd_W5Regular_11">PAGE_NOACCESS</samp> or <samp class="SANS_TheSansMonoCd_W5Regular_11">PAGE_GUARD</samp>,
    it might infer that a hardware breakpoint has been set on this memory page. Another
    option to achieve the same effect is for the malware to execute <samp class="SANS_TheSansMonoCd_W5Regular_11">VirtualQuery</samp>,
    <samp class="SANS_TheSansMonoCd_W5Regular_11">VirtualQueryEx</samp>, or <samp
    class="SANS_TheSansMonoCd_W5Regular_11">NtQueryVirtualMemory</samp>. We’ll discuss
    memory breakpoints more in the next section.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，恶意软件可以使用<sup class="SANS_TheSansMonoCd_W5Regular_11">ReadProcessMemory</sup>函数来检测内存断点。设置内存断点会改变内存页，因此，如果恶意软件在可疑内存页上调用<sup
    class="SANS_TheSansMonoCd_W5Regular_11">ReadProcessMemory</sup>，并且返回一个意外的值，比如<sup
    class="SANS_TheSansMonoCd_W5Regular_11">PAGE_NOACCESS</sup>或<sup class="SANS_TheSansMonoCd_W5Regular_11">PAGE_GUARD</sup>，它可能会推测此内存页上已经设置了硬件断点。另一种实现相同效果的方法是恶意软件执行<sup
    class="SANS_TheSansMonoCd_W5Regular_11">VirtualQuery</sup>、<sup class="SANS_TheSansMonoCd_W5Regular_11">VirtualQueryEx</sup>或<sup
    class="SANS_TheSansMonoCd_W5Regular_11">NtQueryVirtualMemory</sup>。我们将在下一节讨论内存断点。
- en: If you suspect that a malware sample is using any of the techniques described
    in this section, it’s helpful to hook (place a breakpoint on) these functions.
    Once a breakpoint is hit, you can simply modify the return value or <samp class="SANS_TheSansMonoCd_W5Regular_11">nop</samp>
    out the call to the function altogether. The debugger plug-in ScyllaHide, described
    on [page 181](chapter10.xhtml#pg_181), can also be useful here.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你怀疑恶意软件样本使用了本节描述的任何技术，挂钩（在这些函数上设置断点）是很有帮助的。一旦命中断点，你可以简单地修改返回值，或者完全跳过对该函数的调用。调试器插件ScyllaHide，如[第181页](chapter10.xhtml#pg_181)所述，也可以在这里提供帮助。
- en: '#### <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_I_11">Using Memory
    Page Guards for Breakpoint Detection</samp>'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: '#### <sup class="SANS_Futura_Std_Bold_Condensed_Oblique_I_11">使用内存页保护来检测断点</sup>'
- en: '*Memory page guards* are a special flag implemented in Windows for memory access.
    When allocating new memory pages, a program can add the <samp class="SANS_TheSansMonoCd_W5Regular_11">PAGE_GUARD</samp>
    flag as a sort of alarm system for memory access. When this area of memory is
    accessed by the program (or by a different program), it raises a <samp class="SANS_TheSansMonoCd_W5Regular_11">STATUS_GUARD_PAGE_VIOLATION</samp>
    exception. If the program is running under a debugger, <samp class="SANS_TheSansMonoCd_W5Regular_11">PAGE_GUARD</samp>
    often behaves a bit differently (because the debugger is handling the exception)
    and won’t raise the normal exception.'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: '*内存页保护*是Windows中实现的用于内存访问的特殊标志。在分配新的内存页时，程序可以添加<sup class="SANS_TheSansMonoCd_W5Regular_11">PAGE_GUARD</sup>标志，作为一种内存访问的警报系统。当该内存区域被程序（或其他程序）访问时，它会触发<sup
    class="SANS_TheSansMonoCd_W5Regular_11">STATUS_GUARD_PAGE_VIOLATION</sup>异常。如果程序在调试器下运行，<sup
    class="SANS_TheSansMonoCd_W5Regular_11">PAGE_GUARD</sup>的行为通常会有所不同（因为调试器正在处理异常），并且不会触发正常的异常。'
- en: 'Malware can take advantage of this by implementing page guards on certain memory
    pages. If these pages are accessed from outside a debugger (meaning that the malware
    isn’t being debugged), the malware will raise the exception as normal. If no exception
    is raised, depending on the debugger being used and its configuration, this could
    alert the malware that it’s being debugged. To set page guards in memory, malware
    can call <samp class="SANS_TheSansMonoCd_W5Regular_11">VirtualProtect</samp> with
    the <samp class="SANS_TheSansMonoCd_W5Regular_11">PAGE_GUARD</samp> (<samp class="SANS_TheSansMonoCd_W5Regular_11">0x100</samp>)
    value set. The following code shows a malware sample calling <samp class="SANS_TheSansMonoCd_W5Regular_11">VirtualAlloc</samp>
    with this parameter set:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 恶意软件可以通过在某些内存页上实现页面保护来利用这一点。如果这些页面从调试器外部访问（意味着恶意软件没有被调试），恶意软件将正常引发异常。如果没有引发异常，根据使用的调试器及其配置，这可能会警告恶意软件它正被调试。为了在内存中设置页面保护，恶意软件可以调用<samp
    class="SANS_TheSansMonoCd_W5Regular_11">VirtualProtect</samp>并将<samp class="SANS_TheSansMonoCd_W5Regular_11">PAGE_GUARD</samp>（<samp
    class="SANS_TheSansMonoCd_W5Regular_11">0x100</samp>）值设置。以下代码展示了恶意软件调用<samp class="SANS_TheSansMonoCd_W5Regular_11">VirtualAlloc</samp>并设置此参数的示例：
- en: '[PRE8]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: This code calls <samp class="SANS_TheSansMonoCd_W5Regular_11">VirtualAlloc</samp>
    with the <samp class="SANS_TheSansMonoCd_W5Regular_11">flNewProtect</samp> value
    set to <samp class="SANS_TheSansMonoCd_W5Regular_11">0x104</samp>, which is a
    combination of <samp class="SANS_TheSansMonoCd_W5Regular_11">0x100</samp> (<samp
    class="SANS_TheSansMonoCd_W5Regular_11">PAGE_GUARD</samp>) and <samp class="SANS_TheSansMonoCd_W5Regular_11">0x4</samp>
    (<samp class="SANS_TheSansMonoCd_W5Regular_11">READ/WRITE</samp>) protection.
    Memory allocation and <samp class="SANS_TheSansMonoCd_W5Regular_11">VirtualAlloc</samp>
    are covered in more detail in [Part IV](part4.xhtml), particularly [Chapter 17](chapter17.xhtml).
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码调用了<samp class="SANS_TheSansMonoCd_W5Regular_11">VirtualAlloc</samp>，并将<samp
    class="SANS_TheSansMonoCd_W5Regular_11">flNewProtect</samp>值设置为<samp class="SANS_TheSansMonoCd_W5Regular_11">0x104</samp>，这是<samp
    class="SANS_TheSansMonoCd_W5Regular_11">0x100</samp>（<samp class="SANS_TheSansMonoCd_W5Regular_11">PAGE_GUARD</samp>）和<samp
    class="SANS_TheSansMonoCd_W5Regular_11">0x4</samp>（<samp class="SANS_TheSansMonoCd_W5Regular_11">READ/WRITE</samp>）保护的组合。内存分配和<samp
    class="SANS_TheSansMonoCd_W5Regular_11">VirtualAlloc</samp>的详细内容请参考[第四部分](part4.xhtml)，特别是[第17章](chapter17.xhtml)。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_I_11">Using Breakpoint Traps</samp>
  id: totrans-94
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_I_11">使用断点陷阱</samp>
- en: Malware can insert breakpoint instructions such as <samp class="SANS_TheSansMonoCd_W5Regular_11">int
    3</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">int 2d</samp> throughout
    its code in order to force the debugger to break often, causing a lot of trouble
    for the malware analysts debugging it. A constantly breaking debugger makes debugging
    a headache. Breakpoint instructions intentionally placed in malware are sometimes
    called *traps*.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 恶意软件可以在其代码中插入像<samp class="SANS_TheSansMonoCd_W5Regular_11">int 3</samp>和<samp
    class="SANS_TheSansMonoCd_W5Regular_11">int 2d</samp>这样的断点指令，迫使调试器频繁中断，从而给恶意软件分析师调试带来麻烦。一个不断中断的调试器会让调试变得非常头疼。故意在恶意软件中放置的断点指令有时被称为*陷阱*。
- en: '[Figure 10-4](chapter10.xhtml#fig10-4) shows a sample of the Dridex malware
    in x64dbg using the <samp class="SANS_TheSansMonoCd_W5Regular_11">int 3</samp>
    trap technique.'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: '[图10-4](chapter10.xhtml#fig10-4)显示了在x64dbg中使用<samp class="SANS_TheSansMonoCd_W5Regular_11">int
    3</samp>陷阱技术的Dridex恶意软件样本。'
- en: '![](../images/fig10-4.jpg)'
  id: totrans-97
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/fig10-4.jpg)'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 10-4: A Dridex malware
    sample using a breakpoint anti-debug trap</samp>'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">图10-4：使用断点反调试陷阱的Dridex恶意软件样本</samp>
- en: The Dridex code shown here executes two <samp class="SANS_TheSansMonoCd_W5Regular_11">int
    3</samp> instructions, increments <samp class="SANS_TheSansMonoCd_W5Regular_11">eax</samp>,
    executes two more <samp class="SANS_TheSansMonoCd_W5Regular_11">int 3</samp> instructions,
    and then continues to loop. This function repeats 13,512 times (<samp class="SANS_TheSansMonoCd_W5Regular_11">cmp
    eax, 13512</samp>), which can cause major frustration for the malware analyst
    debugging the sample.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 此处显示的Dridex代码执行了两个<samp class="SANS_TheSansMonoCd_W5Regular_11">int 3</samp>指令，递增<samp
    class="SANS_TheSansMonoCd_W5Regular_11">eax</samp>，执行另外两个<samp class="SANS_TheSansMonoCd_W5Regular_11">int
    3</samp>指令，然后继续循环。这个函数会重复13,512次（<samp class="SANS_TheSansMonoCd_W5Regular_11">cmp
    eax, 13512</samp>），这可能会给恶意软件分析师调试样本时带来很大的困扰。
- en: It’s often difficult to circumvent this trap technique in malware. The best
    approach is to identify the problematic instructions and patch them out. As in
    the case of this Dridex sample, the malware may create a loop (using <samp class="SANS_TheSansMonoCd_W5Regular_11">jmp</samp>,
    <samp class="SANS_TheSansMonoCd_W5Regular_11">jnz</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">jz</samp>,
    and so on) of these breakpoint instructions, in which case you’d need to patch
    out or modify the loop instruction to bypass this behavior.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 要绕过这种陷阱技术在恶意软件中通常很困难。最佳方法是识别出有问题的指令并将其修补掉。就像这个 Dridex 示例一样，恶意软件可能会创建一个循环（使用<samp
    class="SANS_TheSansMonoCd_W5Regular_11">jmp</samp>、<samp class="SANS_TheSansMonoCd_W5Regular_11">jnz</samp>、<samp
    class="SANS_TheSansMonoCd_W5Regular_11">jz</samp>等）来执行这些断点指令，在这种情况下，你需要修补或修改循环指令，以绕过这种行为。
- en: <samp class="SANS_Futura_Std_Bold_B_11">Unhandled Exceptions</samp>
  id: totrans-101
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">未处理的异常</samp>
- en: Malware can set a top-level exception handler (called an *unhandled exception
    filter*) to test for a debugger. This supersedes any other handlers, such as the
    default SEH, by first invoking <samp class="SANS_TheSansMonoCd_W5Regular_11">SetUnhandledExceptionFilter</samp>,
    which allows the calling program to become the top-level exception handler, then
    invoking <samp class="SANS_TheSansMonoCd_W5Regular_11">UnhandledExceptionFilter</samp>,
    which forces the exception handler to execute. When a malware program isn’t being
    debugged, the exception will be passed to the new handler. If it *is* being debugged,
    then the new handler won’t be called and the exception will be passed to the debugger,
    indicating to the malware that it’s running inside a debugger.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 恶意软件可以设置一个顶级异常处理程序（称为*未处理异常过滤器*）来检测调试器。这将覆盖任何其他处理程序，例如默认的 SEH，首先通过调用<samp class="SANS_TheSansMonoCd_W5Regular_11">SetUnhandledExceptionFilter</samp>，允许调用程序成为顶级异常处理程序，然后调用<samp
    class="SANS_TheSansMonoCd_W5Regular_11">UnhandledExceptionFilter</samp>，强制执行异常处理程序。当恶意软件程序未被调试时，异常将被传递到新的处理程序。如果正在调试，则不会调用新的处理程序，异常将被传递给调试器，表明恶意软件正在调试器中运行。
- en: To deal with this technique, you can intercept calls to both <samp class="SANS_TheSansMonoCd_W5Regular_11">SetUnhandledExceptionFilter</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">UnhandledExceptionFilter</samp>
    (via breakpoints or hooks) and modify the function calls or patch them out of
    the code completely. [Chapter 11](chapter11.xhtml) discusses exception handling
    in more detail.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 为了应对这种技术，你可以通过断点或钩子拦截对<samp class="SANS_TheSansMonoCd_W5Regular_11">SetUnhandledExceptionFilter</samp>和<samp
    class="SANS_TheSansMonoCd_W5Regular_11">UnhandledExceptionFilter</samp>的调用，并修改函数调用或完全修补掉这些代码。[第11章](chapter11.xhtml)将更详细地讨论异常处理。
- en: <samp class="SANS_Futura_Std_Bold_B_11">Checksums, Section Hashing, and Self-Healing</samp>
  id: totrans-104
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">校验和、代码段哈希和自愈</samp>
- en: Malware can take a checksum (or hash) of its code to determine whether a breakpoint
    has been placed or an analyst has otherwise modified the code in the debugger.
    Using any hashing algorithm (MD5, for example), the malware author can create
    a hash of its code line by line or hash an entire section of code (typically called
    *section hashing*), then compare this with a baseline sum. If there’s a discrepancy,
    the malware may assume that a breakpoint has been set or its code has been otherwise
    modified.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 恶意软件可以通过对其代码进行校验和（或哈希）来判断是否设置了断点，或者分析员是否以其他方式修改了调试器中的代码。使用任何哈希算法（例如 MD5），恶意软件作者可以逐行创建代码的哈希值，或对整个代码段进行哈希（通常称为*代码段哈希*），然后将其与基线值进行比较。如果存在差异，恶意软件可能会认为已设置断点或代码已被修改。
- en: 'Malware can also implement so-called *self-healing* techniques, in which it
    stores clean copies of its code and, if it detects code tampering, restores the
    original version. The following pseudocode demonstrates how this might look in
    practice:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 恶意软件还可以实施所谓的*自愈*技术，存储其代码的干净副本，并在检测到代码篡改时恢复原始版本。以下伪代码展示了这一过程在实践中的表现：
- en: '[PRE9]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: There’s not much an analyst can do to circumvent this technique. The most effective
    method is to identify where the malware is obtaining a checksum of a certain segment
    of code and then patch this functionality out of its code. Hardware breakpoints
    can also be used in the event that the malware is using this approach to look
    for software breakpoints.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 分析员很难绕过这种技术。最有效的方法是识别恶意软件在哪个位置获取某段代码的校验和，然后将这一功能从代码中修补掉。如果恶意软件使用这种方法来查找软件断点，还可以使用硬件断点。
- en: <samp class="SANS_Futura_Std_Bold_B_11">Exploiting, Crashing, and Interfering
    with the Debugger</samp>
  id: totrans-109
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">利用、崩溃和干扰调试器</samp>
- en: Sometimes the most effective anti-debugging method is to directly interfere
    with the debugger by causing it to crash or behave unpredictably. Just like any
    software, debuggers can have bugs in their code that allow the malware to interfere
    with analysis, crash the debugger, or possibly even crash the operating system
    itself. A popular example is a bug in version 1.1 of OllyDbg whereby malware could
    call the <samp class="SANS_TheSansMonoCd_W5Regular_11">OutputDebugString</samp>
    function and pass <samp class="SANS_TheSansMonoCd_W5Regular_11">%s</samp> as a
    parameter; OllyDbg would be unable to handle this value, causing the running malware
    sample to crash and preventing further debugging.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 有时候，最有效的反调试方法就是通过直接干扰调试器，使其崩溃或表现出不可预测的行为。就像任何软件一样，调试器的代码中可能会有漏洞，允许恶意软件干扰分析、使调试器崩溃，甚至可能导致操作系统本身崩溃。一个流行的例子是
    OllyDbg 1.1 版本中的一个漏洞，恶意软件可以调用 <samp class="SANS_TheSansMonoCd_W5Regular_11">OutputDebugString</samp>
    函数，并将 <samp class="SANS_TheSansMonoCd_W5Regular_11">%s</samp> 作为参数传递；OllyDbg 无法处理该值，导致正在运行的恶意软件样本崩溃，从而阻止进一步调试。
- en: 'Perhaps slightly less offensive is the <samp class="SANS_TheSansMonoCd_W5Regular_11">BlockInput</samp>
    function, which malware can abuse to interfere with analysis tools. <samp class="SANS_TheSansMonoCd_W5Regular_11">BlockInput</samp>
    takes only one parameter: <samp class="SANS_TheSansMonoCd_W5Regular_11">fBlockIt</samp>.
    If this parameter is set to <samp class="SANS_TheSansMonoCd_W5Regular_11">1</samp>,
    mouse and keyboard events to all applications will be blocked, which can seriously
    interfere with the debugging process. If malware detects that it is being manually
    inspected or running under a debugger, it may simply call <samp class="SANS_TheSansMonoCd_W5Regular_11">BlockInput</samp>
    as a self-defense mechanism. Luckily, you can easily get around this technique
    by using CTRL-ALT-DELETE, which will escape the <samp class="SANS_TheSansMonoCd_W5Regular_11">BlockInput</samp>
    routine. You can also modify the function call in a debugger, setting the <samp
    class="SANS_TheSansMonoCd_W5Regular_11">fBlockIt</samp> parameter to <samp class="SANS_TheSansMonoCd_W5Regular_11">0</samp>
    instead of <samp class="SANS_TheSansMonoCd_W5Regular_11">1</samp>.'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 也许稍微不那么激进的方法是 <samp class="SANS_TheSansMonoCd_W5Regular_11">BlockInput</samp>
    函数，恶意软件可以滥用它来干扰分析工具。<samp class="SANS_TheSansMonoCd_W5Regular_11">BlockInput</samp>
    只有一个参数：<samp class="SANS_TheSansMonoCd_W5Regular_11">fBlockIt</samp>。如果该参数设置为
    <samp class="SANS_TheSansMonoCd_W5Regular_11">1</samp>，则所有应用程序的鼠标和键盘事件都会被阻止，这会严重干扰调试过程。如果恶意软件检测到自己正在被手动检查或在调试器下运行，它可能会调用
    <samp class="SANS_TheSansMonoCd_W5Regular_11">BlockInput</samp> 作为自我防御机制。幸运的是，您可以通过使用
    CTRL-ALT-DELETE 来轻松绕过此技术，这将使 <samp class="SANS_TheSansMonoCd_W5Regular_11">BlockInput</samp>
    例程失效。您也可以在调试器中修改函数调用，将 <samp class="SANS_TheSansMonoCd_W5Regular_11">fBlockIt</samp>
    参数设置为 <samp class="SANS_TheSansMonoCd_W5Regular_11">0</samp> 而不是 <samp class="SANS_TheSansMonoCd_W5Regular_11">1</samp>。
- en: Finally, malware can use <samp class="SANS_TheSansMonoCd_W5Regular_11">NtSetInformationThread</samp>
    to hide code execution from the debugger or to crash the debugger altogether.
    By passing the <samp class="SANS_TheSansMonoCd_W5Regular_11">ThreadInformationClass</samp>
    value <samp class="SANS_TheSansMonoCd_W5Regular_11">ThreadHideFromDebugger</samp>
    (in hex, 0x11) to the <samp class="SANS_TheSansMonoCd_W5Regular_11">NtSetInformationThread</samp>
    function, the malware can covertly execute code, causing the malware analyst to
    lose control of the running sample. Additionally, if the malware executes a breakpoint
    instruction (such as <samp class="SANS_TheSansMonoCd_W5Regular_11">int 3</samp>)
    in the covertly executed code, the malware process will hang indefinitely in the
    debugger. I’ll discuss this technique in the context of covert code execution
    in [Chapter 11](chapter11.xhtml).
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，恶意软件可以使用 <samp class="SANS_TheSansMonoCd_W5Regular_11">NtSetInformationThread</samp>
    来隐藏代码执行，避免被调试器检测，或者直接使调试器崩溃。通过将 <samp class="SANS_TheSansMonoCd_W5Regular_11">ThreadInformationClass</samp>
    值 <samp class="SANS_TheSansMonoCd_W5Regular_11">ThreadHideFromDebugger</samp>（以十六进制表示为
    0x11）传递给 <samp class="SANS_TheSansMonoCd_W5Regular_11">NtSetInformationThread</samp>
    函数，恶意软件可以隐蔽地执行代码，从而导致恶意软件分析员无法控制正在运行的样本。此外，如果恶意软件在隐蔽执行的代码中执行一个断点指令（例如 <samp class="SANS_TheSansMonoCd_W5Regular_11">int
    3</samp>），恶意软件进程将在调试器中无限期挂起。我将在[第 11 章](chapter11.xhtml)中讨论这一技术。
- en: These are only a few examples of known debugger exploitation techniques, and
    there are certainly more that are unknown. Malware analysts should be wary of
    these techniques and expect new ones to pop up when analyzing advanced evasive
    malware. Remember to always conduct analysis and debugging in a safe testing environment.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 这些只是已知的调试器利用技术中的一些例子，肯定还有许多未知的技术。恶意软件分析师应当对这些技术保持警惕，并预期在分析先进的规避恶意软件时会出现新的技术。记住，始终在安全的测试环境中进行分析和调试。
- en: '### <samp class="SANS_Futura_Std_Bold_B_11">Debug Blocking and Anti-attach
    Techniques</samp>'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: '### <samp class="SANS_Futura_Std_Bold_B_11">调试阻止与反附加技术</samp>'
- en: Instead of detecting a debugger or actively interfering with it, malware may
    simply try to prevent it from functioning altogether. This series of techniques
    is often called *debug blocking* or *anti-attach*.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 恶意软件可能不会检测调试器或主动干扰它，而是简单地尝试完全阻止其功能。这一系列技术通常被称为 *调试阻止* 或 *反附加*。
- en: To attach to a running malware sample, normally the debugger calls the Windows
    function <samp class="SANS_TheSansMonoCd_W5Regular_11">DebugActiveProcess</samp>.
    In the event that the process is already being debugged, this function will fail.
    Malware can take advantage of this by simply acting as its own debugger. It can
    spawn a child process and set the parent process as the debugger. When attempting
    to attach a debugger to this child process, a malware analyst will be met with
    a frustrating <samp class="SANS_TheSansMonoCd_W5Regular_11">STATUS_PORT_ALREADY_SET</samp>
    exception, meaning that the process is already being debugged.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 要附加到正在运行的恶意软件样本，通常调试器会调用 Windows 函数 <samp class="SANS_TheSansMonoCd_W5Regular_11">DebugActiveProcess</samp>。如果该进程已经在调试中，该函数将失败。恶意软件可以利用这一点，简单地充当其自己的调试器。它可以生成一个子进程并将父进程设置为调试器。当尝试将调试器附加到该子进程时，恶意软件分析师将遇到令人沮丧的
    <samp class="SANS_TheSansMonoCd_W5Regular_11">STATUS_PORT_ALREADY_SET</samp> 异常，这意味着该进程已经在调试中。
- en: To overcome this technique, you can attach a debugger to the parent process
    and set a breakpoint on <samp class="SANS_TheSansMonoCd_W5Regular_11">WaitForDebugEvent</samp>.
    When the breakpoint is hit, you can force the process (which is acting as the
    debugger) to unattach from its child process by invoking the <samp class="SANS_TheSansMonoCd_W5Regular_11">DebugActiveProcessStop</samp>
    function.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 为了克服这种技术，您可以将调试器附加到父进程，并在 <samp class="SANS_TheSansMonoCd_W5Regular_11">WaitForDebugEvent</samp>
    上设置断点。当断点被触发时，您可以通过调用 <samp class="SANS_TheSansMonoCd_W5Regular_11">DebugActiveProcessStop</samp>
    函数强制进程（充当调试器的进程）从其子进程中分离。
- en: <samp class="SANS_Dogma_OT_Bold_B_15">NOTE</samp>
  id: totrans-118
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: <samp class="SANS_Dogma_OT_Bold_B_15">注意</samp>
- en: '*For more information on this technique, check out the research paper “The
    Art of Unpacking” by Mark Vincent Yason. The paper is old but still very relevant.
    Read it at* [https://<wbr>www<wbr>.blackhat<wbr>.com<wbr>/presentations<wbr>/bh<wbr>-usa<wbr>-07<wbr>/Yason<wbr>/Whitepaper<wbr>/bh<wbr>-usa<wbr>-07<wbr>-yason<wbr>-WP<wbr>.pdf](https://www.blackhat.com/presentations/bh-usa-07/Yason/Whitepaper/bh-usa-07-yason-WP.pdf).'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: '*有关此技术的更多信息，请查阅 Mark Vincent Yason 的研究论文《The Art of Unpacking》。尽管该论文已久，但依然非常相关。请阅读它：*
    [https://<wbr>www<wbr>.blackhat<wbr>.com<wbr>/presentations<wbr>/bh<wbr>-usa<wbr>-07<wbr>/Yason<wbr>/Whitepaper<wbr>/bh<wbr>-usa<wbr>-07<wbr>-yason<wbr>-WP<wbr>.pdf](https://www.blackhat.com/presentations/bh-usa-07/Yason/Whitepaper/bh-usa-07-yason-WP.pdf)。'
- en: Malware can also modify common debugger functions to prevent debugging; the
    malware family GuLoader does exactly this. When attaching to a process, the debugger
    will invoke the functions <samp class="SANS_TheSansMonoCd_W5Regular_11">DbgBreakPoint</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">DbgUiRemoteBreakin</samp>, which
    essentially allow the debugger to use breakpoints within the program being debugged.
    GuLoader modifies <samp class="SANS_TheSansMonoCd_W5Regular_11">DbgBreakPoint</samp>
    by removing the <samp class="SANS_TheSansMonoCd_W5Regular_11">int 3</samp> opcode
    and replacing it with <samp class="SANS_TheSansMonoCd_W5Regular_11">nop</samp>
    instructions, effectively impairing the function. Likewise, GuLoader modifies
    the <samp class="SANS_TheSansMonoCd_W5Regular_11">DbgUiRemoteBreakin</samp> function
    with an invalid call instruction, which will ultimately cause an exception, possibly
    resulting in a crash of the malware being debugged. *CrowdStrike* wrote an exceptional
    article on GuLoader; for more information on these techniques, read the paper
    at [*https://<wbr>www<wbr>.crowdstrike<wbr>.com<wbr>/blog<wbr>/guloader<wbr>-malware<wbr>-analysis<wbr>/*](https://www.crowdstrike.com/blog/guloader-malware-analysis/).
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 恶意软件还可以修改常见的调试器功能以防止调试；恶意软件家族GuLoader就是这么做的。当附加到一个进程时，调试器会调用函数<samp class="SANS_TheSansMonoCd_W5Regular_11">DbgBreakPoint</samp>和<samp
    class="SANS_TheSansMonoCd_W5Regular_11">DbgUiRemoteBreakin</samp>，这些函数基本上允许调试器在被调试的程序中使用断点。GuLoader通过删除<samp
    class="SANS_TheSansMonoCd_W5Regular_11">int 3</samp>操作码，并用<samp class="SANS_TheSansMonoCd_W5Regular_11">nop</samp>指令替换它，从而修改了<samp
    class="SANS_TheSansMonoCd_W5Regular_11">DbgBreakPoint</samp>，有效地损害了该功能。同样，GuLoader通过一个无效的调用指令修改了<samp
    class="SANS_TheSansMonoCd_W5Regular_11">DbgUiRemoteBreakin</samp>函数，最终会导致一个异常，可能导致正在调试的恶意软件崩溃。*CrowdStrike*写了一篇关于GuLoader的精彩文章；有关这些技术的更多信息，请阅读这篇论文
    [*https://<wbr>www<wbr>.crowdstrike<wbr>.com<wbr>/blog<wbr>/guloader<wbr>-malware<wbr>-analysis<wbr>/*](https://www.crowdstrike.com/blog/guloader-malware-analysis/)。
- en: <samp class="SANS_Futura_Std_Bold_B_11">Other Anti-debugging Techniques</samp>
  id: totrans-121
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">其他反调试技术</samp>
- en: There are many more methods malware can use to discover or interfere with a
    debugger in use. And, of course, researchers and malware authors constantly identify
    new, creative ways to detect and circumvent debuggers. I’ve tried to cover as
    many commonly used or particularly interesting techniques as possible in this
    chapter.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 恶意软件可以使用许多方法来发现或干扰正在使用的调试器。当然，研究人员和恶意软件作者不断发现新的、富有创意的方式来检测并规避调试器。我尽力在本章中覆盖了尽可能多的常用或特别有趣的技术。
- en: Some methods I chose not to describe here because they’re uncommon or difficult
    to implement. For example, some malware families (rootkits, for instance) can
    directly inspect their <samp class="SANS_TheSansMonoCd_W5Regular_11">EPROCESS</samp>
    blocks for signs of an attached debugger, but this is quite rare. Other techniques
    are subject to error. For example, malware can check its debug privileges by attempting
    to call <samp class="SANS_TheSansMonoCd_W5Regular_11">OpenProcess</samp> with
    the target of a system process, such as *csrss.exe*. If the malware can get a
    handle to this process, it may infer that it’s being debugged, but it’s not always
    accurate. Another example is the use of the *trap flag*, a special flag in the
    <samp class="SANS_TheSansMonoCd_W5Regular_11">EFLAGS</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">RFLAGS</samp>
    registers that can give away the presence of a debugger. Both methods can produce
    false positives, are more difficult to implement, and thus are not as widely used.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 有些方法我选择不在这里描述，因为它们不常见或难以实现。例如，一些恶意软件家族（例如rootkit）可以直接检查其<samp class="SANS_TheSansMonoCd_W5Regular_11">EPROCESS</samp>块，以查找附加调试器的迹象，但这种情况非常罕见。其他技术可能会产生错误。例如，恶意软件可以通过尝试调用<samp
    class="SANS_TheSansMonoCd_W5Regular_11">OpenProcess</samp>来检查其调试权限，目标是系统进程，如*csrss.exe*。如果恶意软件能够获取该进程的句柄，它可能会推测自己正在被调试，但这并不总是准确的。另一个例子是使用*trap
    flag*，这是在<samp class="SANS_TheSansMonoCd_W5Regular_11">EFLAGS</samp>和<samp class="SANS_TheSansMonoCd_W5Regular_11">RFLAGS</samp>寄存器中存在的一个特殊标志，可能会暴露调试器的存在。这两种方法都可能产生误报，且实现起来更困难，因此不太常用。
- en: To end this chapter, we’ll take a look at how to counter anti-debugging techniques
    that you encounter when reverse engineering.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的结尾，我们将看看如何应对逆向工程过程中遇到的反调试技术。
- en: <samp class="SANS_Futura_Std_Bold_B_11">Countering Anti-debugging Techniques</samp>
  id: totrans-125
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">反调试技术的对抗</samp>
- en: In order to effectively bypass anti-debugging techniques, first you need to
    have an idea of what exactly you’re up against. You could identify the techniques
    a malware sample is employing simply by single-stepping through its code and manually
    searching for them, but of course, this isn’t very efficient. Typically, you’ll
    want to use a disassembler in combination with a debugger to better understand
    any anti-debugging methods you encounter.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 为了有效地绕过反调试技术，首先你需要清楚了解你面临的具体情况。你可以通过逐步执行恶意软件的代码并手动查找技术来识别恶意软件使用的技术，但这当然不是很高效。通常，你需要结合使用反汇编器和调试器，以更好地理解遇到的任何反调试方法。
- en: Before digging into any malware, I always inspect the sample in a PE static
    analysis and triage tool such as PEStudio or PE-bear. These types of tools allow
    me to inspect imports and strings in the file that may help identify possible
    anti-debugging-related libraries and function calls. I also use tools like CAPA,
    which I described in [Chapter 3](chapter3.xhtml).
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 在深入研究任何恶意软件之前，我总是先在PE静态分析和分类工具中检查样本，例如PEStudio或PE-bear。这些工具允许我检查文件中的导入和字符串，可能有助于识别与反调试相关的库和函数调用。我还使用像CAPA这样的工具，我在[第3章](chapter3.xhtml)中描述过。
- en: Once I’ve identified anti-debugging techniques in the executable, I inspect
    the surrounding code with the help of a disassembler and decide how I’ll counter
    and bypass these techniques. This often involves setting breakpoints on suspect
    code and function calls in the debugger and modifying the code dynamically.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我识别出可执行文件中的反调试技术，我会借助反汇编工具检查周围的代码，并决定如何应对和绕过这些技术。这通常涉及在调试器中设置可疑代码和函数调用的断点，并动态修改代码。
- en: There are some great tools that can help automate the process of bypassing anti-debugging
    techniques. *ScyllaHide* ([*https://<wbr>github<wbr>.com<wbr>/x64dbg<wbr>/ScyllaHide*](https://github.com/x64dbg/ScyllaHide)),
    a plug-in for x64dbg and other debuggers, is perhaps the most popular. It can
    hide a debugger from malware by dynamically modifying the malware’s code and hooking
    suspect functions to bypass many debugger detection and anti-debugger techniques
    (as shown in [Figure 10-5](chapter10.xhtml#fig10-5)).
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 有一些很棒的工具可以帮助自动化绕过反调试技术的过程。*ScyllaHide*（[*https://<wbr>github<wbr>.com<wbr>/x64dbg<wbr>/ScyllaHide*](https://github.com/x64dbg/ScyllaHide)），一个用于x64dbg和其他调试器的插件，可能是最流行的工具。它可以通过动态修改恶意软件的代码并挂钩可疑函数，隐藏调试器，从而绕过许多调试器检测和反调试技术（如[图10-5](chapter10.xhtml#fig10-5)所示）。
- en: '![](../images/fig10-5.jpg)'
  id: totrans-130
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/fig10-5.jpg)'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 10-5: The ScyllaHide
    menu in x64dbg</samp>'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">图10-5：x64dbg中的ScyllaHide菜单</samp>
- en: To enable an *anti-anti-debugging* feature in ScyllaHide, simply check the box
    next to the feature, then select **Apply** and **OK**. Mousing over each option
    will pop up more information about it. I often enable the entire left column of
    options, and this rarely causes problems. That said, while most of these options
    can be enabled safely, some of them may break the malware sample, possibly causing
    it to crash or behave in unexpected ways. So, use this with care.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 要在ScyllaHide中启用*反反调试*功能，只需勾选该功能旁边的框，然后选择**应用**和**确定**。将鼠标悬停在每个选项上会弹出更多信息。我通常启用整个左侧列的选项，这通常不会引发问题。话虽如此，虽然大多数选项可以安全启用，但其中一些可能会破坏恶意软件样本，导致它崩溃或表现出意外行为。因此，请小心使用。
- en: '*HyperHide* ([*https://<wbr>github<wbr>.com<wbr>/Air14<wbr>/HyperHide*](https://github.com/Air14/HyperHide))
    provides many of the same features as ScyllaHide, but it’s always a good idea
    to have multiple tools in your toolbox. [Figure 10-6](chapter10.xhtml#fig10-6)
    shows HyperHide’s anti-anti-debugging capabilities.'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: '*HyperHide*（[*https://<wbr>github<wbr>.com<wbr>/Air14<wbr>/HyperHide*](https://github.com/Air14/HyperHide)）提供了与ScyllaHide类似的许多功能，但通常来说，拥有多种工具总是个好主意。[图10-6](chapter10.xhtml#fig10-6)展示了HyperHide的反反调试功能。'
- en: '![](../images/fig10-6.jpg)'
  id: totrans-134
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/fig10-6.jpg)'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 10-6: The HyperHide
    menu in x64dbg</samp>'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">图10-6：x64dbg中的HyperHide菜单</samp>
- en: Both tools feature very similar anti-anti-debugging options, but one may work
    better than the other in certain circumstances. Try them both out and see which
    you prefer.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 这两种工具具有非常相似的反反调试选项，但在某些情况下，一种工具可能比另一种效果更好。试试这两种工具，看看你更喜欢哪一种。
- en: <samp class="SANS_Futura_Std_Bold_B_11">Summary</samp>
  id: totrans-137
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">总结</samp>
- en: This chapter discussed many common anti-debugging methods that malware might
    use to detect and circumvent debugging tools. Many of these techniques are widely
    used in all sorts of malware, from commodity infostealers to advanced bespoke
    and targeted threats, so it’s important to understand the concepts described here.
    In the next chapter, you’ll learn how malware can covertly execute code to evade
    dynamic analysis tools like debuggers and use misdirection techniques to disrupt
    the analysis process.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 本章讨论了恶意软件可能用来检测和绕过调试工具的许多常见反调试方法。许多这些技术在各种恶意软件中广泛使用，从普通的信息窃取软件到高级定制和针对性的威胁，因此理解这里描述的概念非常重要。在下一章中，您将学习恶意软件如何秘密执行代码以规避动态分析工具，如调试器，并使用误导技术来干扰分析过程。
