- en: '**4'
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '**4**'
- en: CROSS-SITE REQUEST FORGERY**
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 跨站请求伪造（**CSRF**）
- en: '![Image](../images/common.jpg)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/common.jpg)'
- en: 'A *cross-site request forgery (CSRF)* attack occurs when an attacker can make
    a target’s browser send an HTTP request to another website. That website then
    performs an action as though the request were valid and sent by the target. Such
    an attack typically relies on the target being previously authenticated on the
    vulnerable website where the action is submitted and occurs without the target’s
    knowledge. When a CSRF attack is successful, the attacker is able to modify server-side
    information and might even take over a user’s account. Here is a basic example,
    which we’ll walk through shortly:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 当攻击者能够使目标的浏览器向另一个网站发送 HTTP 请求时，就会发生*跨站请求伪造（CSRF）*攻击。该网站随后会执行一个操作，仿佛该请求是由目标发送且有效的。这种攻击通常依赖于目标已经在易受攻击的网站上进行身份验证，并且在目标不知情的情况下发生。当
    CSRF 攻击成功时，攻击者能够修改服务器端信息，甚至可能接管用户账户。下面是一个基本示例，我们稍后会详细讲解：
- en: Bob logs into his banking website to check his balance.
  id: totrans-4
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Bob 登录银行网站查看他的余额。
- en: When he’s finished, Bob checks his email account on a different domain.
  id: totrans-5
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 完成后，Bob 检查他在另一个域名下的电子邮件账户。
- en: Bob has an email with a link to an unfamiliar website and clicks the link to
    see where it leads.
  id: totrans-6
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Bob 收到一封电子邮件，邮件中有一个链接指向一个不熟悉的网站，他点击该链接查看它的目的地。
- en: When loaded, the unfamiliar site instructs Bob’s browser to make an HTTP request
    to Bob’s banking website, requesting a money transfer from his account to the
    attacker’s.
  id: totrans-7
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 加载完成后，那个不熟悉的网站指示 Bob 的浏览器向 Bob 的银行网站发起 HTTP 请求，要求将他的账户中的钱转移到攻击者的账户。
- en: Bob’s banking website receives the HTTP request initiated from the unfamiliar
    (and malicious) website. But because the banking website doesn’t have any CSRF
    protections, it processes the transfer.
  id: totrans-8
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Bob 的银行网站接收到了来自不熟悉（且恶意）网站发起的 HTTP 请求。但由于银行网站没有任何 CSRF 防护，它处理了该转账请求。
- en: '**Authentication**'
  id: totrans-9
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**身份验证**'
- en: 'CRSF attacks, like the one I just described, take advantage of weaknesses in
    the process websites use to authenticate requests. When you visit a website that
    requires you to log in, usually with a username and password, that site will typically
    authenticate you. The site will then store that authentication in your browser
    so you don’t have to log in every time you visit a new page on that site. It can
    store the authentication in two ways: using the basic authentication protocol
    or a cookie.'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 如我刚才描述的那样，CSRF 攻击利用了网站在验证请求时存在的漏洞。当您访问一个需要登录的网站时，通常会使用用户名和密码进行身份验证。网站会将您的身份验证信息存储在浏览器中，这样您在访问该网站的其他页面时就不需要每次都重新登录。它可以通过两种方式存储认证信息：使用基础认证协议或使用
    cookie。
- en: 'You can identify a site that uses basic authorization when HTTP requests include
    a header that looks like this: `Authorization: Basic QWxhZGRpbjpPcGVuU2VzYW1l`.
    The random-looking string is a base64-encoded username and password separated
    by a colon. In this case, `QWxhZGRpbjpPcGVuU2VzYW1l` decodes to `Aladdin:OpenSesame`.
    We won’t focus on basic authentication in this chapter, but you can use many of
    the techniques covered here to exploit CSRF vulnerabilities that use basic authentication.'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: '当 HTTP 请求中包含如下所示的头部时，您可以识别出一个使用基础认证的网站：`Authorization: Basic QWxhZGRpbjpPcGVuU2VzYW1l`。这个看似随机的字符串是经过
    base64 编码的用户名和密码，中间用冒号分隔。在这种情况下，`QWxhZGRpbjpPcGVuU2VzYW1l` 解码为 `Aladdin:OpenSesame`。我们在本章不会专门讲解基础认证，但您可以使用本章介绍的许多技术来利用使用基础认证的
    CSRF 漏洞。'
- en: '*Cookies* are small files that websites create and store in the user’s browser.
    Websites use cookies for various purposes, such as for storing information like
    user preferences or the user’s history of visiting a website. Cookies have certain
    *attributes*, which are standardized pieces of information. Those details tell
    browsers about the cookies and how to treat them. Some cookie attributes can include
    `domain`, `expires`, `max-age`, `secure`, and `httponly`, which you’ll learn about
    later in this chapter. In addition to attributes, cookies can contain a *name/value
    pair*, which consists of an identifier and an associated value that is passed
    to a website (the cookie’s `domain` attribute defines the site to pass this information
    to).'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: '*Cookies* 是网站创建并存储在用户浏览器中的小文件。网站使用 cookies 来实现多种目的，例如存储用户偏好或用户访问网站的历史记录。Cookies
    有一些 *属性*，这些是标准化的信息。这些细节告诉浏览器如何处理 cookies。一些 cookie 属性可能包括 `domain`、`expires`、`max-age`、`secure`
    和 `httponly`，你将在本章后面学习到这些属性。除了属性之外，cookies 还可以包含 *名称/值对*，该对由标识符和与之关联的值组成，并将其传递给网站（cookie
    的 `domain` 属性定义了将此信息传递给哪个网站）。'
- en: 'Browsers define the number of cookies that a site can set. But typically, single
    sites can set anywhere from 50 to 150 cookies in common browsers, and some reportedly
    support upward of 600\. Browsers generally allow sites to use a maximum of 4KB
    per cookie. There is no standard for cookie names or values: sites are free to
    choose their own name/value pairs and purposes. For example, a site could use
    a cookie named `sessionId` to remember who a user is rather than having them enter
    their username and password for every page they visit or action they perform.
    (Recall that HTTP requests are stateless, as described in [Chapter 1](ch01.xhtml#ch01).
    Stateless means that with every HTTP request, a website doesn’t know who a user
    is, so it must reauthenticate that user for every request.)'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 浏览器定义了一个网站可以设置的 cookie 数量。但通常情况下，单个网站在常见浏览器中可以设置从 50 到 150 个 cookie，有些报告显示支持多达
    600 个 cookie。浏览器通常允许每个 cookie 使用最多 4KB 的空间。对于 cookie 的名称和值没有标准：网站可以自由选择自己的名称/值对及用途。例如，一个网站可以使用名为
    `sessionId` 的 cookie 来记住用户身份，而不需要用户在每次访问页面或执行操作时都输入用户名和密码。（回想一下，HTTP 请求是无状态的，正如在[第
    1 章](ch01.xhtml#ch01)中所描述的。无状态意味着每次 HTTP 请求时，网站都不知道用户是谁，因此必须为每次请求重新验证该用户。）
- en: As an example, a name/value pair in a cookie could be `sessionId=9f86d081884c7d659a2feaa0c55ad015a3bf4f1b2b0b822cd15d6c15b0f00a08`
    and the cookie could have a `domain` of `.`site`.com`. Consequently, the `sessionId`
    cookie will be sent to every *.<site>.com* site a user visits, such as *foo.<site>.com*,
    *bar.<site>.com*, *www.<site>.com*, and so on.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 举个例子，cookie 中的一个名称/值对可能是 `sessionId=9f86d081884c7d659a2feaa0c55ad015a3bf4f1b2b0b822cd15d6c15b0f00a08`，该
    cookie 的 `domain` 可能是 `.site.com`。因此，`sessionId` cookie 将会被发送到用户访问的每个 *.<site>.com*
    网站，如 *foo.<site>.com*、*bar.<site>.com*、*www.<site>.com* 等等。
- en: The `secure` and `httponly` attributes tell browsers when and how to send and
    read cookies. These attributes don’t contain values; instead, they act as flags
    that are either present in the cookie or are not. When a cookie contains the `secure`
    attribute, browsers will only send that cookie when visiting HTTPS sites. For
    example, if you visited *http://www.<site>.com/* (an HTTP site) with a secure
    cookie, your browser wouldn’t send the cookie to that site. The reason is to protect
    your privacy, because HTTPS connections are encrypted and HTTP connections are
    not. The `httponly` attribute, which will become important when you learn about
    cross-site scripting in [Chapter 7](ch07.xhtml#ch07), tells the browser to read
    a cookie only through HTTP and HTTPS requests. Therefore, browsers won’t allow
    any scripting languages, such as JavaScript, to read that cookie’s value. When
    the `secure` and `httponly` attributes are not set in cookies, those cookies could
    be sent legitimately but read maliciously. A cookie without the `secure` attribute
    can be sent to a non-HTTPS site; likewise, a cookie without `httponly` set can
    be read by JavaScript.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: '`secure` 和 `httponly` 属性告诉浏览器何时以及如何发送和读取 cookies。这些属性不包含值；相反，它们作为标志，可能出现在 cookie
    中，也可能不出现。当一个 cookie 包含 `secure` 属性时，浏览器只有在访问 HTTPS 网站时才会发送该 cookie。例如，如果你访问 *http://www.<site>.com/*（一个
    HTTP 网站），并且该网站有一个安全的 cookie，你的浏览器不会将该 cookie 发送到该网站。原因是为了保护你的隐私，因为 HTTPS 连接是加密的，而
    HTTP 连接不是。`httponly` 属性将在你学习跨站脚本攻击（XSS）时变得重要，参见[第七章](ch07.xhtml#ch07)，它指示浏览器只通过
    HTTP 和 HTTPS 请求来读取 cookie。因此，浏览器不会允许任何脚本语言（如 JavaScript）读取该 cookie 的值。当 `secure`
    和 `httponly` 属性没有在 cookie 中设置时，这些 cookie 可能会被合法发送，但被恶意读取。没有 `secure` 属性的 cookie
    可以发送到非 HTTPS 网站；同样，未设置 `httponly` 的 cookie 可以被 JavaScript 读取。'
- en: The `expires` and `max-age` attributes indicate when a cookie should expire
    and the browser should destroy it. The `expires` attribute simply tells the browser
    to destroy a cookie on a specific date. For example, a cookie could set the attribute
    to `expires=Wed, 18 Dec 2019 12:00:00 UTC`. In contrast, the `max-age` is the
    number of seconds until the cookie expires and is formatted as an integer (`max-age=300`).
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: '`expires` 和 `max-age` 属性指示 cookie 何时过期以及浏览器何时销毁它。`expires` 属性简单地告诉浏览器在特定日期销毁一个
    cookie。例如，cookie 可以设置属性为 `expires=Wed, 18 Dec 2019 12:00:00 UTC`。与此相对，`max-age`
    是一个整数，表示 cookie 过期的秒数（例如，`max-age=300`）。'
- en: To summarize, if the banking site Bob visits uses cookies, the site will store
    his authentication with the following process. Once Bob visits the site and logs
    in, the bank will respond to his HTTP request with an HTTP response, which includes
    a cookie that identifies Bob. In turn, Bob’s browser will automatically send that
    cookie with all other HTTP requests to the banking website.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 总结一下，如果鲍勃访问的银行网站使用了 cookies，该网站将通过以下过程存储他的身份验证信息。一旦鲍勃访问网站并登录，银行将以 HTTP 响应的形式回应他的
    HTTP 请求，响应中包含一个标识鲍勃的 cookie。反过来，鲍勃的浏览器会自动将该 cookie 与所有其他 HTTP 请求一起发送到银行网站。
- en: After finishing his banking, Bob doesn’t log out when he leaves the banking
    website. Note this important detail, because when you log out of a site, that
    site will typically respond with an HTTP response that expires your cookie. As
    a result, when you revisit the site, you’ll have to log in again.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 完成银行事务后，鲍勃没有在离开银行网站时登出。请注意这个重要细节，因为当你从一个网站登出时，该网站通常会以 HTTP 响应的形式回应，令你的 cookie
    失效。结果，当你重新访问该网站时，你需要再次登录。
- en: When Bob checks his email and clicks the link to visit the unknown site, he
    is inadvertently visiting a malicious website. That website is designed to perform
    a CSRF attack by instructing Bob’s browser to make a request to his banking website.
    This request will also send cookies from his browser.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 当鲍勃查看电子邮件并点击链接访问未知网站时，他无意中访问了一个恶意网站。该网站的设计目的是通过指示鲍勃的浏览器向银行网站发送请求来执行 CSRF 攻击。此请求也会从他的浏览器发送
    cookies。
- en: '**CSRF with GET Requests**'
  id: totrans-20
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**使用 GET 请求的 CSRF**'
- en: The way the malicious site exploits Bob’s banking site depends on whether the
    bank accepts transfers via `GET` or `POST` requests. If Bob’s banking site accepts
    transfers via `GET` requests, the malicious site will send the HTTP request with
    either a hidden form or an `<img>` tag. The `GET` and `POST` methods both rely
    on HTML to make browsers send the required HTTP request, and both methods can
    use the hidden form technique, but only the `GET` method can use the `<img>` tag
    technique. In this section, we’ll look at how the attack works with the HTML `<img>`
    tag technique when using the `GET` request method, and we’ll look at the hidden
    form technique in the next section, “[CSRF with `POST` Requests](ch04.xhtml#ch04lev1sec3).”
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 恶意网站如何利用 Bob 的银行网站，取决于银行是否接受通过 `GET` 或 `POST` 请求进行转账。如果 Bob 的银行网站接受通过 `GET`
    请求进行转账，恶意网站将通过隐藏表单或 `<img>` 标签发送 HTTP 请求。`GET` 和 `POST` 方法都依赖 HTML 使浏览器发送所需的 HTTP
    请求，且两种方法都可以使用隐藏表单技术，但只有 `GET` 方法能够使用 `<img>` 标签技术。在本节中，我们将讨论使用 `GET` 请求方法时，攻击如何通过
    HTML `<img>` 标签技术来实现，而关于隐藏表单技术的内容将在下一节 “[使用 `POST` 请求的 CSRF](ch04.xhtml#ch04lev1sec3)”
    中讨论。
- en: 'The attacker needs to include Bob’s cookies in any transfer HTTP request to
    Bob’s banking website. But because the attacker has no way of reading Bob’s cookies,
    the attacker can’t just create an HTTP request and send it to the banking site.
    Instead, the attacker can use the HTML `<img>` tag to create a `GET` request that
    also includes Bob’s cookies. An `<img>` tag renders images on a web page and includes
    an `src` attribute, which tells browsers where to locate image files. When a browser
    renders an `<img>` tag, it will make an HTTP `GET` request to the `src` attribute
    in the tag and include any existing cookies in that request. So, let’s say that
    the malicious site uses a URL like the following that transfers $500 from Bob
    to Joe:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 攻击者需要在任何转账 HTTP 请求中包含 Bob 的 cookies。但由于攻击者无法读取 Bob 的 cookies，攻击者不能仅仅创建一个 HTTP
    请求并将其发送到银行网站。相反，攻击者可以使用 HTML `<img>` 标签来创建一个 `GET` 请求，该请求也包含 Bob 的 cookies。`<img>`
    标签在网页上渲染图像，并包含一个 `src` 属性，指示浏览器图像文件的位置。当浏览器渲染 `<img>` 标签时，它会发出一个 HTTP `GET` 请求到标签中的
    `src` 属性，并在该请求中包含任何现有的 cookies。所以，假设恶意网站使用如下的 URL 将 $500 从 Bob 转账到 Joe：
- en: '[PRE0]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Then the malicious `<img>` tag would use this URL as its source value, as in
    the following tag:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，恶意的 `<img>` 标签会使用这个 URL 作为其源值，如下所示：
- en: '[PRE1]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: As a result, when Bob visits the attacker-owned site, it includes the `<img>`
    tag in its HTTP response, and the browser then makes the HTTP `GET` request to
    the bank. The browser sends Bob’s authentication cookies to get what it thinks
    should be an image. But in fact, the bank receives the request, processes the
    URL in the tag’s `src` attribute, and creates the transfer request.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，当 Bob 访问攻击者控制的网站时，该网站在 HTTP 响应中包含 `<img>` 标签，浏览器随后会发出 HTTP `GET` 请求到银行。浏览器发送
    Bob 的认证 cookies，试图获取它认为应该是图像的内容。但实际上，银行收到请求后，会处理标签中 `src` 属性的 URL，并创建转账请求。
- en: To avoid this vulnerability, developers should never use HTTP `GET` requests
    to perform any backend data-modifying requests, such as transferring money. But
    any request that is read-only should be safe. Many common web frameworks used
    to build websites, such as Ruby on Rails, Django, and so on, will expect developers
    to follow this principle, and so they’ll automatically add CSRF protections to
    `POST` requests but not `GET` requests.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 为了避免这种漏洞，开发者应该避免使用 HTTP `GET` 请求来执行任何会修改后端数据的操作，如转账。但是，任何只读请求应该是安全的。许多用于构建网站的常见Web框架，如
    Ruby on Rails、Django 等，都会期望开发者遵循这一原则，因此它们会自动为 `POST` 请求添加 CSRF 保护，而不为 `GET` 请求添加保护。
- en: '**CSRF with POST Requests**'
  id: totrans-28
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**使用 POST 请求的 CSRF**'
- en: If the bank performs transfers with `POST` requests, you’ll need to use a different
    approach to create a CSRF attack. An attacker couldn’t use an `<img>` tag, because
    an `<img>` tag can’t invoke a `POST` request. Instead, the attacker’s strategy
    will depend on the contents of the `POST` request.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 如果银行通过 `POST` 请求执行转账操作，你将需要使用不同的方法来创建 CSRF 攻击。攻击者不能使用 `<img>` 标签，因为 `<img>`
    标签无法触发 `POST` 请求。相反，攻击者的策略将依赖于 `POST` 请求的内容。
- en: 'The simplest situation involves a `POST` request with the content-type `application/x-www-form-urlencoded`
    or `text/plain`. The content-type is a header that browsers might include when
    sending HTTP requests. The header tells the recipient how the body of the HTTP
    request is encoded. Here is an example of a `text/plain` content-type request:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 最简单的情况是`POST`请求使用`application/x-www-form-urlencoded`或`text/plain`的内容类型。内容类型是浏览器在发送HTTP请求时可能包含的头部。这个头部告诉接收方HTTP请求正文是如何编码的。以下是一个`text/plain`内容类型请求的示例：
- en: '[PRE2]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The content-type ➊ is labeled, and its type is listed along with the character
    encoding of the request. The content-type is important because browsers treat
    types differently (which I’ll get to in a second).
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 内容类型➊已标明，并列出了请求的类型以及字符编码。内容类型非常重要，因为浏览器对不同的类型有不同的处理方式（稍后我会详细说明）。
- en: 'In this situation, it’s possible for a malicious site to create a hidden HTML
    form and submit it silently to the vulnerable site without the target’s knowledge.
    The form can submit a `POST` or `GET` request to a URL and can even submit parameter
    values. Here is an example of some harmful code in the website that the malicious
    link would direct Bob to:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，恶意网站有可能创建一个隐藏的HTML表单，并在目标不知情的情况下悄悄地将其提交到易受攻击的网站。该表单可以提交一个`POST`或`GET`请求到一个URL，甚至可以提交参数值。以下是恶意链接将Bob引导到的网站中的一些有害代码示例：
- en: '[PRE3]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Here, we’re making an HTTP `POST` request ➋ to Bob’s bank with a form (which
    is denoted by the action attribute in the `<form>` tag). Because the attacker
    doesn’t want Bob to see the form, each of the `<input>` elements ➌ are given the
    type `'hidden'`, which makes them invisible on the web page Bob sees. As the final
    step, the attacker includes some JavaScript inside a `<script>` tag to automatically
    submit the form when the page is loaded ➍. The JavaScript does this by calling
    the `getElementByID()` method on the HTML document with the ID of the form (`"csrf-form"`)
    that we set in the second line ➋ as an argument. As with a `GET` request, once
    the form is submitted, the browser makes the HTTP `POST` request to send Bob’s
    cookies to the bank site, which invokes a transfer. Because `POST` requests send
    an HTTP response back to the browser, the attacker hides the response in an iFrame
    using the `display:none` attribute ➊. As a result, Bob doesn’t see it and doesn’t
    realize what has happened.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们正在向Bob的银行发送一个HTTP `POST`请求➋，请求携带一个表单（由`<form>`标签中的`action`属性表示）。由于攻击者不希望Bob看到该表单，因此每个`<input>`元素➌的类型设置为`'hidden'`，使其在Bob看到的网页上不可见。最后，攻击者在`<script>`标签中包含一些JavaScript代码，自动提交表单，当页面加载时执行
    ➍。JavaScript通过调用HTML文档中的`getElementByID()`方法，并传入我们在第二行➋设置的表单ID（`"csrf-form"`）作为参数来完成这一过程。与`GET`请求类似，一旦表单提交，浏览器会发送HTTP
    `POST`请求，将Bob的Cookies发送到银行网站，从而触发转账。由于`POST`请求会将HTTP响应返回给浏览器，攻击者通过使用`display:none`属性➊将响应隐藏在iFrame中。结果，Bob看不见这个响应，也没意识到发生了什么。
- en: In other scenarios, a site might expect the `POST` request to be submitted with
    the content-type `application/json` instead. In some cases, a request that is
    an `application/json` type will have a *CSRF token*. This token is a value that
    is submitted with the HTTP request so the legitimate site can validate that the
    request originated from itself, not from another, malicious site. Sometimes the
    HTTP body of the `POST` request includes the token, but at other times the `POST`
    request has a custom header with a name like `X-CSRF-TOKEN`. When a browser sends
    an `application/json POST` request to a site, it will send an `OPTIONS` HTTP request
    before the `POST` request. The site then returns a response to the `OPTIONS` call
    indicating which types of HTTP requests it accepts and from what trusted origins.
    This is referred to as a preflight `OPTIONS` call. The browser reads this response
    and then makes the appropriate HTTP request, which in our bank example would be
    a `POST` request for the transfer.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 在其他情况下，网站可能期望`POST`请求使用`application/json`的内容类型提交。某些情况下，`application/json`类型的请求会包含一个*CSRF令牌*。这个令牌是与HTTP请求一起提交的值，目的是让合法的网站验证该请求是来源于自身，而不是来自其他恶意网站。有时`POST`请求的HTTP正文中会包含令牌，但在其他情况下，`POST`请求会带有一个类似`X-CSRF-TOKEN`的自定义头。浏览器向网站发送`application/json
    POST`请求时，它会在`POST`请求之前先发送一个`OPTIONS` HTTP请求。网站随后会返回一个响应，告知哪些类型的HTTP请求被接受，并指明哪些可信来源是被允许的。这被称为预检`OPTIONS`调用。浏览器读取这个响应后，再发送适当的HTTP请求，在我们银行的例子中，这将是一个用于转账的`POST`请求。
- en: 'If implemented correctly, the preflight `OPTIONS` call protects against some
    CSRF vulnerabilities: the malicious sites won’t be listed as trusted sites by
    the server, and browsers will only allow specific websites (known as *white-listed
    websites*) to read the HTTP `OPTIONS` response. As a result, because the malicious
    site can’t read the `OPTIONS` response, browsers won’t send the malicious `POST`
    request.'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 如果正确实施，预检 `OPTIONS` 请求可以防止一些 CSRF 漏洞：恶意网站不会被服务器列为受信任的网站，浏览器仅允许特定的网站（即*白名单网站*）读取
    HTTP `OPTIONS` 响应。因此，由于恶意网站无法读取 `OPTIONS` 响应，浏览器也不会发送恶意的 `POST` 请求。
- en: The set of rules defining when and how websites can read responses from each
    other is called *cross-origin resource sharing (CORS)*. CORS restricts resource
    access, including JSON response access, from a domain outside that which served
    the file or is allowed by the site being tested. In other words, when developers
    use CORS to protect a site, you can’t submit an `application/json` request to
    call the application being tested, read the response, and make another call unless
    the site being tested allows it. In some situations, you can bypass these protections
    by changing the `content-type` header to `application/x-www-form-urlencoded`,
    `multipart/form-data`, or `text/plain`. Browsers don’t send preflight `OPTIONS`
    calls for any of these three content-types when making a `POST` request, so a
    CSRF request might work. If it doesn’t, look at the `Access-Control-Allow-Origin`
    header in the server’s HTTP responses to double-check that the server is not trusting
    arbitrary origins. If that response header changes when requests are sent from
    arbitrary origins, the site might have bigger problems because it allows any origin
    to read responses from its server. This allows for CSRF vulnerabilities but might
    also allow malicious attackers to read any sensitive data returned in the server’s
    HTTP responses.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 定义网站何时以及如何相互读取响应的规则集称为*跨域资源共享（CORS）*。CORS 限制了资源访问，包括来自外部域（即未提供文件或未被测试网站允许的域）的
    JSON 响应访问。换句话说，当开发者使用 CORS 来保护网站时，你无法提交 `application/json` 请求去调用被测试的应用程序，读取响应并再次调用，除非被测试的网站允许这么做。在某些情况下，你可以通过将
    `content-type` 头更改为 `application/x-www-form-urlencoded`、`multipart/form-data`
    或 `text/plain` 来绕过这些保护。当使用这些三种内容类型发送 `POST` 请求时，浏览器不会发送预检的 `OPTIONS` 请求，因此 CSRF
    请求可能会成功。如果没有成功，可以查看服务器 HTTP 响应中的 `Access-Control-Allow-Origin` 头，仔细检查服务器是否信任任意来源。如果该响应头在来自任意来源的请求发送时发生变化，则该站点可能存在更大的问题，因为它允许任何来源读取其服务器的响应。这不仅会导致
    CSRF 漏洞，还可能允许恶意攻击者读取服务器 HTTP 响应中返回的任何敏感数据。
- en: '**Defenses Against CSRF Attacks**'
  id: totrans-39
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**防御 CSRF 攻击**'
- en: 'You can mitigate CSRF vulnerabilities in a number of ways. One of the most
    popular forms of protection against CSRF attacks is the CSRF token. Protected
    sites require the CSRF token when requests are submitted that could potentially
    alter data (that is, `POST` requests). In such a situation, a web application
    (like Bob’s bank) would generate a token with two parts: one that Bob would receive
    and one that the application would retain. When Bob attempts to make transfer
    requests, he would have to submit his token, which the bank would then validate
    with its side of the token. The design of these tokens makes them unguessable
    and only accessible to the specific user they’re assigned to (like Bob). In addition,
    they aren’t always obviously named, but some potential examples of names include
    `X-CSRF-TOKEN`, `lia-token`, `rt`, or `form-id`. Tokens can be included in HTTP
    request headers, in an HTTP `POST` body, or as a hidden field, as in the following
    example:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过多种方式缓解 CSRF 漏洞。防御 CSRF 攻击的最常见方法之一是使用 CSRF token。受保护的网站在提交可能会修改数据的请求时（即
    `POST` 请求），会要求使用 CSRF token。在这种情况下，像 Bob 的银行这样的 Web 应用会生成一个包含两部分的 token：一部分 Bob
    会收到，另一部分应用会保留。当 Bob 尝试进行转账请求时，他必须提交自己的 token，银行会将其与服务器端的 token 进行验证。这些 token 的设计使得它们无法被猜测，并且只能由分配给特定用户（如
    Bob）的人访问。此外，它们的命名并不总是显而易见，但一些可能的命名示例包括 `X-CSRF-TOKEN`、`lia-token`、`rt` 或 `form-id`。这些
    token 可以包含在 HTTP 请求头中，HTTP `POST` 请求体中，或作为隐藏字段，如以下示例所示：
- en: '[PRE4]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: In this example, the site could get the CSRF token from a cookie, an embedded
    script on the website, or as part of the content delivered from the site. Regardless
    of the method, only the target’s web browser would know and be able to read the
    value. Because the attacker couldn’t submit the token, they wouldn’t be able to
    successfully submit a `POST` request and wouldn’t be able to carry out a CSRF
    attack. However, just because a site uses CSRF tokens doesn’t mean it’s a dead
    end when you’re searching for vulnerabilities to exploit. Try removing the token,
    changing its value, and so on to confirm the token has been properly implemented.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，网站可以从 Cookie、嵌入的脚本或作为网站内容的一部分获取 CSRF 令牌。无论使用哪种方法，只有目标的网页浏览器才能知道并读取该值。由于攻击者无法提交令牌，他们将无法成功提交
    `POST` 请求，也无法执行 CSRF 攻击。然而，仅仅因为网站使用了 CSRF 令牌，并不意味着在寻找漏洞时就会走入死胡同。尝试移除令牌、修改其值等操作，以确认令牌是否已正确实现。
- en: The other way sites protect themselves is by using CORS; however, this isn’t
    foolproof because it relies on browser security and ensuring proper CORS configurations
    to determine when third-party sites can access responses. Attackers can sometimes
    bypass CORS by changing the content-type from `application/json` to `application/x-www-form-urlencoded`
    or by using a `GET` request instead of a `POST` request because of misconfigurations
    on the server side. The reason the bypass works is that browsers will automatically
    send an `OPTIONS HTTP` request when the content type is `application/json` but
    won’t automatically send an `OPTIONS HTTP` request if it’s a `GET` request or
    the content type is `application/x-www-form-urlencoded`.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 网站保护自己的一种方式是使用 CORS；然而，这并非万无一失，因为它依赖于浏览器的安全性，并确保适当的 CORS 配置，以确定何时第三方网站可以访问响应。攻击者有时可以通过将内容类型从
    `application/json` 更改为 `application/x-www-form-urlencoded` 或使用 `GET` 请求而非 `POST`
    请求来绕过 CORS，因为服务器端的配置可能存在问题。绕过之所以有效，是因为当内容类型为 `application/json` 时，浏览器会自动发送 `OPTIONS
    HTTP` 请求，但如果是 `GET` 请求或内容类型为 `application/x-www-form-urlencoded`，浏览器则不会自动发送 `OPTIONS
    HTTP` 请求。
- en: Lastly, there are two additional and less common CSRF mitigation strategies.
    First, the site could check the value of the `Origin` or `Referer` header submitted
    with an HTTP request and ensure it contains the expected value. For example, in
    some cases, Twitter will check the `Origin` header and, if it’s not included,
    check the `Referer` header. This works because browsers control these headers
    and attackers can’t set or change them remotely (obviously, this excludes exploiting
    a vulnerability in browsers or browser plug-ins that might allow an attacker to
    control either header). Second, browsers are now beginning to implement support
    for a new cookie attribute called `samesite`. This attribute can be set as `strict`
    or `lax`. When set as `strict`, the browser will not send the cookie with any
    HTTP request that doesn’t originate from the site. This includes even simple HTTP
    `GET` requests. For example, if you were logged into Amazon and it used `strict
    samesite` cookies, the browser would not submit your cookies if you were following
    a link from another site. Also, Amazon would not recognize you as logged in until
    you visited another Amazon web page and the cookies were then submitted. In contrast,
    setting the `samesite` attribute as `lax` instructs browsers to send cookies with
    initial `GET` requests. This supports the design principle that `GET` requests
    should never alter data on the server side. In this case, if you were logged into
    Amazon and it used `lax samesite` cookies, the browser would submit your cookies
    and Amazon would recognize you as logged in if you had been redirected there from
    another site.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，还有两种额外的、较少见的CSRF缓解策略。首先，网站可以检查提交的HTTP请求中的`Origin`或`Referer`头的值，并确保其包含预期的值。例如，在某些情况下，Twitter会检查`Origin`头，如果该头未包含，会检查`Referer`头。之所以有效，是因为浏览器控制这些头部，攻击者无法远程设置或更改它们（显然，这不包括利用浏览器或浏览器插件中的漏洞来允许攻击者控制这些头部）。第二，浏览器现在开始实现对一种名为`samesite`的新cookie属性的支持。该属性可以设置为`strict`或`lax`。当设置为`strict`时，浏览器不会发送任何来自非本站点的HTTP请求的cookie。这甚至包括简单的HTTP
    `GET`请求。例如，如果你已登录Amazon并使用`strict samesite` cookies，当你从另一个网站点击链接时，浏览器不会提交你的cookie。此时，Amazon不会识别你为已登录状态，直到你访问另一个Amazon网页并提交了cookie。相反，将`samesite`属性设置为`lax`指示浏览器在初始的`GET`请求中发送cookie。这支持`GET`请求不应改变服务器端数据的设计原则。在这种情况下，如果你已登录Amazon并使用`lax
    samesite` cookies，当你从另一个网站被重定向到Amazon时，浏览器会提交你的cookie，Amazon会识别你为已登录状态。
- en: '**Shopify Twitter Disconnect**'
  id: totrans-45
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**Shopify Twitter断开连接**'
- en: '**Difficulty:** Low'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: '**难度：** 低'
- en: '**URL:** *https://twitter-commerce.shopifyapps.com/auth/twitter/disconnect/*'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: '**URL：** *https://twitter-commerce.shopifyapps.com/auth/twitter/disconnect/*'
- en: '**Source:** *[https://www.hackerone.com/reports/111216/](https://www.hackerone.com/reports/111216/)*'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: '**来源：** *[https://www.hackerone.com/reports/111216/](https://www.hackerone.com/reports/111216/)*'
- en: '**Date reported:** January 17, 2016'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: '**报告日期：** 2016年1月17日'
- en: '**Bounty paid:** $500'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: '**奖励支付：** $500'
- en: 'When you’re looking for potential CSRF vulnerabilities, be on the lookout for
    `GET` requests that modify server-side data. For example, a hacker discovered
    a vulnerability in a Shopify feature that integrated Twitter into the site to
    let shop owners tweet about their products. The feature also allowed users to
    disconnect a Twitter account from a connected shop. The URL to disconnect a Twitter
    account was the following:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 在寻找潜在的CSRF漏洞时，要留意那些会修改服务器端数据的`GET`请求。例如，一名黑客发现了一个Shopify功能的漏洞，该功能将Twitter集成到站点中，允许商店所有者发布关于其产品的推文。该功能还允许用户断开与连接商店的Twitter帐户的关联。断开Twitter帐户的URL如下所示：
- en: '[PRE5]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'As it turns out, visiting this URL would send a `GET` request to disconnect
    the account, as follows:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 事实证明，访问此URL会发送一个`GET`请求以断开账户，如下所示：
- en: '[PRE6]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: In addition, when the link was originally implemented, Shopify wasn’t validating
    the legitimacy of the `GET` requests sent to it, making the URL vulnerable to
    CSRF.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，当该链接最初实施时，Shopify并未验证发送给它的`GET`请求的合法性，这使得该URL容易受到CSRF攻击。
- en: 'The hacker WeSecureApp, who filed the report, provided the following proof-of-concept
    HTML document:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 提交报告的黑客WeSecureApp提供了以下概念验证HTML文档：
- en: '[PRE7]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: When opened, this HTML document would cause the browser to send an HTTP `GET`
    request to *https://twitter-commerce.shopifyapps.com* through the `<img>` tag’s
    `src` attribute ➊. If someone with a Twitter account connected to Shopify visited
    a web page with this `<img>` tag, their Twitter account would be disconnected
    from Shopify.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 当打开时，这个 HTML 文档会导致浏览器通过 `<img>` 标签的 `src` 属性 ➊ 向 *https://twitter-commerce.shopifyapps.com*
    发送一个 HTTP `GET` 请求。如果有一个连接到 Shopify 的 Twitter 账户访问了包含这个 `<img>` 标签的网页，他们的 Twitter
    账户将会与 Shopify 断开连接。
- en: '***Takeaways***'
  id: totrans-59
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***关键点***'
- en: Keep an eye out for HTTP requests that perform some action on the server, such
    as disconnecting a Twitter account, via a `GET` request. As mentioned earlier,
    `GET` requests should never modify any data on the server. In this situation,
    you could have found the vulnerability by using a proxy server, such as Burp or
    OWASP’s ZAP, to monitor the HTTP requests being sent to Shopify.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 留意那些执行某些服务器端操作的 HTTP 请求，例如通过 `GET` 请求断开 Twitter 账户。如前所述，`GET` 请求永远不应该修改服务器上的任何数据。在这种情况下，你可以通过使用代理服务器，例如
    Burp 或 OWASP 的 ZAP，来监控发送到 Shopify 的 HTTP 请求，发现这个漏洞。
- en: '**Change Users Instacart Zones**'
  id: totrans-61
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**更改用户 Instacart 区域**'
- en: '**Difficulty:** Low'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: '**难度：** 低'
- en: '**URL:** *https://admin.instacart.com/api/v2/zones/*'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: '**网址：** *https://admin.instacart.com/api/v2/zones/*'
- en: '**Source:** *[https://hackerone.com/reports/157993/](https://hackerone.com/reports/157993/)*'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: '**来源：** *[https://hackerone.com/reports/157993/](https://hackerone.com/reports/157993/)*'
- en: '**Date reported:** August 9, 2015'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: '**报告日期：** 2015年8月9日'
- en: '**Bounty paid:** $100'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: '**奖励金额：** $100'
- en: 'When you’re looking at the attack surface, remember to consider a website’s
    API endpoints as well as its web pages. Instacart is a grocery delivery app that
    allows its deliverers to define the zones they work in. The site updated these
    zones with a `POST` request to the Instacart admin subdomain. A hacker discovered
    that the zone’s endpoint on this subdomain was vulnerable to CSRF. For example,
    you could modify a target’s zone with the following code:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 当你查看攻击面时，记得考虑网站的 API 端点以及它的网页。Instacart 是一个食品配送应用程序，允许配送员定义他们工作的区域。该网站通过向 Instacart
    管理子域发送 `POST` 请求来更新这些区域。一名黑客发现该子域上的区域端点存在 CSRF 漏洞。例如，你可以通过以下代码修改目标的区域：
- en: '[PRE8]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'In this example, the hacker created an HTML form to send an HTTP `POST` request
    to the `/api/v2/zones` endpoint ➊. The hacker included two hidden inputs: one
    to set the user’s new zone to the ZIP code `10001` ➋ and one to set the API’s
    `override` parameter to `true` ➌ so the user’s current `zip` value was replaced
    with the hacker’s submitted value. Additionally, the hacker included a submit
    button to make the `POST` request ➍, unlike the Shopify example, which used an
    auto-submitting JavaScript function.'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，黑客创建了一个 HTML 表单，向 `/api/v2/zones` 端点发送了一个 HTTP `POST` 请求 ➊。黑客包括了两个隐藏输入框：一个用来将用户的新区域设置为邮政编码
    `10001` ➋，另一个将 API 的 `override` 参数设置为 `true` ➌，这样用户当前的 `zip` 值就被黑客提交的值替换了。此外，黑客还包括了一个提交按钮来发起
    `POST` 请求 ➍，不同于 Shopify 示例中使用的自动提交的 JavaScript 函数。
- en: Although this example is still successful, the hacker could improve the exploit
    by using the techniques described earlier, such as using a hidden iFrame to auto-submit
    the request on the target’s behalf. This would demonstrate to the Instacart bug
    bounty triagers how an attacker could use this vulnerability with less target
    action; vulnerabilities that are entirely attacker controlled are more likely
    to be successfully exploited than those that aren’t.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管这个例子依然成功，但黑客可以通过使用之前描述的技巧来改善这个漏洞利用方式，比如使用隐藏的 iFrame 来代表目标自动提交请求。这将向 Instacart
    的漏洞奖励评审员展示攻击者如何使用这种漏洞，减少目标的操作；完全由攻击者控制的漏洞，比那些需要目标操作的漏洞更容易成功利用。
- en: '***Takeaways***'
  id: totrans-71
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***关键点***'
- en: When you’re looking for exploits, broaden your attack scope and look beyond
    just a website’s pages to include its API endpoints, which offer great potential
    for vulnerabilities. Occasionally, developers forget that hackers can discover
    and exploit API endpoints, because they aren’t readily available like web pages.
    For example, mobile applications often make HTTP requests to API endpoints, which
    you can monitor with Burp or ZAP just as you do websites.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 在寻找漏洞时，要拓宽攻击范围，不仅要关注网站页面，还要包括它的 API 端点，这些端点常常潜藏着巨大的漏洞风险。有时，开发者会忘记黑客可以发现并利用 API
    端点，因为它们不像网页那样容易被发现。例如，移动应用程序通常会向 API 端点发送 HTTP 请求，你可以使用 Burp 或 ZAP 监控这些请求，就像监控网站一样。
- en: '**Badoo Full Account Takeover**'
  id: totrans-73
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**Badoo 完整账户接管**'
- en: '**Difficulty:** Medium'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: '**难度：** 中'
- en: '**URL:** *[https://www.badoo.com/](https://www.badoo.com/)*'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: '**网址：** *[https://www.badoo.com/](https://www.badoo.com/)*'
- en: '**Source:** *[https://hackerone.com/reports/127703/](https://hackerone.com/reports/127703/)*'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: '**来源：** *[https://hackerone.com/reports/127703/](https://hackerone.com/reports/127703/)*'
- en: '**Date reported:** April 1, 2016'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: '**报告日期：** 2016年4月1日'
- en: '**Bounty paid:** $852'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: '**奖励支付：** $852'
- en: Although developers often use CSRF tokens to protect against CSRF vulnerabilities,
    in some cases, attackers can steal the tokens, as you’ll see in this bug. If you
    explore the social networking website *[https://www.badoo.com/](https://www.badoo.com/)*,
    you’ll see that it uses CSRF tokens. More specifically, it uses a URL parameter,
    `rt`, which is unique to each user. When Badoo’s bug bounty program went live
    on HackerOne, I couldn’t find a way to exploit it. However, the hacker Mahmoud
    Jamal did.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管开发者通常使用CSRF令牌来防止CSRF漏洞，但在某些情况下，攻击者可以窃取令牌，正如你在这个漏洞中看到的那样。如果你浏览社交网站 *[https://www.badoo.com/](https://www.badoo.com/)*，你会看到它使用了CSRF令牌。更具体地说，它使用了一个名为`rt`的URL参数，该参数对每个用户都是唯一的。当Badoo的漏洞奖励计划在HackerOne上线时，我无法找到利用它的方法。然而，黑客Mahmoud
    Jamal做到了。
- en: Jamal recognized the `rt` parameter and its significance. He also noticed that
    the parameter was returned in almost all JSON responses. Unfortunately, this wasn’t
    helpful because CORS protects Badoo from attackers reading those responses, since
    they’re encoded as `application/json` content types. But Jamal kept digging.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: Jamal识别了`rt`参数及其重要性。他还注意到该参数几乎在所有的JSON响应中都会返回。不幸的是，这并没有提供帮助，因为CORS保护了Badoo，防止攻击者读取这些响应，因为它们以`application/json`内容类型进行编码。但Jamal仍然继续深入挖掘。
- en: 'Jamal eventually found the JavaScript file *[https://eu1.badoo.com/worker-scope/chrome-service-worker.js](https://eu1.badoo.com/worker-scope/chrome-service-worker.js)*,
    which contained a variable called `url_stats` and was set to the following value:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: Jamal最终找到了包含名为`url_stats`的变量的JavaScript文件 *[https://eu1.badoo.com/worker-scope/chrome-service-worker.js](https://eu1.badoo.com/worker-scope/chrome-service-worker.js)*，该变量被设置为以下值：
- en: '[PRE9]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'The `url_stats` variable stored a URL that contained the user’s unique `rt`
    value as a parameter when the user’s browser accessed the JavaScript file ➊. Even
    better, to obtain the user’s `rt` value, an attacker would just need the target
    to visit a malicious web page that would access the JavaScript file. CORS does
    not block this because browsers are allowed to read and embed remote JavaScript
    files from external sources. The attacker could then use the `rt` value to link
    any social media account with the user’s Badoo account. As a result, the attacker
    could invoke HTTP `POST` requests to modify the target’s account. Here’s the HTML
    page Jamal used to accomplish this exploit:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: '`url_stats`变量存储了一个URL，其中包含用户唯一的`rt`值作为参数，当用户的浏览器访问该JavaScript文件时➊。更好的是，为了获取用户的`rt`值，攻击者只需要让目标访问一个恶意网页，该网页将访问该JavaScript文件。CORS不会阻止这种情况，因为浏览器允许读取和嵌入来自外部源的远程JavaScript文件。攻击者随后可以使用`rt`值将任何社交媒体账户与用户的Badoo账户关联起来。因此，攻击者可以发起HTTP
    `POST`请求来修改目标的账户。以下是Jamal用来实现这个漏洞的HTML页面：'
- en: '[PRE10]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: When a target loads this page, the page will load the Badoo JavaScript by referencing
    it as the `src` attribute in a `<script>` tag ➊. Having loaded the script, the
    web page then calls the JavaScript function `window.onload`, which defines an
    anonymous JavaScript function ➌. Browsers call the `onload` event handler when
    a web page loads; because the function Jamal defined is in the `window.onload`
    handler, his function will always be called when the page is loaded.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 当目标加载此页面时，页面将通过在`<script>`标签的`src`属性中引用Badoo的JavaScript来加载它➊。加载了脚本后，网页会调用JavaScript函数`window.onload`，该函数定义了一个匿名JavaScript函数➌。浏览器在网页加载时会调用`onload`事件处理程序；由于Jamal定义的函数位于`window.onload`处理程序中，他的函数将在页面加载时始终被调用。
- en: 'Next, Jamal created a `csrf_code` variable ➍ and assigned it the return value
    of a function he defined at ➋ called `getCSRFcode`. The `getCSRFcode` function
    takes and splits a string into an array of strings at each `''=''` character.
    It then returns the value of the third member of the array. When the function
    parses the variable `url_stats` from Badoo’s vulnerable JavaScript file at ➍,
    it splits the string into the following array value:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，Jamal创建了一个`csrf_code`变量➍，并将其赋值为他在➋处定义的一个名为`getCSRFcode`的函数的返回值。`getCSRFcode`函数接受一个字符串，并在每个`'='`字符处将其拆分成字符串数组。然后它返回数组的第三个成员。当该函数解析Badoo的漏洞JavaScript文件中的`url_stats`变量时，它将字符串拆分成以下数组值：
- en: '[PRE11]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Then the function returns the third member of the array, which is the `rt` value,
    and assigns that to `csrf_code`.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 然后该函数返回数组的第三个成员，即`rt`值，并将其赋值给`csrf_code`。
- en: Once he had the CSRF token, Jamal created the `csrf_url` variable, which stores
    a URL to Badoo’s */google/verify.phtml* web page. The web page links his own Google
    account to the target’s Badoo account ➎. This page requires some parameters, which
    are hardcoded into the URL string. I won’t cover them in detail here because they’re
    specific to Badoo. However, note the final `rt` parameter, which doesn’t have
    a hardcoded value. Instead, `csrf_code` is concatenated to the end of the URL
    string so it’s passed as the `rt` parameter’s value. Jamal then makes an HTTP
    request by invoking `window.location` ➏ and assigns it to `csrf_url`, which redirects
    the visiting user’s browser to the URL at ➎. This results in a `GET` request to
    Badoo, which validates the `rt` parameter and processes the request to link the
    target’s Badoo account to Jamal’s Google account, thereby completing the account
    takeover.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦获得了CSRF令牌，Jamal 创建了 `csrf_url` 变量，该变量存储了指向 Badoo 的 */google/verify.phtml*
    网页的 URL。该网页将他的 Google 账户与目标的 Badoo 账户链接起来 ➎。此页面需要一些参数，这些参数被硬编码到 URL 字符串中。我在这里不会详细讨论它们，因为它们是
    Badoo 特有的。然而，请注意最后的 `rt` 参数，它没有硬编码的值。相反，`csrf_code` 被拼接到 URL 字符串的末尾，因此它作为 `rt`
    参数的值被传递。然后，Jamal 通过调用 `window.location` ➏ 发起一个 HTTP 请求，并将其赋值给 `csrf_url`，从而将访问用户的浏览器重定向到
    ➎ 处的 URL。这会导致向 Badoo 发起一个 `GET` 请求，Badoo 会验证 `rt` 参数并处理该请求，将目标的 Badoo 账户与 Jamal
    的 Google 账户关联，从而完成账户接管。
- en: '***Takeaways***'
  id: totrans-90
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***重点总结***'
- en: Where there’s smoke, there’s fire. Jamal noticed that the `rt` parameter was
    being returned in different locations, particularly in JSON responses. For that
    reason, he rightly guessed that `rt` might show up someplace where an attacker
    could access and exploit it, which in this case was a JavaScript file. If you
    feel like a site might be vulnerable, keep digging. In this case, I thought it
    was odd that the CSRF token would only be five digits long and included in URLs.
    Normally, tokens are much longer, making them harder to guess, and included in
    HTTP `POST` request bodies, not URLs. Use a proxy and check all the resources
    that are being called when you visit a site or application. Burp allows you to
    search through all your proxy history to look for specific terms or values, which
    would have revealed the `rt` value included in the JavaScript files here. You
    might find an information leak with sensitive data, such as a CSRF token.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 哪里有烟，哪里就有火。Jamal 注意到 `rt` 参数在不同的位置被返回，特别是在 JSON 响应中。因此，他正确地猜测 `rt` 可能会出现在攻击者可以访问并利用的位置，在这种情况下就是一个
    JavaScript 文件。如果你觉得一个站点可能存在漏洞，继续深入检查。在这种情况下，我觉得奇怪的是 CSRF 令牌居然只有五个数字，并且包含在 URL
    中。通常，令牌要长得多，这样更难猜测，而且应该包含在 HTTP `POST` 请求的主体中，而不是 URL 中。使用代理并检查访问站点或应用时调用的所有资源。Burp
    允许你搜索代理历史记录中的特定术语或值，这可以帮助你发现这里的 JavaScript 文件中包含的 `rt` 值。你可能会发现敏感数据泄漏，例如 CSRF
    令牌。
- en: '**Summary**'
  id: totrans-92
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**总结**'
- en: CSRF vulnerabilities represent another attack vector that attackers can execute
    without the target even knowing or actively performing an action. Finding CSRF
    vulnerabilities can take some ingenuity and a willingness to test all functionality
    on a site.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: CSRF 漏洞代表了攻击者可以在目标用户不知情或没有主动执行任何操作的情况下利用的另一种攻击向量。发现 CSRF 漏洞可能需要一些独创性和测试站点上所有功能的意愿。
- en: Generally, application frameworks, such as Ruby on Rails, are increasingly protecting
    web forms if the site is performing `POST` requests; however, this isn’t the case
    for `GET` requests. Therefore, be sure to keep an eye out for any `GET` HTTP calls
    that change server-side user data (like disconnecting Twitter accounts). Also,
    although I didn’t include an example of it, if you see that a site is sending
    a CSRF token with a `POST` request, you can try changing the CSRF token value
    or removing it entirely to ensure the server is validating its existence.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，应用框架，如 Ruby on Rails，正在越来越多地保护 Web 表单，尤其是当站点执行 `POST` 请求时；但是，`GET` 请求并不在保护范围之内。因此，一定要注意任何可能更改服务器端用户数据的
    `GET` HTTP 调用（例如断开 Twitter 账户连接）。另外，虽然我没有提供这个例子，但如果你看到站点通过 `POST` 请求发送 CSRF 令牌，你可以尝试更改
    CSRF 令牌的值或完全删除它，以确保服务器在验证其存在性。
