- en: '11'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '11'
- en: SIMD Instructions
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: SIMD指令
- en: '![](image_fi/book_art/chapterart.png)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![](image_fi/book_art/chapterart.png)'
- en: This chapter discusses the *vector instructions* on the x86-64\. This special
    class of instructions provides parallel processing, traditionally known as *single-instruction,
    multiple-data (**SIMD)* instructions because, quite literally, a single instruction
    operates on several pieces of data concurrently. As a result of this concurrency,
    SIMD instructions can often execute several times faster (in theory, as much as
    32 to 64 times faster) than the comparable *single-instruction, single-data (SISD),*
    or *scalar,* instructions that compose the standard x86-64 instruction set.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章讨论了x86-64上的*向量指令*。这类特殊指令提供并行处理，传统上被称为*单指令，多数据（**SIMD**）*指令，因为字面上来说，一条指令同时作用于多个数据块。由于这种并发性，SIMD指令通常可以比相应的*单指令，单数据（SISD）*或*标量*指令执行得更快（理论上，速度可以快32到64倍），而这些标准x86-64指令集中的标量指令就是这样。
- en: 'The x86-64 actually provides three sets of vector instructions: the Multimedia
    Extensions (MMX) instruction set, the Streaming SIMD Extensions (SSE) instruction
    set, and the Advanced Vector Extensions (AVX) instruction set. This book does
    not consider the MMX instructions as they are obsolete (SSE equivalents exist
    for the MMX instructions).'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: x86-64实际上提供了三组向量指令：多媒体扩展（MMX）指令集、流式SIMD扩展（SSE）指令集和高级向量扩展（AVX）指令集。本书不考虑MMX指令，因为它们已经过时（SSE指令集有MMX指令的等效功能）。
- en: The x86-64 vector instruction set (SSE/AVX) is almost as large as the scalar
    instruction set. A whole book could be written about SSE/AVX programming and algorithms.
    However, this is not that book; SIMD and parallel algorithms are an advanced subject
    beyond the scope of this book, so this chapter settles for introducing a fair
    number of SSE/AVX instructions and leaves it at that.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: x86-64向量指令集（SSE/AVX）几乎与标量指令集一样大。关于SSE/AVX编程和算法，完全可以写成一本书。然而，这不是那本书；SIMD和并行算法是超出本书范围的高级主题，因此本章仅介绍了一些SSE/AVX指令，并到此为止。
- en: This chapter begins with some prerequisite information. First, it begins with
    a discussion of the x86-64 vector architecture and streaming data types. Then,
    it discusses how to detect the presence of various vector instructions (which
    are not present on all x86-64 CPUs) by using the `cpuid` instruction. Because
    most vector instructions require special memory alignment for data operands, this
    chapter also discusses MASM segments.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 本章首先介绍一些前提信息。首先，它开始讨论x86-64向量架构和流数据类型。然后，讨论如何通过使用`cpuid`指令来检测各种向量指令的存在（并非所有x86-64
    CPU都具备这些指令）。由于大多数向量指令需要特殊的内存对齐来处理数据操作数，本章还讨论了MASM段。
- en: 11.1 The SSE/AVX Architectures
  id: totrans-7
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 11.1 SSE/AVX架构
- en: 'Let’s begin by taking a quick look at the SSE and AVX features in the x64-86
    CPUs. The SSE and AVX instructions have several variants: the original SSE, plus
    SSE2, SSE3, SSE3, SSE4 (SSE4.1 and SSE4.2), AVX, AVX2 (AVX and AVX2 are sometimes
    called AVX-256), and AVX-512\. SSE3 was introduced along with the Pentium 4F (Prescott)
    CPU, Intel’s first 64-bit CPU. Therefore, you can assume that all Intel 64-bit
    CPUs support the SSE3 and earlier SIMD instructions.'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们首先快速了解一下x64-86 CPU中的SSE和AVX功能。SSE和AVX指令有几个变种：原始的SSE，以及SSE2、SSE3、SSE3、SSE4（SSE4.1和SSE4.2）、AVX、AVX2（AVX和AVX2有时被称为AVX-256），以及AVX-512。SSE3是在Pentium
    4F（Prescott）CPU发布时引入的，这是英特尔的第一款64位CPU。因此，你可以假设所有英特尔64位CPU都支持SSE3及之前的SIMD指令。
- en: 'The SSE/AVX architectures have three main generations:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: SSE/AVX架构有三个主要的代际：
- en: The SSE architecture, which (on 64-bit CPUs) provided sixteen 128-bit XMM registers
    supporting integer and floating-point data types
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: SSE架构（在64位CPU上）提供了十六个128位的XMM寄存器，支持整数和浮点数据类型
- en: The AVX/AVX2 architecture, which supported sixteen 256-bit YMM registers (also
    supporting integer and floating-point data types)
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: AVX/AVX2架构，支持十六个256位的YMM寄存器（同样支持整数和浮点数据类型）
- en: The AVX-512 architecture, which supported up to thirty-two 512-bit ZMM registers
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: AVX-512架构，支持最多三十二个512位的ZMM寄存器
- en: As a general rule, this chapter sticks to AVX2 and earlier instructions in its
    examples. Please see the Intel and AMD CPU manuals for a discussion of the additional
    instruction set extensions such as AVX-512\. This chapter does not attempt to
    describe every SSE or AVX instruction. Most streaming instructions have very specialized
    purposes and aren’t particularly useful in generic applications.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 一般来说，本章的示例使用的是 AVX2 及以前的指令。有关 AVX-512 等附加指令集扩展的讨论，请参阅英特尔和 AMD CPU 手册。本章不会试图描述每一条
    SSE 或 AVX 指令。大多数流式指令有非常专业的用途，并不适用于通用应用。
- en: 11.2 Streaming Data Types
  id: totrans-14
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 11.2 流式数据类型
- en: 'The SSE and AVX programming models support two basic data types: scalars and
    vectors. *Scalars* hold one single- or double-precision floating-point value.
    *Vectors* hold multiple floating-point or integer values (between 2 and 32 values,
    depending on the scalar data type of byte, word, dword, qword, single precision,
    or double precision, and the register and memory size of 128 or 256 bits).'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: SSE 和 AVX 编程模型支持两种基本数据类型：标量和向量。*标量*保存一个单精度或双精度浮点值。*向量*保存多个浮点数或整数值（根据标量数据类型（字节、字、双字、四字、单精度或双精度）和寄存器及内存大小（128
    位或 256 位），值的数量在 2 到 32 之间）。
- en: The XMM registers (XMM0 to XMM15) can hold a single 32-bit floating-point value
    (a scalar) or four single-precision floating-point values (a vector). The YMM
    registers (YMM0 to YMM15) can hold eight single-precision (32-bit) floating-point
    values (a vector); see [Figure 11-1](#figure11-1).
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: XMM 寄存器（XMM0 到 XMM15）可以容纳一个 32 位浮点值（标量）或四个单精度浮点值（向量）。YMM 寄存器（YMM0 到 YMM15）可以容纳八个单精度（32
    位）浮点值（向量）；参见[图 11-1](#figure11-1)。
- en: '![f11001](image_fi/501089c11/f11001.png)'
  id: totrans-17
  prefs: []
  type: TYPE_IMG
  zh: '![f11001](image_fi/501089c11/f11001.png)'
- en: 'Figure 11-1: Packed and scalar single-precision floating-point data type'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11-1：打包和标量的单精度浮点数据类型
- en: The XMM registers can hold a single double-precision scalar value or a vector
    containing a pair of double-precision values. The YMM registers can hold a vector
    containing four double-precision floating-point values, as shown in [Figure 11-2](#figure11-2).
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: XMM 寄存器可以容纳一个双精度标量值或一个包含一对双精度值的向量。YMM 寄存器可以容纳一个包含四个双精度浮点值的向量，如[图 11-2](#figure11-2)所示。
- en: '![f11002](image_fi/501089c11/f11002.png)'
  id: totrans-20
  prefs: []
  type: TYPE_IMG
  zh: '![f11002](image_fi/501089c11/f11002.png)'
- en: 'Figure 11-2: Packed and scalar double-precision floating-point type'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11-2：打包的和标量的双精度浮点类型
- en: The XMM registers can hold 16 byte values (YMM registers can hold 32 byte values),
    allowing the CPU to perform 16 (32) byte-sized computations with one instruction
    ([Figure 11-3](#figure11-3)).
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: XMM 寄存器可以容纳 16 个字节值（YMM 寄存器可以容纳 32 个字节值），使 CPU 能够通过一条指令执行 16 个（32 个）字节大小的运算（[图
    11-3](#figure11-3)）。
- en: '![f11003](image_fi/501089c11/f11003.png)'
  id: totrans-23
  prefs: []
  type: TYPE_IMG
  zh: '![f11003](image_fi/501089c11/f11003.png)'
- en: 'Figure 11-3: Packed byte data type'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11-3：打包的字节数据类型
- en: The XMM registers can hold eight word values (YMM registers can hold sixteen
    word values), allowing the CPU to perform eight (sixteen) 16-bit word-sized integer
    computations with one instruction ([Figure 11-4](#figure11-4)).
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: XMM 寄存器可以容纳八个字大小的值（YMM 寄存器可以容纳十六个字大小的值），使 CPU 能够通过一条指令执行八个（十六个）16 位字大小的整数运算（[图
    11-4](#figure11-4)）。
- en: '![f11004](image_fi/501089c11/f11004.png)'
  id: totrans-26
  prefs: []
  type: TYPE_IMG
  zh: '![f11004](image_fi/501089c11/f11004.png)'
- en: 'Figure 11-4: Packed word data type'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11-4：打包的字数据类型
- en: The XMM registers can hold four dword values (YMM registers can hold eight dword
    values), allowing the CPU to perform four (eight) 32-bit dword-sized integer computations
    with one instruction ([Figure 11-5](#figure11-5)).
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: XMM 寄存器可以容纳四个双字值（YMM 寄存器可以容纳八个双字值），使 CPU 能够通过一条指令执行四个（八个）32 位双字大小的整数运算（[图 11-5](#figure11-5)）。
- en: '![f11005](image_fi/501089c11/f11005.png)'
  id: totrans-29
  prefs: []
  type: TYPE_IMG
  zh: '![f11005](image_fi/501089c11/f11005.png)'
- en: 'Figure 11-5: Packed double-word data type'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11-5：打包的双字数据类型
- en: The XMM registers can hold two qword values (YMM registers can hold four qword
    values), allowing the CPU to perform two (four) 64-bit qword computations with
    one instruction ([Figure 11-6](#figure11-6)).
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: XMM 寄存器可以容纳两个四字值（YMM 寄存器可以容纳四个四字值），使 CPU 能够通过一条指令执行两个（四个）64 位四字运算（[图 11-6](#figure11-6)）。
- en: '![f11006](image_fi/501089c11/f11006.png)'
  id: totrans-32
  prefs: []
  type: TYPE_IMG
  zh: '![f11006](image_fi/501089c11/f11006.png)'
- en: 'Figure 11-6: Packed quad-word data type'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11-6：打包的四字数据类型
- en: Intel’s documentation calls the vector elements in an XMM and a YMM register
    *lanes*. For example, a 128-bit XMM register has 16 bytes. Bits 0 to 7 are lane
    0, bits 8 to 15 are lane 1, bits 16 to 23 are lane 2, . . . , and bits 120 to
    127 are lane 15\. A 256-bit YMM register has 32 byte-sized lanes, and a 512-bit
    ZMM register has 64 byte-sized lanes.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 英特尔的文档将 XMM 和 YMM 寄存器中的向量元素称为 *通道*。例如，128 位的 XMM 寄存器有 16 个字节。位 0 到 7 是通道 0，位
    8 到 15 是通道 1，位 16 到 23 是通道 2，……，位 120 到 127 是通道 15。256 位的 YMM 寄存器有 32 个字节大小的通道，而
    512 位的 ZMM 寄存器有 64 个字节大小的通道。
- en: Similarly, a 128-bit XMM register has eight word-sized lanes (lanes 0 to 7).
    A 256-bit YMM register has sixteen word-sized lanes (lanes 0 to 15). On AVX-512-capable
    CPUs, a ZMM register (512 bits) has thirty-two word-sized lanes, numbered 0 to
    31.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 类似地，128 位的 XMM 寄存器有八个 word 大小的通道（通道 0 到 7）。256 位的 YMM 寄存器有十六个 word 大小的通道（通道
    0 到 15）。在支持 AVX-512 的 CPU 上，ZMM 寄存器（512 位）有三十二个 word 大小的通道，编号从 0 到 31。
- en: An XMM register has four dword-sized lanes (lanes 0 to 3); it also has four
    single-precision (32-bit) floating-point lanes (also numbered 0 to 3). A YMM register
    has eight dword or single-precision lanes (lanes 0 to 7). An AVX2 ZMM register
    has sixteen dword or single-precision-sized lanes (numbers 0 to 15).
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: XMM 寄存器有四个 dword 大小的通道（通道 0 到 3）；它还具有四个单精度（32 位）浮点通道（同样编号为 0 到 3）。YMM 寄存器有八个
    dword 或单精度通道（通道 0 到 7）。AVX2 ZMM 寄存器有十六个 dword 或单精度大小的通道（编号为 0 到 15）。
- en: XMM registers support two qword-sized lanes (or two double-precision lanes),
    numbered 0 to 1\. As expected, a YMM register has twice as many (four lanes, numbered
    0 to 3), and an AVX2 ZMM register has four times as many lanes (0 to 7).
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: XMM 寄存器支持两个 qword 大小的通道（或两个双精度通道），编号为 0 到 1。按预期，YMM 寄存器有两倍的数量（四个通道，编号为 0 到 3），而
    AVX2 ZMM 寄存器则有四倍的数量（通道 0 到 7）。
- en: Several SSE/AVX instructions refer to various lanes within these registers.
    In particular, the shuffle and unpack instructions allow you to move data between
    lanes in SSE and AVX operands. See “The Shuffle and Unpack Instructions” on page
    625 for examples of lane usage.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 若干 SSE/AVX 指令引用了这些寄存器中的各个通道。特别是，shuffle 和 unpack 指令允许在 SSE 和 AVX 操作数的通道之间移动数据。有关通道使用的示例，请参见第
    625 页的“shuffle 和 unpack 指令”。
- en: 11.3 Using cpuid to Differentiate Instruction Sets
  id: totrans-39
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 11.3 使用 cpuid 区分指令集
- en: Intel introduced the 8086 (and shortly thereafter, the 8088) microprocessor
    in 1978\. With almost every succeeding CPU generation, Intel added new instructions
    to the instruction set. Until this chapter, this book has used instructions that
    are generally available on all x86-64 CPUs (Intel and AMD). This chapter presents
    instructions that are available only on later-model x86-64 CPUs. To allow programmers
    to determine which CPU their applications were using so they could dynamically
    avoid using newer instructions on older processors, Intel introduced the `cpuid`
    instruction.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 英特尔在 1978 年推出了 8086 微处理器（不久之后推出了 8088）。几乎每一代 CPU，英特尔都会向指令集添加新指令。直到本章为止，本书使用的指令通常在所有
    x86-64 CPU（无论是英特尔还是 AMD）上都能使用。本章介绍了仅在后期型号的 x86-64 CPU 上可用的指令。为了允许程序员确定其应用程序正在使用的
    CPU，以便动态避免在旧处理器上使用较新的指令，英特尔引入了 `cpuid` 指令。
- en: The `cpuid` instruction expects a single parameter (called a *leaf* function)
    passed in the EAX register. It returns various pieces of information about the
    CPU in different 32-bit registers based on the value passed in EAX. An application
    can test the return information to see if certain CPU features are available.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: '`cpuid` 指令期望传递一个单一参数（称为 *leaf* 函数），该参数通过 EAX 寄存器传递。它根据 EAX 中传递的值，返回不同 32 位寄存器中的有关
    CPU 的各类信息。应用程序可以测试返回的信息，以查看是否支持某些 CPU 功能。'
- en: As Intel introduced new instructions, it changed the behavior of `cpuid` to
    reflect those changes. Specifically, Intel changed the range of values a program
    could legally pass in EAX to `cpuid`; this is known as the *highest function supported*.
    As a result, some 64-bit CPUs accept only values in the range 0h to 05h. The instructions
    this chapter discusses may require passing values in the range 0h to 07h. Therefore,
    the first thing you have to do when using `cpuid` is to verify that it accepts
    EAX = 07h as a valid parameter.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 随着英特尔引入新指令，它改变了 `cpuid` 的行为以反映这些变化。具体来说，英特尔改变了程序可以在 EAX 中传递给 `cpuid` 的合法值范围；这一点称为
    *支持的最高功能*。因此，一些 64 位的 CPU 仅接受 0h 到 05h 范围内的值。本章讨论的指令可能要求传递 0h 到 07h 范围内的值。因此，当使用
    `cpuid` 时，首先要做的事情是验证它是否接受 EAX = 07h 作为有效参数。
- en: To determine the highest function supported, you load EAX with 0 or 8000_0000h
    and execute the `cpuid` instruction (all 64-bit CPUs support these two function
    values). The return value is the maximum you can pass to `cpuid` in EAX. The Intel
    and AMD documentation (also see [https://en.wikipedia.org/wiki/CPUID](https://en.wikipedia.org/wiki/CPUID))
    will list the values `cpuid` returns for various CPUs; for the purposes of this
    chapter, we need only verify that the highest function supported is 01h (which
    is true for all 64-bit CPUs) or 07h for certain instructions.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 为了确定支持的最高功能，你需要将 EAX 加载为 0 或 8000_0000h，然后执行 `cpuid` 指令（所有 64 位 CPU 都支持这两个功能值）。返回值是你可以传递给
    `cpuid` 的最大值。Intel 和 AMD 的文档（另请参见 [https://en.wikipedia.org/wiki/CPUID](https://en.wikipedia.org/wiki/CPUID)）会列出
    `cpuid` 返回的各种 CPU 值；对于本章而言，我们只需要验证支持的最高功能是 01h（所有 64 位 CPU 都是如此）或 07h（对于某些指令）。
- en: 'In addition to providing the highest function supported, the `cpuid` instruction
    with EAX = 0h (or 8000_0002h) also returns a 12-character vendor ID in the EBX,
    ECX, and EDX registers. For x86-64 chips, this will be either of the following:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 除了提供支持的最高功能外，`cpuid` 指令（EAX = 0h 或 8000_0002h）还会返回一个 12 字符的厂商 ID，存储在 EBX、ECX
    和 EDX 寄存器中。对于 x86-64 芯片，这将是以下两种之一：
- en: GenuineIntel (EBX is 756e_6547h, EDX is 4965_6e69h, and ECX is 6c65_746eh)
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: GenuineIntel（EBX 为 756e_6547h，EDX 为 4965_6e69h，ECX 为 6c65_746eh）
- en: AuthenticAMD (EBX is 6874_7541h, EDX is 6974_6E65h, and ECX is 444D_4163h)
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: AuthenticAMD（EBX 为 6874_7541h，EDX 为 6974_6E65h，ECX 为 444D_4163h）
- en: To determine if the CPU can execute most SSE and AVX instructions, you must
    execute `cpuid` with EAX = 01h and test various bits placed in the ECX register.
    For a few of the more advanced features (advanced bit-manipulation functions and
    AVX2 instructions), you’ll need to execute `cpuid` with EAX = 07h and check the
    results in the EBX register. The `cpuid` instruction (with EAX = 1) returns an
    interesting SSE/AVX feature flag in the following bits in ECX, as shown in [Table
    11-1](#table11-1); with EAX = 07h, it returns the bit manipulation or AVX2 flag
    in EBX, as shown in [Table 11-2](#table11-2). If the bit is set, the CPU supports
    the specific instruction(s).
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 为了确定 CPU 是否可以执行大多数 SSE 和 AVX 指令，你需要执行 `cpuid`，EAX = 01h，并测试 ECX 寄存器中放置的各个位。对于一些更高级的特性（如高级位操作功能和
    AVX2 指令），你需要执行 `cpuid`，EAX = 07h，并检查 EBX 寄存器中的结果。`cpuid` 指令（EAX = 1）会在 ECX 中的以下位返回有趣的
    SSE/AVX 特性标志，如 [表 11-1](#table11-1) 所示；当 EAX = 07h 时，它会在 EBX 中返回位操作或 AVX2 标志，如
    [表 11-2](#table11-2) 所示。如果该位被设置，则说明 CPU 支持特定的指令。
- en: 'Table 11-1: Intel `cpuid` Feature Flags (EAX = 1)'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 表 11-1：Intel `cpuid` 特性标志（EAX = 1）
- en: '| **Bit** | **ECX** |'
  id: totrans-49
  prefs: []
  type: TYPE_TB
  zh: '| **位** | **ECX** |'
- en: '| --- | --- |'
  id: totrans-50
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| 0 | SSE3 support |'
  id: totrans-51
  prefs: []
  type: TYPE_TB
  zh: '| 0 | SSE3 支持 |'
- en: '| 1 | PCLMULQDQ support |'
  id: totrans-52
  prefs: []
  type: TYPE_TB
  zh: '| 1 | PCLMULQDQ 支持 |'
- en: '| 9 | SSSE3 support |'
  id: totrans-53
  prefs: []
  type: TYPE_TB
  zh: '| 9 | SSSE3 支持 |'
- en: '| 19 | CPU supports SSE4.1 instructions |'
  id: totrans-54
  prefs: []
  type: TYPE_TB
  zh: '| 19 | CPU 支持 SSE4.1 指令 |'
- en: '| 20 | CPU supports SSE4.2 instructions |'
  id: totrans-55
  prefs: []
  type: TYPE_TB
  zh: '| 20 | CPU 支持 SSE4.2 指令 |'
- en: '| 28 | Advanced Vector Extensions |'
  id: totrans-56
  prefs: []
  type: TYPE_TB
  zh: '| 28 | 高级向量扩展 |'
- en: 'Table 11-2: Intel `cpuid` Extended Feature Flags (EAX = 7, ECX = 0)'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 表 11-2：Intel `cpuid` 扩展特性标志（EAX = 7，ECX = 0）
- en: '| **Bit** | **EBX** |'
  id: totrans-58
  prefs: []
  type: TYPE_TB
  zh: '| **位** | **EBX** |'
- en: '| --- | --- |'
  id: totrans-59
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| 3 | Bit Manipulation Instruction Set 1 |'
  id: totrans-60
  prefs: []
  type: TYPE_TB
  zh: '| 3 | 位操作指令集 1 |'
- en: '| 5 | Advanced Vector Extensions 2 (AVX2) |'
  id: totrans-61
  prefs: []
  type: TYPE_TB
  zh: '| 5 | 高级向量扩展 2（AVX2） |'
- en: '| 8 | Bit Manipulation Instruction Set 2 |'
  id: totrans-62
  prefs: []
  type: TYPE_TB
  zh: '| 8 | 位操作指令集 2 |'
- en: '[Listing 11-1](#listing11-1) queries the vendor ID and basic feature flags
    on a CPU.'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 11-1](#listing11-1) 查询 CPU 上的厂商 ID 和基本特性标志。'
- en: '[PRE0]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Listing 11-1: `cpuid` demonstration program'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 11-1：`cpuid` 演示程序
- en: 'On an old MacBook Pro Retina with an Intel i7-3720QM CPU, running under Parallels,
    you get the following output:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 在一台配备 Intel i7-3720QM CPU 的旧款 MacBook Pro Retina 上，通过 Parallels 运行，输出如下：
- en: '[PRE1]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: This CPU supports SSE3 instructions (bit 0 of ECX is 1), SSE4.1 and SSE4.2 instructions
    (bits 19 and 20 of ECX are 1), and the AVX instructions (bit 28 is 1). Those,
    largely, are the instructions this chapter describes. Most modern CPUs will support
    these instructions (the i7-3720QM was released by Intel in 2012). The processor
    doesn’t support some of the more interesting extended features on the Intel instruction
    set (the extended bit-manipulation instructions and the AVX2 instruction set).
    Programs using those instructions will not execute on this (ancient) MacBook Pro.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 该 CPU 支持 SSE3 指令（ECX 的第 0 位为 1）、SSE4.1 和 SSE4.2 指令（ECX 的第 19 位和第 20 位为 1）以及
    AVX 指令（第 28 位为 1）。这些基本上是本章描述的指令。大多数现代 CPU 都会支持这些指令（Intel 于 2012 年发布的 i7-3720QM
    就支持这些指令）。该处理器不支持 Intel 指令集中的一些更有趣的扩展特性（如扩展的位操作指令集和 AVX2 指令集）。使用这些指令的程序无法在这台（古老的）MacBook
    Pro 上执行。
- en: 'Running this on a more recent CPU (an iMac Pro 10-core Intel Xeon W-2150B)
    produces the following output:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 在一台较新的 CPU（iMac Pro 10 核 Intel Xeon W-2150B）上运行此程序，产生以下输出：
- en: '[PRE2]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: As you can see, looking at the extended feature bits, the newer Xeon CPU does
    support these additional instructions. The code fragment in [Listing 11-2](#listing11-2)
    provides a quick modification to [Listing 11-1](#listing11-1) that tests for the
    availability of the BMI1 and BMI2 bit-manipulation instruction sets (insert the
    following code right before the `allDone` label in [Listing 11-1](#listing11-1)).
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，通过查看扩展特性位，较新的 Xeon CPU 确实支持这些额外的指令。列表 [11-2](#listing11-2) 中的代码片段提供了对 [列表
    11-1](#listing11-1) 的快速修改，用来测试 BMI1 和 BMI2 位操作指令集的可用性（将以下代码插入到 [列表 11-1](#listing11-1)
    中的 `allDone` 标签之前）。
- en: '[PRE3]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Listing 11-2: Test for BMI1 and BMI2 instruction sets'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 11-2：测试 BMI1 和 BMI2 指令集
- en: 'Here’s the build command and program output on the Intel i7-3720QM CPU:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 这是在 Intel i7-3720QM CPU 上的构建命令和程序输出：
- en: '[PRE4]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Here’s the same program running on the iMac Pro (Intel Xeon W-2150B):'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 这是相同的程序在 iMac Pro（Intel Xeon W-2150B）上运行的情况：
- en: '[PRE5]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 11.4 Full-Segment Syntax and Segment Alignment
  id: totrans-78
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 11.4 完整段语法与段对齐
- en: As you will soon see, SSE and AVX memory data require alignment on 16-, 32-,
    and even 64-byte boundaries. Although you can use the `align` directive to align
    data (see “MASM Support for Data Alignment” in Chapter 3), it doesn’t work beyond
    16-byte alignment when using the simplified segment directives presented thus
    far in this book. If you need alignment beyond 16 bytes, you have to use MASM
    full-segment declarations.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，SSE 和 AVX 内存数据需要在 16 字节、32 字节甚至 64 字节的边界上进行对齐。虽然你可以使用 `align` 指令来对齐数据（详见第
    3 章中的“MASM 对数据对齐的支持”），但在使用本书中介绍的简化段指令时，16 字节对齐以外的对齐将不起作用。如果需要超过 16 字节的对齐，则必须使用
    MASM 完整段声明。
- en: 'If you want to create a segment with complete control over segment attributes,
    you need to use the `segment` and `ends` directives.^([1](#c11-footnote-1)) The
    generic syntax for a segment declaration is as follows:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想创建一个可以完全控制段属性的段，则需要使用 `segment` 和 `ends` 指令。^([1](#c11-footnote-1)) 段声明的通用语法如下：
- en: '[PRE6]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '`segname` is an identifier. This is the name of the segment (which must also
    appear before the closing `ends` directive). It need not be unique; you can have
    several segment declarations that share the same name. MASM will combine segments
    with the same name when emitting code to the object file. Avoid the segment names
    `_TEXT`, `_DATA`, `_BSS`, and `_CONST`, as MASM uses these names for the `.code`,
    `.data`, `.data?`, and `.const` directives, respectively.'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: '`segname` 是一个标识符。它是段的名称（也必须出现在 `ends` 指令之前）。它不需要是唯一的；你可以有多个段声明使用相同的名称。当 MASM
    输出代码到目标文件时，它会将具有相同名称的段合并。避免使用 `_TEXT`、`_DATA`、`_BSS` 和 `_CONST` 作为段名称，因为 MASM
    分别将这些名称用于 `.code`、`.data`、`.data?` 和 `.const` 指令。'
- en: The `readonly` option is either blank or the MASM-reserved word `readonly`.
    This is a hint to MASM that the segment will contain read-only (constant) data.
    If you attempt to (directly) store a value into a variable that you declare in
    a read-only segment, MASM will complain that you cannot modify a read-only segment.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: '`readonly` 选项可以为空或是 MASM 保留字 `readonly`。这提示 MASM 该段将包含只读（常量）数据。如果你试图（直接）将值存储到在只读段中声明的变量，MASM
    将会报错，指出不能修改只读段。'
- en: 'The `alignment` option is also optional and allows you to specify one of the
    following options:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: '`alignment` 选项是可选的，它允许你指定以下选项之一：'
- en: '`byte`'
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`byte`'
- en: '`word`'
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`word`'
- en: '`dword`'
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`dword`'
- en: '`para`'
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`para`'
- en: '`page`'
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`page`'
- en: '`align(``n``)` (`n` is a constant that must be a power of 2)'
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`align(``n``)` （`n` 是一个常量，必须是 2 的幂）'
- en: The alignment options tell MASM that the first byte emitted for this particular
    segment must appear at an address that is a multiple of the alignment option.
    The `byte`, `word`, and `dword` reserved words specify 1-, 2-, or 4-byte alignments.
    The `para` alignment option specifies paragraph alignment (16 bytes). The `page`
    alignment option specifies an address alignment of 256 bytes. Finally, the `align(``n``)`
    alignment option lets you specify any address alignment that is a power of 2 (1,
    2, 4, 8, 16, 32, and so on).
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 对齐选项告诉 MASM，此特定段的第一个字节必须出现在对齐选项的倍数地址上。`byte`、`word` 和 `dword` 保留字指定 1 字节、2 字节或
    4 字节的对齐。`para` 对齐选项指定段落对齐（16 字节）。`page` 对齐选项指定 256 字节的地址对齐。最后，`align(``n``)` 对齐选项允许你指定任何
    2 的幂次方地址对齐（1、2、4、8、16、32 等等）。
- en: The default segment alignment, if you don’t explicitly specify one, is paragraph
    alignment (16 bytes). This is also the default alignment for the simplified segment
    directives (`.code`, `.data`, `.data?`, and `.const`).
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 默认的段对齐，如果你没有明确指定，是段落对齐（16字节）。这也是简化段指令（`.code`、`.data`、`.data?`和`.const`）的默认对齐方式。
- en: 'If you have some (SSE/AVX) data objects that must start at an address that
    is a multiple of 32 or 64 bytes, then creating a new data segment with 64-byte
    alignment is what you want. Here’s an example of such a segment:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你有一些（SSE/AVX）数据对象，必须从一个是32字节或64字节倍数的地址开始，那么创建一个64字节对齐的新数据段就是你需要的。以下是一个这样的段示例：
- en: '[PRE7]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'The optional `class` field is a string (delimited by apostrophes and single
    quotes) that is typically one of the following names: `CODE`, `DATA`, or `CONST`.
    Note that MASM and the Microsoft linker will combine segments that have the same
    class name even if their segment names are different.'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 可选的`class`字段是一个字符串（由撇号和单引号分隔），通常是以下名称之一：`CODE`、`DATA`或`CONST`。请注意，MASM和微软链接器会将具有相同类名的段合并，即使它们的段名不同。
- en: This chapter presents examples of these segment declarations as they are needed.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 本章展示了这些段声明的示例，它们在需要时使用。
- en: 11.5 SSE, AVX, and AVX2 Memory Operand Alignment
  id: totrans-97
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 11.5 SSE、AVX和AVX2内存操作数对齐
- en: SSE and AVX instructions typically allow access to a variety of memory operand
    sizes. The so-called scalar instructions, which operate on single data elements,
    can access byte-, word-, dword-, and qword-sized memory operands. In many respects,
    these types of memory accesses are similar to memory accesses by the non-SIMD
    instructions. The SSE, AVX, and AVX2 instruction set extensions also access *packed*
    or *vector* operands in memory. Unlike with the scalar memory operands, stringent
    rules limit the access of packed memory operands. This section discusses those
    rules.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: SSE和AVX指令通常允许访问各种内存操作数大小。所谓的标量指令，操作单个数据元素，可以访问字节、字、双字和四字操作数。在许多方面，这些类型的内存访问类似于非SIMD指令的内存访问。SSE、AVX和AVX2指令集扩展还可以访问内存中的*打包*或*向量*操作数。与标量内存操作数不同，严格的规则限制了对打包内存操作数的访问。本节讨论这些规则。
- en: The SSE instructions can access up to 128 bits of memory (16 bytes) with a single
    instruction. Most multi-operand SSE instructions can specify an XMM register or
    a 128-bit memory operand as their source (second) operand. As a general rule,
    these memory operands must appear on a 16-byte-aligned address in memory (that
    is, the LO 4 bits of the memory address must contain 0s).
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: SSE指令可以用单条指令访问最多128位的内存（16字节）。大多数多操作数SSE指令可以将XMM寄存器或128位内存操作数指定为它们的源（第二）操作数。通常情况下，这些内存操作数必须出现在16字节对齐的内存地址上（也就是说，内存地址的低4位必须包含0）。
- en: 'Because segments have a default alignment of `para` (16 bytes), you can easily
    ensure that any 16-byte packed data objects are 16-byte-aligned by using the `align`
    directive:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 因为段的默认对齐是`para`（16字节），你可以通过使用`align`指令轻松确保任何16字节打包的数据对象是16字节对齐的：
- en: '[PRE8]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: MASM will report an error if you attempt to use `align 16` in a segment you’ve
    defined with the `byte`, `word`, or `dword` alignment type. It will work properly
    with `para`, `page`, or any `align(``n``)` option where `n` is greater than or
    equal to 16.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你尝试在使用`byte`、`word`或`dword`对齐类型定义的段中使用`align 16`，MASM会报告错误。在使用`para`、`page`或任何`align(``n``)`选项时，其中`n`大于或等于16时，它将正常工作。
- en: 'If you are using AVX instructions to access 256-bit (32-byte) memory operands,
    you must ensure that those memory operands begin on a 32-byte address boundary.
    Unfortunately, `align 32` won’t work, because the default segment alignment is
    `para` (16-byte) alignment, and the segment’s alignment must be greater than or
    equal to the operand field of any `align` directives appearing within that segment.
    Therefore, to be able to define 256-bit variables usable by AVX instructions,
    you must explicitly define a (data) segment that is aligned on a (minimum) 32-byte
    boundary, such as the following:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你使用AVX指令访问256位（32字节）内存操作数，你必须确保这些内存操作数从32字节的地址边界开始。不幸的是，`align 32`不起作用，因为默认的段对齐是`para`（16字节）对齐，而段的对齐必须大于或等于该段内出现的任何`align`指令的操作数字段。因此，为了能够定义AVX指令可用的256位变量，你必须显式地定义一个在（最小）32字节边界上对齐的（数据）段，例如以下内容：
- en: '[PRE9]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Though it’s somewhat redundant to say this, it’s so important it’s worth repeating:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然说这有些多余，但它非常重要，值得一再强调：
- en: Almost all AVX/AVX2 instructions will generate an alignment fault if you attempt
    to access a 256-bit object at an address that is not 32-byte-aligned. Always ensure
    that your AVX packed operands are properly aligned.
  id: totrans-106
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 几乎所有 AVX/AVX2 指令，如果你尝试在一个不是 32 字节对齐的地址访问一个 256 位对象，都会引发对齐错误。始终确保你的 AVX 打包操作数正确对齐。
- en: 'If you are using the AVX2 extended instructions with 512-bit memory operands,
    you must ensure that those operands appear on an address in memory that is a multiple
    of 64 bytes. As for AVX instructions, you will have to define a segment that has
    an alignment greater than or equal to 64 bytes, such as this:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你使用 AVX2 扩展指令与 512 位内存操作数，你必须确保这些操作数出现在内存中一个是 64 字节的倍数的地址上。至于 AVX 指令，你必须定义一个具有大于或等于
    64 字节对齐的段，例如这样：
- en: '[PRE10]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Forgive the redundancy, but it’s important to remember:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 请原谅重复，但重要的是要记住：
- en: Almost all AVX-512 instructions will generate an alignment fault if you attempt
    to access a 512-bit object at an address that is not 64-byte-aligned. Always ensure
    that your AVX-512 packed operands are properly aligned.
  id: totrans-110
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 几乎所有 AVX-512 指令，如果你尝试在一个不是 64 字节对齐的地址访问一个 512 位对象，都会引发对齐错误。始终确保你的 AVX-512 打包操作数正确对齐。
- en: 'If you’re using SSE, AVX, and AVX2 data types in the same application, you
    can create a single data segment to hold all these data values by using a 64-byte
    alignment option for the single section, instead of a segment for each data type
    size. Remember, the segment’s alignment has to be *greater than* or equal to the
    alignment required by the specific data type. Therefore, a 64-byte alignment will
    work fine for SSE and AVX/AVX2 variables, as well as AVX-512 variables:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在同一个应用程序中使用 SSE、AVX 和 AVX2 数据类型，你可以通过为单个段使用 64 字节对齐选项来创建一个单一的数据段来保存所有这些数据值，而不是为每种数据类型的大小创建单独的段。记住，段的对齐必须*大于或等于*特定数据类型所要求的对齐方式。因此，64
    字节对齐对于 SSE 和 AVX/AVX2 变量以及 AVX-512 变量都能很好地工作：
- en: '[PRE11]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: If you specify an alignment option that is much larger than you need (such as
    256-byte `page` alignment), you might unnecessarily waste memory.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你指定的对齐选项远大于你需要的（例如 256 字节的 `page` 对齐），你可能会不必要地浪费内存。
- en: The `align` directive works well when your SSE, AVX, and AVX2 data values are
    static or global variables. What happens when you want to create local variables
    on the stack or dynamic variables on the heap? Even if your program adheres to
    the Microsoft ABI, you’re guaranteed only 16-byte alignment on the stack upon
    entry to your program (or to a procedure). Similarly, depending on your heap management
    functions, there is no guarantee that a `malloc` (or similar) function returns
    an address that is properly aligned for SSE, AVX, or AVX2 data objects.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 当你的 SSE、AVX 和 AVX2 数据值是静态或全局变量时，`align` 指令表现良好。那么当你想要在栈上创建局部变量或在堆上创建动态变量时会发生什么呢？即使你的程序遵循微软的
    ABI，你在进入程序（或进入一个过程）时，栈上的对齐保证只有 16 字节对齐。同样，根据你的堆管理函数，`malloc`（或类似函数）返回的地址也无法保证适合
    SSE、AVX 或 AVX2 数据对象的对齐方式。
- en: 'Inside a procedure, you can allocate storage for a 16-, 32-, or 64-byte-aligned
    variable by over-allocating the storage, adding the size minus 1 of the object
    to the allocated address, and then using the `and` instruction to zero out LO
    bits of the address (4 bits for 16-byte-aligned objects, 5 bits for 32-byte-aligned
    objects, and 6 bits for 64-byte-aligned objects). Then you reference the object
    by using this pointer. The following sample code demonstrates how to do this:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 在一个过程内部，你可以通过过度分配存储、将对象的大小减去 1 添加到分配的地址，然后使用 `and` 指令将地址的低位清零（16 字节对齐对象清除 4
    位，32 字节对齐对象清除 5 位，64 字节对齐对象清除 6 位）来为 16 字节、32 字节或 64 字节对齐的变量分配存储空间。然后你可以通过使用这个指针来引用该对象。下面的示例代码演示了如何做到这一点：
- en: '[PRE12]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'For data you allocate on the heap, you do the same thing: allocate extra storage
    (up to twice as many bytes minus 1), add the size of the object minus 1 (15, 31,
    or 63) to the address, and then mask the newly formed address with –64, –32, or
    –16 to produce a 64-, 32-, or 16-byte-aligned object, respectively.'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 对于在堆上分配的数据，你可以做同样的事情：分配额外的存储（最多分配大小的两倍减去 1），将对象的大小减去 1（15、31 或 63）加到地址中，然后使用
    -64、-32 或 -16 来屏蔽新形成的地址，以分别产生 64 字节、32 字节或 16 字节对齐的对象。
- en: 11.6 SIMD Data Movement Instructions
  id: totrans-118
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 11.6 SIMD 数据移动指令
- en: The x86-64 CPUs provide a variety of data move instructions that copy data between
    (SSE/AVX) registers, load registers from memory, and store register values to
    memory. The following subsections describe each of these instructions.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: x86-64 CPU提供了多种数据移动指令，用于在（SSE/AVX）寄存器之间复制数据、从内存加载寄存器以及将寄存器值存储到内存。以下小节描述了每条指令。
- en: 11.6.1 The (v)movd and (v)movq Instructions
  id: totrans-120
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 11.6.1 (v)movd 和 (v)movq 指令
- en: For the SSE instruction set, the `movd` (*move dword*) and `movq` (*move qword*)
    instructions copy the value from a 32- or 64-bit general-purpose register or memory
    location into the LO dword or qword of an XMM register:^([2](#c11-footnote-2))
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 对于SSE指令集，`movd`（*移动dword*）和`movq`（*移动qword*）指令将来自32位或64位通用寄存器或内存位置的值复制到XMM寄存器的低dword或qword中：^([2](#c11-footnote-2))
- en: '[PRE13]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: These instructions zero-extend the value to remaining HO bits in the XMM register,
    as shown in Figures 11-7 and 11-8.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 如图11-7和11-8所示，这些指令将值零扩展到XMM寄存器中的剩余高位（HO位）。
- en: '![f11007](image_fi/501089c11/f11007.png)'
  id: totrans-124
  prefs: []
  type: TYPE_IMG
  zh: '![f11007](image_fi/501089c11/f11007.png)'
- en: 'Figure 11-7: Moving a 32-bit value from memory to an XMM register (with zero
    extension)'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 图11-7：将32位值从内存移动到XMM寄存器（带零扩展）
- en: '![f11008](image_fi/501089c11/f11008.png)'
  id: totrans-126
  prefs: []
  type: TYPE_IMG
  zh: '![f11008](image_fi/501089c11/f11008.png)'
- en: 'Figure 11-8: Moving a 64-bit value from memory to an XMM register (with zero
    extension)'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 图11-8：将64位值从内存移动到XMM寄存器（带零扩展）
- en: 'The following instructions store the LO 32 or 64 bits of an XMM register into
    a dword or qword memory location or general-purpose register:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 以下指令将XMM寄存器的低32位或64位存储到dword或qword内存位置或通用寄存器：
- en: '[PRE14]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'The `movq` instruction also allows you to copy data from the LO qword of one
    XMM register to another, but for whatever reason, the `movd` instruction does
    not allow two XMM register operands:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: '`movq`指令还允许你将一个XMM寄存器的低32位（LO qword）数据复制到另一个XMM寄存器，但由于某些原因，`movd`指令不允许两个XMM寄存器操作数：'
- en: '[PRE15]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: For the AVX instructions, you use the following instructions:^([3](#c11-footnote-3))
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 对于AVX指令，你可以使用以下指令：^([3](#c11-footnote-3))
- en: '[PRE16]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The instructions with the XMM destination operands also zero-extend their values
    into the HO bits (up to bit 255, unlike the standard SSE instructions that do
    not modify the upper bits of the YMM registers).
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 具有XMM目标操作数的指令还会将它们的值零扩展到高位（最多扩展到位255，不像标准SSE指令不会修改YMM寄存器的上位）。
- en: Because the `movd` and `movq` instructions access 32- and 64-bit values in memory
    (rather than 128-, 256-, or 512-bit values), these instructions do not require
    their memory operands to be 16-, 32-, or 64-byte-aligned. Of course, the instructions
    may execute faster if their operands are dword (`movd`) or qword (`movq`) aligned
    in memory.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 因为`movd`和`movq`指令访问的是32位和64位内存值（而不是128位、256位或512位值），所以这些指令不要求它们的内存操作数按16字节、32字节或64字节对齐。当然，如果它们的操作数在内存中按dword（`movd`）或qword（`movq`）对齐，指令执行可能会更快。
- en: 11.6.2 The (v)movaps, (v)movapd, and (v)movdqa Instructions
  id: totrans-136
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 11.6.2 (v)movaps、(v)movapd 和 (v)movdqa 指令
- en: The `movaps` (*move aligned, packed single*), `movapd` (*move aligned, packed
    double*), and `movdqa` (*move double quad-word aligned*) instructions move 16
    bytes of data between memory and an XMM register or between two XMM registers.
    The AVX versions (with the `v` prefix) move 16 or 32 bytes between memory and
    an XMM or a YMM register or between two XMM or YMM registers (moves involving
    XMM registers zero out the HO bits of the corresponding YMM register). The memory
    locations must be aligned on a 16-byte or 32-byte boundary (respectively), or
    the CPU will generate an unaligned access fault.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: '`movaps`（*移动对齐的打包单精度*）、`movapd`（*移动对齐的打包双精度*）和`movdqa`（*移动双四字对齐*）指令在内存与XMM寄存器之间或两个XMM寄存器之间移动16字节的数据。AVX版本（带有`v`前缀）在内存与XMM或YMM寄存器之间，或两个XMM或YMM寄存器之间移动16字节或32字节的数据（涉及XMM寄存器的移动会将相应YMM寄存器的高位清零）。内存位置必须按16字节或32字节边界对齐（分别），否则CPU将生成未对齐访问错误。'
- en: All three `mov*` instructions load 16 bytes into an XMM register and are, in
    theory, interchangeable. In practice, Intel may optimize the operations for the
    type of data they move (single-precision floating-point values, double-precision
    floating-point values, or integer values), so it’s always a good idea to choose
    the appropriate instruction for the data type you are using (see “Performance
    Issues and the SIMD Move Instructions” on page 622 for an explanation). Likewise,
    all three `vmov*` instructions load 16 or 32 bytes into an XMM or a YMM register
    and are interchangeable.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 这三条 `mov*` 指令将 16 字节数据加载到 XMM 寄存器中，理论上可以互换使用。实际上，Intel 可能会针对它们所移动的数据类型（单精度浮点值、双精度浮点值或整数值）对操作进行优化，因此最好根据所使用的数据类型选择适当的指令（有关说明，请参见第
    622 页的“性能问题与 SIMD 移动指令”）。同样，所有三条 `vmov*` 指令将 16 或 32 字节的数据加载到 XMM 或 YMM 寄存器中，也可以互换使用。
- en: 'These instructions take the following forms:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 这些指令具有以下形式：
- en: '[PRE17]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: The `mem`128 operand should be a vector (array) of four single-precision floating-point
    values for the `(v)movaps` instruction; it should be a vector of two double-precision
    floating-point values for the `(v)movapd` instruction; it should be a 16-byte
    value (16 bytes, 8 words, 4 dwords, or 2 qwords) when using the `(v)movdqa` instruction.
    If you cannot guarantee that the operands are aligned on a 16-byte boundary, use
    the `movups`, `movupd`, or `movdqu` instructions, instead (see the next section).
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: '`mem`128 操作数应为一个包含四个单精度浮点值的向量（数组），用于 `(v)movaps` 指令；应为一个包含两个双精度浮点值的向量，用于 `(v)movapd`
    指令；当使用 `(v)movdqa` 指令时，应为一个 16 字节的值（16 字节，8 个字，4 个双字或 2 个四字）。如果无法保证操作数在 16 字节边界上对齐，请改用
    `movups`、`movupd` 或 `movdqu` 指令（请参见下一节）。'
- en: The `mem`256 operand should be a vector (array) of eight single-precision floating-point
    values for the `vmovaps` instruction; it should be a vector of four double-precision
    floating-point values for the `vmovapd` instruction; it should be a 32-byte value
    (32 bytes, 16 words, 8 dwords, or 4 qwords) when using the `vmovdqa` instruction.
    If you cannot guarantee that the operands are 32-byte-aligned, use the `vmovups`,
    `vmovupd`, or `vmovdqu` instructions instead.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: '`mem`256 操作数应为一个包含八个单精度浮点值的向量（数组），用于 `vmovaps` 指令；应为一个包含四个双精度浮点值的向量，用于 `vmovapd`
    指令；当使用 `vmovdqa` 指令时，应为一个 32 字节的值（32 字节，16 个字，8 个双字或 4 个四字）。如果无法保证操作数是 32 字节对齐的，请改用
    `vmovups`、`vmovupd` 或 `vmovdqu` 指令。'
- en: 'Although the physical machine instructions themselves don’t particularly care
    about the data type of the memory operands, MASM’s assembly syntax certainly does
    care. You will need to use operand type coercion if the instruction doesn’t match
    one of the following types:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管物理机器指令本身对内存操作数的数据类型并不特别关心，但 MASM 的汇编语法显然是关心的。如果指令与以下任一类型不匹配，则需要使用操作数类型强制转换。
- en: The `movaps` instruction allows `real4`, `dword`, and `oword` operands.
  id: totrans-144
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`movaps` 指令允许 `real4`、`dword` 和 `oword` 操作数。'
- en: The `movapd` instruction allows `real8`, `qword`, and `oword` operands.
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`movapd` 指令允许 `real8`、`qword` 和 `oword` 操作数。'
- en: The `movdqa` instruction allows only `oword` operands.
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`movdqa` 指令仅允许 `oword` 操作数。'
- en: The `vmovaps` instruction allows `real4`, `dword`, and `ymmword ptr` operands
    (when using a YMM register).
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`vmovaps` 指令允许 `real4`、`dword` 和 `ymmword ptr` 操作数（当使用 YMM 寄存器时）。'
- en: The `vmovapd` instruction allows `real8`, `qword`, and `ymmword ptr` operands
    (when using a YMM register).
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`vmovapd` 指令允许 `real8`、`qword` 和 `ymmword ptr` 操作数（当使用 YMM 寄存器时）。'
- en: The `vmovdqa` instruction allows only `ymmword ptr` operands (when using a YMM
    register).
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`vmovdqa` 指令仅允许 `ymmword ptr` 操作数（当使用 YMM 寄存器时）。'
- en: Often you will see `memcpy` (*memory copy*) functions use the `(v)movapd` instructions
    for very high-performance operations. See Agner Fog’s website at [https://www.agner.org/optimize/](https://www.agner.org/optimize/)
    for more details.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 通常你会看到 `memcpy`（*内存复制*）函数使用 `(v)movapd` 指令进行高性能操作。更多详情请访问 Agner Fog 的网站 [https://www.agner.org/optimize/](https://www.agner.org/optimize/)。
- en: 11.6.3 The (v)movups, (v)movupd, and (v)movdqu Instructions
  id: totrans-151
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 11.6.3 （v）movups、（v）movupd 和（v）movdqu 指令
- en: When you cannot guarantee that packed data memory operands lie on a 16- or 32-byte
    address boundary, you can use the `(v)movups` (*move unaligned packed single-precision*),
    `(v)movupd` (*move unaligned packed* *double-precision*), and `(v)movdqu` (*move
    double quad-word* *unaligned*) instructions to move data between XMM or YMM registers
    and memory.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 当你无法保证打包数据的内存操作数位于 16 字节或 32 字节对齐的地址边界时，可以使用 `(v)movups`（*无对齐的打包单精度*）、`(v)movupd`（*无对齐的打包双精度*）和
    `(v)movdqu`（*无对齐的双四字*）指令，在 XMM 或 YMM 寄存器与内存之间移动数据。
- en: 'As for the aligned moves, all the unaligned moves do the same thing: copying
    16 (32) bytes of data to and from memory. The convention for the various data
    types is the same as it is for the aligned data movement instructions.'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 至于对齐的移动指令，所有不对齐的移动指令都做相同的事情：将 16（32）字节的数据从内存中复制到内存中，或者反之。不同数据类型的约定与对齐数据移动指令的约定相同。
- en: 11.6.4 Performance of Aligned and Unaligned Moves
  id: totrans-154
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 11.6.4 对齐与不对齐移动的性能
- en: Listings [11-3](#listing11-3) and [11-4](#listing11-4) provide sample programs
    that demonstrate the performance of the `mova*` and `movu*` instructions using
    aligned and unaligned memory accesses.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: '[列表 11-3](#listing11-3) 和 [列表 11-4](#listing11-4) 提供了示范程序，展示了使用对齐和不对齐内存访问的
    `mova*` 和 `movu*` 指令的性能。'
- en: '[PRE18]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Listing 11-3: Aligned memory-access timing code'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 11-3：对齐内存访问时序代码
- en: '[PRE19]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Listing 11-4: Unaligned memory-access timing code'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 11-4：不对齐内存访问时序代码
- en: The code in [Listing 11-3](#listing11-3) took about 1 minute and 7 seconds to
    execute on a 3GHz Xeon W CPU. The code in [Listing 11-4](#listing11-4) took 1
    minute and 55 seconds to execute on the same processor. As you can see, there
    is sometimes an advantage to accessing SIMD data on an aligned address boundary.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: '[列表 11-3](#listing11-3) 中的代码在 3GHz Xeon W CPU 上执行大约需要 1 分 7 秒。在相同的处理器上，[列表
    11-4](#listing11-4) 中的代码执行需要 1 分 55 秒。如你所见，某些情况下，在对齐的地址边界上访问 SIMD 数据是有优势的。'
- en: 11.6.5 The (v)movlps and (v)movlpd Instructions
  id: totrans-161
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 11.6.5 `(v)movlps` 和 `(v)movlpd` 指令
- en: The `(v)movl*` instructions and `(v)movh*` instructions (from the next section)
    might look like normal move instructions. Their behavior is similar to many other
    SSE/AVX move instructions. However, they were designed to support packing and
    unpacking floating-point vectors. Specifically, these instructions allow you to
    merge two pairs of single-precision or a pair of double-precision floating-point
    operands from two different sources into a single XMM register.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: '`(v)movl*` 指令和 `(v)movh*` 指令（见下节）可能看起来像是普通的移动指令。它们的行为与许多其他 SSE/AVX 移动指令相似。然而，这些指令的设计目的是支持浮点向量的打包和解包。具体而言，这些指令允许你将来自两个不同源的两对单精度浮点数或一对双精度浮点操作数合并到一个单一的
    XMM 寄存器中。'
- en: 'The `(v)movlps` instructions use the following syntax:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: '`(v)movlps` 指令使用以下语法：'
- en: '[PRE20]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: The `movlps` `xmm`dest`,` `mem`64 form copies a pair of single-precision floating-point
    values into the two LO 32-bit lanes of a destination XMM register, as shown in
    [Figure 11-9](#figure11-9). This instruction leaves the HO 64 bits unchanged.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: '`movlps` `xmm`dest`,` `mem`64 形式将一对单精度浮点值复制到目标 XMM 寄存器的两个低 32 位通道，如 [图 11-9](#figure11-9)
    所示。此指令不改变高 64 位。'
- en: '![f11009](image_fi/501089c11/f11009.png)'
  id: totrans-166
  prefs: []
  type: TYPE_IMG
  zh: '![f11009](image_fi/501089c11/f11009.png)'
- en: 'Figure 11-9: `movlps` instruction'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11-9：`movlps` 指令
- en: The `movlps` `mem`64`,` `xmm`src form copies the LO 64 bits (the two LO single-precision
    lanes) from the XMM source register to the specified memory location. Functionally,
    this is equivalent to the `movq` or `movsd` instructions (as it copies 64 bits
    to memory), though this instruction might be slightly faster if the LO 64 bits
    of the XMM register actually contain two single-precision values (see “Performance
    Issues and the SIMD Move Instructions” on page 622 for an explanation).
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: '`movlps` `mem`64`,` `xmm`src 形式将 XMM 源寄存器中的低 64 位（两个低单精度通道）复制到指定的内存位置。从功能上讲，这与
    `movq` 或 `movsd` 指令等价（因为它将 64 位数据复制到内存），尽管如果 XMM 寄存器的低 64 位实际包含两个单精度值，则此指令可能会稍微更快一些（有关详细解释，请参见《性能问题与
    SIMD 移动指令》一节，第 622 页）。'
- en: 'The `vmovlps` instruction has three operands: a destination XMM register, a
    source XMM register, and a source (64-bit) memory location. This instruction copies
    the two single-precision values from the memory location into the LO 64 bits of
    the destination XMM register. It copies the HO 64 bits of the source register
    (which also hold two single-precision values) into the HO 64 bits of the destination
    register. [Figure 11-10](#figure11-10) shows the operation. Note that this instruction
    merges the pair of operands with a single instruction.'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: '`vmovlps` 指令有三个操作数：一个目标 XMM 寄存器，一个源 XMM 寄存器和一个源（64 位）内存位置。该指令将内存位置中的两个单精度值复制到目标
    XMM 寄存器的低 64 位。它还将源寄存器的高 64 位（也包含两个单精度值）复制到目标寄存器的高 64 位。[图 11-10](#figure11-10)
    显示了该操作。请注意，该指令通过一条指令合并了一对操作数。'
- en: '![f11010](image_fi/501089c11/f11010.png)'
  id: totrans-170
  prefs: []
  type: TYPE_IMG
  zh: '![f11010](image_fi/501089c11/f11010.png)'
- en: 'Figure 11-10: `vmovlps` instruction'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: '图 11-10: `vmovlps` 指令'
- en: Like `movsd`, the `movlpd` (*move low packed double*) instruction copies the
    LO 64 bits (a double-precision floating-point value) of the source operand to
    the LO 64 bits of the destination operand. The difference is that the `movlpd`
    instruction doesn’t zero-extend the value when moving data from memory into an
    XMM register, whereas the `movsd` instruction will zero-extend the value into
    the upper 64 bits of the destination XMM register. (Neither the `movsd` nor `movlpd`
    will zero-extend when copying data between XMM registers; of course, zero extension
    doesn’t apply when storing data to memory.)^([4](#c11-footnote-4))
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 类似于 `movsd`，`movlpd`（*移动低字打包双精度*）指令将源操作数的低 64 位（一个双精度浮点值）复制到目标操作数的低 64 位。不同之处在于，`movlpd`
    指令在从内存移动数据到 XMM 寄存器时不会进行零扩展，而 `movsd` 指令则会将值零扩展到目标 XMM 寄存器的上 64 位。（无论是 `movsd`
    还是 `movlpd`，在 XMM 寄存器之间复制数据时都不会进行零扩展；当然，当将数据存储到内存时，零扩展也不适用。）^([4](#c11-footnote-4))
- en: 11.6.6 The movhps and movhpd Instructions
  id: totrans-173
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 11.6.6 `movhps` 和 `movhpd` 指令
- en: The `movhps` and `movhpd` instructions move a 64-bit value (either two single-precision
    floats in the case of `movhps`, or a single double-precision value in the case
    of `movhpd`) into the HO quad word of a destination XMM register. [Figure 11-11](#figure11-11)
    shows the operation of the `movhps` instruction; [Figure 11-12](#figure11-12)
    shows the `movhpd` instruction.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: '`movhps` 和 `movhpd` 指令将一个 64 位的值（`movhps` 为两个单精度浮点数，`movhpd` 为一个双精度浮点数）移动到目标
    XMM 寄存器的高字部分。[图 11-11](#figure11-11) 显示了 `movhps` 指令的操作；[图 11-12](#figure11-12)
    显示了 `movhpd` 指令。'
- en: '![f11011](image_fi/501089c11/f11011.png)'
  id: totrans-175
  prefs: []
  type: TYPE_IMG
  zh: '![f11011](image_fi/501089c11/f11011.png)'
- en: 'Figure 11-11: `movhps` instruction'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: '图 11-11: `movhps` 指令'
- en: '![f11012](image_fi/501089c11/f11012.png)'
  id: totrans-177
  prefs: []
  type: TYPE_IMG
  zh: '![f11012](image_fi/501089c11/f11012.png)'
- en: 'Figure 11-12: `movhpd` instruction'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: '图 11-12: `movhpd` 指令'
- en: 'The `movhps` and `movhpd` instructions can also store the HO quad word of an
    XMM register into memory. The allowable syntax is shown here:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: '`movhps` 和 `movhpd` 指令也可以将 XMM 寄存器的高字（HO quad word）存储到内存中。允许的语法如下所示：'
- en: '[PRE21]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: These instructions do not affect bits 128 to 255 of the YMM registers (if present
    on the CPU).
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 这些指令不会影响 YMM 寄存器的 128 到 255 位（如果 CPU 上存在 YMM 寄存器）。
- en: You would normally use a `movlps` instruction followed by a `movhps` instruction
    to load four single-precision floating-point values into an XMM register, taking
    the floating-point values from two different data sources (similarly, you could
    use the `movlpd` and `movhpd` instructions to load a pair of double-precision
    values into a single XMM register from different sources). Conversely, you could
    also use this instruction to split a vector result in half and store the two halves
    in different data streams. This is probably the intended purpose of this instruction.
    Of course, if you can use it for other purposes, have at it.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 通常你会使用 `movlps` 指令，然后再使用 `movhps` 指令将四个单精度浮点数加载到 XMM 寄存器中，浮点数来自两个不同的数据源（类似地，你可以使用
    `movlpd` 和 `movhpd` 指令从不同源加载一对双精度值到一个 XMM 寄存器）。相反，你也可以使用该指令将一个向量结果拆分成两部分，并将这两部分存储到不同的数据流中。这可能就是该指令的预期用途。当然，如果你能将其用于其他目的，也可以尝试。
- en: 'MASM (version 14.15.26730.0, at least) seems to require `movhps` operands to
    be a 64-bit data type and does not allow `real4` operands.^([5](#c11-footnote-5))
    Therefore, you may have to explicitly coerce an array of two `real4` values with
    `qword ptr` when using this instruction:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: MASM（版本 14.15.26730.0，至少）似乎要求 `movhps` 操作数为 64 位数据类型，并不允许使用 `real4` 操作数。^([5](#c11-footnote-5))
    因此，在使用此指令时，你可能需要显式地将一对 `real4` 值转换为 `qword ptr`：
- en: '[PRE22]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 11.6.7 The vmovhps and vmovhpd Instructions
  id: totrans-185
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 11.6.7 `vmovhps` 和 `vmovhpd` 指令
- en: 'Although the AVX instruction extensions provide `vmovhps` and `vmovhpd` instructions,
    they are not a simple extension of the SSE `movhps` and `movhpd` instructions.
    The syntax for these instructions is as follows:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管 AVX 指令扩展提供了 `vmovhps` 和 `vmovhpd` 指令，但它们并非 SSE `movhps` 和 `movhpd` 指令的简单扩展。这些指令的语法如下：
- en: '[PRE23]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: The instructions that store data into a 64-bit memory location behave similarly
    to the `movhps` and `movhpd` instructions. The instructions that load data into
    an XMM register have two source operands. They load a full 128 bits (four single-precision
    values or two double-precision values) into the destination XMM register. The
    HO 64 bits come from the memory operand; the LO 64 bits come from the LO quad
    word of the source XMM register, as [Figure 11-13](#figure11-13) shows. These
    instructions also zero-extend the value into the upper 128 bits of the (overlaid)
    YMM register.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 将数据存储到 64 位内存位置的指令行为类似于 `movhps` 和 `movhpd` 指令。将数据加载到 XMM 寄存器的指令有两个源操作数。它们将完整的
    128 位（四个单精度值或两个双精度值）加载到目标 XMM 寄存器中。高 64 位来自内存操作数；低 64 位来自源 XMM 寄存器的低 64 位，如[图
    11-13](#figure11-13)所示。这些指令还将值零扩展到（重叠的）YMM 寄存器的上 128 位。
- en: '![f11013](image_fi/501089c11/f11013.png)'
  id: totrans-189
  prefs: []
  type: TYPE_IMG
  zh: '![f11013](image_fi/501089c11/f11013.png)'
- en: 'Figure 11-13: `vmovhpd` and `vmovhps` instructions'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11-13：`vmovhpd` 和 `vmovhps` 指令
- en: 'Unlike for the `movhps` instruction, MASM properly accepts `real4` source operands
    for the `vmovhps` instruction:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 与 `movhps` 指令不同，MASM 正确接受 `real4` 源操作数用于 `vmovhps` 指令：
- en: '[PRE24]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 11.6.8 The movlhps and vmovlhps Instructions
  id: totrans-193
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 11.6.8 `movlhps` 和 `vmovlhps` 指令
- en: The `movlhps` instruction moves a pair of 32-bit single-precision floating-point
    values from the LO qword of the source XMM register into the HO 64 bits of a destination
    XMM register. It leaves the LO 64 bits of the destination register unchanged.
    If the destination register is on a CPU that supports 256-bit AVX registers, this
    instruction also leaves the HO 128 bits of the overlaid YMM register unchanged.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: '`movlhps` 指令将一对 32 位单精度浮点值从源 XMM 寄存器的低 64 位移动到目标 XMM 寄存器的高 64 位。它保持目标寄存器的低
    64 位不变。如果目标寄存器位于支持 256 位 AVX 寄存器的 CPU 上，此指令还将保持重叠 YMM 寄存器的高 128 位不变。'
- en: 'The syntax for these instructions is as follows:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 这些指令的语法如下：
- en: '[PRE25]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: You cannot use this instruction to move data between memory and an XMM register;
    it transfers data only between XMM registers. No double-precision version of this
    instruction exists.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 你不能使用此指令在内存和 XMM 寄存器之间移动数据；它仅在 XMM 寄存器之间传输数据。没有双精度版本的此指令。
- en: 'The `vmovlhps` instruction is similar to `movlhps`, with the following differences:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: '`vmovlhps` 指令类似于 `movlhps`，但有以下不同之处：'
- en: '`vmovlhps` requires three operands: two source XMM registers and a destination
    XMM register.'
  id: totrans-199
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`vmovlhps` 需要三个操作数：两个源 XMM 寄存器和一个目标 XMM 寄存器。'
- en: '`vmovlhps` copies the LO quad word of the first source register into the LO
    quad word of the destination register.'
  id: totrans-200
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`vmovlhps` 将第一个源寄存器的低 64 位拷贝到目标寄存器的低 64 位。'
- en: '`vmovlhps` copies the LO quad word of the second source register into bits
    64 to 127 of the destination register.'
  id: totrans-201
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`vmovlhps` 将第二个源寄存器的低 64 位拷贝到目标寄存器的 64 至 127 位。'
- en: '`vmovlhps` zero-extends the result into the upper 128 bits of the overlaid
    YMM register.'
  id: totrans-202
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`vmovlhps` 将结果零扩展到重叠 YMM 寄存器的上 128 位。'
- en: There is no `vmovlhpd` instruction.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 没有 `vmovlhpd` 指令。
- en: 11.6.9 The movhlps and vmovhlps Instructions
  id: totrans-204
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 11.6.9 `movhlps` 和 `vmovhlps` 指令
- en: 'The `movhlps` instruction has the following syntax:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: '`movhlps` 指令的语法如下：'
- en: '[PRE26]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: The `movhlps` instruction copies the pair of 32-bit single-precision floating-point
    values from the HO qword of the source operand to the LO qword of the destination
    register, leaving the HO 64 bits of the destination register unchanged (this is
    the converse of `movlhps`). This instruction copies data only between XMM registers;
    it does not allow a memory operand.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: '`movhlps` 指令将源操作数的高 64 位中的一对 32 位单精度浮点值拷贝到目标寄存器的低 64 位，而不改变目标寄存器的高 64 位（这是
    `movlhps` 的反操作）。此指令仅在 XMM 寄存器之间拷贝数据；不允许使用内存操作数。'
- en: 'The `vmovhlps` instruction requires three XMM register operands; here is its
    syntax:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: '`vmovhlps` 指令需要三个 XMM 寄存器操作数；其语法如下：'
- en: '[PRE27]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: This instruction copies the HO 64 bits of the first source register into the
    HO 64 bits of the destination register, copies the HO 64 bits of the second source
    register into bits 0 to 63 of the destination register, and finally, zero-extends
    the result into the upper bits of the overlaid YMM register.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 该指令将第一个源寄存器的高 64 位复制到目标寄存器的高 64 位，将第二个源寄存器的高 64 位复制到目标寄存器的 0 到 63 位，最后将结果零扩展到覆盖的
    YMM 寄存器的上位。
- en: There are no `movhlpd` or `vmovhlpd` instructions.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 没有 `movhlpd` 或 `vmovhlpd` 指令。
- en: 11.6.10 The (v)movshdup and (v)movsldup Instructions
  id: totrans-212
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 11.6.10 (v)movshdup 和 (v)movsldup 指令
- en: The `movshdup` instruction moves the two odd-index single-precision floating-point
    values from the source operand (memory or XMM register) and duplicates each element
    into the destination XMM register, as shown in [Figure 11-14](#figure11-14).
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: '`movshdup` 指令将源操作数（内存或 XMM 寄存器）中的两个奇数索引的单精度浮点值移动，并将每个元素复制到目标 XMM 寄存器，如[图 11-14](#figure11-14)所示。'
- en: '![f11014](image_fi/501089c11/f11014.png)'
  id: totrans-214
  prefs: []
  type: TYPE_IMG
  zh: '![f11014](image_fi/501089c11/f11014.png)'
- en: 'Figure 11-14: `movshdup` and `vmovshdup` instructions'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: '图 11-14: `movshdup` 和 `vmovshdup` 指令'
- en: 'This instruction ignores the single-precision floating-point values at even-lane
    indexes into the XMM register. The `vmovshdup` instruction works the same way
    but on YMM registers, copying four single-precision values rather than two (and,
    of course, zeroing the HO bits). The syntax for these instructions is shown here:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 该指令忽略 XMM 寄存器中偶数索引位置的单精度浮点值。`vmovshdup` 指令的工作方式相同，但作用于 YMM 寄存器，复制四个单精度值而不是两个（当然，还会将高位
    0）。这些指令的语法如下所示：
- en: '[PRE28]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: The `movsldup` instruction works just like the `movshdup` instruction, except
    it copies and duplicates the two single-precision values at even indexes in the
    source XMM register to the destination XMM register. Likewise, the `vmovsldup`
    instruction copies and duplicates the four double-precision values in the source
    YMM register at even indexes, as shown in [Figure 11-15](#figure11-15).
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: '`movsldup` 指令的工作方式与 `movshdup` 指令相同，唯一不同的是它将源 XMM 寄存器中偶数索引位置的两个单精度值复制并重复到目标
    XMM 寄存器。同样，`vmovsldup` 指令将源 YMM 寄存器中偶数索引位置的四个双精度值复制并重复，如[图 11-15](#figure11-15)所示。'
- en: '![f11015](image_fi/501089c11/f11015.png)'
  id: totrans-219
  prefs: []
  type: TYPE_IMG
  zh: '![f11015](image_fi/501089c11/f11015.png)'
- en: 'Figure 11-15: `movsldup` and `vmovsldup` instructions'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: '图 11-15: `movsldup` 和 `vmovsldup` 指令'
- en: 'The syntax is as follows:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 语法如下：
- en: '[PRE29]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 11.6.11 The (v)movddup Instruction
  id: totrans-223
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 11.6.11 (v)movddup 指令
- en: The `movddup` instruction copies and duplicates a double-precision value from
    the LO 64 bits of an XMM register or a 64-bit memory location into the LO 64 bits
    of a destination XMM register; then it also duplicates this value into bits 64
    to 127 of that same destination register, as shown in [Figure 11-16](#figure11-16).
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: '`movddup` 指令将 XMM 寄存器的低 64 位或 64 位内存位置中的双精度值复制并重复到目标 XMM 寄存器的低 64 位；然后，它还会将该值复制到目标寄存器的
    64 到 127 位，如[图 11-16](#figure11-16)所示。'
- en: '![f11016](image_fi/501089c11/f11016.png)'
  id: totrans-225
  prefs: []
  type: TYPE_IMG
  zh: '![f11016](image_fi/501089c11/f11016.png)'
- en: 'Figure 11-16: `movddup` instruction behavior'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: '图 11-16: `movddup` 指令的行为'
- en: 'This instruction does not disturb the HO 128 bits of a YMM register (if applicable).
    The syntax for this instruction is as follows:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 该指令不会影响 YMM 寄存器的高 128 位（如果适用）。该指令的语法如下：
- en: '[PRE30]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: The `vmovddup` instruction operates on an XMM or a YMM destination register
    and an XMM or a YMM source register or 128- or 256-bit memory location. The 128-bit
    version works just like the `movddup` instruction except it zeroes the HO bits
    of the destination YMM register. The 256-bit version copies a pair of double-precision
    values at even indexes (0 and 2) in the source value to their corresponding indexes
    in the destination YMM register and duplicates those values at the odd indexes
    in the destination, as [Figure 11-17](#figure11-17) shows.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: '`vmovddup` 指令在 XMM 或 YMM 目标寄存器与 XMM 或 YMM 源寄存器或 128 位或 256 位内存位置之间进行操作。128
    位版本的工作方式与 `movddup` 指令相同，但它会将目标 YMM 寄存器的高位清零。256 位版本将源值中偶数索引（0 和 2）处的一对双精度值复制到目标
    YMM 寄存器中对应的索引，并将这些值复制到目标寄存器中的奇数索引位置，如[图 11-17](#figure11-17)所示。'
- en: '![f11017](image_fi/501089c11/f11017.png)'
  id: totrans-230
  prefs: []
  type: TYPE_IMG
  zh: '![f11017](image_fi/501089c11/f11017.png)'
- en: 'Figure 11-17: `vmovddup` instruction behavior'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: '图 11-17: `vmovddup` 指令的行为'
- en: 'Here is the syntax for this instruction:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 该指令的语法如下：
- en: '[PRE31]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 11.6.12 The (v)lddqu Instruction
  id: totrans-234
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 11.6.12 (v)lddqu 指令
- en: The `(v)lddqu` instruction is operationally identical to `(v)movdqu`. You can
    sometimes use this instruction to improve performance if the (memory) source operand
    is not aligned properly and crosses a cache line boundary in memory. For more
    details on this instruction and its performance limitations, refer to the Intel
    or AMD documentation (specifically, the optimization manuals).
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: '`(v)lddqu`指令在操作上与`(v)movdqu`完全相同。如果（内存）源操作数没有正确对齐并且跨越了内存中的缓存行边界，你有时可以使用此指令来提高性能。有关此指令及其性能限制的更多详细信息，请参阅Intel或AMD的文档（特别是优化手册）。'
- en: 'These instructions always take the following form:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 这些指令通常采用以下形式：
- en: '[PRE32]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 11.6.13 Performance Issues and the SIMD Move Instructions
  id: totrans-238
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 11.6.13 性能问题与SIMD移动指令
- en: When you look at the SSE/AVX instructions’ semantics at the programming model
    level, you might question why certain instructions appear in the instruction set.
    For example, the `movq`, `movsd`, and `movlps` instructions can all load 64 bits
    from a memory location into the LO 64 bits of an XMM register. Why bother doing
    this? Why not have a single instruction that copies the 64 bits from a quad word
    in memory to the LO 64 bits of an XMM register (be it a 64-bit integer, a pair
    of 32-bit integers, a 64-bit double-precision floating-point value, or a pair
    of 32-bit single-precision floating-point values)? The answer lies in the term
    *microarchitecture*.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 当你从编程模型层次查看SSE/AVX指令的语义时，你可能会质疑为什么某些指令出现在指令集中。例如，`movq`、`movsd`和`movlps`指令都可以从内存位置加载64位数据到XMM寄存器的LO
    64位部分。为什么要这样做？为什么不使用一条指令直接将内存中的四字数据复制到XMM寄存器的LO 64位部分（无论是64位整数、一对32位整数、64位双精度浮点值，还是一对32位单精度浮点值）？答案就在于*微架构*这个术语中。
- en: The x86-64 *macroarchitecture* is the programming model that a software engineer
    sees. In the macroarchitecture, an XMM register is a 128-bit resource that, at
    any given time, could hold a 128-bit array of bits (or an integer), a pair of
    64-bit integer values, a pair of 64-bit double-precision floating-point values,
    a set of four single-precision floating-point values, a set of four double-word
    integers, eight words, or 16 bytes. All these data types overlay one another,
    just like the 8-, 16-, 32-, and 64-bit general-purpose registers overlay one another
    (this is known as *aliasing*). If you load two double-precision floating-point
    values into an XMM register and then modify the (integer) word at bit positions
    0 to 15, you’re also changing those same bits (0 to 15) in the double-precision
    value in the LO qword of the XMM register. The semantics of the x86-64 programming
    model require this.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: x86-64 *宏架构*是软件工程师所看到的编程模型。在宏架构中，XMM寄存器是一个128位的资源，在任何给定时刻，它可以容纳一个128位的位数组（或一个整数）、一对64位整数值、一对64位双精度浮点值、一组四个单精度浮点值、一组四个双字整数、八个字或16个字节。所有这些数据类型是相互叠加的，就像8位、16位、32位和64位的通用寄存器相互叠加一样（这被称为*别名*）。如果你将两个双精度浮点值加载到XMM寄存器中，然后修改位位置0到15的（整数）字，你实际上也在改变XMM寄存器的LO四字中的双精度值中相同的位（0到15）。x86-64编程模型的语义要求这样做。
- en: At the microarchitectural level, however, there is no requirement that the CPU
    use the same physical bits in the CPU for integer, single-precision, and double-precision
    values (even when they are aliased to the same register). The microarchitecture
    could set aside a separate set of bits to hold integers, single-precision, and
    double-precision values for a single register. So, for example, when you use the
    `movq` instruction to load 64 bits into an XMM register, that instruction might
    actually copy the bits into the underlying integer register (without affecting
    the single-precision or double-precision subregisters). Likewise, `movlps` would
    copy a pair of single-precision values into the single-precision register, and
    `movsd` would copy a double-precision value into the double-precision register
    ([Figure 11-18](#figure11-18)). These separate subregisters (integer, single-precision,
    and double-precision) could be connected directly to the arithmetic or logical
    unit that handles their specific data types, making arithmetic and logical operations
    on those subregisters more efficient. As long as the data is sitting in the appropriate
    subregister, everything works smoothly.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，从微体系结构的角度来看，并没有要求CPU在CPU中使用相同的物理位来存储整数、单精度和双精度值（即使它们被别名映射到同一个寄存器）。微体系结构可以为单个寄存器设置一组单独的位，用来存储整数、单精度和双精度值。例如，当你使用`movq`指令将64位加载到XMM寄存器时，该指令实际上可能会将位复制到底层的整数寄存器中（而不影响单精度或双精度子寄存器）。同样，`movlps`指令会将一对单精度值复制到单精度寄存器中，`movsd`指令则会将一个双精度值复制到双精度寄存器中（见[图11-18](#figure11-18)）。这些独立的子寄存器（整数、单精度和双精度）可以直接连接到处理它们特定数据类型的算术或逻辑单元，从而使对这些子寄存器的算术和逻辑操作更加高效。只要数据位于适当的子寄存器中，一切都能顺利进行。
- en: '![f11018](image_fi/501089c11/f11018.png)'
  id: totrans-242
  prefs: []
  type: TYPE_IMG
  zh: '![f11018](image_fi/501089c11/f11018.png)'
- en: 'Figure 11-18: Register aliasing at the microarchitectural level'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 图11-18：微体系结构级别的寄存器别名
- en: However, what happens if you use `movq` to load a pair of single-precision floating-point
    values into an XMM register and then try to perform a single-precision vector
    operation on those two values? At the macroarchitectural level, the two single-precision
    values are sitting in the appropriate bit positions of the XMM register, so this
    has to be a legal operation. At the microarchitectural level, however, those two
    single-precision floating-point values are sitting in the integer subregister,
    not the single-precision subregister. The underlying microarchitecture has to
    note that the values are in the wrong subregister and move them to the appropriate
    (single-precision) subregister before performing the single-precision arithmetic
    or logical operation. This may introduce a slight delay (while the microarchitecture
    moves the data around), which is why you should always pick the appropriate move
    instructions for your data types.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果你使用`movq`指令将一对单精度浮点数加载到XMM寄存器中，然后尝试对这两个值执行单精度向量操作，会发生什么情况呢？从宏体系结构的角度来看，这两个单精度值正坐落在XMM寄存器的适当位置，因此这应该是一个合法操作。然而，从微体系结构的角度来看，这两个单精度浮点数坐落在整数子寄存器中，而不是单精度子寄存器中。底层微体系结构必须注意到这些值位于错误的子寄存器，并在执行单精度算术或逻辑操作之前将它们移动到适当的（单精度）子寄存器中。这可能会引入轻微的延迟（当微体系结构移动数据时），这就是为什么你应该始终为数据类型选择适当的移动指令。
- en: 11.6.14 Some Final Comments on the SIMD Move Instructions
  id: totrans-245
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 11.6.14 对SIMD移动指令的一些最终评论
- en: The SIMD data movement instructions are a confusing bunch. Their syntax is inconsistent,
    many instructions duplicate the actions of other instructions, and they have some
    perplexing irregularity issues. Someone new to the x86-64 instruction set might
    ask, “Why was the instruction set designed this way?” Why, indeed?
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: SIMD数据移动指令是一组令人困惑的指令。它们的语法不一致，许多指令重复执行其他指令的操作，而且它们还存在一些令人困惑的不规则性问题。对于x86-64指令集的新手来说，可能会问：“为什么指令集是这样设计的？”为什么，确实是这样？
- en: The answer to that question is historical. The SIMD instructions did not exist
    on the earliest x86 CPUs. Intel added the MMX instruction set to the Pentium-series
    CPUs. At that time (the early 1990s), current technology allowed Intel to add
    only a few additional instructions, and the MMX registers were limited to 64 bits
    in size. Furthermore, software engineers and computer systems designers were only
    beginning to explore the multimedia capabilities of modern computers, so it wasn’t
    entirely clear which instructions (and data types) were necessary to support the
    type of software we see several decades later. As a result, the earliest SIMD
    instructions and data types were limited in scope.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 这个问题的答案是历史性的。最早的x86 CPU并没有SIMD指令集。Intel为Pentium系列CPU增加了MMX指令集。在那个时候（1990年代初期），当时的技术只允许Intel增加少量的指令，而且MMX寄存器的大小限制为64位。此外，软件工程师和计算机系统设计师才刚刚开始探索现代计算机的多媒体功能，因此当时并不完全清楚哪些指令（和数据类型）是支持我们几十年后所看到的软件所必需的。因此，最早的SIMD指令和数据类型在功能上是有限的。
- en: As time passed, CPUs gained additional silicon resources, and software/systems
    engineers discovered new uses for computers (and new algorithms to run on those
    computers), so Intel (and AMD) responded by adding new SIMD instructions to support
    these more modern multimedia applications. The original MMX instructions, for
    example, supported only integer data types, so Intel added floating-point support
    in the SSE instruction set, because multimedia applications needed real data types.
    Then Intel extended the integer types from 64 bits to 128, 256, and even 512 bits.
    With each extension, Intel (and AMD) had to retain the older instruction set extensions
    in order to allow preexisting software to run on the new CPUs.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 随着时间的推移，CPU获得了更多的硅资源，软件/系统工程师也发现了计算机的新用途（以及在这些计算机上运行的新算法），因此Intel（和AMD）通过添加新的SIMD指令来支持这些更现代的多媒体应用。例如，最初的MMX指令仅支持整数数据类型，因此Intel在SSE指令集中增加了浮点数支持，因为多媒体应用需要真实数据类型。随后，Intel将整数类型从64位扩展到了128位、256位，甚至512位。随着每次扩展，Intel（和AMD）不得不保留旧的指令集扩展，以便允许现有软件在新的CPU上运行。
- en: As a result, the newer instruction sets kept piling on new instructions that
    did the same work as the older ones (with some additional capabilities). This
    is why instructions like `movaps` and `vmovaps` have considerable overlap in their
    functionality. If the CPU resources had been available earlier (for example, to
    put 256-bit YMM registers on the CPU), there would have been almost no need for
    the `movaps` instruction—the `vmovaps` could have done all the work.^([6](#c11-footnote-6))
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 结果是，新的指令集不断堆积了与旧指令相同功能的新指令（并附带一些额外的功能）。这就是为什么像`movaps`和`vmovaps`这样的指令在功能上有显著重叠的原因。如果CPU资源早些时候就已到位（例如，能够在CPU上放置256位的YMM寄存器），那么几乎就不需要`movaps`指令了——`vmovaps`本可以完成所有工作。^([6](#c11-footnote-6))
- en: 'In theory, we could create an architecturally elegant variant of the x86-64
    by starting over from scratch and designing a minimal instruction set that handles
    all the activities of the current x86-64 without all the kruft and kludges present
    in the existing instruction set. However, such a CPU would lose the primary advantage
    of the x86-64: the ability to run decades of software written for the Intel architecture.
    The cost of being able to run all this old software is that assembly language
    programmers (and compiler writers) have to deal with all these irregularities
    in the instruction set.'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 从理论上讲，我们可以通过从头开始重新设计一个架构优雅的x86-64变种，设计一个最小的指令集来处理当前x86-64的所有活动，而不需要现有指令集中存在的所有冗余和臃肿。然而，这样的CPU将失去x86-64的主要优势：运行为Intel架构编写的数十年软件的能力。能够运行所有这些旧软件的代价是，汇编语言程序员（和编译器开发者）必须处理指令集中所有这些不规则性。
- en: 11.7 The Shuffle and Unpack Instructions
  id: totrans-251
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 11.7 洗牌和解包指令
- en: The SSE/AVX *shuffle and unpack instructions* are variants of the move instructions.
    In addition to moving data around, these instructions can also rearrange the data
    appearing in different lanes of the XMM and YMM registers.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: SSE/AVX *洗牌和解包指令*是移动指令的变体。除了移动数据之外，这些指令还可以重新排列出现在XMM和YMM寄存器不同通道中的数据。
- en: 11.7.1 The (v)pshufb Instructions
  id: totrans-253
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 11.7.1 (v)pshufb指令
- en: 'The `pshufb` instruction was the first packed byte shuffle SIMD instruction
    (it first appeared with the MMX instruction set). Because of its origin, its syntax
    and behavior are a bit different from the other shuffle instructions in the instruction
    set. The syntax is the following:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: '`pshufb` 指令是第一个打包字节洗牌 SIMD 指令（首次出现在 MMX 指令集中）。由于其起源，语法和行为与指令集中其他洗牌指令有所不同。其语法如下：'
- en: '[PRE33]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: The first (destination) operand is an XMM register whose byte lanes `pshufb`
    will shuffle (rearrange). The second operand (either an XMM register or a 128-bit
    oword memory location) is an array of 16 byte values holding indexes that control
    the shuffle operation. If the second operand is a memory location, that oword
    value must be aligned on a 16-byte boundary.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个（目标）操作数是一个 XMM 寄存器，其字节车道将由 `pshufb` 洗牌（重新排列）。第二个操作数（可以是 XMM 寄存器或 128 位 oword
    内存位置）是一个包含 16 个字节值的数组，这些值控制洗牌操作。如果第二个操作数是内存位置，该 oword 值必须在 16 字节边界上对齐。
- en: Each byte (lane) in the second operand selects a value for the corresponding
    byte lane in the first operand, as shown in [Figure 11-19](#figure11-19).
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个操作数中的每个字节（车道）都为第一个操作数中相应的字节车道选择一个值，如[图 11-19](#figure11-19)所示。
- en: '![f11019](image_fi/501089c11/f11019.png)'
  id: totrans-258
  prefs: []
  type: TYPE_IMG
  zh: '![f11019](image_fi/501089c11/f11019.png)'
- en: 'Figure 11-19: Lane index correspondence for `pshufb` instruction'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11-19：`pshufb` 指令的车道索引对应关系
- en: The 16-byte indexes in the second operand each take the form shown in [Figure
    11-20](#figure11-20).
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个操作数中的 16 字节索引分别采用[图 11-20](#figure11-20)中所示的形式。
- en: '![f11020](image_fi/501089c11/f11020.png)'
  id: totrans-261
  prefs: []
  type: TYPE_IMG
  zh: '![f11020](image_fi/501089c11/f11020.png)'
- en: 'Figure 11-20: `phsufb` byte index'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11-20：`phsufb` 字节索引
- en: The `pshufb` instruction ignores bits 4 to 6 in an index byte. Bit 7 is the
    clear bit; if this bit contains a 1, the `pshufb` instruction ignores the lane
    index bits and stores a 0 into the corresponding byte in XMM[dest]. If the clear
    bit contains a 0, the `pshufb` instruction does a shuffle operation.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: '`pshufb` 指令会忽略索引字节中的第 4 到第 6 位。第 7 位是清除位；如果此位为 1，`pshufb` 指令将忽略车道索引位，并在 XMM[dest]
    中对应的字节位置存储 0。如果清除位为 0，`pshufb` 指令将执行洗牌操作。'
- en: The `pshufb` shuffle operation takes place on a lane-by-lane basis. The instruction
    first makes a temporary copy of XMM[dest]. Then for each index byte (whose HO
    bit is 0), the `pshufb` copies the lane specified by the LO 4 bits of the index
    from the XMM[dest] lane that matches the index’s lane, as shown in [Figure 11-21](#figure11-21).
    In this example, the index appearing in lane 6 contains the value 00000011b. This
    selects the value in lane 3 of the temporary (original XMM[dest]) value and copies
    it to lane 6 of XMM[dest]. The `pshufb` instruction repeats this operation for
    all l6 lanes.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: '`pshufb` 洗牌操作是逐车道进行的。指令首先会创建 XMM[dest] 的临时副本。然后，对于每个索引字节（其 HO 位为 0），`pshufb`
    将根据索引的 LO 4 位，从与该索引车道匹配的 XMM[dest] 车道中复制指定的车道，如[图 11-21](#figure11-21)所示。在此示例中，位于车道
    6 的索引包含值 00000011b。该值选择临时（原始 XMM[dest]）值中车道 3 的值，并将其复制到 XMM[dest] 的车道 6。`pshufb`
    指令会对所有 16 个车道重复此操作。'
- en: '![f11021](image_fi/501089c11/f11021.png)'
  id: totrans-265
  prefs: []
  type: TYPE_IMG
  zh: '![f11021](image_fi/501089c11/f11021.png)'
- en: 'Figure 11-21: Shuffle operation'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11-21：洗牌操作
- en: 'The AVX instruction set extensions introduced the `vpshufb` instruction. Its
    syntax is the following:'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: AVX 指令集扩展引入了 `vpshufb` 指令。其语法如下：
- en: '[PRE34]'
  id: totrans-268
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: The AVX variant adds a source register (rather than using XMM[dest] as both
    the source and destination registers), and, rather than creating a temporary copy
    of XMM[dest] prior to the operation and picking the values from that copy, the
    `vpshufb` instructions select the source bytes from the XMM[src] register. Other
    than that, and the fact that these instructions zero the HO bits of YMM[dest],
    the 128-bit variant operates identically to the SSE `pshufb` instruction.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: AVX 变体添加了源寄存器（而不是使用 XMM[dest] 作为源和目标寄存器），并且与其不同的是，`vpshufb` 指令从 XMM[src] 寄存器中选择源字节，而不是在操作前创建
    XMM[dest] 的临时副本并从该副本中选择值。除此之外，这些指令还将 YMM[dest] 的 HO 位清零，128 位变体与 SSE `pshufb`
    指令的操作完全相同。
- en: The AVX instruction allows you to specify 256-bit YMM registers in addition
    to 128-bit XMM registers.^([7](#c11-footnote-7))
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: AVX 指令允许您指定 256 位的 YMM 寄存器，除了 128 位的 XMM 寄存器之外。^([7](#c11-footnote-7))
- en: 11.7.2 The (v)pshufd Instructions
  id: totrans-271
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 11.7.2 (v)pshufd 指令
- en: 'The SSE extensions first introduced the `pshufd` instruction. The AVX extensions
    added the `vpshufd` instruction. These instructions shuffle dwords in XMM and
    YMM registers (*not* double-precision values) similarly to the `(v)pshufb` instructions.
    However, the shuffle index is specified differently from `(v)pshufb`. The syntax
    for the `(v)pshufd` instructions is as follows:'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: SSE 扩展首次引入了 `pshufd` 指令。AVX 扩展增加了 `vpshufd` 指令。这些指令以类似于 `(v)pshufb` 指令的方式打乱
    XMM 和 YMM 寄存器中的双字（*不是* 双精度值）。然而，打乱索引的指定方式与 `(v)pshufb` 不同。`(v)pshufd` 指令的语法如下：
- en: '[PRE35]'
  id: totrans-273
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: The first operand (XMM[dest] or YMM[dest]) is the destination operand where
    the shuffled values will be stored. The second operand is the source from which
    the instruction will select the double words to place in the destination register;
    as usual, if this is a memory operand, you must align it on the appropriate (16-
    or 32-byte) boundary. The third operand is an 8-bit immediate value that specifies
    the indexes for the double words to select from the source operand.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个操作数（XMM[dest] 或 YMM[dest]）是目标操作数，用于存储被打乱的值。第二个操作数是源操作数，指令将从中选择双字以放入目标寄存器；通常，如果这是内存操作数，则必须将其对齐到适当的（16
    字节或 32 字节）边界。第三个操作数是一个 8 位立即数，指定从源操作数中选择双字的索引。
- en: For the `(v)pshufd` instructions with an XMM[dest] operand, the imm[8] operand
    has the encoding shown in [Table 11-3](#table11-3). The value in bits 0 to 1 selects
    a particular dword from the source operand to place in dword 0 of the XMM[dest]
    operand. The value in bits 2 to 3 selects a dword from the source operand to place
    in dword 1 of the XMM[dest] operand. The value in bits 4 to 5 selects a dword
    from the source operand to place in dword 2 of the XMM[dest] operand. Finally,
    the value in bits 6 to 7 selects a dword from the source operand to place in dword
    3 of the XMM[dest] operand.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 对于带有 XMM[dest] 操作数的 `(v)pshufd` 指令，imm[8] 操作数的编码如 [表 11-3](#table11-3) 所示。位
    0 到 1 中的值选择源操作数中的特定双字，并将其放入 XMM[dest] 操作数的双字 0 中。位 2 到 3 中的值选择源操作数中的一个双字，并将其放入
    XMM[dest] 操作数的双字 1 中。位 4 到 5 中的值选择源操作数中的一个双字，并将其放入 XMM[dest] 操作数的双字 2 中。最后，位 6
    到 7 中的值选择源操作数中的一个双字，并将其放入 XMM[dest] 操作数的双字 3 中。
- en: 'Table 11-3: `(v)pshufd` imm[8] Operand Values'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 表 11-3：`(v)pshufd` imm[8] 操作数值
- en: '| **Bit positions** | **Destination lane** |'
  id: totrans-277
  prefs: []
  type: TYPE_TB
  zh: '| **位位置** | **目标通道** |'
- en: '| --- | --- |'
  id: totrans-278
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| 0 to 1 | 0 |'
  id: totrans-279
  prefs: []
  type: TYPE_TB
  zh: '| 0 到 1 | 0 |'
- en: '| 2 to 3 | 1 |'
  id: totrans-280
  prefs: []
  type: TYPE_TB
  zh: '| 2 到 3 | 1 |'
- en: '| 4 to 5 | 2 |'
  id: totrans-281
  prefs: []
  type: TYPE_TB
  zh: '| 4 到 5 | 2 |'
- en: '| 6 to 7 | 3 |'
  id: totrans-282
  prefs: []
  type: TYPE_TB
  zh: '| 6 到 7 | 3 |'
- en: The difference between the 128-bit `pshufd` and `vpshufd` instructions is that
    `pshufd` leaves the HO 128 bits of the underlying YMM register unchanged and `vpshufd`
    zeroes the HO 128 bits of the underlying YMM register.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 128 位 `pshufd` 与 `vpshufd` 指令的区别在于，`pshufd` 会保持底层 YMM 寄存器的高 128 位不变，而 `vpshufd`
    会将底层 YMM 寄存器的高 128 位清零。
- en: The 256-bit variant of `vpshufd` (when using YMM registers as the source and
    destination operands) still uses an 8-bit immediate operand as the index value.
    Each 2-bit index value manipulates two dword values in the YMM registers. Bits
    0 to 1 control dwords 0 and 4, bits 2 to 3 control dwords 1 and 5, bits 4 to 5
    control dwords 2 and 6, and bits 6 to 7 control dwords 3 and 7, as shown in [Table
    11-4](#table11-4).
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: '`vpshufd` 的 256 位变体（当使用 YMM 寄存器作为源和目标操作数时）仍然使用 8 位立即数操作数作为索引值。每个 2 位的索引值操作
    YMM 寄存器中的两个双字值。位 0 到 1 控制双字 0 和 4，位 2 到 3 控制双字 1 和 5，位 4 到 5 控制双字 2 和 6，位 6 到
    7 控制双字 3 和 7，如 [表 11-4](#table11-4) 所示。'
- en: 'Table 11-4: Double-Word Transfers for `vpshufd` YMM[dest], YMM[src]/mem[src],
    imm[8]'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 表 11-4：`vpshufd` YMM[dest], YMM[src]/mem[src], imm[8] 的双字传输
- en: '| **Index** | **YMM/mem[src] [index] copied into** | **YMM/mem[src] [index
    + 4] copied into** |'
  id: totrans-286
  prefs: []
  type: TYPE_TB
  zh: '| **索引** | **YMM/mem[src] [索引] 复制到** | **YMM/mem[src] [索引 + 4] 复制到** |'
- en: '| --- | --- | --- |'
  id: totrans-287
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| Bits 0 to 1 of imm[8] | YMM[dest][0] | YMM[dest][4] |'
  id: totrans-288
  prefs: []
  type: TYPE_TB
  zh: '| imm[8] 的位 0 到 1 | YMM[dest][0] | YMM[dest][4] |'
- en: '| Bits 2 to 3 of imm[8] | YMM[dest][1] | YMM[dest][5] |'
  id: totrans-289
  prefs: []
  type: TYPE_TB
  zh: '| imm[8] 的位 2 到 3 | YMM[dest][1] | YMM[dest][5] |'
- en: '| Bits 4 to 5 of imm[8] | YMM[dest][2] | YMM[dest][6] |'
  id: totrans-290
  prefs: []
  type: TYPE_TB
  zh: '| imm[8] 的位 4 到 5 | YMM[dest][2] | YMM[dest][6] |'
- en: '| Bits 6 to 7 of imm[8] | YMM[dest][3] | YMM[dest][7] |'
  id: totrans-291
  prefs: []
  type: TYPE_TB
  zh: '| imm[8] 的位 6 到 7 | YMM[dest][3] | YMM[dest][7] |'
- en: The 256-bit version is slightly less flexible as it copies two dwords at a time,
    rather than one. It processes the LO 128 bits exactly the same way as the 128-bit
    version of the instruction; it also copies the corresponding lanes in the upper
    128 bits of the source to the YMM destination register by using the same shuffle
    pattern. Unfortunately, you can’t independently control the HO and LO halves of
    the YMM register by using the `vpshufd` instruction. If you really need to shuffle
    dwords independently, you can use `vshufb` with appropriate indexes that copy
    4 bytes (in place of a single dword).
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 256 位版本的灵活性稍差，因为它一次复制两个双字，而不是一个。它处理 LO 128 位的方式与 128 位版本相同；它还通过使用相同的洗牌模式，将源的高
    128 位中的相应字道复制到 YMM 目标寄存器中。不幸的是，你无法通过 `vpshufd` 指令独立控制 YMM 寄存器的高低两半。如果你真的需要独立地洗牌双字，可以使用
    `vshufb`，并使用合适的索引复制 4 字节（替代单个双字）。
- en: 11.7.3 The (v)pshuflw and (v)pshufhw Instructions
  id: totrans-293
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 11.7.3 (v)pshuflw 和 (v)pshufhw 指令
- en: 'The `pshuflw` and `vpshuflw` and the `pshufhw` and `vpshufhw` instructions
    provide support for 16-bit word shuffles within an XMM or a YMM register. The
    syntax for these instructions is the following:'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: '`pshuflw` 和 `vpshuflw` 以及 `pshufhw` 和 `vpshufhw` 指令支持在 XMM 或 YMM 寄存器内进行 16
    位字的洗牌。这些指令的语法如下：'
- en: '[PRE36]'
  id: totrans-295
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: The 128-bit `lw` variants copy the HO 64 bits of the source operand to the same
    positions in the XMM[dest] operand. Then they use the index (imm[8]) operand to
    select word lanes 0 to 3 in the LO qword of the XMM[src]/mem[128] operand to move
    to the LO 4 lanes of the destination operand. For example, if the LO 2 bits of
    imm[8] are 10b, then the `pshuflw` instruction copies lane 2 from the source into
    lane 0 of the destination operand ([Figure 11-22](#figure11-22)). Note that `pshuflw`
    does not modify the HO 128 bits of the overlaid YMM register, whereas `vpshuflw`
    zeroes those HO bits.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 128 位的 `lw` 变种将源操作数的高 64 位复制到 XMM[dest] 操作数的相同位置。然后，它们使用索引（imm[8]）操作数选择 XMM[src]/mem[128]
    操作数的 LO 四字双字（word lanes 0 到 3），并将其移动到目标操作数的 LO 4 个字道中。例如，如果 imm[8] 的低 2 位是 10b，那么
    `pshuflw` 指令会将源的第 2 道复制到目标操作数的第 0 道中（参见[图 11-22](#figure11-22)）。请注意，`pshuflw`
    不会修改叠加的 YMM 寄存器的高 128 位，而 `vpshuflw` 会将高 128 位清零。
- en: '![f11022](image_fi/501089c11/f11022.png)'
  id: totrans-297
  prefs: []
  type: TYPE_IMG
  zh: '![f11022](image_fi/501089c11/f11022.png)'
- en: 'Figure 11-22: `(v)pshuflw` `xmm``,` `xmm``/``mem``,` `imm`8 operation'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: '图 11-22: `(v)pshuflw` `xmm``,` `xmm``/``mem``,` `imm`8 操作'
- en: The 256-bit `vpshuflw` instruction (with a YMM destination register) copies
    two pairs of words at a time—one pair in the HO 128 bits and one pair in the LO
    128 bits of the YMM destination register and 256-bit source locations, as shown
    in [Figure 11-23](#figure11-23). The index (imm[8]) selection is the same for
    the LO and HO 128 bits.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 256 位的 `vpshuflw` 指令（具有 YMM 目标寄存器）一次复制两对字—一对在 YMM 目标寄存器的高 128 位，另一对在 LO 128
    位，源位置为 256 位，如[图 11-23](#figure11-23)所示。索引（imm[8]）选择对于高低 128 位是相同的。
- en: '![f11023](image_fi/501089c11/f11023.png)'
  id: totrans-300
  prefs: []
  type: TYPE_IMG
  zh: '![f11023](image_fi/501089c11/f11023.png)'
- en: 'Figure 11-23: `vpshuflw` `ymm``,` `ymm``/``mem``,` `imm`8 operation'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: '图 11-23: `vpshuflw` `ymm``,` `ymm``/``mem``,` `imm`8 操作'
- en: The 128-bit `hw` variants copy the LO 64 bits of the source operand to the same
    positions in the destination operand. Then they use the index operand to select
    words 4 to 7 (indexed as 0 to 3) in the 128-bit source operand to move to the
    HO four word lanes of the destination operand ([Figure 11-24](#figure11-24)).
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 128 位的 `hw` 变种将源操作数的低 64 位复制到目标操作数的相同位置。然后，它们使用索引操作数选择源操作数中第 4 到第 7 个字（按 0 到
    3 索引），并将其移动到目标操作数的高 4 个字道中（参见[图 11-24](#figure11-24)）。
- en: '![f11024](image_fi/501089c11/f11024.png)'
  id: totrans-303
  prefs: []
  type: TYPE_IMG
  zh: '![f11024](image_fi/501089c11/f11024.png)'
- en: 'Figure 11-24: `(v)pshufhw` operation'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: '图 11-24: `(v)pshufhw` 操作'
- en: The 256-bit `vpshufhw` instruction (with a YMM destination register) copies
    two pairs of words at a time—one in the HO 128 bits and one in the LO 128 bits
    of the YMM destination register and 256-bit source locations, as shown in [Figure
    11-25](#figure11-25).
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 256 位的 `vpshufhw` 指令（具有 YMM 目标寄存器）一次复制两对字—一对在 YMM 目标寄存器的高 128 位和一对在 LO 128 位，源位置为
    256 位，如[图 11-25](#figure11-25)所示。
- en: '![f11025](image_fi/501089c11/f11025.png)'
  id: totrans-306
  prefs: []
  type: TYPE_IMG
  zh: '![f11025](image_fi/501089c11/f11025.png)'
- en: 'Figure 11-25: `vpshufhw` operation'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: '图 11-25: `vpshufhw` 操作'
- en: 11.7.4 The shufps and shufpd Instructions
  id: totrans-308
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 11.7.4 shufps 和 shufpd 指令
- en: 'The shuffle instructions (`shufps` and `shufpd`) extract single- or double-precision
    values from the source operands and place them in specified positions in the destination
    operand. The third operand, an 8-bit immediate value, selects which values to
    extract from the source to move into the destination register. The syntax for
    these two instructions is as follows:'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: shuffle 指令（`shufps` 和 `shufpd`）从源操作数中提取单精度或双精度值，并将它们放置到目标操作数的指定位置。第三个操作数，一个
    8 位立即数值，选择从源操作数中提取哪些值并移动到目标寄存器。以下是这两条指令的语法：
- en: '[PRE37]'
  id: totrans-310
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: For the `shufps` instruction, the second source operand is an 8-bit immediate
    value that is actually a four-element array of 2-bit values.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 `shufps` 指令，第二个源操作数是一个 8 位立即数值，实际上是一个包含 2 位值的四元素数组。
- en: imm[8] bits 0 and 1 select a single-precision value from one of the four lanes
    in the XMM[src1/dest] operand to store into lane 0 of the destination operation.
    Bits 2 and 3 select a single-precision value from one of the four lanes in the
    XMM[src1/dest] operand to store into lane 1 of the destination operation (the
    destination operand is also XMM[src1/dest]).
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: imm[8] 位 0 和 1 从 XMM[src1/dest] 操作数的四个通道中选择一个单精度值，并将其存储到目标操作中的通道 0。位 2 和 3 从
    XMM[src1/dest] 操作数的四个通道中选择一个单精度值，并将其存储到目标操作中的通道 1（目标操作数同样为 XMM[src1/dest]）。
- en: imm[8] bits 4 and 5 select a single-precision value from one of the four lanes
    in the XMM[src2]/mem[src2] operand to store into lane 2 of the destination operation.
    Bits 6 and 7 select a single-precision value from one of the four lanes in the
    XMM[src2]/mem[src2] operand to store into lane 3 of the destination operation.
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: imm[8] 位 4 和 5 从 XMM[src2]/mem[src2] 操作数的四个通道中选择一个单精度值，并将其存储到目标操作中的通道 2。位 6
    和 7 从 XMM[src2]/mem[src2] 操作数的四个通道中选择一个单精度值，并将其存储到目标操作中的通道 3。
- en: '[Figure 11-26](#figure11-26) shows the operation of the `shufps` instruction.'
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 11-26](#figure11-26) 显示了 `shufps` 指令的操作。'
- en: '![f11026](image_fi/501089c11/f11026.png)'
  id: totrans-315
  prefs: []
  type: TYPE_IMG
  zh: '![f11026](image_fi/501089c11/f11026.png)'
- en: 'Figure 11-26: `shufps` operation'
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11-26：`shufps` 操作
- en: For example, the instruction
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，指令
- en: '[PRE38]'
  id: totrans-318
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'loads XMM0 with the following single-precision values:'
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 加载 XMM0 寄存器以下的单精度值：
- en: XMM0[0 to 31] from XMM0[0 to 32]
  id: totrans-320
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: XMM0[0 到 31] 来自 XMM0[0 到 32]
- en: XMM0[32 to 63] from XMM0[32 to 63]
  id: totrans-321
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: XMM0[32 到 63] 来自 XMM0[32 到 63]
- en: XMM0[64 to 95] from XMM1[63 to 95]
  id: totrans-322
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: XMM0[64 到 95] 来自 XMM1[63 到 95]
- en: XMM0[96 to 127] from XMM1[96 to 127]
  id: totrans-323
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: XMM0[96 到 127] 来自 XMM1[96 到 127]
- en: If the second operand (XMM[src2]/mem[src2]) is the same as the first operand
    (XMM[src1/dest]), it’s possible to rearrange the four single-precision values
    in the XMM[dest] register (which is probably the source of the instruction name
    *shuffle*).
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 如果第二个操作数（XMM[src2]/mem[src2]）与第一个操作数（XMM[src1/dest]）相同，则可以重新排列 XMM[dest] 寄存器中的四个单精度值（这可能就是指令名称
    *shuffle* 的来源）。
- en: The `shufpd` instruction works similarly, shuffling double-precision values.
    As there are only two double-precision values in an XMM register, it takes only
    a single bit to choose between the values. Likewise, as there are only two double-precision
    values in the destination register, the instruction requires only two (single-bit)
    array elements to choose the destination. As a result, the third operand, the
    imm[8] value, is actually just a 2-bit value; the instruction ignores bits 2 to
    7 in the imm[8] operand. Bit 0 of the imm[8] operand selects either lane 0 and
    bits 0 to 63 (if it is 0) or lane 1 and bits 64 to 127 (if it is 1) from the XMM[src1/dest]
    operand to place into lane 0 and bits 0 to 63 of XMM[dest]. Bit 1 of the imm[8]
    operand selects either lane 0 and bits 0 to 63 (if it is 0) or lane 1 and bits
    64 to 127 (if it is 1) from the XMM[src]/mem[128] operand to place into lane 1
    and bits 64 to 127 of XMM[dest]. [Figure 11-27](#figure11-27) shows this operation.
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: '`shufpd` 指令的工作方式类似，打乱双精度值。由于 XMM 寄存器中只有两个双精度值，因此只需一个位来选择这两个值中的一个。同样，因为目标寄存器中只有两个双精度值，指令只需要两个（单比特）数组元素来选择目标。结果，第三个操作数
    imm[8] 实际上只是一个 2 位值；指令会忽略 imm[8] 操作数中的位 2 到 7。imm[8] 操作数的位 0 选择从 XMM[src1/dest]
    操作数中选择通道 0 和位 0 到 63（如果为 0）或通道 1 和位 64 到 127（如果为 1），并将其放入 XMM[dest] 的通道 0 和位 0
    到 63 中。imm[8] 操作数的位 1 选择从 XMM[src]/mem[128] 操作数中选择通道 0 和位 0 到 63（如果为 0）或通道 1 和位
    64 到 127（如果为 1），并将其放入 XMM[dest] 的通道 1 和位 64 到 127 中。[图 11-27](#figure11-27) 显示了这个操作。'
- en: '![f11027](image_fi/501089c11/f11027.png)'
  id: totrans-326
  prefs: []
  type: TYPE_IMG
  zh: '![f11027](image_fi/501089c11/f11027.png)'
- en: 'Figure 11-27: `shufpd` operation'
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11-27：`shufpd` 操作
- en: 11.7.5 The vshufps and vshufpd Instructions
  id: totrans-328
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 11.7.5 vshufps 和 vshufpd 指令
- en: 'The `vshufps` and `vshufpd` instructions are similar to `shufps` and `shufpd`.
    They allow you to shuffle the values in 128-bit XMM registers or 256-bit YMM registers.^([8](#c11-footnote-8))
    The `vshufps` and `vshufpd` instructions have four operands: a destination XMM
    or YMM register, two source operands (src[1] must be an XMM or a YMM register,
    and src[2] can be an XMM or a YMM register or a 128- or 256-bit memory location),
    and an imm[8] operand. Their syntax is the following:'
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: '`vshufps`和`vshufpd`指令类似于`shufps`和`shufpd`。它们允许你在128位XMM寄存器或256位YMM寄存器中进行值的洗牌。^([8](#c11-footnote-8))
    `vshufps`和`vshufpd`指令有四个操作数：一个目标XMM或YMM寄存器，两个源操作数（src[1]必须是XMM或YMM寄存器，src[2]可以是XMM或YMM寄存器，或者是128位或256位的内存位置），以及一个imm[8]操作数。它们的语法如下：'
- en: '[PRE39]'
  id: totrans-330
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Whereas the SSE shuffle instructions use the destination register as an implicit
    source operand, the AVX shuffle instructions allow you to specify explicit destination
    and source operands (they can all be different, or all the same, or any combination
    thereof).
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 而SSE洗牌指令使用目标寄存器作为隐式源操作数，AVX洗牌指令则允许你指定显式的目标和源操作数（它们可以完全不同，或完全相同，或是任何组合）。
- en: For the 256-bit `vshufps` instructions, the imm[8] operand is an array of four
    2-bit values (bits 0:1, 2:3, 4:5, and 6:7). These 2-bit values select one of four
    single-precision values from the source locations, as described in [Table 11-5](#table11-5).
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 对于256位的`vshufps`指令，imm[8] 操作数是一个包含四个2位值的数组（位0:1, 2:3, 4:5, 和 6:7）。这些2位值从源位置选择四个单精度值中的一个，具体如[表11-5](#table11-5)所示。
- en: 'Table 11-5: `vshufps` Destination Selection'
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 表11-5：`vshufps` 目标选择
- en: '|  | **Destination** | **imm[8] value** |'
  id: totrans-334
  prefs: []
  type: TYPE_TB
  zh: '|  | **目标** | **imm[8] 值** |'
- en: '| --- | --- | --- |'
  id: totrans-335
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| **imm[8] bits** |  | **00** | **01** | **10** | **11** |'
  id: totrans-336
  prefs: []
  type: TYPE_TB
  zh: '| **imm[8] 位** |  | **00** | **01** | **10** | **11** |'
- en: '| --- | --- | --- | --- | --- | --- |'
  id: totrans-337
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- | --- | --- |'
- en: '| 76 54 32 **10** | Dest[0 to 31] | Src[1][0 to 31] | Src[1][32 to 63] | Src[1][64
    to 95] | Src[1][96 to 127] |'
  id: totrans-338
  prefs: []
  type: TYPE_TB
  zh: '| 76 54 32 **10** | 目标[0 到 31] | 源[1][0 到 31] | 源[1][32 到 63] | 源[1][64 到 95]
    | 源[1][96 到 127] |'
- en: '|  | Dest[128 to 159] | Src[1][128 to 159] | Src[1][160 to 191] | Src[1][192
    to 223] | Src[1][224 to 255] |'
  id: totrans-339
  prefs: []
  type: TYPE_TB
  zh: '|  | 目标[128 到 159] | 源[1][128 到 159] | 源[1][160 到 191] | 源[1][192 到 223] |
    源[1][224 到 255] |'
- en: '| 76 54 **32** 10 | Dest[32 to 63] | Src[1][0 to 31] | Src[1][32 to 63] | Src[1][64
    to 95] | Src[1][96 to 127] |'
  id: totrans-340
  prefs: []
  type: TYPE_TB
  zh: '| 76 54 **32** 10 | 目标[32 到 63] | 源[1][0 到 31] | 源[1][32 到 63] | 源[1][64 到
    95] | 源[1][96 到 127] |'
- en: '|  | Dest[160 to 191] | Src[1][128 to 159] | Src[1][160 to 191] | Src[1][192
    to 223] | Src[1][224 to 255] |'
  id: totrans-341
  prefs: []
  type: TYPE_TB
  zh: '|  | 目标[160 到 191] | 源[1][128 到 159] | 源[1][160 到 191] | 源[1][192 到 223] |
    源[1][224 到 255] |'
- en: '| 76 **54** 32 10 | Dest[64 to 95] | Src[2][0 to 31] | Src[2][32 to 63] | Src[2][64
    to 95] | Src[2][96 to 127] |'
  id: totrans-342
  prefs: []
  type: TYPE_TB
  zh: '| 76 **54** 32 10 | 目标[64 到 95] | 源[2][0 到 31] | 源[2][32 到 63] | 源[2][64 到
    95] | 源[2][96 到 127] |'
- en: '|  | Dest[192 to 223] | Src[2][128 to 159] | Src[2][160 to 191] | Src[2][192
    to 223] | Src[2][224 to 255] |'
  id: totrans-343
  prefs: []
  type: TYPE_TB
  zh: '|  | 目标[192 到 223] | 源[2][128 到 159] | 源[2][160 到 191] | 源[2][192 到 223] |
    源[2][224 到 255] |'
- en: '| **76** 54 32 10 | Dest[96 to 127] | Src[2][0 to 31] | Src[2][32 to 63] |
    Src[2][64 to 95] | Src[2][96 to 127] |'
  id: totrans-344
  prefs: []
  type: TYPE_TB
  zh: '| **76** 54 32 10 | 目标[96 到 127] | 源[2][0 到 31] | 源[2][32 到 63] | 源[2][64 到
    95] | 源[2][96 到 127] |'
- en: '|  | Dest[224 to 255] | Src[2][128 to 159] | Src[2][160 to 191] | Src[2][192
    to 223] | Src[2][224 to 255] |'
  id: totrans-345
  prefs: []
  type: TYPE_TB
  zh: '|  | 目标[224 到 255] | 源[2][128 到 159] | 源[2][160 到 191] | 源[2][192 到 223] |
    源[2][224 到 255] |'
- en: If both source operands are the same, you can shuffle around the single-precision
    values in any order you choose (and if the destination and both source operands
    are the same, you can arbitrarily shuffle the dwords within that register).
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 如果两个源操作数相同，你可以随意重新排列单精度值的顺序（如果目标和两个源操作数相同，你可以在该寄存器内任意重新排列双字）。
- en: The `vshufps` instruction also allows you to specify XMM and 128-bit memory
    operands. In this form, it behaves quite similarly to the `shufps` instruction
    except that you get to specify two different 128-bit source operands (rather than
    only one 128-bit source operand), and it zeroes the HO 128 bits of the corresponding
    YMM register. If the destination operand is different from the first source operand,
    this can be useful. If the `vshufps`’s first source operand is the same XMM register
    as the destination operand, you should use the `shufps` instruction as its machine
    encoding is shorter.
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: '`vshufps`指令还允许你指定XMM和128位内存操作数。在这种形式下，它的行为与`shufps`指令非常相似，不同之处在于你可以指定两个不同的128位源操作数（而不是只有一个128位源操作数），并且它会将对应的YMM寄存器的高128位清零。如果目标操作数与第一个源操作数不同，这种方式可能会很有用。如果`vshufps`的第一个源操作数与目标操作数相同，应该使用`shufps`指令，因为其机器编码更短。'
- en: The `vshufpd` instruction is an extension of `shufpd` to 256 bits (plus the
    addition of a second source operand). As there are four double-precision values
    present in a 256-bit YMM register, `vshufpd` needs 4 bits to select the source
    indexes (rather than the 2 bits that `shufpd` requires). [Table 11-6](#table11-6)
    describes how `vshufpd` copies the data from the source operands to the destination
    operand.
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: '`vshufpd` 指令是 `shufpd` 指令的扩展，支持 256 位（并增加了第二个源操作数）。由于 256 位 YMM 寄存器中包含四个双精度浮点数值，`vshufpd`
    需要 4 位来选择源索引（而 `shufpd` 只需 2 位）。[表 11-6](#table11-6) 描述了 `vshufpd` 如何将数据从源操作数复制到目标操作数。'
- en: 'Table 11-6: `vshufpd` Destination Selection'
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 表 11-6：`vshufpd` 目标选择
- en: '|  | **Destination** | **imm[8] value** |'
  id: totrans-350
  prefs: []
  type: TYPE_TB
  zh: '|  | **目标** | **imm[8] 值** |'
- en: '| --- | --- | --- |'
  id: totrans-351
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| **imm[8] bits** |  | **0** | **1** |'
  id: totrans-352
  prefs: []
  type: TYPE_TB
  zh: '| **imm[8] 位** |  | **0** | **1** |'
- en: '| --- | --- | --- | --- |'
  id: totrans-353
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- |'
- en: '| 7654 3 2 1 **0** | Dest[0 to 63] | Src[1][0 to 63] | Src[1][64 to 127] |'
  id: totrans-354
  prefs: []
  type: TYPE_TB
  zh: '| 7654 3 2 1 **0** | Dest[0 to 63] | Src[1][0 to 63] | Src[1][64 to 127] |'
- en: '| 7654 3 2 **1** 0 | Dest[64 to 127] | Src[2][0 to 63] | Src[2][64 to 127]
    |'
  id: totrans-355
  prefs: []
  type: TYPE_TB
  zh: '| 7654 3 2 **1** 0 | Dest[64 to 127] | Src[2][0 to 63] | Src[2][64 to 127]
    |'
- en: '| 7654 3 **2** 1 0 | Dest[128 to 191] | Src[1][128 to 191] | Src[1][192 to
    255] |'
  id: totrans-356
  prefs: []
  type: TYPE_TB
  zh: '| 7654 3 **2** 1 0 | Dest[128 to 191] | Src[1][128 to 191] | Src[1][192 to
    255] |'
- en: '| 7654 **3** 2 1 0 | Dest[192 to 255] | Src[2][128 to 191] | Src[2][192 to
    255] |'
  id: totrans-357
  prefs: []
  type: TYPE_TB
  zh: '| 7654 **3** 2 1 0 | Dest[192 to 255] | Src[2][128 to 191] | Src[2][192 to
    255] |'
- en: Like the `vshufps` instruction, `vshufpd` also allows you to specify XMM registers
    if you want a three-operand version of `shufpd`.
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: 与 `vshufps` 指令类似，`vshufpd` 也允许你指定 XMM 寄存器，如果你想要 `shufpd` 的三操作数版本。
- en: 11.7.6 The (v)unpcklps, (v)unpckhps, (v)unpcklpd, and (v)unpckhpd Instructions
  id: totrans-359
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 11.7.6 (v)unpcklps、(v)unpckhps、(v)unpcklpd 和 (v)unpckhpd 指令
- en: The unpack (and merge) instructions are a simplified variant of the shuffle
    instructions. These instructions copy single- and double-precision values from
    fixed locations in their source operands and insert those values into fixed locations
    in the destination operand. They are, essentially, shuffle instructions without
    the imm[8] operand and with fixed shuffle patterns.
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 解包（和合并）指令是洗牌指令的简化变种。这些指令将单精度和双精度浮点数值从源操作数的固定位置复制，并将这些值插入到目标操作数的固定位置。它们本质上是没有
    imm[8] 操作数并且具有固定洗牌模式的洗牌指令。
- en: 'The `unpcklps` and `unpckhps` instructions choose half their single-precision
    operands from one of two sources, merge these values (interleaving them), and
    then store the merged result into the destination operand (which is the same as
    the first source operand). The syntax for these two instructions is as follows:'
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: '`unpcklps` 和 `unpckhps` 指令从两个源中选择它们各自的单精度操作数的一半，将这些值合并（交错排列），然后将合并的结果存储到目标操作数中（目标操作数与第一个源操作数相同）。这两个指令的语法如下：'
- en: '[PRE40]'
  id: totrans-362
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: The XMM[dest] operand serves as both the first source operand and the destination
    operand. The XMM[src]/mem[128] operand is the second source operand.
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: XMM[dest] 操作数既作为第一个源操作数，也作为目标操作数。XMM[src]/mem[128] 操作数是第二个源操作数。
- en: The difference between the two is the way they select their source operands.
    The `unpcklps` instruction copies the two LO single-precision values from the
    source operand to bit positions 32 to 63 (dword 1) and 96 to 127 (dword 3). It
    leaves dword 0 in the destination operand alone and copies the value originally
    in dword 1 to dword 2 in the destination. [Figure 11-28](#figure11-28) diagrams
    this operation.
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: 两者的区别在于它们选择源操作数的方式。`unpcklps` 指令将两个低位单精度浮点数值从源操作数复制到位位置 32 到 63（dword 1）和 96
    到 127（dword 3）。它保留目标操作数中的 dword 0 不变，并将原本在 dword 1 中的值复制到目标操作数的 dword 2 中。[图 11-28](#figure11-28)
    展示了此操作。
- en: '![f11028](image_fi/501089c11/f11028.png)'
  id: totrans-365
  prefs: []
  type: TYPE_IMG
  zh: '![f11028](image_fi/501089c11/f11028.png)'
- en: 'Figure 11-28: `unpcklps` instruction operation'
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11-28：`unpcklps` 指令操作
- en: The `unpckhps` instruction copies the two HO single-precision values from the
    two sources to the destination register, as shown in [Figure 11-29](#figure11-29).
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: '`unpckhps` 指令将两个单精度浮点数值从两个源操作数复制到目标寄存器，如 [图 11-29](#figure11-29) 所示。'
- en: '![f11029](image_fi/501089c11/f11029.png)'
  id: totrans-368
  prefs: []
  type: TYPE_IMG
  zh: '![f11029](image_fi/501089c11/f11029.png)'
- en: 'Figure 11-29: `unpckhps` instruction operation'
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11-29：`unpckhps` 指令操作
- en: The `unpcklpd` and `unpckhpd` instructions do the same thing as `unpcklps` and
    `unpckhps` except, of course, they operate on double-precision values rather than
    single-precision values. Figures 11-30 and 11-31 show the operation of these two
    instructions.
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: '`unpcklpd` 和 `unpckhpd` 指令的功能与 `unpcklps` 和 `unpckhps` 相同，只不过它们处理的是双精度浮点数值，而不是单精度浮点数值。图
    11-30 和 11-31 展示了这两个指令的操作。'
- en: '![f11030](image_fi/501089c11/f11030.png)'
  id: totrans-371
  prefs: []
  type: TYPE_IMG
  zh: '![f11030](image_fi/501089c11/f11030.png)'
- en: 'Figure 11-30: `unpcklpd` instruction operation'
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: 图11-30：`unpcklpd`指令操作
- en: '![f11031](image_fi/501089c11/f11031.png)'
  id: totrans-373
  prefs: []
  type: TYPE_IMG
  zh: '![f11031](image_fi/501089c11/f11031.png)'
- en: 'Figure 11-31: `unpckhpd` instruction operation'
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: 图11-31：`unpckhpd`指令操作
- en: 'The `vunpcklps`, `vunpckhps`, `vunpcklpd`, and `vunpckhpd` instructions have
    the following syntax:'
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: '`vunpcklps`、`vunpckhps`、`vunpcklpd`和`vunpckhpd`指令的语法如下：'
- en: '[PRE41]'
  id: totrans-376
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'They work similarly to the non-`v` variants, with a couple of differences:'
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: 它们的工作原理与非`v`变种相似，存在一些差异：
- en: The AVX variants support using the YMM registers as well as the XMM registers.
  id: totrans-378
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: AVX变种支持使用YMM寄存器和XMM寄存器。
- en: The AVX variants require three operands. The first (destination) and second
    (source[1]) operands must be XMM or YMM registers. The third (source[2]) operand
    can be an XMM or a YMM register or a 128- or 256-bit memory location. The two-operand
    form is just a special case of the three-operand form, where the first and second
    operands specify the same register name.
  id: totrans-379
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: AVX变种需要三个操作数。第一个（目标）和第二个（源[1]）操作数必须是XMM或YMM寄存器。第三个（源[2]）操作数可以是XMM或YMM寄存器，或者是128位或256位内存位置。两操作数形式只是三操作数形式的一种特殊情况，其中第一个和第二个操作数指定相同的寄存器名称。
- en: The 128-bit variants zero out the HO bits of the YMM register rather than leaving
    those bits unchanged.
  id: totrans-380
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 128位变种会将YMM寄存器的HO位清零，而不是让这些位保持不变。
- en: 'Of course, the AVX instructions with the YMM registers interleave twice as
    many single- or double-precision values. The interleaving extension happens in
    the intuitive way, with `vunpcklps` ([Figure 11-32](#figure11-32)):'
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，带有YMM寄存器的AVX指令交错处理的单精度或双精度值的数量是原来的两倍。交错扩展按直观方式发生，`vunpcklps`（[图11-32](#figure11-32)）如下：
- en: The single-precision values in source[1], bits 0 to 31, are first written to
    bits 0 to 31 of the destination.
  id: totrans-382
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 源[1]中的单精度值（位0到31）首先被写入目标的位0到31。
- en: The single-precision values in source[2], bits 0 to 31, are written to bits
    32 to 63 of the destination.
  id: totrans-383
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 源[2]中的单精度值（位0到31）被写入目标的位32到63。
- en: The single-precision values in source[1], bits 32 to 63, are written to bits
    64 to 95 of the destination.
  id: totrans-384
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 源[1]中的单精度值（位32到63）被写入目标的位64到95。
- en: The single-precision values in source[2], bits 32 to 63, are written to bits
    96 to 127 of the destination.
  id: totrans-385
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 源[2]中的单精度值（位32到63）被写入目标的位96到127。
- en: The single-precision values in source[1], bits 128 to 159, are first written
    to bits 128 to 159 of the destination.
  id: totrans-386
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 源[1]中的单精度值（位128到159）首先被写入目标的位128到159。
- en: The single-precision values in source[2], bits 128 to 159, are written to bits
    160 to 191 of the destination.
  id: totrans-387
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 源[2]中的单精度值（位128到159）被写入目标的位160到191。
- en: The single-precision values in source[1], bits 160 to 191, are written to bits
    192 to 223 of the destination.
  id: totrans-388
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 源[1]中的单精度值（位160到191）被写入目标的位192到223。
- en: The single-precision values in source[2], bits 160 to 191, are written to bits
    224 to 256 of the destination.
  id: totrans-389
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 源[2]中的单精度值（位160到191）被写入目标的位224到256。
- en: '![f11032](image_fi/501089c11/f11032.png)'
  id: totrans-390
  prefs: []
  type: TYPE_IMG
  zh: '![f11032](image_fi/501089c11/f11032.png)'
- en: 'Figure 11-32: `vunpcklps` instruction operation'
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: 图11-32：`vunpcklps`指令操作
- en: 'The `vunpckhps` instruction ([Figure 11-33](#figure11-33)) does the following:'
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
  zh: '`vunpckhps`指令（[图11-33](#figure11-33)）执行以下操作：'
- en: The single-precision values in source[1], bits 64 to 95, are first written to
    bits 0 to 31 of the destination.
  id: totrans-393
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 源[1]中的单精度值（位64到95）首先被写入目标的位0到31。
- en: The single-precision values in source[2], bits 64 to 95, are written to bits
    32 to 63 of the destination.
  id: totrans-394
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 源[2]中的单精度值（位64到95）被写入目标的位32到63。
- en: The single-precision values in source[1], bits 96 to 127, are written to bits
    64 to 95 of the destination.
  id: totrans-395
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 源[1]中的单精度值（位96到127）被写入目标的位64到95。
- en: The single-precision values in source[2], bits 96 to 127, are written to bits
    96 to 127 of the destination.
  id: totrans-396
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 源[2]中的单精度值（位96到127）被写入目标的位96到127。
- en: '![f11033](image_fi/501089c11/f11033.png)'
  id: totrans-397
  prefs: []
  type: TYPE_IMG
  zh: '![f11033](image_fi/501089c11/f11033.png)'
- en: 'Figure 11-33: `vunpckhps` instruction operation'
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
  zh: 图11-33：`vunpckhps`指令操作
- en: Likewise, `vunpcklpd` and `vunpckhpd` move double-precision values.
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，`vunpcklpd`和`vunpckhpd`用于移动双精度值。
- en: 11.7.7 The Integer Unpack Instructions
  id: totrans-400
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 11.7.7 整数解包指令
- en: The `punpck*` instructions provide a set of integer unpack instructions to complement
    the floating-point variants. These instructions appear in [Table 11-7](#table11-7).
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
  zh: '`punpck*`指令提供了一组整数解包指令，以补充浮点变种。这些指令出现在[表11-7](#table11-7)中。'
- en: 'Table 11-7: Integer Unpack Instructions'
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
  zh: 表11-7：整数解包指令
- en: '| Instruction | Description |'
  id: totrans-403
  prefs: []
  type: TYPE_TB
  zh: '| 指令 | 描述 |'
- en: '| --- | --- |'
  id: totrans-404
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `punpcklbw` | Unpacks low bytes to words |'
  id: totrans-405
  prefs: []
  type: TYPE_TB
  zh: '| `punpcklbw` | 解包低字节为字 |'
- en: '| `punpckhbw` | Unpacks high bytes to words |'
  id: totrans-406
  prefs: []
  type: TYPE_TB
  zh: '| `punpckhbw` | 解包高字节为字 |'
- en: '| `punpcklwd` | Unpacks low words to dwords |'
  id: totrans-407
  prefs: []
  type: TYPE_TB
  zh: '| `punpcklwd` | 解包低字为双字 |'
- en: '| `punpckhwd` | Unpacks high words to dwords |'
  id: totrans-408
  prefs: []
  type: TYPE_TB
  zh: '| `punpckhwd` | 解包高字为双字 |'
- en: '| `punpckldq` | Unpacks low dwords to qwords |'
  id: totrans-409
  prefs: []
  type: TYPE_TB
  zh: '| `punpckldq` | 解包低双字为四字 |'
- en: '| `punpckhdq` | Unpacks high dwords to qwords |'
  id: totrans-410
  prefs: []
  type: TYPE_TB
  zh: '| `punpckhdq` | 解包高双字为四字 |'
- en: '| `punpcklqdq` | Unpacks low qwords to owords (double qwords) |'
  id: totrans-411
  prefs: []
  type: TYPE_TB
  zh: '| `punpcklqdq` | 解包低四字为双四字（双四字） |'
- en: '| `punpckhqdq` | Unpacks high qwords to owords (double qwords) |'
  id: totrans-412
  prefs: []
  type: TYPE_TB
  zh: '| `punpckhqdq` | 解包高四字为双四字（双四字） |'
- en: 11.7.7.1 The punpck* Instructions
  id: totrans-413
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 11.7.7.1 punpck* 指令
- en: 'The `punpck*` instructions extract half the bytes, words, dwords, or qwords
    from two different sources and merge these values into a destination SSE register.
    The syntax for these instructions is shown here:'
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
  zh: '`punpck*` 指令从两个不同的源中提取一半的字节、字、双字或四字，并将这些值合并到目标 SSE 寄存器中。以下是这些指令的语法：'
- en: '[PRE42]'
  id: totrans-415
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: Figures 11- 34 through 11-41 show the data transfers for each of these instructions.
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11-34 至 11-41 展示了这些指令的每个数据传输。
- en: '![f11034](image_fi/501089c11/f11034.png)'
  id: totrans-417
  prefs: []
  type: TYPE_IMG
  zh: '![f11034](image_fi/501089c11/f11034.png)'
- en: 'Figure 11-34: `punpcklbw` instruction operation'
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
  zh: '图 11-34: `punpcklbw` 指令操作'
- en: '![f11035](image_fi/501089c11/f11035.png)'
  id: totrans-419
  prefs: []
  type: TYPE_IMG
  zh: '![f11035](image_fi/501089c11/f11035.png)'
- en: 'Figure 11-35: `punpckhbw` operation'
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
  zh: '图 11-35: `punpckhbw` 操作'
- en: '![f11036](image_fi/501089c11/f11036.png)'
  id: totrans-421
  prefs: []
  type: TYPE_IMG
  zh: '![f11036](image_fi/501089c11/f11036.png)'
- en: 'Figure 11-36: `punpcklwd` operation'
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
  zh: '图 11-36: `punpcklwd` 操作'
- en: '![f11037](image_fi/501089c11/f11037.png)'
  id: totrans-423
  prefs: []
  type: TYPE_IMG
  zh: '![f11037](image_fi/501089c11/f11037.png)'
- en: 'Figure 11-37: `punpckhwd` operation'
  id: totrans-424
  prefs: []
  type: TYPE_NORMAL
  zh: '图 11-37: `punpckhwd` 操作'
- en: '![f11038](image_fi/501089c11/f11038.png)'
  id: totrans-425
  prefs: []
  type: TYPE_IMG
  zh: '![f11038](image_fi/501089c11/f11038.png)'
- en: 'Figure 11-38: `punpckldq` operation'
  id: totrans-426
  prefs: []
  type: TYPE_NORMAL
  zh: '图 11-38: `punpckldq` 操作'
- en: '![f11039](image_fi/501089c11/f11039.png)'
  id: totrans-427
  prefs: []
  type: TYPE_IMG
  zh: '![f11039](image_fi/501089c11/f11039.png)'
- en: 'Figure 11-39: `punpckhdq` operation'
  id: totrans-428
  prefs: []
  type: TYPE_NORMAL
  zh: '图 11-39: `punpckhdq` 操作'
- en: '![f11040](image_fi/501089c11/f11040.png)'
  id: totrans-429
  prefs: []
  type: TYPE_IMG
  zh: '![f11040](image_fi/501089c11/f11040.png)'
- en: 'Figure 11-40: `punpcklqdq` operation'
  id: totrans-430
  prefs: []
  type: TYPE_NORMAL
  zh: '图 11-40: `punpcklqdq` 操作'
- en: '![f11041](image_fi/501089c11/f11041.png)'
  id: totrans-431
  prefs: []
  type: TYPE_IMG
  zh: '![f11041](image_fi/501089c11/f11041.png)'
- en: 'Figure 11-41: `punpckhqdq` operation'
  id: totrans-432
  prefs: []
  type: TYPE_NORMAL
  zh: '图 11-41: `punpckhqdq` 操作'
- en: 11.7.7.2 The vpunpck* SSE Instructions
  id: totrans-433
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 11.7.7.2 vpunpck* SSE 指令
- en: The AVX `vpunpck*` instructions provide a set of AVX integer unpack instructions
    to complement the SSE variants. These instructions appear in [Table 11-8](#table11-8).
  id: totrans-434
  prefs: []
  type: TYPE_NORMAL
  zh: AVX `vpunpck*` 指令提供了一组 AVX 整数解包指令，以补充 SSE 变体。这些指令出现在 [表 11-8](#table11-8) 中。
- en: 'Table 11-8: AVX Integer Unpack Instructions'
  id: totrans-435
  prefs: []
  type: TYPE_NORMAL
  zh: '表 11-8: AVX 整数解包指令'
- en: '| **Instruction** | **Description** |'
  id: totrans-436
  prefs: []
  type: TYPE_TB
  zh: '| **指令** | **描述** |'
- en: '| --- | --- |'
  id: totrans-437
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `vpunpcklbw` | Unpacks low bytes to words |'
  id: totrans-438
  prefs: []
  type: TYPE_TB
  zh: '| `vpunpcklbw` | 解包低字节为字 |'
- en: '| `vpunpckhbw` | Unpacks high bytes to words |'
  id: totrans-439
  prefs: []
  type: TYPE_TB
  zh: '| `vpunpckhbw` | 解包高字节为字 |'
- en: '| `vpunpcklwd` | Unpacks low words to dwords |'
  id: totrans-440
  prefs: []
  type: TYPE_TB
  zh: '| `vpunpcklwd` | 解包低字为双字 |'
- en: '| `vpunpckhwd` | Unpacks high words to dwords |'
  id: totrans-441
  prefs: []
  type: TYPE_TB
  zh: '| `vpunpckhwd` | 解包高字为双字 |'
- en: '| `vpunpckldq` | Unpacks low dwords to qwords |'
  id: totrans-442
  prefs: []
  type: TYPE_TB
  zh: '| `vpunpckldq` | 解包低双字为四字 |'
- en: '| `vpunpckhdq` | Unpacks high dwords to qwords |'
  id: totrans-443
  prefs: []
  type: TYPE_TB
  zh: '| `vpunpckhdq` | 解包高双字为四字 |'
- en: '| `vpunpcklqdq` | Unpacks low qwords to owords (double qwords) |'
  id: totrans-444
  prefs: []
  type: TYPE_TB
  zh: '| `vpunpcklqdq` | 解包低四字为双四字（双四字） |'
- en: '| `vpunpckhqdq` | Unpacks high qwords to owords (double qwords) |'
  id: totrans-445
  prefs: []
  type: TYPE_TB
  zh: '| `vpunpckhqdq` | 解包高四字为双四字（双四字） |'
- en: 'The `vpunpck*` instructions extract half the bytes, words, dwords, or qwords
    from two different sources and merge these values into a destination AVX or SSE
    register. Here is the syntax for the SSE forms of these instructions:'
  id: totrans-446
  prefs: []
  type: TYPE_NORMAL
  zh: '`vpunpck*` 指令从两个不同的源中提取一半的字节、字、双字或四字，并将这些值合并到目标 AVX 或 SSE 寄存器中。以下是这些指令的 SSE
    形式语法：'
- en: '[PRE43]'
  id: totrans-447
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: Functionally, the only difference between these AVX instructions (`vunpck*`)
    and the SSE (`unpck*`) instructions is that the SSE variants leave the upper bits
    of the YMM AVX registers (bits 128 to 255) unchanged, whereas the AVX variants
    zero-extend the result to 256 bits. See Figures 11-34 through 11-41 for a description
    of the operation of these instructions.
  id: totrans-448
  prefs: []
  type: TYPE_NORMAL
  zh: 从功能上看，AVX 指令（`vunpck*`）和 SSE 指令（`unpck*`）之间的唯一区别是，SSE 变体保持 YMM AVX 寄存器的上半部分（位
    128 到 255）不变，而 AVX 变体将结果零扩展到 256 位。有关这些指令操作的描述，请参见图 11-34 至 11-41。
- en: 11.7.7.3 The vpunpck* AVX Instructions
  id: totrans-449
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 11.7.7.3 vpunpck* AVX 指令
- en: 'The AVX `vunpck*` instructions also support the use of the AVX YMM registers,
    in which case the unpack and merge operation extends from 128 bits to 256 bits.
    The syntax for these instructions is as follows:'
  id: totrans-450
  prefs: []
  type: TYPE_NORMAL
  zh: AVX `vunpck*` 指令还支持使用 AVX YMM 寄存器，在这种情况下，解包和合并操作从 128 位扩展到 256 位。以下是这些指令的语法：
- en: '[PRE44]'
  id: totrans-451
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 11.7.8 The (v)pextrb, (v)pextrw, (v)pextrd, and (v)pextrq Instructions
  id: totrans-452
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 11.7.8 `(v)pextrb`、`(v)pextrw`、`(v)pextrd` 和 `(v)pextrq` 指令
- en: 'The `(v)pextrb`, `(v)pextrw`, `(v)pextrd`, and `(v)pextrq` instructions extract
    a byte, word, dword, or qword from a 128-bit XMM register and copy this data to
    a general-purpose register or memory location. The syntax for these instructions
    is the following:'
  id: totrans-453
  prefs: []
  type: TYPE_NORMAL
  zh: '`(v)pextrb`、`(v)pextrw`、`(v)pextrd` 和 `(v)pextrq` 指令从 128 位 XMM 寄存器中提取一个字节、字、双字或四字，并将这些数据复制到通用寄存器或内存位置。这些指令的语法如下：'
- en: '[PRE45]'
  id: totrans-454
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: The byte and word instructions expect a 32- or 64-bit general-purpose register
    as their destination (first operand) or a memory location that is the same size
    as the instruction (that is, `pextrb` expects a byte-sized memory operand, `pextrw`
    expects a word-sized operand, and so on). The source (second) operand is a 128-bit
    XMM register. The index (third) operand is an 8-bit immediate value that specifies
    an index (lane number). These instructions fetch the byte, word, dword, or qword
    in the lane specified by the 8-bit immediate value and copy that value into the
    destination operand. The double-word and quad-word variants require a 32-bit or
    64-bit general-purpose register, respectively. If the destination operand is a
    32- or 64-bit general-purpose register, the instruction zero-extends the value
    to 32 or 64 bits, if necessary.
  id: totrans-455
  prefs: []
  type: TYPE_NORMAL
  zh: 字节和字指令期望 32 位或 64 位的通用寄存器作为目标（第一个）操作数，或者一个与指令大小相同的内存位置（即，`pextrb` 期望一个字节大小的内存操作数，`pextrw`
    期望一个字大小的操作数，以此类推）。源（第二）操作数是一个 128 位的 XMM 寄存器。索引（第三）操作数是一个 8 位的立即数，用来指定索引（通道号）。这些指令从由
    8 位立即数指定的通道中提取字节、字、双字或四字，并将该值复制到目标操作数中。双字和四字变体分别需要 32 位或 64 位的通用寄存器。如果目标操作数是 32
    位或 64 位的通用寄存器，则指令会根据需要将值扩展为 32 位或 64 位。
- en: 11.7.9 The (v)pinsrb, (v)pinsrw, (v)pinsrd, and (v)pinsrq Instructions
  id: totrans-456
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 11.7.9 `(v)pinsrb`、`(v)pinsrw`、`(v)pinsrd` 和 `(v)pinsrq` 指令
- en: The `(v)pinsr{b,w,d,q}` instructions take a byte, word, dword, or qword from
    a general-purpose register or memory location and store that data to a lane of
    an XMM register. The syntax for these instructions is the following:^([9](#c11-footnote-9))
  id: totrans-457
  prefs: []
  type: TYPE_NORMAL
  zh: '`(v)pinsr{b,w,d,q}` 指令从通用寄存器或内存位置提取一个字节、字、双字或四字，并将该数据存储到 XMM 寄存器的一个通道中。这些指令的语法如下：^([9](#c11-footnote-9))'
- en: '[PRE46]'
  id: totrans-458
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: The destination (first) operand is a 128-bit XMM register. The `pinsr*` instructions
    expect a memory location or a 32-bit general-purpose register as their source
    (second) operand (except the `pinsrq` instructions, which require a 64-bit register).
    The index (third) operand is an 8-bit immediate value that specifies an index
    (lane number).
  id: totrans-459
  prefs: []
  type: TYPE_NORMAL
  zh: 目标（第一个）操作数是一个 128 位的 XMM 寄存器。`pinsr*` 指令期望内存位置或 32 位通用寄存器作为其源（第二）操作数（除了 `pinsrq`
    指令，它们需要一个 64 位寄存器）。索引（第三）操作数是一个 8 位的立即数，用来指定索引（通道号）。
- en: These instructions fetch a byte, word, dword, or qword from the general-purpose
    register or memory location and copy that to the lane in the XMM register specified
    by the 8-bit immediate value. The `pinsr{b,w,d,q}` instructions leave any HO bits
    in the underlying YMM register unchanged (if applicable).
  id: totrans-460
  prefs: []
  type: TYPE_NORMAL
  zh: 这些指令从通用寄存器或内存位置提取一个字节、字、双字或四字，并将其复制到由 8 位立即数指定的 XMM 寄存器中的通道。这些 `pinsr{b,w,d,q}`
    指令保持底层 YMM 寄存器中的任何高位（HO）位不变（如果适用）。
- en: The `vpinsr{b,w,d,q}` instructions copy the data from the XMM source register
    into the destination register and then copy the byte, word, dword, or quad word
    to the specified location in the destination register. These instructions zero-extend
    the value throughout the HO bits of the underlying YMM register.
  id: totrans-461
  prefs: []
  type: TYPE_NORMAL
  zh: '`vpinsr{b,w,d,q}` 指令将数据从 XMM 源寄存器复制到目标寄存器，然后将字节、字、双字或四字复制到目标寄存器中指定的位置。这些指令会将值在底层
    YMM 寄存器的高位（HO）扩展为零。'
- en: 11.7.10 The (v)extractps and (v)insertps Instructions
  id: totrans-462
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 11.7.10 `(v)extractps` 和 `(v)insertps` 指令
- en: 'The `extractps` and `vextractps` instructions are functionally equivalent to
    `pextrd` and `vpextrd`. They extract a 32-bit (single-precision floating-point)
    value from an XMM register and move it into a 32-bit general-purpose register
    or a 32-bit memory location. The syntax for the `(v)extractps` instructions is
    shown here:'
  id: totrans-463
  prefs: []
  type: TYPE_NORMAL
  zh: '`extractps` 和 `vextractps` 指令在功能上等同于 `pextrd` 和 `vpextrd`。它们从 XMM 寄存器中提取一个
    32 位（单精度浮点数）值，并将其移动到一个 32 位的通用寄存器或 32 位的内存位置。这些 `(v)extractps` 指令的语法如下所示：'
- en: '[PRE47]'
  id: totrans-464
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'The `insertps` and `vinsertps` instructions insert a 32-bit floating-point
    value into an XMM register and, optionally, zero out other lanes in the XMM register.
    The syntax for these instructions is as follows:'
  id: totrans-465
  prefs: []
  type: TYPE_NORMAL
  zh: '`insertps`和`vinsertps`指令将一个32位浮点值插入到XMM寄存器中，并可选择性地清除XMM寄存器中的其他通道。此类指令的语法如下：'
- en: '[PRE48]'
  id: totrans-466
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: For the `insertps` and `vinsertps` instructions, the imm[8] operand has the
    fields listed in [Table 11-9](#table11-9).
  id: totrans-467
  prefs: []
  type: TYPE_NORMAL
  zh: 对于`insertps`和`vinsertps`指令，imm[8]操作数包含在[表11-9](#table11-9)中列出的字段。
- en: 'Table 11-9: imm[8] Bit Fields for `insertps` and `vinsertps` Instructions'
  id: totrans-468
  prefs: []
  type: TYPE_NORMAL
  zh: 表11-9：`insertps`和`vinsertps`指令的imm[8]位字段
- en: '| **Bit(s)** | **Meaning** |'
  id: totrans-469
  prefs: []
  type: TYPE_TB
  zh: '| **位(bit)** | **含义** |'
- en: '| --- | --- |'
  id: totrans-470
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| 6 to 7 | (Only if the source operand is an XMM register): Selects the 32-bit
    lane from the source XMM register (0, 1, 2, or 3). If the source operand is a
    32-bit memory location, the instruction ignores this field and uses the full 32
    bits from memory. |'
  id: totrans-471
  prefs: []
  type: TYPE_TB
  zh: '| 6到7 | （仅当源操作数是XMM寄存器时）：从源XMM寄存器中选择32位通道（0、1、2或3）。如果源操作数是32位内存位置，指令将忽略此字段并使用内存中的完整32位数据。
    |'
- en: '| 4 to 5 | Specifies the lane in the destination XMM register in which to store
    the single-precision value. |'
  id: totrans-472
  prefs: []
  type: TYPE_TB
  zh: '| 4到5 | 指定目标XMM寄存器中存储单精度值的通道。 |'
- en: '| 3 | If set, zeroes lane 3 of XMM[dest]. |'
  id: totrans-473
  prefs: []
  type: TYPE_TB
  zh: '| 3 | 如果设置，清零XMM[dest]的第3通道。 |'
- en: '| 2 | If set, zeroes lane 2 of XMM[dest]. |'
  id: totrans-474
  prefs: []
  type: TYPE_TB
  zh: '| 2 | 如果设置，清零XMM[dest]的第2通道。 |'
- en: '| 1 | If set, zeroes lane 1 of XMM[dest]. |'
  id: totrans-475
  prefs: []
  type: TYPE_TB
  zh: '| 1 | 如果设置，清零XMM[dest]的第1通道。 |'
- en: '| 0 | If set, zeroes lane 0 of XMM[dest]. |'
  id: totrans-476
  prefs: []
  type: TYPE_TB
  zh: '| 0 | 如果设置，清零XMM[dest]的第0通道。 |'
- en: On CPUs with the AVX extensions, `insertps` does not modify the upper bits of
    the YMM registers; `vinsertps` zeroes the upper bits.
  id: totrans-477
  prefs: []
  type: TYPE_NORMAL
  zh: 在具有AVX扩展的CPU上，`insertps`不修改YMM寄存器的高位；`vinsertps`会清零高位。
- en: The `vinsertps` instruction first copies the XMM[src1] register to XMM[dest]
    before performing the insertion operation. The HO bits of the corresponding YMM
    register are set to 0.
  id: totrans-478
  prefs: []
  type: TYPE_NORMAL
  zh: '`vinsertps`指令首先将XMM[src1]寄存器复制到XMM[dest]，然后执行插入操作。对应YMM寄存器的高位（HO位）被设置为0。'
- en: The x86-64 does not provide `(v)extractpd` or `(v)insertpd` instructions.
  id: totrans-479
  prefs: []
  type: TYPE_NORMAL
  zh: x86-64架构不提供`(v)extractpd`或`(v)insertpd`指令。
- en: 11.8 SIMD Arithmetic and Logical Operations
  id: totrans-480
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 11.8 SIMD算术和逻辑操作
- en: The SSE and AVX instruction set extensions provide a variety of scalar and vector
    arithmetic and logical operations.
  id: totrans-481
  prefs: []
  type: TYPE_NORMAL
  zh: SSE和AVX指令集扩展提供了多种标量和向量的算术与逻辑操作。
- en: “SSE Floating-Point Arithmetic” in Chapter 6 has already covered floating-point
    arithmetic using the scalar SSE instruction set, so this section does not repeat
    that discussion. Instead, this section covers the *vector* (or *packed*) arithmetic
    and logical instructions.
  id: totrans-482
  prefs: []
  type: TYPE_NORMAL
  zh: 第6章中的“SSE浮点运算”已经讨论了使用标量SSE指令集进行的浮点运算，因此本节不再重复这一讨论。相反，本节将讨论*向量*（或*打包*）算术和逻辑指令。
- en: The vector instructions perform multiple operations in parallel on the different
    data lanes in an SSE or AVX register. Given two source operands, a typical SSE
    instruction will calculate two double-precision floating-point results, two quad-word
    integer calculations, four single-precision floating-point operations, four double-word
    integer calculations, eight word integer calculations, or sixteen byte calculations,
    simultaneously. The AVX registers (YMM) double the number of lanes and therefore
    double the number of concurrent calculations.
  id: totrans-483
  prefs: []
  type: TYPE_NORMAL
  zh: 向量指令在SSE或AVX寄存器中的不同数据通道上并行执行多个操作。给定两个源操作数，典型的SSE指令将同时计算两个双精度浮点结果、两个四字整型计算、四个单精度浮点操作、四个双字整型计算、八个字整型计算或十六个字节计算。AVX寄存器（YMM）将通道数量翻倍，因此并行计算的数量也翻倍。
- en: '[Figure 11-42](#figure11-42) shows how the SSE and AVX instructions perform
    concurrent calculations; a value is taken from the same lane in two source locations,
    the calculation is performed, and the instruction stores the result to the same
    lane in the destination location. This process happens simultaneously for each
    lane in the source and destination operands. For example, if a pair of XMM registers
    contains four single-precision floating-point values, a SIMD packed floating-point
    addition instruction would add the single-precision values in the corresponding
    lanes of the source operands and store the single-precision sums into the corresponding
    lanes of the destination XMM register.'
  id: totrans-484
  prefs: []
  type: TYPE_NORMAL
  zh: '[图11-42](#figure11-42)展示了SSE和AVX指令如何执行并行计算；一个值从两个源位置的相同通道中取出，执行计算后，指令将结果存储到目标位置的相同通道中。这个过程对源操作数和目标操作数中的每个通道都同时发生。例如，如果一对XMM寄存器包含四个单精度浮点值，则SIMD打包浮点加法指令将在源操作数的相应通道中对单精度值进行加法，并将结果存储到目标XMM寄存器的相应通道中。'
- en: '![f11042](image_fi/501089c11/f11042.png)'
  id: totrans-485
  prefs: []
  type: TYPE_IMG
  zh: '![f11042](image_fi/501089c11/f11042.png)'
- en: 'Figure 11-42: SIMD concurrent arithmetic and logical operations'
  id: totrans-486
  prefs: []
  type: TYPE_NORMAL
  zh: 图11-42：SIMD并行算术和逻辑操作
- en: Certain operations—for example, logical AND, ANDN (*and not*), OR, and XOR—don’t
    have to be broken into lanes, because those operations perform the same result
    regardless of the instruction size. The lane size is a single bit. Therefore,
    the corresponding SSE/AVX instructions operate on their entire operands without
    regard for a lane size.
  id: totrans-487
  prefs: []
  type: TYPE_NORMAL
  zh: 某些操作——例如，逻辑与、ANDN（*与非*）、或、异或——不需要拆分为多个通道，因为这些操作无论指令大小如何，都能得到相同的结果。通道大小是一个单独的位。因此，相关的SSE/AVX指令会在不考虑通道大小的情况下操作其整个操作数。
- en: 11.9 The SIMD Logical (Bitwise) Instructions
  id: totrans-488
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 11.9 SIMD 逻辑（按位）指令
- en: The SSE and AVX instruction set extensions provide the logical operations shown
    in [Table 11-10](#table11-10) (using C/C++ bitwise operator syntax).
  id: totrans-489
  prefs: []
  type: TYPE_NORMAL
  zh: SSE和AVX指令集扩展提供了[表11-10](#table11-10)中显示的逻辑操作（使用C/C++按位操作符语法）。
- en: 'Table 11-10: SSE/AVX Logical Instructions'
  id: totrans-490
  prefs: []
  type: TYPE_NORMAL
  zh: 表11-10：SSE/AVX逻辑指令
- en: '| **Operation** | **Description** |'
  id: totrans-491
  prefs: []
  type: TYPE_TB
  zh: '| **操作** | **描述** |'
- en: '| --- | --- |'
  id: totrans-492
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `andpd` | dest = dest and source (128-bit operands) |'
  id: totrans-493
  prefs: []
  type: TYPE_TB
  zh: '| `andpd` | dest = dest 和 source（128位操作数） |'
- en: '| `vandpd` | dest = source1 and source2 (128-bit or 256-bit operands) |'
  id: totrans-494
  prefs: []
  type: TYPE_TB
  zh: '| `vandpd` | dest = source1 和 source2（128位或256位操作数） |'
- en: '| `andnpd` | dest = dest and ~source (128-bit operands) |'
  id: totrans-495
  prefs: []
  type: TYPE_TB
  zh: '| `andnpd` | dest = dest 和 ~source（128位操作数） |'
- en: '| `vandnpd` | dest = source1 and ~source2 (128-bit or 256-bit operands) |'
  id: totrans-496
  prefs: []
  type: TYPE_TB
  zh: '| `vandnpd` | dest = source1 和 ~source2（128位或256位操作数） |'
- en: '| `orpd` | dest = dest &#124; source (128-bit operands) |'
  id: totrans-497
  prefs: []
  type: TYPE_TB
  zh: '| `orpd` | dest = dest &#124; source（128位操作数） |'
- en: '| `vorpd` | dest = source1 &#124; source2 (128-bit or 256-bit operands) |'
  id: totrans-498
  prefs: []
  type: TYPE_TB
  zh: '| `vorpd` | dest = source1 &#124; source2（128位或256位操作数） |'
- en: '| `xorpd` | dest = dest ^ source (128-bit operands) |'
  id: totrans-499
  prefs: []
  type: TYPE_TB
  zh: '| `xorpd` | dest = dest ^ source（128位操作数） |'
- en: '| `vxorpd` | dest = source1 ^ source2 (128-bit or 256-bit operands) |'
  id: totrans-500
  prefs: []
  type: TYPE_TB
  zh: '| `vxorpd` | dest = source1 ^ source2（128位或256位操作数） |'
- en: 'The syntax for these instructions is the following:'
  id: totrans-501
  prefs: []
  type: TYPE_NORMAL
  zh: 这些指令的语法如下：
- en: '[PRE49]'
  id: totrans-502
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: The SSE instructions (without the `v` prefix) leave the HO bits of the underlying
    YMM register unchanged (if applicable). The AVX instructions (with the `v` prefix)
    that have 128-bit operands will zero-extend their result into the HO bits of the
    YMM register.
  id: totrans-503
  prefs: []
  type: TYPE_NORMAL
  zh: SSE指令（没有`v`前缀）会保留底层YMM寄存器的HO位（如果适用）。带有`v`前缀的AVX指令（128位操作数）会将其结果零扩展到YMM寄存器的HO位。
- en: If the (second) source operand is a memory location, it must be aligned on an
    appropriate boundary (for example, 16 bytes for mem[128] values and 32 bytes for
    mem[256] values). Failure to do so will result in a runtime memory alignment fault.
  id: totrans-504
  prefs: []
  type: TYPE_NORMAL
  zh: 如果（第二个）源操作数是一个内存位置，它必须按适当的边界对齐（例如，mem[128]值为16字节，mem[256]值为32字节）。如果未对齐，将导致运行时内存对齐故障。
- en: 11.9.1 The (v)ptest Instructions
  id: totrans-505
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 11.9.1 （v）ptest指令
- en: 'The `ptest` instruction (*packed test*) is similar to the standard integer
    `test` instruction. The `ptest` instruction performs a logical AND between the
    two operands and sets the zero flag if the result is 0\. The `ptest` instruction
    sets the carry flag if the logical AND of the second operand with the inverted
    bits of the first operand produces 0\. The `ptest` instruction supports the following
    syntax:'
  id: totrans-506
  prefs: []
  type: TYPE_NORMAL
  zh: '`ptest`指令（*打包测试*）类似于标准整数`test`指令。`ptest`指令对两个操作数执行逻辑与操作，如果结果为0，则设置零标志。`ptest`指令会在第二个操作数与第一个操作数反转位的逻辑与结果为0时设置进位标志。`ptest`指令支持以下语法：'
- en: '[PRE50]'
  id: totrans-507
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 11.9.2 The Byte Shift Instructions
  id: totrans-508
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 11.9.2 字节移位指令
- en: 'The SSE and AVX instruction set extensions also support a set of logical and
    arithmetic shift instructions. The first two to consider are `pslldq` and `psrldq`.
    Although they begin with a `p`, suggesting they are packed (vector) instructions,
    these instructions really are just 128-bit logical shift-left and shift-right
    instructions. Their syntax is as follows:'
  id: totrans-509
  prefs: []
  type: TYPE_NORMAL
  zh: SSE 和 AVX 指令集扩展还支持一组逻辑和算术移位指令。首先要考虑的是 `pslldq` 和 `psrldq`。尽管它们以 `p` 开头，暗示它们是打包（向量）指令，但这些指令实际上只是
    128 位的逻辑左移和右移指令。它们的语法如下：
- en: '[PRE51]'
  id: totrans-510
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: The `pslldq` instruction shifts its destination XMM register to the left by
    the number of *bytes* specified by the imm[8] operand. This instruction shifts
    0s into the vacated LO bytes.
  id: totrans-511
  prefs: []
  type: TYPE_NORMAL
  zh: '`pslldq` 指令将目标 XMM 寄存器向左移动，移动的字节数由 imm[8] 操作数指定。该指令会在腾出的低字节位置填充 0。'
- en: The `vpslldq` instruction takes the value in the source register (XMM or YMM),
    shifts that value to the left by imm[8] bytes, and then stores the result into
    the destination register. For the 128-bit variant, this instruction zero-extends
    the result into bits 128 to 255 of the underlying YMM register (on AVX-capable
    CPUs).
  id: totrans-512
  prefs: []
  type: TYPE_NORMAL
  zh: '`vpslldq` 指令从源寄存器（XMM 或 YMM）中获取值，将该值向左移动 imm[8] 字节，然后将结果存储到目标寄存器中。对于 128 位变体，该指令会将结果零扩展到底层
    YMM 寄存器的 128 到 255 位（在支持 AVX 的 CPU 上）。'
- en: The `psrldq` and `vpsrldq` instructions operate similarly to `(v)pslldq` except,
    of course, they shift their operands to the right rather than to the left. These
    are logical shift-right operations, so they shift 0s into the HO bytes of their
    operand, and bits shifted out of bit 0 are lost.
  id: totrans-513
  prefs: []
  type: TYPE_NORMAL
  zh: '`psrldq` 和 `vpsrldq` 指令的操作方式与 `(v)pslldq` 类似，当然，它们是将操作数向右移位，而不是向左。它们是逻辑右移操作，因此会将
    0 移入操作数的高字节，移出第 0 位的位会丢失。'
- en: The `pslldq` and `psrldq` instructions shift *bytes* rather than bits. For example,
    many SSE instructions produce byte masks 0 or 0FFh, representing Boolean results.
    These instructions shift the equivalent of a bit in one of these byte masks by
    shifting whole bytes at a time.
  id: totrans-514
  prefs: []
  type: TYPE_NORMAL
  zh: '`pslldq` 和 `psrldq` 指令移位的是 *字节* 而不是位。例如，许多 SSE 指令会生成字节掩码 0 或 0FFh，表示布尔结果。这些指令通过一次性移动整个字节，来移动这些字节掩码中的每一位。'
- en: 11.9.3 The Bit Shift Instructions
  id: totrans-515
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 11.9.3 位移指令
- en: The SSE/AVX instruction set extensions also provide vector bit shift operations
    that work on two or more integer lanes, concurrently. These instructions provide
    word, dword, and qword variants of the logical shift-left, logical shift-right,
    and arithmetic shift-right operations, using the syntax
  id: totrans-516
  prefs: []
  type: TYPE_NORMAL
  zh: SSE/AVX 指令集扩展还提供了在两个或更多整数通道上并行工作的向量位移操作。这些指令提供了逻辑左移、逻辑右移和算术右移操作的字（word）、双字（dword）和四字（qword）变体，使用的语法如下：
- en: '[PRE52]'
  id: totrans-517
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: where `shift` = `psllw`, `pslld`, `psllq`, `psrlw`, `psrld`, `psrlq`, `psraw`,
    or `psrad`, and `vshift` = `vpsllw`, `vpslld`, `vpsllq`, `vpsrlw`, `vpsrld`, `vpsrlq`,
    `vpsraw`, `vpsrad`, or `vpsraq`.
  id: totrans-518
  prefs: []
  type: TYPE_NORMAL
  zh: 其中 `shift` = `psllw`、`pslld`、`psllq`、`psrlw`、`psrld`、`psrlq`、`psraw` 或 `psrad`，`vshift`
    = `vpsllw`、`vpslld`、`vpsllq`、`vpsrlw`、`vpsrld`、`vpsrlq`、`vpsraw`、`vpsrad` 或 `vpsraq`。
- en: The `(v)psl*` instructions shift their operands to the left; the `(v)psr*` instructions
    shift their operands to the right. The `(v)psll*` and `(v)psrl*` instructions
    are logical shift instructions and shift 0s into the bits vacated by the shift.
    Any bits shifted out of the operand are lost. The `(v)psra*` instructions are
    arithmetic shift-right instructions. They replicate the HO bit in each lane when
    shifting that lane’s bits to the right; all bits shifted out of the LO bit are
    lost.
  id: totrans-519
  prefs: []
  type: TYPE_NORMAL
  zh: '`(v)psl*` 指令将操作数向左移动；`(v)psr*` 指令将操作数向右移动。`(v)psll*` 和 `(v)psrl*` 指令是逻辑移位指令，会将
    0 移入移位腾出的位位置。任何从操作数中移出的位都会丢失。`(v)psra*` 指令是算术右移指令，它们会在将该通道的位向右移时，复制该通道的高位（HO）位；所有从低位（LO）移出的位都会丢失。'
- en: The SSE two-operand instructions treat their first operand as both the source
    and destination operand. The second operand specifies the number of bits to shift
    (which is either an 8-bit immediate constant or a value held in an XMM register
    or a 128-bit memory location). Regardless of the shift count’s size, only the
    LO 4, 5, or 6 bits of the count are meaningful (depending on the lane size).
  id: totrans-520
  prefs: []
  type: TYPE_NORMAL
  zh: SSE 的双操作数指令将其第一个操作数视为源操作数和目标操作数。第二个操作数指定移位的位数（可以是 8 位立即数常量，或存储在 XMM 寄存器或 128
    位内存位置中的值）。无论移位计数的大小如何，只有计数的低 4、5 或 6 位是有效的（取决于通道大小）。
- en: The AVX three-operand instructions specify a separate source and destination
    register for the shift operation. These instructions take the value from the source
    register, shift it the specified number of bits, and store the shifted result
    into the destination register. The source register remains unmodified (unless,
    of course, the instruction specifies the same register for the source and destination
    operands). For the AVX instructions, the source and destination registers can
    be XMM (128-bit) or YMM (256-bit) registers. The third operand is either an 8-bit
    immediate constant, an XMM register, or a 128-bit memory location. The third operand
    specifies the bit shift count (the same as the SSE instructions). You specify
    an XMM register for the count even when the source and destination registers are
    256-bit YMM registers.
  id: totrans-521
  prefs: []
  type: TYPE_NORMAL
  zh: AVX 三操作数指令为移位操作指定了一个独立的源和目标寄存器。这些指令从源寄存器获取值，按指定的位数进行移位，并将移位后的结果存储到目标寄存器中。源寄存器保持不变（除非该指令明确指定源和目标操作数使用相同寄存器）。对于
    AVX 指令，源和目标寄存器可以是 XMM（128 位）或 YMM（256 位）寄存器。第三个操作数可以是一个 8 位立即数、XMM 寄存器或 128 位内存位置。第三个操作数指定位移的位数（与
    SSE 指令相同）。即使源和目标寄存器是 256 位的 YMM 寄存器，位移计数也需要指定为 XMM 寄存器。
- en: The `w` suffix instructions shift 16-bit operands (eight lanes for 128-bit destination
    operands, sixteen lanes for 256-bit destinations). The `d` suffix instructions
    shift 32-bit dword operands (four lanes for 128-bit destination operands, eight
    lanes for 256-bit destination operands). The `q` suffix instructions shift 64-bit
    operands (two lanes for 128-bit operands, four lanes for 256-bit operands).
  id: totrans-522
  prefs: []
  type: TYPE_NORMAL
  zh: '`w` 后缀指令处理 16 位操作数（128 位目标操作数为 8 通道，256 位目标操作数为 16 通道）。`d` 后缀指令处理 32 位双字操作数（128
    位目标操作数为 4 通道，256 位目标操作数为 8 通道）。`q` 后缀指令处理 64 位操作数（128 位操作数为 2 通道，256 位操作数为 4 通道）。'
- en: 11.10 The SIMD Integer Arithmetic Instructions
  id: totrans-523
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 11.10 SIMD 整数算术指令
- en: The SSE and AVX instruction set extensions deal mainly with floating-point calculations.
    They do, however, include a set of signed and unsigned integer arithmetic operations.
    This section describes the SSE/AVX integer arithmetic instructions.
  id: totrans-524
  prefs: []
  type: TYPE_NORMAL
  zh: SSE 和 AVX 指令集扩展主要处理浮点计算。然而，它们也包括一组有符号和无符号整数算术运算。本节描述了 SSE/AVX 整数算术指令。
- en: 11.10.1 SIMD Integer Addition
  id: totrans-525
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 11.10.1 SIMD 整数加法
- en: The SIMD integer addition instructions appear in [Table 11-11](#table11-11).
    These instructions do not affect any flags and thus do not indicate when an overflow
    (signed or unsigned) occurs during the execution of these instructions. The program
    itself must ensure that the source operands are all within the appropriate range
    before performing an addition. If carry occurs during an addition, the carry is
    lost.
  id: totrans-526
  prefs: []
  type: TYPE_NORMAL
  zh: SIMD 整数加法指令见 [表 11-11](#table11-11)。这些指令不会影响任何标志，因此不会在执行过程中指示溢出（有符号或无符号）发生。程序本身必须确保源操作数都在适当的范围内，才能执行加法。如果加法过程中发生进位，则进位将丢失。
- en: 'Table 11-11: SIMD Integer Addition Instructions'
  id: totrans-527
  prefs: []
  type: TYPE_NORMAL
  zh: '表 11-11: SIMD 整数加法指令'
- en: '| **Instruction** | **Operands** | **Description** |'
  id: totrans-528
  prefs: []
  type: TYPE_TB
  zh: '| **指令** | **操作数** | **描述** |'
- en: '| --- | --- | --- |'
  id: totrans-529
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| `paddb` | `xmm`[dest], `xmm`/`mem`[128] | 16-lane byte addition |'
  id: totrans-530
  prefs: []
  type: TYPE_TB
  zh: '| `paddb` | `xmm`[dest], `xmm`/`mem`[128] | 16通道字节相加 |'
- en: '| `vpaddb` | `xmm`[dest], `xmm`[src1], `xmm`[src2]/`mem`[128] | 16-lane byte
    addition |'
  id: totrans-531
  prefs: []
  type: TYPE_TB
  zh: '| `vpaddb` | `xmm`[dest], `xmm`[src1], `xmm`[src2]/`mem`[128] | 16通道字节相加 |'
- en: '| `vpaddb` | `ymm`[dest], `ymm`[src1], `ymm`[src2]/`mem`[256] | 32-lane byte
    addition |'
  id: totrans-532
  prefs: []
  type: TYPE_TB
  zh: '| `vpaddb` | `ymm`[dest], `ymm`[src1], `ymm`[src2]/`mem`[256] | 32通道字节相加 |'
- en: '| `paddw` | `xmm`[dest], `xmm`/`mem`[128] | 8-lane word addition |'
  id: totrans-533
  prefs: []
  type: TYPE_TB
  zh: '| `paddw` | `xmm`[dest], `xmm`/`mem`[128] | 8通道字相加 |'
- en: '| `vpaddw` | `xmm`[dest], `xmm`[src1], `xmm`[src2]/`mem`[128] | 8-lane word
    addition |'
  id: totrans-534
  prefs: []
  type: TYPE_TB
  zh: '| `vpaddw` | `xmm`[dest], `xmm`[src1], `xmm`[src2]/`mem`[128] | 8通道字相加 |'
- en: '| `vpaddw` | `ymm`[dest], `ymm`[src1], `ymm`[src2]/`mem`[256] | 16-lane word
    addition |'
  id: totrans-535
  prefs: []
  type: TYPE_TB
  zh: '| `vpaddw` | `ymm`[dest], `ymm`[src1], `ymm`[src2]/`mem`[256] | 16通道字相加 |'
- en: '| `paddd` | `xmm`[dest], `xmm`/`mem`[128] | 4-lane dword addition |'
  id: totrans-536
  prefs: []
  type: TYPE_TB
  zh: '| `paddd` | `xmm`[dest], `xmm`/`mem`[128] | 4通道双字相加 |'
- en: '| `vpaddd` | `xmm`[dest], `xmm`[src1], `xmm`[src2]/`mem`[128] | 4-lane dword
    addition |'
  id: totrans-537
  prefs: []
  type: TYPE_TB
  zh: '| `vpaddd` | `xmm`[dest], `xmm`[src1], `xmm`[src2]/`mem`[128] | 4通道双字相加 |'
- en: '| `vpaddd` | `ymm`[dest], `ymm`[src1], `ymm`[src2]/`mem`[256] | 8-lane dword
    addition |'
  id: totrans-538
  prefs: []
  type: TYPE_TB
  zh: '| `vpaddd` | `ymm`[dest], `ymm`[src1], `ymm`[src2]/`mem`[256] | 8通道双字相加 |'
- en: '| `paddq` | `xmm`[dest], `xmm`/`mem`[128] | 2-lane qword addition |'
  id: totrans-539
  prefs: []
  type: TYPE_TB
  zh: '| `paddq` | `xmm`[dest], `xmm`/`mem`[128] | 2通道四字相加 |'
- en: '| `vpaddq` | `xmm`[dest], `xmm`[src1], `xmm`[src2]/`mem`[128] | 2-lane qword
    addition |'
  id: totrans-540
  prefs: []
  type: TYPE_TB
  zh: '| `vpaddq` | `xmm`[dest], `xmm`[src1], `xmm`[src2]/`mem`[128] | 2通道四字相加 |'
- en: '| `vpaddq` | `ymm`[dest], `ymm`[src1], `ymm`[src2]/`mem`[256] | 4-lane qword
    addition |'
  id: totrans-541
  prefs: []
  type: TYPE_TB
  zh: '| `vpaddq` | `ymm`[dest], `ymm`[src1], `ymm`[src2]/`mem`[256] | 4通道四字节加法 |'
- en: These addition instructions are known as *vertical additions* because if we
    stack the two source operands on top of each other (on a printed page), the lane
    additions occur vertically (one source lane is directly above the second source
    lane for the corresponding addition operation).
  id: totrans-542
  prefs: []
  type: TYPE_NORMAL
  zh: 这些加法指令被称为*垂直加法*，因为如果我们将两个源操作数堆叠在一起（在打印页面上），每个通道的加法操作是垂直发生的（一个源通道直接位于第二个源通道上方，进行相应的加法操作）。
- en: The packed additions ignore any overflow from the addition operation, keeping
    only the LO byte, word, dword, or qword of each addition. As long as overflow
    is never possible, this is not an issue. However, for certain algorithms (especially
    audio and video, which commonly use packed addition), truncating away the overflow
    can produce bizarre results.
  id: totrans-543
  prefs: []
  type: TYPE_NORMAL
  zh: 打包加法忽略了加法操作中的任何溢出，只保留每次加法的低字节、字、双字或四字。例如，只要溢出不可能发生，这不是一个问题。然而，对于某些算法（尤其是常使用打包加法的音频和视频），截断溢出可能会产生异常的结果。
- en: A cleaner solution is to use *saturation arithmetic*. For unsigned addition,
    saturation arithmetic *clips* (or *saturates*) an overflow to the largest possible
    value that the instruction’s size can handle. For example, if the addition of
    two byte values exceeds 0FFh, saturation arithmetic produces 0FFh—the largest
    possible unsigned 8-bit value (likewise, saturation subtraction would produce
    0 if underflow occurs). For signed saturation arithmetic, clipping occurs at the
    largest positive and smallest negative values (for example, 7Fh/+127 for positive
    values and 80h/–128 for negative values).
  id: totrans-544
  prefs: []
  type: TYPE_NORMAL
  zh: 更简洁的解决方案是使用*饱和算术*。对于无符号加法，饱和算术会将溢出*剪裁*（或*饱和*）到指令大小能处理的最大值。例如，如果两个字节值的加法超过0FFh，饱和算术会生成0FFh——这是最大的无符号8位值（同样，饱和减法如果发生下溢则会产生0）。对于有符号饱和算术，剪裁会发生在最大的正值和最小的负值处（例如，7Fh/+127为正值，80h/–128为负值）。
- en: The x86 SIMD instructions provide both signed and unsigned saturation arithmetic,
    though the operations are limited to 8- and 16-bit quantities.^([10](#c11-footnote-10))
    The instructions appear in [Table 11-12](#table11-12).
  id: totrans-545
  prefs: []
  type: TYPE_NORMAL
  zh: x86 SIMD指令提供了有符号和无符号饱和算术，尽管这些操作仅限于8位和16位数值。^([10](#c11-footnote-10)) 这些指令出现在[表
    11-12](#table11-12)中。
- en: 'Table 11-12: SIMD Integer Saturation Addition Instructions'
  id: totrans-546
  prefs: []
  type: TYPE_NORMAL
  zh: 表 11-12：SIMD整数饱和加法指令
- en: '| **Instruction** | **Operands** | **Description** |'
  id: totrans-547
  prefs: []
  type: TYPE_TB
  zh: '| **指令** | **操作数** | **描述** |'
- en: '| --- | --- | --- |'
  id: totrans-548
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| `paddsb` | `xmm`[dest], `xmm`/`mem`[128] | 16-lane byte signed saturation
    addition |'
  id: totrans-549
  prefs: []
  type: TYPE_TB
  zh: '| `paddsb` | `xmm`[dest], `xmm`/`mem`[128] | 16通道字节有符号饱和加法 |'
- en: '| `vpaddsb` | `xmm`[dest], `xmm`[src1], `xmm`[src2]/`mem`[128] | 16-lane byte
    signed saturation addition |'
  id: totrans-550
  prefs: []
  type: TYPE_TB
  zh: '| `vpaddsb` | `xmm`[dest], `xmm`[src1], `xmm`[src2]/`mem`[128] | 16通道字节有符号饱和加法
    |'
- en: '| `vpaddsb` | `ymm`[dest], `ymm`[src1], `ymm`[src2]/`mem`[256] | 32-lane byte
    signed saturation addition |'
  id: totrans-551
  prefs: []
  type: TYPE_TB
  zh: '| `vpaddsb` | `ymm`[dest], `ymm`[src1], `ymm`[src2]/`mem`[256] | 32通道字节有符号饱和加法
    |'
- en: '| `paddsw` | `xmm`[dest], `xmm`/`mem`[128] | 8-lane word signed saturation
    addition |'
  id: totrans-552
  prefs: []
  type: TYPE_TB
  zh: '| `paddsw` | `xmm`[dest], `xmm`/`mem`[128] | 8通道字节有符号饱和加法 |'
- en: '| `vpaddsw` | `xmm`[dest], `xmm`[src1], `xmm`[src2]/`mem`[128] | 8-lane word
    signed saturation addition |'
  id: totrans-553
  prefs: []
  type: TYPE_TB
  zh: '| `vpaddsw` | `xmm`[dest], `xmm`[src1], `xmm`[src2]/`mem`[128] | 8通道字节有符号饱和加法
    |'
- en: '| `vpaddsw` | `ymm`[dest], `ymm`[src1], `ymm`[src2]/`mem`[256] | 16-lane word
    signed saturation addition |'
  id: totrans-554
  prefs: []
  type: TYPE_TB
  zh: '| `vpaddsw` | `ymm`[dest], `ymm`[src1], `ymm`[src2]/`mem`[256] | 16通道字节有符号饱和加法
    |'
- en: '| `paddusb` | `xmm`[dest], `xmm`/`mem`[128] | 16-lane byte unsigned saturation
    addition |'
  id: totrans-555
  prefs: []
  type: TYPE_TB
  zh: '| `paddusb` | `xmm`[dest], `xmm`/`mem`[128] | 16通道字节无符号饱和加法 |'
- en: '| `vpaddusb` | `xmm`[dest], `xmm`[src1], `xmm`[src2]/`mem`[128] | 16-lane byte
    unsigned saturation addition |'
  id: totrans-556
  prefs: []
  type: TYPE_TB
  zh: '| `vpaddusb` | `xmm`[dest], `xmm`[src1], `xmm`[src2]/`mem`[128] | 16通道字节无符号饱和加法
    |'
- en: '| `vpaddusb` | `ymm`[dest], `ymm`[src1], `ymm`[src2]/`mem`[256] | 32-lane byte
    unsigned saturation addition |'
  id: totrans-557
  prefs: []
  type: TYPE_TB
  zh: '| `vpaddusb` | `ymm`[dest], `ymm`[src1], `ymm`[src2]/`mem`[256] | 32通道字节无符号饱和加法
    |'
- en: '| `paddusw` | `xmm`[dest], `xmm`/`mem`[128] | 8-lane word unsigned saturation
    addition |'
  id: totrans-558
  prefs: []
  type: TYPE_TB
  zh: '| `paddusw` | `xmm`[dest], `xmm`/`mem`[128] | 8通道字节无符号饱和加法 |'
- en: '| `vpaddusw` | `xmm`[dest], `xmm`[src1], `xmm`[src2]/`mem`[128] | 8-lane word
    unsigned saturation addition |'
  id: totrans-559
  prefs: []
  type: TYPE_TB
  zh: '| `vpaddusw` | `xmm`[dest], `xmm`[src1], `xmm`[src2]/`mem`[128] | 8通道字节无符号饱和加法
    |'
- en: '| `vpaddusw` | `ymm`[dest], `ymm`[src1], `ymm`[src2]/`mem`[256] | 16-lane word
    unsigned saturation addition |'
  id: totrans-560
  prefs: []
  type: TYPE_TB
  zh: '| `vpaddusw` | `ymm`[dest], `ymm`[src1], `ymm`[src2]/`mem`[256] | 16通道字节无符号饱和加法
    |'
- en: As usual, both `padd*` and `vpadd*` instructions accept 128-bit XMM registers
    (sixteen 8-bit additions or eight 16-bit additions). The `padd*` instructions
    leave the HO bits of any corresponding YMM destination undisturbed; the `vpadd*`
    variants clear the HO bits. Also note that the `padd*` instructions have only
    two operands (the destination register is also a source), whereas the `vpadd*`
    instructions have two source operands and a single destination operand. The `vpadd*`
    instructions with the YMM register provide double the number of parallel additions.
  id: totrans-561
  prefs: []
  type: TYPE_NORMAL
  zh: 和往常一样，`padd*` 和 `vpadd*` 指令接受 128 位 XMM 寄存器（十六个 8 位加法或八个 16 位加法）。`padd*` 指令不会改变任何对应
    YMM 目标寄存器的高 128 位（HO bits）；而 `vpadd*` 变体会清除这些高位。另外，注意到 `padd*` 指令只有两个操作数（目标寄存器也是源寄存器），而
    `vpadd*` 指令有两个源操作数和一个目标操作数。使用 YMM 寄存器的 `vpadd*` 指令提供了双倍的并行加法数量。
- en: 11.10.2 Horizontal Additions
  id: totrans-562
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 11.10.2 横向加法
- en: The SSE/AVX instruction sets also support three *horizontal addition* instructions,
    listed in [Table 11-13](#table11-13).
  id: totrans-563
  prefs: []
  type: TYPE_NORMAL
  zh: SSE/AVX 指令集还支持三种*横向加法*指令，列于[表 11-13](#table11-13)中。
- en: 'Table 11-13: Horizontal Addition Instructions'
  id: totrans-564
  prefs: []
  type: TYPE_NORMAL
  zh: 表 11-13：横向加法指令
- en: '| **Instruction** | **Description** |'
  id: totrans-565
  prefs: []
  type: TYPE_TB
  zh: '| **指令** | **描述** |'
- en: '| --- | --- |'
  id: totrans-566
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `(v)``phaddw` | 16-bit (word) horizontal add |'
  id: totrans-567
  prefs: []
  type: TYPE_TB
  zh: '| `(v)``phaddw` | 16 位（word）横向加法 |'
- en: '| `(v)``phaddd` | 32-bit (dword) horizontal add |'
  id: totrans-568
  prefs: []
  type: TYPE_TB
  zh: '| `(v)``phaddd` | 32 位（dword）横向加法 |'
- en: '| `(v)``phaddsw` | 16-bit (word) horizontal add and saturate |'
  id: totrans-569
  prefs: []
  type: TYPE_TB
  zh: '| `(v)``phaddsw` | 16 位（word）横向加法并饱和 |'
- en: The horizontal addition instructions add adjacent words or dwords in their two
    source operands and store the sum of the result into a destination lane, as shown
    in [Figure 11-43](#figure11-43).
  id: totrans-570
  prefs: []
  type: TYPE_NORMAL
  zh: 横向加法指令将两个源操作数中的相邻字（word）或双字（dword）进行相加，并将结果的和存入目标位置，如[图 11-43](#figure11-43)所示。
- en: '![f11043](image_fi/501089c11/f11043.png)'
  id: totrans-571
  prefs: []
  type: TYPE_IMG
  zh: '![f11043](image_fi/501089c11/f11043.png)'
- en: 'Figure 11-43: Horizontal addition operation'
  id: totrans-572
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11-43：横向加法操作
- en: 'The `phaddw` instruction has the following syntax:'
  id: totrans-573
  prefs: []
  type: TYPE_NORMAL
  zh: '`phaddw` 指令具有以下语法：'
- en: '[PRE53]'
  id: totrans-574
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'It computes the following:'
  id: totrans-575
  prefs: []
  type: TYPE_NORMAL
  zh: 它计算以下内容：
- en: '[PRE54]'
  id: totrans-576
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: As is the case with most SSE instructions, `phaddw` does not affect the HO bits
    of the corresponding YMM destination register, only the LO 128 bits.
  id: totrans-577
  prefs: []
  type: TYPE_NORMAL
  zh: 与大多数 SSE 指令一样，`phaddw` 不会影响对应 YMM 目标寄存器的高位，只会影响低 128 位（LO 128 bits）。
- en: 'The 128-bit `vphaddw` instruction has the following syntax:'
  id: totrans-578
  prefs: []
  type: TYPE_NORMAL
  zh: 128 位 `vphaddw` 指令具有以下语法：
- en: '[PRE55]'
  id: totrans-579
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'It computes the following:'
  id: totrans-580
  prefs: []
  type: TYPE_NORMAL
  zh: 它计算以下内容：
- en: '[PRE56]'
  id: totrans-581
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: The `vphaddw` instruction zeroes out the HO 128 bits of the corresponding YMM
    destination register.
  id: totrans-582
  prefs: []
  type: TYPE_NORMAL
  zh: '`vphaddw` 指令将对应 YMM 目标寄存器的高 128 位清零。'
- en: 'The 256-bit `vphaddw` instruction has the following syntax:'
  id: totrans-583
  prefs: []
  type: TYPE_NORMAL
  zh: 256 位 `vphaddw` 指令具有以下语法：
- en: '[PRE57]'
  id: totrans-584
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: '`vphaddw` does not simply extend the 128-bit version in the intuitive way.
    Instead, it mixes up computations as follows (where `SRC1` is YMM[src1] and `SRC2`
    is YMM[src2]/mem[256]):'
  id: totrans-585
  prefs: []
  type: TYPE_NORMAL
  zh: '`vphaddw` 并不是以直观的方式简单地扩展 128 位版本。相反，它混合计算如下（其中 `SRC1` 为 YMM[src1]，`SRC2` 为
    YMM[src2]/mem[256]）：'
- en: '[PRE58]'
  id: totrans-586
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 11.10.3 Double-Word–Sized Horizontal Additions
  id: totrans-587
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 11.10.3 双字（Double-Word）大小的横向加法
- en: 'The `phaddd` instruction has the following syntax:'
  id: totrans-588
  prefs: []
  type: TYPE_NORMAL
  zh: '`phaddd` 指令具有以下语法：'
- en: '[PRE59]'
  id: totrans-589
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'It computes the following:'
  id: totrans-590
  prefs: []
  type: TYPE_NORMAL
  zh: 它计算以下内容：
- en: '[PRE60]'
  id: totrans-591
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'The 128-bit `vphaddd` instruction has this syntax:'
  id: totrans-592
  prefs: []
  type: TYPE_NORMAL
  zh: 128 位 `vphaddd` 指令具有以下语法：
- en: '[PRE61]'
  id: totrans-593
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'It computes the following:'
  id: totrans-594
  prefs: []
  type: TYPE_NORMAL
  zh: 它计算以下内容：
- en: '[PRE62]'
  id: totrans-595
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'Like `vphaddw`, the 256-bit `vphaddd` instruction has the following syntax:'
  id: totrans-596
  prefs: []
  type: TYPE_NORMAL
  zh: 与 `vphaddw` 类似，256 位 `vphaddd` 指令具有以下语法：
- en: '[PRE63]'
  id: totrans-597
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'It calculates the following:'
  id: totrans-598
  prefs: []
  type: TYPE_NORMAL
  zh: 它计算以下内容：
- en: '[PRE64]'
  id: totrans-599
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: If an overflow occurs during the horizontal addition, `(v)phaddw` and `(v)phaddd`
    simply ignore the overflow and store the LO 16 or 32 bits of the result into the
    destination location.
  id: totrans-600
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在横向加法过程中发生溢出，`(v)phaddw` 和 `(v)phaddd` 会忽略溢出，并将结果的低 16 位或 32 位存入目标位置。
- en: 'The `(v)phaddsw` instructions take the following forms:'
  id: totrans-601
  prefs: []
  type: TYPE_NORMAL
  zh: '`(v)phaddsw` 指令有以下形式：'
- en: '[PRE65]'
  id: totrans-602
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'The `(v)phaddsw` instruction (*horizontal signed integer add with saturate,
    word*) is a slightly different form of `(v)phaddw`: rather than storing only the
    LO bits into the result in the destination lane, this instruction saturates the
    result. *Saturation* means that any (positive) overflow results in the value 7FFFh,
    regardless of the actual result. Likewise, any negative underflow results in the
    value 8000h.'
  id: totrans-603
  prefs: []
  type: TYPE_NORMAL
  zh: '`(v)phaddsw` 指令（*横向带饱和的有符号整数加法，字*）是 `(v)phaddw` 的一种稍有不同的形式：与仅将低位存入目标位置的结果不同，该指令会对结果进行饱和处理。*饱和*意味着任何（正）溢出都会导致值为
    7FFFh，无论实际结果如何。类似地，任何负溢出都会导致值为 8000h。'
- en: Saturation arithmetic works well for audio and video processing. If you were
    using standard (wraparound/modulo) addition when adding two sound samples together,
    the result would be horrible clicking sounds. Saturation, on the other hand, simply
    produces a clipped audio signal. While this is not ideal, it sounds considerably
    better than the results from modulo arithmetic. Similarly, for video processing,
    saturation produces a washed-out (white) color versus the bizarre colors that
    result from modulo arithmetic.
  id: totrans-604
  prefs: []
  type: TYPE_NORMAL
  zh: 饱和算术在音频和视频处理中的表现良好。如果使用标准的（环绕/取模）加法将两个声音样本相加，结果会产生难听的点击声。而饱和算术则会产生一个截断的音频信号。虽然这并不理想，但比起取模算术的结果，这听起来要好得多。类似地，在视频处理中，饱和算术会产生褪色（白色）的颜色，而不是取模算术所带来的奇怪颜色。
- en: Sadly, there is no horizontal add with saturation for double-word operands (for
    example, to handle 24-bit audio).
  id: totrans-605
  prefs: []
  type: TYPE_NORMAL
  zh: 遗憾的是，双字操作数没有饱和水平加法（例如，用于处理 24 位音频）。
- en: 11.10.4 SIMD Integer Subtraction
  id: totrans-606
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 11.10.4 SIMD 整数减法
- en: The SIMD integer subtraction instructions appear in [Table 11-14](#table11-14).
    As for the SIMD addition instructions, they do not affect any flags; any carry,
    borrow, overflow, or underflow information is lost. These instructions subtract
    the second source operand from the first source operand (which is also the destination
    operand for the SSE-only instructions) and store the result into the destination
    operand.
  id: totrans-607
  prefs: []
  type: TYPE_NORMAL
  zh: SIMD 整数减法指令见 [表 11-14](#table11-14)。与 SIMD 加法指令一样，这些指令不会影响任何标志；任何进位、借位、溢出或下溢信息都会丢失。这些指令将第二个源操作数从第一个源操作数中减去（对于仅支持
    SSE 的指令，结果也作为目标操作数），并将结果存储到目标操作数中。
- en: 'Table 11-14: SIMD Integer Subtraction Instructions'
  id: totrans-608
  prefs: []
  type: TYPE_NORMAL
  zh: '表 11-14: SIMD 整数减法指令'
- en: '| **Instruction** | **Operands** | **Description** |'
  id: totrans-609
  prefs: []
  type: TYPE_TB
  zh: '| **指令** | **操作数** | **描述** |'
- en: '| --- | --- | --- |'
  id: totrans-610
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| `psubb` | `xmm`[dest], `xmm`/`mem`[128] | 16-lane byte subtraction |'
  id: totrans-611
  prefs: []
  type: TYPE_TB
  zh: '| `psubb` | `xmm`[dest], `xmm`/`mem`[128] | 16道字节减法 |'
- en: '| `vpsubb` | `xmm`[dest], `xmm`[src], `xmm`/`mem`[128] | 16-lane byte subtraction
    |'
  id: totrans-612
  prefs: []
  type: TYPE_TB
  zh: '| `vpsubb` | `xmm`[dest], `xmm`[src], `xmm`/`mem`[128] | 16道字节减法 |'
- en: '| `vpsubb` | `ymm`[dest], `ymm`[src], `ymm`/`mem`[256] | 32-lane byte subtraction
    |'
  id: totrans-613
  prefs: []
  type: TYPE_TB
  zh: '| `vpsubb` | `ymm`[dest], `ymm`[src], `ymm`/`mem`[256] | 32道字节减法 |'
- en: '| `psubw` | `xmm`[dest], `xmm`/`mem`[128] | 8-lane word subtraction |'
  id: totrans-614
  prefs: []
  type: TYPE_TB
  zh: '| `psubw` | `xmm`[dest], `xmm`/`mem`[128] | 8道字减法 |'
- en: '| `vpsubw` | `xmm`[dest], `xmm`[src], `xmm`/`mem`[128] | 8-lane word subtraction
    |'
  id: totrans-615
  prefs: []
  type: TYPE_TB
  zh: '| `vpsubw` | `xmm`[dest], `xmm`[src], `xmm`/`mem`[128] | 8道字减法 |'
- en: '| `vpsubw` | `ymm`[dest], `ymm`[src], `ymm`/`mem`[256] | 16-lane word subtraction
    |'
  id: totrans-616
  prefs: []
  type: TYPE_TB
  zh: '| `vpsubw` | `ymm`[dest], `ymm`[src], `ymm`/`mem`[256] | 16道字减法 |'
- en: '| `psubd` | `xmm`[dest], `xmm`/`mem`[128] | 4-lane dword subtraction |'
  id: totrans-617
  prefs: []
  type: TYPE_TB
  zh: '| `psubd` | `xmm`[dest], `xmm`/`mem`[128] | 4道双字减法 |'
- en: '| `vpsubd` | `xmm`[dest], `xmm`[src], `xmm`/`mem`[128] | 4-lane dword subtraction
    |'
  id: totrans-618
  prefs: []
  type: TYPE_TB
  zh: '| `vpsubd` | `xmm`[dest], `xmm`[src], `xmm`/`mem`[128] | 4道双字减法 |'
- en: '| `vpsubd` | `ymm`[dest], `ymm`[src], `ymm`/`mem`[256] | 8-lane dword subtraction
    |'
  id: totrans-619
  prefs: []
  type: TYPE_TB
  zh: '| `vpsubd` | `ymm`[dest], `ymm`[src], `ymm`/`mem`[256] | 8道双字减法 |'
- en: '| `psubq` | `xmm`[dest], `xmm`/`mem`[128] | 2-lane qword subtraction |'
  id: totrans-620
  prefs: []
  type: TYPE_TB
  zh: '| `psubq` | `xmm`[dest], `xmm`/`mem`[128] | 2道四字减法 |'
- en: '| `vpsubq` | `xmm`[dest], `xmm`[src], `xmm`/`mem`[128] | 2-lane qword subtraction
    |'
  id: totrans-621
  prefs: []
  type: TYPE_TB
  zh: '| `vpsubq` | `xmm`[dest], `xmm`[src], `xmm`/`mem`[128] | 2道四字减法 |'
- en: '| `vpsubq` | `ymm`[dest], `ymm`[src], `ymm`/`mem`[256] | 4-lane qword subtraction
    |'
  id: totrans-622
  prefs: []
  type: TYPE_TB
  zh: '| `vpsubq` | `ymm`[dest], `ymm`[src], `ymm`/`mem`[256] | 4道四字减法 |'
- en: The `(v)phsubw`, `(v)phsubd`, and `(v)phsubsw` horizontal subtraction instructions
    work just like the horizontal addition instructions, except (of course) they compute
    the difference of the two source operands rather than the sum. See the previous
    sections for details on the horizontal addition instructions.
  id: totrans-623
  prefs: []
  type: TYPE_NORMAL
  zh: '`(v)phsubw`、`(v)phsubd` 和 `(v)phsubsw` 水平减法指令的工作方式与水平加法指令相同，不同之处在于（当然）它们计算的是两个源操作数的差值，而不是和。有关水平加法指令的详细信息，请参见前面的章节。'
- en: Likewise, there is a set of signed and unsigned byte and word saturating subtraction
    instructions (see [Table 11-15](#table11-15)). For the signed instructions, the
    byte-sized instructions saturate positive overflow to 7Fh (+127) and negative
    underflow to 80h (–128). The word-sized instructions saturate to 7FFFh (+32,767)
    and 8000h (–32,768). The unsigned saturation instructions saturate to 0FFFFh (+65,535)
    and 0.
  id: totrans-624
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，也有一组带符号和无符号字节和字饱和减法指令（见 [表 11-15](#table11-15)）。对于带符号指令，字节型指令会将正溢出饱和为 7Fh
    (+127)，负下溢饱和为 80h (–128)。字型指令会将值饱和为 7FFFh (+32,767) 和 8000h (–32,768)。无符号饱和指令会将值饱和为
    0FFFFh (+65,535) 和 0。
- en: 'Table 11-15: SIMD Integer Saturating Subtraction Instructions'
  id: totrans-625
  prefs: []
  type: TYPE_NORMAL
  zh: '表 11-15: SIMD 整数饱和减法指令'
- en: '| **Instruction** | **Operands** | **Description** |'
  id: totrans-626
  prefs: []
  type: TYPE_TB
  zh: '| **指令** | **操作数** | **描述** |'
- en: '| --- | --- | --- |'
  id: totrans-627
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| `psubsb` | `xmm`[dest], `xmm`/`mem`[128] | 16-lane byte signed saturation
    subtraction |'
  id: totrans-628
  prefs: []
  type: TYPE_TB
  zh: '| `psubsb` | `xmm`[dest]，`xmm`/`mem`[128] | 16通道字节带符号饱和减法 |'
- en: '| `vpsubsb` | `xmm`[dest], `xmm`[src], `xmm`/`mem`[128] | 16-lane byte signed
    saturation subtraction |'
  id: totrans-629
  prefs: []
  type: TYPE_TB
  zh: '| `vpsubsb` | `xmm`[dest]，`xmm`[src]，`xmm`/`mem`[128] | 16通道字节带符号饱和减法 |'
- en: '| `vpsubsb` | `ymm`[dest], `ymm`[src], `ymm`/`mem`[256] | 32-lane byte signed
    saturation subtraction |'
  id: totrans-630
  prefs: []
  type: TYPE_TB
  zh: '| `vpsubsb` | `ymm`[dest]，`ymm`[src]，`ymm`/`mem`[256] | 32通道字节带符号饱和减法 |'
- en: '| `psubsw` | `xmm`[dest], `xmm`/`mem`[128] | 8-lane word signed saturation
    subtraction |'
  id: totrans-631
  prefs: []
  type: TYPE_TB
  zh: '| `psubsw` | `xmm`[dest]，`xmm`/`mem`[128] | 8通道字节带符号饱和减法 |'
- en: '| `vpsubsw` | `xmm`[dest], `xmm`[src], `xmm`/`mem`[128] | 8-lane word signed
    saturation subtraction |'
  id: totrans-632
  prefs: []
  type: TYPE_TB
  zh: '| `vpsubsw` | `xmm`[dest]，`xmm`[src]，`xmm`/`mem`[128] | 8通道字节带符号饱和减法 |'
- en: '| `vpsubsw` | `ymm`[dest], `ymm`[src], `ymm`/`mem`[256] | 16-lane word signed
    saturation subtraction |'
  id: totrans-633
  prefs: []
  type: TYPE_TB
  zh: '| `vpsubsw` | `ymm`[dest]，`ymm`[src]，`ymm`/`mem`[256] | 16通道字节带符号饱和减法 |'
- en: '| `psubusb` | `xmm`[dest], `xmm`/`mem`[128] | 16-lane byte unsigned saturation
    subtraction |'
  id: totrans-634
  prefs: []
  type: TYPE_TB
  zh: '| `psubusb` | `xmm`[dest]，`xmm`/`mem`[128] | 16通道字节无符号饱和减法 |'
- en: '| `vpsubusb` | `xmm`[dest], `xmm`[src], `xmm`/`mem`[128] | 16-lane byte unsigned
    saturation subtraction |'
  id: totrans-635
  prefs: []
  type: TYPE_TB
  zh: '| `vpsubusb` | `xmm`[dest]，`xmm`[src]，`xmm`/`mem`[128] | 16通道字节无符号饱和减法 |'
- en: '| `vpsubusb` | `ymm`[dest], `ymm`[src], `ymm`/`mem`[256] | 32-lane byte unsigned
    saturation subtraction |'
  id: totrans-636
  prefs: []
  type: TYPE_TB
  zh: '| `vpsubusb` | `ymm`[dest]，`ymm`[src]，`ymm`/`mem`[256] | 32通道字节无符号饱和减法 |'
- en: '| `psubusw` | `xmm`[dest], `xmm`/`mem`[128] | 8-lane word unsigned saturation
    subtraction |'
  id: totrans-637
  prefs: []
  type: TYPE_TB
  zh: '| `psubusw` | `xmm`[dest]，`xmm`/`mem`[128] | 8通道字节无符号饱和减法 |'
- en: '| `vpsubusw` | `xmm`[dest], `xmm`[src], `xmm`/`mem`[128] | 8-lane word unsigned
    saturation subtraction |'
  id: totrans-638
  prefs: []
  type: TYPE_TB
  zh: '| `vpsubusw` | `xmm`[dest]，`xmm`[src]，`xmm`/`mem`[128] | 8通道字节无符号饱和减法 |'
- en: '| `vpsubusw` | `ymm`[dest], `ymm`[src], `ymm`/`mem`[256] | 16-lane word unsigned
    saturation subtraction |'
  id: totrans-639
  prefs: []
  type: TYPE_TB
  zh: '| `vpsubusw` | `ymm`[dest]，`ymm`[src]，`ymm`/`mem`[256] | 16通道字节无符号饱和减法 |'
- en: 11.10.5 SIMD Integer Multiplication
  id: totrans-640
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 11.10.5 SIMD整数乘法
- en: The SSE/AVX instruction set extensions *somewhat* support multiplication. Lane-by-lane
    multiplication requires that the result of an operation on two *n*-bit values
    fits in *n* bits, but *n* × *n* multiplication can produce a 2×*n*-bit result.
    So a lane-by-lane multiplication operation creates problems as overflow is lost.
    The basic packed integer multiplication multiplies a pair of lanes and stores
    the LO bits of the result in the destination lane. For extended arithmetic, packed
    integer multiplication instructions produce the HO bits of the result.
  id: totrans-641
  prefs: []
  type: TYPE_NORMAL
  zh: SSE/AVX指令集扩展在一定程度上支持乘法。逐通道乘法要求两个*n*位值的操作结果能够适应*n*位，但是*n* × *n*的乘法可能会产生2×*n*位的结果。因此，逐通道乘法操作会出现溢出丢失的问题。基础的打包整数乘法将一对通道相乘，并将结果的低位存储到目标通道。对于扩展算术，打包整数乘法指令会生成结果的高位。
- en: The instructions in [Table 11-16](#table11-16) handle 16-bit multiplication
    operations. The `(v)pmullw` instruction multiplies the 16-bit values appearing
    in the lanes of the source operand and stores the LO word of the result into the
    corresponding destination lane. This instruction is applicable to both signed
    and unsigned values. The `(v)pmulhw` instruction computes the product of two signed
    word values and stores the *HO word* of the result into the destination lanes.
    For unsigned operands, `(v)pmulhuw` performs the same task. By executing both
    `(v)pmullw` and `(v)pmulh(u)w` with the same operands, you can compute the full
    32-bit result of a 16×16-bit multiplication. (You can use the `punpck*` instructions
    to merge the results into 32-bit integers.)
  id: totrans-642
  prefs: []
  type: TYPE_NORMAL
  zh: '[表 11-16](#table11-16)中的指令处理16位乘法操作。`(v)pmullw`指令将源操作数中的16位值进行相乘，并将结果的低位存储到相应的目标通道。该指令适用于带符号和无符号值。`(v)pmulhw`指令计算两个带符号字节值的乘积，并将结果的高位存储到目标通道。对于无符号操作数，`(v)pmulhuw`执行相同的操作。通过使用相同的操作数执行`(v)pmullw`和`(v)pmulh(u)w`，你可以计算16×16位乘法的完整32位结果。（你可以使用`punpck*`指令将结果合并为32位整数。）'
- en: 'Table 11-16: SIMD 16-Bit Packed Integer Multiplication Instructions'
  id: totrans-643
  prefs: []
  type: TYPE_NORMAL
  zh: 表 11-16：SIMD 16位打包整数乘法指令
- en: '| **Instruction** | **Operands** | **Description** |'
  id: totrans-644
  prefs: []
  type: TYPE_TB
  zh: '| **指令** | **操作数** | **描述** |'
- en: '| --- | --- | --- |'
  id: totrans-645
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| `pmullw` | `xmm`[dest], `xmm`/`mem`[128] | 8-lane word multiplication, producing
    the LO word of the product |'
  id: totrans-646
  prefs: []
  type: TYPE_TB
  zh: '| `pmullw` | `xmm`[dest]，`xmm`/`mem`[128] | 8通道字节乘法，生成乘积的低16位 |'
- en: '| `vpmullw` | `xmm`[dest], `xmm`[src], `xmm`/`mem`[128] | 8-lane word multiplication,
    producing the LO word of the product |'
  id: totrans-647
  prefs: []
  type: TYPE_TB
  zh: '| `vpmullw` | `xmm`[dest]，`xmm`[src]，`xmm`/`mem`[128] | 8通道字节乘法，生成乘积的低16位 |'
- en: '| `vpmullw` | `ymm`[dest], `ymm`[src], `ymm`/`mem`[256] | 16-lane word multiplication,
    producing the LO word of the product |'
  id: totrans-648
  prefs: []
  type: TYPE_TB
  zh: '| `vpmullw` | `ymm`[dest], `ymm`[src], `ymm`/`mem`[256] | 16 路 word 乘法，生成乘积的
    LO word |'
- en: '| `pmulhuw` | `xmm`[dest], `xmm`/`mem`[128] | 8-lane word unsigned multiplication,
    producing the HO word of the product |'
  id: totrans-649
  prefs: []
  type: TYPE_TB
  zh: '| `pmulhuw` | `xmm`[dest], `xmm`/`mem`[128] | 8 路 word 无符号乘法，生成乘积的 HO word
    |'
- en: '| `vpmulhuw` | `xmm`[dest], `xmm`[src], `xmm`/`mem`[128] | 8-lane word unsigned
    multiplication, producing the HO word of the product |'
  id: totrans-650
  prefs: []
  type: TYPE_TB
  zh: '| `vpmulhuw` | `xmm`[dest], `xmm`[src], `xmm`/`mem`[128] | 8 路 word 无符号乘法，生成乘积的
    HO word |'
- en: '| `vpmulhuw` | `ymm`[dest], `ymm`[src], `ymm`/`mem`[256] | 16-lane word unsigned
    multiplication, producing the HO word of the product |'
  id: totrans-651
  prefs: []
  type: TYPE_TB
  zh: '| `vpmulhuw` | `ymm`[dest], `ymm`[src], `ymm`/`mem`[256] | 16 路 word 无符号乘法，生成乘积的
    HO word |'
- en: '| `pmulhw` | `xmm`[dest], `xmm`/`mem`[128] | 8-lane word signed multiplication,
    producing the HO word of the product |'
  id: totrans-652
  prefs: []
  type: TYPE_TB
  zh: '| `pmulhw` | `xmm`[dest], `xmm`/`mem`[128] | 8 路 word 有符号乘法，生成乘积的 HO word |'
- en: '| `vpmulhw` | `xmm`[dest], `xmm`[src], `xmm`/`mem`[128] | 8-lane word signed
    multiplication, producing the HO word of the product |'
  id: totrans-653
  prefs: []
  type: TYPE_TB
  zh: '| `vpmulhw` | `xmm`[dest], `xmm`[src], `xmm`/`mem`[128] | 8 路 word 有符号乘法，生成乘积的
    HO word |'
- en: '| `vpmulhw` | `ymm`[dest], `ymm`[src], `ymm`/`mem`[256] | 16-lane word signed
    multiplication, producing the HO word of the product |'
  id: totrans-654
  prefs: []
  type: TYPE_TB
  zh: '| `vpmulhw` | `ymm`[dest], `ymm`[src], `ymm`/`mem`[256] | 16 路 word 有符号乘法，生成乘积的
    HO word |'
- en: '[Table 11-17](#table11-17) lists the 32- and 64-bit versions of the packed
    multiplication instructions. There are no `(v)pmulhd` or `(v)pmulhq` instructions;
    see `(v)pmuludq` and `(v)pmuldq` to handle 32- and 64-bit packed multiplication.'
  id: totrans-655
  prefs: []
  type: TYPE_NORMAL
  zh: '[表 11-17](#table11-17) 列出了 32 位和 64 位版本的打包乘法指令。没有 `(v)pmulhd` 或 `(v)pmulhq`
    指令；请参阅 `(v)pmuludq` 和 `(v)pmuldq` 以处理 32 位和 64 位打包乘法。'
- en: 'Table 11-17: SIMD 32- and 64-Bit Packed Integer Multiplication Instructions'
  id: totrans-656
  prefs: []
  type: TYPE_NORMAL
  zh: 表 11-17：SIMD 32 位和 64 位打包整数乘法指令
- en: '| **Instruction** | **Operands** | **Description** |'
  id: totrans-657
  prefs: []
  type: TYPE_TB
  zh: '| **指令** | **操作数** | **描述** |'
- en: '| --- | --- | --- |'
  id: totrans-658
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| `pmulld` | `xmm`[dest], `xmm`/`mem`[128] | 4-lane dword multiplication, producing
    the LO dword of the product |'
  id: totrans-659
  prefs: []
  type: TYPE_TB
  zh: '| `pmulld` | `xmm`[dest], `xmm`/`mem`[128] | 4 路 dword 乘法，生成乘积的 LO dword |'
- en: '| `vpmulld` | `xmm`[dest], `xmm`[src], `xmm`/`mem`[128] | 4-lane dword multiplication,
    producing the LO dword of the product |'
  id: totrans-660
  prefs: []
  type: TYPE_TB
  zh: '| `vpmulld` | `xmm`[dest], `xmm`[src], `xmm`/`mem`[128] | 4 路 dword 乘法，生成乘积的
    LO dword |'
- en: '| `vpmulld` | `ymm`[dest], `ymm`[src], `ymm`/`mem`[256] | 8-lane dword multiplication,
    producing the LO dword of the product |'
  id: totrans-661
  prefs: []
  type: TYPE_TB
  zh: '| `vpmulld` | `ymm`[dest], `ymm`[src], `ymm`/`mem`[256] | 8 路 dword 乘法，生成乘积的
    LO dword |'
- en: '| `vpmullq` | `xmm`[dest], `xmm`[src], `xmm`/`mem`[128] | 2-lane qword multiplication,
    producing the LO qword of the product |'
  id: totrans-662
  prefs: []
  type: TYPE_TB
  zh: '| `vpmullq` | `xmm`[dest], `xmm`[src], `xmm`/`mem`[128] | 2 路 qword 乘法，生成乘积的
    LO qword |'
- en: '| `vpmullq` | `ymm`[dest], `ymm`[src], `ymm`/`mem`[256] | 4-lane qword multiplication,
    producing the LO qword of the product (available on only AVX-512 CPUs) |'
  id: totrans-663
  prefs: []
  type: TYPE_TB
  zh: '| `vpmullq` | `ymm`[dest], `ymm`[src], `ymm`/`mem`[256] | 4 路 qword 乘法，生成乘积的
    LO qword（仅在 AVX-512 CPU 上可用） |'
- en: 'At some point along the way, Intel introduced `(v)pmuldq` and `(v)pmuludq`
    to perform signed and unsigned 32×32-bit multiplications, producing a 64-bit result.
    The syntax for these instructions is as follows:'
  id: totrans-664
  prefs: []
  type: TYPE_NORMAL
  zh: 在某个阶段，Intel 引入了 `(v)pmuldq` 和 `(v)pmuludq` 来执行有符号和无符号的 32×32 位乘法，生成一个 64 位的结果。这些指令的语法如下：
- en: '[PRE66]'
  id: totrans-665
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: The 128-bit variants multiply the double words appearing in lanes 0 and 2 and
    store the 64-bit results into qword lanes 0 and 1 (dword lanes 0 and 1 and 2 and
    3). On CPUs with AVX registers,^([11](#c11-footnote-11)) `pmuldq` and `pmuludq`
    do not affect the HO 128 bits of the YMM register. The `vpmuldq` and `vpmuludq`
    instructions zero-extend the result to 256 bits. The 256-bit variants multiply
    the double words appearing in lanes 0, 2, 4, and 6, producing 64-bit results that
    they store in qword lanes 0, 1, 2, and 3 (dword lanes 0 and 1, 2 and 3, 4 and
    5, and 6 and 7 ).
  id: totrans-666
  prefs: []
  type: TYPE_NORMAL
  zh: 128 位变体乘以位于 0 和 2 路的双字，并将 64 位结果存储到 qword 路 0 和 1（dword 路 0 和 1、2 和 3）。在具有 AVX
    寄存器的 CPU 上，^([11](#c11-footnote-11)) `pmuldq` 和 `pmuludq` 不影响 YMM 寄存器的高 128 位。`vpmuldq`
    和 `vpmuludq` 指令将结果扩展为 256 位。256 位变体乘以位于 0、2、4 和 6 路的双字，生成 64 位结果并将其存储到 qword 路
    0、1、2 和 3（dword 路 0 和 1、2 和 3、4 和 5、6 和 7）。
- en: 'The `pclmulqdq` instruction provides the ability to multiply two qword values,
    producing a 128-bit result. Here is the syntax for this instruction:'
  id: totrans-667
  prefs: []
  type: TYPE_NORMAL
  zh: '`pclmulqdq` 指令提供了乘以两个 qword 值的能力，生成一个 128 位的结果。该指令的语法如下：'
- en: '[PRE67]'
  id: totrans-668
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: These instructions multiply a pair of qword values found in XMM[dest] and XMM[src]
    and leave the 128-bit result in XMM[dest]. The imm[8] operand specifies which
    qwords to use as the source operands. [Table 11-18](#table11-18) lists the possible
    combinations for `pclmulqdq`. [Table 11-19](#table11-19) lists the combinations
    for `vpclmulqdq`.
  id: totrans-669
  prefs: []
  type: TYPE_NORMAL
  zh: 这些指令将 XMM[dest] 和 XMM[src] 中的 qword 值相乘，并将 128 位的结果保留在 XMM[dest] 中。imm[8] 操作数指定要用作源操作数的
    qword。`pclmulqdq` 的可能组合列在 [表 11-18](#table11-18) 中，`vpclmulqdq` 的组合列在 [表 11-19](#table11-19)
    中。
- en: 'Table 11-18: imm[8] Operand Values for `pclmulqdq` Instruction'
  id: totrans-670
  prefs: []
  type: TYPE_NORMAL
  zh: '表 11-18: `pclmulqdq` 指令的 imm[8] 操作数值'
- en: '| **imm[8]** | **Result** |'
  id: totrans-671
  prefs: []
  type: TYPE_TB
  zh: '| **imm[8]** | **结果** |'
- en: '| --- | --- |'
  id: totrans-672
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| 00h | XMM[dest] = XMM[dest][0 to 63] * XMM/mem[128][0 to 63] |'
  id: totrans-673
  prefs: []
  type: TYPE_TB
  zh: '| 00h | XMM[dest] = XMM[dest][0 到 63] * XMM/mem[128][0 到 63] |'
- en: '| 01h | XMM[dest] = XMM[dest][64 to 127] * XMM/mem[128][0 to 63] |'
  id: totrans-674
  prefs: []
  type: TYPE_TB
  zh: '| 01h | XMM[dest] = XMM[dest][64 到 127] * XMM/mem[128][0 到 63] |'
- en: '| 10h | XMM[dest] = XMM[dest][0 to 63] * XMM/mem[128][64 to 127] |'
  id: totrans-675
  prefs: []
  type: TYPE_TB
  zh: '| 10h | XMM[dest] = XMM[dest][0 到 63] * XMM/mem[128][64 到 127] |'
- en: '| 11h | XMM[dest] = XMM[dest][64 to 127] * XMM/mem[128][64 to 127] |'
  id: totrans-676
  prefs: []
  type: TYPE_TB
  zh: '| 11h | XMM[dest] = XMM[dest][64 到 127] * XMM/mem[128][64 到 127] |'
- en: 'Table 11-19: imm[8] Operand Values for `vpclmulqdq` Instruction'
  id: totrans-677
  prefs: []
  type: TYPE_NORMAL
  zh: '表 11-19: `vpclmulqdq` 指令的 imm[8] 操作数值'
- en: '| **imm[8]** | **Result** |'
  id: totrans-678
  prefs: []
  type: TYPE_TB
  zh: '| **imm[8]** | **结果** |'
- en: '| --- | --- |'
  id: totrans-679
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| 00h | XMM[dest] = XMM[src1][0 to 63] * XMM[src2]/mem[128][0 to 63] |'
  id: totrans-680
  prefs: []
  type: TYPE_TB
  zh: '| 00h | XMM[dest] = XMM[src1][0 到 63] * XMM[src2]/mem[128][0 到 63] |'
- en: '| 01h | XMM[dest] = XMM[src1][64 to 127] * XMM[src2]/mem[128][0 to 63] |'
  id: totrans-681
  prefs: []
  type: TYPE_TB
  zh: '| 01h | XMM[dest] = XMM[src1][64 到 127] * XMM[src2]/mem[128][0 到 63] |'
- en: '| 10h | XMM[dest] = XMM[src1][0 to 63] * XMM[src2]/mem[128][64 to 127] |'
  id: totrans-682
  prefs: []
  type: TYPE_TB
  zh: '| 10h | XMM[dest] = XMM[src1][0 到 63] * XMM[src2]/mem[128][64 到 127] |'
- en: '| 11h | XMM[dest] = XMM[src1][64 to 127] * XMM[src2]/mem[128][64 to 127] |'
  id: totrans-683
  prefs: []
  type: TYPE_TB
  zh: '| 11h | XMM[dest] = XMM[src1][64 到 127] * XMM[src2]/mem[128][64 到 127] |'
- en: As usual, `pclmulqdq` leaves the HO 128 bits of the corresponding YMM destination
    register unchanged, while `vpcmulqdq` zeroes those bits.
  id: totrans-684
  prefs: []
  type: TYPE_NORMAL
  zh: 像往常一样，`pclmulqdq` 会保持对应的 YMM 目标寄存器的高 128 位不变，而 `vpcmulqdq` 会将这些位清零。
- en: 11.10.6 SIMD Integer Averages
  id: totrans-685
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 11.10.6 SIMD 整数平均值
- en: 'The `(v)pavgb` and `(v)pavgw` instructions compute the average of two sets
    of bytes or words. These instructions sum the value in the byte or word lanes
    of their source and destination operands, divide the result by 2, round the results,
    and leave the averaged results sitting in the destination operand lanes. The syntax
    for these instructions is shown here:'
  id: totrans-686
  prefs: []
  type: TYPE_NORMAL
  zh: '`(v)pavgb` 和 `(v)pavgw` 指令计算两个字节或字的平均值。这些指令将源操作数和目标操作数中字节或字的值相加，然后将结果除以 2，四舍五入，并将平均结果存储在目标操作数的
    lane 中。这些指令的语法如下：'
- en: '[PRE68]'
  id: totrans-687
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: The 128-bit `pavgb` and `vpavgb` instructions compute 16 byte-sized averages
    (for the 16 lanes in the source and destination operands). The 256-bit variant
    of the `vpavgb` instruction computes 32 byte-sized averages.
  id: totrans-688
  prefs: []
  type: TYPE_NORMAL
  zh: 128 位的 `pavgb` 和 `vpavgb` 指令计算 16 个字节大小的平均值（针对源和目标操作数中的 16 个 lane）。`vpavgb`
    指令的 256 位变体计算 32 个字节大小的平均值。
- en: The 128-bit `pavgw` and `vpavgw` instructions compute eight word-sized averages
    (for the eight lanes in the source and destination operands). The 256-bit variant
    of the `vpavgw` instruction computes 16 byte-sized averages.
  id: totrans-689
  prefs: []
  type: TYPE_NORMAL
  zh: 128 位的 `pavgw` 和 `vpavgw` 指令计算 8 个字的平均值（针对源和目标操作数中的 8 个 lane）。`vpavgw` 指令的 256
    位变体计算 16 个字节大小的平均值。
- en: The `vpavgb` and `vpavgw` instructions compute the average of the first XMM
    or YMM source operand and the second XMM, YMM, or mem source operand, storing
    the average in the destination XMM or YMM register.
  id: totrans-690
  prefs: []
  type: TYPE_NORMAL
  zh: '`vpavgb` 和 `vpavgw` 指令计算第一个 XMM 或 YMM 源操作数和第二个 XMM、YMM 或内存源操作数的平均值，将平均结果存储在目标
    XMM 或 YMM 寄存器中。'
- en: Unfortunately, there are no `(v)pavgd` or `(v)pavgq` instructions. No doubt,
    these instructions were originally intended for mixing 8- and 16-bit audio or
    video streams (or photo manipulation), and the x86-64 CPU designers never felt
    the need to extend this beyond 16 bits (even though 24-bit audio is common among
    professional audio engineers).
  id: totrans-691
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，没有 `(v)pavgd` 或 `(v)pavgq` 指令。毫无疑问，这些指令最初是为了混合 8 位和 16 位的音频或视频流（或照片处理）而设计的，但
    x86-64 CPU 设计者从未认为有必要将其扩展到 16 位以上（尽管 24 位音频在专业音频工程师中很常见）。
- en: 11.10.7 SIMD Integer Minimum and Maximum
  id: totrans-692
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 11.10.7 SIMD 整数最小值和最大值
- en: The SSE4.1 instruction set extensions added eight packed integer *minimum* and
    *maximum* instructions, as shown in [Table 11-20](#table11-20). These instructions
    scan the lanes of a pair of 128- or 256-bit operands and copy the maximum or minimum
    value from that lane to the same lane in the destination operand.
  id: totrans-693
  prefs: []
  type: TYPE_NORMAL
  zh: SSE4.1 指令集扩展添加了八个打包的整数 *最小值* 和 *最大值* 指令，如 [表 11-20](#table11-20) 所示。这些指令扫描一对
    128 位或 256 位操作数的各个 lane，并将最大值或最小值从该 lane 复制到目标操作数的相同 lane。
- en: 'Table 11-20: SIMD Minimum and Maximum Instructions'
  id: totrans-694
  prefs: []
  type: TYPE_NORMAL
  zh: 表11-20：SIMD最小值和最大值指令
- en: '| **Instruction** | **Description** |'
  id: totrans-695
  prefs: []
  type: TYPE_TB
  zh: '| **指令** | **描述** |'
- en: '| --- | --- |'
  id: totrans-696
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `(v)``pmaxsb` | Destination byte lanes set to the maximum value of the two
    signed byte values found in the corresponding source lanes. |'
  id: totrans-697
  prefs: []
  type: TYPE_TB
  zh: '| `(v)``pmaxsb` | 目标字节通道设置为在相应源通道中找到的两个有符号字节值的最大值。 |'
- en: '| `(v)``pmaxsw` | Destination word lanes set to the maximum value of the two
    signed word values found in the corresponding source lanes. |'
  id: totrans-698
  prefs: []
  type: TYPE_TB
  zh: '| `(v)``pmaxsw` | 目标字通道设置为在相应源通道中找到的两个有符号字值的最大值。 |'
- en: '| `(v)``pmaxsd` | Destination dword lanes set to the maximum value of the two
    signed dword values found in the corresponding source lanes. |'
  id: totrans-699
  prefs: []
  type: TYPE_TB
  zh: '| `(v)``pmaxsd` | 目标双字通道设置为在相应源通道中找到的两个有符号双字值的最大值。 |'
- en: '| `v``pmaxsq` | Destination qword lanes set to the maximum value of the two
    signed qword values found in the corresponding source lanes. (AVX-512 required
    for this instruction.) |'
  id: totrans-700
  prefs: []
  type: TYPE_TB
  zh: '| `v``pmaxsq` | 目标四字通道设置为在相应源通道中找到的两个有符号四字值的最大值。（此指令需要AVX-512支持。） |'
- en: '| `(v)``pmaxub` | Destination byte lanes set to the maximum value of the two
    unsigned byte values found in the corresponding source lanes. |'
  id: totrans-701
  prefs: []
  type: TYPE_TB
  zh: '| `(v)``pmaxub` | 目标字节通道设置为在相应源通道中找到的两个无符号字节值的最大值。 |'
- en: '| `(v)``pmaxuw` | Destination word lanes set to the maximum value of the two
    unsigned word values found in the corresponding source lanes. |'
  id: totrans-702
  prefs: []
  type: TYPE_TB
  zh: '| `(v)``pmaxuw` | 目标字通道设置为在相应源通道中找到的两个无符号字值的最大值。 |'
- en: '| `(v)``pmaxud` | Destination dword lanes set to the maximum value of the two
    unsigned dword values found in the corresponding source lanes. |'
  id: totrans-703
  prefs: []
  type: TYPE_TB
  zh: '| `(v)``pmaxud` | 目标双字通道设置为在相应源通道中找到的两个无符号双字值的最大值。 |'
- en: '| `v``pmaxuq` | Destination qword lanes set to the maximum value of the two
    unsigned qword values found in the corresponding source lanes. (AVX-512 required
    for this instruction.) |'
  id: totrans-704
  prefs: []
  type: TYPE_TB
  zh: '| `v``pmaxuq` | 目标四字通道设置为在相应源通道中找到的两个无符号四字值的最大值。（此指令需要AVX-512支持。） |'
- en: '| `(v)``pminsb` | Destination byte lanes set to the minimum value of the two
    signed byte values found in the corresponding source lanes. |'
  id: totrans-705
  prefs: []
  type: TYPE_TB
  zh: '| `(v)``pminsb` | 目标字节通道设置为在相应源通道中找到的两个有符号字节值的最小值。 |'
- en: '| `(v)``pminsw` | Destination word lanes set to the minimum value of the two
    signed word values found in the corresponding source lanes. |'
  id: totrans-706
  prefs: []
  type: TYPE_TB
  zh: '| `(v)``pminsw` | 目标字通道设置为在相应源通道中找到的两个有符号字值的最小值。 |'
- en: '| `(v)``pminsd` | Destination dword lanes set to the minimum value of the two
    signed dword values found in the corresponding source lanes. |'
  id: totrans-707
  prefs: []
  type: TYPE_TB
  zh: '| `(v)``pminsd` | 目标双字通道设置为在相应源通道中找到的两个有符号双字值的最小值。 |'
- en: '| `v``pminsq` | Destination qword lanes set to the minimum value of the two
    signed qword values found in the corresponding source lanes. (AVX-512- required
    for this instruction.) |'
  id: totrans-708
  prefs: []
  type: TYPE_TB
  zh: '| `v``pminsq` | 目标四字通道设置为在相应源通道中找到的两个有符号四字值的最小值。（此指令需要AVX-512支持。） |'
- en: '| `(v)``pminub` | Destination byte lanes set to the minimum value of the two
    unsigned byte values found in the corresponding source lanes. |'
  id: totrans-709
  prefs: []
  type: TYPE_TB
  zh: '| `(v)``pminub` | 目标字节通道设置为在相应源通道中找到的两个无符号字节值的最小值。 |'
- en: '| `(v)``pminuw` | Destination word lanes set to the minimum value of the two
    unsigned word values found in the corresponding source lanes. |'
  id: totrans-710
  prefs: []
  type: TYPE_TB
  zh: '| `(v)``pminuw` | 目标字通道设置为在相应源通道中找到的两个无符号字值的最小值。 |'
- en: '| `(v)``pminud` | Destination dword lanes set to the minimum value of the two
    unsigned dword values found in the corresponding source lanes. |'
  id: totrans-711
  prefs: []
  type: TYPE_TB
  zh: '| `(v)``pminud` | 目标双字通道设置为在相应源通道中找到的两个无符号双字值的最小值。 |'
- en: '| `v``pminuq` | Destination qword lanes set to the minimum value of the two
    unsigned qword values found in the corresponding source lanes. (AVX-512 required
    for this instruction.) |'
  id: totrans-712
  prefs: []
  type: TYPE_TB
  zh: '| `v``pminuq` | 目标四字通道设置为在相应源通道中找到的两个无符号四字值的最小值。（此指令需要AVX-512支持。） |'
- en: The generic syntax for these instructions is as follows:^([12](#c11-footnote-12))
  id: totrans-713
  prefs: []
  type: TYPE_NORMAL
  zh: 这些指令的通用语法如下：^([12](#c11-footnote-12))
- en: '[PRE69]'
  id: totrans-714
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: The SSE instructions compute the minimum or maximum of the corresponding lanes
    in the source and destination operands and store the minimum or maximum result
    into the corresponding lanes in the destination register. The AVX instructions
    compute the minimum or maximum of the values in the same lanes of the two source
    operands and store the minimum or maximum result into the corresponding lanes
    of the destination register.
  id: totrans-715
  prefs: []
  type: TYPE_NORMAL
  zh: SSE 指令计算源操作数和目标操作数对应通道的最小值或最大值，并将最小值或最大值结果存储到目标寄存器对应通道中。AVX 指令计算两个源操作数相同通道中的最小值或最大值，并将最小值或最大值结果存储到目标寄存器对应通道中。
- en: 11.10.8 SIMD Integer Absolute Value
  id: totrans-716
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 11.10.8 SIMD 整数绝对值
- en: 'The SSE/AVX instruction set extensions provide three sets of instructions for
    computing the absolute values of signed byte, word, and double-word integers:
    `(v)pabsb`, `(v)pabsw`, and `(v)pabsd`.^([13](#c11-footnote-13)) The syntax for
    these instructions is the following:'
  id: totrans-717
  prefs: []
  type: TYPE_NORMAL
  zh: SSE/AVX 指令集扩展提供了三组用于计算有符号字节、字和双字整数绝对值的指令：`(v)pabsb`、`(v)pabsw` 和 `(v)pabsd`。^([13](#c11-footnote-13))
    这些指令的语法如下：
- en: '[PRE70]'
  id: totrans-718
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: When operating on a system that supports AVX registers, the SSE `pabsb`, `pabsw`,
    and `pabsd` instructions leave the upper bits of the YMM registers unmodified.
    The 128-bit versions of the AVX instructions (`vpabsb`, `vpabsw`, and `vpabsd`)
    zero-extend the result through the upper bits.
  id: totrans-719
  prefs: []
  type: TYPE_NORMAL
  zh: 在支持 AVX 寄存器的系统上，SSE `pabsb`、`pabsw` 和 `pabsd` 指令不会修改 YMM 寄存器的高位。AVX 指令的 128
    位版本（`vpabsb`、`vpabsw` 和 `vpabsd`）会将结果零扩展到高位。
- en: 11.10.9 SIMD Integer Sign Adjustment Instructions
  id: totrans-720
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 11.10.9 SIMD 整数符号调整指令
- en: 'The `(v)psignb`, `(v)psignw`, and `(v)psignd` instructions apply the sign found
    in a source lane to the corresponding destination lane. The algorithm works as
    follows:'
  id: totrans-721
  prefs: []
  type: TYPE_NORMAL
  zh: '`(v)psignb`、`(v)psignw` 和 `(v)psignd` 指令将源通道中找到的符号应用到相应的目标通道。其算法如下：'
- en: '[PRE71]'
  id: totrans-722
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'The syntax for these instructions is the following:'
  id: totrans-723
  prefs: []
  type: TYPE_NORMAL
  zh: 这些指令的语法如下：
- en: '[PRE72]'
  id: totrans-724
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: As usual, the 128-bit SSE instructions leave the upper bits of the YMM register
    unchanged (if applicable), and the 128-bit AVX instructions zero-extend the result
    into the upper bits of the YMM register.
  id: totrans-725
  prefs: []
  type: TYPE_NORMAL
  zh: 和往常一样，128 位 SSE 指令不会修改 YMM 寄存器的高位（如果适用），而 128 位 AVX 指令将结果零扩展到 YMM 寄存器的高位。
- en: 11.10.10 SIMD Integer Comparison Instructions
  id: totrans-726
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 11.10.10 SIMD 整数比较指令
- en: The `(v)pcmpeqb`, `(v)pcmpeqw`, `(v)pcmpeqd`, `(v)pcmpeqq`, `(v)pcmpgtb`, `(v)pcmpgtw`,
    `(v)pcmpgtd`, and `(v)pcmpgtq` instructions provide packed signed integer comparisons.
    These instructions compare corresponding bytes, word, dwords, or qwords (depending
    on the instruction suffix) in the various lanes of their operands.^([14](#c11-footnote-14))
    They store the result of the comparison instruction in the corresponding destination
    lanes.
  id: totrans-727
  prefs: []
  type: TYPE_NORMAL
  zh: '`(v)pcmpeqb`、`(v)pcmpeqw`、`(v)pcmpeqd`、`(v)pcmpeqq`、`(v)pcmpgtb`、`(v)pcmpgtw`、`(v)pcmpgtd`
    和 `(v)pcmpgtq` 指令提供打包的有符号整数比较。这些指令在其操作数的各个通道中比较对应的字节、字、双字或四字（取决于指令后缀）。^([14](#c11-footnote-14))
    它们将比较指令的结果存储到对应的目标通道中。'
- en: 11.10.10.1 SSE Compare-for-Equality Instructions
  id: totrans-728
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 11.10.10.1 SSE 等值比较指令
- en: 'The syntax for the SSE *compare-for-equality* instructions (`pcmpeq*`) is shown
    here:'
  id: totrans-729
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是 SSE *相等比较* 指令（`pcmpeq*`）的语法：
- en: '[PRE73]'
  id: totrans-730
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: These instructions compute
  id: totrans-731
  prefs: []
  type: TYPE_NORMAL
  zh: 这些指令计算
- en: '[PRE74]'
  id: totrans-732
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: where `lane` varies from 0 to 15 for `pcmpeqb`, 0 to 7 for `pcmpeqw`, 0 to 3
    for `pcmpeqd`, and 0 to 1 for `pcmpeqq`. The `==` operator produces a value of
    all 1 bits if the two values in the same lane are equal; it produces all 0 bits
    if the values are not equal.
  id: totrans-733
  prefs: []
  type: TYPE_NORMAL
  zh: 其中，`lane` 对于 `pcmpeqb` 为 0 到 15，`pcmpeqw` 为 0 到 7，`pcmpeqd` 为 0 到 3，`pcmpeqq`
    为 0 到 1。如果两个值在同一通道中相等，`==` 运算符会产生全为 1 的值；如果值不相等，则会产生全为 0 的值。
- en: 11.10.10.2 SSE Compare-for-Greater-Than Instructions
  id: totrans-734
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 11.10.10.2 SSE 大于比较指令
- en: 'The following is the syntax for the SSE *compare-for-greater-than* instructions
    (`pcmpgt*`):'
  id: totrans-735
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是 SSE *大于比较* 指令（`pcmpgt*`）的语法：
- en: '[PRE75]'
  id: totrans-736
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: These instructions compute
  id: totrans-737
  prefs: []
  type: TYPE_NORMAL
  zh: 这些指令计算
- en: '[PRE76]'
  id: totrans-738
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: where `lane` is the same as for the compare-for-equality instructions, and the
    `>` operator produces a value of all 1 bits if the signed integer in the XMM[dest]
    lane is greater than the signed value in the corresponding XMM[src]/MEM[128] lane.
  id: totrans-739
  prefs: []
  type: TYPE_NORMAL
  zh: 其中，`lane` 与比较相等指令中的相同，`>` 运算符当 XMM[dest] 通道中的有符号整数大于对应 XMM[src]/MEM[128] 通道中的有符号值时，产生全为
    1 的值。
- en: On AVX-capable CPUs, the SSE packed integer comparisons preserve the value in
    the upper bits of the underlying YMM register.
  id: totrans-740
  prefs: []
  type: TYPE_NORMAL
  zh: 在支持 AVX 的 CPU 上，SSE 打包整数比较保留底层 YMM 寄存器的高位值。
- en: 11.10.10.3 AVX Comparison Instructions
  id: totrans-741
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 11.10.10.3 AVX 比较指令
- en: 'The 128-bit variants of these instructions have the following syntax:'
  id: totrans-742
  prefs: []
  type: TYPE_NORMAL
  zh: 这些指令的128位变体具有以下语法：
- en: '[PRE77]'
  id: totrans-743
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: 'These instructions compute as follows:'
  id: totrans-744
  prefs: []
  type: TYPE_NORMAL
  zh: 这些指令的计算如下：
- en: '[PRE78]'
  id: totrans-745
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: These AVX instructions write 0s to the upper bits of the underlying YMM register.
  id: totrans-746
  prefs: []
  type: TYPE_NORMAL
  zh: 这些AVX指令将0写入底层YMM寄存器的高位。
- en: 'The 256-bit variants of these instructions have the following syntax:'
  id: totrans-747
  prefs: []
  type: TYPE_NORMAL
  zh: 这些指令的256位变体具有以下语法：
- en: '[PRE79]'
  id: totrans-748
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: 'These instructions compute as follows:'
  id: totrans-749
  prefs: []
  type: TYPE_NORMAL
  zh: 这些指令的计算如下：
- en: '[PRE80]'
  id: totrans-750
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: Of course, the principal difference between the 256- and the 128-bit instructions
    is that the 256-bit variants support twice as many byte (32), word (16), dword
    (8), and qword (4) signed-integer lanes.
  id: totrans-751
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，256位和128位指令的主要区别在于，256位变体支持更多的字节（32）、字（16）、双字（8）和四字（4）有符号整数通道。
- en: 11.10.10.4 Compare-for-Less-Than Instructions
  id: totrans-752
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 11.10.10.4 比较小于指令
- en: There are no packed *compare-for-less-than* instructions. You can synthesize
    a less-than comparison by reversing the operands and using a greater-than comparison.
    That is, if *x* < *y*, then it is also true that *y* > *x*. If both packed operands
    are sitting in XMM or YMM registers, swapping the registers is relatively easy
    (especially when using the three-operand AVX instructions). If the second operand
    is a memory operand, you must first load that operand into a register so you can
    reverse the operands (a memory operand must always be the second operand).
  id: totrans-753
  prefs: []
  type: TYPE_NORMAL
  zh: 没有打包的*比较小于*指令。你可以通过交换操作数并使用大于比较来合成小于比较。也就是说，如果*x* < *y*，那么*y* > *x*也成立。如果两个打包操作数都在XMM或YMM寄存器中，交换寄存器是相对容易的（特别是在使用三操作数AVX指令时）。如果第二个操作数是内存操作数，你必须首先将该操作数加载到寄存器中，以便你可以交换操作数（内存操作数必须始终是第二个操作数）。
- en: 11.10.10.5 Using Packed Comparison Results
  id: totrans-754
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 11.10.10.5 使用打包比较结果
- en: The question remains of what to do with the result you obtain from a packed
    comparison. SSE/AVX packed signed integer comparisons do not affect condition
    code flags (because they compare multiple values and only one of those comparisons
    could be moved into the flags). Instead, the packed comparisons simply produce
    Boolean results. You can use these results with the packed AND instructions (`pand`,
    `vpand`, `pandn`, and `vpandn`), the packed OR instructions (`por` and `vpor`),
    or the packed XOR instructions (`pxor` and `vpxor`) to mask or otherwise modify
    other packed data values. Of course, you could also extract the individual lane
    values and test them (via a conditional jump). The following section describes
    a straightforward way to achieve this.
  id: totrans-755
  prefs: []
  type: TYPE_NORMAL
  zh: 问题仍然是如何处理从打包比较中获得的结果。SSE/AVX打包的有符号整数比较不会影响条件码标志（因为它们比较多个值，而这些比较中只有一个可能被移入标志位）。相反，打包比较仅仅产生布尔结果。你可以使用这些结果与打包AND指令（`pand`、`vpand`、`pandn`、`vpandn`）、打包OR指令（`por`和`vpor`）或打包XOR指令（`pxor`和`vpxor`）来屏蔽或修改其他打包数据值。当然，你也可以提取单个通道值并通过条件跳转进行测试。以下部分描述了一种实现此目标的简便方法。
- en: 11.10.10.6 The (v)pmovmskb Instructions
  id: totrans-756
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 11.10.10.6 （v）pmovmskb指令
- en: The `(v)pmovmskb` instruction extracts the HO bit from all the bytes in an XMM
    or YMM register and stores the 16 or 32 bits (respectively) into a general-purpose
    register. These instructions set all HO bits of the general-purpose register to
    0 (beyond those needed to hold the mask bits). The syntax is
  id: totrans-757
  prefs: []
  type: TYPE_NORMAL
  zh: '`(v)pmovmskb`指令从XMM或YMM寄存器中的所有字节提取HO位，并将16位或32位（分别）存储到通用寄存器中。这些指令将通用寄存器中的所有HO位设置为0（除了用于存放掩码位的那些位）。语法如下：'
- en: '[PRE81]'
  id: totrans-758
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: where `reg` is any 32-bit or 64-bit general-purpose integer register. The semantics
    for the `pmovmskb` and `vpmovmskb` instructions with an XMM source register are
    the same, but the encoding of `pmovmskb` is more efficient.
  id: totrans-759
  prefs: []
  type: TYPE_NORMAL
  zh: 其中，`reg`是任何32位或64位的通用整数寄存器。`pmovmskb`和`vpmovmskb`指令在XMM源寄存器中的语义相同，但`pmovmskb`的编码更为高效。
- en: The `(v)pmovmskb` instruction copies the sign bits from each of the byte lanes
    into the corresponding bit position of the general-purpose register. It copies
    bit 7 from the XMM register (the sign bit for lane 0) into bit 0 of the destination
    register; it copies bit 15 from the XMM register (the sign bit for lane 1) into
    bit 1 of the destination register; it copies bit 23 from the XMM register (the
    sign bit for lane 2) into bit 2 of the destination register; and so on.
  id: totrans-760
  prefs: []
  type: TYPE_NORMAL
  zh: '`(v)pmovmskb`指令将每个字节通道的符号位复制到通用寄存器的相应位置。它将XMM寄存器中的位7（通道0的符号位）复制到目标寄存器的位0；它将XMM寄存器中的位15（通道1的符号位）复制到目标寄存器的位1；它将XMM寄存器中的位23（通道2的符号位）复制到目标寄存器的位2；以此类推。'
- en: The 128-bit instructions fill only bits 0 through 15 of the destination register
    (zeroing out all other bits). The 256-bit form of the `vpmovmskb` instruction
    fills bits 0 through 31 of the destination register (zeroing out HO bits if you
    specify a 64-bit register).
  id: totrans-761
  prefs: []
  type: TYPE_NORMAL
  zh: 128位指令仅填充目标寄存器的第0至第15位（将所有其他位清零）。`vpmovmskb`指令的256位形式填充目标寄存器的第0至第31位（如果指定64位寄存器，则清零高位）。
- en: 'You can use the `pmovmskb` instruction to extract a single bit from each byte
    lane in an XMM or a YMM register after a `(v)pcmpeqb` or `(v)pcmpgtb` instruction.
    Consider the following code sequence:'
  id: totrans-762
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用`pmovmskb`指令，在执行`(v)pcmpeqb`或`(v)pcmpgtb`指令后，从XMM或YMM寄存器中的每个字节通道提取单个位。考虑以下代码序列：
- en: '[PRE82]'
  id: totrans-763
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: After the execution of these two instructions, EAX bit 0 will be 1 or 0 if byte
    0 of XMM0 was equal, or not equal, to byte 0 of XMM1, respectively. Likewise,
    EAX bit 1 will contain the result of comparing byte 1 of XMM0 to XMM1, and so
    on for each of the following bytes (up to bit 15, which compares 16-byte values
    in XMM0 and XMM1).
  id: totrans-764
  prefs: []
  type: TYPE_NORMAL
  zh: 在执行这两个指令后，如果XMM0的字节0与XMM1的字节0相等或不相等，EAX的第0位将分别为1或0。同样，EAX的第1位将包含比较XMM0字节1和XMM1字节1的结果，以此类推，直到第15位，它比较XMM0和XMM1的16字节值。
- en: 'Unfortunately, there are no `pmovmskw`, `pmovmskd`, and `pmovmsq` instructions.
    You can achieve the same result as `pmovmskw` by using the following code sequence:'
  id: totrans-765
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，`pmovmskw`、`pmovmskd`和`pmovmsq`指令并不存在。你可以通过使用以下代码序列来实现与`pmovmskw`相同的效果：
- en: '[PRE83]'
  id: totrans-766
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: 'Because `pcmpeqw` produces a sequence of words (which contain either 0000h
    or 0FFFFh) and `pmovmskb` expects byte values, `pmovmskb` produces twice as many
    results as we expect, and every odd-numbered bit that `pmovmskb` produces is a
    duplicate of the preceding even-numbered bit (because the inputs are either 0000h
    or 0FFFFh). This code grabs every odd-numbered bit (starting with bit 15 and working
    down) and skips over the even-numbered bits. While this code is easy enough to
    follow, it is rather long and slow. If you’re willing to live with an 8-bit result
    for which the lane numbers don’t match the bit numbers, you can use more efficient
    code:'
  id: totrans-767
  prefs: []
  type: TYPE_NORMAL
  zh: 由于`pcmpeqw`产生的是一个包含0000h或0FFFFh的字序列，而`pmovmskb`期望的是字节值，`pmovmskb`生成的结果是预期的两倍，每个奇数位都是前一个偶数位的重复（因为输入值要么是0000h，要么是0FFFFh）。这段代码会获取每个奇数位（从第15位开始并向下），跳过偶数位。虽然这段代码足够简单，但它相对较长且速度较慢。如果你愿意接受一个8位的结果，其中通道编号与位编号不匹配，你可以使用更高效的代码：
- en: '[PRE84]'
  id: totrans-768
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: This interleaves the lanes in the bit positions as shown in [Figure 11-44](#figure11-44).
    Usually, it’s easy enough to work around this rearrangement in the software. Of
    course, you can also use a 256-entry lookup table (see Chapter 10) to rearrange
    the bits however you desire. Of course, if you’re just going to test the individual
    bits rather than use them as some sort of mask, you can directly test the bits
    that `pmovmskb` leaves in EAX; you don’t have to coalesce them into a single byte.
  id: totrans-769
  prefs: []
  type: TYPE_NORMAL
  zh: 这会将位按照[图11-44](#figure11-44)中所示的方式交错排列。通常，处理这个重新排列在软件中是足够容易的。当然，你也可以使用256项查找表（见第10章）按你希望的方式重新排列这些位。当然，如果你只需要测试单个比特，而不是将其作为某种掩码使用，你可以直接测试`pmovmskb`保留在EAX中的位；无需将它们合并成一个字节。
- en: '![f11044](image_fi/501089c11/f11044.png)'
  id: totrans-770
  prefs: []
  type: TYPE_IMG
  zh: '![f11044](image_fi/501089c11/f11044.png)'
- en: 'Figure 11-44: Merging bits from `pcmpeqw`'
  id: totrans-771
  prefs: []
  type: TYPE_NORMAL
  zh: 图11-44：从`pcmpeqw`合并位
- en: When using the double-word or quad-word packed comparisons, you could also use
    a scheme such as the one provided here for `pcmpeqw`. However, the floating-point
    mask move instructions (see “The (v)movmskps, (v)movmskpd Instructions” on page
    676) do the job more efficiently by breaking the rule about using SIMD instructions
    that are appropriate for the data type.
  id: totrans-772
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用双字或四字打包比较时，你也可以使用类似于此处为`pcmpeqw`提供的方案。然而，浮点掩码移动指令（见“(v)movmskps, (v)movmskpd指令”第676页）通过打破使用适合数据类型的SIMD指令的规则，能更高效地完成这项工作。
- en: 11.10.11 Integer Conversions
  id: totrans-773
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 11.10.11 整数转换
- en: The SSE and AVX instruction set extensions provide various instructions that
    convert integer values from one form to another. There are zero- and sign-extension
    instructions that convert from a smaller value to a larger one. Other instructions
    convert larger values to smaller ones. This section covers these instructions.
  id: totrans-774
  prefs: []
  type: TYPE_NORMAL
  zh: SSE和AVX指令集扩展提供了多种指令，用于将整数值从一种形式转换为另一种形式。有零扩展和符号扩展指令，用于将较小的值转换为较大的值。其他指令则用于将较大的值转换为较小的值。本节将介绍这些指令。
- en: 11.10.11.1 Packed Zero-Extension Instructions
  id: totrans-775
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 11.10.11.1 打包零扩展指令
- en: The *move with zero-extension* instructions perform the conversions appearing
    in [Table 11-21](#table11-21).
  id: totrans-776
  prefs: []
  type: TYPE_NORMAL
  zh: '*带零扩展的移动*指令执行在 [表 11-21](#table11-21) 中出现的转换。'
- en: 'Table 11-21: SSE4.1 and AVX Packed Zero-Extension Instructions'
  id: totrans-777
  prefs: []
  type: TYPE_NORMAL
  zh: 表 11-21：SSE4.1 和 AVX 打包零扩展指令
- en: '| **Syntax** | **Description** |'
  id: totrans-778
  prefs: []
  type: TYPE_TB
  zh: '| **语法** | **描述** |'
- en: '| --- | --- |'
  id: totrans-779
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `pmovzxbw` `xmm`[dest]`,` `xmm`[src]`/``mem`[64] | Zero-extends a set of
    eight byte values in the LO 8 bytes of XMM[src]/mem[64] to word values in XMM[dest].
    |'
  id: totrans-780
  prefs: []
  type: TYPE_TB
  zh: '| `pmovzxbw` `xmm`[dest]`,` `xmm`[src]`/``mem`[64] | 将 XMM[src]/mem[64] 中低
    8 字节的八个字节值零扩展为 XMM[dest] 中的字值。 |'
- en: '| `pmovzxbd` `xmm`[dest]`,` `xmm`[src]`/``mem`[32] | Zero-extends a set of
    four byte values in the LO 4 bytes of XMM[src]/mem[32] to dword values in XMM[dest].
    |'
  id: totrans-781
  prefs: []
  type: TYPE_TB
  zh: '| `pmovzxbd` `xmm`[dest]`,` `xmm`[src]`/``mem`[32] | 将 XMM[src]/mem[32] 中低
    4 字节的四个字节值零扩展为 XMM[dest] 中的双字值。 |'
- en: '| `pmovzxbq` `xmm`[dest]`,` `xmm`[src]`/``mem`[16] | Zero-extends a set of
    two byte values in the LO 2 bytes of XMM[src]/mem[16] to qword values in XMM[dest].
    |'
  id: totrans-782
  prefs: []
  type: TYPE_TB
  zh: '| `pmovzxbq` `xmm`[dest]`,` `xmm`[src]`/``mem`[16] | 将 XMM[src]/mem[16] 中低
    2 字节的两个字节值零扩展为 XMM[dest] 中的四字值。 |'
- en: '| `pmovzxwd` `xmm`[dest]`,` `xmm`[src]`/``mem`[64] | Zero-extends a set of
    four word values in the LO 8 bytes of XMM[src]/mem[64] to dword values in XMM[dest].
    |'
  id: totrans-783
  prefs: []
  type: TYPE_TB
  zh: '| `pmovzxwd` `xmm`[dest]`,` `xmm`[src]`/``mem`[64] | 将 XMM[src]/mem[64] 中低
    8 字节的四个字值零扩展为 XMM[dest] 中的双字值。 |'
- en: '| `pmovzxwq` `xmm`[dest]`,` `xmm`[src]`/``mem`[32] | Zero-extends a set of
    two word values in the LO 4 bytes of XMM[src]/mem[32] to qword values in XMM[dest].
    |'
  id: totrans-784
  prefs: []
  type: TYPE_TB
  zh: '| `pmovzxwq` `xmm`[dest]`,` `xmm`[src]`/``mem`[32] | 将 XMM[src]/mem[32] 中低
    4 字节的两个字值零扩展为 XMM[dest] 中的四字值。 |'
- en: '| `pmovzxdq` `xmm`[dest]`,` `xmm`[src]`/``mem`[64] | Zero-extends a set of
    two dword values in the LO 8 bytes of XMM[src]/mem[64] to qword values in XMM[dest].
    |'
  id: totrans-785
  prefs: []
  type: TYPE_TB
  zh: '| `pmovzxdq` `xmm`[dest]`,` `xmm`[src]`/``mem`[64] | 将 XMM[src]/mem[64] 中低
    8 字节的两个双字值零扩展为 XMM[dest] 中的四字值。 |'
- en: A set of comparable AVX instructions also exists (same syntax, but with a `v`
    prefix on the instruction mnemonics). The difference, as usual, is that the SSE
    instructions leave the upper bits of the YMM register unchanged, whereas the AVX
    instructions store 0s into the upper bits of the YMM registers.
  id: totrans-786
  prefs: []
  type: TYPE_NORMAL
  zh: 一组可比的 AVX 指令也存在（语法相同，但指令助记符前有 `v` 前缀）。如同往常一样，SSE 指令会保持 YMM 寄存器的上位比特不变，而 AVX
    指令会将 0 存储到 YMM 寄存器的上位比特中。
- en: The AVX2 instruction set extensions double the number of lanes by allowing the
    use of the YMM registers. They take similar operands to the SSE/AVX instructions
    (substituting YMM for the destination register and doubling the size of the memory
    locations) and process twice the number of lanes to produce sixteen words, eight
    dwords, or four qwords in a YMM destination register. See [Table 11-22](#table11-22)
    for details.
  id: totrans-787
  prefs: []
  type: TYPE_NORMAL
  zh: AVX2 指令集扩展通过允许使用 YMM 寄存器来加倍通道数。它们与 SSE/AVX 指令采用相似的操作数（将 YMM 替换为目标寄存器，并加倍内存位置的大小），并处理两倍数量的通道，以在
    YMM 目标寄存器中生成十六个字、八个双字或四个四字。有关详细信息，请参见 [表 11-22](#table11-22)。
- en: 'Table 11-22: AVX2 Packed Zero-Extension Instructions'
  id: totrans-788
  prefs: []
  type: TYPE_NORMAL
  zh: 表 11-22：AVX2 打包零扩展指令
- en: '| **Syntax** | **Description** |'
  id: totrans-789
  prefs: []
  type: TYPE_TB
  zh: '| **语法** | **描述** |'
- en: '| --- | --- |'
  id: totrans-790
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `v``pmovzxbw` `ymm`[dest]`,` `xmm`[src]`/``mem`[128] | Zero-extends a set
    of sixteen byte values in the LO 16 bytes of XMM[src]/mem[128] to word values
    in YMM[dest]. |'
  id: totrans-791
  prefs: []
  type: TYPE_TB
  zh: '| `v``pmovzxbw` `ymm`[dest]`,` `xmm`[src]`/``mem`[128] | 将 XMM[src]/mem[128]
    中低 16 字节的十六个字节值零扩展为 YMM[dest] 中的字值。 |'
- en: '| `v``pmovzxbd` `ymm`[dest]`,` `xmm`[src]`/``mem`[64] | Zero-extends a set
    of eight byte values in the LO 8 bytes of XMM[src]/mem[64] to dword values in
    YMM[dest]. |'
  id: totrans-792
  prefs: []
  type: TYPE_TB
  zh: '| `v``pmovzxbd` `ymm`[dest]`,` `xmm`[src]`/``mem`[64] | 将 XMM[src]/mem[64]
    中低 8 字节的八个字节值零扩展为 YMM[dest] 中的双字值。 |'
- en: '| `v``pmovzxbq` `ymm`[dest]`,` `xmm`[src]`/``mem`[32] | Zero-extends a set
    of four byte values in the LO 4 bytes of XMM[src]/mem[32] to qword values in YMM[dest].
    |'
  id: totrans-793
  prefs: []
  type: TYPE_TB
  zh: '| `v``pmovzxbq` `ymm`[dest]`,` `xmm`[src]`/``mem`[32] | 将 XMM[src]/mem[32]
    中低 4 字节的四个字节值零扩展为 YMM[dest] 中的四字值。 |'
- en: '| `v``pmovzxwd` `ymm`[dest]`,` `xmm`[src]`/``mem`[128] | Zero-extends a set
    of eight word values in the LO 16 bytes of XMM[src]/mem[128] to dword values in
    YMM[dest]. |'
  id: totrans-794
  prefs: []
  type: TYPE_TB
  zh: '| `v``pmovzxwd` `ymm`[dest]`,` `xmm`[src]`/``mem`[128] | 将 XMM[src]/mem[128]
    中低 16 字节的八个字值零扩展为 YMM[dest] 中的双字值。 |'
- en: '| `v``pmovzxwq` `ymm`[dest]`,` `xmm`[src]`/``mem`[64] | Zero-extends a set
    of four word values in the LO 8 bytes of XMM[src]/mem[64] to qword values in YMM[dest].
    |'
  id: totrans-795
  prefs: []
  type: TYPE_TB
  zh: '| `v``pmovzxwq` `ymm`[dest]`,` `xmm`[src]`/``mem`[64] | 将 XMM[src]/mem[64]
    中低 8 字节的四个字值零扩展为 YMM[dest] 中的四字值。 |'
- en: '| `v``pmovzxdq` `ymm`[dest]`,` `xmm`[src]`/``mem`[128] | Zero-extends a set
    of four dword values in the LO 16 bytes of XMM[src]/mem[128] to qword values in
    YMM[dest]. |'
  id: totrans-796
  prefs: []
  type: TYPE_TB
  zh: '| `v``pmovzxdq` `ymm`[dest]`,` `xmm`[src]`/``mem`[128] | 将 XMM[src]/mem[128]
    中低 16 字节的四个双字值零扩展为 YMM[dest] 中的四字值。 |'
- en: 11.10.11.2 Packed Sign-Extension Instructions
  id: totrans-797
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 11.10.11.2 打包符号扩展指令
- en: The SSE/AVX/AVX2 instruction set extensions provide a comparable set of instructions
    that sign-extend byte, word, and dword values. [Table 11-23](#table11-23) lists
    the SSE packed sign-extension instructions.
  id: totrans-798
  prefs: []
  type: TYPE_NORMAL
  zh: SSE/AVX/AVX2 指令集扩展提供了一组相似的指令，用于符号扩展字节、字和双字值。[表 11-23](#table11-23) 列出了 SSE 打包符号扩展指令。
- en: 'Table 11-23: SSE Packed Sign-Extension Instructions'
  id: totrans-799
  prefs: []
  type: TYPE_NORMAL
  zh: '表 11-23: SSE 打包符号扩展指令'
- en: '| **Syntax** | **Description** |'
  id: totrans-800
  prefs: []
  type: TYPE_TB
  zh: '| **语法** | **描述** |'
- en: '| --- | --- |'
  id: totrans-801
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `pmovsxbw` `xmm`[dest]`,` `xmm`[src]`/``mem`[64] | Sign-extends a set of
    eight byte values in the LO 8 bytes of XMM[src]/mem[64] to word values in XMM[dest].
    |'
  id: totrans-802
  prefs: []
  type: TYPE_TB
  zh: '| `pmovsxbw` `xmm`[dest]`,` `xmm`[src]`/``mem`[64] | 将 XMM[src]/mem[64] 中低
    8 字节的八个字节值扩展为 XMM[dest] 中的字值。 |'
- en: '| `pmovsxbd` `xmm`[dest]`,` `xmm`[src]`/``mem`[32] | Sign-extends a set of
    four byte values in the LO 4 bytes of XMM[src]/mem[32] to dword values in XMM[dest].
    |'
  id: totrans-803
  prefs: []
  type: TYPE_TB
  zh: '| `pmovsxbq` `xmm`[dest]`,` `xmm`[src]`/``mem`[32] | 将 XMM[src]/mem[32] 中低
    4 字节的四个字节值扩展为 XMM[dest] 中的双字值。 |'
- en: '| `pmovsxbq` `xmm`[dest]`,` `xmm`[src]`/``mem`[16] | Sign-extends a set of
    two byte values in the LO 2 bytes of XMM[src]/mem[16] to qword values in XMM[dest].
    |'
  id: totrans-804
  prefs: []
  type: TYPE_TB
  zh: '| `pmovsxbq` `xmm`[dest]`,` `xmm`[src]`/``mem`[16] | 将 XMM[src]/mem[16] 中低
    2 字节的两个字节值扩展为 XMM[dest] 中的四字值。 |'
- en: '| `pmovsxwd` `xmm`[dest]`,` `xmm`[src]`/``mem`[64] | Sign-extends a set of
    four word values in the LO 8 bytes of XMM[src]/mem[64] to dword values in XMM[dest].
    |'
  id: totrans-805
  prefs: []
  type: TYPE_TB
  zh: '| `pmovsxwd` `xmm`[dest]`,` `xmm`[src]`/``mem`[64] | 将 XMM[src]/mem[64] 中低
    8 字节的四个字值扩展为 XMM[dest] 中的双字值。 |'
- en: '| `pmovsxwq` `xmm`[dest]`,` `xmm`[src]`/``mem`[32] | Sign-extends a set of
    two word values in the LO 4 bytes of XMM[src]/mem[32] to qword values in XMM[dest].
    |'
  id: totrans-806
  prefs: []
  type: TYPE_TB
  zh: '| `pmovsxwq` `xmm`[dest]`,` `xmm`[src]`/``mem`[32] | 将 XMM[src]/mem[32] 中低
    4 字节的两个字值扩展为 XMM[dest] 中的四字值。 |'
- en: '| `pmovsxdq` `xmm`[dest]`,` `xmm`[src]`/mem`[64] | Sign-extends a set of two
    dword values in the LO 8 bytes of XMM[src]/mem[64] to qword values in XMM[dest].
    |'
  id: totrans-807
  prefs: []
  type: TYPE_TB
  zh: '| `pmovsxdq` `xmm`[dest]`,` `xmm`[src]`/mem`[64] | 将 XMM[src]/mem[64] 中低 8
    字节的两个双字值扩展为 XMM[dest] 中的四字值。 |'
- en: A set of corresponding AVX instructions also exists (whose mnemonics have the
    `v` prefix). As usual, the difference between the SSE and AVX instructions is
    that the SSE instructions leave the upper bits of the YMM register unchanged (if
    applicable), and the AVX instructions store 0s into those upper bits.
  id: totrans-808
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一组对应的 AVX 指令（其助记符以 `v` 前缀为标识）。通常，SSE 和 AVX 指令的区别在于，SSE 指令不会改变 YMM 寄存器的高位（如果适用），而
    AVX 指令则会将这些高位置为 0。
- en: AVX2-capable processors also allow a YMM[dest] destination register, which doubles
    the number of (output) values the instruction can handle; see [Table 11-24](#table11-24).
  id: totrans-809
  prefs: []
  type: TYPE_NORMAL
  zh: 支持 AVX2 的处理器还允许 YMM[dest] 目标寄存器，这将使指令能够处理更多的（输出）值；见 [表 11-24](#table11-24)。
- en: 'Table 11-24: AVX Packed Sign-Extension Instructions'
  id: totrans-810
  prefs: []
  type: TYPE_NORMAL
  zh: '表 11-24: AVX 打包符号扩展指令'
- en: '| **Syntax** | **Description** |'
  id: totrans-811
  prefs: []
  type: TYPE_TB
  zh: '| **语法** | **描述** |'
- en: '| --- | --- |'
  id: totrans-812
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `v``pmovsxbw` `ymm`[dest]`,` `xmm`[src]`/``mem`[128] | Sign-extends a set
    of sixteen byte values in the LO 16 bytes of XMM[src]/mem[128] to word values
    in YMM[dest]. |'
  id: totrans-813
  prefs: []
  type: TYPE_TB
  zh: '| `v``pmovsxbw` `ymm`[dest]`,` `xmm`[src]`/``mem`[128] | 将 XMM[src]/mem[128]
    中低 16 字节的字节值扩展为 YMM[dest] 中的字值。 |'
- en: '| `v``pmovsxbd` `ymm`[dest]`,` `xmm`[src]`/``mem`[64] | Sign-extends a set
    of eight byte values in the LO 8 bytes of XMM[src]/mem[64] to dword values in
    YMM[dest]. |'
  id: totrans-814
  prefs: []
  type: TYPE_TB
  zh: '| `v``pmovsxbd` `ymm`[dest]`,` `xmm`[src]`/``mem`[64] | 将 XMM[src]/mem[64]
    中低 8 字节的八个字节值扩展为 YMM[dest] 中的双字值。 |'
- en: '| `v``pmovsxbq` `ymm`[dest]`,` `xmms`[rc]`/``mem`[32] | Sign-extends a set
    of four byte values in the LO 4 bytes of XMM[src]/mem[32] to qword values in YMM[dest].
    |'
  id: totrans-815
  prefs: []
  type: TYPE_TB
  zh: '| `v``pmovsxbq` `ymm`[dest]`,` `xmm`[src]`/``mem`[32] | 将 XMM[src]/mem[32]
    中低 4 字节的四个字节值扩展为 YMM[dest] 中的四字值。 |'
- en: '| `v``pmovsxwd` `ymm`[dest]`,` `xmm`[src]`/``mem`[128] | Sign-extends a set
    of eight word values in the LO 16 bytes of XMM[src]/mem[128] to dword values in
    YMM[dest]. |'
  id: totrans-816
  prefs: []
  type: TYPE_TB
  zh: '| `v``pmovsxwd` `ymm`[dest]`,` `xmm`[src]`/``mem`[128] | 将 XMM[src]/mem[128]
    中低 16 字节的八个字值扩展为 YMM[dest] 中的双字值。 |'
- en: '| `v``pmovsxwq` `ymm`[dest]`,` `xmm`[src]`/``mem`[64] | Sign-extends a set
    of four word values in the LO 8 bytes of XMM[src]/mem[64] to qword values in YMM[dest].
    |'
  id: totrans-817
  prefs: []
  type: TYPE_TB
  zh: '| `v``pmovsxwq` `ymm`[dest]`,` `xmm`[src]`/``mem`[64] | 将 XMM[src]/mem[64]
    中低 8 字节的四个字值扩展为 YMM[dest] 中的四字值。 |'
- en: '| `v``pmovsxdq` `ymm`[dest]`,` `xmm`[src]`/``mem`[128] | Sign-extends a set
    of four dword values in the LO 16 bytes of XMM[src]/mem[128] to qword values in
    YMM[dest]. |'
  id: totrans-818
  prefs: []
  type: TYPE_TB
  zh: '| `v``pmovsxdq` `ymm`[dest]`,` `xmm`[src]`/``mem`[128] | 将XMM[src]/mem[128]的低16字节中的四个双字值符号扩展为YMM[dest]中的四个四字值。
    |'
- en: 11.10.11.3 Packed Sign Extension with Saturation
  id: totrans-819
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 11.10.11.3 打包符号扩展与饱和
- en: In addition to converting smaller signed or unsigned values to a larger format,
    the SSE/AVX/AVX2-capable CPUs have the ability to convert large values to smaller
    values via saturation; see [Table 11-25](#table11-25).
  id: totrans-820
  prefs: []
  type: TYPE_NORMAL
  zh: 除了将较小的有符号或无符号值转换为较大格式外，支持SSE/AVX/AVX2的CPU还能够通过饱和将较大值转换为较小值；请参见[表 11-25](#table11-25)。
- en: 'Table 11-25: SSE Packed Sign-Extension with Saturation Instructions'
  id: totrans-821
  prefs: []
  type: TYPE_NORMAL
  zh: 表 11-25：SSE打包符号扩展与饱和指令
- en: '| **Syntax** | **Description** |'
  id: totrans-822
  prefs: []
  type: TYPE_TB
  zh: '| **语法** | **描述** |'
- en: '| --- | --- |'
  id: totrans-823
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `packsswb` `xmm`[dest]`,` `xmm`[src]`/``mem`[128] | Packs sixteen signed
    word values (from two 128-bit sources) into sixteen byte lanes in a 128-bit destination
    register using signed saturation. |'
  id: totrans-824
  prefs: []
  type: TYPE_TB
  zh: '| `packsswb` `xmm`[dest]`,` `xmm`[src]`/``mem`[128] | 使用符号饱和，将来自两个128位源的十六个有符号字值打包成一个128位目标寄存器中的十六个字节。
    |'
- en: '| `packuswb` `xmm`[dest]`,` `xmm`[src]`/``mem`[128] | Packs sixteen unsigned
    word values (from two 128-bit sources) into sixteen byte lanes in a 128-bit destination
    register using unsigned saturation. |'
  id: totrans-825
  prefs: []
  type: TYPE_TB
  zh: '| `packuswb` `xmm`[dest]`,` `xmm`[src]`/``mem`[128] | 使用无符号饱和，将来自两个128位源的十六个无符号字值打包成一个128位目标寄存器中的十六个字节。
    |'
- en: '| `packssdw` `xmm`[dest]`,` `xmm`[src]`/``mem`[128] | Packs eight signed dword
    values (from two 128-bit sources) into eight word values in a 128-bit destination
    register using signed saturation. |'
  id: totrans-826
  prefs: []
  type: TYPE_TB
  zh: '| `packssdw` `xmm`[dest]`,` `xmm`[src]`/``mem`[128] | 使用符号饱和，将来自两个128位源的八个有符号双字值打包成一个128位目标寄存器中的八个字节值。
    |'
- en: '| `packusdw` `xmm`[dest]`,` `xmm`[src]`/``mem`[128] | Packs eight unsigned
    dword values (from two 128-bit sources) into eight word values in a 128-bit destination
    register using unsigned saturation. |'
  id: totrans-827
  prefs: []
  type: TYPE_TB
  zh: '| `packusdw` `xmm`[dest]`,` `xmm`[src]`/``mem`[128] | 使用无符号饱和，将来自两个128位源的八个无符号双字值打包成一个128位目标寄存器中的八个字。
    |'
- en: The saturate operation checks its operand to see if the value exceeds the range
    of the result (–128 to +127 for signed bytes, 0 to 255 for unsigned bytes, –32,768
    to +32,767 for signed words, and 0 to 65,535 for unsigned words). When saturating
    to a byte, if the signed source value is less than –128, byte saturation sets
    the value to –128\. When saturating to a word, if the signed source value is less
    than –32,786, signed saturation sets the value to –32,768\. Similarly, if a signed
    byte or word value exceeds +127 or +32,767, then saturation replaces the value
    with +127 or +32,767, respectively. For unsigned operations, saturation limits
    the value to +255 (for bytes) or +65,535 (for words). Unsigned values are never
    less than 0, so unsigned saturation clips values to only +255 or +65,535.
  id: totrans-828
  prefs: []
  type: TYPE_NORMAL
  zh: 饱和操作会检查其操作数，查看值是否超出结果的范围（有符号字节的范围是-128到+127，无符号字节的范围是0到255，有符号字的范围是-32,768到+32,767，无符号字的范围是0到65,535）。当饱和到字节时，如果有符号源值小于-128，字节饱和会将值设置为-128。当饱和到字时，如果有符号源值小于-32,768，有符号饱和会将值设置为-32,768。同样地，如果有符号字节或字值超过+127或+32,767，饱和会分别将值替换为+127或+32,767。对于无符号操作，饱和会将值限制为+255（字节）或+65,535（字）。无符号值永远不小于0，因此无符号饱和会将值裁剪为+255或+65,535。
- en: 'AVX-capable CPUs provide 128-bit variants of these instructions that support
    three operands: two source operands and an independent destination operand. These
    instructions (mnemonics the same as the SSE instructions, with a `v` prefix) have
    the following syntax:'
  id: totrans-829
  prefs: []
  type: TYPE_NORMAL
  zh: 支持AVX的CPU提供这些指令的128位变体，支持三个操作数：两个源操作数和一个独立的目标操作数。这些指令（助记符与SSE指令相同，但以`v`为前缀）具有以下语法：
- en: '[PRE85]'
  id: totrans-830
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: These instructions are roughly equivalent to the SSE variants, except that these
    instructions use XMM[src1] as the first source operand rather than XMM[dest] (which
    the SSE instructions use). Also, the SSE instructions do not modify the upper
    bits of the YMM register (if present on the CPU), whereas the AVX instructions
    store 0s into the upper YMM register bits.
  id: totrans-831
  prefs: []
  type: TYPE_NORMAL
  zh: 这些指令大致等同于SSE变体，唯一的不同是，这些指令使用XMM[src1]作为第一个源操作数，而不是SSE指令使用的XMM[dest]。另外，SSE指令不会修改YMM寄存器的高位（如果CPU上存在该寄存器），而AVX指令会将0存入YMM寄存器的高位。
- en: AVX2-capable CPUs also allow the use of the YMM registers (and 256-bit memory
    locations) to double the number of values the instruction can saturate (see [Table
    11-26](#table11-26)). Of course, don’t forget to check for AVX2 (and AVX) compatibility
    before using these instructions.
  id: totrans-832
  prefs: []
  type: TYPE_NORMAL
  zh: 支持 AVX2 的 CPU 还允许使用 YMM 寄存器（和 256 位内存位置），以便指令能够饱和更多的值（参见 [表 11-26](#table11-26)）。当然，在使用这些指令之前，请不要忘记检查
    AVX2（和 AVX）兼容性。
- en: 'Table 11-26: AVX Packed Sign-Extension with Saturation Instructions'
  id: totrans-833
  prefs: []
  type: TYPE_NORMAL
  zh: 表 11-26：AVX 打包符号扩展与饱和指令
- en: '| **Syntax** | **Description** |'
  id: totrans-834
  prefs: []
  type: TYPE_TB
  zh: '| **语法** | **描述** |'
- en: '| --- | --- |'
  id: totrans-835
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `v``packsswb` `ymm`[dest]`,` `ymm`[src1]`,` `ymm`[src2]`/``mem`[256] | Packs
    32 signed word values (from two 256-bit sources) into 32 byte lanes in a 256-bit
    destination register using signed saturation. |'
  id: totrans-836
  prefs: []
  type: TYPE_TB
  zh: '| `v``packsswb` `ymm`[dest]`,` `ymm`[src1]`,` `ymm`[src2]`/``mem`[256] | 将来自两个
    256 位源的 32 个有符号字值打包到一个 256 位目标寄存器的 32 个字节通道中，使用有符号饱和。 |'
- en: '| `v``packuswb` `ymm`[dest]`,` `ymm`[src1]`,` `ymm`[src2]`/``mem`[256] | Packs
    32 unsigned word values (from two 256-bit sources) into 32 byte lanes in a 256-bit
    destination register using unsigned saturation. |'
  id: totrans-837
  prefs: []
  type: TYPE_TB
  zh: '| `v``packuswb` `ymm`[dest]`,` `ymm`[src1]`,` `ymm`[src2]`/``mem`[256] | 将来自两个
    256 位源的 32 个无符号字值打包到一个 256 位目标寄存器的 32 个字节通道中，使用无符号饱和。 |'
- en: '| `v``packssdw` `ymm`[dest]`,` `ymm`[src1]`,` `ymm`[src2]`/``mem`[256] | Packs
    16 signed dword values (from two 256-bit sources) into 16 word values in a 256-bit
    destination register using signed saturation. |'
  id: totrans-838
  prefs: []
  type: TYPE_TB
  zh: '| `v``packssdw` `ymm`[dest]`,` `ymm`[src1]`,` `ymm`[src2]`/``mem`[256] | 将来自两个
    256 位源的 16 个有符号 dword 值打包到一个 256 位目标寄存器的 16 个字值中，使用有符号饱和。 |'
- en: '| `v``packusdw` `ymm`[dest]`,` `ymm`[src1]`,` `ymm`[src2]`/``mem`[256] | Packs
    16 unsigned dword values (from two 256-bit sources) into 16 word values in a 256-bit
    destination register using unsigned saturation. |'
  id: totrans-839
  prefs: []
  type: TYPE_TB
  zh: '| `v``packusdw` `ymm`[dest]`,` `ymm`[src1]`,` `ymm`[src2]`/``mem`[256] | 将来自两个
    256 位源的 16 个无符号 dword 值打包到一个 256 位目标寄存器的 16 个字值中，使用无符号饱和。 |'
- en: 11.11 SIMD Floating-Point Arithmetic Operations
  id: totrans-840
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 11.11 SIMD 浮点算术运算
- en: The SSE and AVX instruction set extensions provide packed arithmetic equivalents
    for all the scalar floating-point instructions in “SSE Floating-Point Arithmetic”
    in Chapter 6. This section does not repeat the discussion of the scalar floating-point
    operations; see Chapter 6 for more details.
  id: totrans-841
  prefs: []
  type: TYPE_NORMAL
  zh: SSE 和 AVX 指令集扩展为“第 6 章中的 SSE 浮点算术”中的所有标量浮点指令提供了打包算术等效指令。本节不重复标量浮点操作的讨论；有关详细信息，请参见第
    6 章。
- en: 'The 128-bit SSE packed floating-point instructions have the following generic
    syntax (where `instr` is one of the floating-point instructions in [Table 11-27](#table11-27)):'
  id: totrans-842
  prefs: []
  type: TYPE_NORMAL
  zh: 128 位 SSE 打包浮点指令具有以下通用语法（其中 `instr` 是 [表 11-27](#table11-27) 中的浮点指令之一）：
- en: '[PRE86]'
  id: totrans-843
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: The *packed single* (`*ps`) instructions perform four single-precision floating-point
    operations simultaneously. The *packed double* (`*pd`) instructions perform two
    double-precision floating-point operations simultaneously. As is typical for SSE
    instructions, these packed arithmetic instructions compute
  id: totrans-844
  prefs: []
  type: TYPE_NORMAL
  zh: '*打包单精度*（`*ps`）指令同时执行四个单精度浮点运算。*打包双精度*（`*pd`）指令同时执行两个双精度浮点运算。像典型的 SSE 指令一样，这些打包算术指令计算'
- en: '[PRE87]'
  id: totrans-845
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: where `lane` varies from 0 to 3 for packed single-precision instructions and
    from 0 to 1 for packed double-precision instructions. `op` represents the operation
    (such as addition or subtraction). When the SSE instructions are executed on a
    CPU that supports the AVX extensions, the SSE instructions leave the upper bits
    of the AVX register unmodified.
  id: totrans-846
  prefs: []
  type: TYPE_NORMAL
  zh: '`lane` 在打包单精度指令中取值范围为 0 到 3，在打包双精度指令中取值范围为 0 到 1。`op` 表示操作（例如加法或减法）。当 SSE 指令在支持
    AVX 扩展的 CPU 上执行时，SSE 指令会将 AVX 寄存器的高位保持不变。'
- en: The 128-bit AVX packed floating-point instructions have this syntax:^([15](#c11-footnote-15))
  id: totrans-847
  prefs: []
  type: TYPE_NORMAL
  zh: 128 位 AVX 打包浮点指令具有以下语法：^([15](#c11-footnote-15))
- en: '[PRE88]'
  id: totrans-848
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: These instructions compute
  id: totrans-849
  prefs: []
  type: TYPE_NORMAL
  zh: 这些指令计算
- en: '[PRE89]'
  id: totrans-850
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: where `op` corresponds to the operation associated with the specific instruction
    (for example, `vaddps` does a packed single-precision addition). These 128-bit
    AVX instructions clear the HO bits of the underlying YMM[dest] register.
  id: totrans-851
  prefs: []
  type: TYPE_NORMAL
  zh: 其中 `op` 对应于与特定指令相关的操作（例如，`vaddps` 执行打包单精度加法）。这些 128 位 AVX 指令会清除底层 YMM[dest]
    寄存器的 HO 位。
- en: 'The 256-bit AVX packed floating-point instructions have this syntax:'
  id: totrans-852
  prefs: []
  type: TYPE_NORMAL
  zh: 256 位 AVX 打包浮点指令具有以下语法：
- en: '[PRE90]'
  id: totrans-853
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: These instructions compute
  id: totrans-854
  prefs: []
  type: TYPE_NORMAL
  zh: 这些指令计算
- en: '[PRE91]'
  id: totrans-855
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: where `op` corresponds to the operation associated with the specific instruction
    (for example, `vaddps` is a packed single-precision addition). Because these instructions
    operate on 256-bit operands, they compute twice as many lanes of data as the 128-bit
    instructions. Specifically, they simultaneously compute eight single-precision
    (the `v*ps` instructions) or four double-precision results (the `v*pd` instructions).
  id: totrans-856
  prefs: []
  type: TYPE_NORMAL
  zh: 其中，`op`对应于与特定指令关联的操作（例如，`vaddps`是打包的单精度加法）。由于这些指令操作的是256位操作数，它们计算的数据通道数是128位指令的两倍。具体来说，它们同时计算八个单精度结果（`v*ps`指令）或四个双精度结果（`v*pd`指令）。
- en: '[Table 11-27](#table11-27) provides the list of SSE/AVX packed instructions.'
  id: totrans-857
  prefs: []
  type: TYPE_NORMAL
  zh: '[表11-27](#table11-27)提供了SSE/AVX打包指令的列表。'
- en: 'Table 11-27: Floating-Point Arithmetic Instructions'
  id: totrans-858
  prefs: []
  type: TYPE_NORMAL
  zh: 表11-27：浮点数算术指令
- en: '| **Instruction** | **Lanes** | **Description** |'
  id: totrans-859
  prefs: []
  type: TYPE_TB
  zh: '| **指令** | **通道数** | **描述** |'
- en: '| --- | --- | --- |'
  id: totrans-860
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| `addps` | 4 | Adds four single-precision floating-point values |'
  id: totrans-861
  prefs: []
  type: TYPE_TB
  zh: '| `addps` | 4 | 加法四个单精度浮点数值 |'
- en: '| `addpd` | 2 | Adds two double-precision floating-point values |'
  id: totrans-862
  prefs: []
  type: TYPE_TB
  zh: '| `addpd` | 2 | 加法两个双精度浮点数值 |'
- en: '| `vaddps` | 4/8 | Adds four (128-bit/XMM operands) or eight (256-bit/YMM operands)
    single-precision values |'
  id: totrans-863
  prefs: []
  type: TYPE_TB
  zh: '| `vaddps` | 4/8 | 加法四个（128位/XMM操作数）或八个（256位/YMM操作数）单精度数值 |'
- en: '| `vaddpd` | 2/4 | Adds two (128-bit/XMM operands) or four (256-bit/YMM operands)
    double-precision values |'
  id: totrans-864
  prefs: []
  type: TYPE_TB
  zh: '| `vaddpd` | 2/4 | 加法两个（128位/XMM操作数）或四个（256位/YMM操作数）双精度数值 |'
- en: '| `subps` | 4 | Subtracts four single-precision floating-point values |'
  id: totrans-865
  prefs: []
  type: TYPE_TB
  zh: '| `subps` | 4 | 减去四个单精度浮点数值 |'
- en: '| `subpd` | 2 | Subtracts two double-precision floating-point values |'
  id: totrans-866
  prefs: []
  type: TYPE_TB
  zh: '| `subpd` | 2 | 减去两个双精度浮点数值 |'
- en: '| `vsubps` | 4/8 | Subtracts four (128-bit/XMM operands) or eight (256-bit/YMM
    operands) single-precision values |'
  id: totrans-867
  prefs: []
  type: TYPE_TB
  zh: '| `vsubps` | 4/8 | 减去四个（128位/XMM操作数）或八个（256位/YMM操作数）单精度数值 |'
- en: '| `vsubpd` | 2/4 | Subtracts two (128-bit/XMM operands) or four (256-bit/YMM
    operands) double-precision values |'
  id: totrans-868
  prefs: []
  type: TYPE_TB
  zh: '| `vsubpd` | 2/4 | 减去两个（128位/XMM操作数）或四个（256位/YMM操作数）双精度数值 |'
- en: '| `mulps` | 4 | Multiplies four single-precision floating-point values |'
  id: totrans-869
  prefs: []
  type: TYPE_TB
  zh: '| `mulps` | 4 | 乘以四个单精度浮点数值 |'
- en: '| `mulpd` | 2 | Multiplies two double-precision floating-point values |'
  id: totrans-870
  prefs: []
  type: TYPE_TB
  zh: '| `mulpd` | 2 | 乘以两个双精度浮点数值 |'
- en: '| `vmulps` | 4/8 | Multiplies four (128-bit/XMM operands) or eight (256-bit/YMM
    operands) single-precision values |'
  id: totrans-871
  prefs: []
  type: TYPE_TB
  zh: '| `vmulps` | 4/8 | 乘以四个（128位/XMM操作数）或八个（256位/YMM操作数）单精度数值 |'
- en: '| `vmulpd` | 2/4 | Multiplies two (128-bit/XMM operands) or four (256-bit/YMM
    operands) double-precision values |'
  id: totrans-872
  prefs: []
  type: TYPE_TB
  zh: '| `vmulpd` | 2/4 | 乘以两个（128位/XMM操作数）或四个（256位/YMM操作数）双精度数值 |'
- en: '| `divps` | 4 | Divides four single-precision floating-point values |'
  id: totrans-873
  prefs: []
  type: TYPE_TB
  zh: '| `divps` | 4 | 除以四个单精度浮点数值 |'
- en: '| `divpd` | 2 | Divides two double-precision floating-point values |'
  id: totrans-874
  prefs: []
  type: TYPE_TB
  zh: '| `divpd` | 2 | 除以两个双精度浮点数值 |'
- en: '| `vdivps` | 4/8 | Divides four (128-bit/XMM operands) or eight (256-bit/YMM
    operands) single-precision values |'
  id: totrans-875
  prefs: []
  type: TYPE_TB
  zh: '| `vdivps` | 4/8 | 除以四个（128位/XMM操作数）或八个（256位/YMM操作数）单精度数值 |'
- en: '| `vdivpd` | 2/4 | Divides two (128-bit/XMM operands) or four (256-bit/YMM
    operands) double-precision values |'
  id: totrans-876
  prefs: []
  type: TYPE_TB
  zh: '| `vdivpd` | 2/4 | 除以两个（128位/XMM操作数）或四个（256位/YMM操作数）双精度数值 |'
- en: '| `maxps` | 4 | Computes the maximum of four pairs of single-precision floating-point
    values |'
  id: totrans-877
  prefs: []
  type: TYPE_TB
  zh: '| `maxps` | 4 | 计算四个单精度浮点数值对的最大值 |'
- en: '| `maxpd` | 2 | Computes the maximum of two pairs of double-precision floating-point
    values |'
  id: totrans-878
  prefs: []
  type: TYPE_TB
  zh: '| `maxpd` | 2 | 计算两个双精度浮点数值对的最大值 |'
- en: '| `vmaxps` | 4/8 | Computes the maximum of four (128-bit/XMM operands) or eight
    (256-bit/YMM operands) pairs of single-precision values |'
  id: totrans-879
  prefs: []
  type: TYPE_TB
  zh: '| `vmaxps` | 4/8 | 计算四个（128位/XMM操作数）或八个（256位/YMM操作数）单精度数值对的最大值 |'
- en: '| `vmaxpd` | 2/4 | Computes the maximum of two (128-bit/XMM operands) or four
    (256-bit/YMM operands) pairs of double-precision values |'
  id: totrans-880
  prefs: []
  type: TYPE_TB
  zh: '| `vmaxpd` | 2/4 | 计算两个（128位/XMM操作数）或四个（256位/YMM操作数）双精度数值对的最大值 |'
- en: '| `minps` | 4 | Computes the minimum of four pairs of single-precision floating-point
    values |'
  id: totrans-881
  prefs: []
  type: TYPE_TB
  zh: '| `minps` | 4 | 计算四个单精度浮点数值对的最小值 |'
- en: '| `minpd` | 2 | Computes the minimum of two pairs of double-precision floating-point
    values |'
  id: totrans-882
  prefs: []
  type: TYPE_TB
  zh: '| `minpd` | 2 | 计算两个双精度浮点数值对的最小值 |'
- en: '| `vminps` | 4/8 | Computes the minimum of four (128-bit/XMM operands) or eight
    (256-bit/YMM operands) pairs of single-precision values |'
  id: totrans-883
  prefs: []
  type: TYPE_TB
  zh: '| `vminps` | 4/8 | 计算四个（128位/XMM操作数）或八个（256位/YMM操作数）单精度数值对的最小值 |'
- en: '| `vminpd` | 2/4 | Computes the minimum of two (128-bit/XMM operands) or four
    (256-bit/YMM operands) pairs of double-precision values |'
  id: totrans-884
  prefs: []
  type: TYPE_TB
  zh: '| `vminpd` | 2/4 | 计算两个（128位/XMM操作数）或四个（256位/YMM操作数）双精度值对的最小值 |'
- en: '| `sqrtps` | 4 | Computes the square root of four single-precision floating-point
    values |'
  id: totrans-885
  prefs: []
  type: TYPE_TB
  zh: '| `sqrtps` | 4 | 计算四个单精度浮动值的平方根 |'
- en: '| `sqrtpd` | 2 | Computes the square root of two double-precision floating-point
    values |'
  id: totrans-886
  prefs: []
  type: TYPE_TB
  zh: '| `sqrtpd` | 2 | 计算两个双精度浮动值的平方根 |'
- en: '| `vsqrtps` | 4/8 | Computes the square root of four (128-bit/XMM operands)
    or eight (256-bit/YMM operands) single-precision values |'
  id: totrans-887
  prefs: []
  type: TYPE_TB
  zh: '| `vsqrtps` | 4/8 | 计算四个（128位/XMM操作数）或八个（256位/YMM操作数）单精度值的平方根 |'
- en: '| `vsqrtpd` | 2/4 | Computes the square root of two (128-bit/XMM operands)
    or four (256-bit/YMM operands) double-precision values |'
  id: totrans-888
  prefs: []
  type: TYPE_TB
  zh: '| `vsqrtpd` | 2/4 | 计算两个（128位/XMM操作数）或四个（256位/YMM操作数）双精度值的平方根 |'
- en: '| `rsqrtps` | 4 | Computes the approximate reciprocal square root of four single-precision
    floating-point values^([*](#c11-footnote-16)) |'
  id: totrans-889
  prefs: []
  type: TYPE_TB
  zh: '| `rsqrtps` | 4 | 计算四个单精度浮动值的近似倒数平方根^([*](#c11-footnote-16)) |'
- en: '| `vrsqrtps` | 4/8 | Computes the approximate reciprocal square root of four
    (128-bit/XMM operands) or eight (256-bit/YMM operands) single-precision values
    |'
  id: totrans-890
  prefs: []
  type: TYPE_TB
  zh: '| `vrsqrtps` | 4/8 | 计算四个（128位/XMM操作数）或八个（256位/YMM操作数）单精度值的近似倒数平方根 |'
- en: '| ^([*](#c11-footnoteref-16)) The relative error is ≤ 1.5 × 2^(-12). |'
  id: totrans-891
  prefs: []
  type: TYPE_TB
  zh: '| ^([*](#c11-footnoteref-16)) 相对误差 ≤ 1.5 × 2^(-12)。 |'
- en: 'The SSE/AVX instruction set extensions also include floating-point horizontal
    addition and subtraction instructions. The syntax for these instructions is as
    follows:'
  id: totrans-892
  prefs: []
  type: TYPE_NORMAL
  zh: SSE/AVX指令集扩展还包括浮点水平加法和减法指令。这些指令的语法如下：
- en: '[PRE92]'
  id: totrans-893
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: As for the integer horizontal addition and subtraction instructions, these instructions
    add or subtract the values in adjacent lanes in the same register and store the
    result in the destination register (lane 2), as shown in [Figure 11-43](#figure11-43).
  id: totrans-894
  prefs: []
  type: TYPE_NORMAL
  zh: 至于整数水平加法和减法指令，这些指令在同一寄存器的相邻通道中加法或减法，并将结果存储到目标寄存器（通道2），如[图11-43](#figure11-43)所示。
- en: 11.12 SIMD Floating-Point Comparison Instructions
  id: totrans-895
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 11.12 SIMD浮点比较指令
- en: Like the integer packed comparisons, the SSE/AVX floating-point comparisons
    compare two sets of floating-point values (either single- or double-precision,
    depending on the instruction’s syntax) and store a resulting Boolean value (all
    1 bits for true, all 0 bits for false) into the destination lane. However, the
    floating-point comparisons are far more comprehensive than those of their integer
    counterparts. Part of the reason is that floating-point arithmetic is more complex;
    however, an ever-increasing silicon budget for the CPU designers is also responsible
    for this.
  id: totrans-896
  prefs: []
  type: TYPE_NORMAL
  zh: 与整数打包比较类似，SSE/AVX浮点比较比较两组浮点值（无论是单精度还是双精度，具体取决于指令语法），并将结果布尔值（所有1位表示真，所有0位表示假）存储到目标通道。然而，浮点比较比整数对应物更为全面。部分原因是浮点运算更为复杂；然而，CPU设计师的硅预算不断增加也是原因之一。
- en: 11.12.1 SSE and AVX Comparisons
  id: totrans-897
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 11.12.1 SSE和AVX比较
- en: 'There are two sets of basic floating-point comparisons: `(v)cmpps`, which compares
    a set of packed single-precision values, and `(v)cmppd`, which compares a set
    of packed double-precision values. Instead of encoding the comparison type into
    the mnemonic, these instructions use an imm[8] operand whose value specifies the
    type of comparison. The generic syntax for these instructions is as follows:'
  id: totrans-898
  prefs: []
  type: TYPE_NORMAL
  zh: 有两组基本的浮点比较：`(v)cmpps`，它比较一组打包的单精度值；和`(v)cmppd`，它比较一组打包的双精度值。这些指令并不直接将比较类型编码到助记符中，而是使用一个imm[8]操作数，其值指定比较类型。这些指令的通用语法如下：
- en: '[PRE93]'
  id: totrans-899
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: The imm[8] operand specifies the type of the comparison. There are 32 possible
    comparisons, as listed in [Table 11-28](#table11-28).
  id: totrans-900
  prefs: []
  type: TYPE_NORMAL
  zh: imm[8]操作数指定比较类型。共有32种可能的比较方式，详见[表11-28](#table11-28)。
- en: 'Table 11-28: imm[8] Values for `cmpps` and `cmppd` Instructions^([†](#c11-footnote-17))'
  id: totrans-901
  prefs: []
  type: TYPE_NORMAL
  zh: '表11-28: `cmpps`和`cmppd`指令的imm[8]值^([†](#c11-footnote-17))'
- en: '| **imm[8]** | **Description** | **Result** | **Signal** |'
  id: totrans-902
  prefs: []
  type: TYPE_TB
  zh: '| **imm[8]** | **描述** | **结果** | **信号** |'
- en: '| --- | --- | --- | --- |'
  id: totrans-903
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- |'
- en: '|  |  | **A < B** | **A = B** | **A > B** | **Unord** |  |'
  id: totrans-904
  prefs: []
  type: TYPE_TB
  zh: '|  |  | **A < B** | **A = B** | **A > B** | **Unord** |  |'
- en: '| --- | --- | --- | --- | --- | --- | --- |'
  id: totrans-905
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- | --- | --- | --- |'
- en: '| 00h | EQ, ordered, quiet | 0 | 1 | 0 | 0 | No |'
  id: totrans-906
  prefs: []
  type: TYPE_TB
  zh: '| 00h | EQ, 有序, 安静 | 0 | 1 | 0 | 0 | 否 |'
- en: '| 01h | LT, ordered, signaling | 1 | 0 | 0 | 0 | Yes |'
  id: totrans-907
  prefs: []
  type: TYPE_TB
  zh: '| 01h | LT, 有序, 信号 | 1 | 0 | 0 | 0 | 是 |'
- en: '| 02h | LE, ordered, signaling | 1 | 1 | 0 | 0 | Yes |'
  id: totrans-908
  prefs: []
  type: TYPE_TB
  zh: '| 02h | LE, 有序, 信号 | 1 | 1 | 0 | 0 | 是 |'
- en: '| 03h | Unordered, quiet | 0 | 0 | 0 | 1 | No |'
  id: totrans-909
  prefs: []
  type: TYPE_TB
  zh: '| 03h | unordered，安静 | 0 | 0 | 0 | 1 | 否 |'
- en: '| 04h | NE, unordered, quiet | 1 | 0 | 1 | 1 | No |'
  id: totrans-910
  prefs: []
  type: TYPE_TB
  zh: '| 04h | NE，unordered，安静 | 1 | 0 | 1 | 1 | 否 |'
- en: '| 05h | NLT, unordered, signaling | 0 | 1 | 1 | 1 | Yes |'
  id: totrans-911
  prefs: []
  type: TYPE_TB
  zh: '| 05h | NLT，unordered，信号 | 0 | 1 | 1 | 1 | 是 |'
- en: '| 06h | NLE, unordered, signaling | 0 | 0 | 1 | 1 | Yes |'
  id: totrans-912
  prefs: []
  type: TYPE_TB
  zh: '| 06h | NLE，unordered，信号 | 0 | 0 | 1 | 1 | 是 |'
- en: '| 07h | Ordered, quiet | 1 | 1 | 1 | 0 | No |'
  id: totrans-913
  prefs: []
  type: TYPE_TB
  zh: '| 07h | ordered，安静 | 1 | 1 | 1 | 0 | 否 |'
- en: '| 08h | EQ, unordered, quiet | 0 | 1 | 0 | 1 | No |'
  id: totrans-914
  prefs: []
  type: TYPE_TB
  zh: '| 08h | EQ，unordered，安静 | 0 | 1 | 0 | 1 | 否 |'
- en: '| 09h | NGE, unordered, signaling | 1 | 0 | 0 | 1 | Yes |'
  id: totrans-915
  prefs: []
  type: TYPE_TB
  zh: '| 09h | NGE，unordered，信号 | 1 | 0 | 0 | 1 | 是 |'
- en: '| 0Ah | NGT, unordered, signaling | 1 | 1 | 0 | 1 | Yes |'
  id: totrans-916
  prefs: []
  type: TYPE_TB
  zh: '| 0Ah | NGT，unordered，信号 | 1 | 1 | 0 | 1 | 是 |'
- en: '| 0Bh | False, ordered, quiet | 0 | 0 | 0 | 0 | No |'
  id: totrans-917
  prefs: []
  type: TYPE_TB
  zh: '| 0Bh | 假，ordered，安静 | 0 | 0 | 0 | 0 | 否 |'
- en: '| 0Ch | NE, ordered, quiet | 1 | 0 | 1 | 0 | No |'
  id: totrans-918
  prefs: []
  type: TYPE_TB
  zh: '| 0Ch | NE，ordered，安静 | 1 | 0 | 1 | 0 | 否 |'
- en: '| 0Dh | GE, ordered, signaling | 0 | 1 | 1 | 0 | Yes |'
  id: totrans-919
  prefs: []
  type: TYPE_TB
  zh: '| 0Dh | GE，ordered，信号 | 0 | 1 | 1 | 0 | 是 |'
- en: '| 0Eh | GT, ordered, signaling | 0 | 0 | 1 | 0 | Yes |'
  id: totrans-920
  prefs: []
  type: TYPE_TB
  zh: '| 0Eh | GT，ordered，信号 | 0 | 0 | 1 | 0 | 是 |'
- en: '| 0Fh | True, unordered, quiet | 1 | 1 | 1 | 1 | No |'
  id: totrans-921
  prefs: []
  type: TYPE_TB
  zh: '| 0Fh | 真，unordered，安静 | 1 | 1 | 1 | 1 | 否 |'
- en: '| 10h | EQ, ordered, signaling | 0 | 1 | 0 | 0 | Yes |'
  id: totrans-922
  prefs: []
  type: TYPE_TB
  zh: '| 10h | EQ，ordered，信号 | 0 | 1 | 0 | 0 | 是 |'
- en: '| 11h | LT, ordered, quiet | 1 | 0 | 0 | 0 | No |'
  id: totrans-923
  prefs: []
  type: TYPE_TB
  zh: '| 11h | LT，ordered，安静 | 1 | 0 | 0 | 0 | 否 |'
- en: '| 12h | LE, ordered, quiet | 1 | 1 | 0 | 0 | No |'
  id: totrans-924
  prefs: []
  type: TYPE_TB
  zh: '| 12h | LE，ordered，安静 | 1 | 1 | 0 | 0 | 否 |'
- en: '| 13h | Unordered, signaling | 0 | 0 | 0 | 1 | Yes |'
  id: totrans-925
  prefs: []
  type: TYPE_TB
  zh: '| 13h | unordered，信号 | 0 | 0 | 0 | 1 | 是 |'
- en: '| 14h | NE, unordered, signaling | 1 | 0 | 1 | 1 | Yes |'
  id: totrans-926
  prefs: []
  type: TYPE_TB
  zh: '| 14h | NE，unordered，信号 | 1 | 0 | 1 | 1 | 是 |'
- en: '| 15h | NLT, unordered, quiet | 0 | 1 | 1 | 1 | No |'
  id: totrans-927
  prefs: []
  type: TYPE_TB
  zh: '| 15h | NLT，unordered，安静 | 0 | 1 | 1 | 1 | 否 |'
- en: '| 16h | NLE, unordered, quiet | 0 | 0 | 1 | 1 | No |'
  id: totrans-928
  prefs: []
  type: TYPE_TB
  zh: '| 16h | NLE，unordered，安静 | 0 | 0 | 1 | 1 | 否 |'
- en: '| 17h | Ordered, signaling | 1 | 1 | 1 | 0 | Yes |'
  id: totrans-929
  prefs: []
  type: TYPE_TB
  zh: '| 17h | ordered，信号 | 1 | 1 | 1 | 0 | 是 |'
- en: '| 18h | EQ, unordered, signaling | 0 | 1 | 0 | 1 | Yes |'
  id: totrans-930
  prefs: []
  type: TYPE_TB
  zh: '| 18h | EQ，unordered，信号 | 0 | 1 | 0 | 1 | 是 |'
- en: '| 19h | NGE, unordered, quiet | 1 | 0 | 0 | 1 | No |'
  id: totrans-931
  prefs: []
  type: TYPE_TB
  zh: '| 19h | NGE，unordered，安静 | 1 | 0 | 0 | 1 | 否 |'
- en: '| 1Ah | NGT, unordered, quiet | 1 | 1 | 0 | 1 | No |'
  id: totrans-932
  prefs: []
  type: TYPE_TB
  zh: '| 1Ah | NGT，unordered，安静 | 1 | 1 | 0 | 1 | 否 |'
- en: '| 1Bh | False, ordered, signaling | 0 | 0 | 0 | 0 | Yes |'
  id: totrans-933
  prefs: []
  type: TYPE_TB
  zh: '| 1Bh | 假，ordered，信号 | 0 | 0 | 0 | 0 | 是 |'
- en: '| 1Ch | NE, ordered, signaling | 1 | 0 | 1 | 0 | Yes |'
  id: totrans-934
  prefs: []
  type: TYPE_TB
  zh: '| 1Ch | NE，ordered，信号 | 1 | 0 | 1 | 0 | 是 |'
- en: '| 1Dh | GE, ordered, quiet | 0 | 1 | 1 | 0 | No |'
  id: totrans-935
  prefs: []
  type: TYPE_TB
  zh: '| 1Dh | GE，ordered，安静 | 0 | 1 | 1 | 0 | 否 |'
- en: '| 1Eh | GT, ordered, quiet | 0 | 0 | 1 | 0 | No |'
  id: totrans-936
  prefs: []
  type: TYPE_TB
  zh: '| 1Eh | GT，ordered，安静 | 0 | 0 | 1 | 0 | 否 |'
- en: '| 1Fh | True, unordered, signaling | 1 | 1 | 1 | 1 | Yes |'
  id: totrans-937
  prefs: []
  type: TYPE_TB
  zh: '| 1Fh | 真， unordered，信号 | 1 | 1 | 1 | 1 | 是 |'
- en: '| ^([†](#c11-footnoteref-17)) The darker shaded entries are available only
    on CPUs that support AVX extensions. |'
  id: totrans-938
  prefs: []
  type: TYPE_TB
  zh: '| ^([†](#c11-footnoteref-17)) 深色阴影条目仅在支持 AVX 扩展的 CPU 上可用。 |'
- en: The “true” and “false” comparisons always store true or false into the destination
    lanes. For the most part, these comparisons aren’t particularly useful. The `pxor`,
    `xorps`, `xorpd`, `vxorps`, and `vxorpd` instructions are probably better for
    setting an XMM or a YMM register to 0\. Prior to AVX2, using a true comparison
    was the shortest instruction that would set all bits in an XMM or a YMM register
    to 1, though `pcmpeqb` is commonly used as well (be aware of microarchitectural
    inefficiencies with this latter instruction).
  id: totrans-939
  prefs: []
  type: TYPE_NORMAL
  zh: “真”与“假”的比较总是将 true 或 false 存储到目标通道中。大多数情况下，这些比较并不是特别有用。`pxor`、`xorps`、`xorpd`、`vxorps`
    和 `vxorpd` 指令可能更适合将 XMM 或 YMM 寄存器设置为 0。AVX2 之前，使用真比较是设置 XMM 或 YMM 寄存器所有位为 1 的最短指令，尽管
    `pcmpeqb` 也常用于此（注意此后指令的微架构效率问题）。
- en: Note that non-AVX CPUs do not implement the GT, GE, NGT, and NGE instructions.
    On these CPUs, use the inverse operation (for example, NLT for GE) or swap the
    operands and use the opposite condition (as was done for the packed integer comparisons).
  id: totrans-940
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，非AVX CPU 不支持GT、GE、NGT 和 NGE 指令。在这些 CPU 上，可以使用反向操作（例如，使用 NLT 替代 GE），或交换操作数并使用相反条件（就像打包整数比较中所做的那样）。
- en: 11.12.2 Unordered vs. Ordered Comparisons
  id: totrans-941
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 11.12.2 无序与有序比较
- en: The unordered relationship is true when at least one of the two source operands
    being compared is a NaN; the ordered relationship is true when neither source
    operand is a NaN. Having ordered and unordered comparisons allows you to pass
    error conditions through comparisons as false or true, depending on how you interpret
    the final Boolean results appearing in the lanes. Unordered results, as their
    name implies, are incomparable. When you compare two values, one of which is not
    a number, you must always treat the result as a failed comparison.
  id: totrans-942
  prefs: []
  type: TYPE_NORMAL
  zh: 无序关系在至少有一个源操作数是 NaN 时为真；有序关系在两个源操作数都不是 NaN 时为真。拥有有序和无序比较使您可以根据最终布尔结果的解释，将错误条件通过比较传递为假或真。无序结果，顾名思义，是不可比较的。当您比较两个值，其中一个不是数字时，必须始终将结果视为失败的比较。
- en: To handle this situation, you use an ordered or unordered comparison to force
    the result to be false or true, the opposite of what you ultimately expect when
    using the comparison result. For example, suppose you are comparing a sequence
    of values and want the resulting masks to be true if all the comparisons are valid
    (for example, you’re testing to see if all the src[1] values are greater than
    the corresponding src[2] values). You would use an ordered comparison in this
    situation that would force a particular lane to false if one of the values being
    compared is NaN. On the other hand, if you’re checking to see if all the conditions
    are false after the comparison, you’d use an unordered comparison to force the
    result to true if any of the values are NaN.
  id: totrans-943
  prefs: []
  type: TYPE_NORMAL
  zh: 为了处理这种情况，您可以使用有序或无序比较来强制结果为假或真，这与您最终期望的比较结果相反。例如，假设您正在比较一系列值，并希望在所有比较有效时，结果掩码为真（例如，您正在检查是否所有的
    src[1] 值都大于相应的 src[2] 值）。在这种情况下，您会使用有序比较，如果被比较的某个值是 NaN，它将强制某个特定的元素为假。另一方面，如果您正在检查所有条件是否在比较后为假，则可以使用无序比较，如果任何值是
    NaN，它将强制结果为真。
- en: 11.12.3 Signaling and Quiet Comparisons
  id: totrans-944
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 11.12.3 信号与静默比较
- en: The signaling comparisons generate an invalid arithmetic operation exception
    (IA) when an operation produces a quiet NaN. The quiet comparisons do not throw
    an exception and reflect only the status in the MXCSR (see “SSE MXCSR Register”
    in Chapter 6). Note that you can also mask signaling exceptions in the MXCSR register;
    you must explicitly set the IM (*invalid operation mask*, bit 7) in the MXCSR
    to 0 if you want to allow exceptions.
  id: totrans-945
  prefs: []
  type: TYPE_NORMAL
  zh: 信号比较在操作产生静默 NaN 时会生成无效的算术操作异常 (IA)。静默比较不会抛出异常，只会在 MXCSR 中反映状态（请参见第 6 章中的“SSE
    MXCSR 寄存器”）。请注意，您也可以在 MXCSR 寄存器中屏蔽信号异常；如果要允许异常，则必须显式地将 MXCSR 中的 IM（*无效操作屏蔽*，位
    7）设置为 0。
- en: 11.12.4 Instruction Synonyms
  id: totrans-946
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 11.12.4 指令同义词
- en: MASM supports the use of certain synonyms so you don’t have to memorize the
    32 encodings. [Table 11-29](#table11-29) lists these synonyms. In this table,
    *x1* denotes the destination operand (XMM[*n*] or YMM[*n*]), and *x2* denotes
    the source operand (XMM[*n*]/mem[128] or YMM[*n*]/mem[256], as appropriate).
  id: totrans-947
  prefs: []
  type: TYPE_NORMAL
  zh: MASM 支持使用某些同义词，这样您就不必记住 32 种编码。[表 11-29](#table11-29) 列出了这些同义词。在此表中，*x1* 表示目标操作数（XMM[*n*]
    或 YMM[*n*]），*x2* 表示源操作数（XMM[*n*]/mem[128] 或 YMM[*n*]/mem[256]，具体情况而定）。
- en: 'Table 11-29: Synonyms for Common Packed Floating-Point Comparisons'
  id: totrans-948
  prefs: []
  type: TYPE_NORMAL
  zh: 表 11-29：常见打包浮点比较的同义词
- en: '| **Synonym** | **Instruction** | **Synonym** | **Instruction** |'
  id: totrans-949
  prefs: []
  type: TYPE_TB
  zh: '| **同义词** | **指令** | **同义词** | **指令** |'
- en: '| --- | --- | --- | --- |'
  id: totrans-950
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- |'
- en: '| `cmpeqps` `x1``,` `x2` | `cmpps` `x1``,` `x2``, 0` | `cmpeqpd` `x1``,` `x2`
    | `cmppd` `x1``,` `x2``, 0` |'
  id: totrans-951
  prefs: []
  type: TYPE_TB
  zh: '| `cmpeqps` `x1``,` `x2` | `cmpps` `x1``,` `x2``, 0` | `cmpeqpd` `x1``,` `x2`
    | `cmppd` `x1``,` `x2``, 0` |'
- en: '| `cmpltps` `x1``,` `x2` | `cmpps` `x1``,` `x2``, 1` | `cmpltpd` `x1``,` `x2`
    | `cmppd` `x1``,` `x2``, 1` |'
  id: totrans-952
  prefs: []
  type: TYPE_TB
  zh: '| `cmpltps` `x1``,` `x2` | `cmpps` `x1``,` `x2``, 1` | `cmpltpd` `x1``,` `x2`
    | `cmppd` `x1``,` `x2``, 1` |'
- en: '| `cmpleps` `x1``,` `x2` | `cmpps` `x1``,` `x2``, 2` | `cmplepd` `x1``,` `x2`
    | `cmppd` `x1``,` `x2``, 2` |'
  id: totrans-953
  prefs: []
  type: TYPE_TB
  zh: '| `cmpleps` `x1``,` `x2` | `cmpps` `x1``,` `x2``, 2` | `cmlepd` `x1``,` `x2`
    | `cmppd` `x1``,` `x2``, 2` |'
- en: '| `cmpunordps` `x1``,` `x2` | `cmpps` `x1``,` `x2``, 3` | `cmpunordpd` `x1``,`
    `x2` | `cmppd x1, x2, 3` |'
  id: totrans-954
  prefs: []
  type: TYPE_TB
  zh: '| `cmpunordps` `x1``,` `x2` | `cmpps` `x1``,` `x2``, 3` | `cmpunordpd` `x1``,`
    `x2` | `cmppd` `x1``,` `x2``, 3` |'
- en: '| `cmpneqps` `x1``,` `x2` | `cmpps` `x1``,` `x2``, 4` | `cmpneqpd` `x1``,`
    `x2` | `cmppd` `x1``,` `x2``, 4` |'
  id: totrans-955
  prefs: []
  type: TYPE_TB
  zh: '| `cmpneqps` `x1``,` `x2` | `cmpps` `x1``,` `x2``, 4` | `cmpneqpd` `x1``,`
    `x2` | `cmppd` `x1``,` `x2``, 4` |'
- en: '| `cmpnltps` `x1``,` `x2` | `cmpps` `x1``,` `x2``, 5` | `cmpnltpd` `x1``,`
    `x2` | `cmppd` `x1``,` `x2``, 5` |'
  id: totrans-956
  prefs: []
  type: TYPE_TB
  zh: '| `cmpnltps` `x1``,` `x2` | `cmpps` `x1``,` `x2``, 5` | `cmpnltpd` `x1``,`
    `x2` | `cmppd` `x1``,` `x2``, 5` |'
- en: '| `cmpnleps` `x1``,` `x2` | `cmpps` `x1``,` `x2``, 6` | `cmpnlepd` `x1``,`
    `x2` | `cmppd` `x1``,` `x2``, 6` |'
  id: totrans-957
  prefs: []
  type: TYPE_TB
  zh: '| `cmpnleps` `x1``,` `x2` | `cmpps` `x1``,` `x2``, 6` | `cmpnlepd` `x1``,`
    `x2` | `cmppd` `x1``,` `x2``, 6` |'
- en: '| `cmpordps` `x1``,` `x2` | `cmpps` `x1``,` `x2``, 7` | `cmpordpd` `x1``,`
    `x2` | `cmppd` `x1``,` `x2``, 7` |'
  id: totrans-958
  prefs: []
  type: TYPE_TB
  zh: '| `cmpordps` `x1``,` `x2` | `cmpps` `x1``,` `x2``, 7` | `cmpordpd` `x1``,`
    `x2` | `cmppd` `x1``,` `x2``, 7` |'
- en: The synonyms allow you to write instructions such as
  id: totrans-959
  prefs: []
  type: TYPE_NORMAL
  zh: 同义词允许你编写诸如
- en: '[PRE94]'
  id: totrans-960
  prefs: []
  type: TYPE_PRE
  zh: '[PRE94]'
- en: rather than
  id: totrans-961
  prefs: []
  type: TYPE_NORMAL
  zh: 而不是
- en: '[PRE95]'
  id: totrans-962
  prefs: []
  type: TYPE_PRE
  zh: '[PRE95]'
- en: Obviously, using the synonym makes the code much easier to read and understand.
    There aren’t synonyms for all the possible comparisons. To create readable synonyms
    for the instructions MASM doesn’t support, you can use a macro (or a more readable
    symbolic constant). For more information on macros, see Chapter 13.
  id: totrans-963
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，使用同义词可以使代码更易读和理解。并非所有的比较都有同义词。为了创建易读的同义词，对于MASM不支持的指令，可以使用宏（或更具可读性的符号常量）。有关宏的更多信息，请参阅第13章。
- en: 11.12.5 AVX Extended Comparisons
  id: totrans-964
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 11.12.5 AVX扩展比较
- en: 'The AVX versions of these instructions allow three register operands: a destination
    XMM or YMM register, a source XMM or YMM register, and a source XMM or YMM register
    or 128-bit or 256-bit memory location (followed by the imm[8] operand specifying
    the type of the comparison). The basic syntax is the following:'
  id: totrans-965
  prefs: []
  type: TYPE_NORMAL
  zh: 这些指令的AVX版本支持三个寄存器操作数：目标XMM或YMM寄存器、源XMM或YMM寄存器，以及源XMM或YMM寄存器或128位或256位内存位置（后面跟着指定比较类型的imm[8]操作数）。基本语法如下：
- en: '[PRE96]'
  id: totrans-966
  prefs: []
  type: TYPE_PRE
  zh: '[PRE96]'
- en: The 128-bit `vcmpps` instruction compares the four single-precision floating-point
    values in each lane of the XMM[src1] register against the values in the corresponding
    XMM[src2]/mem[128] lanes and stores the true (all 1 bits) or false (all 0 bits)
    result into the corresponding lane of the XMM[dest] register. The 256-bit `vcmpps`
    instruction compares the eight single-precision floating-point values in each
    lane of the YMM[src1] register against the values in the corresponding YMM[src2]/mem[256]
    lanes and stores the true or false result into the corresponding lane of the YMM[dest]
    register.
  id: totrans-967
  prefs: []
  type: TYPE_NORMAL
  zh: 128位的`vcmpps`指令比较XMM[src1]寄存器每个通道中的四个单精度浮点值与相应的XMM[src2]/mem[128]通道中的值，并将结果（全1位表示真，全0位表示假）存储到XMM[dest]寄存器的相应通道。256位的`vcmpps`指令比较YMM[src1]寄存器每个通道中的八个单精度浮点值与相应的YMM[src2]/mem[256]通道中的值，并将真或假的结果存储到YMM[dest]寄存器的相应通道。
- en: The `vcmppd` instructions compare the double-precision values in the two lanes
    (128-bit version) or four lanes (256-bit version) and store the result into the
    corresponding lane of the destination register.
  id: totrans-968
  prefs: []
  type: TYPE_NORMAL
  zh: '`vcmppd`指令比较两个通道（128位版本）或四个通道（256位版本）中的双精度值，并将结果存储到目标寄存器的相应通道中。'
- en: As for the SSE compare instructions, the AVX instructions provide synonyms that
    eliminate the need to memorize 32 imm[8] values. [Table 11-30](#table11-30) lists
    the 32 instruction synonyms.
  id: totrans-969
  prefs: []
  type: TYPE_NORMAL
  zh: 对于SSE比较指令，AVX指令提供了同义词，省去了记忆32个imm[8]值的需要。[表11-30](#table11-30)列出了这32个指令同义词。
- en: 'Table 11-30: AVX Packed Compare Instructions'
  id: totrans-970
  prefs: []
  type: TYPE_NORMAL
  zh: 表11-30：AVX打包比较指令
- en: '| **imm[8]** | **Instruction** |'
  id: totrans-971
  prefs: []
  type: TYPE_TB
  zh: '| **imm[8]** | **指令** |'
- en: '| --- | --- |'
  id: totrans-972
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| 00h | `vcmpeqps` or `vcmpeqpd` |'
  id: totrans-973
  prefs: []
  type: TYPE_TB
  zh: '| 00h | `vcmpeqps` 或 `vcmpeqpd` |'
- en: '| 01h | `vcmpltps` or `vcmpltpd` |'
  id: totrans-974
  prefs: []
  type: TYPE_TB
  zh: '| 01h | `vcmpltps` 或 `vcmpltpd` |'
- en: '| 02h | `vcmpleps` or `vcmplepd` |'
  id: totrans-975
  prefs: []
  type: TYPE_TB
  zh: '| 02h | `vcmpleps` 或 `vcmplepd` |'
- en: '| 03h | `vcmpunordps` or `vcmpunordpd` |'
  id: totrans-976
  prefs: []
  type: TYPE_TB
  zh: '| 03h | `vcmpunordps` 或 `vcmpunordpd` |'
- en: '| 04h | `vcmpneqps` or `vcmpneqpd` |'
  id: totrans-977
  prefs: []
  type: TYPE_TB
  zh: '| 04h | `vcmpneqps` 或 `vcmpneqpd` |'
- en: '| 05h | `vcmpltps` or `vcmpltpd` |'
  id: totrans-978
  prefs: []
  type: TYPE_TB
  zh: '| 05h | `vcmpltps` 或 `vcmpltpd` |'
- en: '| 06h | `vcmpleps` or `vcmplepd` |'
  id: totrans-979
  prefs: []
  type: TYPE_TB
  zh: '| 06h | `vcmpleps` 或 `vcmplepd` |'
- en: '| 07h | `vcmpordps` or `vcmpordpd` |'
  id: totrans-980
  prefs: []
  type: TYPE_TB
  zh: '| 07h | `vcmpordps` 或 `vcmpordpd` |'
- en: '| 08h | `vcmpeq_uqps` or `vcmpeq_uqpd` |'
  id: totrans-981
  prefs: []
  type: TYPE_TB
  zh: '| 08h | `vcmpeq_uqps` 或 `vcmpeq_uqpd` |'
- en: '| 09h | `vcmpngeps` or `vcmpngepd` |'
  id: totrans-982
  prefs: []
  type: TYPE_TB
  zh: '| 09h | `vcmpngeps` 或 `vcmpngepd` |'
- en: '| 0Ah | `vcmpngtps` or `vcmpngtpd` |'
  id: totrans-983
  prefs: []
  type: TYPE_TB
  zh: '| 0Ah | `vcmpngtps` 或 `vcmpngtpd` |'
- en: '| 0Bh | `vcmpfalseps` or `vcmpfalsepd` |'
  id: totrans-984
  prefs: []
  type: TYPE_TB
  zh: '| 0Bh | `vcmpfalseps` 或 `vcmpfalsepd` |'
- en: '| 0Ch | `vcmpneq_oqps` or `vcmpneq_oqpd` |'
  id: totrans-985
  prefs: []
  type: TYPE_TB
  zh: '| 0Ch | `vcmpneq_oqps` 或 `vcmpneq_oqpd` |'
- en: '| 0Dh | `vcmpgeps` or `vcmpgepd` |'
  id: totrans-986
  prefs: []
  type: TYPE_TB
  zh: '| 0Dh | `vcmpgeps` 或 `vcmpgepd` |'
- en: '| 0Eh | `vcmpgtps` or `vcmpgtpd` |'
  id: totrans-987
  prefs: []
  type: TYPE_TB
  zh: '| 0Eh | `vcmpgtps` 或 `vcmpgtpd` |'
- en: '| 0Fh | `vcmptrueps` or `vcmptruepd` |'
  id: totrans-988
  prefs: []
  type: TYPE_TB
  zh: '| 0Fh | `vcmptrueps` 或 `vcmptruepd` |'
- en: '| 10h | `vcmpeq_osps` or `vcmpeq_ospd` |'
  id: totrans-989
  prefs: []
  type: TYPE_TB
  zh: '| 10h | `vcmpeq_osps` 或 `vcmpeq_ospd` |'
- en: '| 11h | `vcmplt_oqps` or `vcmplt_oqpd` |'
  id: totrans-990
  prefs: []
  type: TYPE_TB
  zh: '| 11h | `vcmplt_oqps` 或 `vcmplt_oqpd` |'
- en: '| 12h | `vcmple_oqps` or `vcmple_oqpd` |'
  id: totrans-991
  prefs: []
  type: TYPE_TB
  zh: '| 12h | `vcmple_oqps` 或 `vcmple_oqpd` |'
- en: '| 13h | `vcmpunord_sps` or `vcmpunord_spd` |'
  id: totrans-992
  prefs: []
  type: TYPE_TB
  zh: '| 13h | `vcmpunord_sps` 或 `vcmpunord_spd` |'
- en: '| 14h | `vcmpneq_usps` or `vcmpneq_uspd` |'
  id: totrans-993
  prefs: []
  type: TYPE_TB
  zh: '| 14h | `vcmpneq_usps` 或 `vcmpneq_uspd` |'
- en: '| 15h | `vcmpnlt_uqps` or `vcmpnlt_uqpd` |'
  id: totrans-994
  prefs: []
  type: TYPE_TB
  zh: '| 15h | `vcmpnlt_uqps` 或 `vcmpnlt_uqpd` |'
- en: '| 16h | `vcmpnle_uqps` or `vcmpnle_uqpd` |'
  id: totrans-995
  prefs: []
  type: TYPE_TB
  zh: '| 16h | `vcmpnle_uqps` 或 `vcmpnle_uqpd` |'
- en: '| 17h | `vcmpord_sps` or `vcmpord_spd` |'
  id: totrans-996
  prefs: []
  type: TYPE_TB
  zh: '| 17h | `vcmpord_sps` 或 `vcmpord_spd` |'
- en: '| 18h | `vcmpeq_usps` or `vcmpeq_uspd` |'
  id: totrans-997
  prefs: []
  type: TYPE_TB
  zh: '| 18h | `vcmpeq_usps` 或 `vcmpeq_uspd` |'
- en: '| 19h | `vcmpnge_uqps` or `vcmpnge_uqpd` |'
  id: totrans-998
  prefs: []
  type: TYPE_TB
  zh: '| 19h | `vcmpnge_uqps` 或 `vcmpnge_uqpd` |'
- en: '| 1Ah | `vcmpngt_uqps` or `vcmpngt_uqpd` |'
  id: totrans-999
  prefs: []
  type: TYPE_TB
  zh: '| 1Ah | `vcmpngt_uqps` 或 `vcmpngt_uqpd` |'
- en: '| 1Bh | `vcmpfalse_osps` or `vcmpfalse_ospd` |'
  id: totrans-1000
  prefs: []
  type: TYPE_TB
  zh: '| 1Bh | `vcmpfalse_osps` 或 `vcmpfalse_ospd` |'
- en: '| 1Ch | `vcmpneq_osps` or `vcmpneq_ospd` |'
  id: totrans-1001
  prefs: []
  type: TYPE_TB
  zh: '| 1Ch | `vcmpneq_osps` 或 `vcmpneq_ospd` |'
- en: '| 1Dh | vcmpge_oqps or `vcmpge_oqpd` |'
  id: totrans-1002
  prefs: []
  type: TYPE_TB
  zh: '| 1Dh | `vcmpge_oqps` 或 `vcmpge_oqpd` |'
- en: '| 1Eh | `vcmpgt_oqps` or `vcmpgt_oqpd` |'
  id: totrans-1003
  prefs: []
  type: TYPE_TB
  zh: '| 1Eh | `vcmpgt_oqps` 或 `vcmpgt_oqpd` |'
- en: '| 1Fh | `vcmptrue_usps` or `vcmptrue_uspd` |'
  id: totrans-1004
  prefs: []
  type: TYPE_TB
  zh: '| 1Fh | `vcmptrue_usps` 或 `vcmptrue_uspd` |'
- en: 11.12.6 Using SIMD Comparison Instructions
  id: totrans-1005
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 11.12.6 使用 SIMD 比较指令
- en: As for the integer comparisons (see “Using Packed Comparison Results” on page
    662), the floating-point comparison instructions produce a vector of Boolean results
    that you use to mask further operations on data lanes. You can use the packed
    logical instructions (`pand` and `vpand`, `pandn` and `vpandn`, `por` and `vpor`,
    and `pxor` and `vpxor`) to manipulate these results. You could extract the individual
    lane values and test them with a conditional jump, though this is definitely not
    the SIMD way of doing things; the following section describes one way to extract
    these masks.
  id: totrans-1006
  prefs: []
  type: TYPE_NORMAL
  zh: 对于整数比较（见第 662 页的“使用打包比较结果”），浮点比较指令生成一个布尔结果的向量，你可以用这个向量对数据通道执行进一步操作。你可以使用打包逻辑指令（`pand`
    和 `vpand`，`pandn` 和 `vpandn`，`por` 和 `vpor`，以及 `pxor` 和 `vpxor`）来处理这些结果。你还可以提取单个通道的值，并用条件跳转来测试它们，尽管这绝对不是
    SIMD 的处理方式；接下来的章节会描述一种提取这些掩码的方法。
- en: 11.12.7 The (v)movmskps, (v)movmskpd Instructions
  id: totrans-1007
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 11.12.7 (v)movmskps、(v)movmskpd 指令
- en: The `movmskps` and `movmskpd` instructions extract the sign bits from their
    packed single- and double-precision floating-point source operands and store these
    bits into the LO 4 (or 8) bits of a general-purpose register. The syntax is
  id: totrans-1008
  prefs: []
  type: TYPE_NORMAL
  zh: '`movmskps` 和 `movmskpd` 指令从它们的打包单精度和双精度浮点源操作数中提取符号位，并将这些位存储到通用寄存器的低 4 位（或 8
    位）中。其语法为'
- en: '[PRE97]'
  id: totrans-1009
  prefs: []
  type: TYPE_PRE
  zh: '[PRE97]'
- en: where `reg` is any 32-bit or 64-bit general-purpose integer register.
  id: totrans-1010
  prefs: []
  type: TYPE_NORMAL
  zh: 其中 `reg` 是任意 32 位或 64 位通用整数寄存器。
- en: The `movmskps` instruction extracts the sign bits from the four single-precision
    floating-point values in the XMM source register and copies these bits to the
    LO 4 bits of the destination register, as shown in [Figure 11-45](#figure11-45).
  id: totrans-1011
  prefs: []
  type: TYPE_NORMAL
  zh: '`movmskps` 指令从 XMM 源寄存器中的四个单精度浮点值中提取符号位，并将这些位复制到目标寄存器的低 4 位中，如[图 11-45](#figure11-45)所示。'
- en: The `movmskpd` instruction copies the sign bits from the two double-precision
    floating-point values in the source XMM register to bits 0 and 1 of the destination
    register, as [Figure 11-46](#figure11-46) shows.
  id: totrans-1012
  prefs: []
  type: TYPE_NORMAL
  zh: '`movmskpd` 指令将源 XMM 寄存器中的两个双精度浮点值的符号位复制到目标寄存器的第 0 位和第 1 位，如[图 11-46](#figure11-46)所示。'
- en: The `vmovmskps` instruction extracts the sign bits from the four and eight single-precision
    floating-point values in the XMM and YMM source register and copies these bits
    to the LO 4 and 8 bits of the destination register. [Figure 11-47](#figure11-47)
    shows this operation with a YMM source register.
  id: totrans-1013
  prefs: []
  type: TYPE_NORMAL
  zh: '`vmovmskps` 指令从 XMM 和 YMM 源寄存器中的四个或八个单精度浮点值中提取符号位，并将这些位复制到目标寄存器的低 4 位或 8 位中。[图
    11-47](#figure11-47) 显示了使用 YMM 源寄存器的这一操作。'
- en: '![f11045](image_fi/501089c11/f11045.png)'
  id: totrans-1014
  prefs: []
  type: TYPE_IMG
  zh: '![f11045](image_fi/501089c11/f11045.png)'
- en: 'Figure 11-45: `movmskps` operation'
  id: totrans-1015
  prefs: []
  type: TYPE_NORMAL
  zh: '图 11-45: `movmskps` 操作'
- en: '![f11046](image_fi/501089c11/f11046.png)'
  id: totrans-1016
  prefs: []
  type: TYPE_IMG
  zh: '![f11046](image_fi/501089c11/f11046.png)'
- en: 'Figure 11-46: `movmskpd` operation'
  id: totrans-1017
  prefs: []
  type: TYPE_NORMAL
  zh: '图 11-46: `movmskpd` 操作'
- en: '![f11047](image_fi/501089c11/f11047.png)'
  id: totrans-1018
  prefs: []
  type: TYPE_IMG
  zh: '![f11047](image_fi/501089c11/f11047.png)'
- en: 'Figure 11-47: `vmovmskps` operation'
  id: totrans-1019
  prefs: []
  type: TYPE_NORMAL
  zh: '图 11-47: `vmovmskps` 操作'
- en: The `vmovmskpd` instruction copies the sign bits from the four double-precision
    floating-point values in the source YMM register to bits 0 to 3 of the destination
    register, as shown in [Figure 11-48](#figure11-48).
  id: totrans-1020
  prefs: []
  type: TYPE_NORMAL
  zh: '`vmovmskpd` 指令从源 YMM 寄存器中的四个双精度浮点值复制符号位到目标寄存器的第 0 到第 3 位中，如[图 11-48](#figure11-48)所示。'
- en: '![f11048](image_fi/501089c11/f11048.png)'
  id: totrans-1021
  prefs: []
  type: TYPE_IMG
  zh: '![f11048](image_fi/501089c11/f11048.png)'
- en: 'Figure 11-48: `vmovmskpd` operation'
  id: totrans-1022
  prefs: []
  type: TYPE_NORMAL
  zh: '图 11-48: `vmovmskpd` 操作'
- en: This instruction, with an XMM source register, will copy the sign bits from
    the two double-precision floating-point values into bits 0 and 1 of the destination
    register. In all cases, these instructions zero-extend the results into the upper
    bits of the general-purpose destination register. Note that these instructions
    do not allow memory operands.
  id: totrans-1023
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用 XMM 源寄存器时，此指令将从两个双精度浮点值中复制符号位到目标寄存器的第 0 位和第 1 位。在所有情况下，这些指令会将结果零扩展到通用目标寄存器的高位。请注意，这些指令不允许使用内存操作数。
- en: Although the stated data type for these instructions is packed single-precision
    and packed double-precision, you will also use these instructions on 32-bit integers
    (`movmskps` and `vmovmskps`) and 64-bit integers (`movmskpd` and `vmovmskpd`).
    Specifically, these instructions are perfect for extracting 1-bit Boolean values
    from the various lanes after one of the (dword or qword) packed integer comparisons
    as well as after the single- or double-precision floating-point comparisons (remember
    that although the packed floating-point comparisons compare floating-point values,
    their results are actually integer values).
  id: totrans-1024
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这些指令的声明数据类型是打包单精度和打包双精度，但你也将使用这些指令处理32位整数（`movmskps`和`vmovmskps`）和64位整数（`movmskpd`和`vmovmskpd`）。具体来说，这些指令非常适合从各种通道中提取1位布尔值，尤其是在进行（dword或qword）打包整数比较之后，以及在进行单精度或双精度浮点比较后（请记住，虽然打包浮点比较比较的是浮点值，其结果实际上是整数值）。
- en: 'Consider the following instruction sequence:'
  id: totrans-1025
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下指令序列：
- en: '[PRE98]'
  id: totrans-1026
  prefs: []
  type: TYPE_PRE
  zh: '[PRE98]'
- en: Because `movmskpd` extracts 2 bits from XMM0 and stores them into RAX, this
    code can use RAX as an index into a jump table to select four different branch
    labels. The code at label `nene` executes if both comparisons produce not equal;
    label `neeq` is the target when the lane 0 values are equal but the lane 1 values
    are not equal. Label `eqne` is the target when the lane 0 values are not equal
    but the lane 1 values are equal. Finally, label `eqeq` is where this code branches
    when both sets of lanes contain equal values.
  id: totrans-1027
  prefs: []
  type: TYPE_NORMAL
  zh: 由于`movmskpd`从XMM0提取2位并将它们存储到RAX中，因此这段代码可以使用RAX作为跳转表的索引来选择四个不同的分支标签。如果两个比较都产生不相等，`nene`标签下的代码会执行；当通道0的值相等但通道1的值不等时，跳转到`neeq`标签；当通道0的值不等但通道1的值相等时，跳转到`eqne`标签；最后，当两个通道的值都相等时，跳转到`eqeq`标签。
- en: 11.13 Floating-Point Conversion Instructions
  id: totrans-1028
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 11.13 浮点转换指令
- en: Previously, I described several instructions to convert data between various
    scalar floating-point and integer formats (see “SSE Floating-Point Conversions”
    in Chapter 6). Variants of these instructions also exist for packed data conversions.
    [Table 11-31](#table11-31) lists many of these instructions you will commonly
    use.
  id: totrans-1029
  prefs: []
  type: TYPE_NORMAL
  zh: 在之前的描述中，我介绍了几条指令，用于在各种标量浮点数和整数格式之间转换数据（详见第六章的“SSE浮点转换”）。这些指令的变体也存在于打包数据转换中。[表11-31](#table11-31)列出了你将常用的许多这些指令。
- en: 'Table 11-31: SSE Conversion Instructions'
  id: totrans-1030
  prefs: []
  type: TYPE_NORMAL
  zh: 表11-31：SSE转换指令
- en: '| **Instruction syntax** | **Description** |'
  id: totrans-1031
  prefs: []
  type: TYPE_TB
  zh: '| **指令语法** | **描述** |'
- en: '| --- | --- |'
  id: totrans-1032
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `cvtdq2pd` `xmm`[dest]`,` `xmm`[src]`/``mem`[64] | Converts two packed signed
    double-word integers from XMM[src]/mem[64] to two packed double-precision floating-point
    values in XMM[dest]. If YMM register is present, this instruction leaves the HO
    bits unchanged. |'
  id: totrans-1033
  prefs: []
  type: TYPE_TB
  zh: '| `cvtdq2pd` `xmm`[dest]`,` `xmm`[src]`/``mem`[64] | 将XMM[src]/mem[64]中的两个打包带符号双字整数转换为XMM[dest]中的两个打包双精度浮点值。如果存在YMM寄存器，则此指令保持HO位不变。
    |'
- en: '| `vcvtdq2pd` `xmm`[dest]`,` `xmm`[src]`/``mem`[64] | (AVX) Converts two packed
    signed double-word integers from XMM[src]/mem[64] to two packed double-precision
    floating-point values in XMM[dest]. This instruction stores 0s into the HO bits
    of the underlying YMM register. |'
  id: totrans-1034
  prefs: []
  type: TYPE_TB
  zh: '| `vcvtdq2pd` `xmm`[dest]`,` `xmm`[src]`/``mem`[64] | （AVX）将XMM[src]/mem[64]中的两个打包带符号双字整数转换为XMM[dest]中的两个打包双精度浮点值。此指令将0存储到底层YMM寄存器的HO位。
    |'
- en: '| `vcvtdq2pd` `ymm`[dest]`,` `xmm`[src]`/``mem`[128] | (AVX) Converts four
    packed signed double-word integers from XMM[src]/mem[128] to four packed double-precision
    floating-point values in YMM[dest]. |'
  id: totrans-1035
  prefs: []
  type: TYPE_TB
  zh: '| `vcvtdq2pd` `ymm`[dest]`,` `xmm`[src]`/``mem`[128] | （AVX）将XMM[src]/mem[128]中的四个打包带符号双字整数转换为YMM[dest]中的四个打包双精度浮点值。
    |'
- en: '| `cvtdq2ps` `xmm`[dest]`,` `xmm`[src]`/``mem`[128] | Converts four packed
    signed double-word integers from XMM[src]/mem[128] to four packed single-precision
    floating-point values in XMM[dest]. If YMM register is present, this instruction
    leaves the HO bits unchanged. |'
  id: totrans-1036
  prefs: []
  type: TYPE_TB
  zh: '| `cvtdq2ps` `xmm`[dest]`,` `xmm`[src]`/``mem`[128] | 将XMM[src]/mem[128]中的四个打包带符号双字整数转换为XMM[dest]中的四个打包单精度浮点值。如果存在YMM寄存器，则此指令保持HO位不变。
    |'
- en: '| `vcvtdq2ps` `xmm`[dest]`,` `xmm`[src]`/``mem`[128] | (AVX) Converts four
    packed signed double-word integers from XMM[src]/mem[128] to four packed single-precision
    floating-point values in XMM[dest]. If YMM register is present, this instruction
    writes 0s to the HO bits. |'
  id: totrans-1037
  prefs: []
  type: TYPE_TB
  zh: '| `vcvtdq2ps` `xmm`[dest]`,` `xmm`[src]`/``mem`[128] | （AVX）将XMM[src]/mem[128]中的四个打包带符号双字整数转换为XMM[dest]中的四个打包单精度浮点值。如果存在YMM寄存器，则此指令将0写入HO位。
    |'
- en: '| `vcvtdq2ps` `ymm`[dest]`,` `ymm`[src]`/``mem`[256] | (AVX) Converts eight
    packed signed double-word integers from YMM[src]/mem[256] to eight packed single-precision
    floating-point values in YMM[dest]. If YMM register is present, this instruction
    writes 0s to the HO bits. |'
  id: totrans-1038
  prefs: []
  type: TYPE_TB
  zh: '| `vcvtdq2ps` `ymm`[dest]`,` `ymm`[src]`/``mem`[256] | (AVX) 将 YMM[src]/mem[256]
    中的八个打包的有符号双字整数转换为 YMM[dest] 中的八个打包的单精度浮点值。如果 YMM 寄存器存在，此指令将 HO 位写入 0。|'
- en: '| `cvtpd2dq` `xmm`[dest]`,` `xmm`[src]`/``mem`[128] | Converts two packed double-precision
    floating-point values from XMM[src]/mem[128] to two packed signed double-word
    integers in XMM[dest]. If YMM register is present, this instruction leaves the
    HO bits unchanged. The conversion from floating-point to integer uses the current
    SSE rounding mode. |'
  id: totrans-1039
  prefs: []
  type: TYPE_TB
  zh: '| `cvtpd2dq` `xmm`[dest]`,` `xmm`[src]`/``mem`[128] | 将 XMM[src]/mem[128] 中的两个打包的双精度浮点值转换为
    XMM[dest] 中的两个打包的有符号双字整数。如果 YMM 寄存器存在，此指令将保持 HO 位不变。浮点到整数的转换使用当前的 SSE 四舍五入模式。|'
- en: '| `vcvtpd2dq` `xmm`[dest]`,` `xmm`[src]`/``mem`[128] | (AVX) Converts two packed
    double-precision floating-point values from XMM[src]/mem[128] to two packed signed
    double-word integers in XMM[dest]. This instruction stores 0s into the HO bits
    of the underlying YMM register. The conversion from floating-point to integer
    uses the current AVX rounding mode. |'
  id: totrans-1040
  prefs: []
  type: TYPE_TB
  zh: '| `vcvtpd2dq` `xmm`[dest]`,` `xmm`[src]`/``mem`[128] | (AVX) 将 XMM[src]/mem[128]
    中的两个打包的双精度浮点值转换为 XMM[dest] 中的两个打包的有符号双字整数。此指令将 0 存入底层 YMM 寄存器的 HO 位。浮点到整数的转换使用当前的
    AVX 四舍五入模式。|'
- en: '| `vcvtpd2dq` `xmm`[dest]`,` `ymm`[src]`/``mem`[256] | (AVX) Converts four
    packed double-precision floating-point values from YMM[src]/mem[256] to four packed
    signed double-word integers in XMM[dest]. The conversion of floating-point to
    integer uses the current AVX rounding mode. |'
  id: totrans-1041
  prefs: []
  type: TYPE_TB
  zh: '| `vcvtpd2dq` `xmm`[dest]`,` `ymm`[src]`/``mem`[256] | (AVX) 将 YMM[src]/mem[256]
    中的四个打包的双精度浮点值转换为 XMM[dest] 中的四个打包的有符号双字整数。浮点到整数的转换使用当前的 AVX 四舍五入模式。|'
- en: '| `cvtpd2ps` `xmm`[dest]`,` `xmm`[src]`/``mem`[128] | Converts two packed double-precision
    floating-point values from XMM[src]/mem[128] to two packed single-precision floating-point
    values in XMM[dest]. If YMM register is present, this instruction leaves the HO
    bits unchanged. |'
  id: totrans-1042
  prefs: []
  type: TYPE_TB
  zh: '| `cvtpd2ps` `xmm`[dest]`,` `xmm`[src]`/``mem`[128] | 将 XMM[src]/mem[128] 中的两个打包的双精度浮点值转换为
    XMM[dest] 中的两个打包的单精度浮点值。如果 YMM 寄存器存在，此指令将保持 HO 位不变。|'
- en: '| `vcvtpd2ps` `xmm`[dest]`,` `xmm`[src]`/``mem`[128] | (AVX) Converts two packed
    double-precision floating-point values from XMM[src]/mem[128] to two packed single-precision
    floating-point values in XMM[dest]. This instruction stores 0s into the HO bits
    of the underlying YMM register. |'
  id: totrans-1043
  prefs: []
  type: TYPE_TB
  zh: '| `vcvtpd2ps` `xmm`[dest]`,` `xmm`[src]`/``mem`[128] | (AVX) 将 XMM[src]/mem[128]
    中的两个打包的双精度浮点值转换为 XMM[dest] 中的两个打包的单精度浮点值。此指令将 0 存入底层 YMM 寄存器的 HO 位。|'
- en: '| `vcvtpd2ps` `xmm`[dest]`,` `ymm`[src]`/``mem`[256] | (AVX) Converts four
    packed double-precision floating-point values from YMM[src]/mem[256] to four packed
    single-precision floating-point values in YMM[dest]. |'
  id: totrans-1044
  prefs: []
  type: TYPE_TB
  zh: '| `vcvtpd2ps` `xmm`[dest]`,` `ymm`[src]`/``mem`[256] | (AVX) 将 YMM[src]/mem[256]
    中的四个打包的双精度浮点值转换为 YMM[dest] 中的四个打包的单精度浮点值。|'
- en: '| `cvtps2dq` `xmm`[dest]`,` `xmm`[src]`/``mem`[128] | Converts four packed
    single-precision floating-point values from XMM[src]/mem[128] to four packed signed
    double-word integers in XMM[dest]. If YMM register is present, this instruction
    leaves the HO bits unchanged. The conversion of floating-point to integer uses
    the current SSE rounding mode. |'
  id: totrans-1045
  prefs: []
  type: TYPE_TB
  zh: '| `cvtps2dq` `xmm`[dest]`,` `xmm`[src]`/``mem`[128] | 将 XMM[src]/mem[128] 中的四个打包的单精度浮点值转换为
    XMM[dest] 中的四个打包的有符号双字整数。如果 YMM 寄存器存在，此指令将保持 HO 位不变。浮点到整数的转换使用当前的 SSE 四舍五入模式。|'
- en: '| `vcvtps2dq` `xmm`[dest]`,` `xmm`[src]`/``mem`[128] | (AVX) Converts four
    packed single-precision floating-point values from XMM[src]/mem[128] to four packed
    signed double-word integers in XMM[dest]. This instruction stores 0s into the
    HO bits of the underlying YMM register. The conversion of floating-point to integer
    uses the current AVX rounding mode. |'
  id: totrans-1046
  prefs: []
  type: TYPE_TB
  zh: '| `vcvtps2dq` `xmm`[dest]`,` `xmm`[src]`/``mem`[128] | (AVX) 将 XMM[src]/mem[128]
    中的四个打包的单精度浮点值转换为 XMM[dest] 中的四个打包的有符号双字整数。此指令将 0 存入底层 YMM 寄存器的 HO 位。浮点到整数的转换使用当前的
    AVX 四舍五入模式。|'
- en: '| `vcvtps2dq` `ymm`[dest]`,` `ymm`[src]`/``mem`[256] | (AVX) Converts eight
    packed single-precision floating-point values from YMM[src]/mem[256] to eight
    packed signed double-word integers in YMM[dest]. The conversion of floating-point
    to integer uses the current AVX rounding mode. |'
  id: totrans-1047
  prefs: []
  type: TYPE_TB
  zh: '| `vcvtps2dq` `ymm`[dest]`,` `ymm`[src]`/``mem`[256] | （AVX）将来自YMM[src]/mem[256]的八个打包的单精度浮点值转换为YMM[dest]中的八个打包的有符号双字整数。浮点到整数的转换使用当前的AVX舍入模式。
    |'
- en: '| `cvtps2pd` `xmm`[dest]`,` `xmm`[src]`/``mem`[64] | Converts two packed single-precision
    floating-point values from XMM[src]/mem[64] to two packed double-precision values
    in XMM[dest]. If YMM register is present, this instruction leaves the HO bits
    unchanged. |'
  id: totrans-1048
  prefs: []
  type: TYPE_TB
  zh: '| `cvtps2pd` `xmm`[dest]`,` `xmm`[src]`/``mem`[64] | 将来自XMM[src]/mem[64]的两个打包的单精度浮点值转换为XMM[dest]中的两个打包的双精度值。如果存在YMM寄存器，此指令将保持HO位不变。
    |'
- en: '| `vcvtps2pd` `xmm`[dest]`,` `xmm`[src]`/``mem`[64] | (AVX) Converts two packed
    single-precision floating-point values from XMM[src]/mem[64] to two packed double-precision
    values in XMM[dest]. This instruction stores 0s into the HO bits of the underlying
    YMM register. |'
  id: totrans-1049
  prefs: []
  type: TYPE_TB
  zh: '| `vcvtps2pd` `xmm`[dest]`,` `xmm`[src]`/``mem`[64] | （AVX）将来自XMM[src]/mem[64]的两个打包的单精度浮点值转换为XMM[dest]中的两个打包的双精度值。此指令将0存储到底层YMM寄存器的HO位。
    |'
- en: '| `vcvtps2pd` `ymm`[dest]`,` `xmm`[src]`/``mem`[128] | (AVX) Converts four
    packed single-precision floating-point values from XMM[src]/mem[128] to four packed
    double-precision values in YMM[dest]. |'
  id: totrans-1050
  prefs: []
  type: TYPE_TB
  zh: '| `vcvtps2pd` `ymm`[dest]`,` `xmm`[src]`/``mem`[128] | （AVX）将来自XMM[src]/mem[128]的四个打包的单精度浮点值转换为YMM[dest]中的四个打包的双精度值。
    |'
- en: '| `cvttpd2dq` `xmm`[dest]`,` `xmm`[src]`/``mem`[128] | Converts two packed
    double-precision floating-point values from XMM[src]/mem[128] to two packed signed
    double-word integers in XMM[dest] using truncation. If YMM register is present,
    this instruction leaves the HO bits unchanged. |'
  id: totrans-1051
  prefs: []
  type: TYPE_TB
  zh: '| `cvttpd2dq` `xmm`[dest]`,` `xmm`[src]`/``mem`[128] | 将来自XMM[src]/mem[128]的两个打包的双精度浮点值转换为XMM[dest]中的两个打包的有符号双字整数，使用截断。如果存在YMM寄存器，此指令将保持HO位不变。
    |'
- en: '| `vcvttpd2dq` `xmm`[dest]`,` `xmm`[src]`/``mem`[128] | (AVX) Converts two
    packed double-precision floating-point values from XMM[src]/mem[128] to two packed
    signed double-word integers in XMM[dest] using truncation. This instruction stores
    0s into the HO bits of the underlying YMM register. |'
  id: totrans-1052
  prefs: []
  type: TYPE_TB
  zh: '| `vcvttpd2dq` `xmm`[dest]`,` `xmm`[src]`/``mem`[128] | （AVX）将来自XMM[src]/mem[128]的两个打包的双精度浮点值转换为XMM[dest]中的两个打包的有符号双字整数，使用截断。此指令将0存储到底层YMM寄存器的HO位。
    |'
- en: '| `vcvttpd2dq` `xmm`[dest]`,` `ymm`[src]`/``mem`[256] | (AVX) Converts four
    packed double-precision floating-point values from YMM[src]/mem[256] to four packed
    signed double-word integers in XMM[dest] using truncation. |'
  id: totrans-1053
  prefs: []
  type: TYPE_TB
  zh: '| `vcvttpd2dq` `xmm`[dest]`,` `ymm`[src]`/``mem`[256] | （AVX）将来自YMM[src]/mem[256]的四个打包的双精度浮点值转换为XMM[dest]中的四个打包的有符号双字整数，使用截断。
    |'
- en: '| `cvttps2dq` `xmm`[dest]`,` `xmm`[src]`/``mem`[128] | Converts four packed
    single-precision floating-point values from XMM[src]/mem[128] to four packed signed
    double-word integers in XMM[dest] using truncation. If YMM register is present,
    this instruction leaves the HO bits unchanged. |'
  id: totrans-1054
  prefs: []
  type: TYPE_TB
  zh: '| `cvttps2dq` `xmm`[dest]`,` `xmm`[src]`/``mem`[128] | 将来自XMM[src]/mem[128]的四个打包的单精度浮点值转换为XMM[dest]中的四个打包的有符号双字整数，使用截断。如果存在YMM寄存器，此指令将保持HO位不变。
    |'
- en: '| `vcvttps2dq` `xmm`[dest]`,` `xmm`[src]`/``mem`[128] | (AVX) Converts four
    packed single-precision floating-point values from XMM[src]/mem[128] to four packed
    signed double-word integers in XMM[dest] using truncation. This instruction stores
    0s into the HO bits of the underlying YMM register. |'
  id: totrans-1055
  prefs: []
  type: TYPE_TB
  zh: '| `vcvttps2dq` `xmm`[dest]`,` `xmm`[src]`/``mem`[128] | （AVX）将来自XMM[src]/mem[128]的四个打包的单精度浮点值转换为XMM[dest]中的四个打包的有符号双字整数，使用截断。此指令将0存储到底层YMM寄存器的HO位。
    |'
- en: '| `vcvttps2dq` `ymm`[dest]`,` `ymm`[src]`/``mem`[256] | (AVX) Converts eight
    packed single-precision floating-point values from YMM[src]/mem[256] to eight
    packed signed double-word integers in YMM[dest] using truncation. |'
  id: totrans-1056
  prefs: []
  type: TYPE_TB
  zh: '| `vcvttps2dq` `ymm`[dest]`,` `ymm`[src]`/``mem`[256] | （AVX）将来自YMM[src]/mem[256]的八个打包的单精度浮点值转换为YMM[dest]中的八个打包的有符号双字整数，使用截断。
    |'
- en: 11.14 Aligning SIMD Memory Accesses
  id: totrans-1057
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 11.14 对齐SIMD内存访问
- en: Most SSE and AVX instructions require their memory operands to be on a 16-byte
    (SSE) or 32-byte (AVX) boundary, but this is not always possible. The easiest
    way to handle unaligned memory addresses is to use instructions that don’t require
    aligned memory operands, like `movdqu`, `movups`, and `movupd`. However, the performance
    hit of using unaligned data movement instructions often defeats the purpose of
    using SSE/AVX instructions in the first place.
  id: totrans-1058
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数 SSE 和 AVX 指令要求它们的内存操作数位于 16 字节（SSE）或 32 字节（AVX）边界上，但这并不总是可能的。处理未对齐内存地址的最简单方法是使用不要求对齐内存操作数的指令，例如
    `movdqu`、`movups` 和 `movupd`。然而，使用未对齐的数据移动指令的性能损失通常会削弱使用 SSE/AVX 指令的初衷。
- en: 'Instead, the trick to aligning data for use by SIMD instructions is to process
    the first few data items by using standard general-purpose registers until you
    reach an address that is aligned properly. For example, suppose you want to use
    the `pcmpeqb` instruction to compare blocks of 16 bytes in a large array of bytes.
    `pcmpeqb` requires its memory operands to be at 16-byte-aligned addresses, so
    if the memory operand is not already 16-byte-aligned, you can process the first
    1 to 15 bytes in the array by using standard (non-SSE) instructions until you
    reach an appropriate address for `pcmpeqb`; for example:'
  id: totrans-1059
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，SIMD 指令对齐数据的技巧是通过使用标准的通用寄存器处理前几个数据项，直到达到一个正确对齐的地址。例如，假设你想使用 `pcmpeqb` 指令比较一个大字节数组中的
    16 字节块。`pcmpeqb` 要求它的内存操作数位于 16 字节对齐的地址上，因此如果内存操作数尚未 16 字节对齐，你可以使用标准（非 SSE）指令处理数组中的前
    1 到 15 个字节，直到你达到一个适合 `pcmpeqb` 的地址。例如：
- en: '[PRE99]'
  id: totrans-1060
  prefs: []
  type: TYPE_PRE
  zh: '[PRE99]'
- en: ANDing RSI with 0Fh produces a 0 result (and sets the zero flag) if the LO 4
    bits of RSI contain 0\. If the LO 4 bits of RSI contain 0, the address it contains
    is aligned on a 16-byte boundary.^([16](#c11-footnote-18))
  id: totrans-1061
  prefs: []
  type: TYPE_NORMAL
  zh: 将 RSI 与 0Fh 进行按位与运算，如果 RSI 的低 4 位包含 0，则会产生 0 的结果（并设置零标志）。如果 RSI 的低 4 位包含 0，则它所包含的地址是按
    16 字节边界对齐的。^([16](#c11-footnote-18))
- en: The only drawback to this approach is that you must process as many as 15 bytes
    individually until you get an appropriate address. That’s 6 × 15, or 90, machine
    instructions. However, for large blocks of data (say, more than about 48 or 64
    bytes), you amortize the cost of the single-byte comparisons, and this approach
    isn’t so bad.
  id: totrans-1062
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法的唯一缺点是，在获得适当地址之前，你必须单独处理最多 15 字节。那是 6 × 15，或者 90 条机器指令。然而，对于大块数据（例如，超过约
    48 或 64 字节），你可以摊销单字节比较的成本，这种方法就不那么糟糕了。
- en: To improve the performance of this code, you can modify the initial address
    so that it begins at a 16-byte boundary. ANDing the value in RSI (in this particular
    example) with 0FFFFFFFFFFFFFFF0h (–16) modifies RSI so that it holds the address
    of the start of the 16-byte block containing the original address:^([17](#c11-footnote-19))
  id: totrans-1063
  prefs: []
  type: TYPE_NORMAL
  zh: 为了提高这段代码的性能，你可以修改初始地址，使其从 16 字节边界开始。将 RSI 中的值（在这个特定示例中）与 0FFFFFFFFFFFFFFF0h（–16）进行按位与运算，修改
    RSI，使其保存包含原始地址的 16 字节块的起始地址。^([17](#c11-footnote-19))
- en: '[PRE100]'
  id: totrans-1064
  prefs: []
  type: TYPE_PRE
  zh: '[PRE100]'
- en: 'To avoid matching unintended bytes before the start of the data structure,
    we can create a mask to cover the extra bytes. For example, suppose that we’re
    using the following instruction sequence to rapidly compare 16 bytes at a time:'
  id: totrans-1065
  prefs: []
  type: TYPE_NORMAL
  zh: 为了避免匹配数据结构开始前的非预期字节，我们可以创建一个掩码来覆盖多余的字节。例如，假设我们使用以下指令序列快速比较每次 16 字节：
- en: '[PRE101]'
  id: totrans-1066
  prefs: []
  type: TYPE_PRE
  zh: '[PRE101]'
- en: 'If we use the AND instruction to align the RSI register prior to the execution
    of this code, we might get false results when we compare the first 16 bytes. To
    solve this, we can create a mask that will eliminate any bits from unintended
    comparisons. To create this mask, we start with all 1 bits and zero out any bits
    corresponding to addresses from the beginning of the 16-byte block to the first
    actual data item we’re comparing. This mask can be calculated using the following
    expression:'
  id: totrans-1067
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在执行此代码之前使用 AND 指令对 RSI 寄存器进行对齐，那么在比较前 16 字节时，我们可能会得到错误的结果。为了解决这个问题，我们可以创建一个掩码，消除任何来自非预期比较的位。为了创建这个掩码，我们从所有
    1 位开始，并将与 16 字节块的开始到我们要比较的第一个实际数据项对应的位清零。可以使用以下表达式来计算此掩码：
- en: '[PRE102]'
  id: totrans-1068
  prefs: []
  type: TYPE_PRE
  zh: '[PRE102]'
- en: 'This creates 0 bits in the locations before the data to compare and 1 bit thereafter
    (for the first 16 bytes). We can use this mask to zero out the undesired bit results
    from the `pmovmskb` instruction. The following code snippet demonstrates this
    technique:'
  id: totrans-1069
  prefs: []
  type: TYPE_NORMAL
  zh: 这将在数据比较之前的位置创建 0 位，并在其后创建 1 位（对于前 16 字节）。我们可以使用此掩码将 `pmovmskb` 指令的非预期位结果清零。以下代码片段演示了这一技巧：
- en: '[PRE103]'
  id: totrans-1070
  prefs: []
  type: TYPE_PRE
  zh: '[PRE103]'
- en: Suppose, for example, that the address is already aligned on a 16-byte boundary.
    ANDing that value with 0Fh produces 0\. Shifting –1 to the left zero positions
    produces –1 (all 1 bits). Later, when the code logically ANDs this with the mask
    obtained after the `pcmpeqb` and `pmovmskb` instructions, the result does not
    change. Therefore, the code tests all 16 bytes (as we would want if the original
    address is 16-byte-aligned).
  id: totrans-1071
  prefs: []
  type: TYPE_NORMAL
  zh: 假设例如，地址已经对齐到 16 字节边界。将该值与 0Fh 做按位与操作会得到 0。将 -1 向左移动零位得到 -1（全是 1 位）。稍后，当代码将其与通过
    `pcmpeqb` 和 `pmovmskb` 指令获得的掩码做按位与操作时，结果不会改变。因此，代码测试所有 16 个字节（如果原始地址是 16 字节对齐的话，我们希望如此）。
- en: When the address in RSI has the value 0001b in the LO 4 bits, the actual data
    starts at offset 1 into the 16-byte block. So, we want to ignore the first byte
    when comparing the values in XMM2 against the 16 bytes at [RSI]. In this case,
    the mask is 0FFFFFFFEh, which is all 1s except for a 0 in bit 0\. After the comparison,
    if bit 0 of EAX contains a 1 (meaning the bytes at offset 0 match), the AND operation
    eliminates this bit (replacing it with 0) so it doesn’t affect the comparison.
    Likewise, if the starting offset into the block is 2, 3, . . . , 15, the `shl`
    instruction modifies the bit mask in EBX to eliminate bytes at those offsets from
    consideration in the first compare operation. The result is that it takes only
    11 instructions to do the same work as (up to) 90+ instructions in the original
    (byte-by-byte comparison) example.
  id: totrans-1072
  prefs: []
  type: TYPE_NORMAL
  zh: 当 RSI 中的地址在低 4 位中具有 0001b 的值时，实际数据从 16 字节块的偏移量 1 开始。因此，在将 XMM2 中的值与 [RSI] 处的
    16 字节进行比较时，我们希望忽略第一个字节。在这种情况下，掩码为 0FFFFFFFEh，除了位 0 为 0 外，其余均为 1。比较后，如果 EAX 的第
    0 位包含 1（表示偏移 0 处的字节匹配），则按位与操作会将该位消除（将其替换为 0），以免影响比较。同样，如果块的起始偏移量是 2、3、...、15，`shl`
    指令会修改 EBX 中的位掩码，将这些偏移量处的字节从首次比较操作中排除。结果是，只需 11 条指令即可完成与原始（逐字节比较）示例中最多 90 条指令相同的工作。
- en: 11.15 Aligning Word, Dword, and Qword Object Addresses
  id: totrans-1073
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 11.15 对齐字、双字和四字对象地址
- en: When aligning non-byte-sized objects, you increment the pointer by the size
    of the object (in bytes) until you obtain an address that is 16- (or 32-) byte-aligned.
    However, this works only if the object size is 2, 4, or 8 (because any other value
    will likely miss addresses that are multiples of 16).
  id: totrans-1074
  prefs: []
  type: TYPE_NORMAL
  zh: 在对齐非字节大小的对象时，你可以按对象的大小（以字节为单位）增加指针，直到获得一个 16 字节（或 32 字节）对齐的地址。但是，只有当对象大小为 2、4
    或 8 时，这种方法才有效（因为其他任何值都可能错过那些是 16 的倍数的地址）。
- en: For example, you can process the first several elements of an array of word
    objects (where the first element of the array appears at an even address in memory)
    on a word-by-word basis, incrementing the pointer by 2, until you obtain an address
    that is divisible by 16 (or 32). Note, though, that this scheme works only if
    the array of objects begins at an address that is a multiple of the element size.
    For example, if an array of word values begins at an odd address in memory, you
    will not be able to get an address that is divisible by 16 or 32 with a series
    of additions by 2, and you would not be able to use SSE/AVX instructions to process
    this data without first moving it to another location in memory that is properly
    aligned.
  id: totrans-1075
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，你可以逐字处理一个包含单词对象的数组的前几个元素（其中数组的第一个元素在内存中出现在偶数地址），每次增加指针值 2，直到你得到一个可以被 16（或
    32）整除的地址。需要注意的是，这种方法只有在对象数组的起始地址是元素大小的倍数时才有效。例如，如果一个包含单词值的数组从内存中的奇数地址开始，你无法通过每次加
    2 得到一个可以被 16 或 32 整除的地址，且在没有先将数据移动到另一个正确对齐的内存位置之前，无法使用 SSE/AVX 指令处理该数据。
- en: 11.16 Filling an XMM Register with Several Copies of the Same Value
  id: totrans-1076
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 11.16 用多个相同值填充 XMM 寄存器
- en: 'For many SIMD algorithms, you will want multiple copies of the same value in
    an XMM or a YMM register. You can use the `(v)movddup`, `(v)movshdup`, `(v)pinsd`,
    `(v)pinsq`, and `(v)pshufd` instructions for single-precision and double-precision
    floating-point values. For example, if you have a single-precision floating-point
    value, `r4var`, in memory and you want to replicate it throughout XMM0, you could
    use the following code:'
  id: totrans-1077
  prefs: []
  type: TYPE_NORMAL
  zh: 对于许多 SIMD 算法，你可能需要在 XMM 或 YMM 寄存器中存储相同值的多个副本。你可以使用 `(v)movddup`、`(v)movshdup`、`(v)pinsd`、`(v)pinsq`
    和 `(v)pshufd` 指令来处理单精度和双精度浮点数。例如，如果你有一个单精度浮点值 `r4var` 存储在内存中，并且你想要在整个 XMM0 中复制它，你可以使用以下代码：
- en: '[PRE104]'
  id: totrans-1078
  prefs: []
  type: TYPE_PRE
  zh: '[PRE104]'
- en: 'To copy a pair of double-precision floating-point values from `r8var` into
    XMM0, you could use:'
  id: totrans-1079
  prefs: []
  type: TYPE_NORMAL
  zh: 要将一对双精度浮点数从 `r8var` 复制到 XMM0 中，你可以使用：
- en: '[PRE105]'
  id: totrans-1080
  prefs: []
  type: TYPE_PRE
  zh: '[PRE105]'
- en: Of course, `pshufd` is really intended for double-word integer operations, so
    additional latency (time) may be involved in using `pshufd` immediately after
    `movsd` or `movss`. Although `pshufd` allows a memory operand, that operand must
    be a 16-byte-aligned 128-bit-memory operand, so it’s not useful for directly copying
    a floating-point value through an XMM register.
  id: totrans-1081
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，`pshufd`实际上是为双字整数操作设计的，因此在`movsd`或`movss`之后立即使用`pshufd`可能会涉及额外的延迟（时间）。尽管`pshufd`允许内存操作数，但该操作数必须是16字节对齐的128位内存操作数，因此它不适用于通过XMM寄存器直接复制浮点值。
- en: 'For double-precision floating-point values, you can use `movddup` to duplicate
    a single 64-bit float in the LO bits of an XMM register into the HO bits:'
  id: totrans-1082
  prefs: []
  type: TYPE_NORMAL
  zh: 对于双精度浮点值，你可以使用`movddup`将单个64位浮点数复制到XMM寄存器的低位到高位：
- en: '[PRE106]'
  id: totrans-1083
  prefs: []
  type: TYPE_PRE
  zh: '[PRE106]'
- en: The `movddup` instruction allows unaligned 64-bit memory operands, so it’s probably
    the best choice for duplicating double-precision values.
  id: totrans-1084
  prefs: []
  type: TYPE_NORMAL
  zh: '`movddup`指令允许不对齐的64位内存操作数，因此它可能是复制双精度值的最佳选择。'
- en: 'To copy byte, word, dword, or qword integer values throughout an XMM register,
    the `pshufb`, `pshufw`, `pshufd`, or `pshufq` instructions are a good choice.
    For example, to replicate a single byte throughout XMM0, you could use the following
    sequence:'
  id: totrans-1085
  prefs: []
  type: TYPE_NORMAL
  zh: 要在XMM寄存器中复制字节、字、双字或四字整数值，`pshufb`、`pshufw`、`pshufd`或`pshufq`指令是不错的选择。例如，要在XMM0中复制一个字节，你可以使用以下指令序列：
- en: '[PRE107]'
  id: totrans-1086
  prefs: []
  type: TYPE_PRE
  zh: '[PRE107]'
- en: 'The XMM1 operand is an array of bytes containing masks used to copy data from
    locations in XMM0 onto itself. The value 0 copies byte 0 in XMM0 throughout all
    the other bits in XMM0\. This same code can be used to copy words, dwords, and
    qwords by simply changing the mask value in XMM1\. Or you could use the `pshuflw`
    or `pshufd` instructions to do the job. Here’s another variant that replicates
    a byte throughout XMM0:'
  id: totrans-1087
  prefs: []
  type: TYPE_NORMAL
  zh: XMM1操作数是一个包含掩码的字节数组，用于将数据从XMM0中的位置复制到XMM0自身。值0将XMM0中的字节0复制到XMM0中的所有其他位。通过简单地更改XMM1中的掩码值，你可以使用相同的代码复制字、双字和四字。或者，你也可以使用`pshuflw`或`pshufd`指令来完成此任务。这里是另一个变体，它将一个字节复制到XMM0中的所有位置：
- en: '[PRE108]'
  id: totrans-1088
  prefs: []
  type: TYPE_PRE
  zh: '[PRE108]'
- en: 11.17 Loading Some Common Constants Into XMM and YMM Registers
  id: totrans-1089
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 11.17 将一些常见常量加载到XMM和YMM寄存器
- en: No SSE/AVX instructions let you load an immediate constant into a register.
    However, you can use a couple of idioms (tricks) to load certain common constant
    values into an XMM or a YMM register. This section discusses some of these idioms.
  id: totrans-1090
  prefs: []
  type: TYPE_NORMAL
  zh: 没有SSE/AVX指令可以将立即数常量加载到寄存器中。然而，你可以使用几个惯用法（技巧）将某些常见的常量值加载到XMM或YMM寄存器中。本节讨论了这些惯用法的一些例子。
- en: 'Loading 0 into an SSE/AVX register uses the same idiom that general-purpose
    integer registers employ: exclusive-OR the register with itself. For example,
    to set all the bits in XMM0 to 0s, you would use the following instruction:'
  id: totrans-1091
  prefs: []
  type: TYPE_NORMAL
  zh: 向SSE/AVX寄存器加载0使用的惯用法与通用整数寄存器相同：将寄存器与自身进行异或。例如，要将XMM0中的所有位设置为0，你可以使用以下指令：
- en: '[PRE109]'
  id: totrans-1092
  prefs: []
  type: TYPE_PRE
  zh: '[PRE109]'
- en: 'To set all the bits in an XMM or a YMM register to 1, you can use the `pcmpeqb`
    instruction, as follows:'
  id: totrans-1093
  prefs: []
  type: TYPE_NORMAL
  zh: 要将XMM或YMM寄存器中的所有位设置为1，你可以使用`pcmpeqb`指令，如下所示：
- en: '[PRE110]'
  id: totrans-1094
  prefs: []
  type: TYPE_PRE
  zh: '[PRE110]'
- en: Because any given XMM or YMM register is equal to itself, this instruction stores
    0FFh in all the bytes of XMM0 (or whatever XMM or YMM register you specify).
  id: totrans-1095
  prefs: []
  type: TYPE_NORMAL
  zh: 因为任何给定的XMM或YMM寄存器都等于它自身，所以该指令将0FFh存储到XMM0的所有字节中（或者任何你指定的XMM或YMM寄存器中）。
- en: 'If you want to load the 8-bit value 01h into all 16 bytes of an XMM register,
    you can use the following code (this comes from Intel):'
  id: totrans-1096
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想将8位值01h加载到XMM寄存器的所有16个字节中，你可以使用以下代码（来自Intel）：
- en: '[PRE111]'
  id: totrans-1097
  prefs: []
  type: TYPE_PRE
  zh: '[PRE111]'
- en: You can substitute `psubw` or `psubd` for `psubb` in this example if you want
    to create 16- or 32-bit results (for example, four 32-bit dwords in XMM0, each
    containing the value 00000001h).
  id: totrans-1098
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想创建16位或32位结果（例如，XMM0中的四个32位双字，每个包含值00000001h），你可以在此示例中将`psubb`替换为`psubw`或`psubd`。
- en: 'If you would like the 1 bit in a different bit position (rather than bit 0
    of each byte), you can use the `pslld` instruction after the preceding sequence
    to reposition the bits. For example, if you want to load the XMM0 register with
    8080808080808080h, you could use the following instruction sequence:'
  id: totrans-1099
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你希望1位位于不同的比特位置（而不是每个字节的比特0），你可以在前面的序列之后使用`pslld`指令来重新定位这些位。例如，如果你想将XMM0寄存器加载为8080808080808080h，你可以使用以下指令序列：
- en: '[PRE112]'
  id: totrans-1100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE112]'
- en: Of course, you can supply a different immediate constant to `pslld` to load
    each byte in the register with 02h, 04h, 08h, 10h, 20h, or 40h.
  id: totrans-1101
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，你可以为`pslld`提供不同的立即数常量，以将寄存器中的每个字节加载为02h、04h、08h、10h、20h或40h。
- en: Here’s a neat trick you can use to load 2^(*n*) – 1 (all 1 bits up to the *n*th
    bit in a number) into all the lanes on an SSE/AVX register:^([18](#c11-footnote-20))
  id: totrans-1102
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个巧妙的技巧，你可以用它将 2^(*n*) – 1（直到第 *n* 位的所有 1 位）加载到 SSE/AVX 寄存器的所有通道中：^([18](#c11-footnote-20))
- en: '[PRE113]'
  id: totrans-1103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE113]'
- en: 'You can also load the inverse (NOT(2^(*n*) – 1), all 1 bits in bit position
    *n* through the end of the register) by shifting to the left rather than the right:'
  id: totrans-1104
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以通过左移而非右移来加载反向位（NOT(2^(*n*) – 1)，即从第 *n* 位到寄存器末尾的所有 1 位）：
- en: '[PRE114]'
  id: totrans-1105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE114]'
- en: Of course, you can also load a “constant” into an XMM or a YMM register by putting
    that constant into a memory location (preferably 16- or 32-byte-aligned) and then
    using a `movdqu` or `movdqa` instruction to load that value into a register. Do
    keep in mind, however, that such an operation can be relatively slow if the data
    in memory does not appear in cache. Another possibility, if the constant is small
    enough, is to load the constant into a 32- or 64-bit integer register and use
    `movd` or `movq` to copy that value into an XMM register.
  id: totrans-1106
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，你也可以通过将常量放入内存位置（最好是 16 字节或 32 字节对齐）来加载常量到 XMM 或 YMM 寄存器中，然后使用`movdqu`或`movdqa`指令将该值加载到寄存器中。不过，值得注意的是，如果内存中的数据没有出现在缓存中，这样的操作可能会比较慢。另一种可能性是，如果常量足够小，可以将常量加载到
    32 位或 64 位的整数寄存器中，并使用`movd`或`movq`将该值复制到 XMM 寄存器中。
- en: 11.18 Setting, Clearing, Inverting, and Testing a Single Bit in an SSE Register
  id: totrans-1107
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 11.18 设置、清除、反转和测试 SSE 寄存器中的单个位
- en: Here’s another set of tricks suggested by Raymond Chen ([https://blogs.msdn.microsoft.com/oldnewthing/20141222-00/?p=43333/](https://blogs.msdn.microsoft.com/oldnewthing/20141222-00/?p=43333/))
    to set, clear, or test an individual bit in an XMM register.
  id: totrans-1108
  prefs: []
  type: TYPE_NORMAL
  zh: 这是 Raymond Chen 提出的另一组技巧（[https://blogs.msdn.microsoft.com/oldnewthing/20141222-00/?p=43333/](https://blogs.msdn.microsoft.com/oldnewthing/20141222-00/?p=43333/)），用于设置、清除或测试
    XMM 寄存器中的单个位。
- en: 'To set an individual bit (bit *n*, assuming that *n* is a constant) with all
    other bits cleared, you can use the following macro:'
  id: totrans-1109
  prefs: []
  type: TYPE_NORMAL
  zh: 要设置单个位（假设第 *n* 位是常量），同时清除其他所有位，你可以使用以下宏：
- en: '[PRE115]'
  id: totrans-1110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE115]'
- en: 'Once you can fill an XMM register with a single set bit, you can use that register’s
    value to set, clear, invert, or test that bit in another XMM register. For example,
    to set bit *n* in XMM1, without affecting any of the other bits in XMM1, you could
    use the following code sequence:'
  id: totrans-1111
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你可以用单个位的值填充 XMM 寄存器，你就可以使用该寄存器的值在另一个 XMM 寄存器中设置、清除、反转或测试该位。例如，要在 XMM1 中设置第
    *n* 位，而不影响 XMM1 中的其他位，你可以使用以下代码序列：
- en: '[PRE116]'
  id: totrans-1112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE116]'
- en: 'To clear bit *n* in an XMM register, you use the same sequence but substitute
    the `vpandn` (AND NOT) instruction for the `por` instruction:'
  id: totrans-1113
  prefs: []
  type: TYPE_NORMAL
  zh: 要清除 XMM 寄存器中的第 *n* 位，你可以使用相同的指令序列，但将`vpandn`（与非）指令替换为`por`指令：
- en: '[PRE117]'
  id: totrans-1114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE117]'
- en: 'To invert a bit, simply substitute `pxor` for `por` or `vpandn`:'
  id: totrans-1115
  prefs: []
  type: TYPE_NORMAL
  zh: 要反转一个位，只需将`pxor`替换为`por`或`vpandn`：
- en: '[PRE118]'
  id: totrans-1116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE118]'
- en: 'To test a bit to see if it is set, you have a couple of options. If your CPU
    supports the SSE4.1 instruction set extensions, you can use the `ptest` instruction:'
  id: totrans-1117
  prefs: []
  type: TYPE_NORMAL
  zh: 要测试一个位是否已设置，你有几种选择。如果你的 CPU 支持 SSE4.1 指令集扩展，你可以使用`ptest`指令：
- en: '[PRE119]'
  id: totrans-1118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE119]'
- en: 'If you have an older CPU that doesn’t support the `ptest` instruction, you
    can use `pmovmskb` as follows:'
  id: totrans-1119
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你使用的是不支持`ptest`指令的老款 CPU，你可以如下使用`pmovmskb`：
- en: '[PRE120]'
  id: totrans-1120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE120]'
- en: 11.19 Processing Two Vectors by Using a Single Incremented Index
  id: totrans-1121
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 11.19 使用单一递增索引处理两个向量
- en: Sometimes your code will need to process two blocks of data simultaneously,
    incrementing pointers into both blocks during the execution of the loop.
  id: totrans-1122
  prefs: []
  type: TYPE_NORMAL
  zh: 有时你的代码需要同时处理两块数据，在循环执行过程中，指针会同时递增到两块数据中。
- en: 'One easy way to do this is to use the scaled-indexed addressing mode. If R8
    and R9 contain pointers to the data you want to process, you can walk along both
    blocks of data by using code such as the following:'
  id: totrans-1123
  prefs: []
  type: TYPE_NORMAL
  zh: 一种简单的方法是使用缩放索引寻址模式。如果 R8 和 R9 中包含指向你要处理的数据的指针，你可以通过使用如下代码遍历两个数据块：
- en: '[PRE121]'
  id: totrans-1124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE121]'
- en: 'This code marches along through the two dword arrays comparing values (to search
    for an equal value in the arrays at the same index). This loop uses four registers:
    EAX to compare the two values from the arrays, the two pointers to the arrays
    (R8 and R9), and then the RCX index register to step through the two arrays.'
  id: totrans-1125
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码通过两个 dword 数组进行遍历并比较值（用于搜索数组中相同索引处的相等值）。该循环使用了四个寄存器：EAX 用于比较数组中的两个值，两个数组的指针（R8
    和 R9），然后是 RCX 索引寄存器，用于遍历两个数组。
- en: 'It is possible to eliminate RCX from this loop by incrementing the R8 and R9
    registers in this loop (assuming it’s okay to modify the values in R8 and R9):'
  id: totrans-1126
  prefs: []
  type: TYPE_NORMAL
  zh: 通过在此循环中递增 R8 和 R9 寄存器，可以消除循环中的 RCX（假设修改 R8 和 R9 中的值是可以接受的）：
- en: '[PRE122]'
  id: totrans-1127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE122]'
- en: This scheme requires an extra `add` instruction in the loop. If the execution
    speed of this loop is critical, inserting this extra addition could be a deal
    breaker.
  id: totrans-1128
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方案在循环中需要额外的 `add` 指令。如果该循环的执行速度至关重要，插入这条额外的加法指令可能会成为一个障碍。
- en: 'There is, however, a sneaky trick you can use so that you have to increment
    only a single register on each iteration of the loop:'
  id: totrans-1129
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，你可以使用一个巧妙的技巧，这样你每次迭代时只需要增量一个寄存器：
- en: '[PRE123]'
  id: totrans-1130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE123]'
- en: The comments are there because they explain the trick being used. At the beginning
    of the code, you subtract the value of R8 from R9 and leave the result in R9\.
    In the body of the loop, you compensate for this subtraction by using the `[r9][r8
    * 1]` scaled-indexed addressing mode (whose effective address is the sum of R8
    and R9, thus restoring R9 to its original value, at least on the first iteration
    of the loop). Now, because the `cmp` instruction’s memory address is the sum of
    R8 and R9, adding 4 to R8 also adds 4 to the effective address used by the `cmp`
    instruction. Therefore, on each iteration of the loop, the `mov` and `cmp` instructions
    look at successive elements of their respective arrays, yet the code has to increment
    only a single pointer.
  id: totrans-1131
  prefs: []
  type: TYPE_NORMAL
  zh: 注释在这里是因为它们解释了所使用的技巧。在代码的开始部分，你从 R9 中减去 R8 的值，并将结果保留在 R9 中。在循环体内，你通过使用 `[r9][r8
    * 1]` 缩放索引寻址模式来补偿这个减法（其有效地址是 R8 和 R9 的和，从而恢复 R9 至其原始值，至少在循环的第一次迭代时是如此）。现在，因为 `cmp`
    指令的内存地址是 R8 和 R9 的和，向 R8 加 4 也会将 4 加到 `cmp` 指令使用的有效地址上。因此，在每次循环迭代时，`mov` 和 `cmp`
    指令会查看各自数组的连续元素，但代码只需要增量一个指针。
- en: 'This scheme works especially well when processing SIMD arrays with SSE and
    AVX instructions because the XMM and YMM registers are 16 and 32 bytes each, so
    you can’t use normal scaling factors (1, 2, 4, or 8) to index into an array of
    packed data values. You wind up having to add 16 (or 32) to your pointers when
    stepping through the arrays, thus losing one of the benefits of the scaled-indexed
    addressing mode. For example:'
  id: totrans-1132
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方案在使用 SSE 和 AVX 指令处理 SIMD 数组时特别有效，因为 XMM 和 YMM 寄存器分别是 16 字节和 32 字节，所以你不能使用正常的缩放因子（1、2、4
    或 8）来索引打包数据值的数组。你最终会在遍历数组时必须将 16（或 32）加到指针上，从而失去缩放索引寻址模式的一个优势。例如：
- en: '[PRE124]'
  id: totrans-1133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE124]'
- en: 11.20 Aligning Two Addresses to a Boundary
  id: totrans-1134
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 11.20 对齐两个地址到边界
- en: 'The `vmovapd` and `vaddpd` instructions from the preceding example require
    their memory operands to be 32-byte-aligned or you will get a general protection
    fault (memory access violation). If you have control over the placement of the
    arrays in memory, you can specify an alignment for the arrays. If you have no
    control over the data’s placement in memory, you have two options: working with
    the unaligned data regardless of the performance loss, or moving the data to a
    location where it is properly aligned.'
  id: totrans-1135
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的 `vmovapd` 和 `vaddpd` 指令要求它们的内存操作数必须是 32 字节对齐的，否则会触发一般保护错误（内存访问违规）。如果你能够控制数组在内存中的位置，可以为数组指定对齐方式。如果你无法控制数据在内存中的位置，则有两种选择：无论性能损失如何，处理非对齐数据，或将数据移动到合适对齐的位置。
- en: 'If you must work with unaligned data, you can substitute an unaligned move
    for an aligned move (for example, `vmovupd` for `vmovdqa`) or load the data into
    a YMM register by using an unaligned move and then operate on the data in that
    register by using your desired instruction. For example:'
  id: totrans-1136
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你必须处理非对齐数据，你可以用非对齐的移动代替对齐的移动（例如，`vmovupd` 代替 `vmovdqa`），或者通过使用非对齐的移动将数据加载到
    YMM 寄存器中，然后使用你想要的指令在该寄存器中操作数据。例如：
- en: '[PRE125]'
  id: totrans-1137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE125]'
- en: 'Sadly, the `vaddpd` instruction does not support unaligned access to memory,
    so you must load the value from the second array (pointed at by R9) into another
    register (YMM1) before the packed addition operation. This is the drawback to
    unaligned access: not only are unaligned moves slower, but you also may need to
    use additional registers and instructions to deal with unaligned data.'
  id: totrans-1138
  prefs: []
  type: TYPE_NORMAL
  zh: 可惜的是，`vaddpd` 指令不支持非对齐的内存访问，因此在进行打包加法操作之前，你必须先将第二个数组（由 R9 指向）的值加载到另一个寄存器（YMM1）中。这就是非对齐访问的缺点：不仅非对齐的移动操作更慢，而且你可能还需要使用额外的寄存器和指令来处理非对齐的数据。
- en: Moving the data to a memory location whose alignment you can control is an option
    when you have a data operand you will be using over and over again in the future.
    Moving data is an expensive operation; however, if you have a standard block of
    data you’re going to compare against many other blocks, you can amortize the cost
    of moving that block to a new location over all the operations you need to do.
  id: totrans-1139
  prefs: []
  type: TYPE_NORMAL
  zh: 当你有一个将在未来反复使用的数据操作数时，将数据移动到一个你可以控制其对齐方式的内存位置是一个选择。移动数据是一项昂贵的操作；然而，如果你有一个标准数据块将要与许多其他数据块进行比较，你可以将移动该数据块到新位置的成本分摊到所有需要执行的操作上。
- en: Moving the data is especially useful when one (or both) of the data arrays appears
    at an address that is not an integral multiple of the sub-elements’s size. For
    example, if you have an array of dwords that begin at an odd address, you will
    never be able to align a pointer to that array’s data to a 16-byte boundary without
    moving the data.
  id: totrans-1140
  prefs: []
  type: TYPE_NORMAL
  zh: 移动数据尤其在当数据数组之一（或两者）出现在一个不是子元素大小的整数倍的地址时非常有用。例如，如果你有一个双字数组，它从一个奇数地址开始，你将永远无法将指针对齐到该数组数据的16字节边界，除非你移动数据。
- en: 11.21 Working with Blocks of Data Whose Length Is Not a Multiple of the SSE/AVX
    Register Size
  id: totrans-1141
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 11.21 处理长度不是 SSE/AVX 寄存器大小倍数的数据块
- en: 'Using SIMD instructions to march through a large data set processing 2, 4,
    8, 16, or 32 values at a time often allows a SIMD algorithm (a *vectorized* algorithm)
    to run an order of magnitude faster than the SISD (scalar) algorithm. However,
    two boundary conditions create problems: the start of the data set (when the starting
    address might not be properly aligned) and the end of the data set (when there
    might not be a sufficient number of array elements to completely fill an XMM or
    a YMM register). I’ve addressed the issues with the start of the data set (misaligned
    data) already. This section takes a look at the latter problem.'
  id: totrans-1142
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 SIMD 指令处理一个大数据集，同时处理 2、4、8、16 或 32 个值，通常可以使 SIMD 算法（*向量化*算法）的运行速度比 SISD（标量）算法快一个数量级。然而，有两个边界条件会带来问题：数据集的开始（当起始地址可能没有正确对齐时）和数据集的结束（当没有足够的数组元素来完全填充
    XMM 或 YMM 寄存器时）。我已经处理了数据集开始部分的问题（数据未对齐）。本节将讨论后者的问题。
- en: 'For the most part, when you run out of data at the end of the array (and the
    XMM and YMM registers need more for a packed operation), you can use the same
    technique given earlier for aligning a pointer: load more data than is necessary
    into the register and mask out the unneeded results. For example, if only 8 bytes
    are left to process in a byte array, you can load 16 bytes, do the operation,
    and ignore the results from the last 8 bytes. In the comparison loop examples
    I’ve been using through these past sections, you could do the following:'
  id: totrans-1143
  prefs: []
  type: TYPE_NORMAL
  zh: 在大多数情况下，当数组末尾的数据用尽时（而 XMM 和 YMM 寄存器需要更多数据来执行打包操作），你可以使用前面提到的相同技术来对齐指针：将比必要的更多数据加载到寄存器中，并屏蔽掉不需要的结果。例如，如果在字节数组中只剩下
    8 个字节需要处理，你可以加载 16 个字节，执行操作，并忽略最后 8 个字节的结果。在我在过去几节中使用的比较循环示例中，你可以执行以下操作：
- en: '[PRE126]'
  id: totrans-1144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE126]'
- en: In most cases, accessing data beyond the end of the data structures (either
    the data pointed at by R8, R9, or both in this example) is harmless. However,
    as you saw in “Memory Access and 4K Memory Management Unit Pages” in Chapter 3,
    if that extra data happens to cross a memory management unit page, and that new
    page doesn’t allow read access, the CPU will generate a general protection fault
    (memory access or segmentation fault). Therefore, unless you know that valid data
    follows the array in memory (at least to the extent the instruction references),
    you shouldn’t access that memory area; doing so could crash your software.
  id: totrans-1145
  prefs: []
  type: TYPE_NORMAL
  zh: 在大多数情况下，访问数据结构末尾之外的数据（例如，访问本例中 R8、R9 指向的数据，或两者）是无害的。然而，正如你在第3章“内存访问和4K内存管理单元页面”中看到的那样，如果额外的数据恰好跨越了内存管理单元页面，并且该新页面不允许读取访问，那么
    CPU 会生成一个通用保护故障（内存访问或分段故障）。因此，除非你知道有效数据在内存中紧随数组之后（至少在指令引用的范围内），否则你不应该访问该内存区域；这样做可能会导致你的软件崩溃。
- en: This problem has two solutions. First, you can align memory accesses on an address
    boundary that is the same size as the register (for example, 16-byte alignment
    for XMM registers). Accessing data beyond the end of the data structure with an
    SSE/AVX instruction will not cross a page boundary (because 16-byte accesses aligned
    on 16-byte boundaries will always fall within the same MMU page, and ditto for
    32-byte accesses on 32-byte boundaries).
  id: totrans-1146
  prefs: []
  type: TYPE_NORMAL
  zh: 这个问题有两种解决方案。首先，你可以在与寄存器大小相同的地址边界上对内存访问进行对齐（例如，XMM寄存器的16字节对齐）。使用SSE/AVX指令访问数据结构末尾以外的数据将不会跨越页面边界（因为在16字节边界上对齐的16字节访问总是会落在同一MMU页面内，32字节对齐的32字节访问也一样）。
- en: The second solution is to examine the memory address prior to accessing memory.
    While you cannot access the new page without possibly triggering an access fault,^([19](#c11-footnote-21))
    you can check the address itself and see if accessing 16 (or 32) bytes at that
    address will access data in a new page. If it would, you can take some precautions
    before accessing the data on the next page. For example, rather than continuing
    to process the data in SIMD mode, you could drop down to SISD mode and finish
    processing the data to the end of the array by using standard scalar instructions.
  id: totrans-1147
  prefs: []
  type: TYPE_NORMAL
  zh: 第二种解决方案是在访问内存之前检查内存地址。虽然你不能访问新的页面而不可能触发访问故障^([19](#c11-footnote-21))，你可以检查地址本身，看看在该地址访问16个（或32个）字节是否会访问新页面中的数据。如果是，你可以在访问下一个页面的数据之前采取一些预防措施。例如，与你继续使用SIMD模式处理数据不同，你可以切换到SISD模式，使用标准的标量指令处理数据，直到数组的末尾。
- en: 'To test if a SIMD access will cross an MMU page boundary, supposing that R9
    contains the address at which you’re about to access 16 bytes in memory using
    an SSE instruction, use code like the following:'
  id: totrans-1148
  prefs: []
  type: TYPE_NORMAL
  zh: 要测试SIMD访问是否会跨越MMU页面边界，假设R9包含你即将使用SSE指令访问内存中16个字节的地址，可以使用如下代码：
- en: '[PRE127]'
  id: totrans-1149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE127]'
- en: Each MMU page is 4KB long and is situated on a 4KB address boundary in memory.
    Therefore, the LO 12 bits of an address provide an index into the MMU page associated
    with that address. The preceding code checks whether the address has a page offset
    greater than 0FF0h (4080). If so, then accessing 16 bytes starting at that address
    will cross a page boundary. Check for a value of 0FE0h if you need to check for
    a 32-byte access.
  id: totrans-1150
  prefs: []
  type: TYPE_NORMAL
  zh: 每个MMU页面的大小为4KB，并且位于内存中的4KB地址边界上。因此，地址的低12位提供了该地址所关联的MMU页面的索引。前面的代码检查地址是否有大于0FF0h（4080）的页面偏移量。如果是，则从该地址开始访问16个字节将会跨越页面边界。如果需要检查32字节访问，请检查0FE0h的值。
- en: 11.22 Dynamically Testing for a CPU Feature
  id: totrans-1151
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 11.22 动态测试CPU特性
- en: At the beginning of this chapter, I mentioned that when testing the CPU feature
    set to determine which extensions it supports, the best solution is to dynamically
    select a set of functions based on the presence or absence of certain capabilities.
    To demonstrate dynamically testing for, and using (or avoiding), certain CPU features—specifically,
    testing for the presence of AVX extensions—I’ll modify (and expand) the `print`
    procedure that I’ve been using in examples up to this point.
  id: totrans-1152
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的开始，我提到过，当测试CPU功能集以确定它支持哪些扩展时，最好的解决方案是根据某些功能的存在或缺失动态选择一组函数。为了演示如何动态测试并使用（或避免使用）某些CPU特性——特别是测试AVX扩展的存在——我将修改（并扩展）我至今在示例中使用的`print`过程。
- en: The `print` procedure I’ve been using is very convenient, but it doesn’t preserve
    any SSE or AVX registers that a call to `printf()` could (legally) modify. A generic
    version of `print` should preserve the volatile XMM and YMM registers as well
    as general-purpose registers.
  id: totrans-1153
  prefs: []
  type: TYPE_NORMAL
  zh: 我一直在使用的`print`过程非常方便，但它没有保留任何SSE或AVX寄存器，而`printf()`调用可能（合法地）修改这些寄存器。`print`的通用版本应该保留易失性的XMM和YMM寄存器以及通用寄存器。
- en: The problem is that you cannot write a generic version of `print` that will
    run on all CPUs. If you preserve the XMM registers only, the code will run on
    any x86-64 CPU. However, if the CPU supports the AVX extensions and the program
    uses YMM0 to YMM5, the print routine will preserve only the LO 128 bits of those
    registers, as they are aliased to the corresponding XMM registers. If you save
    the volatile YMM registers, that code will crash on a CPU that doesn’t support
    the AVX extensions. So, the trick is to write code that will dynamically determine
    whether the CPU has the AVX registers and preserve them if they are present, and
    otherwise preserve only the SSE registers.
  id: totrans-1154
  prefs: []
  type: TYPE_NORMAL
  zh: 问题在于，你不能编写一个适用于所有CPU的通用版本的`print`。如果只保留XMM寄存器，代码将在任何x86-64 CPU上运行。然而，如果CPU支持AVX扩展，并且程序使用了YMM0到YMM5寄存器，那么打印例程将只保留这些寄存器的低128位，因为它们与对应的XMM寄存器是别名。如果你保存了易失的YMM寄存器，代码将在不支持AVX扩展的CPU上崩溃。因此，诀窍是编写代码，动态地确定CPU是否具有AVX寄存器，并在它们存在时保留这些寄存器，否则只保留SSE寄存器。
- en: 'The easy way to do this, and probably the most appropriate solution for the
    `print` function, is to simply stick the `cpuid` instruction inside `print` and
    test the results immediately before preserving (and restoring) the registers.
    Here’s a code fragment that demonstrates how this could be done:'
  id: totrans-1155
  prefs: []
  type: TYPE_NORMAL
  zh: 实现这一点的简单方法，可能也是`print`函数最合适的解决方案，就是将`cpuid`指令直接嵌入`print`中，并在保存（和恢复）寄存器之前立即测试结果。以下是一个代码片段，展示了如何实现这一点：
- en: '[PRE128]'
  id: totrans-1156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE128]'
- en: At the end of the `print` function, when it’s time to restore everything, you
    could do another test to determine whether to restore XMM or YMM registers.^([20](#c11-footnote-22))
  id: totrans-1157
  prefs: []
  type: TYPE_NORMAL
  zh: 在`print`函数的末尾，当需要恢复所有内容时，你可以进行另一项测试，以确定是否恢复XMM或YMM寄存器。^([20](#c11-footnote-22))
- en: 'For other functions, when you might not want the expense of `cpuid` (and preserving
    all the registers it stomps on) incurred on every function call, the trick is
    to write *three* functions: one for SSE CPUs, one for AVX CPUs, and a special
    function (that you call only once) that selects which of these two you will call
    in the future. The bit of magic that makes this efficient is *indirection*. You
    won’t directly call any of these functions. Instead, you’ll initialize a pointer
    with the address of the function to call and indirectly call one of these three
    functions by using the pointer. For the current example, we’ll name this pointer
    `print` and initialize it with the address of the third function, `choosePrint`:'
  id: totrans-1158
  prefs: []
  type: TYPE_NORMAL
  zh: 对于其他函数，如果你不希望每次调用函数时都承担`cpuid`（以及保存它影响的所有寄存器）的开销，诀窍是编写*三个*函数：一个用于SSE CPU，一个用于AVX
    CPU，还有一个特殊的函数（你只需调用一次），该函数选择将来调用这两个中的哪一个。使这个方案高效的魔法是*间接调用*。你不会直接调用这些函数。相反，你将初始化一个指针，并将要调用的函数的地址赋给它，然后通过使用该指针间接调用这三个函数之一。对于当前的示例，我们将这个指针命名为`print`，并用第三个函数`choosePrint`的地址初始化它：
- en: '[PRE129]'
  id: totrans-1159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE129]'
- en: 'Here’s the code for `choosePrint`:'
  id: totrans-1160
  prefs: []
  type: TYPE_NORMAL
  zh: 这是`choosePrint`的代码：
- en: '[PRE130]'
  id: totrans-1161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE130]'
- en: The `print_SSE` procedure runs on CPUs without AVX support, and the `print_AVX`
    procedure runs on CPUs with AVX support. The `choosePrint` procedure executes
    the `cpuid` instruction to determine whether the CPU supports the AVX extensions;
    if so, it initializes the `print` pointer with the address of the `print_AVX`
    procedure, and if not, it stores the address of `print_SSE` into the `print` variable.
  id: totrans-1162
  prefs: []
  type: TYPE_NORMAL
  zh: '`print_SSE`过程在没有AVX支持的CPU上运行，而`print_AVX`过程在支持AVX的CPU上运行。`choosePrint`过程执行`cpuid`指令以确定CPU是否支持AVX扩展；如果支持，它将`print`指针初始化为`print_AVX`过程的地址，如果不支持，它将`print_SSE`的地址存储到`print`变量中。'
- en: '`choosePrint` is not an explicit initialization procedure you must call prior
    to calling `print`. The `choosePrint` procedure executes only *once* (assuming
    you call it via the `print` pointer rather than calling it directly). After the
    first execution, the `print` pointer contains the address of the CPU-appropriate
    print function, and `choosePrint` no longer executes.'
  id: totrans-1163
  prefs: []
  type: TYPE_NORMAL
  zh: '`choosePrint`不是一个显式的初始化过程，你不需要在调用`print`之前调用它。`choosePrint`过程只会执行*一次*（假设你是通过`print`指针调用它，而不是直接调用）。第一次执行后，`print`指针将包含适合CPU的打印函数的地址，`choosePrint`将不再执行。'
- en: 'You call the `print` pointer just as you would make any other call to `print`;
    for example:'
  id: totrans-1164
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以像调用任何其他`print`一样调用`print`指针；例如：
- en: '[PRE131]'
  id: totrans-1165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE131]'
- en: After setting up the `print` pointer, `choosePrint` must transfer control to
    the appropriate print procedure (`print_SSE` or `print_AVX`) to do the work the
    user is expecting. Because preserved register values are sitting on the stack,
    and the actual print routines expect only a return address, `choosePrint` will
    first restore all the (general-purpose) registers it saved and then jump to (not
    call) the appropriate print procedure. It does a jump, rather than a call, because
    the return address pointing to the format string is already sitting on the top
    of the stack. On return from the `print_SSE` or `print_AVX` procedure, control
    will return to whomever called `choosePrint` (via the `print` pointer).
  id: totrans-1166
  prefs: []
  type: TYPE_NORMAL
  zh: 在设置好 `print` 指针之后，`choosePrint` 必须将控制权转交给适当的打印过程（`print_SSE` 或 `print_AVX`），以完成用户期望的工作。由于保存的寄存器值位于堆栈上，并且实际的打印例程只期望返回地址，`choosePrint`
    首先会恢复它保存的所有（通用）寄存器，然后跳转到（而不是调用）适当的打印过程。它执行跳转，而不是调用，因为指向格式字符串的返回地址已经位于堆栈顶部。从 `print_SSE`
    或 `print_AVX` 过程返回后，控制将返回给调用 `choosePrint` 的程序（通过 `print` 指针）。
- en: '[Listing 11-5](#listing11-5) shows the complete `print` function, with `print_SSE`
    and `print_AVX`, and a simple main program that calls `print`. I’ve extended `print`
    to accept arguments in R10 and R11 as well as in RDX, R8, and R9 (this function
    reserves RCX to hold the address of the format string following the call to `print`).'
  id: totrans-1167
  prefs: []
  type: TYPE_NORMAL
  zh: '[清单 11-5](#listing11-5) 展示了完整的 `print` 函数，包括 `print_SSE` 和 `print_AVX`，以及一个简单的主程序，它调用了
    `print`。我已经扩展了 `print`，使其能够接受 R10 和 R11 中的参数，以及 RDX、R8 和 R9 中的参数（此函数保留 RCX 用于存放调用
    `print` 后格式字符串的地址）。'
- en: '[PRE132]'
  id: totrans-1168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE132]'
- en: 'Listing 11-5: Dynamically selected print procedure'
  id: totrans-1169
  prefs: []
  type: TYPE_NORMAL
  zh: 清单 11-5：动态选择的打印过程
- en: 'Here’s the build command and output for the program in [Listing 11-5](#listing11-5):'
  id: totrans-1170
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是 [清单 11-5](#listing11-5) 中程序的构建命令和输出：
- en: '[PRE133]'
  id: totrans-1171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE133]'
- en: 11.23 The MASM Include Directive
  id: totrans-1172
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 11.23 MASM 包含指令
- en: As you’ve seen already, including the source code for the `print` procedure
    in every sample listing in this book wastes a lot of space. Including the new
    version from the previous section in every listing would be impractical. In Chapter
    15, I discuss include files, libraries, and other functionality you can use to
    break large projects into manageable pieces. In the meantime, however, it’s worthwhile
    to discuss the MASM `include` directive so this book can eliminate a lot of unnecessary
    code duplication in sample programs.
  id: totrans-1173
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，将 `print` 过程的源代码包含在本书每个示例清单中浪费了大量空间。在每个清单中包含上一节的新版本也是不切实际的。在第 15 章，我将讨论包括文件、库和其他可以帮助你将大型项目分解成可管理部分的功能。不过，在此之前，讨论
    MASM 的 `include` 指令是很有意义的，这样本书就能消除示例程序中的许多不必要的代码重复。
- en: 'The MASM `include` directive uses the following syntax:'
  id: totrans-1174
  prefs: []
  type: TYPE_NORMAL
  zh: MASM 的 `include` 指令使用以下语法：
- en: '[PRE134]'
  id: totrans-1175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE134]'
- en: where `source_filename` is the name of a text file (generally in the same directory
    of the source file containing this `include` directive). MASM will take the source
    file and insert it into the assembly at the point of the `include` directive,
    exactly as though the text in that file had appeared in the source file being
    assembled.
  id: totrans-1176
  prefs: []
  type: TYPE_NORMAL
  zh: 其中 `source_filename` 是文本文件的名称（通常与包含此 `include` 指令的源文件在同一目录中）。MASM 会将源文件插入到汇编文件中，插入位置是
    `include` 指令所在的位置，就像该文件中的文本出现在正在汇编的源文件中一样。
- en: 'For example, I have extracted all the source code associated with the new print
    procedure (the `choosePrint`, `print_AVX`, and `print_SSE` procedures, and the
    `print` qword variable), and I’ve inserted them into the *print.inc* source file.^([21](#c11-footnote-23))
    In listings that follow in this book, I’ll simply place the following directive
    in the code in place of the print function:'
  id: totrans-1177
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，我已经提取了与新打印过程相关的所有源代码（`choosePrint`、`print_AVX` 和 `print_SSE` 过程，以及 `print`
    qword 变量），并将它们插入到 *print.inc* 源文件中。^[21](#c11-footnote-23) 在本书后续的清单中，我将简单地在代码中放置以下指令，代替
    `print` 函数：
- en: '[PRE135]'
  id: totrans-1178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE135]'
- en: I’ve also put the `getTitle` procedure into its own header file (*getTitle.inc*)
    to be able to remove that common code from sample listings.
  id: totrans-1179
  prefs: []
  type: TYPE_NORMAL
  zh: 我还将 `getTitle` 过程放入了一个单独的头文件 (*getTitle.inc*) 中，以便从示例清单中移除这些公共代码。
- en: 11.24 And a Whole Lot More
  id: totrans-1180
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 11.24 还有更多内容
- en: This chapter doesn’t even begin to describe all the various SSE, AVX, AVX2,
    and AVX512 instructions. As already mentioned, most of the SIMD instructions have
    a specific purpose (such as interleaving or deinterleaving bytes associated with
    video or audio information) that aren’t very useful outside their particular problem
    domain. Other instructions (at least, as this book was being written) are sufficiently
    new that they won’t execute on many CPUs in use today. If you’re interested in
    learning about more of the SIMD instructions, check out the information in the
    next section.
  id: totrans-1181
  prefs: []
  type: TYPE_NORMAL
  zh: 本章甚至没有开始描述所有各种SSE、AVX、AVX2和AVX512指令。如前所述，大多数SIMD指令有特定的用途（例如，交织或解交织与视频或音频信息相关的字节），在其特定问题领域之外并不十分有用。其他指令（至少在本书写作时）是相当新的，今天许多使用中的CPU无法执行它们。如果你有兴趣了解更多SIMD指令，请查看下一节中的信息。
- en: 11.25 For More Information
  id: totrans-1182
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 11.25 获取更多信息
- en: For more information about the `cpuid` instruction on AMD CPUs, see the 2010
    AMD document “CPUID Specification” ([https://www.amd.com/system/files/TechDocs/25481.pdf](https://www.amd.com/system/files/TechDocs/25481.pdf)).
    For Intel CPUs, check out “Intel Architecture and Processor Identification with
    CPUID Model and Family Numbers” ([https://software.intel.com/en-us/articles/intel-architecture-and-processor-identification-with-cpuid-model-and-family-numbers/](https://software.intel.com/en-us/articles/intel-architecture-and-processor-identification-with-cpuid-model-and-family-numbers/)).
  id: totrans-1183
  prefs: []
  type: TYPE_NORMAL
  zh: 关于AMD CPU的`cpuid`指令的更多信息，请参见2010年AMD文档《CPUID规格》([https://www.amd.com/system/files/TechDocs/25481.pdf](https://www.amd.com/system/files/TechDocs/25481.pdf))。对于英特尔CPU，请查看《英特尔架构与处理器识别与CPUID模型和家族编号》([https://software.intel.com/en-us/articles/intel-architecture-and-processor-identification-with-cpuid-model-and-family-numbers/](https://software.intel.com/en-us/articles/intel-architecture-and-processor-identification-with-cpuid-model-and-family-numbers/))。
- en: Microsoft’s website (particularly the Visual Studio documentation) has additional
    information on the MASM `segment` directive and x86-64 segments. A search for
    *MASM Segment Directive* on the internet, for example, brought up the page [https://docs.microsoft.com/en-us/cpp/assembler/masm/segment?view=msvc-160/](https://docs.microsoft.com/en-us/cpp/assembler/masm/segment?view=msvc-160/).
  id: totrans-1184
  prefs: []
  type: TYPE_NORMAL
  zh: 微软官网（特别是Visual Studio文档）提供了关于MASM `segment`指令和x86-64段的更多信息。例如，在互联网上搜索*MASM段指令*，就会找到页面[https://docs.microsoft.com/en-us/cpp/assembler/masm/segment?view=msvc-160/](https://docs.microsoft.com/en-us/cpp/assembler/masm/segment?view=msvc-160/)。
- en: 'The complete discussion of all the SIMD instructions can be found in Intel’s
    documentation: *Intel® 64 and IA-32 Architectures Software Developer’s Manual,*
    Volume 2: *Instruction Set Reference*.'
  id: totrans-1185
  prefs: []
  type: TYPE_NORMAL
  zh: 关于所有SIMD指令的完整讨论可以在英特尔的文档中找到：*英特尔® 64和IA-32架构软件开发者手册，* 第二卷：*指令集参考*。
- en: 'You can easily find this documentation online at Intel’s website; for example:'
  id: totrans-1186
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以很容易地在英特尔的官网上找到这些文档；例如：
- en: '*[https://software.intel.com/en-us/articles/intel-sdm/](https://software.intel.com/en-us/articles/intel-sdm/)*'
  id: totrans-1187
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*[https://software.intel.com/en-us/articles/intel-sdm/](https://software.intel.com/en-us/articles/intel-sdm/)*'
- en: '**   *[https://software.intel.com/content/www/us/en/develop/download/intel-64-and-ia-32-architectures-sdm-combined-volumes-1-2a-2b-2c-2d-3a-3b-3c-3d-and-4.html](https://software.intel.com/content/www/us/en/develop/download/intel-64-and-ia-32-architectures-sdm-combined-volumes-1-2a-2b-2c-2d-3a-3b-3c-3d-and-4.html)**'
  id: totrans-1188
  prefs: []
  type: TYPE_NORMAL
  zh: '**   *[https://software.intel.com/content/www/us/en/develop/download/intel-64-and-ia-32-architectures-sdm-combined-volumes-1-2a-2b-2c-2d-3a-3b-3c-3d-and-4.html](https://software.intel.com/content/www/us/en/develop/download/intel-64-and-ia-32-architectures-sdm-combined-volumes-1-2a-2b-2c-2d-3a-3b-3c-3d-and-4.html)**'
- en: '**AMD’s variant can be found at [https://www.amd.com/system/files/TechDocs/40332.pdf](https://www.amd.com/system/files/TechDocs/40332.pdf).'
  id: totrans-1189
  prefs: []
  type: TYPE_NORMAL
  zh: '**AMD的变体可以在[https://www.amd.com/system/files/TechDocs/40332.pdf](https://www.amd.com/system/files/TechDocs/40332.pdf)找到。'
- en: 'Although this chapter has presented many of the SSE/AVX/AVX2 instructions and
    what they do, it has not spent much time describing how you would use these instructions
    in a typical program. You can easily find lots of useful high-performance algorithms
    that use SSE and AVX instructions on the internet. The following URLs provide
    some examples:'
  id: totrans-1190
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管本章介绍了许多SSE/AVX/AVX2指令及其功能，但并未花费太多时间描述如何在典型程序中使用这些指令。你可以很容易地在互联网上找到许多使用SSE和AVX指令的高效算法。以下网址提供了一些示例：
- en: '**Tutorials on SIMD programming**'
  id: totrans-1191
  prefs: []
  type: TYPE_NORMAL
  zh: '**SIMD编程教程**'
- en: SSE Arithmetic, by Stefano Tommesani, [https://tommesani.com/index.php/2010/04/24/sse-arithmetic/](https://tommesani.com/index.php/2010/04/24/sse-arithmetic/)
  id: totrans-1192
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: SSE算术，由Stefano Tommesani编写，[https://tommesani.com/index.php/2010/04/24/sse-arithmetic/](https://tommesani.com/index.php/2010/04/24/sse-arithmetic/)
- en: '*x86/x64 SIMD Instruction List, [https://www.officedaytime.com/simd512e/](https://www.officedaytime.com/simd512e/)*'
  id: totrans-1193
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*x86/x64 SIMD 指令集列表，[https://www.officedaytime.com/simd512e/](https://www.officedaytime.com/simd512e/)*'
- en: '**   *Basics of SIMD Programming, Sony Computer Entertainment, [http://ftp.cvut.cz/kernel/people/geoff/cell/ps3-linux-docs/CellProgrammingTutorial/BasicsOfSIMDProgramming.html](http://ftp.cvut.cz/kernel/people/geoff/cell/ps3-linux-docs/CellProgrammingTutorial/BasicsOfSIMDProgramming.html)**'
  id: totrans-1194
  prefs: []
  type: TYPE_NORMAL
  zh: '**   *SIMD 编程基础，索尼计算机娱乐，[http://ftp.cvut.cz/kernel/people/geoff/cell/ps3-linux-docs/CellProgrammingTutorial/BasicsOfSIMDProgramming.html](http://ftp.cvut.cz/kernel/people/geoff/cell/ps3-linux-docs/CellProgrammingTutorial/BasicsOfSIMDProgramming.html)**'
- en: '****Sorting algorithms**'
  id: totrans-1195
  prefs: []
  type: TYPE_NORMAL
  zh: '****排序算法**'
- en: “A Novel Hybrid Quicksort Algorithm Vectorized Using AVX-512 on Intel Skylake,”
    by Berenger Bramas, [https://arxiv.org/pdf/1704.08579.pdf](https://arxiv.org/pdf/1704.08579.pdf)
  id: totrans-1196
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: “在英特尔 Skylake 上使用 AVX-512 矢量化的混合快速排序算法” 由 Berenger Bramas 撰写，[https://arxiv.org/pdf/1704.08579.pdf](https://arxiv.org/pdf/1704.08579.pdf)
- en: “Register Level Sort Algorithm on Multi-Core SIMD Processors” by Tian Xiaochen
    et al., [http://olab.is.s.u-tokyo.ac.jp/~kamil.rocki/xiaochen_rocki_IA3_SC13.pdf](http://olab.is.s.u-tokyo.ac.jp/~kamil.rocki/xiaochen_rocki_IA3_SC13.pdf)
  id: totrans-1197
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: “多核 SIMD 处理器上的寄存器级排序算法” 由田晓晨等人撰写，[http://olab.is.s.u-tokyo.ac.jp/~kamil.rocki/xiaochen_rocki_IA3_SC13.pdf](http://olab.is.s.u-tokyo.ac.jp/~kamil.rocki/xiaochen_rocki_IA3_SC13.pdf)
- en: “Fast Quicksort Implementation Using AVX Instructions” by Shay Gueron and Vlad
    Krasnov, [http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.1009.7773&rep=rep1&type=pdf](http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.1009.7773&rep=rep1&type=pdf)
  id: totrans-1198
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: “使用 AVX 指令的快速快速排序实现” 由 Shay Gueron 和 Vlad Krasnov 撰写，[http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.1009.7773&rep=rep1&type=pdf](http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.1009.7773&rep=rep1&type=pdf)
- en: '**Search algorithms**'
  id: totrans-1199
  prefs: []
  type: TYPE_NORMAL
  zh: '**搜索算法**'
- en: “SIMD-Friendly Algorithms for Substring Searching” by Wojciech Mula, [http://0x80.pl/articles/simd-strfind.html](http://0x80.pl/articles/simd-strfind.html)
  id: totrans-1200
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: “适用于子字符串搜索的 SIMD 友好算法” 由 Wojciech Mula 撰写，[http://0x80.pl/articles/simd-strfind.html](http://0x80.pl/articles/simd-strfind.html)
- en: “Fast Multiple String Matching Using Streaming SIMD Extensions Technology” by
    Simone Faro and M. Oğuzhan Külekci, [https://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.1041.3831&rep=rep1&type=pdf](https://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.1041.3831&rep=rep1&type=pdf)
  id: totrans-1201
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: “利用流式 SIMD 扩展技术进行快速多字符串匹配” 由 Simone Faro 和 M. Oğuzhan Külekci 撰写，[https://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.1041.3831&rep=rep1&type=pdf](https://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.1041.3831&rep=rep1&type=pdf)
- en: “k-Ary Search on Modern Processors” by Benjamin Schlegel et al., [https://event.cwi.nl/damon2009/DaMoN09-KarySearch.pdf](https://event.cwi.nl/damon2009/DaMoN09-KarySearch.pdf)
  id: totrans-1202
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: “现代处理器上的 k 叉搜索” 由 Benjamin Schlegel 等人撰写，[https://event.cwi.nl/damon2009/DaMoN09-KarySearch.pdf](https://event.cwi.nl/damon2009/DaMoN09-KarySearch.pdf)
- en: 11.26 Test Yourself
  id: totrans-1203
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 11.26 自测
- en: How can you determine whether a particular SSE or AVX feature is available on
    the CPU?
  id: totrans-1204
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你如何判断某个 SSE 或 AVX 特性是否在 CPU 上可用？
- en: Why is it important to check the manufacturer of the CPU?
  id: totrans-1205
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为什么检查 CPU 的制造商很重要？
- en: What EAX setting do you use with `cpuid` to obtain the feature flags?
  id: totrans-1206
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `cpuid` 获取特征标志时，EAX 设置应为多少？
- en: What feature flag bit tells you that the CPU supports SSE4.2 instructions?
  id: totrans-1207
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 哪个特征标志位告诉你 CPU 支持 SSE4.2 指令？
- en: What is the name of the default segment used by the following directives?
  id: totrans-1208
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下指令的默认段名称是什么？
- en: '`.code`'
  id: totrans-1209
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`.code`'
- en: '`.data`'
  id: totrans-1210
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`.data`'
- en: '`.data?`'
  id: totrans-1211
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`.data?`'
- en: '`.const`'
  id: totrans-1212
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`.const`'
- en: What is the default segment alignment?
  id: totrans-1213
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 默认的段对齐方式是什么？
- en: How would you create a data segment aligned on a 64-byte boundary?
  id: totrans-1214
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你如何创建一个对齐到 64 字节边界的数据段？
- en: Which instruction set extensions support the YMM*x* registers?
  id: totrans-1215
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 哪些指令集扩展支持 YMM*x* 寄存器？
- en: What is a lane?
  id: totrans-1216
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 什么是一个 lane？
- en: What is the difference between a scalar instruction and a vector instruction?
  id: totrans-1217
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 标量指令和矢量指令之间有什么区别？
- en: SSE memory operands (XMM) must usually be aligned on what memory boundary?
  id: totrans-1218
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: SSE 内存操作数（XMM）通常需要对齐到哪个内存边界？
- en: AVX memory operands (YMM) must usually be aligned on what memory boundary?
  id: totrans-1219
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: AVX 内存操作数（YMM）通常需要对齐到哪个内存边界？
- en: AVX-512 memory operands (ZMM) must usually be aligned on what memory boundary?
  id: totrans-1220
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: AVX-512 内存操作数（ZMM）通常需要对齐到哪个内存边界？
- en: What instruction would you use to move the data from a 32-bit general-purpose
    integer register into the LO 32 bits of an XMM and a YMM register?
  id: totrans-1221
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你会使用哪条指令将数据从一个 32 位通用整数寄存器移动到 XMM 和 YMM 寄存器的低 32 位？
- en: What instruction would you use to move the data from a 64-bit general-purpose
    integer register into the LO 64 bits of an XMM and a YMM register?
  id: totrans-1222
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你会使用哪条指令将数据从一个 64 位通用整数寄存器移动到 XMM 和 YMM 寄存器的低 64 位？
- en: What three instructions would you use to load 16 bytes from an aligned memory
    location into an XMM register?
  id: totrans-1223
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你会使用哪三条指令从对齐的内存位置加载16字节到XMM寄存器中？
- en: What three instructions would you use to load 16 bytes from an arbitrary memory
    address into an XMM register?
  id: totrans-1224
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你会使用哪三条指令从任意内存地址加载16字节到XMM寄存器中？
- en: If you want to move the HO 64 bits of an XMM register into the HO 64 bits of
    another XMM register without affecting the LO 64 bits of the destination, what
    instruction would you use?
  id: totrans-1225
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果你想将XMM寄存器中的HO 64位移动到另一个XMM寄存器的HO 64位，而不影响目标的LO 64位，应该使用哪个指令？
- en: If you want to duplicate a double-precision value in the LO 64 bits of an XMM
    register in the two qwords (LO and HO) of another XMM register, what instruction
    would you use?
  id: totrans-1226
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果你想将XMM寄存器中的双精度值复制到另一个XMM寄存器的两个四字（LO和HO）中，应该使用哪个指令？
- en: Which instruction would you use to rearrange the bytes in an XMM register?
  id: totrans-1227
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你会使用哪个指令重新排列XMM寄存器中的字节？
- en: Which instruction would you use to rearrange the dword lanes in an XMM register?
  id: totrans-1228
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你会使用哪个指令重新排列XMM寄存器中的双字通道？
- en: Which instructions would you use to extract bytes, words, dwords, or qwords
    from an XMM register and move them into a general-purpose register?
  id: totrans-1229
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你会使用哪些指令从XMM寄存器中提取字节、字、双字或四字，并将它们移动到通用寄存器中？
- en: Which instructions would you use to take a byte, word, dword, or qword in a
    general-purpose register and insert it somewhere in an XMM register?
  id: totrans-1230
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你会使用哪个指令将一个字节、字、双字或四字从通用寄存器插入到XMM寄存器中的某个位置？
- en: What does the `andnpd` instruction do?
  id: totrans-1231
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`andnpd`指令的作用是什么？'
- en: Which instruction would you use to shift the bytes in an XMM register one byte
    position to the left (8 bits)?
  id: totrans-1232
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你会使用哪个指令将XMM寄存器中的字节向左移动一个字节位置（8位）？
- en: Which instruction would you use to shift the bytes in an XMM register one byte
    position to the right (8 bits)?
  id: totrans-1233
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你会使用哪个指令将XMM寄存器中的字节向右移动一个字节位置（8位）？
- en: If you want to shift the two qwords in an XMM register *n* bit positions to
    the left, what instruction would you use?
  id: totrans-1234
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果你想将XMM寄存器中的两个四字向左移动*n*位，应该使用哪个指令？
- en: If you want to shift the two qwords in an XMM register *n* bit positions to
    the right, what instruction would you use?
  id: totrans-1235
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果你想将XMM寄存器中的两个四字向右移动*n*位，应该使用哪个指令？
- en: What happens in a `paddb` instruction when a sum will not fit into 8 bits?
  id: totrans-1236
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当`paddb`指令中的和无法容纳在8位中时，会发生什么？
- en: What is the difference between a vertical addition and a horizontal addition?
  id: totrans-1237
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 垂直加法和水平加法之间的区别是什么？
- en: Where does the `pcmpeqb` instruction put the result of the comparison? How does
    it indicate the result is true?
  id: totrans-1238
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`pcmpeqb`指令将比较结果放在哪个地方？它是如何表示结果为真的？'
- en: There is no `pcmpltq` instruction. Explain how to compare lanes in a pair of
    XMM registers for the less-than condition.
  id: totrans-1239
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 没有`pcmpltq`指令。解释如何比较一对XMM寄存器中的通道，以判断小于条件。
- en: What does the `pmovmskb` instruction do?
  id: totrans-1240
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`pmovmskb`指令的作用是什么？'
- en: How many simultaneous additions are performed by the following?
  id: totrans-1241
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下操作会执行多少次加法？
- en: '`addps`'
  id: totrans-1242
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`addps`'
- en: '`addpd`'
  id: totrans-1243
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`addpd`'
- en: If you have a pointer to data in RAX and want to force that address to be aligned
    on a 16-byte boundary, what instruction would you use?
  id: totrans-1244
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果你有一个指向RAX中的数据的指针，并且希望将该地址强制对齐到16字节边界，应该使用哪个指令？
- en: How can you set all the bits in the XMM0 register to 0?
  id: totrans-1245
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如何将XMM0寄存器中的所有位设置为0？
- en: How can you set all the bits in the XMM1 register to 1?
  id: totrans-1246
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如何将XMM1寄存器中的所有位设置为1？
- en: What directive do you use to insert the content of a source file into the current
    source file during assembly?****
  id: totrans-1247
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在汇编时，使用哪个指令将源文件的内容插入当前源文件？
