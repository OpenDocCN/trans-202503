- en: <hgroup>
  id: totrans-0
  prefs: []
  type: TYPE_NORMAL
  zh: <hgroup>
- en: 13 TREES AND FORESTS
  id: totrans-1
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 13 树和森林
- en: </hgroup>
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: </hgroup>
- en: '![](../images/opener.jpg)'
  id: totrans-3
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/opener.jpg)'
- en: In previous chapters we explored binary trees that have the restriction of only
    two children per node. In this chapter, we’ll consider some new structures that
    go beyond that restriction, such as forests and orchards (when working with a
    single tree isn’t enough). After that, we’ll move on to study B-trees and red-black
    trees for faster searching.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在之前的章节中，我们探讨了二叉树，这些树的每个节点最多只有两个子节点。在本章中，我们将考虑一些不受这一限制的新结构，如森林和果园（当仅处理一棵树不够时）。之后，我们将继续学习
    B 树和红黑树，以便进行更快速的搜索。
- en: Defining Trees and Forests
  id: totrans-5
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 定义树和森林
- en: '*Binary trees* can be empty or consist of a node (the root) and two children,
    which are both binary trees themselves. In particular, *binary search trees* are
    also *ordered* trees, because we define a certain order between children and distinguish
    the left child from the right child.'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: '*二叉树* 可以为空树，也可以由一个节点（根节点）和两个子节点组成，而这两个子节点本身也是二叉树。特别地，*二叉搜索树* 也是*有序*树，因为我们定义了子节点之间的特定顺序，并区分了左子节点和右子节点。'
- en: Let’s expand on those concepts. First, you’ll allow a node to have many children,
    not just two—in other words, nodes can have degrees greater than 2\. You may have
    trees with a specific number of (possibly empty) children per node, as binary
    or ternary trees, but in general, no restrictions are placed on the degree of
    a node. Sometimes trees with an unspecified maximum degree are called *multiary*
    or *multiway*.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们进一步扩展这些概念。首先，你将允许一个节点拥有多个子节点，而不仅仅是两个——换句话说，节点的度数可以大于 2。你可能会遇到每个节点有特定数量（可能为空）的子节点的树，例如二叉树或三叉树，但通常情况下，节点的度数没有限制。有时，度数不确定的树被称为*多叉树*或*多路树*。
- en: Moving beyond single trees, a *forest* is defined as a set of disjointed trees.
    For instance, you could consider the directory for a given hard drive in your
    computer to be a tree, but all the different pieces of storage (like hard drives
    or USB sticks) in your computer would make up a forest.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 超越单棵树，*森林* 被定义为一组不相交的树。例如，你可以将计算机中某个硬盘的目录视为一棵树，但计算机中所有不同的存储设备（如硬盘或 USB 闪存）将构成一个森林。
- en: 'We can even go further and define an *orchard* as a forest with an ordered
    relationship between its trees. In a forest, trees are strewn around in a disordered
    manner, but an orchard has a well-defined layout. Continuing with the computer
    example, if you assign letters to your drives (C:, D:, and so on, Microsoft Windows
    style), your storage actually is an orchard. The forestry-related terms do not
    end here: you can also have *groves*, which are like trees, with the exception
    that their nodes can have links to other nodes, which would turn the data structure
    into a directed (and possibly cyclic) graph.'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: '我们甚至可以进一步定义一个*果园*，它是一个有序关系的森林。在森林中，树木分布杂乱无章，而果园则有着明确的布局。继续用计算机的例子，如果你为你的驱动器分配字母（如
    C:、D: 等，微软 Windows 风格），那么你的存储实际上就是一个果园。与森林相关的术语还不止这些：你还可以拥有*林地*，它们像树一样，但节点之间可以有链接，可能将数据结构转化为一个有向（且可能是循环的）图。'
- en: NOTE
  id: totrans-10
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 注意
- en: '*To simplify the terminology in this chapter, we’ll use the terms forests (when
    no particular order is implied among the trees) and ordered forests (rather than
    orchards), which is the terminology most textbooks use. Also, in this chapter
    we won’t work with groves at all.*'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: '*为了简化本章的术语，我们将使用“森林”这一术语（当树木之间没有特定的顺序时），以及“有序森林”（而非果园），这是大多数教科书使用的术语。此外，本章中我们不会涉及林地。*'
- en: Representing Trees with Arrays
  id: totrans-12
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 使用数组表示树
- en: Do you know how to represent a general tree? How about a forest? Let’s start
    with trees, because by doing so we’ll discover a tip for dealing with forests.
    The first solution you’ll probably think of is having an array to point at each
    child, and in JavaScript with varying-length dynamic arrays, that’s the simplest
    solution. [Figure 13-1](chapter13.xhtml#fig13-1) shows a generic tree where the
    nodes have different degrees.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 你知道如何表示一棵普通的树吗？那森林呢？我们从树开始，因为通过这样做，我们会发现处理森林的一些技巧。你可能会想到的第一个解决方案是使用数组指向每个子节点，在
    JavaScript 中，使用长度可变的动态数组是最简单的解决方案。[图 13-1](chapter13.xhtml#fig13-1) 展示了一个普通的树，其中节点有不同的度数。
- en: '![](../images/Figure13-1.jpg)'
  id: totrans-14
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/Figure13-1.jpg)'
- en: 'Figure 13-1: A generic tree'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 图 13-1：普通树
- en: 'To implement such a tree, add an array of subtrees to each node, resulting
    in something like the following (in terms of JavaScript, this code varies a bit
    from the style of the book and represents trees with a class, which lets you use
    a standard interface like the Document Object Model [DOM] node interface):'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 为了实现这样的树，在每个节点上添加一个子树数组，形成如下所示的结构（从 JavaScript 的角度来看，这段代码与书中的风格略有不同，表示使用类的树结构，这使得你可以使用像文档对象模型
    [DOM] 节点接口这样的标准接口）：
- en: '[PRE0]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: A key field ❶, which also doubles as a flag, decides whether a tree is empty
    ❸, and an array of children ❷ is empty by default. The _throwIfEmpty() method
    ❹ detects incorrect accesses to empty trees (this is used in several methods).
    You also add a getter ❺ and a setter ❻ for the tree’s key. Then add some getters
    to check whether a node is a leaf with no children ❼ and, if not, to get its children
    ❽, in particular, accessing its first ❾ and last ❿ child, mimicking well-known
    DOM node-related methods.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 一个关键字段 ❶，也作为标志，决定树是否为空 ❸，默认情况下，子节点数组 ❷ 为空。`_throwIfEmpty()` 方法 ❹ 检测到对空树的不正确访问（这在多个方法中使用）。你还添加了一个
    getter ❺ 和一个 setter ❻ 来获取和设置树的键。然后添加一些 getter 来检查节点是否是没有子节点的叶子节点 ❼，如果不是，则获取其子节点
    ❽，特别是访问它的第一个 ❾ 和最后一个 ❿ 子节点，模仿常见的 DOM 节点相关方法。
- en: NOTE
  id: totrans-19
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 注意
- en: '*For more details on the DOM node interface, visit* [https://developer.cdn.mozilla.net/en-US/docs/Web/API/Node](https://developer.cdn.mozilla.net/en-US/docs/Web/API/Node)*.*'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: '*欲了解更多关于 DOM 节点接口的详情，请访问* [https://developer.cdn.mozilla.net/en-US/docs/Web/API/Node](https://developer.cdn.mozilla.net/en-US/docs/Web/API/Node)*.*'
- en: You could consider adding more methods to the tree, but you would need some
    extra fields to reproduce certain methods, such as parentNode or previousSibling.
    We’ll see some ways to achieve those things later in the chapter. Now you can
    represent general trees and access their nodes, so next take a look at how to
    add or remove data to update trees.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以考虑为树添加更多的方法，但你需要一些额外的字段来重现某些方法，如 `parentNode` 或 `previousSibling`。我们将在本章稍后看到实现这些功能的一些方法。现在你可以表示一般的树并访问它们的节点，接下来看看如何添加或移除数据来更新树。
- en: Adding Nodes to a Tree
  id: totrans-22
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 向树中添加节点
- en: 'First, add a new child in a specific place among its siblings:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，在同级节点中的特定位置添加一个新子节点：
- en: '[PRE1]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: To add a new key, all you need to specify is its position among its siblings;
    by default, you’ll add it at the end ❶. If the tree is empty (no root), you throw
    an error ❷, and you also do that if the index lies beyond the limits of the current
    array of children ❸. If everything’s okay, just create a new tree ❹, place the
    new key as its root, and place the tree in the correct position among its siblings
    ❺, ending by allowing chaining, as in other previous cases ❻.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 要添加一个新的键，只需指定它在同级节点中的位置；默认情况下，你将把它添加到末尾 ❶。如果树为空（没有根节点），则抛出错误 ❷，如果索引超出当前子节点数组的范围，也会抛出错误
    ❸。如果一切正常，创建一个新的树 ❹，将新键作为其根节点，并将树放置在正确的位置 ❺，最后启用链式操作，如其他情况 ❻。
- en: 'Appending a node is easy:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 附加节点很简单：
- en: '[PRE2]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: You just depend on the default parameters for addChild(), which also test whether
    the tree has a root. No special code needed here.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 你只需依赖 `addChild()` 的默认参数，这也会测试树是否有根。这里不需要特殊的代码。
- en: Removing Nodes from a Tree
  id: totrans-29
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 从树中移除节点
- en: 'To remove a given child, you need only a test and some array manipulation:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 要移除给定的子节点，只需要测试并进行一些数组操作：
- en: '[PRE3]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: After verifying that the tree has a root and isn’t empty ❶, check whether the
    index of the child to remove is valid or not ❷. If it is valid, do some array
    manipulation to remove the child from among its siblings ❸. End by enabling chaining
    as when adding a node ❹.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 在验证树有根且不为空 ❶ 后，检查要删除的子节点的索引是否有效 ❷。如果有效，对数组进行操作，将该子节点从同级节点中移除 ❸。最后，如同添加节点时一样，启用链式操作
    ❹。
- en: Representing Trees with Binary Trees
  id: totrans-33
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 使用二叉树表示树
- en: 'Representing trees with arrays works well, but another way of dealing with
    trees uses a simpler kind of tree, a binary tree. The trick is to use the left
    and right pointers in a different way from before: the left one will point to
    the first child, and the right one will point to the next sibling.'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 使用数组表示树是有效的，但处理树的另一种方法是使用更简单的树形结构——二叉树。诀窍在于不同于以前的使用方式，左指针指向第一个子节点，右指针指向下一个兄弟节点。
- en: NOTE
  id: totrans-35
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 注意
- en: '*If you are wondering whether this technique is purely academic or if you’ll
    ever use it in reality, we’ll be doing so in [Chapter 15](chapter15.xhtml) when
    studying binomial heaps and their variants.*'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: '*如果你在想这种技术是否纯粹是学术性的，或者是否能在实际中使用，我们将在[第15章](chapter15.xhtml)学习二项堆及其变种时使用它。*'
- en: Revisit the tree shown in [Figure 13-1](chapter13.xhtml#fig13-1). An alternative
    representation would have each node’s left link pointing to the node’s first child,
    and the right links would create a list of the node’s siblings. (As with all the
    other diagrams in this book, left and right null pointers are omitted for clarity.)
    If you rearrange and rotate the image 45 degrees, so the left pointers actually
    point down, the scheme becomes clearer, as shown in [Figure 13-2](chapter13.xhtml#fig13-2).
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 回顾一下[图13-1](chapter13.xhtml#fig13-1)中展示的树。另一种表示方法是每个节点的左链接指向该节点的第一个子节点，右链接则创建一个节点的兄弟列表。（与本书中的其他所有图示一样，为了清晰起见，左和右的空指针被省略。）如果你重新排列并旋转图像45度，使得左指针实际指向下方，这个方案就会更清晰，如[图13-2](chapter13.xhtml#fig13-2)所示。
- en: '![](../images/Figure13-2.jpg)'
  id: totrans-38
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/Figure13-2.jpg)'
- en: 'Figure 13-2: A tree represented with the “left-child, right-sibling” style'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 图13-2：使用“左孩子，右兄弟”样式表示的树
- en: Many structures use this *left-child, right-sibling* convention, but it’s better
    to rename the left pointer to *down* for clarity; *right* will still point to
    siblings. As for algorithms (adding or removing values and so on), you won’t need
    to do anything different from what you learned about binary trees in [Chapter
    12](chapter12.xhtml).
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 许多结构使用这种*左孩子，右兄弟*约定，但为了更清晰，最好将左指针重命名为*下*，*右*指针仍然指向兄弟节点。至于算法（添加或删除值等），你不需要做任何不同于在[第12章](chapter12.xhtml)中学到的二叉树内容的事情。
- en: '#### Representing Forests'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: '#### 表示森林'
- en: You can extend these methods for representing trees to represent forests. If
    you use arrays for pointers, you can simply have an array of roots, each pointing
    to a specific tree (we’ll see this concept again in [Chapters 14](chapter14.xhtml)
    and [15](chapter15.xhtml) when discussing binomial and Fibonacci heaps, so consider
    [Figure 13-3](chapter13.xhtml#fig13-3) to be a minor spoiler).
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以将这些表示树的方法扩展到表示森林。如果使用数组作为指针，你可以简单地有一个根节点数组，每个元素指向一个特定的树（我们将在讨论二项堆和斐波那契堆时再次看到这个概念，见[第14章](chapter14.xhtml)和[第15章](chapter15.xhtml)，所以可以把[图13-3](chapter13.xhtml#fig13-3)看作是一个小剧透）。
- en: '![](../images/Figure13-3.jpg)'
  id: totrans-43
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/Figure13-3.jpg)'
- en: 'Figure 13-3: A forest, represented with an array of roots'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 图13-3：一个森林，表示为根节点数组
- en: 'At the top of the forest is an array with a pointer to the root of each individual
    tree. If you prefer the binary tree representation, you can do two different things:
    consider that all roots are siblings or add a fictitious “super-root” that has
    all the forest trees as subtrees. The first is the usual representation, which
    would give something like the forest in [Figure 13-4](chapter13.xhtml#fig13-4)
    (this is the same forest as shown in [Figure 13-3](chapter13.xhtml#fig13-3)).'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 在森林的顶部是一个数组，其中包含指向每棵单独树根节点的指针。如果你更喜欢二叉树的表示方式，你可以做两件事：要么考虑所有根节点都是兄弟节点，要么添加一个虚拟的“超级根”，它包含所有森林中的树作为子树。第一种是常见的表示方式，类似于[图13-4](chapter13.xhtml#fig13-4)所示的森林（这与[图13-3](chapter13.xhtml#fig13-3)中展示的森林相同）。
- en: '![](../images/Figure13-4.jpg)'
  id: totrans-46
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/Figure13-4.jpg)'
- en: 'Figure 13-4: An alternative representation of the same forest; the roots are
    linked to the right.'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 图13-4：同一森林的另一种表示方法；根节点通过右指针连接。
- en: To access this forest, you need a pointer to the leftmost root; from there,
    you can access all the trees. You can go even further by making the list of siblings
    circular and doubly linked; we’ll explore this later and see why those enhancements
    (and complications) are actually needed.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 要访问这个森林，你需要一个指向最左根节点的指针；从那里，你可以访问所有的树。你甚至可以通过使兄弟列表变成循环和双向链表来进一步扩展；我们稍后会探讨这个，并且看看为什么这些增强（以及复杂性）实际上是必要的。
- en: Traversing Trees
  id: totrans-49
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 遍历树
- en: 'When studying binary search trees in [Chapter 12](chapter12.xhtml), we looked
    at three different ways of traversing trees by “visiting” all the nodes according
    to various schemes. With general trees, you don’t have all those methods, but
    we’ll add new ones. But first review the traversals we’ve done before and adapt
    two of them to the general tree:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第12章](chapter12.xhtml)学习二叉查找树时，我们讨论了三种不同的遍历树的方式，通过“访问”所有节点，按照不同的方案进行遍历。对于一般树，你没有那么多的方法，但我们会新增一些。但首先，复习一下我们之前做过的遍历，并将其中的两种方法适配到一般树上：
- en: '**Preorder **For binary trees, *preorder* means first visiting the root, then
    traversing its left subtree, and finally traversing its right subtree. You can
    adapt this for general trees by first visiting the root and then traversing each
    of its subtrees in order.'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: '**前序** 对于二叉树，*前序*意味着首先访问根节点，然后遍历其左子树，最后遍历其右子树。你可以将这个方法适配到一般树上，首先访问根节点，然后按顺序遍历每一个子树。'
- en: '**Postorder **The *postorder* method for binary trees is similar to preorder,
    but it first visits the root’s left subtree, then the right, and finally the root
    itself. The adaptation requires first traversing all the root’s children in order
    and finally visiting the root itself.'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: '**后序** *后序*方法对于二叉树来说类似于前序方法，但它首先访问根节点的左子树，然后是右子树，最后访问根节点本身。其变体要求先遍历所有根节点的子节点，并按顺序访问，最后访问根节点。'
- en: '**Inorder **The *inorder* method doesn’t really have an equivalent. For binary
    trees, it means first traversing the left subtree, then visiting the root, and
    finally traversing the right subtree. However, for general trees, you don’t have
    any reasonable alternative, so you can forgo this traversal (although for B-trees,
    discussed later in this chapter, you do have a possible inorder version).'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: '**中序** *中序*方法实际上没有完全对应的版本。对于二叉树，它意味着首先遍历左子树，然后访问根节点，最后遍历右子树。然而，对于一般树，你没有合适的替代方法，因此可以跳过这种遍历（尽管对于本章后面讨论的B树，你确实有可能实现一个中序版本）。'
- en: 'Coding preorder and postorder traversals is fairly straightforward, and the
    versions used for binary trees require only minor changes (we’ll consider their
    implementations in the questions at the end of this chapter). Two new methods,
    however, are worth studying and also appear in other types of algorithms, such
    as game playing or function optimization: *depth-first* and *breadth-first* traversals.'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 编写前序和后序遍历的代码是相当直接的，二叉树的版本只需要做一些小的修改（我们将在本章末的习题中讨论它们的实现）。然而，有两个新方法值得学习，并且也出现在其他类型的算法中，例如游戏或函数优化：*深度优先*和*广度优先*遍历。
- en: Depth-First Traversal
  id: totrans-55
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 深度优先遍历
- en: The possibly most logical traversal to implement requires visiting the root
    first and then traversing all its children using the same algorithm. In effect,
    it’s equivalent to going as deeply as possible into a branch before moving on
    to another branch—thus, the name *depth first*. [Figure 13-5](chapter13.xhtml#fig13-5)
    shows an example of such a traversal; the numbers in the nodes reflect the order
    in which the visits occur.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 实现可能最合逻辑的遍历方法需要首先访问根节点，然后使用相同的算法遍历所有子节点。实际上，这相当于在移动到另一分支之前尽可能深入地进入一个分支——因此，称为*深度优先*。
    [图13-5](chapter13.xhtml#fig13-5)展示了这种遍历的一个示例；节点中的数字反映了访问发生的顺序。
- en: '![](../images/Figure13-5.jpg)'
  id: totrans-57
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/Figure13-5.jpg)'
- en: 'Figure 13-5: A depth-first traversal of a tree'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 图13-5：树的深度优先遍历
- en: 'This kind of algorithm is a classic one, generally used for searches or games.
    For instance, if you’re trying to get out of a maze, you’d follow some path until
    you either exit (and finish) or become blocked, in which case you go back to try
    another option. (See “Finding a Path in a Maze” on [page 69](chapter5.xhtml#pg_69).)
    Similarly, in games, you consider some sequence of movements as far as you can
    (because of time limitations), and if you haven’t found a winning line, you go
    back to try another one. The logic looks like this:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 这种算法是一种经典算法，通常用于搜索或游戏。例如，如果你试图走出迷宫，你会沿着某条路径前进，直到你要么退出（并完成任务），要么遇到障碍，在这种情况下你会回头尝试另一条路径。（请参阅[第69页](chapter5.xhtml#pg_69)的“迷宫路径查找”。）同样，在游戏中，你会尽可能地考虑某一系列的移动（因为时间有限），如果你还没有找到获胜的路线，就会回头尝试另一条。其逻辑如下：
- en: '[PRE4]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The algorithm is similar to some that you wrote for binary trees in [Chapter
    12](chapter12.xhtml). First, define a default visit() function ❶ that just lists
    the node’s key, and if the tree isn’t empty ❷, visit its root ❸. Then proceed
    to visit all of its children recursively, depth first ❹.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 这个算法与在[第12章](chapter12.xhtml)中为二叉树编写的某些算法类似。首先，定义一个默认的visit()函数❶，它仅列出节点的键，然后如果树不为空❷，访问其根节点❸。接下来，递归地按照深度优先的方式访问所有子节点❹。
- en: Breadth-First Traversal
  id: totrans-62
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 广度优先遍历
- en: The alternative way to traverse trees is breadth first, which is a traversal
    style that you haven’t yet met. (This type of traversal is also called *level
    order* for reasons that will become apparent.) The idea is that you start at the
    root; then, you visit all of its children in the next level. Then (and only then),
    you visit the children’s children at the second level of the tree, and so on.
    You never visit a node until you’ve already visited all the nodes closer to the
    root, going down level by level, one by one. [Figure 13-6](chapter13.xhtml#fig13-6)
    shows such a traversal for a generic tree. Again, the numbers reflect the order
    in which the nodes are visited, and you can verify that each level is fully visited
    before starting the next level.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 遍历树的另一种方式是广度优先，这是一种你还未遇到的遍历方式。（这种遍历方式也被称为*层次顺序*，原因稍后会显现出来。）其基本思想是从根节点开始；然后，访问下一层的所有子节点。然后（仅在此时），访问第二层的子节点，以此类推。你永远不会访问一个节点，直到你已经访问了所有更靠近根节点的节点，一层一层地向下访问。[图13-6](chapter13.xhtml#fig13-6)显示了这种遍历方式。再次提醒，数字表示节点访问的顺序，你可以验证每一层在开始下一层之前都已被完全访问。
- en: '![](../images/Figure13-6.jpg)'
  id: totrans-64
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/Figure13-6.jpg)'
- en: 'Figure 13-6: A breadth-first traversal of a tree'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 图13-6：树的广度优先遍历
- en: 'Implementing this strategy requires using a queue, as discussed in [Chapter
    10](chapter10.xhtml). As you start visiting nodes “horizontally,” you need to
    remember to visit their children later, so a queue with a first in, first out
    (FIFO) strategy works. You can code this as an independent function just for variety:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 实现这一策略需要使用队列，如[第10章](chapter10.xhtml)中所讨论的那样。当你开始“水平”地访问节点时，你需要记得稍后访问它们的子节点，因此使用先进先出（FIFO）策略的队列很有效。你可以将其作为一个独立的函数进行编码以增加多样性：
- en: '[PRE5]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'As with other traversals, a default visit() function ❶ logs the node’s key.
    If the tree to be traversed isn’t empty ❷ (in which case you wouldn’t have to
    do anything), initialize a queue ❸ by pushing the tree’s root ❹. The rest of the
    algorithm is straightforward: while the queue hasn’t been emptied ❺, you pop its
    top ❻, visit that node ❼, and push all of its children into the queue for future
    visits ❽.'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 与其他遍历方法一样，默认的visit()函数❶会记录节点的键。如果要遍历的树不是空的❷（在这种情况下你不需要做任何事情），则初始化一个队列❸并将树的根节点压入队列❹。其余的算法比较直接：当队列未被清空❺时，你弹出队列的顶部❻，访问该节点❼，并将它的所有子节点压入队列以便稍后访问❽。
- en: 'This algorithm isn’t recursive at all, which isn’t common for trees and other
    recursively defined structures. There’s an interesting sort of symmetry here:
    visiting a tree breadth first without recursion requires using a queue, and visiting
    it depth first without recursion needs a stack; see question 13.3.'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 这个算法根本不是递归的，这对于树和其他递归定义的结构来说并不常见。这里有一种有趣的对称性：不使用递归进行广度优先遍历树需要使用队列，而不使用递归进行深度优先遍历则需要使用栈；见第13.3题。
- en: B-trees
  id: totrans-70
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: B树
- en: B-trees have a self-adjusting tree structure with assured logarithmic performance
    for additions, removals, and searches, so in that sense, you could consider them
    an extension of height-balanced binary search trees—and a better-performing one
    at that. A key characteristic of these trees is that nodes can have more than
    two children, which allows for wider, shorter trees with faster searches.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: B树具有自我调整的树结构，确保在添加、删除和查找时具有对数时间性能，因此从这个意义上讲，你可以将它们视为高度平衡的二叉搜索树的扩展——而且是性能更优的扩展。这些树的一个关键特征是节点可以拥有多个子节点，这使得树变得更宽、更矮，从而实现更快速的搜索。
- en: NOTE
  id: totrans-72
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 注意
- en: '*Nobody really knows what the B in B-tree stands for. This structure was defined
    in 1972 by Rudolf Bayer and Edward McCreight, but no explanation was given for
    the term, so you can choose your own interpretation: some proposals have been
    “balanced,” “broad,” “bushy,” and, obviously, “Bayer.”*'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: '*没有人真正知道B树中B代表什么。这个结构是由Rudolf Bayer和Edward McCreight于1972年定义的，但并没有给出这个术语的解释，所以你可以选择自己的解释：一些提议包括“平衡”，“广泛”，“灌木状”，当然，还有“Bayer”。*'
- en: 'The definition (and implementation) for a B-tree varies among different sources
    and authors, so let’s make clear what is used here. A B-tree of order *m* satisfies
    the following properties:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: B树的定义（以及实现）在不同的来源和作者之间有所不同，因此我们需要明确这里所使用的定义。一个阶数为*m*的B树满足以下属性：
- en: Every node has *p* < *m* keys, in ascending order, and *p* + 1 children.
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每个节点有*p* < *m* 个按升序排列的键，和*p* + 1 个子节点。
- en: Every node but the root must have at least *m*/2 (rounded up) children, or in
    other words, all nodes (except the root) should be at least half full.
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 除了根节点外，每个节点必须至少有*m*/2（向上取整）个子节点，换句话说，所有节点（除了根节点）应该至少是半满的。
- en: The root should have at least one key.
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 根节点应至少包含一个键。
- en: All leaves must be at the same level.
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 所有叶子节点必须位于同一层级。
- en: 'The B-tree is structured in a fashion similar to a binary search tree: given
    any key in a node, all the children to its left will be smaller than the key,
    and all the children to its right will be greater than it. For instance, you could
    have a node such as the one shown in [Figure 13-7](chapter13.xhtml#fig13-7).'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: B树的结构类似于二叉搜索树：给定一个节点中的键，该节点左侧的所有子节点的值都小于该键，右侧的所有子节点的值都大于该键。例如，你可以有一个如下所示的节点，参见[图13-7](chapter13.xhtml#fig13-7)。
- en: '![](../images/Figure13-7.jpg)'
  id: totrans-80
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/Figure13-7.jpg)'
- en: 'Figure 13-7: A B-tree node, showing where keys are to be found'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 图13-7：一个B树节点，展示了键的位置
- en: In this case, the node has four keys, so five children. The first child, to
    the left of the 34 key, has keys less than 34; the child between 34 and 40 has
    keys between those two values, and so on, until the last child, the one to the
    right of the 60 key, has keys greater than that value. (These facts are what we’ll
    use to search in a B-tree; you’ll see the algorithm soon.) This structure is similar
    to binary search trees, except that now instead of a maximum of two children per
    node, we allow a greater number—and for actual implementations (such as an index
    for actual files in disk), much larger values are preferred in order to have a
    shorter height and thus faster access.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，节点有四个键，因此有五个子节点。第一个子节点位于34键的左侧，包含比34小的键；位于34和40之间的子节点包含介于这两个值之间的键，以此类推，直到最后一个子节点，它位于60键的右侧，包含比该值大的键。（这些事实就是我们用来在B树中进行搜索的依据；你很快会看到算法。）这种结构类似于二叉搜索树，不同之处在于每个节点现在允许更多的子节点，而不是最多两个子节点——对于实际的实现（如磁盘中文件的索引），通常更大的值更受欢迎，以便缩短树的高度，从而加快访问速度。
- en: Defining B-trees
  id: totrans-83
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 定义B树
- en: 'Let’s start in similar fashion as with binary search trees by defining the
    basic functions we’ll need:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们像在二叉搜索树中一样，首先定义我们需要的基本函数：
- en: '[PRE6]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'You can define B-trees of any order, and we’ll use a variable ORDER ❶ to store
    the one you want. The first time you create a B-tree ❷, you’ll store the desired
    order (or 3, by default), so all future B-trees will have that order. (This decision
    begs the question: What if you want to have B-trees of *different* orders? See
    question 13.9.) The newNode() function ❸ creates a new node with a single null
    key by default, flanked by two null pointers; of course, this node will be “too
    empty,” unless ORDER is small. Note, however, that if you provide an array of
    keys ❹, some JavaScript trickery is used to generate (if needed) a corresponding
    array of null pointers, with one key more; can you see how this works?'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以定义任意阶的B树，我们将使用一个变量ORDER ❶来存储你想要的阶数。当你第一次创建B树 ❷时，你将存储所需的阶数（默认情况下是3），这样所有未来的B树都会具有这个阶数。（这个决定引出了一个问题：如果你想要不同阶数的B树怎么办？参见问题13.9。）newNode()函数
    ❸默认情况下会创建一个包含单一空键的新节点，并且两侧有空指针；当然，这个节点会显得“过于空”，除非ORDER值很小。然而，值得注意的是，如果你提供一个键的数组
    ❹，一些JavaScript的技巧将被用来生成（如果需要）一个对应的空指针数组，数组长度比键数组多一个；你能理解这怎么工作吗？
- en: Finally, a couple of auxiliary functions will come in handy. At times, you’ll
    need to test whether a node is oversized (or would be, if d keys were added to
    it), with more keys than allowed ❺, and _tooBig() will check that. Similarly,
    _tooSmall() determines whether the node is undersized (or would be, if d keys
    were removed from it) and doesn’t have enough keys ❻. (Be careful not to apply
    _tooSmall() to the root—the only node that is allowed to be smaller.) You’ll use
    those two methods when adding or removing keys.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，一些辅助函数会派上用场。有时，你需要测试一个节点是否超载（或者如果添加d个键后会超载），即它的键数超过了允许的数量 ❺，_tooBig()函数将检查这一点。类似地，_tooSmall()函数判断节点是否过小（或者如果移除d个键后会过小），即它没有足够的键
    ❻。（注意不要对根节点使用_tooSmall()——根节点是唯一允许小于规定键数的节点。）你将在添加或删除键时使用这两个方法。
- en: Finding a Key in a B-tree
  id: totrans-88
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 在B树中查找键
- en: 'Let’s start with the most basic algorithm: searching for a key. In a sense,
    the algorithm is similar to searching a binary search tree; you look for the key,
    and if you don’t find it in a node, you determine where to continue searching.
    Consider some examples. Assume you have the following B-tree of order 3; null
    links are represented with blank boxes, as shown in [Figure 13-8](chapter13.xhtml#fig13-8).'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从最基本的算法开始：查找一个键。从某种意义上讲，算法类似于查找二叉搜索树中的键；你查找该键，如果在某个节点中没有找到，你会判断接下来应该在哪里继续查找。考虑一些例子。假设你有一个阶数为3的B树；空链接用空白框表示，如[图13-8](chapter13.xhtml#fig13-8)所示。
- en: '![](../images/Figure13-8.jpg)'
  id: totrans-90
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/Figure13-8.jpg)'
- en: 'Figure 13-8: A B-tree of order 3'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 图 13-8：阶数为 3 的 B 树
- en: 'If you were looking for 22, that would be easy: it’s in the root, so there’s
    nothing to do. You can make it more complex and look for 56, as shown in [Figure
    13-9](chapter13.xhtml#fig13-9).'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在寻找 22，那就简单多了：它就在根节点中，因此无需做任何操作。你可以让它变得更复杂，像寻找 56 一样，参考[图 13-9](chapter13.xhtml#fig13-9)。
- en: '![](../images/Figure13-9.jpg)'
  id: totrans-93
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/Figure13-9.jpg)'
- en: 'Figure 13-9: The search process for key 56'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 图 13-9：键 56 的搜索过程
- en: Start at the root, and since 56 > 22, follow the root’s last pointer to a new
    node. There, you find that 56 should be between 34 and 60, so follow the middle
    pointer to yet another node. In that one, you finally find 56, so the search is
    successful.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 从根节点开始，由于 56 > 22，沿着根节点的最后一个指针到达一个新节点。在那里，你发现 56 应该位于 34 和 60 之间，因此沿着中间指针到达另一个节点。在这个节点中，你最终找到了
    56，因此搜索成功。
- en: What about searching for a key that isn’t in the tree? If you had been looking
    for 38, everything would be the same as for 56, but upon not finding 38 in the
    node with 40 and 56, you would have continued down the first pointer of the node
    (since 38 < 40), but finding it null, the search would have been unsuccessful.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 如果要查找的键不在树中呢？如果你在寻找 38，整个过程和寻找 56 是一样的，但是在没有找到包含 40 和 56 的节点中的 38 后，你会继续沿着节点的第一个指针（因为
    38 < 40），但发现它为空，搜索就会失败。
- en: 'Now on to the algorithms. Every time you get to a node, you need to see whether
    the key you want is there; if not, the algorithm tells you what pointer to follow
    to the next level; there is an auxiliary function for this:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 现在进入算法部分。每次到达一个节点时，你需要检查所需的键是否存在；如果不存在，算法会告诉你该跟随哪个指针到达下一层；为此有一个辅助函数：
- en: '[PRE7]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'This looks for the first element in the keys array that is greater than or
    equal to the key you are searching ❶. If no key fits, findIndex() returns -1,
    so in that case, you return the index of the last element of ptrs (you’ll see
    the reason for this tricky code soon enough):'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 这会寻找键数组中第一个大于或等于你所搜索的键的元素 ❶。如果没有匹配的键，findIndex() 会返回 -1，因此在这种情况下，你返回 ptrs 中最后一个元素的索引（你很快就会明白为什么这段代码如此巧妙）：
- en: '[PRE8]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: If you are searching for a key and arrive at an empty node ❶, the key obviously
    isn’t there. Otherwise, the _findIndex() method finds the first key that isn’t
    less than the searched-for key ❷. If the key is actually equal to the value you
    want to find ❸, you are done; otherwise, continue the search at the corresponding
    pointer. This is why you had _findIndex() return the last position in the array—because
    that’s the link you need to follow when the key you want to find is greater than
    all the keys in the node.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在搜索一个键，并且到达一个空节点 ❶，显然该键不在其中。否则，_findIndex() 方法会找到第一个不小于所搜索键的键 ❷。如果该键正好等于你要查找的值
    ❸，则搜索完成；否则，继续沿着相应的指针进行搜索。这就是为什么你让 _findIndex() 返回数组中的最后一个位置——因为当你要查找的键大于节点中的所有键时，这是你需要跟随的链接。
- en: It may seem like a backward step to do a linear search when you have already
    seen better ways of searching; see question 13.7 for some ideas on better ways
    of searching.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 进行线性搜索可能看起来是倒退的一步，尤其是在你已经看过更好的搜索方法时；有关更好的搜索方法的想法，请参见问题 13.7。
- en: Traversing a B-tree
  id: totrans-103
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 遍历 B 树
- en: We can define the equivalent to the inorder traversal for binary trees, which
    means visiting all keys in ascending order. Since each node has several keys,
    you need to work carefully. [Figure 13-10](chapter13.xhtml#fig13-10) shows how
    to do this.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以定义二叉树的中序遍历等效方式，这意味着按升序访问所有键。由于每个节点有多个键，因此需要仔细操作。[图 13-10](chapter13.xhtml#fig13-10)展示了如何实现这一点。
- en: '![](../images/Figure13-10.jpg)'
  id: totrans-105
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/Figure13-10.jpg)'
- en: 'Figure 13-10: A traversal for B-trees, similar to inorder for binary trees'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 图 13-10：B 树的遍历，类似于二叉树的中序遍历
- en: This version of inorder should visit keys in ascending order, so with the node
    in [Figure 15-9](chapter15.xhtml#fig15-9), start with the first (leftmost) child,
    then visit the node’s first key, followed by the second child, then the second
    key, then the third child, then the third key, and so on, ending after having
    traversed the rightmost child.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 这种版本的中序遍历应该按升序访问键，因此，对于[图 15-9](chapter15.xhtml#fig15-9)中的节点，首先访问最左边的子节点，然后访问该节点的第一个键，再访问第二个子节点，然后是第二个键，然后是第三个子节点，依此类推，直到遍历完最右边的子节点。
- en: 'Here’s a version of it at work:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是一个它工作的示例：
- en: '[PRE9]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'If the current node is empty ❶, do nothing; otherwise, do a loop ❷, alternating
    between traversing a child ❸ and visiting a key ❹. For the latter, remember that
    there’s one fewer key than children. This code uses the condition && expression
    syntax as a shortcut to an if or ternary operator: expression is evaluated if
    and only if condition is true; in this case, visit a key if and only if the corresponding
    index is within the array of keys.'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 如果当前节点为空 ❶，什么都不做；否则，执行一个循环 ❷，在遍历子节点 ❸ 和访问键 ❹ 之间交替进行。对于后者，请记住，键的数量比子节点少一个。此代码使用&&表达式语法作为if或三元运算符的快捷方式：当且仅当条件为真时，表达式才会被求值；在此情况下，只有当对应索引在键数组范围内时，才访问键。
- en: Adding a Key to a B-tree
  id: totrans-111
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 向B树添加键
- en: Now consider how to add a key. If you want to add a key to a node that has enough
    empty space, it’s straightforward. The problem is trying to add a key to a node
    that’s already too full to allow another key. Consider both cases using the B-tree
    of order 3 from earlier as an example (see [Figure 13-11](chapter13.xhtml#fig13-11)).
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 现在考虑如何添加一个键。如果你想向一个有足够空余空间的节点添加键，这很简单。问题在于试图将一个键添加到一个已经满了的节点。考虑使用之前提到的3阶B树作为例子（见[图13-11](chapter13.xhtml#fig13-11)）。
- en: '![](../images/Figure13-11.jpg)'
  id: totrans-113
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/Figure13-11.jpg)'
- en: 'Figure 13-11: A B-tree into which you’ll add some new keys'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 图13-11：你将添加一些新键的B树
- en: First, try to add a 66 key. After searching, you decide it should go with the
    63 key, and since that node has enough space, there’s no extra work (see [Figure
    13-12](chapter13.xhtml#fig13-12)).
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，尝试添加一个66的键。经过查找后，你决定它应该与63的键一起，并且因为该节点有足够的空间，所以不需要额外操作（见[图13-12](chapter13.xhtml#fig13-12)）。
- en: '![](../images/Figure13-12.jpg)'
  id: totrans-116
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/Figure13-12.jpg)'
- en: 'Figure 13-12: Adding a key at a node with space causes no problems.'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 图13-12：在有空间的节点添加键不会遇到问题。
- en: Now make things more complicated, and add a 10 key. That’s a problem, because
    the bottom-left node has no more space. First, you can let it grow beyond its
    maximum size (see [Figure 13-13](chapter13.xhtml#fig13-13)).
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让事情变得更复杂，添加一个10的键。这个问题在于，左下角的节点已经没有空间了。首先，你可以让它超出最大大小（见[图13-13](chapter13.xhtml#fig13-13)）。
- en: '![](../images/Figure13-13.jpg)'
  id: totrans-119
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/Figure13-13.jpg)'
- en: 'Figure 13-13: Adding a key at a node at limit requires splitting the node and
    rotating a key up.'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 图13-13：在节点达到限制时添加键需要分裂节点并旋转一个键到上层。
- en: Now you need to split the oversized node in two and make its middle key go up
    to the parent node. Fortunately, that node has space, so you are done (see [Figure
    13-14](chapter13.xhtml#fig13-14)).
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你需要将过大的节点分裂成两个，并将它的中间键上移到父节点。幸运的是，父节点有空间，所以操作完成了（见[图13-14](chapter13.xhtml#fig13-14)）。
- en: '![](../images/Figure13-14.jpg)'
  id: totrans-122
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/Figure13-14.jpg)'
- en: 'Figure 13-14: After the split, the B-tree structure is okay again.'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 图13-14：分裂后，B树结构恢复正常。
- en: 'If you try to add a 78 key, this node would split twice: first, the 66 key
    would go up to the 34-60 node, and then that node would split, sending its middle
    key (60) to its parent. This is the only way a B-tree can grow: if its root needs
    splitting, it adds a new level.'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你尝试添加一个78的键，这个节点会分裂两次：首先，66的键会移动到34-60节点，然后该节点会分裂，将它的中间键（60）传递到父节点。这是B树唯一的生长方式：如果根节点需要分裂，它会增加一个新层级。
- en: 'Take a look at the code and see what happens at the root level:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 看一下代码，看看根节点层级发生了什么：
- en: '[PRE10]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The easiest case is if the tree is empty ❶, because then all you need to do
    is create a new node with the new key and a couple of null pointers. Otherwise,
    add the key somewhere in the tree ❷ (using an auxiliary recursive _add() method,
    which will see it immediately), and check whether the root became too big ❸. If
    so, create two new nodes ❹ ❺, each with half the keys and pointers, leaving the
    middle key at the root ❻, which will have the two new nodes as children ❼.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 最简单的情况是如果树为空 ❶，因为这时你只需要创建一个新节点，并加入新的键和几个空指针。否则，将键添加到树中的某个位置 ❷（使用一个辅助的递归_add()方法，它会立即处理），并检查根节点是否变得太大
    ❸。如果是，创建两个新节点 ❹ ❺，每个节点包含一半的键和指针，并将中间键保留在根节点 ❻，根节点将有这两个新节点作为子节点 ❼。
- en: 'But how is the new key actually added, and what’s the _add() method missing
    earlier? Here’s the code:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，新的键是如何添加的呢？之前的_add()方法又有什么问题呢？下面是代码：
- en: '[PRE11]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: First find in which subtree of the current node to add the new key ❶. If the
    subtree doesn’t exist (the corresponding pointer is null), you are at the bottom
    level and can simply add the key there ❷; no need to do anything else. (Of course,
    the bottom node may have grown too large, but that will be checked by its parent,
    which will fix the situation if needed.) If there is a subtree ❸, recursively
    add the new key into it ❹ and then check whether the child grew too large ❺. If
    so, you need to add a new node that will get the second half of the keys and pointers
    of the outsized node ❻; the middle key and pointer to the new node will go up
    to the parent ❼, and you’ll leave the first half of the keys and pointers in the
    original child ❽. The code isn’t particularly hard to understand, but handling
    indices and arrays properly requires care.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 首先找到当前节点的子树中应该添加新键的位置❶。如果子树不存在（相应的指针为null），说明你已经到达了最底层，可以直接在此添加键❷；无需做其他操作。（当然，底层节点可能变得过大，但这会由其父节点检查，并在必要时解决问题。）如果存在子树❸，则递归地将新键添加到该子树❹，然后检查子节点是否变得过大❺。如果是，你需要添加一个新节点，将过大节点的后半部分键和指针移到新节点❻；中间的键和指针将上升到父节点❼，而原始子节点将保留前半部分键和指针❽。这段代码并不特别难理解，但正确处理索引和数组需要小心。
- en: Removing a Key from a B-tree
  id: totrans-131
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 从B树中移除键
- en: Adding a key introduces the complexity that sometimes a node grows too big,
    and dealing with that requires either rotating or moving a key up. Removing a
    key also causes difficulties, because nodes may become too empty and need to get
    keys from other nodes or eventually require a key from the parent, which may make
    the whole B-tree shorter; in the same way that additions may cause it to grow
    taller, removals may lower its height.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 添加一个键会引入复杂性，有时节点可能会变得过大，处理这个问题需要旋转或将键上移。移除一个键也会带来困难，因为节点可能变得过空，需要从其他节点获取键，或者最终需要从父节点获取键，这可能导致整个B树的高度变短；就像添加键可能使其变高一样，移除键则可能使其变低。
- en: 'There are several possible cases to study, but here are two: removing a key
    that isn’t in a leaf and removing a key that is in a leaf.'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 有几种可能的情况需要研究，这里有两种：移除一个不在叶子节点中的键和移除一个位于叶子节点中的键。
- en: Removing a Key from a Nonleaf Node
  id: totrans-134
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 从非叶子节点移除键
- en: Removing a key in an internal node is easy; it’s the same as for binary search
    trees. Replace the key with the one that follows it in ascending order and then
    remove *that* key (which will be at a leaf) from the tree. For instance, assume
    you want to remove the 22 key from the tree in [Figure 13-15](chapter13.xhtml#fig13-15).
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 在内部节点中移除键很容易；它与二叉搜索树中的操作相同。将键替换为后继键（按照升序排列的下一个键），然后从树中移除*该*键（它会位于叶子节点）。例如，假设你想从[图13-15](chapter13.xhtml#fig13-15)中的树中移除22键。
- en: '![](../images/Figure13-15.jpg)'
  id: totrans-136
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/Figure13-15.jpg)'
- en: 'Figure 13-15: A B-tree from which you’ll remove a key not from a leaf—in this
    case, the 22'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 图13-15：一个B树，你将在其中移除一个非叶子节点的键——在这个例子中是22
- en: You first need to locate the key following 22, so follow the link after 22 and
    then continue following the leftmost link until you get to a leaf to find the
    24 key (see [Figure 13-16](chapter13.xhtml#fig13-16)).
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 你需要首先定位到22后的键，因此跟随22后的链接，然后继续沿着最左侧的链接，直到到达一个叶子节点找到24键（见[图13-16](chapter13.xhtml#fig13-16)）。
- en: '![](../images/Figure13-16.jpg)'
  id: totrans-139
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/Figure13-16.jpg)'
- en: 'Figure 13-16: To remove 22, first locate the following (greater) key, which
    is 24 in this case.'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 图13-16：要移除22，首先定位到下一个（更大的）键，在此例中是24。
- en: Now, replace the key to be removed (22) with the following key (24) and proceed
    with the logic to remove a key from a leaf node (marked in gray in [Figure 13-17](chapter13.xhtml#fig13-17)).
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，将要移除的键（22）替换为下一个键（24），然后继续按照从叶子节点移除键的逻辑进行操作（在[图13-17](chapter13.xhtml#fig13-17)中以灰色标记）。
- en: '![](../images/Figure13-17.jpg)'
  id: totrans-142
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/Figure13-17.jpg)'
- en: 'Figure 13-17: After moving 24 to the place of the 22, you now need to remove
    the 24 from the leaf node.'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 图13-17：将24移到22的位置后，你现在需要从叶子节点中移除24。
- en: With this method, you always have to remove keys from a leaf node. Here’s how
    to do it.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这种方法，你总是需要从叶子节点中移除键。以下是如何操作。
- en: Removing a Key from a Leaf Node
  id: totrans-145
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 从叶子节点移除键
- en: 'After finding the key to remove and checking that it’s in a leaf node, you
    have two possible cases: either the node is “full enough,” so removing the key
    won’t make it too empty, or the node is at its minimum size, which means removing
    the key will leave it undersized.'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 在找到要移除的键并确认它位于叶子节点后，你有两种可能的情况：要么该节点“足够满”，因此移除键不会使其过空，要么该节点处于最小大小，这意味着移除键会让它变得过小。
- en: 'The first case is easy to handle: continuing the example from the previous
    section, to remove the 24 key, just remove it from the node, which has enough
    keys (see [Figure 13-18](chapter13.xhtml#fig13-18)).'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个情况很容易处理：继续上一节的例子，要移除24键，只需将其从节点中移除，因为该节点有足够的键（见[图13-18](chapter13.xhtml#fig13-18)）。
- en: '![](../images/Figure13-18.jpg)'
  id: totrans-148
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/Figure13-18.jpg)'
- en: 'Figure 13-18: If after removal the leaf node still has enough keys, you’re
    done.'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 图13-18：如果移除后叶子节点仍有足够的键，你就完成了。
- en: 'But consider a more complicated case: What happens if you want to remove the
    12 key? You have a problem, because the corresponding node would end up with not
    enough keys, as shown in [Figure 13-19](chapter13.xhtml#fig13-19). (In this case,
    the node gets emptied, because you are dealing with a B-tree of order 3; in a
    B-tree of a higher order, the node would still have some keys, but just not enough.)'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 但考虑一个更复杂的情况：如果你要移除12键，会发生什么？你会遇到问题，因为对应的节点最终会键数不足，如[图13-19](chapter13.xhtml#fig13-19)所示。（在这种情况下，节点会变为空，因为你正在处理一个3阶的B树；在更高阶的B树中，节点仍然会有一些键，但不足够。）
- en: '![](../images/Figure13-19.jpg)'
  id: totrans-151
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/Figure13-19.jpg)'
- en: 'Figure 13-19: An attempt to rotate keys from a sibling to reorganize the B-tree'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 图13-19：尝试从兄弟节点旋转键以重新组织B树
- en: The solution here depends on the node’s siblings. You can try to borrow keys
    from one of them and check whether it’s possible to borrow from the left or right
    sibling; both siblings are symmetrical. In this case, the left sibling has enough
    keys (4 and 9), so you borrow one from it. The 9 key goes into the parent node,
    and the 11 key is rotated down into the leaf (see [Figure 13-20](chapter13.xhtml#fig13-20)).
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的解决方案取决于节点的兄弟。你可以尝试从其中一个兄弟借键，检查是否可以从左边或右边的兄弟借键；两个兄弟是对称的。在这种情况下，左兄弟有足够的键（4和9），所以从它那里借一个。9键进入父节点，11键被旋转到叶子节点（见[图13-20](chapter13.xhtml#fig13-20)）。
- en: '![](../images/Figure13-20.jpg)'
  id: totrans-154
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/Figure13-20.jpg)'
- en: 'Figure 13-20: A rotation fixed the problem, so you’re done.'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 图13-20：旋转解决了问题，所以你完成了。
- en: 'You have only one pending case to deal with: What happens if no sibling has
    keys to share? In that scenario, merge the node with a sibling, borrowing one
    key from the parent. This step may cause it to become undersized as well and need
    to be fixed. In this example, say you want to remove the 11 key. Merge it with
    its sibling and borrow the 9 key, reaching the situation shown in [Figure 13-21](chapter13.xhtml#fig13-21).'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 你只剩下一个待处理的情况：如果没有兄弟节点有键可共享，会发生什么？在这种情况下，将节点与其兄弟合并，并从父节点借用一个键。这个步骤可能会导致节点变得不足，并需要修复。在这个例子中，假设你要移除11键。将它与其兄弟合并，并借用9键，达到了[图13-21](chapter13.xhtml#fig13-21)所示的情况。
- en: '![](../images/Figure13-21.jpg)'
  id: totrans-157
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/Figure13-21.jpg)'
- en: 'Figure 13-21: The leaf node was fixed, but a problem appears above it.'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 图13-21：叶子节点已经修复，但它上面出现了问题。
- en: To solve the new undersized node situation, you again turn to the borrowing
    concept, rotate keys around, and the final tree would look like [Figure 13-22](chapter13.xhtml#fig13-22).
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解决新的不足节点情况，你再次使用借键的概念，旋转键，最终的树形如[图13-22](chapter13.xhtml#fig13-22)所示。
- en: '![](../images/Figure13-22.jpg)'
  id: totrans-160
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/Figure13-22.jpg)'
- en: 'Figure 13-22: A new rotation fixes the problem.'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 图13-22：新的旋转解决了问题。
- en: When doing this sharing and joining, it’s possible that eventually the tree
    will grow shorter in height. If you removed the 4 and 9 keys in succession, you’d
    arrive at the tree in [Figure 13-23](chapter13.xhtml#fig13-23).
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 在进行共享和合并时，最终树可能会变得更短。如果你连续移除了4和9键，你会得到[图13-23](chapter13.xhtml#fig13-23)中的树形。
- en: '![](../images/Figure13-23.jpg)'
  id: totrans-163
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/Figure13-23.jpg)'
- en: 'Figure 13-23: Removing several keys can make a B-tree eventually grow shorter.'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 图13-23：移除几个键可以使B树最终变得更短。
- en: Can you do the intermediate steps?
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 你能做出中间步骤吗？
- en: Implementing the remove() Method
  id: totrans-166
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 实现remove()方法
- en: 'Now that you’ve seen all the strategies to apply, here’s how to code them.
    Dealing with a removal at the root level is short:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经看到所有的应用策略，接下来是如何编写代码。处理根节点的删除是简短的：
- en: '[PRE12]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: First use a _remove() function to remove the key from the tree recursively ❶.
    If the tree is empty, or if the root node has been left with no keys (because
    it had a single key and had to pass it down when its two children got joined),
    but the node still has one non-null child (the root might already be at the bottom
    level, without children) ❷, return that child. This means the B-tree has become
    shorter.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 首先使用 _remove() 函数递归地从树中移除关键字 ❶。如果树为空，或者根节点已经没有关键字（因为它只有一个关键字，并且在两个子节点合并时必须将其传递下去），但节点仍然有一个非空的子节点（根节点可能已经位于最底层，没有子节点）
    ❷，则返回该子节点。这意味着 B 树已经变得更短。
- en: 'Now start the actual key removal process:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 现在开始实际的关键字移除过程：
- en: '[PRE13]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Start as when doing a search: if the tree is empty, you’re done ❶. Otherwise,
    see whether the current node includes the key you want to remove ❷. If you find
    the key and are at the bottom level ❸, just remove that key and its corresponding
    pointer ❹; otherwise, if you are at a higher level, find the next key in ascending
    order ❺ using _findMin() and put it in place of the original key you wanted to
    remove ❻. Finish by removing the next key from the tree ❼ and fixing its size
    ❽ if needed (because the child became too small, with not enough keys in it).
    If the key wasn’t in the node, go down to the next level to remove it ❾ and fix
    the size if necessary ❿.'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 从进行搜索时开始：如果树为空，操作结束 ❶。否则，检查当前节点是否包含你要移除的关键字 ❷。如果找到关键字并且已经到达底层 ❸，直接移除该关键字及其对应的指针
    ❹；否则，如果你在更高的层次，使用 _findMin() 查找按升序排列的下一个关键字 ❺，并将其放入你想移除的原始关键字的位置 ❻。最后，移除树中的下一个关键字
    ❼，并在需要时修正其大小 ❽（因为子节点变得太小，里面没有足够的关键字）。如果关键字不在节点中，向下移至下一层进行移除 ❾，并在必要时修复大小 ❿。
- en: 'How do you find the next key? You have seen similar methods before, and for
    B-trees, the code is also quite short:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 如何找到下一个关键字？你之前可能见过类似的方法，对于 B 树，代码也相当简短：
- en: '[PRE14]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: If there’s no leftmost subtree, return the first key in the node; otherwise,
    go down to the subtree and look for the minimum there.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 如果没有最左边的子树，返回节点中的第一个关键字；否则，向下进入子树并寻找那里的最小值。
- en: 'The last method is _fixChildIfSmall(), which deals with all the cases mentioned
    before and properly rebalances nodes. The following includes four distinct cases,
    but the logic for each of them is short:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一种方法是 _fixChildIfSmall()，它处理之前提到的所有情况并正确地重新平衡节点。以下包括四种不同的情况，但每种情况的逻辑都很简短：
- en: '[PRE15]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: First, just verify whether the child is still big enough ❶, and if so, nothing
    needs to be done. Then, check whether the child has a left sibling that won’t
    become too empty if you take one key from it ❷; if this is the case, do a rotation
    of keys as described earlier ❸. Alternatively, check whether the child has a right
    sibling with enough keys ❹, and if so, do the rotation with that sibling ❺. If
    no rotation was possible and if there is a left sibling ❻, join it to the child
    ❼; otherwise, there must be a right sibling ❽, so join the child with it instead
    ❾. Again, the cases are not complex, but take care when manipulating indices;
    it’s easy to get things wrong.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，验证子节点是否仍然足够大 ❶，如果是，则无需做任何操作。然后，检查子节点是否有一个左兄弟，如果从中取一个关键字不会导致它变得太空 ❷；如果是这种情况，则进行如前所述的关键字旋转
    ❸。或者，检查子节点是否有一个右兄弟，且其包含足够的关键字 ❹，如果是，执行与该兄弟的旋转 ❺。如果无法进行旋转并且有左兄弟 ❻，则将其与子节点合并 ❼；否则，必定有一个右兄弟
    ❽，因此与它合并 ❾。再次强调，情况不复杂，但操作索引时需要小心；很容易出错。
- en: Considering Performance for B-trees
  id: totrans-179
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 考虑 B 树的性能
- en: A B-tree ensures that every node (apart from the root) will have a minimum number
    of children, so it grows exponentially as levels are added, meaning that the height
    is logarithmic; all paths from the root to another key will be *O*(log *n*), so
    all algorithms turn out to be logarithmic, as shown in [Table 13-1](chapter13.xhtml#tab13-1).
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: B 树确保每个节点（根节点除外）至少有一定数量的子节点，因此随着层次的增加，它呈指数增长，意味着高度是对数的；从根节点到另一个关键字的所有路径都将是 *O*(log
    *n*)，因此所有算法的时间复杂度都呈对数增长，如 [表 13-1](chapter13.xhtml#tab13-1) 所示。
- en: 'Table 13-1: Performance of Operations for B-trees'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 表 13-1：B 树操作的性能
- en: '| Operation | Performance |'
  id: totrans-182
  prefs: []
  type: TYPE_TB
  zh: '| 操作 | 性能 |'
- en: '| --- | --- |'
  id: totrans-183
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| Create | O(1) |'
  id: totrans-184
  prefs: []
  type: TYPE_TB
  zh: '| 创建 | O(1) |'
- en: '| Add | O(log n) |'
  id: totrans-185
  prefs: []
  type: TYPE_TB
  zh: '| 添加 | O(log n) |'
- en: '| Remove | O(log n) |'
  id: totrans-186
  prefs: []
  type: TYPE_TB
  zh: '| 移除 | O(log n) |'
- en: '| Find | O(log n) |'
  id: totrans-187
  prefs: []
  type: TYPE_TB
  zh: '| 查找 | O(log n) |'
- en: '| Traverse | O(n) |'
  id: totrans-188
  prefs: []
  type: TYPE_TB
  zh: '| 遍历 | O(n) |'
- en: B-trees ensure good performance, so they’re widely used, most notably to create
    indices for databases; in fact, the B-tree is the default structure for MySQL
    and PostgreSQL.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: B 树确保良好的性能，因此被广泛应用，特别是在为数据库创建索引时；事实上，B 树是 MySQL 和 PostgreSQL 的默认结构。
- en: '### Red-Black Trees'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: '### 红黑树'
- en: B-trees are powerful, but can be a bit complex to implement. However, you can
    work with them using a binary representation that produces the same results in
    a different way. In particular, we’ll use B-trees of order 3 but we’ll represent
    them in a binary tree style. The resulting *red-black trees* have very good performance
    and are used, among other places, in the Linux kernel to track directory entries,
    virtual memory, scheduling, and more. In this section we’ll look at left-leaning
    red-black trees, which are a variant created by Robert Sedgewick and are easier
    to implement than the original red-black tree.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: B树功能强大，但实现起来可能有些复杂。不过，你可以使用二进制表示法来操作它们，从而以不同的方式产生相同的结果。具体来说，我们将使用阶数为3的B树，但我们会以二叉树的方式表示它们。最终得到的*红黑树*性能非常好，广泛应用于Linux内核中，用于跟踪目录条目、虚拟内存、调度等。在这一部分，我们将介绍左倾红黑树，这是一种由Robert
    Sedgewick创建的变体，比原始的红黑树更容易实现。
- en: NOTE
  id: totrans-192
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 注意
- en: '*B-trees of order 3 are also known as 2-3 trees, alluding to the fact that
    their nodes have either two or three children. In the same way, B-trees of order
    4 are called 2-3-4 trees or 2-4 trees.*'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: '*阶数为3的B树也被称为2-3树，暗示它们的节点有两个或三个子节点。同样，阶数为4的B树被称为2-3-4树或2-4树。*'
- en: Consider the nodes in a red-black tree as 2-nodes (with two children) or 3-nodes
    (with three children). You can represent 2-nodes as common nodes in any binary
    tree, but here you’ll add an extra node to represent a 3-node (see [Figure 13-24](chapter13.xhtml#fig13-24)).
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 将红黑树中的节点视为2节点（有两个子节点）或3节点（有三个子节点）。你可以将2节点表示为任何二叉树中的普通节点，但在这里你需要添加一个额外的节点来表示3节点（参见[图13-24](chapter13.xhtml#fig13-24)）。
- en: '![](../images/Figure13-24.jpg)'
  id: totrans-195
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/Figure13-24.jpg)'
- en: 'Figure 13-24: A red-black node is actually equivalent to a B-tree of order
    3.'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 图13-24：一个红黑节点实际上等效于一个阶数为3的B树。
- en: The standard nodes are black, and the extra nodes added for 3-nodes are red,
    which allow you to distinguish 2-nodes from 3-nodes. You could also say that links
    between nodes are black if they point to a black node or red if they point to
    a red node.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 标准节点是黑色的，为了区分2节点和3节点，3节点会添加额外的红色节点。你也可以说，指向黑色节点的链接是黑色的，而指向红色节点的链接是红色的。
- en: NOTE
  id: totrans-198
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 注意
- en: '*Since this book is black and white, the “red” nodes will be gray with black
    text and the “black” nodes will be black with white text.*'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: '*由于本书是黑白印刷，"红色"节点将用灰色表示，黑色文字；"黑色"节点将用黑色表示，白色文字。*'
- en: Because of the way representation was defined, red nodes are always to the left;
    in addition, a red node can never be connected to another red node (or, alternatively,
    you can’t have two red links in a row). Also, the root is black, and empty trees
    (leaves at the bottom) are also black.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 根据表示方式的定义，红色节点总是位于左侧；此外，红色节点不能与另一个红色节点连接（或者说，不能有两个连续的红色链接）。另外，根节点是黑色的，空树（位于底部的叶子）也是黑色的。
- en: Now, let’s transform the B-tree we worked with earlier into a red-black tree
    (see [Figure 13-25](chapter13.xhtml#fig13-25)).
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们把之前处理的B树转换成红黑树（见[图13-25](chapter13.xhtml#fig13-25)）。
- en: '![](../images/Figure13-25.jpg)'
  id: totrans-202
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/Figure13-25.jpg)'
- en: 'Figure 13-25: A B-tree that will be converted into a red-black tree'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 图13-25：将转换为红黑树的B树
- en: All 2-children nodes become black nodes and 3-children nodes add a new red node,
    as shown in [Figure 13-26](chapter13.xhtml#fig13-26).
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 所有2子节点变为黑色节点，3子节点则添加一个新的红色节点，如[图13-26](chapter13.xhtml#fig13-26)所示。
- en: '![](../images/Figure13-26.jpg)'
  id: totrans-205
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/Figure13-26.jpg)'
- en: 'Figure 13-26: The equivalent red-black tree'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 图13-26：等效的红黑树
- en: You now have a binary search tree, which means you can use the earlier key-searching
    logic without any changes, but you do need to make adjustments when adding or
    removing keys.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你拥有的是一棵二叉搜索树，这意味着你可以使用之前的关键字查找逻辑而不需要任何改变，但在添加或删除关键字时需要进行调整。
- en: NOTE
  id: totrans-208
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 注意
- en: '*Because of their B-tree origin, red-black trees have another important property.
    All paths from the root to a leaf have the same number of black nodes and up to
    that same number of red nodes. This property is called black balance, and we’ll
    often allude to it in this book.*'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: '*由于其源自B树，红黑树具有另一个重要属性。从根到叶的所有路径具有相同数量的黑色节点，并且最多有相同数量的红色节点。这个属性被称为黑平衡，我们在本书中会经常提到它。*'
- en: Next, let’s look at how to implement these red-black trees, but keep in mind
    their equivalence to B-trees of order 3, because algorithms will make much more
    sense that way, essentially doing the same type of work from earlier in this chapter.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们来看看如何实现这些红黑树，但请记住它们与三阶B树的等价性，因为这样算法会更容易理解，实际上它们做的是本章早些时候介绍的相同类型的工作。
- en: Representing Red-Black Trees
  id: totrans-211
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 表示红黑树
- en: 'Red-black trees are just binary search trees, so you can start with some functions
    you already have, such as the find() method and others that need no changes. For
    these new trees, you need a couple of constants and a method to flip a node’s
    color (you’ll use these frequently):'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 红黑树只是二叉查找树，所以你可以从一些已经有的函数开始，例如find()方法和其他不需要更改的函数。对于这些新树，你需要定义几个常量和一个用于翻转节点颜色的方法（你将频繁使用这些方法）：
- en: '[PRE16]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Now start defining the new tree:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 现在开始定义新的树：
- en: '[PRE17]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: To represent a node’s color, add a color attribute ❶, which is red for new nodes,
    although that color may be changed to black later. You also add a couple of auxiliary
    methods to test a node’s color ❷ ❸. Notice you are defining that an empty tree
    is black.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 为了表示节点的颜色，添加一个颜色属性❶，新节点是红色的，尽管这个颜色可能会在以后更改为黑色。你还需要添加几个辅助方法来测试节点的颜色❷❸。请注意，你定义了空树是黑色的。
- en: Adding a Key to a Red-Black Tree
  id: totrans-217
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 向红黑树添加键
- en: You are essentially just adding a key to a B-tree, which was described earlier.
    Always add nodes as red, which won’t affect the black balance of the tree, but
    you can possibly fix their color later or make other changes. Also take care that
    the root is always black and that all the properties of red-black trees are satisfied.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 本质上，你只是向之前描述过的B树中添加一个键。始终将节点添加为红色，这不会影响树的黑色平衡，但你可以稍后修复它们的颜色或做其他更改。还要注意，根节点始终是黑色的，并且确保满足红黑树的所有性质。
- en: 'To implement the algorithm, you’ll allow (for a while) problems like having
    right red links or two consecutive red links, but you’ll use rotations and color
    changes to fix those situations before you are done. Just add the key and worry
    about fixing problems later:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 为了实现该算法，你将暂时允许出现右侧红链接或两个连续红链接等问题，但你会使用旋转和颜色变化来修复这些情况，直到完成。只需添加键，稍后再修复问题：
- en: '[PRE18]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Add the key with an auxiliary _add() method ❶, which is the same algorithm as
    for common binary search trees with only one innovation, a call to a _fixUp()
    function ❷ that takes care of restoring the structure if there are any problems
    in it. The addition itself is done ❸; then first use _add() to add the new key
    to the tree ❹ and then make sure the root is black ❺.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 使用辅助方法 _add()❶ 添加键，算法与普通二叉查找树相同，唯一的创新是调用 _fixUp() 函数❷，该函数负责在结构出现问题时恢复树的结构。添加操作本身完成后❸，首先使用
    _add() 将新键添加到树中❹，然后确保根节点是黑色的❺。
- en: Restoring a Red-Black Tree Structure
  id: totrans-222
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 恢复红黑树结构
- en: If the red-black structure has been damaged somehow, the trick to restoring
    it lies in the _fixUp() method. Remember a new node is always colored red. The
    possible cases when adding a new key depend on whether the new key ends up forming
    part of a 2-node or a 3-node.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 如果红黑树结构被损坏，恢复它的诀窍在于 _fixUp() 方法。记住新节点总是红色的。添加新键时的可能情况取决于新键是否最终形成了2节点或3节点的一部分。
- en: 'The first situation is simple: if the new child is the left child of a black
    node, you just turned a 2-node into a 3-node, and since the red child is on the
    left of the root, everything’s okay. Call this case (a). Otherwise, if the new
    child is to the right of the black root, you can fix it with a rotation. Call
    this case (b). [Figure 13-27](chapter13.xhtml#fig13-27) shows both cases; N is
    the newly added key, and R is the original root for the 2-node.'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个情况很简单：如果新子节点是黑色节点的左子节点，你就把一个2节点变成了3节点，并且由于红色子节点位于根的左侧，一切都没问题。将此情况称为（a）。否则，如果新子节点位于黑色根节点的右侧，你可以通过旋转来修复它。将此情况称为（b）。[图13-27](chapter13.xhtml#fig13-27)展示了这两种情况；N是新添加的键，R是2节点的原根节点。
- en: '![](../images/Figure13-27.jpg)'
  id: totrans-225
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/Figure13-27.jpg)'
- en: 'Figure 13-27: A rotation is needed if adding a node to the right.'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 图13-27：如果将节点添加到右侧，需要进行旋转。
- en: For case (a), nothing needs to be done, and a rotation to the left solves case
    (b). In both situations, the black balance of the whole hasn’t been affected.
    You didn’t add any black links, so everything’s still fine. Also, notice that
    the N node, originally red, has turned black.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 对于情况（a），无需执行任何操作，左旋即可解决情况（b）。在这两种情况下，整个树的黑色平衡没有受到影响。你没有添加任何黑色链接，所以一切仍然正常。同时注意，最初是红色的N节点已经变成了黑色。
- en: The more complex case happens when you add the new key to an existing 2-node
    (thus creating a 3-node), because in this case, all situations are wrong. The
    (relatively) easiest case to fix is when the new key becomes the rightmost key
    in the 3-node, as shown in [Figure 13-28](chapter13.xhtml#fig13-28). Call this
    case (c).
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 更复杂的情况发生在你将新键添加到现有的 2-节点（从而创建 3-节点）时，因为在这种情况下，所有的情况都是错误的。修复起来相对最简单的情况是当新键成为
    3-节点中的最右边键，如[图 13-28](chapter13.xhtml#fig13-28)所示。我们将此情况称为 (c)。
- en: '![](../images/Figure13-28.jpg)'
  id: totrans-229
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/Figure13-28.jpg)'
- en: 'Figure 13-28: You can fix adding a new key to a 2-node tree by flipping colors,
    but new problems may appear above it.'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 图 13-28：你可以通过翻转颜色来修复将新键添加到 2-节点树中的情况，但它上方可能会出现新的问题。
- en: 'Here, a quick solution is available: just flip the three nodes’ colors. But
    notice that doing so will send a red link up the tree, which may require further
    recursive fixing. Also, verify that the black balance of the tree was maintained,
    so the fix is good.'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个快速的解决方案：只需翻转三个节点的颜色。但是要注意，翻转后会将一个红色链接向上传递，可能需要进一步的递归修复。同时，确保树的黑色平衡保持不变，这样修复就算有效。
- en: The next case in terms of complexity is adding the newest key to the left of
    the leftmost one in a 3-node. Call this case (d); you need two steps to solve
    it, as shown in [Figure 13-29](chapter13.xhtml#fig13-29).
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来复杂度较高的情况是将新键添加到 3-节点中最左侧的左子节点左边。我们将此情况称为 (d)；你需要两步才能解决它，如[图 13-29](chapter13.xhtml#fig13-29)所示。
- en: '![](../images/Figure13-29.jpg)'
  id: totrans-233
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/Figure13-29.jpg)'
- en: 'Figure 13-29: Adding a child to the left of a left child can also be solved
    with rotations.'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 图 13-29：将子节点添加到左子节点的左侧也可以通过旋转来解决。
- en: If the new key is the lowest key in a 3-node, you have two left red children
    in a row. Start by doing a right rotation at the root, and that will leave you
    with the previous case (black root, two red children), so a final color flip will
    again solve the problem, although you may still need more recursive fixes.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 如果新键是 3-节点中最小的键，你就会有两个连续的左红子节点。首先在根节点做一次右旋转，这样你会得到之前的情况（黑色根节点，两个红色子节点），然后再进行一次颜色翻转来解决问题，尽管你可能还需要更多的递归修复。
- en: The final case (e) is the most complex. Add a new key that ends as the middle
    key, placed between the two existing keys in a 3-node, as shown in [Figure 13-30](chapter13.xhtml#fig13-30).
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 最终的情况 (e) 是最复杂的。添加一个新键，这个新键最终成为中间键，位于 3-节点中两个现有键之间，如[图 13-30](chapter13.xhtml#fig13-30)所示。
- en: '![](../images/Figure13-30.jpg)'
  id: totrans-237
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/Figure13-30.jpg)'
- en: 'Figure 13-30: You also can fix adding a child to the right of a left child
    with rotations plus color-flipping.'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 图 13-30：你也可以通过旋转加颜色翻转的方式来修复将子节点添加到左子节点右侧的情况。
- en: In this case, you end with a red node to the right of another red node, which
    is a no-no. You can solve the issue by starting a rotation to the left, which
    leaves you with a situation you’ve already dealt with, and finish with another
    rotation, this time to the right, to get a scenario you’ve seen twice before (black
    root with two red children), so a final color flip solves everything.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，你会得到一个红色节点位于另一个红色节点的右侧，这是不允许的。你可以通过开始左旋转来解决这个问题，这会使你得到一个已经处理过的情况，然后完成右旋转，得到一个你之前见过两次的场景（黑色根节点和两个红色子节点），因此最终的颜色翻转可以解决所有问题。
- en: 'Take a look at the rotations code, which is exactly the same as when we studied
    AVL trees in [Chapter 12](chapter12.xhtml), except we don’t need to maintain a
    height attribute:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 看一看旋转代码，它与我们在[第 12 章](chapter12.xhtml)研究 AVL 树时完全相同，唯一的不同是我们不需要维护高度属性：
- en: '[PRE19]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: The only additions are the two lines in bold that exchange colors.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 唯一的新增内容是两条粗体线，它们交换了颜色。
- en: 'Now we’ll delve into the far more interesting code that applies all the fixes
    described (note that we’ll also use this code for removals; the same logic applies
    there):'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将深入探讨应用所有已描述修复的更有趣的代码（请注意，我们也将在删除操作中使用这段代码；同样的逻辑适用）：
- en: '[PRE20]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: If the node you’re looking at has a red right child, do a rotation to the left
    ❶, which solves case (b) and is the first step for cases (c) and (e), which will
    be completed later, when you move up recursively. If you have a left red child
    and a left red grandchild ❷, this is case (d); you could also have arrived here
    after doing a rotation in case (e). Finally, after the previous changes, either
    you have fixed everything—if you were originally in cases (a) or (b)—or you still
    need to flip the color ❸, and you’re done.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你查看的节点有一个红色的右孩子，进行左旋转❶，这解决了（b）情况，并且是（c）和（e）情况的第一步，当你递归向上时，后续步骤将完成。如果你有一个左红色子节点和一个左红色孙子节点❷，这就是（d）情况；你也可能在（e）情况做完旋转后到达这里。最后，在前面的变更后，要么你已经修复了所有问题——如果你最初处于（a）或（b）情况——要么你仍然需要翻转颜色❸，然后完成。
- en: 'Consider another takeaway from this algorithm: color flipping and rotations
    to the left or to the right all retain the black balance in a tree, so if you
    start with a red-black tree and apply only those transformations, you’ll necessarily
    end with a red-black tree. This concept is important for additions, but you’ll
    also apply it for removals.'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个来自该算法的收获是：左右旋转和颜色翻转都能保持树中的黑色平衡，因此，如果你从一棵红黑树开始，并且只应用这些变换，你最终必定会得到一棵红黑树。这个概念对插入操作很重要，但在删除操作时也会应用。
- en: Removing a Key from a Red-Black Tree
  id: totrans-247
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 从红黑树中删除一个键
- en: Removing a key from a red-black tree is probably the most complex algorithm
    discussed in this book. (Many textbooks and other resources tend to omit it or,
    at most, only hint at it.) While adding a key is not too complex, being basically
    the same algorithm as for common binary search trees (plus some logic to ascertain
    that certain constraints are being kept), deletion requires a more difficult process
    with changes both up and down the tree.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 从红黑树中删除一个键可能是本书讨论的最复杂的算法。（许多教科书和其他资源通常会省略它，或者最多只做简单提示。）虽然添加一个键并不复杂，基本上和常见的二叉搜索树算法一样（加上一些检查约束是否保持的逻辑），但是删除需要一个更复杂的过程，包括树的上下变动。
- en: You need to ensure that the key to be deleted is at the bottom of the tree as
    part of a 3-node (either the black or red node), because in that case, removing
    it causes no problem. If the key to be deleted is the red one, just take it off.
    If you want to delete the black one, put the red key in its place, but change
    the color to black to maintain balance. [Figure 13-31](chapter13.xhtml#fig13-31)
    shows both cases; X marks the key to be removed.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 你需要确保要删除的键位于树的底部，作为一个三节点的一部分（无论是黑色节点还是红色节点），因为在这种情况下，删除它不会导致任何问题。如果要删除的是红色键，直接把它删除即可。如果要删除的是黑色键，将红色键替换到它的位置，但将颜色改为黑色以保持平衡。[图13-31](chapter13.xhtml#fig13-31)展示了这两种情况；X标记了要删除的键。
- en: '![](../images/Figure13-31.jpg)'
  id: totrans-250
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/Figure13-31.jpg)'
- en: 'Figure 13-31: Removing a red leaf is direct, and removing the black root is
    also easy to achieve.'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 图13-31：删除一个红色叶子是直接的，而删除黑色根节点也容易实现。
- en: Here’s the process. Either do rotations or flip colors as you go down, so at
    all times, the node at the root either is red or has a red left child, and you’ll
    tolerate (for now) having red right children or black nodes with two red children.
    When you find the key you want, replace it with the following key (as with binary
    search trees) and then proceed to remove that key from the tree. When you find
    it, one of the two cases illustrated in [Figure 13-31](chapter13.xhtml#fig13-31)
    will apply, and you’ll effectively remove the key. Finally, apply the “fix-up”
    algorithm to go back to the root and take care of whatever problems might be left.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 过程是这样的。你可以在向下过程中做旋转或翻转颜色，因此始终保证根节点要么是红色，要么有一个红色的左子节点，并且（暂时）容忍有红色的右子节点或两个红色子节点的黑色节点。当你找到你想要的键时，将其替换为下一个键（如同二叉搜索树），然后继续从树中删除该键。找到时，将会有图13-31中所示的两种情况之一适用，你就能有效地删除该键。最后，应用“修复”算法回到根节点，处理可能残留的任何问题。
- en: 'Remember the invariant to uphold: either the root or its left child must be
    black. Assume that at some moment in the algorithm, you have to go down to the
    left. Obviously, if the root is black, you just go down to the left (which is
    red). The invariant will persist, and now the root will be red. However, if the
    left child is black, there are two cases, depending on the color of the root’s
    right child’s left child. If that child is black, you can just flip colors, as
    [Figure 13-32](chapter13.xhtml#fig13-32) shows (it doesn’t include other links
    or subtrees for clarity, so you can focus on the important nodes). The small triangle
    points to the new red node, which you’ll move left for the updated invariant.'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 记住需要遵守的不变式：根节点或其左子节点必须是黑色的。假设在算法的某个时刻，你必须向左移动。显然，如果根节点是黑色的，你只需向左移动（左子节点是红色的）。不变式将得以保持，现在根节点将变为红色。然而，如果左子节点是黑色的，那么有两种情况，取决于根节点右子节点的左子节点的颜色。如果那个子节点是黑色的，你可以直接翻转颜色，正如[图
    13-32](chapter13.xhtml#fig13-32)所示（为简化起见，它没有包括其他链接或子树，因此你可以专注于重要的节点）。小三角形指向新的红色节点，你将其向左移动以更新不变式。
- en: '![](../images/Figure13-32.jpg)'
  id: totrans-254
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/Figure13-32.jpg)'
- en: 'Figure 13-32: Color flipping adjusts this case.'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 图 13-32：颜色翻转调整了这个情况。
- en: In terms of the equivalent red-black tree, this is like joining nodes to create
    a 4-node, which you’ll need to split later.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 就等效的红黑树而言，这就像将节点合并创建一个 4-节点，稍后你将需要将其分割。
- en: 'If the root’s right child’s left child had been red, you would have needed
    more steps: flipping, rotating right, rotating left, and flipping again. But after
    all those transformations (all of which maintain black balance), you’ll be able
    to go down the left: the root’s left child’s left child will be red, and again
    the invariant is maintained. [Figure 13-33](chapter13.xhtml#fig13-33) shows all
    the steps.'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 如果根节点右子节点的左子节点是红色的，你将需要更多的步骤：翻转颜色、右旋、左旋，再翻转颜色。但经过这些变换（所有这些都保持黑色平衡）后，你就可以向左移动：根节点左子节点的左子节点将是红色的，并且不变式得到保持。[图
    13-33](chapter13.xhtml#fig13-33)显示了所有步骤。
- en: '![](../images/Figure13-33.jpg)'
  id: totrans-258
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/Figure13-33.jpg)'
- en: 'Figure 13-33: The most complex case requires several rotations and color flips.'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 图 13-33：最复杂的情况需要多个旋转和颜色翻转。
- en: The initial tree is (a); (b) is the tree after flipping; (c) is after rotating
    the root’s right’s left child to the right; (d) is after rotating the root to
    the left; and finally, (e) is after flipping colors.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 初始树是（a）；（b）是翻转后的树；（c）是旋转根节点右子节点的左子节点到右边后的结果；（d）是将根节点旋转到左边后的结果；最后，(e)是翻转颜色后的结果。
- en: Considering the equivalent 2-3 tree, this deletion was like borrowing the 4-key
    from a 3-node to send the 3-key down to create a 3-node together with the 2-key.
    As before, you are maintaining black balance and there will be nothing to fix
    later.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑等效的 2-3 树，这次删除操作就像从一个 3-节点借用 4 键，并将 3 键下移，和 2 键一起创建一个 3-节点。如前所述，你在保持黑色平衡，稍后不会有需要修复的情况。
- en: Now consider the other case, which is when you want to move right. This case
    is similar to the ones you just explored, but it’s a tad simpler. If the root
    is black and its right child is red, just move to it with no fuss. If the root
    is red, its left child is black, and the root’s left child’s left child is also
    black, you can just flip colors. Take a look at the situation shown in [Figure
    13-34](chapter13.xhtml#fig13-34).
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 现在考虑另一种情况，即你想要向右移动。这个情况与之前的类似，但稍微简单一些。如果根节点是黑色的，且右子节点是红色的，那么直接向右移动即可。如果根节点是红色的，且其左子节点是黑色的，并且根节点左子节点的左子节点也是黑色的，你可以直接翻转颜色。看看[图
    13-34](chapter13.xhtml#fig13-34)中展示的情况。
- en: '![](../images/Figure13-34.jpg)'
  id: totrans-263
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/Figure13-34.jpg)'
- en: 'Figure 13-34: Color-flipping also fixes the potential 4-node tree.'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 图 13-34：颜色翻转也修复了潜在的 4-节点树。
- en: As before, this solution is equivalent to joining nodes and creating a 4-node
    tree, which will need to be fixed later.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，这个解决方案相当于将节点合并并创建一个 4-节点树，稍后需要修复。
- en: The last case occurs when you need to move right and the root’s left child’s
    left child is red. You need to flip colors, do a rotation, and flip colors again
    to re-establish the invariant, as shown in [Figure 13-35](chapter13.xhtml#fig13-35).
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一种情况发生在你需要向右移动，而根节点左子节点的左子节点是红色时。你需要翻转颜色，进行旋转，然后再翻转颜色以恢复不变式，正如[图 13-35](chapter13.xhtml#fig13-35)所示。
- en: '![](../images/Figure13-35.jpg)'
  id: totrans-267
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/Figure13-35.jpg)'
- en: 'Figure 13-35: This complex case also requires both color flipping and rotations.'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 图 13-35：这个复杂的情况也需要同时进行颜色翻转和旋转。
- en: In this scenario, (a) is the initial situation, (b) shows the flipped colors,
    (c) is after rotating the root to the right, and (d) is after flipping colors
    again.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个场景中，(a) 是初始情况，(b) 显示了翻转后的颜色，(c) 是将根节点右旋后，(d) 是再次翻转颜色后的状态。
- en: Again, in terms of the original 2-3 tree, this example is like moving the 2-key
    up from the 3-node where it was to the place of the 3-key, which joins the 4-key
    into a 3-node. However, note that the final situation is not valid (there’s a
    red child to the right), so this will need to be fixed later.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 再次以原始的 2-3 树为例，这个例子就像是将 2 键从 3 节点中移动到 3 键的位置，之后 4 键与其合并成一个 3 节点。然而，注意最终的情况是不合法的（右侧有一个红色子节点），因此稍后需要修复。
- en: 'The complete algorithm is based directly on Sedgewick’s own code, but blame
    any errors on me. The simple part is this:'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 完整的算法直接基于 Sedgewick 自己的代码，但错误请归咎于我。简单部分如下：
- en: '[PRE21]'
  id: totrans-272
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: First apply the algorithm described to actually remove the key from the tree
    ❶ and then make sure the root is black ❷ unless, obviously, there’s no key and
    the tree became empty.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 首先应用描述的算法，实际从树中移除键 ❶，然后确保根节点是黑色的 ❷，除非显然没有键，且树变为空。
- en: 'The complex part is the _remove() code:'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 删除操作的复杂部分是 _remove() 代码：
- en: '[PRE22]'
  id: totrans-275
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: After verifying that the tree isn’t empty, check whether you need to go left
    ❶, and if so ❷, you may need to apply the transformations you saw earlier before
    actually moving left ❸. If the key you want to delete is greater than or equal
    to the root, start by doing a rotation ❹ so that the red node will be to the right,
    which you’ll need later. If you find the key ❺ and it has no right child, it must
    be at the bottom, so you can now delete it. You’ll want to move right, so set
    things up according to the procedures described earlier ❻ but don’t move just
    yet. If you find the key but aren’t able to delete it, replace it with the following
    key in the tree and move right to delete that value ❼; otherwise, just move right
    to keep looking for the key to be removed ❽. At the end, a final fix-up pass ❾
    solves any wrong configurations in the tree.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 在验证树不为空后，检查是否需要向左移动 ❶，如果需要 ❷，你可能需要先应用之前看到的变换，再实际向左移动 ❸。如果要删除的键大于或等于根节点，首先进行一次旋转
    ❹，这样红色节点将移至右侧，稍后会用到。如果找到键 ❺ 并且它没有右子节点，那它一定在树的底部，此时可以删除它。你会想向右移动，因此按之前描述的程序设置好
    ❻，但不要立刻移动。如果找到了键，但无法删除，替换成树中的下一个键并向右移动删除该值 ❼；否则，直接向右移动继续寻找要删除的键 ❽。最后，一次最终的修复 ❾
    将解决树中的任何错误配置。
- en: Red-black trees have the shortest code for searching and not very complex code
    for adding a new key (basically, just adding a fix-up call at the end), but the
    deletions are rather more involved. Getting the code right is difficult (see question
    13.10 for a small detail).
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 红黑树在搜索方面的代码最简洁，而添加新键的代码也不复杂（基本上，只是在最后添加一个修复调用），但是删除操作则相对复杂。正确编写代码是很困难的（见问题 13.10
    中的小细节）。
- en: Considering Performance for Red-Black Trees
  id: totrans-278
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 考虑红黑树的性能
- en: We don’t need to analyze the performance of red-black trees, because they’re
    just another case of B-trees, so you already know that all algorithms (adding,
    removing, and searching) are *O*(log *n*), as [Table 13-2](chapter13.xhtml#tab13-2)
    shows.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不需要分析红黑树的性能，因为它们只是 B 树的另一种情况，因此你已经知道所有算法（添加、删除、搜索）都是 *O*(log *n*)，如[表 13-2](chapter13.xhtml#tab13-2)所示。
- en: 'Table 13-2: Performance of Operations for Red-Black Trees'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 表 13-2：红黑树操作的性能
- en: '| Operation | Performance |'
  id: totrans-281
  prefs: []
  type: TYPE_TB
  zh: '| 操作 | 性能 |'
- en: '| --- | --- |'
  id: totrans-282
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| Create | O(1) |'
  id: totrans-283
  prefs: []
  type: TYPE_TB
  zh: '| 创建 | O(1) |'
- en: '| Add | O(log n) |'
  id: totrans-284
  prefs: []
  type: TYPE_TB
  zh: '| 添加 | O(log n) |'
- en: '| Remove | O(log n) |'
  id: totrans-285
  prefs: []
  type: TYPE_TB
  zh: '| 移除 | O(log n) |'
- en: '| Find | O(log n) |'
  id: totrans-286
  prefs: []
  type: TYPE_TB
  zh: '| 查找 | O(log n) |'
- en: '| Traverse | O(n) |'
  id: totrans-287
  prefs: []
  type: TYPE_TB
  zh: '| 遍历 | O(n) |'
- en: Of course, because of the possible embedded red links, red-black trees are taller
    on average than B-trees of higher orders (and not all paths from the root to a
    leaf have the same length), but that doesn’t change the result. Performance will
    still be logarithmic, even if searches are slower by a (bound) constant factor.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，由于可能嵌入的红色链接，红黑树的高度通常比高阶 B 树要高（并且并非从根到叶的所有路径长度都相同），但这并不改变结果。即使搜索速度变慢了一个（有界的）常数因子，性能仍然是对数级的。
- en: Summary
  id: totrans-289
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 总结
- en: 'In this chapter, we moved beyond binary trees and explored two new structures
    for the dictionary ADT: B-trees and red-black trees (which are derived from B-trees).
    These structures provide good performance, and they’re used often because their
    implementation is not too complex and their speed is significant.'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们超越了二叉树，探索了字典抽象数据类型（ADT）的两种新结构：B树和红黑树（红黑树是从B树衍生出来的）。这些结构提供了良好的性能，且因其实现不复杂且速度显著，常被使用。
- en: In the next chapter, we’ll study heaps, which are a variant of binary trees,
    and then in the following chapter, we’ll look at extended heaps, which combine
    heaps and forests to achieve high performance.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将学习堆，它是二叉树的一种变体，随后在接下来的章节中，我们将学习扩展堆，它结合了堆和森林，以实现高性能。
- en: Questions
  id: totrans-292
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 问题
- en: '**13.1  Missing Test?**'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: '**13.1  缺失的测试？**'
- en: In the appendChild() method for trees, shouldn’t it include a call to this._throwIfEmpty()?
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 在树的appendChild()方法中，是否应该包括对this._throwIfEmpty()的调用？
- en: '**13.2  Traversing General Trees**'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: '**13.2  遍历一般树**'
- en: Implement the missing preorder and postorder traversals. You might want to do
    this for both trees represented with arrays of children and for trees with a “left
    child, right sibling” representation.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 实现缺失的前序和后序遍历。你可能需要对使用子节点数组表示的树和使用“左子节点，右兄弟”表示的树都进行实现。
- en: '**13.3  Nonrecursive Visiting**'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: '**13.3  非递归访问**'
- en: Implement a depth-first traversal of a tree without recursion by using a stack
    as an auxiliary structure.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 实现一个不使用递归的深度优先遍历树的算法，通过使用栈作为辅助结构。
- en: '**13.4  Tree Equality**'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: '**13.4  树的相等性**'
- en: Implement an equals(tree1, tree2) algorithm that will decide whether two trees
    are equal—that is, having the same shape and the same keys in the same positions.
    You may want to “think outside the box” for this. Maybe you won’t even need recursion!
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 实现一个equals(tree1, tree2)算法，用来判断两棵树是否相等——即，它们具有相同的形状和相同位置的键值。你可能需要“跳出框框”思考。也许你甚至不需要递归！
- en: '**13.5  Measuring Trees**'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: '**13.5  衡量树**'
- en: Redo the calcSize() and calcHeight() functions from [Chapter 12](chapter12.xhtml)
    (see questions 12.5 and 12.6) to work with multiway trees.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 重新实现[第12章](chapter12.xhtml)中的calcSize()和calcHeight()函数（参见问题12.5和12.6），使其适用于多路树。
- en: '**13.6  Sharing More**'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: '**13.6  更多共享**'
- en: In a B-tree, instead of siblings sharing just one key, you can achieve a better
    balance if they share more keys. For example, when adding a key, if a node becomes
    too full and a sibling has enough space, instead of just passing a single key
    to it, pass as many as possible until both siblings are about equally full. A
    similar process would work when removing a key. Implement this optimization.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 在B树中，除了兄弟节点共享一个键之外，如果它们共享更多的键，则可以实现更好的平衡。例如，在添加键时，如果一个节点变得过于拥挤，而一个兄弟节点有足够的空间，那么与其仅传递一个键，不如尽量传递更多的键，直到两个兄弟节点的容量差不多。删除键时，类似的过程也适用。实现这一优化。
- en: '**13.7  Faster Node Searching**'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: '**13.7  更快的节点查找**'
- en: This chapter used linear searching in nodes, but since keys are ordered, a better
    way would be using binary searching. Make this change. Would that make a difference
    in the order of the B-trees’ methods? Why or why not?
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 本章使用了节点的线性查找，但由于键值是有序的，使用二分查找会更好。进行这个更改。这样会对B树的方法顺序产生影响吗？为什么或为什么不？
- en: '**13.8  Lowest Order**'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: '**13.8  最低阶**'
- en: Would B-trees of order 2 make sense?
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 阶数为2的B树是否有意义？
- en: '**13.9  Many Orders of Trees**'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: '**13.9  多阶树**'
- en: 'What would you do if you needed to work with B-trees of different orders? Hint:
    the problem here is that imported modules are singletons. Look for a way to avoid
    this behavior.'
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 如果需要处理不同阶数的B树，你会怎么做？提示：这里的问题是导入的模块是单例模式。尝试寻找一种方法来避免这种行为。
- en: '**13.10  Safe to Delete?**'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: '**13.10  安全删除？**'
- en: In the remove() algorithm for red-black trees, when you actually delete a node,
    are you sure it’s possible to remove it without any negative effects?
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 在红黑树的remove()算法中，当你实际删除一个节点时，是否确定能够在不产生负面影响的情况下将其删除？
