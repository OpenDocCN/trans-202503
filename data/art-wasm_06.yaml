- en: '6'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '6'
- en: Linear Memory
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 线性内存
- en: '![](Images/chapterart.png)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/chapterart.png)'
- en: In this chapter, we’ll examine what linear memory is, how to use it to share
    data between JavaScript and WebAssembly code, and how to create it from within
    JavaScript. We’ll also update linear memory from WebAssembly and then use those
    updates from within the JavaScript code.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将探讨线性内存是什么，如何使用它在 JavaScript 和 WebAssembly 代码之间共享数据，以及如何从 JavaScript
    中创建它。我们还将从 WebAssembly 中更新线性内存，然后在 JavaScript 代码中使用这些更新。
- en: One common task in computer games is collision detection, detecting and appropriately
    reacting to two objects touching. The number of computations required grows exponentially
    as you add objects. Collision detection is a great candidate for building in WebAssembly.
    In this chapter, we’ll create a list of circles defined randomly in the JavaScript,
    and then add that circle data to the WebAssembly linear memory. Then we’ll use
    that data to determine whether any of those circles collide.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在计算机游戏中，一个常见的任务是碰撞检测，即检测并适当地响应两个物体接触的情况。随着物体数量的增加，所需的计算量会呈指数增长。碰撞检测是构建 WebAssembly
    的一个理想候选任务。在本章中，我们将创建一个在 JavaScript 中随机定义的圆形列表，并将该圆形数据添加到 WebAssembly 的线性内存中。然后，我们将使用这些数据来判断这些圆形是否发生碰撞。
- en: WebAssembly shines best when you can pass it tons of data that requires significant
    processing and let it run. A WebAssembly module can perform math faster than JavaScript.
    However, each interaction between JavaScript and the WebAssembly module has an
    associated cost. You can use linear memory to load significant amounts of data
    in JavaScript for processing within a WebAssembly module.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: WebAssembly 在处理大量需要大量计算的数据时表现得最好，并且可以让它运行。WebAssembly 模块比 JavaScript 更快地执行数学运算。然而，每次
    JavaScript 和 WebAssembly 模块之间的交互都有一定的成本。您可以使用线性内存在 JavaScript 中加载大量数据，然后在 WebAssembly
    模块内进行处理。
- en: Linear Memory in WebAssembly
  id: totrans-6
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: WebAssembly 中的线性内存
- en: Linear memory acts as one giant array of data that can be shared between WebAssembly
    and JavaScript. If you’re familiar with low-level programming, linear memory is
    similar to heap memory in native applications. If you’re familiar with JavaScript,
    think of it as one giant `ArrayBuffer` object. Languages like C and C++ create
    local variables by allocating memory on the computer’s stack. The stack-allocated
    local variables are released from memory as soon as the function finishes executing.
    This efficient process means that allocating and deallocating data on the stack
    is as simple as incrementing and decrementing a stack pointer. Your application
    simply increments the stack pointer, and voilà, you have a new allocated variable,
    as depicted in [Figure 6-1](#figure6-1).
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 线性内存充当一个巨大的数据数组，可以在 WebAssembly 和 JavaScript 之间共享。如果你熟悉低级编程，线性内存类似于本地应用程序中的堆内存。如果你熟悉
    JavaScript，可以把它看作一个巨大的`ArrayBuffer`对象。像 C 和 C++ 这样的语言通过在计算机的栈上分配内存来创建局部变量。栈分配的局部变量在函数执行完毕后立即从内存中释放。这一高效的过程意味着在栈上分配和释放数据就像是递增和递减栈指针一样简单。您的应用程序只需递增栈指针，瞧，您就得到了一个新的已分配变量，如[图
    6-1](#figure6-1)所示。
- en: '![f06001](Images/f06001.png)'
  id: totrans-8
  prefs: []
  type: TYPE_IMG
  zh: '![f06001](Images/f06001.png)'
- en: 'Figure 6-1: The stack pointer'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6-1：栈指针
- en: The stack works great for local variables. However, one limitation in WAT is
    that local variables that use the stack can only be one of four types, all of
    which are numeric. Sometimes, you might require more sophisticated data structures,
    such as strings, structures, arrays, and objects.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 栈非常适合用于局部变量。然而，WAT 中的一个限制是，使用栈的局部变量只能是四种类型之一，且它们都属于数值类型。有时，您可能需要更复杂的数据结构，例如字符串、结构体、数组和对象。
- en: Allocation commands, like `malloc` in C and `new`in C++ and JavaScript, allocate
    onto the heap, and the memory management libraries included with those languages
    must look for a free section of memory on the heap large enough to hold the required
    block of memory. Over time that might result in memory fragmentation, where allocated
    memory segments are separated by unallocated memory, as illustrated in [Figure
    6-2](#figure6-2).
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 分配命令，例如 C 中的`malloc`和 C++、JavaScript 中的`new`，将内存分配到堆上，这些语言的内存管理库必须寻找一个足够大的空闲内存区域来容纳所需的内存块。随着时间的推移，这可能导致内存碎片化，即已分配的内存块之间被未分配的内存分隔开，如[图
    6-2](#figure6-2)所示。
- en: 'WebAssembly linear memory is allocated in large chunks called *pages*, which,
    once allocated, cannot be deallocated. WebAssembly memory is also a bit more like
    assembly language memory management: once you’ve allocated your chosen number
    of pages to your WebAssembly module, you, as the programmer, must keep track of
    what you’re using memory for and where it is. In the next few sections, we’ll
    look more closely at how to use linear memory by exploring memory pages.'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: WebAssembly 线性内存以大块叫做*页面*的形式分配，一旦分配后就无法释放。WebAssembly 内存的管理方式也有点像汇编语言的内存管理：一旦您为
    WebAssembly 模块分配了所选数量的页面，您作为程序员必须跟踪您在使用内存时的用途以及它的位置。在接下来的几节中，我们将更仔细地研究如何通过探索内存页面来使用线性内存。
- en: '![f06002](Images/f06002.png)'
  id: totrans-13
  prefs: []
  type: TYPE_IMG
  zh: '![f06002](Images/f06002.png)'
- en: 'Figure 6-2: Linear memory passed data from JavaScript and WebAssembly'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 图6-2：JavaScript 和 WebAssembly 传递的线性内存数据
- en: Pages
  id: totrans-15
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 页面
- en: Pages are the smallest chunk of data that can be allocated for a WebAssembly
    module. At the time of this writing, all WebAssembly pages are 64KB in size. In
    the current version, WebAssembly 1.0, you cannot change that size, although the
    WebAssembly Community Group has an ongoing proposal to make the page size variable
    based on the application’s needs. The maximum number of pages that an application
    can allocate at the time of this writing is 32,767, an overall maximum memory
    size of 2GB. This maximum memory allocation is plenty for web apps but is limiting
    for server-based applications. Increasing the page size could allow server apps
    to increase the maximum amount of linear memory they can allocate. For embedded
    WebAssembly applications, 64KB can be too large; for example, the ATmega328 only
    has 32KB of Flash memory. WebAssembly updates might remove this limitation by
    the time you read this.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 页面是 WebAssembly 模块可以分配的最小数据块。在本文写作时，所有 WebAssembly 页面都是 64KB 大小。在当前版本 WebAssembly
    1.0 中，您无法更改该大小，尽管 WebAssembly 社区组正在进行提案，计划根据应用程序的需求使页面大小可变。本文写作时，应用程序可以分配的最大页面数为
    32,767，总内存大小为 2GB。对于 Web 应用程序来说，这种最大内存分配已经足够，但对于基于服务器的应用程序则有限制。增加页面大小可能使服务器应用程序能够增加它们可以分配的最大线性内存。对于嵌入式
    WebAssembly 应用程序来说，64KB 可能过大；例如，ATmega328 只有 32KB 的闪存。WebAssembly 的更新可能会在您阅读本文时消除这一限制。
- en: You can create the number of pages your app will use either inside the WebAssembly
    module or in the embedding environment for import.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在 WebAssembly 模块内部或在嵌入环境中为导入创建应用程序将使用的页面数量。
- en: Creating Pages in Your Code
  id: totrans-18
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 在代码中创建页面
- en: To allocate a page of linear memory in WAT, use a simple `(memory``)` expression,
    like the one in [Listing 6-1](#listing6-1).
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 要在 WAT 中分配一个线性内存页面，使用一个简单的`(memory)`表达式，如[列表6-1](#listing6-1)所示。
- en: '[PRE0]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Listing 6-1: Declaring a page of memory in WAT'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 列表6-1：在 WAT 中声明一个内存页面
- en: Passing `1` into the memory expression instructs the module to set aside one
    page of linear memory. To allocate the maximum amount of memory you can currently
    allocate to a WebAssembly module at runtime, use the expression in [Listing 6-2](#listing6-2).
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 将`1`传入内存表达式指示模块为线性内存预留一个页面。要分配当前可以为 WebAssembly 模块在运行时分配的最大内存，请使用[列表6-2](#listing6-2)中的表达式。
- en: '[PRE1]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Listing 6-2: Declaring the maximum number of memory pages'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 列表6-2：声明最大内存页面数
- en: Attempting to pass `32_767` into the `(memory``)` expression results in a compile
    error. Memory created using the `(memory``)` expression isn’t accessible to the
    embedding environment unless you include an `(export``)` expression.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试将 `32_767` 传入`(memory)`表达式会导致编译错误。使用`(memory)`表达式创建的内存对嵌入环境不可访问，除非您包含`(export)`表达式。
- en: Creating Memory in the Embedded Environment
  id: totrans-26
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 在嵌入环境中创建内存
- en: The other way to create the linear memory is inside the embedding environment.
    If the embedding environment is JavaScript, the code to create that memory is
    `new WebAssembly.Memory` as in [Listing 6-3](#listing6-3).
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 创建线性内存的另一种方式是在嵌入环境内。如果嵌入环境是 JavaScript，则创建该内存的代码是`new WebAssembly.Memory`，如[列表6-3](#listing6-3)所示。
- en: '[PRE2]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Listing 6-3: Creating a WebAssembly `Memory` object in JavaScript'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 列表6-3：在 JavaScript 中创建 WebAssembly `Memory` 对象
- en: You could then access it from the WebAssembly module using the `(import``)`
    expression in [Listing 6-4](#listing6-4).
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，您可以使用[列表6-4](#listing6-4)中的`(import)`表达式从 WebAssembly 模块访问它。
- en: '[PRE3]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Listing 6-4: Importing a page of memory allocated in JavaScript'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 列表6-4：在 JavaScript 中导入分配的内存页面
- en: Using `import` requires you to create a `Memory` object in JavaScript using
    the `WebAssembly.Memory` class, and then to pass it into the WebAssembly module
    when you initialize it through an `import` object. Create a file called *pointer.js*
    and add the JavaScript code in [Listing 6-5](#listing6-5), which creates a WebAssembly
    `Memory` object.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`import`要求你在 JavaScript 中创建一个 `Memory` 对象，使用 `WebAssembly.Memory` 类，然后在通过
    `import` 对象初始化 WebAssembly 模块时将其传入。创建一个名为 *pointer.js* 的文件，并添加 [Listing 6-5](#listing6-5)
    中的 JavaScript 代码，这段代码创建了一个 WebAssembly `Memory` 对象。
- en: '**pointer.js**'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: '**pointer.js**'
- en: '[PRE4]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Listing 6-5: Initialize WebAssembly linear memory and pass it to the WebAssembly
    module.'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 'Listing 6-5: 初始化 WebAssembly 线性内存并将其传递给 WebAssembly 模块。'
- en: On creation, this code passes in an object with two initialization values. The
    `initial` 1 argument is required and by passing it `1`, we instruct the JavaScript
    engine to set aside one page of linear memory (64KB). The second value `maximum`
    2 is optional and lets the browser know that we’re likely to want to increase
    the size of the linear memory later, and we probably won’t want to grow memory
    to more than four pages. You can increase the size of linear memory by calling
    the `memory.grow` method. You don’t need to set a maximum value to grow your memory,
    but passing in a maximum value tells the browser to set aside more memory than
    the initial value because a call to grow is likely. If you attempt to grow your
    linear memory to more than the maximum value you pass in, the application will
    throw an error. After creating the memory object, we pass it to the WebAssembly
    module through the `importObject` in `env.mem` 3. The JavaScript passes `importObject`
    into the module on instantiation 4.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建时，这段代码传入一个具有两个初始化值的对象。`initial` 1 参数是必需的，通过传入 `1`，我们指示 JavaScript 引擎为线性内存保留一页空间（64KB）。第二个值
    `maximum` 2 是可选的，它让浏览器知道我们可能希望稍后增加线性内存的大小，并且我们大概率不会希望将内存增长到超过四页。你可以通过调用 `memory.grow`
    方法来增加线性内存的大小。虽然不需要设置最大值来增加内存，但传入最大值会告诉浏览器为增长的内存预留更多空间，因为很可能会调用 `grow` 方法。如果你尝试将线性内存增长到超过传入的最大值，应用程序将抛出错误。创建内存对象后，我们通过
    `importObject` 中的 `env.mem` 3 将其传递给 WebAssembly 模块。JavaScript 在实例化时将 `importObject`
    传入模块 4。
- en: Pointers
  id: totrans-38
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 指针
- en: A *pointer* is a variable that references a location in memory. Pointers have
    a variety of applications in computer science, but in this context, we’ll use
    them to point to data structures in linear memory. [Figure 6-3](#figure6-3) shows
    a pointer pointing to memory location 5, which has a value of 99.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: '*指针* 是一个引用内存中某个位置的变量。指针在计算机科学中有多种应用，但在这个上下文中，我们将用它们来指向线性内存中的数据结构。[图 6-3](#figure6-3)
    显示了一个指针指向内存位置 5，该位置的值为 99。'
- en: '![f06003](Images/f06003.png)'
  id: totrans-40
  prefs: []
  type: TYPE_IMG
  zh: '![f06003](Images/f06003.png)'
- en: 'Figure 6-3: Pointer to the fifth byte in memory'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6-3：指向内存中第五个字节的指针
- en: WebAssembly pointers behave differently from those you might be familiar with
    in C or C++ that can point to local variables or variables on the heap. The C
    code in [Listing 6-6](#listing6-6) creates a pointer called `ptr` that points
    to the address of a local variable `x`.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: WebAssembly 的指针行为与 C 或 C++ 中你可能熟悉的指针不同，后者可以指向局部变量或堆上的变量。[Listing 6-6](#listing6-6)
    中的 C 代码创建了一个名为 `ptr` 的指针，指向局部变量 `x` 的地址。
- en: '[PRE5]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Listing 6-6: Example of setting pointer values in C'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 'Listing 6-6: 在 C 中设置指针值的示例'
- en: The pointer `ptr` is set to the address of the `x` variable, which is a local
    variable that has an address on the stack. WebAssembly doesn’t have a distinct
    pointer type, such as C’s `int*` integer pointer type. WebAssembly’s linear memory
    is a large array of data. When you represent a pointer in WAT, you must put the
    data in the linear memory; the pointer is then an `i32` index to that data. The
    variable `x` in [Listing 6-6](#listing6-6) receives an address in linear memory
    when compiling the program to WebAssembly. Unlike in C, WAT cannot create a pointer
    to a local or global variable. To get the C kind of pointer functionality in WebAssembly,
    you can set a global variable to a specific location in linear memory and use
    that global variable to set or retrieve the value stored in WebAssembly linear
    memory, as shown in [Listing 6-7](#listing6-7).
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 指针`ptr`被设置为`x`变量的地址，`x`是一个局部变量，它在栈上有一个地址。WebAssembly没有像C语言中的`int*`整数指针类型那样的独立指针类型。WebAssembly的线性内存是一个大型数据数组。当你在WAT中表示指针时，你必须将数据放入线性内存中；然后，指针就是指向该数据的`i32`索引。编译程序为WebAssembly时，[Listing
    6-6](#listing6-6)中的变量`x`会在线性内存中接收一个地址。与C语言不同，WAT不能创建指向局部或全局变量的指针。要在WebAssembly中实现类似C语言的指针功能，你可以将一个全局变量设置为线性内存中的特定位置，并使用该全局变量来设置或检索存储在WebAssembly线性内存中的值，如[Listing
    6-7](#listing6-7)所示。
- en: '**pointer.wat**'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: '**pointer.wat**'
- en: '[PRE6]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Listing 6-7: Simulating pointers in WAT'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 'Listing 6-7: 在WAT中模拟指针'
- en: This module creates a single page of linear memory 1 and a global `$pointer`
    2 that points to the memory location `128`. We create a function `$init` 3 that
    sets the value of the memory location pointed to by `$pointer` to `99` using the
    `(i32.store``)` 4 expression. The first parameter passed to `(i32.store``)` 5
    is the location in memory where the value is stored, and the second parameter
    6 is the value you want to store. To retrieve the value from this pointer location,
    you use the `i32.load` 8 expression passing in the memory location you want to
    retrieve. We create a function `"get_ptr"` 7 to retrieve this value. Then the
    `(start` `$init)` 9 statement calls `$init` 3 as a module initialization function.
    The `start` statement declares a given function to be the initialization function
    for the module. This function will automatically execute when the module is instantiated.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 该模块创建了一页线性内存1和一个指向内存位置`128`的全局`$pointer`2。我们创建了一个函数`$init`3，该函数使用`(i32.store)`4表达式将`$pointer`指向的内存位置的值设置为`99`。传递给`(i32.store)`5的第一个参数是存储值的内存位置，第二个参数6是你想要存储的值。要从这个指针位置检索值，你可以使用`i32.load`8表达式，并传入你要检索的内存位置。我们创建了一个函数`"get_ptr"`7来检索这个值。然后，`(start`
    `$init)`9语句将`$init`3作为模块初始化函数进行调用。`start`语句声明一个函数作为模块的初始化函数。这个函数将在模块实例化时自动执行。
- en: 'Once you’ve compiled the *pointer.wasm* file and executed it with `node`, you
    should see the following output:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你编译了*pointer.wasm*文件并使用`node`执行它，你应该会看到以下输出：
- en: '[PRE7]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: JavaScript Memory Object
  id: totrans-52
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: JavaScript内存对象
- en: Now that we have some idea of how linear memory works, we’ll create a WebAssembly
    memory object, initialize the data from within a WebAssembly module, and then
    access that data from JavaScript. When you’re working with linear memory, there’s
    a good chance that you’ll want to access it from WebAssembly and the embedding
    environment. In this case, the embedding environment is JavaScript, so we’ll define
    the linear memory there to have access to it before the WebAssembly module is
    initialized. This WAT module is similar to [Listing 6-7](#listing6-7) but will
    be importing linear memory from JavaScript.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们对线性内存的工作原理有了一些了解，我们将创建一个WebAssembly内存对象，从WebAssembly模块内部初始化数据，然后从JavaScript访问这些数据。当你在处理线性内存时，很可能你希望从WebAssembly和嵌入环境中访问它。在这种情况下，嵌入环境是JavaScript，因此我们将在JavaScript中定义线性内存，以便在WebAssembly模块初始化之前访问它。这个WAT模块类似于[Listing
    6-7](#listing6-7)，但它将从JavaScript导入线性内存。
- en: Creating the WebAssembly Memory Object
  id: totrans-54
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建WebAssembly内存对象
- en: Create a file named *store_data.wat* and add the code in [Listing 6-8](#listing6-8)
    to it.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个名为*store_data.wat*的文件，并将[Listing 6-8](#listing6-8)中的代码添加到该文件中。
- en: '**store_data.wat**'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: '**store_data.wat**'
- en: '[PRE8]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Listing 6-8: Creating a linear memory object in WebAssembly'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 'Listing 6-8: 在WebAssembly中创建线性内存对象'
- en: The module in [Listing 6-8](#listing6-8) imports its linear memory 1 from the
    JavaScript embedding environment, which we’ll define in a moment. From JavaScript
    it imports the address of the data we’ll load in the global variable `$data_addr`
    2. It also imports `$data_count` 3, which contains the number of `i32` integers
    we’ll store when the module initializes. The `$store_data` 4 function takes in
    an index and a value, and sets the data location (`$data_addr` + `$index` * 4)
    to `$value` (we multiply by 4 because the `i32` type is four bytes). Using `$data_addr`,
    an imported global variable, allows the JavaScript to decide the location in the
    memory module to store these values.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: '[Listing 6-8](#listing6-8)中的模块从JavaScript嵌入环境中导入其线性内存1，我们稍后将定义它。它从JavaScript导入我们将加载到全局变量`$data_addr`
    2中的数据地址。它还导入了`$data_count` 3，该变量包含在模块初始化时我们将存储的`i32`整数的数量。`$store_data` 4函数接收一个索引和一个值，并将数据位置（`$data_addr`
    + `$index` * 4）设置为`$value`（我们乘以4是因为`i32`类型占用四个字节）。通过使用`$data_addr`，一个导入的全局变量，允许JavaScript决定存储这些值的内存模块位置。'
- en: As in [Listing 6-6](#listing6-6), the `$init` 5 function executes on module
    initialization because of the `(start` `$init)` a statement. Unlike the prior
    `$init` function, this function initializes the data in a loop 6. A loop can be
    a useful way to initialize data in certain parts of linear memory to the same
    value or some value that might be calculated in the loop. This loop sets several
    32-bit integers based on the `$data_count` 8 global variable that the module imports
    from JavaScript. When this `loop` calls `$store_data` 7, it passes in an index
    that is the number of times the `loop` has completed and a value that is `$index`
    * 5\. I chose the value `$index` * 5 so when we display the data, you’ll see the
    data values counting up by 5.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 如[Listing 6-6](#listing6-6)所示，`$init` 5函数在模块初始化时执行，因为存在`(start` `$init)`语句。与之前的`$init`函数不同，这个函数在一个循环6中初始化数据。循环可以是初始化线性内存中特定部分数据的有用方法，使其设置为相同的值，或某些可能在循环中计算的值。这个循环根据模块从JavaScript导入的`$data_count`
    8全局变量设置了几个32位整数。当这个`loop`调用`$store_data` 7时，它传入一个索引，表示`loop`已经完成的次数，以及一个值，值为`$index`
    * 5。我选择了`$index` * 5的值，这样当我们显示数据时，你会看到数据值以5为增量递增。
- en: After the `loop`, we add one more call to `$store_data` 9 to set the first data
    value in the array to `1`. If we don’t initialize it with a value, the memory
    buffer begins with all data set to `0`. Because the `loop` sets the first data
    value to `0`, it wouldn’t be clear where the set data begins when we look at the
    data in JavaScript. Setting it to `1` makes the beginning of the data set more
    apparent when we display it from the JavaScript in the next section.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 在`loop`之后，我们再调用一次`$store_data` 9，将数组中的第一个数据值设置为`1`。如果不初始化它，内存缓冲区将以所有数据初始化为`0`。因为`loop`将第一个数据值设置为`0`，所以当我们在JavaScript中查看数据时，无法清楚地看到设置的数据从何处开始。将其设置为`1`，使得在下一节中我们从JavaScript显示数据时，数据集的开始更加明显。
- en: After you’ve finished creating the *store_data.wat* file, compile it using `wat2wasm`
    to generate a *store_data.wasm* file.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 在完成创建*store_data.wat*文件后，使用`wat2wasm`编译它，生成*store_data.wasm*文件。
- en: Logging to the Console with Colors
  id: totrans-63
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 在控制台上使用颜色记录
- en: Before writing the *store_data.js* portion, let’s briefly look at a node module
    called *colors* that allows you to log lines to the console using your choice
    of colors. In later sections, we’ll use this package to make it easier to see
    different results in our output data. To install colors, use the `npm` command,
    as shown in [Listing 6-9](#listing6-9).
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 在编写*store_data.js*部分之前，让我们简要了解一个名为*colors*的Node模块，它允许你使用自选颜色将日志行输出到控制台。在后续部分，我们将使用这个包来更方便地查看输出数据中的不同结果。要安装colors，请使用`npm`命令，如[Listing
    6-9](#listing6-9)所示。
- en: '[PRE9]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Listing 6-9: Using `npm` to install the colors module'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 'Listing 6-9: 使用`npm`安装colors模块'
- en: Now we can require our app to use it, which allows us to modify the string type
    in JavaScript to include attributes that set colors, bold text, and several other
    features. Create a file named *colors.js* and add the code in [Listing 6-10](#listing6-10).
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以引入我们的应用程序来使用它，这使我们能够修改JavaScript中的字符串类型，添加设置颜色、加粗文本及其他一些功能的属性。创建一个名为*colors.js*的文件，并添加[Listing
    6-10](#listing6-10)中的代码。
- en: '**colors.js**'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: '**colors.js**'
- en: '[PRE10]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Listing 6-10: Log to console in color'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 'Listing 6-10: 用颜色将日志输出到控制台'
- en: When you run *colors.js* using `node`, as shown in [Listing 6-11](#listing6-11),
    the logged output will appear with the colors we specified.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 当你使用`node`运行*colors.js*时，如[Listing 6-11](#listing6-11)所示，日志输出将以我们指定的颜色显示。
- en: '[PRE11]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Listing 6-11: Run *color.js* and log with colors to the console.'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 'Listing 6-11: 运行*color.js*并将颜色日志输出到控制台。'
- en: You should now see the output in [Listing 6-12](#listing6-12) with the first
    line in red and the second in blue.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你应该能看到[清单 6-12](#listing6-12)中的输出，第一行是红色，第二行是蓝色。
- en: '[PRE12]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Listing 6-12: The colors module applied'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 清单 6-12：应用颜色模块
- en: We’ll use the colors module in future apps to improve the output’s appearance
    in the console. In the book, the red output will be black but in bold. Let’s move
    forward by creating a *store_data.js* file in the next section.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在未来的应用程序中使用颜色模块，以改善控制台中输出的外观。在书中，红色的输出会变为黑色，但会加粗。接下来，让我们继续创建一个 *store_data.js*
    文件。
- en: Creating the JavaScript in store_data.js
  id: totrans-78
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 在 store_data.js 中创建 JavaScript
- en: Now we need a *store_data.js* JavaScript file to execute the *store_data.wasm*
    module. We create that JavaScript file using [Listing 6-13](#listing6-13).
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们需要一个 *store_data.js* JavaScript 文件来执行 *store_data.wasm* 模块。我们使用[清单 6-13](#listing6-13)来创建这个
    JavaScript 文件。
- en: '**store_data.js (part 1 of 2)**'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: '**store_data.js（第 1 部分 / 共 2 部分）**'
- en: '[PRE13]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Listing 6-13: A WebAssembly linear memory buffer and `i``mport``Object` with
    global imports'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 清单 6-13：一个 WebAssembly 线性内存缓冲区和带有全局导入的 `importObject`
- en: We create three constants, the first of which creates a new `WebAssembly.Memory`
    1 object that we’ll use when we initialize the WebAssembly module. The constant
    `mem_i32` 2 provides a 32-bit integer view into the memory buffer. It’s crucial
    to keep in mind that this isn’t a copy of the data in the buffer but instead is
    a specific way to view that buffer as an array of 32-bit unsigned integers. When
    we change the values in the memory buffer from inside the WebAssembly module,
    we can use this `mem_i32` view to look at the changes to those values. The constant
    `data_addr` 3 is the byte location of the data we set in the WebAssembly module.
    This location is the *byte index m*,not the 32-bit integer array number.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建了三个常量，第一个常量创建了一个新的 `WebAssembly.Memory` 1 对象，我们将在初始化 WebAssembly 模块时使用它。常量
    `mem_i32` 2 提供了一个 32 位整数视图，用于查看内存缓冲区。这一点很重要，必须记住它不是缓冲区数据的副本，而是以特定的方式将缓冲区视为一个 32
    位无符号整数数组。当我们从 WebAssembly 模块内部更改内存缓冲区中的值时，我们可以使用这个 `mem_i32` 视图查看这些值的变化。常量 `data_addr`
    3 是我们在 WebAssembly 模块中设置的数据的字节位置。这个位置是 *字节索引 m*，而不是 32 位整数数组的编号。
- en: Because a 32-bit integer is four bytes, we need a starting data index that is
    the `data_addr` constant divided by 4\. We set that value in `data_i32_index`
    4. Then we have the number of 32-bit integer values set in the module defined
    by `const data_count` 5. The last `const` in this section of code is the `importObject`
    6. The `importObject` contains three imported data objects for the WebAssembly
    module.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 因为一个 32 位整数占四个字节，我们需要一个起始数据索引，它是 `data_addr` 常量除以 4。我们将这个值设置为 `data_i32_index`
    4。然后，我们定义了由 `const data_count` 5 指定的模块中设置的 32 位整数值的数量。本段代码中的最后一个 `const` 是 `importObject`
    6。`importObject` 包含三个导入的数据对象，用于 WebAssembly 模块。
- en: The final portion of the JavaScript in [Listing 6-14](#listing6-14) uses an
    IIFE to instantiate the WebAssembly module and output the values in linear memory
    to the console.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: '[清单 6-14](#listing6-14) 中的 JavaScript 最后一部分使用了 IIFE 来实例化 WebAssembly 模块并将线性内存中的值输出到控制台。'
- en: '**store_data.js (part 2 of 2)**'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: '**store_data.js（第 2 部分 / 共 2 部分）**'
- en: '[PRE14]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Listing 6-14: Outputting the data values inside linear memory after the IIFE
    instantiates the WebAssembly module'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 清单 6-14：在 IIFE 实例化 WebAssembly 模块后输出线性内存中的数据值
- en: This final portion of the JavaScript instantiates the *store_data.wasm* 1 module,
    passing in the `importObject` we created in [Listing 6-13](#listing6-13). After
    initializing the WebAssembly module, the data in the memory buffer will change
    because the `$init` function within the WAT code runs during the initialization.
    We then loop 2 over the `mem_i32` array starting at the first address in the memory
    buffer and displaying four integers after the data is set. This loop displays
    the value in `mem_i32` in the browser by logging it to the console in red 3 if
    the value isn’t `0` and in the default console color 4 if it is.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 这段 JavaScript 代码的最后部分实例化了 *store_data.wasm* 模块，并传入了我们在[清单 6-13](#listing6-13)中创建的
    `importObject`。初始化 WebAssembly 模块后，内存缓冲区中的数据会发生变化，因为 WAT 代码中的 `$init` 函数会在初始化过程中运行。然后，我们开始循环
    2 遍历 `mem_i32` 数组，从内存缓冲区的第一个地址开始，并在数据设置后显示四个整数。如果值不为 `0`，则在浏览器中通过将其日志显示为红色 3 来展示
    `mem_i32` 中的值；如果值为 `0`，则以默认的控制台颜色 4 显示。
- en: Use `node` to run *store_data.js*; you should see the output in [Listing 6-15](#listing6-15)
    logged to the console.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `node` 运行 *store_data.js*；你应该可以在控制台中看到[清单 6-15](#listing6-15)中的输出日志。
- en: '[PRE15]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Listing 6-15: Data output'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 清单 6-15：数据输出
- en: The first data element that was set by the WebAssembly module is `data[8]`,
    which is where the red output begins. The value `8` is the value in the `data_i32_index`
    constant, which is one fourth the value in `data_addr`. There are 16 integers
    set in the code, because we’ve set the `const data_count` to a value of `16`.
    In the data in [Listing 6-15](#listing6-15), all data elements that are `0` weren’t
    set in the WebAssembly module. You can see that the first eight numbers as well
    as the last four are `0`, and they all appear in the default console color.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: WebAssembly 模块设置的第一个数据元素是`data[8]`，这就是红色输出开始的位置。值`8`是`data_i32_index`常量中的值，是`data_addr`值的四分之一。在代码中设置了16个整数，因为我们已将`const
    data_count`设置为16。在[清单 6-15](#listing6-15)中的数据里，所有值为`0`的数据元素没有在 WebAssembly 模块中被设置。你可以看到，前八个数字以及最后四个数字都是`0`，它们都以默认控制台颜色显示。
- en: Collision Detection
  id: totrans-94
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 碰撞检测
- en: Previously, we created the memory buffer object inside JavaScript, but we initialized
    it from the WebAssembly module. This time, we’ll initialize the memory buffer
    inside JavaScript with values generated in the JavaScript. We’ll also create more
    interesting data structures that will handle our collision detection data. When
    modifying the data in the WebAssembly memory buffer, we want to group the data
    into structures to make it manageable. We’ll create a set of random circle definitions
    in JavaScript, defined with an x- and y-coordinate, and a radius. The JavaScript
    will then set those values in the WebAssembly memory buffer. To organize objects
    in linear memory, you use a combination of a base address, a stride, and an offset.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 之前，我们在 JavaScript 中创建了内存缓冲区对象，但它是从 WebAssembly 模块初始化的。这一次，我们将在 JavaScript 中初始化内存缓冲区，并使用在
    JavaScript 中生成的值。我们还将创建更多有趣的数据结构来处理我们的碰撞检测数据。当修改 WebAssembly 内存缓冲区中的数据时，我们希望将数据分组到结构中，以便更易于管理。我们将在
    JavaScript 中创建一组随机的圆形定义，每个定义都包含一个 x 和 y 坐标以及半径。然后，JavaScript 将这些值设置到 WebAssembly
    内存缓冲区中。为了组织线性内存中的对象，你需要使用基地址、跨度和偏移量的组合。
- en: Base Address, Stride, and Offset
  id: totrans-96
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 基地址、跨度和偏移量
- en: When working with linear memory inside our WebAssembly module, we need to understand
    our data structures at a low level. In our JavaScript, we work with the data in
    linear memory as a JavaScript typed array. Inside the WebAssembly module, linear
    memory is more like a memory heap, or a large array of bytes. When we want to
    create an array of data structures, we need to know the *starting address* (base
    address) of that array, the *stride*(distance in bytes between each structure),
    and the *offset*of any structure’s attributes (how far into a structure can we
    find our attribute).
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 在 WebAssembly 模块内处理线性内存时，我们需要在低级别理解我们的数据结构。在我们的 JavaScript 中，我们将线性内存中的数据当作 JavaScript
    类型化数组来处理。在 WebAssembly 模块内部，线性内存更像是一个内存堆或一个大型字节数组。当我们想要创建一个数据结构数组时，我们需要知道该数组的*起始地址*（基地址）、*跨度*（每个结构之间的字节距离）以及任何结构属性的*偏移量*（我们在结构中找到属性的位置）。
- en: 'We’ll work with a structure in our linear memory that has four attributes:
    an x- and y-coordinate, a radius, and a hit flag. We’ll set the stride as a *unit
    stride*, as shown in [Figure 6-4](#figure6-4), which means that the distance between
    each structure in our array matches the size of the structure.'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在线性内存中处理一个有四个属性的结构：x 和 y 坐标、半径和碰撞标志。我们将跨度设置为*单位跨度*，如[图 6-4](#figure6-4)所示，这意味着数组中每个结构之间的距离与结构的大小匹配。
- en: '![f06004](Images/f06004.png)'
  id: totrans-99
  prefs: []
  type: TYPE_IMG
  zh: '![f06004](Images/f06004.png)'
- en: 'Figure 6-4: Setting a unit stride'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6-4：设置单位跨度
- en: To get the memory address of the specific data structure we want to access,
    we multiply the structure’s index by the stride and add the base address. The
    *base address* is the starting address of our array of structures.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 为了获取我们想要访问的特定数据结构的内存地址，我们将结构的索引乘以跨度并加上基地址。*基地址*是我们结构数组的起始地址。
- en: As an alternative to unit stride, you could pad your stride. If a developer
    decided to align their structure addresses to power-of-two, they might add unused
    bytes (called *padding*) to the end of their structures. For example, if we wanted
    our structure to align with 16-byte addresses, we could add four bytes of padding
    to the end of our structure, giving it a stride of 16, as shown in [Figure 6-5](#figure6-5).
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 作为单位跨度的替代方案，你可以给跨度添加填充。如果开发人员决定将他们的结构地址对齐到 2 的幂次方，他们可能会在结构末尾添加未使用的字节（称为*填充*）。例如，如果我们希望我们的结构与
    16 字节地址对齐，我们可以在结构末尾添加四个字节的填充，使其跨度为 16，如[图 6-5](#figure6-5)所示。
- en: However, we have no need for padding in this example. Each attribute of our
    data structure has an offset. For example, say we have two 32-bit integer attributes,
    `x` and `y`, that are the first two attributes in the data structure, respectively.
    The first attribute, `x`, is at the beginning of the data structure and so has
    an offset of `0`. Because the `x` attribute is a 32-bit integer, it takes up the
    first four bytes of the data structure. That means the `y` offset begins on the
    fifth byte with an offset of `4` (bytes 0, 1, 2, and 3). Using a base address
    (the starting address of our data structure), stride, and offset for each attribute,
    we can construct an array of data structures.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在这个例子中我们不需要填充。我们数据结构中的每个属性都有一个偏移量。例如，假设我们有两个 32 位整数属性，`x` 和 `y`，它们分别是数据结构中的前两个属性。第一个属性
    `x` 位于数据结构的开头，因此其偏移量为 `0`。由于 `x` 属性是 32 位整数，它占据了数据结构的前四个字节。这意味着 `y` 的偏移量从第五个字节开始，偏移量为
    `4`（字节 0、1、2、3）。通过使用基本地址（我们数据结构的起始地址）、步幅和每个属性的偏移量，我们可以构建一个数据结构数组。
- en: '![f06005](Images/f06005.png)'
  id: totrans-104
  prefs: []
  type: TYPE_IMG
  zh: '![f06005](Images/f06005.png)'
- en: 'Figure 6-5: Padding a stride'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 'Figure 6-5: 填充步幅'
- en: Loading Data Structures from JavaScript
  id: totrans-106
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 从 JavaScript 加载数据结构
- en: Let’s start by creating the JavaScript file for a new example app named *data_structures.js*.
    In this app, we’ll create data structures that represent circles in memory. Later,
    we’ll perform a collision detection check between those circles. Add the code
    in [Listing 6-16](#listing6-16) to *data_structures.js*.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始创建一个名为 *data_structures.js* 的新示例应用程序的 JavaScript 文件。在这个应用中，我们将创建表示内存中圆形的结构体。稍后，我们将对这些圆形进行碰撞检测。将
    [Listing 6-16](#listing6-16) 中的代码添加到 *data_structures.js* 中。
- en: '**data_structures.js (part 1 of 3)**'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: '**data_structures.js（第 1 部分，共 3 部分）**'
- en: '[PRE16]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Listing 6-16: Setting the constants to define the structure of the collision
    detection program'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 'Listing 6-16: 设置常量以定义碰撞检测程序的结构'
- en: First, we create a series of `const` values used to create structures in the
    WebAssembly memory buffer. As in [Listing 6-16](#listing6-16), this code creates
    a single 64KB page of WebAssembly memory 1 and a 32-bit unsigned integer view
    into that data. The `obj_base_addr` constant sets the base address of the data
    structures to `0`, the very first byte of memory in the page.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们创建一系列 `const` 值，用于在 WebAssembly 内存缓冲区中创建结构体。正如 [Listing 6-16](#listing6-16)
    中的代码，这段代码创建了一个单一的 64KB WebAssembly 内存页面 1，并通过 32 位无符号整数视图来访问该数据。`obj_base_addr`
    常量将数据结构的基本地址设置为 `0`，即页面内存的第一个字节。
- en: We set the `obj_count` 2 `const` to the number of structures set in this code.
    The `obj_stride` 3 constant holds the number of bytes in the structure. We set
    this to `16` because we have four 32-bit integers in this structure, which is
    16 bytes. The next group of `const` declarations contains the attribute offsets.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将`obj_count` 2 `const` 设置为此代码中结构体的数量。`obj_stride` 3 常量保存结构体的字节数。我们将其设置为`16`，因为这个结构体包含四个
    32 位整数，合计 16 字节。接下来的 `const` 声明组包含了属性的偏移量。
- en: The `x_offset` 4 is the offset of `x` from the start of the structure, so is
    the number of bytes into each structure in the `x` value location. The `y_offset`
    5 is the number of bytes into the structure in the `y` value location, and has
    a value of `4` because the `x` value is a 32-bit integer, pushing the `y` value
    into the fifth byte in the structure. We then set the offset for the `radius`
    6 attribute and `collision` 7 attribute.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: '`x_offset` 4 是 `x` 从结构体开始位置的偏移量，即 `x` 值位置在每个结构体中的字节数。`y_offset` 5 是结构体中 `y`
    值位置的字节数，其值为 `4`，因为 `x` 值是 32 位整数，使得 `y` 值位于结构体的第五个字节。然后我们设置了 `radius` 6 属性和 `collision`
    7 属性的偏移量。'
- en: We calculate the integer index and stride by dividing the byte address by 4
    and the stride by 4\. The reason is that the byte address and stride are the number
    of bytes, and the integer index is 32-bit integers (4 bytes). We also need to
    find the indexes into the integer array, which we calculate by dividing the byte
    indexes by 4 6 as well. The `importObject` 7 has been modified to include the
    new `const` values we’ve added.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过将字节地址除以 4 和步幅除以 4 来计算整数索引和步幅。原因是字节地址和步幅是字节数，而整数索引是 32 位整数（4 字节）。我们还需要找到整数数组中的索引，这是通过将字节索引除以
    4 来计算的。`importObject` 7 已被修改以包括我们添加的新 `const` 值。
- en: With the constants defined, we’ll create a series of randomly sized circles
    for the program to use. As mentioned earlier, a circle is defined by x- and y-coordinates
    and a radius. We’ll randomly define the circles’ x- and y-coordinates with values
    from 0 to 99 and a radius that is between 1 and 11\. The code in [Listing 6-17](#listing6-17)
    loops over the memory object, setting values in the memory buffer to random values
    for each of the structures.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 在定义了常量之后，我们将创建一系列随机大小的圆形供程序使用。如前所述，圆形由 x 和 y 坐标以及半径定义。我们将随机定义圆形的 x 和 y 坐标，值从
    0 到 99，半径在 1 到 11 之间。[列表 6-17](#listing6-17) 中的代码循环遍历内存对象，为每个结构设置随机值。
- en: '**data_structures.js (part 2 of 3)**'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: '**data_structures.js（第 2 部分，共 3 部分）**'
- en: '[PRE17]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Listing 6-17: Initializing the circles with random x- and y-coordinates and
    a radius'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 6-17：使用随机的 x 和 y 坐标以及半径初始化圆形
- en: The loop gets an index for each of the structures 1 for the collision detection
    circles. The `x`, `y`, and radius `r` values 2 are set to random values. Those
    random values are then used to set the memory values 3 based on the object index
    and the attribute offsets.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 循环为每个结构获取一个索引，用于碰撞检测圆形。`x`、`y` 和半径 `r` 的值被设置为随机值。这些随机值随后用于基于对象索引和属性偏移设置内存值。
- en: Displaying the Results
  id: totrans-120
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 显示结果
- en: Next, we need to instantiate the *data_structures.wasm* module, which runs the
    `$init` function, which runs collision detection between each of the circles we
    randomly generated in this data test. [Listing 6-18](#listing6-18) shows the code
    added to *data_structures.js*.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要实例化 *data_structures.wasm* 模块，它运行 `$init` 函数，执行我们在此数据测试中随机生成的每个圆形之间的碰撞检测。[列表
    6-18](#listing6-18) 显示了添加到 *data_structures.js* 的代码。
- en: '**data_structures.js (part 3 of 3)**'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: '**data_structures.js（第 3 部分，共 3 部分）**'
- en: '[PRE18]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Listing 6-18: After WebAssembly runs, the code loops over linear memory looking
    for circle collisions.'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 6-18：WebAssembly 运行后，代码循环遍历线性内存，查找圆形碰撞。
- en: This IIFE function instantiates the WebAssembly module 1 and then loops over
    the objects in the `mem_i32` array 2. This loop gets an index for the structure
    using the stride, the index, and the base index value 3. We then use this calculated
    index to get the `x`, `y`, radius, and collision values from the `mem_i32` 4 array.
    These values are logged to the console in red 5 if there was a collision or green
    6 if there wasn’t.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 这个 IIFE 函数实例化 WebAssembly 模块 1，并循环遍历 `mem_i32` 数组中的对象 2。这个循环使用步幅、索引和基索引值 3 获取结构的索引。然后，我们使用计算出的索引从
    `mem_i32` 4 数组中获取 `x`、`y`、半径和碰撞值。如果发生碰撞，这些值会以红色 5 显示在控制台上，如果没有碰撞，则以绿色 6 显示。
- en: We now have JavaScript that loads a series of structures that define circles
    with x- and y-coordinates randomly chosen with values between 0 and 100\. Each
    circle also has a radius with a value randomly chosen between 1 and 10\. The WebAssembly
    memory buffer is initialized with these values. The JavaScript will set the appropriate
    offset and stride values in the `importObject`. In addition to the `x`, `y`, and
    radius in each structure, there are four bytes set aside to hold a collision value.
    This value is `1` if the circle collides with another circle and `0` if it doesn’t.
    The WebAssembly module’s initialization `(start``)` function calculates the collisions.
    Once the WebAssembly module initializes, the console displays the results of this
    collision check. At this point, we’ve not yet defined the WebAssembly module.
    Let’s do that next.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在有了加载一系列定义圆形的 JavaScript 代码，每个圆形的 x 和 y 坐标是随机选择的，值在 0 到 100 之间。每个圆形还有一个半径，值在
    1 到 10 之间随机选择。WebAssembly 内存缓冲区已使用这些值进行初始化。JavaScript 将在 `importObject` 中设置适当的偏移量和步幅值。除了每个结构中的
    `x`、`y` 和半径外，还会留出四个字节来存储碰撞值。如果圆形与另一个圆形发生碰撞，值为 `1`，如果没有碰撞，则值为 `0`。WebAssembly 模块的初始化
    `(start)` 函数计算碰撞。WebAssembly 模块初始化完成后，控制台显示此碰撞检查的结果。此时，我们还没有定义 WebAssembly 模块。接下来我们将定义它。
- en: Collision Detection Function
  id: totrans-127
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 碰撞检测函数
- en: In other sections, we’ve defined the WAT code before the JavaScript. In this
    section, the JavaScript initializes the values that define the circles in the
    array of structures. For that reason, we’ll be writing the JavaScript first in
    this section. When you’re doing collision detection between two circles, you use
    the Pythagorean theorem to determine whether the distance between the centers
    of your circles is greater than the sum of the circles’ radii. The WAT code in
    this section loops over each of the circles we’ve defined in the WebAssembly memory,
    comparing it to every other circle to see whether they collide. The details of
    collision detection aren’t the focus of this section, so we won’t go into it too
    deeply. It’s simply a means to demonstrate how you can separate your data into
    structures and use that data to perform computations with your WAT code.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 在其他部分中，我们在 JavaScript 之前定义了 WAT 代码。在这一部分中，JavaScript 初始化定义圆形的值，这些值存储在结构体数组中。因此，我们将在本节中首先编写
    JavaScript。当你在两个圆之间进行碰撞检测时，你会使用毕达哥拉斯定理来判断圆心之间的距离是否大于圆的半径和。本节中的 WAT 代码循环遍历我们在 WebAssembly
    内存中定义的每个圆，将其与其他圆进行比较，查看它们是否发生碰撞。碰撞检测的细节不是本节的重点，因此我们不会过多深入探讨。它仅仅是演示如何将数据分离到结构体中，并使用这些数据与
    WAT 代码进行计算。
- en: The first portion of the WAT code defines the imports from the JavaScript. [Listing
    6-19](#listing6-19) shows the beginning of the WAT module.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: WAT 代码的第一部分定义了从 JavaScript 导入的内容。[Listing 6-19](#listing6-19) 显示了 WAT 模块的开头。
- en: '**data_structures.wat (part 1 of 6)**'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: '**data_structures.wat（第 1 部分，共 6 部分）**'
- en: '[PRE19]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Listing 6-19: Importing global variables that define the data structure'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: Listing 6-19：导入定义数据结构的全局变量
- en: The global variables passed into the WebAssembly module define the layout of
    the linear memory and the data structures within it. The `$obj_base_addr` 1 global
    variable is the location in memory where the circle structures are defined. The
    `$obj_count` 2 global variable is the number of circles defined in linear memory.
    The `$obj_stride` 3 global variable is the number of bytes between each of the
    circle definitions. Then we import values for each of the attributes. The `$x_offset`
    4, `$y_offset` 5, `$radius_offset` 6, and `$collision_offset` 7 are the number
    of bytes between the start of the object’s `x`, `y`, radius, and collision flag
    values. These must be set inside this module.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 传递给 WebAssembly 模块的全局变量定义了线性内存的布局和其中的数据结构。`$obj_base_addr` 1 个全局变量是定义圆形结构体在内存中的位置。`$obj_count`
    2 个全局变量是在线性内存中定义的圆的数量。`$obj_stride` 3 个全局变量是每个圆形定义之间的字节数。接下来，我们导入每个属性的值。`$x_offset`
    4、`$y_offset` 5、`$radius_offset` 6 和 `$collision_offset` 7 是对象的 `x`、`y`、半径和碰撞标志值的字节偏移量。必须在该模块内设置这些值。
- en: Next, we’ll define the `$collision_check` function. The details of how this
    function works are only valuable if you’re interested in how circle collision
    detection works. But as an overview, it uses the Pythagorean theorem to determine
    whether the distance between two circles is less than the sum of the circle’s
    radii. To briefly explain, let’s label the radius of the first circle R[1], the
    radius of the second circle R[2], and the distance between the circles D, as shown
    in [Figure 6-6](#figure6-6). No collision occurs if R[1] + R[2] is less than D.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将定义 `$collision_check` 函数。这个函数的工作原理的细节只有在你对圆形碰撞检测的工作方式感兴趣时才有价值。简而言之，它使用毕达哥拉斯定理来判断两个圆之间的距离是否小于圆的半径和。简要解释一下，假设第一个圆的半径为
    R[1]，第二个圆的半径为 R[2]，圆之间的距离为 D，如[图 6-6](#figure6-6)所示。如果 R[1] + R[2] 小于 D，则不会发生碰撞。
- en: '![f06007](Images/f06007.png)'
  id: totrans-135
  prefs: []
  type: TYPE_IMG
  zh: '![f06007](Images/f06007.png)'
- en: 'Figure 6-6: There is no collision if R[1] + R[2] is less than the distance
    between the circles.'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6-6：如果 R[1] + R[2] 小于圆之间的距离，则不会发生碰撞。
- en: If the distance is less than R[1] + R[2], we have a collision, as shown in [Figure
    6-7](#figure6-7).
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 如果距离小于 R[1] + R[2]，则发生碰撞，如[图 6-7](#figure6-7)所示。
- en: '![f06008](Images/f06008.png)'
  id: totrans-138
  prefs: []
  type: TYPE_IMG
  zh: '![f06008](Images/f06008.png)'
- en: 'Figure 6-7: R[1] + R[2] is greater than the distance between the circles.'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6-7：R[1] + R[2] 大于圆之间的距离。
- en: '[Listing 6-20](#listing6-20) shows the code for the `$collision_check` function.'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: '[Listing 6-20](#listing6-20) 展示了 `$collision_check` 函数的代码。'
- en: '**data_structures.wat (part 2 of 6)**'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: '**data_structures.wat（第 2 部分，共 6 部分）**'
- en: '[PRE20]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Listing 6-20: A WebAssembly collision detection function'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: Listing 6-20：一个 WebAssembly 碰撞检测函数
- en: This function takes in the `x`, `y`, and radius attributes of two circles 1
    and then returns `1` if they overlap and `0` if they don’t. It first finds the
    `x` distance between the two circles by subtracting `$x2` from `$x1`. It then
    squares that value and stores it in `$x_diff_sq` 2; then it finds the `y` distance
    between the two circles by subtracting `$y2` from `$y1`. It squares the result
    of that subtraction and stores it in `$y_diff_sq` 3. What we’re building toward
    is the Pythagorean theorem A² + B² = C² 5. In this scenario, `$x_diff_sq` is A²,
    and `$y_diff_sq` is B². The sum of these two values is C², which is compared with
    the sum of the radii squared 4. If radius² is greater than C², the circles overlap
    and the function returns `1`; otherwise, the function returns `0`. The function
    makes this decision using the `i32.gt_u` 6 expression.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 该函数接受两个圆形的`x`、`y`和半径属性 1，然后如果它们重叠则返回`1`，否则返回`0`。它首先通过从`$x2`减去`$x1`来计算两个圆形之间的`x`距离。然后它将该值平方，并存储在`$x_diff_sq`
    2中；接着通过从`$y2`减去`$y1`来计算两个圆形之间的`y`距离。它将这个结果平方并存储在`$y_diff_sq` 3中。我们要建立的是毕达哥拉斯定理
    A² + B² = C² 5。在这个场景中，`$x_diff_sq`是A²，`$y_diff_sq`是B²。这两者的和是C²，然后与半径平方的和 4进行比较。如果半径²大于C²，表示圆形重叠，函数返回`1`；否则，函数返回`0`。该函数使用`i32.gt_u`
    6表达式来做出这个决定。
- en: After the `$collision_check` function, we need a few helper functions. The `$get_attr`
    helper function takes an object base address parameter and an attribute offset
    parameter and returns the value in linear memory at that address location. [Listing
    6-21](#listing6-21) shows that function.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 在`$collision_check`函数之后，我们需要一些辅助函数。`$get_attr`辅助函数接受一个对象基地址参数和一个属性偏移量参数，并返回该地址位置在线性内存中的值。[列表
    6-21](#listing6-21)展示了该函数。
- en: '**data_structures.wat (part 3 of 6)**'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: '**data_structures.wat（第 3 部分，共 6 部分）**'
- en: '[PRE21]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Listing 6-21: Retrieving an object attribute from linear memory'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 6-21：从线性内存中检索对象属性
- en: In the function definition 1, the `$obj_base` parameter is the base address
    for the object, and `$attr_offset` is the offset of the specific attribute we
    want to retrieve. The function adds those values together 2. Then it loads the
    value from that address 3 to return it as a result.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 在函数定义 1 中，`$obj_base`参数是对象的基地址，而`$attr_offset`是我们要检索的特定属性的偏移量。该函数将这两个值相加 2，然后从该地址加载值
    3，并将其作为结果返回。
- en: The next helper function is `$set_collision`, which sets the collision flag
    for two of the circle objects to true. [Listing 6-22](#listing6-22) shows that
    function.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个辅助函数是`$set_collision`，它将两个圆形对象的碰撞标志设置为真。[列表 6-22](#listing6-22)展示了该函数。
- en: '**data_structures.wat (part 4 of 6)**'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: '**data_structures.wat（第 4 部分，共 6 部分）**'
- en: '[PRE22]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Listing 6-22: Set the collision attribute for a given object'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 6-22：为给定对象设置碰撞属性
- en: This function takes in two object base parameters 1 to set the collision flags
    for those objects in memory. It does this by adding `$obj_base_1` to `$collision_offset`
    2 and then setting the value in linear memory at that location to `1` 3. It then
    adds `$obj_base_2` to `$collision_offset` 4 and sets the value at that location
    to `1` 5.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 该函数接受两个对象基地址参数 1，用于设置内存中这些对象的碰撞标志。它通过将`$obj_base_1`加到`$collision_offset` 2，然后将该位置在线性内存中的值设置为`1`
    3。接着，它将`$obj_base_2`加到`$collision_offset` 4，并将该位置的值设置为`1` 5。
- en: Now that we have the other functions defined, we can add the `$init` function
    to the WAT code, as shown in [Listing 6-23](#listing6-23).
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经定义了其他函数，可以将`$init`函数添加到WAT代码中，如[列表 6-23](#listing6-23)所示。
- en: '**data_structures.wat (part 5 of 6)**'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: '**data_structures.wat（第 5 部分，共 6 部分）**'
- en: '[PRE23]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Listing 6-23: A double loop that checks for a collision between every object
    in linear memory'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 6-23：一个双重循环，检查线性内存中每个对象之间的碰撞
- en: The function begins with two groups of local variables. One group contains a
    counter, the address of the objects, and the `x`, `y`, and `r` local variables
    for use with the outer loop 1. The second batch of local variables is for use
    within the inner `loop` 2. The meat of this function is a double loop that compares
    every circle with every other circle in the linear memory looking for circles
    that collide with each other. The beginning of the inner loop checks whether `$i`
    is the same value as `$j` 3. If it is, the code skips the check on this particular
    `$j` object, because otherwise, every circle would collide with itself.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 函数以两组局部变量开始。一组包含计数器、对象地址，以及用于外层循环1的`x`、`y`和`r`局部变量。第二组局部变量用于内层`loop` 2中。该函数的核心是一个双重循环，比较线性内存中每个圆与其他所有圆，查找发生碰撞的圆。内层循环的开始检查`$i`是否与`$j`
    3相等。如果相等，代码跳过对该`$j`对象的检查，否则每个圆都会与自己发生碰撞。
- en: The next line of code calculates the linear memory address of the `i`th object
    4 as `$obj_base_addr` + `$i` * `$obj_stride`. It then sets the value of `$i_obj`
    using the `local.tee` expression in the `(call` `$get_attr)` 5 expression in the
    next line. This call to `$getattr` 5 retrieves the value for `x` from the `i`th
    object and then sets `$xi`.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 下一行代码计算第`i`个对象 4 的线性内存地址，公式为`$obj_base_addr` + `$i` * `$obj_stride`。然后，它使用`local.tee`表达式在下一行的`(call`
    `$get_attr)` 5 表达式中设置`$i_obj`的值。对`$getattr` 5 的调用获取第`i`个对象的`x`值，并将其赋给`$xi`。
- en: The next four lines load values into `$yi` and `$ri` in the same way. Then `$xj`,
    `$yj`, and `$rj` 6 are set using a call to `$get_attr` as well. These values are
    passed into a call to `$collision_check` 7, which returns `1` if the `$i` and
    `$j` circles collide and `0` if they don’t. The `if` statement that follows executes
    a `call` to `$set_collision` 8 if there was a collision, which then sets the collision
    flags on those two objects to `1`. The end of the loop increments `$j` 9 and branches
    back to the top of the inner `loop` if `$j` is less than `$obj_count`. The end
    of the outer `loop` increments `$i` a and branches back to the top of the outer
    `loop` if `$i` is less than `$obj_count`.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来的四行代码以相同的方式将值加载到`$yi`和`$ri`中。然后，`$xj`、`$yj`和`$rj` 6 也通过调用`$get_attr`来设置。这些值会传递给`$collision_check`
    7函数，如果`$i`和`$j`两个圆相撞，它会返回`1`，如果不相撞，则返回`0`。紧随其后的`if`语句会执行对`$set_collision` 8的`call`，如果发生了碰撞，该函数会将这两个对象的碰撞标志设置为`1`。循环结束时，`$j`
    9 会递增，并且如果`$j`小于`$obj_count`，则会跳转回内层`loop`的顶部。外层`loop`结束时，`$i`会递增，如果`$i`小于`$obj_count`，则会跳转回外层`loop`的顶部。
- en: The last item we call in this module is the `(start` `$init)` statement, as
    shown in [Listing 6-24](#listing6-24), which executes the `$init` function when
    the module is initialized.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这个模块中调用的最后一项是`(start` `$init)` 语句，如[清单 6-24](#listing6-24)所示，它在模块初始化时执行`$init`函数。
- en: '**data_structures.wat (part 6 of 6)**'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: '**data_structures.wat（第 6 部分，共 6 部分）**'
- en: '[PRE24]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Listing 6-24: The `start` indicates the function that will execute when the
    module is initialized.'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 清单 6-24：`start`表示模块初始化时会执行的函数。
- en: Now that we have all the code in the *data_structures.wat* file, we can compile
    the WebAssembly file using `wat2wasm`, as shown in [Listing 6-25](#listing6-25).
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经将所有代码放入*data_structures.wat*文件中，可以使用`wat2wasm`来编译WebAssembly文件，如[清单 6-25](#listing6-25)所示。
- en: '[PRE25]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Listing 6-25: Compile *data_structures.wat*'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 清单 6-25：编译 *data_structures.wat*
- en: Once we have a compiled *data_structures.wasm* file, we can run *data_structures.js*
    using `node`, as shown in [Listing 6-26](#listing6-26).
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们有了编译好的 *data_structures.wasm* 文件，就可以使用`node`运行 *data_structures.js*，如[清单
    6-26](#listing6-26)所示。
- en: '[PRE26]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Listing 6-26: Run *data_structures.js*.'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 清单 6-26：运行 *data_structures.js*。
- en: The output will look something like [Listing 6-27](#listing6-27).
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 输出将类似于[清单 6-27](#listing6-27)。
- en: '[PRE27]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Listing 6-27: Output from *data_structures.js*'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 清单 6-27：*data_structures.js* 的输出
- en: In the actual output, any circle that collides with another circle should be
    in red text, and any circle that collides with no other circles should be in green
    text. We now have an application that uses JavaScript to load randomly generated
    data for circles into WebAssembly linear memory. The initialization function in
    the WebAssembly module then loops over all of that data and updates the linear
    memory wherever one of those circles collides with another circle. Collision detection
    is a great use case for WebAssembly because it allows you to load a lot of data
    into linear memory and let your WebAssembly module work in a fast and efficient
    way.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 在实际输出中，任何与其他圆形相撞的圆形应该用红色文本显示，而没有与其他圆形相撞的圆形应该用绿色文本显示。现在我们有一个应用程序，使用 JavaScript
    将随机生成的圆形数据加载到 WebAssembly 线性内存中。然后，WebAssembly 模块中的初始化函数会遍历所有数据，并在发生圆形相撞时更新线性内存。碰撞检测是
    WebAssembly 的一个很好的使用案例，因为它允许你将大量数据加载到线性内存中，并让 WebAssembly 模块以快速高效的方式进行处理。
- en: Summary
  id: totrans-176
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, you learned what WebAssembly linear memory is and how to create
    it from within the WebAssembly module or JavaScript. Next, we initialized the
    linear data from within the WebAssembly module and accessed it from JavaScript.
    Then we created data structures within linear memory using a base address, stride,
    and attribute offsets, and initialized these data structures from within JavaScript
    using random data.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中，你学习了什么是 WebAssembly 线性内存以及如何从 WebAssembly 模块或 JavaScript 中创建它。接下来，我们在 WebAssembly
    模块中初始化了线性数据，并从 JavaScript 访问了这些数据。然后，我们使用基址、步幅和属性偏移量在线性内存中创建了数据结构，并通过 JavaScript
    使用随机数据初始化了这些数据结构。
- en: The final project was an array of circle data structures with x- and y-coordinates
    and a radius. These were passed into a WebAssembly module, which used a double
    loop to loop over the circle data structures looking for circles that overlap
    with each other. If two circles were found to overlap, the WebAssembly module
    set a collision flag inside the linear memory for both circles. JavaScript then
    looped over all of those circles, displaying their x- and y-coordinates, their
    radius, and whether they collided with any other circles.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 最终的项目是一个包含圆形数据结构的数组，每个数据结构都有 x 和 y 坐标以及半径。这些数据被传递到 WebAssembly 模块中，模块使用双重循环遍历圆形数据结构，寻找重叠的圆形。如果找到两个圆形重叠，WebAssembly
    模块会在这两个圆形的线性内存中设置一个碰撞标志。然后，JavaScript 会遍历所有这些圆形，显示它们的 x 和 y 坐标、半径，以及它们是否与其他圆形发生了碰撞。
- en: At this point, you should understand how to manipulate and set linear memory
    from within WAT and JavaScript. You should also be able to use linear memory from
    within your applications to create data structures and process large quantities
    of data in WebAssembly that you can then display using JavaScript. In the next
    chapter, we’ll look at how to manipulate the Document Object Model (DOM) from
    WebAssembly.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 到这一点，你应该已经理解如何在 WAT 和 JavaScript 中操作和设置线性内存。你还应该能够在你的应用程序中使用线性内存来创建数据结构，并在 WebAssembly
    中处理大量数据，然后通过 JavaScript 显示出来。在下一章，我们将探讨如何从 WebAssembly 操作文档对象模型（DOM）。
