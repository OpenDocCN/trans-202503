- en: '**15'
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '**15'
- en: SPECIAL USES OF SUBFUNCTIONS**
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: '**子函数的特殊用途**'
- en: '![Image](../images/pg297_Image_276.jpg)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/pg297_Image_276.jpg)'
- en: As you learned in [Chapter 14](ch14.xhtml), the most common use of a subfunction
    is to break a problem into smaller, easier-to-solve subproblems. This is the foundation
    of *recursion*, the subject of the first half of this chapter.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你在 [第14章](ch14.xhtml) 中学到的，子函数最常见的用途是将一个问题分解成更小、更易解决的子问题。这是 *递归* 的基础，也是本章前半部分的主题。
- en: 'After I cover recursion, I’ll show you another use of subfunctions: directly
    accessing hardware features in assembly language that may not be easily accessible
    in a higher-level language.'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在我讲解递归之后，我将向你展示子函数的另一个用途：直接访问汇编语言中的硬件功能，这些功能在高级语言中可能无法轻易访问。
- en: '**Recursion**'
  id: totrans-5
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**递归**'
- en: Many computer solutions involve repetitive actions. You learned how to use iteration—`while`,
    `for`, and `do-while` loops—to perform repetitive actions in [Chapter 13](ch13.xhtml).
    While iteration can be used to solve any repetitive problem, some solutions are
    described more succinctly using recursion.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 许多计算机解决方案涉及重复的操作。你在 [第13章](ch13.xhtml) 中学会了如何使用迭代—`while`、`for` 和 `do-while`
    循环—来执行重复的操作。虽然迭代可以用来解决任何重复性问题，但某些解决方案使用递归描述时会更加简洁。
- en: A *recursive algorithm* is an algorithm that calls itself to compute a simpler
    case of the problem and uses that result to compute the more complex case at hand.
    The recursive calls continue until the simpler case reaches a *base case*, which
    is a case that is easily computed by itself. At this point, the recursive algorithm
    returns the base case value to the next more complex case, where the value is
    used in that computation. This return/compute process continues, performing increasingly
    complex computations along the way, until we arrive at the solution for the original
    case.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: '*递归算法* 是一种调用自身来计算问题的简化版本，并使用该结果来计算更复杂的情况的算法。递归调用会持续进行，直到简化的情况达到 *基准情况*，即一个可以轻松计算的情况。在这一点上，递归算法会将基准情况的值返回给下一个更复杂的情况，并在该计算中使用这个值。这个返回/计算的过程会继续进行，逐步执行更复杂的计算，直到我们得出原始问题的解决方案。'
- en: 'Let’s look at an example. In mathematics, we denote the factorial operation
    on positive integers with an !, which can be defined recursively:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看一个例子。在数学中，我们用 `!` 来表示正整数的阶乘操作，这可以递归定义：
- en: '![Image](../images/pg334_Image_282a.jpg)'
  id: totrans-9
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/pg334_Image_282a.jpg)'
- en: The first equation shows that *n*! is defined by computing a simpler case of
    itself, (*n* – 1)!. This computation is performed repetitively until we reach
    the base case of *n* = 0\. Then we work our way back out, computing each *n*!
    along the way.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个方程式展示了 *n*! 是通过计算它自身的简化版本 (*n* – 1)! 来定义的。这个计算会反复执行，直到我们达到基准情况 *n* = 0。然后我们返回并计算每一个
    *n*!。
- en: 'For comparison, the iterative definition of the factorial operation is:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 作为对比，阶乘操作的迭代定义是：
- en: '![Image](../images/pg334_Image_282b.jpg)'
  id: totrans-12
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/pg334_Image_282b.jpg)'
- en: Although both forms of defining the factorial operation involve the same number
    of computations, the recursive form is more concise and perhaps more intuitive
    to some people.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管两种定义阶乘操作的形式涉及相同数量的计算，但递归形式更简洁，或许对某些人来说也更直观。
- en: '[Listings 15-1](ch15.xhtml#ch15list1) to [15-3](ch15.xhtml#ch15list3) show
    a program that uses a function, `factorial`, to compute 3!. You’ll see the reason
    for using a small, fixed value when we use `gdb` to examine the behavior of the
    program.'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: '[清单 15-1](ch15.xhtml#ch15list1) 到 [15-3](ch15.xhtml#ch15list3) 展示了一个使用函数 `factorial`
    来计算 3! 的程序。当我们使用 `gdb` 来检查程序的行为时，你会明白为何使用一个小的固定值。'
- en: '*three_factorial.c*'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: '*three_factorial.c*'
- en: '[PRE0]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '*Listing 15-1: A program to compute 3!*'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 15-1：计算 3! 的程序*'
- en: The mathematical factorial function is defined for nonnegative integers, so
    we use `unsigned int`s.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 数学中的阶乘函数是针对非负整数定义的，因此我们使用 `unsigned int` 类型。
- en: There is nothing remarkable about the header file for the `factorial` function,
    shown in [Listing 15-2](ch15.xhtml#ch15list2).
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 `factorial` 函数的头文件，在 [清单 15-2](ch15.xhtml#ch15list2) 中并没有什么特别之处。
- en: '*factorial.h*'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: '*factorial.h*'
- en: '[PRE1]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '*Listing 15-2: The header file for the function to compute* n*!*'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 15-2：计算 n! 的函数的头文件*'
- en: '[Listing 15-3](ch15.xhtml#ch15list3) shows that the `factorial` function calls
    itself to perform a simpler computation, (*n* – 1)!, so it can easily compute
    *n*!.'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: '[清单 15-3](ch15.xhtml#ch15list3) 显示了 `factorial` 函数如何通过调用自身来执行更简单的计算 (*n* –
    1)!, 从而轻松地计算 *n!*。'
- en: '*factorial.c*'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: '*factorial.c*'
- en: '[PRE2]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '*Listing 15-3: A function to compute* n*!*'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 15-3：计算 n! 的函数*'
- en: The `factorial` function first checks for the base case of *n* = 0 ❶. If we’re
    at the base case, the current result is 1\. If we’re not at the base case, the
    `factorial` function calls the `factorial` function to compute (*n* – 1)! and
    multiplies the result by *n* to get *n*!❷.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: '`factorial` 函数首先检查基础情况 *n* = 0 ❶。如果处于基础情况，当前结果为 1。如果不在基础情况，`factorial` 函数会调用自身计算
    (*n* – 1)!，并将结果乘以 *n* 以获得 *n*!❷。'
- en: The assembly language for the `main` function is unremarkable, but let’s look
    at what the compiler generated for the `factorial` function, shown in [Listing
    15-4](ch15.xhtml#ch15list4).
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: '`main` 函数的汇编语言并无特别之处，但让我们看看编译器为 `factorial` 函数生成的内容，如[列表 15-4](ch15.xhtml#ch15list4)所示。'
- en: '*factorial.s*'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: '*factorial.s*'
- en: '[PRE3]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '*Listing 15-4: The compiler-generated assembly language for the function in
    [Listing 15-3](ch15.xhtml#ch15list3)*'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 15-4：编译器生成的[列表 15-3](ch15.xhtml#ch15list3)中函数的汇编语言*'
- en: The algorithm used in the `factorial` function is a simple `if` construct, which
    you learned about in [Chapter 13](ch13.xhtml) ❷. The important part of a recursive
    function is that we need to save any arguments passed to it in registers so these
    registers can be reused to pass arguments in the recursive call to the function.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: '`factorial` 函数使用的算法是一个简单的 `if` 结构，你在[第13章](ch13.xhtml)中学过 ❷。递归函数的关键部分是，我们需要在寄存器中保存传递给它的任何参数，以便这些寄存器可以在递归调用时重新使用来传递参数。'
- en: For example, the `factorial` function takes one argument, `n`, which is passed
    in the `w0` register. From [Table 11-3](ch11.xhtml#ch11tab3) in [Chapter 11](ch11.xhtml),
    we know that we don’t need to save the content of `x0` in our function, but we
    need to use the `w0` portion of `x0` for the recursive call with the new value,
    `(n - 1)` ❸. And when the recursive call returns, we need the original value of
    `n` to compute `n * (n - 1)!`. The compiler has allocated space in the stack frame
    for saving `n` ❶.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，`factorial` 函数接受一个参数 `n`，它通过 `w0` 寄存器传递。从[表 11-3](ch11.xhtml#ch11tab3)中[第11章](ch11.xhtml)我们知道，在我们的函数中不需要保存
    `x0` 的内容，但我们需要使用 `x0` 的 `w0` 部分进行递归调用，并传入新的值 `(n - 1)` ❸。当递归调用返回时，我们需要 `n` 的原始值来计算
    `n * (n - 1)!`。编译器在堆栈帧中为保存 `n` 分配了空间 ❶。
- en: We haven’t discussed the `mul` instruction yet. As you might guess, the `mul`
    instruction in [Listing 15-4](ch15.xhtml#ch15list4) multiplies the integer in
    `w0` by the one in `w1`, leaving the product in `w0` ❹. The details of multiplication
    instructions are somewhat complex. I’ll cover them in [Chapter 16](ch16.xhtml).
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还没有讨论过 `mul` 指令。正如你可能猜到的，[列表 15-4](ch15.xhtml#ch15list4)中的 `mul` 指令会将 `w0`
    中的整数与 `w1` 中的整数相乘，将乘积保留在 `w0` 中 ❹。乘法指令的细节有些复杂，我会在[第16章](ch16.xhtml)中讲解。
- en: We can simplify the `factorial` function a little by writing it directly in
    assembly language. Let’s start by designing our stack frame, as shown in [Figure
    15-1](ch15.xhtml#ch15fig1).
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过直接用汇编语言编写来稍微简化 `factorial` 函数。让我们从设计堆栈帧开始，如[图 15-1](ch15.xhtml#ch15fig1)所示。
- en: '![Image](../images/pg336_Image_282.jpg)'
  id: totrans-36
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/pg336_Image_282.jpg)'
- en: '*Figure 15-1: The stack frame design for the* factorial *function*'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 15-1：* factorial *函数的堆栈帧设计*'
- en: '[Listing 15-5](ch15.xhtml#ch15list5) shows our assembly language version.'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: '[列表 15-5](ch15.xhtml#ch15list5)展示了我们的汇编语言版本。'
- en: '*factorial.s*'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: '*factorial.s*'
- en: '[PRE4]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '*Listing 15-5: A function to compute* n*!*'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 15-5：计算 *n*! 的函数*'
- en: There are a few key differences to note here. First, I don’t know why the compiler
    allocated 48 bytes for the stack frame (see [Listing 15-4](ch15.xhtml#ch15list4)),
    but we only need 32 bytes ❶. Second, we’re using a local variable for the input
    `n`. The compiler uses a local variable for the result of the computation `n *
    (n - 1)!`, but we’re leaving it in the `w0` register ❸. Third, we use the `cbz`
    instruction instead of the `cmp`/`beq` pair the compiler used ❷.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有几个关键的差异需要注意。首先，我不知道为什么编译器为堆栈帧分配了 48 字节（见[列表 15-4](ch15.xhtml#ch15list4)），但我们只需要
    32 字节 ❶。其次，我们使用了一个局部变量来存储输入的 `n`。编译器使用局部变量来存储计算结果 `n * (n - 1)!`，但我们将其保留在 `w0`
    寄存器中 ❸。第三，我们使用了 `cbz` 指令，而不是编译器使用的 `cmp`/`beq` 指令对 ❷。
- en: 'Recursive algorithms can be simple and elegant, but they make heavy use of
    the stack. I used our assembly language version of `factorial` (and the C header
    file in [Listing 15-2](ch15.xhtml#ch15list2)) with the `main` function of [Listing
    15-1](ch15.xhtml#ch15list1) and ran the program under `gdb` so we can take a look
    at the stack usage:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 递归算法可以简单而优雅，但它们大量使用堆栈。我使用了我们汇编语言版本的 `factorial`（以及[列表 15-2](ch15.xhtml#ch15list2)中的
    C 头文件）和[列表 15-1](ch15.xhtml#ch15list1)中的 `main` 函数，并在 `gdb` 下运行了程序，这样我们就可以看看堆栈的使用情况：
- en: '[PRE5]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'I set two breakpoints, one at the recursive call to `factorial` ❶ and the other
    at the point where the function’s algorithm ends ❷. Each time the program breaks
    back into `gdb`, we’ll look at the input value to this call to `factorial`, the
    input value we’re passing to the next call to `factorial`, `pc`, and the stack
    frame for each call to `factorial`:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 我设置了两个断点，一个是在递归调用`factorial` ❶时，另一个是在函数算法结束的地方 ❷。每当程序回到`gdb`时，我们将查看此次调用`factorial`的输入值、传递给下一次调用`factorial`的输入值、`pc`以及每次调用`factorial`的栈帧：
- en: '[PRE6]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The `main` function called the `factorial` function with `3` as the input, which
    is saved on the stack ❷. When viewing this display, remember that the input is
    a 32-bit `int`. Each item on the stack is 64 bits wide, so this `int` is stored
    in the low-order 32 bits of this stack location. Looking at the 32 bytes of the
    stack frame, we see the return address back to `main` ❶.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: '`main`函数调用`factorial`函数时传入了`3`作为输入，这个值保存在栈上 ❷。查看这个显示时，请记住输入是一个32位的`int`。栈上的每项数据宽度是64位，因此这个`int`被存储在这个栈位置的低32位中。通过查看32字节的栈帧，我们可以看到返回地址回到`main`
    ❶。'
- en: 'We’re now ready to call `factorial` with the input `(3 - 1) = 2` in register
    `w0`. When we continue running the program, it will break at the same place in
    `factorial` because the function calls itself before returning to `main`:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们准备使用寄存器`w0`调用`factorial`，并传入输入`(3 - 1) = 2`。当我们继续执行程序时，它将在`factorial`中相同的位置暂停，因为该函数在返回`main`之前会调用自身：
- en: '[PRE7]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The `factorial` function has added another 32-byte stack frame onto the stack
    ❶. The input to this call to `factorial`, `2`, has been saved in this new stack
    frame ❸.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: '`factorial`函数向栈上添加了一个新的32字节栈帧 ❶。这次调用`factorial`的输入值`2`已经保存在这个新的栈帧中 ❸。'
- en: The program counter, `pc`, shows that the `bl factorial` instruction is located
    at `0x55555507cc`. All instructions in the A64 architecture are 32 bits wide,
    so all recursive calls to the `factorial` function will return to location `0x55555507cc
    + 0x4 = 0x55555507d0` in the function. This is the return address stored in the
    frame record ❷.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 程序计数器`pc`显示`bl factorial`指令位于`0x55555507cc`。在A64架构中，所有指令宽度为32位，因此所有递归调用`factorial`函数都会返回到`0x55555507cc
    + 0x4 = 0x55555507d0`的位置。这就是存储在框架记录中的返回地址 ❷。
- en: 'If we enter c (continue) two more times, we finally reach the point where the
    program flow leaves the fourth call to `factorial`, breaking at the second breakpoint:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们再输入两次c（继续），最终我们会到达程序流离开第四次`factorial`调用的地方，并在第二个断点处暂停：
- en: '[PRE8]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: This view shows that each time `factorial` was called, it created a new stack
    frame. It also shows where the input to each call of `factorial` has been saved
    on the stack, the last one being `0` ❶. Since this is the base case, the program
    flow went directly to the end of the function.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 这个视图显示了每次调用`factorial`时，都会创建一个新的栈帧。它还展示了每次调用`factorial`的输入是如何保存在栈上的，最后一个是`0`
    ❶。由于这是基准情况，程序流直接跳到了函数的末尾。
- en: 'The return address stored in the frame records of the top three stack frames
    is `0x00000055555507d0`. When each recursive call to `factorial` returns, it returns
    to the instruction immediately following the `bl factorial` instruction in the
    `factorial` function itself. When we continue execution of the program, it again
    breaks at our second breakpoint:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 栈上前三个栈帧的框架记录中的返回地址是`0x00000055555507d0`。每次递归调用`factorial`返回时，都会返回到`factorial`函数中`bl
    factorial`指令后面的指令。当我们继续执行程序时，它再次在第二个断点处暂停：
- en: '[PRE9]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Comparing this display with the previous display, we can see that the top frame
    record—the one created when `factorial` was called with the base case of `0` as
    input—has been removed from the stack.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 比较这个显示和之前的显示，我们可以看到顶部的框架记录——即当`factorial`函数以`0`作为输入调用时创建的框架记录——已经从栈上移除。
- en: 'When we continue, the program breaks again at the second breakpoint before
    returning from this invocation of `factorial`:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们继续执行时，程序再次在第二个断点处暂停，等待从这次`factorial`调用中返回：
- en: '[PRE10]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Using the continue command (`c`) once more takes us back to the original call
    to `factorial` from `main`:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 再次使用继续命令（`c`）将我们带回原始的`main`中对`factorial`的调用：
- en: '[PRE11]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'The return address in the frame record is back in `main` ❶. When we continue,
    `main` prints the result for us:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 框架记录中的返回地址回到了`main` ❶。当我们继续执行时，`main`将为我们打印结果：
- en: '[PRE12]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The debugger has also printed some information about the process for us. We’re
    still in `gdb` and need to quit that.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 调试器还为我们打印了一些进程信息。我们仍然在`gdb`中，需要退出它。
- en: Looking back at the stack display when the program is at the base case ([page
    311](ch15.xhtml#page_311)), notice that each call to the recursive function creates
    another stack frame. We used a small number in this example, but computing the
    factorial of a large number would use a lot of stack space. And since there is
    a call to a function in each repetition, recursive algorithms can be time-consuming.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 当程序处于基本情况时（参见[第311页](ch15.xhtml#page_311)），回顾栈的显示，注意到每次调用递归函数时都会创建一个新的栈帧。我们在这个例子中使用了一个小数字，但计算大数字的阶乘会占用大量栈空间。而且，由于每次重复都会调用一个函数，递归算法可能会很耗时。
- en: Every recursive solution has an equivalent iterative solution, which is usually
    more efficient, both in time and in stack usage. For example, the iterative algorithm
    to compute the factorial of an integer (see [page 306](ch15.xhtml#page_306)) is
    simple, so an iterative solution might be preferable. However, many problems (such
    as some sorting algorithms) lend themselves more naturally to a recursive solution.
    For such problems, the increased simplicity of the code is often worth the cost
    of recursion.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 每个递归解决方案都有一个等效的迭代解决方案，通常在时间和栈使用上更高效。例如，计算整数阶乘的迭代算法（参见[第306页](ch15.xhtml#page_306)）很简单，因此迭代解决方案可能更为优选。然而，许多问题（例如某些排序算法）更自然地适合使用递归解决方案。对于这类问题，代码的简化通常是值得付出的递归代价。
- en: We would typically write a recursive function in a higher-level language, but
    I used assembly language here so you can gain an understanding of how recursion
    works. Next, I’ll show you how to use assembly language to access hardware features
    that might not be directly accessible in the high-level language you’re using.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通常会在高级语言中编写递归函数，但我在这里使用汇编语言是为了让你理解递归是如何工作的。接下来，我将向你展示如何使用汇编语言访问可能在你使用的高级语言中无法直接访问的硬件特性。
- en: '**YOUR TURN**'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: '**轮到你了**'
- en: 15.1     Enter the C program in [Listings 15-1](ch15.xhtml#ch15list1) to [15-3](ch15.xhtml#ch15list3).
    Run your program under `gdb`, with breakpoints at the beginning of the `if` statement
    and at the `return` statement. Each time it breaks, you should see the value of
    `n` that was the input to the current call to `factorial`. The `bt` (backtrace)
    and `info f` (frame information) `gdb` commands will give you more information
    about the stack frames, which can be helpful in debugging recursive C functions.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 15.1     输入[C程序](ch15.xhtml#ch15list1)至[15-3](ch15.xhtml#ch15list3)。在`gdb`下运行你的程序，并在`if`语句的开头和`return`语句处设置断点。每次断点触发时，你应该看到输入当前调用`factorial`的`n`值。`gdb`的`bt`（回溯）和`info
    f`（帧信息）命令将提供更多关于栈帧的信息，这对调试递归C函数非常有帮助。
- en: '**Accessing CPU Features in Assembly Language**'
  id: totrans-70
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**在汇编语言中访问CPU特性**'
- en: In [Chapter 14](ch14.xhtml), it may have seemed a bit silly to create a whole
    subfunction just to add two integers for the `sum_ints` program (see [Listing
    14-8](ch14.xhtml#ch14list8)), which can be done with a single instruction. But
    as you learned in [Chapter 3](ch03.xhtml), even simple addition can produce carry
    or overflow.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第14章](ch14.xhtml)中，为了`sum_ints`程序（参见[列表14-8](ch14.xhtml#ch14list8)）仅仅添加两个整数就创建一个完整的子函数，可能看起来有些傻，这本来可以通过一条指令完成。但正如你在[第3章](ch03.xhtml)学到的，即使是简单的加法，也可能会产生进位或溢出。
- en: The `add` and `sub` instructions you learned about in [Chapter 11](ch11.xhtml)
    have no effect on the condition flags, but the A64 architecture includes variants
    of `add` and `sub`, `adds` and `subs`, that will set the condition flags in the
    `nzcv` register according to the result of the operation.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 你在[第11章](ch11.xhtml)中学到的`add`和`sub`指令不会影响条件标志，但A64架构包括`add`和`sub`的变体，`adds`和`subs`，它们会根据操作结果设置`nzcv`寄存器中的条件标志。
- en: 'C and C++ don’t provide a way to check the overflow or carry flags in the `nzcv`
    register. In this section, I’ll show you two ways to use assembly language in
    C programs to indicate when there is overflow from addition: we can write a separate
    function in assembly language that is callable from our C code, or we can embed
    assembly language directly within our C code.'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: C和C++并没有提供检查`nzcv`寄存器中溢出或进位标志的方法。在这一部分，我将展示两种方法来在C程序中使用汇编语言指示加法溢出的情况：我们可以编写一个在C代码中可调用的单独汇编函数，或者直接在C代码中嵌入汇编语言。
- en: '***Writing a Separate Function***'
  id: totrans-74
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***编写一个单独的函数***'
- en: I’ll start by rewriting the `sum_ints` program from [Chapter 14](ch14.xhtml)
    in C so that it warns the user if the addition produces overflow. I’ll check for
    overflow in the subfunction `add_two`, and I’ll pass the result back to the `main`
    function using the return mechanism.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 我将从 [第 14 章](ch14.xhtml) 中的 `sum_ints` 程序开始，使用 C 语言重写它，以便在加法产生溢出时提醒用户。我将在子函数
    `add_two` 中检查溢出，并通过返回机制将结果传回 `main` 函数。
- en: '[Listing 15-6](ch15.xhtml#ch15list6) shows the modified `main` function that
    checks the return value from the `add_two` function for overflow.'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: '[清单 15-6](ch15.xhtml#ch15list6) 显示了修改后的 `main` 函数，该函数检查 `add_two` 函数的返回值是否发生溢出。'
- en: '*sum_ints.c*'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: '*sum_ints.c*'
- en: '[PRE13]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '*Listing 15-6: A program to add two integers and show if there is overflow*'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 15-6：一个加法程序，检查两个整数相加时是否发生溢出*'
- en: Next, I’ll rewrite the `add_two` function such that it returns 0 if there is
    no overflow and 1 if there is overflow (recall that in C, zero is logically false
    and a nonzero value is true). I’ll assign this result to the variable `overflow`
    in `main`.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我将重写 `add_two` 函数，使其在没有溢出的情况下返回 0，在发生溢出时返回 1（回忆一下，在 C 语言中，零在逻辑上为假，非零值为真）。我将在
    `main` 函数中将这个结果赋值给变量 `overflow`。
- en: '[Listing 15-7](ch15.xhtml#ch15list7) shows the header file for the new `add_two`
    function.'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: '[清单 15-7](ch15.xhtml#ch15list7) 显示了新的 `add_two` 函数的头文件。'
- en: '*add_two.h*'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: '*add_two.h*'
- en: '[PRE14]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '*Listing 15-7: The header file for the* add_two *function*'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 15-7：add_two 函数的头文件*'
- en: The only change in the function declaration is returning an `int` instead of
    `void`. We need to add a check for overflow in the definition of the `add_two`
    function, as shown in [Listing 15-8](ch15.xhtml#ch15list8).
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 函数声明中的唯一变化是返回一个 `int` 类型，而不是 `void`。我们需要在 `add_two` 函数的定义中添加溢出检查，如 [清单 15-8](ch15.xhtml#ch15list8)
    所示。
- en: '*add_two.c*'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: '*add_two.c*'
- en: '[PRE15]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '*Listing 15-8: A function to add two integers and return an overflow indication*'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 15-8：一个加法函数，返回溢出指示*'
- en: You learned in [Chapter 3](ch03.xhtml) that if adding two integers of the same
    sign gives a result of the opposite sign, you have overflow, so we use this logic
    as the check for overflow ❶.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 你在 [第 3 章](ch03.xhtml) 中学到，如果相加的两个整数符号相同，结果却是相反符号，那么就发生了溢出，因此我们使用这个逻辑来检查溢出 ❶。
- en: '[Listing 15-9](ch15.xhtml#ch15list9) shows the assembly language generated
    by the compiler from this C source.'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: '[清单 15-9](ch15.xhtml#ch15list9) 显示了编译器从这个 C 源代码生成的汇编语言。'
- en: '*add_two.s*'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: '*add_two.s*'
- en: '[PRE16]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: '*Listing 15-9: The compiler-generated assembly language for the* add_two *function
    in [Listing 15-8](ch15.xhtml#ch15list8)*'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 15-9：编译器生成的 [清单 15-8](ch15.xhtml#ch15list8) 中的 add_two 函数的汇编语言*'
- en: As you can see, it takes about 20 instructions to check for overflow in C ❶.
    In [Listing 15-10](ch15.xhtml#ch15list10), I rewrite the `add_two` function in
    assembly language so I can use the `adds` instruction for the addition operation
    and then detect overflow from the condition flags in the `nzcv` register.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，在 C 语言中检查溢出大约需要 20 条指令 ❶。在 [清单 15-10](ch15.xhtml#ch15list10) 中，我将 `add_two`
    函数重写为汇编语言，以便我可以使用 `adds` 指令进行加法运算，然后通过 `nzcv` 寄存器中的条件标志来检测溢出。
- en: '*add_two.s*'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: '*add_two.s*'
- en: '[PRE17]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: '*Listing 15-10: The* add_two *function with overflow detection in assembly
    language*'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 15-10：带有溢出检测的 add_two 函数（汇编语言版）*'
- en: I didn’t create a stack frame for this very simple leaf function because it
    is unlikely we would ever modify this function to call another function.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 我没有为这个非常简单的叶子函数创建栈帧，因为我们不太可能修改这个函数来调用其他函数。
- en: 'I used the `cinc` instruction ❶ to read the overflow flag in the `nzcv` register
    and load the `w0` register with either a `0` or a `1`, depending on whether the
    overflow flag is `0` or `1`:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 我使用了 `cinc` 指令 ❶ 来读取 `nzcv` 寄存器中的溢出标志，并将 `w0` 寄存器加载为 `0` 或 `1`，具体取决于溢出标志是 `0`
    还是 `1`：
- en: cinc**—Conditional increment**
  id: totrans-100
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: cinc**—条件增量**
- en: '`cinc w`d `, w`s `,` cond moves the value in `w`s to `w`d, adding 1 to the
    value if cond is true.'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: '`cinc w`d `, w`s `,` cond 将 `w`s 中的值移动到 `w`d 中，如果 cond 为真，则将值加 1。'
- en: '`cinc x`d `, x`s `,` cond moves the value in `x`s to `x`d, adding 1 to the
    value if cond is true.'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: '`cinc x`d `, x`s `,` cond 将 `x`s 中的值移动到 `x`d 中，如果 cond 为真，则将值加 1。'
- en: The possible values for cond are given in [Table 13-1](ch13.xhtml#ch13tab1)
    in [Chapter 13](ch13.xhtml).
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: cond 的可能值可以在 [第 13 章](ch13.xhtml) 的 [表 13-1](ch13.xhtml#ch13tab1) 中找到。
- en: Using the assembly language version of `add_two` in [Listing 15-10](ch15.xhtml#ch15list10)
    with the `main` function in [Listing 15-6](ch15.xhtml#ch15list6) shows one of
    the reasons for writing a subfunction in assembly language. It allows us to access
    a feature of the CPU, the `V` flag in the `nzcv` register, that is not accessible
    in C, the higher-level language we’re using. Writing in assembly language allows
    us to ensure that there are no intervening instructions that might change the
    flags between the operation (addition, in this example) and the flag check.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 使用[示例 15-10](ch15.xhtml#ch15list10)中的汇编语言版本的`add_two`与[示例 15-6](ch15.xhtml#ch15list6)中的`main`函数一起，展示了编写汇编语言子函数的原因之一。它使我们能够访问CPU的一个特性，即`nzcv`寄存器中的`V`标志，而这种特性在我们使用的高级语言C中是无法访问的。使用汇编语言编写代码使我们能够确保在操作（本例中的加法）和标志检查之间没有其他指令会改变标志。
- en: This example also illustrates a common use of the return value. Inputs and outputs
    are often passed in the argument list, with supplemental information about the
    computation carried in the return value.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子还说明了返回值的常见用法。输入和输出通常通过参数列表传递，关于计算的补充信息则通过返回值携带。
- en: That said, calling a function to simply add two numbers is inefficient. In the
    next section, we’ll look at a common extension to C that allows us to insert assembly
    language directly in our C code.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 话虽如此，单纯地调用一个函数来加两个数字是低效的。在下一节中，我们将看看C语言的一个常见扩展，它允许我们直接在C代码中插入汇编语言。
- en: '***Using Inline Assembly Language***'
  id: totrans-107
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***使用内联汇编语言***'
- en: Like many C compilers, `gcc` includes an extension to the standard C language
    that allows us to embed assembly language in our C code, usually called *inline
    assembly*. Doing so can be complex. We’ll look at a simple case here. You can
    read the details at *[https://gcc.gnu.org/onlinedocs/gcc/Using-Assembly-Language-with-C.html](https://gcc.gnu.org/onlinedocs/gcc/Using-Assembly-Language-with-C.html)*,
    or you can use the `info gcc` command and select **C Extensions ▶ Using Assembly
    Language with C ▶ Extended Asm**.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 和许多C编译器一样，`gcc`包含一个标准C语言的扩展，允许我们在C代码中嵌入汇编语言，通常称为*内联汇编*。这样做可能会很复杂。我们在这里看一个简单的例子。你可以在*[https://gcc.gnu.org/onlinedocs/gcc/Using-Assembly-Language-with-C.html](https://gcc.gnu.org/onlinedocs/gcc/Using-Assembly-Language-with-C.html)*中查看详细信息，或者使用`info
    gcc`命令并选择**C扩展 ▶ 使用汇编语言与C ▶ 扩展汇编**。
- en: 'The `gcc` compiler uses the following general form for embedding assembly language
    in C, which starts with the `asm` keyword:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: '`gcc`编译器使用以下通用格式来在C中嵌入汇编语言，这从`asm`关键字开始：'
- en: '[PRE18]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: The asm-qualifiers are used to help the compiler optimize the C code, a topic
    that is beyond the scope of this book. We’re not asking the compiler to optimize
    our C code, so we won’t use asm-qualifiers.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: asm-限定符用于帮助编译器优化C代码，这个话题超出了本书的范围。我们并没有要求编译器优化我们的C代码，因此我们不会使用asm-限定符。
- en: The output operands are the C variables that could be changed by the assembly
    language statements, thus acting as outputs from the assembly language statements.
    The input operands refer to the C variables that are used by the assembly language
    statements but are not changed, thus acting as inputs to the assembly language
    statements. The clobbers are the registers that get explicitly changed by the
    assembly language statements, thus telling the compiler about the possible changes
    in these registers.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 输出操作数是可能会被汇编语言语句改变的C变量，因此充当汇编语言语句的输出。输入操作数是汇编语言语句使用的C变量，但不会改变，因此充当汇编语言语句的输入。破坏的寄存器是被汇编语言语句显式改变的寄存器，从而告诉编译器这些寄存器可能发生的变化。
- en: In [Listing 15-11](ch15.xhtml#ch15list11), I use inline assembly language to
    check for overflow in the addition.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 在[示例 15-11](ch15.xhtml#ch15list11)中，我使用内联汇编语言来检查加法中的溢出。
- en: '*sum_ints.c*'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: '*sum_ints.c*'
- en: '[PRE19]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: '*Listing 15-11: A program to add two integers and show if there’s overflow*'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: '*示例 15-11：一个程序，用于加两个整数并显示是否溢出*'
- en: The first thing to note about the code here is that it’s important to place
    the `adds` instruction in assembly language so we can check for overflow immediately
    after the instruction is executed ❶. If we were to do the addition in C, the compiler
    would use the `add` instruction, as in [Listing 15-9](ch15.xhtml#ch15list9), which
    does not set the condition flags.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 这里代码的第一点需要注意的是，在汇编语言中放置`adds`指令非常重要，这样我们可以在指令执行后立即检查溢出❶。如果我们在C语言中进行加法，编译器会使用`add`指令，如在[示例
    15-9](ch15.xhtml#ch15list9)中所示，但该指令不会设置条件标志。
- en: There is a template for each assembly language instruction as a text string
    enclosed in quotes ❶. The operands for each instruction are numbered according
    to their relative position on the *output:input* operand list, starting from 0\.
    I preface the variable numbers with `w` in the assembly language template to tell
    the compiler that these are word (32-bit) values. Remember that assembly language
    code is line-oriented, so it’s important to place a newline character, `\n`, at
    the end of each assembly language statement. The newline is not needed at the
    end of the last assembly language statement.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 每个汇编语言指令都有一个作为文本字符串的模板，字符串被引号包围❶。每条指令的操作数根据它们在*输出:输入*操作数列表中的相对位置编号，从0开始。我在汇编语言模板中为变量编号加上`w`前缀，告诉编译器这些是字（32位）值。请记住，汇编语言代码是以行作为单位的，因此在每条汇编语言语句的末尾添加换行符`\n`是很重要的。最后一条汇编语言语句后不需要换行符。
- en: '**NOTE**'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*Be careful not to confuse operand numbers with register numbers.* %w0 *is
    the 32-bit value of the first operand on our* output:input *operand list, and*
    w0 *is the low-order 32 bits of the* x0 *register.*'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: '*小心不要混淆操作数编号和寄存器编号。* `%w0` *是我们输出:输入操作数列表中第一个操作数的32位值，而* w0 *是* x0 *寄存器的低位32位。*'
- en: 'The syntax for each output or input operand is:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 每个输出或输入操作数的语法是：
- en: '[PRE20]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: In our program, `z` is in position 0 and `overflow` is in position 1 ❷; `x`
    is in position 2 and `y` is in position 3 ❸.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的程序中，`z`位于位置0，`overflow`位于位置1❷；`x`位于位置2，`y`位于位置3❸。
- en: The constraint tells the compiler what kind of operand it can use in the assembly
    language template. For example, `"m"` means the compiler should use a memory location
    and `"r"` means it should use a register. Prefixing the kind with `=` tells the
    compiler that our assembly language stores a value there. The `"=r" (z)` constraint
    thus tells the compiler that it needs to use a register for the `%w0` operand,
    that our assembly language will store a value in that register, and to store the
    value in that register in the C variable `z` ❷. The `"r" (x)` constraint tells
    the compiler to use a register for the value in the C variable `x`, but our assembly
    language does not change the value in that register ❸.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 约束告诉编译器在汇编语言模板中可以使用哪种操作数。例如，`"m"`表示编译器应该使用内存位置，而`"r"`表示应该使用寄存器。通过在类型前加上`=`，我们告诉编译器我们的汇编语言会在该位置存储一个值。因此，`"=r"
    (z)`约束告诉编译器，它需要为`%w0`操作数使用一个寄存器，我们的汇编语言将在该寄存器中存储一个值，并将该值存储到C变量`z`中❷。`"r" (x)`约束则告诉编译器使用寄存器存储C变量`x`中的值，但我们的汇编语言不会改变该寄存器中的值❸。
- en: Be aware that when you use inline assembly language, the compiler could generate
    assembly language for your C code that does not work well with your assembly language.
    It’s a good idea to generate the assembly language for the entire function (using
    the `-S` compiler option) and read it carefully to make sure the function is doing
    what you intend. We’ll do this in [Listing 15-12](ch15.xhtml#ch15list12).
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，当你使用内联汇编语言时，编译器可能会为你的C代码生成与汇编语言不兼容的汇编代码。最好生成整个函数的汇编语言（使用`-S`编译器选项），并仔细阅读它，确保函数按照你的意图执行。我们将在[Listing
    15-12](ch15.xhtml#ch15list12)中做这个。
- en: '*sum_ints.s*'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: '*sum_ints.s*'
- en: '[PRE21]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: '*Listing 15-12: The compiler-generated code for inline assembly*'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: '*Listing 15-12：编译器生成的内联汇编代码*'
- en: We told the compiler that the assembly language we’ve inserted uses registers
    for the inputs (`"r"`), so it loads the values from the C variables into registers
    ❶. Similarly, we specified that we’re using registers for the outputs in our assembly
    language (`"=r"`), and the compiler stores the values from the registers into
    the C variables ❷.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 我们告诉编译器，我们插入的汇编语言使用寄存器作为输入（`"r"`），因此它将C变量的值加载到寄存器中❶。类似地，我们指定汇编语言中的输出使用寄存器（`"=r"`），编译器将寄存器中的值存储到C变量中❷。
- en: If you think inline assembly looks tricky, you’re right. The C language standard
    lists inline assembly as a common extension to the language but points out that
    extensions are not part of the standard. This means that using inline assembly
    in C code may not work if you use a different compiler, even on the same computer.
    In most cases, if I need to use assembly language, I use a separate function,
    as we did in [Listing 15-10](ch15.xhtml#ch15list10), which is portable between
    compilers.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你觉得内联汇编看起来很复杂，你没错。C语言标准将内联汇编列为语言的常见扩展，但也指出扩展并不是标准的一部分。这意味着，如果你使用不同的编译器，即使在同一台计算机上，使用内联汇编的C代码可能无法正常工作。在大多数情况下，如果我需要使用汇编语言，我会像在[示例15-10](ch15.xhtml#ch15list10)中那样使用单独的函数，这样的代码在不同编译器之间是可移植的。
- en: '**YOUR TURN**'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: '**轮到你了**'
- en: '15.2     Modify the C program in [Listings 15-6](ch15.xhtml#ch15list6), [15-7](ch15.xhtml#ch15list7),
    and [15-8](ch15.xhtml#ch15list8) to use `unsigned int`s and tell the user when
    the addition produces carry. It will declare the variables as follows:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 15.2 修改[示例15-6](ch15.xhtml#ch15list6)、[15-7](ch15.xhtml#ch15list7)和[15-8](ch15.xhtml#ch15list8)中的C程序，使用`unsigned
    int`类型，并在加法产生进位时提醒用户。它将如下声明变量：
- en: '[PRE22]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'The formatting code for reading and printing the values of the `unsigned int`s
    is `%u`. Here’s an example:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 读取和打印`unsigned int`值的格式代码是`%u`。这里有一个例子：
- en: '[PRE23]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 15.3     Modify the program in [Listing 15-11](ch15.xhtml#ch15list11) to use
    `unsigned int`s and tell the user when the addition produces carry.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 15.3 修改[示例15-11](ch15.xhtml#ch15list11)中的程序，使用`unsigned int`类型，并在加法产生进位时提醒用户。
- en: 15.4     Modify the program in [Listing 15-11](ch15.xhtml#ch15list11) to use
    `register int`s for the `z` and `overflow` variables. How does this change the
    compiler-generated assembly language?
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 15.4 修改[示例15-11](ch15.xhtml#ch15list11)中的程序，为`z`和`overflow`变量使用`register int`类型。这样做会如何改变编译器生成的汇编语言？
- en: '**What You’ve Learned**'
  id: totrans-138
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**你学到的内容**'
- en: '**Recursion** Allows for simple and elegant solutions to some problems, but
    uses a lot of stack space.'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: '**递归** 提供了一些问题的简单而优雅的解决方案，但会使用大量的栈空间。'
- en: '**Accessing hardware features** Most programming languages do not allow direct
    access to all the hardware features in a computer. Using an assembly language
    subfunction or inline assembly language may be the best solution.'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: '**访问硬件特性** 大多数编程语言不允许直接访问计算机的所有硬件特性。使用汇编语言子函数或内联汇编语言可能是最好的解决方案。'
- en: '**Inline assembly** Allows us to embed assembly language in our C code frame
    pointer and the return address to the calling function.'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: '**内联汇编** 允许我们在C代码中嵌入汇编语言，传递帧指针和调用函数的返回地址。'
- en: Now that you know some common ways to use functions in a program, we’ll move
    on to multiplication, division, and logic operations. In the next chapter, you’ll
    learn how to convert a string of numerals in ASCII code to the integer they represent.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经了解了一些在程序中使用函数的常见方法，我们将继续讨论乘法、除法和逻辑操作。在下一章中，你将学习如何将ASCII码表示的数字字符串转换为它们所代表的整数。
