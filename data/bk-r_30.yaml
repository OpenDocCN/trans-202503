- en: '**25**'
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '**25**'
- en: '**DEFINING COLORS AND PLOTTING IN HIGHER DIMENSIONS**'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: '**定义颜色和在高维度中绘制图形**'
- en: '![image](../images/common-01.jpg)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/common-01.jpg)'
- en: Now that you’ve mastered some fundamental visualization skills, you can go beyond
    the standard *x*- and *y*-axes by, for example, coloring points according to some
    additional value or variable or adding a *z*-axis for constructing a 3D plot.
    Higher-dimensional plots like this allow you to visually explore your data or
    models using more variables than would be possible otherwise.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经掌握了一些基本的可视化技巧，你可以通过给点着色来超越标准的*x*和*y*坐标轴，依据某些附加的值或变量，或者添加一个*z*轴来构建3D图表。像这样的高维度图表允许你使用比其他方式更多的变量来直观地探索你的数据或模型。
- en: 'In this chapter, you’ll get into more detail when it comes to handling colors
    and color palettes in R, and then you’ll look at four new plots: 3D scatterplots,
    contour plots, pixel image plots, and perspective plots.'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你将深入了解如何在R中处理颜色和调色板，然后你将看到四种新的图表类型：3D散点图、等高线图、像素图和透视图。
- en: '**25.1 Representing and Using Color**'
  id: totrans-5
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**25.1 表示和使用颜色**'
- en: Color plays a key role in many plots. As you’ve already seen, color can be used
    purely for aesthetic enhancement, or it can be a critical aid to interpreting
    your data/models by distinguishing between values and variables. Before learning
    about some more complicated data and model visualization tools, it’s useful to
    understand a little about how R formally represents and handles colors. In this
    section, you’ll examine common ways to create and represent specific colors and
    how to define and use a cohesive collection of colors; the latter is referred
    to as a *palette*.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 颜色在许多图表中起着关键作用。正如你已经看到的，颜色不仅可以纯粹用于美学增强，也可以通过区分不同的值和变量，成为解读数据/模型的重要工具。在学习一些更复杂的数据和模型可视化工具之前，了解R如何正式表示和处理颜色是很有用的。在本节中，你将学习常见的创建和表示特定颜色的方法，以及如何定义和使用一组协调一致的颜色；后一种方法称为*调色板*。
- en: '***25.1.1 Red-Green-Blue Hexadecimal Color Codes***'
  id: totrans-7
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***25.1.1 红绿蓝十六进制颜色代码***'
- en: When specifying colors in plots, your instruction to R so far has been given
    either in the form of an integer value from `1` to `8` or as a character string
    (see the relevant comments in [Section 7.2.3](ch07.xhtml#ch07lev2sec65)). For
    programming purposes, you need a more objective representation of these colors.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 在指定图表中的颜色时，你迄今为止给R的指令通常是通过一个从`1`到`8`的整数值，或者是字符字符串的形式（请参见[第7.2.3节](ch07.xhtml#ch07lev2sec65)中的相关注释）。为了编程目的，你需要这些颜色的更客观的表示方式。
- en: One of the most common methods of color specification is to specify different
    *saturations* or *intensities* of three primaries—red, green, and blue (RGB)—which
    are then mixed to form the resulting target color. Each primary component of the
    standard RGB system is assigned an integer from 0 to 255 (inclusive). Such mixtures
    are therefore able to form a total of 256³ = 16,777,216 possible colors.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 最常见的颜色指定方法之一是指定三种原色——红色、绿色和蓝色（RGB）的不同*饱和度*或*强度*，然后将它们混合形成最终的目标颜色。标准RGB系统中的每个原色分量都被赋予一个从0到255（包含）的整数。因此，这样的混合可以形成256³
    = 16,777,216种可能的颜色。
- en: You always express these values in (R, G, B) order; the result is commonly referred
    to as a *triplet*. For example, (0,0,0) represents pure black, (255,255,255) represents
    pure white, and (0,255,0) is full green.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 你总是按（R，G，B）的顺序来表示这些值；结果通常称为*三元组*。例如，（0,0,0）代表纯黑色，（255,255,255）代表纯白色，（0,255,0）代表纯绿色。
- en: 'The `col` argument lets you select one of eight colors when you supply it an
    integer from 1 to 8\. You can find these eight colors with the following call:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: '`col`参数允许你在输入从1到8的整数时，选择八种颜色中的一种。你可以通过以下调用来找到这八种颜色：'
- en: '[PRE0]'
  id: totrans-12
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'These are but a small subset of the 650+ named colors that you can list by
    entering `colors()` at the R prompt. All of these named colors can also be expressed
    in the standard RGB format. To find the RGB values for a color, supply the desired
    color names as a vector of character strings to the built-in `col2rgb` function.
    Here’s an example:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 这些只是你通过在R提示符下输入`colors()`命令可以列出的650多个命名颜色的一个小子集。所有这些命名颜色也可以用标准RGB格式表示。要查找颜色的RGB值，只需将所需的颜色名称作为字符向量传递给内置的`col2rgb`函数。以下是一个示例：
- en: '[PRE1]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The result is a matrix of RGB values, with each column representing one of your
    specified colors. This is what R actually means, in an RGB sense, when you ask
    it to plot these colors using the corresponding character string.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 结果是一个RGB值矩阵，每一列代表你指定的颜色之一。这就是R在RGB意义上，当你请求它用相应的字符字符串绘制这些颜色时的实际含义。
- en: 'These RGB triplets are frequently expressed as *hexadecimals*, a numeric coding
    system often used in computing. In R, a hexadecimal, or *hex code*, is a character
    string with a `#` followed by six alphanumeric characters: valid characters are
    the letters *A* through *F* and the digits 0 through 9\. The first pair of characters
    represents the red component, and the second and third pairs represent green and
    blue, respectively. If you have or create one or more RGB triplets, you can turn
    them into hex codes for R to use in any subsequent plotting through the `rgb`
    function. This command takes a matrix of RGB values, though note that it expects
    each (R, G, B) color to be a row of that matrix (as opposed to the columns provided
    from a call to, say, `col2rgb`).'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 这些RGB三元组通常表示为*十六进制数*，这是一种在计算机中常用的数字编码系统。在R中，十六进制或*十六进制代码*是一个字符字符串，前面跟着一个`#`，后面是六个字母数字字符：有效字符是字母*A*到*F*和数字0到9。第一个字符对表示红色分量，第二和第三个字符对分别表示绿色和蓝色。如果你有或创建一个或多个RGB三元组，你可以通过`rgb`函数将它们转换为R可以在后续绘图中使用的十六进制代码。这个命令接受一个RGB值的矩阵，但请注意，它期望每个(R,
    G, B)颜色是该矩阵的行（而不是例如通过`col2rgb`调用时提供的列）。
- en: 'You’ll also need to tell `rgb` that your maximum color value, as per the standard
    RGB format, is 255 (since by default it scales this and uses 1). The following
    code performs a matrix transpose (refer to [Section 3.3](ch03.xhtml#ch03lev1sec14))
    on the result of the previous call to `col2rgb`, putting my three colors as RGB
    triplets in the required form as rows, and specifies the `maxColorValue` accordingly:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 你还需要告诉`rgb`，根据标准的RGB格式，你的最大颜色值是255（因为默认情况下，它将此值缩放并使用1）。以下代码对之前调用`col2rgb`的结果执行矩阵转置（参见[第3.3节](ch03.xhtml#ch03lev1sec14)），将我的三种颜色作为RGB三元组以行的形式放入所需的格式，并相应地指定`maxColorValue`：
- en: '[PRE2]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The output tells you the hexadecimal codes for the RGB values R refers to with
    the names `"black"`, `"green3"`, and `"pink"`, respectively.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 输出会告诉你R所指的RGB值对应的十六进制代码，分别为“black”，“green3”和“pink”。
- en: I won’t go into the specifics of converting a standard RGB triplet to a hexadecimal
    here because it’s beyond the scope of this book, but it’s important to know that
    R represents any colors you create using RGB triplets as hex codes, so you should
    be able to at least recognize a hexadecimal when you’re working with colors and
    color palettes in plotting.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 我不会在这里详细讲解如何将标准的RGB三元组转换为十六进制，因为这超出了本书的范围，但了解R代表你使用RGB三元组创建的任何颜色作为十六进制代码是很重要的，所以当你在绘制图形时，至少应该能够识别十六进制代码。
- en: 'For an even more colorful exploration, let’s write a modest little function
    to plot points in individual colors and label them appropriately with RGB triplets
    and corresponding hex codes. Consider the following in the editor:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更丰富的探索，让我们写一个简单的函数，用单独的颜色绘制点，并用RGB三元组和相应的十六进制代码为其加上标签。请在编辑器中参考以下内容：
- en: '[PRE3]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The function `pcol` takes one argument, `cols`, intended to be a character vector
    of color names recognized by R. When you execute `pcol`, it opens a new graphics
    device and equalizes the figure margin settings to be one line on each side. A
    plot is begun, fully suppressed except for a box. This is so you can use `locator`
    (see [Section 23.3](ch23.xhtml#ch23lev1sec78)) to place points in the plot region,
    implemented in a `for` loop, one after the other. Each point represents one of
    the `cols`, and after its coordinates are returned from `locator`, `points` puts
    down a large dot of the color at hand, with `text` providing annotation to the
    right of each point achieved using `paste` (refer to [Section 4.2](ch04.xhtml#ch04lev1sec17)).
    This annotation includes the R color name, the RGB triplet, and the hex code on
    top of one another; the latter two are found using `col2rgb` and `rgb` exactly
    as demonstrated earlier.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 函数`pcol`接受一个参数`cols`，它应该是一个字符向量，包含R识别的颜色名称。当你执行`pcol`时，它会打开一个新的图形设备，并将图形边距设置为每一边各一行。一个图形开始绘制，但除了边框外，其他部分都被完全抑制。这样，你可以使用`locator`（见[第23.3节](ch23.xhtml#ch23lev1sec78)）在图形区域内逐个放置点，这通过一个`for`循环实现。每个点代表一个`cols`中的颜色，`locator`返回其坐标后，`points`会在当前位置绘制一个大的颜色点，`text`则在每个点的右侧提供注释，注释是通过`paste`实现的（参见[第4.2节](ch04.xhtml#ch04lev1sec17)）。这个注释包括R颜色名称、RGB三元组和十六进制代码，它们依次叠加在一起；后两个通过`col2rgb`和`rgb`函数获得，正如前面所演示的。
- en: The following code sets up the device, first storing 14 valid R color names
    (chosen randomly) in the character vector `mycols`. After exhausting these with
    mouse clicks in different areas of the plot region, the execution is complete.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码设置了设备，首先将14个有效的R颜色名称（随机选择）存储在字符向量`mycols`中。在通过鼠标点击不同区域消耗完这些颜色后，执行过程完成。
- en: '[PRE4]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: When I execute `pcol` as shown here, I click through the 14 points, producing
    rough columns on my graphics device. [Figure 25-1](ch25.xhtml#ch25fig1) shows
    the result.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 当我执行如这里所示的`pcol`时，我点击了14个点，在我的图形设备上生成了粗略的列。[图 25-1](ch25.xhtml#ch25fig1)展示了结果。
- en: '![image](../images/f25-01.jpg)'
  id: totrans-27
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f25-01.jpg)'
- en: '*Figure 25-1: Various named R colors alongside their corresponding RGB triplets
    and hex codes.*'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 25-1: 各种命名的R颜色及其对应的RGB三元组和十六进制代码。*'
- en: In essence, you can obtain any color you want (in other words, far more than
    the named ones that are built into R) by specifying an RGB value and obtaining
    its hex code. These hexadecimals can be supplied as is to any of the traditional
    R graphics functions where you specify color (commonly to a `col` argument). You’ll
    see this as the chapter progresses. Naturally, you can also assign a hex code
    or a vector of hex codes (for example, if you’re creating your own custom colors)
    to a new object in your R workspace so you can use it in subsequent plotting.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 实质上，你可以通过指定RGB值并获取其十六进制代码，获得任何你想要的颜色（换句话说，比R内置的命名颜色多得多）。这些十六进制数值可以直接用于任何传统的R图形函数中，在那里你指定颜色（通常是`col`参数）。随着章节的进展，你将看到这一点。当然，你也可以将一个十六进制代码或一组十六进制代码（例如，如果你正在创建自己的自定义颜色）分配给R工作区中的一个新对象，这样你就可以在后续绘图中使用它。
- en: '***25.1.2 Built-in Palettes***'
  id: totrans-30
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***25.1.2 内置调色板***'
- en: Being able to implement your own RGB colors is most useful when you need many
    colors, the collection of which is referred to as a *palette*. You’ll typically
    need a palette when color is used to describe something on a continuum, like the
    various shades of blue used for the height measurements in [Figure 24-6](ch24.xhtml#ch24fig6)
    on [page 621](ch24.xhtml#page_621).
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 当你需要许多颜色时，能够实现自己的RGB颜色是最有用的，这些颜色的集合被称为*调色板*。通常，当颜色用于描述某种连续体的事物时，你会需要一个调色板，比如在[图24-6](ch24.xhtml#ch24fig6)的[第621页](ch24.xhtml#page_621)上使用的不同蓝色阴影来表示高度测量。
- en: There are a number of color palettes built into the base R installation. These
    are defined by the functions `rainbow`, `heat.colors`, `terrain.colors`, `topo.colors`,
    `cm.colors`, `gray.colors`, and `gray`. With the exception of `gray`, you directly
    specify the number of colors you want, and they’ll be returned as a character
    vector of hex codes representing an equally spaced sequence over the entire color
    range of that particular palette.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 基础R安装中内置了多个颜色调色板。这些由函数`rainbow`、`heat.colors`、`terrain.colors`、`topo.colors`、`cm.colors`、`gray.colors`和`gray`定义。除了`gray`之外，你可以直接指定所需颜色的数量，它们将作为一个包含十六进制代码的字符向量返回，表示该调色板整个颜色范围内等间距的颜色序列。
- en: 'It’s easiest to see this in action with a visualization. The following code
    generates exactly 600 colors from each palette:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 最容易通过可视化效果来查看这一点。以下代码从每个调色板中生成恰好600种颜色：
- en: '[PRE5]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Note that instead of a single integer, `gray` expects a numeric vector of values
    between 0 (total black) and 1 (total white) to provide a grayscale. Its counterpart
    function, `gray.colors`, works the same as the other built-in palettes but defaults
    to a slightly narrower visual range between the extremes of black and white. These
    can be reset using the optional arguments `start` and `end`, which you’ll see
    shortly.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，`gray`期望的是一个介于0（完全黑）和1（完全白）之间的数值向量来提供灰度，而不是一个单一的整数。它的对应函数`gray.colors`的工作原理与其它内置调色板相同，但默认的视觉范围稍微窄一些，位于黑与白之间的极限。这些可以通过可选参数`start`和`end`来重置，稍后你会看到。
- en: The next code chunk uses skills from [Chapter 23](ch23.xhtml#ch23) to initialize
    a new plot and uses vector repetition to place 600 points for each palette in
    a single call to `points`, coloring them appropriately as per the vectors of hex
    codes.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来的代码块使用了[第 23 章](ch23.xhtml#ch23)中的技巧，初始化了一个新的图形，并使用向量重复将600个点放置到`points`函数的一次调用中，根据十六进制代码向量为这些点着色。
- en: '[PRE6]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '[Figure 25-2](ch25.xhtml#ch25fig2) shows the result.'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 25-2](ch25.xhtml#ch25fig2)展示了结果。'
- en: '![image](../images/f25-02.jpg)'
  id: totrans-39
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f25-02.jpg)'
- en: '*Figure 25-2: Showcasing the color ranges of the built-in palettes, with default
    limits used in* `gray.colors`.'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 25-2：展示了内置调色板的颜色范围，使用的是`gray.colors`的默认限制。*'
- en: For more information, access the help files `?gray.colors` and `?gray` for the
    respective grayscale palettes, with the others all appearing under `?rainbow`.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 欲了解更多信息，请访问帮助文件`?gray.colors`和`?gray`，了解各自的灰度调色板，其它的则都在`?rainbow`中。
- en: '***25.1.3 Custom Palettes***'
  id: totrans-42
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***25.1.3 自定义调色板***'
- en: You’re not restricted to the ready-to-use color designs. The function `colorRampPalette`
    allows you to create your own palettes; you supply two or more desired key colors
    to an argument of the same name, and it creates a palette that transitions between
    them. The result of a call to `colorRampPalette` is itself a function—one that
    behaves exactly like the built-in palette functions noted earlier.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 你并不局限于使用现成的颜色设计。函数`colorRampPalette`允许你创建自己的调色板；你只需为同名参数提供两个或更多的期望关键颜色，它就会创建一个在这些颜色之间过渡的调色板。调用`colorRampPalette`的结果本身就是一个函数——其行为与前面提到的内置调色板函数完全相同。
- en: 'Let’s say you’d like to be able to generate colors on a scale between purple
    and yellow. You specify the key colors to be interpolated, in the desired order,
    as a character vector of names from the collection that R recognizes. The following
    line creates this palette function:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你希望能够在紫色和黄色之间生成颜色。你需要指定要插值的关键颜色，并按所需的顺序将它们作为字符向量的名称，选择 R 所识别的颜色集合中的名称。以下代码行创建了这个调色板函数：
- en: '[PRE7]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Let’s create another one, this time picking one that will show up a little clearer
    in case a color plot that ends up using it is printed in grayscale (in which case
    sticking to monochromatic palettes is a good idea).
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们再创建一个，这次选择一个颜色稍微清晰一些的调色板，以防使用它的颜色图打印为灰度图（在这种情况下，使用单色调色板是个好主意）。
- en: '[PRE8]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Here are a couple more, using more than two colors this time:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有更多的示例，这次使用了超过两种颜色：
- en: '[PRE9]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Having created a handful of custom palette functions, you can now generate any
    number of colors from each range just like before (done here using the previously
    stored `N` value of 600 each). After doing so, you can adapt the earlier plotting
    code to get the image in [Figure 25-3](ch25.xhtml#ch25fig3).
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 创建了一些自定义调色板函数后，你现在可以像以前一样从每个范围中生成任意数量的颜色（这里使用之前存储的`N`值，即每个600个）。完成后，你可以调整之前的绘图代码，得到[图
    25-3](ch25.xhtml#ch25fig3)中的图像。
- en: '[PRE10]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '![image](../images/f25-03.jpg)'
  id: totrans-52
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f25-03.jpg)'
- en: '*Figure 25-3: Some examples of custom color palettes created using* `colorRampPalette`.'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 25-3：一些使用`colorRampPalette`创建的自定义颜色调色板示例。*'
- en: '***25.1.4 Using Color Palettes to Index a Continuum***'
  id: totrans-54
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***25.1.4 使用颜色调色板对连续值进行索引***'
- en: 'You’ve now seen a few times how color can be used to identify groups based
    on a categorical variable (the data corresponding to a certain level are simply
    given a distinct color from the others), which is pretty easy to do. However,
    assigning colors appropriately to values on a continuum requires a little more
    thought. There are two methods for this: through categorization or through normalization
    of your continuous values. Let’s look first at the former approach.'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 你已经多次看到如何使用颜色来根据分类变量标识组（属于某一特定级别的数据简单地被赋予一个与其他数据不同的颜色），这其实很容易实现。然而，给连续值适当地分配颜色则需要更多的思考。为此有两种方法：通过分类或通过标准化连续值。我们首先来看第一种方法。
- en: '**Via Categorization**'
  id: totrans-56
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**通过分类**'
- en: One way to color values according to a continuous variable is to turn it into
    the familiar problem of coloring points of a categorical variable. You can do
    this by binning your continuous values into a fixed number of *k* categories,
    generating *k* colors from your palette, and matching each observation to the
    appropriate color based on the bin it falls into.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 根据连续变量为值着色的一种方法是将其转化为为分类变量着色的熟悉问题。你可以通过将连续值分箱为固定数量的*k*类，从你的调色板中生成*k*种颜色，并根据每个观测值所属的箱子匹配相应的颜色。
- en: 'In [Section 20.1](ch20.xhtml#ch20lev1sec62), you plotted height against writing
    handspan for the `survey` data from the `MASS` package. This time, let’s use color
    to additionally inform the nonwriting handspan variable. Load the package and
    execute the following line:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第20.1节](ch20.xhtml#ch20lev1sec62)，你绘制了来自`MASS`包的`survey`数据的身高与书写手跨度之间的关系。这一次，我们使用颜色来额外表达非书写手跨度变量。加载该包并执行以下代码：
- en: '[PRE11]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: This creates the data frame object `surv`, which is made up of only the three
    required columns. Any rows with missing values are removed via a call to `na.omit`
    (refer to [Section 6.1.3](ch06.xhtml#ch06lev2sec57)).
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 这将创建数据框对象`surv`，它只包含三个必要的列。通过调用`na.omit`去除所有包含缺失值的行（参见[第6.1.3节](ch06.xhtml#ch06lev2sec57)）。
- en: Now, the first thing to do is decide on your color palette.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，首先要做的是决定你的调色板。
- en: '[PRE12]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: This will generate colors that go from a dark, dull red at the lower end of
    the scale to a slightly faded yellow at the higher end (similar to the builtin
    `heat.colors` palette; see [Figure 25-2](ch25.xhtml#ch25fig2)). Next, you need
    to decide how many bins, *k*, you’re going to construct for the continuous values.
    This determines how many distinct colors to generate from `NW.pal`. For these
    data, set *k* = 5.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 这将生成从比例尺下端的深暗红色到上端稍微褪色的黄色的颜色（类似于内置的`heat.colors`调色板；见[图25-2](ch25.xhtml#ch25fig2)）。接下来，你需要决定你将为连续值构建多少个箱子，*k*。这将决定从`NW.pal`生成多少种不同的颜色。对于这些数据，设置*k*
    = 5。
- en: '[PRE13]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Your five `NW.pal` colors, as hex codes, are available. Next, you need to actually
    bin the continuous values, which you can do using `cut`. First you need to set
    *k* + 1 break points for the bins (refer to [Section 4.3.3](ch04.xhtml#ch04lev2sec48)
    for a refresher), using `seq`.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 你的五种`NW.pal`颜色，作为十六进制代码，已经准备好。接下来，你需要实际对连续值进行分箱，可以使用`cut`来实现。首先，你需要设置*k* + 1个分割点（参见[第4.3.3节](ch04.xhtml#ch04lev2sec48)复习），使用`seq`。
- en: '[PRE14]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The six equally spaced values span the range of the students’ nonwriting handspans,
    delineating your five intended bins. Then `cut` factorizes the nonwriting handspans
    with respect to those bins. You can use `as.numeric` to specifically return the
    indexes for extracting the appropriate color for each observation from your five
    ordered hex codes in `ryc` (full output is suppressed here for reasons of print).
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 六个等距的值跨越学生的非书写手的跨度范围，划定了你的五个目标箱子。然后，`cut`根据这些箱子对非书写手的跨度进行因子化。你可以使用`as.numeric`特意返回索引，以从`ryc`中的五个有序十六进制代码提取每个观测值的适当颜色（由于打印原因，这里省略了完整输出）。
- en: '[PRE15]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'You’re ready to plot; the result of the following is given on the left of [Figure
    25-4](ch25.xhtml#ch25fig4):'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 你已经准备好绘图；以下结果见[图25-4](ch25.xhtml#ch25fig4)左侧：
- en: '[PRE16]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: '![image](../images/f25-04.jpg)'
  id: totrans-71
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f25-04.jpg)'
- en: '*Figure 25-4: Illustrating two ways to assign color to points based on a continuous
    value: via categorization (left) and via normalization (right)*'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: '*图25-4：展示两种根据连续值为点着色的方法：通过分类（左）和通过归一化（右）*'
- en: '**Via Normalization**'
  id: totrans-73
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**通过归一化**'
- en: Using categorization to index a continuum with color is a little unsophisticated.
    There are plenty of ways you can bin your observations, for example, so your plot
    might look very different from the same plot designed by someone else. In a computational
    sense, it’s more accurate (not to mention elegant) to leave your continuous data
    as is.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 使用分类法通过颜色为连续值进行索引有点过于简单。你可以通过多种方式将观测值分箱，例如，你的图可能与另一个人设计的相同图表看起来完全不同。从计算的角度来看，保留你的连续数据不变是更准确（更优雅）的做法。
- en: 'Recall the built-in `gray` palette mentioned in [Section 25.1.2](ch25.xhtml#ch25lev2sec243).
    This function behaved a little differently from the others. Instead of simply
    asking for a number of colors from the specified palette, you’re required to provide
    a numeric vector of values to tell R, on a continuous scale from 0 through 1,
    how “far along” the palette to go. This type of behavior suits the current task
    perfectly, since your raw data are also on a continuous scale. To implement it,
    you need two things: a way to create a palette that will behave like `gray` and
    a *normalized* version of your continuous values that fall within the acceptable
    standardized range of 0 to 1 inclusive.'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 回想一下[第25.1.2节](ch25.xhtml#ch25lev2sec243)中提到的内置`gray`调色板。这个函数的行为与其他函数略有不同。它不是简单地要求你从指定的调色板中选择颜色数量，而是要求你提供一个数值向量，以告知
    R 在从 0 到 1 的连续范围内，调色板“走多远”。这种行为非常适合当前的任务，因为你的原始数据也是连续的。为了实现这一点，你需要两样东西：一种能够像`gray`一样行为的调色板，以及一个*归一化*后的连续值版本，这些值必须落在
    0 到 1 的标准化范围内（包括 0 和 1）。
- en: 'The `colorRamp` function allows you to create your palette and is used in the
    same way as `colorRampPalette`, but the result is a color palette function that
    expects a numeric vector as stated. You’ll see that in a moment. To transform
    a collection of *n* original values {*x*[1], ..., *x*[n]} to, say, {*z*[1], ...,
    *z*[n]}, where 0 ≤ *z[i]* ≤ 1; *i* = 1, ..., *n*, you can employ the following
    equation:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: '`colorRamp`函数允许你创建调色板，并且与`colorRampPalette`的用法相同，但返回的结果是一个颜色调色板函数，期望输入一个数值向量。你将很快看到这一点。为了将一组原始值
    {*x*[1], ..., *x*[n]} 转换为，比如说， {*z*[1], ..., *z*[n]}，其中 0 ≤ *z[i]* ≤ 1；*i* = 1,
    ..., *n*，你可以使用以下公式：'
- en: '![image](../images/e25-1.jpg)'
  id: totrans-77
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/e25-1.jpg)'
- en: 'Let’s make that an R function by writing the following in the R editor:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过在 R 编辑器中编写以下代码将其转化为一个 R 函数：
- en: '[PRE17]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Based on a vector `datavec` as its only argument, `normalize` implements [Equation
    (25.1)](ch25.xhtml#ch25eq1), using the optional `na.rm` argument to ensure any
    missing values in `datavec` don’t contaminate the calculation of the minimum and
    maximum values (see [Section 13.2.1](ch13.xhtml#ch13lev2sec116)).
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 基于 `datavec` 向量作为唯一参数，`normalize` 实现了[公式 (25.1)](ch25.xhtml#ch25eq1)，使用可选的 `na.rm`
    参数来确保 `datavec` 中的任何缺失值不会污染最小值和最大值的计算（见[第13.2.1节](ch13.xhtml#ch13lev2sec116)）。
- en: 'Import `normalize` and enter the following, which shows the original nonwriting
    handspan values (from the object `surv` you created earlier) and their corresponding
    normalized values (output snipped for brevity):'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 导入 `normalize`，并输入以下代码，它展示了原始的非书写手跨度值（来自你之前创建的 `surv` 对象）及其对应的归一化值（为了简洁，输出被省略）：
- en: '[PRE18]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Now, you need to create a new version of the color palette with `colorRamp`.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你需要使用`colorRamp`创建一个新的颜色调色板版本。
- en: '[PRE19]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Generate the corresponding colors for each observation based on the normalized
    data.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 根据归一化数据为每个观测值生成相应的颜色。
- en: '[PRE20]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: If you actually look at the returned object in `ryc2`, you’ll note it’s a matrix
    of RGB triplets corresponding to each normalized value you supplied to your `colorRamp`
    function `NW.pal2` (noninteger values end up being coerced to integers). These
    need to be converted to hex codes before you can use them in plotting. Using `rgb`
    just as you saw in [Section 25.1.1](ch25.xhtml#ch25lev2sec242), you get the vector
    you need (snipped for print).
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你实际查看`ryc2`中返回的对象，你会注意到它是一个 RGB 三元组矩阵，对应于你提供给`colorRamp`函数`NW.pal2`的每个归一化值（非整数值最终会被强制转换为整数）。在你将它们用于绘图之前，需要将这些值转换为十六进制代码。像在[第25.1.1节](ch25.xhtml#ch25lev2sec242)中看到的那样，使用`rgb`函数，你将得到所需的向量（为打印简洁，已省略）。
- en: '[PRE21]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Note the difference between the hex codes you obtain here in `NW.cols2` and
    those in `NW.cols`. Here, you get a hex code for each unique value, but for the
    categorized `NW.cols`, you have only one hex code for each bin (so just *k* =
    5 colors).
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 注意你在`NW.cols2`中获得的十六进制代码和在`NW.cols`中获得的十六进制代码之间的差异。在这里，你为每个独特的值获取一个十六进制代码，但对于分类后的`NW.cols`，你每个分箱只有一个十六进制代码（所以只有*k*
    = 5种颜色）。
- en: This line produces the image on the right of [Figure 25-4](ch25.xhtml#ch25fig4).
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 这一行生成了[图 25-4](ch25.xhtml#ch25fig4)右侧的图像。
- en: '[PRE22]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: In terms of this relatively simple example, the visual difference between the
    two approaches is minimal, though looking closely you can indeed pick out the
    smoother color transition in the normalized version. As you increase *k* when
    using the categorization technique, the visual result will become closer to that
    of the normalization approach. That said, the normalization approach should generally
    be preferred, since it more closely fits the continuous nature of the values you’re
    trying to visualize, and it works more effectively for values with a skewed distribution
    or when you’re working with a complex color palette.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 就这个相对简单的例子而言，两种方法之间的视觉差异很小，尽管仔细观察，你确实可以辨认出归一化版本中更平滑的颜色过渡。当你增加 *k* 值时，使用分类技术的视觉效果将越来越接近归一化方法。然而，通常应优先选择归一化方法，因为它更贴合你想要可视化的值的连续特性，并且对于分布偏斜的值或使用复杂色板时更为有效。
- en: '***25.1.5 Including a Color Legend***'
  id: totrans-93
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***25.1.5 包含颜色图例***'
- en: Now that you can use color to significant effect in your plots, you need a legend
    to reference the color scale. It’s possible to create a legend using base R tools
    alone, but it can be simpler to use contributed functionality in R instead.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你可以在图形中有效使用颜色，你需要一个图例来参考颜色尺度。尽管使用基础 R 工具也可以创建图例，但使用 R 中的贡献功能通常会更简单。
- en: 'One useful function for this is the `colorlegend` command. This is found in
    the `shape` package ([Soetaert, 2014](ref.xhtml#ref62)), so first download and
    install `shape` from CRAN. The following code then loads the package, reproduces
    the most recent plot (based on the `surv` object created earlier and shown on
    the right of [Figure 25-4](ch25.xhtml#ch25fig4)) with some tidier axis titles,
    and draws the color strip legend:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 一个有用的函数是 `colorlegend` 命令。这个函数位于 `shape` 包中（[Soetaert, 2014](ref.xhtml#ref62)），因此首先需要从
    CRAN 下载并安装 `shape` 包。接下来的代码将加载该包，重新绘制最近的图形（基于之前创建的 `surv` 对象，并显示在[图 25-4](ch25.xhtml#ch25fig4)的右侧），并绘制颜色条图例：
- en: '[PRE23]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: This result is given on the left of [Figure 25-5](ch25.xhtml#ch25fig5).
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 这个结果见于[图 25-5](ch25.xhtml#ch25fig5)的左侧。
- en: The `colorlegend` functions assumes that you already have a plot present in
    an active graphics device, so you need to have one created first. The first thing
    you supply to `colorlegend` is the color span of the values you want to reference.
    This is easiest with a color palette function like those listed in the help file
    `?rainbow` or created using `colorRampPalette`—in other words, a function that
    takes an integer value telling it how many colors to generate. Doing so with a
    large number of colors gives you a smooth color strip, so I use `NW.pal(200)`.
    Next, you provide `colorlegend` with the range of the values that will be referenced
    by the legend using `zlim`, in this case, the range of the nonwriting handspans
    `range(surv$NW.Hnd)`. The `zval` argument takes in the values that you want to
    mark off on the legend. The values of a sequence between 13 and 23, in steps of
    2, are marked off.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: '`colorlegend` 函数假设你已经在活动的图形设备中创建了一个图形，因此你需要先创建一个图形。你传递给 `colorlegend` 的第一个参数是你想要参考的值的颜色范围。使用像
    `?rainbow` 帮助文件中列出的颜色调色板函数或通过 `colorRampPalette` 创建的函数最为简便——换句话说，一个接受整数值的函数，告诉它需要生成多少种颜色。使用大量颜色时，可以得到平滑的色带，因此我使用
    `NW.pal(200)`。接下来，使用 `zlim` 为 `colorlegend` 提供一个值的范围，这个值将被图例所参考，在这个例子中，是非写手手势的范围
    `range(surv$NW.Hnd)`。`zval` 参数接受你希望在图例上标记的值。一个从 13 到 23，步长为 2 的序列被标记了出来。'
- en: '![image](../images/f25-05.jpg)'
  id: totrans-99
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f25-05.jpg)'
- en: '*Figure 25-5: Two examples of implementing a color strip legend using the*
    `colorlegend` *function from the contributed* `shape` *package*'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 25-5：使用来自贡献包* `shape` *的* `colorlegend` *函数实现颜色条图例的两个例子*'
- en: The positioning and sizing of the color legend are done using the `posx` and
    `posy` arguments. Rather than taking user coordinates, each of these must be a
    vector of length 2 describing, in *relative device coordinates*, the horizontal
    (`posx`) and vertical (`posy`) lengths of the strip. In this example, `posx=c(0.3,0.33)`
    tells the function to draw the width of the legend from 30 percent of the left
    of the device to 33 percent so that the width is 3 percent of the overall device
    and positioned to the left of the center. Setting `posy=c(0.5,0.9)` says you want
    the length of the strip to span 40 percent of the device, from 50 percent of the
    way up from the bottom to 90 percent and up. Lastly, you can add the title to
    the legend by supplying a character string to `main`.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 颜色图例的位置和大小是通过`posx`和`posy`参数来控制的。这两个参数并非使用用户坐标，而是必须是一个长度为2的向量，在*相对设备坐标*下描述条形的水平（`posx`）和垂直（`posy`）长度。在这个例子中，`posx=c(0.3,0.33)`指示函数从设备左侧的30%到33%之间绘制图例的宽度，使得宽度占整个设备的3%，并且位置靠左于中心。设置`posy=c(0.5,0.9)`表示你希望条形的长度覆盖设备的40%，从底部50%的位置到90%之间。最后，你可以通过向`main`提供一个字符字符串为图例添加标题。
- en: You’ll probably need to experiment a bit in a trial-and-error fashion to get
    the positioning and sizing (and appropriate tick marks using `zval`) you want.
    The device-specific nature of `posx` and `posy` means that if you resize your
    device, you might well need to reevaluate the values of these arguments.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能需要通过试验和错误的方式来调整图例的位置、大小（以及使用`zval`设置适当的刻度标记）。`posx`和`posy`的设备特定性意味着如果你重新调整设备大小，可能需要重新评估这些参数的值。
- en: If you wanted the legend to appear outside the default plot region, you could
    easily use the `xlim` argument in the initial call to `plot` to widen the horizontal
    size of the plot, giving you extra space to draw a full-length legend. Alternatively,
    you could’ve changed the figure or outer margin spacing (refer to [Section 23.2](ch23.xhtml#ch23lev1sec77))
    to give you enough room to put the legend outside the plot region. This next chunk
    of code does just that by widening the right margin, replotting the scatterplot,
    and inserting a color legend into that extra space.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你希望图例出现在默认绘图区域之外，可以很容易地在第一次调用`plot`时使用`xlim`参数来加宽绘图的横向大小，从而为绘制完整的图例腾出额外的空间。或者，你也可以通过调整图形或外边距的间距（参考[第23.2节](ch23.xhtml#ch23lev1sec77)）来为图例腾出足够的空间，使其出现在绘图区域之外。以下代码段通过加宽右边距、重新绘制散点图，并将颜色图例插入到额外的空间中，完成了这一操作。
- en: '[PRE24]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: The result is given on the right of [Figure 25-5](ch25.xhtml#ch25fig5). The
    legend is narrower than before, taking up only 2 percent of the device width on
    the right with `posx=c(0.89,0.91)`. With no specification of `posy`, `colorlegend`
    has used the default of `c(0.05,0.9)`, giving a color strip that spans almost
    the entire height of the device. The tick marks and labeling of the new legend
    are now placed in increments of 1 from 13.5 to 22.5; note that to display decimal
    places (in other words, *significant digits*), you need to increase the `digit`
    argument from its default, `0`, to reveal them. Here, `digit=1` prints the tick
    mark labels to one decimal place.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 结果如[图25-5](ch25.xhtml#ch25fig5)右侧所示。图例比之前更窄，右侧仅占设备宽度的2%，`posx=c(0.89,0.91)`。由于没有指定`posy`，`colorlegend`使用了默认值`c(0.05,0.9)`，这使得颜色条几乎覆盖了设备的整个高度。新图例的刻度标记和标签现在以1为增量，范围从13.5到22.5；请注意，要显示小数位数（也就是说，*有效数字*），你需要将`digit`参数从默认值`0`调整为其他值。在此，`digit=1`将刻度标签显示为一位小数。
- en: There are more properties that you can control with these legends, including
    labeling style and tick mark positioning; see the `?colorlegend` help file for
    details. You may also like to investigate the similarly named function `color.legend`
    in the contributed `plotrix` package ([Lemon, 2006](ref.xhtml#ref40)) for a slightly
    different take on drawing color legends on existing R plots.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以控制这些图例的更多属性，包括标签样式和刻度标记的位置；有关详细信息，请参阅`?colorlegend`帮助文件。你也可以考虑查看贡献的`plotrix`包中同名的函数`color.legend`（[Lemon,
    2006](ref.xhtml#ref40)），它提供了一种稍微不同的方法来绘制现有R图上的颜色图例。
- en: '***25.1.6 Opacity***'
  id: totrans-107
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***25.1.6 不透明度***'
- en: Another useful skill is the ability to specify the opacity of any of the colors
    and color palettes discussed so far. All functions that provide the user with
    hex codes have an optional argument `alpha`, the valid range of which depends
    on the function (a quick check of the corresponding documentation will tell you).
    For example, the `rgb` function uses `maxColorValue` to set the upper bound on
    opacity, and palette functions like `rainbow` all use the normalized range from
    0 through 1 (just like in the `ggplot2` plots created throughout [Chapter 24](ch24.xhtml#ch24)).
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个有用的技能是能够指定迄今为止讨论的任何颜色和色板的透明度。所有提供十六进制代码的函数都有一个可选参数 `alpha`，其有效范围取决于函数（你可以快速查阅相关文档了解详细信息）。例如，`rgb`
    函数使用 `maxColorValue` 来设定透明度的上限，而像 `rainbow` 这样的色板函数都使用 0 到 1 之间的标准化范围（就像在 [第 24
    章](ch24.xhtml#ch24) 中创建的 `ggplot2` 图表一样）。
- en: 'By default, R assumes full opacity when you’re creating colors. However, hex
    codes change slightly when opacity is explicitly set using `alpha`. Rather than
    six characters after the `#`, eight will appear, with the last two containing
    the additional opacity information. Consider the following lines of code, which
    generate four different versions of red: default, zero opacity, 40 percent opacity
    (0.4 × 255 = 102), and full opacity, respectively:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，R 在创建颜色时假定完全不透明。然而，当显式设置透明度时，十六进制代码会略有变化。此时，`#` 后面将不再是六个字符，而是八个字符，最后两个字符包含额外的透明度信息。考虑以下代码行，它们分别生成了四种不同版本的红色：默认、不透明度为零、40%
    不透明度（0.4 × 255 = 102）和完全不透明：
- en: '[PRE25]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Note that the first and last colors are identical; it’s just that the last hex
    code explicitly specifies full opacity.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，第一种和最后一种颜色是相同的；只是最后一个十六进制代码明确指定了完全不透明。
- en: 'You can always adjust the opacity of any color you’ve already got with the
    `alpha.f` argument (which takes values in the range 0 through 1) of the ready-to-use
    `adjustcolor` function. The following line takes the default red hex code created
    by the first line in the previous example and turns it into a 40 percent opaque
    version (the third line in the previous code):'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过 `alpha.f` 参数（该参数的取值范围是 0 到 1）调整任何已有颜色的透明度，该参数属于随时可用的 `adjustcolor` 函数。以下代码将前一个示例中创建的默认红色十六进制代码转化为
    40% 不透明的版本（即前面代码中的第三行）：
- en: '[PRE26]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: You briefly came across this command already in [Section 24.2.1](ch24.xhtml#ch24lev2sec238),
    when creating a transparent gray confidence interval for a LOESS-smoothed trend
    using base R graphics. This approach is also applicable to hex codes generated
    after you’ve used a built-in or custom palette function to obtain a vector of
    colors.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 你已经在 [第 24.2.1 节](ch24.xhtml#ch24lev2sec238) 中简要接触过此命令，当时你使用基础 R 图形绘制了一个 LOESS
    平滑趋势的透明灰色置信区间。该方法同样适用于使用内置或自定义色板函数生成的十六进制代码，以获得颜色向量。
- en: You’ll put opacity to the test using the built-in `quakes` data frame, which
    consists of data on 1,000 seismic events near Fiji. Let’s re-create the plot in
    [Figure 13-6](ch13.xhtml#ch13fig6) on [page 284](ch13.xhtml#page_284) showing
    “number of detecting stations” against “event magnitude” and dress it up using
    color to identify the continuous “depth” data. Since there are many overlapping
    observations, reducing opacity of the individual points would be a good idea for
    visualization. The code
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 你将通过内置的 `quakes` 数据框进行透明度测试，该数据框包含关于斐济附近 1,000 个地震事件的数据。我们来重新创建 [图 13-6](ch13.xhtml#ch13fig6)
    中的图表，该图显示了“检测站数量”与“事件震级”之间的关系，并通过颜色来识别连续的“深度”数据。由于有许多重叠的观测点，因此降低每个点的透明度对可视化是一个不错的选择。代码如下：
- en: '[PRE27]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'sets up a custom three-color palette both ways (in other words, as a function
    expecting an integer, `depth.pal`, and as a function expecting a value between
    0 and 1, `depth.pal2`; refer to [Sections 25.1.3](ch25.xhtml#ch25lev2sec244) and
    [25.1.4](ch25.xhtml#ch25lev2sec245)). Then, the following line uses the normalization
    approach, with the `normalize` function defined in [Section 25.1.4](ch25.xhtml#ch25lev2sec245),
    to obtain the appropriate colors for the points to be plotted, according to the
    “depth” variable of the data set:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 设置一个自定义的三色调色板，支持两种方式（换句话说，作为一个期望整数的函数 `depth.pal` 和作为一个期望介于 0 和 1 之间值的函数 `depth.pal2`；参考
    [第 25.1.3 节](ch25.xhtml#ch25lev2sec244) 和 [25.1.4 节](ch25.xhtml#ch25lev2sec245)）。接下来，以下代码行使用标准化方法，通过在
    [第 25.1.4 节](ch25.xhtml#ch25lev2sec245) 中定义的 `normalize` 函数，根据数据集的“深度”变量获得适当的颜色，用于绘制图上的点：
- en: '[PRE28]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'The request for 60 percent opacity is made through `alpha` in the call to `rgb`.
    You can create the plot with the following call, which assigns the colors stored
    in `depth.cols`:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 60% 不透明度的请求是通过调用 `rgb` 时的 `alpha` 参数来实现的。你可以使用以下调用来创建图表，该调用将颜色存储在 `depth.cols`
    中：
- en: '[PRE29]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'This plot affords another opportunity to showcase the `colorlegend` function
    from the `shape` package. Assuming you have `shape` already loaded in the current
    R session, the next line draws a corresponding color legend inside the plot region
    (on a default-size device):'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 这个图表提供了另一个机会来展示 `shape` 包中的 `colorlegend` 函数。假设你已经在当前 R 会话中加载了 `shape`，接下来的代码行将在图表区域内绘制一个相应的颜色图例（在默认大小的设备上）：
- en: '[PRE30]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Here you can see another demonstration of the use of `adjustcolor`, where the
    color sequence generated with the call to `depth.pal(20)` is then reduced to 60
    percent opacity to match the plotted points. Again, `posx` and `posy` are used
    to position the legend, and the optional logical argument `left` is set to `TRUE`
    to make the tick marks and color legend labels appear on the left side of the
    strip. [Figure 25-6](ch25.xhtml#ch25fig6) shows the final result.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 这里你可以看到另一个 `adjustcolor` 的使用示例，其中通过调用 `depth.pal(20)` 生成的颜色序列随后被减少到 60% 的不透明度，以匹配绘制的点。同样，`posx`
    和 `posy` 用于定位图例，且可选的逻辑参数 `left` 被设置为 `TRUE`，使得刻度标记和颜色图例标签显示在条形的左侧。[图 25-6](ch25.xhtml#ch25fig6)
    显示了最终结果。
- en: '![image](../images/f25-06.jpg)'
  id: totrans-124
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f25-06.jpg)'
- en: '*Figure 25-6: Altering the color opacity in a custom palette, used to index
    the continuous “event depth” observations in a plot of “number of stations” against
    “magnitude” for the* `quakes` *data set, and a corresponding color legend using*
    `colorlegend` *from the* `shape` *package*'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 25-6：在自定义调色板中改变颜色不透明度，用于在“站点数量”与“震级”图中索引连续的“事件深度”观察，并使用 `shape` 包中的 `colorlegend`
    绘制相应的颜色图例*'
- en: '***25.1.7 RGB Alternatives and Further Functionality***'
  id: totrans-126
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***25.1.7 RGB 替代方案与进一步的功能***'
- en: RGB triplets aren’t the only way color can be represented in R. Other specifications
    include hue-saturation-value (HSV) and hue-chroma-luminance (HCL), available through
    the built-in `hsv` and `hcl` functions. These work in much the same way as `rgb`,
    where you specify the strength of influence of the three components and out pop
    corresponding character string hex codes that form valid R colors for any relevant
    plotting command. In fact, the HSV parameterization is what’s used internally
    by the built-in palettes detailed in [Section 25.1.2](ch25.xhtml#ch25lev2sec243),
    such as `rainbow` and `heat.colors`.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: RGB 三元组并不是 R 中表示颜色的唯一方式。其他的表示方法包括色相-饱和度-明度（HSV）和色相-色度-亮度（HCL），这些可以通过内置的 `hsv`
    和 `hcl` 函数来实现。这些方法的工作原理与 `rgb` 类似，你指定三种成分的影响强度，随后会得到相应的字符字符串十六进制代码，这些代码可以形成有效的
    R 颜色，用于任何相关的绘图命令。实际上，HSV 参数化是内置调色板的实现方式，如 [第 25.1.2 节](ch25.xhtml#ch25lev2sec243)中详细介绍的
    `rainbow` 和 `heat.colors`。
- en: Contributed functionality offers even more flexibility. The `colorspace` package
    ([Ihaka et al., 2015](ref.xhtml#ref34)), which translates between different color
    formats, is worth noting, as is `RColorBrewer` ([Neuwirth, 2014](ref.xhtml#ref51)),
    which is based directly on the well-received color schemes designed by Cynthia
    Brewer (see *[http://colorbrewer2.org/](http://colorbrewer2.org/)*). `RColorBrewer`
    provides more options for creating palettes than are supplied by the built-in
    functionality `colorRampPalette` and `colorRamp`. That said, from an introductory
    perspective, you should find the use of RGB and the base R functionality as discussed
    here sufficient for most visual explorations of your data and models.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 贡献的功能提供了更大的灵活性。`colorspace` 包（[Ihaka 等，2015](ref.xhtml#ref34)）可以在不同的颜色格式之间转换，值得注意，`RColorBrewer`（[Neuwirth,
    2014](ref.xhtml#ref51)）也值得一提，它直接基于 Cynthia Brewer 设计的广受好评的颜色方案（见 *[http://colorbrewer2.org/](http://colorbrewer2.org/)*）。`RColorBrewer`
    提供了比内置功能 `colorRampPalette` 和 `colorRamp` 更多的调色板选项。也就是说，从入门的角度来看，你会发现这里讨论的 RGB
    和基础 R 功能对于大多数数据和模型的可视化探索来说已经足够。
- en: '**Exercise 25.1**'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: '**练习 25.1**'
- en: 'Ensure the `car` package is loaded. Revisit the `Salaries` data frame you looked
    at in [Exercises 24.1](ch24.xhtml#ch24exc1) ([page 622](ch24.xhtml#page_622))
    and [24.2](ch24.xhtml#ch24exc2) ([page 628](ch24.xhtml#page_628)) and take a look
    at the help file `?Salaries` to remind yourself of the variables. Your task is
    to use color, point size, opacity, and point character type to reflect “years
    since Ph.D.,” “sex,” and “rank” in a scatterplot of “salary” against “years of
    service,” by completing the following steps:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 确保已加载`car`包。重新访问你在[练习24.1](ch24.xhtml#ch24exc1)（[第622页](ch24.xhtml#page_622)）和[24.2](ch24.xhtml#ch24exc2)（[第628页](ch24.xhtml#page_628)）中查看过的`Salaries`数据框，并查看帮助文件`?Salaries`以提醒自己有关变量的信息。你的任务是使用颜色、点大小、透明度和点字符类型，在“薪水”与“服务年限”的散点图中，反映“获得博士学位的年数”、“性别”和“职级”，完成以下步骤：
- en: Set up a custom color palette that goes from `"black"` to `"red"` to `"yellow2"`.
    Create two versions of this palette—one that expects a number of colors and one
    that expects a vector of normalized values between 0 and 1.
  id: totrans-131
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 设置一个自定义色板，从`"black"`到`"red"`再到`"yellow2"`。创建两个版本的色板——一个期望多个颜色，另一个期望一个在0和1之间的标准化值向量。
- en: Create two vectors that will control point character and character expansion
    following the guidelines in (i) and (ii). Each of these can be achieved in a single
    line by vector subsetting/repetition based on a numeric coercion of the corresponding
    factor vector in the data frame.
  id: totrans-132
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建两个向量，用来控制点字符和字符扩展，遵循（i）和（ii）的指南。每个向量都可以通过根据数据框中相应因子向量的数值强制转换来进行子集/重复操作，在一行中完成。
- en: Use the point characters `19`, `17`, and `15` to reference the three increasing
    academic ranks in that order.
  id: totrans-133
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用点字符`19`、`17`和`15`依次引用三个递增的学术职级。
- en: Use a character expansion of `1` for females and a character expansion of `1.5`
    for males.
  id: totrans-134
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为女性使用字符扩展`1`，为男性使用字符扩展`1.5`。
- en: Use the `normalize` function defined in [Section 25.1.4](ch25.xhtml#ch25lev2sec245)
    to create a [0,1] normalized version of the range of values of the “years since
    Ph.D.” variable. Then use the appropriate palette from (a) along with `rgb` to
    convert these to the required hex codes.
  id: totrans-135
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用[第25.1.4节](ch25.xhtml#ch25lev2sec245)中定义的`normalize`函数，创建一个“获得博士学位年数”变量的[0,1]标准化版本。然后，使用（a）中的适当色板，并结合`rgb`将这些值转换为所需的十六进制代码。
- en: Modify the vector of colors you just created in (c), adjusting opacity. Colors
    in the vector that correspond to females should be reduced to 90 percent opacity;
    colors that correspond to males should be reduced to 30 percent opacity.
  id: totrans-136
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 修改你在（c）中创建的颜色向量，调整透明度。与女性对应的颜色透明度应减少到90%；与男性对应的颜色透明度应减少到30%。
- en: Now, start the plot; alter the default figure margins to be 5, 4, 4, and 6 lines
    wide on the bottom, left, top, and right, respectively. Plot salary on the *y*-axis
    against years of service on the *x*-axis. Set the corresponding point colors according
    to your vector from (d) and the point characters and character expansion according
    to your vectors from (b). Tidy up the *x*-axis and *y*-axis titles.
  id: totrans-137
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，开始绘制图形；将默认的图形边距调整为底部4行、左侧5行、顶部4行和右侧6行。将薪水绘制在*y*-轴上，将服务年限绘制在*x*-轴上。根据你在（d）中创建的向量设置相应的点颜色，并根据你在（b）中创建的向量设置点字符和字符扩展。整理好*x*-轴和*y*-轴的标题。
- en: Incorporate two separate legends following the guidelines in (i) and (ii). Both
    legends should be horizontal, and you should relax clipping to allow their placement
    in figure margins (refer to [Section 23.2.3](ch23.xhtml#ch23lev2sec228)).
  id: totrans-138
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按照（i）和（ii）的指南，合并两个单独的图例。两个图例应该是水平放置的，且应放松裁剪以允许它们放置在图形边距中（参见[第23.2.3节](ch23.xhtml#ch23lev2sec228)）。
- en: Place the first legend at the user coordinate given by `x=-5` and `y=265000`.
    It should use the levels of the “rank” factor vector as the referencing text and
    pair these with the corresponding `pch` symbols as assigned. Include an appropriate
    title for the legend.
  id: totrans-139
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将第一个图例放置在用户坐标`x=-5`和`y=265000`的位置。它应使用“职级”因子向量的各个水平作为参考文本，并将这些文本与对应的`pch`符号进行配对。为图例添加一个合适的标题。
- en: The second legend should be placed next to the first, using an *x*-coordinate
    of `40` and the same *y*-coordinate value. This legend should show two points,
    both red and of type `19`, but reference the two levels of sex by altering the
    character expansion and opacity of these to reference points as assigned.
  id: totrans-140
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 第二个图例应放置在第一个图例旁边，使用`40`的*x*-坐标和相同的*y*-坐标值。该图例应显示两个点，都是红色的，类型为`19`，但通过改变字符扩展和透明度来引用性别的两个水平。
- en: Lastly, ensure the `shape` package is loaded and use the `colorlegend` function
    along with 50 colors generated from the appropriate palette from (a) to reference
    “years since Ph.D.” You can leave the horizontal and vertical placements of the
    legend at their default values. The `zlim` range should simply be set to match
    the range of the observed data, and the tick mark values set via `zval` should
    be a sequence between 10 and 50, increasing in steps of 10\. Include an appropriate
    title for the color legend.
  id: totrans-141
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，确保`shape`包已加载，并使用`colorlegend`函数配合从（a）中选出的适当调色板生成的50种颜色，来表示“自博士毕业以来的年数”。你可以将图例的水平和垂直位置保持为默认值。`zlim`范围应设置为与观察数据的范围一致，而通过`zval`设置的刻度值应为10到50之间的序列，每次增加10。为颜色图例添加一个合适的标题。
- en: 'After all this, my version of this plot is given here:'
  id: totrans-142
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 完成这些后，我的版本如下所示：
- en: '![image](../images/f0647-01.jpg)'
  id: totrans-143
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![image](../images/f0647-01.jpg)'
- en: 'Your next task is a little different. The goal is to plot a standard normal
    probability density function but use color to shade in polygons underneath the
    curve to denote “distance from mean.” To achieve this, complete the following:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 你的下一个任务有些不同。目标是绘制标准正态概率密度函数，但使用颜色对曲线下方的多边形进行着色，表示“与均值的距离”。为此，完成以下任务：
- en: Generate a vector of exactly 25 colors from the built-in palette `terrain.colors`
    and name it `tcols`. Then, using a reversed version of it obtained via `tcols[25:1]`,
    append the two vectors together to form a new vector of length 50 containing the
    first 25 colors shading one way and then the same 25 shading the opposite way.
  id: totrans-145
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从内置调色板`terrain.colors`生成一个恰好包含25种颜色的向量，并命名为`tcols`。然后，使用`tcols[25:1]`得到它的反转版本，将这两个向量拼接在一起，形成一个新的长度为50的向量，其中前25种颜色按一种方式着色，接着这25种颜色按相反的方式着色。
- en: Next, create and store an evenly spaced sequence of exactly 51 values between
    −3 and 3 inclusive; name it `vals`. Use `dnorm` to calculate and store the corresponding
    51 values of the standard normal density curve; name it `normvals`.
  id: totrans-146
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，创建并存储一个精确的51个值的均匀间隔序列，范围从−3到3（包括3）；命名为`vals`。使用`dnorm`计算并存储标准正态密度曲线的对应51个值；命名为`normvals`。
- en: Draw the normal density curve by plotting the values in (i) as a line (recall
    `type="l"`). In the same call to `plot`, use knowledge from [Chapter 23](ch23.xhtml#ch23)
    to set both the *x*-axis and *y*-axis styles to be of type `"i"`; suppress both
    axis titles with empty strings; change the surrounding box to be an *L* shape;
    and suppress the drawing of the *x*-axis. Give the plot a suitable main title.
  id: totrans-147
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过绘制（i）中的值作为一条线来绘制标准正态密度曲线（记得`type="l"`）。在同一次调用`plot`中，使用[第23章](ch23.xhtml#ch23)中的知识，将*X*轴和*Y*轴的样式设置为`"i"`类型；用空字符串隐藏两个轴的标题；将四周的框改为*L*形状；并禁止绘制*X*轴。给图形添加一个合适的主标题。
- en: To shade the different colors underneath the curve, use a `for` loop, iterating
    through the integers 1 to 50\. At each iteration, the loop should call `polygon`
    (refer to [Section 15.2.3](ch15.xhtml#ch15lev2sec135)). Assuming your indexer
    is `i`, the vertices of each polygon should be formed by the vectors `vals[rep(c(i,i+1),each=2)]`
    and `c(0,normvals[c(i,i+1)],0)`. Each polygon should suppress its border and be
    colored according to the relevant `i`th entry in your color vector of length 50
    created in (h).
  id: totrans-148
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要在曲线下方着色不同的颜色，使用`for`循环，遍历1到50的整数。在每次迭代中，循环应调用`polygon`（参考[第15.2.3节](ch15.xhtml#ch15lev2sec135)）。假设你的索引变量是`i`，则每个多边形的顶点应由向量`vals[rep(c(i,i+1),each=2)]`和`c(0,normvals[c(i,i+1)],0)`构成。每个多边形应隐藏其边框，并根据在（h）中创建的长度为50的颜色向量的相应`i`项着色。
- en: 'Lastly, ensure the `shape` package has been loaded and use your length 50 color
    vector to produce a color legend with default placement to reference “distance
    from mean.” You can easily set the `zlim` and `zval` arguments in the call to
    `colorlegend` using `vals`. Include an appropriate title for the legend. For reference,
    my result is given here:'
  id: totrans-149
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，确保`shape`包已经加载，并使用你长度为50的颜色向量生成一个默认位置的颜色图例，用来表示“与均值的距离”。你可以通过`vals`轻松设置调用`colorlegend`时的`zlim`和`zval`参数。为图例添加一个合适的标题。我的结果如下所示：
- en: '![image](../images/f0648-01.jpg)'
  id: totrans-150
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f0648-01.jpg)'
- en: '**25.2 3D Scatterplots**'
  id: totrans-151
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**25.2 三维散点图**'
- en: This section will look at creating 3D scatterplots, which allow you to plot
    raw observations based on three continuous variables at once, as opposed to only
    two in a conventional 2D scatterplot. You’ll then learn how to enhance your 3D
    scatterplot to represent more variables and make it easier to interpret. There
    are several ways to create three-variable scatterplots in R, but the go-to method
    is usually the `scatterplot3d` function in the contributed package of the same
    name ([Ligges and Mächler, 2003](ref.xhtml#ref42)).
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 本节将介绍如何创建 3D 散点图，这使你可以基于三个连续变量一次性绘制原始观察数据，而不仅仅是传统 2D 散点图中的两个变量。接着，你将学习如何增强你的
    3D 散点图，以表示更多的变量并使其更易于解读。有多种方法可以在 R 中创建三变量散点图，但通常采用的方式是使用同名的贡献包中的 `scatterplot3d`
    函数（[Ligges 和 Mächler, 2003](ref.xhtml#ref42)）。
- en: '***25.2.1 Basic Syntax***'
  id: totrans-153
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***25.2.1 基本语法***'
- en: The syntax of the `scatterplot3d` function is similar to the default `plot`
    function. In the latter, you supply a vector of *x*- and *y*-axis coordinates;
    in the former, you merely supply an additional third vector of values providing
    the *z*-axis coordinates. With that additional dimension, you can think of these
    three axes in terms of the *x*-axis increasing from left to right, the *y*-axis
    increasing from foreground to background, and the *z*-axis increasing from bottom
    to top.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: '`scatterplot3d` 函数的语法类似于默认的 `plot` 函数。在后者中，你提供 *x* 和 *y* 轴坐标的向量；在前者中，你仅需提供额外的第三个向量，提供
    *z* 轴坐标。通过这个额外的维度，你可以将这三个坐标轴视为：*x* 轴从左到右增加，*y* 轴从前景到背景增加，*z* 轴从下到上增加。'
- en: 'Install and load the `scatterplot3d` package, and let’s go straight into an
    example. Recall the famous iris flower data, which you first encountered in [Section
    14.4](ch14.xhtml#ch14lev1sec47). This data set contains measurements on four continuous
    variables (petal length/width and sepal length/width) and one categorical variable
    (flower species); the `iris` data frame is immediately accessible from the R prompt,
    so there’s no need to load anything. Enter the following so you have quick access
    to the measurement values that make up the data:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 安装并加载 `scatterplot3d` 包，我们直接进入一个示例。回想一下著名的鸢尾花数据，你第一次在[第14.4节](ch14.xhtml#ch14lev1sec47)中接触到该数据集。这个数据集包含了四个连续变量的测量值（花瓣长度/宽度和萼片长度/宽度）以及一个分类变量（花卉物种）；`iris`
    数据框可以直接从 R 提示符获取，因此无需加载任何内容。输入以下命令，以便快速访问构成数据的测量值：
- en: '[PRE31]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'The most basic 3D scatterplot of, say, petal length, petal width, and sepal
    width, is achieved with the following:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 基本的 3D 散点图，例如花瓣长度、花瓣宽度和萼片宽度，可以通过以下代码实现：
- en: '[PRE32]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: It’s as simple as that—the result of this code is given on the left of [Figure
    25-7](ch25.xhtml#ch25fig7). Here you can observe a general positive relationship
    among all three plotted variables. There’s also a clearly isolated cluster of
    observations in the foreground that have relatively large sepal widths but small
    petal measurements.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 就这么简单——此代码的结果如[图25-7](ch25.xhtml#ch25fig7)左侧所示。在这里，你可以观察到所有三个绘制变量之间的一般正相关关系。前景中还有一簇明显孤立的观察值，它们具有相对较大的萼片宽度，但花瓣测量值较小。
- en: '![image](../images/f25-07.jpg)'
  id: totrans-160
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f25-07.jpg)'
- en: '*Figure 25-7: Two 3D scatterplots of the famous* `iris` *data with petal width,
    petal length, and sepal width on the* x*-,* y*-, and* z*-axis, respectively. Left:
    Basic default appearance. Right: Tidying up titles and adding visual enhancements
    to emphasize 3D depth and legibility via color and vertical line marks.*'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: '*图25-7：两种 3D 散点图，展示了著名的* `iris` *数据，花瓣宽度、花瓣长度和萼片宽度分别在* x*、* y* 和* z* 轴上。左：基本的默认外观。右：整理标题并增加视觉增强，以通过颜色和垂直线条标记来强调
    3D 深度和可读性。*'
- en: '***25.2.2 Visual Enhancements***'
  id: totrans-162
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***25.2.2 可视化增强***'
- en: It can be difficult to clearly perceive depth in the plotted cloud of points,
    even with the box and *x*-*y* plane grid lines that are drawn by default. For
    this reason, there are a couple of optional enhancements you can make to a `scatterplot3d`
    plot—coloring the points to help make the transition from foreground to background
    clearer and setting the `type="h"` argument to draw lines perpendicular to the
    *x*-*y* plane.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 即便有默认绘制的盒子和 *x*-*y* 平面网格线，仍然很难清晰地感知图中点云的深度。因此，你可以对 `scatterplot3d` 图表进行几个可选的增强—通过给点上色来帮助更清晰地表达前景到背景的过渡，并通过设置
    `type="h"` 参数来绘制垂直于 *x*-*y* 平面的线条。
- en: 'The right-hand plot in [Figure 25-7](ch25.xhtml#ch25fig7) shows the plot with
    these enhancements and is the result of the following:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: '[图25-7](ch25.xhtml#ch25fig7)中的右侧图显示了这些增强效果的图表，并且是以下操作的结果：'
- en: '[PRE33]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: '`xlab`, `ylab`, `zlab`, and `main` control the corresponding titles of the
    three axes and the plot itself.'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: '`xlab`、`ylab`、`zlab`和`main`控制三个坐标轴和图形本身的标题。'
- en: The vertical lines make reading the values of the points much easier. By default,
    those lines in a `type="h"` plot are solid, but you can alter this with the `lty.hplot`
    argument (which behaves in the same way as the standard graphical parameter `lty`);
    setting `lty.hplot=2` requests dashed lines. Similarly, you can alter the line
    type of the “nonvisible” sides of the box; setting `lty.hide=3` instructs the
    plot to draw those lines as dotted.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 垂直线使得读取点的数值更加容易。默认情况下，在`type="h"`图中，这些线是实线，但你可以通过`lty.hplot`参数来修改（它的行为与标准图形参数`lty`相同）；设置`lty.hplot=2`会要求使用虚线。同样，你也可以修改“不可见”边框的线型；设置`lty.hide=3`会要求图表将这些线绘制为点线。
- en: Setting `highlight.3d=TRUE` emphasizes 3D depth by applying color transitioning
    from red to black based on the *y*-axis position of a point. This is useful, but
    there’s an important consequence—it means you can no longer use color to represent
    a fourth variable with such a plot.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 设置`highlight.3d=TRUE`通过根据点在*y*轴的位置应用从红色到黑色的颜色过渡来强调3D深度。这是有用的，但也有一个重要的后果——这意味着你不能再使用颜色来表示图表中的第四个变量。
- en: Along that line of thought, remember that the `iris` data has a fourth continuous
    variable, sepal length (stored as `slen` in [Section 25.2.1](ch25.xhtml#ch25lev2sec249)),
    that you’re not displaying in either of the plots in [Figure 25-7](ch25.xhtml#ch25fig7).
    You’re also not displaying the categorical variable of flower species, so let’s
    fix that. First, set up a color band for the missing measurement variable, using
    your knowledge of having color palettes reference a continuous variable from [Section
    25.1.4](ch25.xhtml#ch25lev2sec245).
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 按照这个思路，请记住`iris`数据集还包含一个第四个连续变量，即花萼长度（在[第25.2.1节](ch25.xhtml#ch25lev2sec249)中存储为`slen`），但你在[图
    25-7](ch25.xhtml#ch25fig7)中的任何图表里都没有展示它。你也没有展示花卉物种的分类变量，所以我们来解决这个问题。首先，为缺失的测量变量设置一个颜色带，利用你在[第25.1.4节](ch25.xhtml#ch25lev2sec245)中了解到的，通过颜色调色板引用一个连续变量的知识。
- en: '[PRE34]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Note that for the last line to run, you’ll need to have the `normalize` function
    defined in [Section 25.1.4](ch25.xhtml#ch25lev2sec245) available in your current
    session.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，要运行最后一行代码，你需要在当前会话中定义[第25.1.4节](ch25.xhtml#ch25lev2sec245)中的`normalize`函数。
- en: 'The following code produces the 3D scatterplot, which also uses the `pch` argument
    to distinguish among the three different species:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码生成了3D散点图，并且也使用了`pch`参数来区分三种不同的物种：
- en: '[PRE35]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'I’ve used the vector `c(19,17,15)`, with the numeric coercion of the `iris$Species`
    vector passed to the square brackets, to pair `pch` character numbers as follows:
    `19` with *Iris setosa* (the first level of the factor), `17` with *Iris versicolor*
    (the second level), and `15` with *Iris virginica* (the third level), respectively
    (refer to [Figure 7-5](ch07.xhtml#ch7fig5) on [page 133](ch07.xhtml#page_133)
    for the different types of point characters).'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 我使用了向量`c(19,17,15)`，并将`iris$Species`向量强制转换为数字后传递给方括号，以将`pch`字符编号与如下内容配对：`19`对应*Iris
    setosa*（因子中的第一个水平），`17`对应*Iris versicolor*（第二个水平），`15`对应*Iris virginica*（第三个水平）（请参见[图
    7-5](ch07.xhtml#ch7fig5)以及[第133页](ch07.xhtml#page_133)了解不同的点字符类型）。
- en: You can then insert a legend referencing species with a familiar call to `legend`.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，你可以插入一个参考物种的图例，使用常见的`legend`调用。
- en: '[PRE36]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: And with a little experimentation, you can include a color strip legend too
    (making sure you’ve loaded the `shape` package so you have access to the `colorlegend`
    function as per [Section 25.1.4](ch25.xhtml#ch25lev2sec245)).
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 通过一些实验，你还可以包含一个颜色条图例（确保你已经加载了`shape`包，以便可以使用`colorlegend`函数，参考[第25.1.4节](ch25.xhtml#ch25lev2sec245)）。
- en: '[PRE37]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: The final result of all this is the image in [Figure 25-8](ch25.xhtml#ch25fig8).
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些的最终结果是[图 25-8](ch25.xhtml#ch25fig8)中的图像。
- en: '![image](../images/f25-08.jpg)'
  id: totrans-180
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f25-08.jpg)'
- en: '*Figure 25-8: A 3D scatterplot of the famous* `iris` *data, displaying all
    five present variables with the additional use of color (for sepal length) and
    point character (for species).*'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 25-8：一个著名的`iris`数据集的3D散点图，展示了所有五个变量，并额外使用了颜色（表示花萼长度）和点的形态（表示物种）。*'
- en: With the creative use of color and point type, you’ve now been able to display
    the five-dimensional data in a single 3D scatterplot. This reveals important information
    about the data. For instance, you can now identify *Iris setosa* as the clearly
    separate group of points in the foreground and see that while *Iris setosa* tend
    to have smaller petal widths and lengths and larger sepal widths than the other
    two species (especially *Iris versicolor*), the purple coloring at the lower end
    of the scale suggests they tend to have smaller sepal lengths.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 通过创意地使用颜色和点类型，您现在能够在一个单一的3D散点图中展示五维数据。这揭示了关于数据的重要信息。例如，您现在可以识别出*Iris setosa*作为前景中明显分离的点组，并看到虽然*Iris
    setosa*的花瓣宽度和长度较小，且比其他两种物种（特别是*Iris versicolor*）的萼片宽度要大，但位于量表下端的紫色着色表明它们的萼片长度较小。
- en: '**Exercise 25.2**'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: '**练习25.2**'
- en: Ensure the `scatterplot3d` library has been loaded in your current R session.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 确保`scatterplot3d`库已在您当前的R会话中加载。
- en: 'Turn your attention back to the `diabetes` data frame found in the `faraway`
    package (you first looked at these data in [Section 21.5.2](ch21.xhtml#ch21lev2sec203)).
    Your goal is to produce a `scatterplot3d` plot of weight, hip, and waist measurements
    as per the following guidelines:'
  id: totrans-185
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 回到`faraway`包中的`diabetes`数据框（您第一次在[第21.5.2节](ch21.xhtml#ch21lev2sec203)中查看了这些数据）。您的目标是根据以下指南，生成一个包含体重、髋部和腰围测量值的`scatterplot3d`图：
- en: – Hip, waist, and weight variables should correspond to the *x*-axis, *y*-axis,
    and *z*-axis, respectively; provide neat axis titles.
  id: totrans-186
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: – 髋部、腰围和体重变量应分别对应于*x*轴、*y*轴和*z*轴；提供整洁的轴标题。
- en: – Use built-in functionality to ensure the 3D depth is highlighted by color.
  id: totrans-187
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: – 使用内置功能，确保通过颜色突出显示3D深度。
- en: – Choose two different point characters to reflect gender.
  id: totrans-188
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: – 选择两种不同的点字符来反映性别。
- en: – Place a simple legend referencing these two point characters and gender in
    the blank space in the upper-left area.
  id: totrans-189
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: – 在左上角的空白区域放置一个简单的图例，引用这两种点字符和性别。
- en: 'Create a 3D scatterplot of the built-in `airquality` data, which you first
    met in [Section 24.2.2](ch24.xhtml#ch24lev2sec239), according to the following
    guidelines:'
  id: totrans-190
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 根据以下指南，创建一个内置的`airquality`数据集的3D散点图，您第一次在[第24.2.2节](ch24.xhtml#ch24lev2sec239)中遇到该数据集：
- en: – Create a copy of the data frame using `na.omit` to remove all rows that contain
    missing values and work with this copy.
  id: totrans-191
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: – 使用`na.omit`创建数据框的副本，移除所有包含缺失值的行，并使用该副本进行操作。
- en: – Plot wind speed and solar radiation against the *x*- and *y*-axes, respectively,
    using the *z*-axis to plot temperature.
  id: totrans-192
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: – 将风速和太阳辐射分别绘制在*x*轴和*y*轴上，使用*z*轴绘制温度。
- en: – Apply vertical dotted lines reaching up from the *x*-*y* plane to each observation.
  id: totrans-193
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: – 在*x*–*y*平面上应用垂直虚线，延伸至每个观测点。
- en: – The data in `airquality` are comprised of measurements taken over five months,
    from May to September. Each plotted point should take on the corresponding `pch`
    value from `1` to `5` respective to the order of these five months.
  id: totrans-194
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: – `airquality`数据包含了从5月到9月五个月内的测量数据。每个绘制的点应根据这五个月的顺序，分别取`pch`值从`1`到`5`。
- en: – With a vector of 50 colors generated from the built-in `topo.colors` palette,
    use the categorization approach to ensure each plotted point is colored according
    to its ozone value.
  id: totrans-195
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: – 使用从内置的`topo.colors`调色板生成的50种颜色的向量，使用分类方法确保每个绘制的点根据其臭氧值着色。
- en: – Set a legend to reference the five point types according to month.
  id: totrans-196
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: – 设置一个图例，引用根据月份的五种点类型。
- en: – Set a color legend (using functionality from the `shape` package) to reference
    the ozone value accordingly.
  id: totrans-197
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: – 设置一个颜色图例（使用`shape`包中的功能），根据臭氧值进行引用。
- en: – Ensure the plot has neat axis, main, and legend titles.
  id: totrans-198
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: – 确保图表有整洁的轴、主标题和图例标题。
- en: '**25.3 Preparing a Surface for Plotting**'
  id: totrans-199
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**25.3 为绘图准备表面**'
- en: In the rest of this chapter, you’ll look at three types of 3D plots geared to
    visualize a *bivariate surface*. Such plots are required when you have two variables,
    based on which a function, estimate, or model has been defined, and you want to
    use the third available axis (in other words, the *z*-axis) to map out the resulting
    surface. You’ve seen examples of bivariate functions already, through the response
    surfaces for the `mtcars` data in [Section 21.5.4](ch21.xhtml#ch21lev2sec205)
    (where you looked at mean MPG as a function of car weight and horsepower) and
    through the study of diagnostic tools for linear regression models in [Section
    22.3.6](ch22.xhtml#ch22lev2sec219) (where you saw how Cook’s distance can be expressed
    as a function of residual and leverage).
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的其余部分，你将看到三种类型的 3D 绘图，用于可视化一个*双变量表面*。当你有两个变量，并且基于这两个变量定义了一个函数、估计或模型时，这种图形是必需的，并且你希望使用第三个可用轴（换句话说，就是*z*轴）来描绘出结果的表面。你已经通过在[第
    21.5.4 节](ch21.xhtml#ch21lev2sec205)中查看`mtcars`数据的响应面（在那里你看到了车重和马力作为自变量时，平均油耗的变化）以及在[第
    22.3.6 节](ch22.xhtml#ch22lev2sec219)中研究线性回归模型的诊断工具（在那里你看到了如何将库克距离表示为残差和杠杆的函数）看过双变量函数的例子。
- en: Before you look at producing these plots, it’s important to understand how they’re
    created in R. The function/estimate/model of interest should be thought of as
    a plane or surface that can vary according to continuous, two-dimensional *x*-*y*
    coordinates. Plotting a completely continuous surface is technically impossible
    since that would require you to evaluate the function at an infinite number of
    coordinates. Therefore, evaluation of the surface is typically performed on a
    finite *grid* of evenly spaced coordinates along both the *x*- and *y*-axes. The
    result of the function at each unique pair of coordinates is stored in a corresponding
    position in an appropriately sized matrix (the size of which depends directly
    upon the resolution of the evaluation grid in the *x*- and *y*-axes), generically
    referred to as the *z-matrix*.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 在你开始绘制这些图形之前，理解它们是如何在 R 中创建的非常重要。你关注的函数/估计/模型应该被视为一个平面或表面，可以根据连续的二维*x*-*y*坐标发生变化。绘制一个完全连续的表面在技术上是不可能的，因为那需要你在无限多个坐标上评估函数。因此，表面的评估通常是在沿*x*轴和*y*轴均匀间隔的有限*网格*坐标上进行的。每个唯一坐标对下的函数结果被存储在适当大小的矩阵中的相应位置（其大小直接取决于在*x*和*y*轴上评估网格的分辨率），通常被称为*z矩阵*。
- en: Since all the traditional R graphics commands that plot these bivariate functions
    operate in the same way—using this *z*-matrix—it’s critical to understand how
    this matrix is constructed, arranged, and interpreted by those commands to ensure
    you’re correctly drawing the outcome. In this section, you’ll ready yourself for
    the specific plot types looked at in the remainder of this chapter by getting
    familiar with this construct in a hypothetical situation.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 由于所有传统的 R 图形命令在绘制这些双变量函数时都以相同的方式操作——使用这个*z*矩阵——因此理解这个矩阵是如何构建、排列和由这些命令解释的至关重要，以确保你能正确地绘制结果。在本节中，你将通过在一个假设情境中熟悉这一构造，为本章其余部分中讨论的特定绘图类型做好准备。
- en: '***25.3.1 Constructing an Evaluation Grid***'
  id: totrans-203
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***25.3.1 构建评估网格***'
- en: Say you have a bivariate function that results in a continuous surface that’s
    defined between 1 and 6 on the *x*-axis and 1 and 4 on the *y*-axis. You can define
    evenly spaced sequences over each of these coordinate ranges using `seq`; for
    simplicity, let’s just do so in straight-out integers.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你有一个双变量函数，它生成一个定义在*x*轴的1到6之间和*y*轴的1到4之间的连续表面。你可以使用`seq`在这些坐标范围内定义均匀间隔的序列；为了简化，我们就直接用整数来定义。
- en: '[PRE38]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: What this implies is that you’re planning to draw your surface based on evaluation
    of the bivariate function of interest upon the grid of *x*-*y* values defined
    by 24 unique positions.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着你计划基于在由 24 个唯一位置定义的*x*-*y*值网格上评估感兴趣的双变量函数来绘制你的表面。
- en: When passed two vectors, the built-in `expand.grid` function explicitly generates
    all unique coordinate pairs by simply repeating each value in the second vector
    against the entire length of the first vector.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 当传入两个向量时，内置的`expand.grid`函数通过简单地将第二个向量中的每个值与第一个向量的整个长度重复，显式生成所有唯一的坐标对。
- en: '[PRE39]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: The result is stored as a two-column data frame with 24 rows. If you look at
    `xycoords` object in the R console, you’ll see `x` values from `1` to `6` all
    paired with a repeated `y` value of `1`, then `x` from `1` to `6` paired with
    `y` as `2`, and so on.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 结果以一个两列的数据框存储，共有24行。如果您查看R控制台中的`xycoords`对象，您会看到`x`值从`1`到`6`与重复的`y`值`1`配对，然后是`x`从`1`到`6`与`y`值`2`配对，依此类推。
- en: 'In practice, what you’d now do is use the evaluation grid coordinates in `xycoords`
    to calculate the result of your bivariate function. For this hypothetical example,
    let’s just say that your bivariate function has resulted in the 24 letters *a*
    to *x*, corresponding to the order of the unique evaluation coordinates in `xycoords`.
    To make this even clearer, take a look at the following column-bind of the hypothetical
    function result with each evaluation coordinate (note that the ready-to-use `letters`
    object in R allows you to generate letters of the alphabet quickly):'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 实际操作中，您现在需要使用`xycoords`中的评估网格坐标来计算双变量函数的结果。在这个假设的例子中，假设您的双变量函数生成了从*a*到*x*的24个字母，分别对应于`xycoords`中唯一评估坐标的顺序。为了更清晰地说明这一点，看看下面将假设函数结果与每个评估坐标列绑定的示例（请注意，R中的现成`letters`对象可以快速生成字母）：
- en: '[PRE40]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: What this emphasizes is that each unique *x*-*y* evaluation coordinate, expressible
    via `expand.grid`, will have a *z* value associated with it. All together, these
    *z* values define the resulting surface.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 这强调了每个唯一的*x*–*y*评估坐标，通过`expand.grid`表示，都将有一个与之相关联的*z*值。所有这些*z*值一起定义了结果的曲面。
- en: '***25.3.2 Constructing the z-Matrix***'
  id: totrans-213
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***25.3.2 构建z矩阵***'
- en: The 3D plots used to visualize a bivariate function require the *z* values corresponding
    to the *x*-*y* evaluation grid in the form of an appropriately constructed matrix.
    The size of the *z*-matrix is determined directly by the resolution of the evaluation
    grid; the number of rows corresponds to the number of unique *x* grid values,
    and the number of columns corresponds to the number of unique *y* grid values.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 用于可视化双变量函数的3D图需要将对应于*x*–*y*评估网格的*z*值呈现为适当构建的矩阵。*z*矩阵的大小直接由评估网格的分辨率决定；行数对应于唯一的*x*网格值的数量，列数对应于唯一的*y*网格值的数量。
- en: You therefore need to take a little care turning your calculated *z* values
    into a matrix. When your vector of *z*-axis values corresponds to the evaluation
    grid arranged in the standard `expand.grid` fashion (in other words, where coordinates
    are stacked by increasing *x* values and repeated *y* values), be sure that your
    resulting *z*-matrix is filled in the default column-wise fashion (see [Section
    3.1.1](ch03.xhtml#ch03lev2sec24)), with the number of rows and columns being exactly
    representative of the number of values in each of the *x*- and *y*-value sequences,
    respectively (`xcoords` and `ycoords` shown earlier). In the current example,
    you know that the resulting *z*-matrix needs to be of size 6 × 4 because there
    are six *x* locations and four *y* locations.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，您需要小心将计算得到的*z*值转换为矩阵。当您的*z*轴向量与标准`expand.grid`方式排列的评估网格相对应时（换句话说，坐标按增加的*x*值和重复的*y*值堆叠），确保您的结果*z*矩阵以默认的列优先方式填充（参见[第3.1.1节](ch03.xhtml#ch03lev2sec24)），行和列的数量应该准确代表每个*x*和*y*值序列中的值的数量（分别是之前显示的`xcoords`和`ycoords`）。在当前的例子中，您知道结果*z*矩阵的大小需要是6
    × 4，因为有六个*x*位置和四个*y*位置。
- en: 'The following is the correct matrix representation of the hypothetical “function
    result” vector `z`:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是假设“函数结果”向量`z`的正确矩阵表示：
- en: '[PRE41]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: '***25.3.3 Conceptualizing the z-Matrix***'
  id: totrans-218
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***25.3.3 构思z矩阵***'
- en: The most important thing to be gained from this section is an idea of how the
    *z*-matrix in its current arrangement translates to *x*-*y* coordinate-based plotting.
    Comparing `zmat` to the earlier output, you can see that moving down a column
    of `zmat` translates to an increase in the *x*-coordinate value for a given *y*-coordinate
    value. In other words, when this hypothetical surface of letters is plotted, moving
    down a column of the matrix corresponds to moving horizontally from left to right
    on the corresponding plot, given a particular vertical *y* position.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 本节最重要的收获是了解当前排列的*z*矩阵如何转换为基于*x*–*y*坐标的绘图。将`zmat`与早期的输出进行比较，您可以看到，沿着`zmat`的列向下移动，意味着对于给定的*y*坐标值，*x*坐标值在增加。换句话说，当这个假设的字母曲面被绘制时，沿着矩阵的一列向下移动对应于在给定的垂直*y*位置下，从左到右水平移动。
- en: '[Figure 25-9](ch25.xhtml#ch25fig9) provides a conceptual diagram of this illustrative
    surface, indexed by `zmat` as per the 24 unique coordinates defined via `xcoords`
    and `ycoords`. (The code to produce this is included in the R script files for
    this book, which can be found at *[https://www.nostarch.com/bookofr/](https://www.nostarch.com/bookofr/)*.)'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 25-9](ch25.xhtml#ch25fig9)提供了这个示例表面的概念图，按`zmat`索引，基于`xcoords`和`ycoords`定义的24个唯一坐标。（生成此图形的代码包含在本书的R脚本文件中，可以在*[https://www.nostarch.com/bookofr/](https://www.nostarch.com/bookofr/)*找到。）'
- en: '![image](../images/f25-09.jpg)'
  id: totrans-221
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f25-09.jpg)'
- en: '*Figure 25-9: Conceptual diagram of a* z*-matrix for plotting bivariate functions,
    based on a 6* × *4 coordinate grid*'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 25-9：绘制双变量函数的*z*矩阵概念图，基于6×4坐标网格*'
- en: As you now progress to plot some actual surfaces of interest, you should keep
    the concept of the *z*-matrix as illustrated in [Figure 25-9](ch25.xhtml#ch25fig9)
    in mind. The 6 × 4 grid used in this hypothetical example is coarse. In practice,
    you’ll usually use far finer grids in terms of the resolution of the *x*- and
    *y*-sequences to improve the visual appearance of the surface.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 当你开始绘制实际的感兴趣表面时，应牢记[图 25-9](ch25.xhtml#ch25fig9)中所示的*z*矩阵的概念。这个假设示例中使用的6 × 4网格较为粗糙。实际上，为了提高表面的视觉效果，你通常会使用更精细的网格，在*x*和*y*序列的分辨率上有所改进。
- en: '**25.4 Contour Plots**'
  id: totrans-224
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**25.4 等高线图**'
- en: One of the most common plots used to display a surface based on evaluation of
    a function over a grid of bivariate coordinates is the *contour plot*. Contour
    plots are perhaps most easily explained as a series of lines—the contours—drawn
    over the 2D evaluation grid, with each contour marking off a specific level of
    the surface of interest.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 显示基于二维坐标网格评估函数的表面的最常见图形之一是*等高线图*。等高线图可以通过一系列线条——即等高线——在二维评估网格上绘制来解释，每条等高线表示感兴趣表面上的特定水平。
- en: '***25.4.1 Drawing Contour Lines***'
  id: totrans-226
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***25.4.1 绘制等高线***'
- en: Based on a given numeric *z*-matrix, the R function `contour` is what’s used
    to produce the contours connecting *x*-*y* coordinates that share the same *z*
    value.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 基于给定的数字*z*矩阵，R函数`contour`用于生成连接具有相同*z*值的*x*-*y*坐标的等高线。
- en: '**Example 1: Topographical Map**'
  id: totrans-228
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**示例 1：地形图**'
- en: For an example, you’ll use another ready-to-use data set—the `volcano` object.
    This data set is simply a matrix containing measurements of the elevation above
    sea level (in meters) of a dormant volcano over a rectangular area in the Auckland
    region of New Zealand; see the documentation in `?volcano` for details. To view
    the topography, you need the `volcano` object (which is your *z*-matrix) and the
    relevant *x*- and *y*-coordinate sequences. In this case, just use integers corresponding
    to the size of the `volcano` matrix (row and column numbers can be obtained with
    a simple call to `dim`; see [Section 3.1.3](ch03.xhtml#ch03lev2sec26)).
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 作为示例，你将使用另一个现成的数据集——`volcano`对象。这个数据集是一个矩阵，包含新西兰奥克兰地区一座休眠火山上空的海拔（单位：米）；有关详细信息，请参阅`?volcano`文档。要查看地形，你需要`volcano`对象（它是你的*z*矩阵）和相关的*x*和*y*坐标序列。在这种情况下，只需使用与`volcano`矩阵大小相对应的整数（可以通过调用`dim`轻松获取行和列的数量；请参见[第
    3.1.3 节](ch03.xhtml#ch03lev2sec26)）。
- en: '[PRE42]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: The *x*- and *y*-sequences are provided to `x` and `y`, respectively, and the
    *z-*matrix to `z`. The optional argument `asp=1`, referring to the aspect ratio
    of the plot, forces a 1-to-1 unit treatment of the coordinate axes (this is relevant
    when the units have a physical size interpretation, like in plots of geographical
    regions—as is the case here).
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: '*x*和*y*序列分别提供给`x`和`y`，而*z*矩阵提供给`z`。可选参数`asp=1`，指的是图形的纵横比，它强制坐标轴以1:1的比例处理（当单位具有物理大小解释时，比如在地理区域的绘图中，这一点非常重要——如这里的情况）。'
- en: '[Figure 25-10](ch25.xhtml#ch25fig10) shows the result of this example. By default,
    R automatically chooses the levels of `z` at which to draw the contours for an
    aesthetically pleasing result. Contours are also selectively labeled with their
    corresponding *z* value. Looking at the topography, you can see the highest peak
    is a rim on the left, marked by an oblong contour at 190 m, with a depression
    (at around 160 m) falling immediately to the right.'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 25-10](ch25.xhtml#ch25fig10)展示了此示例的结果。默认情况下，R会自动选择绘制等高线的`z`值，以获得视觉上美观的效果。等高线也会根据其对应的*z*值选择性地进行标注。观察地形，可以看到最高点位于左侧的边缘，190米的椭圆形等高线标记着这个位置，右侧则有一个大约160米的凹陷。'
- en: '![image](../images/f25-10.jpg)'
  id: totrans-233
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f25-10.jpg)'
- en: '*Figure 25-10: Using* `contour` *to produce a topographic map of the* `volcano`
    *data*'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 25-10：使用* `contour` *绘制* `volcano` *数据的地形图*'
- en: Contours are able to show you not only the peaks and troughs in a surface like
    this but the “steepness” of any such features too. The closer together the contour
    lines lie, the more rapid the change in the overall level of the bivariate function.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 等高线不仅能显示表面上的峰值和谷值，还能显示任何此类特征的“陡峭度”。等高线之间越紧密，双变量函数的整体水平变化越快速。
- en: '**Example 2: Parametric Response Surface**'
  id: totrans-236
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**示例 2：参数响应面**'
- en: 'As a different kind of example, consider the multiple linear model fitted to
    the `mtcars` data mentioned earlier—that is, of MPG modeled by horsepower, weight,
    and an interaction between the two predictors. As in [Section 21.5.4](ch21.xhtml#ch21lev2sec205),
    you can get the fitted model object with the following:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 作为另一个例子，考虑前面提到的对`mtcars`数据拟合的多元线性模型——即由马力、重量及其相互作用预测的每加仑英里数（MPG）。如同在[第21.5.4节](ch21.xhtml#ch21lev2sec205)中所示，你可以使用以下代码获取拟合的模型对象：
- en: '[PRE43]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: The goal is to plot the response, mean mileage, as the previous function of
    horsepower and weight. To do this, you need to evaluate the mean MPG, according
    to the previous model, for a grid of horsepower and weight values. The following
    code does exactly that.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 目标是绘制响应，即平均油耗，作为前面所提到的马力和重量的函数。为此，你需要根据前面的模型评估马力和重量值的网格上的平均MPG。以下代码正是执行这一操作。
- en: '[PRE44]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: First, this code sets up evenly spaced sequences (each of length 20, spanning
    the range of the observed data) in both `hp` and `wt`—these are your *x-*and *y*-sequences.
    This implies there will be 20 × 20 = 400 unique coordinates at which you’ll be
    evaluating the fitted model; these coordinates are obtained using `expand.grid`
    as in [Section 25.3](ch25.xhtml#ch25lev1sec88).
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，这段代码在`hp`和`wt`两个变量上设置了均匀间隔的序列（每个序列长度为20，涵盖观察数据的范围）——这就是你的*x-*和*y*-序列。这意味着将在20
    × 20 = 400个独特的坐标点上评估拟合模型；这些坐标通过`expand.grid`获取，正如[第25.3节](ch25.xhtml#ch25lev1sec88)中所述。
- en: Next, you can use `predict` to get the 400 corresponding mean MPG (*z*) values;
    since it’s already a data frame in the required format, `hp.wt` can be passed
    directly to the `newdata` argument.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，你可以使用`predict`获取对应的400个平均MPG（*z*）值；由于它已经是所需格式的数据框，`hp.wt`可以直接传递给`newdata`参数。
- en: '[PRE45]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: Then, you simply need to arrange the resulting vector as the appropriate 20
    × 20 *z*-matrix.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，你只需将结果向量排列为适当的20 × 20 *z*矩阵。
- en: '[PRE46]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: Finally, you plot the result as contours, as shown in [Figure 25-11](ch25.xhtml#ch25fig11).
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，你将结果绘制为等高线，如在[图 25-11](ch25.xhtml#ch25fig11)中所示。
- en: '[PRE47]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: In this call, you can see the use of the optional `levels` argument. Rather
    than let R automatically decide at which values of *z* to show contours, you can
    supply a numeric vector to this argument with the specific levels at which to
    draw the lines. This numeric vector must be on the same scale as the resulting
    bivariate function of interest; here, I asked for contours at all integer levels
    from 32 through 8\. I also employ the familiar arguments `lty` and `lwd` to control
    the appearance of the contour lines themselves, which are set here as dashed and
    slightly thicker than usual.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 在此调用中，你可以看到可选的`levels`参数的使用。与让R自动决定在哪些*z*值上显示等高线不同，你可以向该参数提供一个数值向量，指定绘制等高线的具体水平。这个数值向量必须与结果的双变量函数在相同的尺度上；在这里，我要求在32到8的所有整数水平上绘制等高线。我还使用了常见的参数`lty`和`lwd`来控制等高线的外观，这里设置为虚线且比通常的略粗。
- en: Furthermore, for contour plots in particular, you’ll often want to deviate from
    the default axis limit style, because the small amount of additional “padding”
    space that’s included in the default plot region (refer to [Section 23.4.1](ch23.xhtml#ch23lev2sec232))
    can be rather prominent—take another look at the volcano contour plot in [Figure
    25-10](ch25.xhtml#ch25fig10). As shown previously, setting `xaxs` and `yaxs` to
    `"i"` restricts all plotting to the exact limits imposed by `x` and `y`.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，特别是对于等高线图，你通常需要偏离默认的坐标轴限制样式，因为默认图形区域中包含的少量额外“填充”空间（参见[第23.4.1节](ch23.xhtml#ch23lev2sec232)）可能显得较为突出——再看一眼[图
    25-10](ch25.xhtml#ch25fig10)中的火山等高线图。如前所示，设置`xaxs`和`yaxs`为`"i"`将限制所有绘图在`x`和`y`强加的精确限制内。
- en: '![image](../images/f25-11.jpg)'
  id: totrans-250
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f25-11.jpg)'
- en: '*Figure 25-11: Contour lines depicting the response surface based on a multiple
    linear model of MPG by horsepower and weight, from the* `mtcars` *data*'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 25-11：基于由马力和重量建模的多元线性模型的响应面等高线，数据来自* `mtcars`'
- en: '**Example 3: Nonparametric Bivariate Density Estimate (Earthquake Data)**'
  id: totrans-252
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**示例3：非参数二元密度估计（地震数据）**'
- en: Another useful role fulfilled by contour plots and the other plots in this chapter
    is to visualize bivariate density functions.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 等高线图和本章中的其他图表还履行了一个有用的角色，即可视化二元密度函数。
- en: In [Section 24.2.2](ch24.xhtml#ch24lev2sec239), you looked at the idea of kernel
    density estimation (KDE) as a method by which to construct smooth estimates of
    the probability density functions of your data—essentially, sophisticated histograms.
    KDE extends to higher dimensions quite naturally so that you can also estimate
    the density of bivariate observations in the *x*-*y* plane. This again involves
    visualizing a *z*-matrix over a fixed grid of coordinates. For theoretical details
    on multivariate KDE, see Wand and Jones ([1995](ref.xhtml#ref70)).
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第24.2.2节](ch24.xhtml#ch24lev2sec239)中，您了解了核密度估计（KDE）作为一种方法，通过它可以构建数据的平滑概率密度函数估计——本质上是复杂的直方图。KDE自然地扩展到更高维度，因此您也可以估计*x*-*y*平面中的二元观测密度。这同样涉及在固定坐标网格上可视化一个*z*矩阵。有关多元KDE的理论细节，请参阅Wand和Jones（[1995](ref.xhtml#ref70)）。
- en: 'Turn your attention back to the built-in `quakes` data frame and recall the
    plots of the spatial coordinates of the 1,000 seismic events (for example, [Figure
    13-1](ch13.xhtml#ch13fig1) on [page 265](ch13.xhtml#page_265) and [Figure 23-1](ch23.xhtml#ch23fig1)
    on [page 578](ch23.xhtml#page_578)). To estimate the probability density function
    of these points, you can use the `kde2d` function in the `MASS` package. Load
    `MASS` and execute the following line to produce the kernel estimate of the observed
    two-dimensional data:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 将注意力转回到内置的`quakes`数据框，并回想一下1,000个地震事件的空间坐标图（例如，[图13-1](ch13.xhtml#ch13fig1)在[第265页](ch13.xhtml#page_265)，和[图23-1](ch23.xhtml#ch23fig1)在[第578页](ch23.xhtml#page_578)）。为了估计这些点的概率密度函数，您可以使用`MASS`包中的`kde2d`函数。加载`MASS`并执行以下代码来生成观测二维数据的核密度估计：
- en: '[PRE48]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: You supply the bivariate data as the `x` and `y` arguments for the horizontal
    and vertical axes. The optional argument `n` is used to specify the number of
    evaluation coordinates (along each of the two axes) at which to actually return
    the estimated density surface. This defines the size of the matrix returned by
    a call to `kde2d`. Here, you’ve asked for KDE to be performed on a 100 × 100 evenly
    spaced grid over the range of the observed data.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 您将二元数据作为`x`和`y`参数提供，分别对应水平和垂直轴。可选参数`n`用于指定在两个轴上的评估坐标数（即实际返回估计的密度曲面的点数）。这定义了通过调用`kde2d`返回的矩阵大小。在这里，您要求在观测数据的范围内，沿100
    × 100均匀间隔的网格执行KDE。
- en: 'The resulting object is simply a list with three members. The components accessed
    through `$x` and `$y` contain the evenly spaced evaluation grid coordinates in
    the corresponding axis directions, and `$z` provides you with the corresponding
    *z*-matrix. You can confirm by entering either `quak.dens$x` or `quak.dens$y`
    at the prompt that they are indeed increasing sequences spanning the ranges of
    the observed data. Entering the following confirms the size of the matrix of interest:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 生成的对象仅仅是一个包含三个成员的列表。通过`$x`和`$y`访问的组件包含相应轴方向上均匀间隔的评估网格坐标，`$z`则提供对应的*z*矩阵。您可以通过在命令行输入`quak.dens$x`或`quak.dens$y`来确认它们确实是增加的序列，涵盖了观测数据的范围。输入以下内容可以确认感兴趣矩阵的大小：
- en: '[PRE49]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: With that, you have all the ingredients you need to display contours of the
    KDE surface. The next line produces the default contour plot, given on the top
    left of [Figure 25-12](ch25.xhtml#ch25fig12).
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这些，您就拥有了显示KDE曲面等高线所需的所有元素。下一行代码生成默认的等高线图，如[图25-12](ch25.xhtml#ch25fig12)左上角所示。
- en: '[PRE50]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'There are many more optional arguments available to `contour` for displaying
    your continuous surface. It can also be helpful to simultaneously view other data
    or raw observations (if they’ve been used in some way to create the surface, as
    is the case with bivariate KDE). The following code replots the `quakes` kernel
    estimate with unpadded axes, different contour levels to the defaults, and the
    raw observations; you can see the result on the top right of [Figure 25-12](ch25.xhtml#ch25fig12):'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: '`contour`函数有许多更多的可选参数，用于显示您的连续曲面。它也可能有助于同时查看其他数据或原始观测数据（如果它们已以某种方式被用于创建曲面，就像二元KDE中的情况一样）。以下代码重新绘制了`quakes`的核密度估计，使用未加填充的轴、与默认值不同的等高线级别和原始观测数据；您可以在[图25-12](ch25.xhtml#ch25fig12)的右上角看到结果：'
- en: '[PRE51]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: Rather than using `levels` to determine the exact levels at which to draw the
    contours (as you did with Example 2), you can use the `nlevels` argument to specify
    the *number* of levels to display, and the function will choose the specific values.
    This latest call to `contour` requested 50 levels to be drawn. You can suppress
    the automatic labeling of the displayed contours by setting `drawlabels=FALSE`,
    also done here, followed by a call to `points` to add the original observations
    to the image. Naturally, the smooth contours delineating the nonparametric density
    estimate reflect the heterogeneous spatial patterning of the data.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 与使用`levels`来确定绘制轮廓的精确等级（如示例2中所做）不同，你可以使用`nlevels`参数来指定要显示的*等级数*，函数将自动选择具体的值。在此调用`contour`时，要求绘制50个等级。你可以通过设置`drawlabels=FALSE`来抑制自动标签的显示，接着调用`points`将原始观测值添加到图像中。显然，平滑的轮廓线描绘了非参数密度估计，反映了数据的异质空间模式。
- en: Changing the appearance of your plotted contours needn’t be done universally;
    you can also alter the appearance of each individual contour level. This can be
    handy if, for example, you want to display contours at a handful of specific levels
    without the default labeling (to focus on the shape of the surface itself) but
    still want to be able to discern the values of those contours. You might also
    want to superimpose contours on an existing plot that already depicts other data
    or model-based results of interest. The third plot of the earthquake KDE surface,
    given on the bottom of [Figure 25-12](ch25.xhtml#ch25fig12), shows how you can
    achieve both of these things.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 更改绘制轮廓的外观不一定要全局进行；你也可以单独更改每个轮廓等级的外观。例如，如果你只想在几个特定的等级上显示轮廓而不显示默认标签（以便专注于表面的形状），但仍希望能够辨认出这些轮廓的值，这时这种方式就非常有用。你也可能想要将轮廓叠加到一个已经绘制其他数据或基于模型的结果的现有图形上。[图25-12](ch25.xhtml#ch25fig12)底部的第三个地震KDE表面图展示了如何同时实现这两种需求。
- en: '![image](../images/f25-12.jpg)'
  id: totrans-266
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f25-12.jpg)'
- en: '*Figure 25-12: Three examples of a contour plot of the bivariate kernel estimate
    of the probability density function of the spatial earthquake locations given
    in the* `quakes` *data set*'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: '*图25-12：地震位置空间的双变量核密度估计概率密度函数的轮廓图示例，数据来自`quakes`数据集*'
- en: To start the plot, the spatial locations of the earthquake data are drawn as
    half-size gray dots using `plot`, the style of the axes are set using `xaxs` and
    `yaxs` to remove the artificial padding around the edges of the plot region, and
    axis titles are added.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 为了开始绘制图形，使用`plot`将地震数据的空间位置绘制为半大小的灰色点，轴的样式通过`xaxs`和`yaxs`进行设置，以去除图形区域边缘的人工填充，并添加轴标题。
- en: '[PRE52]'
  id: totrans-269
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: Then, before calling `contour`, store the desired levels at which to draw contours
    in a vector named `quak.levs` (again, choosing appropriate contour levels depends
    entirely on what kind of surface you’re plotting; you need to be at least roughly
    aware of the values stored in the relevant *z*-matrix).
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，在调用`contour`之前，将要绘制轮廓的期望等级存储在一个名为`quak.levs`的向量中（再次强调，选择适当的轮廓等级完全取决于你绘制的表面类型；你至少需要大致了解相关的*z*矩阵中存储的值）。
- en: '[PRE53]'
  id: totrans-271
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: Now, remember that by default, `contour` refreshes the graphics device and starts
    a new plot, but you want to avoid that when adding contour lines to an existing
    plot. To do so, you need to explicitly specify `add=TRUE`. You then provide the
    four specified levels in `quak.levs` to `levels` and suppress labeling with `drawlabels=FALSE`.
    To control the appearance of contour lines at individual levels, you supply the
    sequence of integers `4:1` to `lty`, the first entry of which, `4`, defines the
    line type of the contour at *z* = 0.001\. The second entry, `3`, specifies the
    line type of the *z* = 0.005 contour, and so on. Lastly, set all drawn contours
    to double-thickness with the single supplied value `lwd=2`. (You could supply
    a vector with four elements here too, if you want differing line thicknesses for
    the different contours. The same element-wise contour specification extends to
    other relevant aesthetics, such as color via `col`.)
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，请记住，默认情况下，`contour` 会刷新图形设备并开始一个新的绘图，但当你向现有图形添加等高线时，你需要避免这种情况。为此，你需要明确指定`add=TRUE`。然后，将
    `quak.levs` 中指定的四个水平传递给 `levels`，并通过 `drawlabels=FALSE` 来抑制标签。为了控制各个水平上等高线的外观，你需要将整数序列
    `4:1` 提供给 `lty`，其中第一个条目 `4` 定义了 *z* = 0.001 时等高线的线型。第二个条目 `3` 指定了 *z* = 0.005
    等高线的线型，依此类推。最后，通过单个提供的值 `lwd=2` 将所有绘制的等高线设置为双重粗细。（如果你希望不同的等高线有不同的线粗，也可以在此提供一个包含四个元素的向量。对于其他相关的美学，如通过
    `col` 控制颜色，同样可以按元素指定等高线的参数。）
- en: '[PRE54]'
  id: totrans-273
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: As a final touch, since the automatic labeling was suppressed in `contour`,
    add a legend in the bottom-left corner of the plot region, referencing the values
    of the contours through the four different line types.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，由于在 `contour` 中抑制了自动标签，因此在图形区域的左下角添加一个图例，通过四种不同的线型来引用等高线的值。
- en: '[PRE55]'
  id: totrans-275
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: '**NOTE**'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*Many built-in and contributed base R plotting functions that by default initialize,
    refresh, or open a new plot include an* `add` *argument as shown here. This allows
    you to use the graphics produced by these functions as additions to an already
    existing graphic. Look in the relevant help file to see whether this is the case
    for a given command.*'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: '*许多内建的和贡献的基本 R 绘图函数，默认情况下会初始化、刷新或打开一个新图形，都包含一个 `add` 参数，如这里所示。这使得你可以将这些函数生成的图形作为现有图形的附加部分来使用。查看相关的帮助文件，看看某个特定命令是否适用。*'
- en: '***25.4.2 Color-Filled Contours***'
  id: totrans-278
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***25.4.2 彩色填充等高线***'
- en: For a straightforward variation on the contour plot, you can use color to fill
    the gaps between the different levels that are drawn. Combined with a color legend,
    this removes the need to label the contour lines and in certain cases can make
    it easier to visually interpret fluctuations in the plotted *z*-matrix surface.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 对于等高线图的简单变体，你可以使用颜色来填充不同水平之间的空隙。结合颜色图例，这样就无需标记等高线，在某些情况下，这可以更容易地直观地解释绘制的 *z*-矩阵表面中的波动。
- en: The `filled.contour` function does this for you. You need to supply the increasing
    sequences of grid coordinates in both the *x*-axis and *y*-axisdirections, as
    well as the corresponding *z*-matrix, to the arguments `x`, `y`, and `z` in the
    same way as in `contour`. The easiest way to specify the colors is to supply a
    color palette to the `color.palette` argument (which defaults to the built-in
    `cm.colors` palette; refer to [Figure 25-2](ch25.xhtml#ch25fig2)), and R does
    the rest.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: '`filled.contour` 函数为你完成了这一切。你需要将 *x* 轴和 *y* 轴方向上逐渐增大的网格坐标序列以及相应的 *z* 矩阵提供给
    `x`、`y` 和 `z` 参数，方法与 `contour` 中相同。指定颜色的最简单方法是将颜色调色板传递给 `color.palette` 参数（默认为内建的
    `cm.colors` 调色板；请参见 [图25-2](ch25.xhtml#ch25fig2)），其余的由 R 自动完成。'
- en: 'Let’s use the `mtcars` response surface from Example 2 for a quick demonstration.
    If you don’t already have them in your current workspace, use the code from [Section
    25.4.1](ch25.xhtml#ch25lev2sec254) to obtain the relevant fitted multiple linear
    regression model, the evaluation grid coordinates, and the prediction thereof.
    With the objects `hp.seq`, `wt.seq`, and `car.pred.mat` defined as earlier, the
    following call produces [Figure 25-13](ch25.xhtml#ch25fig13):'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用示例 2 中的 `mtcars` 响应面来快速演示。如果你的工作空间中尚未有相关数据，请使用 [第25.4.1节](ch25.xhtml#ch25lev2sec254)中的代码来获取相关的拟合多元线性回归模型、评估网格坐标以及相应的预测结果。在之前定义的
    `hp.seq`、`wt.seq` 和 `car.pred.mat` 对象基础上，以下调用将生成 [图25-13](ch25.xhtml#ch25fig13)：
- en: '[PRE56]'
  id: totrans-282
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: '![image](../images/f25-13.jpg)'
  id: totrans-283
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f25-13.jpg)'
- en: '*Figure 25-13: Filled contour plot of the response surface for the fitted multiple
    linear model of the* `mtcars` *data*'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: '*图25-13：`mtcars` 数据集的拟合多元线性模型响应面的填充等高线图*'
- en: Note in this plot that the default color palette hasn’t been used. Instead,
    you’ve supplied a custom palette (produced as a direct result of an appropriate
    call to `colorRampPalette`; refer to [Section 25.1.3](ch25.xhtml#ch25lev2sec244))
    to the relevant argument, moving from white at the lower end to dark red at the
    upper end. Note also that although the *x*-axis and *y*-axis titles are provided
    as usual to `xlab` and `ylab`, you have to supply the title for the color legend
    in a particular way—inside a call to `title` to the `key.title` argument. This
    is because `filled.contour` actually produces two plots, one for the image itself
    and one for the color legend, and makes use of the `layout` command to place them
    next to one another.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，这个图中没有使用默认的颜色调色板。相反，你为相关参数提供了一个自定义的调色板（这是通过适当调用`colorRampPalette`直接生成的；参考[第25.1.3节](ch25.xhtml#ch25lev2sec244)），从下端的白色到上端的深红色。同时注意，尽管*X*轴和*Y*轴的标题像往常一样通过`xlab`和`ylab`提供，但你必须以特定的方式为颜色图例提供标题—通过在`title`中调用`key.title`参数来实现。这是因为`filled.contour`实际上生成了两个图，一个是图像本身，另一个是颜色图例，并使用`layout`命令将它们并排放置。
- en: This internal use of `layout` isn’t directly a problem, but, as you saw in [Section
    23.1.4](ch23.xhtml#ch23lev2sec225), it complicates matters somewhat if you want
    to annotate the filled contour plot after the fact (by, for example, adding points
    to an existing graphic) since the original user coordinate system is lost.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 这种对`layout`的内部使用并不直接构成问题，但正如你在[第23.1.4节](ch23.xhtml#ch23lev2sec225)中看到的，如果你想在事后为填充等高线图添加注释（例如，向现有图形中添加点），会有些复杂，因为原始用户坐标系丢失了。
- en: Turn your attention back to the two-dimensional kernel estimate of the spatial
    `quakes` data (use the code from [Section 25.4.1](ch25.xhtml#ch25lev2sec254) to
    re-create it if you haven’t already got the `quak.dens` object in your workspace).
    The following code creates a filled contour plot of the density surface using
    the built-in `topo.colors` palette and modifies the number of drawn levels from
    the default of 20 to 30\. In the same call, you can superimpose the points of
    the raw observations onto the image through special use of the optional `plot.axes`
    argument. [Figure 25-14](ch25.xhtml#ch25fig14) shows the result.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 回到空间`quakes`数据的二维核估计（如果你还没有在工作区中获得`quak.dens`对象，可以使用[第25.4.1节](ch25.xhtml#ch25lev2sec254)中的代码重新创建）。以下代码使用内置的`topo.colors`调色板创建了密度曲面的填充等高线图，并将绘制的级别数从默认的20个改为30个。在同一个调用中，通过特别使用可选的`plot.axes`参数，你还可以将原始观测数据点叠加到图像上。[图
    25-14](ch25.xhtml#ch25fig14)显示了结果。
- en: '[PRE57]'
  id: totrans-288
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: '![image](../images/f25-14.jpg)'
  id: totrans-289
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f25-14.jpg)'
- en: '*Figure 25-14: Filled contour plot of the kernel estimate of the probability
    density function of the spatial* `quakes` *data, with raw observations superimposed.*'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 25-14：空间* `quakes` *数据的概率密度函数核估计的填充等高线图，原始观测数据叠加其上。*'
- en: Take a look at the way in which `plot.axes` is used; it effectively takes a
    chunk of code. When `plot.axes` is invoked, you must explicitly tell it to mark
    the *x*- and *y*-axes if you want the labeled tick marks to remain. This is done
    with two calls to `axis` (refer to [Section 23.4.3](ch23.xhtml#ch23lev2sec234)—`axis(1)`
    gives *x*, and `axis(2)` is used for *y*). You add the data points with a call
    to `points`; in this example, these are instructed to plot at half size, with
    30 percent opacity imparted with `adjustcolor`. Since you’re supplying multiple
    separate commands at once to the `plot.axes` argument, each command needs to be
    separated by a semicolon (`;`) inside braces (`{ }`).
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 看看`plot.axes`的使用方式；它实际上需要一段代码。当调用`plot.axes`时，如果你希望标记的刻度线保持显示，必须明确告诉它标记*X*轴和*Y*轴。这可以通过两次调用`axis`来完成（参考[第23.4.3节](ch23.xhtml#ch23lev2sec234)—`axis(1)`表示*X*轴，`axis(2)`用于*Y*轴）。你可以通过调用`points`来添加数据点；在这个例子中，这些点被指示以半尺寸绘制，使用`adjustcolor`设置了30%的透明度。由于你同时向`plot.axes`参数提供多个单独的命令，每个命令需要用分号（`;`）在大括号（`{
    }`）内分隔。
- en: Annotation of a filled contour plot in this fashion requires a little more forethought
    since you’re required to manually add the axes via calls to `axis` and perform
    all subsequently desired plotting actions within the call to `filled.contour`.
    It won’t work to, for example, produce a filled contour plot like the `quakes`
    KDE surface and then call `points` as a separate line of code. If you try it,
    you’ll see the observed data points unable to align correctly with their original
    user coordinates as indicated on the axes.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 以这种方式注释填充等高线图需要更多的预先思考，因为你需要通过调用`axis`手动添加坐标轴，并在调用`filled.contour`时执行所有随后想要的绘图操作。例如，不能像生成`quakes`的KDE表面那样生成一个填充的等高线图，然后再将`points`作为单独的代码行调用。如果你这样做，你会发现观察到的数据点无法正确对齐到它们在坐标轴上原始的用户坐标。
- en: '**Exercise 25.3**'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: '**练习 25.3**'
- en: Remember that you inspected various multiple linear regression models of the
    cost of nuclear power plant construction in [Chapters 21](ch21.xhtml#ch21) and
    [22](ch22.xhtml#ch22). The goal now will be to visually assess the impact of including/excluding
    an interactive term between two continuous predictors using contours. Revisit
    the `nuclear` data set, available when you load the `boot` package, and bring
    up the help file to refresh your memory of the variables present.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，你曾经检查过关于核电厂建设成本的多个线性回归模型，详见[第21章](ch21.xhtml#ch21)和[第22章](ch22.xhtml#ch22)。现在的目标是通过等高线图视觉评估包括/排除两个连续预测变量之间的交互项的影响。重新访问`nuclear`数据集，该数据集在加载`boot`包时可用，并查看帮助文件以刷新你对其中变量的记忆。
- en: 'Fit and summarize two linear models with construction cost as the response
    variable according to the following guidelines:'
  id: totrans-295
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 根据以下指导方针，拟合并总结两个线性模型，将建设成本作为响应变量：
- en: The first should account for main effects of the two predictors concerning the
    date of issue of the construction permit and plant capacity.
  id: totrans-296
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 第一个应考虑两个预测变量关于建设许可证发布日期和工厂容量的主要效应。
- en: The second, in addition to the two main effects, should include an interaction
    between permit issue date and capacity.
  id: totrans-297
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 第二个模型，除了两个主要效应外，应包括许可证发布日期和容量之间的交互项。
- en: Set up appropriate *z*-matrices for plotting each of these response surfaces.
    Each one should be based on a 50 × 50 evaluation grid constructed using evenly
    spaced sequences in the capacity and date variables.
  id: totrans-298
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为每个响应面设置适当的* z *矩阵进行绘图。每个矩阵应基于一个50 × 50的评估网格，该网格通过在容量和日期变量中使用均匀间隔的序列构建。
- en: Specify `mfrow` in `par` so that you can display default contour plots for the
    two response surfaces from (a)(i) and (a)(ii) next to one another. Do they appear
    similar? Does thistie in with the statistical significance (or lack thereof) of
    the interaction term in (a)(ii)?
  id: totrans-299
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`par`中指定`mfrow`，以便你可以将（a）（i）和（a）（ii）中的两个响应面显示在一起。它们看起来相似吗？这与（a）（ii）中的交互项的统计显著性（或缺乏显著性）有关系吗？
- en: 'To directly compare the two surfaces, use your choice of built-in color palette
    to produce a filled contour plot of the main-effects-only model and superimpose
    the contour lines of the interactive model on it. Take note of the following:'
  id: totrans-300
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了直接比较这两个表面，使用你选择的内置颜色调色板，生成仅包含主要效应的模型的填充等高线图，并将交互式模型的等高线叠加在其上。注意以下几点：
- en: – This plot is achieved in a single call to `filled.contour`. Recall the special
    way you use `plot.axes` to draw additional features on an existing color-filled
    contour plot.
  id: totrans-301
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: – 这个图是通过一次`filled.contour`调用实现的。回忆一下你是如何使用`plot.axes`在现有的颜色填充等高线图上绘制附加特征的特殊方法。
- en: – The contour lines of the interactive model can be added with an appropriate
    call to `contour`. Recall the use of the optional argument `add`.
  id: totrans-302
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: – 交互式模型的等高线可以通过适当的`contour`调用添加。回忆一下可选参数`add`的使用。
- en: – The superimposed contours should be dashed lines of double thickness.
  id: totrans-303
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: – 重叠的等高线应为双倍厚度的虚线。
- en: – The *x*- and *y*-axes should be included and given tidy titles.
  id: totrans-304
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: – 应包含* x *轴和* y *轴，并为其提供整洁的标题。
- en: – Add some brief text describing the filled contours versus the contour lines,
    with reference to the two versions of the construction cost model and with an
    additional call to `text` that makes use of a single mouse-clicked location from
    `locator` (see [Section 23.3](ch23.xhtml#ch23lev1sec78)). Note that this call
    will need to fully relax clipping for the text to be visible in any of the margins.
  id: totrans-305
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: – 添加一些简短的文本，描述填充等高线与等高线的区别，并参考建设成本模型的两个版本，同时通过额外调用`text`来使用来自`locator`的单击位置（参见[第23.3节](ch23.xhtml#ch23lev1sec78)）。请注意，这个调用需要完全放松剪辑，以便文本能够在任何边缘区域显示。
- en: My result is shown here.
  id: totrans-306
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我的结果如下所示。
- en: '![image](../images/f0667-01.jpg)'
  id: totrans-307
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![image](../images/f0667-01.jpg)'
- en: Another built-in data frame in R, `faithful`, contains observations of waiting
    times and durations of eruptions of the Old Faithful geyser in Yellowstone National
    Park, Wyoming. See the documentation in `?faithful` for details. Plot the data
    with duration on the *y*-axis and waiting time on the *x*-axis.
  id: totrans-308
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: R中的另一个内置数据框`faithful`包含黄石国家公园老忠实喷泉的等待时间和喷发持续时间的观测数据。有关详细信息，请参见`?faithful`中的文档。使用持续时间作为*
    y *轴，等待时间作为* x *轴绘制数据。
- en: Estimate the bivariate density of these data via KDE using a 100 × 100 evaluation
    grid and produce a default contour plot thereof.
  id: totrans-309
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过KDE估算这些数据的双变量密度，使用100 × 100的评估网格，并生成该密度的默认等高线图。
- en: Create a filled contour plot of the kernel estimate using a custom palette that
    ranges from `"darkblue"` to `"hotpink"`; include the raw data as half-size gray
    points. Label the axes and titles appropriately.
  id: totrans-310
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用从`"darkblue"`到`"hotpink"`的自定义调色板，绘制核密度估计的填充等高线图；将原始数据作为半尺寸的灰色点添加。适当标注坐标轴和标题。
- en: Replot the raw data as gray, 3/4-sized, type `2` point characters; set the style
    of the axes to restrict to exactly the ranges of the observed data; and ensure
    tidy axis titles and a main title. To this plot, add the contour lines of the
    density estimate at the specific levels obtained in a sequence from 0.002 to 0.014
    in steps of 0.004\. Suppress the labeling of the contours. The contour lines should
    be dark red and increase in line width thickness for higher levels of the density.
    Add a legend referencing the density level at each of these lines.
  id: totrans-311
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将原始数据重新绘制为灰色的3/4大小，`2`号点字符；设置坐标轴的样式，确保坐标轴的范围严格限制为观察数据的范围；并确保坐标轴标题和主标题整洁。在该图中，添加密度估计的等高线，特定水平从0.002到0.014，以0.004为步长进行序列计算。抑制等高线的标签显示。等高线应为深红色，并且随着密度水平的增加，线宽应变粗。为每条等高线添加图例，指示密度水平。
- en: My plots for (g) and (h) are shown here.
  id: totrans-312
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我的(g)和(h)的图像如下所示。
- en: '![image](../images/f0668-01.jpg)'
  id: totrans-313
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f0668-01.jpg)'
- en: '**25.5 Pixel Images**'
  id: totrans-314
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**25.5 像素图像**'
- en: A *pixel image* is arguably the most literal visual representation of a continuous
    surface approximated by a finite evaluation grid. Its appearance is similar to
    a filled contour plot, but an image plot gives you more direct control over the
    display of each entry of the relevant *z*-matrix.
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: '*像素图像*可以说是最直观的连续表面视觉表示，通过有限的评估网格来近似。它的外观类似于填充的等高线图，但图像图允许您更直接地控制每个相关* z *矩阵条目的显示。'
- en: '***25.5.1 One Grid Point = One Pixel***'
  id: totrans-316
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***25.5.1 一个网格点 = 一个像素***'
- en: Consider each entry of your *z*-matrix as a little rectangle whose color depicts
    its relative value. These rectangles, or *pixels*, are exactly what’s depicted
    as the cells formed by the dashed gray lines making up the conceptual diagram
    of the *z*-matrix in [Figure 25-9](ch25.xhtml#ch25fig9) on [page 656](ch25.xhtml#page_656).
    This emphasizes the important fact that the fineness of your evaluation grid sequences
    (in both the *x*- and *y*-coordinate directions) directly defines the size of
    each pixel and therefore the smoothness of the resulting image. A smaller pixel
    means the *resolution* of the image is increased.
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 将您的* z *矩阵的每个条目视为一个小矩形，其颜色表示其相对值。这些矩形，或称为*像素*，正是[图25-9](ch25.xhtml#ch25fig9)中虚线灰色线条所形成的*
    z *矩阵概念图的单元格。在[第656页](ch25.xhtml#page_656)的图中有所显示。这强调了一个重要事实，即评估网格序列（无论是* x *轴还是*
    y *轴方向）的细密程度直接决定了每个像素的大小，从而影响生成图像的平滑度。较小的像素意味着图像的*分辨率*提高。
- en: 'The built-in `image` function plots pixel images. Much as with `contour`, you
    supply your *x*- and *y*-axis evaluation grid coordinates as increasing sequences
    to the `x` and `y` arguments, with the corresponding *z*-matrix supplied to `z`.
    Going back to the `volcano` data set first looked at in Example 1 of [Section
    25.4.1](ch25.xhtml#ch25lev2sec254), the following line produces [Figure 25-15](ch25.xhtml#ch25fig15):'
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 内置的`image`函数用于绘制像素图像。与`contour`函数类似，您将* x *和* y *轴的评估网格坐标作为递增序列传递给`x`和`y`参数，并将相应的*
    z *矩阵传递给`z`。回到在[第25.4.1节](ch25.xhtml#ch25lev2sec254)的示例1中首次查看的`volcano`数据集，以下代码生成了[图25-15](ch25.xhtml#ch25fig15)：
- en: '[PRE58]'
  id: totrans-319
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: Note again that you use the optional argument `asp=1` to enforce a one-to-one
    aspect ratio of the horizontal and vertical axes. This plot is comprised of exactly
    87 × 61 = 5307 pixels; each one represents a particular entry in the `volcano`
    matrix. Visually, the reflection of this image in the contour plot of the same
    data in [Figure 25-10](ch25.xhtml#ch25fig10) is clear.
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 请再次注意，使用可选参数 `asp=1` 来强制水平和垂直轴的纵横比为 1：1。此图由正好 87 × 61 = 5307 个像素组成；每个像素代表 `volcano`
    矩阵中的一个特定条目。从视觉上看，这个图像在同一数据的轮廓图（见[图 25-10](ch25.xhtml#ch25fig10)）中的反射非常明显。
- en: '![image](../images/f25-15.jpg)'
  id: totrans-321
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f25-15.jpg)'
- en: '*Figure 25-15: Pixel image of the Auckland volcano topography*'
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 25-15：奥克兰火山地形的像素图像*'
- en: The `image` command expects a vector of colors, usually supplied as hex codes
    from a palette, to be passed to its `col` argument. If this isn’t specified, it
    defaults to `heat.colors(12)` using the built-in palette, as in the image plot
    of `volcano`. One immediate concern, however, is the lack of a color legend. Contributed
    tools such as the `colorlegend` function from the `shape` package (refer to [Section
    25.1.5](ch25.xhtml#ch25lev2sec246)) prove useful for these plots.
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: '`image` 命令期望传入一个颜色向量，通常通过调色板的十六进制代码提供，传递给其 `col` 参数。如果没有指定，默认使用内建调色板 `heat.colors(12)`，就像
    `volcano` 图像中的那样。然而，一个直接的问题是缺少颜色图例。来自 `shape` 包的 `colorlegend` 函数（参见[第 25.1.5
    节](ch25.xhtml#ch25lev2sec246)）等贡献工具在这些图像中非常有用。'
- en: 'Return now to the `mtcars` response surface from Example 2 that fits the multiple
    linear regression model of MPG on horsepower and weight (and an interactive effect
    between the two predictors). The code for the necessary objects is reproduced
    here in a shortened form for convenience (refer to [Section 25.4.1](ch25.xhtml#ch25lev2sec254)
    for a fuller explanation of the operations):'
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 现在返回到示例 2 中的 `mtcars` 响应面，它拟合了关于马力和重量的 MPG 多元线性回归模型（以及这两个预测变量之间的交互效应）。这里为方便起见，简化了必要对象的代码（有关操作的完整说明，请参见[第
    25.4.1 节](ch25.xhtml#ch25lev2sec254)）：
- en: '[PRE59]'
  id: totrans-325
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: Just as earlier, you’ve set up a matrix of 400 elements in `car.pred.mat`, which
    is based on sequences of length 20 in both continuous predictors.
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 就像之前一样，你已经在 `car.pred.mat` 中设置了一个包含 400 个元素的矩阵，这个矩阵是基于两个连续预测变量的长度为 20 的序列。
- en: Now, make sure the `shape` package is loaded so you have access to the `colorlegend`
    function. The code that follows first sets up a custom palette of blue colors,
    sets new margin limits that widen the area on the rightmost axis, and then plots
    the predicted 20 × 20 response surface including a color legend; the result is
    given on the left of [Figure 25-16](ch25.xhtml#ch25fig16).
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，确保加载 `shape` 包，这样你就可以使用 `colorlegend` 函数。接下来的代码首先设置了一个自定义的蓝色调色板，设置了新的边距限制以扩展右侧轴的区域，然后绘制了包括颜色图例的预测
    20 × 20 响应面；结果展示在 [图 25-16](ch25.xhtml#ch25fig16) 的左侧。
- en: '[PRE60]'
  id: totrans-328
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: '![image](../images/f25-16.jpg)'
  id: totrans-329
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f25-16.jpg)'
- en: '*Figure 25-16: Two pixel images of the* `mtcars` *mean MPG response surface
    introduced in Example 2, with accompanying color legends. In terms of the evaluation
    grid in the horsepower and weight variables, the surface on the left has a resolution
    of 20 ²; the image on the right is based on a finer 50 ² grid. Contours are superimposed
    upon the rightmost plot.*'
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 25-16：两个像素图像，展示了在示例 2 中引入的`mtcars`平均 MPG 响应面，并附带颜色图例。关于马力和重量变量的评估网格，左侧的图像分辨率为
    20²；右侧的图像基于更细的 50² 网格。轮廓图叠加在最右侧的图上。*'
- en: 'With a relatively coarse evaluation grid, the pixels making up the surface
    are prominent. You can easily increase the resolution of the parametric response
    surface by using finer sequences for the `hp.seq` and `wt.seq` evaluation grid.
    The code that follows does just that by increasing `len` to `50`, over-writing
    the objects used previously:'
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 在较粗的评估网格下，构成响应面的像素较为显眼。你可以通过使用更细的 `hp.seq` 和 `wt.seq` 评估网格，轻松提高参数响应面的分辨率。接下来的代码通过将
    `len` 增加到 `50`，并覆盖之前使用的对象来实现这一点：
- en: '[PRE61]'
  id: totrans-332
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'Then the right-hand image of [Figure 25-16](ch25.xhtml#ch25fig16) is produced
    with the following code:'
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，通过以下代码生成了 [图 25-16](ch25.xhtml#ch25fig16) 右侧的图像：
- en: '[PRE62]'
  id: totrans-334
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: The newly plotted surface consists of 50² = 2500 pixels, as opposed to the previous
    image of merely 20² = 400 pixels. The improvement in the picture is obvious. In
    plotting the new image, the number of colors used (from the custom `blues` palette)
    is increased to 100 to provide smoother color transitions. Note also the use of
    `add` in a call to `contour` to superimpose contour lines upon the image to provide
    further visual emphasis of the fluctuating surface over the evaluation grid. A
    legend is added with an appropriate call to `colorlegend` as a final touch.
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 新绘制的表面由50² = 2500个像素组成，而之前的图像仅由20² = 400个像素组成。图像的改善显而易见。在绘制新图像时，使用的颜色数量（来自自定义的`blues`调色板）增加到100，以提供更平滑的颜色过渡。还注意到，在调用`contour`时使用了`add`，将等高线叠加到图像上，从而进一步强调评估网格上的波动表面。最后，使用`colorlegend`添加了一个图例，为图像增添了最后的润色。
- en: '***25.5.2 Surface Truncation and Empty Pixels***'
  id: totrans-336
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***25.5.2 表面截断和空像素***'
- en: Because of its one-to-one literal representation of the *z*-matrix, a pixel
    image is especially good when you want to plot a surface that fits irregularly
    over, or is smaller than, the standard rectangular evaluation grid spanning the
    *x-*and *y*-axes. To carefully demonstrate this kind of manipulation, let’s turn
    to a new data set from the contributed `spatstat` package by Baddeley and Turner
    ([2005](ref.xhtml#ref06)). Install `spatstat` with a call to `install.package("spatstat")`.
    Note that `spatstat` has a number of dependencies; see [Appendix A.2.3](app01.xhtml#app01lev2sec275)
    if you have any trouble downloading and installing `spatstat`.
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 由于其对*z*矩阵的逐字一对一表示，像素图像在你想绘制不规则覆盖或小于标准矩形评估网格（跨越*x-*和*y*-轴）的表面时，尤其有效。为了仔细展示这种操作，让我们转到由Baddeley和Turner（[2005](ref.xhtml#ref06)）提供的`spatstat`包中的新数据集。使用`install.package("spatstat")`安装`spatstat`。请注意，`spatstat`有许多依赖项；如果在下载和安装`spatstat`时遇到任何问题，请参见[附录A.2.3](app01.xhtml#app01lev2sec275)。
- en: '**Example 4: Nonparametric Bivariate Density Estimate (Chorley-Ribble Data)**'
  id: totrans-338
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**示例4：非参数双变量密度估计（Chorley-Ribble数据）**'
- en: Once `spatstat` is installed and loaded in your current R session with a call
    to `library("spatstat")`, inspect the help file brought up by entering `?chorley`
    at the prompt. This details the Chorely-Ribble cancer data—spatial locations of
    1,036 cases of cancer of the larynx and lung collected in the late 1970s and early
    1980s in a particular region of England (data first analyzed by [Diggle, 1990](ref.xhtml#ref18)).
    The `chorley` object is of a special class specific to `spatstat` (a `"ppp"` object—*planar
    point pattern*), but its components can be extracted just as if you’re referencing
    members of a named list.
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦`spatstat`被安装并加载到当前的R会话中，使用`library("spatstat")`调用，在提示符下输入`?chorley`查看帮助文件。这将详细介绍Chorley-Ribble癌症数据——收集于1970年代末到1980年代初的英格兰某地区的1,036例喉癌和肺癌的空间位置（数据首次由[Diggle,
    1990](ref.xhtml#ref18)分析）。`chorley`对象是`spatstat`特有的特殊类（一个`"ppp"`对象——*平面点模式*），但其组件可以像引用命名列表的成员一样提取。
- en: 'The coordinates of the observations can be retrieved as the components `$x`
    and `$y`. To view the spatial dispersion of the observations, the following line
    gives you the top-left image of [Figure 25-17](ch25.xhtml#ch25fig17):'
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 观察数据的坐标可以作为`$x`和`$y`组件提取。为了查看观察数据的空间分布，以下代码给出了[图25-17](ch25.xhtml#ch25fig17)的左上角图像：
- en: '[PRE63]'
  id: totrans-341
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'Your goal is to display a kernel estimate of the two-dimensional probability
    density function of the cancer distribution, similar to what you did with the
    earthquake data in Example 3\. You’ll use the `kde2d` function for this—execute
    `library("MASS")` to gain access to it. Then, exactly as you used it for the spatial
    locations of `quakes`, the default KDE surface for the observed Chorley-Ribble
    data is given with the following:'
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 你的目标是显示癌症分布的二维概率密度函数的核密度估计，类似于你在示例3中对地震数据所做的。你将使用`kde2d`函数来完成这个任务——执行`library("MASS")`以访问该函数。然后，正如你对`quakes`的空间位置所做的那样，观察到的Chorley-Ribble数据的默认KDE表面如下所示：
- en: '[PRE64]'
  id: totrans-343
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: Note the specification of a fine 256 × 256 easting-northing evaluation grid.
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，指定了一个细致的256 × 256东西-北方向评估网格。
- en: 'To display the density estimate, use the built-in `rainbow` palette and use
    the optional `start` and `end` arguments to restrict the total range of the palette
    to begin at red at the lower end and end at magenta/pink at the upper end (these
    arguments were mentioned briefly in [Section 25.1.2](ch25.xhtml#ch25lev2sec243);
    refer to the help file `?rainbow` for more details on the use of `start` and `end`).
    Prestore 200 colors from this palette with the following line:'
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 要显示密度估计，请使用内置的`rainbow`调色板，并使用可选的`start`和`end`参数将调色板的总范围限制在从红色开始到洋红/粉色结束（这些参数在[第25.1.2节](ch25.xhtml#ch25lev2sec243)中简要提到；更多关于使用`start`和`end`的详细信息，请参考帮助文件`?rainbow`）。使用以下行从此调色板预存200种颜色：
- en: '[PRE65]'
  id: totrans-346
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'Then, the image is produced by calling this:'
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，通过调用以下命令生成图像：
- en: '[PRE66]'
  id: totrans-348
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: Another component of `chorley`, named `$window`, contains the vertices of an
    irregular polygon. This polygon defines the geographical study region in which
    the observations themselves were made. The `$window` component also happens to
    be another special object class of `spatstat`, namely, `"owin"` for “observation
    window.” Although it’s possible to extract the specific vertices of the polygon
    and plot it manually with built-in functionality, the authors of `spatstat` have
    provided a standard `plot` method to use for this purpose.
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个`chorley`的组件，名为`$window`，包含一个不规则多边形的顶点。该多边形定义了地理研究区域，观测数据就是在这个区域内收集的。`$window`组件也是`spatstat`中另一个特殊的对象类，即`"owin"`，表示“观测窗口”。虽然可以提取多边形的特定顶点并使用内置功能手动绘制它，但`spatstat`的作者提供了一个标准的`plot`方法来实现这一目的。
- en: 'After running the `image` command, calling the following code superimposes
    the border of the study region upon the pixel image:'
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 运行`image`命令后，调用以下代码将研究区域的边界叠加在像素图像上：
- en: '[PRE67]'
  id: totrans-351
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: The final result is given on the top right of [Figure 25-17](ch25.xhtml#ch25fig17).
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 最终结果显示在[图25-17](ch25.xhtml#ch25fig17)的右上角。
- en: 'You’ll notice that the geographical region in which the data were collected
    is a little wider than the *x*- and *y*-ranges of the observations themselves,
    so the current plot hasn’t been able to show the region in its entirety. The following
    code shows this numerically:'
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 你会注意到，数据收集的地理区域比观测数据本身的*x*和*y*范围稍宽，因此当前的绘图未能完整显示该区域。以下代码以数字方式显示这一点：
- en: '[PRE68]'
  id: totrans-354
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: The *x*- and *y*-ranges of the study region can be obtained as the `$xrange`
    and `$yrange` components of the `$window` component (which is stored in the first
    line as the object `chor.WIN`). You can see that the overall study region is slightly
    larger when you compare its limits to the results of calling `range` on the raw
    data.
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 研究区域的*x*和*y*范围可以作为`$window`组件（存储在对象`chor.WIN`的第一行）的`$xrange`和`$yrange`组件获得。与在原始数据上调用`range`的结果比较时，你可以看到整体研究区域略大一些。
- en: That’s not the only problem, either. From the plot, you can also see that the
    KDE surface has been estimated and drawn in some areas that are actually *outside*
    the study region, so that will need to be fixed as well. (You’ll look at that
    in a moment.)
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，问题并不仅此而已。从图中还可以看出，KDE表面已经在实际上*超出*研究区域的一些区域进行了估算和绘制，因此这也需要修正。（稍后会看一下。）
- en: '![image](../images/f25-17.jpg)'
  id: totrans-357
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f25-17.jpg)'
- en: '*Figure 25-17: Visual experimentations in attempts to plot a two-dimensional
    kernel estimate of the probability density function of the Chorley-Ribble cancer
    data as a pixel image. Top left: The raw data. Top right: The default* `kde2d`
    *result based on the data ranges with the study region superimposed. Bottom left:
    Expanding the* `xlim` *and* `ylim` *of the call to* `image` *when plotting the
    original density estimate. Bottom right: A revised density estimate, using the
    full* x*- and* y*-ranges of the study region to define the evaluation grid.*'
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: '*图25-17：试图绘制Chorley-Ribble癌症数据二维核密度函数的可视化实验。左上：原始数据。右上：基于数据范围的默认`kde2d`结果，上面叠加了研究区域。左下：在绘制原始密度估计时扩展`xlim`和`ylim`的调用。右下：使用研究区域的整个x和y范围重新定义评估网格的修订密度估计。*'
- en: So, first off, what can you do to ensure the entire geographical region is displayed?
    Well, you could of course use the ranges of the region as stored previously in
    the vectors `WIN.xr` and `WIN.yr` and supply them to the familiar optional `xlim`
    and `ylim` arguments when calling `image`.
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，你可以如何确保显示整个地理区域？嗯，当然可以使用之前存储在向量`WIN.xr`和`WIN.yr`中的区域范围，并在调用`image`时将它们提供给熟悉的可选参数`xlim`和`ylim`。
- en: '[PRE69]'
  id: totrans-360
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: The result of these two lines is given on the bottom left of [Figure 25-17](ch25.xhtml#ch25fig17).
    Unfortunately, the original density estimate is still defined in terms of the
    original *x*- and *y*-ranges of the raw data, which gives you a border of empty
    pixels; in addition, the aforementioned density areas still fall outside the observation
    window.
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 这两行代码的结果显示在[图 25-17](ch25.xhtml#ch25fig17)的左下角。不幸的是，原始的密度估计仍然是基于原始数据的*x*和*y*范围定义的，这导致了空白像素的边界；此外，前述的密度区域仍然位于观察窗口之外。
- en: All this emphasizes the important fact that a *z*-matrix is specific to a predefined
    evaluation grid. The only way to get your density estimate to span the geographical
    study region for the Chorley-Ribble data is to revise your kernel estimate so
    that it’s produced on an evaluation grid that spans the limits of the region.
    Fortunately, the `kde2d` function allows you to set optional *x*-*y* limits of
    the evaluation grid with the `lims` argument. This expects a numeric vector of
    length 4, with the *x*-axis lower and upper values followed by the *y*-axis lower
    and upper values, in that order. The following code reestimates the density using
    the study region limits and plots it. The result is given on the bottom right
    of [Figure 25-17](ch25.xhtml#ch25fig17).
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些都强调了一个重要的事实，即*z*矩阵是特定于预定义评估网格的。要使你的密度估计涵盖 Chorley-Ribble 数据的地理研究区域，唯一的方法是修改你的核密度估计，使其在覆盖该区域边界的评估网格上生成。幸运的是，`kde2d`函数允许你通过`lims`参数设置评估网格的可选*x*-*y*限制。这个参数接受一个长度为4的数值向量，顺序为*x*轴的下限和上限，接着是*y*轴的下限和上限。以下代码使用研究区域的边界重新估计密度并绘制图形。结果显示在[图
    25-17](ch25.xhtml#ch25fig17)的右下角。
- en: '[PRE70]'
  id: totrans-363
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: With that, you’ve solved the problem of ensuring your surface spans the desired
    area. However, this definitely highlights the second problem—the data that were
    actually observed fall strictly within the defined polygon, but you can see plotted
    pixels outside the geographical region, which doesn’t make sense. You can control
    precisely which pixels are plotted in any given pixel image by setting the relevant
    entries in your *z*-matrix to be `NA` if you don’t want them drawn.
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: 这样，你就解决了确保表面覆盖所需区域的问题。然而，这也明确突出了第二个问题——实际观察到的数据严格位于定义的多边形内，但你可以看到地理区域外的像素被绘制出来，这显然不合逻辑。你可以通过将*z*矩阵中相关条目的值设为`NA`来精确控制在任何给定像素图像中绘制哪些像素。
- en: You’ll need a mechanism that can decide whether a given cell entry in your *z*-matrix,
    namely, `chor.dens.WIN$z`, corresponds to a location inside or outside the polygon
    (the object `chor.WIN`). If it falls outside, you’ll want to force that entry
    to be `NA`. In general, this type of decision making requires you to test each
    element of the matrix with respect to its coordinate value on the evaluation grid,
    possibly using your own R function. Fortunately, in this case, the `inside.owin`
    function of `spatstat` does exactly that, but the principle remains the same whenever
    you need control over precisely which pixels are plotted and which aren’t.
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: 你需要一个机制来判断你的*z*矩阵中某个特定单元格的条目，即`chor.dens.WIN$z`，是否对应于多边形内部或外部的位置（对象`chor.WIN`）。如果它位于外部，你会希望强制该条目为`NA`。通常，这种类型的决策需要你根据评估网格中的坐标值来测试矩阵中的每个元素，可能需要使用你自己的R函数。幸运的是，在这种情况下，`spatstat`包中的`inside.owin`函数正是做了这件事，但无论何时你需要精确控制哪些像素被绘制，哪些没有，被绘制的像素也需要类似的原则。
- en: 'Given one or more two-dimensional (*x*,*y*) coordinates and an object of class
    `"owin"`, the `inside.owin` function returns a corresponding logical vector with
    a `TRUE` for those coordinates inside the defined region and a `FALSE` for any
    other coordinate. As a quick demonstration, observe the following result:'
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: 给定一个或多个二维(*x*,*y*)坐标和一个类为`"owin"`的对象，`inside.owin`函数返回一个相应的逻辑向量，其中坐标在定义区域内的为`TRUE`，其他坐标为`FALSE`。作为快速演示，请观察以下结果：
- en: '[PRE71]'
  id: totrans-367
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: This confirms what you can see from [Figure 25-17](ch25.xhtml#ch25fig17)—that
    the coordinate (355,420) lies well within the polygon and that the coordinate
    (345,415) doesn’t.
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: 这确认了你可以从[图 25-17](ch25.xhtml#ch25fig17)看到的内容——坐标(355,420)位于多边形内，而坐标(345,415)不在其中。
- en: Now, you need to use the `inside.owin` function on every coordinate in the evaluation
    grid that *z*-matrix `chor.dens.WIN$z` sits on. First, create the full set of
    grid coordinates using `expand.grid`, in the same way as illustrated in [Section
    25.3.1](ch25.xhtml#ch25lev2sec251).
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你需要在评估网格上的每个坐标使用`inside.owin`函数，该网格上的*z*-矩阵`chor.dens.WIN$z`所在的区域。首先，使用`expand.grid`创建完整的网格坐标集，方式与[第
    25.3.1 节](ch25.xhtml#ch25lev2sec251)中所示相同。
- en: '[PRE72]'
  id: totrans-370
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: Calling `nrow` on the resulting data frame of coordinates confirms you have
    exactly 256² = 65536 grid points as defined in the `chor.dens.WIN` KDE object.
    The following call then takes the two columns of `chor.xy` and makes use of logical
    negation (using `!`) to produce a logical vector that flags grid coordinates that
    are located *outside* the defined geographical region.
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: 对结果数据框的坐标调用`nrow`可以确认你有正好256² = 65536个网格点，这些点在`chor.dens.WIN` KDE对象中被定义。接下来的调用将使用`chor.xy`的两列，并通过逻辑取反（使用`!`）生成一个逻辑向量，标记那些位于定义的地理区域*外部*的网格坐标。
- en: '[PRE73]'
  id: totrans-372
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: The final step is now at hand.
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: 最后的步骤现在已经到来。
- en: '[PRE74]'
  id: totrans-374
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: First, for clarity, recast the long `chor.outside` vector as a 256 × 256 matrix
    to emphasize that it corresponds exactly to the *z*-matrix of interest. Then this
    logical flag matrix is used to directly overwrite the “outside” entries in the
    *z*-matrix to be `NA`.
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，为了清晰起见，将长的`chor.outside`向量重新组织为一个256 × 256的矩阵，以强调它完全对应于感兴趣的*z*-矩阵。然后，这个逻辑标志矩阵用于直接覆盖*z*-矩阵中的“外部”条目，将其设置为`NA`。
- en: 'All that’s left now is to plot the image with the newly manipulated *z*-matrix.
    Make sure you have the `shape` package loaded for the finishing touch of a color
    legend. The following code creates the KDE surface pixel image plot with pixel
    points restricted to the geographical region defined by `$window` only:'
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: 现在剩下的就是用新处理过的*z*-矩阵绘制图像。确保你已经加载了`shape`包，以完成颜色图例的最后处理。以下代码创建了KDE表面像素图，只将像素点限制在由`$window`定义的地理区域内：
- en: '[PRE75]'
  id: totrans-377
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: First you open a new graphics device and widen the right margin to incorporate
    the color legend. Next you invoke `image` to plot, specifically using an *L*-shaped
    box and a strict one-to-one *x*-*y* aspect ratio, and then you add the region
    polygon with slightly thicker lines. Finally you execute `colorlegend` to obtain
    an appropriately positioned legend referencing the color values (the specific
    positioning and tick marks of which were found after a little trial and error).
    You can see the final result in [Figure 25-18](ch25.xhtml#ch25fig18).
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，你打开一个新的图形设备，并将右边距加宽，以容纳颜色图例。接着，你调用`image`函数绘制图形，具体使用一个*L*形框，并保持严格的1:1的*x*-*y*纵横比，然后你添加一个略微加粗的区域多边形。最后，你执行`colorlegend`来获得一个适当位置的图例，引用颜色值（该位置和刻度线是通过一些试验和错误后确定的）。你可以在[图
    25-18](ch25.xhtml#ch25fig18)中看到最终结果。
- en: '![image](../images/f25-18.jpg)'
  id: totrans-379
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f25-18.jpg)'
- en: '*Figure 25-18: Final pixel image plot of the Chorley-Ribble KDE surface, restricted
    to the geographical study region of the originally collected data.*'
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 25-18：Chorley-Ribble KDE表面最终像素图，只包含原始收集数据的地理研究区域。*'
- en: '**NOTE**'
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*In truncating the kernel estimate of the bivariate density estimate that was
    originally defined over the full rectangular evaluation grid, technically you
    no longer have a valid probability density function as a result (since the integral
    over the irregular region will no longer evaluate to a total probability of 1).
    A more mathematically sound approach requires a deeper knowledge of multivariate
    KDE and is beyond the scope of this text. Nevertheless, being able to truncate
    pixel plots like this is useful in any situation where you want to define your
    surface on a (possibly irregular) subset of an overall rectangular evaluation
    grid.*'
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: '*在截断最初定义在整个矩形评估网格上的二元密度估计核时，从技术上讲，你不再拥有有效的概率密度函数（因为在不规则区域上的积分将无法评估为总概率1）。一个更数学上严谨的方法需要更深入的多元KDE知识，超出了本书的范围。然而，能够像这样截断像素图在任何情况下都很有用，尤其是在你想在一个（可能不规则的）子集上定义你的表面时。*'
- en: '**Exercise 25.4**'
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: '**练习 25.4**'
- en: 'Revisit the built-in `airquality` data set and take a look at the help file
    to refresh your memory of the variables present. Create a copy of the data frame:
    select the columns pertaining to daily temperature, wind speed, and ozone level
    and use `na.omit` to remove any records with missing values.'
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: 重新查看内置的`airquality`数据集，并查看帮助文件以刷新你对现有变量的记忆。创建数据框的副本：选择与每日温度、风速和臭氧水平相关的列，并使用`na.omit`删除任何包含缺失值的记录。
- en: From your explorations of these data in [Chapter 24](ch24.xhtml#ch24), there
    appears to be an association among daily temperature, wind speed, and ozone level.
    Fit a multiple linear regression model that aims to predict mean temperature based
    on the wind speed and ozone level, including an interactive effect. Summarize
    the resulting object.
  id: totrans-385
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从你在[第24章](ch24.xhtml#ch24)中对这些数据的探索来看，似乎存在日温度、风速和臭氧水平之间的关联。拟合一个多元线性回归模型，旨在根据风速和臭氧水平预测平均温度，包括交互效应。总结结果对象。
- en: Using the model from (a), construct a *z*-matrix of predicted mean daily temperature
    based on a 50 × 50 evaluation grid in both wind speed and ozone.
  id: totrans-386
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用(a)中的模型，基于风速和臭氧的50 × 50评估网格构建一个*z*矩阵，预测每日平均温度。
- en: 'Create a pixel image of the response surface, superimposing the raw observations
    as per the following:'
  id: totrans-387
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建响应面像素图像，并根据以下要求叠加原始观测值：
- en: – A graphics device should be initialized based on bottom, left, top, and right
    margin lines of 5, 4, 4, and 6, respectively.
  id: totrans-388
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: – 应该根据底部、左侧、顶部和右侧的边距线分别初始化一个图形设备，边距线分别为5、4、4和6。
- en: – 20 colors from the built-in `topo.colors` palette should be used to produce
    the image; include tidy axis titles.
  id: totrans-389
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: – 应使用来自内建`topo.colors`调色板的20种颜色来生成图像；包括整洁的坐标轴标题。
- en: – Revisit the `normalize` function defined in [Section 25.1.4](ch25.xhtml#ch25lev2sec245)
    and use the built-in function `gray` to generate a vector of gray colors (refer
    to [Section 25.1.2](ch25.xhtml#ch25lev2sec243)) based on the normalized raw temperature
    observations. Superimpose the raw observations based on wind speed and ozone onto
    the pixel image, using the gray color vector to indicate the corresponding temperature
    observations.
  id: totrans-390
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: – 重新访问在[第25.1.4节](ch25.xhtml#ch25lev2sec245)中定义的`normalize`函数，并使用内建的`gray`函数生成一个灰色调色板（请参阅[第25.1.2节](ch25.xhtml#ch25lev2sec243)）基于规范化后的原始温度观测。根据风速和臭氧叠加原始观测到像素图像上，使用灰色调色板来表示相应的温度观测。
- en: – Two separate calls should then be made to `colorlegend` of the `shape` package.
    The first should appear in the space on the right margin, referencing the surface
    itself. The second should use the built-in `gray.colors` function, setting the
    optional arguments `start=0` and `end=1`, to generate 10 shades of gray for use
    in the legend that references the raw temperature observations of the superimposed
    points. This legend should reside on top of the pixel image itself, in the upper-right
    quadrant where there are no raw observations.
  id: totrans-391
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: – 然后，应该分别调用`shape`包中的`colorlegend`两次。第一次应出现在右侧边距的空间，引用表面本身。第二次应使用内建的`gray.colors`函数，设置可选参数`start=0`和`end=1`，生成10种灰度用于表示原始温度观测值的图例，这个图例应位于像素图像的右上角，没有原始观测值的地方。
- en: – Both legends should have appropriate titles, and you may need to experiment
    a little with the `posx` and `posy` arguments to find satisfactory placement.
  id: totrans-392
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: – 两个图例应具有适当的标题，您可能需要稍微调整`posx`和`posy`参数，以找到满意的放置位置。
- en: My result of this plotting exercise appears here.
  id: totrans-393
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我的绘图练习结果如下所示。
- en: '![image](../images/f0677-01.jpg)'
  id: totrans-394
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![image](../images/f0677-01.jpg)'
- en: 'In [Section 25.5.2](ch25.xhtml#ch25lev2sec257), you used the `chorley` data
    set in creating a pixel image truncated to a subset of the overall rectangular
    evaluation grid. Ensure `spatstat` is loaded in your current R session and execute
    the following two lines:'
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第25.5.2节](ch25.xhtml#ch25lev2sec257)中，你使用了`chorley`数据集来创建一个截取了整体矩形评估网格子集的像素图像。确保在当前的R会话中加载了`spatstat`，并执行以下两行代码：
- en: R> fire <- split(clmfires)$intentional
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
  zh: R> fire <- split(clmfires)$intentional
- en: R> firewin <- clmfires$window
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
  zh: R> firewin <- clmfires$window
- en: This extracts the 1,786 locations of fires recorded as intentionally lit in
    a particular region of Spain. The spatial coordinates can be extracted as the
    `$x` and `$y` members of `fire`, and the geographical region itself is stored
    as a polygon in `firewin` (of the same class as the `chorley$window` object you
    looked at earlier). See the documentation obtained with `?clmfires` for further
    details.
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码提取了记录为故意点燃的火灾位置，共计1,786个位置，位于西班牙的某个特定区域。空间坐标可以作为`fire`的`$x`和`$y`成员提取，而地理区域本身则作为多边形存储在`firewin`中（它与之前查看的`chorley$window`对象属于同一类）。更多细节请参见使用`?clmfires`获得的文档。
- en: Using the total *x*- and *y*-range of the study region, use `kde2d` from the
    `MASS` package to calculate a bivariate kernel estimate of the probability density
    function of the spatial dispersion of intentionally lit fires. The KDE surface
    should be calculated based on a 256 × 256 evaluation grid.
  id: totrans-399
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用研究区域的总*x*和*y*范围，使用`MASS`包中的`kde2d`计算空间分布的二元核密度估计。KDE表面应基于256 × 256的评估网格计算。
- en: Identify all points on the rectangular evaluation grid that fall outside the
    geographical region using `expand.grid` in conjunction with `inside.owin`. Set
    all corresponding pixels of the density surface to `NA`.
  id: totrans-400
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`expand.grid`与`inside.owin`结合，识别所有落在矩形评估网格外的点。将密度表面上所有对应的像素设置为`NA`。
- en: 'Construct a pixel image of the truncated density, as per the following:'
  id: totrans-401
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 构建一个截断密度的像素图，具体如下：
- en: – The graphics device should have three lines of space on the bottom, left,
    and top of the plot region and should have seven lines on the right.
  id: totrans-402
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: – 图形设备应在绘图区域的底部、左侧和顶部留有三行空间，右侧留有七行空间。
- en: – In producing the image itself, you should use 50 colors generated from the
    built-in `heat.colors` palette. A one-to-one aspect ratio should be maintained,
    the axis titles should be suppressed, and the box type set to be an *L* shape.
  id: totrans-403
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: – 在生成图像时，应使用`heat.colors`调色板生成的50种颜色。应保持1:1的纵横比，压制坐标轴标题，并将框类型设置为*L*形。
- en: – The geographical study region should be superimposed onto the image using
    a double-width line.
  id: totrans-404
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: – 应使用双宽度的线条将地理研究区域叠加到图像上。
- en: – Using `colorlegend` from `shape`, a color legend referencing the density with
    an appropriate title should be placed to the right of the image. You’ll need to
    experiment with the `posx` argument for placement. Label the legend at a sequence
    from `5e-6` to `35e-6` in steps of `5e-6` (refer to [Section 2.1.3](ch02.xhtml#ch02lev2sec19)
    for an explanation of e-notation); also, ensure these labels are able to display
    up to six decimal places of precision.
  id: totrans-405
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: – 使用`shape`中的`colorlegend`，应在图像右侧放置一个参考密度的颜色图例，并附上合适的标题。你需要尝试调整`posx`参数来确定图例的位置。图例标签应从`5e-6`到`35e-6`，步长为`5e-6`（有关e记数法的解释，请参见[第2.1.3节](ch02.xhtml#ch02lev2sec19)）；同时，确保这些标签可以显示最多六位小数的精度。
- en: For your reference, my result is given here.
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
  zh: 供你参考，我的结果在此给出。
- en: '![image](../images/f0679-01.jpg)'
  id: totrans-407
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f0679-01.jpg)'
- en: '**25.6 Perspective Plots**'
  id: totrans-408
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**25.6 透视图**'
- en: The last kind of plot you’ll look at in this chapter is the *perspective plot*,
    some-times also referred to as a *wireframe*. Unlike contour plots and pixel images,
    where fluctuations in the surface are emphasized with line patterns and/or colors,
    a perspective plot uses a physical third dimension against which the *z* value
    is plotted.
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中你将看到的最后一种图形是*透视图*，有时也被称为*线框图*。与等高线图和像素图不同，后者通过线条模式和/或颜色强调表面的波动，而透视图则利用物理的第三维度，在此基础上绘制*z*值。
- en: '***25.6.1 Basic Plots and Angle Adjustment***'
  id: totrans-410
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***25.6.1 基本图形和角度调整***'
- en: Perspective plots are especially useful when you want to emphasize the fluctuating
    nature of the values populating your *z*-matrix. For example, in some applications
    you might want to get a good impression of the relative extremity of any present
    peaks and/or troughs in the plotted surface, which is harder to do in, for example,
    a pixel image or contour plot.
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
  zh: 透视图在你想强调填充*z*矩阵的值波动特性时尤其有用。例如，在某些应用中，你可能希望能够很好地感知绘制表面中任何峰值和/或谷值的相对极值，这在像素图或等高线图中更难实现。
- en: 'Recall the `mtcars` response surface plotted as contours and as pixel images
    in [Sections 25.4.1](ch25.xhtml#ch25lev2sec254) and [25.5.1](ch25.xhtml#ch25lev2sec256).
    You created a 20 × 20 evaluation grid in the horsepower and weight variables,
    as well as a corresponding *z*-matrix of 400 giving the predicted mean MPG result:'
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
  zh: 回顾在[第25.4.1节](ch25.xhtml#ch25lev2sec254)和[25.5.1节](ch25.xhtml#ch25lev2sec256)中绘制的`mtcars`响应面，包括等高线图和像素图。你在马力和重量变量上创建了一个20
    × 20的评估网格，并得到了相应的400个*z*矩阵值，表示预测的平均MPG结果：
- en: '[PRE76]'
  id: totrans-413
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: 'The built-in R function `persp` is used to create perspective plots. Its basic
    usage is the same as `contour`, `filled.contour`, and `image`. Your increasing
    sequences in the *x*- and *y*-axis directions, which define the evaluation grid,
    are passed to `x` and `y`, with your corresponding *z*-matrix passed to `z`. Bring
    up the default appearance for the 20 × 20 `mtcars` response surface with the following:'
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
  zh: 内建的R函数`persp`用于创建透视图。它的基本用法与`contour`、`filled.contour`和`image`相同。你在*x*轴和*y*轴方向上的递增序列（定义了评估网格）被传递给`x`和`y`，而对应的*z*矩阵则传递给`z`。用以下代码可以显示20
    × 20 `mtcars`响应面图的默认外观：
- en: '[PRE77]'
  id: totrans-415
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: This appears in the top left of [Figure 25-19](ch25.xhtml#ch25fig19).
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
  zh: 该示例出现在[第25-19图](ch25.xhtml#ch25fig19)的左上方。
- en: Interpreting the perspective plot is straightforward. The default viewing angle
    shows the *x*-axis in the foreground, increasing from left to right, and the *y*-axis
    on the left side, increasing from the foreground to deeper in the background.
    In this way, the evaluation grid lies flat along the bottom in the 3D graphic,
    with the *z*-axis against which your surface is plotted increasing from the bottom
    vertically to the top.
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
  zh: 解读透视图是简单直接的。默认的视角显示了前景中的*x*轴，从左到右递增，左侧显示了*y*轴，从前景延伸到背景深处。这样，评估网格就平铺在三维图形的底部，*z*轴即你绘制表面的轴，从底部垂直向上递增。
- en: The viewing angle is one of the most important aspects of such a plot. In `persp`,
    you can control it with the two optional arguments `theta`, which spins the plot
    around horizontally, and `phi`, which adjusts the vertical viewing position. Both
    are specified in degrees; `theta` defaults to `0`, so you’re looking directly
    at the *x*-axis spanning left to right in front of you, and `phi` defaults to
    `15` to give a slightly elevated viewing position so you can see the *y*-axis
    extending foreground to background. In general, you can think of the possible
    value of `theta` as anywhere from `0` to `360`, representing a complete rotation
    all around the plot, and the possible value of `phi` as anywhere from `90` to
    `-90`, the range of which moves you from a bird’s-eye view directly from the top
    looking down to a submarine view directly from the bottom looking up.
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
  zh: 视角是这种图形中最重要的方面之一。在`persp`中，你可以通过两个可选参数来控制它，`theta`用于水平旋转图形，`phi`用于调整垂直视角。两者的单位都是度；`theta`的默认值是`0`，这意味着你正对着从左到右的*x*轴，`phi`的默认值是`15`，让视角稍微抬高一些，以便看到从前景到背景延伸的*y*轴。一般来说，你可以将`theta`的可能值视为从`0`到`360`，代表围绕图形进行一次完整的旋转，而`phi`的可能值则是从`90`到`-90`，这一范围将视角从鸟瞰图直接从上方俯视到潜水员视角直接从下方仰视。
- en: 'This second example demonstrates this behavior:'
  id: totrans-419
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个示例展示了这种行为：
- en: '[PRE78]'
  id: totrans-420
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: In fact, it’s this line of code that originally produced the rightmost image
    in [Figure 21-9](ch21.xhtml#ch21fig9) on [page 523](ch21.xhtml#page_523) (when
    you were introduced to the concept of an interactive term between two continuous
    predictors in a multiple linear regression model). The graphic is reproduced here
    in the top right of [Figure 25-19](ch25.xhtml#ch25fig19). The axis titles are
    tidied up using `xlab` and `ylab`, with `zlab` used to control the title for the
    third vertical axis. The use of `theta` and `phi` in this instance has elevated
    the viewing point slightly more than the default and rotated the plot so that
    the origin (in other words, the lower vertex denoting the lower limit of the *x*-*y*
    plane) is prominent in the foreground. It’s worth noting that increasing `theta`
    from `0` rotates the plot in a clockwise-horizontal fashion, but you could also
    supply a negative value to that argument to rotate the plot in the other direction.
    Setting `theta=-30`, as shown here, has the same effect as setting `theta=330`.
  id: totrans-421
  prefs: []
  type: TYPE_NORMAL
  zh: 事实上，正是这行代码最初生成了[第21-9图](ch21.xhtml#ch21fig9)右侧的图像，位于[第523页](ch21.xhtml#page_523)（当你第一次接触到多重线性回归模型中两个连续预测变量的交互项的概念时）。该图形在[第25-19图](ch25.xhtml#ch25fig19)的右上方被重新呈现。轴标题通过`xlab`和`ylab`进行了整理，`zlab`则用于控制第三个垂直轴的标题。此示例中`theta`和`phi`的使用稍微抬高了视角，并旋转了图形，使得原点（即表示*x*-*y*平面下限的下端点）更加突出在前景。值得注意的是，增大`theta`值（从`0`开始）会使图形顺时针水平旋转，但你也可以给该参数传递负值来使图形逆时针旋转。将`theta=-30`，如这里所示，与设置`theta=330`具有相同的效果。
- en: '![image](../images/f25-19.jpg)'
  id: totrans-422
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f25-19.jpg)'
- en: '*Figure 25-19: Perspective plots of the 20* × *20* `mtcars` *response surface
    created using* `persp`*. Top left: Default appearance. Top right: Using* `theta`
    *and* `phi` *to adjust the viewing angle. Bottom left: Setting* `ticktype="detailed"`
    *to provide detailed axis labeling. Bottom right: Adding depth shading using*
    `shade` *and removing facet border lines with* `border=NA`.'
  id: totrans-423
  prefs: []
  type: TYPE_NORMAL
  zh: '*图25-19：使用`persp`创建的20* × *20* `mtcars` *响应面透视图。左上角：默认外观。右上角：使用* `theta` *和*
    `phi` *调整视角。左下角：设置* `ticktype="detailed"` *提供详细的轴标签。右下角：使用* `shade` *添加深度阴影，并通过*
    `border=NA` *移除面边框线。*'
- en: 'By default, there are no tick marks or labels included, only directional arrows.
    You can remedy this by setting the optional `ticktype` argument to `"detailed"`.
    You can find the result of the following in the bottom left of [Figure 25-19](ch25.xhtml#ch25fig19),
    which also offers another viewing angle:'
  id: totrans-424
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，没有勾选标记或标签，只有方向箭头。你可以通过将可选的`ticktype`参数设置为`"detailed"`来解决这个问题。你可以在[图25-19](ch25.xhtml#ch25fig19)的左下角查看以下结果，该图还提供了另一个视角：
- en: '[PRE79]'
  id: totrans-425
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: The help file `?persp` details a host of other arguments specific to controlling
    the presentation of any given perspective plot. As a few examples, you could shade
    the surface in grayscale to emphasize the 3D depth of the image, you could change
    the color or suppress the plotting of the grid lines making up the surface itself,
    or you could change the relative length of the *z*-axis. The final plot of the
    `mtcars` response surface illustrates such actions. The result of the following
    call is visible in the bottom right of [Figure 25-19](ch25.xhtml#ch25fig19).
  id: totrans-426
  prefs: []
  type: TYPE_NORMAL
  zh: 帮助文件`?persp`详细列出了控制任何给定透视图展示的其他许多参数。例如，你可以将表面着色为灰度，以强调图像的三维深度，或者你可以更改颜色或抑制组成表面的网格线的绘制，或者你可以更改*z*轴的相对长度。`mtcars`响应面的最终图示例展示了这些操作。以下调用的结果可以在[图25-19](ch25.xhtml#ch25fig19)的右下角看到。
- en: '[PRE80]'
  id: totrans-427
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: With the same viewing angle as the previous plot, this plot uses the `shade`
    argument to shade the surface facets to produce a lighting-style effect, enhancing
    the perceptive depth slightly. The calculations for the shading rely on a non-negative
    numeric value; setting `shade=0.6` provides a moderate-strength effect. You might
    like to experiment with larger or smaller values. If you’re shading the surface
    in this way, it’s usually best to suppress the grid lines that by default make
    up the surface; you can set `border=NA` to achieve this (the `border` argument
    can also be used to simply change the surface grid color by supplying any valid
    R color to it). Finally, the `expand` argument is used to adjust the size of the
    *z*-axis. Specifying `expand=0.8` requests a vertical axis that is 80 percent
    the size of the axes in the evaluation grid, producing a slightly “squashed down”
    prism in which the surface is drawn. You could also use values greater than 1
    for `expand`, in which case the effect would be to “stretch out” the plot along
    the vertical.
  id: totrans-428
  prefs: []
  type: TYPE_NORMAL
  zh: 这张图与前一张图使用相同的视角，通过`shade`参数为表面面板着色，产生一种光照效果，稍微增强了感知的深度。阴影的计算依赖于一个非负数值；设置`shade=0.6`会提供一个中等强度的效果。你可以尝试更大或更小的值。如果你以这种方式给表面着色，通常最好抑制默认构成表面的网格线；你可以通过设置`border=NA`来实现这一点（`border`参数也可以通过提供任何有效的R颜色来改变表面网格的颜色）。最后，`expand`参数用于调整*z*轴的大小。指定`expand=0.8`会请求一个垂直轴，其大小为评估网格中轴的80%，从而在其中绘制出一个稍微“压扁”的棱柱。你还可以为`expand`指定大于1的值，在这种情况下，效果是沿垂直方向“拉伸”图形。
- en: '***25.6.2 Coloring Facets***'
  id: totrans-429
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***25.6.2 着色面板***'
- en: Like most traditional R plotting commands, you can use the optional `col` argument
    to color the facets of a perspective surface. To color a perspective surface with
    a constant color throughout, you would just provide `col` with a single value.
  id: totrans-430
  prefs: []
  type: TYPE_NORMAL
  zh: 与大多数传统的R绘图命令一样，你可以使用可选的`col`参数为透视表面着色。如果你希望透视表面以恒定颜色填充，只需为`col`提供一个单一的值。
- en: If you’re interested in `col`, however, it’s often the case that you want to
    color the surface according to the fluctuating *z*-values to highlight the changing
    value of the bivariate function. To successfully do this for the facets making
    up the surface, it’s important to understand that these facets aren’t the same
    as the pixels that would make up a pixel image of the same *z*-matrix. Where `image`
    pixels are directly represented by the entries of, say, your *m* × *n*-sized *z*-matrix,
    `persp` facets should be interpreted as the space *between* the border lines drawn
    at those matrix entries, leaving you with (*m* − 1) × (*n* − 1) facets. In other
    words, in a perspective plot, each *z*-matrix entry lies at an intersection of
    the drawn lines—the *z*-matrix entries are *not* situated in the middle of each
    facet.
  id: totrans-431
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果你对`col`感兴趣，通常情况下，你会希望根据波动的*z*值为表面着色，以突出显示二元函数值的变化。为了成功地为构成表面的各个面片进行着色，重要的是要理解，这些面片与构成同一*z*矩阵的像素不同。`image`像素由例如你的*m*
    × *n*大小的*z*矩阵条目直接表示，而`persp`面片应该理解为这些矩阵条目处绘制的边界线之间的空间，这样你会得到(*m* − 1) × (*n* −
    1)个面片。换句话说，在透视图中，每个*z*矩阵条目位于绘制线条的交点处——*z*矩阵条目*不是*位于每个面片的中心。
- en: To illustrate this, take another look at [Figure 25-9](ch25.xhtml#ch25fig9)
    on [page 656](ch25.xhtml#page_656). When you use `image`, R automatically calculates
    the pixel sizes based on your *x*- and *y*-axis evaluation grid sequences and
    plots the surface based on the rectangles formed by the dashed gray lines, with
    the *z*-matrix entries `a`, `b`, `c`, and so on, represented directly. When you
    use `persp`, however, the visible border lines are represented by the solid-line
    grid (of arrows), intersecting at each entry, and so the facets of the resulting
    surface are formed by the space between these lines, each one defined by four
    adjacent entries. [Figure 25-20](ch25.xhtml#ch25fig20) shows a section of the
    hypothetical grid in [Figure 25-9](ch25.xhtml#ch25fig9), where I’ve marked off
    one pixel as interpreted by `image` and one facet as interpreted by `persp`. With
    that, you can see why, in [Figure 25-9](ch25.xhtml#ch25fig9), there would be exactly
    6 × 4 = 24 pixels in an image plot but 5 × 3 = 15 facets in a perspective plot.
  id: totrans-432
  prefs: []
  type: TYPE_NORMAL
  zh: 为了说明这一点，再看一眼[图25-9](ch25.xhtml#ch25fig9)中的内容，位于[656页](ch25.xhtml#page_656)。当你使用`image`时，R会根据你的*x*和*y*轴评估网格序列自动计算像素大小，并根据虚线灰色线条形成的矩形绘制表面，直接表示*z*矩阵条目`a`、`b`、`c`等。当你使用`persp`时，然而，边界线是通过实线网格（箭头）表示的，在每个条目处交叉，因此，生成的表面的面片是由这些线之间的空间形成的，每个面片由四个相邻条目定义。[图25-20](ch25.xhtml#ch25fig20)显示了[图25-9](ch25.xhtml#ch25fig9)中假设网格的一部分，我标出了`image`解释的一个像素和`persp`解释的一个面片。这样，你可以理解为什么在[图25-9](ch25.xhtml#ch25fig9)中，图像绘图中会有6
    × 4 = 24个像素，而透视图中会有5 × 3 = 15个面片。
- en: '![image](../images/f25-20.jpg)'
  id: totrans-433
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f25-20.jpg)'
- en: '*Figure 25-20: Illustrating the difference in treatment of the* z*-matrix in
    a pixel image and in a perspective plot. The highlighted box in the bottom-left
    corner represents an* `image` *pixel of the value* `a` *in the* z*-matrix; the
    highlighted box to the right represents a* `persp` *facet formed by the values*
    `b`, `h`, `i`*, and* `c`*. For coloring, the* z*-value of the highlighted facet
    will be calculated as the mean of those four entries, in other words,* (`b` +
    `h` + `i` + `c`)*/4.*'
  id: totrans-434
  prefs: []
  type: TYPE_NORMAL
  zh: '*图25-20：说明像素图像和透视图中*z*矩阵处理的区别。左下角突出显示的框代表值为`a`的`image`像素，右侧突出显示的框代表由`b`、`h`、`i`和`c`值形成的`persp`面片。为了着色，突出显示的面片的*z*值将被计算为这四个条目的平均值，换句话说，*(`b`
    + `h` + `i` + `c`)* / 4*。*'
- en: The `col` argument needs to specify the (*m* − 1) × (*n* − 1) facet colors (assuming
    an *m* × *n z*-matrix passed to `z`). The typical way to find this in R if you’re
    intending to color the facets according to the *z*-value is to first calculate
    each facet’s *z*-value, which will be the average of the four adjacent *z*-matrix
    entries. Only thereafter can you deploy one of the color assignment approaches
    from [Section 25.1.4](ch25.xhtml#ch25lev2sec245).
  id: totrans-435
  prefs: []
  type: TYPE_NORMAL
  zh: '`col`参数需要指定(*m* − 1) × (*n* − 1)个面片的颜色（假设传递给`z`的是一个*m* × *n*的*z*矩阵）。如果你打算根据*z*值为面片着色，在R中找到这个方法的典型方式是，首先计算每个面片的*z*值，该值将是四个相邻*z*矩阵条目的平均值。只有这样，你才能部署[第25.1.4节](ch25.xhtml#ch25lev2sec245)中的一种颜色分配方法。'
- en: Let’s recast the pixel image of the Chorley-Ribble kernel density estimate (Example
    4; [Figure 25-18](ch25.xhtml#ch25fig18)), complete with *z*-axis-specific coloring,
    as a perspective plot. First, make sure you have the packages `spatstat` and `MASS`
    already loaded. Then repeat the code from earlier to obtain the kernel estimate
    on the appropriate evaluation grid, truncated to the geographical study region.
  id: totrans-436
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们将 Chorley-Ribble 核密度估计的像素图像（示例 4；[图 25-18](ch25.xhtml#ch25fig18)），并加入 *z*
    轴特定的着色，重新绘制为一个透视图。首先，确保已经加载了 `spatstat` 和 `MASS` 这两个包。然后重复之前的代码，以便在适当的评估网格上获得核估计，并将其截断到地理研究区域。
- en: '[PRE81]'
  id: totrans-437
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: 'Next, you need to calculate all the facet *z* values; this can be done en masse
    with the following code:'
  id: totrans-438
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，你需要计算所有的面片 *z* 值；可以使用以下代码批量完成此操作：
- en: '[PRE82]'
  id: totrans-439
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: The first three lines simply store the *z*-matrix as the object `zm` and its
    total rows and columns (both 256 in this case) as `nr` and `nc`, respectively,
    for compactness of the code.
  id: totrans-440
  prefs: []
  type: TYPE_NORMAL
  zh: 前三行只是将 *z* 矩阵存储为对象 `zm`，并将其总行数和列数（在此情况下都是 256）分别存储为 `nr` 和 `nc`，以使代码更加简洁。
- en: 'The fourth line is where the relevant calculations happen, giving a matrix
    of the facet *z* values. It does this systematically, by element-wise summation
    of four versions of the original *z*-matrix: `zm[-1,-1]` (first row and first
    column omitted), `zm[-1,-nc]` (first row, last column omitted), `zm[-nr,-1]` (last
    row, first column omitted), and `zm[-nr,-nc]` (last row, last column omitted).
    When the four alternates are summed in this way and divided by 4 at the end, the
    result is a matrix `zf`, each element of which is the four-point average of each
    “rectangle” of four adjacent entries in the original *z*-matrix, exactly as noted
    in the discussion and caption of [Figure 25-20](ch25.xhtml#ch25fig20). The final
    call to `dim` on `zf` confirms the size of the result. Since there are a total
    of 256 × 256 evaluation grid lines in the defined *z*-matrix, these encapsulate
    a total of 255 × 255 perspective facets.'
  id: totrans-441
  prefs: []
  type: TYPE_NORMAL
  zh: 第四行是进行相关计算的地方，生成一个面片 *z* 值的矩阵。它通过对原始 *z* 矩阵的四个版本按元素逐个求和来系统地完成此操作：`zm[-1,-1]`（省略第一行和第一列）、`zm[-1,-nc]`（省略第一行和最后一列）、`zm[-nr,-1]`（省略最后一行和第一列）、以及
    `zm[-nr,-nc]`（省略最后一行和最后一列）。当这四个替代矩阵按此方式相加并在最后除以 4 时，结果是一个矩阵 `zf`，其每个元素是原始 *z*
    矩阵中四个相邻条目所组成的每个“矩形”的四点平均值，正如[图 25-20](ch25.xhtml#ch25fig20)中的讨论和标题所述。对 `zf` 的最终
    `dim` 调用确认了结果的大小。由于定义的 *z* 矩阵中总共有 256 × 256 的评估网格线，因此这些网格包含了总共 255 × 255 的透视面片。
- en: 'The hard work is done, and all you need to do now is assign the colors from
    your palette to the calculated facet *z* values in `zf`. You can do this using
    either the categorization or normalization approach, as noted in [Section 25.1.4](ch25.xhtml#ch25lev2sec245);
    for simplicity, let’s stick to categorization. Consider the following code:'
  id: totrans-442
  prefs: []
  type: TYPE_NORMAL
  zh: 繁重的工作已经完成，现在你只需要将调色板中的颜色分配给 `zf` 中计算出的面片 *z* 值。你可以使用分类方法或标准化方法来完成此操作，如[第 25.1.4
    节](ch25.xhtml#ch25lev2sec245)中所述；为了简便起见，我们保持使用分类方法。考虑以下代码：
- en: '[PRE83]'
  id: totrans-443
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: The first line is repeated from [Section 25.5.2](ch25.xhtml#ch25lev2sec257)
    to generate the same 200 colors from the built-in `rainbow` palette as were used
    in the pixel images. The second line sets up an evenly spaced sequence spanning
    the range of the calculated facet *z*-values to form the category break points
    that are required by the categorization approach. Note the use of `na.rm=TRUE`
    in the required calls to `min` and `max` to avoid all the `NA` entries present
    in `zf` (remember, the surface has been truncated to the irregular polygon representing
    the geographical study region). The sequence is one more in length than the number
    of generated colors—again, refer to [Section 25.1.4](ch25.xhtml#ch25lev2sec245)
    for this necessary feature of the categorization approach. Lastly, `cut` assigns
    each of the `zf` facet value entries an appropriate rank with respect to the 200
    ordered bins. As you’ve learned, the `zf.colors` ranks are subsequently used to
    index the vector of 200 colors stored in `rbow` when plotting.
  id: totrans-444
  prefs: []
  type: TYPE_NORMAL
  zh: 第一行是从[第 25.5.2 节](ch25.xhtml#ch25lev2sec257)重复的，用于生成与像素图像中相同的 200 种颜色，这些颜色来自内置的
    `rainbow` 调色板。第二行设置了一个均匀间隔的序列，跨度为计算出的面片 *z* 值的范围，用来形成分类方法所需的类别断点。请注意，在调用 `min`
    和 `max` 时使用了 `na.rm=TRUE`，以避免 `zf` 中的所有 `NA` 项（记住，表面已被截断为表示地理研究区域的不规则多边形）。这个序列的长度比生成的颜色数多一个——再次参考[第
    25.1.4 节](ch25.xhtml#ch25lev2sec245)以了解分类方法所需的这一特性。最后，`cut` 将每个 `zf` 面片值条目分配给相应的秩，按照
    200 个排序好的区间进行分类。如你所学，`zf.colors` 的秩随后在绘图时用于索引存储在 `rbow` 中的 200 种颜色。
- en: With that, you can enjoy the fruits of your labor! The following code plots
    the bivariate kernel density estimate of the Chorley-Ribble observations as a
    perspective plot using facet coloring to reflect the relative height of the surface
    along the *z*-axis. Border lines are suppressed to show off the color clearly,
    the *z*-axis is scaled down slightly, and a color legend is inserted on the right
    side (ensure the `shape` package has been loaded for that) after manipulating
    the default figure margins via `mar` in a call to `par` to create extra space
    for it. You can find the result in [Figure 25-21](ch25.xhtml#ch25fig21).
  id: totrans-445
  prefs: []
  type: TYPE_NORMAL
  zh: 这样，你就可以享受你劳动的成果了！以下代码绘制了 Chorley-Ribble 观察值的双变量核密度估计，并使用视角图来展示，其中通过面片着色反映表面沿
    *z* 轴的相对高度。为了清晰地展示颜色，边框线被抑制，*z* 轴略微缩小，并在右侧插入了一个颜色图例（确保已加载 `shape` 包）。在通过 `par`
    调用 `mar` 调整默认图形边距后，额外的空间被用于插入该图例。你可以在 [图 25-21](ch25.xhtml#ch25fig21) 中查看结果。
- en: '[PRE84]'
  id: totrans-446
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: '![image](../images/f25-21.jpg)'
  id: totrans-447
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f25-21.jpg)'
- en: '*Figure 25-21: A perspective plot of the Chorley-Ribble density estimate, demonstrating
    facet coloring that changes according to the* z*-value of the surface.*'
  id: totrans-448
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 25-21：Chorley-Ribble 密度估计的视角图，演示了根据表面 *z* 值变化的面片着色效果。*'
- en: I’ve included the optional argument `scale=FALSE` in the execution of `persp`.
    This retains a one-to-one aspect ratio in the *x*- and *y*-coordinate directions;
    this is useful since you’re looking at geographical data. Unfortunately, this
    also forces the density estimate values on the *z*-axis to be scaled in the same
    way, which makes no sense in the context of the current plot. To avoid the small
    scale resulting in a supremely flat appearance of the surface itself, you need
    to use `expand` to artificially amplify the surface along the third axis. In this
    instance, multiplying it by a factor of around 750 provides a visually pleasing
    result. Note that this would not be necessary if you left the `scale` argument
    at its default `TRUE` value (since, in that case, R internally scales all three
    axes for a one-to-one-to-one aspect ratio).
  id: totrans-449
  prefs: []
  type: TYPE_NORMAL
  zh: 我在执行 `persp` 时加入了可选参数 `scale=FALSE`。这保持了 *x* 和 *y* 坐标方向上的一对一纵横比；这对于查看地理数据非常有用。不幸的是，这也迫使
    *z* 轴上的密度估计值按照相同的方式进行缩放，这在当前图表的上下文中是没有意义的。为了避免小比例造成表面看起来过于平坦，你需要使用 `expand` 来人为地放大第三个轴上的表面。在这个例子中，将其乘以大约
    750 的因子能够得到一个视觉上令人愉悦的结果。需要注意的是，如果你将 `scale` 参数保留为默认的 `TRUE` 值（因为在这种情况下，R 会自动为三个轴进行一对一比例缩放），这就不需要进行这种操作。
- en: '***25.6.3 Rotating with Loops***'
  id: totrans-450
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***25.6.3 使用循环进行旋转***'
- en: There’s one last bit of fun you can have with perspective plots if you want
    to get an overall impression of the plotted surface. Using a simple `for` loop
    ([Section 10.2.1](ch10.xhtml#ch10lev2sec92)) to increment either `theta` or `phi`,
    you can perform a series of repeated calls to `persp`, each one at a slightly
    new angle. Doing this in sequence results in an animation—essentially a cartoon—of
    a rotating surface, allowing you to see it from all different sides.
  id: totrans-451
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想对绘制的表面有一个整体的印象，可以通过视角图进行最后一点有趣的操作。使用一个简单的 `for` 循环（[第 10.2.1 节](ch10.xhtml#ch10lev2sec92)），通过递增
    `theta` 或 `phi`，你可以对 `persp` 进行一系列的重复调用，每次以略微不同的角度进行。按顺序执行这些操作会产生一个动画——本质上是一个旋转表面的卡通效果，让你能够从不同的角度观察它。
- en: 'Consider the following basic function in the R editor:'
  id: totrans-452
  prefs: []
  type: TYPE_NORMAL
  zh: 在 R 编辑器中，考虑以下基本函数：
- en: '[PRE85]'
  id: totrans-453
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: Using an ellipsis (see [Section 11.2.4](ch11.xhtml#ch11lev2sec102)), `persprot`
    simply takes all the arguments you’d usually supply to a call to `persp`, barring
    `theta` and `phi`. Then comes a `for` loop, which immediately calls `persp` with
    `theta=0` and the content of the ellipsis. The `for` loop alters the vertical
    viewing angle, starting with `phi=90` (birds-eye view) and moving down to a mildly
    elevated `phi=20`. A second `for` loop then completes a full 360-degree horizontal
    rotation by altering `theta`.
  id: totrans-454
  prefs: []
  type: TYPE_NORMAL
  zh: 使用省略号（见 [第 11.2.4 节](ch11.xhtml#ch11lev2sec102)），`persprot` 只是接受通常传递给 `persp`
    调用的所有参数，除了 `theta` 和 `phi`。接下来是一个 `for` 循环，它立即调用 `persp`，设置 `theta=0` 和省略号的内容。`for`
    循环通过改变垂直视角来进行调整，从 `phi=90`（鸟瞰图）开始，然后逐渐下降到轻微抬高的 `phi=20`。第二个 `for` 循环则通过改变 `theta`
    完成一个完整的 360 度水平旋转。
- en: The only formally tagged argument is `skip`, which determines the amount `phi`
    and `theta` increment by at each iteration. The default, `skip=1`, simply moves
    through the integer-valued angles. Increasing `skip` will reduce the time it takes
    to complete the rotation, though it makes for a more jagged animation.
  id: totrans-455
  prefs: []
  type: TYPE_NORMAL
  zh: 唯一正式标记的参数是`skip`，它决定了每次迭代中`phi`和`theta`的增量。默认值`skip=1`会在整数角度之间移动。增加`skip`值会减少完成旋转所需的时间，尽管这会使动画变得更加生硬。
- en: Depending on the type of graphics device you’re using, you may want to experiment
    with `skip`. Note that not all graphics device types will be well-suited to the
    animation effect sought by running this rather crude function (for example, it’s
    not appropriate if you’re using RStudio—see [Appendix B](app02.xhtml#app02)).
    That said, when running the base R GUI applications on OS X or Windows, I find
    `persprot` works well under default graphics settings.
  id: totrans-456
  prefs: []
  type: TYPE_NORMAL
  zh: 根据你使用的图形设备类型，你可能想尝试调整`skip`。请注意，并非所有图形设备类型都适合通过运行这个相对粗糙的函数来实现动画效果（例如，如果你使用的是RStudio，这种效果并不合适——见[附录B](app02.xhtml#app02)）。不过，在OS
    X或Windows上的基本R GUI应用中，我发现`persprot`在默认图形设置下运行良好。
- en: Import the function to try it; let’s do so here for a perspective plot of a
    kernel estimate of the probability density function of the spatial `quakes` locations
    you first examined as Example 3, [Section 25.4.1](ch25.xhtml#ch25lev2sec254).
    With the `MASS` package already loaded, produce the density estimate on a 50 ×
    50 evaluation grid with the following line.
  id: totrans-457
  prefs: []
  type: TYPE_NORMAL
  zh: 导入该函数来试试；在这里我们将其用于空间`quakes`位置的概率密度函数核估计的视角图，这些位置你在示例3中首次研究过，[第25.4.1节](ch25.xhtml#ch25lev2sec254)有介绍。`MASS`包已经加载，使用以下代码在50
    × 50的评估网格上生成密度估计。
- en: '[PRE86]'
  id: totrans-458
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: Then you use `persprot` just as you’d use `persp`, without needing to specify
    either `theta` or `phi`.
  id: totrans-459
  prefs: []
  type: TYPE_NORMAL
  zh: 然后你像使用`persp`一样使用`persprot`，无需指定`theta`或`phi`。
- en: '[PRE87]'
  id: totrans-460
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: '[Figure 25-22](ch25.xhtml#ch25fig22) shows a series of screenshots of the rotating
    plot.'
  id: totrans-461
  prefs: []
  type: TYPE_NORMAL
  zh: '[图25-22](ch25.xhtml#ch25fig22)展示了一系列旋转图的截图。'
- en: '![image](../images/f25-22.jpg)'
  id: totrans-462
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f25-22.jpg)'
- en: '*Figure 25-22: A rotating perspective plot of a KDE surface for the spatial
    earthquake locations, after a call to the custom* `persprot` *function*'
  id: totrans-463
  prefs: []
  type: TYPE_NORMAL
  zh: '*图25-22：一个旋转视角图，展示了空间地震位置的KDE表面，在调用自定义*`persprot`*函数之后*'
- en: '**Exercise 25.5**'
  id: totrans-464
  prefs: []
  type: TYPE_NORMAL
  zh: '**练习25.5**'
- en: In [Exercise 25.3](ch25.xhtml#ch25exc3) (a), you revisited the `nuclear` data
    set from the `boot` package and fitted two multiple linear regression models aiming
    to model mean construction cost by permit date issue and plant capacity—one with
    main effects only and the other including an interaction term between the two
    continuous predictors.
  id: totrans-465
  prefs: []
  type: TYPE_NORMAL
  zh: 在[练习25.3](ch25.xhtml#ch25exc3)（a）中，你重新审视了来自`boot`包的`nuclear`数据集，并拟合了两个多元线性回归模型，旨在通过许可日期发放和工厂容量来建模平均建设成本——一个仅包括主效应，另一个则包括两个连续预测变量之间的交互项。
- en: 'Refit the two versions of the model and produce perspective plots of the response
    surfaces based again on a 50 × 50 evaluation grid, taking the following into account:'
  id: totrans-466
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 重新拟合两个版本的模型，并基于50 × 50的评估网格生成响应表面的视角图，再次考虑以下因素：
- en: – Use `mfrow` in a call to `par` to display the two perspective plots next to
    each other. In the same call to `par`, override the default figure margins to
    have only one line of space on each side (`par` is explored in this role in [Chapter
    23](ch23.xhtml#ch23)).
  id: totrans-467
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在调用`par`时使用`mfrow`将两个视角图并排显示。在同一个`par`调用中，覆盖默认的图形边距，使每一侧只有一行空白（`par`在[第23章](ch23.xhtml#ch23)中有详细探讨）。
- en: – Use `zlim` to ensure both plots are displayed on the same scale of vertical
    axis, spin each one horizontally 25 degrees, and ensure detailed axis markings
    and tidy titles.
  id: totrans-468
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: – 使用`zlim`确保两个图形在相同的纵轴比例上显示，分别将每个图水平旋转25度，确保轴标记清晰并且标题整洁。
- en: – Is there any visual indication that the presence of the interaction term has
    had any meaningful impact on modeling the response?
  id: totrans-469
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 是否有任何视觉指示表明交互项的存在对建模响应产生了有意义的影响？
- en: Start a fresh plot. To get a better idea of the difference between the two surfaces,
    produce a perspective plot of the *z*-matrix obtained as the elementwise difference
    between the two individual *z*-matrices for the two fitted models in (a). What,
    in general, is the effect of including the interaction term?
  id: totrans-470
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 开始一个新的图形。为了更好地了解两个表面之间的差异，生成一个视角图，展示通过对两个拟合模型中各自的*z*矩阵逐元素相减所得到的*z*矩阵。通常来说，包含交互项的效果是什么？
- en: 'Turn your attention back to the topographical information on the Auckland volcano,
    as the built-in R object `volcano`: an 87 × 61 matrix of elevation values (in
    meters). You first looked at this in [Section 25.4.1](ch25.xhtml#ch25lev2sec254)
    as a contour plot.'
  id: totrans-471
  prefs: []
  type: TYPE_NORMAL
  zh: 将注意力转回到奥克兰火山的地形信息，使用内置的R对象 `volcano`：一个87 × 61的海拔值矩阵（单位为米）。你在[第25.4.1节](ch25.xhtml#ch25lev2sec254)中首次以等高线图的形式查看了这个数据。
- en: Produce the most basic, default perspective plot of the volcano, using simple
    integer sequences for the *x*- and *y*-coordinates.
  id: totrans-472
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用简单的整数序列为 *x* 和 *y* 坐标绘制火山的最基本默认透视图。
- en: 'The plot in (c) is decidedly unappealing for a number of reasons. Produce a
    more realistic depiction of the volcano as per the following:'
  id: totrans-473
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 图(c)的绘图由于多种原因显得不太吸引人。根据以下要求，制作一个更现实的火山图：
- en: – Use a new graphics device with the margin widths reset to one, one, one, and
    four lines on the bottom, left, top, and right, respectively.
  id: totrans-474
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: – 使用一个新的图形设备，将边距宽度重置为底部、左侧、顶部和右侧分别为1、1、1和4行。
- en: – The help file `?volcano` reveals the *x*- and *y*-coordinates to which the
    volcano *z*-matrix corresponds is in 10-meter units. Using `scale` and altering
    `expand`, replot the surface with the correct aspect ratio in all three axes.
  id: totrans-475
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: – 帮助文件 `?volcano` 显示火山的 *x* 和 *y* 坐标对应的 *z* 矩阵单位是10米。使用 `scale` 并调整 `expand`，重新绘制表面，使得三个坐标轴的纵横比正确。
- en: – Suppress all axis tick marks and notation using `axes`.
  id: totrans-476
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: – 使用 `axes` 去除所有坐标轴刻度和标注。
- en: – The facets should be colored according to 50 colors generated from the built-in
    `terrain.colors` palette, and the facet border lines should be suppressed.
  id: totrans-477
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: – 各个面板的颜色应根据从内置 `terrain.colors` 调色板生成的50种颜色来着色，并且应去除面板的边框线。
- en: – Find your choice of visually appealing viewing angle.
  id: totrans-478
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: – 选择一个视觉上更具吸引力的视角。
- en: – Use `colorlegend` from the `shape` package to place a color legend referencing
    elevation in meters in the space to the right of the plot. Experiment with the
    arguments to find appropriate placement and tick mark labels.
  id: totrans-479
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: – 使用 `shape` 包中的 `colorlegend` 在图表右侧的空间中放置一个颜色图例，表示以米为单位的海拔高度。可以尝试不同的参数来找到合适的放置位置和刻度标记。
- en: 'Here’s my version of the improved plot:'
  id: totrans-480
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这是我改进后的图表版本：
- en: '![image](../images/f0689-01.jpg)'
  id: totrans-481
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![image](../images/f0689-01.jpg)'
- en: 'In [Exercise 25.4](ch25.xhtml#ch25exc4), you looked at the spatial distribution
    of intentionally lit fires in a region of Spain. Ensure the `spatstat` package
    is loaded, and then rerun the following lines to obtain the relevant data objects:'
  id: totrans-482
  prefs: []
  type: TYPE_NORMAL
  zh: 在[练习 25.4](ch25.xhtml#ch25exc4)中，你研究了西班牙某地区故意点燃的火灾的空间分布。确保加载了 `spatstat` 包，然后重新运行以下代码行以获得相关的数据对象：
- en: R> fire <- split(clmfires)$intentional
  id: totrans-483
  prefs: []
  type: TYPE_NORMAL
  zh: R> fire <- split(clmfires)$intentional
- en: R> firewin <- clmfires$window
  id: totrans-484
  prefs: []
  type: TYPE_NORMAL
  zh: R> firewin <- clmfires$window
- en: 'Borrow the code from [Exercise 25.4](ch25.xhtml#ch25exc4) (d) and (e) to reproduce
    the kernel density estimate of this dispersion of observations, based on a 256
    × 256 evaluation grid, truncated to the study region. Then, display it as a perspective
    plot according to the following:'
  id: totrans-485
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从[练习 25.4](ch25.xhtml#ch25exc4)中借用代码(d)和(e)，根据256 × 256的评估网格（截断至研究区域）重新绘制这个分布观察值的核密度估计。然后，按照以下方式将其显示为透视图：
- en: – Just as with the pixel image, use 50 colors from the built-in `heat.colors`
    palette to color the facets by *z* value. Note the truncated *z*-matrix for this
    function contains `NA` values.
  id: totrans-486
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: – 和像素图像一样，使用内置的 `heat.colors` 调色板中的50种颜色，根据 *z* 值为各个面板着色。请注意，这个函数的截断 *z*-矩阵包含
    `NA` 值。
- en: – Border lines on the surface should be suppressed, and you should find your
    preferred choice of viewing angle.
  id: totrans-487
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: – 表面上的边框线应被去除，并且你应找到自己喜欢的视角。
- en: – Use `scale` to ensure the correct spatial aspect ratio. In doing so, you’ll
    also need to adjust the *z*-axis expansion by a factor of around 5,000,000 for
    the density surface to be visible along the vertical, given the natural scaling
    of the density estimate on the specified evaluation grid.
  id: totrans-488
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: – 使用 `scale` 来确保正确的空间纵横比。在这样做时，你还需要通过大约5,000,000倍的因子调整 *z* 轴的扩展，以便在垂直方向上显示密度表面，这是由于在指定评估网格上密度估计的自然缩放。
- en: – Employ detailed axis labeling and simply entitle the axes `"X"`, `"Y"`, and
    `"Z"` as appropriate.
  id: totrans-489
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: – 使用详细的坐标轴标签，并根据需要简单地将坐标轴命名为 `"X"`、`"Y"` 和 `"Z"`。
- en: My product is given here.
  id: totrans-490
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我的产品如下所示。
- en: '![image](../images/f0690-01.jpg)'
  id: totrans-491
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![image](../images/f0690-01.jpg)'
- en: Use the `persprot` function defined in [Section 25.6.3](ch25.xhtml#ch25lev2sec260)
    to view the surface from (e), setting `skip=10`.
  id: totrans-492
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用在[第25.6.3节](ch25.xhtml#ch25lev2sec260)中定义的 `persprot` 函数来查看(e)中的表面，设置 `skip=10`。
- en: '**Important Code in This Chapter**'
  id: totrans-493
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**本章重要代码**'
- en: '| **Function/operator** | **Brief description** | **First occurrence** |'
  id: totrans-494
  prefs: []
  type: TYPE_TB
  zh: '| **函数/操作符** | **简要描述** | **首次出现** |'
- en: '| --- | --- | --- |'
  id: totrans-495
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| `palette` | List integer colors | [Section 25.1.1](ch25.xhtml#ch25lev2sec242),
    [p. 632](ch25.xhtml#page_632) |'
  id: totrans-496
  prefs: []
  type: TYPE_TB
  zh: '| `palette` | 列出整数颜色 | [第25.1.1节](ch25.xhtml#ch25lev2sec242), [第632页](ch25.xhtml#page_632)
    |'
- en: '| `col2rgb` | Named color to RGB | [Section 25.1.1](ch25.xhtml#ch25lev2sec242),
    [p. 632](ch25.xhtml#page_632) |'
  id: totrans-497
  prefs: []
  type: TYPE_TB
  zh: '| `col2rgb` | 命名颜色转RGB | [第25.1.1节](ch25.xhtml#ch25lev2sec242), [第632页](ch25.xhtml#page_632)
    |'
- en: '| `rgb` | RGB to hex code | [Section 25.1.1](ch25.xhtml#ch25lev2sec242), [p.
    633](ch25.xhtml#page_633) |'
  id: totrans-498
  prefs: []
  type: TYPE_TB
  zh: '| `rgb` | RGB转十六进制代码 | [第25.1.1节](ch25.xhtml#ch25lev2sec242), [第633页](ch25.xhtml#page_633)
    |'
- en: '| `rainbow`, `heat.colors`, `gray`, `terrain.colors`, `cm.colors`, `topo.colors`,
    `gray.colors` | Built-in palettes | [Section 25.1.2](ch25.xhtml#ch25lev2sec243),
    [p. 635](ch25.xhtml#page_635) |'
  id: totrans-499
  prefs: []
  type: TYPE_TB
  zh: '| `rainbow`, `heat.colors`, `gray`, `terrain.colors`, `cm.colors`, `topo.colors`,
    `gray.colors` | 内建调色板 | [第25.1.2节](ch25.xhtml#ch25lev2sec243), [第635页](ch25.xhtml#page_635)
    |'
- en: '| `colorRampPalette` | Custom palette (integer) | [Section 25.1.3](ch25.xhtml#ch25lev2sec244),
    [p. 636](ch25.xhtml#page_636) |'
  id: totrans-500
  prefs: []
  type: TYPE_TB
  zh: '| `colorRampPalette` | 自定义调色板（整数） | [第25.1.3节](ch25.xhtml#ch25lev2sec244),
    [第636页](ch25.xhtml#page_636) |'
- en: '| `colorRamp` | Custom palette ([0,1] interval) | [Section 25.1.4](ch25.xhtml#ch25lev2sec245),
    [p. 640](ch25.xhtml#page_640) |'
  id: totrans-501
  prefs: []
  type: TYPE_TB
  zh: '| `colorRamp` | 自定义调色板（[0,1]区间） | [第25.1.4节](ch25.xhtml#ch25lev2sec245), [第640页](ch25.xhtml#page_640)
    |'
- en: '| `colorlegend` | Color legend (`shape`) | [Section 25.1.5](ch25.xhtml#ch25lev2sec246),
    [p. 641](ch25.xhtml#page_641) |'
  id: totrans-502
  prefs: []
  type: TYPE_TB
  zh: '| `colorlegend` | 颜色图例（`shape`） | [第25.1.5节](ch25.xhtml#ch25lev2sec246), [第641页](ch25.xhtml#page_641)
    |'
- en: '| `scatterplot3d` | 3D scatterplot (`scatterplot3d`) | [Section 25.2.1](ch25.xhtml#ch25lev2sec249),
    [p. 649](ch25.xhtml#page_649) |'
  id: totrans-503
  prefs: []
  type: TYPE_TB
  zh: '| `scatterplot3d` | 3D散点图（`scatterplot3d`） | [第25.2.1节](ch25.xhtml#ch25lev2sec249),
    [第649页](ch25.xhtml#page_649) |'
- en: '| `expand.grid` | All unique evaluation coords. | [Section 25.3.1](ch25.xhtml#ch25lev2sec251),
    [p. 654](ch25.xhtml#page_654) |'
  id: totrans-504
  prefs: []
  type: TYPE_TB
  zh: '| `expand.grid` | 所有唯一的评估坐标 | [第25.3.1节](ch25.xhtml#ch25lev2sec251), [第654页](ch25.xhtml#page_654)
    |'
- en: '| `letters` | Alphabet characters | [Section 25.3.1](ch25.xhtml#ch25lev2sec251),
    [p. 655](ch25.xhtml#page_655) |'
  id: totrans-505
  prefs: []
  type: TYPE_TB
  zh: '| `letters` | 字母字符 | [第25.3.1节](ch25.xhtml#ch25lev2sec251), [第655页](ch25.xhtml#page_655)
    |'
- en: '| `contour` | Contour plot | [Section 25.4.1](ch25.xhtml#ch25lev2sec254), [p.
    657](ch25.xhtml#page_657) |'
  id: totrans-506
  prefs: []
  type: TYPE_TB
  zh: '| `contour` | 等高线图 | [第25.4.1节](ch25.xhtml#ch25lev2sec254), [第657页](ch25.xhtml#page_657)
    |'
- en: '| `kde2D` | Bivariate KDE (`MASS`) | [Section 25.4.1](ch25.xhtml#ch25lev2sec254),
    [p. 660](ch25.xhtml#page_660) |'
  id: totrans-507
  prefs: []
  type: TYPE_TB
  zh: '| `kde2D` | 双变量KDE（`MASS`） | [第25.4.1节](ch25.xhtml#ch25lev2sec254), [第660页](ch25.xhtml#page_660)
    |'
- en: '| `filled.contour` | Color-filled contour plot | [Section 25.4.2](ch25.xhtml#ch25lev2sec255),
    [p. 664](ch25.xhtml#page_664) |'
  id: totrans-508
  prefs: []
  type: TYPE_TB
  zh: '| `filled.contour` | 颜色填充的等高线图 | [第25.4.2节](ch25.xhtml#ch25lev2sec255), [第664页](ch25.xhtml#page_664)
    |'
- en: '| `image` | Pixel images | [Section 25.5.1](ch25.xhtml#ch25lev2sec256), [p.
    668](ch25.xhtml#page_668) |'
  id: totrans-509
  prefs: []
  type: TYPE_TB
  zh: '| `image` | 像素图像 | [第25.5.1节](ch25.xhtml#ch25lev2sec256), [第668页](ch25.xhtml#page_668)
    |'
- en: '| `inside.owin` | Test inside region (`spatstat`) | [Section 25.5.2](ch25.xhtml#ch25lev2sec257),
    [p. 674](ch25.xhtml#page_674) |'
  id: totrans-510
  prefs: []
  type: TYPE_TB
  zh: '| `inside.owin` | 测试区域内部（`spatstat`） | [第25.5.2节](ch25.xhtml#ch25lev2sec257),
    [第674页](ch25.xhtml#page_674) |'
- en: '| `persp` | Perspective plot | [Section 25.6.1](ch25.xhtml#ch25lev2sec258),
    [p. 680](ch25.xhtml#page_680) |'
  id: totrans-511
  prefs: []
  type: TYPE_TB
  zh: '| `persp` | 透视图 | [第25.6.1节](ch25.xhtml#ch25lev2sec258), [第680页](ch25.xhtml#page_680)
    |'
