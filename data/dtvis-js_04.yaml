- en: Chapter 4. Creating Specialized Graphs
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第4章：创建专门的图表
- en: The first three chapters looked at different ways to create many common types
    of charts with JavaScript. But if your data has unique properties or if you want
    to show it in an unusual way, a more specialized chart might be more appropriate
    than a typical bar, line, or scatter chart.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 前三章介绍了使用JavaScript创建许多常见图表类型的不同方法。但如果你的数据具有独特的属性，或者你希望以一种不寻常的方式展示它，可能比典型的条形图、折线图或散点图更适合使用更专门的图表。
- en: 'Fortunately, there are many JavaScript techniques and plug-ins to expand our
    visualization vocabulary beyond the standard charts. In this chapter, we’ll look
    at approaches for several specialized chart types, including the following:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，有许多JavaScript技术和插件可以扩展我们的可视化词汇，超越标准图表。在本章中，我们将探讨几种专门图表类型的方法，包括以下内容：
- en: How to combine hierarchy and dimension with tree maps
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何将层次结构和维度结合在一起，使用树形图
- en: How to highlight regions with heat maps
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何使用热力图突出显示区域
- en: How to show links between elements with network graphs
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何使用网络图显示元素之间的连接
- en: How to reveal language patterns with word clouds
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何通过词云揭示语言模式
- en: Visualizing Hierarchies with Tree Maps
  id: totrans-7
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用树形图可视化层次结构
- en: 'Data that we want to visualize can often be organized into a hierarchy, and
    in many cases that hierarchy is itself an important aspect of the visualization.
    This chapter considers several tools for visualizing hierarchical data, and we’ll
    begin the examples with one of the simplest approaches: tree maps. Tree maps represent
    numeric data with two-dimensional areas, and they indicate hierarchies by nesting
    subordinate areas within their parents.'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 我们想要可视化的数据通常可以组织成层次结构，在许多情况下，这种层次结构本身就是可视化的重要组成部分。本章讨论了几种用于可视化层次数据的工具，我们将从最简单的方法之一——树形图开始示例。树形图通过二维区域表示数值数据，并通过将从属区域嵌套在父区域内来表示层次结构。
- en: There are several algorithms for constructing tree maps from hierarchical data;
    one of the most common is the squarified algorithm developed by Mark Bruls, Kees
    Huizing, and Jarke J. van Wijk (*[http://www.win.tue.nl/~vanwijk/stm.pdf](http://www.win.tue.nl/~vanwijk/stm.pdf)*).
    This algorithm is favored for many visualizations because it usually generates
    visually pleasing proportions for the tree map area. To create the graphics in
    our example, we can use Imran Ghory’s treemap-squared library (*[https://github.com/imranghory/treemap-squared](https://github.com/imranghory/treemap-squared)*).
    That library includes code for both calculating and drawing tree maps.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 有几种算法可以从层次数据构建树形图；其中最常见的一种是由Mark Bruls、Kees Huizing和Jarke J. van Wijk开发的**方形算法**（*[http://www.win.tue.nl/~vanwijk/stm.pdf](http://www.win.tue.nl/~vanwijk/stm.pdf)*）。由于它通常能为树形图区域生成视觉上令人愉悦的比例，因此这种算法在许多可视化中广受欢迎。为了创建我们示例中的图形，我们可以使用Imran
    Ghory的treemap-squared库（*[https://github.com/imranghory/treemap-squared](https://github.com/imranghory/treemap-squared)*）。该库包含了用于计算和绘制树形图的代码。
- en: 'Step 1: Include the Required Libraries'
  id: totrans-10
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 步骤1：包含所需的库
- en: The treemap-squared library itself depends on the Raphaël library (*[http://raphaeljs.com/](http://raphaeljs.com/)*)
    for low-level drawing functions. Our markup, therefore, must include both libraries.
    The Raphaël library is popular enough for public CDNs to support.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: treemap-squared库本身依赖于Raphaël库（*[http://raphaeljs.com/](http://raphaeljs.com/)）提供低级绘图功能。因此，我们的标记必须同时包含这两个库。Raphaël库足够流行，公共CDN已提供支持。
- en: '[PRE0]'
  id: totrans-12
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: As you can see, we’ve set aside a `<div>` to hold our tree map. We’ve also included
    the JavaScript libraries as the last part of the `<body>` element, as that provides
    the best browser performance. In this example, we’re relying on CloudFlare’s CDN
    ➊. We’ll have to use our own resources, however, to host the treemap-squared library
    ➋.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，我们已经为树形图预留了一个`<div>`元素。我们还将JavaScript库作为`<body>`元素的最后部分包含在内，因为这样能够提供最佳的浏览器性能。在这个示例中，我们依赖CloudFlare的CDN
    ➊。然而，我们必须使用自己的资源来托管treemap-squared库 ➋。
- en: Note
  id: totrans-14
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '**See [Step 1: Include the Required JavaScript Libraries](ch02.html#step_1_include_the_required_javascript_l
    "Step 1: Include the Required JavaScript Libraries") for a more extensive discussion
    of CDNs and the tradeoffs involved in using them.**'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: '**请参见[步骤1：包含所需的JavaScript库](ch02.html#step_1_include_the_required_javascript_l
    "Step 1: Include the Required JavaScript Libraries")，以便更详细地讨论CDN及其使用中的权衡。**'
- en: 'Step 2: Prepare the Data'
  id: totrans-16
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 步骤2：准备数据
- en: For our example we’ll show the population of the United States divided by region
    and then, within each region, by state. The data is available from the US Census
    Bureau (*[http://www.census.gov/popest/data/state/totals/2012/index.html](http://www.census.gov/popest/data/state/totals/2012/index.html)*).
    We’ll follow its convention and divide the country into four regions. The resulting
    JavaScript array could look like the following snippet.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的示例中，我们将显示按区域划分的美国人口，然后在每个区域内按州进行细分。数据来自美国人口普查局（*[http://www.census.gov/popest/data/state/totals/2012/index.html](http://www.census.gov/popest/data/state/totals/2012/index.html)*）。我们将按照其惯例，将该国划分为四个区域。生成的JavaScript数组可能如下所示。
- en: '[PRE1]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: We’ve retained both the 2010 and the 2012 data.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 我们保留了2010年和2012年的数据。
- en: To structure the data for the treemap-squared library, we need to create separate
    data arrays for each region. At the same time, we can also create arrays to label
    the data values using the two-letter state abbreviations.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 为了将数据结构化为treemap-squared库使用，我们需要为每个区域创建单独的数据数组。同时，我们还可以创建数组，用两位州缩写作为标签来标注数据值。
- en: '[PRE2]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: This code steps through the `census` array to build data and label arrays for
    the `"South"` region. The same approach works for the other three regions as well.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码逐步遍历`census`数组，构建“南部”区域的数据和标签数组。相同的方法也适用于其他三个区域。
- en: 'Step 3: Draw the Tree Map'
  id: totrans-23
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 步骤3：绘制树状图
- en: Now we’re ready to use the library to construct our tree map. We need to assemble
    the individual data and label arrays and then call the library’s main function.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经准备好使用该库来构建树状图。我们需要组装各个数据和标签数组，然后调用库的主函数。
- en: '[PRE3]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The first two parameters at ➊ are the width and height of the map.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: ➊处的前两个参数是地图的宽度和高度。
- en: The resulting chart, shown in [Figure 4-1](ch04.html#tree_maps_show_the_relative_size_of_data
    "Figure 4-1. Tree maps show the relative size of data values using rectangular
    area."), provides a simple visualization of the US population. Among the four
    regions, it is clear where most of the population resides. The bottom-right quadrant
    (the South) has the largest share of the population. And within the regions, the
    relative size of each state’s population is also clear. Notice, for example, how
    California dominates the West.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 结果图表，如[图4-1](ch04.html#tree_maps_show_the_relative_size_of_data "图4-1. 树状图显示数据值的相对大小，使用矩形区域。")所示，提供了美国人口的简单可视化。在四个区域中，最明显的就是人口集中在哪个地方。右下方的区域（南部）拥有最多的人口份额。在各个区域内，每个州的人口相对大小也非常清晰。例如，注意到加利福尼亚在西部占据主导地位。
- en: '![Tree maps show the relative size of data values using rectangular area.](figs/web/04fig01.png.jpg)Figure 4-1. Tree
    maps show the relative size of data values using rectangular area.'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: '![树状图显示数据值的相对大小，使用矩形区域。](figs/web/04fig01.png.jpg)图4-1. 树状图显示数据值的相对大小，使用矩形区域。'
- en: 'Step 4: Vary the Shading to Show Additional Data'
  id: totrans-29
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 步骤4：变换阴影以显示额外数据
- en: The tree map in [Figure 4-1](ch04.html#tree_maps_show_the_relative_size_of_data
    "Figure 4-1. Tree maps show the relative size of data values using rectangular
    area.") does a nice job of showing the US population distribution in 2012\. The
    population isn’t static, however, and we can enhance our visualization to indicate
    trends by taking advantage of the 2010 population data that’s still lurking in
    our data set. When we iterate through the `census` array to extract individual
    regions, we can also calculate a few additional values.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: '[图4-1](ch04.html#tree_maps_show_the_relative_size_of_data "图4-1. 树状图显示数据值的相对大小，使用矩形区域。")中的树状图很好地展示了2012年美国人口的分布。然而，人口并非静态的，我们可以通过利用仍然存在于数据集中的2010年人口数据来增强我们的可视化效果，显示趋势。当我们遍历`census`数组提取各个区域时，还可以计算一些额外的数值。'
- en: Here’s an expanded version of our earlier code fragment that includes these
    additional calculations.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们之前代码片段的扩展版本，包含了这些额外的计算。
- en: '[PRE4]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Let’s walk through those additional calculations:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来逐步讲解这些额外的计算：
- en: We accumulate the total population for all states, both in 2010 and in 2012,
    at ➊ and ➋, respectively. These values let us calculate the average growth rate
    for the entire country.
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们分别在➊和➋处累积了2010年和2012年的各州总人口数据。这些值使我们能够计算整个国家的平均增长率。
- en: For each state, we can calculate its growth rate at ➌.
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于每个州，我们可以在➌处计算其增长率。
- en: For each region, we save both the minimum and maximum growth rates at ➍ and
    ➎.
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于每个区域，我们分别在➍和➎处保存最小和最大增长率。
- en: In the same way that we created a master object for the data and the labels,
    we create another master object for the growth rates. Let’s also calculate the
    total growth rate for the country.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 就像我们为数据和标签创建了一个主对象一样，我们为增长率创建了另一个主对象。我们还将计算全国的总增长率。
- en: '[PRE5]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Now we need a function to calculate the color for a tree-map rectangle. We start
    by defining two color ranges, one for growth rates higher than the national average
    and another for lower growth rates. We can then pick an appropriate color for
    each state, based on that state’s growth rate. As an example, here’s one possible
    set of colors.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们需要一个函数来计算树形图矩形的颜色。我们首先定义两个颜色范围，一个用于高于全国平均水平的增长率，另一个用于低于全国平均水平的增长率。然后，我们可以根据每个州的增长率，为其选择一个合适的颜色。例如，以下是一组可能的颜色。
- en: '[PRE6]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Next is the `pickColor()` function that uses these color ranges to select the
    right color for each box. The treemap-squared library will call it with two parameters—the
    coordinates of the rectangle it’s about to draw, and the index into the data set.
    We don’t need the coordinates in our example, but we will use the index to find
    the value to model. Once we find the state’s growth rate, we can subtract the
    national average. That calculation determines which color range to use. States
    that are growing faster than the national average get the positive color range;
    states growing slower than the average get the negative range.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来是`pickColor()`函数，它使用这些颜色范围为每个框选择合适的颜色。treemap-squared库会用两个参数调用它——一个是它即将绘制的矩形的坐标，另一个是数据集中的索引。在我们的示例中，我们不需要坐标，但我们会使用索引来找到需要建模的值。一旦我们找到州的增长率，我们可以减去全国平均增长率。这个计算决定了使用哪个颜色范围。增长速度快于全国平均水平的州将使用正向颜色范围；增长速度慢于平均水平的州将使用负向颜色范围。
- en: The final part of the code calculates where on the appropriate color range to
    select the color.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 代码的最后部分计算了在适当的颜色范围内选择颜色的位置。
- en: '[PRE7]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The code uses a linear scale based on the extreme values from among all the
    states. So, for example, if a state’s growth rate is halfway between the overall
    average and the maximum growth rate, we’ll give it a color that’s halfway in the
    positive color range array.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 该代码使用一个基于所有州中极值的线性刻度。因此，例如，如果某个州的增长率介于整体平均值和最大增长率之间，我们将为其指定一个位于正向颜色范围数组中间的颜色。
- en: Now when we call `TreeMap.draw()`, we can add this function to its parameters,
    specifically by setting it as the value for the `box` key of the options object.
    The treemap-squared library will then defer to our function for selecting the
    colors of the regions.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，当我们调用`TreeMap.draw()`时，可以将此函数添加到其参数中，具体通过将其设置为选项对象中`box`键的值。treemap-squared库将会调用我们的函数来选择区域的颜色。
- en: '[PRE8]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The resulting tree map of [Figure 4-2](ch04.html#tree_maps_can_use_color_as_well_as_area
    "Figure 4-2. Tree maps can use color as well as area to show data values.") still
    shows the relative populations for all of the states. Now, through the use of
    color shades, it also indicates the rate of population growth compared to the
    national average. The visualization clearly shows the migration from the Northeast
    and Midwest to the South and West.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 结果树形图[图4-2](ch04.html#tree_maps_can_use_color_as_well_as_area "图4-2.树形图可以使用颜色和面积显示数据值。")仍然显示了所有州的相对人口数。现在，通过使用颜色阴影，它还显示了与全国平均水平相比的人口增长率。该可视化清楚地展示了从东北部和中西部到南部和西部的迁移。
- en: '![Tree maps can use color as well as area to show data values.](figs/web/04fig02.png.jpg)Figure 4-2. Tree
    maps can use color as well as area to show data values.'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: '![树形图可以使用颜色和面积显示数据值。](figs/web/04fig02.png.jpg)图4-2.树形图可以使用颜色和面积显示数据值。'
- en: Highlighting Regions with a Heat Map
  id: totrans-49
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用热图突出显示区域
- en: If you work in the web industry, heat maps may already be a part of your job.
    Usability researchers often use heat maps to evaluate site designs, especially
    when they want to analyze which parts of a web page get the most attention from
    users. Heat maps work by overlaying values, represented as semitransparent colors,
    over a two-dimensional area. As the example in [Figure 4-3](ch04.html#heat_maps_traditionally_show_where_web_u
    "Figure 4-3. Heat maps traditionally show where web users focus their attention
    on a page.") shows, different colors represent different levels of attention.
    Users focus most on areas colored red, and less on yellow, green, and blue areas.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你从事网页行业，热图可能已经是你工作的一部分。可用性研究人员通常使用热图来评估网站设计，特别是在他们想要分析网页的哪些部分获得用户最多关注时。热图通过将半透明的颜色值叠加在二维区域上来工作。如[图4-3](ch04.html#heat_maps_traditionally_show_where_web_u
    "图4-3. 热图传统上展示了网页用户集中注意的地方")所示，不同的颜色代表不同的关注程度。用户最关注的是红色区域，其次是黄色、绿色和蓝色区域。
- en: 'For this example, we’ll use a heat map to visualize an important aspect of
    a basketball game: from where on the court the teams are scoring most of their
    points. The software we’ll use is the heatmap.js library from Patrick Wied (*[http://www.patrick-wied.at/static/heatmapjs/](http://www.patrick-wied.at/static/heatmapjs/)*).
    If you need to create traditional website heat maps, that library includes built-in
    support for capturing mouse movements and mouse clicks on a web page. Although
    we won’t use those features for our example, the general approach is much the
    same.'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们将使用热图来可视化篮球比赛中的一个重要方面：球队得分最多的区域。我们将使用的软件是Patrick Wied的heatmap.js库（*[http://www.patrick-wied.at/static/heatmapjs/](http://www.patrick-wied.at/static/heatmapjs/)*）。如果你需要创建传统的网页热图，该库已经内置了捕捉鼠标移动和点击的功能，适用于网页。如果你不需要这些功能，可以忽略它们，通用的方法是类似的。
- en: '![Heat maps traditionally show where web users focus their attention on a page.](figs/web/04fig03.png.jpg)Figure 4-3. Heat
    maps traditionally show where web users focus their attention on a page.'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: '![热图传统上展示了网页用户集中注意的地方。](figs/web/04fig03.png.jpg)图4-3. 热图传统上展示了网页用户集中注意的地方。'
- en: 'Step 1: Include the Required JavaScript'
  id: totrans-53
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 第一步：包含所需的JavaScript
- en: For modern browsers, the heatmap.js library has no additional requirements.
    The library includes optional additions for real-time heat maps and for geographic
    integration, but we won’t need these in our example. Older browsers (principally
    IE8 and older) can use heatmap.js with the *explorer canvas* library. Since we
    don’t need to burden all users with this library, we’ll use conditional comments
    to include it only when it’s needed. Following current best practices, we include
    all script files at the end of our `<body>`.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 对于现代浏览器，heatmap.js库没有额外的要求。该库包含了用于实时热图和地理集成的可选插件，但在我们的示例中不需要这些功能。较旧的浏览器（主要是IE8及更早版本）可以通过*explorer
    canvas*库使用heatmap.js。由于我们不希望所有用户都加载这个库，我们将通过条件注释仅在需要时加载它。遵循当前最佳实践，我们将所有脚本文件放在`<body>`标签的末尾。
- en: '[PRE9]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Step 2: Define the Visualization Data'
  id: totrans-56
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 第二步：定义可视化数据
- en: 'For our example, we’ll visualize the NCAA Men’s Basketball game on February
    13, 2013, between Duke University and the University of North Carolina. Our data
    set (*[http://www.cbssports.com/collegebasketball/gametracker/live/NCAAB_20130213_UNC@DUKE](http://www.cbssports.com/collegebasketball/gametracker/live/NCAAB_20130213_UNC@DUKE)*)
    contains details about every point scored in the game. To clean the data, we convert
    the time of each score to minutes from the game start, and we define the position
    of the scorer in x- and y-coordinates. We’ve defined these coordinates using several
    important conventions:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的示例中，我们将可视化2013年2月13日NCAA男子篮球比赛中，杜克大学与北卡罗来纳大学之间的比赛。我们的数据集（*[http://www.cbssports.com/collegebasketball/gametracker/live/NCAAB_20130213_UNC@DUKE](http://www.cbssports.com/collegebasketball/gametracker/live/NCAAB_20130213_UNC@DUKE)*)包含了比赛中每个得分的详细信息。为了清洗数据，我们将每个得分的时间转换为从比赛开始后的分钟数，并定义得分者的坐标位置。我们已经根据几个重要的约定定义了这些坐标：
- en: We’ll show North Carolina’s points on the left side of the court and Duke’s
    points on the right side.
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们将把北卡罗来纳大学的得分显示在球场的左侧，杜克大学的得分显示在右侧。
- en: The bottom-left corner of the court corresponds to position (0,0), and the top-right
    corner corresponds to (10,10).
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 球场的左下角对应位置(0,0)，右上角对应位置(10,10)。
- en: To avoid confusing free throws with field goals, we’ve given all free throws
    a position of (–1, –1).
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为了避免将罚球与投篮得分混淆，我们为所有罚球指定了位置(–1, –1)。
- en: Here’s the beginning of the data; the full data is available with the book’s
    source code (*[http://jsDataV.is/source/](http://jsDataV.is/source/)*).
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 这是数据的开始部分；完整的数据可以在书籍的源代码中找到（*[http://jsDataV.is/source/](http://jsDataV.is/source/)*）。
- en: '[PRE10]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Step 3: Create the Background Image'
  id: totrans-63
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 第 3 步：创建背景图像
- en: A simple diagram of a basketball court, like that in [Figure 4-4](ch04.html#background_image_sets_the_context_for_th
    "Figure 4-4. A background image sets the context for the visualization."), works
    fine for our visualization. The dimensions of our background image are 600×360
    pixels.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 一个简单的篮球场图示，类似于[图 4-4](ch04.html#background_image_sets_the_context_for_th "图
    4-4. 背景图像为可视化提供了背景")，非常适合我们的可视化。背景图像的尺寸是 600×360 像素。
- en: '![A background image sets the context for the visualization.](figs/web/04fig04.png.jpg)Figure 4-4. A
    background image sets the context for the visualization.'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: '![背景图像为可视化提供了背景。](figs/web/04fig04.png.jpg)图 4-4. 背景图像为可视化提供了背景。'
- en: 'Step 4: Set Aside an HTML Element to Contain the Visualization'
  id: totrans-66
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 第 4 步：预留一个 HTML 元素来容纳可视化
- en: In our web page, we need to define the element (generally a `<div>`) that will
    hold the heat map. When we create the element, we specify its dimensions, and
    we define the background. The following fragment does both of those using inline
    styles to keep the example concise. You might want to use a CSS style sheet in
    an actual implementation.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的网页中，我们需要定义一个元素（通常是 `<div>`），用于容纳热力图。当我们创建这个元素时，我们指定它的尺寸，并定义背景。下面的代码片段通过内联样式实现了这两个功能，以保持示例简洁。在实际实现中，你可能想使用
    CSS 样式表。
- en: '[PRE11]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Notice that we’ve given the element a unique `id`. The heatmap.js library needs
    that `id` to place the map on the page. Most importantly, we also set the `position`
    property to `relative`. The heatmap.js library positions its graphics using absolute
    positioning, and we want to contain those graphics within the parent element.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们已经为元素指定了一个唯一的 `id`。heatmap.js 库需要这个 `id` 来将热力图放置在页面上。最重要的是，我们还将 `position`
    属性设置为 `relative`。heatmap.js 库使用绝对定位来放置图形，而我们希望将这些图形包含在父元素内。
- en: 'Step 5: Format the Data'
  id: totrans-70
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 第 5 步：格式化数据
- en: 'For our next step, we must convert the game data into the proper format for
    the library. The heatmap.js library expects individual data points to contain
    three properties:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们的下一步，我们必须将比赛数据转换为库所需的正确格式。heatmap.js 库要求每个数据点包含三个属性：
- en: The x-coordinate, measured in pixels from the left of the containing element
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: x 坐标，从包含元素的左侧以像素为单位测量
- en: The y-coordinate, measured in pixels from the top of the containing element
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: y 坐标，从包含元素的顶部以像素为单位测量
- en: The magnitude of the data point (specified by the `count` property)
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数据点的幅度（由 `count` 属性指定）
- en: The library also requires the maximum magnitude for the entire map, and here
    things get a little tricky. With standard heat maps, the magnitudes of all the
    data points for any particular position sum together. In our case, that means
    that all the baskets scored from layups and slam dunks—which are effectively from
    the same position on the court—are added together by the heat-map algorithm. That
    one position, right underneath the basket, dominates the rest of the court. To
    counteract that effect, we specify a maximum value far less than what the heat
    map would expect. In our case, we’ll set the maximum value to `3`, which means
    that any location where at least three points were scored will be colored red,
    and we’ll easily be able to see all the baskets.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 该库还需要整个地图的最大幅度，在这里事情有点复杂。对于标准热力图，任何特定位置的数据点幅度会相加。在我们的例子中，这意味着所有由上篮和灌篮得分的篮筐——这些实际上是来自球场同一位置的——会被热力图算法加在一起。这个位置，正好在篮筐下方，占据了球场的主导地位。为了抵消这个效果，我们指定一个远小于热力图预期的最大值。在我们的案例中，我们将最大值设置为
    `3`，这意味着任何得分超过三分的地方都会被标记为红色，我们将轻松看到所有的篮筐。
- en: We can use JavaScript to transform the `game` array into the appropriate format.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用 JavaScript 将 `game` 数组转换为适当的格式。
- en: '[PRE12]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: We start by fetching the height and width of the containing element at ➊, ➋,
    and ➌. If those dimensions change, our code will still work fine. Then we initialize
    the `dataset` object ➍, with a `max` property ➎ and an empty `data` array ➏. Finally,
    we iterate through the game data and add relevant data points to this array. Notice
    that we’re filtering out free throws at ➐.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先获取包含元素的高度和宽度，分别在 ➊、➋ 和 ➌ 处。如果这些尺寸发生变化，我们的代码仍然能够正常工作。接着，我们初始化 `dataset` 对象
    ➍，并设置一个 `max` 属性 ➎ 和一个空的 `data` 数组 ➏。最后，我们遍历比赛数据并将相关数据点添加到这个数组中。注意，我们在 ➐ 处排除了罚球。
- en: 'Step 6: Draw the Map'
  id: totrans-79
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 步骤 6：绘制地图
- en: With a containing element and a formatted data set, it’s a simple matter to
    draw the heat map. We create the heat-map object (the library uses the name `h337`
    in an attempt to be clever) by specifying the containing element, a radius for
    each point, and an opacity. Then we add the data set to this object.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 通过一个包含元素和格式化的数据集，绘制热力图非常简单。我们通过指定包含元素、每个点的半径和透明度来创建热力图对象（该库为了显得聪明，使用了`h337`这个名称）。然后，我们将数据集添加到这个对象中。
- en: '[PRE13]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The resulting visualization in [Figure 4-5](ch04.html#heat_map_shows_successful_shots_in_the_g
    "Figure 4-5. The heat map shows successful shots in the game.") shows where each
    team scored its points.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 4-5](ch04.html#heat_map_shows_successful_shots_in_the_g "图 4-5：热力图显示了比赛中的成功投篮")中的可视化结果展示了每个团队得分的位置。'
- en: '![The heat map shows successful shots in the game.](figs/web/04fig05.png.jpg)Figure 4-5. The
    heat map shows successful shots in the game.'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: '![热力图显示了比赛中的成功投篮。](figs/web/04fig05.png.jpg)图 4-5：热力图显示了比赛中的成功投篮。'
- en: 'Step 7: Adjust the Heat Map z-index'
  id: totrans-84
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 步骤 7：调整热力图的 z-index
- en: The heatmap.js library is especially aggressive in its manipulation of the `z-index`
    property. To ensure that the heat map appears above all other elements on the
    page, the library explicitly sets this property to a value of `10000000000`. If
    your web page has elements that you don’t want the heat map to obscure (such as
    fixed-position navigation menus), that value is probably too aggressive. You can
    fix it by modifying the source code directly. Or, as an alternative, you can simply
    reset the value after the library finishes drawing the map.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: heatmap.js 库在操作 `z-index` 属性时尤其激进。为了确保热力图出现在页面的所有其他元素之上，库将此属性显式设置为 `10000000000`。如果你的网页上有一些不希望被热力图遮挡的元素（例如固定位置的导航菜单），那么这个值可能太过激进。你可以通过直接修改源代码来修复它。或者，作为替代方案，你可以在库绘制完地图后简单地重置这个值。
- en: If you’re using jQuery, the following code will reduce the `z-index` to a more
    reasonable value.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你正在使用 jQuery，以下代码将把 `z-index` 调整为一个更合理的值。
- en: '[PRE14]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Showing Relationships with Network Graphs
  id: totrans-88
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用网络图显示关系
- en: Visualizations don’t always focus on the actual data values; sometimes the most
    interesting aspects of a data set are the relationships among its members. The
    relationships between members of a social network, for example, might be the most
    important feature of that network. To visualize these types of relationships,
    we can use a *network graph.* Network graphs represent objects, generally known
    as *nodes*, as points or circles. Lines or arcs (technically called *edges*) connect
    these nodes to indicate relationships.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 可视化不总是专注于实际的数据值；有时候，数据集中最有趣的方面是其成员之间的关系。例如，社交网络中成员之间的关系可能是该网络最重要的特征。为了可视化这些类型的关系，我们可以使用*网络图*。网络图将对象（通常称为*节点*）表示为点或圆圈。线条或弧线（技术上称为*边*）连接这些节点以表示关系。
- en: Constructing network graphs can be a bit tricky, as the underlying mathematics
    is not always trivial. Fortunately, the Sigma library (*[http://sigmajs.org/](http://sigmajs.org/)*)
    takes care of most of the complicated calculations. By using that library, we
    can create full-featured network graphs with just a little bit of JavaScript.
    For our example, we’ll consider one critic’s list of the top 25 jazz albums of
    all time (*[http://www.thejazzresource.com/top_25_jazz_albums.html](http://www.thejazzresource.com/top_25_jazz_albums.html)*).
    Several musicians performed on more than one of these albums, and a network graph
    lets us explore those connections.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 构建网络图可能有点棘手，因为其中的数学原理并不总是简单的。幸运的是，Sigma 库（*[http://sigmajs.org/](http://sigmajs.org/)*）处理了大部分复杂的计算。通过使用该库，我们只需一点点
    JavaScript 就能创建功能齐全的网络图。对于我们的示例，我们将考虑一位评论家的“有史以来最伟大的 25 张爵士专辑”列表（*[http://www.thejazzresource.com/top_25_jazz_albums.html](http://www.thejazzresource.com/top_25_jazz_albums.html)*）。几位音乐家在多张专辑上有演出，而网络图可以帮助我们探索这些连接。
- en: 'Step 1: Include the Required Libraries'
  id: totrans-91
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 步骤 1：包含所需的库
- en: The Sigma library does not depend on any other JavaScript libraries, so we don’t
    need any other included scripts. It is not, however, available on common content
    distribution networks. Consequently, we’ll have to serve it from our own web host.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: Sigma 库不依赖于其他 JavaScript 库，因此我们不需要包含任何其他脚本。然而，它并不在常见的内容分发网络上提供。因此，我们必须从自己的 Web
    主机上提供该库。
- en: '[PRE15]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: As you can see, we’ve set aside a `<div>` to hold our graph at ➊. We’ve also
    included the JavaScript library as the last part of the `<body>` element at ➋,
    as that provides the best browser performance.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，我们在➊处为我们的图形预留了一个`<div>`。我们还在➋处将JavaScript库作为`<body>`元素的最后一部分包含进去，因为这样能提供最佳的浏览器性能。
- en: Note
  id: totrans-95
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '**In most of the examples in this book, I included steps you can take to make
    your visualizations compatible with older web browsers such as IE8\. In this case,
    however, those approaches degrade performance so severely that they are rarely
    workable. To view the network graph visualization, your users will need a modern
    browser.**'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: '**在本书的大多数示例中，我包含了使你的可视化与旧版网页浏览器（如IE8）兼容的步骤。然而，在这种情况下，这些方法会严重降低性能，因此几乎无法使用。为了查看网络图可视化，用户需要使用现代浏览器。**'
- en: 'Step 2: Prepare the Data'
  id: totrans-97
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 第2步：准备数据
- en: Our data on the top 25 jazz albums looks like the following snippet. I’m showing
    only the first couple of albums, but you can see the full list in the book’s source
    code (*[http://jsDataV.is/source/](http://jsDataV.is/source/)*).
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 我们关于排名前25的爵士专辑的数据如下所示。我这里只展示了前几张专辑，你可以在书的源代码中查看完整的列表（*[http://jsDataV.is/source/](http://jsDataV.is/source/)*）。
- en: '[PRE16]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: That’s not exactly the structure that Sigma requires. We could convert it to
    a Sigma JSON data structure in bulk, but there’s really no need. Instead, as we’ll
    see in the next step, we can simply pass data to the library one element at a
    time.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 那并不是Sigma所要求的结构。我们可以将其批量转换为Sigma JSON数据结构，但实际上没有必要。相反，正如我们在下一步中将看到的，我们可以一次性将数据传递给库中的每个元素。
- en: 'Step 3: Define the Graph’s Nodes'
  id: totrans-101
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 第3步：定义图的节点
- en: Now we’re ready to use the library to construct our graph. We start by initializing
    the library and indicating where it should construct the graph. That parameter
    is the `id` of the `<div>` element set aside to hold the visualization.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们准备好使用库来构建我们的图形了。我们首先初始化库，并指明它应该在哪里构建图形。该参数是用于承载可视化的`<div>`元素的`id`。
- en: '[PRE17]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Now we can continue by adding the nodes to the graph. In our case, each album
    is a node. As we add a node to the graph, we give it a unique identifier (which
    must be a string), a label, and a position. Figuring out an initial position can
    be a bit tricky for arbitrary data. In a few steps, we’ll look at an approach
    that makes the initial position less critical. For now, though, we’ll simply spread
    our albums in a circle using basic trigonometry.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以继续，将节点添加到图中。在我们的例子中，每个专辑都是一个节点。当我们向图中添加一个节点时，我们为它赋予一个唯一标识符（必须是字符串）、一个标签和一个位置。确定初始位置对于任意数据来说可能有些棘手。在接下来的步骤中，我们会查看一种方法，使初始位置变得不那么关键。不过现在，我们将通过基本的三角函数把专辑均匀分布在一个圆圈上。
- en: '[PRE18]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Here, the `radius` value is roughly half of the width of the container. We can
    also give each node a different size, but for our purposes it’s fine to set every
    album’s size to `1`.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，`radius`的值大致是容器宽度的一半。我们也可以给每个节点设置不同的大小，但在我们的应用场景中，将每张专辑的大小设置为`1`就足够了。
- en: Finally, after defining the graph, we tell the library to draw it.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，在定义了图形后，我们告诉库绘制它。
- en: '[PRE19]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: With [Figure 4-6](ch04.html#sigma_draws_graph_nodes_as_small_circles "Figure 4-6. Sigma
    draws graph nodes as small circles."), we now have a nicely drawn circle of the
    top 25 jazz albums of all time. In this initial attempt, some of the labels may
    get in one another’s way, but we’ll address that shortly.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 通过[图4-6](ch04.html#sigma_draws_graph_nodes_as_small_circles "图4-6. Sigma将图的节点绘制为小圆圈")，我们现在拥有了一个精美绘制的圈，表示所有时间里排名前25的爵士专辑。在这个初步尝试中，某些标签可能会相互重叠，但我们稍后会解决这个问题。
- en: If you try out this visualization in the browser, you’ll notice that the Sigma
    library automatically supports panning the graph, and users can move their mouse
    pointer over individual nodes to highlight the node labels.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在浏览器中尝试此可视化，你会注意到Sigma库自动支持平移图形，用户可以将鼠标指针移到单个节点上以高亮显示节点标签。
- en: '![Sigma draws graph nodes as small circles.](figs/web/04fig06.png.jpg)Figure 4-6. Sigma
    draws graph nodes as small circles.'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: '![Sigma将图的节点绘制为小圆圈。](figs/web/04fig06.png.jpg)图4-6. Sigma将图的节点绘制为小圆圈。'
- en: 'Step 4: Connect the Nodes with Edges'
  id: totrans-112
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 第4步：用边连接节点
- en: Now that we have the nodes drawn in a circle, it’s time to connect them with
    edges. In our case, an edge—or connection between two albums—represents a musician
    who performed on both of the albums. Here’s the code that finds those edges.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经在一个圆圈中绘制了节点，接下来是时候用边连接它们了。在我们的例子中，一条边——即两个专辑之间的连接——代表了在这两张专辑上都有演奏的音乐家。以下是找到这些边的代码。
- en: '[PRE20]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: To find the edges, we iterate through the albums in four stages.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 为了找到边，我们将通过四个阶段迭代这些专辑。
- en: Loop through each album as a potential source of a connection at ➊.
  id: totrans-116
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 循环遍历每个专辑，作为潜在的连接源，在➊处。
- en: For the source album, loop through all musicians at ➋.
  id: totrans-117
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于源专辑，循环遍历➋处的所有音乐人。
- en: For each musician, loop through all of the remaining albums as potential targets
    for a connection at ➌.
  id: totrans-118
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于每个音乐人，循环遍历剩余的所有专辑，作为潜在的连接目标，在➌处。
- en: For each target album, loop through all the musicians at ➍, looking for a match.
  id: totrans-119
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于每个目标专辑，循环遍历➌处的所有音乐人，寻找匹配项。
- en: For the last step we’re using the .`some()` method of JavaScript arrays. That
    method takes a function as a parameter, and it returns `true` if that function
    itself returns `true` for any element in the array.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 在最后一步，我们使用 JavaScript 数组的 `.some()` 方法。该方法接受一个函数作为参数，如果该函数对数组中的任何元素返回 `true`，则返回
    `true`。
- en: We’ll want to insert this code before we refresh the graph. When we’ve done
    that, we’ll have a connected circle of albums, as shown in [Figure 4-7](ch04.html#sigma_can_then_connect_graph_nodes_using
    "Figure 4-7. Sigma can then connect graph nodes using lines to represent edges.").
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望在刷新图表之前插入这段代码。完成后，我们将得到一个连接的专辑圆形布局，如图 [4-7](ch04.html#sigma_can_then_connect_graph_nodes_using
    "图 4-7。Sigma 可以通过线条连接图中的节点，表示边。") 所示。
- en: '![Sigma can then connect graph nodes using lines to represent edges.](figs/web/04fig07.png.jpg)Figure 4-7. Sigma
    can then connect graph nodes using lines to represent edges.'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: '![Sigma 可以通过线条连接图中的节点，表示边。](figs/web/04fig07.png.jpg)图 4-7。Sigma 可以通过线条连接图中的节点，表示边。'
- en: Again, you can pan and zoom in on the graph to focus on different parts.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，你可以平移和缩放图表，聚焦于不同的部分。
- en: 'Step 5: Automate the Layout'
  id: totrans-124
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 第五步：自动化布局
- en: So far we’ve manually placed the nodes in our graph in a circle. That’s not
    a terrible approach, but it can make it hard to discern some of the connections.
    It would be better if we could let the library calculate a more optimal layout
    than the simple circle. That’s exactly what we’ll do now.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经手动将节点放置在图表的圆形布局中。这并不是一个糟糕的方法，但它可能会让我们难以分辨某些连接。如果我们能让库计算一个比简单圆形更优化的布局，那就更好了。现在我们将正是这样做。
- en: The mathematics behind this approach is known as *force-directed graphing*.
    In a nutshell, the algorithm proceeds by treating the graph’s nodes and edges
    as physical objects subject to real forces such as gravity and electromagnetism.
    It simulates the effect of those forces, pushing and prodding the nodes into new
    positions on the graph.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法背后的数学原理被称为 *力导向图形*。简而言之，算法通过将图的节点和边视为受真实物理力（如重力和电磁力）作用的物体来进行处理。它模拟这些力的效果，将节点推入图中新的位置。
- en: The underlying algorithm may be complicated, but Sigma makes it easy to employ.
    First we have to add the optional `forceAtlas2` plug-in to the Sigma library.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 底层算法可能比较复杂，但 Sigma 使其变得容易使用。首先，我们需要将可选的 `forceAtlas2` 插件添加到 Sigma 库中。
- en: '[PRE21]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Mathieu Jacomy and Tommaso Venturini developed the specific force-direction
    algorithm employed by this plug-in; they document the algorithm, known as *ForceAtlas2*,
    in the 2011 paper “ForceAtlas2, A Graph Layout Algorithm for Handy Network Visualization”
    (*[http://webatlas.fr/tempshare/ForceAtlas2_Paper.pdf](http://webatlas.fr/tempshare/ForceAtlas2_Paper.pdf)).*
    Although we don’t have to understand the mathematical details of the algorithm,
    knowing how to use its parameters does come in handy. There are three parameters
    that are important for most visualizations that use the plug-in:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: Mathieu Jacomy 和 Tommaso Venturini 开发了这个插件使用的具体力方向算法；他们在 2011 年的论文《ForceAtlas2，一个用于方便网络可视化的图形布局算法》中记录了这个算法，论文可以在
    *[http://webatlas.fr/tempshare/ForceAtlas2_Paper.pdf](http://webatlas.fr/tempshare/ForceAtlas2_Paper.pdf)*
    中找到。尽管我们不需要理解算法的数学细节，但了解如何使用它的参数是非常有用的。对于大多数使用此插件的可视化，有三个参数是非常重要的：
- en: '****`gravity`****. This parameter determines how strongly the algorithm tries
    to keep isolated nodes from drifting off the edges of the screen. Without any
    gravity, the only force acting on isolated nodes will be one that repels them
    from other nodes; undeterred, that force will push the nodes off the screen entirely.
    Since our data includes several isolated nodes, we’ll want to set this value relatively
    high to keep those nodes on the screen.'
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '****`gravity`****。该参数决定了算法在多大程度上尝试防止孤立节点漂移到屏幕边缘。如果没有任何重力作用，孤立节点上唯一起作用的力就是排斥它们远离其他节点的力；这种力将不受阻碍地把节点推到屏幕之外。由于我们的数据中包含几个孤立节点，我们希望将此值设置得较高，以确保这些节点停留在屏幕上。'
- en: '****`scalingRatio`****. This parameter determines how strongly nodes repel
    each other. A small value draws connected nodes closer together, while a large
    value forces all nodes farther apart.'
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '****`scalingRatio`****。这个参数决定了节点之间相互排斥的强度。较小的值会使连接的节点更靠近，而较大的值则会强制所有节点之间距离更远。'
- en: '****`slowDown`****. This parameter decreases the sensitivity of the nodes to
    the repulsive forces from their neighbors. Reducing the sensitivity (by increasing
    this value) can help reduce the instability that may result when nodes face competing
    forces from multiple neighbors. In our data there are many connections that will
    tend to draw the nodes together and compete with the force pulling them apart.
    To dampen the wild oscillations that might otherwise ensue, we’ll set this value
    relatively high as well.'
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '****`slowDown`****。这个参数减少节点对来自邻居的排斥力的敏感度。通过增加这个值来减少敏感度，有助于减少当节点面临来自多个邻居的相互作用力时可能导致的不稳定性。在我们的数据中，存在许多连接会将节点拉近，并与将节点拉开的力产生竞争。为了减缓可能出现的剧烈振荡，我们将这个值设得相对较高。'
- en: The best way to settle on values for these parameters is to experiment with
    the actual data. The values we’ve settled on for this data set are shown in the
    following code.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 确定这些参数值的最佳方法是对实际数据进行实验。我们为这个数据集选定的参数值如下代码所示。
- en: '[PRE22]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Now, instead of simply refreshing the graph when we’re ready to display it,
    we start the force-directed algorithm, which periodically refreshes the display
    while it performs its simulation. We also need to stop the algorithm after it’s
    had a chance to run for a while. In our case, 10 seconds (`10000` milliseconds)
    is plenty of time.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，当我们准备显示图形时，不仅仅是简单地刷新图形，我们开始了力导向算法，它在执行模拟的同时定期刷新显示。我们还需要在算法运行一段时间后停止它。对于我们的情况来说，10秒（`10000`毫秒）就足够了。
- en: As a result, our albums start out in their original circle, but quickly migrate
    to a position that makes it much easier to identify the connections. Some of the
    top albums are tightly connected, indicating that they have many musicians in
    common. A few, however, remain isolated. Their musicians make the list only once.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 结果，我们的专辑最初处于它们的原始圆形位置，但很快就迁移到一个更易于识别连接的位置。一些排名靠前的专辑紧密连接，表明它们有很多共同的音乐人。然而，少数专辑依然是孤立的，它们的音乐人只出现在列表中一次。
- en: As you can see in [Figure 4-8](ch04.html#force_direction_positions_the_graph_node
    "Figure 4-8. Force direction positions the graph nodes automatically."), the labels
    for the nodes still get in the way of one another; we’ll fix that in the next
    step. What’s important here, however, is that it’s much easier to identify the
    albums with lots of connections. The nodes representing those albums have migrated
    to the center of the graph, and they have many links to other nodes.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 如[图 4-8](ch04.html#force_direction_positions_the_graph_node "图 4-8。力导向自动定位图形节点。")所示，节点的标签仍然相互干扰；我们将在下一步修复这个问题。不过这里重要的是，识别出那些具有大量连接的专辑要容易得多。代表这些专辑的节点已经迁移到图形的中心，并且它们与其他节点有许多连接。
- en: '![Force direction positions the graph nodes automatically.](figs/web/04fig08.png.jpg)Figure 4-8. Force
    direction positions the graph nodes automatically.'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: '![力导向自动定位图形节点。](figs/web/04fig08.png.jpg)图 4-8。力导向自动定位图形节点。'
- en: 'Step 6: Add Interactivity'
  id: totrans-139
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 第6步：添加交互性
- en: To keep the labels from interfering with one another, we can add some interactivity
    to the graph. By default, we’ll hide the labels entirely, giving users the chance
    to appreciate the structure of the graph without distractions. We’ll then allow
    them to click on individual nodes to reveal the album title and its connections.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 为了避免标签相互干扰，我们可以为图形添加一些交互功能。默认情况下，我们将完全隐藏标签，让用户能够在没有干扰的情况下欣赏图形的结构。然后，我们允许他们点击单独的节点以显示专辑标题及其连接。
- en: '[PRE23]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: To suppress the initial label display, we modify the initialization code at
    ➊ so that nodes have blank labels. We save a reference to the album title, though,
    at ➋.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 为了抑制初始标签显示，我们修改了在➊处的初始化代码，使得节点具有空白标签。不过，在➋处，我们保存了专辑标题的引用。
- en: Now we need a function that responds to clicks on the node elements. The Sigma
    library supports exactly this sort of function with its interface. We simply bind
    to the `clickNode` event.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们需要一个响应点击节点元素的函数。Sigma库正好支持这种类型的函数及其接口。我们只需绑定到`clickNode`事件。
- en: '[PRE24]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Within that function, the `ev.data.node.id` property gives us the index of the
    node that the user clicked. The complete set of nodes is available from the array
    returned by `s.graph.nodes()`. Since we want to display the label for the clicked
    node (but not for any other), we can iterate through the entire array. At each
    iteration, we either set the `label` property to an empty string (to hide it)
    or to the `album` property (to show it).
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 在那个函数中，`ev.data.node.id` 属性给我们提供了用户点击的节点的索引。完整的节点集合可以从 `s.graph.nodes()` 返回的数组中获得。由于我们只想显示被点击节点的标签（而不是任何其他节点的标签），我们可以遍历整个数组。在每次遍历中，我们要么将
    `label` 属性设置为空字符串（以隐藏它），要么将其设置为 `album` 属性（以显示它）。
- en: '[PRE25]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Now that users have a way to show the title of an album, let’s give them a way
    to hide it. A small addition at ➊ is all it takes to let users toggle the album
    display with subsequent clicks.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 现在用户已经有了展示专辑标题的方法，让我们再提供一个隐藏标题的方法。在 ➊ 处做一个小的修改，就能让用户通过后续点击切换专辑显示。
- en: '[PRE26]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: As long as we’re making the graph respond to clicks, we can also take the opportunity
    to highlight the clicked node’s connections. We do that by changing their color.
    Just as `s.graph.nodes()` returns an array of the graph nodes, `s.graph.edges()`
    returns an array of edges. Each edge object includes `target` and `source` properties
    that hold the index of the relevant node.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我们已经让图表响应点击事件，那么我们也可以利用这个机会来突出显示被点击节点的连接。我们通过改变它们的颜色来实现这一点。就像 `s.graph.nodes()`
    返回图表节点的数组一样，`s.graph.edges()` 返回的是边的数组。每个边对象都包括 `target` 和 `source` 属性，分别存储相关节点的索引。
- en: '[PRE27]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Here we scan through all the graph’s edges to see if they connect to the clicked
    node. If the edge does connect to the node, we change its color at ➋ to something
    other than the default. Otherwise, we change the color back to the default at
    ➌. You can see that we’re using the same approach to toggle the edge colors as
    we did to toggle the node labels on successive clicks at ➊.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们扫描图表的所有边，查看它们是否与点击的节点相连。如果边确实连接到该节点，我们会在 ➋ 处将其颜色更改为不同于默认的颜色。否则，我们会在 ➌
    处将颜色恢复为默认值。可以看到，我们使用了与之前切换节点标签相同的方法来切换边的颜色，都是通过连续点击来实现的，位于 ➊。
- en: Now that we’ve changed the graph properties, we have to tell Sigma to redraw
    it. That’s a simple matter of calling `s.refresh()`.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经修改了图表的属性，我们需要告诉 Sigma 重新绘制它。这只是调用 `s.refresh()` 的简单问题。
- en: '[PRE28]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Now we have a fully interactive network graph in [Figure 4-9](ch04.html#interactive_graph_gives_users_the_chance
    "Figure 4-9. An interactive graph gives users the chance to highlight specific
    nodes.").
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: '现在，我们已经有了一个完全交互式的网络图，见 [图 4-9](ch04.html#interactive_graph_gives_users_the_chance
    "图 4-9. 交互式图表为用户提供了突出特定节点的机会。")。  '
- en: Revealing Language Patterns with Word Clouds
  id: totrans-155
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 通过词云揭示语言模式
- en: Data visualizations don’t always focus on numbers. Sometimes the data for a
    visualization centers on words instead, and a *word cloud* is often an effective
    way to present this kind of data. Word clouds can associate any quantity with
    a list of words; most often that quantity is a relative frequency. This type of
    word cloud, which we’ll create for our next example, reveals which words are common
    and which are rare.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 数据可视化并不总是关注数字。有时，数据可视化的焦点是单词，*词云*往往是展示这类数据的有效方式。词云可以将任意数量与单词列表关联起来；最常见的是，那个数量表示的是相对频率。这种类型的词云，我们将在下一个例子中创建，用来揭示哪些单词常见，哪些单词稀有。
- en: '![An interactive graph gives users the chance to highlight specific nodes.](figs/web/04fig09.png.jpg)Figure 4-9. An
    interactive graph gives users the chance to highlight specific nodes.'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: '![交互式图表为用户提供了突出特定节点的机会。](figs/web/04fig09.png.jpg)图 4-9. 交互式图表为用户提供了突出特定节点的机会。'
- en: To create this visualization, we’ll rely on the wordcloud2 library (*[http://timdream.org/wordcloud2.js](http://timdream.org/wordcloud2.js)*),
    a spin-off from author Tim Dream’s HTML5 Word Cloud project (*[http://timc.idv.tw/wordcloud/](http://timc.idv.tw/wordcloud/)*).
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建这个可视化效果，我们将依赖 wordcloud2 库 (*[http://timdream.org/wordcloud2.js](http://timdream.org/wordcloud2.js)*)，这是作者
    Tim Dream 的 HTML5 词云项目 (*[http://timc.idv.tw/wordcloud/](http://timc.idv.tw/wordcloud/)*）的衍生项目。
- en: Note
  id: totrans-159
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '**As is the case with a few of the more advanced libraries we’ve examined,
    wordcloud2 doesn’t function very well in older web browsers such as IE8 and earlier.
    Since wordcloud2 itself requires a modern browser, for this example we won’t worry
    about compatibility with older browsers. This will free us to use some other modern
    JavaScript features, too.**'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: '**像我们之前检查过的几个更高级的库一样，wordcloud2 在旧版浏览器（如 IE8 及更早版本）中表现不佳。由于 wordcloud2 本身需要现代浏览器，因此在这个例子中我们不需要担心与旧版浏览器的兼容性。这也让我们可以使用其他一些现代
    JavaScript 特性。**'
- en: 'Step 1: Include the Required Libraries'
  id: totrans-161
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 第一步：包含所需的库
- en: The wordcloud2 library does not depend on any other JavaScript libraries, so
    we don’t need any other included scripts. It is not, however, available on common
    content distribution networks, so we’ll have to serve it from our own web host.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: wordcloud2库不依赖任何其他JavaScript库，因此我们不需要其他包含的脚本。然而，它并未在常见的内容分发网络上提供，因此我们必须从我们自己的网络主机提供它。
- en: '[PRE29]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: To keep our example focused on the visualization, we’ll use a word list that
    doesn’t need any special preparation. If you’re working with natural language
    as spoken or written, however, you might wish to process the text to identify
    alternate forms of the same word. For example, you might want to count *hold*,
    *holds*, and *held* as three instances of *hold* rather than three separate words.
    This type of processing obviously depends greatly on the particular language.
    If you’re working in English and Chinese, though, the same developer that created
    wordcloud2 has also released the WordFreq JavaScript library (*[http://timdream.org/wordfreq/](http://timdream.org/wordfreq/)*),
    which performs exactly this type of analysis.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 为了让我们的示例专注于可视化部分，我们将使用一个不需要特别准备的单词列表。然而，如果你正在处理口语或书面自然语言，你可能希望处理文本，以识别同一单词的不同形式。例如，你可能想将*hold*、*holds*和*held*视为同一个单词*hold*的三种形式，而不是三个不同的词。这种处理显然在很大程度上取决于具体的语言。不过，如果你在使用英语和中文，那么创建wordcloud2的开发者也发布了WordFreq
    JavaScript库（*[http://timdream.org/wordfreq/](http://timdream.org/wordfreq/)*），它正是执行这种类型分析的工具。
- en: 'Step 2: Prepare the Data'
  id: totrans-165
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 第二步：准备数据
- en: For this example, we’ll look at the different tags users associate with their
    questions on the popular Stack Overflow (*[http://stackoverflow.com/](http://stackoverflow.com/)*).
    That site lets users pose programming questions that the community tries to answer.
    Tags provide a convenient way to categorize the questions so that users can browse
    other posts related to the same topic. By constructing a word cloud (perhaps better
    named a *tag cloud*), we can quickly show the relative popularity of different
    programming topics.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们将查看用户在流行的Stack Overflow网站上与他们问题相关的不同标签（*[http://stackoverflow.com/](http://stackoverflow.com/)*）。该网站允许用户提出编程问题，社区则尝试回答这些问题。标签为问题提供了一种方便的分类方式，使得用户能够浏览与相同主题相关的其他帖子。通过构建词云（也许更好地称之为*标签云*），我们可以快速展示不同编程主题的相对受欢迎程度。
- en: 'If you wanted to develop this example into a real application, you could access
    the Stack Overflow data in real time using the site’s API. For our example, though,
    we’ll use a static snapshot. Here’s how it starts:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想将这个示例发展成一个真实的应用程序，你可以通过该网站的API实时访问Stack Overflow的数据。然而，对于我们的示例，我们将使用一个静态快照。下面是如何开始的：
- en: '[PRE30]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: In this data set, the list of tags is an array, and each tag within the list
    is also an array. These inner arrays have the word itself as the first item and
    a count for that word as the second item. You can see the complete list in the
    book’s source code (*[http://jsDataV.is/source/](http://jsDataV.is/source/)*).
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个数据集中，标签列表是一个数组，列表中的每个标签也是一个数组。这些内部数组的第一个项目是单词本身，第二个项目是该单词的计数。你可以在书籍的源代码中查看完整的列表（*[http://jsDataV.is/source/](http://jsDataV.is/source/)*）。
- en: The format that wordcloud2 expects is quite similar to how our data is already
    laid out, except that in each word array, the second value needs to specify the
    drawing size for that word. For example, the array element `["javascript", 56]`
    would tell wordcloud2 to draw *javascript* with a height of 56 pixels. Our data,
    of course, isn’t set up with pixel sizes. The data value for *javascript* is `557407`,
    and a word 557,407 pixels high wouldn’t even fit on a billboard. As a result,
    we must convert counts to drawing sizes. The specific algorithm for this conversion
    will depend both on the size of the visualization and on the raw values. A simple
    approach that works in this case is to divide the count values by 10,000 and round
    to the nearest integer.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: wordcloud2所期望的格式与我们当前数据的布局非常相似，唯一不同的是，在每个单词数组中，第二个值需要指定该单词的绘制大小。例如，数组元素`["javascript",
    56]`会告诉wordcloud2将*javascript*绘制为56像素的高度。当然，我们的数据没有以像素大小设置。*javascript*的计数值是`557407`，一个高度为557,407像素的单词甚至无法放进广告牌上。因此，我们必须将计数转换为绘制大小。具体的转换算法将取决于可视化的大小以及原始数据值。一个在此案例中有效的简单方法是将计数值除以10,000并四舍五入到最接近的整数。
- en: '[PRE31]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: In [Chapter 2](ch02.html "Chapter 2. Making Charts Interactive"), we saw how
    jQuery’s `.map()` function makes it easy to process all the elements in an array.
    It turns out that modern browsers have the same functionality built in, so here
    we use the native version of `.map()` even without jQuery. (This native version
    won’t work on older browsers like jQuery will, but we’re not worrying about that
    for this example.)
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第2章](ch02.html "第2章. 使图表互动")中，我们看到 jQuery 的 `.map()` 函数如何让处理数组中的所有元素变得非常容易。事实证明，现代浏览器内建了相同的功能，所以在这里我们即使没有
    jQuery，也使用了 `.map()` 的原生版本。（这个原生版本在较旧的浏览器上无法像 jQuery 那样工作，但我们在这个示例中不需要担心这个问题。）
- en: 'After this code executes, our `list` variable will contain the following:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 在这段代码执行后，我们的 `list` 变量将包含以下内容：
- en: '[PRE32]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Step 3: Add the Required Markup'
  id: totrans-175
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 第3步：添加必要的标记
- en: The wordcloud2 library can build its graphics either using the HTML `<canvas>`
    interface or in pure HTML. As we’ve seen with many graphing libraries, `<canvas>`
    is a convenient interface for creating graphic elements. For word clouds, however,
    there aren’t many benefits to using `<canvas>`. Native HTML, on the other hand,
    lets us use all the standard HTML tools (such as CSS style sheets or JavaScript
    event handling). That’s the approach we’ll take in this example.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: wordcloud2 库可以使用 HTML `<canvas>` 接口或纯 HTML 来构建图形。如同我们在许多图形库中看到的，`<canvas>` 是一个非常方便的接口，用于创建图形元素。然而，对于词云来说，使用
    `<canvas>` 并没有太多好处。另一方面，原生 HTML 允许我们使用所有标准的 HTML 工具（如 CSS 样式表或 JavaScript 事件处理）。在这个示例中，我们将采用这种方法。
- en: '[PRE33]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'When using native HTML, we do have to make sure that the containing element
    has a `position: relative` style, because wordcloud2 relies on that when placing
    the words in their proper location in the cloud. You can see that here we’ve set
    that style inline at ➊.'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: '在使用原生 HTML 时，我们确实需要确保包含元素具有 `position: relative` 样式，因为 wordcloud2 在将单词放置到云中合适位置时依赖于这个样式。你可以看到，在这里我们已经在
    ➊ 处设置了这个样式。'
- en: 'Step 4: Create a Simple Cloud'
  id: totrans-179
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 第4步：创建一个简单的云
- en: With these preparations in place, creating a simple word cloud is about as easy
    as it can get. We call the wordcloud2 library and tell it the HTML element in
    which to draw the cloud, and the list of words for the cloud’s data.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 准备好这些之后，创建一个简单的词云就变得非常容易了。我们调用 wordcloud2 库并告诉它绘制云的 HTML 元素，以及云的数据单词列表。
- en: '[PRE34]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Even with nothing other than default values, wordcloud2 creates the attractive
    visualization shown in [Figure 4-10](ch04.html#word_cloud_can_show_a_list_of_words_with
    "Figure 4-10. A word cloud can show a list of words with their relative frequency.").
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 即使只有默认值，wordcloud2 也会创建出如[图4-10](ch04.html#word_cloud_can_show_a_list_of_words_with
    "图4-10. 词云可以显示单词及其相对频率。")所示的吸引人的可视化效果。
- en: The wordcloud2 interface also provides many options for customizing the visualization.
    As expected, you can set colors and fonts, but you can also change the shape of
    the cloud (even providing a custom polar equation), rotation limits, internal
    grid sizing, and many other features.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: wordcloud2 接口还提供了许多自定义可视化效果的选项。正如预期的那样，你可以设置颜色和字体，但你还可以改变云的形状（甚至提供自定义的极坐标方程）、旋转限制、内部网格大小以及许多其他功能。
- en: '![A word cloud can show a list of words with their relative frequency.](figs/web/04fig10.png.jpg)Figure 4-10. A
    word cloud can show a list of words with their relative frequency.'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: '![词云可以显示单词及其相对频率。](figs/web/04fig10.png.jpg)图4-10. 词云可以显示单词及其相对频率。'
- en: 'Step 5: Add Interactivity'
  id: totrans-185
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 第5步：添加交互性
- en: If you ask wordcloud2 to use the `<canvas>` interface, it gives you a couple
    of callback hooks that your code can use to respond to user interactions. With
    native HTML, however, we aren’t limited to just the callbacks that wordcloud2
    provides. To demonstrate, we can add a simple interaction to respond to mouse
    clicks on words in the cloud.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你要求 wordcloud2 使用 `<canvas>` 接口，它会提供一些回调钩子，供你的代码响应用户的交互。然而，在原生 HTML 中，我们不仅仅局限于
    wordcloud2 提供的回调。为了演示这一点，我们可以添加一个简单的交互，来响应鼠标点击云中单词的操作。
- en: First we’ll let users know that interactions are supported by changing the cursor
    to a pointer when they hover the mouse over a cloud word.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们会让用户知道支持交互，当他们将鼠标悬停在云中的单词上时，我们会将鼠标指针更改为指针形态。
- en: '[PRE35]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Next let’s add an extra element to the markup where we can display information
    about any clicked word.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们在标记中添加一个额外的元素，用于显示关于任何被点击单词的信息。
- en: '[PRE36]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Here we’ve added the `<div>` with the `id details` at ➊.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 这里我们在 ➊ 处添加了带有 `id details` 的 `<div>` 元素。
- en: Then we define a function that can be called when the user clicks within the
    cloud.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们定义一个函数，当用户点击云中的某个位置时可以调用该函数。
- en: '[PRE37]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Because our function will be called for any clicks on the cloud (including clicks
    on empty space), it first checks to see if the target of the click was really
    a word. Words are contained in `<span>` elements, so we can verify that by looking
    at the `nodeName` property of the click target. As you can see at ➊, JavaScript
    node names are always uppercase.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们的函数会在云容器中的任何点击事件（包括点击空白区域）触发时被调用，因此它首先检查点击的目标是否真的为一个单词。单词被包含在 `<span>` 元素中，因此我们可以通过查看点击目标的
    `nodeName` 属性来验证这一点。如你在 ➊ 处所见，JavaScript 的节点名称总是大写。
- en: If the user did click on a word, we can find out which word by looking at the
    `textContent` property of the event target.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 如果用户确实点击了一个单词，我们可以通过查看事件目标的 `textContent` 属性来找出是哪个单词。
- en: '[PRE38]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: After ➊, the variable `tag` will hold the word on which the user clicked. So,
    for example, if a user clicks on the word *javascript*, then the tag variable
    will have the value `"javascript"`.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 在 ➊ 之后，变量 `tag` 将保存用户点击的单词。因此，例如，如果用户点击了单词 *javascript*，那么 `tag` 变量将会有值 `"javascript"`。
- en: Since we’d like to show users the total count when they click on a word, we’re
    going to need to find the word in our original data set. We have the word’s value,
    so that’s simply a matter of searching through the data set to find a match. If
    we were using jQuery, the `.grep()` function would do just that. In this example,
    we’re sticking with native JavaScript, so we can look for an equivalent method
    in pure JavaScript. Unfortunately, although there is such a native method defined—`.find()`—very
    few browsers, even modern ones, currently support it. We could resort to a standard
    `for` or `forEach` loop, but there is an alternative that many consider an improvement
    over that approach. It relies on the `.some()` method, an array method that modern
    browsers support. The `.some()` method passes every element of an array to an
    arbitrary function and stops when that function returns `true`. Here’s how we
    can use it to find the clicked tag in our `tags` array.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们希望在用户点击单词时显示总数，我们需要在原始数据集中查找该单词。我们已经有了单词的值，因此只需通过数据集进行搜索，找到匹配的项。如果我们使用的是
    jQuery，`.grep()` 函数就能做到这一点。在这个示例中，我们坚持使用原生 JavaScript，因此我们需要寻找一个原生 JavaScript
    中的等效方法。不幸的是，尽管已经定义了这样的原生方法——`.find()`——但目前很少有浏览器（即使是现代浏览器）支持它。我们可以采用标准的 `for`
    或 `forEach` 循环，但也有一种替代方案，许多人认为这种方法优于前者。它依赖于现代浏览器支持的 `.some()` 方法。`.some()` 方法会将数组中的每个元素传递给一个任意函数，当该函数返回
    `true` 时停止。下面是我们如何使用它来查找点击的标签在 `tags` 数组中的位置。
- en: '[PRE39]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: The function that’s the argument to `.some()` is defined beginning at ➊ and
    ending at ➍. It is called with the parameter `el`, short for an *element* in the
    `tags` array. The conditional statement at ➋ checks to see if that element’s word
    matches the clicked node’s text content. If so, the function sets the `clickedTag`
    variable and returns `true` to terminate the `.some()` loop.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 作为 `.some()` 参数的函数定义从 ➊ 开始，到 ➍ 结束。该函数以 `el` 为参数，`el` 是 `tags` 数组中的一个 *元素* 的缩写。➋
    处的条件语句检查该元素的单词是否与点击节点的文本内容匹配。如果匹配，该函数会设置 `clickedTag` 变量并返回 `true`，以终止 `.some()`
    循环。
- en: If the clicked word doesn’t match the element we’re checking in the `tags` array,
    then the function supplied to .`some()` returns `false` at ➌. When .`some()` sees
    a `false` return value, it continues iterating through the array.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 如果点击的单词与我们在 `tags` 数组中检查的元素不匹配，那么传给 `.some()` 的函数会在 ➌ 返回 `false`。当 `.some()`
    遇到 `false` 的返回值时，它会继续遍历数组。
- en: We can use the return value of the `.some()` method to make sure the clicked
    element was found in the array. When that’s the case, `.some()` itself returns
    `true`.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用 `.some()` 方法的返回值来确保点击的元素确实在数组中找到了。当发生这种情况时，`.some()` 本身会返回 `true`。
- en: '[PRE40]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: At ➊ and ➋ we update the `details` variable with extra information. At ➌ we
    update the web page with those details.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 在 ➊ 和 ➋ 处，我们用额外的信息更新了 `details` 变量。在 ➌ 处，我们用这些信息更新了网页。
- en: And finally we tell the browser to call our handler when a user clicks on anything
    in the cloud container.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们告诉浏览器，当用户点击云容器中的任何内容时，调用我们的处理程序。
- en: '[PRE41]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: With these few lines of code, our word cloud is now interactive, as shown in
    [Figure 4-11](ch04.html#because_our_word_cloud_consists_of_stand "Figure 4-11. Because
    our word cloud consists of standard HTML elements, we can make it interactive
    with simple JavaScript event handlers.").
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这几行代码，我们的词云现在变得互动了，如 [图 4-11](ch04.html#because_our_word_cloud_consists_of_stand
    "图 4-11. 由于我们的词云由标准 HTML 元素组成，因此我们可以通过简单的 JavaScript 事件处理程序使其具有互动性。") 所示。
- en: '![Because our word cloud consists of standard HTML elements, we can make it
    interactive with simple JavaScript event handlers.](figs/web/04fig11.png.jpg)Figure 4-11. Because
    our word cloud consists of standard HTML elements, we can make it interactive
    with simple JavaScript event handlers.'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: '![由于我们的词云由标准HTML元素组成，因此我们可以通过简单的JavaScript事件处理器使其具有交互性。](figs/web/04fig11.png.jpg)图
    4-11。由于我们的词云由标准HTML元素组成，因此我们可以通过简单的JavaScript事件处理器使其具有交互性。'
- en: Summing Up
  id: totrans-209
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we’ve looked at several different special-purpose visualizations
    and some JavaScript libraries that can help us create them. Tree maps are handy
    for showing both hierarchy and dimension in a single visualization. Heat maps
    can highlight varying intensities throughout a region. Network graphs reveal the
    connections between objects. And word clouds show relative relationships between
    language properties in an attractive and concise visualization.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们探讨了几种不同的专用可视化图表和一些可以帮助我们创建它们的JavaScript库。树状图非常适合在单一可视化中展示层级关系和维度信息。热力图可以突出显示区域内的不同强度。网络图揭示了对象之间的连接关系。而词云则通过一种吸引人且简洁的可视化方式展示语言属性之间的相对关系。
