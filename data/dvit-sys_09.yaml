- en: '9'
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '9'
- en: ARM ASSEMBLY
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: ARM 汇编
- en: '![image](../images/common.jpg)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/common.jpg)'
- en: In this chapter, we cover the ARM version 8 application profile (ARMv8-A) architecture
    A64 ISA, the latest ARM ISA that is in use on all Linux OS ARM computers. Recall
    that an instruction set architecture (or ISA; see [Chapter 5](ch05.xhtml#ch05))
    defines the set of instructions and binary encodings of a machine-level program.
    To run the examples in this chapter, you will need access to a machine with an
    ARMv8-A processor with a 64-bit operating system installed. The examples in this
    chapter use a Raspberry Pi 3B+ running the 64-bit Ubuntu Mate operating system.
    Note that every Raspberry Pi released since 2016 can use the A64 ISA. However,
    Raspberry Pi OS (the default Raspberry Pi operating system) is still 32-bit as
    of this writing.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中，我们将介绍ARM版本8应用程序配置（ARMv8-A）架构的A64指令集（ISA），这是当前所有Linux操作系统ARM计算机上使用的最新ARM
    ISA。回想一下，指令集架构（或ISA；见[第5章](ch05.xhtml#ch05)）定义了机器级程序的一组指令和二进制编码。要运行本章中的示例，你需要一台安装了64位操作系统的ARMv8-A处理器的计算机。本章中的示例使用的是运行64位Ubuntu
    Mate操作系统的树莓派3B+。请注意，自2016年以来发布的每一款树莓派都可以使用A64 ISA。然而，树莓派操作系统（默认的树莓派操作系统）截至目前仍然是32位的。
- en: 'You can confirm that you have a 64-bit version of the operating system (OS)
    on your system by running the `uname -p` command. A system with a 64-bit OS will
    output the following:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过运行`uname -p`命令确认你的系统是否安装了64位操作系统（OS）。拥有64位操作系统的系统将输出以下内容：
- en: '[PRE0]'
  id: totrans-5
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Although it is possible to *build* ARM binaries on Intel machines using ARM’s
    GNU toolchain cross-compilation tools,^([1](ch09.xhtml#fn9_1)) you cannot *run*
    ARM binaries directly on a x86 system. Readers interested in learning about ARM
    assembly directly on their laptops are encouraged to explore QEMU,^([2](ch09.xhtml#fn9_2))
    which can *emulate* an ARM system. Emulators differ from virtual machines in that
    they also simulate the hardware of another system.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然可以使用ARM的GNU工具链交叉编译工具在Intel机器上*构建*ARM二进制文件，^([1](ch09.xhtml#fn9_1)) 但无法直接在x86系统上*运行*ARM二进制文件。想要在自己的笔记本电脑上直接学习ARM汇编的读者，可以尝试探索QEMU，^([2](ch09.xhtml#fn9_2))
    它可以*模拟*一个ARM系统。模拟器不同于虚拟机，因为它们还会模拟另一个系统的硬件。
- en: Another alternative is to use one of Amazon’s recently released EC2 A1 instances.^([3](ch09.xhtml#fn9_3))
    Each instance gives users access to a 64-bit Graviton processor, which follows
    the ARMv8-A specification.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个选择是使用亚马逊最近发布的EC2 A1实例。^([3](ch09.xhtml#fn9_3)) 每个实例为用户提供一个64位Graviton处理器，遵循ARMv8-A规范。
- en: Keep in mind, however, that the specific assembly instructions produced by a
    compiler are highly influenced by the operating system and precise machine architecture.
    Therefore, the assembly produced on AWS instances or through QEMU emulation may
    differ slightly from the examples shown in this chapter.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，请记住，编译器生成的特定汇编指令会受到操作系统和精确机器架构的高度影响。因此，在AWS实例或通过QEMU仿真生成的汇编可能与本章中展示的示例略有不同。
- en: RISC AND ARM PROCESSORS
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: RISC与ARM处理器
- en: For many years, complex instruction set computer (CISC) architectures dominated
    the personal computing and server markets. Common examples of CISC architectures
    include Intel and AMD processors. However, reduced instruction set computer (RISC)
    architectures gained momentum over the past decade due to demand from the mobile
    computing sector. ARM (which stands for Acorn RISC machine) is an example of a
    RISC architecture, along with RISC-V and MIPS. RISC architectures are especially
    attractive to mobile computing due to the energy efficiency of their processors,
    which prolongs battery life. In recent years, ARM and other RISC processors have
    begun making headway in the server and high performance computing (HPC) markets.
    For example, Japan’s Fugaku supercomputer, the fastest in the world as of 2020,
    uses ARM processors.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 多年来，复杂指令集计算机（CISC）架构主导了个人计算和服务器市场。CISC架构的常见例子包括Intel和AMD处理器。然而，由于移动计算领域的需求，精简指令集计算机（RISC）架构在过去十年中逐渐获得了动力。ARM（即Acorn
    RISC机器）是RISC架构的一个例子，此外还有RISC-V和MIPS。由于其处理器的能效，RISC架构特别适合移动计算，从而延长电池寿命。近年来，ARM和其他RISC处理器开始在服务器和高性能计算（HPC）市场取得进展。例如，日本的Fugaku超级计算机（截至2020年为全球最快）就使用了ARM处理器。
- en: '9.1 Diving into Assembly: Basics'
  id: totrans-11
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 9.1 深入汇编：基础知识
- en: 'For a first look at assembly, we modify the `adder` function from [Chapter
    6](ch06.xhtml#ch06) to simplify its behavior. The modified function (`adder2`)
    is shown here:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 为了首次接触汇编，我们修改了[第6章](ch06.xhtml#ch06)中的`adder`函数，简化了其行为。修改后的函数（`adder2`）如下所示：
- en: '[PRE1]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'To compile this code, use the following command:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 要编译这段代码，请使用以下命令：
- en: '[PRE2]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Next, let’s view the corresponding assembly of this code by using the `objdump`
    command:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们使用`objdump`命令查看这段代码的相应汇编：
- en: '[PRE3]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Search for the code snippet associated with adder2 by typing /adder while examining
    the file `output` using `less`. The section associated with `adder` should look
    similar to the following:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 在查看文件`output`时，使用`less`并输入/adder来搜索与adder2相关的代码片段。与`adder`相关的部分应该看起来类似于以下内容：
- en: '[PRE4]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Don’t worry if you don’t understand what’s going on just yet. We will cover
    assembly in greater detail in future sections. For now, let’s study the structure
    of these individual instructions.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 不用担心如果你现在还不完全理解发生了什么。我们将在未来的章节中更详细地介绍汇编。现在，让我们研究这些单个指令的结构。
- en: 'Each line in the preceding example contains the instruction’s 64-bit address
    in program memory (shortened to the lowest three digits to save space), the bytes
    corresponding to the instruction, and the plaintext representation of the instruction
    itself. For example, `d10043ff` is the machine code representation of the instruction
    `sub sp, sp, #0x10`, and the instruction occurs at address `0x724` in code memory.
    Note that `0x724` is an abbreviation of the full 64-bit address associated with
    the `sub sp, sp #0x10` instruction; `objdump` omits the leading zeros to help
    with readability.'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: '前面示例中的每一行包含了程序内存中指令的64位地址（为了节省空间，仅缩写为最低三位数字）、与指令对应的字节，以及指令本身的明文表示。例如，`d10043ff`是指令`sub
    sp, sp, #0x10`的机器码表示，这条指令出现在代码内存地址`0x724`。注意，`0x724`是与`sub sp, sp #0x10`指令相关的完整64位地址的缩写；`objdump`省略了前导零，以提高可读性。'
- en: 'It is important to note that a single line of C code often translates to multiple
    instructions in assembly. The operation `a + 2` is represented by the three instructions
    at code memory addresses `0x728` through `0x730`: `str w0, [sp, #12]`, `ldr w0,
    [sp, #12]`, and `add w0, w0, #0x2`.'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: '需要注意的是，一行C代码通常会翻译成多条汇编指令。操作`a + 2`由代码内存地址`0x728`到`0x730`的三条指令表示：`str w0, [sp,
    #12]`，`ldr w0, [sp, #12]`和`add w0, w0, #0x2`。'
- en: '**Warning YOUR ASSEMBLY MAY LOOK DIFFERENT!**'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: '**警告 你的汇编代码可能看起来不同！**'
- en: If you are compiling your code along with us, you may notice that some of your
    assembly examples look different. The precise assembly instructions that are output
    by a compiler depend on the generating compiler’s version, the precise architecture,
    and the underlying OS. Most of the assembly examples in this chapter were generated
    on a Raspberry Pi 3B+ running the 64-bit Ubuntu Mate operating system and using
    GCC. If you use a different OS, a different compiler, or a different Raspberry
    Pi or single-board computer, your assembly output may vary.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在和我们一起编译代码，可能会注意到你的一些汇编示例看起来有所不同。编译器输出的精确汇编指令依赖于生成编译器的版本、精确的架构以及底层操作系统。我们本章中的大部分汇编示例是在运行64位Ubuntu
    Mate操作系统的Raspberry Pi 3B+上使用GCC生成的。如果你使用的是不同的操作系统、不同的编译器，或者不同的树莓派或单板计算机，你的汇编输出可能会有所不同。
- en: In the examples that follow, we do not use any optimization flags. For example,
    we compile any example file (e.g. `example.c`) using the command `gcc -o example
    example.c`. Consequently, there are many seemingly redundant instructions in the
    examples that follow. Remember that the compiler is not “smart”—it simply follows
    a series of rules to translate human-readable code into machine language. During
    this translation process, it is not uncommon for some redundancy to occur. Optimizing
    compilers remove many of these redundancies during optimization, which is covered
    in [Chapter 12](ch12.xhtml#ch12).
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的示例中，我们没有使用任何优化标志。例如，我们使用命令`gcc -o example example.c`来编译任何示例文件（例如`example.c`）。因此，接下来的示例中会有许多看似冗余的指令。记住，编译器并不“聪明”——它仅按照一系列规则将人类可读的代码转换为机器语言。在这个转换过程中，出现一些冗余是很常见的现象。优化编译器在优化过程中会移除这些冗余，相关内容将在[第12章](ch12.xhtml#ch12)中讨论。
- en: 9.1.1 Registers
  id: totrans-26
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 9.1.1 寄存器
- en: 'Recall that a *register* is a word-sized storage unit located directly on the
    CPU. The ARMv8 CPU has a total of 31 registers for storing general-purpose 64-bit
    data: `x0` to `x30`. Whereas a program may interpret a register’s contents as
    integers or as addresses, the register itself makes no distinction. Programs can
    read from or write to all 31 registers.'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 回想一下，*寄存器*是一个字长的存储单元，直接位于CPU上。ARMv8 CPU共有31个寄存器用于存储通用的64位数据：`x0`到`x30`。尽管程序可以将寄存器的内容解释为整数或地址，但寄存器本身并不做区分。程序可以读写所有31个寄存器。
- en: The ARMv8-A ISA also specifies special-purpose registers. The first two worth
    noting are the *stack pointer* register (`sp`) and the *program counter* register
    (`pc`). The compiler reserves the `sp` register for maintaining the layout of
    the program stack. The `pc` register points to the next instruction to be executed
    by the CPU; unlike the other registers, programs cannot write directly to the
    `pc` register. Next, the *zero register* `zr` permanently stores the value 0,
    and is only useful as a source register.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: ARMv8-A ISA还指定了特殊用途寄存器。值得注意的前两个是*栈指针*寄存器(`sp`)和*程序计数器*寄存器(`pc`)。编译器保留`sp`寄存器以维护程序栈的布局。`pc`寄存器指向CPU即将执行的下一条指令；与其他寄存器不同，程序不能直接写入`pc`寄存器。接下来，*零寄存器*
    `zr` 永久存储值0，仅作为源寄存器有用。
- en: 9.1.2 Advanced Register Notation
  id: totrans-29
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 9.1.2 高级寄存器表示法
- en: Since ARMv8-A is an extension of the 32-bit ARMv7-A architecture, the A64 ISA
    provides mechanisms to access the lower 32 bits of each of the general-purpose
    registers, or `w0` through `w30`. [Figure 9-1](ch09.xhtml#ch9fig1) shows a sample
    layout of register `x0`. If 32-bit data is stored in component register `w0`,
    then the upper 32 bits of the register become inaccessible, and are zeroed out.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 由于ARMv8-A是32位ARMv7-A架构的扩展，A64 ISA提供了访问每个通用寄存器的低32位（或`w0`到`w30`）的机制。[图9-1](ch09.xhtml#ch9fig1)展示了寄存器`x0`的示例布局。如果32位数据存储在组件寄存器`w0`中，则寄存器的高32位变为不可访问并被清零。
- en: '![image](../images/09fig01.jpg)'
  id: totrans-31
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/09fig01.jpg)'
- en: '*Figure 9-1: Component register layout of register %x0*'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: '*图9-1：寄存器%x0的组件寄存器布局*'
- en: '**Warning THE COMPILER MAY CHOOSE COMPONENT REGISTERS DEPENDING ON TYPE**'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: '**警告 编译器根据类型可能会选择组件寄存器**'
- en: When reading assembly code, keep in mind that the compiler typically uses the
    64-bit registers when dealing with 64-bit values (e.g., pointers or `long` types)
    and the 32-bit component registers when dealing with 32-bit types (e.g., `int`).
    In A64, it is very common to see 32-bit component registers intermixed with the
    full 64-bit registers. For example, in the `adder2` function shown earlier, the
    compiler references component register `w0` instead of `x0` given that `int` types
    typically take up 32 bits (four bytes) of space on 64-bit systems. If the `adder2`
    function had a `long` parameter instead of an `int` parameter, the compiler would
    store `a` in register `x0` instead of component register `w0`.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 在阅读汇编代码时，请记住编译器通常在处理64位值（例如指针或`long`类型）时使用64位寄存器，并在处理32位类型（例如`int`）时使用32位组件寄存器。在A64中，经常看到32位组件寄存器与完整的64位寄存器混用。例如，在前述的`adder2`函数中，编译器使用组件寄存器`w0`而不是`x0`，因为`int`类型在64位系统上通常占用32位（四字节）空间。如果`adder2`函数有一个`long`参数而不是`int`参数，编译器将会将`a`存储在寄存器`x0`而不是组件寄存器`w0`中。
- en: For readers previously familiar with the A32 ISA, it is important to note that
    the 32-bit general-purpose registers `r0` to `r12` from the A32 ISA map to the
    A64 component registers `w0` to `w12`. The A64 ISA more than doubles the number
    of available registers.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 对于之前熟悉A32 ISA的读者，重要的是注意A32 ISA中的32位通用寄存器`r0`到`r12`与A64组件寄存器`w0`到`w12`的映射关系。A64
    ISA提供的寄存器数量是A32的两倍以上。
- en: 9.1.3 Instruction Structure
  id: totrans-36
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 9.1.3 指令结构
- en: 'Each instruction consists of an operation code (or *opcode*) that specifies
    what it does, and one or more *operands* that tells the instruction how to do
    it. For most A64 instructions, the following format is typically used:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 每条指令由一个操作码（或*opcode*）指定其功能，以及一个或多个*操作数*指示指令如何执行。对于大多数A64指令，通常使用以下格式：
- en: '[PRE5]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Where <opcode> is the operation code, <D> is the destination register, <O1>
    is the first operand, and <O2> the second operand. For example, the instruction
    `add w0, w0, #0x2` has the opcode `add`, a destination register of `w0`, and the
    two operands `w0` and `#0x2`. There are multiple types of operands:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: '其中<opcode>是操作码，<D>是目标寄存器，<O1>是第一个操作数，<O2>是第二个操作数。例如，指令`add w0, w0, #0x2`具有操作码`add`，目标寄存器为`w0`，操作数为`w0`和`#0x2`。操作数有多种类型：'
- en: '*Constant (literal)* values are preceded by the `#` sign. For example, in the
    instruction `add w0, w0, #0x2`, the operand `#0x2` is a literal value that corresponds
    to the hexadecimal value 0x2.'
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*常量（字面值）*的值前面带有`#`符号。例如，在指令`add w0, w0, #0x2`中，操作数`#0x2`是一个字面值，对应十六进制值0x2。'
- en: '*Register* forms refer to individual registers. The instruction `add` `sp,
    sp, #0x10` uses the stack pointer register `sp` to designate the destination register
    and the first of the two operands needed for the `add` instruction.'
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*寄存器*形式指的是单个寄存器。指令`add sp, sp, #0x10`使用堆栈指针寄存器`sp`来指定目标寄存器，并作为`add`指令所需的两个操作数中的第一个。'
- en: '*Memory* forms correspond to some value inside main memory (RAM) and are commonly
    used for address lookups. Memory address forms can contain a combination of registers
    and constant values. For example, in the instruction `str w0, [sp, #12]`, the
    operand `[sp,` `#12]` is an example of a memory form. It loosely translates to
    “add 12 to the value in register `sp`, and then perform a memory lookup on the
    corresponding address.” If this sounds like a pointer dereference, that’s because
    it is!'
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*内存*形式对应主内存（RAM）中的某个值，通常用于地址查找。内存地址形式可以包含寄存器和常量值的组合。例如，在指令`str w0, [sp, #12]`中，操作数`[sp,
    #12]`就是一种内存形式。它可以大致翻译为“将12加到寄存器`sp`中的值上，然后对相应地址进行内存查找。”如果这听起来像是指针解引用，那是因为它就是这样！'
- en: 9.1.4 An Example with Operands
  id: totrans-43
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 9.1.4 操作数示例
- en: 'The best way to explain operands in detail is to present a quick example. Suppose
    that memory contains the following values:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 解释操作数的最佳方式是通过一个快速示例。假设内存中包含以下值：
- en: '| **Address** | **Value** |'
  id: totrans-45
  prefs: []
  type: TYPE_TB
  zh: '| **地址** | **值** |'
- en: '| 0x804 | 0xCA |'
  id: totrans-46
  prefs: []
  type: TYPE_TB
  zh: '| 0x804 | 0xCA |'
- en: '| 0x808 | 0xFD |'
  id: totrans-47
  prefs: []
  type: TYPE_TB
  zh: '| 0x808 | 0xFD |'
- en: '| 0x80c | 0x12 |'
  id: totrans-48
  prefs: []
  type: TYPE_TB
  zh: '| 0x80c | 0x12 |'
- en: '| 0x810 | 0x1E |'
  id: totrans-49
  prefs: []
  type: TYPE_TB
  zh: '| 0x810 | 0x1E |'
- en: 'Let’s also assume that the following registers contain the values:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 假设以下寄存器包含这些值：
- en: '| **Register** | **Value** |'
  id: totrans-51
  prefs: []
  type: TYPE_TB
  zh: '| **寄存器** | **值** |'
- en: '| `x0` | 0x804 |'
  id: totrans-52
  prefs: []
  type: TYPE_TB
  zh: '| `x0` | 0x804 |'
- en: '| `x1` | 0xC |'
  id: totrans-53
  prefs: []
  type: TYPE_TB
  zh: '| `x1` | 0xC |'
- en: '| `x2` | 0x2 |'
  id: totrans-54
  prefs: []
  type: TYPE_TB
  zh: '| `x2` | 0x2 |'
- en: '| `w3` | 0x4 |'
  id: totrans-55
  prefs: []
  type: TYPE_TB
  zh: '| `w3` | 0x4 |'
- en: Then the operands in [Table 9-1](ch09.xhtml#ch9tab1) evaluate to the values
    shown there. Each row of the table matches an operand with its form (e.g., constant,
    register, memory), how it is translated, and its value.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，[表9-1](ch09.xhtml#ch9tab1)中的操作数会计算出其中显示的值。表格的每一行将操作数与其形式（例如，常量、寄存器、内存）、如何翻译以及其值进行匹配。
- en: '**Table 9-1:** Example Operands'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: '**表9-1：** 操作数示例'
- en: '| **Operand** | **Form** | **Translation** | **Value** |'
  id: totrans-58
  prefs: []
  type: TYPE_TB
  zh: '| **操作数** | **形式** | **翻译** | **值** |'
- en: '| `x0` | Register | `x0` | 0x804 |'
  id: totrans-59
  prefs: []
  type: TYPE_TB
  zh: '| `x0` | 寄存器 | `x0` | 0x804 |'
- en: '| `[x0]` | Memory | *(0x804) | 0xCA |'
  id: totrans-60
  prefs: []
  type: TYPE_TB
  zh: '| `[x0]` | 内存 | *(0x804) | 0xCA |'
- en: '| `#0x804` | Constant | 0x804 | 0x804 |'
  id: totrans-61
  prefs: []
  type: TYPE_TB
  zh: '| `#0x804` | 常量 | 0x804 | 0x804 |'
- en: '| `[x0, #8]` | Memory | *(`x0` + 8) or *(0x80c) | 0x12 |'
  id: totrans-62
  prefs: []
  type: TYPE_TB
  zh: '| `[x0, #8]` | 内存 | *(`x0` + 8) 或 *(0x80c) | 0x12 |'
- en: '| `[x0, x1]` | Memory | *(`x0` + `x1`) or *(0x810) | 0x1E |'
  id: totrans-63
  prefs: []
  type: TYPE_TB
  zh: '| `[x0, x1]` | 内存 | *(`x0` + `x1`) 或 *(0x810) | 0x1E |'
- en: '| `[x0, w3, SXTW]` | (Sign-extend) memory | *(`x0` + SignExtend(`w3`)) or *(0x808)
    | 0xFD |'
  id: totrans-64
  prefs: []
  type: TYPE_TB
  zh: '| `[x0, w3, SXTW]` | （符号扩展）内存 | *(`x0` + 符号扩展(`w3`)) 或 *(0x808) | 0xFD |'
- en: '| `[x0, x2, LSL, #2]` | Scaled memory | *(`x0` + (`x2 ≪ 2`)) or *(0x80c) |
    0x12 |'
  id: totrans-65
  prefs: []
  type: TYPE_TB
  zh: '| `[x0, x2, LSL, #2]` | 缩放内存 | *(`x0` + (`x2 ≪ 2`)) 或 *(0x80c) | 0x12 |'
- en: '| `[x0, w3, SXTW, #1]` | (Sign-extend) scaled memory | *(`x0` + SignExtend(`w3
    ≪ 1`)) or *(0x80c) | 0x12 |'
  id: totrans-66
  prefs: []
  type: TYPE_TB
  zh: '| `[x0, w3, SXTW, #1]` | （符号扩展）缩放内存 | *(`x0` + 符号扩展(`w3 ≪ 1`)) 或 *(0x80c) |
    0x12 |'
- en: In [Table 9-1](ch09.xhtml#ch9tab1), the notation `x0` indicates the value stored
    in 64-bit register `x0`, whereas `w3` indicates a 32-bit value stored in component
    register `w3`. The operand `[x0]` indicates that the value inside `x0` should
    be treated as an address, and to dereference (look up) the value at that address.
    Therefore, the operand `[x0]` corresponds to *(0x804) or the value 0xCA. An operation
    on a 32-bit register can be combined with a 64-bit register using the sign-extend
    word (`SXTW`) instruction. So, `[x0, w3, SXTW]` sign extends `w3` into a 64-bit
    value before adding it to `x0` and performing a memory lookup. Lastly, scaled
    memory types enable the calculation of offsets through the use of a left shift.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 在[表9-1](ch09.xhtml#ch9tab1)中，符号`x0`表示存储在64位寄存器`x0`中的值，而`w3`表示存储在32位寄存器`w3`中的值。操作数`[x0]`表示应将`x0`中的值视为地址，并对该地址进行解引用（查找）。因此，操作数`[x0]`对应于*(0x804)或值0xCA。32位寄存器上的操作可以与64位寄存器结合使用符号扩展字（`SXTW`）指令。因此，`[x0,
    w3, SXTW]`在将`w3`符号扩展为64位值后，将其加到`x0`上并进行内存查找。最后，缩放内存类型通过使用左移来计算偏移量。
- en: A few important notes before continuing. Although [Table 9-1](ch09.xhtml#ch9tab1)
    shows many valid operand forms, not all forms can be used interchangeably in all
    circumstances.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 在继续之前有几点重要说明。虽然[表9-1](ch09.xhtml#ch9tab1)展示了许多有效的操作数形式，但并非所有形式在所有情况下都可以互换使用。
- en: 'Specifically:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 具体而言：
- en: Data cannot be read or written to memory directly; instead, ARM follows a load/store
    model, which requires data to be operated on in registers. Thus, data must be
    transferred to registers before being operated on, and transferred back to memory
    after the operations are complete.
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数据不能直接读取或写入内存；相反，ARM遵循加载/存储模型，需要在寄存器中操作数据。因此，数据必须先转移到寄存器中进行操作，操作完成后再转移回内存。
- en: The destination component of an instruction must always be a register.
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 指令的目标组件必须始终是寄存器。
- en: '[Table 9-1](ch09.xhtml#ch9tab1) is provided as a reference; however, understanding
    key operand forms will help improve the reader’s speed in parsing assembly language.'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: '[表9-1](ch09.xhtml#ch9tab1)作为参考，但理解关键操作数形式将帮助读者提高解析汇编语言的速度。'
- en: 9.2 Common Instructions
  id: totrans-73
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 9.2 常见指令
- en: In this section, we discuss several common ARM assembly instructions. [Table
    9-2](ch09.xhtml#ch9tab2) lists the most foundational instructions in ARM assembly.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一节中，我们讨论了几条常见的ARM汇编指令。[表9-2](ch09.xhtml#ch9tab2)列出了ARM汇编中最基础的指令。
- en: '**Table 9-2:** Most Common Instructions'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: '**表9-2：** 最常见的指令'
- en: '| **Instruction** | **Translation** |  |'
  id: totrans-76
  prefs: []
  type: TYPE_TB
  zh: '| **指令** | **翻译** |  |'
- en: '| `ldr D, [addr]` | D = *(addr) | (loads the value in memory into register
    D) |'
  id: totrans-77
  prefs: []
  type: TYPE_TB
  zh: '| `ldr D, [addr]` | D = *(addr) | （将内存中的值加载到寄存器D中） |'
- en: '| `str S, [addr]` | *(addr) = S | (stores S into memory location *(addr)) |'
  id: totrans-78
  prefs: []
  type: TYPE_TB
  zh: '| `str S, [addr]` | *(addr) = S | （将S存储到内存位置*(addr)） |'
- en: '| `mov D, S` | D = S | (copies value of S into D) |'
  id: totrans-79
  prefs: []
  type: TYPE_TB
  zh: '| `mov D, S` | D = S | （将S的值复制到D中） |'
- en: '| `add D, O1, O2` | D = O1 + O2 | (adds O1 to O2 and stores result in D) |'
  id: totrans-80
  prefs: []
  type: TYPE_TB
  zh: '| `add D, O1, O2` | D = O1 + O2 | （将O1加到O2并将结果存储到D中） |'
- en: '| `sub D, O1, O2` | D = O1 – O2 | (subtracts O2 from O1 and stores result in
    D) |'
  id: totrans-81
  prefs: []
  type: TYPE_TB
  zh: '| `sub D, O1, O2` | D = O1 – O2 | （将O2从O1中减去并将结果存储到D中） |'
- en: Therefore, the sequence of instructions
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，指令的顺序
- en: '[PRE6]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'translates to:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 转换为：
- en: Store the value in register `w0` in the *memory* location specified by `sp`
    + 12 (or `*(sp + 12)`).
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将寄存器`w0`中的值存储到由`sp` + 12指定的*内存*位置（或`*(sp + 12)`）。
- en: Load the value *from* memory location `sp` + 12 (or `*(sp + 12)`) into register
    `w0`.
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从内存位置`sp` + 12（或`*(sp + 12)`）加载值到寄存器`w0`中。
- en: Add the value 0x2 to register `w0`, and store the result in register `w0` (or
    `w0` = `w0` + 0x2).
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将值0x2加到寄存器`w0`，并将结果存储回寄存器`w0`（或`w0` = `w0` + 0x2）。
- en: The `add` and `sub` instructions shown in [Table 9-2](ch09.xhtml#ch9tab2) also
    assist with maintaining the organization of the program stack (i.e., the *call
    stack*). Recall that the *stack pointer* (`sp`) is reserved by the compiler for
    call stack management. Recall also from our earlier discussion on program memory
    in “Parts of Program Memory and Scope” on [page 64](ch02.xhtml#lev1_9) that the
    call stack typically stores local variables and parameters and helps the program
    track its own execution (see [Figure 9-2](ch09.xhtml#ch9fig2)). On ARM systems,
    the execution stack grows toward *lower* addresses. Like all stack data structures,
    operations occur at the “top” of the call stack; `sp` therefore “points” to the
    top of the stack, and its value is the address of top of the stack.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: '[表9-2](ch09.xhtml#ch9tab2)中显示的`add`和`sub`指令也有助于维护程序栈的组织（即*调用栈*）。回想一下，*栈指针*（`sp`）是编译器为调用栈管理保留的。从我们之前在“程序内存和作用域”中关于程序内存的讨论中回忆，调用栈通常存储局部变量和参数，并帮助程序追踪自己的执行（参见[图9-2](ch09.xhtml#ch9fig2)）。在ARM系统中，执行栈朝着*较低*的地址增长。像所有栈数据结构一样，操作发生在调用栈的“顶部”；因此，`sp`“指向”栈的顶部，它的值是栈顶部的地址。'
- en: '![image](../images/09fig02.jpg)'
  id: totrans-89
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/09fig02.jpg)'
- en: '*Figure 9-2: The parts of a program’s address space*'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: '*图9-2：程序地址空间的各个部分*'
- en: The `ldp` and `stp` instructions shown in [Table 9-3](ch09.xhtml#ch9tab3) assist
    with moving multiple memory locations, usually either on or off the program stack.
    As shown in [Table 9-3](ch09.xhtml#ch9tab3), the register `x0` holds a memory
    address.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: '[表9-3](ch09.xhtml#ch9tab3)中显示的`ldp`和`stp`指令有助于移动多个内存位置，通常是在程序栈上或栈外。如[表9-3](ch09.xhtml#ch9tab3)所示，寄存器`x0`保存一个内存地址。'
- en: '**Table 9-3:** Some Instructions for Accessing Multiple Memory Locations'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: '**表9-3：** 一些访问多个内存位置的指令'
- en: '| **Instruction** | **Translation** |'
  id: totrans-93
  prefs: []
  type: TYPE_TB
  zh: '| **指令** | **翻译** |'
- en: '| `ldp D1, D2, [x0]` | D1 = *(x0), D2 = *(x0+8) (loads the value at x0 and
    |'
  id: totrans-94
  prefs: []
  type: TYPE_TB
  zh: '| `ldp D1, D2, [x0]` | D1 = *(x0), D2 = *(x0+8)（加载x0处的值，|'
- en: '|  | X0+8 into registers D1 and D2, respectively) |'
  id: totrans-95
  prefs: []
  type: TYPE_TB
  zh: '|  | 将X0+8的值分别加载到寄存器D1和D2中） |'
- en: '| `ldp D1, D2, [x0, #0x10]!` | x0 = x0 + 0x10, then sets D1 = *(x0), D2 = *(x0+8)
    |'
  id: totrans-96
  prefs: []
  type: TYPE_TB
  zh: '| `ldp D1, D2, [x0, #0x10]!` | x0 = x0 + 0x10，然后设置D1 = *(x0)，D2 = *(x0+8) |'
- en: '| `ldp D1, D2, [x0], #0x10` | D1 = *(x0), D2 = *(x0+8), then sets x0 = x0 +
    0x10 |'
  id: totrans-97
  prefs: []
  type: TYPE_TB
  zh: '| `ldp D1, D2, [x0], #0x10` | D1 = *(x0), D2 = *(x0+8)，然后设置 x0 = x0 + 0x10
    |'
- en: '| `stp S1, S2, [x0]` | *(x0) = S1, *(x0+8) = S2 (stores S1 and S2 at |'
  id: totrans-98
  prefs: []
  type: TYPE_TB
  zh: '| `stp S1, S2, [x0]` | *(x0) = S1, *(x0+8) = S2 (将 S1 和 S2 存储到 |'
- en: '|  | locations *(x0) and *(x0+8), respectively) |'
  id: totrans-99
  prefs: []
  type: TYPE_TB
  zh: '|  | 存储位置 *(x0) 和 *(x0+8)，分别为 |'
- en: '| `stp S1, S2, [x0, #-16]!` | sets x0 = x0 – 16, then stores *(x0) = S1, *(x0+8)
    = S2 |'
  id: totrans-100
  prefs: []
  type: TYPE_TB
  zh: '| `stp S1, S2, [x0, #-16]!` | 设置 x0 = x0 - 16，然后存储 *(x0) = S1, *(x0+8) = S2
    |'
- en: '| `stp S1, S2, [x0], #-16` | stores *(x0) = S1, *(x0+8) = S2 then sets x0 =
    x0 – 16 |'
  id: totrans-101
  prefs: []
  type: TYPE_TB
  zh: '| `stp S1, S2, [x0], #-16` | 存储 *(x0) = S1, *(x0+8) = S2，然后设置 x0 = x0 - 16
    |'
- en: In short, the `ldp` instruction loads a pair of values from the memory locations
    held in register `x0` and at an offset of eight from that memory location (i.e.,
    `x0`+0x8) into the destination registers D1 and D2, respectively. Meanwhile, the
    `stp` instruction stores the pair of values in source registers S1 and S2 to the
    memory locations held in register `x0` and at an offset of eight from that address
    (i.e., `x0`+0x8). Note that the assumption here is that the values in the registers
    are 64-bit quantities. If 32-bit registers are being used instead, the memory
    offsets change to `x0` and `x0`+0x4, respectively.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 简而言之，`ldp` 指令从寄存器 `x0` 所持有的内存位置及该内存位置偏移8字节（即 `x0`+0x8）处加载一对值到目标寄存器 D1 和 D2 中。与此同时，`stp`
    指令将源寄存器 S1 和 S2 中的一对值存储到寄存器 `x0` 所持有的内存位置及该地址偏移8字节（即 `x0`+0x8）处。请注意，这里假设寄存器中的值是64位数。如果使用的是32位寄存器，则内存偏移会变为
    `x0` 和 `x0`+0x4。
- en: 'There are also two special forms of the `ldp` and `stp` instructions that enable
    simultaneous updates to `x0`. For example, the instruction `stp S1, S2, [x0,`
    `#-16]!` implies that 16 bytes should *first* be subtracted from `x0`, and only
    afterward should S1 and S2 be stored at the offsets `[x0]` and `[x0+8]`. In contrast,
    the instruction `ldp D1, D2, [x0], #0x10` states that the values at offsets `[x0]`
    and `[x0+8]` should first be stored in destination registers D1 and D2, and *only
    afterward* should `x0` have 16 bytes added to it. These special forms are commonly
    used at the beginning and end of functions that have multiple function calls,
    as we will see later.'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: '`ldp` 和 `stp` 指令还有两种特殊形式，可以同时更新 `x0`。例如，指令 `stp S1, S2, [x0, #-16]!` 表示应该*首先*从
    `x0` 中减去16字节，然后才将 S1 和 S2 存储到偏移量 `[x0]` 和 `[x0+8]` 处。相比之下，指令 `ldp D1, D2, [x0],
    #0x10` 表示应该首先将偏移量 `[x0]` 和 `[x0+8]` 处的值存储到目标寄存器 D1 和 D2 中，*然后*再将 `x0` 增加16字节。这些特殊形式通常用于具有多个函数调用的函数的开始和结束部分，稍后我们会看到这一点。'
- en: '9.2.1 Putting It All Together: A More Concrete Example'
  id: totrans-104
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 9.2.1 综合实例：一个更具体的例子
- en: Let’s take a closer look at the `adder2` function
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更详细地看看 `adder2` 函数
- en: '[PRE7]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'and its corresponding assembly code:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 以及其对应的汇编代码：
- en: '[PRE8]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The assembly code consists of a `sub` instruction, followed by `str` and `ldr`
    instructions, two `add` instructions, and finally a `ret` instruction. To understand
    how the CPU executes this set of instructions, we need to revisit the structure
    of program memory (see “Parts of Program Memory and Scope” on [page 64](ch02.xhtml#lev1_9)).
    Recall that every time a program executes, the operating system allocates the
    new program’s address space (also known as *virtual memory*). Virtual memory and
    the related concept of processes are covered in greater detail in [Chapter 13](ch13.xhtml#ch13);
    for now, it suffices to think of a process as the abstraction of a running program
    and virtual memory as the memory that is allocated to a single process. Every
    process has its own region of memory called the *call stack*. Keep in mind that
    the call stack is located in process/virtual memory, unlike registers (which are
    located in the CPU).
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 汇编代码由一个 `sub` 指令、接着是 `str` 和 `ldr` 指令、两个 `add` 指令，最后是一个 `ret` 指令组成。为了理解 CPU
    如何执行这一组指令，我们需要回顾程序内存的结构（参见 [第64页](ch02.xhtml#lev1_9)中的“程序内存和作用域”）。回想一下，每当程序执行时，操作系统会为新程序分配地址空间（也叫做
    *虚拟内存*）。虚拟内存和相关的进程概念在 [第13章](ch13.xhtml#ch13)中有更详细的讨论；现在，理解一个进程就是运行中的程序的抽象，虚拟内存就是为单个进程分配的内存就足够了。每个进程都有自己的一块内存区域，称为
    *调用栈*。请记住，调用栈位于进程/虚拟内存中，而寄存器则位于 CPU 中。
- en: '[Figure 9-3](ch09.xhtml#ch9fig3) depicts a sample state of the call stack and
    registers prior to the execution of the `adder2` function.'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 9-3](ch09.xhtml#ch9fig3) 显示了在执行 `adder2` 函数之前调用栈和寄存器的示例状态。'
- en: '![image](../images/09fig03.jpg)'
  id: totrans-111
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/09fig03.jpg)'
- en: '*Figure 9-3: Execution stack prior to execution*'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 9-3：执行栈在执行之前的状态*'
- en: Notice that the stack grows toward *lower* addresses. The parameter to the `adder2`
    function (or `a`) is stored in register `x0` by convention. Since `a` is of type
    `int`, it is stored in component register `w0`, as shown in [Figure 9-3](ch09.xhtml#ch9fig3).
    Likewise, since the `adder2` function returns an `int`, component register `w0`
    is used for the return value instead of `x0`.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，栈是向*较低*地址生长的。`adder2`函数的参数（或`a`）通常由寄存器`x0`存储。由于`a`是`int`类型，它被存储在组件寄存器`w0`中，如[图9-3](ch09.xhtml#ch9fig3)所示。同样，由于`adder2`函数返回一个`int`，因此返回值使用组件寄存器`w0`而不是`x0`。
- en: The addresses associated with the instructions in the code segment of program
    memory have been shortened to 0x724–0x738 to improve figure readability. Likewise,
    the addresses associated with the call stack segment of program memory have been
    shortened to 0xe40–0xe50 from 0xffffffffee40–0xffffffffee50\. In truth, call stack
    addresses occur at much higher addresses in program memory than code segment addresses.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 程序内存代码段中的指令地址已缩短为0x724–0x738，以提高图示的可读性。同样，程序内存中调用栈段的地址已从0xffffffffee40–0xffffffffee50缩短为0xe40–0xe50。实际上，调用栈地址通常出现在比代码段地址高得多的程序内存地址中。
- en: 'Pay close attention to the initial values of registers `sp` and `pc`: they
    are 0xe50 and 0x724, respectively. The `pc` register (or program counter) indicates
    the next instruction to execute, and the address 0x724 corresponds to the first
    instruction in the `adder2` function. The upper-left arrow in the following figures
    visually indicates the currently executing instruction.'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意寄存器`sp`和`pc`的初始值：分别是0xe50和0x724。`pc`寄存器（或程序计数器）指示下一条要执行的指令，地址0x724对应`adder2`函数中的第一条指令。下图中的左上箭头直观地表示当前正在执行的指令。
- en: '![image](../images/f0470-01.jpg)'
  id: totrans-116
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f0470-01.jpg)'
- en: 'The first instruction (`sub sp, sp, #0x10`) subtracts the constant value 0x10
    from the stack pointer, and updates the stack pointer with the new result. Since
    the stack pointer contains the address of the top of the stack, this operation
    *grows* the stack by 16 bytes. The stack pointer now contains the address 0xe40,
    whereas the program counter (`pc`) register contains the address of the next instruction
    to execute, or 0x728.'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: '第一条指令（`sub sp, sp, #0x10`）将常数值0x10从栈指针中减去，并用新结果更新栈指针。由于栈指针包含栈顶的地址，这个操作*扩展*了栈，增加了16个字节。栈指针现在包含地址0xe40，而程序计数器（`pc`）寄存器包含下一条要执行的指令的地址，即0x728。'
- en: '![image](../images/f0471-01.jpg)'
  id: totrans-118
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f0471-01.jpg)'
- en: 'Recall that the `str` instruction *stores* a value located in a register into
    memory. Thus, the next instruction (`str w0, [sp, #12]`) places the value in `w0`
    (the value of `a`, or 0x28) at call stack location `sp` + 12, or 0xe4c. Note that
    this instruction does not modify the contents of register `sp` in any way; it
    simply stores a value on the call stack. Once this instruction executes, `pc`
    advances to the address of the next instruction, or 0x72c.'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: '回想一下，`str`指令*存储*寄存器中的值到内存中。因此，下一条指令（`str w0, [sp, #12]`）将寄存器`w0`中的值（即`a`的值，0x28）存储到调用栈位置`sp`
    + 12，即0xe4c。请注意，这条指令不会以任何方式修改`sp`寄存器的内容；它只是将一个值存储到调用栈中。一旦这条指令执行完毕，`pc`会推进到下一条指令的地址，即0x72c。'
- en: '![image](../images/f0471-02.jpg)'
  id: totrans-120
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f0471-02.jpg)'
- en: 'Next, `ldr w0, [sp, #12]` executes. Recall that the `ldr` instruction *loads*
    a value in memory into a register. By executing this instruction, the CPU replaces
    the value in register `w0` with the value located at stack address `sp` + 12\.
    Even though this may seem like a nonsensical operation (0x28 is replaced by 0x28,
    after all), it highlights a convention where the compiler typically stores function
    parameters onto the call stack for later use and then reloads them into registers
    as needed. Again, the value stored in the `sp` register is not affected by the
    `str` operation. As far as the program is concerned, the “top” of the stack is
    still 0xe40\. Once the `ldr` instruction executes, `pc` advances to address 0x730.'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: '接下来，执行`ldr w0, [sp, #12]`。回想一下，`ldr`指令*加载*内存中的一个值到寄存器中。通过执行该指令，CPU将寄存器`w0`中的值替换为位于栈地址`sp`
    + 12的值。尽管这看起来像是一个没有意义的操作（毕竟0x28被替换为0x28），但它突出了一个约定，即编译器通常会将函数参数存储到调用栈中以备后用，然后根据需要将它们重新加载到寄存器中。再说一次，`sp`寄存器中存储的值不受`str`操作的影响。就程序而言，“栈顶”仍然是0xe40。一旦`ldr`指令执行，`pc`会推进到地址0x730。'
- en: '![image](../images/f0472-01.jpg)'
  id: totrans-122
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f0472-01.jpg)'
- en: 'Afterward, `add w0, w0, #0x2` executes. Recall that the `add` instruction has
    the form `add D, O1, O2` and places O1 + O2 in the destination register D. So,
    `add w0, w0, #0x2` adds the constant value 0x2 to the value stored in `w0` (0x28),
    resulting in 0x2A being stored in register `w0`. Register `pc` advances to the
    next instruction to be executed, or 0x734.'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: '随后执行 `add w0, w0, #0x2`。回想一下，`add` 指令的形式是 `add D, O1, O2`，并将 O1 + O2 的结果存储在目标寄存器
    D 中。因此，`add w0, w0, #0x2` 将常量值 0x2 加到存储在 `w0` 中的值（0x28），结果是 0x2A 被存储在寄存器 `w0`
    中。接着，`pc` 寄存器将前进到下一个指令地址 0x734。'
- en: '![image](../images/f0472-02.jpg)'
  id: totrans-124
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f0472-02.jpg)'
- en: 'The next instruction that executes is `add sp, sp, #0x10`. This instruction
    adds 16 bytes to the address stored in `sp`. Since the stack grows toward lower
    addresses, adding 16 bytes to the stack pointer consequently *shrinks* the stack,
    and reverts `sp` to its original value of 0xe50\. The `pc` register then advances
    to 0x738.'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: '下一条执行的指令是 `add sp, sp, #0x10`。此指令将 16 字节加到存储在 `sp` 中的地址上。由于栈是向低地址增长的，因此向栈指针添加
    16 字节会导致栈“收缩”，并将 `sp` 恢复到其原始值 0xe50。然后，`pc` 寄存器将前进到 0x738。'
- en: 'Recall that the purpose of the call stack is to store the temporary data that
    each function uses as it executes in the context of a larger program. By convention,
    the stack “grows” at the beginning of a function call, and reverts to its original
    state when the function ends. As a result, it is common to see a `sub sp, sp,
    #v` instruction (where `v` is some constant value) at the beginning of a function,
    and `add sp, sp, #v` at the end.'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: '回想一下，调用栈的目的是存储每个函数在更大程序上下文中执行时所使用的临时数据。根据约定，栈在函数调用开始时“增长”，并在函数结束时恢复到原始状态。因此，在函数开始时，通常会看到
    `sub sp, sp, #v` 指令（其中 `v` 是某个常量值），函数结束时会看到 `add sp, sp, #v` 指令。'
- en: '![image](../images/f0473-01.jpg)'
  id: totrans-127
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f0473-01.jpg)'
- en: The last instruction that executes is `ret`. We will talk more about what `ret`
    does in future sections when we discuss function calls, but for now it suffices
    to know that `ret` prepares the call stack for returning from a function. By convention,
    the register `x0` always contains the return value (if one exists). In this case,
    since `adder2` is of type `int`, the return value is stored in component register
    `w0` and the function returns the value 0x2A, or 42.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 最后执行的指令是 `ret`。我们将在未来的章节中讨论 `ret` 的作用，特别是关于函数调用的部分，但目前只需要知道 `ret` 为从函数返回准备调用栈。根据约定，寄存器
    `x0` 总是包含返回值（如果存在）。在这种情况下，由于 `adder2` 是 `int` 类型，返回值被存储在组件寄存器 `w0` 中，函数返回值为 0x2A，即
    42。
- en: 9.3 Arithmetic Instructions
  id: totrans-129
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 9.3 算术指令
- en: 9.3.1 Common Arithmetic Instructions
  id: totrans-130
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 9.3.1 常见的算术指令
- en: The A64 ISA implements several instructions that correspond to arithmetic operations
    performed by the ALU. [Table 9-4](ch09.xhtml#ch9tab4) lists several arithmetic
    instructions that one may encounter when reading ARM assembly.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: A64 ISA 实现了多个与 ALU 执行的算术操作相对应的指令。[表 9-4](ch09.xhtml#ch9tab4)列出了在阅读 ARM 汇编时可能遇到的几条算术指令。
- en: '**Table 9-4:** Common Instructions'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: '**表 9-4：** 常见指令'
- en: '| **Instruction** | **Translation** |'
  id: totrans-133
  prefs: []
  type: TYPE_TB
  zh: '| **指令** | **翻译** |'
- en: '| `add D, O1, O2` | D = O1 + O2 |'
  id: totrans-134
  prefs: []
  type: TYPE_TB
  zh: '| `add D, O1, O2` | D = O1 + O2 |'
- en: '| `sub D, O1, O2` | D = O1 – O2 |'
  id: totrans-135
  prefs: []
  type: TYPE_TB
  zh: '| `sub D, O1, O2` | D = O1 – O2 |'
- en: '| `neg D, O1` | D = –(O1) |'
  id: totrans-136
  prefs: []
  type: TYPE_TB
  zh: '| `neg D, O1` | D = –(O1) |'
- en: The `add` and `sub` instructions correspond to addition and subtraction and
    require two operands in addition to the destination register. In contrast, the
    `neg` instruction requires only one operand in addition to the destination register.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: '`add` 和 `sub` 指令分别对应加法和减法，并且需要两个操作数和一个目标寄存器。相比之下，`neg` 指令只需要一个操作数和一个目标寄存器。'
- en: The three instructions in [Table 9-4](ch09.xhtml#ch9tab4) also have *carry*
    forms that enable the instruction to use the optional carry condition flag, `C`.
    The one-bit carry flag is set when an unsigned operation overflows. We cover other
    condition control flags in the following section, but describe the carry flag
    here to introduce the additional arithmetic instructions. The carry forms and
    their rough translation are shown in [Table 9-5](ch09.xhtml#ch9tab5).
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: '[表 9-4](ch09.xhtml#ch9tab4)中的三条指令也有 *进位* 形式，使得指令能够使用可选的进位条件标志 `C`。当无符号运算发生溢出时，单比特进位标志会被设置。我们将在接下来的章节中讨论其他条件控制标志，但在这里先描述进位标志，以介绍额外的算术指令。进位形式及其大致翻译见[表
    9-5](ch09.xhtml#ch9tab5)。'
- en: '**Table 9-5:** Carry Forms for Common Instructions'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: '**表 9-5：** 常见指令的进位形式'
- en: '| **Instruction** | **Translation** |'
  id: totrans-140
  prefs: []
  type: TYPE_TB
  zh: '| **指令** | **翻译** |'
- en: '| `adc D, O1, O2` | D = O1 + O2 + `C` |'
  id: totrans-141
  prefs: []
  type: TYPE_TB
  zh: '| `adc D, O1, O2` | D = O1 + O2 + `C` |'
- en: '| `sbc D, O1, O2` | D = O1 – O2 – `~C` |'
  id: totrans-142
  prefs: []
  type: TYPE_TB
  zh: '| `sbc D, O1, O2` | D = O1 – O2 – `~C` |'
- en: '| `ngc D, O1` | D = –(O1) – `~C` |'
  id: totrans-143
  prefs: []
  type: TYPE_TB
  zh: '| `ngc D, O1` | D = –(O1) – `~C` |'
- en: The preceding instructions also have an optional `s` suffix. When the `s` suffix
    is used (e.g., `adds`), it indicates that the arithmetic operation is setting
    condition flags.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 上述指令也有一个可选的`s`后缀。当使用`s`后缀时（例如`adds`），表示该算术操作会设置条件标志。
- en: 9.3.1.1 Multiplication and Division
  id: totrans-145
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 9.3.1.1 乘法与除法
- en: '**Table 9-6:** Common Multiplication and Division Instructions'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: '**表9-6：** 常见的乘法和除法指令'
- en: '| **Instruction** | **Translation** |'
  id: totrans-147
  prefs: []
  type: TYPE_TB
  zh: '| **指令** | **翻译** |'
- en: '| `mul D, O1, O2` | D = O1 × O2 |'
  id: totrans-148
  prefs: []
  type: TYPE_TB
  zh: '| `mul D, O1, O2` | D = O1 × O2 |'
- en: '| `udiv D, O1, O2` | D = O1 / O2 (32-bit unsigned) |'
  id: totrans-149
  prefs: []
  type: TYPE_TB
  zh: '| `udiv D, O1, O2` | D = O1 / O2（32位无符号） |'
- en: '| `sdiv D, O1, O2` | D = O1 / O2 (64-bit signed) |'
  id: totrans-150
  prefs: []
  type: TYPE_TB
  zh: '| `sdiv D, O1, O2` | D = O1 / O2（64位有符号） |'
- en: The most common multiplication and division instructions are shown in [Table
    9-6](ch09.xhtml#ch9tab6). The `mul` instruction operates on two operands and places
    the product in the destination D. The division operation does *not* have a generic
    form; the `udiv` and `sdiv` instructions operate on 32-bit and 64-bit data, respectively.
    Note that you cannot multiply 32-bit registers with 64-bit registers.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 最常见的乘法和除法指令见[表9-6](ch09.xhtml#ch9tab6)。`mul`指令操作两个操作数，并将结果存储在目标D中。除法操作没有通用形式；`udiv`和`sdiv`指令分别操作32位和64位数据。注意，不能将32位寄存器与64位寄存器相乘。
- en: In addition, ARMv8-A provides composite forms for multiplication, allowing the
    CPU to perform more sophisticated operations in a single instruction. These instructions
    are shown in [Table 9-7](ch09.xhtml#ch9tab7).
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，ARMv8-A提供了复合形式的乘法，允许CPU在一条指令中执行更复杂的操作。这些指令见[表9-7](ch09.xhtml#ch9tab7)。
- en: '**Table 9-7:** Composite Multiplication Instructions'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: '**表9-7：** 复合乘法指令'
- en: '| **Instruction** | **Translation** |'
  id: totrans-154
  prefs: []
  type: TYPE_TB
  zh: '| **指令** | **翻译** |'
- en: '| `madd D, O1, O2, O3` | D = O3 + (O1 × O2) |'
  id: totrans-155
  prefs: []
  type: TYPE_TB
  zh: '| `madd D, O1, O2, O3` | D = O3 + (O1 × O2) |'
- en: '| `msub D, O1, O2, O3` | D = O3 – (O1 × O2) |'
  id: totrans-156
  prefs: []
  type: TYPE_TB
  zh: '| `msub D, O1, O2, O3` | D = O3 – (O1 × O2) |'
- en: '| `mneg D, O1, O2` | D = –(O1 × S2) |'
  id: totrans-157
  prefs: []
  type: TYPE_TB
  zh: '| `mneg D, O1, O2` | D = –(O1 × S2) |'
- en: 9.3.2 Bit Shifting Instructions
  id: totrans-158
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 9.3.2 位移指令
- en: Bit shifting instructions enable the compiler to perform bit shifting operations.
    Multiplication and division instructions typically take a long time to execute.
    Bit shifting offers the compiler a shortcut for multiplicands and divisors that
    are powers of 2\. For example, to compute `77 * 4`, most compilers will translate
    this operation to `77 ≪ 2` to avoid the use of a `mul` instruction. Likewise,
    to compute `77 / 4`, a compiler typically translates this operation to `77 ≫ 2`
    to avoid using the `sdiv` instruction.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 位移指令使编译器能够执行位移操作。乘法和除法指令通常需要较长时间执行。位移提供了编译器的快捷方式，用于乘数和除数是2的幂的情况。例如，计算`77 * 4`时，大多数编译器会将该操作转换为`77
    ≪ 2`，以避免使用`mul`指令。同样地，计算`77 / 4`时，编译器通常会将该操作转换为`77 ≫ 2`，以避免使用`sdiv`指令。
- en: Keep in mind that left and right bit shifts translate to different instructions
    based on whether the goal is an arithmetic (signed) or logical (unsigned) shift.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，左移和右移指令会根据目标是算术（有符号）移位还是逻辑（无符号）移位，翻译成不同的指令。
- en: '**Table 9-8:** Bit Shift Instructions'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: '**表9-8：** 位移指令'
- en: '| **Instruction** | **Translation** | **Arithmetic or logical?** |'
  id: totrans-162
  prefs: []
  type: TYPE_TB
  zh: '| **指令** | **翻译** | **算术或逻辑？** |'
- en: '| `lsl D, R, #v` | D = R `≪` v | logical or arithmetic |'
  id: totrans-163
  prefs: []
  type: TYPE_TB
  zh: '| `lsl D, R, #v` | D = R `≪` v | 逻辑或算术 |'
- en: '| `lsr D, R, #v` | D = R `≫` v | logical |'
  id: totrans-164
  prefs: []
  type: TYPE_TB
  zh: '| `lsr D, R, #v` | D = R `≫` v | 逻辑 |'
- en: '| `asr D, R, #v` | D = R `≫` v | arithmetic |'
  id: totrans-165
  prefs: []
  type: TYPE_TB
  zh: '| `asr D, R, #v` | D = R `≫` v | 算术 |'
- en: '| `ror D, R, #v` | D = R `≫>` v | neither (rotate) |'
  id: totrans-166
  prefs: []
  type: TYPE_TB
  zh: '| `ror D, R, #v` | D = R `≫>` v | 两者都不是（旋转） |'
- en: In addition to the destination register, each shift instruction takes two operands;
    one is usually a register (denoted by R) and the other is a 6-bit shift value
    (v). On 64-bit systems, the shift value is encoded as a single byte (since it
    doesn’t make sense to shift past 63). The shift value v must either be a constant
    or stored in a component register.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 除了目标寄存器，每条移位指令需要两个操作数；一个通常是寄存器（用R表示），另一个是6位的移位值（v）。在64位系统上，移位值被编码为一个字节（因为移位超过63没有意义）。移位值v必须是常数或存储在一个组件寄存器中。
- en: The last bit shifting instruction, `ror`, requires special discussion. The `ror`
    instruction *rotates* the bits, replacing the most significant bits with the least
    significant bits. We represent the rotate shift instruction using the `≫>` symbol.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一条移位指令`ror`需要特别说明。`ror`指令*旋转*位数，将最高有效位替换为最低有效位。我们使用`≫>`符号来表示旋转移位指令。
- en: '**Note DIFFERENT VERSIONS OF INSTRUCTIONS HELP US DISTINGUISH TYPES AT AN ASSEMBLY
    LEVEL**'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意 不同版本的指令帮助我们在汇编级别区分类型**'
- en: At the assembly level, there is no notion of types. However, recall that the
    compiler can choose to use component registers based on the types present at the
    code level. Similarly, recall that shift right works differently depending on
    whether the value is signed or unsigned. At the assembly level, the compiler uses
    separate instructions to distinguish between logical and arithmetic shifts!
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 在汇编级别，没有类型的概念。然而，回想一下，编译器可以根据代码级别存在的类型选择使用组件寄存器。类似地，回想一下，右移操作的执行方式取决于值是有符号还是无符号。在汇编级别，编译器使用不同的指令来区分逻辑移位和算术移位！
- en: 9.3.3 Bitwise Instructions
  id: totrans-171
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 9.3.3 按位指令
- en: Bitwise instructions enable the compiler to perform bitwise operations on data.
    One way in which the compiler uses bitwise operations is for certain optimizations.
    For example, a compiler may choose to implement 77 mod 4 with the operation `77
    & 3` in lieu of the more expensive `sdiv` instruction.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 按位指令使得编译器能够对数据执行按位操作。编译器使用按位操作的一个方式是进行某些优化。例如，编译器可能选择用`77 & 3`代替开销更大的`sdiv`指令来实现77模4。
- en: '[Table 9-9](ch09.xhtml#ch9tab9) lists common bitwise instructions, and composite
    bitwise instructions that utilize negation.'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: '[表9-9](ch09.xhtml#ch9tab9)列出了常见的按位指令，以及利用否定的复合按位指令。'
- en: '**Table 9-9:** Bitwise Operations'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: '**表9-9：** 按位操作'
- en: '| **Instruction** | **Translation** |'
  id: totrans-175
  prefs: []
  type: TYPE_TB
  zh: '| **指令** | **翻译** |'
- en: '| `and D, O1, O2` | D = O1 `&` O2 |'
  id: totrans-176
  prefs: []
  type: TYPE_TB
  zh: '| `and D, O1, O2` | D = O1 `&` O2 |'
- en: '| `orr D, O1, O2` | D = O1 `&#124;` O2 |'
  id: totrans-177
  prefs: []
  type: TYPE_TB
  zh: '| `orr D, O1, O2` | D = O1 `&#124;` O2 |'
- en: '| `eor D, O1, O2` | D = O1 `^` O2 |'
  id: totrans-178
  prefs: []
  type: TYPE_TB
  zh: '| `eor D, O1, O2` | D = O1 `^` O2 |'
- en: '| `mvn D, O` | D = `~`O |'
  id: totrans-179
  prefs: []
  type: TYPE_TB
  zh: '| `mvn D, O` | D = `~`O |'
- en: '| `bic D, O1, O2` | D = O1 `& ~`O2 |'
  id: totrans-180
  prefs: []
  type: TYPE_TB
  zh: '| `bic D, O1, O2` | D = O1 `& ~`O2 |'
- en: '| `orn D, O1, O2` | D = O1 `&#124; ~`O2 |'
  id: totrans-181
  prefs: []
  type: TYPE_TB
  zh: '| `orn D, O1, O2` | D = O1 `&#124; ~`O2 |'
- en: '| `eon D, O1, O2` | D = O1 `^ ~`O2 |'
  id: totrans-182
  prefs: []
  type: TYPE_TB
  zh: '| `eon D, O1, O2` | D = O1 `^ ~`O2 |'
- en: Remember that bitwise `not` is distinct from negation (`neg`). The `mvn` instruction
    flips the bits of the operand but does not add 1\. Be careful not to confuse these
    two instructions.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，按位`not`与取反（`neg`）不同。`mvn`指令翻转操作数的位，但不加1。要小心不要混淆这两条指令。
- en: '**Warning USE BITWISE OPERATIONS ONLY WHEN NEEDED IN YOUR C CODE!**'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: '**警告 仅在你的C代码中需要时使用按位操作！**'
- en: After reading this section, it may be tempting to replace common arithmetic
    operations in your C code with bitwise shifts and other operations. This is *not*
    recommended. Most modern compilers are smart enough to replace simple arithmetic
    operations with bitwise operations when it makes sense, making it unnecessary
    for the programmer to do so. As a general rule, programmers should prioritize
    code readability whenever possible and avoid premature optimization.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 阅读完本节后，可能会有冲动将你C代码中的常见算术操作替换为按位移位和其他操作。但这*不*推荐。大多数现代编译器足够智能，可以在合适的时候将简单的算术操作替换为按位操作，这样程序员就不需要这么做。一般来说，程序员应尽量优先考虑代码的可读性，避免过早优化。
- en: 9.4 Conditional Control and Loops
  id: totrans-186
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 9.4 条件控制和循环
- en: This section covers assembly instructions for conditionals and loops (see “Conditionals
    and Loops” on [page 30](ch01.xhtml#lev1_3)). Recall that conditional statements
    enable coders to modify program execution based on the result of a conditional
    expression. The compiler translates conditionals into assembly instructions that
    modify the instruction pointer (`pc`) to point to an address that is not the next
    one in the program sequence.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 本节涵盖了用于条件语句和循环的汇编指令（参见[第30页](ch01.xhtml#lev1_3)的“条件语句和循环”）。回想一下，条件语句使得程序员可以根据条件表达式的结果修改程序执行。编译器将条件语句翻译为汇编指令，这些指令修改指令指针（`pc`），使其指向一个不是程序序列中下一个地址的地址。
- en: 9.4.1 Preliminaries
  id: totrans-188
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 9.4.1 基础知识
- en: Conditional Comparison Instructions
  id: totrans-189
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 条件比较指令
- en: Comparison instructions perform an arithmetic operation for the purpose of guiding
    the conditional execution of a program. [Table 9-10](ch09.xhtml#ch9tab10) lists
    the basic instructions associated with conditional control.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 比较指令执行算术操作，目的是引导程序的条件执行。[表9-10](ch09.xhtml#ch9tab10)列出了与条件控制相关的基本指令。
- en: '**Table 9-10:** Conditional Control Instructions'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: '**表9-10：** 条件控制指令'
- en: '| **Instruction** | **Translation** |'
  id: totrans-192
  prefs: []
  type: TYPE_TB
  zh: '| **指令** | **翻译** |'
- en: '| `cmp O1, O2` | Compares O1 with O2 (computes O1 – O2) |'
  id: totrans-193
  prefs: []
  type: TYPE_TB
  zh: '| `cmp O1, O2` | 比较O1与O2（计算 O1 - O2） |'
- en: '| `tst O1, O2` | Computes O1 `&` O2 |'
  id: totrans-194
  prefs: []
  type: TYPE_TB
  zh: '| `tst O1, O2` | 计算 O1 `&` O2 |'
- en: 'The `cmp` instruction compares the value of two operands, O1 and O2\. Specifically,
    it subtracts O2 from O1\. The `tst` instruction performs bitwise AND. It is common
    to see an instruction like:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: '`cmp` 指令比较两个操作数 O1 和 O2 的值。具体来说，它将 O2 从 O1 中减去。`tst` 指令执行按位与操作。通常会看到类似以下的指令：'
- en: '[PRE9]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'In this example, the bitwise AND of `x0` with itself is zero only when `x0`
    contains zero. In other words, this is a test for a zero value and is equivalent
    to the following:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，`x0` 与自身的按位与操作仅在 `x0` 为零时结果为零。换句话说，这是一个零值测试，等同于以下操作：
- en: '[PRE10]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Unlike the arithmetic instructions covered thus far, `cmp` and `tst` do not
    modify a destination register. Instead, both instructions modify a series of single-bit
    values known as *condition code flags*. For example, `cmp` will modify condition
    code flags based on whether the value O1 – O2 results in a positive (greater),
    negative (less), or zero (equal) value. Recall that condition code values encode
    information about an operation in the ALU (see “The ALU” on [page 261](ch05.xhtml#lev2_100)).
    The condition code flags are part of the ARM processor state (`PSTATE`), which
    replaces the current program status register (`CPSR`) from ARMv7-A systems.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 与迄今为止介绍的算术指令不同，`cmp` 和 `tst` 不会修改目标寄存器。相反，这两条指令会修改一系列单比特值，这些值被称为*条件码标志*。例如，`cmp`
    会根据 O1 – O2 的结果是正数（大于）、负数（小于）还是零（相等）来修改条件码标志。请记住，条件码值编码了 ALU 操作的信息（参见 [第261页](ch05.xhtml#lev2_100)
    的“ALU”部分）。条件码标志是 ARM 处理器状态（`PSTATE`）的一部分，取代了 ARMv7-A 系统中的当前程序状态寄存器（`CPSR`）。
- en: '**Table 9-11:** Common Condition Code Flags'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: '**表 9-11：** 常见条件码标志'
- en: '| **Flag** | **Translation** |'
  id: totrans-201
  prefs: []
  type: TYPE_TB
  zh: '| **标志** | **翻译** |'
- en: '| `Z` | Is equal to zero (1: yes; 0: no) |'
  id: totrans-202
  prefs: []
  type: TYPE_TB
  zh: '| `Z` | 等于零（1: 是; 0: 否） |'
- en: '| `N` | Is negative (1: yes; 0: no) |'
  id: totrans-203
  prefs: []
  type: TYPE_TB
  zh: '| `N` | 负数（1: 是; 0: 否） |'
- en: '| `V` | Signed overflow has occurred (1: yes; 0: no) |'
  id: totrans-204
  prefs: []
  type: TYPE_TB
  zh: '| `V` | 发生了带符号溢出（1: 是; 0: 否） |'
- en: '| `C` | Arithmetic carry/unsigned overflow has occurred (1: yes; 0: no) |'
  id: totrans-205
  prefs: []
  type: TYPE_TB
  zh: '| `C` | 算术进位/无符号溢出已发生（1: 是; 0: 否） |'
- en: '[Table 9-11](ch09.xhtml#ch9tab11) depicts the common flags used for condition
    code operations. Revisiting the `cmp O1, O2` instruction:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: '[表 9-11](ch09.xhtml#ch9tab11) 描述了用于条件码操作的常见标志。重新回顾 `cmp O1, O2` 指令：'
- en: The `Z` flag is set to 1 if O1 and O2 are equal.
  id: totrans-207
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果 O1 和 O2 相等，则 `Z` 标志设置为 1。
- en: The `N` flag is set to 1 if O1 is *less* than O2 (O1 – O2 results in a negative
    value).
  id: totrans-208
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果 O1 小于 O2（O1 – O2 结果为负值），则 `N` 标志设置为 1。
- en: The `V` flag is set to 1 if the operation O1 – O2 results in overflow (useful
    for signed comparisons).
  id: totrans-209
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果操作 O1 – O2 结果为溢出，则 `V` 标志设置为 1（对于带符号比较有用）。
- en: The `C` flag is set to 1 if the operation O1 – O2 results in an arithmetic carry
    operation (useful for unsigned comparisons).
  id: totrans-210
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果操作 O1 – O2 结果为算术进位操作（对于无符号比较有用），则 `C` 标志设置为 1。
- en: While an in-depth discussion of condition code flags is beyond the scope of
    this book, the setting of these registers by `cmp` and `tst` enables the next
    set of instructions we cover (the *branch* instructions) to operate correctly.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然对条件码标志的深入讨论超出了本书的范围，但 `cmp` 和 `tst` 指令通过设置这些寄存器，使我们接下来要介绍的指令集（*分支* 指令）能够正确运行。
- en: Branch Instructions
  id: totrans-212
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 分支指令
- en: A branch instruction enables a program’s execution to “jump” to a new position
    in the code. In the assembly programs we have traced through thus far, `pc` always
    points to the next instruction in program memory. The branch instructions enable
    `pc` to be set to either a new instruction not yet seen (as in the case of an
    `if` statement) or to a previously executed instruction (as in the case of a loop).
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 分支指令使程序的执行可以“跳转”到代码中的新位置。在我们迄今为止追踪的汇编程序中，`pc` 总是指向程序内存中的下一条指令。分支指令使得 `pc` 可以被设置为尚未见过的新指令（例如
    `if` 语句的情况），或者是之前执行过的指令（例如循环中的情况）。
- en: '**Table 9-12:** Common Branch Instructions'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: '**表 9-12：** 常见分支指令'
- en: '| **Instruction** | **Description** |'
  id: totrans-215
  prefs: []
  type: TYPE_TB
  zh: '| **指令** | **描述** |'
- en: '| `b addr L` | `pc` = addr |'
  id: totrans-216
  prefs: []
  type: TYPE_TB
  zh: '| `b addr L` | `pc` = addr |'
- en: '| `br A` | `pc` = A |'
  id: totrans-217
  prefs: []
  type: TYPE_TB
  zh: '| `br A` | `pc` = A |'
- en: '| `cbz R, addr L` | If R is equal to 0, `pc` = addr (conditional branch) |'
  id: totrans-218
  prefs: []
  type: TYPE_TB
  zh: '| `cbz R, addr L` | 如果 R 等于 0，`pc` = addr（条件分支） |'
- en: '| `cbnz R, addr L` | If R is not equal to 0, `pc` = addr (conditional branch)
    |'
  id: totrans-219
  prefs: []
  type: TYPE_TB
  zh: '| `cbnz R, addr L` | 如果 R 不等于 0，`pc` = addr（条件分支） |'
- en: '| `b.c addr L` | If c, `pc` = addr (conditional branch) |'
  id: totrans-220
  prefs: []
  type: TYPE_TB
  zh: '| `b.c addr L` | 如果 c，`pc` = addr（条件分支） |'
- en: '**Direct branch instructions**   [Table 9-12](ch09.xhtml#ch9tab12) lists the
    set of common branch instructions; L refers to a *symbolic label*, which serves
    as an identifier in the program’s object file. All labels consist of some letters
    and digits followed by a colon. Labels can be *local* or *global* to an object
    file’s scope. Function labels tend to be *global* and usually consist of the function
    name and a colon. For example, `main:` (or `<main>:`) is used to label a user-defined
    `main` function. In contrast, labels whose scope are *local* are preceded by a
    period. For example, `.L1:` is a label one may encounter in the context of an
    `if` statement or loop.'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: '**直接分支指令** [表 9-12](ch09.xhtml#ch9tab12)列出了常见的分支指令集合；L表示*符号标签*，它作为程序对象文件中的标识符。所有标签由一些字母和数字组成，后跟冒号。标签可以是*局部的*或*全局的*，取决于它在对象文件中的作用范围。函数标签通常是*全局的*，并通常由函数名和冒号组成。例如，`main:`（或`<main>:`）用于标记用户定义的`main`函数。相反，作用域为*局部*的标签前面会加一个句点。例如，`.L1:`是你可能会在`if`语句或循环中遇到的标签。'
- en: All labels have an associated address (`addr` in [Table 9-12](ch09.xhtml#ch9tab12)).
    When the CPU executes a `b` instruction, it sets the `pc` register to `addr`.
    The `b` instruction enables the program counter to change within 128 MB of its
    current location; a programmer writing assembly can also specify a particular
    address to branch to by using the `br` instruction. Unlike the `b` instruction,
    there are no restrictions on the address range of `br`.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 所有标签都有一个关联的地址（在[表 9-12](ch09.xhtml#ch9tab12)中为`addr`）。当CPU执行`b`指令时，它会将`pc`寄存器设置为`addr`。`b`指令使程序计数器能够在当前地址的128
    MB范围内进行跳转；编写汇编程序的程序员还可以通过使用`br`指令指定一个特定的地址来进行跳转。与`b`指令不同，`br`指令没有地址范围的限制。
- en: Sometimes, local labels also are shown as an offset from the start of a function.
    Therefore, an instruction whose address is 28 bytes away from the start of `main`
    may be represented with the label `<main+28>`. For example, the instruction `b`
    `0x7d0 <main+28>` indicates a branch to address 0x7d0, which has the associated
    label `<main+28>`, meaning that it is 28 bytes away from the starting address
    of the `main` function. Executing this instruction sets `pc` to 0x7d0.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，局部标签也会显示为从函数开始的偏移量。因此，一条地址距离`main`函数起始位置28字节的指令，可能会用标签`<main+28>`表示。例如，指令`b`
    `0x7d0 <main+28>`表示跳转到地址0x7d0，该地址的关联标签为`<main+28>`，意味着它距离`main`函数的起始地址有28字节。执行该指令时，将`pc`设置为0x7d0。
- en: The last three instructions are *conditional branch instructions*. In other
    words, the program counter register is set to `addr` only if the given condition
    evaluates to true. The `cbz` and `cbnz` instructions require a register in addition
    to an address. In the case of `cbz`, if R is zero, the branch is taken and `pc`
    is set to `addr`. In the case of `cbnz`, if R is nonzero, the branch is taken
    and `pc` is set to `addr`.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 最后三条指令是*条件分支指令*。换句话说，只有在给定的条件评估为真时，程序计数器寄存器才会被设置为`addr`。`cbz`和`cbnz`指令除了地址外，还需要一个寄存器。在`cbz`的情况下，如果R为零，则执行分支并将`pc`设置为`addr`。在`cbnz`的情况下，如果R非零，则执行分支并将`pc`设置为`addr`。
- en: The most powerful of the conditional branch instructions are the `b.c` instructions,
    which enable the compiler or assembly writer to pick a custom suffix that indicates
    the condition on which a branch is taken.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 最强大的条件分支指令是`b.c`指令，它使编译器或汇编程序员能够选择一个自定义后缀，表示进行分支的条件。
- en: '**Conditional branch instruction suffixes**   [Table 9-13](ch09.xhtml#ch9tab13)
    lists the set of common conditional branch suffixes (c). When used in conjunction
    with a branch, each instruction starts with the letter `b` and a dot, denoting
    that it is a branch instruction. The suffix of each instruction (c) indicates
    the *condition* for the branch. The branch instruction suffixes also determine
    whether to interpret numerical comparisons as signed or unsigned. Note that conditional
    branch instructions have a much more limited range (1 MB) than the `b` instruction.
    These suffixes are also used for the conditional select instruction (`csel`),
    which is covered in the next section.'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: '**条件分支指令后缀** [表 9-13](ch09.xhtml#ch9tab13)列出了常见的条件分支后缀（c）集合。与分支指令一起使用时，每条指令以字母`b`和一个点开始，表示它是一条分支指令。每条指令的后缀（c）表示分支的*条件*。分支指令后缀还决定了是否将数值比较解释为有符号或无符号。请注意，条件分支指令的范围比`b`指令要小得多（1
    MB）。这些后缀也用于条件选择指令（`csel`），该指令将在下一节中介绍。'
- en: '**Table 9-13:** Conditional Branch Instruction Suffixes (synonyms shown in
    parentheses)'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: '**表 9-13：** 条件跳转指令后缀（括号中为同义词）'
- en: '| **Signed Comparison** | **Unsigned Comparison** | **Description** |'
  id: totrans-228
  prefs: []
  type: TYPE_TB
  zh: '| **有符号比较** | **无符号比较** | **描述** |'
- en: '| `eq` | `eq` | branch if equal (==) or branch if zero |'
  id: totrans-229
  prefs: []
  type: TYPE_TB
  zh: '| `eq` | `eq` | 如果相等（==）或者如果为零则跳转 |'
- en: '| `ne` | `ne` | branch if not equal (!=) |'
  id: totrans-230
  prefs: []
  type: TYPE_TB
  zh: '| `ne` | `ne` | 如果不等于（!=）则跳转 |'
- en: '| `mi` | `mi` | branch if minus (negative) |'
  id: totrans-231
  prefs: []
  type: TYPE_TB
  zh: '| `mi` | `mi` | 如果为负数（负值）则跳转 |'
- en: '| `pl` | `pl` | branch if non-negative (>= 0) |'
  id: totrans-232
  prefs: []
  type: TYPE_TB
  zh: '| `pl` | `pl` | 如果非负（>= 0）则跳转 |'
- en: '| `gt` | `hi` | branch if greater than (higher) (>) |'
  id: totrans-233
  prefs: []
  type: TYPE_TB
  zh: '| `gt` | `hi` | 如果大于（更高）（>）则跳转 |'
- en: '| `ge` | `cs` (`hs`) | branch if greater than or equal (>=) |'
  id: totrans-234
  prefs: []
  type: TYPE_TB
  zh: '| `ge` | `cs` (`hs`) | 如果大于或等于（>=）则跳转 |'
- en: '| `lt` | `lo` (`cc`) | branch if less than (<) |'
  id: totrans-235
  prefs: []
  type: TYPE_TB
  zh: '| `lt` | `lo` (`cc`) | 如果小于（<）则跳转 |'
- en: '| `le` | `ls` | branch if less than or equal (<=) |'
  id: totrans-236
  prefs: []
  type: TYPE_TB
  zh: '| `le` | `ls` | 如果小于或等于（<=）则跳转 |'
- en: The goto Statement
  id: totrans-237
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '`goto` 语句'
- en: In the following subsections, we look at conditionals and loops in assembly
    and reverse engineer them back to C. When translating assembly code of conditionals
    and loops back into C, it is useful to understand their corresponding C language
    `goto` forms. The `goto` statement is a C primitive that forces program execution
    to switch to another line in the code. The assembly instruction associated with
    the `goto` statement is `b`.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的子节中，我们将研究汇编语言中的条件语句和循环，并将它们逆向转换回 C 语言。当将汇编代码的条件语句和循环翻译回 C 语言时，了解它们对应的 C
    语言 `goto` 形式非常有用。`goto` 语句是 C 语言中的一种原语，它强制程序执行跳转到代码中的另一行。与 `goto` 语句相关的汇编指令是 `b`。
- en: The `goto` statement consists of the `goto` keyword followed by a *goto label*,
    a type of program label that indicates that execution should continue at the corresponding
    label. So, `goto done` means that the program execution should branch to the line
    marked by label `done`. Other examples of program labels in C include the `switch`
    statement labels previously covered in “switch Statements” on [page 122](ch02.xhtml#lev2_36).
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: '`goto` 语句由 `goto` 关键字组成，后面跟着一个 *goto 标签*，这是一种程序标签，表示执行应该继续到相应的标签位置。因此，`goto
    done` 意味着程序执行应该跳转到标记为 `done` 的行。C 语言中程序标签的其他例子包括前面在“switch 语句”中提到的 `switch` 语句标签，见
    [第 122 页](ch02.xhtml#lev2_36)。'
- en: The following code listings depict a function `getSmallest` written in regular
    C code (first) and its associated `goto` form in C (second). The `getSmallest`
    function compares the value of two integers (`x` and `y`), and assigns the smaller
    value to variable `smallest`.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码清单展示了一个 `getSmallest` 函数，首先是用常规 C 代码编写的版本（第一部分），然后是它在 C 语言中的 `goto` 形式（第二部分）。`getSmallest`
    函数比较两个整数（`x` 和 `y`）的值，并将较小的值赋给变量 `smallest`。
- en: Regular C version
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 常规 C 版本
- en: '[PRE11]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: goto version
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: '`goto` 版本'
- en: '[PRE12]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The `goto` form of this function may seem counterintuitive, but let’s discuss
    what exactly is going on. The conditional checks to see whether variable `x` is
    less than or equal to `y`.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 这个 `goto` 形式的函数可能看起来有些反直觉，但我们来讨论一下到底发生了什么。条件语句检查变量 `x` 是否小于或等于 `y`。
- en: If `x` is less than or equal to `y`, the program transfers control to the label
    marked by `else_statement`, which contains the single statement `smallest = x`.
    Since the program executes linearly, the program continues on to execute the code
    under the label `done`, which returns the value of `smallest` (`x`).
  id: totrans-246
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果 `x` 小于或等于 `y`，程序将控制权转移到标记为 `else_statement` 的标签，该标签包含唯一语句 `smallest = x`。由于程序是线性执行的，接下来程序继续执行
    `done` 标签下的代码，并返回 `smallest` 的值（即 `x`）。
- en: If `x` is greater than `y`, then `smallest` is set to `y`. The program then
    executes the statement `goto done`, which transfers control to the `done` label,
    which returns the value of `smallest` (`y`).
  id: totrans-247
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果 `x` 大于 `y`，则将 `smallest` 设置为 `y`。程序接着执行语句 `goto done`，将控制权转移到 `done` 标签，返回
    `smallest` 的值（即 `y`）。
- en: Although `goto` statements were commonly used in the early days of programming,
    their use in modern code is considered bad practice because it reduces the overall
    readability of code. In fact, computer scientist Edsger Dijkstra wrote a famous
    paper lambasting the use of `goto` statements called “Go To Statement Considered
    Harmful.”^([4](ch09.xhtml#fn9_4))
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管 `goto` 语句在早期编程中很常见，但在现代代码中使用 `goto` 被认为是不好的实践，因为它降低了代码的整体可读性。实际上，计算机科学家艾兹格尔·代克斯特拉（Edsger
    Dijkstra）曾写过一篇著名的论文，批评使用 `goto` 语句，名为《Go To 语句的危害》^([4](ch09.xhtml#fn9_4))。
- en: In general, well-designed C programs do not use `goto` statements, and programmers
    are discouraged from using them to avoid writing code that is difficult to read,
    debug, and maintain. However, the C `goto` statement is important to understand,
    as GCC typically changes C code with conditionals into a `goto` form prior to
    translating it to assembly, including code that contains `if` statements and loops.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，设计良好的 C 程序不会使用 `goto` 语句，程序员应避免使用它们，以避免编写难以阅读、调试和维护的代码。然而，C 语言中的 `goto` 语句是重要的理解内容，因为
    GCC 通常会在将 C 代码翻译成汇编之前，将包含条件语句和循环的 C 代码转化为 `goto` 形式。
- en: The following subsections cover the assembly representation of `if` statements
    and loops in greater detail.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 以下小节将更详细地讨论 `if` 语句和循环的汇编表示。
- en: 9.4.2 if Statements in Assembly
  id: totrans-251
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 9.4.2 汇编中的 if 语句
- en: Let’s take a look at the `getSmallest` function in assembly. For convenience,
    the function is reproduced here.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一下汇编中的 `getSmallest` 函数。为了方便，函数在这里被重复展示。
- en: '[PRE13]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'The corresponding assembly code extracted from GDB looks similar to the following:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 从 GDB 中提取的相应汇编代码如下所示：
- en: '[PRE14]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: This is a different view of the assembly code than we have seen before. Here,
    we can see the *address* associated with each instruction, but not the *bytes*.
    Note that this assembly segment has been lightly edited for the sake of simplicity.
    By convention, GCC places the first and second parameters of a function in registers
    `x0` and `x1`, respectively. Since the parameters to `getSmallest` are of type
    `int`, the compiler places the parameters in the respective component registers
    `w0` and `w1` instead. For the sake of clarity, we refer to these parameters as
    `x` and `y`, respectively.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们之前看到的不同视角的汇编代码。在这里，我们可以看到每条指令相关的*地址*，但看不到*字节*。请注意，为了简化起见，这段汇编代码做了轻微的编辑。按照惯例，GCC
    将函数的第一个和第二个参数分别放在寄存器 `x0` 和 `x1` 中。由于 `getSmallest` 的参数是 `int` 类型，编译器将参数分别放入对应的组件寄存器
    `w0` 和 `w1` 中。为了清晰起见，我们将这两个参数分别称为 `x` 和 `y`。
- en: Let’s trace through the first few lines of the previous assembly code snippet.
    Note that we will not draw out the stack explicitly in this example. We leave
    this as an exercise for the reader, and encourage you to practice your stack tracing
    skills by drawing it out yourself.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们逐步分析前面汇编代码片段的前几行。请注意，我们在这个例子中不会显式地绘制栈。我们将这部分留给读者作为练习，并鼓励你通过自己绘制来练习栈追踪技巧。
- en: The `sub` instruction grows the call stack by 32 bytes (0x20).
  id: totrans-258
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`sub` 指令将调用栈增长了 32 字节（0x20）。'
- en: The `str` instructions at `<getSmallest+4>` and `<getSmallest+8>` store `x`
    and `y` at stack locations `sp` + 12 and `sp` + 8, respectively.
  id: totrans-259
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`<getSmallest+4>` 和 `<getSmallest+8>` 处的 `str` 指令分别将 `x` 和 `y` 存储到栈位置 `sp`
    + 12 和 `sp` + 8。'
- en: The `ldr` instructions at `<getSmallest+12>` and `<getSmallest+16` load `x`
    and `y` into registers `w1` and `w0`, respectively. Note that the original contents
    of `w0` and `w1` have swapped!
  id: totrans-260
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`<getSmallest+12>` 和 `<getSmallest+16>` 处的 `ldr` 指令将 `x` 和 `y` 分别加载到寄存器 `w1`
    和 `w0` 中。请注意，`w0` 和 `w1` 的原始内容已被交换！'
- en: The `cmp` instruction compares `w1` to `w0` (i.e., `x` to `y`) and sets appropriate
    condition code flag registers.
  id: totrans-261
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`cmp` 指令将 `w1` 与 `w0` （即 `x` 与 `y`）进行比较，并设置相应的条件码标志寄存器。'
- en: The `b.le` instruction at `<getSmallest+24>` indicates that if `x` is less than
    or equal to `y`, the next instruction that should execute should be at location
    `<getSmallest+40>` (or `pc` = 0x81c). Otherwise, `pc` is set to the next instruction
    in sequence, or 0x810.
  id: totrans-262
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`<getSmallest+24>` 处的 `b.le` 指令表示如果 `x` 小于或等于 `y`，下一条应执行的指令应位于 `<getSmallest+40>`（即
    `pc` = 0x81c）。否则，`pc` 被设置为顺序中的下一条指令，即 0x810。'
- en: 'The next instructions to execute depend on whether the program follows the
    branch (i.e., executes the jump) at (`<getSmallest+24>`). Let’s first suppose
    that the branch was *not* followed. In this case, `pc` is set to 0x810 (i.e.,
    `<getSmallest+28>`) and the following sequence of instructions executes:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来执行的指令取决于程序是否遵循分支（即是否执行跳转）(` <getSmallest+24>`)。首先假设分支*未*被跟随。在这种情况下，`pc` 被设置为
    0x810（即 `<getSmallest+28>`），接下来的指令序列执行：
- en: The `ldr` instruction at `<getSmallest+28>` loads `y` to register `w0`.
  id: totrans-264
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`<getSmallest+28>` 处的 `ldr` 指令将 `y` 加载到寄存器 `w0` 中。'
- en: The `str` instruction at `<getSmallest+32>` stores `y` at stack location `sp`
    + 28.
  id: totrans-265
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`<getSmallest+32>` 处的 `str` 指令将 `y` 存储在栈位置 `sp` + 28。'
- en: The `b` instruction at `<getSmallest+36>` sets register `pc` to address 0x824.
  id: totrans-266
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`<getSmallest+36>` 处的 `b` 指令将寄存器 `pc` 设置为地址 0x824。'
- en: The `ldr` instruction at `<getSmallest+48>` loads `y` into register `w0`.
  id: totrans-267
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`<getSmallest+48>` 处的 `ldr` 指令将 `y` 加载到寄存器 `w0` 中。'
- en: The last two instructions revert the call stack to its original size and return
    from the function call. In this case, `y` is in the return register, `w0`, and
    `getSmallest` returns `y`.
  id: totrans-268
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后的两条指令将调用栈恢复到其原始大小，并从函数调用中返回。在这种情况下，`y`位于返回寄存器`w0`中，`getSmallest`返回`y`。
- en: 'Now, suppose that the branch *was* taken at `<getSmallest+24>`. In other words,
    the `b.le` instruction sets register `pc` to 0x81c (i.e., `<getSmallest+40>`).
    Then, the next instructions to execute are:'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，假设在`<getSmallest+24>`处确实进行了分支。换句话说，`b.le`指令将寄存器`pc`设置为0x81c（即`<getSmallest+40>`）。然后，接下来的执行指令是：
- en: The `ldr` instruction at `<getSmallest+40>` loads `x` into register `w0`.
  id: totrans-270
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`<getSmallest+40>`处的`ldr`指令将`x`加载到寄存器`w0`中。'
- en: The `str` instruction at `<getSmallest+44>` stores `x` at stack location `sp`
    + 28.
  id: totrans-271
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`<getSmallest+44>`处的`str`指令将`x`存储在栈位置`sp` + 28。'
- en: The `ldr` instruction at `<getSmallest+48>` loads `x` into register `w0`.
  id: totrans-272
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`<getSmallest+48>`处的`ldr`指令将`x`加载到寄存器`w0`中。'
- en: The last two instructions revert the call stack to its original size and return
    from the function call. In this case, `x` is in the return register, `w0`, and
    `getSmallest` returns `x`.
  id: totrans-273
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后的两条指令将调用栈恢复到其原始大小，并从函数调用中返回。在这种情况下，`x`位于返回寄存器`w0`中，`getSmallest`返回`x`。
- en: 'We can then annotate the preceding assembly as follows:'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以如下注释前面的汇编代码：
- en: '[PRE15]'
  id: totrans-275
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Translating this back to C code yields:'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 将此转换回C代码，得到：
- en: goto form
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: goto形式
- en: '[PRE16]'
  id: totrans-278
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Translated C code
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 转换后的C代码
- en: '[PRE17]'
  id: totrans-280
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: In these code listings, the variable `smallest` corresponds to register `w0`.
    If `x` is less than or equal to `y`, the code executes the statement `smallest
    = x`, which is associated with the `goto` label `assign_x` in our `goto` form
    of this function. Otherwise, the statement `smallest = y` is executed. The `goto`
    label `done` is used to indicate that the value in `smallest` should be returned.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 在这些代码列表中，变量`smallest`对应于寄存器`w0`。如果`x`小于或等于`y`，代码将执行语句`smallest = x`，该语句与我们`goto`形式中的`assign_x`标签相关联。否则，执行语句`smallest
    = y`。`goto`标签`done`用于表示应返回`smallest`的值。
- en: Notice that the preceding C translation of the assembly code is a bit different
    from the original `getSmallest` function. These differences don’t matter; a close
    inspection of both functions reveals that the two programs are logically equivalent.
    However, the compiler first converts each `if` statement into an equivalent `goto`
    form, which results in the slightly different but equivalent version. The following
    code listings show the standard `if` statement format and its equivalent `goto`
    form.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，前面的C代码翻译与原始`getSmallest`函数略有不同。这些差异无关紧要；仔细检查这两个函数会发现，它们在逻辑上是等效的。然而，编译器首先将每个`if`语句转换为等效的`goto`形式，这导致了略有不同但等效的版本。以下代码列表展示了标准的`if`语句格式及其等效的`goto`形式。
- en: C if statement
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: C语言的if语句
- en: '[PRE18]'
  id: totrans-284
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Compiler’s equivalent goto form
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 编译器的等效`goto`形式
- en: '[PRE19]'
  id: totrans-286
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Compilers translating code into assembly designate a branch when a condition
    is true. Contrast this behavior with the structure of an `if` statement, where
    a “jump” (to the `else`) occurs when conditions are *not* true. The `goto` form
    captures this difference in logic.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 编译器将代码转换为汇编时，会在条件为真时指定一个分支。与`if`语句的结构对比，当条件*不*为真时，会发生“跳转”（到`else`）。`goto`形式捕捉了这一逻辑差异。
- en: 'Considering the original `goto` translation of the `getSmallest` function,
    we can see that:'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑到原始`goto`翻译的`getSmallest`函数，我们可以看到：
- en: '`x <= y` corresponds to `!*<condition>*`.'
  id: totrans-289
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`x <= y`对应于`!*<condition>*`。'
- en: '`smallest = x` is the <else_statement>.'
  id: totrans-290
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`smallest = x`是<else_statement>。'
- en: The line `smallest = y` is the <then_statement>.
  id: totrans-291
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`smallest = y`这一行是<then_statement>。'
- en: The last line in the function is `return smallest`.
  id: totrans-292
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 函数中的最后一行是`return smallest`。
- en: 'Rewriting the original version of the function with the preceding annotations
    yields:'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 用前述注释重写原始版本的函数，得到如下：
- en: '[PRE20]'
  id: totrans-294
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: This version is identical to the original `getSmallest` function. Keep in mind
    that a function written in different ways at the C code level can translate to
    the same set of assembly instructions.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 这个版本与原始的`getSmallest`函数相同。请记住，虽然C代码级别写法不同，但最终可能翻译为相同的一组汇编指令。
- en: The Conditional Select Instruction
  id: totrans-296
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 条件选择指令
- en: 'The final conditional instruction we cover is the *conditional select* (`csel`)
    instruction. The `cmp`, `tst`, and `b` instructions implement a *conditional transfer
    of control* in a program. In other words, the execution of the program branches
    in many directions. This can be very problematic for optimizing code because branch
    instructions are typically very expensive to execute, due to the disruption they
    can cause to the instruction pipeline (see “Pipelining Hazards: Control Hazards”
    on [page 279](ch05.xhtml#lev2_106) for the details). In contrast, the `csel` instruction
    implements a *conditional transfer of data*. In other words, the CPU executes
    *both* the <then_statement> and <else_statement>, and places the data in the appropriate
    register based on the result of the condition.'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 我们要介绍的最后一个条件指令是*条件选择*（`csel`）指令。`cmp`、`tst`和`b`指令实现了程序中的*条件控制转移*。换句话说，程序的执行会在多个方向上进行分支。这对优化代码来说是非常棘手的，因为分支指令通常非常昂贵，执行时可能会干扰指令流水线（有关详细信息，请参见[第279页](ch05.xhtml#lev2_106)的“流水线危险：控制危险”）。相比之下，`csel`指令实现了*条件数据转移*。换句话说，CPU会执行*两个*
    <then_statement>和<else_statement>，并根据条件的结果将数据放入适当的寄存器中。
- en: 'The use of C’s *ternary expression* often results in the compiler generating
    a `csel` instruction in place of branches. For the standard if–then–else statement,
    the ternary expression has the form:'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: C语言中的*三元表达式*常常导致编译器生成`csel`指令来替代分支指令。对于标准的if–then–else语句，三元表达式的形式是：
- en: '[PRE21]'
  id: totrans-299
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Let’s use this format to rewrite the `getSmallest` function as a ternary expression.
    Keep in mind that this new version of the function behaves exactly as the original
    `getSmallest` function:'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用这种格式将`getSmallest`函数重写为三元表达式。请记住，这个新版本的函数行为与原始的`getSmallest`函数完全相同：
- en: '[PRE22]'
  id: totrans-301
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Even though this may not seem like a big change, let’s look at the resulting
    assembly. Recall that the first and second parameters (`x` and `y`) are stored
    in registers `w0` and `w1`, respectively:'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管这看起来可能不是一个大的改变，但让我们来看一下生成的汇编代码。回想一下，第一和第二个参数（`x`和`y`）分别存储在寄存器`w0`和`w1`中：
- en: '[PRE23]'
  id: totrans-303
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: This assembly code has no jumps. After the comparison of `x` and `y`, `x` moves
    into the return register `w0` only if `x` is less than or equal to `y`.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 这段汇编代码没有跳转。在对`x`和`y`进行比较后，只有在`x`小于或等于`y`时，`x`才会移动到返回寄存器`w0`中。
- en: The structure of the `csel` instruction is
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: '`csel`指令的结构是'
- en: '[PRE24]'
  id: totrans-306
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: where `D` denotes the destination register, `R1` and `R2` are the two registers
    containing the values to be compared, and `C` is the condition to be evaluated.
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 其中`D`表示目标寄存器，`R1`和`R2`是包含待比较值的两个寄存器，`C`是需要评估的条件。
- en: As for the branch instructions, the `C` component of the `csel` instructions
    indicates the condition on which the conditional select occurs. They are identical
    to those shown in [Table 9-13](ch09.xhtml#ch9tab13) on [page 479](ch09.xhtml#ch9tab13).
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 至于分支指令，`csel`指令中的`C`部分表示条件选择发生的条件。它们与[第9-13表](ch09.xhtml#ch9tab13)中所示的条件相同，详见[第479页](ch09.xhtml#ch9tab13)。
- en: 'In the case of the original `getSmallest` function, the compiler’s internal
    optimizer (see [Chapter 12](ch12.xhtml#ch12)) will replace the `b` instructions
    with a `csel` instruction if level 1 optimizations are turned on (i.e., `-O1`):'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 在原始的`getSmallest`函数中，编译器的内部优化器（见[第12章](ch12.xhtml#ch12)）会在开启一级优化（即`-O1`）时，将`b`指令替换为`csel`指令：
- en: '[PRE25]'
  id: totrans-310
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'In general, the compiler is very cautious about optimizing branch instructions
    into `csel` instructions, especially in cases where side effects and pointer values
    are involved. Here, we show two equivalent ways of writing a function called `incrementX`:'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 一般来说，编译器对将分支指令优化为`csel`指令非常谨慎，特别是在涉及副作用和指针值的情况下。这里，我们展示了两种等效的`incrementX`函数写法：
- en: C code
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: C代码
- en: '[PRE26]'
  id: totrans-313
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: C ternary form
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: C三元表达式形式
- en: '[PRE27]'
  id: totrans-315
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Each function takes a pointer to an integer as input and checks whether it is
    `NULL`. If `x` is not `NULL`, the function increments and returns the dereferenced
    value of `x`. Otherwise, the function returns the value 1.
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 每个函数都接受一个指向整数的指针作为输入，并检查其是否为`NULL`。如果`x`不为`NULL`，函数将递增并返回`x`解引用后的值。否则，函数将返回值1。
- en: 'It is tempting to think that `incrementX2` uses a `csel` instruction given
    that it uses a ternary expression. However, both functions yield the exact same
    assembly code:'
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: '`incrementX2`看起来像是使用了`csel`指令，因为它使用了三元表达式。然而，两个函数生成的汇编代码完全相同：'
- en: '[PRE28]'
  id: totrans-318
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Recall that the `csel` instruction *executes both branches of the conditional*.
    In other words, `x` gets dereferenced no matter what. Consider the case where
    `x` is a null pointer. Recall that dereferencing a null pointer leads to a null
    pointer exception in the code, causing a segmentation fault. To prevent any chance
    of this happening, the compiler takes the safe road and uses a branch.
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 回想一下，`csel`指令*执行条件的两个分支*。换句话说，无论如何，`x`都会被解引用。考虑`x`为空指针的情况。回想一下，解引用空指针会导致空指针异常，从而导致段错误。为了防止发生这种情况，编译器采取了安全路径，并使用了分支。
- en: 9.4.3 Loops in Assembly
  id: totrans-320
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 9.4.3 汇编中的循环
- en: Like `if` statements, loops in assembly are also implemented using branch instructions.
    However, loops enable instructions to be *revisited* based on the result of an
    evaluated condition.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 类似于`if`语句，汇编中的循环也使用分支指令实现。然而，循环使得根据评估条件的结果，指令可以*被重新访问*。
- en: The `sumUp` function in the following example sums up all the positive integers
    from 1 to a user-defined integer *n*. This code is intentionally written suboptimally
    to illustrate a `while` loop in C.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例中的`sumUp`函数将从1到用户定义的整数*n*之间的所有正整数求和。这段代码故意写得不够优化，以说明C语言中的`while`循环。
- en: '[PRE29]'
  id: totrans-323
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Compiling this code and disassembling it using GDB yields the following assembly
    code:'
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 编译这段代码并使用GDB反汇编后，得到以下汇编代码：
- en: '[PRE30]'
  id: totrans-325
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Again, we will not draw out the stack explicitly in this example. However, we
    encourage readers to draw the stack out themselves.
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，我们在这个例子中不会显式地绘制栈。然而，我们鼓励读者自行绘制栈。
- en: The First Five Instructions
  id: totrans-327
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 前五条指令
- en: 'The first five instructions of this function set the stack up for function
    execution and store some temporary values:'
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 该函数的前五条指令为函数执行设置栈，并存储一些临时值：
- en: '[PRE31]'
  id: totrans-329
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Specifically, they:'
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 具体来说，它们：
- en: Grow the call stack by 32 bytes, marking the new frame.
  id: totrans-331
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 增加32字节的调用栈，标记新的栈帧。
- en: Store the first parameter (`n`) at stack location `sp` + 12.
  id: totrans-332
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将第一个参数（`n`）存储在栈位置`sp` + 12。
- en: Store the value 0 at stack location `sp` + 24, indicating `total`.
  id: totrans-333
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将值0存储在栈位置`sp` + 24，表示`total`。
- en: Copy the value 1 into register `w0`.
  id: totrans-334
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将值1复制到寄存器`w0`中。
- en: Store the value 1 at stack location `sp` + 28, indicating `i`.
  id: totrans-335
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将值1存储在栈位置`sp` + 28，表示`i`。
- en: Recall that stack locations store *temporary variables* in a function. For simplicity
    we will refer to the location marked by `sp` + 24 as `total` and `sp` + 28 as
    `i`. The input parameter to `sumUp` (`n`) is located at stack address `sp` + 12\.
    Despite the placement of temporary variables on the stack, keep in mind that the
    stack pointer has not changed after the execution of the first instruction (`sub
    sp, sp,` `#0x20`).
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: '回忆一下，栈位置存储函数中的*临时变量*。为了简化，我们将`sp` + 24标记的位置称为`total`，`sp` + 28标记的位置称为`i`。`sumUp`的输入参数（`n`）位于栈地址`sp`
    + 12。尽管临时变量已放置在栈上，但请记住，在执行第一条指令（`sub sp, sp, #0x20`）后，栈指针并没有改变。'
- en: The Heart of the Loop
  id: totrans-337
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 循环的核心
- en: 'The next 12 instructions in the `sumUp` function represent the heart of the
    loop:'
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: '`sumUp`函数中的接下来的12条指令构成了循环的核心：'
- en: '[PRE32]'
  id: totrans-339
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: The first instruction is a direct jump to `<sumUp+52>`, which sets the program
    counter register (`pc`) to address 0x758.
  id: totrans-340
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第一条指令是直接跳转到`<sumUp+52>`，将程序计数器寄存器（`pc`）设置为地址0x758。
- en: The next two instructions that execute (at `<sumUp+52>` and `<sumUp+56>`) load
    `i` and `n` into registers `w1` and `w0`, respectively.
  id: totrans-341
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 接下来执行的两条指令（在`<sumUp+52>`和`<sumUp+56>`处）分别将`i`和`n`加载到寄存器`w1`和`w0`中。
- en: The `cmp` instruction at `<sumUp+60>` compares `i` and `n`, setting the appropriate
    condition flags. The program counter `pc` advances to the next instruction, or
    address 0x764.
  id: totrans-342
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`<sumUp+60>`处的`cmp`指令比较`i`和`n`，设置相应的条件标志。程序计数器`pc`将前进到下一条指令，或者地址0x764。'
- en: The `b.le` instruction at `<sumUp+64>` replaces the `pc` register with address
    0x73c if `i` is less than or equal to `n`.
  id: totrans-343
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`<sumUp+64>`处的`b.le`指令在`i`小于或等于`n`时，将`pc`寄存器替换为地址0x73c。'
- en: 'If the branch is taken (that is, if `i <= n`), program execution jumps to `<sumUp+24>`
    and the following instructions execute:'
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 如果分支被执行（也就是说，`i <= n`），程序执行跳转到`<sumUp+24>`，并执行以下指令：
- en: The `ldr` instructions at `<sumUp+24>` and `<sumUp+28>` load `total` and `i`
    into registers `w1` and `w0`, respectively.
  id: totrans-345
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`<sumUp+24>`和`<sumUp+28>`处的`ldr`指令分别将`total`和`i`加载到寄存器`w1`和`w0`中。'
- en: The `add` instruction at `<sumUp+32>` then adds `total` to `i` (`i +` `total`)
    and stores the result in `w0`.
  id: totrans-346
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`<sumUp+32>`处的`add`指令将`total`和`i`相加（`i + total`），并将结果存储在`w0`中。'
- en: The `str` instruction at `<sumUp+36>` then updates `total` with the value in
    register `w0` (`total = total + i`)
  id: totrans-347
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`<sumUp+36>`处的`str`指令随后将寄存器`w0`中的值更新到`total`中（`total = total + i`）。'
- en: The `ldr` instruction at `<sumUp+40>` loads `i` into register `w0`.
  id: totrans-348
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`<sumUp+40>`处的`ldr`指令将`i`加载到寄存器`w0`中。'
- en: The `add` instruction at `<sumUp+44>` adds 1 to `i` and stores the result in
    register `w0`.
  id: totrans-349
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`<sumUp+44>`处的`add`指令将1加到`i`上，并将结果存储在寄存器`w0`中。'
- en: The `str` instruction at `<sumUp+48>` updates `i` with the value stored in register
    `w0` (`i = i + 1`)
  id: totrans-350
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`<sumUp+48>`处的`str`指令将寄存器`w0`中的值更新到`i`中（`i = i + 1`）。'
- en: The `ldr` instructions at `<sumUp+52>` and `<sumUp+56>` load `i` and `n` into
    registers `w1` and `w0`, respectively.
  id: totrans-351
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`<sumUp+52>`和`<sumUp+56>`处的`ldr`指令分别将`i`和`n`加载到寄存器`w1`和`w0`中。'
- en: The `cmp` instruction at `<sumUp+60>` compares `i` to `n` and sets the appropriate
    condition code flags.
  id: totrans-352
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`<sumUp+60>`处的`cmp`指令将`i`与`n`进行比较，并设置适当的条件码标志。'
- en: The `b.le` instruction then executes. If `i` is less than or equal to `n`, program
    execution jumps back to `<sumUp+24>`, `pc` is set to 0x73c, and the instructions
    between `<sumUp+24>` and `<sumUp+64>` repeat execution. Otherwise, register `pc`
    is set to the address of the next instruction in sequence, or 0x768 (`<sumUp+68>`).
  id: totrans-353
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 然后执行`b.le`指令。如果`i`小于或等于`n`，程序执行跳转回`<sumUp+24>`，`pc`被设置为0x73c，`<sumUp+24>`到`<sumUp+64>`之间的指令会重复执行。否则，寄存器`pc`被设置为下一个指令的地址，即0x768（`<sumUp+68>`）。
- en: 'If the branch is *not* taken (i.e., `i` is greater than `n`), the following
    instructions execute:'
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 如果分支*没有*被采取（即`i`大于`n`），则执行以下指令：
- en: '[PRE33]'
  id: totrans-355
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: These instructions copy `total` to the return register `w0`, restore the call
    stack by shrinking `sp`, and exit the function. Thus, the function returns `total`
    upon exit.
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 这些指令将`total`复制到返回寄存器`w0`中，通过缩小`sp`恢复调用栈，并退出函数。因此，函数在退出时返回`total`。
- en: 'The following code listings show the assembly and C `goto` forms of the `sumUp`
    function:'
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码列出了`sumUp`函数的汇编和C语言`goto`形式：
- en: Assembly
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: 汇编
- en: '[PRE34]'
  id: totrans-359
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Translated goto form
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 翻译后的goto形式
- en: '[PRE35]'
  id: totrans-361
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'The preceding code is also equivalent to the following C code without `goto`
    statements:'
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码也等价于以下没有`goto`语句的C代码：
- en: '[PRE36]'
  id: totrans-363
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: for Loops in Assembly
  id: totrans-364
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 汇编中的for循环
- en: 'The primary loop in the `sumUp` function can also be written as a `for` loop:'
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: '`sumUp`函数中的主要循环也可以写成`for`循环：'
- en: '[PRE37]'
  id: totrans-366
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'This yields identical assembly code to our `while` loop example. We repeat
    the assembly code here and annotate each line with its English translation:'
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: 这会生成与我们的`while`循环示例相同的汇编代码。我们在此重复汇编代码，并用英文翻译标注每一行：
- en: '[PRE38]'
  id: totrans-368
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: To understand why the `for` loop version of this code results in identical assembly
    to the `while` loop version of the code, recall that the `for` loop has the following
    representation.
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: 为了理解为什么`for`循环版本的代码会生成与`while`循环版本相同的汇编代码，请记住`for`循环具有以下表示形式。
- en: '[PRE39]'
  id: totrans-370
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'This is equivalent to the following `while` loop representation:'
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: 这等价于以下的`while`循环表示：
- en: '[PRE40]'
  id: totrans-372
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Since every `for` loop can be represented by a `while` loop (see “for Loops”
    on [page 35](ch01.xhtml#lev3_5)), the following two C programs are equivalent
    representations for the previous assembly:'
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: 由于每个`for`循环都可以用`while`循环表示（见[第35页](ch01.xhtml#lev3_5)中的“for循环”），以下两个C程序是前面汇编代码的等价表示：
- en: for loop
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: for循环
- en: '[PRE41]'
  id: totrans-375
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: while loop
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: while循环
- en: '[PRE42]'
  id: totrans-377
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 9.5 Functions in Assembly
  id: totrans-378
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 9.5 汇编中的函数
- en: In the previous section, we traced through simple functions in assembly. In
    this section, we discuss the interaction between multiple functions in assembly
    in the context of a larger program. We also introduce some new instructions involved
    with function management.
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一节中，我们跟踪了汇编中的简单函数。在本节中，我们讨论了在更大程序的上下文中多个函数之间的交互。我们还介绍了一些与函数管理相关的新指令。
- en: Let’s begin with a refresher on how the call stack is managed. Recall that `sp`
    is the *stack pointer* and always points to the top of the stack. The register
    `x29` represents the base pointer (also known as the *frame pointer* or `FP`)
    and points to the base of the current stack frame. The *stack frame* (also known
    as the *activation frame* or the *activation record*) refers to the portion of
    the stack allocated to a single function call. The currently executing function
    is always at the top of the stack, and its stack frame is referred to as the *active
    frame*. The active frame is bounded by the stack pointer (at the top of stack,
    lower address) and frame pointer (at the bottom of the frame, higher address).
    The activation record typically holds local variables for a function. Lastly,
    the *return address* indicates the program address at which the calling function
    (e.g., `main`) resumes execution as soon as the callee function exits. In A64
    systems, the return address is stored in register `x30` (also known as `LR`).
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从复习调用栈的管理方式开始。回想一下，`sp` 是 *栈指针*，总是指向栈顶。寄存器 `x29` 代表基指针（也称为 *帧指针* 或 `FP`），指向当前栈帧的底部。*栈帧*（也称为
    *激活帧* 或 *激活记录*）指的是为单个函数调用分配的栈内存区域。当前执行的函数总是位于栈的顶部，且其栈帧被称为 *活动帧*。活动帧的边界由栈指针（栈顶，较低地址）和帧指针（帧底部，较高地址）确定。激活记录通常包含函数的局部变量。最后，*返回地址*
    表示调用函数（例如，`main`）在被调用函数退出后将恢复执行的程序地址。在 A64 系统中，返回地址存储在寄存器 `x30`（也称为 `LR`）中。
- en: '[Figure 9-4](ch09.xhtml#ch9fig4) shows the stack frames for `main` and a function
    it calls named `fname`. We will refer to the `main` function as the *caller* function
    and `fname` as the *callee* function.'
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 9-4](ch09.xhtml#ch9fig4) 显示了 `main` 函数及其调用的函数 `fname` 的栈帧。我们将 `main` 函数称为
    *调用者* 函数，将 `fname` 函数称为 *被调用者* 函数。'
- en: '![image](../images/09fig04.jpg)'
  id: totrans-382
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/09fig04.jpg)'
- en: '*Figure 9-4: Stack frame management*'
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 9-4：栈帧管理*'
- en: In [Figure 9-4](ch09.xhtml#ch9fig4), the current active frame belongs to the
    callee function (`fname`). The region of the call stack between the stack and
    frame pointers is used for local variables. The stack pointer moves as local values
    are pushed onto and popped from the stack. The frame pointer is not commonly used
    in optimized code, and is usually optional for operation. As a result, compilers
    like GCC commonly reference values on the stack relative to the stack pointer.
    In [Figure 9-4](ch09.xhtml#ch9fig4), the active frame is bounded below by the
    base pointer of `fname`, or `x29`, which contains stack address 0xef30\. The value
    stored at address 0xef30 is the “saved” frame pointer value (0xef50), which itself
    indicates the bottom of the activation frame for the `main` function. Right below
    the frame pointer is a saved *return address* (stored in `x30`), which indicates
    the address that the program will continue executing once `main` exits.
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: 在[图 9-4](ch09.xhtml#ch9fig4)中，当前活动帧属于被调用函数 (`fname`)。调用栈中从栈指针到帧指针的区域用于存储局部变量。随着局部变量被压入和弹出栈，栈指针会移动。帧指针在优化后的代码中通常不常用，且通常是可选操作。因此，像
    GCC 这样的编译器通常会相对于栈指针引用栈上的值。在[图 9-4](ch09.xhtml#ch9fig4)中，活动帧的下边界由 `fname` 的基指针或
    `x29` 确定，它包含栈地址 0xef30。地址 0xef30 中存储的值是“保存的”帧指针值 (0xef50)，它本身指示 `main` 函数的激活帧底部。在帧指针下方是一个保存的
    *返回地址*（存储在 `x30` 中），它表示程序在 `main` 退出后将继续执行的地址。
- en: '**Warning THE RETURN ADDRESS POINTS TO CODE MEMORY, NOT STACK MEMORY**'
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: '**警告：返回地址指向代码内存，而非栈内存**'
- en: Recall that the call stack region (stack memory) of a program is different from
    its code region (code memory). Whereas `sp` and `x29` point to addresses in the
    stack memory, `pc` points to an address in *code* memory. In other words, the
    return address is an address in *code* memory, not stack memory (see [Figure 9-5](ch09.xhtml#ch9fig5)).
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: 回想一下，程序的调用栈区域（栈内存）与其代码区域（代码内存）是不同的。`sp` 和 `x29` 指向栈内存中的地址，而 `pc` 指向代码内存中的地址。换句话说，返回地址是代码内存中的地址，而非栈内存中的地址（见[图
    9-5](ch09.xhtml#ch9fig5)）。
- en: '![image](../images/09fig05.jpg)'
  id: totrans-387
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/09fig05.jpg)'
- en: '*Figure 9-5: The parts of a program’s address space*'
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 9-5：程序地址空间的各个部分*'
- en: '[Table 9-14](ch09.xhtml#ch9tab14) contains several additional instructions
    that the compiler uses for basic function management.'
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: '[表 9-14](ch09.xhtml#ch9tab14) 包含编译器用于基本函数管理的几个附加指令。'
- en: '**Table 9-14:** Common Function Management Instructions'
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: '**表 9-14：** 常见的函数管理指令'
- en: '| **Instruction** | **Translation** |'
  id: totrans-391
  prefs: []
  type: TYPE_TB
  zh: '| **指令** | **翻译** |'
- en: '| `bl addr <fname>` | Sets `x30` = `pc` + 4 and sets `pc` = addr |'
  id: totrans-392
  prefs: []
  type: TYPE_TB
  zh: '| `bl addr <fname>` | 设置 `x30` = `pc` + 4，并将 `pc` 设置为 addr |'
- en: '| `blr R <fname>` | Sets `x30` = `pc` + 4 and sets `pc` = R |'
  id: totrans-393
  prefs: []
  type: TYPE_TB
  zh: '| `blr R <fname>` | 设置 `x30` = `pc` + 4，并将 `pc` 设置为 R |'
- en: '| `ret` | Returns value in `x0` and sets `pc` = `x30` |'
  id: totrans-394
  prefs: []
  type: TYPE_TB
  zh: '| `ret` | 返回 `x0` 中的值，并将 `pc` 设置为 `x30` |'
- en: The `bl` and `ret` instructions play a prominent role in the process where one
    function calls another. Both instructions modify the instruction pointer (register
    `pc`). When the caller function executes the `bl` instruction, the value of `pc`
    + 4 is saved in register `x30` to represent the return address, or the program
    address at which the caller resumes executing once the callee function finishes.
    The `bl` instruction also replaces the value of `pc` with the address of the callee
    function.
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: '`bl` 和 `ret` 指令在一个函数调用另一个函数的过程中起着重要作用。这两条指令都会修改指令指针（寄存器 `pc`）。当调用函数执行 `bl`
    指令时，`pc` + 4 的值会保存在寄存器 `x30` 中，表示返回地址，或者说是调用函数在被调用函数执行完毕后恢复执行的程序地址。`bl` 指令还将 `pc`
    的值替换为被调用函数的地址。'
- en: The `ret` instruction restores the value of `pc` to the value saved in `x30`,
    ensuring that the program resumes execution at the program address specified in
    the caller function. Any value returned by the callee is stored in register `x0`
    or its component register `w0`. The `ret` instruction is usually the last instruction
    that executes in any function.
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
  zh: '`ret` 指令将 `pc` 的值恢复为保存在 `x30` 中的值，确保程序从调用函数指定的地址恢复执行。被调用函数返回的任何值都存储在寄存器 `x0`
    或其组件寄存器 `w0` 中。`ret` 指令通常是任何函数中执行的最后一条指令。'
- en: '#### 9.5.1 Function Parameters'
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
  zh: '#### 9.5.1 函数参数'
- en: Function parameters are typically preloaded into registers prior to a function
    call. The first eight parameters to a function are stored in registers `x0`–`x7`.
    If a function requires more than seven parameters, the remaining parameters are
    successively loaded into the call stack based on their size (4-byte offsets for
    32-bit data, 8-byte offsets for 64-bit data).
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
  zh: 函数参数通常在函数调用之前被预先加载到寄存器中。传递给函数的前八个参数存储在寄存器 `x0` 到 `x7` 中。如果一个函数需要更多的参数，剩余的参数会根据其大小依次加载到调用栈中（32位数据使用4字节偏移，64位数据使用8字节偏移）。
- en: 9.5.2 Tracing Through an Example
  id: totrans-399
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 9.5.2 跟踪一个示例
- en: Using our knowledge of function management, let’s trace through the code example
    first introduced at the beginning of this chapter.
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
  zh: 使用我们对函数管理的了解，让我们跟踪通过本章开头介绍的代码示例。
- en: '[PRE43]'
  id: totrans-401
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'We compile this code with the command `gcc -o prog prog.c` and use `objdump
    -d` to view the underlying assembly. The latter command outputs a pretty big file
    that contains a lot of information that we don’t need. Use `less` and the search
    functionality to extract the `adder`, `assign`, and `main` functions:'
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用命令 `gcc -o prog prog.c` 编译这段代码，并使用 `objdump -d` 查看底层汇编。后者命令输出了一个相当大的文件，包含了很多我们不需要的信息。可以使用
    `less` 和搜索功能提取 `adder`、`assign` 和 `main` 函数：
- en: '[PRE44]'
  id: totrans-403
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: Each function begins with a symbolic label that corresponds to its declared
    name in the program. For example, `<main>:` is the symbolic label for the `main`
    function. The address of a function label is also the address of the first instruction
    in that function. To save space in the figures that follow, we truncate code addresses
    to the lower 12 bits, and stack addresses to the lower 16 bits. So, stack address
    0xffffffffef50 is shown as 0xef50.
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
  zh: 每个函数以一个符号标签开始，该标签对应程序中声明的函数名。例如，`<main>:` 是 `main` 函数的符号标签。函数标签的地址也是该函数中第一条指令的地址。为了节省接下来的图示空间，我们将代码地址截断为低12位，将堆栈地址截断为低16位。因此，堆栈地址
    `0xffffffffef50` 显示为 `0xef50`。
- en: 9.5.3 Tracing Through main
  id: totrans-405
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 9.5.3 跟踪 `main`
- en: '[Figure 9-6](ch09.xhtml#ch9fig6) shows the execution stack immediately prior
    to the execution of `main`.'
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 9-6](ch09.xhtml#ch9fig6) 显示了在执行 `main` 函数之前，执行栈的状态。'
- en: '![image](../images/09fig06.jpg)'
  id: totrans-407
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/09fig06.jpg)'
- en: '*Figure 9-6: Initial state of CPU registers and call stack prior to executing
    the `main` function*'
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 9-6：执行 `main` 函数前，CPU 寄存器和调用栈的初始状态*'
- en: Recall that the stack grows toward lower addresses. In this example, the frame
    and stack pointers (`x29` and `sp`) both contain address 0xef50\. Initially, `pc`
    is the address of the first instruction in the `main` function, or 0x750\. Registers
    `x30` and `w0` are also highlighted in this example, and both contain initial
    junk values.
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
  zh: 回想一下，堆栈是向较低地址增长的。在这个示例中，帧指针和堆栈指针（`x29` 和 `sp`）都包含地址 `0xef50`。最初，`pc` 是 `main`
    函数中第一条指令的地址，或者说是 `0x750`。寄存器 `x30` 和 `w0` 在这个示例中也被高亮显示，它们都包含初始的垃圾值。
- en: '![image](../images/f0497-01.jpg)'
  id: totrans-410
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f0497-01.jpg)'
- en: 'The first instruction (`stp`) is a composite instruction with two parts. First,
    the second operand (`[sp, #-32]!`) decrements the stack pointer by 32 bytes, thus
    allocating space for the current stack frame. After the evaluation of the operand,
    the stack pointer updates to 0xef30\. Next, the `stp` instruction stores the current
    values of `x29` and `x30` at locations `sp` and `sp` + 8, respectively. The instruction
    pointer `pc` advances to the next instruction in sequence.'
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
  zh: '第一条指令（`stp`）是一个复合指令，包含两个部分。首先，第二个操作数（`[sp, #-32]!`）将栈指针减少 32 字节，从而为当前栈帧分配空间。在操作数求值后，栈指针更新为
    0xef30。接下来，`stp` 指令将 `x29` 和 `x30` 的当前值分别存储在 `sp` 和 `sp` + 8 的位置。指令指针 `pc` 移动到下一条指令。'
- en: '![image](../images/f0497-02.jpg)'
  id: totrans-412
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f0497-02.jpg)'
- en: The next instruction (`mov x29, sp`) updates the value of `x29` to be the same
    as `sp`. Thus, the frame pointer (`x29`) now points to the start of the stack
    frame for the `main` function. The instruction pointer `pc` advances to the next
    instruction in sequence.
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
  zh: 下一条指令（`mov x29, sp`）将寄存器 `x29` 的值更新为与 `sp` 相同。因此，帧指针（`x29`）现在指向 `main` 函数栈帧的起始位置。指令指针
    `pc` 移动到下一条指令。
- en: '![image](../images/f0498-01.jpg)'
  id: totrans-414
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f0498-01.jpg)'
- en: The first `bl` instruction stores `pc` + 4 (or 0x75c) in register `x30`, which
    is the address in `main` at which the program will resume executing once the `assign`
    function returns. Next, the register `pc` is updated with address 0x724, which
    indicates the address of the first instruction in the `assign` function.
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
  zh: 第一条 `bl` 指令将 `pc` + 4（即 0x75c）存储在寄存器 `x30` 中，这个地址是程序在 `assign` 函数返回后将在 `main`
    中恢复执行的位置。接着，寄存器 `pc` 被更新为地址 0x724，表示 `assign` 函数中第一条指令的地址。
- en: '![image](../images/f0498-02.jpg)'
  id: totrans-416
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f0498-02.jpg)'
- en: The next instruction that executes is the first instruction in `assign`. The
    `sub` instruction decrements the stack pointer by 16 bytes. Note that `x29` and
    `sp` now denote the active stack frame boundaries for the `assign` function. The
    program counter advances to the next instruction.
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
  zh: 执行的下一条指令是 `assign` 中的第一条指令。`sub` 指令将栈指针减少 16 字节。请注意，`x29` 和 `sp` 现在表示 `assign`
    函数的活动栈帧边界。程序计数器移动到下一条指令。
- en: '![image](../images/f0499-01.jpg)'
  id: totrans-418
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f0499-01.jpg)'
- en: The `mov` instruction stores the constant value 0x28 in register `w0`. Register
    `pc` advances to the next instruction in sequence.
  id: totrans-419
  prefs: []
  type: TYPE_NORMAL
  zh: '`mov` 指令将常数值 0x28 存储到寄存器 `w0` 中。寄存器 `pc` 移动到下一条指令。'
- en: '![image](../images/f0500-01.jpg)'
  id: totrans-420
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f0500-01.jpg)'
- en: The `str` instruction stores 0x28 at an offset of 12 bytes from the stack pointer,
    or at address 0xef2c. The instruction pointer advances to the next instruction.
  id: totrans-421
  prefs: []
  type: TYPE_NORMAL
  zh: '`str` 指令将 0x28 存储在栈指针偏移 12 字节的位置，或地址 0xef2c。指令指针移动到下一条指令。'
- en: '![image](../images/f0500-02.jpg)'
  id: totrans-422
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f0500-02.jpg)'
- en: The `ldr` instruction saves 0x28 from stack address 0xef2c into register `w0`.
    The instruction pointer advances to the next instruction.
  id: totrans-423
  prefs: []
  type: TYPE_NORMAL
  zh: '`ldr` 指令将 0x28 从栈地址 0xef2c 加载到寄存器 `w0` 中。指令指针移动到下一条指令。'
- en: '![image](../images/f0501-01.jpg)'
  id: totrans-424
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f0501-01.jpg)'
- en: The `add` instruction deallocates the current stack frame and reverts `sp` to
    its previous value, or 0xef30.
  id: totrans-425
  prefs: []
  type: TYPE_NORMAL
  zh: '`add` 指令回收当前栈帧，并将 `sp` 恢复为之前的值，即 0xef30。'
- en: '![image](../images/f0501-02.jpg)'
  id: totrans-426
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f0501-02.jpg)'
- en: The `ret` instruction replaces the value in `pc` with the value in `x30`, or
    0x75c. As a result, program execution returns to the first instruction in the
    `main` function immediately after the call to `assign`.
  id: totrans-427
  prefs: []
  type: TYPE_NORMAL
  zh: '`ret` 指令将 `pc` 中的值替换为 `x30` 中的值，或 0x75c。结果，程序执行将立即返回到 `main` 函数中调用 `assign`
    后的第一条指令。'
- en: '![image](../images/f0502-01.jpg)'
  id: totrans-428
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f0502-01.jpg)'
- en: The next instruction that executes is a function call to `adder` (or `bl 73c`
    `<adder>`). Therefore, register `x30` is updated with `pc` + 4, or 0x760\. The
    program counter is replaced with address 0x73c, signifying that program execution
    continues into the `adder` function.
  id: totrans-429
  prefs: []
  type: TYPE_NORMAL
  zh: 执行的下一条指令是对 `adder` 函数的调用（或 `bl 73c` `<adder>`）。因此，寄存器 `x30` 被更新为 `pc` + 4，即
    0x760。程序计数器被替换为地址 0x73c，表示程序继续执行到 `adder` 函数。
- en: '![image](../images/f0502-02.jpg)'
  id: totrans-430
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f0502-02.jpg)'
- en: The first instruction in the `adder` function decrements the stack pointer by
    16 bytes, allocating the new stack frame for the `adder` function. Note that the
    active stack frame boundaries for the `adder` function are designated by registers
    `sp` and `x29`. The instruction pointer advances to the next instruction in sequence.
  id: totrans-431
  prefs: []
  type: TYPE_NORMAL
  zh: '`adder`函数中的第一条指令将栈指针减少16字节，为`adder`函数分配新的栈帧。请注意，`adder`函数的活动栈帧边界由寄存器`sp`和`x29`指定。指令指针继续执行下一个指令。'
- en: '![image](../images/f0503-01.jpg)'
  id: totrans-432
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f0503-01.jpg)'
- en: What happens next is crucial. The `ldr` instruction loads an *old* value from
    the stack (at `sp` + 12) into register `w0`. This is a direct result of the fact
    that the programmer forgot to initialize `a` in the `adder` function. The instruction
    pointer advances to the next instruction in sequence.
  id: totrans-433
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来的操作至关重要。`ldr`指令从栈中（在`sp` + 12处）加载一个*旧*值到寄存器`w0`中。这是由于程序员忘记初始化`adder`函数中的`a`变量。指令指针继续执行下一个指令。
- en: '![image](../images/f0504-01.jpg)'
  id: totrans-434
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f0504-01.jpg)'
- en: The `add` instruction then adds 0x2 to the value in `w0` and stores the result
    (0x2A) in register `w0`. The instruction pointer advances to the next instruction
    in sequence.
  id: totrans-435
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，`add`指令将0x2加到寄存器`w0`中的值，并将结果（0x2A）存储回寄存器`w0`。指令指针继续执行下一个指令。
- en: '![image](../images/f0504-02.jpg)'
  id: totrans-436
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f0504-02.jpg)'
- en: The next `add` instruction increments the stack pointer by 16 bytes, thus destroying
    the active frame for `adder` and restoring `sp` to its previous value. The instruction
    pointer advances to the next instruction in sequence.
  id: totrans-437
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来的`add`指令将栈指针增加16字节，从而销毁`adder`的活动栈帧，并将`sp`恢复到之前的值。指令指针继续执行下一个指令。
- en: '![image](../images/f0505-01.jpg)'
  id: totrans-438
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f0505-01.jpg)'
- en: Finally, the `ret` instruction overwrites `pc` with the address in register
    `x30`, indicating that program execution should continue in the `main` function
    at code segment address 0x760.
  id: totrans-439
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，`ret`指令用寄存器`x30`中的地址覆盖`pc`，指示程序执行应在代码段地址0x760的`main`函数中继续。
- en: '![image](../images/f0505-02.jpg)'
  id: totrans-440
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f0505-02.jpg)'
- en: Back in the `main` function, the `str` instruction at program address 0x760
    stores the contents of the `w0` register (0x2A) at a call stack location that
    is 28 bytes from the frame pointer (`x29`). Therefore, 0x2A is stored at stack
    address 0xef4c.
  id: totrans-441
  prefs: []
  type: TYPE_NORMAL
  zh: 回到`main`函数时，程序地址0x760处的`str`指令将寄存器`w0`（0x2A）中的内容存储到离帧指针（`x29`）28字节的调用栈位置。因此，0x2A存储在栈地址0xef4c。
- en: '![image](../images/f0506-01.jpg)'
  id: totrans-442
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f0506-01.jpg)'
- en: The next two instructions together load an address of a page into register `x0`.
    Since addresses are 8 bytes long, the 64-bit register `x0` is used instead of
    its 32-bit component, `w0`. The `adrp` instruction loads the address (0x0) into
    register `x0`, while the `add` instruction at code segment address 0x768 adds
    the value 0x820 to it. At the end of these two instructions, register `x0` contains
    memory address 0x820\. Note that the value stored at address 0x820 is the string
    `"x is` `%d\n"`.
  id: totrans-443
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来的两条指令一起将页面的地址加载到寄存器`x0`中。由于地址长度为8字节，因此使用64位寄存器`x0`，而不是它的32位组件`w0`。`adrp`指令将地址（0x0）加载到寄存器`x0`中，而位于代码段地址0x768的`add`指令将0x820的值加到其中。这两条指令执行完毕后，寄存器`x0`包含了内存地址0x820。请注意，存储在地址0x820的值是字符串`"x
    is` `%d\n"`。
- en: '![image](../images/f0507-01.jpg)'
  id: totrans-444
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f0507-01.jpg)'
- en: Next, the `ldr` instruction at program address 0x76c loads 0x2A (which is located
    at an offset of 28 bytes from the frame pointer) into register `w1`.
  id: totrans-445
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，位于程序地址0x76c的`ldr`指令将0x2A（该值位于距帧指针28字节的偏移处）加载到寄存器`w1`中。
- en: '![image](../images/f0507-02.jpg)'
  id: totrans-446
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f0507-02.jpg)'
- en: 'The next instruction calls the `printf` function. For the sake of brevity,
    we will not trace the `printf` function, which is part of `stdio.h`. However,
    we know from the manual page (`man -s3 printf`) that `printf` has the following
    format:'
  id: totrans-447
  prefs: []
  type: TYPE_NORMAL
  zh: 下一条指令调用`printf`函数。为了简洁起见，我们将不会跟踪`printf`函数，它是`stdio.h`的一部分。然而，我们从手册页面（`man -s3
    printf`）中知道，`printf`具有以下格式：
- en: '[PRE45]'
  id: totrans-448
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'In other words, the first argument is a pointer to a string specifying the
    format, and the second argument onward specify the values that are used in that
    format. The instructions specified by addresses 0x764–0x770 correspond to the
    following line in the `main` function:'
  id: totrans-449
  prefs: []
  type: TYPE_NORMAL
  zh: 换句话说，第一个参数是指向指定格式的字符串的指针，从第二个参数开始，后续的参数指定在该格式中使用的值。地址0x764–0x770指定的指令对应于`main`函数中的以下一行：
- en: '[PRE46]'
  id: totrans-450
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'When the `printf` function is called:'
  id: totrans-451
  prefs: []
  type: TYPE_NORMAL
  zh: 当调用`printf`函数时：
- en: The return address (`pc` + 4 or 0x774) is stored in register `x30`.
  id: totrans-452
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 返回地址（`pc` + 4或0x774）存储在寄存器`x30`中。
- en: Register `pc` switches address 0x610, which is the start of the `printf` function.
  id: totrans-453
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 寄存器`pc`切换到地址0x610，这是`printf`函数的起始地址。
- en: Register `sp` is updated to reflect the new stack frame for the `printf` function.
  id: totrans-454
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 寄存器`sp`被更新，以反映`printf`函数的新栈帧。
- en: At some point, `printf` references its arguments, which are the string `"x is
    %d\n"` and the value 0x2A. Recall that for any function with *n* arguments, gcc
    places the first eight arguments in registers `x0`–`x7`, and the remaining arguments
    onto the stack *below* the frame pointer. In this case, the first parameter is
    stored in register `x0` (since it is an address to a string), and the second parameter
    is stored in component register `w1`.
  id: totrans-455
  prefs: []
  type: TYPE_NORMAL
  zh: 在某个时刻，`printf`引用了它的参数，这些参数是字符串`"x is %d\n"`和值0x2A。回想一下，对于任何带有*n*个参数的函数，gcc将前八个参数放入寄存器`x0`到`x7`中，剩余的参数则放到栈中*在*帧指针下方。在这个例子中，第一个参数存储在寄存器`x0`中（因为它是一个指向字符串的地址），第二个参数存储在组件寄存器`w1`中。
- en: After the call to `printf`, the value 0x2A is output to the user in integer
    format. Thus, the value 42 is printed to the screen. The stack pointer reverts
    to its previous value, and `pc` updates to the value stored in register `x30`,
    or 0x774.
  id: totrans-456
  prefs: []
  type: TYPE_NORMAL
  zh: 在调用`printf`之后，值0x2A以整数格式输出给用户。因此，值42被打印到屏幕上。栈指针恢复到之前的值，`pc`更新为寄存器`x30`中存储的值，即0x774。
- en: '![image](../images/f0508-01.jpg)'
  id: totrans-457
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f0508-01.jpg)'
- en: The `mov` instructions at address 0x774 loads the constant value `#0x0` into
    component register `w0`. This represents the value that will be returned when
    `main` completes execution. The program counter advances to the next instruction
    in sequence.
  id: totrans-458
  prefs: []
  type: TYPE_NORMAL
  zh: 地址0x774处的`mov`指令将常数值`#0x0`加载到组件寄存器`w0`中。这表示`main`函数执行完毕后将返回的值。程序计数器将推进到下一条指令。
- en: '![image](../images/f0509-01.jpg)'
  id: totrans-459
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f0509-01.jpg)'
- en: 'The `ldp` instruction at program address 0x778 first copies the values at `sp`
    and `sp` + 8 into registers `x29` and `x30`, reverting them to their original
    values prior to the start of the execution of the `main` function. The last part
    of the `ldp` instruction (as specified by the operand `[sp], #32`) increments
    the stack pointer by 32 bytes, restoring `sp` to its original value prior to the
    execution of `main`. Thus, when the `ldp` instruction completes execution, the
    stack pointer (`sp`), frame pointer (`x29`), and return register (`x30`) all have
    returned to their original values. The program counter advances to the last instruction
    in the `main` function.'
  id: totrans-460
  prefs: []
  type: TYPE_NORMAL
  zh: '地址为0x778的`ldp`指令首先将`sp`和`sp` + 8处的值分别复制到寄存器`x29`和`x30`中，将它们恢复到执行`main`函数之前的原始值。`ldp`指令的最后一部分（由操作数`[sp],
    #32`指定）将栈指针增加32字节，恢复`sp`到`main`执行前的原始值。因此，当`ldp`指令执行完毕时，栈指针（`sp`）、帧指针（`x29`）和返回寄存器（`x30`）都已恢复到它们的原始值。程序计数器推进到`main`函数中的最后一条指令。'
- en: '![image](../images/f0509-02.jpg)'
  id: totrans-461
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f0509-02.jpg)'
- en: The last instruction that executes is `ret`. With 0x0 in the return register
    `w0`, the program returns 0, indicating correct termination.
  id: totrans-462
  prefs: []
  type: TYPE_NORMAL
  zh: 最后执行的指令是`ret`。当返回寄存器`w0`中为0x0时，程序返回0，表示正确终止。
- en: If you have carefully read through this section, you should understand why our
    program prints out the value 42\. In essence, the program inadvertently uses old
    values on the stack to cause it to behave in a way that we didn’t expect. This
    example was pretty harmless; however we discuss in future sections how hackers
    have misused function calls to make programs misbehave in truly malicious ways.
  id: totrans-463
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你仔细阅读了这一部分内容，你应该明白为什么我们的程序输出值42。实际上，程序不小心使用了栈中的旧值，导致其行为超出了我们的预期。这个例子没有什么危害；然而，我们将在后续章节讨论黑客如何恶意滥用函数调用，使得程序以真正恶意的方式表现异常。
- en: 9.6 Recursion
  id: totrans-464
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 9.6 递归
- en: Recursive functions are a special class of functions that call themselves (also
    known as *self-referential* functions) to compute a value. Like their nonrecursive
    counterparts, recursive functions create new stack frames for each function call.
    Unlike standard functions, recursive functions contain function calls to themselves.
  id: totrans-465
  prefs: []
  type: TYPE_NORMAL
  zh: 递归函数是一类特殊的函数，它们调用自身（也称为*自引用*函数）来计算一个值。与非递归函数类似，递归函数为每次函数调用创建新的栈帧。与标准函数不同，递归函数包含对自身的调用。
- en: 'Let’s revisit the problem of summing up the set of positive integers from 1
    to *n*. In previous sections, we discussed the `sumUp` function to achieve this
    task. The following code shows a related function called `sumDown`, which adds
    the numbers in reverse (*n* to 1), and its recursive equivalent `sumr`:'
  id: totrans-466
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回顾一下求和正整数从1到*n*的集合的问题。在之前的章节中，我们讨论了使用`sumUp`函数来完成这个任务。以下代码展示了一个相关的函数`sumDown`，它以相反的顺序（从*n*到1）加和，并且它的递归等价函数是`sumr`：
- en: Iterative
  id: totrans-467
  prefs: []
  type: TYPE_NORMAL
  zh: 迭代
- en: '[PRE47]'
  id: totrans-468
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: Recursive
  id: totrans-469
  prefs: []
  type: TYPE_NORMAL
  zh: 递归
- en: '[PRE48]'
  id: totrans-470
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'The base case in the recursive function `sumr` accounts for any values of *n*
    that are less than or equal to zero, and the recursive step adds the current value
    of *n* to the result of the function call to `sumr` with the value *n –* 1\. Compiling
    `sumr` and disassembling it with GDB yields the following assembly code:'
  id: totrans-471
  prefs: []
  type: TYPE_NORMAL
  zh: 递归函数`sumr`中的基本情况处理了所有小于或等于零的*n*值，而递归步骤将当前的*n*值加到`sumr`函数调用的结果上，其中调用时*n*的值为*n–1*。编译`sumr`并使用GDB反汇编得到以下汇编代码：
- en: '[PRE49]'
  id: totrans-472
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Each line in the preceding assembly code is annotated with its English translation.
    Here, we show the corresponding `goto` form (first) and C program without `goto`
    statements (second):'
  id: totrans-473
  prefs: []
  type: TYPE_NORMAL
  zh: 上述汇编代码中的每一行都附有它的英文翻译。这里，我们展示了对应的`goto`形式（第一种）和没有`goto`语句的C程序（第二种）：
- en: C goto form
  id: totrans-474
  prefs: []
  type: TYPE_NORMAL
  zh: C的goto形式
- en: '[PRE50]'
  id: totrans-475
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: C version without goto
  id: totrans-476
  prefs: []
  type: TYPE_NORMAL
  zh: 不带goto的C版本
- en: '[PRE51]'
  id: totrans-477
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: Although this translation may not initially appear to be identical to the original
    `sumr` function, close inspection reveals that the two functions are indeed equivalent.
  id: totrans-478
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管这种翻译在最初可能看起来与原始的`sumr`函数不完全相同，但仔细观察后可以发现这两个函数实际上是等价的。
- en: '9.6.1 Animation: Observing How the Call Stack Changes'
  id: totrans-479
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 9.6.1 动画：观察调用栈的变化
- en: As an exercise, we encourage you to draw out the stack and see how the values
    change. We have provided an animation online that depicts how the stack is updated
    when we run this function with the value `3`.^([5](ch09.xhtml#fn9_5))
  id: totrans-480
  prefs: []
  type: TYPE_NORMAL
  zh: 作为一个练习，我们鼓励你绘制栈，并观察值是如何变化的。我们在线提供了一段动画，展示了当我们使用值`3`运行此函数时，栈是如何更新的。^([5](ch09.xhtml#fn9_5))
- en: 9.7 Arrays
  id: totrans-481
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 9.7 数组
- en: Recall that arrays (see “Introduction to Arrays” on [page 44](ch01.xhtml#lev2_9))
    are ordered collections of data elements of the same type that are contiguously
    stored in memory. Statically allocated single-dimension arrays (see “Single-Dimensional
    Arrays” on [page 81](ch02.xhtml#lev2_22)) have the form <type> `arr[N]`, where
    <type> is the data type, `arr` is the identifier associated with the array, and
    `N` is the number of data elements. Declaring an array statically as <type> `arr[N]`
    or dynamically as `arr = malloc(N*sizeof(` <type>`))` allocates *N* × `sizeof(`
    <type>`)` total bytes of memory.
  id: totrans-482
  prefs: []
  type: TYPE_NORMAL
  zh: 回顾一下，数组（见[第44页](ch01.xhtml#lev2_9)中的“数组介绍”）是存储在内存中相邻位置的同一类型的数据元素的有序集合。静态分配的一维数组（见[第81页](ch02.xhtml#lev2_22)中的“单维数组”）的形式为<type>`arr[N]`，其中<type>是数据类型，`arr`是与数组关联的标识符，`N`是数据元素的数量。静态声明一个数组形式为<type>`arr[N]`或动态声明为`arr
    = malloc(N*sizeof(<type>))`，这将分配*N* × `sizeof(<type>)`字节的总内存。
- en: To access the element at index `i` in array `arr`, use the syntax `arr[i]`.
    Compilers commonly convert array references into pointer arithmetic (see “Pointer
    Variables” on [page 67](ch02.xhtml#lev1_10)) prior to translating to assembly.
    So, `arr+i` is equivalent to `&arr[i]`, and `*(arr+i)` is equivalent to `arr[i]`.
    Since each data element in `arr` is of type <type>, `arr+i` implies that element
    `i` is stored at address `arr` + `sizeof(` <type>`)` × `i`.
  id: totrans-483
  prefs: []
  type: TYPE_NORMAL
  zh: 要访问数组`arr`中索引为`i`的元素，使用语法`arr[i]`。编译器通常会在转换为汇编之前将数组引用转换为指针运算（见[第67页](ch02.xhtml#lev1_10)中的“指针变量”）。因此，`arr+i`等价于`&arr[i]`，`*(arr+i)`等价于`arr[i]`。由于`arr`中的每个数据元素都是<type>类型，`arr+i`意味着第`i`个元素存储在地址`arr`
    + `sizeof(<type>)` × `i`的位置。
- en: '[Table 9-15](ch09.xhtml#ch9tab15) outlines some common array operations and
    their corresponding assembly instructions. In the examples that follow, suppose
    that we declare an `int` array of length 10 (e.g., `int arr[10]`). Assume that
    register `x1` stores the address of `arr`, register `x2` stores the `int` value
    `i`, and register `x0` represents some variable `x` (also of type `int`). Recall
    that `int` variables take up four bytes of space, whereas `int *` variables take
    up eight bytes.'
  id: totrans-484
  prefs: []
  type: TYPE_NORMAL
  zh: '[表 9-15](ch09.xhtml#ch9tab15)概述了一些常见的数组操作及其对应的汇编指令。在接下来的示例中，假设我们声明了一个长度为10的`int`数组（例如，`int
    arr[10]`）。假设寄存器`x1`存储`arr`的地址，寄存器`x2`存储`int`值`i`，寄存器`x0`表示某个变量`x`（也是`int`类型）。回顾一下，`int`变量占用四个字节空间，而`int
    *`变量占用八个字节空间。'
- en: '**Table 9-15:** Common Array Operations and Their Corresponding Assembly Representations'
  id: totrans-485
  prefs: []
  type: TYPE_NORMAL
  zh: '**表 9-15：** 常见的数组操作及其对应的汇编表示'
- en: '| **Operation** | **Type** | **Assembly Representation** |'
  id: totrans-486
  prefs: []
  type: TYPE_TB
  zh: '| **操作** | **类型** | **汇编表示** |'
- en: '| `x = arr` | `int *` | `mov x0, x1` |'
  id: totrans-487
  prefs: []
  type: TYPE_TB
  zh: '| `x = arr` | `int *` | `mov x0, x1` |'
- en: '| `x = arr[0]` | `int` | `ldr w0, [x1]` |'
  id: totrans-488
  prefs: []
  type: TYPE_TB
  zh: '| `x = arr[0]` | `int` | `ldr w0, [x1]` |'
- en: '| `x = arr[i]` | `int` | `ldr w0, [x1, x2, LSL, #2]` |'
  id: totrans-489
  prefs: []
  type: TYPE_TB
  zh: '| `x = arr[i]` | `int` | `ldr w0, [x1, x2, LSL, #2]` |'
- en: '| `x = &arr[3]` | `int *` | `add x0, x1, #12` |'
  id: totrans-490
  prefs: []
  type: TYPE_TB
  zh: '| `x = &arr[3]` | `int *` | `add x0, x1, #12` |'
- en: '| `x = arr+3` | `int *` | `add x0, x1, #12` |'
  id: totrans-491
  prefs: []
  type: TYPE_TB
  zh: '| `x = arr+3` | `int *` | `add x0, x1, #12` |'
- en: '| `x = *(arr+5)` | `int` | `ldr w0, [x1, #20]` |'
  id: totrans-492
  prefs: []
  type: TYPE_TB
  zh: '| `x = *(arr+5)` | `int` | `ldr w0, [x1, #20]` |'
- en: Notice that to access element `arr[5]` (or `*(arr+5)` using pointer arithmetic),
    the compiler performs a memory lookup on address `arr+5*4` instead of `arr+5`.
    To understand why this is necessary, recall that any element at index `i` in an
    array is stored at address `arr` + `sizeof(` <type>`)` × `i`. The compiler must
    therefore multiply the index by the size of the data type (in this case 4, given
    that `sizeof(int)` = 4) to compute the correct offset. Recall also that memory
    is byte-addressable; offsetting by the correct number of bytes is the same as
    computing an address.
  id: totrans-493
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，为了访问元素 `arr[5]`（或使用指针运算访问 `*(arr+5)`），编译器会对地址 `arr+5*4` 进行内存查找，而不是 `arr+5`。要理解为什么这样做是必要的，请回想一下，数组中索引为
    `i` 的元素存储在地址 `arr` + `sizeof(<type>)` × `i`。因此，编译器必须将索引乘以数据类型的大小（在此情况下是 4，因为 `sizeof(int)`
    = 4）来计算正确的偏移量。还要记住，内存是按字节寻址的；通过正确的字节数偏移等同于计算一个地址。
- en: As an example, consider a sample array (`array`) with 10 integer elements ([Figure
    9-7](ch09.xhtml#ch9fig7)).
  id: totrans-494
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，考虑一个包含 10 个整数元素的示例数组（`array`）（[图 9-7](ch09.xhtml#ch9fig7)）。
- en: '![image](../images/09fig07.jpg)'
  id: totrans-495
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/09fig07.jpg)'
- en: '*Figure 9-7: The layout of a ten-integer array in memory. Each a[i]-labeled
    box represents an offset of four bytes, as each integer requires four bytes to
    store.*'
  id: totrans-496
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 9-7：十个整数数组在内存中的布局。每个标有 a[i] 的框表示四字节的偏移，因为每个整数需要四个字节来存储。*'
- en: Notice that since `array` is an array of integers, each element takes up exactly
    four bytes. Thus, an integer array with 10 elements consumes 40 bytes of contiguous
    memory.
  id: totrans-497
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，由于 `array` 是一个整数数组，每个元素恰好占用四个字节。因此，一个包含 10 个元素的整数数组会占用 40 字节的连续内存。
- en: To compute the address of element 3, the compiler multiplies the index 3 by
    the data size of the integer type (4) to yield an offset of 12 (or 0xc). Sure
    enough, element 3 in [Figure 9-7](ch09.xhtml#ch9fig7) is located at byte offset
    *a*[12].
  id: totrans-498
  prefs: []
  type: TYPE_NORMAL
  zh: 为了计算元素 3 的地址，编译器将索引 3 乘以整数类型的数据大小（4），得到一个偏移量为 12（或 0xc）。果然，图 [9-7](ch09.xhtml#ch9fig7)
    中的元素 3 位于字节偏移量 *a*[12]。
- en: 'Let’s take a look at a simple C function called `sumArray` that sums up all
    the elements in an array:'
  id: totrans-499
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看一个简单的 C 函数，名为 `sumArray`，它会对数组中的所有元素求和：
- en: '[PRE52]'
  id: totrans-500
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'The `sumArray` function takes the address of an array and the array’s associated
    length and sums up all the elements in the array. Now take a look at the corresponding
    assembly of the `sumArray` function:'
  id: totrans-501
  prefs: []
  type: TYPE_NORMAL
  zh: '`sumArray` 函数接受数组的地址和数组的长度，并对数组中的所有元素求和。现在，让我们看一下 `sumArray` 函数的对应汇编代码：'
- en: '[PRE53]'
  id: totrans-502
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: When tracing this assembly code, consider whether the data being accessed represents
    a pointer or a value. For example, the instruction at `<sumArray+12>` results
    in stack location `sp` + 28 containing a variable of type `int`, which is initially
    set to 0\. In contrast, the argument stored at location `sp` + 8 is the first
    argument to the function (`array`), which is of type `int *` and corresponds to
    the base address of the array. A different variable (which we call `i`) is stored
    at location `sp` + 24 and is initially set to 0.
  id: totrans-503
  prefs: []
  type: TYPE_NORMAL
  zh: 在跟踪这段汇编代码时，考虑一下被访问的数据是指针还是值。例如，`<sumArray+12>` 处的指令会导致栈位置 `sp` + 28 包含一个类型为
    `int` 的变量，该变量最初被设置为 0。相反，存储在 `sp` + 8 位置的参数是函数的第一个参数（`array`），它是 `int *` 类型，并对应数组的基地址。另一个变量（我们称之为
    `i`）存储在 `sp` + 24 位置，初始值为 0。
- en: The astute reader will notice a previously unseen instruction at line `<sumArray+30>`
    called `ldrsw`. The `ldrsw` instruction stands for “load register signed word”
    and converts the 32-bit `int` value stored at `sp` + 24 to a 64-bit integer value
    and stores it in `x0`. This operation is necessary because the instructions that
    follow perform pointer arithmetic. Recall that on 64-bit systems, pointers take
    up eight bytes of space. The compiler’s use of `ldrsw` simplifies the process
    by ensuring that all data are stored in full 64-bit registers instead of their
    32-bit components.
  id: totrans-504
  prefs: []
  type: TYPE_NORMAL
  zh: 敏锐的读者会注意到 `<sumArray+30>` 处出现了一条之前未见的指令 `ldrsw`。`ldrsw` 指令表示“加载寄存器有符号字”，它将存储在
    `sp` + 24 处的 32 位 `int` 值转换为 64 位整数，并将其存储在 `x0` 中。这个操作是必要的，因为接下来的指令要进行指针运算。请记住，在
    64 位系统中，指针占用八个字节的空间。编译器使用 `ldrsw` 来简化这个过程，确保所有数据都存储在完整的 64 位寄存器中，而不是它们的 32 位组件。
- en: 'Let’s take a closer look at the seven instructions between locations `<sumArray+28>`
    and `<sumArray+52>`:'
  id: totrans-505
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们仔细看看 `<sumArray+28>` 和 `<sumArray+52>` 之间的七条指令：
- en: '[PRE54]'
  id: totrans-506
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: The compiler uses `lsl` to perform a left shift on the value `i` stored in `x0`.
    When this instruction completes execution, register `x0` contains `i ≪ 2`, or
    `i * 4`. At this point, `x0` contains the number of bytes to calculate the correct
    offset of `array[i]` (or `sizeof(int)` = 4).
  id: totrans-507
  prefs: []
  type: TYPE_NORMAL
  zh: 编译器使用 `lsl` 对存储在 `x0` 中的值 `i` 执行左移操作。当此指令执行完毕时，寄存器 `x0` 中包含 `i ≪ 2`，即 `i * 4`。此时，`x0`
    包含计算 `array[i]` 正确偏移量所需的字节数（或 `sizeof(int)` = 4）。
- en: 'The next instruction (`ldr x1, [sp, #8]`) loads the first argument to the function
    (i.e., the base address of `array`) into register `x1`. Adding `x1` to `x0` in
    the next instruction causes `x0` to contain `array` + `i` × 4\. Recall that the
    element at index `i` in `array` is stored at address `array` + `sizeof(` <type>`)`
    × `i` Therefore, `x0` now contains the assembly-level computation of address `&array[i]`.'
  id: totrans-508
  prefs: []
  type: TYPE_NORMAL
  zh: '下一条指令（`ldr x1, [sp, #8]`）将函数的第一个参数（即 `array` 的基地址）加载到寄存器 `x1` 中。在接下来的指令中，将
    `x1` 加到 `x0` 中，使得 `x0` 包含 `array` + `i` × 4。请记住，`array` 中索引为 `i` 的元素存储在地址 `array`
    + `sizeof(<type>)` × `i` 处。因此，`x0` 现在包含了地址 `&array[i]` 的汇编级计算。'
- en: The instruction at `<sumArray+40>` *dereferences* the value located at `x0`,
    placing the value `array[i]` into `w1`. Notice the use of the component register
    `w1`, since `array[i]` contains a 32-bit `int` value! In contrast, the variable
    `i` was changed to a 64-bit integer on line `<sumArray+24>` because `i` was about
    to be used for *address computation*. Again, addresses (pointers) are stored as
    64-bit words.
  id: totrans-509
  prefs: []
  type: TYPE_NORMAL
  zh: '`<sumArray+40>` 处的指令*取消引用*了存储在 `x0` 中的值，将 `array[i]` 的值放入 `w1` 中。请注意使用了组件寄存器
    `w1`，因为 `array[i]` 包含一个 32 位的 `int` 值！相比之下，变量 `i` 在 `<sumArray+24>` 处被更改为 64 位整数，因为
    `i` 即将用于*地址计算*。再次提醒，地址（指针）以 64 位字存储。'
- en: The last three instructions between `<sumArray+44>` and `<sumArray+52>` load
    the current value of `total` into component register `w1`, add `array[i]` to it,
    and store the result in component register `w0`, before updating `total` at location
    `sp` + 28 with the new sum. Therefore, the seven instructions between `<sumArray+28>`
    and `<sumArray+52>` are equivalent to the line `total += array[i]` in the `sumArray`
    function.
  id: totrans-510
  prefs: []
  type: TYPE_NORMAL
  zh: '`<sumArray+44>` 和 `<sumArray+52>` 之间的最后三条指令将当前的 `total` 值加载到组件寄存器 `w1` 中，将
    `array[i]` 加到其中，并将结果存储在组件寄存器 `w0` 中，然后在 `sp` + 28 位置更新 `total` 为新的和。因此，`<sumArray+28>`
    和 `<sumArray+52>` 之间的七条指令等价于 `sumArray` 函数中的 `total += array[i]` 这一行。'
- en: 9.8 Matrices
  id: totrans-511
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 9.8 矩阵
- en: 'A matrix is a 2D array. A matrix in C can be statically allocated as a 2D array
    (`M[n][m]`), dynamically allocated with a single call to `malloc`, or dynamically
    allocated as an array of arrays. Let’s consider the array of arrays implementation.
    The first array contains `n` elements (`M[n]`), and each element `M[i]` in our
    matrix contains an array of `m` elements. The following code snippets each declare
    matrices of size 4 × 3:'
  id: totrans-512
  prefs: []
  type: TYPE_NORMAL
  zh: 矩阵是一个二维数组。在 C 语言中，矩阵可以作为静态二维数组（`M[n][m]`）分配，或者通过一次 `malloc` 调用进行动态分配，或者作为数组的数组进行动态分配。我们来看看数组的数组实现。第一个数组包含
    `n` 个元素（`M[n]`），矩阵中的每个元素 `M[i]` 包含一个 `m` 个元素的数组。以下代码片段声明了大小为 4 × 3 的矩阵：
- en: '[PRE55]'
  id: totrans-513
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: In the case of the dynamically allocated matrix, the main array contains a contiguous
    array of `int` pointers. Each integer pointer points to a different array in memory.
    [Figure 9-8](ch09.xhtml#ch9fig8) illustrates how we would normally visualize each
    of these matrices.
  id: totrans-514
  prefs: []
  type: TYPE_NORMAL
  zh: 对于动态分配的矩阵，主数组包含一组连续的 `int` 指针数组。每个整数指针指向内存中的不同数组。[图 9-8](ch09.xhtml#ch9fig8)
    说明了我们通常如何可视化这些矩阵。
- en: '![image](../images/09fig08.jpg)'
  id: totrans-515
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/09fig08.jpg)'
- en: '*Figure 9-8: Illustration of a statically allocated (`M1`) and dynamically
    allocated (`M2`) 3 × 4 matrix*'
  id: totrans-516
  prefs: []
  type: TYPE_NORMAL
  zh: '*图9-8：静态分配（`M1`）和动态分配（`M2`）3 × 4矩阵的示例*'
- en: For both of these matrix declarations, element (*i*,*j*) can be accessed using
    the double-indexing syntax `M[i][j]`, where `M` is either `M1` or `M2`. However,
    these matrices are organized differently in memory. Even though both store the
    elements in their primary array contiguously in memory, our statically allocated
    matrix also stores all the rows contiguously in memory, as shown in [Figure 9-9](ch09.xhtml#ch9fig9).
  id: totrans-517
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这两个矩阵声明，元素（*i*,*j*）可以使用双索引语法`M[i][j]`来访问，其中`M`可以是`M1`或`M2`。然而，这些矩阵在内存中的组织方式不同。尽管两者都在主数组中连续存储元素，但是我们静态分配的矩阵也将所有行连续存储在内存中，如[图9-9](ch09.xhtml#ch9fig9)所示。
- en: '![image](../images/09fig09.jpg)'
  id: totrans-518
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/09fig09.jpg)'
- en: '*Figure 9-9: Matrix `M1`’s memory layout in row-major order*'
  id: totrans-519
  prefs: []
  type: TYPE_NORMAL
  zh: '*图9-9：按行主序排列的矩阵`M1`的内存布局*'
- en: 'This contiguous ordering is not guaranteed for `M2`. Recall (from “Two-Dimensional
    Array Memory Layout” on [page 86](ch02.xhtml#lev3_13)) that to contiguously allocate
    an *n* × *m* matrix on the heap, we should use a single call to `malloc` that
    allocates *n* × *m* elements:'
  id: totrans-520
  prefs: []
  type: TYPE_NORMAL
  zh: 这种连续的排序对于`M2`并不保证。回顾一下（参见第86页的“二维数组内存布局”），为了在堆上连续分配一个*n* × *m*矩阵，我们应该使用一次调用`malloc`来分配*n*
    × *m*个元素：
- en: '[PRE56]'
  id: totrans-521
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: Recall that with the declaration of `M3`, element (*i*,*j*) *cannot* be accessed
    using the `M[i][j]` notation. Instead, we must index the element using the format
    `M3[i*cols + j]`.
  id: totrans-522
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，对于声明为`M3`的矩阵，无法使用`M[i][j]`的方式访问元素（*i*,*j*）。相反，我们必须使用`M3[i*cols + j]`的格式进行索引。
- en: 9.8.1 Contiguous Two-Dimensional Arrays
  id: totrans-523
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 9.8.1 连续二维数组
- en: Consider a function `sumMat` that takes a pointer to a contiguously allocated
    (either statically allocated or memory-efficient dynamically allocated) matrix
    as its first parameter, along with a number of rows and columns, and returns the
    sum of all the elements inside the matrix.
  id: totrans-524
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑一个名为`sumMat`的函数，它以一个指向连续分配的（静态分配或内存高效动态分配的）矩阵的指针作为其第一个参数，以及行数和列数，并返回矩阵中所有元素的总和。
- en: We use scaled indexing in the code snippet that follows because it applies to
    both statically and dynamically allocated contiguous matrices. Recall that the
    syntax `m[i][j]` does not work with the memory-efficient contiguous dynamic allocation
    previously discussed.
  id: totrans-525
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在接下来的代码片段中使用了比例索引，因为它适用于静态和动态分配的连续矩阵。回想一下，语法`m[i][j]`不能与先前讨论的内存高效连续动态分配一起使用。
- en: '[PRE57]'
  id: totrans-526
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'Here is the corresponding assembly. Each line is annotated with its English
    translation:'
  id: totrans-527
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是相应的汇编代码。每行都用其英文翻译进行了注释：
- en: '[PRE58]'
  id: totrans-528
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'The local variables `i`, `j`, and `total` are stored at stack locations `sp`
    + 20, `sp` + 24, and `sp` + 28, respectively. The input parameters `m`, `row`,
    and `cols` are stored at locations `sp` + 8, `sp` + 4, and `sp` (top of stack),
    respectively. Using this knowledge, let’s zoom in on the component that just deals
    with the access of element (*i*,*j*) in our matrix (0x8a8–0x8d8):'
  id: totrans-529
  prefs: []
  type: TYPE_NORMAL
  zh: 本地变量`i`、`j`和`total`存储在堆栈位置`sp` + 20、`sp` + 24和`sp` + 28处。输入参数`m`、`row`和`cols`存储在位置`sp`
    + 8、`sp` + 4和堆栈顶部`sp`处。有了这些知识，让我们聚焦于处理矩阵中元素（*i*,*j*）访问的组件（0x8a8–0x8d8）：
- en: '[PRE59]'
  id: totrans-530
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: The first set of instructions calculates the value `cols*i` and places it in
    register `w1`. Recall that for some matrix called `matrix`, `matrix+i*cols` is
    equivalent to `&matrix[i]`.
  id: totrans-531
  prefs: []
  type: TYPE_NORMAL
  zh: 第一组指令计算了值`cols*i`并将其放入寄存器`w1`中。回想一下，对于某个名为`matrix`的矩阵，`matrix+i*cols`等同于`&matrix[i]`。
- en: '[PRE60]'
  id: totrans-532
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: The next set of instructions computes `(cols*i + j) * 4`. The compiler multiplies
    the index `cols * i + j` by four because each element in the matrix is a four-byte
    integer, and this multiplication enables the compiler to compute the correct offset.
    The `sxtw` instruction on line `<sumMat+56>` sign-extends the contents of `w0`
    into a 64-bit integer, since that value is needed for address calculation.
  id: totrans-533
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来的指令集计算了`(cols*i + j) * 4`的值。编译器将索引`cols * i + j`乘以四，因为矩阵中的每个元素都是四字节整数，这样的乘法使编译器能够计算出正确的偏移量。第`<sumMat+56>`行的`sxtw`指令将`w0`的内容符号扩展为64位整数，因为地址计算需要这个值。
- en: 'The following set of instructions adds the calculated offset to the matrix
    pointer and dereferences it to yield the value of element (*i*,*j*):'
  id: totrans-534
  prefs: []
  type: TYPE_NORMAL
  zh: 下一组指令将计算得到的偏移量添加到矩阵指针中，并对其进行解引用，从而得到元素（*i*,*j*）的值：
- en: '[PRE61]'
  id: totrans-535
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: The first instruction loads the address of matrix `m` into register `x1`. The
    `add` instruction adds `(cols * i + j) * 4` to the address of `m` to correctly
    calculate the offset of element (*i*,*j*) and then places the result in register
    `x0`. The third instruction dereferences the address in `x0` and places the value
    (`m[i * cols + j]`) into `w0`. Notice the use of `w0` as the destination component
    register; since our matrix contains integers, and integers take up four bytes
    of space, component register `w0` is again used instead of `x0`.
  id: totrans-536
  prefs: []
  type: TYPE_NORMAL
  zh: 第一条指令将矩阵 `m` 的地址加载到寄存器 `x1` 中。`add` 指令将 `(cols * i + j) * 4` 加到 `m` 的地址上，以正确计算元素
    (*i*,*j*) 的偏移量，然后将结果放入寄存器 `x0`。第三条指令解引用 `x0` 中的地址，并将值（`m[i * cols + j]`）放入 `w0`
    中。注意 `w0` 作为目标组件寄存器的使用；由于我们的矩阵包含整数，并且整数占四个字节的空间，因此组件寄存器 `w0` 再次被用来代替 `x0`。
- en: The last three instructions load the current value of `total` into register
    `w1`, add `total` with `m[i * cols + j]`, and then update `total` with the resulting
    sum.
  id: totrans-537
  prefs: []
  type: TYPE_NORMAL
  zh: 最后三条指令将当前的 `total` 值加载到寄存器 `w1`，将 `total` 与 `m[i * cols + j]` 相加，然后用结果的和更新 `total`。
- en: Let’s consider how element (1,2) is accessed in matrix `M1`.
  id: totrans-538
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看如何访问矩阵 `M1` 中的元素 (1,2)。
- en: '![image](../images/09fig10.jpg)'
  id: totrans-539
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/09fig10.jpg)'
- en: '*Figure 9-10: Matrix `M1`’s memory layout in row-major order (reproduced from
    [Figure 9-9](ch09.xhtml#ch9fig9))*'
  id: totrans-540
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 9-10：矩阵 `M1` 按行主序排列的内存布局（摘自 [图 9-9](ch09.xhtml#ch9fig9))*'
- en: Element (1,2) is located at address `M1 + 1 * cols + 2`. Since `cols` = 3, element
    (1,2) corresponds to `M1 + 5`. To access the element at this location, the compiler
    must multiply 5 by the size of the `int` data type (four bytes), yielding the
    offset `M1 + 20`, which corresponds to byte *a*[20] in the figure. Dereferencing
    this location yields element 5, which is indeed element (1,2) in the matrix.
  id: totrans-541
  prefs: []
  type: TYPE_NORMAL
  zh: 元素 (1,2) 位于地址 `M1 + 1 * cols + 2`。由于 `cols` = 3，元素 (1,2) 对应于 `M1 + 5`。要访问这个位置的元素，编译器必须将
    5 乘以 `int` 数据类型的大小（四个字节），得到偏移量 `M1 + 20`，该偏移量对应图中字节 *a*[20]。解引用这个位置得到元素 5，这实际上就是矩阵中的元素
    (1,2)。
- en: 9.8.2 Noncontiguous Matrix
  id: totrans-542
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 9.8.2 非连续矩阵
- en: The noncontiguous matrix implementation is a bit more complicated. [Figure 9-11](ch09.xhtml#ch9fig11)
    visualizes how `M2` may be laid out in memory.
  id: totrans-543
  prefs: []
  type: TYPE_NORMAL
  zh: 非连续矩阵的实现稍微复杂一些。[图 9-11](ch09.xhtml#ch9fig11) 直观展示了 `M2` 在内存中的布局。
- en: '![image](../images/09fig11.jpg)'
  id: totrans-544
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/09fig11.jpg)'
- en: '*Figure 9-11: Matrix M2’s noncontiguous layout in memory*'
  id: totrans-545
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 9-11：矩阵 M2 在内存中的非连续布局*'
- en: Notice that the array of pointers in `M2` is contiguous, and that each array
    pointed to by some element of `M2` (e.g., `M2[i]`) is contiguous. However, the
    individual arrays are not contiguous with one another. Since `M2` is an array
    of pointers, each element of `M2` takes eight bytes of space. In contrast, since
    each `M2[i]` is an `int` array, the elements of every `M2[i]` array are four bytes
    apart.
  id: totrans-546
  prefs: []
  type: TYPE_NORMAL
  zh: 注意到 `M2` 中的指针数组是连续的，而且每个由 `M2` 的某个元素指向的数组（例如，`M2[i]`）也是连续的。然而，这些单独的数组彼此之间并不连续。由于
    `M2` 是一个指针数组，`M2` 的每个元素占用八个字节的空间。相比之下，由于每个 `M2[i]` 是一个 `int` 数组，`M2[i]` 数组中的元素之间相隔四个字节。
- en: 'The `sumMatrix` function in the following example takes an array of integer
    pointers (called `matrix`) as its first parameter, and a number of rows and columns
    as its second and third parameters:'
  id: totrans-547
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例中的 `sumMatrix` 函数将一个整数指针数组（称为 `matrix`）作为第一个参数，行数和列数作为第二个和第三个参数：
- en: '[PRE62]'
  id: totrans-548
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: Even though this function looks nearly identical to the `sumMat` function shown
    earlier, the matrix accepted by this function consists of a contiguous array of
    *pointers*. Each pointer contains the address of a separate contiguous array,
    which corresponds to a separate row in the matrix.
  id: totrans-549
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管这个函数看起来几乎与前面展示的 `sumMat` 函数相同，但该函数接受的矩阵是一个连续的 *指针* 数组。每个指针包含一个独立连续数组的地址，该数组对应矩阵中的一行。
- en: The corresponding assembly for `sumMatrix` follows. Each line is annotated with
    its English translation.
  id: totrans-550
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是 `sumMatrix` 的对应汇编代码。每行代码都有英文翻译的注释。
- en: '[PRE63]'
  id: totrans-551
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: Again, variables `i`, `j`, and `total` are at stack addresses `sp` + 20, `sp`
    + 24, and `sp` + 28, respectively. The input parameters `matrix`, `row`, and `cols`
    are located at stack addresses `sp` + 8, `sp` + 4, and `sp` (top of stack), respectively.
  id: totrans-552
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，变量 `i`、`j` 和 `total` 分别位于栈地址 `sp` + 20、`sp` + 24 和 `sp` + 28。输入参数 `matrix`、`row`
    和 `cols` 分别位于栈地址 `sp` + 8、`sp` + 4 和 `sp`（栈顶）。
- en: 'Let’s zoom in on the section that deals specifically with an access to element
    (*i*,*j*), or `matrix[i][j]`, which is between instructions 0x944 and 0x970:'
  id: totrans-553
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们聚焦于专门处理访问元素 (*i*,*j*) 或 `matrix[i][j]` 的部分，这在指令 0x944 和 0x970 之间：
- en: '[PRE64]'
  id: totrans-554
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: The five instructions in this example compute `matrix[i]`, or `*(matrix+i)`.
    Since `matrix[i]` contains a pointer, `i` is first converted to a 64-bit integer.
    Then, the compiler multiplies `i` by eight by using a shift operation and then
    adds the result to `matrix` to yield the correct address offset (recall that pointers
    are eight bytes in size). The instruction at `<sumMatrix+52>` then dereferences
    the calculated address to get the element `matrix[i]`.
  id: totrans-555
  prefs: []
  type: TYPE_NORMAL
  zh: 本示例中的五条指令计算 `matrix[i]` 或 `*(matrix+i)`。由于 `matrix[i]` 包含一个指针，`i` 首先被转换为一个 64
    位整数。然后，编译器通过使用位移操作将 `i` 乘以 8，再将结果加到 `matrix` 上，从而得到正确的地址偏移（请记住，指针的大小是 8 字节）。`<sumMatrix+52>`
    处的指令随后对计算出的地址进行解引用，以获取元素 `matrix[i]`。
- en: Since `matrix` is an array of `int` pointers, the element located at `matrix[i]`
    is itself an `int` pointer. The *j*th element in `matrix[i]` is located at offset
    `j` × 4 in the `matrix[i]` array.
  id: totrans-556
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 `matrix` 是一个 `int` 指针的数组，位于 `matrix[i]` 的元素本身就是一个 `int` 指针。`matrix[i]` 中的
    *j* 元素位于 `matrix[i]` 数组中的偏移量 `j × 4` 处。
- en: 'The next set of instructions extract the *j*th element in array `matrix[i]`:'
  id: totrans-557
  prefs: []
  type: TYPE_NORMAL
  zh: 下一组指令提取数组 `matrix[i]` 中的 *j* 元素：
- en: '[PRE65]'
  id: totrans-558
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: The first instruction in this snippet loads variable `j` into register `x0`,
    sign-extending it in the process. The compiler then uses the left shift (`lsl`)
    instruction to multiply `j` by four and stores the result in register `x0`. The
    compiler finally adds the resulting value to the address located in `matrix[i]`
    to get the address of element `matrix[i][j]`, or `&matrix[i][j]`. The instruction
    at `<sumMatrix+68>` then dereferences the address to get the *value* at `matrix[i][j]`,
    which is then stored in register `w0`. Lastly, the instructions from `<sumMatrix+72>`
    through `<sumMatrix+80>` add `total` to `matrix[i][j]` and update the variable
    `total` with the resulting sum.
  id: totrans-559
  prefs: []
  type: TYPE_NORMAL
  zh: 这个代码片段中的第一条指令将变量 `j` 加载到寄存器 `x0` 中，并在此过程中进行符号扩展。然后，编译器使用左移（`lsl`）指令将 `j` 乘以
    4，并将结果存储在寄存器 `x0` 中。编译器最后将结果加到 `matrix[i]` 所在的地址上，从而得到元素 `matrix[i][j]` 的地址，或者
    `&matrix[i][j]`。`<sumMatrix+68>` 处的指令随后对该地址进行解引用，以获取 `matrix[i][j]` 的 *值*，并将其存储在寄存器
    `w0` 中。最后，`<sumMatrix+72>` 到 `<sumMatrix+80>` 之间的指令将 `total` 加到 `matrix[i][j]`
    上，并用结果更新变量 `total`。
- en: Let’s consider an example access to `M2[1][2]`.
  id: totrans-560
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们考虑访问`M2[1][2]`的一个示例。
- en: '![image](../images/09fig12.jpg)'
  id: totrans-561
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/09fig12.jpg)'
- en: '*Figure 9-12: Matrix M2’s noncontiguous layout in memory (reproduced from [Figure
    9-11](ch09.xhtml#ch9fig11))*'
  id: totrans-562
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 9-12：矩阵 M2 在内存中的非连续布局（摘自[图 9-11](ch09.xhtml#ch9fig11)）*'
- en: Note that `M2` starts at memory location *a*[0]. The compiler first computes
    the address of `M2[1]` by multiplying 1 by 8 (`sizeof(int *)`) and adding it to
    the address of `M2` (*a*[0]), yielding the new address *a*[8]. A dereference of
    this address yields the address associated with `M2[1]`, or *a*[36]. The compiler
    then multiplies index 2 by 4 (`sizeof(int)`), and adds the result (8) to *a*[36],
    yielding a final address of *a*[44]. The address *a*[44] is dereferenced, yielding
    the value 5\. Sure enough, the element in [Figure 9-12](ch09.xhtml#ch9fig12) that
    corresponds to `M2[1][2]` has the value 5.
  id: totrans-563
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，`M2` 从内存位置 *a*[0] 开始。编译器首先通过将 1 乘以 8（`sizeof(int *)`），然后将结果加到 `M2` 的地址 (*a*[0])
    上，计算出 `M2[1]` 的地址，得到的新地址是 *a*[8]。对该地址进行解引用会得到与 `M2[1]` 相关联的地址，即 *a*[36]。然后，编译器将索引
    2 乘以 4（`sizeof(int)`），并将结果（8）加到 *a*[36] 上，得到最终地址 *a*[44]。地址 *a*[44] 被解引用，得到值 5。果然，[图
    9-12](ch09.xhtml#ch9fig12) 中对应 `M2[1][2]` 的元素值就是 5。
- en: 9.9 structs in Assembly
  id: totrans-564
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 汇编中的 9.9 结构体
- en: A `struct` (see “C Structs” on [page 103](ch02.xhtml#lev1_15)) is another way
    to create a collection of data types in C. Unlike arrays, they enable different
    data types to be grouped together. C stores a `struct` like a single-dimension
    array, where the data elements (fields) are stored contiguously.
  id: totrans-565
  prefs: []
  type: TYPE_NORMAL
  zh: '`struct`（参见[C 结构体](ch02.xhtml#lev1_15)，第 103 页）是另一种在 C 中创建数据类型集合的方式。与数组不同，它允许不同的数据类型组合在一起。C
    将 `struct` 存储得像一个一维数组，其中数据元素（字段）是连续存储的。'
- en: 'Let’s revisit `struct studentT` from [Chapter 1](ch01.xhtml#ch01):'
  id: totrans-566
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回顾一下来自[第 1 章](ch01.xhtml#ch01)的 `struct studentT`：
- en: '[PRE66]'
  id: totrans-567
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: '[Figure 9-13](ch09.xhtml#ch9fig13) shows how `student` is laid out in memory.
    Each *a*[*i*] denotes an offset in memory.'
  id: totrans-568
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 9-13](ch09.xhtml#ch9fig13) 显示了 `student` 在内存中的布局。每个 *a*[*i*] 表示内存中的一个偏移量。'
- en: '![image](../images/09fig13.jpg)'
  id: totrans-569
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/09fig13.jpg)'
- en: '*Figure 9-13: The memory layout of `struct studentT`*'
  id: totrans-570
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 9-13：`struct studentT` 的内存布局*'
- en: Each field is stored contiguously next to one another in memory in the order
    in which they are declared. In [Figure 9-13](ch09.xhtml#ch9fig13), the `age` field
    is allocated at the memory location directly after the `name` field (at byte offset
    *a*[64]) and is followed by the `grad_yr` (byte offset *a*[68]) and `gpa` (byte
    offset *a*[72]) fields. This organization enables memory-efficient access to the
    fields.
  id: totrans-571
  prefs: []
  type: TYPE_NORMAL
  zh: 每个字段都按照声明的顺序在内存中连续存储。在[图9-13](ch09.xhtml#ch9fig13)中，`age`字段被分配在紧接着`name`字段的位置（字节偏移量
    *a*[64]），后面是`grad_yr`（字节偏移量 *a*[68]）和`gpa`（字节偏移量 *a*[72]）字段。这种组织方式使得访问字段时能够高效利用内存。
- en: 'To understand how the compiler generates assembly code to work with a `struct`,
    consider the function `initStudent`:'
  id: totrans-572
  prefs: []
  type: TYPE_NORMAL
  zh: 要理解编译器如何生成汇编代码以处理`struct`，请考虑`initStudent`函数：
- en: '[PRE67]'
  id: totrans-573
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'The `initStudent` function uses the base address of a `struct studentT` as
    its first parameter, and the desired values for each field as its remaining parameters.
    The following listing depicts this function in assembly:'
  id: totrans-574
  prefs: []
  type: TYPE_NORMAL
  zh: '`initStudent`函数将`struct studentT`的基地址作为第一个参数，剩余的参数是每个字段的期望值。以下清单展示了该函数的汇编代码：'
- en: '[PRE68]'
  id: totrans-575
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: Being mindful of the byte offsets of each field is key to understanding this
    code. Here are a few things to keep in mind.
  id: totrans-576
  prefs: []
  type: TYPE_NORMAL
  zh: 注意每个字段的字节偏移量对于理解这段代码至关重要。这里有一些要记住的事项。
- en: The `strncpy` call takes the base address of the `name` field of `s`, the address
    of array `nm`, and a length specifier as its three arguments. Recall that since
    `name` is the first field in `struct studentT`, the address of `s` is synonymous
    with the address of `s->name`.
  id: totrans-577
  prefs: []
  type: TYPE_NORMAL
  zh: '`strncpy`调用将`s`的`name`字段的基地址、数组`nm`的地址以及长度指定符作为三个参数。请回想一下，由于`name`是`struct
    studentT`中的第一个字段，`s`的地址即等同于`s->name`的地址。'
- en: '[PRE69]'
  id: totrans-578
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: The above code snippet contains an undiscussed register (`s0`). The `s0` register
    is an example of a register reserved for floating point values.
  id: totrans-579
  prefs: []
  type: TYPE_NORMAL
  zh: 上面的代码片段包含了一个未讨论的寄存器（`s0`）。`s0`寄存器是一个为浮点值保留的寄存器的例子。
- en: The next part (instructions `<initStudent+44>` through `<initStudent+52>`) places
    the value of the `gr` parameter at an offset of 68 from the start of `s`. Revisiting
    the memory layout of the struct in [Figure 9-13](ch09.xhtml#ch9fig13) shows that
    this address corresponds to `s->grad_yr`.
  id: totrans-580
  prefs: []
  type: TYPE_NORMAL
  zh: 下一部分（指令 `<initStudent+44>` 到 `<initStudent+52>`）将`gr`参数的值放置在`s`的起始地址偏移量68的位置。回顾[图9-13](ch09.xhtml#ch9fig13)中的内存布局，可以看到该地址对应于`s->grad_yr`。
- en: '[PRE70]'
  id: totrans-581
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: The next section (instructions `<initStudent+56>` through `<initStudent+64>`)
    copies the `ag` parameter to the `s->age` field, which is located at an offset
    of 64 bytes from the address of `s`.
  id: totrans-582
  prefs: []
  type: TYPE_NORMAL
  zh: 下一部分（指令 `<initStudent+56>` 到 `<initStudent+64>`）将`ag`参数复制到`s->age`字段，该字段位于`s`地址的偏移量64字节处。
- en: '[PRE71]'
  id: totrans-583
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'Lastly, the `g` parameter value is copied to the `s->gpa` field (byte offset
    72). Notice the use of the `s0` register given that the data contained at location
    `x29` + 20 is single-precision floating point:'
  id: totrans-584
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，`g`参数的值被复制到`s->gpa`字段（字节偏移量72）。请注意，由于位于位置`x29` + 20的数据显示的是单精度浮点数，因此使用了`s0`寄存器：
- en: '[PRE72]'
  id: totrans-585
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 9.9.1 Data Alignment and structs
  id: totrans-586
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 9.9.1 数据对齐与结构体
- en: 'Consider the following modified declaration of `studentT`:'
  id: totrans-587
  prefs: []
  type: TYPE_NORMAL
  zh: 请考虑以下修改后的`studentT`声明：
- en: '[PRE73]'
  id: totrans-588
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: The size of the `name` field is modified to be 63 bytes, instead of the original
    64 bytes. Consider how this affects the way the `struct` is laid out in memory.
    It may be tempting to visualize it as in [Figure 9-14](ch09.xhtml#ch9fig14).
  id: totrans-589
  prefs: []
  type: TYPE_NORMAL
  zh: '`name`字段的大小被修改为63字节，而不是原来的64字节。考虑一下这如何影响`struct`在内存中的布局。你可能会忍不住想像成[图9-14](ch09.xhtml#ch9fig14)中的样子。'
- en: '![image](../images/09fig14.jpg)'
  id: totrans-590
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/09fig14.jpg)'
- en: '*Figure 9-14: An incorrect memory layout for the updated `struct` `studentTM`.
    Note that the `name` field is reduced from 64 to 63 bytes.*'
  id: totrans-591
  prefs: []
  type: TYPE_NORMAL
  zh: '*图9-14：更新后的`struct` `studentTM`的内存布局不正确。请注意，`name`字段已从64字节减少到63字节。*'
- en: In this depiction, the `age` field occurs in the byte immediately following
    the `name` field. But this is incorrect. [Figure 9-15](ch09.xhtml#ch9fig15) depicts
    the actual layout in memory.
  id: totrans-592
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个图示中，`age`字段出现在紧接着`name`字段的字节后面。但这是不正确的。[图9-15](ch09.xhtml#ch9fig15)显示了内存中实际的布局。
- en: '![image](../images/09fig15.jpg)'
  id: totrans-593
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/09fig15.jpg)'
- en: '*Figure 9-15: The correct memory layout for the updated `struct` `studentTM`.
    Byte *a*[63] is added by the compiler to satisfy memory alignment constraints,
    but it doesn’t correspond to any of the fields.*'
  id: totrans-594
  prefs: []
  type: TYPE_NORMAL
  zh: '*图9-15：更新后的`struct` `studentTM`的正确内存布局。编译器为满足内存对齐约束，添加了字节 *a*[63]，但它并不对应任何字段。*'
- en: A64’s alignment policy requires that four-byte data types (e.g., `int`) reside
    at addresses that are a multiple of four, whereas 64-bit data types (`long`, `double`,
    and pointer data) reside at addresses that are a multiple of eight. For a `struct`,
    the compiler adds empty bytes as “padding” between fields to ensure that each
    field satisfies its alignment requirements. For example, in the `struct` declared
    in the previous code snippet, the compiler adds a byte of padding at byte *a*[63]
    to ensure that the `age` field starts at an address that is at a multiple of four.
    Values aligned properly in memory can be read or written in a single operation,
    enabling greater efficiency.
  id: totrans-595
  prefs: []
  type: TYPE_NORMAL
  zh: A64的对齐策略要求四字节数据类型（例如`int`）位于地址是四的倍数的位置，而64位数据类型（`long`、`double`和指针数据）则位于地址是八的倍数的位置。对于`struct`，编译器在字段之间添加空字节作为“填充”，以确保每个字段满足其对齐要求。例如，在之前代码片段中声明的`struct`中，编译器在字节*a*[63]处添加一个填充字节，以确保`age`字段从一个四的倍数地址开始。正确对齐的值可以通过单次操作进行读写，从而提高效率。
- en: 'Consider what happens when the `struct` is defined as the following:'
  id: totrans-596
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑当`struct`定义如下时会发生什么情况：
- en: '[PRE74]'
  id: totrans-597
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: Moving the `name` array to the end ensures that `age`, `grad_yr`, and `gpa`
    are four-byte aligned. Most compilers will remove the filler byte at the end of
    the `struct`. However, if the `struct` is ever used in the context of an array
    (e.g., `struct studentTM courseSection[20];`) the compiler will again add the
    filler byte as padding between each `struct` in the array to ensure that alignment
    requirements are properly met.
  id: totrans-598
  prefs: []
  type: TYPE_NORMAL
  zh: 将`name`数组移到末尾，确保`age`、`grad_yr`和`gpa`对齐为四字节。大多数编译器将去掉`struct`末尾的填充字节。然而，如果`struct`被用在数组的上下文中（例如，`struct
    studentTM courseSection[20];`），编译器会再次在数组中的每个`struct`之间添加填充字节，以确保正确满足对齐要求。
- en: '9.10 Real World: Buffer Overflow'
  id: totrans-599
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 9.10 现实世界：缓冲区溢出
- en: The C language does not perform automatic array bounds checking. Accessing memory
    outside of the bounds of an array is problematic and often results in errors such
    as segmentation faults. However, a clever attacker can inject malicious code that
    intentionally overruns the boundary of an array (also known as a *buffer*) to
    force the program to execute in an unintended manner. In the worst cases, the
    attacker can run code that allows them to gain *root privilege*, or OS-level access
    to the computer system. A piece of software that takes advantage of the existence
    of a known buffer overrun error in a program is known as a *buffer overflow exploit*.
  id: totrans-600
  prefs: []
  type: TYPE_NORMAL
  zh: C语言不执行自动数组边界检查。访问数组边界之外的内存是有问题的，并且通常会导致诸如段错误之类的错误。然而，巧妙的攻击者可以注入恶意代码，故意使数组（也称为*缓冲区*）越界，从而迫使程序以非预期的方式执行。在最坏的情况下，攻击者可以运行代码，允许他们获取*root权限*，即操作系统级别的访问权限。一种利用程序中已知的缓冲区溢出错误的漏洞的软件称为*缓冲区溢出攻击*。
- en: In this section, we use GDB and assembly language to fully characterize the
    mechanics of a buffer overflow exploit. Prior to reading this chapter we encourage
    you to explore “Debugging Assembly Code” on [page 177](ch03.xhtml#lev1_24).
  id: totrans-601
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将使用GDB和汇编语言来全面描述缓冲区溢出攻击的机制。在阅读本章之前，我们鼓励您先阅读“调试汇编代码”部分，参见[第177页](ch03.xhtml#lev1_24)。
- en: 9.10.1 Famous Examples of Buffer Overflow
  id: totrans-602
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 9.10.1 缓冲区溢出的著名示例
- en: Buffer overflow exploits emerged in the 1980s and remained a chief scourge of
    the computing industry through the early parts of the 2000s. Even though many
    modern operating systems have protections against the simplest buffer overflow
    attacks, careless programming errors can still leave modern programs wide open
    to attack. Buffer overflow exploits have recently been discovered in Skype,^([6](ch09.xhtml#fn9_6))
    Android,^([7](ch09.xhtml#fn9_7)) Google Chrome,^([8](ch09.xhtml#fn9_8)) and others.
  id: totrans-603
  prefs: []
  type: TYPE_NORMAL
  zh: 缓冲区溢出攻击在1980年代出现，并在2000年代初期持续成为计算机行业的主要祸害。尽管许多现代操作系统已经对最简单的缓冲区溢出攻击进行了防护，但不小心的编程错误仍然会让现代程序面临严重的攻击风险。最近在Skype^([6](ch09.xhtml#fn9_6))、Android^([7](ch09.xhtml#fn9_7))、Google
    Chrome^([8](ch09.xhtml#fn9_8))等程序中发现了缓冲区溢出攻击。
- en: Here are some notable historic examples of buffer overflow exploits.
  id: totrans-604
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是一些缓冲区溢出攻击的著名历史示例。
- en: The Morris Worm
  id: totrans-605
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 莫里斯蠕虫
- en: The Morris Worm^([9](ch09.xhtml#fn9_9)) was released in 1998 on ARPANet from
    MIT (to hide that it was written by a student at Cornell) and exploited a buffer
    overrun vulnerability that existed in the Unix finger daemon (`fingerd`). In Linux
    and other Unix-like systems, a *daemon* is a type of process that continuously
    executes in the background, usually performing clean-up and monitoring tasks.
    The `fingerd` daemon returns a user-friendly report on a computer or person. Most
    crucially, the worm had a replication mechanism that caused it to be sent to the
    same computer multiple times, bogging down the system to an unusable state. Even
    though the author claimed that the worm was meant as a harmless intellectual exercise,
    the replication mechanism enabled the worm to spread easily and made it difficult
    to remove. In future years, other worms would employ buffer overflow exploits
    to gain unauthorized access into systems. Notable examples include Code Red (2001),
    MS-SQLSlammer (2003), and W32/Blaster (2003).
  id: totrans-606
  prefs: []
  type: TYPE_NORMAL
  zh: 莫里斯蠕虫^([9](ch09.xhtml#fn9_9))于1998年在MIT的ARPANet上发布（为了掩盖它是由康奈尔大学的一名学生编写的），并利用了Unix指纹守护进程（`fingerd`）中的缓冲区溢出漏洞。在Linux和其他类Unix系统中，*守护进程*是一种持续在后台运行的进程，通常执行清理和监控任务。`fingerd`守护进程提供有关计算机或用户的友好报告。最关键的是，蠕虫具有一种复制机制，使其能够多次发送到同一计算机，导致系统变得无法使用。尽管作者声称该蠕虫本意是作为一种无害的智力练习，但其复制机制使得蠕虫能够轻松传播，并且很难清除。在随后的几年中，其他蠕虫也使用缓冲区溢出漏洞来非法访问系统。著名的例子包括Code
    Red（2001年）、MS-SQLSlammer（2003年）和W32/Blaster（2003年）。
- en: AOL Chat Wars
  id: totrans-607
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: AOL 聊天战争
- en: David Auerbach,^([10](ch09.xhtml#fn9_10)) a former Microsoft engineer, detailed
    his experience with a buffer overflow during his efforts to integrate Microsoft’s
    Messenger Service (MMS) with AOL Instant Messenger in the late 1990s. Back then,
    AOL Instant Messenger (AIM) was *the* service to use if you wanted to instant
    message (or IM) friends and family. Microsoft tried to gain a foothold in this
    market by designing a feature in MMS that enabled MMS users to talk to their AIM
    “buddies.” Displeased, AOL patched their servers so that MMS could no longer connect
    to them. Microsoft engineers figured out a way for MMS clients to mimic the messages
    sent by AIM clients to AOL servers, making it difficult for AOL to distinguish
    between messages received by MMS and AIM. AOL responded by changing the way AIM
    sent messages, and MMS engineers duly changed their client’s messages to once
    again match AIM’s. This “chat war” continued until AOL started using a buffer
    overflow error *in their own client* to verify that sent messages came from AIM
    clients. Since MMS clients did not have the same vulnerability, the chat wars
    ended, with AOL as the victor.
  id: totrans-608
  prefs: []
  type: TYPE_NORMAL
  zh: 大卫·奥尔巴赫（David Auerbach）^([10](ch09.xhtml#fn9_10))，前微软工程师，详细描述了他在将微软的Messenger服务（MMS）与AOL即时通讯（AIM）在1990年代末期进行集成时遇到的缓冲区溢出问题。当时，如果你想和朋友或家人进行即时消息聊天，AOL即时通讯（AIM）是*首选*服务。微软试图通过在MMS中设计一个功能，使得MMS用户能够与他们的AIM“好友”进行对话，从而在该市场中占有一席之地。AOL对此不满，修补了他们的服务器，防止MMS再与其连接。微软工程师找到了让MMS客户端模拟AIM客户端发送给AOL服务器的消息的方法，从而使AOL难以区分由MMS和AIM接收到的消息。AOL回应通过改变AIM消息发送方式，MMS工程师也相应修改了他们的客户端消息，以再次与AIM的消息一致。这场“聊天战争”持续了下去，直到AOL开始在*他们自己的客户端*中使用缓冲区溢出错误来验证发送的消息是否来自AIM客户端。由于MMS客户端没有相同的漏洞，聊天战争最终结束，AOL成为了赢家。
- en: '9.10.2 A First Look: The Guessing Game'
  id: totrans-609
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 9.10.2 初探：猜谜游戏
- en: 'To help you understand the mechanism of the buffer overflow attack, we provide
    an executable of a simple program that enables the user to play a guessing game
    with the program. Download the `secret` executable^([11](ch09.xhtml#fn9_11)) and
    extract it using the `tar` command:'
  id: totrans-610
  prefs: []
  type: TYPE_NORMAL
  zh: 为了帮助你理解缓冲区溢出攻击的机制，我们提供了一个简单程序的可执行文件，用户可以通过它与程序进行猜谜游戏。下载`secret`可执行文件^([11](ch09.xhtml#fn9_11))并使用`tar`命令解压：
- en: '[PRE75]'
  id: totrans-611
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: 'In the following, we provide a copy of the main file associated with the executable:'
  id: totrans-612
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是与该可执行文件相关的主文件副本：
- en: main.c
  id: totrans-613
  prefs: []
  type: TYPE_NORMAL
  zh: main.c
- en: '[PRE76]'
  id: totrans-614
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: This game prompts the user to enter first a secret number and then a secret
    string to win the guessing game. The header file `other.h` contains the definition
    of the `getSecretCode` and `calculateValue` functions, but it is unavailable to
    us. How then can a user beat the program? Brute forcing the solution will take
    too long. One strategy is to analyze the `secret` executable in GDB and step through
    the assembly to reveal the secret number and string. The process of examining
    assembly code to reveal knowledge of how it works is commonly referred to as *reverse
    engineering*. Readers comfortable enough with GDB and reading assembly should
    be able to use GDB to reverse engineer the secret number and the secret string.
  id: totrans-615
  prefs: []
  type: TYPE_NORMAL
  zh: 这个游戏提示用户先输入一个秘密数字，然后输入一个秘密字符串来赢得猜谜游戏。头文件 `other.h` 包含了 `getSecretCode` 和 `calculateValue`
    函数的定义，但我们无法访问它。那么，用户该如何战胜这个程序呢？暴力破解解决方案需要很长时间。一个策略是通过 GDB 分析 `secret` 可执行文件，并逐步查看汇编代码以揭示秘密数字和字符串。检查汇编代码以揭示它如何工作的过程通常称为
    *逆向工程*。对 GDB 和汇编代码阅读足够熟悉的读者应该能够使用 GDB 逆向工程出秘密数字和秘密字符串。
- en: However, there is a different, sneakier way to win.
  id: totrans-616
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，有一种不同的、更狡猾的方式可以获胜。
- en: 9.10.3 Taking a Closer Look (Under the C)
  id: totrans-617
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 9.10.3 更深入的了解（C 之下）
- en: 'The program contains a potential buffer overrun vulnerability at the first
    call to `scanf`. To understand what is going on, let’s inspect the assembly code
    of the `main` function using GDB. Let’s also place a breakpoint at address 0x0000aaaaaaaaa92c,
    which is the address of the instruction right before the call to `scanf` (placing
    the breakpoint at the address for `scanf` causes program execution to halt *inside*
    the call to `scanf`, not in `main`) and then use `ni` to advance forward one instruction:'
  id: totrans-618
  prefs: []
  type: TYPE_NORMAL
  zh: 程序在第一次调用 `scanf` 时包含了潜在的缓冲区溢出漏洞。为了理解发生了什么，我们通过 GDB 检查 `main` 函数的汇编代码。我们还将设置一个断点，地址为
    0x0000aaaaaaaaa92c，这是调用 `scanf` 之前指令的地址（将断点设置在 `scanf` 的地址会导致程序执行在 `scanf` 调用*内部*暂停，而不是在
    `main` 中暂停），然后使用 `ni` 命令逐步执行一条指令：
- en: '[PRE77]'
  id: totrans-619
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: '[Figure 9-16](ch09.xhtml#ch9fig16) depicts the stack immediately before the
    call to `scanf`.'
  id: totrans-620
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 9-16](ch09.xhtml#ch9fig16) 展示了在调用 `scanf` 之前的栈状态。'
- en: '![image](../images/09fig16.jpg)'
  id: totrans-621
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/09fig16.jpg)'
- en: '*Figure 9-16: The call stack immediately before the call to `scanf`*'
  id: totrans-622
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 9-16：调用 `scanf` 之前的调用栈*'
- en: Prior to the call to `scanf`, the first two arguments for `scanf` are preloaded
    into registers `x0` and `x1`, respectively. The address of array `buf` is stored
    at stack location `x29` + 0x18 (see `<playGame+28>`).
  id: totrans-623
  prefs: []
  type: TYPE_NORMAL
  zh: 在调用 `scanf` 之前，`scanf` 的前两个参数分别已预加载到寄存器 `x0` 和 `x1` 中。数组 `buf` 的地址存储在栈位置 `x29`
    + 0x18（见 `<playGame+28>`）。
- en: Now, suppose that the user enters `1234567890` at the prompt. [Figure 9-17](ch09.xhtml#ch9fig17)
    illustrates what the stack looks like immediately after the call to `scanf` completes.
  id: totrans-624
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，假设用户在提示符下输入 `1234567890`。[图 9-17](ch09.xhtml#ch9fig17) 展示了在调用 `scanf` 完成后栈的状态。
- en: '![image](../images/09fig17.jpg)'
  id: totrans-625
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/09fig17.jpg)'
- en: '*Figure 9-17: The call stack immediately after the call to `scanf` with input
    `1234567890`*'
  id: totrans-626
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 9-17：调用 `scanf` 并输入 `1234567890` 后的调用栈*'
- en: 'Recall that the hex values for the ASCII encodings of the digits 0 to 9 are
    0x30 to 0x39, and that each stack memory location is eight bytes long. The frame
    pointer for `main` is 56 bytes away from the stack pointer. Readers tracing along
    can confirm the value of `x29` by using GDB to print its value (`p x29`). In the
    example shown, the saved value of `x29` is 0xffffffffeef0\. The following command
    allows the reader to inspect the 64 bytes (in hex) below register `sp`:'
  id: totrans-627
  prefs: []
  type: TYPE_NORMAL
  zh: 请回想，数字 0 到 9 的 ASCII 编码的十六进制值是 0x30 到 0x39，并且每个栈内存位置的长度为 8 字节。`main` 函数的帧指针距离栈指针
    56 字节。读者可以通过使用 GDB 打印 `x29` 的值（`p x29`）来确认其值。在所示的示例中，`x29` 保存的值是 0xffffffffeef0。以下命令允许读者检查位于寄存器
    `sp` 下面 64 字节（以十六进制表示）的内容：
- en: '[PRE78]'
  id: totrans-628
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: 'This GDB command yields output that looks similar to the following:'
  id: totrans-629
  prefs: []
  type: TYPE_NORMAL
  zh: 这个 GDB 命令的输出将类似于以下内容：
- en: '[PRE79]'
  id: totrans-630
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: Each line represents one 64-bit address, or two 32-bit addresses. So, the value
    associated with the 32-bit address 0xffffffffeedc is located at the rightmost
    four bytes of the line showing 0xffffffffeed8.
  id: totrans-631
  prefs: []
  type: TYPE_NORMAL
  zh: 每一行代表一个 64 位地址，或者两个 32 位地址。因此，关联到 32 位地址 0xffffffffeedc 的值位于显示 0xffffffffeed8
    的行的最右侧四个字节中。
- en: '**Note MULTIBYTE VALUES ARE STORED IN LITTLE-ENDIAN ORDER**'
  id: totrans-632
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意 多字节值按小端顺序存储**'
- en: In the preceding assembly segment, the byte at address 0xffffffffeec0 is 0xf0,
    the byte at address 0xffffffffeec1 is 0xee, the byte at address 0xffffffffeec2
    is 0xff, the byte at address 0xffffffffeec3 is 0xff, the byte at address 0xffffffffeec4
    is 0xff, and the byte at address 0xffffffffeec5 is 0xff. However, the 64-bit *value*
    at address 0xffffffffeec0 is in fact 0xffffffffeef0\. Remember that because ARM64
    is a little-endian system by default (see “Integer Byte Order” on [page 224](ch04.xhtml#lev1_34)),
    the bytes for multibyte values such as addresses are stored in reverse order.
  id: totrans-633
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的汇编段中，地址0xffffffffeec0处的字节是0xf0，地址0xffffffffeec1处的字节是0xee，地址0xffffffffeec2处的字节是0xff，地址0xffffffffeec3处的字节是0xff，地址0xffffffffeec4处的字节是0xff，地址0xffffffffeec5处的字节是0xff。然而，地址0xffffffffeec0处的64位*值*实际上是0xffffffffeef0。请记住，由于ARM64默认是小端系统（参见[第224页](ch04.xhtml#lev1_34)的“整数字节顺序”），多字节值（如地址）的字节以相反的顺序存储。
- en: 'In this example, the address for `buf` is located at address 0xffffffffeed8\.
    Therefore, the following two addresses hold the bytes associated with input string
    `1234567890`:'
  id: totrans-634
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，`buf`的地址位于地址0xffffffffeed8。因此，以下两个地址保存了与输入字符串`1234567890`相关的字节：
- en: '[PRE80]'
  id: totrans-635
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: The null termination byte `\0` appears in the third byte location at address
    0xffffffffeee2\. Recall that `scanf` terminates all strings with a null byte.
  id: totrans-636
  prefs: []
  type: TYPE_NORMAL
  zh: 空终止字节`\0`出现在地址0xffffffffeee2的第三个字节位置。回想一下，`scanf`会用一个空字节来终止所有字符串。
- en: 'Of course, `1234567890` is not the secret number. Here is the output when we
    try to run `secret` with input string `1234567890`:'
  id: totrans-637
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，`1234567890`不是秘密数字。当我们尝试使用输入字符串`1234567890`运行`secret`时，输出如下：
- en: '[PRE81]'
  id: totrans-638
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: The `echo $?` command prints out the return value of the last executed command
    in the shell. In this case, the program returned 1, because the secret number
    we entered is wrong. Recall that by convention, programs return 0 when there are
    no errors. Our goal going forward is to trick the program to exit with a 0 return
    value, indicating that we won the game.
  id: totrans-639
  prefs: []
  type: TYPE_NORMAL
  zh: '`echo $?`命令打印出最后执行的命令的返回值。在这种情况下，程序返回1，因为我们输入的秘密数字是错误的。回想一下，根据惯例，当程序没有错误时，会返回0。我们的目标是让程序以返回值0退出，表明我们赢得了游戏。'
- en: '9.10.4 Buffer Overflow: First Attempt'
  id: totrans-640
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 9.10.4 缓冲区溢出：第一次尝试
- en: 'Next, let’s try typing in the string 12345678901234567890123456789012345:'
  id: totrans-641
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们尝试输入字符串`12345678901234567890123456789012345`：
- en: '[PRE82]'
  id: totrans-642
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: Interesting! Now the program crashes with a bus error (another type of memory
    error), with return code 139\. [Figure 9-18](ch09.xhtml#ch9fig18) shows what the
    call stack for `main` looks like immediately after the call to `scanf` with this
    new input.
  id: totrans-643
  prefs: []
  type: TYPE_NORMAL
  zh: 真有趣！现在程序因总线错误（另一种类型的内存错误）崩溃，返回代码为139。[图9-18](ch09.xhtml#ch9fig18)展示了调用`scanf`并输入这个新字符串后的`main`函数调用栈。
- en: '![image](../images/09fig18.jpg)'
  id: totrans-644
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/09fig18.jpg)'
- en: '*Figure 9-18: The call stack immediately after the call to `scanf` with input
    `12345678901234567890123456789012345`*'
  id: totrans-645
  prefs: []
  type: TYPE_NORMAL
  zh: '*图9-18：调用`scanf`并输入`12345678901234567890123456789012345`后的调用栈*'
- en: The input string is so long that it not only overwrote the saved `x29` stored
    at address 0xeed8, but it spilled over into the return address below the stack
    frame for `main`. Recall that when a function returns, the program tries to resume
    execution at the address specified by the return address. In this example, the
    program tries to resume execution at address 0xffff00353433 after exiting `main`,
    which does not appear to exist. So the program crashes with a bus error.
  id: totrans-646
  prefs: []
  type: TYPE_NORMAL
  zh: 输入字符串过长，不仅覆盖了保存在地址0xeed8处的`x29`，还溢出了`main`栈帧下方的返回地址。回想一下，当函数返回时，程序会尝试从返回地址指定的位置恢复执行。在这个例子中，程序试图在退出`main`后从地址0xffff00353433恢复执行，但该地址似乎不存在。所以程序因总线错误崩溃。
- en: 'Rerunning the program in GDB (`input.txt` contains the input string above)
    reveals this devilry in action:'
  id: totrans-647
  prefs: []
  type: TYPE_NORMAL
  zh: 在GDB中重新运行程序（`input.txt`包含上述输入字符串）揭示了这个恶作剧的行为：
- en: '[PRE83]'
  id: totrans-648
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: Notice that our input string blew past the stated limits of the array `buf`,
    overwriting all the other values stored on the stack. In other words, our string
    created a buffer overrun and corrupted the call stack, causing the program to
    crash. This process is also known as *smashing the stack*.
  id: totrans-649
  prefs: []
  type: TYPE_NORMAL
  zh: 注意到我们的输入字符串超出了`buf`数组的预定限制，覆盖了栈上存储的所有其他值。换句话说，我们的字符串创建了一个缓冲区溢出并破坏了调用栈，导致程序崩溃。这个过程也被称为*栈溢出攻击*。
- en: '9.10.5 A Smarter Buffer Overflow: Second Attempt'
  id: totrans-650
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 9.10.5 更聪明的缓冲区溢出：第二次尝试
- en: Our first example smashed the stack by overwriting the saved `x29` register
    and return address for `main` with junk, causing the program to crash. An attacker
    whose goal is to simply crash a program would be satisfied at this point. However,
    our goal is to trick the guessing game to return 0, indicating that we won the
    game. We accomplish this by filling the call stack with data more meaningful than
    junk values. For example, we could overwrite the stack so that the return address
    is replaced with the address of `endGame`. Then, when the program attempts to
    return from `main`, it will instead execute `endGame` instead of crashing.
  id: totrans-651
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的第一个例子通过用垃圾值覆盖保存的`x29`寄存器和`main`函数的返回地址来破坏了堆栈，导致程序崩溃。一个只想使程序崩溃的攻击者在这一点上可能会感到满意。然而，我们的目标是欺骗猜谜游戏返回0，表示我们赢得了比赛。我们通过填充调用堆栈使其充满比垃圾值更有意义的数据来实现这一点。例如，我们可以覆盖堆栈，使返回地址被替换为`endGame`的地址。然后，当程序试图从`main`返回时，它将执行`endGame`而不是崩溃。
- en: 'To find out the address of `endGame`, let’s inspect `secret` again in GDB:'
  id: totrans-652
  prefs: []
  type: TYPE_NORMAL
  zh: 要找出`endGame`的地址，请再次在GDB中检查`secret`：
- en: '[PRE84]'
  id: totrans-653
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: Observe that `endGame` starts at address 0x0000aaaaaaaaa8ec. [Figure 9-19](ch09.xhtml#ch9fig19)
    illustrates a sample exploit that forces `secret` to run the `endGame` function.
  id: totrans-654
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，`endGame`的地址为0x0000aaaaaaaaa8ec。[图9-19](ch09.xhtml#ch9fig19)说明了一个示例利用程序，强制`secret`运行`endGame`函数的漏洞利用。
- en: '![image](../images/09fig19.jpg)'
  id: totrans-655
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/09fig19.jpg)'
- en: '*Figure 9-19: A sample string that can force `secret` to execute the `endGame`
    function*'
  id: totrans-656
  prefs: []
  type: TYPE_NORMAL
  zh: '*图9-19：一个可以强制`secret`执行`endGame`函数的示例字符串*'
- en: Essentially, there are 32 bytes of junk values followed by the return address.
    Again, because ARM64 is a little-endian system by default, the bytes in the return
    address appear to be in reverse order.
  id: totrans-657
  prefs: []
  type: TYPE_NORMAL
  zh: 本质上，有32字节的垃圾值，然后是返回地址。再次强调，因为ARM64默认是小端系统，返回地址中的字节看起来是反向的。
- en: 'The following program illustrates how an attacker could construct the preceding
    exploit:'
  id: totrans-658
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的程序说明了攻击者如何构建上述漏洞利用：
- en: '[PRE85]'
  id: totrans-659
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: 'The `\x` before each number indicates that the number is formatted as the hexadecimal
    representation for a character. After defining `ebuff[]`, the `main` function
    simply prints it out, character by character. To get the associated byte string,
    compile and run this program as follows:'
  id: totrans-660
  prefs: []
  type: TYPE_NORMAL
  zh: 每个数字前面的`\x`表示该数字格式化为字符的十六进制表示。在定义`ebuff[]`之后，`main`函数只是简单地逐个字符地打印它。要获取关联的字节字符串，请编译并运行以下程序：
- en: '[PRE86]'
  id: totrans-661
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: 'To use `exploit` as input to `scanf`, it suffices to run `secret` with `exploit`.
    To get the exploit to work on a Raspberry Pi, type the following set of commands
    as root (we will explain what is going on following the example):'
  id: totrans-662
  prefs: []
  type: TYPE_NORMAL
  zh: 要将`exploit`作为`scanf`的输入使用，只需在树莓派上运行带有`exploit`的`secret`。要使漏洞利用在树莓派上生效，请作为root键入以下一组命令（我们将在示例之后解释正在进行的操作）：
- en: '[PRE87]'
  id: totrans-663
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: The `sudo su` command puts you in root mode on the Raspberry Pi. When prompted
    for a password, use your password (we assume you have root access to the Raspberry
    Pi). As soon as the password is entered, the next set of commands are typed in
    root mode. Note that the command prompt changes when a user is in root mode (it
    looks something like `root@pi#`).
  id: totrans-664
  prefs: []
  type: TYPE_NORMAL
  zh: '`sudo su`命令会将您置于树莓派的root模式。在提示输入密码时，请使用您的密码（我们假设您对树莓派具有root访问权限）。一旦输入密码，接下来的命令将在root模式下键入。请注意，当用户处于root模式时，命令提示符会改变（看起来类似于`root@pi#`）。'
- en: The `echo` command overwrites the contents of the file `randomize_va_space`
    with the value 0\. Next, the `exit` command returns the user back to user mode.
  id: totrans-665
  prefs: []
  type: TYPE_NORMAL
  zh: '`echo`命令会用值0覆盖文件`randomize_va_space`的内容。接下来，`exit`命令将用户返回到用户模式。'
- en: 'Now, type the following command at the prompt:'
  id: totrans-666
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在提示符下键入以下命令：
- en: '[PRE88]'
  id: totrans-667
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: The program prints out “You are so wrong!” because the string contained in `exploit`
    is *not* the secret number. However, the program also prints out the string “You
    win!” Recall, though, that our goal is to trick the program to return 0\. In a
    larger system, where the notion of “success” is tracked by an external program,
    it is often most important what a program returns, not what it prints out.
  id: totrans-668
  prefs: []
  type: TYPE_NORMAL
  zh: 程序会打印出“你错了！”因为`exploit`中包含的字符串*不是*秘密数字。但是，程序也会打印出字符串“你赢了！”请记住，我们的目标是欺骗程序返回0。在一个更大的系统中，成功的概念由外部程序跟踪，通常更重要的是程序返回的内容，而不是打印出的内容。
- en: 'Checking the return value yields:'
  id: totrans-669
  prefs: []
  type: TYPE_NORMAL
  zh: 检查返回值会得到：
- en: '[PRE89]'
  id: totrans-670
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: Our exploit works! We won the game!
  id: totrans-671
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的攻击成功了！我们赢了比赛！
- en: 9.10.6 Protecting Against Buffer Overflow
  id: totrans-672
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 9.10.6 缓冲区溢出防护
- en: 'The example we showed changed the control flow of the `secret` executable,
    forcing it to return a zero value associated with success. We had to accomplish
    this in a fairly wonky way due to stack protections that ARM and GCC include to
    combat this particular type of attack. However, buffer overflow exploits can do
    real damage on older systems. Some older computer systems also *executed* bytes
    from stack memory. If an attacker placed bytes associated with assembly instructions
    on the call stack, the CPU would interpret the bytes as *real* instructions, enabling
    the attacker to force the CPU to execute *any arbitrary code of their choosing*.
    Fortunately, there are strategies that modern computer systems employ to make
    it more difficult for attackers to run buffer overflow exploits:'
  id: totrans-673
  prefs: []
  type: TYPE_NORMAL
  zh: 我们展示的例子改变了`secret`可执行文件的控制流，迫使它返回一个与成功相关的零值。由于ARM和GCC包含的堆栈保护措施，旨在防止这种特定类型的攻击，我们不得不通过一种相当笨拙的方式来实现这一点。然而，缓冲区溢出攻击在旧系统上可能会造成实际损害。一些旧计算机系统也会从堆栈内存中*执行*字节。如果攻击者将与汇编指令相关的字节放置在调用堆栈上，CPU会将这些字节解释为*真实*的指令，从而使攻击者能够强制CPU执行*他们选择的任何任意代码*。幸运的是，现代计算机系统采用了一些策略，使得攻击者更难运行缓冲区溢出攻击：
- en: '**Stack randomization.**   The OS allocates the starting address of the stack
    at a random location in stack memory, causing the position/size of the call stack
    to vary from one run of a program to another. When we overwrote the `/proc/sys/kernel/randomize_va_space`
    file with a 0 value, we temporarily turned off stack randomization on the Raspberry
    Pi (this file returns to its original value on restart). Without turning off stack
    randomization, multiple machines running the same code would have different stack
    addresses. Modern Linux systems use stack randomization as a standard practice.
    However, a determined attacker can brute force the attack, by attempting to repeat
    attacks with different addresses. A common trick is to use a *NOP sled* (i.e.,
    a large number of NOP instructions) before the actual exploit code. Executing
    the NOP instruction (`0x90`) has no effect, other than causing the program counter
    to increment to the next instruction. As long as the attacker can get the CPU
    to execute somewhere in the NOP sled, the NOP sled will eventually lead to the
    exploit code that follows it. Aleph One’s writeup^([12](ch09.xhtml#fn9_12)) details
    the mechanism of this type of attack.'
  id: totrans-674
  prefs: []
  type: TYPE_NORMAL
  zh: '**堆栈随机化。** 操作系统在堆栈内存中以随机位置分配堆栈的起始地址，使得每次程序运行时调用堆栈的位置/大小不同。当我们将`/proc/sys/kernel/randomize_va_space`文件的值设置为0时，我们暂时关闭了树莓派上的堆栈随机化（该文件在重启后会恢复到原值）。如果不关闭堆栈随机化，多个运行相同代码的机器会有不同的堆栈地址。现代Linux系统将堆栈随机化作为标准做法。然而，一位决心坚定的攻击者可以通过尝试使用不同的地址反复发起攻击来暴力破解这一防御。一个常见的技巧是在实际的攻击代码之前使用*NOP滑道*（即，大量NOP指令）。执行NOP指令（`0x90`）没有任何效果，除了让程序计数器递增到下一个指令。只要攻击者能够让CPU在NOP滑道中的某个位置执行，NOP滑道最终会引导CPU执行随后的攻击代码。Aleph
    One的论文^([12](ch09.xhtml#fn9_12))详细介绍了这种类型攻击的机制。'
- en: '**Stack corruption detection.**   Another line of defense is to try to detect
    when the stack is corrupted. Recent versions of GCC use a stack protector known
    as a *canary* that acts as a guard between the buffer and the other elements of
    the stack. A canary is a value stored in a nonwriteable section of memory that
    can be compared to a value put on the stack. If the canary “dies” during a program’s
    execution, the program knows that it is under attack and aborts with an error
    message. For simplicity, we removed the canary from our `secret` executable by
    compiling it with the `fno-stack-protector` flag in GCC. However, a clever attacker
    can replace the canary during the course of the attack to prevent the program
    from detecting stack corruption.'
  id: totrans-675
  prefs: []
  type: TYPE_NORMAL
  zh: '**堆栈损坏检测。** 另一种防御措施是尝试检测堆栈是否已损坏。GCC的最新版本使用一种堆栈保护器，称为*金丝雀*，它充当缓冲区与堆栈其他元素之间的保护。金丝雀是存储在不可写内存区域中的一个值，可以与堆栈上的值进行比较。如果金丝雀在程序执行过程中“死亡”，程序就知道自己正遭受攻击，并会以错误信息中止。为了简便起见，我们通过在GCC中使用`fno-stack-protector`标志来编译`secret`可执行文件，去除了金丝雀。然而，一位聪明的攻击者可以在攻击过程中替换金丝雀，从而阻止程序检测到堆栈损坏。'
- en: '**Limiting executable regions.**   In this line of defense, executable code
    is restricted to only particular regions of memory. In other words, the call stack
    is no longer executable. However, even this defense can be defeated. In an attack
    utilizing *return-oriented programming* (ROP), an attacker can “cherry-pick” instructions
    in executable regions and jump from instruction to instruction to build an exploit.
    There are some famous examples of this online, especially in video games.^([13](ch09.xhtml#fn9_13))'
  id: totrans-676
  prefs: []
  type: TYPE_NORMAL
  zh: '**限制可执行区域。** 在这一防御措施中，可执行代码仅限于特定的内存区域。换句话说，调用栈不再是可执行的。然而，连这种防御也可以被突破。在利用*基于返回的编程*（ROP）攻击中，攻击者可以“挑选”可执行区域中的指令，并通过跳转指令来构建利用代码。网上有一些著名的例子，尤其是在视频游戏中。^([13](ch09.xhtml#fn9_13))'
- en: 'However, the best line of defense is always the programmer. To prevent buffer
    overflow attacks on your programs, use C functions with *length specifiers* whenever
    possible and add code that performs array bounds checking. It is crucial that
    any defined arrays match the chosen length specifiers. [Table 9-16](ch09.xhtml#ch9tab16)
    lists some common “bad” C functions that are vulnerable to buffer overflow, and
    the corresponding “good” function to use (assume that `buf` is allocated 12 bytes):'
  id: totrans-677
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，最好的防线始终是程序员本人。为了防止缓冲区溢出攻击，尽可能使用带有*长度限定符*的 C 函数，并添加执行数组边界检查的代码。至关重要的是，任何已定义的数组都必须与所选的长度限定符匹配。[表
    9-16](ch09.xhtml#ch9tab16)列出了几种常见的“坏” C 函数，这些函数容易受到缓冲区溢出攻击，以及对应的“好”函数（假设`buf`已分配了12个字节）：
- en: '**Table 9-16:** C Functions with Length Specifiers'
  id: totrans-678
  prefs: []
  type: TYPE_NORMAL
  zh: '**表 9-16：** 带长度限定符的 C 函数'
- en: '| **Instead of** | **Use** |'
  id: totrans-679
  prefs: []
  type: TYPE_TB
  zh: '| **不要使用** | **使用** |'
- en: '| `gets(buf)` | `fgets(buf, 12, stdin)` |'
  id: totrans-680
  prefs: []
  type: TYPE_TB
  zh: '| `gets(buf)` | `fgets(buf, 12, stdin)` |'
- en: '| `scanf("%s", buf)` | `scanf("%12s", buf)` |'
  id: totrans-681
  prefs: []
  type: TYPE_TB
  zh: '| `scanf("%s", buf)` | `scanf("%12s", buf)` |'
- en: '| `strcpy(buf2, buf)` | `strncpy(buf2, buf, 12)` |'
  id: totrans-682
  prefs: []
  type: TYPE_TB
  zh: '| `strcpy(buf2, buf)` | `strncpy(buf2, buf, 12)` |'
- en: '| `strcat(buf2, buf)` | `strncat(buf2, buf, 12)` |'
  id: totrans-683
  prefs: []
  type: TYPE_TB
  zh: '| `strcat(buf2, buf)` | `strncat(buf2, buf, 12)` |'
- en: '| `sprintf(buf, "%d", num)` | `snprintf(buf, 12, "%d", num)` |'
  id: totrans-684
  prefs: []
  type: TYPE_TB
  zh: '| `sprintf(buf, "%d", num)` | `snprintf(buf, 12, "%d", num)` |'
- en: 'The `secret2` binary^([14](ch09.xhtml#fn9_14)) no longer has the buffer overflow
    vulnerability. The `playGame` function of this new binary appears as follows:'
  id: totrans-685
  prefs: []
  type: TYPE_NORMAL
  zh: '`secret2`二进制文件^([14](ch09.xhtml#fn9_14))不再有缓冲区溢出漏洞。这个新二进制文件的`playGame`函数如下所示：'
- en: main2.c
  id: totrans-686
  prefs: []
  type: TYPE_NORMAL
  zh: main2.c
- en: '[PRE90]'
  id: totrans-687
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: 'Notice that we added a length specifier to all calls of `scanf`, causing the
    `scanf` function to stop reading from input after the first 12 bytes are read.
    The exploit string no longer breaks the program:'
  id: totrans-688
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们对所有`scanf`调用添加了长度限定符，使得`scanf`函数在读取输入的前12个字节后停止。此时，利用该漏洞的字符串不再能使程序崩溃：
- en: '[PRE91]'
  id: totrans-689
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: Of course, any reader with basic reverse-engineering skills can still win the
    guessing game by analyzing the assembly code. If you haven’t tried to beat the
    program yet with reverse engineering, we encourage you to do so now.
  id: totrans-690
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，任何具有基本逆向工程技能的读者仍然可以通过分析汇编代码来赢得猜测游戏。如果你还没有尝试通过逆向工程来打败该程序，建议你现在尝试一下。
- en: Notes
  id: totrans-691
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意事项
- en: '[1.](ch09.xhtml#rfn9_1) *[https://developer.arm.com/tools-and-software/open-source-software/developer-tools/gnu-toolchain/gnu-a/downloads](https://developer.arm.com/tools-and-software/open-source-software/developer-tools/gnu-toolchain/gnu-a/downloads)*'
  id: totrans-692
  prefs: []
  type: TYPE_NORMAL
  zh: '[1.](ch09.xhtml#rfn9_1) *[https://developer.arm.com/tools-and-software/open-source-software/developer-tools/gnu-toolchain/gnu-a/downloads](https://developer.arm.com/tools-and-software/open-source-software/developer-tools/gnu-toolchain/gnu-a/downloads)*'
- en: '[2.](ch09.xhtml#rfn9_2) *[https://www.qemu.org/](https://www.qemu.org/)*'
  id: totrans-693
  prefs: []
  type: TYPE_NORMAL
  zh: '[2.](ch09.xhtml#rfn9_2) *[https://www.qemu.org/](https://www.qemu.org/)*'
- en: '[3.](ch09.xhtml#rfn9_3) *[https://aws.amazon.com/ec2/instance-types/a1/](https://aws.amazon.com/ec2/instance-types/a1/)*'
  id: totrans-694
  prefs: []
  type: TYPE_NORMAL
  zh: '[3.](ch09.xhtml#rfn9_3) *[https://aws.amazon.com/ec2/instance-types/a1/](https://aws.amazon.com/ec2/instance-types/a1/)*'
- en: '[4.](ch09.xhtml#rfn9_4) Edsger Dijkstra,“Go To Statement Considered Harmful,”
    *Communications of the ACM* 11(3), pp. 147–148, 1968.'
  id: totrans-695
  prefs: []
  type: TYPE_NORMAL
  zh: '[4.](ch09.xhtml#rfn9_4) Edsger Dijkstra，“Go To语句被认为是有害的，”*ACM通信* 11(3)，第147-148页，1968年。'
- en: '[5.](ch09.xhtml#rfn9_5) *[https://diveintosystems.org/book/C9-ARM64/recursion.html#_animation_observing_how_the_call_stack_changes](https://diveintosystems.org/book/C9-ARM64/recursion.html#_animation_observing_how_the_call_stack_changes)*'
  id: totrans-696
  prefs: []
  type: TYPE_NORMAL
  zh: '[5.](ch09.xhtml#rfn9_5) *[https://diveintosystems.org/book/C9-ARM64/recursion.html#_animation_observing_how_the_call_stack_changes](https://diveintosystems.org/book/C9-ARM64/recursion.html#_animation_observing_how_the_call_stack_changes)*'
- en: '[6.](ch09.xhtml#rfn9_6) Mohit Kumar, “Critical Skype Bug Lets Hackers Remotely
    Execute Malicious Code,” *[https://thehackernews.com/2017/06/skype-crash-bug.html](https://thehackernews.com/2017/06/skype-crash-bug.html)*,
    2017.'
  id: totrans-697
  prefs: []
  type: TYPE_NORMAL
  zh: '[6.](ch09.xhtml#rfn9_6) Mohit Kumar, “Critical Skype Bug Lets Hackers Remotely
    Execute Malicious Code,” *[https://thehackernews.com/2017/06/skype-crash-bug.html](https://thehackernews.com/2017/06/skype-crash-bug.html)*,
    2017.'
- en: '[7.](ch09.xhtml#rfn9_7) Tamir Zahavi-Brunner, “CVE-2017-13253: Buffer overflow
    in multiple Android DRM services,” *[https://blog.zimperium.com/cve-2017-13253-buffer-overflow-multiple-android-drm-services/](https://blog.zimperium.com/cve-2017-13253-buffer-overflow-multiple-android-drm-services/)*,
    2018.'
  id: totrans-698
  prefs: []
  type: TYPE_NORMAL
  zh: '[7.](ch09.xhtml#rfn9_7) Tamir Zahavi-Brunner, “CVE-2017-13253: 多个 Android DRM
    服务中的缓冲区溢出漏洞，” *[https://blog.zimperium.com/cve-2017-13253-buffer-overflow-multiple-android-drm-services/](https://blog.zimperium.com/cve-2017-13253-buffer-overflow-multiple-android-drm-services/)*,
    2018.'
- en: '[8.](ch09.xhtml#rfn9_8) Tom Spring, “Google Patches ‘High Severit’ Browser
    Bug,” *[https://threatpost.com/google-patches-high-severity-browser-bug/128661/](https://threatpost.com/google-patches-high-severity-browser-bug/128661/)*,
    2017.'
  id: totrans-699
  prefs: []
  type: TYPE_NORMAL
  zh: '[8.](ch09.xhtml#rfn9_8) Tom Spring, “谷歌修复‘高危’浏览器漏洞，” *[https://threatpost.com/google-patches-high-severity-browser-bug/128661/](https://threatpost.com/google-patches-high-severity-browser-bug/128661/)*,
    2017.'
- en: '[9.](ch09.xhtml#rfn9_9) Christopher Kelty, “The Morris Worm,” *Limn Magazine*,
    Issue 1: Systemic Risk, 2011\. *[https://limn.it/articles/the-morris-worm/](https://limn.it/articles/the-morris-worm/)*'
  id: totrans-700
  prefs: []
  type: TYPE_NORMAL
  zh: '[9.](ch09.xhtml#rfn9_9) Christopher Kelty, “The Morris Worm,” *Limn Magazine*,
    Issue 1: 系统性风险, 2011\. *[https://limn.it/articles/the-morris-worm/](https://limn.it/articles/the-morris-worm/)*'
- en: '[10.](ch09.xhtml#rfn9_10) David Auerbach, “Chat Wars: Microsoft vs. AOL,” *NplusOne
    Magazine*, Issue 19, Spring 2014\. *[https://nplusonemag.com/issue-19/essays/chat-wars/](https://nplusonemag.com/issue-19/essays/chat-wars/)*'
  id: totrans-701
  prefs: []
  type: TYPE_NORMAL
  zh: '[10.](ch09.xhtml#rfn9_10) David Auerbach, “聊天战争：微软 vs. AOL，” *NplusOne Magazine*,
    Issue 19, 2014年春季\. *[https://nplusonemag.com/issue-19/essays/chat-wars/](https://nplusonemag.com/issue-19/essays/chat-wars/)*'
- en: '[11.](ch09.xhtml#rfn9_11) *[https://diveintosystems.org/book/C9-ARM64/_attachments/secretARM64.tar.gz](https://diveintosystems.org/book/C9-ARM64/_attachments/secretARM64.tar.gz)*'
  id: totrans-702
  prefs: []
  type: TYPE_NORMAL
  zh: '[11.](ch09.xhtml#rfn9_11) *[https://diveintosystems.org/book/C9-ARM64/_attachments/secretARM64.tar.gz](https://diveintosystems.org/book/C9-ARM64/_attachments/secretARM64.tar.gz)*'
- en: '[12.](ch09.xhtml#rfn9_12) Aleph One, “Smashing the Stack for Fun and Profit,”
    *[http://insecure.org/stf/smashstack.html](http://insecure.org/stf/smashstack.html)*,
    1996.'
  id: totrans-703
  prefs: []
  type: TYPE_NORMAL
  zh: '[12.](ch09.xhtml#rfn9_12) Aleph One, “为了乐趣和利润破坏栈，” *[http://insecure.org/stf/smashstack.html](http://insecure.org/stf/smashstack.html)*,
    1996.'
- en: '[13.](ch09.xhtml#rfn9_13) DotsAreCool, “Super Mario World Credit Warp” (Nintendo
    ROP example), *[https://youtu.be/vAHXK2wut_I](https://youtu.be/vAHXK2wut_I)*,
    2015.'
  id: totrans-704
  prefs: []
  type: TYPE_NORMAL
  zh: '[13.](ch09.xhtml#rfn9_13) DotsAreCool, “超级马里奥世界信用跳跃”（任天堂ROP示例）， *[https://youtu.be/vAHXK2wut_I](https://youtu.be/vAHXK2wut_I)*,
    2015.'
- en: '[14.](ch09.xhtml#rfn9_14) *[https://diveintosystems.org/book/C9-ARM64/_attachments/secret2ARM64.tar.gz](https://diveintosystems.org/book/C9-ARM64/_attachments/secret2ARM64.tar.gz)*'
  id: totrans-705
  prefs: []
  type: TYPE_NORMAL
  zh: '[14.](ch09.xhtml#rfn9_14) *[https://diveintosystems.org/book/C9-ARM64/_attachments/secret2ARM64.tar.gz](https://diveintosystems.org/book/C9-ARM64/_attachments/secret2ARM64.tar.gz)*'
