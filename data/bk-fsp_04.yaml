- en: Chapter 4. Staying Objective
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第 4 章. 保持面向目标
- en: For years, *object-oriented (OO)* development has been the de facto standard
    for developing business software, particularly within the enterprise, so you’re
    probably familiar with many of its core principles. It should come as no surprise
    that as a .NET language, F# supports the full cast of constructs—including classes,
    structs, and interfaces—available in the other .NET languages. Despite its reputation
    as a niche language useful only for academic exercises or highly specialized software,
    F#’s general-purpose, multiparadigm nature makes it suitable for most development
    situations. With C# and Visual Basic already well established, though, why choose
    F# as an OO language?
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 多年来，*面向对象（OO）*开发一直是开发业务软件，特别是在企业中的事实标准，所以你可能已经熟悉了其中许多核心原则。作为一门 .NET 语言，F# 支持与其他
    .NET 语言中相同的各种结构——包括类、结构体和接口——这应该不令人惊讶。尽管 F# 被认为是一种只适用于学术练习或高度专业化软件的利基语言，但其通用、多范式的特性使其适用于大多数开发场景。然而，既然
    C# 和 Visual Basic 已经得到了广泛应用，为什么还要选择 F# 作为面向对象语言呢？
- en: 'A large part of the decision rests on F#’s terse syntax, but features like
    type inference, object expressions, and the ability to combine object-oriented
    and functional styles make a strong argument, too. Let’s face it, though: Even
    if you’re developing in a primarily functional manner, when you’re developing
    software on the .NET Framework you’re going to have to work with objects at some
    point; that’s just the nature of the platform.'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 做出选择的一大因素是 F# 的简洁语法，但像类型推断、对象表达式以及将面向对象与函数式风格结合的能力等特性也提供了有力的理由。然而，面对现实：即使你主要采用函数式方式进行开发，当你在
    .NET 框架上开发软件时，最终还是需要与对象打交道；这就是平台的特性所在。
- en: In this chapter, you’ll learn how to create OO constructs in F# with less code,
    yet still build robust frameworks that can hold their own against similar frameworks
    built with more dedicated OO languages.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你将学习如何用更少的代码在 F# 中创建面向对象的结构，同时仍然能够构建强大的框架，这些框架能够与使用更专门的面向对象语言构建的类似框架相抗衡。
- en: Classes
  id: totrans-4
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 类
- en: Conceptually, classes in F# are identical to classes in other OO languages in
    that they encapsulate related data and behavior as fields, properties, methods,
    and events (collectively called *members*) to model real-world objects or concepts.
    Like classes in C# and Visual Basic, F# classes are reference types that support
    single inheritance and multiple interface implementation, and can control access
    to their members. As with all user-defined data types in F#, you declare classes
    with the `type` keyword. (Rather than requiring different keywords for every data
    type you can create, the compiler infers the construct based on its structure.)
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 从概念上讲，F# 中的类与其他 OO 语言中的类相同，它们将相关的数据和行为封装为字段、属性、方法和事件（统称为*成员*），以模拟现实世界的对象或概念。像
    C# 和 Visual Basic 中的类一样，F# 类是引用类型，支持单一继承和多重接口实现，并且可以控制对其成员的访问。与 F# 中的所有用户定义数据类型一样，类是通过
    `type` 关键字来声明的。（编译器根据结构推断构造，而不需要为每种数据类型使用不同的关键字。）
- en: To illustrate, let’s take another look at the class definition introduced in
    the type inference discussion in [Chapter 3](ch03.html "Chapter 3. Fundamentals").
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 为了说明这一点，我们再来看一下在[第 3 章](ch03.html "第 3 章. 基础")中讨论类型推断时引入的类定义。
- en: '[PRE0]'
  id: totrans-7
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: There’s a lot of definition packed into this example. In just four lines, there’s
    a class with a *primary constructor* with three arguments and three implicit,
    read-only properties! While quite a departure from the other .NET languages, this
    terseness is just one of the ways that F# distinguishes itself.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 这个示例包含了大量的定义。在仅仅四行代码中，就有一个带有*主构造函数*、三个参数和三个隐式只读属性的类！虽然与其他 .NET 语言有很大不同，但这种简洁性正是
    F# 区别于其他语言的方式之一。
- en: Constructors
  id: totrans-9
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 构造函数
- en: 'Constructors are the means by which new class instances are created and initialized.
    They’re really specialized functions that return fully initialized class instances.
    Classes in F# do not require a constructor, as shown here:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 构造函数是创建和初始化新类实例的方式。它们实际上是专门的函数，返回完全初始化的类实例。F# 中的类不需要构造函数，如下所示：
- en: '[PRE1]'
  id: totrans-11
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The empty class in this example is valid F# but, unlike in C#, if you don’t
    define a constructor, the compiler won’t automatically generate a *default constructor*
    (a constructor with no parameters). Since a memberless class that you can’t instantiate
    is pretty useless, your classes will typically have at least one constructor and
    one member.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 这个示例中的空类是有效的F#代码，但与C#不同，如果你没有定义构造函数，编译器不会自动生成*默认构造函数*（无参数的构造函数）。由于一个没有成员、无法实例化的类基本没有用处，所以你的类通常会至少有一个构造函数和一个成员。
- en: Note
  id: totrans-13
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '*One reason you might choose to omit the constructor is that each of the type’s
    members is static; that is, it applies to the type rather than an individual instance.
    We’ll examine static members in detail a bit later in this chapter.*'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: '*你可能选择省略构造函数的一个原因是该类型的每个成员都是静态的；也就是说，它适用于类型本身，而非某个单独的实例。稍后我们将在本章中详细讨论静态成员。*'
- en: As with other OO languages, you create new class instances by invoking a constructor.
    In the case of our `Person` class there’s only one constructor, so the choice
    is clear.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 与其他面向对象（OO）语言一样，你可以通过调用构造函数来创建新的类实例。在我们的`Person`类中只有一个构造函数，所以选择是明确的。
- en: '[PRE2]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Using the `new` keyword to create a new class instance is optional. By convention,
    you use the `new` keyword only when creating an instance of a class that implements
    the `IDisposable` interface.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`new`关键字来创建新的类实例是可选的。按照约定，只有在创建实现了`IDisposable`接口的类实例时，你才会使用`new`关键字。
- en: 'F# constructors come in two flavors: primary constructors and additional constructors.'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: F#构造函数有两种类型：主构造函数和附加构造函数。
- en: Primary Constructors
  id: totrans-19
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 主构造函数
- en: F# classes can have a *primary constructor* whose arguments are embedded within
    the type definition itself. The primary constructor’s body contains a series of
    `let` and `do` bindings that represent the class’s field definitions and initialization
    code.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: F#类可以拥有一个*主构造函数*，其参数直接嵌入在类型定义中。主构造函数的主体包含一系列`let`和`do`绑定，表示类的字段定义和初始化代码。
- en: '[PRE3]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: In this example, the primary constructor includes the parameter list with type
    annotations ①, a single field definition for the calculated age ②, and a `do`
    binding ③ that prints the person’s name and age when the object is constructed.
    All of the primary constructor’s parameters are automatically available as fields
    throughout your class, so there’s no need to explicitly map them.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，主构造函数包含带有类型注解的参数列表①，一个用于计算年龄的单一字段定义②，以及一个`do`绑定③，在对象构造时打印出人的姓名和年龄。主构造函数的所有参数都会自动作为字段在整个类中使用，因此不需要显式地映射它们。
- en: The compiler can frequently infer the types for each constructor parameter,
    so there’s often no need to include explicit type annotations. In the preceding
    example, a type annotation (or one on an intermediate binding with a type annotation)
    would still be needed for the `dob` parameter so the compiler can resolve the
    correct subtract operator overload. However, that’s more the exception than the
    rule, as shown in the next example, where the compiler can infer the types for
    both the `name` and `age` parameters as `string` and `int`, respectively.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 编译器通常可以推断每个构造函数参数的类型，因此通常无需包含显式的类型注解。在前面的示例中，`dob`参数仍然需要一个类型注解（或者在中间绑定上使用类型注解），这样编译器才能解析正确的减法运算符重载。然而，这种情况更多是例外而非规则，正如下一个示例所示，编译器可以推断`name`和`age`参数的类型分别为`string`和`int`。
- en: '[PRE4]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'By default, the primary constructor is public, but you can change that by including
    an access modifier before the parameter list. You might consider changing the
    primary constructor’s accessibility if you were implementing the *Singleton pattern*,
    which specifies that only a single instance of the type can exist, as shown here:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，主构造函数是公开的，但你可以通过在参数列表前添加访问修饰符来更改这一点。如果你在实现*单例模式*时，可能会考虑更改主构造函数的可访问性，单例模式规定类型只能有一个实例，如下所示：
- en: '[PRE5]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: More About Accessibility in F#
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 关于F#中的可访问性更多内容
- en: '*Access modifiers* limit the scope of bindings, types, and members throughout
    your program. F# differs from C# and Visual Basic in that it directly supports
    only the `public`, `private`, and `internal` modifiers. You can’t define `protected`
    class members in F# due in part to how they complicate the functional nature of
    the language. F# does still honor `protected` members defined in other languages,
    so they won’t be publicly accessible and you can still override them in derived
    classes without breaking the abstraction.'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: '*访问修饰符* 限制了绑定、类型和成员在整个程序中的作用域。F#与C#和Visual Basic不同，F#仅直接支持`public`、`private`和`internal`修饰符。在F#中不能定义`protected`类成员，部分原因是`protected`成员会使语言的函数式特性变得复杂。尽管如此，F#仍然会遵循在其他语言中定义的`protected`成员，因此它们不会公开访问，并且你仍然可以在派生类中重写它们，而不会破坏抽象。'
- en: Additional Constructors
  id: totrans-29
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 额外的构造函数
- en: Constructors that you define beyond the primary constructor are called *additional
    constructors*. Additional constructors are defined with the `new` keyword followed
    by a parameter list and constructor body, as shown next. While additional constructors
    must always invoke the primary constructor, they may do so indirectly through
    another constructor, thereby allowing you to chain constructor calls.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 你在主构造函数之外定义的构造函数称为*额外构造函数*。额外的构造函数使用`new`关键字定义，后面跟着参数列表和构造函数体，如下所示。虽然额外的构造函数必须始终调用主构造函数，但它们可以通过另一个构造函数间接调用，从而允许你链式调用构造函数。
- en: '[PRE6]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Additional constructors can contain their own `let` bindings and other expressions,
    but unlike those in the primary constructor, any such elements will be local to
    the constructor where they’re defined rather than exposed as fields.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 额外的构造函数可以包含它们自己的`let`绑定和其他表达式，但与主构造函数中的不同，任何此类元素都将局部于定义它们的构造函数，而不是作为字段暴露出来。
- en: Additional constructors can invoke additional code like a primary constructor,
    but instead of using a `do` binding they use the `then` keyword. In this example,
    each additional constructor includes the `then` keyword in order to print a message
    indicating which constructor is being invoked.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 额外的构造函数可以像主构造函数一样调用额外的代码，但它们使用`then`关键字，而不是`do`绑定。在这个例子中，每个额外的构造函数都包含`then`关键字，以便打印一条消息，指示哪个构造函数被调用。
- en: '[PRE7]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Classes without a primary constructor behave a bit differently at initialization.
    When you use them, you must explicitly define fields with the `val` keyword, and
    any additional constructors must initialize any fields not decorated with the
    `DefaultValue` attribute, as shown here:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 没有主构造函数的类在初始化时表现得稍微不同。当你使用它们时，必须显式定义字段，使用`val`关键字，任何额外的构造函数必须初始化没有使用`DefaultValue`属性修饰的字段，如下所示：
- en: '[PRE8]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Self-Identifiers
  id: totrans-37
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 自引用标识符
- en: 'Sometimes you’ll want to reference a class member within a constructor. By
    default, class members aren’t accessible because they require a recursive reference
    to the type, but you can enable *self-referencing* with the `as` keyword and a
    *self-identifier* like this:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 有时候你可能希望在构造函数中引用类成员。默认情况下，类成员是不可访问的，因为它们需要递归引用类型，但你可以通过`as`关键字和*自引用标识符*来启用自引用，如下所示：
- en: '[PRE9]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: You can choose any name for your self-identifiers as long as you follow the
    normal rules for identifiers. You could even use a quoted identifier like the
    following ones if you really want to irritate your future self or anyone else
    who’s maintaining your code.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以为自引用标识符选择任何名称，只要你遵循标识符的常规规则。如果你真的想激怒未来的自己或任何维护你代码的人，甚至可以使用像下面这样的带引号的标识符。
- en: '[PRE10]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: It’s generally best to stick with short names. Common conventions are to use
    either `x` or `this`. But whatever you choose, be consistent!
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 通常最好坚持使用简短的名称。常见的约定是使用`x`或`this`。但无论你选择什么，记得保持一致！
- en: Warning
  id: totrans-43
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 警告
- en: '*The compiler will generate a warning if you define a self-identifier but don’t
    use it in your constructor. The reason is that using the as keyword makes the
    class definition recursive, which results in additional run time validation that
    can negatively impact initializing types in your class hierarchy. Use self-identifiers
    in primary constructors only when you actually need them.*'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: '*如果你定义了一个自引用标识符，但在构造函数中没有使用它，编译器将生成警告。原因是使用`as`关键字使得类定义变得递归，这会导致额外的运行时验证，从而可能对类层次结构中的类型初始化产生负面影响。只有在真正需要时，才在主构造函数中使用自引用标识符。*'
- en: Fields
  id: totrans-45
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 字段
- en: Fields define the data elements associated with an object. In the previous section,
    we took a brief look at both ways to create fields. In this section, we’ll examine
    field creation in more detail.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 字段定义了与对象相关联的数据元素。在前一部分中，我们简要地了解了两种创建字段的方式。在本节中，我们将更详细地讨论字段的创建。
- en: let Bindings
  id: totrans-47
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: let绑定
- en: 'The first way to create fields is with `let` bindings in the primary constructor.
    These fields, which must be initialized in the primary constructor, are *always*
    private to the class. Although they must be initialized when they’re created,
    you can make the value mutable as in any `let` binding, as shown here:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 创建字段的第一种方式是使用主构造函数中的`let`绑定。这些字段必须在主构造函数中初始化，并且*总是*对类是私有的。尽管它们在创建时必须初始化，但你可以像任何`let`绑定一样使其值可变，如下所示：
- en: '[PRE11]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Here, a mutable `let` binding is used to define the backing store for the `Name`
    property.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，使用可变的`let`绑定来定义`Name`属性的后备存储。
- en: Explicit Fields
  id: totrans-51
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 显式字段
- en: 'When you want a little more control over a field or your class doesn’t have
    a primary constructor, create an explicit field with the `val` keyword. Explicit
    fields don’t need to be initialized immediately, but in classes with a primary
    constructor you’ll need to decorate them with the `DefaultValue` attribute to
    ensure that the value is initialized to its appropriate “zero” value, like this:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 当你想对字段进行更多控制，或者你的类没有主构造函数时，可以使用`val`关键字创建显式字段。显式字段不需要立即初始化，但在具有主构造函数的类中，你需要使用`DefaultValue`属性对它们进行修饰，以确保它们被初始化为适当的“零”值，如下所示：
- en: '[PRE12]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'In this example, `n` is an explicit field. Because `n` is of type `string`,
    it’s initialized to `null`, as you can see here:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，`n`是一个显式字段。由于`n`的类型是`string`，它被初始化为`null`，如你所见：
- en: '[PRE13]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Explicit fields are public by default, but you can make them private by including
    the `private` access modifier in the definition like this:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 显式字段默认是公共的，但你可以通过在定义中包含`private`访问修饰符将它们设置为私有，如下所示：
- en: '[PRE14]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Properties
  id: totrans-58
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 属性
- en: Like fields, *properties* represent data associated with an object. Unlike fields,
    though, properties offer more control over how that data is accessed or modified
    by exposing the actions through some combination of `get` and/or `set` functions
    (collectively called *accessors*).
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 和字段一样，*属性*表示与对象相关联的数据。不过与字段不同的是，属性提供了更多的控制，允许你通过某种组合的`get`和/或`set`函数（统称为*访问器*）来控制数据的访问或修改方式。
- en: You can define properties either implicitly or explicitly. One guideline is
    to favor implicit properties when you’re exposing a simple value; when you need
    custom logic when getting or setting a property value, use explicit properties
    instead.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以隐式或显式地定义属性。一个指导原则是，当你暴露一个简单值时，优先使用隐式属性；当你需要在获取或设置属性值时使用自定义逻辑时，改用显式属性。
- en: Explicit Properties
  id: totrans-61
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 显式属性
- en: 'Explicit properties are those where you define and control the backing store
    (typically with a `let` binding) and implement the `get` and `set` function bodies
    yourself. You define an explicit property with the `member` keyword followed by
    a self-identifier, the property name, a type annotation (if the compiler can’t
    infer it), and the function bodies, as shown here:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 显式属性是指你定义并控制后备存储（通常使用`let`绑定），并且自己实现`get`和`set`函数体。你可以使用`member`关键字定义一个显式属性，后跟自引用、属性名称、类型注解（如果编译器无法推断出类型），以及函数体，如下所示：
- en: '[PRE15]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'In this example, the `name` field is the private backing store for the read/write
    `Name` property. Once you’ve created an instance of this `Person` class, you can
    assign a value to the `Name` property with the assignment operator, like so:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，`name`字段是`Name`属性的私有后备存储。一旦你创建了这个`Person`类的实例，就可以像下面这样使用赋值运算符给`Name`属性赋值：
- en: '[PRE16]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Instead of using the `and` keyword, you can use an alternative syntax where
    the `get` and `set` accessors are defined as separate properties.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用另一种语法来代替`and`关键字，在这种语法中，`get`和`set`访问器被定义为独立的属性。
- en: '[PRE17]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Whichever syntax you choose, properties are public by default, but you can
    control their accessibility by inserting the access modifier (`public`, `private`,
    or `internal`) after the `with` (or `and`) keyword, like this:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 无论你选择哪种语法，属性默认是公共的，但你可以通过在`with`（或`and`）关键字后插入访问修饰符（`public`、`private`或`internal`）来控制它们的可访问性，如下所示：
- en: '[PRE18]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'If you wanted the `Name` property to be read-only, you could revise the class
    to include the value as an argument to the primary constructor and remove the
    `and set...` line in this way:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你希望`Name`属性为只读属性，可以通过将值作为主构造函数的一个参数，并去除`and set...`这一行来修改类，方法如下：
- en: '[PRE19]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Of course, this is F#, so although defining a read-only property is already
    easy, there’s an even easier way with the explicit syntax.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，这是F#，所以尽管定义只读属性已经很简单，但通过显式语法还有一种更简单的方式。
- en: '[PRE20]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: When you’re creating a read-only property, the compiler automatically generates
    the `get` accessor function for you.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建只读属性时，编译器会自动为你生成`get`访问器函数。
- en: Implicit Properties
  id: totrans-75
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 隐式属性
- en: Implicit, or automatic, properties were added to F# in version 3.0 (if you’re
    using 2.0, you’ll need to use explicit properties). They’re very much like auto-implemented
    properties in C# in that they allow the compiler to generate the proper backing
    store and corresponding `get`/`set` accessor bodies. Implicit properties are a
    lot like their explicit counterparts, but there are a few differences.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 隐式或自动属性在F# 3.0版本中引入（如果你使用的是2.0版本，则需要使用显式属性）。它们与C#中的自动实现属性非常相似，允许编译器生成适当的后备存储和相应的`get`/`set`访问器主体。隐式属性与显式属性非常相似，但有一些区别。
- en: First, implicit properties are considered part of the type’s initialization,
    so they must appear before other member definitions, typically along with the
    primary constructor. Next, they are defined via the `member val` keyword pair
    and must be initialized to a default value, as shown next. (They must not include
    a self-identifier.) And finally, their accessibility can be changed only at the
    property level, not the accessor level.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，隐式属性被视为类型初始化的一部分，因此必须出现在其他成员定义之前，通常与主构造函数一起定义。接下来，它们通过`member val`关键字对进行定义，并且必须初始化为默认值，如下所示。（它们不能包含自引用标识符。）最后，它们的访问级别只能在属性级别更改，而不能在访问器级别更改。
- en: '[PRE21]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'If your implicit property is read-only, you can omit the `with` expression
    like this:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你的隐式属性是只读的，你可以像这样省略`with`表达式：
- en: '[PRE22]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Indexed Properties
  id: totrans-81
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 索引属性
- en: F# classes can also have *indexed properties*, which are useful for defining
    an array-like interface for working with sequential data. Indexed properties are
    defined like ordinary properties except that the `get` accessor includes an argument.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: F# 类也可以拥有*索引属性*，这些属性对于定义一个类似数组的接口以处理顺序数据非常有用。索引属性的定义方式与普通属性相似，不同之处在于`get`访问器包含一个参数。
- en: 'When you are creating indexed properties, naming one `Item` makes it a *default
    indexed property* and enables convenient syntactic support through the dot operator
    and a pair of brackets enclosing the index value (`.[...]`). For example, consider
    a class that accepts a string and exposes each word through a default indexer
    like this:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建索引属性时，命名为`Item`会使其成为*默认索引属性*，并通过点操作符和一对括号来支持便捷的语法（`.[...]`）。例如，考虑一个接受字符串并通过默认索引器暴露每个单词的类，像这样：
- en: '[PRE23]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Notice that the `Item` property is defined like a normal property with the `get`,
    and even a `set`, accessor. Because this indexer is just a wrapper around the
    `words` array (`String.Split` returns an array), it accepts an integer value and
    returns the corresponding word.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，`Item`属性定义方式与普通属性相似，包含`get`，甚至是`set`访问器。因为这个索引器只是`words`数组（`String.Split`返回一个数组）的一个封装，它接受一个整数值并返回对应的单词。
- en: 'F# arrays are zero-based, so you can get the second word from a sentence like
    this:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: F# 数组是基于零索引的，因此你可以像这样从一个句子中获取第二个单词：
- en: '[PRE24]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'To change the second word, you’d reference the index in the same way and use
    the assignment operator (`<-`) like so:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 要更改第二个单词，你可以以相同的方式引用索引，并使用赋值操作符（`<-`）如下所示：
- en: '[PRE25]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Furthermore, default indexed properties can be multidimensional. For instance,
    you can define one to return a specific character from a word by including two
    parameters.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，默认的索引属性可以是多维的。例如，你可以定义一个属性，通过包含两个参数来返回一个单词中的特定字符。
- en: '[PRE26]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Now you can easily get the first character of the second word like this:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你可以轻松地像这样获取第二个单词的第一个字符：
- en: '[PRE27]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'But what if you want to define another indexed property to get a character
    out of the original string? You’ve already defined a default indexed property
    that accepts an integer, so you can’t do it that way. In C#, you’d have to create
    this as a method, but in F# any property can be an indexed property. For example:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，如果你想定义另一个索引属性来获取原始字符串中的某个字符该怎么办？你已经定义了一个接受整数的默认索引属性，所以不能那样做。在C#中，你必须将其创建为一个方法，但在F#中，任何属性都可以是一个索引属性。例如：
- en: '[PRE28]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'The only caveat is that you can’t use the dot/bracket syntax that you’d use
    with a default indexed property; you have to access the property as if it’s a
    method (as described in [Instance Methods](ch04.html#instance_methods "Instance
    Methods")) by including the index value in parentheses after the property name
    in this way:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 唯一的注意事项是，你不能像使用默认索引属性时那样使用点/括号语法；你必须将属性当作方法来访问（如[实例方法](ch04.html#instance_methods
    "实例方法")所描述），并通过在属性名称后面加上括号内的索引值来访问：
- en: '[PRE29]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Though it looks like a method call, if the `Chars` indexed property included
    a `set` accessor, you’d use the assignment operator just like you would with any
    other property to change the underlying value.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然它看起来像是一个方法调用，但如果`Chars`索引属性包含一个`set`访问器，你会像操作其他属性一样使用赋值运算符来改变底层的值。
- en: Setting at Initialization
  id: totrans-99
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 初始化时设置
- en: An alternative object initialization syntax lets you set individual property
    values as part of the constructor call. To use the object initialization syntax,
    you need only include each property name and value (separated by an equal sign)
    immediately following the normal constructor arguments. Let’s reconsider one of
    the previous `Person` class examples to illustrate.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 一种替代的对象初始化语法允许你在构造函数调用中直接设置各个属性的值。要使用这种对象初始化语法，你只需在正常构造函数参数之后，紧接着写出每个属性的名称和值（用等号分隔）。我们可以通过重新考虑之前的`Person`类示例来说明这一点。
- en: '[PRE30]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Because the `Person` class has only the single, parameterless constructor,
    you could create an instance and then assign a value to the `Name` property in
    a second operation. But it would be much more concise to do it all at once, like
    this:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 因为`Person`类只有一个单一的无参构造函数，所以你可以先创建一个实例，然后在第二个操作中给`Name`属性赋值。但要一次性完成这一切会更加简洁，像这样：
- en: '[PRE31]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'There is one catch to using this syntax: Any properties you initialize this
    way must be writable.'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这种语法时有一个注意点：你初始化的任何属性必须是可写的。
- en: Methods
  id: totrans-105
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 方法
- en: Methods are functions that are associated with a class and that represent the
    type’s behavior.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 方法是与类关联的函数，表示该类型的行为。
- en: Instance Methods
  id: totrans-107
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 实例方法
- en: There are two ways to define instance methods. The first form uses the `member`
    keyword to define a public method in much the same way as a property, as demonstrated
    by the `GetArea` method that follows.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 定义实例方法有两种方式。第一种方式使用`member`关键字定义公共方法，这与定义属性的方式类似，如下面的`GetArea`方法所示。
- en: '[PRE32]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Here, the `Circle` class is initialized with a `diameter` value and contains
    a parameterless, public method named `GetArea` that calculates the area of the
    circle. Because `GetArea` is an instance method, you’ll need to create an instance
    of the `Circle` class to invoke it as follows:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，`Circle`类通过一个`diameter`值初始化，并包含一个无参的公共方法`GetArea`，该方法计算圆的面积。因为`GetArea`是实例方法，你需要创建一个`Circle`类的实例才能像下面这样调用它：
- en: '[PRE33]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Method Accessibility
  id: totrans-112
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 方法可访问性
- en: 'As with properties, you can control access to methods with accessibility modifiers.
    For example, to make a method private you would simply include the `private` keyword
    in the method’s signature, as in the `GetRadius` method here:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 与属性一样，你可以通过访问修饰符来控制方法的访问权限。例如，要将一个方法设置为私有，只需在方法签名中加入`private`关键字，如下所示的`GetRadius`方法：
- en: '[PRE34]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Alternatively, you can use a `let` binding to define a private function, as
    shown here:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 另外，你也可以使用`let`绑定来定义一个私有函数，如下所示：
- en: '[PRE35]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Named Arguments
  id: totrans-117
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 命名参数
- en: When you call a method, you’ll usually provide the arguments as a comma-delimited
    list with each argument corresponding to the parameter at the same position. For
    a bit of extra flexibility, though, F# allows *named arguments* for both methods
    and constructors. With named arguments, each argument is explicitly associated
    with a particular parameter by name. In some cases, named arguments can help clarify
    your code, but they also allow you to specify the arguments in any order.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 当你调用一个方法时，通常会提供一个以逗号分隔的参数列表，每个参数对应于相同位置的参数。为了提供一些额外的灵活性，F# 允许对方法和构造函数使用*命名参数*。通过命名参数，每个参数都通过名称显式地与特定参数关联。在某些情况下，命名参数有助于澄清你的代码，但它们也允许你按任意顺序指定参数。
- en: The following example contains a method that calculates the Euclidean distance
    between two points in a three-dimensional space (RGB colors, to be exact).
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例包含一个计算三维空间中两点之间欧几里得距离（准确来说是RGB颜色）的函数。
- en: '[PRE36]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'You can call the `GetEuclideanDistance` method normally by specifying two colors,
    or by specifying the parameter names in the argument list like this:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过指定两个颜色来正常调用`GetEuclideanDistance`方法，或者像这样通过指定参数名称来调用：
- en: '[PRE37]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: You can specify named arguments in any order. You can also use named arguments
    with unnamed arguments, but if you do, the unnamed arguments must appear first
    in the argument list. Finally, because named arguments are permissible only for
    methods defined with the member syntax, they can’t be used with functions created
    through `let` bindings.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以按任意顺序指定命名参数。你也可以将命名参数与未命名参数一起使用，但如果这样做，未命名参数必须首先出现在参数列表中。最后，由于命名参数仅适用于使用成员语法定义的方法，因此不能与通过`let`绑定创建的函数一起使用。
- en: Overloaded Methods
  id: totrans-124
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 重载方法
- en: An *overloaded method* shares its name with one or more other methods in the
    same class but has a different set of parameters. Overloaded methods often define
    subsets of parameters, with each overload calling a more specific form with its
    supplied arguments and providing default values for others.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: '*重载方法*与同一类中的一个或多个其他方法共享相同的名称，但具有不同的参数集。重载方法通常定义参数的子集，每个重载调用一个更具体的形式，并为其他参数提供默认值。'
- en: 'For example, if you were building a utility to tie in to your favorite version
    control system, you might define a `Commit` method that accepts a list of files,
    the description, and the target branch. To make the target branch optional, you
    could overload the `Commit` function as shown here:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果你正在构建一个与自己喜欢的版本控制系统对接的工具，你可能会定义一个`Commit`方法，该方法接受一个文件列表、描述和目标分支。为了让目标分支成为可选项，你可以像这里展示的那样重载`Commit`函数：
- en: '[PRE38]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: In this example, the overload at ① is responsible for committing changes to
    the repository, while the overload at ② makes the branch parameter optional when
    you supply the default value shown at ③.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，①处的重载负责将更改提交到仓库，而②处的重载则通过在③处提供的默认值，使分支参数变为可选。
- en: Optional Parameters
  id: totrans-129
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 可选参数
- en: Even though F# supports method overloading, you probably won’t use it very often
    because F# also supports *optional parameters*, which are generally more convenient.
    If you prefix a parameter name with a question mark (`?`), the compiler treats
    it as an optional parameter.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管 F# 支持方法重载，但你可能不会经常使用它，因为 F# 还支持*可选参数*，这些参数通常更方便。如果你在参数名称前加上问号（`?`），编译器会将其视为可选参数。
- en: Optional parameters are a bit different in F# than they are in C# and Visual
    Basic. In other languages, optional parameters are defined with a default value
    that’s used when the corresponding argument is omitted. In F#, though, the parameters
    are actually compiled to `option<_>` and default to `None`. (Optional parameter
    values behave like any other option type value, so you’ll still use `defaultArg`
    or pattern matching in your method to get a meaningful value, as appropriate.)
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 可选参数在 F# 中与 C# 和 Visual Basic 中有所不同。在其他语言中，可选参数定义时会指定一个默认值，当省略相应参数时会使用该默认值。但在
    F# 中，参数实际上会被编译为`option<_>`类型，并默认为`None`。（可选参数的值表现得像任何其他的 option 类型值，因此你仍然需要在方法中使用`defaultArg`或模式匹配来获取有意义的值，具体取决于情况。）
- en: Let’s rewrite the `Repository` example from the previous section to use an optional
    parameter instead of an overloaded method.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们改写上一节中的`Repository`示例，使用一个可选参数，而不是重载方法。
- en: '[PRE39]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Although you need to manage the optional parameter within the method, you now
    need to maintain only the one method instead of multiple, overloaded versions.
    As you can see, optional parameters can reduce the likelihood of defects that
    come from using inconsistent defaults across overloads, and they simplify refactoring
    because only one method needs to change.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管你需要在方法中管理可选参数，但现在只需要维护一个方法，而不是多个重载版本。如你所见，可选参数可以减少由于在重载中使用不一致的默认值而产生的缺陷的可能性，并且它们简化了重构，因为只需要更改一个方法。
- en: Slice Expressions
  id: totrans-135
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 切片表达式
- en: Indexed properties, introduced in [Indexed Properties](ch04.html#indexed_properties
    "Indexed Properties"), are great for working with a single value in an encapsulated
    sequence, but you’ll sometimes want to work with a range of values in that sequence.
    Traditionally you’d have to get each item manually through the indexer, or implement
    `IEnumerable<'T>` and get the values through some combination of LINQ’s `Skip`
    and `Take` extension methods. *Slice expressions* resemble indexed properties,
    except that they use range expressions to identify which items should be included
    in the resulting sequence.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 索引属性，在[索引属性](ch04.html#indexed_properties "Indexed Properties")中介绍，非常适合处理封装序列中的单个值，但有时你可能需要处理该序列中的一系列值。传统上，你必须通过索引器手动获取每个项，或者实现`IEnumerable<'T>`并通过LINQ的`Skip`和`Take`扩展方法的某种组合来获取值。*切片表达式*类似于索引属性，只不过它们使用范围表达式来标识应该包含在结果序列中的项。
- en: To use slice expressions with your class, you need to implement a `GetSlice`
    method. There’s really nothing special about the `GetSlice` method; it’s just
    the method that the compiler looks for when it encounters the slice expression
    syntax. To illustrate a slice expression, let’s revisit the `Sentence` class from
    the indexed properties section.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 要在你的类中使用切片表达式，你需要实现一个`GetSlice`方法。其实`GetSlice`方法并没有什么特别之处；它只是编译器在遇到切片表达式语法时会查找的方法。为了说明切片表达式，让我们回顾一下索引属性部分的`Sentence`类。
- en: '[PRE40]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: The basic class definition is the same as before, except this time we have a
    `GetSlice()` method that accepts the lower and upper bounds. (Don’t dwell on the
    match expressions here; a full discussion is waiting for you in [Chapter 7](ch07.html
    "Chapter 7. Patterns, Patterns, Everywhere"). For now it’s enough to know that
    they’re just doing some boundary checks.)
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 基本的类定义与之前相同，只不过这次我们有一个接受上下边界的`GetSlice()`方法。（不要纠结这里的匹配表达式；有关详细讨论，请参见[第7章](ch07.html
    "第7章 模式，无处不在")。现在知道它们只是在进行一些边界检查就足够了。）
- en: 'You could call this method directly in your code, but the expression form is
    much more convenient. For example, to retrieve the second, third, and fourth words
    in a sentence, you could write:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在代码中直接调用这个方法，但表达式形式更为方便。例如，要获取句子中的第二、第三和第四个单词，你可以这样写：
- en: '[PRE41]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: One of the nice things about slice expressions is that the bounds parameters
    are optional, so you can use open-ended ranges. To specify a range without a lower
    bound, just omit the first value (the 1) in the slice expression, which in this
    case is equivalent to `[0..3]`.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 切片表达式的一个优点是，边界参数是可选的，因此你可以使用开放的范围。要指定一个没有下边界的范围，只需在切片表达式中省略第一个值（即1），在这种情况下，它等同于`[0..3]`。
- en: '[PRE42]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: Similarly, you can leave out the second parameter and get the items up to the
    end of the collection.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 类似地，你可以省略第二个参数，获取到集合的末尾的项。
- en: '[PRE43]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Like indexed properties, slice expressions can work on two dimensions, but
    you need to overload the `GetSlice` method to accept four parameters that define
    both pairs of lower and upper bounds. Continuing with the `Sentence` example,
    we can add a multidimensional slice overload to get a range of characters from
    a range of words like this:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 与索引属性类似，切片表达式可以作用于二维，但你需要重载`GetSlice`方法，以接受定义上下边界对的四个参数。继续使用`Sentence`示例，我们可以添加一个多维切片重载，以便从一组单词中获取一系列字符，像这样：
- en: '[PRE44]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: To use this overload, just separate the range pairs in the slice expression
    with a comma.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用这个重载，只需在切片表达式中用逗号分隔范围对。
- en: '[PRE45]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: Events
  id: totrans-150
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 事件
- en: The final member type is *events*. Events are used throughout the .NET Framework
    with some notable examples found in the user interface components and ADO.NET.
    As in other .NET languages, at their core F# events are collections of functions
    invoked in response to some action like a button click or an asynchronous process
    completion.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一种成员类型是*事件*。事件在整个 .NET Framework 中都有应用，一些显著的例子可以在用户界面组件和 ADO.NET 中找到。与其他 .NET
    语言一样，F# 的事件本质上是响应某些操作（如按钮点击或异步进程完成）时调用的一系列函数集合。
- en: In many ways F# events serve the same purpose as traditional .NET events, but
    they’re a completely different mechanism. However, for cross-language compatibility,
    they can tie in to the .NET event system. (We’ll see how your custom events can
    harness this capability with the `CLIEvent` attribute a bit later in this section.)
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 在许多方面，F# 的事件与传统的 .NET 事件具有相同的作用，但它们是完全不同的机制。然而，为了实现跨语言兼容性，它们可以与 .NET 事件系统结合使用。（稍后我们将在本节中看到，如何通过
    `CLIEvent` 属性来利用这种能力）
- en: Basic Event Handling
  id: totrans-153
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 基本事件处理
- en: Events in F# are instances of the `Event<'T>` class (found in `FSharp.Core.Control`).
    One of the primary features that the `Event<'T>` class enables is a more explicit
    publish/subscribe model than you might be used to. In this model you can subscribe
    to published events by adding event handlers to the event via a call to the `Add`
    function.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: F# 中的事件是 `Event<'T>` 类的实例（位于 `FSharp.Core.Control` 中）。`Event<'T>` 类的一个主要特性是，它提供了比你可能习惯的更加明确的发布/订阅模型。在这个模型中，你可以通过调用
    `Add` 函数向事件添加事件处理程序，从而订阅发布的事件。
- en: For example, the `System.Timers.Timer` class publishes an `Elapsed` event that
    you can subscribe to.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，`System.Timers.Timer` 类发布了一个 `Elapsed` 事件，你可以订阅该事件。
- en: '[PRE46]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: Here we create a new instance of the `Timer` class at ①. At ②, we subscribe
    to the `Elapsed` function using a *lambda expression* (an anonymous function)
    as the event handler. Once the timer is started at ③, the event handler prints
    `tick` and increments a reference cell’s value (remember, closures like the one
    created by the lambda expression can’t use mutable `let` bindings) every half-second,
    per the timer definition. When the tick counter reaches five, the loop will terminate
    and the timer will be stopped and disposed of.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们在①处创建一个新的 `Timer` 类实例。在②处，我们使用*lambda 表达式*（匿名函数）作为事件处理程序订阅 `Elapsed` 函数。定时器在③处启动后，事件处理程序每半秒打印
    `tick` 并增加一个引用单元格的值（记住，像 lambda 表达式创建的闭包不能使用可变的 `let` 绑定）。当计时器的计数器达到五时，循环将终止，定时器将停止并被释放。
- en: Observing Events
  id: totrans-158
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 观察事件
- en: The other primary benefit of F# events is that they enable you to treat events
    as sequences that you can intelligently partition, filter, aggregate, or otherwise
    act upon as they’re triggered. The `Event` module defines a number of functions—such
    as `add`, `filter`, `partition`, and `pairwise`—that accept published events.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: F# 事件的另一个主要好处是，它们使你能够将事件视为可以智能地分区、过滤、聚合或以其他方式在触发时处理的序列。`Event` 模块定义了许多函数——如
    `add`、`filter`、`partition` 和 `pairwise`——可以接受发布的事件。
- en: 'To see this principle in action, let’s turn to an example in ADO.NET. The `DataTable`
    class triggers a variety of events in response to certain actions like changed
    or deleted rows. If you wanted to handle the `RowChanged` event, you could add
    a single event handler (just as in the previous section) and include logic to
    filter out the events you don’t care about, or you could use the `filter` function
    from the `Event` module and invoke your handler only when it’s needed, as follows:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 为了演示这一原则，让我们来看一个 ADO.NET 中的例子。`DataTable` 类会在响应某些操作（如行的更改或删除）时触发多种事件。如果你想处理
    `RowChanged` 事件，可以添加一个事件处理程序（就像前一部分一样），并包含逻辑来过滤掉你不关心的事件，或者你也可以使用 `Event` 模块中的
    `filter` 函数，仅在需要时调用你的处理程序，如下所示：
- en: '[PRE47]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: We’ll forego a discussion of the first half of this example; for our purposes,
    all that’s important there is that it sets up a `DataTable` with three columns
    and a primary key. What’s really important here is the `partition` function.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将跳过这个例子前半部分的讨论；对我们来说，重要的是它设置了一个带有三列和主键的 `DataTable`。这里真正重要的是 `partition` 函数。
- en: In this example, we invoke the `partition` function at ③ by supplying both a
    delegate (in the form of a lambda expression) at ④ and the `Event` object published
    by the `DataTable`’s `RowChanged` event at ②. The `partition` function then returns
    two new events that we bind to `h1` and `h2` at ①. Finally, we subscribe to both
    of the new events by calling their `Add` method at ⑤ and ⑥.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们通过在④提供一个委托（以lambda表达式的形式）和在②提供`DataTable`的`RowChanged`事件发布的`Event`对象，来在③调用`partition`函数。然后，`partition`函数返回两个新事件，我们在①绑定到`h1`和`h2`。最后，我们通过在⑤和⑥调用它们的`Add`方法来订阅这两个新事件。
- en: Now that the table structure and event handlers are in place, we can add some
    rows and see how the events are triggered.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 现在表结构和事件处理程序已经就绪，我们可以添加一些行并查看事件是如何被触发的。
- en: '[PRE48]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: As you can see, when the first row is added, the last name doesn’t match the
    criteria specified in the filter, so `h2` is triggered. However, the second row
    does match the criteria, so `h1` is triggered instead.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，当第一行被添加时，姓氏不符合筛选条件，因此触发了`h2`。然而，第二行符合条件，因此触发了`h1`。
- en: If the syntax for calling the partition function looks backward, that’s because
    it is; the *forward pipelining operator* (`|>`) applies its left operand as the
    final argument to the function specified by its right operand. (The forward pipelining
    operator is used frequently in F#, and we’ll explore it in much more detail in
    [Chapter 5](ch05.html "Chapter 5. Let’s Get Functional").)
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 如果调用分区函数的语法看起来像是反向的，那是因为它确实如此；*前向管道操作符*（`|>`）将其左操作数作为右操作数指定函数的最终参数。（前向管道操作符在F#中使用频繁，我们将在[第5章](ch05.html
    "第5章：让我们变得函数式")中更详细地探讨它。）
- en: Custom Events
  id: totrans-168
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 自定义事件
- en: You can define your own custom events in your types. However, doing so is a
    bit different than in other .NET languages because events exist only as objects
    in F# and they lack keyword support.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在你的类型中定义自定义事件。然而，做到这一点与其他.NET语言有所不同，因为事件仅作为对象存在于F#中，并且缺少关键字支持。
- en: The first thing you need to do, aside from defining the type, is create a field
    (with a `let` binding) for your event object. This is the object used to coordinate
    publishing and triggering the event. Once the field is defined, you can expose
    the event’s `Publish` property to the outside world with a property of your own.
    Finally, you’ll need to trigger the event somewhere by calling the `Trigger` function.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 除了定义类型外，首先你需要做的是为你的事件对象创建一个字段（使用`let`绑定）。这是用来协调发布和触发事件的对象。一旦字段被定义，你可以通过自己定义的属性将事件的`Publish`属性暴露给外部。最后，你需要在某个地方通过调用`Trigger`函数来触发事件。
- en: '[PRE49]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: With the type defined, you can create a new instance and subscribe to the `ToggleChanged`
    event as with any built-in type. For example, next we use a partition to create
    two new event handlers, one to handle when the toggle is turned on and another
    to handle when it is turned off. The call to `Event.map` simply rephrases the
    event by throwing away the first parameter (the source, or sender, per .NET conventions)
    before calling the `partition` function.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 定义了类型后，你可以创建一个新实例，并像任何内建类型一样订阅`ToggleChanged`事件。例如，接下来我们使用分区来创建两个新的事件处理程序，一个处理切换打开时的情况，另一个处理切换关闭时的情况。调用`Event.map`只是通过丢弃第一个参数（源或发送者，按.NET约定）重新表述事件，然后再调用`partition`函数。
- en: '[PRE50]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: Now every call to the `Toggle` method will trigger the `ToggleChanged` event
    and cause one of the two handlers to execute.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，每次调用`Toggle`方法都会触发`ToggleChanged`事件，并执行两个处理程序中的一个。
- en: '[PRE51]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'As you’ve just seen, the `ToggleChanged` event is fully enabled within F#.
    If your class won’t be consumed outside F# assemblies, you could stop here. However,
    if you need to use it in assemblies written in different languages, you’ll have
    to do one more thing: decorate the `ToggleChanged` property with the `CLIEvent`
    attribute.'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你刚才看到的，`ToggleChanged`事件在F#中是完全启用的。如果你的类只会在F#程序集内部使用，你可以到此为止。然而，如果你需要在其他语言编写的程序集里使用它，你还需要做一件事：用`CLIEvent`特性装饰`ToggleChanged`属性。
- en: '[PRE52]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: The `CLIEvent` attribute instructs the compiler to include the appropriate metadata
    that makes the event consumable from other .NET languages.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: '`CLIEvent`特性指示编译器包括适当的元数据，使得该事件可以从其他.NET语言中消费。'
- en: Structures
  id: totrans-179
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 结构
- en: '*Structures*, or *structs*, are similar to classes in that they can have fields,
    properties, methods, and events. Structs are defined just like classes except
    that the type must be decorated with the `Struct` attribute.'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: '*结构*（或 *结构体*）与类类似，都可以拥有字段、属性、方法和事件。结构体的定义方式与类相同，不同之处在于类型必须使用 `Struct` 特性进行修饰。'
- en: '[PRE53]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: However, despite their similarities, behind the scenes, classes and structs
    are very different animals. The primary difference between them is that structs
    are *value types*.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，尽管类和结构体有相似之处，实际上它们在幕后是非常不同的。它们之间的主要区别在于结构体是 *值类型*。
- en: This difference is significant because it affects not only how you interact
    with the data but also how value types are represented in the computer’s memory.
    With both types, the runtime allocates space in memory to store the value. Value
    types always result in a new allocation with the data copied into that space.
    With reference types, the memory is allocated once and accessed via a reference
    that identifies its location.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 这个差异很重要，因为它不仅影响你如何与数据交互，还影响值类型在计算机内存中的表示方式。对于这两种类型，运行时都会在内存中分配空间来存储值。值类型总是会导致新的内存分配，并将数据复制到该空间。而对于引用类型，内存只会分配一次，通过引用来访问其位置。
- en: When you pass a reference type to a function, the runtime creates a new reference
    to that location in memory rather than a copy of the data. Therefore, reference
    types can more easily wreak havoc through side effects, because when you pass
    a reference type to a function any changes that you make to that object are immediately
    reflected wherever that object is referenced. In contrast, passing a value type
    to a function creates a copy of the value so any changes to it are isolated to
    that one instance.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 当你将一个引用类型传递给函数时，运行时会在内存中创建该位置的新引用，而不是数据的副本。因此，引用类型更容易通过副作用造成破坏，因为当你将引用类型传递给函数时，对该对象所做的任何修改都会立即反映到该对象被引用的地方。相反，传递值类型给函数会创建该值的副本，因此对其所做的任何修改仅限于该实例。
- en: Structs are also initialized differently than classes. Unlike classes, the compiler
    generates a default (parameterless) constructor for structs that initializes all
    fields to their appropriate zero value (`zero`, `null`, and so on). This means
    that you can’t use `let` bindings to create private instance fields or methods
    within a struct unless they’re static; instead, you must use `val` to define struct
    instance fields. Also, you can’t define your own default constructor, so any additional
    constructors you define must accept at least one parameter. (Your fields can still
    be mutable as long as you don’t include a primary constructor.)
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 结构体的初始化方式也不同于类。与类不同，编译器会为结构体生成一个默认的（无参数）构造函数，该构造函数将所有字段初始化为适当的零值（`zero`、`null`
    等）。这意味着，除非是静态字段，否则你不能使用 `let` 绑定在结构体中创建私有实例字段或方法；相反，你必须使用 `val` 来定义结构体实例字段。此外，你不能定义自己的默认构造函数，因此你定义的任何附加构造函数必须至少接受一个参数。（只要不包含主构造函数，你的字段仍然可以是可变的。）
- en: Because of differences in how memory is allocated for reference and value types,
    structs cannot contain fields of their own type. Without this restriction, the
    memory requirement for a struct instance would be infinitely large because each
    instance would recursively require enough space for another instance of the same
    type.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 由于引用类型和值类型在内存分配方式上的不同，结构体不能包含其自身类型的字段。如果没有这个限制，结构体实例的内存需求将是无限大的，因为每个实例都会递归地要求另一个相同类型实例所需的空间。
- en: Finally, structs can implement interfaces but cannot otherwise participate in
    inheritance. Regardless, structs still derive from `System.Object`, so you can
    override methods (like `ToString`).
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，结构体可以实现接口，但不能参与继承。无论如何，结构体仍然从 `System.Object` 派生，因此你可以重写方法（如 `ToString`）。
- en: Inheritance
  id: totrans-188
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 继承
- en: In OO programming, *inheritance* describes an *identity* relationship between
    two types in the way that an apple *is* a fruit. F# classes support *single inheritance*,
    meaning that any given class can directly inherit from only one other in order
    to establish a class hierarchy. Through inheritance, public (and sometimes internal)
    members exposed by the base type are automatically available in the derived type.
    You can see this principle in action in the following snippet.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 在面向对象编程中，*继承* 描述了两个类型之间的 *身份* 关系，类似于苹果 *是* 一种水果。F# 类支持 *单继承*，这意味着任何给定的类只能直接继承另一个类，以建立类层次结构。通过继承，基类公开的公共（有时是内部）成员会自动在派生类中可用。你可以在以下代码片段中看到这一原则的应用。
- en: '[PRE54]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: The `DerivedType` defined here doesn’t define any functionality of its own,
    but because it derives from `BaseType`, the `SayHello` method is accessible through
    `DerivedType`.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 这里定义的`DerivedType`没有定义任何自己的功能，但由于它继承自`BaseType`，所以可以通过`DerivedType`访问`SayHello`方法。
- en: F# inheritance requires a primary constructor. To specify a base class, include
    the `inherit` keyword followed by the base type name and its constructor arguments
    in the primary constructor before any bindings or member definitions. For instance,
    a task management system might have a `WorkItem` class that represents all work
    items in the system, as well as specialized classes such as `Defect` and `Enhancement`
    that derive from the `WorkItem` class, as shown next in bold.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: F# 的继承要求有一个主构造函数。要指定基类，可以在主构造函数中包含`inherit`关键字，后跟基类型名称及其构造函数参数，然后再进行任何绑定或成员定义。例如，一个任务管理系统可能有一个`WorkItem`类，表示系统中的所有工作项，以及像`Defect`和`Enhancement`这样的专门化类，这些类继承自`WorkItem`类，具体如下面加粗所示。
- en: '[PRE55]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: Every .NET class, including the primitive types, ultimately participates in
    inheritance. Also, when you define a class without explicitly specifying a base
    class, the defined class implicitly inherits from `System.Object`.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 每个 .NET 类，包括原始数据类型，最终都会参与继承。同时，当你定义一个类而没有显式指定基类时，定义的类会隐式地继承自`System.Object`。
- en: Casting
  id: totrans-195
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 类型转换
- en: In [Chapter 3](ch03.html "Chapter 3. Fundamentals") you learned how to convert
    between numeric types. Types can also be converted within their type hierarchy
    through the upcast and downcast operators.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第3章](ch03.html "第3章。基础知识")中，你学习了如何在数值类型之间进行转换。类型也可以通过向上转换和向下转换运算符在其类型层次结构内进行转换。
- en: Upcasting
  id: totrans-197
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 向上转换
- en: Until now I’ve maintained that there are no implicit conversions in F#, but
    that’s not entirely true. The only time that types are implicitly *upcast* (converted
    to a type higher in their inheritance structure) is when they’re passed to a method
    or a `let`-bound function where the corresponding parameter is a flexible type.
    In all other cases, you must explicitly cast the type with the *static cast* operator
    (`:>`).
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 直到现在我一直坚持认为 F# 中没有隐式转换，但这并不完全正确。唯一的隐式*向上转换*（转换为继承结构中更高层次的类型）发生的情况是，当类型被传递给一个方法或一个`let`绑定的函数，而该方法的参数类型是灵活类型。在其他所有情况下，你必须显式地使用*静态类型转换*运算符（`:>`）来转换类型。
- en: To see the static cast operator in action, let’s continue with the `WorkItem`
    example by creating a `Defect` and immediately casting it to a `WorkItem`.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 为了展示静态类型转换运算符的实际应用，让我们继续使用`WorkItem`示例，创建一个`Defect`并立即将其转换为`WorkItem`。
- en: '[PRE56]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: The static cast operator resolves valid casts at compile time. If the code compiles,
    the conversion will always succeed.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 静态类型转换运算符在编译时解析有效的转换。如果代码能够编译，转换就一定会成功。
- en: Downcasting
  id: totrans-202
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 向下转换
- en: The opposite of an upcast is a *downcast*. Downcasts are used to convert a type
    to something lower in its hierarchy, that is, to convert a base type to a derived
    type. To perform a downcast, you use the *dynamic cast* operator (`:?>`)
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 向上转换的相反操作是*向下转换*。向下转换用于将一个类型转换为其层次结构中更低的类型，即将基类型转换为派生类型。要执行向下转换，可以使用*动态类型转换*运算符（`:?>`）。
- en: Because the `WorkItem` instance we created in the previous example is still
    a `Defect`, we can use the dynamic cast operator to convert it back to a `WorkItem`.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 因为我们在前面的示例中创建的`WorkItem`实例仍然是一个`Defect`，所以我们可以使用动态类型转换运算符将其转换回`WorkItem`。
- en: '[PRE57]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: Unlike the static cast operator, the dynamic cast operator isn’t resolved until
    run time, so you may see an `InvalidCastException` if the target type isn’t valid
    for the source object. For instance, if you try to downcast `w` to `Enhancement`,
    the cast will fail.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 与静态类型转换运算符不同，动态类型转换运算符直到运行时才会解析，因此，如果目标类型不适用于源对象，可能会出现`InvalidCastException`。例如，如果你尝试将`w`向下转换为`Enhancement`，转换将失败。
- en: '[PRE58]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: Overriding Members
  id: totrans-208
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 重写成员
- en: Aside from reusing code, you might use inheritance to change the functionality
    offered by a base class by overriding its members.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 除了重用代码外，你还可以通过重写基类的成员来改变基类所提供的功能。
- en: For example, the `ToString` method defined on `System.Object` is a great (and
    often overlooked) debugging tool whose default implementation isn’t particularly
    informative because it just returns the type name. To make it more useful, your
    classes can override the default functionality and return a string that actually
    describes the object.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，`System.Object`上定义的`ToString`方法是一个很好的（但常被忽视的）调试工具，其默认实现并不特别有用，因为它仅仅返回类型名称。为了使其更有用，你的类可以重写默认功能，并返回一个真正描述对象的字符串。
- en: 'To illustrate, consider the `WorkItem` class from earlier. If you were to call
    its `ToString` method, you would see something like this:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 为了说明这一点，考虑之前的`WorkItem`类。如果你调用它的`ToString`方法，你将看到类似下面的内容：
- en: '[PRE59]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: Note
  id: totrans-213
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '*In the preceding example, FSI_0002+ is an artifact of invoking the code in
    FSI. Your type name will probably differ.*'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: '*在前面的例子中，FSI_0002+是调用FSI代码时的产物。你的类型名称可能会有所不同。*'
- en: To override the default behavior and make `ToString` return something more useful,
    define a new method with the `override` keyword.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 要覆盖默认行为并使`ToString`返回更有用的内容，请使用`override`关键字定义一个新方法。
- en: '[PRE60]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: If you call `ToString` now, the result will be the summary text instead of the
    type name.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 如果现在调用`ToString`，结果将是摘要文本，而不是类型名称。
- en: '[PRE61]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'You can override a given function only once per type, but you can override
    it at multiple levels in the hierarchy. For instance, here’s how you could override
    `ToString` again in the `Defect` class to display the severity of the defect:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 每个类型只能覆盖给定函数一次，但你可以在层次结构的多个级别进行覆盖。例如，这里展示了如何在`Defect`类中再次覆盖`ToString`，以显示缺陷的严重性：
- en: '[PRE62]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: When overriding a *virtual member* (an abstract member with a default implementation),
    you can call into the base functionality through the `base` keyword. The `base`
    keyword behaves like a self-identifier except that it represents the base class.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 当覆盖*虚拟成员*（一个具有默认实现的抽象成员）时，可以通过`base`关键字调用基类的功能。`base`关键字的行为像自我标识符，只不过它代表的是基类。
- en: 'Continuing with our `ToString` override theme, to augment the default behavior
    your override could call `base.ToString()` like this:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 继续我们的`ToString`重写主题，为了增强默认行为，你的重写可以像这样调用`base.ToString()`：
- en: '[PRE63]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'Note that the `base` keyword is available only in classes that explicitly inherit
    from another type. To use the `base` keyword in a class that inherits from `System.Object`,
    you would need to explicitly inherit from it as follows:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，`base`关键字仅在显式继承自其他类型的类中可用。要在继承自`System.Object`的类中使用`base`关键字，你需要显式地继承它，如下所示：
- en: '[PRE64]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: Abstract Classes
  id: totrans-226
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 抽象类
- en: An *abstract class* is one that can’t be directly instantiated; it’s accessible
    only through derived classes. Abstract classes typically define a common interface
    and optional implementation for a group of related classes that fulfill similar
    needs in different ways. Abstract classes are used throughout the .NET Framework;
    one great example is the `TextWriter` class in the `System.IO` namespace.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: '*抽象类*是不能直接实例化的类；它只能通过派生类访问。抽象类通常为一组相关类定义公共接口和可选实现，这些类以不同方式满足类似需求。抽象类在.NET框架中被广泛使用，一个很好的例子是`System.IO`命名空间中的`TextWriter`类。'
- en: The `TextWriter` class defines a common mechanism for writing characters to
    *something*. It doesn’t care where or how the characters are written, but it orchestrates
    some of the process, with the implementation details left to individual derived
    classes such as `StreamWriter`, `StringWriter`, and `HttpWriter`.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: '`TextWriter`类定义了一个写入字符到*某个地方*的通用机制。它不关心字符写入的位置或方式，但它协调了这一过程，具体的实现细节则交给像`StreamWriter`、`StringWriter`和`HttpWriter`这样的派生类来完成。'
- en: 'You can define your own abstract classes by decorating the type definition
    with the `AbstractClass` attribute. For example, to create a simple tree structure
    you could use an abstract class as follows:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过用`AbstractClass`属性修饰类型定义来定义自己的抽象类。例如，要创建一个简单的树形结构，你可以使用如下的抽象类：
- en: '[PRE65]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: Abstract Members
  id: totrans-231
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 抽象成员
- en: One reason to define an abstract class is to define *abstract members*, that
    is, members without an implementation. Abstract members are allowed only in abstract
    classes (or interfaces, described in [Interfaces](ch04.html#interfaces "Interfaces"))
    and must be implemented in a derived class. They’re handy when you want to define
    what a class does but not how it does it.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 定义抽象类的一个原因是为了定义*抽象成员*，即没有实现的成员。抽象成员仅允许出现在抽象类中（或者接口中，见[接口](ch04.html#interfaces
    "Interfaces")），并且必须在派生类中实现。当你想定义一个类做什么，但不关心它是如何做的时，抽象成员非常有用。
- en: Abstract Properties
  id: totrans-233
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 抽象属性
- en: When you want to define the data associated with a particular type but not how
    that data is stored or what happens when it is accessed, you can define an *abstract
    property* with the `abstract` keyword.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 当你想定义与特定类型关联的数据，但不关心这些数据是如何存储的或在访问时会发生什么时，你可以使用`abstract`关键字定义*抽象属性*。
- en: 'For example, this abstract class contains one abstract property:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，这个抽象类包含一个抽象属性：
- en: '[PRE66]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: '`AbstractBaseClass` requires only that its subtypes implement the `SomeData`
    property, but they’re free to implement their own storage mechanism. For instance,
    one derived class may use a traditional backing store, whereas another may opt
    to use a .NET generic dictionary as follows:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: '`AbstractBaseClass` 仅要求其子类实现`SomeData`属性，但它们可以自由实现自己的存储机制。例如，一个派生类可能使用传统的后备存储，而另一个则可能选择使用
    .NET 泛型字典，如下所示：'
- en: '[PRE67]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: As you can see, both `BindingBackedClass` and `DictionaryBackedClass` derive
    from `AbstractBaseClass`, but they implement the `SomeData` property in very different
    ways.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，`BindingBackedClass`和`DictionaryBackedClass`都继承自`AbstractBaseClass`，但它们以非常不同的方式实现了`SomeData`属性。
- en: Abstract Methods
  id: totrans-240
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 抽象方法
- en: Even though you can define abstract properties, you’re much more likely to use
    *abstract methods*. Like abstract properties, abstract methods allow you to define
    a capability that derived classes must implement without specifying any of the
    implementation details. For example, when calculating the area of a shape, you
    might define an abstract `Shape` class that includes an abstract `GetArea` method.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管你可以定义抽象属性，但你更有可能使用*抽象方法*。像抽象属性一样，抽象方法允许你定义派生类必须实现的能力，而无需指定任何实现细节。例如，在计算形状的面积时，你可能会定义一个抽象的`Shape`类，其中包含一个抽象的`GetArea`方法。
- en: '[PRE68]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: Because the method doesn’t have an implementation, you must explicitly define
    the entire signature. In this case, the `GetArea` method accepts `unit` and returns
    a float.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 由于该方法没有实现，你必须显式定义整个签名。在这种情况下，`GetArea`方法接受`unit`并返回一个浮动值。
- en: 'Overriding a method is also similar to overriding a property, as you can see
    in the following `Circle` and `Rectangle` classes:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 重写方法也类似于重写属性，正如你在以下`Circle`和`Rectangle`类中看到的那样：
- en: '[PRE69]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: Virtual Members
  id: totrans-246
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 虚拟成员
- en: Like C# and Visual Basic, F# allows *virtual members*—that is, properties or
    methods that can be overridden in a derived class. But unlike other .NET languages,
    F# takes a more literal approach to virtual members. For instance, in C# you include
    the `virtual` modifier in a nonprivate instance member definition, and in Visual
    Basic you use the `Overridable` modifier to achieve the same effect.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 与 C# 和 Visual Basic 一样，F# 也允许*虚拟成员*——即可以在派生类中重写的属性或方法。但与其他 .NET 语言不同，F# 对虚拟成员采取了更为字面化的方法。例如，在
    C# 中，你会在非私有实例成员定义中包含`virtual`修饰符，而在 Visual Basic 中，你则使用`Overridable`修饰符来实现相同的效果。
- en: Virtual members in F# are closely related to abstract members. In fact, in order
    to create a virtual member you first define an abstract member and then provide
    a default implementation with the `default` keyword. For example, in the following
    listing the `Node` class is the basis for a simple tree structure. It provides
    two virtual methods, `AddChild` and `RemoveChild`, which help control the tree
    structure.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: F#中的虚拟成员与抽象成员密切相关。实际上，要创建一个虚拟成员，你首先定义一个抽象成员，然后使用`default`关键字提供默认实现。例如，在以下代码中，`Node`类是一个简单树结构的基础。它提供了两个虚拟方法，`AddChild`和`RemoveChild`，用于帮助控制树结构。
- en: '[PRE70]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: With this definition, all `Node` class instances (including any derived types)
    will allow children. To create a specialized `Node` that doesn’t allow children,
    you could define a `TerminalNode` class and override both virtual methods to prevent
    children from being added or removed.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这个定义，所有`Node`类的实例（包括任何派生类型）都将允许子节点。为了创建一个不允许子节点的特定`Node`类，你可以定义一个`TerminalNode`类，并重写这两个虚拟方法，以防止添加或移除子节点。
- en: '[PRE71]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: Sealed Classes
  id: totrans-252
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 密封类
- en: A *sealed class* is a class that cannot serve as the base class for another
    class. One of the most notable sealed classes in the .NET Framework is `System.String`.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: '*密封类*是不能作为其他类基类的类。在 .NET Framework 中，最著名的密封类之一是`System.String`。'
- en: 'You can create your own sealed classes by decorating them with the `Sealed`
    attribute, as shown in the following snippet:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过使用`Sealed`属性来创建你自己的密封类，如以下代码片段所示：
- en: '[PRE72]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 'If you tried to create another class that inherits from the `NotInheritable`
    class, the compiler would raise an error like this:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你试图创建一个继承自`NotInheritable`类的其他类，编译器将会抛出类似如下的错误：
- en: '[PRE73]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: Static Members
  id: totrans-258
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 静态成员
- en: Fields, properties, and methods are instance members by default. You can make
    each static so that it applies to the type rather than a specific instance by
    including the `static` keyword before the member definition.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 字段、属性和方法默认是实例成员。你可以通过在成员定义前加上`static`关键字，将它们设为静态成员，使其适用于类型而不是特定实例。
- en: A Word about Static Classes
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 关于静态类的说明
- en: In C# a *static class* is an implicitly sealed class that cannot be instantiated
    and in which all members are static. Most of the time in F#, when you want static
    class–like functionality, you’ll place it in a module. However, modules have certain
    limitations. For example, they don’t allow you to overload functions.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 在 C# 中，*静态类* 是一个隐式封闭的类，无法实例化，并且其中的所有成员都是静态的。在 F# 中，大多数情况下，当你需要类似静态类的功能时，会将其放在模块中。然而，模块有一定的局限性。例如，模块不允许你重载函数。
- en: Although F# doesn’t directly support static classes the way that C# does, you
    can do a little syntactic dance to achieve a similar effect. To do so, omit the
    primary constructor (or make it private if you need a static initializer) to ensure
    that no instances can be created, and then verify that every member is static
    (the F# compiler won’t enforce this for you). For completeness, decorate the class
    with `SealedAttribute` so that nothing inherits from it.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管 F# 并不像 C# 那样直接支持静态类，但你可以通过一些语法技巧来实现类似的效果。为此，需要省略主构造函数（或者如果需要静态初始化器，则将其设为私有），以确保无法创建实例，然后验证每个成员是否为静态成员（F#
    编译器不会为你强制执行此检查）。为了完整性，可以使用 `SealedAttribute` 装饰类，确保没有任何类继承自它。
- en: Static Initializers
  id: totrans-263
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 静态初始化器
- en: '*Static initializers*, or *static constructors*, execute only once per class
    and ensure that certain code is executed before a class is used for the first
    time. You create static initializers in F# through a series of static `let` and
    `do` bindings, just as you would when defining a primary constructor. In fact,
    if your class needs a static initializer, you must include a primary constructor
    to contain the static bindings as shown here:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: '*静态初始化器*，或称 *静态构造函数*，每个类只会执行一次，并确保某些代码在类首次使用之前执行。在 F# 中，可以通过一系列静态的 `let` 和
    `do` 绑定来创建静态初始化器，就像定义主构造函数时一样。事实上，如果你的类需要静态初始化器，必须包含一个主构造函数来容纳这些静态绑定，如下所示：'
- en: '[PRE74]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: Static initializers can access only the static members of their containing class.
    If you try to access an instance member from within a static initializer, you’ll
    get a compiler error.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 静态初始化器只能访问它所包含类的静态成员。如果你尝试在静态初始化器中访问实例成员，将会收到编译错误。
- en: Static Fields
  id: totrans-267
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 静态字段
- en: '*Static fields* are often useful as a single reference for something you need
    to use repeatedly. For example, to associate certain data with the class itself,
    define a static field by including the `static` keyword before a `let` binding,
    as shown here:'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: '*静态字段* 常用于作为单一引用，以便你需要反复使用某些数据。例如，为了将某些数据与类本身关联，可以通过在 `let` 绑定前加上 `static`
    关键字来定义一个静态字段，如下所示：'
- en: '[PRE75]'
  id: totrans-269
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: When the `DoSomething` and `DoSomethingElse` methods are called, each calls
    a function in the `Logger` module to write a log message in the same category
    but without the duplication of data.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 当调用 `DoSomething` 和 `DoSomethingElse` 方法时，每个方法都会调用 `Logger` 模块中的一个函数，写入相同类别的日志消息，但不会重复数据。
- en: '[PRE76]'
  id: totrans-271
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: Static Properties
  id: totrans-272
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 静态属性
- en: Properties can also be static. Here, a read-only *static property* is used to
    expose the number of times a particular method has been called across all instances
    of your class.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 属性也可以是静态的。这里使用了一个只读的 *静态属性* 来暴露特定方法在所有类实例中被调用的次数。
- en: '[PRE77]'
  id: totrans-274
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: Every time the `Process` method is called, it increments the `itemsProcessed`
    field and prints a message. To see how many times the `Process` method has been
    called across all instances, inspect the `ItemsProcessed` property on the `Processor`
    class itself.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 每次调用 `Process` 方法时，它会递增 `itemsProcessed` 字段并打印一条消息。要查看 `Process` 方法在所有实例中被调用的次数，请检查
    `Processor` 类本身的 `ItemsProcessed` 属性。
- en: '[PRE78]'
  id: totrans-276
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: This example iterates as long as the `Process` method has been invoked fewer
    than five times. Each iteration creates a new instance of the `Processor` class
    and invokes its `Process` method (which illustrates how the static property is
    instance agnostic).
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 这个示例会迭代，直到 `Process` 方法被调用的次数少于五次。每次迭代都会创建一个新的 `Processor` 类实例，并调用它的 `Process`
    方法（这展示了静态属性与实例无关的特性）。
- en: Static Methods
  id: totrans-278
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 静态方法
- en: Like other static members, *static methods* apply to a type rather than an instance.
    For example, static methods are commonly used in the *Factory pattern* (a common
    approach to creating instances of similar classes without relying on a specific
    implementation). In some variations of the Factory pattern, a static method returns
    new instances of objects that conform to a specific interface. To illustrate this
    concept, consider an application where you need to handle different image formats.
    You may have an abstract `ImageReader` class that other types derive from in order
    to handle specific formats like JPEG, GIF, and PNG.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 和其他静态成员一样，*静态方法*是应用于类型而不是实例的。例如，静态方法常用于*工厂模式*（一种创建相似类实例的常见方法，而无需依赖特定的实现）。在一些工厂模式的变种中，静态方法返回符合特定接口的对象的新实例。为了说明这一概念，假设有一个需要处理不同图像格式的应用程序。你可能有一个抽象的`ImageReader`类，其他类型可以从该类派生，以处理特定的格式，如JPEG、GIF和PNG。
- en: '[PRE79]'
  id: totrans-280
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: 'A Factory method for creating instances of these classes might look something
    like this:'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 创建这些类实例的工厂方法可能如下所示：
- en: '[PRE80]'
  id: totrans-282
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: 'The static `CreateReader` method in the preceeding snippet uses F# pattern
    matching to create the appropriate `ImageReader` implementation based on the provided
    filename. When the file extension isn’t recognized, it raises an exception indicating
    that the format isn’t supported. Because the method is static, you can call it
    without creating an instance of the `ImageReaderFactory` class, as shown here:'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码段中的静态`CreateReader`方法使用F#模式匹配，根据提供的文件名创建适当的`ImageReader`实现。当文件扩展名无法识别时，它会抛出一个异常，指示该格式不受支持。由于该方法是静态的，因此可以在不创建`ImageReaderFactory`类实例的情况下调用它，如下所示：
- en: '[PRE81]'
  id: totrans-284
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: Mutually Recursive Types
  id: totrans-285
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 相互递归类型
- en: When two or more types depend on each other such that one cannot be used without
    the other, the types are said to be *mutually recursive*.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 当两个或多个类型相互依赖，无法单独使用其中一个类型而不依赖另一个时，这些类型被称为*相互递归*。
- en: 'To illustrate, think of a book and its pages. The book can contain a collection
    of pages, but each page might also refer back to the book. Remember, F# is evaluated
    top-down, so which type would you define first? The book or the page? Because
    the book depends on its pages and the page refers back to the book, there is mutual
    recursion here. This means that you must define the types together using the `and`
    keyword, as shown here:'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 举个例子，想象一本书和它的页面。书本可以包含一组页面，但每个页面也可能会引用回书本。请记住，F#是自上而下进行评估的，那么你会先定义哪个类型呢？书本还是页面？由于书本依赖于其页面，并且页面又引用回书本，这里就有了相互递归。这意味着你必须使用`and`关键字将这些类型一起定义，如下所示：
- en: '[PRE82]'
  id: totrans-288
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: Interfaces
  id: totrans-289
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 接口
- en: 'In OO programming, *interfaces* specify the properties, methods, and sometimes
    even events that a type must support. In some ways interfaces are like abstract
    classes, with certain important differences. For one, unlike abstract classes,
    interfaces cannot contain any implementations of their members; their members
    must be abstract. Also, because interfaces define functionality that implementers
    must support, all interface members are implicitly public. Finally, interfaces
    aren’t subject to the same inheritance restrictions as classes: A class can implement
    any number of interfaces (and structs can, too).'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 在面向对象编程中，*接口*指定了类型必须支持的属性、方法，有时还包括事件。在某些方面，接口类似于抽象类，但存在一些重要的区别。首先，与抽象类不同，接口不能包含其成员的实现；它们的成员必须是抽象的。此外，由于接口定义了实现者必须支持的功能，因此所有接口成员默认是公开的。最后，接口不受与类相同的继承限制：一个类可以实现任意数量的接口（结构体也可以）。
- en: Implementing Interfaces
  id: totrans-291
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 实现接口
- en: F# approaches interface implementation a bit differently than its .NET language
    counterparts. C# and Visual Basic allow both implicit and explicit implementations.
    With *implicit implementations*, interface members are accessible directly through
    the implementing class, whereas with *explicit implementations*, interface members
    are accessible only when the implementing type is treated as the interface.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: F#在接口实现方面与其.NET语言的同行有所不同。C#和Visual Basic都允许隐式和显式实现。通过*隐式实现*，接口成员可以通过实现类直接访问，而通过*显式实现*，接口成员只能在将实现类型视为接口时访问。
- en: 'Consider this C# example with two classes that both implement the `IDisposable`
    interface:'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑这个C#示例，其中有两个类都实现了`IDisposable`接口：
- en: '[PRE83]'
  id: totrans-294
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: 'Both classes implement `IDisposable`, but `ImplicitExample`① does so implicitly
    and `ExplicitExample` ② does it explicitly. This difference has a dramatic effect
    on how you call the `Dispose` method in each class, as shown here:'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个类都实现了`IDisposable`，但`ImplicitExample`①是隐式实现的，而`ExplicitExample`②是显式实现的。这种差异会显著影响你在每个类中调用`Dispose`方法的方式，如下所示：
- en: '[PRE84]'
  id: totrans-296
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: Here we instantiate `ImplicitExample` at ① and `ExplicitExample` at ③. For both
    classes we call the `Dispose` method, but because `Dispose` is implicitly implemented
    in the `ImplicitExample` class we can call it directly through `ex1`, as we do
    at ②. The compiler would produce an error if we tried the same approach with `ex2`
    because `Dispose` is explicitly implemented in `ExplicitExample`. Instead, we
    need to cast `ex2` to `IDisposable`, as shown at ④, in order to call its `Dispose`
    method.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 在①处我们实例化了`ImplicitExample`，在③处我们实例化了`ExplicitExample`。对于这两个类，我们都调用了`Dispose`方法，但因为`Dispose`在`ImplicitExample`类中是隐式实现的，所以我们可以直接通过`ex1`调用它，如在②处所示。如果我们尝试对`ex2`采用相同的方法，编译器会报错，因为`Dispose`在`ExplicitExample`类中是显式实现的。相反，我们需要将`ex2`强制转换为`IDisposable`，如在④处所示，才能调用其`Dispose`方法。
- en: Note
  id: totrans-298
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '*All interface implementations in F# are explicit. Though F# honors implicit
    interface implementations on types defined in other languages, any implementations
    that you define in F# will be explicit.*'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: '*F#中的所有接口实现都是显式的。尽管F#支持在其他语言中定义的类型上进行隐式接口实现，但你在F#中定义的任何实现都会是显式的。*'
- en: 'Implementing an interface in F# is similar to inheriting from another class
    except that it uses the `interface` keyword. For example, to implement `IDisposable`
    in one of your types, you could do this:'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 在F#中实现接口类似于继承其他类，只是它使用了`interface`关键字。例如，要在某个类型中实现`IDisposable`，你可以这样做：
- en: '[PRE85]'
  id: totrans-301
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: 'To manually invoke the `Dispose` method on the `MyDisposable` class, you’ll
    need to cast an instance to `IDisposable`, as shown here with the static cast
    operator:'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 要手动调用`MyDisposable`类的`Dispose`方法，你需要将实例强制转换为`IDisposable`，如下所示，使用静态强制转换运算符：
- en: '[PRE86]'
  id: totrans-303
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: Defining Interfaces
  id: totrans-304
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 定义接口
- en: 'When you define a type without any constructors and only abstract members,
    the F# compiler infers that the type is an interface. For example, an interface
    for working with image data might look something like this:'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 当你定义一个没有任何构造函数并且只有抽象成员的类型时，F# 编译器会推断该类型是一个接口。例如，一个用于处理图像数据的接口可能像这样：
- en: '[PRE87]'
  id: totrans-306
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: 'As you can see, the `IImageAdapter` type contains no constructors and all of
    its four members are abstract. To define an empty, or *marker*, interface you
    can end the definition with the `interface end` keyword pair:'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，`IImageAdapter`类型没有构造函数，且它的四个成员都是抽象的。要定义一个空接口，或者说是*标记接口*，你可以用`interface
    end`关键字对来结束定义：
- en: '[PRE88]'
  id: totrans-308
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: Note
  id: totrans-309
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '*It’s standard practice in .NET development to begin interface names with a
    capital letter* I *. You should do so for the sake of consistency.*'
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: '*在.NET开发中，接口名通常以大写字母I开头*。为了保持一致性，你应该遵循这一惯例。'
- en: Like classes, interfaces can inherit from each other to define more specialized
    contracts. Also like classes, interface inheritance is accomplished with the `inherit`
    keyword.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 与类一样，接口也可以继承彼此，以定义更为专门的契约。同样，接口继承也是通过`inherit`关键字实现的。
- en: 'Let’s continue our imaging example. The `IImageAdapter` interface is helpful
    for working with any image format, but some formats include capabilities not available
    in others. To handle these, you could define additional interfaces that represent
    these capabilities. For example, when working with a format that supports transparency
    you might create an `ITransparentImageAdapter` that derives from `IImageAdapter`,
    as shown here:'
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们继续以图像处理为例。`IImageAdapter`接口对于处理任何图像格式都很有帮助，但某些格式包含其他格式没有的功能。为了处理这些功能，你可以定义额外的接口来表示这些功能。例如，在处理支持透明度的格式时，你可能会创建一个从`IImageAdapter`继承的`ITransparentImageAdapter`，如下所示：
- en: '[PRE89]'
  id: totrans-313
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: Now, any types that implement the `ITransparentImageAdapter` must implement
    all members defined by both `IImageAdapter` and `ITransparentImageAdapter`.
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，任何实现了`ITransparentImageAdapter`的类型必须实现`IImageAdapter`和`ITransparentImageAdapter`中定义的所有成员。
- en: Custom Operators
  id: totrans-315
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 自定义操作符
- en: In [Chapter 3](ch03.html "Chapter 3. Fundamentals") you saw numerous predefined
    operators for working with the built-in data types. You can use *operator overloading*
    to extend many of these to your types as well. By overloading operators, you can
    make your custom types interact a bit more naturally.
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第3章](ch03.html "第3章：基础")中，你看到了许多用于处理内置数据类型的预定义操作符。你可以使用*操作符重载*来扩展这些操作符到你的类型上。通过重载操作符，你可以让自定义类型的交互更自然一些。
- en: 'Operators in F# come in two forms: prefix and infix. *Prefix operators* are
    placed before their operand, whereas *infix operators* are placed between their
    operands. F# operators can also be *unary* or *binary*, meaning that they operate
    against one or two arguments, respectively. Custom operators are defined as static
    methods except that the name is the operator wrapped in parentheses.'
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: F#中的操作符有两种形式：前缀和中缀。*前缀操作符*放在操作数之前，而*中缀操作符*则放在操作数之间。F#操作符还可以是*一元*或*二元*的，意味着它们分别对一个或两个参数进行操作。自定义操作符定义为静态方法，只不过名称是操作符并用括号括起来。
- en: Prefix Operators
  id: totrans-318
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 前缀操作符
- en: 'When defining a prefix operator, you must begin its name with a tilde (`~`)
    to distinguish it from infix operators with the same name. The tilde is not otherwise
    part of the operator. To demonstrate operator overloading, we’ll define a type
    that represents basic RGB colors. Consider this class definition:'
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 当定义前缀操作符时，你必须以波浪号（`~`）开头，以便与具有相同名称的中缀操作符区分开来。波浪号本身不是操作符的一部分。为了演示操作符重载，我们将定义一个表示基本RGB颜色的类型。请参考以下类定义：
- en: '[PRE90]'
  id: totrans-320
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: To calculate the negative color you could define a `GetNegative` function, but
    wouldn’t it be more intuitive to prefix an instance with the negative sign (`-`)
    instead?
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 要计算负颜色，你可以定义一个`GetNegative`函数，但将负号（`-`）作为前缀放在实例前面是不是更直观呢？
- en: '[PRE91]'
  id: totrans-322
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: 'With the custom operator defined, you can now create a color instance and find
    its negative with a convenient syntax like this:'
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 定义好自定义操作符后，你现在可以创建一个颜色实例，并用如下便捷的语法来查找它的负值：
- en: '[PRE92]'
  id: totrans-324
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: Infix Operators
  id: totrans-325
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 中缀操作符
- en: Creating infix operators is almost like creating prefix operators except that
    you omit the tilde character from the name.
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 创建中缀操作符几乎就像创建前缀操作符，只是你不需要在名称前加波浪号字符。
- en: Continuing with the `RgbColor` example, it would be nice to add and subtract
    two colors using the familiar and natural `+` and `-` operators.
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 继续使用`RgbColor`的示例，使用我们熟悉且自然的`+`和`-`操作符来加减两种颜色会非常方便。
- en: '[PRE93]'
  id: totrans-328
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: Now we can add and subtract colors just as we would add and subtract numbers.
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以像加减数字一样加减颜色。
- en: '[PRE94]'
  id: totrans-330
  prefs: []
  type: TYPE_PRE
  zh: '[PRE94]'
- en: New Operators
  id: totrans-331
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 新操作符
- en: You’re not limited to overloading only existing operators. You can define custom
    operators using various combinations of the characters `!`, `%`, `&`, `*`, `+`,
    `-`, `.`, `/`, `<`, `=`, `>`, `?`, `@`, `^`, `|`, and `~`. Creating custom operators
    can be complicated because the combination you select determines the precedence
    (priority) and associativity (right to left or left to right) of the operation.
    Furthermore, creating custom operators can hinder the comprehensibility of your
    code if you choose something that’s not intuitive. That said, if you still want
    to define a new operator, the definition looks the same as an overload.
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 你不仅可以重载现有的操作符，还可以使用`!`、`%`、`&`、`*`、`+`、`-`、`.`、`/`、`<`、`=`、`>`、`?`、`@`、`^`、`|`
    和 `~`等字符的各种组合来定义自定义操作符。创建自定义操作符可能会很复杂，因为你选择的组合决定了操作的优先级（precedence）和结合性（右到左或左到右）。此外，如果选择的操作符不直观，可能会影响代码的可读性。因此，如果你仍然想定义一个新的操作符，其定义方式与重载操作符相同。
- en: For example, in the previous section we overloaded the `+` operator to add two
    colors, but how about blending colors? The `+` operator would have been a nice
    choice for a blending operation, but because it’s already being used for adding
    colors we can define the `+=` operator instead.
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，在前一节中我们重载了`+`操作符来加两个颜色，但如果是混合颜色呢？`+`操作符本来是一个不错的混合操作符选择，但由于它已经被用于加颜色，我们可以改用`+=`操作符来代替。
- en: '[PRE95]'
  id: totrans-334
  prefs: []
  type: TYPE_PRE
  zh: '[PRE95]'
- en: 'Now blending two colors is as easy as adding them:'
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，混合两种颜色就像加它们一样简单：
- en: '[PRE96]'
  id: totrans-336
  prefs: []
  type: TYPE_PRE
  zh: '[PRE96]'
- en: Global Operators
  id: totrans-337
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 全局操作符
- en: 'Not only does F# allow you to overload operators on types, but you can also
    define operators globally. This lets you create new operators even for types you
    don’t control! For example, to define any of the custom operators on the standard
    `System.Drawing.Color` struct, you could define a new operator at the global level
    using a `let` binding as follows:'
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: F#不仅允许你在类型上重载操作符，还可以在全局范围内定义操作符。这使你能够为你无法控制的类型创建新操作符！例如，要为标准`System.Drawing.Color`结构定义任何自定义操作符，你可以使用`let`绑定在全局层面定义一个新操作符，如下所示：
- en: '[PRE97]'
  id: totrans-339
  prefs: []
  type: TYPE_PRE
  zh: '[PRE97]'
- en: Warning
  id: totrans-340
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 警告
- en: '*Be careful when defining global operators. Any operator you define that conflicts
    with the built-in one will take priority, meaning you can inadvertently replace
    core functionality.*'
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: '*在定义全局操作符时要小心。你定义的任何与内置操作符冲突的操作符都会优先级更高，这意味着你可能会无意中替换核心功能。*'
- en: Object Expressions
  id: totrans-342
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 对象表达式
- en: As an alternative to formal inheritance, F# provides *object expressions*, a
    handy construct for creating ad hoc (anonymous) types based on an existing class
    or interface. Object expressions are useful when you need a one-off type but don’t
    want to create a formal type. (Although the analogy isn’t perfect, you might find
    it helpful to think of object expressions as lambda expressions for types, because
    the result of an object expression is an instance of a new type that implements
    the interface or inherits from a base class.)
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 作为正式继承的替代，F#提供了*对象表达式*，这是一种创建基于现有类或接口的临时（匿名）类型的便捷构造。对象表达式在你需要一个一次性类型，但又不想创建正式类型时很有用。（虽然这个类比并不完全完美，但你可以将对象表达式视为类型的lambda表达式，因为对象表达式的结果是一个实现接口或继承自基类的新类型的实例。）
- en: 'For example, consider a simplified game scenario where a character can equip
    a weapon. You might see a weapon interface and character class like this:'
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，考虑一个简化的游戏场景，其中角色可以装备武器。你可能会看到像这样的武器接口和角色类：
- en: '[PRE98]'
  id: totrans-345
  prefs: []
  type: TYPE_PRE
  zh: '[PRE98]'
- en: 'You can use these definitions to create a few characters:'
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用这些定义来创建几个角色：
- en: '[PRE99]'
  id: totrans-347
  prefs: []
  type: TYPE_PRE
  zh: '[PRE99]'
- en: As currently written, if either character attacked the other he wouldn’t do
    much damage since he has only his fists. It would be nice to give each character
    a weapon, but all we have right now is the `IWeapon` interface. We could define
    types for every weapon we can think of, but it’s much more convenient to write
    a function that creates weapons for us via an object expression.
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 按照目前的写法，如果其中一个角色攻击另一个角色，他不会造成太大伤害，因为他只有拳头。给每个角色配备武器会是个不错的主意，但我们现在只有`IWeapon`接口。我们可以为每个想得出的武器定义类型，但通过对象表达式编写一个函数来创建武器会更方便。
- en: Object expressions, like the one in the following `forgeWeapon` function, are
    defined with the `new` keyword followed by the type name, the `with` keyword,
    and the member definitions all wrapped in braces.
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 对象表达式，如以下`forgeWeapon`函数中的表达式，通过`new`关键字后跟类型名称、`with`关键字和所有成员定义（用大括号包裹）来定义。
- en: '[PRE100]'
  id: totrans-350
  prefs: []
  type: TYPE_PRE
  zh: '[PRE100]'
- en: With the `forgeWeapon` function in place, we can create some weapons for our
    characters.
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 有了`forgeWeapon`函数，我们可以为我们的角色创建一些武器。
- en: '[PRE101]'
  id: totrans-352
  prefs: []
  type: TYPE_PRE
  zh: '[PRE101]'
- en: 'As you can see, both calls to `forgeWeapon` result in new instances of `IWeapon`.
    They can be used as if they had been formally defined through type definitions,
    as you can see by assigning each to a character and invoking the `Attack` function:'
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，两次调用`forgeWeapon`都将返回`IWeapon`的新实例。它们可以像通过类型定义正式定义的那样使用，例如将它们分别分配给角色并调用`Attack`函数：
- en: '[PRE102]'
  id: totrans-354
  prefs: []
  type: TYPE_PRE
  zh: '[PRE102]'
- en: Despite their convenience, object expressions aren’t suitable for every situation.
    One of their primary drawbacks is that they must implement every abstract member
    from the underlying type. If the underlying interface or base class has many abstract
    members, an object expression can become cumbersome very quickly, so you would
    probably want to consider using a different construct.
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管对象表达式很方便，但并不适用于每种情况。它们的一个主要缺点是，必须实现底层类型的每个抽象成员。如果底层接口或基类有很多抽象成员，对象表达式可能会变得非常繁琐，因此你可能会考虑使用其他构造。
- en: 'Object expressions aren’t limited to a single base type. To implement multiple
    base types with an object expression, you use an inheritance-like syntax. For
    instance, if you wanted weapons created through the `forgeWeapon` function to
    also implement `IDisposable`, you could use the following:'
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 对象表达式不限于单一基类型。要使用对象表达式实现多个基类型，可以使用类似继承的语法。例如，如果你希望通过`forgeWeapon`函数创建的武器也实现`IDisposable`，你可以使用以下代码：
- en: '[PRE103]'
  id: totrans-357
  prefs: []
  type: TYPE_PRE
  zh: '[PRE103]'
- en: 'Creating a new weapon is the same as earlier:'
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: 创建新武器和之前一样：
- en: '[PRE104]'
  id: totrans-359
  prefs: []
  type: TYPE_PRE
  zh: '[PRE104]'
- en: Objects created through object expressions that include multiple base types
    are always treated as the type listed immediately after the `new` keyword, unless
    they’re explicitly cast to one of the other types. For example, in the case of
    the `forgeWeapon` function, the returned object will be `IWeapon` unless you cast
    it to `IDisposable`.
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 通过对象表达式创建的包含多个基类型的对象，总是被视为`new`关键字后面紧接着列出的类型，除非它们被显式地转换为其他类型。例如，在`forgeWeapon`函数的情况下，返回的对象将是`IWeapon`，除非你将其转换为`IDisposable`。
- en: '[PRE105]'
  id: totrans-361
  prefs: []
  type: TYPE_PRE
  zh: '[PRE105]'
- en: Type Extensions
  id: totrans-362
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 类型扩展
- en: When LINQ was added to the .NET Framework, one exciting feature that it introduced
    to C# and Visual Basic was extension methods. *Extension methods* allow you to
    add new methods to an existing type without relying on inheritance or other design
    patterns such as the Decorator pattern. F# provides similar capabilities except
    that it doesn’t stop with methods. In F#, you can create extension methods, properties,
    events, and even static members!
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: 当LINQ被加入到.NET框架时，它为C#和Visual Basic引入的一个令人兴奋的特性是扩展方法。*扩展方法*允许你在不依赖继承或其他设计模式（如装饰器模式）的情况下向现有类型添加新方法。F#提供了类似的功能，不过它不仅限于方法。在F#中，你可以创建扩展方法、属性、事件，甚至静态成员！
- en: 'You extend existing types in F# through *type extensions*, or *type augmentations*.
    Type extensions come in two flavors: intrinsic and optional.'
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过*类型扩展*或*类型增强*来扩展F#中的现有类型。类型扩展有两种类型：内在扩展和可选扩展。
- en: '*Intrinsic extensions* must be defined in the same namespace or module, and
    in the same source file as the type being extended. The new extensions become
    part of the extended type when the code is compiled and are visible through reflection.
    Intrinsic extensions are useful when you want to build up a type incrementally
    by grouping related pieces or as an alternative to building mutually recursive
    type definitions.'
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: '*内在扩展*必须在与被扩展类型相同的命名空间或模块中定义，并且与该类型在同一个源文件中。新扩展在代码编译时成为扩展类型的一部分，并且可以通过反射查看。内在扩展非常适合在构建类型时按增量方式分组相关部分，或作为构建互递归类型定义的替代方案。'
- en: '*Optional extensions* must be defined in a module. Like their C# and Visual
    Basic counterparts, they are accessible only when their containing namespace or
    module is open but are not visible through reflection. Optional extensions are
    most useful for adding custom functionality to types you don’t control or that
    are defined in other assemblies.'
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: '*可选扩展*必须在一个模块中定义。与它们在C#和Visual Basic中的对应物一样，可选扩展只有在其包含的命名空间或模块被打开时才可访问，但无法通过反射看到。可选扩展最适合为你无法控制或在其他程序集定义的类型添加自定义功能。'
- en: Regardless of whether you’re defining intrinsic or optional extensions, the
    syntax is the same. You begin with a new type definition. The difference is that
    instead of using a primary constructor and an equal sign, you use the `with` keyword
    followed by your extension definitions. For example, here we extend the `Color`
    struct (in `System.Drawing`) with both a static and an instance method.
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: 无论是定义内在扩展还是可选扩展，语法都是相同的。你从一个新的类型定义开始。不同之处在于，你不是使用主构造函数和等号，而是使用`with`关键字，后跟扩展定义。例如，在这里我们通过静态方法和实例方法扩展了`Color`结构体（位于`System.Drawing`命名空间）。
- en: '[PRE106]'
  id: totrans-368
  prefs: []
  type: TYPE_PRE
  zh: '[PRE106]'
- en: This optional type extension enhances the `Color` struct’s usability by allowing
    you to create new instances from known hexadecimal color strings or translate
    the color into a hexadecimal color string. The type extension itself is at ②.
    The static extension method ③ relies on the regular expression (a domain-specific
    language for parsing strings) at ① to match and extract the hexadecimal value
    to convert it into the ARGB value passed to `Color`’s constructor. The instance
    extension method ④ simply returns the ARGB value formatted as a hexadecimal string.
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: 这个可选的类型扩展通过允许你从已知的十六进制颜色字符串创建新的实例或将颜色转换为十六进制颜色字符串，增强了`Color`结构体的可用性。类型扩展本身位于②。静态扩展方法③依赖于正则表达式（用于解析字符串的领域特定语言）①来匹配并提取十六进制值，将其转换为传递给`Color`构造函数的ARGB值。实例扩展方法④则简单地返回格式化为十六进制字符串的ARGB值。
- en: Cross-Language Considerations
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: 跨语言考虑
- en: Despite serving a similar purpose, extension methods in F# are implemented differently
    than in the rest of the .NET Framework. Therefore, optional extension methods
    defined in F# aren’t accessible as extension methods in C# or Visual Basic unless
    you include the `Extension` attribute in both the type definition and extension
    methods.
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管目标相似，F#中的扩展方法实现与.NET框架中的其他部分有所不同。因此，在F#中定义的可选扩展方法，在C#或Visual Basic中无法作为扩展方法访问，除非你在类型定义和扩展方法中都包含`Extension`特性。
- en: Summary
  id: totrans-372
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 摘要
- en: Despite F#’s perception as a niche functional language on the .NET Framework,
    you’ve seen in this chapter that F# is also a full-featured OO language. Numerous
    examples demonstrated how F#’s concise syntax aids you in developing robust OO
    frameworks complete with classes, structures, and interfaces. You’ve even seen
    how to implement some common design patterns like Singleton and Factory.
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管 F# 在 .NET 框架中被视为一种小众的函数式语言，但在本章中你已经看到，F# 同时也是一门功能完备的面向对象语言。通过众多示例，你了解了 F#
    简洁的语法如何帮助你开发健壮的面向对象框架，其中包括类、结构和接口。你甚至看到如何实现一些常见的设计模式，如单例模式和工厂模式。
- en: Although F# supports the same common OO concepts as its more established counterpart
    languages, you’ve learned how it takes familiar concepts like operator overloading,
    events, and extension methods and expands them into something much more powerful
    through observation and type augmentation. Finally, you’ve seen how entirely new
    constructs like object expressions can improve code quality by allowing you to
    create ad hoc types when and where you need them.
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管 F# 支持与其更成熟的对等语言相同的常见面向对象概念，但你也学到了它如何通过观察和类型增强，将运算符重载、事件和扩展方法等熟悉的概念扩展为更强大的功能。最后，你还了解了如何利用全新的构造，如对象表达式，通过在需要时创建临时类型来提高代码质量。
