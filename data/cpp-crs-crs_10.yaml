- en: '**8'
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '**8'
- en: STATEMENTS**
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: STATEMENTS**
- en: '*Progress doesn’t come from early risers—progress is made by lazy men looking
    for easier ways to do things.'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: '*进步不是来自早起的人——进步是由懒人寻找更简单的方法来做事情所带来的。*'
- en: —Robert A. Heinlein*, Time Enough for Love
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: —Robert A. Heinlein，《爱情需要足够的时间》
- en: '![Image](../images/common.jpg)'
  id: totrans-4
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/common.jpg)'
- en: Each C++ function comprises a sequence of *statements*, which are programming
    constructs that specify the order of execution. This chapter uses an understanding
    of the object life cycle, templates, and expressions to explore the nuances of
    statements.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 每个 C++ 函数由一系列 *语句* 组成，语句是指定执行顺序的编程构造。本章通过理解对象生命周期、模板和表达式，来探索语句的细微差别。
- en: '**Expression Statements**'
  id: totrans-6
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**表达式语句**'
- en: An *expression statement* is an expression followed by a semicolon (`;`). Expression
    statements comprise most of the statements in a program. You can turn any expression
    into a statement, which you should do whenever you need to evaluate an expression
    but want to discard the result. Of course, this is only useful if evaluating that
    expression causes a side effect, like printing to the console or modifying the
    program’s state.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: '*表达式语句* 是一个表达式后跟一个分号（`;`）。表达式语句构成了程序中的大多数语句。您可以将任何表达式转换为语句，这应该在您需要评估一个表达式但又想丢弃其结果时进行。当然，这只有在评估该表达式会引起副作用时才有用，比如打印到控制台或修改程序的状态。'
- en: '[Listing 8-1](ch08.xhtml#ch08ex01) contains several expression statements.'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: '[清单 8-1](ch08.xhtml#ch08ex01) 包含了几个表达式语句。'
- en: '[PRE0]'
  id: totrans-9
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '*Listing 8-1: A simple program containing several expression statements*'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 8-1：包含几个表达式语句的简单程序*'
- en: The expression statement at ➊ has a side effect (incrementing `x`), but the
    one at ➋ doesn’t. Both are valid (although the one at ➋ isn’t useful). The function
    call to `printf` ➌ is also an expression statement.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: ➊ 处的表达式语句有副作用（递增 `x`），但 ➋ 处的没有。两者都是有效的（尽管 ➋ 处的没有用）。对 `printf` ➌ 的函数调用也是一个表达式语句。
- en: '**Compound Statements**'
  id: totrans-12
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**复合语句**'
- en: '*Compound statements*, also called *blocks*, are a sequence of statements enclosed
    by braces `{ }`. Blocks are useful in control structures like `if` statements,
    because you might want multiple statements to execute rather than one.'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: '*复合语句*，也叫 *块*，是一系列由花括号 `{ }` 包围的语句。块在控制结构中很有用，例如 `if` 语句，因为您可能希望执行多个语句而不仅仅是一个。'
- en: 'Each block declares a new scope, which is called a *block scope*. As you learned
    in [Chapter 4](ch04.xhtml#ch04), objects with automatic storage duration declared
    within a block scope have lifetimes bound by the block. Variables declared within
    a block get destroyed in a well-defined order: the reverse of the order in which
    they were declared.'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 每个块声明了一个新的作用域，称为 *块作用域*。正如您在 [第 4 章](ch04.xhtml#ch04) 中所学，声明在块作用域内的具有自动存储期限的对象，其生命周期与块的生命周期绑定。块内声明的变量按照其声明的反向顺序销毁。
- en: '[Listing 8-2](ch08.xhtml#ch08ex02) uses the trusty `Tracer` class from [Listing
    4-5](ch04.xhtml#ch04ex05) (on [page 97](ch04.xhtml#page_97)) to explore block
    scope.'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: '[清单 8-2](ch08.xhtml#ch08ex02) 使用了来自 [清单 4-5](ch04.xhtml#ch04ex05)（位于 [第 97
    页](ch04.xhtml#page_97)）的可靠 `Tracer` 类来探索块作用域。'
- en: '[PRE1]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '*Listing 8-2: A program exploring compound statements with the `Tracer` class*'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 8-2：一个使用 `Tracer` 类探索复合语句的程序*'
- en: '[Listing 8-2](ch08.xhtml#ch08ex02) begins by initializing a `Tracer` called
    `main` ➊. Next, you generate two compound statements. The first compound statement
    begins with a left brace `{` followed by the block’s first statement, which prints
    `Block a` ➋. You create two `Tracers`, `a1` ➌ and `a2` ➍, and then close the block
    with a right brace `}`. These two tracers get destructed once execution passes
    through `Block a`. Notice that these two tracers destruct in reverse order from
    their initialization: `a2` then `a1`.'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: '[清单 8-2](ch08.xhtml#ch08ex02) 首先初始化了一个名为 `main` 的 `Tracer` ➊。接着，您会生成两个复合语句。第一个复合语句以左花括号
    `{` 开始，后跟该块的第一条语句，该语句打印 `Block a` ➋。您创建了两个 `Tracer`，`a1` ➌ 和 `a2` ➍，然后用右花括号 `}`
    结束该块。这两个 tracers 在执行通过 `Block a` 后被销毁。请注意，这两个 tracers 的销毁顺序与它们的初始化顺序相反：先是 `a2`，然后是
    `a1`。'
- en: 'Also notice another compound statement following `Block a`, where you print
    `Block b` ➎ and then construct two tracers, `b1` ➏ and `b2` ➐. Its behavior is
    identical: `b2` destructs followed by `b1`. Once execution passes through `Block
    b`, the scope of `main` ends and `Tracer main` finally destructs.'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 还请注意，紧接着 `Block a` 后面是另一个复合语句，您打印了 `Block b` ➎，然后构造了两个 tracers，`b1` ➏ 和 `b2`
    ➐。它的行为是相同的：先是 `b2` 销毁，然后是 `b1`。一旦执行通过 `Block b`，`main` 的作用域结束，`Tracer main` 最终销毁。
- en: '**Declaration Statements**'
  id: totrans-20
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**声明语句**'
- en: '*Declaration statements* (or just *declarations*) introduce identifiers, such
    as functions, templates, and namespaces, into your programs. This section explores
    some new features of these familiar declarations, as well as type aliases, attributes,
    and structured bindings.'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: '*声明语句*（或简称*声明*）在程序中引入标识符，例如函数、模板和命名空间。本节将探讨这些熟悉的声明的一些新特性，以及类型别名、属性和结构绑定。'
- en: '**NOTE**'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*The expression `static_assert`, which you learned about in [Chapter 6](ch06.xhtml#ch06),
    is also a declaration statement.*'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: '*表达式`static_assert`，你在[第6章](ch06.xhtml#ch06)中学过，也是一个声明语句。*'
- en: '***Functions***'
  id: totrans-24
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***函数***'
- en: 'A *function declaration*, also called the function’s *signature* or *prototype*,
    specifies a function’s inputs and outputs. The declaration doesn’t need to include
    parameter names, only their types. For example, the following line declares a
    function called `randomize` that takes a `uint32_t` reference and returns `void`:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: '*函数声明*，也叫做函数的*签名*或*原型*，指定了函数的输入和输出。声明不需要包括参数名，只需要包括它们的类型。例如，下面这行代码声明了一个名为`randomize`的函数，该函数接受一个`uint32_t`的引用并返回`void`：'
- en: '[PRE2]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Functions that aren’t member functions are called *non-member functions*, or
    sometimes *free functions*, and they’re always declared outside of `main()` at
    namespace scope. A *function definition* includes the function declaration as
    well as the function’s body. A function’s declaration defines a function’s interface,
    whereas a function’s definition defines its implementation. For example, the following
    definition is one possible implementation of the `ran``domize` function:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 不是成员函数的函数被称为*非成员函数*，有时也叫*自由函数*，它们总是声明在`main()`外部，在命名空间范围内。*函数定义*包括函数声明以及函数的主体。函数的声明定义了函数的接口，而函数的定义则定义了它的实现。例如，下面的定义是`randomize`函数的一种可能实现：
- en: '[PRE3]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '**NOTE**'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*This `randomize` implementation is a linear congruential generator, a primitive
    kind of random number generator. See “Further Reading” on [page 241](ch08.xhtml#page_241)
    for sources of more information on generating random numbers.*'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: '*这个`randomize`实现是一个线性同余生成器，一种原始类型的随机数生成器。有关生成随机数的更多信息，请参见[第241页](ch08.xhtml#page_241)的“进一步阅读”部分。*'
- en: As you’ve probably noticed, function declarations are optional. So why do they
    exist?
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你可能已经注意到的，函数声明是可选的。那么它们为什么存在呢？
- en: The answer is that you can use declared functions throughout your code as long
    as they’re eventually defined somewhere. Your compiler tool chain can figure it
    out. (You’ll learn how this works in [Chapter 21](ch21.xhtml#ch21).)
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 答案是，你可以在代码中使用已声明的函数，只要它们最终在某个地方被定义。你的编译工具链可以自动处理这个问题。（你将在[第21章](ch21.xhtml#ch21)中了解它是如何工作的。）
- en: The program in [Listing 8-3](ch08.xhtml#ch08ex03) determines how many iterations
    the random number generator takes to get from the number 0x4c4347 to the number
    0x474343.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: '[清单8-3](ch08.xhtml#ch08ex03)中的程序确定了随机数生成器从数字0x4c4347转换到数字0x474343需要多少次迭代。'
- en: '[PRE4]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '*Listing 8-3: A program that uses a function in `main` that isn’t defined until
    later*'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单8-3：一个在`main`中使用函数但直到稍后才定义的程序*'
- en: First, you declare `randomize` ➊. Within `main`, you initialize an `iterations`
    counter variable to zero ➋ and a `number` variable to 0x4c4347 ➌. A `while` loop
    checks whether `number` equals the target 0x4c4347 ➍. If it doesn’t, you invoke
    `randomize` ➎ and increment `iterations` ➏. Notice that you haven’t yet defined
    `randomize`. Once `number` equals the target, you print the number of `iterations`
    ➐ before returning from `main`. Finally, you define `randomize` ➑. The program’s
    output shows that it takes almost a billion iterations to randomly draw the target
    value.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，你声明`randomize` ➊。在`main`中，你将`iterations`计数变量初始化为零 ➋，并将`number`变量初始化为0x4c4347
    ➌。一个`while`循环检查`number`是否等于目标值0x4c4347 ➍。如果不相等，你调用`randomize` ➎并递增`iterations`
    ➏。注意，你还没有定义`randomize`。一旦`number`等于目标值，你会在从`main`返回之前打印`iterations`的值 ➐。最后，你定义`randomize`
    ➑。程序的输出显示，要随机抽取目标值，几乎需要十亿次迭代。
- en: Try to delete the definition of `randomize` and recompile. You should get an
    error stating that the definition of `randomize` couldn’t be found.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试删除`randomize`的定义并重新编译。你应该会得到一个错误，提示无法找到`randomize`的定义。
- en: 'You can similarly separate method declarations from their definitions. As with
    non-member functions, you can declare a method by omitting its body. For example,
    the following `RandomNumberGenerator` class replaces the `ran``domize` function
    with `next`:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以像处理非成员函数一样，将方法声明与定义分开。例如，以下`RandomNumberGenerator`类将`ran``domize`函数替换为`next`：
- en: '[PRE5]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'You can construct a `RandomNumberGenerator` with a `seed` value ➊, which it
    uses to initialize the `number` member variable ➋. You’ve declared the `next`
    function using the same rules as non-member functions ➌. To provide the definition
    of `next`, you must use the scope resolution operator and the class name to identify
    which method you want to define. Otherwise, defining a method is the same as defining
    a non-member function:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以构建一个带有`seed`值➊的`RandomNumberGenerator`，它用这个值来初始化`number`成员变量➋。你已按照与非成员函数相同的规则声明了`next`函数➌。为了提供`next`的定义，你必须使用作用域解析符和类名来指定你要定义的方法。否则，定义一个方法与定义一个非成员函数是一样的：
- en: '[PRE6]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: This definition shares the same return type as the declaration ➊. The `RandomNumberGenerator::`
    construct specifies that you’re defining a method ➋. The function details are
    essentially the same ➌, except you’re returning a copy of the random number generator’s
    state rather than writing into a parameter reference ➍.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 这个定义与声明➊共享相同的返回类型。`RandomNumberGenerator::`构造指定你正在定义一个方法➋。函数的细节基本相同➌，只是你返回的是随机数生成器的状态的副本，而不是写入参数引用➋。
- en: '[Listing 8-4](ch08.xhtml#ch08ex04) illustrates how you can refactor [Listing
    8-3](ch08.xhtml#ch08ex03) to incorporate `RandomNumberGenerator`.'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 8-4](ch08.xhtml#ch08ex04)演示了如何重构[示例 8-3](ch08.xhtml#ch08ex03)以包含`RandomNumberGenerator`。'
- en: '[PRE7]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '*Listing 8-4: A refactor of [Listing 8-3](ch08.xhtml#ch08ex03) using a `RandomNumberGenerator`
    class*'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: '*示例 8-4：使用`RandomNumberGenerator`类重构[示例 8-3](ch08.xhtml#ch08ex03)*'
- en: As in [Listing 8-3](ch08.xhtml#ch08ex03), you’ve separated declaration from
    definition. After declaring a constructor that initializes an `iterations` member
    to zero ➊ and sets its `number` member to a `seed` ➋, the `next` ➌ and `get_iterations`
    ➍ method declarations don’t contain implementations. Within `main`, you initialize
    the `RandomNumberGenerator` class with your seed value of 0x4c4347 ➎ and invoke
    the `next` method to extract new random numbers ➏. The results are the same ➐.
    As before, the definitions of `next` and `get_iterations` follow their use in
    `main` ➑➒.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 如[示例 8-3](ch08.xhtml#ch08ex03)所示，你已将声明与定义分开。声明了一个将`iterations`成员初始化为零➊并将其`number`成员设置为`seed`➋的构造函数后，`next`➌和`get_iterations`➍方法的声明没有包含实现。在`main`函数中，你使用`0x4c4347`的种子值➎初始化`RandomNumberGenerator`类，并调用`next`方法提取新的随机数➏。结果是一样的➐。与之前一样，`next`和`get_iterations`的定义位于`main`函数中的调用之后➑➒。
- en: '**NOTE**'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*The utility of separating definition and declaration might not be apparent
    because you’ve been dealing with single-source-file programs so far. [Chapter
    21](ch21.xhtml#ch21) explores multiple-source-file programs where separating declaration
    and definition provides major benefits.*'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: '*分离定义和声明的实用性可能不太明显，因为你迄今为止处理的都是单一源文件程序。[第21章](ch21.xhtml#ch21)探讨了多个源文件程序，其中分离声明和定义带来了巨大的好处。*'
- en: '***Namespaces***'
  id: totrans-49
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***命名空间***'
- en: Namespaces prevent naming conflicts. In large projects or when importing libraries,
    namespaces are essential for disambiguating exactly the symbols you’re looking
    for.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 命名空间可以防止命名冲突。在大型项目中或导入库时，命名空间对于消除歧义、精确定位你要查找的符号至关重要。
- en: '**Placing Symbols Within Namespaces**'
  id: totrans-51
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**将符号放入命名空间中**'
- en: By default, all symbols you declare go into the *global namespace*. The global
    namespace contains all the symbols that you can access without adding any namespace
    qualifiers. Aside from several classes in the `std` namespace, you’ve been using
    objects living exclusively in the global namespace.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，你声明的所有符号都会进入*全局命名空间*。全局命名空间包含所有你可以在不添加命名空间限定符的情况下访问的符号。除了`std`命名空间中的几个类，你所使用的对象都仅存在于全局命名空间中。
- en: 'To place a symbol within a namespace other than the global namespace, you declare
    the symbol within a *namespace block*. A namespace block has the following form:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 要将符号放入除全局命名空间外的命名空间中，你需要在*命名空间块*中声明该符号。命名空间块的形式如下：
- en: '[PRE8]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Namespaces can be nested in one of two ways. First, you can simply nest namespace
    blocks:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 命名空间可以通过两种方式进行嵌套。首先，你可以简单地嵌套命名空间块：
- en: '[PRE9]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Second, you can use the scope-resolution operator:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 其次，你可以使用作用域解析符：
- en: '[PRE10]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The latter approach is more succinct.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 后者的方法更加简洁。
- en: '**Using Symbols in Namespaces**'
  id: totrans-60
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**在命名空间中使用符号**'
- en: To use a symbol within a namespace, you can always use the scope-resolution
    operator to specify the fully qualified name of a symbol. This allows you to prevent
    naming conflicts in large projects or when you’re using a third-party library.
    If you and another programmer use the same symbol, you can avoid ambiguity by
    placing the symbol within a namespace.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用命名空间中的符号，您始终可以使用作用域解析运算符来指定符号的完全限定名称。这可以帮助您避免在大型项目中或使用第三方库时的命名冲突。如果您和另一个程序员使用相同的符号，您可以通过将该符号放入命名空间中来避免歧义。
- en: '[Listing 8-5](ch08.xhtml#ch08ex05) illustrates how you can use fully qualified
    symbol names to access a symbol within a namespace.'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: '[列表 8-5](ch08.xhtml#ch08ex05) 展示了如何使用完全限定的符号名称来访问命名空间中的符号。'
- en: '[PRE11]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '*Listing 8-5: Nested namespace blocks using the scope-resolution operator*'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 8-5：使用作用域解析运算符的嵌套命名空间块*'
- en: '[Listing 8-5](ch08.xhtml#ch08ex05) uses nested namespaces ➊ and declares a
    `Color` type ➋. To use `Color`, you apply the scope-resolution operator to specify
    the full name of the symbol, `BroopKidron13::Shaltanac::Color`. Because `Color`
    is an `enum class`, you use the scope-resolution operator to access its values,
    as when you assign `shaltanac_grass` to `Russet` ➌.'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: '[列表 8-5](ch08.xhtml#ch08ex05) 使用了嵌套命名空间 ➊ 并声明了一个 `Color` 类型 ➋。要使用 `Color`，您需要使用作用域解析运算符来指定符号的全名
    `BroopKidron13::Shaltanac::Color`。因为 `Color` 是一个 `enum class`，所以您需要使用作用域解析运算符来访问它的值，正如您将
    `shaltanac_grass` 赋值给 `Russet` ➌ 时一样。'
- en: '**Using Directives**'
  id: totrans-66
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**使用指令**'
- en: 'You can employ a `using` *directive* to avoid a lot of typing. A `using` directive
    imports a symbol into a block or, if you declare a `using` directive at namespace
    scope, into the current namespace. Either way, you have to type the full namespace
    path only once. The usage has the following pattern:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用 `using` *指令* 来避免大量输入。`using` 指令将符号导入到一个块中，或者如果您在命名空间作用域声明 `using` 指令，则导入到当前命名空间。无论哪种方式，您只需输入一次完全的命名空间路径。其使用模式如下：
- en: '[PRE12]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The corresponding my-type gets imported into the current namespace or block,
    meaning you no longer have to use its full name. [Listing 8-6](ch08.xhtml#ch08ex06)
    refactors [Listing 8-5](ch08.xhtml#ch08ex05) with a using directive.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 相应的 my-type 被导入到当前命名空间或块中，这意味着您不再需要使用其全名。[列表 8-6](ch08.xhtml#ch08ex06) 通过使用指令重构了[列表
    8-5](ch08.xhtml#ch08ex05)。
- en: '[PRE13]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '*Listing 8-6: A refactor of [Listing 8-5](ch08.xhtml#ch08ex05) employing a
    using directive*'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 8-6：使用指令重构[列表 8-5](ch08.xhtml#ch08ex05)*'
- en: With a `using` directive ➊ within `main`, you no longer have to type the namespace
    `BroopKidron13::Shaltanac` to use `Color` ➋➌.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 通过 `main` 中的 `using` 指令 ➊，您不再需要输入命名空间 `BroopKidron13::Shaltanac` 来使用 `Color`
    ➋➌。
- en: If you’re careful, you can introduce all the symbols from a given namespace
    into the global namespace with the `using namespace` directive.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 如果小心使用，您可以通过 `using namespace` 指令将给定命名空间中的所有符号导入到全局命名空间中。
- en: '[Listing 8-7](ch08.xhtml#ch08ex07) elaborates [Listing 8-6](ch08.xhtml#ch08ex06):
    the namespace `BroopKidron13::Shaltanac` contains multiple symbols, which you
    want to import into the global namespace to avoid a lot of typing.'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: '[列表 8-7](ch08.xhtml#ch08ex07) 详细说明了[列表 8-6](ch08.xhtml#ch08ex06)：命名空间 `BroopKidron13::Shaltanac`
    包含多个符号，您希望将它们导入到全局命名空间中，以避免大量输入。'
- en: '[PRE14]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '*Listing 8-7: A refactor of [Listing 8-6](ch08.xhtml#ch08ex06) with multiple
    symbols imported into the global namespace*'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 8-7：重构后的[列表 8-6](ch08.xhtml#ch08ex06)，多个符号导入到全局命名空间中*'
- en: With a `using namespace` directive ➊, you can use classes ➋, enum classes ➌,
    functions ➍, and so on within your program without having to type fully qualified
    names. Of course, you need to be very careful about clobbering existing types
    in the global namespace. Usually, it’s a bad idea to have too many `using namespace`
    directives appear in a single translation unit.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 通过 `using namespace` 指令 ➊，您可以在程序中使用类 ➋、枚举类 ➌、函数 ➍ 等，而无需输入完全限定的名称。当然，您需要非常小心，避免覆盖全局命名空间中的现有类型。通常，在单个翻译单元中出现过多的
    `using namespace` 指令是不好的做法。
- en: '**NOTE**'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*You should never put a using namespace directive within a header file. Every
    source file that includes your header will dump all the symbols from that using
    directive into the global namespace. This can cause issues that are very difficult
    to debug.*'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: '*您绝不应该在头文件中放置 `using namespace` 指令。每个包含您的头文件的源文件都会将该 `using` 指令中的所有符号转存到全局命名空间中。这可能会导致非常难以调试的问题。*'
- en: '***Type Aliasing***'
  id: totrans-80
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***类型别名***'
- en: A *type alias* defines a name that refers to a previously defined name. You
    can use a type alias as a synonym for the existing type name.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 一个 *类型别名* 定义了一个名称，指向一个先前定义的名称。你可以将类型别名作为现有类型名称的同义词使用。
- en: There is no difference between a type and any type aliases referring to it.
    Also, type aliases cannot change the meaning of an existing type name.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 类型和所有引用它的类型别名之间没有区别。此外，类型别名不能改变现有类型名称的含义。
- en: 'To declare a type alias, you use the following format, where type-alias is
    the type alias name and type-id is the target type:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 要声明一个类型别名，你可以使用以下格式，其中 type-alias 是类型别名的名称，type-id 是目标类型：
- en: '[PRE15]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '[Listing 8-8](ch08.xhtml#ch08ex08) employs two type aliases, `String` and `ShaltanacColor`.'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: '[列表 8-8](ch08.xhtml#ch08ex08) 使用了两个类型别名，`String` 和 `ShaltanacColor`。'
- en: '[PRE16]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: '*Listing 8-8: A refactor of [Listing 8-7](ch08.xhtml#ch08ex07) with a type
    alias*'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 8-8：对 [列表 8-7](ch08.xhtml#ch08ex07) 的重构，使用了类型别名*'
- en: '[Listing 8-8](ch08.xhtml#ch08ex08) declares a type alias `String` that refers
    to a `const char[260]` ➊. This listing also declares a `ShaltanacColor` type alias,
    which refers to `BroopKidron13::Shaltanac::Color` ➋. You can use these type aliases
    as drop-in replacements to clean up code. Within `main`, you use `ShaltanacColor`
    to remove all the nested namespaces ➌ and `String` to make the declaration of
    `saying` cleaner ➍.'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: '[列表 8-8](ch08.xhtml#ch08ex08) 声明了一个类型别名 `String`，它指向 `const char[260]` ➊。该列表还声明了一个
    `ShaltanacColor` 类型别名，指向 `BroopKidron13::Shaltanac::Color` ➋。你可以使用这些类型别名作为直接替代，简化代码。在
    `main` 中，你使用 `ShaltanacColor` 来去除所有嵌套的命名空间 ➌，并使用 `String` 使 `saying` 的声明更加简洁 ➍。'
- en: '**NOTE**'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*Type aliases can appear in any scope—block, class, or namespace.*'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: '*类型别名可以出现在任何作用域中——块作用域、类作用域或命名空间作用域。*'
- en: 'You can introduce template parameters into type aliases. This enables two important
    usages:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以将模板参数引入类型别名中。这使得有两种重要的用途：
- en: You can perform partial application on template parameters. *Partial application*
    is the process of fixing some number of arguments to a template, producing another
    template with fewer template parameters.
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可以对模板参数进行部分应用。*部分应用*是将一些参数固定到模板中，生成一个具有更少模板参数的新模板的过程。
- en: You can define a type alias for a template with a fully specified set of template
    parameters.
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可以为一个模板定义一个类型别名，使用完全指定的模板参数集。
- en: Template instantiations can be quite verbose, and type aliases help you avoid
    carpal tunnel syndrome.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 模板实例化可能会非常冗长，而类型别名可以帮助你避免腕管综合症。
- en: '[Listing 8-9](ch08.xhtml#ch08ex09) declares a `NarrowCaster` class with two
    template parameters. You then use a type alias to partially apply one of its parameters
    and produce a new type.'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: '[列表 8-9](ch08.xhtml#ch08ex09) 声明了一个具有两个模板参数的 `NarrowCaster` 类。然后，你使用类型别名部分应用其中一个参数，生成一个新类型。'
- en: '[PRE17]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: '*Listing 8-9: A partial application of the `NarrowCaster` class using a type
    alias*'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 8-9：使用类型别名对 `NarrowCaster` 类进行部分应用*'
- en: 'First, you implement a `NarrowCaster` template class that has the same functionality
    as the `narrow_cast` function template in [Listing 6-6](ch06.xhtml#ch06ex06) (on
    [page 154](ch06.xhtml#page_154)): it will perform a `static_cast` and then check
    for narrowing ➊. Next, you declare a type alias `short_caster` that partially
    applies `short` as the `To` type to `NarrowCast`. Within `main`, you declare a
    `caster` object of type `short_caster<int>` ➌. The single template parameter in
    the `short_caster` type alias gets applied to the remaining type parameter from
    the type alias—`From` ➋. In other words, the type `short_cast<int>` is synonymous
    with `NarrowCaster<short, int>`. In the end, the result is the same: with a 2-byte
    short, you get a narrowing exception when trying to cast an `int` with the value
    142857 into a `short` ➍.'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，你实现了一个 `NarrowCaster` 模板类，它具有与 [列表 6-6](ch06.xhtml#ch06ex06) 中的 `narrow_cast`
    函数模板相同的功能（在 [第 154 页](ch06.xhtml#page_154)）：它会执行 `static_cast`，然后检查是否发生了缩窄 ➊。接着，你声明了一个类型别名
    `short_caster`，将 `short` 部分应用为 `To` 类型到 `NarrowCast` 中。在 `main` 中，你声明了一个类型为 `short_caster<int>`
    的 `caster` 对象 ➌。`short_caster` 类型别名中的单个模板参数应用于类型别名中的剩余类型参数——`From` ➋。换句话说，类型 `short_cast<int>`
    与 `NarrowCaster<short, int>` 同义。最终结果是相同的：使用 2 字节的 `short` 类型，当你尝试将值为 142857 的
    `int` 转换为 `short` 时，会出现缩窄异常 ➍。
- en: '***Structured Bindings***'
  id: totrans-99
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***结构化绑定***'
- en: '*Structured bindings* enable you to unpack objects into their constituent elements.
    Any type whose non-static data members are public can be unpacked this way—for
    example, the POD (plain-old-data class) types introduced in [Chapter 2](ch02.xhtml#ch02).
    The *structured binding syntax* is as follows:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: '*结构化绑定*使你能够将对象解包成它们的组成部分。任何其非静态数据成员是公共的类型都可以通过这种方式解包——例如，在[第二章](ch02.xhtml#ch02)中介绍的POD（普通数据类）类型。*结构化绑定语法*如下：'
- en: '[PRE18]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'This line will initialize an arbitrary number of objects (object-1, object-2,
    and so on) by peeling them off a POD object one by one. The objects peel off the
    POD from top to bottom, and they fill in the structured binding from left to right.
    Consider a `read_text_file` function that takes a string argument corresponding
    to the file path. Such a function might fail, for example, if a file is locked
    or doesn’t exist. You have two options for handling errors:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 这一行将通过逐个剥离POD对象初始化任意数量的对象（object-1、object-2，依此类推）。这些对象从上到下剥离POD，并从左到右填充结构化绑定。考虑一个`read_text_file`函数，它接受一个字符串参数，该参数对应文件路径。比如，如果文件被锁定或不存在，函数可能会失败。你有两种处理错误的选项：
- en: You can throw an exception within `read_text_file`.
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可以在`read_text_file`中抛出异常。
- en: You can return a success status code from the function.
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可以从函数返回一个成功的状态码。
- en: Let’s explore the second option.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来探索第二种选择。
- en: The POD type in [Listing 8-10](ch08.xhtml#ch08ex10) will serve as a fine return
    type from the `read_text_file` function.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 8-10](ch08.xhtml#ch08ex10)中的POD类型将作为`read_text_file`函数的返回类型。'
- en: '[PRE19]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: '*Listing 8-10: A `TextFile` type that will be returned by the `read_text_file`
    function*'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: '*示例 8-10：一个`TextFile`类型，它将由`read_text_file`函数返回*'
- en: First, a flag communicates to the caller whether the function call was a `success`
    ➊. Next is the contents of the `file` ➋ and its size `n_bytes` ➌.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，一个标志会告诉调用者函数调用是否成功 ➊。接下来是`file`的内容 ➋及其大小`n_bytes` ➌。
- en: 'The prototype of `read_text_file` looks like this:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: '`read_text_file`的原型如下所示：'
- en: '[PRE20]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: You can use a structured binding declaration to unpack a `TextFile` into its
    parts within your program, as in [Listing 8-11](ch08.xhtml#ch08ex11).
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用结构化绑定声明将`TextFile`解包成程序中的各个部分，正如在[示例 8-11](ch08.xhtml#ch08ex11)中所示。
- en: '[PRE21]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: '*Listing 8-11: A program simulating the reading of a text file that returns
    a POD that you use in a structured binding*'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: '*示例 8-11：一个模拟读取文本文件的程序，它返回一个POD，你可以在结构化绑定中使用它*'
- en: You’ve declared the `TextFile` ➊ and then provided a dummy definition for `read_text_file`
    ➋. (It doesn’t actually read a file; more on that in [Part II](part02.xhtml#part02).)
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 你声明了`TextFile` ➊，然后为`read_text_file`提供了一个虚拟定义 ➋。（它实际上并不读取文件；更多内容将在[第二部分](part02.xhtml#part02)中讨论。）
- en: 'Within `main`, you invoke `read_text_file` ➍ and use a structured binding declaration
    to unpack the results into three distinct variables: `success`, `contents`, and
    `length` ➌. After structured binding, you can use all these variables as though
    you had declared them individually ➎➏➐.'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 在`main`函数内，你调用`read_text_file` ➍并使用结构化绑定声明将结果解包到三个不同的变量中：`success`、`contents`和`length`
    ➌。在结构化绑定之后，你可以像声明这些变量时一样使用它们 ➎➏➐。
- en: '**NOTE**'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*The types within a structured binding declaration don’t have to match.*'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: '*结构化绑定声明中的类型不必匹配。*'
- en: '***Attributes***'
  id: totrans-119
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***属性***'
- en: Attributes apply implementation-defined features to an expression statement.
    You introduce attributes using double brackets `[[ ]]` containing a list of one
    or more comma-separated attribute elements.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 属性将实现定义的特性应用于表达式语句。你通过使用包含一个或多个以逗号分隔的属性元素的双括号`[[ ]]`来引入属性。
- en: '[Table 8-1](ch08.xhtml#ch08tab01) lists the standard attributes.'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: '[表 8-1](ch08.xhtml#ch08tab01)列出了标准属性。'
- en: '**Table 8-1:** The Standard Attributes'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: '**表 8-1：** 标准属性'
- en: '| **Attribute** | **Meaning** |'
  id: totrans-123
  prefs: []
  type: TYPE_TB
  zh: '| **属性** | **含义** |'
- en: '| `[[noreturn]]` | Indicates that a function doesn’t return. |'
  id: totrans-124
  prefs: []
  type: TYPE_TB
  zh: '| `[[noreturn]]` | 表示一个函数没有返回值。 |'
- en: '| `[[deprecated("`reason`")]]` | Indicates that this expression is deprecated;
    that is, its use is discouraged. The `"reason"` is optional and indicates the
    reason for deprecation. |'
  id: totrans-125
  prefs: []
  type: TYPE_TB
  zh: '| `[[deprecated("`reason`")]]` | 表示该表达式已弃用；即不推荐使用它。`"reason"`是可选的，表示弃用的原因。
    |'
- en: '| `[[fallthrough]]` | Indicates that a switch case intends to fall through
    to the next switch case. This avoids compiler errors that will check for switch
    case fallthrough, because it’s uncommon. |'
  id: totrans-126
  prefs: []
  type: TYPE_TB
  zh: '| `[[fallthrough]]` | 表示一个switch语句的case打算穿透到下一个switch语句的case。这可以避免编译器检查switch
    case穿透错误，因为这种情况不常见。 |'
- en: '| `[[nodiscard]]` | Indicates that the following function or type declaration
    should be used. If code using this element discards the value, the compiler should
    emit a warning. |'
  id: totrans-127
  prefs: []
  type: TYPE_TB
  zh: '| `[[nodiscard]]` | 表示应使用以下函数或类型声明。如果使用该元素的代码丢弃了值，编译器应发出警告。 |'
- en: '| `[[maybe_unused]]` | Indicates that the following element might be unused
    and that the compiler shouldn’t warn about it. |'
  id: totrans-128
  prefs: []
  type: TYPE_TB
  zh: '| `[[maybe_unused]]` | 表示以下元素可能未被使用，编译器不应对此发出警告。 |'
- en: '| `[[carries_dependency]]` | Used within the `<atomic>` header to help the
    compiler optimize certain memory operations. You’re unlikely to encounter this
    directly. |'
  id: totrans-129
  prefs: []
  type: TYPE_TB
  zh: '| `[[carries_dependency]]` | 在 `<atomic>` 头文件中使用，帮助编译器优化某些内存操作。你不太可能直接遇到这个。
    |'
- en: '[Listing 8-12](ch08.xhtml#ch08ex12) demonstrates using the `[[noreturn]]` attribute
    by defining a function that never returns.'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: '[列表 8-12](ch08.xhtml#ch08ex12) 演示了通过定义一个永不返回的函数来使用 `[[noreturn]]` 属性。'
- en: '[PRE22]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: '*Listing 8-12: A program illustrating the use of the `[[noreturn]]` attribute*'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 8-12：演示使用 `[[noreturn]]` 属性的程序*'
- en: First, you declare the `pitcher` function with the `[[noreturn]]` attribute
    ➊. Within this function, you throw an exception ➋. Because you always throw an
    exception, `pitcher` never returns (hence the `[[noreturn]]` attribute). Within
    `main`, you invoke `pitcher` ➌ and handle the caught exception ➍. Of course, this
    listing works without the `[[noreturn]]` attribute. But giving this information
    to the compiler allows it to reason more completely on your code (and potentially
    to optimize your program).
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，你使用 `[[noreturn]]` 属性声明 `pitcher` 函数 ➊。在该函数中，你抛出一个异常 ➋。因为你总是抛出异常，所以 `pitcher`
    永远不会返回（因此使用 `[[noreturn]]` 属性）。在 `main` 中，你调用 `pitcher` ➌ 并处理捕获的异常 ➍。当然，这段代码即使没有
    `[[noreturn]]` 属性也能正常工作，但向编译器提供这些信息可以让它更全面地推理你的代码（并有可能优化你的程序）。
- en: The situations in which you’ll need to use an attribute are rare, but they convey
    useful information to the compiler nonetheless.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 使用属性的情况较少，但它们仍然能向编译器传达有用的信息。
- en: '**Selection Statements**'
  id: totrans-135
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**选择语句**'
- en: '*Selection statements* express conditional control flow. The two varieties
    of selection statements are the `if` statement and the `switch` statement.'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: '*选择语句* 表示条件控制流。选择语句有两种类型，分别是 `if` 语句和 `switch` 语句。'
- en: '***if Statements***'
  id: totrans-137
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***if 语句***'
- en: The `if` statement has the familiar form shown in [Listing 8-13](ch08.xhtml#ch08ex13).
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: '`if` 语句具有在 [列表 8-13](ch08.xhtml#ch08ex13) 中显示的熟悉形式。'
- en: '[PRE23]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: '*Listing 8-13: The syntax of the `if` statement*'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 8-13：`if` 语句的语法*'
- en: Upon encountering an `if` statement, you evaluate the condition-1 expression
    first. If it’s `true`, the block at ➊ is executed and the `if` statement stops
    executing (none of the `else if` or `else` statements are considered). If it’s
    `false`, the `else if` statements’ conditions evaluate in order. These are optional,
    and you can supply as many as you like.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 遇到 `if` 语句时，首先评估条件 1 表达式。如果它为 `true`，则执行 ➊ 处的代码块，`if` 语句停止执行（不会考虑任何 `else if`
    或 `else` 语句）。如果为 `false`，则按顺序评估 `else if` 语句的条件。这些是可选的，你可以根据需要提供任意数量。
- en: If condition-2 evaluates to `true`, for example, the block at ➋ will execute
    and none of the remaining `else if` or `else` statements are considered. Finally,
    the `else` block at ➌ executes if all of the preceding conditions evaluate to
    `false`. Like the `else if` blocks, the `else` block is optional.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果条件 2 评估为 `true`，则会执行 ➋ 处的代码块，剩余的 `else if` 或 `else` 语句不会被考虑。最后，如果所有前面的条件都评估为
    `false`，则执行 ➌ 处的 `else` 块。与 `else if` 块一样，`else` 块是可选的。
- en: The function template in [Listing 8-14](ch08.xhtml#ch08ex14) converts an `else`
    argument into `Positive`, `Negative`, or `Zero`.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: '[列表 8-14](ch08.xhtml#ch08ex14) 中的函数模板将 `else` 参数转换为 `Positive`、`Negative` 或
    `Zero`。'
- en: '[PRE24]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: '*Listing 8-14: An example usage of the `if` statement*'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 8-14：`if` 语句的示例用法*'
- en: The `sign` function takes a single argument and determines if it’s equal to
    0 ➊, greater than 0 ➋, or less than 0 ➌. Depending on which condition matches,
    it sets the automatic variable result equal to one of three strings—`zero`, `positive`,
    or `negative`—and returns this value to the caller.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: '`sign` 函数接受一个参数，并确定该参数是等于 0 ➊、大于 0 ➋，还是小于 0 ➌。根据匹配的条件，它将自动变量 `result` 设置为三种字符串之一——`zero`、`positive`
    或 `negative`，并将此值返回给调用者。'
- en: '**Initialization Statements and if**'
  id: totrans-147
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**初始化语句与 if**'
- en: You can bind an object’s scope to an `if` statement by adding an `init-state``ment`
    to `if` and `else if` declarations, as demonstrated in [Listing 8-15](ch08.xhtml#ch08ex15).
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过向 `if` 和 `else if` 声明中添加一个 `init-state` 语句来绑定对象的作用域，如 [列表 8-15](ch08.xhtml#ch08ex15)
    所示。
- en: '[PRE25]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: '*Listing 8-15: An `if` statement with initializations*'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 8-15：带有初始化的`if`语句*'
- en: You can use this pattern with structured bindings to produce elegant error handling.
    [Listing 8-16](ch08.xhtml#ch08ex16) refactors [Listing 8-11](ch08.xhtml#ch08ex11)
    using the initialization statement to scope a `TextFile` to the `if` statement.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以将此模式与结构化绑定一起使用，以实现优雅的错误处理。[列表 8-16](ch08.xhtml#ch08ex16)通过使用初始化语句将`TextFile`限定在`if`语句中，重构了[列表
    8-11](ch08.xhtml#ch08ex11)。
- en: '[PRE26]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: '*Listing 8-16: An extension of [Listing 8-11](ch08.xhtml#ch08ex11) using structured
    binding and an `if` statement to handle errors*'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 8-16：使用结构化绑定和`if`语句处理错误的[列表 8-11](ch08.xhtml#ch08ex11)的扩展*'
- en: You’ve moved the structured binding declaration into the initialization statement
    portion of the `if` statement ➊. This scopes each of the unpacked objects—`success`,
    `txt`, and `len`—to the `if` block. You use `success` directly within the conditional
    expression of `if` to determine whether `read_text_file` was successful ➋. If
    it was, you print the contents of `REAMDE.txt` ➌. If it wasn’t, you print an error
    message ➍.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 你将结构化绑定声明移到了`if`语句的初始化语句部分 ➊。这样每个解包的对象——`success`、`txt`和`len`——的作用域就限制在了`if`块中。你直接在`if`的条件表达式中使用`success`来判断`read_text_file`是否成功
    ➋。如果成功，你会打印`REAMDE.txt`的内容 ➌；如果失败，则打印错误信息 ➍。
- en: '**constexpr if Statements**'
  id: totrans-155
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**constexpr if 语句**'
- en: You can make an `if` statement `constexpr`; such statements are known as `constexpr
    if` statements. A `constexpr if` statement is evaluated at compile time. Code
    blocks that correspond to `true` conditions get emitted, and the rest is ignored.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使`if`语句成为`constexpr`语句；这样的语句称为`constexpr if`语句。`constexpr if`语句在编译时被求值。对应于`true`条件的代码块会被执行，而其余部分会被忽略。
- en: Usage of the `constexpr if` follows usage for a regular `if` statement, as demonstrated
    in [Listing 8-17](ch08.xhtml#ch08ex17).
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: '`constexpr if`的使用方式与常规的`if`语句相同，正如[列表 8-17](ch08.xhtml#ch08ex17)所示。'
- en: '[PRE27]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: '*Listing 8-17: Usage of the `constexpr if` statement*'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 8-17：`constexpr if` 语句的使用*'
- en: In combination with templates and the `<type_traits>` header, `constexpr` `if`
    statements are extremely powerful. A major use for `constexpr if` is to provide
    custom behavior in a function template depending on some attributes of type parameters.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 与模板和`<type_traits>`头文件结合使用时，`constexpr` `if`语句非常强大。`constexpr if`的一个主要用途是根据类型参数的一些特性，在函数模板中提供自定义行为。
- en: The function template `value_of` in [Listing 8-18](ch08.xhtml#ch08ex18) accepts
    pointers, references, and values. Depending on which kind of object the argument
    is, `value_of` returns either the pointed-to value or the value itself.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: '[列表 8-18](ch08.xhtml#ch08ex18)中的函数模板`value_of`接受指针、引用和值。根据传入参数的对象类型，`value_of`返回指向的值或值本身。'
- en: '[PRE28]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: '*Listing 8-18: An example function template, `value_of`, employing a `constexpr
    if` statement*'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 8-18：一个使用`constexpr if`语句的示例函数模板`value_of`*'
- en: The `value_of` function template accepts a single argument `x` ➊. You determine
    whether the argument is a pointer type using the `std::is_pointer<T>` type trait
    as the conditional expression in a `constexpr if` statement ➋. In case `x` is
    a pointer type, you check for `nullptr` and throw an exception if one is encountered
    ➌. If `x` isn’t a `nullptr`, you dereference it and return the result ➍. Otherwise,
    `x` is not a pointer type, so you return it (because it is therefore a value)
    ➎.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: '`value_of`函数模板接受一个参数`x` ➊。你使用`std::is_pointer<T>`类型特征来判断参数是否为指针类型，并作为`constexpr
    if`语句中的条件表达式 ➋。如果`x`是指针类型，你检查是否为`nullptr`，如果遇到`nullptr`则抛出异常 ➌。如果`x`不是`nullptr`，你解引用它并返回结果
    ➍。否则，`x`不是指针类型，因此直接返回它（因为它是一个值） ➎。'
- en: Within `main`, you instantiate `value_of` multiple times with an `unsigned long`
    pointer ➏, an `unsigned long` reference ➐, an `unsigned long` ➑, and a `nullptr`
    ➒ respectively.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 在`main`函数中，你多次实例化`value_of`，分别使用`unsigned long`指针 ➏、`unsigned long`引用 ➐、`unsigned
    long` ➑和`nullptr` ➒。
- en: At runtime, the `constexpr if` statement disappears; each instantiation of `value_of`
    contains one branch of the selection statement or the other. You might be wondering
    why such a facility is useful. After all, programs are meant to do something useful
    at runtime, not at compile time. Just flip back to [Listing 7-17](ch07.xhtml#ch07ex17)
    (on [page 206](ch07.xhtml#page_206)), and you’ll see that compile time evaluation
    can substantially simplify your programs by eliminating magic values.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 在运行时，`constexpr if` 语句消失；每个 `value_of` 的实例化包含一个分支语句或另一个分支。你可能会想知道为什么这样的功能有用。毕竟，程序应该在运行时做有用的事情，而不是在编译时。只要回到[示例
    7-17](ch07.xhtml#ch07ex17)（见[第206页](ch07.xhtml#page_206)），你会发现编译时求值通过消除魔法值，能显著简化你的程序。
- en: There are other examples where compile time evaluation is popular, especially
    when creating libraries for others to use. Because library writers usually cannot
    know all the ways their users will utilize their library, they need to write generic
    code. Often, they’ll use techniques like those you learned in [Chapter 6](ch06.xhtml#ch06)
    so they can achieve compile-time polymorphism. Constructs like `constexpr` can
    help when writing this kind of code.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 还有其他一些例子，其中编译时求值非常流行，特别是在为他人创建库时。因为库的编写者通常无法知道用户将如何使用他们的库，他们需要编写通用代码。通常，他们会使用你在[第6章](ch06.xhtml#ch06)中学到的技巧，这样他们就可以实现编译时多态。像
    `constexpr` 这样的构造可以在编写此类代码时提供帮助。
- en: '**NOTE**'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*If you have a C background, you’ll immediately recognize the utility of compile
    time evaluation when considering that it almost entirely replaces the need for
    preprocessor macros.*'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: '*如果你有 C 语言背景，你会立刻意识到编译时求值的实用性，因为它几乎完全取代了预处理器宏的需求。*'
- en: '***switch Statements***'
  id: totrans-170
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***switch 语句***'
- en: '[Chapter 2](ch02.xhtml) first introduced the venerable `switch` statement.
    This section delves into the addition of the initialization statement into the
    `switch` declaration. The usage is as follows:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: '[第2章](ch02.xhtml) 首次介绍了著名的 `switch` 语句。本节深入探讨了将初始化语句添加到 `switch` 声明中的方法。用法如下：'
- en: '[PRE29]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: As with `if` statements, you can instantiate within `switch` statements ➊.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 与 `if` 语句一样，你可以在 `switch` 语句中进行实例化 ➊。
- en: '[Listing 8-19](ch08.xhtml#ch08ex19) employs an initialization statement within
    a `switch` statement.'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 8-19](ch08.xhtml#ch08ex19) 在 `switch` 语句中使用了初始化语句。'
- en: '[PRE30]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: '*Listing 8-19: Using an initialization expression in a `switch` statement*'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: '*示例 8-19：在 `switch` 语句中使用初始化表达式*'
- en: You declare the familiar `Color` `enum class` ➊ and join it with a `char*` member
    to form the POD type `Result` ➋. The function `observe_shrub` returns a `Result`
    ➌. Within `main`, you call `observe_shrub` within the initialization expression
    and store the result in the `result` variable ➍. Within the conditional expression
    of `switch`, you extract the `color` element of this `result` ➎. This element
    determines the case that executes (and sets the `description` pointer) ➏.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 你声明了熟悉的 `Color` `enum class` ➊，并将其与 `char*` 成员连接，形成了 POD 类型 `Result` ➋。函数 `observe_shrub`
    返回一个 `Result` ➌。在 `main` 中，你在初始化表达式中调用 `observe_shrub` 并将结果存储在 `result` 变量 ➍ 中。在
    `switch` 的条件表达式中，你提取了此 `result` 的 `color` 元素 ➎。该元素决定了执行的 case（并设置 `description`
    指针） ➏。
- en: As with the `if`-statement-plus-initializer syntax, any object initialized in
    the initialization expression is bound to the scope of the `switch` statement.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 与 `if` 语句加初始化器语法一样，在初始化表达式中初始化的任何对象都绑定到 `switch` 语句的作用域内。
- en: '**Iteration Statements**'
  id: totrans-179
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**迭代语句**'
- en: '*Iteration statements* execute a statement repeatedly. The four kinds of iteration
    statements are the `while` loop, the `do`-`while` loop, the `for` loop, and the
    range-based `for` loop.'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: '*迭代语句* 会重复执行一个语句。四种迭代语句分别是 `while` 循环、`do`-`while` 循环、`for` 循环和基于范围的 `for`
    循环。'
- en: '***while Loops***'
  id: totrans-181
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***while 循环***'
- en: 'The `while` loop is the basic iteration mechanism. The usage is as follows:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: '`while` 循环是基本的迭代机制。用法如下：'
- en: '[PRE31]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Before executing an iteration of the loop, the `while` loop evaluates the `condition`
    expression. If `true`, the loop continues. If `false`, the loop terminates, as
    demonstrated in [Listing 8-20](ch08.xhtml#ch08ex20).
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 在执行循环的每次迭代之前，`while` 循环会先评估 `condition` 表达式。如果为 `true`，循环继续。如果为 `false`，循环终止，如[示例
    8-20](ch08.xhtml#ch08ex20)所示。
- en: '[PRE32]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: '*Listing 8-20: A program that doubles a `uint8_t` and prints the new value
    on each iteration*'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: '*示例 8-20：一个程序，每次迭代时将 `uint8_t` 类型的值加倍，并打印新的值*'
- en: You declare a `double_return_overflow` function taking an 8-bit, unsigned integer
    by reference ➊. This function doubles the argument and checks whether this causes
    an overflow. If it does, it returns `true`. If no overflow occurs, it returns
    `false`.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 你声明了一个 `double_return_overflow` 函数，该函数通过引用接收一个 8 位无符号整数 ➊。该函数将参数加倍，并检查是否导致溢出。如果发生溢出，它返回
    `true`。如果没有溢出，返回 `false`。
- en: You initialize the variable `x` to 1 before entering the `while` loop ➋. The
    conditional expression in the `while` loop evaluates `double_return_overflow(x)`
    ➌. This has the side effect of doubling `x`, because you’ve passed it by reference.
    It also returns a value telling you whether the doubling caused `x` to overflow.
    The loop will execute when the conditional expression evaluates to `true`, but
    `double_return_overflow` is written so it returns `true` when the loop should
    stop. You fix this problem by prepending the logical negation operator (`!`).
    (Recall from [Chapter 7](ch07.xhtml#ch07) that this turns `true` to `false` and
    `false` to `true`.) So the `while` loop is actually asking, “If it’s NOT true
    that `double_return_overflow` is true . . .”
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 在进入 `while` 循环之前，你将变量 `x` 初始化为 1 ➋。`while` 循环中的条件表达式会评估 `double_return_overflow(x)`
    ➌。由于你是通过引用传递 `x`，它会对 `x` 进行加倍，这是它的副作用。该函数还会返回一个值，告诉你加倍是否导致了 `x` 的溢出。当条件表达式的结果为
    `true` 时，循环将继续执行，但 `double_return_overflow` 被写成返回 `true`，当循环应该停止时。你通过在前面加上逻辑非运算符（`!`）来修复这个问题。（回顾
    [第7章](ch07.xhtml#ch07)，该操作会将 `true` 转换为 `false`，将 `false` 转换为 `true`。）因此，`while`
    循环实际上是在问：“如果不是 `double_return_overflow` 为 true...”
- en: The end result is that you print the values 2, then 4, then 8, and so on to
    128 ➍.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 最终结果是，你依次打印出 2、4、8，依此类推直到 128 ➍。
- en: Notice that the value 1 never prints, because evaluating the conditional expression
    doubles `x`. You can modify this behavior by putting the conditional statement
    at the end of a loop, which yields a `do`-`while` loop.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，值 1 从未打印，因为评估条件表达式会将 `x` 加倍。你可以通过将条件语句放在循环末尾来修改这种行为，这样就会得到一个 `do`-`while`
    循环。
- en: '***do-while Loops***'
  id: totrans-191
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***do-while 循环***'
- en: 'A `do`-`while` loop is identical to a `while` loop, except the conditional
    statement evaluates after a loop completes rather than before. Its usage is as
    follows:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: '`do`-`while` 循环与 `while` 循环相同，只是条件语句在循环完成后评估，而不是在循环之前。其用法如下：'
- en: '[PRE33]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Because the condition evaluates at the end of a loop, you guarantee that the
    loop will execute at least once.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 由于条件在循环结束时进行评估，你可以保证循环至少会执行一次。
- en: '[Listing 8-21](ch08.xhtml#ch08ex21) refactors [Listing 8-20](ch08.xhtml#ch08ex20)
    into a `do`-`while` loop.'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 8-21](ch08.xhtml#ch08ex21) 将 [示例 8-20](ch08.xhtml#ch08ex20) 重构为 `do`-`while`
    循环。'
- en: '[PRE34]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: '*Listing 8-21: A program that doubles a `uint8_t` and prints the new value
    on each iteration*'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: '*示例 8-21：一个程序，它在每次迭代时将 `uint8_t` 的值加倍并打印新值*'
- en: Notice that the output from [Listing 8-21](ch08.xhtml#ch08ex21) now begins with
    1 ➊. All you needed to do was reformat the `while` loop to put the condition at
    the end of the loop ➋.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，来自 [示例 8-21](ch08.xhtml#ch08ex21) 的输出现在以 1 开始 ➊。你所需要做的只是重新格式化 `while` 循环，将条件放在循环的末尾
    ➋。
- en: 'In most situations involving iterations, you have three tasks:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 在大多数涉及迭代的情况中，你有三个任务：
- en: Initialize some object.
  id: totrans-200
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 初始化某个对象。
- en: Update the object before each iteration.
  id: totrans-201
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在每次迭代前更新对象。
- en: Inspect the object’s value for some condition.
  id: totrans-202
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 检查对象的值以满足某个条件。
- en: You can use a `while` or `do`-`while` loop to accomplish part of these tasks,
    but the `for` loop provides built-in facilities that make life easier.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用 `while` 或 `do`-`while` 循环来完成这些任务的一部分，但 `for` 循环提供了内建的功能，使得这些操作变得更加简便。
- en: '***for Loops***'
  id: totrans-204
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***for 循环***'
- en: 'The `for` loop is an iteration statement containing three special expressions:
    *initialization*, *conditional*, and *iteration*, as described in the sections
    that follow.'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: '`for` 循环是一个包含三个特殊表达式的迭代语句：*初始化*、*条件* 和 *迭代*，这些将在接下来的部分中进行描述。'
- en: '**The Initialization Expression**'
  id: totrans-206
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**初始化表达式**'
- en: 'The initialization expression is like the initialization of `if`: it executes
    only once before the first iteration executes. Any objects declared within the
    initialization expression have lifetimes bound by the scope of the `for` loop.'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 初始化表达式类似于 `if` 的初始化：它只会在第一次迭代之前执行一次。在初始化表达式中声明的任何对象的生命周期都被限制在 `for` 循环的作用域内。
- en: '**The Conditional Expression**'
  id: totrans-208
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**条件表达式**'
- en: The `for` loop conditional expression evaluates just before each iteration of
    the loop. If the conditional evaluates to `true`, the loop continues to execute.
    If the conditional evaluates to `false`, the loop terminates (this behavior is
    exactly like the conditional of the `while` and `do`-`while` loops).
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: '`for` 循环的条件表达式会在每次循环迭代之前进行评估。如果条件为 `true`，则循环继续执行。如果条件为 `false`，则循环终止（这种行为与
    `while` 循环和 `do`-`while` 循环的条件完全相同）。'
- en: Like `if` and `switch` statements, `for` permits you to initialize objects with
    scope equal to the statement’s.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 与 `if` 和 `switch` 语句类似，`for` 允许你初始化具有与语句相同作用域的对象。
- en: '**The Iteration Expression**'
  id: totrans-211
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**迭代表达式**'
- en: After each iteration of the `for` loop, the iteration expression evaluates.
    This happens before the conditional expression evaluates. Note that the iteration
    expression evaluates after a successful iteration, so the iteration expression
    won’t execute before the first iteration.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 在每次 `for` 循环的迭代后，迭代表达式会进行评估。这个评估发生在条件表达式评估之前。请注意，迭代表达式在成功迭代后进行评估，因此在第一次迭代之前不会执行迭代表达式。
- en: 'To clarify, the following list outlines the typical execution order in a `for`
    loop:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更清晰地说明，以下列表列出了 `for` 循环的典型执行顺序：
- en: Initialization expression
  id: totrans-214
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 初始化表达式
- en: Conditional expression
  id: totrans-215
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 条件表达式
- en: (Loop body)
  id: totrans-216
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: （循环主体）
- en: Iteration expression
  id: totrans-217
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 迭代表达式
- en: Conditional expression
  id: totrans-218
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 条件表达式
- en: (Loop body)
  id: totrans-219
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: （循环主体）
- en: Steps 4 through 6 repeat until a conditional expression returns `false`.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 步骤 4 到 6 会重复执行，直到条件表达式返回 `false`。
- en: '**Usage**'
  id: totrans-221
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**用法**'
- en: '[Listing 8-22](ch08.xhtml#ch08ex22) demonstrates the use of a `for` loop.'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: '[列表 8-22](ch08.xhtml#ch08ex22) 演示了如何使用 `for` 循环。'
- en: '[PRE35]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: '*Listing 8-22: Using a `for` loop*'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 8-22：使用 `for` 循环*'
- en: The initialization ➊, conditional ➋, and iteration ➌ expressions reside in parentheses
    preceding the body of the `for` loop.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: '`for` 循环的初始化 ➊、条件 ➋ 和迭代 ➌ 表达式位于括号中，位于 `for` 循环主体之前。'
- en: '**Iterating with an Index**'
  id: totrans-226
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**使用索引进行迭代**'
- en: The `for` loops are excellent at iterating over an array-like object’s constituent
    elements. You use an auxiliary *index* variable to iterate over the range of valid
    indices for the array-like object. You can use this index to interact with each
    array element in sequence. [Listing 8-23](ch08.xhtml#ch08ex23) employs an index
    variable to print each element of an array along with its index.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: '`for` 循环非常适合遍历类数组对象的组成元素。你使用一个辅助的 *索引* 变量来遍历数组对象有效索引的范围。你可以使用这个索引按顺序与每个数组元素进行交互。[列表
    8-23](ch08.xhtml#ch08ex23) 使用一个索引变量来打印数组的每个元素及其索引。'
- en: '[PRE36]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: '*Listing 8-23: A program iterating over an array of Fibonacci numbers*'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 8-23：遍历斐波那契数列数组的程序*'
- en: You initialize an `int` array called `x` with the first six Fibonacci numbers
    ➊. After printing a header for the output ➋, you build a `for` loop containing
    your initialization ➌, conditional ➍, and iteration ➎ expressions. The initialization
    expression executes first, and it initializes the index variable `i` to zero.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 你初始化一个名为 `x` 的 `int` 数组，包含前六个斐波那契数 ➊。在打印输出标题 ➋ 后，你构建一个包含初始化 ➌、条件 ➍ 和迭代 ➎ 表达式的
    `for` 循环。初始化表达式首先执行，并将索引变量 `i` 初始化为零。
- en: '[Listing 8-23](ch08.xhtml#ch08ex23) shows a coding pattern that hasn’t changed
    since the 1950s. You can eliminate a lot of boilerplate code by using the more
    modern range-based `for` loop.'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: '[列表 8-23](ch08.xhtml#ch08ex23) 显示了一种自 1950 年代以来未曾改变的编码模式。你可以通过使用现代的基于范围的 `for`
    循环来消除大量样板代码。'
- en: '***Ranged-Based for Loops***'
  id: totrans-232
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***基于范围的 `for` 循环***'
- en: The range-based `for` loop iterates over a *range* of values without needing
    an index variable. A range (or *range expression*) is an object that the range-based
    `for` loop knows how to iterate over. Many C++ objects are valid range expressions,
    including arrays. (All of the stdlib containers you’ll learn about in [Part II](part02.xhtml#part02)
    are also valid range expressions.)
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 基于范围的 `for` 循环在没有索引变量的情况下遍历一系列值。范围（或 *范围表达式*）是一个对象，基于范围的 `for` 循环知道如何遍历它。许多
    C++ 对象是有效的范围表达式，包括数组。（你将在 [第二部分](part02.xhtml#part02) 中学习到的所有 stdlib 容器也是有效的范围表达式。）
- en: '**Usage**'
  id: totrans-234
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**用法**'
- en: 'Ranged-based `for` loop usage looks like this:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 基于范围的 `for` 循环用法如下所示：
- en: '[PRE37]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: A *range declaration* declares a named variable. This variable must have the
    same type as implied by the range expression (you can use `auto`).
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: '*范围声明* 声明一个命名变量。这个变量必须与范围表达式所暗示的类型相同（你可以使用 `auto`）。'
- en: '[Listing 8-24](ch08.xhtml#ch08ex24) refactors [Listing 8-23](ch08.xhtml#ch08ex23)
    to use a range-based `for` loop.'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: '[列表 8-24](ch08.xhtml#ch08ex24) 重构了 [列表 8-23](ch08.xhtml#ch08ex23) ，使用基于范围的
    `for` 循环。'
- en: '[PRE38]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: '*Listing 8-24: A range-based `for` loop iterating over the first six Fibonacci
    numbers*'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 8-24：一个基于范围的`for`循环，迭代前六个斐波那契数*'
- en: You still declare an array `x` containing six Fibonacci numbers ➊. The range-based
    `for` loop contains a range-declaration expression ➋ where you declare the `element`
    variable to hold each element of the range. It also contains the range expression
    `x` ➌, which contains the elements you want to iterate over to print ➍.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 你仍然声明一个数组`x`，包含六个斐波那契数 ➊。基于范围的`for`循环包含一个范围声明表达式 ➋，在其中声明`element`变量来保存范围的每个元素。它还包含范围表达式`x`
    ➌，其中包含你希望迭代并打印的元素 ➍。
- en: This code is a whole lot cleaner!
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码整洁多了！
- en: '**Range Expressions**'
  id: totrans-243
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**范围表达式**'
- en: You can define your own types that are also valid range expressions. But you’ll
    need to specify several functions on your type.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以定义自己的类型，这些类型也可以作为有效的范围表达式。但是，你需要在你的类型上指定几个函数。
- en: Every range exposes a `begin` and an `end` method. These functions represent
    the common interface that a range-based `for` loop uses to interact with a range.
    Both methods return *iterators*. An iterator is an object that supports `operator!=`,
    `operator++`, and `operator*`.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 每个范围都暴露了`begin`和`end`方法。这些函数代表了基于范围的`for`循环与范围交互的通用接口。两个方法都返回*迭代器*。迭代器是一个支持`operator!=`、`operator++`和`operator*`的对象。
- en: Let’s look at how all these pieces fit together. Under the hood, a range-based
    `for` loop looks just like the loop in [Listing 8-25](ch08.xhtml#ch08ex25).
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看这些部分是如何结合在一起的。在底层，基于范围的`for`循环看起来就像[列表 8-25](ch08.xhtml#ch08ex25)中的循环。
- en: '[PRE39]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: '*Listing 8-25: A `for` loop simulating a range-based `for` loop*'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 8-25：一个模拟基于范围的`for`循环的`for`循环*'
- en: The initialization expression stores two variables, `b` ➋ and `e` ➊, which you
    initialize to `range.begin()` and `range.end()` respectively. The conditional
    expression checks whether `b` equals `e`, in which case the loop has completed
    ➌ (this is by convention). The iteration expression increments `b` with the prefix
    operator ➍. Finally, the iterator supports the dereference operator `*`, so you
    can extract the pointed-to element ➎.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 初始化表达式存储了两个变量，`b` ➋ 和 `e` ➊，分别初始化为`range.begin()`和`range.end()`。条件表达式检查`b`是否等于`e`，如果相等，则表示循环已完成
    ➌（这是惯例）。迭代表达式使用前缀操作符 ➍ 增加`b`。最后，迭代器支持解引用操作符`*`，因此可以提取指向的元素 ➎。
- en: '**NOTE**'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*The types returned by `begin` and `end` don’t need to be the same. The requirement
    is that `operator!=` on `begin` accepts an `end` argument to support the comparison
    `begin != end`.*'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: '*`begin`和`end`返回的类型不需要相同。要求是`begin`上的`operator!=`接受一个`end`参数，以支持比较`begin !=
    end`。*'
- en: '**A Fibonacci Range**'
  id: totrans-252
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**一个斐波那契范围**'
- en: You can implement a `FibonacciRange`, which will generate an arbitrarily long
    sequence of Fibonacci numbers. From the previous section, you know that this range
    must offer a `begin` and an `end` method that returns an iterator. This iterator,
    which is called `FibonacciIterator` in this example, must in turn offer `operator!=`,
    `operator++`, and `operator*`.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以实现一个`FibonacciRange`，它将生成一个任意长的斐波那契数列。从上一节中，你知道这个范围必须提供一个返回迭代器的`begin`和`end`方法。在本示例中，这个迭代器称为`FibonacciIterator`，它必须提供`operator!=`、`operator++`和`operator*`。
- en: '[Listing 8-26](ch08.xhtml#ch08ex26) implements a `FibonacciIterator` and a
    `FibonacciRange`.'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: '[列表 8-26](ch08.xhtml#ch08ex26)实现了一个`FibonacciIterator`和一个`FibonacciRange`。'
- en: '[PRE40]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: '*Listing 8-26: An implementation of `FibonacciIterator` and `FibonacciRange`*'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 8-26：`FibonacciIterator`和`FibonacciRange`的实现*'
- en: The `FibonacciIterator` has two fields, `current` and `last`, which are initialized
    to 1\. These keep track of two values in the Fibonacci sequence. Its `operator!=`
    checks whether the argument is greater than or equal to `current` ➊. Recall that
    this argument is used within the range-based `for` loop in the conditional expression.
    It should return `true` if elements remain in the range; otherwise, it returns
    `false`. The `operator++` appears in the iteration expression and is responsible
    for setting up the iterator for the next iteration. You first save `current` value
    into the temporary variable `tmp` ➋. Next, you increment current by `last`, yielding
    the next Fibonacci number ➌. (This follows from the definition of a Fibonacci
    sequence.) Then you set `last` equal to `tmp` ➍ and return a reference to `this`
    ➎. Finally, you implement `operator*`, which returns `current` ➏ directly.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: '`FibonacciIterator` 有两个字段，`current` 和 `last`，它们初始化为 1。它们跟踪 Fibonacci 序列中的两个值。其
    `operator!=` 检查传入的参数是否大于或等于 `current` ➊。回想一下，这个参数是在基于范围的 `for` 循环中的条件表达式里使用的。如果范围内还有元素，它应该返回
    `true`；否则返回 `false`。`operator++` 出现在迭代表达式中，负责为下一次迭代设置迭代器。你首先将 `current` 值保存到临时变量
    `tmp` ➋。接下来，你通过 `last` 递增 `current`，得到下一个 Fibonacci 数字 ➌。（这遵循 Fibonacci 序列的定义。）然后你将
    `last` 设置为 `tmp` ➍ 并返回对 `this` 的引用 ➎。最后，你实现了 `operator*`，它直接返回 `current` ➏。'
- en: '`FibonacciRange` is much simpler. Its constructor takes a max argument that
    defines an upper limit for the range ➐. The `begin` method returns a fresh `FibonacciIterator`
    ➑, and the `end` method returns `max` ➒.'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: '`FibonacciRange` 要简单得多。它的构造函数接受一个最大参数，定义了范围的上限 ➐。`begin` 方法返回一个新的 `FibonacciIterator`
    ➑，而 `end` 方法返回 `max` ➒。'
- en: 'It should now be apparent why you need to implement `bool operator!=(int x)`
    on `FibonacciIterator` rather than, for example, `bool operator!=(const FibonacciIterator&
    x)`: a `FibonacciRange` returns an `int` from `end()`.'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 现在应该显而易见为什么你需要在 `FibonacciIterator` 上实现 `bool operator!=(int x)`，而不是比如说在 `bool
    operator!=(const FibonacciIterator& x)` 上实现：一个 `FibonacciRange` 从 `end()` 返回一个
    `int`。
- en: You can use the `FibonacciRange` in a ranged-based `for` loop, as demonstrated
    in [Listing 8-27](ch08.xhtml#ch08ex27).
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在基于范围的 `for` 循环中使用 `FibonacciRange`，正如在 [清单 8-27](ch08.xhtml#ch08ex27) 中所展示的那样。
- en: '[PRE41]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: '*Listing 8-27: Using `FibonacciRange` in a program*'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 8-27：在程序中使用 `FibonacciRange`*'
- en: It took a little work to implement `FibonacciIterator` and `FibonacciRange`
    in [Listing 8-26](ch08.xhtml#ch08ex26), but the payoff is substantial. Within
    `main`, you simply construct a `FibonacciRange` with the desired upper limit ➊,
    and the range-based `for` loop takes care of everything else for you. You simply
    use the resulting elements within the `for` loop ➋.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [清单 8-26](ch08.xhtml#ch08ex26) 中实现 `FibonacciIterator` 和 `FibonacciRange`
    需要一些工作，但其回报是巨大的。在 `main` 中，你只需构造一个带有所需上限的 `FibonacciRange` ➊，基于范围的 `for` 循环会为你处理其他所有事情。你只需在
    `for` 循环中使用生成的元素 ➋。
- en: '[Listing 8-27](ch08.xhtml#ch08ex27) is functionally equivalent to [Listing
    8-28](ch08.xhtml#ch08ex28), which converts the range-based `for` loop to a traditional
    `for` loop.'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: '[清单 8-27](ch08.xhtml#ch08ex27) 与 [清单 8-28](ch08.xhtml#ch08ex28) 功能上是等价的，后者将基于范围的
    `for` 循环转换成传统的 `for` 循环。'
- en: '[PRE42]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: '*Listing 8-28: A refactor of [Listing 8-27](ch08.xhtml#ch08ex27) using a traditional
    `for` loop*'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 8-28：使用传统 `for` 循环重构 [清单 8-27](ch08.xhtml#ch08ex27)*'
- en: '[Listing 8-28](ch08.xhtml#ch08ex28) demonstrates how all of the pieces fit
    together. Calling `range.begin()` ➋ yields a `FibonacciIterator`. When you call
    `range.end()` ➊, it yields an `int`. These types come straight from the method
    definitions of `begin()` and `end()` on `FibonacciRange`. The conditional statement
    ➌ uses `operator!=(int)` on `FibonacciIterator` to get the following behavior:
    if the iterator `x` has gone past the `int` argument to `operator!=`, the conditional
    evaluates to `false` and the loop ends. You’ve also implemented `operator++` on
    `FibonacciIterator` so `++x` ➍ increments the Fibonacci number within `FibonacciIterator`.'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: '[清单 8-28](ch08.xhtml#ch08ex28) 展示了所有部分如何结合在一起。调用 `range.begin()` ➋ 会返回一个 `FibonacciIterator`。当你调用
    `range.end()` ➊ 时，它会返回一个 `int`。这些类型直接来源于 `FibonacciRange` 中 `begin()` 和 `end()`
    方法的定义。条件语句 ➌ 在 `FibonacciIterator` 上使用 `operator!=(int)` 来实现以下行为：如果迭代器 `x` 已经超过了传给
    `operator!=` 的 `int` 参数，条件语句将评估为 `false`，并且循环结束。你还实现了 `FibonacciIterator` 上的 `operator++`，所以
    `++x` ➍ 会在 `FibonacciIterator` 中递增 Fibonacci 数字。'
- en: When you compare [Listings 8-27](ch08.xhtml#ch08ex27) and [8-28](ch08.xhtml#ch08ex28),
    you can see just how much tedium range-based `for` loops hide.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 当你对比 [清单 8-27](ch08.xhtml#ch08ex27) 和 [8-28](ch08.xhtml#ch08ex28) 时，你可以看到基于范围的
    `for` 循环隐藏了多少繁琐的工作。
- en: '**NOTE**'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*You might be thinking, “Sure, the range-based `for` loop looks a lot cleaner,
    but implementing `FibonacciIterator` and `FibonacciRange` is a lot of work.” That’s
    a great point, and for one-time-use code, you probably wouldn’t refactor code
    in this way. Ranges are mainly useful if you’re writing library code, writing
    code that you’ll reuse often, or simply consuming ranges that someone else has
    written.*'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: '*你可能会想：“当然，基于范围的 `for` 循环看起来更简洁，但实现 `FibonacciIterator` 和 `FibonacciRange`
    需要做很多工作。”这是一个很好的观点，对于一次性使用的代码，你可能不会以这种方式重构代码。范围的主要用途是，当你编写库代码、编写你会经常重用的代码，或者只是使用别人编写的范围时。*'
- en: '**Jump Statements**'
  id: totrans-271
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**跳转语句**'
- en: '*Jump statements*, including the `break`, `continue`, and `goto` statements,
    transfer control flow. Unlike selection statements, jump statements are not conditional.
    You should avoid using them because they can almost always be replaced with higher-level
    control structures. They’re discussed here because you might see them in older
    C++ code and they still play a central role in a lot of C code.'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: '*跳转语句*，包括 `break`、`continue` 和 `goto`，用于转移控制流。与选择语句不同，跳转语句并不具有条件性。你应该避免使用它们，因为它们几乎总是可以被更高级的控制结构所替代。这里讨论这些语句是因为你可能在旧版
    C++ 代码中看到它们，它们仍然在许多 C 代码中起着核心作用。'
- en: '***break Statements***'
  id: totrans-273
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***跳出语句***'
- en: The `break` statement terminates execution of the enclosing iteration or `switch`
    statement. Once `break` completes, execution transfers to the statement immediately
    following the `for`, range-based `for`, `while`, `do`-`while`, or `switch` statement.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: '`break` 语句终止外层迭代或 `switch` 语句的执行。一旦 `break` 完成，控制流会转移到紧跟在 `for`、基于范围的 `for`、`while`、`do`-`while`
    或 `switch` 语句之后的语句。'
- en: You’ve already used `break` within `switch` statements; once a case completes,
    the `break` statement terminates the `switch`. Recall that, without a `break`
    statement, the `switch` statement would continue executing all of the following
    cases.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 你已经在 `switch` 语句中使用过 `break`；一旦某个分支执行完毕，`break` 语句就会终止 `switch` 语句。回想一下，如果没有
    `break` 语句，`switch` 语句会继续执行所有后续的分支。
- en: '[Listing 8-29](ch08.xhtml#ch08ex29) refactors [Listing 8-27](ch08.xhtml#ch08ex27)
    to break out of a range-based `for` loop if the iterator `i` equals 21.'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: '[清单 8-29](ch08.xhtml#ch08ex29) 重构了 [清单 8-27](ch08.xhtml#ch08ex27)，当迭代器 `i`
    等于 21 时跳出基于范围的 `for` 循环。'
- en: '[PRE43]'
  id: totrans-277
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: '*Listing 8-29: A refactor of [Listing 8-27](ch08.xhtml#ch08ex27) that breaks
    if the iterator equals 21*'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 8-29：重构自 [清单 8-27](ch08.xhtml#ch08ex27)，当迭代器等于 21 时跳出*'
- en: 'An `if` statement is added that checks whether `i` is 21 ➊. If it is, you print
    three asterisks `***` ➋ and `break` ➌. Notice the output: rather than printing
    21, the program prints three asterisks and the `for` loop terminates. Compare
    this to the output of [Listing 8-27](ch08.xhtml#ch08ex27).'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 添加了一个 `if` 语句，用来检查 `i` 是否等于 21 ➊。若是，它会打印三个星号 `***` ➋ 并执行 `break` ➌。注意输出结果：程序没有打印
    21，而是打印了三个星号，并且 `for` 循环终止了。与 [清单 8-27](ch08.xhtml#ch08ex27) 的输出结果比较。
- en: '***continue Statements***'
  id: totrans-280
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***continue 语句***'
- en: The `continue` statement skips the remainder of an enclosing iteration statement
    and continues with the next iteration. [Listing 8-30](ch08.xhtml#ch08ex30) replaces
    the `break` in [Listing 8-29](ch08.xhtml#ch08ex29) with a `continue`.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: '`continue` 语句跳过外层迭代语句的其余部分，并继续下一次迭代。[清单 8-30](ch08.xhtml#ch08ex30)将 [清单 8-29](ch08.xhtml#ch08ex29)
    中的 `break` 替换为 `continue`。'
- en: '[PRE44]'
  id: totrans-282
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: '*Listing 8-30: A refactor of [Listing 8-29](ch08.xhtml#ch08ex29) to use `continue`
    instead of `break`*'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 8-30：将 [清单 8-29](ch08.xhtml#ch08ex29) 重构为使用 `continue` 替代 `break`*'
- en: You still print three asterisks ➊ when `i` is 21, but you use `continue` instead
    of `break` ➋. This causes 21 not to print, like [Listing 8-29](ch08.xhtml#ch08ex29);
    however, unlike [Listing 8-29](ch08.xhtml#ch08ex29), [Listing 8-30](ch08.xhtml#ch08ex30)
    continues iterating. (Compare the output.)
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 当 `i` 等于 21 时，你仍然打印三个星号 ➊，但你使用 `continue` 替代 `break` ➋。这导致 21 不再打印，类似于 [清单 8-29](ch08.xhtml#ch08ex29)；然而，与
    [清单 8-29](ch08.xhtml#ch08ex29) 不同， [清单 8-30](ch08.xhtml#ch08ex30) 会继续迭代。（比较输出结果。）
- en: '***goto Statements***'
  id: totrans-285
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***goto 语句***'
- en: The `goto` statement is an unconditional jump. The target of a `goto` statement
    is a label.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: '`goto` 语句是一个无条件跳转。`goto` 语句的目标是一个标签。'
- en: '**Labels**'
  id: totrans-287
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**标签**'
- en: '*Labels* are identifiers you can add to any statement. Labels give statements
    a name, and they have no direct impact on the program. To assign a label, prepend
    a statement with the desired name of the label followed by a colon.'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: '*标签* 是你可以添加到任何语句的标识符。标签为语句赋予了名称，但它们对程序没有直接影响。要分配标签，只需在语句前加上所需标签的名称，后跟一个冒号。'
- en: '[Listing 8-31](ch08.xhtml#ch08ex31) adds the labels `luke` and `yoda` to a
    simple program.'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: '[列表 8-31](ch08.xhtml#ch08ex31)为一个简单程序添加了 `luke` 和 `yoda` 标签。'
- en: '[PRE45]'
  id: totrans-290
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: '*Listing 8-31: A simple program with labels*'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 8-31：带标签的简单程序*'
- en: The labels ➊➋ do nothing on their own.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 标签 ➊➋ 本身不执行任何操作。
- en: '**goto Usage**'
  id: totrans-293
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**`goto` 的使用**'
- en: 'The `goto` statement’s usage is as follows:'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: '`goto` 语句的用法如下：'
- en: '[PRE46]'
  id: totrans-295
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: For example, you can employ `goto` statements to needlessly obfuscate the simple
    program in [Listing 8-32](ch08.xhtml#ch08ex32).
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，你可以使用 `goto` 语句不必要地使[列表 8-32](ch08.xhtml#ch08ex32)中的简单程序变得晦涩。
- en: '[PRE47]'
  id: totrans-297
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: '*Listing 8-32: Spaghetti code showcasing the `goto` statement*'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 8-32：展示 `goto` 语句的意大利面代码*'
- en: Control flow in [Listing 8-32](ch08.xhtml#ch08ex32) passes to `silent_bob` ➊,
    then to `luke` ➋, and then to `yoda` ➌.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 在[列表 8-32](ch08.xhtml#ch08ex32)中的控制流先跳转到 `silent_bob` ➊，再到 `luke` ➋，然后到 `yoda`
    ➌。
- en: '**The Role of goto in Modern C++ Programs**'
  id: totrans-300
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**`goto` 在现代 C++ 程序中的作用**'
- en: In modern C++, there is no good role for `goto` statements. Don’t use them.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 在现代 C++ 中，`goto` 语句没有什么好的用途。不要使用它们。
- en: '**NOTE**'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*In poorly written C++ (and in most C code), you might see `goto` used as a
    primitive error-handling mechanism. A lot of system programming entails acquiring
    resources, checking for error conditions, and cleaning up resources. The RAII
    paradigm neatly abstracts all of these details, but C doesn’t have RAII available.
    See the Overture to C Programmers on [page xxxvii](anoverture.xhtml#page_xxxvii)
    for more information.*'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: '*在写得不好的 C++（以及大多数 C 代码）中，你可能会看到 `goto` 被用作一种原始的错误处理机制。很多系统编程涉及获取资源、检查错误条件以及清理资源。RAII（资源获取即初始化）范式巧妙地抽象了这些细节，但
    C 语言并没有 RAII。有关更多信息，请参见 C 程序员的序言，见[第 xxxvii 页](anoverture.xhtml#page_xxxvii)。*'
- en: '**Summary**'
  id: totrans-304
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**总结**'
- en: In this chapter, you worked through different kinds of statements you can employ
    in your programs. They included declarations and initializations, selection statements,
    and iteration statements.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你学习了可以在程序中使用的不同类型的语句。它们包括声明和初始化、选择语句以及迭代语句。
- en: '**NOTE**'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*Keep in mind that `try-catch` blocks are also statements, but they were already
    discussed in great detail in [Chapter 4](ch04.xhtml#ch04).*'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: '*请记住，`try-catch` 块也是语句，但它们已经在[第 4 章](ch04.xhtml#ch04)中详细讨论过。*'
- en: '**EXERCISES**'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: '**习题**'
- en: '**8-1.** Refactor [Listing 8-27](ch08.xhtml#ch08ex27) into separate translation
    units: one for `main` and another for `FibonacciRange` and `FibonacciIterator`.
    Use a header file to share definitions between the two translation units.'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: '**8-1.** 将[列表 8-27](ch08.xhtml#ch08ex27)重构为独立的翻译单元：一个用于 `main`，另一个用于 `FibonacciRange`
    和 `FibonacciIterator`。使用头文件共享两个翻译单元之间的定义。'
- en: '**8-2.** Implement a `PrimeNumberRange` class that can be used in a range expression
    to iterate over all prime numbers less than a given value. Again, use a separate
    header and source file.'
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: '**8-2.** 实现一个 `PrimeNumberRange` 类，可用于在范围表达式中迭代所有小于给定值的素数。再次使用单独的头文件和源文件。'
- en: '**8-3.** Integrate `PrimeNumberRange` into [Listing 8-27](ch08.xhtml#ch08ex27),
    adding another loop that generates all prime numbers less than 5,000.'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: '**8-3.** 将 `PrimeNumberRange` 集成到[列表 8-27](ch08.xhtml#ch08ex27)中，增加另一个循环，生成所有小于
    5,000 的素数。'
- en: '**FURTHER READING**'
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: '**进一步阅读**'
- en: '*ISO International Standard ISO/IEC (2017) — Programming Language C++* (International
    Organization for Standardization; Geneva, Switzerland; *[https://isocpp.org/std/the-standard/](https://isocpp.org/std/the-standard/)*)'
  id: totrans-313
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*ISO 国际标准 ISO/IEC（2017）— 编程语言 C++*（国际标准化组织；瑞士日内瓦； *[https://isocpp.org/std/the-standard/](https://isocpp.org/std/the-standard/)*）'
- en: '*Random Number Generation and Monte Carlo Methods*, 2nd Edition, by James E.
    Gentle (Springer-Verlag, 2003)'
  id: totrans-314
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*《随机数生成与蒙特卡罗方法》，第二版，詹姆斯·E·詹特尔著（Springer-Verlag，2003）*'
- en: '*Random Number Generation and Quasi-Monte Carlo Methods* by Harald Niederreiter
    (SIAM Vol. 63, 1992)'
  id: totrans-315
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*《随机数生成与准蒙特卡罗方法》，哈拉尔德·尼德赖特著（SIAM 第 63 卷，1992）*'
