- en: <hgroup>
  id: totrans-0
  prefs: []
  type: TYPE_NORMAL
  zh: <hgroup>
- en: 6 RECURSIVE FUNCTIONS AND FRACTALS
  id: totrans-1
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 6 递归函数与分形
- en: </hgroup>
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: </hgroup>
- en: '![](../images/icon.jpg)'
  id: totrans-3
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/icon.jpg)'
- en: 'Fractals are enchanting geometric shapes where the real meets the imaginary
    (imaginary numbers, that is). Repeating patterns keep emerging forever as we continue
    to zoom in on them. Mathematicians are still trying to define fractals precisely,
    but they agree on these key features: self-similarity (the way smaller parts of
    a fractal echo the whole) and the ability to scale ad infinitum.'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 分形是迷人的几何图形，现实与虚幻（即虚数）相交汇。当我们不断放大时，重复的模式永远不断地出现。数学家们仍在尝试精确定义分形，但他们一致同意以下几个关键特征：自相似性（分形的较小部分与整体相似）和能够无限放大。
- en: In this chapter, we’ll use Kotlin to draw a variety of fractals and explore
    their enigmatic beauty. Our main goal will be to codify the mathematical logic
    embedded in the design of each fractal, re-create those fractals, and possibly
    discover new ones by playing with the design parameters.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将使用Kotlin绘制各种分形，并探索它们神秘的美。我们的主要目标是将每个分形设计中蕴含的数学逻辑编码出来，重新创建这些分形，并通过调整设计参数可能发现新的分形。
- en: '### The Concept of Fractals'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: '### 分形的概念'
- en: The notion of fractals is full of dualisms and contradictions. Benoit Mandelbrot,
    considered the father of fractal geometry, coined the term *fractal* from the
    Latin word *fractus*, meaning fractured or broken, yet detailed images of fractals
    are hardly fractured, instead showing a continuous flow of intricate patterns.
    Well-known fractals such as the Julia set and the Mandelbrot set display extremely
    complex patterns, yet the equations that generate those patterns are very simple.
    The fact that a fractal map contains an infinite amount of information that can
    be condensed into a single equation is a major discovery of the 20th century,
    a wonder that reveals the hidden beauty of mathematics.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 分形的概念充满了二元对立和矛盾。被认为是分形几何学之父的本诺特·曼德尔布罗特，将*分形*一词从拉丁语*fractus*中创造而来，意为破裂或碎裂，但分形的细节图像几乎没有破裂，反而展示了连续流动的复杂模式。著名的分形，如朱利亚集和曼德尔布罗特集，展示了极其复杂的图案，但生成这些图案的方程式却非常简单。分形图包含了无限的信息量，而这些信息可以浓缩成一个方程式，这一发现是20世纪的重大成果，揭示了数学隐藏的美丽。
- en: Fractals aren’t just exotic mathematical objects, however. They help us see
    the “geometry of nature,” a term popularized by Mandelbrot. Indeed, fractal patterns
    are abundant throughout nature, seen in snowflakes, the branching of trees, the
    human nervous and circulatory systems, coastlines, clouds, hurricanes, and the
    spiral shapes of galaxies. The theory of fractals also has found applications
    in the physical and biological sciences, engineering, and information technology
    and given birth to new areas of research, such as chaos theory and its application
    in studying complex dynamic systems.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，分形不仅仅是奇异的数学对象。它们帮助我们看到了“自然的几何”，这是曼德尔布罗特所推广的术语。实际上，分形模式在大自然中无处不在，雪花、树木的分枝、人类的神经系统和循环系统、海岸线、云彩、飓风以及星系的螺旋形状中都可以看到分形的身影。分形理论也已在物理学、生物学、工程学和信息技术等领域得到了应用，并催生了诸如混沌理论及其在研究复杂动态系统中的应用等新的研究领域。
- en: Before we start coding, let’s review a simple fractal to explore a couple of
    its key features. [Figure 6-1](chapter6.xhtml#fig6-1) shows the Sierpiński triangle,
    a geometric fractal named after the famous Polish mathematician Wacław Sierpiński,
    who created it in 1915\. This fractal is constructed by repeatedly connecting
    the midpoints of the three sides of an equilateral triangle and all the resulting
    subtriangles.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始编程之前，先回顾一个简单的分形，以探索它的一些关键特性。[图6-1](chapter6.xhtml#fig6-1)展示了谢尔宾斯基三角形，这是一种几何分形，得名于著名的波兰数学家瓦茨瓦夫·谢尔宾斯基，他在1915年创造了这一分形。这个分形是通过不断连接等边三角形三个边的中点以及所有生成的子三角形构造而成的。
- en: '![](../images/Figure6-1.jpg)'
  id: totrans-10
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/Figure6-1.jpg)'
- en: 'Figure 6-1: The Sierpiński triangle'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 图6-1：谢尔宾斯基三角形
- en: 'The inherent beauty of this fractal derives from its self-similarity: look
    at any of the smaller triangles inside the outermost triangle and you’ll see a
    mini version of the original figure. Moreover, if we amplify or scale up one of
    the smaller triangles, we’ll find many more of the same inside it. For example,
    [Figure 6-2](chapter6.xhtml#fig6-2) shows a zoomed-in view of just the triangle
    formed by points A, D, and E from [Figure 6-1](chapter6.xhtml#fig6-1). The result
    is the same as the original triangle.'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 这个分形的内在美来自于它的自相似性：观察外部三角形内的任何一个较小的三角形，你会看到它是原始图形的迷你版。此外，如果我们放大或缩放其中一个较小的三角形，我们会发现里面还包含许多相同的小三角形。例如，[图
    6-2](chapter6.xhtml#fig6-2)展示了只包含 A、D 和 E 三个点的三角形的放大视图，来自于[图 6-1](chapter6.xhtml#fig6-1)。结果与原始三角形完全相同。
- en: '![](../images/Figure6-2.jpg)'
  id: totrans-13
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/Figure6-2.jpg)'
- en: 'Figure 6-2: A zoomed-in section of the Sierpiński triangle, illustrating the
    fractal’s ability to scale'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6-2：谢尔宾斯基三角形的放大部分，展示了分形的缩放能力
- en: No theoretical limit is placed on how deep we can go—even the smallest triangle
    from the original figure, when amplified, produces the same result. A fractal
    can scale up forever.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们可以达到的深度，并没有理论上的限制——即使是原始图形中最小的三角形，当放大时，也会得到相同的结果。分形可以永远放大。
- en: 'Fractals also have an interesting property called *fractal dimension*. Unlike
    familiar geometric objects such as lines, areas, and volumes that have one, two,
    and three dimensions, respectively, a fractal can have a fractional number of
    dimensions. The Sierpiński triangle, for example, has 1.585 dimensions: it’s more
    than a one-dimensional line but less than a two-dimensional area. This is because
    it fits in a 2D plane but doesn’t completely fill the area that defines the fractal
    boundary. You can find a more formal and in-depth discussion of this topic in
    many of the excellent resources listed at the end of the chapter.'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 分形还有一个有趣的属性，叫做*分形维度*。不同于我们熟知的几何物体，如线、面积和体积，分别具有一维、二维和三维，分形可以具有分数维度。例如，谢尔宾斯基三角形的维度是1.585：它比一维线更复杂，但又小于二维面积。这是因为它可以适应二维平面，但并没有完全填充定义分形边界的区域。你可以在本章末尾列出的一些优秀资源中找到关于这一话题的更正式和深入的讨论。
- en: Recursive Functions
  id: totrans-17
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 递归函数
- en: The most efficient way to draw a self-similar pattern that can theoretically
    keep repeating itself forever is to use a *recursive function*. This is a function
    that continues to call itself from within its own function body until a stopping
    condition is met. Once we identify the basic building block of a fractal, we can
    write a function to draw that building block and then let the function repeatedly
    call itself, until the fractal pattern is sufficiently developed. In the sections
    that follow, we’ll use this approach to generate several well-known geometric
    fractals, including the Sierpiński triangle, the Sierpiński carpet, and a fractal
    tree. But first, let’s get a feel for how recursion works by writing a function
    to calculate the factorial of an arbitrary positive integer *n*.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 绘制一个理论上可以永远重复下去的自相似模式的最有效方式是使用*递归函数*。这是一种函数，它会在自身的函数体内不断调用自己，直到满足停止条件。一旦我们确定了分形的基本构建块，我们就可以编写一个函数来绘制这个构建块，然后让该函数不断调用自己，直到分形模式足够完善。在接下来的部分中，我们将使用这种方法生成几种著名的几何分形，包括谢尔宾斯基三角形、谢尔宾斯基地毯和分形树。但首先，让我们通过编写一个函数来计算任意正整数
    *n* 的阶乘，来感受一下递归是如何工作的。
- en: 'The factorial of a number *n* is defined as:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 一个数字 *n* 的阶乘定义为：
- en: '*  n*! = *n* × (*n* – 1) × (*n* – 2) × ... × 3 × 2 × 1'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: '*  n*! = *n* × (*n* – 1) × (*n* – 2) × ... × 3 × 2 × 1'
- en: 'In other words, *n*! equals the product of all integers from 1 to *n*. For
    example, 3! = 3 × 2 × 1 = 6, 4! = 4 × 3 × 2 × 1 = 24, and so on (by convention,
    1! = 1). Thinking recursively, we can also define the factorial of *n* as the
    product of *n* and the factorial of the next smaller integer (*n* – 1):'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 换句话说，*n*! 等于从 1 到 *n* 的所有整数的乘积。例如，3! = 3 × 2 × 1 = 6，4! = 4 × 3 × 2 × 1 = 24，以此类推（根据惯例，1!
    = 1）。从递归的角度思考，我们也可以将 *n* 的阶乘定义为 *n* 和下一个较小整数 (*n* – 1) 的阶乘的乘积：
- en: '*  n*! = *n* × (*n* – 1)!'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: '*  n*! = *n* × (*n* – 1)!'
- en: Using this modified form of the equation, we can write a recursive function
    to calculate the factorial of *n*.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这种修改后的方程形式，我们可以写一个递归函数来计算 *n* 的阶乘。
- en: '[PRE0]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Something interesting is happening here. The function getFactorial(n) calls
    itself from inside the function body ❶ and thus kicks off a loop that runs until
    the most recent value of n equals 1. At that point, the last call to the function
    returns 1 and the loop terminates, returning the value of the factorial.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 这里发生了一些有趣的事情。函数getFactorial(n)在函数体内调用自身❶，从而启动了一个循环，直到n的最新值等于1。此时，最后一次调用函数返回1，循环终止，并返回阶乘的值。
- en: '[Table 6-1](chapter6.xhtml#tab6-1) shows how the key function parameters change
    at each iteration, leading to the factorial value in the end.'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: '[表6-1](chapter6.xhtml#tab6-1)展示了关键函数参数在每次迭代中的变化，最终得出阶乘值。'
- en: 'Table 6-1: Anatomy of the Recursive Function getFactorial(n) for n = 5'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 表6-1：递归函数getFactorial(n)的结构，n = 5
- en: '| Iteration | Argument (n) | Test (n == 1) | Returned value |'
  id: totrans-28
  prefs: []
  type: TYPE_TB
  zh: '| 迭代 | 参数（n） | 测试（n == 1） | 返回值 |'
- en: '| --- | --- | --- | --- |'
  id: totrans-29
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- |'
- en: '| 1 | 5 | False | 5 × getFactorial(4) |'
  id: totrans-30
  prefs: []
  type: TYPE_TB
  zh: '| 1 | 5 | 假 | 5 × getFactorial(4) |'
- en: '| 2 | 4 | False | 5 × 4 × getFactorial(3) |'
  id: totrans-31
  prefs: []
  type: TYPE_TB
  zh: '| 2 | 4 | 假 | 5 × 4 × getFactorial(3) |'
- en: '| 3 | 3 | False | 5 × 4 × 3 × getFactorial(2) |'
  id: totrans-32
  prefs: []
  type: TYPE_TB
  zh: '| 3 | 3 | 假 | 5 × 4 × 3 × getFactorial(2) |'
- en: '| 4 | 2 | False | 5 × 4 × 3 × 2 × getFactorial(1) |'
  id: totrans-33
  prefs: []
  type: TYPE_TB
  zh: '| 4 | 2 | 假 | 5 × 4 × 3 × 2 × getFactorial(1) |'
- en: '| 5 | 1 | True | 5 × 4 × 3 × 2 × 1 = 120 |'
  id: totrans-34
  prefs: []
  type: TYPE_TB
  zh: '| 5 | 1 | 真 | 5 × 4 × 3 × 2 × 1 = 120 |'
- en: Notice that a recursive function is essentially a loop that keeps on calling
    itself. We must therefore provide a stopping condition (in this case, n <= 1).
    Without one, the function will be trapped in an infinite loop.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，递归函数本质上是一个不断自我调用的循环。因此，我们必须提供一个停止条件（在这种情况下是n <= 1）。没有停止条件，函数将陷入无限循环。
- en: It may not be obvious just yet, but recursive functions can make coding significantly
    simpler (the alternative would be to use complex nested loops). This becomes especially
    true when the recursive function needs to make multiple calls to itself, using
    different state variables. We’ll see this idea in the upcoming projects.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 现在可能还不明显，但递归函数可以显著简化编码（另一种选择是使用复杂的嵌套循环）。当递归函数需要多次调用自身，并使用不同的状态变量时，这种情况尤为明显。我们将在接下来的项目中看到这个想法。
- en: '*Tail recursion* is a technique in which a recursive function implements tail
    call optimization (TCO). This allows the compiler to avoid consuming additional
    *stack space* (a region in memory that stores information in a last-in, first-out
    order) for each recursive call. Instead, the compiler reuses the same stack space
    for each call, which can help prevent stack overflow errors.'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: '*尾递归*是一种技术，在这种技术中，递归函数实现了尾调用优化（TCO）。这允许编译器避免为每次递归调用消耗额外的*栈空间*（内存中按后进先出顺序存储信息的区域）。相反，编译器为每次调用重复使用相同的栈空间，这有助于防止栈溢出错误。'
- en: To use tail recursion in Kotlin, the recursive call must be the very last call
    of the method. This means that the function must return the result of the recursive
    call directly, without performing any additional operations on it.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 要在 Kotlin 中使用尾递归，递归调用必须是方法的最后一个调用。这意味着函数必须直接返回递归调用的结果，而不对其执行任何额外的操作。
- en: 'Here’s an example of an alternative version of the code that calculates the
    factorial of a number by using tail recursion:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个使用尾递归计算数字阶乘的代码的替代版本示例：
- en: '[PRE1]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: In this implementation, the main() function remains unchanged, but the getFactorial()
    function has been modified.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种实现中，main()函数保持不变，但getFactorial()函数已经被修改。
- en: 'Notice how the getFactorial() function is defined with the tailrec keyword
    ❶, which indicates that it should be optimized for tail call recursion. The function
    takes two arguments: n, which is the number whose factorial will be calculated,
    and result, which is the current result of the calculation. If n is 0 or 1, the
    function returns result. Otherwise, it calls itself recursively with n - 1 as
    the new value of n and n * result as the new value of result. This continues until
    n is 0 or 1, at which point the final result is returned.'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，getFactorial()函数是使用tailrec关键字定义的❶，这表示它应该为尾调用递归进行优化。该函数接受两个参数：n，表示将计算阶乘的数字；result，表示当前的计算结果。如果n为0或1，函数返回result。否则，它会递归调用自身，使用n
    - 1作为n的新值，并使用n * result作为result的新值。这一过程将持续直到n为0或1，此时返回最终结果。
- en: For large numbers (n), this implementation not only saves memory but may also
    require less time to complete the computations.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 对于大数（n），这种实现不仅节省了内存，而且可能需要更少的时间来完成计算。
- en: 'Project 22: The “Hello, World!” of Fractals'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 项目22：分形的“你好，世界！”
- en: 'Our first foray into the world of fractals will be a simple one: we’ll write
    a recursive function to draw a series of concentric squares, each one smaller
    than and located symmetrically inside the previous one. We’ll visualize the fractal
    by using the canvas feature of JavaFX.'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 我们进入分形世界的第一次尝试将是一个简单的示例：我们将编写一个递归函数来绘制一系列同心正方形，每个正方形都比前一个正方形小，并且对称地位于前一个正方形内部。我们将通过使用
    JavaFX 的画布功能来可视化这个分形。
- en: The Strategy
  id: totrans-46
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 策略
- en: The JavaFX canvas allows us to draw a polygon based on the coordinates of its
    vertices. We need a way to calculate the four vertices of a square, given the
    x- and y-coordinates of one of the vertices and the length of any side (for a
    square, they’re all equal). We’ll use the scheme outlined in [Figure 6-3](chapter6.xhtml#fig6-3).
    Keep in mind that the default origin (0, 0) of the canvas is located at the top-left
    corner.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: JavaFX 画布允许我们根据多边形顶点的坐标来绘制多边形。我们需要一种方法来计算正方形的四个顶点，给定其中一个顶点的 x 和 y 坐标以及任意一条边的长度（对于正方形，四条边的长度相等）。我们将使用在[图
    6-3](chapter6.xhtml#fig6-3)中概述的方案。请记住，画布的默认原点（0, 0）位于左上角。
- en: '![](../images/Figure6-3.jpg)'
  id: totrans-48
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/Figure6-3.jpg)'
- en: 'Figure 6-3: The strategy for drawing concentric squares'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6-3：绘制同心正方形的策略
- en: We’ll start by choosing the coordinates for the top-left vertex of the outermost
    square, *x* and *y*. Given those, calculating the square’s other coordinates is
    simply a matter of adding the side length *s* as appropriate. This gives us everything
    we need to draw the outermost square.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从选择外部正方形的左上角顶点坐标 *x* 和 *y* 开始。给定这些坐标，计算正方形的其他坐标只需按需添加边长 *s*。这就为我们绘制外部正方形提供了所需的所有信息。
- en: 'Next, we’ll call a recursive function to draw the inner square or squares by
    using the following function parameters: the x- and y-coordinates for the top-left
    vertex of the most recently drawn square; the side length of that square, *s*;
    and a shrinkage factor, *k* (a percentage setting how much smaller the sides of
    the next square should be). We’ll use this information to calculate *d* in [Figure
    6-3](chapter6.xhtml#fig6-3), the distance from the top of one square to the top
    of the next, as:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将调用递归函数，通过以下参数绘制内部正方形或多个正方形：最近绘制的正方形的左上角顶点的 x 和 y 坐标；该正方形的边长 *s*；以及一个缩小因子
    *k*（一个百分比，表示下一个正方形边长应缩小多少）。我们将使用这些信息计算[图 6-3](chapter6.xhtml#fig6-3)中的 *d*，即从一个正方形的顶部到下一个正方形顶部的距离，计算公式为：
- en: '*  d* = *ks/*2'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: '*  d* = *ks/*2'
- en: 'That in turn will let us update the top-left coordinates and the side length
    of the next square as follows:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 这将使我们能够更新下一个正方形的左上角坐标和边长，如下所示：
- en: '*  x* = *x* + *d*'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: '*  x* = *x* + *d*'
- en: '*  y* = *y* + *d*'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: '*  y* = *y* + *d*'
- en: '*  s* = *s* – 2*d*'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: '*  s* = *s* – 2*d*'
- en: To prevent our recursive function from devolving into an infinite loop, we’ll
    provide a stopping condition in the form of a global constant limiting the number
    of iterations.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 为了防止我们的递归函数变成无限循环，我们将在递归函数中提供一个停止条件，即通过全局常量限制迭代次数。
- en: The Code
  id: totrans-58
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 代码
- en: Following the steps we just discussed, we first create the required variables
    and draw the outer square.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 按照我们刚才讨论的步骤，首先创建所需的变量并绘制外部正方形。
- en: '[PRE2]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: This code places the top-left corner of the outer square at (50, 50) relative
    to the origin and sizes the square to 400×400\. (The canvas itself is 500×500,
    as we’ll see later.) At each iteration, the sides of the inner square will be
    reduced by 15 percent ❶; feel free to play with this value. The squares will be
    drawn in black, as specified by Color.BLACK, on a white background (the default).
    Calling gc.strokePolygon() draws a square ❷ (gc is the GraphicsContext object
    needed to draw to the canvas). This method requires that the coordinates of the
    vertices be passed in two separate DoubleArrays, one for the x-values and one
    for the y-values; the last parameter indicates the number of vertices—in this
    case, for a square, four.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码将外部正方形的左上角放置在相对于原点的 (50, 50) 位置，并将正方形的大小设置为 400×400。画布本身的尺寸是 500×500，稍后我们将看到。在每次迭代中，内部正方形的边长将缩小
    15% ❶；可以根据需要调整这个值。正方形将以黑色绘制，如 Color.BLACK 所指定，背景为白色（默认值）。调用 gc.strokePolygon()
    方法绘制正方形 ❷（gc 是用于在画布上绘图的 GraphicsContext 对象）。此方法要求传入两个单独的 DoubleArray 数组，分别用于 x
    和 y 坐标；最后一个参数表示顶点的数量——在这种情况下，对于正方形，顶点数为四。
- en: Now let’s implement our recursive drawSquares() function.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们实现递归的 drawSquares() 函数。
- en: '[PRE3]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The algorithm starts by checking the stopping condition: if iter, which has
    an initial value of 1 and is incremented by 1 per recursion, exceeds the maximum
    number of iterations set by ITER_MAX, then the loop will stop drawing squares
    on the canvas, and the program will terminate normally. Otherwise, we calculate
    a new set of parameters and proceed to draw another square. Notice that we used
    an underscore as a prefix for the x- and y-coordinates of the top-left vertex,
    as well as for the length of the side, while receiving parameter values. This
    naming convention allows us to use the same variable names inside the function
    as we did outside in the application class.'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 算法首先检查停止条件：如果iter（其初始值为1，并且每次递归递增1）超过了由ITER_MAX设置的最大迭代次数，那么循环将停止在画布上绘制正方形，程序将正常终止。否则，我们计算一组新的参数，继续绘制另一个正方形。请注意，我们在接收参数值时，使用下划线作为左上角顶点的x和y坐标的前缀，以及边长的前缀。这种命名约定使得我们在函数内部使用的变量名与应用程序类外部使用的变量名保持一致。
- en: We then recursively call the drawSquares() function with the updated parameter
    values to draw the next inner square ❶. [Figure 6-4](chapter6.xhtml#fig6-4) shows
    the program output with an ITER_MAX value of 22, which means that 22 squares are
    inside the outermost square.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们递归地调用drawSquares()函数，使用更新后的参数值绘制下一个内侧的正方形❶。[图6-4](chapter6.xhtml#fig6-4)显示了程序的输出，ITER_MAX值为22，意味着最外面的正方形内有22个正方形。
- en: '![](../images/Figure6-4.jpg)'
  id: totrans-66
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/Figure6-4.jpg)'
- en: 'Figure 6-4: A simple fractal made from concentric, nonrotating squares'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 图6-4：由同心的、非旋转的正方形组成的简单分形
- en: Our concentric squares are a simple example of a geometric fractal. It exhibits
    self-similarity in that if we removed a few of the outer squares, the resulting
    image, when scaled up, would look the same, even if we iterated many more times.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的同心正方形是一个简单的几何分形例子。它表现出自相似性，即如果我们去除一些外层正方形，得到的图像在放大后看起来会和原图相同，即使我们迭代更多次。
- en: Here’s the complete code for the app, including the boilerplate JavaFX components
    adapted for Kotlin.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是应用程序的完整代码，包括为Kotlin适配的JavaFX组件模板。
- en: '[PRE4]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: By introducing minor variations to this code, you can create other, similar
    geometric fractals, such as concentric rectangles or circles. Before you attempt
    the practice exercise, I encourage you to experiment with these variations.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 通过对这段代码进行一些微小的变化，你可以创建其他类似的几何分形，比如同心矩形或圆形。在你尝试实践练习之前，我建议你先尝试这些变化。
- en: 'Project 23: Draw the Sierpiński Triangle'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 项目23：绘制谢尔宾斯基三角形
- en: For this project, we’ll draw the Sierpiński triangle (see [Figure 6-1](chapter6.xhtml#fig6-1))
    using an approach similar to [Project 22](chapter6.xhtml#pre-22). First, we’ll
    identify the defining features of the fractal, including its geometric properties,
    and then write a recursive function to do most of the hard work. We’ll use the
    same JavaFX template we used for [Project 22](chapter6.xhtml#pre-22) to create
    the graphical output.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个项目，我们将使用类似于[项目22](chapter6.xhtml#pre-22)的方法绘制谢尔宾斯基三角形（见[图6-1](chapter6.xhtml#fig6-1)）。首先，我们将识别分形的定义特征，包括其几何性质，然后编写一个递归函数来完成大部分的复杂工作。我们将使用与[项目22](chapter6.xhtml#pre-22)相同的JavaFX模板来创建图形输出。
- en: Recall that the Sierpiński triangle is made by taking a triangle and joining
    the midpoints of its sides, producing three child triangles, then joining the
    midpoints of the child triangles’ sides, and so on, recursively, ad infinitum.
    Typically, the triangles are equilateral, meaning they have three equal sides
    and internal angles of 60 degrees. We’ll make use of these basic properties to
    come up with an efficient strategy for creating the fractal. However, working
    with equilateral triangles isn’t strictly required; you can use the steps outlined
    in this section to create an isosceles Sierpiński triangle, with minor adjustments
    to the code.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 回想一下，谢尔宾斯基三角形是通过取一个三角形并连接其三边的中点，产生三个子三角形，然后继续连接这些子三角形边的中点，如此递归下去，直到无限。通常，这些三角形是等边三角形，意味着它们有三条相等的边和60度的内角。我们将利用这些基本特性来制定一种有效的策略，生成分形。然而，处理等边三角形并不是严格要求的；你可以按照本节中概述的步骤，通过对代码做一些小调整，创建一个等腰谢尔宾斯基三角形。
- en: The Strategy
  id: totrans-75
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 策略
- en: 'To draw the Sierpiński triangle, we need a few key parameters: the x- and y-coordinates
    of the parent (outermost) triangle’s top vertex, where the two inclined sides
    meet, and the parent triangle’s base (*b*) and height (*h*). [Figure 6-5](chapter6.xhtml#fig6-5)
    shows these parameters, including some additional ones for the child triangles
    that will be used in our code.'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 绘制谢尔宾斯基三角形时，我们需要一些关键参数：父（三角形外部）三角形的顶点坐标（x，y），即两条倾斜边相交的地方，以及父三角形的底边（*b*）和高度（*h*）。[图6-5](chapter6.xhtml#fig6-5)展示了这些参数，包括一些用于子三角形的附加参数，这些将在我们的代码中使用。
- en: '![](../images/Figure6-5.jpg)'
  id: totrans-77
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/Figure6-5.jpg)'
- en: 'Figure 6-5: The strategy for drawing the Sierpiński triangle'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 图6-5：绘制谢尔宾斯基三角形的策略
- en: We’ll first draw the parent triangle, as we did for the concentric squares example.
    We’ll then call a recursive function to connect the midpoints of the triangle’s
    three sides, whose coordinates are calculated in terms of the parent triangle’s
    base, height, and top vertex. Since this creates three smaller child triangles
    (as opposed to one smaller square), the recursive function will have to call itself
    multiple times, once for each of the child triangles ❶ ❷ ❸. We’ll keep using recursion
    until a stopping condition is met.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先绘制父三角形，就像我们在同心正方形示例中所做的那样。接着，我们会调用一个递归函数来连接三角形三条边的中点，这些中点的坐标是根据父三角形的底边、高度和顶点计算的。由于这将创建三个更小的子三角形（而不是一个更小的正方形），递归函数需要多次调用自身，每次针对一个子三角形
    ❶ ❷ ❸。我们将继续使用递归，直到满足停止条件为止。
- en: '#### The Code'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: '#### 代码'
- en: We’ll discuss the code in three parts. First, we’ll import the required math
    functions and declare some global parameters and a data class (we’ll reuse the
    rest of the JavaFX-specific codes from [Project 22](chapter6.xhtml#pre-22)).
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将分三部分讨论代码。首先，我们将导入所需的数学函数并声明一些全局参数和数据类（其余与JavaFX相关的代码将从[项目22](chapter6.xhtml#pre-22)中复用）。
- en: '[PRE5]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The first global parameter, BASE, represents the base of the parent (outer)
    triangle, which is set to 500\. The second parameter, DEPTH, is the number of
    iterations (how many times inner triangles are drawn), but we use it only to calculate
    our real stopping condition, baseMin. This is the smallest base length of the
    inner triangles when we stop recursion. It’s more practical to think in terms
    of a minimum side length because how small an object we can draw is limited by
    the pixel size of the screen, as well as by our ability to see small objects.
    It wouldn’t make sense to let the recursion run an arbitrary number of times (say,
    50 or 100 times) while creating a static image.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个全局参数BASE表示父（三角形外部）三角形的底边，设定为500\。第二个参数DEPTH是迭代次数（即内嵌三角形绘制的次数），但我们仅用它来计算真正的停止条件baseMin。这是内嵌三角形的最小底边长度，当我们停止递归时，它就达到了最小值。考虑到我们能绘制的物体大小受到屏幕像素尺寸和我们视力的限制，实际上考虑最小边长更为实际。因此，让递归执行任意次（比如50或100次）以生成静态图像是没有意义的。
- en: 'The baseMin parameter is linked to the number of iterations DEPTH as:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: baseMin参数与迭代次数DEPTH的关系如下：
- en: $Equation$ ![](../images/pg236-1.jpg)
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: $方程$ ![](../images/pg236-1.jpg)
- en: This means baseMin decreases exponentially as DEPTH increases, which is why
    just 5 to 10 iterations can be adequate for bringing out the key features of simple
    geometric fractals. In this case, since we’re using a DEPTH value of 7 and a BASE
    of 500, baseMin will be 3.906.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着随着DEPTH的增加，baseMin呈指数下降，因此仅5到10次迭代就足以展现简单几何分形的关键特征。在此案例中，由于我们使用了DEPTH值为7和BASE为500，baseMin将为3.906。
- en: We’ll use the data class Vertices to store and return the vertices of internal
    triangles, with the help of the getVertices() function (which we’ll discuss shortly).
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用数据类Vertices来存储并返回内部三角形的顶点，借助getVertices()函数（我们稍后会详细讨论）。
- en: Next, let’s have a look at the problem-specific code segment that defines and
    draws the parent triangle. The top vertex is set to (300.0, 50.0), and the base
    *b* and height *h* are set to be 500.0 and 500 sin(*θ*), respectively, where *θ*
    is π/3 radians (or 60 degrees).
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们看一下定义并绘制父三角形的特定代码段。顶点设定为(300.0, 50.0)，底边*b*和高度*h*分别设定为500.0和500 sin(*θ*)，其中*θ*为π/3弧度（或60度）。
- en: '[PRE6]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: We draw the parent triangle with a call to the gc.strokePolygon() function,
    passing the x- and y-coordinates of the three vertices and the number of vertices
    (in this case, three). We then make a single call to the recursive function drawTriangle()
    to generate the child triangles. Notice we’re following the same basic steps we
    used in [Project 22](chapter6.xhtml#pre-22) to draw the concentric squares.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过调用 `gc.strokePolygon()` 函数来绘制父三角形，传递三个顶点的 x 和 y 坐标以及顶点数量（在这种情况下是三个）。然后，我们进行一次对递归函数
    `drawTriangle()` 的调用，以生成子三角形。注意，我们遵循了与[项目22](chapter6.xhtml#pre-22)中绘制同心正方形时相同的基本步骤。
- en: Finally, we’ll define our recursive function to draw the inner triangles. We’ll
    also define a helper function for calculating the midpoints of a triangle.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将定义我们的递归函数来绘制内三角形。我们还将定义一个辅助函数，用于计算三角形的中点。
- en: '[PRE7]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Our drawTriangle() function follows a similar pattern to our drawSquares() function
    from [Project 22](chapter6.xhtml#pre-22), but a couple of important differences
    exist. First, the stopping condition is now set with respect to baseMin ❶ instead
    of the maximum number of iterations (we’ve already discussed why that is the case).
    Second, we make three separate recursive calls inside the drawTriangle() function
    (instead of a single recursive call as in the previous project) to make sure that
    all three child triangles generated at each step contribute to creating the final
    fractal image. To see how this works, have a look at [Figure 6-6](chapter6.xhtml#fig6-6).
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的 `drawTriangle()` 函数与我们在[项目22](chapter6.xhtml#pre-22)中的 `drawSquares()` 函数遵循了类似的模式，但存在几个重要的区别。首先，停止条件现在是基于
    `baseMin` ❶ 而不是最大迭代次数（我们已经讨论过为什么这样做）。其次，我们在 `drawTriangle()` 函数内部进行了三次独立的递归调用（而不是像之前的项目那样进行一次递归调用），以确保在每个步骤中生成的三个子三角形都有助于创建最终的分形图像。要查看其工作原理，可以参见[图6-6](chapter6.xhtml#fig6-6)。
- en: '![](../images/Figure6-6.jpg)'
  id: totrans-94
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/Figure6-6.jpg)'
- en: 'Figure 6-6: Evolution of the Sierpiński triangle with recursive calls (n =
    7)'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 图6-6：通过递归调用演化的谢尔宾斯基三角形（n = 7）
- en: If we made only the first recursive call ❷ from inside the drawTriangle() function,
    the final figure will subdivide only the top child triangles, as shown on the
    left side of [Figure 6-6](chapter6.xhtml#fig6-6). The center image shows what
    would happen if we made two recursive calls ❷ ❸; now the top and left child triangles
    are subdivided. Finally, the image on the right is what we want—the complete Sierpiński
    triangle, created by making three back-to-back recursive calls to the drawTriangle()
    function, ❷ ❸ ❹, with updated parameter values for the child triangles.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们仅在 `drawTriangle()` 函数内部进行了第一次递归调用 ❷，最终的图形将只会对子三角形的顶部进行细分，如[图6-6](chapter6.xhtml#fig6-6)左侧所示。中间的图像展示了如果我们进行了两次递归调用
    ❷ ❸，会发生什么情况；此时，顶部和左侧的子三角形都被细分。最后，右侧的图像是我们想要的——完整的谢尔宾斯基三角形，它是通过对 `drawTriangle()`
    函数进行三次连续递归调用 ❷ ❸ ❹ 来创建的，子三角形的参数值也得到了更新。
- en: 'Project 24: Create a Fractal Tree'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 项目24：创建一棵分形树
- en: As the final project on simple geometric fractals, we’ll draw a beautiful fractal
    tree. The tree will start as a single line (the trunk) that splits into two branches.
    Then each branch will itself split into two more branches, and so on.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 作为简单几何分形的最终项目，我们将绘制一棵美丽的分形树。树木将从一条直线（树干）开始，树干分成两条分支。然后，每个分支将自己分成两条分支，依此类推。
- en: The Strategy
  id: totrans-99
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 策略
- en: 'The core strategy for this project is straightforward: draw a line, then recursively
    draw two more lines from the endpoint of that line, each at an angle relative
    to the parent line. [Figure 6-7](chapter6.xhtml#fig6-7) outlines the strategy
    and the features we’ll have to incorporate into the code.'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 该项目的核心策略很简单：绘制一条线，然后从这条线的端点递归绘制两条线，每条线相对于父线都有一个角度。[图6-7](chapter6.xhtml#fig6-7)概述了该策略以及我们需要在代码中整合的特性。
- en: '![](../images/Figure6-7.jpg)'
  id: totrans-101
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/Figure6-7.jpg)'
- en: 'Figure 6-7: The strategy for drawing the fractal tree'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 图6-7：绘制分形树的策略
- en: First, we’ll choose a starting point (*x1*, *y1*) for the parent line, a length
    *l*, and *θ*, the parent line’s angle with respect to the x-axis. Using trigonometry,
    we calculate the coordinates for the endpoint of the parent line (which is also
    the starting point of the two child lines) as *x1* + *l* cos(*θ*) and *y1* + *l*
    sin(*θ*). The child lines are shorter than the parent line (we’ll choose a shrinkage
    factor) and branch out from the parent line by some arbitrary angle *φ*, such
    that the new lines will be drawn at angles (*θ* + *φ*) and (*θ* – *φ*) relative
    to the x-axis, respectively. Keep calculating endpoints, drawing new lines, and
    branching out until a stopping condition is met (for example, when the new branches
    become too small).
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将为父线选择一个起点（*x1*，*y1*），一个长度*l*，以及父线相对于x轴的角度*θ*。使用三角学，我们计算父线终点的坐标（也就是两个子线的起点）为*x1*
    + *l* cos(*θ*)和*y1* + *l* sin(*θ*)。子线比父线短（我们会选择一个缩小因子），并且从父线分支出来的角度为任意角度*φ*，使得新线分别以角度（*θ*
    + *φ*）和（*θ* – *φ*）相对于x轴绘制。不断计算终点，绘制新线并进行分支，直到满足停止条件（例如，当新分支变得太小）。
- en: The Code
  id: totrans-104
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 代码
- en: 'In this example, we do not have any global variables or parameters, and the
    import block for math functions looks like this:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们没有使用任何全局变量或参数，数学函数的导入块如下所示：
- en: '[PRE8]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Hence, the first code snippet we’ll discuss covers the problem-specific parameter
    values within the application class and the call to the recursive function drawTree().
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们将讨论的第一个代码片段涉及到应用类中的问题特定参数值以及递归函数`drawTree()`的调用。
- en: '[PRE9]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: We center the starting point of the parent line horizontally on the canvas and
    place it 100 pixels above the bottom (we’re assuming a canvas size of 600×600).
    The starting angle (angle) of –π/2 draws the tree in an upright position. We set
    the branch-out angle of the child lines relative to the parent line, *φ* (phi),
    to π/10, which produces optimal branching for the given parameters. Unlike in
    our previous fractal projects, we haven’t drawn anything yet. This time, the parent
    line is drawn inside the recursive function, since it uses the same code as drawing
    the child lines. We’ll define that function next.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将父线的起点水平居中放置在画布上，并将其位置设为距离底部100像素（假设画布大小为600×600）。起始角度（angle）为–π/2，使得树木以直立的姿势绘制。我们将子线相对于父线的分支角度*φ*（phi）设置为π/10，这样可以在给定参数下产生最佳的分支效果。与之前的分形项目不同，这次我们还没有绘制任何内容。此时，父线在递归函数内部绘制，因为它使用了与绘制子线相同的代码。接下来，我们将定义这个函数。
- en: '[PRE10]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The termination condition stops recursion when the len parameter passed into
    the function becomes less than or equal to 10 ❶. At each iteration, we calculate
    the endpoint of the current line and draw it with the gc.strokeLine() function.
    We then make two recursive calls ❷ ❸, reducing the length of the child lines by
    four pixels (approximately 7 percent of the original parent line length). When
    the stopping condition is met, instead of terminating the drawTree() function
    immediately, the app draws small circles at the end of all final child lines.
    With a proper selection of colors, the result can resemble a blossoming cherry
    tree. The grayscale version of this tree is shown in [Figure 6-8](chapter6.xhtml#fig6-8).
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 终止条件是在传入函数的len参数小于或等于10时停止递归❶。在每次迭代中，我们计算当前线段的终点，并使用gc.strokeLine()函数绘制它。然后，我们进行两次递归调用❷❸，将子线的长度减少四像素（大约是原父线长度的7%）。当停止条件满足时，应用程序不会立即终止`drawTree()`函数，而是会在所有最终子线的末端绘制小圆圈。通过合理选择颜色，结果可以像一棵盛开的樱花树。此树的灰度版本显示在[图6-8](chapter6.xhtml#fig6-8)中。
- en: '![](../images/Figure6-8.jpg)'
  id: totrans-112
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/Figure6-8.jpg)'
- en: 'Figure 6-8: A blossoming fractal tree'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 图6-8：盛开的分形树
- en: For all the fractal projects we’ve worked on so far, and for this project in
    particular, the parameter values you choose will have a significant effect on
    the final appearance of the image. If you copy the parameter values verbatim from
    the book’s code snippets, you’ll be able to reproduce the exact same figures presented
    in this chapter. However, there are numerous possible combinations of parameter
    values you could use. I encourage you to play with the parameters; who knows,
    you might discover a whole new fractal family that no one has seen yet!
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们到目前为止做的所有分形项目，尤其是这个项目，您选择的参数值将对图像的最终外观产生重大影响。如果您从书中的代码片段中逐字复制参数值，您将能够重现本章中呈现的完全相同的图形。但是，您可以使用许多可能的参数值组合。我鼓励您玩弄这些参数；谁知道呢，也许您会发现一个全新的分形家族，没人见过！
- en: The L-System and Turtle Graphics
  id: totrans-115
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: L系统与海龟图形
- en: Closely related to fractals is the *L-system*, a technique for generating complex
    strings of characters over a series of iterative steps. The characters are then
    interpreted as different geometric operations, such as drawing lines or turning
    left or right. The L-system was introduced by Aristid Lindenmayer, a Hungarian
    biologist, in 1968 to study the development of simple organisms and model plant
    morphology and growth. Lindenmayer proposed that plant development over time can
    be described by “natural” algorithms that are responsible for the geometric features
    seen in the arrangements of branches, leaves, petals, and flowers. (We’ll discuss
    several other nature-inspired algorithms in [Chapters 8](chapter8.xhtml) and [9](chapter9.xhtml).)
    Another feature of plant growth (incorporated in the L-system) that researchers
    were quick to notice was the prevalence of self-similarity—the same pattern being
    replicated at different scales. No wonder the L-system was soon picked up by mathematicians
    and computer scientists to study and visualize the beautiful geometry of nature
    that Mandelbrot succinctly called fractals.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 与分形密切相关的是*L系统*，这是一种通过一系列迭代步骤生成复杂字符序列的技术。然后，这些字符被解释为不同的几何操作，例如绘制线条或向左或向右转弯。L系统由匈牙利生物学家阿里斯蒂德·林登梅耶（Aristid
    Lindenmayer）于1968年提出，用于研究简单生物体的发展，并模拟植物形态和生长。林登梅耶提出，植物随时间的发展可以通过“自然”算法来描述，这些算法负责描述在枝条、叶子、花瓣和花朵排列中看到的几何特征。（我们将在[第8章](chapter8.xhtml)和[第9章](chapter9.xhtml)讨论几个其他受自然启发的算法。）植物生长的另一个特征（也被L系统所包含）是自相似性的普遍存在——同样的模式在不同的尺度上被复制。难怪L系统很快被数学家和计算机科学家采用，用来研究和可视化曼德尔布罗特简洁地称之为分形的大自然美丽几何。
- en: In this section, we’ll study the components of an L-system and develop our own
    L-system simulator in Kotlin. We’ll also learn about Turtle Graphics, a common
    computer programming model used for visualizing the shapes and patterns created
    by L-systems. Since Kotlin’s standard library doesn’t include a Turtle Graphics
    package, we’ll combine JavaFX canvas with Kotlin to create our own Turtle class.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将研究L系统的组成部分，并在Kotlin中开发我们自己的L系统模拟器。我们还将学习海龟图形（Turtle Graphics），这是一种常用的计算机编程模型，用于可视化L系统所创建的形状和模式。由于Kotlin的标准库不包含海龟图形包，我们将结合JavaFX画布和Kotlin来创建我们自己的海龟类。
- en: Formalizing the L-System
  id: totrans-118
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 形式化L系统
- en: 'An L-system requires a few ingredients to generate a string of characters interpretable
    as geometric instructions for drawing fractal objects: an alphabet, an axiom,
    a set of rules, and a depth. The *alphabet* is the set of characters that are
    available for use in the string, each with an associated meaning. For example,
    F might signify drawing a line, + might signify turning right, and so on (we’ll
    define our full alphabet later). The *axiom* is an initial sequence of characters
    that the L-system starts from, and the *rules* establish techniques for transforming
    the axiom (or subsequent strings) over a series of iterations. When there are
    multiple rules, they’re applied in sequence, and the substrings created by each
    rule are concatenated in the same order to form the new string. The depth sets
    the number of iterations over which to apply the rules before you arrive at the
    final string. [Table 6-2](chapter6.xhtml#tab6-2) summarizes the components of
    an L-system.'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: L 系统需要一些基本元素来生成可以解释为绘制分形物体的几何指令的字符串：字母表、公理、一组规则和深度。*字母表*是字符串中可用的字符集，每个字符都有一个相关的含义。例如，F
    可能表示绘制一条线，+ 可能表示向右转，等等（我们稍后会定义完整的字母表）。*公理*是 L 系统起始时的初始字符序列，*规则*则定义了在一系列迭代中转换公理（或后续字符串）的方法。当有多个规则时，它们按顺序应用，每个规则生成的子字符串按相同的顺序连接在一起，形成新的字符串。深度设定了应用规则的迭代次数，直到得到最终的字符串。[表
    6-2](chapter6.xhtml#tab6-2)总结了 L 系统的组件。
- en: 'Table 6-2: L-System Components'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 表 6-2：L 系统组件
- en: '| Feature | Function | Example | Interpretation |'
  id: totrans-121
  prefs: []
  type: TYPE_TB
  zh: '| 特性 | 功能 | 示例 | 解释 |'
- en: '| --- | --- | --- | --- |'
  id: totrans-122
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- |'
- en: '| Alphabet | A set of allowable characters | F, G, J, +, -, [,], X | See [Table
    6-3](chapter6.xhtml#tab6-3). |'
  id: totrans-123
  prefs: []
  type: TYPE_TB
  zh: '| 字母表 | 允许使用的字符集 | F, G, J, +, -, [,], X | 参见[表 6-3](chapter6.xhtml#tab6-3)。
    |'
- en: '| Axiom | An initial set of characters to start off production (to apply the
    rules recursively) | F++F | Move forward from the current position, turn right
    by a specified angle twice, and move forward again. |'
  id: totrans-124
  prefs: []
  type: TYPE_TB
  zh: '| 公理 | 用于开始生成的初始字符集（以递归方式应用规则） | F++F | 从当前位置前进，右转指定角度两次，然后再次前进。 |'
- en: '| Rules | Directions on how to create a new string from a given axiom or string
    | F -> F-F++F-F | Replace every instance of F in a string with the set of characters
    that follow the arrow (->); add other characters not specified in the rule as
    is. |'
  id: totrans-125
  prefs: []
  type: TYPE_TB
  zh: '| 规则 | 如何根据给定公理或字符串创建新字符串的说明 | F -> F-F++F-F | 将字符串中的每个 F 替换为箭头（->）后面的一组字符；对于规则未指定的其他字符，原样保留。
    |'
- en: '| Depth | The number of times the rules are applied (axiom is assumed to have
    a depth of zero) | 5 | Apply the rules five times before creating the corresponding
    figure. |'
  id: totrans-126
  prefs: []
  type: TYPE_TB
  zh: '| 深度 | 规则应用的次数（假设公理的深度为零） | 5 | 在创建相应图形之前应用规则五次。 |'
- en: 'In addition to the components mentioned in [Table 6-2](chapter6.xhtml#tab6-2),
    we need to set two other parameters: the length of the lines to be drawn (or the
    distance to jump over without drawing a line) and the angle of rotation. Typically,
    the length decreases with each iteration because the larger (outer) elements of
    a fractal are often drawn first, followed by finer (inner) elements. Reducing
    the length may also be required to limit the size of the final figure. The angle
    of rotation *θ* for a particular fractal remains constant throughout the process.'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 除了[表 6-2](chapter6.xhtml#tab6-2)中提到的组件外，我们还需要设置另外两个参数：要绘制的线段长度（或跳过不绘制线段的距离）和旋转角度。通常，随着每次迭代，线段长度会减少，因为分形的较大（外部）元素通常先被绘制，然后是较小（内部）元素。减少线段长度也可能是为了限制最终图形的大小。特定分形的旋转角度*θ*在整个过程中保持不变。
- en: 'Let’s look at a simple example to illustrate how to use L-system notations
    and procedures: drawing a triangle. For this exercise, the L-system parameters
    and associated steps are outlined in [Figure 6-9](chapter6.xhtml#fig6-9).'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过一个简单的例子来说明如何使用 L 系统符号和过程：绘制一个三角形。对于这个练习，[图 6-9](chapter6.xhtml#fig6-9)中概述了
    L 系统的参数和相关步骤。
- en: '![](../images/Figure6-9.jpg)'
  id: totrans-129
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/Figure6-9.jpg)'
- en: 'Figure 6-9: The L-system for drawing an equilateral triangle'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6-9：用于绘制等边三角形的 L 系统
- en: 'We start at (*x1*, *y1*) on the canvas, facing in the positive x-axis direction,
    at angle 0 relative to the x-axis. Our axiom is just a single character, F, and
    our rule, F -> F++F++F, tells us that with each iteration we should replace any
    instance of the character F with the string F++F++F. After applying the rule for
    a depth of 1 (meaning apply the rule only once to the axiom before stopping),
    we have our final string: F++F++F.'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从画布上的 (*x1*, *y1*) 开始，面朝正 x 轴方向，相对于 x 轴的角度为 0。我们的公理是一个字符，F，而我们的规则 F -> F++F++F
    告诉我们，每次迭代时，应将字符 F 替换为字符串 F++F++F。应用规则一次（即仅对公理应用一次规则，然后停止）后，我们得到最终的字符串：F++F++F。
- en: 'We now follow this string of instructions: from our initial position, move
    forward (F) a specified length, *l*, to arrive at (*x2*, *y2*), then perform two
    right turns (++), each by a specified angle, *θ*, and move forward (F) again to
    arrive at (*x3*, *y3*). Finally, take two more right turns (++) and move forward
    (F), which brings us back to the starting point and completes the triangle. Each
    time we move forward from one point to another, we trace the path (connect the
    two points) with a line.'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们按照这个指令字符串进行操作：从初始位置出发，向前移动（F）指定的长度 *l*，到达 (*x2*, *y2*)，然后进行两次右转（++），每次按指定角度
    *θ* 旋转，再次向前移动（F），到达 (*x3*, *y3*)。最后，再进行两次右转（++），向前移动（F），这将我们带回起点，完成三角形。每次从一个点移动到另一个点时，我们通过画线连接这两个点，跟踪路径。
- en: Drawing L-System Patterns with Turtle Graphics
  id: totrans-133
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 使用海龟图形绘制 L-系统图案
- en: 'Turtle Graphics is a drawing system that imagines a turtle moving around a
    graphics window. The turtle has at least two properties: its location in terms
    of x- and y-coordinates and its orientation measured by an angle relative to the
    positive direction of the x-axis. The turtle drags around a pen. When the pen
    is down, it draws lines on the window as the turtle moves; when the pen is up,
    the turtle moves without tracing its path.'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 海龟图形是一种绘图系统，它将海龟想象成在图形窗口中移动。海龟至少有两个属性：其在 x 和 y 坐标系中的位置，以及通过相对于正 x 轴方向的角度来衡量的朝向。海龟拖着一支笔。当笔放下时，海龟移动时会在窗口上画出线条；当笔抬起时，海龟移动但不会留下轨迹。
- en: Turtle Graphics was originally part of an educational programming language called
    Logo, but the idea has also been implemented in other languages, including Python.
    It’s used to teach concepts related to programming and the movement and animation
    of simple objects in a graphics window. It can also be used creatively to teach
    Euclidian geometry and to generate interesting patterns through recursion. Perhaps
    the most well-known application of Turtle Graphics in research is for visualizing
    the strings of instructions created by L-systems of geometric fractals.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 海龟图形最初是一个名为 Logo 的教育编程语言的一部分，但这一概念也被实现到了其他编程语言中，包括 Python。它用于教授与编程相关的概念，以及在图形窗口中简单对象的移动和动画。它还可以创意性地用于教授欧几里得几何，并通过递归生成有趣的图案。或许海龟图形在研究中的最著名应用是可视化由几何分形的
    L-系统生成的指令字符串。
- en: When a language has built-in support for Turtle Graphics, we only need to import
    the relevant package or class and make use of its methods or functions to move
    the turtle around and draw lines, shapes, and patterns. Since the Kotlin standard
    library doesn’t include a Turtle package, we’ll develop a simple Turtle class
    that will work seamlessly with the Canvas object of JavaFX and deliver the same
    functionality. The broader goal of this exercise is to build a minimalist L-system
    simulator capable of generating L-system strings of arbitrary depth and realizing
    them with the help of the Turtle class to produce well-known geometric fractals.
    [Table 6-3](chapter6.xhtml#tab6-3) shows the L-system notations (characters) we’ll
    work with and the corresponding Turtle class methods that we’ll need to implement.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 当一种语言内置对海龟图形的支持时，我们只需导入相关的包或类，利用其方法或函数来控制海龟的移动，绘制线条、形状和图案。由于 Kotlin 标准库不包含海龟包，我们将开发一个简单的海龟类，它能与
    JavaFX 的 Canvas 对象无缝配合，提供相同的功能。本练习的更大目标是构建一个简约的 L-系统模拟器，能够生成任意深度的 L-系统字符串，并借助海龟类将其实现，生成著名的几何分形。[表
    6-3](chapter6.xhtml#tab6-3)展示了我们将使用的 L-系统符号（字符）和相应的海龟类方法，我们需要实现这些方法。
- en: 'Table 6-3: L-System Characters and Turtle Graphics Methods'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 表 6-3：L-系统字符和海龟图形方法
- en: '| Character(s) | Desired action | Turtle command |'
  id: totrans-138
  prefs: []
  type: TYPE_TB
  zh: '| 字符 | 期望的动作 | 海龟命令 |'
- en: '| --- | --- | --- |'
  id: totrans-139
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| F, G | Move the turtle forward, and draw a line to connect old and new positions.
    Though F and G have identical actions, rules may not apply the same way to F and
    G. | turtle.lineTo() |'
  id: totrans-140
  prefs: []
  type: TYPE_TB
  zh: '| F, G | 将海龟向前移动，并绘制一条连接旧位置和新位置的线。尽管 F 和 G 执行相同的动作，规则可能不会以相同的方式应用于 F 和 G。 |
    turtle.lineTo() |'
- en: '| J | Jump forward to a new position without drawing a line. | turtle.moveTo()
    |'
  id: totrans-141
  prefs: []
  type: TYPE_TB
  zh: '| J | 跳跃到一个新位置而不绘制线条。 | turtle.moveTo() |'
- en: '| + | Turn the turtle to the right by a specified angle. | turtle.turnRight()
    |'
  id: totrans-142
  prefs: []
  type: TYPE_TB
  zh: '| + | 将海龟向右旋转指定角度。 | turtle.turnRight() |'
- en: '| - | Turn the turtle to the left by a specified angle. | turtle.turnLeft()
    |'
  id: totrans-143
  prefs: []
  type: TYPE_TB
  zh: '| - | 将海龟向左旋转指定角度。 | turtle.turnLeft() |'
- en: '| [ | Push (save) the turtle’s current state (location, angle) to the stack.
    | turtle.push() |'
  id: totrans-144
  prefs: []
  type: TYPE_TB
  zh: '| [ | 将海龟的当前状态（位置、角度）推送（保存）到栈中。 | turtle.push() |'
- en: '| ] | Pull the last saved state from the stack (while also removing it from
    the stack) and set that as the turtle’s current state. | turtle.pop() |'
  id: totrans-145
  prefs: []
  type: TYPE_TB
  zh: '| ] | 从栈中弹出最后一个保存的状态（同时将其从栈中移除）并将其设置为海龟的当前状态。 | turtle.pop() |'
- en: '| X | Do nothing. Skip to the next instruction. | No turtle call |'
  id: totrans-146
  prefs: []
  type: TYPE_TB
  zh: '| X | 什么也不做。跳到下一条指令。 | 无海龟调用 |'
- en: While drawing complex shapes, the L-system strings may require the turtle to
    branch out in different directions from a base location. For this, the turtle
    needs to save its current state so it can later return to the base and choose
    another direction. The push() method helps with saving the current state, while
    the pull() method retrieves a saved state so that the turtle can start a new branch
    from there. These methods will rely on a *stack*, a data structure where the most
    recent item added is the first to be retrieved, commonly called last in, first
    out (LIFO). This way, the turtle will return to more recent states first, to complete
    subbranches, before returning to earlier saved states to start drawing new main
    branches.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 在绘制复杂形状时，L-System 字符串可能会要求海龟从一个基准位置向不同方向分支。为此，海龟需要保存其当前状态，以便稍后返回基准位置并选择另一个方向。`push()`
    方法有助于保存当前状态，而 `pull()` 方法则检索已保存的状态，以便海龟从那里开始新的分支。这些方法将依赖于一个*栈*，一种数据结构，其中最近添加的项是第一个被取出的，通常称为后进先出（LIFO）。这样，海龟将首先返回到较新的状态，以完成子分支，然后再返回到较早保存的状态，开始绘制新的主分支。
- en: 'Project 25: Design an L-System Simulator'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 项目 25：设计一个 L-System 模拟器
- en: An L-system simulator is made up of several functions or classes that help interpret
    L-system rules, generate the final string of instructions, and draw the resulting
    image on a graphics window. Ideally, these components would be coded in a problem-independent
    manner, with some mechanism for the user to input the initial parameters for the
    L-system, perhaps through a file or at the command line. For simplicity’s sake,
    we’ll instead embed these parameters into the code itself, using values that will
    generate a snowflake pattern, but the rest of the code will be generic. All you’ll
    have to do is update these problem-specific parameters to simulate different L-system
    objects.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 一个 L-System 模拟器由几个函数或类组成，这些函数或类帮助解释 L-System 规则、生成最终的指令字符串，并在图形窗口中绘制生成的图像。理想情况下，这些组件应该以与问题无关的方式编写，并且提供某种机制让用户输入
    L-System 的初始参数，可能是通过文件或命令行。为了简化起见，我们将这些参数直接嵌入代码中，使用生成雪花图案的值，但其他代码将保持通用。你只需更新这些特定问题的参数，即可模拟不同的
    L-System 对象。
- en: The Code
  id: totrans-150
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 代码
- en: We’ll begin our L-system simulator code with some global declarations to keep
    our data organized, then define the problem-specific parameters for generating
    a particular L-system object. Next, we’ll declare some helper functions to generate
    the L-system string based on rules and draw the final L-system string on the canvas.
    We’ll also declare our Turtle class with methods for rendering the image and then
    tie everything together with an LSystemApp class.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从一些全局声明开始编写我们的 L-System 模拟器代码，以保持数据的组织性，然后定义生成特定 L-System 对象的特定问题参数。接下来，我们将声明一些辅助函数，用于基于规则生成
    L-System 字符串并在画布上绘制最终的 L-System 字符串。我们还将声明我们的 Turtle 类，并为其添加渲染图像的方法，然后通过一个 LSystemApp
    类将所有内容整合在一起。
- en: Global Declarations
  id: totrans-152
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 全局声明
- en: We’ll start by declaring two data classes to organize L-system data, plus a
    special array type to create the stack functionality required for the push() and
    pull() methods.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将通过声明两个数据类来组织 L-System 数据，以及一个特殊的数组类型来创建 `push()` 和 `pull()` 方法所需的栈功能。
- en: '[PRE11]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The Rule data class will define each L-system rule by using the key and apply
    members, both of type String. The key property will hold the character that will
    be replaced if present when a rule is applied, and the apply property will hold
    the string that will replace the key. For example, for a rule F -> F++F++F, the
    values of key and apply would be F and F++F++F, respectively.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: '`Rule` 数据类将通过使用 `key` 和 `apply` 成员来定义每个L系统规则，二者都是 `String` 类型。`key` 属性将保存如果存在时在应用规则时需要替换的字符，而
    `apply` 属性将保存替换 `key` 的字符串。例如，对于规则 F -> F++F++F，`key` 和 `apply` 的值分别是 F 和 F++F++F。'
- en: The second data class, State, saves the state of the turtle—specifically, its
    x- and y-coordinates and the direction it’s facing relative to the x-axis. Finally,
    stack is declared by using Kotlin’s ArrayDeque class, which implements a resizable
    (mutable) array of the deque (short for *double-ended queue*) data structure.
    This class has methods to facilitate the LIFO feature of the stack. The array’s
    members will be of our custom State data type.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个数据类，State，保存海龟的状态——具体来说，它的x和y坐标以及它相对于x轴的朝向。最后，栈是通过使用Kotlin的`ArrayDeque`类声明的，该类实现了一个可调整大小的（可变的）双端队列（*double-ended
    queue*）数据结构的数组。这个类有方法来方便栈的后进先出（LIFO）特性。数组的成员将是我们自定义的State数据类型。
- en: '##### Problem Definition'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: '##### 问题定义'
- en: Next, we’ll declare the problem-specific parameters of an L-system, including
    its axiom and rules. The parameters we’re using here will generate a simple fractal
    pattern that looks like a snowflake. Feel free to replace them with parameters
    for other well-known L-systems or to experiment with your own.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将声明L系统的特定问题参数，包括它的公理和规则。我们在这里使用的参数将生成一个看起来像雪花的简单分形图案。可以随意将它们替换为其他著名L系统的参数，或者尝试你自己的参数。
- en: '[PRE12]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: First, we define the axiom, or starting string, for a snowflake fractal ❶. Earlier,
    we used this same string, F++F++F, to draw an equilateral triangle. We then create
    a list of type Rule called rules, where we keep all the rules pertaining to the
    L-system ❷. The snowflake requires only a single rule, but the comments inside
    listOf() show how to add more rules if needed. We set the initial value of line
    to 100 pixels based on a canvas size of 600×600, but the line length will shrink
    by one-third with each iteration. We also set the turning angle, ANGLE, to 60
    degrees and the number of iterations, depth, to 5.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们为雪花分形❶定义了公理或起始字符串。之前，我们使用相同的字符串 F++F++F 来绘制等边三角形。然后，我们创建一个名为 rules 的 `Rule`
    类型列表，在其中保存与L系统相关的所有规则❷。雪花只需要一个规则，但 `listOf()` 内的注释展示了如果需要的话如何添加更多规则。我们将线条的初始值设为100像素，基于600×600的画布大小，但线条长度将在每次迭代时缩短三分之一。我们还将转角角度
    `ANGLE` 设置为60度，迭代次数 `depth` 设置为5。
- en: We only need to create a single instance of the Turtle class ❸. We set its initial
    position to (150.0, 200.0), with an initial angle of 0.0 (facing toward the positive
    x-direction). Notice that as the turtle begins to move, both its location and
    its orientation (angle) may change. Finally, we set finalString to an empty string
    at the start; its content will change after each iteration, and only the final
    value will be used to draw the fractal.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 我们只需要创建一个 `Turtle` 类的实例❸。我们将它的初始位置设置为 (150.0, 200.0)，初始角度为 0.0（面朝正x方向）。注意，随着海龟的移动，它的位置和朝向（角度）可能会发生变化。最后，我们将
    `finalString` 设置为空字符串；它的内容将在每次迭代后改变，只有最终的值会用来绘制分形图案。
- en: The generate() Function
  id: totrans-162
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '`generate()` 函数'
- en: The generate() function is a core component of the simulator. It executes the
    L-system rules for a given axiom and depth.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: '`generate()` 函数是模拟器的核心组件。它根据给定的公理和深度执行L系统规则。'
- en: '[PRE13]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: We first declare an empty string called nextString, where we’ll save interim
    values of the final string. We then use two for loops to iterate one character
    at a time through the most recent version of finalString ❶ and apply any relevant
    rules to that character ❷. The Boolean variable match tracks if a particular rule
    should be applied. When a selected character matches the key of the current rule
    ❸, we set match to true and add the replacement string specified by the apply
    element of the rule to nextString. This is followed by the break statement to
    break out of the inner for loop (only one rule will be applicable to a character
    for each iteration of the outer for loop). If none of the rules apply, we add
    the current character to nextString unchanged ❹. Once we’ve iterated over all
    the characters in finalString, we reset its value to nextString ❺.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先声明一个空字符串nextString，在其中保存最终字符串的中间值。然后我们使用两个for循环，通过finalString的最新版本逐个字符进行迭代，并对该字符应用任何相关的规则
    ❷。布尔变量match用于跟踪是否应该应用特定的规则。当选择的字符与当前规则的关键字匹配时 ❸，我们将match设置为true，并将规则的apply元素指定的替换字符串添加到nextString中。接下来是break语句，用于跳出内部for循环（每次外部for循环迭代时，只会有一个规则适用于某个字符）。如果没有任何规则适用，我们将当前字符不加改变地添加到nextString中
    ❹。一旦我们迭代完finalString中的所有字符，我们将其值重置为nextString ❺。
- en: The draw() Function
  id: totrans-166
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: draw()函数
- en: The draw() function draws the final image on the canvas by reading the characters
    in finalString and making corresponding calls to the methods of our Turtle class.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: draw()函数通过读取finalString中的字符，并调用Turtle类的方法来绘制最终图像。
- en: '[PRE14]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: We elegantly implement the drawing process inside a single for loop ❶ and a
    compact when block ❷, which is much less verbose than a traditional multilevel
    if...else block. The for loop scans the characters of the variable finalString
    one at a time and passes them to the when block as letter. Next, we conduct a
    series of tests until a match is found with one of the possible L-system codes.
    Based on the match, we call the related Turtle method to draw or move on the canvas.
    For example, we match characters F and G to the lineTo() method and J to the moveTo()
    method. Notice that different method calls require different parameters, and the
    last three calls inside the when block don’t require any! We’ll see what happens
    when those methods are called next.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在一个优雅的for循环 ❶和一个简洁的when块 ❷中实现绘图过程，这比传统的多层if...else块要简洁得多。for循环逐个扫描变量finalString中的字符，并将它们作为字母传递给when块。接下来，我们进行一系列测试，直到找到与某个L系统代码匹配的字符。根据匹配结果，我们调用相关的Turtle方法来绘制或在画布上移动。例如，我们将字符F和G匹配到lineTo()方法，将J匹配到moveTo()方法。请注意，不同的函数调用需要不同的参数，when块中的最后三个调用不需要任何参数！接下来我们将看到当这些方法被调用时会发生什么。
- en: The Turtle Class and Its Methods
  id: totrans-170
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: Turtle类及其方法
- en: 'Now we’ll implement our Turtle class, where all the methods for carrying out
    the final drawing live. To keep the main body of our L-system application short
    and tidy, we’ll declare this class in a separate file called *Turtle.kt*. We begin
    the file here:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将实现我们的Turtle类，其中包含了执行最终绘图的所有方法。为了保持我们的L系统应用的主体部分简洁明了，我们将在一个名为*Turtle.kt*的单独文件中声明这个类。我们从这里开始编写文件：
- en: '[PRE15]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'The import block gives us access to the required JavaFX and Kotlin library
    components. The primary class constructor, which is part of the class header ❶,
    creates an instance of the Turtle class using three values: the turtle’s starting
    x- and y-coordinates and its initial orientation (angle of the turtle). We set
    the first two parameters as var because their values will be updated each time
    the turtle moves or changes its direction. We keep the third parameter angle as
    val (not explicitly declared but implied), which is used to define a mutable property,
    angleRad.'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 导入块让我们能够访问所需的JavaFX和Kotlin库组件。主类构造函数是类头部的一部分 ❶，它使用三个值创建一个Turtle类的实例：海龟的起始x和y坐标以及其初始方向（海龟的角度）。我们将前两个参数设置为var，因为每次海龟移动或改变方向时，这些值都会更新。我们将第三个参数angle设置为val（没有显式声明，但已暗示），它用于定义一个可变的属性angleRad。
- en: The rest of the class body defines the seven different methods that can be called
    to perform different Turtle object tasks. See [Table 6-3](chapter6.xhtml#tab6-3)
    for a summary of these methods and their corresponding L-system characters.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 类的其余部分定义了七个不同的方法，可以调用它们来执行不同的Turtle对象任务。请参见[表6-3](chapter6.xhtml#tab6-3)以了解这些方法及其对应的L系统字符的概述。
- en: '[PRE16]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The lineTo() method is the only one that actually draws anything on the canvas.
    It draws a straight line of length line, based on the same sine and cosine calculations
    we used to draw segments of the fractal tree in [Project 24](chapter6.xhtml#pre-24).
    All the other methods either move the turtle without drawing a line, change its
    direction, or save or restore its state. The final method simply prints the current
    state of the turtle, which is useful for debugging purposes.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: '`lineTo()`方法是唯一一个真正在画布上绘制内容的方法。它基于我们在[项目24](chapter6.xhtml#pre-24)中绘制分形树段时使用的相同正弦和余弦计算，绘制一个长度为`line`的直线。所有其他方法要么是在不绘制线条的情况下移动海龟，要么改变海龟的方向，或保存或恢复海龟的状态。最终的方法只是打印海龟的当前状态，这对于调试非常有用。'
- en: The push() and pop() methods rely on methods of the ArrayDeque class, which
    we used to implement our stack. The push() method calls the addLast() function,
    while pop() calls the removeLast() function to add or remove an item to the end
    of the stack array, enforcing the LIFO rule. In both cases, we encapsulate the
    state information by using our custom State data class.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: '`push()`和`pop()`方法依赖于`ArrayDeque`类的方法，我们使用它来实现栈。`push()`方法调用`addLast()`函数，而`pop()`调用`removeLast()`函数，将项添加或移除栈数组的末尾，从而遵循LIFO规则。在这两种情况下，我们通过使用自定义的`State`数据类来封装状态信息。'
- en: The LSystemApp Class
  id: totrans-178
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: LSystemApp类
- en: Finally, we’ll bring the different components of the L-system simulator together
    to form a complete application, organized around an LSystemApp class. The following
    listing shows the full body of this class, as well as the main() function. The
    listing also shows where all the other components we discussed earlier fit (except
    for the Turtle class, which is in a separate file).
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将L系统模拟器的不同组件整合在一起，形成一个完整的应用程序，该程序围绕一个LSystemApp类组织。下面的代码展示了这个类的完整代码以及`main()`函数。代码还显示了我们之前讨论的所有其他组件如何融入其中（Turtle类除外，它在一个单独的文件中）。
- en: '[PRE17]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Other than the generate() and draw() functions, much of the LSystemApp consists
    of the boilerplate JavaFX code. What’s different this time is the addition of
    a couple of extra lines that relocate the origin of the canvas to the bottom-left
    corner ❶ and let the positive direction of the y-axis point upward ❷. These simple
    changes make testing previously published L-systems that provide axioms, rules,
    and initial conditions for many well-known fractals very convenient. Published
    L-system parameters are almost always based on the assumption that we draw the
    resulting fractals in the first quadrant of the coordinate system.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 除了`generate()`和`draw()`函数，LSystemApp的大部分代码都包含了常规的JavaFX代码。与以往不同的是，这次添加了几行额外的代码，将画布的原点移到左下角
    ❶，并让y轴的正方向指向上方 ❷。这些简单的修改使得测试之前发布的L系统变得非常方便，这些L系统提供了许多著名分形的公理、规则和初始条件。已发布的L系统参数几乎总是基于我们在坐标系的第一象限绘制分形的假设。
- en: The code managing the L-system revolves around an if block that checks if depth
    is greater than 0 ❸. If not, we simply draw the axiom itself, without applying
    any rules. Otherwise, we call the generate() function depth times to apply the
    rules over the appropriate number of iterations. We then use the final content
    of finalString to draw the fractal. Notice that we set the length of the lines
    to be drawn based on depth ❹. This dynamic adjustment allows us to keep the size
    of the fractal limited to the size of the canvas. If you prefer to use a larger
    or smaller canvas size (we’re using 600×600), you may have to adjust the initial
    line length, as well as the initial position of the turtle.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 管理L系统的代码围绕着一个if块展开，检查深度是否大于0 ❸。如果不是，我们只需绘制公理本身，而不应用任何规则。否则，我们调用`generate()`函数深度次，进行适当次数的迭代应用规则。然后，我们使用`finalString`的最终内容来绘制分形。请注意，我们根据深度
    ❹ 设置了绘制线条的长度。这种动态调整使得我们能够将分形的大小限制在画布的大小范围内。如果你希望使用更大或更小的画布大小（我们使用的是600×600），你可能需要调整初始线条长度以及海龟的初始位置。
- en: The Result
  id: totrans-183
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 结果
- en: We’re now ready to put our brand-new L-system simulator to the test. Since we’ve
    already included problem-specific parameters for a snowflake fractal, we can run
    the simulator with different depths to see how the image gets more complex and
    manifests self-similar patterns as the depth increases. [Figure 6-10](chapter6.xhtml#fig6-10)
    shows the evolution of the snowflake for depths 1, 3, and 5.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在准备好测试我们全新的L系统模拟器了。由于我们已经为雪花分形包含了特定问题的参数，我们可以使用不同的深度运行模拟器，看看随着深度增加，图像如何变得更加复杂，并呈现自相似的图案。[图6-10](chapter6.xhtml#fig6-10)展示了深度为1、3和5时雪花的演变过程。
- en: '![](../images/Figure6-10.jpg)'
  id: totrans-185
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/Figure6-10.jpg)'
- en: 'Figure 6-10: The evolution of a snowflake, using the L-system simulator'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 图6-10：使用L系统模拟器生成的雪花演化过程
- en: Researchers have developed so many interesting L-systems over the years that
    you could spend days playing with those systems in your simulator and looking
    at the intriguing patterns they generate. For example, [Table 6-4](chapter6.xhtml#tab6-4)
    lists the L-system parameters necessary for creating three more fractals with
    different features. Some of these incorporate a wider range of symbols, and they
    all involve multiple rules.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 多年来，研究人员已经开发出许多有趣的L系统，你可以花上好几天的时间在模拟器中玩这些系统，并观察它们生成的迷人图案。例如，[表6-4](chapter6.xhtml#tab6-4)列出了创建三种具有不同特征的分形所需的L系统参数。这些系统有些包含了更广泛的符号范围，而且它们都涉及多个规则。
- en: 'Table 6-4: Additional L-System Examples'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 表6-4：其他L系统示例
- en: '| Property | Fractal name |'
  id: totrans-189
  prefs: []
  type: TYPE_TB
  zh: '| 属性 | 分形名称 |'
- en: '| --- | --- |'
  id: totrans-190
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| Sierpiński triangle | Pattern with rectangles | Fractal plant |'
  id: totrans-191
  prefs: []
  type: TYPE_TB
  zh: '| 锡尔皮ński三角形 | 带矩形的图案 | 分形植物 |'
- en: '| --- | --- | --- |'
  id: totrans-192
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| Axiom | F+G+G | F-F-F-F | X |'
  id: totrans-193
  prefs: []
  type: TYPE_TB
  zh: '| 公理 | F+G+G | F-F-F-F | X |'
- en: '| Rules | F -> F+G-F-G+F G -> GG | F -> F-J+FF-F-FF-FJ-FF+J-FF+F+FF+FJ+FFF
    J -> JJJJJJ | X -> F+[[X]-X]-F[-FX]+X F -> FF |'
  id: totrans-194
  prefs: []
  type: TYPE_TB
  zh: '| 规则 | F -> F+G-F-G+F G -> GG | F -> F-J+FF-F-FF-FJ-FF+J-FF+F+FF+FJ+FFF J ->
    JJJJJJ | X -> F+[[X]-X]-F[-FX]+X F -> FF |'
- en: '| Line | +150.0 | +15.0 | +20.0 |'
  id: totrans-195
  prefs: []
  type: TYPE_TB
  zh: '| 线段 | +150.0 | +15.0 | +20.0 |'
- en: '| Scaling | 0.5 | 0.5 | 0.7 |'
  id: totrans-196
  prefs: []
  type: TYPE_TB
  zh: '| 缩放 | 0.5 | 0.5 | 0.7 |'
- en: '| Angle | 120 | 90 | 25 |'
  id: totrans-197
  prefs: []
  type: TYPE_TB
  zh: '| 角度 | 120 | 90 | 25 |'
- en: '| Depth | 6 | 2 | 6 |'
  id: totrans-198
  prefs: []
  type: TYPE_TB
  zh: '| 深度 | 6 | 2 | 6 |'
- en: '| Turtle | 150.0, 200.0, 0.0 | 150.0, 450.0, 0.0 | 100.0, 50.0, 65.0 |'
  id: totrans-199
  prefs: []
  type: TYPE_TB
  zh: '| 海龟 | 150.0, 200.0, 0.0 | 150.0, 450.0, 0.0 | 100.0, 50.0, 65.0 |'
- en: '| Canvas | 600.0×600.0 | 600.0×600.0 | 600.0×600.0 |'
  id: totrans-200
  prefs: []
  type: TYPE_TB
  zh: '| 画布 | 600.0×600.0 | 600.0×600.0 | 600.0×600.0 |'
- en: The first set of parameters in [Table 6-4](chapter6.xhtml#tab6-4) will create
    the familiar Sierpiński triangle. The second set, with a depth of only two, is
    for a geometric pattern that involves drawing multiple unconnected rectangles
    (see [Figure 6-11](chapter6.xhtml#fig6-11), left). The third set is for a fractal
    plant, a popular object among fractal enthusiasts (see [Figure 6-11](chapter6.xhtml#fig6-11),
    right). It involves a number of push and pull operations ([and]) to keep track
    of the plant’s various branches.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: '[表6-4](chapter6.xhtml#tab6-4)中的第一组参数将创建熟悉的锡尔皮ński三角形。第二组参数，深度仅为二，用于绘制涉及多个不相连矩形的几何图案（见[图6-11](chapter6.xhtml#fig6-11)，左）。第三组参数用于创建分形植物，这是分形爱好者中很受欢迎的一种对象（见[图6-11](chapter6.xhtml#fig6-11)，右）。它涉及多个推拉操作（[和]），以跟踪植物的不同分支。'
- en: '![](../images/Figure6-11.jpg)'
  id: totrans-202
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/Figure6-11.jpg)'
- en: 'Figure 6-11: A rectangular pattern (left) and a fractal plant (right) generated
    by the L-system simulator'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 图6-11：由L系统模拟器生成的矩形图案（左）和分形植物（右）
- en: You can extend the basic L-system simulator we’ve developed in this section
    to generate 3D fractals, such as a space-filling Hilbert curve. Check out the
    resources listed at the end of this chapter to learn more about those advanced
    implementations. The primary benefit of the L-system simulator, however, is that
    it allows you to experiment with your own axioms and rules. Perhaps you’ll come
    up with a brand-new fractal that no one has seen before and name it after yourself!
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以扩展我们在本节中开发的基本L系统模拟器，以生成3D分形，例如空间填充的希尔伯特曲线。请查看本章末尾列出的资源，了解更多关于这些高级实现的内容。然而，L系统模拟器的主要好处在于，它允许你自己尝试不同的公理和规则。也许你会创造出一个前所未见的全新分形，并以自己的名字命名！
- en: The Mighty Mandelbrot Set
  id: totrans-205
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 强大的曼德尔布罗特集
- en: No discussion of fractals would be complete without examining the Mandelbrot
    set, or M-set, and appreciating its complexity and beauty. The M-set differs from
    the other fractals we’ve discussed so far in two important ways. First, it’s a
    nonlinear fractal, meaning its building blocks are made up of pixels organized
    in complex patterns instead of only straight lines. Second, it’s mapped on a complex
    plane, so it requires us to use complex numbers.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 讨论分形时，若不研究曼德尔布罗特集（M集），并欣赏其复杂性与美丽，将是不完整的。M集与我们迄今为止讨论的其他分形有两个重要区别。首先，它是一个非线性分形，意味着它的构建块由像素组成，呈现复杂的图案，而不仅仅是直线。其次，它映射在复平面上，因此我们需要使用复数。
- en: The M-set hinges on the iterative properties of the deceptively simple quadratic
    function, shown in Equation 6.1.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: M集依赖于表面看似简单的二次函数的迭代特性，如方程6.1所示。
- en: $Equation$ (6.1) ![](../images/eq6-1.jpg)
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: $方程$ (6.1) ![](../images/eq6-1.jpg)
- en: Here *c* is a constant. By “iterative properties,” I mean the way the value
    of *f*(*z*) changes if we start with some initial seed value for *z* and then
    recursively feed the value of the equation back into itself as the new *z* value.
    Equation 6.2 shows the recursive form of this function.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 这里 *c* 是常数。所谓“迭代性质”，是指如果我们从某个初始种子值 *z* 开始，并递归地将方程的值反馈到自己作为新的 *z* 值，*f*(*z*)
    的值将如何变化。方程式 6.2 显示了该函数的递归形式。
- en: $Equation$ (6.2) ![](../images/eq6-2.jpg)
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: $方程式$ (6.2) ![](../images/eq6-2.jpg)
- en: The list of numbers generated by repeated iterations of Equation 6.2, given
    a particular seed value *z*[0] and constant *c*, is known as the *orbit* of the
    function. [Table 6-5](chapter6.xhtml#tab6-5) shows the orbits for a few different
    (*z*[0], *c*) combinations.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 由方程 6.2 通过重复迭代生成的数字列表，给定特定的初始种子值 *z*[0] 和常数 *c*，称为该函数的 *轨迹*。 [表 6-5](chapter6.xhtml#tab6-5)
    展示了不同 (*z*[0], *c*) 组合的轨迹。
- en: 'Table 6-5: Selected Orbits of Quadratic Function f(z) = z2 + c'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: '表 6-5: 二次函数 f(z) = z² + c 的选定轨迹'
- en: '| n (iteration) | Case 1: z0 = 0, c = 1 | Case 2: z0 = 0, c = –1 | Case 3:
    z0 = 0, c = –0.65 |'
  id: totrans-213
  prefs: []
  type: TYPE_TB
  zh: '| n (迭代次数) | 情况 1: z0 = 0, c = 1 | 情况 2: z0 = 0, c = –1 | 情况 3: z0 = 0, c =
    –0.65 |'
- en: '| --- | --- | --- | --- |'
  id: totrans-214
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- |'
- en: '| 1 | 1 | –1 | –0.65 |'
  id: totrans-215
  prefs: []
  type: TYPE_TB
  zh: '| 1 | 1 | –1 | –0.65 |'
- en: '| 2 | 2 | 0 | –0.22749999 |'
  id: totrans-216
  prefs: []
  type: TYPE_TB
  zh: '| 2 | 2 | 0 | –0.22749999 |'
- en: '| 3 | 5 | –1 | –0.59824375 |'
  id: totrans-217
  prefs: []
  type: TYPE_TB
  zh: '| 3 | 5 | –1 | –0.59824375 |'
- en: '| 4 | 26 | 0 | –0.29210441 |'
  id: totrans-218
  prefs: []
  type: TYPE_TB
  zh: '| 4 | 26 | 0 | –0.29210441 |'
- en: '| 5 | 677 | –1 | –0.56467501 |'
  id: totrans-219
  prefs: []
  type: TYPE_TB
  zh: '| 5 | 677 | –1 | –0.56467501 |'
- en: '| 6 | 458,330 | 0 | –0.33114213 |'
  id: totrans-220
  prefs: []
  type: TYPE_TB
  zh: '| 6 | 458,330 | 0 | –0.33114213 |'
- en: '| 7 | Very large number! | –1 | –0.54034488 |'
  id: totrans-221
  prefs: []
  type: TYPE_TB
  zh: '| 7 | 非常大的数字！ | –1 | –0.54034488 |'
- en: 'Each case in [Table 6-5](chapter6.xhtml#tab6-5) uses a seed value of 0 but
    a different constant. Notice how minor variations in the value of the constant
    can set the orbit off on a completely different path. In general, the orbit will
    either diverge, meaning the function values will become increasingly large due
    to exponential growth (as in case 1), or remain bounded, such that the orbit values
    stay within a certain range. If the latter, several variations are possible:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: '[表 6-5](chapter6.xhtml#tab6-5) 中的每个情况都使用了初始值 0，但常数不同。请注意，常数值的微小变化可能会使轨迹进入完全不同的路径。一般来说，轨迹要么会发散，这意味着由于指数增长，函数值会变得越来越大（如情况
    1 中所示），要么保持有界，使轨迹值保持在一定范围内。如果是后者，则可能会有几种变化：'
- en: The orbit cycles through a fixed set of values (as in case 2, where the cycle
    has a period of 2).
  id: totrans-223
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 轨迹会循环经过一组固定的值（如情况 2，其中周期为 2）。
- en: The orbit converges toward a fixed value; in case 3, the function value converges
    to –0.4486 after approximately 100 iterations.
  id: totrans-224
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 轨迹会收敛到一个固定值；在情况 3 中，函数值经过大约 100 次迭代后收敛到 –0.4486。
- en: The orbit remains fixed on a single value (for example, when z[0] = 0 and c
    = 0).
  id: totrans-225
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 轨迹会保持在一个固定值上（例如，当 z[0] = 0 且 c = 0 时）。
- en: The orbit values remain bounded but behave chaotically, showing no apparent
    pattern.
  id: totrans-226
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 轨迹值保持有界，但表现出混沌行为，没有明显的模式。
- en: 'All this hidden complexity is governed by the constant *c* as it takes on different
    values. So far, however, we’ve used only real numbers as values of *c*. It’s time
    to introduce complex numbers into the mix—values of *c* that satisfy this equation:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些隐藏的复杂性都由常数 *c* 控制，因为它取不同的值。然而，到目前为止，我们仅使用了实数作为 *c* 的值。现在是时候引入复数——满足以下方程式的
    *c* 值：
- en: $Equation$ (6.3) ![](../images/eq6-3.jpg)
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: $方程式$ (6.3) ![](../images/eq6-3.jpg)
- en: Here *x* and *y* are real numbers, and *i* is √–1\. [Table 6-6](chapter6.xhtml#tab6-6)
    shows a few examples of our quadratic function using complex values of *c*.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 这里 *x* 和 *y* 是实数，*i* 是 √–1。 [表 6-6](chapter6.xhtml#tab6-6) 展示了使用复数 *c* 值的二次函数的一些例子。
- en: 'Table 6-6: Selected Orbits of Quadratic Function f(z) = z2 + c, Where c = x
    + iy'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: '表 6-6: 二次函数 f(z) = z² + c 的选定轨迹，其中 c = x + iy'
- en: '| n (iteration) | Case 1: z0 = 0, c = 0 + i | Case 2: z0 = 0, c = 0 + 2i |'
  id: totrans-231
  prefs: []
  type: TYPE_TB
  zh: '| n (迭代次数) | 情况 1: z0 = 0, c = 0 + i | 情况 2: z0 = 0, c = 0 + 2i |'
- en: '| --- | --- | --- |'
  id: totrans-232
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| 1 | i | 2i |'
  id: totrans-233
  prefs: []
  type: TYPE_TB
  zh: '| 1 | i | 2i |'
- en: '| 2 | –1 + i | –4 + 2i |'
  id: totrans-234
  prefs: []
  type: TYPE_TB
  zh: '| 2 | –1 + i | –4 + 2i |'
- en: '| 3 | –i | 12 – 14i |'
  id: totrans-235
  prefs: []
  type: TYPE_TB
  zh: '| 3 | –i | 12 – 14i |'
- en: '| 4 | –1 + i | –52 – 334i |'
  id: totrans-236
  prefs: []
  type: TYPE_TB
  zh: '| 4 | –1 + i | –52 – 334i |'
- en: '| 5 | –i | –108,852 + 34,738i |'
  id: totrans-237
  prefs: []
  type: TYPE_TB
  zh: '| 5 | –i | –108,852 + 34,738i |'
- en: '| 6 | –1 + i | Far away from (0, 0) |'
  id: totrans-238
  prefs: []
  type: TYPE_TB
  zh: '| 6 | –1 + i | 离 (0, 0) 很远 |'
- en: '| 7 | –i | Very far away from (0, 0) |'
  id: totrans-239
  prefs: []
  type: TYPE_TB
  zh: '| 7 | –i | 离 (0, 0) 非常远 |'
- en: '| M-set membership | Member | Nonmember |'
  id: totrans-240
  prefs: []
  type: TYPE_TB
  zh: '| M 集合成员 | 成员 | 非成员 |'
- en: 'As with real values of *c*, complex values also produce two types of orbits:
    bounded (like case 1) or unbounded (like case 2). Given this, we’re now ready
    to define the Mandelbrot set as the set of all complex numbers *c* for which the
    corresponding orbit generated by recursive function *f*(*z*) = *z*² + *c* remains
    bounded, given a seed of *z*[0] = 0\. Thus, looking at [Table 6-6](chapter6.xhtml#tab6-6),
    *c* = 0 + *i* is a member of the Mandelbrot set, while *c* = 0 + 2*i* is not.'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 与实数*c*的情况类似，复数值也会产生两种类型的轨道：有界（如情况1）或无界（如情况2）。因此，我们现在可以定义曼德尔布罗集：对于所有复数*c*，如果由递归函数*f*（*z*）=
    *z*² + *c*生成的相应轨道在给定种子*z*[0] = 0的情况下保持有界，则该复数*c*属于曼德尔布罗集。因此，查看[表6-6](chapter6.xhtml#tab6-6)，*c*
    = 0 + *i* 是曼德尔布罗集的成员，而*c* = 0 + 2*i* 不是。
- en: 'We visualize the Mandelbrot set by plotting the set’s members on a *complex
    plane*, a coordinate system where the x-axis represents the real component of
    a complex number (*x* in Equation 6.3) and the y-axis represents the imaginary
    component (*y* in Equation 6.3). Given these x- and y-values, the magnitude of
    the orbit of a complex number is calculated as:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过在*复平面*上绘制曼德尔布罗集的成员来可视化这个集合，复平面是一个坐标系，其中 x 轴表示复数的实部（方程6.3中的*x*），y 轴表示复数的虚部（方程6.3中的*y*）。根据这些
    x 和 y 值，可以计算复数轨道的大小，如下所示：
- en: $Equation$ (6.4) ![](../images/eq6-4.jpg)
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: $方程$ (6.4) ![](../images/eq6-4.jpg)
- en: When a complex number is plotted as a point on the complex plane, the magnitude
    of the orbit would be the distance of that point from the origin.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 当复数作为点绘制在复平面上时，轨道的大小就是该点与原点之间的距离。
- en: 'Project 26: Code and Visualize the Mandelbrot Set'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 项目26：编写代码并可视化曼德尔布罗集
- en: 'Let’s turn our attention to creating an app that will help us visualize the
    M-set. Our definition of the M-set provides some clues about what’s required:
    we need to find and plot the complex values of *c* that cause our quadratic function
    (Equation 6.1) to remain bounded as it iterates. However, we still need a few
    clarifications. First, what region of the complex plane should we investigate?
    It would help to know if the M-set members are clustered in a certain region or
    dispersed over a large area. Also, since the quadratic function can continue iterating
    ad infinitum, it isn’t clear when exactly we should conclude that an orbit is
    bounded or unbounded. We could limit ourselves to a certain number of iterations,
    consult the magnitude of the orbit as defined by Equation 6.4, or both.'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们将注意力转向创建一个应用程序，帮助我们可视化曼德尔布罗集。我们对曼德尔布罗集的定义提供了关于所需内容的一些线索：我们需要找到并绘制使得二次函数（方程6.1）在迭代过程中保持有界的复数*c*值。然而，我们仍然需要一些澄清。首先，我们应该调查复平面的哪个区域？了解曼德尔布罗集的成员是否集中在某个特定区域，还是分布在一个较大的区域会有所帮助。另外，由于二次函数可以无限迭代，因此并不清楚我们应该何时得出轨道是有界的或无界的结论。我们可以限制迭代次数，或者根据方程6.4定义的轨道大小来判断，或者两者兼顾。
- en: Fortunately, researchers have already uncovered helpful facts about the M-set
    that we can draw on to make our search efficient and practical. First, from numerous
    plots of the M-set already created, we know that the search space can be limited
    to an area bounded by [–2.0, 1.0] along the real axis (x-axis) and [–1.5, 1.5]
    along the imaginary axis (y-axis). Second, it’s also known that the M-set is a
    closed set entirely contained inside a circle of radius 2 around the origin. This
    means that a complex number *c* can’t be a member of the set if |*z*n| > 2 for
    any *n* > 0\. We’ll use this as a termination condition for the bounded/unbounded
    test. Otherwise, if we complete some threshold number of iterations (iterMax)
    without |*z*n| exceeding 2, we’ll consider *c* to be a member of the M-set.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，研究人员已经揭示了一些关于曼德尔布罗集的有用事实，我们可以利用这些信息使我们的搜索更加高效和实用。首先，从已经创建的多个曼德尔布罗集图形中，我们知道搜索空间可以限制在一个由实轴（x轴）上的[–2.0,
    1.0]和虚轴（y轴）上的[–1.5, 1.5]界定的区域内。其次，曼德尔布罗集也是一个封闭集合，完全包含在以原点为圆心、半径为2的圆内。这意味着，如果对于任何*n*
    > 0，|*z*n| > 2，那么复数*c*不能是该集合的成员。我们将把这个条件作为判断有界/无界的终止条件。否则，如果我们在迭代达到某个阈值（iterMax）之前没有发现|*z*n|超过2，我们将认为*c*是曼德尔布罗集的成员。
- en: We’ll set iterMax to 400 for a relatively clean image of the M-set, but I encourage
    you to experiment by setting iterMax lower or higher. In general, lower iterMax
    values will likely show more noise as well as various zones of convergence. As
    the number of iterations increases (the test condition becomes more stringent),
    the fractal boundary tends to become crisper.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将iterMax设置为400，以便获得相对干净的M集图像，但我鼓励你通过将iterMax设置得更低或更高来进行实验。通常，较低的iterMax值可能会显示更多的噪声以及各种收敛区域。随着迭代次数的增加（测试条件变得更严格），分形边界趋向于变得更加清晰。
- en: The Code
  id: totrans-249
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 代码
- en: 'Despite the sophisticated nature of the concept, the code for creating the
    M-set is relatively minimal. The app we’ll create will have the following features
    and functionalities:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管这个概念相当复杂，但生成M集的代码相对简洁。我们将创建的应用程序将具备以下功能和特性：
- en: The problem definition (done through a small number of global variables)
  id: totrans-251
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 问题定义（通过少量的全局变量完成）
- en: The ability to iterate over the search space point by point
  id: totrans-252
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 能够逐点遍历搜索空间
- en: The ability to check M-set membership conditions for each of those points
  id: totrans-253
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 能够检查每个点是否满足M集成员条件
- en: The ability to draw the point on the canvas with a chosen color scheme
  id: totrans-254
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 能够使用选择的颜色方案在画布上绘制点
- en: In addition, we’ll need to adjust the scale of the image to ensure that the
    search space is properly mapped onto a canvas of a given size.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们需要调整图像的缩放比例，以确保搜索空间正确映射到给定大小的画布上。
- en: Declaring Global Variables
  id: totrans-256
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 声明全局变量
- en: First, we’ll declare some global variables. This code segment defines the bounds
    for the real and imaginary axes, sets the canvas size, determines the search increment
    along the x- and y-axes, and limits the number of iterations for the quadratic
    function.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将声明一些全局变量。这段代码定义了实数轴和虚数轴的范围，设置了画布的大小，确定了x轴和y轴上的搜索增量，并限制了二次函数的迭代次数。
- en: '[PRE18]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: We set xMin and xMax as the lower and upper bounds for the real values of *c*;
    similarly, yMin and yMax are the lower and upper bounds for the imaginary part
    of *c*. The corresponding ranges (xRange and yRange) define a rectangular search
    space we’ll explore to find potential M-set members.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将xMin和xMax设置为*c*的实部的下限和上限；同样，yMin和yMax是*c*虚部的下限和上限。相应的范围（xRange和yRange）定义了一个矩形搜索空间，我们将探索这个空间以寻找潜在的M集成员。
- en: Next, we set the width of the canvas, canvasW, to 600 pixels and the height
    of the canvas, canvasH, to a value that will maintain the proportionality of the
    image (meaning that the M-set, when plotted, won’t look distorted). The benefit
    of this approach is that you only need to adjust canvasW if you want to create
    a larger or smaller image.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将画布的宽度canvasW设置为600像素，画布的高度canvasH设置为一个值，以保持图像的比例（这意味着绘制出的M集不会失真）。这种方法的好处是，如果你想创建一个更大或更小的图像，只需调整canvasW即可。
- en: We set the last two parameters, increment and iterMax, to 0.003 and 400, respectively.
    These values will determine the overall image quality. It’s possible to link the
    increment parameter to canvasW and have it automatically calculated—you’re welcome
    to try that out as a simple experiment.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将最后两个参数，增量和迭代最大值，分别设置为0.003和400。这些值将决定图像的整体质量。可以将增量参数与canvasW关联，并让它自动计算——欢迎作为一个简单的实验尝试一下。
- en: Finding and Drawing M-Set Members
  id: totrans-262
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 寻找并绘制M集成员
- en: We’ll now declare a function to iterate over the search space, check whether
    a particular complex number *c* is within the M-set, and mark the corresponding
    points on the canvas by using a color scheme.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在将声明一个函数，遍历搜索空间，检查某个特定的复数*c*是否属于M集，并使用颜色方案标记画布上的相应点。
- en: '[PRE19]'
  id: totrans-264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: The drawMSet() function uses a nested pair of while loops to iterate over the
    search space. The outer loop ❶ iterates along the y-axis, starting with the minimum
    y value, yMin, and ending when y reaches the upper bound, yMax, incrementing y
    by increment (which we set to 0.003) each time. The inner while loop ❷ does the
    same along the x-axis. With each iteration, we get an (*x, y*) pair representing
    a complex number (as defined by Equation 6.3), which we pass to the getConvergence()
    function ❸ to check if that number belongs to the M-set (we’ll look at that function
    next).
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: drawMSet()函数使用一对嵌套的while循环来遍历搜索空间。外层循环❶沿y轴迭代，从最小y值yMin开始，当y达到上限yMax时结束，每次增量y（我们设置为0.003）。内层while循环❷沿x轴进行相同的操作。每次迭代，我们得到一个(*x,
    y*)对，表示一个复数（如公式6.3所定义），我们将其传递给getConvergence()函数❸，以检查该复数是否属于M集（我们接下来会查看该函数）。
- en: Calling getConvergence() returns the number of iterations of the quadratic function
    it carried out. We divide this by iterMax to measure how quickly the convergence
    decision was made ❹. If this resulting value (speed) is 1, the number of iterations
    must have been iterMax, indicating that the orbit of *c* remained bounded. Therefore,
    we’ll count this particular complex number as a member of the M-set. If speed
    is less than 1, however, that would mean the orbit jumped outside the circle of
    radius 2 before reaching the maximum number of iterations, so we won’t consider
    that number to be an M-set member.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 调用 getConvergence() 返回它执行的二次函数的迭代次数。我们将此次数除以 iterMax 来衡量收敛决策的速度 ❹。如果该结果值（速度）为
    1，则迭代次数必定为 iterMax，表示 *c* 的轨道保持有界。因此，我们将此复数视为 M 集的成员。然而，如果速度小于 1，则表示轨道在达到最大迭代次数之前就跳出了半径为
    2 的圆，所以我们不会将该数字视为 M 集的成员。
- en: We subtract speed from 1 and use the result (factor) to set the color of the
    corresponding point on the canvas, according to a grayscale scheme where (1, 1,
    1) means white and (0, 0, 0) means black. If the orbit diverged very quickly,
    factor will be close to 1, so the point on the canvas representing this number
    will be marked with a white or nearly white pixel. Conversely, if the orbit diverged
    only after many more iterations (but before reaching the maximum allowed), factor
    will be closer to 0, so the corresponding point would be marked with a darker
    pixel. Of course, if the orbit remains bounded, factor will be exactly 0, and
    the corresponding point will be marked with a pure black pixel, signifying that
    the point belongs to the M-set.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从 1 中减去速度，并使用结果（因子）根据灰度方案设置画布上相应点的颜色，其中 (1, 1, 1) 代表白色，(0, 0, 0) 代表黑色。如果轨道非常快地发散，因子将接近
    1，因此表示该数字的画布上的点将标记为白色或接近白色的像素。相反，如果轨道只有在多次迭代后才发散（但在达到最大允许值之前），因子将更接近 0，因此对应的点将被标记为较暗的像素。当然，如果轨道保持有界，因子将恰好为
    0，且对应的点将被标记为纯黑色像素，表示该点属于 M 集。
- en: Finally, we plot the number by mapping its (*x*, *y*) coordinate pair onto a
    pixel location on the canvas ❺, using the scaling factor illustrated in [Figure
    6-12](chapter6.xhtml#fig6-12).
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们通过将数字的 (*x*, *y*) 坐标对映射到画布上的像素位置 ❺，使用在[图 6-12](chapter6.xhtml#fig6-12)中说明的缩放因子进行绘制。
- en: '![](../images/Figure6-12.jpg)'
  id: totrans-269
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/Figure6-12.jpg)'
- en: 'Figure 6-12: Mapping the x-coordinate of c to the x-value of the pixel on the
    canvas'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6-12：将 c 的 x 坐标映射到画布上像素的 x 值
- en: We’re using the proportionality rule to map the x-coordinate to a point on the
    canvas designated as *w*. We apply the same principle to the y-coordinate as well.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用比例规则将 x 坐标映射到画布上指定为 *w* 的点。我们也对 y 坐标应用相同的原理。
- en: Checking for Convergence
  id: totrans-272
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 检查收敛性
- en: The getConvergence() function takes in an (*x*, *y*) pair as arguments and checks
    if the corresponding complex number belongs to the M-set.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: getConvergence() 函数接受一个 (*x*, *y*) 坐标对作为参数，并检查对应的复数是否属于 M 集。
- en: '[PRE20]'
  id: totrans-274
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'To follow the logic of the code, we need a bit of algebra. Recall from Equation
    6.2 that the recursive form of our quadratic function is *z*n = *z*²n [– 1] +
    *c*. For any value of *n* > 1, *z*n [– 1] will be a complex number that can be
    expressed as:'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 为了遵循代码的逻辑，我们需要进行一些代数运算。回想方程 6.2，我们的二次函数的递归形式是 *z*n = *z*²n [– 1] + *c*。对于任何
    n > 1 的值，*z*n [– 1] 都是一个复数，可以表示为：
- en: $Equation$ (6.5) ![](../images/eq6-5.jpg)
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: $Equation$ (6.5) ![](../images/eq6-5.jpg)
- en: 'In Equation 6.5, *zx*n [– 1] is the real part of *z*n [– 1], and *zy*n [– 1]
    is the complex part. We can now rewrite Equation 6.2 by using Equations 6.3 and
    6.5\. After simplification, we get:'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 在方程 6.5 中，*zx*n [– 1] 是 *z*n [– 1] 的实部，*zy*n [– 1] 是虚部。现在我们可以使用方程 6.3 和 6.5
    重写方程 6.2。经过简化后，我们得到：
- en: $Equation$ (6.6) ![](../images/eq6-6.jpg)
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: $Equation$ (6.6) ![](../images/eq6-6.jpg)
- en: 'Equation 6.6 can be further simplified as:'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 方程 6.6 可以进一步简化为：
- en: $Equation$ (6.7) ![](../images/eq6-7.jpg)
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: $Equation$ (6.7) ![](../images/eq6-7.jpg)
- en: where *X* = (*zx*²n [– 1] – *zy*²n [– 1] + *x*) and *Y* = (2*zx*n [– 1] *zy*n
    [– 1] + *y*).
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 其中 *X* = (*zx*²n [– 1] – *zy*²n [– 1] + *x*) 和 *Y* = (2*zx*n [– 1] *zy*n [–
    1] + *y*)。
- en: 'Thinking back to Equation 6.4, we check if the magnitude of *z*n lies outside
    a circle of radius 2 by confirming whether:'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 回想方程 6.4，我们通过确认 *z*n 的模是否超出了半径为 2 的圆来检查：
- en: $Equation$ (6.8) ![](../images/eq6-8.jpg)
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: $Equation$ (6.8) ![](../images/eq6-8.jpg)
- en: Returning to our code, we start by setting real and imaginary components zx
    and zy to 0, the equivalent of setting seed value *z*[0] to 0\. Next, the for
    loop ❶ iterates over Equation 6.7, calculating the values of X and Y. With each
    iteration, we check if the magnitude of *z*n exceeds 2 ❷, per Equation 6.8\. If
    so, the complex number *c* represented by the (*x*, *y*) pair isn’t a member of
    the M-set, and we return the number of iterations it took to reach that conclusion.
    Otherwise, the iteration continues until we reach iterMax. If *z*n remains bounded
    the whole time, we return iterMax to indicate that the number is a member of the
    M-set.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 回到我们的代码，我们首先将实部和虚部zx和zy设为0，相当于将种子值*z*[0]设为0。接下来，for循环❶遍历方程6.7，计算X和Y的值。每次迭代时，我们检查*z*n的模是否超过2❷，按照方程6.8。如果超过了，那么表示由(*x*,
    *y*)组成的复数*c*不是M集的成员，我们返回达到该结论所需的迭代次数。否则，迭代继续，直到达到iterMax。如果*z*n始终保持有界，我们返回iterMax，表示该数是M集的成员。
- en: Bringing Everything Together
  id: totrans-285
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 整合一切
- en: Let’s take a look at how all these code segments fit together.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看一下这些代码段如何结合在一起。
- en: '[PRE21]'
  id: totrans-287
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Other than our global declarations and our two function definitions, the only
    other problem-specific code is a single call to drawMSet() to create and draw
    a fractal. It’s remarkable that despite the M-set’s complexity, only a few lines
    of code are required to generate the fractal.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 除了我们的全局声明和两个函数定义外，唯一与问题相关的代码就是调用一次drawMSet()来创建和绘制分形。令人惊讶的是，尽管M集的复杂性，生成分形所需的代码行数却很少。
- en: The Result
  id: totrans-289
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 结果
- en: Let’s use our app to explore the Mandelbrot set, which remains one of the most
    enigmatic mathematical objects ever discovered. Given the parameter values we
    used in “Declaring Global Variables” on [page 255](#pg_255), [Figure 6-13](chapter6.xhtml#fig6-13)
    shows the core M-set (the dark region) and some of its features.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用我们的应用程序来探索曼德博集合，这仍然是有史以来最神秘的数学对象之一。根据我们在“声明全局变量”一节中使用的参数值，参见[第255页](#pg_255)，[图6-13](chapter6.xhtml#fig6-13)显示了M集的核心部分（黑色区域）及其一些特征。
- en: '![](../images/Figure6-13.jpg)'
  id: totrans-291
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/Figure6-13.jpg)'
- en: 'Figure 6-13: The Mandelbrot set'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 图6-13：曼德博集合
- en: The central, heart-shaped part of the M-set is called the *cardioid*. The circular
    part to the left of the cardioid is called the main *bulb*. It’s a circle centered
    at (–1.0, 0.0), with a radius of 0.25\. Numerous other bulbs are attached to the
    main bulb and the cardioid all around their boundaries, and those bulbs seem to
    have antennas or tentacles. When we zoom in on them, we notice intricate patterns
    and even smaller cardioid-like features with their own bulbs and tentacles. In
    other words, some features of the M-set are replicated again and again, no matter
    how small the scale is (even though the replication is not exact)—a defining feature
    of any fractal.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: M集的中心部分是心形的，称为*心脏形*。心脏形左侧的圆形部分称为主*球体*。它是一个圆，中心位于（–1.0, 0.0），半径为0.25。许多其他小球连接在主球体和心脏形的边界周围，这些小球看起来像是有天线或触手。当我们放大它们时，我们会看到复杂的图案，甚至更小的心脏形特征，带有自己的小球和触手。换句话说，M集的一些特征会不断重复，无论尺度多小（尽管复制并不完全精确）——这是所有分形的标志性特征。
- en: The finer patterns, visible after sufficient magnification, aren’t simple geometric
    shapes; instead, they’re beautifully intricate and detailed in nature. [Figure
    6-14](chapter6.xhtml#fig6-14) shows magnified versions of two specific regions
    of interest, the *seahorse valley* and the *elephant valley*, as identified in
    [Figure 6-13](chapter6.xhtml#fig6-13).
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 放大后可见的细致图案并非简单的几何形状；相反，它们在自然界中是精美而复杂的。[图6-14](chapter6.xhtml#fig6-14)显示了两个特定兴趣区域的放大图，分别是*海马谷*和*大象谷*，如[图6-13](chapter6.xhtml#fig6-13)中所标出。
- en: '![](../images/Figure6-14.jpg)'
  id: totrans-295
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/Figure6-14.jpg)'
- en: 'Figure 6-14: The seahorse valley (left) and the elephant valley (right)'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 图6-14：海马谷（左）和大象谷（右）
- en: You can generate both of these figures by changing the search region and using
    appropriate parameter values in your app, as summarized in [Table 6-7](chapter6.xhtml#tab6-7).
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过改变搜索区域并在应用程序中使用适当的参数值来生成这两种图形，具体见[表6-7](chapter6.xhtml#tab6-7)。
- en: 'Table 6-7: Search Region and Parameter Values for Select Regions of the M-set'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 表6-7：M集某些区域的搜索区域和参数值
- en: '| Parameter | Seahorse valley | Elephant valley |'
  id: totrans-299
  prefs: []
  type: TYPE_TB
  zh: '| 参数 | 海马谷 | 大象谷 |'
- en: '| --- | --- | --- |'
  id: totrans-300
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| xMin | -0.8 | 0.275 |'
  id: totrans-301
  prefs: []
  type: TYPE_TB
  zh: '| xMin | -0.8 | 0.275 |'
- en: '| xMax | -0.7 | 0.325 |'
  id: totrans-302
  prefs: []
  type: TYPE_TB
  zh: '| xMax | -0.7 | 0.325 |'
- en: '| yMin | -0.2 | -0.05 |'
  id: totrans-303
  prefs: []
  type: TYPE_TB
  zh: '| yMin | -0.2 | -0.05 |'
- en: '| yMax | -0.1 | 0.0 |'
  id: totrans-304
  prefs: []
  type: TYPE_TB
  zh: '| yMax | -0.1 | 0.0 |'
- en: '| canvasW | 600 | 600 |'
  id: totrans-305
  prefs: []
  type: TYPE_TB
  zh: '| canvasW | 600 | 600 |'
- en: '| increment | 0.0001 | 0.00005 |'
  id: totrans-306
  prefs: []
  type: TYPE_TB
  zh: '| increment | 0.0001 | 0.00005 |'
- en: '| iterMax | 200 | 200 |'
  id: totrans-307
  prefs: []
  type: TYPE_TB
  zh: '| iterMax | 200 | 200 |'
- en: Enjoy exploring the M-set by using these parameters, or come up with your own
    parameter values and see what other features you can find.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用这些参数，享受探索M集，或者自己设定参数值，看看还能发现什么其他特性。
- en: Summary
  id: totrans-309
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, you used Kotlin to explore the enigmatic beauty of fractals.
    You learned how to design recursive functions to help draw simple geometric fractals,
    and you developed an L-system simulator to generate intricate self-similar patterns
    based on strings of instructions and a few transformation rules. Finally, you
    created an application for visualizing the famous Mandelbrot set.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你使用Kotlin探索了分形的神秘之美。你学习了如何设计递归函数来帮助绘制简单的几何分形，并开发了一个L系统模拟器，通过一串指令和几个变换规则生成复杂的自相似模式。最后，你创建了一个用于可视化著名的曼德尔布罗特集的应用程序。
- en: No matter what the mathematical properties of a fractal are, you now have the
    tools to put together a few lines of code in Kotlin and JavaFX to render it. We’ve
    barely scratched the surface of fractal geometry, however. In particular, you
    have a lot to learn about the M-set that’s beyond the scope of this book. If this
    chapter has aroused your interest in fractals, I encourage you to check out the
    listed resources for further reading.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 无论分形的数学性质如何，你现在已经掌握了在Kotlin和JavaFX中编写几行代码来渲染它的工具。不过，我们仅仅触及了分形几何的皮毛。尤其是，你还有很多关于M集的知识需要学习，这超出了本书的范围。如果本章激发了你对分形的兴趣，我鼓励你查看列出的资源进行进一步阅读。
- en: Resources
  id: totrans-312
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 资源
- en: 'Devaney, Robert L. *An Introduction to Chaotic Dynamical Systems*. 3rd ed.
    Boca Raton, FL: CRC Press, 2022.'
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: Devaney, Robert L. *混沌动力系统导论*。第三版。佛罗里达州博卡拉顿：CRC出版社，2022年。
- en: 'Feldman, David P. *Chaos and Fractals: An Elementary Introduction*. Oxford,
    UK: Oxford University Press, 2012.'
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: Feldman, David P. *混沌与分形：基础入门*. 英国牛津：牛津大学出版社，2012年。
- en: 'Flake, Gary William. *The Computational Beauty of Nature: Computer Explorations
    of Fractals, Chaos, Complex Systems, and Adaptation*. Cambridge, MA: MIT Press,
    2000.'
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: Flake, Gary William. *自然的计算美学：计算机对分形、混沌、复杂系统与适应的探索*. 美国剑桥：MIT出版社，2000年。
- en: 'Mandelbrot, Benoit B. *The Fractal Geometry of Nature*. San Francisco: W. H.
    Freeman & Co., 1982.'
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: Mandelbrot, Benoit B. *自然的分形几何学*。旧金山：W. H. Freeman & Co.，1982年。
- en: Ponce Campuzano, Juan Carlos. “The Mandelbrot Set.” *Complex Analysis*. 2019\.
    Accessed June 15, 2024\. *[https://complex-analysis.com/content/mandelbrot_set.xhtml](https://complex-analysis.com/content/mandelbrot_set.xhtml)*.
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: Ponce Campuzano, Juan Carlos. “曼德尔布罗特集。” *复变函数分析*。2019年。访问日期：2024年6月15日。*[https://complex-analysis.com/content/mandelbrot_set.xhtml](https://complex-analysis.com/content/mandelbrot_set.xhtml)*。
- en: Prusinkiewicz, Przemyslaw, and Aristid Lindenmayer. *The Algorithmic Beauty
    of Plants*. Electronic version, 2004\. Accessed June 15, 2024\. *[http://<wbr>algorithmicbotany<wbr>.org<wbr>/papers<wbr>/abop<wbr>/abop<wbr>.pdf](http://algorithmicbotany.org/papers/abop/abop.pdf)*.
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: Prusinkiewicz, Przemyslaw 和 Aristid Lindenmayer. *植物的算法之美*. 电子版，2004年。访问日期：2024年6月15日。*[http://algorithmicbotany.org/papers/abop/abop.pdf](http://algorithmicbotany.org/papers/abop/abop.pdf)*。
- en: 'Prusinkiewicz, Przemyslaw, Aristid Lindenmayer, and F. David Fracchia. “Synthesis
    of Space-Filling Curves on the Square Grid.” In *Fractals in the Fundamental and
    Applied Sciences*, edited by Heinz-Otto Peitgen, José Marques Henriques, and Luís
    Filipe Penedo, 334–366\. North-Holland: Elsevier, 1991.'
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: Prusinkiewicz, Przemyslaw、Aristid Lindenmayer 和 F. David Fracchia. “在方格网格上合成空间填充曲线。”
    收录于 *分形在基础与应用科学中的应用*，由Heinz-Otto Peitgen, José Marques Henriques和Luís Filipe Penedo主编，334–366页。北荷兰：Elsevier，1991年。
- en: Weisstein, Eric W. “Mandelbrot Set.” Wolfram MathWorld. Accessed June 15, 2024\.
    *[https://mathworld.wolfram.com/MandelbrotSet.xhtml](https://mathworld.wolfram.com/MandelbrotSet.xhtml)*.
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: Weisstein, Eric W. “曼德尔布罗特集。” Wolfram MathWorld。访问日期：2024年6月15日。*[https://mathworld.wolfram.com/MandelbrotSet.xhtml](https://mathworld.wolfram.com/MandelbrotSet.xhtml)*。
